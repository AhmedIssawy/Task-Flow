module.exports = {

"[project]/node_modules/next/dist/compiled/@edge-runtime/cookies/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
// src/index.ts
var src_exports = {};
__export(src_exports, {
    RequestCookies: ()=>RequestCookies,
    ResponseCookies: ()=>ResponseCookies,
    parseCookie: ()=>parseCookie,
    parseSetCookie: ()=>parseSetCookie,
    stringifyCookie: ()=>stringifyCookie
});
module.exports = __toCommonJS(src_exports);
// src/serialize.ts
function stringifyCookie(c) {
    var _a;
    const attrs = [
        "path" in c && c.path && `Path=${c.path}`,
        "expires" in c && (c.expires || c.expires === 0) && `Expires=${(typeof c.expires === "number" ? new Date(c.expires) : c.expires).toUTCString()}`,
        "maxAge" in c && typeof c.maxAge === "number" && `Max-Age=${c.maxAge}`,
        "domain" in c && c.domain && `Domain=${c.domain}`,
        "secure" in c && c.secure && "Secure",
        "httpOnly" in c && c.httpOnly && "HttpOnly",
        "sameSite" in c && c.sameSite && `SameSite=${c.sameSite}`,
        "partitioned" in c && c.partitioned && "Partitioned",
        "priority" in c && c.priority && `Priority=${c.priority}`
    ].filter(Boolean);
    const stringified = `${c.name}=${encodeURIComponent((_a = c.value) != null ? _a : "")}`;
    return attrs.length === 0 ? stringified : `${stringified}; ${attrs.join("; ")}`;
}
function parseCookie(cookie) {
    const map = /* @__PURE__ */ new Map();
    for (const pair of cookie.split(/; */)){
        if (!pair) continue;
        const splitAt = pair.indexOf("=");
        if (splitAt === -1) {
            map.set(pair, "true");
            continue;
        }
        const [key, value] = [
            pair.slice(0, splitAt),
            pair.slice(splitAt + 1)
        ];
        try {
            map.set(key, decodeURIComponent(value != null ? value : "true"));
        } catch  {}
    }
    return map;
}
function parseSetCookie(setCookie) {
    if (!setCookie) {
        return void 0;
    }
    const [[name, value], ...attributes] = parseCookie(setCookie);
    const { domain, expires, httponly, maxage, path, samesite, secure, partitioned, priority } = Object.fromEntries(attributes.map(([key, value2])=>[
            key.toLowerCase().replace(/-/g, ""),
            value2
        ]));
    const cookie = {
        name,
        value: decodeURIComponent(value),
        domain,
        ...expires && {
            expires: new Date(expires)
        },
        ...httponly && {
            httpOnly: true
        },
        ...typeof maxage === "string" && {
            maxAge: Number(maxage)
        },
        path,
        ...samesite && {
            sameSite: parseSameSite(samesite)
        },
        ...secure && {
            secure: true
        },
        ...priority && {
            priority: parsePriority(priority)
        },
        ...partitioned && {
            partitioned: true
        }
    };
    return compact(cookie);
}
function compact(t) {
    const newT = {};
    for(const key in t){
        if (t[key]) {
            newT[key] = t[key];
        }
    }
    return newT;
}
var SAME_SITE = [
    "strict",
    "lax",
    "none"
];
function parseSameSite(string) {
    string = string.toLowerCase();
    return SAME_SITE.includes(string) ? string : void 0;
}
var PRIORITY = [
    "low",
    "medium",
    "high"
];
function parsePriority(string) {
    string = string.toLowerCase();
    return PRIORITY.includes(string) ? string : void 0;
}
function splitCookiesString(cookiesString) {
    if (!cookiesString) return [];
    var cookiesStrings = [];
    var pos = 0;
    var start;
    var ch;
    var lastComma;
    var nextStart;
    var cookiesSeparatorFound;
    function skipWhitespace() {
        while(pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))){
            pos += 1;
        }
        return pos < cookiesString.length;
    }
    function notSpecialChar() {
        ch = cookiesString.charAt(pos);
        return ch !== "=" && ch !== ";" && ch !== ",";
    }
    while(pos < cookiesString.length){
        start = pos;
        cookiesSeparatorFound = false;
        while(skipWhitespace()){
            ch = cookiesString.charAt(pos);
            if (ch === ",") {
                lastComma = pos;
                pos += 1;
                skipWhitespace();
                nextStart = pos;
                while(pos < cookiesString.length && notSpecialChar()){
                    pos += 1;
                }
                if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
                    cookiesSeparatorFound = true;
                    pos = nextStart;
                    cookiesStrings.push(cookiesString.substring(start, lastComma));
                    start = pos;
                } else {
                    pos = lastComma + 1;
                }
            } else {
                pos += 1;
            }
        }
        if (!cookiesSeparatorFound || pos >= cookiesString.length) {
            cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
        }
    }
    return cookiesStrings;
}
// src/request-cookies.ts
var RequestCookies = class {
    constructor(requestHeaders){
        /** @internal */ this._parsed = /* @__PURE__ */ new Map();
        this._headers = requestHeaders;
        const header = requestHeaders.get("cookie");
        if (header) {
            const parsed = parseCookie(header);
            for (const [name, value] of parsed){
                this._parsed.set(name, {
                    name,
                    value
                });
            }
        }
    }
    [Symbol.iterator]() {
        return this._parsed[Symbol.iterator]();
    }
    /**
   * The amount of cookies received from the client
   */ get size() {
        return this._parsed.size;
    }
    get(...args) {
        const name = typeof args[0] === "string" ? args[0] : args[0].name;
        return this._parsed.get(name);
    }
    getAll(...args) {
        var _a;
        const all = Array.from(this._parsed);
        if (!args.length) {
            return all.map(([_, value])=>value);
        }
        const name = typeof args[0] === "string" ? args[0] : (_a = args[0]) == null ? void 0 : _a.name;
        return all.filter(([n])=>n === name).map(([_, value])=>value);
    }
    has(name) {
        return this._parsed.has(name);
    }
    set(...args) {
        const [name, value] = args.length === 1 ? [
            args[0].name,
            args[0].value
        ] : args;
        const map = this._parsed;
        map.set(name, {
            name,
            value
        });
        this._headers.set("cookie", Array.from(map).map(([_, value2])=>stringifyCookie(value2)).join("; "));
        return this;
    }
    /**
   * Delete the cookies matching the passed name or names in the request.
   */ delete(names) {
        const map = this._parsed;
        const result = !Array.isArray(names) ? map.delete(names) : names.map((name)=>map.delete(name));
        this._headers.set("cookie", Array.from(map).map(([_, value])=>stringifyCookie(value)).join("; "));
        return result;
    }
    /**
   * Delete all the cookies in the cookies in the request.
   */ clear() {
        this.delete(Array.from(this._parsed.keys()));
        return this;
    }
    /**
   * Format the cookies in the request as a string for logging
   */ [Symbol.for("edge-runtime.inspect.custom")]() {
        return `RequestCookies ${JSON.stringify(Object.fromEntries(this._parsed))}`;
    }
    toString() {
        return [
            ...this._parsed.values()
        ].map((v)=>`${v.name}=${encodeURIComponent(v.value)}`).join("; ");
    }
};
// src/response-cookies.ts
var ResponseCookies = class {
    constructor(responseHeaders){
        /** @internal */ this._parsed = /* @__PURE__ */ new Map();
        var _a, _b, _c;
        this._headers = responseHeaders;
        const setCookie = (_c = (_b = (_a = responseHeaders.getSetCookie) == null ? void 0 : _a.call(responseHeaders)) != null ? _b : responseHeaders.get("set-cookie")) != null ? _c : [];
        const cookieStrings = Array.isArray(setCookie) ? setCookie : splitCookiesString(setCookie);
        for (const cookieString of cookieStrings){
            const parsed = parseSetCookie(cookieString);
            if (parsed) this._parsed.set(parsed.name, parsed);
        }
    }
    /**
   * {@link https://wicg.github.io/cookie-store/#CookieStore-get CookieStore#get} without the Promise.
   */ get(...args) {
        const key = typeof args[0] === "string" ? args[0] : args[0].name;
        return this._parsed.get(key);
    }
    /**
   * {@link https://wicg.github.io/cookie-store/#CookieStore-getAll CookieStore#getAll} without the Promise.
   */ getAll(...args) {
        var _a;
        const all = Array.from(this._parsed.values());
        if (!args.length) {
            return all;
        }
        const key = typeof args[0] === "string" ? args[0] : (_a = args[0]) == null ? void 0 : _a.name;
        return all.filter((c)=>c.name === key);
    }
    has(name) {
        return this._parsed.has(name);
    }
    /**
   * {@link https://wicg.github.io/cookie-store/#CookieStore-set CookieStore#set} without the Promise.
   */ set(...args) {
        const [name, value, cookie] = args.length === 1 ? [
            args[0].name,
            args[0].value,
            args[0]
        ] : args;
        const map = this._parsed;
        map.set(name, normalizeCookie({
            name,
            value,
            ...cookie
        }));
        replace(map, this._headers);
        return this;
    }
    /**
   * {@link https://wicg.github.io/cookie-store/#CookieStore-delete CookieStore#delete} without the Promise.
   */ delete(...args) {
        const [name, options] = typeof args[0] === "string" ? [
            args[0]
        ] : [
            args[0].name,
            args[0]
        ];
        return this.set({
            ...options,
            name,
            value: "",
            expires: /* @__PURE__ */ new Date(0)
        });
    }
    [Symbol.for("edge-runtime.inspect.custom")]() {
        return `ResponseCookies ${JSON.stringify(Object.fromEntries(this._parsed))}`;
    }
    toString() {
        return [
            ...this._parsed.values()
        ].map(stringifyCookie).join("; ");
    }
};
function replace(bag, headers) {
    headers.delete("set-cookie");
    for (const [, value] of bag){
        const serialized = stringifyCookie(value);
        headers.append("set-cookie", serialized);
    }
}
function normalizeCookie(cookie = {
    name: "",
    value: ""
}) {
    if (typeof cookie.expires === "number") {
        cookie.expires = new Date(cookie.expires);
    }
    if (cookie.maxAge) {
        cookie.expires = new Date(Date.now() + cookie.maxAge * 1e3);
    }
    if (cookie.path === null || cookie.path === void 0) {
        cookie.path = "/";
    }
    return cookie;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    RequestCookies,
    ResponseCookies,
    parseCookie,
    parseSetCookie,
    stringifyCookie
});
}}),
"[project]/node_modules/next/dist/server/web/spec-extension/cookies.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    RequestCookies: null,
    ResponseCookies: null,
    stringifyCookie: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    RequestCookies: function() {
        return _cookies.RequestCookies;
    },
    ResponseCookies: function() {
        return _cookies.ResponseCookies;
    },
    stringifyCookie: function() {
        return _cookies.stringifyCookie;
    }
});
const _cookies = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/@edge-runtime/cookies/index.js [app-ssr] (ecmascript)"); //# sourceMappingURL=cookies.js.map
}}),
"[project]/node_modules/next/dist/server/web/spec-extension/adapters/reflect.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "ReflectAdapter", {
    enumerable: true,
    get: function() {
        return ReflectAdapter;
    }
});
class ReflectAdapter {
    static get(target, prop, receiver) {
        const value = Reflect.get(target, prop, receiver);
        if (typeof value === 'function') {
            return value.bind(target);
        }
        return value;
    }
    static set(target, prop, value, receiver) {
        return Reflect.set(target, prop, value, receiver);
    }
    static has(target, prop) {
        return Reflect.has(target, prop);
    }
    static deleteProperty(target, prop) {
        return Reflect.deleteProperty(target, prop);
    }
} //# sourceMappingURL=reflect.js.map
}}),
"[project]/node_modules/next/dist/server/web/spec-extension/adapters/request-cookies.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    MutableRequestCookiesAdapter: null,
    ReadonlyRequestCookiesError: null,
    RequestCookiesAdapter: null,
    appendMutableCookies: null,
    areCookiesMutableInCurrentPhase: null,
    getModifiedCookieValues: null,
    responseCookiesToRequestCookies: null,
    wrapWithMutableAccessCheck: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    MutableRequestCookiesAdapter: function() {
        return MutableRequestCookiesAdapter;
    },
    ReadonlyRequestCookiesError: function() {
        return ReadonlyRequestCookiesError;
    },
    RequestCookiesAdapter: function() {
        return RequestCookiesAdapter;
    },
    appendMutableCookies: function() {
        return appendMutableCookies;
    },
    areCookiesMutableInCurrentPhase: function() {
        return areCookiesMutableInCurrentPhase;
    },
    getModifiedCookieValues: function() {
        return getModifiedCookieValues;
    },
    responseCookiesToRequestCookies: function() {
        return responseCookiesToRequestCookies;
    },
    wrapWithMutableAccessCheck: function() {
        return wrapWithMutableAccessCheck;
    }
});
const _cookies = __turbopack_context__.r("[project]/node_modules/next/dist/server/web/spec-extension/cookies.js [app-ssr] (ecmascript)");
const _reflect = __turbopack_context__.r("[project]/node_modules/next/dist/server/web/spec-extension/adapters/reflect.js [app-ssr] (ecmascript)");
const _workasyncstorageexternal = __turbopack_context__.r("[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)");
const _workunitasyncstorageexternal = __turbopack_context__.r("[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)");
class ReadonlyRequestCookiesError extends Error {
    constructor(){
        super('Cookies can only be modified in a Server Action or Route Handler. Read more: https://nextjs.org/docs/app/api-reference/functions/cookies#options');
    }
    static callable() {
        throw new ReadonlyRequestCookiesError();
    }
}
class RequestCookiesAdapter {
    static seal(cookies) {
        return new Proxy(cookies, {
            get (target, prop, receiver) {
                switch(prop){
                    case 'clear':
                    case 'delete':
                    case 'set':
                        return ReadonlyRequestCookiesError.callable;
                    default:
                        return _reflect.ReflectAdapter.get(target, prop, receiver);
                }
            }
        });
    }
}
const SYMBOL_MODIFY_COOKIE_VALUES = Symbol.for('next.mutated.cookies');
function getModifiedCookieValues(cookies) {
    const modified = cookies[SYMBOL_MODIFY_COOKIE_VALUES];
    if (!modified || !Array.isArray(modified) || modified.length === 0) {
        return [];
    }
    return modified;
}
function appendMutableCookies(headers, mutableCookies) {
    const modifiedCookieValues = getModifiedCookieValues(mutableCookies);
    if (modifiedCookieValues.length === 0) {
        return false;
    }
    // Return a new response that extends the response with
    // the modified cookies as fallbacks. `res` cookies
    // will still take precedence.
    const resCookies = new _cookies.ResponseCookies(headers);
    const returnedCookies = resCookies.getAll();
    // Set the modified cookies as fallbacks.
    for (const cookie of modifiedCookieValues){
        resCookies.set(cookie);
    }
    // Set the original cookies as the final values.
    for (const cookie of returnedCookies){
        resCookies.set(cookie);
    }
    return true;
}
class MutableRequestCookiesAdapter {
    static wrap(cookies, onUpdateCookies) {
        const responseCookies = new _cookies.ResponseCookies(new Headers());
        for (const cookie of cookies.getAll()){
            responseCookies.set(cookie);
        }
        let modifiedValues = [];
        const modifiedCookies = new Set();
        const updateResponseCookies = ()=>{
            // TODO-APP: change method of getting workStore
            const workStore = _workasyncstorageexternal.workAsyncStorage.getStore();
            if (workStore) {
                workStore.pathWasRevalidated = true;
            }
            const allCookies = responseCookies.getAll();
            modifiedValues = allCookies.filter((c)=>modifiedCookies.has(c.name));
            if (onUpdateCookies) {
                const serializedCookies = [];
                for (const cookie of modifiedValues){
                    const tempCookies = new _cookies.ResponseCookies(new Headers());
                    tempCookies.set(cookie);
                    serializedCookies.push(tempCookies.toString());
                }
                onUpdateCookies(serializedCookies);
            }
        };
        const wrappedCookies = new Proxy(responseCookies, {
            get (target, prop, receiver) {
                switch(prop){
                    // A special symbol to get the modified cookie values
                    case SYMBOL_MODIFY_COOKIE_VALUES:
                        return modifiedValues;
                    // TODO: Throw error if trying to set a cookie after the response
                    // headers have been set.
                    case 'delete':
                        return function(...args) {
                            modifiedCookies.add(typeof args[0] === 'string' ? args[0] : args[0].name);
                            try {
                                target.delete(...args);
                                return wrappedCookies;
                            } finally{
                                updateResponseCookies();
                            }
                        };
                    case 'set':
                        return function(...args) {
                            modifiedCookies.add(typeof args[0] === 'string' ? args[0] : args[0].name);
                            try {
                                target.set(...args);
                                return wrappedCookies;
                            } finally{
                                updateResponseCookies();
                            }
                        };
                    default:
                        return _reflect.ReflectAdapter.get(target, prop, receiver);
                }
            }
        });
        return wrappedCookies;
    }
}
function wrapWithMutableAccessCheck(responseCookies) {
    const wrappedCookies = new Proxy(responseCookies, {
        get (target, prop, receiver) {
            switch(prop){
                case 'delete':
                    return function(...args) {
                        ensureCookiesAreStillMutable('cookies().delete');
                        target.delete(...args);
                        return wrappedCookies;
                    };
                case 'set':
                    return function(...args) {
                        ensureCookiesAreStillMutable('cookies().set');
                        target.set(...args);
                        return wrappedCookies;
                    };
                default:
                    return _reflect.ReflectAdapter.get(target, prop, receiver);
            }
        }
    });
    return wrappedCookies;
}
function areCookiesMutableInCurrentPhase(requestStore) {
    return requestStore.phase === 'action';
}
/** Ensure that cookies() starts throwing on mutation
 * if we changed phases and can no longer mutate.
 *
 * This can happen when going:
 *   'render' -> 'after'
 *   'action' -> 'render'
 * */ function ensureCookiesAreStillMutable(callingExpression) {
    const requestStore = (0, _workunitasyncstorageexternal.getExpectedRequestStore)(callingExpression);
    if (!areCookiesMutableInCurrentPhase(requestStore)) {
        // TODO: maybe we can give a more precise error message based on callingExpression?
        throw new ReadonlyRequestCookiesError();
    }
}
function responseCookiesToRequestCookies(responseCookies) {
    const requestCookies = new _cookies.RequestCookies(new Headers());
    for (const cookie of responseCookies.getAll()){
        requestCookies.set(cookie);
    }
    return requestCookies;
} //# sourceMappingURL=request-cookies.js.map
}}),
"[project]/node_modules/next/dist/server/create-deduped-by-callsite-server-error-logger.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "createDedupedByCallsiteServerErrorLoggerDev", {
    enumerable: true,
    get: function() {
        return createDedupedByCallsiteServerErrorLoggerDev;
    }
});
const _react = /*#__PURE__*/ _interop_require_wildcard(__turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)"));
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const errorRef = {
    current: null
};
// React.cache is currently only available in canary/experimental React channels.
const cache = typeof _react.cache === 'function' ? _react.cache : (fn)=>fn;
// When Dynamic IO is enabled, we record these as errors so that they
// are captured by the dev overlay as it's more critical to fix these
// when enabled.
const logErrorOrWarn = ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : console.warn;
// We don't want to dedupe across requests.
// The developer might've just attempted to fix the warning so we should warn again if it still happens.
const flushCurrentErrorIfNew = cache((key)=>{
    try {
        logErrorOrWarn(errorRef.current);
    } finally{
        errorRef.current = null;
    }
});
function createDedupedByCallsiteServerErrorLoggerDev(getMessage) {
    return function logDedupedError(...args) {
        const message = getMessage(...args);
        if ("TURBOPACK compile-time truthy", 1) {
            var _stack;
            const callStackFrames = (_stack = new Error().stack) == null ? void 0 : _stack.split('\n');
            if (callStackFrames === undefined || callStackFrames.length < 4) {
                logErrorOrWarn(message);
            } else {
                // Error:
                //   logDedupedError
                //   asyncApiBeingAccessedSynchronously
                //   <userland callsite>
                // TODO: This breaks if sourcemaps with ignore lists are enabled.
                const key = callStackFrames[4];
                errorRef.current = message;
                flushCurrentErrorIfNew(key);
            }
        } else //TURBOPACK unreachable
        ;
    };
} //# sourceMappingURL=create-deduped-by-callsite-server-error-logger.js.map
}}),
"[project]/node_modules/next/dist/server/request/utils.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    isRequestAPICallableInsideAfter: null,
    throwForSearchParamsAccessInUseCache: null,
    throwWithStaticGenerationBailoutError: null,
    throwWithStaticGenerationBailoutErrorWithDynamicError: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    isRequestAPICallableInsideAfter: function() {
        return isRequestAPICallableInsideAfter;
    },
    throwForSearchParamsAccessInUseCache: function() {
        return throwForSearchParamsAccessInUseCache;
    },
    throwWithStaticGenerationBailoutError: function() {
        return throwWithStaticGenerationBailoutError;
    },
    throwWithStaticGenerationBailoutErrorWithDynamicError: function() {
        return throwWithStaticGenerationBailoutErrorWithDynamicError;
    }
});
const _staticgenerationbailout = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/static-generation-bailout.js [app-ssr] (ecmascript)");
const _aftertaskasyncstorageexternal = __turbopack_context__.r("[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)");
function throwWithStaticGenerationBailoutError(route, expression) {
    throw Object.defineProperty(new _staticgenerationbailout.StaticGenBailoutError(`Route ${route} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`), "__NEXT_ERROR_CODE", {
        value: "E576",
        enumerable: false,
        configurable: true
    });
}
function throwWithStaticGenerationBailoutErrorWithDynamicError(route, expression) {
    throw Object.defineProperty(new _staticgenerationbailout.StaticGenBailoutError(`Route ${route} with \`dynamic = "error"\` couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`), "__NEXT_ERROR_CODE", {
        value: "E543",
        enumerable: false,
        configurable: true
    });
}
function throwForSearchParamsAccessInUseCache(workStore, constructorOpt) {
    const error = Object.defineProperty(new Error(`Route ${workStore.route} used "searchParams" inside "use cache". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use "searchParams" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`), "__NEXT_ERROR_CODE", {
        value: "E634",
        enumerable: false,
        configurable: true
    });
    Error.captureStackTrace(error, constructorOpt);
    workStore.invalidDynamicUsageError ??= error;
    throw error;
}
function isRequestAPICallableInsideAfter() {
    const afterTaskStore = _aftertaskasyncstorageexternal.afterTaskAsyncStorage.getStore();
    return (afterTaskStore == null ? void 0 : afterTaskStore.rootTaskSpawnPhase) === 'action';
} //# sourceMappingURL=utils.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/invariant-error.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "InvariantError", {
    enumerable: true,
    get: function() {
        return InvariantError;
    }
});
class InvariantError extends Error {
    constructor(message, options){
        super("Invariant: " + (message.endsWith('.') ? message : message + '.') + " This is a bug in Next.js.", options);
        this.name = 'InvariantError';
    }
} //# sourceMappingURL=invariant-error.js.map
}}),
"[project]/node_modules/next/dist/server/request/cookies.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "cookies", {
    enumerable: true,
    get: function() {
        return cookies;
    }
});
const _requestcookies = __turbopack_context__.r("[project]/node_modules/next/dist/server/web/spec-extension/adapters/request-cookies.js [app-ssr] (ecmascript)");
const _cookies = __turbopack_context__.r("[project]/node_modules/next/dist/server/web/spec-extension/cookies.js [app-ssr] (ecmascript)");
const _workasyncstorageexternal = __turbopack_context__.r("[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)");
const _workunitasyncstorageexternal = __turbopack_context__.r("[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)");
const _dynamicrendering = __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/dynamic-rendering.js [app-ssr] (ecmascript)");
const _staticgenerationbailout = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/static-generation-bailout.js [app-ssr] (ecmascript)");
const _dynamicrenderingutils = __turbopack_context__.r("[project]/node_modules/next/dist/server/dynamic-rendering-utils.js [app-ssr] (ecmascript)");
const _creatededupedbycallsiteservererrorlogger = __turbopack_context__.r("[project]/node_modules/next/dist/server/create-deduped-by-callsite-server-error-logger.js [app-ssr] (ecmascript)");
const _scheduler = __turbopack_context__.r("[project]/node_modules/next/dist/lib/scheduler.js [app-ssr] (ecmascript)");
const _utils = __turbopack_context__.r("[project]/node_modules/next/dist/server/request/utils.js [app-ssr] (ecmascript)");
const _invarianterror = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/invariant-error.js [app-ssr] (ecmascript)");
const _reflect = __turbopack_context__.r("[project]/node_modules/next/dist/server/web/spec-extension/adapters/reflect.js [app-ssr] (ecmascript)");
function cookies() {
    const callingExpression = 'cookies';
    const workStore = _workasyncstorageexternal.workAsyncStorage.getStore();
    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
    if (workStore) {
        if (workUnitStore && workUnitStore.phase === 'after' && !(0, _utils.isRequestAPICallableInsideAfter)()) {
            throw Object.defineProperty(new Error(`Route ${workStore.route} used "cookies" inside "after(...)". This is not supported. If you need this data inside an "after" callback, use "cookies" outside of the callback. See more info here: https://nextjs.org/docs/canary/app/api-reference/functions/after`), "__NEXT_ERROR_CODE", {
                value: "E88",
                enumerable: false,
                configurable: true
            });
        }
        if (workStore.forceStatic) {
            // When using forceStatic we override all other logic and always just return an empty
            // cookies object without tracking
            const underlyingCookies = createEmptyCookies();
            return makeUntrackedExoticCookies(underlyingCookies);
        }
        if (workUnitStore) {
            if (workUnitStore.type === 'cache') {
                throw Object.defineProperty(new Error(`Route ${workStore.route} used "cookies" inside "use cache". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use "cookies" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`), "__NEXT_ERROR_CODE", {
                    value: "E398",
                    enumerable: false,
                    configurable: true
                });
            } else if (workUnitStore.type === 'unstable-cache') {
                throw Object.defineProperty(new Error(`Route ${workStore.route} used "cookies" inside a function cached with "unstable_cache(...)". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use "cookies" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`), "__NEXT_ERROR_CODE", {
                    value: "E157",
                    enumerable: false,
                    configurable: true
                });
            }
        }
        if (workStore.dynamicShouldError) {
            throw Object.defineProperty(new _staticgenerationbailout.StaticGenBailoutError(`Route ${workStore.route} with \`dynamic = "error"\` couldn't be rendered statically because it used \`cookies\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`), "__NEXT_ERROR_CODE", {
                value: "E549",
                enumerable: false,
                configurable: true
            });
        }
        if (workUnitStore) {
            switch(workUnitStore.type){
                case 'prerender':
                    return makeHangingCookies(workUnitStore);
                case 'prerender-client':
                    const exportName = '`cookies`';
                    throw Object.defineProperty(new _invarianterror.InvariantError(`${exportName} must not be used within a client component. Next.js should be preventing ${exportName} from being included in client components statically, but did not in this case.`), "__NEXT_ERROR_CODE", {
                        value: "E693",
                        enumerable: false,
                        configurable: true
                    });
                case 'prerender-ppr':
                    // PPR Prerender (no dynamicIO)
                    // We are prerendering with PPR. We need track dynamic access here eagerly
                    // to keep continuity with how cookies has worked in PPR without dynamicIO.
                    (0, _dynamicrendering.postponeWithTracking)(workStore.route, callingExpression, workUnitStore.dynamicTracking);
                    break;
                case 'prerender-legacy':
                    // Legacy Prerender
                    // We track dynamic access here so we don't need to wrap the cookies in
                    // individual property access tracking.
                    (0, _dynamicrendering.throwToInterruptStaticGeneration)(callingExpression, workStore, workUnitStore);
                    break;
                default:
            }
        }
        // We fall through to the dynamic context below but we still track dynamic access
        // because in dev we can still error for things like using cookies inside a cache context
        (0, _dynamicrendering.trackDynamicDataInDynamicRender)(workStore, workUnitStore);
    }
    // cookies is being called in a dynamic context
    const requestStore = (0, _workunitasyncstorageexternal.getExpectedRequestStore)(callingExpression);
    let underlyingCookies;
    if ((0, _requestcookies.areCookiesMutableInCurrentPhase)(requestStore)) {
        // We can't conditionally return different types here based on the context.
        // To avoid confusion, we always return the readonly type here.
        underlyingCookies = requestStore.userspaceMutableCookies;
    } else {
        underlyingCookies = requestStore.cookies;
    }
    if (("TURBOPACK compile-time value", "development") === 'development' && !(workStore == null ? void 0 : workStore.isPrefetchRequest)) {
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        return makeUntrackedExoticCookiesWithDevWarnings(underlyingCookies, workStore == null ? void 0 : workStore.route);
    } else {
        return makeUntrackedExoticCookies(underlyingCookies);
    }
}
function createEmptyCookies() {
    return _requestcookies.RequestCookiesAdapter.seal(new _cookies.RequestCookies(new Headers({})));
}
const CachedCookies = new WeakMap();
function makeHangingCookies(prerenderStore) {
    const cachedPromise = CachedCookies.get(prerenderStore);
    if (cachedPromise) {
        return cachedPromise;
    }
    const promise = (0, _dynamicrenderingutils.makeHangingPromise)(prerenderStore.renderSignal, '`cookies()`');
    CachedCookies.set(prerenderStore, promise);
    return promise;
}
function makeUntrackedExoticCookies(underlyingCookies) {
    const cachedCookies = CachedCookies.get(underlyingCookies);
    if (cachedCookies) {
        return cachedCookies;
    }
    const promise = Promise.resolve(underlyingCookies);
    CachedCookies.set(underlyingCookies, promise);
    Object.defineProperties(promise, {
        [Symbol.iterator]: {
            value: underlyingCookies[Symbol.iterator] ? underlyingCookies[Symbol.iterator].bind(underlyingCookies) : // but that's already a hard thing to debug so we may as well implement it consistently. The biggest problem with
            // implementing this in this way is the underlying cookie type is a ResponseCookie and not a RequestCookie and so it
            // has extra properties not available on RequestCookie instances.
            polyfilledResponseCookiesIterator.bind(underlyingCookies)
        },
        size: {
            get () {
                return underlyingCookies.size;
            }
        },
        get: {
            value: underlyingCookies.get.bind(underlyingCookies)
        },
        getAll: {
            value: underlyingCookies.getAll.bind(underlyingCookies)
        },
        has: {
            value: underlyingCookies.has.bind(underlyingCookies)
        },
        set: {
            value: underlyingCookies.set.bind(underlyingCookies)
        },
        delete: {
            value: underlyingCookies.delete.bind(underlyingCookies)
        },
        clear: {
            value: typeof underlyingCookies.clear === 'function' ? underlyingCookies.clear.bind(underlyingCookies) : // but that's already a hard thing to debug so we may as well implement it consistently. The biggest problem with
            // implementing this in this way is the underlying cookie type is a ResponseCookie and not a RequestCookie and so it
            // has extra properties not available on RequestCookie instances.
            polyfilledResponseCookiesClear.bind(underlyingCookies, promise)
        },
        toString: {
            value: underlyingCookies.toString.bind(underlyingCookies)
        }
    });
    return promise;
}
function makeUntrackedExoticCookiesWithDevWarnings(underlyingCookies, route) {
    const cachedCookies = CachedCookies.get(underlyingCookies);
    if (cachedCookies) {
        return cachedCookies;
    }
    const promise = new Promise((resolve)=>(0, _scheduler.scheduleImmediate)(()=>resolve(underlyingCookies)));
    CachedCookies.set(underlyingCookies, promise);
    Object.defineProperties(promise, {
        [Symbol.iterator]: {
            value: function() {
                const expression = '`...cookies()` or similar iteration';
                syncIODev(route, expression);
                return underlyingCookies[Symbol.iterator] ? underlyingCookies[Symbol.iterator].apply(underlyingCookies, arguments) : // but that's already a hard thing to debug so we may as well implement it consistently. The biggest problem with
                // implementing this in this way is the underlying cookie type is a ResponseCookie and not a RequestCookie and so it
                // has extra properties not available on RequestCookie instances.
                polyfilledResponseCookiesIterator.call(underlyingCookies);
            },
            writable: false
        },
        size: {
            get () {
                const expression = '`cookies().size`';
                syncIODev(route, expression);
                return underlyingCookies.size;
            }
        },
        get: {
            value: function get() {
                let expression;
                if (arguments.length === 0) {
                    expression = '`cookies().get()`';
                } else {
                    expression = `\`cookies().get(${describeNameArg(arguments[0])})\``;
                }
                syncIODev(route, expression);
                return underlyingCookies.get.apply(underlyingCookies, arguments);
            },
            writable: false
        },
        getAll: {
            value: function getAll() {
                let expression;
                if (arguments.length === 0) {
                    expression = '`cookies().getAll()`';
                } else {
                    expression = `\`cookies().getAll(${describeNameArg(arguments[0])})\``;
                }
                syncIODev(route, expression);
                return underlyingCookies.getAll.apply(underlyingCookies, arguments);
            },
            writable: false
        },
        has: {
            value: function get() {
                let expression;
                if (arguments.length === 0) {
                    expression = '`cookies().has()`';
                } else {
                    expression = `\`cookies().has(${describeNameArg(arguments[0])})\``;
                }
                syncIODev(route, expression);
                return underlyingCookies.has.apply(underlyingCookies, arguments);
            },
            writable: false
        },
        set: {
            value: function set() {
                let expression;
                if (arguments.length === 0) {
                    expression = '`cookies().set()`';
                } else {
                    const arg = arguments[0];
                    if (arg) {
                        expression = `\`cookies().set(${describeNameArg(arg)}, ...)\``;
                    } else {
                        expression = '`cookies().set(...)`';
                    }
                }
                syncIODev(route, expression);
                return underlyingCookies.set.apply(underlyingCookies, arguments);
            },
            writable: false
        },
        delete: {
            value: function() {
                let expression;
                if (arguments.length === 0) {
                    expression = '`cookies().delete()`';
                } else if (arguments.length === 1) {
                    expression = `\`cookies().delete(${describeNameArg(arguments[0])})\``;
                } else {
                    expression = `\`cookies().delete(${describeNameArg(arguments[0])}, ...)\``;
                }
                syncIODev(route, expression);
                return underlyingCookies.delete.apply(underlyingCookies, arguments);
            },
            writable: false
        },
        clear: {
            value: function clear() {
                const expression = '`cookies().clear()`';
                syncIODev(route, expression);
                // @ts-ignore clear is defined in RequestCookies implementation but not in the type
                return typeof underlyingCookies.clear === 'function' ? underlyingCookies.clear.apply(underlyingCookies, arguments) : // but that's already a hard thing to debug so we may as well implement it consistently. The biggest problem with
                // implementing this in this way is the underlying cookie type is a ResponseCookie and not a RequestCookie and so it
                // has extra properties not available on RequestCookie instances.
                polyfilledResponseCookiesClear.call(underlyingCookies, promise);
            },
            writable: false
        },
        toString: {
            value: function toString() {
                const expression = '`cookies().toString()` or implicit casting';
                syncIODev(route, expression);
                return underlyingCookies.toString.apply(underlyingCookies, arguments);
            },
            writable: false
        }
    });
    return promise;
}
// Similar to `makeUntrackedExoticCookiesWithDevWarnings`, but just logging the
// sync access without actually defining the cookies properties on the promise.
function makeUntrackedCookiesWithDevWarnings(underlyingCookies, route) {
    const cachedCookies = CachedCookies.get(underlyingCookies);
    if (cachedCookies) {
        return cachedCookies;
    }
    const promise = new Promise((resolve)=>(0, _scheduler.scheduleImmediate)(()=>resolve(underlyingCookies)));
    const proxiedPromise = new Proxy(promise, {
        get (target, prop, receiver) {
            switch(prop){
                case Symbol.iterator:
                    {
                        warnForSyncAccess(route, '`...cookies()` or similar iteration');
                        break;
                    }
                case 'size':
                case 'get':
                case 'getAll':
                case 'has':
                case 'set':
                case 'delete':
                case 'clear':
                case 'toString':
                    {
                        warnForSyncAccess(route, `\`cookies().${prop}\``);
                        break;
                    }
                default:
                    {
                    // We only warn for well-defined properties of the cookies object.
                    }
            }
            return _reflect.ReflectAdapter.get(target, prop, receiver);
        }
    });
    CachedCookies.set(underlyingCookies, proxiedPromise);
    return proxiedPromise;
}
function describeNameArg(arg) {
    return typeof arg === 'object' && arg !== null && typeof arg.name === 'string' ? `'${arg.name}'` : typeof arg === 'string' ? `'${arg}'` : '...';
}
function syncIODev(route, expression) {
    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
    if (workUnitStore && workUnitStore.type === 'request' && workUnitStore.prerenderPhase === true) {
        // When we're rendering dynamically in dev we need to advance out of the
        // Prerender environment when we read Request data synchronously
        const requestStore = workUnitStore;
        (0, _dynamicrendering.trackSynchronousRequestDataAccessInDev)(requestStore);
    }
    // In all cases we warn normally
    warnForSyncAccess(route, expression);
}
const warnForSyncAccess = (0, _creatededupedbycallsiteservererrorlogger.createDedupedByCallsiteServerErrorLoggerDev)(createCookiesAccessError);
function createCookiesAccessError(route, expression) {
    const prefix = route ? `Route "${route}" ` : 'This route ';
    return Object.defineProperty(new Error(`${prefix}used ${expression}. ` + `\`cookies()\` should be awaited before using its value. ` + `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`), "__NEXT_ERROR_CODE", {
        value: "E223",
        enumerable: false,
        configurable: true
    });
}
function polyfilledResponseCookiesIterator() {
    return this.getAll().map((c)=>[
            c.name,
            c
        ]).values();
}
function polyfilledResponseCookiesClear(returnable) {
    for (const cookie of this.getAll()){
        this.delete(cookie.name);
    }
    return returnable;
} //# sourceMappingURL=cookies.js.map
}}),
"[project]/node_modules/next/dist/server/web/spec-extension/adapters/headers.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    HeadersAdapter: null,
    ReadonlyHeadersError: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    HeadersAdapter: function() {
        return HeadersAdapter;
    },
    ReadonlyHeadersError: function() {
        return ReadonlyHeadersError;
    }
});
const _reflect = __turbopack_context__.r("[project]/node_modules/next/dist/server/web/spec-extension/adapters/reflect.js [app-ssr] (ecmascript)");
class ReadonlyHeadersError extends Error {
    constructor(){
        super('Headers cannot be modified. Read more: https://nextjs.org/docs/app/api-reference/functions/headers');
    }
    static callable() {
        throw new ReadonlyHeadersError();
    }
}
class HeadersAdapter extends Headers {
    constructor(headers){
        // We've already overridden the methods that would be called, so we're just
        // calling the super constructor to ensure that the instanceof check works.
        super();
        this.headers = new Proxy(headers, {
            get (target, prop, receiver) {
                // Because this is just an object, we expect that all "get" operations
                // are for properties. If it's a "get" for a symbol, we'll just return
                // the symbol.
                if (typeof prop === 'symbol') {
                    return _reflect.ReflectAdapter.get(target, prop, receiver);
                }
                const lowercased = prop.toLowerCase();
                // Let's find the original casing of the key. This assumes that there is
                // no mixed case keys (e.g. "Content-Type" and "content-type") in the
                // headers object.
                const original = Object.keys(headers).find((o)=>o.toLowerCase() === lowercased);
                // If the original casing doesn't exist, return undefined.
                if (typeof original === 'undefined') return;
                // If the original casing exists, return the value.
                return _reflect.ReflectAdapter.get(target, original, receiver);
            },
            set (target, prop, value, receiver) {
                if (typeof prop === 'symbol') {
                    return _reflect.ReflectAdapter.set(target, prop, value, receiver);
                }
                const lowercased = prop.toLowerCase();
                // Let's find the original casing of the key. This assumes that there is
                // no mixed case keys (e.g. "Content-Type" and "content-type") in the
                // headers object.
                const original = Object.keys(headers).find((o)=>o.toLowerCase() === lowercased);
                // If the original casing doesn't exist, use the prop as the key.
                return _reflect.ReflectAdapter.set(target, original ?? prop, value, receiver);
            },
            has (target, prop) {
                if (typeof prop === 'symbol') return _reflect.ReflectAdapter.has(target, prop);
                const lowercased = prop.toLowerCase();
                // Let's find the original casing of the key. This assumes that there is
                // no mixed case keys (e.g. "Content-Type" and "content-type") in the
                // headers object.
                const original = Object.keys(headers).find((o)=>o.toLowerCase() === lowercased);
                // If the original casing doesn't exist, return false.
                if (typeof original === 'undefined') return false;
                // If the original casing exists, return true.
                return _reflect.ReflectAdapter.has(target, original);
            },
            deleteProperty (target, prop) {
                if (typeof prop === 'symbol') return _reflect.ReflectAdapter.deleteProperty(target, prop);
                const lowercased = prop.toLowerCase();
                // Let's find the original casing of the key. This assumes that there is
                // no mixed case keys (e.g. "Content-Type" and "content-type") in the
                // headers object.
                const original = Object.keys(headers).find((o)=>o.toLowerCase() === lowercased);
                // If the original casing doesn't exist, return true.
                if (typeof original === 'undefined') return true;
                // If the original casing exists, delete the property.
                return _reflect.ReflectAdapter.deleteProperty(target, original);
            }
        });
    }
    /**
   * Seals a Headers instance to prevent modification by throwing an error when
   * any mutating method is called.
   */ static seal(headers) {
        return new Proxy(headers, {
            get (target, prop, receiver) {
                switch(prop){
                    case 'append':
                    case 'delete':
                    case 'set':
                        return ReadonlyHeadersError.callable;
                    default:
                        return _reflect.ReflectAdapter.get(target, prop, receiver);
                }
            }
        });
    }
    /**
   * Merges a header value into a string. This stores multiple values as an
   * array, so we need to merge them into a string.
   *
   * @param value a header value
   * @returns a merged header value (a string)
   */ merge(value) {
        if (Array.isArray(value)) return value.join(', ');
        return value;
    }
    /**
   * Creates a Headers instance from a plain object or a Headers instance.
   *
   * @param headers a plain object or a Headers instance
   * @returns a headers instance
   */ static from(headers) {
        if (headers instanceof Headers) return headers;
        return new HeadersAdapter(headers);
    }
    append(name, value) {
        const existing = this.headers[name];
        if (typeof existing === 'string') {
            this.headers[name] = [
                existing,
                value
            ];
        } else if (Array.isArray(existing)) {
            existing.push(value);
        } else {
            this.headers[name] = value;
        }
    }
    delete(name) {
        delete this.headers[name];
    }
    get(name) {
        const value = this.headers[name];
        if (typeof value !== 'undefined') return this.merge(value);
        return null;
    }
    has(name) {
        return typeof this.headers[name] !== 'undefined';
    }
    set(name, value) {
        this.headers[name] = value;
    }
    forEach(callbackfn, thisArg) {
        for (const [name, value] of this.entries()){
            callbackfn.call(thisArg, value, name, this);
        }
    }
    *entries() {
        for (const key of Object.keys(this.headers)){
            const name = key.toLowerCase();
            // We assert here that this is a string because we got it from the
            // Object.keys() call above.
            const value = this.get(name);
            yield [
                name,
                value
            ];
        }
    }
    *keys() {
        for (const key of Object.keys(this.headers)){
            const name = key.toLowerCase();
            yield name;
        }
    }
    *values() {
        for (const key of Object.keys(this.headers)){
            // We assert here that this is a string because we got it from the
            // Object.keys() call above.
            const value = this.get(key);
            yield value;
        }
    }
    [Symbol.iterator]() {
        return this.entries();
    }
} //# sourceMappingURL=headers.js.map
}}),
"[project]/node_modules/next/dist/server/request/headers.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "headers", {
    enumerable: true,
    get: function() {
        return headers;
    }
});
const _headers = __turbopack_context__.r("[project]/node_modules/next/dist/server/web/spec-extension/adapters/headers.js [app-ssr] (ecmascript)");
const _workasyncstorageexternal = __turbopack_context__.r("[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)");
const _workunitasyncstorageexternal = __turbopack_context__.r("[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)");
const _dynamicrendering = __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/dynamic-rendering.js [app-ssr] (ecmascript)");
const _staticgenerationbailout = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/static-generation-bailout.js [app-ssr] (ecmascript)");
const _dynamicrenderingutils = __turbopack_context__.r("[project]/node_modules/next/dist/server/dynamic-rendering-utils.js [app-ssr] (ecmascript)");
const _creatededupedbycallsiteservererrorlogger = __turbopack_context__.r("[project]/node_modules/next/dist/server/create-deduped-by-callsite-server-error-logger.js [app-ssr] (ecmascript)");
const _scheduler = __turbopack_context__.r("[project]/node_modules/next/dist/lib/scheduler.js [app-ssr] (ecmascript)");
const _utils = __turbopack_context__.r("[project]/node_modules/next/dist/server/request/utils.js [app-ssr] (ecmascript)");
const _invarianterror = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/invariant-error.js [app-ssr] (ecmascript)");
const _reflect = __turbopack_context__.r("[project]/node_modules/next/dist/server/web/spec-extension/adapters/reflect.js [app-ssr] (ecmascript)");
function headers() {
    const workStore = _workasyncstorageexternal.workAsyncStorage.getStore();
    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
    if (workStore) {
        if (workUnitStore && workUnitStore.phase === 'after' && !(0, _utils.isRequestAPICallableInsideAfter)()) {
            throw Object.defineProperty(new Error(`Route ${workStore.route} used "headers" inside "after(...)". This is not supported. If you need this data inside an "after" callback, use "headers" outside of the callback. See more info here: https://nextjs.org/docs/canary/app/api-reference/functions/after`), "__NEXT_ERROR_CODE", {
                value: "E367",
                enumerable: false,
                configurable: true
            });
        }
        if (workStore.forceStatic) {
            // When using forceStatic we override all other logic and always just return an empty
            // headers object without tracking
            const underlyingHeaders = _headers.HeadersAdapter.seal(new Headers({}));
            return makeUntrackedExoticHeaders(underlyingHeaders);
        }
        if (workUnitStore) {
            if (workUnitStore.type === 'cache') {
                throw Object.defineProperty(new Error(`Route ${workStore.route} used "headers" inside "use cache". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use "headers" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`), "__NEXT_ERROR_CODE", {
                    value: "E304",
                    enumerable: false,
                    configurable: true
                });
            } else if (workUnitStore.type === 'unstable-cache') {
                throw Object.defineProperty(new Error(`Route ${workStore.route} used "headers" inside a function cached with "unstable_cache(...)". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use "headers" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`), "__NEXT_ERROR_CODE", {
                    value: "E127",
                    enumerable: false,
                    configurable: true
                });
            }
        }
        if (workStore.dynamicShouldError) {
            throw Object.defineProperty(new _staticgenerationbailout.StaticGenBailoutError(`Route ${workStore.route} with \`dynamic = "error"\` couldn't be rendered statically because it used \`headers\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`), "__NEXT_ERROR_CODE", {
                value: "E525",
                enumerable: false,
                configurable: true
            });
        }
        if (workUnitStore) {
            switch(workUnitStore.type){
                case 'prerender':
                    return makeHangingHeaders(workUnitStore);
                case 'prerender-client':
                    const exportName = '`headers`';
                    throw Object.defineProperty(new _invarianterror.InvariantError(`${exportName} must not be used within a client component. Next.js should be preventing ${exportName} from being included in client components statically, but did not in this case.`), "__NEXT_ERROR_CODE", {
                        value: "E693",
                        enumerable: false,
                        configurable: true
                    });
                case 'prerender-ppr':
                    // PPR Prerender (no dynamicIO)
                    // We are prerendering with PPR. We need track dynamic access here eagerly
                    // to keep continuity with how headers has worked in PPR without dynamicIO.
                    // TODO consider switching the semantic to throw on property access instead
                    (0, _dynamicrendering.postponeWithTracking)(workStore.route, 'headers', workUnitStore.dynamicTracking);
                    break;
                case 'prerender-legacy':
                    // Legacy Prerender
                    // We are in a legacy static generation mode while prerendering
                    // We track dynamic access here so we don't need to wrap the headers in
                    // individual property access tracking.
                    (0, _dynamicrendering.throwToInterruptStaticGeneration)('headers', workStore, workUnitStore);
                    break;
                default:
            }
        }
        // We fall through to the dynamic context below but we still track dynamic access
        // because in dev we can still error for things like using headers inside a cache context
        (0, _dynamicrendering.trackDynamicDataInDynamicRender)(workStore, workUnitStore);
    }
    const requestStore = (0, _workunitasyncstorageexternal.getExpectedRequestStore)('headers');
    if (("TURBOPACK compile-time value", "development") === 'development' && !(workStore == null ? void 0 : workStore.isPrefetchRequest)) {
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        return makeUntrackedExoticHeadersWithDevWarnings(requestStore.headers, workStore == null ? void 0 : workStore.route);
    } else {
        return makeUntrackedExoticHeaders(requestStore.headers);
    }
}
const CachedHeaders = new WeakMap();
function makeHangingHeaders(prerenderStore) {
    const cachedHeaders = CachedHeaders.get(prerenderStore);
    if (cachedHeaders) {
        return cachedHeaders;
    }
    const promise = (0, _dynamicrenderingutils.makeHangingPromise)(prerenderStore.renderSignal, '`headers()`');
    CachedHeaders.set(prerenderStore, promise);
    return promise;
}
function makeUntrackedExoticHeaders(underlyingHeaders) {
    const cachedHeaders = CachedHeaders.get(underlyingHeaders);
    if (cachedHeaders) {
        return cachedHeaders;
    }
    const promise = Promise.resolve(underlyingHeaders);
    CachedHeaders.set(underlyingHeaders, promise);
    Object.defineProperties(promise, {
        append: {
            value: underlyingHeaders.append.bind(underlyingHeaders)
        },
        delete: {
            value: underlyingHeaders.delete.bind(underlyingHeaders)
        },
        get: {
            value: underlyingHeaders.get.bind(underlyingHeaders)
        },
        has: {
            value: underlyingHeaders.has.bind(underlyingHeaders)
        },
        set: {
            value: underlyingHeaders.set.bind(underlyingHeaders)
        },
        getSetCookie: {
            value: underlyingHeaders.getSetCookie.bind(underlyingHeaders)
        },
        forEach: {
            value: underlyingHeaders.forEach.bind(underlyingHeaders)
        },
        keys: {
            value: underlyingHeaders.keys.bind(underlyingHeaders)
        },
        values: {
            value: underlyingHeaders.values.bind(underlyingHeaders)
        },
        entries: {
            value: underlyingHeaders.entries.bind(underlyingHeaders)
        },
        [Symbol.iterator]: {
            value: underlyingHeaders[Symbol.iterator].bind(underlyingHeaders)
        }
    });
    return promise;
}
function makeUntrackedExoticHeadersWithDevWarnings(underlyingHeaders, route) {
    const cachedHeaders = CachedHeaders.get(underlyingHeaders);
    if (cachedHeaders) {
        return cachedHeaders;
    }
    const promise = new Promise((resolve)=>(0, _scheduler.scheduleImmediate)(()=>resolve(underlyingHeaders)));
    CachedHeaders.set(underlyingHeaders, promise);
    Object.defineProperties(promise, {
        append: {
            value: function append() {
                const expression = `\`headers().append(${describeNameArg(arguments[0])}, ...)\``;
                syncIODev(route, expression);
                return underlyingHeaders.append.apply(underlyingHeaders, arguments);
            }
        },
        delete: {
            value: function _delete() {
                const expression = `\`headers().delete(${describeNameArg(arguments[0])})\``;
                syncIODev(route, expression);
                return underlyingHeaders.delete.apply(underlyingHeaders, arguments);
            }
        },
        get: {
            value: function get() {
                const expression = `\`headers().get(${describeNameArg(arguments[0])})\``;
                syncIODev(route, expression);
                return underlyingHeaders.get.apply(underlyingHeaders, arguments);
            }
        },
        has: {
            value: function has() {
                const expression = `\`headers().has(${describeNameArg(arguments[0])})\``;
                syncIODev(route, expression);
                return underlyingHeaders.has.apply(underlyingHeaders, arguments);
            }
        },
        set: {
            value: function set() {
                const expression = `\`headers().set(${describeNameArg(arguments[0])}, ...)\``;
                syncIODev(route, expression);
                return underlyingHeaders.set.apply(underlyingHeaders, arguments);
            }
        },
        getSetCookie: {
            value: function getSetCookie() {
                const expression = '`headers().getSetCookie()`';
                syncIODev(route, expression);
                return underlyingHeaders.getSetCookie.apply(underlyingHeaders, arguments);
            }
        },
        forEach: {
            value: function forEach() {
                const expression = '`headers().forEach(...)`';
                syncIODev(route, expression);
                return underlyingHeaders.forEach.apply(underlyingHeaders, arguments);
            }
        },
        keys: {
            value: function keys() {
                const expression = '`headers().keys()`';
                syncIODev(route, expression);
                return underlyingHeaders.keys.apply(underlyingHeaders, arguments);
            }
        },
        values: {
            value: function values() {
                const expression = '`headers().values()`';
                syncIODev(route, expression);
                return underlyingHeaders.values.apply(underlyingHeaders, arguments);
            }
        },
        entries: {
            value: function entries() {
                const expression = '`headers().entries()`';
                syncIODev(route, expression);
                return underlyingHeaders.entries.apply(underlyingHeaders, arguments);
            }
        },
        [Symbol.iterator]: {
            value: function() {
                const expression = '`...headers()` or similar iteration';
                syncIODev(route, expression);
                return underlyingHeaders[Symbol.iterator].apply(underlyingHeaders, arguments);
            }
        }
    });
    return promise;
}
// Similar to `makeUntrackedExoticHeadersWithDevWarnings`, but just logging the
// sync access without actually defining the headers properties on the promise.
function makeUntrackedHeadersWithDevWarnings(underlyingHeaders, route) {
    const cachedHeaders = CachedHeaders.get(underlyingHeaders);
    if (cachedHeaders) {
        return cachedHeaders;
    }
    const promise = new Promise((resolve)=>(0, _scheduler.scheduleImmediate)(()=>resolve(underlyingHeaders)));
    const proxiedPromise = new Proxy(promise, {
        get (target, prop, receiver) {
            switch(prop){
                case Symbol.iterator:
                    {
                        warnForSyncAccess(route, '`...headers()` or similar iteration');
                        break;
                    }
                case 'append':
                case 'delete':
                case 'get':
                case 'has':
                case 'set':
                case 'getSetCookie':
                case 'forEach':
                case 'keys':
                case 'values':
                case 'entries':
                    {
                        warnForSyncAccess(route, `\`headers().${prop}\``);
                        break;
                    }
                default:
                    {
                    // We only warn for well-defined properties of the headers object.
                    }
            }
            return _reflect.ReflectAdapter.get(target, prop, receiver);
        }
    });
    CachedHeaders.set(underlyingHeaders, proxiedPromise);
    return proxiedPromise;
}
function describeNameArg(arg) {
    return typeof arg === 'string' ? `'${arg}'` : '...';
}
function syncIODev(route, expression) {
    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
    if (workUnitStore && workUnitStore.type === 'request' && workUnitStore.prerenderPhase === true) {
        // When we're rendering dynamically in dev we need to advance out of the
        // Prerender environment when we read Request data synchronously
        const requestStore = workUnitStore;
        (0, _dynamicrendering.trackSynchronousRequestDataAccessInDev)(requestStore);
    }
    // In all cases we warn normally
    warnForSyncAccess(route, expression);
}
const warnForSyncAccess = (0, _creatededupedbycallsiteservererrorlogger.createDedupedByCallsiteServerErrorLoggerDev)(createHeadersAccessError);
function createHeadersAccessError(route, expression) {
    const prefix = route ? `Route "${route}" ` : 'This route ';
    return Object.defineProperty(new Error(`${prefix}used ${expression}. ` + `\`headers()\` should be awaited before using its value. ` + `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`), "__NEXT_ERROR_CODE", {
        value: "E277",
        enumerable: false,
        configurable: true
    });
} //# sourceMappingURL=headers.js.map
}}),
"[project]/node_modules/next/dist/server/request/draft-mode.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "draftMode", {
    enumerable: true,
    get: function() {
        return draftMode;
    }
});
const _workunitasyncstorageexternal = __turbopack_context__.r("[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)");
const _workasyncstorageexternal = __turbopack_context__.r("[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)");
const _dynamicrendering = __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/dynamic-rendering.js [app-ssr] (ecmascript)");
const _creatededupedbycallsiteservererrorlogger = __turbopack_context__.r("[project]/node_modules/next/dist/server/create-deduped-by-callsite-server-error-logger.js [app-ssr] (ecmascript)");
const _staticgenerationbailout = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/static-generation-bailout.js [app-ssr] (ecmascript)");
const _hooksservercontext = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/hooks-server-context.js [app-ssr] (ecmascript)");
const _invarianterror = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/invariant-error.js [app-ssr] (ecmascript)");
const _reflect = __turbopack_context__.r("[project]/node_modules/next/dist/server/web/spec-extension/adapters/reflect.js [app-ssr] (ecmascript)");
function draftMode() {
    const callingExpression = 'draftMode';
    const workStore = _workasyncstorageexternal.workAsyncStorage.getStore();
    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
    if (!workStore || !workUnitStore) {
        (0, _workunitasyncstorageexternal.throwForMissingRequestStore)(callingExpression);
    }
    switch(workUnitStore.type){
        case 'request':
            return createOrGetCachedDraftMode(workUnitStore.draftMode, workStore);
        case 'cache':
        case 'unstable-cache':
            // Inside of `"use cache"` or `unstable_cache`, draft mode is available if
            // the outmost work unit store is a request store, and if draft mode is
            // enabled.
            const draftModeProvider = (0, _workunitasyncstorageexternal.getDraftModeProviderForCacheScope)(workStore, workUnitStore);
            if (draftModeProvider) {
                return createOrGetCachedDraftMode(draftModeProvider, workStore);
            }
        // Otherwise, we fall through to providing an empty draft mode.
        // eslint-disable-next-line no-fallthrough
        case 'prerender':
        case 'prerender-client':
        case 'prerender-ppr':
        case 'prerender-legacy':
            // Return empty draft mode
            return createOrGetCachedDraftMode(null, workStore);
        default:
            const _exhaustiveCheck = workUnitStore;
            return _exhaustiveCheck;
    }
}
function createOrGetCachedDraftMode(draftModeProvider, workStore) {
    const cacheKey = draftModeProvider ?? NullDraftMode;
    const cachedDraftMode = CachedDraftModes.get(cacheKey);
    if (cachedDraftMode) {
        return cachedDraftMode;
    }
    let promise;
    if (("TURBOPACK compile-time value", "development") === 'development' && !(workStore == null ? void 0 : workStore.isPrefetchRequest)) {
        const route = workStore == null ? void 0 : workStore.route;
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        promise = createExoticDraftModeWithDevWarnings(draftModeProvider, route);
    } else {
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        promise = createExoticDraftMode(draftModeProvider);
    }
    CachedDraftModes.set(cacheKey, promise);
    return promise;
}
const NullDraftMode = {};
const CachedDraftModes = new WeakMap();
function createExoticDraftMode(underlyingProvider) {
    const instance = new DraftMode(underlyingProvider);
    const promise = Promise.resolve(instance);
    Object.defineProperty(promise, 'isEnabled', {
        get () {
            return instance.isEnabled;
        },
        enumerable: true,
        configurable: true
    });
    promise.enable = instance.enable.bind(instance);
    promise.disable = instance.disable.bind(instance);
    return promise;
}
function createExoticDraftModeWithDevWarnings(underlyingProvider, route) {
    const instance = new DraftMode(underlyingProvider);
    const promise = Promise.resolve(instance);
    Object.defineProperty(promise, 'isEnabled', {
        get () {
            const expression = '`draftMode().isEnabled`';
            syncIODev(route, expression);
            return instance.isEnabled;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(promise, 'enable', {
        value: function get() {
            const expression = '`draftMode().enable()`';
            syncIODev(route, expression);
            return instance.enable.apply(instance, arguments);
        }
    });
    Object.defineProperty(promise, 'disable', {
        value: function get() {
            const expression = '`draftMode().disable()`';
            syncIODev(route, expression);
            return instance.disable.apply(instance, arguments);
        }
    });
    return promise;
}
// Similar to `createExoticDraftModeWithDevWarnings`, but just logging the sync
// access without actually defining the draftMode properties on the promise.
function createDraftModeWithDevWarnings(underlyingProvider, route) {
    const instance = new DraftMode(underlyingProvider);
    const promise = Promise.resolve(instance);
    const proxiedPromise = new Proxy(promise, {
        get (target, prop, receiver) {
            switch(prop){
                case 'isEnabled':
                    warnForSyncAccess(route, `\`draftMode().${prop}\``);
                    break;
                case 'enable':
                case 'disable':
                    {
                        warnForSyncAccess(route, `\`draftMode().${prop}()\``);
                        break;
                    }
                default:
                    {
                    // We only warn for well-defined properties of the draftMode object.
                    }
            }
            return _reflect.ReflectAdapter.get(target, prop, receiver);
        }
    });
    return proxiedPromise;
}
class DraftMode {
    constructor(provider){
        this._provider = provider;
    }
    get isEnabled() {
        if (this._provider !== null) {
            return this._provider.isEnabled;
        }
        return false;
    }
    enable() {
        // We have a store we want to track dynamic data access to ensure we
        // don't statically generate routes that manipulate draft mode.
        trackDynamicDraftMode('draftMode().enable()');
        if (this._provider !== null) {
            this._provider.enable();
        }
    }
    disable() {
        trackDynamicDraftMode('draftMode().disable()');
        if (this._provider !== null) {
            this._provider.disable();
        }
    }
}
function syncIODev(route, expression) {
    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
    if (workUnitStore && workUnitStore.type === 'request' && workUnitStore.prerenderPhase === true) {
        // When we're rendering dynamically in dev we need to advance out of the
        // Prerender environment when we read Request data synchronously
        const requestStore = workUnitStore;
        (0, _dynamicrendering.trackSynchronousRequestDataAccessInDev)(requestStore);
    }
    // In all cases we warn normally
    warnForSyncAccess(route, expression);
}
const warnForSyncAccess = (0, _creatededupedbycallsiteservererrorlogger.createDedupedByCallsiteServerErrorLoggerDev)(createDraftModeAccessError);
function createDraftModeAccessError(route, expression) {
    const prefix = route ? `Route "${route}" ` : 'This route ';
    return Object.defineProperty(new Error(`${prefix}used ${expression}. ` + `\`draftMode()\` should be awaited before using its value. ` + `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`), "__NEXT_ERROR_CODE", {
        value: "E377",
        enumerable: false,
        configurable: true
    });
}
function trackDynamicDraftMode(expression) {
    const store = _workasyncstorageexternal.workAsyncStorage.getStore();
    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
    if (store) {
        // We have a store we want to track dynamic data access to ensure we
        // don't statically generate routes that manipulate draft mode.
        if (workUnitStore) {
            if (workUnitStore.type === 'cache') {
                throw Object.defineProperty(new Error(`Route ${store.route} used "${expression}" inside "use cache". The enabled status of draftMode can be read in caches but you must not enable or disable draftMode inside a cache. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`), "__NEXT_ERROR_CODE", {
                    value: "E246",
                    enumerable: false,
                    configurable: true
                });
            } else if (workUnitStore.type === 'unstable-cache') {
                throw Object.defineProperty(new Error(`Route ${store.route} used "${expression}" inside a function cached with "unstable_cache(...)". The enabled status of draftMode can be read in caches but you must not enable or disable draftMode inside a cache. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`), "__NEXT_ERROR_CODE", {
                    value: "E259",
                    enumerable: false,
                    configurable: true
                });
            } else if (workUnitStore.phase === 'after') {
                throw Object.defineProperty(new Error(`Route ${store.route} used "${expression}" inside \`after\`. The enabled status of draftMode can be read inside \`after\` but you cannot enable or disable draftMode. See more info here: https://nextjs.org/docs/app/api-reference/functions/after`), "__NEXT_ERROR_CODE", {
                    value: "E348",
                    enumerable: false,
                    configurable: true
                });
            }
        }
        if (store.dynamicShouldError) {
            throw Object.defineProperty(new _staticgenerationbailout.StaticGenBailoutError(`Route ${store.route} with \`dynamic = "error"\` couldn't be rendered statically because it used \`${expression}\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`), "__NEXT_ERROR_CODE", {
                value: "E553",
                enumerable: false,
                configurable: true
            });
        }
        if (workUnitStore) {
            switch(workUnitStore.type){
                case 'prerender':
                    // dynamicIO Prerender
                    const error = Object.defineProperty(new Error(`Route ${store.route} used ${expression} without first calling \`await connection()\`. See more info here: https://nextjs.org/docs/messages/next-prerender-sync-headers`), "__NEXT_ERROR_CODE", {
                        value: "E126",
                        enumerable: false,
                        configurable: true
                    });
                    (0, _dynamicrendering.abortAndThrowOnSynchronousRequestDataAccess)(store.route, expression, error, workUnitStore);
                    break;
                case 'prerender-client':
                    const exportName = '`draftMode`';
                    throw Object.defineProperty(new _invarianterror.InvariantError(`${exportName} must not be used within a client component. Next.js should be preventing ${exportName} from being included in client components statically, but did not in this case.`), "__NEXT_ERROR_CODE", {
                        value: "E693",
                        enumerable: false,
                        configurable: true
                    });
                case 'prerender-ppr':
                    // PPR Prerender
                    (0, _dynamicrendering.postponeWithTracking)(store.route, expression, workUnitStore.dynamicTracking);
                    break;
                case 'prerender-legacy':
                    // legacy Prerender
                    workUnitStore.revalidate = 0;
                    const err = Object.defineProperty(new _hooksservercontext.DynamicServerError(`Route ${store.route} couldn't be rendered statically because it used \`${expression}\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`), "__NEXT_ERROR_CODE", {
                        value: "E558",
                        enumerable: false,
                        configurable: true
                    });
                    store.dynamicUsageDescription = expression;
                    store.dynamicUsageStack = err.stack;
                    throw err;
                case 'request':
                    if ("TURBOPACK compile-time truthy", 1) {
                        workUnitStore.usedDynamic = true;
                    }
                    break;
                default:
            }
        }
    }
} //# sourceMappingURL=draft-mode.js.map
}}),
"[project]/node_modules/next/headers.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
module.exports.cookies = __turbopack_context__.r("[project]/node_modules/next/dist/server/request/cookies.js [app-ssr] (ecmascript)").cookies;
module.exports.headers = __turbopack_context__.r("[project]/node_modules/next/dist/server/request/headers.js [app-ssr] (ecmascript)").headers;
module.exports.draftMode = __turbopack_context__.r("[project]/node_modules/next/dist/server/request/draft-mode.js [app-ssr] (ecmascript)").draftMode;
}}),

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFtdLAogICJzZWN0aW9ucyI6IFsKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNywgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvJTQwZWRnZS1ydW50aW1lL2Nvb2tpZXMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBzcmNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoc3JjX2V4cG9ydHMsIHtcbiAgUmVxdWVzdENvb2tpZXM6ICgpID0+IFJlcXVlc3RDb29raWVzLFxuICBSZXNwb25zZUNvb2tpZXM6ICgpID0+IFJlc3BvbnNlQ29va2llcyxcbiAgcGFyc2VDb29raWU6ICgpID0+IHBhcnNlQ29va2llLFxuICBwYXJzZVNldENvb2tpZTogKCkgPT4gcGFyc2VTZXRDb29raWUsXG4gIHN0cmluZ2lmeUNvb2tpZTogKCkgPT4gc3RyaW5naWZ5Q29va2llXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKHNyY19leHBvcnRzKTtcblxuLy8gc3JjL3NlcmlhbGl6ZS50c1xuZnVuY3Rpb24gc3RyaW5naWZ5Q29va2llKGMpIHtcbiAgdmFyIF9hO1xuICBjb25zdCBhdHRycyA9IFtcbiAgICBcInBhdGhcIiBpbiBjICYmIGMucGF0aCAmJiBgUGF0aD0ke2MucGF0aH1gLFxuICAgIFwiZXhwaXJlc1wiIGluIGMgJiYgKGMuZXhwaXJlcyB8fCBjLmV4cGlyZXMgPT09IDApICYmIGBFeHBpcmVzPSR7KHR5cGVvZiBjLmV4cGlyZXMgPT09IFwibnVtYmVyXCIgPyBuZXcgRGF0ZShjLmV4cGlyZXMpIDogYy5leHBpcmVzKS50b1VUQ1N0cmluZygpfWAsXG4gICAgXCJtYXhBZ2VcIiBpbiBjICYmIHR5cGVvZiBjLm1heEFnZSA9PT0gXCJudW1iZXJcIiAmJiBgTWF4LUFnZT0ke2MubWF4QWdlfWAsXG4gICAgXCJkb21haW5cIiBpbiBjICYmIGMuZG9tYWluICYmIGBEb21haW49JHtjLmRvbWFpbn1gLFxuICAgIFwic2VjdXJlXCIgaW4gYyAmJiBjLnNlY3VyZSAmJiBcIlNlY3VyZVwiLFxuICAgIFwiaHR0cE9ubHlcIiBpbiBjICYmIGMuaHR0cE9ubHkgJiYgXCJIdHRwT25seVwiLFxuICAgIFwic2FtZVNpdGVcIiBpbiBjICYmIGMuc2FtZVNpdGUgJiYgYFNhbWVTaXRlPSR7Yy5zYW1lU2l0ZX1gLFxuICAgIFwicGFydGl0aW9uZWRcIiBpbiBjICYmIGMucGFydGl0aW9uZWQgJiYgXCJQYXJ0aXRpb25lZFwiLFxuICAgIFwicHJpb3JpdHlcIiBpbiBjICYmIGMucHJpb3JpdHkgJiYgYFByaW9yaXR5PSR7Yy5wcmlvcml0eX1gXG4gIF0uZmlsdGVyKEJvb2xlYW4pO1xuICBjb25zdCBzdHJpbmdpZmllZCA9IGAke2MubmFtZX09JHtlbmNvZGVVUklDb21wb25lbnQoKF9hID0gYy52YWx1ZSkgIT0gbnVsbCA/IF9hIDogXCJcIil9YDtcbiAgcmV0dXJuIGF0dHJzLmxlbmd0aCA9PT0gMCA/IHN0cmluZ2lmaWVkIDogYCR7c3RyaW5naWZpZWR9OyAke2F0dHJzLmpvaW4oXCI7IFwiKX1gO1xufVxuZnVuY3Rpb24gcGFyc2VDb29raWUoY29va2llKSB7XG4gIGNvbnN0IG1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGZvciAoY29uc3QgcGFpciBvZiBjb29raWUuc3BsaXQoLzsgKi8pKSB7XG4gICAgaWYgKCFwYWlyKVxuICAgICAgY29udGludWU7XG4gICAgY29uc3Qgc3BsaXRBdCA9IHBhaXIuaW5kZXhPZihcIj1cIik7XG4gICAgaWYgKHNwbGl0QXQgPT09IC0xKSB7XG4gICAgICBtYXAuc2V0KHBhaXIsIFwidHJ1ZVwiKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSBbcGFpci5zbGljZSgwLCBzcGxpdEF0KSwgcGFpci5zbGljZShzcGxpdEF0ICsgMSldO1xuICAgIHRyeSB7XG4gICAgICBtYXAuc2V0KGtleSwgZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IFwidHJ1ZVwiKSk7XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICB9XG4gIHJldHVybiBtYXA7XG59XG5mdW5jdGlvbiBwYXJzZVNldENvb2tpZShzZXRDb29raWUpIHtcbiAgaWYgKCFzZXRDb29raWUpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGNvbnN0IFtbbmFtZSwgdmFsdWVdLCAuLi5hdHRyaWJ1dGVzXSA9IHBhcnNlQ29va2llKHNldENvb2tpZSk7XG4gIGNvbnN0IHtcbiAgICBkb21haW4sXG4gICAgZXhwaXJlcyxcbiAgICBodHRwb25seSxcbiAgICBtYXhhZ2UsXG4gICAgcGF0aCxcbiAgICBzYW1lc2l0ZSxcbiAgICBzZWN1cmUsXG4gICAgcGFydGl0aW9uZWQsXG4gICAgcHJpb3JpdHlcbiAgfSA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBhdHRyaWJ1dGVzLm1hcCgoW2tleSwgdmFsdWUyXSkgPT4gW1xuICAgICAga2V5LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvLS9nLCBcIlwiKSxcbiAgICAgIHZhbHVlMlxuICAgIF0pXG4gICk7XG4gIGNvbnN0IGNvb2tpZSA9IHtcbiAgICBuYW1lLFxuICAgIHZhbHVlOiBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpLFxuICAgIGRvbWFpbixcbiAgICAuLi5leHBpcmVzICYmIHsgZXhwaXJlczogbmV3IERhdGUoZXhwaXJlcykgfSxcbiAgICAuLi5odHRwb25seSAmJiB7IGh0dHBPbmx5OiB0cnVlIH0sXG4gICAgLi4udHlwZW9mIG1heGFnZSA9PT0gXCJzdHJpbmdcIiAmJiB7IG1heEFnZTogTnVtYmVyKG1heGFnZSkgfSxcbiAgICBwYXRoLFxuICAgIC4uLnNhbWVzaXRlICYmIHsgc2FtZVNpdGU6IHBhcnNlU2FtZVNpdGUoc2FtZXNpdGUpIH0sXG4gICAgLi4uc2VjdXJlICYmIHsgc2VjdXJlOiB0cnVlIH0sXG4gICAgLi4ucHJpb3JpdHkgJiYgeyBwcmlvcml0eTogcGFyc2VQcmlvcml0eShwcmlvcml0eSkgfSxcbiAgICAuLi5wYXJ0aXRpb25lZCAmJiB7IHBhcnRpdGlvbmVkOiB0cnVlIH1cbiAgfTtcbiAgcmV0dXJuIGNvbXBhY3QoY29va2llKTtcbn1cbmZ1bmN0aW9uIGNvbXBhY3QodCkge1xuICBjb25zdCBuZXdUID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIHQpIHtcbiAgICBpZiAodFtrZXldKSB7XG4gICAgICBuZXdUW2tleV0gPSB0W2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXdUO1xufVxudmFyIFNBTUVfU0lURSA9IFtcInN0cmljdFwiLCBcImxheFwiLCBcIm5vbmVcIl07XG5mdW5jdGlvbiBwYXJzZVNhbWVTaXRlKHN0cmluZykge1xuICBzdHJpbmcgPSBzdHJpbmcudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIFNBTUVfU0lURS5pbmNsdWRlcyhzdHJpbmcpID8gc3RyaW5nIDogdm9pZCAwO1xufVxudmFyIFBSSU9SSVRZID0gW1wibG93XCIsIFwibWVkaXVtXCIsIFwiaGlnaFwiXTtcbmZ1bmN0aW9uIHBhcnNlUHJpb3JpdHkoc3RyaW5nKSB7XG4gIHN0cmluZyA9IHN0cmluZy50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gUFJJT1JJVFkuaW5jbHVkZXMoc3RyaW5nKSA/IHN0cmluZyA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIHNwbGl0Q29va2llc1N0cmluZyhjb29raWVzU3RyaW5nKSB7XG4gIGlmICghY29va2llc1N0cmluZylcbiAgICByZXR1cm4gW107XG4gIHZhciBjb29raWVzU3RyaW5ncyA9IFtdO1xuICB2YXIgcG9zID0gMDtcbiAgdmFyIHN0YXJ0O1xuICB2YXIgY2g7XG4gIHZhciBsYXN0Q29tbWE7XG4gIHZhciBuZXh0U3RhcnQ7XG4gIHZhciBjb29raWVzU2VwYXJhdG9yRm91bmQ7XG4gIGZ1bmN0aW9uIHNraXBXaGl0ZXNwYWNlKCkge1xuICAgIHdoaWxlIChwb3MgPCBjb29raWVzU3RyaW5nLmxlbmd0aCAmJiAvXFxzLy50ZXN0KGNvb2tpZXNTdHJpbmcuY2hhckF0KHBvcykpKSB7XG4gICAgICBwb3MgKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHBvcyA8IGNvb2tpZXNTdHJpbmcubGVuZ3RoO1xuICB9XG4gIGZ1bmN0aW9uIG5vdFNwZWNpYWxDaGFyKCkge1xuICAgIGNoID0gY29va2llc1N0cmluZy5jaGFyQXQocG9zKTtcbiAgICByZXR1cm4gY2ggIT09IFwiPVwiICYmIGNoICE9PSBcIjtcIiAmJiBjaCAhPT0gXCIsXCI7XG4gIH1cbiAgd2hpbGUgKHBvcyA8IGNvb2tpZXNTdHJpbmcubGVuZ3RoKSB7XG4gICAgc3RhcnQgPSBwb3M7XG4gICAgY29va2llc1NlcGFyYXRvckZvdW5kID0gZmFsc2U7XG4gICAgd2hpbGUgKHNraXBXaGl0ZXNwYWNlKCkpIHtcbiAgICAgIGNoID0gY29va2llc1N0cmluZy5jaGFyQXQocG9zKTtcbiAgICAgIGlmIChjaCA9PT0gXCIsXCIpIHtcbiAgICAgICAgbGFzdENvbW1hID0gcG9zO1xuICAgICAgICBwb3MgKz0gMTtcbiAgICAgICAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgICAgICAgbmV4dFN0YXJ0ID0gcG9zO1xuICAgICAgICB3aGlsZSAocG9zIDwgY29va2llc1N0cmluZy5sZW5ndGggJiYgbm90U3BlY2lhbENoYXIoKSkge1xuICAgICAgICAgIHBvcyArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3MgPCBjb29raWVzU3RyaW5nLmxlbmd0aCAmJiBjb29raWVzU3RyaW5nLmNoYXJBdChwb3MpID09PSBcIj1cIikge1xuICAgICAgICAgIGNvb2tpZXNTZXBhcmF0b3JGb3VuZCA9IHRydWU7XG4gICAgICAgICAgcG9zID0gbmV4dFN0YXJ0O1xuICAgICAgICAgIGNvb2tpZXNTdHJpbmdzLnB1c2goY29va2llc1N0cmluZy5zdWJzdHJpbmcoc3RhcnQsIGxhc3RDb21tYSkpO1xuICAgICAgICAgIHN0YXJ0ID0gcG9zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBvcyA9IGxhc3RDb21tYSArIDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBvcyArPSAxO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWNvb2tpZXNTZXBhcmF0b3JGb3VuZCB8fCBwb3MgPj0gY29va2llc1N0cmluZy5sZW5ndGgpIHtcbiAgICAgIGNvb2tpZXNTdHJpbmdzLnB1c2goY29va2llc1N0cmluZy5zdWJzdHJpbmcoc3RhcnQsIGNvb2tpZXNTdHJpbmcubGVuZ3RoKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjb29raWVzU3RyaW5ncztcbn1cblxuLy8gc3JjL3JlcXVlc3QtY29va2llcy50c1xudmFyIFJlcXVlc3RDb29raWVzID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihyZXF1ZXN0SGVhZGVycykge1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9wYXJzZWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuX2hlYWRlcnMgPSByZXF1ZXN0SGVhZGVycztcbiAgICBjb25zdCBoZWFkZXIgPSByZXF1ZXN0SGVhZGVycy5nZXQoXCJjb29raWVcIik7XG4gICAgaWYgKGhlYWRlcikge1xuICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VDb29raWUoaGVhZGVyKTtcbiAgICAgIGZvciAoY29uc3QgW25hbWUsIHZhbHVlXSBvZiBwYXJzZWQpIHtcbiAgICAgICAgdGhpcy5fcGFyc2VkLnNldChuYW1lLCB7IG5hbWUsIHZhbHVlIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFyc2VkW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGFtb3VudCBvZiBjb29raWVzIHJlY2VpdmVkIGZyb20gdGhlIGNsaWVudFxuICAgKi9cbiAgZ2V0IHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcnNlZC5zaXplO1xuICB9XG4gIGdldCguLi5hcmdzKSB7XG4gICAgY29uc3QgbmFtZSA9IHR5cGVvZiBhcmdzWzBdID09PSBcInN0cmluZ1wiID8gYXJnc1swXSA6IGFyZ3NbMF0ubmFtZTtcbiAgICByZXR1cm4gdGhpcy5fcGFyc2VkLmdldChuYW1lKTtcbiAgfVxuICBnZXRBbGwoLi4uYXJncykge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBhbGwgPSBBcnJheS5mcm9tKHRoaXMuX3BhcnNlZCk7XG4gICAgaWYgKCFhcmdzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGFsbC5tYXAoKFtfLCB2YWx1ZV0pID0+IHZhbHVlKTtcbiAgICB9XG4gICAgY29uc3QgbmFtZSA9IHR5cGVvZiBhcmdzWzBdID09PSBcInN0cmluZ1wiID8gYXJnc1swXSA6IChfYSA9IGFyZ3NbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfYS5uYW1lO1xuICAgIHJldHVybiBhbGwuZmlsdGVyKChbbl0pID0+IG4gPT09IG5hbWUpLm1hcCgoW18sIHZhbHVlXSkgPT4gdmFsdWUpO1xuICB9XG4gIGhhcyhuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcnNlZC5oYXMobmFtZSk7XG4gIH1cbiAgc2V0KC4uLmFyZ3MpIHtcbiAgICBjb25zdCBbbmFtZSwgdmFsdWVdID0gYXJncy5sZW5ndGggPT09IDEgPyBbYXJnc1swXS5uYW1lLCBhcmdzWzBdLnZhbHVlXSA6IGFyZ3M7XG4gICAgY29uc3QgbWFwID0gdGhpcy5fcGFyc2VkO1xuICAgIG1hcC5zZXQobmFtZSwgeyBuYW1lLCB2YWx1ZSB9KTtcbiAgICB0aGlzLl9oZWFkZXJzLnNldChcbiAgICAgIFwiY29va2llXCIsXG4gICAgICBBcnJheS5mcm9tKG1hcCkubWFwKChbXywgdmFsdWUyXSkgPT4gc3RyaW5naWZ5Q29va2llKHZhbHVlMikpLmpvaW4oXCI7IFwiKVxuICAgICk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZSB0aGUgY29va2llcyBtYXRjaGluZyB0aGUgcGFzc2VkIG5hbWUgb3IgbmFtZXMgaW4gdGhlIHJlcXVlc3QuXG4gICAqL1xuICBkZWxldGUobmFtZXMpIHtcbiAgICBjb25zdCBtYXAgPSB0aGlzLl9wYXJzZWQ7XG4gICAgY29uc3QgcmVzdWx0ID0gIUFycmF5LmlzQXJyYXkobmFtZXMpID8gbWFwLmRlbGV0ZShuYW1lcykgOiBuYW1lcy5tYXAoKG5hbWUpID0+IG1hcC5kZWxldGUobmFtZSkpO1xuICAgIHRoaXMuX2hlYWRlcnMuc2V0KFxuICAgICAgXCJjb29raWVcIixcbiAgICAgIEFycmF5LmZyb20obWFwKS5tYXAoKFtfLCB2YWx1ZV0pID0+IHN0cmluZ2lmeUNvb2tpZSh2YWx1ZSkpLmpvaW4oXCI7IFwiKVxuICAgICk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlIGFsbCB0aGUgY29va2llcyBpbiB0aGUgY29va2llcyBpbiB0aGUgcmVxdWVzdC5cbiAgICovXG4gIGNsZWFyKCkge1xuICAgIHRoaXMuZGVsZXRlKEFycmF5LmZyb20odGhpcy5fcGFyc2VkLmtleXMoKSkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBGb3JtYXQgdGhlIGNvb2tpZXMgaW4gdGhlIHJlcXVlc3QgYXMgYSBzdHJpbmcgZm9yIGxvZ2dpbmdcbiAgICovXG4gIFtTeW1ib2wuZm9yKFwiZWRnZS1ydW50aW1lLmluc3BlY3QuY3VzdG9tXCIpXSgpIHtcbiAgICByZXR1cm4gYFJlcXVlc3RDb29raWVzICR7SlNPTi5zdHJpbmdpZnkoT2JqZWN0LmZyb21FbnRyaWVzKHRoaXMuX3BhcnNlZCkpfWA7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIFsuLi50aGlzLl9wYXJzZWQudmFsdWVzKCldLm1hcCgodikgPT4gYCR7di5uYW1lfT0ke2VuY29kZVVSSUNvbXBvbmVudCh2LnZhbHVlKX1gKS5qb2luKFwiOyBcIik7XG4gIH1cbn07XG5cbi8vIHNyYy9yZXNwb25zZS1jb29raWVzLnRzXG52YXIgUmVzcG9uc2VDb29raWVzID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihyZXNwb25zZUhlYWRlcnMpIHtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fcGFyc2VkID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICB0aGlzLl9oZWFkZXJzID0gcmVzcG9uc2VIZWFkZXJzO1xuICAgIGNvbnN0IHNldENvb2tpZSA9IChfYyA9IChfYiA9IChfYSA9IHJlc3BvbnNlSGVhZGVycy5nZXRTZXRDb29raWUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKHJlc3BvbnNlSGVhZGVycykpICE9IG51bGwgPyBfYiA6IHJlc3BvbnNlSGVhZGVycy5nZXQoXCJzZXQtY29va2llXCIpKSAhPSBudWxsID8gX2MgOiBbXTtcbiAgICBjb25zdCBjb29raWVTdHJpbmdzID0gQXJyYXkuaXNBcnJheShzZXRDb29raWUpID8gc2V0Q29va2llIDogc3BsaXRDb29raWVzU3RyaW5nKHNldENvb2tpZSk7XG4gICAgZm9yIChjb25zdCBjb29raWVTdHJpbmcgb2YgY29va2llU3RyaW5ncykge1xuICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VTZXRDb29raWUoY29va2llU3RyaW5nKTtcbiAgICAgIGlmIChwYXJzZWQpXG4gICAgICAgIHRoaXMuX3BhcnNlZC5zZXQocGFyc2VkLm5hbWUsIHBhcnNlZCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiB7QGxpbmsgaHR0cHM6Ly93aWNnLmdpdGh1Yi5pby9jb29raWUtc3RvcmUvI0Nvb2tpZVN0b3JlLWdldCBDb29raWVTdG9yZSNnZXR9IHdpdGhvdXQgdGhlIFByb21pc2UuXG4gICAqL1xuICBnZXQoLi4uYXJncykge1xuICAgIGNvbnN0IGtleSA9IHR5cGVvZiBhcmdzWzBdID09PSBcInN0cmluZ1wiID8gYXJnc1swXSA6IGFyZ3NbMF0ubmFtZTtcbiAgICByZXR1cm4gdGhpcy5fcGFyc2VkLmdldChrZXkpO1xuICB9XG4gIC8qKlxuICAgKiB7QGxpbmsgaHR0cHM6Ly93aWNnLmdpdGh1Yi5pby9jb29raWUtc3RvcmUvI0Nvb2tpZVN0b3JlLWdldEFsbCBDb29raWVTdG9yZSNnZXRBbGx9IHdpdGhvdXQgdGhlIFByb21pc2UuXG4gICAqL1xuICBnZXRBbGwoLi4uYXJncykge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBhbGwgPSBBcnJheS5mcm9tKHRoaXMuX3BhcnNlZC52YWx1ZXMoKSk7XG4gICAgaWYgKCFhcmdzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGFsbDtcbiAgICB9XG4gICAgY29uc3Qga2V5ID0gdHlwZW9mIGFyZ3NbMF0gPT09IFwic3RyaW5nXCIgPyBhcmdzWzBdIDogKF9hID0gYXJnc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLm5hbWU7XG4gICAgcmV0dXJuIGFsbC5maWx0ZXIoKGMpID0+IGMubmFtZSA9PT0ga2V5KTtcbiAgfVxuICBoYXMobmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9wYXJzZWQuaGFzKG5hbWUpO1xuICB9XG4gIC8qKlxuICAgKiB7QGxpbmsgaHR0cHM6Ly93aWNnLmdpdGh1Yi5pby9jb29raWUtc3RvcmUvI0Nvb2tpZVN0b3JlLXNldCBDb29raWVTdG9yZSNzZXR9IHdpdGhvdXQgdGhlIFByb21pc2UuXG4gICAqL1xuICBzZXQoLi4uYXJncykge1xuICAgIGNvbnN0IFtuYW1lLCB2YWx1ZSwgY29va2llXSA9IGFyZ3MubGVuZ3RoID09PSAxID8gW2FyZ3NbMF0ubmFtZSwgYXJnc1swXS52YWx1ZSwgYXJnc1swXV0gOiBhcmdzO1xuICAgIGNvbnN0IG1hcCA9IHRoaXMuX3BhcnNlZDtcbiAgICBtYXAuc2V0KG5hbWUsIG5vcm1hbGl6ZUNvb2tpZSh7IG5hbWUsIHZhbHVlLCAuLi5jb29raWUgfSkpO1xuICAgIHJlcGxhY2UobWFwLCB0aGlzLl9oZWFkZXJzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICoge0BsaW5rIGh0dHBzOi8vd2ljZy5naXRodWIuaW8vY29va2llLXN0b3JlLyNDb29raWVTdG9yZS1kZWxldGUgQ29va2llU3RvcmUjZGVsZXRlfSB3aXRob3V0IHRoZSBQcm9taXNlLlxuICAgKi9cbiAgZGVsZXRlKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBbbmFtZSwgb3B0aW9uc10gPSB0eXBlb2YgYXJnc1swXSA9PT0gXCJzdHJpbmdcIiA/IFthcmdzWzBdXSA6IFthcmdzWzBdLm5hbWUsIGFyZ3NbMF1dO1xuICAgIHJldHVybiB0aGlzLnNldCh7IC4uLm9wdGlvbnMsIG5hbWUsIHZhbHVlOiBcIlwiLCBleHBpcmVzOiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoMCkgfSk7XG4gIH1cbiAgW1N5bWJvbC5mb3IoXCJlZGdlLXJ1bnRpbWUuaW5zcGVjdC5jdXN0b21cIildKCkge1xuICAgIHJldHVybiBgUmVzcG9uc2VDb29raWVzICR7SlNPTi5zdHJpbmdpZnkoT2JqZWN0LmZyb21FbnRyaWVzKHRoaXMuX3BhcnNlZCkpfWA7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIFsuLi50aGlzLl9wYXJzZWQudmFsdWVzKCldLm1hcChzdHJpbmdpZnlDb29raWUpLmpvaW4oXCI7IFwiKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHJlcGxhY2UoYmFnLCBoZWFkZXJzKSB7XG4gIGhlYWRlcnMuZGVsZXRlKFwic2V0LWNvb2tpZVwiKTtcbiAgZm9yIChjb25zdCBbLCB2YWx1ZV0gb2YgYmFnKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IHN0cmluZ2lmeUNvb2tpZSh2YWx1ZSk7XG4gICAgaGVhZGVycy5hcHBlbmQoXCJzZXQtY29va2llXCIsIHNlcmlhbGl6ZWQpO1xuICB9XG59XG5mdW5jdGlvbiBub3JtYWxpemVDb29raWUoY29va2llID0geyBuYW1lOiBcIlwiLCB2YWx1ZTogXCJcIiB9KSB7XG4gIGlmICh0eXBlb2YgY29va2llLmV4cGlyZXMgPT09IFwibnVtYmVyXCIpIHtcbiAgICBjb29raWUuZXhwaXJlcyA9IG5ldyBEYXRlKGNvb2tpZS5leHBpcmVzKTtcbiAgfVxuICBpZiAoY29va2llLm1heEFnZSkge1xuICAgIGNvb2tpZS5leHBpcmVzID0gbmV3IERhdGUoRGF0ZS5ub3coKSArIGNvb2tpZS5tYXhBZ2UgKiAxZTMpO1xuICB9XG4gIGlmIChjb29raWUucGF0aCA9PT0gbnVsbCB8fCBjb29raWUucGF0aCA9PT0gdm9pZCAwKSB7XG4gICAgY29va2llLnBhdGggPSBcIi9cIjtcbiAgfVxuICByZXR1cm4gY29va2llO1xufVxuLy8gQW5ub3RhdGUgdGhlIENvbW1vbkpTIGV4cG9ydCBuYW1lcyBmb3IgRVNNIGltcG9ydCBpbiBub2RlOlxuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gIFJlcXVlc3RDb29raWVzLFxuICBSZXNwb25zZUNvb2tpZXMsXG4gIHBhcnNlQ29va2llLFxuICBwYXJzZVNldENvb2tpZSxcbiAgc3RyaW5naWZ5Q29va2llXG59KTtcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxJQUFJLFlBQVksT0FBTyxjQUFjO0FBQ3JDLElBQUksbUJBQW1CLE9BQU8sd0JBQXdCO0FBQ3RELElBQUksb0JBQW9CLE9BQU8sbUJBQW1CO0FBQ2xELElBQUksZUFBZSxPQUFPLFNBQVMsQ0FBQyxjQUFjO0FBQ2xELElBQUksV0FBVyxDQUFDLFFBQVE7SUFDdEIsSUFBSyxJQUFJLFFBQVEsSUFDZixVQUFVLFFBQVEsTUFBTTtRQUFFLEtBQUssR0FBRyxDQUFDLEtBQUs7UUFBRSxZQUFZO0lBQUs7QUFDL0Q7QUFDQSxJQUFJLGNBQWMsQ0FBQyxJQUFJLE1BQU0sUUFBUTtJQUNuQyxJQUFJLFFBQVEsT0FBTyxTQUFTLFlBQVksT0FBTyxTQUFTLFlBQVk7UUFDbEUsS0FBSyxJQUFJLE9BQU8sa0JBQWtCLE1BQ2hDLElBQUksQ0FBQyxhQUFhLElBQUksQ0FBQyxJQUFJLFFBQVEsUUFBUSxRQUN6QyxVQUFVLElBQUksS0FBSztZQUFFLEtBQUssSUFBTSxJQUFJLENBQUMsSUFB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bmUiOiAzNzksICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvc2VydmVyL3dlYi9zcGVjLWV4dGVuc2lvbi9jb29raWVzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7XG4gIFJlcXVlc3RDb29raWVzLFxuICBSZXNwb25zZUNvb2tpZXMsXG4gIHN0cmluZ2lmeUNvb2tpZSxcbn0gZnJvbSAnbmV4dC9kaXN0L2NvbXBpbGVkL0BlZGdlLXJ1bnRpbWUvY29va2llcydcbiJdLCJuYW1lcyI6WyJSZXF1ZXN0Q29va2llcyIsIlJlc3BvbnNlQ29va2llcyIsInN0cmluZ2lmeUNvb2tpZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0lBQ0VBLGNBQWMsRUFBQTtlQUFkQSxTQUFBQSxjQUFjOztJQUNkQyxlQUFlLEVBQUE7ZUFBZkEsU0FBQUEsZUFBZTs7SUFDZkMsZUFBZSxFQUFBO2VBQWZBLFNBQUFBLGVBQWU7Ozt5QkFDViIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA0MTEsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvc2VydmVyL3dlYi9zcGVjLWV4dGVuc2lvbi9hZGFwdGVycy9yZWZsZWN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjbGFzcyBSZWZsZWN0QWRhcHRlciB7XG4gIHN0YXRpYyBnZXQ8VCBleHRlbmRzIG9iamVjdD4oXG4gICAgdGFyZ2V0OiBULFxuICAgIHByb3A6IHN0cmluZyB8IHN5bWJvbCxcbiAgICByZWNlaXZlcjogdW5rbm93blxuICApOiBhbnkge1xuICAgIGNvbnN0IHZhbHVlID0gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcilcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gdmFsdWUuYmluZCh0YXJnZXQpXG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICBzdGF0aWMgc2V0PFQgZXh0ZW5kcyBvYmplY3Q+KFxuICAgIHRhcmdldDogVCxcbiAgICBwcm9wOiBzdHJpbmcgfCBzeW1ib2wsXG4gICAgdmFsdWU6IGFueSxcbiAgICByZWNlaXZlcjogYW55XG4gICk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBSZWZsZWN0LnNldCh0YXJnZXQsIHByb3AsIHZhbHVlLCByZWNlaXZlcilcbiAgfVxuXG4gIHN0YXRpYyBoYXM8VCBleHRlbmRzIG9iamVjdD4odGFyZ2V0OiBULCBwcm9wOiBzdHJpbmcgfCBzeW1ib2wpOiBib29sZWFuIHtcbiAgICByZXR1cm4gUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wKVxuICB9XG5cbiAgc3RhdGljIGRlbGV0ZVByb3BlcnR5PFQgZXh0ZW5kcyBvYmplY3Q+KFxuICAgIHRhcmdldDogVCxcbiAgICBwcm9wOiBzdHJpbmcgfCBzeW1ib2xcbiAgKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIFJlZmxlY3QuZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wKVxuICB9XG59XG4iXSwibmFtZXMiOlsiUmVmbGVjdEFkYXB0ZXIiLCJnZXQiLCJ0YXJnZXQiLCJwcm9wIiwicmVjZWl2ZXIiLCJ2YWx1ZSIsIlJlZmxlY3QiLCJiaW5kIiwic2V0IiwiaGFzIiwiZGVsZXRlUHJvcGVydHkiXSwibWFwcGluZ3MiOiI7OzsrQkFBYUEsa0JBQUFBOzs7ZUFBQUE7OztBQUFOLE1BQU1BO0lBQ1gsT0FBT0MsSUFDTEMsTUFBUyxFQUNUQyxJQUFxQixFQUNyQkMsUUFBaUIsRUFDWjtRQUNMLE1BQU1DLFFBQVFDLFFBQVFMLEdBQUcsQ0FBQ0MsUUFBUUMsTUFBTUM7UUFDeEMsSUFBSSxPQUFPQyxVQUFVLFlBQVk7WUFDL0IsT0FBT0EsTUFBTUUsSUFBSSxDQUFDTDtRQUNwQjtRQUVBLE9BQU9HO0lBQ1Q7SUFFQSxPQUFPRyxJQUNMTixNQUFTLEVBQ1RDLElBQXFCLEVBQ3JCRSxLQUFVLEVBQ1ZELFFBQWEsRUFDSjtRQUNULE9BQU9FLFFBQVFFLEdBQUcsQ0FBQ04sUUFBUUMsTUFBTUUsT0FBT0Q7SUFDMUM7SUFFQSxPQUFPSyxJQUFzQlAsTUFBUyxFQUFFQyxJQUFxQixFQUFXO1FBQ3RFLE9BQU9HLFFBQVFHLEdBQUcsQ0FBQ1AsUUFBUUM7SUFDN0I7SUFFQSxPQUFPTyxlQUNMUixNQUFTLEVBQ1RDLElBQXFCLEVBQ1o7UUFDVCxPQUFPRyxRQUFRSSxjQUFjLENBQUNSLFFBQVFDO0lBQ3hDO0FBQ0YiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNDQ0LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL3NlcnZlci93ZWIvc3BlYy1leHRlbnNpb24vYWRhcHRlcnMvcmVxdWVzdC1jb29raWVzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJlcXVlc3RDb29raWVzIH0gZnJvbSAnLi4vY29va2llcydcblxuaW1wb3J0IHsgUmVzcG9uc2VDb29raWVzIH0gZnJvbSAnLi4vY29va2llcydcbmltcG9ydCB7IFJlZmxlY3RBZGFwdGVyIH0gZnJvbSAnLi9yZWZsZWN0J1xuaW1wb3J0IHsgd29ya0FzeW5jU3RvcmFnZSB9IGZyb20gJy4uLy4uLy4uL2FwcC1yZW5kZXIvd29yay1hc3luYy1zdG9yYWdlLmV4dGVybmFsJ1xuaW1wb3J0IHtcbiAgZ2V0RXhwZWN0ZWRSZXF1ZXN0U3RvcmUsXG4gIHR5cGUgUmVxdWVzdFN0b3JlLFxufSBmcm9tICcuLi8uLi8uLi9hcHAtcmVuZGVyL3dvcmstdW5pdC1hc3luYy1zdG9yYWdlLmV4dGVybmFsJ1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY2xhc3MgUmVhZG9ubHlSZXF1ZXN0Q29va2llc0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcbiAgICAgICdDb29raWVzIGNhbiBvbmx5IGJlIG1vZGlmaWVkIGluIGEgU2VydmVyIEFjdGlvbiBvciBSb3V0ZSBIYW5kbGVyLiBSZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9hcGktcmVmZXJlbmNlL2Z1bmN0aW9ucy9jb29raWVzI29wdGlvbnMnXG4gICAgKVxuICB9XG5cbiAgcHVibGljIHN0YXRpYyBjYWxsYWJsZSgpIHtcbiAgICB0aHJvdyBuZXcgUmVhZG9ubHlSZXF1ZXN0Q29va2llc0Vycm9yKClcbiAgfVxufVxuXG4vLyBXZSB1c2UgdGhpcyB0byB0eXBlIHNvbWUgQVBJcyBidXQgd2UgZG9uJ3QgY29uc3RydWN0IGluc3RhbmNlcyBkaXJlY3RseVxuZXhwb3J0IHR5cGUgeyBSZXNwb25zZUNvb2tpZXMgfVxuXG4vLyBUaGUgYGNvb2tpZXMoKWAgQVBJIGlzIGEgbWl4IG9mIHJlcXVlc3QgYW5kIHJlc3BvbnNlIGNvb2tpZXMuIEZvciBgLmdldCgpYCBtZXRob2RzLFxuLy8gd2Ugd2FudCB0byByZXR1cm4gdGhlIHJlcXVlc3QgY29va2llIGlmIGl0IGV4aXN0cy4gRm9yIG11dGF0aXZlIG1ldGhvZHMgbGlrZSBgLnNldCgpYCxcbi8vIHdlIHdhbnQgdG8gcmV0dXJuIHRoZSByZXNwb25zZSBjb29raWUuXG5leHBvcnQgdHlwZSBSZWFkb25seVJlcXVlc3RDb29raWVzID0gT21pdDxcbiAgUmVxdWVzdENvb2tpZXMsXG4gICdzZXQnIHwgJ2NsZWFyJyB8ICdkZWxldGUnXG4+ICZcbiAgUGljazxSZXNwb25zZUNvb2tpZXMsICdzZXQnIHwgJ2RlbGV0ZSc+XG5cbmV4cG9ydCBjbGFzcyBSZXF1ZXN0Q29va2llc0FkYXB0ZXIge1xuICBwdWJsaWMgc3RhdGljIHNlYWwoY29va2llczogUmVxdWVzdENvb2tpZXMpOiBSZWFkb25seVJlcXVlc3RDb29raWVzIHtcbiAgICByZXR1cm4gbmV3IFByb3h5KGNvb2tpZXMgYXMgYW55LCB7XG4gICAgICBnZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgICBzd2l0Y2ggKHByb3ApIHtcbiAgICAgICAgICBjYXNlICdjbGVhcic6XG4gICAgICAgICAgY2FzZSAnZGVsZXRlJzpcbiAgICAgICAgICBjYXNlICdzZXQnOlxuICAgICAgICAgICAgcmV0dXJuIFJlYWRvbmx5UmVxdWVzdENvb2tpZXNFcnJvci5jYWxsYWJsZVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdEFkYXB0ZXIuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfSlcbiAgfVxufVxuXG5jb25zdCBTWU1CT0xfTU9ESUZZX0NPT0tJRV9WQUxVRVMgPSBTeW1ib2wuZm9yKCduZXh0Lm11dGF0ZWQuY29va2llcycpXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRNb2RpZmllZENvb2tpZVZhbHVlcyhcbiAgY29va2llczogUmVzcG9uc2VDb29raWVzXG4pOiBSZXNwb25zZUNvb2tpZVtdIHtcbiAgY29uc3QgbW9kaWZpZWQ6IFJlc3BvbnNlQ29va2llW10gfCB1bmRlZmluZWQgPSAoY29va2llcyBhcyB1bmtub3duIGFzIGFueSlbXG4gICAgU1lNQk9MX01PRElGWV9DT09LSUVfVkFMVUVTXG4gIF1cbiAgaWYgKCFtb2RpZmllZCB8fCAhQXJyYXkuaXNBcnJheShtb2RpZmllZCkgfHwgbW9kaWZpZWQubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtdXG4gIH1cblxuICByZXR1cm4gbW9kaWZpZWRcbn1cblxudHlwZSBTZXRDb29raWVBcmdzID1cbiAgfCBba2V5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcsIGNvb2tpZT86IFBhcnRpYWw8UmVzcG9uc2VDb29raWU+XVxuICB8IFtvcHRpb25zOiBSZXNwb25zZUNvb2tpZV1cblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGVuZE11dGFibGVDb29raWVzKFxuICBoZWFkZXJzOiBIZWFkZXJzLFxuICBtdXRhYmxlQ29va2llczogUmVzcG9uc2VDb29raWVzXG4pOiBib29sZWFuIHtcbiAgY29uc3QgbW9kaWZpZWRDb29raWVWYWx1ZXMgPSBnZXRNb2RpZmllZENvb2tpZVZhbHVlcyhtdXRhYmxlQ29va2llcylcbiAgaWYgKG1vZGlmaWVkQ29va2llVmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gUmV0dXJuIGEgbmV3IHJlc3BvbnNlIHRoYXQgZXh0ZW5kcyB0aGUgcmVzcG9uc2Ugd2l0aFxuICAvLyB0aGUgbW9kaWZpZWQgY29va2llcyBhcyBmYWxsYmFja3MuIGByZXNgIGNvb2tpZXNcbiAgLy8gd2lsbCBzdGlsbCB0YWtlIHByZWNlZGVuY2UuXG4gIGNvbnN0IHJlc0Nvb2tpZXMgPSBuZXcgUmVzcG9uc2VDb29raWVzKGhlYWRlcnMpXG4gIGNvbnN0IHJldHVybmVkQ29va2llcyA9IHJlc0Nvb2tpZXMuZ2V0QWxsKClcblxuICAvLyBTZXQgdGhlIG1vZGlmaWVkIGNvb2tpZXMgYXMgZmFsbGJhY2tzLlxuICBmb3IgKGNvbnN0IGNvb2tpZSBvZiBtb2RpZmllZENvb2tpZVZhbHVlcykge1xuICAgIHJlc0Nvb2tpZXMuc2V0KGNvb2tpZSlcbiAgfVxuXG4gIC8vIFNldCB0aGUgb3JpZ2luYWwgY29va2llcyBhcyB0aGUgZmluYWwgdmFsdWVzLlxuICBmb3IgKGNvbnN0IGNvb2tpZSBvZiByZXR1cm5lZENvb2tpZXMpIHtcbiAgICByZXNDb29raWVzLnNldChjb29raWUpXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG50eXBlIFJlc3BvbnNlQ29va2llID0gTm9uTnVsbGFibGU8XG4gIFJldHVyblR5cGU8SW5zdGFuY2VUeXBlPHR5cGVvZiBSZXNwb25zZUNvb2tpZXM+WydnZXQnXT5cbj5cblxuZXhwb3J0IGNsYXNzIE11dGFibGVSZXF1ZXN0Q29va2llc0FkYXB0ZXIge1xuICBwdWJsaWMgc3RhdGljIHdyYXAoXG4gICAgY29va2llczogUmVxdWVzdENvb2tpZXMsXG4gICAgb25VcGRhdGVDb29raWVzPzogKGNvb2tpZXM6IHN0cmluZ1tdKSA9PiB2b2lkXG4gICk6IFJlc3BvbnNlQ29va2llcyB7XG4gICAgY29uc3QgcmVzcG9uc2VDb29raWVzID0gbmV3IFJlc3BvbnNlQ29va2llcyhuZXcgSGVhZGVycygpKVxuICAgIGZvciAoY29uc3QgY29va2llIG9mIGNvb2tpZXMuZ2V0QWxsKCkpIHtcbiAgICAgIHJlc3BvbnNlQ29va2llcy5zZXQoY29va2llKVxuICAgIH1cblxuICAgIGxldCBtb2RpZmllZFZhbHVlczogUmVzcG9uc2VDb29raWVbXSA9IFtdXG4gICAgY29uc3QgbW9kaWZpZWRDb29raWVzID0gbmV3IFNldDxzdHJpbmc+KClcbiAgICBjb25zdCB1cGRhdGVSZXNwb25zZUNvb2tpZXMgPSAoKSA9PiB7XG4gICAgICAvLyBUT0RPLUFQUDogY2hhbmdlIG1ldGhvZCBvZiBnZXR0aW5nIHdvcmtTdG9yZVxuICAgICAgY29uc3Qgd29ya1N0b3JlID0gd29ya0FzeW5jU3RvcmFnZS5nZXRTdG9yZSgpXG4gICAgICBpZiAod29ya1N0b3JlKSB7XG4gICAgICAgIHdvcmtTdG9yZS5wYXRoV2FzUmV2YWxpZGF0ZWQgPSB0cnVlXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGFsbENvb2tpZXMgPSByZXNwb25zZUNvb2tpZXMuZ2V0QWxsKClcbiAgICAgIG1vZGlmaWVkVmFsdWVzID0gYWxsQ29va2llcy5maWx0ZXIoKGMpID0+IG1vZGlmaWVkQ29va2llcy5oYXMoYy5uYW1lKSlcbiAgICAgIGlmIChvblVwZGF0ZUNvb2tpZXMpIHtcbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZENvb2tpZXM6IHN0cmluZ1tdID0gW11cbiAgICAgICAgZm9yIChjb25zdCBjb29raWUgb2YgbW9kaWZpZWRWYWx1ZXMpIHtcbiAgICAgICAgICBjb25zdCB0ZW1wQ29va2llcyA9IG5ldyBSZXNwb25zZUNvb2tpZXMobmV3IEhlYWRlcnMoKSlcbiAgICAgICAgICB0ZW1wQ29va2llcy5zZXQoY29va2llKVxuICAgICAgICAgIHNlcmlhbGl6ZWRDb29raWVzLnB1c2godGVtcENvb2tpZXMudG9TdHJpbmcoKSlcbiAgICAgICAgfVxuXG4gICAgICAgIG9uVXBkYXRlQ29va2llcyhzZXJpYWxpemVkQ29va2llcylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB3cmFwcGVkQ29va2llcyA9IG5ldyBQcm94eShyZXNwb25zZUNvb2tpZXMsIHtcbiAgICAgIGdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG4gICAgICAgIHN3aXRjaCAocHJvcCkge1xuICAgICAgICAgIC8vIEEgc3BlY2lhbCBzeW1ib2wgdG8gZ2V0IHRoZSBtb2RpZmllZCBjb29raWUgdmFsdWVzXG4gICAgICAgICAgY2FzZSBTWU1CT0xfTU9ESUZZX0NPT0tJRV9WQUxVRVM6XG4gICAgICAgICAgICByZXR1cm4gbW9kaWZpZWRWYWx1ZXNcblxuICAgICAgICAgIC8vIFRPRE86IFRocm93IGVycm9yIGlmIHRyeWluZyB0byBzZXQgYSBjb29raWUgYWZ0ZXIgdGhlIHJlc3BvbnNlXG4gICAgICAgICAgLy8gaGVhZGVycyBoYXZlIGJlZW4gc2V0LlxuICAgICAgICAgIGNhc2UgJ2RlbGV0ZSc6XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3M6IFtzdHJpbmddIHwgW1Jlc3BvbnNlQ29va2llXSkge1xuICAgICAgICAgICAgICBtb2RpZmllZENvb2tpZXMuYWRkKFxuICAgICAgICAgICAgICAgIHR5cGVvZiBhcmdzWzBdID09PSAnc3RyaW5nJyA/IGFyZ3NbMF0gOiBhcmdzWzBdLm5hbWVcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRhcmdldC5kZWxldGUoLi4uYXJncylcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZENvb2tpZXNcbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB1cGRhdGVSZXNwb25zZUNvb2tpZXMoKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnc2V0JzpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJnczogU2V0Q29va2llQXJncykge1xuICAgICAgICAgICAgICBtb2RpZmllZENvb2tpZXMuYWRkKFxuICAgICAgICAgICAgICAgIHR5cGVvZiBhcmdzWzBdID09PSAnc3RyaW5nJyA/IGFyZ3NbMF0gOiBhcmdzWzBdLm5hbWVcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRhcmdldC5zZXQoLi4uYXJncylcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZENvb2tpZXNcbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB1cGRhdGVSZXNwb25zZUNvb2tpZXMoKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3RBZGFwdGVyLmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgIH0pXG5cbiAgICByZXR1cm4gd3JhcHBlZENvb2tpZXNcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gd3JhcFdpdGhNdXRhYmxlQWNjZXNzQ2hlY2soXG4gIHJlc3BvbnNlQ29va2llczogUmVzcG9uc2VDb29raWVzXG4pOiBSZXNwb25zZUNvb2tpZXMge1xuICBjb25zdCB3cmFwcGVkQ29va2llcyA9IG5ldyBQcm94eShyZXNwb25zZUNvb2tpZXMsIHtcbiAgICBnZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgc3dpdGNoIChwcm9wKSB7XG4gICAgICAgIGNhc2UgJ2RlbGV0ZSc6XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzOiBbc3RyaW5nXSB8IFtSZXNwb25zZUNvb2tpZV0pIHtcbiAgICAgICAgICAgIGVuc3VyZUNvb2tpZXNBcmVTdGlsbE11dGFibGUoJ2Nvb2tpZXMoKS5kZWxldGUnKVxuICAgICAgICAgICAgdGFyZ2V0LmRlbGV0ZSguLi5hcmdzKVxuICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWRDb29raWVzXG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdzZXQnOlxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJnczogU2V0Q29va2llQXJncykge1xuICAgICAgICAgICAgZW5zdXJlQ29va2llc0FyZVN0aWxsTXV0YWJsZSgnY29va2llcygpLnNldCcpXG4gICAgICAgICAgICB0YXJnZXQuc2V0KC4uLmFyZ3MpXG4gICAgICAgICAgICByZXR1cm4gd3JhcHBlZENvb2tpZXNcbiAgICAgICAgICB9XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gUmVmbGVjdEFkYXB0ZXIuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpXG4gICAgICB9XG4gICAgfSxcbiAgfSlcbiAgcmV0dXJuIHdyYXBwZWRDb29raWVzXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcmVDb29raWVzTXV0YWJsZUluQ3VycmVudFBoYXNlKHJlcXVlc3RTdG9yZTogUmVxdWVzdFN0b3JlKSB7XG4gIHJldHVybiByZXF1ZXN0U3RvcmUucGhhc2UgPT09ICdhY3Rpb24nXG59XG5cbi8qKiBFbnN1cmUgdGhhdCBjb29raWVzKCkgc3RhcnRzIHRocm93aW5nIG9uIG11dGF0aW9uXG4gKiBpZiB3ZSBjaGFuZ2VkIHBoYXNlcyBhbmQgY2FuIG5vIGxvbmdlciBtdXRhdGUuXG4gKlxuICogVGhpcyBjYW4gaGFwcGVuIHdoZW4gZ29pbmc6XG4gKiAgICdyZW5kZXInIC0+ICdhZnRlcidcbiAqICAgJ2FjdGlvbicgLT4gJ3JlbmRlcidcbiAqICovXG5mdW5jdGlvbiBlbnN1cmVDb29raWVzQXJlU3RpbGxNdXRhYmxlKGNhbGxpbmdFeHByZXNzaW9uOiBzdHJpbmcpIHtcbiAgY29uc3QgcmVxdWVzdFN0b3JlID0gZ2V0RXhwZWN0ZWRSZXF1ZXN0U3RvcmUoY2FsbGluZ0V4cHJlc3Npb24pXG4gIGlmICghYXJlQ29va2llc011dGFibGVJbkN1cnJlbnRQaGFzZShyZXF1ZXN0U3RvcmUpKSB7XG4gICAgLy8gVE9ETzogbWF5YmUgd2UgY2FuIGdpdmUgYSBtb3JlIHByZWNpc2UgZXJyb3IgbWVzc2FnZSBiYXNlZCBvbiBjYWxsaW5nRXhwcmVzc2lvbj9cbiAgICB0aHJvdyBuZXcgUmVhZG9ubHlSZXF1ZXN0Q29va2llc0Vycm9yKClcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzcG9uc2VDb29raWVzVG9SZXF1ZXN0Q29va2llcyhcbiAgcmVzcG9uc2VDb29raWVzOiBSZXNwb25zZUNvb2tpZXNcbik6IFJlcXVlc3RDb29raWVzIHtcbiAgY29uc3QgcmVxdWVzdENvb2tpZXMgPSBuZXcgUmVxdWVzdENvb2tpZXMobmV3IEhlYWRlcnMoKSlcbiAgZm9yIChjb25zdCBjb29raWUgb2YgcmVzcG9uc2VDb29raWVzLmdldEFsbCgpKSB7XG4gICAgcmVxdWVzdENvb2tpZXMuc2V0KGNvb2tpZSlcbiAgfVxuICByZXR1cm4gcmVxdWVzdENvb2tpZXNcbn1cbiJdLCJuYW1lcyI6WyJNdXRhYmxlUmVxdWVzdENvb2tpZXNBZGFwdGVyIiwiUmVhZG9ubHlSZXF1ZXN0Q29va2llc0Vycm9yIiwiUmVxdWVzdENvb2tpZXNBZGFwdGVyIiwiYXBwZW5kTXV0YWJsZUNvb2tpZXMiLCJhcmVDb29raWVzTXV0YWJsZUluQ3VycmVudFBoYXNlIiwiZ2V0TW9kaWZpZWRDb29raWVWYWx1ZXMiLCJyZXNwb25zZUNvb2tpZXNUb1JlcXVlc3RDb29raWVzIiwid3JhcFdpdGhNdXRhYmxlQWNjZXNzQ2hlY2siLCJFcnJvciIsImNvbnN0cnVjdG9yIiwiY2FsbGFibGUiLCJzZWFsIiwiY29va2llcyIsIlByb3h5IiwiZ2V0IiwidGFyZ2V0IiwicHJvcCIsInJlY2VpdmVyIiwiUmVmbGVjdEFkYXB0ZXIiLCJTWU1CT0xfTU9ESUZZX0NPT0tJRV9WQUxVRVMiLCJTeW1ib2wiLCJmb3IiLCJtb2RpZmllZCIsIkFycmF5IiwiaXNBcnJheSIsImxlbmd0aCIsImhlYWRlcnMiLCJtdXRhYmxlQ29va2llcyIsIm1vZGlmaWVkQ29va2llVmFsdWVzIiwicmVzQ29va2llcyIsIlJlc3BvbnNlQ29va2llcyIsInJldHVybmVkQ29va2llcyIsImdldEFsbCIsImNvb2tpZSIsInNldCIsIndyYXAiLCJvblVwZGF0ZUNvb2tpZXMiLCJyZXNwb25zZUNvb2tpZXMiLCJIZWFkZXJzIiwibW9kaWZpZWRWYWx1ZXMiLCJtb2RpZmllZENvb2tpZXMiLCJTZXQiLCJ1cGRhdGVSZXNwb25zZUNvb2tpZXMiLCJ3b3JrU3RvcmUiLCJ3b3JrQXN5bmNTdG9yYWdlIiwiZ2V0U3RvcmUiLCJwYXRoV2FzUmV2YWxpZGF0ZWQiLCJhbGxDb29raWVzIiwiZmlsdGVyIiwiYyIsImhhcyIsIm5hbWUiLCJzZXJpYWxpemVkQ29va2llcyIsInRlbXBDb29raWVzIiwicHVzaCIsInRvU3RyaW5nIiwid3JhcHBlZENvb2tpZXMiLCJhcmdzIiwiYWRkIiwiZGVsZXRlIiwiZW5zdXJlQ29va2llc0FyZVN0aWxsTXV0YWJsZSIsInJlcXVlc3RTdG9yZSIsInBoYXNlIiwiY2FsbGluZ0V4cHJlc3Npb24iLCJnZXRFeHBlY3RlZFJlcXVlc3RTdG9yZSIsInJlcXVlc3RDb29raWVzIiwiUmVxdWVzdENvb2tpZXMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBeUdhQSw0QkFBNEIsRUFBQTtlQUE1QkE7O0lBNUZBQywyQkFBMkIsRUFBQTtlQUEzQkE7O0lBd0JBQyxxQkFBcUIsRUFBQTtlQUFyQkE7O0lBb0NHQyxvQkFBb0IsRUFBQTtlQUFwQkE7O0lBd0lBQywrQkFBK0IsRUFBQTtlQUEvQkE7O0lBekpBQyx1QkFBdUIsRUFBQTtlQUF2QkE7O0lBNEtBQywrQkFBK0IsRUFBQTtlQUEvQkE7O0lBOUNBQywwQkFBMEIsRUFBQTtlQUExQkE7Ozt5QkF0TGU7eUJBR0E7MENBQ0U7OENBSTFCO0FBS0EsTUFBTU4sb0NBQW9DTztJQUMvQ0MsYUFBYztRQUNaLEtBQUssQ0FDSDtJQUVKO0lBRUEsT0FBY0MsV0FBVztRQUN2QixNQUFNLElBQUlUO0lBQ1o7QUFDRjtBQWNPLE1BQU1DO0lBQ1gsT0FBY1MsS0FBS0MsT0FBdUIsRUFBMEI7UUFDbEUsT0FBTyxJQUFJQyxNQUFNRCxTQUFnQjtZQUMvQkUsS0FBSUMsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLFFBQVE7Z0JBQ3hCLE9BQVFEO29CQUNOLEtBQUs7b0JBQ0wsS0FBSztvQkFDTCxLQUFLO3dCQUNILE9BQU9mLDRCQUE0QlMsUUFBUTtvQkFDN0M7d0JBQ0UsT0FBT1EsU0FBQUEsY0FBYyxDQUFDSixHQUFHLENBQUNDLFFBQVFDLE1BQU1DO2dCQUM1QztZQUNGO1FBQ0Y7SUFDRjtBQUNGO0FBRUEsTUFBTUUsOEJBQThCQyxPQUFPQyxHQUFHLENBQUM7QUFFeEMsU0FBU2hCLHdCQUNkTyxPQUF3QjtJQUV4QixNQUFNVSxXQUEwQ1YsT0FBMEIsQ0FDeEVPLDRCQUNEO0lBQ0QsSUFBSSxDQUFDRyxZQUFZLENBQUNDLE1BQU1DLE9BQU8sQ0FBQ0YsYUFBYUEsU0FBU0csTUFBTSxLQUFLLEdBQUc7UUFDbEUsT0FBTyxFQUFFO0lBQ1g7SUFFQSxPQUFPSDtBQUNUO0FBTU8sU0FBU25CLHFCQUNkdUIsT0FBZ0IsRUFDaEJDLGNBQStCO0lBRS9CLE1BQU1DLHVCQUF1QnZCLHdCQUF3QnNCO0lBQ3JELElBQUlDLHFCQUFxQkgsTUFBTSxLQUFLLEdBQUc7UUFDckMsT0FBTztJQUNUO0lBRUEsdURBQXVEO0lBQ3ZELG1EQUFtRDtJQUNuRCw4QkFBOEI7SUFDOUIsTUFBTUksYUFBYSxJQUFJQyxTQUFBQSxlQUFlLENBQUNKO0lBQ3ZDLE1BQU1LLGtCQUFrQkYsV0FBV0csTUFBTTtJQUV6Qyx5Q0FBeUM7SUFDekMsS0FBSyxNQUFNQyxVQUFVTCxxQkFBc0I7UUFDekNDLFdBQVdLLEdBQUcsQ0FBQ0Q7SUFDakI7SUFFQSxnREFBZ0Q7SUFDaEQsS0FBSyxNQUFNQSxVQUFVRixnQkFBaUI7UUFDcENGLFdBQVdLLEdBQUcsQ0FBQ0Q7SUFDakI7SUFFQSxPQUFPO0FBQ1Q7QUFNTyxNQUFNakM7SUFDWCxPQUFjbUMsS0FDWnZCLE9BQXVCLEVBQ3ZCd0IsZUFBNkMsRUFDNUI7UUFDakIsTUFBTUMsa0JBQWtCLElBQUlQLFNBQUFBLGVBQWUsQ0FBQyxJQUFJUTtRQUNoRCxLQUFLLE1BQU1MLFVBQVVyQixRQUFRb0IsTUFBTSxHQUFJO1lBQ3JDSyxnQkFBZ0JILEdBQUcsQ0FBQ0Q7UUFDdEI7UUFFQSxJQUFJTSxpQkFBbUMsRUFBRTtRQUN6QyxNQUFNQyxrQkFBa0IsSUFBSUM7UUFDNUIsTUFBTUMsd0JBQXdCO1lBQzVCLCtDQUErQztZQUMvQyxNQUFNQyxZQUFZQywwQkFBQUEsZ0JBQWdCLENBQUNDLFFBQVE7WUFDM0MsSUFBSUYsV0FBVztnQkFDYkEsVUFBVUcsa0JBQWtCLEdBQUc7WUFDakM7WUFFQSxNQUFNQyxhQUFhVixnQkFBZ0JMLE1BQU07WUFDekNPLGlCQUFpQlEsV0FBV0MsTUFBTSxDQUFDLENBQUNDLElBQU1ULGdCQUFnQlUsR0FBRyxDQUFDRCxFQUFFRSxJQUFJO1lBQ3BFLElBQUlmLGlCQUFpQjtnQkFDbkIsTUFBTWdCLG9CQUE4QixFQUFFO2dCQUN0QyxLQUFLLE1BQU1uQixVQUFVTSxlQUFnQjtvQkFDbkMsTUFBTWMsY0FBYyxJQUFJdkIsU0FBQUEsZUFBZSxDQUFDLElBQUlRO29CQUM1Q2UsWUFBWW5CLEdBQUcsQ0FBQ0Q7b0JBQ2hCbUIsa0JBQWtCRSxJQUFJLENBQUNELFlBQVlFLFFBQVE7Z0JBQzdDO2dCQUVBbkIsZ0JBQWdCZ0I7WUFDbEI7UUFDRjtRQUVBLE1BQU1JLGlCQUFpQixJQUFJM0MsTUFBTXdCLGlCQUFpQjtZQUNoRHZCLEtBQUlDLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxRQUFRO2dCQUN4QixPQUFRRDtvQkFDTixxREFBcUQ7b0JBQ3JELEtBQUtHO3dCQUNILE9BQU9vQjtvQkFFVCxpRUFBaUU7b0JBQ2pFLHlCQUF5QjtvQkFDekIsS0FBSzt3QkFDSCxPQUFPLFNBQVUsR0FBR2tCLElBQWlDOzRCQUNuRGpCLGdCQUFnQmtCLEdBQUcsQ0FDakIsT0FBT0QsSUFBSSxDQUFDLEVBQUUsS0FBSyxXQUFXQSxJQUFJLENBQUMsRUFBRSxHQUFHQSxJQUFJLENBQUMsRUFBRSxDQUFDTixJQUFJOzRCQUV0RCxJQUFJO2dDQUNGcEMsT0FBTzRDLE1BQU0sSUFBSUY7Z0NBQ2pCLE9BQU9EOzRCQUNULFNBQVU7Z0NBQ1JkOzRCQUNGO3dCQUNGO29CQUNGLEtBQUs7d0JBQ0gsT0FBTyxTQUFVLEdBQUdlLElBQW1COzRCQUNyQ2pCLGdCQUFnQmtCLEdBQUcsQ0FDakIsT0FBT0QsSUFBSSxDQUFDLEVBQUUsS0FBSyxXQUFXQSxJQUFJLENBQUMsRUFBRSxHQUFHQSxJQUFJLENBQUMsRUFBRSxDQUFDTixJQUFJOzRCQUV0RCxJQUFJO2dDQUNGcEMsT0FBT21CLEdBQUcsSUFBSXVCO2dDQUNkLE9BQU9EOzRCQUNULFNBQVU7Z0NBQ1JkOzRCQUNGO3dCQUNGO29CQUVGO3dCQUNFLE9BQU94QixTQUFBQSxjQUFjLENBQUNKLEdBQUcsQ0FBQ0MsUUFBUUMsTUFBTUM7Z0JBQzVDO1lBQ0Y7UUFDRjtRQUVBLE9BQU91QztJQUNUO0FBQ0Y7QUFFTyxTQUFTakQsMkJBQ2Q4QixlQUFnQztJQUVoQyxNQUFNbUIsaUJBQWlCLElBQUkzQyxNQUFNd0IsaUJBQWlCO1FBQ2hEdkIsS0FBSUMsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLFFBQVE7WUFDeEIsT0FBUUQ7Z0JBQ04sS0FBSztvQkFDSCxPQUFPLFNBQVUsR0FBR3lDLElBQWlDO3dCQUNuREcsNkJBQTZCO3dCQUM3QjdDLE9BQU80QyxNQUFNLElBQUlGO3dCQUNqQixPQUFPRDtvQkFDVDtnQkFDRixLQUFLO29CQUNILE9BQU8sU0FBVSxHQUFHQyxJQUFtQjt3QkFDckNHLDZCQUE2Qjt3QkFDN0I3QyxPQUFPbUIsR0FBRyxJQUFJdUI7d0JBQ2QsT0FBT0Q7b0JBQ1Q7Z0JBRUY7b0JBQ0UsT0FBT3RDLFNBQUFBLGNBQWMsQ0FBQ0osR0FBRyxDQUFDQyxRQUFRQyxNQUFNQztZQUM1QztRQUNGO0lBQ0Y7SUFDQSxPQUFPdUM7QUFDVDtBQUVPLFNBQVNwRCxnQ0FBZ0N5RCxZQUEwQjtJQUN4RSxPQUFPQSxhQUFhQyxLQUFLLEtBQUs7QUFDaEM7QUFFQTs7Ozs7O0dBTUcsR0FDSCxTQUFTRiw2QkFBNkJHLGlCQUF5QjtJQUM3RCxNQUFNRixlQUFlRyxDQUFBQSxHQUFBQSw4QkFBQUEsdUJBQXVCLEVBQUNEO0lBQzdDLElBQUksQ0FBQzNELGdDQUFnQ3lELGVBQWU7UUFDbEQsbUZBQW1GO1FBQ25GLE1BQU0sSUFBSTVEO0lBQ1o7QUFDRjtBQUVPLFNBQVNLLGdDQUNkK0IsZUFBZ0M7SUFFaEMsTUFBTTRCLGlCQUFpQixJQUFJQyxTQUFBQSxjQUFjLENBQUMsSUFBSTVCO0lBQzlDLEtBQUssTUFBTUwsVUFBVUksZ0JBQWdCTCxNQUFNLEdBQUk7UUFDN0NpQyxlQUFlL0IsR0FBRyxDQUFDRDtJQUNyQjtJQUNBLE9BQU9nQztBQUNUIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDY1OSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9zZXJ2ZXIvY3JlYXRlLWRlZHVwZWQtYnktY2FsbHNpdGUtc2VydmVyLWVycm9yLWxvZ2dlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCdcblxuY29uc3QgZXJyb3JSZWY6IHsgY3VycmVudDogbnVsbCB8IEVycm9yIH0gPSB7IGN1cnJlbnQ6IG51bGwgfVxuXG4vLyBSZWFjdC5jYWNoZSBpcyBjdXJyZW50bHkgb25seSBhdmFpbGFibGUgaW4gY2FuYXJ5L2V4cGVyaW1lbnRhbCBSZWFjdCBjaGFubmVscy5cbmNvbnN0IGNhY2hlID1cbiAgdHlwZW9mIFJlYWN0LmNhY2hlID09PSAnZnVuY3Rpb24nXG4gICAgPyBSZWFjdC5jYWNoZVxuICAgIDogKGZuOiAoa2V5OiB1bmtub3duKSA9PiB2b2lkKSA9PiBmblxuXG4vLyBXaGVuIER5bmFtaWMgSU8gaXMgZW5hYmxlZCwgd2UgcmVjb3JkIHRoZXNlIGFzIGVycm9ycyBzbyB0aGF0IHRoZXlcbi8vIGFyZSBjYXB0dXJlZCBieSB0aGUgZGV2IG92ZXJsYXkgYXMgaXQncyBtb3JlIGNyaXRpY2FsIHRvIGZpeCB0aGVzZVxuLy8gd2hlbiBlbmFibGVkLlxuY29uc3QgbG9nRXJyb3JPcldhcm4gPSBwcm9jZXNzLmVudi5fX05FWFRfRFlOQU1JQ19JT1xuICA/IGNvbnNvbGUuZXJyb3JcbiAgOiBjb25zb2xlLndhcm5cblxuLy8gV2UgZG9uJ3Qgd2FudCB0byBkZWR1cGUgYWNyb3NzIHJlcXVlc3RzLlxuLy8gVGhlIGRldmVsb3BlciBtaWdodCd2ZSBqdXN0IGF0dGVtcHRlZCB0byBmaXggdGhlIHdhcm5pbmcgc28gd2Ugc2hvdWxkIHdhcm4gYWdhaW4gaWYgaXQgc3RpbGwgaGFwcGVucy5cbmNvbnN0IGZsdXNoQ3VycmVudEVycm9ySWZOZXcgPSBjYWNoZShcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFycyAtLSBjYWNoZSBrZXlcbiAgKGtleTogdW5rbm93bikgPT4ge1xuICAgIHRyeSB7XG4gICAgICBsb2dFcnJvck9yV2FybihlcnJvclJlZi5jdXJyZW50KVxuICAgIH0gZmluYWxseSB7XG4gICAgICBlcnJvclJlZi5jdXJyZW50ID0gbnVsbFxuICAgIH1cbiAgfVxuKVxuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGxvZ3MgYW4gZXJyb3IgbWVzc2FnZSB0aGF0IGlzIGRlZHVwZWQgYnkgdGhlIHVzZXJsYW5kXG4gKiBjYWxsc2l0ZS5cbiAqIFRoaXMgcmVxdWlyZXMgbm8gaW5kaXJlY3Rpb24gYmV0d2VlbiB0aGUgY2FsbCBvZiB0aGlzIGZ1bmN0aW9uIGFuZCB0aGUgdXNlcmxhbmRcbiAqIGNhbGxzaXRlIGkuZS4gdGhlcmUncyBvbmx5IGEgc2luZ2xlIGxpYnJhcnkgZnJhbWUgYWJvdmUgdGhpcy5cbiAqIERvIG5vdCB1c2Ugb24gdGhlIENsaWVudCB3aGVyZSBzb3VyY2VtYXBzIGFuZCBpZ25vcmUgbGlzdGluZyBtaWdodCBiZSBlbmFibGVkLlxuICogT25seSB1c2UgdGhhdCBmb3Igd2FybmluZ3MgbmVlZCBhIGZpeCBpbmRlcGVuZGVudCBvZiB0aGUgY2FsbHN0YWNrLlxuICpcbiAqIEBwYXJhbSBnZXRNZXNzYWdlXG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRGVkdXBlZEJ5Q2FsbHNpdGVTZXJ2ZXJFcnJvckxvZ2dlckRldjxBcmdzIGV4dGVuZHMgYW55W10+KFxuICBnZXRNZXNzYWdlOiAoLi4uYXJnczogQXJncykgPT4gRXJyb3Jcbikge1xuICByZXR1cm4gZnVuY3Rpb24gbG9nRGVkdXBlZEVycm9yKC4uLmFyZ3M6IEFyZ3MpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gZ2V0TWVzc2FnZSguLi5hcmdzKVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNvbnN0IGNhbGxTdGFja0ZyYW1lcyA9IG5ldyBFcnJvcigpLnN0YWNrPy5zcGxpdCgnXFxuJylcbiAgICAgIGlmIChjYWxsU3RhY2tGcmFtZXMgPT09IHVuZGVmaW5lZCB8fCBjYWxsU3RhY2tGcmFtZXMubGVuZ3RoIDwgNCkge1xuICAgICAgICBsb2dFcnJvck9yV2FybihtZXNzYWdlKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRXJyb3I6XG4gICAgICAgIC8vICAgbG9nRGVkdXBlZEVycm9yXG4gICAgICAgIC8vICAgYXN5bmNBcGlCZWluZ0FjY2Vzc2VkU3luY2hyb25vdXNseVxuICAgICAgICAvLyAgIDx1c2VybGFuZCBjYWxsc2l0ZT5cbiAgICAgICAgLy8gVE9ETzogVGhpcyBicmVha3MgaWYgc291cmNlbWFwcyB3aXRoIGlnbm9yZSBsaXN0cyBhcmUgZW5hYmxlZC5cbiAgICAgICAgY29uc3Qga2V5ID0gY2FsbFN0YWNrRnJhbWVzWzRdXG4gICAgICAgIGVycm9yUmVmLmN1cnJlbnQgPSBtZXNzYWdlXG4gICAgICAgIGZsdXNoQ3VycmVudEVycm9ySWZOZXcoa2V5KVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsb2dFcnJvck9yV2FybihtZXNzYWdlKVxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbImNyZWF0ZURlZHVwZWRCeUNhbGxzaXRlU2VydmVyRXJyb3JMb2dnZXJEZXYiLCJlcnJvclJlZiIsImN1cnJlbnQiLCJjYWNoZSIsIlJlYWN0IiwiZm4iLCJsb2dFcnJvck9yV2FybiIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfRFlOQU1JQ19JTyIsImNvbnNvbGUiLCJlcnJvciIsIndhcm4iLCJmbHVzaEN1cnJlbnRFcnJvcklmTmV3Iiwia2V5IiwiZ2V0TWVzc2FnZSIsImxvZ0RlZHVwZWRFcnJvciIsImFyZ3MiLCJtZXNzYWdlIiwiTk9ERV9FTlYiLCJjYWxsU3RhY2tGcmFtZXMiLCJFcnJvciIsInN0YWNrIiwic3BsaXQiLCJ1bmRlZmluZWQiLCJsZW5ndGgiXSwibWFwcGluZ3MiOiI7OzsrQkF5Q2dCQSwrQ0FBQUE7OztlQUFBQTs7OytEQXpDTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRXZCLE1BQU1DLFdBQXNDO0lBQUVDLFNBQVM7QUFBSztBQUU1RCxpRkFBaUY7QUFDakYsTUFBTUMsUUFDSixPQUFPQyxPQUFNRCxLQUFLLEtBQUssYUFDbkJDLE9BQU1ELEtBQUssR0FDWCxDQUFDRSxLQUErQkE7QUFFdEMscUVBQXFFO0FBQ3JFLHFFQUFxRTtBQUNyRSxnQkFBZ0I7QUFDaEIsTUFBTUMsaUJBQWlCQyxRQUFRQyxHQUFHLENBQUNDLGlCQUFpQixTQUNoREMsUUFBUUMsS0FBSyxhQUNiRCxRQUFRRSxJQUFJO0FBRWhCLDJDQUEyQztBQUMzQyx3R0FBd0c7QUFDeEcsTUFBTUMseUJBQXlCVixNQUM3QixBQUNBLENBQUNXLHlFQUR5RTtJQUV4RSxJQUFJO1FBQ0ZSLGVBQWVMLFNBQVNDLE9BQU87SUFDakMsU0FBVTtRQUNSRCxTQUFTQyxPQUFPLEdBQUc7SUFDckI7QUFDRjtBQWNLLFNBQVNGLDRDQUNkZSxVQUFvQztJQUVwQyxPQUFPLFNBQVNDLGdCQUFnQixHQUFHQyxJQUFVO1FBQzNDLE1BQU1DLFVBQVVILGNBQWNFO1FBRTlCLElBQUlWLFFBQVFDLEdBQUcsQ0FBQ1csUUFBUSxLQUFLLFdBQWM7Z0JBQ2pCO1lBQXhCLE1BQU1DLGtCQUFBQSxDQUFrQixTQUFBLElBQUlDLFFBQVFDLEtBQUssS0FBQSxPQUFBLEtBQUEsSUFBakIsT0FBbUJDLEtBQUssQ0FBQztZQUNqRCxJQUFJSCxvQkFBb0JJLGFBQWFKLGdCQUFnQkssTUFBTSxHQUFHLEdBQUc7Z0JBQy9EbkIsZUFBZVk7WUFDakIsT0FBTztnQkFDTCxTQUFTO2dCQUNULG9CQUFvQjtnQkFDcEIsdUNBQXVDO2dCQUN2Qyx3QkFBd0I7Z0JBQ3hCLGlFQUFpRTtnQkFDakUsTUFBTUosTUFBTU0sZUFBZSxDQUFDLEVBQUU7Z0JBQzlCbkIsU0FBU0MsT0FBTyxHQUFHZ0I7Z0JBQ25CTCx1QkFBdUJDO1lBQ3pCO1FBQ0YsT0FBTzs7SUFHVDtBQUNGIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDc1NiwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9zZXJ2ZXIvcmVxdWVzdC91dGlscy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTdGF0aWNHZW5CYWlsb3V0RXJyb3IgfSBmcm9tICcuLi8uLi9jbGllbnQvY29tcG9uZW50cy9zdGF0aWMtZ2VuZXJhdGlvbi1iYWlsb3V0J1xuaW1wb3J0IHsgYWZ0ZXJUYXNrQXN5bmNTdG9yYWdlIH0gZnJvbSAnLi4vYXBwLXJlbmRlci9hZnRlci10YXNrLWFzeW5jLXN0b3JhZ2UuZXh0ZXJuYWwnXG5pbXBvcnQgdHlwZSB7IFdvcmtTdG9yZSB9IGZyb20gJy4uL2FwcC1yZW5kZXIvd29yay1hc3luYy1zdG9yYWdlLmV4dGVybmFsJ1xuXG5leHBvcnQgZnVuY3Rpb24gdGhyb3dXaXRoU3RhdGljR2VuZXJhdGlvbkJhaWxvdXRFcnJvcihcbiAgcm91dGU6IHN0cmluZyxcbiAgZXhwcmVzc2lvbjogc3RyaW5nXG4pOiBuZXZlciB7XG4gIHRocm93IG5ldyBTdGF0aWNHZW5CYWlsb3V0RXJyb3IoXG4gICAgYFJvdXRlICR7cm91dGV9IGNvdWxkbid0IGJlIHJlbmRlcmVkIHN0YXRpY2FsbHkgYmVjYXVzZSBpdCB1c2VkICR7ZXhwcmVzc2lvbn0uIFNlZSBtb3JlIGluZm8gaGVyZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2J1aWxkaW5nLXlvdXItYXBwbGljYXRpb24vcmVuZGVyaW5nL3N0YXRpYy1hbmQtZHluYW1pYyNkeW5hbWljLXJlbmRlcmluZ2BcbiAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdGhyb3dXaXRoU3RhdGljR2VuZXJhdGlvbkJhaWxvdXRFcnJvcldpdGhEeW5hbWljRXJyb3IoXG4gIHJvdXRlOiBzdHJpbmcsXG4gIGV4cHJlc3Npb246IHN0cmluZ1xuKTogbmV2ZXIge1xuICB0aHJvdyBuZXcgU3RhdGljR2VuQmFpbG91dEVycm9yKFxuICAgIGBSb3V0ZSAke3JvdXRlfSB3aXRoIFxcYGR5bmFtaWMgPSBcImVycm9yXCJcXGAgY291bGRuJ3QgYmUgcmVuZGVyZWQgc3RhdGljYWxseSBiZWNhdXNlIGl0IHVzZWQgJHtleHByZXNzaW9ufS4gU2VlIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYnVpbGRpbmcteW91ci1hcHBsaWNhdGlvbi9yZW5kZXJpbmcvc3RhdGljLWFuZC1keW5hbWljI2R5bmFtaWMtcmVuZGVyaW5nYFxuICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0aHJvd0ZvclNlYXJjaFBhcmFtc0FjY2Vzc0luVXNlQ2FjaGUoXG4gIHdvcmtTdG9yZTogV29ya1N0b3JlLFxuICBjb25zdHJ1Y3Rvck9wdDogRnVuY3Rpb25cbik6IG5ldmVyIHtcbiAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgYFJvdXRlICR7d29ya1N0b3JlLnJvdXRlfSB1c2VkIFwic2VhcmNoUGFyYW1zXCIgaW5zaWRlIFwidXNlIGNhY2hlXCIuIEFjY2Vzc2luZyBEeW5hbWljIGRhdGEgc291cmNlcyBpbnNpZGUgYSBjYWNoZSBzY29wZSBpcyBub3Qgc3VwcG9ydGVkLiBJZiB5b3UgbmVlZCB0aGlzIGRhdGEgaW5zaWRlIGEgY2FjaGVkIGZ1bmN0aW9uIHVzZSBcInNlYXJjaFBhcmFtc1wiIG91dHNpZGUgb2YgdGhlIGNhY2hlZCBmdW5jdGlvbiBhbmQgcGFzcyB0aGUgcmVxdWlyZWQgZHluYW1pYyBkYXRhIGluIGFzIGFuIGFyZ3VtZW50LiBTZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL25leHQtcmVxdWVzdC1pbi11c2UtY2FjaGVgXG4gIClcblxuICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlcnJvciwgY29uc3RydWN0b3JPcHQpXG4gIHdvcmtTdG9yZS5pbnZhbGlkRHluYW1pY1VzYWdlRXJyb3IgPz89IGVycm9yXG5cbiAgdGhyb3cgZXJyb3Jcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUmVxdWVzdEFQSUNhbGxhYmxlSW5zaWRlQWZ0ZXIoKSB7XG4gIGNvbnN0IGFmdGVyVGFza1N0b3JlID0gYWZ0ZXJUYXNrQXN5bmNTdG9yYWdlLmdldFN0b3JlKClcbiAgcmV0dXJuIGFmdGVyVGFza1N0b3JlPy5yb290VGFza1NwYXduUGhhc2UgPT09ICdhY3Rpb24nXG59XG4iXSwibmFtZXMiOlsiaXNSZXF1ZXN0QVBJQ2FsbGFibGVJbnNpZGVBZnRlciIsInRocm93Rm9yU2VhcmNoUGFyYW1zQWNjZXNzSW5Vc2VDYWNoZSIsInRocm93V2l0aFN0YXRpY0dlbmVyYXRpb25CYWlsb3V0RXJyb3IiLCJ0aHJvd1dpdGhTdGF0aWNHZW5lcmF0aW9uQmFpbG91dEVycm9yV2l0aER5bmFtaWNFcnJvciIsInJvdXRlIiwiZXhwcmVzc2lvbiIsIlN0YXRpY0dlbkJhaWxvdXRFcnJvciIsIndvcmtTdG9yZSIsImNvbnN0cnVjdG9yT3B0IiwiZXJyb3IiLCJFcnJvciIsImNhcHR1cmVTdGFja1RyYWNlIiwiaW52YWxpZER5bmFtaWNVc2FnZUVycm9yIiwiYWZ0ZXJUYXNrU3RvcmUiLCJhZnRlclRhc2tBc3luY1N0b3JhZ2UiLCJnZXRTdG9yZSIsInJvb3RUYXNrU3Bhd25QaGFzZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztJQW9DZ0JBLCtCQUErQixFQUFBO2VBQS9CQTs7SUFkQUMsb0NBQW9DLEVBQUE7ZUFBcENBOztJQWxCQUMscUNBQXFDLEVBQUE7ZUFBckNBOztJQVNBQyxxREFBcUQsRUFBQTtlQUFyREE7Ozt5Q0Fic0I7K0NBQ0E7QUFHL0IsU0FBU0Qsc0NBQ2RFLEtBQWEsRUFDYkMsVUFBa0I7SUFFbEIsTUFBTSxPQUFBLGNBRUwsQ0FGSyxJQUFJQyx5QkFBQUEscUJBQXFCLENBQzdCLENBQUMsTUFBTSxFQUFFRixNQUFNLGlEQUFpRCxFQUFFQyxXQUFXLDBIQUEwSCxDQUFDLEdBRHBNLHFCQUFBO2VBQUE7b0JBQUE7c0JBQUE7SUFFTjtBQUNGO0FBRU8sU0FBU0Ysc0RBQ2RDLEtBQWEsRUFDYkMsVUFBa0I7SUFFbEIsTUFBTSxPQUFBLGNBRUwsQ0FGSyxJQUFJQyx5QkFBQUEscUJBQXFCLENBQzdCLENBQUMsTUFBTSxFQUFFRixNQUFNLDRFQUE0RSxFQUFFQyxXQUFXLDBIQUEwSCxDQUFDLEdBRC9OLHFCQUFBO2VBQUE7b0JBQUE7c0JBQUE7SUFFTjtBQUNGO0FBRU8sU0FBU0oscUNBQ2RNLFNBQW9CLEVBQ3BCQyxjQUF3QjtJQUV4QixNQUFNQyxRQUFRLE9BQUEsY0FFYixDQUZhLElBQUlDLE1BQ2hCLENBQUMsTUFBTSxFQUFFSCxVQUFVSCxLQUFLLENBQUMsb1ZBQW9WLENBQUMsR0FEbFcscUJBQUE7ZUFBQTtvQkFBQTtzQkFBQTtJQUVkO0lBRUFNLE1BQU1DLGlCQUFpQixDQUFDRixPQUFPRDtJQUMvQkQsVUFBVUssd0JBQXdCLEtBQUtIO0lBRXZDLE1BQU1BO0FBQ1I7QUFFTyxTQUFTVDtJQUNkLE1BQU1hLGlCQUFpQkMsK0JBQUFBLHFCQUFxQixDQUFDQyxRQUFRO0lBQ3JELE9BQU9GLENBQUFBLGtCQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxlQUFnQkcsa0JBQWtCLE1BQUs7QUFDaEQiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogODIxLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL3NoYXJlZC9saWIvaW52YXJpYW50LWVycm9yLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjbGFzcyBJbnZhcmlhbnRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBvcHRpb25zPzogRXJyb3JPcHRpb25zKSB7XG4gICAgc3VwZXIoXG4gICAgICBgSW52YXJpYW50OiAke21lc3NhZ2UuZW5kc1dpdGgoJy4nKSA/IG1lc3NhZ2UgOiBtZXNzYWdlICsgJy4nfSBUaGlzIGlzIGEgYnVnIGluIE5leHQuanMuYCxcbiAgICAgIG9wdGlvbnNcbiAgICApXG4gICAgdGhpcy5uYW1lID0gJ0ludmFyaWFudEVycm9yJ1xuICB9XG59XG4iXSwibmFtZXMiOlsiSW52YXJpYW50RXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwibWVzc2FnZSIsIm9wdGlvbnMiLCJlbmRzV2l0aCIsIm5hbWUiXSwibWFwcGluZ3MiOiI7OzsrQkFBYUEsa0JBQUFBOzs7ZUFBQUE7OztBQUFOLE1BQU1BLHVCQUF1QkM7SUFDbENDLFlBQVlDLE9BQWUsRUFBRUMsT0FBc0IsQ0FBRTtRQUNuRCxLQUFLLENBQ0YsZ0JBQWFELENBQUFBLFFBQVFFLFFBQVEsQ0FBQyxPQUFPRixVQUFVQSxVQUFVLEdBQUUsSUFBRSw4QkFDOURDO1FBRUYsSUFBSSxDQUFDRSxJQUFJLEdBQUc7SUFDZDtBQUNGIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDg0MiwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9zZXJ2ZXIvcmVxdWVzdC9jb29raWVzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIHR5cGUgUmVhZG9ubHlSZXF1ZXN0Q29va2llcyxcbiAgdHlwZSBSZXNwb25zZUNvb2tpZXMsXG4gIGFyZUNvb2tpZXNNdXRhYmxlSW5DdXJyZW50UGhhc2UsXG4gIFJlcXVlc3RDb29raWVzQWRhcHRlcixcbn0gZnJvbSAnLi4vd2ViL3NwZWMtZXh0ZW5zaW9uL2FkYXB0ZXJzL3JlcXVlc3QtY29va2llcydcbmltcG9ydCB7IFJlcXVlc3RDb29raWVzIH0gZnJvbSAnLi4vd2ViL3NwZWMtZXh0ZW5zaW9uL2Nvb2tpZXMnXG5pbXBvcnQgeyB3b3JrQXN5bmNTdG9yYWdlIH0gZnJvbSAnLi4vYXBwLXJlbmRlci93b3JrLWFzeW5jLXN0b3JhZ2UuZXh0ZXJuYWwnXG5pbXBvcnQge1xuICB3b3JrVW5pdEFzeW5jU3RvcmFnZSxcbiAgdHlwZSBQcmVyZW5kZXJTdG9yZU1vZGVybixcbn0gZnJvbSAnLi4vYXBwLXJlbmRlci93b3JrLXVuaXQtYXN5bmMtc3RvcmFnZS5leHRlcm5hbCdcbmltcG9ydCB7XG4gIHBvc3Rwb25lV2l0aFRyYWNraW5nLFxuICB0aHJvd1RvSW50ZXJydXB0U3RhdGljR2VuZXJhdGlvbixcbiAgdHJhY2tEeW5hbWljRGF0YUluRHluYW1pY1JlbmRlcixcbiAgdHJhY2tTeW5jaHJvbm91c1JlcXVlc3REYXRhQWNjZXNzSW5EZXYsXG59IGZyb20gJy4uL2FwcC1yZW5kZXIvZHluYW1pYy1yZW5kZXJpbmcnXG5pbXBvcnQgeyBnZXRFeHBlY3RlZFJlcXVlc3RTdG9yZSB9IGZyb20gJy4uL2FwcC1yZW5kZXIvd29yay11bml0LWFzeW5jLXN0b3JhZ2UuZXh0ZXJuYWwnXG5pbXBvcnQgeyBTdGF0aWNHZW5CYWlsb3V0RXJyb3IgfSBmcm9tICcuLi8uLi9jbGllbnQvY29tcG9uZW50cy9zdGF0aWMtZ2VuZXJhdGlvbi1iYWlsb3V0J1xuaW1wb3J0IHsgbWFrZUhhbmdpbmdQcm9taXNlIH0gZnJvbSAnLi4vZHluYW1pYy1yZW5kZXJpbmctdXRpbHMnXG5pbXBvcnQgeyBjcmVhdGVEZWR1cGVkQnlDYWxsc2l0ZVNlcnZlckVycm9yTG9nZ2VyRGV2IH0gZnJvbSAnLi4vY3JlYXRlLWRlZHVwZWQtYnktY2FsbHNpdGUtc2VydmVyLWVycm9yLWxvZ2dlcidcbmltcG9ydCB7IHNjaGVkdWxlSW1tZWRpYXRlIH0gZnJvbSAnLi4vLi4vbGliL3NjaGVkdWxlcidcbmltcG9ydCB7IGlzUmVxdWVzdEFQSUNhbGxhYmxlSW5zaWRlQWZ0ZXIgfSBmcm9tICcuL3V0aWxzJ1xuaW1wb3J0IHsgSW52YXJpYW50RXJyb3IgfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL2ludmFyaWFudC1lcnJvcidcbmltcG9ydCB7IFJlZmxlY3RBZGFwdGVyIH0gZnJvbSAnLi4vd2ViL3NwZWMtZXh0ZW5zaW9uL2FkYXB0ZXJzL3JlZmxlY3QnXG5cbi8qKlxuICogSW4gdGhpcyB2ZXJzaW9uIG9mIE5leHQuanMgYGNvb2tpZXMoKWAgcmV0dXJucyBhIFByb21pc2UgaG93ZXZlciB5b3UgY2FuIHN0aWxsIHJlZmVyZW5jZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgdW5kZXJseWluZyBjb29raWVzIG9iamVjdFxuICogc3luY2hyb25vdXNseSB0byBmYWNpbGl0YXRlIG1pZ3JhdGlvbi4gVGhlIGBVbnNhZmVVbndyYXBwZWRDb29raWVzYCB0eXBlIGlzIGFkZGVkIHRvIHlvdXIgY29kZSBieSBhIGNvZGVtb2QgdGhhdCBhdHRlbXB0cyB0byBhdXRvbWF0aWNhbGx5XG4gKiB1cGRhdGVzIGNhbGxzaXRlcyB0byByZWZsZWN0IHRoZSBuZXcgUHJvbWlzZSByZXR1cm4gdHlwZS4gVGhlcmUgYXJlIHNvbWUgY2FzZXMgd2hlcmUgYGNvb2tpZXMoKWAgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkLCBuYW1lbHlcbiAqIHdoZW4gaXQgaXMgdXNlZCBpbnNpZGUgYSBzeW5jaHJvbm91cyBmdW5jdGlvbiBhbmQgd2UgY2FuJ3QgYmUgc3VyZSB0aGUgZnVuY3Rpb24gY2FuIGJlIG1hZGUgYXN5bmMgYXV0b21hdGljYWxseS4gSW4gdGhlc2UgY2FzZXMgd2UgYWRkIGFuXG4gKiBleHBsaWNpdCB0eXBlIGNhc2UgdG8gYFVuc2FmZVVud3JhcHBlZENvb2tpZXNgIHRvIGVuYWJsZSB0eXBlc2NyaXB0IHRvIGFsbG93IGZvciB0aGUgc3luY2hyb25vdXMgdXNhZ2Ugb25seSB3aGVyZSBpdCBpcyBhY3R1YWxseSBuZWNlc3NhcnkuXG4gKlxuICogWW91IHNob3VsZCBzaG91bGQgdXBkYXRlIHRoZXNlIGNhbGxzaXRlcyB0byBlaXRoZXIgYmUgYXN5bmMgZnVuY3Rpb25zIHdoZXJlIHRoZSBgY29va2llcygpYCB2YWx1ZSBjYW4gYmUgYXdhaXRlZCBvciB5b3Ugc2hvdWxkIGNhbGwgYGNvb2tpZXMoKWBcbiAqIGZyb20gb3V0c2lkZSBhbmQgYXdhaXQgdGhlIHJldHVybiB2YWx1ZSBiZWZvcmUgcGFzc2luZyBpdCBpbnRvIHRoaXMgZnVuY3Rpb24uXG4gKlxuICogWW91IGNhbiBmaW5kIGluc3RhbmNlcyB0aGF0IHJlcXVpcmUgbWFudWFsIG1pZ3JhdGlvbiBieSBzZWFyY2hpbmcgZm9yIGBVbnNhZmVVbndyYXBwZWRDb29raWVzYCBpbiB5b3VyIGNvZGViYXNlIG9yIGJ5IHNlYXJjaCBmb3IgYSBjb21tZW50IHRoYXRcbiAqIHN0YXJ0cyB3aXRoIGBAbmV4dC1jb2RlbW9kLWVycm9yYC5cbiAqXG4gKiBJbiBhIGZ1dHVyZSB2ZXJzaW9uIG9mIE5leHQuanMgYGNvb2tpZXMoKWAgd2lsbCBvbmx5IHJldHVybiBhIFByb21pc2UgYW5kIHlvdSB3aWxsIG5vdCBiZSBhYmxlIHRvIGFjY2VzcyB0aGUgdW5kZXJseWluZyBjb29raWVzIG9iamVjdCBkaXJlY3RseVxuICogd2l0aG91dCBhd2FpdGluZyB0aGUgcmV0dXJuIHZhbHVlIGZpcnN0LiBXaGVuIHRoaXMgY2hhbmdlIGhhcHBlbnMgdGhlIHR5cGUgYFVuc2FmZVVud3JhcHBlZENvb2tpZXNgIHdpbGwgYmUgdXBkYXRlZCB0byByZWZsZWN0IHRoYXQgaXMgaXQgbm8gbG9uZ2VyXG4gKiB1c2FibGUuXG4gKlxuICogVGhpcyB0eXBlIGlzIG1hcmtlZCBkZXByZWNhdGVkIHRvIGhlbHAgaWRlbnRpZnkgaXQgYXMgdGFyZ2V0IGZvciByZWZhY3RvcmluZyBhd2F5LlxuICpcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmV4cG9ydCB0eXBlIFVuc2FmZVVud3JhcHBlZENvb2tpZXMgPSBSZWFkb25seVJlcXVlc3RDb29raWVzXG5cbmV4cG9ydCBmdW5jdGlvbiBjb29raWVzKCk6IFByb21pc2U8UmVhZG9ubHlSZXF1ZXN0Q29va2llcz4ge1xuICBjb25zdCBjYWxsaW5nRXhwcmVzc2lvbiA9ICdjb29raWVzJ1xuICBjb25zdCB3b3JrU3RvcmUgPSB3b3JrQXN5bmNTdG9yYWdlLmdldFN0b3JlKClcbiAgY29uc3Qgd29ya1VuaXRTdG9yZSA9IHdvcmtVbml0QXN5bmNTdG9yYWdlLmdldFN0b3JlKClcblxuICBpZiAod29ya1N0b3JlKSB7XG4gICAgaWYgKFxuICAgICAgd29ya1VuaXRTdG9yZSAmJlxuICAgICAgd29ya1VuaXRTdG9yZS5waGFzZSA9PT0gJ2FmdGVyJyAmJlxuICAgICAgIWlzUmVxdWVzdEFQSUNhbGxhYmxlSW5zaWRlQWZ0ZXIoKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAvLyBUT0RPKGFmdGVyKTogY2xhcmlmeSB0aGF0IHRoaXMgb25seSBhcHBsaWVzIHRvIHBhZ2VzP1xuICAgICAgICBgUm91dGUgJHt3b3JrU3RvcmUucm91dGV9IHVzZWQgXCJjb29raWVzXCIgaW5zaWRlIFwiYWZ0ZXIoLi4uKVwiLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQuIElmIHlvdSBuZWVkIHRoaXMgZGF0YSBpbnNpZGUgYW4gXCJhZnRlclwiIGNhbGxiYWNrLCB1c2UgXCJjb29raWVzXCIgb3V0c2lkZSBvZiB0aGUgY2FsbGJhY2suIFNlZSBtb3JlIGluZm8gaGVyZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvY2FuYXJ5L2FwcC9hcGktcmVmZXJlbmNlL2Z1bmN0aW9ucy9hZnRlcmBcbiAgICAgIClcbiAgICB9XG5cbiAgICBpZiAod29ya1N0b3JlLmZvcmNlU3RhdGljKSB7XG4gICAgICAvLyBXaGVuIHVzaW5nIGZvcmNlU3RhdGljIHdlIG92ZXJyaWRlIGFsbCBvdGhlciBsb2dpYyBhbmQgYWx3YXlzIGp1c3QgcmV0dXJuIGFuIGVtcHR5XG4gICAgICAvLyBjb29raWVzIG9iamVjdCB3aXRob3V0IHRyYWNraW5nXG4gICAgICBjb25zdCB1bmRlcmx5aW5nQ29va2llcyA9IGNyZWF0ZUVtcHR5Q29va2llcygpXG4gICAgICByZXR1cm4gbWFrZVVudHJhY2tlZEV4b3RpY0Nvb2tpZXModW5kZXJseWluZ0Nvb2tpZXMpXG4gICAgfVxuXG4gICAgaWYgKHdvcmtVbml0U3RvcmUpIHtcbiAgICAgIGlmICh3b3JrVW5pdFN0b3JlLnR5cGUgPT09ICdjYWNoZScpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBSb3V0ZSAke3dvcmtTdG9yZS5yb3V0ZX0gdXNlZCBcImNvb2tpZXNcIiBpbnNpZGUgXCJ1c2UgY2FjaGVcIi4gQWNjZXNzaW5nIER5bmFtaWMgZGF0YSBzb3VyY2VzIGluc2lkZSBhIGNhY2hlIHNjb3BlIGlzIG5vdCBzdXBwb3J0ZWQuIElmIHlvdSBuZWVkIHRoaXMgZGF0YSBpbnNpZGUgYSBjYWNoZWQgZnVuY3Rpb24gdXNlIFwiY29va2llc1wiIG91dHNpZGUgb2YgdGhlIGNhY2hlZCBmdW5jdGlvbiBhbmQgcGFzcyB0aGUgcmVxdWlyZWQgZHluYW1pYyBkYXRhIGluIGFzIGFuIGFyZ3VtZW50LiBTZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL25leHQtcmVxdWVzdC1pbi11c2UtY2FjaGVgXG4gICAgICAgIClcbiAgICAgIH0gZWxzZSBpZiAod29ya1VuaXRTdG9yZS50eXBlID09PSAndW5zdGFibGUtY2FjaGUnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgUm91dGUgJHt3b3JrU3RvcmUucm91dGV9IHVzZWQgXCJjb29raWVzXCIgaW5zaWRlIGEgZnVuY3Rpb24gY2FjaGVkIHdpdGggXCJ1bnN0YWJsZV9jYWNoZSguLi4pXCIuIEFjY2Vzc2luZyBEeW5hbWljIGRhdGEgc291cmNlcyBpbnNpZGUgYSBjYWNoZSBzY29wZSBpcyBub3Qgc3VwcG9ydGVkLiBJZiB5b3UgbmVlZCB0aGlzIGRhdGEgaW5zaWRlIGEgY2FjaGVkIGZ1bmN0aW9uIHVzZSBcImNvb2tpZXNcIiBvdXRzaWRlIG9mIHRoZSBjYWNoZWQgZnVuY3Rpb24gYW5kIHBhc3MgdGhlIHJlcXVpcmVkIGR5bmFtaWMgZGF0YSBpbiBhcyBhbiBhcmd1bWVudC4gU2VlIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYXBpLXJlZmVyZW5jZS9mdW5jdGlvbnMvdW5zdGFibGVfY2FjaGVgXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHdvcmtTdG9yZS5keW5hbWljU2hvdWxkRXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBTdGF0aWNHZW5CYWlsb3V0RXJyb3IoXG4gICAgICAgIGBSb3V0ZSAke3dvcmtTdG9yZS5yb3V0ZX0gd2l0aCBcXGBkeW5hbWljID0gXCJlcnJvclwiXFxgIGNvdWxkbid0IGJlIHJlbmRlcmVkIHN0YXRpY2FsbHkgYmVjYXVzZSBpdCB1c2VkIFxcYGNvb2tpZXNcXGAuIFNlZSBtb3JlIGluZm8gaGVyZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2J1aWxkaW5nLXlvdXItYXBwbGljYXRpb24vcmVuZGVyaW5nL3N0YXRpYy1hbmQtZHluYW1pYyNkeW5hbWljLXJlbmRlcmluZ2BcbiAgICAgIClcbiAgICB9XG5cbiAgICBpZiAod29ya1VuaXRTdG9yZSkge1xuICAgICAgc3dpdGNoICh3b3JrVW5pdFN0b3JlLnR5cGUpIHtcbiAgICAgICAgY2FzZSAncHJlcmVuZGVyJzpcbiAgICAgICAgICByZXR1cm4gbWFrZUhhbmdpbmdDb29raWVzKHdvcmtVbml0U3RvcmUpXG4gICAgICAgIGNhc2UgJ3ByZXJlbmRlci1jbGllbnQnOlxuICAgICAgICAgIGNvbnN0IGV4cG9ydE5hbWUgPSAnYGNvb2tpZXNgJ1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhcmlhbnRFcnJvcihcbiAgICAgICAgICAgIGAke2V4cG9ydE5hbWV9IG11c3Qgbm90IGJlIHVzZWQgd2l0aGluIGEgY2xpZW50IGNvbXBvbmVudC4gTmV4dC5qcyBzaG91bGQgYmUgcHJldmVudGluZyAke2V4cG9ydE5hbWV9IGZyb20gYmVpbmcgaW5jbHVkZWQgaW4gY2xpZW50IGNvbXBvbmVudHMgc3RhdGljYWxseSwgYnV0IGRpZCBub3QgaW4gdGhpcyBjYXNlLmBcbiAgICAgICAgICApXG4gICAgICAgIGNhc2UgJ3ByZXJlbmRlci1wcHInOlxuICAgICAgICAgIC8vIFBQUiBQcmVyZW5kZXIgKG5vIGR5bmFtaWNJTylcbiAgICAgICAgICAvLyBXZSBhcmUgcHJlcmVuZGVyaW5nIHdpdGggUFBSLiBXZSBuZWVkIHRyYWNrIGR5bmFtaWMgYWNjZXNzIGhlcmUgZWFnZXJseVxuICAgICAgICAgIC8vIHRvIGtlZXAgY29udGludWl0eSB3aXRoIGhvdyBjb29raWVzIGhhcyB3b3JrZWQgaW4gUFBSIHdpdGhvdXQgZHluYW1pY0lPLlxuICAgICAgICAgIHBvc3Rwb25lV2l0aFRyYWNraW5nKFxuICAgICAgICAgICAgd29ya1N0b3JlLnJvdXRlLFxuICAgICAgICAgICAgY2FsbGluZ0V4cHJlc3Npb24sXG4gICAgICAgICAgICB3b3JrVW5pdFN0b3JlLmR5bmFtaWNUcmFja2luZ1xuICAgICAgICAgIClcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdwcmVyZW5kZXItbGVnYWN5JzpcbiAgICAgICAgICAvLyBMZWdhY3kgUHJlcmVuZGVyXG4gICAgICAgICAgLy8gV2UgdHJhY2sgZHluYW1pYyBhY2Nlc3MgaGVyZSBzbyB3ZSBkb24ndCBuZWVkIHRvIHdyYXAgdGhlIGNvb2tpZXMgaW5cbiAgICAgICAgICAvLyBpbmRpdmlkdWFsIHByb3BlcnR5IGFjY2VzcyB0cmFja2luZy5cbiAgICAgICAgICB0aHJvd1RvSW50ZXJydXB0U3RhdGljR2VuZXJhdGlvbihcbiAgICAgICAgICAgIGNhbGxpbmdFeHByZXNzaW9uLFxuICAgICAgICAgICAgd29ya1N0b3JlLFxuICAgICAgICAgICAgd29ya1VuaXRTdG9yZVxuICAgICAgICAgIClcbiAgICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBmYWxsdGhyb3VnaFxuICAgICAgfVxuICAgIH1cbiAgICAvLyBXZSBmYWxsIHRocm91Z2ggdG8gdGhlIGR5bmFtaWMgY29udGV4dCBiZWxvdyBidXQgd2Ugc3RpbGwgdHJhY2sgZHluYW1pYyBhY2Nlc3NcbiAgICAvLyBiZWNhdXNlIGluIGRldiB3ZSBjYW4gc3RpbGwgZXJyb3IgZm9yIHRoaW5ncyBsaWtlIHVzaW5nIGNvb2tpZXMgaW5zaWRlIGEgY2FjaGUgY29udGV4dFxuICAgIHRyYWNrRHluYW1pY0RhdGFJbkR5bmFtaWNSZW5kZXIod29ya1N0b3JlLCB3b3JrVW5pdFN0b3JlKVxuICB9XG5cbiAgLy8gY29va2llcyBpcyBiZWluZyBjYWxsZWQgaW4gYSBkeW5hbWljIGNvbnRleHRcblxuICBjb25zdCByZXF1ZXN0U3RvcmUgPSBnZXRFeHBlY3RlZFJlcXVlc3RTdG9yZShjYWxsaW5nRXhwcmVzc2lvbilcblxuICBsZXQgdW5kZXJseWluZ0Nvb2tpZXM6IFJlYWRvbmx5UmVxdWVzdENvb2tpZXNcblxuICBpZiAoYXJlQ29va2llc011dGFibGVJbkN1cnJlbnRQaGFzZShyZXF1ZXN0U3RvcmUpKSB7XG4gICAgLy8gV2UgY2FuJ3QgY29uZGl0aW9uYWxseSByZXR1cm4gZGlmZmVyZW50IHR5cGVzIGhlcmUgYmFzZWQgb24gdGhlIGNvbnRleHQuXG4gICAgLy8gVG8gYXZvaWQgY29uZnVzaW9uLCB3ZSBhbHdheXMgcmV0dXJuIHRoZSByZWFkb25seSB0eXBlIGhlcmUuXG4gICAgdW5kZXJseWluZ0Nvb2tpZXMgPVxuICAgICAgcmVxdWVzdFN0b3JlLnVzZXJzcGFjZU11dGFibGVDb29raWVzIGFzIHVua25vd24gYXMgUmVhZG9ubHlSZXF1ZXN0Q29va2llc1xuICB9IGVsc2Uge1xuICAgIHVuZGVybHlpbmdDb29raWVzID0gcmVxdWVzdFN0b3JlLmNvb2tpZXNcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAhd29ya1N0b3JlPy5pc1ByZWZldGNoUmVxdWVzdCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfRFlOQU1JQ19JTykge1xuICAgICAgcmV0dXJuIG1ha2VVbnRyYWNrZWRDb29raWVzV2l0aERldldhcm5pbmdzKFxuICAgICAgICB1bmRlcmx5aW5nQ29va2llcyxcbiAgICAgICAgd29ya1N0b3JlPy5yb3V0ZVxuICAgICAgKVxuICAgIH1cblxuICAgIHJldHVybiBtYWtlVW50cmFja2VkRXhvdGljQ29va2llc1dpdGhEZXZXYXJuaW5ncyhcbiAgICAgIHVuZGVybHlpbmdDb29raWVzLFxuICAgICAgd29ya1N0b3JlPy5yb3V0ZVxuICAgIClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbWFrZVVudHJhY2tlZEV4b3RpY0Nvb2tpZXModW5kZXJseWluZ0Nvb2tpZXMpXG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRW1wdHlDb29raWVzKCk6IFJlYWRvbmx5UmVxdWVzdENvb2tpZXMge1xuICByZXR1cm4gUmVxdWVzdENvb2tpZXNBZGFwdGVyLnNlYWwobmV3IFJlcXVlc3RDb29raWVzKG5ldyBIZWFkZXJzKHt9KSkpXG59XG5cbmludGVyZmFjZSBDYWNoZUxpZmV0aW1lIHt9XG5jb25zdCBDYWNoZWRDb29raWVzID0gbmV3IFdlYWtNYXA8XG4gIENhY2hlTGlmZXRpbWUsXG4gIFByb21pc2U8UmVhZG9ubHlSZXF1ZXN0Q29va2llcz5cbj4oKVxuXG5mdW5jdGlvbiBtYWtlSGFuZ2luZ0Nvb2tpZXMoXG4gIHByZXJlbmRlclN0b3JlOiBQcmVyZW5kZXJTdG9yZU1vZGVyblxuKTogUHJvbWlzZTxSZWFkb25seVJlcXVlc3RDb29raWVzPiB7XG4gIGNvbnN0IGNhY2hlZFByb21pc2UgPSBDYWNoZWRDb29raWVzLmdldChwcmVyZW5kZXJTdG9yZSlcbiAgaWYgKGNhY2hlZFByb21pc2UpIHtcbiAgICByZXR1cm4gY2FjaGVkUHJvbWlzZVxuICB9XG5cbiAgY29uc3QgcHJvbWlzZSA9IG1ha2VIYW5naW5nUHJvbWlzZTxSZWFkb25seVJlcXVlc3RDb29raWVzPihcbiAgICBwcmVyZW5kZXJTdG9yZS5yZW5kZXJTaWduYWwsXG4gICAgJ2Bjb29raWVzKClgJ1xuICApXG4gIENhY2hlZENvb2tpZXMuc2V0KHByZXJlbmRlclN0b3JlLCBwcm9taXNlKVxuXG4gIHJldHVybiBwcm9taXNlXG59XG5cbmZ1bmN0aW9uIG1ha2VVbnRyYWNrZWRFeG90aWNDb29raWVzKFxuICB1bmRlcmx5aW5nQ29va2llczogUmVhZG9ubHlSZXF1ZXN0Q29va2llc1xuKTogUHJvbWlzZTxSZWFkb25seVJlcXVlc3RDb29raWVzPiB7XG4gIGNvbnN0IGNhY2hlZENvb2tpZXMgPSBDYWNoZWRDb29raWVzLmdldCh1bmRlcmx5aW5nQ29va2llcylcbiAgaWYgKGNhY2hlZENvb2tpZXMpIHtcbiAgICByZXR1cm4gY2FjaGVkQ29va2llc1xuICB9XG5cbiAgY29uc3QgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSh1bmRlcmx5aW5nQ29va2llcylcbiAgQ2FjaGVkQ29va2llcy5zZXQodW5kZXJseWluZ0Nvb2tpZXMsIHByb21pc2UpXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMocHJvbWlzZSwge1xuICAgIFtTeW1ib2wuaXRlcmF0b3JdOiB7XG4gICAgICB2YWx1ZTogdW5kZXJseWluZ0Nvb2tpZXNbU3ltYm9sLml0ZXJhdG9yXVxuICAgICAgICA/IHVuZGVybHlpbmdDb29raWVzW1N5bWJvbC5pdGVyYXRvcl0uYmluZCh1bmRlcmx5aW5nQ29va2llcylcbiAgICAgICAgOiAvLyBUT0RPIHRoaXMgaXMgYSBwb2x5ZmlsbCBmb3Igd2hlbiB0aGUgdW5kZXJseWluZyB0eXBlIGlzIFJlc3BvbnNlQ29va2llc1xuICAgICAgICAgIC8vIFdlIHNob3VsZCByZW1vdmUgdGhpcyBhbmQgdW5pZnkgb3VyIGNvb2tpZXMgdHlwZXMuIFdlIGNvdWxkIGp1c3QgbGV0IHRoaXMgY29udGludWUgdG8gdGhyb3cgbGF6aWx5XG4gICAgICAgICAgLy8gYnV0IHRoYXQncyBhbHJlYWR5IGEgaGFyZCB0aGluZyB0byBkZWJ1ZyBzbyB3ZSBtYXkgYXMgd2VsbCBpbXBsZW1lbnQgaXQgY29uc2lzdGVudGx5LiBUaGUgYmlnZ2VzdCBwcm9ibGVtIHdpdGhcbiAgICAgICAgICAvLyBpbXBsZW1lbnRpbmcgdGhpcyBpbiB0aGlzIHdheSBpcyB0aGUgdW5kZXJseWluZyBjb29raWUgdHlwZSBpcyBhIFJlc3BvbnNlQ29va2llIGFuZCBub3QgYSBSZXF1ZXN0Q29va2llIGFuZCBzbyBpdFxuICAgICAgICAgIC8vIGhhcyBleHRyYSBwcm9wZXJ0aWVzIG5vdCBhdmFpbGFibGUgb24gUmVxdWVzdENvb2tpZSBpbnN0YW5jZXMuXG4gICAgICAgICAgcG9seWZpbGxlZFJlc3BvbnNlQ29va2llc0l0ZXJhdG9yLmJpbmQodW5kZXJseWluZ0Nvb2tpZXMpLFxuICAgIH0sXG4gICAgc2l6ZToge1xuICAgICAgZ2V0KCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB1bmRlcmx5aW5nQ29va2llcy5zaXplXG4gICAgICB9LFxuICAgIH0sXG4gICAgZ2V0OiB7XG4gICAgICB2YWx1ZTogdW5kZXJseWluZ0Nvb2tpZXMuZ2V0LmJpbmQodW5kZXJseWluZ0Nvb2tpZXMpLFxuICAgIH0sXG4gICAgZ2V0QWxsOiB7XG4gICAgICB2YWx1ZTogdW5kZXJseWluZ0Nvb2tpZXMuZ2V0QWxsLmJpbmQodW5kZXJseWluZ0Nvb2tpZXMpLFxuICAgIH0sXG4gICAgaGFzOiB7XG4gICAgICB2YWx1ZTogdW5kZXJseWluZ0Nvb2tpZXMuaGFzLmJpbmQodW5kZXJseWluZ0Nvb2tpZXMpLFxuICAgIH0sXG4gICAgc2V0OiB7XG4gICAgICB2YWx1ZTogdW5kZXJseWluZ0Nvb2tpZXMuc2V0LmJpbmQodW5kZXJseWluZ0Nvb2tpZXMpLFxuICAgIH0sXG4gICAgZGVsZXRlOiB7XG4gICAgICB2YWx1ZTogdW5kZXJseWluZ0Nvb2tpZXMuZGVsZXRlLmJpbmQodW5kZXJseWluZ0Nvb2tpZXMpLFxuICAgIH0sXG4gICAgY2xlYXI6IHtcbiAgICAgIHZhbHVlOlxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGNsZWFyIGlzIGRlZmluZWQgaW4gUmVxdWVzdENvb2tpZXMgaW1wbGVtZW50YXRpb24gYnV0IG5vdCBpbiB0aGUgdHlwZVxuICAgICAgICB0eXBlb2YgdW5kZXJseWluZ0Nvb2tpZXMuY2xlYXIgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICA/IC8vIEB0cy1leHBlY3QtZXJyb3IgY2xlYXIgaXMgZGVmaW5lZCBpbiBSZXF1ZXN0Q29va2llcyBpbXBsZW1lbnRhdGlvbiBidXQgbm90IGluIHRoZSB0eXBlXG4gICAgICAgICAgICB1bmRlcmx5aW5nQ29va2llcy5jbGVhci5iaW5kKHVuZGVybHlpbmdDb29raWVzKVxuICAgICAgICAgIDogLy8gVE9ETyB0aGlzIGlzIGEgcG9seWZpbGwgZm9yIHdoZW4gdGhlIHVuZGVybHlpbmcgdHlwZSBpcyBSZXNwb25zZUNvb2tpZXNcbiAgICAgICAgICAgIC8vIFdlIHNob3VsZCByZW1vdmUgdGhpcyBhbmQgdW5pZnkgb3VyIGNvb2tpZXMgdHlwZXMuIFdlIGNvdWxkIGp1c3QgbGV0IHRoaXMgY29udGludWUgdG8gdGhyb3cgbGF6aWx5XG4gICAgICAgICAgICAvLyBidXQgdGhhdCdzIGFscmVhZHkgYSBoYXJkIHRoaW5nIHRvIGRlYnVnIHNvIHdlIG1heSBhcyB3ZWxsIGltcGxlbWVudCBpdCBjb25zaXN0ZW50bHkuIFRoZSBiaWdnZXN0IHByb2JsZW0gd2l0aFxuICAgICAgICAgICAgLy8gaW1wbGVtZW50aW5nIHRoaXMgaW4gdGhpcyB3YXkgaXMgdGhlIHVuZGVybHlpbmcgY29va2llIHR5cGUgaXMgYSBSZXNwb25zZUNvb2tpZSBhbmQgbm90IGEgUmVxdWVzdENvb2tpZSBhbmQgc28gaXRcbiAgICAgICAgICAgIC8vIGhhcyBleHRyYSBwcm9wZXJ0aWVzIG5vdCBhdmFpbGFibGUgb24gUmVxdWVzdENvb2tpZSBpbnN0YW5jZXMuXG4gICAgICAgICAgICBwb2x5ZmlsbGVkUmVzcG9uc2VDb29raWVzQ2xlYXIuYmluZCh1bmRlcmx5aW5nQ29va2llcywgcHJvbWlzZSksXG4gICAgfSxcbiAgICB0b1N0cmluZzoge1xuICAgICAgdmFsdWU6IHVuZGVybHlpbmdDb29raWVzLnRvU3RyaW5nLmJpbmQodW5kZXJseWluZ0Nvb2tpZXMpLFxuICAgIH0sXG4gIH0gc2F0aXNmaWVzIENvb2tpZUV4dGVuc2lvbnMpXG5cbiAgcmV0dXJuIHByb21pc2Vcbn1cblxuZnVuY3Rpb24gbWFrZVVudHJhY2tlZEV4b3RpY0Nvb2tpZXNXaXRoRGV2V2FybmluZ3MoXG4gIHVuZGVybHlpbmdDb29raWVzOiBSZWFkb25seVJlcXVlc3RDb29raWVzLFxuICByb3V0ZT86IHN0cmluZ1xuKTogUHJvbWlzZTxSZWFkb25seVJlcXVlc3RDb29raWVzPiB7XG4gIGNvbnN0IGNhY2hlZENvb2tpZXMgPSBDYWNoZWRDb29raWVzLmdldCh1bmRlcmx5aW5nQ29va2llcylcbiAgaWYgKGNhY2hlZENvb2tpZXMpIHtcbiAgICByZXR1cm4gY2FjaGVkQ29va2llc1xuICB9XG5cbiAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlPFJlYWRvbmx5UmVxdWVzdENvb2tpZXM+KChyZXNvbHZlKSA9PlxuICAgIHNjaGVkdWxlSW1tZWRpYXRlKCgpID0+IHJlc29sdmUodW5kZXJseWluZ0Nvb2tpZXMpKVxuICApXG4gIENhY2hlZENvb2tpZXMuc2V0KHVuZGVybHlpbmdDb29raWVzLCBwcm9taXNlKVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHByb21pc2UsIHtcbiAgICBbU3ltYm9sLml0ZXJhdG9yXToge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9ICdgLi4uY29va2llcygpYCBvciBzaW1pbGFyIGl0ZXJhdGlvbidcbiAgICAgICAgc3luY0lPRGV2KHJvdXRlLCBleHByZXNzaW9uKVxuICAgICAgICByZXR1cm4gdW5kZXJseWluZ0Nvb2tpZXNbU3ltYm9sLml0ZXJhdG9yXVxuICAgICAgICAgID8gdW5kZXJseWluZ0Nvb2tpZXNbU3ltYm9sLml0ZXJhdG9yXS5hcHBseShcbiAgICAgICAgICAgICAgdW5kZXJseWluZ0Nvb2tpZXMsXG4gICAgICAgICAgICAgIGFyZ3VtZW50cyBhcyBhbnlcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IC8vIFRPRE8gdGhpcyBpcyBhIHBvbHlmaWxsIGZvciB3aGVuIHRoZSB1bmRlcmx5aW5nIHR5cGUgaXMgUmVzcG9uc2VDb29raWVzXG4gICAgICAgICAgICAvLyBXZSBzaG91bGQgcmVtb3ZlIHRoaXMgYW5kIHVuaWZ5IG91ciBjb29raWVzIHR5cGVzLiBXZSBjb3VsZCBqdXN0IGxldCB0aGlzIGNvbnRpbnVlIHRvIHRocm93IGxhemlseVxuICAgICAgICAgICAgLy8gYnV0IHRoYXQncyBhbHJlYWR5IGEgaGFyZCB0aGluZyB0byBkZWJ1ZyBzbyB3ZSBtYXkgYXMgd2VsbCBpbXBsZW1lbnQgaXQgY29uc2lzdGVudGx5LiBUaGUgYmlnZ2VzdCBwcm9ibGVtIHdpdGhcbiAgICAgICAgICAgIC8vIGltcGxlbWVudGluZyB0aGlzIGluIHRoaXMgd2F5IGlzIHRoZSB1bmRlcmx5aW5nIGNvb2tpZSB0eXBlIGlzIGEgUmVzcG9uc2VDb29raWUgYW5kIG5vdCBhIFJlcXVlc3RDb29raWUgYW5kIHNvIGl0XG4gICAgICAgICAgICAvLyBoYXMgZXh0cmEgcHJvcGVydGllcyBub3QgYXZhaWxhYmxlIG9uIFJlcXVlc3RDb29raWUgaW5zdGFuY2VzLlxuICAgICAgICAgICAgcG9seWZpbGxlZFJlc3BvbnNlQ29va2llc0l0ZXJhdG9yLmNhbGwodW5kZXJseWluZ0Nvb2tpZXMpXG4gICAgICB9LFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgIH0sXG4gICAgc2l6ZToge1xuICAgICAgZ2V0KCk6IG51bWJlciB7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSAnYGNvb2tpZXMoKS5zaXplYCdcbiAgICAgICAgc3luY0lPRGV2KHJvdXRlLCBleHByZXNzaW9uKVxuICAgICAgICByZXR1cm4gdW5kZXJseWluZ0Nvb2tpZXMuc2l6ZVxuICAgICAgfSxcbiAgICB9LFxuICAgIGdldDoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgbGV0IGV4cHJlc3Npb246IHN0cmluZ1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGV4cHJlc3Npb24gPSAnYGNvb2tpZXMoKS5nZXQoKWAnXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXhwcmVzc2lvbiA9IGBcXGBjb29raWVzKCkuZ2V0KCR7ZGVzY3JpYmVOYW1lQXJnKGFyZ3VtZW50c1swXSl9KVxcYGBcbiAgICAgICAgfVxuICAgICAgICBzeW5jSU9EZXYocm91dGUsIGV4cHJlc3Npb24pXG4gICAgICAgIHJldHVybiB1bmRlcmx5aW5nQ29va2llcy5nZXQuYXBwbHkodW5kZXJseWluZ0Nvb2tpZXMsIGFyZ3VtZW50cyBhcyBhbnkpXG4gICAgICB9LFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgIH0sXG4gICAgZ2V0QWxsOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QWxsKCkge1xuICAgICAgICBsZXQgZXhwcmVzc2lvbjogc3RyaW5nXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgZXhwcmVzc2lvbiA9ICdgY29va2llcygpLmdldEFsbCgpYCdcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleHByZXNzaW9uID0gYFxcYGNvb2tpZXMoKS5nZXRBbGwoJHtkZXNjcmliZU5hbWVBcmcoYXJndW1lbnRzWzBdKX0pXFxgYFxuICAgICAgICB9XG4gICAgICAgIHN5bmNJT0Rldihyb3V0ZSwgZXhwcmVzc2lvbilcbiAgICAgICAgcmV0dXJuIHVuZGVybHlpbmdDb29raWVzLmdldEFsbC5hcHBseShcbiAgICAgICAgICB1bmRlcmx5aW5nQ29va2llcyxcbiAgICAgICAgICBhcmd1bWVudHMgYXMgYW55XG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgfSxcbiAgICBoYXM6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIGxldCBleHByZXNzaW9uOiBzdHJpbmdcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBleHByZXNzaW9uID0gJ2Bjb29raWVzKCkuaGFzKClgJ1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4cHJlc3Npb24gPSBgXFxgY29va2llcygpLmhhcygke2Rlc2NyaWJlTmFtZUFyZyhhcmd1bWVudHNbMF0pfSlcXGBgXG4gICAgICAgIH1cbiAgICAgICAgc3luY0lPRGV2KHJvdXRlLCBleHByZXNzaW9uKVxuICAgICAgICByZXR1cm4gdW5kZXJseWluZ0Nvb2tpZXMuaGFzLmFwcGx5KHVuZGVybHlpbmdDb29raWVzLCBhcmd1bWVudHMgYXMgYW55KVxuICAgICAgfSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICB9LFxuICAgIHNldDoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldCgpIHtcbiAgICAgICAgbGV0IGV4cHJlc3Npb246IHN0cmluZ1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGV4cHJlc3Npb24gPSAnYGNvb2tpZXMoKS5zZXQoKWAnXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgYXJnID0gYXJndW1lbnRzWzBdXG4gICAgICAgICAgaWYgKGFyZykge1xuICAgICAgICAgICAgZXhwcmVzc2lvbiA9IGBcXGBjb29raWVzKCkuc2V0KCR7ZGVzY3JpYmVOYW1lQXJnKGFyZyl9LCAuLi4pXFxgYFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBleHByZXNzaW9uID0gJ2Bjb29raWVzKCkuc2V0KC4uLilgJ1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzeW5jSU9EZXYocm91dGUsIGV4cHJlc3Npb24pXG4gICAgICAgIHJldHVybiB1bmRlcmx5aW5nQ29va2llcy5zZXQuYXBwbHkodW5kZXJseWluZ0Nvb2tpZXMsIGFyZ3VtZW50cyBhcyBhbnkpXG4gICAgICB9LFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgIH0sXG4gICAgZGVsZXRlOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBsZXQgZXhwcmVzc2lvbjogc3RyaW5nXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgZXhwcmVzc2lvbiA9ICdgY29va2llcygpLmRlbGV0ZSgpYCdcbiAgICAgICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgZXhwcmVzc2lvbiA9IGBcXGBjb29raWVzKCkuZGVsZXRlKCR7ZGVzY3JpYmVOYW1lQXJnKGFyZ3VtZW50c1swXSl9KVxcYGBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleHByZXNzaW9uID0gYFxcYGNvb2tpZXMoKS5kZWxldGUoJHtkZXNjcmliZU5hbWVBcmcoYXJndW1lbnRzWzBdKX0sIC4uLilcXGBgXG4gICAgICAgIH1cbiAgICAgICAgc3luY0lPRGV2KHJvdXRlLCBleHByZXNzaW9uKVxuICAgICAgICByZXR1cm4gdW5kZXJseWluZ0Nvb2tpZXMuZGVsZXRlLmFwcGx5KFxuICAgICAgICAgIHVuZGVybHlpbmdDb29raWVzLFxuICAgICAgICAgIGFyZ3VtZW50cyBhcyBhbnlcbiAgICAgICAgKVxuICAgICAgfSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICB9LFxuICAgIGNsZWFyOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSAnYGNvb2tpZXMoKS5jbGVhcigpYCdcbiAgICAgICAgc3luY0lPRGV2KHJvdXRlLCBleHByZXNzaW9uKVxuICAgICAgICAvLyBAdHMtaWdub3JlIGNsZWFyIGlzIGRlZmluZWQgaW4gUmVxdWVzdENvb2tpZXMgaW1wbGVtZW50YXRpb24gYnV0IG5vdCBpbiB0aGUgdHlwZVxuICAgICAgICByZXR1cm4gdHlwZW9mIHVuZGVybHlpbmdDb29raWVzLmNsZWFyID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgPyAvLyBAdHMtaWdub3JlIGNsZWFyIGlzIGRlZmluZWQgaW4gUmVxdWVzdENvb2tpZXMgaW1wbGVtZW50YXRpb24gYnV0IG5vdCBpbiB0aGUgdHlwZVxuICAgICAgICAgICAgdW5kZXJseWluZ0Nvb2tpZXMuY2xlYXIuYXBwbHkodW5kZXJseWluZ0Nvb2tpZXMsIGFyZ3VtZW50cylcbiAgICAgICAgICA6IC8vIFRPRE8gdGhpcyBpcyBhIHBvbHlmaWxsIGZvciB3aGVuIHRoZSB1bmRlcmx5aW5nIHR5cGUgaXMgUmVzcG9uc2VDb29raWVzXG4gICAgICAgICAgICAvLyBXZSBzaG91bGQgcmVtb3ZlIHRoaXMgYW5kIHVuaWZ5IG91ciBjb29raWVzIHR5cGVzLiBXZSBjb3VsZCBqdXN0IGxldCB0aGlzIGNvbnRpbnVlIHRvIHRocm93IGxhemlseVxuICAgICAgICAgICAgLy8gYnV0IHRoYXQncyBhbHJlYWR5IGEgaGFyZCB0aGluZyB0byBkZWJ1ZyBzbyB3ZSBtYXkgYXMgd2VsbCBpbXBsZW1lbnQgaXQgY29uc2lzdGVudGx5LiBUaGUgYmlnZ2VzdCBwcm9ibGVtIHdpdGhcbiAgICAgICAgICAgIC8vIGltcGxlbWVudGluZyB0aGlzIGluIHRoaXMgd2F5IGlzIHRoZSB1bmRlcmx5aW5nIGNvb2tpZSB0eXBlIGlzIGEgUmVzcG9uc2VDb29raWUgYW5kIG5vdCBhIFJlcXVlc3RDb29raWUgYW5kIHNvIGl0XG4gICAgICAgICAgICAvLyBoYXMgZXh0cmEgcHJvcGVydGllcyBub3QgYXZhaWxhYmxlIG9uIFJlcXVlc3RDb29raWUgaW5zdGFuY2VzLlxuICAgICAgICAgICAgcG9seWZpbGxlZFJlc3BvbnNlQ29va2llc0NsZWFyLmNhbGwodW5kZXJseWluZ0Nvb2tpZXMsIHByb21pc2UpXG4gICAgICB9LFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgIH0sXG4gICAgdG9TdHJpbmc6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9ICdgY29va2llcygpLnRvU3RyaW5nKClgIG9yIGltcGxpY2l0IGNhc3RpbmcnXG4gICAgICAgIHN5bmNJT0Rldihyb3V0ZSwgZXhwcmVzc2lvbilcbiAgICAgICAgcmV0dXJuIHVuZGVybHlpbmdDb29raWVzLnRvU3RyaW5nLmFwcGx5KFxuICAgICAgICAgIHVuZGVybHlpbmdDb29raWVzLFxuICAgICAgICAgIGFyZ3VtZW50cyBhcyBhbnlcbiAgICAgICAgKVxuICAgICAgfSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICB9LFxuICB9IHNhdGlzZmllcyBDb29raWVFeHRlbnNpb25zKVxuXG4gIHJldHVybiBwcm9taXNlXG59XG5cbi8vIFNpbWlsYXIgdG8gYG1ha2VVbnRyYWNrZWRFeG90aWNDb29raWVzV2l0aERldldhcm5pbmdzYCwgYnV0IGp1c3QgbG9nZ2luZyB0aGVcbi8vIHN5bmMgYWNjZXNzIHdpdGhvdXQgYWN0dWFsbHkgZGVmaW5pbmcgdGhlIGNvb2tpZXMgcHJvcGVydGllcyBvbiB0aGUgcHJvbWlzZS5cbmZ1bmN0aW9uIG1ha2VVbnRyYWNrZWRDb29raWVzV2l0aERldldhcm5pbmdzKFxuICB1bmRlcmx5aW5nQ29va2llczogUmVhZG9ubHlSZXF1ZXN0Q29va2llcyxcbiAgcm91dGU/OiBzdHJpbmdcbik6IFByb21pc2U8UmVhZG9ubHlSZXF1ZXN0Q29va2llcz4ge1xuICBjb25zdCBjYWNoZWRDb29raWVzID0gQ2FjaGVkQ29va2llcy5nZXQodW5kZXJseWluZ0Nvb2tpZXMpXG4gIGlmIChjYWNoZWRDb29raWVzKSB7XG4gICAgcmV0dXJuIGNhY2hlZENvb2tpZXNcbiAgfVxuXG4gIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZTxSZWFkb25seVJlcXVlc3RDb29raWVzPigocmVzb2x2ZSkgPT5cbiAgICBzY2hlZHVsZUltbWVkaWF0ZSgoKSA9PiByZXNvbHZlKHVuZGVybHlpbmdDb29raWVzKSlcbiAgKVxuXG4gIGNvbnN0IHByb3hpZWRQcm9taXNlID0gbmV3IFByb3h5KHByb21pc2UsIHtcbiAgICBnZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgc3dpdGNoIChwcm9wKSB7XG4gICAgICAgIGNhc2UgU3ltYm9sLml0ZXJhdG9yOiB7XG4gICAgICAgICAgd2FybkZvclN5bmNBY2Nlc3Mocm91dGUsICdgLi4uY29va2llcygpYCBvciBzaW1pbGFyIGl0ZXJhdGlvbicpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdzaXplJzpcbiAgICAgICAgY2FzZSAnZ2V0JzpcbiAgICAgICAgY2FzZSAnZ2V0QWxsJzpcbiAgICAgICAgY2FzZSAnaGFzJzpcbiAgICAgICAgY2FzZSAnc2V0JzpcbiAgICAgICAgY2FzZSAnZGVsZXRlJzpcbiAgICAgICAgY2FzZSAnY2xlYXInOlxuICAgICAgICBjYXNlICd0b1N0cmluZyc6IHtcbiAgICAgICAgICB3YXJuRm9yU3luY0FjY2Vzcyhyb3V0ZSwgYFxcYGNvb2tpZXMoKS4ke3Byb3B9XFxgYClcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAvLyBXZSBvbmx5IHdhcm4gZm9yIHdlbGwtZGVmaW5lZCBwcm9wZXJ0aWVzIG9mIHRoZSBjb29raWVzIG9iamVjdC5cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gUmVmbGVjdEFkYXB0ZXIuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpXG4gICAgfSxcbiAgfSlcblxuICBDYWNoZWRDb29raWVzLnNldCh1bmRlcmx5aW5nQ29va2llcywgcHJveGllZFByb21pc2UpXG5cbiAgcmV0dXJuIHByb3hpZWRQcm9taXNlXG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmFtZUFyZyhhcmc6IHVua25vd24pIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmXG4gICAgYXJnICE9PSBudWxsICYmXG4gICAgdHlwZW9mIChhcmcgYXMgYW55KS5uYW1lID09PSAnc3RyaW5nJ1xuICAgID8gYCckeyhhcmcgYXMgYW55KS5uYW1lfSdgXG4gICAgOiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJ1xuICAgICAgPyBgJyR7YXJnfSdgXG4gICAgICA6ICcuLi4nXG59XG5cbmZ1bmN0aW9uIHN5bmNJT0Rldihyb3V0ZTogc3RyaW5nIHwgdW5kZWZpbmVkLCBleHByZXNzaW9uOiBzdHJpbmcpIHtcbiAgY29uc3Qgd29ya1VuaXRTdG9yZSA9IHdvcmtVbml0QXN5bmNTdG9yYWdlLmdldFN0b3JlKClcbiAgaWYgKFxuICAgIHdvcmtVbml0U3RvcmUgJiZcbiAgICB3b3JrVW5pdFN0b3JlLnR5cGUgPT09ICdyZXF1ZXN0JyAmJlxuICAgIHdvcmtVbml0U3RvcmUucHJlcmVuZGVyUGhhc2UgPT09IHRydWVcbiAgKSB7XG4gICAgLy8gV2hlbiB3ZSdyZSByZW5kZXJpbmcgZHluYW1pY2FsbHkgaW4gZGV2IHdlIG5lZWQgdG8gYWR2YW5jZSBvdXQgb2YgdGhlXG4gICAgLy8gUHJlcmVuZGVyIGVudmlyb25tZW50IHdoZW4gd2UgcmVhZCBSZXF1ZXN0IGRhdGEgc3luY2hyb25vdXNseVxuICAgIGNvbnN0IHJlcXVlc3RTdG9yZSA9IHdvcmtVbml0U3RvcmVcbiAgICB0cmFja1N5bmNocm9ub3VzUmVxdWVzdERhdGFBY2Nlc3NJbkRldihyZXF1ZXN0U3RvcmUpXG4gIH1cbiAgLy8gSW4gYWxsIGNhc2VzIHdlIHdhcm4gbm9ybWFsbHlcbiAgd2FybkZvclN5bmNBY2Nlc3Mocm91dGUsIGV4cHJlc3Npb24pXG59XG5cbmNvbnN0IHdhcm5Gb3JTeW5jQWNjZXNzID0gY3JlYXRlRGVkdXBlZEJ5Q2FsbHNpdGVTZXJ2ZXJFcnJvckxvZ2dlckRldihcbiAgY3JlYXRlQ29va2llc0FjY2Vzc0Vycm9yXG4pXG5cbmZ1bmN0aW9uIGNyZWF0ZUNvb2tpZXNBY2Nlc3NFcnJvcihcbiAgcm91dGU6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgZXhwcmVzc2lvbjogc3RyaW5nXG4pIHtcbiAgY29uc3QgcHJlZml4ID0gcm91dGUgPyBgUm91dGUgXCIke3JvdXRlfVwiIGAgOiAnVGhpcyByb3V0ZSAnXG4gIHJldHVybiBuZXcgRXJyb3IoXG4gICAgYCR7cHJlZml4fXVzZWQgJHtleHByZXNzaW9ufS4gYCArXG4gICAgICBgXFxgY29va2llcygpXFxgIHNob3VsZCBiZSBhd2FpdGVkIGJlZm9yZSB1c2luZyBpdHMgdmFsdWUuIGAgK1xuICAgICAgYExlYXJuIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL3N5bmMtZHluYW1pYy1hcGlzYFxuICApXG59XG5cbmZ1bmN0aW9uIHBvbHlmaWxsZWRSZXNwb25zZUNvb2tpZXNJdGVyYXRvcihcbiAgdGhpczogUmVzcG9uc2VDb29raWVzXG4pOiBSZXR1cm5UeXBlPFJlYWRvbmx5UmVxdWVzdENvb2tpZXNbdHlwZW9mIFN5bWJvbC5pdGVyYXRvcl0+IHtcbiAgcmV0dXJuIHRoaXMuZ2V0QWxsKClcbiAgICAubWFwKChjKSA9PiBbYy5uYW1lLCBjXSBhcyBbc3RyaW5nLCBhbnldKVxuICAgIC52YWx1ZXMoKVxufVxuXG5mdW5jdGlvbiBwb2x5ZmlsbGVkUmVzcG9uc2VDb29raWVzQ2xlYXIoXG4gIHRoaXM6IFJlc3BvbnNlQ29va2llcyxcbiAgcmV0dXJuYWJsZTogUHJvbWlzZTxSZWFkb25seVJlcXVlc3RDb29raWVzPlxuKTogdHlwZW9mIHJldHVybmFibGUge1xuICBmb3IgKGNvbnN0IGNvb2tpZSBvZiB0aGlzLmdldEFsbCgpKSB7XG4gICAgdGhpcy5kZWxldGUoY29va2llLm5hbWUpXG4gIH1cbiAgcmV0dXJuIHJldHVybmFibGVcbn1cblxudHlwZSBDb29raWVFeHRlbnNpb25zID0ge1xuICBbSyBpbiBrZXlvZiBSZWFkb25seVJlcXVlc3RDb29raWVzIHwgJ2NsZWFyJ106IHVua25vd25cbn1cbiJdLCJuYW1lcyI6WyJjb29raWVzIiwiY2FsbGluZ0V4cHJlc3Npb24iLCJ3b3JrU3RvcmUiLCJ3b3JrQXN5bmNTdG9yYWdlIiwiZ2V0U3RvcmUiLCJ3b3JrVW5pdFN0b3JlIiwid29ya1VuaXRBc3luY1N0b3JhZ2UiLCJwaGFzZSIsImlzUmVxdWVzdEFQSUNhbGxhYmxlSW5zaWRlQWZ0ZXIiLCJFcnJvciIsInJvdXRlIiwiZm9yY2VTdGF0aWMiLCJ1bmRlcmx5aW5nQ29va2llcyIsImNyZWF0ZUVtcHR5Q29va2llcyIsIm1ha2VVbnRyYWNrZWRFeG90aWNDb29raWVzIiwidHlwZSIsImR5bmFtaWNTaG91bGRFcnJvciIsIlN0YXRpY0dlbkJhaWxvdXRFcnJvciIsIm1ha2VIYW5naW5nQ29va2llcyIsImV4cG9ydE5hbWUiLCJJbnZhcmlhbnRFcnJvciIsInBvc3Rwb25lV2l0aFRyYWNraW5nIiwiZHluYW1pY1RyYWNraW5nIiwidGhyb3dUb0ludGVycnVwdFN0YXRpY0dlbmVyYXRpb24iLCJ0cmFja0R5bmFtaWNEYXRhSW5EeW5hbWljUmVuZGVyIiwicmVxdWVzdFN0b3JlIiwiZ2V0RXhwZWN0ZWRSZXF1ZXN0U3RvcmUiLCJhcmVDb29raWVzTXV0YWJsZUluQ3VycmVudFBoYXNlIiwidXNlcnNwYWNlTXV0YWJsZUNvb2tpZXMiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJpc1ByZWZldGNoUmVxdWVzdCIsIl9fTkVYVF9EWU5BTUlDX0lPIiwibWFrZVVudHJhY2tlZENvb2tpZXNXaXRoRGV2V2FybmluZ3MiLCJtYWtlVW50cmFja2VkRXhvdGljQ29va2llc1dpdGhEZXZXYXJuaW5ncyIsIlJlcXVlc3RDb29raWVzQWRhcHRlciIsInNlYWwiLCJSZXF1ZXN0Q29va2llcyIsIkhlYWRlcnMiLCJDYWNoZWRDb29raWVzIiwiV2Vha01hcCIsInByZXJlbmRlclN0b3JlIiwiY2FjaGVkUHJvbWlzZSIsImdldCIsInByb21pc2UiLCJtYWtlSGFuZ2luZ1Byb21pc2UiLCJyZW5kZXJTaWduYWwiLCJzZXQiLCJjYWNoZWRDb29raWVzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJ2YWx1ZSIsImJpbmQiLCJwb2x5ZmlsbGVkUmVzcG9uc2VDb29raWVzSXRlcmF0b3IiLCJzaXplIiwiZ2V0QWxsIiwiaGFzIiwiZGVsZXRlIiwiY2xlYXIiLCJwb2x5ZmlsbGVkUmVzcG9uc2VDb29raWVzQ2xlYXIiLCJ0b1N0cmluZyIsInNjaGVkdWxlSW1tZWRpYXRlIiwiZXhwcmVzc2lvbiIsInN5bmNJT0RldiIsImFwcGx5IiwiYXJndW1lbnRzIiwiY2FsbCIsIndyaXRhYmxlIiwibGVuZ3RoIiwiZGVzY3JpYmVOYW1lQXJnIiwiYXJnIiwicHJveGllZFByb21pc2UiLCJQcm94eSIsInRhcmdldCIsInByb3AiLCJyZWNlaXZlciIsIndhcm5Gb3JTeW5jQWNjZXNzIiwiUmVmbGVjdEFkYXB0ZXIiLCJuYW1lIiwicHJlcmVuZGVyUGhhc2UiLCJ0cmFja1N5bmNocm9ub3VzUmVxdWVzdERhdGFBY2Nlc3NJbkRldiIsImNyZWF0ZURlZHVwZWRCeUNhbGxzaXRlU2VydmVyRXJyb3JMb2dnZXJEZXYiLCJjcmVhdGVDb29raWVzQWNjZXNzRXJyb3IiLCJwcmVmaXgiLCJtYXAiLCJjIiwidmFsdWVzIiwicmV0dXJuYWJsZSIsImNvb2tpZSJdLCJtYXBwaW5ncyI6Ijs7OytCQWtEZ0JBLFdBQUFBOzs7ZUFBQUE7OztnQ0E3Q1Q7eUJBQ3dCOzBDQUNFOzhDQUkxQjtrQ0FNQTt5Q0FFK0I7dUNBQ0g7MERBQ3lCOzJCQUMxQjt1QkFDYztnQ0FDakI7eUJBQ0E7QUF5QnhCLFNB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MkMsRUFDbkVDO0FBR0YsU0FBU0EseUJBQ1A3RSxLQUF5QixFQUN6QnlELFVBQWtCO0lBRWxCLE1BQU1xQixTQUFTOUUsUUFBUSxDQUFDLE9BQU8sRUFBRUEsTUFBTSxFQUFFLENBQUMsR0FBRztJQUM3QyxPQUFPLE9BQUEsY0FJTixDQUpNLElBQUlELE1BQ1QsR0FBRytFLE9BQU8sS0FBSyxFQUFFckIsV0FBVyxFQUFFLENBQUMsR0FDN0IsQ0FBQyx3REFBd0QsQ0FBQyxHQUMxRCxDQUFDLDhEQUE4RCxDQUFDLEdBSDdELHFCQUFBO2VBQUE7b0JBQUE7c0JBQUE7SUFJUDtBQUNGO0FBRUEsU0FBU1Q7SUFHUCxPQUFPLElBQUksQ0FBQ0UsTUFBTSxHQUNmNkIsR0FBRyxDQUFDLENBQUNDLElBQU07WUFBQ0EsRUFBRVAsSUFBSTtZQUFFTztTQUFFLEVBQ3RCQyxNQUFNO0FBQ1g7QUFFQSxTQUFTM0IsK0JBRVA0QixVQUEyQztJQUUzQyxLQUFLLE1BQU1DLFVBQVUsSUFBSSxDQUFDakMsTUFBTSxHQUFJO1FBQ2xDLElBQUksQ0FBQ0UsTUFBTSxDQUFDK0IsT0FBT1YsSUFBSTtJQUN6QjtJQUNBLE9BQU9TO0FBQ1QiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTIxMSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9zZXJ2ZXIvd2ViL3NwZWMtZXh0ZW5zaW9uL2FkYXB0ZXJzL2hlYWRlcnMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBJbmNvbWluZ0h0dHBIZWFkZXJzIH0gZnJvbSAnaHR0cCdcblxuaW1wb3J0IHsgUmVmbGVjdEFkYXB0ZXIgfSBmcm9tICcuL3JlZmxlY3QnXG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjbGFzcyBSZWFkb25seUhlYWRlcnNFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXG4gICAgICAnSGVhZGVycyBjYW5ub3QgYmUgbW9kaWZpZWQuIFJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2FwaS1yZWZlcmVuY2UvZnVuY3Rpb25zL2hlYWRlcnMnXG4gICAgKVxuICB9XG5cbiAgcHVibGljIHN0YXRpYyBjYWxsYWJsZSgpIHtcbiAgICB0aHJvdyBuZXcgUmVhZG9ubHlIZWFkZXJzRXJyb3IoKVxuICB9XG59XG5cbmV4cG9ydCB0eXBlIFJlYWRvbmx5SGVhZGVycyA9IEhlYWRlcnMgJiB7XG4gIC8qKiBAZGVwcmVjYXRlZCBNZXRob2QgdW5hdmFpbGFibGUgb24gYFJlYWRvbmx5SGVhZGVyc2AuIFJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2FwaS1yZWZlcmVuY2UvZnVuY3Rpb25zL2hlYWRlcnMgKi9cbiAgYXBwZW5kKC4uLmFyZ3M6IGFueVtdKTogdm9pZFxuICAvKiogQGRlcHJlY2F0ZWQgTWV0aG9kIHVuYXZhaWxhYmxlIG9uIGBSZWFkb25seUhlYWRlcnNgLiBSZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9hcGktcmVmZXJlbmNlL2Z1bmN0aW9ucy9oZWFkZXJzICovXG4gIHNldCguLi5hcmdzOiBhbnlbXSk6IHZvaWRcbiAgLyoqIEBkZXByZWNhdGVkIE1ldGhvZCB1bmF2YWlsYWJsZSBvbiBgUmVhZG9ubHlIZWFkZXJzYC4gUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYXBpLXJlZmVyZW5jZS9mdW5jdGlvbnMvaGVhZGVycyAqL1xuICBkZWxldGUoLi4uYXJnczogYW55W10pOiB2b2lkXG59XG5leHBvcnQgY2xhc3MgSGVhZGVyc0FkYXB0ZXIgZXh0ZW5kcyBIZWFkZXJzIHtcbiAgcHJpdmF0ZSByZWFkb25seSBoZWFkZXJzOiBJbmNvbWluZ0h0dHBIZWFkZXJzXG5cbiAgY29uc3RydWN0b3IoaGVhZGVyczogSW5jb21pbmdIdHRwSGVhZGVycykge1xuICAgIC8vIFdlJ3ZlIGFscmVhZHkgb3ZlcnJpZGRlbiB0aGUgbWV0aG9kcyB0aGF0IHdvdWxkIGJlIGNhbGxlZCwgc28gd2UncmUganVzdFxuICAgIC8vIGNhbGxpbmcgdGhlIHN1cGVyIGNvbnN0cnVjdG9yIHRvIGVuc3VyZSB0aGF0IHRoZSBpbnN0YW5jZW9mIGNoZWNrIHdvcmtzLlxuICAgIHN1cGVyKClcblxuICAgIHRoaXMuaGVhZGVycyA9IG5ldyBQcm94eShoZWFkZXJzLCB7XG4gICAgICBnZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgICAvLyBCZWNhdXNlIHRoaXMgaXMganVzdCBhbiBvYmplY3QsIHdlIGV4cGVjdCB0aGF0IGFsbCBcImdldFwiIG9wZXJhdGlvbnNcbiAgICAgICAgLy8gYXJlIGZvciBwcm9wZXJ0aWVzLiBJZiBpdCdzIGEgXCJnZXRcIiBmb3IgYSBzeW1ib2wsIHdlJ2xsIGp1c3QgcmV0dXJuXG4gICAgICAgIC8vIHRoZSBzeW1ib2wuXG4gICAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgICByZXR1cm4gUmVmbGVjdEFkYXB0ZXIuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBsb3dlcmNhc2VkID0gcHJvcC50b0xvd2VyQ2FzZSgpXG5cbiAgICAgICAgLy8gTGV0J3MgZmluZCB0aGUgb3JpZ2luYWwgY2FzaW5nIG9mIHRoZSBrZXkuIFRoaXMgYXNzdW1lcyB0aGF0IHRoZXJlIGlzXG4gICAgICAgIC8vIG5vIG1peGVkIGNhc2Uga2V5cyAoZS5nLiBcIkNvbnRlbnQtVHlwZVwiIGFuZCBcImNvbnRlbnQtdHlwZVwiKSBpbiB0aGVcbiAgICAgICAgLy8gaGVhZGVycyBvYmplY3QuXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsID0gT2JqZWN0LmtleXMoaGVhZGVycykuZmluZChcbiAgICAgICAgICAobykgPT4gby50b0xvd2VyQ2FzZSgpID09PSBsb3dlcmNhc2VkXG4gICAgICAgIClcblxuICAgICAgICAvLyBJZiB0aGUgb3JpZ2luYWwgY2FzaW5nIGRvZXNuJ3QgZXhpc3QsIHJldHVybiB1bmRlZmluZWQuXG4gICAgICAgIGlmICh0eXBlb2Ygb3JpZ2luYWwgPT09ICd1bmRlZmluZWQnKSByZXR1cm5cblxuICAgICAgICAvLyBJZiB0aGUgb3JpZ2luYWwgY2FzaW5nIGV4aXN0cywgcmV0dXJuIHRoZSB2YWx1ZS5cbiAgICAgICAgcmV0dXJuIFJlZmxlY3RBZGFwdGVyLmdldCh0YXJnZXQsIG9yaWdpbmFsLCByZWNlaXZlcilcbiAgICAgIH0sXG4gICAgICBzZXQodGFyZ2V0LCBwcm9wLCB2YWx1ZSwgcmVjZWl2ZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9wID09PSAnc3ltYm9sJykge1xuICAgICAgICAgIHJldHVybiBSZWZsZWN0QWRhcHRlci5zZXQodGFyZ2V0LCBwcm9wLCB2YWx1ZSwgcmVjZWl2ZXIpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBsb3dlcmNhc2VkID0gcHJvcC50b0xvd2VyQ2FzZSgpXG5cbiAgICAgICAgLy8gTGV0J3MgZmluZCB0aGUgb3JpZ2luYWwgY2FzaW5nIG9mIHRoZSBrZXkuIFRoaXMgYXNzdW1lcyB0aGF0IHRoZXJlIGlzXG4gICAgICAgIC8vIG5vIG1peGVkIGNhc2Uga2V5cyAoZS5nLiBcIkNvbnRlbnQtVHlwZVwiIGFuZCBcImNvbnRlbnQtdHlwZVwiKSBpbiB0aGVcbiAgICAgICAgLy8gaGVhZGVycyBvYmplY3QuXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsID0gT2JqZWN0LmtleXMoaGVhZGVycykuZmluZChcbiAgICAgICAgICAobykgPT4gby50b0xvd2VyQ2FzZSgpID09PSBsb3dlcmNhc2VkXG4gICAgICAgIClcblxuICAgICAgICAvLyBJZiB0aGUgb3JpZ2luYWwgY2FzaW5nIGRvZXNuJ3QgZXhpc3QsIHVzZSB0aGUgcHJvcCBhcyB0aGUga2V5LlxuICAgICAgICByZXR1cm4gUmVmbGVjdEFkYXB0ZXIuc2V0KHRhcmdldCwgb3JpZ2luYWwgPz8gcHJvcCwgdmFsdWUsIHJlY2VpdmVyKVxuICAgICAgfSxcbiAgICAgIGhhcyh0YXJnZXQsIHByb3ApIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9wID09PSAnc3ltYm9sJykgcmV0dXJuIFJlZmxlY3RBZGFwdGVyLmhhcyh0YXJnZXQsIHByb3ApXG5cbiAgICAgICAgY29uc3QgbG93ZXJjYXNlZCA9IHByb3AudG9Mb3dlckNhc2UoKVxuXG4gICAgICAgIC8vIExldCdzIGZpbmQgdGhlIG9yaWdpbmFsIGNhc2luZyBvZiB0aGUga2V5LiBUaGlzIGFzc3VtZXMgdGhhdCB0aGVyZSBpc1xuICAgICAgICAvLyBubyBtaXhlZCBjYXNlIGtleXMgKGUuZy4gXCJDb250ZW50LVR5cGVcIiBhbmQgXCJjb250ZW50LXR5cGVcIikgaW4gdGhlXG4gICAgICAgIC8vIGhlYWRlcnMgb2JqZWN0LlxuICAgICAgICBjb25zdCBvcmlnaW5hbCA9IE9iamVjdC5rZXlzKGhlYWRlcnMpLmZpbmQoXG4gICAgICAgICAgKG8pID0+IG8udG9Mb3dlckNhc2UoKSA9PT0gbG93ZXJjYXNlZFxuICAgICAgICApXG5cbiAgICAgICAgLy8gSWYgdGhlIG9yaWdpbmFsIGNhc2luZyBkb2Vzbid0IGV4aXN0LCByZXR1cm4gZmFsc2UuXG4gICAgICAgIGlmICh0eXBlb2Ygb3JpZ2luYWwgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gZmFsc2VcblxuICAgICAgICAvLyBJZiB0aGUgb3JpZ2luYWwgY2FzaW5nIGV4aXN0cywgcmV0dXJuIHRydWUuXG4gICAgICAgIHJldHVybiBSZWZsZWN0QWRhcHRlci5oYXModGFyZ2V0LCBvcmlnaW5hbClcbiAgICAgIH0sXG4gICAgICBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3ApIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9wID09PSAnc3ltYm9sJylcbiAgICAgICAgICByZXR1cm4gUmVmbGVjdEFkYXB0ZXIuZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wKVxuXG4gICAgICAgIGNvbnN0IGxvd2VyY2FzZWQgPSBwcm9wLnRvTG93ZXJDYXNlKClcblxuICAgICAgICAvLyBMZXQncyBmaW5kIHRoZSBvcmlnaW5hbCBjYXNpbmcgb2YgdGhlIGtleS4gVGhpcyBhc3N1bWVzIHRoYXQgdGhlcmUgaXNcbiAgICAgICAgLy8gbm8gbWl4ZWQgY2FzZSBrZXlzIChlLmcuIFwiQ29udGVudC1UeXBlXCIgYW5kIFwiY29udGVudC10eXBlXCIpIGluIHRoZVxuICAgICAgICAvLyBoZWFkZXJzIG9iamVjdC5cbiAgICAgICAgY29uc3Qgb3JpZ2luYWwgPSBPYmplY3Qua2V5cyhoZWFkZXJzKS5maW5kKFxuICAgICAgICAgIChvKSA9PiBvLnRvTG93ZXJDYXNlKCkgPT09IGxvd2VyY2FzZWRcbiAgICAgICAgKVxuXG4gICAgICAgIC8vIElmIHRoZSBvcmlnaW5hbCBjYXNpbmcgZG9lc24ndCBleGlzdCwgcmV0dXJuIHRydWUuXG4gICAgICAgIGlmICh0eXBlb2Ygb3JpZ2luYWwgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gdHJ1ZVxuXG4gICAgICAgIC8vIElmIHRoZSBvcmlnaW5hbCBjYXNpbmcgZXhpc3RzLCBkZWxldGUgdGhlIHByb3BlcnR5LlxuICAgICAgICByZXR1cm4gUmVmbGVjdEFkYXB0ZXIuZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBvcmlnaW5hbClcbiAgICAgIH0sXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWFscyBhIEhlYWRlcnMgaW5zdGFuY2UgdG8gcHJldmVudCBtb2RpZmljYXRpb24gYnkgdGhyb3dpbmcgYW4gZXJyb3Igd2hlblxuICAgKiBhbnkgbXV0YXRpbmcgbWV0aG9kIGlzIGNhbGxlZC5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgc2VhbChoZWFkZXJzOiBIZWFkZXJzKTogUmVhZG9ubHlIZWFkZXJzIHtcbiAgICByZXR1cm4gbmV3IFByb3h5PFJlYWRvbmx5SGVhZGVycz4oaGVhZGVycywge1xuICAgICAgZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICAgICAgc3dpdGNoIChwcm9wKSB7XG4gICAgICAgICAgY2FzZSAnYXBwZW5kJzpcbiAgICAgICAgICBjYXNlICdkZWxldGUnOlxuICAgICAgICAgIGNhc2UgJ3NldCc6XG4gICAgICAgICAgICByZXR1cm4gUmVhZG9ubHlIZWFkZXJzRXJyb3IuY2FsbGFibGVcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3RBZGFwdGVyLmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogTWVyZ2VzIGEgaGVhZGVyIHZhbHVlIGludG8gYSBzdHJpbmcuIFRoaXMgc3RvcmVzIG11bHRpcGxlIHZhbHVlcyBhcyBhblxuICAgKiBhcnJheSwgc28gd2UgbmVlZCB0byBtZXJnZSB0aGVtIGludG8gYSBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB2YWx1ZSBhIGhlYWRlciB2YWx1ZVxuICAgKiBAcmV0dXJucyBhIG1lcmdlZCBoZWFkZXIgdmFsdWUgKGEgc3RyaW5nKVxuICAgKi9cbiAgcHJpdmF0ZSBtZXJnZSh2YWx1ZTogc3RyaW5nIHwgc3RyaW5nW10pOiBzdHJpbmcge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkgcmV0dXJuIHZhbHVlLmpvaW4oJywgJylcblxuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBIZWFkZXJzIGluc3RhbmNlIGZyb20gYSBwbGFpbiBvYmplY3Qgb3IgYSBIZWFkZXJzIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0gaGVhZGVycyBhIHBsYWluIG9iamVjdCBvciBhIEhlYWRlcnMgaW5zdGFuY2VcbiAgICogQHJldHVybnMgYSBoZWFkZXJzIGluc3RhbmNlXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGZyb20oaGVhZGVyczogSW5jb21pbmdIdHRwSGVhZGVycyB8IEhlYWRlcnMpOiBIZWFkZXJzIHtcbiAgICBpZiAoaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMpIHJldHVybiBoZWFkZXJzXG5cbiAgICByZXR1cm4gbmV3IEhlYWRlcnNBZGFwdGVyKGhlYWRlcnMpXG4gIH1cblxuICBwdWJsaWMgYXBwZW5kKG5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZyk6IHZvaWQge1xuICAgIGNvbnN0IGV4aXN0aW5nID0gdGhpcy5oZWFkZXJzW25hbWVdXG4gICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuaGVhZGVyc1tuYW1lXSA9IFtleGlzdGluZywgdmFsdWVdXG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGV4aXN0aW5nKSkge1xuICAgICAgZXhpc3RpbmcucHVzaCh2YWx1ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oZWFkZXJzW25hbWVdID0gdmFsdWVcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZGVsZXRlKG5hbWU6IHN0cmluZyk6IHZvaWQge1xuICAgIGRlbGV0ZSB0aGlzLmhlYWRlcnNbbmFtZV1cbiAgfVxuXG4gIHB1YmxpYyBnZXQobmFtZTogc3RyaW5nKTogc3RyaW5nIHwgbnVsbCB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLmhlYWRlcnNbbmFtZV1cbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykgcmV0dXJuIHRoaXMubWVyZ2UodmFsdWUpXG5cbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgcHVibGljIGhhcyhuYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaXMuaGVhZGVyc1tuYW1lXSAhPT0gJ3VuZGVmaW5lZCdcbiAgfVxuXG4gIHB1YmxpYyBzZXQobmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy5oZWFkZXJzW25hbWVdID0gdmFsdWVcbiAgfVxuXG4gIHB1YmxpYyBmb3JFYWNoKFxuICAgIGNhbGxiYWNrZm46ICh2YWx1ZTogc3RyaW5nLCBuYW1lOiBzdHJpbmcsIHBhcmVudDogSGVhZGVycykgPT4gdm9pZCxcbiAgICB0aGlzQXJnPzogYW55XG4gICk6IHZvaWQge1xuICAgIGZvciAoY29uc3QgW25hbWUsIHZhbHVlXSBvZiB0aGlzLmVudHJpZXMoKSkge1xuICAgICAgY2FsbGJhY2tmbi5jYWxsKHRoaXNBcmcsIHZhbHVlLCBuYW1lLCB0aGlzKVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyAqZW50cmllcygpOiBIZWFkZXJzSXRlcmF0b3I8W3N0cmluZywgc3RyaW5nXT4ge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHRoaXMuaGVhZGVycykpIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBrZXkudG9Mb3dlckNhc2UoKVxuICAgICAgLy8gV2UgYXNzZXJ0IGhlcmUgdGhhdCB0aGlzIGlzIGEgc3RyaW5nIGJlY2F1c2Ugd2UgZ290IGl0IGZyb20gdGhlXG4gICAgICAvLyBPYmplY3Qua2V5cygpIGNhbGwgYWJvdmUuXG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0KG5hbWUpIGFzIHN0cmluZ1xuXG4gICAgICB5aWVsZCBbbmFtZSwgdmFsdWVdIGFzIFtzdHJpbmcsIHN0cmluZ11cbiAgICB9XG4gIH1cblxuICBwdWJsaWMgKmtleXMoKTogSGVhZGVyc0l0ZXJhdG9yPHN0cmluZz4ge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHRoaXMuaGVhZGVycykpIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBrZXkudG9Mb3dlckNhc2UoKVxuICAgICAgeWllbGQgbmFtZVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyAqdmFsdWVzKCk6IEhlYWRlcnNJdGVyYXRvcjxzdHJpbmc+IHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh0aGlzLmhlYWRlcnMpKSB7XG4gICAgICAvLyBXZSBhc3NlcnQgaGVyZSB0aGF0IHRoaXMgaXMgYSBzdHJpbmcgYmVjYXVzZSB3ZSBnb3QgaXQgZnJvbSB0aGVcbiAgICAgIC8vIE9iamVjdC5rZXlzKCkgY2FsbCBhYm92ZS5cbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5nZXQoa2V5KSBhcyBzdHJpbmdcblxuICAgICAgeWllbGQgdmFsdWVcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgW1N5bWJvbC5pdGVyYXRvcl0oKTogSGVhZGVyc0l0ZXJhdG9yPFtzdHJpbmcsIHN0cmluZ10+IHtcbiAgICByZXR1cm4gdGhpcy5lbnRyaWVzKClcbiAgfVxufVxuIl0sIm5hbWVzIjpbIkhlYWRlcnNBZGFwdGVyIiwiUmVhZG9ubHlIZWFkZXJzRXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwiY2FsbGFibGUiLCJIZWFkZXJzIiwiaGVhZGVycyIsIlByb3h5IiwiZ2V0IiwidGFyZ2V0IiwicHJvcCIsInJlY2VpdmVyIiwiUmVmbGVjdEFkYXB0ZXIiLCJsb3dlcmNhc2VkIiwidG9Mb3dlckNhc2UiLCJvcmlnaW5hbCIsIk9iamVjdCIsImtleXMiLCJmaW5kIiwibyIsInNldCIsInZhbHVlIiwiaGFzIiwiZGVsZXRlUHJvcGVydHkiLCJzZWFsIiwibWVyZ2UiLCJBcnJheSIsImlzQXJyYXkiLCJqb2luIiwiZnJvbSIsImFwcGVuZCIsIm5hbWUiLCJleGlzdGluZyIsInB1c2giLCJkZWxldGUiLCJmb3JFYWNoIiwiY2FsbGJhY2tmbiIsInRoaXNBcmciLCJlbnRyaWVzIiwiY2FsbCIsImtleSIsInZhbHVlcyIsIlN5bWJvbCIsIml0ZXJhdG9yIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztJQTJCYUEsY0FBYyxFQUFBO2VBQWRBOztJQXBCQUMsb0JBQW9CLEVBQUE7ZUFBcEJBOzs7eUJBTGtCO0FBS3hCLE1BQU1BLDZCQUE2QkM7SUFDeENDLGFBQWM7UUFDWixLQUFLLENBQ0g7SUFFSjtJQUVBLE9BQWNDLFdBQVc7UUFDdkIsTUFBTSxJQUFJSDtJQUNaO0FBQ0Y7QUFVTyxNQUFNRCx1QkFBdUJLO0lBR2xDRixZQUFZRyxPQUE0QixDQUFFO1FBQ3hDLDJFQUEyRTtRQUMzRSwyRUFBMkU7UUFDM0UsS0FBSztRQUVMLElBQUksQ0FBQ0EsT0FBTyxHQUFHLElBQUlDLE1BQU1ELFNBQVM7WUFDaENFLEtBQUlDLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxRQUFRO2dCQUN4QixzRUFBc0U7Z0JBQ3RFLHNFQUFzRTtnQkFDdEUsY0FBYztnQkFDZCxJQUFJLE9BQU9ELFNBQVMsVUFBVTtvQkFDNUIsT0FBT0UsU0FBQUEsY0FBYyxDQUFDSixHQUFHLENBQUNDLFFBQVFDLE1BQU1DO2dCQUMxQztnQkFFQSxNQUFNRSxhQUFhSCxLQUFLSSxXQUFXO2dCQUVuQyx3RUFBd0U7Z0JBQ3hFLHFFQUFxRTtnQkFDckUsa0JBQWtCO2dCQUNsQixNQUFNQyxXQUFXQyxPQUFPQyxJQUFJLENBQUNYLFNBQVNZLElBQUksQ0FDeEMsQ0FBQ0MsSUFBTUEsRUFBRUwsV0FBVyxPQUFPRDtnQkFHN0IsMERBQTBEO2dCQUMxRCxJQUFJLE9BQU9FLGFBQWEsYUFBYTtnQkFFckMsbURBQW1EO2dCQUNuRCxPQUFPSCxTQUFBQSxjQUFjLENBQUNKLEdBQUcsQ0FBQ0MsUUFBUU0sVUFBVUo7WUFDOUM7WUFDQVMsS0FBSVgsTUFBTSxFQUFFQyxJQUFJLEVBQUVXLEtBQUssRUFBRVYsUUFBUTtnQkFDL0IsSUFBSSxPQUFPRCxTQUFTLFVBQVU7b0JBQzVCLE9BQU9FLFNBQUFBLGNBQWMsQ0FBQ1EsR0FBRyxDQUFDWCxRQUFRQyxNQUFNVyxPQUFPVjtnQkFDakQ7Z0JBRUEsTUFBTUUsYUFBYUgsS0FBS0ksV0FBVztnQkFFbkMsd0VBQXdFO2dCQUN4RSxxRUFBcUU7Z0JBQ3JFLGtCQUFrQjtnQkFDbEIsTUFBTUMsV0FBV0MsT0FBT0MsSUFBSSxDQUFDWCxTQUFTWSxJQUFJLENBQ3hDLENBQUNDLElBQU1BLEVBQUVMLFdBQVcsT0FBT0Q7Z0JBRzdCLGlFQUFpRTtnQkFDakUsT0FBT0QsU0FBQUEsY0FBYyxDQUFDUSxHQUFHLENBQUNYLFFBQVFNLFlBQVlMLE1BQU1XLE9BQU9WO1lBQzdEO1lBQ0FXLEtBQUliLE1BQU0sRUFBRUMsSUFBSTtnQkFDZCxJQUFJLE9BQU9BLFNBQVMsVUFBVSxPQUFPRSxTQUFBQSxjQUFjLENBQUNVLEdBQUcsQ0FBQ2IsUUFBUUM7Z0JBRWhFLE1BQU1HLGFBQWFILEtBQUtJLFdBQVc7Z0JBRW5DLHdFQUF3RTtnQkFDeEUscUVBQXFFO2dCQUNyRSxrQkFBa0I7Z0JBQ2xCLE1BQU1DLFdBQVdDLE9BQU9DLElBQUksQ0FBQ1gsU0FBU1ksSUFBSSxDQUN4QyxDQUFDQyxJQUFNQSxFQUFFTCxXQUFXLE9BQU9EO2dCQUc3QixzREFBc0Q7Z0JBQ3RELElBQUksT0FBT0UsYUFBYSxhQUFhLE9BQU87Z0JBRTVDLDhDQUE4QztnQkFDOUMsT0FBT0gsU0FBQUEsY0FBYyxDQUFDVSxHQUFHLENBQUNiLFFBQVFNO1lBQ3BDO1lBQ0FRLGdCQUFlZCxNQUFNLEVBQUVDLElBQUk7Z0JBQ3pCLElBQUksT0FBT0EsU0FBUyxVQUNsQixPQUFPRSxTQUFBQSxjQUFjLENBQUNXLGNBQWMsQ0FBQ2QsUUFBUUM7Z0JBRS9DLE1BQU1HLGFBQWFILEtBQUtJLFdBQVc7Z0JBRW5DLHdFQUF3RTtnQkFDeEUscUVBQXFFO2dCQUNyRSxrQkFBa0I7Z0JBQ2xCLE1BQU1DLFdBQVdDLE9BQU9DLElBQUksQ0FBQ1gsU0FBU1ksSUFBSSxDQUN4QyxDQUFDQyxJQUFNQSxFQUFFTCxXQUFXLE9BQU9EO2dCQUc3QixxREFBcUQ7Z0JBQ3JELElBQUksT0FBT0UsYUFBYSxhQUFhLE9BQU87Z0JBRTVDLHNEQUFzRDtnQkFDdEQsT0FBT0gsU0FBQUEsY0FBYyxDQUFDVyxjQUFjLENBQUNkLFFBQVFNO1lBQy9DO1FBQ0Y7SUFDRjtJQUVBOzs7R0FHQyxHQUNELE9BQWNTLEtBQUtsQixPQUFnQixFQUFtQjtRQUNwRCxPQUFPLElBQUlDLE1BQXVCRCxTQUFTO1lBQ3pDRSxLQUFJQyxNQUFNLEVBQUVDLElBQUksRUFBRUMsUUFBUTtnQkFDeEIsT0FBUUQ7b0JBQ04sS0FBSztvQkFDTCxLQUFLO29CQUNMLEtBQUs7d0JBQ0gsT0FBT1QscUJBQXFCRyxRQUFRO29CQUN0Qzt3QkFDRSxPQUFPUSxTQUFBQSxjQUFjLENBQUNKLEdBQUcsQ0FBQ0MsUUFBUUMsTUFBTUM7Z0JBQzVDO1lBQ0Y7UUFDRjtJQUNGO0lBRUE7Ozs7OztHQU1DLEdBQ09jLE1BQU1KLEtBQXdCLEVBQVU7UUFDOUMsSUFBSUssTUFBTUMsT0FBTyxDQUFDTixRQUFRLE9BQU9BLE1BQU1PLElBQUksQ0FBQztRQUU1QyxPQUFPUDtJQUNUO0lBRUE7Ozs7O0dBS0MsR0FDRCxPQUFjUSxLQUFLdkIsT0FBc0MsRUFBVztRQUNsRSxJQUFJQSxtQkFBbUJELFNBQVMsT0FBT0M7UUFFdkMsT0FBTyxJQUFJTixlQUFlTTtJQUM1QjtJQUVPd0IsT0FBT0MsSUFBWSxFQUFFVixLQUFhLEVBQVE7UUFDL0MsTUFBTVcsV0FBVyxJQUFJLENBQUMxQixPQUFPLENBQUN5QixLQUFLO1FBQ25DLElBQUksT0FBT0MsYUFBYSxVQUFVO1lBQ2hDLElBQUksQ0FBQzFCLE9BQU8sQ0FBQ3lCLEtBQUssR0FBRztnQkFBQ0M7Z0JBQVVYO2FBQU07UUFDeEMsT0FBTyxJQUFJSyxNQUFNQyxPQUFPLENBQUNLLFdBQVc7WUFDbENBLFNBQVNDLElBQUksQ0FBQ1o7UUFDaEIsT0FBTztZQUNMLElBQUksQ0FBQ2YsT0FBTyxDQUFDeUIsS0FBSyxHQUFHVjtRQUN2QjtJQUNGO0lBRU9hLE9BQU9ILElBQVksRUFBUTtRQUNoQyxPQUFPLElBQUksQ0FBQ3pCLE9BQU8sQ0FBQ3lCLEtBQUs7SUFDM0I7SUFFT3ZCLElBQUl1QixJQUFZLEVBQWlCO1FBQ3RDLE1BQU1WLFFBQVEsSUFBSSxDQUFDZixPQUFPLENBQUN5QixLQUFLO1FBQ2hDLElBQUksT0FBT1YsVUFBVSxhQUFhLE9BQU8sSUFBSSxDQUFDSSxLQUFLLENBQUNKO1FBRXBELE9BQU87SUFDVDtJQUVPQyxJQUFJUyxJQUFZLEVBQVc7UUFDaEMsT0FBTyxPQUFPLElBQUksQ0FBQ3pCLE9BQU8sQ0FBQ3lCLEtBQUssS0FBSztJQUN2QztJQUVPWCxJQUFJVyxJQUFZLEVBQUVWLEtBQWEsRUFBUTtRQUM1QyxJQUFJLENBQUNmLE9BQU8sQ0FBQ3lCLEtBQUssR0FBR1Y7SUFDdkI7SUFFT2MsUUFDTEMsVUFBa0UsRUFDbEVDLE9BQWEsRUFDUDtRQUNOLEtBQUssTUFBTSxDQUFDTixNQUFNVixNQUFNLElBQUksSUFBSSxDQUFDaUIsT0FBTyxHQUFJO1lBQzFDRixXQUFXRyxJQUFJLENBQUNGLFNBQVNoQixPQUFPVSxNQUFNLElBQUk7UUFDNUM7SUFDRjtJQUVBLENBQVFPLFVBQTZDO1FBQ25ELEtBQUssTUFBTUUsT0FBT3hCLE9BQU9DLElBQUksQ0FBQyxJQUFJLENBQUNYLE9BQU8sRUFBRztZQUMzQyxNQUFNeUIsT0FBT1MsSUFBSTFCLFdBQVc7WUFDNUIsa0VBQWtFO1lBQ2xFLDRCQUE0QjtZQUM1QixNQUFNTyxRQUFRLElBQUksQ0FBQ2IsR0FBRyxDQUFDdUI7WUFFdkIsTUFBTTtnQkFBQ0E7Z0JBQU1WO2FBQU07UUFDckI7SUFDRjtJQUVBLENBQVFKLE9BQWdDO1FBQ3RDLEtBQUssTUFBTXVCLE9BQU94QixPQUFPQyxJQUFJLENBQUMsSUFBSSxDQUFDWCxPQUFPLEVBQUc7WUFDM0MsTUFBTXlCLE9BQU9TLElBQUkxQixXQUFXO1lBQzVCLE1BQU1pQjtRQUNSO0lBQ0Y7SUFFQSxDQUFRVSxTQUFrQztRQUN4QyxLQUFLLE1BQU1ELE9BQU94QixPQUFPQyxJQUFJLENBQUMsSUFBSSxDQUFDWCxPQUFPLEVBQUc7WUFDM0Msa0VBQWtFO1lBQ2xFLDRCQUE0QjtZQUM1QixNQUFNZSxRQUFRLElBQUksQ0FBQ2IsR0FBRyxDQUFDZ0M7WUFFdkIsTUFBTW5CO1FBQ1I7SUFDRjtJQUVPLENBQUNxQixPQUFPQyxRQUFRLENBQUMsR0FBc0M7UUFDNUQsT0FBTyxJQUFJLENBQUNMLE9BQU87SUFDckI7QUFDRiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxNDA2LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL3NlcnZlci9yZXF1ZXN0L2hlYWRlcnMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgSGVhZGVyc0FkYXB0ZXIsXG4gIHR5cGUgUmVhZG9ubHlIZWFkZXJzLFxufSBmcm9tICcuLi93ZWIvc3BlYy1leHRlbnNpb24vYWRhcHRlcnMvaGVhZGVycydcbmltcG9ydCB7IHdvcmtBc3luY1N0b3JhZ2UgfSBmcm9tICcuLi9hcHAtcmVuZGVyL3dvcmstYXN5bmMtc3RvcmFnZS5leHRlcm5hbCdcbmltcG9ydCB7IGdldEV4cGVjdGVkUmVxdWVzdFN0b3JlIH0gZnJvbSAnLi4vYXBwLXJlbmRlci93b3JrLXVuaXQtYXN5bmMtc3RvcmFnZS5leHRlcm5hbCdcbmltcG9ydCB7XG4gIHdvcmtVbml0QXN5bmNTdG9yYWdlLFxuICB0eXBlIFByZXJlbmRlclN0b3JlTW9kZXJuLFxufSBmcm9tICcuLi9hcHAtcmVuZGVyL3dvcmstdW5pdC1hc3luYy1zdG9yYWdlLmV4dGVybmFsJ1xuaW1wb3J0IHtcbiAgcG9zdHBvbmVXaXRoVHJhY2tpbmcsXG4gIHRocm93VG9JbnRlcnJ1cHRTdGF0aWNHZW5lcmF0aW9uLFxuICB0cmFja0R5bmFtaWNEYXRhSW5EeW5hbWljUmVuZGVyLFxuICB0cmFja1N5bmNocm9ub3VzUmVxdWVzdERhdGFBY2Nlc3NJbkRldixcbn0gZnJvbSAnLi4vYXBwLXJlbmRlci9keW5hbWljLXJlbmRlcmluZydcbmltcG9ydCB7IFN0YXRpY0dlbkJhaWxvdXRFcnJvciB9IGZyb20gJy4uLy4uL2NsaWVudC9jb21wb25lbnRzL3N0YXRpYy1nZW5lcmF0aW9uLWJhaWxvdXQnXG5pbXBvcnQgeyBtYWtlSGFuZ2luZ1Byb21pc2UgfSBmcm9tICcuLi9keW5hbWljLXJlbmRlcmluZy11dGlscydcbmltcG9ydCB7IGNyZWF0ZURlZHVwZWRCeUNhbGxzaXRlU2VydmVyRXJyb3JMb2dnZXJEZXYgfSBmcm9tICcuLi9jcmVhdGUtZGVkdXBlZC1ieS1jYWxsc2l0ZS1zZXJ2ZXItZXJyb3ItbG9nZ2VyJ1xuaW1wb3J0IHsgc2NoZWR1bGVJbW1lZGlhdGUgfSBmcm9tICcuLi8uLi9saWIvc2NoZWR1bGVyJ1xuaW1wb3J0IHsgaXNSZXF1ZXN0QVBJQ2FsbGFibGVJbnNpZGVBZnRlciB9IGZyb20gJy4vdXRpbHMnXG5pbXBvcnQgeyBJbnZhcmlhbnRFcnJvciB9IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvaW52YXJpYW50LWVycm9yJ1xuaW1wb3J0IHsgUmVmbGVjdEFkYXB0ZXIgfSBmcm9tICcuLi93ZWIvc3BlYy1leHRlbnNpb24vYWRhcHRlcnMvcmVmbGVjdCdcblxuLyoqXG4gKiBJbiB0aGlzIHZlcnNpb24gb2YgTmV4dC5qcyBgaGVhZGVycygpYCByZXR1cm5zIGEgUHJvbWlzZSBob3dldmVyIHlvdSBjYW4gc3RpbGwgcmVmZXJlbmNlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSB1bmRlcmx5aW5nIEhlYWRlcnMgaW5zdGFuY2VcbiAqIHN5bmNocm9ub3VzbHkgdG8gZmFjaWxpdGF0ZSBtaWdyYXRpb24uIFRoZSBgVW5zYWZlVW53cmFwcGVkSGVhZGVyc2AgdHlwZSBpcyBhZGRlZCB0byB5b3VyIGNvZGUgYnkgYSBjb2RlbW9kIHRoYXQgYXR0ZW1wdHMgdG8gYXV0b21hdGljYWxseVxuICogdXBkYXRlcyBjYWxsc2l0ZXMgdG8gcmVmbGVjdCB0aGUgbmV3IFByb21pc2UgcmV0dXJuIHR5cGUuIFRoZXJlIGFyZSBzb21lIGNhc2VzIHdoZXJlIGBoZWFkZXJzKClgIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCwgbmFtZWx5XG4gKiB3aGVuIGl0IGlzIHVzZWQgaW5zaWRlIGEgc3luY2hyb25vdXMgZnVuY3Rpb24gYW5kIHdlIGNhbid0IGJlIHN1cmUgdGhlIGZ1bmN0aW9uIGNhbiBiZSBtYWRlIGFzeW5jIGF1dG9tYXRpY2FsbHkuIEluIHRoZXNlIGNhc2VzIHdlIGFkZCBhblxuICogZXhwbGljaXQgdHlwZSBjYXNlIHRvIGBVbnNhZmVVbndyYXBwZWRIZWFkZXJzYCB0byBlbmFibGUgdHlwZXNjcmlwdCB0byBhbGxvdyBmb3IgdGhlIHN5bmNocm9ub3VzIHVzYWdlIG9ubHkgd2hlcmUgaXQgaXMgYWN0dWFsbHkgbmVjZXNzYXJ5LlxuICpcbiAqIFlvdSBzaG91bGQgc2hvdWxkIHVwZGF0ZSB0aGVzZSBjYWxsc2l0ZXMgdG8gZWl0aGVyIGJlIGFzeW5jIGZ1bmN0aW9ucyB3aGVyZSB0aGUgYGhlYWRlcnMoKWAgdmFsdWUgY2FuIGJlIGF3YWl0ZWQgb3IgeW91IHNob3VsZCBjYWxsIGBoZWFkZXJzKClgXG4gKiBmcm9tIG91dHNpZGUgYW5kIGF3YWl0IHRoZSByZXR1cm4gdmFsdWUgYmVmb3JlIHBhc3NpbmcgaXQgaW50byB0aGlzIGZ1bmN0aW9uLlxuICpcbiAqIFlvdSBjYW4gZmluZCBpbnN0YW5jZXMgdGhhdCByZXF1aXJlIG1hbnVhbCBtaWdyYXRpb24gYnkgc2VhcmNoaW5nIGZvciBgVW5zYWZlVW53cmFwcGVkSGVhZGVyc2AgaW4geW91ciBjb2RlYmFzZSBvciBieSBzZWFyY2ggZm9yIGEgY29tbWVudCB0aGF0XG4gKiBzdGFydHMgd2l0aCBgQG5leHQtY29kZW1vZC1lcnJvcmAuXG4gKlxuICogSW4gYSBmdXR1cmUgdmVyc2lvbiBvZiBOZXh0LmpzIGBoZWFkZXJzKClgIHdpbGwgb25seSByZXR1cm4gYSBQcm9taXNlIGFuZCB5b3Ugd2lsbCBub3QgYmUgYWJsZSB0byBhY2Nlc3MgdGhlIHVuZGVybHlpbmcgSGVhZGVycyBpbnN0YW5jZVxuICogd2l0aG91dCBhd2FpdGluZyB0aGUgcmV0dXJuIHZhbHVlIGZpcnN0LiBXaGVuIHRoaXMgY2hhbmdlIGhhcHBlbnMgdGhlIHR5cGUgYFVuc2FmZVVud3JhcHBlZEhlYWRlcnNgIHdpbGwgYmUgdXBkYXRlZCB0byByZWZsZWN0IHRoYXQgaXMgaXQgbm8gbG9uZ2VyXG4gKiB1c2FibGUuXG4gKlxuICogVGhpcyB0eXBlIGlzIG1hcmtlZCBkZXByZWNhdGVkIHRvIGhlbHAgaWRlbnRpZnkgaXQgYXMgdGFyZ2V0IGZvciByZWZhY3RvcmluZyBhd2F5LlxuICpcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmV4cG9ydCB0eXBlIFVuc2FmZVVud3JhcHBlZEhlYWRlcnMgPSBSZWFkb25seUhlYWRlcnNcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGFsbG93cyB5b3UgdG8gcmVhZCB0aGUgSFRUUCBpbmNvbWluZyByZXF1ZXN0IGhlYWRlcnMgaW5cbiAqIFtTZXJ2ZXIgQ29tcG9uZW50c10oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2J1aWxkaW5nLXlvdXItYXBwbGljYXRpb24vcmVuZGVyaW5nL3NlcnZlci1jb21wb25lbnRzKSxcbiAqIFtTZXJ2ZXIgQWN0aW9uc10oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2J1aWxkaW5nLXlvdXItYXBwbGljYXRpb24vZGF0YS1mZXRjaGluZy9zZXJ2ZXItYWN0aW9ucy1hbmQtbXV0YXRpb25zKSxcbiAqIFtSb3V0ZSBIYW5kbGVyc10oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2J1aWxkaW5nLXlvdXItYXBwbGljYXRpb24vcm91dGluZy9yb3V0ZS1oYW5kbGVycykgYW5kXG4gKiBbTWlkZGxld2FyZV0oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2J1aWxkaW5nLXlvdXItYXBwbGljYXRpb24vcm91dGluZy9taWRkbGV3YXJlKS5cbiAqXG4gKiBSZWFkIG1vcmU6IFtOZXh0LmpzIERvY3M6IGBoZWFkZXJzYF0oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2FwaS1yZWZlcmVuY2UvZnVuY3Rpb25zL2hlYWRlcnMpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZWFkZXJzKCk6IFByb21pc2U8UmVhZG9ubHlIZWFkZXJzPiB7XG4gIGNvbnN0IHdvcmtTdG9yZSA9IHdvcmtBc3luY1N0b3JhZ2UuZ2V0U3RvcmUoKVxuICBjb25zdCB3b3JrVW5pdFN0b3JlID0gd29ya1VuaXRBc3luY1N0b3JhZ2UuZ2V0U3RvcmUoKVxuXG4gIGlmICh3b3JrU3RvcmUpIHtcbiAgICBpZiAoXG4gICAgICB3b3JrVW5pdFN0b3JlICYmXG4gICAgICB3b3JrVW5pdFN0b3JlLnBoYXNlID09PSAnYWZ0ZXInICYmXG4gICAgICAhaXNSZXF1ZXN0QVBJQ2FsbGFibGVJbnNpZGVBZnRlcigpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBSb3V0ZSAke3dvcmtTdG9yZS5yb3V0ZX0gdXNlZCBcImhlYWRlcnNcIiBpbnNpZGUgXCJhZnRlciguLi4pXCIuIFRoaXMgaXMgbm90IHN1cHBvcnRlZC4gSWYgeW91IG5lZWQgdGhpcyBkYXRhIGluc2lkZSBhbiBcImFmdGVyXCIgY2FsbGJhY2ssIHVzZSBcImhlYWRlcnNcIiBvdXRzaWRlIG9mIHRoZSBjYWxsYmFjay4gU2VlIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9jYW5hcnkvYXBwL2FwaS1yZWZlcmVuY2UvZnVuY3Rpb25zL2FmdGVyYFxuICAgICAgKVxuICAgIH1cblxuICAgIGlmICh3b3JrU3RvcmUuZm9yY2VTdGF0aWMpIHtcbiAgICAgIC8vIFdoZW4gdXNpbmcgZm9yY2VTdGF0aWMgd2Ugb3ZlcnJpZGUgYWxsIG90aGVyIGxvZ2ljIGFuZCBhbHdheXMganVzdCByZXR1cm4gYW4gZW1wdHlcbiAgICAgIC8vIGhlYWRlcnMgb2JqZWN0IHdpdGhvdXQgdHJhY2tpbmdcbiAgICAgIGNvbnN0IHVuZGVybHlpbmdIZWFkZXJzID0gSGVhZGVyc0FkYXB0ZXIuc2VhbChuZXcgSGVhZGVycyh7fSkpXG4gICAgICByZXR1cm4gbWFrZVVudHJhY2tlZEV4b3RpY0hlYWRlcnModW5kZXJseWluZ0hlYWRlcnMpXG4gICAgfVxuXG4gICAgaWYgKHdvcmtVbml0U3RvcmUpIHtcbiAgICAgIGlmICh3b3JrVW5pdFN0b3JlLnR5cGUgPT09ICdjYWNoZScpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBSb3V0ZSAke3dvcmtTdG9yZS5yb3V0ZX0gdXNlZCBcImhlYWRlcnNcIiBpbnNpZGUgXCJ1c2UgY2FjaGVcIi4gQWNjZXNzaW5nIER5bmFtaWMgZGF0YSBzb3VyY2VzIGluc2lkZSBhIGNhY2hlIHNjb3BlIGlzIG5vdCBzdXBwb3J0ZWQuIElmIHlvdSBuZWVkIHRoaXMgZGF0YSBpbnNpZGUgYSBjYWNoZWQgZnVuY3Rpb24gdXNlIFwiaGVhZGVyc1wiIG91dHNpZGUgb2YgdGhlIGNhY2hlZCBmdW5jdGlvbiBhbmQgcGFzcyB0aGUgcmVxdWlyZWQgZHluYW1pYyBkYXRhIGluIGFzIGFuIGFyZ3VtZW50LiBTZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL25leHQtcmVxdWVzdC1pbi11c2UtY2FjaGVgXG4gICAgICAgIClcbiAgICAgIH0gZWxzZSBpZiAod29ya1VuaXRTdG9yZS50eXBlID09PSAndW5zdGFibGUtY2FjaGUnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgUm91dGUgJHt3b3JrU3RvcmUucm91dGV9IHVzZWQgXCJoZWFkZXJzXCIgaW5zaWRlIGEgZnVuY3Rpb24gY2FjaGVkIHdpdGggXCJ1bnN0YWJsZV9jYWNoZSguLi4pXCIuIEFjY2Vzc2luZyBEeW5hbWljIGRhdGEgc291cmNlcyBpbnNpZGUgYSBjYWNoZSBzY29wZSBpcyBub3Qgc3VwcG9ydGVkLiBJZiB5b3UgbmVlZCB0aGlzIGRhdGEgaW5zaWRlIGEgY2FjaGVkIGZ1bmN0aW9uIHVzZSBcImhlYWRlcnNcIiBvdXRzaWRlIG9mIHRoZSBjYWNoZWQgZnVuY3Rpb24gYW5kIHBhc3MgdGhlIHJlcXVpcmVkIGR5bmFtaWMgZGF0YSBpbiBhcyBhbiBhcmd1bWVudC4gU2VlIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYXBpLXJlZmVyZW5jZS9mdW5jdGlvbnMvdW5zdGFibGVfY2FjaGVgXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHdvcmtTdG9yZS5keW5hbWljU2hvdWxkRXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBTdGF0aWNHZW5CYWlsb3V0RXJyb3IoXG4gICAgICAgIGBSb3V0ZSAke3dvcmtTdG9yZS5yb3V0ZX0gd2l0aCBcXGBkeW5hbWljID0gXCJlcnJvclwiXFxgIGNvdWxkbid0IGJlIHJlbmRlcmVkIHN0YXRpY2FsbHkgYmVjYXVzZSBpdCB1c2VkIFxcYGhlYWRlcnNcXGAuIFNlZSBtb3JlIGluZm8gaGVyZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2J1aWxkaW5nLXlvdXItYXBwbGljYXRpb24vcmVuZGVyaW5nL3N0YXRpYy1hbmQtZHluYW1pYyNkeW5hbWljLXJlbmRlcmluZ2BcbiAgICAgIClcbiAgICB9XG5cbiAgICBpZiAod29ya1VuaXRTdG9yZSkge1xuICAgICAgc3dpdGNoICh3b3JrVW5pdFN0b3JlLnR5cGUpIHtcbiAgICAgICAgY2FzZSAncHJlcmVuZGVyJzpcbiAgICAgICAgICByZXR1cm4gbWFrZUhhbmdpbmdIZWFkZXJzKHdvcmtVbml0U3RvcmUpXG4gICAgICAgIGNhc2UgJ3ByZXJlbmRlci1jbGllbnQnOlxuICAgICAgICAgIGNvbnN0IGV4cG9ydE5hbWUgPSAnYGhlYWRlcnNgJ1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhcmlhbnRFcnJvcihcbiAgICAgICAgICAgIGAke2V4cG9ydE5hbWV9IG11c3Qgbm90IGJlIHVzZWQgd2l0aGluIGEgY2xpZW50IGNvbXBvbmVudC4gTmV4dC5qcyBzaG91bGQgYmUgcHJldmVudGluZyAke2V4cG9ydE5hbWV9IGZyb20gYmVpbmcgaW5jbHVkZWQgaW4gY2xpZW50IGNvbXBvbmVudHMgc3RhdGljYWxseSwgYnV0IGRpZCBub3QgaW4gdGhpcyBjYXNlLmBcbiAgICAgICAgICApXG4gICAgICAgIGNhc2UgJ3ByZXJlbmRlci1wcHInOlxuICAgICAgICAgIC8vIFBQUiBQcmVyZW5kZXIgKG5vIGR5bmFtaWNJTylcbiAgICAgICAgICAvLyBXZSBhcmUgcHJlcmVuZGVyaW5nIHdpdGggUFBSLiBXZSBuZWVkIHRyYWNrIGR5bmFtaWMgYWNjZXNzIGhlcmUgZWFnZXJseVxuICAgICAgICAgIC8vIHRvIGtlZXAgY29udGludWl0eSB3aXRoIGhvdyBoZWFkZXJzIGhhcyB3b3JrZWQgaW4gUFBSIHdpdGhvdXQgZHluYW1pY0lPLlxuICAgICAgICAgIC8vIFRPRE8gY29uc2lkZXIgc3dpdGNoaW5nIHRoZSBzZW1hbnRpYyB0byB0aHJvdyBvbiBwcm9wZXJ0eSBhY2Nlc3MgaW5zdGVhZFxuICAgICAgICAgIHBvc3Rwb25lV2l0aFRyYWNraW5nKFxuICAgICAgICAgICAgd29ya1N0b3JlLnJvdXRlLFxuICAgICAgICAgICAgJ2hlYWRlcnMnLFxuICAgICAgICAgICAgd29ya1VuaXRTdG9yZS5keW5hbWljVHJhY2tpbmdcbiAgICAgICAgICApXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAncHJlcmVuZGVyLWxlZ2FjeSc6XG4gICAgICAgICAgLy8gTGVnYWN5IFByZXJlbmRlclxuICAgICAgICAgIC8vIFdlIGFyZSBpbiBhIGxlZ2FjeSBzdGF0aWMgZ2VuZXJhdGlvbiBtb2RlIHdoaWxlIHByZXJlbmRlcmluZ1xuICAgICAgICAgIC8vIFdlIHRyYWNrIGR5bmFtaWMgYWNjZXNzIGhlcmUgc28gd2UgZG9uJ3QgbmVlZCB0byB3cmFwIHRoZSBoZWFkZXJzIGluXG4gICAgICAgICAgLy8gaW5kaXZpZHVhbCBwcm9wZXJ0eSBhY2Nlc3MgdHJhY2tpbmcuXG4gICAgICAgICAgdGhyb3dUb0ludGVycnVwdFN0YXRpY0dlbmVyYXRpb24oJ2hlYWRlcnMnLCB3b3JrU3RvcmUsIHdvcmtVbml0U3RvcmUpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gZmFsbHRocm91Z2hcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gV2UgZmFsbCB0aHJvdWdoIHRvIHRoZSBkeW5hbWljIGNvbnRleHQgYmVsb3cgYnV0IHdlIHN0aWxsIHRyYWNrIGR5bmFtaWMgYWNjZXNzXG4gICAgLy8gYmVjYXVzZSBpbiBkZXYgd2UgY2FuIHN0aWxsIGVycm9yIGZvciB0aGluZ3MgbGlrZSB1c2luZyBoZWFkZXJzIGluc2lkZSBhIGNhY2hlIGNvbnRleHRcbiAgICB0cmFja0R5bmFtaWNEYXRhSW5EeW5hbWljUmVuZGVyKHdvcmtTdG9yZSwgd29ya1VuaXRTdG9yZSlcbiAgfVxuXG4gIGNvbnN0IHJlcXVlc3RTdG9yZSA9IGdldEV4cGVjdGVkUmVxdWVzdFN0b3JlKCdoZWFkZXJzJylcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICF3b3JrU3RvcmU/LmlzUHJlZmV0Y2hSZXF1ZXN0KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9EWU5BTUlDX0lPKSB7XG4gICAgICByZXR1cm4gbWFrZVVudHJhY2tlZEhlYWRlcnNXaXRoRGV2V2FybmluZ3MoXG4gICAgICAgIHJlcXVlc3RTdG9yZS5oZWFkZXJzLFxuICAgICAgICB3b3JrU3RvcmU/LnJvdXRlXG4gICAgICApXG4gICAgfVxuXG4gICAgcmV0dXJuIG1ha2VVbnRyYWNrZWRFeG90aWNIZWFkZXJzV2l0aERldldhcm5pbmdzKFxuICAgICAgcmVxdWVzdFN0b3JlLmhlYWRlcnMsXG4gICAgICB3b3JrU3RvcmU/LnJvdXRlXG4gICAgKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBtYWtlVW50cmFja2VkRXhvdGljSGVhZGVycyhyZXF1ZXN0U3RvcmUuaGVhZGVycylcbiAgfVxufVxuXG5pbnRlcmZhY2UgQ2FjaGVMaWZldGltZSB7fVxuY29uc3QgQ2FjaGVkSGVhZGVycyA9IG5ldyBXZWFrTWFwPENhY2hlTGlmZXRpbWUsIFByb21pc2U8UmVhZG9ubHlIZWFkZXJzPj4oKVxuXG5mdW5jdGlvbiBtYWtlSGFuZ2luZ0hlYWRlcnMoXG4gIHByZXJlbmRlclN0b3JlOiBQcmVyZW5kZXJTdG9yZU1vZGVyblxuKTogUHJvbWlzZTxSZWFkb25seUhlYWRlcnM+IHtcbiAgY29uc3QgY2FjaGVkSGVhZGVycyA9IENhY2hlZEhlYWRlcnMuZ2V0KHByZXJlbmRlclN0b3JlKVxuICBpZiAoY2FjaGVkSGVhZGVycykge1xuICAgIHJldHVybiBjYWNoZWRIZWFkZXJzXG4gIH1cblxuICBjb25zdCBwcm9taXNlID0gbWFrZUhhbmdpbmdQcm9taXNlPFJlYWRvbmx5SGVhZGVycz4oXG4gICAgcHJlcmVuZGVyU3RvcmUucmVuZGVyU2lnbmFsLFxuICAgICdgaGVhZGVycygpYCdcbiAgKVxuICBDYWNoZWRIZWFkZXJzLnNldChwcmVyZW5kZXJTdG9yZSwgcHJvbWlzZSlcblxuICByZXR1cm4gcHJvbWlzZVxufVxuXG5mdW5jdGlvbiBtYWtlVW50cmFja2VkRXhvdGljSGVhZGVycyhcbiAgdW5kZXJseWluZ0hlYWRlcnM6IFJlYWRvbmx5SGVhZGVyc1xuKTogUHJvbWlzZTxSZWFkb25seUhlYWRlcnM+IHtcbiAgY29uc3QgY2FjaGVkSGVhZGVycyA9IENhY2hlZEhlYWRlcnMuZ2V0KHVuZGVybHlpbmdIZWFkZXJzKVxuICBpZiAoY2FjaGVkSGVhZGVycykge1xuICAgIHJldHVybiBjYWNoZWRIZWFkZXJzXG4gIH1cblxuICBjb25zdCBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHVuZGVybHlpbmdIZWFkZXJzKVxuICBDYWNoZWRIZWFkZXJzLnNldCh1bmRlcmx5aW5nSGVhZGVycywgcHJvbWlzZSlcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhwcm9taXNlLCB7XG4gICAgYXBwZW5kOiB7XG4gICAgICB2YWx1ZTogdW5kZXJseWluZ0hlYWRlcnMuYXBwZW5kLmJpbmQodW5kZXJseWluZ0hlYWRlcnMpLFxuICAgIH0sXG4gICAgZGVsZXRlOiB7XG4gICAgICB2YWx1ZTogdW5kZXJseWluZ0hlYWRlcnMuZGVsZXRlLmJpbmQodW5kZXJseWluZ0hlYWRlcnMpLFxuICAgIH0sXG4gICAgZ2V0OiB7XG4gICAgICB2YWx1ZTogdW5kZXJseWluZ0hlYWRlcnMuZ2V0LmJpbmQodW5kZXJseWluZ0hlYWRlcnMpLFxuICAgIH0sXG4gICAgaGFzOiB7XG4gICAgICB2YWx1ZTogdW5kZXJseWluZ0hlYWRlcnMuaGFzLmJpbmQodW5kZXJseWluZ0hlYWRlcnMpLFxuICAgIH0sXG4gICAgc2V0OiB7XG4gICAgICB2YWx1ZTogdW5kZXJseWluZ0hlYWRlcnMuc2V0LmJpbmQodW5kZXJseWluZ0hlYWRlcnMpLFxuICAgIH0sXG4gICAgZ2V0U2V0Q29va2llOiB7XG4gICAgICB2YWx1ZTogdW5kZXJseWluZ0hlYWRlcnMuZ2V0U2V0Q29va2llLmJpbmQodW5kZXJseWluZ0hlYWRlcnMpLFxuICAgIH0sXG4gICAgZm9yRWFjaDoge1xuICAgICAgdmFsdWU6IHVuZGVybHlpbmdIZWFkZXJzLmZvckVhY2guYmluZCh1bmRlcmx5aW5nSGVhZGVycyksXG4gICAgfSxcbiAgICBrZXlzOiB7XG4gICAgICB2YWx1ZTogdW5kZXJseWluZ0hlYWRlcnMua2V5cy5iaW5kKHVuZGVybHlpbmdIZWFkZXJzKSxcbiAgICB9LFxuICAgIHZhbHVlczoge1xuICAgICAgdmFsdWU6IHVuZGVybHlpbmdIZWFkZXJzLnZhbHVlcy5iaW5kKHVuZGVybHlpbmdIZWFkZXJzKSxcbiAgICB9LFxuICAgIGVudHJpZXM6IHtcbiAgICAgIHZhbHVlOiB1bmRlcmx5aW5nSGVhZGVycy5lbnRyaWVzLmJpbmQodW5kZXJseWluZ0hlYWRlcnMpLFxuICAgIH0sXG4gICAgW1N5bWJvbC5pdGVyYXRvcl06IHtcbiAgICAgIHZhbHVlOiB1bmRlcmx5aW5nSGVhZGVyc1tTeW1ib2wuaXRlcmF0b3JdLmJpbmQodW5kZXJseWluZ0hlYWRlcnMpLFxuICAgIH0sXG4gIH0gc2F0aXNmaWVzIEhlYWRlcnNFeHRlbnNpb25zKVxuXG4gIHJldHVybiBwcm9taXNlXG59XG5cbmZ1bmN0aW9uIG1ha2VVbnRyYWNrZWRFeG90aWNIZWFkZXJzV2l0aERldldhcm5pbmdzKFxuICB1bmRlcmx5aW5nSGVhZGVyczogUmVhZG9ubHlIZWFkZXJzLFxuICByb3V0ZT86IHN0cmluZ1xuKTogUHJvbWlzZTxSZWFkb25seUhlYWRlcnM+IHtcbiAgY29uc3QgY2FjaGVkSGVhZGVycyA9IENhY2hlZEhlYWRlcnMuZ2V0KHVuZGVybHlpbmdIZWFkZXJzKVxuICBpZiAoY2FjaGVkSGVhZGVycykge1xuICAgIHJldHVybiBjYWNoZWRIZWFkZXJzXG4gIH1cblxuICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2U8UmVhZG9ubHlIZWFkZXJzPigocmVzb2x2ZSkgPT5cbiAgICBzY2hlZHVsZUltbWVkaWF0ZSgoKSA9PiByZXNvbHZlKHVuZGVybHlpbmdIZWFkZXJzKSlcbiAgKVxuXG4gIENhY2hlZEhlYWRlcnMuc2V0KHVuZGVybHlpbmdIZWFkZXJzLCBwcm9taXNlKVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHByb21pc2UsIHtcbiAgICBhcHBlbmQ6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBlbmQoKSB7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBgXFxgaGVhZGVycygpLmFwcGVuZCgke2Rlc2NyaWJlTmFtZUFyZyhhcmd1bWVudHNbMF0pfSwgLi4uKVxcYGBcbiAgICAgICAgc3luY0lPRGV2KHJvdXRlLCBleHByZXNzaW9uKVxuICAgICAgICByZXR1cm4gdW5kZXJseWluZ0hlYWRlcnMuYXBwZW5kLmFwcGx5KFxuICAgICAgICAgIHVuZGVybHlpbmdIZWFkZXJzLFxuICAgICAgICAgIGFyZ3VtZW50cyBhcyBhbnlcbiAgICAgICAgKVxuICAgICAgfSxcbiAgICB9LFxuICAgIGRlbGV0ZToge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWxldGUoKSB7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBgXFxgaGVhZGVycygpLmRlbGV0ZSgke2Rlc2NyaWJlTmFtZUFyZyhhcmd1bWVudHNbMF0pfSlcXGBgXG4gICAgICAgIHN5bmNJT0Rldihyb3V0ZSwgZXhwcmVzc2lvbilcbiAgICAgICAgcmV0dXJuIHVuZGVybHlpbmdIZWFkZXJzLmRlbGV0ZS5hcHBseShcbiAgICAgICAgICB1bmRlcmx5aW5nSGVhZGVycyxcbiAgICAgICAgICBhcmd1bWVudHMgYXMgYW55XG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgfSxcbiAgICBnZXQ6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBgXFxgaGVhZGVycygpLmdldCgke2Rlc2NyaWJlTmFtZUFyZyhhcmd1bWVudHNbMF0pfSlcXGBgXG4gICAgICAgIHN5bmNJT0Rldihyb3V0ZSwgZXhwcmVzc2lvbilcbiAgICAgICAgcmV0dXJuIHVuZGVybHlpbmdIZWFkZXJzLmdldC5hcHBseSh1bmRlcmx5aW5nSGVhZGVycywgYXJndW1lbnRzIGFzIGFueSlcbiAgICAgIH0sXG4gICAgfSxcbiAgICBoYXM6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYXMoKSB7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBgXFxgaGVhZGVycygpLmhhcygke2Rlc2NyaWJlTmFtZUFyZyhhcmd1bWVudHNbMF0pfSlcXGBgXG4gICAgICAgIHN5bmNJT0Rldihyb3V0ZSwgZXhwcmVzc2lvbilcbiAgICAgICAgcmV0dXJuIHVuZGVybHlpbmdIZWFkZXJzLmhhcy5hcHBseSh1bmRlcmx5aW5nSGVhZGVycywgYXJndW1lbnRzIGFzIGFueSlcbiAgICAgIH0sXG4gICAgfSxcbiAgICBzZXQ6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXQoKSB7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBgXFxgaGVhZGVycygpLnNldCgke2Rlc2NyaWJlTmFtZUFyZyhhcmd1bWVudHNbMF0pfSwgLi4uKVxcYGBcbiAgICAgICAgc3luY0lPRGV2KHJvdXRlLCBleHByZXNzaW9uKVxuICAgICAgICByZXR1cm4gdW5kZXJseWluZ0hlYWRlcnMuc2V0LmFwcGx5KHVuZGVybHlpbmdIZWFkZXJzLCBhcmd1bWVudHMgYXMgYW55KVxuICAgICAgfSxcbiAgICB9LFxuICAgIGdldFNldENvb2tpZToge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNldENvb2tpZSgpIHtcbiAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9ICdgaGVhZGVycygpLmdldFNldENvb2tpZSgpYCdcbiAgICAgICAgc3luY0lPRGV2KHJvdXRlLCBleHByZXNzaW9uKVxuICAgICAgICByZXR1cm4gdW5kZXJseWluZ0hlYWRlcnMuZ2V0U2V0Q29va2llLmFwcGx5KFxuICAgICAgICAgIHVuZGVybHlpbmdIZWFkZXJzLFxuICAgICAgICAgIGFyZ3VtZW50cyBhcyBhbnlcbiAgICAgICAgKVxuICAgICAgfSxcbiAgICB9LFxuICAgIGZvckVhY2g6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JFYWNoKCkge1xuICAgICAgICBjb25zdCBleHByZXNzaW9uID0gJ2BoZWFkZXJzKCkuZm9yRWFjaCguLi4pYCdcbiAgICAgICAgc3luY0lPRGV2KHJvdXRlLCBleHByZXNzaW9uKVxuICAgICAgICByZXR1cm4gdW5kZXJseWluZ0hlYWRlcnMuZm9yRWFjaC5hcHBseShcbiAgICAgICAgICB1bmRlcmx5aW5nSGVhZGVycyxcbiAgICAgICAgICBhcmd1bWVudHMgYXMgYW55XG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgfSxcbiAgICBrZXlzOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24ga2V5cygpIHtcbiAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9ICdgaGVhZGVycygpLmtleXMoKWAnXG4gICAgICAgIHN5bmNJT0Rldihyb3V0ZSwgZXhwcmVzc2lvbilcbiAgICAgICAgcmV0dXJuIHVuZGVybHlpbmdIZWFkZXJzLmtleXMuYXBwbHkodW5kZXJseWluZ0hlYWRlcnMsIGFyZ3VtZW50cyBhcyBhbnkpXG4gICAgICB9LFxuICAgIH0sXG4gICAgdmFsdWVzOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWVzKCkge1xuICAgICAgICBjb25zdCBleHByZXNzaW9uID0gJ2BoZWFkZXJzKCkudmFsdWVzKClgJ1xuICAgICAgICBzeW5jSU9EZXYocm91dGUsIGV4cHJlc3Npb24pXG4gICAgICAgIHJldHVybiB1bmRlcmx5aW5nSGVhZGVycy52YWx1ZXMuYXBwbHkoXG4gICAgICAgICAgdW5kZXJseWluZ0hlYWRlcnMsXG4gICAgICAgICAgYXJndW1lbnRzIGFzIGFueVxuICAgICAgICApXG4gICAgICB9LFxuICAgIH0sXG4gICAgZW50cmllczoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVudHJpZXMoKSB7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSAnYGhlYWRlcnMoKS5lbnRyaWVzKClgJ1xuICAgICAgICBzeW5jSU9EZXYocm91dGUsIGV4cHJlc3Npb24pXG4gICAgICAgIHJldHVybiB1bmRlcmx5aW5nSGVhZGVycy5lbnRyaWVzLmFwcGx5KFxuICAgICAgICAgIHVuZGVybHlpbmdIZWFkZXJzLFxuICAgICAgICAgIGFyZ3VtZW50cyBhcyBhbnlcbiAgICAgICAgKVxuICAgICAgfSxcbiAgICB9LFxuICAgIFtTeW1ib2wuaXRlcmF0b3JdOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBleHByZXNzaW9uID0gJ2AuLi5oZWFkZXJzKClgIG9yIHNpbWlsYXIgaXRlcmF0aW9uJ1xuICAgICAgICBzeW5jSU9EZXYocm91dGUsIGV4cHJlc3Npb24pXG4gICAgICAgIHJldHVybiB1bmRlcmx5aW5nSGVhZGVyc1tTeW1ib2wuaXRlcmF0b3JdLmFwcGx5KFxuICAgICAgICAgIHVuZGVybHlpbmdIZWFkZXJzLFxuICAgICAgICAgIGFyZ3VtZW50cyBhcyBhbnlcbiAgICAgICAgKVxuICAgICAgfSxcbiAgICB9LFxuICB9IHNhdGlzZmllcyBIZWFkZXJzRXh0ZW5zaW9ucylcblxuICByZXR1cm4gcHJvbWlzZVxufVxuXG4vLyBTaW1pbGFyIHRvIGBtYWtlVW50cmFja2VkRXhvdGljSGVhZGVyc1dpdGhEZXZXYXJuaW5nc2AsIGJ1dCBqdXN0IGxvZ2dpbmcgdGhlXG4vLyBzeW5jIGFjY2VzcyB3aXRob3V0IGFjdHVhbGx5IGRlZmluaW5nIHRoZSBoZWFkZXJzIHByb3BlcnRpZXMgb24gdGhlIHByb21pc2UuXG5mdW5jdGlvbiBtYWtlVW50cmFja2VkSGVhZGVyc1dpdGhEZXZXYXJuaW5ncyhcbiAgdW5kZXJseWluZ0hlYWRlcnM6IFJlYWRvbmx5SGVhZGVycyxcbiAgcm91dGU/OiBzdHJpbmdcbik6IFByb21pc2U8UmVhZG9ubHlIZWFkZXJzPiB7XG4gIGNvbnN0IGNhY2hlZEhlYWRlcnMgPSBDYWNoZWRIZWFkZXJzLmdldCh1bmRlcmx5aW5nSGVhZGVycylcbiAgaWYgKGNhY2hlZEhlYWRlcnMpIHtcbiAgICByZXR1cm4gY2FjaGVkSGVhZGVyc1xuICB9XG5cbiAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlPFJlYWRvbmx5SGVhZGVycz4oKHJlc29sdmUpID0+XG4gICAgc2NoZWR1bGVJbW1lZGlhdGUoKCkgPT4gcmVzb2x2ZSh1bmRlcmx5aW5nSGVhZGVycykpXG4gIClcblxuICBjb25zdCBwcm94aWVkUHJvbWlzZSA9IG5ldyBQcm94eShwcm9taXNlLCB7XG4gICAgZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICAgIHN3aXRjaCAocHJvcCkge1xuICAgICAgICBjYXNlIFN5bWJvbC5pdGVyYXRvcjoge1xuICAgICAgICAgIHdhcm5Gb3JTeW5jQWNjZXNzKHJvdXRlLCAnYC4uLmhlYWRlcnMoKWAgb3Igc2ltaWxhciBpdGVyYXRpb24nKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnYXBwZW5kJzpcbiAgICAgICAgY2FzZSAnZGVsZXRlJzpcbiAgICAgICAgY2FzZSAnZ2V0JzpcbiAgICAgICAgY2FzZSAnaGFzJzpcbiAgICAgICAgY2FzZSAnc2V0JzpcbiAgICAgICAgY2FzZSAnZ2V0U2V0Q29va2llJzpcbiAgICAgICAgY2FzZSAnZm9yRWFjaCc6XG4gICAgICAgIGNhc2UgJ2tleXMnOlxuICAgICAgICBjYXNlICd2YWx1ZXMnOlxuICAgICAgICBjYXNlICdlbnRyaWVzJzoge1xuICAgICAgICAgIHdhcm5Gb3JTeW5jQWNjZXNzKHJvdXRlLCBgXFxgaGVhZGVycygpLiR7cHJvcH1cXGBgKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIC8vIFdlIG9ubHkgd2FybiBmb3Igd2VsbC1kZWZpbmVkIHByb3BlcnRpZXMgb2YgdGhlIGhlYWRlcnMgb2JqZWN0LlxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBSZWZsZWN0QWRhcHRlci5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcilcbiAgICB9LFxuICB9KVxuXG4gIENhY2hlZEhlYWRlcnMuc2V0KHVuZGVybHlpbmdIZWFkZXJzLCBwcm94aWVkUHJvbWlzZSlcblxuICByZXR1cm4gcHJveGllZFByb21pc2Vcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVOYW1lQXJnKGFyZzogdW5rbm93bikge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgPyBgJyR7YXJnfSdgIDogJy4uLidcbn1cblxuZnVuY3Rpb24gc3luY0lPRGV2KHJvdXRlOiBzdHJpbmcgfCB1bmRlZmluZWQsIGV4cHJlc3Npb246IHN0cmluZykge1xuICBjb25zdCB3b3JrVW5pdFN0b3JlID0gd29ya1VuaXRBc3luY1N0b3JhZ2UuZ2V0U3RvcmUoKVxuICBpZiAoXG4gICAgd29ya1VuaXRTdG9yZSAmJlxuICAgIHdvcmtVbml0U3RvcmUudHlwZSA9PT0gJ3JlcXVlc3QnICYmXG4gICAgd29ya1VuaXRTdG9yZS5wcmVyZW5kZXJQaGFzZSA9PT0gdHJ1ZVxuICApIHtcbiAgICAvLyBXaGVuIHdlJ3JlIHJlbmRlcmluZyBkeW5hbWljYWxseSBpbiBkZXYgd2UgbmVlZCB0byBhZHZhbmNlIG91dCBvZiB0aGVcbiAgICAvLyBQcmVyZW5kZXIgZW52aXJvbm1lbnQgd2hlbiB3ZSByZWFkIFJlcXVlc3QgZGF0YSBzeW5jaHJvbm91c2x5XG4gICAgY29uc3QgcmVxdWVzdFN0b3JlID0gd29ya1VuaXRTdG9yZVxuICAgIHRyYWNrU3luY2hyb25vdXNSZXF1ZXN0RGF0YUFjY2Vzc0luRGV2KHJlcXVlc3RTdG9yZSlcbiAgfVxuICAvLyBJbiBhbGwgY2FzZXMgd2Ugd2FybiBub3JtYWxseVxuICB3YXJuRm9yU3luY0FjY2Vzcyhyb3V0ZSwgZXhwcmVzc2lvbilcbn1cblxuY29uc3Qgd2FybkZvclN5bmNBY2Nlc3MgPSBjcmVhdGVEZWR1cGVkQnlDYWxsc2l0ZVNlcnZlckVycm9yTG9nZ2VyRGV2KFxuICBjcmVhdGVIZWFkZXJzQWNjZXNzRXJyb3JcbilcblxuZnVuY3Rpb24gY3JlYXRlSGVhZGVyc0FjY2Vzc0Vycm9yKFxuICByb3V0ZTogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICBleHByZXNzaW9uOiBzdHJpbmdcbikge1xuICBjb25zdCBwcmVmaXggPSByb3V0ZSA/IGBSb3V0ZSBcIiR7cm91dGV9XCIgYCA6ICdUaGlzIHJvdXRlICdcbiAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICBgJHtwcmVmaXh9dXNlZCAke2V4cHJlc3Npb259LiBgICtcbiAgICAgIGBcXGBoZWFkZXJzKClcXGAgc2hvdWxkIGJlIGF3YWl0ZWQgYmVmb3JlIHVzaW5nIGl0cyB2YWx1ZS4gYCArXG4gICAgICBgTGVhcm4gbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvc3luYy1keW5hbWljLWFwaXNgXG4gIClcbn1cblxudHlwZSBIZWFkZXJzRXh0ZW5zaW9ucyA9IHtcbiAgW0sgaW4ga2V5b2YgUmVhZG9ubHlIZWFkZXJzXTogdW5rbm93blxufVxuIl0sIm5hbWVzIjpbImhlYWRlcnMiLCJ3b3JrU3RvcmUiLCJ3b3JrQXN5bmNTdG9yYWdlIiwiZ2V0U3RvcmUiLCJ3b3JrVW5pdFN0b3JlIiwid29ya1VuaXRBc3luY1N0b3JhZ2UiLCJwaGFzZSIsImlzUmVxdWVzdEFQSUNhbGxhYmxlSW5zaWRlQWZ0ZXIiLCJFcnJvciIsInJvdXRlIiwiZm9yY2VTdGF0aWMiLCJ1bmRlcmx5aW5nSGVhZGVycyIsIkhlYWRlcnNBZGFwdGVyIiwic2VhbCIsIkhlYWRlcnMiLCJtYWtlVW50cmFja2VkRXhvdGljSGVhZGVycyIsInR5cGUiLCJkeW5hbWljU2hvdWxkRXJyb3IiLCJTdGF0aWNHZW5CYWlsb3V0RXJyb3IiLCJtYWtlSGFuZ2luZ0hlYWRlcnMiLCJleHBvcnROYW1lIiwiSW52YXJpYW50RXJyb3IiLCJwb3N0cG9uZVdpdGhUcmFja2luZyIsImR5bmFtaWNUcmFja2luZyIsInRocm93VG9JbnRlcnJ1cHRTdGF0aWNHZW5lcmF0aW9uIiwidHJhY2tEeW5hbWljRGF0YUluRHluYW1pY1JlbmRlciIsInJlcXVlc3RTdG9yZSIsImdldEV4cGVjdGVkUmVxdWVzdFN0b3JlIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiaXNQcmVmZXRjaFJlcXVlc3QiLCJfX05FWFRfRFlOQU1JQ19JTyIsIm1ha2VVbnRyYWNrZWRIZWFkZXJzV2l0aERldldhcm5pbmdzIiwibWFrZVVudHJhY2tlZEV4b3RpY0hlYWRlcnNXaXRoRGV2V2FybmluZ3MiLCJDYWNoZWRIZWFkZXJzIiwiV2Vha01hcCIsInByZXJlbmRlclN0b3JlIiwiY2FjaGVkSGVhZGVycyIsImdldCIsInByb21pc2UiLCJtYWtlSGFuZ2luZ1Byb21pc2UiLCJyZW5kZXJTaWduYWwiLCJzZXQiLCJQcm9taXNlIiwicmVzb2x2ZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnRpZXMiLCJhcHBlbmQiLCJ2YWx1ZSIsImJpbmQiLCJkZWxldGUiLCJoYXMiLCJnZXRTZXRDb29raWUiLCJmb3JFYWNoIiwia2V5cyIsInZhbHVlcyIsImVudHJpZXMiLCJTeW1ib2wiLCJpdGVyYXRvciIsInNjaGVkdWxlSW1tZWRpYXRlIiwiZXhwcmVzc2lvbiIsImRlc2NyaWJlTmFtZUFyZyIsImFyZ3VtZW50cyIsInN5bmNJT0RldiIsImFwcGx5IiwiX2RlbGV0ZSIsInByb3hpZWRQcm9taXNlIiwiUHJveHkiLCJ0YXJnZXQiLCJwcm9wIiwicmVjZWl2ZXIiLCJ3YXJuRm9yU3luY0FjY2VzcyIsIlJlZmxlY3RBZGFwdGVyIiwiYXJnIiwicHJlcmVuZGVyUGhhc2UiLCJ0cmFja1N5bmNocm9ub3VzUmVxdWVzdERhdGFBY2Nlc3NJbkRldiIsImNyZWF0ZURlZHVwZWRCeUNhbGxzaXRlU2VydmVyRXJyb3JMb2dnZXJEZXYiLCJjcmVhdGVIZWFkZXJzQWNjZXNzRXJyb3IiLCJwcmVmaXgiXSwibWFwcGluZ3MiOiI7OzsrQkF3RGdCQSxXQUFBQTs7O2VBQUFBOzs7eUJBckRUOzBDQUMwQjs4Q0FDTztrQ0FVakM7eUNBQytCO3VDQUNIOzBEQUN5QjsyQkFDMUI7dUJBQ2M7Z0NBQ2pCO3lCQUNBO0FBa0N4QixTQUFTQTtJQUNkLE1BQU1DLFlBQVlDLDBCQUFBQSxnQkFBZ0IsQ0FBQ0MsUUFBUTtJQUMzQyxNQUFNQyxnQkFBZ0JDLDhCQUFBQSxvQkFBb0IsQ0FBQ0YsUUFBUTtJQUVuRCxJQUFJRixXQUFXO1FBQ2IsSUFDRUcsaUJBQ0FBLGNBQWNFLEtBQUssS0FBSyxXQUN4QixDQUFDQyxDQUFBQSxHQUFBQSxPQUFBQSwrQkFBK0IsS0FDaEM7WUFDQSxNQUFNLE9BQUEsY0FFTCxDQUZLLElBQUlDLE1BQ1IsQ0FBQyxNQUFNLEVBQUVQLFVBQVVRLEtBQUssQ0FBQyx5T0FBeU8sQ0FBQyxHQUQvUCxxQkFBQTt1QkFBQTs0QkFBQTs4QkFBQTtZQUVOO1FBQ0Y7UUFFQSxJQUFJUixVQUFVUyxXQUFXLEVBQUU7WUFDekIscUZBQXFGO1lBQ3JGLGtDQUFrQztZQUNsQyxNQUFNQyxvQkFBb0JDLFNBQUFBLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDLElBQUlDLFFBQVEsQ0FBQztZQUMzRCxPQUFPQywyQkFBMkJKO1FBQ3BDO1FBRUEsSUFBSVAsZUFBZTtZQUNqQixJQUFJQSxj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VyxDQUFDLENBQUMsRUFBRUEsSUFBSSxDQUFDLENBQUMsR0FBRztBQUNoRDtBQUVBLFNBQVNWLFVBQVV2RCxLQUF5QixFQUFFb0QsVUFBa0I7SUFDOUQsTUFBTXpELGdCQUFnQkMsOEJBQUFBLG9CQUFvQixDQUFDRixRQUFRO0lBQ25ELElBQ0VDLGlCQUNBQSxjQUFjWSxJQUFJLEtBQUssYUFDdkJaLGNBQWN1RSxjQUFjLEtBQUssTUFDakM7UUFDQSx3RUFBd0U7UUFDeEUsZ0VBQWdFO1FBQ2hFLE1BQU1qRCxlQUFldEI7UUFDckJ3RSxDQUFBQSxHQUFBQSxrQkFBQUEsc0NBQXNDLEVBQUNsRDtJQUN6QztJQUNBLGdDQUFnQztJQUNoQzhDLGtCQUFrQi9ELE9BQU9vRDtBQUMzQjtBQUVBLE1BQU1XLG9CQUFvQkssQ0FBQUEsR0FBQUEsMENBQUFBLDJDQUEyQyxFQUNuRUM7QUFHRixTQUFTQSx5QkFDUHJFLEtBQXlCLEVBQ3pCb0QsVUFBa0I7SUFFbEIsTUFBTWtCLFNBQVN0RSxRQUFRLENBQUMsT0FBTyxFQUFFQSxNQUFNLEVBQUUsQ0FBQyxHQUFHO0lBQzdDLE9BQU8sT0FBQSxjQUlOLENBSk0sSUFBSUQsTUFDVCxHQUFHdUUsT0FBTyxLQUFLLEVBQUVsQixXQUFXLEVBQUUsQ0FBQyxHQUM3QixDQUFDLHdEQUF3RCxDQUFDLEdBQzFELENBQUMsOERBQThELENBQUMsR0FIN0QscUJBQUE7ZUFBQTtvQkFBQTtzQkFBQTtJQUlQO0FBQ0YiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTcxOCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9zZXJ2ZXIvcmVxdWVzdC9kcmFmdC1tb2RlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIGdldERyYWZ0TW9kZVByb3ZpZGVyRm9yQ2FjaGVTY29wZSxcbiAgdGhyb3dGb3JNaXNzaW5nUmVxdWVzdFN0b3JlLFxufSBmcm9tICcuLi9hcHAtcmVuZGVyL3dvcmstdW5pdC1hc3luYy1zdG9yYWdlLmV4dGVybmFsJ1xuXG5pbXBvcnQgdHlwZSB7IERyYWZ0TW9kZVByb3ZpZGVyIH0gZnJvbSAnLi4vYXN5bmMtc3RvcmFnZS9kcmFmdC1tb2RlLXByb3ZpZGVyJ1xuXG5pbXBvcnQge1xuICB3b3JrQXN5bmNTdG9yYWdlLFxuICB0eXBlIFdvcmtTdG9yZSxcbn0gZnJvbSAnLi4vYXBwLXJlbmRlci93b3JrLWFzeW5jLXN0b3JhZ2UuZXh0ZXJuYWwnXG5pbXBvcnQgeyB3b3JrVW5pdEFzeW5jU3RvcmFnZSB9IGZyb20gJy4uL2FwcC1yZW5kZXIvd29yay11bml0LWFzeW5jLXN0b3JhZ2UuZXh0ZXJuYWwnXG5pbXBvcnQge1xuICBhYm9ydEFuZFRocm93T25TeW5jaHJvbm91c1JlcXVlc3REYXRhQWNjZXNzLFxuICBwb3N0cG9uZVdpdGhUcmFja2luZyxcbiAgdHJhY2tTeW5jaHJvbm91c1JlcXVlc3REYXRhQWNjZXNzSW5EZXYsXG59IGZyb20gJy4uL2FwcC1yZW5kZXIvZHluYW1pYy1yZW5kZXJpbmcnXG5pbXBvcnQgeyBjcmVhdGVEZWR1cGVkQnlDYWxsc2l0ZVNlcnZlckVycm9yTG9nZ2VyRGV2IH0gZnJvbSAnLi4vY3JlYXRlLWRlZHVwZWQtYnktY2FsbHNpdGUtc2VydmVyLWVycm9yLWxvZ2dlcidcbmltcG9ydCB7IFN0YXRpY0dlbkJhaWxvdXRFcnJvciB9IGZyb20gJy4uLy4uL2NsaWVudC9jb21wb25lbnRzL3N0YXRpYy1nZW5lcmF0aW9uLWJhaWxvdXQnXG5pbXBvcnQgeyBEeW5hbWljU2VydmVyRXJyb3IgfSBmcm9tICcuLi8uLi9jbGllbnQvY29tcG9uZW50cy9ob29rcy1zZXJ2ZXItY29udGV4dCdcbmltcG9ydCB7IEludmFyaWFudEVycm9yIH0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi9pbnZhcmlhbnQtZXJyb3InXG5pbXBvcnQgeyBSZWZsZWN0QWRhcHRlciB9IGZyb20gJy4uL3dlYi9zcGVjLWV4dGVuc2lvbi9hZGFwdGVycy9yZWZsZWN0J1xuXG4vKipcbiAqIEluIHRoaXMgdmVyc2lvbiBvZiBOZXh0LmpzIGBkcmFmdE1vZGUoKWAgcmV0dXJucyBhIFByb21pc2UgaG93ZXZlciB5b3UgY2FuIHN0aWxsIHJlZmVyZW5jZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgdW5kZXJseWluZyBkcmFmdE1vZGUgb2JqZWN0XG4gKiBzeW5jaHJvbm91c2x5IHRvIGZhY2lsaXRhdGUgbWlncmF0aW9uLiBUaGUgYFVuc2FmZVVud3JhcHBlZERyYWZ0TW9kZWAgdHlwZSBpcyBhZGRlZCB0byB5b3VyIGNvZGUgYnkgYSBjb2RlbW9kIHRoYXQgYXR0ZW1wdHMgdG8gYXV0b21hdGljYWxseVxuICogdXBkYXRlcyBjYWxsc2l0ZXMgdG8gcmVmbGVjdCB0aGUgbmV3IFByb21pc2UgcmV0dXJuIHR5cGUuIFRoZXJlIGFyZSBzb21lIGNhc2VzIHdoZXJlIGBkcmFmdE1vZGUoKWAgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkLCBuYW1lbHlcbiAqIHdoZW4gaXQgaXMgdXNlZCBpbnNpZGUgYSBzeW5jaHJvbm91cyBmdW5jdGlvbiBhbmQgd2UgY2FuJ3QgYmUgc3VyZSB0aGUgZnVuY3Rpb24gY2FuIGJlIG1hZGUgYXN5bmMgYXV0b21hdGljYWxseS4gSW4gdGhlc2UgY2FzZXMgd2UgYWRkIGFuXG4gKiBleHBsaWNpdCB0eXBlIGNhc2UgdG8gYFVuc2FmZVVud3JhcHBlZERyYWZ0TW9kZWAgdG8gZW5hYmxlIHR5cGVzY3JpcHQgdG8gYWxsb3cgZm9yIHRoZSBzeW5jaHJvbm91cyB1c2FnZSBvbmx5IHdoZXJlIGl0IGlzIGFjdHVhbGx5IG5lY2Vzc2FyeS5cbiAqXG4gKiBZb3Ugc2hvdWxkIHNob3VsZCB1cGRhdGUgdGhlc2UgY2FsbHNpdGVzIHRvIGVpdGhlciBiZSBhc3luYyBmdW5jdGlvbnMgd2hlcmUgdGhlIGBkcmFmdE1vZGUoKWAgdmFsdWUgY2FuIGJlIGF3YWl0ZWQgb3IgeW91IHNob3VsZCBjYWxsIGBkcmFmdE1vZGUoKWBcbiAqIGZyb20gb3V0c2lkZSBhbmQgYXdhaXQgdGhlIHJldHVybiB2YWx1ZSBiZWZvcmUgcGFzc2luZyBpdCBpbnRvIHRoaXMgZnVuY3Rpb24uXG4gKlxuICogWW91IGNhbiBmaW5kIGluc3RhbmNlcyB0aGF0IHJlcXVpcmUgbWFudWFsIG1pZ3JhdGlvbiBieSBzZWFyY2hpbmcgZm9yIGBVbnNhZmVVbndyYXBwZWREcmFmdE1vZGVgIGluIHlvdXIgY29kZWJhc2Ugb3IgYnkgc2VhcmNoIGZvciBhIGNvbW1lbnQgdGhhdFxuICogc3RhcnRzIHdpdGggYEBuZXh0LWNvZGVtb2QtZXJyb3JgLlxuICpcbiAqIEluIGEgZnV0dXJlIHZlcnNpb24gb2YgTmV4dC5qcyBgZHJhZnRNb2RlKClgIHdpbGwgb25seSByZXR1cm4gYSBQcm9taXNlIGFuZCB5b3Ugd2lsbCBub3QgYmUgYWJsZSB0byBhY2Nlc3MgdGhlIHVuZGVybHlpbmcgZHJhZnRNb2RlIG9iamVjdCBkaXJlY3RseVxuICogd2l0aG91dCBhd2FpdGluZyB0aGUgcmV0dXJuIHZhbHVlIGZpcnN0LiBXaGVuIHRoaXMgY2hhbmdlIGhhcHBlbnMgdGhlIHR5cGUgYFVuc2FmZVVud3JhcHBlZERyYWZ0TW9kZWAgd2lsbCBiZSB1cGRhdGVkIHRvIHJlZmxlY3QgdGhhdCBpcyBpdCBubyBsb25nZXJcbiAqIHVzYWJsZS5cbiAqXG4gKiBUaGlzIHR5cGUgaXMgbWFya2VkIGRlcHJlY2F0ZWQgdG8gaGVscCBpZGVudGlmeSBpdCBhcyB0YXJnZXQgZm9yIHJlZmFjdG9yaW5nIGF3YXkuXG4gKlxuICogQGRlcHJlY2F0ZWRcbiAqL1xuZXhwb3J0IHR5cGUgVW5zYWZlVW53cmFwcGVkRHJhZnRNb2RlID0gRHJhZnRNb2RlXG5cbmV4cG9ydCBmdW5jdGlvbiBkcmFmdE1vZGUoKTogUHJvbWlzZTxEcmFmdE1vZGU+IHtcbiAgY29uc3QgY2FsbGluZ0V4cHJlc3Npb24gPSAnZHJhZnRNb2RlJ1xuICBjb25zdCB3b3JrU3RvcmUgPSB3b3JrQXN5bmNTdG9yYWdlLmdldFN0b3JlKClcbiAgY29uc3Qgd29ya1VuaXRTdG9yZSA9IHdvcmtVbml0QXN5bmNTdG9yYWdlLmdldFN0b3JlKClcblxuICBpZiAoIXdvcmtTdG9yZSB8fCAhd29ya1VuaXRTdG9yZSkge1xuICAgIHRocm93Rm9yTWlzc2luZ1JlcXVlc3RTdG9yZShjYWxsaW5nRXhwcmVzc2lvbilcbiAgfVxuXG4gIHN3aXRjaCAod29ya1VuaXRTdG9yZS50eXBlKSB7XG4gICAgY2FzZSAncmVxdWVzdCc6XG4gICAgICByZXR1cm4gY3JlYXRlT3JHZXRDYWNoZWREcmFmdE1vZGUod29ya1VuaXRTdG9yZS5kcmFmdE1vZGUsIHdvcmtTdG9yZSlcblxuICAgIGNhc2UgJ2NhY2hlJzpcbiAgICBjYXNlICd1bnN0YWJsZS1jYWNoZSc6XG4gICAgICAvLyBJbnNpZGUgb2YgYFwidXNlIGNhY2hlXCJgIG9yIGB1bnN0YWJsZV9jYWNoZWAsIGRyYWZ0IG1vZGUgaXMgYXZhaWxhYmxlIGlmXG4gICAgICAvLyB0aGUgb3V0bW9zdCB3b3JrIHVuaXQgc3RvcmUgaXMgYSByZXF1ZXN0IHN0b3JlLCBhbmQgaWYgZHJhZnQgbW9kZSBpc1xuICAgICAgLy8gZW5hYmxlZC5cbiAgICAgIGNvbnN0IGRyYWZ0TW9kZVByb3ZpZGVyID0gZ2V0RHJhZnRNb2RlUHJvdmlkZXJGb3JDYWNoZVNjb3BlKFxuICAgICAgICB3b3JrU3RvcmUsXG4gICAgICAgIHdvcmtVbml0U3RvcmVcbiAgICAgIClcblxuICAgICAgaWYgKGRyYWZ0TW9kZVByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVPckdldENhY2hlZERyYWZ0TW9kZShkcmFmdE1vZGVQcm92aWRlciwgd29ya1N0b3JlKVxuICAgICAgfVxuXG4gICAgLy8gT3RoZXJ3aXNlLCB3ZSBmYWxsIHRocm91Z2ggdG8gcHJvdmlkaW5nIGFuIGVtcHR5IGRyYWZ0IG1vZGUuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG4gICAgY2FzZSAncHJlcmVuZGVyJzpcbiAgICBjYXNlICdwcmVyZW5kZXItY2xpZW50JzpcbiAgICBjYXNlICdwcmVyZW5kZXItcHByJzpcbiAgICBjYXNlICdwcmVyZW5kZXItbGVnYWN5JzpcbiAgICAgIC8vIFJldHVybiBlbXB0eSBkcmFmdCBtb2RlXG4gICAgICByZXR1cm4gY3JlYXRlT3JHZXRDYWNoZWREcmFmdE1vZGUobnVsbCwgd29ya1N0b3JlKVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2s6IG5ldmVyID0gd29ya1VuaXRTdG9yZVxuICAgICAgcmV0dXJuIF9leGhhdXN0aXZlQ2hlY2tcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVPckdldENhY2hlZERyYWZ0TW9kZShcbiAgZHJhZnRNb2RlUHJvdmlkZXI6IERyYWZ0TW9kZVByb3ZpZGVyIHwgbnVsbCxcbiAgd29ya1N0b3JlOiBXb3JrU3RvcmUgfCB1bmRlZmluZWRcbik6IFByb21pc2U8RHJhZnRNb2RlPiB7XG4gIGNvbnN0IGNhY2hlS2V5ID0gZHJhZnRNb2RlUHJvdmlkZXIgPz8gTnVsbERyYWZ0TW9kZVxuICBjb25zdCBjYWNoZWREcmFmdE1vZGUgPSBDYWNoZWREcmFmdE1vZGVzLmdldChjYWNoZUtleSlcblxuICBpZiAoY2FjaGVkRHJhZnRNb2RlKSB7XG4gICAgcmV0dXJuIGNhY2hlZERyYWZ0TW9kZVxuICB9XG5cbiAgbGV0IHByb21pc2U6IFByb21pc2U8RHJhZnRNb2RlPlxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAhd29ya1N0b3JlPy5pc1ByZWZldGNoUmVxdWVzdCkge1xuICAgIGNvbnN0IHJvdXRlID0gd29ya1N0b3JlPy5yb3V0ZVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9EWU5BTUlDX0lPKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRHJhZnRNb2RlV2l0aERldldhcm5pbmdzKGRyYWZ0TW9kZVByb3ZpZGVyLCByb3V0ZSlcbiAgICB9XG5cbiAgICBwcm9taXNlID0gY3JlYXRlRXhvdGljRHJhZnRNb2RlV2l0aERldldhcm5pbmdzKGRyYWZ0TW9kZVByb3ZpZGVyLCByb3V0ZSlcbiAgfSBlbHNlIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0RZTkFNSUNfSU8pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IERyYWZ0TW9kZShkcmFmdE1vZGVQcm92aWRlcikpXG4gICAgfVxuXG4gICAgcHJvbWlzZSA9IGNyZWF0ZUV4b3RpY0RyYWZ0TW9kZShkcmFmdE1vZGVQcm92aWRlcilcbiAgfVxuXG4gIENhY2hlZERyYWZ0TW9kZXMuc2V0KGNhY2hlS2V5LCBwcm9taXNlKVxuXG4gIHJldHVybiBwcm9taXNlXG59XG5cbmludGVyZmFjZSBDYWNoZUxpZmV0aW1lIHt9XG5jb25zdCBOdWxsRHJhZnRNb2RlID0ge31cbmNvbnN0IENhY2hlZERyYWZ0TW9kZXMgPSBuZXcgV2Vha01hcDxDYWNoZUxpZmV0aW1lLCBQcm9taXNlPERyYWZ0TW9kZT4+KClcblxuZnVuY3Rpb24gY3JlYXRlRXhvdGljRHJhZnRNb2RlKFxuICB1bmRlcmx5aW5nUHJvdmlkZXI6IG51bGwgfCBEcmFmdE1vZGVQcm92aWRlclxuKTogUHJvbWlzZTxEcmFmdE1vZGU+IHtcbiAgY29uc3QgaW5zdGFuY2UgPSBuZXcgRHJhZnRNb2RlKHVuZGVybHlpbmdQcm92aWRlcilcbiAgY29uc3QgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShpbnN0YW5jZSlcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgJ2lzRW5hYmxlZCcsIHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gaW5zdGFuY2UuaXNFbmFibGVkXG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgfSlcbiAgOyhwcm9taXNlIGFzIGFueSkuZW5hYmxlID0gaW5zdGFuY2UuZW5hYmxlLmJpbmQoaW5zdGFuY2UpXG4gIDsocHJvbWlzZSBhcyBhbnkpLmRpc2FibGUgPSBpbnN0YW5jZS5kaXNhYmxlLmJpbmQoaW5zdGFuY2UpXG5cbiAgcmV0dXJuIHByb21pc2Vcbn1cblxuZnVuY3Rpb24gY3JlYXRlRXhvdGljRHJhZnRNb2RlV2l0aERldldhcm5pbmdzKFxuICB1bmRlcmx5aW5nUHJvdmlkZXI6IG51bGwgfCBEcmFmdE1vZGVQcm92aWRlcixcbiAgcm91dGU6IHVuZGVmaW5lZCB8IHN0cmluZ1xuKTogUHJvbWlzZTxEcmFmdE1vZGU+IHtcbiAgY29uc3QgaW5zdGFuY2UgPSBuZXcgRHJhZnRNb2RlKHVuZGVybHlpbmdQcm92aWRlcilcbiAgY29uc3QgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShpbnN0YW5jZSlcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgJ2lzRW5hYmxlZCcsIHtcbiAgICBnZXQoKSB7XG4gICAgICBjb25zdCBleHByZXNzaW9uID0gJ2BkcmFmdE1vZGUoKS5pc0VuYWJsZWRgJ1xuICAgICAgc3luY0lPRGV2KHJvdXRlLCBleHByZXNzaW9uKVxuICAgICAgcmV0dXJuIGluc3RhbmNlLmlzRW5hYmxlZFxuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gIH0pXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsICdlbmFibGUnLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSAnYGRyYWZ0TW9kZSgpLmVuYWJsZSgpYCdcbiAgICAgIHN5bmNJT0Rldihyb3V0ZSwgZXhwcmVzc2lvbilcbiAgICAgIHJldHVybiBpbnN0YW5jZS5lbmFibGUuYXBwbHkoaW5zdGFuY2UsIGFyZ3VtZW50cyBhcyBhbnkpXG4gICAgfSxcbiAgfSlcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgJ2Rpc2FibGUnLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSAnYGRyYWZ0TW9kZSgpLmRpc2FibGUoKWAnXG4gICAgICBzeW5jSU9EZXYocm91dGUsIGV4cHJlc3Npb24pXG4gICAgICByZXR1cm4gaW5zdGFuY2UuZGlzYWJsZS5hcHBseShpbnN0YW5jZSwgYXJndW1lbnRzIGFzIGFueSlcbiAgICB9LFxuICB9KVxuXG4gIHJldHVybiBwcm9taXNlXG59XG5cbi8vIFNpbWlsYXIgdG8gYGNyZWF0ZUV4b3RpY0RyYWZ0TW9kZVdpdGhEZXZXYXJuaW5nc2AsIGJ1dCBqdXN0IGxvZ2dpbmcgdGhlIHN5bmNcbi8vIGFjY2VzcyB3aXRob3V0IGFjdHVhbGx5IGRlZmluaW5nIHRoZSBkcmFmdE1vZGUgcHJvcGVydGllcyBvbiB0aGUgcHJvbWlzZS5cbmZ1bmN0aW9uIGNyZWF0ZURyYWZ0TW9kZVdpdGhEZXZXYXJuaW5ncyhcbiAgdW5kZXJseWluZ1Byb3ZpZGVyOiBudWxsIHwgRHJhZnRNb2RlUHJvdmlkZXIsXG4gIHJvdXRlOiB1bmRlZmluZWQgfCBzdHJpbmdcbik6IFByb21pc2U8RHJhZnRNb2RlPiB7XG4gIGNvbnN0IGluc3RhbmNlID0gbmV3IERyYWZ0TW9kZSh1bmRlcmx5aW5nUHJvdmlkZXIpXG4gIGNvbnN0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoaW5zdGFuY2UpXG5cbiAgY29uc3QgcHJveGllZFByb21pc2UgPSBuZXcgUHJveHkocHJvbWlzZSwge1xuICAgIGdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG4gICAgICBzd2l0Y2ggKHByb3ApIHtcbiAgICAgICAgY2FzZSAnaXNFbmFibGVkJzpcbiAgICAgICAgICB3YXJuRm9yU3luY0FjY2Vzcyhyb3V0ZSwgYFxcYGRyYWZ0TW9kZSgpLiR7cHJvcH1cXGBgKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ2VuYWJsZSc6XG4gICAgICAgIGNhc2UgJ2Rpc2FibGUnOiB7XG4gICAgICAgICAgd2FybkZvclN5bmNBY2Nlc3Mocm91dGUsIGBcXGBkcmFmdE1vZGUoKS4ke3Byb3B9KClcXGBgKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIC8vIFdlIG9ubHkgd2FybiBmb3Igd2VsbC1kZWZpbmVkIHByb3BlcnRpZXMgb2YgdGhlIGRyYWZ0TW9kZSBvYmplY3QuXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFJlZmxlY3RBZGFwdGVyLmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKVxuICAgIH0sXG4gIH0pXG5cbiAgcmV0dXJuIHByb3hpZWRQcm9taXNlXG59XG5cbmNsYXNzIERyYWZ0TW9kZSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWwgLSB0aGlzIGRlY2xhcmF0aW9uIGlzIHN0cmlwcGVkIHZpYSBgdHNjIC0tc3RyaXBJbnRlcm5hbGBcbiAgICovXG4gIHByaXZhdGUgcmVhZG9ubHkgX3Byb3ZpZGVyOiBudWxsIHwgRHJhZnRNb2RlUHJvdmlkZXJcblxuICBjb25zdHJ1Y3Rvcihwcm92aWRlcjogbnVsbCB8IERyYWZ0TW9kZVByb3ZpZGVyKSB7XG4gICAgdGhpcy5fcHJvdmlkZXIgPSBwcm92aWRlclxuICB9XG4gIGdldCBpc0VuYWJsZWQoKSB7XG4gICAgaWYgKHRoaXMuX3Byb3ZpZGVyICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJvdmlkZXIuaXNFbmFibGVkXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHB1YmxpYyBlbmFibGUoKSB7XG4gICAgLy8gV2UgaGF2ZSBhIHN0b3JlIHdlIHdhbnQgdG8gdHJhY2sgZHluYW1pYyBkYXRhIGFjY2VzcyB0byBlbnN1cmUgd2VcbiAgICAvLyBkb24ndCBzdGF0aWNhbGx5IGdlbmVyYXRlIHJvdXRlcyB0aGF0IG1hbmlwdWxhdGUgZHJhZnQgbW9kZS5cbiAgICB0cmFja0R5bmFtaWNEcmFmdE1vZGUoJ2RyYWZ0TW9kZSgpLmVuYWJsZSgpJylcbiAgICBpZiAodGhpcy5fcHJvdmlkZXIgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuX3Byb3ZpZGVyLmVuYWJsZSgpXG4gICAgfVxuICB9XG4gIHB1YmxpYyBkaXNhYmxlKCkge1xuICAgIHRyYWNrRHluYW1pY0RyYWZ0TW9kZSgnZHJhZnRNb2RlKCkuZGlzYWJsZSgpJylcbiAgICBpZiAodGhpcy5fcHJvdmlkZXIgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuX3Byb3ZpZGVyLmRpc2FibGUoKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzeW5jSU9EZXYocm91dGU6IHN0cmluZyB8IHVuZGVmaW5lZCwgZXhwcmVzc2lvbjogc3RyaW5nKSB7XG4gIGNvbnN0IHdvcmtVbml0U3RvcmUgPSB3b3JrVW5pdEFzeW5jU3RvcmFnZS5nZXRTdG9yZSgpXG4gIGlmIChcbiAgICB3b3JrVW5pdFN0b3JlICYmXG4gICAgd29ya1VuaXRTdG9yZS50eXBlID09PSAncmVxdWVzdCcgJiZcbiAgICB3b3JrVW5pdFN0b3JlLnByZXJlbmRlclBoYXNlID09PSB0cnVlXG4gICkge1xuICAgIC8vIFdoZW4gd2UncmUgcmVuZGVyaW5nIGR5bmFtaWNhbGx5IGluIGRldiB3ZSBuZWVkIHRvIGFkdmFuY2Ugb3V0IG9mIHRoZVxuICAgIC8vIFByZXJlbmRlciBlbnZpcm9ubWVudCB3aGVuIHdlIHJlYWQgUmVxdWVzdCBkYXRhIHN5bmNocm9ub3VzbHlcbiAgICBjb25zdCByZXF1ZXN0U3RvcmUgPSB3b3JrVW5pdFN0b3JlXG4gICAgdHJhY2tTeW5jaHJvbm91c1JlcXVlc3REYXRhQWNjZXNzSW5EZXYocmVxdWVzdFN0b3JlKVxuICB9XG4gIC8vIEluIGFsbCBjYXNlcyB3ZSB3YXJuIG5vcm1hbGx5XG4gIHdhcm5Gb3JTeW5jQWNjZXNzKHJvdXRlLCBleHByZXNzaW9uKVxufVxuXG5jb25zdCB3YXJuRm9yU3luY0FjY2VzcyA9IGNyZWF0ZURlZHVwZWRCeUNhbGxzaXRlU2VydmVyRXJyb3JMb2dnZXJEZXYoXG4gIGNyZWF0ZURyYWZ0TW9kZUFjY2Vzc0Vycm9yXG4pXG5cbmZ1bmN0aW9uIGNyZWF0ZURyYWZ0TW9kZUFjY2Vzc0Vycm9yKFxuICByb3V0ZTogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICBleHByZXNzaW9uOiBzdHJpbmdcbikge1xuICBjb25zdCBwcmVmaXggPSByb3V0ZSA/IGBSb3V0ZSBcIiR7cm91dGV9XCIgYCA6ICdUaGlzIHJvdXRlICdcbiAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICBgJHtwcmVmaXh9dXNlZCAke2V4cHJlc3Npb259LiBgICtcbiAgICAgIGBcXGBkcmFmdE1vZGUoKVxcYCBzaG91bGQgYmUgYXdhaXRlZCBiZWZvcmUgdXNpbmcgaXRzIHZhbHVlLiBgICtcbiAgICAgIGBMZWFybiBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9zeW5jLWR5bmFtaWMtYXBpc2BcbiAgKVxufVxuXG5mdW5jdGlvbiB0cmFja0R5bmFtaWNEcmFmdE1vZGUoZXhwcmVzc2lvbjogc3RyaW5nKSB7XG4gIGNvbnN0IHN0b3JlID0gd29ya0FzeW5jU3RvcmFnZS5nZXRTdG9yZSgpXG4gIGNvbnN0IHdvcmtVbml0U3RvcmUgPSB3b3JrVW5pdEFzeW5jU3RvcmFnZS5nZXRTdG9yZSgpXG4gIGlmIChzdG9yZSkge1xuICAgIC8vIFdlIGhhdmUgYSBzdG9yZSB3ZSB3YW50IHRvIHRyYWNrIGR5bmFtaWMgZGF0YSBhY2Nlc3MgdG8gZW5zdXJlIHdlXG4gICAgLy8gZG9uJ3Qgc3RhdGljYWxseSBnZW5lcmF0ZSByb3V0ZXMgdGhhdCBtYW5pcHVsYXRlIGRyYWZ0IG1vZGUuXG4gICAgaWYgKHdvcmtVbml0U3RvcmUpIHtcbiAgICAgIGlmICh3b3JrVW5pdFN0b3JlLnR5cGUgPT09ICdjYWNoZScpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBSb3V0ZSAke3N0b3JlLnJvdXRlfSB1c2VkIFwiJHtleHByZXNzaW9ufVwiIGluc2lkZSBcInVzZSBjYWNoZVwiLiBUaGUgZW5hYmxlZCBzdGF0dXMgb2YgZHJhZnRNb2RlIGNhbiBiZSByZWFkIGluIGNhY2hlcyBidXQgeW91IG11c3Qgbm90IGVuYWJsZSBvciBkaXNhYmxlIGRyYWZ0TW9kZSBpbnNpZGUgYSBjYWNoZS4gU2VlIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LXJlcXVlc3QtaW4tdXNlLWNhY2hlYFxuICAgICAgICApXG4gICAgICB9IGVsc2UgaWYgKHdvcmtVbml0U3RvcmUudHlwZSA9PT0gJ3Vuc3RhYmxlLWNhY2hlJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFJvdXRlICR7c3RvcmUucm91dGV9IHVzZWQgXCIke2V4cHJlc3Npb259XCIgaW5zaWRlIGEgZnVuY3Rpb24gY2FjaGVkIHdpdGggXCJ1bnN0YWJsZV9jYWNoZSguLi4pXCIuIFRoZSBlbmFibGVkIHN0YXR1cyBvZiBkcmFmdE1vZGUgY2FuIGJlIHJlYWQgaW4gY2FjaGVzIGJ1dCB5b3UgbXVzdCBub3QgZW5hYmxlIG9yIGRpc2FibGUgZHJhZnRNb2RlIGluc2lkZSBhIGNhY2hlLiBTZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9hcGktcmVmZXJlbmNlL2Z1bmN0aW9ucy91bnN0YWJsZV9jYWNoZWBcbiAgICAgICAgKVxuICAgICAgfSBlbHNlIGlmICh3b3JrVW5pdFN0b3JlLnBoYXNlID09PSAnYWZ0ZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgUm91dGUgJHtzdG9yZS5yb3V0ZX0gdXNlZCBcIiR7ZXhwcmVzc2lvbn1cIiBpbnNpZGUgXFxgYWZ0ZXJcXGAuIFRoZSBlbmFibGVkIHN0YXR1cyBvZiBkcmFmdE1vZGUgY2FuIGJlIHJlYWQgaW5zaWRlIFxcYGFmdGVyXFxgIGJ1dCB5b3UgY2Fubm90IGVuYWJsZSBvciBkaXNhYmxlIGRyYWZ0TW9kZS4gU2VlIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYXBpLXJlZmVyZW5jZS9mdW5jdGlvbnMvYWZ0ZXJgXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3RvcmUuZHluYW1pY1Nob3VsZEVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgU3RhdGljR2VuQmFpbG91dEVycm9yKFxuICAgICAgICBgUm91dGUgJHtzdG9yZS5yb3V0ZX0gd2l0aCBcXGBkeW5hbWljID0gXCJlcnJvclwiXFxgIGNvdWxkbid0IGJlIHJlbmRlcmVkIHN0YXRpY2FsbHkgYmVjYXVzZSBpdCB1c2VkIFxcYCR7ZXhwcmVzc2lvbn1cXGAuIFNlZSBtb3JlIGluZm8gaGVyZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2J1aWxkaW5nLXlvdXItYXBwbGljYXRpb24vcmVuZGVyaW5nL3N0YXRpYy1hbmQtZHluYW1pYyNkeW5hbWljLXJlbmRlcmluZ2BcbiAgICAgIClcbiAgICB9XG5cbiAgICBpZiAod29ya1VuaXRTdG9yZSkge1xuICAgICAgc3dpdGNoICh3b3JrVW5pdFN0b3JlLnR5cGUpIHtcbiAgICAgICAgY2FzZSAncHJlcmVuZGVyJzpcbiAgICAgICAgICAvLyBkeW5hbWljSU8gUHJlcmVuZGVyXG4gICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgUm91dGUgJHtzdG9yZS5yb3V0ZX0gdXNlZCAke2V4cHJlc3Npb259IHdpdGhvdXQgZmlyc3QgY2FsbGluZyBcXGBhd2FpdCBjb25uZWN0aW9uKClcXGAuIFNlZSBtb3JlIGluZm8gaGVyZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbmV4dC1wcmVyZW5kZXItc3luYy1oZWFkZXJzYFxuICAgICAgICAgIClcbiAgICAgICAgICBhYm9ydEFuZFRocm93T25TeW5jaHJvbm91c1JlcXVlc3REYXRhQWNjZXNzKFxuICAgICAgICAgICAgc3RvcmUucm91dGUsXG4gICAgICAgICAgICBleHByZXNzaW9uLFxuICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICB3b3JrVW5pdFN0b3JlXG4gICAgICAgICAgKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ3ByZXJlbmRlci1jbGllbnQnOlxuICAgICAgICAgIGNvbnN0IGV4cG9ydE5hbWUgPSAnYGRyYWZ0TW9kZWAnXG4gICAgICAgICAgdGhyb3cgbmV3IEludmFyaWFudEVycm9yKFxuICAgICAgICAgICAgYCR7ZXhwb3J0TmFtZX0gbXVzdCBub3QgYmUgdXNlZCB3aXRoaW4gYSBjbGllbnQgY29tcG9uZW50LiBOZXh0LmpzIHNob3VsZCBiZSBwcmV2ZW50aW5nICR7ZXhwb3J0TmFtZX0gZnJvbSBiZWluZyBpbmNsdWRlZCBpbiBjbGllbnQgY29tcG9uZW50cyBzdGF0aWNhbGx5LCBidXQgZGlkIG5vdCBpbiB0aGlzIGNhc2UuYFxuICAgICAgICAgIClcbiAgICAgICAgY2FzZSAncHJlcmVuZGVyLXBwcic6XG4gICAgICAgICAgLy8gUFBSIFByZXJlbmRlclxuICAgICAgICAgIHBvc3Rwb25lV2l0aFRyYWNraW5nKFxuICAgICAgICAgICAgc3RvcmUucm91dGUsXG4gICAgICAgICAgICBleHByZXNzaW9uLFxuICAgICAgICAgICAgd29ya1VuaXRTdG9yZS5keW5hbWljVHJhY2tpbmdcbiAgICAgICAgICApXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAncHJlcmVuZGVyLWxlZ2FjeSc6XG4gICAgICAgICAgLy8gbGVnYWN5IFByZXJlbmRlclxuICAgICAgICAgIHdvcmtVbml0U3RvcmUucmV2YWxpZGF0ZSA9IDBcblxuICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBEeW5hbWljU2VydmVyRXJyb3IoXG4gICAgICAgICAgICBgUm91dGUgJHtzdG9yZS5yb3V0ZX0gY291bGRuJ3QgYmUgcmVuZGVyZWQgc3RhdGljYWxseSBiZWNhdXNlIGl0IHVzZWQgXFxgJHtleHByZXNzaW9ufVxcYC4gU2VlIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9keW5hbWljLXNlcnZlci1lcnJvcmBcbiAgICAgICAgICApXG4gICAgICAgICAgc3RvcmUuZHluYW1pY1VzYWdlRGVzY3JpcHRpb24gPSBleHByZXNzaW9uXG4gICAgICAgICAgc3RvcmUuZHluYW1pY1VzYWdlU3RhY2sgPSBlcnIuc3RhY2tcblxuICAgICAgICAgIHRocm93IGVyclxuICAgICAgICBjYXNlICdyZXF1ZXN0JzpcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICAgIHdvcmtVbml0U3RvcmUudXNlZER5bmFtaWMgPSB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIGZhbGx0aHJvdWdoXG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOlsiZHJhZnRNb2RlIiwiY2FsbGluZ0V4cHJlc3Npb24iLCJ3b3JrU3RvcmUiLCJ3b3JrQXN5bmNTdG9yYWdlIiwiZ2V0U3RvcmUiLCJ3b3JrVW5pdFN0b3JlIiwid29ya1VuaXRBc3luY1N0b3JhZ2UiLCJ0aHJvd0Zvck1pc3NpbmdSZXF1ZXN0U3RvcmUiLCJ0eXBlIiwiY3JlYXRlT3JHZXRDYWNoZWREcmFmdE1vZGUiLCJkcmFmdE1vZGVQcm92aWRlciIsImdldERyYWZ0TW9kZVByb3ZpZGVyRm9yQ2FjaGVTY29wZSIsIl9leGhhdXN0aXZlQ2hlY2siLCJjYWNoZUtleSIsIk51bGxEcmFmdE1vZGUiLCJjYWNoZWREcmFmdE1vZGUiLCJDYWNoZWREcmFmdE1vZGVzIiwiZ2V0IiwicHJvbWlzZSIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImlzUHJlZmV0Y2hSZXF1ZXN0Iiwicm91dGUiLCJfX05FWFRfRFlOQU1JQ19JTyIsImNyZWF0ZURyYWZ0TW9kZVdpdGhEZXZXYXJuaW5ncyIsImNyZWF0ZUV4b3RpY0RyYWZ0TW9kZVdpdGhEZXZXYXJuaW5ncyIsIlByb21pc2UiLCJyZXNvbHZlIiwiRHJhZnRNb2RlIiwiY3JlYXRlRXhvdGljRHJhZnRNb2RlIiwic2V0IiwiV2Vha01hcCIsInVuZGVybHlpbmdQcm92aWRlciIsImluc3RhbmNlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJpc0VuYWJsZWQiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwiZW5hYmxlIiwiYmluZCIsImRpc2FibGUiLCJleHByZXNzaW9uIiwic3luY0lPRGV2IiwidmFsdWUiLCJhcHBseSIsImFyZ3VtZW50cyIsInByb3hpZWRQcm9taXNlIiwiUHJveHkiLCJ0YXJnZXQiLCJwcm9wIiwicmVjZWl2ZXIiLCJ3YXJuRm9yU3luY0FjY2VzcyIsIlJlZmxlY3RBZGFwdGVyIiwiY29uc3RydWN0b3IiLCJwcm92aWRlciIsIl9wcm92aWRlciIsInRyYWNrRHluYW1pY0RyYWZ0TW9kZSIsInByZXJlbmRlclBoYXNlIiwicmVxdWVzdFN0b3JlIiwidHJhY2tTeW5jaHJvbm91c1JlcXVlc3REYXRhQWNjZXNzSW5EZXYiLCJjcmVhdGVEZWR1cGVkQnlDYWxsc2l0ZVNlcnZlckVycm9yTG9nZ2VyRGV2IiwiY3JlYXRlRHJhZnRNb2RlQWNjZXNzRXJyb3IiLCJwcmVmaXgiLCJFcnJvciIsInN0b3JlIiwicGhhc2UiLCJkeW5hbWljU2hvdWxkRXJyb3IiLCJTdGF0aWNHZW5CYWlsb3V0RXJyb3IiLCJlcnJvciIsImFib3J0QW5kVGhyb3dPblN5bmNocm9ub3VzUmVxdWVzdERhdGFBY2Nlc3MiLCJleHBvcnROYW1lIiwiSW52YXJpYW50RXJyb3IiLCJwb3N0cG9uZVdpdGhUcmFja2luZyIsImR5bmFtaWNUcmFja2luZyIsInJldmFsaWRhdGUiLCJlcnIiLCJEeW5hbWljU2VydmVyRXJyb3IiLCJkeW5hbWljVXNhZ2VEZXNjcmlwdGlvbiIsImR5bmFtaWNVc2FnZVN0YWNrIiwic3RhY2siLCJ1c2VkRHluYW1pYyJdLCJtYXBwaW5ncyI6Ijs7OytCQThD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MUNoQixjQUFjNkUsV0FBVyxHQUFHO29CQUM5QjtvQkFDQTtnQkFDRjtZQUVGO1FBQ0Y7SUFDRjtBQUNGIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDE5ODUsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9oZWFkZXJzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzLmNvb2tpZXMgPSByZXF1aXJlKCcuL2Rpc3Qvc2VydmVyL3JlcXVlc3QvY29va2llcycpLmNvb2tpZXNcbm1vZHVsZS5leHBvcnRzLmhlYWRlcnMgPSByZXF1aXJlKCcuL2Rpc3Qvc2VydmVyL3JlcXVlc3QvaGVhZGVycycpLmhlYWRlcnNcbm1vZHVsZS5leHBvcnRzLmRyYWZ0TW9kZSA9IHJlcXVpcmUoJy4vZGlzdC9zZXJ2ZXIvcmVxdWVzdC9kcmFmdC1tb2RlJykuZHJhZnRNb2RlXG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxPQUFPLENBQUMsT0FBTyxHQUFHLDZHQUF5QyxPQUFPO0FBQ3pFLE9BQU8sT0FBTyxDQUFDLE9BQU8sR0FBRyw2R0FBeUMsT0FBTztBQUN6RSxPQUFPLE9BQU8sQ0FBQyxTQUFTLEdBQUcsZ0hBQTRDLFNBQVMiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fV0KfQ==