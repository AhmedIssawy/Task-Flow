module.exports = {

"[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) return obj;
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") return {
        default: obj
    };
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) Object.defineProperty(newObj, key, desc);
            else newObj[key] = obj[key];
        }
    }
    newObj.default = obj;
    if (cache) cache.set(obj, newObj);
    return newObj;
}
exports._ = _interop_require_wildcard;
}}),
"[project]/node_modules/next/dist/shared/lib/router/utils/querystring.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    assign: null,
    searchParamsToUrlQuery: null,
    urlQueryToSearchParams: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    assign: function() {
        return assign;
    },
    searchParamsToUrlQuery: function() {
        return searchParamsToUrlQuery;
    },
    urlQueryToSearchParams: function() {
        return urlQueryToSearchParams;
    }
});
function searchParamsToUrlQuery(searchParams) {
    const query = {};
    for (const [key, value] of searchParams.entries()){
        const existing = query[key];
        if (typeof existing === 'undefined') {
            query[key] = value;
        } else if (Array.isArray(existing)) {
            existing.push(value);
        } else {
            query[key] = [
                existing,
                value
            ];
        }
    }
    return query;
}
function stringifyUrlQueryParam(param) {
    if (typeof param === 'string') {
        return param;
    }
    if (typeof param === 'number' && !isNaN(param) || typeof param === 'boolean') {
        return String(param);
    } else {
        return '';
    }
}
function urlQueryToSearchParams(query) {
    const searchParams = new URLSearchParams();
    for (const [key, value] of Object.entries(query)){
        if (Array.isArray(value)) {
            for (const item of value){
                searchParams.append(key, stringifyUrlQueryParam(item));
            }
        } else {
            searchParams.set(key, stringifyUrlQueryParam(value));
        }
    }
    return searchParams;
}
function assign(target) {
    for(var _len = arguments.length, searchParamsList = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
        searchParamsList[_key - 1] = arguments[_key];
    }
    for (const searchParams of searchParamsList){
        for (const key of searchParams.keys()){
            target.delete(key);
        }
        for (const [key, value] of searchParams.entries()){
            target.append(key, value);
        }
    }
    return target;
} //# sourceMappingURL=querystring.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/router/utils/format-url.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
// Format function modified from nodejs
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    formatUrl: null,
    formatWithValidation: null,
    urlObjectKeys: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    formatUrl: function() {
        return formatUrl;
    },
    formatWithValidation: function() {
        return formatWithValidation;
    },
    urlObjectKeys: function() {
        return urlObjectKeys;
    }
});
const _interop_require_wildcard = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [app-ssr] (ecmascript)");
const _querystring = /*#__PURE__*/ _interop_require_wildcard._(__turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/querystring.js [app-ssr] (ecmascript)"));
const slashedProtocols = /https?|ftp|gopher|file/;
function formatUrl(urlObj) {
    let { auth, hostname } = urlObj;
    let protocol = urlObj.protocol || '';
    let pathname = urlObj.pathname || '';
    let hash = urlObj.hash || '';
    let query = urlObj.query || '';
    let host = false;
    auth = auth ? encodeURIComponent(auth).replace(/%3A/i, ':') + '@' : '';
    if (urlObj.host) {
        host = auth + urlObj.host;
    } else if (hostname) {
        host = auth + (~hostname.indexOf(':') ? "[" + hostname + "]" : hostname);
        if (urlObj.port) {
            host += ':' + urlObj.port;
        }
    }
    if (query && typeof query === 'object') {
        query = String(_querystring.urlQueryToSearchParams(query));
    }
    let search = urlObj.search || query && "?" + query || '';
    if (protocol && !protocol.endsWith(':')) protocol += ':';
    if (urlObj.slashes || (!protocol || slashedProtocols.test(protocol)) && host !== false) {
        host = '//' + (host || '');
        if (pathname && pathname[0] !== '/') pathname = '/' + pathname;
    } else if (!host) {
        host = '';
    }
    if (hash && hash[0] !== '#') hash = '#' + hash;
    if (search && search[0] !== '?') search = '?' + search;
    pathname = pathname.replace(/[?#]/g, encodeURIComponent);
    search = search.replace('#', '%23');
    return "" + protocol + host + pathname + search + hash;
}
const urlObjectKeys = [
    'auth',
    'hash',
    'host',
    'hostname',
    'href',
    'path',
    'pathname',
    'port',
    'protocol',
    'query',
    'search',
    'slashes'
];
function formatWithValidation(url) {
    if ("TURBOPACK compile-time truthy", 1) {
        if (url !== null && typeof url === 'object') {
            Object.keys(url).forEach((key)=>{
                if (!urlObjectKeys.includes(key)) {
                    console.warn("Unknown key passed via urlObject into url.format: " + key);
                }
            });
        }
    }
    return formatUrl(url);
} //# sourceMappingURL=format-url.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/router-reducer-types.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    ACTION_HMR_REFRESH: null,
    ACTION_NAVIGATE: null,
    ACTION_PREFETCH: null,
    ACTION_REFRESH: null,
    ACTION_RESTORE: null,
    ACTION_SERVER_ACTION: null,
    ACTION_SERVER_PATCH: null,
    PrefetchCacheEntryStatus: null,
    PrefetchKind: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    ACTION_HMR_REFRESH: function() {
        return ACTION_HMR_REFRESH;
    },
    ACTION_NAVIGATE: function() {
        return ACTION_NAVIGATE;
    },
    ACTION_PREFETCH: function() {
        return ACTION_PREFETCH;
    },
    ACTION_REFRESH: function() {
        return ACTION_REFRESH;
    },
    ACTION_RESTORE: function() {
        return ACTION_RESTORE;
    },
    ACTION_SERVER_ACTION: function() {
        return ACTION_SERVER_ACTION;
    },
    ACTION_SERVER_PATCH: function() {
        return ACTION_SERVER_PATCH;
    },
    PrefetchCacheEntryStatus: function() {
        return PrefetchCacheEntryStatus;
    },
    PrefetchKind: function() {
        return PrefetchKind;
    }
});
const ACTION_REFRESH = 'refresh';
const ACTION_NAVIGATE = 'navigate';
const ACTION_RESTORE = 'restore';
const ACTION_SERVER_PATCH = 'server-patch';
const ACTION_PREFETCH = 'prefetch';
const ACTION_HMR_REFRESH = 'hmr-refresh';
const ACTION_SERVER_ACTION = 'server-action';
var PrefetchKind = /*#__PURE__*/ function(PrefetchKind) {
    PrefetchKind["AUTO"] = "auto";
    PrefetchKind["FULL"] = "full";
    PrefetchKind["TEMPORARY"] = "temporary";
    return PrefetchKind;
}({});
var PrefetchCacheEntryStatus = /*#__PURE__*/ function(PrefetchCacheEntryStatus) {
    PrefetchCacheEntryStatus["fresh"] = "fresh";
    PrefetchCacheEntryStatus["reusable"] = "reusable";
    PrefetchCacheEntryStatus["expired"] = "expired";
    PrefetchCacheEntryStatus["stale"] = "stale";
    return PrefetchCacheEntryStatus;
}({});
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=router-reducer-types.js.map
}}),
"[project]/node_modules/next/dist/client/use-merged-ref.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useMergedRef", {
    enumerable: true,
    get: function() {
        return useMergedRef;
    }
});
const _react = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
function useMergedRef(refA, refB) {
    const cleanupA = (0, _react.useRef)(null);
    const cleanupB = (0, _react.useRef)(null);
    // NOTE: In theory, we could skip the wrapping if only one of the refs is non-null.
    // (this happens often if the user doesn't pass a ref to Link/Form/Image)
    // But this can cause us to leak a cleanup-ref into user code (e.g. via `<Link legacyBehavior>`),
    // and the user might pass that ref into ref-merging library that doesn't support cleanup refs
    // (because it hasn't been updated for React 19)
    // which can then cause things to blow up, because a cleanup-returning ref gets called with `null`.
    // So in practice, it's safer to be defensive and always wrap the ref, even on React 19.
    return (0, _react.useCallback)((current)=>{
        if (current === null) {
            const cleanupFnA = cleanupA.current;
            if (cleanupFnA) {
                cleanupA.current = null;
                cleanupFnA();
            }
            const cleanupFnB = cleanupB.current;
            if (cleanupFnB) {
                cleanupB.current = null;
                cleanupFnB();
            }
        } else {
            if (refA) {
                cleanupA.current = applyRef(refA, current);
            }
            if (refB) {
                cleanupB.current = applyRef(refB, current);
            }
        }
    }, [
        refA,
        refB
    ]);
}
function applyRef(refA, current) {
    if (typeof refA === 'function') {
        const cleanup = refA(current);
        if (typeof cleanup === 'function') {
            return cleanup;
        } else {
            return ()=>refA(null);
        }
    } else {
        refA.current = current;
        return ()=>{
            refA.current = null;
        };
    }
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=use-merged-ref.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/utils.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    DecodeError: null,
    MiddlewareNotFoundError: null,
    MissingStaticPage: null,
    NormalizeError: null,
    PageNotFoundError: null,
    SP: null,
    ST: null,
    WEB_VITALS: null,
    execOnce: null,
    getDisplayName: null,
    getLocationOrigin: null,
    getURL: null,
    isAbsoluteUrl: null,
    isResSent: null,
    loadGetInitialProps: null,
    normalizeRepeatedSlashes: null,
    stringifyError: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    DecodeError: function() {
        return DecodeError;
    },
    MiddlewareNotFoundError: function() {
        return MiddlewareNotFoundError;
    },
    MissingStaticPage: function() {
        return MissingStaticPage;
    },
    NormalizeError: function() {
        return NormalizeError;
    },
    PageNotFoundError: function() {
        return PageNotFoundError;
    },
    SP: function() {
        return SP;
    },
    ST: function() {
        return ST;
    },
    WEB_VITALS: function() {
        return WEB_VITALS;
    },
    execOnce: function() {
        return execOnce;
    },
    getDisplayName: function() {
        return getDisplayName;
    },
    getLocationOrigin: function() {
        return getLocationOrigin;
    },
    getURL: function() {
        return getURL;
    },
    isAbsoluteUrl: function() {
        return isAbsoluteUrl;
    },
    isResSent: function() {
        return isResSent;
    },
    loadGetInitialProps: function() {
        return loadGetInitialProps;
    },
    normalizeRepeatedSlashes: function() {
        return normalizeRepeatedSlashes;
    },
    stringifyError: function() {
        return stringifyError;
    }
});
const WEB_VITALS = [
    'CLS',
    'FCP',
    'FID',
    'INP',
    'LCP',
    'TTFB'
];
function execOnce(fn) {
    let used = false;
    let result;
    return function() {
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        if (!used) {
            used = true;
            result = fn(...args);
        }
        return result;
    };
}
// Scheme: https://tools.ietf.org/html/rfc3986#section-3.1
// Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3
const ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\d+\-.]*?:/;
const isAbsoluteUrl = (url)=>ABSOLUTE_URL_REGEX.test(url);
function getLocationOrigin() {
    const { protocol, hostname, port } = window.location;
    return protocol + "//" + hostname + (port ? ':' + port : '');
}
function getURL() {
    const { href } = window.location;
    const origin = getLocationOrigin();
    return href.substring(origin.length);
}
function getDisplayName(Component) {
    return typeof Component === 'string' ? Component : Component.displayName || Component.name || 'Unknown';
}
function isResSent(res) {
    return res.finished || res.headersSent;
}
function normalizeRepeatedSlashes(url) {
    const urlParts = url.split('?');
    const urlNoQuery = urlParts[0];
    return urlNoQuery // first we replace any non-encoded backslashes with forward
    // then normalize repeated forward slashes
    .replace(/\\/g, '/').replace(/\/\/+/g, '/') + (urlParts[1] ? "?" + urlParts.slice(1).join('?') : '');
}
async function loadGetInitialProps(App, ctx) {
    if ("TURBOPACK compile-time truthy", 1) {
        var _App_prototype;
        if ((_App_prototype = App.prototype) == null ? void 0 : _App_prototype.getInitialProps) {
            const message = '"' + getDisplayName(App) + '.getInitialProps()" is defined as an instance method - visit https://nextjs.org/docs/messages/get-initial-props-as-an-instance-method for more information.';
            throw Object.defineProperty(new Error(message), "__NEXT_ERROR_CODE", {
                value: "E394",
                enumerable: false,
                configurable: true
            });
        }
    }
    // when called from _app `ctx` is nested in `ctx`
    const res = ctx.res || ctx.ctx && ctx.ctx.res;
    if (!App.getInitialProps) {
        if (ctx.ctx && ctx.Component) {
            // @ts-ignore pageProps default
            return {
                pageProps: await loadGetInitialProps(ctx.Component, ctx.ctx)
            };
        }
        return {};
    }
    const props = await App.getInitialProps(ctx);
    if (res && isResSent(res)) {
        return props;
    }
    if (!props) {
        const message = '"' + getDisplayName(App) + '.getInitialProps()" should resolve to an object. But found "' + props + '" instead.';
        throw Object.defineProperty(new Error(message), "__NEXT_ERROR_CODE", {
            value: "E394",
            enumerable: false,
            configurable: true
        });
    }
    if ("TURBOPACK compile-time truthy", 1) {
        if (Object.keys(props).length === 0 && !ctx.ctx) {
            console.warn("" + getDisplayName(App) + " returned an empty object from `getInitialProps`. This de-optimizes and prevents automatic static optimization. https://nextjs.org/docs/messages/empty-object-getInitialProps");
        }
    }
    return props;
}
const SP = typeof performance !== 'undefined';
const ST = SP && [
    'mark',
    'measure',
    'getEntriesByName'
].every((method)=>typeof performance[method] === 'function');
class DecodeError extends Error {
}
class NormalizeError extends Error {
}
class PageNotFoundError extends Error {
    constructor(page){
        super();
        this.code = 'ENOENT';
        this.name = 'PageNotFoundError';
        this.message = "Cannot find module for page: " + page;
    }
}
class MissingStaticPage extends Error {
    constructor(page, message){
        super();
        this.message = "Failed to load static file for page: " + page + " " + message;
    }
}
class MiddlewareNotFoundError extends Error {
    constructor(){
        super();
        this.code = 'ENOENT';
        this.message = "Cannot find the middleware module";
    }
}
function stringifyError(error) {
    return JSON.stringify({
        message: error.message,
        stack: error.stack
    });
} //# sourceMappingURL=utils.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/router/utils/parse-path.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/**
 * Given a path this function will find the pathname, query and hash and return
 * them. This is useful to parse full paths on the client side.
 * @param path A path to parse e.g. /foo/bar?id=1#hash
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "parsePath", {
    enumerable: true,
    get: function() {
        return parsePath;
    }
});
function parsePath(path) {
    const hashIndex = path.indexOf('#');
    const queryIndex = path.indexOf('?');
    const hasQuery = queryIndex > -1 && (hashIndex < 0 || queryIndex < hashIndex);
    if (hasQuery || hashIndex > -1) {
        return {
            pathname: path.substring(0, hasQuery ? queryIndex : hashIndex),
            query: hasQuery ? path.substring(queryIndex, hashIndex > -1 ? hashIndex : undefined) : '',
            hash: hashIndex > -1 ? path.slice(hashIndex) : ''
        };
    }
    return {
        pathname: path,
        query: '',
        hash: ''
    };
} //# sourceMappingURL=parse-path.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "addPathPrefix", {
    enumerable: true,
    get: function() {
        return addPathPrefix;
    }
});
const _parsepath = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/parse-path.js [app-ssr] (ecmascript)");
function addPathPrefix(path, prefix) {
    if (!path.startsWith('/') || !prefix) {
        return path;
    }
    const { pathname, query, hash } = (0, _parsepath.parsePath)(path);
    return "" + prefix + pathname + query + hash;
} //# sourceMappingURL=add-path-prefix.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/**
 * Removes the trailing slash for a given route or page path. Preserves the
 * root page. Examples:
 *   - `/foo/bar/` -> `/foo/bar`
 *   - `/foo/bar` -> `/foo/bar`
 *   - `/` -> `/`
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "removeTrailingSlash", {
    enumerable: true,
    get: function() {
        return removeTrailingSlash;
    }
});
function removeTrailingSlash(route) {
    return route.replace(/\/$/, '') || '/';
} //# sourceMappingURL=remove-trailing-slash.js.map
}}),
"[project]/node_modules/next/dist/client/normalize-trailing-slash.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "normalizePathTrailingSlash", {
    enumerable: true,
    get: function() {
        return normalizePathTrailingSlash;
    }
});
const _removetrailingslash = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js [app-ssr] (ecmascript)");
const _parsepath = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/parse-path.js [app-ssr] (ecmascript)");
const normalizePathTrailingSlash = (path)=>{
    if (!path.startsWith('/') || ("TURBOPACK compile-time value", void 0)) {
        return path;
    }
    const { pathname, query, hash } = (0, _parsepath.parsePath)(path);
    if ("TURBOPACK compile-time truthy", 1) {
        if (/\.[^/]+\/?$/.test(pathname)) {
            return "" + (0, _removetrailingslash.removeTrailingSlash)(pathname) + query + hash;
        } else if (pathname.endsWith('/')) {
            return "" + pathname + query + hash;
        } else {
            return pathname + "/" + query + hash;
        }
    }
    //TURBOPACK unreachable
    ;
};
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=normalize-trailing-slash.js.map
}}),
"[project]/node_modules/next/dist/client/add-base-path.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "addBasePath", {
    enumerable: true,
    get: function() {
        return addBasePath;
    }
});
const _addpathprefix = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js [app-ssr] (ecmascript)");
const _normalizetrailingslash = __turbopack_context__.r("[project]/node_modules/next/dist/client/normalize-trailing-slash.js [app-ssr] (ecmascript)");
const basePath = ("TURBOPACK compile-time value", "") || '';
function addBasePath(path, required) {
    return (0, _normalizetrailingslash.normalizePathTrailingSlash)(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : (0, _addpathprefix.addPathPrefix)(path, basePath));
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=add-base-path.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/utils/warn-once.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "warnOnce", {
    enumerable: true,
    get: function() {
        return warnOnce;
    }
});
let warnOnce = (_)=>{};
if ("TURBOPACK compile-time truthy", 1) {
    const warnings = new Set();
    warnOnce = (msg)=>{
        if (!warnings.has(msg)) {
            console.warn(msg);
        }
        warnings.add(msg);
    };
} //# sourceMappingURL=warn-once.js.map
}}),
"[project]/node_modules/next/dist/client/components/app-router-headers.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    ACTION_HEADER: null,
    FLIGHT_HEADERS: null,
    NEXT_ACTION_NOT_FOUND_HEADER: null,
    NEXT_DID_POSTPONE_HEADER: null,
    NEXT_HMR_REFRESH_HASH_COOKIE: null,
    NEXT_HMR_REFRESH_HEADER: null,
    NEXT_IS_PRERENDER_HEADER: null,
    NEXT_REWRITTEN_PATH_HEADER: null,
    NEXT_REWRITTEN_QUERY_HEADER: null,
    NEXT_ROUTER_PREFETCH_HEADER: null,
    NEXT_ROUTER_SEGMENT_PREFETCH_HEADER: null,
    NEXT_ROUTER_STALE_TIME_HEADER: null,
    NEXT_ROUTER_STATE_TREE_HEADER: null,
    NEXT_RSC_UNION_QUERY: null,
    NEXT_URL: null,
    RSC_CONTENT_TYPE_HEADER: null,
    RSC_HEADER: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    ACTION_HEADER: function() {
        return ACTION_HEADER;
    },
    FLIGHT_HEADERS: function() {
        return FLIGHT_HEADERS;
    },
    NEXT_ACTION_NOT_FOUND_HEADER: function() {
        return NEXT_ACTION_NOT_FOUND_HEADER;
    },
    NEXT_DID_POSTPONE_HEADER: function() {
        return NEXT_DID_POSTPONE_HEADER;
    },
    NEXT_HMR_REFRESH_HASH_COOKIE: function() {
        return NEXT_HMR_REFRESH_HASH_COOKIE;
    },
    NEXT_HMR_REFRESH_HEADER: function() {
        return NEXT_HMR_REFRESH_HEADER;
    },
    NEXT_IS_PRERENDER_HEADER: function() {
        return NEXT_IS_PRERENDER_HEADER;
    },
    NEXT_REWRITTEN_PATH_HEADER: function() {
        return NEXT_REWRITTEN_PATH_HEADER;
    },
    NEXT_REWRITTEN_QUERY_HEADER: function() {
        return NEXT_REWRITTEN_QUERY_HEADER;
    },
    NEXT_ROUTER_PREFETCH_HEADER: function() {
        return NEXT_ROUTER_PREFETCH_HEADER;
    },
    NEXT_ROUTER_SEGMENT_PREFETCH_HEADER: function() {
        return NEXT_ROUTER_SEGMENT_PREFETCH_HEADER;
    },
    NEXT_ROUTER_STALE_TIME_HEADER: function() {
        return NEXT_ROUTER_STALE_TIME_HEADER;
    },
    NEXT_ROUTER_STATE_TREE_HEADER: function() {
        return NEXT_ROUTER_STATE_TREE_HEADER;
    },
    NEXT_RSC_UNION_QUERY: function() {
        return NEXT_RSC_UNION_QUERY;
    },
    NEXT_URL: function() {
        return NEXT_URL;
    },
    RSC_CONTENT_TYPE_HEADER: function() {
        return RSC_CONTENT_TYPE_HEADER;
    },
    RSC_HEADER: function() {
        return RSC_HEADER;
    }
});
const RSC_HEADER = 'RSC';
const ACTION_HEADER = 'Next-Action';
const NEXT_ROUTER_STATE_TREE_HEADER = 'Next-Router-State-Tree';
const NEXT_ROUTER_PREFETCH_HEADER = 'Next-Router-Prefetch';
const NEXT_ROUTER_SEGMENT_PREFETCH_HEADER = 'Next-Router-Segment-Prefetch';
const NEXT_HMR_REFRESH_HEADER = 'Next-HMR-Refresh';
const NEXT_HMR_REFRESH_HASH_COOKIE = '__next_hmr_refresh_hash__';
const NEXT_URL = 'Next-Url';
const RSC_CONTENT_TYPE_HEADER = 'text/x-component';
const FLIGHT_HEADERS = [
    RSC_HEADER,
    NEXT_ROUTER_STATE_TREE_HEADER,
    NEXT_ROUTER_PREFETCH_HEADER,
    NEXT_HMR_REFRESH_HEADER,
    NEXT_ROUTER_SEGMENT_PREFETCH_HEADER
];
const NEXT_RSC_UNION_QUERY = '_rsc';
const NEXT_ROUTER_STALE_TIME_HEADER = 'x-nextjs-stale-time';
const NEXT_DID_POSTPONE_HEADER = 'x-nextjs-postponed';
const NEXT_REWRITTEN_PATH_HEADER = 'x-nextjs-rewritten-path';
const NEXT_REWRITTEN_QUERY_HEADER = 'x-nextjs-rewritten-query';
const NEXT_IS_PRERENDER_HEADER = 'x-nextjs-prerender';
const NEXT_ACTION_NOT_FOUND_HEADER = 'x-nextjs-action-not-found';
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=app-router-headers.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/is-thenable.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/**
 * Check to see if a value is Thenable.
 *
 * @param promise the maybe-thenable value
 * @returns true if the value is thenable
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "isThenable", {
    enumerable: true,
    get: function() {
        return isThenable;
    }
});
function isThenable(promise) {
    return promise !== null && typeof promise === 'object' && 'then' in promise && typeof promise.then === 'function';
} //# sourceMappingURL=is-thenable.js.map
}}),
"[project]/node_modules/next/dist/next-devtools/userspace/use-app-dev-rendering-indicator.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useAppDevRenderingIndicator", {
    enumerable: true,
    get: function() {
        return useAppDevRenderingIndicator;
    }
});
const _react = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
const _nextdevtools = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/next-devtools/index.js [app-ssr] (ecmascript)");
const useAppDevRenderingIndicator = ()=>{
    const [isPending, startTransition] = (0, _react.useTransition)();
    (0, _react.useEffect)(()=>{
        if (isPending) {
            _nextdevtools.dispatcher.renderingIndicatorShow();
        } else {
            _nextdevtools.dispatcher.renderingIndicatorHide();
        }
    }, [
        isPending
    ]);
    return startTransition;
};
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=use-app-dev-rendering-indicator.js.map
}}),
"[project]/node_modules/next/dist/client/components/use-action-queue.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    dispatchAppRouterAction: null,
    useActionQueue: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    dispatchAppRouterAction: function() {
        return dispatchAppRouterAction;
    },
    useActionQueue: function() {
        return useActionQueue;
    }
});
const _interop_require_wildcard = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [app-ssr] (ecmascript)");
const _react = /*#__PURE__*/ _interop_require_wildcard._(__turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)"));
const _isthenable = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/is-thenable.js [app-ssr] (ecmascript)");
// The app router state lives outside of React, so we can import the dispatch
// method directly wherever we need it, rather than passing it around via props
// or context.
let dispatch = null;
function dispatchAppRouterAction(action) {
    if (dispatch === null) {
        throw Object.defineProperty(new Error('Internal Next.js error: Router action dispatched before initialization.'), "__NEXT_ERROR_CODE", {
            value: "E668",
            enumerable: false,
            configurable: true
        });
    }
    dispatch(action);
}
function useActionQueue(actionQueue) {
    const [state, setState] = _react.default.useState(actionQueue.state);
    // Because of a known issue that requires to decode Flight streams inside the
    // render phase, we have to be a bit clever and assign the dispatch method to
    // a module-level variable upon initialization. The useState hook in this
    // module only exists to synchronize state that lives outside of React.
    // Ideally, what we'd do instead is pass the state as a prop to root.render;
    // this is conceptually how we're modeling the app router state, despite the
    // weird implementation details.
    if ("TURBOPACK compile-time truthy", 1) {
        const { useAppDevRenderingIndicator } = __turbopack_context__.r("[project]/node_modules/next/dist/next-devtools/userspace/use-app-dev-rendering-indicator.js [app-ssr] (ecmascript)");
        // eslint-disable-next-line react-hooks/rules-of-hooks
        const appDevRenderingIndicator = useAppDevRenderingIndicator();
        dispatch = (action)=>{
            appDevRenderingIndicator(()=>{
                actionQueue.dispatch(action, setState);
            });
        };
    } else //TURBOPACK unreachable
    ;
    return (0, _isthenable.isThenable)(state) ? (0, _react.use)(state) : state;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=use-action-queue.js.map
}}),
"[project]/node_modules/next/dist/client/app-call-server.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "callServer", {
    enumerable: true,
    get: function() {
        return callServer;
    }
});
const _react = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
const _routerreducertypes = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/router-reducer-types.js [app-ssr] (ecmascript)");
const _useactionqueue = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/use-action-queue.js [app-ssr] (ecmascript)");
async function callServer(actionId, actionArgs) {
    return new Promise((resolve, reject)=>{
        (0, _react.startTransition)(()=>{
            (0, _useactionqueue.dispatchAppRouterAction)({
                type: _routerreducertypes.ACTION_SERVER_ACTION,
                actionId,
                actionArgs,
                resolve,
                reject
            });
        });
    });
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=app-call-server.js.map
}}),
"[project]/node_modules/next/dist/client/app-find-source-map-url.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "findSourceMapURL", {
    enumerable: true,
    get: function() {
        return findSourceMapURL;
    }
});
const basePath = ("TURBOPACK compile-time value", "") || '';
const pathname = "" + basePath + "/__nextjs_source-map";
const findSourceMapURL = ("TURBOPACK compile-time truthy", 1) ? function findSourceMapURL(filename) {
    if (filename === '') {
        return null;
    }
    if (filename.startsWith(document.location.origin) && filename.includes('/_next/static')) {
        // This is a request for a client chunk. This can only happen when
        // using Turbopack. In this case, since we control how those source
        // maps are generated, we can safely assume that the sourceMappingURL
        // is relative to the filename, with an added `.map` extension. The
        // browser can just request this file, and it gets served through the
        // normal dev server, without the need to route this through
        // the `/__nextjs_source-map` dev middleware.
        return "" + filename + ".map";
    }
    const url = new URL(pathname, document.location.origin);
    url.searchParams.set('filename', filename);
    return url.href;
} : "TURBOPACK unreachable";
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=app-find-source-map-url.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/segment.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    DEFAULT_SEGMENT_KEY: null,
    PAGE_SEGMENT_KEY: null,
    addSearchParamsIfPageSegment: null,
    isGroupSegment: null,
    isParallelRouteSegment: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    DEFAULT_SEGMENT_KEY: function() {
        return DEFAULT_SEGMENT_KEY;
    },
    PAGE_SEGMENT_KEY: function() {
        return PAGE_SEGMENT_KEY;
    },
    addSearchParamsIfPageSegment: function() {
        return addSearchParamsIfPageSegment;
    },
    isGroupSegment: function() {
        return isGroupSegment;
    },
    isParallelRouteSegment: function() {
        return isParallelRouteSegment;
    }
});
function isGroupSegment(segment) {
    // Use array[0] for performant purpose
    return segment[0] === '(' && segment.endsWith(')');
}
function isParallelRouteSegment(segment) {
    return segment.startsWith('@') && segment !== '@children';
}
function addSearchParamsIfPageSegment(segment, searchParams) {
    const isPageSegment = segment.includes(PAGE_SEGMENT_KEY);
    if (isPageSegment) {
        const stringifiedQuery = JSON.stringify(searchParams);
        return stringifiedQuery !== '{}' ? PAGE_SEGMENT_KEY + '?' + stringifiedQuery : PAGE_SEGMENT_KEY;
    }
    return segment;
}
const PAGE_SEGMENT_KEY = '__PAGE__';
const DEFAULT_SEGMENT_KEY = '__DEFAULT__'; //# sourceMappingURL=segment.js.map
}}),
"[project]/node_modules/next/dist/client/flight-data-helpers.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    getFlightDataPartsFromPath: null,
    getNextFlightSegmentPath: null,
    normalizeFlightData: null,
    prepareFlightRouterStateForRequest: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    getFlightDataPartsFromPath: function() {
        return getFlightDataPartsFromPath;
    },
    getNextFlightSegmentPath: function() {
        return getNextFlightSegmentPath;
    },
    normalizeFlightData: function() {
        return normalizeFlightData;
    },
    prepareFlightRouterStateForRequest: function() {
        return prepareFlightRouterStateForRequest;
    }
});
const _segment = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/segment.js [app-ssr] (ecmascript)");
function getFlightDataPartsFromPath(flightDataPath) {
    // Pick the last 4 items from the `FlightDataPath` to get the [tree, seedData, viewport, isHeadPartial].
    const flightDataPathLength = 4;
    // tree, seedData, and head are *always* the last three items in the `FlightDataPath`.
    const [tree, seedData, head, isHeadPartial] = flightDataPath.slice(-flightDataPathLength);
    // The `FlightSegmentPath` is everything except the last three items. For a root render, it won't be present.
    const segmentPath = flightDataPath.slice(0, -flightDataPathLength);
    var _segmentPath_;
    return {
        // TODO: Unify these two segment path helpers. We are inconsistently pushing an empty segment ("")
        // to the start of the segment path in some places which makes it hard to use solely the segment path.
        // Look for "// TODO-APP: remove ''" in the codebase.
        pathToSegment: segmentPath.slice(0, -1),
        segmentPath,
        // if the `FlightDataPath` corresponds with the root, there'll be no segment path,
        // in which case we default to ''.
        segment: (_segmentPath_ = segmentPath[segmentPath.length - 1]) != null ? _segmentPath_ : '',
        tree,
        seedData,
        head,
        isHeadPartial,
        isRootRender: flightDataPath.length === flightDataPathLength
    };
}
function getNextFlightSegmentPath(flightSegmentPath) {
    // Since `FlightSegmentPath` is a repeated tuple of `Segment` and `ParallelRouteKey`, we slice off two items
    // to get the next segment path.
    return flightSegmentPath.slice(2);
}
function normalizeFlightData(flightData) {
    // FlightData can be a string when the server didn't respond with a proper flight response,
    // or when a redirect happens, to signal to the client that it needs to perform an MPA navigation.
    if (typeof flightData === 'string') {
        return flightData;
    }
    return flightData.map(getFlightDataPartsFromPath);
}
function prepareFlightRouterStateForRequest(flightRouterState, isHmrRefresh) {
    // HMR requests need the complete, unmodified state for proper functionality
    if (isHmrRefresh) {
        return encodeURIComponent(JSON.stringify(flightRouterState));
    }
    return encodeURIComponent(JSON.stringify(stripClientOnlyDataFromFlightRouterState(flightRouterState)));
}
/**
 * Recursively strips client-only data from FlightRouterState while preserving
 * server-needed information for proper rendering decisions.
 */ function stripClientOnlyDataFromFlightRouterState(flightRouterState) {
    const [segment, parallelRoutes, _url, refreshMarker, isRootLayout, hasLoadingBoundary] = flightRouterState;
    // __PAGE__ segments are always fetched from the server, so there's
    // no need to send them up
    const cleanedSegment = stripSearchParamsFromPageSegment(segment);
    // Recursively process parallel routes
    const cleanedParallelRoutes = {};
    for (const [key, childState] of Object.entries(parallelRoutes)){
        cleanedParallelRoutes[key] = stripClientOnlyDataFromFlightRouterState(childState);
    }
    const result = [
        cleanedSegment,
        cleanedParallelRoutes,
        null,
        shouldPreserveRefreshMarker(refreshMarker) ? refreshMarker : null
    ];
    // Append optional fields if present
    if (isRootLayout !== undefined) {
        result[4] = isRootLayout;
    }
    if (hasLoadingBoundary !== undefined) {
        result[5] = hasLoadingBoundary;
    }
    return result;
}
/**
 * Strips search parameters from __PAGE__ segments to prevent sensitive
 * client-side data from being sent to the server.
 */ function stripSearchParamsFromPageSegment(segment) {
    if (typeof segment === 'string' && segment.startsWith(_segment.PAGE_SEGMENT_KEY + '?')) {
        return _segment.PAGE_SEGMENT_KEY;
    }
    return segment;
}
/**
 * Determines whether the refresh marker should be sent to the server
 * Client-only markers like 'refresh' are stripped, while server-needed markers
 * like 'refetch' and 'inside-shared-layout' are preserved.
 */ function shouldPreserveRefreshMarker(refreshMarker) {
    return Boolean(refreshMarker && refreshMarker !== 'refresh');
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=flight-data-helpers.js.map
}}),
"[project]/node_modules/next/dist/client/app-build-id.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
// This gets assigned as a side-effect during app initialization. Because it
// represents the build used to create the JS bundle, it should never change
// after being set, so we store it in a global variable.
//
// When performing RSC requests, if the incoming data has a different build ID,
// we perform an MPA navigation/refresh to load the updated build and ensure
// that the client and server in sync.
// Starts as an empty string. In practice, because setAppBuildId is called
// during initialization before hydration starts, this will always get
// reassigned to the actual build ID before it's ever needed by a navigation.
// If for some reasons it didn't, due to a bug or race condition, then on
// navigation the build comparision would fail and trigger an MPA navigation.
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    getAppBuildId: null,
    setAppBuildId: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    getAppBuildId: function() {
        return getAppBuildId;
    },
    setAppBuildId: function() {
        return setAppBuildId;
    }
});
let globalBuildId = '';
function setAppBuildId(buildId) {
    globalBuildId = buildId;
}
function getAppBuildId() {
    return globalBuildId;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=app-build-id.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/hash.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
// http://www.cse.yorku.ca/~oz/hash.html
// More specifically, 32-bit hash via djbxor
// (ref: https://gist.github.com/eplawless/52813b1d8ad9af510d85?permalink_comment_id=3367765#gistcomment-3367765)
// This is due to number type differences between rust for turbopack to js number types,
// where rust does not have easy way to repreesnt js's 53-bit float number type for the matching
// overflow behavior. This is more `correct` in terms of having canonical hash across different runtime / implementation
// as can gaurantee determinstic output from 32bit hash.
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    djb2Hash: null,
    hexHash: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    djb2Hash: function() {
        return djb2Hash;
    },
    hexHash: function() {
        return hexHash;
    }
});
function djb2Hash(str) {
    let hash = 5381;
    for(let i = 0; i < str.length; i++){
        const char = str.charCodeAt(i);
        hash = (hash << 5) + hash + char & 0xffffffff;
    }
    return hash >>> 0;
}
function hexHash(str) {
    return djb2Hash(str).toString(36).slice(0, 5);
} //# sourceMappingURL=hash.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/router/utils/cache-busting-search-param.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "computeCacheBustingSearchParam", {
    enumerable: true,
    get: function() {
        return computeCacheBustingSearchParam;
    }
});
const _hash = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/hash.js [app-ssr] (ecmascript)");
function computeCacheBustingSearchParam(prefetchHeader, segmentPrefetchHeader, stateTreeHeader, nextUrlHeader) {
    if (prefetchHeader === undefined && segmentPrefetchHeader === undefined && stateTreeHeader === undefined && nextUrlHeader === undefined) {
        return '';
    }
    return (0, _hash.hexHash)([
        prefetchHeader || '0',
        segmentPrefetchHeader || '0',
        stateTreeHeader || '0',
        nextUrlHeader || '0'
    ].join(','));
} //# sourceMappingURL=cache-busting-search-param.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/set-cache-busting-search-param.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    setCacheBustingSearchParam: null,
    setCacheBustingSearchParamWithHash: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    setCacheBustingSearchParam: function() {
        return setCacheBustingSearchParam;
    },
    setCacheBustingSearchParamWithHash: function() {
        return setCacheBustingSearchParamWithHash;
    }
});
const _cachebustingsearchparam = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/cache-busting-search-param.js [app-ssr] (ecmascript)");
const _approuterheaders = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/app-router-headers.js [app-ssr] (ecmascript)");
const setCacheBustingSearchParam = (url, headers)=>{
    const uniqueCacheKey = (0, _cachebustingsearchparam.computeCacheBustingSearchParam)(headers[_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER], headers[_approuterheaders.NEXT_ROUTER_SEGMENT_PREFETCH_HEADER], headers[_approuterheaders.NEXT_ROUTER_STATE_TREE_HEADER], headers[_approuterheaders.NEXT_URL]);
    setCacheBustingSearchParamWithHash(url, uniqueCacheKey);
};
const setCacheBustingSearchParamWithHash = (url, hash)=>{
    /**
   * Note that we intentionally do not use `url.searchParams.set` here:
   *
   * const url = new URL('https://example.com/search?q=custom%20spacing');
   * url.searchParams.set('_rsc', 'abc123');
   * console.log(url.toString()); // Outputs: https://example.com/search?q=custom+spacing&_rsc=abc123
   *                                                                             ^ <--- this is causing confusion
   * This is in fact intended based on https://url.spec.whatwg.org/#interface-urlsearchparams, but
   * we want to preserve the %20 as %20 if that's what the user passed in, hence the custom
   * logic below.
   */ const existingSearch = url.search;
    const rawQuery = existingSearch.startsWith('?') ? existingSearch.slice(1) : existingSearch;
    // Always remove any existing cache busting param and add a fresh one to ensure
    // we have the correct value based on current request headers
    const pairs = rawQuery.split('&').filter((pair)=>pair && !pair.startsWith("" + _approuterheaders.NEXT_RSC_UNION_QUERY + "="));
    if (hash.length > 0) {
        pairs.push(_approuterheaders.NEXT_RSC_UNION_QUERY + "=" + hash);
    } else {
        pairs.push("" + _approuterheaders.NEXT_RSC_UNION_QUERY);
    }
    url.search = pairs.length ? "?" + pairs.join('&') : '';
};
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=set-cache-busting-search-param.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/fetch-server-response.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    createFetch: null,
    createFromNextReadableStream: null,
    fetchServerResponse: null,
    urlToUrlWithoutFlightMarker: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    createFetch: function() {
        return createFetch;
    },
    createFromNextReadableStream: function() {
        return createFromNextReadableStream;
    },
    fetchServerResponse: function() {
        return fetchServerResponse;
    },
    urlToUrlWithoutFlightMarker: function() {
        return urlToUrlWithoutFlightMarker;
    }
});
const _client = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-server-dom-turbopack-client.js [app-ssr] (ecmascript)");
const _approuterheaders = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/app-router-headers.js [app-ssr] (ecmascript)");
const _appcallserver = __turbopack_context__.r("[project]/node_modules/next/dist/client/app-call-server.js [app-ssr] (ecmascript)");
const _appfindsourcemapurl = __turbopack_context__.r("[project]/node_modules/next/dist/client/app-find-source-map-url.js [app-ssr] (ecmascript)");
const _routerreducertypes = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/router-reducer-types.js [app-ssr] (ecmascript)");
const _flightdatahelpers = __turbopack_context__.r("[project]/node_modules/next/dist/client/flight-data-helpers.js [app-ssr] (ecmascript)");
const _appbuildid = __turbopack_context__.r("[project]/node_modules/next/dist/client/app-build-id.js [app-ssr] (ecmascript)");
const _setcachebustingsearchparam = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/set-cache-busting-search-param.js [app-ssr] (ecmascript)");
const createFromReadableStream = _client.createFromReadableStream;
function urlToUrlWithoutFlightMarker(url) {
    const urlWithoutFlightParameters = new URL(url, location.origin);
    urlWithoutFlightParameters.searchParams.delete(_approuterheaders.NEXT_RSC_UNION_QUERY);
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    return urlWithoutFlightParameters;
}
function doMpaNavigation(url) {
    return {
        flightData: urlToUrlWithoutFlightMarker(url).toString(),
        canonicalUrl: undefined,
        couldBeIntercepted: false,
        prerendered: false,
        postponed: false,
        staleTime: -1
    };
}
let abortController = new AbortController();
if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
async function fetchServerResponse(url, options) {
    const { flightRouterState, nextUrl, prefetchKind } = options;
    const headers = {
        // Enable flight response
        [_approuterheaders.RSC_HEADER]: '1',
        // Provide the current router state
        [_approuterheaders.NEXT_ROUTER_STATE_TREE_HEADER]: (0, _flightdatahelpers.prepareFlightRouterStateForRequest)(flightRouterState, options.isHmrRefresh)
    };
    /**
   * Three cases:
   * - `prefetchKind` is `undefined`, it means it's a normal navigation, so we want to prefetch the page data fully
   * - `prefetchKind` is `full` - we want to prefetch the whole page so same as above
   * - `prefetchKind` is `auto` - if the page is dynamic, prefetch the page data partially, if static prefetch the page data fully
   */ if (prefetchKind === _routerreducertypes.PrefetchKind.AUTO) {
        headers[_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER] = '1';
    }
    if (("TURBOPACK compile-time value", "development") === 'development' && options.isHmrRefresh) {
        headers[_approuterheaders.NEXT_HMR_REFRESH_HEADER] = '1';
    }
    if (nextUrl) {
        headers[_approuterheaders.NEXT_URL] = nextUrl;
    }
    try {
        var _res_headers_get;
        // When creating a "temporary" prefetch (the "on-demand" prefetch that gets created on navigation, if one doesn't exist)
        // we send the request with a "high" priority as it's in response to a user interaction that could be blocking a transition.
        // Otherwise, all other prefetches are sent with a "low" priority.
        // We use "auto" for in all other cases to match the existing default, as this function is shared outside of prefetching.
        const fetchPriority = prefetchKind ? prefetchKind === _routerreducertypes.PrefetchKind.TEMPORARY ? 'high' : 'low' : 'auto';
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        const res = await createFetch(url, headers, fetchPriority, abortController.signal);
        const responseUrl = urlToUrlWithoutFlightMarker(res.url);
        const canonicalUrl = res.redirected ? responseUrl : undefined;
        const contentType = res.headers.get('content-type') || '';
        const interception = !!((_res_headers_get = res.headers.get('vary')) == null ? void 0 : _res_headers_get.includes(_approuterheaders.NEXT_URL));
        const postponed = !!res.headers.get(_approuterheaders.NEXT_DID_POSTPONE_HEADER);
        const staleTimeHeaderSeconds = res.headers.get(_approuterheaders.NEXT_ROUTER_STALE_TIME_HEADER);
        const staleTime = staleTimeHeaderSeconds !== null ? parseInt(staleTimeHeaderSeconds, 10) * 1000 : -1;
        let isFlightResponse = contentType.startsWith(_approuterheaders.RSC_CONTENT_TYPE_HEADER);
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        // If fetch returns something different than flight response handle it like a mpa navigation
        // If the fetch was not 200, we also handle it like a mpa navigation
        if (!isFlightResponse || !res.ok || !res.body) {
            // in case the original URL came with a hash, preserve it before redirecting to the new URL
            if (url.hash) {
                responseUrl.hash = url.hash;
            }
            return doMpaNavigation(responseUrl.toString());
        }
        // We may navigate to a page that requires a different Webpack runtime.
        // In prod, every page will have the same Webpack runtime.
        // In dev, the Webpack runtime is minimal for each page.
        // We need to ensure the Webpack runtime is updated before executing client-side JS of the new page.
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        // Handle the `fetch` readable stream that can be unwrapped by `React.use`.
        const flightStream = postponed ? createUnclosingPrefetchStream(res.body) : res.body;
        const response = await createFromNextReadableStream(flightStream);
        if ((0, _appbuildid.getAppBuildId)() !== response.b) {
            return doMpaNavigation(res.url);
        }
        return {
            flightData: (0, _flightdatahelpers.normalizeFlightData)(response.f),
            canonicalUrl: canonicalUrl,
            couldBeIntercepted: interception,
            prerendered: response.S,
            postponed,
            staleTime
        };
    } catch (err) {
        if (!abortController.signal.aborted) {
            console.error("Failed to fetch RSC payload for " + url + ". Falling back to browser navigation.", err);
        }
        // If fetch fails handle it like a mpa navigation
        // TODO-APP: Add a test for the case where a CORS request fails, e.g. external url redirect coming from the response.
        // See https://github.com/vercel/next.js/issues/43605#issuecomment-1451617521 for a reproduction.
        return {
            flightData: url.toString(),
            canonicalUrl: undefined,
            couldBeIntercepted: false,
            prerendered: false,
            postponed: false,
            staleTime: -1
        };
    }
}
async function createFetch(url, headers, fetchPriority, signal) {
    // TODO: In output: "export" mode, the headers do nothing. Omit them (and the
    // cache busting search param) from the request so they're
    // maximally cacheable.
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    const fetchOptions = {
        // Backwards compat for older browsers. `same-origin` is the default in modern browsers.
        credentials: 'same-origin',
        headers,
        priority: fetchPriority || undefined,
        signal
    };
    // `fetchUrl` is slightly different from `url` because we add a cache-busting
    // search param to it. This should not leak outside of this function, so we
    // track them separately.
    let fetchUrl = new URL(url);
    (0, _setcachebustingsearchparam.setCacheBustingSearchParam)(fetchUrl, headers);
    let browserResponse = await fetch(fetchUrl, fetchOptions);
    // If the server responds with a redirect (e.g. 307), and the redirected
    // location does not contain the cache busting search param set in the
    // original request, the response is likely invalid  when following the
    // redirect, the browser forwards the request headers, but since the cache
    // busting search param is missing, the server will reject the request due to
    // a mismatch.
    //
    // Ideally, we would be able to intercept the redirect response and perform it
    // manually, instead of letting the browser automatically follow it, but this
    // is not allowed by the fetch API.
    //
    // So instead, we must "replay" the redirect by fetching the new location
    // again, but this time we'll append the cache busting search param to prevent
    // a mismatch.
    //
    // TODO: We can optimize Next.js's built-in middleware APIs by returning a
    // custom status code, to prevent the browser from automatically following it.
    //
    // This does not affect Server Action-based redirects; those are encoded
    // differently, as part of the Flight body. It only affects redirects that
    // occur in a middleware or a third-party proxy.
    let redirected = browserResponse.redirected;
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    // Remove the cache busting search param from the response URL, to prevent it
    // from leaking outside of this function.
    const responseUrl = new URL(browserResponse.url, fetchUrl);
    responseUrl.searchParams.delete(_approuterheaders.NEXT_RSC_UNION_QUERY);
    const rscResponse = {
        url: responseUrl.href,
        // This is true if any redirects occurred, either automatically by the
        // browser, or manually by us. So it's different from
        // `browserResponse.redirected`, which only tells us whether the browser
        // followed a redirect, and only for the last response in the chain.
        redirected,
        // These can be copied from the last browser response we received. We
        // intentionally only expose the subset of fields that are actually used
        // elsewhere in the codebase.
        ok: browserResponse.ok,
        headers: browserResponse.headers,
        body: browserResponse.body,
        status: browserResponse.status
    };
    return rscResponse;
}
function createFromNextReadableStream(flightStream) {
    return createFromReadableStream(flightStream, {
        callServer: _appcallserver.callServer,
        findSourceMapURL: _appfindsourcemapurl.findSourceMapURL
    });
}
function createUnclosingPrefetchStream(originalFlightStream) {
    // When PPR is enabled, prefetch streams may contain references that never
    // resolve, because that's how we encode dynamic data access. In the decoded
    // object returned by the Flight client, these are reified into hanging
    // promises that suspend during render, which is effectively what we want.
    // The UI resolves when it switches to the dynamic data stream
    // (via useDeferredValue(dynamic, static)).
    //
    // However, the Flight implementation currently errors if the server closes
    // the response before all the references are resolved. As a cheat to work
    // around this, we wrap the original stream in a new stream that never closes,
    // and therefore doesn't error.
    const reader = originalFlightStream.getReader();
    return new ReadableStream({
        async pull (controller) {
            while(true){
                const { done, value } = await reader.read();
                if (!done) {
                    // Pass to the target stream and keep consuming the Flight response
                    // from the server.
                    controller.enqueue(value);
                    continue;
                }
                // The server stream has closed. Exit, but intentionally do not close
                // the target stream.
                return;
            }
        }
    });
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=fetch-server-response.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/create-href-from-url.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "createHrefFromUrl", {
    enumerable: true,
    get: function() {
        return createHrefFromUrl;
    }
});
function createHrefFromUrl(url, includeHash) {
    if (includeHash === void 0) includeHash = true;
    return url.pathname + url.search + (includeHash ? url.hash : '');
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=create-href-from-url.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "createRouterCacheKey", {
    enumerable: true,
    get: function() {
        return createRouterCacheKey;
    }
});
const _segment = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/segment.js [app-ssr] (ecmascript)");
function createRouterCacheKey(segment, withoutSearchParameters) {
    if (withoutSearchParameters === void 0) withoutSearchParameters = false;
    // if the segment is an array, it means it's a dynamic segment
    // for example, ['lang', 'en', 'd']. We need to convert it to a string to store it as a cache node key.
    if (Array.isArray(segment)) {
        return segment[0] + "|" + segment[1] + "|" + segment[2];
    }
    // Page segments might have search parameters, ie __PAGE__?foo=bar
    // When `withoutSearchParameters` is true, we only want to return the page segment
    if (withoutSearchParameters && segment.startsWith(_segment.PAGE_SEGMENT_KEY)) {
        return _segment.PAGE_SEGMENT_KEY;
    }
    return segment;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=create-router-cache-key.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/invalidate-cache-below-flight-segmentpath.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "invalidateCacheBelowFlightSegmentPath", {
    enumerable: true,
    get: function() {
        return invalidateCacheBelowFlightSegmentPath;
    }
});
const _createroutercachekey = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js [app-ssr] (ecmascript)");
const _flightdatahelpers = __turbopack_context__.r("[project]/node_modules/next/dist/client/flight-data-helpers.js [app-ssr] (ecmascript)");
function invalidateCacheBelowFlightSegmentPath(newCache, existingCache, flightSegmentPath) {
    const isLastEntry = flightSegmentPath.length <= 2;
    const [parallelRouteKey, segment] = flightSegmentPath;
    const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(segment);
    const existingChildSegmentMap = existingCache.parallelRoutes.get(parallelRouteKey);
    if (!existingChildSegmentMap) {
        // Bailout because the existing cache does not have the path to the leaf node
        // Will trigger lazy fetch in layout-router because of missing segment
        return;
    }
    let childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey);
    if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {
        childSegmentMap = new Map(existingChildSegmentMap);
        newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap);
    }
    // In case of last entry don't copy further down.
    if (isLastEntry) {
        childSegmentMap.delete(cacheKey);
        return;
    }
    const existingChildCacheNode = existingChildSegmentMap.get(cacheKey);
    let childCacheNode = childSegmentMap.get(cacheKey);
    if (!childCacheNode || !existingChildCacheNode) {
        // Bailout because the existing cache does not have the path to the leaf node
        // Will trigger lazy fetch in layout-router because of missing segment
        return;
    }
    if (childCacheNode === existingChildCacheNode) {
        childCacheNode = {
            lazyData: childCacheNode.lazyData,
            rsc: childCacheNode.rsc,
            prefetchRsc: childCacheNode.prefetchRsc,
            head: childCacheNode.head,
            prefetchHead: childCacheNode.prefetchHead,
            parallelRoutes: new Map(childCacheNode.parallelRoutes)
        };
        childSegmentMap.set(cacheKey, childCacheNode);
    }
    invalidateCacheBelowFlightSegmentPath(childCacheNode, existingChildCacheNode, (0, _flightdatahelpers.getNextFlightSegmentPath)(flightSegmentPath));
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=invalidate-cache-below-flight-segmentpath.js.map
}}),
"[project]/node_modules/next/dist/client/components/match-segments.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "matchSegment", {
    enumerable: true,
    get: function() {
        return matchSegment;
    }
});
const matchSegment = (existingSegment, segment)=>{
    // segment is either Array or string
    if (typeof existingSegment === 'string') {
        if (typeof segment === 'string') {
            // Common case: segment is just a string
            return existingSegment === segment;
        }
        return false;
    }
    if (typeof segment === 'string') {
        return false;
    }
    return existingSegment[0] === segment[0] && existingSegment[1] === segment[1];
};
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=match-segments.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "fillLazyItemsTillLeafWithHead", {
    enumerable: true,
    get: function() {
        return fillLazyItemsTillLeafWithHead;
    }
});
const _createroutercachekey = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js [app-ssr] (ecmascript)");
const _routerreducertypes = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/router-reducer-types.js [app-ssr] (ecmascript)");
function fillLazyItemsTillLeafWithHead(navigatedAt, newCache, existingCache, routerState, cacheNodeSeedData, head, prefetchEntry) {
    const isLastSegment = Object.keys(routerState[1]).length === 0;
    if (isLastSegment) {
        newCache.head = head;
        return;
    }
    // Remove segment that we got data for so that it is filled in during rendering of rsc.
    for(const key in routerState[1]){
        const parallelRouteState = routerState[1][key];
        const segmentForParallelRoute = parallelRouteState[0];
        const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(segmentForParallelRoute);
        // TODO: We should traverse the cacheNodeSeedData tree instead of the router
        // state tree. Ideally, they would always be the same shape, but because of
        // the loading.js pattern, cacheNodeSeedData sometimes only represents a
        // partial tree. That's why this node is sometimes null. Once PPR lands,
        // loading.js will no longer have special behavior and we can traverse the
        // data tree instead.
        //
        // We should also consider merging the router state tree and the data tree
        // in the response format, so that we don't have to send the keys twice.
        // Then the client can convert them into separate representations.
        const parallelSeedData = cacheNodeSeedData !== null && cacheNodeSeedData[2][key] !== undefined ? cacheNodeSeedData[2][key] : null;
        if (existingCache) {
            const existingParallelRoutesCacheNode = existingCache.parallelRoutes.get(key);
            if (existingParallelRoutesCacheNode) {
                const hasReusablePrefetch = (prefetchEntry == null ? void 0 : prefetchEntry.kind) === 'auto' && prefetchEntry.status === _routerreducertypes.PrefetchCacheEntryStatus.reusable;
                let parallelRouteCacheNode = new Map(existingParallelRoutesCacheNode);
                const existingCacheNode = parallelRouteCacheNode.get(cacheKey);
                let newCacheNode;
                if (parallelSeedData !== null) {
                    // New data was sent from the server.
                    const seedNode = parallelSeedData[1];
                    const loading = parallelSeedData[3];
                    newCacheNode = {
                        lazyData: null,
                        rsc: seedNode,
                        // This is a PPR-only field. When PPR is enabled, we shouldn't hit
                        // this path during a navigation, but until PPR is fully implemented
                        // yet it's possible the existing node does have a non-null
                        // `prefetchRsc`. As an incremental step, we'll just de-opt to the
                        // old behavior  no PPR value.
                        prefetchRsc: null,
                        head: null,
                        prefetchHead: null,
                        loading,
                        parallelRoutes: new Map(existingCacheNode == null ? void 0 : existingCacheNode.parallelRoutes),
                        navigatedAt
                    };
                } else if (hasReusablePrefetch && existingCacheNode) {
                    // No new data was sent from the server, but the existing cache node
                    // was prefetched, so we should reuse that.
                    newCacheNode = {
                        lazyData: existingCacheNode.lazyData,
                        rsc: existingCacheNode.rsc,
                        // This is a PPR-only field. Unlike the previous branch, since we're
                        // just cloning the existing cache node, we might as well keep the
                        // PPR value, if it exists.
                        prefetchRsc: existingCacheNode.prefetchRsc,
                        head: existingCacheNode.head,
                        prefetchHead: existingCacheNode.prefetchHead,
                        parallelRoutes: new Map(existingCacheNode.parallelRoutes),
                        loading: existingCacheNode.loading
                    };
                } else {
                    // No data available for this node. This will trigger a lazy fetch
                    // during render.
                    newCacheNode = {
                        lazyData: null,
                        rsc: null,
                        prefetchRsc: null,
                        head: null,
                        prefetchHead: null,
                        parallelRoutes: new Map(existingCacheNode == null ? void 0 : existingCacheNode.parallelRoutes),
                        loading: null,
                        navigatedAt
                    };
                }
                // Overrides the cache key with the new cache node.
                parallelRouteCacheNode.set(cacheKey, newCacheNode);
                // Traverse deeper to apply the head / fill lazy items till the head.
                fillLazyItemsTillLeafWithHead(navigatedAt, newCacheNode, existingCacheNode, parallelRouteState, parallelSeedData ? parallelSeedData : null, head, prefetchEntry);
                newCache.parallelRoutes.set(key, parallelRouteCacheNode);
                continue;
            }
        }
        let newCacheNode;
        if (parallelSeedData !== null) {
            // New data was sent from the server.
            const seedNode = parallelSeedData[1];
            const loading = parallelSeedData[3];
            newCacheNode = {
                lazyData: null,
                rsc: seedNode,
                prefetchRsc: null,
                head: null,
                prefetchHead: null,
                parallelRoutes: new Map(),
                loading,
                navigatedAt
            };
        } else {
            // No data available for this node. This will trigger a lazy fetch
            // during render.
            newCacheNode = {
                lazyData: null,
                rsc: null,
                prefetchRsc: null,
                head: null,
                prefetchHead: null,
                parallelRoutes: new Map(),
                loading: null,
                navigatedAt
            };
        }
        const existingParallelRoutes = newCache.parallelRoutes.get(key);
        if (existingParallelRoutes) {
            existingParallelRoutes.set(cacheKey, newCacheNode);
        } else {
            newCache.parallelRoutes.set(key, new Map([
                [
                    cacheKey,
                    newCacheNode
                ]
            ]));
        }
        fillLazyItemsTillLeafWithHead(navigatedAt, newCacheNode, undefined, parallelRouteState, parallelSeedData, head, prefetchEntry);
    }
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=fill-lazy-items-till-leaf-with-head.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/invalidate-cache-by-router-state.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "invalidateCacheByRouterState", {
    enumerable: true,
    get: function() {
        return invalidateCacheByRouterState;
    }
});
const _createroutercachekey = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js [app-ssr] (ecmascript)");
function invalidateCacheByRouterState(newCache, existingCache, routerState) {
    // Remove segment that we got data for so that it is filled in during rendering of rsc.
    for(const key in routerState[1]){
        const segmentForParallelRoute = routerState[1][key][0];
        const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(segmentForParallelRoute);
        const existingParallelRoutesCacheNode = existingCache.parallelRoutes.get(key);
        if (existingParallelRoutesCacheNode) {
            let parallelRouteCacheNode = new Map(existingParallelRoutesCacheNode);
            parallelRouteCacheNode.delete(cacheKey);
            newCache.parallelRoutes.set(key, parallelRouteCacheNode);
        }
    }
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=invalidate-cache-by-router-state.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/fill-cache-with-new-subtree-data.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    fillCacheWithNewSubTreeData: null,
    fillCacheWithNewSubTreeDataButOnlyLoading: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    fillCacheWithNewSubTreeData: function() {
        return fillCacheWithNewSubTreeData;
    },
    fillCacheWithNewSubTreeDataButOnlyLoading: function() {
        return fillCacheWithNewSubTreeDataButOnlyLoading;
    }
});
const _invalidatecachebyrouterstate = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/invalidate-cache-by-router-state.js [app-ssr] (ecmascript)");
const _filllazyitemstillleafwithhead = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js [app-ssr] (ecmascript)");
const _createroutercachekey = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js [app-ssr] (ecmascript)");
const _segment = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/segment.js [app-ssr] (ecmascript)");
/**
 * Common logic for filling cache with new sub tree data.
 */ function fillCacheHelper(navigatedAt, newCache, existingCache, flightData, prefetchEntry, fillLazyItems) {
    const { segmentPath, seedData: cacheNodeSeedData, tree: treePatch, head } = flightData;
    let newCacheNode = newCache;
    let existingCacheNode = existingCache;
    for(let i = 0; i < segmentPath.length; i += 2){
        const parallelRouteKey = segmentPath[i];
        const segment = segmentPath[i + 1];
        // segmentPath is a repeating tuple of parallelRouteKey and segment
        // we know we've hit the last entry we've reached our final pair
        const isLastEntry = i === segmentPath.length - 2;
        const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(segment);
        const existingChildSegmentMap = existingCacheNode.parallelRoutes.get(parallelRouteKey);
        if (!existingChildSegmentMap) {
            continue;
        }
        let childSegmentMap = newCacheNode.parallelRoutes.get(parallelRouteKey);
        if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {
            childSegmentMap = new Map(existingChildSegmentMap);
            newCacheNode.parallelRoutes.set(parallelRouteKey, childSegmentMap);
        }
        const existingChildCacheNode = existingChildSegmentMap.get(cacheKey);
        let childCacheNode = childSegmentMap.get(cacheKey);
        if (isLastEntry) {
            if (cacheNodeSeedData && (!childCacheNode || !childCacheNode.lazyData || childCacheNode === existingChildCacheNode)) {
                const incomingSegment = cacheNodeSeedData[0];
                const rsc = cacheNodeSeedData[1];
                const loading = cacheNodeSeedData[3];
                childCacheNode = {
                    lazyData: null,
                    // When `fillLazyItems` is false, we only want to fill the RSC data for the layout,
                    // not the page segment.
                    rsc: fillLazyItems || incomingSegment !== _segment.PAGE_SEGMENT_KEY ? rsc : null,
                    prefetchRsc: null,
                    head: null,
                    prefetchHead: null,
                    loading,
                    parallelRoutes: fillLazyItems && existingChildCacheNode ? new Map(existingChildCacheNode.parallelRoutes) : new Map(),
                    navigatedAt
                };
                if (existingChildCacheNode && fillLazyItems) {
                    (0, _invalidatecachebyrouterstate.invalidateCacheByRouterState)(childCacheNode, existingChildCacheNode, treePatch);
                }
                if (fillLazyItems) {
                    (0, _filllazyitemstillleafwithhead.fillLazyItemsTillLeafWithHead)(navigatedAt, childCacheNode, existingChildCacheNode, treePatch, cacheNodeSeedData, head, prefetchEntry);
                }
                childSegmentMap.set(cacheKey, childCacheNode);
            }
            continue;
        }
        if (!childCacheNode || !existingChildCacheNode) {
            continue;
        }
        if (childCacheNode === existingChildCacheNode) {
            childCacheNode = {
                lazyData: childCacheNode.lazyData,
                rsc: childCacheNode.rsc,
                prefetchRsc: childCacheNode.prefetchRsc,
                head: childCacheNode.head,
                prefetchHead: childCacheNode.prefetchHead,
                parallelRoutes: new Map(childCacheNode.parallelRoutes),
                loading: childCacheNode.loading
            };
            childSegmentMap.set(cacheKey, childCacheNode);
        }
        // Move deeper into the cache nodes
        newCacheNode = childCacheNode;
        existingCacheNode = existingChildCacheNode;
    }
}
function fillCacheWithNewSubTreeData(navigatedAt, newCache, existingCache, flightData, prefetchEntry) {
    fillCacheHelper(navigatedAt, newCache, existingCache, flightData, prefetchEntry, true);
}
function fillCacheWithNewSubTreeDataButOnlyLoading(navigatedAt, newCache, existingCache, flightData, prefetchEntry) {
    fillCacheHelper(navigatedAt, newCache, existingCache, flightData, prefetchEntry, false);
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=fill-cache-with-new-subtree-data.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/apply-flight-data.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "applyFlightData", {
    enumerable: true,
    get: function() {
        return applyFlightData;
    }
});
const _filllazyitemstillleafwithhead = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js [app-ssr] (ecmascript)");
const _fillcachewithnewsubtreedata = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/fill-cache-with-new-subtree-data.js [app-ssr] (ecmascript)");
function applyFlightData(navigatedAt, existingCache, cache, flightData, prefetchEntry) {
    // The one before last item is the router state tree patch
    const { tree: treePatch, seedData, head, isRootRender } = flightData;
    // Handles case where prefetch only returns the router tree patch without rendered components.
    if (seedData === null) {
        return false;
    }
    if (isRootRender) {
        const rsc = seedData[1];
        const loading = seedData[3];
        cache.loading = loading;
        cache.rsc = rsc;
        // This is a PPR-only field. When PPR is enabled, we shouldn't hit
        // this path during a navigation, but until PPR is fully implemented
        // yet it's possible the existing node does have a non-null
        // `prefetchRsc`. As an incremental step, we'll just de-opt to the
        // old behavior  no PPR value.
        cache.prefetchRsc = null;
        (0, _filllazyitemstillleafwithhead.fillLazyItemsTillLeafWithHead)(navigatedAt, cache, existingCache, treePatch, seedData, head, prefetchEntry);
    } else {
        // Copy rsc for the root node of the cache.
        cache.rsc = existingCache.rsc;
        // This is a PPR-only field. Unlike the previous branch, since we're
        // just cloning the existing cache node, we might as well keep the
        // PPR value, if it exists.
        cache.prefetchRsc = existingCache.prefetchRsc;
        cache.parallelRoutes = new Map(existingCache.parallelRoutes);
        cache.loading = existingCache.loading;
        // Create a copy of the existing cache with the rsc applied.
        (0, _fillcachewithnewsubtreedata.fillCacheWithNewSubTreeData)(navigatedAt, cache, existingCache, flightData, prefetchEntry);
    }
    return true;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=apply-flight-data.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/refetch-inactive-parallel-segments.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    addRefreshMarkerToActiveParallelSegments: null,
    refreshInactiveParallelSegments: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    addRefreshMarkerToActiveParallelSegments: function() {
        return addRefreshMarkerToActiveParallelSegments;
    },
    refreshInactiveParallelSegments: function() {
        return refreshInactiveParallelSegments;
    }
});
const _applyflightdata = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/apply-flight-data.js [app-ssr] (ecmascript)");
const _fetchserverresponse = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/fetch-server-response.js [app-ssr] (ecmascript)");
const _segment = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/segment.js [app-ssr] (ecmascript)");
async function refreshInactiveParallelSegments(options) {
    const fetchedSegments = new Set();
    await refreshInactiveParallelSegmentsImpl({
        ...options,
        rootTree: options.updatedTree,
        fetchedSegments
    });
}
async function refreshInactiveParallelSegmentsImpl(param) {
    let { navigatedAt, state, updatedTree, updatedCache, includeNextUrl, fetchedSegments, rootTree = updatedTree, canonicalUrl } = param;
    const [, parallelRoutes, refetchPath, refetchMarker] = updatedTree;
    const fetchPromises = [];
    if (refetchPath && refetchPath !== canonicalUrl && refetchMarker === 'refresh' && // it's possible for the tree to contain multiple segments that contain data at the same URL
    // we keep track of them so we can dedupe the requests
    !fetchedSegments.has(refetchPath)) {
        fetchedSegments.add(refetchPath) // Mark this URL as fetched
        ;
        // Eagerly kick off the fetch for the refetch path & the parallel routes. This should be fine to do as they each operate
        // independently on their own cache nodes, and `applyFlightData` will copy anything it doesn't care about from the existing cache.
        const fetchPromise = (0, _fetchserverresponse.fetchServerResponse)(new URL(refetchPath, location.origin), {
            // refetch from the root of the updated tree, otherwise it will be scoped to the current segment
            // and might not contain the data we need to patch in interception route data (such as dynamic params from a previous segment)
            flightRouterState: [
                rootTree[0],
                rootTree[1],
                rootTree[2],
                'refetch'
            ],
            nextUrl: includeNextUrl ? state.nextUrl : null
        }).then((param)=>{
            let { flightData } = param;
            if (typeof flightData !== 'string') {
                for (const flightDataPath of flightData){
                    // we only pass the new cache as this function is called after clearing the router cache
                    // and filling in the new page data from the server. Meaning the existing cache is actually the cache that's
                    // just been created & has been written to, but hasn't been "committed" yet.
                    (0, _applyflightdata.applyFlightData)(navigatedAt, updatedCache, updatedCache, flightDataPath);
                }
            } else {
            // When flightData is a string, it suggests that the server response should have triggered an MPA navigation
            // I'm not 100% sure of this decision, but it seems unlikely that we'd want to introduce a redirect side effect
            // when refreshing on-screen data, so handling this has been ommitted.
            }
        });
        fetchPromises.push(fetchPromise);
    }
    for(const key in parallelRoutes){
        const parallelFetchPromise = refreshInactiveParallelSegmentsImpl({
            navigatedAt,
            state,
            updatedTree: parallelRoutes[key],
            updatedCache,
            includeNextUrl,
            fetchedSegments,
            rootTree,
            canonicalUrl
        });
        fetchPromises.push(parallelFetchPromise);
    }
    await Promise.all(fetchPromises);
}
function addRefreshMarkerToActiveParallelSegments(tree, path) {
    const [segment, parallelRoutes, , refetchMarker] = tree;
    // a page segment might also contain concatenated search params, so we do a partial match on the key
    if (segment.includes(_segment.PAGE_SEGMENT_KEY) && refetchMarker !== 'refresh') {
        tree[2] = path;
        tree[3] = 'refresh';
    }
    for(const key in parallelRoutes){
        addRefreshMarkerToActiveParallelSegments(parallelRoutes[key], path);
    }
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=refetch-inactive-parallel-segments.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "applyRouterStatePatchToTree", {
    enumerable: true,
    get: function() {
        return applyRouterStatePatchToTree;
    }
});
const _segment = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/segment.js [app-ssr] (ecmascript)");
const _flightdatahelpers = __turbopack_context__.r("[project]/node_modules/next/dist/client/flight-data-helpers.js [app-ssr] (ecmascript)");
const _matchsegments = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/match-segments.js [app-ssr] (ecmascript)");
const _refetchinactiveparallelsegments = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/refetch-inactive-parallel-segments.js [app-ssr] (ecmascript)");
/**
 * Deep merge of the two router states. Parallel route keys are preserved if the patch doesn't have them.
 */ function applyPatch(initialTree, patchTree) {
    const [initialSegment, initialParallelRoutes] = initialTree;
    const [patchSegment, patchParallelRoutes] = patchTree;
    // if the applied patch segment is __DEFAULT__ then it can be ignored in favor of the initial tree
    // this is because the __DEFAULT__ segment is used as a placeholder on navigation
    if (patchSegment === _segment.DEFAULT_SEGMENT_KEY && initialSegment !== _segment.DEFAULT_SEGMENT_KEY) {
        return initialTree;
    }
    if ((0, _matchsegments.matchSegment)(initialSegment, patchSegment)) {
        const newParallelRoutes = {};
        for(const key in initialParallelRoutes){
            const isInPatchTreeParallelRoutes = typeof patchParallelRoutes[key] !== 'undefined';
            if (isInPatchTreeParallelRoutes) {
                newParallelRoutes[key] = applyPatch(initialParallelRoutes[key], patchParallelRoutes[key]);
            } else {
                newParallelRoutes[key] = initialParallelRoutes[key];
            }
        }
        for(const key in patchParallelRoutes){
            if (newParallelRoutes[key]) {
                continue;
            }
            newParallelRoutes[key] = patchParallelRoutes[key];
        }
        const tree = [
            initialSegment,
            newParallelRoutes
        ];
        // Copy over the existing tree
        if (initialTree[2]) {
            tree[2] = initialTree[2];
        }
        if (initialTree[3]) {
            tree[3] = initialTree[3];
        }
        if (initialTree[4]) {
            tree[4] = initialTree[4];
        }
        return tree;
    }
    return patchTree;
}
function applyRouterStatePatchToTree(flightSegmentPath, flightRouterState, treePatch, path) {
    const [segment, parallelRoutes, url, refetch, isRootLayout] = flightRouterState;
    // Root refresh
    if (flightSegmentPath.length === 1) {
        const tree = applyPatch(flightRouterState, treePatch);
        (0, _refetchinactiveparallelsegments.addRefreshMarkerToActiveParallelSegments)(tree, path);
        return tree;
    }
    const [currentSegment, parallelRouteKey] = flightSegmentPath;
    // Tree path returned from the server should always match up with the current tree in the browser
    if (!(0, _matchsegments.matchSegment)(currentSegment, segment)) {
        return null;
    }
    const lastSegment = flightSegmentPath.length === 2;
    let parallelRoutePatch;
    if (lastSegment) {
        parallelRoutePatch = applyPatch(parallelRoutes[parallelRouteKey], treePatch);
    } else {
        parallelRoutePatch = applyRouterStatePatchToTree((0, _flightdatahelpers.getNextFlightSegmentPath)(flightSegmentPath), parallelRoutes[parallelRouteKey], treePatch, path);
        if (parallelRoutePatch === null) {
            return null;
        }
    }
    const tree = [
        flightSegmentPath[0],
        {
            ...parallelRoutes,
            [parallelRouteKey]: parallelRoutePatch
        },
        url,
        refetch
    ];
    // Current segment is the root layout
    if (isRootLayout) {
        tree[4] = true;
    }
    (0, _refetchinactiveparallelsegments.addRefreshMarkerToActiveParallelSegments)(tree, path);
    return tree;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=apply-router-state-patch-to-tree.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/should-hard-navigate.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "shouldHardNavigate", {
    enumerable: true,
    get: function() {
        return shouldHardNavigate;
    }
});
const _flightdatahelpers = __turbopack_context__.r("[project]/node_modules/next/dist/client/flight-data-helpers.js [app-ssr] (ecmascript)");
const _matchsegments = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/match-segments.js [app-ssr] (ecmascript)");
function shouldHardNavigate(flightSegmentPath, flightRouterState) {
    const [segment, parallelRoutes] = flightRouterState;
    // TODO-APP: Check if `as` can be replaced.
    const [currentSegment, parallelRouteKey] = flightSegmentPath;
    // Check if current segment matches the existing segment.
    if (!(0, _matchsegments.matchSegment)(currentSegment, segment)) {
        // If dynamic parameter in tree doesn't match up with segment path a hard navigation is triggered.
        if (Array.isArray(currentSegment)) {
            return true;
        }
        // If the existing segment did not match soft navigation is triggered.
        return false;
    }
    const lastSegment = flightSegmentPath.length <= 2;
    if (lastSegment) {
        return false;
    }
    return shouldHardNavigate((0, _flightdatahelpers.getNextFlightSegmentPath)(flightSegmentPath), parallelRoutes[parallelRouteKey]);
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=should-hard-navigate.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "isNavigatingToNewRootLayout", {
    enumerable: true,
    get: function() {
        return isNavigatingToNewRootLayout;
    }
});
function isNavigatingToNewRootLayout(currentTree, nextTree) {
    // Compare segments
    const currentTreeSegment = currentTree[0];
    const nextTreeSegment = nextTree[0];
    // If any segment is different before we find the root layout, the root layout has changed.
    // E.g. /same/(group1)/layout.js -> /same/(group2)/layout.js
    // First segment is 'same' for both, keep looking. (group1) changed to (group2) before the root layout was found, it must have changed.
    if (Array.isArray(currentTreeSegment) && Array.isArray(nextTreeSegment)) {
        // Compare dynamic param name and type but ignore the value, different values would not affect the current root layout
        // /[name] - /slug1 and /slug2, both values (slug1 & slug2) still has the same layout /[name]/layout.js
        if (currentTreeSegment[0] !== nextTreeSegment[0] || currentTreeSegment[2] !== nextTreeSegment[2]) {
            return true;
        }
    } else if (currentTreeSegment !== nextTreeSegment) {
        return true;
    }
    // Current tree root layout found
    if (currentTree[4]) {
        // If the next tree doesn't have the root layout flag, it must have changed.
        return !nextTree[4];
    }
    // Current tree didn't have its root layout here, must have changed.
    if (nextTree[4]) {
        return true;
    }
    // We can't assume it's `parallelRoutes.children` here in case the root layout is `app/@something/layout.js`
    // But it's not possible to be more than one parallelRoutes before the root layout is found
    // TODO-APP: change to traverse all parallel routes
    const currentTreeChild = Object.values(currentTree[1])[0];
    const nextTreeChild = Object.values(nextTree[1])[0];
    if (!currentTreeChild || !nextTreeChild) return true;
    return isNavigatingToNewRootLayout(currentTreeChild, nextTreeChild);
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=is-navigating-to-new-root-layout.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/page-path/ensure-leading-slash.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/**
 * For a given page path, this function ensures that there is a leading slash.
 * If there is not a leading slash, one is added, otherwise it is noop.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "ensureLeadingSlash", {
    enumerable: true,
    get: function() {
        return ensureLeadingSlash;
    }
});
function ensureLeadingSlash(path) {
    return path.startsWith('/') ? path : "/" + path;
} //# sourceMappingURL=ensure-leading-slash.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/router/utils/app-paths.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    normalizeAppPath: null,
    normalizeRscURL: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    normalizeAppPath: function() {
        return normalizeAppPath;
    },
    normalizeRscURL: function() {
        return normalizeRscURL;
    }
});
const _ensureleadingslash = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/page-path/ensure-leading-slash.js [app-ssr] (ecmascript)");
const _segment = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/segment.js [app-ssr] (ecmascript)");
function normalizeAppPath(route) {
    return (0, _ensureleadingslash.ensureLeadingSlash)(route.split('/').reduce((pathname, segment, index, segments)=>{
        // Empty segments are ignored.
        if (!segment) {
            return pathname;
        }
        // Groups are ignored.
        if ((0, _segment.isGroupSegment)(segment)) {
            return pathname;
        }
        // Parallel segments are ignored.
        if (segment[0] === '@') {
            return pathname;
        }
        // The last segment (if it's a leaf) should be ignored.
        if ((segment === 'page' || segment === 'route') && index === segments.length - 1) {
            return pathname;
        }
        return pathname + "/" + segment;
    }, ''));
}
function normalizeRscURL(url) {
    return url.replace(/\.rsc($|\?)/, '$1');
} //# sourceMappingURL=app-paths.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/router/utils/interception-routes.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    INTERCEPTION_ROUTE_MARKERS: null,
    extractInterceptionRouteInformation: null,
    isInterceptionRouteAppPath: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    INTERCEPTION_ROUTE_MARKERS: function() {
        return INTERCEPTION_ROUTE_MARKERS;
    },
    extractInterceptionRouteInformation: function() {
        return extractInterceptionRouteInformation;
    },
    isInterceptionRouteAppPath: function() {
        return isInterceptionRouteAppPath;
    }
});
const _apppaths = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/app-paths.js [app-ssr] (ecmascript)");
const INTERCEPTION_ROUTE_MARKERS = [
    '(..)(..)',
    '(.)',
    '(..)',
    '(...)'
];
function isInterceptionRouteAppPath(path) {
    // TODO-APP: add more serious validation
    return path.split('/').find((segment)=>INTERCEPTION_ROUTE_MARKERS.find((m)=>segment.startsWith(m))) !== undefined;
}
function extractInterceptionRouteInformation(path) {
    let interceptingRoute, marker, interceptedRoute;
    for (const segment of path.split('/')){
        marker = INTERCEPTION_ROUTE_MARKERS.find((m)=>segment.startsWith(m));
        if (marker) {
            ;
            [interceptingRoute, interceptedRoute] = path.split(marker, 2);
            break;
        }
    }
    if (!interceptingRoute || !marker || !interceptedRoute) {
        throw Object.defineProperty(new Error("Invalid interception route: " + path + ". Must be in the format /<intercepting route>/(..|...|..)(..)/<intercepted route>"), "__NEXT_ERROR_CODE", {
            value: "E269",
            enumerable: false,
            configurable: true
        });
    }
    interceptingRoute = (0, _apppaths.normalizeAppPath)(interceptingRoute) // normalize the path, e.g. /(blog)/feed -> /feed
    ;
    switch(marker){
        case '(.)':
            // (.) indicates that we should match with sibling routes, so we just need to append the intercepted route to the intercepting route
            if (interceptingRoute === '/') {
                interceptedRoute = "/" + interceptedRoute;
            } else {
                interceptedRoute = interceptingRoute + '/' + interceptedRoute;
            }
            break;
        case '(..)':
            // (..) indicates that we should match at one level up, so we need to remove the last segment of the intercepting route
            if (interceptingRoute === '/') {
                throw Object.defineProperty(new Error("Invalid interception route: " + path + ". Cannot use (..) marker at the root level, use (.) instead."), "__NEXT_ERROR_CODE", {
                    value: "E207",
                    enumerable: false,
                    configurable: true
                });
            }
            interceptedRoute = interceptingRoute.split('/').slice(0, -1).concat(interceptedRoute).join('/');
            break;
        case '(...)':
            // (...) will match the route segment in the root directory, so we need to use the root directory to prepend the intercepted route
            interceptedRoute = '/' + interceptedRoute;
            break;
        case '(..)(..)':
            // (..)(..) indicates that we should match at two levels up, so we need to remove the last two segments of the intercepting route
            const splitInterceptingRoute = interceptingRoute.split('/');
            if (splitInterceptingRoute.length <= 2) {
                throw Object.defineProperty(new Error("Invalid interception route: " + path + ". Cannot use (..)(..) marker at the root level or one level up."), "__NEXT_ERROR_CODE", {
                    value: "E486",
                    enumerable: false,
                    configurable: true
                });
            }
            interceptedRoute = splitInterceptingRoute.slice(0, -2).concat(interceptedRoute).join('/');
            break;
        default:
            throw Object.defineProperty(new Error('Invariant: unexpected marker'), "__NEXT_ERROR_CODE", {
                value: "E112",
                enumerable: false,
                configurable: true
            });
    }
    return {
        interceptingRoute,
        interceptedRoute
    };
} //# sourceMappingURL=interception-routes.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/compute-changed-path.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    computeChangedPath: null,
    extractPathFromFlightRouterState: null,
    getSelectedParams: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    computeChangedPath: function() {
        return computeChangedPath;
    },
    extractPathFromFlightRouterState: function() {
        return extractPathFromFlightRouterState;
    },
    getSelectedParams: function() {
        return getSelectedParams;
    }
});
const _interceptionroutes = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/interception-routes.js [app-ssr] (ecmascript)");
const _segment = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/segment.js [app-ssr] (ecmascript)");
const _matchsegments = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/match-segments.js [app-ssr] (ecmascript)");
const removeLeadingSlash = (segment)=>{
    return segment[0] === '/' ? segment.slice(1) : segment;
};
const segmentToPathname = (segment)=>{
    if (typeof segment === 'string') {
        // 'children' is not a valid path -- it's technically a parallel route that corresponds with the current segment's page
        // if we don't skip it, then the computed pathname might be something like `/children` which doesn't make sense.
        if (segment === 'children') return '';
        return segment;
    }
    return segment[1];
};
function normalizeSegments(segments) {
    return segments.reduce((acc, segment)=>{
        segment = removeLeadingSlash(segment);
        if (segment === '' || (0, _segment.isGroupSegment)(segment)) {
            return acc;
        }
        return acc + "/" + segment;
    }, '') || '/';
}
function extractPathFromFlightRouterState(flightRouterState) {
    const segment = Array.isArray(flightRouterState[0]) ? flightRouterState[0][1] : flightRouterState[0];
    if (segment === _segment.DEFAULT_SEGMENT_KEY || _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.some((m)=>segment.startsWith(m))) return undefined;
    if (segment.startsWith(_segment.PAGE_SEGMENT_KEY)) return '';
    const segments = [
        segmentToPathname(segment)
    ];
    var _flightRouterState_;
    const parallelRoutes = (_flightRouterState_ = flightRouterState[1]) != null ? _flightRouterState_ : {};
    const childrenPath = parallelRoutes.children ? extractPathFromFlightRouterState(parallelRoutes.children) : undefined;
    if (childrenPath !== undefined) {
        segments.push(childrenPath);
    } else {
        for (const [key, value] of Object.entries(parallelRoutes)){
            if (key === 'children') continue;
            const childPath = extractPathFromFlightRouterState(value);
            if (childPath !== undefined) {
                segments.push(childPath);
            }
        }
    }
    return normalizeSegments(segments);
}
function computeChangedPathImpl(treeA, treeB) {
    const [segmentA, parallelRoutesA] = treeA;
    const [segmentB, parallelRoutesB] = treeB;
    const normalizedSegmentA = segmentToPathname(segmentA);
    const normalizedSegmentB = segmentToPathname(segmentB);
    if (_interceptionroutes.INTERCEPTION_ROUTE_MARKERS.some((m)=>normalizedSegmentA.startsWith(m) || normalizedSegmentB.startsWith(m))) {
        return '';
    }
    if (!(0, _matchsegments.matchSegment)(segmentA, segmentB)) {
        var _extractPathFromFlightRouterState;
        // once we find where the tree changed, we compute the rest of the path by traversing the tree
        return (_extractPathFromFlightRouterState = extractPathFromFlightRouterState(treeB)) != null ? _extractPathFromFlightRouterState : '';
    }
    for(const parallelRouterKey in parallelRoutesA){
        if (parallelRoutesB[parallelRouterKey]) {
            const changedPath = computeChangedPathImpl(parallelRoutesA[parallelRouterKey], parallelRoutesB[parallelRouterKey]);
            if (changedPath !== null) {
                return segmentToPathname(segmentB) + "/" + changedPath;
            }
        }
    }
    return null;
}
function computeChangedPath(treeA, treeB) {
    const changedPath = computeChangedPathImpl(treeA, treeB);
    if (changedPath == null || changedPath === '/') {
        return changedPath;
    }
    // lightweight normalization to remove route groups
    return normalizeSegments(changedPath.split('/'));
}
function getSelectedParams(currentTree, params) {
    if (params === void 0) params = {};
    const parallelRoutes = currentTree[1];
    for (const parallelRoute of Object.values(parallelRoutes)){
        const segment = parallelRoute[0];
        const isDynamicParameter = Array.isArray(segment);
        const segmentValue = isDynamicParameter ? segment[1] : segment;
        if (!segmentValue || segmentValue.startsWith(_segment.PAGE_SEGMENT_KEY)) continue;
        // Ensure catchAll and optional catchall are turned into an array
        const isCatchAll = isDynamicParameter && (segment[2] === 'c' || segment[2] === 'oc');
        if (isCatchAll) {
            params[segment[0]] = segment[1].split('/');
        } else if (isDynamicParameter) {
            params[segment[0]] = segment[1];
        }
        params = getSelectedParams(parallelRoute, params);
    }
    return params;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=compute-changed-path.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/handle-mutable.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "handleMutable", {
    enumerable: true,
    get: function() {
        return handleMutable;
    }
});
const _computechangedpath = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/compute-changed-path.js [app-ssr] (ecmascript)");
function isNotUndefined(value) {
    return typeof value !== 'undefined';
}
function handleMutable(state, mutable) {
    var _mutable_shouldScroll;
    // shouldScroll is true by default, can override to false.
    const shouldScroll = (_mutable_shouldScroll = mutable.shouldScroll) != null ? _mutable_shouldScroll : true;
    let nextUrl = state.nextUrl;
    if (isNotUndefined(mutable.patchedTree)) {
        // If we received a patched tree, we need to compute the changed path.
        const changedPath = (0, _computechangedpath.computeChangedPath)(state.tree, mutable.patchedTree);
        if (changedPath) {
            // If the tree changed, we need to update the nextUrl
            nextUrl = changedPath;
        } else if (!nextUrl) {
            // if the tree ends up being the same (ie, no changed path), and we don't have a nextUrl, then we should use the canonicalUrl
            nextUrl = state.canonicalUrl;
        }
    // otherwise this will be a no-op and continue to use the existing nextUrl
    }
    var _mutable_scrollableSegments;
    return {
        // Set href.
        canonicalUrl: isNotUndefined(mutable.canonicalUrl) ? mutable.canonicalUrl === state.canonicalUrl ? state.canonicalUrl : mutable.canonicalUrl : state.canonicalUrl,
        pushRef: {
            pendingPush: isNotUndefined(mutable.pendingPush) ? mutable.pendingPush : state.pushRef.pendingPush,
            mpaNavigation: isNotUndefined(mutable.mpaNavigation) ? mutable.mpaNavigation : state.pushRef.mpaNavigation,
            preserveCustomHistoryState: isNotUndefined(mutable.preserveCustomHistoryState) ? mutable.preserveCustomHistoryState : state.pushRef.preserveCustomHistoryState
        },
        // All navigation requires scroll and focus management to trigger.
        focusAndScrollRef: {
            apply: shouldScroll ? isNotUndefined(mutable == null ? void 0 : mutable.scrollableSegments) ? true : state.focusAndScrollRef.apply : false,
            onlyHashChange: mutable.onlyHashChange || false,
            hashFragment: shouldScroll ? mutable.hashFragment && mutable.hashFragment !== '' ? decodeURIComponent(mutable.hashFragment.slice(1)) : state.focusAndScrollRef.hashFragment : null,
            segmentPaths: shouldScroll ? (_mutable_scrollableSegments = mutable == null ? void 0 : mutable.scrollableSegments) != null ? _mutable_scrollableSegments : state.focusAndScrollRef.segmentPaths : []
        },
        // Apply cache.
        cache: mutable.cache ? mutable.cache : state.cache,
        prefetchCache: mutable.prefetchCache ? mutable.prefetchCache : state.prefetchCache,
        // Apply patched router state.
        tree: isNotUndefined(mutable.patchedTree) ? mutable.patchedTree : state.tree,
        nextUrl
    };
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=handle-mutable.js.map
}}),
"[project]/node_modules/@swc/helpers/cjs/_class_private_field_loose_base.cjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
function _class_private_field_loose_base(receiver, privateKey) {
    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
        throw new TypeError("attempted to use private field on non-instance");
    }
    return receiver;
}
exports._ = _class_private_field_loose_base;
}}),
"[project]/node_modules/@swc/helpers/cjs/_class_private_field_loose_key.cjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var id = 0;
function _class_private_field_loose_key(name) {
    return "__private_" + id++ + "_" + name;
}
exports._ = _class_private_field_loose_key;
}}),
"[project]/node_modules/next/dist/client/components/promise-queue.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*
    This is a simple promise queue that allows you to limit the number of concurrent promises
    that are running at any given time. It's used to limit the number of concurrent
    prefetch requests that are being made to the server but could be used for other
    things as well.
*/ Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "PromiseQueue", {
    enumerable: true,
    get: function() {
        return PromiseQueue;
    }
});
const _class_private_field_loose_base = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_class_private_field_loose_base.cjs [app-ssr] (ecmascript)");
const _class_private_field_loose_key = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_class_private_field_loose_key.cjs [app-ssr] (ecmascript)");
var _maxConcurrency = /*#__PURE__*/ _class_private_field_loose_key._("_maxConcurrency"), _runningCount = /*#__PURE__*/ _class_private_field_loose_key._("_runningCount"), _queue = /*#__PURE__*/ _class_private_field_loose_key._("_queue"), _processNext = /*#__PURE__*/ _class_private_field_loose_key._("_processNext");
class PromiseQueue {
    enqueue(promiseFn) {
        let taskResolve;
        let taskReject;
        const taskPromise = new Promise((resolve, reject)=>{
            taskResolve = resolve;
            taskReject = reject;
        });
        const task = async ()=>{
            try {
                _class_private_field_loose_base._(this, _runningCount)[_runningCount]++;
                const result = await promiseFn();
                taskResolve(result);
            } catch (error) {
                taskReject(error);
            } finally{
                _class_private_field_loose_base._(this, _runningCount)[_runningCount]--;
                _class_private_field_loose_base._(this, _processNext)[_processNext]();
            }
        };
        const enqueueResult = {
            promiseFn: taskPromise,
            task
        };
        // wonder if we should take a LIFO approach here
        _class_private_field_loose_base._(this, _queue)[_queue].push(enqueueResult);
        _class_private_field_loose_base._(this, _processNext)[_processNext]();
        return taskPromise;
    }
    bump(promiseFn) {
        const index = _class_private_field_loose_base._(this, _queue)[_queue].findIndex((item)=>item.promiseFn === promiseFn);
        if (index > -1) {
            const bumpedItem = _class_private_field_loose_base._(this, _queue)[_queue].splice(index, 1)[0];
            _class_private_field_loose_base._(this, _queue)[_queue].unshift(bumpedItem);
            _class_private_field_loose_base._(this, _processNext)[_processNext](true);
        }
    }
    constructor(maxConcurrency = 5){
        Object.defineProperty(this, _processNext, {
            value: processNext
        });
        Object.defineProperty(this, _maxConcurrency, {
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _runningCount, {
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _queue, {
            writable: true,
            value: void 0
        });
        _class_private_field_loose_base._(this, _maxConcurrency)[_maxConcurrency] = maxConcurrency;
        _class_private_field_loose_base._(this, _runningCount)[_runningCount] = 0;
        _class_private_field_loose_base._(this, _queue)[_queue] = [];
    }
}
function processNext(forced) {
    if (forced === void 0) forced = false;
    if ((_class_private_field_loose_base._(this, _runningCount)[_runningCount] < _class_private_field_loose_base._(this, _maxConcurrency)[_maxConcurrency] || forced) && _class_private_field_loose_base._(this, _queue)[_queue].length > 0) {
        var _class_private_field_loose_base__queue_shift;
        (_class_private_field_loose_base__queue_shift = _class_private_field_loose_base._(this, _queue)[_queue].shift()) == null ? void 0 : _class_private_field_loose_base__queue_shift.task();
    }
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=promise-queue.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    DYNAMIC_STALETIME_MS: null,
    STATIC_STALETIME_MS: null,
    createSeededPrefetchCacheEntry: null,
    getOrCreatePrefetchCacheEntry: null,
    prunePrefetchCache: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    DYNAMIC_STALETIME_MS: function() {
        return DYNAMIC_STALETIME_MS;
    },
    STATIC_STALETIME_MS: function() {
        return STATIC_STALETIME_MS;
    },
    createSeededPrefetchCacheEntry: function() {
        return createSeededPrefetchCacheEntry;
    },
    getOrCreatePrefetchCacheEntry: function() {
        return getOrCreatePrefetchCacheEntry;
    },
    prunePrefetchCache: function() {
        return prunePrefetchCache;
    }
});
const _fetchserverresponse = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/fetch-server-response.js [app-ssr] (ecmascript)");
const _routerreducertypes = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/router-reducer-types.js [app-ssr] (ecmascript)");
const _prefetchreducer = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js [app-ssr] (ecmascript)");
const INTERCEPTION_CACHE_KEY_MARKER = '%';
/**
 * Creates a cache key for the router prefetch cache
 *
 * @param url - The URL being navigated to
 * @param nextUrl - an internal URL, primarily used for handling rewrites. Defaults to '/'.
 * @return The generated prefetch cache key.
 */ function createPrefetchCacheKeyImpl(url, includeSearchParams, prefix) {
    // Initially we only use the pathname as the cache key. We don't want to include
    // search params so that multiple URLs with the same search parameter can re-use
    // loading states.
    let pathnameFromUrl = url.pathname;
    // RSC responses can differ based on search params, specifically in the case where we aren't
    // returning a partial response (ie with `PrefetchKind.AUTO`).
    // In the auto case, since loading.js & layout.js won't have access to search params,
    // we can safely re-use that cache entry. But for full prefetches, we should not
    // re-use the cache entry as the response may differ.
    if (includeSearchParams) {
        // if we have a full prefetch, we can include the search param in the key,
        // as we'll be getting back a full response. The server might have read the search
        // params when generating the full response.
        pathnameFromUrl += url.search;
    }
    if (prefix) {
        return "" + prefix + INTERCEPTION_CACHE_KEY_MARKER + pathnameFromUrl;
    }
    return pathnameFromUrl;
}
function createPrefetchCacheKey(url, kind, nextUrl) {
    return createPrefetchCacheKeyImpl(url, kind === _routerreducertypes.PrefetchKind.FULL, nextUrl);
}
function getExistingCacheEntry(url, kind, nextUrl, prefetchCache, allowAliasing) {
    if (kind === void 0) kind = _routerreducertypes.PrefetchKind.TEMPORARY;
    // We first check if there's a more specific interception route prefetch entry
    // This is because when we detect a prefetch that corresponds with an interception route, we prefix it with nextUrl (see `createPrefetchCacheKey`)
    // to avoid conflicts with other pages that may have the same URL but render different things depending on the `Next-URL` header.
    for (const maybeNextUrl of [
        nextUrl,
        null
    ]){
        const cacheKeyWithParams = createPrefetchCacheKeyImpl(url, true, maybeNextUrl);
        const cacheKeyWithoutParams = createPrefetchCacheKeyImpl(url, false, maybeNextUrl);
        // First, we check if we have a cache entry that exactly matches the URL
        const cacheKeyToUse = url.search ? cacheKeyWithParams : cacheKeyWithoutParams;
        const existingEntry = prefetchCache.get(cacheKeyToUse);
        if (existingEntry && allowAliasing) {
            // We know we're returning an aliased entry when the pathname matches but the search params don't,
            const isAliased = existingEntry.url.pathname === url.pathname && existingEntry.url.search !== url.search;
            if (isAliased) {
                return {
                    ...existingEntry,
                    aliased: true
                };
            }
            return existingEntry;
        }
        // If the request contains search params, and we're not doing a full prefetch, we can return the
        // param-less entry if it exists.
        // This is technically covered by the check at the bottom of this function, which iterates over cache entries,
        // but lets us arrive there quicker in the param-full case.
        const entryWithoutParams = prefetchCache.get(cacheKeyWithoutParams);
        if (("TURBOPACK compile-time value", "development") !== 'development' && allowAliasing && url.search && kind !== _routerreducertypes.PrefetchKind.FULL && entryWithoutParams && // We shouldn't return the aliased entry if it was relocated to a new cache key.
        // Since it's rewritten, it could respond with a completely different loading state.
        !entryWithoutParams.key.includes(INTERCEPTION_CACHE_KEY_MARKER)) //TURBOPACK unreachable
        ;
    }
    // If we've gotten to this point, we didn't find a specific cache entry that matched
    // the request URL.
    // We attempt a partial match by checking if there's a cache entry with the same pathname.
    // Regardless of what we find, since it doesn't correspond with the requested URL, we'll mark it "aliased".
    // This will signal to the router that it should only apply the loading state on the prefetched data.
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    return undefined;
}
function getOrCreatePrefetchCacheEntry(param) {
    let { url, nextUrl, tree, prefetchCache, kind, allowAliasing = true } = param;
    const existingCacheEntry = getExistingCacheEntry(url, kind, nextUrl, prefetchCache, allowAliasing);
    if (existingCacheEntry) {
        // Grab the latest status of the cache entry and update it
        existingCacheEntry.status = getPrefetchEntryCacheStatus(existingCacheEntry);
        // when `kind` is provided, an explicit prefetch was requested.
        // if the requested prefetch is "full" and the current cache entry wasn't, we want to re-prefetch with the new intent
        const switchedToFullPrefetch = existingCacheEntry.kind !== _routerreducertypes.PrefetchKind.FULL && kind === _routerreducertypes.PrefetchKind.FULL;
        if (switchedToFullPrefetch) {
            // If we switched to a full prefetch, validate that the existing cache entry contained partial data.
            // It's possible that the cache entry was seeded with full data but has a cache type of "auto" (ie when cache entries
            // are seeded but without a prefetch intent)
            existingCacheEntry.data.then((prefetchResponse)=>{
                const isFullPrefetch = Array.isArray(prefetchResponse.flightData) && prefetchResponse.flightData.some((flightData)=>{
                    // If we started rendering from the root and we returned RSC data (seedData), we already had a full prefetch.
                    return flightData.isRootRender && flightData.seedData !== null;
                });
                if (!isFullPrefetch) {
                    return createLazyPrefetchEntry({
                        tree,
                        url,
                        nextUrl,
                        prefetchCache,
                        // If we didn't get an explicit prefetch kind, we want to set a temporary kind
                        // rather than assuming the same intent as the previous entry, to be consistent with how we
                        // lazily create prefetch entries when intent is left unspecified.
                        kind: kind != null ? kind : _routerreducertypes.PrefetchKind.TEMPORARY
                    });
                }
            });
        }
        // If the existing cache entry was marked as temporary, it means it was lazily created when attempting to get an entry,
        // where we didn't have the prefetch intent. Now that we have the intent (in `kind`), we want to update the entry to the more accurate kind.
        if (kind && existingCacheEntry.kind === _routerreducertypes.PrefetchKind.TEMPORARY) {
            existingCacheEntry.kind = kind;
        }
        // We've determined that the existing entry we found is still valid, so we return it.
        return existingCacheEntry;
    }
    // If we didn't return an entry, create a new one.
    return createLazyPrefetchEntry({
        tree,
        url,
        nextUrl,
        prefetchCache,
        kind: kind || _routerreducertypes.PrefetchKind.TEMPORARY
    });
}
/*
 * Used to take an existing cache entry and prefix it with the nextUrl, if it exists.
 * This ensures that we don't have conflicting cache entries for the same URL (as is the case with route interception).
 */ function prefixExistingPrefetchCacheEntry(param) {
    let { url, nextUrl, prefetchCache, existingCacheKey } = param;
    const existingCacheEntry = prefetchCache.get(existingCacheKey);
    if (!existingCacheEntry) {
        // no-op -- there wasn't an entry to move
        return;
    }
    const newCacheKey = createPrefetchCacheKey(url, existingCacheEntry.kind, nextUrl);
    prefetchCache.set(newCacheKey, {
        ...existingCacheEntry,
        key: newCacheKey
    });
    prefetchCache.delete(existingCacheKey);
    return newCacheKey;
}
function createSeededPrefetchCacheEntry(param) {
    let { nextUrl, tree, prefetchCache, url, data, kind } = param;
    // The initial cache entry technically includes full data, but it isn't explicitly prefetched -- we just seed the
    // prefetch cache so that we can skip an extra prefetch request later, since we already have the data.
    // if the prefetch corresponds with an interception route, we use the nextUrl to prefix the cache key
    const prefetchCacheKey = data.couldBeIntercepted ? createPrefetchCacheKey(url, kind, nextUrl) : createPrefetchCacheKey(url, kind);
    const prefetchEntry = {
        treeAtTimeOfPrefetch: tree,
        data: Promise.resolve(data),
        kind,
        prefetchTime: Date.now(),
        lastUsedTime: Date.now(),
        staleTime: data.staleTime,
        key: prefetchCacheKey,
        status: _routerreducertypes.PrefetchCacheEntryStatus.fresh,
        url
    };
    prefetchCache.set(prefetchCacheKey, prefetchEntry);
    return prefetchEntry;
}
/**
 * Creates a prefetch entry entry and enqueues a fetch request to retrieve the data.
 */ function createLazyPrefetchEntry(param) {
    let { url, kind, tree, nextUrl, prefetchCache } = param;
    const prefetchCacheKey = createPrefetchCacheKey(url, kind);
    // initiates the fetch request for the prefetch and attaches a listener
    // to the promise to update the prefetch cache entry when the promise resolves (if necessary)
    const data = _prefetchreducer.prefetchQueue.enqueue(()=>(0, _fetchserverresponse.fetchServerResponse)(url, {
            flightRouterState: tree,
            nextUrl,
            prefetchKind: kind
        }).then((prefetchResponse)=>{
            // TODO: `fetchServerResponse` should be more tighly coupled to these prefetch cache operations
            // to avoid drift between this cache key prefixing logic
            // (which is currently directly influenced by the server response)
            let newCacheKey;
            if (prefetchResponse.couldBeIntercepted) {
                // Determine if we need to prefix the cache key with the nextUrl
                newCacheKey = prefixExistingPrefetchCacheEntry({
                    url,
                    existingCacheKey: prefetchCacheKey,
                    nextUrl,
                    prefetchCache
                });
            }
            // If the prefetch was a cache hit, we want to update the existing cache entry to reflect that it was a full prefetch.
            // This is because we know that a static response will contain the full RSC payload, and can be updated to respect the `static`
            // staleTime.
            if (prefetchResponse.prerendered) {
                const existingCacheEntry = prefetchCache.get(newCacheKey != null ? newCacheKey : prefetchCacheKey);
                if (existingCacheEntry) {
                    existingCacheEntry.kind = _routerreducertypes.PrefetchKind.FULL;
                    if (prefetchResponse.staleTime !== -1) {
                        // This is the stale time that was collected by the server during
                        // static generation. Use this in place of the default stale time.
                        existingCacheEntry.staleTime = prefetchResponse.staleTime;
                    }
                }
            }
            return prefetchResponse;
        }));
    const prefetchEntry = {
        treeAtTimeOfPrefetch: tree,
        data,
        kind,
        prefetchTime: Date.now(),
        lastUsedTime: null,
        staleTime: -1,
        key: prefetchCacheKey,
        status: _routerreducertypes.PrefetchCacheEntryStatus.fresh,
        url
    };
    prefetchCache.set(prefetchCacheKey, prefetchEntry);
    return prefetchEntry;
}
function prunePrefetchCache(prefetchCache) {
    for (const [href, prefetchCacheEntry] of prefetchCache){
        if (getPrefetchEntryCacheStatus(prefetchCacheEntry) === _routerreducertypes.PrefetchCacheEntryStatus.expired) {
            prefetchCache.delete(href);
        }
    }
}
const DYNAMIC_STALETIME_MS = Number(("TURBOPACK compile-time value", "0")) * 1000;
const STATIC_STALETIME_MS = Number(("TURBOPACK compile-time value", "300")) * 1000;
function getPrefetchEntryCacheStatus(param) {
    let { kind, prefetchTime, lastUsedTime, staleTime } = param;
    if (staleTime !== -1) {
        // `staleTime` is the value sent by the server during static generation.
        // When this is available, it takes precedence over any of the heuristics
        // that follow.
        //
        // TODO: When PPR is enabled, the server will *always* return a stale time
        // when prefetching. We should never use a prefetch entry that hasn't yet
        // received data from the server. So the only two cases should be 1) we use
        // the server-generated stale time 2) the unresolved entry is discarded.
        return Date.now() < prefetchTime + staleTime ? _routerreducertypes.PrefetchCacheEntryStatus.fresh : _routerreducertypes.PrefetchCacheEntryStatus.stale;
    }
    // We will re-use the cache entry data for up to the `dynamic` staletime window.
    if (Date.now() < (lastUsedTime != null ? lastUsedTime : prefetchTime) + DYNAMIC_STALETIME_MS) {
        return lastUsedTime ? _routerreducertypes.PrefetchCacheEntryStatus.reusable : _routerreducertypes.PrefetchCacheEntryStatus.fresh;
    }
    // For "auto" prefetching, we'll re-use only the loading boundary for up to `static` staletime window.
    // A stale entry will only re-use the `loading` boundary, not the full data.
    // This will trigger a "lazy fetch" for the full data.
    if (kind === _routerreducertypes.PrefetchKind.AUTO) {
        if (Date.now() < prefetchTime + STATIC_STALETIME_MS) {
            return _routerreducertypes.PrefetchCacheEntryStatus.stale;
        }
    }
    // for "full" prefetching, we'll re-use the cache entry data for up to `static` staletime window.
    if (kind === _routerreducertypes.PrefetchKind.FULL) {
        if (Date.now() < prefetchTime + STATIC_STALETIME_MS) {
            return _routerreducertypes.PrefetchCacheEntryStatus.reusable;
        }
    }
    return _routerreducertypes.PrefetchCacheEntryStatus.expired;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=prefetch-cache-utils.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    prefetchQueue: null,
    prefetchReducer: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    prefetchQueue: function() {
        return prefetchQueue;
    },
    prefetchReducer: function() {
        return prefetchReducer;
    }
});
const _promisequeue = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/promise-queue.js [app-ssr] (ecmascript)");
const _prefetchcacheutils = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js [app-ssr] (ecmascript)");
const prefetchQueue = new _promisequeue.PromiseQueue(5);
const prefetchReducer = ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : prefetchReducerImpl;
function identityReducerWhenSegmentCacheIsEnabled(state) {
    // Unlike the old implementation, the Segment Cache doesn't store its data in
    // the router reducer state.
    //
    // This shouldn't be reachable because we wrap the prefetch API in a check,
    // too, which prevents the action from being dispatched. But it's here for
    // clarity + code elimination.
    return state;
}
function prefetchReducerImpl(state, action) {
    // let's prune the prefetch cache before we do anything else
    (0, _prefetchcacheutils.prunePrefetchCache)(state.prefetchCache);
    const { url } = action;
    (0, _prefetchcacheutils.getOrCreatePrefetchCacheEntry)({
        url,
        nextUrl: state.nextUrl,
        prefetchCache: state.prefetchCache,
        kind: action.kind,
        tree: state.tree,
        allowAliasing: true
    });
    return state;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=prefetch-reducer.js.map
}}),
"[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
exports._ = _interop_require_default;
}}),
"[project]/node_modules/next/dist/client/components/navigation-untracked.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useUntrackedPathname", {
    enumerable: true,
    get: function() {
        return useUntrackedPathname;
    }
});
const _react = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
const _hooksclientcontextsharedruntime = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/contexts/hooks-client-context.js [app-ssr] (ecmascript)");
/**
 * This checks to see if the current render has any unknown route parameters.
 * It's used to trigger a different render path in the error boundary.
 *
 * @returns true if there are any unknown route parameters, false otherwise
 */ function hasFallbackRouteParams() {
    if ("TURBOPACK compile-time truthy", 1) {
        // AsyncLocalStorage should not be included in the client bundle.
        const { workAsyncStorage } = __turbopack_context__.r("[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)");
        const workStore = workAsyncStorage.getStore();
        if (!workStore) return false;
        const { fallbackRouteParams } = workStore;
        if (!fallbackRouteParams || fallbackRouteParams.size === 0) return false;
        return true;
    }
    //TURBOPACK unreachable
    ;
}
function useUntrackedPathname() {
    // If there are any unknown route parameters we would typically throw
    // an error, but this internal method allows us to return a null value instead
    // for components that do not propagate the pathname to the static shell (like
    // the error boundary).
    if (hasFallbackRouteParams()) {
        return null;
    }
    // This shouldn't cause any issues related to conditional rendering because
    // the environment will be consistent for the render.
    // eslint-disable-next-line react-hooks/rules-of-hooks
    return (0, _react.useContext)(_hooksclientcontextsharedruntime.PathnameContext);
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=navigation-untracked.js.map
}}),
"[project]/node_modules/next/dist/client/components/http-access-fallback/http-access-fallback.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    HTTPAccessErrorStatus: null,
    HTTP_ERROR_FALLBACK_ERROR_CODE: null,
    getAccessFallbackErrorTypeByStatus: null,
    getAccessFallbackHTTPStatus: null,
    isHTTPAccessFallbackError: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    HTTPAccessErrorStatus: function() {
        return HTTPAccessErrorStatus;
    },
    HTTP_ERROR_FALLBACK_ERROR_CODE: function() {
        return HTTP_ERROR_FALLBACK_ERROR_CODE;
    },
    getAccessFallbackErrorTypeByStatus: function() {
        return getAccessFallbackErrorTypeByStatus;
    },
    getAccessFallbackHTTPStatus: function() {
        return getAccessFallbackHTTPStatus;
    },
    isHTTPAccessFallbackError: function() {
        return isHTTPAccessFallbackError;
    }
});
const HTTPAccessErrorStatus = {
    NOT_FOUND: 404,
    FORBIDDEN: 403,
    UNAUTHORIZED: 401
};
const ALLOWED_CODES = new Set(Object.values(HTTPAccessErrorStatus));
const HTTP_ERROR_FALLBACK_ERROR_CODE = 'NEXT_HTTP_ERROR_FALLBACK';
function isHTTPAccessFallbackError(error) {
    if (typeof error !== 'object' || error === null || !('digest' in error) || typeof error.digest !== 'string') {
        return false;
    }
    const [prefix, httpStatus] = error.digest.split(';');
    return prefix === HTTP_ERROR_FALLBACK_ERROR_CODE && ALLOWED_CODES.has(Number(httpStatus));
}
function getAccessFallbackHTTPStatus(error) {
    const httpStatus = error.digest.split(';')[1];
    return Number(httpStatus);
}
function getAccessFallbackErrorTypeByStatus(status) {
    switch(status){
        case 401:
            return 'unauthorized';
        case 403:
            return 'forbidden';
        case 404:
            return 'not-found';
        default:
            return;
    }
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=http-access-fallback.js.map
}}),
"[project]/node_modules/next/dist/client/components/redirect-status-code.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "RedirectStatusCode", {
    enumerable: true,
    get: function() {
        return RedirectStatusCode;
    }
});
var RedirectStatusCode = /*#__PURE__*/ function(RedirectStatusCode) {
    RedirectStatusCode[RedirectStatusCode["SeeOther"] = 303] = "SeeOther";
    RedirectStatusCode[RedirectStatusCode["TemporaryRedirect"] = 307] = "TemporaryRedirect";
    RedirectStatusCode[RedirectStatusCode["PermanentRedirect"] = 308] = "PermanentRedirect";
    return RedirectStatusCode;
}({});
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=redirect-status-code.js.map
}}),
"[project]/node_modules/next/dist/client/components/redirect-error.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    REDIRECT_ERROR_CODE: null,
    RedirectType: null,
    isRedirectError: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    REDIRECT_ERROR_CODE: function() {
        return REDIRECT_ERROR_CODE;
    },
    RedirectType: function() {
        return RedirectType;
    },
    isRedirectError: function() {
        return isRedirectError;
    }
});
const _redirectstatuscode = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/redirect-status-code.js [app-ssr] (ecmascript)");
const REDIRECT_ERROR_CODE = 'NEXT_REDIRECT';
var RedirectType = /*#__PURE__*/ function(RedirectType) {
    RedirectType["push"] = "push";
    RedirectType["replace"] = "replace";
    return RedirectType;
}({});
function isRedirectError(error) {
    if (typeof error !== 'object' || error === null || !('digest' in error) || typeof error.digest !== 'string') {
        return false;
    }
    const digest = error.digest.split(';');
    const [errorCode, type] = digest;
    const destination = digest.slice(2, -2).join(';');
    const status = digest.at(-2);
    const statusCode = Number(status);
    return errorCode === REDIRECT_ERROR_CODE && (type === 'replace' || type === 'push') && typeof destination === 'string' && !isNaN(statusCode) && statusCode in _redirectstatuscode.RedirectStatusCode;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=redirect-error.js.map
}}),
"[project]/node_modules/next/dist/client/components/is-next-router-error.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "isNextRouterError", {
    enumerable: true,
    get: function() {
        return isNextRouterError;
    }
});
const _httpaccessfallback = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/http-access-fallback/http-access-fallback.js [app-ssr] (ecmascript)");
const _redirecterror = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/redirect-error.js [app-ssr] (ecmascript)");
function isNextRouterError(error) {
    return (0, _redirecterror.isRedirectError)(error) || (0, _httpaccessfallback.isHTTPAccessFallbackError)(error);
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=is-next-router-error.js.map
}}),
"[project]/node_modules/next/dist/client/components/nav-failure-handler.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    handleHardNavError: null,
    useNavFailureHandler: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    handleHardNavError: function() {
        return handleHardNavError;
    },
    useNavFailureHandler: function() {
        return useNavFailureHandler;
    }
});
const _react = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
const _createhreffromurl = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/create-href-from-url.js [app-ssr] (ecmascript)");
function handleHardNavError(error) {
    if (error && "undefined" !== 'undefined' && window.next.__pendingUrl && (0, _createhreffromurl.createHrefFromUrl)(new URL(window.location.href)) !== (0, _createhreffromurl.createHrefFromUrl)(window.next.__pendingUrl)) //TURBOPACK unreachable
    ;
    return false;
}
function useNavFailureHandler() {
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=nav-failure-handler.js.map
}}),
"[project]/node_modules/next/dist/client/components/handle-isr-error.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "HandleISRError", {
    enumerable: true,
    get: function() {
        return HandleISRError;
    }
});
const workAsyncStorage = ("TURBOPACK compile-time truthy", 1) ? __turbopack_context__.r("[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)").workAsyncStorage : "TURBOPACK unreachable";
function HandleISRError(param) {
    let { error } = param;
    if (workAsyncStorage) {
        const store = workAsyncStorage.getStore();
        if ((store == null ? void 0 : store.isRevalidate) || (store == null ? void 0 : store.isStaticGeneration)) {
            console.error(error);
            throw error;
        }
    }
    return null;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=handle-isr-error.js.map
}}),
"[project]/node_modules/next/dist/client/components/error-boundary.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    ErrorBoundary: null,
    ErrorBoundaryHandler: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    ErrorBoundary: function() {
        return ErrorBoundary;
    },
    ErrorBoundaryHandler: function() {
        return ErrorBoundaryHandler;
    }
});
const _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-ssr] (ecmascript)");
const _jsxruntime = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js [app-ssr] (ecmascript)");
const _react = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)"));
const _navigationuntracked = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/navigation-untracked.js [app-ssr] (ecmascript)");
const _isnextroutererror = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/is-next-router-error.js [app-ssr] (ecmascript)");
const _navfailurehandler = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/nav-failure-handler.js [app-ssr] (ecmascript)");
const _handleisrerror = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/handle-isr-error.js [app-ssr] (ecmascript)");
class ErrorBoundaryHandler extends _react.default.Component {
    static getDerivedStateFromError(error) {
        if ((0, _isnextroutererror.isNextRouterError)(error)) {
            // Re-throw if an expected internal Next.js router error occurs
            // this means it should be handled by a different boundary (such as a NotFound boundary in a parent segment)
            throw error;
        }
        return {
            error
        };
    }
    static getDerivedStateFromProps(props, state) {
        const { error } = state;
        // if we encounter an error while
        // a navigation is pending we shouldn't render
        // the error boundary and instead should fallback
        // to a hard navigation to attempt recovering
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        /**
     * Handles reset of the error boundary when a navigation happens.
     * Ensures the error boundary does not stay enabled when navigating to a new page.
     * Approach of setState in render is safe as it checks the previous pathname and then overrides
     * it as outlined in https://react.dev/reference/react/useState#storing-information-from-previous-renders
     */ if (props.pathname !== state.previousPathname && state.error) {
            return {
                error: null,
                previousPathname: props.pathname
            };
        }
        return {
            error: state.error,
            previousPathname: props.pathname
        };
    }
    // Explicit type is needed to avoid the generated `.d.ts` having a wide return type that could be specific to the `@types/react` version.
    render() {
        if (this.state.error) {
            return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
                children: [
                    /*#__PURE__*/ (0, _jsxruntime.jsx)(_handleisrerror.HandleISRError, {
                        error: this.state.error
                    }),
                    this.props.errorStyles,
                    this.props.errorScripts,
                    /*#__PURE__*/ (0, _jsxruntime.jsx)(this.props.errorComponent, {
                        error: this.state.error,
                        reset: this.reset
                    })
                ]
            });
        }
        return this.props.children;
    }
    constructor(props){
        super(props), this.reset = ()=>{
            this.setState({
                error: null
            });
        };
        this.state = {
            error: null,
            previousPathname: this.props.pathname
        };
    }
}
function ErrorBoundary(param) {
    let { errorComponent, errorStyles, errorScripts, children } = param;
    // When we're rendering the missing params shell, this will return null. This
    // is because we won't be rendering any not found boundaries or error
    // boundaries for the missing params shell. When this runs on the client
    // (where these errors can occur), we will get the correct pathname.
    const pathname = (0, _navigationuntracked.useUntrackedPathname)();
    if (errorComponent) {
        return /*#__PURE__*/ (0, _jsxruntime.jsx)(ErrorBoundaryHandler, {
            pathname: pathname,
            errorComponent: errorComponent,
            errorStyles: errorStyles,
            errorScripts: errorScripts,
            children: children
        });
    }
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_jsxruntime.Fragment, {
        children: children
    });
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=error-boundary.js.map
}}),
"[project]/node_modules/next/dist/client/components/builtin/global-error.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, // supplied custom global error signatures.
"default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
const _jsxruntime = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js [app-ssr] (ecmascript)");
const _handleisrerror = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/handle-isr-error.js [app-ssr] (ecmascript)");
const styles = {
    error: {
        // https://github.com/sindresorhus/modern-normalize/blob/main/modern-normalize.css#L38-L52
        fontFamily: 'system-ui,"Segoe UI",Roboto,Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji"',
        height: '100vh',
        textAlign: 'center',
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        justifyContent: 'center'
    },
    text: {
        fontSize: '14px',
        fontWeight: 400,
        lineHeight: '28px',
        margin: '0 8px'
    }
};
function DefaultGlobalError(param) {
    let { error } = param;
    const digest = error == null ? void 0 : error.digest;
    return /*#__PURE__*/ (0, _jsxruntime.jsxs)("html", {
        id: "__next_error__",
        children: [
            /*#__PURE__*/ (0, _jsxruntime.jsx)("head", {}),
            /*#__PURE__*/ (0, _jsxruntime.jsxs)("body", {
                children: [
                    /*#__PURE__*/ (0, _jsxruntime.jsx)(_handleisrerror.HandleISRError, {
                        error: error
                    }),
                    /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        style: styles.error,
                        children: /*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {
                            children: [
                                /*#__PURE__*/ (0, _jsxruntime.jsxs)("h2", {
                                    style: styles.text,
                                    children: [
                                        "Application error: a ",
                                        digest ? 'server' : 'client',
                                        "-side exception has occurred while loading ",
                                        window.location.hostname,
                                        " (see the",
                                        ' ',
                                        digest ? 'server logs' : 'browser console',
                                        " for more information)."
                                    ]
                                }),
                                digest ? /*#__PURE__*/ (0, _jsxruntime.jsx)("p", {
                                    style: styles.text,
                                    children: "Digest: " + digest
                                }) : null
                            ]
                        })
                    })
                ]
            })
        ]
    });
}
const _default = DefaultGlobalError;
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=global-error.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/router/utils/html-bots.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
// This regex contains the bots that we need to do a blocking render for and can't safely stream the response
// due to how they parse the DOM. For example, they might explicitly check for metadata in the `head` tag, so we can't stream metadata tags after the `head` was sent.
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "HTML_LIMITED_BOT_UA_RE", {
    enumerable: true,
    get: function() {
        return HTML_LIMITED_BOT_UA_RE;
    }
});
const HTML_LIMITED_BOT_UA_RE = /Mediapartners-Google|Chrome-Lighthouse|Slurp|DuckDuckBot|baiduspider|yandex|sogou|bitlybot|tumblr|vkShare|quora link preview|redditbot|ia_archiver|Bingbot|BingPreview|applebot|facebookexternalhit|facebookcatalog|Twitterbot|LinkedInBot|Slackbot|Discordbot|WhatsApp|SkypeUriPreview|Yeti/i; //# sourceMappingURL=html-bots.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/router/utils/is-bot.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    HTML_LIMITED_BOT_UA_RE: null,
    HTML_LIMITED_BOT_UA_RE_STRING: null,
    getBotType: null,
    isBot: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    HTML_LIMITED_BOT_UA_RE: function() {
        return _htmlbots.HTML_LIMITED_BOT_UA_RE;
    },
    HTML_LIMITED_BOT_UA_RE_STRING: function() {
        return HTML_LIMITED_BOT_UA_RE_STRING;
    },
    getBotType: function() {
        return getBotType;
    },
    isBot: function() {
        return isBot;
    }
});
const _htmlbots = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/html-bots.js [app-ssr] (ecmascript)");
// Bot crawler that will spin up a headless browser and execute JS.
// By default, only googlebots are considered as DOM bots. Blow is where the regex is computed from:
// x-ref: https://developers.google.com/search/docs/crawling-indexing/google-common-crawlers
const HEADLESS_BROWSER_BOT_UA_RE = /google/i;
const HTML_LIMITED_BOT_UA_RE_STRING = _htmlbots.HTML_LIMITED_BOT_UA_RE.source;
function isDomBotUA(userAgent) {
    return HEADLESS_BROWSER_BOT_UA_RE.test(userAgent);
}
function isHtmlLimitedBotUA(userAgent) {
    return _htmlbots.HTML_LIMITED_BOT_UA_RE.test(userAgent);
}
function isBot(userAgent) {
    return isDomBotUA(userAgent) || isHtmlLimitedBotUA(userAgent);
}
function getBotType(userAgent) {
    if (isDomBotUA(userAgent)) {
        return 'dom';
    }
    if (isHtmlLimitedBotUA(userAgent)) {
        return 'html';
    }
    return undefined;
} //# sourceMappingURL=is-bot.js.map
}}),
"[project]/node_modules/next/dist/client/components/app-router-announcer.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "AppRouterAnnouncer", {
    enumerable: true,
    get: function() {
        return AppRouterAnnouncer;
    }
});
const _react = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
const _reactdom = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-dom.js [app-ssr] (ecmascript)");
const ANNOUNCER_TYPE = 'next-route-announcer';
const ANNOUNCER_ID = '__next-route-announcer__';
function getAnnouncerNode() {
    var _existingAnnouncer_shadowRoot;
    const existingAnnouncer = document.getElementsByName(ANNOUNCER_TYPE)[0];
    if (existingAnnouncer == null ? void 0 : (_existingAnnouncer_shadowRoot = existingAnnouncer.shadowRoot) == null ? void 0 : _existingAnnouncer_shadowRoot.childNodes[0]) {
        return existingAnnouncer.shadowRoot.childNodes[0];
    } else {
        const container = document.createElement(ANNOUNCER_TYPE);
        container.style.cssText = 'position:absolute';
        const announcer = document.createElement('div');
        announcer.ariaLive = 'assertive';
        announcer.id = ANNOUNCER_ID;
        announcer.role = 'alert';
        announcer.style.cssText = 'position:absolute;border:0;height:1px;margin:-1px;padding:0;width:1px;clip:rect(0 0 0 0);overflow:hidden;white-space:nowrap;word-wrap:normal';
        // Use shadow DOM here to avoid any potential CSS bleed
        const shadow = container.attachShadow({
            mode: 'open'
        });
        shadow.appendChild(announcer);
        document.body.appendChild(container);
        return announcer;
    }
}
function AppRouterAnnouncer(param) {
    let { tree } = param;
    const [portalNode, setPortalNode] = (0, _react.useState)(null);
    (0, _react.useEffect)(()=>{
        const announcer = getAnnouncerNode();
        setPortalNode(announcer);
        return ()=>{
            const container = document.getElementsByTagName(ANNOUNCER_TYPE)[0];
            if (container == null ? void 0 : container.isConnected) {
                document.body.removeChild(container);
            }
        };
    }, []);
    const [routeAnnouncement, setRouteAnnouncement] = (0, _react.useState)('');
    const previousTitle = (0, _react.useRef)(undefined);
    (0, _react.useEffect)(()=>{
        let currentTitle = '';
        if (document.title) {
            currentTitle = document.title;
        } else {
            const pageHeader = document.querySelector('h1');
            if (pageHeader) {
                currentTitle = pageHeader.innerText || pageHeader.textContent || '';
            }
        }
        // Only announce the title change, but not for the first load because screen
        // readers do that automatically.
        if (previousTitle.current !== undefined && previousTitle.current !== currentTitle) {
            setRouteAnnouncement(currentTitle);
        }
        previousTitle.current = currentTitle;
    }, [
        tree
    ]);
    return portalNode ? /*#__PURE__*/ (0, _reactdom.createPortal)(routeAnnouncement, portalNode) : null;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=app-router-announcer.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/reducers/get-segment-value.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "getSegmentValue", {
    enumerable: true,
    get: function() {
        return getSegmentValue;
    }
});
function getSegmentValue(segment) {
    return Array.isArray(segment) ? segment[1] : segment;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=get-segment-value.js.map
}}),
"[project]/node_modules/next/dist/client/components/redirect.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    getRedirectError: null,
    getRedirectStatusCodeFromError: null,
    getRedirectTypeFromError: null,
    getURLFromRedirectError: null,
    permanentRedirect: null,
    redirect: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    getRedirectError: function() {
        return getRedirectError;
    },
    getRedirectStatusCodeFromError: function() {
        return getRedirectStatusCodeFromError;
    },
    getRedirectTypeFromError: function() {
        return getRedirectTypeFromError;
    },
    getURLFromRedirectError: function() {
        return getURLFromRedirectError;
    },
    permanentRedirect: function() {
        return permanentRedirect;
    },
    redirect: function() {
        return redirect;
    }
});
const _redirectstatuscode = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/redirect-status-code.js [app-ssr] (ecmascript)");
const _redirecterror = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/redirect-error.js [app-ssr] (ecmascript)");
const actionAsyncStorage = ("TURBOPACK compile-time truthy", 1) ? __turbopack_context__.r("[externals]/next/dist/server/app-render/action-async-storage.external.js [external] (next/dist/server/app-render/action-async-storage.external.js, cjs)").actionAsyncStorage : "TURBOPACK unreachable";
function getRedirectError(url, type, statusCode) {
    if (statusCode === void 0) statusCode = _redirectstatuscode.RedirectStatusCode.TemporaryRedirect;
    const error = Object.defineProperty(new Error(_redirecterror.REDIRECT_ERROR_CODE), "__NEXT_ERROR_CODE", {
        value: "E394",
        enumerable: false,
        configurable: true
    });
    error.digest = _redirecterror.REDIRECT_ERROR_CODE + ";" + type + ";" + url + ";" + statusCode + ";";
    return error;
}
function redirect(/** The URL to redirect to */ url, type) {
    var _actionAsyncStorage_getStore;
    type != null ? type : type = (actionAsyncStorage == null ? void 0 : (_actionAsyncStorage_getStore = actionAsyncStorage.getStore()) == null ? void 0 : _actionAsyncStorage_getStore.isAction) ? _redirecterror.RedirectType.push : _redirecterror.RedirectType.replace;
    throw getRedirectError(url, type, _redirectstatuscode.RedirectStatusCode.TemporaryRedirect);
}
function permanentRedirect(/** The URL to redirect to */ url, type) {
    if (type === void 0) type = _redirecterror.RedirectType.replace;
    throw getRedirectError(url, type, _redirectstatuscode.RedirectStatusCode.PermanentRedirect);
}
function getURLFromRedirectError(error) {
    if (!(0, _redirecterror.isRedirectError)(error)) return null;
    // Slices off the beginning of the digest that contains the code and the
    // separating ';'.
    return error.digest.split(';').slice(2, -2).join(';');
}
function getRedirectTypeFromError(error) {
    if (!(0, _redirecterror.isRedirectError)(error)) {
        throw Object.defineProperty(new Error('Not a redirect error'), "__NEXT_ERROR_CODE", {
            value: "E260",
            enumerable: false,
            configurable: true
        });
    }
    return error.digest.split(';', 2)[1];
}
function getRedirectStatusCodeFromError(error) {
    if (!(0, _redirecterror.isRedirectError)(error)) {
        throw Object.defineProperty(new Error('Not a redirect error'), "__NEXT_ERROR_CODE", {
            value: "E260",
            enumerable: false,
            configurable: true
        });
    }
    return Number(error.digest.split(';').at(-2));
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=redirect.js.map
}}),
"[project]/node_modules/next/dist/client/components/not-found.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "notFound", {
    enumerable: true,
    get: function() {
        return notFound;
    }
});
const _httpaccessfallback = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/http-access-fallback/http-access-fallback.js [app-ssr] (ecmascript)");
/**
 * This function allows you to render the [not-found.js file](https://nextjs.org/docs/app/api-reference/file-conventions/not-found)
 * within a route segment as well as inject a tag.
 *
 * `notFound()` can be used in
 * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),
 * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and
 * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).
 *
 * - In a Server Component, this will insert a `<meta name="robots" content="noindex" />` meta tag and set the status code to 404.
 * - In a Route Handler or Server Action, it will serve a 404 to the caller.
 *
 * Read more: [Next.js Docs: `notFound`](https://nextjs.org/docs/app/api-reference/functions/not-found)
 */ const DIGEST = "" + _httpaccessfallback.HTTP_ERROR_FALLBACK_ERROR_CODE + ";404";
function notFound() {
    // eslint-disable-next-line no-throw-literal
    const error = Object.defineProperty(new Error(DIGEST), "__NEXT_ERROR_CODE", {
        value: "E394",
        enumerable: false,
        configurable: true
    });
    error.digest = DIGEST;
    throw error;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=not-found.js.map
}}),
"[project]/node_modules/next/dist/client/components/forbidden.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "forbidden", {
    enumerable: true,
    get: function() {
        return forbidden;
    }
});
const _httpaccessfallback = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/http-access-fallback/http-access-fallback.js [app-ssr] (ecmascript)");
// TODO: Add `forbidden` docs
/**
 * @experimental
 * This function allows you to render the [forbidden.js file](https://nextjs.org/docs/app/api-reference/file-conventions/forbidden)
 * within a route segment as well as inject a tag.
 *
 * `forbidden()` can be used in
 * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),
 * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and
 * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).
 *
 * Read more: [Next.js Docs: `forbidden`](https://nextjs.org/docs/app/api-reference/functions/forbidden)
 */ const DIGEST = "" + _httpaccessfallback.HTTP_ERROR_FALLBACK_ERROR_CODE + ";403";
function forbidden() {
    if ("TURBOPACK compile-time truthy", 1) {
        throw Object.defineProperty(new Error("`forbidden()` is experimental and only allowed to be enabled when `experimental.authInterrupts` is enabled."), "__NEXT_ERROR_CODE", {
            value: "E488",
            enumerable: false,
            configurable: true
        });
    }
    // eslint-disable-next-line no-throw-literal
    const error = Object.defineProperty(new Error(DIGEST), "__NEXT_ERROR_CODE", {
        value: "E394",
        enumerable: false,
        configurable: true
    });
    error.digest = DIGEST;
    throw error;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=forbidden.js.map
}}),
"[project]/node_modules/next/dist/client/components/unauthorized.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "unauthorized", {
    enumerable: true,
    get: function() {
        return unauthorized;
    }
});
const _httpaccessfallback = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/http-access-fallback/http-access-fallback.js [app-ssr] (ecmascript)");
// TODO: Add `unauthorized` docs
/**
 * @experimental
 * This function allows you to render the [unauthorized.js file](https://nextjs.org/docs/app/api-reference/file-conventions/unauthorized)
 * within a route segment as well as inject a tag.
 *
 * `unauthorized()` can be used in
 * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),
 * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and
 * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).
 *
 *
 * Read more: [Next.js Docs: `unauthorized`](https://nextjs.org/docs/app/api-reference/functions/unauthorized)
 */ const DIGEST = "" + _httpaccessfallback.HTTP_ERROR_FALLBACK_ERROR_CODE + ";401";
function unauthorized() {
    if ("TURBOPACK compile-time truthy", 1) {
        throw Object.defineProperty(new Error("`unauthorized()` is experimental and only allowed to be used when `experimental.authInterrupts` is enabled."), "__NEXT_ERROR_CODE", {
            value: "E411",
            enumerable: false,
            configurable: true
        });
    }
    // eslint-disable-next-line no-throw-literal
    const error = Object.defineProperty(new Error(DIGEST), "__NEXT_ERROR_CODE", {
        value: "E394",
        enumerable: false,
        configurable: true
    });
    error.digest = DIGEST;
    throw error;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=unauthorized.js.map
}}),
"[project]/node_modules/next/dist/server/dynamic-rendering-utils.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    isHangingPromiseRejectionError: null,
    makeHangingPromise: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    isHangingPromiseRejectionError: function() {
        return isHangingPromiseRejectionError;
    },
    makeHangingPromise: function() {
        return makeHangingPromise;
    }
});
function isHangingPromiseRejectionError(err) {
    if (typeof err !== 'object' || err === null || !('digest' in err)) {
        return false;
    }
    return err.digest === HANGING_PROMISE_REJECTION;
}
const HANGING_PROMISE_REJECTION = 'HANGING_PROMISE_REJECTION';
class HangingPromiseRejectionError extends Error {
    constructor(expression){
        super(`During prerendering, ${expression} rejects when the prerender is complete. Typically these errors are handled by React but if you move ${expression} to a different context by using \`setTimeout\`, \`after\`, or similar functions you may observe this error and you should handle it in that context.`), this.expression = expression, this.digest = HANGING_PROMISE_REJECTION;
    }
}
const abortListenersBySignal = new WeakMap();
function makeHangingPromise(signal, expression) {
    if (signal.aborted) {
        return Promise.reject(new HangingPromiseRejectionError(expression));
    } else {
        const hangingPromise = new Promise((_, reject)=>{
            const boundRejection = reject.bind(null, new HangingPromiseRejectionError(expression));
            let currentListeners = abortListenersBySignal.get(signal);
            if (currentListeners) {
                currentListeners.push(boundRejection);
            } else {
                const listeners = [
                    boundRejection
                ];
                abortListenersBySignal.set(signal, listeners);
                signal.addEventListener('abort', ()=>{
                    for(let i = 0; i < listeners.length; i++){
                        listeners[i]();
                    }
                }, {
                    once: true
                });
            }
        });
        // We are fine if no one actually awaits this promise. We shouldn't consider this an unhandled rejection so
        // we attach a noop catch handler here to suppress this warning. If you actually await somewhere or construct
        // your own promise out of it you'll need to ensure you handle the error when it rejects.
        hangingPromise.catch(ignoreReject);
        return hangingPromise;
    }
}
function ignoreReject() {} //# sourceMappingURL=dynamic-rendering-utils.js.map
}}),
"[project]/node_modules/next/dist/server/lib/router-utils/is-postpone.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "isPostpone", {
    enumerable: true,
    get: function() {
        return isPostpone;
    }
});
const REACT_POSTPONE_TYPE = Symbol.for('react.postpone');
function isPostpone(error) {
    return typeof error === 'object' && error !== null && error.$$typeof === REACT_POSTPONE_TYPE;
} //# sourceMappingURL=is-postpone.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/lazy-dynamic/bailout-to-csr.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
// This has to be a shared module which is shared between client component error boundary and dynamic component
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    BailoutToCSRError: null,
    isBailoutToCSRError: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    BailoutToCSRError: function() {
        return BailoutToCSRError;
    },
    isBailoutToCSRError: function() {
        return isBailoutToCSRError;
    }
});
const BAILOUT_TO_CSR = 'BAILOUT_TO_CLIENT_SIDE_RENDERING';
class BailoutToCSRError extends Error {
    constructor(reason){
        super("Bail out to client-side rendering: " + reason), this.reason = reason, this.digest = BAILOUT_TO_CSR;
    }
}
function isBailoutToCSRError(err) {
    if (typeof err !== 'object' || err === null || !('digest' in err)) {
        return false;
    }
    return err.digest === BAILOUT_TO_CSR;
} //# sourceMappingURL=bailout-to-csr.js.map
}}),
"[project]/node_modules/next/dist/client/components/hooks-server-context.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    DynamicServerError: null,
    isDynamicServerError: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    DynamicServerError: function() {
        return DynamicServerError;
    },
    isDynamicServerError: function() {
        return isDynamicServerError;
    }
});
const DYNAMIC_ERROR_CODE = 'DYNAMIC_SERVER_USAGE';
class DynamicServerError extends Error {
    constructor(description){
        super("Dynamic server usage: " + description), this.description = description, this.digest = DYNAMIC_ERROR_CODE;
    }
}
function isDynamicServerError(err) {
    if (typeof err !== 'object' || err === null || !('digest' in err) || typeof err.digest !== 'string') {
        return false;
    }
    return err.digest === DYNAMIC_ERROR_CODE;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=hooks-server-context.js.map
}}),
"[project]/node_modules/next/dist/client/components/static-generation-bailout.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    StaticGenBailoutError: null,
    isStaticGenBailoutError: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    StaticGenBailoutError: function() {
        return StaticGenBailoutError;
    },
    isStaticGenBailoutError: function() {
        return isStaticGenBailoutError;
    }
});
const NEXT_STATIC_GEN_BAILOUT = 'NEXT_STATIC_GEN_BAILOUT';
class StaticGenBailoutError extends Error {
    constructor(...args){
        super(...args), this.code = NEXT_STATIC_GEN_BAILOUT;
    }
}
function isStaticGenBailoutError(error) {
    if (typeof error !== 'object' || error === null || !('code' in error)) {
        return false;
    }
    return error.code === NEXT_STATIC_GEN_BAILOUT;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=static-generation-bailout.js.map
}}),
"[project]/node_modules/next/dist/lib/metadata/metadata-constants.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    METADATA_BOUNDARY_NAME: null,
    OUTLET_BOUNDARY_NAME: null,
    VIEWPORT_BOUNDARY_NAME: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    METADATA_BOUNDARY_NAME: function() {
        return METADATA_BOUNDARY_NAME;
    },
    OUTLET_BOUNDARY_NAME: function() {
        return OUTLET_BOUNDARY_NAME;
    },
    VIEWPORT_BOUNDARY_NAME: function() {
        return VIEWPORT_BOUNDARY_NAME;
    }
});
const METADATA_BOUNDARY_NAME = '__next_metadata_boundary__';
const VIEWPORT_BOUNDARY_NAME = '__next_viewport_boundary__';
const OUTLET_BOUNDARY_NAME = '__next_outlet_boundary__'; //# sourceMappingURL=metadata-constants.js.map
}}),
"[project]/node_modules/next/dist/lib/scheduler.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    atLeastOneTask: null,
    scheduleImmediate: null,
    scheduleOnNextTick: null,
    waitAtLeastOneReactRenderTask: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    atLeastOneTask: function() {
        return atLeastOneTask;
    },
    scheduleImmediate: function() {
        return scheduleImmediate;
    },
    scheduleOnNextTick: function() {
        return scheduleOnNextTick;
    },
    waitAtLeastOneReactRenderTask: function() {
        return waitAtLeastOneReactRenderTask;
    }
});
const scheduleOnNextTick = (cb)=>{
    // We use Promise.resolve().then() here so that the operation is scheduled at
    // the end of the promise job queue, we then add it to the next process tick
    // to ensure it's evaluated afterwards.
    //
    // This was inspired by the implementation of the DataLoader interface: https://github.com/graphql/dataloader/blob/d336bd15282664e0be4b4a657cb796f09bafbc6b/src/index.js#L213-L255
    //
    Promise.resolve().then(()=>{
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        else {
            process.nextTick(cb);
        }
    });
};
const scheduleImmediate = (cb)=>{
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    else {
        setImmediate(cb);
    }
};
function atLeastOneTask() {
    return new Promise((resolve)=>scheduleImmediate(resolve));
}
function waitAtLeastOneReactRenderTask() {
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    else {
        return new Promise((r)=>setImmediate(r));
    }
} //# sourceMappingURL=scheduler.js.map
}}),
"[project]/node_modules/next/dist/server/app-render/dynamic-rendering.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/**
 * The functions provided by this module are used to communicate certain properties
 * about the currently running code so that Next.js can make decisions on how to handle
 * the current execution in different rendering modes such as pre-rendering, resuming, and SSR.
 *
 * Today Next.js treats all code as potentially static. Certain APIs may only make sense when dynamically rendering.
 * Traditionally this meant deopting the entire render to dynamic however with PPR we can now deopt parts
 * of a React tree as dynamic while still keeping other parts static. There are really two different kinds of
 * Dynamic indications.
 *
 * The first is simply an intention to be dynamic. unstable_noStore is an example of this where
 * the currently executing code simply declares that the current scope is dynamic but if you use it
 * inside unstable_cache it can still be cached. This type of indication can be removed if we ever
 * make the default dynamic to begin with because the only way you would ever be static is inside
 * a cache scope which this indication does not affect.
 *
 * The second is an indication that a dynamic data source was read. This is a stronger form of dynamic
 * because it means that it is inappropriate to cache this at all. using a dynamic data source inside
 * unstable_cache should error. If you want to use some dynamic data inside unstable_cache you should
 * read that data outside the cache and pass it in as an argument to the cached function.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    Postpone: null,
    PreludeState: null,
    abortAndThrowOnSynchronousRequestDataAccess: null,
    abortOnSynchronousPlatformIOAccess: null,
    accessedDynamicData: null,
    annotateDynamicAccess: null,
    consumeDynamicAccess: null,
    createDynamicTrackingState: null,
    createDynamicValidationState: null,
    createHangingInputAbortSignal: null,
    createPostponedAbortSignal: null,
    formatDynamicAPIAccesses: null,
    getFirstDynamicReason: null,
    isDynamicPostpone: null,
    isPrerenderInterruptedError: null,
    markCurrentScopeAsDynamic: null,
    postponeWithTracking: null,
    throwIfDisallowedDynamic: null,
    throwToInterruptStaticGeneration: null,
    trackAllowedDynamicAccess: null,
    trackDynamicDataInDynamicRender: null,
    trackFallbackParamAccessed: null,
    trackSynchronousPlatformIOAccessInDev: null,
    trackSynchronousRequestDataAccessInDev: null,
    useDynamicRouteParams: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    Postpone: function() {
        return Postpone;
    },
    PreludeState: function() {
        return PreludeState;
    },
    abortAndThrowOnSynchronousRequestDataAccess: function() {
        return abortAndThrowOnSynchronousRequestDataAccess;
    },
    abortOnSynchronousPlatformIOAccess: function() {
        return abortOnSynchronousPlatformIOAccess;
    },
    accessedDynamicData: function() {
        return accessedDynamicData;
    },
    annotateDynamicAccess: function() {
        return annotateDynamicAccess;
    },
    consumeDynamicAccess: function() {
        return consumeDynamicAccess;
    },
    createDynamicTrackingState: function() {
        return createDynamicTrackingState;
    },
    createDynamicValidationState: function() {
        return createDynamicValidationState;
    },
    createHangingInputAbortSignal: function() {
        return createHangingInputAbortSignal;
    },
    createPostponedAbortSignal: function() {
        return createPostponedAbortSignal;
    },
    formatDynamicAPIAccesses: function() {
        return formatDynamicAPIAccesses;
    },
    getFirstDynamicReason: function() {
        return getFirstDynamicReason;
    },
    isDynamicPostpone: function() {
        return isDynamicPostpone;
    },
    isPrerenderInterruptedError: function() {
        return isPrerenderInterruptedError;
    },
    markCurrentScopeAsDynamic: function() {
        return markCurrentScopeAsDynamic;
    },
    postponeWithTracking: function() {
        return postponeWithTracking;
    },
    throwIfDisallowedDynamic: function() {
        return throwIfDisallowedDynamic;
    },
    throwToInterruptStaticGeneration: function() {
        return throwToInterruptStaticGeneration;
    },
    trackAllowedDynamicAccess: function() {
        return trackAllowedDynamicAccess;
    },
    trackDynamicDataInDynamicRender: function() {
        return trackDynamicDataInDynamicRender;
    },
    trackFallbackParamAccessed: function() {
        return trackFallbackParamAccessed;
    },
    trackSynchronousPlatformIOAccessInDev: function() {
        return trackSynchronousPlatformIOAccessInDev;
    },
    trackSynchronousRequestDataAccessInDev: function() {
        return trackSynchronousRequestDataAccessInDev;
    },
    useDynamicRouteParams: function() {
        return useDynamicRouteParams;
    }
});
const _react = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)"));
const _hooksservercontext = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/hooks-server-context.js [app-ssr] (ecmascript)");
const _staticgenerationbailout = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/static-generation-bailout.js [app-ssr] (ecmascript)");
const _workunitasyncstorageexternal = __turbopack_context__.r("[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)");
const _workasyncstorageexternal = __turbopack_context__.r("[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)");
const _dynamicrenderingutils = __turbopack_context__.r("[project]/node_modules/next/dist/server/dynamic-rendering-utils.js [app-ssr] (ecmascript)");
const _metadataconstants = __turbopack_context__.r("[project]/node_modules/next/dist/lib/metadata/metadata-constants.js [app-ssr] (ecmascript)");
const _scheduler = __turbopack_context__.r("[project]/node_modules/next/dist/lib/scheduler.js [app-ssr] (ecmascript)");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const hasPostpone = typeof _react.default.unstable_postpone === 'function';
function createDynamicTrackingState(isDebugDynamicAccesses) {
    return {
        isDebugDynamicAccesses,
        dynamicAccesses: [],
        syncDynamicErrorWithStack: null
    };
}
function createDynamicValidationState() {
    return {
        hasSuspenseAboveBody: false,
        hasDynamicMetadata: false,
        hasDynamicViewport: false,
        hasAllowedDynamic: false,
        dynamicErrors: []
    };
}
function getFirstDynamicReason(trackingState) {
    var _trackingState_dynamicAccesses_;
    return (_trackingState_dynamicAccesses_ = trackingState.dynamicAccesses[0]) == null ? void 0 : _trackingState_dynamicAccesses_.expression;
}
function markCurrentScopeAsDynamic(store, workUnitStore, expression) {
    if (workUnitStore) {
        if (workUnitStore.type === 'cache' || workUnitStore.type === 'unstable-cache') {
            // inside cache scopes marking a scope as dynamic has no effect because the outer cache scope
            // creates a cache boundary. This is subtly different from reading a dynamic data source which is
            // forbidden inside a cache scope.
            return;
        }
    }
    // If we're forcing dynamic rendering or we're forcing static rendering, we
    // don't need to do anything here because the entire page is already dynamic
    // or it's static and it should not throw or postpone here.
    if (store.forceDynamic || store.forceStatic) return;
    if (store.dynamicShouldError) {
        throw Object.defineProperty(new _staticgenerationbailout.StaticGenBailoutError(`Route ${store.route} with \`dynamic = "error"\` couldn't be rendered statically because it used \`${expression}\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`), "__NEXT_ERROR_CODE", {
            value: "E553",
            enumerable: false,
            configurable: true
        });
    }
    if (workUnitStore) {
        if (workUnitStore.type === 'prerender-ppr') {
            postponeWithTracking(store.route, expression, workUnitStore.dynamicTracking);
        } else if (workUnitStore.type === 'prerender-legacy') {
            workUnitStore.revalidate = 0;
            // We aren't prerendering but we are generating a static page. We need to bail out of static generation
            const err = Object.defineProperty(new _hooksservercontext.DynamicServerError(`Route ${store.route} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`), "__NEXT_ERROR_CODE", {
                value: "E550",
                enumerable: false,
                configurable: true
            });
            store.dynamicUsageDescription = expression;
            store.dynamicUsageStack = err.stack;
            throw err;
        } else if (("TURBOPACK compile-time value", "development") === 'development' && workUnitStore && workUnitStore.type === 'request') {
            workUnitStore.usedDynamic = true;
        }
    }
}
function trackFallbackParamAccessed(store, expression) {
    const prerenderStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
    if (!prerenderStore || prerenderStore.type !== 'prerender-ppr') return;
    postponeWithTracking(store.route, expression, prerenderStore.dynamicTracking);
}
function throwToInterruptStaticGeneration(expression, store, prerenderStore) {
    // We aren't prerendering but we are generating a static page. We need to bail out of static generation
    const err = Object.defineProperty(new _hooksservercontext.DynamicServerError(`Route ${store.route} couldn't be rendered statically because it used \`${expression}\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`), "__NEXT_ERROR_CODE", {
        value: "E558",
        enumerable: false,
        configurable: true
    });
    prerenderStore.revalidate = 0;
    store.dynamicUsageDescription = expression;
    store.dynamicUsageStack = err.stack;
    throw err;
}
function trackDynamicDataInDynamicRender(_store, workUnitStore) {
    if (workUnitStore) {
        if (workUnitStore.type === 'cache' || workUnitStore.type === 'unstable-cache') {
            // inside cache scopes marking a scope as dynamic has no effect because the outer cache scope
            // creates a cache boundary. This is subtly different from reading a dynamic data source which is
            // forbidden inside a cache scope.
            return;
        }
        // TODO: it makes no sense to have these work unit store types during a dev render.
        if (workUnitStore.type === 'prerender' || workUnitStore.type === 'prerender-client' || workUnitStore.type === 'prerender-legacy') {
            workUnitStore.revalidate = 0;
        }
        if (("TURBOPACK compile-time value", "development") === 'development' && workUnitStore.type === 'request') {
            workUnitStore.usedDynamic = true;
        }
    }
}
function abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore) {
    const reason = `Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`;
    const error = createPrerenderInterruptedError(reason);
    prerenderStore.controller.abort(error);
    const dynamicTracking = prerenderStore.dynamicTracking;
    if (dynamicTracking) {
        dynamicTracking.dynamicAccesses.push({
            // When we aren't debugging, we don't need to create another error for the
            // stack trace.
            stack: dynamicTracking.isDebugDynamicAccesses ? new Error().stack : undefined,
            expression
        });
    }
}
function abortOnSynchronousPlatformIOAccess(route, expression, errorWithStack, prerenderStore) {
    const dynamicTracking = prerenderStore.dynamicTracking;
    abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore);
    // It is important that we set this tracking value after aborting. Aborts are executed
    // synchronously except for the case where you abort during render itself. By setting this
    // value late we can use it to determine if any of the aborted tasks are the task that
    // called the sync IO expression in the first place.
    if (dynamicTracking) {
        if (dynamicTracking.syncDynamicErrorWithStack === null) {
            dynamicTracking.syncDynamicErrorWithStack = errorWithStack;
        }
    }
}
function trackSynchronousPlatformIOAccessInDev(requestStore) {
    // We don't actually have a controller to abort but we do the semantic equivalent by
    // advancing the request store out of prerender mode
    requestStore.prerenderPhase = false;
}
function abortAndThrowOnSynchronousRequestDataAccess(route, expression, errorWithStack, prerenderStore) {
    const prerenderSignal = prerenderStore.controller.signal;
    if (prerenderSignal.aborted === false) {
        // TODO it would be better to move this aborted check into the callsite so we can avoid making
        // the error object when it isn't relevant to the aborting of the prerender however
        // since we need the throw semantics regardless of whether we abort it is easier to land
        // this way. See how this was handled with `abortOnSynchronousPlatformIOAccess` for a closer
        // to ideal implementation
        abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore);
        // It is important that we set this tracking value after aborting. Aborts are executed
        // synchronously except for the case where you abort during render itself. By setting this
        // value late we can use it to determine if any of the aborted tasks are the task that
        // called the sync IO expression in the first place.
        const dynamicTracking = prerenderStore.dynamicTracking;
        if (dynamicTracking) {
            if (dynamicTracking.syncDynamicErrorWithStack === null) {
                dynamicTracking.syncDynamicErrorWithStack = errorWithStack;
            }
        }
    }
    throw createPrerenderInterruptedError(`Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`);
}
const trackSynchronousRequestDataAccessInDev = trackSynchronousPlatformIOAccessInDev;
function Postpone({ reason, route }) {
    const prerenderStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
    const dynamicTracking = prerenderStore && prerenderStore.type === 'prerender-ppr' ? prerenderStore.dynamicTracking : null;
    postponeWithTracking(route, reason, dynamicTracking);
}
function postponeWithTracking(route, expression, dynamicTracking) {
    assertPostpone();
    if (dynamicTracking) {
        dynamicTracking.dynamicAccesses.push({
            // When we aren't debugging, we don't need to create another error for the
            // stack trace.
            stack: dynamicTracking.isDebugDynamicAccesses ? new Error().stack : undefined,
            expression
        });
    }
    _react.default.unstable_postpone(createPostponeReason(route, expression));
}
function createPostponeReason(route, expression) {
    return `Route ${route} needs to bail out of prerendering at this point because it used ${expression}. ` + `React throws this special object to indicate where. It should not be caught by ` + `your own try/catch. Learn more: https://nextjs.org/docs/messages/ppr-caught-error`;
}
function isDynamicPostpone(err) {
    if (typeof err === 'object' && err !== null && typeof err.message === 'string') {
        return isDynamicPostponeReason(err.message);
    }
    return false;
}
function isDynamicPostponeReason(reason) {
    return reason.includes('needs to bail out of prerendering at this point because it used') && reason.includes('Learn more: https://nextjs.org/docs/messages/ppr-caught-error');
}
if (isDynamicPostponeReason(createPostponeReason('%%%', '^^^')) === false) {
    throw Object.defineProperty(new Error('Invariant: isDynamicPostpone misidentified a postpone reason. This is a bug in Next.js'), "__NEXT_ERROR_CODE", {
        value: "E296",
        enumerable: false,
        configurable: true
    });
}
const NEXT_PRERENDER_INTERRUPTED = 'NEXT_PRERENDER_INTERRUPTED';
function createPrerenderInterruptedError(message) {
    const error = Object.defineProperty(new Error(message), "__NEXT_ERROR_CODE", {
        value: "E394",
        enumerable: false,
        configurable: true
    });
    error.digest = NEXT_PRERENDER_INTERRUPTED;
    return error;
}
function isPrerenderInterruptedError(error) {
    return typeof error === 'object' && error !== null && error.digest === NEXT_PRERENDER_INTERRUPTED && 'name' in error && 'message' in error && error instanceof Error;
}
function accessedDynamicData(dynamicAccesses) {
    return dynamicAccesses.length > 0;
}
function consumeDynamicAccess(serverDynamic, clientDynamic) {
    // We mutate because we only call this once we are no longer writing
    // to the dynamicTrackingState and it's more efficient than creating a new
    // array.
    serverDynamic.dynamicAccesses.push(...clientDynamic.dynamicAccesses);
    return serverDynamic.dynamicAccesses;
}
function formatDynamicAPIAccesses(dynamicAccesses) {
    return dynamicAccesses.filter((access)=>typeof access.stack === 'string' && access.stack.length > 0).map(({ expression, stack })=>{
        stack = stack.split('\n') // Remove the "Error: " prefix from the first line of the stack trace as
        // well as the first 4 lines of the stack trace which is the distance
        // from the user code and the `new Error().stack` call.
        .slice(4).filter((line)=>{
            // Exclude Next.js internals from the stack trace.
            if (line.includes('node_modules/next/')) {
                return false;
            }
            // Exclude anonymous functions from the stack trace.
            if (line.includes(' (<anonymous>)')) {
                return false;
            }
            // Exclude Node.js internals from the stack trace.
            if (line.includes(' (node:')) {
                return false;
            }
            return true;
        }).join('\n');
        return `Dynamic API Usage Debug - ${expression}:\n${stack}`;
    });
}
function assertPostpone() {
    if (!hasPostpone) {
        throw Object.defineProperty(new Error(`Invariant: React.unstable_postpone is not defined. This suggests the wrong version of React was loaded. This is a bug in Next.js`), "__NEXT_ERROR_CODE", {
            value: "E224",
            enumerable: false,
            configurable: true
        });
    }
}
function createPostponedAbortSignal(reason) {
    assertPostpone();
    const controller = new AbortController();
    // We get our hands on a postpone instance by calling postpone and catching the throw
    try {
        _react.default.unstable_postpone(reason);
    } catch (x) {
        controller.abort(x);
    }
    return controller.signal;
}
function createHangingInputAbortSignal(workUnitStore) {
    const controller = new AbortController();
    if (workUnitStore.cacheSignal) {
        // If we have a cacheSignal it means we're in a prospective render. If the input
        // we're waiting on is coming from another cache, we do want to wait for it so that
        // we can resolve this cache entry too.
        workUnitStore.cacheSignal.inputReady().then(()=>{
            controller.abort();
        });
    } else {
        // Otherwise we're in the final render and we should already have all our caches
        // filled. We might still be waiting on some microtasks so we wait one tick before
        // giving up. When we give up, we still want to render the content of this cache
        // as deeply as we can so that we can suspend as deeply as possible in the tree
        // or not at all if we don't end up waiting for the input.
        (0, _scheduler.scheduleOnNextTick)(()=>controller.abort());
    }
    return controller.signal;
}
function annotateDynamicAccess(expression, prerenderStore) {
    const dynamicTracking = prerenderStore.dynamicTracking;
    if (dynamicTracking) {
        dynamicTracking.dynamicAccesses.push({
            stack: dynamicTracking.isDebugDynamicAccesses ? new Error().stack : undefined,
            expression
        });
    }
}
function useDynamicRouteParams(expression) {
    const workStore = _workasyncstorageexternal.workAsyncStorage.getStore();
    if (workStore && workStore.isStaticGeneration && workStore.fallbackRouteParams && workStore.fallbackRouteParams.size > 0) {
        // There are fallback route params, we should track these as dynamic
        // accesses.
        const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
        if (workUnitStore) {
            // We're prerendering with dynamicIO or PPR or both
            if (workUnitStore.type === 'prerender-client') {
                // We are in a prerender with dynamicIO semantics
                // We are going to hang here and never resolve. This will cause the currently
                // rendering component to effectively be a dynamic hole
                _react.default.use((0, _dynamicrenderingutils.makeHangingPromise)(workUnitStore.renderSignal, expression));
            } else if (workUnitStore.type === 'prerender-ppr') {
                // We're prerendering with PPR
                postponeWithTracking(workStore.route, expression, workUnitStore.dynamicTracking);
            } else if (workUnitStore.type === 'prerender-legacy') {
                throwToInterruptStaticGeneration(expression, workStore, workUnitStore);
            }
        }
    }
}
const hasSuspenseRegex = /\n\s+at Suspense \(<anonymous>\)/;
const hasSuspenseAfterBodyOrHtmlRegex = /\n\s+at (?:body|html) \(<anonymous>\)[\s\S]*?\n\s+at Suspense \(<anonymous>\)/;
const hasMetadataRegex = new RegExp(`\\n\\s+at ${_metadataconstants.METADATA_BOUNDARY_NAME}[\\n\\s]`);
const hasViewportRegex = new RegExp(`\\n\\s+at ${_metadataconstants.VIEWPORT_BOUNDARY_NAME}[\\n\\s]`);
const hasOutletRegex = new RegExp(`\\n\\s+at ${_metadataconstants.OUTLET_BOUNDARY_NAME}[\\n\\s]`);
function trackAllowedDynamicAccess(workStore, componentStack, dynamicValidation, clientDynamic) {
    if (hasOutletRegex.test(componentStack)) {
        // We don't need to track that this is dynamic. It is only so when something else is also dynamic.
        return;
    } else if (hasMetadataRegex.test(componentStack)) {
        dynamicValidation.hasDynamicMetadata = true;
        return;
    } else if (hasViewportRegex.test(componentStack)) {
        dynamicValidation.hasDynamicViewport = true;
        return;
    } else if (hasSuspenseAfterBodyOrHtmlRegex.test(componentStack)) {
        // This prerender has a Suspense boundary above the body which
        // effectively opts the page into allowing 100% dynamic rendering
        dynamicValidation.hasAllowedDynamic = true;
        dynamicValidation.hasSuspenseAboveBody = true;
        return;
    } else if (hasSuspenseRegex.test(componentStack)) {
        // this error had a Suspense boundary above it so we don't need to report it as a source
        // of disallowed
        dynamicValidation.hasAllowedDynamic = true;
        return;
    } else if (clientDynamic.syncDynamicErrorWithStack) {
        // This task was the task that called the sync error.
        dynamicValidation.dynamicErrors.push(clientDynamic.syncDynamicErrorWithStack);
        return;
    } else {
        const message = `Route "${workStore.route}": A component accessed data, headers, params, searchParams, or a short-lived cache without a Suspense boundary nor a "use cache" above it. See more info: https://nextjs.org/docs/messages/next-prerender-missing-suspense`;
        const error = createErrorWithComponentOrOwnerStack(message, componentStack);
        dynamicValidation.dynamicErrors.push(error);
        return;
    }
}
/**
 * In dev mode, we prefer using the owner stack, otherwise the provided
 * component stack is used.
 */ function createErrorWithComponentOrOwnerStack(message, componentStack) {
    const ownerStack = ("TURBOPACK compile-time value", "development") !== 'production' && _react.default.captureOwnerStack ? _react.default.captureOwnerStack() : null;
    const error = Object.defineProperty(new Error(message), "__NEXT_ERROR_CODE", {
        value: "E394",
        enumerable: false,
        configurable: true
    });
    error.stack = error.name + ': ' + message + (ownerStack ?? componentStack);
    return error;
}
var PreludeState = /*#__PURE__*/ function(PreludeState) {
    PreludeState[PreludeState["Full"] = 0] = "Full";
    PreludeState[PreludeState["Empty"] = 1] = "Empty";
    PreludeState[PreludeState["Errored"] = 2] = "Errored";
    return PreludeState;
}({});
function logDisallowedDynamicError(workStore, error) {
    console.error(error);
    if (!workStore.dev) {
        if (workStore.hasReadableErrorStacks) {
            console.error(`To get a more detailed stack trace and pinpoint the issue, start the app in development mode by running \`next dev\`, then open "${workStore.route}" in your browser to investigate the error.`);
        } else {
            console.error(`To get a more detailed stack trace and pinpoint the issue, try one of the following:
  - Start the app in development mode by running \`next dev\`, then open "${workStore.route}" in your browser to investigate the error.
  - Rerun the production build with \`next build --debug-prerender\` to generate better stack traces.`);
        }
    }
}
function throwIfDisallowedDynamic(workStore, prelude, dynamicValidation, serverDynamic) {
    if (workStore.invalidDynamicUsageError) {
        logDisallowedDynamicError(workStore, workStore.invalidDynamicUsageError);
        throw new _staticgenerationbailout.StaticGenBailoutError();
    }
    if (prelude !== 0) {
        if (dynamicValidation.hasSuspenseAboveBody) {
            // This route has opted into allowing fully dynamic rendering
            // by including a Suspense boundary above the body. In this case
            // a lack of a shell is not considered disallowed so we simply return
            return;
        }
        if (serverDynamic.syncDynamicErrorWithStack) {
            // There is no shell and the server did something sync dynamic likely
            // leading to an early termination of the prerender before the shell
            // could be completed. We terminate the build/validating render.
            logDisallowedDynamicError(workStore, serverDynamic.syncDynamicErrorWithStack);
            throw new _staticgenerationbailout.StaticGenBailoutError();
        }
        // We didn't have any sync bailouts but there may be user code which
        // blocked the root. We would have captured these during the prerender
        // and can log them here and then terminate the build/validating render
        const dynamicErrors = dynamicValidation.dynamicErrors;
        if (dynamicErrors.length > 0) {
            for(let i = 0; i < dynamicErrors.length; i++){
                logDisallowedDynamicError(workStore, dynamicErrors[i]);
            }
            throw new _staticgenerationbailout.StaticGenBailoutError();
        }
        // If we got this far then the only other thing that could be blocking
        // the root is dynamic Viewport. If this is dynamic then
        // you need to opt into that by adding a Suspense boundary above the body
        // to indicate your are ok with fully dynamic rendering.
        if (dynamicValidation.hasDynamicViewport) {
            console.error(`Route "${workStore.route}" has a \`generateViewport\` that depends on Request data (\`cookies()\`, etc...) or uncached external data (\`fetch(...)\`, etc...) without explicitly allowing fully dynamic rendering. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-viewport`);
            throw new _staticgenerationbailout.StaticGenBailoutError();
        }
        if (prelude === 1) {
            // If we ever get this far then we messed up the tracking of invalid dynamic.
            // We still adhere to the constraint that you must produce a shell but invite the
            // user to report this as a bug in Next.js.
            console.error(`Route "${workStore.route}" did not produce a static shell and Next.js was unable to determine a reason. This is a bug in Next.js.`);
            throw new _staticgenerationbailout.StaticGenBailoutError();
        }
    } else {
        if (dynamicValidation.hasAllowedDynamic === false && dynamicValidation.hasDynamicMetadata) {
            console.error(`Route "${workStore.route}" has a \`generateMetadata\` that depends on Request data (\`cookies()\`, etc...) or uncached external data (\`fetch(...)\`, etc...) when the rest of the route does not. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-metadata`);
            throw new _staticgenerationbailout.StaticGenBailoutError();
        }
    }
} //# sourceMappingURL=dynamic-rendering.js.map
}}),
"[project]/node_modules/next/dist/client/components/unstable-rethrow.server.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "unstable_rethrow", {
    enumerable: true,
    get: function() {
        return unstable_rethrow;
    }
});
const _dynamicrenderingutils = __turbopack_context__.r("[project]/node_modules/next/dist/server/dynamic-rendering-utils.js [app-ssr] (ecmascript)");
const _ispostpone = __turbopack_context__.r("[project]/node_modules/next/dist/server/lib/router-utils/is-postpone.js [app-ssr] (ecmascript)");
const _bailouttocsr = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/lazy-dynamic/bailout-to-csr.js [app-ssr] (ecmascript)");
const _isnextroutererror = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/is-next-router-error.js [app-ssr] (ecmascript)");
const _dynamicrendering = __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/dynamic-rendering.js [app-ssr] (ecmascript)");
const _hooksservercontext = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/hooks-server-context.js [app-ssr] (ecmascript)");
function unstable_rethrow(error) {
    if ((0, _isnextroutererror.isNextRouterError)(error) || (0, _bailouttocsr.isBailoutToCSRError)(error) || (0, _hooksservercontext.isDynamicServerError)(error) || (0, _dynamicrendering.isDynamicPostpone)(error) || (0, _ispostpone.isPostpone)(error) || (0, _dynamicrenderingutils.isHangingPromiseRejectionError)(error)) {
        throw error;
    }
    if (error instanceof Error && 'cause' in error) {
        unstable_rethrow(error.cause);
    }
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=unstable-rethrow.server.js.map
}}),
"[project]/node_modules/next/dist/client/components/unstable-rethrow.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/**
 * This function should be used to rethrow internal Next.js errors so that they can be handled by the framework.
 * When wrapping an API that uses errors to interrupt control flow, you should use this function before you do any error handling.
 * This function will rethrow the error if it is a Next.js error so it can be handled, otherwise it will do nothing.
 *
 * Read more: [Next.js Docs: `unstable_rethrow`](https://nextjs.org/docs/app/api-reference/functions/unstable_rethrow)
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "unstable_rethrow", {
    enumerable: true,
    get: function() {
        return unstable_rethrow;
    }
});
const unstable_rethrow = ("TURBOPACK compile-time truthy", 1) ? __turbopack_context__.r("[project]/node_modules/next/dist/client/components/unstable-rethrow.server.js [app-ssr] (ecmascript)").unstable_rethrow : "TURBOPACK unreachable";
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=unstable-rethrow.js.map
}}),
"[project]/node_modules/next/dist/client/components/navigation.react-server.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/** @internal */ Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    ReadonlyURLSearchParams: null,
    RedirectType: null,
    forbidden: null,
    notFound: null,
    permanentRedirect: null,
    redirect: null,
    unauthorized: null,
    unstable_rethrow: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    ReadonlyURLSearchParams: function() {
        return ReadonlyURLSearchParams;
    },
    RedirectType: function() {
        return _redirecterror.RedirectType;
    },
    forbidden: function() {
        return _forbidden.forbidden;
    },
    notFound: function() {
        return _notfound.notFound;
    },
    permanentRedirect: function() {
        return _redirect.permanentRedirect;
    },
    redirect: function() {
        return _redirect.redirect;
    },
    unauthorized: function() {
        return _unauthorized.unauthorized;
    },
    unstable_rethrow: function() {
        return _unstablerethrow.unstable_rethrow;
    }
});
const _redirect = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/redirect.js [app-ssr] (ecmascript)");
const _redirecterror = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/redirect-error.js [app-ssr] (ecmascript)");
const _notfound = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/not-found.js [app-ssr] (ecmascript)");
const _forbidden = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/forbidden.js [app-ssr] (ecmascript)");
const _unauthorized = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/unauthorized.js [app-ssr] (ecmascript)");
const _unstablerethrow = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/unstable-rethrow.js [app-ssr] (ecmascript)");
class ReadonlyURLSearchParamsError extends Error {
    constructor(){
        super('Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams');
    }
}
class ReadonlyURLSearchParams extends URLSearchParams {
    /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */ append() {
        throw new ReadonlyURLSearchParamsError();
    }
    /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */ delete() {
        throw new ReadonlyURLSearchParamsError();
    }
    /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */ set() {
        throw new ReadonlyURLSearchParamsError();
    }
    /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */ sort() {
        throw new ReadonlyURLSearchParamsError();
    }
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=navigation.react-server.js.map
}}),
"[project]/node_modules/next/dist/client/components/bailout-to-client-rendering.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "bailoutToClientRendering", {
    enumerable: true,
    get: function() {
        return bailoutToClientRendering;
    }
});
const _bailouttocsr = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/lazy-dynamic/bailout-to-csr.js [app-ssr] (ecmascript)");
const _workasyncstorageexternal = __turbopack_context__.r("[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)");
const _workunitasyncstorageexternal = __turbopack_context__.r("[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)");
function bailoutToClientRendering(reason) {
    const workStore = _workasyncstorageexternal.workAsyncStorage.getStore();
    if (workStore == null ? void 0 : workStore.forceStatic) return;
    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
    if (workUnitStore) {
        switch(workUnitStore.type){
            case 'prerender':
            case 'prerender-client':
            case 'prerender-ppr':
            case 'prerender-legacy':
                throw Object.defineProperty(new _bailouttocsr.BailoutToCSRError(reason), "__NEXT_ERROR_CODE", {
                    value: "E394",
                    enumerable: false,
                    configurable: true
                });
            default:
        }
    }
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=bailout-to-client-rendering.js.map
}}),
"[project]/node_modules/next/dist/client/components/navigation.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    ReadonlyURLSearchParams: null,
    RedirectType: null,
    ServerInsertedHTMLContext: null,
    forbidden: null,
    notFound: null,
    permanentRedirect: null,
    redirect: null,
    unauthorized: null,
    unstable_rethrow: null,
    useParams: null,
    usePathname: null,
    useRouter: null,
    useSearchParams: null,
    useSelectedLayoutSegment: null,
    useSelectedLayoutSegments: null,
    useServerInsertedHTML: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    ReadonlyURLSearchParams: function() {
        return _navigationreactserver.ReadonlyURLSearchParams;
    },
    RedirectType: function() {
        return _navigationreactserver.RedirectType;
    },
    ServerInsertedHTMLContext: function() {
        return _serverinsertedhtmlsharedruntime.ServerInsertedHTMLContext;
    },
    forbidden: function() {
        return _navigationreactserver.forbidden;
    },
    notFound: function() {
        return _navigationreactserver.notFound;
    },
    permanentRedirect: function() {
        return _navigationreactserver.permanentRedirect;
    },
    redirect: function() {
        return _navigationreactserver.redirect;
    },
    unauthorized: function() {
        return _navigationreactserver.unauthorized;
    },
    unstable_rethrow: function() {
        return _navigationreactserver.unstable_rethrow;
    },
    useParams: function() {
        return useParams;
    },
    usePathname: function() {
        return usePathname;
    },
    useRouter: function() {
        return useRouter;
    },
    useSearchParams: function() {
        return useSearchParams;
    },
    useSelectedLayoutSegment: function() {
        return useSelectedLayoutSegment;
    },
    useSelectedLayoutSegments: function() {
        return useSelectedLayoutSegments;
    },
    useServerInsertedHTML: function() {
        return _serverinsertedhtmlsharedruntime.useServerInsertedHTML;
    }
});
const _react = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
const _approutercontextsharedruntime = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/contexts/app-router-context.js [app-ssr] (ecmascript)");
const _hooksclientcontextsharedruntime = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/contexts/hooks-client-context.js [app-ssr] (ecmascript)");
const _getsegmentvalue = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/reducers/get-segment-value.js [app-ssr] (ecmascript)");
const _segment = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/segment.js [app-ssr] (ecmascript)");
const _navigationreactserver = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/navigation.react-server.js [app-ssr] (ecmascript)");
const _serverinsertedhtmlsharedruntime = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/contexts/server-inserted-html.js [app-ssr] (ecmascript)");
const useDynamicRouteParams = ("TURBOPACK compile-time truthy", 1) ? __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/dynamic-rendering.js [app-ssr] (ecmascript)").useDynamicRouteParams : "TURBOPACK unreachable";
function useSearchParams() {
    const searchParams = (0, _react.useContext)(_hooksclientcontextsharedruntime.SearchParamsContext);
    // In the case where this is `null`, the compat types added in
    // `next-env.d.ts` will add a new overload that changes the return type to
    // include `null`.
    const readonlySearchParams = (0, _react.useMemo)(()=>{
        if (!searchParams) {
            // When the router is not ready in pages, we won't have the search params
            // available.
            return null;
        }
        return new _navigationreactserver.ReadonlyURLSearchParams(searchParams);
    }, [
        searchParams
    ]);
    if ("TURBOPACK compile-time truthy", 1) {
        // AsyncLocalStorage should not be included in the client bundle.
        const { bailoutToClientRendering } = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/bailout-to-client-rendering.js [app-ssr] (ecmascript)");
        // TODO-APP: handle dynamic = 'force-static' here and on the client
        bailoutToClientRendering('useSearchParams()');
    }
    return readonlySearchParams;
}
function usePathname() {
    useDynamicRouteParams == null ? void 0 : useDynamicRouteParams('usePathname()');
    // In the case where this is `null`, the compat types added in `next-env.d.ts`
    // will add a new overload that changes the return type to include `null`.
    return (0, _react.useContext)(_hooksclientcontextsharedruntime.PathnameContext);
}
function useRouter() {
    const router = (0, _react.useContext)(_approutercontextsharedruntime.AppRouterContext);
    if (router === null) {
        throw Object.defineProperty(new Error('invariant expected app router to be mounted'), "__NEXT_ERROR_CODE", {
            value: "E238",
            enumerable: false,
            configurable: true
        });
    }
    return router;
}
function useParams() {
    useDynamicRouteParams == null ? void 0 : useDynamicRouteParams('useParams()');
    return (0, _react.useContext)(_hooksclientcontextsharedruntime.PathParamsContext);
}
/** Get the canonical parameters from the current level to the leaf node. */ // Client components API
function getSelectedLayoutSegmentPath(tree, parallelRouteKey, first, segmentPath) {
    if (first === void 0) first = true;
    if (segmentPath === void 0) segmentPath = [];
    let node;
    if (first) {
        // Use the provided parallel route key on the first parallel route
        node = tree[1][parallelRouteKey];
    } else {
        // After first parallel route prefer children, if there's no children pick the first parallel route.
        const parallelRoutes = tree[1];
        var _parallelRoutes_children;
        node = (_parallelRoutes_children = parallelRoutes.children) != null ? _parallelRoutes_children : Object.values(parallelRoutes)[0];
    }
    if (!node) return segmentPath;
    const segment = node[0];
    let segmentValue = (0, _getsegmentvalue.getSegmentValue)(segment);
    if (!segmentValue || segmentValue.startsWith(_segment.PAGE_SEGMENT_KEY)) {
        return segmentPath;
    }
    segmentPath.push(segmentValue);
    return getSelectedLayoutSegmentPath(node, parallelRouteKey, false, segmentPath);
}
function useSelectedLayoutSegments(parallelRouteKey) {
    if (parallelRouteKey === void 0) parallelRouteKey = 'children';
    useDynamicRouteParams == null ? void 0 : useDynamicRouteParams('useSelectedLayoutSegments()');
    const context = (0, _react.useContext)(_approutercontextsharedruntime.LayoutRouterContext);
    // @ts-expect-error This only happens in `pages`. Type is overwritten in navigation.d.ts
    if (!context) return null;
    return getSelectedLayoutSegmentPath(context.parentTree, parallelRouteKey);
}
function useSelectedLayoutSegment(parallelRouteKey) {
    if (parallelRouteKey === void 0) parallelRouteKey = 'children';
    useDynamicRouteParams == null ? void 0 : useDynamicRouteParams('useSelectedLayoutSegment()');
    const selectedLayoutSegments = useSelectedLayoutSegments(parallelRouteKey);
    if (!selectedLayoutSegments || selectedLayoutSegments.length === 0) {
        return null;
    }
    const selectedLayoutSegment = parallelRouteKey === 'children' ? selectedLayoutSegments[0] : selectedLayoutSegments[selectedLayoutSegments.length - 1];
    // if the default slot is showing, we return null since it's not technically "selected" (it's a fallback)
    // and returning an internal value like `__DEFAULT__` would be confusing.
    return selectedLayoutSegment === _segment.DEFAULT_SEGMENT_KEY ? null : selectedLayoutSegment;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=navigation.js.map
}}),
"[project]/node_modules/next/dist/client/components/redirect-boundary.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    RedirectBoundary: null,
    RedirectErrorBoundary: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    RedirectBoundary: function() {
        return RedirectBoundary;
    },
    RedirectErrorBoundary: function() {
        return RedirectErrorBoundary;
    }
});
const _interop_require_wildcard = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [app-ssr] (ecmascript)");
const _jsxruntime = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js [app-ssr] (ecmascript)");
const _react = /*#__PURE__*/ _interop_require_wildcard._(__turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)"));
const _navigation = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/navigation.js [app-ssr] (ecmascript)");
const _redirect = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/redirect.js [app-ssr] (ecmascript)");
const _redirecterror = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/redirect-error.js [app-ssr] (ecmascript)");
function HandleRedirect(param) {
    let { redirect, reset, redirectType } = param;
    const router = (0, _navigation.useRouter)();
    (0, _react.useEffect)(()=>{
        _react.default.startTransition(()=>{
            if (redirectType === _redirecterror.RedirectType.push) {
                router.push(redirect, {});
            } else {
                router.replace(redirect, {});
            }
            reset();
        });
    }, [
        redirect,
        redirectType,
        reset,
        router
    ]);
    return null;
}
class RedirectErrorBoundary extends _react.default.Component {
    static getDerivedStateFromError(error) {
        if ((0, _redirecterror.isRedirectError)(error)) {
            const url = (0, _redirect.getURLFromRedirectError)(error);
            const redirectType = (0, _redirect.getRedirectTypeFromError)(error);
            return {
                redirect: url,
                redirectType
            };
        }
        // Re-throw if error is not for redirect
        throw error;
    }
    // Explicit type is needed to avoid the generated `.d.ts` having a wide return type that could be specific to the `@types/react` version.
    render() {
        const { redirect, redirectType } = this.state;
        if (redirect !== null && redirectType !== null) {
            return /*#__PURE__*/ (0, _jsxruntime.jsx)(HandleRedirect, {
                redirect: redirect,
                redirectType: redirectType,
                reset: ()=>this.setState({
                        redirect: null
                    })
            });
        }
        return this.props.children;
    }
    constructor(props){
        super(props);
        this.state = {
            redirect: null,
            redirectType: null
        };
    }
}
function RedirectBoundary(param) {
    let { children } = param;
    const router = (0, _navigation.useRouter)();
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(RedirectErrorBoundary, {
        router: router,
        children: children
    });
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=redirect-boundary.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/reducers/find-head-in-cache.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "findHeadInCache", {
    enumerable: true,
    get: function() {
        return findHeadInCache;
    }
});
const _segment = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/segment.js [app-ssr] (ecmascript)");
const _createroutercachekey = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js [app-ssr] (ecmascript)");
function findHeadInCache(cache, parallelRoutes) {
    return findHeadInCacheImpl(cache, parallelRoutes, '');
}
function findHeadInCacheImpl(cache, parallelRoutes, keyPrefix) {
    const isLastItem = Object.keys(parallelRoutes).length === 0;
    if (isLastItem) {
        // Returns the entire Cache Node of the segment whose head we will render.
        return [
            cache,
            keyPrefix
        ];
    }
    // First try the 'children' parallel route if it exists
    // when starting from the "root", this corresponds with the main page component
    const parallelRoutesKeys = Object.keys(parallelRoutes).filter((key)=>key !== 'children');
    // if we are at the root, we need to check the children slot first
    if ('children' in parallelRoutes) {
        parallelRoutesKeys.unshift('children');
    }
    for (const key of parallelRoutesKeys){
        const [segment, childParallelRoutes] = parallelRoutes[key];
        // If the parallel is not matched and using the default segment,
        // skip searching the head from it.
        if (segment === _segment.DEFAULT_SEGMENT_KEY) {
            continue;
        }
        const childSegmentMap = cache.parallelRoutes.get(key);
        if (!childSegmentMap) {
            continue;
        }
        const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(segment);
        const cacheNode = childSegmentMap.get(cacheKey);
        if (!cacheNode) {
            continue;
        }
        const item = findHeadInCacheImpl(cacheNode, childParallelRoutes, keyPrefix + '/' + cacheKey);
        if (item) {
            return item;
        }
    }
    return null;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=find-head-in-cache.js.map
}}),
"[project]/node_modules/next/dist/client/components/unresolved-thenable.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/**
 * Create a "Thenable" that does not resolve. This is used to suspend indefinitely when data is not available yet.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "unresolvedThenable", {
    enumerable: true,
    get: function() {
        return unresolvedThenable;
    }
});
const unresolvedThenable = {
    then: ()=>{}
};
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=unresolved-thenable.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "pathHasPrefix", {
    enumerable: true,
    get: function() {
        return pathHasPrefix;
    }
});
const _parsepath = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/parse-path.js [app-ssr] (ecmascript)");
function pathHasPrefix(path, prefix) {
    if (typeof path !== 'string') {
        return false;
    }
    const { pathname } = (0, _parsepath.parsePath)(path);
    return pathname === prefix || pathname.startsWith(prefix + '/');
} //# sourceMappingURL=path-has-prefix.js.map
}}),
"[project]/node_modules/next/dist/client/has-base-path.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "hasBasePath", {
    enumerable: true,
    get: function() {
        return hasBasePath;
    }
});
const _pathhasprefix = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js [app-ssr] (ecmascript)");
const basePath = ("TURBOPACK compile-time value", "") || '';
function hasBasePath(path) {
    return (0, _pathhasprefix.pathHasPrefix)(path, basePath);
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=has-base-path.js.map
}}),
"[project]/node_modules/next/dist/client/remove-base-path.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "removeBasePath", {
    enumerable: true,
    get: function() {
        return removeBasePath;
    }
});
const _hasbasepath = __turbopack_context__.r("[project]/node_modules/next/dist/client/has-base-path.js [app-ssr] (ecmascript)");
const basePath = ("TURBOPACK compile-time value", "") || '';
function removeBasePath(path) {
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    // Can't trim the basePath if it has zero length!
    if (basePath.length === 0) return path;
    path = path.slice(basePath.length);
    if (!path.startsWith('/')) path = "/" + path;
    return path;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=remove-base-path.js.map
}}),
"[project]/node_modules/next/dist/client/components/errors/graceful-degrade-boundary.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    GracefulDegradeBoundary: null,
    default: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    GracefulDegradeBoundary: function() {
        return GracefulDegradeBoundary;
    },
    default: function() {
        return _default;
    }
});
const _jsxruntime = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js [app-ssr] (ecmascript)");
const _react = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
function getDomNodeAttributes(node) {
    const result = {};
    for(let i = 0; i < node.attributes.length; i++){
        const attr = node.attributes[i];
        result[attr.name] = attr.value;
    }
    return result;
}
class GracefulDegradeBoundary extends _react.Component {
    static getDerivedStateFromError(_) {
        return {
            hasError: true
        };
    }
    componentDidMount() {
        const htmlNode = this.htmlRef.current;
        if (this.state.hasError && htmlNode) {
            // Reapply the cached HTML attributes to the root element
            Object.entries(this.htmlAttributes).forEach((param)=>{
                let [key, value] = param;
                htmlNode.setAttribute(key, value);
            });
        }
    }
    render() {
        const { hasError } = this.state;
        // Cache the root HTML content on the first render
        if ("undefined" !== 'undefined' && !this.rootHtml) //TURBOPACK unreachable
        ;
        if (hasError) {
            // Render the current HTML content without hydration
            return /*#__PURE__*/ (0, _jsxruntime.jsx)("html", {
                ref: this.htmlRef,
                suppressHydrationWarning: true,
                dangerouslySetInnerHTML: {
                    __html: this.rootHtml
                }
            });
        }
        return this.props.children;
    }
    constructor(props){
        super(props);
        this.state = {
            hasError: false
        };
        this.rootHtml = '';
        this.htmlAttributes = {};
        this.htmlRef = /*#__PURE__*/ (0, _react.createRef)();
    }
}
const _default = GracefulDegradeBoundary;
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=graceful-degrade-boundary.js.map
}}),
"[project]/node_modules/next/dist/compiled/strip-ansi/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
(()=>{
    "use strict";
    var e = {
        511: (e)=>{
            e.exports = ({ onlyFirst: e = false } = {})=>{
                const r = [
                    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
                    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
                ].join("|");
                return new RegExp(r, e ? undefined : "g");
            };
        },
        532: (e, r, _)=>{
            const t = _(511);
            e.exports = (e)=>typeof e === "string" ? e.replace(t(), "") : e;
        }
    };
    var r = {};
    function __nccwpck_require__(_) {
        var t = r[_];
        if (t !== undefined) {
            return t.exports;
        }
        var a = r[_] = {
            exports: {}
        };
        var n = true;
        try {
            e[_](a, a.exports, __nccwpck_require__);
            n = false;
        } finally{
            if (n) delete r[_];
        }
        return a.exports;
    }
    if (typeof __nccwpck_require__ !== "undefined") __nccwpck_require__.ab = ("TURBOPACK compile-time value", "/ROOT/node_modules/next/dist/compiled/strip-ansi") + "/";
    var _ = __nccwpck_require__(532);
    module.exports = _;
})();
}}),
"[project]/node_modules/next/dist/shared/lib/format-webpack-messages.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/**
MIT License

Copyright (c) 2015-present, Facebook, Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/ Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return formatWebpackMessages;
    }
});
const _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-ssr] (ecmascript)");
const _stripansi = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/strip-ansi/index.js [app-ssr] (ecmascript)"));
// This file is based on https://github.com/facebook/create-react-app/blob/7b1a32be6ec9f99a6c9a3c66813f3ac09c4736b9/packages/react-dev-utils/formatWebpackMessages.js
// It's been edited to remove chalk and CRA-specific logic
const friendlySyntaxErrorLabel = 'Syntax error:';
const WEBPACK_BREAKING_CHANGE_POLYFILLS = '\n\nBREAKING CHANGE: webpack < 5 used to include polyfills for node.js core modules by default.';
function isLikelyASyntaxError(message) {
    return (0, _stripansi.default)(message).includes(friendlySyntaxErrorLabel);
}
let hadMissingSassError = false;
// Cleans up webpack error messages.
function formatMessage(message, verbose, importTraceNote) {
    // TODO: Replace this once webpack 5 is stable
    if (typeof message === 'object' && message.message) {
        const filteredModuleTrace = message.moduleTrace && message.moduleTrace.filter((trace)=>!/next-(middleware|client-pages|route|edge-function)-loader\.js/.test(trace.originName));
        let body = message.message;
        const breakingChangeIndex = body.indexOf(WEBPACK_BREAKING_CHANGE_POLYFILLS);
        if (breakingChangeIndex >= 0) {
            body = body.slice(0, breakingChangeIndex);
        }
        message = (message.moduleName ? (0, _stripansi.default)(message.moduleName) + '\n' : '') + (message.file ? (0, _stripansi.default)(message.file) + '\n' : '') + body + (message.details && verbose ? '\n' + message.details : '') + (filteredModuleTrace && filteredModuleTrace.length ? (importTraceNote || '\n\nImport trace for requested module:') + filteredModuleTrace.map((trace)=>"\n" + trace.moduleName).join('') : '') + (message.stack && verbose ? '\n' + message.stack : '');
    }
    let lines = message.split('\n');
    // Strip Webpack-added headers off errors/warnings
    // https://github.com/webpack/webpack/blob/master/lib/ModuleError.js
    lines = lines.filter((line)=>!/Module [A-z ]+\(from/.test(line));
    // Transform parsing error into syntax error
    // TODO: move this to our ESLint formatter?
    lines = lines.map((line)=>{
        const parsingError = /Line (\d+):(?:(\d+):)?\s*Parsing error: (.+)$/.exec(line);
        if (!parsingError) {
            return line;
        }
        const [, errorLine, errorColumn, errorMessage] = parsingError;
        return friendlySyntaxErrorLabel + " " + errorMessage + " (" + errorLine + ":" + errorColumn + ")";
    });
    message = lines.join('\n');
    // Smoosh syntax errors (commonly found in CSS)
    message = message.replace(/SyntaxError\s+\((\d+):(\d+)\)\s*(.+?)\n/g, "" + friendlySyntaxErrorLabel + " $3 ($1:$2)\n");
    // Clean up export errors
    message = message.replace(/^.*export '(.+?)' was not found in '(.+?)'.*$/gm, "Attempted import error: '$1' is not exported from '$2'.");
    message = message.replace(/^.*export 'default' \(imported as '(.+?)'\) was not found in '(.+?)'.*$/gm, "Attempted import error: '$2' does not contain a default export (imported as '$1').");
    message = message.replace(/^.*export '(.+?)' \(imported as '(.+?)'\) was not found in '(.+?)'.*$/gm, "Attempted import error: '$1' is not exported from '$3' (imported as '$2').");
    lines = message.split('\n');
    // Remove leading newline
    if (lines.length > 2 && lines[1].trim() === '') {
        lines.splice(1, 1);
    }
    // Cleans up verbose "module not found" messages for files and packages.
    if (lines[1] && lines[1].startsWith('Module not found: ')) {
        lines = [
            lines[0],
            lines[1].replace('Error: ', '').replace('Module not found: Cannot find file:', 'Cannot find file:'),
            ...lines.slice(2)
        ];
    }
    // Add helpful message for users trying to use Sass for the first time
    if (lines[1] && lines[1].match(/Cannot find module.+sass/)) {
        // ./file.module.scss (<<loader info>>) => ./file.module.scss
        const firstLine = lines[0].split('!');
        lines[0] = firstLine[firstLine.length - 1];
        lines[1] = "To use Next.js' built-in Sass support, you first need to install `sass`.\n";
        lines[1] += 'Run `npm i sass` or `yarn add sass` inside your workspace.\n';
        lines[1] += '\nLearn more: https://nextjs.org/docs/messages/install-sass';
        // dispose of unhelpful stack trace
        lines = lines.slice(0, 2);
        hadMissingSassError = true;
    } else if (hadMissingSassError && message.match(/(sass-loader|resolve-url-loader: CSS error)/)) {
        // dispose of unhelpful stack trace following missing sass module
        lines = [];
    }
    if (!verbose) {
        message = lines.join('\n');
        // Internal stacks are generally useless so we strip them... with the
        // exception of stacks containing `webpack:` because they're normally
        // from user code generated by Webpack. For more information see
        // https://github.com/facebook/create-react-app/pull/1050
        message = message.replace(/^\s*at\s((?!webpack:).)*:\d+:\d+[\s)]*(\n|$)/gm, '') // at ... ...:x:y
        ;
        message = message.replace(/^\s*at\s<anonymous>(\n|$)/gm, '') // at <anonymous>
        ;
        message = message.replace(/File was processed with these loaders:\n(.+[\\/](next[\\/]dist[\\/].+|@next[\\/]react-refresh-utils[\\/]loader)\.js\n)*You may need an additional loader to handle the result of these loaders.\n/g, '');
        lines = message.split('\n');
    }
    // Remove duplicated newlines
    lines = lines.filter((line, index, arr)=>index === 0 || line.trim() !== '' || line.trim() !== arr[index - 1].trim());
    // Reassemble the message
    message = lines.join('\n');
    return message.trim();
}
function formatWebpackMessages(json, verbose) {
    const formattedErrors = json.errors.map((message)=>{
        const isUnknownNextFontError = message.message.includes('An error occurred in `next/font`.');
        return formatMessage(message, isUnknownNextFontError || verbose);
    });
    const formattedWarnings = json.warnings.map((message)=>{
        return formatMessage(message, verbose);
    });
    // Reorder errors to put the most relevant ones first.
    let reactServerComponentsError = -1;
    for(let i = 0; i < formattedErrors.length; i++){
        const error = formattedErrors[i];
        if (error.includes('ReactServerComponentsError')) {
            reactServerComponentsError = i;
            break;
        }
    }
    // Move the reactServerComponentsError to the top if it exists
    if (reactServerComponentsError !== -1) {
        const error = formattedErrors.splice(reactServerComponentsError, 1);
        formattedErrors.unshift(error[0]);
    }
    const result = {
        ...json,
        errors: formattedErrors,
        warnings: formattedWarnings
    };
    if (!verbose && result.errors.some(isLikelyASyntaxError)) {
        // If there are any syntax errors, show just them.
        result.errors = result.errors.filter(isLikelyASyntaxError);
        result.warnings = [];
    }
    return result;
} //# sourceMappingURL=format-webpack-messages.js.map
}}),
"[project]/node_modules/next/dist/client/dev/hot-reloader/shared.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    REACT_REFRESH_FULL_RELOAD: null,
    REACT_REFRESH_FULL_RELOAD_FROM_ERROR: null,
    reportInvalidHmrMessage: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    REACT_REFRESH_FULL_RELOAD: function() {
        return REACT_REFRESH_FULL_RELOAD;
    },
    REACT_REFRESH_FULL_RELOAD_FROM_ERROR: function() {
        return REACT_REFRESH_FULL_RELOAD_FROM_ERROR;
    },
    reportInvalidHmrMessage: function() {
        return reportInvalidHmrMessage;
    }
});
const REACT_REFRESH_FULL_RELOAD = '[Fast Refresh] performing full reload\n\n' + "Fast Refresh will perform a full reload when you edit a file that's imported by modules outside of the React rendering tree.\n" + 'You might have a file which exports a React component but also exports a value that is imported by a non-React component file.\n' + 'Consider migrating the non-React component export to a separate file and importing it into both files.\n\n' + 'It is also possible the parent component of the component you edited is a class component, which disables Fast Refresh.\n' + 'Fast Refresh requires at least one parent function component in your React tree.';
const REACT_REFRESH_FULL_RELOAD_FROM_ERROR = '[Fast Refresh] performing full reload because your application had an unrecoverable error';
function reportInvalidHmrMessage(message, err) {
    console.warn('[HMR] Invalid message: ' + JSON.stringify(message) + '\n' + (err instanceof Error && (err == null ? void 0 : err.stack) || ''));
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=shared.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/is-plain-object.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    getObjectClassLabel: null,
    isPlainObject: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    getObjectClassLabel: function() {
        return getObjectClassLabel;
    },
    isPlainObject: function() {
        return isPlainObject;
    }
});
function getObjectClassLabel(value) {
    return Object.prototype.toString.call(value);
}
function isPlainObject(value) {
    if (getObjectClassLabel(value) !== '[object Object]') {
        return false;
    }
    const prototype = Object.getPrototypeOf(value);
    /**
   * this used to be previously:
   *
   * `return prototype === null || prototype === Object.prototype`
   *
   * but Edge Runtime expose Object from vm, being that kind of type-checking wrongly fail.
   *
   * It was changed to the current implementation since it's resilient to serialization.
   */ return prototype === null || prototype.hasOwnProperty('isPrototypeOf');
} //# sourceMappingURL=is-plain-object.js.map
}}),
"[project]/node_modules/next/dist/lib/is-error.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    default: null,
    getProperError: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    /**
 * Checks whether the given value is a NextError.
 * This can be used to print a more detailed error message with properties like `code` & `digest`.
 */ default: function() {
        return isError;
    },
    getProperError: function() {
        return getProperError;
    }
});
const _isplainobject = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/is-plain-object.js [app-ssr] (ecmascript)");
function isError(err) {
    return typeof err === 'object' && err !== null && 'name' in err && 'message' in err;
}
function safeStringify(obj) {
    const seen = new WeakSet();
    return JSON.stringify(obj, (_key, value)=>{
        // If value is an object and already seen, replace with "[Circular]"
        if (typeof value === 'object' && value !== null) {
            if (seen.has(value)) {
                return '[Circular]';
            }
            seen.add(value);
        }
        return value;
    });
}
function getProperError(err) {
    if (isError(err)) {
        return err;
    }
    if ("TURBOPACK compile-time truthy", 1) {
        // provide better error for case where `throw undefined`
        // is called in development
        if (typeof err === 'undefined') {
            return Object.defineProperty(new Error('An undefined error was thrown, ' + 'see here for more info: https://nextjs.org/docs/messages/threw-undefined'), "__NEXT_ERROR_CODE", {
                value: "E98",
                enumerable: false,
                configurable: true
            });
        }
        if (err === null) {
            return Object.defineProperty(new Error('A null error was thrown, ' + 'see here for more info: https://nextjs.org/docs/messages/threw-undefined'), "__NEXT_ERROR_CODE", {
                value: "E336",
                enumerable: false,
                configurable: true
            });
        }
    }
    return Object.defineProperty(new Error((0, _isplainobject.isPlainObject)(err) ? safeStringify(err) : err + ''), "__NEXT_ERROR_CODE", {
        value: "E394",
        enumerable: false,
        configurable: true
    });
} //# sourceMappingURL=is-error.js.map
}}),
"[project]/node_modules/next/dist/client/lib/console.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    formatConsoleArgs: null,
    parseConsoleArgs: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    formatConsoleArgs: function() {
        return formatConsoleArgs;
    },
    parseConsoleArgs: function() {
        return parseConsoleArgs;
    }
});
const _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-ssr] (ecmascript)");
const _iserror = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/lib/is-error.js [app-ssr] (ecmascript)"));
function formatObject(arg, depth) {
    switch(typeof arg){
        case 'object':
            if (arg === null) {
                return 'null';
            } else if (Array.isArray(arg)) {
                let result = '[';
                if (depth < 1) {
                    for(let i = 0; i < arg.length; i++){
                        if (result !== '[') {
                            result += ',';
                        }
                        if (Object.prototype.hasOwnProperty.call(arg, i)) {
                            result += formatObject(arg[i], depth + 1);
                        }
                    }
                } else {
                    result += arg.length > 0 ? '...' : '';
                }
                result += ']';
                return result;
            } else if (arg instanceof Error) {
                return arg + '';
            } else {
                const keys = Object.keys(arg);
                let result = '{';
                if (depth < 1) {
                    for(let i = 0; i < keys.length; i++){
                        const key = keys[i];
                        const desc = Object.getOwnPropertyDescriptor(arg, 'key');
                        if (desc && !desc.get && !desc.set) {
                            const jsonKey = JSON.stringify(key);
                            if (jsonKey !== '"' + key + '"') {
                                result += jsonKey + ': ';
                            } else {
                                result += key + ': ';
                            }
                            result += formatObject(desc.value, depth + 1);
                        }
                    }
                } else {
                    result += keys.length > 0 ? '...' : '';
                }
                result += '}';
                return result;
            }
        case 'string':
            return JSON.stringify(arg);
        default:
            return String(arg);
    }
}
function formatConsoleArgs(args) {
    let message;
    let idx;
    if (typeof args[0] === 'string') {
        message = args[0];
        idx = 1;
    } else {
        message = '';
        idx = 0;
    }
    let result = '';
    let startQuote = false;
    for(let i = 0; i < message.length; ++i){
        const char = message[i];
        if (char !== '%' || i === message.length - 1 || idx >= args.length) {
            result += char;
            continue;
        }
        const code = message[++i];
        switch(code){
            case 'c':
                {
                    // TODO: We should colorize with HTML instead of turning into a string.
                    // Ignore for now.
                    result = startQuote ? "" + result + "]" : "[" + result;
                    startQuote = !startQuote;
                    idx++;
                    break;
                }
            case 'O':
            case 'o':
                {
                    result += formatObject(args[idx++], 0);
                    break;
                }
            case 'd':
            case 'i':
                {
                    result += parseInt(args[idx++], 10);
                    break;
                }
            case 'f':
                {
                    result += parseFloat(args[idx++]);
                    break;
                }
            case 's':
                {
                    result += String(args[idx++]);
                    break;
                }
            default:
                result += '%' + code;
        }
    }
    for(; idx < args.length; idx++){
        result += (idx > 0 ? ' ' : '') + formatObject(args[idx], 0);
    }
    return result;
}
function parseConsoleArgs(args) {
    // See
    // https://github.com/facebook/react/blob/65a56d0e99261481c721334a3ec4561d173594cd/packages/react-devtools-shared/src/backend/flight/renderer.js#L88-L93
    //
    // Logs replayed from the server look like this:
    // [
    //   "%c%s%c %o\n\n%s\n\n%s\n",
    //   "background: #e6e6e6; ...",
    //   " Server ", // can also be e.g. " Prerender "
    //   "",
    //   Error,
    //   "The above error occurred in the <Page> component.",
    //   ...
    // ]
    if (args.length > 3 && typeof args[0] === 'string' && args[0].startsWith('%c%s%c ') && typeof args[1] === 'string' && typeof args[2] === 'string' && typeof args[3] === 'string') {
        const environmentName = args[2];
        const maybeError = args[4];
        return {
            environmentName: environmentName.trim(),
            error: (0, _iserror.default)(maybeError) ? maybeError : null
        };
    }
    return {
        environmentName: null,
        error: null
    };
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=console.js.map
}}),
"[project]/node_modules/next/dist/next-devtools/shared/console-error.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
// To distinguish from React error.digest, we use a different symbol here to determine if the error is from console.error or unhandled promise rejection.
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    createConsoleError: null,
    isConsoleError: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    createConsoleError: function() {
        return createConsoleError;
    },
    isConsoleError: function() {
        return isConsoleError;
    }
});
const digestSym = Symbol.for('next.console.error.digest');
function createConsoleError(message, environmentName) {
    const error = typeof message === 'string' ? Object.defineProperty(new Error(message), "__NEXT_ERROR_CODE", {
        value: "E394",
        enumerable: false,
        configurable: true
    }) : message;
    error[digestSym] = 'NEXT_CONSOLE_ERROR';
    if (environmentName && !error.environmentName) {
        error.environmentName = environmentName;
    }
    return error;
}
const isConsoleError = (error)=>{
    return error && error[digestSym] === 'NEXT_CONSOLE_ERROR';
};
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=console-error.js.map
}}),
"[project]/node_modules/next/dist/next-devtools/userspace/app/errors/stitched-error.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    coerceError: null,
    decorateDevError: null,
    getComponentStack: null,
    getOwnerStack: null,
    setComponentStack: null,
    setOwnerStack: null,
    setOwnerStackIfAvailable: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    coerceError: function() {
        return coerceError;
    },
    decorateDevError: function() {
        return decorateDevError;
    },
    getComponentStack: function() {
        return getComponentStack;
    },
    getOwnerStack: function() {
        return getOwnerStack;
    },
    setComponentStack: function() {
        return setComponentStack;
    },
    setOwnerStack: function() {
        return setOwnerStack;
    },
    setOwnerStackIfAvailable: function() {
        return setOwnerStackIfAvailable;
    }
});
const _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-ssr] (ecmascript)");
const _react = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)"));
const _iserror = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/lib/is-error.js [app-ssr] (ecmascript)"));
const ownerStacks = new WeakMap();
const componentStacks = new WeakMap();
function getComponentStack(error) {
    return componentStacks.get(error);
}
function setComponentStack(error, stack) {
    componentStacks.set(error, stack);
}
function getOwnerStack(error) {
    return ownerStacks.get(error);
}
function setOwnerStack(error, stack) {
    ownerStacks.set(error, stack);
}
function coerceError(value) {
    return (0, _iserror.default)(value) ? value : Object.defineProperty(new Error('' + value), "__NEXT_ERROR_CODE", {
        value: "E394",
        enumerable: false,
        configurable: true
    });
}
function setOwnerStackIfAvailable(error) {
    // React 18 and prod does not have `captureOwnerStack`
    if ('captureOwnerStack' in _react.default) {
        setOwnerStack(error, _react.default.captureOwnerStack());
    }
}
function decorateDevError(thrownValue, errorInfo) {
    const error = coerceError(thrownValue);
    setOwnerStackIfAvailable(error);
    // TODO: change to passing down errorInfo later
    // In development mode, pass along the component stack to the error
    if (errorInfo.componentStack) {
        setComponentStack(error, errorInfo.componentStack);
    }
    return error;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=stitched-error.js.map
}}),
"[project]/node_modules/next/dist/compiled/safe-stable-stringify/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
(function() {
    "use strict";
    var e = {
        879: function(e, t) {
            const { hasOwnProperty: n } = Object.prototype;
            const r = configure();
            r.configure = configure;
            r.stringify = r;
            r.default = r;
            t.stringify = r;
            t.configure = configure;
            e.exports = r;
            const i = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/;
            function strEscape(e) {
                if (e.length < 5e3 && !i.test(e)) {
                    return `"${e}"`;
                }
                return JSON.stringify(e);
            }
            function sort(e, t) {
                if (e.length > 200 || t) {
                    return e.sort(t);
                }
                for(let t = 1; t < e.length; t++){
                    const n = e[t];
                    let r = t;
                    while(r !== 0 && e[r - 1] > n){
                        e[r] = e[r - 1];
                        r--;
                    }
                    e[r] = n;
                }
                return e;
            }
            const f = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Object.getPrototypeOf(new Int8Array)), Symbol.toStringTag).get;
            function isTypedArrayWithEntries(e) {
                return f.call(e) !== undefined && e.length !== 0;
            }
            function stringifyTypedArray(e, t, n) {
                if (e.length < n) {
                    n = e.length;
                }
                const r = t === "," ? "" : " ";
                let i = `"0":${r}${e[0]}`;
                for(let f = 1; f < n; f++){
                    i += `${t}"${f}":${r}${e[f]}`;
                }
                return i;
            }
            function getCircularValueOption(e) {
                if (n.call(e, "circularValue")) {
                    const t = e.circularValue;
                    if (typeof t === "string") {
                        return `"${t}"`;
                    }
                    if (t == null) {
                        return t;
                    }
                    if (t === Error || t === TypeError) {
                        return {
                            toString () {
                                throw new TypeError("Converting circular structure to JSON");
                            }
                        };
                    }
                    throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined');
                }
                return '"[Circular]"';
            }
            function getDeterministicOption(e) {
                let t;
                if (n.call(e, "deterministic")) {
                    t = e.deterministic;
                    if (typeof t !== "boolean" && typeof t !== "function") {
                        throw new TypeError('The "deterministic" argument must be of type boolean or comparator function');
                    }
                }
                return t === undefined ? true : t;
            }
            function getBooleanOption(e, t) {
                let r;
                if (n.call(e, t)) {
                    r = e[t];
                    if (typeof r !== "boolean") {
                        throw new TypeError(`The "${t}" argument must be of type boolean`);
                    }
                }
                return r === undefined ? true : r;
            }
            function getPositiveIntegerOption(e, t) {
                let r;
                if (n.call(e, t)) {
                    r = e[t];
                    if (typeof r !== "number") {
                        throw new TypeError(`The "${t}" argument must be of type number`);
                    }
                    if (!Number.isInteger(r)) {
                        throw new TypeError(`The "${t}" argument must be an integer`);
                    }
                    if (r < 1) {
                        throw new RangeError(`The "${t}" argument must be >= 1`);
                    }
                }
                return r === undefined ? Infinity : r;
            }
            function getItemCount(e) {
                if (e === 1) {
                    return "1 item";
                }
                return `${e} items`;
            }
            function getUniqueReplacerSet(e) {
                const t = new Set;
                for (const n of e){
                    if (typeof n === "string" || typeof n === "number") {
                        t.add(String(n));
                    }
                }
                return t;
            }
            function getStrictOption(e) {
                if (n.call(e, "strict")) {
                    const t = e.strict;
                    if (typeof t !== "boolean") {
                        throw new TypeError('The "strict" argument must be of type boolean');
                    }
                    if (t) {
                        return (e)=>{
                            let t = `Object can not safely be stringified. Received type ${typeof e}`;
                            if (typeof e !== "function") t += ` (${e.toString()})`;
                            throw new Error(t);
                        };
                    }
                }
            }
            function configure(e) {
                e = {
                    ...e
                };
                const t = getStrictOption(e);
                if (t) {
                    if (e.bigint === undefined) {
                        e.bigint = false;
                    }
                    if (!("circularValue" in e)) {
                        e.circularValue = Error;
                    }
                }
                const n = getCircularValueOption(e);
                const r = getBooleanOption(e, "bigint");
                const i = getDeterministicOption(e);
                const f = typeof i === "function" ? i : undefined;
                const u = getPositiveIntegerOption(e, "maximumDepth");
                const o = getPositiveIntegerOption(e, "maximumBreadth");
                function stringifyFnReplacer(e, s, l, c, a, g) {
                    let p = s[e];
                    if (typeof p === "object" && p !== null && typeof p.toJSON === "function") {
                        p = p.toJSON(e);
                    }
                    p = c.call(s, e, p);
                    switch(typeof p){
                        case "string":
                            return strEscape(p);
                        case "object":
                            {
                                if (p === null) {
                                    return "null";
                                }
                                if (l.indexOf(p) !== -1) {
                                    return n;
                                }
                                let e = "";
                                let t = ",";
                                const r = g;
                                if (Array.isArray(p)) {
                                    if (p.length === 0) {
                                        return "[]";
                                    }
                                    if (u < l.length + 1) {
                                        return '"[Array]"';
                                    }
                                    l.push(p);
                                    if (a !== "") {
                                        g += a;
                                        e += `\n${g}`;
                                        t = `,\n${g}`;
                                    }
                                    const n = Math.min(p.length, o);
                                    let i = 0;
                                    for(; i < n - 1; i++){
                                        const n = stringifyFnReplacer(String(i), p, l, c, a, g);
                                        e += n !== undefined ? n : "null";
                                        e += t;
                                    }
                                    const f = stringifyFnReplacer(String(i), p, l, c, a, g);
                                    e += f !== undefined ? f : "null";
                                    if (p.length - 1 > o) {
                                        const n = p.length - o - 1;
                                        e += `${t}"... ${getItemCount(n)} not stringified"`;
                                    }
                                    if (a !== "") {
                                        e += `\n${r}`;
                                    }
                                    l.pop();
                                    return `[${e}]`;
                                }
                                let s = Object.keys(p);
                                const y = s.length;
                                if (y === 0) {
                                    return "{}";
                                }
                                if (u < l.length + 1) {
                                    return '"[Object]"';
                                }
                                let d = "";
                                let h = "";
                                if (a !== "") {
                                    g += a;
                                    t = `,\n${g}`;
                                    d = " ";
                                }
                                const $ = Math.min(y, o);
                                if (i && !isTypedArrayWithEntries(p)) {
                                    s = sort(s, f);
                                }
                                l.push(p);
                                for(let n = 0; n < $; n++){
                                    const r = s[n];
                                    const i = stringifyFnReplacer(r, p, l, c, a, g);
                                    if (i !== undefined) {
                                        e += `${h}${strEscape(r)}:${d}${i}`;
                                        h = t;
                                    }
                                }
                                if (y > o) {
                                    const n = y - o;
                                    e += `${h}"...":${d}"${getItemCount(n)} not stringified"`;
                                    h = t;
                                }
                                if (a !== "" && h.length > 1) {
                                    e = `\n${g}${e}\n${r}`;
                                }
                                l.pop();
                                return `{${e}}`;
                            }
                        case "number":
                            return isFinite(p) ? String(p) : t ? t(p) : "null";
                        case "boolean":
                            return p === true ? "true" : "false";
                        case "undefined":
                            return undefined;
                        case "bigint":
                            if (r) {
                                return String(p);
                            }
                        default:
                            return t ? t(p) : undefined;
                    }
                }
                function stringifyArrayReplacer(e, i, f, s, l, c) {
                    if (typeof i === "object" && i !== null && typeof i.toJSON === "function") {
                        i = i.toJSON(e);
                    }
                    switch(typeof i){
                        case "string":
                            return strEscape(i);
                        case "object":
                            {
                                if (i === null) {
                                    return "null";
                                }
                                if (f.indexOf(i) !== -1) {
                                    return n;
                                }
                                const e = c;
                                let t = "";
                                let r = ",";
                                if (Array.isArray(i)) {
                                    if (i.length === 0) {
                                        return "[]";
                                    }
                                    if (u < f.length + 1) {
                                        return '"[Array]"';
                                    }
                                    f.push(i);
                                    if (l !== "") {
                                        c += l;
                                        t += `\n${c}`;
                                        r = `,\n${c}`;
                                    }
                                    const n = Math.min(i.length, o);
                                    let a = 0;
                                    for(; a < n - 1; a++){
                                        const e = stringifyArrayReplacer(String(a), i[a], f, s, l, c);
                                        t += e !== undefined ? e : "null";
                                        t += r;
                                    }
                                    const g = stringifyArrayReplacer(String(a), i[a], f, s, l, c);
                                    t += g !== undefined ? g : "null";
                                    if (i.length - 1 > o) {
                                        const e = i.length - o - 1;
                                        t += `${r}"... ${getItemCount(e)} not stringified"`;
                                    }
                                    if (l !== "") {
                                        t += `\n${e}`;
                                    }
                                    f.pop();
                                    return `[${t}]`;
                                }
                                f.push(i);
                                let a = "";
                                if (l !== "") {
                                    c += l;
                                    r = `,\n${c}`;
                                    a = " ";
                                }
                                let g = "";
                                for (const e of s){
                                    const n = stringifyArrayReplacer(e, i[e], f, s, l, c);
                                    if (n !== undefined) {
                                        t += `${g}${strEscape(e)}:${a}${n}`;
                                        g = r;
                                    }
                                }
                                if (l !== "" && g.length > 1) {
                                    t = `\n${c}${t}\n${e}`;
                                }
                                f.pop();
                                return `{${t}}`;
                            }
                        case "number":
                            return isFinite(i) ? String(i) : t ? t(i) : "null";
                        case "boolean":
                            return i === true ? "true" : "false";
                        case "undefined":
                            return undefined;
                        case "bigint":
                            if (r) {
                                return String(i);
                            }
                        default:
                            return t ? t(i) : undefined;
                    }
                }
                function stringifyIndent(e, s, l, c, a) {
                    switch(typeof s){
                        case "string":
                            return strEscape(s);
                        case "object":
                            {
                                if (s === null) {
                                    return "null";
                                }
                                if (typeof s.toJSON === "function") {
                                    s = s.toJSON(e);
                                    if (typeof s !== "object") {
                                        return stringifyIndent(e, s, l, c, a);
                                    }
                                    if (s === null) {
                                        return "null";
                                    }
                                }
                                if (l.indexOf(s) !== -1) {
                                    return n;
                                }
                                const t = a;
                                if (Array.isArray(s)) {
                                    if (s.length === 0) {
                                        return "[]";
                                    }
                                    if (u < l.length + 1) {
                                        return '"[Array]"';
                                    }
                                    l.push(s);
                                    a += c;
                                    let e = `\n${a}`;
                                    const n = `,\n${a}`;
                                    const r = Math.min(s.length, o);
                                    let i = 0;
                                    for(; i < r - 1; i++){
                                        const t = stringifyIndent(String(i), s[i], l, c, a);
                                        e += t !== undefined ? t : "null";
                                        e += n;
                                    }
                                    const f = stringifyIndent(String(i), s[i], l, c, a);
                                    e += f !== undefined ? f : "null";
                                    if (s.length - 1 > o) {
                                        const t = s.length - o - 1;
                                        e += `${n}"... ${getItemCount(t)} not stringified"`;
                                    }
                                    e += `\n${t}`;
                                    l.pop();
                                    return `[${e}]`;
                                }
                                let r = Object.keys(s);
                                const g = r.length;
                                if (g === 0) {
                                    return "{}";
                                }
                                if (u < l.length + 1) {
                                    return '"[Object]"';
                                }
                                a += c;
                                const p = `,\n${a}`;
                                let y = "";
                                let d = "";
                                let h = Math.min(g, o);
                                if (isTypedArrayWithEntries(s)) {
                                    y += stringifyTypedArray(s, p, o);
                                    r = r.slice(s.length);
                                    h -= s.length;
                                    d = p;
                                }
                                if (i) {
                                    r = sort(r, f);
                                }
                                l.push(s);
                                for(let e = 0; e < h; e++){
                                    const t = r[e];
                                    const n = stringifyIndent(t, s[t], l, c, a);
                                    if (n !== undefined) {
                                        y += `${d}${strEscape(t)}: ${n}`;
                                        d = p;
                                    }
                                }
                                if (g > o) {
                                    const e = g - o;
                                    y += `${d}"...": "${getItemCount(e)} not stringified"`;
                                    d = p;
                                }
                                if (d !== "") {
                                    y = `\n${a}${y}\n${t}`;
                                }
                                l.pop();
                                return `{${y}}`;
                            }
                        case "number":
                            return isFinite(s) ? String(s) : t ? t(s) : "null";
                        case "boolean":
                            return s === true ? "true" : "false";
                        case "undefined":
                            return undefined;
                        case "bigint":
                            if (r) {
                                return String(s);
                            }
                        default:
                            return t ? t(s) : undefined;
                    }
                }
                function stringifySimple(e, s, l) {
                    switch(typeof s){
                        case "string":
                            return strEscape(s);
                        case "object":
                            {
                                if (s === null) {
                                    return "null";
                                }
                                if (typeof s.toJSON === "function") {
                                    s = s.toJSON(e);
                                    if (typeof s !== "object") {
                                        return stringifySimple(e, s, l);
                                    }
                                    if (s === null) {
                                        return "null";
                                    }
                                }
                                if (l.indexOf(s) !== -1) {
                                    return n;
                                }
                                let t = "";
                                const r = s.length !== undefined;
                                if (r && Array.isArray(s)) {
                                    if (s.length === 0) {
                                        return "[]";
                                    }
                                    if (u < l.length + 1) {
                                        return '"[Array]"';
                                    }
                                    l.push(s);
                                    const e = Math.min(s.length, o);
                                    let n = 0;
                                    for(; n < e - 1; n++){
                                        const e = stringifySimple(String(n), s[n], l);
                                        t += e !== undefined ? e : "null";
                                        t += ",";
                                    }
                                    const r = stringifySimple(String(n), s[n], l);
                                    t += r !== undefined ? r : "null";
                                    if (s.length - 1 > o) {
                                        const e = s.length - o - 1;
                                        t += `,"... ${getItemCount(e)} not stringified"`;
                                    }
                                    l.pop();
                                    return `[${t}]`;
                                }
                                let c = Object.keys(s);
                                const a = c.length;
                                if (a === 0) {
                                    return "{}";
                                }
                                if (u < l.length + 1) {
                                    return '"[Object]"';
                                }
                                let g = "";
                                let p = Math.min(a, o);
                                if (r && isTypedArrayWithEntries(s)) {
                                    t += stringifyTypedArray(s, ",", o);
                                    c = c.slice(s.length);
                                    p -= s.length;
                                    g = ",";
                                }
                                if (i) {
                                    c = sort(c, f);
                                }
                                l.push(s);
                                for(let e = 0; e < p; e++){
                                    const n = c[e];
                                    const r = stringifySimple(n, s[n], l);
                                    if (r !== undefined) {
                                        t += `${g}${strEscape(n)}:${r}`;
                                        g = ",";
                                    }
                                }
                                if (a > o) {
                                    const e = a - o;
                                    t += `${g}"...":"${getItemCount(e)} not stringified"`;
                                }
                                l.pop();
                                return `{${t}}`;
                            }
                        case "number":
                            return isFinite(s) ? String(s) : t ? t(s) : "null";
                        case "boolean":
                            return s === true ? "true" : "false";
                        case "undefined":
                            return undefined;
                        case "bigint":
                            if (r) {
                                return String(s);
                            }
                        default:
                            return t ? t(s) : undefined;
                    }
                }
                function stringify(e, t, n) {
                    if (arguments.length > 1) {
                        let r = "";
                        if (typeof n === "number") {
                            r = " ".repeat(Math.min(n, 10));
                        } else if (typeof n === "string") {
                            r = n.slice(0, 10);
                        }
                        if (t != null) {
                            if (typeof t === "function") {
                                return stringifyFnReplacer("", {
                                    "": e
                                }, [], t, r, "");
                            }
                            if (Array.isArray(t)) {
                                return stringifyArrayReplacer("", e, [], getUniqueReplacerSet(t), r, "");
                            }
                        }
                        if (r.length !== 0) {
                            return stringifyIndent("", e, [], r, "");
                        }
                    }
                    return stringifySimple("", e, []);
                }
                return stringify;
            }
        }
    };
    var t = {};
    function __nccwpck_require__(n) {
        var r = t[n];
        if (r !== undefined) {
            return r.exports;
        }
        var i = t[n] = {
            exports: {}
        };
        var f = true;
        try {
            e[n](i, i.exports, __nccwpck_require__);
            f = false;
        } finally{
            if (f) delete t[n];
        }
        return i.exports;
    }
    if (typeof __nccwpck_require__ !== "undefined") __nccwpck_require__.ab = ("TURBOPACK compile-time value", "/ROOT/node_modules/next/dist/compiled/safe-stable-stringify") + "/";
    var n = __nccwpck_require__(879);
    module.exports = n;
})();
}}),
"[project]/node_modules/next/dist/shared/lib/error-source.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    decorateServerError: null,
    getErrorSource: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    decorateServerError: function() {
        return decorateServerError;
    },
    getErrorSource: function() {
        return getErrorSource;
    }
});
const symbolError = Symbol.for('NextjsError');
function getErrorSource(error) {
    return error[symbolError] || null;
}
function decorateServerError(error, type) {
    Object.defineProperty(error, symbolError, {
        writable: false,
        enumerable: false,
        configurable: false,
        value: type
    });
} //# sourceMappingURL=error-source.js.map
}}),
"[project]/node_modules/next/dist/next-devtools/userspace/app/terminal-logging-config.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    getIsTerminalLoggingEnabled: null,
    getTerminalLoggingConfig: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    getIsTerminalLoggingEnabled: function() {
        return getIsTerminalLoggingEnabled;
    },
    getTerminalLoggingConfig: function() {
        return getTerminalLoggingConfig;
    }
});
function getTerminalLoggingConfig() {
    try {
        return JSON.parse(("TURBOPACK compile-time value", "false") || 'false');
    } catch (e) {
        return false;
    }
}
function getIsTerminalLoggingEnabled() {
    const config = getTerminalLoggingConfig();
    return Boolean(config);
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=terminal-logging-config.js.map
}}),
"[project]/node_modules/next/dist/next-devtools/shared/forward-logs-shared.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    UNDEFINED_MARKER: null,
    patchConsoleMethod: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    UNDEFINED_MARKER: function() {
        return UNDEFINED_MARKER;
    },
    patchConsoleMethod: function() {
        return patchConsoleMethod;
    }
});
const UNDEFINED_MARKER = '__next_tagged_undefined';
function patchConsoleMethod(methodName, wrapper) {
    const descriptor = Object.getOwnPropertyDescriptor(console, methodName);
    if (descriptor && (descriptor.configurable || descriptor.writable) && typeof descriptor.value === 'function') {
        const originalMethod = descriptor.value;
        const originalName = Object.getOwnPropertyDescriptor(originalMethod, 'name');
        const wrapperMethod = function() {
            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                args[_key] = arguments[_key];
            }
            wrapper(methodName, ...args);
            originalMethod.apply(this, args);
        };
        if (originalName) {
            Object.defineProperty(wrapperMethod, 'name', originalName);
        }
        Object.defineProperty(console, methodName, {
            value: wrapperMethod
        });
        return ()=>{
            Object.defineProperty(console, methodName, {
                value: originalMethod,
                writable: descriptor.writable,
                configurable: descriptor.configurable
            });
        };
    }
    return ()=>{};
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=forward-logs-shared.js.map
}}),
"[project]/node_modules/next/dist/next-devtools/userspace/app/forward-logs.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    PROMISE_MARKER: null,
    UNAVAILABLE_MARKER: null,
    forwardErrorLog: null,
    forwardUnhandledError: null,
    initializeDebugLogForwarding: null,
    isTerminalLoggingEnabled: null,
    logQueue: null,
    logStringify: null,
    logUnhandledRejection: null,
    preLogSerializationClone: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    PROMISE_MARKER: function() {
        return PROMISE_MARKER;
    },
    UNAVAILABLE_MARKER: function() {
        return UNAVAILABLE_MARKER;
    },
    forwardErrorLog: function() {
        return forwardErrorLog;
    },
    forwardUnhandledError: function() {
        return forwardUnhandledError;
    },
    initializeDebugLogForwarding: function() {
        return initializeDebugLogForwarding;
    },
    isTerminalLoggingEnabled: function() {
        return isTerminalLoggingEnabled;
    },
    logQueue: function() {
        return logQueue;
    },
    logStringify: function() {
        return logStringify;
    },
    logUnhandledRejection: function() {
        return logUnhandledRejection;
    },
    preLogSerializationClone: function() {
        return preLogSerializationClone;
    }
});
const _safestablestringify = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/safe-stable-stringify/index.js [app-ssr] (ecmascript)");
const _stitchederror = __turbopack_context__.r("[project]/node_modules/next/dist/next-devtools/userspace/app/errors/stitched-error.js [app-ssr] (ecmascript)");
const _errorsource = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/error-source.js [app-ssr] (ecmascript)");
const _terminalloggingconfig = __turbopack_context__.r("[project]/node_modules/next/dist/next-devtools/userspace/app/terminal-logging-config.js [app-ssr] (ecmascript)");
const _forwardlogsshared = __turbopack_context__.r("[project]/node_modules/next/dist/next-devtools/shared/forward-logs-shared.js [app-ssr] (ecmascript)");
const terminalLoggingConfig = (0, _terminalloggingconfig.getTerminalLoggingConfig)();
const PROMISE_MARKER = 'Promise {}';
const UNAVAILABLE_MARKER = '[Unable to view]';
const maximumDepth = typeof terminalLoggingConfig === 'object' && terminalLoggingConfig.depthLimit ? terminalLoggingConfig.depthLimit : 5;
const maximumBreadth = typeof terminalLoggingConfig === 'object' && terminalLoggingConfig.edgeLimit ? terminalLoggingConfig.edgeLimit : 100;
const stringify = (0, _safestablestringify.configure)({
    maximumDepth,
    maximumBreadth
});
const isTerminalLoggingEnabled = (0, _terminalloggingconfig.getIsTerminalLoggingEnabled)();
const methods = [
    'log',
    'info',
    'warn',
    'debug',
    'table',
    'assert',
    'dir',
    'dirxml',
    'group',
    'groupCollapsed',
    'groupEnd',
    'trace'
];
function preLogSerializationClone(value, seen) {
    if (seen === void 0) seen = new WeakMap();
    if (value === undefined) return _forwardlogsshared.UNDEFINED_MARKER;
    if (value === null || typeof value !== 'object') return value;
    if (seen.has(value)) return seen.get(value);
    try {
        Object.keys(value);
    } catch (e) {
        return UNAVAILABLE_MARKER;
    }
    try {
        if (typeof value.then === 'function') return PROMISE_MARKER;
    } catch (e) {
        return UNAVAILABLE_MARKER;
    }
    if (Array.isArray(value)) {
        const out = [];
        seen.set(value, out);
        for (const item of value){
            try {
                out.push(preLogSerializationClone(item, seen));
            } catch (e) {
                out.push(UNAVAILABLE_MARKER);
            }
        }
        return out;
    }
    const proto = Object.getPrototypeOf(value);
    if (proto === Object.prototype || proto === null) {
        const out = {};
        seen.set(value, out);
        for (const key of Object.keys(value)){
            try {
                out[key] = preLogSerializationClone(value[key], seen);
            } catch (e) {
                out[key] = UNAVAILABLE_MARKER;
            }
        }
        return out;
    }
    return Object.prototype.toString.call(value);
}
const logStringify = (data)=>{
    try {
        const result = stringify(data);
        return result != null ? result : '"' + UNAVAILABLE_MARKER + '"';
    } catch (e) {
        return '"' + UNAVAILABLE_MARKER + '"';
    }
};
const afterThisFrame = (cb)=>{
    let timeout;
    const rafId = requestAnimationFrame(()=>{
        timeout = setTimeout(()=>{
            cb();
        });
    });
    return ()=>{
        cancelAnimationFrame(rafId);
        clearTimeout(timeout);
    };
};
let isPatched = false;
const serializeEntries = (entries)=>entries.map((clientEntry)=>{
        switch(clientEntry.kind){
            case 'any-logged-error':
            case 'console':
                {
                    return {
                        ...clientEntry,
                        args: clientEntry.args.map(stringifyUserArg)
                    };
                }
            case 'formatted-error':
                {
                    return clientEntry;
                }
            default:
                {
                    return null;
                }
        }
    });
const logQueue = {
    entries: [],
    flushScheduled: false,
    cancelFlush: null,
    socket: null,
    sourceType: undefined,
    router: null,
    scheduleLogSend: (entry)=>{
        logQueue.entries.push(entry);
        if (logQueue.flushScheduled) {
            return;
        }
        // safe to deref and use in setTimeout closure since we cancel on new socket
        const socket = logQueue.socket;
        if (!socket) {
            return;
        }
        // we probably dont need this
        logQueue.flushScheduled = true;
        // non blocking log flush, runs at most once per frame
        logQueue.cancelFlush = afterThisFrame(()=>{
            logQueue.flushScheduled = false;
            // just incase
            try {
                const payload = JSON.stringify({
                    event: 'browser-logs',
                    entries: serializeEntries(logQueue.entries),
                    router: logQueue.router,
                    // needed for source mapping, we just assign the sourceType from the last error for the whole batch
                    sourceType: logQueue.sourceType
                });
                socket.send(payload);
                logQueue.entries = [];
                logQueue.sourceType = undefined;
            } catch (e) {
            // error (make sure u don't infinite loop)
            /* noop */ }
        });
    },
    onSocketReady: (socket)=>{
        if (socket.readyState !== WebSocket.OPEN) {
            // invariant
            return;
        }
        // incase an existing timeout was going to run with a stale socket
        logQueue.cancelFlush == null ? void 0 : logQueue.cancelFlush.call(logQueue);
        logQueue.socket = socket;
        try {
            const payload = JSON.stringify({
                event: 'browser-logs',
                entries: serializeEntries(logQueue.entries),
                router: logQueue.router,
                sourceType: logQueue.sourceType
            });
            socket.send(payload);
            logQueue.entries = [];
            logQueue.sourceType = undefined;
        } catch (e) {
        /** noop just incase */ }
    }
};
const stringifyUserArg = (arg)=>{
    if (arg.kind !== 'arg') {
        return arg;
    }
    return {
        ...arg,
        data: logStringify(arg.data)
    };
};
const createErrorArg = (error)=>{
    const stack = stackWithOwners(error);
    return {
        kind: 'formatted-error-arg',
        prefix: error.message ? error.name + ": " + error.message : "" + error.name,
        stack
    };
};
const createLogEntry = (level, args)=>{
    // do not abstract this, it implicitly relies on which functions call it. forcing the inlined implementation makes you think about callers
    // error capture stack trace maybe
    const stack = stackWithOwners(new Error());
    const stackLines = stack == null ? void 0 : stack.split('\n');
    const cleanStack = stackLines == null ? void 0 : stackLines.slice(3).join('\n') // this is probably ignored anyways
    ;
    const entry = {
        kind: 'console',
        consoleMethodStack: cleanStack != null ? cleanStack : null,
        method: level,
        args: args.map((arg)=>{
            if (arg instanceof Error) {
                return createErrorArg(arg);
            }
            return {
                kind: 'arg',
                data: preLogSerializationClone(arg)
            };
        })
    };
    logQueue.scheduleLogSend(entry);
};
const forwardErrorLog = (args)=>{
    const errorObjects = args.filter((arg)=>arg instanceof Error);
    const first = errorObjects.at(0);
    if (first) {
        const source = (0, _errorsource.getErrorSource)(first);
        if (source) {
            logQueue.sourceType = source;
        }
    }
    /**
   * browser shows stack regardless of type of data passed to console.error, so we should do the same
   *
   * do not abstract this, it implicitly relies on which functions call it. forcing the inlined implementation makes you think about callers
   */ const stack = stackWithOwners(new Error());
    const stackLines = stack == null ? void 0 : stack.split('\n');
    const cleanStack = stackLines == null ? void 0 : stackLines.slice(3).join('\n');
    const entry = {
        kind: 'any-logged-error',
        method: 'error',
        consoleErrorStack: cleanStack != null ? cleanStack : '',
        args: args.map((arg)=>{
            if (arg instanceof Error) {
                return createErrorArg(arg);
            }
            return {
                kind: 'arg',
                data: preLogSerializationClone(arg)
            };
        })
    };
    logQueue.scheduleLogSend(entry);
};
const createUncaughtErrorEntry = (errorName, errorMessage, fullStack)=>{
    const entry = {
        kind: 'formatted-error',
        prefix: "Uncaught " + errorName + ": " + errorMessage,
        stack: fullStack,
        method: 'error'
    };
    logQueue.scheduleLogSend(entry);
};
const stackWithOwners = (error)=>{
    let ownerStack = '';
    (0, _stitchederror.setOwnerStackIfAvailable)(error);
    ownerStack = (0, _stitchederror.getOwnerStack)(error) || '';
    const stack = (error.stack || '') + ownerStack;
    return stack;
};
function logUnhandledRejection(reason) {
    if (reason instanceof Error) {
        createUnhandledRejectionErrorEntry(reason, stackWithOwners(reason));
        return;
    }
    createUnhandledRejectionNonErrorEntry(reason);
}
const createUnhandledRejectionErrorEntry = (error, fullStack)=>{
    const source = (0, _errorsource.getErrorSource)(error);
    if (source) {
        logQueue.sourceType = source;
    }
    const entry = {
        kind: 'formatted-error',
        prefix: " unhandledRejection: " + error.name + ": " + error.message,
        stack: fullStack,
        method: 'error'
    };
    logQueue.scheduleLogSend(entry);
};
const createUnhandledRejectionNonErrorEntry = (reason)=>{
    const entry = {
        kind: 'any-logged-error',
        // we can't access the stack since the event is dispatched async and creating an inline error would be meaningless
        consoleErrorStack: '',
        method: 'error',
        args: [
            {
                kind: 'arg',
                data: " unhandledRejection:",
                isRejectionMessage: true
            },
            {
                kind: 'arg',
                data: preLogSerializationClone(reason)
            }
        ]
    };
    logQueue.scheduleLogSend(entry);
};
const isHMR = (args)=>{
    const firstArg = args[0];
    if (typeof firstArg !== 'string') {
        return false;
    }
    if (firstArg.startsWith('[Fast Refresh]')) {
        return true;
    }
    if (firstArg.startsWith('[HMR]')) {
        return true;
    }
    return false;
};
const isIgnoredLog = (args)=>{
    if (args.length < 3) {
        return false;
    }
    const [format, styles, label] = args;
    if (typeof format !== 'string' || typeof styles !== 'string' || typeof label !== 'string') {
        return false;
    }
    // kinda hacky, we should define a common format for these strings so we can safely ignore
    return format.startsWith('%c%s%c') && styles.includes('background:');
};
function forwardUnhandledError(error) {
    createUncaughtErrorEntry(error.name, error.message, stackWithOwners(error));
}
const initializeDebugLogForwarding = (router)=>{
    // probably don't need this
    if (isPatched) {
        return;
    }
    // TODO(rob): why does this break rendering on server, important to know incase the same bug appears in browser
    if ("TURBOPACK compile-time truthy", 1) {
        return;
    }
    //TURBOPACK unreachable
    ;
};
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=forward-logs.js.map
}}),
"[project]/node_modules/next/dist/next-devtools/userspace/app/errors/use-error-handler.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    handleClientError: null,
    handleConsoleError: null,
    handleGlobalErrors: null,
    useErrorHandler: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    handleClientError: function() {
        return handleClientError;
    },
    handleConsoleError: function() {
        return handleConsoleError;
    },
    handleGlobalErrors: function() {
        return handleGlobalErrors;
    },
    useErrorHandler: function() {
        return useErrorHandler;
    }
});
const _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-ssr] (ecmascript)");
const _react = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
const _isnextroutererror = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/is-next-router-error.js [app-ssr] (ecmascript)");
const _console = __turbopack_context__.r("[project]/node_modules/next/dist/client/lib/console.js [app-ssr] (ecmascript)");
const _iserror = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/lib/is-error.js [app-ssr] (ecmascript)"));
const _consoleerror = __turbopack_context__.r("[project]/node_modules/next/dist/next-devtools/shared/console-error.js [app-ssr] (ecmascript)");
const _stitchederror = __turbopack_context__.r("[project]/node_modules/next/dist/next-devtools/userspace/app/errors/stitched-error.js [app-ssr] (ecmascript)");
const _forwardlogs = __turbopack_context__.r("[project]/node_modules/next/dist/next-devtools/userspace/app/forward-logs.js [app-ssr] (ecmascript)");
const queueMicroTask = globalThis.queueMicrotask || ((cb)=>Promise.resolve().then(cb));
const errorQueue = [];
const errorHandlers = [];
const rejectionQueue = [];
const rejectionHandlers = [];
function handleConsoleError(originError, consoleErrorArgs) {
    let error;
    const { environmentName } = (0, _console.parseConsoleArgs)(consoleErrorArgs);
    if ((0, _iserror.default)(originError)) {
        error = (0, _consoleerror.createConsoleError)(originError, environmentName);
    } else {
        error = (0, _consoleerror.createConsoleError)((0, _console.formatConsoleArgs)(consoleErrorArgs), environmentName);
    }
    (0, _stitchederror.setOwnerStackIfAvailable)(error);
    errorQueue.push(error);
    for (const handler of errorHandlers){
        // Delayed the error being passed to React Dev Overlay,
        // avoid the state being synchronously updated in the component.
        queueMicroTask(()=>{
            handler(error);
        });
    }
}
function handleClientError(error) {
    errorQueue.push(error);
    for (const handler of errorHandlers){
        // Delayed the error being passed to React Dev Overlay,
        // avoid the state being synchronously updated in the component.
        queueMicroTask(()=>{
            handler(error);
        });
    }
}
function useErrorHandler(handleOnUnhandledError, handleOnUnhandledRejection) {
    (0, _react.useEffect)(()=>{
        // Handle queued errors.
        errorQueue.forEach(handleOnUnhandledError);
        rejectionQueue.forEach(handleOnUnhandledRejection);
        // Listen to new errors.
        errorHandlers.push(handleOnUnhandledError);
        rejectionHandlers.push(handleOnUnhandledRejection);
        return ()=>{
            // Remove listeners.
            errorHandlers.splice(errorHandlers.indexOf(handleOnUnhandledError), 1);
            rejectionHandlers.splice(rejectionHandlers.indexOf(handleOnUnhandledRejection), 1);
            // Reset error queues.
            errorQueue.splice(0, errorQueue.length);
            rejectionQueue.splice(0, rejectionQueue.length);
        };
    }, [
        handleOnUnhandledError,
        handleOnUnhandledRejection
    ]);
}
function onUnhandledError(event) {
    const thrownValue = event.error;
    if ((0, _isnextroutererror.isNextRouterError)(thrownValue)) {
        event.preventDefault();
        return false;
    }
    // When there's an error property present, we log the error to error overlay.
    // Otherwise we don't do anything as it's not logging in the console either.
    if (thrownValue) {
        const error = (0, _stitchederror.coerceError)(thrownValue);
        (0, _stitchederror.setOwnerStackIfAvailable)(error);
        handleClientError(error);
        if (_forwardlogs.isTerminalLoggingEnabled) {
            (0, _forwardlogs.forwardUnhandledError)(error);
        }
    }
}
function onUnhandledRejection(ev) {
    const reason = ev == null ? void 0 : ev.reason;
    if ((0, _isnextroutererror.isNextRouterError)(reason)) {
        ev.preventDefault();
        return;
    }
    const error = (0, _stitchederror.coerceError)(reason);
    (0, _stitchederror.setOwnerStackIfAvailable)(error);
    rejectionQueue.push(error);
    for (const handler of rejectionHandlers){
        handler(error);
    }
    if (_forwardlogs.isTerminalLoggingEnabled) {
        (0, _forwardlogs.logUnhandledRejection)(reason);
    }
}
function handleGlobalErrors() {
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=use-error-handler.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/errors/constants.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "MISSING_ROOT_TAGS_ERROR", {
    enumerable: true,
    get: function() {
        return MISSING_ROOT_TAGS_ERROR;
    }
});
const MISSING_ROOT_TAGS_ERROR = 'NEXT_MISSING_ROOT_TAGS';
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=constants.js.map
}}),
"[project]/node_modules/next/dist/next-devtools/userspace/app/errors/replay-ssr-only-errors.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "ReplaySsrOnlyErrors", {
    enumerable: true,
    get: function() {
        return ReplaySsrOnlyErrors;
    }
});
const _react = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
const _useerrorhandler = __turbopack_context__.r("[project]/node_modules/next/dist/next-devtools/userspace/app/errors/use-error-handler.js [app-ssr] (ecmascript)");
const _isnextroutererror = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/is-next-router-error.js [app-ssr] (ecmascript)");
const _constants = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/errors/constants.js [app-ssr] (ecmascript)");
function readSsrError() {
    if (typeof document === 'undefined') {
        return null;
    }
    const ssrErrorTemplateTag = document.querySelector('template[data-next-error-message]');
    if (ssrErrorTemplateTag) {
        const message = ssrErrorTemplateTag.getAttribute('data-next-error-message');
        const stack = ssrErrorTemplateTag.getAttribute('data-next-error-stack');
        const digest = ssrErrorTemplateTag.getAttribute('data-next-error-digest');
        const error = Object.defineProperty(new Error(message), "__NEXT_ERROR_CODE", {
            value: "E394",
            enumerable: false,
            configurable: true
        });
        if (digest) {
            ;
            error.digest = digest;
        }
        // Skip Next.js SSR'd internal errors that which will be handled by the error boundaries.
        if ((0, _isnextroutererror.isNextRouterError)(error)) {
            return null;
        }
        error.stack = stack || '';
        return error;
    }
    return null;
}
function ReplaySsrOnlyErrors(param) {
    let { onBlockingError } = param;
    if ("TURBOPACK compile-time truthy", 1) {
        // Need to read during render. The attributes will be gone after commit.
        const ssrError = readSsrError();
        // eslint-disable-next-line react-hooks/rules-of-hooks
        (0, _react.useEffect)(()=>{
            if (ssrError !== null) {
                // TODO(veil): Include original Owner Stack (NDX-905)
                // TODO(veil): Mark as recoverable error
                // TODO(veil): console.error
                (0, _useerrorhandler.handleClientError)(ssrError);
                // If it's missing root tags, we can't recover, make it blocking.
                if (ssrError.digest === _constants.MISSING_ROOT_TAGS_ERROR) {
                    onBlockingError();
                }
            }
        }, [
            ssrError,
            onBlockingError
        ]);
    }
    return null;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=replay-ssr-only-errors.js.map
}}),
"[project]/node_modules/next/dist/client/dev/runtime-error-handler.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "RuntimeErrorHandler", {
    enumerable: true,
    get: function() {
        return RuntimeErrorHandler;
    }
});
const RuntimeErrorHandler = {
    hadRuntimeError: false
};
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=runtime-error-handler.js.map
}}),
"[project]/node_modules/next/dist/next-devtools/userspace/app/segment-explorer-node.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE: null,
    SegmentBoundaryTriggerNode: null,
    SegmentStateProvider: null,
    SegmentViewNode: null,
    SegmentViewStateNode: null,
    useSegmentState: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE: function() {
        return SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE;
    },
    SegmentBoundaryTriggerNode: function() {
        return SegmentBoundaryTriggerNode;
    },
    SegmentStateProvider: function() {
        return SegmentStateProvider;
    },
    SegmentViewNode: function() {
        return SegmentViewNode;
    },
    SegmentViewStateNode: function() {
        return SegmentViewStateNode;
    },
    useSegmentState: function() {
        return useSegmentState;
    }
});
const _jsxruntime = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js [app-ssr] (ecmascript)");
const _react = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
const _nextdevtools = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/next-devtools/index.js [app-ssr] (ecmascript)");
const _notfound = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/not-found.js [app-ssr] (ecmascript)");
const SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE = 'NEXT_DEVTOOLS_SIMULATED_ERROR';
function SegmentTrieNode(param) {
    let { type, pagePath } = param;
    const { boundaryType, setBoundaryType } = useSegmentState();
    const nodeState = (0, _react.useMemo)(()=>{
        return {
            type,
            pagePath,
            boundaryType,
            setBoundaryType
        };
    }, [
        type,
        pagePath,
        boundaryType,
        setBoundaryType
    ]);
    // Use `useLayoutEffect` to ensure the state is updated during suspense.
    // `useEffect` won't work as the state is preserved during suspense.
    (0, _react.useLayoutEffect)(()=>{
        _nextdevtools.dispatcher.segmentExplorerNodeAdd(nodeState);
        return ()=>{
            _nextdevtools.dispatcher.segmentExplorerNodeRemove(nodeState);
        };
    }, [
        nodeState
    ]);
    return null;
}
function NotFoundSegmentNode() {
    (0, _notfound.notFound)();
}
function ErrorSegmentNode() {
    throw Object.defineProperty(new Error(SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE), "__NEXT_ERROR_CODE", {
        value: "E394",
        enumerable: false,
        configurable: true
    });
}
const forever = new Promise(()=>{});
function LoadingSegmentNode() {
    (0, _react.use)(forever);
    return null;
}
function SegmentViewStateNode(param) {
    let { page } = param;
    (0, _react.useLayoutEffect)(()=>{
        _nextdevtools.dispatcher.segmentExplorerUpdateRouteState(page);
        return ()=>{
            _nextdevtools.dispatcher.segmentExplorerUpdateRouteState('');
        };
    }, [
        page
    ]);
    return null;
}
function SegmentBoundaryTriggerNode() {
    const { boundaryType } = useSegmentState();
    let segmentNode = null;
    if (boundaryType === 'loading') {
        segmentNode = /*#__PURE__*/ (0, _jsxruntime.jsx)(LoadingSegmentNode, {});
    } else if (boundaryType === 'not-found') {
        segmentNode = /*#__PURE__*/ (0, _jsxruntime.jsx)(NotFoundSegmentNode, {});
    } else if (boundaryType === 'error') {
        segmentNode = /*#__PURE__*/ (0, _jsxruntime.jsx)(ErrorSegmentNode, {});
    }
    return segmentNode;
}
function SegmentViewNode(param) {
    let { type, pagePath, children } = param;
    const segmentNode = /*#__PURE__*/ (0, _jsxruntime.jsx)(SegmentTrieNode, {
        type: type,
        pagePath: pagePath
    }, type);
    return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
        children: [
            segmentNode,
            children
        ]
    });
}
const SegmentStateContext = /*#__PURE__*/ (0, _react.createContext)({
    boundaryType: null,
    setBoundaryType: ()=>{}
});
function SegmentStateProvider(param) {
    let { children } = param;
    const [boundaryType, setBoundaryType] = (0, _react.useState)(null);
    const [errorBoundaryKey, setErrorBoundaryKey] = (0, _react.useState)(0);
    const reloadBoundary = (0, _react.useCallback)(()=>setErrorBoundaryKey((prev)=>prev + 1), []);
    const setBoundaryTypeAndReload = (0, _react.useCallback)((type)=>{
        if (type === null) {
            reloadBoundary();
        }
        setBoundaryType(type);
    }, [
        reloadBoundary
    ]);
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(SegmentStateContext.Provider, {
        value: {
            boundaryType,
            setBoundaryType: setBoundaryTypeAndReload
        },
        children: children
    }, errorBoundaryKey);
}
function useSegmentState() {
    return (0, _react.useContext)(SegmentStateContext);
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=segment-explorer-node.js.map
}}),
"[project]/node_modules/next/dist/next-devtools/userspace/app/app-dev-overlay-error-boundary.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "AppDevOverlayErrorBoundary", {
    enumerable: true,
    get: function() {
        return AppDevOverlayErrorBoundary;
    }
});
const _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-ssr] (ecmascript)");
const _jsxruntime = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js [app-ssr] (ecmascript)");
const _react = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
const _nextdevtools = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/next-devtools/index.js [app-ssr] (ecmascript)");
const _runtimeerrorhandler = __turbopack_context__.r("[project]/node_modules/next/dist/client/dev/runtime-error-handler.js [app-ssr] (ecmascript)");
const _errorboundary = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/error-boundary.js [app-ssr] (ecmascript)");
const _globalerror = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/client/components/builtin/global-error.js [app-ssr] (ecmascript)"));
const _segmentexplorernode = __turbopack_context__.r("[project]/node_modules/next/dist/next-devtools/userspace/app/segment-explorer-node.js [app-ssr] (ecmascript)");
function ErroredHtml(param) {
    let { globalError: [GlobalError, globalErrorStyles], error } = param;
    if (!error) {
        return /*#__PURE__*/ (0, _jsxruntime.jsxs)("html", {
            children: [
                /*#__PURE__*/ (0, _jsxruntime.jsx)("head", {}),
                /*#__PURE__*/ (0, _jsxruntime.jsx)("body", {})
            ]
        });
    }
    return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_errorboundary.ErrorBoundary, {
        errorComponent: _globalerror.default,
        children: [
            globalErrorStyles,
            /*#__PURE__*/ (0, _jsxruntime.jsx)(GlobalError, {
                error: error
            })
        ]
    });
}
class AppDevOverlayErrorBoundary extends _react.PureComponent {
    static getDerivedStateFromError(error) {
        _runtimeerrorhandler.RuntimeErrorHandler.hadRuntimeError = true;
        return {
            reactError: error
        };
    }
    componentDidCatch(err) {
        if (("TURBOPACK compile-time value", "development") === 'development' && err.message === _segmentexplorernode.SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE) {
            return;
        }
        _nextdevtools.dispatcher.openErrorOverlay();
    }
    render() {
        const { children, globalError } = this.props;
        const { reactError } = this.state;
        const fallback = /*#__PURE__*/ (0, _jsxruntime.jsx)(ErroredHtml, {
            globalError: globalError,
            error: reactError
        });
        return reactError !== null ? fallback : children;
    }
    constructor(...args){
        super(...args), this.state = {
            reactError: null
        };
    }
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=app-dev-overlay-error-boundary.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/normalized-asset-prefix.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "normalizedAssetPrefix", {
    enumerable: true,
    get: function() {
        return normalizedAssetPrefix;
    }
});
function normalizedAssetPrefix(assetPrefix) {
    // remove all leading slashes and trailing slashes
    const escapedAssetPrefix = (assetPrefix == null ? void 0 : assetPrefix.replace(/^\/+|\/+$/g, '')) || false;
    // if an assetPrefix was '/', we return empty string
    // because it could be an unnecessary trailing slash
    if (!escapedAssetPrefix) {
        return '';
    }
    if (URL.canParse(escapedAssetPrefix)) {
        const url = new URL(escapedAssetPrefix).toString();
        return url.endsWith('/') ? url.slice(0, -1) : url;
    }
    // assuming assetPrefix here is a pathname-style,
    // restore the leading slash
    return "/" + escapedAssetPrefix;
} //# sourceMappingURL=normalized-asset-prefix.js.map
}}),
"[project]/node_modules/next/dist/client/dev/hot-reloader/get-socket-url.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "getSocketUrl", {
    enumerable: true,
    get: function() {
        return getSocketUrl;
    }
});
const _normalizedassetprefix = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/normalized-asset-prefix.js [app-ssr] (ecmascript)");
function getSocketProtocol(assetPrefix) {
    let protocol = window.location.protocol;
    try {
        // assetPrefix is a url
        protocol = new URL(assetPrefix).protocol;
    } catch (e) {}
    return protocol === 'http:' ? 'ws:' : 'wss:';
}
function getSocketUrl(assetPrefix) {
    const prefix = (0, _normalizedassetprefix.normalizedAssetPrefix)(assetPrefix);
    const protocol = getSocketProtocol(assetPrefix || '');
    if (URL.canParse(prefix)) {
        // since normalized asset prefix is ensured to be a URL format,
        // we can safely replace the protocol
        return prefix.replace(/^http/, 'ws');
    }
    const { hostname, port } = window.location;
    return protocol + "//" + hostname + (port ? ":" + port : '') + prefix;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=get-socket-url.js.map
}}),
"[project]/node_modules/next/dist/client/dev/hot-reloader/app/use-websocket.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    useSendMessage: null,
    useTurbopack: null,
    useWebsocket: null,
    useWebsocketPing: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    useSendMessage: function() {
        return useSendMessage;
    },
    useTurbopack: function() {
        return useTurbopack;
    },
    useWebsocket: function() {
        return useWebsocket;
    },
    useWebsocketPing: function() {
        return useWebsocketPing;
    }
});
const _react = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
const _approutercontextsharedruntime = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/contexts/app-router-context.js [app-ssr] (ecmascript)");
const _getsocketurl = __turbopack_context__.r("[project]/node_modules/next/dist/client/dev/hot-reloader/get-socket-url.js [app-ssr] (ecmascript)");
function useWebsocket(assetPrefix) {
    const webSocketRef = (0, _react.useRef)(undefined);
    (0, _react.useEffect)(()=>{
        if (webSocketRef.current) {
            return;
        }
        const url = (0, _getsocketurl.getSocketUrl)(assetPrefix);
        webSocketRef.current = new window.WebSocket("" + url + "/_next/webpack-hmr");
    }, [
        assetPrefix
    ]);
    return webSocketRef;
}
function useSendMessage(webSocketRef) {
    const sendMessage = (0, _react.useCallback)((data)=>{
        const socket = webSocketRef.current;
        if (!socket || socket.readyState !== socket.OPEN) {
            return;
        }
        return socket.send(data);
    }, [
        webSocketRef
    ]);
    return sendMessage;
}
function useTurbopack(sendMessage, onUpdateError) {
    const turbopackState = (0, _react.useRef)({
        init: false,
        // Until the dynamic import resolves, queue any turbopack messages which will be replayed.
        queue: [],
        callback: undefined
    });
    const processTurbopackMessage = (0, _react.useCallback)((msg)=>{
        const { callback, queue } = turbopackState.current;
        if (callback) {
            callback(msg);
        } else {
            queue.push(msg);
        }
    }, []);
    (0, _react.useEffect)(()=>{
        const { current: initCurrent } = turbopackState;
        // TODO(WEB-1589): only install if `process.turbopack` set.
        if (initCurrent.init) {
            return;
        }
        initCurrent.init = true;
        __turbopack_context__.r("[turbopack]/browser/dev/hmr-client/hmr-client.ts [app-ssr] (ecmascript, async loader)")(__turbopack_context__.i).then((param)=>{
            let { connect } = param;
            const { current } = turbopackState;
            connect({
                addMessageListener (cb) {
                    current.callback = cb;
                    // Replay all Turbopack messages before we were able to establish the HMR client.
                    for (const msg of current.queue){
                        cb(msg);
                    }
                    current.queue = undefined;
                },
                sendMessage,
                onUpdateError
            });
        });
    }, [
        sendMessage,
        onUpdateError
    ]);
    return processTurbopackMessage;
}
function useWebsocketPing(websocketRef) {
    const sendMessage = useSendMessage(websocketRef);
    const { tree } = (0, _react.useContext)(_approutercontextsharedruntime.GlobalLayoutRouterContext);
    (0, _react.useEffect)(()=>{
        // Never send pings when using Turbopack as it's not used.
        // Pings were originally used to keep track of active routes in on-demand-entries with webpack.
        if ("TURBOPACK compile-time truthy", 1) {
            return;
        }
        //TURBOPACK unreachable
        ;
        // Taken from on-demand-entries-client.js
        const interval = undefined;
    }, [
        tree,
        sendMessage
    ]);
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=use-websocket.js.map
}}),
"[project]/node_modules/next/dist/server/dev/hot-reloader-types.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "HMR_ACTIONS_SENT_TO_BROWSER", {
    enumerable: true,
    get: function() {
        return HMR_ACTIONS_SENT_TO_BROWSER;
    }
});
var HMR_ACTIONS_SENT_TO_BROWSER = /*#__PURE__*/ function(HMR_ACTIONS_SENT_TO_BROWSER) {
    HMR_ACTIONS_SENT_TO_BROWSER["ADDED_PAGE"] = "addedPage";
    HMR_ACTIONS_SENT_TO_BROWSER["REMOVED_PAGE"] = "removedPage";
    HMR_ACTIONS_SENT_TO_BROWSER["RELOAD_PAGE"] = "reloadPage";
    HMR_ACTIONS_SENT_TO_BROWSER["SERVER_COMPONENT_CHANGES"] = "serverComponentChanges";
    HMR_ACTIONS_SENT_TO_BROWSER["MIDDLEWARE_CHANGES"] = "middlewareChanges";
    HMR_ACTIONS_SENT_TO_BROWSER["CLIENT_CHANGES"] = "clientChanges";
    HMR_ACTIONS_SENT_TO_BROWSER["SERVER_ONLY_CHANGES"] = "serverOnlyChanges";
    HMR_ACTIONS_SENT_TO_BROWSER["SYNC"] = "sync";
    HMR_ACTIONS_SENT_TO_BROWSER["BUILT"] = "built";
    HMR_ACTIONS_SENT_TO_BROWSER["BUILDING"] = "building";
    HMR_ACTIONS_SENT_TO_BROWSER["DEV_PAGES_MANIFEST_UPDATE"] = "devPagesManifestUpdate";
    HMR_ACTIONS_SENT_TO_BROWSER["TURBOPACK_MESSAGE"] = "turbopack-message";
    HMR_ACTIONS_SENT_TO_BROWSER["SERVER_ERROR"] = "serverError";
    HMR_ACTIONS_SENT_TO_BROWSER["TURBOPACK_CONNECTED"] = "turbopack-connected";
    HMR_ACTIONS_SENT_TO_BROWSER["ISR_MANIFEST"] = "isrManifest";
    HMR_ACTIONS_SENT_TO_BROWSER["DEV_INDICATOR"] = "devIndicator";
    return HMR_ACTIONS_SENT_TO_BROWSER;
}({}); //# sourceMappingURL=hot-reloader-types.js.map
}}),
"[project]/node_modules/next/dist/client/dev/report-hmr-latency.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, /**
 * Logs information about a completed HMR to the console, the server (via a
 * `client-hmr-latency` event), and to `self.__NEXT_HMR_LATENCY_CB` (a debugging
 * hook).
 *
 * @param hasUpdate Set this to `false` to avoid reporting the HMR event via a
 *   `client-hmr-latency` event or to `self.__NEXT_HMR_LATENCY_CB`. Used by
 *   turbopack when we must report a message to the browser console (because we
 *   already logged a "rebuilding" message), but it's not a real HMR, so we
 *   don't want to impact our telemetry.
 */ "default", {
    enumerable: true,
    get: function() {
        return reportHmrLatency;
    }
});
function reportHmrLatency(sendMessage, updatedModules, startMsSinceEpoch, endMsSinceEpoch, hasUpdate) {
    if (hasUpdate === void 0) hasUpdate = true;
    const latencyMs = endMsSinceEpoch - startMsSinceEpoch;
    console.log("[Fast Refresh] done in " + latencyMs + "ms");
    if (!hasUpdate) {
        return;
    }
    sendMessage(JSON.stringify({
        event: 'client-hmr-latency',
        id: window.__nextDevClientId,
        startTime: startMsSinceEpoch,
        endTime: endMsSinceEpoch,
        page: window.location.pathname,
        updatedModules,
        // Whether the page (tab) was hidden at the time the event occurred.
        // This can impact the accuracy of the event's timing.
        isPageHidden: document.visibilityState === 'hidden'
    }));
    if (self.__NEXT_HMR_LATENCY_CB) {
        self.__NEXT_HMR_LATENCY_CB(latencyMs);
    }
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=report-hmr-latency.js.map
}}),
"[project]/node_modules/next/dist/client/dev/hot-reloader/turbopack-hot-reloader-common.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "TurbopackHmr", {
    enumerable: true,
    get: function() {
        return TurbopackHmr;
    }
});
const _class_private_field_loose_base = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_class_private_field_loose_base.cjs [app-ssr] (ecmascript)");
const _class_private_field_loose_key = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_class_private_field_loose_key.cjs [app-ssr] (ecmascript)");
// How long to wait before reporting the HMR start, used to suppress irrelevant
// `BUILDING` events. Does not impact reported latency.
const TURBOPACK_HMR_START_DELAY_MS = 100;
var _updatedModules = /*#__PURE__*/ _class_private_field_loose_key._("_updatedModules"), _startMsSinceEpoch = /*#__PURE__*/ _class_private_field_loose_key._("_startMsSinceEpoch"), _lastUpdateMsSinceEpoch = /*#__PURE__*/ _class_private_field_loose_key._("_lastUpdateMsSinceEpoch"), _deferredReportHmrStartId = /*#__PURE__*/ _class_private_field_loose_key._("_deferredReportHmrStartId"), // as it reports *any* compilation, including fully no-op/cached compilations
// and those unrelated to HMR. Fixing this would require significant
// architectural changes.
//
// Work around this by deferring any "rebuilding" message by 100ms. If we get
// a BUILT event within that threshold and nothing has changed, just suppress
// the message entirely.
_runDeferredReportHmrStart = /*#__PURE__*/ _class_private_field_loose_key._("_runDeferredReportHmrStart"), _cancelDeferredReportHmrStart = /*#__PURE__*/ _class_private_field_loose_key._("_cancelDeferredReportHmrStart"), /** Helper for other `onEvent` methods. */ _onUpdate = /*#__PURE__*/ _class_private_field_loose_key._("_onUpdate");
class TurbopackHmr {
    onBuilding() {
        _class_private_field_loose_base._(this, _lastUpdateMsSinceEpoch)[_lastUpdateMsSinceEpoch] = undefined;
        _class_private_field_loose_base._(this, _cancelDeferredReportHmrStart)[_cancelDeferredReportHmrStart]();
        _class_private_field_loose_base._(this, _startMsSinceEpoch)[_startMsSinceEpoch] = Date.now();
        // report the HMR start after a short delay
        _class_private_field_loose_base._(this, _deferredReportHmrStartId)[_deferredReportHmrStartId] = setTimeout(()=>_class_private_field_loose_base._(this, _runDeferredReportHmrStart)[_runDeferredReportHmrStart](), self.__NEXT_HMR_TURBOPACK_REPORT_NOISY_NOOP_EVENTS ? 0 : TURBOPACK_HMR_START_DELAY_MS);
    }
    onTurbopackMessage(msg) {
        _class_private_field_loose_base._(this, _onUpdate)[_onUpdate]();
        const updatedModules = extractModulesFromTurbopackMessage(msg.data);
        for (const module1 of updatedModules){
            _class_private_field_loose_base._(this, _updatedModules)[_updatedModules].add(module1);
        }
    }
    onServerComponentChanges() {
        _class_private_field_loose_base._(this, _onUpdate)[_onUpdate]();
    }
    onReloadPage() {
        _class_private_field_loose_base._(this, _onUpdate)[_onUpdate]();
    }
    onPageAddRemove() {
        _class_private_field_loose_base._(this, _onUpdate)[_onUpdate]();
    }
    /**
   * @returns `null` if the caller should ignore the update entirely. Returns an
   *   object with `hasUpdates: false` if the caller should report the end of
   *   the HMR in the browser console, but the HMR was a no-op.
   */ onBuilt() {
        // Check that we got *any* `TurbopackMessageAction`, even if
        // `updatedModules` is empty (not everything gets recorded there).
        //
        // There's also a case where `onBuilt` gets called before `onBuilding`,
        // which can happen during initial page load. Ignore that too!
        const hasUpdates = _class_private_field_loose_base._(this, _lastUpdateMsSinceEpoch)[_lastUpdateMsSinceEpoch] != null && _class_private_field_loose_base._(this, _startMsSinceEpoch)[_startMsSinceEpoch] != null;
        if (!hasUpdates && _class_private_field_loose_base._(this, _deferredReportHmrStartId)[_deferredReportHmrStartId] != null) {
            // suppress the update entirely
            _class_private_field_loose_base._(this, _cancelDeferredReportHmrStart)[_cancelDeferredReportHmrStart]();
            return null;
        }
        _class_private_field_loose_base._(this, _runDeferredReportHmrStart)[_runDeferredReportHmrStart]();
        var _class_private_field_loose_base__lastUpdateMsSinceEpoch;
        const result = {
            hasUpdates,
            updatedModules: _class_private_field_loose_base._(this, _updatedModules)[_updatedModules],
            startMsSinceEpoch: _class_private_field_loose_base._(this, _startMsSinceEpoch)[_startMsSinceEpoch],
            endMsSinceEpoch: (_class_private_field_loose_base__lastUpdateMsSinceEpoch = _class_private_field_loose_base._(this, _lastUpdateMsSinceEpoch)[_lastUpdateMsSinceEpoch]) != null ? _class_private_field_loose_base__lastUpdateMsSinceEpoch : Date.now()
        };
        _class_private_field_loose_base._(this, _updatedModules)[_updatedModules] = new Set();
        return result;
    }
    constructor(){
        Object.defineProperty(this, _runDeferredReportHmrStart, {
            value: runDeferredReportHmrStart
        });
        Object.defineProperty(this, _cancelDeferredReportHmrStart, {
            value: cancelDeferredReportHmrStart
        });
        Object.defineProperty(this, _onUpdate, {
            value: onUpdate
        });
        Object.defineProperty(this, _updatedModules, {
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _startMsSinceEpoch, {
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _lastUpdateMsSinceEpoch, {
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _deferredReportHmrStartId, {
            writable: true,
            value: void 0
        });
        _class_private_field_loose_base._(this, _updatedModules)[_updatedModules] = new Set();
    }
}
function runDeferredReportHmrStart() {
    if (_class_private_field_loose_base._(this, _deferredReportHmrStartId)[_deferredReportHmrStartId] != null) {
        console.log('[Fast Refresh] rebuilding');
        _class_private_field_loose_base._(this, _cancelDeferredReportHmrStart)[_cancelDeferredReportHmrStart]();
    }
}
function cancelDeferredReportHmrStart() {
    clearTimeout(_class_private_field_loose_base._(this, _deferredReportHmrStartId)[_deferredReportHmrStartId]);
    _class_private_field_loose_base._(this, _deferredReportHmrStartId)[_deferredReportHmrStartId] = undefined;
}
function onUpdate() {
    _class_private_field_loose_base._(this, _runDeferredReportHmrStart)[_runDeferredReportHmrStart]();
    _class_private_field_loose_base._(this, _lastUpdateMsSinceEpoch)[_lastUpdateMsSinceEpoch] = Date.now();
}
function extractModulesFromTurbopackMessage(data) {
    const updatedModules = new Set();
    const updates = Array.isArray(data) ? data : [
        data
    ];
    for (const update of updates){
        // TODO this won't capture changes to CSS since they don't result in a "merged" update
        if (update.type !== 'partial' || update.instruction.type !== 'ChunkListUpdate' || update.instruction.merged === undefined) {
            continue;
        }
        for (const mergedUpdate of update.instruction.merged){
            for (const name of Object.keys(mergedUpdate.entries)){
                const res = /(.*)\s+\[.*/.exec(name);
                if (res === null) {
                    console.error('[Turbopack HMR] Expected module to match pattern: ' + name);
                    continue;
                }
                updatedModules.add(res[1]);
            }
        }
    }
    return updatedModules;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=turbopack-hot-reloader-common.js.map
}}),
"[project]/node_modules/next/dist/next-devtools/userspace/app/errors/use-forward-console-log.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useForwardConsoleLog", {
    enumerable: true,
    get: function() {
        return useForwardConsoleLog;
    }
});
const _react = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
const _forwardlogs = __turbopack_context__.r("[project]/node_modules/next/dist/next-devtools/userspace/app/forward-logs.js [app-ssr] (ecmascript)");
const useForwardConsoleLog = (socketRef)=>{
    (0, _react.useEffect)(()=>{
        if (!_forwardlogs.isTerminalLoggingEnabled) {
            return;
        }
        const socket = socketRef.current;
        if (!socket) {
            return;
        }
        const onOpen = ()=>{
            _forwardlogs.logQueue.onSocketReady(socket);
        };
        socket.addEventListener('open', onOpen);
        return ()=>{
            socket.removeEventListener('open', onOpen);
        };
    }, [
        socketRef
    ]);
};
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=use-forward-console-log.js.map
}}),
"[project]/node_modules/next/dist/client/dev/hot-reloader/app/hot-reloader-app.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/// <reference types="webpack/module.d.ts" />
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    default: null,
    waitForWebpackRuntimeHotUpdate: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    default: function() {
        return HotReload;
    },
    waitForWebpackRuntimeHotUpdate: function() {
        return waitForWebpackRuntimeHotUpdate;
    }
});
const _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-ssr] (ecmascript)");
const _jsxruntime = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js [app-ssr] (ecmascript)");
const _react = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
const _stripansi = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/strip-ansi/index.js [app-ssr] (ecmascript)"));
const _formatwebpackmessages = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/format-webpack-messages.js [app-ssr] (ecmascript)"));
const _navigation = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/navigation.js [app-ssr] (ecmascript)");
const _shared = __turbopack_context__.r("[project]/node_modules/next/dist/client/dev/hot-reloader/shared.js [app-ssr] (ecmascript)");
const _nextdevtools = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/next-devtools/index.js [app-ssr] (ecmascript)");
const _replayssronlyerrors = __turbopack_context__.r("[project]/node_modules/next/dist/next-devtools/userspace/app/errors/replay-ssr-only-errors.js [app-ssr] (ecmascript)");
const _appdevoverlayerrorboundary = __turbopack_context__.r("[project]/node_modules/next/dist/next-devtools/userspace/app/app-dev-overlay-error-boundary.js [app-ssr] (ecmascript)");
const _useerrorhandler = __turbopack_context__.r("[project]/node_modules/next/dist/next-devtools/userspace/app/errors/use-error-handler.js [app-ssr] (ecmascript)");
const _runtimeerrorhandler = __turbopack_context__.r("[project]/node_modules/next/dist/client/dev/runtime-error-handler.js [app-ssr] (ecmascript)");
const _usewebsocket = __turbopack_context__.r("[project]/node_modules/next/dist/client/dev/hot-reloader/app/use-websocket.js [app-ssr] (ecmascript)");
const _hotreloadertypes = __turbopack_context__.r("[project]/node_modules/next/dist/server/dev/hot-reloader-types.js [app-ssr] (ecmascript)");
const _navigationuntracked = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/navigation-untracked.js [app-ssr] (ecmascript)");
const _reporthmrlatency = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/client/dev/report-hmr-latency.js [app-ssr] (ecmascript)"));
const _turbopackhotreloadercommon = __turbopack_context__.r("[project]/node_modules/next/dist/client/dev/hot-reloader/turbopack-hot-reloader-common.js [app-ssr] (ecmascript)");
const _approuterheaders = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/app-router-headers.js [app-ssr] (ecmascript)");
const _useforwardconsolelog = __turbopack_context__.r("[project]/node_modules/next/dist/next-devtools/userspace/app/errors/use-forward-console-log.js [app-ssr] (ecmascript)");
let mostRecentCompilationHash = null;
let __nextDevClientId = Math.round(Math.random() * 100 + Date.now());
let reloading = false;
let webpackStartMsSinceEpoch = null;
const turbopackHmr = ("TURBOPACK compile-time truthy", 1) ? new _turbopackhotreloadercommon.TurbopackHmr() : "TURBOPACK unreachable";
let pendingHotUpdateWebpack = Promise.resolve();
let resolvePendingHotUpdateWebpack = ()=>{};
function setPendingHotUpdateWebpack() {
    pendingHotUpdateWebpack = new Promise((resolve)=>{
        resolvePendingHotUpdateWebpack = ()=>{
            resolve();
        };
    });
}
function waitForWebpackRuntimeHotUpdate() {
    return pendingHotUpdateWebpack;
}
// There is a newer version of the code available.
function handleAvailableHash(hash) {
    // Update last known compilation hash.
    mostRecentCompilationHash = hash;
}
/**
 * Is there a newer version of this code available?
 * For webpack: Check if the hash changed compared to __webpack_hash__
 * For Turbopack: Always true because it doesn't have __webpack_hash__
 */ function isUpdateAvailable() {
    if ("TURBOPACK compile-time truthy", 1) {
        return true;
    }
    //TURBOPACK unreachable
    ;
}
// Webpack disallows updates in other states.
function canApplyUpdates() {
    return module.hot.status() === 'idle';
}
function afterApplyUpdates(fn) {
    if (canApplyUpdates()) {
        fn();
    } else {
        function handler(status) {
            if (status === 'idle') {
                module.hot.removeStatusHandler(handler);
                fn();
            }
        }
        module.hot.addStatusHandler(handler);
    }
}
function performFullReload(err, sendMessage) {
    const stackTrace = err && (err.stack && err.stack.split('\n').slice(0, 5).join('\n') || err.message || err + '');
    sendMessage(JSON.stringify({
        event: 'client-full-reload',
        stackTrace,
        hadRuntimeError: !!_runtimeerrorhandler.RuntimeErrorHandler.hadRuntimeError,
        dependencyChain: err ? err.dependencyChain : undefined
    }));
    if (reloading) return;
    reloading = true;
    window.location.reload();
}
// Attempt to update code on the fly, fall back to a hard reload.
function tryApplyUpdatesWebpack(sendMessage) {
    if (!isUpdateAvailable() || !canApplyUpdates()) {
        resolvePendingHotUpdateWebpack();
        _nextdevtools.dispatcher.onBuildOk();
        (0, _reporthmrlatency.default)(sendMessage, [], webpackStartMsSinceEpoch, Date.now());
        return;
    }
    function handleApplyUpdates(err, updatedModules) {
        if (err || _runtimeerrorhandler.RuntimeErrorHandler.hadRuntimeError || updatedModules == null) {
            if (err) {
                console.warn(_shared.REACT_REFRESH_FULL_RELOAD);
            } else if (_runtimeerrorhandler.RuntimeErrorHandler.hadRuntimeError) {
                console.warn(_shared.REACT_REFRESH_FULL_RELOAD_FROM_ERROR);
            }
            performFullReload(err, sendMessage);
            return;
        }
        _nextdevtools.dispatcher.onBuildOk();
        if (isUpdateAvailable()) {
            // While we were updating, there was a new update! Do it again.
            tryApplyUpdatesWebpack(sendMessage);
            return;
        }
        _nextdevtools.dispatcher.onRefresh();
        resolvePendingHotUpdateWebpack();
        (0, _reporthmrlatency.default)(sendMessage, updatedModules, webpackStartMsSinceEpoch, Date.now());
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
    }
    // https://webpack.js.org/api/hot-module-replacement/#check
    module.hot.check(/* autoApply */ false).then((updatedModules)=>{
        if (updatedModules == null) {
            return null;
        }
        // We should always handle an update, even if updatedModules is empty (but
        // non-null) for any reason. That's what webpack would normally do:
        // https://github.com/webpack/webpack/blob/3aa6b6bc3a64/lib/hmr/HotModuleReplacement.runtime.js#L296-L298
        _nextdevtools.dispatcher.onBeforeRefresh();
        // https://webpack.js.org/api/hot-module-replacement/#apply
        return module.hot.apply();
    }).then((updatedModules)=>{
        handleApplyUpdates(null, updatedModules);
    }, (err)=>{
        handleApplyUpdates(err, null);
    });
}
/** Handles messages from the server for the App Router. */ function processMessage(obj, sendMessage, processTurbopackMessage, router, appIsrManifestRef, pathnameRef) {
    if (!('action' in obj)) {
        return;
    }
    function handleErrors(errors) {
        // "Massage" webpack messages.
        const formatted = (0, _formatwebpackmessages.default)({
            errors: errors,
            warnings: []
        });
        // Only show the first error.
        _nextdevtools.dispatcher.onBuildError(formatted.errors[0]);
        // Also log them to the console.
        for(let i = 0; i < formatted.errors.length; i++){
            console.error((0, _stripansi.default)(formatted.errors[i]));
        }
        // Do not attempt to reload now.
        // We will reload on next success instead.
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
    }
    function handleHotUpdate() {
        if ("TURBOPACK compile-time truthy", 1) {
            const hmrUpdate = turbopackHmr.onBuilt();
            if (hmrUpdate != null) {
                (0, _reporthmrlatency.default)(sendMessage, [
                    ...hmrUpdate.updatedModules
                ], hmrUpdate.startMsSinceEpoch, hmrUpdate.endMsSinceEpoch, hmrUpdate.hasUpdates);
            }
            _nextdevtools.dispatcher.onBuildOk();
        } else //TURBOPACK unreachable
        ;
    }
    switch(obj.action){
        case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.ISR_MANIFEST:
            {
                if ("TURBOPACK compile-time truthy", 1) {
                    if (appIsrManifestRef) {
                        appIsrManifestRef.current = obj.data;
                        // handle initial status on receiving manifest
                        // navigation is handled in useEffect for pathname changes
                        // as we'll receive the updated manifest before usePathname
                        // triggers for new value
                        if (pathnameRef.current in obj.data) {
                            _nextdevtools.dispatcher.onStaticIndicator(true);
                        } else {
                            _nextdevtools.dispatcher.onStaticIndicator(false);
                        }
                    }
                }
                break;
            }
        case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.BUILDING:
            {
                _nextdevtools.dispatcher.buildingIndicatorShow();
                if ("TURBOPACK compile-time truthy", 1) {
                    turbopackHmr.onBuilding();
                } else //TURBOPACK unreachable
                ;
                break;
            }
        case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.BUILT:
        case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.SYNC:
            {
                _nextdevtools.dispatcher.buildingIndicatorHide();
                if (obj.hash) {
                    handleAvailableHash(obj.hash);
                }
                const { errors, warnings } = obj;
                // Is undefined when it's a 'built' event
                if ('versionInfo' in obj) _nextdevtools.dispatcher.onVersionInfo(obj.versionInfo);
                if ('debug' in obj && obj.debug) _nextdevtools.dispatcher.onDebugInfo(obj.debug);
                if ('devIndicator' in obj) _nextdevtools.dispatcher.onDevIndicator(obj.devIndicator);
                const hasErrors = Boolean(errors && errors.length);
                // Compilation with errors (e.g. syntax error or missing modules).
                if (hasErrors) {
                    sendMessage(JSON.stringify({
                        event: 'client-error',
                        errorCount: errors.length,
                        clientId: __nextDevClientId
                    }));
                    handleErrors(errors);
                    return;
                }
                const hasWarnings = Boolean(warnings && warnings.length);
                if (hasWarnings) {
                    sendMessage(JSON.stringify({
                        event: 'client-warning',
                        warningCount: warnings.length,
                        clientId: __nextDevClientId
                    }));
                    // Print warnings to the console.
                    const formattedMessages = (0, _formatwebpackmessages.default)({
                        warnings: warnings,
                        errors: []
                    });
                    for(let i = 0; i < formattedMessages.warnings.length; i++){
                        if (i === 5) {
                            console.warn('There were more warnings in other files.\n' + 'You can find a complete log in the terminal.');
                            break;
                        }
                        console.warn((0, _stripansi.default)(formattedMessages.warnings[i]));
                    }
                // No early return here as we need to apply modules in the same way between warnings only and compiles without warnings
                }
                sendMessage(JSON.stringify({
                    event: 'client-success',
                    clientId: __nextDevClientId
                }));
                if (obj.action === _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.BUILT) {
                    handleHotUpdate();
                }
                return;
            }
        case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_CONNECTED:
            {
                processTurbopackMessage({
                    type: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_CONNECTED,
                    data: {
                        sessionId: obj.data.sessionId
                    }
                });
                break;
            }
        case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_MESSAGE:
            {
                turbopackHmr.onTurbopackMessage(obj);
                _nextdevtools.dispatcher.onBeforeRefresh();
                processTurbopackMessage({
                    type: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_MESSAGE,
                    data: obj.data
                });
                if (_runtimeerrorhandler.RuntimeErrorHandler.hadRuntimeError) {
                    console.warn(_shared.REACT_REFRESH_FULL_RELOAD_FROM_ERROR);
                    performFullReload(null, sendMessage);
                }
                _nextdevtools.dispatcher.onRefresh();
                break;
            }
        // TODO-APP: make server component change more granular
        case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.SERVER_COMPONENT_CHANGES:
            {
                turbopackHmr == null ? void 0 : turbopackHmr.onServerComponentChanges();
                sendMessage(JSON.stringify({
                    event: 'server-component-reload-page',
                    clientId: __nextDevClientId,
                    hash: obj.hash
                }));
                // Store the latest hash in a session cookie so that it's sent back to the
                // server with any subsequent requests.
                document.cookie = _approuterheaders.NEXT_HMR_REFRESH_HASH_COOKIE + "=" + obj.hash;
                if (_runtimeerrorhandler.RuntimeErrorHandler.hadRuntimeError) {
                    if (reloading) return;
                    reloading = true;
                    return window.location.reload();
                }
                (0, _react.startTransition)(()=>{
                    router.hmrRefresh();
                    _nextdevtools.dispatcher.onRefresh();
                });
                if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
                ;
                return;
            }
        case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.RELOAD_PAGE:
            {
                turbopackHmr == null ? void 0 : turbopackHmr.onReloadPage();
                sendMessage(JSON.stringify({
                    event: 'client-reload-page',
                    clientId: __nextDevClientId
                }));
                if (reloading) return;
                reloading = true;
                return window.location.reload();
            }
        case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.ADDED_PAGE:
        case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.REMOVED_PAGE:
            {
                turbopackHmr == null ? void 0 : turbopackHmr.onPageAddRemove();
                // TODO-APP: potentially only refresh if the currently viewed page was added/removed.
                return router.hmrRefresh();
            }
        case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.SERVER_ERROR:
            {
                const { errorJSON } = obj;
                if (errorJSON) {
                    const { message, stack } = JSON.parse(errorJSON);
                    const error = Object.defineProperty(new Error(message), "__NEXT_ERROR_CODE", {
                        value: "E394",
                        enumerable: false,
                        configurable: true
                    });
                    error.stack = stack;
                    handleErrors([
                        error
                    ]);
                }
                return;
            }
        case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.DEV_PAGES_MANIFEST_UPDATE:
            {
                return;
            }
        default:
            {}
    }
}
function HotReload(param) {
    let { assetPrefix, children, globalError } = param;
    (0, _useerrorhandler.useErrorHandler)(_nextdevtools.dispatcher.onUnhandledError, _nextdevtools.dispatcher.onUnhandledRejection);
    const webSocketRef = (0, _usewebsocket.useWebsocket)(assetPrefix);
    (0, _usewebsocket.useWebsocketPing)(webSocketRef);
    const sendMessage = (0, _usewebsocket.useSendMessage)(webSocketRef);
    (0, _useforwardconsolelog.useForwardConsoleLog)(webSocketRef);
    const processTurbopackMessage = (0, _usewebsocket.useTurbopack)(sendMessage, (err)=>performFullReload(err, sendMessage));
    const router = (0, _navigation.useRouter)();
    // We don't want access of the pathname for the dev tools to trigger a dynamic
    // access (as the dev overlay will never be present in production).
    const pathname = (0, _navigationuntracked.useUntrackedPathname)();
    const appIsrManifestRef = (0, _react.useRef)({});
    const pathnameRef = (0, _react.useRef)(pathname);
    if ("TURBOPACK compile-time truthy", 1) {
        // this conditional is only for dead-code elimination which
        // isn't a runtime conditional only build-time so ignore hooks rule
        // eslint-disable-next-line react-hooks/rules-of-hooks
        (0, _react.useEffect)(()=>{
            pathnameRef.current = pathname;
            const appIsrManifest = appIsrManifestRef.current;
            if (appIsrManifest) {
                if (pathname && pathname in appIsrManifest) {
                    try {
                        _nextdevtools.dispatcher.onStaticIndicator(true);
                    } catch (reason) {
                        let message = '';
                        if (reason instanceof DOMException) {
                            var _reason_stack;
                            // Most likely a SecurityError, because of an unavailable localStorage
                            message = (_reason_stack = reason.stack) != null ? _reason_stack : reason.message;
                        } else if (reason instanceof Error) {
                            var _reason_stack1;
                            message = 'Error: ' + reason.message + '\n' + ((_reason_stack1 = reason.stack) != null ? _reason_stack1 : '');
                        } else {
                            message = 'Unexpected Exception: ' + reason;
                        }
                        console.warn('[HMR] ' + message);
                    }
                } else {
                    _nextdevtools.dispatcher.onStaticIndicator(false);
                }
            }
        }, [
            pathname
        ]);
    }
    (0, _react.useEffect)(()=>{
        const websocket = webSocketRef.current;
        if (!websocket) return;
        const handler = (event)=>{
            try {
                const obj = JSON.parse(event.data);
                processMessage(obj, sendMessage, processTurbopackMessage, router, appIsrManifestRef, pathnameRef);
            } catch (err) {
                (0, _shared.reportInvalidHmrMessage)(event, err);
            }
        };
        websocket.addEventListener('message', handler);
        return ()=>websocket.removeEventListener('message', handler);
    }, [
        sendMessage,
        router,
        webSocketRef,
        processTurbopackMessage,
        appIsrManifestRef
    ]);
    return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_appdevoverlayerrorboundary.AppDevOverlayErrorBoundary, {
        globalError: globalError,
        children: [
            /*#__PURE__*/ (0, _jsxruntime.jsx)(_replayssronlyerrors.ReplaySsrOnlyErrors, {
                onBlockingError: _nextdevtools.dispatcher.openErrorOverlay
            }),
            children
        ]
    });
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=hot-reloader-app.js.map
}}),
"[project]/node_modules/next/dist/client/components/app-router.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    createEmptyCacheNode: null,
    createPrefetchURL: null,
    default: null,
    isExternalURL: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    createEmptyCacheNode: function() {
        return createEmptyCacheNode;
    },
    createPrefetchURL: function() {
        return createPrefetchURL;
    },
    default: function() {
        return AppRouter;
    },
    isExternalURL: function() {
        return isExternalURL;
    }
});
const _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-ssr] (ecmascript)");
const _interop_require_wildcard = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [app-ssr] (ecmascript)");
const _jsxruntime = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js [app-ssr] (ecmascript)");
const _react = /*#__PURE__*/ _interop_require_wildcard._(__turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)"));
const _approutercontextsharedruntime = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/contexts/app-router-context.js [app-ssr] (ecmascript)");
const _routerreducertypes = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/router-reducer-types.js [app-ssr] (ecmascript)");
const _createhreffromurl = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/create-href-from-url.js [app-ssr] (ecmascript)");
const _hooksclientcontextsharedruntime = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/contexts/hooks-client-context.js [app-ssr] (ecmascript)");
const _useactionqueue = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/use-action-queue.js [app-ssr] (ecmascript)");
const _errorboundary = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/error-boundary.js [app-ssr] (ecmascript)");
const _globalerror = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/client/components/builtin/global-error.js [app-ssr] (ecmascript)"));
const _isbot = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/is-bot.js [app-ssr] (ecmascript)");
const _addbasepath = __turbopack_context__.r("[project]/node_modules/next/dist/client/add-base-path.js [app-ssr] (ecmascript)");
const _approuterannouncer = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/app-router-announcer.js [app-ssr] (ecmascript)");
const _redirectboundary = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/redirect-boundary.js [app-ssr] (ecmascript)");
const _findheadincache = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/reducers/find-head-in-cache.js [app-ssr] (ecmascript)");
const _unresolvedthenable = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/unresolved-thenable.js [app-ssr] (ecmascript)");
const _removebasepath = __turbopack_context__.r("[project]/node_modules/next/dist/client/remove-base-path.js [app-ssr] (ecmascript)");
const _hasbasepath = __turbopack_context__.r("[project]/node_modules/next/dist/client/has-base-path.js [app-ssr] (ecmascript)");
const _computechangedpath = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/compute-changed-path.js [app-ssr] (ecmascript)");
const _navfailurehandler = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/nav-failure-handler.js [app-ssr] (ecmascript)");
const _approuterinstance = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/app-router-instance.js [app-ssr] (ecmascript)");
const _redirect = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/redirect.js [app-ssr] (ecmascript)");
const _redirecterror = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/redirect-error.js [app-ssr] (ecmascript)");
const _links = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/links.js [app-ssr] (ecmascript)");
const _gracefuldegradeboundary = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/client/components/errors/graceful-degrade-boundary.js [app-ssr] (ecmascript)"));
const globalMutable = {};
function isExternalURL(url) {
    return url.origin !== window.location.origin;
}
function createPrefetchURL(href) {
    // Don't prefetch for bots as they don't navigate.
    if ((0, _isbot.isBot)(window.navigator.userAgent)) {
        return null;
    }
    let url;
    try {
        url = new URL((0, _addbasepath.addBasePath)(href), window.location.href);
    } catch (_) {
        // TODO: Does this need to throw or can we just console.error instead? Does
        // anyone rely on this throwing? (Seems unlikely.)
        throw Object.defineProperty(new Error("Cannot prefetch '" + href + "' because it cannot be converted to a URL."), "__NEXT_ERROR_CODE", {
            value: "E234",
            enumerable: false,
            configurable: true
        });
    }
    // Don't prefetch during development (improves compilation performance)
    if ("TURBOPACK compile-time truthy", 1) {
        return null;
    }
    //TURBOPACK unreachable
    ;
}
function HistoryUpdater(param) {
    let { appRouterState } = param;
    (0, _react.useInsertionEffect)(()=>{
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        const { tree, pushRef, canonicalUrl } = appRouterState;
        const historyState = {
            ...pushRef.preserveCustomHistoryState ? window.history.state : {},
            // Identifier is shortened intentionally.
            // __NA is used to identify if the history entry can be handled by the app-router.
            // __N is used to identify if the history entry can be handled by the old router.
            __NA: true,
            __PRIVATE_NEXTJS_INTERNALS_TREE: tree
        };
        if (pushRef.pendingPush && // Skip pushing an additional history entry if the canonicalUrl is the same as the current url.
        // This mirrors the browser behavior for normal navigation.
        (0, _createhreffromurl.createHrefFromUrl)(new URL(window.location.href)) !== canonicalUrl) {
            // This intentionally mutates React state, pushRef is overwritten to ensure additional push/replace calls do not trigger an additional history entry.
            pushRef.pendingPush = false;
            window.history.pushState(historyState, '', canonicalUrl);
        } else {
            window.history.replaceState(historyState, '', canonicalUrl);
        }
    }, [
        appRouterState
    ]);
    (0, _react.useEffect)(()=>{
        // The Next-Url and the base tree may affect the result of a prefetch
        // task. Re-prefetch all visible links with the updated values. In most
        // cases, this will not result in any new network requests, only if
        // the prefetch result actually varies on one of these inputs.
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
    }, [
        appRouterState.nextUrl,
        appRouterState.tree
    ]);
    return null;
}
function createEmptyCacheNode() {
    return {
        lazyData: null,
        rsc: null,
        prefetchRsc: null,
        head: null,
        prefetchHead: null,
        parallelRoutes: new Map(),
        loading: null,
        navigatedAt: -1
    };
}
function copyNextJsInternalHistoryState(data) {
    if (data == null) data = {};
    const currentState = window.history.state;
    const __NA = currentState == null ? void 0 : currentState.__NA;
    if (__NA) {
        data.__NA = __NA;
    }
    const __PRIVATE_NEXTJS_INTERNALS_TREE = currentState == null ? void 0 : currentState.__PRIVATE_NEXTJS_INTERNALS_TREE;
    if (__PRIVATE_NEXTJS_INTERNALS_TREE) {
        data.__PRIVATE_NEXTJS_INTERNALS_TREE = __PRIVATE_NEXTJS_INTERNALS_TREE;
    }
    return data;
}
function Head(param) {
    let { headCacheNode } = param;
    // If this segment has a `prefetchHead`, it's the statically prefetched data.
    // We should use that on initial render instead of `head`. Then we'll switch
    // to `head` when the dynamic response streams in.
    const head = headCacheNode !== null ? headCacheNode.head : null;
    const prefetchHead = headCacheNode !== null ? headCacheNode.prefetchHead : null;
    // If no prefetch data is available, then we go straight to rendering `head`.
    const resolvedPrefetchRsc = prefetchHead !== null ? prefetchHead : head;
    // We use `useDeferredValue` to handle switching between the prefetched and
    // final values. The second argument is returned on initial render, then it
    // re-renders with the first argument.
    return (0, _react.useDeferredValue)(head, resolvedPrefetchRsc);
}
/**
 * The global router that wraps the application components.
 */ function Router(param) {
    let { actionQueue, assetPrefix, globalError, gracefullyDegrade } = param;
    const state = (0, _useactionqueue.useActionQueue)(actionQueue);
    const { canonicalUrl } = state;
    // Add memoized pathname/query for useSearchParams and usePathname.
    const { searchParams, pathname } = (0, _react.useMemo)(()=>{
        const url = new URL(canonicalUrl, ("TURBOPACK compile-time truthy", 1) ? 'http://n' : "TURBOPACK unreachable");
        return {
            // This is turned into a readonly class in `useSearchParams`
            searchParams: url.searchParams,
            pathname: (0, _hasbasepath.hasBasePath)(url.pathname) ? (0, _removebasepath.removeBasePath)(url.pathname) : url.pathname
        };
    }, [
        canonicalUrl
    ]);
    if ("TURBOPACK compile-time truthy", 1) {
        // eslint-disable-next-line react-hooks/rules-of-hooks
        const { cache, prefetchCache, tree } = state;
        // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes
        // eslint-disable-next-line react-hooks/rules-of-hooks
        (0, _react.useEffect)(()=>{
            // Add `window.nd` for debugging purposes.
            // This is not meant for use in applications as concurrent rendering will affect the cache/tree/router.
            // @ts-ignore this is for debugging
            window.nd = {
                router: _approuterinstance.publicAppRouterInstance,
                cache,
                prefetchCache,
                tree
            };
        }, [
            cache,
            prefetchCache,
            tree
        ]);
    }
    (0, _react.useEffect)(()=>{
        // If the app is restored from bfcache, it's possible that
        // pushRef.mpaNavigation is true, which would mean that any re-render of this component
        // would trigger the mpa navigation logic again from the lines below.
        // This will restore the router to the initial state in the event that the app is restored from bfcache.
        function handlePageShow(event) {
            var _window_history_state;
            if (!event.persisted || !((_window_history_state = window.history.state) == null ? void 0 : _window_history_state.__PRIVATE_NEXTJS_INTERNALS_TREE)) {
                return;
            }
            // Clear the pendingMpaPath value so that a subsequent MPA navigation to the same URL can be triggered.
            // This is necessary because if the browser restored from bfcache, the pendingMpaPath would still be set to the value
            // of the last MPA navigation.
            globalMutable.pendingMpaPath = undefined;
            (0, _useactionqueue.dispatchAppRouterAction)({
                type: _routerreducertypes.ACTION_RESTORE,
                url: new URL(window.location.href),
                tree: window.history.state.__PRIVATE_NEXTJS_INTERNALS_TREE
            });
        }
        window.addEventListener('pageshow', handlePageShow);
        return ()=>{
            window.removeEventListener('pageshow', handlePageShow);
        };
    }, []);
    (0, _react.useEffect)(()=>{
        // Ensure that any redirect errors that bubble up outside of the RedirectBoundary
        // are caught and handled by the router.
        function handleUnhandledRedirect(event) {
            const error = 'reason' in event ? event.reason : event.error;
            if ((0, _redirecterror.isRedirectError)(error)) {
                event.preventDefault();
                const url = (0, _redirect.getURLFromRedirectError)(error);
                const redirectType = (0, _redirect.getRedirectTypeFromError)(error);
                // TODO: This should access the router methods directly, rather than
                // go through the public interface.
                if (redirectType === _redirecterror.RedirectType.push) {
                    _approuterinstance.publicAppRouterInstance.push(url, {});
                } else {
                    _approuterinstance.publicAppRouterInstance.replace(url, {});
                }
            }
        }
        window.addEventListener('error', handleUnhandledRedirect);
        window.addEventListener('unhandledrejection', handleUnhandledRedirect);
        return ()=>{
            window.removeEventListener('error', handleUnhandledRedirect);
            window.removeEventListener('unhandledrejection', handleUnhandledRedirect);
        };
    }, []);
    // When mpaNavigation flag is set do a hard navigation to the new url.
    // Infinitely suspend because we don't actually want to rerender any child
    // components with the new URL and any entangled state updates shouldn't
    // commit either (eg: useTransition isPending should stay true until the page
    // unloads).
    //
    // This is a side effect in render. Don't try this at home, kids. It's
    // probably safe because we know this is a singleton component and it's never
    // in <Offscreen>. At least I hope so. (It will run twice in dev strict mode,
    // but that's... fine?)
    const { pushRef } = state;
    if (pushRef.mpaNavigation) {
        // if there's a re-render, we don't want to trigger another redirect if one is already in flight to the same URL
        if (globalMutable.pendingMpaPath !== canonicalUrl) {
            const location = window.location;
            if (pushRef.pendingPush) {
                location.assign(canonicalUrl);
            } else {
                location.replace(canonicalUrl);
            }
            globalMutable.pendingMpaPath = canonicalUrl;
        }
        // TODO-APP: Should we listen to navigateerror here to catch failed
        // navigations somehow? And should we call window.stop() if a SPA navigation
        // should interrupt an MPA one?
        // NOTE: This is intentionally using `throw` instead of `use` because we're
        // inside an externally mutable condition (pushRef.mpaNavigation), which
        // violates the rules of hooks.
        throw _unresolvedthenable.unresolvedThenable;
    }
    (0, _react.useEffect)(()=>{
        const originalPushState = window.history.pushState.bind(window.history);
        const originalReplaceState = window.history.replaceState.bind(window.history);
        // Ensure the canonical URL in the Next.js Router is updated when the URL is changed so that `usePathname` and `useSearchParams` hold the pushed values.
        const applyUrlFromHistoryPushReplace = (url)=>{
            var _window_history_state;
            const href = window.location.href;
            const tree = (_window_history_state = window.history.state) == null ? void 0 : _window_history_state.__PRIVATE_NEXTJS_INTERNALS_TREE;
            (0, _react.startTransition)(()=>{
                (0, _useactionqueue.dispatchAppRouterAction)({
                    type: _routerreducertypes.ACTION_RESTORE,
                    url: new URL(url != null ? url : href, href),
                    tree
                });
            });
        };
        /**
     * Patch pushState to ensure external changes to the history are reflected in the Next.js Router.
     * Ensures Next.js internal history state is copied to the new history entry.
     * Ensures usePathname and useSearchParams hold the newly provided url.
     */ window.history.pushState = function pushState(data, _unused, url) {
            // Avoid a loop when Next.js internals trigger pushState/replaceState
            if ((data == null ? void 0 : data.__NA) || (data == null ? void 0 : data._N)) {
                return originalPushState(data, _unused, url);
            }
            data = copyNextJsInternalHistoryState(data);
            if (url) {
                applyUrlFromHistoryPushReplace(url);
            }
            return originalPushState(data, _unused, url);
        };
        /**
     * Patch replaceState to ensure external changes to the history are reflected in the Next.js Router.
     * Ensures Next.js internal history state is copied to the new history entry.
     * Ensures usePathname and useSearchParams hold the newly provided url.
     */ window.history.replaceState = function replaceState(data, _unused, url) {
            // Avoid a loop when Next.js internals trigger pushState/replaceState
            if ((data == null ? void 0 : data.__NA) || (data == null ? void 0 : data._N)) {
                return originalReplaceState(data, _unused, url);
            }
            data = copyNextJsInternalHistoryState(data);
            if (url) {
                applyUrlFromHistoryPushReplace(url);
            }
            return originalReplaceState(data, _unused, url);
        };
        /**
     * Handle popstate event, this is used to handle back/forward in the browser.
     * By default dispatches ACTION_RESTORE, however if the history entry was not pushed/replaced by app-router it will reload the page.
     * That case can happen when the old router injected the history entry.
     */ const onPopState = (event)=>{
            if (!event.state) {
                // TODO-APP: this case only happens when pushState/replaceState was called outside of Next.js. It should probably reload the page in this case.
                return;
            }
            // This case happens when the history entry was pushed by the `pages` router.
            if (!event.state.__NA) {
                window.location.reload();
                return;
            }
            // TODO-APP: Ideally the back button should not use startTransition as it should apply the updates synchronously
            // Without startTransition works if the cache is there for this path
            (0, _react.startTransition)(()=>{
                (0, _approuterinstance.dispatchTraverseAction)(window.location.href, event.state.__PRIVATE_NEXTJS_INTERNALS_TREE);
            });
        };
        // Register popstate event to call onPopstate.
        window.addEventListener('popstate', onPopState);
        return ()=>{
            window.history.pushState = originalPushState;
            window.history.replaceState = originalReplaceState;
            window.removeEventListener('popstate', onPopState);
        };
    }, []);
    const { cache, tree, nextUrl, focusAndScrollRef } = state;
    const matchingHead = (0, _react.useMemo)(()=>{
        return (0, _findheadincache.findHeadInCache)(cache, tree[1]);
    }, [
        cache,
        tree
    ]);
    // Add memoized pathParams for useParams.
    const pathParams = (0, _react.useMemo)(()=>{
        return (0, _computechangedpath.getSelectedParams)(tree);
    }, [
        tree
    ]);
    const layoutRouterContext = (0, _react.useMemo)(()=>{
        return {
            parentTree: tree,
            parentCacheNode: cache,
            parentSegmentPath: null,
            // Root node always has `url`
            // Provided in AppTreeContext to ensure it can be overwritten in layout-router
            url: canonicalUrl
        };
    }, [
        tree,
        cache,
        canonicalUrl
    ]);
    const globalLayoutRouterContext = (0, _react.useMemo)(()=>{
        return {
            tree,
            focusAndScrollRef,
            nextUrl
        };
    }, [
        tree,
        focusAndScrollRef,
        nextUrl
    ]);
    let head;
    if (matchingHead !== null) {
        // The head is wrapped in an extra component so we can use
        // `useDeferredValue` to swap between the prefetched and final versions of
        // the head. (This is what LayoutRouter does for segment data, too.)
        //
        // The `key` is used to remount the component whenever the head moves to
        // a different segment.
        const [headCacheNode, headKey] = matchingHead;
        head = /*#__PURE__*/ (0, _jsxruntime.jsx)(Head, {
            headCacheNode: headCacheNode
        }, headKey);
    } else {
        head = null;
    }
    let content = /*#__PURE__*/ (0, _jsxruntime.jsxs)(_redirectboundary.RedirectBoundary, {
        children: [
            head,
            cache.rsc,
            /*#__PURE__*/ (0, _jsxruntime.jsx)(_approuterannouncer.AppRouterAnnouncer, {
                tree: tree
            })
        ]
    });
    if ("TURBOPACK compile-time truthy", 1) {
        // In development, we apply few error boundaries and hot-reloader:
        // - DevRootHTTPAccessFallbackBoundary: avoid using navigation API like notFound() in root layout
        // - HotReloader:
        //  - hot-reload the app when the code changes
        //  - render dev overlay
        //  - catch runtime errors and display global-error when necessary
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        const HotReloader = __turbopack_context__.r("[project]/node_modules/next/dist/client/dev/hot-reloader/app/hot-reloader-app.js [app-ssr] (ecmascript)").default;
        content = /*#__PURE__*/ (0, _jsxruntime.jsx)(HotReloader, {
            assetPrefix: assetPrefix,
            globalError: globalError,
            children: content
        });
    } else //TURBOPACK unreachable
    ;
    return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
        children: [
            /*#__PURE__*/ (0, _jsxruntime.jsx)(HistoryUpdater, {
                appRouterState: state
            }),
            /*#__PURE__*/ (0, _jsxruntime.jsx)(RuntimeStyles, {}),
            /*#__PURE__*/ (0, _jsxruntime.jsx)(_hooksclientcontextsharedruntime.PathParamsContext.Provider, {
                value: pathParams,
                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_hooksclientcontextsharedruntime.PathnameContext.Provider, {
                    value: pathname,
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_hooksclientcontextsharedruntime.SearchParamsContext.Provider, {
                        value: searchParams,
                        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_approutercontextsharedruntime.GlobalLayoutRouterContext.Provider, {
                            value: globalLayoutRouterContext,
                            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_approutercontextsharedruntime.AppRouterContext.Provider, {
                                value: _approuterinstance.publicAppRouterInstance,
                                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_approutercontextsharedruntime.LayoutRouterContext.Provider, {
                                    value: layoutRouterContext,
                                    children: content
                                })
                            })
                        })
                    })
                })
            })
        ]
    });
}
function AppRouter(param) {
    let { actionQueue, globalErrorState, assetPrefix, gracefullyDegrade } = param;
    (0, _navfailurehandler.useNavFailureHandler)();
    const router = /*#__PURE__*/ (0, _jsxruntime.jsx)(Router, {
        actionQueue: actionQueue,
        assetPrefix: assetPrefix,
        globalError: globalErrorState,
        gracefullyDegrade: gracefullyDegrade
    });
    if (gracefullyDegrade) {
        return router;
    } else {
        return /*#__PURE__*/ (0, _jsxruntime.jsx)(_errorboundary.ErrorBoundary, {
            // At the very top level, use the default GlobalError component as the final fallback.
            // When the app router itself fails, which means the framework itself fails, we show the default error.
            errorComponent: _globalerror.default,
            children: router
        });
    }
}
const runtimeStyles = new Set();
let runtimeStyleChanged = new Set();
globalThis._N_E_STYLE_LOAD = function(href) {
    let len = runtimeStyles.size;
    runtimeStyles.add(href);
    if (runtimeStyles.size !== len) {
        runtimeStyleChanged.forEach((cb)=>cb());
    }
    // TODO figure out how to get a promise here
    // But maybe it's not necessary as react would block rendering until it's loaded
    return Promise.resolve();
};
function RuntimeStyles() {
    const [, forceUpdate] = _react.default.useState(0);
    const renderedStylesSize = runtimeStyles.size;
    (0, _react.useEffect)(()=>{
        const changed = ()=>forceUpdate((c)=>c + 1);
        runtimeStyleChanged.add(changed);
        if (renderedStylesSize !== runtimeStyles.size) {
            changed();
        }
        return ()=>{
            runtimeStyleChanged.delete(changed);
        };
    }, [
        renderedStylesSize,
        forceUpdate
    ]);
    const dplId = ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : '';
    return [
        ...runtimeStyles
    ].map((href, i)=>/*#__PURE__*/ (0, _jsxruntime.jsx)("link", {
            rel: "stylesheet",
            href: "" + href + dplId,
            // @ts-ignore
            precedence: "next"
        }, i));
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=app-router.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/ppr-navigations.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    abortTask: null,
    listenForDynamicRequest: null,
    startPPRNavigation: null,
    updateCacheNodeOnPopstateRestoration: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    abortTask: function() {
        return abortTask;
    },
    listenForDynamicRequest: function() {
        return listenForDynamicRequest;
    },
    startPPRNavigation: function() {
        return startPPRNavigation;
    },
    updateCacheNodeOnPopstateRestoration: function() {
        return updateCacheNodeOnPopstateRestoration;
    }
});
const _segment = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/segment.js [app-ssr] (ecmascript)");
const _matchsegments = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/match-segments.js [app-ssr] (ecmascript)");
const _createroutercachekey = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js [app-ssr] (ecmascript)");
const _isnavigatingtonewrootlayout = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js [app-ssr] (ecmascript)");
const _prefetchcacheutils = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js [app-ssr] (ecmascript)");
const MPA_NAVIGATION_TASK = {
    route: null,
    node: null,
    dynamicRequestTree: null,
    children: null
};
function startPPRNavigation(navigatedAt, oldCacheNode, oldRouterState, newRouterState, prefetchData, prefetchHead, isPrefetchHeadPartial, isSamePageNavigation, scrollableSegmentsResult) {
    const segmentPath = [];
    return updateCacheNodeOnNavigation(navigatedAt, oldCacheNode, oldRouterState, newRouterState, false, prefetchData, prefetchHead, isPrefetchHeadPartial, isSamePageNavigation, segmentPath, scrollableSegmentsResult);
}
function updateCacheNodeOnNavigation(navigatedAt, oldCacheNode, oldRouterState, newRouterState, didFindRootLayout, prefetchData, prefetchHead, isPrefetchHeadPartial, isSamePageNavigation, segmentPath, scrollableSegmentsResult) {
    // Diff the old and new trees to reuse the shared layouts.
    const oldRouterStateChildren = oldRouterState[1];
    const newRouterStateChildren = newRouterState[1];
    const prefetchDataChildren = prefetchData !== null ? prefetchData[2] : null;
    if (!didFindRootLayout) {
        // We're currently traversing the part of the tree that was also part of
        // the previous route. If we discover a root layout, then we don't need to
        // trigger an MPA navigation. See beginRenderingNewRouteTree for context.
        const isRootLayout = newRouterState[4] === true;
        if (isRootLayout) {
            // Found a matching root layout.
            didFindRootLayout = true;
        }
    }
    const oldParallelRoutes = oldCacheNode.parallelRoutes;
    // Clone the current set of segment children, even if they aren't active in
    // the new tree.
    // TODO: We currently retain all the inactive segments indefinitely, until
    // there's an explicit refresh, or a parent layout is lazily refreshed. We
    // rely on this for popstate navigations, which update the Router State Tree
    // but do not eagerly perform a data fetch, because they expect the segment
    // data to already be in the Cache Node tree. For highly static sites that
    // are mostly read-only, this may happen only rarely, causing memory to
    // leak. We should figure out a better model for the lifetime of inactive
    // segments, so we can maintain instant back/forward navigations without
    // leaking memory indefinitely.
    const prefetchParallelRoutes = new Map(oldParallelRoutes);
    // As we diff the trees, we may sometimes modify (copy-on-write, not mutate)
    // the Route Tree that was returned by the server  for example, in the case
    // of default parallel routes, we preserve the currently active segment. To
    // avoid mutating the original tree, we clone the router state children along
    // the return path.
    let patchedRouterStateChildren = {};
    let taskChildren = null;
    // Most navigations require a request to fetch additional data from the
    // server, either because the data was not already prefetched, or because the
    // target route contains dynamic data that cannot be prefetched.
    //
    // However, if the target route is fully static, and it's already completely
    // loaded into the segment cache, then we can skip the server request.
    //
    // This starts off as `false`, and is set to `true` if any of the child
    // routes requires a dynamic request.
    let needsDynamicRequest = false;
    // As we traverse the children, we'll construct a FlightRouterState that can
    // be sent to the server to request the dynamic data. If it turns out that
    // nothing in the subtree is dynamic (i.e. needsDynamicRequest is false at the
    // end), then this will be discarded.
    // TODO: We can probably optimize the format of this data structure to only
    // include paths that are dynamic. Instead of reusing the
    // FlightRouterState type.
    let dynamicRequestTreeChildren = {};
    for(let parallelRouteKey in newRouterStateChildren){
        const newRouterStateChild = newRouterStateChildren[parallelRouteKey];
        const oldRouterStateChild = oldRouterStateChildren[parallelRouteKey];
        const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey);
        const prefetchDataChild = prefetchDataChildren !== null ? prefetchDataChildren[parallelRouteKey] : null;
        const newSegmentChild = newRouterStateChild[0];
        const newSegmentPathChild = segmentPath.concat([
            parallelRouteKey,
            newSegmentChild
        ]);
        const newSegmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(newSegmentChild);
        const oldSegmentChild = oldRouterStateChild !== undefined ? oldRouterStateChild[0] : undefined;
        const oldCacheNodeChild = oldSegmentMapChild !== undefined ? oldSegmentMapChild.get(newSegmentKeyChild) : undefined;
        let taskChild;
        if (newSegmentChild === _segment.DEFAULT_SEGMENT_KEY) {
            // This is another kind of leaf segment  a default route.
            //
            // Default routes have special behavior. When there's no matching segment
            // for a parallel route, Next.js preserves the currently active segment
            // during a client navigation  but not for initial render. The server
            // leaves it to the client to account for this. So we need to handle
            // it here.
            if (oldRouterStateChild !== undefined) {
                // Reuse the existing Router State for this segment. We spawn a "task"
                // just to keep track of the updated router state; unlike most, it's
                // already fulfilled and won't be affected by the dynamic response.
                taskChild = spawnReusedTask(oldRouterStateChild);
            } else {
                // There's no currently active segment. Switch to the "create" path.
                taskChild = beginRenderingNewRouteTree(navigatedAt, oldRouterStateChild, newRouterStateChild, oldCacheNodeChild, didFindRootLayout, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead, isPrefetchHeadPartial, newSegmentPathChild, scrollableSegmentsResult);
            }
        } else if (isSamePageNavigation && // Check if this is a page segment.
        // TODO: We're not consistent about how we do this check. Some places
        // check if the segment starts with PAGE_SEGMENT_KEY, but most seem to
        // check if there any any children, which is why I'm doing it here. We
        // should probably encode an empty children set as `null` though. Either
        // way, we should update all the checks to be consistent.
        Object.keys(newRouterStateChild[1]).length === 0) {
            // We special case navigations to the exact same URL as the current
            // location. It's a common UI pattern for apps to refresh when you click a
            // link to the current page. So when this happens, we refresh the dynamic
            // data in the page segments.
            //
            // Note that this does not apply if the any part of the hash or search
            // query has changed. This might feel a bit weird but it makes more sense
            // when you consider that the way to trigger this behavior is to click
            // the same link multiple times.
            //
            // TODO: We should probably refresh the *entire* route when this case
            // occurs, not just the page segments. Essentially treating it the same as
            // a refresh() triggered by an action, which is the more explicit way of
            // modeling the UI pattern described above.
            //
            // Also note that this only refreshes the dynamic data, not static/
            // cached data. If the page segment is fully static and prefetched, the
            // request is skipped. (This is also how refresh() works.)
            taskChild = beginRenderingNewRouteTree(navigatedAt, oldRouterStateChild, newRouterStateChild, oldCacheNodeChild, didFindRootLayout, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead, isPrefetchHeadPartial, newSegmentPathChild, scrollableSegmentsResult);
        } else if (oldRouterStateChild !== undefined && oldSegmentChild !== undefined && (0, _matchsegments.matchSegment)(newSegmentChild, oldSegmentChild)) {
            if (oldCacheNodeChild !== undefined && oldRouterStateChild !== undefined) {
                // This segment exists in both the old and new trees. Recursively update
                // the children.
                taskChild = updateCacheNodeOnNavigation(navigatedAt, oldCacheNodeChild, oldRouterStateChild, newRouterStateChild, didFindRootLayout, prefetchDataChild, prefetchHead, isPrefetchHeadPartial, isSamePageNavigation, newSegmentPathChild, scrollableSegmentsResult);
            } else {
                // There's no existing Cache Node for this segment. Switch to the
                // "create" path.
                taskChild = beginRenderingNewRouteTree(navigatedAt, oldRouterStateChild, newRouterStateChild, oldCacheNodeChild, didFindRootLayout, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead, isPrefetchHeadPartial, newSegmentPathChild, scrollableSegmentsResult);
            }
        } else {
            // This is a new tree. Switch to the "create" path.
            taskChild = beginRenderingNewRouteTree(navigatedAt, oldRouterStateChild, newRouterStateChild, oldCacheNodeChild, didFindRootLayout, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead, isPrefetchHeadPartial, newSegmentPathChild, scrollableSegmentsResult);
        }
        if (taskChild !== null) {
            // Recursively propagate up the child tasks.
            if (taskChild.route === null) {
                // One of the child tasks discovered a change to the root layout.
                // Immediately unwind from this recursive traversal.
                return MPA_NAVIGATION_TASK;
            }
            if (taskChildren === null) {
                taskChildren = new Map();
            }
            taskChildren.set(parallelRouteKey, taskChild);
            const newCacheNodeChild = taskChild.node;
            if (newCacheNodeChild !== null) {
                const newSegmentMapChild = new Map(oldSegmentMapChild);
                newSegmentMapChild.set(newSegmentKeyChild, newCacheNodeChild);
                prefetchParallelRoutes.set(parallelRouteKey, newSegmentMapChild);
            }
            // The child tree's route state may be different from the prefetched
            // route sent by the server. We need to clone it as we traverse back up
            // the tree.
            const taskChildRoute = taskChild.route;
            patchedRouterStateChildren[parallelRouteKey] = taskChildRoute;
            const dynamicRequestTreeChild = taskChild.dynamicRequestTree;
            if (dynamicRequestTreeChild !== null) {
                // Something in the child tree is dynamic.
                needsDynamicRequest = true;
                dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild;
            } else {
                dynamicRequestTreeChildren[parallelRouteKey] = taskChildRoute;
            }
        } else {
            // The child didn't change. We can use the prefetched router state.
            patchedRouterStateChildren[parallelRouteKey] = newRouterStateChild;
            dynamicRequestTreeChildren[parallelRouteKey] = newRouterStateChild;
        }
    }
    if (taskChildren === null) {
        // No new tasks were spawned.
        return null;
    }
    const newCacheNode = {
        lazyData: null,
        rsc: oldCacheNode.rsc,
        // We intentionally aren't updating the prefetchRsc field, since this node
        // is already part of the current tree, because it would be weird for
        // prefetch data to be newer than the final data. It probably won't ever be
        // observable anyway, but it could happen if the segment is unmounted then
        // mounted again, because LayoutRouter will momentarily switch to rendering
        // prefetchRsc, via useDeferredValue.
        prefetchRsc: oldCacheNode.prefetchRsc,
        head: oldCacheNode.head,
        prefetchHead: oldCacheNode.prefetchHead,
        loading: oldCacheNode.loading,
        // Everything is cloned except for the children, which we computed above.
        parallelRoutes: prefetchParallelRoutes,
        navigatedAt
    };
    return {
        // Return a cloned copy of the router state with updated children.
        route: patchRouterStateWithNewChildren(newRouterState, patchedRouterStateChildren),
        node: newCacheNode,
        dynamicRequestTree: needsDynamicRequest ? patchRouterStateWithNewChildren(newRouterState, dynamicRequestTreeChildren) : null,
        children: taskChildren
    };
}
function beginRenderingNewRouteTree(navigatedAt, oldRouterState, newRouterState, existingCacheNode, didFindRootLayout, prefetchData, possiblyPartialPrefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult) {
    if (!didFindRootLayout) {
        // The route tree changed before we reached a layout. (The highest-level
        // layout in a route tree is referred to as the "root" layout.) This could
        // mean that we're navigating between two different root layouts. When this
        // happens, we perform a full-page (MPA-style) navigation.
        //
        // However, the algorithm for deciding where to start rendering a route
        // (i.e. the one performed in order to reach this function) is stricter
        // than the one used to detect a change in the root layout. So just because
        // we're re-rendering a segment outside of the root layout does not mean we
        // should trigger a full-page navigation.
        //
        // Specifically, we handle dynamic parameters differently: two segments are
        // considered the same even if their parameter values are different.
        //
        // Refer to isNavigatingToNewRootLayout for details.
        //
        // Note that we only have to perform this extra traversal if we didn't
        // already discover a root layout in the part of the tree that is unchanged.
        // In the common case, this branch is skipped completely.
        if (oldRouterState === undefined || (0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(oldRouterState, newRouterState)) {
            // The root layout changed. Perform a full-page navigation.
            return MPA_NAVIGATION_TASK;
        }
    }
    return createCacheNodeOnNavigation(navigatedAt, newRouterState, existingCacheNode, prefetchData, possiblyPartialPrefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult);
}
function createCacheNodeOnNavigation(navigatedAt, routerState, existingCacheNode, prefetchData, possiblyPartialPrefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult) {
    // Same traversal as updateCacheNodeNavigation, but we switch to this path
    // once we reach the part of the tree that was not in the previous route. We
    // don't need to diff against the old tree, we just need to create a new one.
    // The head is assigned to every leaf segment delivered by the server. Based
    // on corresponding logic in fill-lazy-items-till-leaf-with-head.ts
    const routerStateChildren = routerState[1];
    const isLeafSegment = Object.keys(routerStateChildren).length === 0;
    // Even we're rendering inside the "new" part of the target tree, we may have
    // a locally cached segment that we can reuse. This may come from either 1)
    // the CacheNode tree, which lives in React state and is populated by previous
    // navigations; or 2) the prefetch cache, which is a separate cache that is
    // populated by prefetches.
    let rsc;
    let loading;
    let head;
    let cacheNodeNavigatedAt;
    if (existingCacheNode !== undefined && // DYNAMIC_STALETIME_MS defaults to 0, but it can be increased using
    // the experimental.staleTimes.dynamic config. When set, we'll avoid
    // refetching dynamic data if it was fetched within the given threshold.
    existingCacheNode.navigatedAt + _prefetchcacheutils.DYNAMIC_STALETIME_MS > navigatedAt) {
        // We have an existing CacheNode for this segment, and it's not stale. We
        // should reuse it rather than request a new one.
        rsc = existingCacheNode.rsc;
        loading = existingCacheNode.loading;
        head = existingCacheNode.head;
        // Don't update the navigatedAt timestamp, since we're reusing stale data.
        cacheNodeNavigatedAt = existingCacheNode.navigatedAt;
    } else if (prefetchData !== null) {
        // There's no existing CacheNode for this segment, but we do have prefetch
        // data. If the prefetch data is fully static (i.e. does not contain any
        // dynamic holes), we don't need to request it from the server.
        rsc = prefetchData[1];
        loading = prefetchData[3];
        head = isLeafSegment ? possiblyPartialPrefetchHead : null;
        // Even though we're accessing the data from the prefetch cache, this is
        // conceptually a new segment, not a reused one. So we should update the
        // navigatedAt timestamp.
        cacheNodeNavigatedAt = navigatedAt;
        const isPrefetchRscPartial = prefetchData[4];
        if (isPrefetchRscPartial || // Check if the head is partial (only relevant if this is a leaf segment)
        isPrefetchHeadPartial && isLeafSegment) {
            // We only have partial data from this segment. Like missing segments, we
            // must request the full data from the server.
            return spawnPendingTask(navigatedAt, routerState, prefetchData, possiblyPartialPrefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult);
        } else {
        // The prefetch data is fully static, so we can omit it from the
        // navigation request.
        }
    } else {
        // There's no prefetch for this segment. Everything from this point will be
        // requested from the server, even if there are static children below it.
        // Create a terminal task node that will later be fulfilled by
        // server response.
        return spawnPendingTask(navigatedAt, routerState, null, possiblyPartialPrefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult);
    }
    // We already have a full segment we can render, so we don't need to request a
    // new one from the server. Keep traversing down the tree until we reach
    // something that requires a dynamic request.
    const prefetchDataChildren = prefetchData !== null ? prefetchData[2] : null;
    const taskChildren = new Map();
    const existingCacheNodeChildren = existingCacheNode !== undefined ? existingCacheNode.parallelRoutes : null;
    const cacheNodeChildren = new Map(existingCacheNodeChildren);
    let dynamicRequestTreeChildren = {};
    let needsDynamicRequest = false;
    if (isLeafSegment) {
        // The segment path of every leaf segment (i.e. page) is collected into
        // a result array. This is used by the LayoutRouter to scroll to ensure that
        // new pages are visible after a navigation.
        // TODO: We should use a string to represent the segment path instead of
        // an array. We already use a string representation for the path when
        // accessing the Segment Cache, so we can use the same one.
        scrollableSegmentsResult.push(segmentPath);
    } else {
        for(let parallelRouteKey in routerStateChildren){
            const routerStateChild = routerStateChildren[parallelRouteKey];
            const prefetchDataChild = prefetchDataChildren !== null ? prefetchDataChildren[parallelRouteKey] : null;
            const existingSegmentMapChild = existingCacheNodeChildren !== null ? existingCacheNodeChildren.get(parallelRouteKey) : undefined;
            const segmentChild = routerStateChild[0];
            const segmentPathChild = segmentPath.concat([
                parallelRouteKey,
                segmentChild
            ]);
            const segmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(segmentChild);
            const existingCacheNodeChild = existingSegmentMapChild !== undefined ? existingSegmentMapChild.get(segmentKeyChild) : undefined;
            const taskChild = createCacheNodeOnNavigation(navigatedAt, routerStateChild, existingCacheNodeChild, prefetchDataChild, possiblyPartialPrefetchHead, isPrefetchHeadPartial, segmentPathChild, scrollableSegmentsResult);
            taskChildren.set(parallelRouteKey, taskChild);
            const dynamicRequestTreeChild = taskChild.dynamicRequestTree;
            if (dynamicRequestTreeChild !== null) {
                // Something in the child tree is dynamic.
                needsDynamicRequest = true;
                dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild;
            } else {
                dynamicRequestTreeChildren[parallelRouteKey] = routerStateChild;
            }
            const newCacheNodeChild = taskChild.node;
            if (newCacheNodeChild !== null) {
                const newSegmentMapChild = new Map();
                newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild);
                cacheNodeChildren.set(parallelRouteKey, newSegmentMapChild);
            }
        }
    }
    return {
        // Since we're inside a new route tree, unlike the
        // `updateCacheNodeOnNavigation` path, the router state on the children
        // tasks is always the same as the router state we pass in. So we don't need
        // to clone/modify it.
        route: routerState,
        node: {
            lazyData: null,
            // Since this segment is already full, we don't need to use the
            // `prefetchRsc` field.
            rsc,
            prefetchRsc: null,
            head,
            prefetchHead: null,
            loading,
            parallelRoutes: cacheNodeChildren,
            navigatedAt: cacheNodeNavigatedAt
        },
        dynamicRequestTree: needsDynamicRequest ? patchRouterStateWithNewChildren(routerState, dynamicRequestTreeChildren) : null,
        children: taskChildren
    };
}
function patchRouterStateWithNewChildren(baseRouterState, newChildren) {
    const clone = [
        baseRouterState[0],
        newChildren
    ];
    // Based on equivalent logic in apply-router-state-patch-to-tree, but should
    // confirm whether we need to copy all of these fields. Not sure the server
    // ever sends, e.g. the refetch marker.
    if (2 in baseRouterState) {
        clone[2] = baseRouterState[2];
    }
    if (3 in baseRouterState) {
        clone[3] = baseRouterState[3];
    }
    if (4 in baseRouterState) {
        clone[4] = baseRouterState[4];
    }
    return clone;
}
function spawnPendingTask(navigatedAt, routerState, prefetchData, prefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult) {
    // Create a task that will later be fulfilled by data from the server.
    // Clone the prefetched route tree and the `refetch` marker to it. We'll send
    // this to the server so it knows where to start rendering.
    const dynamicRequestTree = patchRouterStateWithNewChildren(routerState, routerState[1]);
    dynamicRequestTree[3] = 'refetch';
    const newTask = {
        route: routerState,
        // Corresponds to the part of the route that will be rendered on the server.
        node: createPendingCacheNode(navigatedAt, routerState, prefetchData, prefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult),
        // Because this is non-null, and it gets propagated up through the parent
        // tasks, the root task will know that it needs to perform a server request.
        dynamicRequestTree,
        children: null
    };
    return newTask;
}
function spawnReusedTask(reusedRouterState) {
    // Create a task that reuses an existing segment, e.g. when reusing
    // the current active segment in place of a default route.
    return {
        route: reusedRouterState,
        node: null,
        dynamicRequestTree: null,
        children: null
    };
}
function listenForDynamicRequest(task, responsePromise) {
    responsePromise.then((param)=>{
        let { flightData } = param;
        if (typeof flightData === 'string') {
            // Happens when navigating to page in `pages` from `app`. We shouldn't
            // get here because should have already handled this during
            // the prefetch.
            return;
        }
        for (const normalizedFlightData of flightData){
            const { segmentPath, tree: serverRouterState, seedData: dynamicData, head: dynamicHead } = normalizedFlightData;
            if (!dynamicData) {
                continue;
            }
            writeDynamicDataIntoPendingTask(task, segmentPath, serverRouterState, dynamicData, dynamicHead);
        }
        // Now that we've exhausted all the data we received from the server, if
        // there are any remaining pending tasks in the tree, abort them now.
        // If there's any missing data, it will trigger a lazy fetch.
        abortTask(task, null);
    }, (error)=>{
        // This will trigger an error during render
        abortTask(task, error);
    });
}
function writeDynamicDataIntoPendingTask(rootTask, segmentPath, serverRouterState, dynamicData, dynamicHead) {
    // The data sent by the server represents only a subtree of the app. We need
    // to find the part of the task tree that matches the server response, and
    // fulfill it using the dynamic data.
    //
    // segmentPath represents the parent path of subtree. It's a repeating pattern
    // of parallel route key and segment:
    //
    //   [string, Segment, string, Segment, string, Segment, ...]
    //
    // Iterate through the path and finish any tasks that match this payload.
    let task = rootTask;
    for(let i = 0; i < segmentPath.length; i += 2){
        const parallelRouteKey = segmentPath[i];
        const segment = segmentPath[i + 1];
        const taskChildren = task.children;
        if (taskChildren !== null) {
            const taskChild = taskChildren.get(parallelRouteKey);
            if (taskChild !== undefined) {
                const taskSegment = taskChild.route[0];
                if ((0, _matchsegments.matchSegment)(segment, taskSegment)) {
                    // Found a match for this task. Keep traversing down the task tree.
                    task = taskChild;
                    continue;
                }
            }
        }
        // We didn't find a child task that matches the server data. Exit. We won't
        // abort the task, though, because a different FlightDataPath may be able to
        // fulfill it (see loop in listenForDynamicRequest). We only abort tasks
        // once we've run out of data.
        return;
    }
    finishTaskUsingDynamicDataPayload(task, serverRouterState, dynamicData, dynamicHead);
}
function finishTaskUsingDynamicDataPayload(task, serverRouterState, dynamicData, dynamicHead) {
    if (task.dynamicRequestTree === null) {
        // Everything in this subtree is already complete. Bail out.
        return;
    }
    // dynamicData may represent a larger subtree than the task. Before we can
    // finish the task, we need to line them up.
    const taskChildren = task.children;
    const taskNode = task.node;
    if (taskChildren === null) {
        // We've reached the leaf node of the pending task. The server data tree
        // lines up the pending Cache Node tree. We can now switch to the
        // normal algorithm.
        if (taskNode !== null) {
            finishPendingCacheNode(taskNode, task.route, serverRouterState, dynamicData, dynamicHead);
            // Set this to null to indicate that this task is now complete.
            task.dynamicRequestTree = null;
        }
        return;
    }
    // The server returned more data than we need to finish the task. Skip over
    // the extra segments until we reach the leaf task node.
    const serverChildren = serverRouterState[1];
    const dynamicDataChildren = dynamicData[2];
    for(const parallelRouteKey in serverRouterState){
        const serverRouterStateChild = serverChildren[parallelRouteKey];
        const dynamicDataChild = dynamicDataChildren[parallelRouteKey];
        const taskChild = taskChildren.get(parallelRouteKey);
        if (taskChild !== undefined) {
            const taskSegment = taskChild.route[0];
            if ((0, _matchsegments.matchSegment)(serverRouterStateChild[0], taskSegment) && dynamicDataChild !== null && dynamicDataChild !== undefined) {
                // Found a match for this task. Keep traversing down the task tree.
                return finishTaskUsingDynamicDataPayload(taskChild, serverRouterStateChild, dynamicDataChild, dynamicHead);
            }
        }
    // We didn't find a child task that matches the server data. We won't abort
    // the task, though, because a different FlightDataPath may be able to
    // fulfill it (see loop in listenForDynamicRequest). We only abort tasks
    // once we've run out of data.
    }
}
function createPendingCacheNode(navigatedAt, routerState, prefetchData, prefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult) {
    const routerStateChildren = routerState[1];
    const prefetchDataChildren = prefetchData !== null ? prefetchData[2] : null;
    const parallelRoutes = new Map();
    for(let parallelRouteKey in routerStateChildren){
        const routerStateChild = routerStateChildren[parallelRouteKey];
        const prefetchDataChild = prefetchDataChildren !== null ? prefetchDataChildren[parallelRouteKey] : null;
        const segmentChild = routerStateChild[0];
        const segmentPathChild = segmentPath.concat([
            parallelRouteKey,
            segmentChild
        ]);
        const segmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(segmentChild);
        const newCacheNodeChild = createPendingCacheNode(navigatedAt, routerStateChild, prefetchDataChild === undefined ? null : prefetchDataChild, prefetchHead, isPrefetchHeadPartial, segmentPathChild, scrollableSegmentsResult);
        const newSegmentMapChild = new Map();
        newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild);
        parallelRoutes.set(parallelRouteKey, newSegmentMapChild);
    }
    // The head is assigned to every leaf segment delivered by the server. Based
    // on corresponding logic in fill-lazy-items-till-leaf-with-head.ts
    const isLeafSegment = parallelRoutes.size === 0;
    if (isLeafSegment) {
        // The segment path of every leaf segment (i.e. page) is collected into
        // a result array. This is used by the LayoutRouter to scroll to ensure that
        // new pages are visible after a navigation.
        // TODO: We should use a string to represent the segment path instead of
        // an array. We already use a string representation for the path when
        // accessing the Segment Cache, so we can use the same one.
        scrollableSegmentsResult.push(segmentPath);
    }
    const maybePrefetchRsc = prefetchData !== null ? prefetchData[1] : null;
    const maybePrefetchLoading = prefetchData !== null ? prefetchData[3] : null;
    return {
        lazyData: null,
        parallelRoutes: parallelRoutes,
        prefetchRsc: maybePrefetchRsc !== undefined ? maybePrefetchRsc : null,
        prefetchHead: isLeafSegment ? prefetchHead : [
            null,
            null
        ],
        // TODO: Technically, a loading boundary could contain dynamic data. We must
        // have separate `loading` and `prefetchLoading` fields to handle this, like
        // we do for the segment data and head.
        loading: maybePrefetchLoading !== undefined ? maybePrefetchLoading : null,
        // Create a deferred promise. This will be fulfilled once the dynamic
        // response is received from the server.
        rsc: createDeferredRsc(),
        head: isLeafSegment ? createDeferredRsc() : null,
        navigatedAt
    };
}
function finishPendingCacheNode(cacheNode, taskState, serverState, dynamicData, dynamicHead) {
    // Writes a dynamic response into an existing Cache Node tree. This does _not_
    // create a new tree, it updates the existing tree in-place. So it must follow
    // the Suspense rules of cache safety  it can resolve pending promises, but
    // it cannot overwrite existing data. It can add segments to the tree (because
    // a missing segment will cause the layout router to suspend).
    // but it cannot delete them.
    //
    // We must resolve every promise in the tree, or else it will suspend
    // indefinitely. If we did not receive data for a segment, we will resolve its
    // data promise to `null` to trigger a lazy fetch during render.
    const taskStateChildren = taskState[1];
    const serverStateChildren = serverState[1];
    const dataChildren = dynamicData[2];
    // The router state that we traverse the tree with (taskState) is the same one
    // that we used to construct the pending Cache Node tree. That way we're sure
    // to resolve all the pending promises.
    const parallelRoutes = cacheNode.parallelRoutes;
    for(let parallelRouteKey in taskStateChildren){
        const taskStateChild = taskStateChildren[parallelRouteKey];
        const serverStateChild = serverStateChildren[parallelRouteKey];
        const dataChild = dataChildren[parallelRouteKey];
        const segmentMapChild = parallelRoutes.get(parallelRouteKey);
        const taskSegmentChild = taskStateChild[0];
        const taskSegmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(taskSegmentChild);
        const cacheNodeChild = segmentMapChild !== undefined ? segmentMapChild.get(taskSegmentKeyChild) : undefined;
        if (cacheNodeChild !== undefined) {
            if (serverStateChild !== undefined && (0, _matchsegments.matchSegment)(taskSegmentChild, serverStateChild[0])) {
                if (dataChild !== undefined && dataChild !== null) {
                    // This is the happy path. Recursively update all the children.
                    finishPendingCacheNode(cacheNodeChild, taskStateChild, serverStateChild, dataChild, dynamicHead);
                } else {
                    // The server never returned data for this segment. Trigger a lazy
                    // fetch during render. This shouldn't happen because the Route Tree
                    // and the Seed Data tree sent by the server should always be the same
                    // shape when part of the same server response.
                    abortPendingCacheNode(taskStateChild, cacheNodeChild, null);
                }
            } else {
                // The server never returned data for this segment. Trigger a lazy
                // fetch during render.
                abortPendingCacheNode(taskStateChild, cacheNodeChild, null);
            }
        } else {
        // The server response matches what was expected to receive, but there's
        // no matching Cache Node in the task tree. This is a bug in the
        // implementation because we should have created a node for every
        // segment in the tree that's associated with this task.
        }
    }
    // Use the dynamic data from the server to fulfill the deferred RSC promise
    // on the Cache Node.
    const rsc = cacheNode.rsc;
    const dynamicSegmentData = dynamicData[1];
    if (rsc === null) {
        // This is a lazy cache node. We can overwrite it. This is only safe
        // because we know that the LayoutRouter suspends if `rsc` is `null`.
        cacheNode.rsc = dynamicSegmentData;
    } else if (isDeferredRsc(rsc)) {
        // This is a deferred RSC promise. We can fulfill it with the data we just
        // received from the server. If it was already resolved by a different
        // navigation, then this does nothing because we can't overwrite data.
        rsc.resolve(dynamicSegmentData);
    } else {
    // This is not a deferred RSC promise, nor is it empty, so it must have
    // been populated by a different navigation. We must not overwrite it.
    }
    // Check if this is a leaf segment. If so, it will have a `head` property with
    // a pending promise that needs to be resolved with the dynamic head from
    // the server.
    const head = cacheNode.head;
    if (isDeferredRsc(head)) {
        head.resolve(dynamicHead);
    }
}
function abortTask(task, error) {
    const cacheNode = task.node;
    if (cacheNode === null) {
        // This indicates the task is already complete.
        return;
    }
    const taskChildren = task.children;
    if (taskChildren === null) {
        // Reached the leaf task node. This is the root of a pending cache
        // node tree.
        abortPendingCacheNode(task.route, cacheNode, error);
    } else {
        // This is an intermediate task node. Keep traversing until we reach a
        // task node with no children. That will be the root of the cache node tree
        // that needs to be resolved.
        for (const taskChild of taskChildren.values()){
            abortTask(taskChild, error);
        }
    }
    // Set this to null to indicate that this task is now complete.
    task.dynamicRequestTree = null;
}
function abortPendingCacheNode(routerState, cacheNode, error) {
    // For every pending segment in the tree, resolve its `rsc` promise to `null`
    // to trigger a lazy fetch during render.
    //
    // Or, if an error object is provided, it will error instead.
    const routerStateChildren = routerState[1];
    const parallelRoutes = cacheNode.parallelRoutes;
    for(let parallelRouteKey in routerStateChildren){
        const routerStateChild = routerStateChildren[parallelRouteKey];
        const segmentMapChild = parallelRoutes.get(parallelRouteKey);
        if (segmentMapChild === undefined) {
            continue;
        }
        const segmentChild = routerStateChild[0];
        const segmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(segmentChild);
        const cacheNodeChild = segmentMapChild.get(segmentKeyChild);
        if (cacheNodeChild !== undefined) {
            abortPendingCacheNode(routerStateChild, cacheNodeChild, error);
        } else {
        // This shouldn't happen because we're traversing the same tree that was
        // used to construct the cache nodes in the first place.
        }
    }
    const rsc = cacheNode.rsc;
    if (isDeferredRsc(rsc)) {
        if (error === null) {
            // This will trigger a lazy fetch during render.
            rsc.resolve(null);
        } else {
            // This will trigger an error during rendering.
            rsc.reject(error);
        }
    }
    // Check if this is a leaf segment. If so, it will have a `head` property with
    // a pending promise that needs to be resolved. If an error was provided, we
    // will not resolve it with an error, since this is rendered at the root of
    // the app. We want the segment to error, not the entire app.
    const head = cacheNode.head;
    if (isDeferredRsc(head)) {
        head.resolve(null);
    }
}
function updateCacheNodeOnPopstateRestoration(oldCacheNode, routerState) {
    // A popstate navigation reads data from the local cache. It does not issue
    // new network requests (unless the cache entries have been evicted). So, we
    // update the cache to drop the prefetch data for any segment whose dynamic
    // data was already received. This prevents an unnecessary flash back to PPR
    // state during a back/forward navigation.
    //
    // This function clones the entire cache node tree and sets the `prefetchRsc`
    // field to `null` to prevent it from being rendered. We can't mutate the node
    // in place because this is a concurrent data structure.
    const routerStateChildren = routerState[1];
    const oldParallelRoutes = oldCacheNode.parallelRoutes;
    const newParallelRoutes = new Map(oldParallelRoutes);
    for(let parallelRouteKey in routerStateChildren){
        const routerStateChild = routerStateChildren[parallelRouteKey];
        const segmentChild = routerStateChild[0];
        const segmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(segmentChild);
        const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey);
        if (oldSegmentMapChild !== undefined) {
            const oldCacheNodeChild = oldSegmentMapChild.get(segmentKeyChild);
            if (oldCacheNodeChild !== undefined) {
                const newCacheNodeChild = updateCacheNodeOnPopstateRestoration(oldCacheNodeChild, routerStateChild);
                const newSegmentMapChild = new Map(oldSegmentMapChild);
                newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild);
                newParallelRoutes.set(parallelRouteKey, newSegmentMapChild);
            }
        }
    }
    // Only show prefetched data if the dynamic data is still pending.
    //
    // Tehnically, what we're actually checking is whether the dynamic network
    // response was received. But since it's a streaming response, this does not
    // mean that all the dynamic data has fully streamed in. It just means that
    // _some_ of the dynamic data was received. But as a heuristic, we assume that
    // the rest dynamic data will stream in quickly, so it's still better to skip
    // the prefetch state.
    const rsc = oldCacheNode.rsc;
    const shouldUsePrefetch = isDeferredRsc(rsc) && rsc.status === 'pending';
    return {
        lazyData: null,
        rsc,
        head: oldCacheNode.head,
        prefetchHead: shouldUsePrefetch ? oldCacheNode.prefetchHead : [
            null,
            null
        ],
        prefetchRsc: shouldUsePrefetch ? oldCacheNode.prefetchRsc : null,
        loading: oldCacheNode.loading,
        // These are the cloned children we computed above
        parallelRoutes: newParallelRoutes,
        navigatedAt: oldCacheNode.navigatedAt
    };
}
const DEFERRED = Symbol();
// This type exists to distinguish a DeferredRsc from a Flight promise. It's a
// compromise to avoid adding an extra field on every Cache Node, which would be
// awkward because the pre-PPR parts of codebase would need to account for it,
// too. We can remove it once type Cache Node type is more settled.
function isDeferredRsc(value) {
    return value && value.tag === DEFERRED;
}
function createDeferredRsc() {
    let resolve;
    let reject;
    const pendingRsc = new Promise((res, rej)=>{
        resolve = res;
        reject = rej;
    });
    pendingRsc.status = 'pending';
    pendingRsc.resolve = (value)=>{
        if (pendingRsc.status === 'pending') {
            const fulfilledRsc = pendingRsc;
            fulfilledRsc.status = 'fulfilled';
            fulfilledRsc.value = value;
            resolve(value);
        }
    };
    pendingRsc.reject = (error)=>{
        if (pendingRsc.status === 'pending') {
            const rejectedRsc = pendingRsc;
            rejectedRsc.status = 'rejected';
            rejectedRsc.reason = error;
            reject(error);
        }
    };
    pendingRsc.tag = DEFERRED;
    return pendingRsc;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=ppr-navigations.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/clear-cache-node-data-for-segment-path.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "clearCacheNodeDataForSegmentPath", {
    enumerable: true,
    get: function() {
        return clearCacheNodeDataForSegmentPath;
    }
});
const _flightdatahelpers = __turbopack_context__.r("[project]/node_modules/next/dist/client/flight-data-helpers.js [app-ssr] (ecmascript)");
const _createroutercachekey = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js [app-ssr] (ecmascript)");
function clearCacheNodeDataForSegmentPath(newCache, existingCache, flightSegmentPath) {
    const isLastEntry = flightSegmentPath.length <= 2;
    const [parallelRouteKey, segment] = flightSegmentPath;
    const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(segment);
    const existingChildSegmentMap = existingCache.parallelRoutes.get(parallelRouteKey);
    let childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey);
    if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {
        childSegmentMap = new Map(existingChildSegmentMap);
        newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap);
    }
    const existingChildCacheNode = existingChildSegmentMap == null ? void 0 : existingChildSegmentMap.get(cacheKey);
    let childCacheNode = childSegmentMap.get(cacheKey);
    // In case of last segment start off the fetch at this level and don't copy further down.
    if (isLastEntry) {
        if (!childCacheNode || !childCacheNode.lazyData || childCacheNode === existingChildCacheNode) {
            childSegmentMap.set(cacheKey, {
                lazyData: null,
                rsc: null,
                prefetchRsc: null,
                head: null,
                prefetchHead: null,
                parallelRoutes: new Map(),
                loading: null,
                navigatedAt: -1
            });
        }
        return;
    }
    if (!childCacheNode || !existingChildCacheNode) {
        // Start fetch in the place where the existing cache doesn't have the data yet.
        if (!childCacheNode) {
            childSegmentMap.set(cacheKey, {
                lazyData: null,
                rsc: null,
                prefetchRsc: null,
                head: null,
                prefetchHead: null,
                parallelRoutes: new Map(),
                loading: null,
                navigatedAt: -1
            });
        }
        return;
    }
    if (childCacheNode === existingChildCacheNode) {
        childCacheNode = {
            lazyData: childCacheNode.lazyData,
            rsc: childCacheNode.rsc,
            prefetchRsc: childCacheNode.prefetchRsc,
            head: childCacheNode.head,
            prefetchHead: childCacheNode.prefetchHead,
            parallelRoutes: new Map(childCacheNode.parallelRoutes),
            loading: childCacheNode.loading
        };
        childSegmentMap.set(cacheKey, childCacheNode);
    }
    return clearCacheNodeDataForSegmentPath(childCacheNode, existingChildCacheNode, (0, _flightdatahelpers.getNextFlightSegmentPath)(flightSegmentPath));
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=clear-cache-node-data-for-segment-path.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/aliased-prefetch-navigations.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    addSearchParamsToPageSegments: null,
    handleAliasedPrefetchEntry: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    addSearchParamsToPageSegments: function() {
        return addSearchParamsToPageSegments;
    },
    handleAliasedPrefetchEntry: function() {
        return handleAliasedPrefetchEntry;
    }
});
const _segment = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/segment.js [app-ssr] (ecmascript)");
const _approuter = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/app-router.js [app-ssr] (ecmascript)");
const _applyrouterstatepatchtotree = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js [app-ssr] (ecmascript)");
const _createhreffromurl = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/create-href-from-url.js [app-ssr] (ecmascript)");
const _createroutercachekey = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js [app-ssr] (ecmascript)");
const _fillcachewithnewsubtreedata = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/fill-cache-with-new-subtree-data.js [app-ssr] (ecmascript)");
const _handlemutable = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/handle-mutable.js [app-ssr] (ecmascript)");
function handleAliasedPrefetchEntry(navigatedAt, state, flightData, url, mutable) {
    let currentTree = state.tree;
    let currentCache = state.cache;
    const href = (0, _createhreffromurl.createHrefFromUrl)(url);
    let applied;
    if (typeof flightData === 'string') {
        return false;
    }
    for (const normalizedFlightData of flightData){
        // If the segment doesn't have a loading component, we don't need to do anything.
        if (!hasLoadingComponentInSeedData(normalizedFlightData.seedData)) {
            continue;
        }
        let treePatch = normalizedFlightData.tree;
        // Segments are keyed by searchParams (e.g. __PAGE__?{"foo":"bar"}). We might return a less specific, param-less entry,
        // so we ensure that the final tree contains the correct searchParams (reflected in the URL) are provided in the updated FlightRouterState tree.
        // We only do this on the first read, as otherwise we'd be overwriting the searchParams that may have already been set
        treePatch = addSearchParamsToPageSegments(treePatch, Object.fromEntries(url.searchParams));
        const { seedData, isRootRender, pathToSegment } = normalizedFlightData;
        // TODO-APP: remove ''
        const flightSegmentPathWithLeadingEmpty = [
            '',
            ...pathToSegment
        ];
        // Segments are keyed by searchParams (e.g. __PAGE__?{"foo":"bar"}). We might return a less specific, param-less entry,
        // so we ensure that the final tree contains the correct searchParams (reflected in the URL) are provided in the updated FlightRouterState tree.
        // We only do this on the first read, as otherwise we'd be overwriting the searchParams that may have already been set
        treePatch = addSearchParamsToPageSegments(treePatch, Object.fromEntries(url.searchParams));
        let newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)(flightSegmentPathWithLeadingEmpty, currentTree, treePatch, href);
        const newCache = (0, _approuter.createEmptyCacheNode)();
        // The prefetch cache entry was aliased -- this signals that we only fill in the cache with the
        // loading state and not the actual parallel route seed data.
        if (isRootRender && seedData) {
            // Fill in the cache with the new loading / rsc data
            const rsc = seedData[1];
            const loading = seedData[3];
            newCache.loading = loading;
            newCache.rsc = rsc;
            // Construct a new tree and apply the aliased loading state for each parallel route
            fillNewTreeWithOnlyLoadingSegments(navigatedAt, newCache, currentCache, treePatch, seedData);
        } else {
            // Copy rsc for the root node of the cache.
            newCache.rsc = currentCache.rsc;
            newCache.prefetchRsc = currentCache.prefetchRsc;
            newCache.loading = currentCache.loading;
            newCache.parallelRoutes = new Map(currentCache.parallelRoutes);
            // copy the loading state only into the leaf node (the part that changed)
            (0, _fillcachewithnewsubtreedata.fillCacheWithNewSubTreeDataButOnlyLoading)(navigatedAt, newCache, currentCache, normalizedFlightData);
        }
        // If we don't have an updated tree, there's no reason to update the cache, as the tree
        // dictates what cache nodes to render.
        if (newTree) {
            currentTree = newTree;
            currentCache = newCache;
            applied = true;
        }
    }
    if (!applied) {
        return false;
    }
    mutable.patchedTree = currentTree;
    mutable.cache = currentCache;
    mutable.canonicalUrl = href;
    mutable.hashFragment = url.hash;
    return (0, _handlemutable.handleMutable)(state, mutable);
}
function hasLoadingComponentInSeedData(seedData) {
    if (!seedData) return false;
    const parallelRoutes = seedData[2];
    const loading = seedData[3];
    if (loading) {
        return true;
    }
    for(const key in parallelRoutes){
        if (hasLoadingComponentInSeedData(parallelRoutes[key])) {
            return true;
        }
    }
    return false;
}
function fillNewTreeWithOnlyLoadingSegments(navigatedAt, newCache, existingCache, routerState, cacheNodeSeedData) {
    const isLastSegment = Object.keys(routerState[1]).length === 0;
    if (isLastSegment) {
        return;
    }
    for(const key in routerState[1]){
        const parallelRouteState = routerState[1][key];
        const segmentForParallelRoute = parallelRouteState[0];
        const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(segmentForParallelRoute);
        const parallelSeedData = cacheNodeSeedData !== null && cacheNodeSeedData[2][key] !== undefined ? cacheNodeSeedData[2][key] : null;
        let newCacheNode;
        if (parallelSeedData !== null) {
            // New data was sent from the server.
            const rsc = parallelSeedData[1];
            const loading = parallelSeedData[3];
            newCacheNode = {
                lazyData: null,
                // copy the layout but null the page segment as that's not meant to be used
                rsc: segmentForParallelRoute.includes(_segment.PAGE_SEGMENT_KEY) ? null : rsc,
                prefetchRsc: null,
                head: null,
                prefetchHead: null,
                parallelRoutes: new Map(),
                loading,
                navigatedAt
            };
        } else {
            // No data available for this node. This will trigger a lazy fetch
            // during render.
            newCacheNode = {
                lazyData: null,
                rsc: null,
                prefetchRsc: null,
                head: null,
                prefetchHead: null,
                parallelRoutes: new Map(),
                loading: null,
                navigatedAt: -1
            };
        }
        const existingParallelRoutes = newCache.parallelRoutes.get(key);
        if (existingParallelRoutes) {
            existingParallelRoutes.set(cacheKey, newCacheNode);
        } else {
            newCache.parallelRoutes.set(key, new Map([
                [
                    cacheKey,
                    newCacheNode
                ]
            ]));
        }
        fillNewTreeWithOnlyLoadingSegments(navigatedAt, newCacheNode, existingCache, parallelRouteState, parallelSeedData);
    }
}
function addSearchParamsToPageSegments(flightRouterState, searchParams) {
    const [segment, parallelRoutes, ...rest] = flightRouterState;
    // If it's a page segment, modify the segment by adding search params
    if (segment.includes(_segment.PAGE_SEGMENT_KEY)) {
        const newSegment = (0, _segment.addSearchParamsIfPageSegment)(segment, searchParams);
        return [
            newSegment,
            parallelRoutes,
            ...rest
        ];
    }
    // Otherwise, recurse through the parallel routes and return a new tree
    const updatedParallelRoutes = {};
    for (const [key, parallelRoute] of Object.entries(parallelRoutes)){
        updatedParallelRoutes[key] = addSearchParamsToPageSegments(parallelRoute, searchParams);
    }
    return [
        segment,
        updatedParallelRoutes,
        ...rest
    ];
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=aliased-prefetch-navigations.js.map
}}),
"[project]/node_modules/next/dist/client/components/segment-cache.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/**
 * Entry point to the Segment Cache implementation.
 *
 * All code related to the Segment Cache lives `segment-cache-impl` directory.
 * Callers access it through this indirection.
 *
 * This is to ensure the code is dead code eliminated from the bundle if the
 * flag is disabled.
 *
 * TODO: This is super tedious. Since experimental flags are an essential part
 * of our workflow, we should establish a better pattern for dead code
 * elimination. Ideally it would be done at the bundler level, like how React's
 * build process works. In the React repo, you don't even need to add any extra
 * configuration per experiment  if the code is not reachable, it gets stripped
 * from the build automatically by Rollup. Or, shorter term, we could stub out
 * experimental modules at build time by updating the build config, i.e. a more
 * automated version of what I'm doing manually in this file.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    NavigationResultTag: null,
    PrefetchPriority: null,
    cancelPrefetchTask: null,
    createCacheKey: null,
    getCurrentCacheVersion: null,
    isPrefetchTaskDirty: null,
    navigate: null,
    prefetch: null,
    reschedulePrefetchTask: null,
    revalidateEntireCache: null,
    schedulePrefetchTask: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    NavigationResultTag: function() {
        return NavigationResultTag;
    },
    PrefetchPriority: function() {
        return PrefetchPriority;
    },
    cancelPrefetchTask: function() {
        return cancelPrefetchTask;
    },
    createCacheKey: function() {
        return createCacheKey;
    },
    getCurrentCacheVersion: function() {
        return getCurrentCacheVersion;
    },
    isPrefetchTaskDirty: function() {
        return isPrefetchTaskDirty;
    },
    navigate: function() {
        return navigate;
    },
    prefetch: function() {
        return prefetch;
    },
    reschedulePrefetchTask: function() {
        return reschedulePrefetchTask;
    },
    revalidateEntireCache: function() {
        return revalidateEntireCache;
    },
    schedulePrefetchTask: function() {
        return schedulePrefetchTask;
    }
});
const notEnabled = ()=>{
    throw Object.defineProperty(new Error('Segment Cache experiment is not enabled. This is a bug in Next.js.'), "__NEXT_ERROR_CODE", {
        value: "E654",
        enumerable: false,
        configurable: true
    });
};
const prefetch = ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : notEnabled;
const navigate = ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : notEnabled;
const revalidateEntireCache = ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : notEnabled;
const getCurrentCacheVersion = ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : notEnabled;
const schedulePrefetchTask = ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : notEnabled;
const cancelPrefetchTask = ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : notEnabled;
const reschedulePrefetchTask = ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : notEnabled;
const isPrefetchTaskDirty = ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : notEnabled;
const createCacheKey = ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : notEnabled;
var NavigationResultTag = /*#__PURE__*/ function(NavigationResultTag) {
    NavigationResultTag[NavigationResultTag["MPA"] = 0] = "MPA";
    NavigationResultTag[NavigationResultTag["Success"] = 1] = "Success";
    NavigationResultTag[NavigationResultTag["NoOp"] = 2] = "NoOp";
    NavigationResultTag[NavigationResultTag["Async"] = 3] = "Async";
    return NavigationResultTag;
}({});
var PrefetchPriority = /*#__PURE__*/ function(PrefetchPriority) {
    /**
   * Assigned to the most recently hovered/touched link. Special network
   * bandwidth is reserved for this task only. There's only ever one Intent-
   * priority task at a time; when a new Intent task is scheduled, the previous
   * one is bumped down to Default.
   */ PrefetchPriority[PrefetchPriority["Intent"] = 2] = "Intent";
    /**
   * The default priority for prefetch tasks.
   */ PrefetchPriority[PrefetchPriority["Default"] = 1] = "Default";
    /**
   * Assigned to tasks when they spawn non-blocking background work, like
   * revalidating a partially cached entry to see if more data is available.
   */ PrefetchPriority[PrefetchPriority["Background"] = 0] = "Background";
    return PrefetchPriority;
}({});
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=segment-cache.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    handleExternalUrl: null,
    navigateReducer: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    handleExternalUrl: function() {
        return handleExternalUrl;
    },
    navigateReducer: function() {
        return navigateReducer;
    }
});
const _fetchserverresponse = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/fetch-server-response.js [app-ssr] (ecmascript)");
const _createhreffromurl = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/create-href-from-url.js [app-ssr] (ecmascript)");
const _invalidatecachebelowflightsegmentpath = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/invalidate-cache-below-flight-segmentpath.js [app-ssr] (ecmascript)");
const _applyrouterstatepatchtotree = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js [app-ssr] (ecmascript)");
const _shouldhardnavigate = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/should-hard-navigate.js [app-ssr] (ecmascript)");
const _isnavigatingtonewrootlayout = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js [app-ssr] (ecmascript)");
const _routerreducertypes = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/router-reducer-types.js [app-ssr] (ecmascript)");
const _handlemutable = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/handle-mutable.js [app-ssr] (ecmascript)");
const _applyflightdata = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/apply-flight-data.js [app-ssr] (ecmascript)");
const _prefetchreducer = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js [app-ssr] (ecmascript)");
const _approuter = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/app-router.js [app-ssr] (ecmascript)");
const _segment = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/segment.js [app-ssr] (ecmascript)");
const _pprnavigations = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/ppr-navigations.js [app-ssr] (ecmascript)");
const _prefetchcacheutils = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js [app-ssr] (ecmascript)");
const _clearcachenodedataforsegmentpath = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/clear-cache-node-data-for-segment-path.js [app-ssr] (ecmascript)");
const _aliasedprefetchnavigations = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/aliased-prefetch-navigations.js [app-ssr] (ecmascript)");
const _segmentcache = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/segment-cache.js [app-ssr] (ecmascript)");
function handleExternalUrl(state, mutable, url, pendingPush) {
    mutable.mpaNavigation = true;
    mutable.canonicalUrl = url;
    mutable.pendingPush = pendingPush;
    mutable.scrollableSegments = undefined;
    return (0, _handlemutable.handleMutable)(state, mutable);
}
function generateSegmentsFromPatch(flightRouterPatch) {
    const segments = [];
    const [segment, parallelRoutes] = flightRouterPatch;
    if (Object.keys(parallelRoutes).length === 0) {
        return [
            [
                segment
            ]
        ];
    }
    for (const [parallelRouteKey, parallelRoute] of Object.entries(parallelRoutes)){
        for (const childSegment of generateSegmentsFromPatch(parallelRoute)){
            // If the segment is empty, it means we are at the root of the tree
            if (segment === '') {
                segments.push([
                    parallelRouteKey,
                    ...childSegment
                ]);
            } else {
                segments.push([
                    segment,
                    parallelRouteKey,
                    ...childSegment
                ]);
            }
        }
    }
    return segments;
}
function triggerLazyFetchForLeafSegments(newCache, currentCache, flightSegmentPath, treePatch) {
    let appliedPatch = false;
    newCache.rsc = currentCache.rsc;
    newCache.prefetchRsc = currentCache.prefetchRsc;
    newCache.loading = currentCache.loading;
    newCache.parallelRoutes = new Map(currentCache.parallelRoutes);
    const segmentPathsToFill = generateSegmentsFromPatch(treePatch).map((segment)=>[
            ...flightSegmentPath,
            ...segment
        ]);
    for (const segmentPaths of segmentPathsToFill){
        (0, _clearcachenodedataforsegmentpath.clearCacheNodeDataForSegmentPath)(newCache, currentCache, segmentPaths);
        appliedPatch = true;
    }
    return appliedPatch;
}
function handleNavigationResult(url, state, mutable, pendingPush, result) {
    switch(result.tag){
        case _segmentcache.NavigationResultTag.MPA:
            {
                // Perform an MPA navigation.
                const newUrl = result.data;
                return handleExternalUrl(state, mutable, newUrl, pendingPush);
            }
        case _segmentcache.NavigationResultTag.NoOp:
            {
                // The server responded with no change to the current page. However, if
                // the URL changed, we still need to update that.
                const newCanonicalUrl = result.data.canonicalUrl;
                mutable.canonicalUrl = newCanonicalUrl;
                // Check if the only thing that changed was the hash fragment.
                const oldUrl = new URL(state.canonicalUrl, url);
                const onlyHashChange = // navigations are always same-origin.
                url.pathname === oldUrl.pathname && url.search === oldUrl.search && url.hash !== oldUrl.hash;
                if (onlyHashChange) {
                    // The only updated part of the URL is the hash.
                    mutable.onlyHashChange = true;
                    mutable.shouldScroll = result.data.shouldScroll;
                    mutable.hashFragment = url.hash;
                    // Setting this to an empty array triggers a scroll for all new and
                    // updated segments. See `ScrollAndFocusHandler` for more details.
                    mutable.scrollableSegments = [];
                }
                return (0, _handlemutable.handleMutable)(state, mutable);
            }
        case _segmentcache.NavigationResultTag.Success:
            {
                // Received a new result.
                mutable.cache = result.data.cacheNode;
                mutable.patchedTree = result.data.flightRouterState;
                mutable.canonicalUrl = result.data.canonicalUrl;
                mutable.scrollableSegments = result.data.scrollableSegments;
                mutable.shouldScroll = result.data.shouldScroll;
                mutable.hashFragment = result.data.hash;
                return (0, _handlemutable.handleMutable)(state, mutable);
            }
        case _segmentcache.NavigationResultTag.Async:
            {
                return result.data.then((asyncResult)=>handleNavigationResult(url, state, mutable, pendingPush, asyncResult), // TODO: This matches the current behavior but we need to do something
                // better here if the network fails.
                ()=>{
                    return state;
                });
            }
        default:
            {
                result;
                return state;
            }
    }
}
function navigateReducer(state, action) {
    const { url, isExternalUrl, navigateType, shouldScroll, allowAliasing } = action;
    const mutable = {};
    const { hash } = url;
    const href = (0, _createhreffromurl.createHrefFromUrl)(url);
    const pendingPush = navigateType === 'push';
    // we want to prune the prefetch cache on every navigation to avoid it growing too large
    (0, _prefetchcacheutils.prunePrefetchCache)(state.prefetchCache);
    mutable.preserveCustomHistoryState = false;
    mutable.pendingPush = pendingPush;
    if (isExternalUrl) {
        return handleExternalUrl(state, mutable, url.toString(), pendingPush);
    }
    // Handles case where `<meta http-equiv="refresh">` tag is present,
    // which will trigger an MPA navigation.
    if (document.getElementById('__next-page-redirect')) {
        return handleExternalUrl(state, mutable, href, pendingPush);
    }
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    const prefetchValues = (0, _prefetchcacheutils.getOrCreatePrefetchCacheEntry)({
        url,
        nextUrl: state.nextUrl,
        tree: state.tree,
        prefetchCache: state.prefetchCache,
        allowAliasing
    });
    const { treeAtTimeOfPrefetch, data } = prefetchValues;
    _prefetchreducer.prefetchQueue.bump(data);
    return data.then((param)=>{
        let { flightData, canonicalUrl: canonicalUrlOverride, postponed } = param;
        const navigatedAt = Date.now();
        let isFirstRead = false;
        // we only want to mark this once
        if (!prefetchValues.lastUsedTime) {
            // important: we should only mark the cache node as dirty after we unsuspend from the call above
            prefetchValues.lastUsedTime = navigatedAt;
            isFirstRead = true;
        }
        if (prefetchValues.aliased) {
            // When alias is enabled, search param may not be included in the canonicalUrl.
            // But we want to set url to canonicalUrl so that we use redirected path for fetching dynamic data.
            const urlWithCanonicalPathname = new URL(url.href);
            if (canonicalUrlOverride) {
                urlWithCanonicalPathname.pathname = canonicalUrlOverride.pathname;
            }
            const result = (0, _aliasedprefetchnavigations.handleAliasedPrefetchEntry)(navigatedAt, state, flightData, urlWithCanonicalPathname, mutable);
            // We didn't return new router state because we didn't apply the aliased entry for some reason.
            // We'll re-invoke the navigation handler but ensure that we don't attempt to use the aliased entry. This
            // will create an on-demand prefetch entry.
            if (result === false) {
                return navigateReducer(state, {
                    ...action,
                    allowAliasing: false
                });
            }
            return result;
        }
        // Handle case when navigating to page in `pages` from `app`
        if (typeof flightData === 'string') {
            return handleExternalUrl(state, mutable, flightData, pendingPush);
        }
        const updatedCanonicalUrl = canonicalUrlOverride ? (0, _createhreffromurl.createHrefFromUrl)(canonicalUrlOverride) : href;
        const onlyHashChange = !!hash && state.canonicalUrl.split('#', 1)[0] === updatedCanonicalUrl.split('#', 1)[0];
        // If only the hash has changed, the server hasn't sent us any new data. We can just update
        // the mutable properties responsible for URL and scroll handling and return early.
        if (onlyHashChange) {
            mutable.onlyHashChange = true;
            mutable.canonicalUrl = updatedCanonicalUrl;
            mutable.shouldScroll = shouldScroll;
            mutable.hashFragment = hash;
            mutable.scrollableSegments = [];
            return (0, _handlemutable.handleMutable)(state, mutable);
        }
        let currentTree = state.tree;
        let currentCache = state.cache;
        let scrollableSegments = [];
        for (const normalizedFlightData of flightData){
            const { pathToSegment: flightSegmentPath, seedData, head, isHeadPartial, isRootRender } = normalizedFlightData;
            let treePatch = normalizedFlightData.tree;
            // TODO-APP: remove ''
            const flightSegmentPathWithLeadingEmpty = [
                '',
                ...flightSegmentPath
            ];
            // Create new tree based on the flightSegmentPath and router state patch
            let newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)(flightSegmentPathWithLeadingEmpty, currentTree, treePatch, href);
            // If the tree patch can't be applied to the current tree then we use the tree at time of prefetch
            // TODO-APP: This should instead fill in the missing pieces in `currentTree` with the data from `treeAtTimeOfPrefetch`, then apply the patch.
            if (newTree === null) {
                newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)(flightSegmentPathWithLeadingEmpty, treeAtTimeOfPrefetch, treePatch, href);
            }
            if (newTree !== null) {
                if (// will send back a static response that's rendered from
                // the root. If for some reason it doesn't, we fall back to the
                // non-PPR implementation.
                // TODO: We should get rid of the else branch and do all navigations
                // via startPPRNavigation. The current structure is just
                // an incremental step.
                seedData && isRootRender && postponed) {
                    const task = (0, _pprnavigations.startPPRNavigation)(navigatedAt, currentCache, currentTree, treePatch, seedData, head, isHeadPartial, false, scrollableSegments);
                    if (task !== null) {
                        if (task.route === null) {
                            // Detected a change to the root layout. Perform an full-
                            // page navigation.
                            return handleExternalUrl(state, mutable, href, pendingPush);
                        }
                        // Use the tree computed by startPPRNavigation instead
                        // of the one computed by applyRouterStatePatchToTree.
                        // TODO: We should remove applyRouterStatePatchToTree
                        // from the PPR path entirely.
                        const patchedRouterState = task.route;
                        newTree = patchedRouterState;
                        const newCache = task.node;
                        if (newCache !== null) {
                            // We've created a new Cache Node tree that contains a prefetched
                            // version of the next page. This can be rendered instantly.
                            mutable.cache = newCache;
                        }
                        const dynamicRequestTree = task.dynamicRequestTree;
                        if (dynamicRequestTree !== null) {
                            // The prefetched tree has dynamic holes in it. We initiate a
                            // dynamic request to fill them in.
                            //
                            // Do not block on the result. We'll immediately render the Cache
                            // Node tree and suspend on the dynamic parts. When the request
                            // comes in, we'll fill in missing data and ping React to
                            // re-render. Unlike the lazy fetching model in the non-PPR
                            // implementation, this is modeled as a single React update +
                            // streaming, rather than multiple top-level updates. (However,
                            // even in the new model, we'll still need to sometimes update the
                            // root multiple times per navigation, like if the server sends us
                            // a different response than we expected. For now, we revert back
                            // to the lazy fetching mechanism in that case.)
                            const dynamicRequest = (0, _fetchserverresponse.fetchServerResponse)(new URL(updatedCanonicalUrl, url.origin), {
                                flightRouterState: dynamicRequestTree,
                                nextUrl: state.nextUrl
                            });
                            (0, _pprnavigations.listenForDynamicRequest)(task, dynamicRequest);
                        // We store the dynamic request on the `lazyData` property of the CacheNode
                        // because we're not going to await the dynamic request here. Since we're not blocking
                        // on the dynamic request, `layout-router` will
                        // task.node.lazyData = dynamicRequest
                        } else {
                        // The prefetched tree does not contain dynamic holes  it's
                        // fully static. We can skip the dynamic request.
                        }
                    } else {
                        // Nothing changed, so reuse the old cache.
                        // TODO: What if the head changed but not any of the segment data?
                        // Is that possible? If so, we should clone the whole tree and
                        // update the head.
                        newTree = treePatch;
                    }
                } else {
                    // The static response does not include any dynamic holes, so
                    // there's no need to do a second request.
                    // TODO: As an incremental step this just reverts back to the
                    // non-PPR implementation. We can simplify this branch further,
                    // given that PPR prefetches are always static and return the whole
                    // tree. Or in the meantime we could factor it out into a
                    // separate function.
                    if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {
                        return handleExternalUrl(state, mutable, href, pendingPush);
                    }
                    const cache = (0, _approuter.createEmptyCacheNode)();
                    let applied = false;
                    if (prefetchValues.status === _routerreducertypes.PrefetchCacheEntryStatus.stale && !isFirstRead) {
                        // When we have a stale prefetch entry, we only want to re-use the loading state of the route we're navigating to, to support instant loading navigations
                        // this will trigger a lazy fetch for the actual page data by nulling the `rsc` and `prefetchRsc` values for page data,
                        // while copying over the `loading` for the segment that contains the page data.
                        // We only do this on subsequent reads, as otherwise there'd be no loading data to re-use.
                        // We skip this branch if only the hash fragment has changed, as we don't want to trigger a lazy fetch in that case
                        applied = triggerLazyFetchForLeafSegments(cache, currentCache, flightSegmentPath, treePatch);
                        // since we re-used the stale cache's loading state & refreshed the data,
                        // update the `lastUsedTime` so that it can continue to be re-used for the next 30s
                        prefetchValues.lastUsedTime = navigatedAt;
                    } else {
                        applied = (0, _applyflightdata.applyFlightData)(navigatedAt, currentCache, cache, normalizedFlightData, prefetchValues);
                    }
                    const hardNavigate = (0, _shouldhardnavigate.shouldHardNavigate)(flightSegmentPathWithLeadingEmpty, currentTree);
                    if (hardNavigate) {
                        // Copy rsc for the root node of the cache.
                        cache.rsc = currentCache.rsc;
                        cache.prefetchRsc = currentCache.prefetchRsc;
                        (0, _invalidatecachebelowflightsegmentpath.invalidateCacheBelowFlightSegmentPath)(cache, currentCache, flightSegmentPath);
                        // Ensure the existing cache value is used when the cache was not invalidated.
                        mutable.cache = cache;
                    } else if (applied) {
                        mutable.cache = cache;
                        // If we applied the cache, we update the "current cache" value so any other
                        // segments in the FlightDataPath will be able to reference the updated cache.
                        currentCache = cache;
                    }
                    for (const subSegment of generateSegmentsFromPatch(treePatch)){
                        const scrollableSegmentPath = [
                            ...flightSegmentPath,
                            ...subSegment
                        ];
                        // Filter out the __DEFAULT__ paths as they shouldn't be scrolled to in this case.
                        if (scrollableSegmentPath[scrollableSegmentPath.length - 1] !== _segment.DEFAULT_SEGMENT_KEY) {
                            scrollableSegments.push(scrollableSegmentPath);
                        }
                    }
                }
                currentTree = newTree;
            }
        }
        mutable.patchedTree = currentTree;
        mutable.canonicalUrl = updatedCanonicalUrl;
        mutable.scrollableSegments = scrollableSegments;
        mutable.hashFragment = hash;
        mutable.shouldScroll = shouldScroll;
        return (0, _handlemutable.handleMutable)(state, mutable);
    }, ()=>state);
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=navigate-reducer.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/reducers/server-patch-reducer.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "serverPatchReducer", {
    enumerable: true,
    get: function() {
        return serverPatchReducer;
    }
});
const _createhreffromurl = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/create-href-from-url.js [app-ssr] (ecmascript)");
const _applyrouterstatepatchtotree = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js [app-ssr] (ecmascript)");
const _isnavigatingtonewrootlayout = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js [app-ssr] (ecmascript)");
const _navigatereducer = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js [app-ssr] (ecmascript)");
const _applyflightdata = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/apply-flight-data.js [app-ssr] (ecmascript)");
const _handlemutable = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/handle-mutable.js [app-ssr] (ecmascript)");
const _approuter = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/app-router.js [app-ssr] (ecmascript)");
function serverPatchReducer(state, action) {
    const { serverResponse: { flightData, canonicalUrl: canonicalUrlOverride }, navigatedAt } = action;
    const mutable = {};
    mutable.preserveCustomHistoryState = false;
    // Handle case when navigating to page in `pages` from `app`
    if (typeof flightData === 'string') {
        return (0, _navigatereducer.handleExternalUrl)(state, mutable, flightData, state.pushRef.pendingPush);
    }
    let currentTree = state.tree;
    let currentCache = state.cache;
    for (const normalizedFlightData of flightData){
        const { segmentPath: flightSegmentPath, tree: treePatch } = normalizedFlightData;
        const newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)([
            '',
            ...flightSegmentPath
        ], currentTree, treePatch, state.canonicalUrl);
        // `applyRouterStatePatchToTree` returns `null` when it determined that the server response is not applicable to the current tree.
        // In other words, the server responded with a tree that doesn't match what the client is currently rendering.
        // This can happen if the server patch action took longer to resolve than a subsequent navigation which would have changed the tree.
        // Previously this case triggered an MPA navigation but it should be safe to simply discard the server response rather than forcing
        // the entire page to reload.
        if (newTree === null) {
            return state;
        }
        if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {
            return (0, _navigatereducer.handleExternalUrl)(state, mutable, state.canonicalUrl, state.pushRef.pendingPush);
        }
        const canonicalUrlOverrideHref = canonicalUrlOverride ? (0, _createhreffromurl.createHrefFromUrl)(canonicalUrlOverride) : undefined;
        if (canonicalUrlOverrideHref) {
            mutable.canonicalUrl = canonicalUrlOverrideHref;
        }
        const cache = (0, _approuter.createEmptyCacheNode)();
        (0, _applyflightdata.applyFlightData)(navigatedAt, currentCache, cache, normalizedFlightData);
        mutable.patchedTree = newTree;
        mutable.cache = cache;
        currentCache = cache;
        currentTree = newTree;
    }
    return (0, _handlemutable.handleMutable)(state, mutable);
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=server-patch-reducer.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/reducers/restore-reducer.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "restoreReducer", {
    enumerable: true,
    get: function() {
        return restoreReducer;
    }
});
const _createhreffromurl = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/create-href-from-url.js [app-ssr] (ecmascript)");
const _computechangedpath = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/compute-changed-path.js [app-ssr] (ecmascript)");
const _pprnavigations = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/ppr-navigations.js [app-ssr] (ecmascript)");
function restoreReducer(state, action) {
    const { url, tree } = action;
    const href = (0, _createhreffromurl.createHrefFromUrl)(url);
    // This action is used to restore the router state from the history state.
    // However, it's possible that the history state no longer contains the `FlightRouterState`.
    // We will copy over the internal state on pushState/replaceState events, but if a history entry
    // occurred before hydration, or if the user navigated to a hash using a regular anchor link,
    // the history state will not contain the `FlightRouterState`.
    // In this case, we'll continue to use the existing tree so the router doesn't get into an invalid state.
    const treeToRestore = tree || state.tree;
    const oldCache = state.cache;
    const newCache = ("TURBOPACK compile-time falsy", 0) ? // prevents an unnecessary flash back to PPR state during a
    // back/forward navigation.
    "TURBOPACK unreachable" : oldCache;
    var _extractPathFromFlightRouterState;
    return {
        // Set canonical url
        canonicalUrl: href,
        pushRef: {
            pendingPush: false,
            mpaNavigation: false,
            // Ensures that the custom history state that was set is preserved when applying this update.
            preserveCustomHistoryState: true
        },
        focusAndScrollRef: state.focusAndScrollRef,
        cache: newCache,
        prefetchCache: state.prefetchCache,
        // Restore provided tree
        tree: treeToRestore,
        nextUrl: (_extractPathFromFlightRouterState = (0, _computechangedpath.extractPathFromFlightRouterState)(treeToRestore)) != null ? _extractPathFromFlightRouterState : url.pathname
    };
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=restore-reducer.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/handle-segment-mismatch.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "handleSegmentMismatch", {
    enumerable: true,
    get: function() {
        return handleSegmentMismatch;
    }
});
const _navigatereducer = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js [app-ssr] (ecmascript)");
function handleSegmentMismatch(state, action, treePatch) {
    if ("TURBOPACK compile-time truthy", 1) {
        console.warn('Performing hard navigation because your application experienced an unrecoverable error. If this keeps occurring, please file a Next.js issue.\n\n' + 'Reason: Segment mismatch\n' + ("Last Action: " + action.type + "\n\n") + ("Current Tree: " + JSON.stringify(state.tree) + "\n\n") + ("Tree Patch Payload: " + JSON.stringify(treePatch)));
    }
    return (0, _navigatereducer.handleExternalUrl)(state, {}, state.canonicalUrl, true);
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=handle-segment-mismatch.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "hasInterceptionRouteInCurrentTree", {
    enumerable: true,
    get: function() {
        return hasInterceptionRouteInCurrentTree;
    }
});
const _interceptionroutes = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/interception-routes.js [app-ssr] (ecmascript)");
function hasInterceptionRouteInCurrentTree(param) {
    let [segment, parallelRoutes] = param;
    // If we have a dynamic segment, it's marked as an interception route by the presence of the `i` suffix.
    if (Array.isArray(segment) && (segment[2] === 'di' || segment[2] === 'ci')) {
        return true;
    }
    // If segment is not an array, apply the existing string-based check
    if (typeof segment === 'string' && (0, _interceptionroutes.isInterceptionRouteAppPath)(segment)) {
        return true;
    }
    // Iterate through parallelRoutes if they exist
    if (parallelRoutes) {
        for(const key in parallelRoutes){
            if (hasInterceptionRouteInCurrentTree(parallelRoutes[key])) {
                return true;
            }
        }
    }
    return false;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=has-interception-route-in-current-tree.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/reducers/refresh-reducer.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "refreshReducer", {
    enumerable: true,
    get: function() {
        return refreshReducer;
    }
});
const _fetchserverresponse = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/fetch-server-response.js [app-ssr] (ecmascript)");
const _createhreffromurl = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/create-href-from-url.js [app-ssr] (ecmascript)");
const _applyrouterstatepatchtotree = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js [app-ssr] (ecmascript)");
const _isnavigatingtonewrootlayout = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js [app-ssr] (ecmascript)");
const _navigatereducer = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js [app-ssr] (ecmascript)");
const _handlemutable = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/handle-mutable.js [app-ssr] (ecmascript)");
const _filllazyitemstillleafwithhead = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js [app-ssr] (ecmascript)");
const _approuter = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/app-router.js [app-ssr] (ecmascript)");
const _handlesegmentmismatch = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/handle-segment-mismatch.js [app-ssr] (ecmascript)");
const _hasinterceptionrouteincurrenttree = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js [app-ssr] (ecmascript)");
const _refetchinactiveparallelsegments = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/refetch-inactive-parallel-segments.js [app-ssr] (ecmascript)");
const _segmentcache = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/segment-cache.js [app-ssr] (ecmascript)");
function refreshReducer(state, action) {
    const { origin } = action;
    const mutable = {};
    const href = state.canonicalUrl;
    let currentTree = state.tree;
    mutable.preserveCustomHistoryState = false;
    const cache = (0, _approuter.createEmptyCacheNode)();
    // If the current tree was intercepted, the nextUrl should be included in the request.
    // This is to ensure that the refresh request doesn't get intercepted, accidentally triggering the interception route.
    const includeNextUrl = (0, _hasinterceptionrouteincurrenttree.hasInterceptionRouteInCurrentTree)(state.tree);
    // TODO-APP: verify that `href` is not an external url.
    // Fetch data from the root of the tree.
    cache.lazyData = (0, _fetchserverresponse.fetchServerResponse)(new URL(href, origin), {
        flightRouterState: [
            currentTree[0],
            currentTree[1],
            currentTree[2],
            'refetch'
        ],
        nextUrl: includeNextUrl ? state.nextUrl : null
    });
    const navigatedAt = Date.now();
    return cache.lazyData.then(async (param)=>{
        let { flightData, canonicalUrl: canonicalUrlOverride } = param;
        // Handle case when navigating to page in `pages` from `app`
        if (typeof flightData === 'string') {
            return (0, _navigatereducer.handleExternalUrl)(state, mutable, flightData, state.pushRef.pendingPush);
        }
        // Remove cache.lazyData as it has been resolved at this point.
        cache.lazyData = null;
        for (const normalizedFlightData of flightData){
            const { tree: treePatch, seedData: cacheNodeSeedData, head, isRootRender } = normalizedFlightData;
            if (!isRootRender) {
                // TODO-APP: handle this case better
                console.log('REFRESH FAILED');
                return state;
            }
            const newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)([
                ''
            ], currentTree, treePatch, state.canonicalUrl);
            if (newTree === null) {
                return (0, _handlesegmentmismatch.handleSegmentMismatch)(state, action, treePatch);
            }
            if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {
                return (0, _navigatereducer.handleExternalUrl)(state, mutable, href, state.pushRef.pendingPush);
            }
            const canonicalUrlOverrideHref = canonicalUrlOverride ? (0, _createhreffromurl.createHrefFromUrl)(canonicalUrlOverride) : undefined;
            if (canonicalUrlOverride) {
                mutable.canonicalUrl = canonicalUrlOverrideHref;
            }
            // Handles case where prefetch only returns the router tree patch without rendered components.
            if (cacheNodeSeedData !== null) {
                const rsc = cacheNodeSeedData[1];
                const loading = cacheNodeSeedData[3];
                cache.rsc = rsc;
                cache.prefetchRsc = null;
                cache.loading = loading;
                (0, _filllazyitemstillleafwithhead.fillLazyItemsTillLeafWithHead)(navigatedAt, cache, undefined, treePatch, cacheNodeSeedData, head, undefined);
                if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
                ;
                else {
                    mutable.prefetchCache = new Map();
                }
            }
            await (0, _refetchinactiveparallelsegments.refreshInactiveParallelSegments)({
                navigatedAt,
                state,
                updatedTree: newTree,
                updatedCache: cache,
                includeNextUrl,
                canonicalUrl: mutable.canonicalUrl || state.canonicalUrl
            });
            mutable.cache = cache;
            mutable.patchedTree = newTree;
            currentTree = newTree;
        }
        return (0, _handlemutable.handleMutable)(state, mutable);
    }, ()=>state);
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=refresh-reducer.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/reducers/hmr-refresh-reducer.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "hmrRefreshReducer", {
    enumerable: true,
    get: function() {
        return hmrRefreshReducer;
    }
});
const _fetchserverresponse = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/fetch-server-response.js [app-ssr] (ecmascript)");
const _createhreffromurl = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/create-href-from-url.js [app-ssr] (ecmascript)");
const _applyrouterstatepatchtotree = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js [app-ssr] (ecmascript)");
const _isnavigatingtonewrootlayout = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js [app-ssr] (ecmascript)");
const _navigatereducer = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js [app-ssr] (ecmascript)");
const _handlemutable = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/handle-mutable.js [app-ssr] (ecmascript)");
const _applyflightdata = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/apply-flight-data.js [app-ssr] (ecmascript)");
const _approuter = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/app-router.js [app-ssr] (ecmascript)");
const _handlesegmentmismatch = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/handle-segment-mismatch.js [app-ssr] (ecmascript)");
const _hasinterceptionrouteincurrenttree = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js [app-ssr] (ecmascript)");
// A version of refresh reducer that keeps the cache around instead of wiping all of it.
function hmrRefreshReducerImpl(state, action) {
    const { origin } = action;
    const mutable = {};
    const href = state.canonicalUrl;
    mutable.preserveCustomHistoryState = false;
    const cache = (0, _approuter.createEmptyCacheNode)();
    // If the current tree was intercepted, the nextUrl should be included in the request.
    // This is to ensure that the refresh request doesn't get intercepted, accidentally triggering the interception route.
    const includeNextUrl = (0, _hasinterceptionrouteincurrenttree.hasInterceptionRouteInCurrentTree)(state.tree);
    // TODO-APP: verify that `href` is not an external url.
    // Fetch data from the root of the tree.
    const navigatedAt = Date.now();
    cache.lazyData = (0, _fetchserverresponse.fetchServerResponse)(new URL(href, origin), {
        flightRouterState: [
            state.tree[0],
            state.tree[1],
            state.tree[2],
            'refetch'
        ],
        nextUrl: includeNextUrl ? state.nextUrl : null,
        isHmrRefresh: true
    });
    return cache.lazyData.then((param)=>{
        let { flightData, canonicalUrl: canonicalUrlOverride } = param;
        // Handle case when navigating to page in `pages` from `app`
        if (typeof flightData === 'string') {
            return (0, _navigatereducer.handleExternalUrl)(state, mutable, flightData, state.pushRef.pendingPush);
        }
        // Remove cache.lazyData as it has been resolved at this point.
        cache.lazyData = null;
        let currentTree = state.tree;
        let currentCache = state.cache;
        for (const normalizedFlightData of flightData){
            const { tree: treePatch, isRootRender } = normalizedFlightData;
            if (!isRootRender) {
                // TODO-APP: handle this case better
                console.log('REFRESH FAILED');
                return state;
            }
            const newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)([
                ''
            ], currentTree, treePatch, state.canonicalUrl);
            if (newTree === null) {
                return (0, _handlesegmentmismatch.handleSegmentMismatch)(state, action, treePatch);
            }
            if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {
                return (0, _navigatereducer.handleExternalUrl)(state, mutable, href, state.pushRef.pendingPush);
            }
            const canonicalUrlOverrideHref = canonicalUrlOverride ? (0, _createhreffromurl.createHrefFromUrl)(canonicalUrlOverride) : undefined;
            if (canonicalUrlOverride) {
                mutable.canonicalUrl = canonicalUrlOverrideHref;
            }
            const applied = (0, _applyflightdata.applyFlightData)(navigatedAt, currentCache, cache, normalizedFlightData);
            if (applied) {
                mutable.cache = cache;
                currentCache = cache;
            }
            mutable.patchedTree = newTree;
            mutable.canonicalUrl = href;
            currentTree = newTree;
        }
        return (0, _handlemutable.handleMutable)(state, mutable);
    }, ()=>state);
}
function hmrRefreshReducerNoop(state, _action) {
    return state;
}
const hmrRefreshReducer = ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : hmrRefreshReducerImpl;
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=hmr-refresh-reducer.js.map
}}),
"[project]/node_modules/next/dist/client/assign-location.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "assignLocation", {
    enumerable: true,
    get: function() {
        return assignLocation;
    }
});
const _addbasepath = __turbopack_context__.r("[project]/node_modules/next/dist/client/add-base-path.js [app-ssr] (ecmascript)");
function assignLocation(location, url) {
    if (location.startsWith('.')) {
        const urlBase = url.origin + url.pathname;
        return new URL(// new URL('./relative', 'https://example.com/subdir').href -> 'https://example.com/relative'
        // new URL('./relative', 'https://example.com/subdir/').href -> 'https://example.com/subdir/relative'
        (urlBase.endsWith('/') ? urlBase : urlBase + '/') + location);
    }
    return new URL((0, _addbasepath.addBasePath)(location), url.href);
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=assign-location.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/server-reference-info.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    extractInfoFromServerReferenceId: null,
    omitUnusedArgs: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    extractInfoFromServerReferenceId: function() {
        return extractInfoFromServerReferenceId;
    },
    omitUnusedArgs: function() {
        return omitUnusedArgs;
    }
});
function extractInfoFromServerReferenceId(id) {
    const infoByte = parseInt(id.slice(0, 2), 16);
    const typeBit = infoByte >> 7 & 0x1;
    const argMask = infoByte >> 1 & 0x3f;
    const restArgs = infoByte & 0x1;
    const usedArgs = Array(6);
    for(let index = 0; index < 6; index++){
        const bitPosition = 5 - index;
        const bit = argMask >> bitPosition & 0x1;
        usedArgs[index] = bit === 1;
    }
    return {
        type: typeBit === 1 ? 'use-cache' : 'server-action',
        usedArgs: usedArgs,
        hasRestArgs: restArgs === 1
    };
}
function omitUnusedArgs(args, info) {
    const filteredArgs = new Array(args.length);
    for(let index = 0; index < args.length; index++){
        if (index < 6 && info.usedArgs[index] || // This assumes that the server reference info byte has the restArgs bit
        // set to 1 if there are more than 6 args.
        index >= 6 && info.hasRestArgs) {
            filteredArgs[index] = args[index];
        }
    }
    return filteredArgs;
} //# sourceMappingURL=server-reference-info.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/reducers/server-action-reducer.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "serverActionReducer", {
    enumerable: true,
    get: function() {
        return serverActionReducer;
    }
});
const _appcallserver = __turbopack_context__.r("[project]/node_modules/next/dist/client/app-call-server.js [app-ssr] (ecmascript)");
const _appfindsourcemapurl = __turbopack_context__.r("[project]/node_modules/next/dist/client/app-find-source-map-url.js [app-ssr] (ecmascript)");
const _approuterheaders = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/app-router-headers.js [app-ssr] (ecmascript)");
const _client = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-server-dom-turbopack-client.js [app-ssr] (ecmascript)");
const _routerreducertypes = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/router-reducer-types.js [app-ssr] (ecmascript)");
const _assignlocation = __turbopack_context__.r("[project]/node_modules/next/dist/client/assign-location.js [app-ssr] (ecmascript)");
const _createhreffromurl = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/create-href-from-url.js [app-ssr] (ecmascript)");
const _navigatereducer = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js [app-ssr] (ecmascript)");
const _applyrouterstatepatchtotree = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js [app-ssr] (ecmascript)");
const _isnavigatingtonewrootlayout = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js [app-ssr] (ecmascript)");
const _handlemutable = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/handle-mutable.js [app-ssr] (ecmascript)");
const _filllazyitemstillleafwithhead = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js [app-ssr] (ecmascript)");
const _approuter = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/app-router.js [app-ssr] (ecmascript)");
const _hasinterceptionrouteincurrenttree = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js [app-ssr] (ecmascript)");
const _handlesegmentmismatch = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/handle-segment-mismatch.js [app-ssr] (ecmascript)");
const _refetchinactiveparallelsegments = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/refetch-inactive-parallel-segments.js [app-ssr] (ecmascript)");
const _flightdatahelpers = __turbopack_context__.r("[project]/node_modules/next/dist/client/flight-data-helpers.js [app-ssr] (ecmascript)");
const _redirect = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/redirect.js [app-ssr] (ecmascript)");
const _redirecterror = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/redirect-error.js [app-ssr] (ecmascript)");
const _prefetchcacheutils = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js [app-ssr] (ecmascript)");
const _removebasepath = __turbopack_context__.r("[project]/node_modules/next/dist/client/remove-base-path.js [app-ssr] (ecmascript)");
const _hasbasepath = __turbopack_context__.r("[project]/node_modules/next/dist/client/has-base-path.js [app-ssr] (ecmascript)");
const _serverreferenceinfo = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/server-reference-info.js [app-ssr] (ecmascript)");
const _segmentcache = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/segment-cache.js [app-ssr] (ecmascript)");
const createFromFetch = _client.createFromFetch;
async function fetchServerAction(state, nextUrl, param) {
    let { actionId, actionArgs } = param;
    const temporaryReferences = (0, _client.createTemporaryReferenceSet)();
    const info = (0, _serverreferenceinfo.extractInfoFromServerReferenceId)(actionId);
    // TODO: Currently, we're only omitting unused args for the experimental "use
    // cache" functions. Once the server reference info byte feature is stable, we
    // should apply this to server actions as well.
    const usedArgs = info.type === 'use-cache' ? (0, _serverreferenceinfo.omitUnusedArgs)(actionArgs, info) : actionArgs;
    const body = await (0, _client.encodeReply)(usedArgs, {
        temporaryReferences
    });
    const res = await fetch(state.canonicalUrl, {
        method: 'POST',
        headers: {
            Accept: _approuterheaders.RSC_CONTENT_TYPE_HEADER,
            [_approuterheaders.ACTION_HEADER]: actionId,
            [_approuterheaders.NEXT_ROUTER_STATE_TREE_HEADER]: (0, _flightdatahelpers.prepareFlightRouterStateForRequest)(state.tree),
            ...("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : {},
            ...nextUrl ? {
                [_approuterheaders.NEXT_URL]: nextUrl
            } : {}
        },
        body
    });
    // Handle server actions that the server didn't recognize.
    const unrecognizedActionHeader = res.headers.get(_approuterheaders.NEXT_ACTION_NOT_FOUND_HEADER);
    if (unrecognizedActionHeader === '1') {
        throw Object.defineProperty(new Error('Server Action "' + actionId + '" was not found on the server. \nRead more: https://nextjs.org/docs/messages/failed-to-find-server-action'), "__NEXT_ERROR_CODE", {
            value: "E715",
            enumerable: false,
            configurable: true
        });
    }
    const redirectHeader = res.headers.get('x-action-redirect');
    const [location, _redirectType] = (redirectHeader == null ? void 0 : redirectHeader.split(';')) || [];
    let redirectType;
    switch(_redirectType){
        case 'push':
            redirectType = _redirecterror.RedirectType.push;
            break;
        case 'replace':
            redirectType = _redirecterror.RedirectType.replace;
            break;
        default:
            redirectType = undefined;
    }
    const isPrerender = !!res.headers.get(_approuterheaders.NEXT_IS_PRERENDER_HEADER);
    let revalidatedParts;
    try {
        const revalidatedHeader = JSON.parse(res.headers.get('x-action-revalidated') || '[[],0,0]');
        revalidatedParts = {
            paths: revalidatedHeader[0] || [],
            tag: !!revalidatedHeader[1],
            cookie: revalidatedHeader[2]
        };
    } catch (e) {
        revalidatedParts = NO_REVALIDATED_PARTS;
    }
    const redirectLocation = location ? (0, _assignlocation.assignLocation)(location, new URL(state.canonicalUrl, window.location.href)) : undefined;
    const contentType = res.headers.get('content-type');
    const isRscResponse = !!(contentType && contentType.startsWith(_approuterheaders.RSC_CONTENT_TYPE_HEADER));
    // Handle invalid server action responses.
    // A valid response must have `content-type: text/x-component`, unless it's an external redirect.
    // (external redirects have an 'x-action-redirect' header, but the body is an empty 'text/plain')
    if (!isRscResponse && !redirectLocation) {
        // The server can respond with a text/plain error message, but we'll fallback to something generic
        // if there isn't one.
        const message = res.status >= 400 && contentType === 'text/plain' ? await res.text() : 'An unexpected response was received from the server.';
        throw Object.defineProperty(new Error(message), "__NEXT_ERROR_CODE", {
            value: "E394",
            enumerable: false,
            configurable: true
        });
    }
    let actionResult;
    let actionFlightData;
    if (isRscResponse) {
        const response = await createFromFetch(Promise.resolve(res), {
            callServer: _appcallserver.callServer,
            findSourceMapURL: _appfindsourcemapurl.findSourceMapURL,
            temporaryReferences
        });
        // An internal redirect can send an RSC response, but does not have a useful `actionResult`.
        actionResult = redirectLocation ? undefined : response.a;
        actionFlightData = (0, _flightdatahelpers.normalizeFlightData)(response.f);
    } else {
        // An external redirect doesn't contain RSC data.
        actionResult = undefined;
        actionFlightData = undefined;
    }
    return {
        actionResult,
        actionFlightData,
        redirectLocation,
        redirectType,
        revalidatedParts,
        isPrerender
    };
}
const NO_REVALIDATED_PARTS = {
    paths: [],
    tag: false,
    cookie: false
};
function serverActionReducer(state, action) {
    const { resolve, reject } = action;
    const mutable = {};
    let currentTree = state.tree;
    mutable.preserveCustomHistoryState = false;
    // only pass along the `nextUrl` param (used for interception routes) if the current route was intercepted.
    // If the route has been intercepted, the action should be as well.
    // Otherwise the server action might be intercepted with the wrong action id
    // (ie, one that corresponds with the intercepted route)
    const nextUrl = state.nextUrl && (0, _hasinterceptionrouteincurrenttree.hasInterceptionRouteInCurrentTree)(state.tree) ? state.nextUrl : null;
    const navigatedAt = Date.now();
    return fetchServerAction(state, nextUrl, action).then(async (param)=>{
        let { actionResult, actionFlightData: flightData, redirectLocation, redirectType, isPrerender, revalidatedParts } = param;
        let redirectHref;
        // honor the redirect type instead of defaulting to push in case of server actions.
        if (redirectLocation) {
            if (redirectType === _redirecterror.RedirectType.replace) {
                state.pushRef.pendingPush = false;
                mutable.pendingPush = false;
            } else {
                state.pushRef.pendingPush = true;
                mutable.pendingPush = true;
            }
            redirectHref = (0, _createhreffromurl.createHrefFromUrl)(redirectLocation, false);
            mutable.canonicalUrl = redirectHref;
        }
        if (!flightData) {
            resolve(actionResult);
            // If there is a redirect but no flight data we need to do a mpaNavigation.
            if (redirectLocation) {
                return (0, _navigatereducer.handleExternalUrl)(state, mutable, redirectLocation.href, state.pushRef.pendingPush);
            }
            return state;
        }
        if (typeof flightData === 'string') {
            // Handle case when navigating to page in `pages` from `app`
            resolve(actionResult);
            return (0, _navigatereducer.handleExternalUrl)(state, mutable, flightData, state.pushRef.pendingPush);
        }
        const actionRevalidated = revalidatedParts.paths.length > 0 || revalidatedParts.tag || revalidatedParts.cookie;
        for (const normalizedFlightData of flightData){
            const { tree: treePatch, seedData: cacheNodeSeedData, head, isRootRender } = normalizedFlightData;
            if (!isRootRender) {
                // TODO-APP: handle this case better
                console.log('SERVER ACTION APPLY FAILED');
                resolve(actionResult);
                return state;
            }
            // Given the path can only have two items the items are only the router state and rsc for the root.
            const newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)([
                ''
            ], currentTree, treePatch, redirectHref ? redirectHref : state.canonicalUrl);
            if (newTree === null) {
                resolve(actionResult);
                return (0, _handlesegmentmismatch.handleSegmentMismatch)(state, action, treePatch);
            }
            if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {
                resolve(actionResult);
                return (0, _navigatereducer.handleExternalUrl)(state, mutable, redirectHref || state.canonicalUrl, state.pushRef.pendingPush);
            }
            // The server sent back RSC data for the server action, so we need to apply it to the cache.
            if (cacheNodeSeedData !== null) {
                const rsc = cacheNodeSeedData[1];
                const cache = (0, _approuter.createEmptyCacheNode)();
                cache.rsc = rsc;
                cache.prefetchRsc = null;
                cache.loading = cacheNodeSeedData[3];
                (0, _filllazyitemstillleafwithhead.fillLazyItemsTillLeafWithHead)(navigatedAt, cache, undefined, treePatch, cacheNodeSeedData, head, undefined);
                mutable.cache = cache;
                if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
                ;
                else {
                    mutable.prefetchCache = new Map();
                }
                if (actionRevalidated) {
                    await (0, _refetchinactiveparallelsegments.refreshInactiveParallelSegments)({
                        navigatedAt,
                        state,
                        updatedTree: newTree,
                        updatedCache: cache,
                        includeNextUrl: Boolean(nextUrl),
                        canonicalUrl: mutable.canonicalUrl || state.canonicalUrl
                    });
                }
            }
            mutable.patchedTree = newTree;
            currentTree = newTree;
        }
        if (redirectLocation && redirectHref) {
            if (!("TURBOPACK compile-time value", false) && !actionRevalidated) {
                // Because the RedirectBoundary will trigger a navigation, we need to seed the prefetch cache
                // with the FlightData that we got from the server action for the target page, so that it's
                // available when the page is navigated to and doesn't need to be re-fetched.
                // We only do this if the server action didn't revalidate any data, as in that case the
                // client cache will be cleared and the data will be re-fetched anyway.
                // NOTE: We don't do this in the Segment Cache implementation.
                // Dynamic data should never be placed into the cache, unless it's
                // "converted" to static data using <Link prefetch={true}>. What we
                // do instead is re-prefetch links and forms whenever the cache is
                // invalidated.
                (0, _prefetchcacheutils.createSeededPrefetchCacheEntry)({
                    url: redirectLocation,
                    data: {
                        flightData,
                        canonicalUrl: undefined,
                        couldBeIntercepted: false,
                        prerendered: false,
                        postponed: false,
                        // TODO: We should be able to set this if the server action
                        // returned a fully static response.
                        staleTime: -1
                    },
                    tree: state.tree,
                    prefetchCache: state.prefetchCache,
                    nextUrl: state.nextUrl,
                    kind: isPrerender ? _routerreducertypes.PrefetchKind.FULL : _routerreducertypes.PrefetchKind.AUTO
                });
                mutable.prefetchCache = state.prefetchCache;
            }
            // If the action triggered a redirect, the action promise will be rejected with
            // a redirect so that it's handled by RedirectBoundary as we won't have a valid
            // action result to resolve the promise with. This will effectively reset the state of
            // the component that called the action as the error boundary will remount the tree.
            // The status code doesn't matter here as the action handler will have already sent
            // a response with the correct status code.
            reject((0, _redirect.getRedirectError)((0, _hasbasepath.hasBasePath)(redirectHref) ? (0, _removebasepath.removeBasePath)(redirectHref) : redirectHref, redirectType || _redirecterror.RedirectType.push));
        } else {
            resolve(actionResult);
        }
        return (0, _handlemutable.handleMutable)(state, mutable);
    }, (e)=>{
        // When the server action is rejected we don't update the state and instead call the reject handler of the promise.
        reject(e);
        return state;
    });
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=server-action-reducer.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/router-reducer.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "reducer", {
    enumerable: true,
    get: function() {
        return reducer;
    }
});
const _routerreducertypes = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/router-reducer-types.js [app-ssr] (ecmascript)");
const _navigatereducer = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js [app-ssr] (ecmascript)");
const _serverpatchreducer = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/reducers/server-patch-reducer.js [app-ssr] (ecmascript)");
const _restorereducer = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/reducers/restore-reducer.js [app-ssr] (ecmascript)");
const _refreshreducer = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/reducers/refresh-reducer.js [app-ssr] (ecmascript)");
const _prefetchreducer = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js [app-ssr] (ecmascript)");
const _hmrrefreshreducer = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/reducers/hmr-refresh-reducer.js [app-ssr] (ecmascript)");
const _serveractionreducer = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/reducers/server-action-reducer.js [app-ssr] (ecmascript)");
/**
 * Reducer that handles the app-router state updates.
 */ function clientReducer(state, action) {
    switch(action.type){
        case _routerreducertypes.ACTION_NAVIGATE:
            {
                return (0, _navigatereducer.navigateReducer)(state, action);
            }
        case _routerreducertypes.ACTION_SERVER_PATCH:
            {
                return (0, _serverpatchreducer.serverPatchReducer)(state, action);
            }
        case _routerreducertypes.ACTION_RESTORE:
            {
                return (0, _restorereducer.restoreReducer)(state, action);
            }
        case _routerreducertypes.ACTION_REFRESH:
            {
                return (0, _refreshreducer.refreshReducer)(state, action);
            }
        case _routerreducertypes.ACTION_HMR_REFRESH:
            {
                return (0, _hmrrefreshreducer.hmrRefreshReducer)(state, action);
            }
        case _routerreducertypes.ACTION_PREFETCH:
            {
                return (0, _prefetchreducer.prefetchReducer)(state, action);
            }
        case _routerreducertypes.ACTION_SERVER_ACTION:
            {
                return (0, _serveractionreducer.serverActionReducer)(state, action);
            }
        // This case should never be hit as dispatch is strongly typed.
        default:
            throw Object.defineProperty(new Error('Unknown action'), "__NEXT_ERROR_CODE", {
                value: "E295",
                enumerable: false,
                configurable: true
            });
    }
}
function serverReducer(state, _action) {
    return state;
}
const reducer = ("TURBOPACK compile-time truthy", 1) ? serverReducer : "TURBOPACK unreachable";
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=router-reducer.js.map
}}),
"[project]/node_modules/next/dist/client/components/app-router-instance.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    createMutableActionQueue: null,
    dispatchNavigateAction: null,
    dispatchTraverseAction: null,
    getCurrentAppRouterState: null,
    publicAppRouterInstance: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    createMutableActionQueue: function() {
        return createMutableActionQueue;
    },
    dispatchNavigateAction: function() {
        return dispatchNavigateAction;
    },
    dispatchTraverseAction: function() {
        return dispatchTraverseAction;
    },
    getCurrentAppRouterState: function() {
        return getCurrentAppRouterState;
    },
    publicAppRouterInstance: function() {
        return publicAppRouterInstance;
    }
});
const _routerreducertypes = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/router-reducer-types.js [app-ssr] (ecmascript)");
const _routerreducer = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/router-reducer.js [app-ssr] (ecmascript)");
const _react = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
const _isthenable = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/is-thenable.js [app-ssr] (ecmascript)");
const _segmentcache = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/segment-cache.js [app-ssr] (ecmascript)");
const _useactionqueue = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/use-action-queue.js [app-ssr] (ecmascript)");
const _addbasepath = __turbopack_context__.r("[project]/node_modules/next/dist/client/add-base-path.js [app-ssr] (ecmascript)");
const _approuter = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/app-router.js [app-ssr] (ecmascript)");
const _prefetchreducer = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js [app-ssr] (ecmascript)");
const _links = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/links.js [app-ssr] (ecmascript)");
function runRemainingActions(actionQueue, setState) {
    if (actionQueue.pending !== null) {
        actionQueue.pending = actionQueue.pending.next;
        if (actionQueue.pending !== null) {
            // eslint-disable-next-line @typescript-eslint/no-use-before-define
            runAction({
                actionQueue,
                action: actionQueue.pending,
                setState
            });
        } else {
            // No more actions are pending, check if a refresh is needed
            if (actionQueue.needsRefresh) {
                actionQueue.needsRefresh = false;
                actionQueue.dispatch({
                    type: _routerreducertypes.ACTION_REFRESH,
                    origin: window.location.origin
                }, setState);
            }
        }
    }
}
async function runAction(param) {
    let { actionQueue, action, setState } = param;
    const prevState = actionQueue.state;
    actionQueue.pending = action;
    const payload = action.payload;
    const actionResult = actionQueue.action(prevState, payload);
    function handleResult(nextState) {
        // if we discarded this action, the state should also be discarded
        if (action.discarded) {
            return;
        }
        actionQueue.state = nextState;
        runRemainingActions(actionQueue, setState);
        action.resolve(nextState);
    }
    // if the action is a promise, set up a callback to resolve it
    if ((0, _isthenable.isThenable)(actionResult)) {
        actionResult.then(handleResult, (err)=>{
            runRemainingActions(actionQueue, setState);
            action.reject(err);
        });
    } else {
        handleResult(actionResult);
    }
}
function dispatchAction(actionQueue, payload, setState) {
    let resolvers = {
        resolve: setState,
        reject: ()=>{}
    };
    // most of the action types are async with the exception of restore
    // it's important that restore is handled quickly since it's fired on the popstate event
    // and we don't want to add any delay on a back/forward nav
    // this only creates a promise for the async actions
    if (payload.type !== _routerreducertypes.ACTION_RESTORE) {
        // Create the promise and assign the resolvers to the object.
        const deferredPromise = new Promise((resolve, reject)=>{
            resolvers = {
                resolve,
                reject
            };
        });
        (0, _react.startTransition)(()=>{
            // we immediately notify React of the pending promise -- the resolver is attached to the action node
            // and will be called when the associated action promise resolves
            setState(deferredPromise);
        });
    }
    const newAction = {
        payload,
        next: null,
        resolve: resolvers.resolve,
        reject: resolvers.reject
    };
    // Check if the queue is empty
    if (actionQueue.pending === null) {
        // The queue is empty, so add the action and start it immediately
        // Mark this action as the last in the queue
        actionQueue.last = newAction;
        runAction({
            actionQueue,
            action: newAction,
            setState
        });
    } else if (payload.type === _routerreducertypes.ACTION_NAVIGATE || payload.type === _routerreducertypes.ACTION_RESTORE) {
        // Navigations (including back/forward) take priority over any pending actions.
        // Mark the pending action as discarded (so the state is never applied) and start the navigation action immediately.
        actionQueue.pending.discarded = true;
        // The rest of the current queue should still execute after this navigation.
        // (Note that it can't contain any earlier navigations, because we always put those into `actionQueue.pending` by calling `runAction`)
        newAction.next = actionQueue.pending.next;
        // if the pending action was a server action, mark the queue as needing a refresh once events are processed
        if (actionQueue.pending.payload.type === _routerreducertypes.ACTION_SERVER_ACTION) {
            actionQueue.needsRefresh = true;
        }
        runAction({
            actionQueue,
            action: newAction,
            setState
        });
    } else {
        // The queue is not empty, so add the action to the end of the queue
        // It will be started by runRemainingActions after the previous action finishes
        if (actionQueue.last !== null) {
            actionQueue.last.next = newAction;
        }
        actionQueue.last = newAction;
    }
}
let globalActionQueue = null;
function createMutableActionQueue(initialState, instrumentationHooks) {
    const actionQueue = {
        state: initialState,
        dispatch: (payload, setState)=>dispatchAction(actionQueue, payload, setState),
        action: async (state, action)=>{
            const result = (0, _routerreducer.reducer)(state, action);
            return result;
        },
        pending: null,
        last: null,
        onRouterTransitionStart: instrumentationHooks !== null && typeof instrumentationHooks.onRouterTransitionStart === 'function' ? instrumentationHooks.onRouterTransitionStart : null
    };
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    return actionQueue;
}
function getCurrentAppRouterState() {
    return globalActionQueue !== null ? globalActionQueue.state : null;
}
function getAppRouterActionQueue() {
    if (globalActionQueue === null) {
        throw Object.defineProperty(new Error('Internal Next.js error: Router action dispatched before initialization.'), "__NEXT_ERROR_CODE", {
            value: "E668",
            enumerable: false,
            configurable: true
        });
    }
    return globalActionQueue;
}
function getProfilingHookForOnNavigationStart() {
    if (globalActionQueue !== null) {
        return globalActionQueue.onRouterTransitionStart;
    }
    return null;
}
function dispatchNavigateAction(href, navigateType, shouldScroll, linkInstanceRef) {
    // TODO: This stuff could just go into the reducer. Leaving as-is for now
    // since we're about to rewrite all the router reducer stuff anyway.
    const url = new URL((0, _addbasepath.addBasePath)(href), location.href);
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    (0, _links.setLinkForCurrentNavigation)(linkInstanceRef);
    const onRouterTransitionStart = getProfilingHookForOnNavigationStart();
    if (onRouterTransitionStart !== null) {
        onRouterTransitionStart(href, navigateType);
    }
    (0, _useactionqueue.dispatchAppRouterAction)({
        type: _routerreducertypes.ACTION_NAVIGATE,
        url,
        isExternalUrl: (0, _approuter.isExternalURL)(url),
        locationSearch: location.search,
        shouldScroll,
        navigateType,
        allowAliasing: true
    });
}
function dispatchTraverseAction(href, tree) {
    const onRouterTransitionStart = getProfilingHookForOnNavigationStart();
    if (onRouterTransitionStart !== null) {
        onRouterTransitionStart(href, 'traverse');
    }
    (0, _useactionqueue.dispatchAppRouterAction)({
        type: _routerreducertypes.ACTION_RESTORE,
        url: new URL(href),
        tree
    });
}
const publicAppRouterInstance = {
    back: ()=>window.history.back(),
    forward: ()=>window.history.forward(),
    prefetch: ("TURBOPACK compile-time falsy", 0) ? // cache. So we don't need to dispatch an action.
    "TURBOPACK unreachable" : (href, options)=>{
        // Use the old prefetch implementation.
        const actionQueue = getAppRouterActionQueue();
        const url = (0, _approuter.createPrefetchURL)(href);
        if (url !== null) {
            var _options_kind;
            // The prefetch reducer doesn't actually update any state or
            // trigger a rerender. It just writes to a mutable cache. So we
            // shouldn't bother calling setState/dispatch; we can just re-run
            // the reducer directly using the current state.
            // TODO: Refactor this away from a "reducer" so it's
            // less confusing.
            (0, _prefetchreducer.prefetchReducer)(actionQueue.state, {
                type: _routerreducertypes.ACTION_PREFETCH,
                url,
                kind: (_options_kind = options == null ? void 0 : options.kind) != null ? _options_kind : _routerreducertypes.PrefetchKind.FULL
            });
        }
    },
    replace: (href, options)=>{
        (0, _react.startTransition)(()=>{
            var _options_scroll;
            dispatchNavigateAction(href, 'replace', (_options_scroll = options == null ? void 0 : options.scroll) != null ? _options_scroll : true, null);
        });
    },
    push: (href, options)=>{
        (0, _react.startTransition)(()=>{
            var _options_scroll;
            dispatchNavigateAction(href, 'push', (_options_scroll = options == null ? void 0 : options.scroll) != null ? _options_scroll : true, null);
        });
    },
    refresh: ()=>{
        (0, _react.startTransition)(()=>{
            (0, _useactionqueue.dispatchAppRouterAction)({
                type: _routerreducertypes.ACTION_REFRESH,
                origin: window.location.origin
            });
        });
    },
    hmrRefresh: ()=>{
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        else {
            (0, _react.startTransition)(()=>{
                (0, _useactionqueue.dispatchAppRouterAction)({
                    type: _routerreducertypes.ACTION_HMR_REFRESH,
                    origin: window.location.origin
                });
            });
        }
    }
};
// Exists for debugging purposes. Don't use in application code.
if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=app-router-instance.js.map
}}),
"[project]/node_modules/next/dist/client/components/links.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    IDLE_LINK_STATUS: null,
    PENDING_LINK_STATUS: null,
    mountFormInstance: null,
    mountLinkInstance: null,
    onLinkVisibilityChanged: null,
    onNavigationIntent: null,
    pingVisibleLinks: null,
    setLinkForCurrentNavigation: null,
    unmountLinkForCurrentNavigation: null,
    unmountPrefetchableInstance: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    IDLE_LINK_STATUS: function() {
        return IDLE_LINK_STATUS;
    },
    PENDING_LINK_STATUS: function() {
        return PENDING_LINK_STATUS;
    },
    mountFormInstance: function() {
        return mountFormInstance;
    },
    mountLinkInstance: function() {
        return mountLinkInstance;
    },
    onLinkVisibilityChanged: function() {
        return onLinkVisibilityChanged;
    },
    onNavigationIntent: function() {
        return onNavigationIntent;
    },
    pingVisibleLinks: function() {
        return pingVisibleLinks;
    },
    setLinkForCurrentNavigation: function() {
        return setLinkForCurrentNavigation;
    },
    unmountLinkForCurrentNavigation: function() {
        return unmountLinkForCurrentNavigation;
    },
    unmountPrefetchableInstance: function() {
        return unmountPrefetchableInstance;
    }
});
const _approuterinstance = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/app-router-instance.js [app-ssr] (ecmascript)");
const _approuter = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/app-router.js [app-ssr] (ecmascript)");
const _routerreducertypes = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/router-reducer-types.js [app-ssr] (ecmascript)");
const _segmentcache = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/segment-cache.js [app-ssr] (ecmascript)");
const _react = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
// Tracks the most recently navigated link instance. When null, indicates
// the current navigation was not initiated by a link click.
let linkForMostRecentNavigation = null;
const PENDING_LINK_STATUS = {
    pending: true
};
const IDLE_LINK_STATUS = {
    pending: false
};
function setLinkForCurrentNavigation(link) {
    (0, _react.startTransition)(()=>{
        linkForMostRecentNavigation == null ? void 0 : linkForMostRecentNavigation.setOptimisticLinkStatus(IDLE_LINK_STATUS);
        link == null ? void 0 : link.setOptimisticLinkStatus(PENDING_LINK_STATUS);
        linkForMostRecentNavigation = link;
    });
}
function unmountLinkForCurrentNavigation(link) {
    if (linkForMostRecentNavigation === link) {
        linkForMostRecentNavigation = null;
    }
}
// Use a WeakMap to associate a Link instance with its DOM element. This is
// used by the IntersectionObserver to track the link's visibility.
const prefetchable = typeof WeakMap === 'function' ? new WeakMap() : new Map();
// A Set of the currently visible links. We re-prefetch visible links after a
// cache invalidation, or when the current URL changes. It's a separate data
// structure from the WeakMap above because only the visible links need to
// be enumerated.
const prefetchableAndVisible = new Set();
// A single IntersectionObserver instance shared by all <Link> components.
const observer = typeof IntersectionObserver === 'function' ? new IntersectionObserver(handleIntersect, {
    rootMargin: '200px'
}) : null;
function observeVisibility(element, instance) {
    const existingInstance = prefetchable.get(element);
    if (existingInstance !== undefined) {
        // This shouldn't happen because each <Link> component should have its own
        // anchor tag instance, but it's defensive coding to avoid a memory leak in
        // case there's a logical error somewhere else.
        unmountPrefetchableInstance(element);
    }
    // Only track prefetchable links that have a valid prefetch URL
    prefetchable.set(element, instance);
    if (observer !== null) {
        observer.observe(element);
    }
}
function coercePrefetchableUrl(href) {
    try {
        return (0, _approuter.createPrefetchURL)(href);
    } catch (e) {
        // createPrefetchURL sometimes throws an error if an invalid URL is
        // provided, though I'm not sure if it's actually necessary.
        // TODO: Consider removing the throw from the inner function, or change it
        // to reportError. Or maybe the error isn't even necessary for automatic
        // prefetches, just navigations.
        const reportErrorFn = typeof reportError === 'function' ? reportError : console.error;
        reportErrorFn("Cannot prefetch '" + href + "' because it cannot be converted to a URL.");
        return null;
    }
}
function mountLinkInstance(element, href, router, kind, prefetchEnabled, setOptimisticLinkStatus) {
    if (prefetchEnabled) {
        const prefetchURL = coercePrefetchableUrl(href);
        if (prefetchURL !== null) {
            const instance = {
                router,
                kind,
                isVisible: false,
                prefetchTask: null,
                prefetchHref: prefetchURL.href,
                setOptimisticLinkStatus
            };
            // We only observe the link's visibility if it's prefetchable. For
            // example, this excludes links to external URLs.
            observeVisibility(element, instance);
            return instance;
        }
    }
    // If the link is not prefetchable, we still create an instance so we can
    // track its optimistic state (i.e. useLinkStatus).
    const instance = {
        router,
        kind,
        isVisible: false,
        prefetchTask: null,
        prefetchHref: null,
        setOptimisticLinkStatus
    };
    return instance;
}
function mountFormInstance(element, href, router, kind) {
    const prefetchURL = coercePrefetchableUrl(href);
    if (prefetchURL === null) {
        // This href is not prefetchable, so we don't track it.
        // TODO: We currently observe/unobserve a form every time its href changes.
        // For Links, this isn't a big deal because the href doesn't usually change,
        // but for forms it's extremely common. We should optimize this.
        return;
    }
    const instance = {
        router,
        kind,
        isVisible: false,
        prefetchTask: null,
        prefetchHref: prefetchURL.href,
        setOptimisticLinkStatus: null
    };
    observeVisibility(element, instance);
}
function unmountPrefetchableInstance(element) {
    const instance = prefetchable.get(element);
    if (instance !== undefined) {
        prefetchable.delete(element);
        prefetchableAndVisible.delete(instance);
        const prefetchTask = instance.prefetchTask;
        if (prefetchTask !== null) {
            (0, _segmentcache.cancelPrefetchTask)(prefetchTask);
        }
    }
    if (observer !== null) {
        observer.unobserve(element);
    }
}
function handleIntersect(entries) {
    for (const entry of entries){
        // Some extremely old browsers or polyfills don't reliably support
        // isIntersecting so we check intersectionRatio instead. (Do we care? Not
        // really. But whatever this is fine.)
        const isVisible = entry.intersectionRatio > 0;
        onLinkVisibilityChanged(entry.target, isVisible);
    }
}
function onLinkVisibilityChanged(element, isVisible) {
    if ("TURBOPACK compile-time truthy", 1) {
        // Prefetching on viewport is disabled in development for performance
        // reasons, because it requires compiling the target page.
        // TODO: Investigate re-enabling this.
        return;
    }
    //TURBOPACK unreachable
    ;
    const instance = undefined;
}
function onNavigationIntent(element, unstable_upgradeToDynamicPrefetch) {
    const instance = prefetchable.get(element);
    if (instance === undefined) {
        return;
    }
    // Prefetch the link on hover/touchstart.
    if (instance !== undefined) {
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        rescheduleLinkPrefetch(instance, _segmentcache.PrefetchPriority.Intent);
    }
}
function rescheduleLinkPrefetch(instance, priority) {
    const existingPrefetchTask = instance.prefetchTask;
    if (!instance.isVisible) {
        // Cancel any in-progress prefetch task. (If it already finished then this
        // is a no-op.)
        if (existingPrefetchTask !== null) {
            (0, _segmentcache.cancelPrefetchTask)(existingPrefetchTask);
        }
        // We don't need to reset the prefetchTask to null upon cancellation; an
        // old task object can be rescheduled with reschedulePrefetchTask. This is a
        // micro-optimization but also makes the code simpler (don't need to
        // worry about whether an old task object is stale).
        return;
    }
    if ("TURBOPACK compile-time truthy", 1) {
        // The old prefetch implementation does not have different priority levels.
        // Just schedule a new prefetch task.
        prefetchWithOldCacheImplementation(instance);
        return;
    }
    //TURBOPACK unreachable
    ;
    const appRouterState = undefined;
}
function pingVisibleLinks(nextUrl, tree) {
    // For each currently visible link, cancel the existing prefetch task (if it
    // exists) and schedule a new one. This is effectively the same as if all the
    // visible links left and then re-entered the viewport.
    //
    // This is called when the Next-Url or the base tree changes, since those
    // may affect the result of a prefetch task. It's also called after a
    // cache invalidation.
    for (const instance of prefetchableAndVisible){
        const task = instance.prefetchTask;
        if (task !== null && !(0, _segmentcache.isPrefetchTaskDirty)(task, nextUrl, tree)) {
            continue;
        }
        // Something changed. Cancel the existing prefetch task and schedule a
        // new one.
        if (task !== null) {
            (0, _segmentcache.cancelPrefetchTask)(task);
        }
        const cacheKey = (0, _segmentcache.createCacheKey)(instance.prefetchHref, nextUrl);
        instance.prefetchTask = (0, _segmentcache.schedulePrefetchTask)(cacheKey, tree, instance.kind === _routerreducertypes.PrefetchKind.FULL, _segmentcache.PrefetchPriority.Default, null);
    }
}
function prefetchWithOldCacheImplementation(instance) {
    // This is the path used when the Segment Cache is not enabled.
    if ("TURBOPACK compile-time truthy", 1) {
        return;
    }
    //TURBOPACK unreachable
    ;
    const doPrefetch = undefined;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=links.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/router/utils/is-local-url.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "isLocalURL", {
    enumerable: true,
    get: function() {
        return isLocalURL;
    }
});
const _utils = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/utils.js [app-ssr] (ecmascript)");
const _hasbasepath = __turbopack_context__.r("[project]/node_modules/next/dist/client/has-base-path.js [app-ssr] (ecmascript)");
function isLocalURL(url) {
    // prevent a hydration mismatch on href for url with anchor refs
    if (!(0, _utils.isAbsoluteUrl)(url)) return true;
    try {
        // absolute urls can be local if they are on the same origin
        const locationOrigin = (0, _utils.getLocationOrigin)();
        const resolved = new URL(url, locationOrigin);
        return resolved.origin === locationOrigin && (0, _hasbasepath.hasBasePath)(resolved.pathname);
    } catch (_) {
        return false;
    }
} //# sourceMappingURL=is-local-url.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/utils/error-once.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "errorOnce", {
    enumerable: true,
    get: function() {
        return errorOnce;
    }
});
let errorOnce = (_)=>{};
if ("TURBOPACK compile-time truthy", 1) {
    const errors = new Set();
    errorOnce = (msg)=>{
        if (!errors.has(msg)) {
            console.error(msg);
        }
        errors.add(msg);
    };
} //# sourceMappingURL=error-once.js.map
}}),
"[project]/node_modules/next/dist/client/app-dir/link.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    default: null,
    useLinkStatus: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    /**
 * A React component that extends the HTML `<a>` element to provide
 * [prefetching](https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)
 * and client-side navigation. This is the primary way to navigate between routes in Next.js.
 *
 * @remarks
 * - Prefetching is only enabled in production.
 *
 * @see https://nextjs.org/docs/app/api-reference/components/link
 */ default: function() {
        return LinkComponent;
    },
    useLinkStatus: function() {
        return useLinkStatus;
    }
});
const _interop_require_wildcard = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [app-ssr] (ecmascript)");
const _jsxruntime = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js [app-ssr] (ecmascript)");
const _react = /*#__PURE__*/ _interop_require_wildcard._(__turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)"));
const _formaturl = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/format-url.js [app-ssr] (ecmascript)");
const _approutercontextsharedruntime = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/contexts/app-router-context.js [app-ssr] (ecmascript)");
const _routerreducertypes = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/router-reducer-types.js [app-ssr] (ecmascript)");
const _usemergedref = __turbopack_context__.r("[project]/node_modules/next/dist/client/use-merged-ref.js [app-ssr] (ecmascript)");
const _utils = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/utils.js [app-ssr] (ecmascript)");
const _addbasepath = __turbopack_context__.r("[project]/node_modules/next/dist/client/add-base-path.js [app-ssr] (ecmascript)");
const _warnonce = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/utils/warn-once.js [app-ssr] (ecmascript)");
const _links = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/links.js [app-ssr] (ecmascript)");
const _islocalurl = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/is-local-url.js [app-ssr] (ecmascript)");
const _approuterinstance = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/app-router-instance.js [app-ssr] (ecmascript)");
const _erroronce = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/utils/error-once.js [app-ssr] (ecmascript)");
function isModifiedEvent(event) {
    const eventTarget = event.currentTarget;
    const target = eventTarget.getAttribute('target');
    return target && target !== '_self' || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey || // triggers resource download
    event.nativeEvent && event.nativeEvent.which === 2;
}
function linkClicked(e, href, as, linkInstanceRef, replace, scroll, onNavigate) {
    const { nodeName } = e.currentTarget;
    // anchors inside an svg have a lowercase nodeName
    const isAnchorNodeName = nodeName.toUpperCase() === 'A';
    if (isAnchorNodeName && isModifiedEvent(e) || e.currentTarget.hasAttribute('download')) {
        // ignore click for browsers default behavior
        return;
    }
    if (!(0, _islocalurl.isLocalURL)(href)) {
        if (replace) {
            // browser default behavior does not replace the history state
            // so we need to do it manually
            e.preventDefault();
            location.replace(href);
        }
        // ignore click for browsers default behavior
        return;
    }
    e.preventDefault();
    if (onNavigate) {
        let isDefaultPrevented = false;
        onNavigate({
            preventDefault: ()=>{
                isDefaultPrevented = true;
            }
        });
        if (isDefaultPrevented) {
            return;
        }
    }
    _react.default.startTransition(()=>{
        (0, _approuterinstance.dispatchNavigateAction)(as || href, replace ? 'replace' : 'push', scroll != null ? scroll : true, linkInstanceRef.current);
    });
}
function formatStringOrUrl(urlObjOrString) {
    if (typeof urlObjOrString === 'string') {
        return urlObjOrString;
    }
    return (0, _formaturl.formatUrl)(urlObjOrString);
}
function LinkComponent(props) {
    const [linkStatus, setOptimisticLinkStatus] = (0, _react.useOptimistic)(_links.IDLE_LINK_STATUS);
    let children;
    const linkInstanceRef = (0, _react.useRef)(null);
    const { href: hrefProp, as: asProp, children: childrenProp, prefetch: prefetchProp = null, passHref, replace, shallow, scroll, onClick, onMouseEnter: onMouseEnterProp, onTouchStart: onTouchStartProp, legacyBehavior = false, onNavigate, ref: forwardedRef, unstable_dynamicOnHover, ...restProps } = props;
    children = childrenProp;
    if (legacyBehavior && (typeof children === 'string' || typeof children === 'number')) {
        children = /*#__PURE__*/ (0, _jsxruntime.jsx)("a", {
            children: children
        });
    }
    const router = _react.default.useContext(_approutercontextsharedruntime.AppRouterContext);
    const prefetchEnabled = prefetchProp !== false;
    /**
   * The possible states for prefetch are:
   * - null: this is the default "auto" mode, where we will prefetch partially if the link is in the viewport
   * - true: we will prefetch if the link is visible and prefetch the full page, not just partially
   * - false: we will not prefetch if in the viewport at all
   * - 'unstable_dynamicOnHover': this starts in "auto" mode, but switches to "full" when the link is hovered
   */ const appPrefetchKind = prefetchProp === null || prefetchProp === 'auto' ? _routerreducertypes.PrefetchKind.AUTO : _routerreducertypes.PrefetchKind.FULL;
    if ("TURBOPACK compile-time truthy", 1) {
        function createPropError(args) {
            return Object.defineProperty(new Error("Failed prop type: The prop `" + args.key + "` expects a " + args.expected + " in `<Link>`, but got `" + args.actual + "` instead." + (("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : '')), "__NEXT_ERROR_CODE", {
                value: "E319",
                enumerable: false,
                configurable: true
            });
        }
        // TypeScript trick for type-guarding:
        const requiredPropsGuard = {
            href: true
        };
        const requiredProps = Object.keys(requiredPropsGuard);
        requiredProps.forEach((key)=>{
            if (key === 'href') {
                if (props[key] == null || typeof props[key] !== 'string' && typeof props[key] !== 'object') {
                    throw createPropError({
                        key,
                        expected: '`string` or `object`',
                        actual: props[key] === null ? 'null' : typeof props[key]
                    });
                }
            } else {
                // TypeScript trick for type-guarding:
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const _ = key;
            }
        });
        // TypeScript trick for type-guarding:
        const optionalPropsGuard = {
            as: true,
            replace: true,
            scroll: true,
            shallow: true,
            passHref: true,
            prefetch: true,
            unstable_dynamicOnHover: true,
            onClick: true,
            onMouseEnter: true,
            onTouchStart: true,
            legacyBehavior: true,
            onNavigate: true
        };
        const optionalProps = Object.keys(optionalPropsGuard);
        optionalProps.forEach((key)=>{
            const valType = typeof props[key];
            if (key === 'as') {
                if (props[key] && valType !== 'string' && valType !== 'object') {
                    throw createPropError({
                        key,
                        expected: '`string` or `object`',
                        actual: valType
                    });
                }
            } else if (key === 'onClick' || key === 'onMouseEnter' || key === 'onTouchStart' || key === 'onNavigate') {
                if (props[key] && valType !== 'function') {
                    throw createPropError({
                        key,
                        expected: '`function`',
                        actual: valType
                    });
                }
            } else if (key === 'replace' || key === 'scroll' || key === 'shallow' || key === 'passHref' || key === 'legacyBehavior' || key === 'unstable_dynamicOnHover') {
                if (props[key] != null && valType !== 'boolean') {
                    throw createPropError({
                        key,
                        expected: '`boolean`',
                        actual: valType
                    });
                }
            } else if (key === 'prefetch') {
                if (props[key] != null && valType !== 'boolean' && props[key] !== 'auto') {
                    throw createPropError({
                        key,
                        expected: '`boolean | "auto"`',
                        actual: valType
                    });
                }
            } else {
                // TypeScript trick for type-guarding:
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const _ = key;
            }
        });
    }
    if ("TURBOPACK compile-time truthy", 1) {
        if (props.locale) {
            (0, _warnonce.warnOnce)('The `locale` prop is not supported in `next/link` while using the `app` router. Read more about app router internalization: https://nextjs.org/docs/app/building-your-application/routing/internationalization');
        }
        if (!asProp) {
            let href;
            if (typeof hrefProp === 'string') {
                href = hrefProp;
            } else if (typeof hrefProp === 'object' && typeof hrefProp.pathname === 'string') {
                href = hrefProp.pathname;
            }
            if (href) {
                const hasDynamicSegment = href.split('/').some((segment)=>segment.startsWith('[') && segment.endsWith(']'));
                if (hasDynamicSegment) {
                    throw Object.defineProperty(new Error("Dynamic href `" + href + "` found in <Link> while using the `/app` router, this is not supported. Read more: https://nextjs.org/docs/messages/app-dir-dynamic-href"), "__NEXT_ERROR_CODE", {
                        value: "E267",
                        enumerable: false,
                        configurable: true
                    });
                }
            }
        }
    }
    const { href, as } = _react.default.useMemo(()=>{
        const resolvedHref = formatStringOrUrl(hrefProp);
        return {
            href: resolvedHref,
            as: asProp ? formatStringOrUrl(asProp) : resolvedHref
        };
    }, [
        hrefProp,
        asProp
    ]);
    // This will return the first child, if multiple are provided it will throw an error
    let child;
    if (legacyBehavior) {
        if ("TURBOPACK compile-time truthy", 1) {
            if (onClick) {
                console.warn('"onClick" was passed to <Link> with `href` of `' + hrefProp + '` but "legacyBehavior" was set. The legacy behavior requires onClick be set on the child of next/link');
            }
            if (onMouseEnterProp) {
                console.warn('"onMouseEnter" was passed to <Link> with `href` of `' + hrefProp + '` but "legacyBehavior" was set. The legacy behavior requires onMouseEnter be set on the child of next/link');
            }
            try {
                child = _react.default.Children.only(children);
            } catch (err) {
                if (!children) {
                    throw Object.defineProperty(new Error("No children were passed to <Link> with `href` of `" + hrefProp + "` but one child is required https://nextjs.org/docs/messages/link-no-children"), "__NEXT_ERROR_CODE", {
                        value: "E320",
                        enumerable: false,
                        configurable: true
                    });
                }
                throw Object.defineProperty(new Error("Multiple children were passed to <Link> with `href` of `" + hrefProp + "` but only one child is supported https://nextjs.org/docs/messages/link-multiple-children" + (("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : '')), "__NEXT_ERROR_CODE", {
                    value: "E266",
                    enumerable: false,
                    configurable: true
                });
            }
        } else //TURBOPACK unreachable
        ;
    } else {
        if ("TURBOPACK compile-time truthy", 1) {
            if ((children == null ? void 0 : children.type) === 'a') {
                throw Object.defineProperty(new Error('Invalid <Link> with <a> child. Please remove <a> or use <Link legacyBehavior>.\nLearn more: https://nextjs.org/docs/messages/invalid-new-link-with-extra-anchor'), "__NEXT_ERROR_CODE", {
                    value: "E209",
                    enumerable: false,
                    configurable: true
                });
            }
        }
    }
    const childRef = legacyBehavior ? child && typeof child === 'object' && child.ref : forwardedRef;
    // Use a callback ref to attach an IntersectionObserver to the anchor tag on
    // mount. In the future we will also use this to keep track of all the
    // currently mounted <Link> instances, e.g. so we can re-prefetch them after
    // a revalidation or refresh.
    const observeLinkVisibilityOnMount = _react.default.useCallback((element)=>{
        if (router !== null) {
            linkInstanceRef.current = (0, _links.mountLinkInstance)(element, href, router, appPrefetchKind, prefetchEnabled, setOptimisticLinkStatus);
        }
        return ()=>{
            if (linkInstanceRef.current) {
                (0, _links.unmountLinkForCurrentNavigation)(linkInstanceRef.current);
                linkInstanceRef.current = null;
            }
            (0, _links.unmountPrefetchableInstance)(element);
        };
    }, [
        prefetchEnabled,
        href,
        router,
        appPrefetchKind,
        setOptimisticLinkStatus
    ]);
    const mergedRef = (0, _usemergedref.useMergedRef)(observeLinkVisibilityOnMount, childRef);
    const childProps = {
        ref: mergedRef,
        onClick (e) {
            if ("TURBOPACK compile-time truthy", 1) {
                if (!e) {
                    throw Object.defineProperty(new Error('Component rendered inside next/link has to pass click event to "onClick" prop.'), "__NEXT_ERROR_CODE", {
                        value: "E312",
                        enumerable: false,
                        configurable: true
                    });
                }
            }
            if (!legacyBehavior && typeof onClick === 'function') {
                onClick(e);
            }
            if (legacyBehavior && child.props && typeof child.props.onClick === 'function') {
                child.props.onClick(e);
            }
            if (!router) {
                return;
            }
            if (e.defaultPrevented) {
                return;
            }
            linkClicked(e, href, as, linkInstanceRef, replace, scroll, onNavigate);
        },
        onMouseEnter (e) {
            if (!legacyBehavior && typeof onMouseEnterProp === 'function') {
                onMouseEnterProp(e);
            }
            if (legacyBehavior && child.props && typeof child.props.onMouseEnter === 'function') {
                child.props.onMouseEnter(e);
            }
            if (!router) {
                return;
            }
            if ("TURBOPACK compile-time truthy", 1) {
                return;
            }
            //TURBOPACK unreachable
            ;
            const upgradeToDynamicPrefetch = undefined;
        },
        onTouchStart: ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : function onTouchStart(e) {
            if (!legacyBehavior && typeof onTouchStartProp === 'function') {
                onTouchStartProp(e);
            }
            if (legacyBehavior && child.props && typeof child.props.onTouchStart === 'function') {
                child.props.onTouchStart(e);
            }
            if (!router) {
                return;
            }
            if (!prefetchEnabled) {
                return;
            }
            const upgradeToDynamicPrefetch = unstable_dynamicOnHover === true;
            (0, _links.onNavigationIntent)(e.currentTarget, upgradeToDynamicPrefetch);
        }
    };
    // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is
    // defined, we specify the current 'href', so that repetition is not needed by the user.
    // If the url is absolute, we can bypass the logic to prepend the basePath.
    if ((0, _utils.isAbsoluteUrl)(as)) {
        childProps.href = as;
    } else if (!legacyBehavior || passHref || child.type === 'a' && !('href' in child.props)) {
        childProps.href = (0, _addbasepath.addBasePath)(as);
    }
    let link;
    if (legacyBehavior) {
        if ("TURBOPACK compile-time truthy", 1) {
            (0, _erroronce.errorOnce)('`legacyBehavior` is deprecated and will be removed in a future ' + 'release. A codemod is available to upgrade your components:\n\n' + 'npx @next/codemod@latest new-link .\n\n' + 'Learn more: https://nextjs.org/docs/app/building-your-application/upgrading/codemods#remove-a-tags-from-link-components');
        }
        link = /*#__PURE__*/ _react.default.cloneElement(child, childProps);
    } else {
        link = /*#__PURE__*/ (0, _jsxruntime.jsx)("a", {
            ...restProps,
            ...childProps,
            children: children
        });
    }
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(LinkStatusContext.Provider, {
        value: linkStatus,
        children: link
    });
}
const LinkStatusContext = /*#__PURE__*/ (0, _react.createContext)(_links.IDLE_LINK_STATUS);
const useLinkStatus = ()=>{
    return (0, _react.useContext)(LinkStatusContext);
};
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=link.js.map
}}),
"[project]/node_modules/@radix-ui/react-compose-refs/dist/index.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// packages/react/compose-refs/src/compose-refs.tsx
__turbopack_context__.s({
    "composeRefs": ()=>composeRefs,
    "useComposedRefs": ()=>useComposedRefs
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
;
function setRef(ref, value) {
    if (typeof ref === "function") {
        return ref(value);
    } else if (ref !== null && ref !== void 0) {
        ref.current = value;
    }
}
function composeRefs(...refs) {
    return (node)=>{
        let hasCleanup = false;
        const cleanups = refs.map((ref)=>{
            const cleanup = setRef(ref, node);
            if (!hasCleanup && typeof cleanup == "function") {
                hasCleanup = true;
            }
            return cleanup;
        });
        if (hasCleanup) {
            return ()=>{
                for(let i = 0; i < cleanups.length; i++){
                    const cleanup = cleanups[i];
                    if (typeof cleanup == "function") {
                        cleanup();
                    } else {
                        setRef(refs[i], null);
                    }
                }
            };
        }
    };
}
function useComposedRefs(...refs) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useCallback"](composeRefs(...refs), refs);
}
;
 //# sourceMappingURL=index.mjs.map
}),
"[project]/node_modules/@radix-ui/react-slot/dist/index.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// src/slot.tsx
__turbopack_context__.s({
    "Root": ()=>Slot,
    "Slot": ()=>Slot,
    "Slottable": ()=>Slottable,
    "createSlot": ()=>createSlot,
    "createSlottable": ()=>createSlottable
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$compose$2d$refs$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@radix-ui/react-compose-refs/dist/index.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js [app-ssr] (ecmascript)");
;
;
;
// @__NO_SIDE_EFFECTS__
function createSlot(ownerName) {
    const SlotClone = /* @__PURE__ */ createSlotClone(ownerName);
    const Slot2 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["forwardRef"]((props, forwardedRef)=>{
        const { children, ...slotProps } = props;
        const childrenArray = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Children"].toArray(children);
        const slottable = childrenArray.find(isSlottable);
        if (slottable) {
            const newElement = slottable.props.children;
            const newChildren = childrenArray.map((child)=>{
                if (child === slottable) {
                    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Children"].count(newElement) > 1) return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Children"].only(null);
                    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isValidElement"](newElement) ? newElement.props.children : null;
                } else {
                    return child;
                }
            });
            return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])(SlotClone, {
                ...slotProps,
                ref: forwardedRef,
                children: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isValidElement"](newElement) ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cloneElement"](newElement, void 0, newChildren) : null
            });
        }
        return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])(SlotClone, {
            ...slotProps,
            ref: forwardedRef,
            children
        });
    });
    Slot2.displayName = `${ownerName}.Slot`;
    return Slot2;
}
var Slot = /* @__PURE__ */ createSlot("Slot");
// @__NO_SIDE_EFFECTS__
function createSlotClone(ownerName) {
    const SlotClone = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["forwardRef"]((props, forwardedRef)=>{
        const { children, ...slotProps } = props;
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isValidElement"](children)) {
            const childrenRef = getElementRef(children);
            const props2 = mergeProps(slotProps, children.props);
            if (children.type !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Fragment"]) {
                props2.ref = forwardedRef ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$compose$2d$refs$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["composeRefs"])(forwardedRef, childrenRef) : childrenRef;
            }
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cloneElement"](children, props2);
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Children"].count(children) > 1 ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Children"].only(null) : null;
    });
    SlotClone.displayName = `${ownerName}.SlotClone`;
    return SlotClone;
}
var SLOTTABLE_IDENTIFIER = Symbol("radix.slottable");
// @__NO_SIDE_EFFECTS__
function createSlottable(ownerName) {
    const Slottable2 = ({ children })=>{
        return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Fragment"], {
            children
        });
    };
    Slottable2.displayName = `${ownerName}.Slottable`;
    Slottable2.__radixId = SLOTTABLE_IDENTIFIER;
    return Slottable2;
}
var Slottable = /* @__PURE__ */ createSlottable("Slottable");
function isSlottable(child) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isValidElement"](child) && typeof child.type === "function" && "__radixId" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER;
}
function mergeProps(slotProps, childProps) {
    const overrideProps = {
        ...childProps
    };
    for(const propName in childProps){
        const slotPropValue = slotProps[propName];
        const childPropValue = childProps[propName];
        const isHandler = /^on[A-Z]/.test(propName);
        if (isHandler) {
            if (slotPropValue && childPropValue) {
                overrideProps[propName] = (...args)=>{
                    const result = childPropValue(...args);
                    slotPropValue(...args);
                    return result;
                };
            } else if (slotPropValue) {
                overrideProps[propName] = slotPropValue;
            }
        } else if (propName === "style") {
            overrideProps[propName] = {
                ...slotPropValue,
                ...childPropValue
            };
        } else if (propName === "className") {
            overrideProps[propName] = [
                slotPropValue,
                childPropValue
            ].filter(Boolean).join(" ");
        }
    }
    return {
        ...slotProps,
        ...overrideProps
    };
}
function getElementRef(element) {
    let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
    let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
    if (mayWarn) {
        return element.ref;
    }
    getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
    mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
    if (mayWarn) {
        return element.props.ref;
    }
    return element.props.ref || element.ref;
}
;
 //# sourceMappingURL=index.mjs.map
}),
"[project]/node_modules/clsx/dist/clsx.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "clsx": ()=>clsx,
    "default": ()=>__TURBOPACK__default__export__
});
function r(e) {
    var t, f, n = "";
    if ("string" == typeof e || "number" == typeof e) n += e;
    else if ("object" == typeof e) if (Array.isArray(e)) {
        var o = e.length;
        for(t = 0; t < o; t++)e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
    } else for(f in e)e[f] && (n && (n += " "), n += f);
    return n;
}
function clsx() {
    for(var e, t, f = 0, n = "", o = arguments.length; f < o; f++)(e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
    return n;
}
const __TURBOPACK__default__export__ = clsx;
}),
"[project]/node_modules/class-variance-authority/dist/index.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * Copyright 2022 Joe Bell. All rights reserved.
 *
 * This file is licensed to you under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR REPRESENTATIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */ __turbopack_context__.s({
    "cva": ()=>cva,
    "cx": ()=>cx
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$clsx$2f$dist$2f$clsx$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/clsx/dist/clsx.mjs [app-ssr] (ecmascript)");
;
const falsyToString = (value)=>typeof value === "boolean" ? `${value}` : value === 0 ? "0" : value;
const cx = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$clsx$2f$dist$2f$clsx$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clsx"];
const cva = (base, config)=>(props)=>{
        var _config_compoundVariants;
        if ((config === null || config === void 0 ? void 0 : config.variants) == null) return cx(base, props === null || props === void 0 ? void 0 : props.class, props === null || props === void 0 ? void 0 : props.className);
        const { variants, defaultVariants } = config;
        const getVariantClassNames = Object.keys(variants).map((variant)=>{
            const variantProp = props === null || props === void 0 ? void 0 : props[variant];
            const defaultVariantProp = defaultVariants === null || defaultVariants === void 0 ? void 0 : defaultVariants[variant];
            if (variantProp === null) return null;
            const variantKey = falsyToString(variantProp) || falsyToString(defaultVariantProp);
            return variants[variant][variantKey];
        });
        const propsWithoutUndefined = props && Object.entries(props).reduce((acc, param)=>{
            let [key, value] = param;
            if (value === undefined) {
                return acc;
            }
            acc[key] = value;
            return acc;
        }, {});
        const getCompoundVariantClassNames = config === null || config === void 0 ? void 0 : (_config_compoundVariants = config.compoundVariants) === null || _config_compoundVariants === void 0 ? void 0 : _config_compoundVariants.reduce((acc, param)=>{
            let { class: cvClass, className: cvClassName, ...compoundVariantOptions } = param;
            return Object.entries(compoundVariantOptions).every((param)=>{
                let [key, value] = param;
                return Array.isArray(value) ? value.includes({
                    ...defaultVariants,
                    ...propsWithoutUndefined
                }[key]) : ({
                    ...defaultVariants,
                    ...propsWithoutUndefined
                })[key] === value;
            }) ? [
                ...acc,
                cvClass,
                cvClassName
            ] : acc;
        }, []);
        return cx(base, getVariantClassNames, getCompoundVariantClassNames, props === null || props === void 0 ? void 0 : props.class, props === null || props === void 0 ? void 0 : props.className);
    };
}),
"[project]/node_modules/tailwind-merge/dist/bundle-mjs.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "createTailwindMerge": ()=>createTailwindMerge,
    "extendTailwindMerge": ()=>extendTailwindMerge,
    "fromTheme": ()=>fromTheme,
    "getDefaultConfig": ()=>getDefaultConfig,
    "mergeConfigs": ()=>mergeConfigs,
    "twJoin": ()=>twJoin,
    "twMerge": ()=>twMerge,
    "validators": ()=>validators
});
const CLASS_PART_SEPARATOR = '-';
const createClassGroupUtils = (config)=>{
    const classMap = createClassMap(config);
    const { conflictingClassGroups, conflictingClassGroupModifiers } = config;
    const getClassGroupId = (className)=>{
        const classParts = className.split(CLASS_PART_SEPARATOR);
        // Classes like `-inset-1` produce an empty string as first classPart. We assume that classes for negative values are used correctly and remove it from classParts.
        if (classParts[0] === '' && classParts.length !== 1) {
            classParts.shift();
        }
        return getGroupRecursive(classParts, classMap) || getGroupIdForArbitraryProperty(className);
    };
    const getConflictingClassGroupIds = (classGroupId, hasPostfixModifier)=>{
        const conflicts = conflictingClassGroups[classGroupId] || [];
        if (hasPostfixModifier && conflictingClassGroupModifiers[classGroupId]) {
            return [
                ...conflicts,
                ...conflictingClassGroupModifiers[classGroupId]
            ];
        }
        return conflicts;
    };
    return {
        getClassGroupId,
        getConflictingClassGroupIds
    };
};
const getGroupRecursive = (classParts, classPartObject)=>{
    if (classParts.length === 0) {
        return classPartObject.classGroupId;
    }
    const currentClassPart = classParts[0];
    const nextClassPartObject = classPartObject.nextPart.get(currentClassPart);
    const classGroupFromNextClassPart = nextClassPartObject ? getGroupRecursive(classParts.slice(1), nextClassPartObject) : undefined;
    if (classGroupFromNextClassPart) {
        return classGroupFromNextClassPart;
    }
    if (classPartObject.validators.length === 0) {
        return undefined;
    }
    const classRest = classParts.join(CLASS_PART_SEPARATOR);
    return classPartObject.validators.find(({ validator })=>validator(classRest))?.classGroupId;
};
const arbitraryPropertyRegex = /^\[(.+)\]$/;
const getGroupIdForArbitraryProperty = (className)=>{
    if (arbitraryPropertyRegex.test(className)) {
        const arbitraryPropertyClassName = arbitraryPropertyRegex.exec(className)[1];
        const property = arbitraryPropertyClassName?.substring(0, arbitraryPropertyClassName.indexOf(':'));
        if (property) {
            // I use two dots here because one dot is used as prefix for class groups in plugins
            return 'arbitrary..' + property;
        }
    }
};
/**
 * Exported for testing only
 */ const createClassMap = (config)=>{
    const { theme, classGroups } = config;
    const classMap = {
        nextPart: new Map(),
        validators: []
    };
    for(const classGroupId in classGroups){
        processClassesRecursively(classGroups[classGroupId], classMap, classGroupId, theme);
    }
    return classMap;
};
const processClassesRecursively = (classGroup, classPartObject, classGroupId, theme)=>{
    classGroup.forEach((classDefinition)=>{
        if (typeof classDefinition === 'string') {
            const classPartObjectToEdit = classDefinition === '' ? classPartObject : getPart(classPartObject, classDefinition);
            classPartObjectToEdit.classGroupId = classGroupId;
            return;
        }
        if (typeof classDefinition === 'function') {
            if (isThemeGetter(classDefinition)) {
                processClassesRecursively(classDefinition(theme), classPartObject, classGroupId, theme);
                return;
            }
            classPartObject.validators.push({
                validator: classDefinition,
                classGroupId
            });
            return;
        }
        Object.entries(classDefinition).forEach(([key, classGroup])=>{
            processClassesRecursively(classGroup, getPart(classPartObject, key), classGroupId, theme);
        });
    });
};
const getPart = (classPartObject, path)=>{
    let currentClassPartObject = classPartObject;
    path.split(CLASS_PART_SEPARATOR).forEach((pathPart)=>{
        if (!currentClassPartObject.nextPart.has(pathPart)) {
            currentClassPartObject.nextPart.set(pathPart, {
                nextPart: new Map(),
                validators: []
            });
        }
        currentClassPartObject = currentClassPartObject.nextPart.get(pathPart);
    });
    return currentClassPartObject;
};
const isThemeGetter = (func)=>func.isThemeGetter;
// LRU cache inspired from hashlru (https://github.com/dominictarr/hashlru/blob/v1.0.4/index.js) but object replaced with Map to improve performance
const createLruCache = (maxCacheSize)=>{
    if (maxCacheSize < 1) {
        return {
            get: ()=>undefined,
            set: ()=>{}
        };
    }
    let cacheSize = 0;
    let cache = new Map();
    let previousCache = new Map();
    const update = (key, value)=>{
        cache.set(key, value);
        cacheSize++;
        if (cacheSize > maxCacheSize) {
            cacheSize = 0;
            previousCache = cache;
            cache = new Map();
        }
    };
    return {
        get (key) {
            let value = cache.get(key);
            if (value !== undefined) {
                return value;
            }
            if ((value = previousCache.get(key)) !== undefined) {
                update(key, value);
                return value;
            }
        },
        set (key, value) {
            if (cache.has(key)) {
                cache.set(key, value);
            } else {
                update(key, value);
            }
        }
    };
};
const IMPORTANT_MODIFIER = '!';
const MODIFIER_SEPARATOR = ':';
const MODIFIER_SEPARATOR_LENGTH = MODIFIER_SEPARATOR.length;
const createParseClassName = (config)=>{
    const { prefix, experimentalParseClassName } = config;
    /**
   * Parse class name into parts.
   *
   * Inspired by `splitAtTopLevelOnly` used in Tailwind CSS
   * @see https://github.com/tailwindlabs/tailwindcss/blob/v3.2.2/src/util/splitAtTopLevelOnly.js
   */ let parseClassName = (className)=>{
        const modifiers = [];
        let bracketDepth = 0;
        let parenDepth = 0;
        let modifierStart = 0;
        let postfixModifierPosition;
        for(let index = 0; index < className.length; index++){
            let currentCharacter = className[index];
            if (bracketDepth === 0 && parenDepth === 0) {
                if (currentCharacter === MODIFIER_SEPARATOR) {
                    modifiers.push(className.slice(modifierStart, index));
                    modifierStart = index + MODIFIER_SEPARATOR_LENGTH;
                    continue;
                }
                if (currentCharacter === '/') {
                    postfixModifierPosition = index;
                    continue;
                }
            }
            if (currentCharacter === '[') {
                bracketDepth++;
            } else if (currentCharacter === ']') {
                bracketDepth--;
            } else if (currentCharacter === '(') {
                parenDepth++;
            } else if (currentCharacter === ')') {
                parenDepth--;
            }
        }
        const baseClassNameWithImportantModifier = modifiers.length === 0 ? className : className.substring(modifierStart);
        const baseClassName = stripImportantModifier(baseClassNameWithImportantModifier);
        const hasImportantModifier = baseClassName !== baseClassNameWithImportantModifier;
        const maybePostfixModifierPosition = postfixModifierPosition && postfixModifierPosition > modifierStart ? postfixModifierPosition - modifierStart : undefined;
        return {
            modifiers,
            hasImportantModifier,
            baseClassName,
            maybePostfixModifierPosition
        };
    };
    if (prefix) {
        const fullPrefix = prefix + MODIFIER_SEPARATOR;
        const parseClassNameOriginal = parseClassName;
        parseClassName = (className)=>className.startsWith(fullPrefix) ? parseClassNameOriginal(className.substring(fullPrefix.length)) : {
                isExternal: true,
                modifiers: [],
                hasImportantModifier: false,
                baseClassName: className,
                maybePostfixModifierPosition: undefined
            };
    }
    if (experimentalParseClassName) {
        const parseClassNameOriginal = parseClassName;
        parseClassName = (className)=>experimentalParseClassName({
                className,
                parseClassName: parseClassNameOriginal
            });
    }
    return parseClassName;
};
const stripImportantModifier = (baseClassName)=>{
    if (baseClassName.endsWith(IMPORTANT_MODIFIER)) {
        return baseClassName.substring(0, baseClassName.length - 1);
    }
    /**
   * In Tailwind CSS v3 the important modifier was at the start of the base class name. This is still supported for legacy reasons.
   * @see https://github.com/dcastil/tailwind-merge/issues/513#issuecomment-2614029864
   */ if (baseClassName.startsWith(IMPORTANT_MODIFIER)) {
        return baseClassName.substring(1);
    }
    return baseClassName;
};
/**
 * Sorts modifiers according to following schema:
 * - Predefined modifiers are sorted alphabetically
 * - When an arbitrary variant appears, it must be preserved which modifiers are before and after it
 */ const createSortModifiers = (config)=>{
    const orderSensitiveModifiers = Object.fromEntries(config.orderSensitiveModifiers.map((modifier)=>[
            modifier,
            true
        ]));
    const sortModifiers = (modifiers)=>{
        if (modifiers.length <= 1) {
            return modifiers;
        }
        const sortedModifiers = [];
        let unsortedModifiers = [];
        modifiers.forEach((modifier)=>{
            const isPositionSensitive = modifier[0] === '[' || orderSensitiveModifiers[modifier];
            if (isPositionSensitive) {
                sortedModifiers.push(...unsortedModifiers.sort(), modifier);
                unsortedModifiers = [];
            } else {
                unsortedModifiers.push(modifier);
            }
        });
        sortedModifiers.push(...unsortedModifiers.sort());
        return sortedModifiers;
    };
    return sortModifiers;
};
const createConfigUtils = (config)=>({
        cache: createLruCache(config.cacheSize),
        parseClassName: createParseClassName(config),
        sortModifiers: createSortModifiers(config),
        ...createClassGroupUtils(config)
    });
const SPLIT_CLASSES_REGEX = /\s+/;
const mergeClassList = (classList, configUtils)=>{
    const { parseClassName, getClassGroupId, getConflictingClassGroupIds, sortModifiers } = configUtils;
    /**
   * Set of classGroupIds in following format:
   * `{importantModifier}{variantModifiers}{classGroupId}`
   * @example 'float'
   * @example 'hover:focus:bg-color'
   * @example 'md:!pr'
   */ const classGroupsInConflict = [];
    const classNames = classList.trim().split(SPLIT_CLASSES_REGEX);
    let result = '';
    for(let index = classNames.length - 1; index >= 0; index -= 1){
        const originalClassName = classNames[index];
        const { isExternal, modifiers, hasImportantModifier, baseClassName, maybePostfixModifierPosition } = parseClassName(originalClassName);
        if (isExternal) {
            result = originalClassName + (result.length > 0 ? ' ' + result : result);
            continue;
        }
        let hasPostfixModifier = !!maybePostfixModifierPosition;
        let classGroupId = getClassGroupId(hasPostfixModifier ? baseClassName.substring(0, maybePostfixModifierPosition) : baseClassName);
        if (!classGroupId) {
            if (!hasPostfixModifier) {
                // Not a Tailwind class
                result = originalClassName + (result.length > 0 ? ' ' + result : result);
                continue;
            }
            classGroupId = getClassGroupId(baseClassName);
            if (!classGroupId) {
                // Not a Tailwind class
                result = originalClassName + (result.length > 0 ? ' ' + result : result);
                continue;
            }
            hasPostfixModifier = false;
        }
        const variantModifier = sortModifiers(modifiers).join(':');
        const modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER : variantModifier;
        const classId = modifierId + classGroupId;
        if (classGroupsInConflict.includes(classId)) {
            continue;
        }
        classGroupsInConflict.push(classId);
        const conflictGroups = getConflictingClassGroupIds(classGroupId, hasPostfixModifier);
        for(let i = 0; i < conflictGroups.length; ++i){
            const group = conflictGroups[i];
            classGroupsInConflict.push(modifierId + group);
        }
        // Tailwind class not in conflict
        result = originalClassName + (result.length > 0 ? ' ' + result : result);
    }
    return result;
};
/**
 * The code in this file is copied from https://github.com/lukeed/clsx and modified to suit the needs of tailwind-merge better.
 *
 * Specifically:
 * - Runtime code from https://github.com/lukeed/clsx/blob/v1.2.1/src/index.js
 * - TypeScript types from https://github.com/lukeed/clsx/blob/v1.2.1/clsx.d.ts
 *
 * Original code has MIT license: Copyright (c) Luke Edwards <luke.edwards05@gmail.com> (lukeed.com)
 */ function twJoin() {
    let index = 0;
    let argument;
    let resolvedValue;
    let string = '';
    while(index < arguments.length){
        if (argument = arguments[index++]) {
            if (resolvedValue = toValue(argument)) {
                string && (string += ' ');
                string += resolvedValue;
            }
        }
    }
    return string;
}
const toValue = (mix)=>{
    if (typeof mix === 'string') {
        return mix;
    }
    let resolvedValue;
    let string = '';
    for(let k = 0; k < mix.length; k++){
        if (mix[k]) {
            if (resolvedValue = toValue(mix[k])) {
                string && (string += ' ');
                string += resolvedValue;
            }
        }
    }
    return string;
};
function createTailwindMerge(createConfigFirst, ...createConfigRest) {
    let configUtils;
    let cacheGet;
    let cacheSet;
    let functionToCall = initTailwindMerge;
    function initTailwindMerge(classList) {
        const config = createConfigRest.reduce((previousConfig, createConfigCurrent)=>createConfigCurrent(previousConfig), createConfigFirst());
        configUtils = createConfigUtils(config);
        cacheGet = configUtils.cache.get;
        cacheSet = configUtils.cache.set;
        functionToCall = tailwindMerge;
        return tailwindMerge(classList);
    }
    function tailwindMerge(classList) {
        const cachedResult = cacheGet(classList);
        if (cachedResult) {
            return cachedResult;
        }
        const result = mergeClassList(classList, configUtils);
        cacheSet(classList, result);
        return result;
    }
    return function callTailwindMerge() {
        return functionToCall(twJoin.apply(null, arguments));
    };
}
const fromTheme = (key)=>{
    const themeGetter = (theme)=>theme[key] || [];
    themeGetter.isThemeGetter = true;
    return themeGetter;
};
const arbitraryValueRegex = /^\[(?:(\w[\w-]*):)?(.+)\]$/i;
const arbitraryVariableRegex = /^\((?:(\w[\w-]*):)?(.+)\)$/i;
const fractionRegex = /^\d+\/\d+$/;
const tshirtUnitRegex = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/;
const lengthUnitRegex = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/;
const colorFunctionRegex = /^(rgba?|hsla?|hwb|(ok)?(lab|lch)|color-mix)\(.+\)$/;
// Shadow always begins with x and y offset separated by underscore optionally prepended by inset
const shadowRegex = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
const imageRegex = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;
const isFraction = (value)=>fractionRegex.test(value);
const isNumber = (value)=>!!value && !Number.isNaN(Number(value));
const isInteger = (value)=>!!value && Number.isInteger(Number(value));
const isPercent = (value)=>value.endsWith('%') && isNumber(value.slice(0, -1));
const isTshirtSize = (value)=>tshirtUnitRegex.test(value);
const isAny = ()=>true;
const isLengthOnly = (value)=>// `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
    // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
    // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
    lengthUnitRegex.test(value) && !colorFunctionRegex.test(value);
const isNever = ()=>false;
const isShadow = (value)=>shadowRegex.test(value);
const isImage = (value)=>imageRegex.test(value);
const isAnyNonArbitrary = (value)=>!isArbitraryValue(value) && !isArbitraryVariable(value);
const isArbitrarySize = (value)=>getIsArbitraryValue(value, isLabelSize, isNever);
const isArbitraryValue = (value)=>arbitraryValueRegex.test(value);
const isArbitraryLength = (value)=>getIsArbitraryValue(value, isLabelLength, isLengthOnly);
const isArbitraryNumber = (value)=>getIsArbitraryValue(value, isLabelNumber, isNumber);
const isArbitraryPosition = (value)=>getIsArbitraryValue(value, isLabelPosition, isNever);
const isArbitraryImage = (value)=>getIsArbitraryValue(value, isLabelImage, isImage);
const isArbitraryShadow = (value)=>getIsArbitraryValue(value, isLabelShadow, isShadow);
const isArbitraryVariable = (value)=>arbitraryVariableRegex.test(value);
const isArbitraryVariableLength = (value)=>getIsArbitraryVariable(value, isLabelLength);
const isArbitraryVariableFamilyName = (value)=>getIsArbitraryVariable(value, isLabelFamilyName);
const isArbitraryVariablePosition = (value)=>getIsArbitraryVariable(value, isLabelPosition);
const isArbitraryVariableSize = (value)=>getIsArbitraryVariable(value, isLabelSize);
const isArbitraryVariableImage = (value)=>getIsArbitraryVariable(value, isLabelImage);
const isArbitraryVariableShadow = (value)=>getIsArbitraryVariable(value, isLabelShadow, true);
// Helpers
const getIsArbitraryValue = (value, testLabel, testValue)=>{
    const result = arbitraryValueRegex.exec(value);
    if (result) {
        if (result[1]) {
            return testLabel(result[1]);
        }
        return testValue(result[2]);
    }
    return false;
};
const getIsArbitraryVariable = (value, testLabel, shouldMatchNoLabel = false)=>{
    const result = arbitraryVariableRegex.exec(value);
    if (result) {
        if (result[1]) {
            return testLabel(result[1]);
        }
        return shouldMatchNoLabel;
    }
    return false;
};
// Labels
const isLabelPosition = (label)=>label === 'position' || label === 'percentage';
const isLabelImage = (label)=>label === 'image' || label === 'url';
const isLabelSize = (label)=>label === 'length' || label === 'size' || label === 'bg-size';
const isLabelLength = (label)=>label === 'length';
const isLabelNumber = (label)=>label === 'number';
const isLabelFamilyName = (label)=>label === 'family-name';
const isLabelShadow = (label)=>label === 'shadow';
const validators = /*#__PURE__*/ Object.defineProperty({
    __proto__: null,
    isAny,
    isAnyNonArbitrary,
    isArbitraryImage,
    isArbitraryLength,
    isArbitraryNumber,
    isArbitraryPosition,
    isArbitraryShadow,
    isArbitrarySize,
    isArbitraryValue,
    isArbitraryVariable,
    isArbitraryVariableFamilyName,
    isArbitraryVariableImage,
    isArbitraryVariableLength,
    isArbitraryVariablePosition,
    isArbitraryVariableShadow,
    isArbitraryVariableSize,
    isFraction,
    isInteger,
    isNumber,
    isPercent,
    isTshirtSize
}, Symbol.toStringTag, {
    value: 'Module'
});
const getDefaultConfig = ()=>{
    /**
   * Theme getters for theme variable namespaces
   * @see https://tailwindcss.com/docs/theme#theme-variable-namespaces
   */ /***/ const themeColor = fromTheme('color');
    const themeFont = fromTheme('font');
    const themeText = fromTheme('text');
    const themeFontWeight = fromTheme('font-weight');
    const themeTracking = fromTheme('tracking');
    const themeLeading = fromTheme('leading');
    const themeBreakpoint = fromTheme('breakpoint');
    const themeContainer = fromTheme('container');
    const themeSpacing = fromTheme('spacing');
    const themeRadius = fromTheme('radius');
    const themeShadow = fromTheme('shadow');
    const themeInsetShadow = fromTheme('inset-shadow');
    const themeTextShadow = fromTheme('text-shadow');
    const themeDropShadow = fromTheme('drop-shadow');
    const themeBlur = fromTheme('blur');
    const themePerspective = fromTheme('perspective');
    const themeAspect = fromTheme('aspect');
    const themeEase = fromTheme('ease');
    const themeAnimate = fromTheme('animate');
    /**
   * Helpers to avoid repeating the same scales
   *
   * We use functions that create a new array every time they're called instead of static arrays.
   * This ensures that users who modify any scale by mutating the array (e.g. with `array.push(element)`) don't accidentally mutate arrays in other parts of the config.
   */ /***/ const scaleBreak = ()=>[
            'auto',
            'avoid',
            'all',
            'avoid-page',
            'page',
            'left',
            'right',
            'column'
        ];
    const scalePosition = ()=>[
            'center',
            'top',
            'bottom',
            'left',
            'right',
            'top-left',
            // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
            'left-top',
            'top-right',
            // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
            'right-top',
            'bottom-right',
            // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
            'right-bottom',
            'bottom-left',
            // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
            'left-bottom'
        ];
    const scalePositionWithArbitrary = ()=>[
            ...scalePosition(),
            isArbitraryVariable,
            isArbitraryValue
        ];
    const scaleOverflow = ()=>[
            'auto',
            'hidden',
            'clip',
            'visible',
            'scroll'
        ];
    const scaleOverscroll = ()=>[
            'auto',
            'contain',
            'none'
        ];
    const scaleUnambiguousSpacing = ()=>[
            isArbitraryVariable,
            isArbitraryValue,
            themeSpacing
        ];
    const scaleInset = ()=>[
            isFraction,
            'full',
            'auto',
            ...scaleUnambiguousSpacing()
        ];
    const scaleGridTemplateColsRows = ()=>[
            isInteger,
            'none',
            'subgrid',
            isArbitraryVariable,
            isArbitraryValue
        ];
    const scaleGridColRowStartAndEnd = ()=>[
            'auto',
            {
                span: [
                    'full',
                    isInteger,
                    isArbitraryVariable,
                    isArbitraryValue
                ]
            },
            isInteger,
            isArbitraryVariable,
            isArbitraryValue
        ];
    const scaleGridColRowStartOrEnd = ()=>[
            isInteger,
            'auto',
            isArbitraryVariable,
            isArbitraryValue
        ];
    const scaleGridAutoColsRows = ()=>[
            'auto',
            'min',
            'max',
            'fr',
            isArbitraryVariable,
            isArbitraryValue
        ];
    const scaleAlignPrimaryAxis = ()=>[
            'start',
            'end',
            'center',
            'between',
            'around',
            'evenly',
            'stretch',
            'baseline',
            'center-safe',
            'end-safe'
        ];
    const scaleAlignSecondaryAxis = ()=>[
            'start',
            'end',
            'center',
            'stretch',
            'center-safe',
            'end-safe'
        ];
    const scaleMargin = ()=>[
            'auto',
            ...scaleUnambiguousSpacing()
        ];
    const scaleSizing = ()=>[
            isFraction,
            'auto',
            'full',
            'dvw',
            'dvh',
            'lvw',
            'lvh',
            'svw',
            'svh',
            'min',
            'max',
            'fit',
            ...scaleUnambiguousSpacing()
        ];
    const scaleColor = ()=>[
            themeColor,
            isArbitraryVariable,
            isArbitraryValue
        ];
    const scaleBgPosition = ()=>[
            ...scalePosition(),
            isArbitraryVariablePosition,
            isArbitraryPosition,
            {
                position: [
                    isArbitraryVariable,
                    isArbitraryValue
                ]
            }
        ];
    const scaleBgRepeat = ()=>[
            'no-repeat',
            {
                repeat: [
                    '',
                    'x',
                    'y',
                    'space',
                    'round'
                ]
            }
        ];
    const scaleBgSize = ()=>[
            'auto',
            'cover',
            'contain',
            isArbitraryVariableSize,
            isArbitrarySize,
            {
                size: [
                    isArbitraryVariable,
                    isArbitraryValue
                ]
            }
        ];
    const scaleGradientStopPosition = ()=>[
            isPercent,
            isArbitraryVariableLength,
            isArbitraryLength
        ];
    const scaleRadius = ()=>[
            // Deprecated since Tailwind CSS v4.0.0
            '',
            'none',
            'full',
            themeRadius,
            isArbitraryVariable,
            isArbitraryValue
        ];
    const scaleBorderWidth = ()=>[
            '',
            isNumber,
            isArbitraryVariableLength,
            isArbitraryLength
        ];
    const scaleLineStyle = ()=>[
            'solid',
            'dashed',
            'dotted',
            'double'
        ];
    const scaleBlendMode = ()=>[
            'normal',
            'multiply',
            'screen',
            'overlay',
            'darken',
            'lighten',
            'color-dodge',
            'color-burn',
            'hard-light',
            'soft-light',
            'difference',
            'exclusion',
            'hue',
            'saturation',
            'color',
            'luminosity'
        ];
    const scaleMaskImagePosition = ()=>[
            isNumber,
            isPercent,
            isArbitraryVariablePosition,
            isArbitraryPosition
        ];
    const scaleBlur = ()=>[
            // Deprecated since Tailwind CSS v4.0.0
            '',
            'none',
            themeBlur,
            isArbitraryVariable,
            isArbitraryValue
        ];
    const scaleRotate = ()=>[
            'none',
            isNumber,
            isArbitraryVariable,
            isArbitraryValue
        ];
    const scaleScale = ()=>[
            'none',
            isNumber,
            isArbitraryVariable,
            isArbitraryValue
        ];
    const scaleSkew = ()=>[
            isNumber,
            isArbitraryVariable,
            isArbitraryValue
        ];
    const scaleTranslate = ()=>[
            isFraction,
            'full',
            ...scaleUnambiguousSpacing()
        ];
    return {
        cacheSize: 500,
        theme: {
            animate: [
                'spin',
                'ping',
                'pulse',
                'bounce'
            ],
            aspect: [
                'video'
            ],
            blur: [
                isTshirtSize
            ],
            breakpoint: [
                isTshirtSize
            ],
            color: [
                isAny
            ],
            container: [
                isTshirtSize
            ],
            'drop-shadow': [
                isTshirtSize
            ],
            ease: [
                'in',
                'out',
                'in-out'
            ],
            font: [
                isAnyNonArbitrary
            ],
            'font-weight': [
                'thin',
                'extralight',
                'light',
                'normal',
                'medium',
                'semibold',
                'bold',
                'extrabold',
                'black'
            ],
            'inset-shadow': [
                isTshirtSize
            ],
            leading: [
                'none',
                'tight',
                'snug',
                'normal',
                'relaxed',
                'loose'
            ],
            perspective: [
                'dramatic',
                'near',
                'normal',
                'midrange',
                'distant',
                'none'
            ],
            radius: [
                isTshirtSize
            ],
            shadow: [
                isTshirtSize
            ],
            spacing: [
                'px',
                isNumber
            ],
            text: [
                isTshirtSize
            ],
            'text-shadow': [
                isTshirtSize
            ],
            tracking: [
                'tighter',
                'tight',
                'normal',
                'wide',
                'wider',
                'widest'
            ]
        },
        classGroups: {
            // --------------
            // --- Layout ---
            // --------------
            /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */ aspect: [
                {
                    aspect: [
                        'auto',
                        'square',
                        isFraction,
                        isArbitraryValue,
                        isArbitraryVariable,
                        themeAspect
                    ]
                }
            ],
            /**
       * Container
       * @see https://tailwindcss.com/docs/container
       * @deprecated since Tailwind CSS v4.0.0
       */ container: [
                'container'
            ],
            /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */ columns: [
                {
                    columns: [
                        isNumber,
                        isArbitraryValue,
                        isArbitraryVariable,
                        themeContainer
                    ]
                }
            ],
            /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */ 'break-after': [
                {
                    'break-after': scaleBreak()
                }
            ],
            /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */ 'break-before': [
                {
                    'break-before': scaleBreak()
                }
            ],
            /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */ 'break-inside': [
                {
                    'break-inside': [
                        'auto',
                        'avoid',
                        'avoid-page',
                        'avoid-column'
                    ]
                }
            ],
            /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */ 'box-decoration': [
                {
                    'box-decoration': [
                        'slice',
                        'clone'
                    ]
                }
            ],
            /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */ box: [
                {
                    box: [
                        'border',
                        'content'
                    ]
                }
            ],
            /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */ display: [
                'block',
                'inline-block',
                'inline',
                'flex',
                'inline-flex',
                'table',
                'inline-table',
                'table-caption',
                'table-cell',
                'table-column',
                'table-column-group',
                'table-footer-group',
                'table-header-group',
                'table-row-group',
                'table-row',
                'flow-root',
                'grid',
                'inline-grid',
                'contents',
                'list-item',
                'hidden'
            ],
            /**
       * Screen Reader Only
       * @see https://tailwindcss.com/docs/display#screen-reader-only
       */ sr: [
                'sr-only',
                'not-sr-only'
            ],
            /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */ float: [
                {
                    float: [
                        'right',
                        'left',
                        'none',
                        'start',
                        'end'
                    ]
                }
            ],
            /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */ clear: [
                {
                    clear: [
                        'left',
                        'right',
                        'both',
                        'none',
                        'start',
                        'end'
                    ]
                }
            ],
            /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */ isolation: [
                'isolate',
                'isolation-auto'
            ],
            /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */ 'object-fit': [
                {
                    object: [
                        'contain',
                        'cover',
                        'fill',
                        'none',
                        'scale-down'
                    ]
                }
            ],
            /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */ 'object-position': [
                {
                    object: scalePositionWithArbitrary()
                }
            ],
            /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */ overflow: [
                {
                    overflow: scaleOverflow()
                }
            ],
            /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */ 'overflow-x': [
                {
                    'overflow-x': scaleOverflow()
                }
            ],
            /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */ 'overflow-y': [
                {
                    'overflow-y': scaleOverflow()
                }
            ],
            /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */ overscroll: [
                {
                    overscroll: scaleOverscroll()
                }
            ],
            /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */ 'overscroll-x': [
                {
                    'overscroll-x': scaleOverscroll()
                }
            ],
            /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */ 'overscroll-y': [
                {
                    'overscroll-y': scaleOverscroll()
                }
            ],
            /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */ position: [
                'static',
                'fixed',
                'absolute',
                'relative',
                'sticky'
            ],
            /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */ inset: [
                {
                    inset: scaleInset()
                }
            ],
            /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */ 'inset-x': [
                {
                    'inset-x': scaleInset()
                }
            ],
            /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */ 'inset-y': [
                {
                    'inset-y': scaleInset()
                }
            ],
            /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */ start: [
                {
                    start: scaleInset()
                }
            ],
            /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */ end: [
                {
                    end: scaleInset()
                }
            ],
            /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */ top: [
                {
                    top: scaleInset()
                }
            ],
            /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */ right: [
                {
                    right: scaleInset()
                }
            ],
            /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */ bottom: [
                {
                    bottom: scaleInset()
                }
            ],
            /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */ left: [
                {
                    left: scaleInset()
                }
            ],
            /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */ visibility: [
                'visible',
                'invisible',
                'collapse'
            ],
            /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */ z: [
                {
                    z: [
                        isInteger,
                        'auto',
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            // ------------------------
            // --- Flexbox and Grid ---
            // ------------------------
            /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */ basis: [
                {
                    basis: [
                        isFraction,
                        'full',
                        'auto',
                        themeContainer,
                        ...scaleUnambiguousSpacing()
                    ]
                }
            ],
            /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */ 'flex-direction': [
                {
                    flex: [
                        'row',
                        'row-reverse',
                        'col',
                        'col-reverse'
                    ]
                }
            ],
            /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */ 'flex-wrap': [
                {
                    flex: [
                        'nowrap',
                        'wrap',
                        'wrap-reverse'
                    ]
                }
            ],
            /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */ flex: [
                {
                    flex: [
                        isNumber,
                        isFraction,
                        'auto',
                        'initial',
                        'none',
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */ grow: [
                {
                    grow: [
                        '',
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */ shrink: [
                {
                    shrink: [
                        '',
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */ order: [
                {
                    order: [
                        isInteger,
                        'first',
                        'last',
                        'none',
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */ 'grid-cols': [
                {
                    'grid-cols': scaleGridTemplateColsRows()
                }
            ],
            /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */ 'col-start-end': [
                {
                    col: scaleGridColRowStartAndEnd()
                }
            ],
            /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */ 'col-start': [
                {
                    'col-start': scaleGridColRowStartOrEnd()
                }
            ],
            /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */ 'col-end': [
                {
                    'col-end': scaleGridColRowStartOrEnd()
                }
            ],
            /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */ 'grid-rows': [
                {
                    'grid-rows': scaleGridTemplateColsRows()
                }
            ],
            /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */ 'row-start-end': [
                {
                    row: scaleGridColRowStartAndEnd()
                }
            ],
            /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */ 'row-start': [
                {
                    'row-start': scaleGridColRowStartOrEnd()
                }
            ],
            /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */ 'row-end': [
                {
                    'row-end': scaleGridColRowStartOrEnd()
                }
            ],
            /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */ 'grid-flow': [
                {
                    'grid-flow': [
                        'row',
                        'col',
                        'dense',
                        'row-dense',
                        'col-dense'
                    ]
                }
            ],
            /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */ 'auto-cols': [
                {
                    'auto-cols': scaleGridAutoColsRows()
                }
            ],
            /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */ 'auto-rows': [
                {
                    'auto-rows': scaleGridAutoColsRows()
                }
            ],
            /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */ gap: [
                {
                    gap: scaleUnambiguousSpacing()
                }
            ],
            /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */ 'gap-x': [
                {
                    'gap-x': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */ 'gap-y': [
                {
                    'gap-y': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */ 'justify-content': [
                {
                    justify: [
                        ...scaleAlignPrimaryAxis(),
                        'normal'
                    ]
                }
            ],
            /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */ 'justify-items': [
                {
                    'justify-items': [
                        ...scaleAlignSecondaryAxis(),
                        'normal'
                    ]
                }
            ],
            /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */ 'justify-self': [
                {
                    'justify-self': [
                        'auto',
                        ...scaleAlignSecondaryAxis()
                    ]
                }
            ],
            /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */ 'align-content': [
                {
                    content: [
                        'normal',
                        ...scaleAlignPrimaryAxis()
                    ]
                }
            ],
            /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */ 'align-items': [
                {
                    items: [
                        ...scaleAlignSecondaryAxis(),
                        {
                            baseline: [
                                '',
                                'last'
                            ]
                        }
                    ]
                }
            ],
            /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */ 'align-self': [
                {
                    self: [
                        'auto',
                        ...scaleAlignSecondaryAxis(),
                        {
                            baseline: [
                                '',
                                'last'
                            ]
                        }
                    ]
                }
            ],
            /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */ 'place-content': [
                {
                    'place-content': scaleAlignPrimaryAxis()
                }
            ],
            /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */ 'place-items': [
                {
                    'place-items': [
                        ...scaleAlignSecondaryAxis(),
                        'baseline'
                    ]
                }
            ],
            /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */ 'place-self': [
                {
                    'place-self': [
                        'auto',
                        ...scaleAlignSecondaryAxis()
                    ]
                }
            ],
            // Spacing
            /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */ p: [
                {
                    p: scaleUnambiguousSpacing()
                }
            ],
            /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */ px: [
                {
                    px: scaleUnambiguousSpacing()
                }
            ],
            /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */ py: [
                {
                    py: scaleUnambiguousSpacing()
                }
            ],
            /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */ ps: [
                {
                    ps: scaleUnambiguousSpacing()
                }
            ],
            /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */ pe: [
                {
                    pe: scaleUnambiguousSpacing()
                }
            ],
            /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */ pt: [
                {
                    pt: scaleUnambiguousSpacing()
                }
            ],
            /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */ pr: [
                {
                    pr: scaleUnambiguousSpacing()
                }
            ],
            /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */ pb: [
                {
                    pb: scaleUnambiguousSpacing()
                }
            ],
            /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */ pl: [
                {
                    pl: scaleUnambiguousSpacing()
                }
            ],
            /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */ m: [
                {
                    m: scaleMargin()
                }
            ],
            /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */ mx: [
                {
                    mx: scaleMargin()
                }
            ],
            /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */ my: [
                {
                    my: scaleMargin()
                }
            ],
            /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */ ms: [
                {
                    ms: scaleMargin()
                }
            ],
            /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */ me: [
                {
                    me: scaleMargin()
                }
            ],
            /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */ mt: [
                {
                    mt: scaleMargin()
                }
            ],
            /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */ mr: [
                {
                    mr: scaleMargin()
                }
            ],
            /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */ mb: [
                {
                    mb: scaleMargin()
                }
            ],
            /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */ ml: [
                {
                    ml: scaleMargin()
                }
            ],
            /**
       * Space Between X
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */ 'space-x': [
                {
                    'space-x': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */ 'space-x-reverse': [
                'space-x-reverse'
            ],
            /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */ 'space-y': [
                {
                    'space-y': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */ 'space-y-reverse': [
                'space-y-reverse'
            ],
            // --------------
            // --- Sizing ---
            // --------------
            /**
       * Size
       * @see https://tailwindcss.com/docs/width#setting-both-width-and-height
       */ size: [
                {
                    size: scaleSizing()
                }
            ],
            /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */ w: [
                {
                    w: [
                        themeContainer,
                        'screen',
                        ...scaleSizing()
                    ]
                }
            ],
            /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */ 'min-w': [
                {
                    'min-w': [
                        themeContainer,
                        'screen',
                        /** Deprecated. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */ 'none',
                        ...scaleSizing()
                    ]
                }
            ],
            /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */ 'max-w': [
                {
                    'max-w': [
                        themeContainer,
                        'screen',
                        'none',
                        /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */ 'prose',
                        /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */ {
                            screen: [
                                themeBreakpoint
                            ]
                        },
                        ...scaleSizing()
                    ]
                }
            ],
            /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */ h: [
                {
                    h: [
                        'screen',
                        'lh',
                        ...scaleSizing()
                    ]
                }
            ],
            /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */ 'min-h': [
                {
                    'min-h': [
                        'screen',
                        'lh',
                        'none',
                        ...scaleSizing()
                    ]
                }
            ],
            /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */ 'max-h': [
                {
                    'max-h': [
                        'screen',
                        'lh',
                        ...scaleSizing()
                    ]
                }
            ],
            // ------------------
            // --- Typography ---
            // ------------------
            /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */ 'font-size': [
                {
                    text: [
                        'base',
                        themeText,
                        isArbitraryVariableLength,
                        isArbitraryLength
                    ]
                }
            ],
            /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */ 'font-smoothing': [
                'antialiased',
                'subpixel-antialiased'
            ],
            /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */ 'font-style': [
                'italic',
                'not-italic'
            ],
            /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */ 'font-weight': [
                {
                    font: [
                        themeFontWeight,
                        isArbitraryVariable,
                        isArbitraryNumber
                    ]
                }
            ],
            /**
       * Font Stretch
       * @see https://tailwindcss.com/docs/font-stretch
       */ 'font-stretch': [
                {
                    'font-stretch': [
                        'ultra-condensed',
                        'extra-condensed',
                        'condensed',
                        'semi-condensed',
                        'normal',
                        'semi-expanded',
                        'expanded',
                        'extra-expanded',
                        'ultra-expanded',
                        isPercent,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */ 'font-family': [
                {
                    font: [
                        isArbitraryVariableFamilyName,
                        isArbitraryValue,
                        themeFont
                    ]
                }
            ],
            /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */ 'fvn-normal': [
                'normal-nums'
            ],
            /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */ 'fvn-ordinal': [
                'ordinal'
            ],
            /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */ 'fvn-slashed-zero': [
                'slashed-zero'
            ],
            /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */ 'fvn-figure': [
                'lining-nums',
                'oldstyle-nums'
            ],
            /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */ 'fvn-spacing': [
                'proportional-nums',
                'tabular-nums'
            ],
            /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */ 'fvn-fraction': [
                'diagonal-fractions',
                'stacked-fractions'
            ],
            /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */ tracking: [
                {
                    tracking: [
                        themeTracking,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */ 'line-clamp': [
                {
                    'line-clamp': [
                        isNumber,
                        'none',
                        isArbitraryVariable,
                        isArbitraryNumber
                    ]
                }
            ],
            /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */ leading: [
                {
                    leading: [
                        /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */ themeLeading,
                        ...scaleUnambiguousSpacing()
                    ]
                }
            ],
            /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */ 'list-image': [
                {
                    'list-image': [
                        'none',
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */ 'list-style-position': [
                {
                    list: [
                        'inside',
                        'outside'
                    ]
                }
            ],
            /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */ 'list-style-type': [
                {
                    list: [
                        'disc',
                        'decimal',
                        'none',
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */ 'text-alignment': [
                {
                    text: [
                        'left',
                        'center',
                        'right',
                        'justify',
                        'start',
                        'end'
                    ]
                }
            ],
            /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://v3.tailwindcss.com/docs/placeholder-color
       */ 'placeholder-color': [
                {
                    placeholder: scaleColor()
                }
            ],
            /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */ 'text-color': [
                {
                    text: scaleColor()
                }
            ],
            /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */ 'text-decoration': [
                'underline',
                'overline',
                'line-through',
                'no-underline'
            ],
            /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */ 'text-decoration-style': [
                {
                    decoration: [
                        ...scaleLineStyle(),
                        'wavy'
                    ]
                }
            ],
            /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */ 'text-decoration-thickness': [
                {
                    decoration: [
                        isNumber,
                        'from-font',
                        'auto',
                        isArbitraryVariable,
                        isArbitraryLength
                    ]
                }
            ],
            /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */ 'text-decoration-color': [
                {
                    decoration: scaleColor()
                }
            ],
            /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */ 'underline-offset': [
                {
                    'underline-offset': [
                        isNumber,
                        'auto',
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */ 'text-transform': [
                'uppercase',
                'lowercase',
                'capitalize',
                'normal-case'
            ],
            /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */ 'text-overflow': [
                'truncate',
                'text-ellipsis',
                'text-clip'
            ],
            /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */ 'text-wrap': [
                {
                    text: [
                        'wrap',
                        'nowrap',
                        'balance',
                        'pretty'
                    ]
                }
            ],
            /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */ indent: [
                {
                    indent: scaleUnambiguousSpacing()
                }
            ],
            /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */ 'vertical-align': [
                {
                    align: [
                        'baseline',
                        'top',
                        'middle',
                        'bottom',
                        'text-top',
                        'text-bottom',
                        'sub',
                        'super',
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */ whitespace: [
                {
                    whitespace: [
                        'normal',
                        'nowrap',
                        'pre',
                        'pre-line',
                        'pre-wrap',
                        'break-spaces'
                    ]
                }
            ],
            /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */ break: [
                {
                    break: [
                        'normal',
                        'words',
                        'all',
                        'keep'
                    ]
                }
            ],
            /**
       * Overflow Wrap
       * @see https://tailwindcss.com/docs/overflow-wrap
       */ wrap: [
                {
                    wrap: [
                        'break-word',
                        'anywhere',
                        'normal'
                    ]
                }
            ],
            /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */ hyphens: [
                {
                    hyphens: [
                        'none',
                        'manual',
                        'auto'
                    ]
                }
            ],
            /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */ content: [
                {
                    content: [
                        'none',
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            // -------------------
            // --- Backgrounds ---
            // -------------------
            /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */ 'bg-attachment': [
                {
                    bg: [
                        'fixed',
                        'local',
                        'scroll'
                    ]
                }
            ],
            /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */ 'bg-clip': [
                {
                    'bg-clip': [
                        'border',
                        'padding',
                        'content',
                        'text'
                    ]
                }
            ],
            /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */ 'bg-origin': [
                {
                    'bg-origin': [
                        'border',
                        'padding',
                        'content'
                    ]
                }
            ],
            /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */ 'bg-position': [
                {
                    bg: scaleBgPosition()
                }
            ],
            /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */ 'bg-repeat': [
                {
                    bg: scaleBgRepeat()
                }
            ],
            /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */ 'bg-size': [
                {
                    bg: scaleBgSize()
                }
            ],
            /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */ 'bg-image': [
                {
                    bg: [
                        'none',
                        {
                            linear: [
                                {
                                    to: [
                                        't',
                                        'tr',
                                        'r',
                                        'br',
                                        'b',
                                        'bl',
                                        'l',
                                        'tl'
                                    ]
                                },
                                isInteger,
                                isArbitraryVariable,
                                isArbitraryValue
                            ],
                            radial: [
                                '',
                                isArbitraryVariable,
                                isArbitraryValue
                            ],
                            conic: [
                                isInteger,
                                isArbitraryVariable,
                                isArbitraryValue
                            ]
                        },
                        isArbitraryVariableImage,
                        isArbitraryImage
                    ]
                }
            ],
            /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */ 'bg-color': [
                {
                    bg: scaleColor()
                }
            ],
            /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */ 'gradient-from-pos': [
                {
                    from: scaleGradientStopPosition()
                }
            ],
            /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */ 'gradient-via-pos': [
                {
                    via: scaleGradientStopPosition()
                }
            ],
            /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */ 'gradient-to-pos': [
                {
                    to: scaleGradientStopPosition()
                }
            ],
            /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */ 'gradient-from': [
                {
                    from: scaleColor()
                }
            ],
            /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */ 'gradient-via': [
                {
                    via: scaleColor()
                }
            ],
            /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */ 'gradient-to': [
                {
                    to: scaleColor()
                }
            ],
            // ---------------
            // --- Borders ---
            // ---------------
            /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */ rounded: [
                {
                    rounded: scaleRadius()
                }
            ],
            /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */ 'rounded-s': [
                {
                    'rounded-s': scaleRadius()
                }
            ],
            /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */ 'rounded-e': [
                {
                    'rounded-e': scaleRadius()
                }
            ],
            /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */ 'rounded-t': [
                {
                    'rounded-t': scaleRadius()
                }
            ],
            /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */ 'rounded-r': [
                {
                    'rounded-r': scaleRadius()
                }
            ],
            /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */ 'rounded-b': [
                {
                    'rounded-b': scaleRadius()
                }
            ],
            /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */ 'rounded-l': [
                {
                    'rounded-l': scaleRadius()
                }
            ],
            /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */ 'rounded-ss': [
                {
                    'rounded-ss': scaleRadius()
                }
            ],
            /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */ 'rounded-se': [
                {
                    'rounded-se': scaleRadius()
                }
            ],
            /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */ 'rounded-ee': [
                {
                    'rounded-ee': scaleRadius()
                }
            ],
            /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */ 'rounded-es': [
                {
                    'rounded-es': scaleRadius()
                }
            ],
            /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */ 'rounded-tl': [
                {
                    'rounded-tl': scaleRadius()
                }
            ],
            /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */ 'rounded-tr': [
                {
                    'rounded-tr': scaleRadius()
                }
            ],
            /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */ 'rounded-br': [
                {
                    'rounded-br': scaleRadius()
                }
            ],
            /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */ 'rounded-bl': [
                {
                    'rounded-bl': scaleRadius()
                }
            ],
            /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */ 'border-w': [
                {
                    border: scaleBorderWidth()
                }
            ],
            /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */ 'border-w-x': [
                {
                    'border-x': scaleBorderWidth()
                }
            ],
            /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */ 'border-w-y': [
                {
                    'border-y': scaleBorderWidth()
                }
            ],
            /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */ 'border-w-s': [
                {
                    'border-s': scaleBorderWidth()
                }
            ],
            /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */ 'border-w-e': [
                {
                    'border-e': scaleBorderWidth()
                }
            ],
            /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */ 'border-w-t': [
                {
                    'border-t': scaleBorderWidth()
                }
            ],
            /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */ 'border-w-r': [
                {
                    'border-r': scaleBorderWidth()
                }
            ],
            /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */ 'border-w-b': [
                {
                    'border-b': scaleBorderWidth()
                }
            ],
            /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */ 'border-w-l': [
                {
                    'border-l': scaleBorderWidth()
                }
            ],
            /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/border-width#between-children
       */ 'divide-x': [
                {
                    'divide-x': scaleBorderWidth()
                }
            ],
            /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/border-width#between-children
       */ 'divide-x-reverse': [
                'divide-x-reverse'
            ],
            /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/border-width#between-children
       */ 'divide-y': [
                {
                    'divide-y': scaleBorderWidth()
                }
            ],
            /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/border-width#between-children
       */ 'divide-y-reverse': [
                'divide-y-reverse'
            ],
            /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */ 'border-style': [
                {
                    border: [
                        ...scaleLineStyle(),
                        'hidden',
                        'none'
                    ]
                }
            ],
            /**
       * Divide Style
       * @see https://tailwindcss.com/docs/border-style#setting-the-divider-style
       */ 'divide-style': [
                {
                    divide: [
                        ...scaleLineStyle(),
                        'hidden',
                        'none'
                    ]
                }
            ],
            /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */ 'border-color': [
                {
                    border: scaleColor()
                }
            ],
            /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */ 'border-color-x': [
                {
                    'border-x': scaleColor()
                }
            ],
            /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */ 'border-color-y': [
                {
                    'border-y': scaleColor()
                }
            ],
            /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */ 'border-color-s': [
                {
                    'border-s': scaleColor()
                }
            ],
            /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */ 'border-color-e': [
                {
                    'border-e': scaleColor()
                }
            ],
            /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */ 'border-color-t': [
                {
                    'border-t': scaleColor()
                }
            ],
            /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */ 'border-color-r': [
                {
                    'border-r': scaleColor()
                }
            ],
            /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */ 'border-color-b': [
                {
                    'border-b': scaleColor()
                }
            ],
            /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */ 'border-color-l': [
                {
                    'border-l': scaleColor()
                }
            ],
            /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */ 'divide-color': [
                {
                    divide: scaleColor()
                }
            ],
            /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */ 'outline-style': [
                {
                    outline: [
                        ...scaleLineStyle(),
                        'none',
                        'hidden'
                    ]
                }
            ],
            /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */ 'outline-offset': [
                {
                    'outline-offset': [
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */ 'outline-w': [
                {
                    outline: [
                        '',
                        isNumber,
                        isArbitraryVariableLength,
                        isArbitraryLength
                    ]
                }
            ],
            /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */ 'outline-color': [
                {
                    outline: scaleColor()
                }
            ],
            // ---------------
            // --- Effects ---
            // ---------------
            /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */ shadow: [
                {
                    shadow: [
                        // Deprecated since Tailwind CSS v4.0.0
                        '',
                        'none',
                        themeShadow,
                        isArbitraryVariableShadow,
                        isArbitraryShadow
                    ]
                }
            ],
            /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-shadow-color
       */ 'shadow-color': [
                {
                    shadow: scaleColor()
                }
            ],
            /**
       * Inset Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-shadow
       */ 'inset-shadow': [
                {
                    'inset-shadow': [
                        'none',
                        themeInsetShadow,
                        isArbitraryVariableShadow,
                        isArbitraryShadow
                    ]
                }
            ],
            /**
       * Inset Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-shadow-color
       */ 'inset-shadow-color': [
                {
                    'inset-shadow': scaleColor()
                }
            ],
            /**
       * Ring Width
       * @see https://tailwindcss.com/docs/box-shadow#adding-a-ring
       */ 'ring-w': [
                {
                    ring: scaleBorderWidth()
                }
            ],
            /**
       * Ring Width Inset
       * @see https://v3.tailwindcss.com/docs/ring-width#inset-rings
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */ 'ring-w-inset': [
                'ring-inset'
            ],
            /**
       * Ring Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-ring-color
       */ 'ring-color': [
                {
                    ring: scaleColor()
                }
            ],
            /**
       * Ring Offset Width
       * @see https://v3.tailwindcss.com/docs/ring-offset-width
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */ 'ring-offset-w': [
                {
                    'ring-offset': [
                        isNumber,
                        isArbitraryLength
                    ]
                }
            ],
            /**
       * Ring Offset Color
       * @see https://v3.tailwindcss.com/docs/ring-offset-color
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */ 'ring-offset-color': [
                {
                    'ring-offset': scaleColor()
                }
            ],
            /**
       * Inset Ring Width
       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-ring
       */ 'inset-ring-w': [
                {
                    'inset-ring': scaleBorderWidth()
                }
            ],
            /**
       * Inset Ring Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-ring-color
       */ 'inset-ring-color': [
                {
                    'inset-ring': scaleColor()
                }
            ],
            /**
       * Text Shadow
       * @see https://tailwindcss.com/docs/text-shadow
       */ 'text-shadow': [
                {
                    'text-shadow': [
                        'none',
                        themeTextShadow,
                        isArbitraryVariableShadow,
                        isArbitraryShadow
                    ]
                }
            ],
            /**
       * Text Shadow Color
       * @see https://tailwindcss.com/docs/text-shadow#setting-the-shadow-color
       */ 'text-shadow-color': [
                {
                    'text-shadow': scaleColor()
                }
            ],
            /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */ opacity: [
                {
                    opacity: [
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */ 'mix-blend': [
                {
                    'mix-blend': [
                        ...scaleBlendMode(),
                        'plus-darker',
                        'plus-lighter'
                    ]
                }
            ],
            /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */ 'bg-blend': [
                {
                    'bg-blend': scaleBlendMode()
                }
            ],
            /**
       * Mask Clip
       * @see https://tailwindcss.com/docs/mask-clip
       */ 'mask-clip': [
                {
                    'mask-clip': [
                        'border',
                        'padding',
                        'content',
                        'fill',
                        'stroke',
                        'view'
                    ]
                },
                'mask-no-clip'
            ],
            /**
       * Mask Composite
       * @see https://tailwindcss.com/docs/mask-composite
       */ 'mask-composite': [
                {
                    mask: [
                        'add',
                        'subtract',
                        'intersect',
                        'exclude'
                    ]
                }
            ],
            /**
       * Mask Image
       * @see https://tailwindcss.com/docs/mask-image
       */ 'mask-image-linear-pos': [
                {
                    'mask-linear': [
                        isNumber
                    ]
                }
            ],
            'mask-image-linear-from-pos': [
                {
                    'mask-linear-from': scaleMaskImagePosition()
                }
            ],
            'mask-image-linear-to-pos': [
                {
                    'mask-linear-to': scaleMaskImagePosition()
                }
            ],
            'mask-image-linear-from-color': [
                {
                    'mask-linear-from': scaleColor()
                }
            ],
            'mask-image-linear-to-color': [
                {
                    'mask-linear-to': scaleColor()
                }
            ],
            'mask-image-t-from-pos': [
                {
                    'mask-t-from': scaleMaskImagePosition()
                }
            ],
            'mask-image-t-to-pos': [
                {
                    'mask-t-to': scaleMaskImagePosition()
                }
            ],
            'mask-image-t-from-color': [
                {
                    'mask-t-from': scaleColor()
                }
            ],
            'mask-image-t-to-color': [
                {
                    'mask-t-to': scaleColor()
                }
            ],
            'mask-image-r-from-pos': [
                {
                    'mask-r-from': scaleMaskImagePosition()
                }
            ],
            'mask-image-r-to-pos': [
                {
                    'mask-r-to': scaleMaskImagePosition()
                }
            ],
            'mask-image-r-from-color': [
                {
                    'mask-r-from': scaleColor()
                }
            ],
            'mask-image-r-to-color': [
                {
                    'mask-r-to': scaleColor()
                }
            ],
            'mask-image-b-from-pos': [
                {
                    'mask-b-from': scaleMaskImagePosition()
                }
            ],
            'mask-image-b-to-pos': [
                {
                    'mask-b-to': scaleMaskImagePosition()
                }
            ],
            'mask-image-b-from-color': [
                {
                    'mask-b-from': scaleColor()
                }
            ],
            'mask-image-b-to-color': [
                {
                    'mask-b-to': scaleColor()
                }
            ],
            'mask-image-l-from-pos': [
                {
                    'mask-l-from': scaleMaskImagePosition()
                }
            ],
            'mask-image-l-to-pos': [
                {
                    'mask-l-to': scaleMaskImagePosition()
                }
            ],
            'mask-image-l-from-color': [
                {
                    'mask-l-from': scaleColor()
                }
            ],
            'mask-image-l-to-color': [
                {
                    'mask-l-to': scaleColor()
                }
            ],
            'mask-image-x-from-pos': [
                {
                    'mask-x-from': scaleMaskImagePosition()
                }
            ],
            'mask-image-x-to-pos': [
                {
                    'mask-x-to': scaleMaskImagePosition()
                }
            ],
            'mask-image-x-from-color': [
                {
                    'mask-x-from': scaleColor()
                }
            ],
            'mask-image-x-to-color': [
                {
                    'mask-x-to': scaleColor()
                }
            ],
            'mask-image-y-from-pos': [
                {
                    'mask-y-from': scaleMaskImagePosition()
                }
            ],
            'mask-image-y-to-pos': [
                {
                    'mask-y-to': scaleMaskImagePosition()
                }
            ],
            'mask-image-y-from-color': [
                {
                    'mask-y-from': scaleColor()
                }
            ],
            'mask-image-y-to-color': [
                {
                    'mask-y-to': scaleColor()
                }
            ],
            'mask-image-radial': [
                {
                    'mask-radial': [
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            'mask-image-radial-from-pos': [
                {
                    'mask-radial-from': scaleMaskImagePosition()
                }
            ],
            'mask-image-radial-to-pos': [
                {
                    'mask-radial-to': scaleMaskImagePosition()
                }
            ],
            'mask-image-radial-from-color': [
                {
                    'mask-radial-from': scaleColor()
                }
            ],
            'mask-image-radial-to-color': [
                {
                    'mask-radial-to': scaleColor()
                }
            ],
            'mask-image-radial-shape': [
                {
                    'mask-radial': [
                        'circle',
                        'ellipse'
                    ]
                }
            ],
            'mask-image-radial-size': [
                {
                    'mask-radial': [
                        {
                            closest: [
                                'side',
                                'corner'
                            ],
                            farthest: [
                                'side',
                                'corner'
                            ]
                        }
                    ]
                }
            ],
            'mask-image-radial-pos': [
                {
                    'mask-radial-at': scalePosition()
                }
            ],
            'mask-image-conic-pos': [
                {
                    'mask-conic': [
                        isNumber
                    ]
                }
            ],
            'mask-image-conic-from-pos': [
                {
                    'mask-conic-from': scaleMaskImagePosition()
                }
            ],
            'mask-image-conic-to-pos': [
                {
                    'mask-conic-to': scaleMaskImagePosition()
                }
            ],
            'mask-image-conic-from-color': [
                {
                    'mask-conic-from': scaleColor()
                }
            ],
            'mask-image-conic-to-color': [
                {
                    'mask-conic-to': scaleColor()
                }
            ],
            /**
       * Mask Mode
       * @see https://tailwindcss.com/docs/mask-mode
       */ 'mask-mode': [
                {
                    mask: [
                        'alpha',
                        'luminance',
                        'match'
                    ]
                }
            ],
            /**
       * Mask Origin
       * @see https://tailwindcss.com/docs/mask-origin
       */ 'mask-origin': [
                {
                    'mask-origin': [
                        'border',
                        'padding',
                        'content',
                        'fill',
                        'stroke',
                        'view'
                    ]
                }
            ],
            /**
       * Mask Position
       * @see https://tailwindcss.com/docs/mask-position
       */ 'mask-position': [
                {
                    mask: scaleBgPosition()
                }
            ],
            /**
       * Mask Repeat
       * @see https://tailwindcss.com/docs/mask-repeat
       */ 'mask-repeat': [
                {
                    mask: scaleBgRepeat()
                }
            ],
            /**
       * Mask Size
       * @see https://tailwindcss.com/docs/mask-size
       */ 'mask-size': [
                {
                    mask: scaleBgSize()
                }
            ],
            /**
       * Mask Type
       * @see https://tailwindcss.com/docs/mask-type
       */ 'mask-type': [
                {
                    'mask-type': [
                        'alpha',
                        'luminance'
                    ]
                }
            ],
            /**
       * Mask Image
       * @see https://tailwindcss.com/docs/mask-image
       */ 'mask-image': [
                {
                    mask: [
                        'none',
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            // ---------------
            // --- Filters ---
            // ---------------
            /**
       * Filter
       * @see https://tailwindcss.com/docs/filter
       */ filter: [
                {
                    filter: [
                        // Deprecated since Tailwind CSS v3.0.0
                        '',
                        'none',
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */ blur: [
                {
                    blur: scaleBlur()
                }
            ],
            /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */ brightness: [
                {
                    brightness: [
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */ contrast: [
                {
                    contrast: [
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */ 'drop-shadow': [
                {
                    'drop-shadow': [
                        // Deprecated since Tailwind CSS v4.0.0
                        '',
                        'none',
                        themeDropShadow,
                        isArbitraryVariableShadow,
                        isArbitraryShadow
                    ]
                }
            ],
            /**
       * Drop Shadow Color
       * @see https://tailwindcss.com/docs/filter-drop-shadow#setting-the-shadow-color
       */ 'drop-shadow-color': [
                {
                    'drop-shadow': scaleColor()
                }
            ],
            /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */ grayscale: [
                {
                    grayscale: [
                        '',
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */ 'hue-rotate': [
                {
                    'hue-rotate': [
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */ invert: [
                {
                    invert: [
                        '',
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */ saturate: [
                {
                    saturate: [
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */ sepia: [
                {
                    sepia: [
                        '',
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Backdrop Filter
       * @see https://tailwindcss.com/docs/backdrop-filter
       */ 'backdrop-filter': [
                {
                    'backdrop-filter': [
                        // Deprecated since Tailwind CSS v3.0.0
                        '',
                        'none',
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */ 'backdrop-blur': [
                {
                    'backdrop-blur': scaleBlur()
                }
            ],
            /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */ 'backdrop-brightness': [
                {
                    'backdrop-brightness': [
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */ 'backdrop-contrast': [
                {
                    'backdrop-contrast': [
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */ 'backdrop-grayscale': [
                {
                    'backdrop-grayscale': [
                        '',
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */ 'backdrop-hue-rotate': [
                {
                    'backdrop-hue-rotate': [
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */ 'backdrop-invert': [
                {
                    'backdrop-invert': [
                        '',
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */ 'backdrop-opacity': [
                {
                    'backdrop-opacity': [
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */ 'backdrop-saturate': [
                {
                    'backdrop-saturate': [
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */ 'backdrop-sepia': [
                {
                    'backdrop-sepia': [
                        '',
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            // --------------
            // --- Tables ---
            // --------------
            /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */ 'border-collapse': [
                {
                    border: [
                        'collapse',
                        'separate'
                    ]
                }
            ],
            /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */ 'border-spacing': [
                {
                    'border-spacing': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */ 'border-spacing-x': [
                {
                    'border-spacing-x': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */ 'border-spacing-y': [
                {
                    'border-spacing-y': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */ 'table-layout': [
                {
                    table: [
                        'auto',
                        'fixed'
                    ]
                }
            ],
            /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */ caption: [
                {
                    caption: [
                        'top',
                        'bottom'
                    ]
                }
            ],
            // ---------------------------------
            // --- Transitions and Animation ---
            // ---------------------------------
            /**
       * Transition Property
       * @see https://tailwindcss.com/docs/transition-property
       */ transition: [
                {
                    transition: [
                        '',
                        'all',
                        'colors',
                        'opacity',
                        'shadow',
                        'transform',
                        'none',
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Transition Behavior
       * @see https://tailwindcss.com/docs/transition-behavior
       */ 'transition-behavior': [
                {
                    transition: [
                        'normal',
                        'discrete'
                    ]
                }
            ],
            /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */ duration: [
                {
                    duration: [
                        isNumber,
                        'initial',
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */ ease: [
                {
                    ease: [
                        'linear',
                        'initial',
                        themeEase,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */ delay: [
                {
                    delay: [
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */ animate: [
                {
                    animate: [
                        'none',
                        themeAnimate,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            // ------------------
            // --- Transforms ---
            // ------------------
            /**
       * Backface Visibility
       * @see https://tailwindcss.com/docs/backface-visibility
       */ backface: [
                {
                    backface: [
                        'hidden',
                        'visible'
                    ]
                }
            ],
            /**
       * Perspective
       * @see https://tailwindcss.com/docs/perspective
       */ perspective: [
                {
                    perspective: [
                        themePerspective,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Perspective Origin
       * @see https://tailwindcss.com/docs/perspective-origin
       */ 'perspective-origin': [
                {
                    'perspective-origin': scalePositionWithArbitrary()
                }
            ],
            /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */ rotate: [
                {
                    rotate: scaleRotate()
                }
            ],
            /**
       * Rotate X
       * @see https://tailwindcss.com/docs/rotate
       */ 'rotate-x': [
                {
                    'rotate-x': scaleRotate()
                }
            ],
            /**
       * Rotate Y
       * @see https://tailwindcss.com/docs/rotate
       */ 'rotate-y': [
                {
                    'rotate-y': scaleRotate()
                }
            ],
            /**
       * Rotate Z
       * @see https://tailwindcss.com/docs/rotate
       */ 'rotate-z': [
                {
                    'rotate-z': scaleRotate()
                }
            ],
            /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */ scale: [
                {
                    scale: scaleScale()
                }
            ],
            /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */ 'scale-x': [
                {
                    'scale-x': scaleScale()
                }
            ],
            /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */ 'scale-y': [
                {
                    'scale-y': scaleScale()
                }
            ],
            /**
       * Scale Z
       * @see https://tailwindcss.com/docs/scale
       */ 'scale-z': [
                {
                    'scale-z': scaleScale()
                }
            ],
            /**
       * Scale 3D
       * @see https://tailwindcss.com/docs/scale
       */ 'scale-3d': [
                'scale-3d'
            ],
            /**
       * Skew
       * @see https://tailwindcss.com/docs/skew
       */ skew: [
                {
                    skew: scaleSkew()
                }
            ],
            /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */ 'skew-x': [
                {
                    'skew-x': scaleSkew()
                }
            ],
            /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */ 'skew-y': [
                {
                    'skew-y': scaleSkew()
                }
            ],
            /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */ transform: [
                {
                    transform: [
                        isArbitraryVariable,
                        isArbitraryValue,
                        '',
                        'none',
                        'gpu',
                        'cpu'
                    ]
                }
            ],
            /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */ 'transform-origin': [
                {
                    origin: scalePositionWithArbitrary()
                }
            ],
            /**
       * Transform Style
       * @see https://tailwindcss.com/docs/transform-style
       */ 'transform-style': [
                {
                    transform: [
                        '3d',
                        'flat'
                    ]
                }
            ],
            /**
       * Translate
       * @see https://tailwindcss.com/docs/translate
       */ translate: [
                {
                    translate: scaleTranslate()
                }
            ],
            /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */ 'translate-x': [
                {
                    'translate-x': scaleTranslate()
                }
            ],
            /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */ 'translate-y': [
                {
                    'translate-y': scaleTranslate()
                }
            ],
            /**
       * Translate Z
       * @see https://tailwindcss.com/docs/translate
       */ 'translate-z': [
                {
                    'translate-z': scaleTranslate()
                }
            ],
            /**
       * Translate None
       * @see https://tailwindcss.com/docs/translate
       */ 'translate-none': [
                'translate-none'
            ],
            // ---------------------
            // --- Interactivity ---
            // ---------------------
            /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */ accent: [
                {
                    accent: scaleColor()
                }
            ],
            /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */ appearance: [
                {
                    appearance: [
                        'none',
                        'auto'
                    ]
                }
            ],
            /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */ 'caret-color': [
                {
                    caret: scaleColor()
                }
            ],
            /**
       * Color Scheme
       * @see https://tailwindcss.com/docs/color-scheme
       */ 'color-scheme': [
                {
                    scheme: [
                        'normal',
                        'dark',
                        'light',
                        'light-dark',
                        'only-dark',
                        'only-light'
                    ]
                }
            ],
            /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */ cursor: [
                {
                    cursor: [
                        'auto',
                        'default',
                        'pointer',
                        'wait',
                        'text',
                        'move',
                        'help',
                        'not-allowed',
                        'none',
                        'context-menu',
                        'progress',
                        'cell',
                        'crosshair',
                        'vertical-text',
                        'alias',
                        'copy',
                        'no-drop',
                        'grab',
                        'grabbing',
                        'all-scroll',
                        'col-resize',
                        'row-resize',
                        'n-resize',
                        'e-resize',
                        's-resize',
                        'w-resize',
                        'ne-resize',
                        'nw-resize',
                        'se-resize',
                        'sw-resize',
                        'ew-resize',
                        'ns-resize',
                        'nesw-resize',
                        'nwse-resize',
                        'zoom-in',
                        'zoom-out',
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Field Sizing
       * @see https://tailwindcss.com/docs/field-sizing
       */ 'field-sizing': [
                {
                    'field-sizing': [
                        'fixed',
                        'content'
                    ]
                }
            ],
            /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */ 'pointer-events': [
                {
                    'pointer-events': [
                        'auto',
                        'none'
                    ]
                }
            ],
            /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */ resize: [
                {
                    resize: [
                        'none',
                        '',
                        'y',
                        'x'
                    ]
                }
            ],
            /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */ 'scroll-behavior': [
                {
                    scroll: [
                        'auto',
                        'smooth'
                    ]
                }
            ],
            /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */ 'scroll-m': [
                {
                    'scroll-m': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */ 'scroll-mx': [
                {
                    'scroll-mx': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */ 'scroll-my': [
                {
                    'scroll-my': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */ 'scroll-ms': [
                {
                    'scroll-ms': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */ 'scroll-me': [
                {
                    'scroll-me': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */ 'scroll-mt': [
                {
                    'scroll-mt': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */ 'scroll-mr': [
                {
                    'scroll-mr': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */ 'scroll-mb': [
                {
                    'scroll-mb': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */ 'scroll-ml': [
                {
                    'scroll-ml': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */ 'scroll-p': [
                {
                    'scroll-p': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */ 'scroll-px': [
                {
                    'scroll-px': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */ 'scroll-py': [
                {
                    'scroll-py': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */ 'scroll-ps': [
                {
                    'scroll-ps': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */ 'scroll-pe': [
                {
                    'scroll-pe': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */ 'scroll-pt': [
                {
                    'scroll-pt': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */ 'scroll-pr': [
                {
                    'scroll-pr': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */ 'scroll-pb': [
                {
                    'scroll-pb': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */ 'scroll-pl': [
                {
                    'scroll-pl': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */ 'snap-align': [
                {
                    snap: [
                        'start',
                        'end',
                        'center',
                        'align-none'
                    ]
                }
            ],
            /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */ 'snap-stop': [
                {
                    snap: [
                        'normal',
                        'always'
                    ]
                }
            ],
            /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */ 'snap-type': [
                {
                    snap: [
                        'none',
                        'x',
                        'y',
                        'both'
                    ]
                }
            ],
            /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */ 'snap-strictness': [
                {
                    snap: [
                        'mandatory',
                        'proximity'
                    ]
                }
            ],
            /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */ touch: [
                {
                    touch: [
                        'auto',
                        'none',
                        'manipulation'
                    ]
                }
            ],
            /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */ 'touch-x': [
                {
                    'touch-pan': [
                        'x',
                        'left',
                        'right'
                    ]
                }
            ],
            /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */ 'touch-y': [
                {
                    'touch-pan': [
                        'y',
                        'up',
                        'down'
                    ]
                }
            ],
            /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */ 'touch-pz': [
                'touch-pinch-zoom'
            ],
            /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */ select: [
                {
                    select: [
                        'none',
                        'text',
                        'all',
                        'auto'
                    ]
                }
            ],
            /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */ 'will-change': [
                {
                    'will-change': [
                        'auto',
                        'scroll',
                        'contents',
                        'transform',
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            // -----------
            // --- SVG ---
            // -----------
            /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */ fill: [
                {
                    fill: [
                        'none',
                        ...scaleColor()
                    ]
                }
            ],
            /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */ 'stroke-w': [
                {
                    stroke: [
                        isNumber,
                        isArbitraryVariableLength,
                        isArbitraryLength,
                        isArbitraryNumber
                    ]
                }
            ],
            /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */ stroke: [
                {
                    stroke: [
                        'none',
                        ...scaleColor()
                    ]
                }
            ],
            // ---------------------
            // --- Accessibility ---
            // ---------------------
            /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */ 'forced-color-adjust': [
                {
                    'forced-color-adjust': [
                        'auto',
                        'none'
                    ]
                }
            ]
        },
        conflictingClassGroups: {
            overflow: [
                'overflow-x',
                'overflow-y'
            ],
            overscroll: [
                'overscroll-x',
                'overscroll-y'
            ],
            inset: [
                'inset-x',
                'inset-y',
                'start',
                'end',
                'top',
                'right',
                'bottom',
                'left'
            ],
            'inset-x': [
                'right',
                'left'
            ],
            'inset-y': [
                'top',
                'bottom'
            ],
            flex: [
                'basis',
                'grow',
                'shrink'
            ],
            gap: [
                'gap-x',
                'gap-y'
            ],
            p: [
                'px',
                'py',
                'ps',
                'pe',
                'pt',
                'pr',
                'pb',
                'pl'
            ],
            px: [
                'pr',
                'pl'
            ],
            py: [
                'pt',
                'pb'
            ],
            m: [
                'mx',
                'my',
                'ms',
                'me',
                'mt',
                'mr',
                'mb',
                'ml'
            ],
            mx: [
                'mr',
                'ml'
            ],
            my: [
                'mt',
                'mb'
            ],
            size: [
                'w',
                'h'
            ],
            'font-size': [
                'leading'
            ],
            'fvn-normal': [
                'fvn-ordinal',
                'fvn-slashed-zero',
                'fvn-figure',
                'fvn-spacing',
                'fvn-fraction'
            ],
            'fvn-ordinal': [
                'fvn-normal'
            ],
            'fvn-slashed-zero': [
                'fvn-normal'
            ],
            'fvn-figure': [
                'fvn-normal'
            ],
            'fvn-spacing': [
                'fvn-normal'
            ],
            'fvn-fraction': [
                'fvn-normal'
            ],
            'line-clamp': [
                'display',
                'overflow'
            ],
            rounded: [
                'rounded-s',
                'rounded-e',
                'rounded-t',
                'rounded-r',
                'rounded-b',
                'rounded-l',
                'rounded-ss',
                'rounded-se',
                'rounded-ee',
                'rounded-es',
                'rounded-tl',
                'rounded-tr',
                'rounded-br',
                'rounded-bl'
            ],
            'rounded-s': [
                'rounded-ss',
                'rounded-es'
            ],
            'rounded-e': [
                'rounded-se',
                'rounded-ee'
            ],
            'rounded-t': [
                'rounded-tl',
                'rounded-tr'
            ],
            'rounded-r': [
                'rounded-tr',
                'rounded-br'
            ],
            'rounded-b': [
                'rounded-br',
                'rounded-bl'
            ],
            'rounded-l': [
                'rounded-tl',
                'rounded-bl'
            ],
            'border-spacing': [
                'border-spacing-x',
                'border-spacing-y'
            ],
            'border-w': [
                'border-w-x',
                'border-w-y',
                'border-w-s',
                'border-w-e',
                'border-w-t',
                'border-w-r',
                'border-w-b',
                'border-w-l'
            ],
            'border-w-x': [
                'border-w-r',
                'border-w-l'
            ],
            'border-w-y': [
                'border-w-t',
                'border-w-b'
            ],
            'border-color': [
                'border-color-x',
                'border-color-y',
                'border-color-s',
                'border-color-e',
                'border-color-t',
                'border-color-r',
                'border-color-b',
                'border-color-l'
            ],
            'border-color-x': [
                'border-color-r',
                'border-color-l'
            ],
            'border-color-y': [
                'border-color-t',
                'border-color-b'
            ],
            translate: [
                'translate-x',
                'translate-y',
                'translate-none'
            ],
            'translate-none': [
                'translate',
                'translate-x',
                'translate-y',
                'translate-z'
            ],
            'scroll-m': [
                'scroll-mx',
                'scroll-my',
                'scroll-ms',
                'scroll-me',
                'scroll-mt',
                'scroll-mr',
                'scroll-mb',
                'scroll-ml'
            ],
            'scroll-mx': [
                'scroll-mr',
                'scroll-ml'
            ],
            'scroll-my': [
                'scroll-mt',
                'scroll-mb'
            ],
            'scroll-p': [
                'scroll-px',
                'scroll-py',
                'scroll-ps',
                'scroll-pe',
                'scroll-pt',
                'scroll-pr',
                'scroll-pb',
                'scroll-pl'
            ],
            'scroll-px': [
                'scroll-pr',
                'scroll-pl'
            ],
            'scroll-py': [
                'scroll-pt',
                'scroll-pb'
            ],
            touch: [
                'touch-x',
                'touch-y',
                'touch-pz'
            ],
            'touch-x': [
                'touch'
            ],
            'touch-y': [
                'touch'
            ],
            'touch-pz': [
                'touch'
            ]
        },
        conflictingClassGroupModifiers: {
            'font-size': [
                'leading'
            ]
        },
        orderSensitiveModifiers: [
            '*',
            '**',
            'after',
            'backdrop',
            'before',
            'details-content',
            'file',
            'first-letter',
            'first-line',
            'marker',
            'placeholder',
            'selection'
        ]
    };
};
/**
 * @param baseConfig Config where other config will be merged into. This object will be mutated.
 * @param configExtension Partial config to merge into the `baseConfig`.
 */ const mergeConfigs = (baseConfig, { cacheSize, prefix, experimentalParseClassName, extend = {}, override = {} })=>{
    overrideProperty(baseConfig, 'cacheSize', cacheSize);
    overrideProperty(baseConfig, 'prefix', prefix);
    overrideProperty(baseConfig, 'experimentalParseClassName', experimentalParseClassName);
    overrideConfigProperties(baseConfig.theme, override.theme);
    overrideConfigProperties(baseConfig.classGroups, override.classGroups);
    overrideConfigProperties(baseConfig.conflictingClassGroups, override.conflictingClassGroups);
    overrideConfigProperties(baseConfig.conflictingClassGroupModifiers, override.conflictingClassGroupModifiers);
    overrideProperty(baseConfig, 'orderSensitiveModifiers', override.orderSensitiveModifiers);
    mergeConfigProperties(baseConfig.theme, extend.theme);
    mergeConfigProperties(baseConfig.classGroups, extend.classGroups);
    mergeConfigProperties(baseConfig.conflictingClassGroups, extend.conflictingClassGroups);
    mergeConfigProperties(baseConfig.conflictingClassGroupModifiers, extend.conflictingClassGroupModifiers);
    mergeArrayProperties(baseConfig, extend, 'orderSensitiveModifiers');
    return baseConfig;
};
const overrideProperty = (baseObject, overrideKey, overrideValue)=>{
    if (overrideValue !== undefined) {
        baseObject[overrideKey] = overrideValue;
    }
};
const overrideConfigProperties = (baseObject, overrideObject)=>{
    if (overrideObject) {
        for(const key in overrideObject){
            overrideProperty(baseObject, key, overrideObject[key]);
        }
    }
};
const mergeConfigProperties = (baseObject, mergeObject)=>{
    if (mergeObject) {
        for(const key in mergeObject){
            mergeArrayProperties(baseObject, mergeObject, key);
        }
    }
};
const mergeArrayProperties = (baseObject, mergeObject, key)=>{
    const mergeValue = mergeObject[key];
    if (mergeValue !== undefined) {
        baseObject[key] = baseObject[key] ? baseObject[key].concat(mergeValue) : mergeValue;
    }
};
const extendTailwindMerge = (configExtension, ...createConfig)=>typeof configExtension === 'function' ? createTailwindMerge(getDefaultConfig, configExtension, ...createConfig) : createTailwindMerge(()=>mergeConfigs(getDefaultConfig(), configExtension), ...createConfig);
const twMerge = /*#__PURE__*/ createTailwindMerge(getDefaultConfig);
;
 //# sourceMappingURL=bundle-mjs.mjs.map
}),
"[project]/node_modules/lucide-react/dist/esm/shared/src/utils.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * @license lucide-react v0.523.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_context__.s({
    "hasA11yProp": ()=>hasA11yProp,
    "mergeClasses": ()=>mergeClasses,
    "toCamelCase": ()=>toCamelCase,
    "toKebabCase": ()=>toKebabCase,
    "toPascalCase": ()=>toPascalCase
});
const toKebabCase = (string)=>string.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
const toCamelCase = (string)=>string.replace(/^([A-Z])|[\s-_]+(\w)/g, (match, p1, p2)=>p2 ? p2.toUpperCase() : p1.toLowerCase());
const toPascalCase = (string)=>{
    const camelCase = toCamelCase(string);
    return camelCase.charAt(0).toUpperCase() + camelCase.slice(1);
};
const mergeClasses = (...classes)=>classes.filter((className, index, array)=>{
        return Boolean(className) && className.trim() !== "" && array.indexOf(className) === index;
    }).join(" ").trim();
const hasA11yProp = (props)=>{
    for(const prop in props){
        if (prop.startsWith("aria-") || prop === "role" || prop === "title") {
            return true;
        }
    }
};
;
 //# sourceMappingURL=utils.js.map
}),
"[project]/node_modules/lucide-react/dist/esm/defaultAttributes.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * @license lucide-react v0.523.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_context__.s({
    "default": ()=>defaultAttributes
});
var defaultAttributes = {
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: 2,
    strokeLinecap: "round",
    strokeLinejoin: "round"
};
;
 //# sourceMappingURL=defaultAttributes.js.map
}),
"[project]/node_modules/lucide-react/dist/esm/Icon.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * @license lucide-react v0.523.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_context__.s({
    "default": ()=>Icon
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$defaultAttributes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/defaultAttributes.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$shared$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/shared/src/utils.js [app-ssr] (ecmascript)");
;
;
;
const Icon = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["forwardRef"])(({ color = "currentColor", size = 24, strokeWidth = 2, absoluteStrokeWidth, className = "", children, iconNode, ...rest }, ref)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createElement"])("svg", {
        ref,
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$defaultAttributes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"],
        width: size,
        height: size,
        stroke: color,
        strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size) : strokeWidth,
        className: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$shared$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["mergeClasses"])("lucide", className),
        ...!children && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$shared$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hasA11yProp"])(rest) && {
            "aria-hidden": "true"
        },
        ...rest
    }, [
        ...iconNode.map(([tag, attrs])=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createElement"])(tag, attrs)),
        ...Array.isArray(children) ? children : [
            children
        ]
    ]));
;
 //# sourceMappingURL=Icon.js.map
}),
"[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * @license lucide-react v0.523.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_context__.s({
    "default": ()=>createLucideIcon
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$shared$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/shared/src/utils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$Icon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/Icon.js [app-ssr] (ecmascript)");
;
;
;
const createLucideIcon = (iconName, iconNode)=>{
    const Component = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["forwardRef"])(({ className, ...props }, ref)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createElement"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$Icon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"], {
            ref,
            iconNode,
            className: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$shared$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["mergeClasses"])(`lucide-${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$shared$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toKebabCase"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$shared$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toPascalCase"])(iconName))}`, `lucide-${iconName}`, className),
            ...props
        }));
    Component.displayName = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$shared$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toPascalCase"])(iconName);
    return Component;
};
;
 //# sourceMappingURL=createLucideIcon.js.map
}),
"[project]/node_modules/lucide-react/dist/esm/icons/ghost.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * @license lucide-react v0.523.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_context__.s({
    "__iconNode": ()=>__iconNode,
    "default": ()=>Ghost
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-ssr] (ecmascript)");
;
const __iconNode = [
    [
        "path",
        {
            d: "M9 10h.01",
            key: "qbtxuw"
        }
    ],
    [
        "path",
        {
            d: "M15 10h.01",
            key: "1qmjsl"
        }
    ],
    [
        "path",
        {
            d: "M12 2a8 8 0 0 0-8 8v12l3-3 2.5 2.5L12 19l2.5 2.5L17 19l3 3V10a8 8 0 0 0-8-8z",
            key: "uwwb07"
        }
    ]
];
const Ghost = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("ghost", __iconNode);
;
 //# sourceMappingURL=ghost.js.map
}),
"[project]/node_modules/lucide-react/dist/esm/icons/ghost.js [app-ssr] (ecmascript) <export default as Ghost>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "Ghost": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$ghost$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$ghost$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/icons/ghost.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/lucide-react/dist/esm/icons/house.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * @license lucide-react v0.523.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_context__.s({
    "__iconNode": ()=>__iconNode,
    "default": ()=>House
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-ssr] (ecmascript)");
;
const __iconNode = [
    [
        "path",
        {
            d: "M15 21v-8a1 1 0 0 0-1-1h-4a1 1 0 0 0-1 1v8",
            key: "5wwlr5"
        }
    ],
    [
        "path",
        {
            d: "M3 10a2 2 0 0 1 .709-1.528l7-5.999a2 2 0 0 1 2.582 0l7 5.999A2 2 0 0 1 21 10v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z",
            key: "1d0kgt"
        }
    ]
];
const House = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("house", __iconNode);
;
 //# sourceMappingURL=house.js.map
}),
"[project]/node_modules/lucide-react/dist/esm/icons/house.js [app-ssr] (ecmascript) <export default as Home>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "Home": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$house$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$house$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/icons/house.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/lucide-react/dist/esm/icons/arrow-left.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * @license lucide-react v0.523.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_context__.s({
    "__iconNode": ()=>__iconNode,
    "default": ()=>ArrowLeft
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-ssr] (ecmascript)");
;
const __iconNode = [
    [
        "path",
        {
            d: "m12 19-7-7 7-7",
            key: "1l729n"
        }
    ],
    [
        "path",
        {
            d: "M19 12H5",
            key: "x3x0zl"
        }
    ]
];
const ArrowLeft = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("arrow-left", __iconNode);
;
 //# sourceMappingURL=arrow-left.js.map
}),
"[project]/node_modules/lucide-react/dist/esm/icons/arrow-left.js [app-ssr] (ecmascript) <export default as ArrowLeft>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "ArrowLeft": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$arrow$2d$left$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$arrow$2d$left$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/icons/arrow-left.js [app-ssr] (ecmascript)");
}),

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFtdLAogICJzZWN0aW9ucyI6IFsKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNywgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy8lNDBzd2MvaGVscGVycy9janMvX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZC5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkge1xuICAgIGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDtcblxuICAgIHZhciBjYWNoZUJhYmVsSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgdmFyIGNhY2hlTm9kZUludGVyb3AgPSBuZXcgV2Vha01hcCgpO1xuXG4gICAgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbihub2RlSW50ZXJvcCkge1xuICAgICAgICByZXR1cm4gbm9kZUludGVyb3AgPyBjYWNoZU5vZGVJbnRlcm9wIDogY2FjaGVCYWJlbEludGVyb3A7XG4gICAgfSkobm9kZUludGVyb3ApO1xufVxuZnVuY3Rpb24gX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZChvYmosIG5vZGVJbnRlcm9wKSB7XG4gICAgaWYgKCFub2RlSW50ZXJvcCAmJiBvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHJldHVybiBvYmo7XG4gICAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHsgZGVmYXVsdDogb2JqIH07XG5cbiAgICB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApO1xuXG4gICAgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSByZXR1cm4gY2FjaGUuZ2V0KG9iaik7XG5cbiAgICB2YXIgbmV3T2JqID0geyBfX3Byb3RvX186IG51bGwgfTtcbiAgICB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChrZXkgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICAgIHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsO1xuICAgICAgICAgICAgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTtcbiAgICAgICAgICAgIGVsc2UgbmV3T2JqW2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5ld09iai5kZWZhdWx0ID0gb2JqO1xuXG4gICAgaWYgKGNhY2hlKSBjYWNoZS5zZXQob2JqLCBuZXdPYmopO1xuXG4gICAgcmV0dXJuIG5ld09iajtcbn1cbmV4cG9ydHMuXyA9IF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQ7XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBRUEsU0FBUyx5QkFBeUIsV0FBVztJQUN6QyxJQUFJLE9BQU8sWUFBWSxZQUFZLE9BQU87SUFFMUMsSUFBSSxvQkFBb0IsSUFBSTtJQUM1QixJQUFJLG1CQUFtQixJQUFJO0lBRTNCLE9BQU8sQ0FBQywyQkFBMkIsU0FBUyxXQUFXO1FBQ25ELE9BQU8sY0FBYyxtQkFBbUI7SUFDNUMsQ0FBQyxFQUFFO0FBQ1A7QUFDQSxTQUFTLDBCQUEwQixHQUFHLEVBQUUsV0FBVztJQUMvQyxJQUFJLENBQUMsZUFBZSxPQUFPLElBQUksVUFBVSxFQUFFLE9BQU87SUFDbEQsSUFBSSxRQUFRLFFBQVEsT0FBTyxRQUFRLFlBQVksT0FBTyxRQUFRLFlBQVksT0FBTztRQUFFLFNBQVM7SUFBSTtJQUVoRyxJQUFJLFFBQVEseUJBQXlCO0lBRXJDLElBQUksU0FBUyxNQUFNLEdBQUcsQ0FBQyxNQUFNLE9BQU8sTUFBTSxHQUFHLENBQUM7SUFFOUMsSUFBSSxTQUFTO1FBQUUsV0FBVztJQUFLO0lBQy9CLElBQUksd0JBQXdCLE9BQU8sY0FBYyxJQUFJLE9BQU8sd0JBQXdCO0lBRXBGLElBQUssSUFBSSxPQUFPLElBQUs7UUFDakIsSUFBSSxRQUFRLGFBQWEsT0FBTyxTQUFTLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxLQUFLLE1BQU07WUFDckUsSUFBSSxPQUFPLHdCQUF3QixPQUFPLHdCQUF3QixDQUFDLEtBQUssT0FBTztZQUMvRSxJQUFJLFFBQVEsQ0FBQyxLQUFLLEdBQUcsSUFBSSxLQUFLLEdBQUcsR0FBRyxPQUFPLGNBQWMsQ0FBQyxRQUFRLEtBQUs7aUJBQ2xFLE1BQU0sQ0FBQyxJQUFJLEdBQUcsR0FBRyxDQUFDLElBQUk7UUFDL0I7SUFDSjtJQUVBLE9BQU8sT0FBTyxHQUFHO0lBRWpCLElBQUksT0FBTyxNQUFNLEdBQUcsQ0FBQyxLQUFLO0lBRTFCLE9BQU87QUFDWDtBQUNBLFFBQVEsQ0FBQyxHQUFHIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDQ0LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3F1ZXJ5c3RyaW5nLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgUGFyc2VkVXJsUXVlcnkgfSBmcm9tICdxdWVyeXN0cmluZydcblxuZXhwb3J0IGZ1bmN0aW9uIHNlYXJjaFBhcmFtc1RvVXJsUXVlcnkoXG4gIHNlYXJjaFBhcmFtczogVVJMU2VhcmNoUGFyYW1zXG4pOiBQYXJzZWRVcmxRdWVyeSB7XG4gIGNvbnN0IHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeSA9IHt9XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHNlYXJjaFBhcmFtcy5lbnRyaWVzKCkpIHtcbiAgICBjb25zdCBleGlzdGluZyA9IHF1ZXJ5W2tleV1cbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcXVlcnlba2V5XSA9IHZhbHVlXG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGV4aXN0aW5nKSkge1xuICAgICAgZXhpc3RpbmcucHVzaCh2YWx1ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgcXVlcnlba2V5XSA9IFtleGlzdGluZywgdmFsdWVdXG4gICAgfVxuICB9XG4gIHJldHVybiBxdWVyeVxufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlVcmxRdWVyeVBhcmFtKHBhcmFtOiB1bmtub3duKTogc3RyaW5nIHtcbiAgaWYgKHR5cGVvZiBwYXJhbSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGFyYW1cbiAgfVxuXG4gIGlmIChcbiAgICAodHlwZW9mIHBhcmFtID09PSAnbnVtYmVyJyAmJiAhaXNOYU4ocGFyYW0pKSB8fFxuICAgIHR5cGVvZiBwYXJhbSA9PT0gJ2Jvb2xlYW4nXG4gICkge1xuICAgIHJldHVybiBTdHJpbmcocGFyYW0pXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICcnXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVybFF1ZXJ5VG9TZWFyY2hQYXJhbXMocXVlcnk6IFBhcnNlZFVybFF1ZXJ5KTogVVJMU2VhcmNoUGFyYW1zIHtcbiAgY29uc3Qgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpXG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHF1ZXJ5KSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHZhbHVlKSB7XG4gICAgICAgIHNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCBzdHJpbmdpZnlVcmxRdWVyeVBhcmFtKGl0ZW0pKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzZWFyY2hQYXJhbXMuc2V0KGtleSwgc3RyaW5naWZ5VXJsUXVlcnlQYXJhbSh2YWx1ZSkpXG4gICAgfVxuICB9XG4gIHJldHVybiBzZWFyY2hQYXJhbXNcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbihcbiAgdGFyZ2V0OiBVUkxTZWFyY2hQYXJhbXMsXG4gIC4uLnNlYXJjaFBhcmFtc0xpc3Q6IFVSTFNlYXJjaFBhcmFtc1tdXG4pOiBVUkxTZWFyY2hQYXJhbXMge1xuICBmb3IgKGNvbnN0IHNlYXJjaFBhcmFtcyBvZiBzZWFyY2hQYXJhbXNMaXN0KSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2Ygc2VhcmNoUGFyYW1zLmtleXMoKSkge1xuICAgICAgdGFyZ2V0LmRlbGV0ZShrZXkpXG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Ygc2VhcmNoUGFyYW1zLmVudHJpZXMoKSkge1xuICAgICAgdGFyZ2V0LmFwcGVuZChrZXksIHZhbHVlKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXRcbn1cbiJdLCJuYW1lcyI6WyJhc3NpZ24iLCJzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5IiwidXJsUXVlcnlUb1NlYXJjaFBhcmFtcyIsInNlYXJjaFBhcmFtcyIsInF1ZXJ5Iiwia2V5IiwidmFsdWUiLCJlbnRyaWVzIiwiZXhpc3RpbmciLCJBcnJheSIsImlzQXJyYXkiLCJwdXNoIiwic3RyaW5naWZ5VXJsUXVlcnlQYXJhbSIsInBhcmFtIiwiaXNOYU4iLCJTdHJpbmciLCJVUkxTZWFyY2hQYXJhbXMiLCJPYmplY3QiLCJpdGVtIiwiYXBwZW5kIiwic2V0IiwidGFyZ2V0Iiwic2VhcmNoUGFyYW1zTGlzdCIsImtleXMiLCJkZWxldGUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztJQWdEZ0JBLE1BQU0sRUFBQTtlQUFOQTs7SUE5Q0FDLHNCQUFzQixFQUFBO2VBQXRCQTs7SUFnQ0FDLHNCQUFzQixFQUFBO2VBQXRCQTs7O0FBaENULFNBQVNELHVCQUNkRSxZQUE2QjtJQUU3QixNQUFNQyxRQUF3QixDQUFDO0lBQy9CLEtBQUssTUFBTSxDQUFDQyxLQUFLQyxNQUFNLElBQUlILGFBQWFJLE9BQU8sR0FBSTtRQUNqRCxNQUFNQyxXQUFXSixLQUFLLENBQUNDLElBQUk7UUFDM0IsSUFBSSxPQUFPRyxhQUFhLGFBQWE7WUFDbkNKLEtBQUssQ0FBQ0MsSUFBSSxHQUFHQztRQUNmLE9BQU8sSUFBSUcsTUFBTUMsT0FBTyxDQUFDRixXQUFXO1lBQ2xDQSxTQUFTRyxJQUFJLENBQUNMO1FBQ2hCLE9BQU87WUFDTEYsS0FBSyxDQUFDQyxJQUFJLEdBQUc7Z0JBQUNHO2dCQUFVRjthQUFNO1FBQ2hDO0lBQ0Y7SUFDQSxPQUFPRjtBQUNUO0FBRUEsU0FBU1EsdUJBQXVCQyxLQUFjO0lBQzVDLElBQUksT0FBT0EsVUFBVSxVQUFVO1FBQzdCLE9BQU9BO0lBQ1Q7SUFFQSxJQUNHLE9BQU9BLFVBQVUsWUFBWSxDQUFDQyxNQUFNRCxVQUNyQyxPQUFPQSxVQUFVLFdBQ2pCO1FBQ0EsT0FBT0UsT0FBT0Y7SUFDaEIsT0FBTztRQUNMLE9BQU87SUFDVDtBQUNGO0FBRU8sU0FBU1gsdUJBQXVCRSxLQUFxQjtJQUMxRCxNQUFNRCxlQUFlLElBQUlhO0lBQ3pCLEtBQUssTUFBTSxDQUFDWCxLQUFLQyxNQUFNLElBQUlXLE9BQU9WLE9BQU8sQ0FBQ0gsT0FBUTtRQUNoRCxJQUFJSyxNQUFNQyxPQUFPLENBQUNKLFFBQVE7WUFDeEIsS0FBSyxNQUFNWSxRQUFRWixNQUFPO2dCQUN4QkgsYUFBYWdCLE1BQU0sQ0FBQ2QsS0FBS08sdUJBQXVCTTtZQUNsRDtRQUNGLE9BQU87WUFDTGYsYUFBYWlCLEdBQUcsQ0FBQ2YsS0FBS08sdUJBQXVCTjtRQUMvQztJQUNGO0lBQ0EsT0FBT0g7QUFDVDtBQUVPLFNBQVNILE9BQ2RxQixNQUF1QjtJQUN2QixJQUFBLElBQUEsT0FBQSxVQUFBLE1BQUEsRUFBR0MsbUJBQUgsSUFBQSxNQUFBLE9BQUEsSUFBQSxPQUFBLElBQUEsSUFBQSxPQUFBLEdBQUEsT0FBQSxNQUFBLE9BQUE7UUFBR0EsZ0JBQUFBLENBQUgsT0FBQSxFQUFBLEdBQUEsU0FBQSxDQUFBLEtBQXNDOztJQUV0QyxLQUFLLE1BQU1uQixnQkFBZ0JtQixpQkFBa0I7UUFDM0MsS0FBSyxNQUFNakIsT0FBT0YsYUFBYW9CLElBQUksR0FBSTtZQUNyQ0YsT0FBT0csTUFBTSxDQUFDbkI7UUFDaEI7UUFFQSxLQUFLLE1BQU0sQ0FBQ0EsS0FBS0MsTUFBTSxJQUFJSCxhQUFhSSxPQUFPLEdBQUk7WUFDakRjLE9BQU9GLE1BQU0sQ0FBQ2QsS0FBS0M7UUFDckI7SUFDRjtJQUVBLE9BQU9lO0FBQ1QiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTI5LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2Zvcm1hdC11cmwudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRm9ybWF0IGZ1bmN0aW9uIG1vZGlmaWVkIGZyb20gbm9kZWpzXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHR5cGUgeyBVcmxPYmplY3QgfSBmcm9tICd1cmwnXG5pbXBvcnQgdHlwZSB7IFBhcnNlZFVybFF1ZXJ5IH0gZnJvbSAncXVlcnlzdHJpbmcnXG5pbXBvcnQgKiBhcyBxdWVyeXN0cmluZyBmcm9tICcuL3F1ZXJ5c3RyaW5nJ1xuXG5jb25zdCBzbGFzaGVkUHJvdG9jb2xzID0gL2h0dHBzP3xmdHB8Z29waGVyfGZpbGUvXG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRVcmwodXJsT2JqOiBVcmxPYmplY3QpIHtcbiAgbGV0IHsgYXV0aCwgaG9zdG5hbWUgfSA9IHVybE9ialxuICBsZXQgcHJvdG9jb2wgPSB1cmxPYmoucHJvdG9jb2wgfHwgJydcbiAgbGV0IHBhdGhuYW1lID0gdXJsT2JqLnBhdGhuYW1lIHx8ICcnXG4gIGxldCBoYXNoID0gdXJsT2JqLmhhc2ggfHwgJydcbiAgbGV0IHF1ZXJ5ID0gdXJsT2JqLnF1ZXJ5IHx8ICcnXG4gIGxldCBob3N0OiBzdHJpbmcgfCBmYWxzZSA9IGZhbHNlXG5cbiAgYXV0aCA9IGF1dGggPyBlbmNvZGVVUklDb21wb25lbnQoYXV0aCkucmVwbGFjZSgvJTNBL2ksICc6JykgKyAnQCcgOiAnJ1xuXG4gIGlmICh1cmxPYmouaG9zdCkge1xuICAgIGhvc3QgPSBhdXRoICsgdXJsT2JqLmhvc3RcbiAgfSBlbHNlIGlmIChob3N0bmFtZSkge1xuICAgIGhvc3QgPSBhdXRoICsgKH5ob3N0bmFtZS5pbmRleE9mKCc6JykgPyBgWyR7aG9zdG5hbWV9XWAgOiBob3N0bmFtZSlcbiAgICBpZiAodXJsT2JqLnBvcnQpIHtcbiAgICAgIGhvc3QgKz0gJzonICsgdXJsT2JqLnBvcnRcbiAgICB9XG4gIH1cblxuICBpZiAocXVlcnkgJiYgdHlwZW9mIHF1ZXJ5ID09PSAnb2JqZWN0Jykge1xuICAgIHF1ZXJ5ID0gU3RyaW5nKHF1ZXJ5c3RyaW5nLnVybFF1ZXJ5VG9TZWFyY2hQYXJhbXMocXVlcnkgYXMgUGFyc2VkVXJsUXVlcnkpKVxuICB9XG5cbiAgbGV0IHNlYXJjaCA9IHVybE9iai5zZWFyY2ggfHwgKHF1ZXJ5ICYmIGA/JHtxdWVyeX1gKSB8fCAnJ1xuXG4gIGlmIChwcm90b2NvbCAmJiAhcHJvdG9jb2wuZW5kc1dpdGgoJzonKSkgcHJvdG9jb2wgKz0gJzonXG5cbiAgaWYgKFxuICAgIHVybE9iai5zbGFzaGVzIHx8XG4gICAgKCghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29scy50ZXN0KHByb3RvY29sKSkgJiYgaG9zdCAhPT0gZmFsc2UpXG4gICkge1xuICAgIGhvc3QgPSAnLy8nICsgKGhvc3QgfHwgJycpXG4gICAgaWYgKHBhdGhuYW1lICYmIHBhdGhuYW1lWzBdICE9PSAnLycpIHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWVcbiAgfSBlbHNlIGlmICghaG9zdCkge1xuICAgIGhvc3QgPSAnJ1xuICB9XG5cbiAgaWYgKGhhc2ggJiYgaGFzaFswXSAhPT0gJyMnKSBoYXNoID0gJyMnICsgaGFzaFxuICBpZiAoc2VhcmNoICYmIHNlYXJjaFswXSAhPT0gJz8nKSBzZWFyY2ggPSAnPycgKyBzZWFyY2hcblxuICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZW5jb2RlVVJJQ29tcG9uZW50KVxuICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgnIycsICclMjMnKVxuXG4gIHJldHVybiBgJHtwcm90b2NvbH0ke2hvc3R9JHtwYXRobmFtZX0ke3NlYXJjaH0ke2hhc2h9YFxufVxuXG5leHBvcnQgY29uc3QgdXJsT2JqZWN0S2V5cyA9IFtcbiAgJ2F1dGgnLFxuICAnaGFzaCcsXG4gICdob3N0JyxcbiAgJ2hvc3RuYW1lJyxcbiAgJ2hyZWYnLFxuICAncGF0aCcsXG4gICdwYXRobmFtZScsXG4gICdwb3J0JyxcbiAgJ3Byb3RvY29sJyxcbiAgJ3F1ZXJ5JyxcbiAgJ3NlYXJjaCcsXG4gICdzbGFzaGVzJyxcbl1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFdpdGhWYWxpZGF0aW9uKHVybDogVXJsT2JqZWN0KTogc3RyaW5nIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgaWYgKHVybCAhPT0gbnVsbCAmJiB0eXBlb2YgdXJsID09PSAnb2JqZWN0Jykge1xuICAgICAgT2JqZWN0LmtleXModXJsKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgaWYgKCF1cmxPYmplY3RLZXlzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICBgVW5rbm93biBrZXkgcGFzc2VkIHZpYSB1cmxPYmplY3QgaW50byB1cmwuZm9ybWF0OiAke2tleX1gXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmb3JtYXRVcmwodXJsKVxufVxuIl0sIm5hbWVzIjpbImZvcm1hdFVybCIsImZvcm1hdFdpdGhWYWxpZGF0aW9uIiwidXJsT2JqZWN0S2V5cyIsInNsYXNoZWRQcm90b2NvbHMiLCJ1cmxPYmoiLCJhdXRoIiwiaG9zdG5hbWUiLCJwcm90b2NvbCIsInBhdGhuYW1lIiwiaGFzaCIsInF1ZXJ5IiwiaG9zdCIsImVuY29kZVVSSUNvbXBvbmVudCIsInJlcGxhY2UiLCJpbmRleE9mIiwicG9ydCIsIlN0cmluZyIsInF1ZXJ5c3RyaW5nIiwidXJsUXVlcnlUb1NlYXJjaFBhcmFtcyIsInNlYXJjaCIsImVuZHNXaXRoIiwic2xhc2hlcyIsInRlc3QiLCJ1cmwiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsImtleSIsImluY2x1ZGVzIiwiY29uc29sZSIsIndhcm4iXSwibWFw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LElBQUksQ0FDVCx1REFBb0RIO2dCQUV6RDtZQUNGO1FBQ0Y7SUFDRjtJQUVBLE9BQU85QixVQUFVdUI7QUFDbkIiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMjQzLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JvdXRlci1yZWR1Y2VyLXR5cGVzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgQ2FjaGVOb2RlIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgdHlwZSB7XG4gIEZsaWdodFJvdXRlclN0YXRlLFxuICBGbGlnaHRTZWdtZW50UGF0aCxcbn0gZnJvbSAnLi4vLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvdHlwZXMnXG5pbXBvcnQgdHlwZSB7IEZldGNoU2VydmVyUmVzcG9uc2VSZXN1bHQgfSBmcm9tICcuL2ZldGNoLXNlcnZlci1yZXNwb25zZSdcblxuZXhwb3J0IGNvbnN0IEFDVElPTl9SRUZSRVNIID0gJ3JlZnJlc2gnXG5leHBvcnQgY29uc3QgQUNUSU9OX05BVklHQVRFID0gJ25hdmlnYXRlJ1xuZXhwb3J0IGNvbnN0IEFDVElPTl9SRVNUT1JFID0gJ3Jlc3RvcmUnXG5leHBvcnQgY29uc3QgQUNUSU9OX1NFUlZFUl9QQVRDSCA9ICdzZXJ2ZXItcGF0Y2gnXG5leHBvcnQgY29uc3QgQUNUSU9OX1BSRUZFVENIID0gJ3ByZWZldGNoJ1xuZXhwb3J0IGNvbnN0IEFDVElPTl9ITVJfUkVGUkVTSCA9ICdobXItcmVmcmVzaCdcbmV4cG9ydCBjb25zdCBBQ1RJT05fU0VSVkVSX0FDVElPTiA9ICdzZXJ2ZXItYWN0aW9uJ1xuXG5leHBvcnQgdHlwZSBSb3V0ZXJDaGFuZ2VCeVNlcnZlclJlc3BvbnNlID0gKHtcbiAgbmF2aWdhdGVkQXQsXG4gIHByZXZpb3VzVHJlZSxcbiAgc2VydmVyUmVzcG9uc2UsXG59OiB7XG4gIG5hdmlnYXRlZEF0OiBudW1iZXJcbiAgcHJldmlvdXNUcmVlOiBGbGlnaHRSb3V0ZXJTdGF0ZVxuICBzZXJ2ZXJSZXNwb25zZTogRmV0Y2hTZXJ2ZXJSZXNwb25zZVJlc3VsdFxufSkgPT4gdm9pZFxuXG5leHBvcnQgaW50ZXJmYWNlIE11dGFibGUge1xuICBtcGFOYXZpZ2F0aW9uPzogYm9vbGVhblxuICBwYXRjaGVkVHJlZT86IEZsaWdodFJvdXRlclN0YXRlXG4gIGNhbm9uaWNhbFVybD86IHN0cmluZ1xuICBzY3JvbGxhYmxlU2VnbWVudHM/OiBGbGlnaHRTZWdtZW50UGF0aFtdXG4gIHBlbmRpbmdQdXNoPzogYm9vbGVhblxuICBjYWNoZT86IENhY2hlTm9kZVxuICBwcmVmZXRjaENhY2hlPzogQXBwUm91dGVyU3RhdGVbJ3ByZWZldGNoQ2FjaGUnXVxuICBoYXNoRnJhZ21lbnQ/OiBzdHJpbmdcbiAgc2hvdWxkU2Nyb2xsPzogYm9vbGVhblxuICBwcmVzZXJ2ZUN1c3RvbUhpc3RvcnlTdGF0ZT86IGJvb2xlYW5cbiAgb25seUhhc2hDaGFuZ2U/OiBib29sZWFuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VydmVyQWN0aW9uTXV0YWJsZSBleHRlbmRzIE11dGFibGUge1xuICBpbkZsaWdodFNlcnZlckFjdGlvbj86IFByb21pc2U8YW55PiB8IG51bGxcbn1cblxuLyoqXG4gKiBSZWZyZXNoIHRyaWdnZXJzIGEgcmVmcmVzaCBvZiB0aGUgZnVsbCBwYWdlIGRhdGEuXG4gKiAtIGZldGNoZXMgdGhlIEZsaWdodCBkYXRhIGFuZCBmaWxscyByc2MgYXQgdGhlIHJvb3Qgb2YgdGhlIGNhY2hlLlxuICogLSBUaGUgcm91dGVyIHN0YXRlIGlzIHVwZGF0ZWQgYXQgdGhlIHJvb3QuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVmcmVzaEFjdGlvbiB7XG4gIHR5cGU6IHR5cGVvZiBBQ1RJT05fUkVGUkVTSFxuICBvcmlnaW46IExvY2F0aW9uWydvcmlnaW4nXVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEhtclJlZnJlc2hBY3Rpb24ge1xuICB0eXBlOiB0eXBlb2YgQUNUSU9OX0hNUl9SRUZSRVNIXG4gIG9yaWdpbjogTG9jYXRpb25bJ29yaWdpbiddXG59XG5cbmV4cG9ydCB0eXBlIFNlcnZlckFjdGlvbkRpc3BhdGNoZXIgPSAoXG4gIGFyZ3M6IE9taXQ8XG4gICAgU2VydmVyQWN0aW9uQWN0aW9uLFxuICAgICd0eXBlJyB8ICdtdXRhYmxlJyB8ICduYXZpZ2F0ZScgfCAnY2hhbmdlQnlTZXJ2ZXJSZXNwb25zZScgfCAnY2FjaGUnXG4gID5cbikgPT4gdm9pZFxuXG5leHBvcnQgaW50ZXJmYWNlIFNlcnZlckFjdGlvbkFjdGlvbiB7XG4gIHR5cGU6IHR5cGVvZiBBQ1RJT05fU0VSVkVSX0FDVElPTlxuICBhY3Rpb25JZDogc3RyaW5nXG4gIGFjdGlvbkFyZ3M6IGFueVtdXG4gIHJlc29sdmU6ICh2YWx1ZTogYW55KSA9PiB2b2lkXG4gIHJlamVjdDogKHJlYXNvbj86IGFueSkgPT4gdm9pZFxufVxuXG4vKipcbiAqIE5hdmlnYXRlIHRyaWdnZXJzIGEgbmF2aWdhdGlvbiB0byB0aGUgcHJvdmlkZWQgdXJsLiBJdCBzdXBwb3J0cyB0d28gdHlwZXM6IGBwdXNoYCBhbmQgYHJlcGxhY2VgLlxuICpcbiAqIGBuYXZpZ2F0ZVR5cGVgOlxuICogLSBgcHVzaGAgLSBwdXNoZXMgYSBuZXcgaGlzdG9yeSBlbnRyeSBpbiB0aGUgYnJvd3NlciBoaXN0b3J5XG4gKiAtIGByZXBsYWNlYCAtIHJlcGxhY2VzIHRoZSBjdXJyZW50IGhpc3RvcnkgZW50cnkgaW4gdGhlIGJyb3dzZXIgaGlzdG9yeVxuICpcbiAqIE5hdmlnYXRlIGhhcyBtdWx0aXBsZSBjYWNoZSBoZXVyaXN0aWNzOlxuICogLSBwYWdlIHdhcyBwcmVmZXRjaGVkXG4gKiAgLSBBcHBseSByb3V0ZXIgc3RhdGUgdHJlZSBmcm9tIHByZWZldGNoXG4gKiAgLSBBcHBseSBGbGlnaHQgZGF0YSBmcm9tIHByZWZldGNoIHRvIHRoZSBjYWNoZVxuICogIC0gSWYgRmxpZ2h0IGRhdGEgaXMgYSBzdHJpbmcsIGl0J3MgYSByZWRpcmVjdCBhbmQgdGhlIHN0YXRlIGlzIHVwZGF0ZWQgdG8gdHJpZ2dlciBhIHJlZGlyZWN0XG4gKiAgLSBDaGVjayBpZiBoYXJkIG5hdmlnYXRpb24gaXMgbmVlZGVkXG4gKiAgICAtIEhhcmQgbmF2aWdhdGlvbiBoYXBwZW5zIHdoZW4gYSBkeW5hbWljIHBhcmFtZXRlciBiZWxvdyB0aGUgY29tbW9uIGxheW91dCBjaGFuZ2VkXG4gKiAgICAtIFdoZW4gaGFyZCBuYXZpZ2F0aW9uIGlzIG5lZWRlZCB0aGUgY2FjaGUgaXMgaW52YWxpZGF0ZWQgYmVsb3cgdGhlIGZsaWdodFNlZ21lbnRQYXRoXG4gKiAgICAtIFRoZSBtaXNzaW5nIGNhY2hlIG5vZGVzIG9mIHRoZSBwYWdlIHdpbGwgYmUgZmV0Y2hlZCBpbiBsYXlvdXQtcm91dGVyIGFuZCB0cmlnZ2VyIHRoZSBTRVJWRVJfUEFUQ0ggYWN0aW9uXG4gKiAgLSBJZiBoYXJkIG5hdmlnYXRpb24gaXMgbm90IG5lZWRlZFxuICogICAgLSBUaGUgY2FjaGUgaXMgcmV1c2VkXG4gKiAgICAtIElmIGFueSBjYWNoZSBub2RlcyBhcmUgbWlzc2luZyB0aGV5J2xsIGJlIGZldGNoZWQgaW4gbGF5b3V0LXJvdXRlciBhbmQgdHJpZ2dlciB0aGUgU0VSVkVSX1BBVENIIGFjdGlvblxuICogLSBwYWdlIHdhcyBub3QgcHJlZmV0Y2hlZFxuICogIC0gVGhlIG5hdmlnYXRlIHdhcyBjYWxsZWQgZnJvbSBgbmV4dC9yb3V0ZXJgIChgcm91dGVyLnB1c2goKWAgLyBgcm91dGVyLnJlcGxhY2UoKWApIC8gYG5leHQvbGlua2Agd2l0aG91dCBwcmVmZXRjaGVkIGRhdGEgYXZhaWxhYmxlIChlLmcuIHRoZSBwcmVmZXRjaCBkaWRuJ3QgY29tZSBiYWNrIGZyb20gdGhlIHNlcnZlciBiZWZvcmUgY2xpY2tpbmcgdGhlIGxpbmspXG4gKiAgICAtIEZsaWdodCBkYXRhIGlzIGZldGNoZWQgaW4gdGhlIHJlZHVjZXIgKHN1c3BlbmRzIHRoZSByZWR1Y2VyKVxuICogICAgLSBSb3V0ZXIgc3RhdGUgdHJlZSBpcyBjcmVhdGVkIGJhc2VkIG9uIEZsaWdodCBkYXRhXG4gKiAgICAtIENhY2hlIGlzIGZpbGxlZCBiYXNlZCBvbiB0aGUgRmxpZ2h0IGRhdGFcbiAqXG4gKiBBYm92ZSBzdGVwcyBleHBsYWluIDMgY2FzZXM6XG4gKiAtIGBzb2Z0YCAtIFJldXNlcyB0aGUgZXhpc3RpbmcgY2FjaGUgYW5kIGZldGNoZXMgbWlzc2luZyBub2RlcyBpbiBsYXlvdXQtcm91dGVyLlxuICogLSBgaGFyZGAgLSBDcmVhdGVzIGEgbmV3IGNhY2hlIHdoZXJlIGNhY2hlIG5vZGVzIGFyZSByZW1vdmVkIGJlbG93IHRoZSBjb21tb24gbGF5b3V0IGFuZCBmZXRjaGVzIG1pc3Npbmcgbm9kZXMgaW4gbGF5b3V0LXJvdXRlci5cbiAqIC0gYG9wdGltaXN0aWNgIChleHBsaWNpdCBubyBwcmVmZXRjaCkgLSBDcmVhdGVzIGEgbmV3IGNhY2hlIGFuZCBraWNrcyBvZmYgdGhlIGRhdGEgZmV0Y2ggaW4gdGhlIHJlZHVjZXIuIFRoZSBkYXRhIGZldGNoIGlzIGF3YWl0ZWQgaW4gdGhlIGxheW91dC1yb3V0ZXIuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTmF2aWdhdGVBY3Rpb24ge1xuICB0eXBlOiB0eXBlb2YgQUNUSU9OX05BVklHQVRFXG4gIHVybDogVVJMXG4gIGlzRXh0ZXJuYWxVcmw6IGJvb2xlYW5cbiAgbG9jYXRpb25TZWFyY2g6IExvY2F0aW9uWydzZWFyY2gnXVxuICBuYXZpZ2F0ZVR5cGU6ICdwdXNoJyB8ICdyZXBsYWNlJ1xuICBzaG91bGRTY3JvbGw6IGJvb2xlYW5cbiAgYWxsb3dBbGlhc2luZzogYm9vbGVhblxufVxuXG4vKipcbiAqIFJlc3RvcmUgYXBwbGllcyB0aGUgcHJvdmlkZWQgcm91dGVyIHN0YXRlLlxuICogLSBVc2VkIGZvciBgcG9wc3RhdGVgIChiYWNrL2ZvcndhcmQgbmF2aWdhdGlvbikgd2hlcmUgYSBrbm93biByb3V0ZXIgc3RhdGUgaGFzIHRvIGJlIGFwcGxpZWQuXG4gKiAtIEFsc28gdXNlZCB3aGVuIHN5bmNpbmcgdGhlIHJvdXRlciBzdGF0ZSB3aXRoIGBwdXNoU3RhdGVgL2ByZXBsYWNlU3RhdGVgIGNhbGxzLlxuICogLSBSb3V0ZXIgc3RhdGUgaXMgYXBwbGllZCBhcy1pcyBmcm9tIHRoZSBoaXN0b3J5IHN0YXRlLCBpZiBhdmFpbGFibGUuXG4gKiAtIElmIHRoZSBoaXN0b3J5IHN0YXRlIGRvZXMgbm90IGNvbnRhaW4gdGhlIHJvdXRlciBzdGF0ZSwgdGhlIGV4aXN0aW5nIHJvdXRlciBzdGF0ZSBpcyB1c2VkLlxuICogLSBJZiBhbnkgY2FjaGUgbm9kZSBpcyBtaXNzaW5nIGl0IHdpbGwgYmUgZmV0Y2hlZCBpbiBsYXlvdXQtcm91dGVyIGR1cmluZyByZW5kZXJpbmcgYW5kIHRoZSBzZXJ2ZXItcGF0Y2ggY2FzZS5cbiAqIC0gSWYgZXhpc3RpbmcgY2FjaGUgbm9kZXMgbWF0Y2ggdGhlc2UgYXJlIHVzZWQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVzdG9yZUFjdGlvbiB7XG4gIHR5cGU6IHR5cGVvZiBBQ1RJT05fUkVTVE9SRVxuICB1cmw6IFVSTFxuICB0cmVlOiBGbGlnaHRSb3V0ZXJTdGF0ZSB8IHVuZGVmaW5lZFxufVxuXG4vKipcbiAqIFNlcnZlci1wYXRjaCBhcHBsaWVzIHRoZSBwcm92aWRlZCBGbGlnaHQgZGF0YSB0byB0aGUgY2FjaGUgYW5kIHJvdXRlciB0cmVlLlxuICogLSBPbmx5IHRyaWdnZXJlZCBpbiBsYXlvdXQtcm91dGVyLlxuICogLSBDcmVhdGVzIGEgbmV3IGNhY2hlIGFuZCByb3V0ZXIgc3RhdGUgd2l0aCB0aGUgRmxpZ2h0IGRhdGEgYXBwbGllZC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTZXJ2ZXJQYXRjaEFjdGlvbiB7XG4gIHR5cGU6IHR5cGVvZiBBQ1RJT05fU0VSVkVSX1BBVENIXG4gIG5hdmlnYXRlZEF0OiBudW1iZXJcbiAgc2VydmVyUmVzcG9uc2U6IEZldGNoU2VydmVyUmVzcG9uc2VSZXN1bHRcbiAgcHJldmlvdXNUcmVlOiBGbGlnaHRSb3V0ZXJTdGF0ZVxufVxuXG4vKipcbiAqIFByZWZldGNoS2luZCBkZWZpbmVzIHRoZSB0eXBlIG9mIHByZWZldGNoaW5nIHRoYXQgc2hvdWxkIGJlIGRvbmUuXG4gKiAtIGBhdXRvYCAtIGlmIHRoZSBwYWdlIGlzIGR5bmFtaWMsIHByZWZldGNoIHRoZSBwYWdlIGRhdGEgcGFydGlhbGx5LCBpZiBzdGF0aWMgcHJlZmV0Y2ggdGhlIHBhZ2UgZGF0YSBmdWxseS5cbiAqIC0gYGZ1bGxgIC0gcHJlZmV0Y2ggdGhlIHBhZ2UgZGF0YSBmdWxseS5cbiAqIC0gYHRlbXBvcmFyeWAgLSBhIHRlbXBvcmFyeSBwcmVmZXRjaCBlbnRyeSBpcyBhZGRlZCB0byB0aGUgY2FjaGUsIHRoaXMgaXMgdXNlZCB3aGVuIHByZWZldGNoPXtmYWxzZX0gaXMgdXNlZCBpbiBuZXh0L2xpbmsgb3Igd2hlbiB5b3UgcHVzaCBhIHJvdXRlIHByb2dyYW1tYXRpY2FsbHkuXG4gKi9cblxuZXhwb3J0IGVudW0gUHJlZmV0Y2hLaW5kIHtcbiAgQVVUTyA9ICdhdXRvJyxcbiAgRlVMTCA9ICdmdWxsJyxcbiAgVEVNUE9SQVJZID0gJ3RlbXBvcmFyeScsXG59XG5cbi8qKlxuICogUHJlZmV0Y2ggYWRkcyB0aGUgcHJvdmlkZWQgRmxpZ2h0RGF0YSB0byB0aGUgcHJlZmV0Y2ggY2FjaGVcbiAqIC0gQ3JlYXRlcyB0aGUgcm91dGVyIHN0YXRlIHRyZWUgYmFzZWQgb24gdGhlIHBhdGNoIGluIEZsaWdodERhdGFcbiAqIC0gQWRkcyB0aGUgRmxpZ2h0RGF0YSB0byB0aGUgcHJlZmV0Y2ggY2FjaGVcbiAqIC0gSW4gQUNUSU9OX05BVklHQVRFIHRoZSBwcmVmZXRjaCBjYWNoZSBpcyBjaGVja2VkIGFuZCB0aGUgcm91dGVyIHN0YXRlIHRyZWUgYW5kIEZsaWdodERhdGEgYXJlIGFwcGxpZWQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUHJlZmV0Y2hBY3Rpb24ge1xuICB0eXBlOiB0eXBlb2YgQUNUSU9OX1BSRUZFVENIXG4gIHVybDogVVJMXG4gIGtpbmQ6IFByZWZldGNoS2luZFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFB1c2hSZWYge1xuICAvKipcbiAgICogSWYgdGhlIGFwcC1yb3V0ZXIgc2hvdWxkIHB1c2ggYSBuZXcgaGlzdG9yeSBlbnRyeSBpbiBhcHAtcm91dGVyJ3MgdXNlRWZmZWN0KClcbiAgICovXG4gIHBlbmRpbmdQdXNoOiBib29sZWFuXG4gIC8qKlxuICAgKiBNdWx0aS1wYWdlIG5hdmlnYXRpb24gdGhyb3VnaCBsb2NhdGlvbi5ocmVmLlxuICAgKi9cbiAgbXBhTmF2aWdhdGlvbjogYm9vbGVhblxuICAvKipcbiAgICogU2tpcCBhcHBseWluZyB0aGUgcm91dGVyIHN0YXRlIHRvIHRoZSBicm93c2VyIGhpc3Rvcnkgc3RhdGUuXG4gICAqL1xuICBwcmVzZXJ2ZUN1c3RvbUhpc3RvcnlTdGF0ZTogYm9vbGVhblxufVxuXG5leHBvcnQgdHlwZSBGb2N1c0FuZFNjcm9sbFJlZiA9IHtcbiAgLyoqXG4gICAqIElmIGZvY3VzIGFuZCBzY3JvbGwgc2hvdWxkIGJlIHNldCBpbiB0aGUgbGF5b3V0LXJvdXRlcidzIHVzZUVmZmVjdCgpXG4gICAqL1xuICBhcHBseTogYm9vbGVhblxuICAvKipcbiAgICogVGhlIGhhc2ggZnJhZ21lbnQgdGhhdCBzaG91bGQgYmUgc2Nyb2xsZWQgdG8uXG4gICAqL1xuICBoYXNoRnJhZ21lbnQ6IHN0cmluZyB8IG51bGxcbiAgLyoqXG4gICAqIFRoZSBwYXRocyBvZiB0aGUgc2VnbWVudHMgdGhhdCBzaG91bGQgYmUgZm9jdXNlZC5cbiAgICovXG4gIHNlZ21lbnRQYXRoczogRmxpZ2h0U2VnbWVudFBhdGhbXVxuICAvKipcbiAgICogSWYgb25seSB0aGUgVVJMcyBoYXNoIGZyYWdtZW50IGNoYW5nZWRcbiAgICovXG4gIG9ubHlIYXNoQ2hhbmdlOiBib29sZWFuXG59XG5cbmV4cG9ydCB0eXBlIFByZWZldGNoQ2FjaGVFbnRyeSA9IHtcbiAgdHJlZUF0VGltZU9mUHJlZmV0Y2g6IEZsaWdodFJvdXRlclN0YXRlXG4gIGRhdGE6IFByb21pc2U8RmV0Y2hTZXJ2ZXJSZXNwb25zZVJlc3VsdD5cbiAga2luZDogUHJlZmV0Y2hLaW5kXG4gIHByZWZldGNoVGltZTogbnVtYmVyXG4gIHN0YWxlVGltZTogbnVtYmVyXG4gIGxhc3RVc2VkVGltZTogbnVtYmVyIHwgbnVsbFxuICBrZXk6IHN0cmluZ1xuICBzdGF0dXM6IFByZWZldGNoQ2FjaGVFbnRyeVN0YXR1c1xuICB1cmw6IFVSTFxufVxuXG5leHBvcnQgZW51bSBQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMge1xuICBmcmVzaCA9ICdmcmVzaCcsXG4gIHJldXNhYmxlID0gJ3JldXNhYmxlJyxcbiAgZXhwaXJlZCA9ICdleHBpcmVkJyxcbiAgc3RhbGUgPSAnc3RhbGUnLFxufVxuXG4vKipcbiAqIEhhbmRsZXMga2VlcGluZyB0aGUgc3RhdGUgb2YgYXBwLXJvdXRlci5cbiAqL1xuZXhwb3J0IHR5cGUgQXBwUm91dGVyU3RhdGUgPSB7XG4gIC8qKlxuICAgKiBUaGUgcm91dGVyIHN0YXRlLCB0aGlzIGlzIHdyaXR0ZW4gaW50byB0aGUgaGlzdG9yeSBzdGF0ZSBpbiBhcHAtcm91dGVyIHVzaW5nIHJlcGxhY2VTdGF0ZS9wdXNoU3RhdGUuXG4gICAqIC0gSGFzIHRvIGJlIHNlcmlhbGl6YWJsZSBhcyBpdCBpcyB3cml0dGVuIGludG8gdGhlIGhpc3Rvcnkgc3RhdGUuXG4gICAqIC0gSG9sZHMgd2hpY2ggc2VnbWVudHMgYW5kIHBhcmFsbGVsIHJvdXRlcyBhcmUgc2hvd24gb24gdGhlIHNjcmVlbi5cbiAgICovXG4gIHRyZWU6IEZsaWdodFJvdXRlclN0YXRlXG4gIC8qKlxuICAgKiBUaGUgY2FjaGUgaG9sZHMgUmVhY3Qgbm9kZXMgZm9yIGV2ZXJ5IHNlZ21lbnQgdGhhdCBpcyBzaG93biBvbiBzY3JlZW4gYXMgd2VsbCBhcyBwcmV2aW91c2x5IHNob3duIHNlZ21lbnRzLlxuICAgKiBJdCBhbHNvIGhvbGRzIGluLXByb2dyZXNzIGRhdGEgcmVxdWVzdHMuXG4gICAqIFByZWZldGNoZWQgZGF0YSBpcyBzdG9yZWQgc2VwYXJhdGVseSBpbiBgcHJlZmV0Y2hDYWNoZWAsIHRoYXQgaXMgYXBwbGllZCBkdXJpbmcgQUNUSU9OX05BVklHQVRFLlxuICAgKi9cbiAgY2FjaGU6IENhY2hlTm9kZVxuICAvKipcbiAgICogQ2FjaGUgdGhhdCBob2xkcyBwcmVmZXRjaGVkIEZsaWdodCByZXNwb25zZXMga2V5ZWQgYnkgdXJsLlxuICAgKi9cbiAgcHJlZmV0Y2hDYWNoZTogTWFwPHN0cmluZywgUHJlZmV0Y2hDYWNoZUVudHJ5PlxuICAvKipcbiAgICogRGVjaWRlcyBpZiB0aGUgdXBkYXRlIHNob3VsZCBjcmVhdGUgYSBuZXcgaGlzdG9yeSBlbnRyeSBhbmQgaWYgdGhlIG5hdmlnYXRpb24gaGFzIHRvIHRyaWdnZXIgYSBicm93c2VyIG5hdmlnYXRpb24uXG4gICAqL1xuICBwdXNoUmVmOiBQdXNoUmVmXG4gIC8qKlxuICAgKiBEZWNpZGVzIGlmIHRoZSB1cGRhdGUgc2hvdWxkIGFwcGx5IHNjcm9sbCBhbmQgZm9jdXMgbWFuYWdlbWVudC5cbiAgICovXG4gIGZvY3VzQW5kU2Nyb2xsUmVmOiBGb2N1c0FuZFNjcm9sbFJlZlxuICAvKipcbiAgICogVGhlIGNhbm9uaWNhbCB1cmwgdGhhdCBpcyBwdXNoZWQvcmVwbGFjZWQuXG4gICAqIC0gVGhpcyBpcyB0aGUgdXJsIHlvdSBzZWUgaW4gdGhlIGJyb3dzZXIuXG4gICAqL1xuICBjYW5vbmljYWxVcmw6IHN0cmluZ1xuICAvKipcbiAgICogVGhlIHVuZGVybHlpbmcgXCJ1cmxcIiByZXByZXNlbnRpbmcgdGhlIFVJIHN0YXRlLCB3aGljaCBpcyB1c2VkIGZvciBpbnRlcmNlcHRpbmcgcm91dGVzLlxuICAgKi9cbiAgbmV4dFVybDogc3RyaW5nIHwgbnVsbFxufVxuXG5leHBvcnQgdHlwZSBSZWFkb25seVJlZHVjZXJTdGF0ZSA9IFJlYWRvbmx5PEFwcFJvdXRlclN0YXRlPlxuZXhwb3J0IHR5cGUgUmVkdWNlclN0YXRlID0gUHJvbWlzZTxBcHBSb3V0ZXJTdGF0ZT4gfCBBcHBSb3V0ZXJTdGF0ZVxuZXhwb3J0IHR5cGUgUmVkdWNlckFjdGlvbnMgPSBSZWFkb25seTxcbiAgfCBSZWZyZXNoQWN0aW9uXG4gIHwgTmF2aWdhdGVBY3Rpb25cbiAgfCBSZXN0b3JlQWN0aW9uXG4gIHwgU2VydmVyUGF0Y2hBY3Rpb25cbiAgfCBQcmVmZXRjaEFjdGlvblxuICB8IEhtclJlZnJlc2hBY3Rpb25cbiAgfCBTZXJ2ZXJBY3Rpb25BY3Rpb25cbj5cbiJdLCJuYW1lcyI6WyJBQ1RJT05fSE1SX1JFRlJFU0giLCJBQ1RJT05fTkFWSUdBVEUiLCJBQ1RJT05fUFJFRkVUQ0giLCJBQ1RJT05fUkVGUkVTSCIsIkFDVElPTl9SRVNUT1JFIiwiQUNUSU9OX1NFUlZFUl9BQ1RJT04iLCJBQ1RJT05fU0VSVkVSX1BBVENIIiwiUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzIiwiUHJlZmV0Y2hLaW5kIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFZYUEsa0JBQWtCLEVBQUE7ZUFBbEJBOztJQUpBQyxlQUFlLEVBQUE7ZUFBZkE7O0lBR0FDLGVBQWUsRUFBQTtlQUFmQTs7SUFKQUMsY0FBYyxFQUFBO2VBQWRBOztJQUVBQyxjQUFjLEVBQUE7ZUFBZEE7O0lBSUFDLG9CQUFvQixFQUFBO2VBQXBCQTs7SUFIQUMsbUJBQW1CLEVBQUE7ZUFBbkJBOztJQXlNREMsd0JBQXdCLEVBQUE7ZUFBeEJBOztJQWhFQUMsWUFBWSxFQUFBO2VBQVpBOzs7QUE1SUwsTUFBTUwsaUJBQWlCO0FBQ3ZCLE1BQU1GLGtCQUFrQjtBQUN4QixNQUFNRyxpQkFBaUI7QUFDdkIsTUFBTUUsc0JBQXNCO0FBQzVCLE1BQU1KLGtCQUFrQjtBQUN4QixNQUFNRixxQkFBcUI7QUFDM0IsTUFBTUssdUJBQXVCO0FBc0k3QixJQUFLRyxlQUFBQSxXQUFBQSxHQUFBQSxTQUFBQSxZQUFBQTs7OztXQUFBQTs7QUFnRUwsSUFBS0QsMkJBQUFBLFdBQUFBLEdBQUFBLFNBQUFBLHdCQUFBQTs7Ozs7V0FBQUEiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMzI1LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2NsaWVudC91c2UtbWVyZ2VkLXJlZi50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlUmVmLCB0eXBlIFJlZiB9IGZyb20gJ3JlYWN0J1xuXG4vLyBUaGlzIGlzIGEgY29tcGF0aWJpbGl0eSBob29rIHRvIHN1cHBvcnQgUmVhY3QgMTggYW5kIDE5IHJlZnMuXG4vLyBJbiAxOSwgYSBjbGVhbnVwIGZ1bmN0aW9uIGZyb20gcmVmcyBtYXkgYmUgcmV0dXJuZWQuXG4vLyBJbiAxOCwgcmV0dXJuaW5nIGEgY2xlYW51cCBmdW5jdGlvbiBjcmVhdGVzIGEgd2FybmluZy5cbi8vIFNpbmNlIHdlIHRha2UgdXNlcnNwYWNlIHJlZnMsIHdlIGRvbid0IGtub3cgYWhlYWQgb2YgdGltZSBpZiBhIGNsZWFudXAgZnVuY3Rpb24gd2lsbCBiZSByZXR1cm5lZC5cbi8vIFRoaXMgaW1wbGVtZW50cyBjbGVhbnVwIGZ1bmN0aW9ucyB3aXRoIHRoZSBvbGQgYmVoYXZpb3IgaW4gMTguXG4vLyBXZSBrbm93IHJlZnMgYXJlIGFsd2F5cyBjYWxsZWQgYWx0ZXJuYXRpbmcgd2l0aCBgbnVsbGAgYW5kIHRoZW4gYFRgLlxuLy8gU28gYSBjYWxsIHdpdGggYG51bGxgIG1lYW5zIHdlIG5lZWQgdG8gY2FsbCB0aGUgcHJldmlvdXMgY2xlYW51cCBmdW5jdGlvbnMuXG5leHBvcnQgZnVuY3Rpb24gdXNlTWVyZ2VkUmVmPFRFbGVtZW50PihcbiAgcmVmQTogUmVmPFRFbGVtZW50PixcbiAgcmVmQjogUmVmPFRFbGVtZW50PlxuKTogUmVmPFRFbGVtZW50PiB7XG4gIGNvbnN0IGNsZWFudXBBID0gdXNlUmVmPCgoKSA9PiB2b2lkKSB8IG51bGw+KG51bGwpXG4gIGNvbnN0IGNsZWFudXBCID0gdXNlUmVmPCgoKSA9PiB2b2lkKSB8IG51bGw+KG51bGwpXG5cbiAgLy8gTk9URTogSW4gdGhlb3J5LCB3ZSBjb3VsZCBza2lwIHRoZSB3cmFwcGluZyBpZiBvbmx5IG9uZSBvZiB0aGUgcmVmcyBpcyBub24tbnVsbC5cbiAgLy8gKHRoaXMgaGFwcGVucyBvZnRlbiBpZiB0aGUgdXNlciBkb2Vzbid0IHBhc3MgYSByZWYgdG8gTGluay9Gb3JtL0ltYWdlKVxuICAvLyBCdXQgdGhpcyBjYW4gY2F1c2UgdXMgdG8gbGVhayBhIGNsZWFudXAtcmVmIGludG8gdXNlciBjb2RlIChlLmcuIHZpYSBgPExpbmsgbGVnYWN5QmVoYXZpb3I+YCksXG4gIC8vIGFuZCB0aGUgdXNlciBtaWdodCBwYXNzIHRoYXQgcmVmIGludG8gcmVmLW1lcmdpbmcgbGlicmFyeSB0aGF0IGRvZXNuJ3Qgc3VwcG9ydCBjbGVhbnVwIHJlZnNcbiAgLy8gKGJlY2F1c2UgaXQgaGFzbid0IGJlZW4gdXBkYXRlZCBmb3IgUmVhY3QgMTkpXG4gIC8vIHdoaWNoIGNhbiB0aGVuIGNhdXNlIHRoaW5ncyB0byBibG93IHVwLCBiZWNhdXNlIGEgY2xlYW51cC1yZXR1cm5pbmcgcmVmIGdldHMgY2FsbGVkIHdpdGggYG51bGxgLlxuICAvLyBTbyBpbiBwcmFjdGljZSwgaXQncyBzYWZlciB0byBiZSBkZWZlbnNpdmUgYW5kIGFsd2F5cyB3cmFwIHRoZSByZWYsIGV2ZW4gb24gUmVhY3QgMTkuXG4gIHJldHVybiB1c2VDYWxsYmFjayhcbiAgICAoY3VycmVudDogVEVsZW1lbnQgfCBudWxsKTogdm9pZCA9PiB7XG4gICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICBjb25zdCBjbGVhbnVwRm5BID0gY2xlYW51cEEuY3VycmVudFxuICAgICAgICBpZiAoY2xlYW51cEZuQSkge1xuICAgICAgICAgIGNsZWFudXBBLmN1cnJlbnQgPSBudWxsXG4gICAgICAgICAgY2xlYW51cEZuQSgpXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2xlYW51cEZuQiA9IGNsZWFudXBCLmN1cnJlbnRcbiAgICAgICAgaWYgKGNsZWFudXBGbkIpIHtcbiAgICAgICAgICBjbGVhbnVwQi5jdXJyZW50ID0gbnVsbFxuICAgICAgICAgIGNsZWFudXBGbkIoKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocmVmQSkge1xuICAgICAgICAgIGNsZWFudXBBLmN1cnJlbnQgPSBhcHBseVJlZihyZWZBLCBjdXJyZW50KVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZWZCKSB7XG4gICAgICAgICAgY2xlYW51cEIuY3VycmVudCA9IGFwcGx5UmVmKHJlZkIsIGN1cnJlbnQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFtyZWZBLCByZWZCXVxuICApXG59XG5cbmZ1bmN0aW9uIGFwcGx5UmVmPFRFbGVtZW50PihcbiAgcmVmQTogTm9uTnVsbGFibGU8UmVmPFRFbGVtZW50Pj4sXG4gIGN1cnJlbnQ6IFRFbGVtZW50XG4pIHtcbiAgaWYgKHR5cGVvZiByZWZBID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc3QgY2xlYW51cCA9IHJlZkEoY3VycmVudClcbiAgICBpZiAodHlwZW9mIGNsZWFudXAgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBjbGVhbnVwXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoKSA9PiByZWZBKG51bGwpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlZkEuY3VycmVudCA9IGN1cnJlbnRcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcmVmQS5jdXJyZW50ID0gbnVsbFxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbInVzZU1lcmdlZFJlZiIsInJlZkEiLCJyZWZCIiwiY2xlYW51cEEiLCJ1c2VSZWYiLCJjbGVhbnVwQiIsInVzZUNhbGxiYWNrIiwiY3VycmVudCIsImNsZWFudXBGbkEiLCJjbGVhbnVwRm5CIiwiYXBwbHlSZWYiLCJjbGVhbnVwIl0sIm1hcHBpbmdzIjoiOzs7K0JBU2dCQSxnQkFBQUE7OztlQUFBQTs7O3VCQVQ4QjtBQVN2QyxTQUFTQSxhQUNkQyxJQUFtQixFQUNuQkMsSUFBbUI7SUFFbkIsTUFBTUMsV0FBV0MsQ0FBQUEsR0FBQUEsT0FBQUEsTUFBTSxFQUFzQjtJQUM3QyxNQUFNQyxXQUFXRCxDQUFBQSxHQUFBQSxPQUFBQSxNQUFNLEVBQXNCO0lBRTdDLG1GQUFtRjtJQUNuRix5RUFBeUU7SUFDekUsaUdBQWlHO0lBQ2pHLDhGQUE4RjtJQUM5RixnREFBZ0Q7SUFDaEQsbUdBQW1HO0lBQ25HLHdGQUF3RjtJQUN4RixPQUFPRSxDQUFBQSxHQUFBQSxPQUFBQSxXQUFXLEVBQ2hCLENBQUNDO1FBQ0MsSUFBSUEsWUFBWSxNQUFNO1lBQ3BCLE1BQU1DLGFBQWFMLFNBQVNJLE9BQU87WUFDbkMsSUFBSUMsWUFBWTtnQkFDZEwsU0FBU0ksT0FBTyxHQUFHO2dCQUNuQkM7WUFDRjtZQUNBLE1BQU1DLGFBQWFKLFNBQVNFLE9BQU87WUFDbkMsSUFBSUUsWUFBWTtnQkFDZEosU0FBU0UsT0FBTyxHQUFHO2dCQUNuQkU7WUFDRjtRQUNGLE9BQU87WUFDTCxJQUFJUixNQUFNO2dCQUNSRSxTQUFTSSxPQUFPLEdBQUdHLFNBQVNULE1BQU1NO1lBQ3BDO1lBQ0EsSUFBSUwsTUFBTTtnQkFDUkcsU0FBU0UsT0FBTyxHQUFHRyxTQUFTUixNQUFNSztZQUNwQztRQUNGO0lBQ0YsR0FDQTtRQUFDTjtRQUFNQztLQUFLO0FBRWhCO0FBRUEsU0FBU1EsU0FDUFQsSUFBZ0MsRUFDaENNLE9BQWlCO0lBRWpCLElBQUksT0FBT04sU0FBUyxZQUFZO1FBQzlCLE1BQU1VLFVBQVVWLEtBQUtNO1FBQ3JCLElBQUksT0FBT0ksWUFBWSxZQUFZO1lBQ2pDLE9BQU9BO1FBQ1QsT0FBTztZQUNMLE9BQU8sSUFBTVYsS0FBSztRQUNwQjtJQUNGLE9BQU87UUFDTEEsS0FBS00sT0FBTyxHQUFHQTtRQUNmLE9BQU87WUFDTE4sS0FBS00sT0FBTyxHQUFHO1FBQ2pCO0lBQ0Y7QUFDRiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAzOTgsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvc2hhcmVkL2xpYi91dGlscy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IEh0bWxQcm9wcyB9IGZyb20gJy4vaHRtbC1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHR5cGUgeyBDb21wb25lbnRUeXBlLCBKU1ggfSBmcm9tICdyZWFjdCdcbmltcG9ydCB0eXBlIHsgRG9tYWluTG9jYWxlIH0gZnJvbSAnLi4vLi4vc2VydmVyL2NvbmZpZydcbmltcG9ydCB0eXBlIHsgRW52IH0gZnJvbSAnQG5leHQvZW52J1xuaW1wb3J0IHR5cGUgeyBJbmNvbWluZ01lc3NhZ2UsIFNlcnZlclJlc3BvbnNlIH0gZnJvbSAnaHR0cCdcbmltcG9ydCB0eXBlIHsgTmV4dFJvdXRlciB9IGZyb20gJy4vcm91dGVyL3JvdXRlcidcbmltcG9ydCB0eXBlIHsgUGFyc2VkVXJsUXVlcnkgfSBmcm9tICdxdWVyeXN0cmluZydcbmltcG9ydCB0eXBlIHsgUHJldmlld0RhdGEgfSBmcm9tICcuLi8uLi90eXBlcydcbmltcG9ydCB0eXBlIHsgQ09NUElMRVJfTkFNRVMgfSBmcm9tICcuL2NvbnN0YW50cydcbmltcG9ydCB0eXBlIGZzIGZyb20gJ2ZzJ1xuXG5leHBvcnQgdHlwZSBOZXh0Q29tcG9uZW50VHlwZTxcbiAgQ29udGV4dCBleHRlbmRzIEJhc2VDb250ZXh0ID0gTmV4dFBhZ2VDb250ZXh0LFxuICBJbml0aWFsUHJvcHMgPSB7fSxcbiAgUHJvcHMgPSB7fSxcbj4gPSBDb21wb25lbnRUeXBlPFByb3BzPiAmIHtcbiAgLyoqXG4gICAqIFVzZWQgZm9yIGluaXRpYWwgcGFnZSBsb2FkIGRhdGEgcG9wdWxhdGlvbi4gRGF0YSByZXR1cm5lZCBmcm9tIGBnZXRJbml0aWFsUHJvcHNgIGlzIHNlcmlhbGl6ZWQgd2hlbiBzZXJ2ZXIgcmVuZGVyZWQuXG4gICAqIE1ha2Ugc3VyZSB0byByZXR1cm4gcGxhaW4gYE9iamVjdGAgd2l0aG91dCB1c2luZyBgRGF0ZWAsIGBNYXBgLCBgU2V0YC5cbiAgICogQHBhcmFtIGNvbnRleHQgQ29udGV4dCBvZiBgcGFnZWBcbiAgICovXG4gIGdldEluaXRpYWxQcm9wcz8oY29udGV4dDogQ29udGV4dCk6IEluaXRpYWxQcm9wcyB8IFByb21pc2U8SW5pdGlhbFByb3BzPlxufVxuXG5leHBvcnQgdHlwZSBEb2N1bWVudFR5cGUgPSBOZXh0Q29tcG9uZW50VHlwZTxcbiAgRG9jdW1lbnRDb250ZXh0LFxuICBEb2N1bWVudEluaXRpYWxQcm9wcyxcbiAgRG9jdW1lbnRQcm9wc1xuPlxuXG5leHBvcnQgdHlwZSBBcHBUeXBlPFAgPSB7fT4gPSBOZXh0Q29tcG9uZW50VHlwZTxcbiAgQXBwQ29udGV4dFR5cGUsXG4gIFAsXG4gIEFwcFByb3BzVHlwZTxhbnksIFA+XG4+XG5cbmV4cG9ydCB0eXBlIEFwcFRyZWVUeXBlID0gQ29tcG9uZW50VHlwZTxcbiAgQXBwSW5pdGlhbFByb3BzICYgeyBbbmFtZTogc3RyaW5nXTogYW55IH1cbj5cblxuLyoqXG4gKiBXZWIgdml0YWxzIHByb3ZpZGVkIHRvIF9hcHAucmVwb3J0V2ViVml0YWxzIGJ5IENvcmUgV2ViIFZpdGFscyBwbHVnaW4gZGV2ZWxvcGVkIGJ5IEdvb2dsZSBDaHJvbWUgdGVhbS5cbiAqIGh0dHBzOi8vbmV4dGpzLm9yZy9ibG9nL25leHQtOS00I2ludGVncmF0ZWQtd2ViLXZpdGFscy1yZXBvcnRpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IFdFQl9WSVRBTFMgPSBbJ0NMUycsICdGQ1AnLCAnRklEJywgJ0lOUCcsICdMQ1AnLCAnVFRGQiddIGFzIGNvbnN0XG5leHBvcnQgdHlwZSBOZXh0V2ViVml0YWxzTWV0cmljID0ge1xuICBpZDogc3RyaW5nXG4gIHN0YXJ0VGltZTogbnVtYmVyXG4gIHZhbHVlOiBudW1iZXJcbiAgYXR0cmlidXRpb24/OiB7IFtrZXk6IHN0cmluZ106IHVua25vd24gfVxufSAmIChcbiAgfCB7XG4gICAgICBsYWJlbDogJ3dlYi12aXRhbCdcbiAgICAgIG5hbWU6ICh0eXBlb2YgV0VCX1ZJVEFMUylbbnVtYmVyXVxuICAgIH1cbiAgfCB7XG4gICAgICBsYWJlbDogJ2N1c3RvbSdcbiAgICAgIG5hbWU6XG4gICAgICAgIHwgJ05leHQuanMtaHlkcmF0aW9uJ1xuICAgICAgICB8ICdOZXh0LmpzLXJvdXRlLWNoYW5nZS10by1yZW5kZXInXG4gICAgICAgIHwgJ05leHQuanMtcmVuZGVyJ1xuICAgIH1cbilcblxuZXhwb3J0IHR5cGUgRW5oYW5jZXI8Qz4gPSAoQ29tcG9uZW50OiBDKSA9PiBDXG5cbmV4cG9ydCB0eXBlIENvbXBvbmVudHNFbmhhbmNlciA9XG4gIHwge1xuICAgICAgZW5oYW5jZUFwcD86IEVuaGFuY2VyPEFwcFR5cGU+XG4gICAgICBlbmhhbmNlQ29tcG9uZW50PzogRW5oYW5jZXI8TmV4dENvbXBvbmVudFR5cGU+XG4gICAgfVxuICB8IEVuaGFuY2VyPE5leHRDb21wb25lbnRUeXBlPlxuXG5leHBvcnQgdHlwZSBSZW5kZXJQYWdlUmVzdWx0ID0ge1xuICBodG1sOiBzdHJpbmdcbiAgaGVhZD86IEFycmF5PEpTWC5FbGVtZW50IHwgbnVsbD5cbn1cblxuZXhwb3J0IHR5cGUgUmVuZGVyUGFnZSA9IChcbiAgb3B0aW9ucz86IENvbXBvbmVudHNFbmhhbmNlclxuKSA9PiBEb2N1bWVudEluaXRpYWxQcm9wcyB8IFByb21pc2U8RG9jdW1lbnRJbml0aWFsUHJvcHM+XG5cbmV4cG9ydCB0eXBlIEJhc2VDb250ZXh0ID0ge1xuICByZXM/OiBTZXJ2ZXJSZXNwb25zZVxuICBbazogc3RyaW5nXTogYW55XG59XG5cbmV4cG9ydCB0eXBlIE5FWFRfREFUQSA9IHtcbiAgcHJvcHM6IFJlY29yZDxzdHJpbmcsIGFueT5cbiAgcGFnZTogc3RyaW5nXG4gIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeVxuICBidWlsZElkOiBzdHJpbmdcbiAgYXNzZXRQcmVmaXg/OiBzdHJpbmdcbiAgcnVudGltZUNvbmZpZz86IHsgW2tleTogc3RyaW5nXTogYW55IH1cbiAgbmV4dEV4cG9ydD86IGJvb2xlYW5cbiAgYXV0b0V4cG9ydD86IGJvb2xlYW5cbiAgaXNGYWxsYmFjaz86IGJvb2xlYW5cbiAgaXNFeHBlcmltZW50YWxDb21waWxlPzogYm9vbGVhblxuICBkeW5hbWljSWRzPzogKHN0cmluZyB8IG51bWJlcilbXVxuICBlcnI/OiBFcnJvciAmIHtcbiAgICBzdGF0dXNDb2RlPzogbnVtYmVyXG4gICAgc291cmNlPzogdHlwZW9mIENPTVBJTEVSX05BTUVTLnNlcnZlciB8IHR5cGVvZiBDT01QSUxFUl9OQU1FUy5lZGdlU2VydmVyXG4gIH1cbiAgZ3NwPzogYm9vbGVhblxuICBnc3NwPzogYm9vbGVhblxuICBjdXN0b21TZXJ2ZXI/OiBib29sZWFuXG4gIGdpcD86IGJvb2xlYW5cbiAgYXBwR2lwPzogYm9vbGVhblxuICBsb2NhbGU/OiBzdHJpbmdcbiAgbG9jYWxlcz86IHJlYWRvbmx5IHN0cmluZ1tdXG4gIGRlZmF1bHRMb2NhbGU/OiBzdHJpbmdcbiAgZG9tYWluTG9jYWxlcz86IHJlYWRvbmx5IERvbWFpbkxvY2FsZVtdXG4gIHNjcmlwdExvYWRlcj86IGFueVtdXG4gIGlzUHJldmlldz86IGJvb2xlYW5cbiAgbm90Rm91bmRTcmNQYWdlPzogc3RyaW5nXG59XG5cbi8qKlxuICogYE5leHRgIGNvbnRleHRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBOZXh0UGFnZUNvbnRleHQge1xuICAvKipcbiAgICogRXJyb3Igb2JqZWN0IGlmIGVuY291bnRlcmVkIGR1cmluZyByZW5kZXJpbmdcbiAgICovXG4gIGVycj86IChFcnJvciAmIHsgc3RhdHVzQ29kZT86IG51bWJlciB9KSB8IG51bGxcbiAgLyoqXG4gICAqIGBIVFRQYCByZXF1ZXN0IG9iamVjdC5cbiAgICovXG4gIHJlcT86IEluY29taW5nTWVzc2FnZVxuICAvKipcbiAgICogYEhUVFBgIHJlc3BvbnNlIG9iamVjdC5cbiAgICovXG4gIHJlcz86IFNlcnZlclJlc3BvbnNlXG4gIC8qKlxuICAgKiBQYXRoIHNlY3Rpb24gb2YgYFVSTGAuXG4gICAqL1xuICBwYXRobmFtZTogc3RyaW5nXG4gIC8qKlxuICAgKiBRdWVyeSBzdHJpbmcgc2VjdGlvbiBvZiBgVVJMYCBwYXJzZWQgYXMgYW4gb2JqZWN0LlxuICAgKi9cbiAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5XG4gIC8qKlxuICAgKiBgU3RyaW5nYCBvZiB0aGUgYWN0dWFsIHBhdGggaW5jbHVkaW5nIHF1ZXJ5LlxuICAgKi9cbiAgYXNQYXRoPzogc3RyaW5nXG4gIC8qKlxuICAgKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBsb2NhbGVcbiAgICovXG4gIGxvY2FsZT86IHN0cmluZ1xuICAvKipcbiAgICogQWxsIGNvbmZpZ3VyZWQgbG9jYWxlc1xuICAgKi9cbiAgbG9jYWxlcz86IHJlYWRvbmx5IHN0cmluZ1tdXG4gIC8qKlxuICAgKiBUaGUgY29uZmlndXJlZCBkZWZhdWx0IGxvY2FsZVxuICAgKi9cbiAgZGVmYXVsdExvY2FsZT86IHN0cmluZ1xuICAvKipcbiAgICogYENvbXBvbmVudGAgdGhlIHRyZWUgb2YgdGhlIEFwcCB0byB1c2UgaWYgbmVlZGluZyB0byByZW5kZXIgc2VwYXJhdGVseVxuICAgKi9cbiAgQXBwVHJlZTogQXBwVHJlZVR5cGVcbn1cblxuZXhwb3J0IHR5cGUgQXBwQ29udGV4dFR5cGU8Um91dGVyIGV4dGVuZHMgTmV4dFJvdXRlciA9IE5leHRSb3V0ZXI+ID0ge1xuICBDb21wb25lbnQ6IE5leHRDb21wb25lbnRUeXBlPE5leHRQYWdlQ29udGV4dD5cbiAgQXBwVHJlZTogQXBwVHJlZVR5cGVcbiAgY3R4OiBOZXh0UGFnZUNvbnRleHRcbiAgcm91dGVyOiBSb3V0ZXJcbn1cblxuZXhwb3J0IHR5cGUgQXBwSW5pdGlhbFByb3BzPFBhZ2VQcm9wcyA9IGFueT4gPSB7XG4gIHBhZ2VQcm9wczogUGFnZVByb3BzXG59XG5cbmV4cG9ydCB0eXBlIEFwcFByb3BzVHlwZTxcbiAgUm91dGVyIGV4dGVuZHMgTmV4dFJvdXRlciA9IE5leHRSb3V0ZXIsXG4gIFBhZ2VQcm9wcyA9IHt9LFxuPiA9IEFwcEluaXRpYWxQcm9wczxQYWdlUHJvcHM+ICYge1xuICBDb21wb25lbnQ6IE5leHRDb21wb25lbnRUeXBlPE5leHRQYWdlQ29udGV4dCwgYW55LCBhbnk+XG4gIHJvdXRlcjogUm91dGVyXG4gIF9fTl9TU0c/OiBib29sZWFuXG4gIF9fTl9TU1A/OiBib29sZWFuXG59XG5cbmV4cG9ydCB0eXBlIERvY3VtZW50Q29udGV4dCA9IE5leHRQYWdlQ29udGV4dCAmIHtcbiAgcmVuZGVyUGFnZTogUmVuZGVyUGFnZVxuICBkZWZhdWx0R2V0SW5pdGlhbFByb3BzKFxuICAgIGN0eDogRG9jdW1lbnRDb250ZXh0LFxuICAgIG9wdGlvbnM/OiB7IG5vbmNlPzogc3RyaW5nIH1cbiAgKTogUHJvbWlzZTxEb2N1bWVudEluaXRpYWxQcm9wcz5cbn1cblxuZXhwb3J0IHR5cGUgRG9jdW1lbnRJbml0aWFsUHJvcHMgPSBSZW5kZXJQYWdlUmVzdWx0ICYge1xuICBzdHlsZXM/OiBSZWFjdC5SZWFjdEVsZW1lbnRbXSB8IEl0ZXJhYmxlPFJlYWN0LlJlYWN0Tm9kZT4gfCBKU1guRWxlbWVudFxufVxuXG5leHBvcnQgdHlwZSBEb2N1bWVudFByb3BzID0gRG9jdW1lbnRJbml0aWFsUHJvcHMgJiBIdG1sUHJvcHNcblxuLyoqXG4gKiBOZXh0IGBBUElgIHJvdXRlIHJlcXVlc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBOZXh0QXBpUmVxdWVzdCBleHRlbmRzIEluY29taW5nTWVzc2FnZSB7XG4gIC8qKlxuICAgKiBPYmplY3Qgb2YgYHF1ZXJ5YCB2YWx1ZXMgZnJvbSB1cmxcbiAgICovXG4gIHF1ZXJ5OiBQYXJ0aWFsPHtcbiAgICBba2V5OiBzdHJpbmddOiBzdHJpbmcgfCBzdHJpbmdbXVxuICB9PlxuICAvKipcbiAgICogT2JqZWN0IG9mIGBjb29raWVzYCBmcm9tIGhlYWRlclxuICAgKi9cbiAgY29va2llczogUGFydGlhbDx7XG4gICAgW2tleTogc3RyaW5nXTogc3RyaW5nXG4gIH0+XG5cbiAgYm9keTogYW55XG5cbiAgZW52OiBFbnZcblxuICBkcmFmdE1vZGU/OiBib29sZWFuXG5cbiAgcHJldmlldz86IGJvb2xlYW5cbiAgLyoqXG4gICAqIFByZXZpZXcgZGF0YSBzZXQgb24gdGhlIHJlcXVlc3QsIGlmIGFueVxuICAgKiAqL1xuICBwcmV2aWV3RGF0YT86IFByZXZpZXdEYXRhXG59XG5cbi8qKlxuICogU2VuZCBib2R5IG9mIHJlc3BvbnNlXG4gKi9cbnR5cGUgU2VuZDxUPiA9IChib2R5OiBUKSA9PiB2b2lkXG5cbi8qKlxuICogTmV4dCBgQVBJYCByb3V0ZSByZXNwb25zZVxuICovXG5leHBvcnQgdHlwZSBOZXh0QXBpUmVzcG9uc2U8RGF0YSA9IGFueT4gPSBTZXJ2ZXJSZXNwb25zZSAmIHtcbiAgLyoqXG4gICAqIFNlbmQgZGF0YSBgYW55YCBkYXRhIGluIHJlc3BvbnNlXG4gICAqL1xuICBzZW5kOiBTZW5kPERhdGE+XG4gIC8qKlxuICAgKiBTZW5kIGRhdGEgYGpzb25gIGRhdGEgaW4gcmVzcG9uc2VcbiAgICovXG4gIGpzb246IFNlbmQ8RGF0YT5cbiAgc3RhdHVzOiAoc3RhdHVzQ29kZTogbnVtYmVyKSA9PiBOZXh0QXBpUmVzcG9uc2U8RGF0YT5cbiAgcmVkaXJlY3QodXJsOiBzdHJpbmcpOiBOZXh0QXBpUmVzcG9uc2U8RGF0YT5cbiAgcmVkaXJlY3Qoc3RhdHVzOiBudW1iZXIsIHVybDogc3RyaW5nKTogTmV4dEFwaVJlc3BvbnNlPERhdGE+XG5cbiAgLyoqXG4gICAqIFNldCBkcmFmdCBtb2RlXG4gICAqL1xuICBzZXREcmFmdE1vZGU6IChvcHRpb25zOiB7IGVuYWJsZTogYm9vbGVhbiB9KSA9PiBOZXh0QXBpUmVzcG9uc2U8RGF0YT5cblxuICAvKipcbiAgICogU2V0IHByZXZpZXcgZGF0YSBmb3IgTmV4dC5qcycgcHJlcmVuZGVyIG1vZGVcbiAgICovXG4gIHNldFByZXZpZXdEYXRhOiAoXG4gICAgZGF0YTogb2JqZWN0IHwgc3RyaW5nLFxuICAgIG9wdGlvbnM/OiB7XG4gICAgICAvKipcbiAgICAgICAqIFNwZWNpZmllcyB0aGUgbnVtYmVyIChpbiBzZWNvbmRzKSBmb3IgdGhlIHByZXZpZXcgc2Vzc2lvbiB0byBsYXN0IGZvci5cbiAgICAgICAqIFRoZSBnaXZlbiBudW1iZXIgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYW4gaW50ZWdlciBieSByb3VuZGluZyBkb3duLlxuICAgICAgICogQnkgZGVmYXVsdCwgbm8gbWF4aW11bSBhZ2UgaXMgc2V0IGFuZCB0aGUgcHJldmlldyBzZXNzaW9uIGZpbmlzaGVzXG4gICAgICAgKiB3aGVuIHRoZSBjbGllbnQgc2h1dHMgZG93biAoYnJvd3NlciBpcyBjbG9zZWQpLlxuICAgICAgICovXG4gICAgICBtYXhBZ2U/OiBudW1iZXJcbiAgICAgIC8qKlxuICAgICAgICogU3BlY2lmaWVzIHRoZSBwYXRoIGZvciB0aGUgcHJldmlldyBzZXNzaW9uIHRvIHdvcmsgdW5kZXIuIEJ5IGRlZmF1bHQsXG4gICAgICAgKiB0aGUgcGF0aCBpcyBjb25zaWRlcmVkIHRoZSBcImRlZmF1bHQgcGF0aFwiLCBpLmUuLCBhbnkgcGFnZXMgdW5kZXIgXCIvXCIuXG4gICAgICAgKi9cbiAgICAgIHBhdGg/OiBzdHJpbmdcbiAgICB9XG4gICkgPT4gTmV4dEFwaVJlc3BvbnNlPERhdGE+XG5cbiAgLyoqXG4gICAqIENsZWFyIHByZXZpZXcgZGF0YSBmb3IgTmV4dC5qcycgcHJlcmVuZGVyIG1vZGVcbiAgICovXG4gIGNsZWFyUHJldmlld0RhdGE6IChvcHRpb25zPzogeyBwYXRoPzogc3RyaW5nIH0pID0+IE5leHRBcGlSZXNwb25zZTxEYXRhPlxuXG4gIC8qKlxuICAgKiBSZXZhbGlkYXRlIGEgc3BlY2lmaWMgcGFnZSBhbmQgcmVnZW5lcmF0ZSBpdCB1c2luZyBPbi1EZW1hbmQgSW5jcmVtZW50YWxcbiAgICogU3RhdGljIFJlZ2VuZXJhdGlvbi5cbiAgICogVGhlIHBhdGggc2hvdWxkIGJlIGFuIGFjdHVhbCBwYXRoLCBub3QgYSByZXdyaXR0ZW4gcGF0aC4gRS5nLiBmb3JcbiAgICogXCIvYmxvZy9bc2x1Z11cIiB0aGlzIHNob3VsZCBiZSBcIi9ibG9nL3Bvc3QtMVwiLlxuICAgKiBAbGluayBodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYnVpbGRpbmcteW91ci1hcHBsaWNhdGlvbi9kYXRhLWZldGNoaW5nL2luY3JlbWVudGFsLXN0YXRpYy1yZWdlbmVyYXRpb24jb24tZGVtYW5kLXJldmFsaWRhdGlvbi13aXRoLXJldmFsaWRhdGVwYXRoXG4gICAqL1xuICByZXZhbGlkYXRlOiAoXG4gICAgdXJsUGF0aDogc3RyaW5nLFxuICAgIG9wdHM/OiB7XG4gICAgICB1bnN0YWJsZV9vbmx5R2VuZXJhdGVkPzogYm9vbGVhblxuICAgIH1cbiAgKSA9PiBQcm9taXNlPHZvaWQ+XG59XG5cbi8qKlxuICogTmV4dCBgQVBJYCByb3V0ZSBoYW5kbGVyXG4gKi9cbmV4cG9ydCB0eXBlIE5leHRBcGlIYW5kbGVyPFQgPSBhbnk+ID0gKFxuICByZXE6IE5leHRBcGlSZXF1ZXN0LFxuICByZXM6IE5leHRBcGlSZXNwb25zZTxUPlxuKSA9PiB1bmtub3duIHwgUHJvbWlzZTx1bmtub3duPlxuXG4vKipcbiAqIFV0aWxzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleGVjT25jZTxUIGV4dGVuZHMgKC4uLmFyZ3M6IGFueVtdKSA9PiBSZXR1cm5UeXBlPFQ+PihcbiAgZm46IFRcbik6IFQge1xuICBsZXQgdXNlZCA9IGZhbHNlXG4gIGxldCByZXN1bHQ6IFJldHVyblR5cGU8VD5cblxuICByZXR1cm4gKCguLi5hcmdzOiBhbnlbXSkgPT4ge1xuICAgIGlmICghdXNlZCkge1xuICAgICAgdXNlZCA9IHRydWVcbiAgICAgIHJlc3VsdCA9IGZuKC4uLmFyZ3MpXG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfSkgYXMgVFxufVxuXG4vLyBTY2hlbWU6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tMy4xXG4vLyBBYnNvbHV0ZSBVUkw6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tNC4zXG5jb25zdCBBQlNPTFVURV9VUkxfUkVHRVggPSAvXlthLXpBLVpdW2EtekEtWlxcZCtcXC0uXSo/Oi9cbmV4cG9ydCBjb25zdCBpc0Fic29sdXRlVXJsID0gKHVybDogc3RyaW5nKSA9PiBBQlNPTFVURV9VUkxfUkVHRVgudGVzdCh1cmwpXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRMb2NhdGlvbk9yaWdpbigpIHtcbiAgY29uc3QgeyBwcm90b2NvbCwgaG9zdG5hbWUsIHBvcnQgfSA9IHdpbmRvdy5sb2NhdGlvblxuICByZXR1cm4gYCR7cHJvdG9jb2x9Ly8ke2hvc3RuYW1lfSR7cG9ydCA/ICc6JyArIHBvcnQgOiAnJ31gXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRVUkwoKSB7XG4gIGNvbnN0IHsgaHJlZiB9ID0gd2luZG93LmxvY2F0aW9uXG4gIGNvbnN0IG9yaWdpbiA9IGdldExvY2F0aW9uT3JpZ2luKClcbiAgcmV0dXJuIGhyZWYuc3Vic3RyaW5nKG9yaWdpbi5sZW5ndGgpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREaXNwbGF5TmFtZTxQPihDb21wb25lbnQ6IENvbXBvbmVudFR5cGU8UD4pIHtcbiAgcmV0dXJuIHR5cGVvZiBDb21wb25lbnQgPT09ICdzdHJpbmcnXG4gICAgPyBDb21wb25lbnRcbiAgICA6IENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnVW5rbm93bidcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUmVzU2VudChyZXM6IFNlcnZlclJlc3BvbnNlKSB7XG4gIHJldHVybiByZXMuZmluaXNoZWQgfHwgcmVzLmhlYWRlcnNTZW50XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVSZXBlYXRlZFNsYXNoZXModXJsOiBzdHJpbmcpIHtcbiAgY29uc3QgdXJsUGFydHMgPSB1cmwuc3BsaXQoJz8nKVxuICBjb25zdCB1cmxOb1F1ZXJ5ID0gdXJsUGFydHNbMF1cblxuICByZXR1cm4gKFxuICAgIHVybE5vUXVlcnlcbiAgICAgIC8vIGZpcnN0IHdlIHJlcGxhY2UgYW55IG5vbi1lbmNvZGVkIGJhY2tzbGFzaGVzIHdpdGggZm9yd2FyZFxuICAgICAgLy8gdGhlbiBub3JtYWxpemUgcmVwZWF0ZWQgZm9yd2FyZCBzbGFzaGVzXG4gICAgICAucmVwbGFjZSgvXFxcXC9nLCAnLycpXG4gICAgICAucmVwbGFjZSgvXFwvXFwvKy9nLCAnLycpICtcbiAgICAodXJsUGFydHNbMV0gPyBgPyR7dXJsUGFydHMuc2xpY2UoMSkuam9pbignPycpfWAgOiAnJylcbiAgKVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbG9hZEdldEluaXRpYWxQcm9wczxcbiAgQyBleHRlbmRzIEJhc2VDb250ZXh0LFxuICBJUCA9IHt9LFxuICBQID0ge30sXG4+KEFwcDogTmV4dENvbXBvbmVudFR5cGU8QywgSVAsIFA+LCBjdHg6IEMpOiBQcm9taXNlPElQPiB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKEFwcC5wcm90b3R5cGU/LmdldEluaXRpYWxQcm9wcykge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGBcIiR7Z2V0RGlzcGxheU5hbWUoXG4gICAgICAgIEFwcFxuICAgICAgKX0uZ2V0SW5pdGlhbFByb3BzKClcIiBpcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIG1ldGhvZCAtIHZpc2l0IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2dldC1pbml0aWFsLXByb3BzLWFzLWFuLWluc3RhbmNlLW1ldGhvZCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5gXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSlcbiAgICB9XG4gIH1cbiAgLy8gd2hlbiBjYWxsZWQgZnJvbSBfYXBwIGBjdHhgIGlzIG5lc3RlZCBpbiBgY3R4YFxuICBjb25zdCByZXMgPSBjdHgucmVzIHx8IChjdHguY3R4ICYmIGN0eC5jdHgucmVzKVxuXG4gIGlmICghQXBwLmdldEluaXRpYWxQcm9wcykge1xuICAgIGlmIChjdHguY3R4ICYmIGN0eC5Db21wb25lbnQpIHtcbiAgICAgIC8vIEB0cy1pZ25vcmUgcGFnZVByb3BzIGRlZmF1bHRcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhZ2VQcm9wczogYXdhaXQgbG9hZEdldEluaXRpYWxQcm9wcyhjdHguQ29tcG9uZW50LCBjdHguY3R4KSxcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHt9IGFzIElQXG4gIH1cblxuICBjb25zdCBwcm9wcyA9IGF3YWl0IEFwcC5nZXRJbml0aWFsUHJvcHMoY3R4KVxuXG4gIGlmIChyZXMgJiYgaXNSZXNTZW50KHJlcykpIHtcbiAgICByZXR1cm4gcHJvcHNcbiAgfVxuXG4gIGlmICghcHJvcHMpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gYFwiJHtnZXREaXNwbGF5TmFtZShcbiAgICAgIEFwcFxuICAgICl9LmdldEluaXRpYWxQcm9wcygpXCIgc2hvdWxkIHJlc29sdmUgdG8gYW4gb2JqZWN0LiBCdXQgZm91bmQgXCIke3Byb3BzfVwiIGluc3RlYWQuYFxuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKVxuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoT2JqZWN0LmtleXMocHJvcHMpLmxlbmd0aCA9PT0gMCAmJiAhY3R4LmN0eCkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgJHtnZXREaXNwbGF5TmFtZShcbiAgICAgICAgICBBcHBcbiAgICAgICAgKX0gcmV0dXJuZWQgYW4gZW1wdHkgb2JqZWN0IGZyb20gXFxgZ2V0SW5pdGlhbFByb3BzXFxgLiBUaGlzIGRlLW9wdGltaXplcyBhbmQgcHJldmVudHMgYXV0b21hdGljIHN0YXRpYyBvcHRpbWl6YXRpb24uIGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2VtcHR5LW9iamVjdC1nZXRJbml0aWFsUHJvcHNgXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHByb3BzXG59XG5cbmV4cG9ydCBjb25zdCBTUCA9IHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gJ3VuZGVmaW5lZCdcbmV4cG9ydCBjb25zdCBTVCA9XG4gIFNQICYmXG4gIChbJ21hcmsnLCAnbWVhc3VyZScsICdnZXRFbnRyaWVzQnlOYW1lJ10gYXMgY29uc3QpLmV2ZXJ5KFxuICAgIChtZXRob2QpID0+IHR5cGVvZiBwZXJmb3JtYW5jZVttZXRob2RdID09PSAnZnVuY3Rpb24nXG4gIClcblxuZXhwb3J0IGNsYXNzIERlY29kZUVycm9yIGV4dGVuZHMgRXJyb3Ige31cbmV4cG9ydCBjbGFzcyBOb3JtYWxpemVFcnJvciBleHRlbmRzIEVycm9yIHt9XG5leHBvcnQgY2xhc3MgUGFnZU5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvZGU6IHN0cmluZ1xuXG4gIGNvbnN0cnVjdG9yKHBhZ2U6IHN0cmluZykge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLmNvZGUgPSAnRU5PRU5UJ1xuICAgIHRoaXMubmFtZSA9ICdQYWdlTm90Rm91bmRFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBgQ2Fubm90IGZpbmQgbW9kdWxlIGZvciBwYWdlOiAke3BhZ2V9YFxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBNaXNzaW5nU3RhdGljUGFnZSBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IocGFnZTogc3RyaW5nLCBtZXNzYWdlOiBzdHJpbmcpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5tZXNzYWdlID0gYEZhaWxlZCB0byBsb2FkIHN0YXRpYyBmaWxlIGZvciBwYWdlOiAke3BhZ2V9ICR7bWVzc2FnZX1gXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIE1pZGRsZXdhcmVOb3RGb3VuZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb2RlOiBzdHJpbmdcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuY29kZSA9ICdFTk9FTlQnXG4gICAgdGhpcy5tZXNzYWdlID0gYENhbm5vdCBmaW5kIHRoZSBtaWRkbGV3YXJlIG1vZHVsZWBcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIENhY2hlRnMge1xuICBleGlzdHNTeW5jOiB0eXBlb2YgZnMuZXhpc3RzU3luY1xuICByZWFkRmlsZTogdHlwZW9mIGZzLnByb21pc2VzLnJlYWRGaWxlXG4gIHJlYWRGaWxlU3luYzogdHlwZW9mIGZzLnJlYWRGaWxlU3luY1xuICB3cml0ZUZpbGUoZjogc3RyaW5nLCBkOiBhbnkpOiBQcm9taXNlPHZvaWQ+XG4gIG1rZGlyKGRpcjogc3RyaW5nKTogUHJvbWlzZTx2b2lkIHwgc3RyaW5nPlxuICBzdGF0KGY6IHN0cmluZyk6IFByb21pc2U8eyBtdGltZTogRGF0ZSB9PlxufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5naWZ5RXJyb3IoZXJyb3I6IEVycm9yKSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSh7IG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsIHN0YWNrOiBlcnJvci5zdGFjayB9KVxufVxuIl0sIm5hbWVzIjpbIkRlY29kZUVycm9yIiwiTWlkZGxld2FyZU5vdEZvdW5kRXJyb3IiLCJNaXNzaW5nU3RhdGljUGFnZSIsIk5vcm1hbGl6ZUVycm9yIiwiUGFnZU5vdEZvdW5kRXJyb3IiLCJTUCIsIlNUIiwiV0VCX1ZJVEFMUyIsImV4ZWNPbmNlIiwiZ2V0RGlzcGxheU5hbWUiLCJnZXRMb2NhdGlvbk9yaWdpbiIsImdldFVSTCIsImlzQWJzb2x1dGVVcmwiLCJpc1Jlc1NlbnQiLCJsb2FkR2V0SW5pdGlhbFByb3BzIiwibm9ybWFsaXplUmVwZWF0ZWRTbGFzaGVzIiwic3RyaW5naWZ5RXJyb3IiLCJmbiIsInVzZWQiLCJyZXN1bHQiLCJhcmdzIiwiQUJTT0xVVEVfVVJMX1JFR0VYIiwidXJsIiwidGVzdCIsInByb3RvY29sIiwiaG9zdG5hbWUiLCJwb3J0Iiwid2luZG93IiwibG9jYXRpb24iLCJocmVmIiwib3JpZ2luIiwic3Vic3RyaW5nIiwibGVuZ3RoIiwiQ29tcG9uZW50IiwiZGlzcGxheU5hbWUiLCJuYW1lIiwicmVzIiwiZmluaXNoZWQiLCJoZWFkZXJzU2VudCIsInVybFBhcnRzIiwic3BsaXQiLCJ1cmxOb1F1ZXJ5IiwicmVwbGFjZSIsInNsaWNlIiwiam9pbiIsIkFwcCIsImN0eCIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsInByb3RvdHlwZSIsImdldEluaXRpYWxQcm9wcyIsIm1lc3NhZ2UiLCJFcnJvciIsInBhZ2VQcm9wcyIsInByb3BzIiwiT2JqZWN0Iiwia2V5cyIsImNvbnNvbGUiLCJ3YXJuIiwicGVyZm9ybWFuY2UiLCJldmVyeSIsIm1ldGhvZCIsImNvbnN0cnVjdG9yIiwicGFnZSIsImNvZGUiLCJlcnJvciIsIkpTT04iLCJzdHJpbmdpZnkiLCJzdGFjayJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFvYWFBLFdBQVcsRUFBQTtlQUFYQTs7SUFvQkFDLHVCQUF1QixFQUFBO2VBQXZCQTs7SUFQQUMsaUJBQWlCLEVBQUE7ZUFBakJBOztJQVpBQyxjQUFjLEVBQUE7ZUFBZEE7O0lBQ0FDLGlCQUFpQixFQUFBO2VBQWpCQTs7SUFUQUMsRUFBRSxFQUFBO2VBQUZBOztJQUNBQyxFQUFFLEVBQUE7ZUFBRkE7O0lBbFhBQyxVQUFVLEVBQUE7ZUFBVkE7O0lBc1FHQyxRQUFRLEVBQUE7ZUFBUkE7O0lBK0JBQyxjQUFjLEVBQUE7ZUFBZEE7O0lBWEFDLGlCQUFpQixFQUFBO2VBQWpCQTs7SUFLQUMsTUFBTSxFQUFBO2VBQU5BOztJQVBIQyxhQUFhLEVBQUE7ZUFBYkE7O0lBbUJHQyxTQUFTLEVBQUE7ZUFBVEE7O0lBa0JNQyxtQkFBbUIsRUFBQTtlQUFuQkE7O0lBZE5DLHdCQUF3QixFQUFBO2VBQXhCQTs7SUErR0FDLGNBQWMsRUFBQTtlQUFkQTs7O0FBOVpULE1BQU1ULGFBQWE7SUFBQztJQUFPO0lBQU87SUFBTztJQUFPO0lBQU87Q0FBTztBQXNROUQsU0FBU0MsU0FDZFMsRUFBSztJQUVMLElBQUlDLE9BQU87SUFDWCxJQUFJQztJQUVKLE9BQVE7eUNBQUlDLE9BQUFBLElBQUFBLE1BQUFBLE9BQUFBLE9BQUFBLEdBQUFBLE9BQUFBLE1BQUFBLE9BQUFBO1lBQUFBLElBQUFBLENBQUFBLEtBQUFBLEdBQUFBLFNBQUFBLENBQUFBLEtBQUFBOztRQUNWLElBQUksQ0FBQ0YsTUFBTTtZQUNUQSxPQUFPO1lBQ1BDLFNBQVNGLE1BQU1HO1FBQ2pCO1FBQ0EsT0FBT0Q7SUFDVDtBQUNGO0FBRUEsMERBQTBEO0FBQzFELGdFQUFnRTtBQUNoRSxNQUFNRSxxQkFBcUI7QUFDcEIsTUFBTVQsZ0JBQWdCLENBQUNVLE1BQWdCRCxtQkFBbUJFLElBQUksQ0FBQ0Q7QUFFL0QsU0FBU1o7SUFDZCxNQUFNLEVBQUVjLFFBQVEsRUFBRUMsUUFBUSxFQUFFQyxJQUFJLEVBQUUsR0FBR0MsT0FBT0MsUUFBUTtJQUNwRCxPQUFVSixXQUFTLE9BQUlDLFdBQVdDLENBQUFBLE9BQU8sTUFBTUEsT0FBTyxFQUFDO0FBQ3pEO0FBRU8sU0FBU2Y7SUFDZCxNQUFNLEVBQUVrQixJQUFJLEVBQUUsR0FBR0YsT0FBT0MsUUFBUTtJQUNoQyxNQUFNRSxTQUFTcEI7SUFDZixPQUFPbUIsS0FBS0UsU0FBUyxDQUFDRCxPQUFPRSxNQUFNO0FBQ3JDO0FBRU8sU0FBU3ZCLGVBQWtCd0IsU0FBMkI7SUFDM0QsT0FBTyxPQUFPQSxjQUFjLFdBQ3hCQSxZQUNBQSxVQUFVQyxXQUFXLElBQUlELFVBQVVFLElBQUksSUFBSTtBQUNqRDtBQUVPLFNBQVN0QixVQUFVdUIsR0FBbUI7SUFDM0MsT0FBT0EsSUFBSUMsUUFBUSxJQUFJRCxJQUFJRSxXQUFXO0FBQ3hDO0FBRU8sU0FBU3ZCLHlCQUF5Qk8sR0FBVztJQUNsRCxNQUFNaUIsV0FBV2pCLElBQUlrQixLQUFLLENBQUM7SUFDM0IsTUFBTUMsYUFBYUYsUUFBUSxDQUFDLEVBQUU7SUFFOUIsT0FDRUUsV0FDRSw0REFBNEQ7SUFDNUQsMENBQTBDO0tBQ3pDQyxPQUFPLENBQUMsT0FBTyxLQUNmQSxPQUFPLENBQUMsVUFBVSxPQUNwQkgsQ0FBQUEsUUFBUSxDQUFDLEVBQUUsR0FBSSxNQUFHQSxTQUFTSSxLQUFLLENBQUMsR0FBR0MsSUFBSSxDQUFDLE9BQVMsRUFBQztBQUV4RDtBQUVPLGVBQWU5QixvQkFJcEIrQixHQUFnQyxFQUFFQyxHQUFNO0lBQ3hDLElBQUlDLFFBQVFDLEdBQUcsQ0FBQ0MsUUFBUSxLQUFLLFdBQWM7WUFDckNKO1FBQUosSUFBQSxDQUFJQSxpQkFBQUEsSUFBSUssU0FBUyxLQUFBLE9BQUEsS0FBQSxJQUFiTCxlQUFlTSxlQUFlLEVBQUU7WUFDbEMsTUFBTUMsVUFBVyxNQUFHM0MsZUFDbEJvQyxPQUNBO1lBQ0YsTUFBTSxPQUFBLGNBQWtCLENBQWxCLElBQUlRLE1BQU1ELFVBQVYscUJBQUE7dUJBQUE7NEJBQUE7OEJBQUE7WUFBaUI7UUFDekI7SUFDRjtJQUNBLGlEQUFpRDtJQUNqRCxNQUFNaEIsTUFBTVUsSUFBSVYsR0FBRyxJQUFLVSxJQUFJQSxHQUFHLElBQUlBLElBQUlBLEdBQUcsQ0FBQ1YsR0FBRztJQUU5QyxJQUFJLENBQUNTLElBQUlNLGVBQWUsRUFBRTtRQUN4QixJQUFJTCxJQUFJQSxHQUFHLElBQUlBLElBQUliLFNBQVMsRUFBRTtZQUM1QiwrQkFBK0I7WUFDL0IsT0FBTztnQkFDTHFCLFdBQVcsTUFBTXhDLG9CQUFvQmdDLElBQUliLFNBQVMsRUFBRWEsSUFBSUEsR0FBRztZQUM3RDtRQUNGO1FBQ0EsT0FBTyxDQUFDO0lBQ1Y7SUFFQSxNQUFNUyxRQUFRLE1BQU1WLElBQUlNLGVBQWUsQ0FBQ0w7SUFFeEMsSUFBSVYsT0FBT3ZCLFVBQVV1QixNQUFNO1FBQ3pCLE9BQU9tQjtJQUNUO0lBRUEsSUFBSSxDQUFDQSxPQUFPO1FBQ1YsTUFBTUgsVUFBVyxNQUFHM0MsZUFDbEJvQyxPQUNBLGlFQUE4RFUsUUFBTTtRQUN0RSxNQUFNLE9BQUEsY0FBa0IsQ0FBbEIsSUFBSUYsTUFBTUQsVUFBVixxQkFBQTttQkFBQTt3QkFBQTswQkFBQTtRQUFpQjtJQUN6QjtJQUVBLElBQUlMLFFBQVFDLEdBQUcsQ0FBQ0MsUUFBUSxLQUFLLFdBQWM7UUFDekMsSUFBSU8sT0FBT0MsSUFBSSxDQUFDRixPQUFPdkIsTUFBTSxLQUFLLEtBQUssQ0FBQ2MsSUFBSUEsR0FBRyxFQUFFO1lBQy9DWSxRQUFRQyxJQUFJLENBQ1QsS0FBRWxELGVBQ0RvQyxPQUNBO1FBRU47SUFDRjtJQUVBLE9BQU9VO0FBQ1Q7QUFFTyxNQUFNbEQsS0FBSyxPQUFPdUQsZ0JBQWdCO0FBQ2xDLE1BQU10RCxLQUNYRCxNQUNDO0lBQUM7SUFBUTtJQUFXO0NBQW1CLENBQVd3RCxLQUFLLENBQ3RELENBQUNDLFNBQVcsT0FBT0YsV0FBVyxDQUFDRSxPQUFPLEtBQUs7QUFHeEMsTUFBTTlELG9CQUFvQnFEO0FBQU87QUFDakMsTUFBTWxELHVCQUF1QmtEO0FBQU87QUFDcEMsTUFBTWpELDBCQUEwQmlEO0lBR3JDVSxZQUFZQyxJQUFZLENBQUU7UUFDeEIsS0FBSztRQUNMLElBQUksQ0FBQ0MsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDOUIsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDaUIsT0FBTyxHQUFJLGtDQUErQlk7SUFDakQ7QUFDRjtBQUVPLE1BQU05RCwwQkFBMEJtRDtJQUNyQ1UsWUFBWUMsSUFBWSxFQUFFWixPQUFlLENBQUU7UUFDekMsS0FBSztRQUNMLElBQUksQ0FBQ0EsT0FBTyxHQUFJLDBDQUF1Q1ksT0FBSyxNQUFHWjtJQUNqRTtBQUNGO0FBRU8sTUFBTW5ELGdDQUFnQ29EO0lBRTNDVSxhQUFjO1FBQ1osS0FBSztRQUNMLElBQUksQ0FBQ0UsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDYixPQUFPLEdBQUk7SUFDbEI7QUFDRjtBQVdPLFNBQVNwQyxlQUFla0QsS0FBWTtJQUN6QyxPQUFPQyxLQUFLQyxTQUFTLENBQUM7UUFBRWhCLFNBQVNjLE1BQU1kLE9BQU87UUFBRWlCLE9BQU9ILE1BQU1HLEtBQUs7SUFBQztBQUNyRSIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA2MTIsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcGFyc2UtcGF0aC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEdpdmVuIGEgcGF0aCB0aGlzIGZ1bmN0aW9uIHdpbGwgZmluZCB0aGUgcGF0aG5hbWUsIHF1ZXJ5IGFuZCBoYXNoIGFuZCByZXR1cm5cbiAqIHRoZW0uIFRoaXMgaXMgdXNlZnVsIHRvIHBhcnNlIGZ1bGwgcGF0aHMgb24gdGhlIGNsaWVudCBzaWRlLlxuICogQHBhcmFtIHBhdGggQSBwYXRoIHRvIHBhcnNlIGUuZy4gL2Zvby9iYXI/aWQ9MSNoYXNoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVBhdGgocGF0aDogc3RyaW5nKSB7XG4gIGNvbnN0IGhhc2hJbmRleCA9IHBhdGguaW5kZXhPZignIycpXG4gIGNvbnN0IHF1ZXJ5SW5kZXggPSBwYXRoLmluZGV4T2YoJz8nKVxuICBjb25zdCBoYXNRdWVyeSA9IHF1ZXJ5SW5kZXggPiAtMSAmJiAoaGFzaEluZGV4IDwgMCB8fCBxdWVyeUluZGV4IDwgaGFzaEluZGV4KVxuXG4gIGlmIChoYXNRdWVyeSB8fCBoYXNoSW5kZXggPiAtMSkge1xuICAgIHJldHVybiB7XG4gICAgICBwYXRobmFtZTogcGF0aC5zdWJzdHJpbmcoMCwgaGFzUXVlcnkgPyBxdWVyeUluZGV4IDogaGFzaEluZGV4KSxcbiAgICAgIHF1ZXJ5OiBoYXNRdWVyeVxuICAgICAgICA/IHBhdGguc3Vic3RyaW5nKHF1ZXJ5SW5kZXgsIGhhc2hJbmRleCA+IC0xID8gaGFzaEluZGV4IDogdW5kZWZpbmVkKVxuICAgICAgICA6ICcnLFxuICAgICAgaGFzaDogaGFzaEluZGV4ID4gLTEgPyBwYXRoLnNsaWNlKGhhc2hJbmRleCkgOiAnJyxcbiAgICB9XG4gIH1cblxuICByZXR1cm4geyBwYXRobmFtZTogcGF0aCwgcXVlcnk6ICcnLCBoYXNoOiAnJyB9XG59XG4iXSwibmFtZXMiOlsicGFyc2VQYXRoIiwicGF0aCIsImhhc2hJbmRleCIsImluZGV4T2YiLCJxdWVyeUluZGV4IiwiaGFzUXVlcnkiLCJwYXRobmFtZSIsInN1YnN0cmluZyIsInF1ZXJ5IiwidW5kZWZpbmVkIiwiaGFzaCIsInNsaWNlIl0sIm1hcHBpbmdzIjoiQUFBQTs7OztDQUlDOzs7K0JBQ2VBLGFBQUFBOzs7ZUFBQUE7OztBQUFULFNBQVNBLFVBQVVDLElBQVk7SUFDcEMsTUFBTUMsWUFBWUQsS0FBS0UsT0FBTyxDQUFDO0lBQy9CLE1BQU1DLGFBQWFILEtBQUtFLE9BQU8sQ0FBQztJQUNoQyxNQUFNRSxXQUFXRCxhQUFhLENBQUMsS0FBTUYsQ0FBQUEsWUFBWSxLQUFLRSxhQUFhRixTQUFRO0lBRTNFLElBQUlHLFlBQVlILFlBQVksQ0FBQyxHQUFHO1FBQzlCLE9BQU87WUFDTEksVUFBVUwsS0FBS00sU0FBUyxDQUFDLEdBQUdGLFdBQVdELGFBQWFGO1lBQ3BETSxPQUFPSCxXQUNISixLQUFLTSxTQUFTLENBQUNILFlBQVlGLFlBQVksQ0FBQyxJQUFJQSxZQUFZTyxhQUN4RDtZQUNKQyxNQUFNUixZQUFZLENBQUMsSUFBSUQsS0FBS1UsS0FBSyxDQUFDVCxhQUFhO1FBQ2pEO0lBQ0Y7SUFFQSxPQUFPO1FBQUVJLFVBQVVMO1FBQU1PLE9BQU87UUFBSUUsTUFBTTtJQUFHO0FBQy9DIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDY0OCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9zaGFyZWQvbGliL3JvdXRlci91dGlscy9hZGQtcGF0aC1wcmVmaXgudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcGFyc2VQYXRoIH0gZnJvbSAnLi9wYXJzZS1wYXRoJ1xuXG4vKipcbiAqIEFkZHMgdGhlIHByb3ZpZGVkIHByZWZpeCB0byB0aGUgZ2l2ZW4gcGF0aC4gSXQgZmlyc3QgZW5zdXJlcyB0aGF0IHRoZSBwYXRoXG4gKiBpcyBpbmRlZWQgc3RhcnRpbmcgd2l0aCBhIHNsYXNoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkUGF0aFByZWZpeChwYXRoOiBzdHJpbmcsIHByZWZpeD86IHN0cmluZykge1xuICBpZiAoIXBhdGguc3RhcnRzV2l0aCgnLycpIHx8ICFwcmVmaXgpIHtcbiAgICByZXR1cm4gcGF0aFxuICB9XG5cbiAgY29uc3QgeyBwYXRobmFtZSwgcXVlcnksIGhhc2ggfSA9IHBhcnNlUGF0aChwYXRoKVxuICByZXR1cm4gYCR7cHJlZml4fSR7cGF0aG5hbWV9JHtxdWVyeX0ke2hhc2h9YFxufVxuIl0sIm5hbWVzIjpbImFkZFBhdGhQcmVmaXgiLCJwYXRoIiwicHJlZml4Iiwic3RhcnRzV2l0aCIsInBhdGhuYW1lIiwicXVlcnkiLCJoYXNoIiwicGFyc2VQYXRoIl0sIm1hcHBpbmdzIjoiOzs7K0JBTWdCQSxpQkFBQUE7OztlQUFBQTs7OzJCQU5VO0FBTW5CLFNBQVNBLGNBQWNDLElBQVksRUFBRUMsTUFBZTtJQUN6RCxJQUFJLENBQUNELEtBQUtFLFVBQVUsQ0FBQyxRQUFRLENBQUNELFFBQVE7UUFDcEMsT0FBT0Q7SUFDVDtJQUVBLE1BQU0sRUFBRUcsUUFBUSxFQUFFQyxLQUFLLEVBQUVDLElBQUksRUFBRSxHQUFHQyxDQUFBQSxHQUFBQSxXQUFBQSxTQUFTLEVBQUNOO0lBQzVDLE9BQVEsS0FBRUMsU0FBU0UsV0FBV0MsUUFBUUM7QUFDeEMiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNjcxLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3JlbW92ZS10cmFpbGluZy1zbGFzaC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFJlbW92ZXMgdGhlIHRyYWlsaW5nIHNsYXNoIGZvciBhIGdpdmVuIHJvdXRlIG9yIHBhZ2UgcGF0aC4gUHJlc2VydmVzIHRoZVxuICogcm9vdCBwYWdlLiBFeGFtcGxlczpcbiAqICAgLSBgL2Zvby9iYXIvYCAtPiBgL2Zvby9iYXJgXG4gKiAgIC0gYC9mb28vYmFyYCAtPiBgL2Zvby9iYXJgXG4gKiAgIC0gYC9gIC0+IGAvYFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlVHJhaWxpbmdTbGFzaChyb3V0ZTogc3RyaW5nKSB7XG4gIHJldHVybiByb3V0ZS5yZXBsYWNlKC9cXC8kLywgJycpIHx8ICcvJ1xufVxuIl0sIm5hbWVzIjpbInJlbW92ZVRyYWlsaW5nU2xhc2giLCJyb3V0ZSIsInJlcGxhY2UiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Q0FNQzs7OytCQUNlQSx1QkFBQUE7OztlQUFBQTs7O0FBQVQsU0FBU0Esb0JBQW9CQyxLQUFhO0lBQy9DLE9BQU9BLE1BQU1DLE9BQU8sQ0FBQyxPQUFPLE9BQU87QUFDckMiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNjk1LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2NsaWVudC9ub3JtYWxpemUtdHJhaWxpbmctc2xhc2gudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmVtb3ZlVHJhaWxpbmdTbGFzaCB9IGZyb20gJy4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3JlbW92ZS10cmFpbGluZy1zbGFzaCdcbmltcG9ydCB7IHBhcnNlUGF0aCB9IGZyb20gJy4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3BhcnNlLXBhdGgnXG5cbi8qKlxuICogTm9ybWFsaXplcyB0aGUgdHJhaWxpbmcgc2xhc2ggb2YgYSBwYXRoIGFjY29yZGluZyB0byB0aGUgYHRyYWlsaW5nU2xhc2hgIG9wdGlvblxuICogaW4gYG5leHQuY29uZmlnLmpzYC5cbiAqL1xuZXhwb3J0IGNvbnN0IG5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoID0gKHBhdGg6IHN0cmluZykgPT4ge1xuICBpZiAoIXBhdGguc3RhcnRzV2l0aCgnLycpIHx8IHByb2Nlc3MuZW52Ll9fTkVYVF9NQU5VQUxfVFJBSUxJTkdfU0xBU0gpIHtcbiAgICByZXR1cm4gcGF0aFxuICB9XG5cbiAgY29uc3QgeyBwYXRobmFtZSwgcXVlcnksIGhhc2ggfSA9IHBhcnNlUGF0aChwYXRoKVxuICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1RSQUlMSU5HX1NMQVNIKSB7XG4gICAgaWYgKC9cXC5bXi9dK1xcLz8kLy50ZXN0KHBhdGhuYW1lKSkge1xuICAgICAgcmV0dXJuIGAke3JlbW92ZVRyYWlsaW5nU2xhc2gocGF0aG5hbWUpfSR7cXVlcnl9JHtoYXNofWBcbiAgICB9IGVsc2UgaWYgKHBhdGhuYW1lLmVuZHNXaXRoKCcvJykpIHtcbiAgICAgIHJldHVybiBgJHtwYXRobmFtZX0ke3F1ZXJ5fSR7aGFzaH1gXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBgJHtwYXRobmFtZX0vJHtxdWVyeX0ke2hhc2h9YFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBgJHtyZW1vdmVUcmFpbGluZ1NsYXNoKHBhdGhuYW1lKX0ke3F1ZXJ5fSR7aGFzaH1gXG59XG4iXSwibmFtZXMiOlsibm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2giLCJwYXRoIiwic3RhcnRzV2l0aCIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfTUFOVUFMX1RSQUlMSU5HX1NMQVNIIiwicGF0aG5hbWUiLCJxdWVyeSIsImhhc2giLCJwYXJzZVBhdGgiLCJfX05FWFRfVFJBSUxJTkdfU0xBU0giLCJ0ZXN0IiwicmVtb3ZlVHJhaWxpbmdTbGFzaCIsImVuZHNXaXRoIl0sIm1hcHBpbmdzIjoiOzs7K0JBT2FBLDhCQUFBQTs7O2VBQUFBOzs7cUNBUHVCOzJCQUNWO0FBTW5CLE1BQU1BLDZCQUE2QixDQUFDQztJQUN6QyxJQUFJLENBQUNBLEtBQUtDLFVBQVUsQ0FBQyxRQUFRQyxRQUFRQyxHQUFHLENBQUNDLDRCQUE0QixFQUFFO1FBQ3JFLE9BQU9KO0lBQ1Q7SUFFQSxNQUFNLEVBQUVLLFFBQVEsRUFBRUMsS0FBSyxFQUFFQyxJQUFJLEVBQUUsR0FBR0MsQ0FBQUEsR0FBQUEsV0FBQUEsU0FBUyxFQUFDUjtJQUM1QyxJQUFJRSxRQUFRQyxHQUFHLENBQUNNLHFCQUFxQixHQUFFO1FBQ3JDLElBQUksY0FBY0MsSUFBSSxDQUFDTCxXQUFXO1lBQ2hDLE9BQVEsS0FBRU0sQ0FBQUEsR0FBQUEscUJBQUFBLG1CQUFtQixFQUFDTixZQUFZQyxRQUFRQztRQUNwRCxPQUFPLElBQUlGLFNBQVNPLFFBQVEsQ0FBQyxNQUFNO1lBQ2pDLE9BQVEsS0FBRVAsV0FBV0MsUUFBUUM7UUFDL0IsT0FBTztZQUNMLE9BQVVGLFdBQVMsTUFBR0MsUUFBUUM7UUFDaEM7SUFDRjs7O0FBR0YiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNzM2LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2NsaWVudC9hZGQtYmFzZS1wYXRoLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFkZFBhdGhQcmVmaXggfSBmcm9tICcuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9hZGQtcGF0aC1wcmVmaXgnXG5pbXBvcnQgeyBub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCB9IGZyb20gJy4vbm9ybWFsaXplLXRyYWlsaW5nLXNsYXNoJ1xuXG5jb25zdCBiYXNlUGF0aCA9IChwcm9jZXNzLmVudi5fX05FWFRfUk9VVEVSX0JBU0VQQVRIIGFzIHN0cmluZykgfHwgJydcblxuZXhwb3J0IGZ1bmN0aW9uIGFkZEJhc2VQYXRoKHBhdGg6IHN0cmluZywgcmVxdWlyZWQ/OiBib29sZWFuKTogc3RyaW5nIHtcbiAgcmV0dXJuIG5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoKFxuICAgIHByb2Nlc3MuZW52Ll9fTkVYVF9NQU5VQUxfQ0xJRU5UX0JBU0VfUEFUSCAmJiAhcmVxdWlyZWRcbiAgICAgID8gcGF0aFxuICAgICAgOiBhZGRQYXRoUHJlZml4KHBhdGgsIGJhc2VQYXRoKVxuICApXG59XG4iXSwibmFtZXMiOlsiYWRkQmFzZVBhdGgiLCJiYXNlUGF0aCIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfUk9VVEVSX0JBU0VQQVRIIiwicGF0aCIsInJlcXVpcmVkIiwibm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2giLCJfX05FWFRfTUFOVUFMX0NMSUVOVF9CQVNFX1BBVEgiLCJhZGRQYXRoUHJlZml4Il0sIm1hcHBpbmdzIjoiOzs7K0JBS2dCQSxlQUFBQTs7O2VBQUFBOzs7K0JBTGM7d0NBQ2E7QUFFM0MsTUFBTUMsV0FBWUMsUUFBUUMsR0FBRyxDQUFDQyxzQkFBc0IsTUFBZTtBQUU1RCxTQUFTSixZQUFZSyxJQUFZLEVBQUVDLFFBQWtCO0lBQzFELE9BQU9DLENBQUFBLEdBQUFBLHdCQUFBQSwwQkFBMEIsRUFDL0JMLFFBQVFDLEdBQUcsQ0FBQ0ssMEJBQ1JILElBRHNDLElBQUksQ0FBQ0MsaUJBRTNDRyxDQUFBQSxHQUFBQSxlQUFBQSxhQUFhLEVBQUNKLE1BQU1KO0FBRTVCIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDc2NCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9zaGFyZWQvbGliL3V0aWxzL3dhcm4tb25jZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJsZXQgd2Fybk9uY2UgPSAoXzogc3RyaW5nKSA9PiB7fVxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgY29uc3Qgd2FybmluZ3MgPSBuZXcgU2V0PHN0cmluZz4oKVxuICB3YXJuT25jZSA9IChtc2c6IHN0cmluZykgPT4ge1xuICAgIGlmICghd2FybmluZ3MuaGFzKG1zZykpIHtcbiAgICAgIGNvbnNvbGUud2Fybihtc2cpXG4gICAgfVxuICAgIHdhcm5pbmdzLmFkZChtc2cpXG4gIH1cbn1cblxuZXhwb3J0IHsgd2Fybk9uY2UgfVxuIl0sIm5hbWVzIjpbIndhcm5PbmNlIiwiXyIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsIndhcm5pbmdzIiwiU2V0IiwibXNnIiwiaGFzIiwiY29uc29sZSIsIndhcm4iLCJhZGQiXSwibWFwcGluZ3MiOiI7OzsrQkFXU0EsWUFBQUE7OztlQUFBQTs7O0FBWFQsSUFBSUEsV0FBVyxDQUFDQyxLQUFlO0FBQy9CLElBQUlDLFFBQVFDLEdBQUcsQ0FBQ0MsUUFBUSxLQUFLLFdBQWM7SUFDekMsTUFBTUMsV0FBVyxJQUFJQztJQUNyQk4sV0FBVyxDQUFDTztRQUNWLElBQUksQ0FBQ0YsU0FBU0csR0FBRyxDQUFDRCxNQUFNO1lBQ3RCRSxRQUFRQyxJQUFJLENBQUNIO1FBQ2Y7UUFDQUYsU0FBU00sR0FBRyxDQUFDSjtJQUNmO0FBQ0YiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNzg5LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2NsaWVudC9jb21wb25lbnRzL2FwcC1yb3V0ZXItaGVhZGVycy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgUlNDX0hFQURFUiA9ICdSU0MnIGFzIGNvbnN0XG5leHBvcnQgY29uc3QgQUNUSU9OX0hFQURFUiA9ICdOZXh0LUFjdGlvbicgYXMgY29uc3Rcbi8vIFRPRE86IEluc3RlYWQgb2Ygc2VuZGluZyB0aGUgZnVsbCByb3V0ZXIgc3RhdGUsIHdlIG9ubHkgbmVlZCB0byBzZW5kIHRoZVxuLy8gc2VnbWVudCBwYXRoLiBTYXZlcyBieXRlcy4gVGhlbiB3ZSBjb3VsZCBhbHNvIHVzZSB0aGlzIGZpZWxkIGZvciBzZWdtZW50XG4vLyBwcmVmZXRjaGVzLCB3aGljaCBhbHNvIG5lZWQgdG8gc3BlY2lmeSBhIHBhcnRpY3VsYXIgc2VnbWVudC5cbmV4cG9ydCBjb25zdCBORVhUX1JPVVRFUl9TVEFURV9UUkVFX0hFQURFUiA9ICdOZXh0LVJvdXRlci1TdGF0ZS1UcmVlJyBhcyBjb25zdFxuZXhwb3J0IGNvbnN0IE5FWFRfUk9VVEVSX1BSRUZFVENIX0hFQURFUiA9ICdOZXh0LVJvdXRlci1QcmVmZXRjaCcgYXMgY29uc3Rcbi8vIFRoaXMgY29udGFpbnMgdGhlIHBhdGggdG8gdGhlIHNlZ21lbnQgYmVpbmcgcHJlZmV0Y2hlZC5cbi8vIFRPRE86IElmIHdlIGNoYW5nZSBOZXh0LVJvdXRlci1TdGF0ZS1UcmVlIHRvIGJlIGEgc2VnbWVudCBwYXRoLCB3ZSBjYW4gdXNlXG4vLyB0aGF0IGluc3RlYWQuIFRoZW4gTmV4dC1Sb3V0ZXItUHJlZmV0Y2ggYW5kIE5leHQtUm91dGVyLVNlZ21lbnQtUHJlZmV0Y2ggY2FuXG4vLyBiZSBtZXJnZWQgaW50byBhIHNpbmdsZSBlbnVtLlxuZXhwb3J0IGNvbnN0IE5FWFRfUk9VVEVSX1NFR01FTlRfUFJFRkVUQ0hfSEVBREVSID1cbiAgJ05leHQtUm91dGVyLVNlZ21lbnQtUHJlZmV0Y2gnIGFzIGNvbnN0XG5leHBvcnQgY29uc3QgTkVYVF9ITVJfUkVGUkVTSF9IRUFERVIgPSAnTmV4dC1ITVItUmVmcmVzaCcgYXMgY29uc3RcbmV4cG9ydCBjb25zdCBORVhUX0hNUl9SRUZSRVNIX0hBU0hfQ09PS0lFID0gJ19fbmV4dF9obXJfcmVmcmVzaF9oYXNoX18nIGFzIGNvbnN0XG5leHBvcnQgY29uc3QgTkVYVF9VUkwgPSAnTmV4dC1VcmwnIGFzIGNvbnN0XG5leHBvcnQgY29uc3QgUlNDX0NPTlRFTlRfVFlQRV9IRUFERVIgPSAndGV4dC94LWNvbXBvbmVudCcgYXMgY29uc3RcblxuZXhwb3J0IGNvbnN0IEZMSUdIVF9IRUFERVJTID0gW1xuICBSU0NfSEVBREVSLFxuICBORVhUX1JPVVRFUl9TVEFURV9UUkVFX0hFQURFUixcbiAgTkVYVF9ST1VURVJfUFJFRkVUQ0hfSEVBREVSLFxuICBORVhUX0hNUl9SRUZSRVNIX0hFQURFUixcbiAgTkVYVF9ST1VURVJfU0VHTUVOVF9QUkVGRVRDSF9IRUFERVIsXG5dIGFzIGNvbnN0XG5cbmV4cG9ydCBjb25zdCBORVhUX1JTQ19VTklPTl9RVUVSWSA9ICdfcnNjJyBhcyBjb25zdFxuXG5leHBvcnQgY29uc3QgTkVYVF9ST1VURVJfU1RBTEVfVElNRV9IRUFERVIgPSAneC1uZXh0anMtc3RhbGUtdGltZScgYXMgY29uc3RcbmV4cG9ydCBjb25zdCBORVhUX0RJRF9QT1NUUE9ORV9IRUFERVIgPSAneC1uZXh0anMtcG9zdHBvbmVkJyBhcyBjb25zdFxuZXhwb3J0IGNvbnN0IE5FWFRfUkVXUklUVEVOX1BBVEhfSEVBREVSID0gJ3gtbmV4dGpzLXJld3JpdHRlbi1wYXRoJyBhcyBjb25zdFxuZXhwb3J0IGNvbnN0IE5FWFRfUkVXUklUVEVOX1FVRVJZX0hFQURFUiA9ICd4LW5leHRqcy1yZXdyaXR0ZW4tcXVlcnknIGFzIGNvbnN0XG5leHBvcnQgY29uc3QgTkVYVF9JU19QUkVSRU5ERVJfSEVBREVSID0gJ3gtbmV4dGpzLXByZXJlbmRlcicgYXMgY29uc3RcbmV4cG9ydCBjb25zdCBORVhUX0FDVElPTl9OT1RfRk9VTkRfSEVBREVSID0gJ3gtbmV4dGpzLWFjdGlvbi1ub3QtZm91bmQnIGFzIGNvbnN0XG4iXSwibmFtZXMiOlsiQUNUSU9OX0hFQURFUiIsIkZMSUdIVF9IRUFERVJTIiwiTkVYVF9BQ1RJT05fTk9UX0ZPVU5EX0hFQURFUiIsIk5FWFRfRElEX1BPU1RQT05FX0hFQURFUiIsIk5FWFRfSE1SX1JFRlJFU0hfSEFTSF9DT09LSUUiLCJORVhUX0hNUl9SRUZSRVNIX0hFQURFUiIsIk5FWFRfSVNfUFJFUkVOREVSX0hFQURFUiIsIk5FWFRfUkVXUklUVEVOX1BBVEhfSEVBREVSIiwiTkVYVF9SRVdSSVRURU5fUVVFUllfSEVBREVSIiwiTkVYVF9ST1VURVJfUFJFRkVUQ0hfSEVBREVSIiwiTkVYVF9ST1VURVJfU0VHTUVOVF9QUkVGRVRDSF9IRUFERVIiLCJORVhUX1JPVVRFUl9TVEFMRV9USU1FX0hFQURFUiIsIk5FWFRfUk9VVEVSX1NUQVRFX1RSRUVfSEVBREVSIiwiTkVYVF9SU0NfVU5JT05fUVVFUlkiLCJORVhUX1VSTCIsIlJTQ19DT05URU5UX1RZUEVfSEVBREVSIiwiUlNDX0hFQURFUiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFDYUEsYUFBYSxFQUFBO2VBQWJBOztJQWlCQUMsY0FBYyxFQUFBO2VBQWRBOztJQWVBQyw0QkFBNEIsRUFBQTtlQUE1QkE7O0lBSkFDLHdCQUF3QixFQUFBO2VBQXhCQTs7SUFmQUMsNEJBQTRCLEVBQUE7ZUFBNUJBOztJQURBQyx1QkFBdUIsRUFBQTtlQUF2QkE7O0lBbUJBQyx3QkFBd0IsRUFBQTtlQUF4QkE7O0lBRkFDLDBCQUEwQixFQUFBO2VBQTFCQTs7SUFDQUMsMkJBQTJCLEVBQUE7ZUFBM0JBOztJQXpCQUMsMkJBQTJCLEVBQUE7ZUFBM0JBOztJQUtBQyxtQ0FBbUMsRUFBQTtlQUFuQ0E7O0lBaUJBQyw2QkFBNkIsRUFBQTtlQUE3QkE7O0lBdkJBQyw2QkFBNkIsRUFBQTtlQUE3QkE7O0lBcUJBQyxvQkFBb0IsRUFBQTtlQUFwQkE7O0lBWEFDLFFBQVEsRUFBQTtlQUFSQTs7SUFDQUMsdUJBQXVCLEVBQUE7ZUFBdkJBOztJQWhCQUMsVUFBVSxFQUFBO2VBQVZBOzs7QUFBTixNQUFNQSxhQUFhO0FBQ25CLE1BQU1oQixnQkFBZ0I7QUFJdEIsTUFBTVksZ0NBQWdDO0FBQ3RDLE1BQU1ILDhCQUE4QjtBQUtwQyxNQUFNQyxzQ0FDWDtBQUNLLE1BQU1MLDBCQUEwQjtBQUNoQyxNQUFNRCwrQkFBK0I7QUFDckMsTUFBTVUsV0FBVztBQUNqQixNQUFNQywwQkFBMEI7QUFFaEMsTUFBTWQsaUJBQWlCO0lBQzVCZTtJQUNBSjtJQUNBSDtJQUNBSjtJQUNBSztDQUNEO0FBRU0sTUFBTUcsdUJBQXVCO0FBRTdCLE1BQU1GLGdDQUFnQztBQUN0QyxNQUFNUiwyQkFBMkI7QUFDakMsTUFBTUksNkJBQTZCO0FBQ25DLE1BQU1DLDhCQUE4QjtBQUNwQyxNQUFNRiwyQkFBMkI7QUFDakMsTUFBTUosK0JBQStCIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDkwNiwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9zaGFyZWQvbGliL2lzLXRoZW5hYmxlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ2hlY2sgdG8gc2VlIGlmIGEgdmFsdWUgaXMgVGhlbmFibGUuXG4gKlxuICogQHBhcmFtIHByb21pc2UgdGhlIG1heWJlLXRoZW5hYmxlIHZhbHVlXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZSBpcyB0aGVuYWJsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNUaGVuYWJsZTxUID0gdW5rbm93bj4oXG4gIHByb21pc2U6IFByb21pc2U8VD4gfCBUXG4pOiBwcm9taXNlIGlzIFByb21pc2U8VD4ge1xuICByZXR1cm4gKFxuICAgIHByb21pc2UgIT09IG51bGwgJiZcbiAgICB0eXBlb2YgcHJvbWlzZSA9PT0gJ29iamVjdCcgJiZcbiAgICAndGhlbicgaW4gcHJvbWlzZSAmJlxuICAgIHR5cGVvZiBwcm9taXNlLnRoZW4gPT09ICdmdW5jdGlvbidcbiAgKVxufVxuIl0sIm5hbWVzIjpbImlzVGhlbmFibGUiLCJwcm9taXNlIiwidGhlbiJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7O0NBS0M7OzsrQkFDZUEsY0FBQUE7OztlQUFBQTs7O0FBQVQsU0FBU0EsV0FDZEMsT0FBdUI7SUFFdkIsT0FDRUEsWUFBWSxRQUNaLE9BQU9BLFlBQVksWUFDbkIsVUFBVUEsV0FDVixPQUFPQSxRQUFRQyxJQUFJLEtBQUs7QUFFNUIiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogOTI5LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL25leHQtZGV2dG9vbHMvdXNlcnNwYWNlL3VzZS1hcHAtZGV2LXJlbmRlcmluZy1pbmRpY2F0b3IudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVRyYW5zaXRpb24gfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IGRpc3BhdGNoZXIgfSBmcm9tICduZXh0L2Rpc3QvY29tcGlsZWQvbmV4dC1kZXZ0b29scydcblxuZXhwb3J0IGNvbnN0IHVzZUFwcERldlJlbmRlcmluZ0luZGljYXRvciA9ICgpID0+IHtcbiAgY29uc3QgW2lzUGVuZGluZywgc3RhcnRUcmFuc2l0aW9uXSA9IHVzZVRyYW5zaXRpb24oKVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGlzUGVuZGluZykge1xuICAgICAgZGlzcGF0Y2hlci5yZW5kZXJpbmdJbmRpY2F0b3JTaG93KClcbiAgICB9IGVsc2Uge1xuICAgICAgZGlzcGF0Y2hlci5yZW5kZXJpbmdJbmRpY2F0b3JIaWRlKClcbiAgICB9XG4gIH0sIFtpc1BlbmRpbmddKVxuXG4gIHJldHVybiBzdGFydFRyYW5zaXRpb25cbn1cbiJdLCJuYW1lcyI6WyJ1c2VBcHBEZXZSZW5kZXJpbmdJbmRpY2F0b3IiLCJpc1BlbmRpbmciLCJzdGFydFRyYW5zaXRpb24iLCJ1c2VUcmFuc2l0aW9uIiwidXNlRWZmZWN0IiwiZGlzcGF0Y2hlciIsInJlbmRlcmluZ0luZGljYXRvclNob3ciLCJyZW5kZXJpbmdJbmRpY2F0b3JIaWRlIl0sIm1hcHBpbmdzIjoiOzs7K0JBS2FBLCtCQUFBQTs7O2VBQUFBOzs7dUJBSDRCOzhCQUNkO0FBRXBCLE1BQU1BLDhCQUE4QjtJQUN6QyxNQUFNLENBQUNDLFdBQVdDLGdCQUFnQixHQUFHQyxDQUFBQSxHQUFBQSxPQUFBQSxhQUFhO0lBRWxEQyxDQUFBQSxHQUFBQSxPQUFBQSxTQUFTLEVBQUM7UUFDUixJQUFJSCxXQUFXO1lBQ2JJLGNBQUFBLFVBQVUsQ0FBQ0Msc0JBQXNCO1FBQ25DLE9BQU87WUFDTEQsY0FBQUEsVUFBVSxDQUFDRSxzQkFBc0I7UUFDbkM7SUFDRixHQUFHO1FBQUNOO0tBQVU7SUFFZCxPQUFPQztBQUNUIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDk2NiwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvY29tcG9uZW50cy91c2UtYWN0aW9uLXF1ZXVlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgRGlzcGF0Y2ggfSBmcm9tICdyZWFjdCdcbmltcG9ydCBSZWFjdCwgeyB1c2UgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IGlzVGhlbmFibGUgfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL2lzLXRoZW5hYmxlJ1xuaW1wb3J0IHR5cGUgeyBBcHBSb3V0ZXJBY3Rpb25RdWV1ZSB9IGZyb20gJy4vYXBwLXJvdXRlci1pbnN0YW5jZSdcbmltcG9ydCB0eXBlIHtcbiAgQXBwUm91dGVyU3RhdGUsXG4gIFJlZHVjZXJBY3Rpb25zLFxuICBSZWR1Y2VyU3RhdGUsXG59IGZyb20gJy4vcm91dGVyLXJlZHVjZXIvcm91dGVyLXJlZHVjZXItdHlwZXMnXG5cbi8vIFRoZSBhcHAgcm91dGVyIHN0YXRlIGxpdmVzIG91dHNpZGUgb2YgUmVhY3QsIHNvIHdlIGNhbiBpbXBvcnQgdGhlIGRpc3BhdGNoXG4vLyBtZXRob2QgZGlyZWN0bHkgd2hlcmV2ZXIgd2UgbmVlZCBpdCwgcmF0aGVyIHRoYW4gcGFzc2luZyBpdCBhcm91bmQgdmlhIHByb3BzXG4vLyBvciBjb250ZXh0LlxubGV0IGRpc3BhdGNoOiBEaXNwYXRjaDxSZWR1Y2VyQWN0aW9ucz4gfCBudWxsID0gbnVsbFxuXG5leHBvcnQgZnVuY3Rpb24gZGlzcGF0Y2hBcHBSb3V0ZXJBY3Rpb24oYWN0aW9uOiBSZWR1Y2VyQWN0aW9ucykge1xuICBpZiAoZGlzcGF0Y2ggPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnSW50ZXJuYWwgTmV4dC5qcyBlcnJvcjogUm91dGVyIGFjdGlvbiBkaXNwYXRjaGVkIGJlZm9yZSBpbml0aWFsaXphdGlvbi4nXG4gICAgKVxuICB9XG4gIGRpc3BhdGNoKGFjdGlvbilcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUFjdGlvblF1ZXVlKFxuICBhY3Rpb25RdWV1ZTogQXBwUm91dGVyQWN0aW9uUXVldWVcbik6IEFwcFJvdXRlclN0YXRlIHtcbiAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSBSZWFjdC51c2VTdGF0ZTxSZWR1Y2VyU3RhdGU+KGFjdGlvblF1ZXVlLnN0YXRlKVxuXG4gIC8vIEJlY2F1c2Ugb2YgYSBrbm93biBpc3N1ZSB0aGF0IHJlcXVpcmVzIHRvIGRlY29kZSBGbGlnaHQgc3RyZWFtcyBpbnNpZGUgdGhlXG4gIC8vIHJlbmRlciBwaGFzZSwgd2UgaGF2ZSB0byBiZSBhIGJpdCBjbGV2ZXIgYW5kIGFzc2lnbiB0aGUgZGlzcGF0Y2ggbWV0aG9kIHRvXG4gIC8vIGEgbW9kdWxlLWxldmVsIHZhcmlhYmxlIHVwb24gaW5pdGlhbGl6YXRpb24uIFRoZSB1c2VTdGF0ZSBob29rIGluIHRoaXNcbiAgLy8gbW9kdWxlIG9ubHkgZXhpc3RzIHRvIHN5bmNocm9uaXplIHN0YXRlIHRoYXQgbGl2ZXMgb3V0c2lkZSBvZiBSZWFjdC5cbiAgLy8gSWRlYWxseSwgd2hhdCB3ZSdkIGRvIGluc3RlYWQgaXMgcGFzcyB0aGUgc3RhdGUgYXMgYSBwcm9wIHRvIHJvb3QucmVuZGVyO1xuICAvLyB0aGlzIGlzIGNvbmNlcHR1YWxseSBob3cgd2UncmUgbW9kZWxpbmcgdGhlIGFwcCByb3V0ZXIgc3RhdGUsIGRlc3BpdGUgdGhlXG4gIC8vIHdlaXJkIGltcGxlbWVudGF0aW9uIGRldGFpbHMuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY29uc3QgeyB1c2VBcHBEZXZSZW5kZXJpbmdJbmRpY2F0b3IgfSA9XG4gICAgICByZXF1aXJlKCcuLi8uLi9uZXh0LWRldnRvb2xzL3VzZXJzcGFjZS91c2UtYXBwLWRldi1yZW5kZXJpbmctaW5kaWNhdG9yJykgYXMgdHlwZW9mIGltcG9ydCgnLi4vLi4vbmV4dC1kZXZ0b29scy91c2Vyc3BhY2UvdXNlLWFwcC1kZXYtcmVuZGVyaW5nLWluZGljYXRvcicpXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgY29uc3QgYXBwRGV2UmVuZGVyaW5nSW5kaWNhdG9yID0gdXNlQXBwRGV2UmVuZGVyaW5nSW5kaWNhdG9yKClcblxuICAgIGRpc3BhdGNoID0gKGFjdGlvbjogUmVkdWNlckFjdGlvbnMpID0+IHtcbiAgICAgIGFwcERldlJlbmRlcmluZ0luZGljYXRvcigoKSA9PiB7XG4gICAgICAgIGFjdGlvblF1ZXVlLmRpc3BhdGNoKGFjdGlvbiwgc2V0U3RhdGUpXG4gICAgICB9KVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBkaXNwYXRjaCA9IChhY3Rpb246IFJlZHVjZXJBY3Rpb25zKSA9PlxuICAgICAgYWN0aW9uUXVldWUuZGlzcGF0Y2goYWN0aW9uLCBzZXRTdGF0ZSlcbiAgfVxuXG4gIHJldHVybiBpc1RoZW5hYmxlKHN0YXRlKSA/IHVzZShzdGF0ZSkgOiBzdGF0ZVxufVxuIl0sIm5hbWVzIjpbImRpc3BhdGNoQXBwUm91dGVyQWN0aW9uIiwidXNlQWN0aW9uUXVldWUiLCJkaXNwYXRjaCIsImFjdGlvbiIsIkVycm9yIiwiYWN0aW9uUXVldWUiLCJzdGF0ZSIsInNldFN0YXRlIiwiUmVhY3QiLCJ1c2VTdGF0ZSIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsInVzZUFwcERldlJlbmRlcmluZ0luZGljYXRvciIsInJlcXVpcmUiLCJhcHBEZXZSZW5kZXJpbmdJbmRpY2F0b3IiLCJpc1RoZW5hYmxlIiwidXNlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztJQWVnQkEsdUJBQXVCLEVBQUE7ZUFBdkJBOztJQVNBQyxjQUFjLEVBQUE7ZUFBZEE7Ozs7aUVBdkJXOzRCQUNBO0FBUTNCLDZFQUE2RTtBQUM3RSwrRUFBK0U7QUFDL0UsY0FBYztBQUNkLElBQUlDLFdBQTRDO0FBRXpDLFNBQVNGLHdCQUF3QkcsTUFBc0I7SUFDNUQsSUFBSUQsYUFBYSxNQUFNO1FBQ3JCLE1BQU0sT0FBQSxjQUVMLENBRkssSUFBSUUsTUFDUiw0RUFESSxxQkFBQTttQkFBQTt3QkFBQTswQkFBQTtRQUVOO0lBQ0Y7SUFDQUYsU0FBU0M7QUFDWDtBQUVPLFNBQVNGLGVBQ2RJLFdBQWlDO0lBRWpDLE1BQU0sQ0FBQ0MsT0FBT0MsU0FBUyxHQUFHQyxPQUFBQSxPQUFLLENBQUNDLFFBQVEsQ0FBZUosWUFBWUMsS0FBSztJQUV4RSw2RUFBNkU7SUFDN0UsNkVBQTZFO0lBQzdFLHlFQUF5RTtJQUN6RSx1RUFBdUU7SUFDdkUsNEVBQTRFO0lBQzVFLDRFQUE0RTtJQUM1RSxnQ0FBZ0M7SUFDaEMsSUFBSUksUUFBUUMsR0FBRyxDQUFDQyxRQUFRLEtBQUssV0FBYztRQUN6QyxNQUFNLEVBQUVDLDJCQUEyQixFQUFFLEdBQ25DQyxRQUFRO1FBQ1Ysc0RBQXNEO1FBQ3RELE1BQU1DLDJCQUEyQkY7UUFFakNYLFdBQVcsQ0FBQ0M7WUFDVlkseUJBQXlCO2dCQUN2QlYsWUFBWUgsUUFBUSxDQUFDQyxRQUFRSTtZQUMvQjtRQUNGO0lBQ0YsT0FBTzs7SUFLUCxPQUFPUyxDQUFBQSxHQUFBQSxZQUFBQSxVQUFVLEVBQUNWLFNBQVNXLENBQUFBLEdBQUFBLE9BQUFBLEdBQUcsRUFBQ1gsU0FBU0E7QUFDMUMiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTAzOSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvYXBwLWNhbGwtc2VydmVyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHN0YXJ0VHJhbnNpdGlvbiB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgQUNUSU9OX1NFUlZFUl9BQ1RJT04gfSBmcm9tICcuL2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcm91dGVyLXJlZHVjZXItdHlwZXMnXG5pbXBvcnQgeyBkaXNwYXRjaEFwcFJvdXRlckFjdGlvbiB9IGZyb20gJy4vY29tcG9uZW50cy91c2UtYWN0aW9uLXF1ZXVlJ1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2FsbFNlcnZlcihhY3Rpb25JZDogc3RyaW5nLCBhY3Rpb25BcmdzOiBhbnlbXSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHN0YXJ0VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICBkaXNwYXRjaEFwcFJvdXRlckFjdGlvbih7XG4gICAgICAgIHR5cGU6IEFDVElPTl9TRVJWRVJfQUNUSU9OLFxuICAgICAgICBhY3Rpb25JZCxcbiAgICAgICAgYWN0aW9uQXJncyxcbiAgICAgICAgcmVzb2x2ZSxcbiAgICAgICAgcmVqZWN0LFxuICAgICAgfSlcbiAgICB9KVxuICB9KVxufVxuIl0sIm5hbWVzIjpbImNhbGxTZXJ2ZXIiLCJhY3Rpb25JZCIsImFjdGlvbkFyZ3MiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInN0YXJ0VHJhbnNpdGlvbiIsImRpc3BhdGNoQXBwUm91dGVyQWN0aW9uIiwidHlwZSIsIkFDVElPTl9TRVJWRVJfQUNUSU9OIl0sIm1hcHBpbmdzIjoiOzs7K0JBSXNCQSxjQUFBQTs7O2VBQUFBOzs7dUJBSlU7b0NBQ0s7Z0NBQ0c7QUFFakMsZUFBZUEsV0FBV0MsUUFBZ0IsRUFBRUMsVUFBaUI7SUFDbEUsT0FBTyxJQUFJQyxRQUFRLENBQUNDLFNBQVNDO1FBQzNCQyxDQUFBQSxHQUFBQSxPQUFBQSxlQUFlLEVBQUM7WUFDZEMsQ0FBQUEsR0FBQUEsZ0JBQUFBLHVCQUF1QixFQUFDO2dCQUN0QkMsTUFBTUMsb0JBQUFBLG9CQUFvQjtnQkFDMUJSO2dCQUNBQztnQkFDQUU7Z0JBQ0FDO1lBQ0Y7UUFDRjtJQUNGO0FBQ0YiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTA3NywgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvYXBwLWZpbmQtc291cmNlLW1hcC11cmwudHMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgYmFzZVBhdGggPSBwcm9jZXNzLmVudi5fX05FWFRfUk9VVEVSX0JBU0VQQVRIIHx8ICcnXG5jb25zdCBwYXRobmFtZSA9IGAke2Jhc2VQYXRofS9fX25leHRqc19zb3VyY2UtbWFwYFxuXG5leHBvcnQgY29uc3QgZmluZFNvdXJjZU1hcFVSTCA9XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnXG4gICAgPyBmdW5jdGlvbiBmaW5kU291cmNlTWFwVVJMKGZpbGVuYW1lOiBzdHJpbmcpOiBzdHJpbmcgfCBudWxsIHtcbiAgICAgICAgaWYgKGZpbGVuYW1lID09PSAnJykge1xuICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgZmlsZW5hbWUuc3RhcnRzV2l0aChkb2N1bWVudC5sb2NhdGlvbi5vcmlnaW4pICYmXG4gICAgICAgICAgZmlsZW5hbWUuaW5jbHVkZXMoJy9fbmV4dC9zdGF0aWMnKVxuICAgICAgICApIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGEgcmVxdWVzdCBmb3IgYSBjbGllbnQgY2h1bmsuIFRoaXMgY2FuIG9ubHkgaGFwcGVuIHdoZW5cbiAgICAgICAgICAvLyB1c2luZyBUdXJib3BhY2suIEluIHRoaXMgY2FzZSwgc2luY2Ugd2UgY29udHJvbCBob3cgdGhvc2Ugc291cmNlXG4gICAgICAgICAgLy8gbWFwcyBhcmUgZ2VuZXJhdGVkLCB3ZSBjYW4gc2FmZWx5IGFzc3VtZSB0aGF0IHRoZSBzb3VyY2VNYXBwaW5nVVJMXG4gICAgICAgICAgLy8gaXMgcmVsYXRpdmUgdG8gdGhlIGZpbGVuYW1lLCB3aXRoIGFuIGFkZGVkIGAubWFwYCBleHRlbnNpb24uIFRoZVxuICAgICAgICAgIC8vIGJyb3dzZXIgY2FuIGp1c3QgcmVxdWVzdCB0aGlzIGZpbGUsIGFuZCBpdCBnZXRzIHNlcnZlZCB0aHJvdWdoIHRoZVxuICAgICAgICAgIC8vIG5vcm1hbCBkZXYgc2VydmVyLCB3aXRob3V0IHRoZSBuZWVkIHRvIHJvdXRlIHRoaXMgdGhyb3VnaFxuICAgICAgICAgIC8vIHRoZSBgL19fbmV4dGpzX3NvdXJjZS1tYXBgIGRldiBtaWRkbGV3YXJlLlxuICAgICAgICAgIHJldHVybiBgJHtmaWxlbmFtZX0ubWFwYFxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChwYXRobmFtZSwgZG9jdW1lbnQubG9jYXRpb24ub3JpZ2luKVxuICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgnZmlsZW5hbWUnLCBmaWxlbmFtZSlcblxuICAgICAgICByZXR1cm4gdXJsLmhyZWZcbiAgICAgIH1cbiAgICA6IHVuZGVmaW5lZFxuIl0sIm5hbWVzIjpbImZpbmRTb3VyY2VNYXBVUkwiLCJiYXNlUGF0aCIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfUk9VVEVSX0JBU0VQQVRIIiwicGF0aG5hbWUiLCJOT0RFX0VOViIsImZpbGVuYW1lIiwic3RhcnRzV2l0aCIsImRvY3VtZW50IiwibG9jYXRpb24iLCJvcmlnaW4iLCJpbmNsdWRlcyIsInVybCIsIlVSTCIsInNlYXJjaFBhcmFtcyIsInNldCIsImhyZWYiLCJ1bmRlZmluZWQiXSwibWFwcGluZ3MiOiI7OzsrQkFHYUEsb0JBQUFBOzs7ZUFBQUE7OztBQUhiLE1BQU1DLFdBQVdDLFFBQVFDLEdBQUcsQ0FBQ0Msc0JBQXNCLE1BQUk7QUFDdkQsTUFBTUMsV0FBWSxLQUFFSixXQUFTO0FBRXRCLE1BQU1ELG1CQUNYRSxRQUFRQyxHQUFHLENBQUNHLFFBQVEsS0FBSyxjQUNyQixTQUFTTixpQkFBaUJPLFFBQWdCO0lBQ3hDLElBQUlBLGFBQWEsSUFBSTtRQUNuQixPQUFPO0lBQ1Q7SUFFQSxJQUNFQSxTQUFTQyxVQUFVLENBQUNDLFNBQVNDLFFBQVEsQ0FBQ0MsTUFBTSxLQUM1Q0osU0FBU0ssUUFBUSxDQUFDLGtCQUNsQjtRQUNBLGtFQUFrRTtRQUNsRSxtRUFBbUU7UUFDbkUscUVBQXFFO1FBQ3JFLG1FQUFtRTtRQUNuRSxxRUFBcUU7UUFDckUsNERBQTREO1FBQzVELDZDQUE2QztRQUM3QyxPQUFRLEtBQUVMLFdBQVM7SUFDckI7SUFFQSxNQUFNTSxNQUFNLElBQUlDLElBQUlULFVBQVVJLFNBQVNDLFFBQVEsQ0FBQ0MsTUFBTTtJQUN0REUsSUFBSUUsWUFBWSxDQUFDQyxHQUFHLENBQUMsWUFBWVQ7SUFFakMsT0FBT00sSUFBSUksSUFBSTtBQUNqQixJQUNBQyIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxMTE5LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL3NoYXJlZC9saWIvc2VnbWVudC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IFNlZ21lbnQgfSBmcm9tICcuLi8uLi9zZXJ2ZXIvYXBwLXJlbmRlci90eXBlcydcblxuZXhwb3J0IGZ1bmN0aW9uIGlzR3JvdXBTZWdtZW50KHNlZ21lbnQ6IHN0cmluZykge1xuICAvLyBVc2UgYXJyYXlbMF0gZm9yIHBlcmZvcm1hbnQgcHVycG9zZVxuICByZXR1cm4gc2VnbWVudFswXSA9PT0gJygnICYmIHNlZ21lbnQuZW5kc1dpdGgoJyknKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNQYXJhbGxlbFJvdXRlU2VnbWVudChzZWdtZW50OiBzdHJpbmcpIHtcbiAgcmV0dXJuIHNlZ21lbnQuc3RhcnRzV2l0aCgnQCcpICYmIHNlZ21lbnQgIT09ICdAY2hpbGRyZW4nXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRTZWFyY2hQYXJhbXNJZlBhZ2VTZWdtZW50KFxuICBzZWdtZW50OiBTZWdtZW50LFxuICBzZWFyY2hQYXJhbXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IHN0cmluZ1tdIHwgdW5kZWZpbmVkPlxuKSB7XG4gIGNvbnN0IGlzUGFnZVNlZ21lbnQgPSBzZWdtZW50LmluY2x1ZGVzKFBBR0VfU0VHTUVOVF9LRVkpXG5cbiAgaWYgKGlzUGFnZVNlZ21lbnQpIHtcbiAgICBjb25zdCBzdHJpbmdpZmllZFF1ZXJ5ID0gSlNPTi5zdHJpbmdpZnkoc2VhcmNoUGFyYW1zKVxuICAgIHJldHVybiBzdHJpbmdpZmllZFF1ZXJ5ICE9PSAne30nXG4gICAgICA/IFBBR0VfU0VHTUVOVF9LRVkgKyAnPycgKyBzdHJpbmdpZmllZFF1ZXJ5XG4gICAgICA6IFBBR0VfU0VHTUVOVF9LRVlcbiAgfVxuXG4gIHJldHVybiBzZWdtZW50XG59XG5cbmV4cG9ydCBjb25zdCBQQUdFX1NFR01FTlRfS0VZID0gJ19fUEFHRV9fJ1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfU0VHTUVOVF9LRVkgPSAnX19ERUZBVUxUX18nXG4iXSwibmFtZXMiOlsiREVGQVVMVF9TRUdNRU5UX0tFWSIsIlBBR0VfU0VHTUVOVF9LRVkiLCJhZGRTZWFyY2hQYXJhbXNJZlBhZ2VTZWdtZW50IiwiaXNHcm91cFNlZ21lbnQiLCJpc1BhcmFsbGVsUm91dGVTZWdtZW50Iiwic2VnbWVudCIsImVuZHNXaXRoIiwic3RhcnRzV2l0aCIsInNlYXJjaFBhcmFtcyIsImlzUGFnZVNlZ21lbnQiLCJpbmNsdWRlcyIsInN0cmluZ2lmaWVkUXVlcnkiLCJKU09OIiwic3RyaW5naWZ5Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztJQTRCYUEsbUJBQW1CLEVBQUE7ZUFBbkJBOztJQURBQyxnQkFBZ0IsRUFBQTtlQUFoQkE7O0lBaEJHQyw0QkFBNEIsRUFBQTtlQUE1QkE7O0lBVEFDLGNBQWMsRUFBQTtlQUFkQTs7SUFLQUMsc0JBQXNCLEVBQUE7ZUFBdEJBOzs7QUFMVCxTQUFTRCxlQUFlRSxPQUFlO0lBQzVDLHNDQUFzQztJQUN0QyxPQUFPQSxPQUFPLENBQUMsRUFBRSxLQUFLLE9BQU9BLFFBQVFDLFFBQVEsQ0FBQztBQUNoRDtBQUVPLFNBQVNGLHVCQUF1QkMsT0FBZTtJQUNwRCxPQUFPQSxRQUFRRSxVQUFVLENBQUMsUUFBUUYsWUFBWTtBQUNoRDtBQUVPLFNBQVNILDZCQUNkRyxPQUFnQixFQUNoQkcsWUFBMkQ7SUFFM0QsTUFBTUMsZ0JBQWdCSixRQUFRSyxRQUFRLENBQUNUO0lBRXZDLElBQUlRLGVBQWU7UUFDakIsTUFBTUUsbUJBQW1CQyxLQUFLQyxTQUFTLENBQUNMO1FBQ3hDLE9BQU9HLHFCQUFxQixPQUN4QlYsbUJBQW1CLE1BQU1VLG1CQUN6QlY7SUFDTjtJQUVBLE9BQU9JO0FBQ1Q7QUFFTyxNQUFNSixtQkFBbUI7QUFDekIsTUFBTUQsc0JBQXNCIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDExNzUsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvY2xpZW50L2ZsaWdodC1kYXRhLWhlbHBlcnMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUge1xuICBDYWNoZU5vZGVTZWVkRGF0YSxcbiAgRmxpZ2h0RGF0YSxcbiAgRmxpZ2h0RGF0YVBhdGgsXG4gIEZsaWdodFJvdXRlclN0YXRlLFxuICBGbGlnaHRTZWdtZW50UGF0aCxcbiAgU2VnbWVudCxcbn0gZnJvbSAnLi4vc2VydmVyL2FwcC1yZW5kZXIvdHlwZXMnXG5pbXBvcnQgdHlwZSB7IEhlYWREYXRhIH0gZnJvbSAnLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgeyBQQUdFX1NFR01FTlRfS0VZIH0gZnJvbSAnLi4vc2hhcmVkL2xpYi9zZWdtZW50J1xuXG5leHBvcnQgdHlwZSBOb3JtYWxpemVkRmxpZ2h0RGF0YSA9IHtcbiAgLyoqXG4gICAqIFRoZSBmdWxsIGBGbGlnaHRTZWdtZW50UGF0aGAgaW5jbHVzaXZlIG9mIHRoZSBmaW5hbCBgU2VnbWVudGBcbiAgICovXG4gIHNlZ21lbnRQYXRoOiBGbGlnaHRTZWdtZW50UGF0aFxuICAvKipcbiAgICogVGhlIGBGbGlnaHRTZWdtZW50UGF0aGAgZXhjbHVzaXZlIG9mIHRoZSBmaW5hbCBgU2VnbWVudGBcbiAgICovXG4gIHBhdGhUb1NlZ21lbnQ6IEZsaWdodFNlZ21lbnRQYXRoXG4gIHNlZ21lbnQ6IFNlZ21lbnRcbiAgdHJlZTogRmxpZ2h0Um91dGVyU3RhdGVcbiAgc2VlZERhdGE6IENhY2hlTm9kZVNlZWREYXRhIHwgbnVsbFxuICBoZWFkOiBIZWFkRGF0YVxuICBpc0hlYWRQYXJ0aWFsOiBib29sZWFuXG4gIGlzUm9vdFJlbmRlcjogYm9vbGVhblxufVxuXG4vLyBUT0RPOiBXZSBzaG91bGQgb25seSBoYXZlIHRvIGV4cG9ydCBgbm9ybWFsaXplRmxpZ2h0RGF0YWAsIGhvd2V2ZXIgYmVjYXVzZSB0aGUgaW5pdGlhbCBmbGlnaHQgZGF0YVxuLy8gdGhhdCBnZXRzIHBhc3NlZCB0byBgY3JlYXRlSW5pdGlhbFJvdXRlclN0YXRlYCBkb2Vzbid0IGNvbmZvcm0gdG8gdGhlIGBGbGlnaHREYXRhUGF0aGAgdHlwZSAoaXQncyBtaXNzaW5nIHRoZSByb290IHNlZ21lbnQpXG4vLyB3ZSdyZSBjdXJyZW50bHkgZXhwb3J0aW5nIGl0IHNvIHdlIGNhbiB1c2UgaXQgZGlyZWN0bHkuIFRoaXMgc2hvdWxkIGJlIGZpeGVkIGFzIHBhcnQgb2YgdGhlIHVuaWZpY2F0aW9uIG9mXG4vLyB0aGUgZGlmZmVyZW50IHdheXMgd2UgZXhwcmVzcyBgRmxpZ2h0U2VnbWVudFBhdGhgLlxuZXhwb3J0IGZ1bmN0aW9uIGdldEZsaWdodERhdGFQYXJ0c0Zyb21QYXRoKFxuICBmbGlnaHREYXRhUGF0aDogRmxpZ2h0RGF0YVBhdGhcbik6IE5vcm1hbGl6ZWRGbGlnaHREYXRhIHtcbiAgLy8gUGljayB0aGUgbGFzdCA0IGl0ZW1zIGZyb20gdGhlIGBGbGlnaHREYXRhUGF0aGAgdG8gZ2V0IHRoZSBbdHJlZSwgc2VlZERhdGEsIHZpZXdwb3J0LCBpc0hlYWRQYXJ0aWFsXS5cbiAgY29uc3QgZmxpZ2h0RGF0YVBhdGhMZW5ndGggPSA0XG4gIC8vIHRyZWUsIHNlZWREYXRhLCBhbmQgaGVhZCBhcmUgKmFsd2F5cyogdGhlIGxhc3QgdGhyZWUgaXRlbXMgaW4gdGhlIGBGbGlnaHREYXRhUGF0aGAuXG4gIGNvbnN0IFt0cmVlLCBzZWVkRGF0YSwgaGVhZCwgaXNIZWFkUGFydGlhbF0gPVxuICAgIGZsaWdodERhdGFQYXRoLnNsaWNlKC1mbGlnaHREYXRhUGF0aExlbmd0aClcbiAgLy8gVGhlIGBGbGlnaHRTZWdtZW50UGF0aGAgaXMgZXZlcnl0aGluZyBleGNlcHQgdGhlIGxhc3QgdGhyZWUgaXRlbXMuIEZvciBhIHJvb3QgcmVuZGVyLCBpdCB3b24ndCBiZSBwcmVzZW50LlxuICBjb25zdCBzZWdtZW50UGF0aCA9IGZsaWdodERhdGFQYXRoLnNsaWNlKDAsIC1mbGlnaHREYXRhUGF0aExlbmd0aClcblxuICByZXR1cm4ge1xuICAgIC8vIFRPRE86IFVuaWZ5IHRoZXNlIHR3byBzZWdtZW50IHBhdGggaGVscGVycy4gV2UgYXJlIGluY29uc2lzdGVudGx5IHB1c2hpbmcgYW4gZW1wdHkgc2VnbWVudCAoXCJcIilcbiAgICAvLyB0byB0aGUgc3RhcnQgb2YgdGhlIHNlZ21lbnQgcGF0aCBpbiBzb21lIHBsYWNlcyB3aGljaCBtYWtlcyBpdCBoYXJkIHRvIHVzZSBzb2xlbHkgdGhlIHNlZ21lbnQgcGF0aC5cbiAgICAvLyBMb29rIGZvciBcIi8vIFRPRE8tQVBQOiByZW1vdmUgJydcIiBpbiB0aGUgY29kZWJhc2UuXG4gICAgcGF0aFRvU2VnbWVudDogc2VnbWVudFBhdGguc2xpY2UoMCwgLTEpLFxuICAgIHNlZ21lbnRQYXRoLFxuICAgIC8vIGlmIHRoZSBgRmxpZ2h0RGF0YVBhdGhgIGNvcnJlc3BvbmRzIHdpdGggdGhlIHJvb3QsIHRoZXJlJ2xsIGJlIG5vIHNlZ21lbnQgcGF0aCxcbiAgICAvLyBpbiB3aGljaCBjYXNlIHdlIGRlZmF1bHQgdG8gJycuXG4gICAgc2VnbWVudDogc2VnbWVudFBhdGhbc2VnbWVudFBhdGgubGVuZ3RoIC0gMV0gPz8gJycsXG4gICAgdHJlZSxcbiAgICBzZWVkRGF0YSxcbiAgICBoZWFkLFxuICAgIGlzSGVhZFBhcnRpYWwsXG4gICAgaXNSb290UmVuZGVyOiBmbGlnaHREYXRhUGF0aC5sZW5ndGggPT09IGZsaWdodERhdGFQYXRoTGVuZ3RoLFxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXROZXh0RmxpZ2h0U2VnbWVudFBhdGgoXG4gIGZsaWdodFNlZ21lbnRQYXRoOiBGbGlnaHRTZWdtZW50UGF0aFxuKTogRmxpZ2h0U2VnbWVudFBhdGgge1xuICAvLyBTaW5jZSBgRmxpZ2h0U2VnbWVudFBhdGhgIGlzIGEgcmVwZWF0ZWQgdHVwbGUgb2YgYFNlZ21lbnRgIGFuZCBgUGFyYWxsZWxSb3V0ZUtleWAsIHdlIHNsaWNlIG9mZiB0d28gaXRlbXNcbiAgLy8gdG8gZ2V0IHRoZSBuZXh0IHNlZ21lbnQgcGF0aC5cbiAgcmV0dXJuIGZsaWdodFNlZ21lbnRQYXRoLnNsaWNlKDIpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVGbGlnaHREYXRhKFxuICBmbGlnaHREYXRhOiBGbGlnaHREYXRhXG4pOiBOb3JtYWxpemVkRmxpZ2h0RGF0YVtdIHwgc3RyaW5nIHtcbiAgLy8gRmxpZ2h0RGF0YSBjYW4gYmUgYSBzdHJpbmcgd2hlbiB0aGUgc2VydmVyIGRpZG4ndCByZXNwb25kIHdpdGggYSBwcm9wZXIgZmxpZ2h0IHJlc3BvbnNlLFxuICAvLyBvciB3aGVuIGEgcmVkaXJlY3QgaGFwcGVucywgdG8gc2lnbmFsIHRvIHRoZSBjbGllbnQgdGhhdCBpdCBuZWVkcyB0byBwZXJmb3JtIGFuIE1QQSBuYXZpZ2F0aW9uLlxuICBpZiAodHlwZW9mIGZsaWdodERhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZsaWdodERhdGFcbiAgfVxuXG4gIHJldHVybiBmbGlnaHREYXRhLm1hcChnZXRGbGlnaHREYXRhUGFydHNGcm9tUGF0aClcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gcHJlcGFyZSB0aGUgZmxpZ2h0IHJvdXRlciBzdGF0ZSBmb3IgdGhlIHJlcXVlc3QuXG4gKiBJdCByZW1vdmVzIG1hcmtlcnMgdGhhdCBhcmUgbm90IG5lZWRlZCBieSB0aGUgc2VydmVyLCBhbmQgYXJlIHB1cmVseSB1c2VkXG4gKiBmb3Igc3Rhc2hpbmcgc3RhdGUgb24gdGhlIGNsaWVudC5cbiAqIEBwYXJhbSBmbGlnaHRSb3V0ZXJTdGF0ZSAtIFRoZSBmbGlnaHQgcm91dGVyIHN0YXRlIHRvIHByZXBhcmUuXG4gKiBAcGFyYW0gaXNIbXJSZWZyZXNoIC0gV2hldGhlciB0aGlzIGlzIGFuIEhNUiByZWZyZXNoIHJlcXVlc3QuXG4gKiBAcmV0dXJucyBUaGUgcHJlcGFyZWQgZmxpZ2h0IHJvdXRlciBzdGF0ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByZXBhcmVGbGlnaHRSb3V0ZXJTdGF0ZUZvclJlcXVlc3QoXG4gIGZsaWdodFJvdXRlclN0YXRlOiBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgaXNIbXJSZWZyZXNoPzogYm9vbGVhblxuKTogc3RyaW5nIHtcbiAgLy8gSE1SIHJlcXVlc3RzIG5lZWQgdGhlIGNvbXBsZXRlLCB1bm1vZGlmaWVkIHN0YXRlIGZvciBwcm9wZXIgZnVuY3Rpb25hbGl0eVxuICBpZiAoaXNIbXJSZWZyZXNoKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShmbGlnaHRSb3V0ZXJTdGF0ZSkpXG4gIH1cblxuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KFxuICAgIEpTT04uc3RyaW5naWZ5KHN0cmlwQ2xpZW50T25seURhdGFGcm9tRmxpZ2h0Um91dGVyU3RhdGUoZmxpZ2h0Um91dGVyU3RhdGUpKVxuICApXG59XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgc3RyaXBzIGNsaWVudC1vbmx5IGRhdGEgZnJvbSBGbGlnaHRSb3V0ZXJTdGF0ZSB3aGlsZSBwcmVzZXJ2aW5nXG4gKiBzZXJ2ZXItbmVlZGVkIGluZm9ybWF0aW9uIGZvciBwcm9wZXIgcmVuZGVyaW5nIGRlY2lzaW9ucy5cbiAqL1xuZnVuY3Rpb24gc3RyaXBDbGllbnRPbmx5RGF0YUZyb21GbGlnaHRSb3V0ZXJTdGF0ZShcbiAgZmxpZ2h0Um91dGVyU3RhdGU6IEZsaWdodFJvdXRlclN0YXRlXG4pOiBGbGlnaHRSb3V0ZXJTdGF0ZSB7XG4gIGNvbnN0IFtcbiAgICBzZWdtZW50LFxuICAgIHBhcmFsbGVsUm91dGVzLFxuICAgIF91cmwsIC8vIEludGVudGlvbmFsbHkgdW51c2VkIC0gVVJMcyBhcmUgY2xpZW50LW9ubHlcbiAgICByZWZyZXNoTWFya2VyLFxuICAgIGlzUm9vdExheW91dCxcbiAgICBoYXNMb2FkaW5nQm91bmRhcnksXG4gIF0gPSBmbGlnaHRSb3V0ZXJTdGF0ZVxuXG4gIC8vIF9fUEFHRV9fIHNlZ21lbnRzIGFyZSBhbHdheXMgZmV0Y2hlZCBmcm9tIHRoZSBzZXJ2ZXIsIHNvIHRoZXJlJ3NcbiAgLy8gbm8gbmVlZCB0byBzZW5kIHRoZW0gdXBcbiAgY29uc3QgY2xlYW5lZFNlZ21lbnQgPSBzdHJpcFNlYXJjaFBhcmFtc0Zyb21QYWdlU2VnbWVudChzZWdtZW50KVxuXG4gIC8vIFJlY3Vyc2l2ZWx5IHByb2Nlc3MgcGFyYWxsZWwgcm91dGVzXG4gIGNvbnN0IGNsZWFuZWRQYXJhbGxlbFJvdXRlczogeyBba2V5OiBzdHJpbmddOiBGbGlnaHRSb3V0ZXJTdGF0ZSB9ID0ge31cbiAgZm9yIChjb25zdCBba2V5LCBjaGlsZFN0YXRlXSBvZiBPYmplY3QuZW50cmllcyhwYXJhbGxlbFJvdXRlcykpIHtcbiAgICBjbGVhbmVkUGFyYWxsZWxSb3V0ZXNba2V5XSA9XG4gICAgICBzdHJpcENsaWVudE9ubHlEYXRhRnJvbUZsaWdodFJvdXRlclN0YXRlKGNoaWxkU3RhdGUpXG4gIH1cblxuICBjb25zdCByZXN1bHQ6IEZsaWdodFJvdXRlclN0YXRlID0gW1xuICAgIGNsZWFuZWRTZWdtZW50LFxuICAgIGNsZWFuZWRQYXJhbGxlbFJvdXRlcyxcbiAgICBudWxsLCAvLyBVUkxzIG9taXR0ZWQgLSBzZXJ2ZXIgcmVjb25zdHJ1Y3RzIHBhdGhzIGZyb20gc2VnbWVudHNcbiAgICBzaG91bGRQcmVzZXJ2ZVJlZnJlc2hNYXJrZXIocmVmcmVzaE1hcmtlcikgPyByZWZyZXNoTWFya2VyIDogbnVsbCxcbiAgXVxuXG4gIC8vIEFwcGVuZCBvcHRpb25hbCBmaWVsZHMgaWYgcHJlc2VudFxuICBpZiAoaXNSb290TGF5b3V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXN1bHRbNF0gPSBpc1Jvb3RMYXlvdXRcbiAgfVxuICBpZiAoaGFzTG9hZGluZ0JvdW5kYXJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXN1bHRbNV0gPSBoYXNMb2FkaW5nQm91bmRhcnlcbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuLyoqXG4gKiBTdHJpcHMgc2VhcmNoIHBhcmFtZXRlcnMgZnJvbSBfX1BBR0VfXyBzZWdtZW50cyB0byBwcmV2ZW50IHNlbnNpdGl2ZVxuICogY2xpZW50LXNpZGUgZGF0YSBmcm9tIGJlaW5nIHNlbnQgdG8gdGhlIHNlcnZlci5cbiAqL1xuZnVuY3Rpb24gc3RyaXBTZWFyY2hQYXJhbXNGcm9tUGFnZVNlZ21lbnQoc2VnbWVudDogU2VnbWVudCk6IFNlZ21lbnQge1xuICBpZiAoXG4gICAgdHlwZW9mIHNlZ21lbnQgPT09ICdzdHJpbmcnICYmXG4gICAgc2VnbWVudC5zdGFydHNXaXRoKFBBR0VfU0VHTUVOVF9LRVkgKyAnPycpXG4gICkge1xuICAgIHJldHVybiBQQUdFX1NFR01FTlRfS0VZXG4gIH1cbiAgcmV0dXJuIHNlZ21lbnRcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHJlZnJlc2ggbWFya2VyIHNob3VsZCBiZSBzZW50IHRvIHRoZSBzZXJ2ZXJcbiAqIENsaWVudC1vbmx5IG1hcmtlcnMgbGlrZSAncmVmcmVzaCcgYXJlIHN0cmlwcGVkLCB3aGlsZSBzZXJ2ZXItbmVlZGVkIG1hcmtlcnNcbiAqIGxpa2UgJ3JlZmV0Y2gnIGFuZCAnaW5zaWRlLXNoYXJlZC1sYXlvdXQnIGFyZSBwcmVzZXJ2ZWQuXG4gKi9cbmZ1bmN0aW9uIHNob3VsZFByZXNlcnZlUmVmcmVzaE1hcmtlcihcbiAgcmVmcmVzaE1hcmtlcjogRmxpZ2h0Um91dGVyU3RhdGVbM11cbik6IGJvb2xlYW4ge1xuICByZXR1cm4gQm9vbGVhbihyZWZyZXNoTWFya2VyICYmIHJlZnJlc2hNYXJrZXIgIT09ICdyZWZyZXNoJylcbn1cbiJdLCJuYW1lcyI6WyJnZXRGbGlnaHREYXRhUGFydHNGcm9tUGF0aCIsImdldE5leHRGbGlnaHRTZWdtZW50UGF0aCIsIm5vcm1hbGl6ZUZsaWdodERhdGEiLCJwcmVwYXJlRmxpZ2h0Um91dGVyU3RhdGVGb3JSZXF1ZXN0IiwiZmxpZ2h0RGF0YVBhdGgiLCJmbGlnaHREYXRhUGF0aExlbmd0aCIsInRyZWUiLCJzZWVkRGF0YSIsImhlYWQiLCJpc0hlYWRQYXJ0aWFsIiwic2xpY2UiLCJzZWdtZW50UGF0aCIsInBhdGhUb1NlZ21lbnQiLCJzZWdtZW50IiwibGVuZ3RoIiwiaXNSb290UmVuZGVyIiwiZmxpZ2h0U2VnbWVudFBhdGgiLCJmbGlnaHREYXRhIiwibWFwIiwiZmxpZ2h0Um91dGVyU3RhdGUiLCJpc0htclJlZnJlc2giLCJlbmNvZGVVUklDb21wb25lbnQiLCJKU09OIiwic3RyaW5naWZ5Iiwic3RyaXBDbGllbnRPbmx5RGF0YUZyb21GbGlnaHRSb3V0ZXJTdGF0ZSIsInBhcmFsbGVsUm91dGVzIiwiX3VybCIsInJlZnJlc2hNYXJrZXIiLCJpc1Jvb3RMYXlvdXQiLCJoYXNMb2FkaW5nQm91bmRhcnkiLCJjbGVhbmVkU2VnbWVudCIsInN0cmlwU2VhcmNoUGFyYW1zRnJvbVBhZ2VTZWdtZW50IiwiY2xlYW5lZFBhcmFsbGVsUm91dGVzIiwia2V5IiwiY2hpbGRTdGF0ZSIsIk9iamVjdCIsImVudHJpZXMiLCJyZXN1bHQiLCJzaG91bGRQcmVzZXJ2ZVJlZnJlc2hNYXJrZXIiLCJ1bmRlZmluZWQiLCJzdGFydHNXaXRoIiwiUEFHRV9TRUdNRU5UX0tFWSIsIkJvb2xlYW4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7SUFnQ2dCQSwwQkFBMEIsRUFBQTtlQUExQkE7O0lBNEJBQyx3QkFBd0IsRUFBQTtlQUF4QkE7O0lBUUFDLG1CQUFtQixFQUFBO2VBQW5CQTs7SUFvQkFDLGtDQUFrQyxFQUFBO2VBQWxDQTs7O3lCQS9FaUI7QUF1QjFCLFNBQVNILDJCQUNkSSxjQUE4QjtJQUU5Qix3R0FBd0c7SUFDeEcsTUFBTUMsdUJBQXVCO0lBQzdCLHNGQUFzRjtJQUN0RixNQUFNLENBQUNDLE1BQU1DLFVBQVVDLE1BQU1DLGNBQWMsR0FDekNMLGVBQWVNLEtBQUssQ0FBQyxDQUFDTDtJQUN4Qiw2R0FBNkc7SUFDN0csTUFBTU0sY0FBY1AsZUFBZU0sS0FBSyxDQUFDLEdBQUcsQ0FBQ0w7UUFVbENNO0lBUlgsT0FBTztRQUNMLGtHQUFrRztRQUNsRyxzR0FBc0c7UUFDdEcscURBQXFEO1FBQ3JEQyxlQUFlRCxZQUFZRCxLQUFLLENBQUMsR0FBRyxDQUFDO1FBQ3JDQztRQUNBLGtGQUFrRjtRQUNsRixrQ0FBa0M7UUFDbENFLFNBQVNGLENBQUFBLGdCQUFBQSxXQUFXLENBQUNBLFlBQVlHLE1BQU0sR0FBRyxFQUFFLEtBQUEsT0FBbkNILGdCQUF1QztRQUNoREw7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQU0sY0FBY1gsZUFBZVUsTUFBTSxLQUFLVDtJQUMxQztBQUNGO0FBRU8sU0FBU0oseUJBQ2RlLGlCQUFvQztJQUVwQyw0R0FBNEc7SUFDNUcsZ0NBQWdDO0lBQ2hDLE9BQU9BLGtCQUFrQk4sS0FBSyxDQUFDO0FBQ2pDO0FBRU8sU0FBU1Isb0JBQ2RlLFVBQXNCO0lBRXRCLDJGQUEyRjtJQUMzRixrR0FBa0c7SUFDbEcsSUFBSSxPQUFPQSxlQUFlLFVBQVU7UUFDbEMsT0FBT0E7SUFDVDtJQUVBLE9BQU9BLFdBQVdDLEdBQUcsQ0FBQ2xCO0FBQ3hCO0FBVU8sU0FBU0csbUNBQ2RnQixpQkFBb0MsRUFDcENDLFlBQXNCO0lBRXRCLDRFQUE0RTtJQUM1RSxJQUFJQSxjQUFjO1FBQ2hCLE9BQU9DLG1CQUFtQkMsS0FBS0MsU0FBUyxDQUFDSjtJQUMzQztJQUVBLE9BQU9FLG1CQUNMQyxLQUFLQyxTQUFTLENBQUNDLHlDQUF5Q0w7QUFFNUQ7QUFFQTs7O0NBR0MsR0FDRCxTQUFTSyx5Q0FDUEwsaUJBQW9DO0lBRXBDLE1BQU0sQ0FDSk4sU0FDQVksZ0JBQ0FDLE1BQ0FDLGVBQ0FDLGNBQ0FDLG1CQUNELEdBQUdWO0lBRUosbUVBQW1FO0lBQ25FLDBCQUEwQjtJQUMxQixNQUFNVyxpQkFBaUJDLGlDQUFpQ2xCO0lBRXhELHNDQUFzQztJQUN0QyxNQUFNbUIsd0JBQThELENBQUM7SUFDckUsS0FBSyxNQUFNLENBQUNDLEtBQUtDLFdBQVcsSUFBSUMsT0FBT0MsT0FBTyxDQUFDWCxnQkFBaUI7UUFDOURPLHFCQUFxQixDQUFDQyxJQUFJLEdBQ3hCVCx5Q0FBeUNVO0lBQzdDO0lBRUEsTUFBTUcsU0FBNEI7UUFDaENQO1FBQ0FFO1FBQ0E7UUFDQU0sNEJBQTRCWCxpQkFBaUJBLGdCQUFnQjtLQUM5RDtJQUVELG9DQUFvQztJQUNwQyxJQUFJQyxpQkFBaUJXLFdBQVc7UUFDOUJGLE1BQU0sQ0FBQyxFQUFFLEdBQUdUO0lBQ2Q7SUFDQSxJQUFJQyx1QkFBdUJVLFdBQVc7UUFDcENGLE1BQU0sQ0FBQyxFQUFFLEdBQUdSO0lBQ2Q7SUFFQSxPQUFPUTtBQUNUO0FBRUE7OztDQUdDLEdBQ0QsU0FBU04saUNBQWlDbEIsT0FBZ0I7SUFDeEQsSUFDRSxPQUFPQSxZQUFZLFlBQ25CQSxRQUFRMkIsVUFBVSxDQUFDQyxTQUFBQSxnQkFBZ0IsR0FBRyxNQUN0QztRQUNBLE9BQU9BLFNBQUFBLGdCQUFnQjtJQUN6QjtJQUNBLE9BQU81QjtBQUNUO0FBRUE7Ozs7Q0FJQyxHQUNELFNBQVN5Qiw0QkFDUFgsYUFBbUM7SUFFbkMsT0FBT2UsUUFBUWYsaUJBQWlCQSxrQkFBa0I7QUFDcEQiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTMwNiwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvYXBwLWJ1aWxkLWlkLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRoaXMgZ2V0cyBhc3NpZ25lZCBhcyBhIHNpZGUtZWZmZWN0IGR1cmluZyBhcHAgaW5pdGlhbGl6YXRpb24uIEJlY2F1c2UgaXRcbi8vIHJlcHJlc2VudHMgdGhlIGJ1aWxkIHVzZWQgdG8gY3JlYXRlIHRoZSBKUyBidW5kbGUsIGl0IHNob3VsZCBuZXZlciBjaGFuZ2Vcbi8vIGFmdGVyIGJlaW5nIHNldCwgc28gd2Ugc3RvcmUgaXQgaW4gYSBnbG9iYWwgdmFyaWFibGUuXG4vL1xuLy8gV2hlbiBwZXJmb3JtaW5nIFJTQyByZXF1ZXN0cywgaWYgdGhlIGluY29taW5nIGRhdGEgaGFzIGEgZGlmZmVyZW50IGJ1aWxkIElELFxuLy8gd2UgcGVyZm9ybSBhbiBNUEEgbmF2aWdhdGlvbi9yZWZyZXNoIHRvIGxvYWQgdGhlIHVwZGF0ZWQgYnVpbGQgYW5kIGVuc3VyZVxuLy8gdGhhdCB0aGUgY2xpZW50IGFuZCBzZXJ2ZXIgaW4gc3luYy5cblxuLy8gU3RhcnRzIGFzIGFuIGVtcHR5IHN0cmluZy4gSW4gcHJhY3RpY2UsIGJlY2F1c2Ugc2V0QXBwQnVpbGRJZCBpcyBjYWxsZWRcbi8vIGR1cmluZyBpbml0aWFsaXphdGlvbiBiZWZvcmUgaHlkcmF0aW9uIHN0YXJ0cywgdGhpcyB3aWxsIGFsd2F5cyBnZXRcbi8vIHJlYXNzaWduZWQgdG8gdGhlIGFjdHVhbCBidWlsZCBJRCBiZWZvcmUgaXQncyBldmVyIG5lZWRlZCBieSBhIG5hdmlnYXRpb24uXG4vLyBJZiBmb3Igc29tZSByZWFzb25zIGl0IGRpZG4ndCwgZHVlIHRvIGEgYnVnIG9yIHJhY2UgY29uZGl0aW9uLCB0aGVuIG9uXG4vLyBuYXZpZ2F0aW9uIHRoZSBidWlsZCBjb21wYXJpc2lvbiB3b3VsZCBmYWlsIGFuZCB0cmlnZ2VyIGFuIE1QQSBuYXZpZ2F0aW9uLlxubGV0IGdsb2JhbEJ1aWxkSWQ6IHN0cmluZyA9ICcnXG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRBcHBCdWlsZElkKGJ1aWxkSWQ6IHN0cmluZykge1xuICBnbG9iYWxCdWlsZElkID0gYnVpbGRJZFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXBwQnVpbGRJZCgpOiBzdHJpbmcge1xuICByZXR1cm4gZ2xvYmFsQnVpbGRJZFxufVxuIl0sIm5hbWVzIjpbImdldEFwcEJ1aWxkSWQiLCJzZXRBcHBCdWlsZElkIiwiZ2xvYmFsQnVpbGRJZCIsImJ1aWxkSWQiXSwibWFwcGluZ3MiOiJBQUFBLDRFQUE0RTtBQUM1RSw0RUFBNEU7QUFDNUUsd0RBQXdEO0FBQ3hELEVBQUU7QUFDRiwrRUFBK0U7QUFDL0UsNEVBQTRFO0FBQzVFLHNDQUFzQztBQUV0QywwRUFBMEU7QUFDMUUsc0VBQXNFO0FBQ3RFLDZFQUE2RTtBQUM3RSx5RUFBeUU7QUFDekUsNkVBQTZFOzs7Ozs7Ozs7Ozs7Ozs7SUFPN0RBLGFBQWEsRUFBQTtlQUFiQTs7SUFKQUMsYUFBYSxFQUFBO2VBQWJBOzs7QUFGaEIsSUFBSUMsZ0JBQXdCO0FBRXJCLFNBQVNELGNBQWNFLE9BQWU7SUFDM0NELGdCQUFnQkM7QUFDbEI7QUFFTyxTQUFTSDtJQUNkLE9BQU9FO0FBQ1QiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTM1OSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9zaGFyZWQvbGliL2hhc2gudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gaHR0cDovL3d3dy5jc2UueW9ya3UuY2Evfm96L2hhc2guaHRtbFxuLy8gTW9yZSBzcGVjaWZpY2FsbHksIDMyLWJpdCBoYXNoIHZpYSBkamJ4b3Jcbi8vIChyZWY6IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2VwbGF3bGVzcy81MjgxM2IxZDhhZDlhZjUxMGQ4NT9wZXJtYWxpbmtfY29tbWVudF9pZD0zMzY3NzY1I2dpc3Rjb21tZW50LTMzNjc3NjUpXG4vLyBUaGlzIGlzIGR1ZSB0byBudW1iZXIgdHlwZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIHJ1c3QgZm9yIHR1cmJvcGFjayB0byBqcyBudW1iZXIgdHlwZXMsXG4vLyB3aGVyZSBydXN0IGRvZXMgbm90IGhhdmUgZWFzeSB3YXkgdG8gcmVwcmVlc250IGpzJ3MgNTMtYml0IGZsb2F0IG51bWJlciB0eXBlIGZvciB0aGUgbWF0Y2hpbmdcbi8vIG92ZXJmbG93IGJlaGF2aW9yLiBUaGlzIGlzIG1vcmUgYGNvcnJlY3RgIGluIHRlcm1zIG9mIGhhdmluZyBjYW5vbmljYWwgaGFzaCBhY3Jvc3MgZGlmZmVyZW50IHJ1bnRpbWUgLyBpbXBsZW1lbnRhdGlvblxuLy8gYXMgY2FuIGdhdXJhbnRlZSBkZXRlcm1pbnN0aWMgb3V0cHV0IGZyb20gMzJiaXQgaGFzaC5cbmV4cG9ydCBmdW5jdGlvbiBkamIySGFzaChzdHI6IHN0cmluZykge1xuICBsZXQgaGFzaCA9IDUzODFcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGFyID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoYXNoID0gKChoYXNoIDw8IDUpICsgaGFzaCArIGNoYXIpICYgMHhmZmZmZmZmZlxuICB9XG4gIHJldHVybiBoYXNoID4+PiAwXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoZXhIYXNoKHN0cjogc3RyaW5nKSB7XG4gIHJldHVybiBkamIySGFzaChzdHIpLnRvU3RyaW5nKDM2KS5zbGljZSgwLCA1KVxufVxuIl0sIm5hbWVzIjpbImRqYjJIYXNoIiwiaGV4SGFzaCIsInN0ciIsImhhc2giLCJpIiwibGVuZ3RoIiwiY2hhciIsImNoYXJDb2RlQXQiLCJ0b1N0cmluZyIsInNsaWNlIl0sIm1hcHBpbmdzIjoiQUFBQSx3Q0FBd0M7QUFDeEMsNENBQTRDO0FBQzVDLGlIQUFpSDtBQUNqSCx3RkFBd0Y7QUFDeEYsZ0dBQWdHO0FBQ2hHLHdIQUF3SDtBQUN4SCx3REFBd0Q7Ozs7Ozs7Ozs7Ozs7OztJQUN4Q0EsUUFBUSxFQUFBO2VBQVJBOztJQVNBQyxPQUFPLEVBQUE7ZUFBUEE7OztBQVRULFNBQVNELFNBQVNFLEdBQVc7SUFDbEMsSUFBSUMsT0FBTztJQUNYLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJRixJQUFJRyxNQUFNLEVBQUVELElBQUs7UUFDbkMsTUFBTUUsT0FBT0osSUFBSUssVUFBVSxDQUFDSDtRQUM1QkQsT0FBU0EsQ0FBQUEsUUFBUSxDQUFBLElBQUtBLE9BQU9HLE9BQVE7SUFDdkM7SUFDQSxPQUFPSCxTQUFTO0FBQ2xCO0FBRU8sU0FBU0YsUUFBUUMsR0FBVztJQUNqQyxPQUFPRixTQUFTRSxLQUFLTSxRQUFRLENBQUMsSUFBSUMsS0FBSyxDQUFDLEdBQUc7QUFDN0MiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTQwNCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9zaGFyZWQvbGliL3JvdXRlci91dGlscy9jYWNoZS1idXN0aW5nLXNlYXJjaC1wYXJhbS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBoZXhIYXNoIH0gZnJvbSAnLi4vLi4vaGFzaCdcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVDYWNoZUJ1c3RpbmdTZWFyY2hQYXJhbShcbiAgcHJlZmV0Y2hIZWFkZXI6IHN0cmluZyB8IHN0cmluZ1tdIHwgdW5kZWZpbmVkLFxuICBzZWdtZW50UHJlZmV0Y2hIZWFkZXI6IHN0cmluZyB8IHN0cmluZ1tdIHwgdW5kZWZpbmVkLFxuICBzdGF0ZVRyZWVIZWFkZXI6IHN0cmluZyB8IHN0cmluZ1tdIHwgdW5kZWZpbmVkLFxuICBuZXh0VXJsSGVhZGVyOiBzdHJpbmcgfCBzdHJpbmdbXSB8IHVuZGVmaW5lZFxuKTogc3RyaW5nIHtcbiAgaWYgKFxuICAgIHByZWZldGNoSGVhZGVyID09PSB1bmRlZmluZWQgJiZcbiAgICBzZWdtZW50UHJlZmV0Y2hIZWFkZXIgPT09IHVuZGVmaW5lZCAmJlxuICAgIHN0YXRlVHJlZUhlYWRlciA9PT0gdW5kZWZpbmVkICYmXG4gICAgbmV4dFVybEhlYWRlciA9PT0gdW5kZWZpbmVkXG4gICkge1xuICAgIHJldHVybiAnJ1xuICB9XG4gIHJldHVybiBoZXhIYXNoKFxuICAgIFtcbiAgICAgIHByZWZldGNoSGVhZGVyIHx8ICcwJyxcbiAgICAgIHNlZ21lbnRQcmVmZXRjaEhlYWRlciB8fCAnMCcsXG4gICAgICBzdGF0ZVRyZWVIZWFkZXIgfHwgJzAnLFxuICAgICAgbmV4dFVybEhlYWRlciB8fCAnMCcsXG4gICAgXS5qb2luKCcsJylcbiAgKVxufVxuIl0sIm5hbWVzIjpbImNvbXB1dGVDYWNoZUJ1c3RpbmdTZWFyY2hQYXJhbSIsInByZWZldGNoSGVhZGVyIiwic2VnbWVudFByZWZldGNoSGVhZGVyIiwic3RhdGVUcmVlSGVhZGVyIiwibmV4dFVybEhlYWRlciIsInVuZGVmaW5lZCIsImhleEhhc2giLCJqb2luIl0sIm1hcHBpbmdzIjoiOzs7K0JBRWdCQSxrQ0FBQUE7OztlQUFBQTs7O3NCQUZRO0FBRWpCLFNBQVNBLCtCQUNkQyxjQUE2QyxFQUM3Q0MscUJBQW9ELEVBQ3BEQyxlQUE4QyxFQUM5Q0MsYUFBNEM7SUFFNUMsSUFDRUgsbUJBQW1CSSxhQUNuQkgsMEJBQTBCRyxhQUMxQkYsb0JBQW9CRSxhQUNwQkQsa0JBQWtCQyxXQUNsQjtRQUNBLE9BQU87SUFDVDtJQUNBLE9BQU9DLENBQUFBLEdBQUFBLE1BQUFBLE9BQU8sRUFDWjtRQUNFTCxrQkFBa0I7UUFDbEJDLHlCQUF5QjtRQUN6QkMsbUJBQW1CO1FBQ25CQyxpQkFBaUI7S0FDbEIsQ0FBQ0csSUFBSSxDQUFDO0FBRVgiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTQzMSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9zZXQtY2FjaGUtYnVzdGluZy1zZWFyY2gtcGFyYW0udHMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbmltcG9ydCB7IGNvbXB1dGVDYWNoZUJ1c3RpbmdTZWFyY2hQYXJhbSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2NhY2hlLWJ1c3Rpbmctc2VhcmNoLXBhcmFtJ1xuaW1wb3J0IHtcbiAgTkVYVF9ST1VURVJfUFJFRkVUQ0hfSEVBREVSLFxuICBORVhUX1JPVVRFUl9TRUdNRU5UX1BSRUZFVENIX0hFQURFUixcbiAgTkVYVF9ST1VURVJfU1RBVEVfVFJFRV9IRUFERVIsXG4gIE5FWFRfVVJMLFxuICBORVhUX1JTQ19VTklPTl9RVUVSWSxcbn0gZnJvbSAnLi4vYXBwLXJvdXRlci1oZWFkZXJzJ1xuaW1wb3J0IHR5cGUgeyBSZXF1ZXN0SGVhZGVycyB9IGZyb20gJy4vZmV0Y2gtc2VydmVyLXJlc3BvbnNlJ1xuXG4vKipcbiAqIE11dGF0ZXMgdGhlIHByb3ZpZGVkIFVSTCBieSBhZGRpbmcgYSBjYWNoZS1idXN0aW5nIHNlYXJjaCBwYXJhbWV0ZXIgZm9yIENETnMgdGhhdCBkb24ndFxuICogc3VwcG9ydCBjdXN0b20gaGVhZGVycy4gVGhpcyBoZWxwcyBhdm9pZCBjYWNoaW5nIGNvbmZsaWN0cyBieSBtYWtpbmcgZWFjaCByZXF1ZXN0IHVuaXF1ZS5cbiAqXG4gKiBSYXRoZXIgdGhhbiByZWx5aW5nIG9uIHRoZSBWYXJ5IGhlYWRlciB3aGljaCBzb21lIENETnMgaWdub3JlLCB3ZSBhcHBlbmQgYSBzZWFyY2ggcGFyYW1cbiAqIHRvIGNyZWF0ZSBhIHVuaXF1ZSBVUkwgdGhhdCBmb3JjZXMgYSBmcmVzaCByZXF1ZXN0LlxuICpcbiAqIEV4YW1wbGU6XG4gKiBVUkwgYmVmb3JlOiBodHRwczovL2V4YW1wbGUuY29tL3BhdGg/cXVlcnk9MVxuICogVVJMIGFmdGVyOiBodHRwczovL2V4YW1wbGUuY29tL3BhdGg/cXVlcnk9MSZfcnNjPWFiYzEyM1xuICpcbiAqIE5vdGU6IFRoaXMgZnVuY3Rpb24gbXV0YXRlcyB0aGUgaW5wdXQgVVJMIGRpcmVjdGx5IGFuZCBkb2VzIG5vdCByZXR1cm4gYW55dGhpbmcuXG4gKlxuICogVE9ETzogU2luY2Ugd2UgbmVlZCB0byB1c2UgYSBzZWFyY2ggcGFyYW0gYW55d2F5LCB3ZSBjb3VsZCBzaW1wbGlmeSBieSByZW1vdmluZyB0aGUgY3VzdG9tXG4gKiBoZWFkZXJzIGFwcHJvYWNoIGVudGlyZWx5IGFuZCBqdXN0IHVzZSBzZWFyY2ggcGFyYW1zLlxuICovXG5leHBvcnQgY29uc3Qgc2V0Q2FjaGVCdXN0aW5nU2VhcmNoUGFyYW0gPSAoXG4gIHVybDogVVJMLFxuICBoZWFkZXJzOiBSZXF1ZXN0SGVhZGVyc1xuKTogdm9pZCA9PiB7XG4gIGNvbnN0IHVuaXF1ZUNhY2hlS2V5ID0gY29tcHV0ZUNhY2hlQnVzdGluZ1NlYXJjaFBhcmFtKFxuICAgIGhlYWRlcnNbTkVYVF9ST1VURVJfUFJFRkVUQ0hfSEVBREVSXSxcbiAgICBoZWFkZXJzW05FWFRfUk9VVEVSX1NFR01FTlRfUFJFRkVUQ0hfSEVBREVSXSxcbiAgICBoZWFkZXJzW05FWFRfUk9VVEVSX1NUQVRFX1RSRUVfSEVBREVSXSxcbiAgICBoZWFkZXJzW05FWFRfVVJMXVxuICApXG4gIHNldENhY2hlQnVzdGluZ1NlYXJjaFBhcmFtV2l0aEhhc2godXJsLCB1bmlxdWVDYWNoZUtleSlcbn1cblxuLyoqXG4gKiBTZXRzIGEgY2FjaGUtYnVzdGluZyBzZWFyY2ggcGFyYW1ldGVyIG9uIGEgVVJMIHVzaW5nIGEgcHJvdmlkZWQgaGFzaCB2YWx1ZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHBlcmZvcm1zIHRoZSBzYW1lIGxvZ2ljIGFzIGBzZXRDYWNoZUJ1c3RpbmdTZWFyY2hQYXJhbWAgYnV0IGFjY2VwdHNcbiAqIGEgcHJlLWNvbXB1dGVkIGhhc2ggaW5zdGVhZCBvZiBjb21wdXRpbmcgaXQgZnJvbSBoZWFkZXJzLlxuICpcbiAqIEV4YW1wbGU6XG4gKiBVUkwgYmVmb3JlOiBodHRwczovL2V4YW1wbGUuY29tL3BhdGg/cXVlcnk9MVxuICogaGFzaDogXCJhYmMxMjNcIlxuICogVVJMIGFmdGVyOiBodHRwczovL2V4YW1wbGUuY29tL3BhdGg/cXVlcnk9MSZfcnNjPWFiYzEyM1xuICpcbiAqIElmIHRoZSBoYXNoIGlzIG51bGwsIHdlIHdpbGwgc2V0IGBfcnNjYCBzZWFyY2ggcGFyYW0gd2l0aG91dCBhIHZhbHVlLlxuICogTGlrZSB0aGlzOiBodHRwczovL2V4YW1wbGUuY29tL3BhdGg/cXVlcnk9MSZfcnNjXG4gKlxuICogTm90ZTogVGhpcyBmdW5jdGlvbiBtdXRhdGVzIHRoZSBpbnB1dCBVUkwgZGlyZWN0bHkgYW5kIGRvZXMgbm90IHJldHVybiBhbnl0aGluZy5cbiAqL1xuZXhwb3J0IGNvbnN0IHNldENhY2hlQnVzdGluZ1NlYXJjaFBhcmFtV2l0aEhhc2ggPSAoXG4gIHVybDogVVJMLFxuICBoYXNoOiBzdHJpbmdcbik6IHZvaWQgPT4ge1xuICAvKipcbiAgICogTm90ZSB0aGF0IHdlIGludGVudGlvbmFsbHkgZG8gbm90IHVzZSBgdXJsLnNlYXJjaFBhcmFtcy5zZXRgIGhlcmU6XG4gICAqXG4gICAqIGNvbnN0IHVybCA9IG5ldyBVUkwoJ2h0dHBzOi8vZXhhbXBsZS5jb20vc2VhcmNoP3E9Y3VzdG9tJTIwc3BhY2luZycpO1xuICAgKiB1cmwuc2VhcmNoUGFyYW1zLnNldCgnX3JzYycsICdhYmMxMjMnKTtcbiAgICogY29uc29sZS5sb2codXJsLnRvU3RyaW5nKCkpOyAvLyBPdXRwdXRzOiBodHRwczovL2V4YW1wbGUuY29tL3NlYXJjaD9xPWN1c3RvbStzcGFjaW5nJl9yc2M9YWJjMTIzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBeIDwtLS0gdGhpcyBpcyBjYXVzaW5nIGNvbmZ1c2lvblxuICAgKiBUaGlzIGlzIGluIGZhY3QgaW50ZW5kZWQgYmFzZWQgb24gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNpbnRlcmZhY2UtdXJsc2VhcmNocGFyYW1zLCBidXRcbiAgICogd2Ugd2FudCB0byBwcmVzZXJ2ZSB0aGUgJTIwIGFzICUyMCBpZiB0aGF0J3Mgd2hhdCB0aGUgdXNlciBwYXNzZWQgaW4sIGhlbmNlIHRoZSBjdXN0b21cbiAgICogbG9naWMgYmVsb3cuXG4gICAqL1xuICBjb25zdCBleGlzdGluZ1NlYXJjaCA9IHVybC5zZWFyY2hcbiAgY29uc3QgcmF3UXVlcnkgPSBleGlzdGluZ1NlYXJjaC5zdGFydHNXaXRoKCc/JylcbiAgICA/IGV4aXN0aW5nU2VhcmNoLnNsaWNlKDEpXG4gICAgOiBleGlzdGluZ1NlYXJjaFxuXG4gIC8vIEFsd2F5cyByZW1vdmUgYW55IGV4aXN0aW5nIGNhY2hlIGJ1c3RpbmcgcGFyYW0gYW5kIGFkZCBhIGZyZXNoIG9uZSB0byBlbnN1cmVcbiAgLy8gd2UgaGF2ZSB0aGUgY29ycmVjdCB2YWx1ZSBiYXNlZCBvbiBjdXJyZW50IHJlcXVlc3QgaGVhZGVyc1xuICBjb25zdCBwYWlycyA9IHJhd1F1ZXJ5XG4gICAgLnNwbGl0KCcmJylcbiAgICAuZmlsdGVyKChwYWlyKSA9PiBwYWlyICYmICFwYWlyLnN0YXJ0c1dpdGgoYCR7TkVYVF9SU0NfVU5JT05fUVVFUll9PWApKVxuXG4gIGlmIChoYXNoLmxlbmd0aCA+IDApIHtcbiAgICBwYWlycy5wdXNoKGAke05FWFRfUlNDX1VOSU9OX1FVRVJZfT0ke2hhc2h9YClcbiAgfSBlbHNlIHtcbiAgICBwYWlycy5wdXNoKGAke05FWFRfUlNDX1VOSU9OX1FVRVJZfWApXG4gIH1cbiAgdXJsLnNlYXJjaCA9IHBhaXJzLmxlbmd0aCA/IGA/JHtwYWlycy5qb2luKCcmJyl9YCA6ICcnXG59XG4iXSwibmFtZXMiOlsic2V0Q2FjaGVCdXN0aW5nU2VhcmNoUGFyYW0iLCJzZXRDYWNoZUJ1c3RpbmdTZWFyY2hQYXJhbVdpdGhIYXNoIiwidXJsIiwiaGVhZGVycyIsInVuaXF1ZUNhY2hlS2V5IiwiY29tcHV0ZUNhY2hlQnVzdGluZ1NlYXJjaFBhcmFtIiwiTkVYVF9ST1VURVJfUFJFRkVUQ0hfSEVBREVSIiwiTkVYVF9ST1VURVJfU0VHTUVOVF9QUkVGRVRDSF9IRUFERVIiLCJORVhUX1JPVVRFUl9TVEFURV9UUkVFX0hFQURFUiIsIk5FWFRfVVJMIiwiaGFzaCIsImV4aXN0aW5nU2VhcmNoIiwic2VhcmNoIiwicmF3UXVlcnkiLCJzdGFydHNXaXRoIiwic2xpY2UiLCJwYWlycyIsInNwbGl0IiwiZmlsdGVyIiwicGFpciIsIk5FWFRfUlNDX1VOSU9OX1FVRVJZIiwibGVuZ3RoIiwicHVzaCIsImpvaW4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0lBNEJhQSwwQkFBMEIsRUFBQTtlQUExQkE7O0lBNkJBQyxrQ0FBa0MsRUFBQTtlQUFsQ0E7Ozt5Q0F2RGtDO2tDQU94QztBQW1CQSxNQUFNRCw2QkFBNkIsQ0FDeENFLEtBQ0FDO0lBRUEsTUFBTUMsaUJBQWlCQyxDQUFBQSxHQUFBQSx5QkFBQUEsOEJBQThCLEVBQ25ERixPQUFPLENBQUNHLGtCQUFBQSwyQkFBMkIsQ0FBQyxFQUNwQ0gsT0FBTyxDQUFDSSxrQkFBQUEsbUNBQW1DLENBQUMsRUFDNUNKLE9BQU8sQ0FBQ0ssa0JBQUFBLDZCQUE2QixDQUFDLEVBQ3RDTCxPQUFPLENBQUNNLGtCQUFBQSxRQUFRLENBQUM7SUFFbkJSLG1DQUFtQ0MsS0FBS0U7QUFDMUM7QUFrQk8sTUFBTUgscUNBQXFDLENBQ2hEQyxLQUNBUTtJQUVBOzs7Ozs7Ozs7O0dBVUMsR0FDRCxNQUFNQyxpQkFBaUJULElBQUlVLE1BQU07SUFDakMsTUFBTUMsV0FBV0YsZUFBZUcsVUFBVSxDQUFDLE9BQ3ZDSCxlQUFlSSxLQUFLLENBQUMsS0FDckJKO0lBRUosK0VBQStFO0lBQy9FLDZEQUE2RDtJQUM3RCxNQUFNSyxRQUFRSCxTQUNYSSxLQUFLLENBQUMsS0FDTkMsTUFBTSxDQUFDLENBQUNDLE9BQVNBLFFBQVEsQ0FBQ0EsS0FBS0wsVUFBVSxDQUFFLEtBQUVNLGtCQUFBQSxvQkFBb0IsR0FBQztJQUVyRSxJQUFJVixLQUFLVyxNQUFNLEdBQUcsR0FBRztRQUNuQkwsTUFBTU0sSUFBSSxDQUFJRixrQkFBQUEsb0JBQW9CLEdBQUMsTUFBR1Y7SUFDeEMsT0FBTztRQUNMTSxNQUFNTSxJQUFJLENBQUUsS0FBRUYsa0JBQUFBLG9CQUFvQjtJQUNwQztJQUNBbEIsSUFBSVUsTUFBTSxHQUFHSSxNQUFNSyxNQUFNLEdBQUksTUFBR0wsTUFBTU8sSUFBSSxDQUFDLE9BQVM7QUFDdEQiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTQ5NCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9mZXRjaC1zZXJ2ZXItcmVzcG9uc2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbi8vIFRPRE86IEV4cGxpY2l0bHkgaW1wb3J0IGZyb20gY2xpZW50LmJyb3dzZXJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tZXh0cmFuZW91cy1kZXBlbmRlbmNpZXNcbmltcG9ydCB7IGNyZWF0ZUZyb21SZWFkYWJsZVN0cmVhbSBhcyBjcmVhdGVGcm9tUmVhZGFibGVTdHJlYW1Ccm93c2VyIH0gZnJvbSAncmVhY3Qtc2VydmVyLWRvbS13ZWJwYWNrL2NsaWVudCdcblxuaW1wb3J0IHR5cGUge1xuICBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgTmF2aWdhdGlvbkZsaWdodFJlc3BvbnNlLFxufSBmcm9tICcuLi8uLi8uLi9zZXJ2ZXIvYXBwLXJlbmRlci90eXBlcydcblxuaW1wb3J0IHR5cGUgeyBORVhUX1JPVVRFUl9TRUdNRU5UX1BSRUZFVENIX0hFQURFUiB9IGZyb20gJy4uL2FwcC1yb3V0ZXItaGVhZGVycydcbmltcG9ydCB7XG4gIE5FWFRfUk9VVEVSX1BSRUZFVENIX0hFQURFUixcbiAgTkVYVF9ST1VURVJfU1RBVEVfVFJFRV9IRUFERVIsXG4gIE5FWFRfUlNDX1VOSU9OX1FVRVJZLFxuICBORVhUX1VSTCxcbiAgUlNDX0hFQURFUixcbiAgUlNDX0NPTlRFTlRfVFlQRV9IRUFERVIsXG4gIE5FWFRfSE1SX1JFRlJFU0hfSEVBREVSLFxuICBORVhUX0RJRF9QT1NUUE9ORV9IRUFERVIsXG4gIE5FWFRfUk9VVEVSX1NUQUxFX1RJTUVfSEVBREVSLFxufSBmcm9tICcuLi9hcHAtcm91dGVyLWhlYWRlcnMnXG5pbXBvcnQgeyBjYWxsU2VydmVyIH0gZnJvbSAnLi4vLi4vYXBwLWNhbGwtc2VydmVyJ1xuaW1wb3J0IHsgZmluZFNvdXJjZU1hcFVSTCB9IGZyb20gJy4uLy4uL2FwcC1maW5kLXNvdXJjZS1tYXAtdXJsJ1xuaW1wb3J0IHsgUHJlZmV0Y2hLaW5kIH0gZnJvbSAnLi9yb3V0ZXItcmVkdWNlci10eXBlcydcbmltcG9ydCB7XG4gIG5vcm1hbGl6ZUZsaWdodERhdGEsXG4gIHByZXBhcmVGbGlnaHRSb3V0ZXJTdGF0ZUZvclJlcXVlc3QsXG4gIHR5cGUgTm9ybWFsaXplZEZsaWdodERhdGEsXG59IGZyb20gJy4uLy4uL2ZsaWdodC1kYXRhLWhlbHBlcnMnXG5pbXBvcnQgeyBnZXRBcHBCdWlsZElkIH0gZnJvbSAnLi4vLi4vYXBwLWJ1aWxkLWlkJ1xuaW1wb3J0IHsgc2V0Q2FjaGVCdXN0aW5nU2VhcmNoUGFyYW0gfSBmcm9tICcuL3NldC1jYWNoZS1idXN0aW5nLXNlYXJjaC1wYXJhbSdcblxuY29uc3QgY3JlYXRlRnJvbVJlYWRhYmxlU3RyZWFtID1cbiAgY3JlYXRlRnJvbVJlYWRhYmxlU3RyZWFtQnJvd3NlciBhcyAodHlwZW9mIGltcG9ydCgncmVhY3Qtc2VydmVyLWRvbS13ZWJwYWNrL2NsaWVudC5icm93c2VyJykpWydjcmVhdGVGcm9tUmVhZGFibGVTdHJlYW0nXVxuXG5leHBvcnQgaW50ZXJmYWNlIEZldGNoU2VydmVyUmVzcG9uc2VPcHRpb25zIHtcbiAgcmVhZG9ubHkgZmxpZ2h0Um91dGVyU3RhdGU6IEZsaWdodFJvdXRlclN0YXRlXG4gIHJlYWRvbmx5IG5leHRVcmw6IHN0cmluZyB8IG51bGxcbiAgcmVhZG9ubHkgcHJlZmV0Y2hLaW5kPzogUHJlZmV0Y2hLaW5kXG4gIHJlYWRvbmx5IGlzSG1yUmVmcmVzaD86IGJvb2xlYW5cbn1cblxuZXhwb3J0IHR5cGUgRmV0Y2hTZXJ2ZXJSZXNwb25zZVJlc3VsdCA9IHtcbiAgZmxpZ2h0RGF0YTogTm9ybWFsaXplZEZsaWdodERhdGFbXSB8IHN0cmluZ1xuICBjYW5vbmljYWxVcmw6IFVSTCB8IHVuZGVmaW5lZFxuICBjb3VsZEJlSW50ZXJjZXB0ZWQ6IGJvb2xlYW5cbiAgcHJlcmVuZGVyZWQ6IGJvb2xlYW5cbiAgcG9zdHBvbmVkOiBib29sZWFuXG4gIHN0YWxlVGltZTogbnVtYmVyXG59XG5cbmV4cG9ydCB0eXBlIFJlcXVlc3RIZWFkZXJzID0ge1xuICBbUlNDX0hFQURFUl0/OiAnMSdcbiAgW05FWFRfUk9VVEVSX1NUQVRFX1RSRUVfSEVBREVSXT86IHN0cmluZ1xuICBbTkVYVF9VUkxdPzogc3RyaW5nXG4gIFtORVhUX1JPVVRFUl9QUkVGRVRDSF9IRUFERVJdPzogJzEnXG4gIFtORVhUX1JPVVRFUl9TRUdNRU5UX1BSRUZFVENIX0hFQURFUl0/OiBzdHJpbmdcbiAgJ3gtZGVwbG95bWVudC1pZCc/OiBzdHJpbmdcbiAgW05FWFRfSE1SX1JFRlJFU0hfSEVBREVSXT86ICcxJ1xuICAvLyBBIGhlYWRlciB0aGF0IGlzIG9ubHkgYWRkZWQgaW4gdGVzdCBtb2RlIHRvIGFzc2VydCBvbiBmZXRjaCBwcmlvcml0eVxuICAnTmV4dC1UZXN0LUZldGNoLVByaW9yaXR5Jz86IFJlcXVlc3RJbml0Wydwcmlvcml0eSddXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cmxUb1VybFdpdGhvdXRGbGlnaHRNYXJrZXIodXJsOiBzdHJpbmcpOiBVUkwge1xuICBjb25zdCB1cmxXaXRob3V0RmxpZ2h0UGFyYW1ldGVycyA9IG5ldyBVUkwodXJsLCBsb2NhdGlvbi5vcmlnaW4pXG4gIHVybFdpdGhvdXRGbGlnaHRQYXJhbWV0ZXJzLnNlYXJjaFBhcmFtcy5kZWxldGUoTkVYVF9SU0NfVU5JT05fUVVFUlkpXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKFxuICAgICAgcHJvY2Vzcy5lbnYuX19ORVhUX0NPTkZJR19PVVRQVVQgPT09ICdleHBvcnQnICYmXG4gICAgICB1cmxXaXRob3V0RmxpZ2h0UGFyYW1ldGVycy5wYXRobmFtZS5lbmRzV2l0aCgnLnR4dCcpXG4gICAgKSB7XG4gICAgICBjb25zdCB7IHBhdGhuYW1lIH0gPSB1cmxXaXRob3V0RmxpZ2h0UGFyYW1ldGVyc1xuICAgICAgY29uc3QgbGVuZ3RoID0gcGF0aG5hbWUuZW5kc1dpdGgoJy9pbmRleC50eHQnKSA/IDEwIDogNFxuICAgICAgLy8gU2xpY2Ugb2ZmIGAvaW5kZXgudHh0YCBvciBgLnR4dGAgZnJvbSB0aGUgZW5kIG9mIHRoZSBwYXRobmFtZVxuICAgICAgdXJsV2l0aG91dEZsaWdodFBhcmFtZXRlcnMucGF0aG5hbWUgPSBwYXRobmFtZS5zbGljZSgwLCAtbGVuZ3RoKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdXJsV2l0aG91dEZsaWdodFBhcmFtZXRlcnNcbn1cblxuZnVuY3Rpb24gZG9NcGFOYXZpZ2F0aW9uKHVybDogc3RyaW5nKTogRmV0Y2hTZXJ2ZXJSZXNwb25zZVJlc3VsdCB7XG4gIHJldHVybiB7XG4gICAgZmxpZ2h0RGF0YTogdXJsVG9VcmxXaXRob3V0RmxpZ2h0TWFya2VyKHVybCkudG9TdHJpbmcoKSxcbiAgICBjYW5vbmljYWxVcmw6IHVuZGVmaW5lZCxcbiAgICBjb3VsZEJlSW50ZXJjZXB0ZWQ6IGZhbHNlLFxuICAgIHByZXJlbmRlcmVkOiBmYWxzZSxcbiAgICBwb3N0cG9uZWQ6IGZhbHNlLFxuICAgIHN0YWxlVGltZTogLTEsXG4gIH1cbn1cblxubGV0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgLy8gQWJvcnQgYW55IGluLWZsaWdodCByZXF1ZXN0cyB3aGVuIHRoZSBwYWdlIGlzIHVubG9hZGVkLCBlLmcuIGR1ZSB0b1xuICAvLyByZWxvYWRpbmcgdGhlIHBhZ2Ugb3IgcGVyZm9ybWluZyBoYXJkIG5hdmlnYXRpb25zLiBUaGlzIGFsbG93cyB1cyB0byBpZ25vcmVcbiAgLy8gd2hhdCB3b3VsZCBvdGhlcndpc2UgYmUgYSB0aHJvd24gVHlwZUVycm9yIHdoZW4gdGhlIGJyb3dzZXIgY2FuY2VscyB0aGVcbiAgLy8gcmVxdWVzdHMuXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwYWdlaGlkZScsICgpID0+IHtcbiAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKVxuICB9KVxuXG4gIC8vIFVzZSBhIGZyZXNoIEFib3J0Q29udHJvbGxlciBpbnN0YW5jZSBvbiBwYWdlc2hvdywgZS5nLiB3aGVuIG5hdmlnYXRpbmcgYmFja1xuICAvLyBhbmQgdGhlIEphdmFTY3JpcHQgZXhlY3V0aW9uIGNvbnRleHQgaXMgcmVzdG9yZWQgYnkgdGhlIGJyb3dzZXIuXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwYWdlc2hvdycsICgpID0+IHtcbiAgICBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKClcbiAgfSlcbn1cblxuLyoqXG4gKiBGZXRjaCB0aGUgZmxpZ2h0IGRhdGEgZm9yIHRoZSBwcm92aWRlZCB1cmwuIFRha2VzIGluIHRoZSBjdXJyZW50IHJvdXRlciBzdGF0ZVxuICogdG8gZGVjaWRlIHdoYXQgdG8gcmVuZGVyIHNlcnZlci1zaWRlLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hTZXJ2ZXJSZXNwb25zZShcbiAgdXJsOiBVUkwsXG4gIG9wdGlvbnM6IEZldGNoU2VydmVyUmVzcG9uc2VPcHRpb25zXG4pOiBQcm9taXNlPEZldGNoU2VydmVyUmVzcG9uc2VSZXN1bHQ+IHtcbiAgY29uc3QgeyBmbGlnaHRSb3V0ZXJTdGF0ZSwgbmV4dFVybCwgcHJlZmV0Y2hLaW5kIH0gPSBvcHRpb25zXG5cbiAgY29uc3QgaGVhZGVyczogUmVxdWVzdEhlYWRlcnMgPSB7XG4gICAgLy8gRW5hYmxlIGZsaWdodCByZXNwb25zZVxuICAgIFtSU0NfSEVBREVSXTogJzEnLFxuICAgIC8vIFByb3ZpZGUgdGhlIGN1cnJlbnQgcm91dGVyIHN0YXRlXG4gICAgW05FWFRfUk9VVEVSX1NUQVRFX1RSRUVfSEVBREVSXTogcHJlcGFyZUZsaWdodFJvdXRlclN0YXRlRm9yUmVxdWVzdChcbiAgICAgIGZsaWdodFJvdXRlclN0YXRlLFxuICAgICAgb3B0aW9ucy5pc0htclJlZnJlc2hcbiAgICApLFxuICB9XG5cbiAgLyoqXG4gICAqIFRocmVlIGNhc2VzOlxuICAgKiAtIGBwcmVmZXRjaEtpbmRgIGlzIGB1bmRlZmluZWRgLCBpdCBtZWFucyBpdCdzIGEgbm9ybWFsIG5hdmlnYXRpb24sIHNvIHdlIHdhbnQgdG8gcHJlZmV0Y2ggdGhlIHBhZ2UgZGF0YSBmdWxseVxuICAgKiAtIGBwcmVmZXRjaEtpbmRgIGlzIGBmdWxsYCAtIHdlIHdhbnQgdG8gcHJlZmV0Y2ggdGhlIHdob2xlIHBhZ2Ugc28gc2FtZSBhcyBhYm92ZVxuICAgKiAtIGBwcmVmZXRjaEtpbmRgIGlzIGBhdXRvYCAtIGlmIHRoZSBwYWdlIGlzIGR5bmFtaWMsIHByZWZldGNoIHRoZSBwYWdlIGRhdGEgcGFydGlhbGx5LCBpZiBzdGF0aWMgcHJlZmV0Y2ggdGhlIHBhZ2UgZGF0YSBmdWxseVxuICAgKi9cbiAgaWYgKHByZWZldGNoS2luZCA9PT0gUHJlZmV0Y2hLaW5kLkFVVE8pIHtcbiAgICBoZWFkZXJzW05FWFRfUk9VVEVSX1BSRUZFVENIX0hFQURFUl0gPSAnMSdcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiBvcHRpb25zLmlzSG1yUmVmcmVzaCkge1xuICAgIGhlYWRlcnNbTkVYVF9ITVJfUkVGUkVTSF9IRUFERVJdID0gJzEnXG4gIH1cblxuICBpZiAobmV4dFVybCkge1xuICAgIGhlYWRlcnNbTkVYVF9VUkxdID0gbmV4dFVybFxuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBXaGVuIGNyZWF0aW5nIGEgXCJ0ZW1wb3JhcnlcIiBwcmVmZXRjaCAodGhlIFwib24tZGVtYW5kXCIgcHJlZmV0Y2ggdGhhdCBnZXRzIGNyZWF0ZWQgb24gbmF2aWdhdGlvbiwgaWYgb25lIGRvZXNuJ3QgZXhpc3QpXG4gICAgLy8gd2Ugc2VuZCB0aGUgcmVxdWVzdCB3aXRoIGEgXCJoaWdoXCIgcHJpb3JpdHkgYXMgaXQncyBpbiByZXNwb25zZSB0byBhIHVzZXIgaW50ZXJhY3Rpb24gdGhhdCBjb3VsZCBiZSBibG9ja2luZyBhIHRyYW5zaXRpb24uXG4gICAgLy8gT3RoZXJ3aXNlLCBhbGwgb3RoZXIgcHJlZmV0Y2hlcyBhcmUgc2VudCB3aXRoIGEgXCJsb3dcIiBwcmlvcml0eS5cbiAgICAvLyBXZSB1c2UgXCJhdXRvXCIgZm9yIGluIGFsbCBvdGhlciBjYXNlcyB0byBtYXRjaCB0aGUgZXhpc3RpbmcgZGVmYXVsdCwgYXMgdGhpcyBmdW5jdGlvbiBpcyBzaGFyZWQgb3V0c2lkZSBvZiBwcmVmZXRjaGluZy5cbiAgICBjb25zdCBmZXRjaFByaW9yaXR5ID0gcHJlZmV0Y2hLaW5kXG4gICAgICA/IHByZWZldGNoS2luZCA9PT0gUHJlZmV0Y2hLaW5kLlRFTVBPUkFSWVxuICAgICAgICA/ICdoaWdoJ1xuICAgICAgICA6ICdsb3cnXG4gICAgICA6ICdhdXRvJ1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfQ09ORklHX09VVFBVVCA9PT0gJ2V4cG9ydCcpIHtcbiAgICAgICAgLy8gSW4gXCJvdXRwdXQ6IGV4cG9ydFwiIG1vZGUsIHdlIGNhbid0IHJlbHkgb24gaGVhZGVycyB0byBkaXN0aW5ndWlzaFxuICAgICAgICAvLyBiZXR3ZWVuIEhUTUwgYW5kIFJTQyByZXF1ZXN0cy4gSW5zdGVhZCwgd2UgYXBwZW5kIGFuIGV4dHJhIHByZWZpeFxuICAgICAgICAvLyB0byB0aGUgcmVxdWVzdC5cbiAgICAgICAgdXJsID0gbmV3IFVSTCh1cmwpXG4gICAgICAgIGlmICh1cmwucGF0aG5hbWUuZW5kc1dpdGgoJy8nKSkge1xuICAgICAgICAgIHVybC5wYXRobmFtZSArPSAnaW5kZXgudHh0J1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVybC5wYXRobmFtZSArPSAnLnR4dCdcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGNyZWF0ZUZldGNoKFxuICAgICAgdXJsLFxuICAgICAgaGVhZGVycyxcbiAgICAgIGZldGNoUHJpb3JpdHksXG4gICAgICBhYm9ydENvbnRyb2xsZXIuc2lnbmFsXG4gICAgKVxuXG4gICAgY29uc3QgcmVzcG9uc2VVcmwgPSB1cmxUb1VybFdpdGhvdXRGbGlnaHRNYXJrZXIocmVzLnVybClcbiAgICBjb25zdCBjYW5vbmljYWxVcmwgPSByZXMucmVkaXJlY3RlZCA/IHJlc3BvbnNlVXJsIDogdW5kZWZpbmVkXG5cbiAgICBjb25zdCBjb250ZW50VHlwZSA9IHJlcy5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykgfHwgJydcbiAgICBjb25zdCBpbnRlcmNlcHRpb24gPSAhIXJlcy5oZWFkZXJzLmdldCgndmFyeScpPy5pbmNsdWRlcyhORVhUX1VSTClcbiAgICBjb25zdCBwb3N0cG9uZWQgPSAhIXJlcy5oZWFkZXJzLmdldChORVhUX0RJRF9QT1NUUE9ORV9IRUFERVIpXG4gICAgY29uc3Qgc3RhbGVUaW1lSGVhZGVyU2Vjb25kcyA9IHJlcy5oZWFkZXJzLmdldChcbiAgICAgIE5FWFRfUk9VVEVSX1NUQUxFX1RJTUVfSEVBREVSXG4gICAgKVxuICAgIGNvbnN0IHN0YWxlVGltZSA9XG4gICAgICBzdGFsZVRpbWVIZWFkZXJTZWNvbmRzICE9PSBudWxsXG4gICAgICAgID8gcGFyc2VJbnQoc3RhbGVUaW1lSGVhZGVyU2Vjb25kcywgMTApICogMTAwMFxuICAgICAgICA6IC0xXG4gICAgbGV0IGlzRmxpZ2h0UmVzcG9uc2UgPSBjb250ZW50VHlwZS5zdGFydHNXaXRoKFJTQ19DT05URU5UX1RZUEVfSEVBREVSKVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfQ09ORklHX09VVFBVVCA9PT0gJ2V4cG9ydCcpIHtcbiAgICAgICAgaWYgKCFpc0ZsaWdodFJlc3BvbnNlKSB7XG4gICAgICAgICAgaXNGbGlnaHRSZXNwb25zZSA9IGNvbnRlbnRUeXBlLnN0YXJ0c1dpdGgoJ3RleHQvcGxhaW4nKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgZmV0Y2ggcmV0dXJucyBzb21ldGhpbmcgZGlmZmVyZW50IHRoYW4gZmxpZ2h0IHJlc3BvbnNlIGhhbmRsZSBpdCBsaWtlIGEgbXBhIG5hdmlnYXRpb25cbiAgICAvLyBJZiB0aGUgZmV0Y2ggd2FzIG5vdCAyMDAsIHdlIGFsc28gaGFuZGxlIGl0IGxpa2UgYSBtcGEgbmF2aWdhdGlvblxuICAgIGlmICghaXNGbGlnaHRSZXNwb25zZSB8fCAhcmVzLm9rIHx8ICFyZXMuYm9keSkge1xuICAgICAgLy8gaW4gY2FzZSB0aGUgb3JpZ2luYWwgVVJMIGNhbWUgd2l0aCBhIGhhc2gsIHByZXNlcnZlIGl0IGJlZm9yZSByZWRpcmVjdGluZyB0byB0aGUgbmV3IFVSTFxuICAgICAgaWYgKHVybC5oYXNoKSB7XG4gICAgICAgIHJlc3BvbnNlVXJsLmhhc2ggPSB1cmwuaGFzaFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZG9NcGFOYXZpZ2F0aW9uKHJlc3BvbnNlVXJsLnRvU3RyaW5nKCkpXG4gICAgfVxuXG4gICAgLy8gV2UgbWF5IG5hdmlnYXRlIHRvIGEgcGFnZSB0aGF0IHJlcXVpcmVzIGEgZGlmZmVyZW50IFdlYnBhY2sgcnVudGltZS5cbiAgICAvLyBJbiBwcm9kLCBldmVyeSBwYWdlIHdpbGwgaGF2ZSB0aGUgc2FtZSBXZWJwYWNrIHJ1bnRpbWUuXG4gICAgLy8gSW4gZGV2LCB0aGUgV2VicGFjayBydW50aW1lIGlzIG1pbmltYWwgZm9yIGVhY2ggcGFnZS5cbiAgICAvLyBXZSBuZWVkIHRvIGVuc3VyZSB0aGUgV2VicGFjayBydW50aW1lIGlzIHVwZGF0ZWQgYmVmb3JlIGV4ZWN1dGluZyBjbGllbnQtc2lkZSBKUyBvZiB0aGUgbmV3IHBhZ2UuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIXByb2Nlc3MuZW52LlRVUkJPUEFDSykge1xuICAgICAgYXdhaXQgKFxuICAgICAgICByZXF1aXJlKCcuLi8uLi9kZXYvaG90LXJlbG9hZGVyL2FwcC9ob3QtcmVsb2FkZXItYXBwJykgYXMgdHlwZW9mIGltcG9ydCgnLi4vLi4vZGV2L2hvdC1yZWxvYWRlci9hcHAvaG90LXJlbG9hZGVyLWFwcCcpXG4gICAgICApLndhaXRGb3JXZWJwYWNrUnVudGltZUhvdFVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHRoZSBgZmV0Y2hgIHJlYWRhYmxlIHN0cmVhbSB0aGF0IGNhbiBiZSB1bndyYXBwZWQgYnkgYFJlYWN0LnVzZWAuXG4gICAgY29uc3QgZmxpZ2h0U3RyZWFtID0gcG9zdHBvbmVkXG4gICAgICA/IGNyZWF0ZVVuY2xvc2luZ1ByZWZldGNoU3RyZWFtKHJlcy5ib2R5KVxuICAgICAgOiByZXMuYm9keVxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgKGNyZWF0ZUZyb21OZXh0UmVhZGFibGVTdHJlYW0oXG4gICAgICBmbGlnaHRTdHJlYW1cbiAgICApIGFzIFByb21pc2U8TmF2aWdhdGlvbkZsaWdodFJlc3BvbnNlPilcblxuICAgIGlmIChnZXRBcHBCdWlsZElkKCkgIT09IHJlc3BvbnNlLmIpIHtcbiAgICAgIHJldHVybiBkb01wYU5hdmlnYXRpb24ocmVzLnVybClcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZmxpZ2h0RGF0YTogbm9ybWFsaXplRmxpZ2h0RGF0YShyZXNwb25zZS5mKSxcbiAgICAgIGNhbm9uaWNhbFVybDogY2Fub25pY2FsVXJsLFxuICAgICAgY291bGRCZUludGVyY2VwdGVkOiBpbnRlcmNlcHRpb24sXG4gICAgICBwcmVyZW5kZXJlZDogcmVzcG9uc2UuUyxcbiAgICAgIHBvc3Rwb25lZCxcbiAgICAgIHN0YWxlVGltZSxcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmICghYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBgRmFpbGVkIHRvIGZldGNoIFJTQyBwYXlsb2FkIGZvciAke3VybH0uIEZhbGxpbmcgYmFjayB0byBicm93c2VyIG5hdmlnYXRpb24uYCxcbiAgICAgICAgZXJyXG4gICAgICApXG4gICAgfVxuXG4gICAgLy8gSWYgZmV0Y2ggZmFpbHMgaGFuZGxlIGl0IGxpa2UgYSBtcGEgbmF2aWdhdGlvblxuICAgIC8vIFRPRE8tQVBQOiBBZGQgYSB0ZXN0IGZvciB0aGUgY2FzZSB3aGVyZSBhIENPUlMgcmVxdWVzdCBmYWlscywgZS5nLiBleHRlcm5hbCB1cmwgcmVkaXJlY3QgY29taW5nIGZyb20gdGhlIHJlc3BvbnNlLlxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL25leHQuanMvaXNzdWVzLzQzNjA1I2lzc3VlY29tbWVudC0xNDUxNjE3NTIxIGZvciBhIHJlcHJvZHVjdGlvbi5cbiAgICByZXR1cm4ge1xuICAgICAgZmxpZ2h0RGF0YTogdXJsLnRvU3RyaW5nKCksXG4gICAgICBjYW5vbmljYWxVcmw6IHVuZGVmaW5lZCxcbiAgICAgIGNvdWxkQmVJbnRlcmNlcHRlZDogZmFsc2UsXG4gICAgICBwcmVyZW5kZXJlZDogZmFsc2UsXG4gICAgICBwb3N0cG9uZWQ6IGZhbHNlLFxuICAgICAgc3RhbGVUaW1lOiAtMSxcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhpcyBpcyBhIHN1YnNldCBvZiB0aGUgc3RhbmRhcmQgUmVzcG9uc2UgdHlwZS4gV2UgdXNlIGEgY3VzdG9tIHR5cGUgZm9yXG4vLyB0aGlzIHNvIHdlIGNhbiBsaW1pdCB3aGljaCBkZXRhaWxzIGFib3V0IHRoZSByZXNwb25zZSBsZWFrIGludG8gdGhlIHJlc3Qgb2Zcbi8vIHRoZSBjb2RlYmFzZS4gRm9yIGV4YW1wbGUsIHRoZXJlJ3Mgc29tZSBjdXN0b20gbG9naWMgZm9yIG1hbnVhbGx5IGZvbGxvd2luZ1xuLy8gcmVkaXJlY3RzLCBzbyBcInJlZGlyZWN0ZWRcIiBpbiB0aGlzIHR5cGUgY291bGQgYmUgYSBjb21wb3NpdGUgb2YgbXVsdGlwbGVcbi8vIGJyb3dzZXIgZmV0Y2ggY2FsbHM7IGhvd2V2ZXIsIHRoaXMgZmFjdCBzaG91bGQgbm90IGxlYWsgdG8gdGhlIGNhbGxlci5cbmV4cG9ydCB0eXBlIFJTQ1Jlc3BvbnNlID0ge1xuICBvazogYm9vbGVhblxuICByZWRpcmVjdGVkOiBib29sZWFuXG4gIGhlYWRlcnM6IEhlYWRlcnNcbiAgYm9keTogUmVhZGFibGVTdHJlYW08VWludDhBcnJheT4gfCBudWxsXG4gIHN0YXR1czogbnVtYmVyXG4gIHVybDogc3RyaW5nXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVGZXRjaChcbiAgdXJsOiBVUkwsXG4gIGhlYWRlcnM6IFJlcXVlc3RIZWFkZXJzLFxuICBmZXRjaFByaW9yaXR5OiAnYXV0bycgfCAnaGlnaCcgfCAnbG93JyB8IG51bGwsXG4gIHNpZ25hbD86IEFib3J0U2lnbmFsXG4pOiBQcm9taXNlPFJTQ1Jlc3BvbnNlPiB7XG4gIC8vIFRPRE86IEluIG91dHB1dDogXCJleHBvcnRcIiBtb2RlLCB0aGUgaGVhZGVycyBkbyBub3RoaW5nLiBPbWl0IHRoZW0gKGFuZCB0aGVcbiAgLy8gY2FjaGUgYnVzdGluZyBzZWFyY2ggcGFyYW0pIGZyb20gdGhlIHJlcXVlc3Qgc28gdGhleSdyZVxuICAvLyBtYXhpbWFsbHkgY2FjaGVhYmxlLlxuXG4gIGlmIChwcm9jZXNzLmVudi5fX05FWFRfVEVTVF9NT0RFICYmIGZldGNoUHJpb3JpdHkgIT09IG51bGwpIHtcbiAgICBoZWFkZXJzWydOZXh0LVRlc3QtRmV0Y2gtUHJpb3JpdHknXSA9IGZldGNoUHJpb3JpdHlcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5ORVhUX0RFUExPWU1FTlRfSUQpIHtcbiAgICBoZWFkZXJzWyd4LWRlcGxveW1lbnQtaWQnXSA9IHByb2Nlc3MuZW52Lk5FWFRfREVQTE9ZTUVOVF9JRFxuICB9XG5cbiAgY29uc3QgZmV0Y2hPcHRpb25zOiBSZXF1ZXN0SW5pdCA9IHtcbiAgICAvLyBCYWNrd2FyZHMgY29tcGF0IGZvciBvbGRlciBicm93c2Vycy4gYHNhbWUtb3JpZ2luYCBpcyB0aGUgZGVmYXVsdCBpbiBtb2Rlcm4gYnJvd3NlcnMuXG4gICAgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbicsXG4gICAgaGVhZGVycyxcbiAgICBwcmlvcml0eTogZmV0Y2hQcmlvcml0eSB8fCB1bmRlZmluZWQsXG4gICAgc2lnbmFsLFxuICB9XG4gIC8vIGBmZXRjaFVybGAgaXMgc2xpZ2h0bHkgZGlmZmVyZW50IGZyb20gYHVybGAgYmVjYXVzZSB3ZSBhZGQgYSBjYWNoZS1idXN0aW5nXG4gIC8vIHNlYXJjaCBwYXJhbSB0byBpdC4gVGhpcyBzaG91bGQgbm90IGxlYWsgb3V0c2lkZSBvZiB0aGlzIGZ1bmN0aW9uLCBzbyB3ZVxuICAvLyB0cmFjayB0aGVtIHNlcGFyYXRlbHkuXG4gIGxldCBmZXRjaFVybCA9IG5ldyBVUkwodXJsKVxuICBzZXRDYWNoZUJ1c3RpbmdTZWFyY2hQYXJhbShmZXRjaFVybCwgaGVhZGVycylcbiAgbGV0IGJyb3dzZXJSZXNwb25zZSA9IGF3YWl0IGZldGNoKGZldGNoVXJsLCBmZXRjaE9wdGlvbnMpXG5cbiAgLy8gSWYgdGhlIHNlcnZlciByZXNwb25kcyB3aXRoIGEgcmVkaXJlY3QgKGUuZy4gMzA3KSwgYW5kIHRoZSByZWRpcmVjdGVkXG4gIC8vIGxvY2F0aW9uIGRvZXMgbm90IGNvbnRhaW4gdGhlIGNhY2hlIGJ1c3Rpbmcgc2VhcmNoIHBhcmFtIHNldCBpbiB0aGVcbiAgLy8gb3JpZ2luYWwgcmVxdWVzdCwgdGhlIHJlc3BvbnNlIGlzIGxpa2VseSBpbnZhbGlkIOKAlCB3aGVuIGZvbGxvd2luZyB0aGVcbiAgLy8gcmVkaXJlY3QsIHRoZSBicm93c2VyIGZvcndhcmRzIHRoZSByZXF1ZXN0IGhlYWRlcnMsIGJ1dCBzaW5jZSB0aGUgY2FjaGVcbiAgLy8gYnVzdGluZyBzZWFyY2ggcGFyYW0gaXMgbWlzc2luZywgdGhlIHNlcnZlciB3aWxsIHJlamVjdCB0aGUgcmVxdWVzdCBkdWUgdG9cbiAgLy8gYSBtaXNtYXRjaC5cbiAgLy9cbiAgLy8gSWRlYWxseSwgd2Ugd291bGQgYmUgYWJsZSB0byBpbnRlcmNlcHQgdGhlIHJlZGlyZWN0IHJlc3BvbnNlIGFuZCBwZXJmb3JtIGl0XG4gIC8vIG1hbnVhbGx5LCBpbnN0ZWFkIG9mIGxldHRpbmcgdGhlIGJyb3dzZXIgYXV0b21hdGljYWxseSBmb2xsb3cgaXQsIGJ1dCB0aGlzXG4gIC8vIGlzIG5vdCBhbGxvd2VkIGJ5IHRoZSBmZXRjaCBBUEkuXG4gIC8vXG4gIC8vIFNvIGluc3RlYWQsIHdlIG11c3QgXCJyZXBsYXlcIiB0aGUgcmVkaXJlY3QgYnkgZmV0Y2hpbmcgdGhlIG5ldyBsb2NhdGlvblxuICAvLyBhZ2FpbiwgYnV0IHRoaXMgdGltZSB3ZSdsbCBhcHBlbmQgdGhlIGNhY2hlIGJ1c3Rpbmcgc2VhcmNoIHBhcmFtIHRvIHByZXZlbnRcbiAgLy8gYSBtaXNtYXRjaC5cbiAgLy9cbiAgLy8gVE9ETzogV2UgY2FuIG9wdGltaXplIE5leHQuanMncyBidWlsdC1pbiBtaWRkbGV3YXJlIEFQSXMgYnkgcmV0dXJuaW5nIGFcbiAgLy8gY3VzdG9tIHN0YXR1cyBjb2RlLCB0byBwcmV2ZW50IHRoZSBicm93c2VyIGZyb20gYXV0b21hdGljYWxseSBmb2xsb3dpbmcgaXQuXG4gIC8vXG4gIC8vIFRoaXMgZG9lcyBub3QgYWZmZWN0IFNlcnZlciBBY3Rpb24tYmFzZWQgcmVkaXJlY3RzOyB0aG9zZSBhcmUgZW5jb2RlZFxuICAvLyBkaWZmZXJlbnRseSwgYXMgcGFydCBvZiB0aGUgRmxpZ2h0IGJvZHkuIEl0IG9ubHkgYWZmZWN0cyByZWRpcmVjdHMgdGhhdFxuICAvLyBvY2N1ciBpbiBhIG1pZGRsZXdhcmUgb3IgYSB0aGlyZC1wYXJ0eSBwcm94eS5cblxuICBsZXQgcmVkaXJlY3RlZCA9IGJyb3dzZXJSZXNwb25zZS5yZWRpcmVjdGVkXG4gIGlmIChwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1ZBTElEQVRFX1JTQ19SRVFVRVNUX0hFQURFUlMpIHtcbiAgICAvLyBUaGlzIGlzIHRvIHByZXZlbnQgYSByZWRpcmVjdCBsb29wLiBTYW1lIGxpbWl0IHVzZWQgYnkgQ2hyb21lLlxuICAgIGNvbnN0IE1BWF9SRURJUkVDVFMgPSAyMFxuICAgIGZvciAobGV0IG4gPSAwOyBuIDwgTUFYX1JFRElSRUNUUzsgbisrKSB7XG4gICAgICBpZiAoIWJyb3dzZXJSZXNwb25zZS5yZWRpcmVjdGVkKSB7XG4gICAgICAgIC8vIFRoZSBzZXJ2ZXIgZGlkIG5vdCBwZXJmb3JtIGEgcmVkaXJlY3QuXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBjb25zdCByZXNwb25zZVVybCA9IG5ldyBVUkwoYnJvd3NlclJlc3BvbnNlLnVybCwgZmV0Y2hVcmwpXG4gICAgICBpZiAocmVzcG9uc2VVcmwub3JpZ2luICE9PSBmZXRjaFVybC5vcmlnaW4pIHtcbiAgICAgICAgLy8gVGhlIHNlcnZlciByZWRpcmVjdGVkIHRvIGFuIGV4dGVybmFsIFVSTC4gVGhlIHJlc3Qgb2YgdGhlIGxvZ2ljIGJlbG93XG4gICAgICAgIC8vIGlzIG5vdCByZWxldmFudCwgYmVjYXVzZSBpdCBvbmx5IGFwcGxpZXMgdG8gaW50ZXJuYWwgcmVkaXJlY3RzLlxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgICByZXNwb25zZVVybC5zZWFyY2hQYXJhbXMuZ2V0KE5FWFRfUlNDX1VOSU9OX1FVRVJZKSA9PT1cbiAgICAgICAgZmV0Y2hVcmwuc2VhcmNoUGFyYW1zLmdldChORVhUX1JTQ19VTklPTl9RVUVSWSlcbiAgICAgICkge1xuICAgICAgICAvLyBUaGUgcmVkaXJlY3RlZCBVUkwgYWxyZWFkeSBpbmNsdWRlcyB0aGUgY2FjaGUgYnVzdGluZyBzZWFyY2ggcGFyYW0uXG4gICAgICAgIC8vIFRoaXMgd2FzIHByb2JhYmx5IGludGVudGlvbmFsLiBSZWdhcmRsZXNzLCB0aGVyZSdzIG5vIHJlYXNvbiB0b1xuICAgICAgICAvLyBpc3N1ZSBhbm90aGVyIHJlcXVlc3QgdG8gdGhpcyBVUkwgYmVjYXVzZSBpdCBhbHJlYWR5IGhhcyB0aGUgcGFyYW1cbiAgICAgICAgLy8gdmFsdWUgdGhhdCB3ZSB3b3VsZCBoYXZlIGFkZGVkIGJlbG93LlxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgLy8gVGhlIFJTQyByZXF1ZXN0IHdhcyByZWRpcmVjdGVkLiBBc3N1bWUgdGhlIHJlc3BvbnNlIGlzIGludmFsaWQuXG4gICAgICAvL1xuICAgICAgLy8gQXBwZW5kIHRoZSBjYWNoZSBidXN0aW5nIHNlYXJjaCBwYXJhbSB0byB0aGUgcmVkaXJlY3RlZCBVUkwgYW5kXG4gICAgICAvLyBmZXRjaCBhZ2Fpbi5cbiAgICAgIGZldGNoVXJsID0gbmV3IFVSTChyZXNwb25zZVVybClcbiAgICAgIHNldENhY2hlQnVzdGluZ1NlYXJjaFBhcmFtKGZldGNoVXJsLCBoZWFkZXJzKVxuICAgICAgYnJvd3NlclJlc3BvbnNlID0gYXdhaXQgZmV0Y2goZmV0Y2hVcmwsIGZldGNoT3B0aW9ucylcbiAgICAgIC8vIFdlIGp1c3QgcGVyZm9ybWVkIGEgbWFudWFsIHJlZGlyZWN0LCBzbyB0aGlzIGlzIG5vdyB0cnVlLlxuICAgICAgcmVkaXJlY3RlZCA9IHRydWVcbiAgICB9XG4gIH1cblxuICAvLyBSZW1vdmUgdGhlIGNhY2hlIGJ1c3Rpbmcgc2VhcmNoIHBhcmFtIGZyb20gdGhlIHJlc3BvbnNlIFVSTCwgdG8gcHJldmVudCBpdFxuICAvLyBmcm9tIGxlYWtpbmcgb3V0c2lkZSBvZiB0aGlzIGZ1bmN0aW9uLlxuICBjb25zdCByZXNwb25zZVVybCA9IG5ldyBVUkwoYnJvd3NlclJlc3BvbnNlLnVybCwgZmV0Y2hVcmwpXG4gIHJlc3BvbnNlVXJsLnNlYXJjaFBhcmFtcy5kZWxldGUoTkVYVF9SU0NfVU5JT05fUVVFUlkpXG5cbiAgY29uc3QgcnNjUmVzcG9uc2U6IFJTQ1Jlc3BvbnNlID0ge1xuICAgIHVybDogcmVzcG9uc2VVcmwuaHJlZixcblxuICAgIC8vIFRoaXMgaXMgdHJ1ZSBpZiBhbnkgcmVkaXJlY3RzIG9jY3VycmVkLCBlaXRoZXIgYXV0b21hdGljYWxseSBieSB0aGVcbiAgICAvLyBicm93c2VyLCBvciBtYW51YWxseSBieSB1cy4gU28gaXQncyBkaWZmZXJlbnQgZnJvbVxuICAgIC8vIGBicm93c2VyUmVzcG9uc2UucmVkaXJlY3RlZGAsIHdoaWNoIG9ubHkgdGVsbHMgdXMgd2hldGhlciB0aGUgYnJvd3NlclxuICAgIC8vIGZvbGxvd2VkIGEgcmVkaXJlY3QsIGFuZCBvbmx5IGZvciB0aGUgbGFzdCByZXNwb25zZSBpbiB0aGUgY2hhaW4uXG4gICAgcmVkaXJlY3RlZCxcblxuICAgIC8vIFRoZXNlIGNhbiBiZSBjb3BpZWQgZnJvbSB0aGUgbGFzdCBicm93c2VyIHJlc3BvbnNlIHdlIHJlY2VpdmVkLiBXZVxuICAgIC8vIGludGVudGlvbmFsbHkgb25seSBleHBvc2UgdGhlIHN1YnNldCBvZiBmaWVsZHMgdGhhdCBhcmUgYWN0dWFsbHkgdXNlZFxuICAgIC8vIGVsc2V3aGVyZSBpbiB0aGUgY29kZWJhc2UuXG4gICAgb2s6IGJyb3dzZXJSZXNwb25zZS5vayxcbiAgICBoZWFkZXJzOiBicm93c2VyUmVzcG9uc2UuaGVhZGVycyxcbiAgICBib2R5OiBicm93c2VyUmVzcG9uc2UuYm9keSxcbiAgICBzdGF0dXM6IGJyb3dzZXJSZXNwb25zZS5zdGF0dXMsXG4gIH1cblxuICByZXR1cm4gcnNjUmVzcG9uc2Vcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZyb21OZXh0UmVhZGFibGVTdHJlYW0oXG4gIGZsaWdodFN0cmVhbTogUmVhZGFibGVTdHJlYW08VWludDhBcnJheT5cbik6IFByb21pc2U8dW5rbm93bj4ge1xuICByZXR1cm4gY3JlYXRlRnJvbVJlYWRhYmxlU3RyZWFtKGZsaWdodFN0cmVhbSwge1xuICAgIGNhbGxTZXJ2ZXIsXG4gICAgZmluZFNvdXJjZU1hcFVSTCxcbiAgfSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlVW5jbG9zaW5nUHJlZmV0Y2hTdHJlYW0oXG4gIG9yaWdpbmFsRmxpZ2h0U3RyZWFtOiBSZWFkYWJsZVN0cmVhbTxVaW50OEFycmF5PlxuKTogUmVhZGFibGVTdHJlYW08VWludDhBcnJheT4ge1xuICAvLyBXaGVuIFBQUiBpcyBlbmFibGVkLCBwcmVmZXRjaCBzdHJlYW1zIG1heSBjb250YWluIHJlZmVyZW5jZXMgdGhhdCBuZXZlclxuICAvLyByZXNvbHZlLCBiZWNhdXNlIHRoYXQncyBob3cgd2UgZW5jb2RlIGR5bmFtaWMgZGF0YSBhY2Nlc3MuIEluIHRoZSBkZWNvZGVkXG4gIC8vIG9iamVjdCByZXR1cm5lZCBieSB0aGUgRmxpZ2h0IGNsaWVudCwgdGhlc2UgYXJlIHJlaWZpZWQgaW50byBoYW5naW5nXG4gIC8vIHByb21pc2VzIHRoYXQgc3VzcGVuZCBkdXJpbmcgcmVuZGVyLCB3aGljaCBpcyBlZmZlY3RpdmVseSB3aGF0IHdlIHdhbnQuXG4gIC8vIFRoZSBVSSByZXNvbHZlcyB3aGVuIGl0IHN3aXRjaGVzIHRvIHRoZSBkeW5hbWljIGRhdGEgc3RyZWFtXG4gIC8vICh2aWEgdXNlRGVmZXJyZWRWYWx1ZShkeW5hbWljLCBzdGF0aWMpKS5cbiAgLy9cbiAgLy8gSG93ZXZlciwgdGhlIEZsaWdodCBpbXBsZW1lbnRhdGlvbiBjdXJyZW50bHkgZXJyb3JzIGlmIHRoZSBzZXJ2ZXIgY2xvc2VzXG4gIC8vIHRoZSByZXNwb25zZSBiZWZvcmUgYWxsIHRoZSByZWZlcmVuY2VzIGFyZSByZXNvbHZlZC4gQXMgYSBjaGVhdCB0byB3b3JrXG4gIC8vIGFyb3VuZCB0aGlzLCB3ZSB3cmFwIHRoZSBvcmlnaW5hbCBzdHJlYW0gaW4gYSBuZXcgc3RyZWFtIHRoYXQgbmV2ZXIgY2xvc2VzLFxuICAvLyBhbmQgdGhlcmVmb3JlIGRvZXNuJ3QgZXJyb3IuXG4gIGNvbnN0IHJlYWRlciA9IG9yaWdpbmFsRmxpZ2h0U3RyZWFtLmdldFJlYWRlcigpXG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIGFzeW5jIHB1bGwoY29udHJvbGxlcikge1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKVxuICAgICAgICBpZiAoIWRvbmUpIHtcbiAgICAgICAgICAvLyBQYXNzIHRvIHRoZSB0YXJnZXQgc3RyZWFtIGFuZCBrZWVwIGNvbnN1bWluZyB0aGUgRmxpZ2h0IHJlc3BvbnNlXG4gICAgICAgICAgLy8gZnJvbSB0aGUgc2VydmVyLlxuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh2YWx1ZSlcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBzZXJ2ZXIgc3RyZWFtIGhhcyBjbG9zZWQuIEV4aXQsIGJ1dCBpbnRlbnRpb25hbGx5IGRvIG5vdCBjbG9zZVxuICAgICAgICAvLyB0aGUgdGFyZ2V0IHN0cmVhbS5cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfSxcbiAgfSlcbn1cbiJdLCJuYW1lcyI6WyJjcmVhdGVGZXRjaCIsImNyZWF0ZUZyb21OZXh0UmVhZGFibGVTdHJlYW0iLCJmZXRjaFNlcnZlclJlc3BvbnNlIiwidXJsVG9VcmxXaXRob3V0RmxpZ2h0TWFya2VyIiwiY3JlYXRlRnJvbVJlYWRhYmxlU3RyZWFtIiwiY3JlYXRlRnJvbVJlYWRhYmxlU3RyZWFtQnJvd3NlciIsInVybCIsInVybFdpdGhvdXRGbGlnaHRQYXJhbWV0ZXJzIiwiVVJMIiwibG9jYXRpb24iLCJvcmlnaW4iLCJzZWFyY2hQYXJhbXMiLCJkZWxldGUiLCJORVhUX1JTQ19VTklPTl9RVUVSWSIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsIl9fTkVYVF9DT05GSUdfT1VUUFVUIiwicGF0aG5hbWUiLCJlbmRzV2l0aCIsImxlbmd0aCIsInNsaWNlIiwiZG9NcGFOYXZpZ2F0aW9uIiwiZmxpZ2h0RGF0YSIsInRvU3RyaW5nIiwiY2Fub25pY2FsVXJsIiwidW5kZWZpbmVkIiwiY291bGRCZUludGVyY2VwdGVkIiwicHJlcmVuZGVyZWQiLCJwb3N0cG9uZWQiLCJzdGFsZVRpbWUiLCJhYm9ydENvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwiYWJvcnQiLCJvcHRpb25zIiwiZmxpZ2h0Um91dGVyU3RhdGUiLCJuZXh0VXJsIiwicHJlZmV0Y2hLaW5kIiwiaGVhZGVycyIsIlJTQ19IRUFERVIiLCJORVhUX1JPVVRFUl9TVEFURV9UUkVFX0hFQURFUiIsInByZXBhcmVGbGlnaHRSb3V0ZXJTdGF0ZUZvclJlcXVlc3QiLCJpc0htclJlZnJlc2giLCJQcmVmZXRjaEtpbmQiLCJBVVRPIiwiTkVYVF9ST1VURVJfUFJFRkVUQ0hfSEVBREVSIiwiTkVYVF9ITVJfUkVGUkVTSF9IRUFERVIiLCJORVhUX1VSTCIsInJlcyIsImZldGNoUHJpb3JpdHkiLCJURU1QT1JBUlkiLCJzaWduYWwiLCJyZXNwb25zZVVybCIsInJlZGlyZWN0ZWQiLCJjb250ZW50VHlwZSIsImdldCIsImludGVyY2VwdGlvbiIsImluY2x1ZGVzIiwiTkVYVF9ESURfUE9TVFBPTkVfSEVBREVSIiwic3RhbGVUaW1lSGVhZGVyU2Vjb25kcyIsIk5FWFRfUk9VVEVSX1NUQUxFX1RJTUVfSEVBREVSIiwicGFyc2VJbnQiLCJpc0ZsaWdodFJlc3BvbnNlIiwic3RhcnRzV2l0aCIsIlJTQ19DT05URU5UX1RZUEVfSEVBREVSIiwib2siLCJib2R5IiwiaGFzaCIsIlRVUkJPUEFDSyIsInJlcXVpcmUiLCJ3YWl0Rm9yV2VicGFja1J1bnRpbWVIb3RVcGRhdGUiLCJmbGlnaHRTdHJlYW0iLCJjcmVhdGVVbmNsb3NpbmdQcmVmZXRjaFN0cmVhbSIsInJlc3BvbnNlIiwiZ2V0QXBwQnVpbGRJZCIsImIiLCJub3JtYWxpemVGbGlnaHREYXRhIiwiZiIsIlMiLCJlcnIiLCJhYm9ydGVkIiwiY29uc29sZSIsImVycm9yIiwiX19ORVhUX1RFU1RfTU9ERSIsIk5FWFRfREVQTE9ZTUVOVF9JRCIsImZldGNoT3B0aW9ucyIsImNyZWRlbnRpYWxzIiwicHJpb3JpdHkiLCJmZXRjaFVybCIsInNldENhY2hlQnVzdGluZ1NlYXJjaFBhcmFtIiwiYnJvd3NlclJlc3BvbnNlIiwiZmV0Y2giLCJfX05FWFRfQ0xJRU5UX1ZBTElEQVRFX1JTQ19SRVFVRVNUX0hFQURFUlMiLCJNQVhfUkVESVJFQ1RTIiwibiIsInJzY1Jlc3BvbnNlIiwiaHJlZiIsInN0YXR1cyIsImNhbGxTZXJ2ZXIiLCJmaW5kU291cmNlTWFwVVJMIiwib3JpZ2luYWxGbGlnaHRTdHJlYW0iLCJyZWFkZXIiLCJnZXRSZWFkZXIiLCJSZWFkYWJsZVN0cmVhbSIsInB1bGwiLCJjb250cm9sbGVyIiwiZG9uZSIsInZhbHVlIiwicmVhZCIsImVucXVldWUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7SUF5UnNCQSxXQUFXLEVBQUE7ZUFBWEE7O0lBcUhOQyw0QkFBNEIsRUFBQTtlQUE1QkE7O0lBM1JNQyxtQkFBbUIsRUFBQTtlQUFuQkE7O0lBbEROQywyQkFBMkIsRUFBQTtlQUEzQkE7Ozt3QkE3RDREO2tDQWtCckU7K0JBQ29CO3FDQUNNO29DQUNKO21DQUt0Qjs0QkFDdUI7NENBQ2E7QUFFM0MsTUFBTUMsMkJBQ0pDLFFBQUFBLHdCQUErQjtBQThCMUIsU0FBU0YsNEJBQTRCRyxHQUFXO0lBQ3JELE1BQU1DLDZCQUE2QixJQUFJQyxJQUFJRixLQUFLRyxTQUFTQyxNQUFNO0lBQy9ESCwyQkFBMkJJLFlBQVksQ0FBQ0MsTUFBTSxDQUFDQyxrQkFBQUEsb0JBQW9CO0lBQ25FLElBQUlDLFFBQVFDLEdBQUcsQ0FBQ0MsUUFBUSxLQUFLLGNBQWM7O0lBVzNDLE9BQU9UO0FBQ1Q7QUFFQSxTQUFTZSxnQkFBZ0JoQixHQUFXO0lBQ2xDLE9BQU87UUFDTGlCLFlBQVlwQiw0QkFBNEJHLEtBQUtrQixRQUFRO1FBQ3JEQyxjQUFjQztRQUNkQyxvQkFBb0I7UUFDcEJDLGFBQWE7UUFDYkMsV0FBVztRQUNYQyxXQUFXLENBQUM7SUFDZDtBQUNGO0FBRUEsSUFBSUMsa0JBQWtCLElBQUlDO0FBRTFCLElBQUksT0FBT0MsV0FBVyxhQUFhOztBQW9CNUIsZUFBZS9CLG9CQUNwQkksR0FBUSxFQUNSOEIsT0FBbUM7SUFFbkMsTUFBTSxFQUFFQyxpQkFBaUIsRUFBRUMsT0FBTyxFQUFFQyxZQUFZLEVBQUUsR0FBR0g7SUFFckQsTUFBTUksVUFBMEI7UUFDOUIseUJBQXlCO1FBQ3pCLENBQUNDLGtCQUFBQSxVQUFVLENBQUMsRUFBRTtRQUNkLG1DQUFtQztRQUNuQyxDQUFDQyxrQkFBQUEsNkJBQTZCLENBQUMsRUFBRUMsQ0FBQUEsR0FBQUEsbUJB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QStCO0lBQy9CLE1BQU1DLFNBQVNELHFCQUFxQkUsU0FBUztJQUM3QyxPQUFPLElBQUlDLGVBQWU7UUFDeEIsTUFBTUMsTUFBS0MsVUFBVTtZQUNuQixNQUFPLEtBQU07Z0JBQ1gsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLEtBQUssRUFBRSxHQUFHLE1BQU1OLE9BQU9PLElBQUk7Z0JBQ3pDLElBQUksQ0FBQ0YsTUFBTTtvQkFDVCxtRUFBbUU7b0JBQ25FLG1CQUFtQjtvQkFDbkJELFdBQVdJLE9BQU8sQ0FBQ0Y7b0JBQ25CO2dCQUNGO2dCQUNBLHFFQUFxRTtnQkFDckUscUJBQXFCO2dCQUNyQjtZQUNGO1FBQ0Y7SUFDRjtBQUNGIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDE3NTUsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvY3JlYXRlLWhyZWYtZnJvbS11cmwudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUhyZWZGcm9tVXJsKFxuICB1cmw6IFBpY2s8VVJMLCAncGF0aG5hbWUnIHwgJ3NlYXJjaCcgfCAnaGFzaCc+LFxuICBpbmNsdWRlSGFzaDogYm9vbGVhbiA9IHRydWVcbik6IHN0cmluZyB7XG4gIHJldHVybiB1cmwucGF0aG5hbWUgKyB1cmwuc2VhcmNoICsgKGluY2x1ZGVIYXNoID8gdXJsLmhhc2ggOiAnJylcbn1cbiJdLCJuYW1lcyI6WyJjcmVhdGVIcmVmRnJvbVVybCIsInVybCIsImluY2x1ZGVIYXNoIiwicGF0aG5hbWUiLCJzZWFyY2giLCJoYXNoIl0sIm1hcHBpbmdzIjoiOzs7K0JBQWdCQSxxQkFBQUE7OztlQUFBQTs7O0FBQVQsU0FBU0Esa0JBQ2RDLEdBQThDLEVBQzlDQyxXQUEyQjtJQUEzQkEsSUFBQUEsZ0JBQUFBLEtBQUFBLEdBQUFBLGNBQXVCO0lBRXZCLE9BQU9ELElBQUlFLFFBQVEsR0FBR0YsSUFBSUcsTUFBTSxHQUFJRixDQUFBQSxjQUFjRCxJQUFJSSxJQUFJLEdBQUcsRUFBQztBQUNoRSIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxNzgxLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2NyZWF0ZS1yb3V0ZXItY2FjaGUta2V5LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgU2VnbWVudCB9IGZyb20gJy4uLy4uLy4uL3NlcnZlci9hcHAtcmVuZGVyL3R5cGVzJ1xuaW1wb3J0IHsgUEFHRV9TRUdNRU5UX0tFWSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9saWIvc2VnbWVudCdcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJvdXRlckNhY2hlS2V5KFxuICBzZWdtZW50OiBTZWdtZW50LFxuICB3aXRob3V0U2VhcmNoUGFyYW1ldGVyczogYm9vbGVhbiA9IGZhbHNlXG4pIHtcbiAgLy8gaWYgdGhlIHNlZ21lbnQgaXMgYW4gYXJyYXksIGl0IG1lYW5zIGl0J3MgYSBkeW5hbWljIHNlZ21lbnRcbiAgLy8gZm9yIGV4YW1wbGUsIFsnbGFuZycsICdlbicsICdkJ10uIFdlIG5lZWQgdG8gY29udmVydCBpdCB0byBhIHN0cmluZyB0byBzdG9yZSBpdCBhcyBhIGNhY2hlIG5vZGUga2V5LlxuICBpZiAoQXJyYXkuaXNBcnJheShzZWdtZW50KSkge1xuICAgIHJldHVybiBgJHtzZWdtZW50WzBdfXwke3NlZ21lbnRbMV19fCR7c2VnbWVudFsyXX1gXG4gIH1cblxuICAvLyBQYWdlIHNlZ21lbnRzIG1pZ2h0IGhhdmUgc2VhcmNoIHBhcmFtZXRlcnMsIGllIF9fUEFHRV9fP2Zvbz1iYXJcbiAgLy8gV2hlbiBgd2l0aG91dFNlYXJjaFBhcmFtZXRlcnNgIGlzIHRydWUsIHdlIG9ubHkgd2FudCB0byByZXR1cm4gdGhlIHBhZ2Ugc2VnbWVudFxuICBpZiAod2l0aG91dFNlYXJjaFBhcmFtZXRlcnMgJiYgc2VnbWVudC5zdGFydHNXaXRoKFBBR0VfU0VHTUVOVF9LRVkpKSB7XG4gICAgcmV0dXJuIFBBR0VfU0VHTUVOVF9LRVlcbiAgfVxuXG4gIHJldHVybiBzZWdtZW50XG59XG4iXSwibmFtZXMiOlsiY3JlYXRlUm91dGVyQ2FjaGVLZXkiLCJzZWdtZW50Iiwid2l0aG91dFNlYXJjaFBhcmFtZXRlcnMiLCJBcnJheSIsImlzQXJyYXkiLCJzdGFydHNXaXRoIiwiUEFHRV9TRUdNRU5UX0tFWSJdLCJtYXBwaW5ncyI6Ijs7OytCQUdnQkEsd0JBQUFBOzs7ZUFBQUE7Ozt5QkFGaUI7QUFFMUIsU0FBU0EscUJBQ2RDLE9BQWdCLEVBQ2hCQyx1QkFBd0M7SUFBeENBLElBQUFBLDRCQUFBQSxLQUFBQSxHQUFBQSwwQkFBbUM7SUFFbkMsOERBQThEO0lBQzlELHVHQUF1RztJQUN2RyxJQUFJQyxNQUFNQyxPQUFPLENBQUNILFVBQVU7UUFDMUIsT0FBVUEsT0FBTyxDQUFDLEVBQUUsR0FBQyxNQUFHQSxPQUFPLENBQUMsRUFBRSxHQUFDLE1BQUdBLE9BQU8sQ0FBQyxFQUFFO0lBQ2xEO0lBRUEsa0VBQWtFO0lBQ2xFLGtGQUFrRjtJQUNsRixJQUFJQywyQkFBMkJELFFBQVFJLFVBQVUsQ0FBQ0MsU0FBQUEsZ0JBQWdCLEdBQUc7UUFDbkUsT0FBT0EsU0FBQUEsZ0JBQWdCO0lBQ3pCO0lBRUEsT0FBT0w7QUFDVCIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxODE4LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2ludmFsaWRhdGUtY2FjaGUtYmVsb3ctZmxpZ2h0LXNlZ21lbnRwYXRoLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgQ2FjaGVOb2RlIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgdHlwZSB7IEZsaWdodFNlZ21lbnRQYXRoIH0gZnJvbSAnLi4vLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvdHlwZXMnXG5pbXBvcnQgeyBjcmVhdGVSb3V0ZXJDYWNoZUtleSB9IGZyb20gJy4vY3JlYXRlLXJvdXRlci1jYWNoZS1rZXknXG5pbXBvcnQgeyBnZXROZXh0RmxpZ2h0U2VnbWVudFBhdGggfSBmcm9tICcuLi8uLi9mbGlnaHQtZGF0YS1oZWxwZXJzJ1xuXG4vKipcbiAqIEZpbGwgY2FjaGUgdXAgdG8gdGhlIGVuZCBvZiB0aGUgZmxpZ2h0U2VnbWVudFBhdGgsIGludmFsaWRhdGluZyBhbnl0aGluZyBiZWxvdyBpdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludmFsaWRhdGVDYWNoZUJlbG93RmxpZ2h0U2VnbWVudFBhdGgoXG4gIG5ld0NhY2hlOiBDYWNoZU5vZGUsXG4gIGV4aXN0aW5nQ2FjaGU6IENhY2hlTm9kZSxcbiAgZmxpZ2h0U2VnbWVudFBhdGg6IEZsaWdodFNlZ21lbnRQYXRoXG4pOiB2b2lkIHtcbiAgY29uc3QgaXNMYXN0RW50cnkgPSBmbGlnaHRTZWdtZW50UGF0aC5sZW5ndGggPD0gMlxuICBjb25zdCBbcGFyYWxsZWxSb3V0ZUtleSwgc2VnbWVudF0gPSBmbGlnaHRTZWdtZW50UGF0aFxuXG4gIGNvbnN0IGNhY2hlS2V5ID0gY3JlYXRlUm91dGVyQ2FjaGVLZXkoc2VnbWVudClcblxuICBjb25zdCBleGlzdGluZ0NoaWxkU2VnbWVudE1hcCA9XG4gICAgZXhpc3RpbmdDYWNoZS5wYXJhbGxlbFJvdXRlcy5nZXQocGFyYWxsZWxSb3V0ZUtleSlcblxuICBpZiAoIWV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwKSB7XG4gICAgLy8gQmFpbG91dCBiZWNhdXNlIHRoZSBleGlzdGluZyBjYWNoZSBkb2VzIG5vdCBoYXZlIHRoZSBwYXRoIHRvIHRoZSBsZWFmIG5vZGVcbiAgICAvLyBXaWxsIHRyaWdnZXIgbGF6eSBmZXRjaCBpbiBsYXlvdXQtcm91dGVyIGJlY2F1c2Ugb2YgbWlzc2luZyBzZWdtZW50XG4gICAgcmV0dXJuXG4gIH1cblxuICBsZXQgY2hpbGRTZWdtZW50TWFwID0gbmV3Q2FjaGUucGFyYWxsZWxSb3V0ZXMuZ2V0KHBhcmFsbGVsUm91dGVLZXkpXG4gIGlmICghY2hpbGRTZWdtZW50TWFwIHx8IGNoaWxkU2VnbWVudE1hcCA9PT0gZXhpc3RpbmdDaGlsZFNlZ21lbnRNYXApIHtcbiAgICBjaGlsZFNlZ21lbnRNYXAgPSBuZXcgTWFwKGV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwKVxuICAgIG5ld0NhY2hlLnBhcmFsbGVsUm91dGVzLnNldChwYXJhbGxlbFJvdXRlS2V5LCBjaGlsZFNlZ21lbnRNYXApXG4gIH1cblxuICAvLyBJbiBjYXNlIG9mIGxhc3QgZW50cnkgZG9uJ3QgY29weSBmdXJ0aGVyIGRvd24uXG4gIGlmIChpc0xhc3RFbnRyeSkge1xuICAgIGNoaWxkU2VnbWVudE1hcC5kZWxldGUoY2FjaGVLZXkpXG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCBleGlzdGluZ0NoaWxkQ2FjaGVOb2RlID0gZXhpc3RpbmdDaGlsZFNlZ21lbnRNYXAuZ2V0KGNhY2hlS2V5KVxuICBsZXQgY2hpbGRDYWNoZU5vZGUgPSBjaGlsZFNlZ21lbnRNYXAuZ2V0KGNhY2hlS2V5KVxuXG4gIGlmICghY2hpbGRDYWNoZU5vZGUgfHwgIWV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUpIHtcbiAgICAvLyBCYWlsb3V0IGJlY2F1c2UgdGhlIGV4aXN0aW5nIGNhY2hlIGRvZXMgbm90IGhhdmUgdGhlIHBhdGggdG8gdGhlIGxlYWYgbm9kZVxuICAgIC8vIFdpbGwgdHJpZ2dlciBsYXp5IGZldGNoIGluIGxheW91dC1yb3V0ZXIgYmVjYXVzZSBvZiBtaXNzaW5nIHNlZ21lbnRcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChjaGlsZENhY2hlTm9kZSA9PT0gZXhpc3RpbmdDaGlsZENhY2hlTm9kZSkge1xuICAgIGNoaWxkQ2FjaGVOb2RlID0ge1xuICAgICAgbGF6eURhdGE6IGNoaWxkQ2FjaGVOb2RlLmxhenlEYXRhLFxuICAgICAgcnNjOiBjaGlsZENhY2hlTm9kZS5yc2MsXG4gICAgICBwcmVmZXRjaFJzYzogY2hpbGRDYWNoZU5vZGUucHJlZmV0Y2hSc2MsXG4gICAgICBoZWFkOiBjaGlsZENhY2hlTm9kZS5oZWFkLFxuICAgICAgcHJlZmV0Y2hIZWFkOiBjaGlsZENhY2hlTm9kZS5wcmVmZXRjaEhlYWQsXG4gICAgICBwYXJhbGxlbFJvdXRlczogbmV3IE1hcChjaGlsZENhY2hlTm9kZS5wYXJhbGxlbFJvdXRlcyksXG4gICAgfSBhcyBDYWNoZU5vZGVcbiAgICBjaGlsZFNlZ21lbnRNYXAuc2V0KGNhY2hlS2V5LCBjaGlsZENhY2hlTm9kZSlcbiAgfVxuXG4gIGludmFsaWRhdGVDYWNoZUJlbG93RmxpZ2h0U2VnbWVudFBhdGgoXG4gICAgY2hpbGRDYWNoZU5vZGUsXG4gICAgZXhpc3RpbmdDaGlsZENhY2hlTm9kZSxcbiAgICBnZXROZXh0RmxpZ2h0U2VnbWVudFBhdGgoZmxpZ2h0U2VnbWVudFBhdGgpXG4gIClcbn1cbiJdLCJuYW1lcyI6WyJpbnZhbGlkYXRlQ2FjaGVCZWxvd0ZsaWdodFNlZ21lbnRQYXRoIiwibmV3Q2FjaGUiLCJleGlzdGluZ0NhY2hlIiwiZmxpZ2h0U2VnbWVudFBhdGgiLCJpc0xhc3RFbnRyeSIsImxlbmd0aCIsInBhcmFsbGVsUm91dGVLZXkiLCJzZWdtZW50IiwiY2FjaGVLZXkiLCJjcmVhdGVSb3V0ZXJDYWNoZUtleSIsImV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwIiwicGFyYWxsZWxSb3V0ZXMiLCJnZXQiLCJjaGlsZFNlZ21lbnRNYXAiLCJNYXAiLCJzZXQiLCJkZWxldGUiLCJleGlzdGluZ0NoaWxkQ2FjaGVOb2RlIiwiY2hpbGRDYWNoZU5vZGUiLCJsYXp5RGF0YSIsInJzYyIsInByZWZldGNoUnNjIiwiaGVhZCIsInByZWZldGNoSGVhZCIsImdldE5leHRGbGlnaHRTZWdtZW50UGF0aCJdLCJtYXBwaW5ncyI6Ijs7OytCQVFnQkEseUNBQUFBOzs7ZUFBQUE7OztzQ0FOcUI7bUNBQ0k7QUFLbEMsU0FBU0Esc0NBQ2RDLFFBQW1CLEVBQ25CQyxhQUF3QixFQUN4QkMsaUJBQW9DO0lBRXBDLE1BQU1DLGNBQWNELGtCQUFrQkUsTUFBTSxJQUFJO0lBQ2hELE1BQU0sQ0FBQ0Msa0JBQWtCQyxRQUFRLEdBQUdKO0lBRXBDLE1BQU1LLFdBQVdDLENBQUFBLEdBQUFBLHNCQUFBQSxvQkFBb0IsRUFBQ0Y7SUFFdEMsTUFBTUcsMEJBQ0pSLGNBQWNTLGNBQWMsQ0FBQ0MsR0FBRyxDQUFDTjtJQUVuQyxJQUFJLENBQUNJLHlCQUF5QjtRQUM1Qiw2RUFBNkU7UUFDN0Usc0VBQXNFO1FBQ3RFO0lBQ0Y7SUFFQSxJQUFJRyxrQkFBa0JaLFNBQVNVLGNBQWMsQ0FBQ0MsR0FBRyxDQUFDTjtJQUNsRCxJQUFJLENBQUNPLG1CQUFtQkEsb0JBQW9CSCx5QkFBeUI7UUFDbkVHLGtCQUFrQixJQUFJQyxJQUFJSjtRQUMxQlQsU0FBU1UsY0FBYyxDQUFDSSxHQUFHLENBQUNULGtCQUFrQk87SUFDaEQ7SUFFQSxpREFBaUQ7SUFDakQsSUFBSVQsYUFBYTtRQUNmUyxnQkFBZ0JHLE1BQU0sQ0FBQ1I7UUFDdkI7SUFDRjtJQUVBLE1BQU1TLHlCQUF5QlAsd0JBQXdCRSxHQUFHLENBQUNKO0lBQzNELElBQUlVLGlCQUFpQkwsZ0JBQWdCRCxHQUFHLENBQUNKO0lBRXpDLElBQUksQ0FBQ1Usa0JBQWtCLENBQUNELHdCQUF3QjtRQUM5Qyw2RUFBNkU7UUFDN0Usc0VBQXNFO1FBQ3RFO0lBQ0Y7SUFFQSxJQUFJQyxtQkFBbUJELHdCQUF3QjtRQUM3Q0MsaUJBQWlCO1lBQ2ZDLFVBQVVELGVBQWVDLFFBQVE7WUFDakNDLEtBQUtGLGVBQWVFLEdBQUc7WUFDdkJDLGFBQWFILGVBQWVHLFdBQVc7WUFDdkNDLE1BQU1KLGVBQWVJLElBQUk7WUFDekJDLGNBQWNMLGVBQWVLLFlBQVk7WUFDekNaLGdCQUFnQixJQUFJRyxJQUFJSSxlQUFlUCxjQUFjO1FBQ3ZEO1FBQ0FFLGdCQUFnQkUsR0FBRyxDQUFDUCxVQUFVVTtJQUNoQztJQUVBbEIsc0NBQ0VrQixnQkFDQUQsd0JBQ0FPLENBQUFBLEdBQUFBLG1CQUFBQSx3QkFBd0IsRUFBQ3JCO0FBRTdCIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDE4ODIsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvY2xpZW50L2NvbXBvbmVudHMvbWF0Y2gtc2VnbWVudHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBTZWdtZW50IH0gZnJvbSAnLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvdHlwZXMnXG5cbmV4cG9ydCBjb25zdCBtYXRjaFNlZ21lbnQgPSAoXG4gIGV4aXN0aW5nU2VnbWVudDogU2VnbWVudCxcbiAgc2VnbWVudDogU2VnbWVudFxuKTogYm9vbGVhbiA9PiB7XG4gIC8vIHNlZ21lbnQgaXMgZWl0aGVyIEFycmF5IG9yIHN0cmluZ1xuICBpZiAodHlwZW9mIGV4aXN0aW5nU2VnbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHNlZ21lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBDb21tb24gY2FzZTogc2VnbWVudCBpcyBqdXN0IGEgc3RyaW5nXG4gICAgICByZXR1cm4gZXhpc3RpbmdTZWdtZW50ID09PSBzZWdtZW50XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKHR5cGVvZiBzZWdtZW50ID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHJldHVybiBleGlzdGluZ1NlZ21lbnRbMF0gPT09IHNlZ21lbnRbMF0gJiYgZXhpc3RpbmdTZWdtZW50WzFdID09PSBzZWdtZW50WzFdXG59XG4iXSwibmFtZXMiOlsibWF0Y2hTZWdtZW50IiwiZXhpc3RpbmdTZWdtZW50Iiwic2VnbWVudCJdLCJtYXBwaW5ncyI6Ijs7OytCQUVhQSxnQkFBQUE7OztlQUFBQTs7O0FBQU4sTUFBTUEsZUFBZSxDQUMxQkMsaUJBQ0FDO0lBRUEsb0NBQW9DO0lBQ3BDLElBQUksT0FBT0Qsb0JBQW9CLFVBQVU7UUFDdkMsSUFBSSxPQUFPQyxZQUFZLFVBQVU7WUFDL0Isd0NBQXdDO1lBQ3hDLE9BQU9ELG9CQUFvQkM7UUFDN0I7UUFDQSxPQUFPO0lBQ1Q7SUFFQSxJQUFJLE9BQU9BLFlBQVksVUFBVTtRQUMvQixPQUFPO0lBQ1Q7SUFDQSxPQUFPRCxlQUFlLENBQUMsRUFBRSxLQUFLQyxPQUFPLENBQUMsRUFBRSxJQUFJRCxlQUFlLENBQUMsRUFBRSxLQUFLQyxPQUFPLENBQUMsRUFBRTtBQUMvRSIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxOTE4LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2ZpbGwtbGF6eS1pdGVtcy10aWxsLWxlYWYtd2l0aC1oZWFkLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgQ2FjaGVOb2RlIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgdHlwZSB7XG4gIEZsaWdodFJvdXRlclN0YXRlLFxuICBDYWNoZU5vZGVTZWVkRGF0YSxcbn0gZnJvbSAnLi4vLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvdHlwZXMnXG5pbXBvcnQgeyBjcmVhdGVSb3V0ZXJDYWNoZUtleSB9IGZyb20gJy4vY3JlYXRlLXJvdXRlci1jYWNoZS1rZXknXG5pbXBvcnQge1xuICBQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMsXG4gIHR5cGUgUHJlZmV0Y2hDYWNoZUVudHJ5LFxufSBmcm9tICcuL3JvdXRlci1yZWR1Y2VyLXR5cGVzJ1xuXG5leHBvcnQgZnVuY3Rpb24gZmlsbExhenlJdGVtc1RpbGxMZWFmV2l0aEhlYWQoXG4gIG5hdmlnYXRlZEF0OiBudW1iZXIsXG4gIG5ld0NhY2hlOiBDYWNoZU5vZGUsXG4gIGV4aXN0aW5nQ2FjaGU6IENhY2hlTm9kZSB8IHVuZGVmaW5lZCxcbiAgcm91dGVyU3RhdGU6IEZsaWdodFJvdXRlclN0YXRlLFxuICBjYWNoZU5vZGVTZWVkRGF0YTogQ2FjaGVOb2RlU2VlZERhdGEgfCBudWxsLFxuICBoZWFkOiBSZWFjdC5SZWFjdE5vZGUsXG4gIHByZWZldGNoRW50cnk6IFByZWZldGNoQ2FjaGVFbnRyeSB8IHVuZGVmaW5lZFxuKTogdm9pZCB7XG4gIGNvbnN0IGlzTGFzdFNlZ21lbnQgPSBPYmplY3Qua2V5cyhyb3V0ZXJTdGF0ZVsxXSkubGVuZ3RoID09PSAwXG4gIGlmIChpc0xhc3RTZWdtZW50KSB7XG4gICAgbmV3Q2FjaGUuaGVhZCA9IGhlYWRcbiAgICByZXR1cm5cbiAgfVxuICAvLyBSZW1vdmUgc2VnbWVudCB0aGF0IHdlIGdvdCBkYXRhIGZvciBzbyB0aGF0IGl0IGlzIGZpbGxlZCBpbiBkdXJpbmcgcmVuZGVyaW5nIG9mIHJzYy5cbiAgZm9yIChjb25zdCBrZXkgaW4gcm91dGVyU3RhdGVbMV0pIHtcbiAgICBjb25zdCBwYXJhbGxlbFJvdXRlU3RhdGUgPSByb3V0ZXJTdGF0ZVsxXVtrZXldXG4gICAgY29uc3Qgc2VnbWVudEZvclBhcmFsbGVsUm91dGUgPSBwYXJhbGxlbFJvdXRlU3RhdGVbMF1cbiAgICBjb25zdCBjYWNoZUtleSA9IGNyZWF0ZVJvdXRlckNhY2hlS2V5KHNlZ21lbnRGb3JQYXJhbGxlbFJvdXRlKVxuXG4gICAgLy8gVE9ETzogV2Ugc2hvdWxkIHRyYXZlcnNlIHRoZSBjYWNoZU5vZGVTZWVkRGF0YSB0cmVlIGluc3RlYWQgb2YgdGhlIHJvdXRlclxuICAgIC8vIHN0YXRlIHRyZWUuIElkZWFsbHksIHRoZXkgd291bGQgYWx3YXlzIGJlIHRoZSBzYW1lIHNoYXBlLCBidXQgYmVjYXVzZSBvZlxuICAgIC8vIHRoZSBsb2FkaW5nLmpzIHBhdHRlcm4sIGNhY2hlTm9kZVNlZWREYXRhIHNvbWV0aW1lcyBvbmx5IHJlcHJlc2VudHMgYVxuICAgIC8vIHBhcnRpYWwgdHJlZS4gVGhhdCdzIHdoeSB0aGlzIG5vZGUgaXMgc29tZXRpbWVzIG51bGwuIE9uY2UgUFBSIGxhbmRzLFxuICAgIC8vIGxvYWRpbmcuanMgd2lsbCBubyBsb25nZXIgaGF2ZSBzcGVjaWFsIGJlaGF2aW9yIGFuZCB3ZSBjYW4gdHJhdmVyc2UgdGhlXG4gICAgLy8gZGF0YSB0cmVlIGluc3RlYWQuXG4gICAgLy9cbiAgICAvLyBXZSBzaG91bGQgYWxzbyBjb25zaWRlciBtZXJnaW5nIHRoZSByb3V0ZXIgc3RhdGUgdHJlZSBhbmQgdGhlIGRhdGEgdHJlZVxuICAgIC8vIGluIHRoZSByZXNwb25zZSBmb3JtYXQsIHNvIHRoYXQgd2UgZG9uJ3QgaGF2ZSB0byBzZW5kIHRoZSBrZXlzIHR3aWNlLlxuICAgIC8vIFRoZW4gdGhlIGNsaWVudCBjYW4gY29udmVydCB0aGVtIGludG8gc2VwYXJhdGUgcmVwcmVzZW50YXRpb25zLlxuICAgIGNvbnN0IHBhcmFsbGVsU2VlZERhdGEgPVxuICAgICAgY2FjaGVOb2RlU2VlZERhdGEgIT09IG51bGwgJiYgY2FjaGVOb2RlU2VlZERhdGFbMl1ba2V5XSAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gY2FjaGVOb2RlU2VlZERhdGFbMl1ba2V5XVxuICAgICAgICA6IG51bGxcbiAgICBpZiAoZXhpc3RpbmdDYWNoZSkge1xuICAgICAgY29uc3QgZXhpc3RpbmdQYXJhbGxlbFJvdXRlc0NhY2hlTm9kZSA9XG4gICAgICAgIGV4aXN0aW5nQ2FjaGUucGFyYWxsZWxSb3V0ZXMuZ2V0KGtleSlcbiAgICAgIGlmIChleGlzdGluZ1BhcmFsbGVsUm91dGVzQ2FjaGVOb2RlKSB7XG4gICAgICAgIGNvbnN0IGhhc1JldXNhYmxlUHJlZmV0Y2ggPVxuICAgICAgICAgIHByZWZldGNoRW50cnk/LmtpbmQgPT09ICdhdXRvJyAmJlxuICAgICAgICAgIHByZWZldGNoRW50cnkuc3RhdHVzID09PSBQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMucmV1c2FibGVcblxuICAgICAgICBsZXQgcGFyYWxsZWxSb3V0ZUNhY2hlTm9kZSA9IG5ldyBNYXAoZXhpc3RpbmdQYXJhbGxlbFJvdXRlc0NhY2hlTm9kZSlcbiAgICAgICAgY29uc3QgZXhpc3RpbmdDYWNoZU5vZGUgPSBwYXJhbGxlbFJvdXRlQ2FjaGVOb2RlLmdldChjYWNoZUtleSlcbiAgICAgICAgbGV0IG5ld0NhY2hlTm9kZTogQ2FjaGVOb2RlXG4gICAgICAgIGlmIChwYXJhbGxlbFNlZWREYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gTmV3IGRhdGEgd2FzIHNlbnQgZnJvbSB0aGUgc2VydmVyLlxuICAgICAgICAgIGNvbnN0IHNlZWROb2RlID0gcGFyYWxsZWxTZWVkRGF0YVsxXVxuICAgICAgICAgIGNvbnN0IGxvYWRpbmcgPSBwYXJhbGxlbFNlZWREYXRhWzNdXG4gICAgICAgICAgbmV3Q2FjaGVOb2RlID0ge1xuICAgICAgICAgICAgbGF6eURhdGE6IG51bGwsXG4gICAgICAgICAgICByc2M6IHNlZWROb2RlLFxuICAgICAgICAgICAgLy8gVGhpcyBpcyBhIFBQUi1vbmx5IGZpZWxkLiBXaGVuIFBQUiBpcyBlbmFibGVkLCB3ZSBzaG91bGRuJ3QgaGl0XG4gICAgICAgICAgICAvLyB0aGlzIHBhdGggZHVyaW5nIGEgbmF2aWdhdGlvbiwgYnV0IHVudGlsIFBQUiBpcyBmdWxseSBpbXBsZW1lbnRlZFxuICAgICAgICAgICAgLy8geWV0IGl0J3MgcG9zc2libGUgdGhlIGV4aXN0aW5nIG5vZGUgZG9lcyBoYXZlIGEgbm9uLW51bGxcbiAgICAgICAgICAgIC8vIGBwcmVmZXRjaFJzY2AuIEFzIGFuIGluY3JlbWVudGFsIHN0ZXAsIHdlJ2xsIGp1c3QgZGUtb3B0IHRvIHRoZVxuICAgICAgICAgICAgLy8gb2xkIGJlaGF2aW9yIOKAlCBubyBQUFIgdmFsdWUuXG4gICAgICAgICAgICBwcmVmZXRjaFJzYzogbnVsbCxcbiAgICAgICAgICAgIGhlYWQ6IG51bGwsXG4gICAgICAgICAgICBwcmVmZXRjaEhlYWQ6IG51bGwsXG4gICAgICAgICAgICBsb2FkaW5nLFxuICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IG5ldyBNYXAoZXhpc3RpbmdDYWNoZU5vZGU/LnBhcmFsbGVsUm91dGVzKSxcbiAgICAgICAgICAgIG5hdmlnYXRlZEF0LFxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChoYXNSZXVzYWJsZVByZWZldGNoICYmIGV4aXN0aW5nQ2FjaGVOb2RlKSB7XG4gICAgICAgICAgLy8gTm8gbmV3IGRhdGEgd2FzIHNlbnQgZnJvbSB0aGUgc2VydmVyLCBidXQgdGhlIGV4aXN0aW5nIGNhY2hlIG5vZGVcbiAgICAgICAgICAvLyB3YXMgcHJlZmV0Y2hlZCwgc28gd2Ugc2hvdWxkIHJldXNlIHRoYXQuXG4gICAgICAgICAgbmV3Q2FjaGVOb2RlID0ge1xuICAgICAgICAgICAgbGF6eURhdGE6IGV4aXN0aW5nQ2FjaGVOb2RlLmxhenlEYXRhLFxuICAgICAgICAgICAgcnNjOiBleGlzdGluZ0NhY2hlTm9kZS5yc2MsXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgUFBSLW9ubHkgZmllbGQuIFVubGlrZSB0aGUgcHJldmlvdXMgYnJhbmNoLCBzaW5jZSB3ZSdyZVxuICAgICAgICAgICAgLy8ganVzdCBjbG9uaW5nIHRoZSBleGlzdGluZyBjYWNoZSBub2RlLCB3ZSBtaWdodCBhcyB3ZWxsIGtlZXAgdGhlXG4gICAgICAgICAgICAvLyBQUFIgdmFsdWUsIGlmIGl0IGV4aXN0cy5cbiAgICAgICAgICAgIHByZWZldGNoUnNjOiBleGlzdGluZ0NhY2hlTm9kZS5wcmVmZXRjaFJzYyxcbiAgICAgICAgICAgIGhlYWQ6IGV4aXN0aW5nQ2FjaGVOb2RlLmhlYWQsXG4gICAgICAgICAgICBwcmVmZXRjaEhlYWQ6IGV4aXN0aW5nQ2FjaGVOb2RlLnByZWZldGNoSGVhZCxcbiAgICAgICAgICAgIHBhcmFsbGVsUm91dGVzOiBuZXcgTWFwKGV4aXN0aW5nQ2FjaGVOb2RlLnBhcmFsbGVsUm91dGVzKSxcbiAgICAgICAgICAgIGxvYWRpbmc6IGV4aXN0aW5nQ2FjaGVOb2RlLmxvYWRpbmcsXG4gICAgICAgICAgfSBhcyBDYWNoZU5vZGVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBObyBkYXRhIGF2YWlsYWJsZSBmb3IgdGhpcyBub2RlLiBUaGlzIHdpbGwgdHJpZ2dlciBhIGxhenkgZmV0Y2hcbiAgICAgICAgICAvLyBkdXJpbmcgcmVuZGVyLlxuICAgICAgICAgIG5ld0NhY2hlTm9kZSA9IHtcbiAgICAgICAgICAgIGxhenlEYXRhOiBudWxsLFxuICAgICAgICAgICAgcnNjOiBudWxsLFxuICAgICAgICAgICAgcHJlZmV0Y2hSc2M6IG51bGwsXG4gICAgICAgICAgICBoZWFkOiBudWxsLFxuICAgICAgICAgICAgcHJlZmV0Y2hIZWFkOiBudWxsLFxuICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IG5ldyBNYXAoZXhpc3RpbmdDYWNoZU5vZGU/LnBhcmFsbGVsUm91dGVzKSxcbiAgICAgICAgICAgIGxvYWRpbmc6IG51bGwsXG4gICAgICAgICAgICBuYXZpZ2F0ZWRBdCxcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPdmVycmlkZXMgdGhlIGNhY2hlIGtleSB3aXRoIHRoZSBuZXcgY2FjaGUgbm9kZS5cbiAgICAgICAgcGFyYWxsZWxSb3V0ZUNhY2hlTm9kZS5zZXQoY2FjaGVLZXksIG5ld0NhY2hlTm9kZSlcbiAgICAgICAgLy8gVHJhdmVyc2UgZGVlcGVyIHRvIGFwcGx5IHRoZSBoZWFkIC8gZmlsbCBsYXp5IGl0ZW1zIHRpbGwgdGhlIGhlYWQuXG4gICAgICAgIGZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkKFxuICAgICAgICAgIG5hdmlnYXRlZEF0LFxuICAgICAgICAgIG5ld0NhY2hlTm9kZSxcbiAgICAgICAgICBleGlzdGluZ0NhY2hlTm9kZSxcbiAgICAgICAgICBwYXJhbGxlbFJvdXRlU3RhdGUsXG4gICAgICAgICAgcGFyYWxsZWxTZWVkRGF0YSA/IHBhcmFsbGVsU2VlZERhdGEgOiBudWxsLFxuICAgICAgICAgIGhlYWQsXG4gICAgICAgICAgcHJlZmV0Y2hFbnRyeVxuICAgICAgICApXG5cbiAgICAgICAgbmV3Q2FjaGUucGFyYWxsZWxSb3V0ZXMuc2V0KGtleSwgcGFyYWxsZWxSb3V0ZUNhY2hlTm9kZSlcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgbmV3Q2FjaGVOb2RlOiBDYWNoZU5vZGVcbiAgICBpZiAocGFyYWxsZWxTZWVkRGF0YSAhPT0gbnVsbCkge1xuICAgICAgLy8gTmV3IGRhdGEgd2FzIHNlbnQgZnJvbSB0aGUgc2VydmVyLlxuICAgICAgY29uc3Qgc2VlZE5vZGUgPSBwYXJhbGxlbFNlZWREYXRhWzFdXG4gICAgICBjb25zdCBsb2FkaW5nID0gcGFyYWxsZWxTZWVkRGF0YVszXVxuICAgICAgbmV3Q2FjaGVOb2RlID0ge1xuICAgICAgICBsYXp5RGF0YTogbnVsbCxcbiAgICAgICAgcnNjOiBzZWVkTm9kZSxcbiAgICAgICAgcHJlZmV0Y2hSc2M6IG51bGwsXG4gICAgICAgIGhlYWQ6IG51bGwsXG4gICAgICAgIHByZWZldGNoSGVhZDogbnVsbCxcbiAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IG5ldyBNYXAoKSxcbiAgICAgICAgbG9hZGluZyxcbiAgICAgICAgbmF2aWdhdGVkQXQsXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5vIGRhdGEgYXZhaWxhYmxlIGZvciB0aGlzIG5vZGUuIFRoaXMgd2lsbCB0cmlnZ2VyIGEgbGF6eSBmZXRjaFxuICAgICAgLy8gZHVyaW5nIHJlbmRlci5cbiAgICAgIG5ld0NhY2hlTm9kZSA9IHtcbiAgICAgICAgbGF6eURhdGE6IG51bGwsXG4gICAgICAgIHJzYzogbnVsbCxcbiAgICAgICAgcHJlZmV0Y2hSc2M6IG51bGwsXG4gICAgICAgIGhlYWQ6IG51bGwsXG4gICAgICAgIHByZWZldGNoSGVhZDogbnVsbCxcbiAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IG5ldyBNYXAoKSxcbiAgICAgICAgbG9hZGluZzogbnVsbCxcbiAgICAgICAgbmF2aWdhdGVkQXQsXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZXhpc3RpbmdQYXJhbGxlbFJvdXRlcyA9IG5ld0NhY2hlLnBhcmFsbGVsUm91dGVzLmdldChrZXkpXG4gICAgaWYgKGV4aXN0aW5nUGFyYWxsZWxSb3V0ZXMpIHtcbiAgICAgIGV4aXN0aW5nUGFyYWxsZWxSb3V0ZXMuc2V0KGNhY2hlS2V5LCBuZXdDYWNoZU5vZGUpXG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0NhY2hlLnBhcmFsbGVsUm91dGVzLnNldChrZXksIG5ldyBNYXAoW1tjYWNoZUtleSwgbmV3Q2FjaGVOb2RlXV0pKVxuICAgIH1cblxuICAgIGZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkKFxuICAgICAgbmF2aWdhdGVkQXQsXG4gICAgICBuZXdDYWNoZU5vZGUsXG4gICAgICB1bmRlZmluZWQsXG4gICAgICBwYXJhbGxlbFJvdXRlU3RhdGUsXG4gICAgICBwYXJhbGxlbFNlZWREYXRhLFxuICAgICAgaGVhZCxcbiAgICAgIHByZWZldGNoRW50cnlcbiAgICApXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJmaWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZCIsIm5hdmlnYXRlZEF0IiwibmV3Q2FjaGUiLCJleGlzdGluZ0NhY2hlIiwicm91dGVyU3RhdGUiLCJjYWNoZU5vZGVTZWVkRGF0YSIsImhlYWQiLCJwcmVmZXRjaEVudHJ5IiwiaXNMYXN0U2VnbWVudCIsIk9iamVjdCIsImtleXMiLCJsZW5ndGgiLCJrZXkiLCJwYXJhbGxlbFJvdXRlU3RhdGUiLCJzZWdtZW50Rm9yUGFyYWxsZWxSb3V0ZSIsImNhY2hlS2V5IiwiY3JlYXRlUm91dGVyQ2FjaGVLZXkiLCJwYXJhbGxlbFNlZWREYXRhIiwidW5kZWZpbmVkIiwiZXhpc3RpbmdQYXJhbGxlbFJvdXRlc0NhY2hlTm9kZSIsInBhcmFsbGVsUm91dGVzIiwiZ2V0IiwiaGFzUmV1c2FibGVQcmVmZXRjaCIsImtpbmQiLCJzdGF0dXMiLCJQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMiLCJyZXVzYWJsZSIsInBhcmFsbGVsUm91dGVDYWNoZU5vZGUiLCJNYXAiLCJleGlzdGluZ0NhY2hlTm9kZSIsIm5ld0NhY2hlTm9kZSIsInNlZWROb2RlIiwibG9hZGluZyIsImxhenlEYXRhIiwicnNjIiwicHJlZmV0Y2hSc2MiLCJwcmVmZXRjaEhlYWQiLCJzZXQiLCJleGlzdGluZ1BhcmFsbGVsUm91dGVzIl0sIm1hcHBpbmdzIjoiOzs7K0JBV2dCQSxpQ0FBQUE7OztlQUFBQTs7O3NDQU5xQjtvQ0FJOUI7QUFFQSxTQUFTQSw4QkFDZEMsV0FBbUIsRUFDbkJDLFFBQW1CLEVBQ25CQyxhQUFvQyxFQUNwQ0MsV0FBOEIsRUFDOUJDLGlCQUEyQyxFQUMzQ0MsSUFBcUIsRUFDckJDLGFBQTZDO0lB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RCxtQkFDQWhCLG9CQUNBSSxtQkFBbUJBLG1CQUFtQixNQUN0Q1gsTUFDQUM7Z0JBR0ZMLFNBQVNrQixjQUFjLENBQUNpQixHQUFHLENBQUN6QixLQUFLZTtnQkFDakM7WUFDRjtRQUNGO1FBRUEsSUFBSUc7UUFDSixJQUFJYixxQkFBcUIsTUFBTTtZQUM3QixxQ0FBcUM7WUFDckMsTUFBTWMsV0FBV2QsZ0JBQWdCLENBQUMsRUFBRTtZQUNwQyxNQUFNZSxVQUFVZixnQkFBZ0IsQ0FBQyxFQUFFO1lBQ25DYSxlQUFlO2dCQUNiRyxVQUFVO2dCQUNWQyxLQUFLSDtnQkFDTEksYUFBYTtnQkFDYjdCLE1BQU07Z0JBQ044QixjQUFjO2dCQUNkaEIsZ0JBQWdCLElBQUlRO2dCQUNwQkk7Z0JBQ0EvQjtZQUNGO1FBQ0YsT0FBTztZQUNMLGtFQUFrRTtZQUNsRSxpQkFBaUI7WUFDakI2QixlQUFlO2dCQUNiRyxVQUFVO2dCQUNWQyxLQUFLO2dCQUNMQyxhQUFhO2dCQUNiN0IsTUFBTTtnQkFDTjhCLGNBQWM7Z0JBQ2RoQixnQkFBZ0IsSUFBSVE7Z0JBQ3BCSSxTQUFTO2dCQUNUL0I7WUFDRjtRQUNGO1FBRUEsTUFBTXFDLHlCQUF5QnBDLFNBQVNrQixjQUFjLENBQUNDLEdBQUcsQ0FBQ1Q7UUFDM0QsSUFBSTBCLHdCQUF3QjtZQUMxQkEsdUJBQXVCRCxHQUFHLENBQUN0QixVQUFVZTtRQUN2QyxPQUFPO1lBQ0w1QixTQUFTa0IsY0FBYyxDQUFDaUIsR0FBRyxDQUFDekIsS0FBSyxJQUFJZ0IsSUFBSTtnQkFBQztvQkFBQ2I7b0JBQVVlO2lCQUFhO2FBQUM7UUFDckU7UUFFQTlCLDhCQUNFQyxhQUNBNkIsY0FDQVosV0FDQUwsb0JBQ0FJLGtCQUNBWCxNQUNBQztJQUVKO0FBQ0YiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMjA3MCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9pbnZhbGlkYXRlLWNhY2hlLWJ5LXJvdXRlci1zdGF0ZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IENhY2hlTm9kZSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHR5cGUgeyBGbGlnaHRSb3V0ZXJTdGF0ZSB9IGZyb20gJy4uLy4uLy4uL3NlcnZlci9hcHAtcmVuZGVyL3R5cGVzJ1xuaW1wb3J0IHsgY3JlYXRlUm91dGVyQ2FjaGVLZXkgfSBmcm9tICcuL2NyZWF0ZS1yb3V0ZXItY2FjaGUta2V5J1xuXG4vKipcbiAqIEludmFsaWRhdGUgY2FjaGUgb25lIGxldmVsIGRvd24gZnJvbSB0aGUgcm91dGVyIHN0YXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW52YWxpZGF0ZUNhY2hlQnlSb3V0ZXJTdGF0ZShcbiAgbmV3Q2FjaGU6IENhY2hlTm9kZSxcbiAgZXhpc3RpbmdDYWNoZTogQ2FjaGVOb2RlLFxuICByb3V0ZXJTdGF0ZTogRmxpZ2h0Um91dGVyU3RhdGVcbik6IHZvaWQge1xuICAvLyBSZW1vdmUgc2VnbWVudCB0aGF0IHdlIGdvdCBkYXRhIGZvciBzbyB0aGF0IGl0IGlzIGZpbGxlZCBpbiBkdXJpbmcgcmVuZGVyaW5nIG9mIHJzYy5cbiAgZm9yIChjb25zdCBrZXkgaW4gcm91dGVyU3RhdGVbMV0pIHtcbiAgICBjb25zdCBzZWdtZW50Rm9yUGFyYWxsZWxSb3V0ZSA9IHJvdXRlclN0YXRlWzFdW2tleV1bMF1cbiAgICBjb25zdCBjYWNoZUtleSA9IGNyZWF0ZVJvdXRlckNhY2hlS2V5KHNlZ21lbnRGb3JQYXJhbGxlbFJvdXRlKVxuICAgIGNvbnN0IGV4aXN0aW5nUGFyYWxsZWxSb3V0ZXNDYWNoZU5vZGUgPVxuICAgICAgZXhpc3RpbmdDYWNoZS5wYXJhbGxlbFJvdXRlcy5nZXQoa2V5KVxuICAgIGlmIChleGlzdGluZ1BhcmFsbGVsUm91dGVzQ2FjaGVOb2RlKSB7XG4gICAgICBsZXQgcGFyYWxsZWxSb3V0ZUNhY2hlTm9kZSA9IG5ldyBNYXAoZXhpc3RpbmdQYXJhbGxlbFJvdXRlc0NhY2hlTm9kZSlcbiAgICAgIHBhcmFsbGVsUm91dGVDYWNoZU5vZGUuZGVsZXRlKGNhY2hlS2V5KVxuICAgICAgbmV3Q2FjaGUucGFyYWxsZWxSb3V0ZXMuc2V0KGtleSwgcGFyYWxsZWxSb3V0ZUNhY2hlTm9kZSlcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJpbnZhbGlkYXRlQ2FjaGVCeVJvdXRlclN0YXRlIiwibmV3Q2FjaGUiLCJleGlzdGluZ0NhY2hlIiwicm91dGVyU3RhdGUiLCJrZXkiLCJzZWdtZW50Rm9yUGFyYWxsZWxSb3V0ZSIsImNhY2hlS2V5IiwiY3JlYXRlUm91dGVyQ2FjaGVLZXkiLCJleGlzdGluZ1BhcmFsbGVsUm91dGVzQ2FjaGVOb2RlIiwicGFyYWxsZWxSb3V0ZXMiLCJnZXQiLCJwYXJhbGxlbFJvdXRlQ2FjaGVOb2RlIiwiTWFwIiwiZGVsZXRlIiwic2V0Il0sIm1hcHBpbmdzIjoiOzs7K0JBT2dCQSxnQ0FBQUE7OztlQUFBQTs7O3NDQUxxQjtBQUs5QixTQUFTQSw2QkFDZEMsUUFBbUIsRUFDbkJDLGFBQXdCLEVBQ3hCQyxXQUE4QjtJQUU5Qix1RkFBdUY7SUFDdkYsSUFBSyxNQUFNQyxPQUFPRCxXQUFXLENBQUMsRUFBRSxDQUFFO1FBQ2hDLE1BQU1FLDBCQUEwQkYsV0FBVyxDQUFDLEVBQUUsQ0FBQ0MsSUFBSSxDQUFDLEVBQUU7UUFDdEQsTUFBTUUsV0FBV0MsQ0FBQUEsR0FBQUEsc0JBQUFBLG9CQUFvQixFQUFDRjtRQUN0QyxNQUFNRyxrQ0FDSk4sY0FBY08sY0FBYyxDQUFDQyxHQUFHLENBQUNOO1FBQ25DLElBQUlJLGlDQUFpQztZQUNuQyxJQUFJRyx5QkFBeUIsSUFBSUMsSUFBSUo7WUFDckNHLHVCQUF1QkUsTUFBTSxDQUFDUDtZQUM5QkwsU0FBU1EsY0FBYyxDQUFDSyxHQUFHLENBQUNWLEtBQUtPO1FBQ25DO0lBQ0Y7QUFDRiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAyMTA2LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2ZpbGwtY2FjaGUtd2l0aC1uZXctc3VidHJlZS1kYXRhLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgQ2FjaGVOb2RlIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgdHlwZSB7IFNlZ21lbnQgfSBmcm9tICcuLi8uLi8uLi9zZXJ2ZXIvYXBwLXJlbmRlci90eXBlcydcbmltcG9ydCB7IGludmFsaWRhdGVDYWNoZUJ5Um91dGVyU3RhdGUgfSBmcm9tICcuL2ludmFsaWRhdGUtY2FjaGUtYnktcm91dGVyLXN0YXRlJ1xuaW1wb3J0IHsgZmlsbExhenlJdGVtc1RpbGxMZWFmV2l0aEhlYWQgfSBmcm9tICcuL2ZpbGwtbGF6eS1pdGVtcy10aWxsLWxlYWYtd2l0aC1oZWFkJ1xuaW1wb3J0IHsgY3JlYXRlUm91dGVyQ2FjaGVLZXkgfSBmcm9tICcuL2NyZWF0ZS1yb3V0ZXItY2FjaGUta2V5J1xuaW1wb3J0IHR5cGUgeyBQcmVmZXRjaENhY2hlRW50cnkgfSBmcm9tICcuL3JvdXRlci1yZWR1Y2VyLXR5cGVzJ1xuaW1wb3J0IHsgUEFHRV9TRUdNRU5UX0tFWSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9saWIvc2VnbWVudCdcbmltcG9ydCB0eXBlIHsgTm9ybWFsaXplZEZsaWdodERhdGEgfSBmcm9tICcuLi8uLi9mbGlnaHQtZGF0YS1oZWxwZXJzJ1xuXG4vKipcbiAqIENvbW1vbiBsb2dpYyBmb3IgZmlsbGluZyBjYWNoZSB3aXRoIG5ldyBzdWIgdHJlZSBkYXRhLlxuICovXG5mdW5jdGlvbiBmaWxsQ2FjaGVIZWxwZXIoXG4gIG5hdmlnYXRlZEF0OiBudW1iZXIsXG4gIG5ld0NhY2hlOiBDYWNoZU5vZGUsXG4gIGV4aXN0aW5nQ2FjaGU6IENhY2hlTm9kZSxcbiAgZmxpZ2h0RGF0YTogTm9ybWFsaXplZEZsaWdodERhdGEsXG4gIHByZWZldGNoRW50cnk6IFByZWZldGNoQ2FjaGVFbnRyeSB8IHVuZGVmaW5lZCxcbiAgZmlsbExhenlJdGVtczogYm9vbGVhblxuKTogdm9pZCB7XG4gIGNvbnN0IHtcbiAgICBzZWdtZW50UGF0aCxcbiAgICBzZWVkRGF0YTogY2FjaGVOb2RlU2VlZERhdGEsXG4gICAgdHJlZTogdHJlZVBhdGNoLFxuICAgIGhlYWQsXG4gIH0gPSBmbGlnaHREYXRhXG4gIGxldCBuZXdDYWNoZU5vZGUgPSBuZXdDYWNoZVxuICBsZXQgZXhpc3RpbmdDYWNoZU5vZGUgPSBleGlzdGluZ0NhY2hlXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50UGF0aC5sZW5ndGg7IGkgKz0gMikge1xuICAgIGNvbnN0IHBhcmFsbGVsUm91dGVLZXk6IHN0cmluZyA9IHNlZ21lbnRQYXRoW2ldXG4gICAgY29uc3Qgc2VnbWVudDogU2VnbWVudCA9IHNlZ21lbnRQYXRoW2kgKyAxXVxuXG4gICAgLy8gc2VnbWVudFBhdGggaXMgYSByZXBlYXRpbmcgdHVwbGUgb2YgcGFyYWxsZWxSb3V0ZUtleSBhbmQgc2VnbWVudFxuICAgIC8vIHdlIGtub3cgd2UndmUgaGl0IHRoZSBsYXN0IGVudHJ5IHdlJ3ZlIHJlYWNoZWQgb3VyIGZpbmFsIHBhaXJcbiAgICBjb25zdCBpc0xhc3RFbnRyeSA9IGkgPT09IHNlZ21lbnRQYXRoLmxlbmd0aCAtIDJcbiAgICBjb25zdCBjYWNoZUtleSA9IGNyZWF0ZVJvdXRlckNhY2hlS2V5KHNlZ21lbnQpXG5cbiAgICBjb25zdCBleGlzdGluZ0NoaWxkU2VnbWVudE1hcCA9XG4gICAgICBleGlzdGluZ0NhY2hlTm9kZS5wYXJhbGxlbFJvdXRlcy5nZXQocGFyYWxsZWxSb3V0ZUtleSlcblxuICAgIGlmICghZXhpc3RpbmdDaGlsZFNlZ21lbnRNYXApIHtcbiAgICAgIC8vIEJhaWxvdXQgYmVjYXVzZSB0aGUgZXhpc3RpbmcgY2FjaGUgZG9lcyBub3QgaGF2ZSB0aGUgcGF0aCB0byB0aGUgbGVhZiBub2RlXG4gICAgICAvLyBXaWxsIHRyaWdnZXIgbGF6eSBmZXRjaCBpbiBsYXlvdXQtcm91dGVyIGJlY2F1c2Ugb2YgbWlzc2luZyBzZWdtZW50XG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGxldCBjaGlsZFNlZ21lbnRNYXAgPSBuZXdDYWNoZU5vZGUucGFyYWxsZWxSb3V0ZXMuZ2V0KHBhcmFsbGVsUm91dGVLZXkpXG4gICAgaWYgKCFjaGlsZFNlZ21lbnRNYXAgfHwgY2hpbGRTZWdtZW50TWFwID09PSBleGlzdGluZ0NoaWxkU2VnbWVudE1hcCkge1xuICAgICAgY2hpbGRTZWdtZW50TWFwID0gbmV3IE1hcChleGlzdGluZ0NoaWxkU2VnbWVudE1hcClcbiAgICAgIG5ld0NhY2hlTm9kZS5wYXJhbGxlbFJvdXRlcy5zZXQocGFyYWxsZWxSb3V0ZUtleSwgY2hpbGRTZWdtZW50TWFwKVxuICAgIH1cblxuICAgIGNvbnN0IGV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUgPSBleGlzdGluZ0NoaWxkU2VnbWVudE1hcC5nZXQoY2FjaGVLZXkpXG4gICAgbGV0IGNoaWxkQ2FjaGVOb2RlID0gY2hpbGRTZWdtZW50TWFwLmdldChjYWNoZUtleSlcblxuICAgIGlmIChpc0xhc3RFbnRyeSkge1xuICAgICAgaWYgKFxuICAgICAgICBjYWNoZU5vZGVTZWVkRGF0YSAmJlxuICAgICAgICAoIWNoaWxkQ2FjaGVOb2RlIHx8XG4gICAgICAgICAgIWNoaWxkQ2FjaGVOb2RlLmxhenlEYXRhIHx8XG4gICAgICAgICAgY2hpbGRDYWNoZU5vZGUgPT09IGV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUpXG4gICAgICApIHtcbiAgICAgICAgY29uc3QgaW5jb21pbmdTZWdtZW50ID0gY2FjaGVOb2RlU2VlZERhdGFbMF1cbiAgICAgICAgY29uc3QgcnNjID0gY2FjaGVOb2RlU2VlZERhdGFbMV1cbiAgICAgICAgY29uc3QgbG9hZGluZyA9IGNhY2hlTm9kZVNlZWREYXRhWzNdXG5cbiAgICAgICAgY2hpbGRDYWNoZU5vZGUgPSB7XG4gICAgICAgICAgbGF6eURhdGE6IG51bGwsXG4gICAgICAgICAgLy8gV2hlbiBgZmlsbExhenlJdGVtc2AgaXMgZmFsc2UsIHdlIG9ubHkgd2FudCB0byBmaWxsIHRoZSBSU0MgZGF0YSBmb3IgdGhlIGxheW91dCxcbiAgICAgICAgICAvLyBub3QgdGhlIHBhZ2Ugc2VnbWVudC5cbiAgICAgICAgICByc2M6XG4gICAgICAgICAgICBmaWxsTGF6eUl0ZW1zIHx8IGluY29taW5nU2VnbWVudCAhPT0gUEFHRV9TRUdNRU5UX0tFWSA/IHJzYyA6IG51bGwsXG4gICAgICAgICAgcHJlZmV0Y2hSc2M6IG51bGwsXG4gICAgICAgICAgaGVhZDogbnVsbCxcbiAgICAgICAgICBwcmVmZXRjaEhlYWQ6IG51bGwsXG4gICAgICAgICAgbG9hZGluZyxcbiAgICAgICAgICBwYXJhbGxlbFJvdXRlczpcbiAgICAgICAgICAgIGZpbGxMYXp5SXRlbXMgJiYgZXhpc3RpbmdDaGlsZENhY2hlTm9kZVxuICAgICAgICAgICAgICA/IG5ldyBNYXAoZXhpc3RpbmdDaGlsZENhY2hlTm9kZS5wYXJhbGxlbFJvdXRlcylcbiAgICAgICAgICAgICAgOiBuZXcgTWFwKCksXG4gICAgICAgICAgbmF2aWdhdGVkQXQsXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXhpc3RpbmdDaGlsZENhY2hlTm9kZSAmJiBmaWxsTGF6eUl0ZW1zKSB7XG4gICAgICAgICAgaW52YWxpZGF0ZUNhY2hlQnlSb3V0ZXJTdGF0ZShcbiAgICAgICAgICAgIGNoaWxkQ2FjaGVOb2RlLFxuICAgICAgICAgICAgZXhpc3RpbmdDaGlsZENhY2hlTm9kZSxcbiAgICAgICAgICAgIHRyZWVQYXRjaFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlsbExhenlJdGVtcykge1xuICAgICAgICAgIGZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkKFxuICAgICAgICAgICAgbmF2aWdhdGVkQXQsXG4gICAgICAgICAgICBjaGlsZENhY2hlTm9kZSxcbiAgICAgICAgICAgIGV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUsXG4gICAgICAgICAgICB0cmVlUGF0Y2gsXG4gICAgICAgICAgICBjYWNoZU5vZGVTZWVkRGF0YSxcbiAgICAgICAgICAgIGhlYWQsXG4gICAgICAgICAgICBwcmVmZXRjaEVudHJ5XG4gICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGRTZWdtZW50TWFwLnNldChjYWNoZUtleSwgY2hpbGRDYWNoZU5vZGUpXG4gICAgICB9XG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGlmICghY2hpbGRDYWNoZU5vZGUgfHwgIWV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUpIHtcbiAgICAgIC8vIEJhaWxvdXQgYmVjYXVzZSB0aGUgZXhpc3RpbmcgY2FjaGUgZG9lcyBub3QgaGF2ZSB0aGUgcGF0aCB0byB0aGUgbGVhZiBub2RlXG4gICAgICAvLyBXaWxsIHRyaWdnZXIgbGF6eSBmZXRjaCBpbiBsYXlvdXQtcm91dGVyIGJlY2F1c2Ugb2YgbWlzc2luZyBzZWdtZW50XG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGlmIChjaGlsZENhY2hlTm9kZSA9PT0gZXhpc3RpbmdDaGlsZENhY2hlTm9kZSkge1xuICAgICAgY2hpbGRDYWNoZU5vZGUgPSB7XG4gICAgICAgIGxhenlEYXRhOiBjaGlsZENhY2hlTm9kZS5sYXp5RGF0YSxcbiAgICAgICAgcnNjOiBjaGlsZENhY2hlTm9kZS5yc2MsXG4gICAgICAgIHByZWZldGNoUnNjOiBjaGlsZENhY2hlTm9kZS5wcmVmZXRjaFJzYyxcbiAgICAgICAgaGVhZDogY2hpbGRDYWNoZU5vZGUuaGVhZCxcbiAgICAgICAgcHJlZmV0Y2hIZWFkOiBjaGlsZENhY2hlTm9kZS5wcmVmZXRjaEhlYWQsXG4gICAgICAgIHBhcmFsbGVsUm91dGVzOiBuZXcgTWFwKGNoaWxkQ2FjaGVOb2RlLnBhcmFsbGVsUm91dGVzKSxcbiAgICAgICAgbG9hZGluZzogY2hpbGRDYWNoZU5vZGUubG9hZGluZyxcbiAgICAgIH0gYXMgQ2FjaGVOb2RlXG4gICAgICBjaGlsZFNlZ21lbnRNYXAuc2V0KGNhY2hlS2V5LCBjaGlsZENhY2hlTm9kZSlcbiAgICB9XG5cbiAgICAvLyBNb3ZlIGRlZXBlciBpbnRvIHRoZSBjYWNoZSBub2Rlc1xuICAgIG5ld0NhY2hlTm9kZSA9IGNoaWxkQ2FjaGVOb2RlXG4gICAgZXhpc3RpbmdDYWNoZU5vZGUgPSBleGlzdGluZ0NoaWxkQ2FjaGVOb2RlXG4gIH1cbn1cblxuLyoqXG4gKiBGaWxsIGNhY2hlIHdpdGggcnNjIGJhc2VkIG9uIGZsaWdodERhdGFQYXRoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaWxsQ2FjaGVXaXRoTmV3U3ViVHJlZURhdGEoXG4gIG5hdmlnYXRlZEF0OiBudW1iZXIsXG4gIG5ld0NhY2hlOiBDYWNoZU5vZGUsXG4gIGV4aXN0aW5nQ2FjaGU6IENhY2hlTm9kZSxcbiAgZmxpZ2h0RGF0YTogTm9ybWFsaXplZEZsaWdodERhdGEsXG4gIHByZWZldGNoRW50cnk/OiBQcmVmZXRjaENhY2hlRW50cnlcbik6IHZvaWQge1xuICBmaWxsQ2FjaGVIZWxwZXIoXG4gICAgbmF2aWdhdGVkQXQsXG4gICAgbmV3Q2FjaGUsXG4gICAgZXhpc3RpbmdDYWNoZSxcbiAgICBmbGlnaHREYXRhLFxuICAgIHByZWZldGNoRW50cnksXG4gICAgdHJ1ZVxuICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaWxsQ2FjaGVXaXRoTmV3U3ViVHJlZURhdGFCdXRPbmx5TG9hZGluZyhcbiAgbmF2aWdhdGVkQXQ6IG51bWJlcixcbiAgbmV3Q2FjaGU6IENhY2hlTm9kZSxcbiAgZXhpc3RpbmdDYWNoZTogQ2FjaGVOb2RlLFxuICBmbGlnaHREYXRhOiBOb3JtYWxpemVkRmxpZ2h0RGF0YSxcbiAgcHJlZmV0Y2hFbnRyeT86IFByZWZldGNoQ2FjaGVFbnRyeVxuKTogdm9pZCB7XG4gIGZpbGxDYWNoZUhlbHBlcihcbiAgICBuYXZpZ2F0ZWRBdCxcbiAgICBuZXdDYWNoZSxcbiAgICBleGlzdGluZ0NhY2hlLFxuICAgIGZsaWdodERhdGEsXG4gICAgcHJlZmV0Y2hFbnRyeSxcbiAgICBmYWxzZVxuICApXG59XG4iXSwibmFtZXMiOlsiZmlsbENhY2hlV2l0aE5ld1N1YlRyZWVEYXRhIiwiZmlsbENhY2hlV2l0aE5ld1N1YlRyZWVEYXRhQnV0T25seUxvYWRpbmciLCJmaWxsQ2FjaGVIZWxwZXIiLCJuYXZpZ2F0ZWRBdCIsIm5ld0NhY2hlIiwiZXhpc3RpbmdDYWNoZSIsImZsaWdodERhdGEiLCJwcmVmZXRjaEVudHJ5IiwiZmlsbExhenlJdGVtcyIsInNlZ21lbnRQYXRoIiwic2VlZERhdGEiLCJjYWNoZU5vZGVTZWVkRGF0YSIsInRyZWUiLCJ0cmVlUGF0Y2giLCJoZWFkIiwibmV3Q2FjaGVOb2RlIiwiZXhpc3RpbmdDYWNoZU5vZGUiLCJpIiwibGVuZ3RoIiwicGFyYWxsZWxSb3V0ZUtleSIsInNlZ21lbnQiLCJpc0xhc3RFbnRyeSIsImNhY2hlS2V5IiwiY3JlYXRlUm91dGVyQ2FjaGVLZXkiLCJleGlzdGluZ0NoaWxkU2VnbWVudE1hcCIsInBhcmFsbGVsUm91dGVzIiwiZ2V0IiwiY2hpbGRTZWdtZW50TWFwIiwiTWFwIiwic2V0IiwiZXhpc3RpbmdDaGlsZENhY2hlTm9kZSIsImNoaWxkQ2FjaGVOb2RlIiwibGF6eURhdGEiLCJpbmNvbWluZ1NlZ21lbnQiLCJyc2MiLCJsb2FkaW5nIiwiUEFHRV9TRUdNRU5UX0tFWSIsInByZWZldGNoUnNjIiwicHJlZmV0Y2hIZWFkIiwiaW52YWxpZGF0ZUNhY2hlQnlSb3V0ZXJTdGF0ZSIsImZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztJQXdJZ0JBLDJCQUEyQixFQUFBO2VBQTNCQTs7SUFpQkFDLHlDQUF5QyxFQUFBO2VBQXpDQTs7OzhDQXZKNkI7K0NBQ0M7c0NBQ1Q7eUJBRUo7QUFHakM7O0NBRUMsR0FDRCxTQUFTQyxnQkFDUEMsV0FBbUIsRUFDbkJDLFFBQW1CLEVBQ25CQyxhQUF3QixFQUN4QkMsVUFBZ0MsRUFDaENDLGFBQTZDLEVBQzdDQyxhQUFzQjtJQUV0QixNQUFNLEVBQ0pDLFdBQVcsRUFDWEMsVUFBVUMsaUJBQWlCLEVBQzNCQyxNQUFNQyxTQUFTLEVBQ2ZDLElBQUksRUFDTCxHQUFHUjtJQUNKLElBQUlTLGVBQWVYO0lBQ25CLElBQUlZLG9CQUFvQlg7SUFFeEIsSUFBSyxJQUFJWSxJQUFJLEdBQUdBLElBQUlSLFlBQVlTLE1BQU0sRUFBRUQsS0FBSyxFQUFHO1FBQzlDLE1BQU1FLG1CQUEyQlYsV0FBVyxDQUFDUSxFQUFFO1FBQy9DLE1BQU1HLFVBQW1CWCxXQUFXLENBQUNRLElBQUksRUFBRTtRQUUzQyxtRUFBbUU7UUFDbkUsZ0VBQWdFO1FBQ2hFLE1BQU1JLGNBQWNKLE1BQU1SLFlBQVlTLE1BQU0sR0FBRztRQUMvQyxNQUFNSSxXQUFXQyxDQUFBQSxHQUFBQSxzQkFBQUEsb0JBQW9CLEVBQUNIO1FBRXRDLE1BQU1JLDBCQUNKUixrQkFBa0JTLGNBQWMsQ0FBQ0MsR0FBRyxDQUFDUDtRQUV2QyxJQUFJLENBQUNLLHlCQUF5QjtZQUc1QjtRQUNGO1FBRUEsSUFBSUcsa0JBQWtCWixhQUFhVSxjQUFjLENBQUNDLEdBQUcsQ0FBQ1A7UUFDdEQsSUFBSSxDQUFDUSxtQkFBbUJBLG9CQUFvQkgseUJBQXlCO1lBQ25FRyxrQkFBa0IsSUFBSUMsSUFBSUo7WUFDMUJULGFBQWFVLGNBQWMsQ0FBQ0ksR0FBRyxDQUFDVixrQkFBa0JRO1FBQ3BEO1FBRUEsTUFBTUcseUJBQXlCTix3QkFBd0JFLEdBQUcsQ0FBQ0o7UUFDM0QsSUFBSVMsaUJBQWlCSixnQkFBZ0JELEdBQUcsQ0FBQ0o7UUFFekMsSUFBSUQsYUFBYTtZQUNmLElBQ0VWLHFCQUNDLENBQUEsQ0FBQ29CLGtCQUNBLENBQUNBLGVBQWVDLFFBQVEsSUFDeEJELG1CQUFtQkQsc0JBQXFCLEdBQzFDO2dCQUNBLE1BQU1HLGtCQUFrQnRCLGlCQUFpQixDQUFDLEVBQUU7Z0JBQzVDLE1BQU11QixNQUFNdkIsaUJBQWlCLENBQUMsRUFBRTtnQkFDaEMsTUFBTXdCLFVBQVV4QixpQkFBaUIsQ0FBQyxFQUFFO2dCQUVwQ29CLGlCQUFpQjtvQkFDZkMsVUFBVTtvQkFDVixtRkFBbUY7b0JBQ25GLHdCQUF3QjtvQkFDeEJFLEtBQ0UxQixpQkFBaUJ5QixvQkFBb0JHLFNBQUFBLGdCQUFnQixHQUFHRixNQUFNO29CQUNoRUcsYUFBYTtvQkFDYnZCLE1BQU07b0JBQ053QixjQUFjO29CQUNkSDtvQkFDQVYsZ0JBQ0VqQixpQkFBaUJzQix5QkFDYixJQUFJRixJQUFJRSx1QkFBdUJMLGNBQWMsSUFDN0MsSUFBSUc7b0JBQ1Z6QjtnQkFDRjtnQkFFQSxJQUFJMkIsMEJBQTBCdEIsZUFBZTtvQkFDM0MrQixDQUFBQSxHQUFBQSw4QkFBQUEsNEJBQTRCLEVBQzFCUixnQkFDQUQsd0JBQ0FqQjtnQkFFSjtnQkFDQSxJQUFJTCxlQUFlO29CQUNqQmdDLENBQUFBLEdBQUFBLCtCQUFBQSw2QkFBNkIsRUFDM0JyQyxhQUNBNEIsZ0JBQ0FELHdCQUNBakIsV0FDQUYsbUJBQ0FHLE1BQ0FQO2dCQUVKO2dCQUVBb0IsZ0JBQWdCRSxHQUFHLENBQUNQLFVBQVVTO1lBQ2hDO1lBQ0E7UUFDRjtRQUVBLElBQUksQ0FBQ0Esa0JBQWtCLENBQUNELHdCQUF3QjtZQUc5QztRQUNGO1FBRUEsSUFBSUMsbUJBQW1CRCx3QkFBd0I7WUFDN0NDLGlCQUFpQjtnQkFDZkMsVUFBVUQsZUFBZUMsUUFBUTtnQkFDakNFLEtBQUtILGVBQWVHLEdBQUc7Z0JBQ3ZCRyxhQUFhTixlQUFlTSxXQUFXO2dCQUN2Q3ZCLE1BQU1pQixlQUFlakIsSUFBSTtnQkFDekJ3QixjQUFjUCxlQUFlTyxZQUFZO2dCQUN6Q2IsZ0JBQWdCLElBQUlHLElBQUlHLGVBQWVOLGNBQWM7Z0JBQ3JEVSxTQUFTSixlQUFlSSxPQUFPO1lBQ2pDO1lBQ0FSLGdCQUFnQkUsR0FBRyxDQUFDUCxVQUFVUztRQUNoQztRQUVBLG1DQUFtQztRQUNuQ2hCLGVBQWVnQjtRQUNmZixvQkFBb0JjO0lBQ3RCO0FBQ0Y7QUFLTyxTQUFTOUIsNEJBQ2RHLFdBQW1CLEVBQ25CQyxRQUFtQixFQUNuQkMsYUFBd0IsRUFDeEJDLFVBQWdDLEVBQ2hDQyxhQUFrQztJQUVsQ0wsZ0JBQ0VDLGFBQ0FDLFVBQ0FDLGVBQ0FDLFlBQ0FDLGVBQ0E7QUFFSjtBQUVPLFNBQVNOLDBDQUNkRSxXQUFtQixFQUNuQkMsUUFBbUIsRUFDbkJDLGFBQXdCLEVBQ3hCQyxVQUFnQyxFQUNoQ0MsYUFBa0M7SUFFbENMLGdCQUNFQyxhQUNBQyxVQUNBQyxlQUNBQyxZQUNBQyxlQUNBO0FBRUoiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMjIyMSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9hcHBseS1mbGlnaHQtZGF0YS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IENhY2hlTm9kZSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHsgZmlsbExhenlJdGVtc1RpbGxMZWFmV2l0aEhlYWQgfSBmcm9tICcuL2ZpbGwtbGF6eS1pdGVtcy10aWxsLWxlYWYtd2l0aC1oZWFkJ1xuaW1wb3J0IHsgZmlsbENhY2hlV2l0aE5ld1N1YlRyZWVEYXRhIH0gZnJvbSAnLi9maWxsLWNhY2hlLXdpdGgtbmV3LXN1YnRyZWUtZGF0YSdcbmltcG9ydCB0eXBlIHsgUHJlZmV0Y2hDYWNoZUVudHJ5IH0gZnJvbSAnLi9yb3V0ZXItcmVkdWNlci10eXBlcydcbmltcG9ydCB0eXBlIHsgTm9ybWFsaXplZEZsaWdodERhdGEgfSBmcm9tICcuLi8uLi9mbGlnaHQtZGF0YS1oZWxwZXJzJ1xuXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlGbGlnaHREYXRhKFxuICBuYXZpZ2F0ZWRBdDogbnVtYmVyLFxuICBleGlzdGluZ0NhY2hlOiBDYWNoZU5vZGUsXG4gIGNhY2hlOiBDYWNoZU5vZGUsXG4gIGZsaWdodERhdGE6IE5vcm1hbGl6ZWRGbGlnaHREYXRhLFxuICBwcmVmZXRjaEVudHJ5PzogUHJlZmV0Y2hDYWNoZUVudHJ5XG4pOiBib29sZWFuIHtcbiAgLy8gVGhlIG9uZSBiZWZvcmUgbGFzdCBpdGVtIGlzIHRoZSByb3V0ZXIgc3RhdGUgdHJlZSBwYXRjaFxuICBjb25zdCB7IHRyZWU6IHRyZWVQYXRjaCwgc2VlZERhdGEsIGhlYWQsIGlzUm9vdFJlbmRlciB9ID0gZmxpZ2h0RGF0YVxuXG4gIC8vIEhhbmRsZXMgY2FzZSB3aGVyZSBwcmVmZXRjaCBvbmx5IHJldHVybnMgdGhlIHJvdXRlciB0cmVlIHBhdGNoIHdpdGhvdXQgcmVuZGVyZWQgY29tcG9uZW50cy5cbiAgaWYgKHNlZWREYXRhID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBpZiAoaXNSb290UmVuZGVyKSB7XG4gICAgY29uc3QgcnNjID0gc2VlZERhdGFbMV1cbiAgICBjb25zdCBsb2FkaW5nID0gc2VlZERhdGFbM11cbiAgICBjYWNoZS5sb2FkaW5nID0gbG9hZGluZ1xuICAgIGNhY2hlLnJzYyA9IHJzY1xuICAgIC8vIFRoaXMgaXMgYSBQUFItb25seSBmaWVsZC4gV2hlbiBQUFIgaXMgZW5hYmxlZCwgd2Ugc2hvdWxkbid0IGhpdFxuICAgIC8vIHRoaXMgcGF0aCBkdXJpbmcgYSBuYXZpZ2F0aW9uLCBidXQgdW50aWwgUFBSIGlzIGZ1bGx5IGltcGxlbWVudGVkXG4gICAgLy8geWV0IGl0J3MgcG9zc2libGUgdGhlIGV4aXN0aW5nIG5vZGUgZG9lcyBoYXZlIGEgbm9uLW51bGxcbiAgICAvLyBgcHJlZmV0Y2hSc2NgLiBBcyBhbiBpbmNyZW1lbnRhbCBzdGVwLCB3ZSdsbCBqdXN0IGRlLW9wdCB0byB0aGVcbiAgICAvLyBvbGQgYmVoYXZpb3Ig4oCUIG5vIFBQUiB2YWx1ZS5cbiAgICBjYWNoZS5wcmVmZXRjaFJzYyA9IG51bGxcbiAgICBmaWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZChcbiAgICAgIG5hdmlnYXRlZEF0LFxuICAgICAgY2FjaGUsXG4gICAgICBleGlzdGluZ0NhY2hlLFxuICAgICAgdHJlZVBhdGNoLFxuICAgICAgc2VlZERhdGEsXG4gICAgICBoZWFkLFxuICAgICAgcHJlZmV0Y2hFbnRyeVxuICAgIClcbiAgfSBlbHNlIHtcbiAgICAvLyBDb3B5IHJzYyBmb3IgdGhlIHJvb3Qgbm9kZSBvZiB0aGUgY2FjaGUuXG4gICAgY2FjaGUucnNjID0gZXhpc3RpbmdDYWNoZS5yc2NcbiAgICAvLyBUaGlzIGlzIGEgUFBSLW9ubHkgZmllbGQuIFVubGlrZSB0aGUgcHJldmlvdXMgYnJhbmNoLCBzaW5jZSB3ZSdyZVxuICAgIC8vIGp1c3QgY2xvbmluZyB0aGUgZXhpc3RpbmcgY2FjaGUgbm9kZSwgd2UgbWlnaHQgYXMgd2VsbCBrZWVwIHRoZVxuICAgIC8vIFBQUiB2YWx1ZSwgaWYgaXQgZXhpc3RzLlxuICAgIGNhY2hlLnByZWZldGNoUnNjID0gZXhpc3RpbmdDYWNoZS5wcmVmZXRjaFJzY1xuICAgIGNhY2hlLnBhcmFsbGVsUm91dGVzID0gbmV3IE1hcChleGlzdGluZ0NhY2hlLnBhcmFsbGVsUm91dGVzKVxuICAgIGNhY2hlLmxvYWRpbmcgPSBleGlzdGluZ0NhY2hlLmxvYWRpbmdcbiAgICAvLyBDcmVhdGUgYSBjb3B5IG9mIHRoZSBleGlzdGluZyBjYWNoZSB3aXRoIHRoZSByc2MgYXBwbGllZC5cbiAgICBmaWxsQ2FjaGVXaXRoTmV3U3ViVHJlZURhdGEoXG4gICAgICBuYXZpZ2F0ZWRBdCxcbiAgICAgIGNhY2hlLFxuICAgICAgZXhpc3RpbmdDYWNoZSxcbiAgICAgIGZsaWdodERhdGEsXG4gICAgICBwcmVmZXRjaEVudHJ5XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cbiJdLCJuYW1lcyI6WyJhcHBseUZsaWdodERhdGEiLCJuYXZpZ2F0ZWRBdCIsImV4aXN0aW5nQ2FjaGUiLCJjYWNoZSIsImZsaWdodERhdGEiLCJwcmVmZXRjaEVudHJ5IiwidHJlZSIsInRyZWVQYXRjaCIsInNlZWREYXRhIiwiaGVhZCIsImlzUm9vdFJlbmRlciIsInJzYyIsImxvYWRpbmciLCJwcmVmZXRjaFJzYyIsImZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkIiwicGFyYWxsZWxSb3V0ZXMiLCJNYXAiLCJmaWxsQ2FjaGVXaXRoTmV3U3ViVHJlZURhdGEiXSwibWFwcGluZ3MiOiI7OzsrQkFNZ0JBLG1CQUFBQTs7O2VBQUFBOzs7K0NBTDhCOzZDQUNGO0FBSXJDLFNBQVNBLGdCQUNkQyxXQUFtQixFQUNuQkMsYUFBd0IsRUFDeEJDLEtBQWdCLEVBQ2hCQyxVQUFnQyxFQUNoQ0MsYUFBa0M7SUFFbEMsMERBQTBEO0lBQzFELE1BQU0sRUFBRUMsTUFBTUMsU0FBUyxFQUFFQyxRQUFRLEVBQUVDLElBQUksRUFBRUMsWUFBWSxFQUFFLEdBQUdOO0lBRTFELDhGQUE4RjtJQUM5RixJQUFJSSxhQUFhLE1BQU07UUFDckIsT0FBTztJQUNUO0lBRUEsSUFBSUUsY0FBYztRQUNoQixNQUFNQyxNQUFNSCxRQUFRLENBQUMsRUFBRTtRQUN2QixNQUFNSSxVQUFVSixRQUFRLENBQUMsRUFBRTtRQUMzQkwsTUFBTVMsT0FBTyxHQUFHQTtRQUNoQlQsTUFBTVEsR0FBRyxHQUFHQTtRQUNaLGtFQUFrRTtRQUNsRSxvRUFBb0U7UUFDcEUsMkRBQTJEO1FBQzNELGtFQUFrRTtRQUNsRSwrQkFBK0I7UUFDL0JSLE1BQU1VLFdBQVcsR0FBRztRQUNwQkMsQ0FBQUEsR0FBQUEsK0JBQUFBLDZCQUE2QixFQUMzQmIsYUFDQUUsT0FDQUQsZUFDQUssV0FDQUMsVUFDQUMsTUFDQUo7SUFFSixPQUFPO1FBQ0wsMkNBQTJDO1FBQzNDRixNQUFNUSxHQUFHLEdBQUdULGNBQWNTLEdBQUc7UUFDN0Isb0VBQW9FO1FBQ3BFLGtFQUFrRTtRQUNsRSwyQkFBMkI7UUFDM0JSLE1BQU1VLFdBQVcsR0FBR1gsY0FBY1csV0FBVztRQUM3Q1YsTUFBTVksY0FBYyxHQUFHLElBQUlDLElBQUlkLGNBQWNhLGNBQWM7UUFDM0RaLE1BQU1TLE9BQU8sR0FBR1YsY0FBY1UsT0FBTztRQUNyQyw0REFBNEQ7UUFDNURLLENBQUFBLEdBQUFBLDZCQUFBQSwyQkFBMkIsRUFDekJoQixhQUNBRSxPQUNBRCxlQUNBRSxZQUNBQztJQUVKO0lBRUEsT0FBTztBQUNUIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDIyNzgsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVmZXRjaC1pbmFjdGl2ZS1wYXJhbGxlbC1zZWdtZW50cy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IEZsaWdodFJvdXRlclN0YXRlIH0gZnJvbSAnLi4vLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvdHlwZXMnXG5pbXBvcnQgdHlwZSB7IENhY2hlTm9kZSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHR5cGUgeyBBcHBSb3V0ZXJTdGF0ZSB9IGZyb20gJy4vcm91dGVyLXJlZHVjZXItdHlwZXMnXG5pbXBvcnQgeyBhcHBseUZsaWdodERhdGEgfSBmcm9tICcuL2FwcGx5LWZsaWdodC1kYXRhJ1xuaW1wb3J0IHsgZmV0Y2hTZXJ2ZXJSZXNwb25zZSB9IGZyb20gJy4vZmV0Y2gtc2VydmVyLXJlc3BvbnNlJ1xuaW1wb3J0IHsgUEFHRV9TRUdNRU5UX0tFWSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9saWIvc2VnbWVudCdcblxuaW50ZXJmYWNlIFJlZnJlc2hJbmFjdGl2ZVBhcmFsbGVsU2VnbWVudHMge1xuICBuYXZpZ2F0ZWRBdDogbnVtYmVyXG4gIHN0YXRlOiBBcHBSb3V0ZXJTdGF0ZVxuICB1cGRhdGVkVHJlZTogRmxpZ2h0Um91dGVyU3RhdGVcbiAgdXBkYXRlZENhY2hlOiBDYWNoZU5vZGVcbiAgaW5jbHVkZU5leHRVcmw6IGJvb2xlYW5cbiAgY2Fub25pY2FsVXJsOiBzdHJpbmdcbn1cblxuLyoqXG4gKiBSZWZyZXNoZXMgaW5hY3RpdmUgc2VnbWVudHMgdGhhdCBhcmUgc3RpbGwgaW4gdGhlIGN1cnJlbnQgRmxpZ2h0Um91dGVyU3RhdGUuXG4gKiBBIHNlZ21lbnQgaXMgY29uc2lkZXJlZCBcImluYWN0aXZlXCIgd2hlbiB0aGUgc2VydmVyIHJlc3BvbnNlIGluZGljYXRlcyBpdCBkaWRuJ3QgbWF0Y2ggdG8gYSBwYWdlIGNvbXBvbmVudC5cbiAqIFRoaXMgaGFwcGVucyBkdXJpbmcgYSBzb2Z0LW5hdmlnYXRpb24sIHdoZXJlIHRoZSBzZXJ2ZXIgd2lsbCB3YW50IHRvIHBhdGNoIGluIHRoZSBzZWdtZW50XG4gKiB3aXRoIHRoZSBcImRlZmF1bHRcIiBjb21wb25lbnQsIGJ1dCB3ZSBleHBsaWNpdGx5IGlnbm9yZSB0aGUgc2VydmVyIGluIHRoaXMgY2FzZVxuICogYW5kIGtlZXAgdGhlIGV4aXN0aW5nIHN0YXRlIGZvciB0aGF0IHNlZ21lbnQuIE5ldyBkYXRhIGZvciBpbmFjdGl2ZSBzZWdtZW50cyBhcmUgaW5oZXJlbnRseVxuICogbm90IHBhcnQgb2YgdGhlIHNlcnZlciByZXNwb25zZSB3aGVuIHdlIHBhdGNoIHRoZSB0cmVlLCBiZWNhdXNlIHRoZXkgd2VyZSBhc3NvY2lhdGVkIHdpdGggYSByZXNwb25zZVxuICogZnJvbSBhbiBlYXJsaWVyIG5hdmlnYXRpb24vcmVxdWVzdC4gRm9yIGVhY2ggc2VnbWVudCwgb25jZSBpdCBiZWNvbWVzIFwiYWN0aXZlXCIsIHdlIGVuY29kZSB0aGUgVVJMIHRoYXQgcHJvdmlkZWRcbiAqIHRoZSBkYXRhIGZvciBpdC4gVGhpcyBmdW5jdGlvbiB0cmF2ZXJzZXMgcGFyYWxsZWwgcm91dGVzIGxvb2tpbmcgZm9yIHRoZXNlIG1hcmtlcnMgc28gdGhhdCBpdCBjYW4gcmUtZmV0Y2hcbiAqIGFuZCBwYXRjaCB0aGUgbmV3IGRhdGEgaW50byB0aGUgdHJlZS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlZnJlc2hJbmFjdGl2ZVBhcmFsbGVsU2VnbWVudHMoXG4gIG9wdGlvbnM6IFJlZnJlc2hJbmFjdGl2ZVBhcmFsbGVsU2VnbWVudHNcbikge1xuICBjb25zdCBmZXRjaGVkU2VnbWVudHMgPSBuZXcgU2V0PHN0cmluZz4oKVxuICBhd2FpdCByZWZyZXNoSW5hY3RpdmVQYXJhbGxlbFNlZ21lbnRzSW1wbCh7XG4gICAgLi4ub3B0aW9ucyxcbiAgICByb290VHJlZTogb3B0aW9ucy51cGRhdGVkVHJlZSxcbiAgICBmZXRjaGVkU2VnbWVudHMsXG4gIH0pXG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlZnJlc2hJbmFjdGl2ZVBhcmFsbGVsU2VnbWVudHNJbXBsKHtcbiAgbmF2aWdhdGVkQXQsXG4gIHN0YXRlLFxuICB1cGRhdGVkVHJlZSxcbiAgdXBkYXRlZENhY2hlLFxuICBpbmNsdWRlTmV4dFVybCxcbiAgZmV0Y2hlZFNlZ21lbnRzLFxuICByb290VHJlZSA9IHVwZGF0ZWRUcmVlLFxuICBjYW5vbmljYWxVcmwsXG59OiBSZWZyZXNoSW5hY3RpdmVQYXJhbGxlbFNlZ21lbnRzICYge1xuICBmZXRjaGVkU2VnbWVudHM6IFNldDxzdHJpbmc+XG4gIHJvb3RUcmVlOiBGbGlnaHRSb3V0ZXJTdGF0ZVxufSkge1xuICBjb25zdCBbLCBwYXJhbGxlbFJvdXRlcywgcmVmZXRjaFBhdGgsIHJlZmV0Y2hNYXJrZXJdID0gdXBkYXRlZFRyZWVcbiAgY29uc3QgZmV0Y2hQcm9taXNlcyA9IFtdXG5cbiAgaWYgKFxuICAgIHJlZmV0Y2hQYXRoICYmXG4gICAgcmVmZXRjaFBhdGggIT09IGNhbm9uaWNhbFVybCAmJlxuICAgIHJlZmV0Y2hNYXJrZXIgPT09ICdyZWZyZXNoJyAmJlxuICAgIC8vIGl0J3MgcG9zc2libGUgZm9yIHRoZSB0cmVlIHRvIGNvbnRhaW4gbXVsdGlwbGUgc2VnbWVudHMgdGhhdCBjb250YWluIGRhdGEgYXQgdGhlIHNhbWUgVVJMXG4gICAgLy8gd2Uga2VlcCB0cmFjayBvZiB0aGVtIHNvIHdlIGNhbiBkZWR1cGUgdGhlIHJlcXVlc3RzXG4gICAgIWZldGNoZWRTZWdtZW50cy5oYXMocmVmZXRjaFBhdGgpXG4gICkge1xuICAgIGZldGNoZWRTZWdtZW50cy5hZGQocmVmZXRjaFBhdGgpIC8vIE1hcmsgdGhpcyBVUkwgYXMgZmV0Y2hlZFxuXG4gICAgLy8gRWFnZXJseSBraWNrIG9mZiB0aGUgZmV0Y2ggZm9yIHRoZSByZWZldGNoIHBhdGggJiB0aGUgcGFyYWxsZWwgcm91dGVzLiBUaGlzIHNob3VsZCBiZSBmaW5lIHRvIGRvIGFzIHRoZXkgZWFjaCBvcGVyYXRlXG4gICAgLy8gaW5kZXBlbmRlbnRseSBvbiB0aGVpciBvd24gY2FjaGUgbm9kZXMsIGFuZCBgYXBwbHlGbGlnaHREYXRhYCB3aWxsIGNvcHkgYW55dGhpbmcgaXQgZG9lc24ndCBjYXJlIGFib3V0IGZyb20gdGhlIGV4aXN0aW5nIGNhY2hlLlxuICAgIGNvbnN0IGZldGNoUHJvbWlzZSA9IGZldGNoU2VydmVyUmVzcG9uc2UoXG4gICAgICBuZXcgVVJMKHJlZmV0Y2hQYXRoLCBsb2NhdGlvbi5vcmlnaW4pLFxuICAgICAge1xuICAgICAgICAvLyByZWZldGNoIGZyb20gdGhlIHJvb3Qgb2YgdGhlIHVwZGF0ZWQgdHJlZSwgb3RoZXJ3aXNlIGl0IHdpbGwgYmUgc2NvcGVkIHRvIHRoZSBjdXJyZW50IHNlZ21lbnRcbiAgICAgICAgLy8gYW5kIG1pZ2h0IG5vdCBjb250YWluIHRoZSBkYXRhIHdlIG5lZWQgdG8gcGF0Y2ggaW4gaW50ZXJjZXB0aW9uIHJvdXRlIGRhdGEgKHN1Y2ggYXMgZHluYW1pYyBwYXJhbXMgZnJvbSBhIHByZXZpb3VzIHNlZ21lbnQpXG4gICAgICAgIGZsaWdodFJvdXRlclN0YXRlOiBbcm9vdFRyZWVbMF0sIHJvb3RUcmVlWzFdLCByb290VHJlZVsyXSwgJ3JlZmV0Y2gnXSxcbiAgICAgICAgbmV4dFVybDogaW5jbHVkZU5leHRVcmwgPyBzdGF0ZS5uZXh0VXJsIDogbnVsbCxcbiAgICAgIH1cbiAgICApLnRoZW4oKHsgZmxpZ2h0RGF0YSB9KSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGZsaWdodERhdGEgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGZvciAoY29uc3QgZmxpZ2h0RGF0YVBhdGggb2YgZmxpZ2h0RGF0YSkge1xuICAgICAgICAgIC8vIHdlIG9ubHkgcGFzcyB0aGUgbmV3IGNhY2hlIGFzIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGFmdGVyIGNsZWFyaW5nIHRoZSByb3V0ZXIgY2FjaGVcbiAgICAgICAgICAvLyBhbmQgZmlsbGluZyBpbiB0aGUgbmV3IHBhZ2UgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIuIE1lYW5pbmcgdGhlIGV4aXN0aW5nIGNhY2hlIGlzIGFjdHVhbGx5IHRoZSBjYWNoZSB0aGF0J3NcbiAgICAgICAgICAvLyBqdXN0IGJlZW4gY3JlYXRlZCAmIGhhcyBiZWVuIHdyaXR0ZW4gdG8sIGJ1dCBoYXNuJ3QgYmVlbiBcImNvbW1pdHRlZFwiIHlldC5cbiAgICAgICAgICBhcHBseUZsaWdodERhdGEoXG4gICAgICAgICAgICBuYXZpZ2F0ZWRBdCxcbiAgICAgICAgICAgIHVwZGF0ZWRDYWNoZSxcbiAgICAgICAgICAgIHVwZGF0ZWRDYWNoZSxcbiAgICAgICAgICAgIGZsaWdodERhdGFQYXRoXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXaGVuIGZsaWdodERhdGEgaXMgYSBzdHJpbmcsIGl0IHN1Z2dlc3RzIHRoYXQgdGhlIHNlcnZlciByZXNwb25zZSBzaG91bGQgaGF2ZSB0cmlnZ2VyZWQgYW4gTVBBIG5hdmlnYXRpb25cbiAgICAgICAgLy8gSSdtIG5vdCAxMDAlIHN1cmUgb2YgdGhpcyBkZWNpc2lvbiwgYnV0IGl0IHNlZW1zIHVubGlrZWx5IHRoYXQgd2UnZCB3YW50IHRvIGludHJvZHVjZSBhIHJlZGlyZWN0IHNpZGUgZWZmZWN0XG4gICAgICAgIC8vIHdoZW4gcmVmcmVzaGluZyBvbi1zY3JlZW4gZGF0YSwgc28gaGFuZGxpbmcgdGhpcyBoYXMgYmVlbiBvbW1pdHRlZC5cbiAgICAgIH1cbiAgICB9KVxuXG4gICAgZmV0Y2hQcm9taXNlcy5wdXNoKGZldGNoUHJvbWlzZSlcbiAgfVxuXG4gIGZvciAoY29uc3Qga2V5IGluIHBhcmFsbGVsUm91dGVzKSB7XG4gICAgY29uc3QgcGFyYWxsZWxGZXRjaFByb21pc2UgPSByZWZyZXNoSW5hY3RpdmVQYXJhbGxlbFNlZ21lbnRzSW1wbCh7XG4gICAgICBuYXZpZ2F0ZWRBdCxcbiAgICAgIHN0YXRlLFxuICAgICAgdXBkYXRlZFRyZWU6IHBhcmFsbGVsUm91dGVzW2tleV0sXG4gICAgICB1cGRhdGVkQ2FjaGUsXG4gICAgICBpbmNsdWRlTmV4dFVybCxcbiAgICAgIGZldGNoZWRTZWdtZW50cyxcbiAgICAgIHJvb3RUcmVlLFxuICAgICAgY2Fub25pY2FsVXJsLFxuICAgIH0pXG5cbiAgICBmZXRjaFByb21pc2VzLnB1c2gocGFyYWxsZWxGZXRjaFByb21pc2UpXG4gIH1cblxuICBhd2FpdCBQcm9taXNlLmFsbChmZXRjaFByb21pc2VzKVxufVxuXG4vKipcbiAqIFdhbGtzIHRoZSBjdXJyZW50IHBhcmFsbGVsIHNlZ21lbnRzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBcImFjdGl2ZVwiLlxuICogQW4gYWN0aXZlIHBhcmFsbGVsIHJvdXRlIHdpbGwgaGF2ZSBhIGBfX1BBR0VfX2Agc2VnbWVudCBpbiB0aGUgRmxpZ2h0Um91dGVyU3RhdGUuXG4gKiBBcyBvcHBvc2VkIHRvIGEgYF9fREVGQVVMVF9fYCBzZWdtZW50LCB3aGljaCBtZWFucyB0aGVyZSB3YXMgbm8gbWF0Y2ggZm9yIHRoYXQgcGFyYWxsZWwgcm91dGUuXG4gKiBXZSBhZGQgYSBzcGVjaWFsIG1hcmtlciBoZXJlIHNvIHRoYXQgd2Uga25vdyBob3cgdG8gcmVmcmVzaCBpdHMgZGF0YSB3aGVuIHRoZSByb3V0ZXIgaXMgcmV2YWxpZGF0ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRSZWZyZXNoTWFya2VyVG9BY3RpdmVQYXJhbGxlbFNlZ21lbnRzKFxuICB0cmVlOiBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgcGF0aDogc3RyaW5nXG4pIHtcbiAgY29uc3QgW3NlZ21lbnQsIHBhcmFsbGVsUm91dGVzLCAsIHJlZmV0Y2hNYXJrZXJdID0gdHJlZVxuICAvLyBhIHBhZ2Ugc2VnbWVudCBtaWdodCBhbHNvIGNvbnRhaW4gY29uY2F0ZW5hdGVkIHNlYXJjaCBwYXJhbXMsIHNvIHdlIGRvIGEgcGFydGlhbCBtYXRjaCBvbiB0aGUga2V5XG4gIGlmIChzZWdtZW50LmluY2x1ZGVzKFBBR0VfU0VHTUVOVF9LRVkpICYmIHJlZmV0Y2hNYXJrZXIgIT09ICdyZWZyZXNoJykge1xuICAgIHRyZWVbMl0gPSBwYXRoXG4gICAgdHJlZVszXSA9ICdyZWZyZXNoJ1xuICB9XG5cbiAgZm9yIChjb25zdCBrZXkgaW4gcGFyYWxsZWxSb3V0ZXMpIHtcbiAgICBhZGRSZWZyZXNoTWFya2VyVG9BY3RpdmVQYXJhbGxlbFNlZ21lbnRzKHBhcmFsbGVsUm91dGVzW2tleV0sIHBhdGgpXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJhZGRSZWZyZXNoTWFya2VyVG9BY3RpdmVQYXJhbGxlbFNlZ21lbnRzIiwicmVmcmVzaEluYWN0aXZlUGFyYWxsZWxTZWdtZW50cyIsIm9wdGlvbnMiLCJmZXRjaGVkU2VnbWVudHMiLCJTZXQiLCJyZWZyZXNoSW5hY3RpdmVQYXJhbGxlbFNlZ21lbnRzSW1wbCIsInJvb3RUcmVlIiwidXBkYXRlZFRyZWUiLCJuYXZpZ2F0ZWRBdCIsInN0YXRlIiwidXBkYXRlZENhY2hlIiwiaW5jbHVkZU5leHRVcmwiLCJjYW5vbmljYWxVcmwiLCJwYXJhbGxlbFJvdXRlcyIsInJlZmV0Y2hQYXRoIiwicmVmZXRjaE1hcmtlciIsImZldGNoUHJvbWlzZXMiLCJoYXMiLCJhZGQiLCJmZXRjaFByb21pc2UiLCJmZXRjaFNlcnZlclJlc3BvbnNlIiwiVVJMIiwibG9jYXRpb24iLCJvcmlnaW4iLCJmbGlnaHRSb3V0ZXJTdGF0ZSIsIm5leHRVcmwiLCJ0aGVuIiwiZmxpZ2h0RGF0YSIsImZsaWdodERhdGFQYXRoIiwiYXBwbHlGbGlnaHREYXRhIiwicHVzaCIsImtleSIsInBhcmFsbGVsRmV0Y2hQcm9taXNlIiwiUHJvbWlzZSIsImFsbCIsInRyZWUiLCJwYXRoIiwic2VnbWVudCIsImluY2x1ZGVzIiwiUEFHRV9TRUdNRU5UX0tFWSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7SUF5SGdCQSx3Q0FBd0MsRUFBQTtlQUF4Q0E7O0lBOUZNQywrQkFBK0IsRUFBQTtlQUEvQkE7OztpQ0F4QlU7cUNBQ0k7eUJBQ0g7QUFzQjFCLGVBQWVBLGdDQUNwQkMsT0FBd0M7SUFFeEMsTUFBTUMsa0JBQWtCLElBQUlDO0lBQzVCLE1BQU1DLG9DQUFvQztRQUN4QyxHQUFHSCxPQUFPO1FBQ1ZJLFVBQVVKLFFBQVFLLFdBQVc7UUFDN0JKO0lBQ0Y7QUFDRjtBQUVBLGVBQWVFLG9DQUFvQyxLQVlsRDtJQVprRCxJQUFBLEVBQ2pERyxXQUFXLEVBQ1hDLEtBQUssRUFDTEYsV0FBVyxFQUNYRyxZQUFZLEVBQ1pDLGNBQWMsRUFDZFIsZUFBZSxFQUNmRyxXQUFXQyxXQUFXLEVBQ3RCSyxZQUFZLEVBSWIsR0Faa0Q7SUFhakQsTUFBTSxHQUFHQyxnQkFBZ0JDLGFBQWFDLGNBQWMsR0FBR1I7SUFDdkQsTUFBTVMsZ0JBQWdCLEVBQUU7SUFFeEIsSUFDRUYsZUFDQUEsZ0JBQWdCRixnQkFDaEJHLGtCQUFrQixhQUNsQiw0RkFBNEY7SUFDNUYsc0RBQXNEO0lBQ3RELENBQUNaLGdCQUFnQmMsR0FBRyxDQUFDSCxjQUNyQjtRQUNBWCxnQkFBZ0JlLEdBQUcsQ0FBQ0osYUFBYSwyQkFBMkI7O1FBRTVELHdIQUF3SDtRQUN4SCxrSUFBa0k7UUFDbEksTUFBTUssZUFBZUMsQ0FBQUEsR0FBQUEscUJBQUFBLG1CQUFtQixFQUN0QyxJQUFJQyxJQUFJUCxhQUFhUSxTQUFTQyxNQUFNLEdBQ3BDO1lBQ0UsZ0dBQWdHO1lBQ2hHLDhIQUE4SDtZQUM5SEMsbUJBQW1CO2dCQUFDbEIsUUFBUSxDQUFDLEVBQUU7Z0JBQUVBLFFBQVEsQ0FBQyxFQUFFO2dCQUFFQSxRQUFRLENBQUMsRUFBRTtnQkFBRTthQUFVO1lBQ3JFbUIsU0FBU2QsaUJBQWlCRixNQUFNZ0IsT0FBTyxHQUFHO1FBQzVDLEdBQ0FDLElBQUksQ0FBQyxDQUFBO2dCQUFDLEVBQUVDLFVBQVUsRUFBRSxHQUFBO1lBQ3BCLElBQUksT0FBT0EsZUFBZSxVQUFVO2dCQUNsQyxLQUFLLE1BQU1DLGtCQUFrQkQsV0FBWTtvQkFDdkMsd0ZBQXdGO29CQUN4Riw0R0FBNEc7b0JBQzVHLDRFQUE0RTtvQkFDNUVFLENBQUFBLEdBQUFBLGlCQUFBQSxlQUFlLEVBQ2JyQixhQUNBRSxjQUNBQSxjQUNBa0I7Z0JBRUo7WUFDRixPQUFPO1lBQ0wsNEdBQTRHO1lBQzVHLCtHQUErRztZQUMvRyxzRUFBc0U7WUFDeEU7UUFDRjtRQUVBWixjQUFjYyxJQUFJLENBQUNYO0lBQ3JCO0lBRUEsSUFBSyxNQUFNWSxPQUFPbEIsZUFBZ0I7UUFDaEMsTUFBTW1CLHVCQUF1QjNCLG9DQUFvQztZQUMvREc7WUFDQUM7WUFDQUYsYUFBYU0sY0FBYyxDQUFDa0IsSUFBSTtZQUNoQ3JCO1lBQ0FDO1lBQ0FSO1lBQ0FHO1lBQ0FNO1FBQ0Y7UUFFQUksY0FBY2MsSUFBSSxDQUFDRTtJQUNyQjtJQUVBLE1BQU1DLFFBQVFDLEdBQUcsQ0FBQ2xCO0FBQ3BCO0FBUU8sU0FBU2hCLHlDQUNkbUMsSUFBdUIsRUFDdkJDLElBQVk7SUFFWixNQUFNLENBQUNDLFNBQVN4QixrQkFBa0JFLGNBQWMsR0FBR29CO0lBQ25ELG9HQUFvRztJQUNwRyxJQUFJRSxRQUFRQyxRQUFRLENBQUNDLFNBQUFBLGdCQUFnQixLQUFLeEIsa0JBQWtCLFdBQVc7UUFDckVvQixJQUFJLENBQUMsRUFBRSxHQUFHQztRQUNWRCxJQUFJLENBQUMsRUFBRSxHQUFHO0lBQ1o7SUFFQSxJQUFLLE1BQU1KLE9BQU9sQixlQUFnQjtRQUNoQ2IseUNBQXlDYSxjQUFjLENBQUNrQixJQUFJLEVBQUVLO0lBQ2hFO0FBQ0YiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMjM4NywgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9hcHBseS1yb3V0ZXItc3RhdGUtcGF0Y2gtdG8tdHJlZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7XG4gIEZsaWdodFJvdXRlclN0YXRlLFxuICBGbGlnaHRTZWdtZW50UGF0aCxcbn0gZnJvbSAnLi4vLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvdHlwZXMnXG5pbXBvcnQgeyBERUZBVUxUX1NFR01FTlRfS0VZIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2xpYi9zZWdtZW50J1xuaW1wb3J0IHsgZ2V0TmV4dEZsaWdodFNlZ21lbnRQYXRoIH0gZnJvbSAnLi4vLi4vZmxpZ2h0LWRhdGEtaGVscGVycydcbmltcG9ydCB7IG1hdGNoU2VnbWVudCB9IGZyb20gJy4uL21hdGNoLXNlZ21lbnRzJ1xuaW1wb3J0IHsgYWRkUmVmcmVzaE1hcmtlclRvQWN0aXZlUGFyYWxsZWxTZWdtZW50cyB9IGZyb20gJy4vcmVmZXRjaC1pbmFjdGl2ZS1wYXJhbGxlbC1zZWdtZW50cydcblxuLyoqXG4gKiBEZWVwIG1lcmdlIG9mIHRoZSB0d28gcm91dGVyIHN0YXRlcy4gUGFyYWxsZWwgcm91dGUga2V5cyBhcmUgcHJlc2VydmVkIGlmIHRoZSBwYXRjaCBkb2Vzbid0IGhhdmUgdGhlbS5cbiAqL1xuZnVuY3Rpb24gYXBwbHlQYXRjaChcbiAgaW5pdGlhbFRyZWU6IEZsaWdodFJvdXRlclN0YXRlLFxuICBwYXRjaFRyZWU6IEZsaWdodFJvdXRlclN0YXRlXG4pOiBGbGlnaHRSb3V0ZXJTdGF0ZSB7XG4gIGNvbnN0IFtpbml0aWFsU2VnbWVudCwgaW5pdGlhbFBhcmFsbGVsUm91dGVzXSA9IGluaXRpYWxUcmVlXG4gIGNvbnN0IFtwYXRjaFNlZ21lbnQsIHBhdGNoUGFyYWxsZWxSb3V0ZXNdID0gcGF0Y2hUcmVlXG5cbiAgLy8gaWYgdGhlIGFwcGxpZWQgcGF0Y2ggc2VnbWVudCBpcyBfX0RFRkFVTFRfXyB0aGVuIGl0IGNhbiBiZSBpZ25vcmVkIGluIGZhdm9yIG9mIHRoZSBpbml0aWFsIHRyZWVcbiAgLy8gdGhpcyBpcyBiZWNhdXNlIHRoZSBfX0RFRkFVTFRfXyBzZWdtZW50IGlzIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBvbiBuYXZpZ2F0aW9uXG4gIGlmIChcbiAgICBwYXRjaFNlZ21lbnQgPT09IERFRkFVTFRfU0VHTUVOVF9LRVkgJiZcbiAgICBpbml0aWFsU2VnbWVudCAhPT0gREVGQVVMVF9TRUdNRU5UX0tFWVxuICApIHtcbiAgICByZXR1cm4gaW5pdGlhbFRyZWVcbiAgfVxuXG4gIGlmIChtYXRjaFNlZ21lbnQoaW5pdGlhbFNlZ21lbnQsIHBhdGNoU2VnbWVudCkpIHtcbiAgICBjb25zdCBuZXdQYXJhbGxlbFJvdXRlczogRmxpZ2h0Um91dGVyU3RhdGVbMV0gPSB7fVxuICAgIGZvciAoY29uc3Qga2V5IGluIGluaXRpYWxQYXJhbGxlbFJvdXRlcykge1xuICAgICAgY29uc3QgaXNJblBhdGNoVHJlZVBhcmFsbGVsUm91dGVzID1cbiAgICAgICAgdHlwZW9mIHBhdGNoUGFyYWxsZWxSb3V0ZXNba2V5XSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgIGlmIChpc0luUGF0Y2hUcmVlUGFyYWxsZWxSb3V0ZXMpIHtcbiAgICAgICAgbmV3UGFyYWxsZWxSb3V0ZXNba2V5XSA9IGFwcGx5UGF0Y2goXG4gICAgICAgICAgaW5pdGlhbFBhcmFsbGVsUm91dGVzW2tleV0sXG4gICAgICAgICAgcGF0Y2hQYXJhbGxlbFJvdXRlc1trZXldXG4gICAgICAgIClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld1BhcmFsbGVsUm91dGVzW2tleV0gPSBpbml0aWFsUGFyYWxsZWxSb3V0ZXNba2V5XVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoY29uc3Qga2V5IGluIHBhdGNoUGFyYWxsZWxSb3V0ZXMpIHtcbiAgICAgIGlmIChuZXdQYXJhbGxlbFJvdXRlc1trZXldKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIG5ld1BhcmFsbGVsUm91dGVzW2tleV0gPSBwYXRjaFBhcmFsbGVsUm91dGVzW2tleV1cbiAgICB9XG5cbiAgICBjb25zdCB0cmVlOiBGbGlnaHRSb3V0ZXJTdGF0ZSA9IFtpbml0aWFsU2VnbWVudCwgbmV3UGFyYWxsZWxSb3V0ZXNdXG5cbiAgICAvLyBDb3B5IG92ZXIgdGhlIGV4aXN0aW5nIHRyZWVcbiAgICBpZiAoaW5pdGlhbFRyZWVbMl0pIHtcbiAgICAgIHRyZWVbMl0gPSBpbml0aWFsVHJlZVsyXVxuICAgIH1cblxuICAgIGlmIChpbml0aWFsVHJlZVszXSkge1xuICAgICAgdHJlZVszXSA9IGluaXRpYWxUcmVlWzNdXG4gICAgfVxuXG4gICAgaWYgKGluaXRpYWxUcmVlWzRdKSB7XG4gICAgICB0cmVlWzRdID0gaW5pdGlhbFRyZWVbNF1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJlZVxuICB9XG5cbiAgcmV0dXJuIHBhdGNoVHJlZVxufVxuXG4vKipcbiAqIEFwcGx5IHRoZSByb3V0ZXIgc3RhdGUgZnJvbSB0aGUgRmxpZ2h0IHJlc3BvbnNlLCBidXQgc2tpcCBwYXRjaGluZyBkZWZhdWx0IHNlZ21lbnRzLlxuICogVXNlZnVsIGZvciBwYXRjaGluZyB0aGUgcm91dGVyIGNhY2hlIHdoZW4gbmF2aWdhdGluZywgd2hlcmUgd2UgcGVyc2lzdCB0aGUgZXhpc3RpbmcgZGVmYXVsdCBzZWdtZW50IGlmIHRoZXJlIGlzbid0IGEgbmV3IG9uZS5cbiAqIENyZWF0ZXMgYSBuZXcgcm91dGVyIHN0YXRlIHRyZWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUoXG4gIGZsaWdodFNlZ21lbnRQYXRoOiBGbGlnaHRTZWdtZW50UGF0aCxcbiAgZmxpZ2h0Um91dGVyU3RhdGU6IEZsaWdodFJvdXRlclN0YXRlLFxuICB0cmVlUGF0Y2g6IEZsaWdodFJvdXRlclN0YXRlLFxuICBwYXRoOiBzdHJpbmdcbik6IEZsaWdodFJvdXRlclN0YXRlIHwgbnVsbCB7XG4gIGNvbnN0IFtzZWdtZW50LCBwYXJhbGxlbFJvdXRlcywgdXJsLCByZWZldGNoLCBpc1Jvb3RMYXlvdXRdID1cbiAgICBmbGlnaHRSb3V0ZXJTdGF0ZVxuXG4gIC8vIFJvb3QgcmVmcmVzaFxuICBpZiAoZmxpZ2h0U2VnbWVudFBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgY29uc3QgdHJlZTogRmxpZ2h0Um91dGVyU3RhdGUgPSBhcHBseVBhdGNoKGZsaWdodFJvdXRlclN0YXRlLCB0cmVlUGF0Y2gpXG5cbiAgICBhZGRSZWZyZXNoTWFya2VyVG9BY3RpdmVQYXJhbGxlbFNlZ21lbnRzKHRyZWUsIHBhdGgpXG5cbiAgICByZXR1cm4gdHJlZVxuICB9XG5cbiAgY29uc3QgW2N1cnJlbnRTZWdtZW50LCBwYXJhbGxlbFJvdXRlS2V5XSA9IGZsaWdodFNlZ21lbnRQYXRoXG5cbiAgLy8gVHJlZSBwYXRoIHJldHVybmVkIGZyb20gdGhlIHNlcnZlciBzaG91bGQgYWx3YXlzIG1hdGNoIHVwIHdpdGggdGhlIGN1cnJlbnQgdHJlZSBpbiB0aGUgYnJvd3NlclxuICBpZiAoIW1hdGNoU2VnbWVudChjdXJyZW50U2VnbWVudCwgc2VnbWVudCkpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgY29uc3QgbGFzdFNlZ21lbnQgPSBmbGlnaHRTZWdtZW50UGF0aC5sZW5ndGggPT09IDJcblxuICBsZXQgcGFyYWxsZWxSb3V0ZVBhdGNoXG4gIGlmIChsYXN0U2VnbWVudCkge1xuICAgIHBhcmFsbGVsUm91dGVQYXRjaCA9IGFwcGx5UGF0Y2gocGFyYWxsZWxSb3V0ZXNbcGFyYWxsZWxSb3V0ZUtleV0sIHRyZWVQYXRjaClcbiAgfSBlbHNlIHtcbiAgICBwYXJhbGxlbFJvdXRlUGF0Y2ggPSBhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUoXG4gICAgICBnZXROZXh0RmxpZ2h0U2VnbWVudFBhdGgoZmxpZ2h0U2VnbWVudFBhdGgpLFxuICAgICAgcGFyYWxsZWxSb3V0ZXNbcGFyYWxsZWxSb3V0ZUtleV0sXG4gICAgICB0cmVlUGF0Y2gsXG4gICAgICBwYXRoXG4gICAgKVxuXG4gICAgaWYgKHBhcmFsbGVsUm91dGVQYXRjaCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cblxuICBjb25zdCB0cmVlOiBGbGlnaHRSb3V0ZXJTdGF0ZSA9IFtcbiAgICBmbGlnaHRTZWdtZW50UGF0aFswXSxcbiAgICB7XG4gICAgICAuLi5wYXJhbGxlbFJvdXRlcyxcbiAgICAgIFtwYXJhbGxlbFJvdXRlS2V5XTogcGFyYWxsZWxSb3V0ZVBhdGNoLFxuICAgIH0sXG4gICAgdXJsLFxuICAgIHJlZmV0Y2gsXG4gIF1cblxuICAvLyBDdXJyZW50IHNlZ21lbnQgaXMgdGhlIHJvb3QgbGF5b3V0XG4gIGlmIChpc1Jvb3RMYXlvdXQpIHtcbiAgICB0cmVlWzRdID0gdHJ1ZVxuICB9XG5cbiAgYWRkUmVmcmVzaE1hcmtlclRvQWN0aXZlUGFyYWxsZWxTZWdtZW50cyh0cmVlLCBwYXRoKVxuXG4gIHJldHVybiB0cmVlXG59XG4iXSwibmFtZXMiOlsiYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlIiwiYXBwbHlQYXRjaCIsImluaXRpYWxUcmVlIiwicGF0Y2hUcmVlIiwiaW5pdGlhbFNlZ21lbnQiLCJpbml0aWFsUGFyYWxsZWxSb3V0ZXMiLCJwYXRjaFNlZ21lbnQiLCJwYXRjaFBhcmFsbGVsUm91dGVzIiwiREVGQVVMVF9TRUdNRU5UX0tFWSIsIm1hdGNoU2VnbWVudCIsIm5ld1BhcmFsbGVsUm91dGVzIiwia2V5IiwiaXNJblBhdGNoVHJlZVBhcmFsbGVsUm91dGVzIiwidHJlZSIsImZsaWdodFNlZ21lbnRQYXRoIiwiZmxpZ2h0Um91dGVyU3RhdGUiLCJ0cmVlUGF0Y2giLCJwYXRoIiwic2VnbWVudCIsInBhcmFsbGVsUm91dGVzIiwidXJsIiwicmVmZXRjaCIsImlzUm9vdExheW91dCIsImxlbmd0aCIsImFkZFJlZnJlc2hNYXJrZXJUb0FjdGl2ZVBhcmFsbGVsU2VnbWVudHMiLCJjdXJyZW50U2VnbWVudCIsInBhcmFsbGVsUm91dGVLZXkiLCJsYXN0U2VnbWVudCIsInBhcmFsbGVsUm91dGVQYXRjaCIsImdldE5leHRGbGlnaHRTZWdtZW50UGF0aCJdLCJtYXBwaW5ncyI6Ijs7OytCQTZFZ0JBLCtCQUFBQTs7O2VBQUFBOzs7eUJBekVvQjttQ0FDSzsrQkFDWjtpREFDNEI7QUFFekQ7O0NBRUMsR0FDRCxTQUFTQyxXQUNQQyxXQUE4QixFQUM5QkMsU0FBNEI7SUFFNUIsTUFBTSxDQUFDQyxn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O0lBRS9DLE9BQU9KO0FBQ1QiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMjQ5NiwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9zaG91bGQtaGFyZC1uYXZpZ2F0ZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7XG4gIEZsaWdodFJvdXRlclN0YXRlLFxuICBGbGlnaHREYXRhUGF0aCxcbiAgU2VnbWVudCxcbn0gZnJvbSAnLi4vLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvdHlwZXMnXG5pbXBvcnQgeyBnZXROZXh0RmxpZ2h0U2VnbWVudFBhdGggfSBmcm9tICcuLi8uLi9mbGlnaHQtZGF0YS1oZWxwZXJzJ1xuaW1wb3J0IHsgbWF0Y2hTZWdtZW50IH0gZnJvbSAnLi4vbWF0Y2gtc2VnbWVudHMnXG5cbi8vIFRPRE8tQVBQOiBmbGlnaHRTZWdtZW50UGF0aCB3aWxsIGJlIGVtcHR5IGluIGNhc2Ugb2Ygc3RhdGljIHJlc3BvbnNlLCBuZWVkcyB0byBiZSBoYW5kbGVkLlxuZXhwb3J0IGZ1bmN0aW9uIHNob3VsZEhhcmROYXZpZ2F0ZShcbiAgZmxpZ2h0U2VnbWVudFBhdGg6IEZsaWdodERhdGFQYXRoLFxuICBmbGlnaHRSb3V0ZXJTdGF0ZTogRmxpZ2h0Um91dGVyU3RhdGVcbik6IGJvb2xlYW4ge1xuICBjb25zdCBbc2VnbWVudCwgcGFyYWxsZWxSb3V0ZXNdID0gZmxpZ2h0Um91dGVyU3RhdGVcbiAgLy8gVE9ETy1BUFA6IENoZWNrIGlmIGBhc2AgY2FuIGJlIHJlcGxhY2VkLlxuICBjb25zdCBbY3VycmVudFNlZ21lbnQsIHBhcmFsbGVsUm91dGVLZXldID0gZmxpZ2h0U2VnbWVudFBhdGggYXMgW1xuICAgIFNlZ21lbnQsXG4gICAgc3RyaW5nLFxuICBdXG5cbiAgLy8gQ2hlY2sgaWYgY3VycmVudCBzZWdtZW50IG1hdGNoZXMgdGhlIGV4aXN0aW5nIHNlZ21lbnQuXG4gIGlmICghbWF0Y2hTZWdtZW50KGN1cnJlbnRTZWdtZW50LCBzZWdtZW50KSkge1xuICAgIC8vIElmIGR5bmFtaWMgcGFyYW1ldGVyIGluIHRyZWUgZG9lc24ndCBtYXRjaCB1cCB3aXRoIHNlZ21lbnQgcGF0aCBhIGhhcmQgbmF2aWdhdGlvbiBpcyB0cmlnZ2VyZWQuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudFNlZ21lbnQpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8vIElmIHRoZSBleGlzdGluZyBzZWdtZW50IGRpZCBub3QgbWF0Y2ggc29mdCBuYXZpZ2F0aW9uIGlzIHRyaWdnZXJlZC5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBjb25zdCBsYXN0U2VnbWVudCA9IGZsaWdodFNlZ21lbnRQYXRoLmxlbmd0aCA8PSAyXG5cbiAgaWYgKGxhc3RTZWdtZW50KSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gc2hvdWxkSGFyZE5hdmlnYXRlKFxuICAgIGdldE5leHRGbGlnaHRTZWdtZW50UGF0aChmbGlnaHRTZWdtZW50UGF0aCksXG4gICAgcGFyYWxsZWxSb3V0ZXNbcGFyYWxsZWxSb3V0ZUtleV1cbiAgKVxufVxuIl0sIm5hbWVzIjpbInNob3VsZEhhcmROYXZpZ2F0ZSIsImZsaWdodFNlZ21lbnRQYXRoIiwiZmxpZ2h0Um91dGVyU3RhdGUiLCJzZWdtZW50IiwicGFyYWxsZWxSb3V0ZXMiLCJjdXJyZW50U2VnbWVudCIsInBhcmFsbGVsUm91dGVLZXkiLCJtYXRjaFNlZ21lbnQiLCJBcnJheSIsImlzQXJyYXkiLCJsYXN0U2VnbWVudCIsImxlbmd0aCIsImdldE5leHRGbGlnaHRTZWdtZW50UGF0aCJdLCJtYXBwaW5ncyI6Ijs7OytCQVNnQkEsc0JBQUFBOzs7ZUFBQUE7OzttQ0FKeUI7K0JBQ1o7QUFHdEIsU0FBU0EsbUJBQ2RDLGlCQUFpQyxFQUNqQ0MsaUJBQW9DO0lBRXBDLE1BQU0sQ0FBQ0MsU0FBU0MsZUFBZSxHQUFHRjtJQUNsQywyQ0FBMkM7SUFDM0MsTUFBTSxDQUFDRyxnQkFBZ0JDLGlCQUFpQixHQUFHTDtJQUszQyx5REFBeUQ7SUFDekQsSUFBSSxDQUFDTSxDQUFBQSxHQUFBQSxlQUFBQSxZQUFZLEVBQUNGLGdCQUFnQkYsVUFBVTtRQUMxQyxrR0FBa0c7UUFDbEcsSUFBSUssTUFBTUMsT0FBTyxDQUFDSixpQkFBaUI7WUFDakMsT0FBTztRQUNUO1FBRUEsc0VBQXNFO1FBQ3RFLE9BQU87SUFDVDtJQUNBLE1BQU1LLGNBQWNULGtCQUFrQlUsTUFBTSxJQUFJO0lBRWhELElBQUlELGFBQWE7UUFDZixPQUFPO0lBQ1Q7SUFFQSxPQUFPVixtQkFDTFksQ0FBQUEsR0FBQUEsbUJBQUFBLHdCQUF3QixFQUFDWCxvQkFDekJHLGNBQWMsQ0FBQ0UsaUJBQWlCO0FBRXBDIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDI1MzksICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvaXMtbmF2aWdhdGluZy10by1uZXctcm9vdC1sYXlvdXQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBGbGlnaHRSb3V0ZXJTdGF0ZSB9IGZyb20gJy4uLy4uLy4uL3NlcnZlci9hcHAtcmVuZGVyL3R5cGVzJ1xuXG5leHBvcnQgZnVuY3Rpb24gaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0KFxuICBjdXJyZW50VHJlZTogRmxpZ2h0Um91dGVyU3RhdGUsXG4gIG5leHRUcmVlOiBGbGlnaHRSb3V0ZXJTdGF0ZVxuKTogYm9vbGVhbiB7XG4gIC8vIENvbXBhcmUgc2VnbWVudHNcbiAgY29uc3QgY3VycmVudFRyZWVTZWdtZW50ID0gY3VycmVudFRyZWVbMF1cbiAgY29uc3QgbmV4dFRyZWVTZWdtZW50ID0gbmV4dFRyZWVbMF1cblxuICAvLyBJZiBhbnkgc2VnbWVudCBpcyBkaWZmZXJlbnQgYmVmb3JlIHdlIGZpbmQgdGhlIHJvb3QgbGF5b3V0LCB0aGUgcm9vdCBsYXlvdXQgaGFzIGNoYW5nZWQuXG4gIC8vIEUuZy4gL3NhbWUvKGdyb3VwMSkvbGF5b3V0LmpzIC0+IC9zYW1lLyhncm91cDIpL2xheW91dC5qc1xuICAvLyBGaXJzdCBzZWdtZW50IGlzICdzYW1lJyBmb3IgYm90aCwga2VlcCBsb29raW5nLiAoZ3JvdXAxKSBjaGFuZ2VkIHRvIChncm91cDIpIGJlZm9yZSB0aGUgcm9vdCBsYXlvdXQgd2FzIGZvdW5kLCBpdCBtdXN0IGhhdmUgY2hhbmdlZC5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudFRyZWVTZWdtZW50KSAmJiBBcnJheS5pc0FycmF5KG5leHRUcmVlU2VnbWVudCkpIHtcbiAgICAvLyBDb21wYXJlIGR5bmFtaWMgcGFyYW0gbmFtZSBhbmQgdHlwZSBidXQgaWdub3JlIHRoZSB2YWx1ZSwgZGlmZmVyZW50IHZhbHVlcyB3b3VsZCBub3QgYWZmZWN0IHRoZSBjdXJyZW50IHJvb3QgbGF5b3V0XG4gICAgLy8gL1tuYW1lXSAtIC9zbHVnMSBhbmQgL3NsdWcyLCBib3RoIHZhbHVlcyAoc2x1ZzEgJiBzbHVnMikgc3RpbGwgaGFzIHRoZSBzYW1lIGxheW91dCAvW25hbWVdL2xheW91dC5qc1xuICAgIGlmIChcbiAgICAgIGN1cnJlbnRUcmVlU2VnbWVudFswXSAhPT0gbmV4dFRyZWVTZWdtZW50WzBdIHx8XG4gICAgICBjdXJyZW50VHJlZVNlZ21lbnRbMl0gIT09IG5leHRUcmVlU2VnbWVudFsyXVxuICAgICkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH0gZWxzZSBpZiAoY3VycmVudFRyZWVTZWdtZW50ICE9PSBuZXh0VHJlZVNlZ21lbnQpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gQ3VycmVudCB0cmVlIHJvb3QgbGF5b3V0IGZvdW5kXG4gIGlmIChjdXJyZW50VHJlZVs0XSkge1xuICAgIC8vIElmIHRoZSBuZXh0IHRyZWUgZG9lc24ndCBoYXZlIHRoZSByb290IGxheW91dCBmbGFnLCBpdCBtdXN0IGhhdmUgY2hhbmdlZC5cbiAgICByZXR1cm4gIW5leHRUcmVlWzRdXG4gIH1cbiAgLy8gQ3VycmVudCB0cmVlIGRpZG4ndCBoYXZlIGl0cyByb290IGxheW91dCBoZXJlLCBtdXN0IGhhdmUgY2hhbmdlZC5cbiAgaWYgKG5leHRUcmVlWzRdKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICAvLyBXZSBjYW4ndCBhc3N1bWUgaXQncyBgcGFyYWxsZWxSb3V0ZXMuY2hpbGRyZW5gIGhlcmUgaW4gY2FzZSB0aGUgcm9vdCBsYXlvdXQgaXMgYGFwcC9Ac29tZXRoaW5nL2xheW91dC5qc2BcbiAgLy8gQnV0IGl0J3Mgbm90IHBvc3NpYmxlIHRvIGJlIG1vcmUgdGhhbiBvbmUgcGFyYWxsZWxSb3V0ZXMgYmVmb3JlIHRoZSByb290IGxheW91dCBpcyBmb3VuZFxuICAvLyBUT0RPLUFQUDogY2hhbmdlIHRvIHRyYXZlcnNlIGFsbCBwYXJhbGxlbCByb3V0ZXNcbiAgY29uc3QgY3VycmVudFRyZWVDaGlsZCA9IE9iamVjdC52YWx1ZXMoY3VycmVudFRyZWVbMV0pWzBdXG4gIGNvbnN0IG5leHRUcmVlQ2hpbGQgPSBPYmplY3QudmFsdWVzKG5leHRUcmVlWzFdKVswXVxuICBpZiAoIWN1cnJlbnRUcmVlQ2hpbGQgfHwgIW5leHRUcmVlQ2hpbGQpIHJldHVybiB0cnVlXG4gIHJldHVybiBpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQoY3VycmVudFRyZWVDaGlsZCwgbmV4dFRyZWVDaGlsZClcbn1cbiJdLCJuYW1lcyI6WyJpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQiLCJjdXJyZW50VHJlZSIsIm5leHRUcmVlIiwiY3VycmVudFRyZWVTZWdtZW50IiwibmV4dFRyZWVTZWdtZW50IiwiQXJyYXkiLCJpc0FycmF5IiwiY3VycmVudFRyZWVDaGlsZCIsIk9iamVjdCIsInZhbHVlcyIsIm5leHRUcmVlQ2hpbGQiXSwibWFwcGluZ3MiOiI7OzsrQkFFZ0JBLCtCQUFBQTs7O2VBQUFBOzs7QUFBVCxTQUFTQSw0QkFDZEMsV0FBOEIsRUFDOUJDLFFBQTJCO0lBRTNCLG1CQUFtQjtJQUNuQixNQUFNQyxxQkFBcUJGLFdBQVcsQ0FBQyxFQUFFO0lBQ3pDLE1BQU1HLGtCQUFrQkYsUUFBUSxDQUFDLEVBQUU7SUFFbkMsMkZBQTJGO0lBQzNGLDREQUE0RDtJQUM1RCx1SUFBdUk7SUFDdkksSUFBSUcsTUFBTUMsT0FBTyxDQUFDSCx1QkFBdUJFLE1BQU1DLE9BQU8sQ0FBQ0Ysa0JBQWtCO1FBQ3ZFLHNIQUFzSDtRQUN0SCx1R0FBdUc7UUFDdkcsSUFDRUQsa0JBQWtCLENBQUMsRUFBRSxLQUFLQyxlQUFlLENBQUMsRUFBRSxJQUM1Q0Qsa0JBQWtCLENBQUMsRUFBRSxLQUFLQyxlQUFlLENBQUMsRUFBRSxFQUM1QztZQUNBLE9BQU87UUFDVDtJQUNGLE9BQU8sSUFBSUQsdUJBQXVCQyxpQkFBaUI7UUFDakQsT0FBTztJQUNUO0lBRUEsaUNBQWlDO0lBQ2pDLElBQUlILFdBQVcsQ0FBQyxFQUFFLEVBQUU7UUFDbEIsNEVBQTRFO1FBQzVFLE9BQU8sQ0FBQ0MsUUFBUSxDQUFDLEVBQUU7SUFDckI7SUFDQSxvRUFBb0U7SUFDcEUsSUFBSUEsUUFBUSxDQUFDLEVBQUUsRUFBRTtRQUNmLE9BQU87SUFDVDtJQUNBLDRHQUE0RztJQUM1RywyRkFBMkY7SUFDM0YsbURBQW1EO0lBQ25ELE1BQU1LLG1CQUFtQkMsT0FBT0MsTUFBTSxDQUFDUixXQUFXLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRTtJQUN6RCxNQUFNUyxnQkFBZ0JGLE9BQU9DLE1BQU0sQ0FBQ1AsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUU7SUFDbkQsSUFBSSxDQUFDSyxvQkFBb0IsQ0FBQ0csZUFBZSxPQUFPO0lBQ2hELE9BQU9WLDRCQUE0Qk8sa0JBQWtCRztBQUN2RCIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAyNTk0LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL3NoYXJlZC9saWIvcGFnZS1wYXRoL2Vuc3VyZS1sZWFkaW5nLXNsYXNoLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRm9yIGEgZ2l2ZW4gcGFnZSBwYXRoLCB0aGlzIGZ1bmN0aW9uIGVuc3VyZXMgdGhhdCB0aGVyZSBpcyBhIGxlYWRpbmcgc2xhc2guXG4gKiBJZiB0aGVyZSBpcyBub3QgYSBsZWFkaW5nIHNsYXNoLCBvbmUgaXMgYWRkZWQsIG90aGVyd2lzZSBpdCBpcyBub29wLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5zdXJlTGVhZGluZ1NsYXNoKHBhdGg6IHN0cmluZykge1xuICByZXR1cm4gcGF0aC5zdGFydHNXaXRoKCcvJykgPyBwYXRoIDogYC8ke3BhdGh9YFxufVxuIl0sIm5hbWVzIjpbImVuc3VyZUxlYWRpbmdTbGFzaCIsInBhdGgiLCJzdGFydHNXaXRoIl0sIm1hcHBpbmdzIjoiQUFBQTs7O0NBR0M7OzsrQkFDZUEsc0JBQUFBOzs7ZUFBQUE7OztBQUFULFNBQVNBLG1CQUFtQkMsSUFBWTtJQUM3QyxPQUFPQSxLQUFLQyxVQUFVLENBQUMsT0FBT0QsT0FBUSxNQUFHQTtBQUMzQyIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAyNjE1LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2FwcC1wYXRocy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBlbnN1cmVMZWFkaW5nU2xhc2ggfSBmcm9tICcuLi8uLi9wYWdlLXBhdGgvZW5zdXJlLWxlYWRpbmctc2xhc2gnXG5pbXBvcnQgeyBpc0dyb3VwU2VnbWVudCB9IGZyb20gJy4uLy4uL3NlZ21lbnQnXG5cbi8qKlxuICogTm9ybWFsaXplcyBhbiBhcHAgcm91dGUgc28gaXQgcmVwcmVzZW50cyB0aGUgYWN0dWFsIHJlcXVlc3QgcGF0aC4gRXNzZW50aWFsbHlcbiAqIHBlcmZvcm1pbmcgdGhlIGZvbGxvd2luZyB0cmFuc2Zvcm1hdGlvbnM6XG4gKlxuICogLSBgLyhkYXNoYm9hcmQpL3VzZXIvW2lkXS9wYWdlYCB0byBgL3VzZXIvW2lkXWBcbiAqIC0gYC8oZGFzaGJvYXJkKS9hY2NvdW50L3BhZ2VgIHRvIGAvYWNjb3VudGBcbiAqIC0gYC91c2VyL1tpZF0vcGFnZWAgdG8gYC91c2VyL1tpZF1gXG4gKiAtIGAvYWNjb3VudC9wYWdlYCB0byBgL2FjY291bnRgXG4gKiAtIGAvcGFnZWAgdG8gYC9gXG4gKiAtIGAvKGRhc2hib2FyZCkvdXNlci9baWRdL3JvdXRlYCB0byBgL3VzZXIvW2lkXWBcbiAqIC0gYC8oZGFzaGJvYXJkKS9hY2NvdW50L3JvdXRlYCB0byBgL2FjY291bnRgXG4gKiAtIGAvdXNlci9baWRdL3JvdXRlYCB0byBgL3VzZXIvW2lkXWBcbiAqIC0gYC9hY2NvdW50L3JvdXRlYCB0byBgL2FjY291bnRgXG4gKiAtIGAvcm91dGVgIHRvIGAvYFxuICogLSBgL2AgdG8gYC9gXG4gKlxuICogQHBhcmFtIHJvdXRlIHRoZSBhcHAgcm91dGUgdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB0aGUgbm9ybWFsaXplZCBwYXRobmFtZVxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplQXBwUGF0aChyb3V0ZTogc3RyaW5nKSB7XG4gIHJldHVybiBlbnN1cmVMZWFkaW5nU2xhc2goXG4gICAgcm91dGUuc3BsaXQoJy8nKS5yZWR1Y2UoKHBhdGhuYW1lLCBzZWdtZW50LCBpbmRleCwgc2VnbWVudHMpID0+IHtcbiAgICAgIC8vIEVtcHR5IHNlZ21lbnRzIGFyZSBpZ25vcmVkLlxuICAgICAgaWYgKCFzZWdtZW50KSB7XG4gICAgICAgIHJldHVybiBwYXRobmFtZVxuICAgICAgfVxuXG4gICAgICAvLyBHcm91cHMgYXJlIGlnbm9yZWQuXG4gICAgICBpZiAoaXNHcm91cFNlZ21lbnQoc2VnbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIHBhdGhuYW1lXG4gICAgICB9XG5cbiAgICAgIC8vIFBhcmFsbGVsIHNlZ21lbnRzIGFyZSBpZ25vcmVkLlxuICAgICAgaWYgKHNlZ21lbnRbMF0gPT09ICdAJykge1xuICAgICAgICByZXR1cm4gcGF0aG5hbWVcbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGxhc3Qgc2VnbWVudCAoaWYgaXQncyBhIGxlYWYpIHNob3VsZCBiZSBpZ25vcmVkLlxuICAgICAgaWYgKFxuICAgICAgICAoc2VnbWVudCA9PT0gJ3BhZ2UnIHx8IHNlZ21lbnQgPT09ICdyb3V0ZScpICYmXG4gICAgICAgIGluZGV4ID09PSBzZWdtZW50cy5sZW5ndGggLSAxXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHBhdGhuYW1lXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBgJHtwYXRobmFtZX0vJHtzZWdtZW50fWBcbiAgICB9LCAnJylcbiAgKVxufVxuXG4vKipcbiAqIFN0cmlwcyB0aGUgYC5yc2NgIGV4dGVuc2lvbiBpZiBpdCdzIGluIHRoZSBwYXRobmFtZS5cbiAqIFNpbmNlIHRoaXMgZnVuY3Rpb24gaXMgdXNlZCBvbiBmdWxsIHVybHMgaXQgY2hlY2tzIGA/YCBmb3Igc2VhcmNoUGFyYW1zIGhhbmRsaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplUnNjVVJMKHVybDogc3RyaW5nKSB7XG4gIHJldHVybiB1cmwucmVwbGFjZShcbiAgICAvXFwucnNjKCR8XFw/KS8sXG4gICAgLy8gJDEgZW5zdXJlcyBgP2AgaXMgcHJlc2VydmVkXG4gICAgJyQxJ1xuICApXG59XG4iXSwibmFtZXMiOlsibm9ybWFsaXplQXBwUGF0aCIsIm5vcm1hbGl6ZVJzY1VSTCIsInJvdXRlIiwiZW5zdXJlTGVhZGluZ1NsYXNoIiwic3BsaXQiLCJyZWR1Y2UiLCJwYXRobmFtZSIsInNlZ21lbnQiLCJpbmRleCIsInNlZ21lbnRzIiwiaXNHcm91cFNlZ21lbnQiLCJsZW5ndGgiLCJ1cmwiLCJyZXBsYWNlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztJQXNCZ0JBLGdCQUFnQixFQUFBO2VBQWhCQTs7SUFtQ0FDLGVBQWUsRUFBQTtlQUFmQTs7O29DQXpEbUI7eUJBQ0o7QUFxQnhCLFNBQVNELGlCQUFpQkUsS0FBYTtJQUM1QyxPQUFPQyxDQUFBQSxHQUFBQSxvQkFBQUEsa0JBQWtCLEVBQ3ZCRCxNQUFNRSxLQUFLLENBQUMsS0FBS0MsTUFBTSxDQUFDLENBQUNDLFVBQVVDLFNBQVNDLE9BQU9DO1FBQ2pELDhCQUE4QjtRQUM5QixJQUFJLENBQUNGLFNBQVM7WUFDWixPQUFPRDtRQUNUO1FBRUEsc0JBQXNCO1FBQ3RCLElBQUlJLENBQUFBLEdBQUFBLFNBQUFBLGNBQWMsRUFBQ0gsVUFBVTtZQUMzQixPQUFPRDtRQUNUO1FBRUEsaUNBQWlDO1FBQ2pDLElBQUlDLE9BQU8sQ0FBQyxFQUFFLEtBQUssS0FBSztZQUN0QixPQUFPRDtRQUNUO1FBRUEsdURBQXVEO1FBQ3ZELElBQ0dDLENBQUFBLFlBQVksVUFBVUEsWUFBWSxPQUFNLEtBQ3pDQyxVQUFVQyxTQUFTRSxNQUFNLEdBQUcsR0FDNUI7WUFDQSxPQUFPTDtRQUNUO1FBRUEsT0FBVUEsV0FBUyxNQUFHQztJQUN4QixHQUFHO0FBRVA7QUFNTyxTQUFTTixnQkFBZ0JXLEdBQVc7SUFDekMsT0FBT0EsSUFBSUMsT0FBTyxDQUNoQixlQUNBLEFBQ0EsOEJBRDhCO0FBR2xDIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDI2NjgsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaW50ZXJjZXB0aW9uLXJvdXRlcy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBub3JtYWxpemVBcHBQYXRoIH0gZnJvbSAnLi9hcHAtcGF0aHMnXG5cbi8vIG9yZGVyIG1hdHRlcnMgaGVyZSwgdGhlIGZpcnN0IG1hdGNoIHdpbGwgYmUgdXNlZFxuZXhwb3J0IGNvbnN0IElOVEVSQ0VQVElPTl9ST1VURV9NQVJLRVJTID0gW1xuICAnKC4uKSguLiknLFxuICAnKC4pJyxcbiAgJyguLiknLFxuICAnKC4uLiknLFxuXSBhcyBjb25zdFxuXG5leHBvcnQgZnVuY3Rpb24gaXNJbnRlcmNlcHRpb25Sb3V0ZUFwcFBhdGgocGF0aDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIC8vIFRPRE8tQVBQOiBhZGQgbW9yZSBzZXJpb3VzIHZhbGlkYXRpb25cbiAgcmV0dXJuIChcbiAgICBwYXRoXG4gICAgICAuc3BsaXQoJy8nKVxuICAgICAgLmZpbmQoKHNlZ21lbnQpID0+XG4gICAgICAgIElOVEVSQ0VQVElPTl9ST1VURV9NQVJLRVJTLmZpbmQoKG0pID0+IHNlZ21lbnQuc3RhcnRzV2l0aChtKSlcbiAgICAgICkgIT09IHVuZGVmaW5lZFxuICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0SW50ZXJjZXB0aW9uUm91dGVJbmZvcm1hdGlvbihwYXRoOiBzdHJpbmcpIHtcbiAgbGV0IGludGVyY2VwdGluZ1JvdXRlOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgbWFya2VyOiAodHlwZW9mIElOVEVSQ0VQVElPTl9ST1VURV9NQVJLRVJTKVtudW1iZXJdIHwgdW5kZWZpbmVkLFxuICAgIGludGVyY2VwdGVkUm91dGU6IHN0cmluZyB8IHVuZGVmaW5lZFxuXG4gIGZvciAoY29uc3Qgc2VnbWVudCBvZiBwYXRoLnNwbGl0KCcvJykpIHtcbiAgICBtYXJrZXIgPSBJTlRFUkNFUFRJT05fUk9VVEVfTUFSS0VSUy5maW5kKChtKSA9PiBzZWdtZW50LnN0YXJ0c1dpdGgobSkpXG4gICAgaWYgKG1hcmtlcikge1xuICAgICAgO1tpbnRlcmNlcHRpbmdSb3V0ZSwgaW50ZXJjZXB0ZWRSb3V0ZV0gPSBwYXRoLnNwbGl0KG1hcmtlciwgMilcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKCFpbnRlcmNlcHRpbmdSb3V0ZSB8fCAhbWFya2VyIHx8ICFpbnRlcmNlcHRlZFJvdXRlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEludmFsaWQgaW50ZXJjZXB0aW9uIHJvdXRlOiAke3BhdGh9LiBNdXN0IGJlIGluIHRoZSBmb3JtYXQgLzxpbnRlcmNlcHRpbmcgcm91dGU+LyguLnwuLi58Li4pKC4uKS88aW50ZXJjZXB0ZWQgcm91dGU+YFxuICAgIClcbiAgfVxuXG4gIGludGVyY2VwdGluZ1JvdXRlID0gbm9ybWFsaXplQXBwUGF0aChpbnRlcmNlcHRpbmdSb3V0ZSkgLy8gbm9ybWFsaXplIHRoZSBwYXRoLCBlLmcuIC8oYmxvZykvZmVlZCAtPiAvZmVlZFxuXG4gIHN3aXRjaCAobWFya2VyKSB7XG4gICAgY2FzZSAnKC4pJzpcbiAgICAgIC8vICguKSBpbmRpY2F0ZXMgdGhhdCB3ZSBzaG91bGQgbWF0Y2ggd2l0aCBzaWJsaW5nIHJvdXRlcywgc28gd2UganVzdCBuZWVkIHRvIGFwcGVuZCB0aGUgaW50ZXJjZXB0ZWQgcm91dGUgdG8gdGhlIGludGVyY2VwdGluZyByb3V0ZVxuICAgICAgaWYgKGludGVyY2VwdGluZ1JvdXRlID09PSAnLycpIHtcbiAgICAgICAgaW50ZXJjZXB0ZWRSb3V0ZSA9IGAvJHtpbnRlcmNlcHRlZFJvdXRlfWBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludGVyY2VwdGVkUm91dGUgPSBpbnRlcmNlcHRpbmdSb3V0ZSArICcvJyArIGludGVyY2VwdGVkUm91dGVcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnKC4uKSc6XG4gICAgICAvLyAoLi4pIGluZGljYXRlcyB0aGF0IHdlIHNob3VsZCBtYXRjaCBhdCBvbmUgbGV2ZWwgdXAsIHNvIHdlIG5lZWQgdG8gcmVtb3ZlIHRoZSBsYXN0IHNlZ21lbnQgb2YgdGhlIGludGVyY2VwdGluZyByb3V0ZVxuICAgICAgaWYgKGludGVyY2VwdGluZ1JvdXRlID09PSAnLycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBJbnZhbGlkIGludGVyY2VwdGlvbiByb3V0ZTogJHtwYXRofS4gQ2Fubm90IHVzZSAoLi4pIG1hcmtlciBhdCB0aGUgcm9vdCBsZXZlbCwgdXNlICguKSBpbnN0ZWFkLmBcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgaW50ZXJjZXB0ZWRSb3V0ZSA9IGludGVyY2VwdGluZ1JvdXRlXG4gICAgICAgIC5zcGxpdCgnLycpXG4gICAgICAgIC5zbGljZSgwLCAtMSlcbiAgICAgICAgLmNvbmNhdChpbnRlcmNlcHRlZFJvdXRlKVxuICAgICAgICAuam9pbignLycpXG4gICAgICBicmVha1xuICAgIGNhc2UgJyguLi4pJzpcbiAgICAgIC8vICguLi4pIHdpbGwgbWF0Y2ggdGhlIHJvdXRlIHNlZ21lbnQgaW4gdGhlIHJvb3QgZGlyZWN0b3J5LCBzbyB3ZSBuZWVkIHRvIHVzZSB0aGUgcm9vdCBkaXJlY3RvcnkgdG8gcHJlcGVuZCB0aGUgaW50ZXJjZXB0ZWQgcm91dGVcbiAgICAgIGludGVyY2VwdGVkUm91dGUgPSAnLycgKyBpbnRlcmNlcHRlZFJvdXRlXG4gICAgICBicmVha1xuICAgIGNhc2UgJyguLikoLi4pJzpcbiAgICAgIC8vICguLikoLi4pIGluZGljYXRlcyB0aGF0IHdlIHNob3VsZCBtYXRjaCBhdCB0d28gbGV2ZWxzIHVwLCBzbyB3ZSBuZWVkIHRvIHJlbW92ZSB0aGUgbGFzdCB0d28gc2VnbWVudHMgb2YgdGhlIGludGVyY2VwdGluZyByb3V0ZVxuXG4gICAgICBjb25zdCBzcGxpdEludGVyY2VwdGluZ1JvdXRlID0gaW50ZXJjZXB0aW5nUm91dGUuc3BsaXQoJy8nKVxuICAgICAgaWYgKHNwbGl0SW50ZXJjZXB0aW5nUm91dGUubGVuZ3RoIDw9IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBJbnZhbGlkIGludGVyY2VwdGlvbiByb3V0ZTogJHtwYXRofS4gQ2Fubm90IHVzZSAoLi4pKC4uKSBtYXJrZXIgYXQgdGhlIHJvb3QgbGV2ZWwgb3Igb25lIGxldmVsIHVwLmBcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICBpbnRlcmNlcHRlZFJvdXRlID0gc3BsaXRJbnRlcmNlcHRpbmdSb3V0ZVxuICAgICAgICAuc2xpY2UoMCwgLTIpXG4gICAgICAgIC5jb25jYXQoaW50ZXJjZXB0ZWRSb3V0ZSlcbiAgICAgICAgLmpvaW4oJy8nKVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhcmlhbnQ6IHVuZXhwZWN0ZWQgbWFya2VyJylcbiAgfVxuXG4gIHJldHVybiB7IGludGVyY2VwdGluZ1JvdXRlLCBpbnRlcmNlcHRlZFJvdXRlIH1cbn1cbiJdLCJuYW1lcyI6WyJJTlRFUkNFUFRJT05fUk9VVEVfTUFSS0VSUyIsImV4dHJhY3RJbnRlcmNlcHRpb25Sb3V0ZUluZm9ybWF0aW9uIiwiaXNJbnRlcmNlcHRpb25Sb3V0ZUFwcFBhdGgiLCJwYXRoIiwic3BsaXQiLCJmaW5kIiwic2VnbWVudCIsIm0iLCJzdGFydHNXaXRoIiwidW5kZWZpbmVkIiwiaW50ZXJjZXB0aW5nUm91dGUiLCJtYXJrZXIiLCJpbnRlcmNlcHRlZFJvdXRlIiwiRXJyb3IiLCJub3JtYWxpemVBcHBQYXRoIiwic2xpY2UiLCJjb25jYXQiLCJqb2luIiwic3BsaXRJbnRlcmNlcHRpbmdSb3V0ZSIsImxlbmd0aCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0lBR2FBLDBCQUEwQixFQUFBO2VBQTFCQTs7SUFrQkdDLG1DQUFtQyxFQUFBO2VBQW5DQTs7SUFYQUMsMEJBQTBCLEVBQUE7ZUFBMUJBOzs7MEJBVmlCO0FBRzFCLE1BQU1GLDZCQUE2QjtJQUN4QztJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBRU0sU0FBU0UsMkJBQTJCQyxJQUFZO0lBQ3JELHdDQUF3QztJQUN4QyxPQUNFQSxLQUNHQyxLQUFLLENBQUMsS0FDTkMsSUFBSSxDQUFDLENBQUNDLFVBQ0xOLDJCQUEyQkssSUFBSSxDQUFDLENBQUNFLElBQU1ELFFBQVFFLFVBQVUsQ0FBQ0QsU0FDdERFO0FBRVo7QUFFTyxTQUFTUixvQ0FBb0NFLElBQVk7SUFDOUQsSUFBSU8sbUJBQ0ZDLFFBQ0FDO0lBRUYsS0FBSyxNQUFNTixXQUFXSCxLQUFLQyxLQUFLLENBQUMsS0FBTTtRQUNyQ08sU0FBU1gsMkJBQTJCSyxJQUFJLENBQUMsQ0FBQ0UsSUFBTUQsUUFBUUUsVUFBVSxDQUFDRDtRQUNuRSxJQUFJSSxRQUFROztZQUNULENBQUNELG1CQUFtQkUsaUJBQWlCLEdBQUdULEtBQUtDLEtBQUssQ0FBQ08sUUFBUTtZQUM1RDtRQUNGO0lBQ0Y7SUFFQSxJQUFJLENBQUNELHFCQUFxQixDQUFDQyxVQUFVLENBQUNDLGtCQUFrQjtRQUN0RCxNQUFNLE9BQUEsY0FFTCxDQUZLLElBQUlDLE1BQ1AsaUNBQThCVixPQUFLLHNGQURoQyxxQkFBQTttQkFBQTt3QkFBQTswQkFBQTtRQUVOO0lBQ0Y7SUFFQU8sb0JBQW9CSSxDQUFBQSxHQUFBQSxVQUFBQSxnQkFBZ0IsRUFBQ0osbUJBQW1CLGlEQUFpRDs7SUFFekcsT0FBUUM7UUFDTixLQUFLO1lBQ0gsb0lBQW9JO1lBQ3BJLElBQUlELHNCQUFzQixLQUFLO2dCQUM3QkUsbUJBQW9CLE1BQUdBO1lBQ3pCLE9BQU87Z0JBQ0xBLG1CQUFtQkYsb0JBQW9CLE1BQU1FO1lBQy9DO1lBQ0E7UUFDRixLQUFLO1lBQ0gsdUhBQXVIO1lBQ3ZILElBQUlGLHNCQUFzQixLQUFLO2dCQUM3QixNQUFNLE9BQUEsY0FFTCxDQUZLLElBQUlHLE1BQ1AsaUNBQThCVixPQUFLLGlFQURoQyxxQkFBQTsyQkFBQTtnQ0FBQTtrQ0FBQTtnQkFFTjtZQUNGO1lBQ0FTLG1CQUFtQkYsa0JBQ2hCTixLQUFLLENBQUMsS0FDTlcsS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUNWQyxNQUFNLENBQUNKLGtCQUNQSyxJQUFJLENBQUM7WUFDUjtRQUNGLEtBQUs7WUFDSCxrSUFBa0k7WUFDbElMLG1CQUFtQixNQUFNQTtZQUN6QjtRQUNGLEtBQUs7WUFDSCxpSUFBaUk7WUFFakksTUFBTU0seUJBQXlCUixrQkFBa0JOLEtBQUssQ0FBQztZQUN2RCxJQUFJYyx1QkFBdUJDLE1BQU0sSUFBSSxHQUFHO2dCQUN0QyxNQUFNLE9BQUEsY0FFTCxDQUZLLElBQUlOLE1BQ1AsaUNBQThCVixPQUFLLG9FQURoQyxxQkFBQTsyQkFBQTtnQ0FBQTtrQ0FBQTtnQkFFTjtZQUNGO1lBRUFTLG1CQUFtQk0sdUJBQ2hCSCxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQ1ZDLE1BQU0sQ0FBQ0osa0JBQ1BLLElBQUksQ0FBQztZQUNSO1FBQ0Y7WUFDRSxNQUFNLE9BQUEsY0FBeUMsQ0FBekMsSUFBSUosTUFBTSxpQ0FBVixxQkFBQTt1QkFBQTs0QkFBQTs4QkFBQTtZQUF3QztJQUNsRDtJQUVBLE9BQU87UUFBRUg7UUFBbUJFO0lBQWlCO0FBQy9DIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDI3NzcsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvY29tcHV0ZS1jaGFuZ2VkLXBhdGgudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUge1xuICBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgU2VnbWVudCxcbn0gZnJvbSAnLi4vLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvdHlwZXMnXG5pbXBvcnQgeyBJTlRFUkNFUFRJT05fUk9VVEVfTUFSS0VSUyB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2ludGVyY2VwdGlvbi1yb3V0ZXMnXG5pbXBvcnQgdHlwZSB7IFBhcmFtcyB9IGZyb20gJy4uLy4uLy4uL3NlcnZlci9yZXF1ZXN0L3BhcmFtcydcbmltcG9ydCB7XG4gIGlzR3JvdXBTZWdtZW50LFxuICBERUZBVUxUX1NFR01FTlRfS0VZLFxuICBQQUdFX1NFR01FTlRfS0VZLFxufSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvbGliL3NlZ21lbnQnXG5pbXBvcnQgeyBtYXRjaFNlZ21lbnQgfSBmcm9tICcuLi9tYXRjaC1zZWdtZW50cydcblxuY29uc3QgcmVtb3ZlTGVhZGluZ1NsYXNoID0gKHNlZ21lbnQ6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gIHJldHVybiBzZWdtZW50WzBdID09PSAnLycgPyBzZWdtZW50LnNsaWNlKDEpIDogc2VnbWVudFxufVxuXG5jb25zdCBzZWdtZW50VG9QYXRobmFtZSA9IChzZWdtZW50OiBTZWdtZW50KTogc3RyaW5nID0+IHtcbiAgaWYgKHR5cGVvZiBzZWdtZW50ID09PSAnc3RyaW5nJykge1xuICAgIC8vICdjaGlsZHJlbicgaXMgbm90IGEgdmFsaWQgcGF0aCAtLSBpdCdzIHRlY2huaWNhbGx5IGEgcGFyYWxsZWwgcm91dGUgdGhhdCBjb3JyZXNwb25kcyB3aXRoIHRoZSBjdXJyZW50IHNlZ21lbnQncyBwYWdlXG4gICAgLy8gaWYgd2UgZG9uJ3Qgc2tpcCBpdCwgdGhlbiB0aGUgY29tcHV0ZWQgcGF0aG5hbWUgbWlnaHQgYmUgc29tZXRoaW5nIGxpa2UgYC9jaGlsZHJlbmAgd2hpY2ggZG9lc24ndCBtYWtlIHNlbnNlLlxuICAgIGlmIChzZWdtZW50ID09PSAnY2hpbGRyZW4nKSByZXR1cm4gJydcblxuICAgIHJldHVybiBzZWdtZW50XG4gIH1cblxuICByZXR1cm4gc2VnbWVudFsxXVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVTZWdtZW50cyhzZWdtZW50czogc3RyaW5nW10pOiBzdHJpbmcge1xuICByZXR1cm4gKFxuICAgIHNlZ21lbnRzLnJlZHVjZSgoYWNjLCBzZWdtZW50KSA9PiB7XG4gICAgICBzZWdtZW50ID0gcmVtb3ZlTGVhZGluZ1NsYXNoKHNlZ21lbnQpXG4gICAgICBpZiAoc2VnbWVudCA9PT0gJycgfHwgaXNHcm91cFNlZ21lbnQoc2VnbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIGFjY1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYCR7YWNjfS8ke3NlZ21lbnR9YFxuICAgIH0sICcnKSB8fCAnLydcbiAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdFBhdGhGcm9tRmxpZ2h0Um91dGVyU3RhdGUoXG4gIGZsaWdodFJvdXRlclN0YXRlOiBGbGlnaHRSb3V0ZXJTdGF0ZVxuKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgY29uc3Qgc2VnbWVudCA9IEFycmF5LmlzQXJyYXkoZmxpZ2h0Um91dGVyU3RhdGVbMF0pXG4gICAgPyBmbGlnaHRSb3V0ZXJTdGF0ZVswXVsxXVxuICAgIDogZmxpZ2h0Um91dGVyU3RhdGVbMF1cblxuICBpZiAoXG4gICAgc2VnbWVudCA9PT0gREVGQVVMVF9TRUdNRU5UX0tFWSB8fFxuICAgIElOVEVSQ0VQVElPTl9ST1VURV9NQVJLRVJTLnNvbWUoKG0pID0+IHNlZ21lbnQuc3RhcnRzV2l0aChtKSlcbiAgKVxuICAgIHJldHVybiB1bmRlZmluZWRcblxuICBpZiAoc2VnbWVudC5zdGFydHNXaXRoKFBBR0VfU0VHTUVOVF9LRVkpKSByZXR1cm4gJydcblxuICBjb25zdCBzZWdtZW50cyA9IFtzZWdtZW50VG9QYXRobmFtZShzZWdtZW50KV1cbiAgY29uc3QgcGFyYWxsZWxSb3V0ZXMgPSBmbGlnaHRSb3V0ZXJTdGF0ZVsxXSA/PyB7fVxuXG4gIGNvbnN0IGNoaWxkcmVuUGF0aCA9IHBhcmFsbGVsUm91dGVzLmNoaWxkcmVuXG4gICAgPyBleHRyYWN0UGF0aEZyb21GbGlnaHRSb3V0ZXJTdGF0ZShwYXJhbGxlbFJvdXRlcy5jaGlsZHJlbilcbiAgICA6IHVuZGVmaW5lZFxuXG4gIGlmIChjaGlsZHJlblBhdGggIT09IHVuZGVmaW5lZCkge1xuICAgIHNlZ21lbnRzLnB1c2goY2hpbGRyZW5QYXRoKVxuICB9IGVsc2Uge1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHBhcmFsbGVsUm91dGVzKSkge1xuICAgICAgaWYgKGtleSA9PT0gJ2NoaWxkcmVuJykgY29udGludWVcblxuICAgICAgY29uc3QgY2hpbGRQYXRoID0gZXh0cmFjdFBhdGhGcm9tRmxpZ2h0Um91dGVyU3RhdGUodmFsdWUpXG5cbiAgICAgIGlmIChjaGlsZFBhdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZWdtZW50cy5wdXNoKGNoaWxkUGF0aClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbm9ybWFsaXplU2VnbWVudHMoc2VnbWVudHMpXG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVDaGFuZ2VkUGF0aEltcGwoXG4gIHRyZWVBOiBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgdHJlZUI6IEZsaWdodFJvdXRlclN0YXRlXG4pOiBzdHJpbmcgfCBudWxsIHtcbiAgY29uc3QgW3NlZ21lbnRBLCBwYXJhbGxlbFJvdXRlc0FdID0gdHJlZUFcbiAgY29uc3QgW3NlZ21lbnRCLCBwYXJhbGxlbFJvdXRlc0JdID0gdHJlZUJcblxuICBjb25zdCBub3JtYWxpemVkU2VnbWVudEEgPSBzZWdtZW50VG9QYXRobmFtZShzZWdtZW50QSlcbiAgY29uc3Qgbm9ybWFsaXplZFNlZ21lbnRCID0gc2VnbWVudFRvUGF0aG5hbWUoc2VnbWVudEIpXG5cbiAgaWYgKFxuICAgIElOVEVSQ0VQVElPTl9ST1VURV9NQVJLRVJTLnNvbWUoXG4gICAgICAobSkgPT5cbiAgICAgICAgbm9ybWFsaXplZFNlZ21lbnRBLnN0YXJ0c1dpdGgobSkgfHwgbm9ybWFsaXplZFNlZ21lbnRCLnN0YXJ0c1dpdGgobSlcbiAgICApXG4gICkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFtYXRjaFNlZ21lbnQoc2VnbWVudEEsIHNlZ21lbnRCKSkge1xuICAgIC8vIG9uY2Ugd2UgZmluZCB3aGVyZSB0aGUgdHJlZSBjaGFuZ2VkLCB3ZSBjb21wdXRlIHRoZSByZXN0IG9mIHRoZSBwYXRoIGJ5IHRyYXZlcnNpbmcgdGhlIHRyZWVcbiAgICByZXR1cm4gZXh0cmFjdFBhdGhGcm9tRmxpZ2h0Um91dGVyU3RhdGUodHJlZUIpID8/ICcnXG4gIH1cblxuICBmb3IgKGNvbnN0IHBhcmFsbGVsUm91dGVyS2V5IGluIHBhcmFsbGVsUm91dGVzQSkge1xuICAgIGlmIChwYXJhbGxlbFJvdXRlc0JbcGFyYWxsZWxSb3V0ZXJLZXldKSB7XG4gICAgICBjb25zdCBjaGFuZ2VkUGF0aCA9IGNvbXB1dGVDaGFuZ2VkUGF0aEltcGwoXG4gICAgICAgIHBhcmFsbGVsUm91dGVzQVtwYXJhbGxlbFJvdXRlcktleV0sXG4gICAgICAgIHBhcmFsbGVsUm91dGVzQltwYXJhbGxlbFJvdXRlcktleV1cbiAgICAgIClcbiAgICAgIGlmIChjaGFuZ2VkUGF0aCAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gYCR7c2VnbWVudFRvUGF0aG5hbWUoc2VnbWVudEIpfS8ke2NoYW5nZWRQYXRofWBcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUNoYW5nZWRQYXRoKFxuICB0cmVlQTogRmxpZ2h0Um91dGVyU3RhdGUsXG4gIHRyZWVCOiBGbGlnaHRSb3V0ZXJTdGF0ZVxuKTogc3RyaW5nIHwgbnVsbCB7XG4gIGNvbnN0IGNoYW5nZWRQYXRoID0gY29tcHV0ZUNoYW5nZWRQYXRoSW1wbCh0cmVlQSwgdHJlZUIpXG5cbiAgaWYgKGNoYW5nZWRQYXRoID09IG51bGwgfHwgY2hhbmdlZFBhdGggPT09ICcvJykge1xuICAgIHJldHVybiBjaGFuZ2VkUGF0aFxuICB9XG5cbiAgLy8gbGlnaHR3ZWlnaHQgbm9ybWFsaXphdGlvbiB0byByZW1vdmUgcm91dGUgZ3JvdXBzXG4gIHJldHVybiBub3JtYWxpemVTZWdtZW50cyhjaGFuZ2VkUGF0aC5zcGxpdCgnLycpKVxufVxuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IGV4dHJhY3RzIGR5bmFtaWMgcGFyYW1ldGVycyBmcm9tIEZsaWdodFJvdXRlclN0YXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2VsZWN0ZWRQYXJhbXMoXG4gIGN1cnJlbnRUcmVlOiBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgcGFyYW1zOiBQYXJhbXMgPSB7fVxuKTogUGFyYW1zIHtcbiAgY29uc3QgcGFyYWxsZWxSb3V0ZXMgPSBjdXJyZW50VHJlZVsxXVxuXG4gIGZvciAoY29uc3QgcGFyYWxsZWxSb3V0ZSBvZiBPYmplY3QudmFsdWVzKHBhcmFsbGVsUm91dGVzKSkge1xuICAgIGNvbnN0IHNlZ21lbnQgPSBwYXJhbGxlbFJvdXRlWzBdXG4gICAgY29uc3QgaXNEeW5hbWljUGFyYW1ldGVyID0gQXJyYXkuaXNBcnJheShzZWdtZW50KVxuICAgIGNvbnN0IHNlZ21lbnRWYWx1ZSA9IGlzRHluYW1pY1BhcmFtZXRlciA/IHNlZ21lbnRbMV0gOiBzZWdtZW50XG4gICAgaWYgKCFzZWdtZW50VmFsdWUgfHwgc2VnbWVudFZhbHVlLnN0YXJ0c1dpdGgoUEFHRV9TRUdNRU5UX0tFWSkpIGNvbnRpbnVlXG5cbiAgICAvLyBFbnN1cmUgY2F0Y2hBbGwgYW5kIG9wdGlvbmFsIGNhdGNoYWxsIGFyZSB0dXJuZWQgaW50byBhbiBhcnJheVxuICAgIGNvbnN0IGlzQ2F0Y2hBbGwgPVxuICAgICAgaXNEeW5hbWljUGFyYW1ldGVyICYmIChzZWdtZW50WzJdID09PSAnYycgfHwgc2VnbWVudFsyXSA9PT0gJ29jJylcblxuICAgIGlmIChpc0NhdGNoQWxsKSB7XG4gICAgICBwYXJhbXNbc2VnbWVudFswXV0gPSBzZWdtZW50WzFdLnNwbGl0KCcvJylcbiAgICB9IGVsc2UgaWYgKGlzRHluYW1pY1BhcmFtZXRlcikge1xuICAgICAgcGFyYW1zW3NlZ21lbnRbMF1dID0gc2VnbWVudFsxXVxuICAgIH1cblxuICAgIHBhcmFtcyA9IGdldFNlbGVjdGVkUGFyYW1zKHBhcmFsbGVsUm91dGUsIHBhcmFtcylcbiAgfVxuXG4gIHJldHVybiBwYXJhbXNcbn1cbiJdLCJuYW1lcyI6WyJjb21wdXRlQ2hhbmdlZFBhdGgiLCJleHRyYWN0UGF0aEZyb21GbGlnaHRSb3V0ZXJTdGF0ZSIsImdldFNlbGVjdGVkUGFyYW1zIiwicmVtb3ZlTGVhZGluZ1NsYXNoIiwic2VnbWVudCIsInNsaWNlIiwic2VnbWVudFRvUGF0aG5hbWUiLCJub3JtYWxpemVTZWdtZW50cyIsInNlZ21lbnRzIiwicmVkdWNlIiwiYWNjIiwiaXNHcm91cFNlZ21lbnQiLCJmbGlnaHRSb3V0ZXJTdGF0ZSIsIkFycmF5IiwiaXNBcnJheSIsIkRFRkFVTFRfU0VHTUVOVF9LRVkiLCJJTlRFUkNFUFRJT05fUk9VVEVfTUFSS0VSUyIsInNvbWUiLCJtIiwic3RhcnRzV2l0aCIsInVuZGVmaW5lZCIsIlBBR0VfU0VHTUVOVF9LRVkiLCJwYXJhbGxlbFJvdXRlcyIsImNoaWxkcmVuUGF0aCIsImNoaWxkcmVuIiwicHVzaCIsImtleSIsInZhbHVlIiwiT2JqZWN0IiwiZW50cmllcyIsImNoaWxkUGF0aCIsImNvbXB1dGVDaGFuZ2VkUGF0aEltcGwiLCJ0cmVlQSIsInRyZWVCIiwic2VnbWVudEEiLCJwYXJhbGxlbFJvdXRlc0EiLCJzZWdtZW50QiIsInBhcmFsbGVsUm91dGVzQiIsIm5vcm1hbGl6ZWRTZWdtZW50QSIsIm5vcm1hbGl6ZWRTZWdtZW50QiIsIm1hdGNoU2VnbWVudCIsInBhcmFsbGVsUm91dGVyS2V5IiwiY2hhbmdlZFBhdGgiLCJzcGxpdCIsImN1cnJlbnRUcmVlIiwicGFyYW1zIiwicGFyYWxsZWxSb3V0ZSIsInZhbHVlcyIsImlzRHluYW1pY1BhcmFtZXRlciIsInNlZ21lbnRWYWx1ZSIsImlzQ2F0Y2hBbGwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztJQXdIZ0JBLGtCQUFrQixFQUFBO2VBQWxCQTs7SUE5RUFDLGdDQUFnQyxFQUFBO2VBQWhDQTs7SUErRkFDLGlCQUFpQixFQUFBO2VBQWpCQTs7O29DQXJJMkI7eUJBTXBDOytCQUNzQjtBQUU3QixNQUFNQyxxQkFBcUIsQ0FBQ0M7SUFDMUIsT0FBT0EsT0FBTyxDQUFDLEVBQUUsS0FBSyxNQUFNQSxRQUFRQyxLQUFLLENBQUMsS0FBS0Q7QUFDakQ7QUFFQSxNQUFNRSxvQkFBb0IsQ0FBQ0Y7SUFDekIsSUFBSSxPQUFPQSxZQUFZLFVBQVU7UUFDL0IsdUhBQXVIO1FBQ3ZILGdIQUFnSDtRQUNoSCxJQUFJQSxZQUFZLFlBQVksT0FBTztRQUVuQyxPQUFPQTtJQUNUO0lBRUEsT0FBT0EsT0FBTyxDQUFDLEVBQUU7QUFDbkI7QUFFQSxTQUFTRyxrQkFBa0JDLFFBQWtCO0lBQzNDLE9BQ0VBLFNBQVNDLE1BQU0sQ0FBQyxDQUFDQyxLQUFLTjtRQUNwQkEsVUFBVUQsbUJBQW1CQztRQUM3QixJQUFJQSxZQUFZLE1BQU1PLENBQUFBLEdBQUFBLFNBQUFBLGNBQWMsRUFBQ1AsVUFBVTtZQUM3QyxPQUFPTTtRQUNUO1FBRUEsT0FBVUEsTUFBSSxNQUFHTjtJQUNuQixHQUFHLE9BQU87QUFFZDtBQUVPLFNBQVNILGlDQUNkVyxpQkFBb0M7SUFFcEMsTUFBTVIsVUFBVVMsTUFBTUMsT0FBTyxDQUFDRixpQkFBaUIsQ0FBQyxFQUFFLElB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RCxJQUFJLENBQUM2QyxnQkFBZ0JBLGFBQWE5QixVQUFVLENBQUNFLFNBQUFBLGdCQUFnQixHQUFHO1FBRWhFLGlFQUFpRTtRQUNqRSxNQUFNNkIsYUFDSkYsc0JBQXVCNUMsQ0FBQUEsT0FBTyxDQUFDLEVBQUUsS0FBSyxPQUFPQSxPQUFPLENBQUMsRUFBRSxLQUFLLElBQUc7UUFFakUsSUFBSThDLFlBQVk7WUFDZEwsTUFBTSxDQUFDekMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxHQUFHQSxPQUFPLENBQUMsRUFBRSxDQUFDdUMsS0FBSyxDQUFDO1FBQ3hDLE9BQU8sSUFBSUssb0JBQW9CO1lBQzdCSCxNQUFNLENBQUN6QyxPQUFPLENBQUMsRUFBRSxDQUFDLEdBQUdBLE9BQU8sQ0FBQyxFQUFFO1FBQ2pDO1FBRUF5QyxTQUFTM0Msa0JBQWtCNEMsZUFBZUQ7SUFDNUM7SUFFQSxPQUFPQTtBQUNUIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDI5MTIsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvaGFuZGxlLW11dGFibGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY29tcHV0ZUNoYW5nZWRQYXRoIH0gZnJvbSAnLi9jb21wdXRlLWNoYW5nZWQtcGF0aCdcbmltcG9ydCB0eXBlIHtcbiAgTXV0YWJsZSxcbiAgUmVhZG9ubHlSZWR1Y2VyU3RhdGUsXG4gIFJlZHVjZXJTdGF0ZSxcbn0gZnJvbSAnLi9yb3V0ZXItcmVkdWNlci10eXBlcydcblxuZnVuY3Rpb24gaXNOb3RVbmRlZmluZWQ8VD4odmFsdWU6IFQpOiB2YWx1ZSBpcyBFeGNsdWRlPFQsIHVuZGVmaW5lZD4ge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJ1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFuZGxlTXV0YWJsZShcbiAgc3RhdGU6IFJlYWRvbmx5UmVkdWNlclN0YXRlLFxuICBtdXRhYmxlOiBNdXRhYmxlXG4pOiBSZWR1Y2VyU3RhdGUge1xuICAvLyBzaG91bGRTY3JvbGwgaXMgdHJ1ZSBieSBkZWZhdWx0LCBjYW4gb3ZlcnJpZGUgdG8gZmFsc2UuXG4gIGNvbnN0IHNob3VsZFNjcm9sbCA9IG11dGFibGUuc2hvdWxkU2Nyb2xsID8/IHRydWVcblxuICBsZXQgbmV4dFVybCA9IHN0YXRlLm5leHRVcmxcblxuICBpZiAoaXNOb3RVbmRlZmluZWQobXV0YWJsZS5wYXRjaGVkVHJlZSkpIHtcbiAgICAvLyBJZiB3ZSByZWNlaXZlZCBhIHBhdGNoZWQgdHJlZSwgd2UgbmVlZCB0byBjb21wdXRlIHRoZSBjaGFuZ2VkIHBhdGguXG4gICAgY29uc3QgY2hhbmdlZFBhdGggPSBjb21wdXRlQ2hhbmdlZFBhdGgoc3RhdGUudHJlZSwgbXV0YWJsZS5wYXRjaGVkVHJlZSlcbiAgICBpZiAoY2hhbmdlZFBhdGgpIHtcbiAgICAgIC8vIElmIHRoZSB0cmVlIGNoYW5nZWQsIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBuZXh0VXJsXG4gICAgICBuZXh0VXJsID0gY2hhbmdlZFBhdGhcbiAgICB9IGVsc2UgaWYgKCFuZXh0VXJsKSB7XG4gICAgICAvLyBpZiB0aGUgdHJlZSBlbmRzIHVwIGJlaW5nIHRoZSBzYW1lIChpZSwgbm8gY2hhbmdlZCBwYXRoKSwgYW5kIHdlIGRvbid0IGhhdmUgYSBuZXh0VXJsLCB0aGVuIHdlIHNob3VsZCB1c2UgdGhlIGNhbm9uaWNhbFVybFxuICAgICAgbmV4dFVybCA9IHN0YXRlLmNhbm9uaWNhbFVybFxuICAgIH1cbiAgICAvLyBvdGhlcndpc2UgdGhpcyB3aWxsIGJlIGEgbm8tb3AgYW5kIGNvbnRpbnVlIHRvIHVzZSB0aGUgZXhpc3RpbmcgbmV4dFVybFxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAvLyBTZXQgaHJlZi5cbiAgICBjYW5vbmljYWxVcmw6IGlzTm90VW5kZWZpbmVkKG11dGFibGUuY2Fub25pY2FsVXJsKVxuICAgICAgPyBtdXRhYmxlLmNhbm9uaWNhbFVybCA9PT0gc3RhdGUuY2Fub25pY2FsVXJsXG4gICAgICAgID8gc3RhdGUuY2Fub25pY2FsVXJsXG4gICAgICAgIDogbXV0YWJsZS5jYW5vbmljYWxVcmxcbiAgICAgIDogc3RhdGUuY2Fub25pY2FsVXJsLFxuICAgIHB1c2hSZWY6IHtcbiAgICAgIHBlbmRpbmdQdXNoOiBpc05vdFVuZGVmaW5lZChtdXRhYmxlLnBlbmRpbmdQdXNoKVxuICAgICAgICA/IG11dGFibGUucGVuZGluZ1B1c2hcbiAgICAgICAgOiBzdGF0ZS5wdXNoUmVmLnBlbmRpbmdQdXNoLFxuICAgICAgbXBhTmF2aWdhdGlvbjogaXNOb3RVbmRlZmluZWQobXV0YWJsZS5tcGFOYXZpZ2F0aW9uKVxuICAgICAgICA/IG11dGFibGUubXBhTmF2aWdhdGlvblxuICAgICAgICA6IHN0YXRlLnB1c2hSZWYubXBhTmF2aWdhdGlvbixcbiAgICAgIHByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlOiBpc05vdFVuZGVmaW5lZChcbiAgICAgICAgbXV0YWJsZS5wcmVzZXJ2ZUN1c3RvbUhpc3RvcnlTdGF0ZVxuICAgICAgKVxuICAgICAgICA/IG11dGFibGUucHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGVcbiAgICAgICAgOiBzdGF0ZS5wdXNoUmVmLnByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlLFxuICAgIH0sXG4gICAgLy8gQWxsIG5hdmlnYXRpb24gcmVxdWlyZXMgc2Nyb2xsIGFuZCBmb2N1cyBtYW5hZ2VtZW50IHRvIHRyaWdnZXIuXG4gICAgZm9jdXNBbmRTY3JvbGxSZWY6IHtcbiAgICAgIGFwcGx5OiBzaG91bGRTY3JvbGxcbiAgICAgICAgPyBpc05vdFVuZGVmaW5lZChtdXRhYmxlPy5zY3JvbGxhYmxlU2VnbWVudHMpXG4gICAgICAgICAgPyB0cnVlXG4gICAgICAgICAgOiBzdGF0ZS5mb2N1c0FuZFNjcm9sbFJlZi5hcHBseVxuICAgICAgICA6IC8vIElmIHNob3VsZFNjcm9sbCBpcyBmYWxzZSB0aGVuIHdlIHNob3VsZCBub3QgYXBwbHkgc2Nyb2xsIGFuZCBmb2N1cyBtYW5hZ2VtZW50LlxuICAgICAgICAgIGZhbHNlLFxuICAgICAgb25seUhhc2hDaGFuZ2U6IG11dGFibGUub25seUhhc2hDaGFuZ2UgfHwgZmFsc2UsXG4gICAgICBoYXNoRnJhZ21lbnQ6IHNob3VsZFNjcm9sbFxuICAgICAgICA/IC8vIEVtcHR5IGhhc2ggc2hvdWxkIHRyaWdnZXIgZGVmYXVsdCBiZWhhdmlvciBvZiBzY3JvbGxpbmcgbGF5b3V0IGludG8gdmlldy5cbiAgICAgICAgICAvLyAjdG9wIGlzIGhhbmRsZWQgaW4gbGF5b3V0LXJvdXRlci5cbiAgICAgICAgICBtdXRhYmxlLmhhc2hGcmFnbWVudCAmJiBtdXRhYmxlLmhhc2hGcmFnbWVudCAhPT0gJydcbiAgICAgICAgICA/IC8vIFJlbW92ZSBsZWFkaW5nICMgYW5kIGRlY29kZSBoYXNoIHRvIG1ha2Ugbm9uLWxhdGluIGhhc2hlcyB3b3JrLlxuICAgICAgICAgICAgZGVjb2RlVVJJQ29tcG9uZW50KG11dGFibGUuaGFzaEZyYWdtZW50LnNsaWNlKDEpKVxuICAgICAgICAgIDogc3RhdGUuZm9jdXNBbmRTY3JvbGxSZWYuaGFzaEZyYWdtZW50XG4gICAgICAgIDogLy8gSWYgc2hvdWxkU2Nyb2xsIGlzIGZhbHNlIHRoZW4gd2Ugc2hvdWxkIG5vdCBhcHBseSBzY3JvbGwgYW5kIGZvY3VzIG1hbmFnZW1lbnQuXG4gICAgICAgICAgbnVsbCxcbiAgICAgIHNlZ21lbnRQYXRoczogc2hvdWxkU2Nyb2xsXG4gICAgICAgID8gbXV0YWJsZT8uc2Nyb2xsYWJsZVNlZ21lbnRzID8/IHN0YXRlLmZvY3VzQW5kU2Nyb2xsUmVmLnNlZ21lbnRQYXRoc1xuICAgICAgICA6IC8vIElmIHNob3VsZFNjcm9sbCBpcyBmYWxzZSB0aGVuIHdlIHNob3VsZCBub3QgYXBwbHkgc2Nyb2xsIGFuZCBmb2N1cyBtYW5hZ2VtZW50LlxuICAgICAgICAgIFtdLFxuICAgIH0sXG4gICAgLy8gQXBwbHkgY2FjaGUuXG4gICAgY2FjaGU6IG11dGFibGUuY2FjaGUgPyBtdXRhYmxlLmNhY2hlIDogc3RhdGUuY2FjaGUsXG4gICAgcHJlZmV0Y2hDYWNoZTogbXV0YWJsZS5wcmVmZXRjaENhY2hlXG4gICAgICA/IG11dGFibGUucHJlZmV0Y2hDYWNoZVxuICAgICAgOiBzdGF0ZS5wcmVmZXRjaENhY2hlLFxuICAgIC8vIEFwcGx5IHBhdGNoZWQgcm91dGVyIHN0YXRlLlxuICAgIHRyZWU6IGlzTm90VW5kZWZpbmVkKG11dGFibGUucGF0Y2hlZFRyZWUpXG4gICAgICA/IG11dGFibGUucGF0Y2hlZFRyZWVcbiAgICAgIDogc3RhdGUudHJlZSxcbiAgICBuZXh0VXJsLFxuICB9XG59XG4iXSwibmFtZXMiOlsiaGFuZGxlTXV0YWJsZSIsImlzTm90VW5kZWZpbmVkIiwidmFsdWUiLCJzdGF0ZSIsIm11dGFibGUiLCJzaG91bGRTY3JvbGwiLCJuZXh0VXJsIiwicGF0Y2hlZFRyZWUiLCJjaGFuZ2VkUGF0aCIsImNvbXB1dGVDaGFuZ2VkUGF0aCIsInRyZWUiLCJjYW5vbmljYWxVcmwiLCJwdXNoUmVmIiwicGVuZGluZ1B1c2giLCJtcGFOYXZpZ2F0aW9uIiwicHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGUiLCJmb2N1c0FuZFNjcm9sbFJlZiIsImFwcGx5Iiwic2Nyb2xsYWJsZVNlZ21lbnRzIiwib25seUhhc2hDaGFuZ2UiLCJoYXNoRnJhZ21lbnQiLCJkZWNvZGVVUklDb21wb25lbnQiLCJzbGljZSIsInNlZ21lbnRQYXRocyIsImNhY2hlIiwicHJlZmV0Y2hDYWNoZSJdLCJtYXBwaW5ncyI6Ijs7OytCQVdnQkEsaUJBQUFBOzs7ZUFBQUE7OztvQ0FYbUI7QUFPbkMsU0FBU0MsZUFBa0JDLEtBQVE7SUFDakMsT0FBTyxPQUFPQSxVQUFVO0FBQzFCO0FBRU8sU0FBU0YsY0FDZEcsS0FBMkIsRUFDM0JDLE9BQWdCO1FBR0tBO0lBRHJCLDBEQUEwRDtJQUMxRCxNQUFNQyxlQUFlRCxDQUFBQSx3QkFBQUEsUUFBUUMsWUFBWSxLQUFBLE9BQXBCRCx3QkFBd0I7SUFFN0MsSUFBSUUsVUFBVUgsTUFBTUcsT0FBTztJQUUzQixJQUFJTCxlQUFlRyxRQUFRRyxXQUFXLEdBQUc7UUFDdkMsc0VBQXNFO1FBQ3RFLE1BQU1DLGNBQWNDLENBQUFBLEdBQUFBLG9CQUFBQSxrQkFBa0IsRUFBQ04sTUFBTU8sSUFBSSxFQUFFTixRQUFRRyxXQUFXO1FBQ3RFLElBQUlDLGFBQWE7WUFDZixxREFBcUQ7WUFDckRGLFVBQVVFO1FBQ1osT0FBTyxJQUFJLENBQUNGLFNBQVM7WUFDbkIsNkhBQTZIO1lBQzdIQSxVQUFVSCxNQUFNUSxZQUFZO1FBQzlCO0lBQ0EsMEVBQTBFO0lBQzVFO1FBeUNRUDtJQXZDUixPQUFPO1FBQ0wsWUFBWTtRQUNaTyxjQUFjVixlQUFlRyxRQUFRTyxZQUFZLElBQzdDUCxRQUFRTyxZQUFZLEtBQUtSLE1BQU1RLFlBQVksR0FDekNSLE1BQU1RLFlBQVksR0FDbEJQLFFBQVFPLFlBQVksR0FDdEJSLE1BQU1RLFlBQVk7UUFDdEJDLFNBQVM7WUFDUEMsYUFBYVosZUFBZUcsUUFBUVMsV0FBVyxJQUMzQ1QsUUFBUVMsV0FBVyxHQUNuQlYsTUFBTVMsT0FBTyxDQUFDQyxXQUFXO1lBQzdCQyxlQUFlYixlQUFlRyxRQUFRVSxhQUFhLElBQy9DVixRQUFRVSxhQUFhLEdBQ3JCWCxNQUFNUyxPQUFPLENBQUNFLGFBQWE7WUFDL0JDLDRCQUE0QmQsZUFDMUJHLFFBQVFXLDBCQUEwQixJQUVoQ1gsUUFBUVcsMEJBQTBCLEdBQ2xDWixNQUFNUyxPQUFPLENBQUNHLDBCQUEwQjtRQUM5QztRQUNBLGtFQUFrRTtRQUNsRUMsbUJBQW1CO1lBQ2pCQyxPQUFPWixlQUNISixlQUFlRyxXQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxRQUFTYyxrQkFBa0IsSUFDeEMsT0FDQWYsTUFBTWEsaUJBQWlCLENBQUNDLEtBQUssR0FFL0I7WUFDSkUsZ0JBQWdCZixRQUFRZSxjQUFjLElBQUk7WUFDMUNDLGNBQWNmLGVBR1ZELEFBREEsUUFDUWdCLFlBQVksSUFBSWhCLFFBQVFnQixJQURJLFFBQ1EsS0FBSyxLQUUvQ0MsbUJBQW1CakIsUUFBUWdCLFlBQVksQ0FBQ0UsS0FBSyxDQUFDLE1BQzlDbkIsTUFBTWEsaUJBQWlCLENBQUNJLFlBQVksR0FFdEM7WUFDSkcsY0FBY2xCLGVBQ1ZELENBQUFBLDhCQUFBQSxXQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxRQUFTYyxrQkFBa0IsS0FBQSxPQUEzQmQsOEJBQStCRCxNQUFNYSxpQkFBaUIsQ0FBQ08sWUFBWSxHQUVuRSxFQUFFO1FBQ1I7UUFDQSxlQUFlO1FBQ2ZDLE9BQU9wQixRQUFRb0IsS0FBSyxHQUFHcEIsUUFBUW9CLEtBQUssR0FBR3JCLE1BQU1xQixLQUFLO1FBQ2xEQyxlQUFlckIsUUFBUXFCLGFBQWEsR0FDaENyQixRQUFRcUIsYUFBYSxHQUNyQnRCLE1BQU1zQixhQUFhO1FBQ3ZCLDhCQUE4QjtRQUM5QmYsTUFBTVQsZUFBZUcsUUFBUUcsV0FBVyxJQUNwQ0gsUUFBUUcsV0FBVyxHQUNuQkosTUFBTU8sSUFBSTtRQUNkSjtJQUNGO0FBQ0YiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMjk3OSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy8lNDBzd2MvaGVscGVycy9janMvX2NsYXNzX3ByaXZhdGVfZmllbGRfbG9vc2VfYmFzZS5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF9jbGFzc19wcml2YXRlX2ZpZWxkX2xvb3NlX2Jhc2UocmVjZWl2ZXIsIHByaXZhdGVLZXkpIHtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyZWNlaXZlciwgcHJpdmF0ZUtleSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImF0dGVtcHRlZCB0byB1c2UgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2VcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlY2VpdmVyO1xufVxuZXhwb3J0cy5fID0gX2NsYXNzX3ByaXZhdGVfZmllbGRfbG9vc2VfYmFzZTtcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFFQSxTQUFTLGdDQUFnQyxRQUFRLEVBQUUsVUFBVTtJQUN6RCxJQUFJLENBQUMsT0FBTyxTQUFTLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxVQUFVLGFBQWE7UUFDN0QsTUFBTSxJQUFJLFVBQVU7SUFDeEI7SUFFQSxPQUFPO0FBQ1g7QUFDQSxRQUFRLENBQUMsR0FBRyIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAyOTkyLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzLyU0MHN3Yy9oZWxwZXJzL2Nqcy9fY2xhc3NfcHJpdmF0ZV9maWVsZF9sb29zZV9rZXkuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgaWQgPSAwO1xuXG5mdW5jdGlvbiBfY2xhc3NfcHJpdmF0ZV9maWVsZF9sb29zZV9rZXkobmFtZSkge1xuICAgIHJldHVybiBcIl9fcHJpdmF0ZV9cIiArIGlkKysgKyBcIl9cIiArIG5hbWU7XG59XG5leHBvcnRzLl8gPSBfY2xhc3NfcHJpdmF0ZV9maWVsZF9sb29zZV9rZXk7XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBRUEsSUFBSSxLQUFLO0FBRVQsU0FBUywrQkFBK0IsSUFBSTtJQUN4QyxPQUFPLGVBQWUsT0FBTyxNQUFNO0FBQ3ZDO0FBQ0EsUUFBUSxDQUFDLEdBQUciLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMzAwMywgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvY29tcG9uZW50cy9wcm9taXNlLXF1ZXVlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgVGhpcyBpcyBhIHNpbXBsZSBwcm9taXNlIHF1ZXVlIHRoYXQgYWxsb3dzIHlvdSB0byBsaW1pdCB0aGUgbnVtYmVyIG9mIGNvbmN1cnJlbnQgcHJvbWlzZXNcbiAgICB0aGF0IGFyZSBydW5uaW5nIGF0IGFueSBnaXZlbiB0aW1lLiBJdCdzIHVzZWQgdG8gbGltaXQgdGhlIG51bWJlciBvZiBjb25jdXJyZW50XG4gICAgcHJlZmV0Y2ggcmVxdWVzdHMgdGhhdCBhcmUgYmVpbmcgbWFkZSB0byB0aGUgc2VydmVyIGJ1dCBjb3VsZCBiZSB1c2VkIGZvciBvdGhlclxuICAgIHRoaW5ncyBhcyB3ZWxsLlxuKi9cbmV4cG9ydCBjbGFzcyBQcm9taXNlUXVldWUge1xuICAjbWF4Q29uY3VycmVuY3k6IG51bWJlclxuICAjcnVubmluZ0NvdW50OiBudW1iZXJcbiAgI3F1ZXVlOiBBcnJheTx7XG4gICAgcHJvbWlzZUZuOiBQcm9taXNlPGFueT5cbiAgICB0YXNrOiAoKSA9PiB2b2lkXG4gIH0+XG5cbiAgY29uc3RydWN0b3IobWF4Q29uY3VycmVuY3kgPSA1KSB7XG4gICAgdGhpcy4jbWF4Q29uY3VycmVuY3kgPSBtYXhDb25jdXJyZW5jeVxuICAgIHRoaXMuI3J1bm5pbmdDb3VudCA9IDBcbiAgICB0aGlzLiNxdWV1ZSA9IFtdXG4gIH1cblxuICBlbnF1ZXVlPFQ+KHByb21pc2VGbjogKCkgPT4gUHJvbWlzZTxUPik6IFByb21pc2U8VD4ge1xuICAgIGxldCB0YXNrUmVzb2x2ZTogKHZhbHVlOiBUIHwgUHJvbWlzZUxpa2U8VD4pID0+IHZvaWRcbiAgICBsZXQgdGFza1JlamVjdDogKHJlYXNvbj86IGFueSkgPT4gdm9pZFxuXG4gICAgY29uc3QgdGFza1Byb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0YXNrUmVzb2x2ZSA9IHJlc29sdmVcbiAgICAgIHRhc2tSZWplY3QgPSByZWplY3RcbiAgICB9KSBhcyBQcm9taXNlPFQ+XG5cbiAgICBjb25zdCB0YXNrID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy4jcnVubmluZ0NvdW50KytcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvbWlzZUZuKClcbiAgICAgICAgdGFza1Jlc29sdmUocmVzdWx0KVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGFza1JlamVjdChlcnJvcilcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXMuI3J1bm5pbmdDb3VudC0tXG4gICAgICAgIHRoaXMuI3Byb2Nlc3NOZXh0KClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBlbnF1ZXVlUmVzdWx0ID0geyBwcm9taXNlRm46IHRhc2tQcm9taXNlLCB0YXNrIH1cbiAgICAvLyB3b25kZXIgaWYgd2Ugc2hvdWxkIHRha2UgYSBMSUZPIGFwcHJvYWNoIGhlcmVcbiAgICB0aGlzLiNxdWV1ZS5wdXNoKGVucXVldWVSZXN1bHQpXG4gICAgdGhpcy4jcHJvY2Vzc05leHQoKVxuXG4gICAgcmV0dXJuIHRhc2tQcm9taXNlXG4gIH1cblxuICBidW1wKHByb21pc2VGbjogUHJvbWlzZTxhbnk+KSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLiNxdWV1ZS5maW5kSW5kZXgoKGl0ZW0pID0+IGl0ZW0ucHJvbWlzZUZuID09PSBwcm9taXNlRm4pXG5cbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgY29uc3QgYnVtcGVkSXRlbSA9IHRoaXMuI3F1ZXVlLnNwbGljZShpbmRleCwgMSlbMF1cbiAgICAgIHRoaXMuI3F1ZXVlLnVuc2hpZnQoYnVtcGVkSXRlbSlcbiAgICAgIHRoaXMuI3Byb2Nlc3NOZXh0KHRydWUpXG4gICAgfVxuICB9XG5cbiAgI3Byb2Nlc3NOZXh0KGZvcmNlZCA9IGZhbHNlKSB7XG4gICAgaWYgKFxuICAgICAgKHRoaXMuI3J1bm5pbmdDb3VudCA8IHRoaXMuI21heENvbmN1cnJlbmN5IHx8IGZvcmNlZCkgJiZcbiAgICAgIHRoaXMuI3F1ZXVlLmxlbmd0aCA+IDBcbiAgICApIHtcbiAgICAgIHRoaXMuI3F1ZXVlLnNoaWZ0KCk/LnRhc2soKVxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbIlByb21pc2VRdWV1ZSIsImVucXVldWUiLCJwcm9taXNlRm4iLCJ0YXNrUmVzb2x2ZSIsInRhc2tSZWplY3QiLCJ0YXNrUHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwidGFzayIsInJlc3VsdCIsImVycm9yIiwiZW5xdWV1ZVJlc3VsdCIsInB1c2giLCJidW1wIiwiaW5kZXgiLCJmaW5kSW5kZXgiLCJpdGVtIiwiYnVtcGVkSXRlbSIsInNwbGljZSIsInVuc2hpZnQiLCJjb25zdHJ1Y3RvciIsIm1heENvbmN1cnJlbmN5IiwiZm9yY2VkIiwibGVuZ3RoIiwic2hpZnQiXSwibWFwcGluZ3MiOiJBQUFBOzs7OztBQUtBOzs7K0JBQ2FBLGdCQUFBQTs7O2VBQUFBOzs7OztJQUNYLGtCQUFBLFdBQUEsR0FBQSwrQkFBQSxDQUFBLENBQUEsb0JBQ0EsZ0JBQUEsV0FBQSxHQUFBLCtCQUFBLENBQUEsQ0FBQSxrQkFDQSxTQUFBLFdBQUEsR0FBQSwrQkFBQSxDQUFBLENBQUEsV0FtREEsZUFBQSxXQUFBLEdBQUEsK0JBQUEsQ0FBQSxDQUFBO0FBdERLLE1BQU1BO0lBY1hDLFFBQVdDLFNBQTJCLEVBQWM7UUFDbEQsSUFBSUM7UUFDSixJQUFJQztRQUVKLE1BQU1DLGNBQWMsSUFBSUMsUUFBUSxDQUFDQyxTQUFTQztZQUN4Q0wsY0FBY0k7WUFDZEgsYUFBYUk7UUFDZjtRQUVBLE1BQU1DLE9BQU87WUFDWCxJQUFJO2dCQUNGLGdDQUFBLENBQUEsQ0FBQSxJQUFJLEVBQUMsY0FBQSxDQUFBLGNBQUE7Z0JBQ0wsTUFBTUMsU0FBUyxNQUFNUjtnQkFDckJDLFlBQVlPO1lBQ2QsRUFBRSxPQUFPQyxPQUFPO2dCQUNkUCxXQUFXTztZQUNiLFNBQVU7Z0JBQ1IsZ0NBQUEsQ0FBQSxDQUFBLElBQUksRUFBQyxjQUFBLENBQUEsY0FBQTtnQkFDTCxnQ0FBQSxDQUFBLENBQUEsSUFBSSxFQUFDLGFBQUEsQ0FBQSxhQUFBO1lBQ1A7UUFDRjtRQUVBLE1BQU1DLGdCQUFnQjtZQUFFVixXQUFXRztZQUFhSTtRQUFLO1FBQ3JELGdEQUFnRDtRQUNoRCxnQ0FBQSxDQUFBLENBQUEsSUFBSSxFQUFDLE9BQUEsQ0FBQSxPQUFBLENBQU9JLElBQUksQ0FBQ0Q7UUFDakIsZ0NBQUEsQ0FBQSxDQUFBLElBQUksRUFBQyxhQUFBLENBQUEsYUFBQTtRQUVMLE9BQU9QO0lBQ1Q7SUFFQVMsS0FBS1osU0FBdUIsRUFBRTtRQUM1QixNQUFNYSxRQUFRLGdDQUFBLENBQUEsQ0FBQSxJQUFJLEVBQUMsT0FBQSxDQUFBLE9BQUEsQ0FBT0MsU0FBUyxDQUFDLENBQUNDLE9BQVNBLEtBQUtmLFNBQVMsS0FBS0E7UUFFakUsSUFBSWEsUUFBUSxDQUFDLEdBQUc7WUFDZCxNQUFNRyxhQUFhLGdDQUFBLENBQUEsQ0FBQSxJQUFJLEVBQUMsT0FBQSxDQUFBLE9BQUEsQ0FBT0MsTUFBTSxDQUFDSixPQUFPLEVBQUUsQ0FBQyxFQUFFO1lBQ2xELGdDQUFBLENBQUEsQ0FBQSxJQUFJLEVBQUMsT0FBQSxDQUFBLE9BQUEsQ0FBT0ssT0FBTyxDQUFDRjtZQUNwQixnQ0FBQSxDQUFBLENBQUEsSUFBSSxFQUFDLGFBQUEsQ0FBQSxhQUFBLENBQWE7UUFDcEI7SUFDRjtJQTVDQUcsWUFBWUMsaUJBQWlCLENBQUMsQ0FBRTtRQThDaEMsT0FBQSxjQUFBLENBQUEsSUFBQSxFQUFBLGNBQUE7bUJBQUE7O1FBckRBLE9BQUEsY0FBQSxDQUFBLElBQUEsRUFBQSxpQkFBQTs7bUJBQUEsS0FBQTs7UUFDQSxPQUFBLGNBQUEsQ0FBQSxJQUFBLEVBQUEsZUFBQTs7bUJBQUEsS0FBQTs7UUFDQSxPQUFBLGNBQUEsQ0FBQSxJQUFBLEVBQUEsUUFBQTs7bUJBQUEsS0FBQTs7UUFNRSxnQ0FBQSxDQUFBLENBQUEsSUFBSSxFQUFDLGdCQUFBLENBQUEsZ0JBQUEsR0FBa0JBO1FBQ3ZCLGdDQUFBLENBQUEsQ0FBQSxJQUFJLEVBQUMsY0FBQSxDQUFBLGNBQUEsR0FBZ0I7UUFDckIsZ0NBQUEsQ0FBQSxDQUFBLElBQUksRUFBQyxPQUFBLENBQUEsT0FBQSxHQUFTLEVBQUU7SUFDbEI7QUFrREY7QUFSRSxTQUFBLFlBQWFDLE1BQWM7SUFBZEEsSUFBQUEsV0FBQUEsS0FBQUEsR0FBQUEsU0FBUztJQUNwQixJQUNHLENBQUEsZ0NBQUEsQ0FBQSxDQUFBLElBQUksRUFBQyxjQUFBLENBQUEsY0FBQSxHQUFnQixnQ0FBQSxDQUFBLENBQUEsSUFBSSxFQUFDLGdCQUFBLENBQUEsZ0JBQUEsSUFBbUJBLE1BQUssS0FDbkQsZ0NBQUEsQ0FBQSxDQUFBLElBQUksRUFBQyxPQUFBLENBQUEsT0FBQSxDQUFPQyxNQUFNLEdBQUcsR0FDckI7WUFDQTtTQUFBLCtDQUFBLGdDQUFBLENBQUEsQ0FBQSxJQUFJLEVBQUMsT0FBQSxDQUFBLE9BQUEsQ0FBT0MsS0FBSyxFQUFBLEtBQUEsT0FBQSxLQUFBLElBQWpCLDZDQUFxQmhCLElBQUk7SUFDM0I7QUFDRiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAzMDk4LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3ByZWZldGNoLWNhY2hlLXV0aWxzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIGZldGNoU2VydmVyUmVzcG9uc2UsXG4gIHR5cGUgRmV0Y2hTZXJ2ZXJSZXNwb25zZVJlc3VsdCxcbn0gZnJvbSAnLi9mZXRjaC1zZXJ2ZXItcmVzcG9uc2UnXG5pbXBvcnQge1xuICBQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMsXG4gIHR5cGUgUHJlZmV0Y2hDYWNoZUVudHJ5LFxuICBQcmVmZXRjaEtpbmQsXG4gIHR5cGUgUmVhZG9ubHlSZWR1Y2VyU3RhdGUsXG59IGZyb20gJy4vcm91dGVyLXJlZHVjZXItdHlwZXMnXG5pbXBvcnQgeyBwcmVmZXRjaFF1ZXVlIH0gZnJvbSAnLi9yZWR1Y2Vycy9wcmVmZXRjaC1yZWR1Y2VyJ1xuXG5jb25zdCBJTlRFUkNFUFRJT05fQ0FDSEVfS0VZX01BUktFUiA9ICclJ1xuXG5leHBvcnQgdHlwZSBBbGlhc2VkUHJlZmV0Y2hDYWNoZUVudHJ5ID0gUHJlZmV0Y2hDYWNoZUVudHJ5ICYge1xuICAvKiogVGhpcyBpcyBhIHNwZWNpYWwgcHJvcGVydHkgdGhhdCBpbmRpY2F0ZXMgYSBwcmVmZXRjaCBlbnRyeSBhc3NvY2lhdGVkIHdpdGggYSBkaWZmZXJlbnQgVVJMXG4gICAqIHdhcyByZXR1cm5lZCByYXRoZXIgdGhhbiB0aGUgcmVxdWVzdGVkIFVSTC4gVGhpcyBzaWduYWxzIHRvIHRoZSByb3V0ZXIgdGhhdCBpdCBzaG91bGQgb25seVxuICAgKiBhcHBseSB0aGUgcGFydCB0aGF0IGRvZXNuJ3QgZGVwZW5kIG9uIHNlYXJjaFBhcmFtcyAoc3BlY2lmaWNhbGx5IHRoZSBsb2FkaW5nIHN0YXRlKS5cbiAgICovXG4gIGFsaWFzZWQ/OiBib29sZWFuXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNhY2hlIGtleSBmb3IgdGhlIHJvdXRlciBwcmVmZXRjaCBjYWNoZVxuICpcbiAqIEBwYXJhbSB1cmwgLSBUaGUgVVJMIGJlaW5nIG5hdmlnYXRlZCB0b1xuICogQHBhcmFtIG5leHRVcmwgLSBhbiBpbnRlcm5hbCBVUkwsIHByaW1hcmlseSB1c2VkIGZvciBoYW5kbGluZyByZXdyaXRlcy4gRGVmYXVsdHMgdG8gJy8nLlxuICogQHJldHVybiBUaGUgZ2VuZXJhdGVkIHByZWZldGNoIGNhY2hlIGtleS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUHJlZmV0Y2hDYWNoZUtleUltcGwoXG4gIHVybDogVVJMLFxuICBpbmNsdWRlU2VhcmNoUGFyYW1zOiBib29sZWFuLFxuICBwcmVmaXg/OiBzdHJpbmcgfCBudWxsXG4pIHtcbiAgLy8gSW5pdGlhbGx5IHdlIG9ubHkgdXNlIHRoZSBwYXRobmFtZSBhcyB0aGUgY2FjaGUga2V5LiBXZSBkb24ndCB3YW50IHRvIGluY2x1ZGVcbiAgLy8gc2VhcmNoIHBhcmFtcyBzbyB0aGF0IG11bHRpcGxlIFVSTHMgd2l0aCB0aGUgc2FtZSBzZWFyY2ggcGFyYW1ldGVyIGNhbiByZS11c2VcbiAgLy8gbG9hZGluZyBzdGF0ZXMuXG4gIGxldCBwYXRobmFtZUZyb21VcmwgPSB1cmwucGF0aG5hbWVcblxuICAvLyBSU0MgcmVzcG9uc2VzIGNhbiBkaWZmZXIgYmFzZWQgb24gc2VhcmNoIHBhcmFtcywgc3BlY2lmaWNhbGx5IGluIHRoZSBjYXNlIHdoZXJlIHdlIGFyZW4ndFxuICAvLyByZXR1cm5pbmcgYSBwYXJ0aWFsIHJlc3BvbnNlIChpZSB3aXRoIGBQcmVmZXRjaEtpbmQuQVVUT2ApLlxuICAvLyBJbiB0aGUgYXV0byBjYXNlLCBzaW5jZSBsb2FkaW5nLmpzICYgbGF5b3V0LmpzIHdvbid0IGhhdmUgYWNjZXNzIHRvIHNlYXJjaCBwYXJhbXMsXG4gIC8vIHdlIGNhbiBzYWZlbHkgcmUtdXNlIHRoYXQgY2FjaGUgZW50cnkuIEJ1dCBmb3IgZnVsbCBwcmVmZXRjaGVzLCB3ZSBzaG91bGQgbm90XG4gIC8vIHJlLXVzZSB0aGUgY2FjaGUgZW50cnkgYXMgdGhlIHJlc3BvbnNlIG1heSBkaWZmZXIuXG4gIGlmIChpbmNsdWRlU2VhcmNoUGFyYW1zKSB7XG4gICAgLy8gaWYgd2UgaGF2ZSBhIGZ1bGwgcHJlZmV0Y2gsIHdlIGNhbiBpbmNsdWRlIHRoZSBzZWFyY2ggcGFyYW0gaW4gdGhlIGtleSxcbiAgICAvLyBhcyB3ZSdsbCBiZSBnZXR0aW5nIGJhY2sgYSBmdWxsIHJlc3BvbnNlLiBUaGUgc2VydmVyIG1pZ2h0IGhhdmUgcmVhZCB0aGUgc2VhcmNoXG4gICAgLy8gcGFyYW1zIHdoZW4gZ2VuZXJhdGluZyB0aGUgZnVsbCByZXNwb25zZS5cbiAgICBwYXRobmFtZUZyb21VcmwgKz0gdXJsLnNlYXJjaFxuICB9XG5cbiAgaWYgKHByZWZpeCkge1xuICAgIHJldHVybiBgJHtwcmVmaXh9JHtJTlRFUkNFUFRJT05fQ0FDSEVfS0VZX01BUktFUn0ke3BhdGhuYW1lRnJvbVVybH1gXG4gIH1cblxuICByZXR1cm4gcGF0aG5hbWVGcm9tVXJsXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVByZWZldGNoQ2FjaGVLZXkoXG4gIHVybDogVVJMLFxuICBraW5kOiBQcmVmZXRjaEtpbmQgfCB1bmRlZmluZWQsXG4gIG5leHRVcmw/OiBzdHJpbmcgfCBudWxsXG4pIHtcbiAgcmV0dXJuIGNyZWF0ZVByZWZldGNoQ2FjaGVLZXlJbXBsKHVybCwga2luZCA9PT0gUHJlZmV0Y2hLaW5kLkZVTEwsIG5leHRVcmwpXG59XG5cbmZ1bmN0aW9uIGdldEV4aXN0aW5nQ2FjaGVFbnRyeShcbiAgdXJsOiBVUkwsXG4gIGtpbmQ6IFByZWZldGNoS2luZCA9IFByZWZldGNoS2luZC5URU1QT1JBUlksXG4gIG5leHRVcmw6IHN0cmluZyB8IG51bGwsXG4gIHByZWZldGNoQ2FjaGU6IE1hcDxzdHJpbmcsIFByZWZldGNoQ2FjaGVFbnRyeT4sXG4gIGFsbG93QWxpYXNpbmc6IGJvb2xlYW5cbik6IEFsaWFzZWRQcmVmZXRjaENhY2hlRW50cnkgfCB1bmRlZmluZWQge1xuICAvLyBXZSBmaXJzdCBjaGVjayBpZiB0aGVyZSdzIGEgbW9yZSBzcGVjaWZpYyBpbnRlcmNlcHRpb24gcm91dGUgcHJlZmV0Y2ggZW50cnlcbiAgLy8gVGhpcyBpcyBiZWNhdXNlIHdoZW4gd2UgZGV0ZWN0IGEgcHJlZmV0Y2ggdGhhdCBjb3JyZXNwb25kcyB3aXRoIGFuIGludGVyY2VwdGlvbiByb3V0ZSwgd2UgcHJlZml4IGl0IHdpdGggbmV4dFVybCAoc2VlIGBjcmVhdGVQcmVmZXRjaENhY2hlS2V5YClcbiAgLy8gdG8gYXZvaWQgY29uZmxpY3RzIHdpdGggb3RoZXIgcGFnZXMgdGhhdCBtYXkgaGF2ZSB0aGUgc2FtZSBVUkwgYnV0IHJlbmRlciBkaWZmZXJlbnQgdGhpbmdzIGRlcGVuZGluZyBvbiB0aGUgYE5leHQtVVJMYCBoZWFkZXIuXG4gIGZvciAoY29uc3QgbWF5YmVOZXh0VXJsIG9mIFtuZXh0VXJsLCBudWxsXSkge1xuICAgIGNvbnN0IGNhY2hlS2V5V2l0aFBhcmFtcyA9IGNyZWF0ZVByZWZldGNoQ2FjaGVLZXlJbXBsKFxuICAgICAgdXJsLFxuICAgICAgdHJ1ZSxcbiAgICAgIG1heWJlTmV4dFVybFxuICAgIClcbiAgICBjb25zdCBjYWNoZUtleVdpdGhvdXRQYXJhbXMgPSBjcmVhdGVQcmVmZXRjaENhY2hlS2V5SW1wbChcbiAgICAgIHVybCxcbiAgICAgIGZhbHNlLFxuICAgICAgbWF5YmVOZXh0VXJsXG4gICAgKVxuXG4gICAgLy8gRmlyc3QsIHdlIGNoZWNrIGlmIHdlIGhhdmUgYSBjYWNoZSBlbnRyeSB0aGF0IGV4YWN0bHkgbWF0Y2hlcyB0aGUgVVJMXG4gICAgY29uc3QgY2FjaGVLZXlUb1VzZSA9IHVybC5zZWFyY2hcbiAgICAgID8gY2FjaGVLZXlXaXRoUGFyYW1zXG4gICAgICA6IGNhY2hlS2V5V2l0aG91dFBhcmFtc1xuXG4gICAgY29uc3QgZXhpc3RpbmdFbnRyeSA9IHByZWZldGNoQ2FjaGUuZ2V0KGNhY2hlS2V5VG9Vc2UpXG4gICAgaWYgKGV4aXN0aW5nRW50cnkgJiYgYWxsb3dBbGlhc2luZykge1xuICAgICAgLy8gV2Uga25vdyB3ZSdyZSByZXR1cm5pbmcgYW4gYWxpYXNlZCBlbnRyeSB3aGVuIHRoZSBwYXRobmFtZSBtYXRjaGVzIGJ1dCB0aGUgc2VhcmNoIHBhcmFtcyBkb24ndCxcbiAgICAgIGNvbnN0IGlzQWxpYXNlZCA9XG4gICAgICAgIGV4aXN0aW5nRW50cnkudXJsLnBhdGhuYW1lID09PSB1cmwucGF0aG5hbWUgJiZcbiAgICAgICAgZXhpc3RpbmdFbnRyeS51cmwuc2VhcmNoICE9PSB1cmwuc2VhcmNoXG5cbiAgICAgIGlmIChpc0FsaWFzZWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5leGlzdGluZ0VudHJ5LFxuICAgICAgICAgIGFsaWFzZWQ6IHRydWUsXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGV4aXN0aW5nRW50cnlcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgcmVxdWVzdCBjb250YWlucyBzZWFyY2ggcGFyYW1zLCBhbmQgd2UncmUgbm90IGRvaW5nIGEgZnVsbCBwcmVmZXRjaCwgd2UgY2FuIHJldHVybiB0aGVcbiAgICAvLyBwYXJhbS1sZXNzIGVudHJ5IGlmIGl0IGV4aXN0cy5cbiAgICAvLyBUaGlzIGlzIHRlY2huaWNhbGx5IGNvdmVyZWQgYnkgdGhlIGNoZWNrIGF0IHRoZSBib3R0b20gb2YgdGhpcyBmdW5jdGlvbiwgd2hpY2ggaXRlcmF0ZXMgb3ZlciBjYWNoZSBlbnRyaWVzLFxuICAgIC8vIGJ1dCBsZXRzIHVzIGFycml2ZSB0aGVyZSBxdWlja2VyIGluIHRoZSBwYXJhbS1mdWxsIGNhc2UuXG4gICAgY29uc3QgZW50cnlXaXRob3V0UGFyYW1zID0gcHJlZmV0Y2hDYWNoZS5nZXQoY2FjaGVLZXlXaXRob3V0UGFyYW1zKVxuICAgIGlmIChcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAnZGV2ZWxvcG1lbnQnICYmXG4gICAgICBhbGxvd0FsaWFzaW5nICYmXG4gICAgICB1cmwuc2VhcmNoICYmXG4gICAgICBraW5kICE9PSBQcmVmZXRjaEtpbmQuRlVMTCAmJlxuICAgICAgZW50cnlXaXRob3V0UGFyYW1zICYmXG4gICAgICAvLyBXZSBzaG91bGRuJ3QgcmV0dXJuIHRoZSBhbGlhc2VkIGVudHJ5IGlmIGl0IHdhcyByZWxvY2F0ZWQgdG8gYSBuZXcgY2FjaGUga2V5LlxuICAgICAgLy8gU2luY2UgaXQncyByZXdyaXR0ZW4sIGl0IGNvdWxkIHJlc3BvbmQgd2l0aCBhIGNvbXBsZXRlbHkgZGlmZmVyZW50IGxvYWRpbmcgc3RhdGUuXG4gICAgICAhZW50cnlXaXRob3V0UGFyYW1zLmtleS5pbmNsdWRlcyhJTlRFUkNFUFRJT05fQ0FDSEVfS0VZX01BUktFUilcbiAgICApIHtcbiAgICAgIHJldHVybiB7IC4uLmVudHJ5V2l0aG91dFBhcmFtcywgYWxpYXNlZDogdHJ1ZSB9XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgd2UndmUgZ290dGVuIHRvIHRoaXMgcG9pbnQsIHdlIGRpZG4ndCBmaW5kIGEgc3BlY2lmaWMgY2FjaGUgZW50cnkgdGhhdCBtYXRjaGVkXG4gIC8vIHRoZSByZXF1ZXN0IFVSTC5cbiAgLy8gV2UgYXR0ZW1wdCBhIHBhcnRpYWwgbWF0Y2ggYnkgY2hlY2tpbmcgaWYgdGhlcmUncyBhIGNhY2hlIGVudHJ5IHdpdGggdGhlIHNhbWUgcGF0aG5hbWUuXG4gIC8vIFJlZ2FyZGxlc3Mgb2Ygd2hhdCB3ZSBmaW5kLCBzaW5jZSBpdCBkb2Vzbid0IGNvcnJlc3BvbmQgd2l0aCB0aGUgcmVxdWVzdGVkIFVSTCwgd2UnbGwgbWFyayBpdCBcImFsaWFzZWRcIi5cbiAgLy8gVGhpcyB3aWxsIHNpZ25hbCB0byB0aGUgcm91dGVyIHRoYXQgaXQgc2hvdWxkIG9ubHkgYXBwbHkgdGhlIGxvYWRpbmcgc3RhdGUgb24gdGhlIHByZWZldGNoZWQgZGF0YS5cbiAgaWYgKFxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAnZGV2ZWxvcG1lbnQnICYmXG4gICAga2luZCAhPT0gUHJlZmV0Y2hLaW5kLkZVTEwgJiZcbiAgICBhbGxvd0FsaWFzaW5nXG4gICkge1xuICAgIGZvciAoY29uc3QgY2FjaGVFbnRyeSBvZiBwcmVmZXRjaENhY2hlLnZhbHVlcygpKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGNhY2hlRW50cnkudXJsLnBhdGhuYW1lID09PSB1cmwucGF0aG5hbWUgJiZcbiAgICAgICAgLy8gV2Ugc2hvdWxkbid0IHJldHVybiB0aGUgYWxpYXNlZCBlbnRyeSBpZiBpdCB3YXMgcmVsb2NhdGVkIHRvIGEgbmV3IGNhY2hlIGtleS5cbiAgICAgICAgLy8gU2luY2UgaXQncyByZXdyaXR0ZW4sIGl0IGNvdWxkIHJlc3BvbmQgd2l0aCBhIGNvbXBsZXRlbHkgZGlmZmVyZW50IGxvYWRpbmcgc3RhdGUuXG4gICAgICAgICFjYWNoZUVudHJ5LmtleS5pbmNsdWRlcyhJTlRFUkNFUFRJT05fQ0FDSEVfS0VZX01BUktFUilcbiAgICAgICkge1xuICAgICAgICByZXR1cm4geyAuLi5jYWNoZUVudHJ5LCBhbGlhc2VkOiB0cnVlIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkXG59XG5cbi8qKlxuICogUmV0dXJucyBhIHByZWZldGNoIGNhY2hlIGVudHJ5IGlmIG9uZSBleGlzdHMuIE90aGVyd2lzZSBjcmVhdGVzIGEgbmV3IG9uZSBhbmQgZW5xdWV1ZXMgYSBmZXRjaCByZXF1ZXN0XG4gKiB0byByZXRyaWV2ZSB0aGUgcHJlZmV0Y2ggZGF0YSBmcm9tIHRoZSBzZXJ2ZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRPckNyZWF0ZVByZWZldGNoQ2FjaGVFbnRyeSh7XG4gIHVybCxcbiAgbmV4dFVybCxcbiAgdHJlZSxcbiAgcHJlZmV0Y2hDYWNoZSxcbiAga2luZCxcbiAgYWxsb3dBbGlhc2luZyA9IHRydWUsXG59OiBQaWNrPFJlYWRvbmx5UmVkdWNlclN0YXRlLCAnbmV4dFVybCcgfCAncHJlZmV0Y2hDYWNoZScgfCAndHJlZSc+ICYge1xuICB1cmw6IFVSTFxuICBraW5kPzogUHJlZmV0Y2hLaW5kXG4gIGFsbG93QWxpYXNpbmc6IGJvb2xlYW5cbn0pOiBBbGlhc2VkUHJlZmV0Y2hDYWNoZUVudHJ5IHtcbiAgY29uc3QgZXhpc3RpbmdDYWNoZUVudHJ5ID0gZ2V0RXhpc3RpbmdDYWNoZUVudHJ5KFxuICAgIHVybCxcbiAgICBraW5kLFxuICAgIG5leHRVcmwsXG4gICAgcHJlZmV0Y2hDYWNoZSxcbiAgICBhbGxvd0FsaWFzaW5nXG4gIClcblxuICBpZiAoZXhpc3RpbmdDYWNoZUVudHJ5KSB7XG4gICAgLy8gR3JhYiB0aGUgbGF0ZXN0IHN0YXR1cyBvZiB0aGUgY2FjaGUgZW50cnkgYW5kIHVwZGF0ZSBpdFxuICAgIGV4aXN0aW5nQ2FjaGVFbnRyeS5zdGF0dXMgPSBnZXRQcmVmZXRjaEVudHJ5Q2FjaGVTdGF0dXMoZXhpc3RpbmdDYWNoZUVudHJ5KVxuXG4gICAgLy8gd2hlbiBga2luZGAgaXMgcHJvdmlkZWQsIGFuIGV4cGxpY2l0IHByZWZldGNoIHdhcyByZXF1ZXN0ZWQuXG4gICAgLy8gaWYgdGhlIHJlcXVlc3RlZCBwcmVmZXRjaCBpcyBcImZ1bGxcIiBhbmQgdGhlIGN1cnJlbnQgY2FjaGUgZW50cnkgd2Fzbid0LCB3ZSB3YW50IHRvIHJlLXByZWZldGNoIHdpdGggdGhlIG5ldyBpbnRlbnRcbiAgICBjb25zdCBzd2l0Y2hlZFRvRnVsbFByZWZldGNoID1cbiAgICAgIGV4aXN0aW5nQ2FjaGVFbnRyeS5raW5kICE9PSBQcmVmZXRjaEtpbmQuRlVMTCAmJlxuICAgICAga2luZCA9PT0gUHJlZmV0Y2hLaW5kLkZVTExcblxuICAgIGlmIChzd2l0Y2hlZFRvRnVsbFByZWZldGNoKSB7XG4gICAgICAvLyBJZiB3ZSBzd2l0Y2hlZCB0byBhIGZ1bGwgcHJlZmV0Y2gsIHZhbGlkYXRlIHRoYXQgdGhlIGV4aXN0aW5nIGNhY2hlIGVudHJ5IGNvbnRhaW5lZCBwYXJ0aWFsIGRhdGEuXG4gICAgICAvLyBJdCdzIHBvc3NpYmxlIHRoYXQgdGhlIGNhY2hlIGVudHJ5IHdhcyBzZWVkZWQgd2l0aCBmdWxsIGRhdGEgYnV0IGhhcyBhIGNhY2hlIHR5cGUgb2YgXCJhdXRvXCIgKGllIHdoZW4gY2FjaGUgZW50cmllc1xuICAgICAgLy8gYXJlIHNlZWRlZCBidXQgd2l0aG91dCBhIHByZWZldGNoIGludGVudClcbiAgICAgIGV4aXN0aW5nQ2FjaGVFbnRyeS5kYXRhLnRoZW4oKHByZWZldGNoUmVzcG9uc2UpID0+IHtcbiAgICAgICAgY29uc3QgaXNGdWxsUHJlZmV0Y2ggPVxuICAgICAgICAgIEFycmF5LmlzQXJyYXkocHJlZmV0Y2hSZXNwb25zZS5mbGlnaHREYXRhKSAmJlxuICAgICAgICAgIHByZWZldGNoUmVzcG9uc2UuZmxpZ2h0RGF0YS5zb21lKChmbGlnaHREYXRhKSA9PiB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBzdGFydGVkIHJlbmRlcmluZyBmcm9tIHRoZSByb290IGFuZCB3ZSByZXR1cm5lZCBSU0MgZGF0YSAoc2VlZERhdGEpLCB3ZSBhbHJlYWR5IGhhZCBhIGZ1bGwgcHJlZmV0Y2guXG4gICAgICAgICAgICByZXR1cm4gZmxpZ2h0RGF0YS5pc1Jvb3RSZW5kZXIgJiYgZmxpZ2h0RGF0YS5zZWVkRGF0YSAhPT0gbnVsbFxuICAgICAgICAgIH0pXG5cbiAgICAgICAgaWYgKCFpc0Z1bGxQcmVmZXRjaCkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVMYXp5UHJlZmV0Y2hFbnRyeSh7XG4gICAgICAgICAgICB0cmVlLFxuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgbmV4dFVybCxcbiAgICAgICAgICAgIHByZWZldGNoQ2FjaGUsXG4gICAgICAgICAgICAvLyBJZiB3ZSBkaWRuJ3QgZ2V0IGFuIGV4cGxpY2l0IHByZWZldGNoIGtpbmQsIHdlIHdhbnQgdG8gc2V0IGEgdGVtcG9yYXJ5IGtpbmRcbiAgICAgICAgICAgIC8vIHJhdGhlciB0aGFuIGFzc3VtaW5nIHRoZSBzYW1lIGludGVudCBhcyB0aGUgcHJldmlvdXMgZW50cnksIHRvIGJlIGNvbnNpc3RlbnQgd2l0aCBob3cgd2VcbiAgICAgICAgICAgIC8vIGxhemlseSBjcmVhdGUgcHJlZmV0Y2ggZW50cmllcyB3aGVuIGludGVudCBpcyBsZWZ0IHVuc3BlY2lmaWVkLlxuICAgICAgICAgICAga2luZDoga2luZCA/PyBQcmVmZXRjaEtpbmQuVEVNUE9SQVJZLFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGV4aXN0aW5nIGNhY2hlIGVudHJ5IHdhcyBtYXJrZWQgYXMgdGVtcG9yYXJ5LCBpdCBtZWFucyBpdCB3YXMgbGF6aWx5IGNyZWF0ZWQgd2hlbiBhdHRlbXB0aW5nIHRvIGdldCBhbiBlbnRyeSxcbiAgICAvLyB3aGVyZSB3ZSBkaWRuJ3QgaGF2ZSB0aGUgcHJlZmV0Y2ggaW50ZW50LiBOb3cgdGhhdCB3ZSBoYXZlIHRoZSBpbnRlbnQgKGluIGBraW5kYCksIHdlIHdhbnQgdG8gdXBkYXRlIHRoZSBlbnRyeSB0byB0aGUgbW9yZSBhY2N1cmF0ZSBraW5kLlxuICAgIGlmIChraW5kICYmIGV4aXN0aW5nQ2FjaGVFbnRyeS5raW5kID09PSBQcmVmZXRjaEtpbmQuVEVNUE9SQVJZKSB7XG4gICAgICBleGlzdGluZ0NhY2hlRW50cnkua2luZCA9IGtpbmRcbiAgICB9XG5cbiAgICAvLyBXZSd2ZSBkZXRlcm1pbmVkIHRoYXQgdGhlIGV4aXN0aW5nIGVudHJ5IHdlIGZvdW5kIGlzIHN0aWxsIHZhbGlkLCBzbyB3ZSByZXR1cm4gaXQuXG4gICAgcmV0dXJuIGV4aXN0aW5nQ2FjaGVFbnRyeVxuICB9XG5cbiAgLy8gSWYgd2UgZGlkbid0IHJldHVybiBhbiBlbnRyeSwgY3JlYXRlIGEgbmV3IG9uZS5cbiAgcmV0dXJuIGNyZWF0ZUxhenlQcmVmZXRjaEVudHJ5KHtcbiAgICB0cmVlLFxuICAgIHVybCxcbiAgICBuZXh0VXJsLFxuICAgIHByZWZldGNoQ2FjaGUsXG4gICAga2luZDoga2luZCB8fCBQcmVmZXRjaEtpbmQuVEVNUE9SQVJZLFxuICB9KVxufVxuXG4vKlxuICogVXNlZCB0byB0YWtlIGFuIGV4aXN0aW5nIGNhY2hlIGVudHJ5IGFuZCBwcmVmaXggaXQgd2l0aCB0aGUgbmV4dFVybCwgaWYgaXQgZXhpc3RzLlxuICogVGhpcyBlbnN1cmVzIHRoYXQgd2UgZG9uJ3QgaGF2ZSBjb25mbGljdGluZyBjYWNoZSBlbnRyaWVzIGZvciB0aGUgc2FtZSBVUkwgKGFzIGlzIHRoZSBjYXNlIHdpdGggcm91dGUgaW50ZXJjZXB0aW9uKS5cbiAqL1xuZnVuY3Rpb24gcHJlZml4RXhpc3RpbmdQcmVmZXRjaENhY2hlRW50cnkoe1xuICB1cmwsXG4gIG5leHRVcmwsXG4gIHByZWZldGNoQ2FjaGUsXG4gIGV4aXN0aW5nQ2FjaGVLZXksXG59OiBQaWNrPFJlYWRvbmx5UmVkdWNlclN0YXRlLCAnbmV4dFVybCcgfCAncHJlZmV0Y2hDYWNoZSc+ICYge1xuICB1cmw6IFVSTFxuICBleGlzdGluZ0NhY2hlS2V5OiBzdHJpbmdcbn0pIHtcbiAgY29uc3QgZXhpc3RpbmdDYWNoZUVudHJ5ID0gcHJlZmV0Y2hDYWNoZS5nZXQoZXhpc3RpbmdDYWNoZUtleSlcbiAgaWYgKCFleGlzdGluZ0NhY2hlRW50cnkpIHtcbiAgICAvLyBuby1vcCAtLSB0aGVyZSB3YXNuJ3QgYW4gZW50cnkgdG8gbW92ZVxuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3QgbmV3Q2FjaGVLZXkgPSBjcmVhdGVQcmVmZXRjaENhY2hlS2V5KFxuICAgIHVybCxcbiAgICBleGlzdGluZ0NhY2hlRW50cnkua2luZCxcbiAgICBuZXh0VXJsXG4gIClcbiAgcHJlZmV0Y2hDYWNoZS5zZXQobmV3Q2FjaGVLZXksIHsgLi4uZXhpc3RpbmdDYWNoZUVudHJ5LCBrZXk6IG5ld0NhY2hlS2V5IH0pXG4gIHByZWZldGNoQ2FjaGUuZGVsZXRlKGV4aXN0aW5nQ2FjaGVLZXkpXG5cbiAgcmV0dXJuIG5ld0NhY2hlS2V5XG59XG5cbi8qKlxuICogVXNlIHRvIHNlZWQgdGhlIHByZWZldGNoIGNhY2hlIHdpdGggZGF0YSB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gZmV0Y2hlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNlZWRlZFByZWZldGNoQ2FjaGVFbnRyeSh7XG4gIG5leHRVcmwsXG4gIHRyZWUsXG4gIHByZWZldGNoQ2FjaGUsXG4gIHVybCxcbiAgZGF0YSxcbiAga2luZCxcbn06IFBpY2s8UmVhZG9ubHlSZWR1Y2VyU3RhdGUsICduZXh0VXJsJyB8ICd0cmVlJyB8ICdwcmVmZXRjaENhY2hlJz4gJiB7XG4gIHVybDogVVJMXG4gIGRhdGE6IEZldGNoU2VydmVyUmVzcG9uc2VSZXN1bHRcbiAga2luZDogUHJlZmV0Y2hLaW5kXG59KSB7XG4gIC8vIFRoZSBpbml0aWFsIGNhY2hlIGVudHJ5IHRlY2huaWNhbGx5IGluY2x1ZGVzIGZ1bGwgZGF0YSwgYnV0IGl0IGlzbid0IGV4cGxpY2l0bHkgcHJlZmV0Y2hlZCAtLSB3ZSBqdXN0IHNlZWQgdGhlXG4gIC8vIHByZWZldGNoIGNhY2hlIHNvIHRoYXQgd2UgY2FuIHNraXAgYW4gZXh0cmEgcHJlZmV0Y2ggcmVxdWVzdCBsYXRlciwgc2luY2Ugd2UgYWxyZWFkeSBoYXZlIHRoZSBkYXRhLlxuICAvLyBpZiB0aGUgcHJlZmV0Y2ggY29ycmVzcG9uZHMgd2l0aCBhbiBpbnRlcmNlcHRpb24gcm91dGUsIHdlIHVzZSB0aGUgbmV4dFVybCB0byBwcmVmaXggdGhlIGNhY2hlIGtleVxuICBjb25zdCBwcmVmZXRjaENhY2hlS2V5ID0gZGF0YS5jb3VsZEJlSW50ZXJjZXB0ZWRcbiAgICA/IGNyZWF0ZVByZWZldGNoQ2FjaGVLZXkodXJsLCBraW5kLCBuZXh0VXJsKVxuICAgIDogY3JlYXRlUHJlZmV0Y2hDYWNoZUtleSh1cmwsIGtpbmQpXG5cbiAgY29uc3QgcHJlZmV0Y2hFbnRyeSA9IHtcbiAgICB0cmVlQXRUaW1lT2ZQcmVmZXRjaDogdHJlZSxcbiAgICBkYXRhOiBQcm9taXNlLnJlc29sdmUoZGF0YSksXG4gICAga2luZCxcbiAgICBwcmVmZXRjaFRpbWU6IERhdGUubm93KCksXG4gICAgbGFzdFVzZWRUaW1lOiBEYXRlLm5vdygpLFxuICAgIHN0YWxlVGltZTogZGF0YS5zdGFsZVRpbWUsXG4gICAga2V5OiBwcmVmZXRjaENhY2hlS2V5LFxuICAgIHN0YXR1czogUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzLmZyZXNoLFxuICAgIHVybCxcbiAgfSBzYXRpc2ZpZXMgUHJlZmV0Y2hDYWNoZUVudHJ5XG5cbiAgcHJlZmV0Y2hDYWNoZS5zZXQocHJlZmV0Y2hDYWNoZUtleSwgcHJlZmV0Y2hFbnRyeSlcblxuICByZXR1cm4gcHJlZmV0Y2hFbnRyeVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBwcmVmZXRjaCBlbnRyeSBlbnRyeSBhbmQgZW5xdWV1ZXMgYSBmZXRjaCByZXF1ZXN0IHRvIHJldHJpZXZlIHRoZSBkYXRhLlxuICovXG5mdW5jdGlvbiBjcmVhdGVMYXp5UHJlZmV0Y2hFbnRyeSh7XG4gIHVybCxcbiAga2luZCxcbiAgdHJlZSxcbiAgbmV4dFVybCxcbiAgcHJlZmV0Y2hDYWNoZSxcbn06IFBpY2s8UmVhZG9ubHlSZWR1Y2VyU3RhdGUsICduZXh0VXJsJyB8ICd0cmVlJyB8ICdwcmVmZXRjaENhY2hlJz4gJiB7XG4gIHVybDogVVJMXG4gIGtpbmQ6IFByZWZldGNoS2luZFxufSk6IFByZWZldGNoQ2FjaGVFbnRyeSB7XG4gIGNvbnN0IHByZWZldGNoQ2FjaGVLZXkgPSBjcmVhdGVQcmVmZXRjaENhY2hlS2V5KHVybCwga2luZClcblxuICAvLyBpbml0aWF0ZXMgdGhlIGZldGNoIHJlcXVlc3QgZm9yIHRoZSBwcmVmZXRjaCBhbmQgYXR0YWNoZXMgYSBsaXN0ZW5lclxuICAvLyB0byB0aGUgcHJvbWlzZSB0byB1cGRhdGUgdGhlIHByZWZldGNoIGNhY2hlIGVudHJ5IHdoZW4gdGhlIHByb21pc2UgcmVzb2x2ZXMgKGlmIG5lY2Vzc2FyeSlcbiAgY29uc3QgZGF0YSA9IHByZWZldGNoUXVldWUuZW5xdWV1ZSgoKSA9PlxuICAgIGZldGNoU2VydmVyUmVzcG9uc2UodXJsLCB7XG4gICAgICBmbGlnaHRSb3V0ZXJTdGF0ZTogdHJlZSxcbiAgICAgIG5leHRVcmwsXG4gICAgICBwcmVmZXRjaEtpbmQ6IGtpbmQsXG4gICAgfSkudGhlbigocHJlZmV0Y2hSZXNwb25zZSkgPT4ge1xuICAgICAgLy8gVE9ETzogYGZldGNoU2VydmVyUmVzcG9uc2VgIHNob3VsZCBiZSBtb3JlIHRpZ2hseSBjb3VwbGVkIHRvIHRoZXNlIHByZWZldGNoIGNhY2hlIG9wZXJhdGlvbnNcbiAgICAgIC8vIHRvIGF2b2lkIGRyaWZ0IGJldHdlZW4gdGhpcyBjYWNoZSBrZXkgcHJlZml4aW5nIGxvZ2ljXG4gICAgICAvLyAod2hpY2ggaXMgY3VycmVudGx5IGRpcmVjdGx5IGluZmx1ZW5jZWQgYnkgdGhlIHNlcnZlciByZXNwb25zZSlcbiAgICAgIGxldCBuZXdDYWNoZUtleVxuXG4gICAgICBpZiAocHJlZmV0Y2hSZXNwb25zZS5jb3VsZEJlSW50ZXJjZXB0ZWQpIHtcbiAgICAgICAgLy8gRGV0ZXJtaW5lIGlmIHdlIG5lZWQgdG8gcHJlZml4IHRoZSBjYWNoZSBrZXkgd2l0aCB0aGUgbmV4dFVybFxuICAgICAgICBuZXdDYWNoZUtleSA9IHByZWZpeEV4aXN0aW5nUHJlZmV0Y2hDYWNoZUVudHJ5KHtcbiAgICAgICAgICB1cmwsXG4gICAgICAgICAgZXhpc3RpbmdDYWNoZUtleTogcHJlZmV0Y2hDYWNoZUtleSxcbiAgICAgICAgICBuZXh0VXJsLFxuICAgICAgICAgIHByZWZldGNoQ2FjaGUsXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSBwcmVmZXRjaCB3YXMgYSBjYWNoZSBoaXQsIHdlIHdhbnQgdG8gdXBkYXRlIHRoZSBleGlzdGluZyBjYWNoZSBlbnRyeSB0byByZWZsZWN0IHRoYXQgaXQgd2FzIGEgZnVsbCBwcmVmZXRjaC5cbiAgICAgIC8vIFRoaXMgaXMgYmVjYXVzZSB3ZSBrbm93IHRoYXQgYSBzdGF0aWMgcmVzcG9uc2Ugd2lsbCBjb250YWluIHRoZSBmdWxsIFJTQyBwYXlsb2FkLCBhbmQgY2FuIGJlIHVwZGF0ZWQgdG8gcmVzcGVjdCB0aGUgYHN0YXRpY2BcbiAgICAgIC8vIHN0YWxlVGltZS5cbiAgICAgIGlmIChwcmVmZXRjaFJlc3BvbnNlLnByZXJlbmRlcmVkKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nQ2FjaGVFbnRyeSA9IHByZWZldGNoQ2FjaGUuZ2V0KFxuICAgICAgICAgIC8vIGlmIHdlIHByZWZpeGVkIHRoZSBjYWNoZSBrZXkgZHVlIHRvIHJvdXRlIGludGVyY2VwdGlvbiwgd2Ugd2FudCB0byB1c2UgdGhlIG5ldyBrZXkuIE90aGVyd2lzZSB3ZSB1c2UgdGhlIG9yaWdpbmFsIGtleVxuICAgICAgICAgIG5ld0NhY2hlS2V5ID8/IHByZWZldGNoQ2FjaGVLZXlcbiAgICAgICAgKVxuICAgICAgICBpZiAoZXhpc3RpbmdDYWNoZUVudHJ5KSB7XG4gICAgICAgICAgZXhpc3RpbmdDYWNoZUVudHJ5LmtpbmQgPSBQcmVmZXRjaEtpbmQuRlVMTFxuICAgICAgICAgIGlmIChwcmVmZXRjaFJlc3BvbnNlLnN0YWxlVGltZSAhPT0gLTEpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIHN0YWxlIHRpbWUgdGhhdCB3YXMgY29sbGVjdGVkIGJ5IHRoZSBzZXJ2ZXIgZHVyaW5nXG4gICAgICAgICAgICAvLyBzdGF0aWMgZ2VuZXJhdGlvbi4gVXNlIHRoaXMgaW4gcGxhY2Ugb2YgdGhlIGRlZmF1bHQgc3RhbGUgdGltZS5cbiAgICAgICAgICAgIGV4aXN0aW5nQ2FjaGVFbnRyeS5zdGFsZVRpbWUgPSBwcmVmZXRjaFJlc3BvbnNlLnN0YWxlVGltZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJlZmV0Y2hSZXNwb25zZVxuICAgIH0pXG4gIClcblxuICBjb25zdCBwcmVmZXRjaEVudHJ5ID0ge1xuICAgIHRyZWVBdFRpbWVPZlByZWZldGNoOiB0cmVlLFxuICAgIGRhdGEsXG4gICAga2luZCxcbiAgICBwcmVmZXRjaFRpbWU6IERhdGUubm93KCksXG4gICAgbGFzdFVzZWRUaW1lOiBudWxsLFxuICAgIHN0YWxlVGltZTogLTEsXG4gICAga2V5OiBwcmVmZXRjaENhY2hlS2V5LFxuICAgIHN0YXR1czogUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzLmZyZXNoLFxuICAgIHVybCxcbiAgfVxuXG4gIHByZWZldGNoQ2FjaGUuc2V0KHByZWZldGNoQ2FjaGVLZXksIHByZWZldGNoRW50cnkpXG5cbiAgcmV0dXJuIHByZWZldGNoRW50cnlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBydW5lUHJlZmV0Y2hDYWNoZShcbiAgcHJlZmV0Y2hDYWNoZTogUmVhZG9ubHlSZWR1Y2VyU3RhdGVbJ3ByZWZldGNoQ2FjaGUnXVxuKSB7XG4gIGZvciAoY29uc3QgW2hyZWYsIHByZWZldGNoQ2FjaGVFbnRyeV0gb2YgcHJlZmV0Y2hDYWNoZSkge1xuICAgIGlmIChcbiAgICAgIGdldFByZWZldGNoRW50cnlDYWNoZVN0YXR1cyhwcmVmZXRjaENhY2hlRW50cnkpID09PVxuICAgICAgUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzLmV4cGlyZWRcbiAgICApIHtcbiAgICAgIHByZWZldGNoQ2FjaGUuZGVsZXRlKGhyZWYpXG4gICAgfVxuICB9XG59XG5cbi8vIFRoZXNlIHZhbHVlcyBhcmUgc2V0IGJ5IGBkZWZpbmUtZW52LXBsdWdpbmAgKGJhc2VkIG9uIGBuZXh0Q29uZmlnLmV4cGVyaW1lbnRhbC5zdGFsZVRpbWVzYClcbi8vIGFuZCBkZWZhdWx0IHRvIDUgbWludXRlcyAoc3RhdGljKSAvIDAgc2Vjb25kcyAoZHluYW1pYylcbmV4cG9ydCBjb25zdCBEWU5BTUlDX1NUQUxFVElNRV9NUyA9XG4gIE51bWJlcihwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1JPVVRFUl9EWU5BTUlDX1NUQUxFVElNRSkgKiAxMDAwXG5cbmV4cG9ydCBjb25zdCBTVEFUSUNfU1RBTEVUSU1FX01TID1cbiAgTnVtYmVyKHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfUk9VVEVSX1NUQVRJQ19TVEFMRVRJTUUpICogMTAwMFxuXG5mdW5jdGlvbiBnZXRQcmVmZXRjaEVudHJ5Q2FjaGVTdGF0dXMoe1xuICBraW5kLFxuICBwcmVmZXRjaFRpbWUsXG4gIGxhc3RVc2VkVGltZSxcbiAgc3RhbGVUaW1lLFxufTogUHJlZmV0Y2hDYWNoZUVudHJ5KTogUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzIHtcbiAgaWYgKHN0YWxlVGltZSAhPT0gLTEpIHtcbiAgICAvLyBgc3RhbGVUaW1lYCBpcyB0aGUgdmFsdWUgc2VudCBieSB0aGUgc2VydmVyIGR1cmluZyBzdGF0aWMgZ2VuZXJhdGlvbi5cbiAgICAvLyBXaGVuIHRoaXMgaXMgYXZhaWxhYmxlLCBpdCB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgYW55IG9mIHRoZSBoZXVyaXN0aWNzXG4gICAgLy8gdGhhdCBmb2xsb3cuXG4gICAgLy9cbiAgICAvLyBUT0RPOiBXaGVuIFBQUiBpcyBlbmFibGVkLCB0aGUgc2VydmVyIHdpbGwgKmFsd2F5cyogcmV0dXJuIGEgc3RhbGUgdGltZVxuICAgIC8vIHdoZW4gcHJlZmV0Y2hpbmcuIFdlIHNob3VsZCBuZXZlciB1c2UgYSBwcmVmZXRjaCBlbnRyeSB0aGF0IGhhc24ndCB5ZXRcbiAgICAvLyByZWNlaXZlZCBkYXRhIGZyb20gdGhlIHNlcnZlci4gU28gdGhlIG9ubHkgdHdvIGNhc2VzIHNob3VsZCBiZSAxKSB3ZSB1c2VcbiAgICAvLyB0aGUgc2VydmVyLWdlbmVyYXRlZCBzdGFsZSB0aW1lIDIpIHRoZSB1bnJlc29sdmVkIGVudHJ5IGlzIGRpc2NhcmRlZC5cbiAgICByZXR1cm4gRGF0ZS5ub3coKSA8IHByZWZldGNoVGltZSArIHN0YWxlVGltZVxuICAgICAgPyBQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMuZnJlc2hcbiAgICAgIDogUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzLnN0YWxlXG4gIH1cblxuICAvLyBXZSB3aWxsIHJlLXVzZSB0aGUgY2FjaGUgZW50cnkgZGF0YSBmb3IgdXAgdG8gdGhlIGBkeW5hbWljYCBzdGFsZXRpbWUgd2luZG93LlxuICBpZiAoRGF0ZS5ub3coKSA8IChsYXN0VXNlZFRpbWUgPz8gcHJlZmV0Y2hUaW1lKSArIERZTkFNSUNfU1RBTEVUSU1FX01TKSB7XG4gICAgcmV0dXJuIGxhc3RVc2VkVGltZVxuICAgICAgPyBQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMucmV1c2FibGVcbiAgICAgIDogUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzLmZyZXNoXG4gIH1cblxuICAvLyBGb3IgXCJhdXRvXCIgcHJlZmV0Y2hpbmcsIHdlJ2xsIHJlLXVzZSBvbmx5IHRoZSBsb2FkaW5nIGJvdW5kYXJ5IGZvciB1cCB0byBgc3RhdGljYCBzdGFsZXRpbWUgd2luZG93LlxuICAvLyBBIHN0YWxlIGVudHJ5IHdpbGwgb25seSByZS11c2UgdGhlIGBsb2FkaW5nYCBib3VuZGFyeSwgbm90IHRoZSBmdWxsIGRhdGEuXG4gIC8vIFRoaXMgd2lsbCB0cmlnZ2VyIGEgXCJsYXp5IGZldGNoXCIgZm9yIHRoZSBmdWxsIGRhdGEuXG4gIGlmIChraW5kID09PSBQcmVmZXRjaEtpbmQuQVVUTykge1xuICAgIGlmIChEYXRlLm5vdygpIDwgcHJlZmV0Y2hUaW1lICsgU1RBVElDX1NUQUxFVElNRV9NUykge1xuICAgICAgcmV0dXJuIFByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cy5zdGFsZVxuICAgIH1cbiAgfVxuXG4gIC8vIGZvciBcImZ1bGxcIiBwcmVmZXRjaGluZywgd2UnbGwgcmUtdXNlIHRoZSBjYWNoZSBlbnRyeSBkYXRhIGZvciB1cCB0byBgc3RhdGljYCBzdGFsZXRpbWUgd2luZG93LlxuICBpZiAoa2luZCA9PT0gUHJlZmV0Y2hLaW5kLkZVTEwpIHtcbiAgICBpZiAoRGF0ZS5ub3coKSA8IHByZWZldGNoVGltZSArIFNUQVRJQ19TVEFMRVRJTUVfTVMpIHtcbiAgICAgIHJldHVybiBQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMucmV1c2FibGVcbiAgICB9XG4gIH1cblxuICByZXR1cm4gUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzLmV4cGlyZWRcbn1cbiJdLCJuYW1lcyI6WyJEWU5BTUlDX1NUQUxFVElNRV9NUyIsIlNUQVRJQ19TVEFMRVRJTUVfTVMiLCJjcmVhdGVTZWVkZWRQcmVmZXRjaENhY2hlRW50cnkiLCJnZXRPckNyZWF0ZVByZWZldGNoQ2FjaGVFbnRyeSIsInBydW5lUHJlZmV0Y2hDYWNoZSIsIklOVEVSQ0VQVElPTl9DQUNIRV9LRVlfTUFSS0VSIiwiY3JlYXRlUHJlZmV0Y2hDYWNoZUtleUltcGwiLCJ1cmwiLCJpbmNsdWRlU2VhcmNoUGFyYW1zIiwicHJlZml4IiwicGF0aG5hbWVGcm9tVXJsIiwicGF0aG5hbWUiLCJzZWFyY2giLCJjcmVhdGVQcmVmZXRjaENhY2hlS2V5Iiwia2luZCIsIm5leHRVcmwiLCJQcmVmZXRjaEtpbmQiLCJGVUxMIiwiZ2V0RXhpc3RpbmdDYWNoZUVudHJ5IiwicHJlZmV0Y2hDYWNoZSIsImFsbG93QWxpYXNpbmciLCJURU1QT1JBUlkiLCJtYXliZU5leHRVcmwiLCJjYWNoZUtleVdpdGhQYXJhbXMiLCJjYWNoZUtleVdpdGhvdXRQYXJhbXMiLCJjYWNoZUtleVRvVXNlIiwiZXhpc3RpbmdFbnRyeSIsImdldCIsImlzQWxpYXNlZCIsImFsaWFzZWQiLCJlbnRyeVdpdGhvdXRQYXJhbXMiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJrZXkiLCJpbmNsdWRlcyIsImNhY2hlRW50cnkiLCJ2YWx1ZXMiLCJ1bmRlZmluZWQiLCJ0cmVlIiwiZXhpc3RpbmdDYWNoZUVudHJ5Iiwic3RhdHVzIiwiZ2V0UHJlZmV0Y2hFbnRyeUNhY2hlU3RhdHVzIiwic3dpdGNoZWRUb0Z1bGxQcmVmZXRjaCIsImRhdGEiLCJ0aGVuIiwicHJlZmV0Y2hSZXNwb25zZSIsImlzRnVsbFByZWZldGNoIiwiQXJyYXkiLCJpc0FycmF5IiwiZmxpZ2h0RGF0YSIsInNvbWUiLCJpc1Jvb3RSZW5kZXIiLCJzZWVkRGF0YSIsImNyZWF0ZUxhenlQcmVmZXRjaEVudHJ5IiwicHJlZml4RXhpc3RpbmdQcmVmZXRjaENhY2hlRW50cnkiLCJleGlzdGluZ0NhY2hlS2V5IiwibmV3Q2FjaGVLZXkiLCJzZXQiLCJkZWxldGUiLCJwcmVmZXRjaENhY2hlS2V5IiwiY291bGRCZUludGVyY2VwdGVkIiwicHJlZmV0Y2hFbnRyeSIsInRyZWVBdFRpbWVPZlByZWZldGNoIiwiUHJvbWlzZSIsInJlc29sdmUiLCJwcmVmZXRjaFRpbWUiLCJEYXRlIiwibm93IiwibGFzdFVzZWRUaW1lIiwic3RhbGVUaW1lIiwiUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzIiwiZnJlc2giLCJwcmVmZXRjaFF1ZXVlIiwiZW5xdWV1ZSIsImZldGNoU2VydmVyUmVzcG9uc2UiLCJmbGlnaHRSb3V0ZXJTdGF0ZSIsInByZWZldGNoS2luZCIsInByZXJlbmRlcmVkIiwiaHJlZiIsInByZWZldGNoQ2FjaGVFbnRyeSIsImV4cGlyZWQiLCJOdW1iZXIiLCJfX05FWFRfQ0xJRU5UX1JPVVRFUl9EWU5BTUlDX1NUQUxFVElNRSIsIl9fTkVYVF9DTElFTlRfUk9VVEVSX1NUQVRJQ19TVEFMRVRJTUUiLCJzdGFsZSIsInJldXNhYmxlIiwiQVVUTyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7SUE0WWFBLG9CQUFvQixFQUFBO2VBQXBCQTs7SUFHQUMsbUJBQW1CLEVBQUE7ZUFBbkJBOztJQW5JR0MsOEJBQThCLEVBQUE7ZUFBOUJBOztJQTlHQUMsNkJBQTZCLEVBQUE7ZUFBN0JBOztJQStOQUMsa0JBQWtCLEVBQUE7ZUFBbEJBOzs7cUNBMVhUO29DQU1BO2lDQUN1QjtBQUU5QixNQUFNQyxnQ0FBZ0M7QUFVdEM7Ozs7OztDQU1DLEdBQ0QsU0FBU0MsMkJBQ1BDLEdBQVEsRUFDUkMsbUJBQTRCLEVBQzVCQyxNQUFzQjtJQUV0QixnRkFBZ0Y7SUFDaEYsZ0ZBQWdGO0lBQ2hGLGtCQUFrQjtJQUNs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QUFBQSx3QkFBd0IsQ0FBQ2MsS0FBSztRQUN2QztJQUNGO0lBRUEsaUdBQWlHO0lBQ2pHLElBQUl2RSxTQUFTRSxvQkFBQUEsWUFBWSxDQUFDQyxJQUFJLEVBQUU7UUFDOUIsSUFBSWtELEtBQUtDLEdBQUcsS0FBS0YsZUFBZWpFLHFCQUFxQjtZQUNuRCxPQUFPc0Usb0JBQUFBLHdCQUF3QixDQUFDZSxRQUFRO1FBQzFDO0lBQ0Y7SUFFQSxPQUFPZixvQkFBQUEsd0JBQXdCLENBQUNVLE9BQU87QUFDekMiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMzQwNiwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yZWR1Y2Vycy9wcmVmZXRjaC1yZWR1Y2VyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHtcbiAgUHJlZmV0Y2hBY3Rpb24sXG4gIFJlZHVjZXJTdGF0ZSxcbiAgUmVhZG9ubHlSZWR1Y2VyU3RhdGUsXG59IGZyb20gJy4uL3JvdXRlci1yZWR1Y2VyLXR5cGVzJ1xuaW1wb3J0IHsgUHJvbWlzZVF1ZXVlIH0gZnJvbSAnLi4vLi4vcHJvbWlzZS1xdWV1ZSdcbmltcG9ydCB7XG4gIGdldE9yQ3JlYXRlUHJlZmV0Y2hDYWNoZUVudHJ5LFxuICBwcnVuZVByZWZldGNoQ2FjaGUsXG59IGZyb20gJy4uL3ByZWZldGNoLWNhY2hlLXV0aWxzJ1xuZXhwb3J0IGNvbnN0IHByZWZldGNoUXVldWUgPSBuZXcgUHJvbWlzZVF1ZXVlKDUpXG5cbmV4cG9ydCBjb25zdCBwcmVmZXRjaFJlZHVjZXIgPSBwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1NFR01FTlRfQ0FDSEVcbiAgPyBpZGVudGl0eVJlZHVjZXJXaGVuU2VnbWVudENhY2hlSXNFbmFibGVkXG4gIDogcHJlZmV0Y2hSZWR1Y2VySW1wbFxuXG5mdW5jdGlvbiBpZGVudGl0eVJlZHVjZXJXaGVuU2VnbWVudENhY2hlSXNFbmFibGVkPFQ+KHN0YXRlOiBUKTogVCB7XG4gIC8vIFVubGlrZSB0aGUgb2xkIGltcGxlbWVudGF0aW9uLCB0aGUgU2VnbWVudCBDYWNoZSBkb2Vzbid0IHN0b3JlIGl0cyBkYXRhIGluXG4gIC8vIHRoZSByb3V0ZXIgcmVkdWNlciBzdGF0ZS5cbiAgLy9cbiAgLy8gVGhpcyBzaG91bGRuJ3QgYmUgcmVhY2hhYmxlIGJlY2F1c2Ugd2Ugd3JhcCB0aGUgcHJlZmV0Y2ggQVBJIGluIGEgY2hlY2ssXG4gIC8vIHRvbywgd2hpY2ggcHJldmVudHMgdGhlIGFjdGlvbiBmcm9tIGJlaW5nIGRpc3BhdGNoZWQuIEJ1dCBpdCdzIGhlcmUgZm9yXG4gIC8vIGNsYXJpdHkgKyBjb2RlIGVsaW1pbmF0aW9uLlxuICByZXR1cm4gc3RhdGVcbn1cblxuZnVuY3Rpb24gcHJlZmV0Y2hSZWR1Y2VySW1wbChcbiAgc3RhdGU6IFJlYWRvbmx5UmVkdWNlclN0YXRlLFxuICBhY3Rpb246IFByZWZldGNoQWN0aW9uXG4pOiBSZWR1Y2VyU3RhdGUge1xuICAvLyBsZXQncyBwcnVuZSB0aGUgcHJlZmV0Y2ggY2FjaGUgYmVmb3JlIHdlIGRvIGFueXRoaW5nIGVsc2VcbiAgcHJ1bmVQcmVmZXRjaENhY2hlKHN0YXRlLnByZWZldGNoQ2FjaGUpXG5cbiAgY29uc3QgeyB1cmwgfSA9IGFjdGlvblxuXG4gIGdldE9yQ3JlYXRlUHJlZmV0Y2hDYWNoZUVudHJ5KHtcbiAgICB1cmwsXG4gICAgbmV4dFVybDogc3RhdGUubmV4dFVybCxcbiAgICBwcmVmZXRjaENhY2hlOiBzdGF0ZS5wcmVmZXRjaENhY2hlLFxuICAgIGtpbmQ6IGFjdGlvbi5raW5kLFxuICAgIHRyZWU6IHN0YXRlLnRyZWUsXG4gICAgYWxsb3dBbGlhc2luZzogdHJ1ZSxcbiAgfSlcblxuICByZXR1cm4gc3RhdGVcbn1cbiJdLCJuYW1lcyI6WyJwcmVmZXRjaFF1ZXVlIiwicHJlZmV0Y2hSZWR1Y2VyIiwiUHJvbWlzZVF1ZXVlIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9DTElFTlRfU0VHTUVOVF9DQUNIRSIsImlkZW50aXR5UmVkdWNlcldoZW5TZWdtZW50Q2FjaGVJc0VuYWJsZWQiLCJwcmVmZXRjaFJlZHVjZXJJbXBsIiwic3RhdGUiLCJhY3Rpb24iLCJwcnVuZVByZWZldGNoQ2FjaGUiLCJwcmVmZXRjaENhY2hlIiwidXJsIiwiZ2V0T3JDcmVhdGVQcmVmZXRjaENhY2hlRW50cnkiLCJuZXh0VXJsIiwia2luZCIsInRyZWUiLCJhbGxvd0FsaWFzaW5nIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztJQVVhQSxhQUFhLEVBQUE7ZUFBYkE7O0lBRUFDLGVBQWUsRUFBQTtlQUFmQTs7OzhCQVBnQjtvQ0FJdEI7QUFDQSxNQUFNRCxnQkFBZ0IsSUFBSUUsY0FBQUEsWUFBWSxDQUFDO0FBRXZDLE1BQU1ELGtCQUFrQkUsUUFBUUMsR0FBRyxDQUFDQywwQkFDdkNDLENBRGtFLHlCQUVsRUM7QUFFSixTQUFTRCx5Q0FBNENFLEtBQVE7SUFDM0QsNkVBQTZFO0lBQzdFLDRCQUE0QjtJQUM1QixFQUFFO0lBQ0YsMkVBQTJFO0lBQzNFLDBFQUEwRTtJQUMxRSw4QkFBOEI7SUFDOUIsT0FBT0E7QUFDVDtBQUVBLFNBQVNELG9CQUNQQyxLQUEyQixFQUMzQkMsTUFBc0I7SUFFdEIsNERBQTREO0lBQzVEQyxDQUFBQSxHQUFBQSxvQkFBQUEsa0JBQWtCLEVBQUNGLE1BQU1HLGFBQWE7SUFFdEMsTUFBTSxFQUFFQyxHQUFHLEVBQUUsR0FBR0g7SUFFaEJJLENBQUFBLEdBQUFBLG9CQUFBQSw2QkFBNkIsRUFBQztRQUM1QkQ7UUFDQUUsU0FBU04sTUFBTU0sT0FBTztRQUN0QkgsZUFBZUgsTUFBTUcsYUFBYTtRQUNsQ0ksTUFBTU4sT0FBT00sSUFBSTtRQUNqQkMsTUFBTVIsTUFBTVEsSUFBSTtRQUNoQkMsZUFBZTtJQUNqQjtJQUVBLE9BQU9UO0FBQ1QiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMzQ2NywgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy8lNDBzd2MvaGVscGVycy9janMvX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0LmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9O1xufVxuZXhwb3J0cy5fID0gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0O1xuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUVBLFNBQVMseUJBQXlCLEdBQUc7SUFDakMsT0FBTyxPQUFPLElBQUksVUFBVSxHQUFHLE1BQU07UUFBRSxTQUFTO0lBQUk7QUFDeEQ7QUFDQSxRQUFRLENBQUMsR0FBRyIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAzNDc5LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2NsaWVudC9jb21wb25lbnRzL25hdmlnYXRpb24tdW50cmFja2VkLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUNvbnRleHQgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IFBhdGhuYW1lQ29udGV4dCB9IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvaG9va3MtY2xpZW50LWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5cbi8qKlxuICogVGhpcyBjaGVja3MgdG8gc2VlIGlmIHRoZSBjdXJyZW50IHJlbmRlciBoYXMgYW55IHVua25vd24gcm91dGUgcGFyYW1ldGVycy5cbiAqIEl0J3MgdXNlZCB0byB0cmlnZ2VyIGEgZGlmZmVyZW50IHJlbmRlciBwYXRoIGluIHRoZSBlcnJvciBib3VuZGFyeS5cbiAqXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZXJlIGFyZSBhbnkgdW5rbm93biByb3V0ZSBwYXJhbWV0ZXJzLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuZnVuY3Rpb24gaGFzRmFsbGJhY2tSb3V0ZVBhcmFtcygpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gQXN5bmNMb2NhbFN0b3JhZ2Ugc2hvdWxkIG5vdCBiZSBpbmNsdWRlZCBpbiB0aGUgY2xpZW50IGJ1bmRsZS5cbiAgICBjb25zdCB7IHdvcmtBc3luY1N0b3JhZ2UgfSA9XG4gICAgICByZXF1aXJlKCcuLi8uLi9zZXJ2ZXIvYXBwLXJlbmRlci93b3JrLWFzeW5jLXN0b3JhZ2UuZXh0ZXJuYWwnKSBhcyB0eXBlb2YgaW1wb3J0KCcuLi8uLi9zZXJ2ZXIvYXBwLXJlbmRlci93b3JrLWFzeW5jLXN0b3JhZ2UuZXh0ZXJuYWwnKVxuXG4gICAgY29uc3Qgd29ya1N0b3JlID0gd29ya0FzeW5jU3RvcmFnZS5nZXRTdG9yZSgpXG4gICAgaWYgKCF3b3JrU3RvcmUpIHJldHVybiBmYWxzZVxuXG4gICAgY29uc3QgeyBmYWxsYmFja1JvdXRlUGFyYW1zIH0gPSB3b3JrU3RvcmVcbiAgICBpZiAoIWZhbGxiYWNrUm91dGVQYXJhbXMgfHwgZmFsbGJhY2tSb3V0ZVBhcmFtcy5zaXplID09PSAwKSByZXR1cm4gZmFsc2VcblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyoqXG4gKiBUaGlzIHJldHVybnMgYSBgbnVsbGAgdmFsdWUgaWYgdGhlcmUgYXJlIGFueSB1bmtub3duIHJvdXRlIHBhcmFtZXRlcnMsIGFuZFxuICogb3RoZXJ3aXNlIHJldHVybnMgdGhlIHBhdGhuYW1lIGZyb20gdGhlIGNvbnRleHQuIFRoaXMgaXMgYW4gYWx0ZXJuYXRpdmUgdG9cbiAqIGB1c2VQYXRobmFtZWAgdGhhdCBpcyB1c2VkIGluIHRoZSBlcnJvciBib3VuZGFyeSB0byBhdm9pZCByZW5kZXJpbmcgdGhlXG4gKiBlcnJvciBib3VuZGFyeSB3aGVuIHRoZXJlIGFyZSB1bmtub3duIHJvdXRlIHBhcmFtZXRlcnMuIFRoaXMgZG9lc24ndCB0aHJvd1xuICogd2hlbiBhY2Nlc3NlZCB3aXRoIHVua25vd24gcm91dGUgcGFyYW1ldGVycy5cbiAqXG4gKiBAcmV0dXJuc1xuICpcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlVW50cmFja2VkUGF0aG5hbWUoKTogc3RyaW5nIHwgbnVsbCB7XG4gIC8vIElmIHRoZXJlIGFyZSBhbnkgdW5rbm93biByb3V0ZSBwYXJhbWV0ZXJzIHdlIHdvdWxkIHR5cGljYWxseSB0aHJvd1xuICAvLyBhbiBlcnJvciwgYnV0IHRoaXMgaW50ZXJuYWwgbWV0aG9kIGFsbG93cyB1cyB0byByZXR1cm4gYSBudWxsIHZhbHVlIGluc3RlYWRcbiAgLy8gZm9yIGNvbXBvbmVudHMgdGhhdCBkbyBub3QgcHJvcGFnYXRlIHRoZSBwYXRobmFtZSB0byB0aGUgc3RhdGljIHNoZWxsIChsaWtlXG4gIC8vIHRoZSBlcnJvciBib3VuZGFyeSkuXG4gIGlmIChoYXNGYWxsYmFja1JvdXRlUGFyYW1zKCkpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLy8gVGhpcyBzaG91bGRuJ3QgY2F1c2UgYW55IGlzc3VlcyByZWxhdGVkIHRvIGNvbmRpdGlvbmFsIHJlbmRlcmluZyBiZWNhdXNlXG4gIC8vIHRoZSBlbnZpcm9ubWVudCB3aWxsIGJlIGNvbnNpc3RlbnQgZm9yIHRoZSByZW5kZXIuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICByZXR1cm4gdXNlQ29udGV4dChQYXRobmFtZUNvbnRleHQpXG59XG4iXSwibmFtZXMiOlsidXNlVW50cmFja2VkUGF0aG5hbWUiLCJoYXNGYWxsYmFja1JvdXRlUGFyYW1zIiwid2luZG93Iiwid29ya0FzeW5jU3RvcmFnZSIsInJlcXVpcmUiLCJ3b3JrU3RvcmUiLCJnZXRTdG9yZSIsImZhbGxiYWNrUm91dGVQYXJhbXMiLCJzaXplIiwidXNlQ29udGV4dCIsIlBhdGhuYW1lQ29udGV4dCJdLCJtYXBwaW5ncyI6Ijs7OytCQXNDZ0JBLHdCQUFBQTs7O2VBQUFBOzs7dUJBdENXO2lEQUNLO0FBRWhDOzs7OztDQUtDLEdBQ0QsU0FBU0M7SUFDUCxJQUFJLE9BQU9DLFdBQVcsa0JBQWE7UUFDakMsaUVBQWlFO1FBQ2pFLE1BQU0sRUFBRUMsZ0JBQWdCLEVBQUUsR0FDeEJDLFFBQVE7UUFFVixNQUFNQyxZQUFZRixpQkFBaUJHLFFBQVE7UUFDM0MsSUFBSSxDQUFDRCxXQUFXLE9BQU87UUFFdkIsTUFBTSxFQUFFRSxtQkFBbUIsRUFBRSxHQUFHRjtRQUNoQyxJQUFJLENBQUNFLHVCQUF1QkEsb0JBQW9CQyxJQUFJLEtBQUssR0FBRyxPQUFPO1FBRW5FLE9BQU87SUFDVDs7O0FBR0Y7QUFhTyxTQUFTUjtJQUNkLHFFQUFxRTtJQUNyRSw4RUFBOEU7SUFDOUUsOEVBQThFO0lBQzlFLHVCQUF1QjtJQUN2QixJQUFJQywwQkFBMEI7UUFDNUIsT0FBTztJQUNUO0lBRUEsMkVBQTJFO0lBQzNFLHFEQUFxRDtJQUNyRCxzREFBc0Q7SUFDdEQsT0FBT1EsQ0FBQUEsR0FBQUEsT0FBQUEsVUFBVSxFQUFDQyxpQ0FBQUEsZUFBZTtBQUNuQyIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAzNTM0LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2NsaWVudC9jb21wb25lbnRzL2h0dHAtYWNjZXNzLWZhbGxiYWNrL2h0dHAtYWNjZXNzLWZhbGxiYWNrLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBIVFRQQWNjZXNzRXJyb3JTdGF0dXMgPSB7XG4gIE5PVF9GT1VORDogNDA0LFxuICBGT1JCSURERU46IDQwMyxcbiAgVU5BVVRIT1JJWkVEOiA0MDEsXG59XG5cbmNvbnN0IEFMTE9XRURfQ09ERVMgPSBuZXcgU2V0KE9iamVjdC52YWx1ZXMoSFRUUEFjY2Vzc0Vycm9yU3RhdHVzKSlcblxuZXhwb3J0IGNvbnN0IEhUVFBfRVJST1JfRkFMTEJBQ0tfRVJST1JfQ09ERSA9ICdORVhUX0hUVFBfRVJST1JfRkFMTEJBQ0snXG5cbmV4cG9ydCB0eXBlIEhUVFBBY2Nlc3NGYWxsYmFja0Vycm9yID0gRXJyb3IgJiB7XG4gIGRpZ2VzdDogYCR7dHlwZW9mIEhUVFBfRVJST1JfRkFMTEJBQ0tfRVJST1JfQ09ERX07JHtzdHJpbmd9YFxufVxuXG4vKipcbiAqIENoZWNrcyBhbiBlcnJvciB0byBkZXRlcm1pbmUgaWYgaXQncyBhbiBlcnJvciBnZW5lcmF0ZWQgYnlcbiAqIHRoZSBIVFRQIG5hdmlnYXRpb24gQVBJcyBgbm90Rm91bmQoKWAsIGBmb3JiaWRkZW4oKWAgb3IgYHVuYXV0aG9yaXplZCgpYC5cbiAqXG4gKiBAcGFyYW0gZXJyb3IgdGhlIGVycm9yIHRoYXQgbWF5IHJlZmVyZW5jZSBhIEhUVFAgYWNjZXNzIGVycm9yXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBlcnJvciBpcyBhIEhUVFAgYWNjZXNzIGVycm9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0hUVFBBY2Nlc3NGYWxsYmFja0Vycm9yKFxuICBlcnJvcjogdW5rbm93blxuKTogZXJyb3IgaXMgSFRUUEFjY2Vzc0ZhbGxiYWNrRXJyb3Ige1xuICBpZiAoXG4gICAgdHlwZW9mIGVycm9yICE9PSAnb2JqZWN0JyB8fFxuICAgIGVycm9yID09PSBudWxsIHx8XG4gICAgISgnZGlnZXN0JyBpbiBlcnJvcikgfHxcbiAgICB0eXBlb2YgZXJyb3IuZGlnZXN0ICE9PSAnc3RyaW5nJ1xuICApIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBjb25zdCBbcHJlZml4LCBodHRwU3RhdHVzXSA9IGVycm9yLmRpZ2VzdC5zcGxpdCgnOycpXG5cbiAgcmV0dXJuIChcbiAgICBwcmVmaXggPT09IEhUVFBfRVJST1JfRkFMTEJBQ0tfRVJST1JfQ09ERSAmJlxuICAgIEFMTE9XRURfQ09ERVMuaGFzKE51bWJlcihodHRwU3RhdHVzKSlcbiAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWNjZXNzRmFsbGJhY2tIVFRQU3RhdHVzKFxuICBlcnJvcjogSFRUUEFjY2Vzc0ZhbGxiYWNrRXJyb3Jcbik6IG51bWJlciB7XG4gIGNvbnN0IGh0dHBTdGF0dXMgPSBlcnJvci5kaWdlc3Quc3BsaXQoJzsnKVsxXVxuICByZXR1cm4gTnVtYmVyKGh0dHBTdGF0dXMpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRBY2Nlc3NGYWxsYmFja0Vycm9yVHlwZUJ5U3RhdHVzKFxuICBzdGF0dXM6IG51bWJlclxuKTogJ25vdC1mb3VuZCcgfCAnZm9yYmlkZGVuJyB8ICd1bmF1dGhvcml6ZWQnIHwgdW5kZWZpbmVkIHtcbiAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICBjYXNlIDQwMTpcbiAgICAgIHJldHVybiAndW5hdXRob3JpemVkJ1xuICAgIGNhc2UgNDAzOlxuICAgICAgcmV0dXJuICdmb3JiaWRkZW4nXG4gICAgY2FzZSA0MDQ6XG4gICAgICByZXR1cm4gJ25vdC1mb3VuZCdcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJIVFRQQWNjZXNzRXJyb3JTdGF0dXMiLCJIVFRQX0VSUk9SX0ZBTExCQUNLX0VSUk9SX0NPREUiLCJnZXRBY2Nlc3NGYWxsYmFja0Vycm9yVHlwZUJ5U3RhdHVzIiwiZ2V0QWNjZXNzRmFsbGJhY2tIVFRQU3RhdHVzIiwiaXNIVFRQQWNjZXNzRmFsbGJhY2tFcnJvciIsIk5PVF9GT1VORCIsIkZPUkJJRERFTiIsIlVOQVVUSE9SSVpFRCIsIkFMTE9XRURfQ09ERVMiLCJTZXQiLCJPYmplY3QiLCJ2YWx1ZXMiLCJlcnJvciIsImRpZ2VzdCIsInByZWZpeCIsImh0dHBTdGF0dXMiLCJzcGxpdCIsImhhcyIsIk51bWJlciIsInN0YXR1cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFBYUEscUJBQXFCLEVBQUE7ZUFBckJBOztJQVFBQyw4QkFBOEIsRUFBQTtlQUE5QkE7O0lBdUNHQyxrQ0FBa0MsRUFBQTtlQUFsQ0E7O0lBUEFDLDJCQUEyQixFQUFBO2VBQTNCQTs7SUFuQkFDLHlCQUF5QixFQUFBO2VBQXpCQTs7O0FBckJULE1BQU1KLHdCQUF3QjtJQUNuQ0ssV0FBVztJQUNYQyxXQUFXO0lBQ1hDLGNBQWM7QUFDaEI7QUFFQSxNQUFNQyxnQkFBZ0IsSUFBSUMsSUFBSUMsT0FBT0MsTUFBTSxDQUFDWDtBQUVyQyxNQUFNQyxpQ0FBaUM7QUFhdkMsU0FBU0csMEJBQ2RRLEtBQWM7SUFFZCxJQUNFLE9BQU9BLFVBQVUsWUFDakJBLFVBQVUsUUFDVixDQUFFLENBQUEsWUFBWUEsS0FBSSxLQUNsQixPQUFPQSxNQUFNQyxNQUFNLEtBQUssVUFDeEI7UUFDQSxPQUFPO0lBQ1Q7SUFDQSxNQUFNLENBQUNDLFFBQVFDLFdBQVcsR0FBR0gsTUFBTUMsTUFBTSxDQUFDRyxLQUFLLENBQUM7SUFFaEQsT0FDRUYsV0FBV2Isa0NBQ1hPLGNBQWNTLEdBQUcsQ0FBQ0MsT0FBT0g7QUFFN0I7QUFFTyxTQUFTWiw0QkFDZFMsS0FBOEI7SUFFOUIsTUFBTUcsYUFBYUgsTUFBTUMsTUFBTSxDQUFDRyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7SUFDN0MsT0FBT0UsT0FBT0g7QUFDaEI7QUFFTyxTQUFTYixtQ0FDZGlCLE1BQWM7SUFFZCxPQUFRQTtRQUNOLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1lBQ0gsT0FBTztRQUNUO1lBQ0U7SUFDSjtBQUNGIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDM2MTAsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvY2xpZW50L2NvbXBvbmVudHMvcmVkaXJlY3Qtc3RhdHVzLWNvZGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGVudW0gUmVkaXJlY3RTdGF0dXNDb2RlIHtcbiAgU2VlT3RoZXIgPSAzMDMsXG4gIFRlbXBvcmFyeVJlZGlyZWN0ID0gMzA3LFxuICBQZXJtYW5lbnRSZWRpcmVjdCA9IDMwOCxcbn1cbiJdLCJuYW1lcyI6WyJSZWRpcmVjdFN0YXR1c0NvZGUiXSwibWFwcGluZ3MiOiI7OzsrQkFBWUEsc0JBQUFBOzs7ZUFBQUE7OztBQUFMLElBQUtBLHFCQUFBQSxXQUFBQSxHQUFBQSxTQUFBQSxrQkFBQUE7Ozs7V0FBQUEiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMzYzOCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvY29tcG9uZW50cy9yZWRpcmVjdC1lcnJvci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBSZWRpcmVjdFN0YXR1c0NvZGUgfSBmcm9tICcuL3JlZGlyZWN0LXN0YXR1cy1jb2RlJ1xuXG5leHBvcnQgY29uc3QgUkVESVJFQ1RfRVJST1JfQ09ERSA9ICdORVhUX1JFRElSRUNUJ1xuXG5leHBvcnQgZW51bSBSZWRpcmVjdFR5cGUge1xuICBwdXNoID0gJ3B1c2gnLFxuICByZXBsYWNlID0gJ3JlcGxhY2UnLFxufVxuXG5leHBvcnQgdHlwZSBSZWRpcmVjdEVycm9yID0gRXJyb3IgJiB7XG4gIGRpZ2VzdDogYCR7dHlwZW9mIFJFRElSRUNUX0VSUk9SX0NPREV9OyR7UmVkaXJlY3RUeXBlfTske3N0cmluZ307JHtSZWRpcmVjdFN0YXR1c0NvZGV9O2Bcbn1cblxuLyoqXG4gKiBDaGVja3MgYW4gZXJyb3IgdG8gZGV0ZXJtaW5lIGlmIGl0J3MgYW4gZXJyb3IgZ2VuZXJhdGVkIGJ5IHRoZVxuICogYHJlZGlyZWN0KHVybClgIGhlbHBlci5cbiAqXG4gKiBAcGFyYW0gZXJyb3IgdGhlIGVycm9yIHRoYXQgbWF5IHJlZmVyZW5jZSBhIHJlZGlyZWN0IGVycm9yXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBlcnJvciBpcyBhIHJlZGlyZWN0IGVycm9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1JlZGlyZWN0RXJyb3IoZXJyb3I6IHVua25vd24pOiBlcnJvciBpcyBSZWRpcmVjdEVycm9yIHtcbiAgaWYgKFxuICAgIHR5cGVvZiBlcnJvciAhPT0gJ29iamVjdCcgfHxcbiAgICBlcnJvciA9PT0gbnVsbCB8fFxuICAgICEoJ2RpZ2VzdCcgaW4gZXJyb3IpIHx8XG4gICAgdHlwZW9mIGVycm9yLmRpZ2VzdCAhPT0gJ3N0cmluZydcbiAgKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBjb25zdCBkaWdlc3QgPSBlcnJvci5kaWdlc3Quc3BsaXQoJzsnKVxuICBjb25zdCBbZXJyb3JDb2RlLCB0eXBlXSA9IGRpZ2VzdFxuICBjb25zdCBkZXN0aW5hdGlvbiA9IGRpZ2VzdC5zbGljZSgyLCAtMikuam9pbignOycpXG4gIGNvbnN0IHN0YXR1cyA9IGRpZ2VzdC5hdCgtMilcblxuICBjb25zdCBzdGF0dXNDb2RlID0gTnVtYmVyKHN0YXR1cylcblxuICByZXR1cm4gKFxuICAgIGVycm9yQ29kZSA9PT0gUkVESVJFQ1RfRVJST1JfQ09ERSAmJlxuICAgICh0eXBlID09PSAncmVwbGFjZScgfHwgdHlwZSA9PT0gJ3B1c2gnKSAmJlxuICAgIHR5cGVvZiBkZXN0aW5hdGlvbiA9PT0gJ3N0cmluZycgJiZcbiAgICAhaXNOYU4oc3RhdHVzQ29kZSkgJiZcbiAgICBzdGF0dXNDb2RlIGluIFJlZGlyZWN0U3RhdHVzQ29kZVxuICApXG59XG4iXSwibmFtZXMiOlsiUkVESVJFQ1RfRVJST1JfQ09ERSIsIlJlZGlyZWN0VHlwZSIsImlzUmVkaXJlY3RFcnJvciIsImVycm9yIiwiZGlnZXN0Iiwic3BsaXQiLCJlcnJvckNvZGUiLCJ0eXBlIiwiZGVzdGluYXRpb24iLCJzbGljZSIsImpvaW4iLCJzdGF0dXMiLCJhdCIsInN0YXR1c0NvZGUiLCJOdW1iZXIiLCJpc05hTiIsIlJlZGlyZWN0U3RhdHVzQ29kZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0lBRWFBLG1CQUFtQixFQUFBO2VBQW5CQTs7SUFFREMsWUFBWSxFQUFBO2VBQVpBOztJQWdCSUMsZUFBZSxFQUFBO2VBQWZBOzs7b0NBcEJtQjtBQUU1QixNQUFNRixzQkFBc0I7QUFFNUIsSUFBS0MsZUFBQUEsV0FBQUEsR0FBQUEsU0FBQUEsWUFBQUE7OztXQUFBQTs7QUFnQkwsU0FBU0MsZ0JBQWdCQyxLQUFjO0lBQzVDLElBQ0UsT0FBT0EsVUFBVSxZQUNqQkEsVUFBVSxRQUNWLENBQUUsQ0FBQSxZQUFZQSxLQUFJLEtBQ2xCLE9BQU9BLE1BQU1DLE1BQU0sS0FBSyxVQUN4QjtRQUNBLE9BQU87SUFDVDtJQUVBLE1BQU1BLFNBQVNELE1BQU1DLE1BQU0sQ0FBQ0MsS0FBSyxDQUFDO0lBQ2xDLE1BQU0sQ0FBQ0MsV0FBV0MsS0FBSyxHQUFHSDtJQUMxQixNQUFNSSxjQUFjSixPQUFPSyxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUdDLElBQUksQ0FBQztJQUM3QyxNQUFNQyxTQUFTUCxPQUFPUSxFQUFFLENBQUMsQ0FBQztJQUUxQixNQUFNQyxhQUFhQyxPQUFPSDtJQUUxQixPQUNFTCxjQUFjTix1QkFDYk8sQ0FBQUEsU0FBUyxhQUFhQSxTQUFTLE1BQUssS0FDckMsT0FBT0MsZ0JBQWdCLFlBQ3ZCLENBQUNPLE1BQU1GLGVBQ1BBLGNBQWNHLG9CQUFBQSxrQkFBa0I7QUFFcEMiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMzY5NCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvY29tcG9uZW50cy9pcy1uZXh0LXJvdXRlci1lcnJvci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBpc0hUVFBBY2Nlc3NGYWxsYmFja0Vycm9yLFxuICB0eXBlIEhUVFBBY2Nlc3NGYWxsYmFja0Vycm9yLFxufSBmcm9tICcuL2h0dHAtYWNjZXNzLWZhbGxiYWNrL2h0dHAtYWNjZXNzLWZhbGxiYWNrJ1xuaW1wb3J0IHsgaXNSZWRpcmVjdEVycm9yLCB0eXBlIFJlZGlyZWN0RXJyb3IgfSBmcm9tICcuL3JlZGlyZWN0LWVycm9yJ1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZXJyb3IgaXMgYSBuYXZpZ2F0aW9uIHNpZ25hbCBlcnJvci4gVGhlc2UgZXJyb3JzIGFyZVxuICogdGhyb3duIGJ5IHVzZXIgY29kZSB0byBwZXJmb3JtIG5hdmlnYXRpb24gb3BlcmF0aW9ucyBhbmQgaW50ZXJydXB0IHRoZSBSZWFjdFxuICogcmVuZGVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNOZXh0Um91dGVyRXJyb3IoXG4gIGVycm9yOiB1bmtub3duXG4pOiBlcnJvciBpcyBSZWRpcmVjdEVycm9yIHwgSFRUUEFjY2Vzc0ZhbGxiYWNrRXJyb3Ige1xuICByZXR1cm4gaXNSZWRpcmVjdEVycm9yKGVycm9yKSB8fCBpc0hUVFBBY2Nlc3NGYWxsYmFja0Vycm9yKGVycm9yKVxufVxuIl0sIm5hbWVzIjpbImlzTmV4dFJvdXRlckVycm9yIiwiZXJyb3IiLCJpc1JlZGlyZWN0RXJyb3IiLCJpc0hUVFBBY2Nlc3NGYWxsYmFja0Vycm9yIl0sIm1hcHBpbmdzIjoiOzs7K0JBV2dCQSxxQkFBQUE7OztlQUFBQTs7O29DQVJUOytCQUM2QztBQU83QyxTQUFTQSxrQkFDZEMsS0FBYztJQUVkLE9BQU9DLENBQUFBLEdBQUFBLGVBQUFBLGVBQWUsRUFBQ0QsVUFBVUUsQ0FBQUEsR0FBQUEsb0JBQUFBLHlCQUF5QixFQUFDRjtBQUM3RCIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAzNzIxLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2NsaWVudC9jb21wb25lbnRzL25hdi1mYWlsdXJlLWhhbmRsZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBjcmVhdGVIcmVmRnJvbVVybCB9IGZyb20gJy4vcm91dGVyLXJlZHVjZXIvY3JlYXRlLWhyZWYtZnJvbS11cmwnXG5cbmV4cG9ydCBmdW5jdGlvbiBoYW5kbGVIYXJkTmF2RXJyb3IoZXJyb3I6IHVua25vd24pOiBib29sZWFuIHtcbiAgaWYgKFxuICAgIGVycm9yICYmXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB3aW5kb3cubmV4dC5fX3BlbmRpbmdVcmwgJiZcbiAgICBjcmVhdGVIcmVmRnJvbVVybChuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKSkgIT09XG4gICAgICBjcmVhdGVIcmVmRnJvbVVybCh3aW5kb3cubmV4dC5fX3BlbmRpbmdVcmwpXG4gICkge1xuICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICBgRXJyb3Igb2NjdXJyZWQgZHVyaW5nIG5hdmlnYXRpb24sIGZhbGxpbmcgYmFjayB0byBoYXJkIG5hdmlnYXRpb25gLFxuICAgICAgZXJyb3JcbiAgICApXG4gICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSB3aW5kb3cubmV4dC5fX3BlbmRpbmdVcmwudG9TdHJpbmcoKVxuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VOYXZGYWlsdXJlSGFuZGxlcigpIHtcbiAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9BUFBfTkFWX0ZBSUxfSEFORExJTkcpIHtcbiAgICAvLyB0aGlzIGlmIGlzIG9ubHkgZm9yIERDRSBvZiB0aGUgZmVhdHVyZSBmbGFnIG5vdCBjb25kaXRpb25hbFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBjb25zdCB1bmNhdWdodEV4Y2VwdGlvbkhhbmRsZXIgPSAoXG4gICAgICAgIGV2dDogRXJyb3JFdmVudCB8IFByb21pc2VSZWplY3Rpb25FdmVudFxuICAgICAgKSA9PiB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gJ3JlYXNvbicgaW4gZXZ0ID8gZXZ0LnJlYXNvbiA6IGV2dC5lcnJvclxuICAgICAgICAvLyBpZiB3ZSBoYXZlIGFuIHVuaGFuZGxlZCBleGNlcHRpb24vcmVqZWN0aW9uIGR1cmluZ1xuICAgICAgICAvLyBhIG5hdmlnYXRpb24gd2UgZmFsbCBiYWNrIHRvIGEgaGFyZCBuYXZpZ2F0aW9uIHRvXG4gICAgICAgIC8vIGF0dGVtcHQgcmVjb3ZlcmluZyB0byBhIGdvb2Qgc3RhdGVcbiAgICAgICAgaGFuZGxlSGFyZE5hdkVycm9yKGVycm9yKVxuICAgICAgfVxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3VuaGFuZGxlZHJlamVjdGlvbicsIHVuY2F1Z2h0RXhjZXB0aW9uSGFuZGxlcilcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIHVuY2F1Z2h0RXhjZXB0aW9uSGFuZGxlcilcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIHVuY2F1Z2h0RXhjZXB0aW9uSGFuZGxlcilcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgJ3VuaGFuZGxlZHJlamVjdGlvbicsXG4gICAgICAgICAgdW5jYXVnaHRFeGNlcHRpb25IYW5kbGVyXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9LCBbXSlcbiAgfVxufVxuIl0sIm5hbWVzIjpbImhhbmRsZUhhcmROYXZFcnJvciIsInVzZU5hdkZhaWx1cmVIYW5kbGVyIiwiZXJyb3IiLCJ3aW5kb3ciLCJuZXh0IiwiX19wZW5kaW5nVXJsIiwiY3JlYXRlSHJlZkZyb21VcmwiLCJVUkwiLCJsb2NhdGlvbiIsImhyZWYiLCJjb25zb2xlIiwidG9TdHJpbmciLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX0FQUF9OQVZfRkFJTF9IQU5ETElORyIsInVzZUVmZmVjdCIsInVuY2F1Z2h0RXhjZXB0aW9uSGFuZGxlciIsImV2dCIsInJlYXNvbiIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztJQUdnQkEsa0JBQWtCLEVBQUE7ZUFBbEJBOztJQWtCQUMsb0JBQW9CLEVBQUE7ZUFBcEJBOzs7dUJBckJVO21DQUNRO0FBRTNCLFNBQVNELG1CQUFtQkUsS0FBYztJQUMvQyxJQUNFQSxTQUNBLE9BQU9DLFNBQVcsZUFDbEJBLE9BQU9DLElBQUksQ0FBQ0MsWUFBWSxJQUN4QkMsQ0FBQUEsR0FBQUEsbUJBQUFBLGlCQUFpQixFQUFDLElBQUlDLElBQUlKLE9BQU9LLFFBQVEsQ0FBQ0MsSUFBSSxPQUM1Q0gsQ0FBQUEsR0FBQUEsbUJBQUFBLGlCQUFpQixFQUFDSCxPQUFPQyxJQUFJLENBQUNDLFlBQVksR0FDNUM7O0lBUUYsT0FBTztBQUNUO0FBRU8sU0FBU0o7SUFDZCxJQUFJVyxRQUFRQyxHQUFHLENBQUNDLDRCQUE0QixFQUFFOztBQXdCaEQiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMzc2NiwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvY29tcG9uZW50cy9oYW5kbGUtaXNyLWVycm9yLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB3b3JrQXN5bmNTdG9yYWdlID1cbiAgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCdcbiAgICA/IChcbiAgICAgICAgcmVxdWlyZSgnLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvd29yay1hc3luYy1zdG9yYWdlLmV4dGVybmFsJykgYXMgdHlwZW9mIGltcG9ydCgnLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvd29yay1hc3luYy1zdG9yYWdlLmV4dGVybmFsJylcbiAgICAgICkud29ya0FzeW5jU3RvcmFnZVxuICAgIDogdW5kZWZpbmVkXG5cbi8vIGlmIHdlIGFyZSByZXZhbGlkYXRpbmcgd2Ugd2FudCB0byByZS10aHJvdyB0aGUgZXJyb3Igc28gdGhlXG4vLyBmdW5jdGlvbiBjcmFzaGVzIHNvIHdlIGNhbiBtYWludGFpbiBvdXIgcHJldmlvdXMgY2FjaGVcbi8vIGluc3RlYWQgb2YgY2FjaGluZyB0aGUgZXJyb3IgcGFnZVxuZXhwb3J0IGZ1bmN0aW9uIEhhbmRsZUlTUkVycm9yKHsgZXJyb3IgfTogeyBlcnJvcjogYW55IH0pIHtcbiAgaWYgKHdvcmtBc3luY1N0b3JhZ2UpIHtcbiAgICBjb25zdCBzdG9yZSA9IHdvcmtBc3luY1N0b3JhZ2UuZ2V0U3RvcmUoKVxuICAgIGlmIChzdG9yZT8uaXNSZXZhbGlkYXRlIHx8IHN0b3JlPy5pc1N0YXRpY0dlbmVyYXRpb24pIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG4iXSwibmFtZXMiOlsiSGFuZGxlSVNSRXJyb3IiLCJ3b3JrQXN5bmNTdG9yYWdlIiwid2luZG93IiwicmVxdWlyZSIsInVuZGVmaW5lZCIsImVycm9yIiwic3RvcmUiLCJnZXRTdG9yZSIsImlzUmV2YWxpZGF0ZSIsImlzU3RhdGljR2VuZXJhdGlvbiIsImNvbnNvbGUiXSwibWFwcGluZ3MiOiI7OzsrQkFVZ0JBLGtCQUFBQTs7O2VBQUFBOzs7QUFWaEIsTUFBTUMsbUJBQ0osT0FBT0MsV0FBVyxxQkFFWkMsUUFBUSx1S0FDUkYsZ0JBQWdCLEdBQ2xCRztBQUtDLFNBQVNKLGVBQWUsS0FBeUI7SUFBekIsSUFBQSxFQUFFSyxLQUFLLEVBQWtCLEdBQXpCO0lBQzdCLElBQUlKLGtCQUFrQjtRQUNwQixNQUFNSyxRQUFRTCxpQkFBaUJNLFFBQVE7UUFDdkMsSUFBSUQsQ0FBQUEsU0FBQUEsT0FBQUEsS0FBQUEsSUFBQUEsTUFBT0UsWUFBWSxLQUFBLENBQUlGLFNBQUFBLE9BQUFBLEtBQUFBLElBQUFBLE1BQU9HLGtCQUFrQixHQUFFO1lBQ3BEQyxRQUFRTCxLQUFLLENBQUNBO1lBQ2QsTUFBTUE7UUFDUjtJQUNGO0lBRUEsT0FBTztBQUNUIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDM4MDAsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvY2xpZW50L2NvbXBvbmVudHMvZXJyb3ItYm91bmRhcnkudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuXG5pbXBvcnQgUmVhY3QsIHsgdHlwZSBKU1ggfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IHVzZVVudHJhY2tlZFBhdGhuYW1lIH0gZnJvbSAnLi9uYXZpZ2F0aW9uLXVudHJhY2tlZCdcbmltcG9ydCB7IGlzTmV4dFJvdXRlckVycm9yIH0gZnJvbSAnLi9pcy1uZXh0LXJvdXRlci1lcnJvcidcbmltcG9ydCB7IGhhbmRsZUhhcmROYXZFcnJvciB9IGZyb20gJy4vbmF2LWZhaWx1cmUtaGFuZGxlcidcbmltcG9ydCB7IEhhbmRsZUlTUkVycm9yIH0gZnJvbSAnLi9oYW5kbGUtaXNyLWVycm9yJ1xuXG5leHBvcnQgdHlwZSBFcnJvckNvbXBvbmVudCA9IFJlYWN0LkNvbXBvbmVudFR5cGU8e1xuICBlcnJvcjogRXJyb3JcbiAgLy8gZ2xvYmFsLWVycm9yLCB0aGVyZSdzIG5vIGByZXNldGAgZnVuY3Rpb247XG4gIC8vIHJlZ3VsYXIgZXJyb3IgYm91bmRhcnksIHRoZXJlJ3MgYSBgcmVzZXRgIGZ1bmN0aW9uLlxuICByZXNldD86ICgpID0+IHZvaWRcbn0+XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXJyb3JCb3VuZGFyeVByb3BzIHtcbiAgY2hpbGRyZW4/OiBSZWFjdC5SZWFjdE5vZGVcbiAgZXJyb3JDb21wb25lbnQ6IEVycm9yQ29tcG9uZW50IHwgdW5kZWZpbmVkXG4gIGVycm9yU3R5bGVzPzogUmVhY3QuUmVhY3ROb2RlIHwgdW5kZWZpbmVkXG4gIGVycm9yU2NyaXB0cz86IFJlYWN0LlJlYWN0Tm9kZSB8IHVuZGVmaW5lZFxufVxuXG5pbnRlcmZhY2UgRXJyb3JCb3VuZGFyeUhhbmRsZXJQcm9wcyBleHRlbmRzIEVycm9yQm91bmRhcnlQcm9wcyB7XG4gIHBhdGhuYW1lOiBzdHJpbmcgfCBudWxsXG4gIGVycm9yQ29tcG9uZW50OiBFcnJvckNvbXBvbmVudFxufVxuXG5pbnRlcmZhY2UgRXJyb3JCb3VuZGFyeUhhbmRsZXJTdGF0ZSB7XG4gIGVycm9yOiBFcnJvciB8IG51bGxcbiAgcHJldmlvdXNQYXRobmFtZTogc3RyaW5nIHwgbnVsbFxufVxuXG5leHBvcnQgY2xhc3MgRXJyb3JCb3VuZGFyeUhhbmRsZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8XG4gIEVycm9yQm91bmRhcnlIYW5kbGVyUHJvcHMsXG4gIEVycm9yQm91bmRhcnlIYW5kbGVyU3RhdGVcbj4ge1xuICBjb25zdHJ1Y3Rvcihwcm9wczogRXJyb3JCb3VuZGFyeUhhbmRsZXJQcm9wcykge1xuICAgIHN1cGVyKHByb3BzKVxuICAgIHRoaXMuc3RhdGUgPSB7IGVycm9yOiBudWxsLCBwcmV2aW91c1BhdGhuYW1lOiB0aGlzLnByb3BzLnBhdGhuYW1lIH1cbiAgfVxuXG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoZXJyb3I6IEVycm9yKSB7XG4gICAgaWYgKGlzTmV4dFJvdXRlckVycm9yKGVycm9yKSkge1xuICAgICAgLy8gUmUtdGhyb3cgaWYgYW4gZXhwZWN0ZWQgaW50ZXJuYWwgTmV4dC5qcyByb3V0ZXIgZXJyb3Igb2NjdXJzXG4gICAgICAvLyB0aGlzIG1lYW5zIGl0IHNob3VsZCBiZSBoYW5kbGVkIGJ5IGEgZGlmZmVyZW50IGJvdW5kYXJ5IChzdWNoIGFzIGEgTm90Rm91bmQgYm91bmRhcnkgaW4gYSBwYXJlbnQgc2VnbWVudClcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuXG4gICAgcmV0dXJuIHsgZXJyb3IgfVxuICB9XG5cbiAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhcbiAgICBwcm9wczogRXJyb3JCb3VuZGFyeUhhbmRsZXJQcm9wcyxcbiAgICBzdGF0ZTogRXJyb3JCb3VuZGFyeUhhbmRsZXJTdGF0ZVxuICApOiBFcnJvckJvdW5kYXJ5SGFuZGxlclN0YXRlIHwgbnVsbCB7XG4gICAgY29uc3QgeyBlcnJvciB9ID0gc3RhdGVcblxuICAgIC8vIGlmIHdlIGVuY291bnRlciBhbiBlcnJvciB3aGlsZVxuICAgIC8vIGEgbmF2aWdhdGlvbiBpcyBwZW5kaW5nIHdlIHNob3VsZG4ndCByZW5kZXJcbiAgICAvLyB0aGUgZXJyb3IgYm91bmRhcnkgYW5kIGluc3RlYWQgc2hvdWxkIGZhbGxiYWNrXG4gICAgLy8gdG8gYSBoYXJkIG5hdmlnYXRpb24gdG8gYXR0ZW1wdCByZWNvdmVyaW5nXG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9BUFBfTkFWX0ZBSUxfSEFORExJTkcpIHtcbiAgICAgIGlmIChlcnJvciAmJiBoYW5kbGVIYXJkTmF2RXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIC8vIGNsZWFyIGVycm9yIHNvIHdlIGRvbid0IHJlbmRlciBhbnl0aGluZ1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgIHByZXZpb3VzUGF0aG5hbWU6IHByb3BzLnBhdGhuYW1lLFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlcyByZXNldCBvZiB0aGUgZXJyb3IgYm91bmRhcnkgd2hlbiBhIG5hdmlnYXRpb24gaGFwcGVucy5cbiAgICAgKiBFbnN1cmVzIHRoZSBlcnJvciBib3VuZGFyeSBkb2VzIG5vdCBzdGF5IGVuYWJsZWQgd2hlbiBuYXZpZ2F0aW5nIHRvIGEgbmV3IHBhZ2UuXG4gICAgICogQXBwcm9hY2ggb2Ygc2V0U3RhdGUgaW4gcmVuZGVyIGlzIHNhZmUgYXMgaXQgY2hlY2tzIHRoZSBwcmV2aW91cyBwYXRobmFtZSBhbmQgdGhlbiBvdmVycmlkZXNcbiAgICAgKiBpdCBhcyBvdXRsaW5lZCBpbiBodHRwczovL3JlYWN0LmRldi9yZWZlcmVuY2UvcmVhY3QvdXNlU3RhdGUjc3RvcmluZy1pbmZvcm1hdGlvbi1mcm9tLXByZXZpb3VzLXJlbmRlcnNcbiAgICAgKi9cbiAgICBpZiAocHJvcHMucGF0aG5hbWUgIT09IHN0YXRlLnByZXZpb3VzUGF0aG5hbWUgJiYgc3RhdGUuZXJyb3IpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICBwcmV2aW91c1BhdGhuYW1lOiBwcm9wcy5wYXRobmFtZSxcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGVycm9yOiBzdGF0ZS5lcnJvcixcbiAgICAgIHByZXZpb3VzUGF0aG5hbWU6IHByb3BzLnBhdGhuYW1lLFxuICAgIH1cbiAgfVxuXG4gIHJlc2V0ID0gKCkgPT4ge1xuICAgIHRoaXMuc2V0U3RhdGUoeyBlcnJvcjogbnVsbCB9KVxuICB9XG5cbiAgLy8gRXhwbGljaXQgdHlwZSBpcyBuZWVkZWQgdG8gYXZvaWQgdGhlIGdlbmVyYXRlZCBgLmQudHNgIGhhdmluZyBhIHdpZGUgcmV0dXJuIHR5cGUgdGhhdCBjb3VsZCBiZSBzcGVjaWZpYyB0byB0aGUgYEB0eXBlcy9yZWFjdGAgdmVyc2lvbi5cbiAgcmVuZGVyKCk6IFJlYWN0LlJlYWN0Tm9kZSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuZXJyb3IpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDw+XG4gICAgICAgICAgPEhhbmRsZUlTUkVycm9yIGVycm9yPXt0aGlzLnN0YXRlLmVycm9yfSAvPlxuICAgICAgICAgIHt0aGlzLnByb3BzLmVycm9yU3R5bGVzfVxuICAgICAgICAgIHt0aGlzLnByb3BzLmVycm9yU2NyaXB0c31cbiAgICAgICAgICA8dGhpcy5wcm9wcy5lcnJvckNvbXBvbmVudFxuICAgICAgICAgICAgZXJyb3I9e3RoaXMuc3RhdGUuZXJyb3J9XG4gICAgICAgICAgICByZXNldD17dGhpcy5yZXNldH1cbiAgICAgICAgICAvPlxuICAgICAgICA8Lz5cbiAgICAgIClcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlblxuICB9XG59XG5cbi8qKlxuICogSGFuZGxlcyBlcnJvcnMgdGhyb3VnaCBgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yYC5cbiAqIFJlbmRlcnMgdGhlIHByb3ZpZGVkIGVycm9yIGNvbXBvbmVudCBhbmQgcHJvdmlkZXMgYSB3YXkgdG8gYHJlc2V0YCB0aGUgZXJyb3IgYm91bmRhcnkgc3RhdGUuXG4gKi9cblxuLyoqXG4gKiBSZW5kZXJzIGVycm9yIGJvdW5kYXJ5IHdpdGggdGhlIHByb3ZpZGVkIFwiZXJyb3JDb21wb25lbnRcIiBwcm9wZXJ0eSBhcyB0aGUgZmFsbGJhY2suXG4gKiBJZiBubyBcImVycm9yQ29tcG9uZW50XCIgcHJvcGVydHkgaXMgcHJvdmlkZWQgaXQgcmVuZGVycyB0aGUgY2hpbGRyZW4gd2l0aG91dCBhbiBlcnJvciBib3VuZGFyeS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEVycm9yQm91bmRhcnkoe1xuICBlcnJvckNvbXBvbmVudCxcbiAgZXJyb3JTdHlsZXMsXG4gIGVycm9yU2NyaXB0cyxcbiAgY2hpbGRyZW4sXG59OiBFcnJvckJvdW5kYXJ5UHJvcHMgJiB7XG4gIGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGVcbn0pOiBKU1guRWxlbWVudCB7XG4gIC8vIFdoZW4gd2UncmUgcmVuZGVyaW5nIHRoZSBtaXNzaW5nIHBhcmFtcyBzaGVsbCwgdGhpcyB3aWxsIHJldHVybiBudWxsLiBUaGlzXG4gIC8vIGlzIGJlY2F1c2Ugd2Ugd29uJ3QgYmUgcmVuZGVyaW5nIGFueSBub3QgZm91bmQgYm91bmRhcmllcyBvciBlcnJvclxuICAvLyBib3VuZGFyaWVzIGZvciB0aGUgbWlzc2luZyBwYXJhbXMgc2hlbGwuIFdoZW4gdGhpcyBydW5zIG9uIHRoZSBjbGllbnRcbiAgLy8gKHdoZXJlIHRoZXNlIGVycm9ycyBjYW4gb2NjdXIpLCB3ZSB3aWxsIGdldCB0aGUgY29ycmVjdCBwYXRobmFtZS5cbiAgY29uc3QgcGF0aG5hbWUgPSB1c2VVbnRyYWNrZWRQYXRobmFtZSgpXG4gIGlmIChlcnJvckNvbXBvbmVudCkge1xuICAgIHJldHVybiAoXG4gICAgICA8RXJyb3JCb3VuZGFyeUhhbmRsZXJcbiAgICAgICAgcGF0aG5hbWU9e3BhdGhuYW1lfVxuICAgICAgICBlcnJvckNvbXBvbmVudD17ZXJyb3JDb21wb25lbnR9XG4gICAgICAgIGVycm9yU3R5bGVzPXtlcnJvclN0eWxlc31cbiAgICAgICAgZXJyb3JTY3JpcHRzPXtlcnJvclNjcmlwdHN9XG4gICAgICA+XG4gICAgICAgIHtjaGlsZHJlbn1cbiAgICAgIDwvRXJyb3JCb3VuZGFyeUhhbmRsZXI+XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIDw+e2NoaWxkcmVufTwvPlxufVxuIl0sIm5hbWVzIjpbIkVycm9yQm91bmRhcnkiLCJFcnJvckJvdW5kYXJ5SGFuZGxlciIsIlJlYWN0IiwiQ29tcG9uZW50IiwiZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIiwiZXJyb3IiLCJpc05leHRSb3V0ZXJFcnJvciIsImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsInByb3BzIiwic3RhdGUiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX0FQUF9OQVZfRkFJTF9IQU5ETElORyIsImhhbmRsZUhhcmROYXZFcnJvciIsInByZXZpb3VzUGF0aG5hbWUiLCJwYXRobmFtZSIsInJlbmRlciIsIkhhbmRsZUlTUkVycm9yIiwiZXJyb3JTdHlsZXMiLCJlcnJvclNjcmlwdHMiLCJ0aGlzIiwiZXJyb3JDb21wb25lbnQiLCJyZXNldCIsImNoaWxkcmVuIiwiY29uc3RydWN0b3IiLCJzZXRTdGF0ZSIsInVzZVVudHJhY2tlZFBhdGhuYW1lIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztJQTBIZ0JBLGFBQWEsRUFBQTtlQUFiQTs7SUExRkhDLG9CQUFvQixFQUFBO2VBQXBCQTs7Ozs7Z0VBOUJtQjtxQ0FDSzttQ0FDSDttQ0FDQztnQ0FDSjtBQTBCeEIsTUFBTUEsNkJBQTZCQyxPQUFBQSxPQUFLLENBQUNDLFNBQVM7SUFTdkQsT0FBT0MseUJBQXlCQyxLQUFZLEVBQUU7UUFDNUMsSUFBSUMsQ0FBQUEsR0FBQUEsbUJBQUFBLGlCQUFpQixFQUFDRCxRQUFRO1lBQzVCLCtEQUErRDtZQUMvRCw0R0FBNEc7WUFDNUcsTUFBTUE7UUFDUjtRQUVBLE9BQU87WUFBRUE7UUFBTTtJQUNqQjtJQUVBLE9BQU9FLHlCQUNMQyxLQUFnQyxFQUNoQ0MsS0FBZ0MsRUFDRTtRQUNsQyxNQUFNLEVBQUVKLEtBQUssRUFBRSxHQUFHSTtRQUVsQixpQ0FBaUM7UUFDakMsOENBQThDO1FBQzlDLGlEQUFpRDtRQUNqRCw2Q0FBNkM7UUFDN0MsSUFBSUMsUUFBUUMsR0FBRyxDQUFDQyw0QkFBNEIsRUFBRTs7UUFVOUM7Ozs7O0tBS0MsR0FDRCxJQUFJSixNQUFNTyxRQUFRLEtBQUtOLE1BQU1LLGdCQUFnQixJQUFJTCxNQUFNSixLQUFLLEVBQUU7WUFDNUQsT0FBTztnQkFDTEEsT0FBTztnQkFDUFMsa0JBQWtCTixNQUFNTyxRQUFRO1lBQ2xDO1FBQ0Y7UUFDQSxPQUFPO1lBQ0xWLE9BQU9JLE1BQU1KLEtBQUs7WUFDbEJTLGtCQUFrQk4sTUFBTU8sUUFBUTtRQUNsQztJQUNGO0lBTUEseUlBQXlJO0lBQ3pJQyxTQUEwQjtRQUN4QixJQUFJLElBQUksQ0FBQ1AsS0FBSyxDQUFDSixLQUFLLEVBQUU7WUFDcEIsT0FBQSxXQUFBLEdBQ0UsQ0FBQSxHQUFBLFlBQUEsSUFBQSxFQUFBLFlBQUEsUUFBQSxFQUFBOztrQ0FDRSxDQUFBLEdBQUEsWUFBQSxHQUFBLEVBQUNZLGdCQUFBQSxjQUFjLEVBQUE7d0JBQUNaLE9BQU8sSUFBSSxDQUFDSSxLQUFLLENBQUNKLEtBQUs7O29CQUN0QyxJQUFJLENBQUNHLEtBQUssQ0FBQ1UsV0FBVztvQkFDdEIsSUFBSSxDQUFDVixLQUFLLENBQUNXLFlBQVk7a0NBQ3hCLENBQUEsR0FBQSxZQUFBLEdBQUEsRUFBQ0MsSUFBSSxDQUFDWixLQUFLLENBQUNhLGNBQWMsRUFBQTt3QkFDeEJoQixPQUFPLElBQUksQ0FBQ0ksS0FBSyxDQUFDSixLQUFLO3dCQUN2QmlCLE9BQU8sSUFBSSxDQUFDQSxLQUFLOzs7O1FBSXpCO1FBRUEsT0FBTyxJQUFJLENBQUNkLEtBQUssQ0FBQ2UsUUFBUTtJQUM1QjtJQTFFQUMsWUFBWWhCLEtBQWdDLENBQUU7UUFDNUMsS0FBSyxDQUFDQSxRQUFBQSxJQUFBQSxDQW9EUmMsS0FBQUEsR0FBUTtZQUNOLElBQUksQ0FBQ0csUUFBUSxDQUFDO2dCQUFFcEIsT0FBTztZQUFLO1FBQzlCO1FBckRFLElBQUksQ0FBQ0ksS0FBSyxHQUFHO1lBQUVKLE9BQU87WUFBTVMsa0JBQWtCLElBQUksQ0FBQ04sS0FBSyxDQUFDTyxRQUFRO1FBQUM7SUFDcEU7QUF3RUY7QUFXTyxTQUFTZixjQUFjLEtBTzdCO0lBUDZCLElBQUEsRUFDNUJxQixjQUFjLEVBQ2RILFdBQVcsRUFDWEMsWUFBWSxFQUNaSSxRQUFRLEVBR1QsR0FQNkI7SUFRNUIsNkVBQTZFO0lBQzdFLHFFQUFxRTtJQUNyRSx3RUFBd0U7SUFDeEUsb0VBQW9FO0lBQ3BFLE1BQU1SLFdBQVdXLENBQUFBLEdBQUFBLHFCQUFBQSxvQkFBb0I7SUFDckMsSUFBSUwsZ0JBQWdCO1FBQ2xCLE9BQUEsV0FBQSxHQUNFLENBQUEsR0FBQSxZQUFBLEdBQUEsRUFBQ3BCLHNCQUFBQTtZQUNDYyxVQUFVQTtZQUNWTSxnQkFBZ0JBO1lBQ2hCSCxhQUFhQTtZQUNiQyxjQUFjQTtzQkFFYkk7O0lBR1A7SUFFQSxPQUFBLFdBQUEsR0FBTyxDQUFBLEdBQUEsWUFBQSxHQUFBLEVBQUEsWUFBQSxRQUFBLEVBQUE7a0JBQUdBOztBQUNaIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDM5MjcsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvY2xpZW50L2NvbXBvbmVudHMvYnVpbHRpbi9nbG9iYWwtZXJyb3IudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuXG5pbXBvcnQgeyBIYW5kbGVJU1JFcnJvciB9IGZyb20gJy4uL2hhbmRsZS1pc3ItZXJyb3InXG5cbmNvbnN0IHN0eWxlcyA9IHtcbiAgZXJyb3I6IHtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL21vZGVybi1ub3JtYWxpemUvYmxvYi9tYWluL21vZGVybi1ub3JtYWxpemUuY3NzI0wzOC1MNTJcbiAgICBmb250RmFtaWx5OlxuICAgICAgJ3N5c3RlbS11aSxcIlNlZ29lIFVJXCIsUm9ib3RvLEhlbHZldGljYSxBcmlhbCxzYW5zLXNlcmlmLFwiQXBwbGUgQ29sb3IgRW1vamlcIixcIlNlZ29lIFVJIEVtb2ppXCInLFxuICAgIGhlaWdodDogJzEwMHZoJyxcbiAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICBmbGV4RGlyZWN0aW9uOiAnY29sdW1uJyxcbiAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICBqdXN0aWZ5Q29udGVudDogJ2NlbnRlcicsXG4gIH0sXG4gIHRleHQ6IHtcbiAgICBmb250U2l6ZTogJzE0cHgnLFxuICAgIGZvbnRXZWlnaHQ6IDQwMCxcbiAgICBsaW5lSGVpZ2h0OiAnMjhweCcsXG4gICAgbWFyZ2luOiAnMCA4cHgnLFxuICB9LFxufSBhcyBjb25zdFxuXG5leHBvcnQgdHlwZSBHbG9iYWxFcnJvckNvbXBvbmVudCA9IFJlYWN0LkNvbXBvbmVudFR5cGU8e1xuICBlcnJvcjogYW55XG59PlxuZnVuY3Rpb24gRGVmYXVsdEdsb2JhbEVycm9yKHsgZXJyb3IgfTogeyBlcnJvcjogYW55IH0pIHtcbiAgY29uc3QgZGlnZXN0OiBzdHJpbmcgfCB1bmRlZmluZWQgPSBlcnJvcj8uZGlnZXN0XG4gIHJldHVybiAoXG4gICAgPGh0bWwgaWQ9XCJfX25leHRfZXJyb3JfX1wiPlxuICAgICAgPGhlYWQ+PC9oZWFkPlxuICAgICAgPGJvZHk+XG4gICAgICAgIDxIYW5kbGVJU1JFcnJvciBlcnJvcj17ZXJyb3J9IC8+XG4gICAgICAgIDxkaXYgc3R5bGU9e3N0eWxlcy5lcnJvcn0+XG4gICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgIDxoMiBzdHlsZT17c3R5bGVzLnRleHR9PlxuICAgICAgICAgICAgICBBcHBsaWNhdGlvbiBlcnJvcjogYSB7ZGlnZXN0ID8gJ3NlcnZlcicgOiAnY2xpZW50J30tc2lkZSBleGNlcHRpb25cbiAgICAgICAgICAgICAgaGFzIG9jY3VycmVkIHdoaWxlIGxvYWRpbmcge3dpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZX0gKHNlZSB0aGV7JyAnfVxuICAgICAgICAgICAgICB7ZGlnZXN0ID8gJ3NlcnZlciBsb2dzJyA6ICdicm93c2VyIGNvbnNvbGUnfSBmb3IgbW9yZVxuICAgICAgICAgICAgICBpbmZvcm1hdGlvbikuXG4gICAgICAgICAgICA8L2gyPlxuICAgICAgICAgICAge2RpZ2VzdCA/IDxwIHN0eWxlPXtzdHlsZXMudGV4dH0+e2BEaWdlc3Q6ICR7ZGlnZXN0fWB9PC9wPiA6IG51bGx9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9ib2R5PlxuICAgIDwvaHRtbD5cbiAgKVxufVxuXG4vLyBFeHBvcnRlZCBzbyB0aGF0IHRoZSBpbXBvcnQgc2lnbmF0dXJlIGluIHRoZSBsb2FkZXJzIGNhbiBiZSBpZGVudGljYWwgdG8gdXNlclxuLy8gc3VwcGxpZWQgY3VzdG9tIGdsb2JhbCBlcnJvciBzaWduYXR1cmVzLlxuZXhwb3J0IGRlZmF1bHQgRGVmYXVsdEdsb2JhbEVycm9yXG4iXSwibmFtZXMiOlsic3R5bGVzIiwiZXJyb3IiLCJmb250RmFtaWx5IiwiaGVpZ2h0IiwidGV4dEFsaWduIiwiZGlzcGxheSIsImZsZXhEaXJlY3Rpb24iLCJhbGlnbkl0ZW1zIiwianVzdGlmeUNvbnRlbnQiLCJ0ZXh0IiwiZm9udFNpemUiLCJmb250V2VpZ2h0IiwibGluZUhlaWdodCIsIm1hcmdpbiIsIkRlZmF1bHRHbG9iYWxFcnJvciIsImRpZ2VzdCIsImh0bWwiLCJpZCIsImhlYWQiLCJib2R5IiwiSGFuZGxlSVNSRXJyb3IiLCJkaXYiLCJzdHlsZSIsImgyIiwid2luZG93IiwibG9jYXRpb24iLCJob3N0bmFtZSIsInAiXSwibWFwcGluZ3MiOiI7OzsrQkFtREEsQUFEQSwyQ0FDMkMscUNBRHFDO0FBRWhGLFdBQUE7OztlQUFBOzs7O2dDQWxEK0I7QUFFL0IsTUFBTUEsU0FBUztJQUNiQyxPQUFPO1FBQ0wsMEZBQTBGO1FBQzFGQyxZQUNFO1FBQ0ZDLFFBQVE7UUFDUkMsV0FBVztRQUNYQyxTQUFTO1FBQ1RDLGVBQWU7UUFDZkMsWUFBWTtRQUNaQyxnQkFBZ0I7SUFDbEI7SUFDQUMsTUFBTTtRQUNKQyxVQUFVO1FBQ1ZDLFlBQVk7UUFDWkMsWUFBWTtRQUNaQyxRQUFRO0lBQ1Y7QUFDRjtBQUtBLFNBQVNDLG1CQUFtQixLQUF5QjtJQUF6QixJQUFBLEVBQUViLEtBQUssRUFBa0IsR0FBekI7SUFDMUIsTUFBTWMsU0FBNkJkLFNBQUFBLE9BQUFBLEtBQUFBLElBQUFBLE1BQU9jLE1BQU07SUFDaEQsT0FBQSxXQUFBLEdBQ0UsQ0FBQSxHQUFBLFlBQUEsSUFBQSxFQUFDQyxRQUFBQTtRQUFLQyxJQUFHOzswQkFDUCxDQUFBLEdBQUEsWUFBQSxHQUFBLEVBQUNDLFFBQUFBLENBQUFBOzBCQUNELENBQUEsR0FBQSxZQUFBLElBQUEsRUFBQ0MsUUFBQUE7O2tDQUNDLENBQUEsR0FBQSxZQUFBLEdBQUEsRUFBQ0MsZ0JBQUFBLGNBQWMsRUFBQTt3QkFBQ25CLE9BQU9BOztrQ0FDdkIsQ0FBQSxHQUFBLFlBQUEsR0FBQSxFQUFDb0IsT0FBQUE7d0JBQUlDLE9BQU90QixPQUFPQyxLQUFLO2tDQUN0QixXQUFBLEdBQUEsQ0FBQSxHQUFBLFlBQUEsSUFBQSxFQUFDb0IsT0FBQUE7OzhDQUNDLENBQUEsR0FBQSxZQUFBLElBQUEsRUFBQ0UsTUFBQUE7b0NBQUdELE9BQU90QixPQUFPUyxJQUFJOzt3Q0FBRTt3Q0FDQU0sU0FBUyxXQUFXO3dDQUFTO3dDQUN2QlMsT0FBT0MsUUFBUSxDQUFDQyxRQUFRO3dDQUFDO3dDQUFVO3dDQUM5RFgsU0FBUyxnQkFBZ0I7d0NBQWtCOzs7Z0NBRzdDQSxTQUFBQSxXQUFBQSxHQUFTLENBQUEsR0FBQSxZQUFBLEdBQUEsRUFBQ1ksS0FBQUE7b0NBQUVMLE9BQU90QixPQUFPUyxJQUFJOzhDQUFJLGFBQVVNO3FDQUFnQjs7Ozs7Ozs7QUFNekU7TUFJQSxXQUFlRCIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA0MDEyLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2h0bWwtYm90cy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUaGlzIHJlZ2V4IGNvbnRhaW5zIHRoZSBib3RzIHRoYXQgd2UgbmVlZCB0byBkbyBhIGJsb2NraW5nIHJlbmRlciBmb3IgYW5kIGNhbid0IHNhZmVseSBzdHJlYW0gdGhlIHJlc3BvbnNlXG4vLyBkdWUgdG8gaG93IHRoZXkgcGFyc2UgdGhlIERPTS4gRm9yIGV4YW1wbGUsIHRoZXkgbWlnaHQgZXhwbGljaXRseSBjaGVjayBmb3IgbWV0YWRhdGEgaW4gdGhlIGBoZWFkYCB0YWcsIHNvIHdlIGNhbid0IHN0cmVhbSBtZXRhZGF0YSB0YWdzIGFmdGVyIHRoZSBgaGVhZGAgd2FzIHNlbnQuXG5leHBvcnQgY29uc3QgSFRNTF9MSU1JVEVEX0JPVF9VQV9SRSA9XG4gIC9NZWRpYXBhcnRuZXJzLUdvb2dsZXxDaHJvbWUtTGlnaHRob3VzZXxTbHVycHxEdWNrRHVja0JvdHxiYWlkdXNwaWRlcnx5YW5kZXh8c29nb3V8Yml0bHlib3R8dHVtYmxyfHZrU2hhcmV8cXVvcmEgbGluayBwcmV2aWV3fHJlZGRpdGJvdHxpYV9hcmNoaXZlcnxCaW5nYm90fEJpbmdQcmV2aWV3fGFwcGxlYm90fGZhY2Vib29rZXh0ZXJuYWxoaXR8ZmFjZWJvb2tjYXRhbG9nfFR3aXR0ZXJib3R8TGlua2VkSW5Cb3R8U2xhY2tib3R8RGlzY29yZGJvdHxXaGF0c0FwcHxTa3lwZVVyaVByZXZpZXd8WWV0aS9pXG4iXSwibmFtZXMiOlsiSFRNTF9MSU1JVEVEX0JPVF9VQV9SRSJdLCJtYXBwaW5ncyI6IkFBQUEsNkdBQTZHO0FBQzdHLHNLQUFzSzs7OzsrQkFDekpBLDBCQUFBQTs7O2VBQUFBOzs7QUFBTixNQUFNQSx5QkFDWCIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA0MDMwLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2lzLWJvdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBIVE1MX0xJTUlURURfQk9UX1VBX1JFIH0gZnJvbSAnLi9odG1sLWJvdHMnXG5cbi8vIEJvdCBjcmF3bGVyIHRoYXQgd2lsbCBzcGluIHVwIGEgaGVhZGxlc3MgYnJvd3NlciBhbmQgZXhlY3V0ZSBKUy5cbi8vIEJ5IGRlZmF1bHQsIG9ubHkgZ29vZ2xlYm90cyBhcmUgY29uc2lkZXJlZCBhcyBET00gYm90cy4gQmxvdyBpcyB3aGVyZSB0aGUgcmVnZXggaXMgY29tcHV0ZWQgZnJvbTpcbi8vIHgtcmVmOiBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9zZWFyY2gvZG9jcy9jcmF3bGluZy1pbmRleGluZy9nb29nbGUtY29tbW9uLWNyYXdsZXJzXG5jb25zdCBIRUFETEVTU19CUk9XU0VSX0JPVF9VQV9SRSA9IC9nb29nbGUvaVxuXG5leHBvcnQgY29uc3QgSFRNTF9MSU1JVEVEX0JPVF9VQV9SRV9TVFJJTkcgPSBIVE1MX0xJTUlURURfQk9UX1VBX1JFLnNvdXJjZVxuXG5leHBvcnQgeyBIVE1MX0xJTUlURURfQk9UX1VBX1JFIH1cblxuZnVuY3Rpb24gaXNEb21Cb3RVQSh1c2VyQWdlbnQ6IHN0cmluZykge1xuICByZXR1cm4gSEVBRExFU1NfQlJPV1NFUl9CT1RfVUFfUkUudGVzdCh1c2VyQWdlbnQpXG59XG5cbmZ1bmN0aW9uIGlzSHRtbExpbWl0ZWRCb3RVQSh1c2VyQWdlbnQ6IHN0cmluZykge1xuICByZXR1cm4gSFRNTF9MSU1JVEVEX0JPVF9VQV9SRS50ZXN0KHVzZXJBZ2VudClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQm90KHVzZXJBZ2VudDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiBpc0RvbUJvdFVBKHVzZXJBZ2VudCkgfHwgaXNIdG1sTGltaXRlZEJvdFVBKHVzZXJBZ2VudClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEJvdFR5cGUodXNlckFnZW50OiBzdHJpbmcpOiAnZG9tJyB8ICdodG1sJyB8IHVuZGVmaW5lZCB7XG4gIGlmIChpc0RvbUJvdFVBKHVzZXJBZ2VudCkpIHtcbiAgICByZXR1cm4gJ2RvbSdcbiAgfVxuICBpZiAoaXNIdG1sTGltaXRlZEJvdFVBKHVzZXJBZ2VudCkpIHtcbiAgICByZXR1cm4gJ2h0bWwnXG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZFxufVxuIl0sIm5hbWVzIjpbIkhUTUxfTElNSVRFRF9CT1RfVUFfUkUiLCJIVE1MX0xJTUlURURfQk9UX1VBX1JFX1NUUklORyIsImdldEJvdFR5cGUiLCJpc0JvdCIsIkhFQURMRVNTX0JST1dTRVJfQk9UX1VBX1JFIiwic291cmNlIiwiaXNEb21Cb3RVQSIsInVzZXJBZ2VudCIsInRlc3QiLCJpc0h0bWxMaW1pdGVkQm90VUEiLCJ1bmRlZmluZWQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7SUFTU0Esc0JBQXNCLEVBQUE7ZUFBdEJBLFVBQUFBLHNCQUFzQjs7SUFGbEJDLDZCQUE2QixFQUFBO2VBQTdCQTs7SUFnQkdDLFVBQVUsRUFBQTtlQUFWQTs7SUFKQUMsS0FBSyxFQUFBO2VBQUxBOzs7MEJBbkJ1QjtBQUV2QyxtRUFBbUU7QUFDbkUsb0dBQW9HO0FBQ3BHLDRGQUE0RjtBQUM1RixNQUFNQyw2QkFBNkI7QUFFNUIsTUFBTUgsZ0NBQWdDRCxVQUFBQSxzQkFBc0IsQ0FBQ0ssTUFBTTtBQUkxRSxTQUFTQyxXQUFXQyxTQUFpQjtJQUNuQyxPQUFPSCwyQkFBMkJJLElBQUksQ0FBQ0Q7QUFDekM7QUFFQSxTQUFTRSxtQkFBbUJGLFNBQWlCO0lBQzNDLE9BQU9QLFVBQUFBLHNCQUFzQixDQUFDUSxJQUFJLENBQUNEO0FBQ3JDO0FBRU8sU0FBU0osTUFBTUksU0FBaUI7SUFDckMsT0FBT0QsV0FBV0MsY0FBY0UsbUJBQW1CRjtBQUNyRDtBQUVPLFNBQVNMLFdBQVdLLFNBQWlCO0lBQzFDLElBQUlELFdBQVdDLFlBQVk7UUFDekIsT0FBTztJQUNUO0lBQ0EsSUFBSUUsbUJBQW1CRixZQUFZO1FBQ2pDLE9BQU87SUFDVDtJQUNBLE9BQU9HO0FBQ1QiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNDA4OSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvY29tcG9uZW50cy9hcHAtcm91dGVyLWFubm91bmNlci50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBjcmVhdGVQb3J0YWwgfSBmcm9tICdyZWFjdC1kb20nXG5pbXBvcnQgdHlwZSB7IEZsaWdodFJvdXRlclN0YXRlIH0gZnJvbSAnLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvdHlwZXMnXG5cbmNvbnN0IEFOTk9VTkNFUl9UWVBFID0gJ25leHQtcm91dGUtYW5ub3VuY2VyJ1xuY29uc3QgQU5OT1VOQ0VSX0lEID0gJ19fbmV4dC1yb3V0ZS1hbm5vdW5jZXJfXydcblxuZnVuY3Rpb24gZ2V0QW5ub3VuY2VyTm9kZSgpIHtcbiAgY29uc3QgZXhpc3RpbmdBbm5vdW5jZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZShBTk5PVU5DRVJfVFlQRSlbMF1cbiAgaWYgKGV4aXN0aW5nQW5ub3VuY2VyPy5zaGFkb3dSb290Py5jaGlsZE5vZGVzWzBdKSB7XG4gICAgcmV0dXJuIGV4aXN0aW5nQW5ub3VuY2VyLnNoYWRvd1Jvb3QuY2hpbGROb2Rlc1swXSBhcyBIVE1MRWxlbWVudFxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoQU5OT1VOQ0VSX1RZUEUpXG4gICAgY29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSAncG9zaXRpb246YWJzb2x1dGUnXG4gICAgY29uc3QgYW5ub3VuY2VyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICBhbm5vdW5jZXIuYXJpYUxpdmUgPSAnYXNzZXJ0aXZlJ1xuICAgIGFubm91bmNlci5pZCA9IEFOTk9VTkNFUl9JRFxuICAgIGFubm91bmNlci5yb2xlID0gJ2FsZXJ0J1xuICAgIGFubm91bmNlci5zdHlsZS5jc3NUZXh0ID1cbiAgICAgICdwb3NpdGlvbjphYnNvbHV0ZTtib3JkZXI6MDtoZWlnaHQ6MXB4O21hcmdpbjotMXB4O3BhZGRpbmc6MDt3aWR0aDoxcHg7Y2xpcDpyZWN0KDAgMCAwIDApO292ZXJmbG93OmhpZGRlbjt3aGl0ZS1zcGFjZTpub3dyYXA7d29yZC13cmFwOm5vcm1hbCdcblxuICAgIC8vIFVzZSBzaGFkb3cgRE9NIGhlcmUgdG8gYXZvaWQgYW55IHBvdGVudGlhbCBDU1MgYmxlZWRcbiAgICBjb25zdCBzaGFkb3cgPSBjb250YWluZXIuYXR0YWNoU2hhZG93KHsgbW9kZTogJ29wZW4nIH0pXG4gICAgc2hhZG93LmFwcGVuZENoaWxkKGFubm91bmNlcilcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNvbnRhaW5lcilcbiAgICByZXR1cm4gYW5ub3VuY2VyXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEFwcFJvdXRlckFubm91bmNlcih7IHRyZWUgfTogeyB0cmVlOiBGbGlnaHRSb3V0ZXJTdGF0ZSB9KSB7XG4gIGNvbnN0IFtwb3J0YWxOb2RlLCBzZXRQb3J0YWxOb2RlXSA9IHVzZVN0YXRlPEhUTUxFbGVtZW50IHwgbnVsbD4obnVsbClcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGFubm91bmNlciA9IGdldEFubm91bmNlck5vZGUoKVxuICAgIHNldFBvcnRhbE5vZGUoYW5ub3VuY2VyKVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShBTk5PVU5DRVJfVFlQRSlbMF1cbiAgICAgIGlmIChjb250YWluZXI/LmlzQ29ubmVjdGVkKSB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoY29udGFpbmVyKVxuICAgICAgfVxuICAgIH1cbiAgfSwgW10pXG5cbiAgY29uc3QgW3JvdXRlQW5ub3VuY2VtZW50LCBzZXRSb3V0ZUFubm91bmNlbWVudF0gPSB1c2VTdGF0ZSgnJylcbiAgY29uc3QgcHJldmlvdXNUaXRsZSA9IHVzZVJlZjxzdHJpbmcgfCB1bmRlZmluZWQ+KHVuZGVmaW5lZClcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxldCBjdXJyZW50VGl0bGUgPSAnJ1xuICAgIGlmIChkb2N1bWVudC50aXRsZSkge1xuICAgICAgY3VycmVudFRpdGxlID0gZG9jdW1lbnQudGl0bGVcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcGFnZUhlYWRlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2gxJylcbiAgICAgIGlmIChwYWdlSGVhZGVyKSB7XG4gICAgICAgIGN1cnJlbnRUaXRsZSA9IHBhZ2VIZWFkZXIuaW5uZXJUZXh0IHx8IHBhZ2VIZWFkZXIudGV4dENvbnRlbnQgfHwgJydcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBPbmx5IGFubm91bmNlIHRoZSB0aXRsZSBjaGFuZ2UsIGJ1dCBub3QgZm9yIHRoZSBmaXJzdCBsb2FkIGJlY2F1c2Ugc2NyZWVuXG4gICAgLy8gcmVhZGVycyBkbyB0aGF0IGF1dG9tYXRpY2FsbHkuXG4gICAgaWYgKFxuICAgICAgcHJldmlvdXNUaXRsZS5jdXJyZW50ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIHByZXZpb3VzVGl0bGUuY3VycmVudCAhPT0gY3VycmVudFRpdGxlXG4gICAgKSB7XG4gICAgICBzZXRSb3V0ZUFubm91bmNlbWVudChjdXJyZW50VGl0bGUpXG4gICAgfVxuICAgIHByZXZpb3VzVGl0bGUuY3VycmVudCA9IGN1cnJlbnRUaXRsZVxuICB9LCBbdHJlZV0pXG5cbiAgcmV0dXJuIHBvcnRhbE5vZGUgPyBjcmVhdGVQb3J0YWwocm91dGVBbm5vdW5jZW1lbnQsIHBvcnRhbE5vZGUpIDogbnVsbFxufVxuIl0sIm5hbWVzIjpbIkFwcFJvdXRlckFubm91bmNlciIsIkFOTk9VTkNFUl9UWVBFIiwiQU5OT1VOQ0VSX0lEIiwiZ2V0QW5ub3VuY2VyTm9kZSIsImV4aXN0aW5nQW5ub3VuY2VyIiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50c0J5TmFtZSIsInNoYWRvd1Jvb3QiLCJjaGlsZE5vZGVzIiwiY29udGFpbmVyIiwiY3JlYXRlRWxlbWVudCIsInN0eWxlIiwiY3NzVGV4dCIsImFubm91bmNlciIsImFyaWFMaXZlIiwiaWQiLCJyb2xlIiwic2hhZG93IiwiYXR0YWNoU2hhZG93IiwibW9kZSIsImFwcGVuZENoaWxkIiwiYm9keSIsInRyZWUiLCJwb3J0YWxOb2RlIiwic2V0UG9ydGFsTm9kZSIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJpc0Nvbm5lY3RlZCIsInJlbW92ZUNoaWxkIiwicm91dGVBbm5vdW5jZW1lbnQiLCJzZXRSb3V0ZUFubm91bmNlbWVudCIsInByZXZpb3VzVGl0bGUiLCJ1c2VSZWYiLCJ1bmRlZmluZWQiLCJjdXJyZW50VGl0bGUiLCJ0aXRsZSIsInBhZ2VIZWFkZXIiLCJxdWVyeVNlbGVjdG9yIiwiaW5uZXJUZXh0IiwidGV4dENvbnRlbnQiLCJjdXJyZW50IiwiY3JlYXRlUG9ydGFsIl0sIm1hcHBpbmdzIjoiOzs7K0JBNkJnQkEsc0JBQUFBOzs7ZUFBQUE7Ozt1QkE3QjRCOzBCQUNmO0FBRzdCLE1BQU1DLGlCQUFpQjtBQUN2QixNQUFNQyxlQUFlO0FBRXJCLFNBQVNDO1FBRUhDO0lBREosTUFBTUEsb0JBQW9CQyxTQUFTQyxpQkFBaUIsQ0FBQ0wsZUFBZSxDQUFDLEVBQUU7SUFDdkUsSUFBSUcscUJBQUFBLE9BQUFBLEtBQUFBLElBQUFBLENBQUFBLGdDQUFBQSxrQkFBbUJHLFVBQVUsS0FBQSxPQUFBLEtBQUEsSUFBN0JILDhCQUErQkksVUFBVSxDQUFDLEVBQUUsRUFBRTtRQUNoRCxPQUFPSixrQkFBa0JHLFVBQVUsQ0FBQ0MsVUFBVSxDQUFDLEVBQUU7SUFDbkQsT0FBTztRQUNMLE1BQU1DLFlBQVlKLFNBQVNLLGFBQWEsQ0FBQ1Q7UUFDekNRLFVBQVVFLEtBQUssQ0FBQ0MsT0FBTyxHQUFHO1FBQzFCLE1BQU1DLFlBQVlSLFNBQVNLLGFBQWEsQ0FBQztRQUN6Q0csVUFBVUMsUUFBUSxHQUFHO1FBQ3JCRCxVQUFVRSxFQUFFLEdBQUdiO1FBQ2ZXLFVBQVVHLElBQUksR0FBRztRQUNqQkgsVUFBVUYsS0FBSyxDQUFDQyxPQUFPLEdBQ3JCO1FBRUYsdURBQXVEO1FBQ3ZELE1BQU1LLFNBQVNSLFVBQVVTLFlBQVksQ0FBQztZQUFFQyxNQUFNO1FBQU87UUFDckRGLE9BQU9HLFdBQVcsQ0FBQ1A7UUFDbkJSLFNBQVNnQixJQUFJLENBQUNELFdBQVcsQ0FBQ1g7UUFDMUIsT0FBT0k7SUFDVDtBQUNGO0FBRU8sU0FBU2IsbUJBQW1CLEtBQXFDO0lBQXJDLElBQUEsRUFBRXNCLElBQUksRUFBK0IsR0FBckM7SUFDakMsTUFBTSxDQUFDQyxZQUFZQyxjQUFjLEdBQUdDLENBQUFBLEdBQUFBLE9BQUFBLFFBQVEsRUFBcUI7SUFFakVDLENBQUFBLEdBQUFBLE9BQUFBLFNBQVMsRUFBQztRQUNSLE1BQU1iLFlBQVlWO1FBQ2xCcUIsY0FBY1g7UUFDZCxPQUFPO1lBQ0wsTUFBTUosWUFBWUosU0FBU3NCLG9CQUFvQixDQUFDMUIsZUFBZSxDQUFDLEVBQUU7WUFDbEUsSUFBSVEsYUFBQUEsT0FBQUEsS0FBQUEsSUFBQUEsVUFBV21CLFdBQVcsRUFBRTtnQkFDMUJ2QixTQUFTZ0IsSUFBSSxDQUFDUSxXQUFXLENBQUNwQjtZQUM1QjtRQUNGO0lBQ0YsR0FBRyxFQUFFO0lBRUwsTUFBTSxDQUFDcUIsbUJBQW1CQyxxQkFBcUIsR0FBR04sQ0FBQUEsR0FBQUEsT0FBQUEsUUFBUSxFQUFDO0lBQzNELE1BQU1PLGdCQUFnQkMsQ0FBQUEsR0FBQUEsT0FBQUEsTUFBTSxFQUFxQkM7SUFFakRSLENBQUFBLEdBQUFBLE9BQUFBLFNBQVMsRUFBQztRQUNSLElBQUlTLGVBQWU7UUFDbkIsSUFBSTlCLFNBQVMrQixLQUFLLEVBQUU7WUFDbEJELGVBQWU5QixTQUFTK0IsS0FBSztRQUMvQixPQUFPO1lBQ0wsTUFBTUMsYUFBYWhDLFNBQVNpQyxhQUFhLENBQUM7WUFDMUMsSUFBSUQsWUFBWTtnQkFDZEYsZUFBZUUsV0FBV0UsU0FBUyxJQUFJRixXQUFXRyxXQUFXLElBQUk7WUFDbkU7UUFDRjtRQUVBLDRFQUE0RTtRQUM1RSxpQ0FBaUM7UUFDakMsSUFDRVIsY0FBY1MsT0FBTyxLQUFLUCxhQUMxQkYsY0FBY1MsT0FBTyxLQUFLTixjQUMxQjtZQUNBSixxQkFBcUJJO1FBQ3ZCO1FBQ0FILGNBQWNTLE9BQU8sR0FBR047SUFDMUIsR0FBRztRQUFDYjtLQUFLO0lBRVQsT0FBT0MsYUFBQUEsV0FBQUEsR0FBYW1CLENBQUFBLEdBQUFBLFVBQUFBLFlBQVksRUFBQ1osbUJBQW1CUCxjQUFjO0FBQ3BFIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDQxNzMsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvZ2V0LXNlZ21lbnQtdmFsdWUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBTZWdtZW50IH0gZnJvbSAnLi4vLi4vLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvdHlwZXMnXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTZWdtZW50VmFsdWUoc2VnbWVudDogU2VnbWVudCkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShzZWdtZW50KSA/IHNlZ21lbnRbMV0gOiBzZWdtZW50XG59XG4iXSwibmFtZXMiOlsiZ2V0U2VnbWVudFZhbHVlIiwic2VnbWVudCIsIkFycmF5IiwiaXNBcnJheSJdLCJtYXBwaW5ncyI6Ijs7OytCQUVnQkEsbUJBQUFBOzs7ZUFBQUE7OztBQUFULFNBQVNBLGdCQUFnQkMsT0FBZ0I7SUFDOUMsT0FBT0MsTUFBTUMsT0FBTyxDQUFDRixXQUFXQSxPQUFPLENBQUMsRUFBRSxHQUFHQTtBQUMvQyIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA0MTk4LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2NsaWVudC9jb21wb25lbnRzL3JlZGlyZWN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJlZGlyZWN0U3RhdHVzQ29kZSB9IGZyb20gJy4vcmVkaXJlY3Qtc3RhdHVzLWNvZGUnXG5pbXBvcnQge1xuICBSZWRpcmVjdFR5cGUsXG4gIHR5cGUgUmVkaXJlY3RFcnJvcixcbiAgaXNSZWRpcmVjdEVycm9yLFxuICBSRURJUkVDVF9FUlJPUl9DT0RFLFxufSBmcm9tICcuL3JlZGlyZWN0LWVycm9yJ1xuXG5jb25zdCBhY3Rpb25Bc3luY1N0b3JhZ2UgPVxuICB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJ1xuICAgID8gKFxuICAgICAgICByZXF1aXJlKCcuLi8uLi9zZXJ2ZXIvYXBwLXJlbmRlci9hY3Rpb24tYXN5bmMtc3RvcmFnZS5leHRlcm5hbCcpIGFzIHR5cGVvZiBpbXBvcnQoJy4uLy4uL3NlcnZlci9hcHAtcmVuZGVyL2FjdGlvbi1hc3luYy1zdG9yYWdlLmV4dGVybmFsJylcbiAgICAgICkuYWN0aW9uQXN5bmNTdG9yYWdlXG4gICAgOiB1bmRlZmluZWRcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJlZGlyZWN0RXJyb3IoXG4gIHVybDogc3RyaW5nLFxuICB0eXBlOiBSZWRpcmVjdFR5cGUsXG4gIHN0YXR1c0NvZGU6IFJlZGlyZWN0U3RhdHVzQ29kZSA9IFJlZGlyZWN0U3RhdHVzQ29kZS5UZW1wb3JhcnlSZWRpcmVjdFxuKTogUmVkaXJlY3RFcnJvciB7XG4gIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKFJFRElSRUNUX0VSUk9SX0NPREUpIGFzIFJlZGlyZWN0RXJyb3JcbiAgZXJyb3IuZGlnZXN0ID0gYCR7UkVESVJFQ1RfRVJST1JfQ09ERX07JHt0eXBlfTske3VybH07JHtzdGF0dXNDb2RlfTtgXG4gIHJldHVybiBlcnJvclxufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byByZWRpcmVjdCB0aGUgdXNlciB0byBhbm90aGVyIFVSTC4gSXQgY2FuIGJlIHVzZWQgaW5cbiAqIFtTZXJ2ZXIgQ29tcG9uZW50c10oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2J1aWxkaW5nLXlvdXItYXBwbGljYXRpb24vcmVuZGVyaW5nL3NlcnZlci1jb21wb25lbnRzKSxcbiAqIFtSb3V0ZSBIYW5kbGVyc10oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2J1aWxkaW5nLXlvdXItYXBwbGljYXRpb24vcm91dGluZy9yb3V0ZS1oYW5kbGVycyksIGFuZFxuICogW1NlcnZlciBBY3Rpb25zXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYnVpbGRpbmcteW91ci1hcHBsaWNhdGlvbi9kYXRhLWZldGNoaW5nL3NlcnZlci1hY3Rpb25zLWFuZC1tdXRhdGlvbnMpLlxuICpcbiAqIC0gSW4gYSBTZXJ2ZXIgQ29tcG9uZW50LCB0aGlzIHdpbGwgaW5zZXJ0IGEgbWV0YSB0YWcgdG8gcmVkaXJlY3QgdGhlIHVzZXIgdG8gdGhlIHRhcmdldCBwYWdlLlxuICogLSBJbiBhIFJvdXRlIEhhbmRsZXIgb3IgU2VydmVyIEFjdGlvbiwgaXQgd2lsbCBzZXJ2ZSBhIDMwNy8zMDMgdG8gdGhlIGNhbGxlci5cbiAqIC0gSW4gYSBTZXJ2ZXIgQWN0aW9uLCB0eXBlIGRlZmF1bHRzIHRvICdwdXNoJyBhbmQgJ3JlcGxhY2UnIGVsc2V3aGVyZS5cbiAqXG4gKiBSZWFkIG1vcmU6IFtOZXh0LmpzIERvY3M6IGByZWRpcmVjdGBdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9hcGktcmVmZXJlbmNlL2Z1bmN0aW9ucy9yZWRpcmVjdClcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlZGlyZWN0KFxuICAvKiogVGhlIFVSTCB0byByZWRpcmVjdCB0byAqL1xuICB1cmw6IHN0cmluZyxcbiAgdHlwZT86IFJlZGlyZWN0VHlwZVxuKTogbmV2ZXIge1xuICB0eXBlID8/PSBhY3Rpb25Bc3luY1N0b3JhZ2U/LmdldFN0b3JlKCk/LmlzQWN0aW9uXG4gICAgPyBSZWRpcmVjdFR5cGUucHVzaFxuICAgIDogUmVkaXJlY3RUeXBlLnJlcGxhY2VcblxuICB0aHJvdyBnZXRSZWRpcmVjdEVycm9yKHVybCwgdHlwZSwgUmVkaXJlY3RTdGF0dXNDb2RlLlRlbXBvcmFyeVJlZGlyZWN0KVxufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byByZWRpcmVjdCB0aGUgdXNlciB0byBhbm90aGVyIFVSTC4gSXQgY2FuIGJlIHVzZWQgaW5cbiAqIFtTZXJ2ZXIgQ29tcG9uZW50c10oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2J1aWxkaW5nLXlvdXItYXBwbGljYXRpb24vcmVuZGVyaW5nL3NlcnZlci1jb21wb25lbnRzKSxcbiAqIFtSb3V0ZSBIYW5kbGVyc10oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2J1aWxkaW5nLXlvdXItYXBwbGljYXRpb24vcm91dGluZy9yb3V0ZS1oYW5kbGVycyksIGFuZFxuICogW1NlcnZlciBBY3Rpb25zXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYnVpbGRpbmcteW91ci1hcHBsaWNhdGlvbi9kYXRhLWZldGNoaW5nL3NlcnZlci1hY3Rpb25zLWFuZC1tdXRhdGlvbnMpLlxuICpcbiAqIC0gSW4gYSBTZXJ2ZXIgQ29tcG9uZW50LCB0aGlzIHdpbGwgaW5zZXJ0IGEgbWV0YSB0YWcgdG8gcmVkaXJlY3QgdGhlIHVzZXIgdG8gdGhlIHRhcmdldCBwYWdlLlxuICogLSBJbiBhIFJvdXRlIEhhbmRsZXIgb3IgU2VydmVyIEFjdGlvbiwgaXQgd2lsbCBzZXJ2ZSBhIDMwOC8zMDMgdG8gdGhlIGNhbGxlci5cbiAqXG4gKiBSZWFkIG1vcmU6IFtOZXh0LmpzIERvY3M6IGByZWRpcmVjdGBdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9hcGktcmVmZXJlbmNlL2Z1bmN0aW9ucy9yZWRpcmVjdClcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBlcm1hbmVudFJlZGlyZWN0KFxuICAvKiogVGhlIFVSTCB0byByZWRpcmVjdCB0byAqL1xuICB1cmw6IHN0cmluZyxcbiAgdHlwZTogUmVkaXJlY3RUeXBlID0gUmVkaXJlY3RUeXBlLnJlcGxhY2Vcbik6IG5ldmVyIHtcbiAgdGhyb3cgZ2V0UmVkaXJlY3RFcnJvcih1cmwsIHR5cGUsIFJlZGlyZWN0U3RhdHVzQ29kZS5QZXJtYW5lbnRSZWRpcmVjdClcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBlbmNvZGVkIFVSTCBmcm9tIHRoZSBlcnJvciBpZiBpdCdzIGEgUmVkaXJlY3RFcnJvciwgbnVsbFxuICogb3RoZXJ3aXNlLiBOb3RlIHRoYXQgdGhpcyBkb2VzIG5vdCB2YWxpZGF0ZSB0aGUgVVJMIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSBlcnJvciB0aGUgZXJyb3IgdGhhdCBtYXkgYmUgYSByZWRpcmVjdCBlcnJvclxuICogQHJldHVybiB0aGUgdXJsIGlmIHRoZSBlcnJvciB3YXMgYSByZWRpcmVjdCBlcnJvclxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VVJMRnJvbVJlZGlyZWN0RXJyb3IoZXJyb3I6IFJlZGlyZWN0RXJyb3IpOiBzdHJpbmdcbmV4cG9ydCBmdW5jdGlvbiBnZXRVUkxGcm9tUmVkaXJlY3RFcnJvcihlcnJvcjogdW5rbm93bik6IHN0cmluZyB8IG51bGwge1xuICBpZiAoIWlzUmVkaXJlY3RFcnJvcihlcnJvcikpIHJldHVybiBudWxsXG5cbiAgLy8gU2xpY2VzIG9mZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSBkaWdlc3QgdGhhdCBjb250YWlucyB0aGUgY29kZSBhbmQgdGhlXG4gIC8vIHNlcGFyYXRpbmcgJzsnLlxuICByZXR1cm4gZXJyb3IuZGlnZXN0LnNwbGl0KCc7Jykuc2xpY2UoMiwgLTIpLmpvaW4oJzsnKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmVkaXJlY3RUeXBlRnJvbUVycm9yKGVycm9yOiBSZWRpcmVjdEVycm9yKTogUmVkaXJlY3RUeXBlIHtcbiAgaWYgKCFpc1JlZGlyZWN0RXJyb3IoZXJyb3IpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYSByZWRpcmVjdCBlcnJvcicpXG4gIH1cblxuICByZXR1cm4gZXJyb3IuZGlnZXN0LnNwbGl0KCc7JywgMilbMV0gYXMgUmVkaXJlY3RUeXBlXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSZWRpcmVjdFN0YXR1c0NvZGVGcm9tRXJyb3IoZXJyb3I6IFJlZGlyZWN0RXJyb3IpOiBudW1iZXIge1xuICBpZiAoIWlzUmVkaXJlY3RFcnJvcihlcnJvcikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhIHJlZGlyZWN0IGVycm9yJylcbiAgfVxuXG4gIHJldHVybiBOdW1iZXIoZXJyb3IuZGlnZXN0LnNwbGl0KCc7JykuYXQoLTIpKVxufVxuIl0sIm5hbWVzIjpbImdldFJlZGlyZWN0RXJyb3IiLCJnZXRSZWRpcmVjdFN0YXR1c0NvZGVGcm9tRXJyb3IiLCJnZXRSZWRpcmVjdFR5cGVGcm9tRXJyb3IiLCJnZXRVUkxGcm9tUmVkaXJlY3RFcnJvciIsInBlcm1hbmVudFJlZGlyZWN0IiwicmVkaXJlY3QiLCJhY3Rpb25Bc3luY1N0b3JhZ2UiLCJ3aW5kb3ciLCJyZXF1aXJlIiwidW5kZWZpbmVkIiwidXJsIiwidHlwZSIsInN0YXR1c0NvZGUiLCJSZWRpcmVjdFN0YXR1c0NvZGUiLCJUZW1wb3JhcnlSZWRpcmVjdCIsImVycm9yIiwiRXJyb3IiLCJSRURJUkVDVF9FUlJPUl9DT0RFIiwiZGlnZXN0IiwiZ2V0U3RvcmUiLCJpc0FjdGlvbiIsIlJlZGlyZWN0VHlwZSIsInB1c2giLCJyZXBsYWNlIiwiUGVybWFuZW50UmVkaXJlY3QiLCJpc1JlZGlyZWN0RXJyb3IiLCJzcGxpdCIsInNsaWNlIiwiam9pbiIsIk51bWJlciIsImF0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFlZ0JBLGdCQUFnQixFQUFBO2VBQWhCQTs7SUE2RUFDLDhCQUE4QixFQUFBO2VBQTlCQTs7SUFSQUMsd0JBQXdCLEVBQUE7ZUFBeEJBOztJQVJBQyx1QkFBdUIsRUFBQTtlQUF2QkE7O0lBaEJBQyxpQkFBaUIsRUFBQTtlQUFqQkE7O0lBdkJBQyxRQUFRLEVBQUE7ZUFBUkE7OztvQ0FyQ21COytCQU01QjtBQUVQLE1BQU1DLHFCQUNKLE9BQU9DLFdBQVcscUJBRVpDLFFBQVEsMktBQ1JGLGtCQUFrQixHQUNwQkc7QUFFQyxTQUFTVCxpQkFDZFUsR0FBVyxFQUNYQyxJQUFrQixFQUNsQkMsVUFBcUU7SUFBckVBLElBQUFBLGVBQUFBLEtBQUFBLEdBQUFBLGFBQWlDQyxvQkFBQUEsa0JBQWtCLENBQUNDLGlCQUFpQjtJQUVyRSxNQUFNQyxRQUFRLE9BQUEsY0FBOEIsQ0FBOUIsSUFBSUMsTUFBTUMsZUFBQUEsbUJBQW1CLEdBQTdCLHFCQUFBO2VBQUE7b0JBQUE7c0JBQUE7SUFBNkI7SUFDM0NGLE1BQU1HLE1BQU0sR0FBTUQsZUFBQUEsbUJBQW1CLEdBQUMsTUFBR04sT0FBSyxNQUFHRCxNQUFJLE1BQUdFLGFBQVc7SUFDbkUsT0FBT0c7QUFDVDtBQWNPLFNBQVNWLFNBQ2QsMkJBQTJCLEdBQzNCSyxHQUFXLEVBQ1hDLElBQW1CO1FBRVZMO0lBQVRLLFFBQUFBLE9BQUFBLE9BQUFBLE9BQVNMLENBQUFBLHNCQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxDQUFBQSwrQkFBQUEsbUJBQW9CYSxRQUFRLEVBQUEsS0FBQSxPQUFBLEtBQUEsSUFBNUJiLDZCQUFnQ2MsUUFBUSxJQUM3Q0MsZUFBQUEsWUFBWSxDQUFDQyxJQUFJLEdBQ2pCRCxlQUFBQSxZQUFZLENBQUNFLE9BQU87SUFFeEIsTUFBTXZCLGlCQUFpQlUsS0FBS0MsTUFBTUUsb0JBQUFBLGtCQUFrQixDQUFDQyxpQkFBaUI7QUFDeEU7QUFhTyxTQUFTVixrQkFDZCwyQkFBMkIsR0FDM0JNLEdBQVcsRUFDWEMsSUFBeUM7SUFBekNBLElBQUFBLFNBQUFBLEtBQUFBLEdBQUFBLE9BQXFCVSxlQUFBQSxZQUFZLENBQUNFLE9BQU87SUFFekMsTUFBTXZCLGlCQUFpQlUsS0FBS0MsTUFBTUUsb0JBQUFBLGtCQUFrQixDQUFDVyxpQkFBaUI7QUFDeEU7QUFVTyxTQUFTckIsd0JBQXdCWSxLQUFjO0lBQ3BELElBQUksQ0FBQ1UsQ0FBQUEsR0FBQUEsZUFBQUEsZUFBZSxFQUFDVixRQUFRLE9BQU87SUFFcEMsd0VBQXdFO0lBQ3hFLGtCQUFrQjtJQUNsQixPQUFPQSxNQUFNRyxNQUFNLENBQUNRLEtBQUssQ0FBQyxLQUFLQyxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUdDLElBQUksQ0FBQztBQUNuRDtBQUVPLFNBQVMxQix5QkFBeUJhLEtBQW9CO0lBQzNELElBQUksQ0FBQ1UsQ0FBQUEsR0FBQUEsZUFBQUEsZUFBZSxFQUFDVixRQUFRO1FBQzNCLE1BQU0sT0FBQSxjQUFpQyxDQUFqQyxJQUFJQyxNQUFNLHlCQUFWLHFCQUFBO21CQUFBO3dCQUFBOzBCQUFBO1FBQWdDO0lBQ3hDO0lBRUEsT0FBT0QsTUFBTUcsTUFBTSxDQUFDUSxLQUFLLENBQUMsS0FBSyxFQUFFLENBQUMsRUFBRTtBQUN0QztBQUVPLFNBQVN6QiwrQkFBK0JjLEtBQW9CO0lBQ2pFLElBQUksQ0FBQ1UsQ0FBQUEsR0FBQUEsZUFBQUEsZUFBZSxFQUFDVixRQUFRO1FBQzNCLE1BQU0sT0FBQSxjQUFpQyxDQUFqQyxJQUFJQyxNQUFNLHlCQUFWLHFCQUFBO21CQUFBO3dCQUFBOzBCQUFBO1FBQWdDO0lBQ3hDO0lBRUEsT0FBT2EsT0FBT2QsTUFBTUcsTUFBTSxDQUFDUSxLQUFLLENBQUMsS0FBS0ksRUFBRSxDQUFDLENBQUM7QUFDNUMiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNDI5NiwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvY29tcG9uZW50cy9ub3QtZm91bmQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgSFRUUF9FUlJPUl9GQUxMQkFDS19FUlJPUl9DT0RFLFxuICB0eXBlIEhUVFBBY2Nlc3NGYWxsYmFja0Vycm9yLFxufSBmcm9tICcuL2h0dHAtYWNjZXNzLWZhbGxiYWNrL2h0dHAtYWNjZXNzLWZhbGxiYWNrJ1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byByZW5kZXIgdGhlIFtub3QtZm91bmQuanMgZmlsZV0oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2FwaS1yZWZlcmVuY2UvZmlsZS1jb252ZW50aW9ucy9ub3QtZm91bmQpXG4gKiB3aXRoaW4gYSByb3V0ZSBzZWdtZW50IGFzIHdlbGwgYXMgaW5qZWN0IGEgdGFnLlxuICpcbiAqIGBub3RGb3VuZCgpYCBjYW4gYmUgdXNlZCBpblxuICogW1NlcnZlciBDb21wb25lbnRzXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYnVpbGRpbmcteW91ci1hcHBsaWNhdGlvbi9yZW5kZXJpbmcvc2VydmVyLWNvbXBvbmVudHMpLFxuICogW1JvdXRlIEhhbmRsZXJzXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYnVpbGRpbmcteW91ci1hcHBsaWNhdGlvbi9yb3V0aW5nL3JvdXRlLWhhbmRsZXJzKSwgYW5kXG4gKiBbU2VydmVyIEFjdGlvbnNdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL2RhdGEtZmV0Y2hpbmcvc2VydmVyLWFjdGlvbnMtYW5kLW11dGF0aW9ucykuXG4gKlxuICogLSBJbiBhIFNlcnZlciBDb21wb25lbnQsIHRoaXMgd2lsbCBpbnNlcnQgYSBgPG1ldGEgbmFtZT1cInJvYm90c1wiIGNvbnRlbnQ9XCJub2luZGV4XCIgLz5gIG1ldGEgdGFnIGFuZCBzZXQgdGhlIHN0YXR1cyBjb2RlIHRvIDQwNC5cbiAqIC0gSW4gYSBSb3V0ZSBIYW5kbGVyIG9yIFNlcnZlciBBY3Rpb24sIGl0IHdpbGwgc2VydmUgYSA0MDQgdG8gdGhlIGNhbGxlci5cbiAqXG4gKiBSZWFkIG1vcmU6IFtOZXh0LmpzIERvY3M6IGBub3RGb3VuZGBdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9hcGktcmVmZXJlbmNlL2Z1bmN0aW9ucy9ub3QtZm91bmQpXG4gKi9cblxuY29uc3QgRElHRVNUID0gYCR7SFRUUF9FUlJPUl9GQUxMQkFDS19FUlJPUl9DT0RFfTs0MDRgXG5cbmV4cG9ydCBmdW5jdGlvbiBub3RGb3VuZCgpOiBuZXZlciB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10aHJvdy1saXRlcmFsXG4gIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKERJR0VTVCkgYXMgSFRUUEFjY2Vzc0ZhbGxiYWNrRXJyb3JcbiAgOyhlcnJvciBhcyBIVFRQQWNjZXNzRmFsbGJhY2tFcnJvcikuZGlnZXN0ID0gRElHRVNUXG5cbiAgdGhyb3cgZXJyb3Jcbn1cbiJdLCJuYW1lcyI6WyJub3RGb3VuZCIsIkRJR0VTVCIsIkhUVFBfRVJST1JfRkFMTEJBQ0tfRVJST1JfQ09ERSIsImVycm9yIiwiRXJyb3IiLCJkaWdlc3QiXSwibWFwcGluZ3MiOiI7OzsrQkFzQmdCQSxZQUFBQTs7O2VBQUFBOzs7b0NBbkJUO0FBRVA7Ozs7Ozs7Ozs7Ozs7Q0FhQyxHQUVELE1BQU1DLFNBQVUsS0FBRUMsb0JBQUFBLDhCQUE4QixHQUFDO0FBRTFDLFNBQVNGO0lBQ2QsNENBQTRDO0lBQzVDLE1BQU1HLFFBQVEsT0FBQSxjQUFpQixDQUFqQixJQUFJQyxNQUFNSCxTQUFWLHFCQUFBO2VBQUE7b0JBQUE7c0JBQUE7SUFBZ0I7SUFDNUJFLE1BQWtDRSxNQUFNLEdBQUdKO0lBRTdDLE1BQU1FO0FBQ1IiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNDM0MywgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvY29tcG9uZW50cy9mb3JiaWRkZW4udHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgSFRUUF9FUlJPUl9GQUxMQkFDS19FUlJPUl9DT0RFLFxuICB0eXBlIEhUVFBBY2Nlc3NGYWxsYmFja0Vycm9yLFxufSBmcm9tICcuL2h0dHAtYWNjZXNzLWZhbGxiYWNrL2h0dHAtYWNjZXNzLWZhbGxiYWNrJ1xuXG4vLyBUT0RPOiBBZGQgYGZvcmJpZGRlbmAgZG9jc1xuLyoqXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBUaGlzIGZ1bmN0aW9uIGFsbG93cyB5b3UgdG8gcmVuZGVyIHRoZSBbZm9yYmlkZGVuLmpzIGZpbGVdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9hcGktcmVmZXJlbmNlL2ZpbGUtY29udmVudGlvbnMvZm9yYmlkZGVuKVxuICogd2l0aGluIGEgcm91dGUgc2VnbWVudCBhcyB3ZWxsIGFzIGluamVjdCBhIHRhZy5cbiAqXG4gKiBgZm9yYmlkZGVuKClgIGNhbiBiZSB1c2VkIGluXG4gKiBbU2VydmVyIENvbXBvbmVudHNdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL3JlbmRlcmluZy9zZXJ2ZXItY29tcG9uZW50cyksXG4gKiBbUm91dGUgSGFuZGxlcnNdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL3JvdXRpbmcvcm91dGUtaGFuZGxlcnMpLCBhbmRcbiAqIFtTZXJ2ZXIgQWN0aW9uc10oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2J1aWxkaW5nLXlvdXItYXBwbGljYXRpb24vZGF0YS1mZXRjaGluZy9zZXJ2ZXItYWN0aW9ucy1hbmQtbXV0YXRpb25zKS5cbiAqXG4gKiBSZWFkIG1vcmU6IFtOZXh0LmpzIERvY3M6IGBmb3JiaWRkZW5gXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYXBpLXJlZmVyZW5jZS9mdW5jdGlvbnMvZm9yYmlkZGVuKVxuICovXG5cbmNvbnN0IERJR0VTVCA9IGAke0hUVFBfRVJST1JfRkFMTEJBQ0tfRVJST1JfQ09ERX07NDAzYFxuXG5leHBvcnQgZnVuY3Rpb24gZm9yYmlkZGVuKCk6IG5ldmVyIHtcbiAgaWYgKCFwcm9jZXNzLmVudi5fX05FWFRfRVhQRVJJTUVOVEFMX0FVVEhfSU5URVJSVVBUUykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBcXGBmb3JiaWRkZW4oKVxcYCBpcyBleHBlcmltZW50YWwgYW5kIG9ubHkgYWxsb3dlZCB0byBiZSBlbmFibGVkIHdoZW4gXFxgZXhwZXJpbWVudGFsLmF1dGhJbnRlcnJ1cHRzXFxgIGlzIGVuYWJsZWQuYFxuICAgIClcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10aHJvdy1saXRlcmFsXG4gIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKERJR0VTVCkgYXMgSFRUUEFjY2Vzc0ZhbGxiYWNrRXJyb3JcbiAgOyhlcnJvciBhcyBIVFRQQWNjZXNzRmFsbGJhY2tFcnJvcikuZGlnZXN0ID0gRElHRVNUXG4gIHRocm93IGVycm9yXG59XG4iXSwibmFtZXMiOlsiZm9yYmlkZGVuIiwiRElHRVNUIiwiSFRUUF9FUlJPUl9GQUxMQkFDS19FUlJPUl9DT0RFIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9FWFBFUklNRU5UQUxfQVVUSF9JTlRFUlJVUFRTIiwiRXJyb3IiLCJlcnJvciIsImRpZ2VzdCJdLCJtYXBwaW5ncyI6Ijs7OytCQXFCZ0JBLGFBQUFBOzs7ZUFBQUE7OztvQ0FsQlQ7QUFFUCw2QkFBNkI7QUFDN0I7Ozs7Ozs7Ozs7O0NBV0MsR0FFRCxNQUFNQyxTQUFVLEtBQUVDLG9CQUFBQSw4QkFBOEIsR0FBQztBQUUxQyxTQUFTRjtJQUNkLElBQUksQ0FBQ0csUUFBUUMsR0FBRyxDQUFDQyx1QkFBcUMsWUFBRjtRQUNsRCxNQUFNLE9BQUEsY0FFTCxDQUZLLElBQUlDLE1BQ1AsZ0hBREcscUJBQUE7bUJBQUE7d0JBQUE7MEJBQUE7UUFFTjtJQUNGO0lBRUEsNENBQTRDO0lBQzVDLE1BQU1DLFFBQVEsT0FBQSxjQUFpQixDQUFqQixJQUFJRCxNQUFNTCxTQUFWLHFCQUFBO2VBQUE7b0JBQUE7c0JBQUE7SUFBZ0I7SUFDNUJNLE1BQWtDQyxNQUFNLEdBQUdQO0lBQzdDLE1BQU1NO0FBQ1IiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNDM5NiwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvY29tcG9uZW50cy91bmF1dGhvcml6ZWQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgSFRUUF9FUlJPUl9GQUxMQkFDS19FUlJPUl9DT0RFLFxuICB0eXBlIEhUVFBBY2Nlc3NGYWxsYmFja0Vycm9yLFxufSBmcm9tICcuL2h0dHAtYWNjZXNzLWZhbGxiYWNrL2h0dHAtYWNjZXNzLWZhbGxiYWNrJ1xuXG4vLyBUT0RPOiBBZGQgYHVuYXV0aG9yaXplZGAgZG9jc1xuLyoqXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBUaGlzIGZ1bmN0aW9uIGFsbG93cyB5b3UgdG8gcmVuZGVyIHRoZSBbdW5hdXRob3JpemVkLmpzIGZpbGVdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9hcGktcmVmZXJlbmNlL2ZpbGUtY29udmVudGlvbnMvdW5hdXRob3JpemVkKVxuICogd2l0aGluIGEgcm91dGUgc2VnbWVudCBhcyB3ZWxsIGFzIGluamVjdCBhIHRhZy5cbiAqXG4gKiBgdW5hdXRob3JpemVkKClgIGNhbiBiZSB1c2VkIGluXG4gKiBbU2VydmVyIENvbXBvbmVudHNdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL3JlbmRlcmluZy9zZXJ2ZXItY29tcG9uZW50cyksXG4gKiBbUm91dGUgSGFuZGxlcnNdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL3JvdXRpbmcvcm91dGUtaGFuZGxlcnMpLCBhbmRcbiAqIFtTZXJ2ZXIgQWN0aW9uc10oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2J1aWxkaW5nLXlvdXItYXBwbGljYXRpb24vZGF0YS1mZXRjaGluZy9zZXJ2ZXItYWN0aW9ucy1hbmQtbXV0YXRpb25zKS5cbiAqXG4gKlxuICogUmVhZCBtb3JlOiBbTmV4dC5qcyBEb2NzOiBgdW5hdXRob3JpemVkYF0oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2FwaS1yZWZlcmVuY2UvZnVuY3Rpb25zL3VuYXV0aG9yaXplZClcbiAqL1xuXG5jb25zdCBESUdFU1QgPSBgJHtIVFRQX0VSUk9SX0ZBTExCQUNLX0VSUk9SX0NPREV9OzQwMWBcblxuZXhwb3J0IGZ1bmN0aW9uIHVuYXV0aG9yaXplZCgpOiBuZXZlciB7XG4gIGlmICghcHJvY2Vzcy5lbnYuX19ORVhUX0VYUEVSSU1FTlRBTF9BVVRIX0lOVEVSUlVQVFMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgXFxgdW5hdXRob3JpemVkKClcXGAgaXMgZXhwZXJpbWVudGFsIGFuZCBvbmx5IGFsbG93ZWQgdG8gYmUgdXNlZCB3aGVuIFxcYGV4cGVyaW1lbnRhbC5hdXRoSW50ZXJydXB0c1xcYCBpcyBlbmFibGVkLmBcbiAgICApXG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdGhyb3ctbGl0ZXJhbFxuICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihESUdFU1QpIGFzIEhUVFBBY2Nlc3NGYWxsYmFja0Vycm9yXG4gIDsoZXJyb3IgYXMgSFRUUEFjY2Vzc0ZhbGxiYWNrRXJyb3IpLmRpZ2VzdCA9IERJR0VTVFxuICB0aHJvdyBlcnJvclxufVxuIl0sIm5hbWVzIjpbInVuYXV0aG9yaXplZCIsIkRJR0VTVCIsIkhUVFBfRVJST1JfRkFMTEJBQ0tfRVJST1JfQ09ERSIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfRVhQRVJJTUVOVEFMX0FVVEhfSU5URVJSVVBUUyIsIkVycm9yIiwiZXJyb3IiLCJkaWdlc3QiXSwibWFwcGluZ3MiOiI7OzsrQkFzQmdCQSxnQkFBQUE7OztlQUFBQTs7O29DQW5CVDtBQUVQLGdDQUFnQztBQUNoQzs7Ozs7Ozs7Ozs7O0NBWUMsR0FFRCxNQUFNQyxTQUFVLEtBQUVDLG9CQUFBQSw4QkFBOEIsR0FBQztBQUUxQyxTQUFTRjtJQUNkLElBQUksQ0FBQ0csUUFBUUMsR0FBRyxDQUFDQyx1QkFBcUMsWUFBRjtRQUNsRCxNQUFNLE9BQUEsY0FFTCxDQUZLLElBQUlDLE1BQ1AsZ0hBREcscUJBQUE7bUJBQUE7d0JBQUE7MEJBQUE7UUFFTjtJQUNGO0lBRUEsNENBQTRDO0lBQzVDLE1BQU1DLFFBQVEsT0FBQSxjQUFpQixDQUFqQixJQUFJRCxNQUFNTCxTQUFWLHFCQUFBO2VBQUE7b0JBQUE7c0JBQUE7SUFBZ0I7SUFDNUJNLE1BQWtDQyxNQUFNLEdBQUdQO0lBQzdDLE1BQU1NO0FBQ1IiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNDQ1MCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9zZXJ2ZXIvZHluYW1pYy1yZW5kZXJpbmctdXRpbHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGlzSGFuZ2luZ1Byb21pc2VSZWplY3Rpb25FcnJvcihcbiAgZXJyOiB1bmtub3duXG4pOiBlcnIgaXMgSGFuZ2luZ1Byb21pc2VSZWplY3Rpb25FcnJvciB7XG4gIGlmICh0eXBlb2YgZXJyICE9PSAnb2JqZWN0JyB8fCBlcnIgPT09IG51bGwgfHwgISgnZGlnZXN0JyBpbiBlcnIpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gZXJyLmRpZ2VzdCA9PT0gSEFOR0lOR19QUk9NSVNFX1JFSkVDVElPTlxufVxuXG5jb25zdCBIQU5HSU5HX1BST01JU0VfUkVKRUNUSU9OID0gJ0hBTkdJTkdfUFJPTUlTRV9SRUpFQ1RJT04nXG5cbmNsYXNzIEhhbmdpbmdQcm9taXNlUmVqZWN0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIHB1YmxpYyByZWFkb25seSBkaWdlc3QgPSBIQU5HSU5HX1BST01JU0VfUkVKRUNUSU9OXG5cbiAgY29uc3RydWN0b3IocHVibGljIHJlYWRvbmx5IGV4cHJlc3Npb246IHN0cmluZykge1xuICAgIHN1cGVyKFxuICAgICAgYER1cmluZyBwcmVyZW5kZXJpbmcsICR7ZXhwcmVzc2lvbn0gcmVqZWN0cyB3aGVuIHRoZSBwcmVyZW5kZXIgaXMgY29tcGxldGUuIFR5cGljYWxseSB0aGVzZSBlcnJvcnMgYXJlIGhhbmRsZWQgYnkgUmVhY3QgYnV0IGlmIHlvdSBtb3ZlICR7ZXhwcmVzc2lvbn0gdG8gYSBkaWZmZXJlbnQgY29udGV4dCBieSB1c2luZyBcXGBzZXRUaW1lb3V0XFxgLCBcXGBhZnRlclxcYCwgb3Igc2ltaWxhciBmdW5jdGlvbnMgeW91IG1heSBvYnNlcnZlIHRoaXMgZXJyb3IgYW5kIHlvdSBzaG91bGQgaGFuZGxlIGl0IGluIHRoYXQgY29udGV4dC5gXG4gICAgKVxuICB9XG59XG5cbnR5cGUgQWJvcnRMaXN0ZW5lcnMgPSBBcnJheTwoZXJyOiB1bmtub3duKSA9PiB2b2lkPlxuY29uc3QgYWJvcnRMaXN0ZW5lcnNCeVNpZ25hbCA9IG5ldyBXZWFrTWFwPEFib3J0U2lnbmFsLCBBYm9ydExpc3RlbmVycz4oKVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gY29uc3RydWN0cyBhIHByb21pc2UgdGhhdCB3aWxsIG5ldmVyIHJlc29sdmUuIFRoaXMgaXMgcHJpbWFyaWx5XG4gKiB1c2VmdWwgZm9yIGR5bmFtaWNJTyB3aGVyZSB3ZSB1c2UgcHJvbWlzZSByZXNvbHV0aW9uIHRpbWluZyB0byBkZXRlcm1pbmUgd2hpY2hcbiAqIHBhcnRzIG9mIGEgcmVuZGVyIGNhbiBiZSBpbmNsdWRlZCBpbiBhIHByZXJlbmRlci5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VIYW5naW5nUHJvbWlzZTxUPihcbiAgc2lnbmFsOiBBYm9ydFNpZ25hbCxcbiAgZXhwcmVzc2lvbjogc3RyaW5nXG4pOiBQcm9taXNlPFQ+IHtcbiAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBIYW5naW5nUHJvbWlzZVJlamVjdGlvbkVycm9yKGV4cHJlc3Npb24pKVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGhhbmdpbmdQcm9taXNlID0gbmV3IFByb21pc2U8VD4oKF8sIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgYm91bmRSZWplY3Rpb24gPSByZWplY3QuYmluZChcbiAgICAgICAgbnVsbCxcbiAgICAgICAgbmV3IEhhbmdpbmdQcm9taXNlUmVqZWN0aW9uRXJyb3IoZXhwcmVzc2lvbilcbiAgICAgIClcbiAgICAgIGxldCBjdXJyZW50TGlzdGVuZXJzID0gYWJvcnRMaXN0ZW5lcnNCeVNpZ25hbC5nZXQoc2lnbmFsKVxuICAgICAgaWYgKGN1cnJlbnRMaXN0ZW5lcnMpIHtcbiAgICAgICAgY3VycmVudExpc3RlbmVycy5wdXNoKGJvdW5kUmVqZWN0aW9uKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gW2JvdW5kUmVqZWN0aW9uXVxuICAgICAgICBhYm9ydExpc3RlbmVyc0J5U2lnbmFsLnNldChzaWduYWwsIGxpc3RlbmVycylcbiAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgJ2Fib3J0JyxcbiAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBsaXN0ZW5lcnNbaV0oKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgeyBvbmNlOiB0cnVlIH1cbiAgICAgICAgKVxuICAgICAgfVxuICAgIH0pXG4gICAgLy8gV2UgYXJlIGZpbmUgaWYgbm8gb25lIGFjdHVhbGx5IGF3YWl0cyB0aGlzIHByb21pc2UuIFdlIHNob3VsZG4ndCBjb25zaWRlciB0aGlzIGFuIHVuaGFuZGxlZCByZWplY3Rpb24gc29cbiAgICAvLyB3ZSBhdHRhY2ggYSBub29wIGNhdGNoIGhhbmRsZXIgaGVyZSB0byBzdXBwcmVzcyB0aGlzIHdhcm5pbmcuIElmIHlvdSBhY3R1YWxseSBhd2FpdCBzb21ld2hlcmUgb3IgY29uc3RydWN0XG4gICAgLy8geW91ciBvd24gcHJvbWlzZSBvdXQgb2YgaXQgeW91J2xsIG5lZWQgdG8gZW5zdXJlIHlvdSBoYW5kbGUgdGhlIGVycm9yIHdoZW4gaXQgcmVqZWN0cy5cbiAgICBoYW5naW5nUHJvbWlzZS5jYXRjaChpZ25vcmVSZWplY3QpXG4gICAgcmV0dXJuIGhhbmdpbmdQcm9taXNlXG4gIH1cbn1cblxuZnVuY3Rpb24gaWdub3JlUmVqZWN0KCkge31cbiJdLCJuYW1lcyI6WyJpc0hhbmdpbmdQcm9taXNlUmVqZWN0aW9uRXJyb3IiLCJtYWtlSGFuZ2luZ1Byb21pc2UiLCJlcnIiLCJkaWdlc3QiLCJIQU5HSU5HX1BST01JU0VfUkVKRUNUSU9OIiwiSGFuZ2luZ1Byb21pc2VSZWplY3Rpb25FcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJleHByZXNzaW9uIiwiYWJvcnRMaXN0ZW5lcnNCeVNpZ25hbCIsIldlYWtNYXAiLCJzaWduYWwiLCJhYm9ydGVkIiwiUHJvbWlzZSIsInJlamVjdCIsImhhbmdpbmdQcm9taXNlIiwiXyIsImJvdW5kUmVqZWN0aW9uIiwiYmluZCIsImN1cnJlbnRMaXN0ZW5lcnMiLCJnZXQiLCJwdXNoIiwibGlzdGVuZXJzIiwic2V0IiwiYWRkRXZlbnRMaXN0ZW5lciIsImkiLCJsZW5ndGgiLCJvbmNlIiwiY2F0Y2giLCJpZ25vcmVSZWplY3QiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0lBQWdCQSw4QkFBOEIsRUFBQTtlQUE5QkE7O0lBZ0NBQyxrQkFBa0IsRUFBQTtlQUFsQkE7OztBQWhDVCxTQUFTRCwrQkFDZEUsR0FBWTtJQUVaLElBQUksT0FBT0EsUUFBUSxZQUFZQSxRQUFRLFFBQVEsQ0FBRSxDQUFBLFlBQVlBLEdBQUUsR0FBSTtRQUNqRSxPQUFPO0lBQ1Q7SUFFQSxPQUFPQSxJQUFJQyxNQUFNLEtBQUtDO0FBQ3hCO0FBRUEsTUFBTUEsNEJBQTRCO0FBRWxDLE1BQU1DLHFDQUFxQ0M7SUFHekNDLFlBQTRCQyxVQUFrQixDQUFFO1FBQzlDLEtBQUssQ0FDSCxDQUFDLHFCQUFxQixFQUFFQSxXQUFXLHFHQUFxRyxFQUFFQSxXQUFXLHFKQUFxSixDQUFDLEdBQUEsSUFBQSxDQUZuUkEsVUFBQUEsR0FBQUEsWUFBQUEsSUFBQUEsQ0FGWkwsTUFBQUEsR0FBU0M7SUFNekI7QUFDRjtBQUdBLE1BQU1LLHlCQUF5QixJQUFJQztBQVM1QixTQUFTVCxtQkFDZFUsTUFBbUIsRUFDbkJILFVBQWtCO0lBRWxCLElBQUlHLE9BQU9DLE9BQU8sRUFBRTtRQUNsQixPQUFPQyxRQUFRQyxNQUFNLENBQUMsSUFBSVQsNkJBQTZCRztJQUN6RCxPQUFPO1FBQ0wsTUFBTU8saUJBQWlCLElBQUlGLFFBQVcsQ0FBQ0csR0FBR0Y7WUFDeEMsTUFBTUcsaUJBQWlCSCxPQUFPSSxJQUFJLENBQ2hDLE1BQ0EsSUFBSWIsNkJBQTZCRztZQUVuQyxJQUFJVyxtQkFBbUJWLHVCQUF1QlcsR0FBRyxDQUFDVDtZQUNsRCxJQUFJUSxrQkFBa0I7Z0JBQ3BCQSxpQkFBaUJFLElBQUksQ0FBQ0o7WUFDeEIsT0FBTztnQkFDTCxNQUFNSyxZQUFZO29CQUFDTDtpQkFBZTtnQkFDbENSLHVCQUF1QmMsR0FBRyxDQUFDWixRQUFRVztnQkFDbkNYLE9BQU9hLGdCQUFnQixDQUNyQixTQUNBO29CQUNFLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJSCxVQUFVSSxNQUFNLEVBQUVELElBQUs7d0JBQ3pDSCxTQUFTLENBQUNHLEVBQUU7b0JBQ2Q7Z0JBQ0YsR0FDQTtvQkFBRUUsTUFBTTtnQkFBSztZQUVqQjtRQUNGO1FBQ0EsMkdBQTJHO1FBQzNHLDZHQUE2RztRQUM3Ryx5RkFBeUY7UUFDekZaLGVBQWVhLEtBQUssQ0FBQ0M7UUFDckIsT0FBT2Q7SUFDVDtBQUNGO0FBRUEsU0FBU2MsZ0JBQWdCIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDQ1MjEsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvc2VydmVyL2xpYi9yb3V0ZXItdXRpbHMvaXMtcG9zdHBvbmUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgUkVBQ1RfUE9TVFBPTkVfVFlQRTogc3ltYm9sID0gU3ltYm9sLmZvcigncmVhY3QucG9zdHBvbmUnKVxuXG5leHBvcnQgZnVuY3Rpb24gaXNQb3N0cG9uZShlcnJvcjogYW55KTogYm9vbGVhbiB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJlxuICAgIGVycm9yICE9PSBudWxsICYmXG4gICAgZXJyb3IuJCR0eXBlb2YgPT09IFJFQUNUX1BPU1RQT05FX1RZUEVcbiAgKVxufVxuIl0sIm5hbWVzIjpbImlzUG9zdHBvbmUiLCJSRUFDVF9QT1NUUE9ORV9UWVBFIiwiU3ltYm9sIiwiZm9yIiwiZXJyb3IiLCIkJHR5cGVvZiJdLCJtYXBwaW5ncyI6Ijs7OytCQUVnQkEsY0FBQUE7OztlQUFBQTs7O0FBRmhCLE1BQU1DLHNCQUE4QkMsT0FBT0MsR0FBRyxDQUFDO0FBRXhDLFNBQVNILFdBQVdJLEtBQVU7SUFDbkMsT0FDRSxPQUFPQSxVQUFVLFlBQ2pCQSxVQUFVLFFBQ1ZBLE1BQU1DLFFBQVEsS0FBS0o7QUFFdkIiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNDU0MCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9zaGFyZWQvbGliL2xhenktZHluYW1pYy9iYWlsb3V0LXRvLWNzci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUaGlzIGhhcyB0byBiZSBhIHNoYXJlZCBtb2R1bGUgd2hpY2ggaXMgc2hhcmVkIGJldHdlZW4gY2xpZW50IGNvbXBvbmVudCBlcnJvciBib3VuZGFyeSBhbmQgZHluYW1pYyBjb21wb25lbnRcbmNvbnN0IEJBSUxPVVRfVE9fQ1NSID0gJ0JBSUxPVVRfVE9fQ0xJRU5UX1NJREVfUkVOREVSSU5HJ1xuXG4vKiogQW4gZXJyb3IgdGhhdCBzaG91bGQgYmUgdGhyb3duIHdoZW4gd2Ugd2FudCB0byBiYWlsIG91dCB0byBjbGllbnQtc2lkZSByZW5kZXJpbmcuICovXG5leHBvcnQgY2xhc3MgQmFpbG91dFRvQ1NSRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIHB1YmxpYyByZWFkb25seSBkaWdlc3QgPSBCQUlMT1VUX1RPX0NTUlxuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyByZWFkb25seSByZWFzb246IHN0cmluZykge1xuICAgIHN1cGVyKGBCYWlsIG91dCB0byBjbGllbnQtc2lkZSByZW5kZXJpbmc6ICR7cmVhc29ufWApXG4gIH1cbn1cblxuLyoqIENoZWNrcyBpZiBhIHBhc3NlZCBhcmd1bWVudCBpcyBhbiBlcnJvciB0aGF0IGlzIHRocm93biBpZiB3ZSB3YW50IHRvIGJhaWwgb3V0IHRvIGNsaWVudC1zaWRlIHJlbmRlcmluZy4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0JhaWxvdXRUb0NTUkVycm9yKGVycjogdW5rbm93bik6IGVyciBpcyBCYWlsb3V0VG9DU1JFcnJvciB7XG4gIGlmICh0eXBlb2YgZXJyICE9PSAnb2JqZWN0JyB8fCBlcnIgPT09IG51bGwgfHwgISgnZGlnZXN0JyBpbiBlcnIpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gZXJyLmRpZ2VzdCA9PT0gQkFJTE9VVF9UT19DU1Jcbn1cbiJdLCJuYW1lcyI6WyJCYWlsb3V0VG9DU1JFcnJvciIsImlzQmFpbG91dFRvQ1NSRXJyb3IiLCJCQUlMT1VUX1RPX0NTUiIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJyZWFzb24iLCJkaWdlc3QiLCJlcnIiXSwibWFwcGluZ3MiOiJBQUFBLCtHQUErRzs7Ozs7Ozs7Ozs7Ozs7O0lBSWxHQSxpQkFBaUIsRUFBQTtlQUFqQkE7O0lBU0dDLG1CQUFtQixFQUFBO2VBQW5CQTs7O0FBWmhCLE1BQU1DLGlCQUFpQjtBQUdoQixNQUFNRiwwQkFBMEJHO0lBR3JDQyxZQUE0QkMsTUFBYyxDQUFFO1FBQzFDLEtBQUssQ0FBRSx3Q0FBcUNBLFNBQUFBLElBQUFBLENBRGxCQSxNQUFBQSxHQUFBQSxRQUFBQSxJQUFBQSxDQUZaQyxNQUFBQSxHQUFTSjtJQUl6QjtBQUNGO0FBR08sU0FBU0Qsb0JBQW9CTSxHQUFZO0lBQzlDLElBQUksT0FBT0EsUUFBUSxZQUFZQSxRQUFRLFFBQVEsQ0FBRSxDQUFBLFlBQVlBLEdBQUUsR0FBSTtRQUNqRSxPQUFPO0lBQ1Q7SUFFQSxPQUFPQSxJQUFJRCxNQUFNLEtBQUtKO0FBQ3hCIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDQ1ODAsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvY2xpZW50L2NvbXBvbmVudHMvaG9va3Mtc2VydmVyLWNvbnRleHQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgRFlOQU1JQ19FUlJPUl9DT0RFID0gJ0RZTkFNSUNfU0VSVkVSX1VTQUdFJ1xuXG5leHBvcnQgY2xhc3MgRHluYW1pY1NlcnZlckVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBkaWdlc3Q6IHR5cGVvZiBEWU5BTUlDX0VSUk9SX0NPREUgPSBEWU5BTUlDX0VSUk9SX0NPREVcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgcmVhZG9ubHkgZGVzY3JpcHRpb246IHN0cmluZykge1xuICAgIHN1cGVyKGBEeW5hbWljIHNlcnZlciB1c2FnZTogJHtkZXNjcmlwdGlvbn1gKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0R5bmFtaWNTZXJ2ZXJFcnJvcihlcnI6IHVua25vd24pOiBlcnIgaXMgRHluYW1pY1NlcnZlckVycm9yIHtcbiAgaWYgKFxuICAgIHR5cGVvZiBlcnIgIT09ICdvYmplY3QnIHx8XG4gICAgZXJyID09PSBudWxsIHx8XG4gICAgISgnZGlnZXN0JyBpbiBlcnIpIHx8XG4gICAgdHlwZW9mIGVyci5kaWdlc3QgIT09ICdzdHJpbmcnXG4gICkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIGVyci5kaWdlc3QgPT09IERZTkFNSUNfRVJST1JfQ09ERVxufVxuIl0sIm5hbWVzIjpbIkR5bmFtaWNTZXJ2ZXJFcnJvciIsImlzRHluYW1pY1NlcnZlckVycm9yIiwiRFlOQU1JQ19FUlJPUl9DT0RFIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsImRlc2NyaXB0aW9uIiwiZGlnZXN0IiwiZXJyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztJQUVhQSxrQkFBa0IsRUFBQTtlQUFsQkE7O0lBUUdDLG9CQUFvQixFQUFBO2VBQXBCQTs7O0FBVmhCLE1BQU1DLHFCQUFxQjtBQUVwQixNQUFNRiwyQkFBMkJHO0lBR3RDQyxZQUE0QkMsV0FBbUIsQ0FBRTtRQUMvQyxLQUFLLENBQUUsMkJBQXdCQSxjQUFBQSxJQUFBQSxDQURMQSxXQUFBQSxHQUFBQSxhQUFBQSxJQUFBQSxDQUY1QkMsTUFBQUEsR0FBb0NKO0lBSXBDO0FBQ0Y7QUFFTyxTQUFTRCxxQkFBcUJNLEdBQVk7SUFDL0MsSUFDRSxPQUFPQSxRQUFRLFlBQ2ZBLFFBQVEsUUFDUixDQUFFLENBQUEsWUFBWUEsR0FBRSxLQUNoQixPQUFPQSxJQUFJRCxNQUFNLEtBQUssVUFDdEI7UUFDQSxPQUFPO0lBQ1Q7SUFFQSxPQUFPQyxJQUFJRCxNQUFNLEtBQUtKO0FBQ3hCIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDQ2MjYsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvY2xpZW50L2NvbXBvbmVudHMvc3RhdGljLWdlbmVyYXRpb24tYmFpbG91dC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBORVhUX1NUQVRJQ19HRU5fQkFJTE9VVCA9ICdORVhUX1NUQVRJQ19HRU5fQkFJTE9VVCdcblxuZXhwb3J0IGNsYXNzIFN0YXRpY0dlbkJhaWxvdXRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgcHVibGljIHJlYWRvbmx5IGNvZGUgPSBORVhUX1NUQVRJQ19HRU5fQkFJTE9VVFxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNTdGF0aWNHZW5CYWlsb3V0RXJyb3IoXG4gIGVycm9yOiB1bmtub3duXG4pOiBlcnJvciBpcyBTdGF0aWNHZW5CYWlsb3V0RXJyb3Ige1xuICBpZiAodHlwZW9mIGVycm9yICE9PSAnb2JqZWN0JyB8fCBlcnJvciA9PT0gbnVsbCB8fCAhKCdjb2RlJyBpbiBlcnJvcikpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiBlcnJvci5jb2RlID09PSBORVhUX1NUQVRJQ19HRU5fQkFJTE9VVFxufVxuIl0sIm5hbWVzIjpbIlN0YXRpY0dlbkJhaWxvdXRFcnJvciIsImlzU3RhdGljR2VuQmFpbG91dEVycm9yIiwiTkVYVF9TVEFUSUNfR0VOX0JBSUxPVVQiLCJFcnJvciIsImNvZGUiLCJlcnJvciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7SUFFYUEscUJBQXFCLEVBQUE7ZUFBckJBOztJQUlHQyx1QkFBdUIsRUFBQTtlQUF2QkE7OztBQU5oQixNQUFNQywwQkFBMEI7QUFFekIsTUFBTUYsOEJBQThCRzs7UUFBcEMsS0FBQSxJQUFBLE9BQUEsSUFBQSxDQUNXQyxJQUFBQSxHQUFPRjs7QUFDekI7QUFFTyxTQUFTRCx3QkFDZEksS0FBYztJQUVkLElBQUksT0FBT0EsVUFBVSxZQUFZQSxVQUFVLFFBQVEsQ0FBRSxDQUFBLFVBQVVBLEtBQUksR0FBSTtRQUNyRSxPQUFPO0lBQ1Q7SUFFQSxPQUFPQSxNQUFNRCxJQUFJLEtBQUtGO0FBQ3hCIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDQ2NzIsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvbGliL21ldGFkYXRhL21ldGFkYXRhLWNvbnN0YW50cy50c3giXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IE1FVEFEQVRBX0JPVU5EQVJZX05BTUUgPSAnX19uZXh0X21ldGFkYXRhX2JvdW5kYXJ5X18nXG5leHBvcnQgY29uc3QgVklFV1BPUlRfQk9VTkRBUllfTkFNRSA9ICdfX25leHRfdmlld3BvcnRfYm91bmRhcnlfXydcbmV4cG9ydCBjb25zdCBPVVRMRVRfQk9VTkRBUllfTkFNRSA9ICdfX25leHRfb3V0bGV0X2JvdW5kYXJ5X18nXG4iXSwibmFtZXMiOlsiTUVUQURBVEFfQk9VTkRBUllfTkFNRSIsIk9VVExFVF9CT1VOREFSWV9OQU1FIiwiVklFV1BPUlRfQk9VTkRBUllfTkFNRSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0lBQWFBLHNCQUFzQixFQUFBO2VBQXRCQTs7SUFFQUMsb0JBQW9CLEVBQUE7ZUFBcEJBOztJQURBQyxzQkFBc0IsRUFBQTtlQUF0QkE7OztBQUROLE1BQU1GLHlCQUF5QjtBQUMvQixNQUFNRSx5QkFBeUI7QUFDL0IsTUFBTUQsdUJBQXVCIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDQ3MDYsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvbGliL3NjaGVkdWxlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgdHlwZSBTY2hlZHVsZWRGbjxUID0gdm9pZD4gPSAoKSA9PiBUIHwgUHJvbWlzZUxpa2U8VD5cbmV4cG9ydCB0eXBlIFNjaGVkdWxlckZuPFQgPSB2b2lkPiA9IChjYjogU2NoZWR1bGVkRm48VD4pID0+IHZvaWRcblxuLyoqXG4gKiBTY2hlZHVsZXMgYSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb24gdGhlIG5leHQgdGljayBhZnRlciB0aGUgb3RoZXIgcHJvbWlzZXNcbiAqIGhhdmUgYmVlbiByZXNvbHZlZC5cbiAqXG4gKiBAcGFyYW0gY2IgdGhlIGZ1bmN0aW9uIHRvIHNjaGVkdWxlXG4gKi9cbmV4cG9ydCBjb25zdCBzY2hlZHVsZU9uTmV4dFRpY2sgPSAoY2I6IFNjaGVkdWxlZEZuPHZvaWQ+KSA9PiB7XG4gIC8vIFdlIHVzZSBQcm9taXNlLnJlc29sdmUoKS50aGVuKCkgaGVyZSBzbyB0aGF0IHRoZSBvcGVyYXRpb24gaXMgc2NoZWR1bGVkIGF0XG4gIC8vIHRoZSBlbmQgb2YgdGhlIHByb21pc2Ugam9iIHF1ZXVlLCB3ZSB0aGVuIGFkZCBpdCB0byB0aGUgbmV4dCBwcm9jZXNzIHRpY2tcbiAgLy8gdG8gZW5zdXJlIGl0J3MgZXZhbHVhdGVkIGFmdGVyd2FyZHMuXG4gIC8vXG4gIC8vIFRoaXMgd2FzIGluc3BpcmVkIGJ5IHRoZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgRGF0YUxvYWRlciBpbnRlcmZhY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9ncmFwaHFsL2RhdGFsb2FkZXIvYmxvYi9kMzM2YmQxNTI4MjY2NGUwYmU0YjRhNjU3Y2I3OTZmMDliYWZiYzZiL3NyYy9pbmRleC5qcyNMMjEzLUwyNTVcbiAgLy9cbiAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5FWFRfUlVOVElNRSA9PT0gJ2VkZ2UnKSB7XG4gICAgICBzZXRUaW1lb3V0KGNiLCAwKVxuICAgIH0gZWxzZSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGNiKVxuICAgIH1cbiAgfSlcbn1cblxuLyoqXG4gKiBTY2hlZHVsZXMgYSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgdXNpbmcgYHNldEltbWVkaWF0ZWAgb3IgYHNldFRpbWVvdXRgIGlmXG4gKiBgc2V0SW1tZWRpYXRlYCBpcyBub3QgYXZhaWxhYmxlIChsaWtlIGluIHRoZSBFZGdlIHJ1bnRpbWUpLlxuICpcbiAqIEBwYXJhbSBjYiB0aGUgZnVuY3Rpb24gdG8gc2NoZWR1bGVcbiAqL1xuZXhwb3J0IGNvbnN0IHNjaGVkdWxlSW1tZWRpYXRlID0gKGNiOiBTY2hlZHVsZWRGbjx2b2lkPik6IHZvaWQgPT4ge1xuICBpZiAocHJvY2Vzcy5lbnYuTkVYVF9SVU5USU1FID09PSAnZWRnZScpIHtcbiAgICBzZXRUaW1lb3V0KGNiLCAwKVxuICB9IGVsc2Uge1xuICAgIHNldEltbWVkaWF0ZShjYilcbiAgfVxufVxuXG4vKipcbiAqIHJldHVybnMgYSBwcm9taXNlIHRoYW4gcmVzb2x2ZXMgaW4gYSBmdXR1cmUgdGFzay4gVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgdGhlIHRhc2sgaXQgcmVzb2x2ZXMgaW5cbiAqIHdpbGwgYmUgdGhlIG5leHQgdGFzayBidXQgaWYgeW91IGF3YWl0IGl0IHlvdSBjYW4gYXQgbGVhc3QgYmUgc3VyZSB0aGF0IHRoZSBjdXJyZW50IHRhc2sgaXMgb3ZlciBhbmRcbiAqIG1vc3QgdXNlZnVsbHkgdGhhdCB0aGUgZW50aXJlIG1pY3JvdGFzayBxdWV1ZSBvZiB0aGUgY3VycmVudCB0YXNrIGhhcyBiZWVuIGVtcHRpZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhdExlYXN0T25lVGFzaygpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlKSA9PiBzY2hlZHVsZUltbWVkaWF0ZShyZXNvbHZlKSlcbn1cblxuLyoqXG4gKiBUaGlzIHV0aWxpdHkgZnVuY3Rpb24gaXMgZXh0cmFjdGVkIHRvIG1ha2UgaXQgZWFzaWVyIHRvIGZpbmQgcGxhY2VzIHdoZXJlIHdlIGFyZSBkb2luZ1xuICogc3BlY2lmaWMgdGltaW5nIHRyaWNrcyB0byB0cnkgdG8gc2NoZWR1bGUgd29yayBhZnRlciBSZWFjdCBoYXMgcmVuZGVyZWQuIFRoaXMgaXMgZXNwZWNpYWxseVxuICogaW1wb3J0YW50IGF0IHRoZSBtb21lbnQgYmVjYXVzZSBOZXh0LmpzIHVzZXMgdGhlIGVkZ2UgYnVpbGRzIG9mIFJlYWN0IHdoaWNoIHVzZSBzZXRUaW1lb3V0IHRvXG4gKiBzY2hlZHVsZSB3b3JrIHdoZW4geW91IG1pZ2h0IGV4cGVjdCB0aGF0IHNvbWV0aGluZyBsaWtlIHNldEltbWVkaWF0ZSB3b3VsZCBkbyB0aGUgdHJpY2suXG4gKlxuICogTG9uZyB0ZXJtIHdlIHNob3VsZCBzd2l0Y2ggdG8gdGhlIG5vZGUgdmVyc2lvbnMgb2YgUmVhY3QgcmVuZGVyaW5nIHdoZW4gcG9zc2libGUgYW5kIHRoZW5cbiAqIHVwZGF0ZSB0aGlzIHRvIHVzZSBzZXRJbW1lZGlhdGUgcmF0aGVyIHRoYW4gc2V0VGltZW91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gd2FpdEF0TGVhc3RPbmVSZWFjdFJlbmRlclRhc2soKTogUHJvbWlzZTx2b2lkPiB7XG4gIGlmIChwcm9jZXNzLmVudi5ORVhUX1JVTlRJTUUgPT09ICdlZGdlJykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocikgPT4gc2V0VGltZW91dChyLCAwKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHIpID0+IHNldEltbWVkaWF0ZShyKSlcbiAgfVxufVxuIl0sIm5hbWVzIjpbImF0TGVhc3RPbmVUYXNrIiwic2NoZWR1bGVJbW1lZGlhdGUiLCJzY2hlZHVsZU9uTmV4dFRpY2siLCJ3YWl0QXRMZWFzdE9uZVJlYWN0UmVuZGVyVGFzayIsImNiIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUlVOVElNRSIsInNldFRpbWVvdXQiLCJuZXh0VGljayIsInNldEltbWVkaWF0ZSIsInIiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7SUE0Q2dCQSxjQUFjLEVBQUE7ZUFBZEE7O0lBYkhDLGlCQUFpQixFQUFBO2VBQWpCQTs7SUF0QkFDLGtCQUFrQixFQUFBO2VBQWxCQTs7SUFnREdDLDZCQUE2QixFQUFBO2VBQTdCQTs7O0FBaERULE1BQU1ELHFCQUFxQixDQUFDRTtJQUNqQyw2RUFBNkU7SUFDN0UsNEVBQTRFO0lBQzVFLHVDQUF1QztJQUN2QyxFQUFFO0lBQ0Ysa0xBQWtMO0lBQ2xMLEVBQUU7SUFDRkMsUUFBUUMsT0FBTyxHQUFHQyxJQUFJLENBQUM7UUFDckIsSUFBSUMsUUFBUUMsR0FBRyxDQUFDQyxZQUFZLEtBQUssUUFBUTs7YUFFbEM7WUFDTEYsUUFBUUksUUFBUSxDQUFDUjtRQUNuQjtJQUNGO0FBQ0Y7QUFRTyxNQUFNSCxvQkFBb0IsQ0FBQ0c7SUFDaEMsSUFBSUksUUFBUUMsR0FBRyxDQUFDQyxZQUFZLEtBQUssUUFBUTs7U0FFbEM7UUFDTEcsYUFBYVQ7SUFDZjtBQUNGO0FBT08sU0FBU0o7SUFDZCxPQUFPLElBQUlLLFFBQWMsQ0FBQ0MsVUFBWUwsa0JBQWtCSztBQUMxRDtBQVdPLFNBQVNIO0lBQ2QsSUFBSUssUUFBUUMsR0FBRyxDQUFDQyxZQUFZLEtBQUssUUFBUTs7U0FFbEM7UUFDTCxPQUFPLElBQUlMLFFBQVEsQ0FBQ1MsSUFBTUQsYUFBYUM7SUFDekM7QUFDRiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA0NzczLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL3NlcnZlci9hcHAtcmVuZGVyL2R5bmFtaWMtcmVuZGVyaW5nLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGhlIGZ1bmN0aW9ucyBwcm92aWRlZCBieSB0aGlzIG1vZHVsZSBhcmUgdXNlZCB0byBjb21tdW5pY2F0ZSBjZXJ0YWluIHByb3BlcnRpZXNcbiAqIGFib3V0IHRoZSBjdXJyZW50bHkgcnVubmluZyBjb2RlIHNvIHRoYXQgTmV4dC5qcyBjYW4gbWFrZSBkZWNpc2lvbnMgb24gaG93IHRvIGhhbmRsZVxuICogdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGluIGRpZmZlcmVudCByZW5kZXJpbmcgbW9kZXMgc3VjaCBhcyBwcmUtcmVuZGVyaW5nLCByZXN1bWluZywgYW5kIFNTUi5cbiAqXG4gKiBUb2RheSBOZXh0LmpzIHRyZWF0cyBhbGwgY29kZSBhcyBwb3RlbnRpYWxseSBzdGF0aWMuIENlcnRhaW4gQVBJcyBtYXkgb25seSBtYWtlIHNlbnNlIHdoZW4gZHluYW1pY2FsbHkgcmVuZGVyaW5nLlxuICogVHJhZGl0aW9uYWxseSB0aGlzIG1lYW50IGRlb3B0aW5nIHRoZSBlbnRpcmUgcmVuZGVyIHRvIGR5bmFtaWMgaG93ZXZlciB3aXRoIFBQUiB3ZSBjYW4gbm93IGRlb3B0IHBhcnRzXG4gKiBvZiBhIFJlYWN0IHRyZWUgYXMgZHluYW1pYyB3aGlsZSBzdGlsbCBrZWVwaW5nIG90aGVyIHBhcnRzIHN0YXRpYy4gVGhlcmUgYXJlIHJlYWxseSB0d28gZGlmZmVyZW50IGtpbmRzIG9mXG4gKiBEeW5hbWljIGluZGljYXRpb25zLlxuICpcbiAqIFRoZSBmaXJzdCBpcyBzaW1wbHkgYW4gaW50ZW50aW9uIHRvIGJlIGR5bmFtaWMuIHVuc3RhYmxlX25vU3RvcmUgaXMgYW4gZXhhbXBsZSBvZiB0aGlzIHdoZXJlXG4gKiB0aGUgY3VycmVudGx5IGV4ZWN1dGluZyBjb2RlIHNpbXBseSBkZWNsYXJlcyB0aGF0IHRoZSBjdXJyZW50IHNjb3BlIGlzIGR5bmFtaWMgYnV0IGlmIHlvdSB1c2UgaXRcbiAqIGluc2lkZSB1bnN0YWJsZV9jYWNoZSBpdCBjYW4gc3RpbGwgYmUgY2FjaGVkLiBUaGlzIHR5cGUgb2YgaW5kaWNhdGlvbiBjYW4gYmUgcmVtb3ZlZCBpZiB3ZSBldmVyXG4gKiBtYWtlIHRoZSBkZWZhdWx0IGR5bmFtaWMgdG8gYmVnaW4gd2l0aCBiZWNhdXNlIHRoZSBvbmx5IHdheSB5b3Ugd291bGQgZXZlciBiZSBzdGF0aWMgaXMgaW5zaWRlXG4gKiBhIGNhY2hlIHNjb3BlIHdoaWNoIHRoaXMgaW5kaWNhdGlvbiBkb2VzIG5vdCBhZmZlY3QuXG4gKlxuICogVGhlIHNlY29uZCBpcyBhbiBpbmRpY2F0aW9uIHRoYXQgYSBkeW5hbWljIGRhdGEgc291cmNlIHdhcyByZWFkLiBUaGlzIGlzIGEgc3Ryb25nZXIgZm9ybSBvZiBkeW5hbWljXG4gKiBiZWNhdXNlIGl0IG1lYW5zIHRoYXQgaXQgaXMgaW5hcHByb3ByaWF0ZSB0byBjYWNoZSB0aGlzIGF0IGFsbC4gdXNpbmcgYSBkeW5hbWljIGRhdGEgc291cmNlIGluc2lkZVxuICogdW5zdGFibGVfY2FjaGUgc2hvdWxkIGVycm9yLiBJZiB5b3Ugd2FudCB0byB1c2Ugc29tZSBkeW5hbWljIGRhdGEgaW5zaWRlIHVuc3RhYmxlX2NhY2hlIHlvdSBzaG91bGRcbiAqIHJlYWQgdGhhdCBkYXRhIG91dHNpZGUgdGhlIGNhY2hlIGFuZCBwYXNzIGl0IGluIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSBjYWNoZWQgZnVuY3Rpb24uXG4gKi9cblxuaW1wb3J0IHR5cGUgeyBXb3JrU3RvcmUgfSBmcm9tICcuLi9hcHAtcmVuZGVyL3dvcmstYXN5bmMtc3RvcmFnZS5leHRlcm5hbCdcbmltcG9ydCB0eXBlIHtcbiAgV29ya1VuaXRTdG9yZSxcbiAgUmVxdWVzdFN0b3JlLFxuICBQcmVyZW5kZXJTdG9yZUxlZ2FjeSxcbiAgUHJlcmVuZGVyU3RvcmVNb2Rlcm4sXG59IGZyb20gJy4uL2FwcC1yZW5kZXIvd29yay11bml0LWFzeW5jLXN0b3JhZ2UuZXh0ZXJuYWwnXG5cbi8vIE9uY2UgcG9zdHBvbmUgaXMgaW4gc3RhYmxlIHdlIHNob3VsZCBzd2l0Y2ggdG8gaW1wb3J0aW5nIHRoZSBwb3N0cG9uZSBleHBvcnQgZGlyZWN0bHlcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcblxuaW1wb3J0IHsgRHluYW1pY1NlcnZlckVycm9yIH0gZnJvbSAnLi4vLi4vY2xpZW50L2NvbXBvbmVudHMvaG9va3Mtc2VydmVyLWNvbnRleHQnXG5pbXBvcnQgeyBTdGF0aWNHZW5CYWlsb3V0RXJyb3IgfSBmcm9tICcuLi8uLi9jbGllbnQvY29tcG9uZW50cy9zdGF0aWMtZ2VuZXJhdGlvbi1iYWlsb3V0J1xuaW1wb3J0IHsgd29ya1VuaXRBc3luY1N0b3JhZ2UgfSBmcm9tICcuL3dvcmstdW5pdC1hc3luYy1zdG9yYWdlLmV4dGVybmFsJ1xuaW1wb3J0IHsgd29ya0FzeW5jU3RvcmFnZSB9IGZyb20gJy4uL2FwcC1yZW5kZXIvd29yay1hc3luYy1zdG9yYWdlLmV4dGVybmFsJ1xuaW1wb3J0IHsgbWFrZUhhbmdpbmdQcm9taXNlIH0gZnJvbSAnLi4vZHluYW1pYy1yZW5kZXJpbmctdXRpbHMnXG5pbXBvcnQge1xuICBNRVRBREFUQV9CT1VOREFSWV9OQU1FLFxuICBWSUVXUE9SVF9CT1VOREFSWV9OQU1FLFxuICBPVVRMRVRfQk9VTkRBUllfTkFNRSxcbn0gZnJvbSAnLi4vLi4vbGliL21ldGFkYXRhL21ldGFkYXRhLWNvbnN0YW50cydcbmltcG9ydCB7IHNjaGVkdWxlT25OZXh0VGljayB9IGZyb20gJy4uLy4uL2xpYi9zY2hlZHVsZXInXG5cbmNvbnN0IGhhc1Bvc3Rwb25lID0gdHlwZW9mIFJlYWN0LnVuc3RhYmxlX3Bvc3Rwb25lID09PSAnZnVuY3Rpb24nXG5cbmV4cG9ydCB0eXBlIER5bmFtaWNBY2Nlc3MgPSB7XG4gIC8qKlxuICAgKiBJZiBkZWJ1Z2dpbmcsIHRoaXMgd2lsbCBjb250YWluIHRoZSBzdGFjayB0cmFjZSBvZiB3aGVyZSB0aGUgZHluYW1pYyBhY2Nlc3NcbiAgICogb2NjdXJyZWQuIFRoaXMgaXMgdXNlZCB0byBwcm92aWRlIG1vcmUgaW5mb3JtYXRpb24gdG8gdGhlIHVzZXIgYWJvdXQgd2h5XG4gICAqIHRoZWlyIHBhZ2UgaXMgYmVpbmcgcmVuZGVyZWQgZHluYW1pY2FsbHkuXG4gICAqL1xuICBzdGFjaz86IHN0cmluZ1xuXG4gIC8qKlxuICAgKiBUaGUgZXhwcmVzc2lvbiB0aGF0IHdhcyBhY2Nlc3NlZCBkeW5hbWljYWxseS5cbiAgICovXG4gIGV4cHJlc3Npb246IHN0cmluZ1xufVxuXG4vLyBTdG9yZXMgZHluYW1pYyByZWFzb25zIHVzZWQgZHVyaW5nIGFuIFJTQyByZW5kZXIuXG5leHBvcnQgdHlwZSBEeW5hbWljVHJhY2tpbmdTdGF0ZSA9IHtcbiAgLyoqXG4gICAqIFdoZW4gdHJ1ZSwgc3RhY2sgaW5mb3JtYXRpb24gd2lsbCBhbHNvIGJlIHRyYWNrZWQgZHVyaW5nIGR5bmFtaWMgYWNjZXNzLlxuICAgKi9cbiAgcmVhZG9ubHkgaXNEZWJ1Z0R5bmFtaWNBY2Nlc3NlczogYm9vbGVhbiB8IHVuZGVmaW5lZFxuXG4gIC8qKlxuICAgKiBUaGUgZHluYW1pYyBhY2Nlc3NlcyB0aGF0IG9jY3VycmVkIGR1cmluZyB0aGUgcmVuZGVyLlxuICAgKi9cbiAgcmVhZG9ubHkgZHluYW1pY0FjY2Vzc2VzOiBBcnJheTxEeW5hbWljQWNjZXNzPlxuXG4gIHN5bmNEeW5hbWljRXJyb3JXaXRoU3RhY2s6IG51bGwgfCBFcnJvclxufVxuXG4vLyBTdG9yZXMgZHluYW1pYyByZWFzb25zIHVzZWQgZHVyaW5nIGFuIFNTUiByZW5kZXIuXG5leHBvcnQgdHlwZSBEeW5hbWljVmFsaWRhdGlvblN0YXRlID0ge1xuICBoYXNTdXNwZW5zZUFib3ZlQm9keTogYm9vbGVhblxuICBoYXNEeW5hbWljTWV0YWRhdGE6IGJvb2xlYW5cbiAgaGFzRHluYW1pY1ZpZXdwb3J0OiBib29sZWFuXG4gIGhhc0FsbG93ZWREeW5hbWljOiBib29sZWFuXG4gIGR5bmFtaWNFcnJvcnM6IEFycmF5PEVycm9yPlxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRHluYW1pY1RyYWNraW5nU3RhdGUoXG4gIGlzRGVidWdEeW5hbWljQWNjZXNzZXM6IGJvb2xlYW4gfCB1bmRlZmluZWRcbik6IER5bmFtaWNUcmFja2luZ1N0YXRlIHtcbiAgcmV0dXJuIHtcbiAgICBpc0RlYnVnRHluYW1pY0FjY2Vzc2VzLFxuICAgIGR5bmFtaWNBY2Nlc3NlczogW10sXG4gICAgc3luY0R5bmFtaWNFcnJvcldpdGhTdGFjazogbnVsbCxcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRHluYW1pY1ZhbGlkYXRpb25TdGF0ZSgpOiBEeW5hbWljVmFsaWRhdGlvblN0YXRlIHtcbiAgcmV0dXJuIHtcbiAgICBoYXNTdXNwZW5zZUFib3ZlQm9keTogZmFsc2UsXG4gICAgaGFzRHluYW1pY01ldGFkYXRhOiBmYWxzZSxcbiAgICBoYXNEeW5hbWljVmlld3BvcnQ6IGZhbHNlLFxuICAgIGhhc0FsbG93ZWREeW5hbWljOiBmYWxzZSxcbiAgICBkeW5hbWljRXJyb3JzOiBbXSxcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Rmlyc3REeW5hbWljUmVhc29uKFxuICB0cmFja2luZ1N0YXRlOiBEeW5hbWljVHJhY2tpbmdTdGF0ZVxuKTogdW5kZWZpbmVkIHwgc3RyaW5nIHtcbiAgcmV0dXJuIHRyYWNraW5nU3RhdGUuZHluYW1pY0FjY2Vzc2VzWzBdPy5leHByZXNzaW9uXG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBjb21tdW5pY2F0ZXMgdGhhdCB0aGUgY3VycmVudCBzY29wZSBzaG91bGQgYmUgdHJlYXRlZCBhcyBkeW5hbWljLlxuICpcbiAqIEluIG1vc3QgY2FzZXMgdGhpcyBmdW5jdGlvbiBpcyBhIG5vLW9wIGJ1dCBpZiBjYWxsZWQgZHVyaW5nXG4gKiBhIFBQUiBwcmVyZW5kZXIgaXQgd2lsbCBwb3N0cG9uZSB0aGUgY3VycmVudCBzdWItdHJlZSBhbmQgY2FsbGluZ1xuICogaXQgZHVyaW5nIGEgbm9ybWFsIHByZXJlbmRlciB3aWxsIGNhdXNlIHRoZSBlbnRpcmUgcHJlcmVuZGVyIHRvIGFib3J0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXJrQ3VycmVudFNjb3BlQXNEeW5hbWljKFxuICBzdG9yZTogV29ya1N0b3JlLFxuICB3b3JrVW5pdFN0b3JlOiB1bmRlZmluZWQgfCBFeGNsdWRlPFdvcmtVbml0U3RvcmUsIFByZXJlbmRlclN0b3JlTW9kZXJuPixcbiAgZXhwcmVzc2lvbjogc3RyaW5nXG4pOiB2b2lkIHtcbiAgaWYgKHdvcmtVbml0U3RvcmUpIHtcbiAgICBpZiAoXG4gICAgICB3b3JrVW5pdFN0b3JlLnR5cGUgPT09ICdjYWNoZScgfHxcbiAgICAgIHdvcmtVbml0U3RvcmUudHlwZSA9PT0gJ3Vuc3RhYmxlLWNhY2hlJ1xuICAgICkge1xuICAgICAgLy8gaW5zaWRlIGNhY2hlIHNjb3BlcyBtYXJraW5nIGEgc2NvcGUgYXMgZHluYW1pYyBoYXMgbm8gZWZmZWN0IGJlY2F1c2UgdGhlIG91dGVyIGNhY2hlIHNjb3BlXG4gICAgICAvLyBjcmVhdGVzIGEgY2FjaGUgYm91bmRhcnkuIFRoaXMgaXMgc3VidGx5IGRpZmZlcmVudCBmcm9tIHJlYWRpbmcgYSBkeW5hbWljIGRhdGEgc291cmNlIHdoaWNoIGlzXG4gICAgICAvLyBmb3JiaWRkZW4gaW5zaWRlIGEgY2FjaGUgc2NvcGUuXG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cblxuICAvLyBJZiB3ZSdyZSBmb3JjaW5nIGR5bmFtaWMgcmVuZGVyaW5nIG9yIHdlJ3JlIGZvcmNpbmcgc3RhdGljIHJlbmRlcmluZywgd2VcbiAgLy8gZG9uJ3QgbmVlZCB0byBkbyBhbnl0aGluZyBoZXJlIGJlY2F1c2UgdGhlIGVudGlyZSBwYWdlIGlzIGFscmVhZHkgZHluYW1pY1xuICAvLyBvciBpdCdzIHN0YXRpYyBhbmQgaXQgc2hvdWxkIG5vdCB0aHJvdyBvciBwb3N0cG9uZSBoZXJlLlxuICBpZiAoc3RvcmUuZm9yY2VEeW5hbWljIHx8IHN0b3JlLmZvcmNlU3RhdGljKSByZXR1cm5cblxuICBpZiAoc3RvcmUuZHluYW1pY1Nob3VsZEVycm9yKSB7XG4gICAgdGhyb3cgbmV3IFN0YXRpY0dlbkJhaWxvdXRFcnJvcihcbiAgICAgIGBSb3V0ZSAke3N0b3JlLnJvdXRlfSB3aXRoIFxcYGR5bmFtaWMgPSBcImVycm9yXCJcXGAgY291bGRuJ3QgYmUgcmVuZGVyZWQgc3RhdGljYWxseSBiZWNhdXNlIGl0IHVzZWQgXFxgJHtleHByZXNzaW9ufVxcYC4gU2VlIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYnVpbGRpbmcteW91ci1hcHBsaWNhdGlvbi9yZW5kZXJpbmcvc3RhdGljLWFuZC1keW5hbWljI2R5bmFtaWMtcmVuZGVyaW5nYFxuICAgIClcbiAgfVxuXG4gIGlmICh3b3JrVW5pdFN0b3JlKSB7XG4gICAgaWYgKHdvcmtVbml0U3RvcmUudHlwZSA9PT0gJ3ByZXJlbmRlci1wcHInKSB7XG4gICAgICBwb3N0cG9uZVdpdGhUcmFja2luZyhcbiAgICAgICAgc3RvcmUucm91dGUsXG4gICAgICAgIGV4cHJlc3Npb24sXG4gICAgICAgIHdvcmtVbml0U3RvcmUuZHluYW1pY1RyYWNraW5nXG4gICAgICApXG4gICAgfSBlbHNlIGlmICh3b3JrVW5pdFN0b3JlLnR5cGUgPT09ICdwcmVyZW5kZXItbGVnYWN5Jykge1xuICAgICAgd29ya1VuaXRTdG9yZS5yZXZhbGlkYXRlID0gMFxuXG4gICAgICAvLyBXZSBhcmVuJ3QgcHJlcmVuZGVyaW5nIGJ1dCB3ZSBhcmUgZ2VuZXJhdGluZyBhIHN0YXRpYyBwYWdlLiBXZSBuZWVkIHRvIGJhaWwgb3V0IG9mIHN0YXRpYyBnZW5lcmF0aW9uXG4gICAgICBjb25zdCBlcnIgPSBuZXcgRHluYW1pY1NlcnZlckVycm9yKFxuICAgICAgICBgUm91dGUgJHtzdG9yZS5yb3V0ZX0gY291bGRuJ3QgYmUgcmVuZGVyZWQgc3RhdGljYWxseSBiZWNhdXNlIGl0IHVzZWQgJHtleHByZXNzaW9ufS4gU2VlIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9keW5hbWljLXNlcnZlci1lcnJvcmBcbiAgICAgIClcbiAgICAgIHN0b3JlLmR5bmFtaWNVc2FnZURlc2NyaXB0aW9uID0gZXhwcmVzc2lvblxuICAgICAgc3RvcmUuZHluYW1pY1VzYWdlU3RhY2sgPSBlcnIuc3RhY2tcblxuICAgICAgdGhyb3cgZXJyXG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmXG4gICAgICB3b3JrVW5pdFN0b3JlICYmXG4gICAgICB3b3JrVW5pdFN0b3JlLnR5cGUgPT09ICdyZXF1ZXN0J1xuICAgICkge1xuICAgICAgd29ya1VuaXRTdG9yZS51c2VkRHluYW1pYyA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGNvbW11bmljYXRlcyB0aGF0IHNvbWUgZHluYW1pYyBwYXRoIHBhcmFtZXRlciB3YXMgcmVhZC4gVGhpc1xuICogZGlmZmVycyBmcm9tIHRoZSBtb3JlIGdlbmVyYWwgYHRyYWNrRHluYW1pY0RhdGFBY2Nlc3NlZGAgaW4gdGhhdCBpdCBpcyB3aWxsXG4gKiBub3QgZXJyb3Igd2hlbiBgZHluYW1pYyA9IFwiZXJyb3JcImAgaXMgc2V0LlxuICpcbiAqIEBwYXJhbSBzdG9yZSBUaGUgc3RhdGljIGdlbmVyYXRpb24gc3RvcmVcbiAqIEBwYXJhbSBleHByZXNzaW9uIFRoZSBleHByZXNzaW9uIHRoYXQgd2FzIGFjY2Vzc2VkIGR5bmFtaWNhbGx5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFja0ZhbGxiYWNrUGFyYW1BY2Nlc3NlZChcbiAgc3RvcmU6IFdvcmtTdG9yZSxcbiAgZXhwcmVzc2lvbjogc3RyaW5nXG4pOiB2b2lkIHtcbiAgY29uc3QgcHJlcmVuZGVyU3RvcmUgPSB3b3JrVW5pdEFzeW5jU3RvcmFnZS5nZXRTdG9yZSgpXG4gIGlmICghcHJlcmVuZGVyU3RvcmUgfHwgcHJlcmVuZGVyU3RvcmUudHlwZSAhPT0gJ3ByZXJlbmRlci1wcHInKSByZXR1cm5cblxuICBwb3N0cG9uZVdpdGhUcmFja2luZyhzdG9yZS5yb3V0ZSwgZXhwcmVzc2lvbiwgcHJlcmVuZGVyU3RvcmUuZHluYW1pY1RyYWNraW5nKVxufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbWVhbnQgdG8gYmUgdXNlZCB3aGVuIHByZXJlbmRlcmluZyB3aXRob3V0IGR5bmFtaWNJTyBvciBQUFIuXG4gKiBXaGVuIGNhbGxlZCBkdXJpbmcgYSBidWlsZCBpdCB3aWxsIGNhdXNlIE5leHQuanMgdG8gY29uc2lkZXIgdGhlIHJvdXRlIGFzIGR5bmFtaWMuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0aHJvd1RvSW50ZXJydXB0U3RhdGljR2VuZXJhdGlvbihcbiAgZXhwcmVzc2lvbjogc3RyaW5nLFxuICBzdG9yZTogV29ya1N0b3JlLFxuICBwcmVyZW5kZXJTdG9yZTogUHJlcmVuZGVyU3RvcmVMZWdhY3lcbik6IG5ldmVyIHtcbiAgLy8gV2UgYXJlbid0IHByZXJlbmRlcmluZyBidXQgd2UgYXJlIGdlbmVyYXRpbmcgYSBzdGF0aWMgcGFnZS4gV2UgbmVlZCB0byBiYWlsIG91dCBvZiBzdGF0aWMgZ2VuZXJhdGlvblxuICBjb25zdCBlcnIgPSBuZXcgRHluYW1pY1NlcnZlckVycm9yKFxuICAgIGBSb3V0ZSAke3N0b3JlLnJvdXRlfSBjb3VsZG4ndCBiZSByZW5kZXJlZCBzdGF0aWNhbGx5IGJlY2F1c2UgaXQgdXNlZCBcXGAke2V4cHJlc3Npb259XFxgLiBTZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2R5bmFtaWMtc2VydmVyLWVycm9yYFxuICApXG5cbiAgcHJlcmVuZGVyU3RvcmUucmV2YWxpZGF0ZSA9IDBcblxuICBzdG9yZS5keW5hbWljVXNhZ2VEZXNjcmlwdGlvbiA9IGV4cHJlc3Npb25cbiAgc3RvcmUuZHluYW1pY1VzYWdlU3RhY2sgPSBlcnIuc3RhY2tcblxuICB0aHJvdyBlcnJcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBiZSB1c2VkIHRvIHRyYWNrIHdoZXRoZXIgc29tZXRoaW5nIGR5bmFtaWMgaGFwcGVuZWQgZXZlbiB3aGVuXG4gKiB3ZSBhcmUgaW4gYSBkeW5hbWljIHJlbmRlci4gVGhpcyBpcyB1c2VmdWwgZm9yIERldiB3aGVyZSBhbGwgcmVuZGVycyBhcmUgZHluYW1pYyBidXRcbiAqIHdlIHN0aWxsIHRyYWNrIHdoZXRoZXIgZHluYW1pYyBBUElzIHdlcmUgYWNjZXNzZWQgZm9yIGhlbHBmdWwgbWVzc2FnaW5nXG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFja0R5bmFtaWNEYXRhSW5EeW5hbWljUmVuZGVyKFxuICBfc3RvcmU6IFdvcmtTdG9yZSxcbiAgd29ya1VuaXRTdG9yZTogdm9pZCB8IFdvcmtVbml0U3RvcmVcbikge1xuICBpZiAod29ya1VuaXRTdG9yZSkge1xuICAgIGlmIChcbiAgICAgIHdvcmtVbml0U3RvcmUudHlwZSA9PT0gJ2NhY2hlJyB8fFxuICAgICAgd29ya1VuaXRTdG9yZS50eXBlID09PSAndW5zdGFibGUtY2FjaGUnXG4gICAgKSB7XG4gICAgICAvLyBpbnNpZGUgY2FjaGUgc2NvcGVzIG1hcmtpbmcgYSBzY29wZSBhcyBkeW5hbWljIGhhcyBubyBlZmZlY3QgYmVjYXVzZSB0aGUgb3V0ZXIgY2FjaGUgc2NvcGVcbiAgICAgIC8vIGNyZWF0ZXMgYSBjYWNoZSBib3VuZGFyeS4gVGhpcyBpcyBzdWJ0bHkgZGlmZmVyZW50IGZyb20gcmVhZGluZyBhIGR5bmFtaWMgZGF0YSBzb3VyY2Ugd2hpY2ggaXNcbiAgICAgIC8vIGZvcmJpZGRlbiBpbnNpZGUgYSBjYWNoZSBzY29wZS5cbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyBUT0RPOiBpdCBtYWtlcyBubyBzZW5zZSB0byBoYXZlIHRoZXNlIHdvcmsgdW5pdCBzdG9yZSB0eXBlcyBkdXJpbmcgYSBkZXYgcmVuZGVyLlxuICAgIGlmIChcbiAgICAgIHdvcmtVbml0U3RvcmUudHlwZSA9PT0gJ3ByZXJlbmRlcicgfHxcbiAgICAgIHdvcmtVbml0U3RvcmUudHlwZSA9PT0gJ3ByZXJlbmRlci1jbGllbnQnIHx8XG4gICAgICB3b3JrVW5pdFN0b3JlLnR5cGUgPT09ICdwcmVyZW5kZXItbGVnYWN5J1xuICAgICkge1xuICAgICAgd29ya1VuaXRTdG9yZS5yZXZhbGlkYXRlID0gMFxuICAgIH1cbiAgICBpZiAoXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJlxuICAgICAgd29ya1VuaXRTdG9yZS50eXBlID09PSAncmVxdWVzdCdcbiAgICApIHtcbiAgICAgIHdvcmtVbml0U3RvcmUudXNlZER5bmFtaWMgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFib3J0T25TeW5jaHJvbm91c0R5bmFtaWNEYXRhQWNjZXNzKFxuICByb3V0ZTogc3RyaW5nLFxuICBleHByZXNzaW9uOiBzdHJpbmcsXG4gIHByZXJlbmRlclN0b3JlOiBQcmVyZW5kZXJTdG9yZU1vZGVyblxuKTogdm9pZCB7XG4gIGNvbnN0IHJlYXNvbiA9IGBSb3V0ZSAke3JvdXRlfSBuZWVkcyB0byBiYWlsIG91dCBvZiBwcmVyZW5kZXJpbmcgYXQgdGhpcyBwb2ludCBiZWNhdXNlIGl0IHVzZWQgJHtleHByZXNzaW9ufS5gXG5cbiAgY29uc3QgZXJyb3IgPSBjcmVhdGVQcmVyZW5kZXJJbnRlcnJ1cHRlZEVycm9yKHJlYXNvbilcblxuICBwcmVyZW5kZXJTdG9yZS5jb250cm9sbGVyLmFib3J0KGVycm9yKVxuXG4gIGNvbnN0IGR5bmFtaWNUcmFja2luZyA9IHByZXJlbmRlclN0b3JlLmR5bmFtaWNUcmFja2luZ1xuICBpZiAoZHluYW1pY1RyYWNraW5nKSB7XG4gICAgZHluYW1pY1RyYWNraW5nLmR5bmFtaWNBY2Nlc3Nlcy5wdXNoKHtcbiAgICAgIC8vIFdoZW4gd2UgYXJlbid0IGRlYnVnZ2luZywgd2UgZG9uJ3QgbmVlZCB0byBjcmVhdGUgYW5vdGhlciBlcnJvciBmb3IgdGhlXG4gICAgICAvLyBzdGFjayB0cmFjZS5cbiAgICAgIHN0YWNrOiBkeW5hbWljVHJhY2tpbmcuaXNEZWJ1Z0R5bmFtaWNBY2Nlc3Nlc1xuICAgICAgICA/IG5ldyBFcnJvcigpLnN0YWNrXG4gICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgZXhwcmVzc2lvbixcbiAgICB9KVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhYm9ydE9uU3luY2hyb25vdXNQbGF0Zm9ybUlPQWNjZXNzKFxuICByb3V0ZTogc3RyaW5nLFxuICBleHByZXNzaW9uOiBzdHJpbmcsXG4gIGVycm9yV2l0aFN0YWNrOiBFcnJvcixcbiAgcHJlcmVuZGVyU3RvcmU6IFByZXJlbmRlclN0b3JlTW9kZXJuXG4pOiB2b2lkIHtcbiAgY29uc3QgZHluYW1pY1RyYWNraW5nID0gcHJlcmVuZGVyU3RvcmUuZHluYW1pY1RyYWNraW5nXG4gIGFib3J0T25TeW5jaHJvbm91c0R5bmFtaWNEYXRhQWNjZXNzKHJvdXRlLCBleHByZXNzaW9uLCBwcmVyZW5kZXJTdG9yZSlcbiAgLy8gSXQgaXMgaW1wb3J0YW50IHRoYXQgd2Ugc2V0IHRoaXMgdHJhY2tpbmcgdmFsdWUgYWZ0ZXIgYWJvcnRpbmcuIEFib3J0cyBhcmUgZXhlY3V0ZWRcbiAgLy8gc3luY2hyb25vdXNseSBleGNlcHQgZm9yIHRoZSBjYXNlIHdoZXJlIHlvdSBhYm9ydCBkdXJpbmcgcmVuZGVyIGl0c2VsZi4gQnkgc2V0dGluZyB0aGlzXG4gIC8vIHZhbHVlIGxhdGUgd2UgY2FuIHVzZSBpdCB0byBkZXRlcm1pbmUgaWYgYW55IG9mIHRoZSBhYm9ydGVkIHRhc2tzIGFyZSB0aGUgdGFzayB0aGF0XG4gIC8vIGNhbGxlZCB0aGUgc3luYyBJTyBleHByZXNzaW9uIGluIHRoZSBmaXJzdCBwbGFjZS5cbiAgaWYgKGR5bmFtaWNUcmFja2luZykge1xuICAgIGlmIChkeW5hbWljVHJhY2tpbmcuc3luY0R5bmFtaWNFcnJvcldpdGhTdGFjayA9PT0gbnVsbCkge1xuICAgICAgZHluYW1pY1RyYWNraW5nLnN5bmNEeW5hbWljRXJyb3JXaXRoU3RhY2sgPSBlcnJvcldpdGhTdGFja1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdHJhY2tTeW5jaHJvbm91c1BsYXRmb3JtSU9BY2Nlc3NJbkRldihcbiAgcmVxdWVzdFN0b3JlOiBSZXF1ZXN0U3RvcmVcbik6IHZvaWQge1xuICAvLyBXZSBkb24ndCBhY3R1YWxseSBoYXZlIGEgY29udHJvbGxlciB0byBhYm9ydCBidXQgd2UgZG8gdGhlIHNlbWFudGljIGVxdWl2YWxlbnQgYnlcbiAgLy8gYWR2YW5jaW5nIHRoZSByZXF1ZXN0IHN0b3JlIG91dCBvZiBwcmVyZW5kZXIgbW9kZVxuICByZXF1ZXN0U3RvcmUucHJlcmVuZGVyUGhhc2UgPSBmYWxzZVxufVxuXG4vKipcbiAqIHVzZSB0aGlzIGZ1bmN0aW9uIHdoZW4gcHJlcmVuZGVyaW5nIHdpdGggZHluYW1pY0lPLiBJZiB3ZSBhcmUgZG9pbmcgYVxuICogcHJvc3BlY3RpdmUgcHJlcmVuZGVyIHdlIGRvbid0IGFjdHVhbGx5IGFib3J0IGJlY2F1c2Ugd2Ugd2FudCB0byBkaXNjb3ZlclxuICogYWxsIGNhY2hlcyBmb3IgdGhlIHNoZWxsLiBJZiB0aGlzIGlzIHRoZSBhY3R1YWwgcHJlcmVuZGVyIHdlIGRvIGFib3J0LlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyBhIHByZXJlbmRlclN0b3JlIGJ1dCB0aGUgY2FsbGVyIHNob3VsZCBlbnN1cmUgd2UncmVcbiAqIGFjdHVhbGx5IHJ1bm5pbmcgaW4gZHluYW1pY0lPIG1vZGUuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhYm9ydEFuZFRocm93T25TeW5jaHJvbm91c1JlcXVlc3REYXRhQWNjZXNzKFxuICByb3V0ZTogc3RyaW5nLFxuICBleHByZXNzaW9uOiBzdHJpbmcsXG4gIGVycm9yV2l0aFN0YWNrOiBFcnJvcixcbiAgcHJlcmVuZGVyU3RvcmU6IFByZXJlbmRlclN0b3JlTW9kZXJuXG4pOiBuZXZlciB7XG4gIGNvbnN0IHByZXJlbmRlclNpZ25hbCA9IHByZXJlbmRlclN0b3JlLmNvbnRyb2xsZXIuc2lnbmFsXG4gIGlmIChwcmVyZW5kZXJTaWduYWwuYWJvcnRlZCA9PT0gZmFsc2UpIHtcbiAgICAvLyBUT0RPIGl0IHdvdWxkIGJlIGJldHRlciB0byBtb3ZlIHRoaXMgYWJvcnRlZCBjaGVjayBpbnRvIHRoZSBjYWxsc2l0ZSBzbyB3ZSBjYW4gYXZvaWQgbWFraW5nXG4gICAgLy8gdGhlIGVycm9yIG9iamVjdCB3aGVuIGl0IGlzbid0IHJlbGV2YW50IHRvIHRoZSBhYm9ydGluZyBvZiB0aGUgcHJlcmVuZGVyIGhvd2V2ZXJcbiAgICAvLyBzaW5jZSB3ZSBuZWVkIHRoZSB0aHJvdyBzZW1hbnRpY3MgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHdlIGFib3J0IGl0IGlzIGVhc2llciB0byBsYW5kXG4gICAgLy8gdGhpcyB3YXkuIFNlZSBob3cgdGhpcyB3YXMgaGFuZGxlZCB3aXRoIGBhYm9ydE9uU3luY2hyb25vdXNQbGF0Zm9ybUlPQWNjZXNzYCBmb3IgYSBjbG9zZXJcbiAgICAvLyB0byBpZGVhbCBpbXBsZW1lbnRhdGlvblxuICAgIGFib3J0T25TeW5jaHJvbm91c0R5bmFtaWNEYXRhQWNjZXNzKHJvdXRlLCBleHByZXNzaW9uLCBwcmVyZW5kZXJTdG9yZSlcbiAgICAvLyBJdCBpcyBpbXBvcnRhbnQgdGhhdCB3ZSBzZXQgdGhpcyB0cmFja2luZyB2YWx1ZSBhZnRlciBhYm9ydGluZy4gQWJvcnRzIGFyZSBleGVjdXRlZFxuICAgIC8vIHN5bmNocm9ub3VzbHkgZXhjZXB0IGZvciB0aGUgY2FzZSB3aGVyZSB5b3UgYWJvcnQgZHVyaW5nIHJlbmRlciBpdHNlbGYuIEJ5IHNldHRpbmcgdGhpc1xuICAgIC8vIHZhbHVlIGxhdGUgd2UgY2FuIHVzZSBpdCB0byBkZXRlcm1pbmUgaWYgYW55IG9mIHRoZSBhYm9ydGVkIHRhc2tzIGFyZSB0aGUgdGFzayB0aGF0XG4gICAgLy8gY2FsbGVkIHRoZSBzeW5jIElPIGV4cHJlc3Npb24gaW4gdGhlIGZpcnN0IHBsYWNlLlxuICAgIGNvbnN0IGR5bmFtaWNUcmFja2luZyA9IHByZXJlbmRlclN0b3JlLmR5bmFtaWNUcmFja2luZ1xuICAgIGlmIChkeW5hbWljVHJhY2tpbmcpIHtcbiAgICAgIGlmIChkeW5hbWljVHJhY2tpbmcuc3luY0R5bmFtaWNFcnJvcldpdGhTdGFjayA9PT0gbnVsbCkge1xuICAgICAgICBkeW5hbWljVHJhY2tpbmcuc3luY0R5bmFtaWNFcnJvcldpdGhTdGFjayA9IGVycm9yV2l0aFN0YWNrXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHRocm93IGNyZWF0ZVByZXJlbmRlckludGVycnVwdGVkRXJyb3IoXG4gICAgYFJvdXRlICR7cm91dGV9IG5lZWRzIHRvIGJhaWwgb3V0IG9mIHByZXJlbmRlcmluZyBhdCB0aGlzIHBvaW50IGJlY2F1c2UgaXQgdXNlZCAke2V4cHJlc3Npb259LmBcbiAgKVxufVxuXG4vLyBGb3Igbm93IHRoZXNlIGltcGxlbWVudGF0aW9ucyBhcmUgdGhlIHNhbWUgc28gd2UganVzdCByZWV4cG9ydFxuZXhwb3J0IGNvbnN0IHRyYWNrU3luY2hyb25vdXNSZXF1ZXN0RGF0YUFjY2Vzc0luRGV2ID1cbiAgdHJhY2tTeW5jaHJvbm91c1BsYXRmb3JtSU9BY2Nlc3NJbkRldlxuXG4vKipcbiAqIFRoaXMgY29tcG9uZW50IHdpbGwgY2FsbCBgUmVhY3QucG9zdHBvbmVgIHRoYXQgdGhyb3dzIHRoZSBwb3N0cG9uZWQgZXJyb3IuXG4gKi9cbnR5cGUgUG9zdHBvbmVQcm9wcyA9IHtcbiAgcmVhc29uOiBzdHJpbmdcbiAgcm91dGU6IHN0cmluZ1xufVxuZXhwb3J0IGZ1bmN0aW9uIFBvc3Rwb25lKHsgcmVhc29uLCByb3V0ZSB9OiBQb3N0cG9uZVByb3BzKTogbmV2ZXIge1xuICBjb25zdCBwcmVyZW5kZXJTdG9yZSA9IHdvcmtVbml0QXN5bmNTdG9yYWdlLmdldFN0b3JlKClcbiAgY29uc3QgZHluYW1pY1RyYWNraW5nID1cbiAgICBwcmVyZW5kZXJTdG9yZSAmJiBwcmVyZW5kZXJTdG9yZS50eXBlID09PSAncHJlcmVuZGVyLXBwcidcbiAgICAgID8gcHJlcmVuZGVyU3RvcmUuZHluYW1pY1RyYWNraW5nXG4gICAgICA6IG51bGxcbiAgcG9zdHBvbmVXaXRoVHJhY2tpbmcocm91dGUsIHJlYXNvbiwgZHluYW1pY1RyYWNraW5nKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9zdHBvbmVXaXRoVHJhY2tpbmcoXG4gIHJvdXRlOiBzdHJpbmcsXG4gIGV4cHJlc3Npb246IHN0cmluZyxcbiAgZHluYW1pY1RyYWNraW5nOiBudWxsIHwgRHluYW1pY1RyYWNraW5nU3RhdGVcbik6IG5ldmVyIHtcbiAgYXNzZXJ0UG9zdHBvbmUoKVxuICBpZiAoZHluYW1pY1RyYWNraW5nKSB7XG4gICAgZHluYW1pY1RyYWNraW5nLmR5bmFtaWNBY2Nlc3Nlcy5wdXNoKHtcbiAgICAgIC8vIFdoZW4gd2UgYXJlbid0IGRlYnVnZ2luZywgd2UgZG9uJ3QgbmVlZCB0byBjcmVhdGUgYW5vdGhlciBlcnJvciBmb3IgdGhlXG4gICAgICAvLyBzdGFjayB0cmFjZS5cbiAgICAgIHN0YWNrOiBkeW5hbWljVHJhY2tpbmcuaXNEZWJ1Z0R5bmFtaWNBY2Nlc3Nlc1xuICAgICAgICA/IG5ldyBFcnJvcigpLnN0YWNrXG4gICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgZXhwcmVzc2lvbixcbiAgICB9KVxuICB9XG5cbiAgUmVhY3QudW5zdGFibGVfcG9zdHBvbmUoY3JlYXRlUG9zdHBvbmVSZWFzb24ocm91dGUsIGV4cHJlc3Npb24pKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVQb3N0cG9uZVJlYXNvbihyb3V0ZTogc3RyaW5nLCBleHByZXNzaW9uOiBzdHJpbmcpIHtcbiAgcmV0dXJuIChcbiAgICBgUm91dGUgJHtyb3V0ZX0gbmVlZHMgdG8gYmFpbCBvdXQgb2YgcHJlcmVuZGVyaW5nIGF0IHRoaXMgcG9pbnQgYmVjYXVzZSBpdCB1c2VkICR7ZXhwcmVzc2lvbn0uIGAgK1xuICAgIGBSZWFjdCB0aHJvd3MgdGhpcyBzcGVjaWFsIG9iamVjdCB0byBpbmRpY2F0ZSB3aGVyZS4gSXQgc2hvdWxkIG5vdCBiZSBjYXVnaHQgYnkgYCArXG4gICAgYHlvdXIgb3duIHRyeS9jYXRjaC4gTGVhcm4gbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvcHByLWNhdWdodC1lcnJvcmBcbiAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNEeW5hbWljUG9zdHBvbmUoZXJyOiB1bmtub3duKSB7XG4gIGlmIChcbiAgICB0eXBlb2YgZXJyID09PSAnb2JqZWN0JyAmJlxuICAgIGVyciAhPT0gbnVsbCAmJlxuICAgIHR5cGVvZiAoZXJyIGFzIGFueSkubWVzc2FnZSA9PT0gJ3N0cmluZydcbiAgKSB7XG4gICAgcmV0dXJuIGlzRHluYW1pY1Bvc3Rwb25lUmVhc29uKChlcnIgYXMgYW55KS5tZXNzYWdlKVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBpc0R5bmFtaWNQb3N0cG9uZVJlYXNvbihyZWFzb246IHN0cmluZykge1xuICByZXR1cm4gKFxuICAgIHJlYXNvbi5pbmNsdWRlcyhcbiAgICAgICduZWVkcyB0byBiYWlsIG91dCBvZiBwcmVyZW5kZXJpbmcgYXQgdGhpcyBwb2ludCBiZWNhdXNlIGl0IHVzZWQnXG4gICAgKSAmJlxuICAgIHJlYXNvbi5pbmNsdWRlcyhcbiAgICAgICdMZWFybiBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9wcHItY2F1Z2h0LWVycm9yJ1xuICAgIClcbiAgKVxufVxuXG5pZiAoaXNEeW5hbWljUG9zdHBvbmVSZWFzb24oY3JlYXRlUG9zdHBvbmVSZWFzb24oJyUlJScsICdeXl4nKSkgPT09IGZhbHNlKSB7XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAnSW52YXJpYW50OiBpc0R5bmFtaWNQb3N0cG9uZSBtaXNpZGVudGlmaWVkIGEgcG9zdHBvbmUgcmVhc29uLiBUaGlzIGlzIGEgYnVnIGluIE5leHQuanMnXG4gIClcbn1cblxuY29uc3QgTkVYVF9QUkVSRU5ERVJfSU5URVJSVVBURUQgPSAnTkVYVF9QUkVSRU5ERVJfSU5URVJSVVBURUQnXG5cbmZ1bmN0aW9uIGNyZWF0ZVByZXJlbmRlckludGVycnVwdGVkRXJyb3IobWVzc2FnZTogc3RyaW5nKTogRXJyb3Ige1xuICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKVxuICA7KGVycm9yIGFzIGFueSkuZGlnZXN0ID0gTkVYVF9QUkVSRU5ERVJfSU5URVJSVVBURURcbiAgcmV0dXJuIGVycm9yXG59XG5cbnR5cGUgRGlnZXN0RXJyb3IgPSBFcnJvciAmIHtcbiAgZGlnZXN0OiBzdHJpbmdcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUHJlcmVuZGVySW50ZXJydXB0ZWRFcnJvcihcbiAgZXJyb3I6IHVua25vd25cbik6IGVycm9yIGlzIERpZ2VzdEVycm9yIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmXG4gICAgZXJyb3IgIT09IG51bGwgJiZcbiAgICAoZXJyb3IgYXMgYW55KS5kaWdlc3QgPT09IE5FWFRfUFJFUkVOREVSX0lOVEVSUlVQVEVEICYmXG4gICAgJ25hbWUnIGluIGVycm9yICYmXG4gICAgJ21lc3NhZ2UnIGluIGVycm9yICYmXG4gICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvclxuICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhY2Nlc3NlZER5bmFtaWNEYXRhKFxuICBkeW5hbWljQWNjZXNzZXM6IEFycmF5PER5bmFtaWNBY2Nlc3M+XG4pOiBib29sZWFuIHtcbiAgcmV0dXJuIGR5bmFtaWNBY2Nlc3Nlcy5sZW5ndGggPiAwXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb25zdW1lRHluYW1pY0FjY2VzcyhcbiAgc2VydmVyRHluYW1pYzogRHluYW1pY1RyYWNraW5nU3RhdGUsXG4gIGNsaWVudER5bmFtaWM6IER5bmFtaWNUcmFja2luZ1N0YXRlXG4pOiBEeW5hbWljVHJhY2tpbmdTdGF0ZVsnZHluYW1pY0FjY2Vzc2VzJ10ge1xuICAvLyBXZSBtdXRhdGUgYmVjYXVzZSB3ZSBvbmx5IGNhbGwgdGhpcyBvbmNlIHdlIGFyZSBubyBsb25nZXIgd3JpdGluZ1xuICAvLyB0byB0aGUgZHluYW1pY1RyYWNraW5nU3RhdGUgYW5kIGl0J3MgbW9yZSBlZmZpY2llbnQgdGhhbiBjcmVhdGluZyBhIG5ld1xuICAvLyBhcnJheS5cbiAgc2VydmVyRHluYW1pYy5keW5hbWljQWNjZXNzZXMucHVzaCguLi5jbGllbnREeW5hbWljLmR5bmFtaWNBY2Nlc3NlcylcbiAgcmV0dXJuIHNlcnZlckR5bmFtaWMuZHluYW1pY0FjY2Vzc2VzXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXREeW5hbWljQVBJQWNjZXNzZXMoXG4gIGR5bmFtaWNBY2Nlc3NlczogQXJyYXk8RHluYW1pY0FjY2Vzcz5cbik6IHN0cmluZ1tdIHtcbiAgcmV0dXJuIGR5bmFtaWNBY2Nlc3Nlc1xuICAgIC5maWx0ZXIoXG4gICAgICAoYWNjZXNzKTogYWNjZXNzIGlzIFJlcXVpcmVkPER5bmFtaWNBY2Nlc3M+ID0+XG4gICAgICAgIHR5cGVvZiBhY2Nlc3Muc3RhY2sgPT09ICdzdHJpbmcnICYmIGFjY2Vzcy5zdGFjay5sZW5ndGggPiAwXG4gICAgKVxuICAgIC5tYXAoKHsgZXhwcmVzc2lvbiwgc3RhY2sgfSkgPT4ge1xuICAgICAgc3RhY2sgPSBzdGFja1xuICAgICAgICAuc3BsaXQoJ1xcbicpXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgXCJFcnJvcjogXCIgcHJlZml4IGZyb20gdGhlIGZpcnN0IGxpbmUgb2YgdGhlIHN0YWNrIHRyYWNlIGFzXG4gICAgICAgIC8vIHdlbGwgYXMgdGhlIGZpcnN0IDQgbGluZXMgb2YgdGhlIHN0YWNrIHRyYWNlIHdoaWNoIGlzIHRoZSBkaXN0YW5jZVxuICAgICAgICAvLyBmcm9tIHRoZSB1c2VyIGNvZGUgYW5kIHRoZSBgbmV3IEVycm9yKCkuc3RhY2tgIGNhbGwuXG4gICAgICAgIC5zbGljZSg0KVxuICAgICAgICAuZmlsdGVyKChsaW5lKSA9PiB7XG4gICAgICAgICAgLy8gRXhjbHVkZSBOZXh0LmpzIGludGVybmFscyBmcm9tIHRoZSBzdGFjayB0cmFjZS5cbiAgICAgICAgICBpZiAobGluZS5pbmNsdWRlcygnbm9kZV9tb2R1bGVzL25leHQvJykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEV4Y2x1ZGUgYW5vbnltb3VzIGZ1bmN0aW9ucyBmcm9tIHRoZSBzdGFjayB0cmFjZS5cbiAgICAgICAgICBpZiAobGluZS5pbmNsdWRlcygnICg8YW5vbnltb3VzPiknKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRXhjbHVkZSBOb2RlLmpzIGludGVybmFscyBmcm9tIHRoZSBzdGFjayB0cmFjZS5cbiAgICAgICAgICBpZiAobGluZS5pbmNsdWRlcygnIChub2RlOicpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9KVxuICAgICAgICAuam9pbignXFxuJylcbiAgICAgIHJldHVybiBgRHluYW1pYyBBUEkgVXNhZ2UgRGVidWcgLSAke2V4cHJlc3Npb259OlxcbiR7c3RhY2t9YFxuICAgIH0pXG59XG5cbmZ1bmN0aW9uIGFzc2VydFBvc3Rwb25lKCkge1xuICBpZiAoIWhhc1Bvc3Rwb25lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEludmFyaWFudDogUmVhY3QudW5zdGFibGVfcG9zdHBvbmUgaXMgbm90IGRlZmluZWQuIFRoaXMgc3VnZ2VzdHMgdGhlIHdyb25nIHZlcnNpb24gb2YgUmVhY3Qgd2FzIGxvYWRlZC4gVGhpcyBpcyBhIGJ1ZyBpbiBOZXh0LmpzYFxuICAgIClcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgaXMgYSBiaXQgb2YgYSBoYWNrIHRvIGFsbG93IHVzIHRvIGFib3J0IGEgcmVuZGVyIHVzaW5nIGEgUG9zdHBvbmUgaW5zdGFuY2UgaW5zdGVhZCBvZiBhbiBFcnJvciB3aGljaCBjaGFuZ2VzIFJlYWN0J3NcbiAqIGFib3J0IHNlbWFudGljcyBzbGlnaHRseS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVBvc3Rwb25lZEFib3J0U2lnbmFsKHJlYXNvbjogc3RyaW5nKTogQWJvcnRTaWduYWwge1xuICBhc3NlcnRQb3N0cG9uZSgpXG4gIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKClcbiAgLy8gV2UgZ2V0IG91ciBoYW5kcyBvbiBhIHBvc3Rwb25lIGluc3RhbmNlIGJ5IGNhbGxpbmcgcG9zdHBvbmUgYW5kIGNhdGNoaW5nIHRoZSB0aHJvd1xuICB0cnkge1xuICAgIFJlYWN0LnVuc3RhYmxlX3Bvc3Rwb25lKHJlYXNvbilcbiAgfSBjYXRjaCAoeDogdW5rbm93bikge1xuICAgIGNvbnRyb2xsZXIuYWJvcnQoeClcbiAgfVxuICByZXR1cm4gY29udHJvbGxlci5zaWduYWxcbn1cblxuLyoqXG4gKiBJbiBhIHByZXJlbmRlciwgd2UgbWF5IGVuZCB1cCB3aXRoIGhhbmdpbmcgUHJvbWlzZXMgYXMgaW5wdXRzIGR1ZSB0aGVtXG4gKiBzdGFsbGluZyBvbiBjb25uZWN0aW9uKCkgb3IgYmVjYXVzZSB0aGV5J3JlIGxvYWRpbmcgZHluYW1pYyBkYXRhLiBJbiB0aGF0XG4gKiBjYXNlIHdlIG5lZWQgdG8gYWJvcnQgdGhlIGVuY29kaW5nIG9mIGFyZ3VtZW50cyBzaW5jZSB0aGV5J2xsIG5ldmVyIGNvbXBsZXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSGFuZ2luZ0lucHV0QWJvcnRTaWduYWwoXG4gIHdvcmtVbml0U3RvcmU6IFByZXJlbmRlclN0b3JlTW9kZXJuXG4pOiBBYm9ydFNpZ25hbCB7XG4gIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKClcblxuICBpZiAod29ya1VuaXRTdG9yZS5jYWNoZVNpZ25hbCkge1xuICAgIC8vIElmIHdlIGhhdmUgYSBjYWNoZVNpZ25hbCBpdCBtZWFucyB3ZSdyZSBpbiBhIHByb3NwZWN0aXZlIHJlbmRlci4gSWYgdGhlIGlucHV0XG4gICAgLy8gd2UncmUgd2FpdGluZyBvbiBpcyBjb21pbmcgZnJvbSBhbm90aGVyIGNhY2hlLCB3ZSBkbyB3YW50IHRvIHdhaXQgZm9yIGl0IHNvIHRoYXRcbiAgICAvLyB3ZSBjYW4gcmVzb2x2ZSB0aGlzIGNhY2hlIGVudHJ5IHRvby5cbiAgICB3b3JrVW5pdFN0b3JlLmNhY2hlU2lnbmFsLmlucHV0UmVhZHkoKS50aGVuKCgpID0+IHtcbiAgICAgIGNvbnRyb2xsZXIuYWJvcnQoKVxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgLy8gT3RoZXJ3aXNlIHdlJ3JlIGluIHRoZSBmaW5hbCByZW5kZXIgYW5kIHdlIHNob3VsZCBhbHJlYWR5IGhhdmUgYWxsIG91ciBjYWNoZXNcbiAgICAvLyBmaWxsZWQuIFdlIG1pZ2h0IHN0aWxsIGJlIHdhaXRpbmcgb24gc29tZSBtaWNyb3Rhc2tzIHNvIHdlIHdhaXQgb25lIHRpY2sgYmVmb3JlXG4gICAgLy8gZ2l2aW5nIHVwLiBXaGVuIHdlIGdpdmUgdXAsIHdlIHN0aWxsIHdhbnQgdG8gcmVuZGVyIHRoZSBjb250ZW50IG9mIHRoaXMgY2FjaGVcbiAgICAvLyBhcyBkZWVwbHkgYXMgd2UgY2FuIHNvIHRoYXQgd2UgY2FuIHN1c3BlbmQgYXMgZGVlcGx5IGFzIHBvc3NpYmxlIGluIHRoZSB0cmVlXG4gICAgLy8gb3Igbm90IGF0IGFsbCBpZiB3ZSBkb24ndCBlbmQgdXAgd2FpdGluZyBmb3IgdGhlIGlucHV0LlxuICAgIHNjaGVkdWxlT25OZXh0VGljaygoKSA9PiBjb250cm9sbGVyLmFib3J0KCkpXG4gIH1cblxuICByZXR1cm4gY29udHJvbGxlci5zaWduYWxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFubm90YXRlRHluYW1pY0FjY2VzcyhcbiAgZXhwcmVzc2lvbjogc3RyaW5nLFxuICBwcmVyZW5kZXJTdG9yZTogUHJlcmVuZGVyU3RvcmVNb2Rlcm5cbikge1xuICBjb25zdCBkeW5hbWljVHJhY2tpbmcgPSBwcmVyZW5kZXJTdG9yZS5keW5hbWljVHJhY2tpbmdcbiAgaWYgKGR5bmFtaWNUcmFja2luZykge1xuICAgIGR5bmFtaWNUcmFja2luZy5keW5hbWljQWNjZXNzZXMucHVzaCh7XG4gICAgICBzdGFjazogZHluYW1pY1RyYWNraW5nLmlzRGVidWdEeW5hbWljQWNjZXNzZXNcbiAgICAgICAgPyBuZXcgRXJyb3IoKS5zdGFja1xuICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgIGV4cHJlc3Npb24sXG4gICAgfSlcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlRHluYW1pY1JvdXRlUGFyYW1zKGV4cHJlc3Npb246IHN0cmluZykge1xuICBjb25zdCB3b3JrU3RvcmUgPSB3b3JrQXN5bmNTdG9yYWdlLmdldFN0b3JlKClcblxuICBpZiAoXG4gICAgd29ya1N0b3JlICYmXG4gICAgd29ya1N0b3JlLmlzU3RhdGljR2VuZXJhdGlvbiAmJlxuICAgIHdvcmtTdG9yZS5mYWxsYmFja1JvdXRlUGFyYW1zICYmXG4gICAgd29ya1N0b3JlLmZhbGxiYWNrUm91dGVQYXJhbXMuc2l6ZSA+IDBcbiAgKSB7XG4gICAgLy8gVGhlcmUgYXJlIGZhbGxiYWNrIHJvdXRlIHBhcmFtcywgd2Ugc2hvdWxkIHRyYWNrIHRoZXNlIGFzIGR5bmFtaWNcbiAgICAvLyBhY2Nlc3Nlcy5cbiAgICBjb25zdCB3b3JrVW5pdFN0b3JlID0gd29ya1VuaXRBc3luY1N0b3JhZ2UuZ2V0U3RvcmUoKVxuICAgIGlmICh3b3JrVW5pdFN0b3JlKSB7XG4gICAgICAvLyBXZSdyZSBwcmVyZW5kZXJpbmcgd2l0aCBkeW5hbWljSU8gb3IgUFBSIG9yIGJvdGhcbiAgICAgIGlmICh3b3JrVW5pdFN0b3JlLnR5cGUgPT09ICdwcmVyZW5kZXItY2xpZW50Jykge1xuICAgICAgICAvLyBXZSBhcmUgaW4gYSBwcmVyZW5kZXIgd2l0aCBkeW5hbWljSU8gc2VtYW50aWNzXG4gICAgICAgIC8vIFdlIGFyZSBnb2luZyB0byBoYW5nIGhlcmUgYW5kIG5ldmVyIHJlc29sdmUuIFRoaXMgd2lsbCBjYXVzZSB0aGUgY3VycmVudGx5XG4gICAgICAgIC8vIHJlbmRlcmluZyBjb21wb25lbnQgdG8gZWZmZWN0aXZlbHkgYmUgYSBkeW5hbWljIGhvbGVcbiAgICAgICAgUmVhY3QudXNlKG1ha2VIYW5naW5nUHJvbWlzZSh3b3JrVW5pdFN0b3JlLnJlbmRlclNpZ25hbCwgZXhwcmVzc2lvbikpXG4gICAgICB9IGVsc2UgaWYgKHdvcmtVbml0U3RvcmUudHlwZSA9PT0gJ3ByZXJlbmRlci1wcHInKSB7XG4gICAgICAgIC8vIFdlJ3JlIHByZXJlbmRlcmluZyB3aXRoIFBQUlxuICAgICAgICBwb3N0cG9uZVdpdGhUcmFja2luZyhcbiAgICAgICAgICB3b3JrU3RvcmUucm91dGUsXG4gICAgICAgICAgZXhwcmVzc2lvbixcbiAgICAgICAgICB3b3JrVW5pdFN0b3JlLmR5bmFtaWNUcmFja2luZ1xuICAgICAgICApXG4gICAgICB9IGVsc2UgaWYgKHdvcmtVbml0U3RvcmUudHlwZSA9PT0gJ3ByZXJlbmRlci1sZWdhY3knKSB7XG4gICAgICAgIHRocm93VG9JbnRlcnJ1cHRTdGF0aWNHZW5lcmF0aW9uKGV4cHJlc3Npb24sIHdvcmtTdG9yZSwgd29ya1VuaXRTdG9yZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuY29uc3QgaGFzU3VzcGVuc2VSZWdleCA9IC9cXG5cXHMrYXQgU3VzcGVuc2UgXFwoPGFub255bW91cz5cXCkvXG5jb25zdCBoYXNTdXNwZW5zZUFmdGVyQm9keU9ySHRtbFJlZ2V4ID1cbiAgL1xcblxccythdCAoPzpib2R5fGh0bWwpIFxcKDxhbm9ueW1vdXM+XFwpW1xcc1xcU10qP1xcblxccythdCBTdXNwZW5zZSBcXCg8YW5vbnltb3VzPlxcKS9cbmNvbnN0IGhhc01ldGFkYXRhUmVnZXggPSBuZXcgUmVnRXhwKFxuICBgXFxcXG5cXFxccythdCAke01FVEFEQVRBX0JPVU5EQVJZX05BTUV9W1xcXFxuXFxcXHNdYFxuKVxuY29uc3QgaGFzVmlld3BvcnRSZWdleCA9IG5ldyBSZWdFeHAoXG4gIGBcXFxcblxcXFxzK2F0ICR7VklFV1BPUlRfQk9VTkRBUllfTkFNRX1bXFxcXG5cXFxcc11gXG4pXG5jb25zdCBoYXNPdXRsZXRSZWdleCA9IG5ldyBSZWdFeHAoYFxcXFxuXFxcXHMrYXQgJHtPVVRMRVRfQk9VTkRBUllfTkFNRX1bXFxcXG5cXFxcc11gKVxuXG5leHBvcnQgZnVuY3Rpb24gdHJhY2tBbGxvd2VkRHluYW1pY0FjY2VzcyhcbiAgd29ya1N0b3JlOiBXb3JrU3RvcmUsXG4gIGNvbXBvbmVudFN0YWNrOiBzdHJpbmcsXG4gIGR5bmFtaWNWYWxpZGF0aW9uOiBEeW5hbWljVmFsaWRhdGlvblN0YXRlLFxuICBjbGllbnREeW5hbWljOiBEeW5hbWljVHJhY2tpbmdTdGF0ZVxuKSB7XG4gIGlmIChoYXNPdXRsZXRSZWdleC50ZXN0KGNvbXBvbmVudFN0YWNrKSkge1xuICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gdHJhY2sgdGhhdCB0aGlzIGlzIGR5bmFtaWMuIEl0IGlzIG9ubHkgc28gd2hlbiBzb21ldGhpbmcgZWxzZSBpcyBhbHNvIGR5bmFtaWMuXG4gICAgcmV0dXJuXG4gIH0gZWxzZSBpZiAoaGFzTWV0YWRhdGFSZWdleC50ZXN0KGNvbXBvbmVudFN0YWNrKSkge1xuICAgIGR5bmFtaWNWYWxpZGF0aW9uLmhhc0R5bmFtaWNNZXRhZGF0YSA9IHRydWVcbiAgICByZXR1cm5cbiAgfSBlbHNlIGlmIChoYXNWaWV3cG9ydFJlZ2V4LnRlc3QoY29tcG9uZW50U3RhY2spKSB7XG4gICAgZHluYW1pY1ZhbGlkYXRpb24uaGFzRHluYW1pY1ZpZXdwb3J0ID0gdHJ1ZVxuICAgIHJldHVyblxuICB9IGVsc2UgaWYgKGhhc1N1c3BlbnNlQWZ0ZXJCb2R5T3JIdG1sUmVnZXgudGVzdChjb21wb25lbnRTdGFjaykpIHtcbiAgICAvLyBUaGlzIHByZXJlbmRlciBoYXMgYSBTdXNwZW5zZSBib3VuZGFyeSBhYm92ZSB0aGUgYm9keSB3aGljaFxuICAgIC8vIGVmZmVjdGl2ZWx5IG9wdHMgdGhlIHBhZ2UgaW50byBhbGxvd2luZyAxMDAlIGR5bmFtaWMgcmVuZGVyaW5nXG4gICAgZHluYW1pY1ZhbGlkYXRpb24uaGFzQWxsb3dlZER5bmFtaWMgPSB0cnVlXG4gICAgZHluYW1pY1ZhbGlkYXRpb24uaGFzU3VzcGVuc2VBYm92ZUJvZHkgPSB0cnVlXG4gICAgcmV0dXJuXG4gIH0gZWxzZSBpZiAoaGFzU3VzcGVuc2VSZWdleC50ZXN0KGNvbXBvbmVudFN0YWNrKSkge1xuICAgIC8vIHRoaXMgZXJyb3IgaGFkIGEgU3VzcGVuc2UgYm91bmRhcnkgYWJvdmUgaXQgc28gd2UgZG9uJ3QgbmVlZCB0byByZXBvcnQgaXQgYXMgYSBzb3VyY2VcbiAgICAvLyBvZiBkaXNhbGxvd2VkXG4gICAgZHluYW1pY1ZhbGlkYXRpb24uaGFzQWxsb3dlZER5bmFtaWMgPSB0cnVlXG4gICAgcmV0dXJuXG4gIH0gZWxzZSBpZiAoY2xpZW50RHluYW1pYy5zeW5jRHluYW1pY0Vycm9yV2l0aFN0YWNrKSB7XG4gICAgLy8gVGhpcyB0YXNrIHdhcyB0aGUgdGFzayB0aGF0IGNhbGxlZCB0aGUgc3luYyBlcnJvci5cbiAgICBkeW5hbWljVmFsaWRhdGlvbi5keW5hbWljRXJyb3JzLnB1c2goXG4gICAgICBjbGllbnREeW5hbWljLnN5bmNEeW5hbWljRXJyb3JXaXRoU3RhY2tcbiAgICApXG4gICAgcmV0dXJuXG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGBSb3V0ZSBcIiR7d29ya1N0b3JlLnJvdXRlfVwiOiBBIGNvbXBvbmVudCBhY2Nlc3NlZCBkYXRhLCBoZWFkZXJzLCBwYXJhbXMsIHNlYXJjaFBhcmFtcywgb3IgYSBzaG9ydC1saXZlZCBjYWNoZSB3aXRob3V0IGEgU3VzcGVuc2UgYm91bmRhcnkgbm9yIGEgXCJ1c2UgY2FjaGVcIiBhYm92ZSBpdC4gU2VlIG1vcmUgaW5mbzogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbmV4dC1wcmVyZW5kZXItbWlzc2luZy1zdXNwZW5zZWBcbiAgICBjb25zdCBlcnJvciA9IGNyZWF0ZUVycm9yV2l0aENvbXBvbmVudE9yT3duZXJTdGFjayhtZXNzYWdlLCBjb21wb25lbnRTdGFjaylcbiAgICBkeW5hbWljVmFsaWRhdGlvbi5keW5hbWljRXJyb3JzLnB1c2goZXJyb3IpXG4gICAgcmV0dXJuXG4gIH1cbn1cblxuLyoqXG4gKiBJbiBkZXYgbW9kZSwgd2UgcHJlZmVyIHVzaW5nIHRoZSBvd25lciBzdGFjaywgb3RoZXJ3aXNlIHRoZSBwcm92aWRlZFxuICogY29tcG9uZW50IHN0YWNrIGlzIHVzZWQuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVycm9yV2l0aENvbXBvbmVudE9yT3duZXJTdGFjayhcbiAgbWVzc2FnZTogc3RyaW5nLFxuICBjb21wb25lbnRTdGFjazogc3RyaW5nXG4pIHtcbiAgY29uc3Qgb3duZXJTdGFjayA9XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBSZWFjdC5jYXB0dXJlT3duZXJTdGFja1xuICAgICAgPyBSZWFjdC5jYXB0dXJlT3duZXJTdGFjaygpXG4gICAgICA6IG51bGxcblxuICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKVxuICBlcnJvci5zdGFjayA9IGVycm9yLm5hbWUgKyAnOiAnICsgbWVzc2FnZSArIChvd25lclN0YWNrID8/IGNvbXBvbmVudFN0YWNrKVxuICByZXR1cm4gZXJyb3Jcbn1cblxuZXhwb3J0IGVudW0gUHJlbHVkZVN0YXRlIHtcbiAgRnVsbCA9IDAsXG4gIEVtcHR5ID0gMSxcbiAgRXJyb3JlZCA9IDIsXG59XG5cbmZ1bmN0aW9uIGxvZ0Rpc2FsbG93ZWREeW5hbWljRXJyb3Iod29ya1N0b3JlOiBXb3JrU3RvcmUsIGVycm9yOiBFcnJvcik6IHZvaWQge1xuICBjb25zb2xlLmVycm9yKGVycm9yKVxuXG4gIGlmICghd29ya1N0b3JlLmRldikge1xuICAgIGlmICh3b3JrU3RvcmUuaGFzUmVhZGFibGVFcnJvclN0YWNrcykge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgYFRvIGdldCBhIG1vcmUgZGV0YWlsZWQgc3RhY2sgdHJhY2UgYW5kIHBpbnBvaW50IHRoZSBpc3N1ZSwgc3RhcnQgdGhlIGFwcCBpbiBkZXZlbG9wbWVudCBtb2RlIGJ5IHJ1bm5pbmcgXFxgbmV4dCBkZXZcXGAsIHRoZW4gb3BlbiBcIiR7d29ya1N0b3JlLnJvdXRlfVwiIGluIHlvdXIgYnJvd3NlciB0byBpbnZlc3RpZ2F0ZSB0aGUgZXJyb3IuYFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBUbyBnZXQgYSBtb3JlIGRldGFpbGVkIHN0YWNrIHRyYWNlIGFuZCBwaW5wb2ludCB0aGUgaXNzdWUsIHRyeSBvbmUgb2YgdGhlIGZvbGxvd2luZzpcbiAgLSBTdGFydCB0aGUgYXBwIGluIGRldmVsb3BtZW50IG1vZGUgYnkgcnVubmluZyBcXGBuZXh0IGRldlxcYCwgdGhlbiBvcGVuIFwiJHt3b3JrU3RvcmUucm91dGV9XCIgaW4geW91ciBicm93c2VyIHRvIGludmVzdGlnYXRlIHRoZSBlcnJvci5cbiAgLSBSZXJ1biB0aGUgcHJvZHVjdGlvbiBidWlsZCB3aXRoIFxcYG5leHQgYnVpbGQgLS1kZWJ1Zy1wcmVyZW5kZXJcXGAgdG8gZ2VuZXJhdGUgYmV0dGVyIHN0YWNrIHRyYWNlcy5gKVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdGhyb3dJZkRpc2FsbG93ZWREeW5hbWljKFxuICB3b3JrU3RvcmU6IFdvcmtTdG9yZSxcbiAgcHJlbHVkZTogUHJlbHVkZVN0YXRlLFxuICBkeW5hbWljVmFsaWRhdGlvbjogRHluYW1pY1ZhbGlkYXRpb25TdGF0ZSxcbiAgc2VydmVyRHluYW1pYzogRHluYW1pY1RyYWNraW5nU3RhdGVcbik6IHZvaWQge1xuICBpZiAod29ya1N0b3JlLmludmFsaWREeW5hbWljVXNhZ2VFcnJvcikge1xuICAgIGxvZ0Rpc2FsbG93ZWREeW5hbWljRXJyb3Iod29ya1N0b3JlLCB3b3JrU3RvcmUuaW52YWxpZER5bmFtaWNVc2FnZUVycm9yKVxuICAgIHRocm93IG5ldyBTdGF0aWNHZW5CYWlsb3V0RXJyb3IoKVxuICB9XG5cbiAgaWYgKHByZWx1ZGUgIT09IFByZWx1ZGVTdGF0ZS5GdWxsKSB7XG4gICAgaWYgKGR5bmFtaWNWYWxpZGF0aW9uLmhhc1N1c3BlbnNlQWJvdmVCb2R5KSB7XG4gICAgICAvLyBUaGlzIHJvdXRlIGhhcyBvcHRlZCBpbnRvIGFsbG93aW5nIGZ1bGx5IGR5bmFtaWMgcmVuZGVyaW5nXG4gICAgICAvLyBieSBpbmNsdWRpbmcgYSBTdXNwZW5zZSBib3VuZGFyeSBhYm92ZSB0aGUgYm9keS4gSW4gdGhpcyBjYXNlXG4gICAgICAvLyBhIGxhY2sgb2YgYSBzaGVsbCBpcyBub3QgY29uc2lkZXJlZCBkaXNhbGxvd2VkIHNvIHdlIHNpbXBseSByZXR1cm5cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChzZXJ2ZXJEeW5hbWljLnN5bmNEeW5hbWljRXJyb3JXaXRoU3RhY2spIHtcbiAgICAgIC8vIFRoZXJlIGlzIG5vIHNoZWxsIGFuZCB0aGUgc2VydmVyIGRpZCBzb21ldGhpbmcgc3luYyBkeW5hbWljIGxpa2VseVxuICAgICAgLy8gbGVhZGluZyB0byBhbiBlYXJseSB0ZXJtaW5hdGlvbiBvZiB0aGUgcHJlcmVuZGVyIGJlZm9yZSB0aGUgc2hlbGxcbiAgICAgIC8vIGNvdWxkIGJlIGNvbXBsZXRlZC4gV2UgdGVybWluYXRlIHRoZSBidWlsZC92YWxpZGF0aW5nIHJlbmRlci5cbiAgICAgIGxvZ0Rpc2FsbG93ZWREeW5hbWljRXJyb3IoXG4gICAgICAgIHdvcmtTdG9yZSxcbiAgICAgICAgc2VydmVyRHluYW1pYy5zeW5jRHluYW1pY0Vycm9yV2l0aFN0YWNrXG4gICAgICApXG4gICAgICB0aHJvdyBuZXcgU3RhdGljR2VuQmFpbG91dEVycm9yKClcbiAgICB9XG5cbiAgICAvLyBXZSBkaWRuJ3QgaGF2ZSBhbnkgc3luYyBiYWlsb3V0cyBidXQgdGhlcmUgbWF5IGJlIHVzZXIgY29kZSB3aGljaFxuICAgIC8vIGJsb2NrZWQgdGhlIHJvb3QuIFdlIHdvdWxkIGhhdmUgY2FwdHVyZWQgdGhlc2UgZHVyaW5nIHRoZSBwcmVyZW5kZXJcbiAgICAvLyBhbmQgY2FuIGxvZyB0aGVtIGhlcmUgYW5kIHRoZW4gdGVybWluYXRlIHRoZSBidWlsZC92YWxpZGF0aW5nIHJlbmRlclxuICAgIGNvbnN0IGR5bmFtaWNFcnJvcnMgPSBkeW5hbWljVmFsaWRhdGlvbi5keW5hbWljRXJyb3JzXG4gICAgaWYgKGR5bmFtaWNFcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkeW5hbWljRXJyb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxvZ0Rpc2FsbG93ZWREeW5hbWljRXJyb3Iod29ya1N0b3JlLCBkeW5hbWljRXJyb3JzW2ldKVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgU3RhdGljR2VuQmFpbG91dEVycm9yKClcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBnb3QgdGhpcyBmYXIgdGhlbiB0aGUgb25seSBvdGhlciB0aGluZyB0aGF0IGNvdWxkIGJlIGJsb2NraW5nXG4gICAgLy8gdGhlIHJvb3QgaXMgZHluYW1pYyBWaWV3cG9ydC4gSWYgdGhpcyBpcyBkeW5hbWljIHRoZW5cbiAgICAvLyB5b3UgbmVlZCB0byBvcHQgaW50byB0aGF0IGJ5IGFkZGluZyBhIFN1c3BlbnNlIGJvdW5kYXJ5IGFib3ZlIHRoZSBib2R5XG4gICAgLy8gdG8gaW5kaWNhdGUgeW91ciBhcmUgb2sgd2l0aCBmdWxseSBkeW5hbWljIHJlbmRlcmluZy5cbiAgICBpZiAoZHluYW1pY1ZhbGlkYXRpb24uaGFzRHluYW1pY1ZpZXdwb3J0KSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBgUm91dGUgXCIke3dvcmtTdG9yZS5yb3V0ZX1cIiBoYXMgYSBcXGBnZW5lcmF0ZVZpZXdwb3J0XFxgIHRoYXQgZGVwZW5kcyBvbiBSZXF1ZXN0IGRhdGEgKFxcYGNvb2tpZXMoKVxcYCwgZXRjLi4uKSBvciB1bmNhY2hlZCBleHRlcm5hbCBkYXRhIChcXGBmZXRjaCguLi4pXFxgLCBldGMuLi4pIHdpdGhvdXQgZXhwbGljaXRseSBhbGxvd2luZyBmdWxseSBkeW5hbWljIHJlbmRlcmluZy4gU2VlIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LXByZXJlbmRlci1keW5hbWljLXZpZXdwb3J0YFxuICAgICAgKVxuICAgICAgdGhyb3cgbmV3IFN0YXRpY0dlbkJhaWxvdXRFcnJvcigpXG4gICAgfVxuXG4gICAgaWYgKHByZWx1ZGUgPT09IFByZWx1ZGVTdGF0ZS5FbXB0eSkge1xuICAgICAgLy8gSWYgd2UgZXZlciBnZXQgdGhpcyBmYXIgdGhlbiB3ZSBtZXNzZWQgdXAgdGhlIHRyYWNraW5nIG9mIGludmFsaWQgZHluYW1pYy5cbiAgICAgIC8vIFdlIHN0aWxsIGFkaGVyZSB0byB0aGUgY29uc3RyYWludCB0aGF0IHlvdSBtdXN0IHByb2R1Y2UgYSBzaGVsbCBidXQgaW52aXRlIHRoZVxuICAgICAgLy8gdXNlciB0byByZXBvcnQgdGhpcyBhcyBhIGJ1ZyBpbiBOZXh0LmpzLlxuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgYFJvdXRlIFwiJHt3b3JrU3RvcmUucm91dGV9XCIgZGlkIG5vdCBwcm9kdWNlIGEgc3RhdGljIHNoZWxsIGFuZCBOZXh0LmpzIHdhcyB1bmFibGUgdG8gZGV0ZXJtaW5lIGEgcmVhc29uLiBUaGlzIGlzIGEgYnVnIGluIE5leHQuanMuYFxuICAgICAgKVxuICAgICAgdGhyb3cgbmV3IFN0YXRpY0dlbkJhaWxvdXRFcnJvcigpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChcbiAgICAgIGR5bmFtaWNWYWxpZGF0aW9uLmhhc0FsbG93ZWREeW5hbWljID09PSBmYWxzZSAmJlxuICAgICAgZHluYW1pY1ZhbGlkYXRpb24uaGFzRHluYW1pY01ldGFkYXRhXG4gICAgKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBgUm91dGUgXCIke3dvcmtTdG9yZS5yb3V0ZX1cIiBoYXMgYSBcXGBnZW5lcmF0ZU1ldGFkYXRhXFxgIHRoYXQgZGVwZW5kcyBvbiBSZXF1ZXN0IGRhdGEgKFxcYGNvb2tpZXMoKVxcYCwgZXRjLi4uKSBvciB1bmNhY2hlZCBleHRlcm5hbCBkYXRhIChcXGBmZXRjaCguLi4pXFxgLCBldGMuLi4pIHdoZW4gdGhlIHJlc3Qgb2YgdGhlIHJvdXRlIGRvZXMgbm90LiBTZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL25leHQtcHJlcmVuZGVyLWR5bmFtaWMtbWV0YWRhdGFgXG4gICAgICApXG4gICAgICB0aHJvdyBuZXcgU3RhdGljR2VuQmFpbG91dEVycm9yKClcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJQb3N0cG9uZSIsIlByZWx1ZGVTdGF0ZSIsImFib3J0QW5kVGhyb3dPblN5bmNocm9ub3VzUmVxdWVzdERhdGFBY2Nlc3MiLCJhYm9ydE9uU3luY2hyb25vdXNQbGF0Zm9ybUlPQWNjZXNzIiwiYWNjZXNzZWREeW5hbWljRGF0YSIsImFubm90YXRlRHluYW1pY0FjY2VzcyIsImNvbnN1bWVEeW5hbWljQWNjZXNzIiwiY3JlYXRlRHluYW1pY1RyYWNraW5nU3RhdGUiLCJjcmVhdGVEeW5hbWljVmFsaWRhdGlvblN0YXRlIiwiY3JlYXRlSGFuZ2luZ0lucHV0QWJvcnRTaWduYWwiLCJjcmVhdGVQb3N0cG9uZWRBYm9ydFNpZ25hbCIsImZvcm1hdER5bmFtaWNBUElBY2Nlc3NlcyIsImdldEZpcnN0RHluYW1pY1JlYXNvbiIsImlzRHluYW1pY1Bvc3Rwb25lIiwiaXNQcmVyZW5kZXJJbnRlcnJ1cHRlZEVycm9yIiwibWFya0N1cnJlbnRTY29wZUFzRHluYW1pYyIsInBvc3Rwb25lV2l0aFRyYWNraW5nIiwidGhyb3dJZkRpc2FsbG93ZWREeW5hbWljIiwidGhyb3dUb0ludGVycnVwdFN0YXRpY0dlbmVyYXRpb24iLCJ0cmFja0FsbG93ZWREeW5hbWljQWNjZXNzIiwidHJhY2tEeW5hbWljRGF0YUluRHluYW1pY1JlbmRlciIsInRyYWNrRmFsbGJhY2tQYXJhbUFjY2Vzc2VkIiwidHJhY2tTeW5jaHJvbm91c1BsYXRmb3JtSU9BY2Nlc3NJbkRldiIsInRyYWNrU3luY2hyb25vdXNSZXF1ZXN0RGF0YUFjY2Vzc0luRGV2IiwidXNlRHluYW1pY1JvdXRlUGFyYW1zIiwiaGFzUG9zdHBvbmUiLCJSZWFjdCIsInVuc3RhYmxlX3Bvc3Rwb25lIiwiaXNEZWJ1Z0R5bmFtaWNBY2Nlc3NlcyIsImR5bmFtaWNBY2Nlc3NlcyIsInN5bmNEeW5hbWljRXJyb3JXaXRoU3RhY2siLCJoYXNTdXNwZW5zZUFib3ZlQm9keSIsImhhc0R5bmFtaWNNZXRhZGF0YSIsImhhc0R5bmFtaWNWaWV3cG9ydCIsImhhc0FsbG93ZWREeW5hbWljIiwiZHluYW1pY0Vycm9ycyIsInRyYWNraW5nU3RhdGUiLCJleHByZXNzaW9uIiwic3RvcmUiLCJ3b3JrVW5pdFN0b3JlIiwidHlwZSIsImZvcmNlRHluYW1pYyIsImZvcmNlU3RhdGljIiwiZHluYW1pY1Nob3VsZEVycm9yIiwiU3RhdGljR2VuQmFpbG91dEVycm9yIiwicm91dGUiLCJkeW5hbWljVHJhY2tpbmciLCJyZXZhbGlkYXRlIiwiZXJyIiwiRHluYW1pY1NlcnZlckVycm9yIiwiZHluYW1pY1VzYWdlRGVzY3JpcHRpb24iLCJkeW5hbWljVXNhZ2VTdGFjayIsInN0YWNrIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwidXNlZER5bmFtaWMiLCJwcmVyZW5kZXJTdG9yZSIsIndvcmtVbml0QXN5bmNTdG9yYWdlIiwiZ2V0U3RvcmUiLCJfc3RvcmUiLCJhYm9ydE9uU3luY2hyb25vdXNEeW5hbWljRGF0YUFjY2VzcyIsInJlYXNvbiIsImVycm9yIiwiY3JlYXRlUHJlcmVuZGVySW50ZXJydXB0ZWRFcnJvciIsImNvbnRyb2xsZXIiLCJhYm9ydCIsInB1c2giLCJFcnJvciIsInVuZGVmaW5lZCIsImVycm9yV2l0aFN0YWNrIiwicmVxdWVzdFN0b3JlIiwicHJlcmVuZGVyUGhhc2UiLCJwcmVyZW5kZXJTaWduYWwiLCJzaWduYWwiLCJhYm9ydGVkIiwiYXNzZXJ0UG9zdHBvbmUiLCJjcmVhdGVQb3N0cG9uZVJlYXNvbiIsIm1lc3NhZ2UiLCJpc0R5bmFtaWNQb3N0cG9uZVJlYXNvbiIsImluY2x1ZGVzIiwiTkVYVF9QUkVSRU5ERVJfSU5URVJSVVBURUQiLCJkaWdlc3QiLCJsZW5ndGgiLCJzZXJ2ZXJEeW5hbWljIiwiY2xpZW50RHluYW1pYyIsImZpbHRlciIsImFjY2VzcyIsIm1hcCIsInNwbGl0Iiwic2xpY2UiLCJsaW5lIiwiam9pbiIsIkFib3J0Q29udHJvbGxlciIsIngiLCJjYWNoZVNpZ25hbCIsImlucHV0UmVhZHkiLCJ0aGVuIiwic2NoZWR1bGVPbk5leHRUaWNrIiwid29ya1N0b3JlIiwid29ya0FzeW5jU3RvcmFnZSIsImlzU3RhdGljR2VuZXJhdGlvbiIsImZhbGxiYWNrUm91dGVQYXJhbXMiLCJzaXplIiwidXNlIiwibWFrZUhhbmdpbmdQcm9taXNlIiwicmVuZGVyU2lnbmFsIiwiaGFzU3VzcGVuc2VSZWdleCIsImhhc1N1c3BlbnNlQWZ0ZXJCb2R5T3JIdG1sUmVnZXgiLCJoYXNNZXRhZGF0YVJlZ2V4IiwiUmVnRXhwIiwiTUVUQURBVEFfQk9VTkRBUllfTkFNRSIsImhhc1ZpZXdwb3J0UmVnZXgiLCJWSUVXUE9SVF9CT1VOREFSWV9OQU1FIiwiaGFzT3V0bGV0UmVnZXgiLCJPVVRMRVRfQk9VTkRBUllfTkFNRSIsImNvbXBvbmVudFN0YWNrIiwiZHluYW1pY1ZhbGlkYXRpb24iLCJ0ZXN0IiwiY3JlYXRlRXJyb3JXaXRoQ29tcG9uZW50T3JPd25lclN0YWNrIiwib3duZXJTdGFjayIsImNhcHR1cmVPd25lclN0YWNrIiwibmFtZSIsImxvZ0Rpc2FsbG93ZWREeW5hbWljRXJyb3IiLCJjb25zb2xlIiwiZGV2IiwiaGFzUmVhZGFibGVFcnJvclN0YWNrcyIsInByZWx1ZGUiLCJpbnZhbGlkRHluYW1pY1VzYWdlRXJyb3IiLCJpIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FvQkM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFnVmVBLFFBQVEsRUFBQTtlQUFSQTs7SUEyVEpDLFlBQVksRUFBQTtlQUFaQTs7SUFwV0lDLDJDQUEyQyxFQUFBO2VBQTNDQTs7SUFyQ0FDLGtDQUFrQyxFQUFBO2VBQWxDQTs7SUF3S0FDLG1CQUFtQixFQUFBO2VBQW5CQTs7SUE0R0FDLHFCQUFxQixFQUFBO2VBQXJCQTs7SUF0R0FDLG9CQUFvQixFQUFBO2VBQXBCQTs7SUEvV0FDLDBCQUEw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SUFBSThDLElBQUksR0FBR0EsSUFBSTlGLGNBQWNnRCxNQUFNLEVBQUU4QyxJQUFLO2dCQUM3Q04sMEJBQTBCeEIsV0FBV2hFLGFBQWEsQ0FBQzhGLEVBQUU7WUFDdkQ7WUFFQSxNQUFNLElBQUlyRix5QkFBQUEscUJBQXFCO1FBQ2pDO1FBRUEsc0VBQXNFO1FBQ3RFLHdEQUF3RDtRQUN4RCx5RUFBeUU7UUFDekUsd0RBQXdEO1FBQ3hELElBQUl5RSxrQkFBa0JwRixrQkFBa0IsRUFBRTtZQUN4QzJGLFFBQVE3RCxLQUFLLENBQ1gsQ0FBQyxPQUFPLEVBQUVvQyxVQUFVdEQsS0FBSyxDQUFDLDhRQUE4USxDQUFDO1lBRTNTLE1BQU0sSUFBSUQseUJBQUFBLHFCQUFxQjtRQUNqQztRQUVBLElBQUltRixZQUFBQSxHQUFnQztZQUNsQyw2RUFBNkU7WUFDN0UsaUZBQWlGO1lBQ2pGLDJDQUEyQztZQUMzQ0gsUUFBUTdELEtBQUssQ0FDWCxDQUFDLE9BQU8sRUFBRW9DLFVBQVV0RCxLQUFLLENBQUMsd0dBQXdHLENBQUM7WUFFckksTUFBTSxJQUFJRCx5QkFBQUEscUJBQXFCO1FBQ2pDO0lBQ0YsT0FBTztRQUNMLElBQ0V5RSxrQkFBa0JuRixpQkFBaUIsS0FBSyxTQUN4Q21GLGtCQUFrQnJGLGtCQUFrQixFQUNwQztZQUNBNEYsUUFBUTdELEtBQUssQ0FDWCxDQUFDLE9BQU8sRUFBRW9DLFVBQVV0RCxLQUFLLENBQUMsOFBBQThQLENBQUM7WUFFM1IsTUFBTSxJQUFJRCx5QkFBQUEscUJBQXFCO1FBQ2pDO0lBQ0Y7QUFDRiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA1MzQ1LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2NsaWVudC9jb21wb25lbnRzL3Vuc3RhYmxlLXJldGhyb3cuc2VydmVyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzSGFuZ2luZ1Byb21pc2VSZWplY3Rpb25FcnJvciB9IGZyb20gJy4uLy4uL3NlcnZlci9keW5hbWljLXJlbmRlcmluZy11dGlscydcbmltcG9ydCB7IGlzUG9zdHBvbmUgfSBmcm9tICcuLi8uLi9zZXJ2ZXIvbGliL3JvdXRlci11dGlscy9pcy1wb3N0cG9uZSdcbmltcG9ydCB7IGlzQmFpbG91dFRvQ1NSRXJyb3IgfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL2xhenktZHluYW1pYy9iYWlsb3V0LXRvLWNzcidcbmltcG9ydCB7IGlzTmV4dFJvdXRlckVycm9yIH0gZnJvbSAnLi9pcy1uZXh0LXJvdXRlci1lcnJvcidcbmltcG9ydCB7IGlzRHluYW1pY1Bvc3Rwb25lIH0gZnJvbSAnLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvZHluYW1pYy1yZW5kZXJpbmcnXG5pbXBvcnQgeyBpc0R5bmFtaWNTZXJ2ZXJFcnJvciB9IGZyb20gJy4vaG9va3Mtc2VydmVyLWNvbnRleHQnXG5cbmV4cG9ydCBmdW5jdGlvbiB1bnN0YWJsZV9yZXRocm93KGVycm9yOiB1bmtub3duKTogdm9pZCB7XG4gIGlmIChcbiAgICBpc05leHRSb3V0ZXJFcnJvcihlcnJvcikgfHxcbiAgICBpc0JhaWxvdXRUb0NTUkVycm9yKGVycm9yKSB8fFxuICAgIGlzRHluYW1pY1NlcnZlckVycm9yKGVycm9yKSB8fFxuICAgIGlzRHluYW1pY1Bvc3Rwb25lKGVycm9yKSB8fFxuICAgIGlzUG9zdHBvbmUoZXJyb3IpIHx8XG4gICAgaXNIYW5naW5nUHJvbWlzZVJlamVjdGlvbkVycm9yKGVycm9yKVxuICApIHtcbiAgICB0aHJvdyBlcnJvclxuICB9XG5cbiAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgJ2NhdXNlJyBpbiBlcnJvcikge1xuICAgIHVuc3RhYmxlX3JldGhyb3coZXJyb3IuY2F1c2UpXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJ1bnN0YWJsZV9yZXRocm93IiwiZXJyb3IiLCJpc05leHRSb3V0ZXJFcnJvciIsImlzQmFpbG91dFRvQ1NSRXJyb3IiLCJpc0R5bmFtaWNTZXJ2ZXJFcnJvciIsImlzRHluYW1pY1Bvc3Rwb25lIiwiaXNQb3N0cG9uZSIsImlzSGFuZ2luZ1Byb21pc2VSZWplY3Rpb25FcnJvciIsIkVycm9yIiwiY2F1c2UiXSwibWFwcGluZ3MiOiI7OzsrQkFPZ0JBLG9CQUFBQTs7O2VBQUFBOzs7dUNBUCtCOzRCQUNwQjs4QkFDUzttQ0FDRjtrQ0FDQTtvQ0FDRztBQUU5QixTQUFTQSxpQkFBaUJDLEtBQWM7SUFDN0MsSUFDRUMsQ0FBQUEsR0FBQUEsbUJBQUFBLGlCQUFpQixFQUFDRCxVQUNsQkUsQ0FBQUEsR0FBQUEsY0FBQUEsbUJBQW1CLEVBQUNGLFVBQ3BCRyxDQUFBQSxHQUFBQSxvQkFBQUEsb0JBQW9CLEVBQUNILFVBQ3JCSSxDQUFBQSxHQUFBQSxrQkFBQUEsaUJBQWlCLEVBQUNKLFVBQ2xCSyxDQUFBQSxHQUFBQSxZQUFBQSxVQUFVLEVBQUNMLFVBQ1hNLENBQUFBLEdBQUFBLHVCQUFBQSw4QkFBOEIsRUFBQ04sUUFDL0I7UUFDQSxNQUFNQTtJQUNSO0lBRUEsSUFBSUEsaUJBQWlCTyxTQUFTLFdBQVdQLE9BQU87UUFDOUNELGlCQUFpQkMsTUFBTVEsS0FBSztJQUM5QjtBQUNGIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDUzODEsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvY2xpZW50L2NvbXBvbmVudHMvdW5zdGFibGUtcmV0aHJvdy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIHVzZWQgdG8gcmV0aHJvdyBpbnRlcm5hbCBOZXh0LmpzIGVycm9ycyBzbyB0aGF0IHRoZXkgY2FuIGJlIGhhbmRsZWQgYnkgdGhlIGZyYW1ld29yay5cbiAqIFdoZW4gd3JhcHBpbmcgYW4gQVBJIHRoYXQgdXNlcyBlcnJvcnMgdG8gaW50ZXJydXB0IGNvbnRyb2wgZmxvdywgeW91IHNob3VsZCB1c2UgdGhpcyBmdW5jdGlvbiBiZWZvcmUgeW91IGRvIGFueSBlcnJvciBoYW5kbGluZy5cbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCByZXRocm93IHRoZSBlcnJvciBpZiBpdCBpcyBhIE5leHQuanMgZXJyb3Igc28gaXQgY2FuIGJlIGhhbmRsZWQsIG90aGVyd2lzZSBpdCB3aWxsIGRvIG5vdGhpbmcuXG4gKlxuICogUmVhZCBtb3JlOiBbTmV4dC5qcyBEb2NzOiBgdW5zdGFibGVfcmV0aHJvd2BdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9hcGktcmVmZXJlbmNlL2Z1bmN0aW9ucy91bnN0YWJsZV9yZXRocm93KVxuICovXG5leHBvcnQgY29uc3QgdW5zdGFibGVfcmV0aHJvdyA9XG4gIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnXG4gICAgPyAoXG4gICAgICAgIHJlcXVpcmUoJy4vdW5zdGFibGUtcmV0aHJvdy5zZXJ2ZXInKSBhcyB0eXBlb2YgaW1wb3J0KCcuL3Vuc3RhYmxlLXJldGhyb3cuc2VydmVyJylcbiAgICAgICkudW5zdGFibGVfcmV0aHJvd1xuICAgIDogKFxuICAgICAgICByZXF1aXJlKCcuL3Vuc3RhYmxlLXJldGhyb3cuYnJvd3NlcicpIGFzIHR5cGVvZiBpbXBvcnQoJy4vdW5zdGFibGUtcmV0aHJvdy5icm93c2VyJylcbiAgICAgICkudW5zdGFibGVfcmV0aHJvd1xuIl0sIm5hbWVzIjpbInVuc3RhYmxlX3JldGhyb3ciLCJ3aW5kb3ciLCJyZXF1aXJlIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0NBTUM7OzsrQkFDWUEsb0JBQUFBOzs7ZUFBQUE7OztBQUFOLE1BQU1BLG1CQUNYLE9BQU9DLFdBQVcscUJBRVpDLFFBQVEsd0hBQ1JGLGdCQUFnQixHQUVoQkUsUUFBUSw4QkFDUkYsZ0JBQWdCIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDU0MTAsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvY2xpZW50L2NvbXBvbmVudHMvbmF2aWdhdGlvbi5yZWFjdC1zZXJ2ZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBpbnRlcm5hbCAqL1xuY2xhc3MgUmVhZG9ubHlVUkxTZWFyY2hQYXJhbXNFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXG4gICAgICAnTWV0aG9kIHVuYXZhaWxhYmxlIG9uIGBSZWFkb25seVVSTFNlYXJjaFBhcmFtc2AuIFJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2FwaS1yZWZlcmVuY2UvZnVuY3Rpb25zL3VzZS1zZWFyY2gtcGFyYW1zI3VwZGF0aW5nLXNlYXJjaHBhcmFtcydcbiAgICApXG4gIH1cbn1cblxuY2xhc3MgUmVhZG9ubHlVUkxTZWFyY2hQYXJhbXMgZXh0ZW5kcyBVUkxTZWFyY2hQYXJhbXMge1xuICAvKiogQGRlcHJlY2F0ZWQgTWV0aG9kIHVuYXZhaWxhYmxlIG9uIGBSZWFkb25seVVSTFNlYXJjaFBhcmFtc2AuIFJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2FwaS1yZWZlcmVuY2UvZnVuY3Rpb25zL3VzZS1zZWFyY2gtcGFyYW1zI3VwZGF0aW5nLXNlYXJjaHBhcmFtcyAqL1xuICBhcHBlbmQoKSB7XG4gICAgdGhyb3cgbmV3IFJlYWRvbmx5VVJMU2VhcmNoUGFyYW1zRXJyb3IoKVxuICB9XG4gIC8qKiBAZGVwcmVjYXRlZCBNZXRob2QgdW5hdmFpbGFibGUgb24gYFJlYWRvbmx5VVJMU2VhcmNoUGFyYW1zYC4gUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYXBpLXJlZmVyZW5jZS9mdW5jdGlvbnMvdXNlLXNlYXJjaC1wYXJhbXMjdXBkYXRpbmctc2VhcmNocGFyYW1zICovXG4gIGRlbGV0ZSgpIHtcbiAgICB0aHJvdyBuZXcgUmVhZG9ubHlVUkxTZWFyY2hQYXJhbXNFcnJvcigpXG4gIH1cbiAgLyoqIEBkZXByZWNhdGVkIE1ldGhvZCB1bmF2YWlsYWJsZSBvbiBgUmVhZG9ubHlVUkxTZWFyY2hQYXJhbXNgLiBSZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9hcGktcmVmZXJlbmNlL2Z1bmN0aW9ucy91c2Utc2VhcmNoLXBhcmFtcyN1cGRhdGluZy1zZWFyY2hwYXJhbXMgKi9cbiAgc2V0KCkge1xuICAgIHRocm93IG5ldyBSZWFkb25seVVSTFNlYXJjaFBhcmFtc0Vycm9yKClcbiAgfVxuICAvKiogQGRlcHJlY2F0ZWQgTWV0aG9kIHVuYXZhaWxhYmxlIG9uIGBSZWFkb25seVVSTFNlYXJjaFBhcmFtc2AuIFJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2FwaS1yZWZlcmVuY2UvZnVuY3Rpb25zL3VzZS1zZWFyY2gtcGFyYW1zI3VwZGF0aW5nLXNlYXJjaHBhcmFtcyAqL1xuICBzb3J0KCkge1xuICAgIHRocm93IG5ldyBSZWFkb25seVVSTFNlYXJjaFBhcmFtc0Vycm9yKClcbiAgfVxufVxuXG5leHBvcnQgeyByZWRpcmVjdCwgcGVybWFuZW50UmVkaXJlY3QgfSBmcm9tICcuL3JlZGlyZWN0J1xuZXhwb3J0IHsgUmVkaXJlY3RUeXBlIH0gZnJvbSAnLi9yZWRpcmVjdC1lcnJvcidcbmV4cG9ydCB7IG5vdEZvdW5kIH0gZnJvbSAnLi9ub3QtZm91bmQnXG5leHBvcnQgeyBmb3JiaWRkZW4gfSBmcm9tICcuL2ZvcmJpZGRlbidcbmV4cG9ydCB7IHVuYXV0aG9yaXplZCB9IGZyb20gJy4vdW5hdXRob3JpemVkJ1xuZXhwb3J0IHsgdW5zdGFibGVfcmV0aHJvdyB9IGZyb20gJy4vdW5zdGFibGUtcmV0aHJvdydcbmV4cG9ydCB7IFJlYWRvbmx5VVJMU2VhcmNoUGFyYW1zIH1cbiJdLCJuYW1lcyI6WyJSZWFkb25seVVSTFNlYXJjaFBhcmFtcyIsIlJlZGlyZWN0VHlwZSIsImZvcmJpZGRlbiIsIm5vdEZvdW5kIiwicGVybWFuZW50UmVkaXJlY3QiLCJyZWRpcmVjdCIsInVuYXV0aG9yaXplZCIsInVuc3RhYmxlX3JldGhyb3ciLCJSZWFkb25seVVSTFNlYXJjaFBhcmFtc0Vycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIlVSTFNlYXJjaFBhcmFtcyIsImFwcGVuZCIsImRlbGV0ZSIsInNldCIsInNvcnQiXSwibWFwcGluZ3MiOiJBQUFBLGNBQWM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBa0NMQSx1QkFBdUIsRUFBQTtlQUF2QkE7O0lBTEFDLFlBQVksRUFBQTtlQUFaQSxlQUFBQSxZQUFZOztJQUVaQyxTQUFTLEVBQUE7ZUFBVEEsV0FBQUEsU0FBUzs7SUFEVEMsUUFBUSxFQUFBO2VBQVJBLFVBQUFBLFFBQVE7O0lBRkVDLGlCQUFpQixFQUFBO2VBQWpCQSxVQUFBQSxpQkFBaUI7O0lBQTNCQyxRQUFRLEVBQUE7ZUFBUkEsVUFBQUEsUUFBUTs7SUFJUkMsWUFBWSxFQUFBO2VBQVpBLGNBQUFBLFlBQVk7O0lBQ1pDLGdCQUFnQixFQUFBO2VBQWhCQSxpQkFBQUEsZ0JBQWdCOzs7MEJBTG1COytCQUNmOzBCQUNKOzJCQUNDOzhCQUNHO2lDQUNJO0FBaENqQyxNQUFNQyxxQ0FBcUNDO0lBQ3pDQyxhQUFjO1FBQ1osS0FBSyxDQUNIO0lBRUo7QUFDRjtBQUVBLE1BQU1WLGdDQUFnQ1c7SUFDcEMsd0tBQXdLLEdBQ3hLQyxTQUFTO1FBQ1AsTUFBTSxJQUFJSjtJQUNaO0lBQ0Esd0tBQXdLLEdBQ3hLSyxTQUFTO1FBQ1AsTUFBTSxJQUFJTDtJQUNaO0lBQ0Esd0tBQXdLLEdBQ3hLTSxNQUFNO1FBQ0osTUFBTSxJQUFJTjtJQUNaO0lBQ0Esd0tBQXdLLEdBQ3hLTyxPQUFPO1FBQ0wsTUFBTSxJQUFJUDtJQUNaO0FBQ0YiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNTQ5MywgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvY29tcG9uZW50cy9iYWlsb3V0LXRvLWNsaWVudC1yZW5kZXJpbmcudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmFpbG91dFRvQ1NSRXJyb3IgfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL2xhenktZHluYW1pYy9iYWlsb3V0LXRvLWNzcidcbmltcG9ydCB7IHdvcmtBc3luY1N0b3JhZ2UgfSBmcm9tICcuLi8uLi9zZXJ2ZXIvYXBwLXJlbmRlci93b3JrLWFzeW5jLXN0b3JhZ2UuZXh0ZXJuYWwnXG5pbXBvcnQgeyB3b3JrVW5pdEFzeW5jU3RvcmFnZSB9IGZyb20gJy4uLy4uL3NlcnZlci9hcHAtcmVuZGVyL3dvcmstdW5pdC1hc3luYy1zdG9yYWdlLmV4dGVybmFsJ1xuXG5leHBvcnQgZnVuY3Rpb24gYmFpbG91dFRvQ2xpZW50UmVuZGVyaW5nKHJlYXNvbjogc3RyaW5nKTogdm9pZCB8IG5ldmVyIHtcbiAgY29uc3Qgd29ya1N0b3JlID0gd29ya0FzeW5jU3RvcmFnZS5nZXRTdG9yZSgpXG5cbiAgaWYgKHdvcmtTdG9yZT8uZm9yY2VTdGF0aWMpIHJldHVyblxuXG4gIGNvbnN0IHdvcmtVbml0U3RvcmUgPSB3b3JrVW5pdEFzeW5jU3RvcmFnZS5nZXRTdG9yZSgpXG5cbiAgaWYgKHdvcmtVbml0U3RvcmUpIHtcbiAgICBzd2l0Y2ggKHdvcmtVbml0U3RvcmUudHlwZSkge1xuICAgICAgY2FzZSAncHJlcmVuZGVyJzpcbiAgICAgIGNhc2UgJ3ByZXJlbmRlci1jbGllbnQnOlxuICAgICAgY2FzZSAncHJlcmVuZGVyLXBwcic6XG4gICAgICBjYXNlICdwcmVyZW5kZXItbGVnYWN5JzpcbiAgICAgICAgdGhyb3cgbmV3IEJhaWxvdXRUb0NTUkVycm9yKHJlYXNvbilcbiAgICAgIGRlZmF1bHQ6XG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOlsiYmFpbG91dFRvQ2xpZW50UmVuZGVyaW5nIiwicmVhc29uIiwid29ya1N0b3JlIiwid29ya0FzeW5jU3RvcmFnZSIsImdldFN0b3JlIiwiZm9yY2VTdGF0aWMiLCJ3b3JrVW5pdFN0b3JlIiwid29ya1VuaXRBc3luY1N0b3JhZ2UiLCJ0eXBlIiwiQmFpbG91dFRvQ1NSRXJyb3IiXSwibWFwcGluZ3MiOiI7OzsrQkFJZ0JBLDRCQUFBQTs7O2VBQUFBOzs7OEJBSmtCOzBDQUNEOzhDQUNJO0FBRTlCLFNBQVNBLHlCQUF5QkMsTUFBYztJQUNyRCxNQUFNQyxZQUFZQywwQkFBQUEsZ0JBQWdCLENBQUNDLFFBQVE7SUFFM0MsSUFBSUYsYUFBQUEsT0FBQUEsS0FBQUEsSUFBQUEsVUFBV0csV0FBVyxFQUFFO0lBRTVCLE1BQU1DLGdCQUFnQkMsOEJBQUFBLG9CQUFvQixDQUFDSCxRQUFRO0lBRW5ELElBQUlFLGVBQWU7UUFDakIsT0FBUUEsY0FBY0UsSUFBSTtZQUN4QixLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO2dCQUNILE1BQU0sT0FBQSxjQUE2QixDQUE3QixJQUFJQyxjQUFBQSxpQkFBaUIsQ0FBQ1IsU0FBdEIscUJBQUE7MkJBQUE7Z0NBQUE7a0NBQUE7Z0JBQTRCO1lBQ3BDO1FBQ0Y7SUFDRjtBQUNGIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDU1MzcsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvY2xpZW50L2NvbXBvbmVudHMvbmF2aWdhdGlvbi50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IEZsaWdodFJvdXRlclN0YXRlIH0gZnJvbSAnLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvdHlwZXMnXG5pbXBvcnQgdHlwZSB7IFBhcmFtcyB9IGZyb20gJy4uLy4uL3NlcnZlci9yZXF1ZXN0L3BhcmFtcydcblxuaW1wb3J0IHsgdXNlQ29udGV4dCwgdXNlTWVtbyB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHtcbiAgQXBwUm91dGVyQ29udGV4dCxcbiAgTGF5b3V0Um91dGVyQ29udGV4dCxcbiAgdHlwZSBBcHBSb3V0ZXJJbnN0YW5jZSxcbn0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQge1xuICBTZWFyY2hQYXJhbXNDb250ZXh0LFxuICBQYXRobmFtZUNvbnRleHQsXG4gIFBhdGhQYXJhbXNDb250ZXh0LFxufSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL2hvb2tzLWNsaWVudC1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHsgZ2V0U2VnbWVudFZhbHVlIH0gZnJvbSAnLi9yb3V0ZXItcmVkdWNlci9yZWR1Y2Vycy9nZXQtc2VnbWVudC12YWx1ZSdcbmltcG9ydCB7IFBBR0VfU0VHTUVOVF9LRVksIERFRkFVTFRfU0VHTUVOVF9LRVkgfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL3NlZ21lbnQnXG5pbXBvcnQgeyBSZWFkb25seVVSTFNlYXJjaFBhcmFtcyB9IGZyb20gJy4vbmF2aWdhdGlvbi5yZWFjdC1zZXJ2ZXInXG5cbmNvbnN0IHVzZUR5bmFtaWNSb3V0ZVBhcmFtcyA9XG4gIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnXG4gICAgPyAoXG4gICAgICAgIHJlcXVpcmUoJy4uLy4uL3NlcnZlci9hcHAtcmVuZGVyL2R5bmFtaWMtcmVuZGVyaW5nJykgYXMgdHlwZW9mIGltcG9ydCgnLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvZHluYW1pYy1yZW5kZXJpbmcnKVxuICAgICAgKS51c2VEeW5hbWljUm91dGVQYXJhbXNcbiAgICA6IHVuZGVmaW5lZFxuXG4vKipcbiAqIEEgW0NsaWVudCBDb21wb25lbnRdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL3JlbmRlcmluZy9jbGllbnQtY29tcG9uZW50cykgaG9va1xuICogdGhhdCBsZXRzIHlvdSAqcmVhZCogdGhlIGN1cnJlbnQgVVJMJ3Mgc2VhcmNoIHBhcmFtZXRlcnMuXG4gKlxuICogTGVhcm4gbW9yZSBhYm91dCBbYFVSTFNlYXJjaFBhcmFtc2Agb24gTUROXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvVVJMU2VhcmNoUGFyYW1zKVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogXCJ1c2UgY2xpZW50XCJcbiAqIGltcG9ydCB7IHVzZVNlYXJjaFBhcmFtcyB9IGZyb20gJ25leHQvbmF2aWdhdGlvbidcbiAqXG4gKiBleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBQYWdlKCkge1xuICogICBjb25zdCBzZWFyY2hQYXJhbXMgPSB1c2VTZWFyY2hQYXJhbXMoKVxuICogICBzZWFyY2hQYXJhbXMuZ2V0KCdmb28nKSAvLyByZXR1cm5zICdiYXInIHdoZW4gP2Zvbz1iYXJcbiAqICAgLy8gLi4uXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBSZWFkIG1vcmU6IFtOZXh0LmpzIERvY3M6IGB1c2VTZWFyY2hQYXJhbXNgXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYXBpLXJlZmVyZW5jZS9mdW5jdGlvbnMvdXNlLXNlYXJjaC1wYXJhbXMpXG4gKi9cbi8vIENsaWVudCBjb21wb25lbnRzIEFQSVxuZXhwb3J0IGZ1bmN0aW9uIHVzZVNlYXJjaFBhcmFtcygpOiBSZWFkb25seVVSTFNlYXJjaFBhcmFtcyB7XG4gIGNvbnN0IHNlYXJjaFBhcmFtcyA9IHVzZUNvbnRleHQoU2VhcmNoUGFyYW1zQ29udGV4dClcblxuICAvLyBJbiB0aGUgY2FzZSB3aGVyZSB0aGlzIGlzIGBudWxsYCwgdGhlIGNvbXBhdCB0eXBlcyBhZGRlZCBpblxuICAvLyBgbmV4dC1lbnYuZC50c2Agd2lsbCBhZGQgYSBuZXcgb3ZlcmxvYWQgdGhhdCBjaGFuZ2VzIHRoZSByZXR1cm4gdHlwZSB0b1xuICAvLyBpbmNsdWRlIGBudWxsYC5cbiAgY29uc3QgcmVhZG9ubHlTZWFyY2hQYXJhbXMgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoIXNlYXJjaFBhcmFtcykge1xuICAgICAgLy8gV2hlbiB0aGUgcm91dGVyIGlzIG5vdCByZWFkeSBpbiBwYWdlcywgd2Ugd29uJ3QgaGF2ZSB0aGUgc2VhcmNoIHBhcmFtc1xuICAgICAgLy8gYXZhaWxhYmxlLlxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFJlYWRvbmx5VVJMU2VhcmNoUGFyYW1zKHNlYXJjaFBhcmFtcylcbiAgfSwgW3NlYXJjaFBhcmFtc10pIGFzIFJlYWRvbmx5VVJMU2VhcmNoUGFyYW1zXG5cbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gQXN5bmNMb2NhbFN0b3JhZ2Ugc2hvdWxkIG5vdCBiZSBpbmNsdWRlZCBpbiB0aGUgY2xpZW50IGJ1bmRsZS5cbiAgICBjb25zdCB7IGJhaWxvdXRUb0NsaWVudFJlbmRlcmluZyB9ID1cbiAgICAgIHJlcXVpcmUoJy4vYmFpbG91dC10by1jbGllbnQtcmVuZGVyaW5nJykgYXMgdHlwZW9mIGltcG9ydCgnLi9iYWlsb3V0LXRvLWNsaWVudC1yZW5kZXJpbmcnKVxuICAgIC8vIFRPRE8tQVBQOiBoYW5kbGUgZHluYW1pYyA9ICdmb3JjZS1zdGF0aWMnIGhlcmUgYW5kIG9uIHRoZSBjbGllbnRcbiAgICBiYWlsb3V0VG9DbGllbnRSZW5kZXJpbmcoJ3VzZVNlYXJjaFBhcmFtcygpJylcbiAgfVxuXG4gIHJldHVybiByZWFkb25seVNlYXJjaFBhcmFtc1xufVxuXG4vKipcbiAqIEEgW0NsaWVudCBDb21wb25lbnRdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL3JlbmRlcmluZy9jbGllbnQtY29tcG9uZW50cykgaG9va1xuICogdGhhdCBsZXRzIHlvdSByZWFkIHRoZSBjdXJyZW50IFVSTCdzIHBhdGhuYW1lLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogXCJ1c2UgY2xpZW50XCJcbiAqIGltcG9ydCB7IHVzZVBhdGhuYW1lIH0gZnJvbSAnbmV4dC9uYXZpZ2F0aW9uJ1xuICpcbiAqIGV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFBhZ2UoKSB7XG4gKiAgY29uc3QgcGF0aG5hbWUgPSB1c2VQYXRobmFtZSgpIC8vIHJldHVybnMgXCIvZGFzaGJvYXJkXCIgb24gL2Rhc2hib2FyZD9mb289YmFyXG4gKiAgLy8gLi4uXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBSZWFkIG1vcmU6IFtOZXh0LmpzIERvY3M6IGB1c2VQYXRobmFtZWBdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9hcGktcmVmZXJlbmNlL2Z1bmN0aW9ucy91c2UtcGF0aG5hbWUpXG4gKi9cbi8vIENsaWVudCBjb21wb25lbnRzIEFQSVxuZXhwb3J0IGZ1bmN0aW9uIHVzZVBhdGhuYW1lKCk6IHN0cmluZyB7XG4gIHVzZUR5bmFtaWNSb3V0ZVBhcmFtcz8uKCd1c2VQYXRobmFtZSgpJylcblxuICAvLyBJbiB0aGUgY2FzZSB3aGVyZSB0aGlzIGlzIGBudWxsYCwgdGhlIGNvbXBhdCB0eXBlcyBhZGRlZCBpbiBgbmV4dC1lbnYuZC50c2BcbiAgLy8gd2lsbCBhZGQgYSBuZXcgb3ZlcmxvYWQgdGhhdCBjaGFuZ2VzIHRoZSByZXR1cm4gdHlwZSB0byBpbmNsdWRlIGBudWxsYC5cbiAgcmV0dXJuIHVzZUNvbnRleHQoUGF0aG5hbWVDb250ZXh0KSBhcyBzdHJpbmdcbn1cblxuLy8gQ2xpZW50IGNvbXBvbmVudHMgQVBJXG5leHBvcnQge1xuICBTZXJ2ZXJJbnNlcnRlZEhUTUxDb250ZXh0LFxuICB1c2VTZXJ2ZXJJbnNlcnRlZEhUTUwsXG59IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvc2VydmVyLWluc2VydGVkLWh0bWwuc2hhcmVkLXJ1bnRpbWUnXG5cbi8qKlxuICpcbiAqIFRoaXMgaG9vayBhbGxvd3MgeW91IHRvIHByb2dyYW1tYXRpY2FsbHkgY2hhbmdlIHJvdXRlcyBpbnNpZGUgW0NsaWVudCBDb21wb25lbnRdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL3JlbmRlcmluZy9jbGllbnQtY29tcG9uZW50cykuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBcInVzZSBjbGllbnRcIlxuICogaW1wb3J0IHsgdXNlUm91dGVyIH0gZnJvbSAnbmV4dC9uYXZpZ2F0aW9uJ1xuICpcbiAqIGV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFBhZ2UoKSB7XG4gKiAgY29uc3Qgcm91dGVyID0gdXNlUm91dGVyKClcbiAqICAvLyAuLi5cbiAqICByb3V0ZXIucHVzaCgnL2Rhc2hib2FyZCcpIC8vIE5hdmlnYXRlIHRvIC9kYXNoYm9hcmRcbiAqIH1cbiAqIGBgYFxuICpcbiAqIFJlYWQgbW9yZTogW05leHQuanMgRG9jczogYHVzZVJvdXRlcmBdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9hcGktcmVmZXJlbmNlL2Z1bmN0aW9ucy91c2Utcm91dGVyKVxuICovXG4vLyBDbGllbnQgY29tcG9uZW50cyBBUElcbmV4cG9ydCBmdW5jdGlvbiB1c2VSb3V0ZXIoKTogQXBwUm91dGVySW5zdGFuY2Uge1xuICBjb25zdCByb3V0ZXIgPSB1c2VDb250ZXh0KEFwcFJvdXRlckNvbnRleHQpXG4gIGlmIChyb3V0ZXIgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCBleHBlY3RlZCBhcHAgcm91dGVyIHRvIGJlIG1vdW50ZWQnKVxuICB9XG5cbiAgcmV0dXJuIHJvdXRlclxufVxuXG4vKipcbiAqIEEgW0NsaWVudCBDb21wb25lbnRdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL3JlbmRlcmluZy9jbGllbnQtY29tcG9uZW50cykgaG9va1xuICogdGhhdCBsZXRzIHlvdSByZWFkIGEgcm91dGUncyBkeW5hbWljIHBhcmFtcyBmaWxsZWQgaW4gYnkgdGhlIGN1cnJlbnQgVVJMLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogXCJ1c2UgY2xpZW50XCJcbiAqIGltcG9ydCB7IHVzZVBhcmFtcyB9IGZyb20gJ25leHQvbmF2aWdhdGlvbidcbiAqXG4gKiBleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBQYWdlKCkge1xuICogICAvLyBvbiAvZGFzaGJvYXJkL1t0ZWFtXSB3aGVyZSBwYXRobmFtZSBpcyAvZGFzaGJvYXJkL25leHRqc1xuICogICBjb25zdCB7IHRlYW0gfSA9IHVzZVBhcmFtcygpIC8vIHRlYW0gPT09IFwibmV4dGpzXCJcbiAqIH1cbiAqIGBgYFxuICpcbiAqIFJlYWQgbW9yZTogW05leHQuanMgRG9jczogYHVzZVBhcmFtc2BdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9hcGktcmVmZXJlbmNlL2Z1bmN0aW9ucy91c2UtcGFyYW1zKVxuICovXG4vLyBDbGllbnQgY29tcG9uZW50cyBBUElcbmV4cG9ydCBmdW5jdGlvbiB1c2VQYXJhbXM8VCBleHRlbmRzIFBhcmFtcyA9IFBhcmFtcz4oKTogVCB7XG4gIHVzZUR5bmFtaWNSb3V0ZVBhcmFtcz8uKCd1c2VQYXJhbXMoKScpXG5cbiAgcmV0dXJuIHVzZUNvbnRleHQoUGF0aFBhcmFtc0NvbnRleHQpIGFzIFRcbn1cblxuLyoqIEdldCB0aGUgY2Fub25pY2FsIHBhcmFtZXRlcnMgZnJvbSB0aGUgY3VycmVudCBsZXZlbCB0byB0aGUgbGVhZiBub2RlLiAqL1xuLy8gQ2xpZW50IGNvbXBvbmVudHMgQVBJXG5mdW5jdGlvbiBnZXRTZWxlY3RlZExheW91dFNlZ21lbnRQYXRoKFxuICB0cmVlOiBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgcGFyYWxsZWxSb3V0ZUtleTogc3RyaW5nLFxuICBmaXJzdCA9IHRydWUsXG4gIHNlZ21lbnRQYXRoOiBzdHJpbmdbXSA9IFtdXG4pOiBzdHJpbmdbXSB7XG4gIGxldCBub2RlOiBGbGlnaHRSb3V0ZXJTdGF0ZVxuICBpZiAoZmlyc3QpIHtcbiAgICAvLyBVc2UgdGhlIHByb3ZpZGVkIHBhcmFsbGVsIHJvdXRlIGtleSBvbiB0aGUgZmlyc3QgcGFyYWxsZWwgcm91dGVcbiAgICBub2RlID0gdHJlZVsxXVtwYXJhbGxlbFJvdXRlS2V5XVxuICB9IGVsc2Uge1xuICAgIC8vIEFmdGVyIGZpcnN0IHBhcmFsbGVsIHJvdXRlIHByZWZlciBjaGlsZHJlbiwgaWYgdGhlcmUncyBubyBjaGlsZHJlbiBwaWNrIHRoZSBmaXJzdCBwYXJhbGxlbCByb3V0ZS5cbiAgICBjb25zdCBwYXJhbGxlbFJvdXRlcyA9IHRyZWVbMV1cbiAgICBub2RlID0gcGFyYWxsZWxSb3V0ZXMuY2hpbGRyZW4gPz8gT2JqZWN0LnZhbHVlcyhwYXJhbGxlbFJvdXRlcylbMF1cbiAgfVxuXG4gIGlmICghbm9kZSkgcmV0dXJuIHNlZ21lbnRQYXRoXG4gIGNvbnN0IHNlZ21lbnQgPSBub2RlWzBdXG5cbiAgbGV0IHNlZ21lbnRWYWx1ZSA9IGdldFNlZ21lbnRWYWx1ZShzZWdtZW50KVxuXG4gIGlmICghc2VnbWVudFZhbHVlIHx8IHNlZ21lbnRWYWx1ZS5zdGFydHNXaXRoKFBBR0VfU0VHTUVOVF9LRVkpKSB7XG4gICAgcmV0dXJuIHNlZ21lbnRQYXRoXG4gIH1cblxuICBzZWdtZW50UGF0aC5wdXNoKHNlZ21lbnRWYWx1ZSlcblxuICByZXR1cm4gZ2V0U2VsZWN0ZWRMYXlvdXRTZWdtZW50UGF0aChcbiAgICBub2RlLFxuICAgIHBhcmFsbGVsUm91dGVLZXksXG4gICAgZmFsc2UsXG4gICAgc2VnbWVudFBhdGhcbiAgKVxufVxuXG4vKipcbiAqIEEgW0NsaWVudCBDb21wb25lbnRdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL3JlbmRlcmluZy9jbGllbnQtY29tcG9uZW50cykgaG9va1xuICogdGhhdCBsZXRzIHlvdSByZWFkIHRoZSBhY3RpdmUgcm91dGUgc2VnbWVudHMgKipiZWxvdyoqIHRoZSBMYXlvdXQgaXQgaXMgY2FsbGVkIGZyb20uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiAndXNlIGNsaWVudCdcbiAqXG4gKiBpbXBvcnQgeyB1c2VTZWxlY3RlZExheW91dFNlZ21lbnRzIH0gZnJvbSAnbmV4dC9uYXZpZ2F0aW9uJ1xuICpcbiAqIGV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEV4YW1wbGVDbGllbnRDb21wb25lbnQoKSB7XG4gKiAgIGNvbnN0IHNlZ21lbnRzID0gdXNlU2VsZWN0ZWRMYXlvdXRTZWdtZW50cygpXG4gKlxuICogICByZXR1cm4gKFxuICogICAgIDx1bD5cbiAqICAgICAgIHtzZWdtZW50cy5tYXAoKHNlZ21lbnQsIGluZGV4KSA9PiAoXG4gKiAgICAgICAgIDxsaSBrZXk9e2luZGV4fT57c2VnbWVudH08L2xpPlxuICogICAgICAgKSl9XG4gKiAgICAgPC91bD5cbiAqICAgKVxuICogfVxuICogYGBgXG4gKlxuICogUmVhZCBtb3JlOiBbTmV4dC5qcyBEb2NzOiBgdXNlU2VsZWN0ZWRMYXlvdXRTZWdtZW50c2BdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9hcGktcmVmZXJlbmNlL2Z1bmN0aW9ucy91c2Utc2VsZWN0ZWQtbGF5b3V0LXNlZ21lbnRzKVxuICovXG4vLyBDbGllbnQgY29tcG9uZW50cyBBUElcbmV4cG9ydCBmdW5jdGlvbiB1c2VTZWxlY3RlZExheW91dFNlZ21lbnRzKFxuICBwYXJhbGxlbFJvdXRlS2V5OiBzdHJpbmcgPSAnY2hpbGRyZW4nXG4pOiBzdHJpbmdbXSB7XG4gIHVzZUR5bmFtaWNSb3V0ZVBhcmFtcz8uKCd1c2VTZWxlY3RlZExheW91dFNlZ21lbnRzKCknKVxuXG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KExheW91dFJvdXRlckNvbnRleHQpXG4gIC8vIEB0cy1leHBlY3QtZXJyb3IgVGhpcyBvbmx5IGhhcHBlbnMgaW4gYHBhZ2VzYC4gVHlwZSBpcyBvdmVyd3JpdHRlbiBpbiBuYXZpZ2F0aW9uLmQudHNcbiAgaWYgKCFjb250ZXh0KSByZXR1cm4gbnVsbFxuXG4gIHJldHVybiBnZXRTZWxlY3RlZExheW91dFNlZ21lbnRQYXRoKGNvbnRleHQucGFyZW50VHJlZSwgcGFyYWxsZWxSb3V0ZUtleSlcbn1cblxuLyoqXG4gKiBBIFtDbGllbnQgQ29tcG9uZW50XShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYnVpbGRpbmcteW91ci1hcHBsaWNhdGlvbi9yZW5kZXJpbmcvY2xpZW50LWNvbXBvbmVudHMpIGhvb2tcbiAqIHRoYXQgbGV0cyB5b3UgcmVhZCB0aGUgYWN0aXZlIHJvdXRlIHNlZ21lbnQgKipvbmUgbGV2ZWwgYmVsb3cqKiB0aGUgTGF5b3V0IGl0IGlzIGNhbGxlZCBmcm9tLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogJ3VzZSBjbGllbnQnXG4gKiBpbXBvcnQgeyB1c2VTZWxlY3RlZExheW91dFNlZ21lbnQgfSBmcm9tICduZXh0L25hdmlnYXRpb24nXG4gKlxuICogZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRXhhbXBsZUNsaWVudENvbXBvbmVudCgpIHtcbiAqICAgY29uc3Qgc2VnbWVudCA9IHVzZVNlbGVjdGVkTGF5b3V0U2VnbWVudCgpXG4gKlxuICogICByZXR1cm4gPHA+QWN0aXZlIHNlZ21lbnQ6IHtzZWdtZW50fTwvcD5cbiAqIH1cbiAqIGBgYFxuICpcbiAqIFJlYWQgbW9yZTogW05leHQuanMgRG9jczogYHVzZVNlbGVjdGVkTGF5b3V0U2VnbWVudGBdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9hcGktcmVmZXJlbmNlL2Z1bmN0aW9ucy91c2Utc2VsZWN0ZWQtbGF5b3V0LXNlZ21lbnQpXG4gKi9cbi8vIENsaWVudCBjb21wb25lbnRzIEFQSVxuZXhwb3J0IGZ1bmN0aW9uIHVzZVNlbGVjdGVkTGF5b3V0U2VnbWVudChcbiAgcGFyYWxsZWxSb3V0ZUtleTogc3RyaW5nID0gJ2NoaWxkcmVuJ1xuKTogc3RyaW5nIHwgbnVsbCB7XG4gIHVzZUR5bmFtaWNSb3V0ZVBhcmFtcz8uKCd1c2VTZWxlY3RlZExheW91dFNlZ21lbnQoKScpXG5cbiAgY29uc3Qgc2VsZWN0ZWRMYXlvdXRTZWdtZW50cyA9IHVzZVNlbGVjdGVkTGF5b3V0U2VnbWVudHMocGFyYWxsZWxSb3V0ZUtleSlcblxuICBpZiAoIXNlbGVjdGVkTGF5b3V0U2VnbWVudHMgfHwgc2VsZWN0ZWRMYXlvdXRTZWdtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgY29uc3Qgc2VsZWN0ZWRMYXlvdXRTZWdtZW50ID1cbiAgICBwYXJhbGxlbFJvdXRlS2V5ID09PSAnY2hpbGRyZW4nXG4gICAgICA/IHNlbGVjdGVkTGF5b3V0U2VnbWVudHNbMF1cbiAgICAgIDogc2VsZWN0ZWRMYXlvdXRTZWdtZW50c1tzZWxlY3RlZExheW91dFNlZ21lbnRzLmxlbmd0aCAtIDFdXG5cbiAgLy8gaWYgdGhlIGRlZmF1bHQgc2xvdCBpcyBzaG93aW5nLCB3ZSByZXR1cm4gbnVsbCBzaW5jZSBpdCdzIG5vdCB0ZWNobmljYWxseSBcInNlbGVjdGVkXCIgKGl0J3MgYSBmYWxsYmFjaylcbiAgLy8gYW5kIHJldHVybmluZyBhbiBpbnRlcm5hbCB2YWx1ZSBsaWtlIGBfX0RFRkFVTFRfX2Agd291bGQgYmUgY29uZnVzaW5nLlxuICByZXR1cm4gc2VsZWN0ZWRMYXlvdXRTZWdtZW50ID09PSBERUZBVUxUX1NFR01FTlRfS0VZXG4gICAgPyBudWxsXG4gICAgOiBzZWxlY3RlZExheW91dFNlZ21lbnRcbn1cblxuLy8gU2hhcmVkIGNvbXBvbmVudHMgQVBJc1xuZXhwb3J0IHtcbiAgbm90Rm91bmQsXG4gIGZvcmJpZGRlbixcbiAgdW5hdXRob3JpemVkLFxuICByZWRpcmVjdCxcbiAgcGVybWFuZW50UmVkaXJlY3QsXG4gIFJlZGlyZWN0VHlwZSxcbiAgUmVhZG9ubHlVUkxTZWFyY2hQYXJhbXMsXG4gIHVuc3RhYmxlX3JldGhyb3csXG59IGZyb20gJy4vbmF2aWdhdGlvbi5yZWFjdC1zZXJ2ZXInXG4iXSwibmFtZXMiOlsiUmVhZG9ubHlVUkxTZWFyY2hQYXJhbXMiLCJSZWRpcmVjdFR5cGUiLCJTZXJ2ZXJJbnNlcnRlZEhUTUxDb250ZXh0IiwiZm9yYmlkZGVuIiwibm90Rm91bmQiLCJwZXJtYW5lbnRSZWRpcmVjdCIsInJlZGlyZWN0IiwidW5hdXRob3JpemVkIiwidW5zdGFibGVfcmV0aHJvdyIsInVzZVBhcmFtcyIsInVzZVBhdGhuYW1lIiwidXNlUm91dGVyIiwidXNlU2VhcmNoUGFyYW1zIiwidXNlU2VsZWN0ZWRMYXlvdXRTZWdtZW50IiwidXNlU2VsZWN0ZWRMYXlvdXRTZWdtZW50cyIsInVzZVNlcnZlckluc2VydGVkSFRNTCIsInVzZUR5bmFtaWNSb3V0ZVBhcmFtcyIsIndpbmRvdyIsInJlcXVpcmUiLCJ1bmRlZmluZWQiLCJzZWFyY2hQYXJhbXMiLCJ1c2VDb250ZXh0IiwiU2VhcmNoUGFyYW1zQ29udGV4dCIsInJlYWRvbmx5U2VhcmNoUGFyYW1zIiwidXNlTWVtbyIsImJhaWxvdXRUb0NsaWVudFJlbmRlcmluZyIsIlBhdGhuYW1lQ29udGV4dCIsInJvdXRlciIsIkFwcFJvdXRlckNvbnRleHQiLCJFcnJvciIsIlBhdGhQYXJhbXNDb250ZXh0IiwiZ2V0U2VsZWN0ZWRMYXlvdXRTZWdtZW50UGF0aCIsInRyZWUiLCJwYXJhbGxlbFJvdXRlS2V5IiwiZmlyc3QiLCJzZWdtZW50UGF0aCIsIm5vZGUiLCJwYXJhbGxlbFJvdXRlcyIsImNoaWxkcmVuIiwiT2JqZWN0IiwidmFsdWVzIiwic2VnbWVudCIsInNlZ21lbnRWYWx1ZSIsImdldFNlZ21lbnRWYWx1ZSIsInN0YXJ0c1dpdGgiLCJQQUdFX1NFR01FTlRfS0VZIiwicHVzaCIsImNvbnRleHQiLCJMYXlvdXRSb3V0ZXJDb250ZXh0IiwicGFyZW50VHJlZSIsInNlbGVjdGVkTGF5b3V0U2VnbWVudHMiLCJsZW5ndGgiLCJzZWxlY3RlZExheW91dFNlZ21lbnQiLCJERUZBVUxUX1NFR01FTlRfS0VZIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBMFJFQSx1QkFBdUIsRUFBQTtlQUF2QkEsdUJBQUFBLHVCQUF1Qjs7SUFEdkJDLFlBQVksRUFBQTtlQUFaQSx1QkFBQUEsWUFBWTs7SUFwTFpDLHlCQUF5QixFQUFBO2VBQXpCQSxpQ0FBQUEseUJBQXlCOztJQWdMekJDLFNBQVMsRUFBQTtlQUFUQSx1QkFBQUEsU0FBUzs7SUFEVEMsUUFBUSxFQUFBO2VBQVJBLHVCQUFBQSxRQUFROztJQUlSQyxpQkFBaUIsRUFBQTtlQUFqQkEsdUJBQUFBLGlCQUFpQjs7SUFEakJDLFFBQVEsRUFBQTtlQUFSQSx1QkFBQUEsUUFBUTs7SUFEUkMsWUFBWSxFQUFBO2VBQVpBLHVCQUFBQSxZQUFZOztJQUtaQyxnQkFBZ0IsRUFBQTtlQUFoQkEsdUJBQUFBLGdCQUFnQjs7SUFwSUZDLFNBQVMsRUFBQTtlQUFUQTs7SUE1REFDLFdBQVcsRUFBQTtlQUFYQTs7SUFpQ0FDLFNBQVMsRUFBQTtlQUFUQTs7SUE5RUFDLGVBQWUsRUFBQTtlQUFmQTs7SUE2TUFDLHdCQUF3QixFQUFBO2VBQXhCQTs7SUEvQkFDLHlCQUF5QixFQUFBO2VBQXpCQTs7SUF0SGRDLHFCQUFxQixFQUFBO2VBQXJCQSxpQ0FBQUEscUJBQXFCOzs7dUJBbkdhOytDQUs3QjtpREFLQTtpQ0FDeUI7eUJBQ3NCO3VDQUNkO2lEQXVGakM7QUFyRlAsTUFBTUMsd0JBQ0osT0FBT0MsV0FBVyxxQkFFWkMsUUFBUSxrSEFD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Z0JBQXFDO0lBQXJDQSxJQUFBQSxxQkFBQUEsS0FBQUEsR0FBQUEsbUJBQTJCO0lBRTNCakIseUJBQUFBLE9BQUFBLEtBQUFBLElBQUFBLHNCQUF3QjtJQUV4QixNQUFNa0MseUJBQXlCcEMsMEJBQTBCbUI7SUFFekQsSUFBSSxDQUFDaUIsMEJBQTBCQSx1QkFBdUJDLE1BQU0sS0FBSyxHQUFHO1FBQ2xFLE9BQU87SUFDVDtJQUVBLE1BQU1DLHdCQUNKbkIscUJBQXFCLGFBQ2pCaUIsc0JBQXNCLENBQUMsRUFBRSxHQUN6QkEsc0JBQXNCLENBQUNBLHVCQUF1QkMsTUFBTSxHQUFHLEVBQUU7SUFFL0QseUdBQXlHO0lBQ3pHLHlFQUF5RTtJQUN6RSxPQUFPQywwQkFBMEJDLFNBQUFBLG1CQUFtQixHQUNoRCxPQUNBRDtBQUNOIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDU3MjIsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvY2xpZW50L2NvbXBvbmVudHMvcmVkaXJlY3QtYm91bmRhcnkudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHR5cGUgeyBBcHBSb3V0ZXJJbnN0YW5jZSB9IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHsgdXNlUm91dGVyIH0gZnJvbSAnLi9uYXZpZ2F0aW9uJ1xuaW1wb3J0IHsgZ2V0UmVkaXJlY3RUeXBlRnJvbUVycm9yLCBnZXRVUkxGcm9tUmVkaXJlY3RFcnJvciB9IGZyb20gJy4vcmVkaXJlY3QnXG5pbXBvcnQgeyBSZWRpcmVjdFR5cGUsIGlzUmVkaXJlY3RFcnJvciB9IGZyb20gJy4vcmVkaXJlY3QtZXJyb3InXG5cbmludGVyZmFjZSBSZWRpcmVjdEJvdW5kYXJ5UHJvcHMge1xuICByb3V0ZXI6IEFwcFJvdXRlckluc3RhbmNlXG4gIGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGVcbn1cblxuZnVuY3Rpb24gSGFuZGxlUmVkaXJlY3Qoe1xuICByZWRpcmVjdCxcbiAgcmVzZXQsXG4gIHJlZGlyZWN0VHlwZSxcbn06IHtcbiAgcmVkaXJlY3Q6IHN0cmluZ1xuICByZWRpcmVjdFR5cGU6IFJlZGlyZWN0VHlwZVxuICByZXNldDogKCkgPT4gdm9pZFxufSkge1xuICBjb25zdCByb3V0ZXIgPSB1c2VSb3V0ZXIoKVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgUmVhY3Quc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgIGlmIChyZWRpcmVjdFR5cGUgPT09IFJlZGlyZWN0VHlwZS5wdXNoKSB7XG4gICAgICAgIHJvdXRlci5wdXNoKHJlZGlyZWN0LCB7fSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvdXRlci5yZXBsYWNlKHJlZGlyZWN0LCB7fSlcbiAgICAgIH1cbiAgICAgIHJlc2V0KClcbiAgICB9KVxuICB9LCBbcmVkaXJlY3QsIHJlZGlyZWN0VHlwZSwgcmVzZXQsIHJvdXRlcl0pXG5cbiAgcmV0dXJuIG51bGxcbn1cblxuZXhwb3J0IGNsYXNzIFJlZGlyZWN0RXJyb3JCb3VuZGFyeSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxcbiAgUmVkaXJlY3RCb3VuZGFyeVByb3BzLFxuICB7IHJlZGlyZWN0OiBzdHJpbmcgfCBudWxsOyByZWRpcmVjdFR5cGU6IFJlZGlyZWN0VHlwZSB8IG51bGwgfVxuPiB7XG4gIGNvbnN0cnVjdG9yKHByb3BzOiBSZWRpcmVjdEJvdW5kYXJ5UHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcylcbiAgICB0aGlzLnN0YXRlID0geyByZWRpcmVjdDogbnVsbCwgcmVkaXJlY3RUeXBlOiBudWxsIH1cbiAgfVxuXG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoZXJyb3I6IGFueSkge1xuICAgIGlmIChpc1JlZGlyZWN0RXJyb3IoZXJyb3IpKSB7XG4gICAgICBjb25zdCB1cmwgPSBnZXRVUkxGcm9tUmVkaXJlY3RFcnJvcihlcnJvcilcbiAgICAgIGNvbnN0IHJlZGlyZWN0VHlwZSA9IGdldFJlZGlyZWN0VHlwZUZyb21FcnJvcihlcnJvcilcbiAgICAgIHJldHVybiB7IHJlZGlyZWN0OiB1cmwsIHJlZGlyZWN0VHlwZSB9XG4gICAgfVxuICAgIC8vIFJlLXRocm93IGlmIGVycm9yIGlzIG5vdCBmb3IgcmVkaXJlY3RcbiAgICB0aHJvdyBlcnJvclxuICB9XG5cbiAgLy8gRXhwbGljaXQgdHlwZSBpcyBuZWVkZWQgdG8gYXZvaWQgdGhlIGdlbmVyYXRlZCBgLmQudHNgIGhhdmluZyBhIHdpZGUgcmV0dXJuIHR5cGUgdGhhdCBjb3VsZCBiZSBzcGVjaWZpYyB0byB0aGUgYEB0eXBlcy9yZWFjdGAgdmVyc2lvbi5cbiAgcmVuZGVyKCk6IFJlYWN0LlJlYWN0Tm9kZSB7XG4gICAgY29uc3QgeyByZWRpcmVjdCwgcmVkaXJlY3RUeXBlIH0gPSB0aGlzLnN0YXRlXG4gICAgaWYgKHJlZGlyZWN0ICE9PSBudWxsICYmIHJlZGlyZWN0VHlwZSAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgPEhhbmRsZVJlZGlyZWN0XG4gICAgICAgICAgcmVkaXJlY3Q9e3JlZGlyZWN0fVxuICAgICAgICAgIHJlZGlyZWN0VHlwZT17cmVkaXJlY3RUeXBlfVxuICAgICAgICAgIHJlc2V0PXsoKSA9PiB0aGlzLnNldFN0YXRlKHsgcmVkaXJlY3Q6IG51bGwgfSl9XG4gICAgICAgIC8+XG4gICAgICApXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW5cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gUmVkaXJlY3RCb3VuZGFyeSh7IGNoaWxkcmVuIH06IHsgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZSB9KSB7XG4gIGNvbnN0IHJvdXRlciA9IHVzZVJvdXRlcigpXG4gIHJldHVybiAoXG4gICAgPFJlZGlyZWN0RXJyb3JCb3VuZGFyeSByb3V0ZXI9e3JvdXRlcn0+e2NoaWxkcmVufTwvUmVkaXJlY3RFcnJvckJvdW5kYXJ5PlxuICApXG59XG4iXSwibmFtZXMiOlsiUmVkaXJlY3RCb3VuZGFyeSIsIlJlZGlyZWN0RXJyb3JCb3VuZGFyeSIsIkhhbmRsZVJlZGlyZWN0IiwicmVkaXJlY3QiLCJyZXNldCIsInJlZGlyZWN0VHlwZSIsInJvdXRlciIsInVzZVJvdXRlciIsInVzZUVmZmVjdCIsIlJlYWN0Iiwic3RhcnRUcmFuc2l0aW9uIiwiUmVkaXJlY3RUeXBlIiwicHVzaCIsInJlcGxhY2UiLCJDb21wb25lbnQiLCJnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IiLCJlcnJvciIsImlzUmVkaXJlY3RFcnJvciIsInVybCIsImdldFVSTEZyb21SZWRpcmVjdEVycm9yIiwiZ2V0UmVkaXJlY3RUeXBlRnJvbUVycm9yIiwicmVuZGVyIiwic3RhdGUiLCJzZXRTdGF0ZSIsInByb3BzIiwiY2hpbGRyZW4iLCJjb25zdHJ1Y3RvciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7SUF5RWdCQSxnQkFBZ0IsRUFBQTtlQUFoQkE7O0lBcENIQyxxQkFBcUIsRUFBQTtlQUFyQkE7Ozs7O2lFQXBDb0I7NEJBRVA7MEJBQ3dDOytCQUNwQjtBQU85QyxTQUFTQyxlQUFlLEtBUXZCO0lBUnVCLElBQUEsRUFDdEJDLFFBQVEsRUFDUkMsS0FBSyxFQUNMQyxZQUFZLEVBS2IsR0FSdUI7SUFTdEIsTUFBTUMsU0FBU0MsQ0FBQUEsR0FBQUEsWUFBQUEsU0FBUztJQUV4QkMsQ0FBQUEsR0FBQUEsT0FBQUEsU0FBUyxFQUFDO1FBQ1JDLE9BQUFBLE9BQUssQ0FBQ0MsZUFBZSxDQUFDO1lBQ3BCLElBQUlMLGlCQUFpQk0sZUFBQUEsWUFBWSxDQUFDQyxJQUFJLEVBQUU7Z0JBQ3RDTixPQUFPTSxJQUFJLENBQUNULFVBQVUsQ0FBQztZQUN6QixPQUFPO2dCQUNMRyxPQUFPTyxPQUFPLENBQUNWLFVBQVUsQ0FBQztZQUM1QjtZQUNBQztRQUNGO0lBQ0YsR0FBRztRQUFDRDtRQUFVRTtRQUFjRDtRQUFPRTtLQUFPO0lBRTFDLE9BQU87QUFDVDtBQUVPLE1BQU1MLDhCQUE4QlEsT0FBQUEsT0FBSyxDQUFDSyxTQUFTO0lBU3hELE9BQU9DLHlCQUF5QkMsS0FBVSxFQUFFO1FBQzFDLElBQUlDLENBQUFBLEdBQUFBLGVBQUFBLGVBQWUsRUFBQ0QsUUFBUTtZQUMxQixNQUFNRSxNQUFNQyxDQUFBQSxHQUFBQSxVQUFBQSx1QkFBdUIsRUFBQ0g7WUFDcEMsTUFBTVgsZUFBZWUsQ0FBQUEsR0FBQUEsVUFBQUEsd0JBQXdCLEVBQUNKO1lBQzlDLE9BQU87Z0JBQUViLFVBQVVlO2dCQUFLYjtZQUFhO1FBQ3ZDO1FBQ0Esd0NBQXdDO1FBQ3hDLE1BQU1XO0lBQ1I7SUFFQSx5SUFBeUk7SUFDeklLLFNBQTBCO1FBQ3hCLE1BQU0sRUFBRWxCLFFBQVEsRUFBRUUsWUFBWSxFQUFFLEdBQUcsSUFBSSxDQUFDaUIsS0FBSztRQUM3QyxJQUFJbkIsYUFBYSxRQUFRRSxpQkFBaUIsTUFBTTtZQUM5QyxPQUFBLFdBQUEsR0FDRSxDQUFBLEdBQUEsWUFBQSxHQUFBLEVBQUNILGdCQUFBQTtnQkFDQ0MsVUFBVUE7Z0JBQ1ZFLGNBQWNBO2dCQUNkRCxPQUFPLElBQU0sSUFBSSxDQUFDbUIsUUFBUSxDQUFDO3dCQUFFcEIsVUFBVTtvQkFBSzs7UUFHbEQ7UUFFQSxPQUFPLElBQUksQ0FBQ3FCLEtBQUssQ0FBQ0MsUUFBUTtJQUM1QjtJQTdCQUMsWUFBWUYsS0FBNEIsQ0FBRTtRQUN4QyxLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDRixLQUFLLEdBQUc7WUFBRW5CLFVBQVU7WUFBTUUsY0FBYztRQUFLO0lBQ3BEO0FBMkJGO0FBRU8sU0FBU0wsaUJBQWlCLEtBQTJDO0lBQTNDLElBQUEsRUFBRXlCLFFBQVEsRUFBaUMsR0FBM0M7SUFDL0IsTUFBTW5CLFNBQVNDLENBQUFBLEdBQUFBLFlBQUFBLFNBQVM7SUFDeEIsT0FBQSxXQUFBLEdBQ0UsQ0FBQSxHQUFBLFlBQUEsR0FBQSxFQUFDTix1QkFBQUE7UUFBc0JLLFFBQVFBO2tCQUFTbUI7O0FBRTVDIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDU4MjUsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvZmluZC1oZWFkLWluLWNhY2hlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgRmxpZ2h0Um91dGVyU3RhdGUgfSBmcm9tICcuLi8uLi8uLi8uLi9zZXJ2ZXIvYXBwLXJlbmRlci90eXBlcydcbmltcG9ydCB0eXBlIHsgQ2FjaGVOb2RlIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgeyBERUZBVUxUX1NFR01FTlRfS0VZIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL2xpYi9zZWdtZW50J1xuaW1wb3J0IHsgY3JlYXRlUm91dGVyQ2FjaGVLZXkgfSBmcm9tICcuLi9jcmVhdGUtcm91dGVyLWNhY2hlLWtleSdcblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRIZWFkSW5DYWNoZShcbiAgY2FjaGU6IENhY2hlTm9kZSxcbiAgcGFyYWxsZWxSb3V0ZXM6IEZsaWdodFJvdXRlclN0YXRlWzFdXG4pOiBbQ2FjaGVOb2RlLCBzdHJpbmddIHwgbnVsbCB7XG4gIHJldHVybiBmaW5kSGVhZEluQ2FjaGVJbXBsKGNhY2hlLCBwYXJhbGxlbFJvdXRlcywgJycpXG59XG5cbmZ1bmN0aW9uIGZpbmRIZWFkSW5DYWNoZUltcGwoXG4gIGNhY2hlOiBDYWNoZU5vZGUsXG4gIHBhcmFsbGVsUm91dGVzOiBGbGlnaHRSb3V0ZXJTdGF0ZVsxXSxcbiAga2V5UHJlZml4OiBzdHJpbmdcbik6IFtDYWNoZU5vZGUsIHN0cmluZ10gfCBudWxsIHtcbiAgY29uc3QgaXNMYXN0SXRlbSA9IE9iamVjdC5rZXlzKHBhcmFsbGVsUm91dGVzKS5sZW5ndGggPT09IDBcbiAgaWYgKGlzTGFzdEl0ZW0pIHtcbiAgICAvLyBSZXR1cm5zIHRoZSBlbnRpcmUgQ2FjaGUgTm9kZSBvZiB0aGUgc2VnbWVudCB3aG9zZSBoZWFkIHdlIHdpbGwgcmVuZGVyLlxuICAgIHJldHVybiBbY2FjaGUsIGtleVByZWZpeF1cbiAgfVxuXG4gIC8vIEZpcnN0IHRyeSB0aGUgJ2NoaWxkcmVuJyBwYXJhbGxlbCByb3V0ZSBpZiBpdCBleGlzdHNcbiAgLy8gd2hlbiBzdGFydGluZyBmcm9tIHRoZSBcInJvb3RcIiwgdGhpcyBjb3JyZXNwb25kcyB3aXRoIHRoZSBtYWluIHBhZ2UgY29tcG9uZW50XG4gIGNvbnN0IHBhcmFsbGVsUm91dGVzS2V5cyA9IE9iamVjdC5rZXlzKHBhcmFsbGVsUm91dGVzKS5maWx0ZXIoXG4gICAgKGtleSkgPT4ga2V5ICE9PSAnY2hpbGRyZW4nXG4gIClcblxuICAvLyBpZiB3ZSBhcmUgYXQgdGhlIHJvb3QsIHdlIG5lZWQgdG8gY2hlY2sgdGhlIGNoaWxkcmVuIHNsb3QgZmlyc3RcbiAgaWYgKCdjaGlsZHJlbicgaW4gcGFyYWxsZWxSb3V0ZXMpIHtcbiAgICBwYXJhbGxlbFJvdXRlc0tleXMudW5zaGlmdCgnY2hpbGRyZW4nKVxuICB9XG5cbiAgZm9yIChjb25zdCBrZXkgb2YgcGFyYWxsZWxSb3V0ZXNLZXlzKSB7XG4gICAgY29uc3QgW3NlZ21lbnQsIGNoaWxkUGFyYWxsZWxSb3V0ZXNdID0gcGFyYWxsZWxSb3V0ZXNba2V5XVxuICAgIC8vIElmIHRoZSBwYXJhbGxlbCBpcyBub3QgbWF0Y2hlZCBhbmQgdXNpbmcgdGhlIGRlZmF1bHQgc2VnbWVudCxcbiAgICAvLyBza2lwIHNlYXJjaGluZyB0aGUgaGVhZCBmcm9tIGl0LlxuICAgIGlmIChzZWdtZW50ID09PSBERUZBVUxUX1NFR01FTlRfS0VZKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBjb25zdCBjaGlsZFNlZ21lbnRNYXAgPSBjYWNoZS5wYXJhbGxlbFJvdXRlcy5nZXQoa2V5KVxuICAgIGlmICghY2hpbGRTZWdtZW50TWFwKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGNvbnN0IGNhY2hlS2V5ID0gY3JlYXRlUm91dGVyQ2FjaGVLZXkoc2VnbWVudClcblxuICAgIGNvbnN0IGNhY2hlTm9kZSA9IGNoaWxkU2VnbWVudE1hcC5nZXQoY2FjaGVLZXkpXG4gICAgaWYgKCFjYWNoZU5vZGUpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgY29uc3QgaXRlbSA9IGZpbmRIZWFkSW5DYWNoZUltcGwoXG4gICAgICBjYWNoZU5vZGUsXG4gICAgICBjaGlsZFBhcmFsbGVsUm91dGVzLFxuICAgICAga2V5UHJlZml4ICsgJy8nICsgY2FjaGVLZXlcbiAgICApXG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIHJldHVybiBpdGVtXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGxcbn1cbiJdLCJuYW1lcyI6WyJmaW5kSGVhZEluQ2FjaGUiLCJjYWNoZSIsInBhcmFsbGVsUm91dGVzIiwiZmluZEhlYWRJbkNhY2hlSW1wbCIsImtleVByZWZpeCIsImlzTGFzdEl0ZW0iLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIiwicGFyYWxsZWxSb3V0ZXNLZXlzIiwiZmlsdGVyIiwia2V5IiwidW5zaGlmdCIsInNlZ21lbnQiLCJjaGlsZFBhcmFsbGVsUm91dGVzIiwiREVGQVVMVF9TRUdNRU5UX0tFWSIsImNoaWxkU2VnbWVudE1hcCIsImdldCIsImNhY2hlS2V5IiwiY3JlYXRlUm91dGVyQ2FjaGVLZXkiLCJjYWNoZU5vZGUiLCJpdGVtIl0sIm1hcHBpbmdzIjoiOzs7K0JBS2dCQSxtQkFBQUE7OztlQUFBQTs7O3lCQUhvQjtzQ0FDQztBQUU5QixTQUFTQSxnQkFDZEMsS0FBZ0IsRUFDaEJDLGNBQW9DO0lBRXBDLE9BQU9DLG9CQUFvQkYsT0FBT0MsZ0JBQWdCO0FBQ3BEO0FBRUEsU0FBU0Msb0JBQ1BGLEtBQWdCLEVBQ2hCQyxjQUFvQyxFQUNwQ0UsU0FBaUI7SUFFakIsTUFBTUMsYUFBYUMsT0FBT0MsSUFBSSxDQUFDTCxnQkFBZ0JNLE1BQU0sS0FBSztJQUMxRCxJQUFJSCxZQUFZO1FBQ2QsMEVBQTBFO1FBQzFFLE9BQU87WUFBQ0o7WUFBT0c7U0FBVTtJQUMzQjtJQUVBLHVEQUF1RDtJQUN2RCwrRUFBK0U7SUFDL0UsTUFBTUsscUJBQXFCSCxPQUFPQyxJQUFJLENBQUNMLGdCQUFnQlEsTUFBTSxDQUMzRCxDQUFDQyxNQUFRQSxRQUFRO0lBR25CLGtFQUFrRTtJQUNsRSxJQUFJLGNBQWNULGdCQUFnQjtRQUNoQ08sbUJBQW1CRyxPQUFPLENBQUM7SUFDN0I7SUFFQSxLQUFLLE1BQU1ELE9BQU9GLG1CQUFvQjtRQUNwQyxNQUFNLENBQUNJLFNBQVNDLG9CQUFvQixHQUFHWixjQUFjLENBQUNTLElBQUk7UUFDMUQsZ0VBQWdFO1FBQ2hFLG1DQUFtQztRQUNuQyxJQUFJRSxZQUFZRSxTQUFBQSxtQkFBbUIsRUFBRTtZQUNuQztRQUNGO1FBQ0EsTUFBTUMsa0JBQWtCZixNQUFNQyxjQUFjLENBQUNlLEdBQUcsQ0FBQ047UUFDakQsSUFBSSxDQUFDSyxpQkFBaUI7WUFDcEI7UUFDRjtRQUVBLE1BQU1FLFdBQVdDLENBQUFBLEdBQUFBLHNCQUFBQSxvQkFBb0IsRUFBQ047UUFFdEMsTUFBTU8sWUFBWUosZ0JBQWdCQyxHQUFHLENBQUNDO1FBQ3RDLElBQUksQ0FBQ0UsV0FBVztZQUNkO1FBQ0Y7UUFFQSxNQUFNQyxPQUFPbEIsb0JBQ1hpQixXQUNBTixxQkFDQVYsWUFBWSxNQUFNYztRQUVwQixJQUFJRyxNQUFNO1lBQ1IsT0FBT0E7UUFDVDtJQUNGO0lBRUEsT0FBTztBQUNUIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDU4OTEsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvY2xpZW50L2NvbXBvbmVudHMvdW5yZXNvbHZlZC10aGVuYWJsZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENyZWF0ZSBhIFwiVGhlbmFibGVcIiB0aGF0IGRvZXMgbm90IHJlc29sdmUuIFRoaXMgaXMgdXNlZCB0byBzdXNwZW5kIGluZGVmaW5pdGVseSB3aGVuIGRhdGEgaXMgbm90IGF2YWlsYWJsZSB5ZXQuXG4gKi9cbmV4cG9ydCBjb25zdCB1bnJlc29sdmVkVGhlbmFibGUgPSB7XG4gIHRoZW46ICgpID0+IHt9LFxufSBhcyBQcm9taXNlTGlrZTx2b2lkPlxuIl0sIm5hbWVzIjpbInVucmVzb2x2ZWRUaGVuYWJsZSIsInRoZW4iXSwibWFwcGluZ3MiOiJBQUFBOztDQUVDOzs7K0JBQ1lBLHNCQUFBQTs7O2VBQUFBOzs7QUFBTixNQUFNQSxxQkFBcUI7SUFDaENDLE1BQU0sS0FBTztBQUNmIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDU5MTgsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcGF0aC1oYXMtcHJlZml4LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHBhcnNlUGF0aCB9IGZyb20gJy4vcGFyc2UtcGF0aCdcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBnaXZlbiBwYXRoIHN0YXJ0cyB3aXRoIGEgZ2l2ZW4gcHJlZml4LiBJdCBlbnN1cmVzIGl0IG1hdGNoZXNcbiAqIGV4YWN0bHkgd2l0aG91dCBjb250YWluaW5nIGV4dHJhIGNoYXJzLiBlLmcuIHByZWZpeCAvZG9jcyBzaG91bGQgcmVwbGFjZVxuICogZm9yIC9kb2NzLCAvZG9jcy8sIC9kb2NzL2EgYnV0IG5vdCAvZG9jc3NzXG4gKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEBwYXJhbSBwcmVmaXggVGhlIHByZWZpeCB0byBjaGVjayBhZ2FpbnN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGF0aEhhc1ByZWZpeChwYXRoOiBzdHJpbmcsIHByZWZpeDogc3RyaW5nKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGNvbnN0IHsgcGF0aG5hbWUgfSA9IHBhcnNlUGF0aChwYXRoKVxuICByZXR1cm4gcGF0aG5hbWUgPT09IHByZWZpeCB8fCBwYXRobmFtZS5zdGFydHNXaXRoKHByZWZpeCArICcvJylcbn1cbiJdLCJuYW1lcyI6WyJwYXRoSGFzUHJlZml4IiwicGF0aCIsInByZWZpeCIsInBhdGhuYW1lIiwicGFyc2VQYXRoIiwic3RhcnRzV2l0aCJdLCJtYXBwaW5ncyI6Ijs7OytCQVNnQkEsaUJBQUFBOzs7ZUFBQUE7OzsyQkFUVTtBQVNuQixTQUFTQSxjQUFjQyxJQUFZLEVBQUVDLE1BQWM7SUFDeEQsSUFBSSxPQUFPRCxTQUFTLFVBQVU7UUFDNUIsT0FBTztJQUNUO0lBRUEsTUFBTSxFQUFFRSxRQUFRLEVBQUUsR0FBR0MsQ0FBQUEsR0FBQUEsV0FBQUEsU0FBUyxFQUFDSDtJQUMvQixPQUFPRSxhQUFhRCxVQUFVQyxTQUFTRSxVQUFVLENBQUNILFNBQVM7QUFDN0QiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNTk0MSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvaGFzLWJhc2UtcGF0aC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwYXRoSGFzUHJlZml4IH0gZnJvbSAnLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcGF0aC1oYXMtcHJlZml4J1xuXG5jb25zdCBiYXNlUGF0aCA9IChwcm9jZXNzLmVudi5fX05FWFRfUk9VVEVSX0JBU0VQQVRIIGFzIHN0cmluZykgfHwgJydcblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0Jhc2VQYXRoKHBhdGg6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gcGF0aEhhc1ByZWZpeChwYXRoLCBiYXNlUGF0aClcbn1cbiJdLCJuYW1lcyI6WyJoYXNCYXNlUGF0aCIsImJhc2VQYXRoIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9ST1VURVJfQkFTRVBBVEgiLCJwYXRoIiwicGF0aEhhc1ByZWZpeCJdLCJtYXBwaW5ncyI6Ijs7OytCQUlnQkEsZUFBQUE7OztlQUFBQTs7OytCQUpjO0FBRTlCLE1BQU1DLFdBQVlDLFFBQVFDLEdBQUcsQ0FBQ0Msc0JBQXNCLE1BQWU7QUFFNUQsU0FBU0osWUFBWUssSUFBWTtJQUN0QyxPQUFPQyxDQUFBQSxHQUFBQSxlQUFBQSxhQUFhLEVBQUNELE1BQU1KO0FBQzdCIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDU5NjgsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvY2xpZW50L3JlbW92ZS1iYXNlLXBhdGgudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaGFzQmFzZVBhdGggfSBmcm9tICcuL2hhcy1iYXNlLXBhdGgnXG5cbmNvbnN0IGJhc2VQYXRoID0gKHByb2Nlc3MuZW52Ll9fTkVYVF9ST1VURVJfQkFTRVBBVEggYXMgc3RyaW5nKSB8fCAnJ1xuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQmFzZVBhdGgocGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9NQU5VQUxfQ0xJRU5UX0JBU0VfUEFUSCkge1xuICAgIGlmICghaGFzQmFzZVBhdGgocGF0aCkpIHtcbiAgICAgIHJldHVybiBwYXRoXG4gICAgfVxuICB9XG5cbiAgLy8gQ2FuJ3QgdHJpbSB0aGUgYmFzZVBhdGggaWYgaXQgaGFzIHplcm8gbGVuZ3RoIVxuICBpZiAoYmFzZVBhdGgubGVuZ3RoID09PSAwKSByZXR1cm4gcGF0aFxuXG4gIHBhdGggPSBwYXRoLnNsaWNlKGJhc2VQYXRoLmxlbmd0aClcbiAgaWYgKCFwYXRoLnN0YXJ0c1dpdGgoJy8nKSkgcGF0aCA9IGAvJHtwYXRofWBcbiAgcmV0dXJuIHBhdGhcbn1cbiJdLCJuYW1lcyI6WyJyZW1vdmVCYXNlUGF0aCIsImJhc2VQYXRoIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9ST1VURVJfQkFTRVBBVEgiLCJwYXRoIiwiX19ORVhUX01BTlVBTF9DTElFTlRfQkFTRV9QQVRIIiwiaGFzQmFzZVBhdGgiLCJsZW5ndGgiLCJzbGljZSIsInN0YXJ0c1dpdGgiXSwibWFwcGluZ3MiOiI7OzsrQkFJZ0JBLGtCQUFBQTs7O2VBQUFBOzs7NkJBSlk7QUFFNUIsTUFBTUMsV0FBWUMsUUFBUUMsR0FBRyxDQUFDQyxzQkFBc0IsTUFBZTtBQUU1RCxTQUFTSixlQUFlSyxJQUFZO0lBQ3pDLElBQUlILFFBQVFDLEdBQUcsQ0FBQ0csOEJBQThCLEVBQUU7O0lBTWhELGlEQUFpRDtJQUNqRCxJQUFJTCxTQUFTTyxNQUFNLEtBQUssR0FBRyxPQUFPSDtJQUVsQ0EsT0FBT0EsS0FBS0ksS0FBSyxDQUFDUixTQUFTTyxNQUFNO0lBQ2pDLElBQUksQ0FBQ0gsS0FBS0ssVUFBVSxDQUFDLE1BQU1MLE9BQVEsTUFBR0E7SUFDdEMsT0FBT0E7QUFDVCIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA2MDAxLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2NsaWVudC9jb21wb25lbnRzL2Vycm9ycy9ncmFjZWZ1bC1kZWdyYWRlLWJvdW5kYXJ5LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuaW1wb3J0IHsgQ29tcG9uZW50LCBjcmVhdGVSZWYsIHR5cGUgUmVhY3ROb2RlIH0gZnJvbSAncmVhY3QnXG5cbmludGVyZmFjZSBFcnJvckJvdW5kYXJ5UHJvcHMge1xuICBjaGlsZHJlbjogUmVhY3ROb2RlXG59XG5cbmludGVyZmFjZSBFcnJvckJvdW5kYXJ5U3RhdGUge1xuICBoYXNFcnJvcjogYm9vbGVhblxufVxuXG5mdW5jdGlvbiBnZXREb21Ob2RlQXR0cmlidXRlcyhub2RlOiBIVE1MRWxlbWVudCk6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4ge1xuICBjb25zdCByZXN1bHQ6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fVxuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGF0dHIgPSBub2RlLmF0dHJpYnV0ZXNbaV1cbiAgICByZXN1bHRbYXR0ci5uYW1lXSA9IGF0dHIudmFsdWVcbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmV4cG9ydCBjbGFzcyBHcmFjZWZ1bERlZ3JhZGVCb3VuZGFyeSBleHRlbmRzIENvbXBvbmVudDxcbiAgRXJyb3JCb3VuZGFyeVByb3BzLFxuICBFcnJvckJvdW5kYXJ5U3RhdGVcbj4ge1xuICBwcml2YXRlIHJvb3RIdG1sOiBzdHJpbmdcbiAgcHJpdmF0ZSBodG1sQXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuICBwcml2YXRlIGh0bWxSZWY6IFJlYWN0LlJlZk9iamVjdDxIVE1MSHRtbEVsZW1lbnQgfCBudWxsPlxuXG4gIGNvbnN0cnVjdG9yKHByb3BzOiBFcnJvckJvdW5kYXJ5UHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcylcbiAgICB0aGlzLnN0YXRlID0geyBoYXNFcnJvcjogZmFsc2UgfVxuICAgIHRoaXMucm9vdEh0bWwgPSAnJ1xuICAgIHRoaXMuaHRtbEF0dHJpYnV0ZXMgPSB7fVxuICAgIHRoaXMuaHRtbFJlZiA9IGNyZWF0ZVJlZjxIVE1MSHRtbEVsZW1lbnQ+KClcbiAgfVxuXG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoXzogdW5rbm93bik6IEVycm9yQm91bmRhcnlTdGF0ZSB7XG4gICAgcmV0dXJuIHsgaGFzRXJyb3I6IHRydWUgfVxuICB9XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgY29uc3QgaHRtbE5vZGUgPSB0aGlzLmh0bWxSZWYuY3VycmVudFxuICAgIGlmICh0aGlzLnN0YXRlLmhhc0Vycm9yICYmIGh0bWxOb2RlKSB7XG4gICAgICAvLyBSZWFwcGx5IHRoZSBjYWNoZWQgSFRNTCBhdHRyaWJ1dGVzIHRvIHRoZSByb290IGVsZW1lbnRcbiAgICAgIE9iamVjdC5lbnRyaWVzKHRoaXMuaHRtbEF0dHJpYnV0ZXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICBodG1sTm9kZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSlcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgaGFzRXJyb3IgfSA9IHRoaXMuc3RhdGVcbiAgICAvLyBDYWNoZSB0aGUgcm9vdCBIVE1MIGNvbnRlbnQgb24gdGhlIGZpcnN0IHJlbmRlclxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAhdGhpcy5yb290SHRtbCkge1xuICAgICAgdGhpcy5yb290SHRtbCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5pbm5lckhUTUxcbiAgICAgIHRoaXMuaHRtbEF0dHJpYnV0ZXMgPSBnZXREb21Ob2RlQXR0cmlidXRlcyhkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpXG4gICAgfVxuXG4gICAgaWYgKGhhc0Vycm9yKSB7XG4gICAgICAvLyBSZW5kZXIgdGhlIGN1cnJlbnQgSFRNTCBjb250ZW50IHdpdGhvdXQgaHlkcmF0aW9uXG4gICAgICByZXR1cm4gKFxuICAgICAgICA8aHRtbFxuICAgICAgICAgIHJlZj17dGhpcy5odG1sUmVmfVxuICAgICAgICAgIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZ1xuICAgICAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MPXt7XG4gICAgICAgICAgICBfX2h0bWw6IHRoaXMucm9vdEh0bWwsXG4gICAgICAgICAgfX1cbiAgICAgICAgLz5cbiAgICAgIClcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlblxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEdyYWNlZnVsRGVncmFkZUJvdW5kYXJ5XG4iXSwibmFtZXMiOlsiR3JhY2VmdWxEZWdyYWRlQm91bmRhcnkiLCJnZXREb21Ob2RlQXR0cmlidXRlcyIsIm5vZGUiLCJyZXN1bHQiLCJpIiwiYXR0cmlidXRlcyIsImxlbmd0aCIsImF0dHIiLCJuYW1lIiwidmFsdWUiLCJDb21wb25lbnQiLCJnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IiLCJfIiwiaGFzRXJyb3IiLCJjb21wb25lbnREaWRNb3VudCIsImh0bWxOb2RlIiwiaHRtbFJlZiIsImN1cnJlbnQiLCJzdGF0ZSIsIk9iamVjdCIsImVudHJpZXMiLCJodG1sQXR0cmlidXRlcyIsImZvckVhY2giLCJrZXkiLCJzZXRBdHRyaWJ1dGUiLCJyZW5kZXIiLCJ3aW5kb3ciLCJyb290SHRtbCIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwiaW5uZXJIVE1MIiwiaHRtbCIsInJlZiIsInN1cHByZXNzSHlkcmF0aW9uV2FybmluZyIsImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIiwiX19odG1sIiwicHJvcHMiLCJjaGlsZHJlbiIsImNvbnN0cnVjdG9yIiwiY3JlYXRlUmVmIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztJQXFCYUEsdUJBQXVCLEVBQUE7ZUFBdkJBOztJQXVEYixPQUFzQyxFQUFBO2VBQXRDOzs7O3VCQTFFcUQ7QUFVckQsU0FBU0MscUJBQXFCQyxJQUFpQjtJQUM3QyxNQUFNQyxTQUFpQyxDQUFDO0lBQ3hDLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJRixLQUFLRyxVQUFVLENBQUNDLE1BQU0sRUFBRUYsSUFBSztRQUMvQyxNQUFNRyxPQUFPTCxLQUFLRyxVQUFVLENBQUNELEVBQUU7UUFDL0JELE1BQU0sQ0FBQ0ksS0FBS0MsSUFBSSxDQUFDLEdBQUdELEtBQUtFLEtBQUs7SUFDaEM7SUFDQSxPQUFPTjtBQUNUO0FBRU8sTUFBTUgsZ0NBQWdDVSxPQUFBQSxTQUFTO0lBZ0JwRCxPQUFPQyx5QkFBeUJDLENBQVUsRUFBc0I7UUFDOUQsT0FBTztZQUFFQyxVQUFVO1FBQUs7SUFDMUI7SUFFQUMsb0JBQW9CO1FBQ2xCLE1BQU1DLFdBQVcsSUFBSSxDQUFDQyxPQUFPLENBQUNDLE9BQU87UUFDckMsSUFBSSxJQUFJLENBQUNDLEtBQUssQ0FBQ0wsUUFBUSxJQUFJRSxVQUFVO1lBQ25DLHlEQUF5RDtZQUN6REksT0FBT0MsT0FBTyxDQUFDLElBQUksQ0FBQ0MsY0FBYyxFQUFFQyxPQUFPLENBQUMsQ0FBQTtvQkFBQyxDQUFDQyxLQUFLZCxNQUFNLEdBQUE7Z0JBQ3ZETSxTQUFTUyxZQUFZLENBQUNELEtBQUtkO1lBQzdCO1FBQ0Y7SUFDRjtJQUVBZ0IsU0FBUztRQUNQLE1BQU0sRUFBRVosUUFBUSxFQUFFLEdBQUcsSUFBSSxDQUFDSyxLQUFLO1FBQy9CLGtEQUFrRDtRQUNsRCxJQUFJLE9BQU9RLFNBQVcsZUFBZSxDQUFDLElBQUksQ0FBQ0MsUUFBUSxFQUFFOztRQUtyRCxJQUFJZCxVQUFVO1lBQ1osb0RBQW9EO1lBQ3BELE9BQUEsV0FBQSxHQUNFLENBQUEsR0FBQSxZQUFBLEdBQUEsRUFBQ2tCLFFBQUFBO2dCQUNDQyxLQUFLLElBQUksQ0FBQ2hCLE9BQU87Z0JBQ2pCaUIsd0JBQXdCLEVBQUE7Z0JBQ3hCQyx5QkFBeUI7b0JBQ3ZCQyxRQUFRLElBQUksQ0FBQ1IsUUFBUTtnQkFDdkI7O1FBR047UUFFQSxPQUFPLElBQUksQ0FBQ1MsS0FBSyxDQUFDQyxRQUFRO0lBQzVCO0lBNUNBQyxZQUFZRixLQUF5QixDQUFFO1FBQ3JDLEtBQUssQ0FBQ0E7UUFDTixJQUFJLENBQUNsQixLQUFLLEdBQUc7WUFBRUwsVUFBVTtRQUFNO1FBQy9CLElBQUksQ0FBQ2MsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ04sY0FBYyxHQUFHLENBQUM7UUFDdkIsSUFBSSxDQUFDTCxPQUFPLEdBQUEsV0FBQSxHQUFHdUIsQ0FBQUEsR0FBQUEsT0FBQUEsU0FBUztJQUMxQjtBQXVDRjtNQUVBLFdBQWV2QyIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA2MDg4LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9zdHJpcC1hbnNpL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIigoKT0+e1widXNlIHN0cmljdFwiO3ZhciBlPXs1MTE6ZT0+e2UuZXhwb3J0cz0oe29ubHlGaXJzdDplPWZhbHNlfT17fSk9Pntjb25zdCByPVtcIltcXFxcdTAwMUJcXFxcdTAwOUJdW1tcXFxcXSgpIzs/XSooPzooPzooPzooPzo7Wy1hLXpBLVpcXFxcZFxcXFwvIyYuOj0/JUB+X10rKSp8W2EtekEtWlxcXFxkXSsoPzo7Wy1hLXpBLVpcXFxcZFxcXFwvIyYuOj0/JUB+X10qKSopP1xcXFx1MDAwNylcIixcIig/Oig/OlxcXFxkezEsNH0oPzo7XFxcXGR7MCw0fSkqKT9bXFxcXGRBLVBSLVRaY2YtbnRxcnk9Pjx+XSkpXCJdLmpvaW4oXCJ8XCIpO3JldHVybiBuZXcgUmVnRXhwKHIsZT91bmRlZmluZWQ6XCJnXCIpfX0sNTMyOihlLHIsXyk9Pntjb25zdCB0PV8oNTExKTtlLmV4cG9ydHM9ZT0+dHlwZW9mIGU9PT1cInN0cmluZ1wiP2UucmVwbGFjZSh0KCksXCJcIik6ZX19O3ZhciByPXt9O2Z1bmN0aW9uIF9fbmNjd3Bja19yZXF1aXJlX18oXyl7dmFyIHQ9cltfXTtpZih0IT09dW5kZWZpbmVkKXtyZXR1cm4gdC5leHBvcnRzfXZhciBhPXJbX109e2V4cG9ydHM6e319O3ZhciBuPXRydWU7dHJ5e2VbX10oYSxhLmV4cG9ydHMsX19uY2N3cGNrX3JlcXVpcmVfXyk7bj1mYWxzZX1maW5hbGx5e2lmKG4pZGVsZXRlIHJbX119cmV0dXJuIGEuZXhwb3J0c31pZih0eXBlb2YgX19uY2N3cGNrX3JlcXVpcmVfXyE9PVwidW5kZWZpbmVkXCIpX19uY2N3cGNrX3JlcXVpcmVfXy5hYj1fX2Rpcm5hbWUrXCIvXCI7dmFyIF89X19uY2N3cGNrX3JlcXVpcmVfXyg1MzIpO21vZHVsZS5leHBvcnRzPV99KSgpOyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxDQUFDO0lBQUs7SUFBYSxJQUFJLElBQUU7UUFBQyxLQUFJLENBQUE7WUFBSSxFQUFFLE9BQU8sR0FBQyxDQUFDLEVBQUMsV0FBVSxJQUFFLEtBQUssRUFBQyxHQUFDLENBQUMsQ0FBQztnQkFBSSxNQUFNLElBQUU7b0JBQUM7b0JBQStIO2lCQUEyRCxDQUFDLElBQUksQ0FBQztnQkFBSyxPQUFPLElBQUksT0FBTyxHQUFFLElBQUUsWUFBVTtZQUFJO1FBQUM7UUFBRSxLQUFJLENBQUMsR0FBRSxHQUFFO1lBQUssTUFBTSxJQUFFLEVBQUU7WUFBSyxFQUFFLE9BQU8sR0FBQyxDQUFBLElBQUcsT0FBTyxNQUFJLFdBQVMsRUFBRSxPQUFPLENBQUMsS0FBSSxNQUFJO1FBQUM7SUFBQztJQUFFLElBQUksSUFBRSxDQUFDO0lBQUUsU0FBUyxvQkFBb0IsQ0FBQztRQUFFLElBQUksSUFBRSxDQUFDLENBQUMsRUFBRTtRQUFDLElBQUcsTUFBSSxXQUFVO1lBQUMsT0FBTyxFQUFFLE9BQU87UUFBQTtRQUFDLElBQUksSUFBRSxDQUFDLENBQUMsRUFBRSxHQUFDO1lBQUMsU0FBUSxDQUFDO1FBQUM7UUFBRSxJQUFJLElBQUU7UUFBSyxJQUFHO1lBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFFLEVBQUUsT0FBTyxFQUFDO1lBQXFCLElBQUU7UUFBSyxTQUFRO1lBQUMsSUFBRyxHQUFFLE9BQU8sQ0FBQyxDQUFDLEVBQUU7UUFBQTtRQUFDLE9BQU8sRUFBRSxPQUFPO0lBQUE7SUFBQyxJQUFHLE9BQU8sd0JBQXNCLGFBQVksb0JBQW9CLEVBQUUsR0FBQyx1RkFBVTtJQUFJLElBQUksSUFBRSxvQkFBb0I7SUFBSyxPQUFPLE9BQU8sR0FBQztBQUFDLENBQUMiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNjEzMywgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9zaGFyZWQvbGliL2Zvcm1hdC13ZWJwYWNrLW1lc3NhZ2VzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuTUlUIExpY2Vuc2VcblxuQ29weXJpZ2h0IChjKSAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG5jb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG5TT0ZUV0FSRS5cbiovXG5pbXBvcnQgc3RyaXBBbnNpIGZyb20gJ25leHQvZGlzdC9jb21waWxlZC9zdHJpcC1hbnNpJ1xuLy8gVGhpcyBmaWxlIGlzIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9jcmVhdGUtcmVhY3QtYXBwL2Jsb2IvN2IxYTMyYmU2ZWM5Zjk5YTZjOWEzYzY2ODEzZjNhYzA5YzQ3MzZiOS9wYWNrYWdlcy9yZWFjdC1kZXYtdXRpbHMvZm9ybWF0V2VicGFja01lc3NhZ2VzLmpzXG4vLyBJdCdzIGJlZW4gZWRpdGVkIHRvIHJlbW92ZSBjaGFsayBhbmQgQ1JBLXNwZWNpZmljIGxvZ2ljXG5cbmNvbnN0IGZyaWVuZGx5U3ludGF4RXJyb3JMYWJlbCA9ICdTeW50YXggZXJyb3I6J1xuXG5jb25zdCBXRUJQQUNLX0JSRUFLSU5HX0NIQU5HRV9QT0xZRklMTFMgPVxuICAnXFxuXFxuQlJFQUtJTkcgQ0hBTkdFOiB3ZWJwYWNrIDwgNSB1c2VkIHRvIGluY2x1ZGUgcG9seWZpbGxzIGZvciBub2RlLmpzIGNvcmUgbW9kdWxlcyBieSBkZWZhdWx0LidcblxuZnVuY3Rpb24gaXNMaWtlbHlBU3ludGF4RXJyb3IobWVzc2FnZTogc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpcEFuc2kobWVzc2FnZSkuaW5jbHVkZXMoZnJpZW5kbHlTeW50YXhFcnJvckxhYmVsKVxufVxuXG5sZXQgaGFkTWlzc2luZ1Nhc3NFcnJvciA9IGZhbHNlXG5cbi8vIENsZWFucyB1cCB3ZWJwYWNrIGVycm9yIG1lc3NhZ2VzLlxuZnVuY3Rpb24gZm9ybWF0TWVzc2FnZShcbiAgbWVzc2FnZTogYW55LFxuICB2ZXJib3NlPzogYm9vbGVhbixcbiAgaW1wb3J0VHJhY2VOb3RlPzogYm9vbGVhblxuKSB7XG4gIC8vIFRPRE86IFJlcGxhY2UgdGhpcyBvbmNlIHdlYnBhY2sgNSBpcyBzdGFibGVcbiAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnb2JqZWN0JyAmJiBtZXNzYWdlLm1lc3NhZ2UpIHtcbiAgICBjb25zdCBmaWx0ZXJlZE1vZHVsZVRyYWNlID1cbiAgICAgIG1lc3NhZ2UubW9kdWxlVHJhY2UgJiZcbiAgICAgIG1lc3NhZ2UubW9kdWxlVHJhY2UuZmlsdGVyKFxuICAgICAgICAodHJhY2U6IGFueSkgPT5cbiAgICAgICAgICAhL25leHQtKG1pZGRsZXdhcmV8Y2xpZW50LXBhZ2VzfHJvdXRlfGVkZ2UtZnVuY3Rpb24pLWxvYWRlclxcLmpzLy50ZXN0KFxuICAgICAgICAgICAgdHJhY2Uub3JpZ2luTmFtZVxuICAgICAgICAgIClcbiAgICAgIClcblxuICAgIGxldCBib2R5ID0gbWVzc2FnZS5tZXNzYWdlXG4gICAgY29uc3QgYnJlYWtpbmdDaGFuZ2VJbmRleCA9IGJvZHkuaW5kZXhPZihXRUJQQUNLX0JSRUFLSU5HX0NIQU5HRV9QT0xZRklMTFMpXG4gICAgaWYgKGJyZWFraW5nQ2hhbmdlSW5kZXggPj0gMCkge1xuICAgICAgYm9keSA9IGJvZHkuc2xpY2UoMCwgYnJlYWtpbmdDaGFuZ2VJbmRleClcbiAgICB9XG5cbiAgICBtZXNzYWdlID1cbiAgICAgIChtZXNzYWdlLm1vZHVsZU5hbWUgPyBzdHJpcEFuc2kobWVzc2FnZS5tb2R1bGVOYW1lKSArICdcXG4nIDogJycpICtcbiAgICAgIChtZXNzYWdlLmZpbGUgPyBzdHJpcEFuc2kobWVzc2FnZS5maWxlKSArICdcXG4nIDogJycpICtcbiAgICAgIGJvZHkgK1xuICAgICAgKG1lc3NhZ2UuZGV0YWlscyAmJiB2ZXJib3NlID8gJ1xcbicgKyBtZXNzYWdlLmRldGFpbHMgOiAnJykgK1xuICAgICAgKGZpbHRlcmVkTW9kdWxlVHJhY2UgJiYgZmlsdGVyZWRNb2R1bGVUcmFjZS5sZW5ndGhcbiAgICAgICAgPyAoaW1wb3J0VHJhY2VOb3RlIHx8ICdcXG5cXG5JbXBvcnQgdHJhY2UgZm9yIHJlcXVlc3RlZCBtb2R1bGU6JykgK1xuICAgICAgICAgIGZpbHRlcmVkTW9kdWxlVHJhY2VcbiAgICAgICAgICAgIC5tYXAoKHRyYWNlOiBhbnkpID0+IGBcXG4ke3RyYWNlLm1vZHVsZU5hbWV9YClcbiAgICAgICAgICAgIC5qb2luKCcnKVxuICAgICAgICA6ICcnKSArXG4gICAgICAobWVzc2FnZS5zdGFjayAmJiB2ZXJib3NlID8gJ1xcbicgKyBtZXNzYWdlLnN0YWNrIDogJycpXG4gIH1cbiAgbGV0IGxpbmVzID0gbWVzc2FnZS5zcGxpdCgnXFxuJylcblxuICAvLyBTdHJpcCBXZWJwYWNrLWFkZGVkIGhlYWRlcnMgb2ZmIGVycm9ycy93YXJuaW5nc1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay93ZWJwYWNrL2Jsb2IvbWFzdGVyL2xpYi9Nb2R1bGVFcnJvci5qc1xuICBsaW5lcyA9IGxpbmVzLmZpbHRlcigobGluZTogc3RyaW5nKSA9PiAhL01vZHVsZSBbQS16IF0rXFwoZnJvbS8udGVzdChsaW5lKSlcblxuICAvLyBUcmFuc2Zvcm0gcGFyc2luZyBlcnJvciBpbnRvIHN5bnRheCBlcnJvclxuICAvLyBUT0RPOiBtb3ZlIHRoaXMgdG8gb3VyIEVTTGludCBmb3JtYXR0ZXI/XG4gIGxpbmVzID0gbGluZXMubWFwKChsaW5lOiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCBwYXJzaW5nRXJyb3IgPSAvTGluZSAoXFxkKyk6KD86KFxcZCspOik/XFxzKlBhcnNpbmcgZXJyb3I6ICguKykkLy5leGVjKFxuICAgICAgbGluZVxuICAgIClcbiAgICBpZiAoIXBhcnNpbmdFcnJvcikge1xuICAgICAgcmV0dXJuIGxpbmVcbiAgICB9XG4gICAgY29uc3QgWywgZXJyb3JMaW5lLCBlcnJvckNvbHVtbiwgZXJyb3JNZXNzYWdlXSA9IHBhcnNpbmdFcnJvclxuICAgIHJldHVybiBgJHtmcmllbmRseVN5bnRheEVycm9yTGFiZWx9ICR7ZXJyb3JNZXNzYWdlfSAoJHtlcnJvckxpbmV9OiR7ZXJyb3JDb2x1bW59KWBcbiAgfSlcblxuICBtZXNzYWdlID0gbGluZXMuam9pbignXFxuJylcbiAgLy8gU21vb3NoIHN5bnRheCBlcnJvcnMgKGNvbW1vbmx5IGZvdW5kIGluIENTUylcbiAgbWVzc2FnZSA9IG1lc3NhZ2UucmVwbGFjZShcbiAgICAvU3ludGF4RXJyb3JcXHMrXFwoKFxcZCspOihcXGQrKVxcKVxccyooLis/KVxcbi9nLFxuICAgIGAke2ZyaWVuZGx5U3ludGF4RXJyb3JMYWJlbH0gJDMgKCQxOiQyKVxcbmBcbiAgKVxuICAvLyBDbGVhbiB1cCBleHBvcnQgZXJyb3JzXG4gIG1lc3NhZ2UgPSBtZXNzYWdlLnJlcGxhY2UoXG4gICAgL14uKmV4cG9ydCAnKC4rPyknIHdhcyBub3QgZm91bmQgaW4gJyguKz8pJy4qJC9nbSxcbiAgICBgQXR0ZW1wdGVkIGltcG9ydCBlcnJvcjogJyQxJyBpcyBub3QgZXhwb3J0ZWQgZnJvbSAnJDInLmBcbiAgKVxuICBtZXNzYWdlID0gbWVzc2FnZS5yZXBsYWNlKFxuICAgIC9eLipleHBvcnQgJ2RlZmF1bHQnIFxcKGltcG9ydGVkIGFzICcoLis/KSdcXCkgd2FzIG5vdCBmb3VuZCBpbiAnKC4rPyknLiokL2dtLFxuICAgIGBBdHRlbXB0ZWQgaW1wb3J0IGVycm9yOiAnJDInIGRvZXMgbm90IGNvbnRhaW4gYSBkZWZhdWx0IGV4cG9ydCAoaW1wb3J0ZWQgYXMgJyQxJykuYFxuICApXG4gIG1lc3NhZ2UgPSBtZXNzYWdlLnJlcGxhY2UoXG4gICAgL14uKmV4cG9ydCAnKC4rPyknIFxcKGltcG9ydGVkIGFzICcoLis/KSdcXCkgd2FzIG5vdCBmb3VuZCBpbiAnKC4rPyknLiokL2dtLFxuICAgIGBBdHRlbXB0ZWQgaW1wb3J0IGVycm9yOiAnJDEnIGlzIG5vdCBleHBvcnRlZCBmcm9tICckMycgKGltcG9ydGVkIGFzICckMicpLmBcbiAgKVxuICBsaW5lcyA9IG1lc3NhZ2Uuc3BsaXQoJ1xcbicpXG5cbiAgLy8gUmVtb3ZlIGxlYWRpbmcgbmV3bGluZVxuICBpZiAobGluZXMubGVuZ3RoID4gMiAmJiBsaW5lc1sxXS50cmltKCkgPT09ICcnKSB7XG4gICAgbGluZXMuc3BsaWNlKDEsIDEpXG4gIH1cblxuICAvLyBDbGVhbnMgdXAgdmVyYm9zZSBcIm1vZHVsZSBub3QgZm91bmRcIiBtZXNzYWdlcyBmb3IgZmlsZXMgYW5kIHBhY2thZ2VzLlxuICBpZiAobGluZXNbMV0gJiYgbGluZXNbMV0uc3RhcnRzV2l0aCgnTW9kdWxlIG5vdCBmb3VuZDogJykpIHtcbiAgICBsaW5lcyA9IFtcbiAgICAgIGxpbmVzWzBdLFxuICAgICAgbGluZXNbMV1cbiAgICAgICAgLnJlcGxhY2UoJ0Vycm9yOiAnLCAnJylcbiAgICAgICAgLnJlcGxhY2UoJ01vZHVsZSBub3QgZm91bmQ6IENhbm5vdCBmaW5kIGZpbGU6JywgJ0Nhbm5vdCBmaW5kIGZpbGU6JyksXG4gICAgICAuLi5saW5lcy5zbGljZSgyKSxcbiAgICBdXG4gIH1cblxuICAvLyBBZGQgaGVscGZ1bCBtZXNzYWdlIGZvciB1c2VycyB0cnlpbmcgdG8gdXNlIFNhc3MgZm9yIHRoZSBmaXJzdCB0aW1lXG4gIGlmIChsaW5lc1sxXSAmJiBsaW5lc1sxXS5tYXRjaCgvQ2Fubm90IGZpbmQgbW9kdWxlLitzYXNzLykpIHtcbiAgICAvLyAuL2ZpbGUubW9kdWxlLnNjc3MgKDw8bG9hZGVyIGluZm8+PikgPT4gLi9maWxlLm1vZHVsZS5zY3NzXG4gICAgY29uc3QgZmlyc3RMaW5lID0gbGluZXNbMF0uc3BsaXQoJyEnKVxuICAgIGxpbmVzWzBdID0gZmlyc3RMaW5lW2ZpcnN0TGluZS5sZW5ndGggLSAxXVxuXG4gICAgbGluZXNbMV0gPVxuICAgICAgXCJUbyB1c2UgTmV4dC5qcycgYnVpbHQtaW4gU2FzcyBzdXBwb3J0LCB5b3UgZmlyc3QgbmVlZCB0byBpbnN0YWxsIGBzYXNzYC5cXG5cIlxuICAgIGxpbmVzWzFdICs9ICdSdW4gYG5wbSBpIHNhc3NgIG9yIGB5YXJuIGFkZCBzYXNzYCBpbnNpZGUgeW91ciB3b3Jrc3BhY2UuXFxuJ1xuICAgIGxpbmVzWzFdICs9ICdcXG5MZWFybiBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9pbnN0YWxsLXNhc3MnXG5cbiAgICAvLyBkaXNwb3NlIG9mIHVuaGVscGZ1bCBzdGFjayB0cmFjZVxuICAgIGxpbmVzID0gbGluZXMuc2xpY2UoMCwgMilcbiAgICBoYWRNaXNzaW5nU2Fzc0Vycm9yID0gdHJ1ZVxuICB9IGVsc2UgaWYgKFxuICAgIGhhZE1pc3NpbmdTYXNzRXJyb3IgJiZcbiAgICBtZXNzYWdlLm1hdGNoKC8oc2Fzcy1sb2FkZXJ8cmVzb2x2ZS11cmwtbG9hZGVyOiBDU1MgZXJyb3IpLylcbiAgKSB7XG4gICAgLy8gZGlzcG9zZSBvZiB1bmhlbHBmdWwgc3RhY2sgdHJhY2UgZm9sbG93aW5nIG1pc3Npbmcgc2FzcyBtb2R1bGVcbiAgICBsaW5lcyA9IFtdXG4gIH1cblxuICBpZiAoIXZlcmJvc2UpIHtcbiAgICBtZXNzYWdlID0gbGluZXMuam9pbignXFxuJylcbiAgICAvLyBJbnRlcm5hbCBzdGFja3MgYXJlIGdlbmVyYWxseSB1c2VsZXNzIHNvIHdlIHN0cmlwIHRoZW0uLi4gd2l0aCB0aGVcbiAgICAvLyBleGNlcHRpb24gb2Ygc3RhY2tzIGNvbnRhaW5pbmcgYHdlYnBhY2s6YCBiZWNhdXNlIHRoZXkncmUgbm9ybWFsbHlcbiAgICAvLyBmcm9tIHVzZXIgY29kZSBnZW5lcmF0ZWQgYnkgV2VicGFjay4gRm9yIG1vcmUgaW5mb3JtYXRpb24gc2VlXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2NyZWF0ZS1yZWFjdC1hcHAvcHVsbC8xMDUwXG4gICAgbWVzc2FnZSA9IG1lc3NhZ2UucmVwbGFjZShcbiAgICAgIC9eXFxzKmF0XFxzKCg/IXdlYnBhY2s6KS4pKjpcXGQrOlxcZCtbXFxzKV0qKFxcbnwkKS9nbSxcbiAgICAgICcnXG4gICAgKSAvLyBhdCAuLi4gLi4uOng6eVxuICAgIG1lc3NhZ2UgPSBtZXNzYWdlLnJlcGxhY2UoL15cXHMqYXRcXHM8YW5vbnltb3VzPihcXG58JCkvZ20sICcnKSAvLyBhdCA8YW5vbnltb3VzPlxuXG4gICAgbWVzc2FnZSA9IG1lc3NhZ2UucmVwbGFjZShcbiAgICAgIC9GaWxlIHdhcyBwcm9jZXNzZWQgd2l0aCB0aGVzZSBsb2FkZXJzOlxcbiguK1tcXFxcL10obmV4dFtcXFxcL11kaXN0W1xcXFwvXS4rfEBuZXh0W1xcXFwvXXJlYWN0LXJlZnJlc2gtdXRpbHNbXFxcXC9dbG9hZGVyKVxcLmpzXFxuKSpZb3UgbWF5IG5lZWQgYW4gYWRkaXRpb25hbCBsb2FkZXIgdG8gaGFuZGxlIHRoZSByZXN1bHQgb2YgdGhlc2UgbG9hZGVycy5cXG4vZyxcbiAgICAgICcnXG4gICAgKVxuXG4gICAgbGluZXMgPSBtZXNzYWdlLnNwbGl0KCdcXG4nKVxuICB9XG5cbiAgLy8gUmVtb3ZlIGR1cGxpY2F0ZWQgbmV3bGluZXNcbiAgbGluZXMgPSAobGluZXMgYXMgc3RyaW5nW10pLmZpbHRlcihcbiAgICAobGluZSwgaW5kZXgsIGFycikgPT5cbiAgICAgIGluZGV4ID09PSAwIHx8IGxpbmUudHJpbSgpICE9PSAnJyB8fCBsaW5lLnRyaW0oKSAhPT0gYXJyW2luZGV4IC0gMV0udHJpbSgpXG4gIClcblxuICAvLyBSZWFzc2VtYmxlIHRoZSBtZXNzYWdlXG4gIG1lc3NhZ2UgPSBsaW5lcy5qb2luKCdcXG4nKVxuICByZXR1cm4gbWVzc2FnZS50cmltKClcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZm9ybWF0V2VicGFja01lc3NhZ2VzKGpzb246IGFueSwgdmVyYm9zZT86IGJvb2xlYW4pIHtcbiAgY29uc3QgZm9ybWF0dGVkRXJyb3JzID0ganNvbi5lcnJvcnMubWFwKChtZXNzYWdlOiBhbnkpID0+IHtcbiAgICBjb25zdCBpc1Vua25vd25OZXh0Rm9udEVycm9yID0gbWVzc2FnZS5tZXNzYWdlLmluY2x1ZGVzKFxuICAgICAgJ0FuIGVycm9yIG9jY3VycmVkIGluIGBuZXh0L2ZvbnRgLidcbiAgICApXG4gICAgcmV0dXJuIGZvcm1hdE1lc3NhZ2UobWVzc2FnZSwgaXNVbmtub3duTmV4dEZvbnRFcnJvciB8fCB2ZXJib3NlKVxuICB9KVxuICBjb25zdCBmb3JtYXR0ZWRXYXJuaW5ncyA9IGpzb24ud2FybmluZ3MubWFwKChtZXNzYWdlOiBhbnkpID0+IHtcbiAgICByZXR1cm4gZm9ybWF0TWVzc2FnZShtZXNzYWdlLCB2ZXJib3NlKVxuICB9KVxuXG4gIC8vIFJlb3JkZXIgZXJyb3JzIHRvIHB1dCB0aGUgbW9zdCByZWxldmFudCBvbmVzIGZpcnN0LlxuICBsZXQgcmVhY3RTZXJ2ZXJDb21wb25lbnRzRXJyb3IgPSAtMVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZm9ybWF0dGVkRXJyb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZXJyb3IgPSBmb3JtYXR0ZWRFcnJvcnNbaV1cbiAgICBpZiAoZXJyb3IuaW5jbHVkZXMoJ1JlYWN0U2VydmVyQ29tcG9uZW50c0Vycm9yJykpIHtcbiAgICAgIHJlYWN0U2VydmVyQ29tcG9uZW50c0Vycm9yID0gaVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICAvLyBNb3ZlIHRoZSByZWFjdFNlcnZlckNvbXBvbmVudHNFcnJvciB0byB0aGUgdG9wIGlmIGl0IGV4aXN0c1xuICBpZiAocmVhY3RTZXJ2ZXJDb21wb25lbnRzRXJyb3IgIT09IC0xKSB7XG4gICAgY29uc3QgZXJyb3IgPSBmb3JtYXR0ZWRFcnJvcnMuc3BsaWNlKHJlYWN0U2VydmVyQ29tcG9uZW50c0Vycm9yLCAxKVxuICAgIGZvcm1hdHRlZEVycm9ycy51bnNoaWZ0KGVycm9yWzBdKVxuICB9XG5cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIC4uLmpzb24sXG4gICAgZXJyb3JzOiBmb3JtYXR0ZWRFcnJvcnMsXG4gICAgd2FybmluZ3M6IGZvcm1hdHRlZFdhcm5pbmdzLFxuICB9XG4gIGlmICghdmVyYm9zZSAmJiByZXN1bHQuZXJyb3JzLnNvbWUoaXNMaWtlbHlBU3ludGF4RXJyb3IpKSB7XG4gICAgLy8gSWYgdGhlcmUgYXJlIGFueSBzeW50YXggZXJyb3JzLCBzaG93IGp1c3QgdGhlbS5cbiAgICByZXN1bHQuZXJyb3JzID0gcmVzdWx0LmVycm9ycy5maWx0ZXIoaXNMaWtlbHlBU3ludGF4RXJyb3IpXG4gICAgcmVzdWx0Lndhcm5pbmdzID0gW11cbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG4iXSwibmFtZXMiOlsiZm9ybWF0V2VicGFja01lc3NhZ2VzIiwiZnJpZW5kbHlTeW50YXhFcnJvckxhYmVsIiwiV0VCUEFDS19CUkVBS0lOR19DSEFOR0VfUE9MWUZJTExTIiwiaXNMaWtlbHlBU3ludGF4RXJyb3IiLCJtZXNzYWdlIiwic3RyaXBBbnNpIiwiaW5jbHVkZXMiLCJoYWRNaXNzaW5nU2Fzc0Vycm9yIiwiZm9ybWF0TWVzc2FnZSIsInZlcmJvc2UiLCJpbXBvcnRUcmFjZU5vdGUiLCJmaWx0ZXJlZE1vZHVsZVRyYWNlIiwibW9kdWxlVHJhY2UiLCJmaWx0ZXIiLCJ0cmFjZSIsInRlc3QiLCJvcmlnaW5OYW1lIiwiYm9keSIsImJyZWFraW5nQ2hhbmdlSW5kZXgiLCJpbmRleE9mIiwic2xpY2UiLCJtb2R1bGVOYW1lIiwiZmlsZSIsImRldGFpbHMiLCJsZW5ndGgiLCJtYXAiLCJqb2luIiwic3RhY2siLCJsaW5lcyIsInNwbGl0IiwibGluZSIsInBhcnNpbmdFcnJvciIsImV4ZWMiLCJlcnJvckxpbmUiLCJlcnJvckNvbHVtbiIsImVycm9yTWVzc2FnZSIsInJlcGxhY2UiLCJ0cmltIiwic3BsaWNlIiwic3RhcnRzV2l0aCIsIm1hdGNoIiwiZmlyc3RMaW5lIiwiaW5kZXgiLCJhcnIiLCJqc29uIiwiZm9ybWF0dGVkRXJyb3JzIiwiZXJyb3JzIiwiaXNVbmtub3duTmV4dEZvbnRFcnJvciIsImZvcm1hdHRlZFdhcm5pbmdzIiwid2FybmluZ3MiLCJyZWFjdFNlcnZlckNvbXBvbmVudHNFcnJvciIsImkiLCJlcnJvciIsInVuc2hpZnQiLCJyZXN1bHQiLCJzb21l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VUFBVUQ7SUFDWjtJQUNBLElBQUksQ0FBQ3ZDLFdBQVc2QyxPQUFPUixNQUFNLENBQUNTLElBQUksQ0FBQ3BELHVCQUF1QjtRQUN4RCxrREFBa0Q7UUFDbERtRCxPQUFPUixNQUFNLEdBQUdRLE9BQU9SLE1BQU0sQ0FBQ2pDLE1BQU0sQ0FBQ1Y7UUFDckNtRCxPQUFPTCxRQUFRLEdBQUcsRUFBRTtJQUN0QjtJQUNBLE9BQU9LO0FBQ1QiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNjI5NCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvZGV2L2hvdC1yZWxvYWRlci9zaGFyZWQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBITVJfQUNUSU9OX1RZUEVTIH0gZnJvbSAnLi4vLi4vLi4vc2VydmVyL2Rldi9ob3QtcmVsb2FkZXItdHlwZXMnXG5cbmV4cG9ydCBjb25zdCBSRUFDVF9SRUZSRVNIX0ZVTExfUkVMT0FEID1cbiAgJ1tGYXN0IFJlZnJlc2hdIHBlcmZvcm1pbmcgZnVsbCByZWxvYWRcXG5cXG4nICtcbiAgXCJGYXN0IFJlZnJlc2ggd2lsbCBwZXJmb3JtIGEgZnVsbCByZWxvYWQgd2hlbiB5b3UgZWRpdCBhIGZpbGUgdGhhdCdzIGltcG9ydGVkIGJ5IG1vZHVsZXMgb3V0c2lkZSBvZiB0aGUgUmVhY3QgcmVuZGVyaW5nIHRyZWUuXFxuXCIgK1xuICAnWW91IG1pZ2h0IGhhdmUgYSBmaWxlIHdoaWNoIGV4cG9ydHMgYSBSZWFjdCBjb21wb25lbnQgYnV0IGFsc28gZXhwb3J0cyBhIHZhbHVlIHRoYXQgaXMgaW1wb3J0ZWQgYnkgYSBub24tUmVhY3QgY29tcG9uZW50IGZpbGUuXFxuJyArXG4gICdDb25zaWRlciBtaWdyYXRpbmcgdGhlIG5vbi1SZWFjdCBjb21wb25lbnQgZXhwb3J0IHRvIGEgc2VwYXJhdGUgZmlsZSBhbmQgaW1wb3J0aW5nIGl0IGludG8gYm90aCBmaWxlcy5cXG5cXG4nICtcbiAgJ0l0IGlzIGFsc28gcG9zc2libGUgdGhlIHBhcmVudCBjb21wb25lbnQgb2YgdGhlIGNvbXBvbmVudCB5b3UgZWRpdGVkIGlzIGEgY2xhc3MgY29tcG9uZW50LCB3aGljaCBkaXNhYmxlcyBGYXN0IFJlZnJlc2guXFxuJyArXG4gICdGYXN0IFJlZnJlc2ggcmVxdWlyZXMgYXQgbGVhc3Qgb25lIHBhcmVudCBmdW5jdGlvbiBjb21wb25lbnQgaW4geW91ciBSZWFjdCB0cmVlLidcblxuZXhwb3J0IGNvbnN0IFJFQUNUX1JFRlJFU0hfRlVMTF9SRUxPQURfRlJPTV9FUlJPUiA9XG4gICdbRmFzdCBSZWZyZXNoXSBwZXJmb3JtaW5nIGZ1bGwgcmVsb2FkIGJlY2F1c2UgeW91ciBhcHBsaWNhdGlvbiBoYWQgYW4gdW5yZWNvdmVyYWJsZSBlcnJvcidcblxuZXhwb3J0IGZ1bmN0aW9uIHJlcG9ydEludmFsaWRIbXJNZXNzYWdlKFxuICBtZXNzYWdlOiBITVJfQUNUSU9OX1RZUEVTIHwgTWVzc2FnZUV2ZW50PHVua25vd24+LFxuICBlcnI6IHVua25vd25cbikge1xuICBjb25zb2xlLndhcm4oXG4gICAgJ1tITVJdIEludmFsaWQgbWVzc2FnZTogJyArXG4gICAgICBKU09OLnN0cmluZ2lmeShtZXNzYWdlKSArXG4gICAgICAnXFxuJyArXG4gICAgICAoKGVyciBpbnN0YW5jZW9mIEVycm9yICYmIGVycj8uc3RhY2spIHx8ICcnKVxuICApXG59XG4iXSwibmFtZXMiOlsiUkVBQ1RfUkVGUkVTSF9GVUxMX1JFTE9BRCIsIlJFQUNUX1JFRlJFU0hfRlVMTF9SRUxPQURfRlJPTV9FUlJPUiIsInJlcG9ydEludmFsaWRIbXJNZXNzYWdlIiwibWVzc2FnZSIsImVyciIsImNvbnNvbGUiLCJ3YXJuIiwiSlNPTiIsInN0cmluZ2lmeSIsIkVycm9yIiwic3RhY2siXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztJQUVhQSx5QkFBeUIsRUFBQTtlQUF6QkE7O0lBUUFDLG9DQUFvQyxFQUFBO2VBQXBDQTs7SUFHR0MsdUJBQXVCLEVBQUE7ZUFBdkJBOzs7QUFYVCxNQUFNRiw0QkFDWCw4Q0FDQSxtSUFDQSxxSUFDQSwrR0FDQSw4SEFDQTtBQUVLLE1BQU1DLHVDQUNYO0FBRUssU0FBU0Msd0JBQ2RDLE9BQWlELEVBQ2pEQyxHQUFZO0lBRVpDLFFBQVFDLElBQUksQ0FDViw0QkFDRUMsS0FBS0MsU0FBUyxDQUFDTCxXQUNmLE9BQ0MsQ0FBQ0MsZUFBZUssU0FBQUEsQ0FBU0wsT0FBQUEsT0FBQUEsS0FBQUEsSUFBQUEsSUFBS00sS0FBSyxLQUFLLEVBQUM7QUFFaEQiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNjMzNywgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9zaGFyZWQvbGliL2lzLXBsYWluLW9iamVjdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gZ2V0T2JqZWN0Q2xhc3NMYWJlbCh2YWx1ZTogYW55KTogc3RyaW5nIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWU6IGFueSk6IGJvb2xlYW4ge1xuICBpZiAoZ2V0T2JqZWN0Q2xhc3NMYWJlbCh2YWx1ZSkgIT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBjb25zdCBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpXG5cbiAgLyoqXG4gICAqIHRoaXMgdXNlZCB0byBiZSBwcmV2aW91c2x5OlxuICAgKlxuICAgKiBgcmV0dXJuIHByb3RvdHlwZSA9PT0gbnVsbCB8fCBwcm90b3R5cGUgPT09IE9iamVjdC5wcm90b3R5cGVgXG4gICAqXG4gICAqIGJ1dCBFZGdlIFJ1bnRpbWUgZXhwb3NlIE9iamVjdCBmcm9tIHZtLCBiZWluZyB0aGF0IGtpbmQgb2YgdHlwZS1jaGVja2luZyB3cm9uZ2x5IGZhaWwuXG4gICAqXG4gICAqIEl0IHdhcyBjaGFuZ2VkIHRvIHRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIHNpbmNlIGl0J3MgcmVzaWxpZW50IHRvIHNlcmlhbGl6YXRpb24uXG4gICAqL1xuICByZXR1cm4gcHJvdG90eXBlID09PSBudWxsIHx8IHByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnaXNQcm90b3R5cGVPZicpXG59XG4iXSwibmFtZXMiOlsiZ2V0T2JqZWN0Q2xhc3NMYWJlbCIsImlzUGxhaW5PYmplY3QiLCJ2YWx1ZSIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsImdldFByb3RvdHlwZU9mIiwiaGFzT3duUHJvcGVydHkiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0lBQWdCQSxtQkFBbUIsRUFBQTtlQUFuQkE7O0lBSUFDLGFBQWEsRUFBQTtlQUFiQTs7O0FBSlQsU0FBU0Qsb0JBQW9CRSxLQUFVO0lBQzVDLE9BQU9DLE9BQU9DLFNBQVMsQ0FBQ0MsUUFBUSxDQUFDQyxJQUFJLENBQUNKO0FBQ3hDO0FBRU8sU0FBU0QsY0FBY0MsS0FBVTtJQUN0QyxJQUFJRixvQkFBb0JFLFdBQVcsbUJBQW1CO1FBQ3BELE9BQU87SUFDVDtJQUVBLE1BQU1FLFlBQVlELE9BQU9JLGNBQWMsQ0FBQ0w7SUFFeEM7Ozs7Ozs7O0dBUUMsR0FDRCxPQUFPRSxjQUFjLFFBQVFBLFVBQVVJLGNBQWMsQ0FBQztBQUN4RCIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA2MzgyLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2xpYi9pcy1lcnJvci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc1BsYWluT2JqZWN0IH0gZnJvbSAnLi4vc2hhcmVkL2xpYi9pcy1wbGFpbi1vYmplY3QnXG5cbi8vIFdlIGFsbG93IHNvbWUgYWRkaXRpb25hbCBhdHRhY2hlZCBwcm9wZXJ0aWVzIGZvciBOZXh0LmpzIGVycm9yc1xuZXhwb3J0IGludGVyZmFjZSBOZXh0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIHR5cGU/OiBzdHJpbmdcbiAgcGFnZT86IHN0cmluZ1xuICBjb2RlPzogc3RyaW5nIHwgbnVtYmVyXG4gIGNhbmNlbGxlZD86IGJvb2xlYW5cbiAgZGlnZXN0PzogbnVtYmVyXG59XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgTmV4dEVycm9yLlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBwcmludCBhIG1vcmUgZGV0YWlsZWQgZXJyb3IgbWVzc2FnZSB3aXRoIHByb3BlcnRpZXMgbGlrZSBgY29kZWAgJiBgZGlnZXN0YC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNFcnJvcihlcnI6IHVua25vd24pOiBlcnIgaXMgTmV4dEVycm9yIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2YgZXJyID09PSAnb2JqZWN0JyAmJiBlcnIgIT09IG51bGwgJiYgJ25hbWUnIGluIGVyciAmJiAnbWVzc2FnZScgaW4gZXJyXG4gIClcbn1cblxuZnVuY3Rpb24gc2FmZVN0cmluZ2lmeShvYmo6IGFueSkge1xuICBjb25zdCBzZWVuID0gbmV3IFdlYWtTZXQoKVxuXG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmosIChfa2V5LCB2YWx1ZSkgPT4ge1xuICAgIC8vIElmIHZhbHVlIGlzIGFuIG9iamVjdCBhbmQgYWxyZWFkeSBzZWVuLCByZXBsYWNlIHdpdGggXCJbQ2lyY3VsYXJdXCJcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKHNlZW4uaGFzKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nXG4gICAgICB9XG4gICAgICBzZWVuLmFkZCh2YWx1ZSlcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlXG4gIH0pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQcm9wZXJFcnJvcihlcnI6IHVua25vd24pOiBFcnJvciB7XG4gIGlmIChpc0Vycm9yKGVycikpIHtcbiAgICByZXR1cm4gZXJyXG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAvLyBwcm92aWRlIGJldHRlciBlcnJvciBmb3IgY2FzZSB3aGVyZSBgdGhyb3cgdW5kZWZpbmVkYFxuICAgIC8vIGlzIGNhbGxlZCBpbiBkZXZlbG9wbWVudFxuICAgIGlmICh0eXBlb2YgZXJyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICAgICAgJ0FuIHVuZGVmaW5lZCBlcnJvciB3YXMgdGhyb3duLCAnICtcbiAgICAgICAgICAnc2VlIGhlcmUgZm9yIG1vcmUgaW5mbzogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvdGhyZXctdW5kZWZpbmVkJ1xuICAgICAgKVxuICAgIH1cblxuICAgIGlmIChlcnIgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gICAgICAgICdBIG51bGwgZXJyb3Igd2FzIHRocm93biwgJyArXG4gICAgICAgICAgJ3NlZSBoZXJlIGZvciBtb3JlIGluZm86IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL3RocmV3LXVuZGVmaW5lZCdcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IEVycm9yKGlzUGxhaW5PYmplY3QoZXJyKSA/IHNhZmVTdHJpbmdpZnkoZXJyKSA6IGVyciArICcnKVxufVxuIl0sIm5hbWVzIjpbImlzRXJyb3IiLCJnZXRQcm9wZXJFcnJvciIsImVyciIsInNhZmVTdHJpbmdpZnkiLCJvYmoiLCJzZWVuIiwiV2Vha1NldCIsIkpTT04iLCJzdHJpbmdpZnkiLCJfa2V5IiwidmFsdWUiLCJoYXMiLCJhZGQiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJFcnJvciIsImlzUGxhaW5PYmplY3QiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0lBV0E7OztDQUdDLEdBQ0QsT0FJQyxFQUFBO2VBSnVCQTs7SUFxQlJDLGNBQWMsRUFBQTtlQUFkQTs7OytCQXBDYztBQWVmLFNBQVNELFFBQVFFLEdBQVk7SUFDMUMsT0FDRSxPQUFPQSxRQUFRLFlBQVlBLFFBQVEsUUFBUSxVQUFVQSxPQUFPLGFBQWFBO0FBRTdFO0FBRUEsU0FBU0MsY0FBY0MsR0FBUTtJQUM3QixNQUFNQyxPQUFPLElBQUlDO0lBRWpCLE9BQU9DLEtBQUtDLFNBQVMsQ0FBQ0osS0FBSyxDQUFDSyxNQUFNQztRQUNoQyxvRUFBb0U7UUFDcEUsSUFBSSxPQUFPQSxVQUFVLFlBQVlBLFVBQVUsTUFBTTtZQUMvQyxJQUFJTCxLQUFLTSxHQUFHLENBQUNELFFBQVE7Z0JBQ25CLE9BQU87WUFDVDtZQUNBTCxLQUFLTyxHQUFHLENBQUNGO1FBQ1g7UUFDQSxPQUFPQTtJQUNUO0FBQ0Y7QUFFTyxTQUFTVCxlQUFlQyxHQUFZO0lBQ3pDLElBQUlGLFFBQVFFLE1BQU07UUFDaEIsT0FBT0E7SUFDVDtJQUVBLElBQUlXLFFBQVFDLEdBQUcsQ0FBQ0MsUUFBUSxLQUFLLFdBQWU7UUFDMUMsd0RBQXdEO1FBQ3hELDJCQUEyQjtRQUMzQixJQUFJLE9BQU9iLFFBQVEsYUFBYTtZQUM5QixPQUFPLE9BQUEsY0FHTixDQUhNLElBQUljLE1BQ1Qsb0NBQ0UsNkVBRkcscUJBQUE7dUJBQUE7NEJBQUE7OEJBQUE7WUFHUDtRQUNGO1FBRUEsSUFBSWQsUUFBUSxNQUFNO1lBQ2hCLE9BQU8sT0FBQSxjQUdOLENBSE0sSUFBSWMsTUFDVCw4QkFDRSw2RUFGRyxxQkFBQTt1QkFBQTs0QkFBQTs4QkFBQTtZQUdQO1FBQ0Y7SUFDRjtJQUVBLE9BQU8sT0FBQSxjQUE2RCxDQUE3RCxJQUFJQSxNQUFNQyxDQUFBQSxHQUFBQSxlQUFBQSxhQUFhLEVBQUNmLE9BQU9DLGNBQWNELE9BQU9BLE1BQU0sS0FBMUQscUJBQUE7ZUFBQTtvQkFBQTtzQkFBQTtJQUE0RDtBQUNyRSIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA2NDU3LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2NsaWVudC9saWIvY29uc29sZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgaXNFcnJvciBmcm9tICcuLi8uLi9saWIvaXMtZXJyb3InXG5cbmZ1bmN0aW9uIGZvcm1hdE9iamVjdChhcmc6IHVua25vd24sIGRlcHRoOiBudW1iZXIpIHtcbiAgc3dpdGNoICh0eXBlb2YgYXJnKSB7XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGlmIChhcmcgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICdudWxsJ1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9ICdbJ1xuICAgICAgICBpZiAoZGVwdGggPCAxKSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgIT09ICdbJykge1xuICAgICAgICAgICAgICByZXN1bHQgKz0gJywnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFyZywgaSkpIHtcbiAgICAgICAgICAgICAgcmVzdWx0ICs9IGZvcm1hdE9iamVjdChhcmdbaV0sIGRlcHRoICsgMSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0ICs9IGFyZy5sZW5ndGggPiAwID8gJy4uLicgOiAnJ1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSAnXSdcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgfSBlbHNlIGlmIChhcmcgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICByZXR1cm4gYXJnICsgJydcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhhcmcpXG4gICAgICAgIGxldCByZXN1bHQgPSAneydcbiAgICAgICAgaWYgKGRlcHRoIDwgMSkge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXVxuICAgICAgICAgICAgY29uc3QgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYXJnLCAna2V5JylcbiAgICAgICAgICAgIGlmIChkZXNjICYmICFkZXNjLmdldCAmJiAhZGVzYy5zZXQpIHtcbiAgICAgICAgICAgICAgY29uc3QganNvbktleSA9IEpTT04uc3RyaW5naWZ5KGtleSlcbiAgICAgICAgICAgICAgaWYgKGpzb25LZXkgIT09ICdcIicgKyBrZXkgKyAnXCInKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGpzb25LZXkgKyAnOiAnXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGtleSArICc6ICdcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXN1bHQgKz0gZm9ybWF0T2JqZWN0KGRlc2MudmFsdWUsIGRlcHRoICsgMSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0ICs9IGtleXMubGVuZ3RoID4gMCA/ICcuLi4nIDogJydcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gJ30nXG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgIH1cbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZylcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFN0cmluZyhhcmcpXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdENvbnNvbGVBcmdzKGFyZ3M6IHVua25vd25bXSk6IHN0cmluZyB7XG4gIGxldCBtZXNzYWdlOiBzdHJpbmdcbiAgbGV0IGlkeDogbnVtYmVyXG4gIGlmICh0eXBlb2YgYXJnc1swXSA9PT0gJ3N0cmluZycpIHtcbiAgICBtZXNzYWdlID0gYXJnc1swXVxuICAgIGlkeCA9IDFcbiAgfSBlbHNlIHtcbiAgICBtZXNzYWdlID0gJydcbiAgICBpZHggPSAwXG4gIH1cbiAgbGV0IHJlc3VsdCA9ICcnXG4gIGxldCBzdGFydFF1b3RlID0gZmFsc2VcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXNzYWdlLmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgY2hhciA9IG1lc3NhZ2VbaV1cbiAgICBpZiAoY2hhciAhPT0gJyUnIHx8IGkgPT09IG1lc3NhZ2UubGVuZ3RoIC0gMSB8fCBpZHggPj0gYXJncy5sZW5ndGgpIHtcbiAgICAgIHJlc3VsdCArPSBjaGFyXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGNvbnN0IGNvZGUgPSBtZXNzYWdlWysraV1cbiAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgIGNhc2UgJ2MnOiB7XG4gICAgICAgIC8vIFRPRE86IFdlIHNob3VsZCBjb2xvcml6ZSB3aXRoIEhUTUwgaW5zdGVhZCBvZiB0dXJuaW5nIGludG8gYSBzdHJpbmcuXG4gICAgICAgIC8vIElnbm9yZSBmb3Igbm93LlxuICAgICAgICByZXN1bHQgPSBzdGFydFF1b3RlID8gYCR7cmVzdWx0fV1gIDogYFske3Jlc3VsdH1gXG4gICAgICAgIHN0YXJ0UXVvdGUgPSAhc3RhcnRRdW90ZVxuICAgICAgICBpZHgrK1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgY2FzZSAnTyc6XG4gICAgICBjYXNlICdvJzoge1xuICAgICAgICByZXN1bHQgKz0gZm9ybWF0T2JqZWN0KGFyZ3NbaWR4KytdLCAwKVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgY2FzZSAnZCc6XG4gICAgICBjYXNlICdpJzoge1xuICAgICAgICByZXN1bHQgKz0gcGFyc2VJbnQoYXJnc1tpZHgrK10gYXMgYW55LCAxMClcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ2YnOiB7XG4gICAgICAgIHJlc3VsdCArPSBwYXJzZUZsb2F0KGFyZ3NbaWR4KytdIGFzIGFueSlcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ3MnOiB7XG4gICAgICAgIHJlc3VsdCArPSBTdHJpbmcoYXJnc1tpZHgrK10pXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXN1bHQgKz0gJyUnICsgY29kZVxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBpZHggPCBhcmdzLmxlbmd0aDsgaWR4KyspIHtcbiAgICByZXN1bHQgKz0gKGlkeCA+IDAgPyAnICcgOiAnJykgKyBmb3JtYXRPYmplY3QoYXJnc1tpZHhdLCAwKVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VDb25zb2xlQXJncyhhcmdzOiB1bmtub3duW10pOiB7XG4gIGVudmlyb25tZW50TmFtZTogc3RyaW5nIHwgbnVsbFxuICBlcnJvcjogRXJyb3IgfCBudWxsXG59IHtcbiAgLy8gU2VlXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iLzY1YTU2ZDBlOTkyNjE0ODFjNzIxMzM0YTNlYzQ1NjFkMTczNTk0Y2QvcGFja2FnZXMvcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL2ZsaWdodC9yZW5kZXJlci5qcyNMODgtTDkzXG4gIC8vXG4gIC8vIExvZ3MgcmVwbGF5ZWQgZnJvbSB0aGUgc2VydmVyIGxvb2sgbGlrZSB0aGlzOlxuICAvLyBbXG4gIC8vICAgXCIlYyVzJWMgJW9cXG5cXG4lc1xcblxcbiVzXFxuXCIsXG4gIC8vICAgXCJiYWNrZ3JvdW5kOiAjZTZlNmU2OyAuLi5cIixcbiAgLy8gICBcIiBTZXJ2ZXIgXCIsIC8vIGNhbiBhbHNvIGJlIGUuZy4gXCIgUHJlcmVuZGVyIFwiXG4gIC8vICAgXCJcIixcbiAgLy8gICBFcnJvcixcbiAgLy8gICBcIlRoZSBhYm92ZSBlcnJvciBvY2N1cnJlZCBpbiB0aGUgPFBhZ2U+IGNvbXBvbmVudC5cIixcbiAgLy8gICAuLi5cbiAgLy8gXVxuICBpZiAoXG4gICAgYXJncy5sZW5ndGggPiAzICYmXG4gICAgdHlwZW9mIGFyZ3NbMF0gPT09ICdzdHJpbmcnICYmXG4gICAgYXJnc1swXS5zdGFydHNXaXRoKCclYyVzJWMgJykgJiZcbiAgICB0eXBlb2YgYXJnc1sxXSA9PT0gJ3N0cmluZycgJiZcbiAgICB0eXBlb2YgYXJnc1syXSA9PT0gJ3N0cmluZycgJiZcbiAgICB0eXBlb2YgYXJnc1szXSA9PT0gJ3N0cmluZydcbiAgKSB7XG4gICAgY29uc3QgZW52aXJvbm1lbnROYW1lID0gYXJnc1syXVxuICAgIGNvbnN0IG1heWJlRXJyb3IgPSBhcmdzWzRdXG5cbiAgICByZXR1cm4ge1xuICAgICAgZW52aXJvbm1lbnROYW1lOiBlbnZpcm9ubWVudE5hbWUudHJpbSgpLFxuICAgICAgZXJyb3I6IGlzRXJyb3IobWF5YmVFcnJvcikgPyBtYXliZUVycm9yIDogbnVsbCxcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGVudmlyb25tZW50TmFtZTogbnVsbCxcbiAgICBlcnJvcjogbnVsbCxcbiAgfVxufVxuIl0sIm5hbWVzIjpbImZvcm1hdENvbnNvbGVBcmdzIiwicGFyc2VDb25zb2xlQXJncyIsImZvcm1hdE9iamVjdCIsImFyZyIsImRlcHRoIiwiQXJyYXkiLCJpc0FycmF5IiwicmVzdWx0IiwiaSIsImxlbmd0aCIsIk9iamVjdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsIkVycm9yIiwia2V5cyIsImtleSIsImRlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJnZXQiLCJzZXQiLCJqc29uS2V5IiwiSlNPTiIsInN0cmluZ2lmeSIsInZhbHVlIiwiU3RyaW5nIiwiYXJncyIsIm1lc3NhZ2UiLCJpZHgiLCJzdGFydFF1b3RlIiwiY2hhciIsImNvZGUiLCJwYXJzZUludCIsInBhcnNlRmxvYXQiLCJzdGFydHNXaXRoIiwiZW52aXJvbm1lbnROYW1lIiwibWF5YmVFcnJvciIsInRyaW0iLCJlcnJvciIsImlzRXJyb3IiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0lBdURnQkEsaUJBQWlCLEVBQUE7ZUFBakJBOztJQTJEQUMsZ0JBQWdCLEVBQUE7ZUFBaEJBOzs7O2tFQWxISTtBQUVwQixTQUFTQyxhQUFhQyxHQUFZLEVBQUVDLEtBQWE7SUFDL0MsT0FBUSxPQUFPRDtRQUNiLEtBQUs7WUFDSCxJQUFJQSxRQUFRLE1BQU07Z0JBQ2hCLE9BQU87WUFDVCxPQUFPLElBQUlFLE1BQU1DLE9BQU8sQ0FBQ0gsTUFBTTtnQkFDN0IsSUFBSUksU0FBUztnQkFDYixJQUFJSCxRQUFRLEdBQUc7b0JBQ2IsSUFBSyxJQUFJSSxJQUFJLEdBQUdBLElBQUlMLElBQUlNLE1BQU0sRUFBRUQsSUFBSzt3QkFDbkMsSUFBSUQsV0FBVyxLQUFLOzRCQUNsQkEsVUFBVTt3QkFDWjt3QkFDQSxJQUFJRyxPQUFPQyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDVixLQUFLSyxJ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LEVBQUMsSUFBSzFCLGFBQWF3QixJQUFJLENBQUNFLElBQUksRUFBRTtJQUMzRDtJQUVBLE9BQU9yQjtBQUNUO0FBRU8sU0FBU04saUJBQWlCeUIsSUFBZTtJQUk5QyxNQUFNO0lBQ04sd0pBQXdKO0lBQ3hKLEVBQUU7SUFDRixnREFBZ0Q7SUFDaEQsSUFBSTtJQUNKLCtCQUErQjtJQUMvQixnQ0FBZ0M7SUFDaEMsa0RBQWtEO0lBQ2xELFFBQVE7SUFDUixXQUFXO0lBQ1gseURBQXlEO0lBQ3pELFFBQVE7SUFDUixJQUFJO0lBQ0osSUFDRUEsS0FBS2pCLE1BQU0sR0FBRyxLQUNkLE9BQU9pQixJQUFJLENBQUMsRUFBRSxLQUFLLFlBQ25CQSxJQUFJLENBQUMsRUFBRSxDQUFDUSxVQUFVLENBQUMsY0FDbkIsT0FBT1IsSUFBSSxDQUFDLEVBQUUsS0FBSyxZQUNuQixPQUFPQSxJQUFJLENBQUMsRUFBRSxLQUFLLFlBQ25CLE9BQU9BLElBQUksQ0FBQyxFQUFFLEtBQUssVUFDbkI7UUFDQSxNQUFNUyxrQkFBa0JULElBQUksQ0FBQyxFQUFFO1FBQy9CLE1BQU1VLGFBQWFWLElBQUksQ0FBQyxFQUFFO1FBRTFCLE9BQU87WUFDTFMsaUJBQWlCQSxnQkFBZ0JFLElBQUk7WUFDckNDLE9BQU9DLENBQUFBLEdBQUFBLFNBQUFBLE9BQU8sRUFBQ0gsY0FBY0EsYUFBYTtRQUM1QztJQUNGO0lBRUEsT0FBTztRQUNMRCxpQkFBaUI7UUFDakJHLE9BQU87SUFDVDtBQUNGIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDY2MzIsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvbmV4dC1kZXZ0b29scy9zaGFyZWQvY29uc29sZS1lcnJvci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUbyBkaXN0aW5ndWlzaCBmcm9tIFJlYWN0IGVycm9yLmRpZ2VzdCwgd2UgdXNlIGEgZGlmZmVyZW50IHN5bWJvbCBoZXJlIHRvIGRldGVybWluZSBpZiB0aGUgZXJyb3IgaXMgZnJvbSBjb25zb2xlLmVycm9yIG9yIHVuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbi5cbmNvbnN0IGRpZ2VzdFN5bSA9IFN5bWJvbC5mb3IoJ25leHQuY29uc29sZS5lcnJvci5kaWdlc3QnKVxuXG4vLyBSZXByZXNlbnQgbm9uIEVycm9yIHNoYXBlIHVuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbnMgb3IgY29uc29sZS5lcnJvciBlcnJvcnMuXG4vLyBUaG9zZSBlcnJvcnMgd2lsbCBiZSBjYXB0dXJlZCBhbmQgZGlzcGxheWVkIGluIEVycm9yIE92ZXJsYXkuXG5leHBvcnQgdHlwZSBDb25zb2xlRXJyb3IgPSBFcnJvciAmIHtcbiAgW2RpZ2VzdFN5bV06ICdORVhUX0NPTlNPTEVfRVJST1InXG4gIGVudmlyb25tZW50TmFtZTogc3RyaW5nXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb25zb2xlRXJyb3IoXG4gIG1lc3NhZ2U6IHN0cmluZyB8IEVycm9yLFxuICBlbnZpcm9ubWVudE5hbWU/OiBzdHJpbmcgfCBudWxsXG4pOiBDb25zb2xlRXJyb3Ige1xuICBjb25zdCBlcnJvciA9IChcbiAgICB0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycgPyBuZXcgRXJyb3IobWVzc2FnZSkgOiBtZXNzYWdlXG4gICkgYXMgQ29uc29sZUVycm9yXG4gIGVycm9yW2RpZ2VzdFN5bV0gPSAnTkVYVF9DT05TT0xFX0VSUk9SJ1xuXG4gIGlmIChlbnZpcm9ubWVudE5hbWUgJiYgIWVycm9yLmVudmlyb25tZW50TmFtZSkge1xuICAgIGVycm9yLmVudmlyb25tZW50TmFtZSA9IGVudmlyb25tZW50TmFtZVxuICB9XG5cbiAgcmV0dXJuIGVycm9yXG59XG5cbmV4cG9ydCBjb25zdCBpc0NvbnNvbGVFcnJvciA9IChlcnJvcjogYW55KTogZXJyb3IgaXMgQ29uc29sZUVycm9yID0+IHtcbiAgcmV0dXJuIGVycm9yICYmIGVycm9yW2RpZ2VzdFN5bV0gPT09ICdORVhUX0NPTlNPTEVfRVJST1InXG59XG4iXSwibmFtZXMiOlsiY3JlYXRlQ29uc29sZUVycm9yIiwiaXNDb25zb2xlRXJyb3IiLCJkaWdlc3RTeW0iLCJTeW1ib2wiLCJmb3IiLCJtZXNzYWdlIiwiZW52aXJvbm1lbnROYW1lIiwiZXJyb3IiLCJFcnJvciJdLCJtYXBwaW5ncyI6IkFBQUEseUpBQXlKOzs7Ozs7Ozs7Ozs7Ozs7SUFVeklBLGtCQUFrQixFQUFBO2VBQWxCQTs7SUFnQkhDLGNBQWMsRUFBQTtlQUFkQTs7O0FBekJiLE1BQU1DLFlBQVlDLE9BQU9DLEdBQUcsQ0FBQztBQVN0QixTQUFTSixtQkFDZEssT0FBdUIsRUFDdkJDLGVBQStCO0lBRS9CLE1BQU1DLFFBQ0osT0FBT0YsWUFBWSxXQUFXLE9BQUEsY0FBa0IsQ0FBbEIsSUFBSUcsTUFBTUgsVUFBVixxQkFBQTtlQUFBO29CQUFBO3NCQUFBO0lBQWlCLEtBQUlBO0lBRXJERSxLQUFLLENBQUNMLFVBQVUsR0FBRztJQUVuQixJQUFJSSxtQkFBbUIsQ0FBQ0MsTUFBTUQsZUFBZSxFQUFFO1FBQzdDQyxNQUFNRCxlQUFlLEdBQUdBO0lBQzFCO0lBRUEsT0FBT0M7QUFDVDtBQUVPLE1BQU1OLGlCQUFpQixDQUFDTTtJQUM3QixPQUFPQSxTQUFTQSxLQUFLLENBQUNMLFVBQVUsS0FBSztBQUN2QyIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA2NjgzLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL25leHQtZGV2dG9vbHMvdXNlcnNwYWNlL2FwcC9lcnJvcnMvc3RpdGNoZWQtZXJyb3IudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IGlzRXJyb3IgZnJvbSAnLi4vLi4vLi4vLi4vbGliL2lzLWVycm9yJ1xuXG5jb25zdCBvd25lclN0YWNrcyA9IG5ldyBXZWFrTWFwPEVycm9yLCBzdHJpbmcgfCBudWxsPigpXG5jb25zdCBjb21wb25lbnRTdGFja3MgPSBuZXcgV2Vha01hcDxFcnJvciwgc3RyaW5nPigpXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb21wb25lbnRTdGFjayhlcnJvcjogRXJyb3IpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICByZXR1cm4gY29tcG9uZW50U3RhY2tzLmdldChlcnJvcilcbn1cbmV4cG9ydCBmdW5jdGlvbiBzZXRDb21wb25lbnRTdGFjayhlcnJvcjogRXJyb3IsIHN0YWNrOiBzdHJpbmcpIHtcbiAgY29tcG9uZW50U3RhY2tzLnNldChlcnJvciwgc3RhY2spXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRPd25lclN0YWNrKGVycm9yOiBFcnJvcik6IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQge1xuICByZXR1cm4gb3duZXJTdGFja3MuZ2V0KGVycm9yKVxufVxuZXhwb3J0IGZ1bmN0aW9uIHNldE93bmVyU3RhY2soZXJyb3I6IEVycm9yLCBzdGFjazogc3RyaW5nIHwgbnVsbCkge1xuICBvd25lclN0YWNrcy5zZXQoZXJyb3IsIHN0YWNrKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29lcmNlRXJyb3IodmFsdWU6IHVua25vd24pOiBFcnJvciB7XG4gIHJldHVybiBpc0Vycm9yKHZhbHVlKSA/IHZhbHVlIDogbmV3IEVycm9yKCcnICsgdmFsdWUpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRPd25lclN0YWNrSWZBdmFpbGFibGUoZXJyb3I6IEVycm9yKTogdm9pZCB7XG4gIC8vIFJlYWN0IDE4IGFuZCBwcm9kIGRvZXMgbm90IGhhdmUgYGNhcHR1cmVPd25lclN0YWNrYFxuICBpZiAoJ2NhcHR1cmVPd25lclN0YWNrJyBpbiBSZWFjdCkge1xuICAgIHNldE93bmVyU3RhY2soZXJyb3IsIFJlYWN0LmNhcHR1cmVPd25lclN0YWNrKCkpXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlY29yYXRlRGV2RXJyb3IoXG4gIHRocm93blZhbHVlOiB1bmtub3duLFxuICBlcnJvckluZm86IFJlYWN0LkVycm9ySW5mb1xuKSB7XG4gIGNvbnN0IGVycm9yID0gY29lcmNlRXJyb3IodGhyb3duVmFsdWUpXG4gIHNldE93bmVyU3RhY2tJZkF2YWlsYWJsZShlcnJvcilcbiAgLy8gVE9ETzogY2hhbmdlIHRvIHBhc3NpbmcgZG93biBlcnJvckluZm8gbGF0ZXJcbiAgLy8gSW4gZGV2ZWxvcG1lbnQgbW9kZSwgcGFzcyBhbG9uZyB0aGUgY29tcG9uZW50IHN0YWNrIHRvIHRoZSBlcnJvclxuICBpZiAoZXJyb3JJbmZvLmNvbXBvbmVudFN0YWNrKSB7XG4gICAgc2V0Q29tcG9uZW50U3RhY2soZXJyb3IsIGVycm9ySW5mby5jb21wb25lbnRTdGFjaylcbiAgfVxuICByZXR1cm4gZXJyb3Jcbn1cbiJdLCJuYW1lcyI6WyJjb2VyY2VFcnJvciIsImRlY29yYXRlRGV2RXJyb3IiLCJnZXRDb21wb25lbnRTdGFjayIsImdldE93bmVyU3RhY2siLCJzZXRDb21wb25lbnRTdGFjayIsInNldE93bmVyU3RhY2siLCJzZXRPd25lclN0YWNrSWZBdmFpbGFibGUiLCJvd25lclN0YWNrcyIsIldlYWtNYXAiLCJjb21wb25lbnRTdGFja3MiLCJlcnJvciIsImdldCIsInN0YWNrIiwic2V0IiwidmFsdWUiLCJpc0Vycm9yIiwiRXJyb3IiLCJSZWFjdCIsImNhcHR1cmVPd25lclN0YWNrIiwidGhyb3duVmFsdWUiLCJlcnJvckluZm8iLCJjb21wb25lbnRTdGFjayJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQW9CZ0JBLFdBQVcsRUFBQTtlQUFYQTs7SUFXQUMsZ0JBQWdCLEVBQUE7ZUFBaEJBOztJQXpCQUMsaUJBQWlCLEVBQUE7ZUFBakJBOztJQU9BQyxhQUFhLEVBQUE7ZUFBYkE7O0lBSkFDLGlCQUFpQixFQUFBO2VBQWpCQTs7SUFPQUMsYUFBYSxFQUFBO2VBQWJBOztJQVFBQyx3QkFBd0IsRUFBQTtlQUF4QkE7Ozs7Z0VBeEJFO2tFQUNFO0FBRXBCLE1BQU1DLGNBQWMsSUFBSUM7QUFDeEIsTUFBTUMsa0JBQWtCLElBQUlEO0FBRXJCLFNBQVNOLGtCQUFrQlEsS0FBWTtJQUM1QyxPQUFPRCxnQkFBZ0JFLEdBQUcsQ0FBQ0Q7QUFDN0I7QUFDTyxTQUFTTixrQkFBa0JNLEtBQVksRUFBRUUsS0FBYTtJQUMzREgsZ0JBQWdCSSxHQUFHLENBQUNILE9BQU9FO0FBQzdCO0FBRU8sU0FBU1QsY0FBY08sS0FBWTtJQUN4QyxPQUFPSCxZQUFZSSxHQUFHLENBQUNEO0FBQ3pCO0FBQ08sU0FBU0wsY0FBY0ssS0FBWSxFQUFFRSxLQUFvQjtJQUM5REwsWUFBWU0sR0FBRyxDQUFDSCxPQUFPRTtBQUN6QjtBQUVPLFNBQVNaLFlBQVljLEtBQWM7SUFDeEMsT0FBT0MsQ0FBQUEsR0FBQUEsU0FBQUEsT0FBTyxFQUFDRCxTQUFTQSxRQUFRLE9BQUEsY0FBcUIsQ0FBckIsSUFBSUUsTUFBTSxLQUFLRixRQUFmLHFCQUFBO2VBQUE7b0JBQUE7c0JBQUE7SUFBb0I7QUFDdEQ7QUFFTyxTQUFTUix5QkFBeUJJLEtBQVk7SUFDbkQsc0RBQXNEO0lBQ3RELElBQUksdUJBQXVCTyxPQUFBQSxPQUFLLEVBQUU7UUFDaENaLGNBQWNLLE9BQU9PLE9BQUFBLE9BQUssQ0FBQ0MsaUJBQWlCO0lBQzlDO0FBQ0Y7QUFFTyxTQUFTakIsaUJBQ2RrQixXQUFvQixFQUNwQkMsU0FBMEI7SUFFMUIsTUFBTVYsUUFBUVYsWUFBWW1CO0lBQzFCYix5QkFBeUJJO0lBQ3pCLCtDQUErQztJQUMvQyxtRUFBbUU7SUFDbkUsSUFBSVUsVUFBVUMsY0FBYyxFQUFFO1FBQzVCakIsa0JBQWtCTSxPQUFPVSxVQUFVQyxjQUFjO0lBQ25EO0lBQ0EsT0FBT1g7QUFDVCIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA2Nzc2LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9zYWZlLXN0YWJsZS1zdHJpbmdpZnkvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIGU9ezg3OTpmdW5jdGlvbihlLHQpe2NvbnN0e2hhc093blByb3BlcnR5Om59PU9iamVjdC5wcm90b3R5cGU7Y29uc3Qgcj1jb25maWd1cmUoKTtyLmNvbmZpZ3VyZT1jb25maWd1cmU7ci5zdHJpbmdpZnk9cjtyLmRlZmF1bHQ9cjt0LnN0cmluZ2lmeT1yO3QuY29uZmlndXJlPWNvbmZpZ3VyZTtlLmV4cG9ydHM9cjtjb25zdCBpPS9bXFx1MDAwMC1cXHUwMDFmXFx1MDAyMlxcdTAwNWNcXHVkODAwLVxcdWRmZmZdLztmdW5jdGlvbiBzdHJFc2NhcGUoZSl7aWYoZS5sZW5ndGg8NWUzJiYhaS50ZXN0KGUpKXtyZXR1cm5gXCIke2V9XCJgfXJldHVybiBKU09OLnN0cmluZ2lmeShlKX1mdW5jdGlvbiBzb3J0KGUsdCl7aWYoZS5sZW5ndGg+MjAwfHx0KXtyZXR1cm4gZS5zb3J0KHQpfWZvcihsZXQgdD0xO3Q8ZS5sZW5ndGg7dCsrKXtjb25zdCBuPWVbdF07bGV0IHI9dDt3aGlsZShyIT09MCYmZVtyLTFdPm4pe2Vbcl09ZVtyLTFdO3ItLX1lW3JdPW59cmV0dXJuIGV9Y29uc3QgZj1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE9iamVjdC5nZXRQcm90b3R5cGVPZihPYmplY3QuZ2V0UHJvdG90eXBlT2YobmV3IEludDhBcnJheSkpLFN5bWJvbC50b1N0cmluZ1RhZykuZ2V0O2Z1bmN0aW9uIGlzVHlwZWRBcnJheVdpdGhFbnRyaWVzKGUpe3JldHVybiBmLmNhbGwoZSkhPT11bmRlZmluZWQmJmUubGVuZ3RoIT09MH1mdW5jdGlvbiBzdHJpbmdpZnlUeXBlZEFycmF5KGUsdCxuKXtpZihlLmxlbmd0aDxuKXtuPWUubGVuZ3RofWNvbnN0IHI9dD09PVwiLFwiP1wiXCI6XCIgXCI7bGV0IGk9YFwiMFwiOiR7cn0ke2VbMF19YDtmb3IobGV0IGY9MTtmPG47ZisrKXtpKz1gJHt0fVwiJHtmfVwiOiR7cn0ke2VbZl19YH1yZXR1cm4gaX1mdW5jdGlvbiBnZXRDaXJjdWxhclZhbHVlT3B0aW9uKGUpe2lmKG4uY2FsbChlLFwiY2lyY3VsYXJWYWx1ZVwiKSl7Y29uc3QgdD1lLmNpcmN1bGFyVmFsdWU7aWYodHlwZW9mIHQ9PT1cInN0cmluZ1wiKXtyZXR1cm5gXCIke3R9XCJgfWlmKHQ9PW51bGwpe3JldHVybiB0fWlmKHQ9PT1FcnJvcnx8dD09PVR5cGVFcnJvcil7cmV0dXJue3RvU3RyaW5nKCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkNvbnZlcnRpbmcgY2lyY3VsYXIgc3RydWN0dXJlIHRvIEpTT05cIil9fX10aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJjaXJjdWxhclZhbHVlXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZyBvciB0aGUgdmFsdWUgbnVsbCBvciB1bmRlZmluZWQnKX1yZXR1cm4nXCJbQ2lyY3VsYXJdXCInfWZ1bmN0aW9uIGdldERldGVybWluaXN0aWNPcHRpb24oZSl7bGV0IHQ7aWYobi5jYWxsKGUsXCJkZXRlcm1pbmlzdGljXCIpKXt0PWUuZGV0ZXJtaW5pc3RpYztpZih0eXBlb2YgdCE9PVwiYm9vbGVhblwiJiZ0eXBlb2YgdCE9PVwiZnVuY3Rpb25cIil7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwiZGV0ZXJtaW5pc3RpY1wiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBib29sZWFuIG9yIGNvbXBhcmF0b3IgZnVuY3Rpb24nKX19cmV0dXJuIHQ9PT11bmRlZmluZWQ/dHJ1ZTp0fWZ1bmN0aW9uIGdldEJvb2xlYW5PcHRpb24oZSx0KXtsZXQgcjtpZihuLmNhbGwoZSx0KSl7cj1lW3RdO2lmKHR5cGVvZiByIT09XCJib29sZWFuXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcIiR7dH1cIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgYm9vbGVhbmApfX1yZXR1cm4gcj09PXVuZGVmaW5lZD90cnVlOnJ9ZnVuY3Rpb24gZ2V0UG9zaXRpdmVJbnRlZ2VyT3B0aW9uKGUsdCl7bGV0IHI7aWYobi5jYWxsKGUsdCkpe3I9ZVt0XTtpZih0eXBlb2YgciE9PVwibnVtYmVyXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcIiR7dH1cIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyYCl9aWYoIU51bWJlci5pc0ludGVnZXIocikpe3Rocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcIiR7dH1cIiBhcmd1bWVudCBtdXN0IGJlIGFuIGludGVnZXJgKX1pZihyPDEpe3Rocm93IG5ldyBSYW5nZUVycm9yKGBUaGUgXCIke3R9XCIgYXJndW1lbnQgbXVzdCBiZSA+PSAxYCl9fXJldHVybiByPT09dW5kZWZpbmVkP0luZmluaXR5OnJ9ZnVuY3Rpb24gZ2V0SXRlbUNvdW50KGUpe2lmKGU9PT0xKXtyZXR1cm5cIjEgaXRlbVwifXJldHVybmAke2V9IGl0ZW1zYH1mdW5jdGlvbiBnZXRVbmlxdWVSZXBsYWNlclNldChlKXtjb25zdCB0PW5ldyBTZXQ7Zm9yKGNvbnN0IG4gb2YgZSl7aWYodHlwZW9mIG49PT1cInN0cmluZ1wifHx0eXBlb2Ygbj09PVwibnVtYmVyXCIpe3QuYWRkKFN0cmluZyhuKSl9fXJldHVybiB0fWZ1bmN0aW9uIGdldFN0cmljdE9wdGlvbihlKXtpZihuLmNhbGwoZSxcInN0cmljdFwiKSl7Y29uc3QgdD1lLnN0cmljdDtpZih0eXBlb2YgdCE9PVwiYm9vbGVhblwiKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJzdHJpY3RcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgYm9vbGVhbicpfWlmKHQpe3JldHVybiBlPT57bGV0IHQ9YE9iamVjdCBjYW4gbm90IHNhZmVseSBiZSBzdHJpbmdpZmllZC4gUmVjZWl2ZWQgdHlwZSAke3R5cGVvZiBlfWA7aWYodHlwZW9mIGUhPT1cImZ1bmN0aW9uXCIpdCs9YCAoJHtlLnRvU3RyaW5nKCl9KWA7dGhyb3cgbmV3IEVycm9yKHQpfX19fWZ1bmN0aW9uIGNvbmZpZ3VyZShlKXtlPXsuLi5lfTtjb25zdCB0PWdldFN0cmljdE9wdGlvbihlKTtpZih0KXtpZihlLmJpZ2ludD09PXVuZGVmaW5lZCl7ZS5iaWdpbnQ9ZmFsc2V9aWYoIShcImNpcmN1bGFyVmFsdWVcImluIGUpKXtlLmNpcmN1bGFyVmFsdWU9RXJyb3J9fWNvbnN0IG49Z2V0Q2lyY3VsYXJWYWx1ZU9wdGlvbihlKTtjb25zdCByPWdldEJvb2xlYW5PcHRpb24oZSxcImJpZ2ludFwiKTtjb25zdCBpPWdldERldGVybWluaXN0aWNPcHRpb24oZSk7Y29uc3QgZj10eXBlb2YgaT09PVwiZnVuY3Rpb25cIj9pOnVuZGVmaW5lZDtjb25zdCB1PWdldFBvc2l0aXZlSW50ZWdlck9wdGlvbihlLFwibWF4aW11bURlcHRoXCIpO2NvbnN0IG89Z2V0UG9zaXRpdmVJbnRlZ2VyT3B0aW9uKGUsXCJtYXhpbXVtQnJlYWR0aFwiKTtmdW5jdGlvbiBzdHJpbmdpZnlGblJlcGxhY2VyKGUscyxsLGMsYSxnKXtsZXQgcD1zW2VdO2lmKHR5cGVvZiBwPT09XCJvYmplY3RcIiYmcCE9PW51bGwmJnR5cGVvZiBwLnRvSlNPTj09PVwiZnVuY3Rpb25cIil7cD1wLnRvSlNPTihlKX1wPWMuY2FsbChzLGUscCk7c3dpdGNoKHR5cGVvZiBwKXtjYXNlXCJzdHJpbmdcIjpyZXR1cm4gc3RyRXNjYXBlKHApO2Nhc2VcIm9iamVjdFwiOntpZihwPT09bnVsbCl7cmV0dXJuXCJudWxsXCJ9aWYobC5pbmRleE9mKHApIT09LTEpe3JldHVybiBufWxldCBlPVwiXCI7bGV0IHQ9XCIsXCI7Y29uc3Qgcj1nO2lmKEFycmF5LmlzQXJyYXkocCkpe2lmKHAubGVuZ3RoPT09MCl7cmV0dXJuXCJbXVwifWlmKHU8bC5sZW5ndGgrMSl7cmV0dXJuJ1wiW0FycmF5XVwiJ31sLnB1c2gocCk7aWYoYSE9PVwiXCIpe2crPWE7ZSs9YFxcbiR7Z31gO3Q9YCxcXG4ke2d9YH1jb25zdCBuPU1hdGgubWluKHAubGVuZ3RoLG8pO2xldCBpPTA7Zm9yKDtpPG4tMTtpKyspe2NvbnN0IG49c3RyaW5naWZ5Rm5SZXBsYWNlcihTdHJpbmcoaSkscCxsLGMsYSxnKTtlKz1uIT09dW5kZWZpbmVkP246XCJudWxsXCI7ZSs9dH1jb25zdCBmPXN0cmluZ2lmeUZuUmVwbGFjZXIoU3RyaW5nKGkpLHAsbCxjLGEsZyk7ZSs9ZiE9PXVuZGVmaW5lZD9mOlwibnVsbFwiO2lmKHAubGVuZ3RoLTE+byl7Y29uc3Qgbj1wLmxlbmd0aC1vLTE7ZSs9YCR7dH1cIi4uLiAke2dldEl0ZW1Db3VudChuKX0gbm90IHN0cmluZ2lmaWVkXCJgfWlmKGEhPT1cIlwiKXtlKz1gXFxuJHtyfWB9bC5wb3AoKTtyZXR1cm5gWyR7ZX1dYH1sZXQgcz1PYmplY3Qua2V5cyhwKTtjb25zdCB5PXMubGVuZ3RoO2lmKHk9PT0wKXtyZXR1cm5cInt9XCJ9aWYodTxsLmxlbmd0aCsxKXtyZXR1cm4nXCJbT2JqZWN0XVwiJ31sZXQgZD1cIlwiO2xldCBoPVwiXCI7aWYoYSE9PVwiXCIpe2crPWE7dD1gLFxcbiR7Z31gO2Q9XCIgXCJ9Y29uc3QgJD1NYXRoLm1pbih5LG8pO2lmKGkmJiFpc1R5cGVkQXJyYXlXaXRoRW50cmllcyhwKSl7cz1zb3J0KHMsZil9bC5wdXNoKHApO2ZvcihsZXQgbj0wO248JDtuKyspe2NvbnN0IHI9c1tuXTtjb25zdCBpPXN0cmluZ2lmeUZuUmVwbGFjZXIocixwLGwsYyxhLGcpO2lmKGkhPT11bmRlZmluZWQpe2UrPWAke2h9JHtzdHJFc2NhcGUocil9OiR7ZH0ke2l9YDtoPXR9fWlmKHk+byl7Y29uc3Qgbj15LW87ZSs9YCR7aH1cIi4uLlwiOiR7ZH1cIiR7Z2V0SXRlbUNvdW50KG4pfSBub3Qgc3RyaW5naWZpZWRcImA7aD10fWlmKGEhPT1cIlwiJiZoLmxlbmd0aD4xKXtlPWBcXG4ke2d9JHtlfVxcbiR7cn1gfWwucG9wKCk7cmV0dXJuYHske2V9fWB9Y2FzZVwibnVtYmVyXCI6cmV0dXJuIGlzRmluaXRlKHApP1N0cmluZyhwKTp0P3QocCk6XCJudWxsXCI7Y2FzZVwiYm9vbGVhblwiOnJldHVybiBwPT09dHJ1ZT9cInRydWVcIjpcImZhbHNlXCI7Y2FzZVwidW5kZWZpbmVkXCI6cmV0dXJuIHVuZGVmaW5lZDtjYXNlXCJiaWdpbnRcIjppZihyKXtyZXR1cm4gU3RyaW5nKHApfWRlZmF1bHQ6cmV0dXJuIHQ/dChwKTp1bmRlZmluZWR9fWZ1bmN0aW9uIHN0cmluZ2lmeUFycmF5UmVwbGFjZXIoZSxpLGYscyxsLGMpe2lmKHR5cGVvZiBpPT09XCJvYmplY3RcIiYmaSE9PW51bGwmJnR5cGVvZiBpLnRvSlNPTj09PVwiZnVuY3Rpb25cIil7aT1pLnRvSlNPTihlKX1zd2l0Y2godHlwZW9mIGkpe2Nhc2VcInN0cmluZ1wiOnJldHVybiBzdHJFc2NhcGUoaSk7Y2FzZVwib2JqZWN0XCI6e2lmKGk9PT1udWxsKXtyZXR1cm5cIm51bGxcIn1pZihmLmluZGV4T2YoaSkhPT0tMSl7cmV0dXJuIG59Y29uc3QgZT1jO2xldCB0PVwiXCI7bGV0IHI9XCIsXCI7aWYoQXJyYXkuaXNBcnJheShpKSl7aWYoaS5sZW5ndGg9PT0wKXtyZXR1cm5cIltdXCJ9aWYodTxmLmxlbmd0aCsxKXtyZXR1cm4nXCJbQXJyYXldXCInfWYucHVzaChpKTtpZihsIT09XCJcIil7Yys9bDt0Kz1gXFxuJHtjfWA7cj1gLFxcbiR7Y31gfWNvbnN0IG49TWF0aC5taW4oaS5sZW5ndGgsbyk7bGV0IGE9MDtmb3IoO2E8bi0xO2ErKyl7Y29uc3QgZT1zdHJpbmdpZnlBcnJheVJlcGxhY2VyKFN0cmluZyhhKSxpW2FdLGYscyxsLGMpO3QrPWUhPT11bmRlZmluZWQ/ZTpcIm51bGxcIjt0Kz1yfWNvbnN0IGc9c3RyaW5naWZ5QXJyYXlSZXBsYWNlcihTdHJpbmcoYSksaVthXSxmLHMsbCxjKTt0Kz1nIT09dW5kZWZpbmVkP2c6XCJudWxsXCI7aWYoaS5sZW5ndGgtMT5vKXtjb25zdCBlPWkubGVuZ3RoLW8tMTt0Kz1gJHtyfVwiLi4uICR7Z2V0SXRlbUNvdW50KGUpfSBub3Qgc3RyaW5naWZpZWRcImB9aWYobCE9PVwiXCIpe3QrPWBcXG4ke2V9YH1mLnBvcCgpO3JldHVybmBbJHt0fV1gfWYucHVzaChpKTtsZXQgYT1cIlwiO2lmKGwhPT1cIlwiKXtjKz1sO3I9YCxcXG4ke2N9YDthPVwiIFwifWxldCBnPVwiXCI7Zm9yKGNvbnN0IGUgb2Ygcyl7Y29uc3Qgbj1zdHJpbmdpZnlBcnJheVJlcGxhY2VyKGUsaVtlXSxmLHMsbCxjKTtpZihuIT09dW5kZWZpbmVkKXt0Kz1gJHtnfSR7c3RyRXNjYXBlKGUpfToke2F9JHtufWA7Zz1yfX1pZihsIT09XCJcIiYmZy5sZW5ndGg+MSl7dD1gXFxuJHtjfSR7dH1cXG4ke2V9YH1mLnBvcCgpO3JldHVybmB7JHt0fX1gfWNhc2VcIm51bWJlclwiOnJldHVybiBpc0Zpbml0ZShpKT9TdHJpbmcoaSk6dD90KGkpOlwibnVsbFwiO2Nhc2VcImJvb2xlYW5cIjpyZXR1cm4gaT09PXRydWU/XCJ0cnVlXCI6XCJmYWxzZVwiO2Nhc2VcInVuZGVmaW5lZFwiOnJldHVybiB1bmRlZmluZWQ7Y2FzZVwiYmlnaW50XCI6aWYocil7cmV0dXJuIFN0cmluZyhpKX1kZWZhdWx0OnJldHVybiB0P3QoaSk6dW5kZWZpbmVkfX1mdW5jdGlvbiBzdHJpbmdpZnlJbmRlbnQoZSxzLGwsYyxhKXtzd2l0Y2godHlwZW9mIHMpe2Nhc2VcInN0cmluZ1wiOnJldHVybiBzdHJFc2NhcGUocyk7Y2FzZVwib2JqZWN0XCI6e2lmKHM9PT1udWxsKXtyZXR1cm5cIm51bGxcIn1pZih0eXBlb2Ygcy50b0pTT049PT1cImZ1bmN0aW9uXCIpe3M9cy50b0pTT04oZSk7aWYodHlwZW9mIHMhPT1cIm9iamVjdFwiKXtyZXR1cm4gc3RyaW5naWZ5SW5kZW50KGUscyxsLGMsYSl9aWYocz09PW51bGwpe3JldHVyblwibnVsbFwifX1pZihsLmluZGV4T2YocykhPT0tMSl7cmV0dXJuIG59Y29uc3QgdD1hO2lmKEFycmF5LmlzQXJyYXkocykpe2lmKHMubGVuZ3RoPT09MCl7cmV0dXJuXCJbXVwifWlmKHU8bC5sZW5ndGgrMSl7cmV0dXJuJ1wiW0FycmF5XVwiJ31sLnB1c2gocyk7YSs9YztsZXQgZT1gXFxuJHthfWA7Y29uc3Qgbj1gLFxcbiR7YX1gO2NvbnN0IHI9TWF0aC5taW4ocy5sZW5ndGgsbyk7bGV0IGk9MDtmb3IoO2k8ci0xO2krKyl7Y29uc3QgdD1zdHJpbmdpZnlJbmRlbnQoU3RyaW5nKGkpLHNbaV0sbCxjLGEpO2UrPXQhPT11bmRlZmluZWQ/dDpcIm51bGxcIjtlKz1ufWNvbnN0IGY9c3RyaW5naWZ5SW5kZW50KFN0cmluZyhpKSxzW2ldLGwsYyxhKTtlKz1mIT09dW5kZWZpbmVkP2Y6XCJudWxsXCI7aWYocy5sZW5ndGgtMT5vKXtjb25zdCB0PXMubGVuZ3RoLW8tMTtlKz1gJHtufVwiLi4uICR7Z2V0SXRlbUNvdW50KHQpfSBub3Qgc3RyaW5naWZpZWRcImB9ZSs9YFxcbiR7dH1gO2wucG9wKCk7cmV0dXJuYFske2V9XWB9bGV0IHI9T2JqZWN0LmtleXMocyk7Y29uc3QgZz1yLmxlbmd0aDtpZihnPT09MCl7cmV0dXJuXCJ7fVwifWlmKHU8bC5sZW5ndGgrMSl7cmV0dXJuJ1wiW09iamVjdF1cIid9YSs9Yztjb25zdCBwPWAsXFxuJHthfWA7bGV0IHk9XCJcIjtsZXQgZD1cIlwiO2xldCBoPU1hdGgubWluKGcsbyk7aWYoaXNUeXBlZEFycmF5V2l0aEVudHJpZXMocykpe3krPXN0cmluZ2lmeVR5cGVkQXJyYXkocyxwLG8pO3I9ci5zbGljZShzLmxlbmd0aCk7aC09cy5sZW5ndGg7ZD1wfWlmKGkpe3I9c29ydChyLGYpfWwucHVzaChzKTtmb3IobGV0IGU9MDtlPGg7ZSsrKXtjb25zdCB0PXJbZV07Y29uc3Qgbj1zdHJpbmdpZnlJbmRlbnQodCxzW3RdLGwsYyxhKTtpZihuIT09dW5kZWZpbmVkKXt5Kz1gJHtkfSR7c3RyRXNjYXBlKHQpfTogJHtufWA7ZD1wfX1pZihnPm8pe2NvbnN0IGU9Zy1vO3krPWAke2R9XCIuLi5cIjogXCIke2dldEl0ZW1Db3VudChlKX0gbm90IHN0cmluZ2lmaWVkXCJgO2Q9cH1pZihkIT09XCJcIil7eT1gXFxuJHthfSR7eX1cXG4ke3R9YH1sLnBvcCgpO3JldHVybmB7JHt5fX1gfWNhc2VcIm51bWJlclwiOnJldHVybiBpc0Zpbml0ZShzKT9TdHJpbmcocyk6dD90KHMpOlwibnVsbFwiO2Nhc2VcImJvb2xlYW5cIjpyZXR1cm4gcz09PXRydWU/XCJ0cnVlXCI6XCJmYWxzZVwiO2Nhc2VcInVuZGVmaW5lZFwiOnJldHVybiB1bmRlZmluZWQ7Y2FzZVwiYmlnaW50XCI6aWYocil7cmV0dXJuIFN0cmluZyhzKX1kZWZhdWx0OnJldHVybiB0P3Qocyk6dW5kZWZpbmVkfX1mdW5jdGlvbiBzdHJpbmdpZnlTaW1wbGUoZSxzLGwpe3N3aXRjaCh0eXBlb2Ygcyl7Y2FzZVwic3RyaW5nXCI6cmV0dXJuIHN0ckVzY2FwZShzKTtjYXNlXCJvYmplY3RcIjp7aWYocz09PW51bGwpe3JldHVyblwibnVsbFwifWlmKHR5cGVvZiBzLnRvSlNPTj09PVwiZnVuY3Rpb25cIil7cz1zLnRvSlNPTihlKTtpZih0eXBlb2YgcyE9PVwib2JqZWN0XCIpe3JldHVybiBzdHJpbmdpZnlTaW1wbGUoZSxzLGwpfWlmKHM9PT1udWxsKXtyZXR1cm5cIm51bGxcIn19aWYobC5pbmRleE9mKHMpIT09LTEpe3JldHVybiBufWxldCB0PVwiXCI7Y29uc3Qgcj1zLmxlbmd0aCE9PXVuZGVmaW5lZDtpZihyJiZBcnJheS5pc0FycmF5KHMpKXtpZihzLmxlbmd0aD09PTApe3JldHVyblwiW11cIn1pZih1PGwubGVuZ3RoKzEpe3JldHVybidcIltBcnJheV1cIid9bC5wdXNoKHMpO2NvbnN0IGU9TWF0aC5taW4ocy5sZW5ndGgsbyk7bGV0IG49MDtmb3IoO248ZS0xO24rKyl7Y29uc3QgZT1zdHJpbmdpZnlTaW1wbGUoU3RyaW5nKG4pLHNbbl0sbCk7dCs9ZSE9PXVuZGVmaW5lZD9lOlwibnVsbFwiO3QrPVwiLFwifWNvbnN0IHI9c3RyaW5naWZ5U2ltcGxlKFN0cmluZyhuKSxzW25dLGwpO3QrPXIhPT11bmRlZmluZWQ/cjpcIm51bGxcIjtpZihzLmxlbmd0aC0xPm8pe2NvbnN0IGU9cy5sZW5ndGgtby0xO3QrPWAsXCIuLi4gJHtnZXRJdGVtQ291bnQoZSl9IG5vdCBzdHJpbmdpZmllZFwiYH1sLnBvcCgpO3JldHVybmBbJHt0fV1gfWxldCBjPU9iamVjdC5rZXlzKHMpO2NvbnN0IGE9Yy5sZW5ndGg7aWYoYT09PTApe3JldHVyblwie31cIn1pZih1PGwubGVuZ3RoKzEpe3JldHVybidcIltPYmplY3RdXCInfWxldCBnPVwiXCI7bGV0IHA9TWF0aC5taW4oYSxvKTtpZihyJiZpc1R5cGVkQXJyYXlXaXRoRW50cmllcyhzKSl7dCs9c3RyaW5naWZ5VHlwZWRBcnJheShzLFwiLFwiLG8pO2M9Yy5zbGljZShzLmxlbmd0aCk7cC09cy5sZW5ndGg7Zz1cIixcIn1pZihpKXtjPXNvcnQoYyxmKX1sLnB1c2gocyk7Zm9yKGxldCBlPTA7ZTxwO2UrKyl7Y29uc3Qgbj1jW2VdO2NvbnN0IHI9c3RyaW5naWZ5U2ltcGxlKG4sc1tuXSxsKTtpZihyIT09dW5kZWZpbmVkKXt0Kz1gJHtnfSR7c3RyRXNjYXBlKG4pfToke3J9YDtnPVwiLFwifX1pZihhPm8pe2NvbnN0IGU9YS1vO3QrPWAke2d9XCIuLi5cIjpcIiR7Z2V0SXRlbUNvdW50KGUpfSBub3Qgc3RyaW5naWZpZWRcImB9bC5wb3AoKTtyZXR1cm5geyR7dH19YH1jYXNlXCJudW1iZXJcIjpyZXR1cm4gaXNGaW5pdGUocyk/U3RyaW5nKHMpOnQ/dChzKTpcIm51bGxcIjtjYXNlXCJib29sZWFuXCI6cmV0dXJuIHM9PT10cnVlP1widHJ1ZVwiOlwiZmFsc2VcIjtjYXNlXCJ1bmRlZmluZWRcIjpyZXR1cm4gdW5kZWZpbmVkO2Nhc2VcImJpZ2ludFwiOmlmKHIpe3JldHVybiBTdHJpbmcocyl9ZGVmYXVsdDpyZXR1cm4gdD90KHMpOnVuZGVmaW5lZH19ZnVuY3Rpb24gc3RyaW5naWZ5KGUsdCxuKXtpZihhcmd1bWVudHMubGVuZ3RoPjEpe2xldCByPVwiXCI7aWYodHlwZW9mIG49PT1cIm51bWJlclwiKXtyPVwiIFwiLnJlcGVhdChNYXRoLm1pbihuLDEwKSl9ZWxzZSBpZih0eXBlb2Ygbj09PVwic3RyaW5nXCIpe3I9bi5zbGljZSgwLDEwKX1pZih0IT1udWxsKXtpZih0eXBlb2YgdD09PVwiZnVuY3Rpb25cIil7cmV0dXJuIHN0cmluZ2lmeUZuUmVwbGFjZXIoXCJcIix7XCJcIjplfSxbXSx0LHIsXCJcIil9aWYoQXJyYXkuaXNBcnJheSh0KSl7cmV0dXJuIHN0cmluZ2lmeUFycmF5UmVwbGFjZXIoXCJcIixlLFtdLGdldFVuaXF1ZVJlcGxhY2VyU2V0KHQpLHIsXCJcIil9fWlmKHIubGVuZ3RoIT09MCl7cmV0dXJuIHN0cmluZ2lmeUluZGVudChcIlwiLGUsW10scixcIlwiKX19cmV0dXJuIHN0cmluZ2lmeVNpbXBsZShcIlwiLGUsW10pfXJldHVybiBzdHJpbmdpZnl9fX07dmFyIHQ9e307ZnVuY3Rpb24gX19uY2N3cGNrX3JlcXVpcmVfXyhuKXt2YXIgcj10W25dO2lmKHIhPT11bmRlZmluZWQpe3JldHVybiByLmV4cG9ydHN9dmFyIGk9dFtuXT17ZXhwb3J0czp7fX07dmFyIGY9dHJ1ZTt0cnl7ZVtuXShpLGkuZXhwb3J0cyxfX25jY3dwY2tfcmVxdWlyZV9fKTtmPWZhbHNlfWZpbmFsbHl7aWYoZilkZWxldGUgdFtuXX1yZXR1cm4gaS5leHBvcnRzfWlmKHR5cGVvZiBfX25jY3dwY2tfcmVxdWlyZV9fIT09XCJ1bmRlZmluZWRcIilfX25jY3dwY2tfcmVxdWlyZV9fLmFiPV9fZGlybmFtZStcIi9cIjt2YXIgbj1fX25jY3dwY2tfcmVxdWlyZV9fKDg3OSk7bW9kdWxlLmV4cG9ydHM9bn0pKCk7Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLENBQUM7SUFBVztJQUFhLElBQUksSUFBRTtRQUFDLEtBQUksU0FBUyxDQUFDLEVBQUMsQ0FBQztZQUFFLE1BQUssRUFBQyxnQkFBZSxDQUFDLEVBQUMsR0FBQyxPQUFPLFNBQVM7WUFBQyxNQUFNLElBQUU7WUFBWSxFQUFFLFNBQVMsR0FBQztZQUFVLEVBQUUsU0FBUyxHQUFDO1lBQUUsRUFBRSxPQUFPLEdBQUM7WUFBRSxFQUFFLFNBQVMsR0FBQztZQUFFLEVBQUUsU0FBUyxHQUFDO1lBQVUsRUFBRSxPQUFPLEdBQUM7WUFBRSxNQUFNLElBQUU7WUFBMkMsU0FBUyxVQUFVLENBQUM7Z0JBQUUsSUFBRyxFQUFFLE1BQU0sR0FBQyxPQUFLLENBQUMsRUFBRSxJQUFJLENBQUMsSUFBRztvQkFBQyxPQUFNLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO2dCQUFBO2dCQUFDLE9BQU8sS0FBSyxTQUFTLENBQUM7WUFBRTtZQUFDLFNBQVMsS0FBSyxDQUFDLEVBQUMsQ0FBQztnQkFBRSxJQUFHLEVBQUUsTUFBTSxHQUFDLE9BQUssR0FBRTtvQkFBQyxPQUFPLEVBQUUsSUFBSSxDQUFDO2dCQUFFO2dCQUFDLElBQUksSUFBSSxJQUFFLEdBQUUsSUFBRSxFQUFFLE1BQU0sRUFBQyxJQUFJO29CQUFDLE1BQU0sSUFBRSxDQUFDLENBQUMsRUFBRTtvQkFBQyxJQUFJLElBQUU7b0JBQUUsTUFBTSxNQUFJLEtBQUcsQ0FBQyxDQUFDLElBQUUsRUFBRSxHQUFDLEVBQUU7d0JBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBQyxDQUFDLENBQUMsSUFBRSxFQUFFO3dCQUFDO29CQUFHO29CQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUM7Z0JBQUM7Z0JBQUMsT0FBTztZQUFDO1lBQUMsTUFBTSxJQUFFLE9BQU8sd0JBQXdCLENBQUMsT0FBTyxjQUFjLENBQUMs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QUFDLElBQUcsTUFBSSxXQUFVO1lBQUMsT0FBTyxFQUFFLE9BQU87UUFBQTtRQUFDLElBQUksSUFBRSxDQUFDLENBQUMsRUFBRSxHQUFDO1lBQUMsU0FBUSxDQUFDO1FBQUM7UUFBRSxJQUFJLElBQUU7UUFBSyxJQUFHO1lBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFFLEVBQUUsT0FBTyxFQUFDO1lBQXFCLElBQUU7UUFBSyxTQUFRO1lBQUMsSUFBRyxHQUFFLE9BQU8sQ0FBQyxDQUFDLEVBQUU7UUFBQTtRQUFDLE9BQU8sRUFBRSxPQUFPO0lBQUE7SUFBQyxJQUFHLE9BQU8sd0JBQXNCLGFBQVksb0JBQW9CLEVBQUUsR0FBQyxrR0FBVTtJQUFJLElBQUksSUFBRSxvQkFBb0I7SUFBSyxPQUFPLE9BQU8sR0FBQztBQUFDLENBQUMiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNzM3OCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9zaGFyZWQvbGliL2Vycm9yLXNvdXJjZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBzeW1ib2xFcnJvciA9IFN5bWJvbC5mb3IoJ05leHRqc0Vycm9yJylcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEVycm9yU291cmNlKGVycm9yOiBFcnJvcik6ICdzZXJ2ZXInIHwgJ2VkZ2Utc2VydmVyJyB8IG51bGwge1xuICByZXR1cm4gKGVycm9yIGFzIGFueSlbc3ltYm9sRXJyb3JdIHx8IG51bGxcbn1cblxuZXhwb3J0IHR5cGUgRXJyb3JTb3VyY2VUeXBlID0gJ2VkZ2Utc2VydmVyJyB8ICdzZXJ2ZXInXG5cbmV4cG9ydCBmdW5jdGlvbiBkZWNvcmF0ZVNlcnZlckVycm9yKGVycm9yOiBFcnJvciwgdHlwZTogRXJyb3JTb3VyY2VUeXBlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlcnJvciwgc3ltYm9sRXJyb3IsIHtcbiAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZTogdHlwZSxcbiAgfSlcbn1cbiJdLCJuYW1lcyI6WyJkZWNvcmF0ZVNlcnZlckVycm9yIiwiZ2V0RXJyb3JTb3VyY2UiLCJzeW1ib2xFcnJvciIsIlN5bWJvbCIsImZvciIsImVycm9yIiwidHlwZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5Iiwid3JpdGFibGUiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwidmFsdWUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0lBUWdCQSxtQkFBbUIsRUFBQTtlQUFuQkE7O0lBTkFDLGNBQWMsRUFBQTtlQUFkQTs7O0FBRmhCLE1BQU1DLGNBQWNDLE9BQU9DLEdBQUcsQ0FBQztBQUV4QixTQUFTSCxlQUFlSSxLQUFZO0lBQ3pDLE9BQVFBLEtBQWEsQ0FBQ0gsWUFBWSxJQUFJO0FBQ3hDO0FBSU8sU0FBU0Ysb0JBQW9CSyxLQUFZLEVBQUVDLElBQXFCO0lBQ3JFQyxPQUFPQyxjQUFjLENBQUNILE9BQU9ILGFBQWE7UUFDeENPLFVBQVU7UUFDVkMsWUFBWTtRQUNaQyxjQUFjO1FBQ2RDLE9BQU9OO0lBQ1Q7QUFDRiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA3NDE3LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL25leHQtZGV2dG9vbHMvdXNlcnNwYWNlL2FwcC90ZXJtaW5hbC1sb2dnaW5nLWNvbmZpZy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gZ2V0VGVybWluYWxMb2dnaW5nQ29uZmlnKCk6XG4gIHwgZmFsc2VcbiAgfCBib29sZWFuXG4gIHwge1xuICAgICAgZGVwdGhMaW1pdD86IG51bWJlclxuICAgICAgZWRnZUxpbWl0PzogbnVtYmVyXG4gICAgICBzaG93U291cmNlTG9jYXRpb24/OiBib29sZWFuXG4gICAgfSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoXG4gICAgICBwcm9jZXNzLmVudi5fX05FWFRfQlJPV1NFUl9ERUJVR19JTkZPX0lOX1RFUk1JTkFMIHx8ICdmYWxzZSdcbiAgICApXG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRJc1Rlcm1pbmFsTG9nZ2luZ0VuYWJsZWQoKTogYm9vbGVhbiB7XG4gIGNvbnN0IGNvbmZpZyA9IGdldFRlcm1pbmFsTG9nZ2luZ0NvbmZpZygpXG4gIHJldHVybiBCb29sZWFuKGNvbmZpZylcbn1cbiJdLCJuYW1lcyI6WyJnZXRJc1Rlcm1pbmFsTG9nZ2luZ0VuYWJsZWQiLCJnZXRUZXJtaW5hbExvZ2dpbmdDb25maWciLCJKU09OIiwicGFyc2UiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX0JST1dTRVJfREVCVUdfSU5GT19JTl9URVJNSU5BTCIsImNvbmZpZyIsIkJvb2xlYW4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0lBaUJnQkEsMkJBQTJCLEVBQUE7ZUFBM0JBOztJQWpCQUMsd0JBQXdCLEVBQUE7ZUFBeEJBOzs7QUFBVCxTQUFTQTtJQVFkLElBQUk7UUFDRixPQUFPQyxLQUFLQyxLQUFLLENBQ2ZDLFFBQVFDLEdBQUcsQ0FBQ0MsaUNBQXlDLElBQUo7SUFFckQsRUFBRSxPQUFBLEdBQU07UUFDTixPQUFPO0lBQ1Q7QUFDRjtBQUVPLFNBQVNOO0lBQ2QsTUFBTU8sU0FBU047SUFDZixPQUFPTyxRQUFRRDtBQUNqQiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA3NDYyLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL25leHQtZGV2dG9vbHMvc2hhcmVkL2ZvcndhcmQtbG9ncy1zaGFyZWQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHR5cGUgTG9nTWV0aG9kID1cbiAgfCAnbG9nJ1xuICB8ICdpbmZvJ1xuICB8ICdkZWJ1ZydcbiAgfCAndGFibGUnXG4gIHwgJ2Vycm9yJ1xuICB8ICdhc3NlcnQnXG4gIHwgJ2RpcidcbiAgfCAnZGlyeG1sJ1xuICB8ICdncm91cCdcbiAgfCAnZ3JvdXBDb2xsYXBzZWQnXG4gIHwgJ2dyb3VwRW5kJ1xuICB8ICd0cmFjZSdcbiAgfCAnd2FybidcblxuZXhwb3J0IHR5cGUgQ29uc29sZUVudHJ5PFQ+ID0ge1xuICBraW5kOiAnY29uc29sZSdcbiAgbWV0aG9kOiBMb2dNZXRob2RcbiAgY29uc29sZU1ldGhvZFN0YWNrOiBzdHJpbmcgfCBudWxsXG4gIGFyZ3M6IEFycmF5PFxuICAgIHwge1xuICAgICAgICBraW5kOiAnYXJnJ1xuICAgICAgICBkYXRhOiBUXG4gICAgICB9XG4gICAgfCB7XG4gICAgICAgIGtpbmQ6ICdmb3JtYXR0ZWQtZXJyb3ItYXJnJ1xuICAgICAgICBwcmVmaXg6IHN0cmluZ1xuICAgICAgICBzdGFjazogc3RyaW5nXG4gICAgICB9XG4gID5cbn1cblxuZXhwb3J0IHR5cGUgQ29uc29sZUVycm9yRW50cnk8VD4gPSB7XG4gIGtpbmQ6ICdhbnktbG9nZ2VkLWVycm9yJ1xuICBtZXRob2Q6ICdlcnJvcidcbiAgY29uc29sZUVycm9yU3RhY2s6IHN0cmluZ1xuICBhcmdzOiBBcnJheTxcbiAgICB8IHtcbiAgICAgICAga2luZDogJ2FyZydcbiAgICAgICAgZGF0YTogVFxuICAgICAgICBpc1JlamVjdGlvbk1lc3NhZ2U/OiBib29sZWFuXG4gICAgICB9XG4gICAgfCB7XG4gICAgICAgIGtpbmQ6ICdmb3JtYXR0ZWQtZXJyb3ItYXJnJ1xuICAgICAgICBwcmVmaXg6IHN0cmluZ1xuICAgICAgICBzdGFjazogc3RyaW5nIHwgbnVsbFxuICAgICAgfVxuICA+XG59XG5cbmV4cG9ydCB0eXBlIEZvcm1hdHRlZEVycm9yRW50cnkgPSB7XG4gIGtpbmQ6ICdmb3JtYXR0ZWQtZXJyb3InXG4gIHByZWZpeDogc3RyaW5nXG4gIHN0YWNrOiBzdHJpbmdcbiAgbWV0aG9kOiAnZXJyb3InXG59XG5cbmV4cG9ydCB0eXBlIENsaWVudExvZ0VudHJ5ID1cbiAgfCBDb25zb2xlRW50cnk8dW5rbm93bj5cbiAgfCBDb25zb2xlRXJyb3JFbnRyeTx1bmtub3duPlxuICB8IEZvcm1hdHRlZEVycm9yRW50cnlcbmV4cG9ydCB0eXBlIFNlcnZlckxvZ0VudHJ5ID1cbiAgfCBDb25zb2xlRW50cnk8c3RyaW5nPlxuICB8IENvbnNvbGVFcnJvckVudHJ5PHN0cmluZz5cbiAgfCBGb3JtYXR0ZWRFcnJvckVudHJ5XG5cbmV4cG9ydCBjb25zdCBVTkRFRklORURfTUFSS0VSID0gJ19fbmV4dF90YWdnZWRfdW5kZWZpbmVkJ1xuXG4vLyBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi8yOGRjMDc3NmJlMmUxMzcwZmUyMTc1NDlkMzJhZWUyNTE5ZjBjZjA1L3BhY2thZ2VzL3JlYWN0LXNlcnZlci9zcmMvUmVhY3RGbGlnaHRTZXJ2ZXIuanMjTDI0OFxuZXhwb3J0IGZ1bmN0aW9uIHBhdGNoQ29uc29sZU1ldGhvZDxUIGV4dGVuZHMga2V5b2YgQ29uc29sZT4oXG4gIG1ldGhvZE5hbWU6IFQsXG4gIHdyYXBwZXI6IChcbiAgICBtZXRob2ROYW1lOiBULFxuICAgIC4uLmFyZ3M6IENvbnNvbGVbVF0gZXh0ZW5kcyAoLi4uYXJnczogaW5mZXIgUCkgPT4gYW55ID8gUCA6IG5ldmVyW11cbiAgKSA9PiB2b2lkXG4pOiAoKSA9PiB2b2lkIHtcbiAgY29uc3QgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uc29sZSwgbWV0aG9kTmFtZSlcbiAgaWYgKFxuICAgIGRlc2NyaXB0b3IgJiZcbiAgICAoZGVzY3JpcHRvci5jb25maWd1cmFibGUgfHwgZGVzY3JpcHRvci53cml0YWJsZSkgJiZcbiAgICB0eXBlb2YgZGVzY3JpcHRvci52YWx1ZSA9PT0gJ2Z1bmN0aW9uJ1xuICApIHtcbiAgICBjb25zdCBvcmlnaW5hbE1ldGhvZCA9IGRlc2NyaXB0b3IudmFsdWUgYXMgQ29uc29sZVtUXSBleHRlbmRzIChcbiAgICAgIC4uLmFyZ3M6IGFueVtdXG4gICAgKSA9PiBhbnlcbiAgICAgID8gQ29uc29sZVtUXVxuICAgICAgOiBuZXZlclxuICAgIGNvbnN0IG9yaWdpbmFsTmFtZSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob3JpZ2luYWxNZXRob2QsICduYW1lJylcbiAgICBjb25zdCB3cmFwcGVyTWV0aG9kID0gZnVuY3Rpb24gKFxuICAgICAgdGhpczogdHlwZW9mIGNvbnNvbGUsXG4gICAgICAuLi5hcmdzOiBDb25zb2xlW1RdIGV4dGVuZHMgKC4uLmFyZ3M6IGluZmVyIFApID0+IGFueSA/IFAgOiBuZXZlcltdXG4gICAgKSB7XG4gICAgICB3cmFwcGVyKG1ldGhvZE5hbWUsIC4uLmFyZ3MpXG5cbiAgICAgIG9yaWdpbmFsTWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgfVxuICAgIGlmIChvcmlnaW5hbE5hbWUpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3cmFwcGVyTWV0aG9kLCAnbmFtZScsIG9yaWdpbmFsTmFtZSlcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbnNvbGUsIG1ldGhvZE5hbWUsIHtcbiAgICAgIHZhbHVlOiB3cmFwcGVyTWV0aG9kLFxuICAgIH0pXG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbnNvbGUsIG1ldGhvZE5hbWUsIHtcbiAgICAgICAgdmFsdWU6IG9yaWdpbmFsTWV0aG9kLFxuICAgICAgICB3cml0YWJsZTogZGVzY3JpcHRvci53cml0YWJsZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSxcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICgpID0+IHt9XG59XG4iXSwibmFtZXMiOlsiVU5ERUZJTkVEX01BUktFUiIsInBhdGNoQ29uc29sZU1ldGhvZCIsIm1ldGhvZE5hbWUiLCJ3cmFwcGVyIiwiZGVzY3JpcHRvciIsIk9iamVjdCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImNvbnNvbGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsInZhbHVlIiwib3JpZ2luYWxNZXRob2QiLCJvcmlnaW5hbE5hbWUiLCJ3cmFwcGVyTWV0aG9kIiwiYXJncyIsImFwcGx5IiwiZGVmaW5lUHJvcGVydHkiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0lBa0VhQSxnQkFBZ0IsRUFBQTtlQUFoQkE7O0lBR0dDLGtCQUFrQixFQUFBO2VBQWxCQTs7O0FBSFQsTUFBTUQsbUJBQW1CO0FBR3pCLFNBQVNDLG1CQUNkQyxVQUFhLEVBQ2JDLE9BR1M7SUFFVCxNQUFNQyxhQUFhQyxPQUFPQyx3QkFBd0IsQ0FBQ0MsU0FBU0w7SUFDNUQsSUFDRUUsY0FDQ0EsQ0FBQUEsV0FBV0ksWUFBWSxJQUFJSixXQUFXSyxRQUFPLEtBQzlDLE9BQU9MLFdBQVdNLEtBQUssS0FBSyxZQUM1QjtRQUNBLE1BQU1DLGlCQUFpQlAsV0FBV00sS0FBSztRQUt2QyxNQUFNRSxlQUFlUCxPQUFPQyx3QkFBd0IsQ0FBQ0ssZ0JBQWdCO1FBQ3JFLE1BQU1FLGdCQUFnQjtZQUVwQixJQUFBLElBQUEsT0FBQSxVQUFBLE1BQUEsRUFBR0MsT0FBSCxJQUFBLE1BQUEsT0FBQSxPQUFBLEdBQUEsT0FBQSxNQUFBLE9BQUE7Z0JBQUdBLElBQUFBLENBQUgsS0FBQSxHQUFBLFNBQUEsQ0FBQSxLQUFtRTs7WUFFbkVYLFFBQVFELGVBQWVZO1lBRXZCSCxlQUFlSSxLQUFLLENBQUMsSUFBSSxFQUFFRDtRQUM3QjtRQUNBLElBQUlGLGNBQWM7WUFDaEJQLE9BQU9XLGNBQWMsQ0FBQ0gsZUFBZSxRQUFRRDtRQUMvQztRQUNBUCxPQUFPVyxjQUFjLENBQUNULFNBQVNMLFlBQVk7WUFDekNRLE9BQU9HO1FBQ1Q7UUFFQSxPQUFPO1lBQ0xSLE9BQU9XLGNBQWMsQ0FBQ1QsU0FBU0wsWUFBWTtnQkFDekNRLE9BQU9DO2dCQUNQRixVQUFVTCxXQUFXSyxRQUFRO2dCQUM3QkQsY0FBY0osV0FBV0ksWUFBWTtZQUN2QztRQUNGO0lBQ0Y7SUFFQSxPQUFPLEtBQU87QUFDaEIiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNzUyNSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9uZXh0LWRldnRvb2xzL3VzZXJzcGFjZS9hcHAvZm9yd2FyZC1sb2dzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNvbmZpZ3VyZSB9IGZyb20gJ25leHQvZGlzdC9jb21waWxlZC9zYWZlLXN0YWJsZS1zdHJpbmdpZnknXG5pbXBvcnQge1xuICBnZXRPd25lclN0YWNrLFxuICBzZXRPd25lclN0YWNrSWZBdmFpbGFibGUsXG59IGZyb20gJy4vZXJyb3JzL3N0aXRjaGVkLWVycm9yJ1xuaW1wb3J0IHsgZ2V0RXJyb3JTb3VyY2UgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvbGliL2Vycm9yLXNvdXJjZSdcbmltcG9ydCB7XG4gIGdldFRlcm1pbmFsTG9nZ2luZ0NvbmZpZyxcbiAgZ2V0SXNUZXJtaW5hbExvZ2dpbmdFbmFibGVkLFxufSBmcm9tICcuL3Rlcm1pbmFsLWxvZ2dpbmctY29uZmlnJ1xuaW1wb3J0IHtcbiAgdHlwZSBDb25zb2xlRW50cnksXG4gIHR5cGUgQ29uc29sZUVycm9yRW50cnksXG4gIHR5cGUgRm9ybWF0dGVkRXJyb3JFbnRyeSxcbiAgdHlwZSBDbGllbnRMb2dFbnRyeSxcbiAgdHlwZSBMb2dNZXRob2QsXG4gIHBhdGNoQ29uc29sZU1ldGhvZCxcbiAgVU5ERUZJTkVEX01BUktFUixcbn0gZnJvbSAnLi4vLi4vc2hhcmVkL2ZvcndhcmQtbG9ncy1zaGFyZWQnXG5cbmNvbnN0IHRlcm1pbmFsTG9nZ2luZ0NvbmZpZyA9IGdldFRlcm1pbmFsTG9nZ2luZ0NvbmZpZygpXG5leHBvcnQgY29uc3QgUFJPTUlTRV9NQVJLRVIgPSAnUHJvbWlzZSB7fSdcbmV4cG9ydCBjb25zdCBVTkFWQUlMQUJMRV9NQVJLRVIgPSAnW1VuYWJsZSB0byB2aWV3XSdcblxuY29uc3QgbWF4aW11bURlcHRoID1cbiAgdHlwZW9mIHRlcm1pbmFsTG9nZ2luZ0NvbmZpZyA9PT0gJ29iamVjdCcgJiYgdGVybWluYWxMb2dnaW5nQ29uZmlnLmRlcHRoTGltaXRcbiAgICA/IHRlcm1pbmFsTG9nZ2luZ0NvbmZpZy5kZXB0aExpbWl0XG4gICAgOiA1XG5jb25zdCBtYXhpbXVtQnJlYWR0aCA9XG4gIHR5cGVvZiB0ZXJtaW5hbExvZ2dpbmdDb25maWcgPT09ICdvYmplY3QnICYmIHRlcm1pbmFsTG9nZ2luZ0NvbmZpZy5lZGdlTGltaXRcbiAgICA/IHRlcm1pbmFsTG9nZ2luZ0NvbmZpZy5lZGdlTGltaXRcbiAgICA6IDEwMFxuXG5jb25zdCBzdHJpbmdpZnkgPSBjb25maWd1cmUoe1xuICBtYXhpbXVtRGVwdGgsXG4gIG1heGltdW1CcmVhZHRoLFxufSlcblxuZXhwb3J0IGNvbnN0IGlzVGVybWluYWxMb2dnaW5nRW5hYmxlZCA9IGdldElzVGVybWluYWxMb2dnaW5nRW5hYmxlZCgpXG5cbmNvbnN0IG1ldGhvZHM6IEFycmF5PExvZ01ldGhvZD4gPSBbXG4gICdsb2cnLFxuICAnaW5mbycsXG4gICd3YXJuJyxcbiAgJ2RlYnVnJyxcbiAgJ3RhYmxlJyxcbiAgJ2Fzc2VydCcsXG4gICdkaXInLFxuICAnZGlyeG1sJyxcbiAgJ2dyb3VwJyxcbiAgJ2dyb3VwQ29sbGFwc2VkJyxcbiAgJ2dyb3VwRW5kJyxcbiAgJ3RyYWNlJyxcbl1cbi8qKlxuICogYWxsb3dzIHVzIHRvOlxuICogLSByZXZpdmUgdGhlIHVuZGVmaW5lZCBsb2cgaW4gdGhlIHNlcnZlciBhcyBpdCB3b3VsZCBsb29rIGluIHRoZSBicm93c2VyXG4gKiAtIG5vdCByZWFkL2F0dGVtcHQgdG8gc2VyaWFsaXplIHByb21pc2VzIChuZXh0IHdpbGwgY29uc29sZSBlcnJvciBpZiB5b3UgZG8gdGhhdCwgYW5kIHdpbGwgY2F1c2UgdGhpcyBwcm9ncmFtIHRvIGluZmluaXRlbHkgcmVjdXJzZSlcbiAqIC0gaWYgd2UgcmVhZCBhIHByb3h5IHRoYXQgdGhyb3dzIChubyB3YXkgdG8gZGV0ZWN0IGlmIHNvbWV0aGluZyBpcyBhIHByb3h5KSwgZXhwbGFpbiB0byB0aGUgdXNlciB3ZSBjYW4ndCByZWFkIHRoaXMgZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJlTG9nU2VyaWFsaXphdGlvbkNsb25lPFQ+KFxuICB2YWx1ZTogVCxcbiAgc2VlbiA9IG5ldyBXZWFrTWFwKClcbik6IGFueSB7XG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gVU5ERUZJTkVEX01BUktFUlxuICBpZiAodmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JykgcmV0dXJuIHZhbHVlXG4gIGlmIChzZWVuLmhhcyh2YWx1ZSBhcyBvYmplY3QpKSByZXR1cm4gc2Vlbi5nZXQodmFsdWUgYXMgb2JqZWN0KVxuXG4gIHRyeSB7XG4gICAgT2JqZWN0LmtleXModmFsdWUgYXMgb2JqZWN0KVxuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gVU5BVkFJTEFCTEVfTUFSS0VSXG4gIH1cblxuICB0cnkge1xuICAgIGlmICh0eXBlb2YgKHZhbHVlIGFzIGFueSkudGhlbiA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIFBST01JU0VfTUFSS0VSXG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBVTkFWQUlMQUJMRV9NQVJLRVJcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIGNvbnN0IG91dDogYW55W10gPSBbXVxuICAgIHNlZW4uc2V0KHZhbHVlLCBvdXQpXG4gICAgZm9yIChjb25zdCBpdGVtIG9mIHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBvdXQucHVzaChwcmVMb2dTZXJpYWxpemF0aW9uQ2xvbmUoaXRlbSwgc2VlbikpXG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgb3V0LnB1c2goVU5BVkFJTEFCTEVfTUFSS0VSKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0XG4gIH1cblxuICBjb25zdCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSlcbiAgaWYgKHByb3RvID09PSBPYmplY3QucHJvdG90eXBlIHx8IHByb3RvID09PSBudWxsKSB7XG4gICAgY29uc3Qgb3V0OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiA9IHt9XG4gICAgc2Vlbi5zZXQodmFsdWUgYXMgb2JqZWN0LCBvdXQpXG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModmFsdWUgYXMgb2JqZWN0KSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgb3V0W2tleV0gPSBwcmVMb2dTZXJpYWxpemF0aW9uQ2xvbmUoKHZhbHVlIGFzIGFueSlba2V5XSwgc2VlbilcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICBvdXRba2V5XSA9IFVOQVZBSUxBQkxFX01BUktFUlxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKVxufVxuXG4vLyBvbmx5IHNhZmUgaWYgcGFzc2VkIHNhZmVDbG9uZSBkYXRhXG5leHBvcnQgY29uc3QgbG9nU3RyaW5naWZ5ID0gKGRhdGE6IHVua25vd24pOiBzdHJpbmcgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHN0cmluZ2lmeShkYXRhKVxuICAgIHJldHVybiByZXN1bHQgPz8gYFwiJHtVTkFWQUlMQUJMRV9NQVJLRVJ9XCJgXG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBgXCIke1VOQVZBSUxBQkxFX01BUktFUn1cImBcbiAgfVxufVxuXG5jb25zdCBhZnRlclRoaXNGcmFtZSA9IChjYjogKCkgPT4gdm9pZCkgPT4ge1xuICBsZXQgdGltZW91dDogUmV0dXJuVHlwZTx0eXBlb2Ygc2V0VGltZW91dD4gfCB1bmRlZmluZWRcblxuICBjb25zdCByYWZJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgY2IoKVxuICAgIH0pXG4gIH0pXG5cbiAgcmV0dXJuICgpID0+IHtcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZShyYWZJZClcbiAgICBjbGVhclRpbWVvdXQodGltZW91dClcbiAgfVxufVxuXG5sZXQgaXNQYXRjaGVkID0gZmFsc2VcblxuY29uc3Qgc2VyaWFsaXplRW50cmllcyA9IChlbnRyaWVzOiBBcnJheTxDbGllbnRMb2dFbnRyeT4pID0+XG4gIGVudHJpZXMubWFwKChjbGllbnRFbnRyeSkgPT4ge1xuICAgIHN3aXRjaCAoY2xpZW50RW50cnkua2luZCkge1xuICAgICAgY2FzZSAnYW55LWxvZ2dlZC1lcnJvcic6XG4gICAgICBjYXNlICdjb25zb2xlJzoge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLmNsaWVudEVudHJ5LFxuICAgICAgICAgIGFyZ3M6IGNsaWVudEVudHJ5LmFyZ3MubWFwKHN0cmluZ2lmeVVzZXJBcmcpLFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjYXNlICdmb3JtYXR0ZWQtZXJyb3InOiB7XG4gICAgICAgIHJldHVybiBjbGllbnRFbnRyeVxuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICByZXR1cm4gbnVsbCFcbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbmV4cG9ydCBjb25zdCBsb2dRdWV1ZToge1xuICBlbnRyaWVzOiBBcnJheTxDbGllbnRMb2dFbnRyeT5cbiAgb25Tb2NrZXRSZWFkeTogKHNvY2tldDogV2ViU29ja2V0KSA9PiB2b2lkXG4gIGZsdXNoU2NoZWR1bGVkOiBib29sZWFuXG4gIHNvY2tldDogV2ViU29ja2V0IHwgbnVsbFxuICBjYW5jZWxGbHVzaDogKCgpID0+IHZvaWQpIHwgbnVsbFxuICBzb3VyY2VUeXBlPzogJ3NlcnZlcicgfCAnZWRnZS1zZXJ2ZXInXG4gIHJvdXRlcjogJ2FwcCcgfCAncGFnZXMnIHwgbnVsbFxuICBzY2hlZHVsZUxvZ1NlbmQ6IChlbnRyeTogQ2xpZW50TG9nRW50cnkpID0+IHZvaWRcbn0gPSB7XG4gIGVudHJpZXM6IFtdLFxuICBmbHVzaFNjaGVkdWxlZDogZmFsc2UsXG4gIGNhbmNlbEZsdXNoOiBudWxsLFxuICBzb2NrZXQ6IG51bGwsXG4gIHNvdXJjZVR5cGU6IHVuZGVmaW5lZCxcbiAgcm91dGVyOiBudWxsLFxuICBzY2hlZHVsZUxvZ1NlbmQ6IChlbnRyeTogQ2xpZW50TG9nRW50cnkpID0+IHtcbiAgICBsb2dRdWV1ZS5lbnRyaWVzLnB1c2goZW50cnkpXG4gICAgaWYgKGxvZ1F1ZXVlLmZsdXNoU2NoZWR1bGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gc2FmZSB0byBkZXJlZiBhbmQgdXNlIGluIHNldFRpbWVvdXQgY2xvc3VyZSBzaW5jZSB3ZSBjYW5jZWwgb24gbmV3IHNvY2tldFxuICAgIGNvbnN0IHNvY2tldCA9IGxvZ1F1ZXVlLnNvY2tldFxuICAgIGlmICghc29ja2V0KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyB3ZSBwcm9iYWJseSBkb250IG5lZWQgdGhpc1xuICAgIGxvZ1F1ZXVlLmZsdXNoU2NoZWR1bGVkID0gdHJ1ZVxuXG4gICAgLy8gbm9uIGJsb2NraW5nIGxvZyBmbHVzaCwgcnVucyBhdCBtb3N0IG9uY2UgcGVyIGZyYW1lXG4gICAgbG9nUXVldWUuY2FuY2VsRmx1c2ggPSBhZnRlclRoaXNGcmFtZSgoKSA9PiB7XG4gICAgICBsb2dRdWV1ZS5mbHVzaFNjaGVkdWxlZCA9IGZhbHNlXG5cbiAgICAgIC8vIGp1c3QgaW5jYXNlXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBwYXlsb2FkID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGV2ZW50OiAnYnJvd3Nlci1sb2dzJyxcbiAgICAgICAgICBlbnRyaWVzOiBzZXJpYWxpemVFbnRyaWVzKGxvZ1F1ZXVlLmVudHJpZXMpLFxuICAgICAgICAgIHJvdXRlcjogbG9nUXVldWUucm91dGVyLFxuICAgICAgICAgIC8vIG5lZWRlZCBmb3Igc291cmNlIG1hcHBpbmcsIHdlIGp1c3QgYXNzaWduIHRoZSBzb3VyY2VUeXBlIGZyb20gdGhlIGxhc3QgZXJyb3IgZm9yIHRoZSB3aG9sZSBiYXRjaFxuICAgICAgICAgIHNvdXJjZVR5cGU6IGxvZ1F1ZXVlLnNvdXJjZVR5cGUsXG4gICAgICAgIH0pXG5cbiAgICAgICAgc29ja2V0LnNlbmQocGF5bG9hZClcbiAgICAgICAgbG9nUXVldWUuZW50cmllcyA9IFtdXG4gICAgICAgIGxvZ1F1ZXVlLnNvdXJjZVR5cGUgPSB1bmRlZmluZWRcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICAvLyBlcnJvciAobWFrZSBzdXJlIHUgZG9uJ3QgaW5maW5pdGUgbG9vcClcbiAgICAgICAgLyogbm9vcCAqL1xuICAgICAgfVxuICAgIH0pXG4gIH0sXG4gIG9uU29ja2V0UmVhZHk6IChzb2NrZXQ6IFdlYlNvY2tldCkgPT4ge1xuICAgIGlmIChzb2NrZXQucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0Lk9QRU4pIHtcbiAgICAgIC8vIGludmFyaWFudFxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gaW5jYXNlIGFuIGV4aXN0aW5nIHRpbWVvdXQgd2FzIGdvaW5nIHRvIHJ1biB3aXRoIGEgc3RhbGUgc29ja2V0XG4gICAgbG9nUXVldWUuY2FuY2VsRmx1c2g/LigpXG4gICAgbG9nUXVldWUuc29ja2V0ID0gc29ja2V0XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIGV2ZW50OiAnYnJvd3Nlci1sb2dzJyxcbiAgICAgICAgZW50cmllczogc2VyaWFsaXplRW50cmllcyhsb2dRdWV1ZS5lbnRyaWVzKSxcbiAgICAgICAgcm91dGVyOiBsb2dRdWV1ZS5yb3V0ZXIsXG4gICAgICAgIHNvdXJjZVR5cGU6IGxvZ1F1ZXVlLnNvdXJjZVR5cGUsXG4gICAgICB9KVxuXG4gICAgICBzb2NrZXQuc2VuZChwYXlsb2FkKVxuICAgICAgbG9nUXVldWUuZW50cmllcyA9IFtdXG4gICAgICBsb2dRdWV1ZS5zb3VyY2VUeXBlID0gdW5kZWZpbmVkXG4gICAgfSBjYXRjaCB7XG4gICAgICAvKiogbm9vcCBqdXN0IGluY2FzZSAqL1xuICAgIH1cbiAgfSxcbn1cblxuY29uc3Qgc3RyaW5naWZ5VXNlckFyZyA9IChcbiAgYXJnOlxuICAgIHwge1xuICAgICAgICBraW5kOiAnYXJnJ1xuICAgICAgICBkYXRhOiB1bmtub3duXG4gICAgICB9XG4gICAgfCB7XG4gICAgICAgIGtpbmQ6ICdmb3JtYXR0ZWQtZXJyb3ItYXJnJ1xuICAgICAgfVxuKSA9PiB7XG4gIGlmIChhcmcua2luZCAhPT0gJ2FyZycpIHtcbiAgICByZXR1cm4gYXJnXG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5hcmcsXG4gICAgZGF0YTogbG9nU3RyaW5naWZ5KGFyZy5kYXRhKSxcbiAgfVxufVxuXG5jb25zdCBjcmVhdGVFcnJvckFyZyA9IChlcnJvcjogRXJyb3IpID0+IHtcbiAgY29uc3Qgc3RhY2sgPSBzdGFja1dpdGhPd25lcnMoZXJyb3IpXG4gIHJldHVybiB7XG4gICAga2luZDogJ2Zvcm1hdHRlZC1lcnJvci1hcmcnIGFzIGNvbnN0LFxuICAgIHByZWZpeDogZXJyb3IubWVzc2FnZSA/IGAke2Vycm9yLm5hbWV9OiAke2Vycm9yLm1lc3NhZ2V9YCA6IGAke2Vycm9yLm5hbWV9YCxcbiAgICBzdGFjayxcbiAgfVxufVxuXG5jb25zdCBjcmVhdGVMb2dFbnRyeSA9IChsZXZlbDogTG9nTWV0aG9kLCBhcmdzOiBhbnlbXSkgPT4ge1xuICAvLyBkbyBub3QgYWJzdHJhY3QgdGhpcywgaXQgaW1wbGljaXRseSByZWxpZXMgb24gd2hpY2ggZnVuY3Rpb25zIGNhbGwgaXQuIGZvcmNpbmcgdGhlIGlubGluZWQgaW1wbGVtZW50YXRpb24gbWFrZXMgeW91IHRoaW5rIGFib3V0IGNhbGxlcnNcbiAgLy8gZXJyb3IgY2FwdHVyZSBzdGFjayB0cmFjZSBtYXliZVxuICBjb25zdCBzdGFjayA9IHN0YWNrV2l0aE93bmVycyhuZXcgRXJyb3IoKSlcbiAgY29uc3Qgc3RhY2tMaW5lcyA9IHN0YWNrPy5zcGxpdCgnXFxuJylcbiAgY29uc3QgY2xlYW5TdGFjayA9IHN0YWNrTGluZXM/LnNsaWNlKDMpLmpvaW4oJ1xcbicpIC8vIHRoaXMgaXMgcHJvYmFibHkgaWdub3JlZCBhbnl3YXlzXG4gIGNvbnN0IGVudHJ5OiBDb25zb2xlRW50cnk8dW5rbm93bj4gPSB7XG4gICAga2luZDogJ2NvbnNvbGUnLFxuICAgIGNvbnNvbGVNZXRob2RTdGFjazogY2xlYW5TdGFjayA/PyBudWxsLCAvLyBkZXBlbmRpbmcgb24gYnJvd3NlciB3ZSBtaWdodCBub3QgaGF2ZSBzdGFja1xuICAgIG1ldGhvZDogbGV2ZWwsXG4gICAgYXJnczogYXJncy5tYXAoKGFyZykgPT4ge1xuICAgICAgaWYgKGFyZyBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVFcnJvckFyZyhhcmcpXG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBraW5kOiAnYXJnJyxcbiAgICAgICAgZGF0YTogcHJlTG9nU2VyaWFsaXphdGlvbkNsb25lKGFyZyksXG4gICAgICB9XG4gICAgfSksXG4gIH1cblxuICBsb2dRdWV1ZS5zY2hlZHVsZUxvZ1NlbmQoZW50cnkpXG59XG5cbmV4cG9ydCBjb25zdCBmb3J3YXJkRXJyb3JMb2cgPSAoYXJnczogYW55W10pID0+IHtcbiAgY29uc3QgZXJyb3JPYmplY3RzID0gYXJncy5maWx0ZXIoKGFyZykgPT4gYXJnIGluc3RhbmNlb2YgRXJyb3IpXG4gIGNvbnN0IGZpcnN0ID0gZXJyb3JPYmplY3RzLmF0KDApXG4gIGlmIChmaXJzdCkge1xuICAgIGNvbnN0IHNvdXJjZSA9IGdldEVycm9yU291cmNlKGZpcnN0KVxuICAgIGlmIChzb3VyY2UpIHtcbiAgICAgIGxvZ1F1ZXVlLnNvdXJjZVR5cGUgPSBzb3VyY2VcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIGJyb3dzZXIgc2hvd3Mgc3RhY2sgcmVnYXJkbGVzcyBvZiB0eXBlIG9mIGRhdGEgcGFzc2VkIHRvIGNvbnNvbGUuZXJyb3IsIHNvIHdlIHNob3VsZCBkbyB0aGUgc2FtZVxuICAgKlxuICAgKiBkbyBub3QgYWJzdHJhY3QgdGhpcywgaXQgaW1wbGljaXRseSByZWxpZXMgb24gd2hpY2ggZnVuY3Rpb25zIGNhbGwgaXQuIGZvcmNpbmcgdGhlIGlubGluZWQgaW1wbGVtZW50YXRpb24gbWFrZXMgeW91IHRoaW5rIGFib3V0IGNhbGxlcnNcbiAgICovXG4gIGNvbnN0IHN0YWNrID0gc3RhY2tXaXRoT3duZXJzKG5ldyBFcnJvcigpKVxuICBjb25zdCBzdGFja0xpbmVzID0gc3RhY2s/LnNwbGl0KCdcXG4nKVxuICBjb25zdCBjbGVhblN0YWNrID0gc3RhY2tMaW5lcz8uc2xpY2UoMykuam9pbignXFxuJylcblxuICBjb25zdCBlbnRyeTogQ29uc29sZUVycm9yRW50cnk8dW5rbm93bj4gPSB7XG4gICAga2luZDogJ2FueS1sb2dnZWQtZXJyb3InLFxuICAgIG1ldGhvZDogJ2Vycm9yJyxcbiAgICBjb25zb2xlRXJyb3JTdGFjazogY2xlYW5TdGFjayA/PyAnJyxcbiAgICBhcmdzOiBhcmdzLm1hcCgoYXJnKSA9PiB7XG4gICAgICBpZiAoYXJnIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVycm9yQXJnKGFyZylcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGtpbmQ6ICdhcmcnLFxuICAgICAgICBkYXRhOiBwcmVMb2dTZXJpYWxpemF0aW9uQ2xvbmUoYXJnKSxcbiAgICAgIH1cbiAgICB9KSxcbiAgfVxuXG4gIGxvZ1F1ZXVlLnNjaGVkdWxlTG9nU2VuZChlbnRyeSlcbn1cblxuY29uc3QgY3JlYXRlVW5jYXVnaHRFcnJvckVudHJ5ID0gKFxuICBlcnJvck5hbWU6IHN0cmluZyxcbiAgZXJyb3JNZXNzYWdlOiBzdHJpbmcsXG4gIGZ1bGxTdGFjazogc3RyaW5nXG4pID0+IHtcbiAgY29uc3QgZW50cnk6IEZvcm1hdHRlZEVycm9yRW50cnkgPSB7XG4gICAga2luZDogJ2Zvcm1hdHRlZC1lcnJvcicsXG4gICAgcHJlZml4OiBgVW5jYXVnaHQgJHtlcnJvck5hbWV9OiAke2Vycm9yTWVzc2FnZX1gLFxuICAgIHN0YWNrOiBmdWxsU3RhY2ssXG4gICAgbWV0aG9kOiAnZXJyb3InLFxuICB9XG5cbiAgbG9nUXVldWUuc2NoZWR1bGVMb2dTZW5kKGVudHJ5KVxufVxuXG5jb25zdCBzdGFja1dpdGhPd25lcnMgPSAoZXJyb3I6IEVycm9yKSA9PiB7XG4gIGxldCBvd25lclN0YWNrID0gJydcbiAgc2V0T3duZXJTdGFja0lmQXZhaWxhYmxlKGVycm9yKVxuICBvd25lclN0YWNrID0gZ2V0T3duZXJTdGFjayhlcnJvcikgfHwgJydcbiAgY29uc3Qgc3RhY2sgPSAoZXJyb3Iuc3RhY2sgfHwgJycpICsgb3duZXJTdGFja1xuICByZXR1cm4gc3RhY2tcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvZ1VuaGFuZGxlZFJlamVjdGlvbihyZWFzb246IHVua25vd24pIHtcbiAgaWYgKHJlYXNvbiBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgY3JlYXRlVW5oYW5kbGVkUmVqZWN0aW9uRXJyb3JFbnRyeShyZWFzb24sIHN0YWNrV2l0aE93bmVycyhyZWFzb24pKVxuICAgIHJldHVyblxuICB9XG4gIGNyZWF0ZVVuaGFuZGxlZFJlamVjdGlvbk5vbkVycm9yRW50cnkocmVhc29uKVxufVxuXG5jb25zdCBjcmVhdGVVbmhhbmRsZWRSZWplY3Rpb25FcnJvckVudHJ5ID0gKFxuICBlcnJvcjogRXJyb3IsXG4gIGZ1bGxTdGFjazogc3RyaW5nXG4pID0+IHtcbiAgY29uc3Qgc291cmNlID0gZ2V0RXJyb3JTb3VyY2UoZXJyb3IpXG4gIGlmIChzb3VyY2UpIHtcbiAgICBsb2dRdWV1ZS5zb3VyY2VUeXBlID0gc291cmNlXG4gIH1cblxuICBjb25zdCBlbnRyeTogQ2xpZW50TG9nRW50cnkgPSB7XG4gICAga2luZDogJ2Zvcm1hdHRlZC1lcnJvcicsXG4gICAgcHJlZml4OiBg4qivIHVuaGFuZGxlZFJlamVjdGlvbjogJHtlcnJvci5uYW1lfTogJHtlcnJvci5tZXNzYWdlfWAsXG4gICAgc3RhY2s6IGZ1bGxTdGFjayxcbiAgICBtZXRob2Q6ICdlcnJvcicsXG4gIH1cblxuICBsb2dRdWV1ZS5zY2hlZHVsZUxvZ1NlbmQoZW50cnkpXG59XG5cbmNvbnN0IGNyZWF0ZVVuaGFuZGxlZFJlamVjdGlvbk5vbkVycm9yRW50cnkgPSAocmVhc29uOiB1bmtub3duKSA9PiB7XG4gIGNvbnN0IGVudHJ5OiBDbGllbnRMb2dFbnRyeSA9IHtcbiAgICBraW5kOiAnYW55LWxvZ2dlZC1lcnJvcicsXG4gICAgLy8gd2UgY2FuJ3QgYWNjZXNzIHRoZSBzdGFjayBzaW5jZSB0aGUgZXZlbnQgaXMgZGlzcGF0Y2hlZCBhc3luYyBhbmQgY3JlYXRpbmcgYW4gaW5saW5lIGVycm9yIHdvdWxkIGJlIG1lYW5pbmdsZXNzXG4gICAgY29uc29sZUVycm9yU3RhY2s6ICcnLFxuICAgIG1ldGhvZDogJ2Vycm9yJyxcbiAgICBhcmdzOiBbXG4gICAgICB7XG4gICAgICAgIGtpbmQ6ICdhcmcnLFxuICAgICAgICBkYXRhOiBg4qivIHVuaGFuZGxlZFJlamVjdGlvbjpgLFxuICAgICAgICBpc1JlamVjdGlvbk1lc3NhZ2U6IHRydWUsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBraW5kOiAnYXJnJyxcbiAgICAgICAgZGF0YTogcHJlTG9nU2VyaWFsaXphdGlvbkNsb25lKHJlYXNvbiksXG4gICAgICB9LFxuICAgIF0sXG4gIH1cblxuICBsb2dRdWV1ZS5zY2hlZHVsZUxvZ1NlbmQoZW50cnkpXG59XG5cbmNvbnN0IGlzSE1SID0gKGFyZ3M6IGFueVtdKSA9PiB7XG4gIGNvbnN0IGZpcnN0QXJnID0gYXJnc1swXVxuICBpZiAodHlwZW9mIGZpcnN0QXJnICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGlmIChmaXJzdEFyZy5zdGFydHNXaXRoKCdbRmFzdCBSZWZyZXNoXScpKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGlmIChmaXJzdEFyZy5zdGFydHNXaXRoKCdbSE1SXScpKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuXG5jb25zdCBpc0lnbm9yZWRMb2cgPSAoYXJnczogYW55W10pID0+IHtcbiAgaWYgKGFyZ3MubGVuZ3RoIDwgMykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgY29uc3QgW2Zvcm1hdCwgc3R5bGVzLCBsYWJlbF0gPSBhcmdzXG5cbiAgaWYgKFxuICAgIHR5cGVvZiBmb3JtYXQgIT09ICdzdHJpbmcnIHx8XG4gICAgdHlwZW9mIHN0eWxlcyAhPT0gJ3N0cmluZycgfHxcbiAgICB0eXBlb2YgbGFiZWwgIT09ICdzdHJpbmcnXG4gICkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8ga2luZGEgaGFja3ksIHdlIHNob3VsZCBkZWZpbmUgYSBjb21tb24gZm9ybWF0IGZvciB0aGVzZSBzdHJpbmdzIHNvIHdlIGNhbiBzYWZlbHkgaWdub3JlXG4gIHJldHVybiBmb3JtYXQuc3RhcnRzV2l0aCgnJWMlcyVjJykgJiYgc3R5bGVzLmluY2x1ZGVzKCdiYWNrZ3JvdW5kOicpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3J3YXJkVW5oYW5kbGVkRXJyb3IoZXJyb3I6IEVycm9yKSB7XG4gIGNyZWF0ZVVuY2F1Z2h0RXJyb3JFbnRyeShlcnJvci5uYW1lLCBlcnJvci5tZXNzYWdlLCBzdGFja1dpdGhPd25lcnMoZXJyb3IpKVxufVxuXG4vLyBUT0RPOiB0aGlzIHJvdXRlciBjaGVjayBpcyBicml0dGxlLCB3ZSBuZWVkIHRvIHVwZGF0ZSBiYXNlZCBvbiB0aGUgY3VycmVudCByb3V0ZXIgdGhlIHVzZXIgaXMgdXNpbmdcbmV4cG9ydCBjb25zdCBpbml0aWFsaXplRGVidWdMb2dGb3J3YXJkaW5nID0gKHJvdXRlcjogJ2FwcCcgfCAncGFnZXMnKTogdm9pZCA9PiB7XG4gIC8vIHByb2JhYmx5IGRvbid0IG5lZWQgdGhpc1xuICBpZiAoaXNQYXRjaGVkKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgLy8gVE9ETyhyb2IpOiB3aHkgZG9lcyB0aGlzIGJyZWFrIHJlbmRlcmluZyBvbiBzZXJ2ZXIsIGltcG9ydGFudCB0byBrbm93IGluY2FzZSB0aGUgc2FtZSBidWcgYXBwZWFycyBpbiBicm93c2VyXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVyblxuICB9XG5cbiAgLy8gYmV0dGVyIHRvIGJlIHNhZmUgdGhhbiBzb3JyeVxuICB0cnkge1xuICAgIG1ldGhvZHMuZm9yRWFjaCgobWV0aG9kKSA9PlxuICAgICAgcGF0Y2hDb25zb2xlTWV0aG9kKG1ldGhvZCwgKF8sIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgaWYgKGlzSE1SKGFyZ3MpKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzSWdub3JlZExvZyhhcmdzKSkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGNyZWF0ZUxvZ0VudHJ5KG1ldGhvZCwgYXJncylcbiAgICAgIH0pXG4gICAgKVxuICB9IGNhdGNoIHt9XG4gIGxvZ1F1ZXVlLnJvdXRlciA9IHJvdXRlclxuICBpc1BhdGNoZWQgPSB0cnVlXG59XG4iXSwibmFtZXMiOlsiUFJPTUlTRV9NQVJLRVIiLCJVTkFWQUlMQUJMRV9NQVJLRVIiLCJmb3J3YXJkRXJyb3JMb2ciLCJmb3J3YXJkVW5oYW5kbGVkRXJyb3IiLCJpbml0aWFsaXplRGVidWdMb2dGb3J3YXJkaW5nIiwiaXNUZXJtaW5hbExvZ2dpbmdFbmFibGVkIiwibG9nUXVldWUiLCJsb2dTdHJpbmdpZnkiLCJsb2dVbmhhbmRsZWRSZWplY3Rpb24iLCJwcmVMb2dTZXJpYWxpemF0aW9uQ2xvbmUiLCJ0ZXJtaW5hbExvZ2dpbmdDb25maWciLCJnZXRUZXJtaW5hbExvZ2dpbmdDb25maWciLCJtYXhpbXVtRGVwdGgiLCJkZXB0aExpbWl0IiwibWF4aW11bUJyZWFkdGgiLCJlZGdlTGltaXQiLCJzdHJpbmdpZnkiLCJjb25maWd1cmUiLCJnZXRJc1Rlcm1pbmFsTG9nZ2luZ0VuYWJsZWQiLCJtZXRob2RzIiwidmFsdWUiLCJzZWVuIiwiV2Vha01hcCIsInVuZGVmaW5lZCIsIlVOREVGSU5FRF9NQVJLRVIiLCJoYXMiLCJnZXQiLCJPYmplY3QiLCJrZXlzIiwidGhlbiIsIkFycmF5IiwiaXNBcnJheSIsIm91dCIsInNldCIsIml0ZW0iLCJwdXNoIiwicHJvdG8iLCJnZXRQcm90b3R5cGVPZiIsInByb3RvdHlwZSIsImtleSIsInRvU3RyaW5nIiwiY2FsbCIsImRhdGEiLCJyZXN1bHQiLCJhZnRlclRoaXNGcmFtZSIsImNiIiwidGltZW91dCIsInJhZklkIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwic2V0VGltZW91dCIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiY2xlYXJUaW1lb3V0IiwiaXNQYXRjaGVkIiwic2VyaWFsaXplRW50cmllcyIsImVudHJpZXMiLCJtYXAiLCJjbGllbnRFbnRyeSIsImtpbmQiLCJhcmdzIiwic3RyaW5naWZ5VXNlckFyZyIsImZsdXNoU2NoZWR1bGVkIiwiY2FuY2VsRmx1c2giLCJzb2NrZXQiLCJzb3VyY2VUeXBlIiwicm91dGVyIiwic2NoZWR1bGVMb2dTZW5kIiwiZW50cnkiLCJwYXlsb2FkIiwiSlNPTiIsImV2ZW50Iiwic2VuZCIsIm9uU29ja2V0UmVhZHkiLCJyZWFkeVN0YXRlIiwiV2ViU29ja2V0IiwiT1BFTiIsImFyZyIsImNyZWF0ZUVycm9yQXJnIiwiZXJyb3IiLCJzdGFjayIsInN0YWNrV2l0aE93bmVycyIsInByZWZpeCIsIm1lc3NhZ2UiLCJuYW1lIiwiY3JlYXRlTG9nRW50cnkiLCJsZXZlbCIsIkVycm9yIiwic3RhY2tMaW5lcyIsInNwbGl0IiwiY2xlYW5TdGFjayIsInNsaWNlIiwiam9pbiIsImNvbnNvbGVNZXRob2RTdGFjayIsIm1ldGhvZCIsImVycm9yT2JqZWN0cyIsImZpbHRlciIsImZpcnN0IiwiYXQiLCJzb3VyY2UiLCJnZXRFcnJvclNvdXJjZSIsImNvbnNvbGVFcnJvclN0YWNrIiwiY3JlYXRlVW5jYXVnaHRFcnJvckVudHJ5IiwiZXJyb3JOYW1lIiwiZXJyb3JNZXNzYWdlIiwiZnVsbFN0YWNrIiwib3duZXJTdGFjayIsInNldE93bmVyU3RhY2tJZkF2YWlsYWJsZSIsImdldE93bmVyU3RhY2siLCJyZWFzb24iLCJjcmVhdGVVbmhhbmRsZWRSZWplY3Rpb25FcnJvckVudHJ5IiwiY3JlYXRlVW5oYW5kbGVkUmVqZWN0aW9uTm9uRXJyb3JFbnRyeSIsImlzUmVqZWN0aW9uTWVzc2FnZSIsImlzSE1SIiwiZmlyc3RBcmciLCJzdGFydHNXaXRoIiwiaXNJZ25vcmVkTG9nIiwibGVuZ3RoIiwiZm9ybWF0Iiwic3R5bGVzIiwibGFiZWwiLCJpbmNsdWRlcyIsIndpbmRvdyIsImZvckVhY2giLCJwYXRjaENvbnNvbGVNZXRob2QiLCJfIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7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Q2xCLE9BQU9DLFdBQVcsWUFDbEIsT0FBT0MsVUFBVSxVQUNqQjtRQUNBLE9BQU87SUFDVDtJQUVBLDBGQUEwRjtJQUMxRixPQUFPRixPQUFPSCxVQUFVLENBQUMsYUFBYUksT0FBT0UsUUFBUSxDQUFDO0FBQ3hEO0FBRU8sU0FBU3BILHNCQUFzQjBFLEtBQVk7SUFDaER1Qix5QkFBeUJ2QixNQUFNSyxJQUFJLEVBQUVMLE1BQU1JLE9BQU8sRUFBRUYsZ0JBQWdCRjtBQUN0RTtBQUdPLE1BQU16RSwrQkFBK0IsQ0FBQzREO0lBQzNDLDJCQUEyQjtJQUMzQixJQUFJWixXQUFXO1FBQ2I7SUFDRjtJQUNBLCtHQUErRztJQUMvRyxJQUFJLE9BQU9vRSxXQUFXLGtCQUFhO1FBQ2pDO0lBQ0Y7OztBQWtCRiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA3OTMxLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL25leHQtZGV2dG9vbHMvdXNlcnNwYWNlL2FwcC9lcnJvcnMvdXNlLWVycm9yLWhhbmRsZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBpc05leHRSb3V0ZXJFcnJvciB9IGZyb20gJy4uLy4uLy4uLy4uL2NsaWVudC9jb21wb25lbnRzL2lzLW5leHQtcm91dGVyLWVycm9yJ1xuaW1wb3J0IHtcbiAgZm9ybWF0Q29uc29sZUFyZ3MsXG4gIHBhcnNlQ29uc29sZUFyZ3MsXG59IGZyb20gJy4uLy4uLy4uLy4uL2NsaWVudC9saWIvY29uc29sZSdcbmltcG9ydCBpc0Vycm9yIGZyb20gJy4uLy4uLy4uLy4uL2xpYi9pcy1lcnJvcidcbmltcG9ydCB7IGNyZWF0ZUNvbnNvbGVFcnJvciB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zb2xlLWVycm9yJ1xuaW1wb3J0IHsgY29lcmNlRXJyb3IsIHNldE93bmVyU3RhY2tJZkF2YWlsYWJsZSB9IGZyb20gJy4vc3RpdGNoZWQtZXJyb3InXG5pbXBvcnQge1xuICBmb3J3YXJkVW5oYW5kbGVkRXJyb3IsXG4gIGlzVGVybWluYWxMb2dnaW5nRW5hYmxlZCxcbiAgbG9nVW5oYW5kbGVkUmVqZWN0aW9uLFxufSBmcm9tICcuLi9mb3J3YXJkLWxvZ3MnXG5cbmNvbnN0IHF1ZXVlTWljcm9UYXNrID1cbiAgZ2xvYmFsVGhpcy5xdWV1ZU1pY3JvdGFzayB8fCAoKGNiOiAoKSA9PiB2b2lkKSA9PiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGNiKSlcblxuZXhwb3J0IHR5cGUgRXJyb3JIYW5kbGVyID0gKGVycm9yOiBFcnJvcikgPT4gdm9pZFxuXG5jb25zdCBlcnJvclF1ZXVlOiBBcnJheTxFcnJvcj4gPSBbXVxuY29uc3QgZXJyb3JIYW5kbGVyczogQXJyYXk8RXJyb3JIYW5kbGVyPiA9IFtdXG5jb25zdCByZWplY3Rpb25RdWV1ZTogQXJyYXk8RXJyb3I+ID0gW11cbmNvbnN0IHJlamVjdGlvbkhhbmRsZXJzOiBBcnJheTxFcnJvckhhbmRsZXI+ID0gW11cblxuZXhwb3J0IGZ1bmN0aW9uIGhhbmRsZUNvbnNvbGVFcnJvcihcbiAgb3JpZ2luRXJyb3I6IHVua25vd24sXG4gIGNvbnNvbGVFcnJvckFyZ3M6IGFueVtdXG4pIHtcbiAgbGV0IGVycm9yOiBFcnJvclxuICBjb25zdCB7IGVudmlyb25tZW50TmFtZSB9ID0gcGFyc2VDb25zb2xlQXJncyhjb25zb2xlRXJyb3JBcmdzKVxuICBpZiAoaXNFcnJvcihvcmlnaW5FcnJvcikpIHtcbiAgICBlcnJvciA9IGNyZWF0ZUNvbnNvbGVFcnJvcihvcmlnaW5FcnJvciwgZW52aXJvbm1lbnROYW1lKVxuICB9IGVsc2Uge1xuICAgIGVycm9yID0gY3JlYXRlQ29uc29sZUVycm9yKFxuICAgICAgZm9ybWF0Q29uc29sZUFyZ3MoY29uc29sZUVycm9yQXJncyksXG4gICAgICBlbnZpcm9ubWVudE5hbWVcbiAgICApXG4gIH1cbiAgc2V0T3duZXJTdGFja0lmQXZhaWxhYmxlKGVycm9yKVxuXG4gIGVycm9yUXVldWUucHVzaChlcnJvcilcbiAgZm9yIChjb25zdCBoYW5kbGVyIG9mIGVycm9ySGFuZGxlcnMpIHtcbiAgICAvLyBEZWxheWVkIHRoZSBlcnJvciBiZWluZyBwYXNzZWQgdG8gUmVhY3QgRGV2IE92ZXJsYXksXG4gICAgLy8gYXZvaWQgdGhlIHN0YXRlIGJlaW5nIHN5bmNocm9ub3VzbHkgdXBkYXRlZCBpbiB0aGUgY29tcG9uZW50LlxuICAgIHF1ZXVlTWljcm9UYXNrKCgpID0+IHtcbiAgICAgIGhhbmRsZXIoZXJyb3IpXG4gICAgfSlcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFuZGxlQ2xpZW50RXJyb3IoZXJyb3I6IEVycm9yKSB7XG4gIGVycm9yUXVldWUucHVzaChlcnJvcilcbiAgZm9yIChjb25zdCBoYW5kbGVyIG9mIGVycm9ySGFuZGxlcnMpIHtcbiAgICAvLyBEZWxheWVkIHRoZSBlcnJvciBiZWluZyBwYXNzZWQgdG8gUmVhY3QgRGV2IE92ZXJsYXksXG4gICAgLy8gYXZvaWQgdGhlIHN0YXRlIGJlaW5nIHN5bmNocm9ub3VzbHkgdXBkYXRlZCBpbiB0aGUgY29tcG9uZW50LlxuICAgIHF1ZXVlTWljcm9UYXNrKCgpID0+IHtcbiAgICAgIGhhbmRsZXIoZXJyb3IpXG4gICAgfSlcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlRXJyb3JIYW5kbGVyKFxuICBoYW5kbGVPblVuaGFuZGxlZEVycm9yOiBFcnJvckhhbmRsZXIsXG4gIGhhbmRsZU9uVW5oYW5kbGVkUmVqZWN0aW9uOiBFcnJvckhhbmRsZXJcbikge1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIEhhbmRsZSBxdWV1ZWQgZXJyb3JzLlxuICAgIGVycm9yUXVldWUuZm9yRWFjaChoYW5kbGVPblVuaGFuZGxlZEVycm9yKVxuICAgIHJlamVjdGlvblF1ZXVlLmZvckVhY2goaGFuZGxlT25VbmhhbmRsZWRSZWplY3Rpb24pXG5cbiAgICAvLyBMaXN0ZW4gdG8gbmV3IGVycm9ycy5cbiAgICBlcnJvckhhbmRsZXJzLnB1c2goaGFuZGxlT25VbmhhbmRsZWRFcnJvcilcbiAgICByZWplY3Rpb25IYW5kbGVycy5wdXNoKGhhbmRsZU9uVW5oYW5kbGVkUmVqZWN0aW9uKVxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIC8vIFJlbW92ZSBsaXN0ZW5lcnMuXG4gICAgICBlcnJvckhhbmRsZXJzLnNwbGljZShlcnJvckhhbmRsZXJzLmluZGV4T2YoaGFuZGxlT25VbmhhbmRsZWRFcnJvciksIDEpXG4gICAgICByZWplY3Rpb25IYW5kbGVycy5zcGxpY2UoXG4gICAgICAgIHJlamVjdGlvbkhhbmRsZXJzLmluZGV4T2YoaGFuZGxlT25VbmhhbmRsZWRSZWplY3Rpb24pLFxuICAgICAgICAxXG4gICAgICApXG5cbiAgICAgIC8vIFJlc2V0IGVycm9yIHF1ZXVlcy5cbiAgICAgIGVycm9yUXVldWUuc3BsaWNlKDAsIGVycm9yUXVldWUubGVuZ3RoKVxuICAgICAgcmVqZWN0aW9uUXVldWUuc3BsaWNlKDAsIHJlamVjdGlvblF1ZXVlLmxlbmd0aClcbiAgICB9XG4gIH0sIFtoYW5kbGVPblVuaGFuZGxlZEVycm9yLCBoYW5kbGVPblVuaGFuZGxlZFJlamVjdGlvbl0pXG59XG5cbmZ1bmN0aW9uIG9uVW5oYW5kbGVkRXJyb3IoZXZlbnQ6IFdpbmRvd0V2ZW50TWFwWydlcnJvciddKTogdm9pZCB8IGJvb2xlYW4ge1xuICBjb25zdCB0aHJvd25WYWx1ZTogdW5rbm93biA9IGV2ZW50LmVycm9yXG4gIGlmIChpc05leHRSb3V0ZXJFcnJvcih0aHJvd25WYWx1ZSkpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgLy8gV2hlbiB0aGVyZSdzIGFuIGVycm9yIHByb3BlcnR5IHByZXNlbnQsIHdlIGxvZyB0aGUgZXJyb3IgdG8gZXJyb3Igb3ZlcmxheS5cbiAgLy8gT3RoZXJ3aXNlIHdlIGRvbid0IGRvIGFueXRoaW5nIGFzIGl0J3Mgbm90IGxvZ2dpbmcgaW4gdGhlIGNvbnNvbGUgZWl0aGVyLlxuICBpZiAodGhyb3duVmFsdWUpIHtcbiAgICBjb25zdCBlcnJvciA9IGNvZXJjZUVycm9yKHRocm93blZhbHVlKVxuICAgIHNldE93bmVyU3RhY2tJZkF2YWlsYWJsZShlcnJvcilcbiAgICBoYW5kbGVDbGllbnRFcnJvcihlcnJvcilcbiAgICBpZiAoaXNUZXJtaW5hbExvZ2dpbmdFbmFibGVkKSB7XG4gICAgICBmb3J3YXJkVW5oYW5kbGVkRXJyb3IoZXJyb3IpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG9uVW5oYW5kbGVkUmVqZWN0aW9uKGV2OiBXaW5kb3dFdmVudE1hcFsndW5oYW5kbGVkcmVqZWN0aW9uJ10pOiB2b2lkIHtcbiAgY29uc3QgcmVhc29uOiB1bmtub3duID0gZXY/LnJlYXNvblxuICBpZiAoaXNOZXh0Um91dGVyRXJyb3IocmVhc29uKSkge1xuICAgIGV2LnByZXZlbnREZWZhdWx0KClcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IGVycm9yID0gY29lcmNlRXJyb3IocmVhc29uKVxuICBzZXRPd25lclN0YWNrSWZBdmFpbGFibGUoZXJyb3IpXG5cbiAgcmVqZWN0aW9uUXVldWUucHVzaChlcnJvcilcbiAgZm9yIChjb25zdCBoYW5kbGVyIG9mIHJlamVjdGlvbkhhbmRsZXJzKSB7XG4gICAgaGFuZGxlcihlcnJvcilcbiAgfVxuXG4gIGlmIChpc1Rlcm1pbmFsTG9nZ2luZ0VuYWJsZWQpIHtcbiAgICBsb2dVbmhhbmRsZWRSZWplY3Rpb24ocmVhc29uKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYW5kbGVHbG9iYWxFcnJvcnMoKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRyeSB7XG4gICAgICAvLyBJbmNyZWFzZSB0aGUgbnVtYmVyIG9mIHN0YWNrIGZyYW1lcyBvbiB0aGUgY2xpZW50XG4gICAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSA1MFxuICAgIH0gY2F0Y2gge31cblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uVW5oYW5kbGVkRXJyb3IpXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3VuaGFuZGxlZHJlamVjdGlvbicsIG9uVW5oYW5kbGVkUmVqZWN0aW9uKVxuICB9XG59XG4iXSwibmFtZXMiOlsiaGFuZGxlQ2xpZW50RXJyb3IiLCJoYW5kbGVDb25zb2xlRXJyb3IiLCJoYW5kbGVHbG9iYWxFcnJvcnMiLCJ1c2VFcnJvckhhbmRsZXIiLCJxdWV1ZU1pY3JvVGFzayIsImdsb2JhbFRoaXMiLCJxdWV1ZU1pY3JvdGFzayIsImNiIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwiZXJyb3JRdWV1ZSIsImVycm9ySGFuZGxlcnMiLCJyZWplY3Rpb25RdWV1ZSIsInJlamVjdGlvbkhhbmRsZXJzIiwib3JpZ2luRXJyb3IiLCJjb25zb2xlRXJyb3JBcmdzIiwiZXJyb3IiLCJlbnZpcm9ubWVudE5hbWUiLCJwYXJzZUNvbnNvbGVBcmdzIiwiaXNFcnJvciIsImNyZWF0ZUNvbnNvbGVFcnJvciIsImZvcm1hdENvbnNvbGVBcmdzIiwic2V0T3duZXJTdGFja0lmQXZhaWxhYmxlIiwicHVzaCIsImhhbmRsZXIiLCJoYW5kbGVPblVuaGFuZGxlZEVycm9yIiwiaGFuZGxlT25VbmhhbmRsZWRSZWplY3Rpb24iLCJ1c2VFZmZlY3QiLCJmb3JFYWNoIiwic3BsaWNlIiwiaW5kZXhPZiIsImxlbmd0aCIsIm9uVW5oYW5kbGVkRXJyb3IiLCJldmVudCIsInRocm93blZhbHVlIiwiaXNOZXh0Um91dGVyRXJyb3IiLCJwcmV2ZW50RGVmYXVsdCIsImNvZXJjZUVycm9yIiwiaXNUZXJtaW5hbExvZ2dpbmdFbmFibGVkIiwiZm9yd2FyZFVuaGFuZGxlZEVycm9yIiwib25VbmhhbmRsZWRSZWplY3Rpb24iLCJldiIsInJlYXNvbiIsImxvZ1VuaGFuZGxlZFJlamVjdGlvbiIsIndpbmRvdyIsIkVycm9yIiwic3RhY2tUcmFjZUxpbWl0IiwiYWRkRXZlbnRMaXN0ZW5lciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztJQW1EZ0JBLGlCQUFpQixFQUFBO2VBQWpCQTs7SUExQkFDLGtCQUFrQixFQUFBO2VBQWxCQTs7SUF1R0FDLGtCQUFrQixFQUFBO2VBQWxCQTs7SUFsRUFDLGVBQWUsRUFBQTtlQUFmQTs7Ozt1QkE5RFU7bUNBQ1E7eUJBSTNCO2tFQUNhOzhCQUNlOytCQUNtQjs2QkFLL0M7QUFFUCxNQUFNQyxpQkFDSkMsV0FBV0MsY0FBYyxJQUFLLENBQUEsQ0FBQ0MsS0FBbUJDLFFBQVFDLE9BQU8sR0FBR0MsSUFBSSxDQUFDSCxHQUFFO0FBSTdFLE1BQU1JLGFBQTJCLEVBQUU7QUFDbkMsTUFBTUMsZ0JBQXFDLEVBQUU7QUFDN0MsTUFBTUMsaUJBQStCLEVBQUU7QUFDdkMsTUFBTUMsb0JBQXlDLEVBQUU7QUFFMUMsU0FBU2IsbUJBQ2RjLFdBQW9CLEVBQ3BCQyxnQkFBdUI7SUFFdkIsSUFBSUM7SUFDSixNQUFNLEVBQUVDLGVBQWUsRUFBRSxHQUFHQyxDQUFBQSxHQUFBQSxTQUFBQSxnQkFBZ0IsRUFBQ0g7SUFDN0MsSUFBSUksQ0FBQUEsR0FBQUEsU0FBQUEsT0FBTyxFQUFDTCxjQUFjO1FBQ3hCRSxRQUFRSSxDQUFBQSxHQUFBQSxjQUFBQSxrQkFBa0IsRUFBQ04sYUFBYUc7SUFDMUMsT0FBTztRQUNMRCxRQUFRSSxDQUFBQSxHQUFBQSxjQUFBQSxrQkFBa0IsRUFDeEJDLENBQUFBLEdBQUFBLFNBQUFBLGlCQUFpQixFQUFDTixtQkFDbEJFO0lBRUo7SUFDQUssQ0FBQUEsR0FBQUEsZUFBQUEsd0JBQXdCLEVBQUNOO0lBRXpCTixXQUFXYSxJQUFJLENBQUNQO0lBQ2hCLEtBQUssTUFBTVEsV0FBV2IsY0FBZTtRQUNuQyx1REFBdUQ7UUFDdkQsZ0VBQWdFO1FBQ2hFUixlQUFlO1lBQ2JxQixRQUFRUjtRQUNWO0lBQ0Y7QUFDRjtBQUVPLFNBQVNqQixrQkFBa0JpQixLQUFZO0lBQzVDTixXQUFXYSxJQUFJLENBQUNQO0lBQ2hCLEtBQUssTUFBTVEsV0FBV2IsY0FBZTtRQUNuQyx1REFBdUQ7UUFDdkQsZ0VBQWdFO1FBQ2hFUixlQUFlO1lBQ2JxQixRQUFRUjtRQUNWO0lBQ0Y7QUFDRjtBQUVPLFNBQVNkLGdCQUNkdUIsc0JBQW9DLEVBQ3BDQywwQkFBd0M7SUFFeENDLENBQUFBLEdBQUFBLE9BQUFBLFNBQVMsRUFBQztRQUNSLHdCQUF3QjtRQUN4QmpCLFdBQVdrQixPQUFPLENBQUNIO1FBQ25CYixlQUFlZ0IsT0FBTyxDQUFDRjtRQUV2Qix3QkFBd0I7UUFDeEJmLGNBQWNZLElBQUksQ0FBQ0U7UUFDbkJaLGtCQUFrQlUsSUFBSSxDQUFDRztRQUV2QixPQUFPO1lBQ0wsb0JBQW9CO1lBQ3BCZixjQUFja0IsTUFBTSxDQUFDbEIsY0FBY21CLE9BQU8sQ0FBQ0wseUJBQXlCO1lBQ3BFWixrQkFBa0JnQixNQUFNLENBQ3RCaEIsa0JBQWtCaUIsT0FBTyxDQUFDSiw2QkFDMUI7WUFHRixzQkFBc0I7WUFDdEJoQixXQUFXbUIsTUFBTSxDQUFDLEdBQUduQixXQUFXcUIsTUFBTTtZQUN0Q25CLGVBQWVpQixNQUFNLENBQUMsR0FBR2pCLGVBQWVtQixNQUFNO1FBQ2hEO0lBQ0YsR0FBRztRQUFDTjtRQUF3QkM7S0FBMkI7QUFDekQ7QUFFQSxTQUFTTSxpQkFBaUJDLEtBQThCO0lBQ3RELE1BQU1DLGNBQXVCRCxNQUFNakIsS0FBSztJQUN4QyxJQUFJbUIsQ0FBQUEsR0FBQUEsbUJBQUFBLGlCQUFpQixFQUFDRCxjQUFjO1FBQ2xDRCxNQUFNRyxjQUFjO1FBQ3BCLE9BQU87SUFDVDtJQUNBLDZFQUE2RTtJQUM3RSw0RUFBNEU7SUFDNUUsSUFBSUYsYUFBYTtRQUNmLE1BQU1sQixRQUFRcUIsQ0FBQUEsR0FBQUEsZUFBQUEsV0FBVyxFQUFDSDtRQUMxQlosQ0FBQUEsR0FBQUEsZUFBQUEsd0JBQXdCLEVBQUNOO1FBQ3pCakIsa0JBQWtCaUI7UUFDbEIsSUFBSXNCLGFBQUFBLHdCQUF3QixFQUFFO1lBQzVCQyxDQUFBQSxHQUFBQSxhQUFBQSxxQkFBcUIsRUFBQ3ZCO1FBQ3hCO0lBQ0Y7QUFDRjtBQUVBLFNBQVN3QixxQkFBcUJDLEVBQXdDO0lBQ3BFLE1BQU1DLFNBQWtCRCxNQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxHQUFJQyxNQUFNO0lBQ2xDLElBQUlQLENBQUFBLEdBQUFBLG1CQUFBQSxpQkFBaUIsRUFBQ08sU0FBUztRQUM3QkQsR0FBR0wsY0FBYztRQUNqQjtJQUNGO0lBRUEsTUFBTXBCLFFBQVFxQixDQUFBQSxHQUFBQSxlQUFBQSxXQUFXLEVBQUNLO0lBQzFCcEIsQ0FBQUEsR0FBQUEsZUFBQUEsd0JBQXdCLEVBQUNOO0lBRXpCSixlQUFlVyxJQUFJLENBQUNQO0lBQ3BCLEtBQUssTUFBTVEsV0FBV1gsa0JBQW1CO1FBQ3ZDVyxRQUFRUjtJQUNWO0lBRUEsSUFBSXNCLGFBQUFBLHdCQUF3QixFQUFFO1FBQzVCSyxDQUFBQSxHQUFBQSxhQUFBQSxxQkFBcUIsRUFBQ0Q7SUFDeEI7QUFDRjtBQUVPLFNBQVN6QztJQUNkLElBQUksT0FBTzJDLFdBQVcsYUFBYTs7QUFTckMiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogODA3MiwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9zaGFyZWQvbGliL2Vycm9ycy9jb25zdGFudHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IE1JU1NJTkdfUk9PVF9UQUdTX0VSUk9SID0gJ05FWFRfTUlTU0lOR19ST09UX1RBR1MnXG4iXSwibmFtZXMiOlsiTUlTU0lOR19ST09UX1RBR1NfRVJST1IiXSwibWFwcGluZ3MiOiI7OzsrQkFBYUEsMkJBQUFBOzs7ZUFBQUE7OztBQUFOLE1BQU1BLDBCQUEwQiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA4MDk1LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL25leHQtZGV2dG9vbHMvdXNlcnNwYWNlL2FwcC9lcnJvcnMvcmVwbGF5LXNzci1vbmx5LWVycm9ycy50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBoYW5kbGVDbGllbnRFcnJvciB9IGZyb20gJy4vdXNlLWVycm9yLWhhbmRsZXInXG5pbXBvcnQgeyBpc05leHRSb3V0ZXJFcnJvciB9IGZyb20gJy4uLy4uLy4uLy4uL2NsaWVudC9jb21wb25lbnRzL2lzLW5leHQtcm91dGVyLWVycm9yJ1xuaW1wb3J0IHsgTUlTU0lOR19ST09UX1RBR1NfRVJST1IgfSBmcm9tICcuLi8uLi8uLi8uLi9zaGFyZWQvbGliL2Vycm9ycy9jb25zdGFudHMnXG5cbmZ1bmN0aW9uIHJlYWRTc3JFcnJvcigpOiAoRXJyb3IgJiB7IGRpZ2VzdD86IHN0cmluZyB9KSB8IG51bGwge1xuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBjb25zdCBzc3JFcnJvclRlbXBsYXRlVGFnID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcbiAgICAndGVtcGxhdGVbZGF0YS1uZXh0LWVycm9yLW1lc3NhZ2VdJ1xuICApXG4gIGlmIChzc3JFcnJvclRlbXBsYXRlVGFnKSB7XG4gICAgY29uc3QgbWVzc2FnZTogc3RyaW5nID0gc3NyRXJyb3JUZW1wbGF0ZVRhZy5nZXRBdHRyaWJ1dGUoXG4gICAgICAnZGF0YS1uZXh0LWVycm9yLW1lc3NhZ2UnXG4gICAgKSFcbiAgICBjb25zdCBzdGFjayA9IHNzckVycm9yVGVtcGxhdGVUYWcuZ2V0QXR0cmlidXRlKCdkYXRhLW5leHQtZXJyb3Itc3RhY2snKVxuICAgIGNvbnN0IGRpZ2VzdCA9IHNzckVycm9yVGVtcGxhdGVUYWcuZ2V0QXR0cmlidXRlKCdkYXRhLW5leHQtZXJyb3ItZGlnZXN0JylcbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKVxuICAgIGlmIChkaWdlc3QpIHtcbiAgICAgIDsoZXJyb3IgYXMgYW55KS5kaWdlc3QgPSBkaWdlc3RcbiAgICB9XG4gICAgLy8gU2tpcCBOZXh0LmpzIFNTUidkIGludGVybmFsIGVycm9ycyB0aGF0IHdoaWNoIHdpbGwgYmUgaGFuZGxlZCBieSB0aGUgZXJyb3IgYm91bmRhcmllcy5cbiAgICBpZiAoaXNOZXh0Um91dGVyRXJyb3IoZXJyb3IpKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICBlcnJvci5zdGFjayA9IHN0YWNrIHx8ICcnXG4gICAgcmV0dXJuIGVycm9yXG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuXG4vKipcbiAqIE5lZWRzIHRvIGJlIGluIHRoZSBzYW1lIGVycm9yIGJvdW5kYXJ5IGFzIHRoZSBzaGVsbC5cbiAqIElmIGl0IGNvbW1pdHMsIHdlIGtub3cgd2UgcmVjb3ZlcmVkIGZyb20gYW4gU1NSIGVycm9yLlxuICogSWYgaXQgZG9lc24ndCBjb21taXQsIHdlIGVycm9yZWQgYWdhaW4gYW5kIFJlYWN0IHdpbGwgdGFrZSBjYXJlIG9mIGVycm9yIHJlcG9ydGluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFJlcGxheVNzck9ubHlFcnJvcnMoe1xuICBvbkJsb2NraW5nRXJyb3IsXG59OiB7XG4gIG9uQmxvY2tpbmdFcnJvcjogKCkgPT4gdm9pZFxufSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIE5lZWQgdG8gcmVhZCBkdXJpbmcgcmVuZGVyLiBUaGUgYXR0cmlidXRlcyB3aWxsIGJlIGdvbmUgYWZ0ZXIgY29tbWl0LlxuICAgIGNvbnN0IHNzckVycm9yID0gcmVhZFNzckVycm9yKClcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgaWYgKHNzckVycm9yICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE8odmVpbCk6IEluY2x1ZGUgb3JpZ2luYWwgT3duZXIgU3RhY2sgKE5EWC05MDUpXG4gICAgICAgIC8vIFRPRE8odmVpbCk6IE1hcmsgYXMgcmVjb3ZlcmFibGUgZXJyb3JcbiAgICAgICAgLy8gVE9ETyh2ZWlsKTogY29uc29sZS5lcnJvclxuICAgICAgICBoYW5kbGVDbGllbnRFcnJvcihzc3JFcnJvcilcblxuICAgICAgICAvLyBJZiBpdCdzIG1pc3Npbmcgcm9vdCB0YWdzLCB3ZSBjYW4ndCByZWNvdmVyLCBtYWtlIGl0IGJsb2NraW5nLlxuICAgICAgICBpZiAoc3NyRXJyb3IuZGlnZXN0ID09PSBNSVNTSU5HX1JPT1RfVEFHU19FUlJPUikge1xuICAgICAgICAgIG9uQmxvY2tpbmdFcnJvcigpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBbc3NyRXJyb3IsIG9uQmxvY2tpbmdFcnJvcl0pXG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuIl0sIm5hbWVzIjpbIlJlcGxheVNzck9ubHlFcnJvcnMiLCJyZWFkU3NyRXJyb3IiLCJkb2N1bWVudCIsInNzckVycm9yVGVtcGxhdGVUYWciLCJxdWVyeVNlbGVjdG9yIiwibWVzc2FnZSIsImdldEF0dHJpYnV0ZSIsInN0YWNrIiwiZGlnZXN0IiwiZXJyb3IiLCJFcnJvciIsImlzTmV4dFJvdXRlckVycm9yIiwib25CbG9ja2luZ0Vycm9yIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwic3NyRXJyb3IiLCJ1c2VFZmZlY3QiLCJoYW5kbGVDbGllbnRFcnJvciIsIk1JU1NJTkdfUk9PVF9UQUdTX0VSUk9SIl0sIm1hcHBpbmdzIjoiOzs7K0JBdUNnQkEsdUJBQUFBOzs7ZUFBQUE7Ozt1QkF2Q1U7aUNBQ1E7bUNBQ0E7MkJBQ007QUFFeEMsU0FBU0M7SUFDUCxJQUFJLE9BQU9DLGFBQWEsYUFBYTtRQUNuQyxPQUFPO0lBQ1Q7SUFFQSxNQUFNQyxzQkFBc0JELFNBQVNFLGFBQWEsQ0FDaEQ7SUFFRixJQUFJRCxxQkFBcUI7UUFDdkIsTUFBTUUsVUFBa0JGLG9CQUFvQkcsWUFBWSxDQUN0RDtRQUVGLE1BQU1DLFFBQVFKLG9CQUFvQkcsWUFBWSxDQUFDO1FBQy9DLE1BQU1FLFNBQVNMLG9CQUFvQkcsWUFBWSxDQUFDO1FBQ2hELE1BQU1HLFFBQVEsT0FBQSxjQUFrQixDQUFsQixJQUFJQyxNQUFNTCxVQUFWLHFCQUFBO21CQUFBO3dCQUFBOzBCQUFBO1FBQWlCO1FBQy9CLElBQUlHLFFBQVE7O1lBQ1JDLE1BQWNELE1BQU0sR0FBR0E7UUFDM0I7UUFDQSx5RkFBeUY7UUFDekYsSUFBSUcsQ0FBQUEsR0FBQUEsbUJBQUFBLGlCQUFpQixFQUFDRixRQUFRO1lBQzVCLE9BQU87UUFDVDtRQUNBQSxNQUFNRixLQUFLLEdBQUdBLFNBQVM7UUFDdkIsT0FBT0U7SUFDVDtJQUVBLE9BQU87QUFDVDtBQU9PLFNBQVNULG9CQUFvQixLQUluQztJQUptQyxJQUFBLEVBQ2xDWSxlQUFlLEVBR2hCLEdBSm1DO0lBS2xDLElBQUlDLFFBQVFDLEdBQUcsQ0FBQ0MsUUFBUSxLQUFLLFdBQWM7UUFDekMsd0VBQXdFO1FBQ3hFLE1BQU1DLFdBQVdmO1FBQ2pCLHNEQUFzRDtRQUN0RGdCLENBQUFBLEdBQUFBLE9BQUFBLFNBQVMsRUFBQztZQUNSLElBQUlELGFBQWEsTUFBTTtnQkFDckIscURBQXFEO2dCQUNyRCx3Q0FBd0M7Z0JBQ3hDLDRCQUE0QjtnQkFDNUJFLENBQUFBLEdBQUFBLGlCQUFBQSxpQkFBaUIsRUFBQ0Y7Z0JBRWxCLGlFQUFpRTtnQkFDakUsSUFBSUEsU0FBU1IsTUFBTSxLQUFLVyxXQUFBQSx1QkFBdUIsRUFBRTtvQkFDL0NQO2dCQUNGO1lBQ0Y7UUFDRixHQUFHO1lBQUNJO1lBQVVKO1NBQWdCO0lBQ2hDO0lBRUEsT0FBTztBQUNUIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDgxNzIsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvY2xpZW50L2Rldi9ydW50aW1lLWVycm9yLWhhbmRsZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IFJ1bnRpbWVFcnJvckhhbmRsZXIgPSB7XG4gIGhhZFJ1bnRpbWVFcnJvcjogZmFsc2UsXG59XG4iXSwibmFtZXMiOlsiUnVudGltZUVycm9ySGFuZGxlciIsImhhZFJ1bnRpbWVFcnJvciJdLCJtYXBwaW5ncyI6Ijs7OytCQUFhQSx1QkFBQUE7OztlQUFBQTs7O0FBQU4sTUFBTUEsc0JBQXNCO0lBQ2pDQyxpQkFBaUI7QUFDbkIiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogODE5NywgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9uZXh0LWRldnRvb2xzL3VzZXJzcGFjZS9hcHAvc2VnbWVudC1leHBsb3Jlci1ub2RlLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuaW1wb3J0IHR5cGUgeyBSZWFjdE5vZGUgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7XG4gIHVzZVN0YXRlLFxuICBjcmVhdGVDb250ZXh0LFxuICB1c2VDb250ZXh0LFxuICB1c2UsXG4gIHVzZU1lbW8sXG4gIHVzZUNhbGxiYWNrLFxufSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IHVzZUxheW91dEVmZmVjdCB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgZGlzcGF0Y2hlciB9IGZyb20gJ25leHQvZGlzdC9jb21waWxlZC9uZXh0LWRldnRvb2xzJ1xuaW1wb3J0IHsgbm90Rm91bmQgfSBmcm9tICcuLi8uLi8uLi9jbGllbnQvY29tcG9uZW50cy9ub3QtZm91bmQnXG5cbmV4cG9ydCBjb25zdCBTRUdNRU5UX0VYUExPUkVSX1NJTVVMQVRFRF9FUlJPUl9NRVNTQUdFID1cbiAgJ05FWFRfREVWVE9PTFNfU0lNVUxBVEVEX0VSUk9SJ1xuXG5leHBvcnQgdHlwZSBTZWdtZW50Tm9kZVN0YXRlID0ge1xuICB0eXBlOiBzdHJpbmdcbiAgcGFnZVBhdGg6IHN0cmluZ1xuICBib3VuZGFyeVR5cGU6IHN0cmluZyB8IG51bGxcbiAgc2V0Qm91bmRhcnlUeXBlOiAodHlwZTogJ2Vycm9yJyB8ICdub3QtZm91bmQnIHwgJ2xvYWRpbmcnIHwgbnVsbCkgPT4gdm9pZFxufVxuXG5mdW5jdGlvbiBTZWdtZW50VHJpZU5vZGUoe1xuICB0eXBlLFxuICBwYWdlUGF0aCxcbn06IHtcbiAgdHlwZTogc3RyaW5nXG4gIHBhZ2VQYXRoOiBzdHJpbmdcbn0pOiBSZWFjdC5SZWFjdE5vZGUge1xuICBjb25zdCB7IGJvdW5kYXJ5VHlwZSwgc2V0Qm91bmRhcnlUeXBlIH0gPSB1c2VTZWdtZW50U3RhdGUoKVxuICBjb25zdCBub2RlU3RhdGU6IFNlZ21lbnROb2RlU3RhdGUgPSB1c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZSxcbiAgICAgIHBhZ2VQYXRoLFxuICAgICAgYm91bmRhcnlUeXBlLFxuICAgICAgc2V0Qm91bmRhcnlUeXBlLFxuICAgIH1cbiAgfSwgW3R5cGUsIHBhZ2VQYXRoLCBib3VuZGFyeVR5cGUsIHNldEJvdW5kYXJ5VHlwZV0pXG5cbiAgLy8gVXNlIGB1c2VMYXlvdXRFZmZlY3RgIHRvIGVuc3VyZSB0aGUgc3RhdGUgaXMgdXBkYXRlZCBkdXJpbmcgc3VzcGVuc2UuXG4gIC8vIGB1c2VFZmZlY3RgIHdvbid0IHdvcmsgYXMgdGhlIHN0YXRlIGlzIHByZXNlcnZlZCBkdXJpbmcgc3VzcGVuc2UuXG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgZGlzcGF0Y2hlci5zZWdtZW50RXhwbG9yZXJOb2RlQWRkKG5vZGVTdGF0ZSlcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZGlzcGF0Y2hlci5zZWdtZW50RXhwbG9yZXJOb2RlUmVtb3ZlKG5vZGVTdGF0ZSlcbiAgICB9XG4gIH0sIFtub2RlU3RhdGVdKVxuXG4gIHJldHVybiBudWxsXG59XG5cbmZ1bmN0aW9uIE5vdEZvdW5kU2VnbWVudE5vZGUoKTogUmVhY3QuUmVhY3ROb2RlIHtcbiAgbm90Rm91bmQoKVxufVxuXG5mdW5jdGlvbiBFcnJvclNlZ21lbnROb2RlKCk6IFJlYWN0LlJlYWN0Tm9kZSB7XG4gIHRocm93IG5ldyBFcnJvcihTRUdNRU5UX0VYUExPUkVSX1NJTVVMQVRFRF9FUlJPUl9NRVNTQUdFKVxufVxuXG5jb25zdCBmb3JldmVyID0gbmV3IFByb21pc2UoKCkgPT4ge30pXG5mdW5jdGlvbiBMb2FkaW5nU2VnbWVudE5vZGUoKTogUmVhY3QuUmVhY3ROb2RlIHtcbiAgdXNlKGZvcmV2ZXIpXG4gIHJldHVybiBudWxsXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBTZWdtZW50Vmlld1N0YXRlTm9kZSh7IHBhZ2UgfTogeyBwYWdlOiBzdHJpbmcgfSkge1xuICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGRpc3BhdGNoZXIuc2VnbWVudEV4cGxvcmVyVXBkYXRlUm91dGVTdGF0ZShwYWdlKVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBkaXNwYXRjaGVyLnNlZ21lbnRFeHBsb3JlclVwZGF0ZVJvdXRlU3RhdGUoJycpXG4gICAgfVxuICB9LCBbcGFnZV0pXG4gIHJldHVybiBudWxsXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBTZWdtZW50Qm91bmRhcnlUcmlnZ2VyTm9kZSgpIHtcbiAgY29uc3QgeyBib3VuZGFyeVR5cGUgfSA9IHVzZVNlZ21lbnRTdGF0ZSgpXG4gIGxldCBzZWdtZW50Tm9kZTogUmVhY3QuUmVhY3ROb2RlID0gbnVsbFxuICBpZiAoYm91bmRhcnlUeXBlID09PSAnbG9hZGluZycpIHtcbiAgICBzZWdtZW50Tm9kZSA9IDxMb2FkaW5nU2VnbWVudE5vZGUgLz5cbiAgfSBlbHNlIGlmIChib3VuZGFyeVR5cGUgPT09ICdub3QtZm91bmQnKSB7XG4gICAgc2VnbWVudE5vZGUgPSA8Tm90Rm91bmRTZWdtZW50Tm9kZSAvPlxuICB9IGVsc2UgaWYgKGJvdW5kYXJ5VHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIHNlZ21lbnROb2RlID0gPEVycm9yU2VnbWVudE5vZGUgLz5cbiAgfVxuICByZXR1cm4gc2VnbWVudE5vZGVcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFNlZ21lbnRWaWV3Tm9kZSh7XG4gIHR5cGUsXG4gIHBhZ2VQYXRoLFxuICBjaGlsZHJlbixcbn06IHtcbiAgdHlwZTogc3RyaW5nXG4gIHBhZ2VQYXRoOiBzdHJpbmdcbiAgY2hpbGRyZW4/OiBSZWFjdE5vZGVcbn0pOiBSZWFjdC5SZWFjdE5vZGUge1xuICBjb25zdCBzZWdtZW50Tm9kZSA9IChcbiAgICA8U2VnbWVudFRyaWVOb2RlIGtleT17dHlwZX0gdHlwZT17dHlwZX0gcGFnZVBhdGg9e3BhZ2VQYXRofSAvPlxuICApXG5cbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAge3NlZ21lbnROb2RlfVxuICAgICAge2NoaWxkcmVufVxuICAgIDwvPlxuICApXG59XG5cbmNvbnN0IFNlZ21lbnRTdGF0ZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0PHtcbiAgYm91bmRhcnlUeXBlOiAnbm90LWZvdW5kJyB8ICdlcnJvcicgfCAnbG9hZGluZycgfCBudWxsXG4gIHNldEJvdW5kYXJ5VHlwZTogKHR5cGU6ICdub3QtZm91bmQnIHwgJ2Vycm9yJyB8ICdsb2FkaW5nJyB8IG51bGwpID0+IHZvaWRcbn0+KHtcbiAgYm91bmRhcnlUeXBlOiBudWxsLFxuICBzZXRCb3VuZGFyeVR5cGU6ICgpID0+IHt9LFxufSlcblxuZXhwb3J0IGZ1bmN0aW9uIFNlZ21lbnRTdGF0ZVByb3ZpZGVyKHsgY2hpbGRyZW4gfTogeyBjaGlsZHJlbjogUmVhY3ROb2RlIH0pIHtcbiAgY29uc3QgW2JvdW5kYXJ5VHlwZSwgc2V0Qm91bmRhcnlUeXBlXSA9IHVzZVN0YXRlPFxuICAgICdub3QtZm91bmQnIHwgJ2Vycm9yJyB8ICdsb2FkaW5nJyB8IG51bGxcbiAgPihudWxsKVxuXG4gIGNvbnN0IFtlcnJvckJvdW5kYXJ5S2V5LCBzZXRFcnJvckJvdW5kYXJ5S2V5XSA9IHVzZVN0YXRlKDApXG4gIGNvbnN0IHJlbG9hZEJvdW5kYXJ5ID0gdXNlQ2FsbGJhY2soXG4gICAgKCkgPT4gc2V0RXJyb3JCb3VuZGFyeUtleSgocHJldikgPT4gcHJldiArIDEpLFxuICAgIFtdXG4gIClcblxuICBjb25zdCBzZXRCb3VuZGFyeVR5cGVBbmRSZWxvYWQgPSB1c2VDYWxsYmFjayhcbiAgICAodHlwZTogJ25vdC1mb3VuZCcgfCAnZXJyb3InIHwgJ2xvYWRpbmcnIHwgbnVsbCkgPT4ge1xuICAgICAgaWYgKHR5cGUgPT09IG51bGwpIHtcbiAgICAgICAgcmVsb2FkQm91bmRhcnkoKVxuICAgICAgfVxuICAgICAgc2V0Qm91bmRhcnlUeXBlKHR5cGUpXG4gICAgfSxcbiAgICBbcmVsb2FkQm91bmRhcnldXG4gIClcblxuICByZXR1cm4gKFxuICAgIDxTZWdtZW50U3RhdGVDb250ZXh0LlByb3ZpZGVyXG4gICAgICBrZXk9e2Vycm9yQm91bmRhcnlLZXl9XG4gICAgICB2YWx1ZT17e1xuICAgICAgICBib3VuZGFyeVR5cGUsXG4gICAgICAgIHNldEJvdW5kYXJ5VHlwZTogc2V0Qm91bmRhcnlUeXBlQW5kUmVsb2FkLFxuICAgICAgfX1cbiAgICA+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9TZWdtZW50U3RhdGVDb250ZXh0LlByb3ZpZGVyPlxuICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VTZWdtZW50U3RhdGUoKSB7XG4gIHJldHVybiB1c2VDb250ZXh0KFNlZ21lbnRTdGF0ZUNvbnRleHQpXG59XG4iXSwibmFtZXMiOlsiU0VHTUVOVF9FWFBMT1JFUl9TSU1VTEFURURfRVJST1JfTUVTU0FHRSIsIlNlZ21lbnRCb3VuZGFyeVRyaWdnZXJOb2RlIiwiU2VnbWVudFN0YXRlUHJvdmlkZXIiLCJTZWdtZW50Vmlld05vZGUiLCJTZWdtZW50Vmlld1N0YXRlTm9kZSIsInVzZVNlZ21lbnRTdGF0ZSIsIlNlZ21lbnRUcmllTm9kZSIsInR5cGUiLCJwYWdlUGF0aCIsImJvdW5kYXJ5VHlwZSIsInNldEJvdW5kYXJ5VHlwZSIsIm5vZGVTdGF0ZSIsInVzZU1lbW8iLCJ1c2VMYXlvdXRFZmZlY3QiLCJkaXNwYXRjaGVyIiwic2VnbWVudEV4cGxvcmVyTm9kZUFkZCIsInNlZ21lbnRFeHBsb3Jlck5vZGVSZW1vdmUiLCJOb3RGb3VuZFNlZ21lbnROb2RlIiwibm90Rm91bmQiLCJFcnJvclNlZ21lbnROb2RlIiwiRXJyb3IiLCJmb3JldmVyIiwiUHJvbWlzZSIsIkxvYWRpbmdTZWdtZW50Tm9kZSIsInVzZSIsInBhZ2UiLCJzZWdtZW50RXhwbG9yZXJVcGRhdGVSb3V0ZVN0YXRlIiwic2VnbWVudE5vZGUiLCJjaGlsZHJlbiIsIlNlZ21lbnRTdGF0ZUNvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwidXNlU3RhdGUiLCJlcnJvckJvdW5kYXJ5S2V5Iiwic2V0RXJyb3JCb3VuZGFyeUtleSIsInJlbG9hZEJvdW5kYXJ5IiwidXNlQ2FsbGJhY2siLCJwcmV2Iiwic2V0Qm91bmRhcnlUeXBlQW5kUmVsb2FkIiwiUHJvdmlkZXIiLCJ2YWx1ZSIsInVzZUNvbnRleHQiXSwibWFw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QixLQUFPO0FBQzFCO0FBRU8sU0FBU1IscUJBQXFCLEtBQXFDO0lBQXJDLElBQUEsRUFBRTBCLFFBQVEsRUFBMkIsR0FBckM7SUFDbkMsTUFBTSxDQUFDbkIsY0FBY0MsZ0JBQWdCLEdBQUdxQixDQUFBQSxHQUFBQSxPQUFBQSxRQUFRLEVBRTlDO0lBRUYsTUFBTSxDQUFDQyxrQkFBa0JDLG9CQUFvQixHQUFHRixDQUFBQSxHQUFBQSxPQUFBQSxRQUFRLEVBQUM7SUFDekQsTUFBTUcsaUJBQWlCQyxDQUFBQSxHQUFBQSxPQUFBQSxXQUFXLEVBQ2hDLElBQU1GLG9CQUFvQixDQUFDRyxPQUFTQSxPQUFPLElBQzNDLEVBQUU7SUFHSixNQUFNQywyQkFBMkJGLENBQUFBLEdBQUFBLE9BQUFBLFdBQVcsRUFDMUMsQ0FBQzVCO1FBQ0MsSUFBSUEsU0FBUyxNQUFNO1lBQ2pCMkI7UUFDRjtRQUNBeEIsZ0JBQWdCSDtJQUNsQixHQUNBO1FBQUMyQjtLQUFlO0lBR2xCLE9BQUEsV0FBQSxHQUNFLENBQUEsR0FBQSxZQUFBLEdBQUEsRUFBQ0wsb0JBQW9CUyxRQUFRLEVBQUE7UUFFM0JDLE9BQU87WUFDTDlCO1lBQ0FDLGlCQUFpQjJCO1FBQ25CO2tCQUVDVDtPQU5JSTtBQVNYO0FBRU8sU0FBUzNCO0lBQ2QsT0FBT21DLENBQUFBLEdBQUFBLE9BQUFBLFVBQVUsRUFBQ1g7QUFDcEIiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogODM2MCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9uZXh0LWRldnRvb2xzL3VzZXJzcGFjZS9hcHAvYXBwLWRldi1vdmVybGF5LWVycm9yLWJvdW5kYXJ5LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQdXJlQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBkaXNwYXRjaGVyIH0gZnJvbSAnbmV4dC9kaXN0L2NvbXBpbGVkL25leHQtZGV2dG9vbHMnXG5pbXBvcnQgeyBSdW50aW1lRXJyb3JIYW5kbGVyIH0gZnJvbSAnLi4vLi4vLi4vY2xpZW50L2Rldi9ydW50aW1lLWVycm9yLWhhbmRsZXInXG5pbXBvcnQgeyBFcnJvckJvdW5kYXJ5IH0gZnJvbSAnLi4vLi4vLi4vY2xpZW50L2NvbXBvbmVudHMvZXJyb3ItYm91bmRhcnknXG5pbXBvcnQgRGVmYXVsdEdsb2JhbEVycm9yIGZyb20gJy4uLy4uLy4uL2NsaWVudC9jb21wb25lbnRzL2J1aWx0aW4vZ2xvYmFsLWVycm9yJ1xuaW1wb3J0IHR5cGUgeyBHbG9iYWxFcnJvclN0YXRlIH0gZnJvbSAnLi4vLi4vLi4vY2xpZW50L2NvbXBvbmVudHMvYXBwLXJvdXRlci1pbnN0YW5jZSdcbmltcG9ydCB7IFNFR01FTlRfRVhQTE9SRVJfU0lNVUxBVEVEX0VSUk9SX01FU1NBR0UgfSBmcm9tICcuL3NlZ21lbnQtZXhwbG9yZXItbm9kZSdcblxudHlwZSBBcHBEZXZPdmVybGF5RXJyb3JCb3VuZGFyeVByb3BzID0ge1xuICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlXG4gIGdsb2JhbEVycm9yOiBHbG9iYWxFcnJvclN0YXRlXG59XG5cbnR5cGUgQXBwRGV2T3ZlcmxheUVycm9yQm91bmRhcnlTdGF0ZSA9IHtcbiAgcmVhY3RFcnJvcjogdW5rbm93blxufVxuXG5mdW5jdGlvbiBFcnJvcmVkSHRtbCh7XG4gIGdsb2JhbEVycm9yOiBbR2xvYmFsRXJyb3IsIGdsb2JhbEVycm9yU3R5bGVzXSxcbiAgZXJyb3IsXG59OiB7XG4gIGdsb2JhbEVycm9yOiBHbG9iYWxFcnJvclN0YXRlXG4gIGVycm9yOiB1bmtub3duXG59KSB7XG4gIGlmICghZXJyb3IpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGh0bWw+XG4gICAgICAgIDxoZWFkIC8+XG4gICAgICAgIDxib2R5IC8+XG4gICAgICA8L2h0bWw+XG4gICAgKVxuICB9XG4gIHJldHVybiAoXG4gICAgPEVycm9yQm91bmRhcnkgZXJyb3JDb21wb25lbnQ9e0RlZmF1bHRHbG9iYWxFcnJvcn0+XG4gICAgICB7Z2xvYmFsRXJyb3JTdHlsZXN9XG4gICAgICA8R2xvYmFsRXJyb3IgZXJyb3I9e2Vycm9yfSAvPlxuICAgIDwvRXJyb3JCb3VuZGFyeT5cbiAgKVxufVxuXG5leHBvcnQgY2xhc3MgQXBwRGV2T3ZlcmxheUVycm9yQm91bmRhcnkgZXh0ZW5kcyBQdXJlQ29tcG9uZW50PFxuICBBcHBEZXZPdmVybGF5RXJyb3JCb3VuZGFyeVByb3BzLFxuICBBcHBEZXZPdmVybGF5RXJyb3JCb3VuZGFyeVN0YXRlXG4+IHtcbiAgc3RhdGUgPSB7IHJlYWN0RXJyb3I6IG51bGwgfVxuXG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoZXJyb3I6IEVycm9yKSB7XG4gICAgUnVudGltZUVycm9ySGFuZGxlci5oYWRSdW50aW1lRXJyb3IgPSB0cnVlXG5cbiAgICByZXR1cm4ge1xuICAgICAgcmVhY3RFcnJvcjogZXJyb3IsXG4gICAgfVxuICB9XG5cbiAgY29tcG9uZW50RGlkQ2F0Y2goZXJyOiBFcnJvcikge1xuICAgIGlmIChcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmXG4gICAgICBlcnIubWVzc2FnZSA9PT0gU0VHTUVOVF9FWFBMT1JFUl9TSU1VTEFURURfRVJST1JfTUVTU0FHRVxuICAgICkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGRpc3BhdGNoZXIub3BlbkVycm9yT3ZlcmxheSgpXG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBjaGlsZHJlbiwgZ2xvYmFsRXJyb3IgfSA9IHRoaXMucHJvcHNcbiAgICBjb25zdCB7IHJlYWN0RXJyb3IgfSA9IHRoaXMuc3RhdGVcblxuICAgIGNvbnN0IGZhbGxiYWNrID0gKFxuICAgICAgPEVycm9yZWRIdG1sIGdsb2JhbEVycm9yPXtnbG9iYWxFcnJvcn0gZXJyb3I9e3JlYWN0RXJyb3J9IC8+XG4gICAgKVxuXG4gICAgcmV0dXJuIHJlYWN0RXJyb3IgIT09IG51bGwgPyBmYWxsYmFjayA6IGNoaWxkcmVuXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJBcHBEZXZPdmVybGF5RXJyb3JCb3VuZGFyeSIsIkVycm9yZWRIdG1sIiwiZ2xvYmFsRXJyb3IiLCJHbG9iYWxFcnJvciIsImdsb2JhbEVycm9yU3R5bGVzIiwiZXJyb3IiLCJodG1sIiwiaGVhZCIsImJvZHkiLCJFcnJvckJvdW5kYXJ5IiwiZXJyb3JDb21wb25lbnQiLCJEZWZhdWx0R2xvYmFsRXJyb3IiLCJQdXJlQ29tcG9uZW50IiwiZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIiwiUnVudGltZUVycm9ySGFuZGxlciIsImhhZFJ1bnRpbWVFcnJvciIsInJlYWN0RXJyb3IiLCJjb21wb25lbnREaWRDYXRjaCIsImVyciIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsIm1lc3NhZ2UiLCJTRUdNRU5UX0VYUExPUkVSX1NJTVVMQVRFRF9FUlJPUl9NRVNTQUdFIiwiZGlzcGF0Y2hlciIsIm9wZW5FcnJvck92ZXJsYXkiLCJyZW5kZXIiLCJjaGlsZHJlbiIsInByb3BzIiwic3RhdGUiLCJmYWxsYmFjayJdLCJtYXBwaW5ncyI6Ijs7OytCQXdDYUEsOEJBQUFBOzs7ZUFBQUE7Ozs7O3VCQXhDaUI7OEJBQ0g7cUNBQ1M7K0JBQ047c0VBQ0M7cUNBRTBCO0FBV3pELFNBQVNDLFlBQVksS0FNcEI7SUFOb0IsSUFBQSxFQUNuQkMsYUFBYSxDQUFDQyxhQUFhQyxrQkFBa0IsRUFDN0NDLEtBQUssRUFJTixHQU5vQjtJQU9uQixJQUFJLENBQUNBLE9BQU87UUFDVixPQUFBLFdBQUEsR0FDRSxDQUFBLEdBQUEsWUFBQSxJQUFBLEVBQUNDLFFBQUFBOzs4QkFDQyxDQUFBLEdBQUEsWUFBQSxHQUFBLEVBQUNDLFFBQUFBLENBQUFBOzhCQUNELENBQUEsR0FBQSxZQUFBLEdBQUEsRUFBQ0MsUUFBQUEsQ0FBQUE7OztJQUdQO0lBQ0EsT0FBQSxXQUFBLEdBQ0UsQ0FBQSxHQUFBLFlBQUEsSUFBQSxFQUFDQyxlQUFBQSxhQUFhLEVBQUE7UUFBQ0MsZ0JBQWdCQyxhQUFBQSxPQUFrQjs7WUFDOUNQOzBCQUNELENBQUEsR0FBQSxZQUFBLEdBQUEsRUFBQ0QsYUFBQUE7Z0JBQVlFLE9BQU9BOzs7O0FBRzFCO0FBRU8sTUFBTUwsbUNBQW1DWSxPQUFBQSxhQUFhO0lBTTNELE9BQU9DLHlCQUF5QlIsS0FBWSxFQUFFO1FBQzVDUyxxQkFBQUEsbUJBQW1CLENBQUNDLGVBQWUsR0FBRztRQUV0QyxPQUFPO1lBQ0xDLFlBQVlYO1FBQ2Q7SUFDRjtJQUVBWSxrQkFBa0JDLEdBQVUsRUFBRTtRQUM1QixJQUNFQyxRQUFRQyxHQUFHLENBQUNDLFFBQVEsZ0NBQUssaUJBQ3pCSCxJQUFJSSxPQUFPLEtBQUtDLHFCQUFBQSx3Q0FBd0MsRUFDeEQ7WUFDQTtRQUNGO1FBQ0FDLGNBQUFBLFVBQVUsQ0FBQ0MsZ0JBQWdCO0lBQzdCO0lBRUFDLFNBQVM7UUFDUCxNQUFNLEVBQUVDLFFBQVEsRUFBRXpCLFdBQVcsRUFBRSxHQUFHLElBQUksQ0FBQzBCLEtBQUs7UUFDNUMsTUFBTSxFQUFFWixVQUFVLEVBQUUsR0FBRyxJQUFJLENBQUNhLEtBQUs7UUFFakMsTUFBTUMsV0FBQUEsV0FBQUEsR0FDSixDQUFBLEdBQUEsWUFBQSxHQUFBLEVBQUM3QixhQUFBQTtZQUFZQyxhQUFhQTtZQUFhRyxPQUFPVzs7UUFHaEQsT0FBT0EsZUFBZSxPQUFPYyxXQUFXSDtJQUMxQzs7UUFqQ0ssS0FBQSxJQUFBLE9BQUEsSUFBQSxDQUlMRSxLQUFBQSxHQUFRO1lBQUViLFlBQVk7UUFBSzs7QUE4QjdCIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDg0MzgsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvc2hhcmVkL2xpYi9ub3JtYWxpemVkLWFzc2V0LXByZWZpeC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplZEFzc2V0UHJlZml4KGFzc2V0UHJlZml4OiBzdHJpbmcgfCB1bmRlZmluZWQpOiBzdHJpbmcge1xuICAvLyByZW1vdmUgYWxsIGxlYWRpbmcgc2xhc2hlcyBhbmQgdHJhaWxpbmcgc2xhc2hlc1xuICBjb25zdCBlc2NhcGVkQXNzZXRQcmVmaXggPSBhc3NldFByZWZpeD8ucmVwbGFjZSgvXlxcLyt8XFwvKyQvZywgJycpIHx8IGZhbHNlXG5cbiAgLy8gaWYgYW4gYXNzZXRQcmVmaXggd2FzICcvJywgd2UgcmV0dXJuIGVtcHR5IHN0cmluZ1xuICAvLyBiZWNhdXNlIGl0IGNvdWxkIGJlIGFuIHVubmVjZXNzYXJ5IHRyYWlsaW5nIHNsYXNoXG4gIGlmICghZXNjYXBlZEFzc2V0UHJlZml4KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoVVJMLmNhblBhcnNlKGVzY2FwZWRBc3NldFByZWZpeCkpIHtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGVzY2FwZWRBc3NldFByZWZpeCkudG9TdHJpbmcoKVxuICAgIHJldHVybiB1cmwuZW5kc1dpdGgoJy8nKSA/IHVybC5zbGljZSgwLCAtMSkgOiB1cmxcbiAgfVxuXG4gIC8vIGFzc3VtaW5nIGFzc2V0UHJlZml4IGhlcmUgaXMgYSBwYXRobmFtZS1zdHlsZSxcbiAgLy8gcmVzdG9yZSB0aGUgbGVhZGluZyBzbGFzaFxuICByZXR1cm4gYC8ke2VzY2FwZWRBc3NldFByZWZpeH1gXG59XG4iXSwibmFtZXMiOlsibm9ybWFsaXplZEFzc2V0UHJlZml4IiwiYXNzZXRQcmVmaXgiLCJlc2NhcGVkQXNzZXRQcmVmaXgiLCJyZXBsYWNlIiwiVVJMIiwiY2FuUGFyc2UiLCJ1cmwiLCJ0b1N0cmluZyIsImVuZHNXaXRoIiwic2xpY2UiXSwibWFwcGluZ3MiOiI7OzsrQkFBZ0JBLHlCQUFBQTs7O2VBQUFBOzs7QUFBVCxTQUFTQSxzQkFBc0JDLFdBQStCO0lBQ25FLGtEQUFrRDtJQUNsRCxNQUFNQyxxQkFBcUJELENBQUFBLGVBQUFBLE9BQUFBLEtBQUFBLElBQUFBLFlBQWFFLE9BQU8sQ0FBQyxjQUFjLEdBQUEsS0FBTztJQUVyRSxvREFBb0Q7SUFDcEQsb0RBQW9EO0lBQ3BELElBQUksQ0FBQ0Qsb0JBQW9CO1FBQ3ZCLE9BQU87SUFDVDtJQUVBLElBQUlFLElBQUlDLFFBQVEsQ0FBQ0gscUJBQXFCO1FBQ3BDLE1BQU1JLE1BQU0sSUFBSUYsSUFBSUYsb0JBQW9CSyxRQUFRO1FBQ2hELE9BQU9ELElBQUlFLFFBQVEsQ0FBQyxPQUFPRixJQUFJRyxLQUFLLENBQUMsR0FBRyxDQUFDLEtBQUtIO0lBQ2hEO0lBRUEsaURBQWlEO0lBQ2pELDRCQUE0QjtJQUM1QixPQUFRLE1BQUdKO0FBQ2IiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogODQ2OSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvZGV2L2hvdC1yZWxvYWRlci9nZXQtc29ja2V0LXVybC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBub3JtYWxpemVkQXNzZXRQcmVmaXggfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvbGliL25vcm1hbGl6ZWQtYXNzZXQtcHJlZml4J1xuXG5mdW5jdGlvbiBnZXRTb2NrZXRQcm90b2NvbChhc3NldFByZWZpeDogc3RyaW5nKTogc3RyaW5nIHtcbiAgbGV0IHByb3RvY29sID0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sXG5cbiAgdHJ5IHtcbiAgICAvLyBhc3NldFByZWZpeCBpcyBhIHVybFxuICAgIHByb3RvY29sID0gbmV3IFVSTChhc3NldFByZWZpeCkucHJvdG9jb2xcbiAgfSBjYXRjaCB7fVxuXG4gIHJldHVybiBwcm90b2NvbCA9PT0gJ2h0dHA6JyA/ICd3czonIDogJ3dzczonXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTb2NrZXRVcmwoYXNzZXRQcmVmaXg6IHN0cmluZyB8IHVuZGVmaW5lZCk6IHN0cmluZyB7XG4gIGNvbnN0IHByZWZpeCA9IG5vcm1hbGl6ZWRBc3NldFByZWZpeChhc3NldFByZWZpeClcbiAgY29uc3QgcHJvdG9jb2wgPSBnZXRTb2NrZXRQcm90b2NvbChhc3NldFByZWZpeCB8fCAnJylcblxuICBpZiAoVVJMLmNhblBhcnNlKHByZWZpeCkpIHtcbiAgICAvLyBzaW5jZSBub3JtYWxpemVkIGFzc2V0IHByZWZpeCBpcyBlbnN1cmVkIHRvIGJlIGEgVVJMIGZvcm1hdCxcbiAgICAvLyB3ZSBjYW4gc2FmZWx5IHJlcGxhY2UgdGhlIHByb3RvY29sXG4gICAgcmV0dXJuIHByZWZpeC5yZXBsYWNlKC9eaHR0cC8sICd3cycpXG4gIH1cblxuICBjb25zdCB7IGhvc3RuYW1lLCBwb3J0IH0gPSB3aW5kb3cubG9jYXRpb25cbiAgcmV0dXJuIGAke3Byb3RvY29sfS8vJHtob3N0bmFtZX0ke3BvcnQgPyBgOiR7cG9ydH1gIDogJyd9JHtwcmVmaXh9YFxufVxuIl0sIm5hbWVzIjpbImdldFNvY2tldFVybCIsImdldFNvY2tldFByb3RvY29sIiwiYXNzZXRQcmVmaXgiLCJwcm90b2NvbCIsIndpbmRvdyIsImxvY2F0aW9uIiwiVVJMIiwicHJlZml4Iiwibm9ybWFsaXplZEFzc2V0UHJlZml4IiwiY2FuUGFyc2UiLCJyZXBsYWNlIiwiaG9zdG5hbWUiLCJwb3J0Il0sIm1hcHBpbmdzIjoiOzs7K0JBYWdCQSxnQkFBQUE7OztlQUFBQTs7O3VDQWJzQjtBQUV0QyxTQUFTQyxrQkFBa0JDLFdBQW1CO0lBQzVDLElBQUlDLFdBQVdDLE9BQU9DLFFBQVEsQ0FBQ0YsUUFBUTtJQUV2QyxJQUFJO1FBQ0YsdUJBQXVCO1FBQ3ZCQSxXQUFXLElBQUlHLElBQUlKLGFBQWFDLFFBQVE7SUFDMUMsRUFBRSxPQUFBLEdBQU0sQ0FBQztJQUVULE9BQU9BLGFBQWEsVUFBVSxRQUFRO0FBQ3hDO0FBRU8sU0FBU0gsYUFBYUUsV0FBK0I7SUFDMUQsTUFBTUssU0FBU0MsQ0FBQUEsR0FBQUEsdUJBQUFBLHFCQUFxQixFQUFDTjtJQUNyQyxNQUFNQyxXQUFXRixrQkFBa0JDLGVBQWU7SUFFbEQsSUFBSUksSUFBSUcsUUFBUSxDQUFDRixTQUFTO1FBQ3hCLCtEQUErRDtRQUMvRCxxQ0FBcUM7UUFDckMsT0FBT0EsT0FBT0csT0FBTyxDQUFDLFNBQVM7SUFDakM7SUFFQSxNQUFNLEVBQUVDLFFBQVEsRUFBRUMsSUFBSSxFQUFFLEdBQUdSLE9BQU9DLFFBQVE7SUFDMUMsT0FBVUYsV0FBUyxPQUFJUSxXQUFXQyxDQUFBQSxPQUFRLE1BQUdBLE9BQVMsRUFBQyxJQUFJTDtBQUM3RCIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA4NTExLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2NsaWVudC9kZXYvaG90LXJlbG9hZGVyL2FwcC91c2Utd2Vic29ja2V0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VDb250ZXh0LCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgR2xvYmFsTGF5b3V0Um91dGVyQ29udGV4dCB9IGZyb20gJy4uLy4uLy4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHsgZ2V0U29ja2V0VXJsIH0gZnJvbSAnLi4vZ2V0LXNvY2tldC11cmwnXG5pbXBvcnQgdHlwZSB7IFR1cmJvcGFja01zZ1RvQnJvd3NlciB9IGZyb20gJy4uLy4uLy4uLy4uL3NlcnZlci9kZXYvaG90LXJlbG9hZGVyLXR5cGVzJ1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlV2Vic29ja2V0KGFzc2V0UHJlZml4OiBzdHJpbmcpIHtcbiAgY29uc3Qgd2ViU29ja2V0UmVmID0gdXNlUmVmPFdlYlNvY2tldD4odW5kZWZpbmVkKVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHdlYlNvY2tldFJlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCB1cmwgPSBnZXRTb2NrZXRVcmwoYXNzZXRQcmVmaXgpXG5cbiAgICB3ZWJTb2NrZXRSZWYuY3VycmVudCA9IG5ldyB3aW5kb3cuV2ViU29ja2V0KGAke3VybH0vX25leHQvd2VicGFjay1obXJgKVxuICB9LCBbYXNzZXRQcmVmaXhdKVxuXG4gIHJldHVybiB3ZWJTb2NrZXRSZWZcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVNlbmRNZXNzYWdlKHdlYlNvY2tldFJlZjogUmV0dXJuVHlwZTx0eXBlb2YgdXNlV2Vic29ja2V0Pikge1xuICBjb25zdCBzZW5kTWVzc2FnZSA9IHVzZUNhbGxiYWNrKFxuICAgIChkYXRhOiBzdHJpbmcpID0+IHtcbiAgICAgIGNvbnN0IHNvY2tldCA9IHdlYlNvY2tldFJlZi5jdXJyZW50XG4gICAgICBpZiAoIXNvY2tldCB8fCBzb2NrZXQucmVhZHlTdGF0ZSAhPT0gc29ja2V0Lk9QRU4pIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICByZXR1cm4gc29ja2V0LnNlbmQoZGF0YSlcbiAgICB9LFxuICAgIFt3ZWJTb2NrZXRSZWZdXG4gIClcbiAgcmV0dXJuIHNlbmRNZXNzYWdlXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VUdXJib3BhY2soXG4gIHNlbmRNZXNzYWdlOiBSZXR1cm5UeXBlPHR5cGVvZiB1c2VTZW5kTWVzc2FnZT4sXG4gIG9uVXBkYXRlRXJyb3I6IChlcnI6IHVua25vd24pID0+IHZvaWRcbikge1xuICBjb25zdCB0dXJib3BhY2tTdGF0ZSA9IHVzZVJlZjx7XG4gICAgaW5pdDogYm9vbGVhblxuICAgIHF1ZXVlOiBBcnJheTxUdXJib3BhY2tNc2dUb0Jyb3dzZXI+IHwgdW5kZWZpbmVkXG4gICAgY2FsbGJhY2s6ICgobXNnOiBUdXJib3BhY2tNc2dUb0Jyb3dzZXIpID0+IHZvaWQpIHwgdW5kZWZpbmVkXG4gIH0+KHtcbiAgICBpbml0OiBmYWxzZSxcbiAgICAvLyBVbnRpbCB0aGUgZHluYW1pYyBpbXBvcnQgcmVzb2x2ZXMsIHF1ZXVlIGFueSB0dXJib3BhY2sgbWVzc2FnZXMgd2hpY2ggd2lsbCBiZSByZXBsYXllZC5cbiAgICBxdWV1ZTogW10sXG4gICAgY2FsbGJhY2s6IHVuZGVmaW5lZCxcbiAgfSlcblxuICBjb25zdCBwcm9jZXNzVHVyYm9wYWNrTWVzc2FnZSA9IHVzZUNhbGxiYWNrKChtc2c6IFR1cmJvcGFja01zZ1RvQnJvd3NlcikgPT4ge1xuICAgIGNvbnN0IHsgY2FsbGJhY2ssIHF1ZXVlIH0gPSB0dXJib3BhY2tTdGF0ZS5jdXJyZW50XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjayhtc2cpXG4gICAgfSBlbHNlIHtcbiAgICAgIHF1ZXVlIS5wdXNoKG1zZylcbiAgICB9XG4gIH0sIFtdKVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgeyBjdXJyZW50OiBpbml0Q3VycmVudCB9ID0gdHVyYm9wYWNrU3RhdGVcbiAgICAvLyBUT0RPKFdFQi0xNTg5KTogb25seSBpbnN0YWxsIGlmIGBwcm9jZXNzLnR1cmJvcGFja2Agc2V0LlxuICAgIGlmIChpbml0Q3VycmVudC5pbml0KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaW5pdEN1cnJlbnQuaW5pdCA9IHRydWVcblxuICAgIGltcG9ydChcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgcmVxdWlyZXMgXCJtb2R1bGVSZXNvbHV0aW9uXCI6IFwibm9kZTE2XCIgaW4gdHNjb25maWcuanNvbiBhbmQgbm90IC50cyBleHRlbnNpb25cbiAgICAgICdAdmVyY2VsL3R1cmJvcGFjay1lY21hc2NyaXB0LXJ1bnRpbWUvYnJvd3Nlci9kZXYvaG1yLWNsaWVudC9obXItY2xpZW50LnRzJ1xuICAgICkudGhlbigoeyBjb25uZWN0IH0pID0+IHtcbiAgICAgIGNvbnN0IHsgY3VycmVudCB9ID0gdHVyYm9wYWNrU3RhdGVcbiAgICAgIGNvbm5lY3Qoe1xuICAgICAgICBhZGRNZXNzYWdlTGlzdGVuZXIoY2I6IChtc2c6IFR1cmJvcGFja01zZ1RvQnJvd3NlcikgPT4gdm9pZCkge1xuICAgICAgICAgIGN1cnJlbnQuY2FsbGJhY2sgPSBjYlxuXG4gICAgICAgICAgLy8gUmVwbGF5IGFsbCBUdXJib3BhY2sgbWVzc2FnZXMgYmVmb3JlIHdlIHdlcmUgYWJsZSB0byBlc3RhYmxpc2ggdGhlIEhNUiBjbGllbnQuXG4gICAgICAgICAgZm9yIChjb25zdCBtc2cgb2YgY3VycmVudC5xdWV1ZSEpIHtcbiAgICAgICAgICAgIGNiKG1zZylcbiAgICAgICAgICB9XG4gICAgICAgICAgY3VycmVudC5xdWV1ZSA9IHVuZGVmaW5lZFxuICAgICAgICB9LFxuICAgICAgICBzZW5kTWVzc2FnZSxcbiAgICAgICAgb25VcGRhdGVFcnJvcixcbiAgICAgIH0pXG4gICAgfSlcbiAgfSwgW3NlbmRNZXNzYWdlLCBvblVwZGF0ZUVycm9yXSlcblxuICByZXR1cm4gcHJvY2Vzc1R1cmJvcGFja01lc3NhZ2Vcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVdlYnNvY2tldFBpbmcoXG4gIHdlYnNvY2tldFJlZjogUmV0dXJuVHlwZTx0eXBlb2YgdXNlV2Vic29ja2V0PlxuKSB7XG4gIGNvbnN0IHNlbmRNZXNzYWdlID0gdXNlU2VuZE1lc3NhZ2Uod2Vic29ja2V0UmVmKVxuICBjb25zdCB7IHRyZWUgfSA9IHVzZUNvbnRleHQoR2xvYmFsTGF5b3V0Um91dGVyQ29udGV4dClcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIE5ldmVyIHNlbmQgcGluZ3Mgd2hlbiB1c2luZyBUdXJib3BhY2sgYXMgaXQncyBub3QgdXNlZC5cbiAgICAvLyBQaW5ncyB3ZXJlIG9yaWdpbmFsbHkgdXNlZCB0byBrZWVwIHRyYWNrIG9mIGFjdGl2ZSByb3V0ZXMgaW4gb24tZGVtYW5kLWVudHJpZXMgd2l0aCB3ZWJwYWNrLlxuICAgIGlmIChwcm9jZXNzLmVudi5UVVJCT1BBQ0spIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIFRha2VuIGZyb20gb24tZGVtYW5kLWVudHJpZXMtY2xpZW50LmpzXG4gICAgY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBzZW5kTWVzc2FnZShcbiAgICAgICAgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGV2ZW50OiAncGluZycsXG4gICAgICAgICAgdHJlZSxcbiAgICAgICAgICBhcHBEaXJSb3V0ZTogdHJ1ZSxcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICB9LCAyNTAwKVxuICAgIHJldHVybiAoKSA9PiBjbGVhckludGVydmFsKGludGVydmFsKVxuICB9LCBbdHJlZSwgc2VuZE1lc3NhZ2VdKVxufVxuIl0sIm5hbWVzIjpbInVzZVNlbmRNZXNzYWdlIiwidXNlVHVyYm9wYWNrIiwidXNlV2Vic29ja2V0IiwidXNlV2Vic29ja2V0UGluZyIsImFzc2V0UHJlZml4Iiwid2ViU29ja2V0UmVmIiwidXNlUmVmIiwidW5kZWZpbmVkIiwidXNlRWZmZWN0IiwiY3VycmVudCIsInVybCIsImdldFNvY2tldFVybCIsIndpbmRvdyIsIldlYlNvY2tldCIsInNlbmRNZXNzYWdlIiwidXNlQ2FsbGJhY2siLCJkYXRhIiwic29ja2V0IiwicmVhZHlTdGF0ZSIsIk9QRU4iLCJzZW5kIiwib25VcGRhdGVFcnJvciIsInR1cmJvcGFja1N0YXRlIiwiaW5pdCIsInF1ZXVlIiwiY2FsbGJhY2siLCJwcm9jZXNzVHVyYm9wYWNrTWVzc2FnZSIsIm1zZyIsInB1c2giLCJpbml0Q3VycmVudCIsInRoZW4iLCJjb25uZWN0IiwiYWRkTWVzc2FnZUxpc3RlbmVyIiwiY2IiLCJ3ZWJzb2NrZXRSZWYiLCJ0cmVlIiwidXNlQ29udGV4dCIsIkdsb2JhbExheW91dFJvdXRlckNvbnRleHQiLCJwcm9jZXNzIiwiZW52IiwiVFVSQk9QQUNLIiwiaW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsIkpTT04iLCJzdHJpbmdpZnkiLCJldmVudCIsImFwcERpclJvdXRlIiwiY2xlYXJJbnRlcnZhbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztJQXFCZ0JBLGNBQWMsRUFBQTtlQUFkQTs7SUFjQUMsWUFBWSxFQUFBO2VBQVpBOztJQTlCQUMsWUFBWSxFQUFBO2VBQVpBOztJQXNGQUMsZ0JBQWdCLEVBQUE7ZUFBaEJBOzs7dUJBM0YyQzsrQ0FDakI7OEJBQ2I7QUFHdEIsU0FBU0QsYUFBYUUsV0FBbUI7SUFDOUMsTUFBTUMsZUFBZUMsQ0FBQUEsR0FBQUEsT0FBQUEsTUFBTSxFQUFZQztJQUV2Q0MsQ0FBQUEsR0FBQUEsT0FBQUEsU0FBUyxFQUFDO1FBQ1IsSUFBSUgsYUFBYUksT0FBTyxFQUFFO1lBQ3hCO1FBQ0Y7UUFFQSxNQUFNQyxNQUFNQyxDQUFBQSxHQUFBQSxjQUFBQSxZQUFZLEVBQUNQO1FBRXpCQyxhQUFhSSxPQUFPLEdBQUcsSUFBSUcsT0FBT0MsU0FBUyxDQUFFLEtBQUVILE1BQUk7SUFDckQsR0FBRztRQUFDTjtLQUFZO0lBRWhCLE9BQU9DO0FBQ1Q7QUFFTyxTQUFTTCxlQUFlSyxZQUE2QztJQUMxRSxNQUFNUyxjQUFjQyxDQUFBQSxHQUFBQSxPQUFBQSxXQUFXLEVBQzdCLENBQUNDO1FBQ0MsTUFBTUMsU0FBU1osYUFBYUksT0FBTztRQUNuQyxJQUFJLENBQUNRLFVBQVVBLE9BQU9DLFVBQVUsS0FBS0QsT0FBT0UsSUFBSSxFQUFFO1lBQ2hEO1FBQ0Y7UUFDQSxPQUFPRixPQUFPRyxJQUFJLENBQUNKO0lBQ3JCLEdBQ0E7UUFBQ1g7S0FBYTtJQUVoQixPQUFPUztBQUNUO0FBRU8sU0FBU2IsYUFDZGEsV0FBOEMsRUFDOUNPLGFBQXFDO0lBRXJDLE1BQU1DLGlCQUFpQmhCLENBQUFBLEdBQUFBLE9BQUFBLE1BQU0sRUFJMUI7UUFDRGlCLE1BQU07UUFDTiwwRkFBMEY7UUFDMUZDLE9BQU8sRUFBRTtRQUNUQyxVQUFVbEI7SUFDWjtJQUVBLE1BQU1tQiwwQkFBMEJYLENBQUFBLEdBQUFBLE9BQUFBLFdBQVcsRUFBQyxDQUFDWTtRQUMzQyxNQUFNLEVBQUVGLFFBQVEsRUFBRUQsS0FBSyxFQUFFLEdBQUdGLGVBQWViLE9BQU87UUFDbEQsSUFBSWdCLFVBQVU7WUFDWkEsU0FBU0U7UUFDWCxPQUFPO1lBQ0xILE1BQU9JLElBQUksQ0FBQ0Q7UUFDZDtJQUNGLEdBQUcsRUFBRTtJQUVMbkIsQ0FBQUEsR0FBQUEsT0FBQUEsU0FBUyxFQUFDO1FBQ1IsTUFBTSxFQUFFQyxTQUFTb0IsV0FBVyxFQUFFLEdBQUdQO1FBQ2pDLDJEQUEyRDtRQUMzRCxJQUFJTyxZQUFZTixJQUFJLEVBQUU7WUFDcEI7UUFDRjtRQUNBTSxZQUFZTixJQUFJLEdBQUc7UUFFbkIsTUFBTSxDQUNKLGdHQUFnRyxtQ0FFaEdPLElBQUksQ0FBQyxDQUFBO2dCQUFDLEVBQUVDLE9BQU8sRUFBRSxHQUFBO1lBQ2pCLE1BQU0sRUFBRXRCLE9BQU8sRUFBRSxHQUFHYTtZQUNwQlMsUUFBUTtnQkFDTkMsb0JBQW1CQyxFQUF3QztvQkFDekR4QixRQUFRZ0IsUUFBUSxHQUFHUTtvQkFFbkIsaUZBQWlGO29CQUNqRixLQUFLLE1BQU1OLE9BQU9sQixRQUFRZSxLQUFLLENBQUc7d0JBQ2hDUyxHQUFHTjtvQkFDTDtvQkFDQWxCLFFBQVFlLEtBQUssR0FBR2pCO2dCQUNsQjtnQkFDQU87Z0JBQ0FPO1lBQ0Y7UUFDRjtJQUNGLEdBQUc7UUFBQ1A7UUFBYU87S0FBYztJQUUvQixPQUFPSztBQUNUO0FBRU8sU0FBU3ZCLGlCQUNkK0IsWUFBNkM7SUFFN0MsTUFBTXBCLGNBQWNkLGVBQWVrQztJQUNuQyxNQUFNLEVBQUVDLElBQUksRUFBRSxHQUFHQyxDQUFBQSxHQUFBQSxPQUFBQSxVQUFVLEVBQUNDLCtCQUFBQSx5QkFBeUI7SUFFckQ3QixDQUFBQSxHQUFBQSxPQUFBQSxTQUFTLEVBQUM7UUFDUiwwREFBMEQ7UUFDMUQsK0ZBQStGO1FBQy9GLElBQUk4QixRQUFRQyxHQUFHLENBQUNDLFNBQVMsZUFBRTtZQUN6QjtRQUNGOzs7UUFFQSx5Q0FBeUM7UUFDekMsTUFBTUMsV0FBV0MsWUFBWTtJQVUvQixHQUFHO1FBQUNQO1FBQU1yQjtLQUFZO0FBQ3hCIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDg2NDMsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvc2VydmVyL2Rldi9ob3QtcmVsb2FkZXItdHlwZXMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBJbmNvbWluZ01lc3NhZ2UsIFNlcnZlclJlc3BvbnNlIH0gZnJvbSAnaHR0cCdcbmltcG9ydCB0eXBlIHsgVXJsT2JqZWN0IH0gZnJvbSAndXJsJ1xuaW1wb3J0IHR5cGUgeyBEdXBsZXggfSBmcm9tICdzdHJlYW0nXG5pbXBvcnQgdHlwZSB7IHdlYnBhY2sgfSBmcm9tICduZXh0L2Rpc3QvY29tcGlsZWQvd2VicGFjay93ZWJwYWNrJ1xuaW1wb3J0IHR5cGUgZ2V0QmFzZVdlYnBhY2tDb25maWcgZnJvbSAnLi4vLi4vYnVpbGQvd2VicGFjay1jb25maWcnXG5pbXBvcnQgdHlwZSB7IFJvdXRlRGVmaW5pdGlvbiB9IGZyb20gJy4uL3JvdXRlLWRlZmluaXRpb25zL3JvdXRlLWRlZmluaXRpb24nXG5pbXBvcnQgdHlwZSB7IFByb2plY3QsIFVwZGF0ZSBhcyBUdXJib3BhY2tVcGRhdGUgfSBmcm9tICcuLi8uLi9idWlsZC9zd2MvdHlwZXMnXG5pbXBvcnQgdHlwZSB7IFZlcnNpb25JbmZvIH0gZnJvbSAnLi9wYXJzZS12ZXJzaW9uLWluZm8nXG5pbXBvcnQgdHlwZSB7IERlYnVnSW5mbyB9IGZyb20gJy4uLy4uL25leHQtZGV2dG9vbHMvc2hhcmVkL3R5cGVzJ1xuaW1wb3J0IHR5cGUgeyBEZXZJbmRpY2F0b3JTZXJ2ZXJTdGF0ZSB9IGZyb20gJy4vZGV2LWluZGljYXRvci1zZXJ2ZXItc3RhdGUnXG5cbmV4cG9ydCBjb25zdCBlbnVtIEhNUl9BQ1RJT05TX1NFTlRfVE9fQlJPV1NFUiB7XG4gIEFEREVEX1BBR0UgPSAnYWRkZWRQYWdlJyxcbiAgUkVNT1ZFRF9QQUdFID0gJ3JlbW92ZWRQYWdlJyxcbiAgUkVMT0FEX1BBR0UgPSAncmVsb2FkUGFnZScsXG4gIFNFUlZFUl9DT01QT05FTlRfQ0hBTkdFUyA9ICdzZXJ2ZXJDb21wb25lbnRDaGFuZ2VzJyxcbiAgTUlERExFV0FSRV9DSEFOR0VTID0gJ21pZGRsZXdhcmVDaGFuZ2VzJyxcbiAgQ0xJRU5UX0NIQU5HRVMgPSAnY2xpZW50Q2hhbmdlcycsXG4gIFNFUlZFUl9PTkxZX0NIQU5HRVMgPSAnc2VydmVyT25seUNoYW5nZXMnLFxuICBTWU5DID0gJ3N5bmMnLFxuICBCVUlMVCA9ICdidWlsdCcsXG4gIEJVSUxESU5HID0gJ2J1aWxkaW5nJyxcbiAgREVWX1BBR0VTX01BTklGRVNUX1VQREFURSA9ICdkZXZQYWdlc01hbmlmZXN0VXBkYXRlJyxcbiAgVFVSQk9QQUNLX01FU1NBR0UgPSAndHVyYm9wYWNrLW1lc3NhZ2UnLFxuICBTRVJWRVJfRVJST1IgPSAnc2VydmVyRXJyb3InLFxuICBUVVJCT1BBQ0tfQ09OTkVDVEVEID0gJ3R1cmJvcGFjay1jb25uZWN0ZWQnLFxuICBJU1JfTUFOSUZFU1QgPSAnaXNyTWFuaWZlc3QnLFxuICBERVZfSU5ESUNBVE9SID0gJ2RldkluZGljYXRvcicsXG59XG5cbmludGVyZmFjZSBTZXJ2ZXJFcnJvckFjdGlvbiB7XG4gIGFjdGlvbjogSE1SX0FDVElPTlNfU0VOVF9UT19CUk9XU0VSLlNFUlZFUl9FUlJPUlxuICBlcnJvckpTT046IHN0cmluZ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFR1cmJvcGFja01lc3NhZ2VBY3Rpb24ge1xuICBhY3Rpb246IEhNUl9BQ1RJT05TX1NFTlRfVE9fQlJPV1NFUi5UVVJCT1BBQ0tfTUVTU0FHRVxuICBkYXRhOiBUdXJib3BhY2tVcGRhdGUgfCBUdXJib3BhY2tVcGRhdGVbXVxufVxuXG5pbnRlcmZhY2UgQnVpbGRpbmdBY3Rpb24ge1xuICBhY3Rpb246IEhNUl9BQ1RJT05TX1NFTlRfVE9fQlJPV1NFUi5CVUlMRElOR1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbXBpbGF0aW9uRXJyb3Ige1xuICBtb2R1bGVOYW1lPzogc3RyaW5nXG4gIG1lc3NhZ2U6IHN0cmluZ1xuICBkZXRhaWxzPzogc3RyaW5nXG4gIG1vZHVsZVRyYWNlPzogQXJyYXk8eyBtb2R1bGVOYW1lPzogc3RyaW5nIH0+XG4gIHN0YWNrPzogc3RyaW5nXG59XG5leHBvcnQgaW50ZXJmYWNlIFN5bmNBY3Rpb24ge1xuICBhY3Rpb246IEhNUl9BQ1RJT05TX1NFTlRfVE9fQlJPV1NFUi5TWU5DXG4gIGhhc2g6IHN0cmluZ1xuICBlcnJvcnM6IFJlYWRvbmx5QXJyYXk8Q29tcGlsYXRpb25FcnJvcj5cbiAgd2FybmluZ3M6IFJlYWRvbmx5QXJyYXk8Q29tcGlsYXRpb25FcnJvcj5cbiAgdmVyc2lvbkluZm86IFZlcnNpb25JbmZvXG4gIHVwZGF0ZWRNb2R1bGVzPzogUmVhZG9ubHlBcnJheTxzdHJpbmc+XG4gIGRlYnVnPzogRGVidWdJbmZvXG4gIGRldkluZGljYXRvcjogRGV2SW5kaWNhdG9yU2VydmVyU3RhdGVcbn1cbmludGVyZmFjZSBCdWlsdEFjdGlvbiB7XG4gIGFjdGlvbjogSE1SX0FDVElPTlNfU0VOVF9UT19CUk9XU0VSLkJVSUxUXG4gIGhhc2g6IHN0cmluZ1xuICBlcnJvcnM6IFJlYWRvbmx5QXJyYXk8Q29tcGlsYXRpb25FcnJvcj5cbiAgd2FybmluZ3M6IFJlYWRvbmx5QXJyYXk8Q29tcGlsYXRpb25FcnJvcj5cbiAgdXBkYXRlZE1vZHVsZXM/OiBSZWFkb25seUFycmF5PHN0cmluZz5cbn1cblxuaW50ZXJmYWNlIEFkZGVkUGFnZUFjdGlvbiB7XG4gIGFjdGlvbjogSE1SX0FDVElPTlNfU0VOVF9UT19CUk9XU0VSLkFEREVEX1BBR0VcbiAgZGF0YTogW3BhZ2U6IHN0cmluZyB8IG51bGxdXG59XG5cbmludGVyZmFjZSBSZW1vdmVkUGFnZUFjdGlvbiB7XG4gIGFjdGlvbjogSE1SX0FDVElPTlNfU0VOVF9UT19CUk9XU0VSLlJFTU9WRURfUEFHRVxuICBkYXRhOiBbcGFnZTogc3RyaW5nIHwgbnVsbF1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZWxvYWRQYWdlQWN0aW9uIHtcbiAgYWN0aW9uOiBITVJfQUNUSU9OU19TRU5UX1RPX0JST1dTRVIuUkVMT0FEX1BBR0VcbiAgZGF0YTogc3RyaW5nXG59XG5cbmludGVyZmFjZSBTZXJ2ZXJDb21wb25lbnRDaGFuZ2VzQWN0aW9uIHtcbiAgYWN0aW9uOiBITVJfQUNUSU9OU19TRU5UX1RPX0JST1dTRVIuU0VSVkVSX0NPTVBPTkVOVF9DSEFOR0VTXG4gIGhhc2g6IHN0cmluZ1xufVxuXG5pbnRlcmZhY2UgTWlkZGxld2FyZUNoYW5nZXNBY3Rpb24ge1xuICBldmVudDogSE1SX0FDVElPTlNfU0VOVF9UT19CUk9XU0VSLk1JRERMRVdBUkVfQ0hBTkdFU1xufVxuXG5pbnRlcmZhY2UgQ2xpZW50Q2hhbmdlc0FjdGlvbiB7XG4gIGV2ZW50OiBITVJfQUNUSU9OU19TRU5UX1RPX0JST1dTRVIuQ0xJRU5UX0NIQU5HRVNcbn1cblxuaW50ZXJmYWNlIFNlcnZlck9ubHlDaGFuZ2VzQWN0aW9uIHtcbiAgZXZlbnQ6IEhNUl9BQ1RJT05TX1NFTlRfVE9fQlJPV1NFUi5TRVJWRVJfT05MWV9DSEFOR0VTXG4gIHBhZ2VzOiBSZWFkb25seUFycmF5PHN0cmluZz5cbn1cblxuaW50ZXJmYWNlIERldlBhZ2VzTWFuaWZlc3RVcGRhdGVBY3Rpb24ge1xuICBhY3Rpb246IEhNUl9BQ1RJT05TX1NFTlRfVE9fQlJPV1NFUi5ERVZfUEFHRVNfTUFOSUZFU1RfVVBEQVRFXG4gIGRhdGE6IFtcbiAgICB7XG4gICAgICBkZXZQYWdlc01hbmlmZXN0OiB0cnVlXG4gICAgfSxcbiAgXVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFR1cmJvcGFja0Nvbm5lY3RlZEFjdGlvbiB7XG4gIGFjdGlvbjogSE1SX0FDVElPTlNfU0VOVF9UT19CUk9XU0VSLlRVUkJPUEFDS19DT05ORUNURURcbiAgZGF0YTogeyBzZXNzaW9uSWQ6IG51bWJlciB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXBwSXNyTWFuaWZlc3RBY3Rpb24ge1xuICBhY3Rpb246IEhNUl9BQ1RJT05TX1NFTlRfVE9fQlJPV1NFUi5JU1JfTUFOSUZFU1RcbiAgZGF0YTogUmVjb3JkPHN0cmluZywgYm9vbGVhbj5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBEZXZJbmRpY2F0b3JBY3Rpb24ge1xuICBhY3Rpb246IEhNUl9BQ1RJT05TX1NFTlRfVE9fQlJPV1NFUi5ERVZfSU5ESUNBVE9SXG4gIGRldkluZGljYXRvcjogRGV2SW5kaWNhdG9yU2VydmVyU3RhdGVcbn1cblxuZXhwb3J0IHR5cGUgSE1SX0FDVElPTl9UWVBFUyA9XG4gIHwgVHVyYm9wYWNrTWVzc2FnZUFjdGlvblxuICB8IFR1cmJvcGFja0Nvbm5lY3RlZEFjdGlvblxuICB8IEJ1aWxkaW5nQWN0aW9uXG4gIHwgU3luY0FjdGlvblxuICB8IEJ1aWx0QWN0aW9uXG4gIHwgQWRkZWRQYWdlQWN0aW9uXG4gIHwgUmVtb3ZlZFBhZ2VBY3Rpb25cbiAgfCBSZWxvYWRQYWdlQWN0aW9uXG4gIHwgU2VydmVyQ29tcG9uZW50Q2hhbmdlc0FjdGlvblxuICB8IENsaWVudENoYW5nZXNBY3Rpb25cbiAgfCBNaWRkbGV3YXJlQ2hhbmdlc0FjdGlvblxuICB8IFNlcnZlck9ubHlDaGFuZ2VzQWN0aW9uXG4gIHwgRGV2UGFnZXNNYW5pZmVzdFVwZGF0ZUFjdGlvblxuICB8IFNlcnZlckVycm9yQWN0aW9uXG4gIHwgQXBwSXNyTWFuaWZlc3RBY3Rpb25cbiAgfCBEZXZJbmRpY2F0b3JBY3Rpb25cblxuZXhwb3J0IHR5cGUgVHVyYm9wYWNrTXNnVG9Ccm93c2VyID1cbiAgfCB7IHR5cGU6IEhNUl9BQ1RJT05TX1NFTlRfVE9fQlJPV1NFUi5UVVJCT1BBQ0tfTUVTU0FHRTsgZGF0YTogYW55IH1cbiAgfCB7XG4gICAgICB0eXBlOiBITVJfQUNUSU9OU19TRU5UX1RPX0JST1dTRVIuVFVSQk9QQUNLX0NPTk5FQ1RFRFxuICAgICAgZGF0YTogeyBzZXNzaW9uSWQ6IG51bWJlciB9XG4gICAgfVxuXG5leHBvcnQgaW50ZXJmYWNlIE5leHRKc0hvdFJlbG9hZGVySW50ZXJmYWNlIHtcbiAgdHVyYm9wYWNrUHJvamVjdD86IFByb2plY3RcbiAgYWN0aXZlV2VicGFja0NvbmZpZ3M/OiBBcnJheTxBd2FpdGVkPFJldHVyblR5cGU8dHlwZW9mIGdldEJhc2VXZWJwYWNrQ29uZmlnPj4+XG4gIHNlcnZlclN0YXRzOiB3ZWJwYWNrLlN0YXRzIHwgbnVsbFxuICBlZGdlU2VydmVyU3RhdHM6IHdlYnBhY2suU3RhdHMgfCBudWxsXG4gIHJ1bihcbiAgICByZXE6IEluY29taW5nTWVzc2FnZSxcbiAgICByZXM6IFNlcnZlclJlc3BvbnNlLFxuICAgIHBhcnNlZFVybDogVXJsT2JqZWN0XG4gICk6IFByb21pc2U8eyBmaW5pc2hlZD86IHRydWUgfT5cblxuICBzZXRIbXJTZXJ2ZXJFcnJvcihlcnJvcjogRXJyb3IgfCBudWxsKTogdm9pZFxuICBjbGVhckhtclNlcnZlckVycm9yKCk6IHZvaWRcbiAgc3RhcnQoKTogUHJvbWlzZTx2b2lkPlxuICBzZW5kKGFjdGlvbjogSE1SX0FDVElPTl9UWVBFUyk6IHZvaWRcbiAgZ2V0Q29tcGlsYXRpb25FcnJvcnMocGFnZTogc3RyaW5nKTogUHJvbWlzZTxhbnlbXT5cbiAgb25ITVIoXG4gICAgcmVxOiBJbmNvbWluZ01lc3NhZ2UsXG4gICAgX3NvY2tldDogRHVwbGV4LFxuICAgIGhlYWQ6IEJ1ZmZlcixcbiAgICBvblVwZ3JhZGU6IChjbGllbnQ6IHsgc2VuZChkYXRhOiBzdHJpbmcpOiB2b2lkIH0pID0+IHZvaWRcbiAgKTogdm9pZFxuICBpbnZhbGlkYXRlKHtcbiAgICByZWxvYWRBZnRlckludmFsaWRhdGlvbixcbiAgfToge1xuICAgIHJlbG9hZEFmdGVySW52YWxpZGF0aW9uOiBib29sZWFuXG4gIH0pOiBQcm9taXNlPHZvaWQ+IHwgdm9pZFxuICBidWlsZEZhbGxiYWNrRXJyb3IoKTogUHJvbWlzZTx2b2lkPlxuICBlbnN1cmVQYWdlKHtcbiAgICBwYWdlLFxuICAgIGNsaWVudE9ubHksXG4gICAgYXBwUGF0aHMsXG4gICAgZGVmaW5pdGlvbixcbiAgICBpc0FwcCxcbiAgICB1cmwsXG4gIH06IHtcbiAgICBwYWdlOiBzdHJpbmdcbiAgICBjbGllbnRPbmx5OiBib29sZWFuXG4gICAgYXBwUGF0aHM/OiBSZWFkb25seUFycmF5PHN0cmluZz4gfCBudWxsXG4gICAgaXNBcHA/OiBib29sZWFuXG4gICAgZGVmaW5pdGlvbjogUm91dGVEZWZpbml0aW9uIHwgdW5kZWZpbmVkXG4gICAgdXJsPzogc3RyaW5nXG4gIH0pOiBQcm9taXNlPHZvaWQ+XG4gIGNsb3NlKCk6IHZvaWRcbn1cbiJdLCJuYW1lcyI6WyJITVJfQUNUSU9OU19TRU5UX1RPX0JST1dTRVIiXSwibWFwcGluZ3MiOiI7OzsrQkFXa0JBLCtCQUFBQTs7O2VBQUFBOzs7QUFBWCxJQUFXQSw4QkFBQUEsV0FBQUEsR0FBQUEsU0FBQUEsMkJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7OztXQUFBQSIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA4Njc3LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2NsaWVudC9kZXYvcmVwb3J0LWhtci1sYXRlbmN5LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImRlY2xhcmUgZ2xvYmFsIHtcbiAgaW50ZXJmYWNlIFdpbmRvdyB7XG4gICAgX19ORVhUX0hNUl9MQVRFTkNZX0NCOiAoKGxhdGVuY3lNczogbnVtYmVyKSA9PiB2b2lkKSB8IHVuZGVmaW5lZFxuICB9XG59XG5cbi8qKlxuICogTG9ncyBpbmZvcm1hdGlvbiBhYm91dCBhIGNvbXBsZXRlZCBITVIgdG8gdGhlIGNvbnNvbGUsIHRoZSBzZXJ2ZXIgKHZpYSBhXG4gKiBgY2xpZW50LWhtci1sYXRlbmN5YCBldmVudCksIGFuZCB0byBgc2VsZi5fX05FWFRfSE1SX0xBVEVOQ1lfQ0JgIChhIGRlYnVnZ2luZ1xuICogaG9vaykuXG4gKlxuICogQHBhcmFtIGhhc1VwZGF0ZSBTZXQgdGhpcyB0byBgZmFsc2VgIHRvIGF2b2lkIHJlcG9ydGluZyB0aGUgSE1SIGV2ZW50IHZpYSBhXG4gKiAgIGBjbGllbnQtaG1yLWxhdGVuY3lgIGV2ZW50IG9yIHRvIGBzZWxmLl9fTkVYVF9ITVJfTEFURU5DWV9DQmAuIFVzZWQgYnlcbiAqICAgdHVyYm9wYWNrIHdoZW4gd2UgbXVzdCByZXBvcnQgYSBtZXNzYWdlIHRvIHRoZSBicm93c2VyIGNvbnNvbGUgKGJlY2F1c2Ugd2VcbiAqICAgYWxyZWFkeSBsb2dnZWQgYSBcInJlYnVpbGRpbmdcIiBtZXNzYWdlKSwgYnV0IGl0J3Mgbm90IGEgcmVhbCBITVIsIHNvIHdlXG4gKiAgIGRvbid0IHdhbnQgdG8gaW1wYWN0IG91ciB0ZWxlbWV0cnkuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlcG9ydEhtckxhdGVuY3koXG4gIHNlbmRNZXNzYWdlOiAobWVzc2FnZTogc3RyaW5nKSA9PiB2b2lkLFxuICB1cGRhdGVkTW9kdWxlczogUmVhZG9ubHlBcnJheTxzdHJpbmcgfCBudW1iZXI+LFxuICBzdGFydE1zU2luY2VFcG9jaDogbnVtYmVyLFxuICBlbmRNc1NpbmNlRXBvY2g6IG51bWJlcixcbiAgaGFzVXBkYXRlOiBib29sZWFuID0gdHJ1ZVxuKSB7XG4gIGNvbnN0IGxhdGVuY3lNcyA9IGVuZE1zU2luY2VFcG9jaCAtIHN0YXJ0TXNTaW5jZUVwb2NoXG4gIGNvbnNvbGUubG9nKGBbRmFzdCBSZWZyZXNoXSBkb25lIGluICR7bGF0ZW5jeU1zfW1zYClcbiAgaWYgKCFoYXNVcGRhdGUpIHtcbiAgICByZXR1cm5cbiAgfVxuICBzZW5kTWVzc2FnZShcbiAgICBKU09OLnN0cmluZ2lmeSh7XG4gICAgICBldmVudDogJ2NsaWVudC1obXItbGF0ZW5jeScsXG4gICAgICBpZDogd2luZG93Ll9fbmV4dERldkNsaWVudElkLFxuICAgICAgc3RhcnRUaW1lOiBzdGFydE1zU2luY2VFcG9jaCxcbiAgICAgIGVuZFRpbWU6IGVuZE1zU2luY2VFcG9jaCxcbiAgICAgIHBhZ2U6IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgIHVwZGF0ZWRNb2R1bGVzLFxuICAgICAgLy8gV2hldGhlciB0aGUgcGFnZSAodGFiKSB3YXMgaGlkZGVuIGF0IHRoZSB0aW1lIHRoZSBldmVudCBvY2N1cnJlZC5cbiAgICAgIC8vIFRoaXMgY2FuIGltcGFjdCB0aGUgYWNjdXJhY3kgb2YgdGhlIGV2ZW50J3MgdGltaW5nLlxuICAgICAgaXNQYWdlSGlkZGVuOiBkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09ICdoaWRkZW4nLFxuICAgIH0pXG4gIClcbiAgaWYgKHNlbGYuX19ORVhUX0hNUl9MQVRFTkNZX0NCKSB7XG4gICAgc2VsZi5fX05FWFRfSE1SX0xBVEVOQ1lfQ0IobGF0ZW5jeU1zKVxuICB9XG59XG4iXSwibmFtZXMiOlsicmVwb3J0SG1yTGF0ZW5jeSIsInNlbmRNZXNzYWdlIiwidXBkYXRlZE1vZHVsZXMiLCJzdGFydE1zU2luY2VFcG9jaCIsImVuZE1zU2luY2VFcG9jaCIsImhhc1VwZGF0ZSIsImxhdGVuY3lNcyIsImNvbnNvbGUiLCJsb2ciLCJKU09OIiwic3RyaW5naWZ5IiwiZXZlbnQiLCJpZCIsIndpbmRvdyIsIl9fbmV4dERldkNsaWVudElkIiwic3RhcnRUaW1lIiwiZW5kVGltZSIsInBhZ2UiLCJsb2NhdGlvbiIsInBhdGhuYW1lIiwiaXNQYWdlSGlkZGVuIiwiZG9jdW1lbnQiLCJ2aXNpYmlsaXR5U3RhdGUiLCJzZWxmIiwiX19ORVhUX0hNUl9MQVRFTkNZX0NCIl0sIm1hcHBpbmdzIjoiOzs7K0JBTUE7Ozs7Ozs7Ozs7Q0FVQyxHQUNELFdBQUE7OztlQUF3QkE7OztBQUFULFNBQVNBLGlCQUN0QkMsV0FBc0MsRUFDdENDLGNBQThDLEVBQzlDQyxpQkFBeUIsRUFDekJDLGVBQXVCLEVBQ3ZCQyxTQUF5QjtJQUF6QkEsSUFBQUEsY0FBQUEsS0FBQUEsR0FBQUEsWUFBcUI7SUFFckIsTUFBTUMsWUFBWUYsa0JBQWtCRDtJQUNwQ0ksUUFBUUMsR0FBRyxDQUFFLDRCQUF5QkYsWUFBVTtJQUNoRCxJQUFJLENBQUNELFdBQVc7UUFDZDtJQUNGO0lBQ0FKLFlBQ0VRLEtBQUtDLFNBQVMsQ0FBQztRQUNiQyxPQUFPO1FBQ1BDLElBQUlDLE9BQU9DLGlCQUFpQjtRQUM1QkMsV0FBV1o7UUFDWGEsU0FBU1o7UUFDVGEsTUFBTUosT0FBT0ssUUFBUSxDQUFDQyxRQUFRO1FBQzlCakI7UUFDQSxvRUFBb0U7UUFDcEUsc0RBQXNEO1FBQ3REa0IsY0FBY0MsU0FBU0MsZUFBZSxLQUFLO0lBQzdDO0lBRUYsSUFBSUMsS0FBS0MscUJBQXFCLEVBQUU7UUFDOUJELEtBQUtDLHFCQUFxQixDQUFDbEI7SUFDN0I7QUFDRiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA4NzMxLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2NsaWVudC9kZXYvaG90LXJlbG9hZGVyL3R1cmJvcGFjay1ob3QtcmVsb2FkZXItY29tbW9uLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgVHVyYm9wYWNrTWVzc2FnZUFjdGlvbiB9IGZyb20gJy4uLy4uLy4uL3NlcnZlci9kZXYvaG90LXJlbG9hZGVyLXR5cGVzJ1xuaW1wb3J0IHR5cGUgeyBVcGRhdGUgYXMgVHVyYm9wYWNrVXBkYXRlIH0gZnJvbSAnLi4vLi4vLi4vYnVpbGQvc3djL3R5cGVzJ1xuXG5kZWNsYXJlIGdsb2JhbCB7XG4gIGludGVyZmFjZSBXaW5kb3cge1xuICAgIF9fTkVYVF9ITVJfVFVSQk9QQUNLX1JFUE9SVF9OT0lTWV9OT09QX0VWRU5UUzogYm9vbGVhbiB8IHVuZGVmaW5lZFxuICB9XG59XG5cbi8vIEhvdyBsb25nIHRvIHdhaXQgYmVmb3JlIHJlcG9ydGluZyB0aGUgSE1SIHN0YXJ0LCB1c2VkIHRvIHN1cHByZXNzIGlycmVsZXZhbnRcbi8vIGBCVUlMRElOR2AgZXZlbnRzLiBEb2VzIG5vdCBpbXBhY3QgcmVwb3J0ZWQgbGF0ZW5jeS5cbmNvbnN0IFRVUkJPUEFDS19ITVJfU1RBUlRfREVMQVlfTVMgPSAxMDBcblxuaW50ZXJmYWNlIEhtclVwZGF0ZSB7XG4gIGhhc1VwZGF0ZXM6IGJvb2xlYW5cbiAgdXBkYXRlZE1vZHVsZXM6IFNldDxzdHJpbmc+XG4gIHN0YXJ0TXNTaW5jZUVwb2NoOiBudW1iZXJcbiAgZW5kTXNTaW5jZUVwb2NoOiBudW1iZXJcbn1cblxuZXhwb3J0IGNsYXNzIFR1cmJvcGFja0htciB7XG4gICN1cGRhdGVkTW9kdWxlczogU2V0PHN0cmluZz5cbiAgI3N0YXJ0TXNTaW5jZUVwb2NoOiBudW1iZXIgfCB1bmRlZmluZWRcbiAgI2xhc3RVcGRhdGVNc1NpbmNlRXBvY2g6IG51bWJlciB8IHVuZGVmaW5lZFxuICAjZGVmZXJyZWRSZXBvcnRIbXJTdGFydElkOiBSZXR1cm5UeXBlPHR5cGVvZiBzZXRUaW1lb3V0PiB8IHVuZGVmaW5lZFxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuI3VwZGF0ZWRNb2R1bGVzID0gbmV3IFNldCgpXG4gIH1cblxuICAvLyBIQUNLOiBUdXJib3BhY2sgdGVuZHMgdG8gZ2VuZXJhdGUgYSBsb3Qgb2YgaXJyZWxldmFudCBcIkJVSUxESU5HXCIgYWN0aW9ucyxcbiAgLy8gYXMgaXQgcmVwb3J0cyAqYW55KiBjb21waWxhdGlvbiwgaW5jbHVkaW5nIGZ1bGx5IG5vLW9wL2NhY2hlZCBjb21waWxhdGlvbnNcbiAgLy8gYW5kIHRob3NlIHVucmVsYXRlZCB0byBITVIuIEZpeGluZyB0aGlzIHdvdWxkIHJlcXVpcmUgc2lnbmlmaWNhbnRcbiAgLy8gYXJjaGl0ZWN0dXJhbCBjaGFuZ2VzLlxuICAvL1xuICAvLyBXb3JrIGFyb3VuZCB0aGlzIGJ5IGRlZmVycmluZyBhbnkgXCJyZWJ1aWxkaW5nXCIgbWVzc2FnZSBieSAxMDBtcy4gSWYgd2UgZ2V0XG4gIC8vIGEgQlVJTFQgZXZlbnQgd2l0aGluIHRoYXQgdGhyZXNob2xkIGFuZCBub3RoaW5nIGhhcyBjaGFuZ2VkLCBqdXN0IHN1cHByZXNzXG4gIC8vIHRoZSBtZXNzYWdlIGVudGlyZWx5LlxuICAjcnVuRGVmZXJyZWRSZXBvcnRIbXJTdGFydCgpIHtcbiAgICBpZiAodGhpcy4jZGVmZXJyZWRSZXBvcnRIbXJTdGFydElkICE9IG51bGwpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdbRmFzdCBSZWZyZXNoXSByZWJ1aWxkaW5nJylcbiAgICAgIHRoaXMuI2NhbmNlbERlZmVycmVkUmVwb3J0SG1yU3RhcnQoKVxuICAgIH1cbiAgfVxuXG4gICNjYW5jZWxEZWZlcnJlZFJlcG9ydEhtclN0YXJ0KCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLiNkZWZlcnJlZFJlcG9ydEhtclN0YXJ0SWQpXG4gICAgdGhpcy4jZGVmZXJyZWRSZXBvcnRIbXJTdGFydElkID0gdW5kZWZpbmVkXG4gIH1cblxuICBvbkJ1aWxkaW5nKCkge1xuICAgIHRoaXMuI2xhc3RVcGRhdGVNc1NpbmNlRXBvY2ggPSB1bmRlZmluZWRcbiAgICB0aGlzLiNjYW5jZWxEZWZlcnJlZFJlcG9ydEhtclN0YXJ0KClcbiAgICB0aGlzLiNzdGFydE1zU2luY2VFcG9jaCA9IERhdGUubm93KClcblxuICAgIC8vIHJlcG9ydCB0aGUgSE1SIHN0YXJ0IGFmdGVyIGEgc2hvcnQgZGVsYXlcbiAgICB0aGlzLiNkZWZlcnJlZFJlcG9ydEhtclN0YXJ0SWQgPSBzZXRUaW1lb3V0KFxuICAgICAgKCkgPT4gdGhpcy4jcnVuRGVmZXJyZWRSZXBvcnRIbXJTdGFydCgpLFxuICAgICAgLy8gZGVidWdnaW5nIGZlYXR1cmU6IGRvbid0IGRlZmVyL3N1cHByZXNzIG5vaXN5IG5vLW9wIEhNUiB1cGRhdGUgbWVzc2FnZXNcbiAgICAgIHNlbGYuX19ORVhUX0hNUl9UVVJCT1BBQ0tfUkVQT1JUX05PSVNZX05PT1BfRVZFTlRTXG4gICAgICAgID8gMFxuICAgICAgICA6IFRVUkJPUEFDS19ITVJfU1RBUlRfREVMQVlfTVNcbiAgICApXG4gIH1cblxuICAvKiogSGVscGVyIGZvciBvdGhlciBgb25FdmVudGAgbWV0aG9kcy4gKi9cbiAgI29uVXBkYXRlKCkge1xuICAgIHRoaXMuI3J1bkRlZmVycmVkUmVwb3J0SG1yU3RhcnQoKVxuICAgIHRoaXMuI2xhc3RVcGRhdGVNc1NpbmNlRXBvY2ggPSBEYXRlLm5vdygpXG4gIH1cblxuICBvblR1cmJvcGFja01lc3NhZ2UobXNnOiBUdXJib3BhY2tNZXNzYWdlQWN0aW9uKSB7XG4gICAgdGhpcy4jb25VcGRhdGUoKVxuICAgIGNvbnN0IHVwZGF0ZWRNb2R1bGVzID0gZXh0cmFjdE1vZHVsZXNGcm9tVHVyYm9wYWNrTWVzc2FnZShtc2cuZGF0YSlcbiAgICBmb3IgKGNvbnN0IG1vZHVsZSBvZiB1cGRhdGVkTW9kdWxlcykge1xuICAgICAgdGhpcy4jdXBkYXRlZE1vZHVsZXMuYWRkKG1vZHVsZSlcbiAgICB9XG4gIH1cblxuICBvblNlcnZlckNvbXBvbmVudENoYW5nZXMoKSB7XG4gICAgdGhpcy4jb25VcGRhdGUoKVxuICB9XG5cbiAgb25SZWxvYWRQYWdlKCkge1xuICAgIHRoaXMuI29uVXBkYXRlKClcbiAgfVxuXG4gIG9uUGFnZUFkZFJlbW92ZSgpIHtcbiAgICB0aGlzLiNvblVwZGF0ZSgpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMgYG51bGxgIGlmIHRoZSBjYWxsZXIgc2hvdWxkIGlnbm9yZSB0aGUgdXBkYXRlIGVudGlyZWx5LiBSZXR1cm5zIGFuXG4gICAqICAgb2JqZWN0IHdpdGggYGhhc1VwZGF0ZXM6IGZhbHNlYCBpZiB0aGUgY2FsbGVyIHNob3VsZCByZXBvcnQgdGhlIGVuZCBvZlxuICAgKiAgIHRoZSBITVIgaW4gdGhlIGJyb3dzZXIgY29uc29sZSwgYnV0IHRoZSBITVIgd2FzIGEgbm8tb3AuXG4gICAqL1xuICBvbkJ1aWx0KCk6IEhtclVwZGF0ZSB8IG51bGwge1xuICAgIC8vIENoZWNrIHRoYXQgd2UgZ290ICphbnkqIGBUdXJib3BhY2tNZXNzYWdlQWN0aW9uYCwgZXZlbiBpZlxuICAgIC8vIGB1cGRhdGVkTW9kdWxlc2AgaXMgZW1wdHkgKG5vdCBldmVyeXRoaW5nIGdldHMgcmVjb3JkZWQgdGhlcmUpLlxuICAgIC8vXG4gICAgLy8gVGhlcmUncyBhbHNvIGEgY2FzZSB3aGVyZSBgb25CdWlsdGAgZ2V0cyBjYWxsZWQgYmVmb3JlIGBvbkJ1aWxkaW5nYCxcbiAgICAvLyB3aGljaCBjYW4gaGFwcGVuIGR1cmluZyBpbml0aWFsIHBhZ2UgbG9hZC4gSWdub3JlIHRoYXQgdG9vIVxuICAgIGNvbnN0IGhhc1VwZGF0ZXMgPVxuICAgICAgdGhpcy4jbGFzdFVwZGF0ZU1zU2luY2VFcG9jaCAhPSBudWxsICYmIHRoaXMuI3N0YXJ0TXNTaW5jZUVwb2NoICE9IG51bGxcbiAgICBpZiAoIWhhc1VwZGF0ZXMgJiYgdGhpcy4jZGVmZXJyZWRSZXBvcnRIbXJTdGFydElkICE9IG51bGwpIHtcbiAgICAgIC8vIHN1cHByZXNzIHRoZSB1cGRhdGUgZW50aXJlbHlcbiAgICAgIHRoaXMuI2NhbmNlbERlZmVycmVkUmVwb3J0SG1yU3RhcnQoKVxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgdGhpcy4jcnVuRGVmZXJyZWRSZXBvcnRIbXJTdGFydCgpXG5cbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICBoYXNVcGRhdGVzLFxuICAgICAgdXBkYXRlZE1vZHVsZXM6IHRoaXMuI3VwZGF0ZWRNb2R1bGVzLFxuICAgICAgc3RhcnRNc1NpbmNlRXBvY2g6IHRoaXMuI3N0YXJ0TXNTaW5jZUVwb2NoISxcbiAgICAgIGVuZE1zU2luY2VFcG9jaDogdGhpcy4jbGFzdFVwZGF0ZU1zU2luY2VFcG9jaCA/PyBEYXRlLm5vdygpLFxuICAgIH1cbiAgICB0aGlzLiN1cGRhdGVkTW9kdWxlcyA9IG5ldyBTZXQoKVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxufVxuXG5mdW5jdGlvbiBleHRyYWN0TW9kdWxlc0Zyb21UdXJib3BhY2tNZXNzYWdlKFxuICBkYXRhOiBUdXJib3BhY2tVcGRhdGUgfCBUdXJib3BhY2tVcGRhdGVbXVxuKTogU2V0PHN0cmluZz4ge1xuICBjb25zdCB1cGRhdGVkTW9kdWxlczogU2V0PHN0cmluZz4gPSBuZXcgU2V0KClcblxuICBjb25zdCB1cGRhdGVzID0gQXJyYXkuaXNBcnJheShkYXRhKSA/IGRhdGEgOiBbZGF0YV1cbiAgZm9yIChjb25zdCB1cGRhdGUgb2YgdXBkYXRlcykge1xuICAgIC8vIFRPRE8gdGhpcyB3b24ndCBjYXB0dXJlIGNoYW5nZXMgdG8gQ1NTIHNpbmNlIHRoZXkgZG9uJ3QgcmVzdWx0IGluIGEgXCJtZXJnZWRcIiB1cGRhdGVcbiAgICBpZiAoXG4gICAgICB1cGRhdGUudHlwZSAhPT0gJ3BhcnRpYWwnIHx8XG4gICAgICB1cGRhdGUuaW5zdHJ1Y3Rpb24udHlwZSAhPT0gJ0NodW5rTGlzdFVwZGF0ZScgfHxcbiAgICAgIHVwZGF0ZS5pbnN0cnVjdGlvbi5tZXJnZWQgPT09IHVuZGVmaW5lZFxuICAgICkge1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IG1lcmdlZFVwZGF0ZSBvZiB1cGRhdGUuaW5zdHJ1Y3Rpb24ubWVyZ2VkKSB7XG4gICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgT2JqZWN0LmtleXMobWVyZ2VkVXBkYXRlLmVudHJpZXMpKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IC8oLiopXFxzK1xcWy4qLy5leGVjKG5hbWUpXG4gICAgICAgIGlmIChyZXMgPT09IG51bGwpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgJ1tUdXJib3BhY2sgSE1SXSBFeHBlY3RlZCBtb2R1bGUgdG8gbWF0Y2ggcGF0dGVybjogJyArIG5hbWVcbiAgICAgICAgICApXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIHVwZGF0ZWRNb2R1bGVzLmFkZChyZXNbMV0pXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVwZGF0ZWRNb2R1bGVzXG59XG4iXSwibmFtZXMiOlsiVHVyYm9wYWNrSG1yIiwiVFVSQk9QQUNLX0hNUl9TVEFSVF9ERUxBWV9NUyIsIm9uQnVpbGRpbmciLCJ1bmRlZmluZWQiLCJEYXRlIiwibm93Iiwic2V0VGltZW91dCIsInNlbGYiLCJfX05FWFRfSE1SX1RVUkJPUEFDS19SRVBPUlRfTk9JU1lfTk9PUF9FVkVOVFMiLCJvblR1cmJvcGFja01lc3NhZ2UiLCJtc2ciLCJ1cGRhdGVkTW9kdWxlcyIsImV4dHJhY3RNb2R1bGVzRnJvbVR1cmJvcGFja01lc3NhZ2UiLCJkYXRhIiwibW9kdWxlIiwiYWRkIiwib25TZXJ2ZXJDb21wb25lbnRDaGFuZ2VzIiwib25SZWxvYWRQYWdlIiwib25QYWdlQWRkUmVtb3ZlIiwib25CdWlsdCIsImhhc1VwZGF0ZXMiLCJyZXN1bHQiLCJzdGFydE1zU2luY2VFcG9jaCIsImVuZE1zU2luY2VFcG9jaCIsIlNldCIsImNvbnN0cnVjdG9yIiwiY29uc29sZSIsImxvZyIsImNsZWFyVGltZW91dCIsInVwZGF0ZXMiLCJBcnJheSIsImlzQXJyYXkiLCJ1cGRhdGUiLCJ0eXBlIiwiaW5zdHJ1Y3Rpb24iLCJtZXJnZWQiLCJtZXJnZWRVcGRhdGUiLCJuYW1lIiwiT2JqZWN0Iiwia2V5cyIsImVudHJpZXMiLCJyZXMiLCJleGVjIiwiZXJyb3IiXSwibWFwcGluZ3MiOiI7OzsrQkFvQmFBLGdCQUFBQTs7O2VBQUFBOzs7OztBQVhiLCtFQUErRTtBQUMvRSx1REFBdUQ7QUFDdkQsTUFBTUMsK0JBQStCO0lBVW5DLGtCQUFBLFdBQUEsR0FBQSwrQkFBQSxDQUFBLENBQUEsb0JBQ0EscUJBQUEsV0FBQSxHQUFBLCtCQUFBLENBQUEsQ0FBQSx1QkFDQSwwQkFBQSxXQUFBLEdBQUEsK0JBQUEsQ0FBQSxDQUFBLDRCQUNBLDRCQUFBLFdBQUEsR0FBQSwrQkFBQSxDQUFBLENBQUEsOEJBTUEsQUFDQSw0RUFENEUsQ0FDQztBQUM3RSxvRUFBb0U7QUFDcEUseUJBQXlCO0FBQ3pCLEVBQUU7QUFDRiw2RUFBNkU7QUFDN0UsNkVBQTZFO0FBQzdFLHdCQUF3QjtBQUN4Qiw2QkFBQSxXQUFBLEdBQUEsK0JBQUEsQ0FBQSxDQUFBLCtCQU9BLGdDQUFBLFdBQUEsR0FBQSwrQkFBQSxDQUFBLENBQUEsa0NBb0JBLHdDQUF3QyxHQUN4QyxZQUFBLFdBQUEsR0FBQSwrQkFBQSxDQUFBLENBQUE7QUE5Q0ssTUFBTUQ7SUE4QlhFLGFBQWE7UUFDWCxnQ0FBQSxDQUFBLENBQUEsSUFBSSxFQUFDLHdCQUFBLENBQUEsd0JBQUEsR0FBMEJDO1FBQy9CLGdDQUFBLENBQUEsQ0FBQSxJQUFJLEVBQUMsOEJBQUEsQ0FBQSw4QkFBQTtRQUNMLGdDQUFBLENBQUEsQ0FBQSxJQUFJLEVBQUMsbUJBQUEsQ0FBQSxtQkFBQSxHQUFxQkMsS0FBS0MsR0FBRztRQUVsQywyQ0FBMkM7UUFDM0MsZ0NBQUEs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CiAgICB7Im9mZnNldCI6IHsibGluZSI6IDg4ODMsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvbmV4dC1kZXZ0b29scy91c2Vyc3BhY2UvYXBwL2Vycm9ycy91c2UtZm9yd2FyZC1jb25zb2xlLWxvZy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IGlzVGVybWluYWxMb2dnaW5nRW5hYmxlZCwgbG9nUXVldWUgfSBmcm9tICcuLi9mb3J3YXJkLWxvZ3MnXG5pbXBvcnQgdHlwZSB7IHVzZVdlYnNvY2tldCB9IGZyb20gJy4uLy4uLy4uLy4uL2NsaWVudC9kZXYvaG90LXJlbG9hZGVyL2FwcC91c2Utd2Vic29ja2V0J1xuXG5leHBvcnQgY29uc3QgdXNlRm9yd2FyZENvbnNvbGVMb2cgPSAoXG4gIHNvY2tldFJlZjogUmV0dXJuVHlwZTx0eXBlb2YgdXNlV2Vic29ja2V0PlxuKSA9PiB7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFpc1Rlcm1pbmFsTG9nZ2luZ0VuYWJsZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjb25zdCBzb2NrZXQgPSBzb2NrZXRSZWYuY3VycmVudFxuICAgIGlmICghc29ja2V0KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBvbk9wZW4gPSAoKSA9PiB7XG4gICAgICBsb2dRdWV1ZS5vblNvY2tldFJlYWR5KHNvY2tldClcbiAgICB9XG4gICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ29wZW4nLCBvbk9wZW4pXG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ29wZW4nLCBvbk9wZW4pXG4gICAgfVxuICB9LCBbc29ja2V0UmVmXSlcbn1cbiJdLCJuYW1lcyI6WyJ1c2VGb3J3YXJkQ29uc29sZUxvZyIsInNvY2tldFJlZiIsInVzZUVmZmVjdCIsImlzVGVybWluYWxMb2dnaW5nRW5hYmxlZCIsInNvY2tldCIsImN1cnJlbnQiLCJvbk9wZW4iLCJsb2dRdWV1ZSIsIm9uU29ja2V0UmVhZHkiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciJdLCJtYXBwaW5ncyI6Ijs7OytCQUlhQSx3QkFBQUE7OztlQUFBQTs7O3VCQUphOzZCQUN5QjtBQUc1QyxNQUFNQSx1QkFBdUIsQ0FDbENDO0lBRUFDLENBQUFBLEdBQUFBLE9BQUFBLFNBQVMsRUFBQztRQUNSLElBQUksQ0FBQ0MsYUFBQUEsd0JBQXdCLEVBQUU7WUFDN0I7UUFDRjtRQUNBLE1BQU1DLFNBQVNILFVBQVVJLE9BQU87UUFDaEMsSUFBSSxDQUFDRCxRQUFRO1lBQ1g7UUFDRjtRQUVBLE1BQU1FLFNBQVM7WUFDYkMsYUFBQUEsUUFBUSxDQUFDQyxhQUFhLENBQUNKO1FBQ3pCO1FBQ0FBLE9BQU9LLGdCQUFnQixDQUFDLFFBQVFIO1FBRWhDLE9BQU87WUFDTEYsT0FBT00sbUJBQW1CLENBQUMsUUFBUUo7UUFDckM7SUFDRixHQUFHO1FBQUNMO0tBQVU7QUFDaEIiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogODkyNywgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvZGV2L2hvdC1yZWxvYWRlci9hcHAvaG90LXJlbG9hZGVyLWFwcC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiLy8vIDxyZWZlcmVuY2UgdHlwZXM9XCJ3ZWJwYWNrL21vZHVsZS5kLnRzXCIgLz5cblxuaW1wb3J0IHR5cGUgeyBSZWFjdE5vZGUgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IHVzZUVmZmVjdCwgc3RhcnRUcmFuc2l0aW9uLCB1c2VSZWYgfSBmcm9tICdyZWFjdCdcbmltcG9ydCBzdHJpcEFuc2kgZnJvbSAnbmV4dC9kaXN0L2NvbXBpbGVkL3N0cmlwLWFuc2knXG5pbXBvcnQgZm9ybWF0V2VicGFja01lc3NhZ2VzIGZyb20gJy4uLy4uLy4uLy4uL3NoYXJlZC9saWIvZm9ybWF0LXdlYnBhY2stbWVzc2FnZXMnXG5pbXBvcnQgeyB1c2VSb3V0ZXIgfSBmcm9tICcuLi8uLi8uLi9jb21wb25lbnRzL25hdmlnYXRpb24nXG5pbXBvcnQge1xuICBSRUFDVF9SRUZSRVNIX0ZVTExfUkVMT0FELFxuICBSRUFDVF9SRUZSRVNIX0ZVTExfUkVMT0FEX0ZST01fRVJST1IsXG4gIHJlcG9ydEludmFsaWRIbXJNZXNzYWdlLFxufSBmcm9tICcuLi9zaGFyZWQnXG5pbXBvcnQgeyBkaXNwYXRjaGVyIH0gZnJvbSAnbmV4dC9kaXN0L2NvbXBpbGVkL25leHQtZGV2dG9vbHMnXG5pbXBvcnQgeyBSZXBsYXlTc3JPbmx5RXJyb3JzIH0gZnJvbSAnLi4vLi4vLi4vLi4vbmV4dC1kZXZ0b29scy91c2Vyc3BhY2UvYXBwL2Vycm9ycy9yZXBsYXktc3NyLW9ubHktZXJyb3JzJ1xuaW1wb3J0IHsgQXBwRGV2T3ZlcmxheUVycm9yQm91bmRhcnkgfSBmcm9tICcuLi8uLi8uLi8uLi9uZXh0LWRldnRvb2xzL3VzZXJzcGFjZS9hcHAvYXBwLWRldi1vdmVybGF5LWVycm9yLWJvdW5kYXJ5J1xuaW1wb3J0IHsgdXNlRXJyb3JIYW5kbGVyIH0gZnJvbSAnLi4vLi4vLi4vLi4vbmV4dC1kZXZ0b29scy91c2Vyc3BhY2UvYXBwL2Vycm9ycy91c2UtZXJyb3ItaGFuZGxlcidcbmltcG9ydCB7IFJ1bnRpbWVFcnJvckhhbmRsZXIgfSBmcm9tICcuLi8uLi9ydW50aW1lLWVycm9yLWhhbmRsZXInXG5pbXBvcnQge1xuICB1c2VTZW5kTWVzc2FnZSxcbiAgdXNlVHVyYm9wYWNrLFxuICB1c2VXZWJzb2NrZXQsXG4gIHVzZVdlYnNvY2tldFBpbmcsXG59IGZyb20gJy4vdXNlLXdlYnNvY2tldCdcbmltcG9ydCB7IEhNUl9BQ1RJT05TX1NFTlRfVE9fQlJPV1NFUiB9IGZyb20gJy4uLy4uLy4uLy4uL3NlcnZlci9kZXYvaG90LXJlbG9hZGVyLXR5cGVzJ1xuaW1wb3J0IHR5cGUge1xuICBITVJfQUNUSU9OX1RZUEVTLFxuICBUdXJib3BhY2tNc2dUb0Jyb3dzZXIsXG59IGZyb20gJy4uLy4uLy4uLy4uL3NlcnZlci9kZXYvaG90LXJlbG9hZGVyLXR5cGVzJ1xuaW1wb3J0IHsgdXNlVW50cmFja2VkUGF0aG5hbWUgfSBmcm9tICcuLi8uLi8uLi9jb21wb25lbnRzL25hdmlnYXRpb24tdW50cmFja2VkJ1xuaW1wb3J0IHJlcG9ydEhtckxhdGVuY3kgZnJvbSAnLi4vLi4vcmVwb3J0LWhtci1sYXRlbmN5J1xuaW1wb3J0IHsgVHVyYm9wYWNrSG1yIH0gZnJvbSAnLi4vdHVyYm9wYWNrLWhvdC1yZWxvYWRlci1jb21tb24nXG5pbXBvcnQgeyBORVhUX0hNUl9SRUZSRVNIX0hBU0hfQ09PS0lFIH0gZnJvbSAnLi4vLi4vLi4vY29tcG9uZW50cy9hcHAtcm91dGVyLWhlYWRlcnMnXG5pbXBvcnQgdHlwZSB7IEdsb2JhbEVycm9yU3RhdGUgfSBmcm9tICcuLi8uLi8uLi9jb21wb25lbnRzL2FwcC1yb3V0ZXItaW5zdGFuY2UnXG5pbXBvcnQgeyB1c2VGb3J3YXJkQ29uc29sZUxvZyB9IGZyb20gJy4uLy4uLy4uLy4uL25leHQtZGV2dG9vbHMvdXNlcnNwYWNlL2FwcC9lcnJvcnMvdXNlLWZvcndhcmQtY29uc29sZS1sb2cnXG5cbmxldCBtb3N0UmVjZW50Q29tcGlsYXRpb25IYXNoOiBhbnkgPSBudWxsXG5sZXQgX19uZXh0RGV2Q2xpZW50SWQgPSBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiAxMDAgKyBEYXRlLm5vdygpKVxubGV0IHJlbG9hZGluZyA9IGZhbHNlXG5sZXQgd2VicGFja1N0YXJ0TXNTaW5jZUVwb2NoOiBudW1iZXIgfCBudWxsID0gbnVsbFxuY29uc3QgdHVyYm9wYWNrSG1yOiBUdXJib3BhY2tIbXIgfCBudWxsID0gcHJvY2Vzcy5lbnYuVFVSQk9QQUNLXG4gID8gbmV3IFR1cmJvcGFja0htcigpXG4gIDogbnVsbFxuXG5sZXQgcGVuZGluZ0hvdFVwZGF0ZVdlYnBhY2sgPSBQcm9taXNlLnJlc29sdmUoKVxubGV0IHJlc29sdmVQZW5kaW5nSG90VXBkYXRlV2VicGFjazogKCkgPT4gdm9pZCA9ICgpID0+IHt9XG5mdW5jdGlvbiBzZXRQZW5kaW5nSG90VXBkYXRlV2VicGFjaygpIHtcbiAgcGVuZGluZ0hvdFVwZGF0ZVdlYnBhY2sgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHJlc29sdmVQZW5kaW5nSG90VXBkYXRlV2VicGFjayA9ICgpID0+IHtcbiAgICAgIHJlc29sdmUoKVxuICAgIH1cbiAgfSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdhaXRGb3JXZWJwYWNrUnVudGltZUhvdFVwZGF0ZSgpIHtcbiAgcmV0dXJuIHBlbmRpbmdIb3RVcGRhdGVXZWJwYWNrXG59XG5cbi8vIFRoZXJlIGlzIGEgbmV3ZXIgdmVyc2lvbiBvZiB0aGUgY29kZSBhdmFpbGFibGUuXG5mdW5jdGlvbiBoYW5kbGVBdmFpbGFibGVIYXNoKGhhc2g6IHN0cmluZykge1xuICAvLyBVcGRhdGUgbGFzdCBrbm93biBjb21waWxhdGlvbiBoYXNoLlxuICBtb3N0UmVjZW50Q29tcGlsYXRpb25IYXNoID0gaGFzaFxufVxuXG4vKipcbiAqIElzIHRoZXJlIGEgbmV3ZXIgdmVyc2lvbiBvZiB0aGlzIGNvZGUgYXZhaWxhYmxlP1xuICogRm9yIHdlYnBhY2s6IENoZWNrIGlmIHRoZSBoYXNoIGNoYW5nZWQgY29tcGFyZWQgdG8gX193ZWJwYWNrX2hhc2hfX1xuICogRm9yIFR1cmJvcGFjazogQWx3YXlzIHRydWUgYmVjYXVzZSBpdCBkb2Vzbid0IGhhdmUgX193ZWJwYWNrX2hhc2hfX1xuICovXG5mdW5jdGlvbiBpc1VwZGF0ZUF2YWlsYWJsZSgpIHtcbiAgaWYgKHByb2Nlc3MuZW52LlRVUkJPUEFDSykge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKiBnbG9iYWxzIF9fd2VicGFja19oYXNoX18gKi9cbiAgLy8gX193ZWJwYWNrX2hhc2hfXyBpcyB0aGUgaGFzaCBvZiB0aGUgY3VycmVudCBjb21waWxhdGlvbi5cbiAgLy8gSXQncyBhIGdsb2JhbCB2YXJpYWJsZSBpbmplY3RlZCBieSBXZWJwYWNrLlxuICByZXR1cm4gbW9zdFJlY2VudENvbXBpbGF0aW9uSGFzaCAhPT0gX193ZWJwYWNrX2hhc2hfX1xufVxuXG4vLyBXZWJwYWNrIGRpc2FsbG93cyB1cGRhdGVzIGluIG90aGVyIHN0YXRlcy5cbmZ1bmN0aW9uIGNhbkFwcGx5VXBkYXRlcygpIHtcbiAgcmV0dXJuIG1vZHVsZS5ob3Quc3RhdHVzKCkgPT09ICdpZGxlJ1xufVxuZnVuY3Rpb24gYWZ0ZXJBcHBseVVwZGF0ZXMoZm46IGFueSkge1xuICBpZiAoY2FuQXBwbHlVcGRhdGVzKCkpIHtcbiAgICBmbigpXG4gIH0gZWxzZSB7XG4gICAgZnVuY3Rpb24gaGFuZGxlcihzdGF0dXM6IGFueSkge1xuICAgICAgaWYgKHN0YXR1cyA9PT0gJ2lkbGUnKSB7XG4gICAgICAgIG1vZHVsZS5ob3QucmVtb3ZlU3RhdHVzSGFuZGxlcihoYW5kbGVyKVxuICAgICAgICBmbigpXG4gICAgICB9XG4gICAgfVxuICAgIG1vZHVsZS5ob3QuYWRkU3RhdHVzSGFuZGxlcihoYW5kbGVyKVxuICB9XG59XG5cbmZ1bmN0aW9uIHBlcmZvcm1GdWxsUmVsb2FkKGVycjogYW55LCBzZW5kTWVzc2FnZTogYW55KSB7XG4gIGNvbnN0IHN0YWNrVHJhY2UgPVxuICAgIGVyciAmJlxuICAgICgoZXJyLnN0YWNrICYmIGVyci5zdGFjay5zcGxpdCgnXFxuJykuc2xpY2UoMCwgNSkuam9pbignXFxuJykpIHx8XG4gICAgICBlcnIubWVzc2FnZSB8fFxuICAgICAgZXJyICsgJycpXG5cbiAgc2VuZE1lc3NhZ2UoXG4gICAgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgZXZlbnQ6ICdjbGllbnQtZnVsbC1yZWxvYWQnLFxuICAgICAgc3RhY2tUcmFjZSxcbiAgICAgIGhhZFJ1bnRpbWVFcnJvcjogISFSdW50aW1lRXJyb3JIYW5kbGVyLmhhZFJ1bnRpbWVFcnJvcixcbiAgICAgIGRlcGVuZGVuY3lDaGFpbjogZXJyID8gZXJyLmRlcGVuZGVuY3lDaGFpbiA6IHVuZGVmaW5lZCxcbiAgICB9KVxuICApXG5cbiAgaWYgKHJlbG9hZGluZykgcmV0dXJuXG4gIHJlbG9hZGluZyA9IHRydWVcbiAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpXG59XG5cbi8vIEF0dGVtcHQgdG8gdXBkYXRlIGNvZGUgb24gdGhlIGZseSwgZmFsbCBiYWNrIHRvIGEgaGFyZCByZWxvYWQuXG5mdW5jdGlvbiB0cnlBcHBseVVwZGF0ZXNXZWJwYWNrKHNlbmRNZXNzYWdlOiAobWVzc2FnZTogc3RyaW5nKSA9PiB2b2lkKSB7XG4gIGlmICghaXNVcGRhdGVBdmFpbGFibGUoKSB8fCAhY2FuQXBwbHlVcGRhdGVzKCkpIHtcbiAgICByZXNvbHZlUGVuZGluZ0hvdFVwZGF0ZVdlYnBhY2soKVxuICAgIGRpc3BhdGNoZXIub25CdWlsZE9rKClcbiAgICByZXBvcnRIbXJMYXRlbmN5KHNlbmRNZXNzYWdlLCBbXSwgd2VicGFja1N0YXJ0TXNTaW5jZUVwb2NoISwgRGF0ZS5ub3coKSlcbiAgICByZXR1cm5cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUFwcGx5VXBkYXRlcyhcbiAgICBlcnI6IGFueSxcbiAgICB1cGRhdGVkTW9kdWxlczogKHN0cmluZyB8IG51bWJlcilbXSB8IG51bGxcbiAgKSB7XG4gICAgaWYgKGVyciB8fCBSdW50aW1lRXJyb3JIYW5kbGVyLmhhZFJ1bnRpbWVFcnJvciB8fCB1cGRhdGVkTW9kdWxlcyA9PSBudWxsKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihSRUFDVF9SRUZSRVNIX0ZVTExfUkVMT0FEKVxuICAgICAgfSBlbHNlIGlmIChSdW50aW1lRXJyb3JIYW5kbGVyLmhhZFJ1bnRpbWVFcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oUkVBQ1RfUkVGUkVTSF9GVUxMX1JFTE9BRF9GUk9NX0VSUk9SKVxuICAgICAgfVxuICAgICAgcGVyZm9ybUZ1bGxSZWxvYWQoZXJyLCBzZW5kTWVzc2FnZSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGRpc3BhdGNoZXIub25CdWlsZE9rKClcblxuICAgIGlmIChpc1VwZGF0ZUF2YWlsYWJsZSgpKSB7XG4gICAgICAvLyBXaGlsZSB3ZSB3ZXJlIHVwZGF0aW5nLCB0aGVyZSB3YXMgYSBuZXcgdXBkYXRlISBEbyBpdCBhZ2Fpbi5cbiAgICAgIHRyeUFwcGx5VXBkYXRlc1dlYnBhY2soc2VuZE1lc3NhZ2UpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBkaXNwYXRjaGVyLm9uUmVmcmVzaCgpXG4gICAgcmVzb2x2ZVBlbmRpbmdIb3RVcGRhdGVXZWJwYWNrKClcbiAgICByZXBvcnRIbXJMYXRlbmN5KFxuICAgICAgc2VuZE1lc3NhZ2UsXG4gICAgICB1cGRhdGVkTW9kdWxlcyxcbiAgICAgIHdlYnBhY2tTdGFydE1zU2luY2VFcG9jaCEsXG4gICAgICBEYXRlLm5vdygpXG4gICAgKVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9URVNUX01PREUpIHtcbiAgICAgIGFmdGVyQXBwbHlVcGRhdGVzKCgpID0+IHtcbiAgICAgICAgaWYgKHNlbGYuX19ORVhUX0hNUl9DQikge1xuICAgICAgICAgIHNlbGYuX19ORVhUX0hNUl9DQigpXG4gICAgICAgICAgc2VsZi5fX05FWFRfSE1SX0NCID0gbnVsbFxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIC8vIGh0dHBzOi8vd2VicGFjay5qcy5vcmcvYXBpL2hvdC1tb2R1bGUtcmVwbGFjZW1lbnQvI2NoZWNrXG4gIG1vZHVsZS5ob3RcbiAgICAuY2hlY2soLyogYXV0b0FwcGx5ICovIGZhbHNlKVxuICAgIC50aGVuKCh1cGRhdGVkTW9kdWxlczogKHN0cmluZyB8IG51bWJlcilbXSB8IG51bGwpID0+IHtcbiAgICAgIGlmICh1cGRhdGVkTW9kdWxlcyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG5cbiAgICAgIC8vIFdlIHNob3VsZCBhbHdheXMgaGFuZGxlIGFuIHVwZGF0ZSwgZXZlbiBpZiB1cGRhdGVkTW9kdWxlcyBpcyBlbXB0eSAoYnV0XG4gICAgICAvLyBub24tbnVsbCkgZm9yIGFueSByZWFzb24uIFRoYXQncyB3aGF0IHdlYnBhY2sgd291bGQgbm9ybWFsbHkgZG86XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay93ZWJwYWNrL2Jsb2IvM2FhNmI2YmMzYTY0L2xpYi9obXIvSG90TW9kdWxlUmVwbGFjZW1lbnQucnVudGltZS5qcyNMMjk2LUwyOThcbiAgICAgIGRpc3BhdGNoZXIub25CZWZvcmVSZWZyZXNoKClcbiAgICAgIC8vIGh0dHBzOi8vd2VicGFjay5qcy5vcmcvYXBpL2hvdC1tb2R1bGUtcmVwbGFjZW1lbnQvI2FwcGx5XG4gICAgICByZXR1cm4gbW9kdWxlLmhvdC5hcHBseSgpXG4gICAgfSlcbiAgICAudGhlbihcbiAgICAgICh1cGRhdGVkTW9kdWxlczogKHN0cmluZyB8IG51bWJlcilbXSB8IG51bGwpID0+IHtcbiAgICAgICAgaGFuZGxlQXBwbHlVcGRhdGVzKG51bGwsIHVwZGF0ZWRNb2R1bGVzKVxuICAgICAgfSxcbiAgICAgIChlcnI6IGFueSkgPT4ge1xuICAgICAgICBoYW5kbGVBcHBseVVwZGF0ZXMoZXJyLCBudWxsKVxuICAgICAgfVxuICAgIClcbn1cblxuLyoqIEhhbmRsZXMgbWVzc2FnZXMgZnJvbSB0aGUgc2VydmVyIGZvciB0aGUgQXBwIFJvdXRlci4gKi9cbmZ1bmN0aW9uIHByb2Nlc3NNZXNzYWdlKFxuICBvYmo6IEhNUl9BQ1RJT05fVFlQRVMsXG4gIHNlbmRNZXNzYWdlOiAobWVzc2FnZTogc3RyaW5nKSA9PiB2b2lkLFxuICBwcm9jZXNzVHVyYm9wYWNrTWVzc2FnZTogKG1zZzogVHVyYm9wYWNrTXNnVG9Ccm93c2VyKSA9PiB2b2lkLFxuICByb3V0ZXI6IFJldHVyblR5cGU8dHlwZW9mIHVzZVJvdXRlcj4sXG4gIGFwcElzck1hbmlmZXN0UmVmOiBSZXR1cm5UeXBlPHR5cGVvZiB1c2VSZWY+LFxuICBwYXRobmFtZVJlZjogUmV0dXJuVHlwZTx0eXBlb2YgdXNlUmVmPlxuKSB7XG4gIGlmICghKCdhY3Rpb24nIGluIG9iaikpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUVycm9ycyhlcnJvcnM6IFJlYWRvbmx5QXJyYXk8dW5rbm93bj4pIHtcbiAgICAvLyBcIk1hc3NhZ2VcIiB3ZWJwYWNrIG1lc3NhZ2VzLlxuICAgIGNvbnN0IGZvcm1hdHRlZCA9IGZvcm1hdFdlYnBhY2tNZXNzYWdlcyh7XG4gICAgICBlcnJvcnM6IGVycm9ycyxcbiAgICAgIHdhcm5pbmdzOiBbXSxcbiAgICB9KVxuXG4gICAgLy8gT25seSBzaG93IHRoZSBmaXJzdCBlcnJvci5cbiAgICBkaXNwYXRjaGVyLm9uQnVpbGRFcnJvcihmb3JtYXR0ZWQuZXJyb3JzWzBdKVxuXG4gICAgLy8gQWxzbyBsb2cgdGhlbSB0byB0aGUgY29uc29sZS5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZvcm1hdHRlZC5lcnJvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnNvbGUuZXJyb3Ioc3RyaXBBbnNpKGZvcm1hdHRlZC5lcnJvcnNbaV0pKVxuICAgIH1cblxuICAgIC8vIERvIG5vdCBhdHRlbXB0IHRvIHJlbG9hZCBub3cuXG4gICAgLy8gV2Ugd2lsbCByZWxvYWQgb24gbmV4dCBzdWNjZXNzIGluc3RlYWQuXG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9URVNUX01PREUpIHtcbiAgICAgIGlmIChzZWxmLl9fTkVYVF9ITVJfQ0IpIHtcbiAgICAgICAgc2VsZi5fX05FWFRfSE1SX0NCKGZvcm1hdHRlZC5lcnJvcnNbMF0pXG4gICAgICAgIHNlbGYuX19ORVhUX0hNUl9DQiA9IG51bGxcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVIb3RVcGRhdGUoKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52LlRVUkJPUEFDSykge1xuICAgICAgY29uc3QgaG1yVXBkYXRlID0gdHVyYm9wYWNrSG1yIS5vbkJ1aWx0KClcbiAgICAgIGlmIChobXJVcGRhdGUgIT0gbnVsbCkge1xuICAgICAgICByZXBvcnRIbXJMYXRlbmN5KFxuICAgICAgICAgIHNlbmRNZXNzYWdlLFxuICAgICAgICAgIFsuLi5obXJVcGRhdGUudXBkYXRlZE1vZHVsZXNdLFxuICAgICAgICAgIGhtclVwZGF0ZS5zdGFydE1zU2luY2VFcG9jaCxcbiAgICAgICAgICBobXJVcGRhdGUuZW5kTXNTaW5jZUVwb2NoLFxuICAgICAgICAgIC8vIHN1cHByZXNzIHRoZSBgY2xpZW50LWhtci1sYXRlbmN5YCBldmVudCBpZiB0aGUgdXBkYXRlIHdhcyBhIG5vLW9wOlxuICAgICAgICAgIGhtclVwZGF0ZS5oYXNVcGRhdGVzXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIGRpc3BhdGNoZXIub25CdWlsZE9rKClcbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5QXBwbHlVcGRhdGVzV2VicGFjayhzZW5kTWVzc2FnZSlcbiAgICB9XG4gIH1cblxuICBzd2l0Y2ggKG9iai5hY3Rpb24pIHtcbiAgICBjYXNlIEhNUl9BQ1RJT05TX1NFTlRfVE9fQlJPV1NFUi5JU1JfTUFOSUZFU1Q6IHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfREVWX0lORElDQVRPUikge1xuICAgICAgICBpZiAoYXBwSXNyTWFuaWZlc3RSZWYpIHtcbiAgICAgICAgICBhcHBJc3JNYW5pZmVzdFJlZi5jdXJyZW50ID0gb2JqLmRhdGFcblxuICAgICAgICAgIC8vIGhhbmRsZSBpbml0aWFsIHN0YXR1cyBvbiByZWNlaXZpbmcgbWFuaWZlc3RcbiAgICAgICAgICAvLyBuYXZpZ2F0aW9uIGlzIGhhbmRsZWQgaW4gdXNlRWZmZWN0IGZvciBwYXRobmFtZSBjaGFuZ2VzXG4gICAgICAgICAgLy8gYXMgd2UnbGwgcmVjZWl2ZSB0aGUgdXBkYXRlZCBtYW5pZmVzdCBiZWZvcmUgdXNlUGF0aG5hbWVcbiAgICAgICAgICAvLyB0cmlnZ2VycyBmb3IgbmV3IHZhbHVlXG4gICAgICAgICAgaWYgKChwYXRobmFtZVJlZi5jdXJyZW50IGFzIHN0cmluZykgaW4gb2JqLmRhdGEpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoZXIub25TdGF0aWNJbmRpY2F0b3IodHJ1ZSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGlzcGF0Y2hlci5vblN0YXRpY0luZGljYXRvcihmYWxzZSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGNhc2UgSE1SX0FDVElPTlNfU0VOVF9UT19CUk9XU0VSLkJVSUxESU5HOiB7XG4gICAgICBkaXNwYXRjaGVyLmJ1aWxkaW5nSW5kaWNhdG9yU2hvdygpXG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5UVVJCT1BBQ0spIHtcbiAgICAgICAgdHVyYm9wYWNrSG1yIS5vbkJ1aWxkaW5nKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdlYnBhY2tTdGFydE1zU2luY2VFcG9jaCA9IERhdGUubm93KClcbiAgICAgICAgc2V0UGVuZGluZ0hvdFVwZGF0ZVdlYnBhY2soKVxuICAgICAgICBjb25zb2xlLmxvZygnW0Zhc3QgUmVmcmVzaF0gcmVidWlsZGluZycpXG4gICAgICB9XG4gICAgICBicmVha1xuICAgIH1cbiAgICBjYXNlIEhNUl9BQ1RJT05TX1NFTlRfVE9fQlJPV1NFUi5CVUlMVDpcbiAgICBjYXNlIEhNUl9BQ1RJT05TX1NFTlRfVE9fQlJPV1NFUi5TWU5DOiB7XG4gICAgICBkaXNwYXRjaGVyLmJ1aWxkaW5nSW5kaWNhdG9ySGlkZSgpXG5cbiAgICAgIGlmIChvYmouaGFzaCkge1xuICAgICAgICBoYW5kbGVBdmFpbGFibGVIYXNoKG9iai5oYXNoKVxuICAgICAgfVxuXG4gICAgICBjb25zdCB7IGVycm9ycywgd2FybmluZ3MgfSA9IG9ialxuXG4gICAgICAvLyBJcyB1bmRlZmluZWQgd2hlbiBpdCdzIGEgJ2J1aWx0JyBldmVudFxuICAgICAgaWYgKCd2ZXJzaW9uSW5mbycgaW4gb2JqKSBkaXNwYXRjaGVyLm9uVmVyc2lvbkluZm8ob2JqLnZlcnNpb25JbmZvKVxuICAgICAgaWYgKCdkZWJ1ZycgaW4gb2JqICYmIG9iai5kZWJ1ZykgZGlzcGF0Y2hlci5vbkRlYnVnSW5mbyhvYmouZGVidWcpXG4gICAgICBpZiAoJ2RldkluZGljYXRvcicgaW4gb2JqKSBkaXNwYXRjaGVyLm9uRGV2SW5kaWNhdG9yKG9iai5kZXZJbmRpY2F0b3IpXG5cbiAgICAgIGNvbnN0IGhhc0Vycm9ycyA9IEJvb2xlYW4oZXJyb3JzICYmIGVycm9ycy5sZW5ndGgpXG4gICAgICAvLyBDb21waWxhdGlvbiB3aXRoIGVycm9ycyAoZS5nLiBzeW50YXggZXJyb3Igb3IgbWlzc2luZyBtb2R1bGVzKS5cbiAgICAgIGlmIChoYXNFcnJvcnMpIHtcbiAgICAgICAgc2VuZE1lc3NhZ2UoXG4gICAgICAgICAgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgZXZlbnQ6ICdjbGllbnQtZXJyb3InLFxuICAgICAgICAgICAgZXJyb3JDb3VudDogZXJyb3JzLmxlbmd0aCxcbiAgICAgICAgICAgIGNsaWVudElkOiBfX25leHREZXZDbGllbnRJZCxcbiAgICAgICAgICB9KVxuICAgICAgICApXG5cbiAgICAgICAgaGFuZGxlRXJyb3JzKGVycm9ycylcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGhhc1dhcm5pbmdzID0gQm9vbGVhbih3YXJuaW5ncyAmJiB3YXJuaW5ncy5sZW5ndGgpXG4gICAgICBpZiAoaGFzV2FybmluZ3MpIHtcbiAgICAgICAgc2VuZE1lc3NhZ2UoXG4gICAgICAgICAgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgZXZlbnQ6ICdjbGllbnQtd2FybmluZycsXG4gICAgICAgICAgICB3YXJuaW5nQ291bnQ6IHdhcm5pbmdzLmxlbmd0aCxcbiAgICAgICAgICAgIGNsaWVudElkOiBfX25leHREZXZDbGllbnRJZCxcbiAgICAgICAgICB9KVxuICAgICAgICApXG5cbiAgICAgICAgLy8gUHJpbnQgd2FybmluZ3MgdG8gdGhlIGNvbnNvbGUuXG4gICAgICAgIGNvbnN0IGZvcm1hdHRlZE1lc3NhZ2VzID0gZm9ybWF0V2VicGFja01lc3NhZ2VzKHtcbiAgICAgICAgICB3YXJuaW5nczogd2FybmluZ3MsXG4gICAgICAgICAgZXJyb3JzOiBbXSxcbiAgICAgICAgfSlcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZvcm1hdHRlZE1lc3NhZ2VzLndhcm5pbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGkgPT09IDUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgJ1RoZXJlIHdlcmUgbW9yZSB3YXJuaW5ncyBpbiBvdGhlciBmaWxlcy5cXG4nICtcbiAgICAgICAgICAgICAgICAnWW91IGNhbiBmaW5kIGEgY29tcGxldGUgbG9nIGluIHRoZSB0ZXJtaW5hbC4nXG4gICAgICAgICAgICApXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zb2xlLndhcm4oc3RyaXBBbnNpKGZvcm1hdHRlZE1lc3NhZ2VzLndhcm5pbmdzW2ldKSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vIGVhcmx5IHJldHVybiBoZXJlIGFzIHdlIG5lZWQgdG8gYXBwbHkgbW9kdWxlcyBpbiB0aGUgc2FtZSB3YXkgYmV0d2VlbiB3YXJuaW5ncyBvbmx5IGFuZCBjb21waWxlcyB3aXRob3V0IHdhcm5pbmdzXG4gICAgICB9XG5cbiAgICAgIHNlbmRNZXNzYWdlKFxuICAgICAgICBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgZXZlbnQ6ICdjbGllbnQtc3VjY2VzcycsXG4gICAgICAgICAgY2xpZW50SWQ6IF9fbmV4dERldkNsaWVudElkLFxuICAgICAgICB9KVxuICAgICAgKVxuXG4gICAgICBpZiAob2JqLmFjdGlvbiA9PT0gSE1SX0FDVElPTlNfU0VOVF9UT19CUk9XU0VSLkJVSUxUKSB7XG4gICAgICAgIGhhbmRsZUhvdFVwZGF0ZSgpXG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY2FzZSBITVJfQUNUSU9OU19TRU5UX1RPX0JST1dTRVIuVFVSQk9QQUNLX0NPTk5FQ1RFRDoge1xuICAgICAgcHJvY2Vzc1R1cmJvcGFja01lc3NhZ2Uoe1xuICAgICAgICB0eXBlOiBITVJfQUNUSU9OU19TRU5UX1RPX0JST1dTRVIuVFVSQk9QQUNLX0NPTk5FQ1RFRCxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHNlc3Npb25JZDogb2JqLmRhdGEuc2Vzc2lvbklkLFxuICAgICAgICB9LFxuICAgICAgfSlcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGNhc2UgSE1SX0FDVElPTlNfU0VOVF9UT19CUk9XU0VSLlRVUkJPUEFDS19NRVNTQUdFOiB7XG4gICAgICB0dXJib3BhY2tIbXIhLm9uVHVyYm9wYWNrTWVzc2FnZShvYmopXG4gICAgICBkaXNwYXRjaGVyLm9uQmVmb3JlUmVmcmVzaCgpXG4gICAgICBwcm9jZXNzVHVyYm9wYWNrTWVzc2FnZSh7XG4gICAgICAgIHR5cGU6IEhNUl9BQ1RJT05TX1NFTlRfVE9fQlJPV1NFUi5UVVJCT1BBQ0tfTUVTU0FHRSxcbiAgICAgICAgZGF0YTogb2JqLmRhdGEsXG4gICAgICB9KVxuICAgICAgaWYgKFJ1bnRpbWVFcnJvckhhbmRsZXIuaGFkUnVudGltZUVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihSRUFDVF9SRUZSRVNIX0ZVTExfUkVMT0FEX0ZST01fRVJST1IpXG4gICAgICAgIHBlcmZvcm1GdWxsUmVsb2FkKG51bGwsIHNlbmRNZXNzYWdlKVxuICAgICAgfVxuICAgICAgZGlzcGF0Y2hlci5vblJlZnJlc2goKVxuICAgICAgYnJlYWtcbiAgICB9XG4gICAgLy8gVE9ETy1BUFA6IG1ha2Ugc2VydmVyIGNvbXBvbmVudCBjaGFuZ2UgbW9yZSBncmFudWxhclxuICAgIGNhc2UgSE1SX0FDVElPTlNfU0VOVF9UT19CUk9XU0VSLlNFUlZFUl9DT01QT05FTlRfQ0hBTkdFUzoge1xuICAgICAgdHVyYm9wYWNrSG1yPy5vblNlcnZlckNvbXBvbmVudENoYW5nZXMoKVxuICAgICAgc2VuZE1lc3NhZ2UoXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBldmVudDogJ3NlcnZlci1jb21wb25lbnQtcmVsb2FkLXBhZ2UnLFxuICAgICAgICAgIGNsaWVudElkOiBfX25leHREZXZDbGllbnRJZCxcbiAgICAgICAgICBoYXNoOiBvYmouaGFzaCxcbiAgICAgICAgfSlcbiAgICAgIClcblxuICAgICAgLy8gU3RvcmUgdGhlIGxhdGVzdCBoYXNoIGluIGEgc2Vzc2lvbiBjb29raWUgc28gdGhhdCBpdCdzIHNlbnQgYmFjayB0byB0aGVcbiAgICAgIC8vIHNlcnZlciB3aXRoIGFueSBzdWJzZXF1ZW50IHJlcXVlc3RzLlxuICAgICAgZG9jdW1lbnQuY29va2llID0gYCR7TkVYVF9ITVJfUkVGUkVTSF9IQVNIX0NPT0tJRX09JHtvYmouaGFzaH1gXG5cbiAgICAgIGlmIChSdW50aW1lRXJyb3JIYW5kbGVyLmhhZFJ1bnRpbWVFcnJvcikge1xuICAgICAgICBpZiAocmVsb2FkaW5nKSByZXR1cm5cbiAgICAgICAgcmVsb2FkaW5nID0gdHJ1ZVxuICAgICAgICByZXR1cm4gd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpXG4gICAgICB9XG5cbiAgICAgIHN0YXJ0VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICAgIHJvdXRlci5obXJSZWZyZXNoKClcbiAgICAgICAgZGlzcGF0Y2hlci5vblJlZnJlc2goKVxuICAgICAgfSlcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9URVNUX01PREUpIHtcbiAgICAgICAgaWYgKHNlbGYuX19ORVhUX0hNUl9DQikge1xuICAgICAgICAgIHNlbGYuX19ORVhUX0hNUl9DQigpXG4gICAgICAgICAgc2VsZi5fX05FWFRfSE1SX0NCID0gbnVsbFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjYXNlIEhNUl9BQ1RJT05TX1NFTlRfVE9fQlJPV1NFUi5SRUxPQURfUEFHRToge1xuICAgICAgdHVyYm9wYWNrSG1yPy5vblJlbG9hZFBhZ2UoKVxuICAgICAgc2VuZE1lc3NhZ2UoXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBldmVudDogJ2NsaWVudC1yZWxvYWQtcGFnZScsXG4gICAgICAgICAgY2xpZW50SWQ6IF9fbmV4dERldkNsaWVudElkLFxuICAgICAgICB9KVxuICAgICAgKVxuICAgICAgaWYgKHJlbG9hZGluZykgcmV0dXJuXG4gICAgICByZWxvYWRpbmcgPSB0cnVlXG4gICAgICByZXR1cm4gd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpXG4gICAgfVxuICAgIGNhc2UgSE1SX0FDVElPTlNfU0VOVF9UT19CUk9XU0VSLkFEREVEX1BBR0U6XG4gICAgY2FzZSBITVJfQUNUSU9OU19TRU5UX1RPX0JST1dTRVIuUkVNT1ZFRF9QQUdFOiB7XG4gICAgICB0dXJib3BhY2tIbXI/Lm9uUGFnZUFkZFJlbW92ZSgpXG4gICAgICAvLyBUT0RPLUFQUDogcG90ZW50aWFsbHkgb25seSByZWZyZXNoIGlmIHRoZSBjdXJyZW50bHkgdmlld2VkIHBhZ2Ugd2FzIGFkZGVkL3JlbW92ZWQuXG4gICAgICByZXR1cm4gcm91dGVyLmhtclJlZnJlc2goKVxuICAgIH1cbiAgICBjYXNlIEhNUl9BQ1RJT05TX1NFTlRfVE9fQlJPV1NFUi5TRVJWRVJfRVJST1I6IHtcbiAgICAgIGNvbnN0IHsgZXJyb3JKU09OIH0gPSBvYmpcbiAgICAgIGlmIChlcnJvckpTT04pIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlLCBzdGFjayB9ID0gSlNPTi5wYXJzZShlcnJvckpTT04pXG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpXG4gICAgICAgIGVycm9yLnN0YWNrID0gc3RhY2tcbiAgICAgICAgaGFuZGxlRXJyb3JzKFtlcnJvcl0pXG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY2FzZSBITVJfQUNUSU9OU19TRU5UX1RPX0JST1dTRVIuREVWX1BBR0VTX01BTklGRVNUX1VQREFURToge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gSG90UmVsb2FkKHtcbiAgYXNzZXRQcmVmaXgsXG4gIGNoaWxkcmVuLFxuICBnbG9iYWxFcnJvcixcbn06IHtcbiAgYXNzZXRQcmVmaXg6IHN0cmluZ1xuICBjaGlsZHJlbjogUmVhY3ROb2RlXG4gIGdsb2JhbEVycm9yOiBHbG9iYWxFcnJvclN0YXRlXG59KSB7XG4gIHVzZUVycm9ySGFuZGxlcihkaXNwYXRjaGVyLm9uVW5oYW5kbGVkRXJyb3IsIGRpc3BhdGNoZXIub25VbmhhbmRsZWRSZWplY3Rpb24pXG5cbiAgY29uc3Qgd2ViU29ja2V0UmVmID0gdXNlV2Vic29ja2V0KGFzc2V0UHJlZml4KVxuXG4gIHVzZVdlYnNvY2tldFBpbmcod2ViU29ja2V0UmVmKVxuICBjb25zdCBzZW5kTWVzc2FnZSA9IHVzZVNlbmRNZXNzYWdlKHdlYlNvY2tldFJlZilcbiAgdXNlRm9yd2FyZENvbnNvbGVMb2cod2ViU29ja2V0UmVmKVxuICBjb25zdCBwcm9jZXNzVHVyYm9wYWNrTWVzc2FnZSA9IHVzZVR1cmJvcGFjayhzZW5kTWVzc2FnZSwgKGVycikgPT5cbiAgICBwZXJmb3JtRnVsbFJlbG9hZChlcnIsIHNlbmRNZXNzYWdlKVxuICApXG5cbiAgY29uc3Qgcm91dGVyID0gdXNlUm91dGVyKClcblxuICAvLyBXZSBkb24ndCB3YW50IGFjY2VzcyBvZiB0aGUgcGF0aG5hbWUgZm9yIHRoZSBkZXYgdG9vbHMgdG8gdHJpZ2dlciBhIGR5bmFtaWNcbiAgLy8gYWNjZXNzIChhcyB0aGUgZGV2IG92ZXJsYXkgd2lsbCBuZXZlciBiZSBwcmVzZW50IGluIHByb2R1Y3Rpb24pLlxuICBjb25zdCBwYXRobmFtZSA9IHVzZVVudHJhY2tlZFBhdGhuYW1lKClcbiAgY29uc3QgYXBwSXNyTWFuaWZlc3RSZWYgPSB1c2VSZWY8UmVjb3JkPHN0cmluZywgZmFsc2UgfCBudW1iZXI+Pih7fSlcbiAgY29uc3QgcGF0aG5hbWVSZWYgPSB1c2VSZWYocGF0aG5hbWUpXG5cbiAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9ERVZfSU5ESUNBVE9SKSB7XG4gICAgLy8gdGhpcyBjb25kaXRpb25hbCBpcyBvbmx5IGZvciBkZWFkLWNvZGUgZWxpbWluYXRpb24gd2hpY2hcbiAgICAvLyBpc24ndCBhIHJ1bnRpbWUgY29uZGl0aW9uYWwgb25seSBidWlsZC10aW1lIHNvIGlnbm9yZSBob29rcyBydWxlXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIHBhdGhuYW1lUmVmLmN1cnJlbnQgPSBwYXRobmFtZVxuXG4gICAgICBjb25zdCBhcHBJc3JNYW5pZmVzdCA9IGFwcElzck1hbmlmZXN0UmVmLmN1cnJlbnRcblxuICAgICAgaWYgKGFwcElzck1hbmlmZXN0KSB7XG4gICAgICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZSBpbiBhcHBJc3JNYW5pZmVzdCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkaXNwYXRjaGVyLm9uU3RhdGljSW5kaWNhdG9yKHRydWUpXG4gICAgICAgICAgfSBjYXRjaCAocmVhc29uKSB7XG4gICAgICAgICAgICBsZXQgbWVzc2FnZSA9ICcnXG5cbiAgICAgICAgICAgIGlmIChyZWFzb24gaW5zdGFuY2VvZiBET01FeGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgLy8gTW9zdCBsaWtlbHkgYSBTZWN1cml0eUVycm9yLCBiZWNhdXNlIG9mIGFuIHVuYXZhaWxhYmxlIGxvY2FsU3RvcmFnZVxuICAgICAgICAgICAgICBtZXNzYWdlID0gcmVhc29uLnN0YWNrID8/IHJlYXNvbi5tZXNzYWdlXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlYXNvbiBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgIG1lc3NhZ2UgPSAnRXJyb3I6ICcgKyByZWFzb24ubWVzc2FnZSArICdcXG4nICsgKHJlYXNvbi5zdGFjayA/PyAnJylcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1lc3NhZ2UgPSAnVW5leHBlY3RlZCBFeGNlcHRpb246ICcgKyByZWFzb25cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdbSE1SXSAnICsgbWVzc2FnZSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGlzcGF0Y2hlci5vblN0YXRpY0luZGljYXRvcihmYWxzZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFtwYXRobmFtZV0pXG4gIH1cblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHdlYnNvY2tldCA9IHdlYlNvY2tldFJlZi5jdXJyZW50XG4gICAgaWYgKCF3ZWJzb2NrZXQpIHJldHVyblxuXG4gICAgY29uc3QgaGFuZGxlciA9IChldmVudDogTWVzc2FnZUV2ZW50PGFueT4pID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSlcbiAgICAgICAgcHJvY2Vzc01lc3NhZ2UoXG4gICAgICAgICAgb2JqLFxuICAgICAgICAgIHNlbmRNZXNzYWdlLFxuICAgICAgICAgIHByb2Nlc3NUdXJib3BhY2tNZXNzYWdlLFxuICAgICAgICAgIHJvdXRlcixcbiAgICAgICAgICBhcHBJc3JNYW5pZmVzdFJlZixcbiAgICAgICAgICBwYXRobmFtZVJlZlxuICAgICAgICApXG4gICAgICB9IGNhdGNoIChlcnI6IHVua25vd24pIHtcbiAgICAgICAgcmVwb3J0SW52YWxpZEhtck1lc3NhZ2UoZXZlbnQsIGVycilcbiAgICAgIH1cbiAgICB9XG5cbiAgICB3ZWJzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGhhbmRsZXIpXG4gICAgcmV0dXJuICgpID0+IHdlYnNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgaGFuZGxlcilcbiAgfSwgW1xuICAgIHNlbmRNZXNzYWdlLFxuICAgIHJvdXRlcixcbiAgICB3ZWJTb2NrZXRSZWYsXG4gICAgcHJvY2Vzc1R1cmJvcGFja01lc3NhZ2UsXG4gICAgYXBwSXNyTWFuaWZlc3RSZWYsXG4gIF0pXG4gIHJldHVybiAoXG4gICAgPEFwcERldk92ZXJsYXlFcnJvckJvdW5kYXJ5IGdsb2JhbEVycm9yPXtnbG9iYWxFcnJvcn0+XG4gICAgICA8UmVwbGF5U3NyT25seUVycm9ycyBvbkJsb2NraW5nRXJyb3I9e2Rpc3BhdGNoZXIub3BlbkVycm9yT3ZlcmxheX0gLz5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L0FwcERldk92ZXJsYXlFcnJvckJvdW5kYXJ5PlxuICApXG59XG4iXSwibmFtZXMiOlsiSG90UmVsb2FkIiwid2FpdEZvcldlYnBhY2tSdW50aW1lSG90VXBkYXRlIiwibW9zdFJlY2VudENvbXBpbGF0aW9uSGFzaCIsIl9fbmV4dERldkNsaWVudElkIiwiTWF0aCIsInJvdW5kIiwicmFuZG9tIiwiRGF0ZSIsIm5vdyIsInJlbG9hZGluZyIsIndlYnBhY2tTdGFydE1zU2luY2VFcG9jaCIsInR1cmJvcGFja0htciIsInByb2Nlc3MiLCJlbnYiLCJUVVJCT1BBQ0siLCJUdXJib3BhY2tIbXIiLCJwZW5kaW5nSG90VXBkYXRlV2VicGFjayIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVzb2x2ZVBlbmRpbmdIb3RVcGRhdGVXZWJwYWNrIiwic2V0UGVuZGluZ0hvdFVwZGF0ZVdlYnBhY2siLCJoYW5kbGVBdmFpbGFibGVIYXNoIiwiaGFzaCIsImlzVXBkYXRlQXZhaWxhYmxlIiwiX193ZWJwYWNrX2hhc2hfXyIsImNhbkFwcGx5VXBkYXRlcyIsIm1vZHVsZSIsImhvdCIsInN0YXR1cyIsImFmdGVyQXBwbHlVcGRhdGVzIiwiZm4iLCJoYW5kbGVyIiwicmVtb3ZlU3RhdHVzSGFuZGxlciIsImFkZFN0YXR1c0hhbmRsZXIiLCJwZXJmb3JtRnVsbFJlbG9hZCIsImVyciIsInNlbmRNZXNzYWdlIiwic3RhY2tUcmFjZSIsInN0YWNrIiwic3BsaXQiLCJzbGljZSIsImpvaW4iLCJtZXNzYWdlIiwiSlNPTiIsInN0cmluZ2lmeSIsImV2ZW50IiwiaGFkUnVudGltZUVycm9yIiwiUnVudGltZUVycm9ySGFuZGxlciIsImRlcGVuZGVuY3lDaGFpbiIsInVuZGVmaW5lZCIsIndpbmRvdyIsImxvY2F0aW9uIiwicmVsb2FkIiwidHJ5QXBwbHlVcGRhdGVzV2VicGFjayIsImRpc3BhdGNoZXIiLCJvbkJ1aWxkT2siLCJyZXBvcnRIbXJMYXRlbmN5IiwiaGFuZGxlQXBwbHlVcGRhdGVzIiwidXBkYXRlZE1vZHVsZXMiLCJjb25zb2xlIiwid2FybiIsIlJFQUNUX1JFRlJFU0hfRlVMTF9SRUxPQUQiLCJSRUFDVF9SRUZSRVNIX0ZVTExfUkVMT0FEX0ZST01fRVJST1IiLCJvblJlZnJlc2giLCJfX05FWFRfVEVTVF9NT0RFIiwic2VsZiIsIl9fTkVYVF9ITVJfQ0IiLCJjaGVjayIsInRoZW4iLCJvbkJlZm9yZVJlZnJlc2giLCJhcHBseSIsInByb2Nlc3NNZXNzYWdlIiwib2JqIiwicHJvY2Vzc1R1cmJvcGFja01lc3NhZ2UiLCJyb3V0ZXIiLCJhcHBJc3JNYW5pZmVzdFJlZiIsInBhdGhuYW1lUmVmIiwiaGFuZGxlRXJyb3JzIiwiZXJyb3JzIiwiZm9ybWF0dGVkIiwiZm9ybWF0V2VicGFja01lc3NhZ2VzIiwid2FybmluZ3MiLCJvbkJ1aWxkRXJyb3IiLCJpIiwibGVuZ3RoIiwiZXJyb3IiLCJzdHJpcEFuc2kiLCJoYW5kbGVIb3RVcGRhdGUiLCJobXJVcGRhdGUiLCJvbkJ1aWx0Iiwic3RhcnRNc1NpbmNlRXBvY2giLCJlbmRNc1NpbmNlRXBvY2giLCJoYXNVcGRhdGVzIiwiYWN0aW9uIiwiSE1SX0FDVElPTlNfU0VOVF9UT19CUk9XU0VSIiwiSVNSX01BTklGRVNUIiwiX19ORVhUX0RFVl9JTkRJQ0FUT1IiLCJjdXJyZW50IiwiZGF0YSIsIm9uU3RhdGljSW5kaWNhdG9yIiwiQlVJTERJTkciLCJidWlsZGluZ0luZGljYXRvclNob3ciLCJvbkJ1aWxkaW5nIiwibG9nIiwiQlVJTFQiLCJTWU5DIiwiYnVpbGRpbmdJbmRpY2F0b3JIaWRlIiwib25WZXJzaW9uSW5mbyIsInZlcnNpb25JbmZvIiwiZGVidWciLCJvbkRlYnVnSW5mbyIsIm9uRGV2SW5kaWNhdG9yIiwiZGV2SW5kaWNhdG9yIiwiaGFzRXJyb3JzIiwiQm9vbGVhbiIsImVycm9yQ291bnQiLCJjbGllbnRJZCIsImhhc1dhcm5pbmdzIiwid2FybmluZ0NvdW50IiwiZm9ybWF0dGVkTWVzc2FnZXMiLCJUVVJCT1BBQ0tfQ09OTkVDVEVEIiwidHlwZSIsInNlc3Npb25JZCIsIlRVUkJPUEFDS19NRVNTQUdFIiwib25UdXJib3BhY2tNZXNzYWdlIiwiU0VSVkVSX0NPTVBPTkVOVF9DSEFOR0VTIiwib25TZXJ2ZXJDb21wb25lbnRDaGFuZ2VzIiwiZG9jdW1lbnQiLCJjb29raWUiLCJORVhUX0hNUl9SRUZSRVNIX0hBU0hfQ09PS0lFIiwic3RhcnRUcmFuc2l0aW9uIiwiaG1yUmVmcmVzaCIsIlJFTE9BRF9QQUdFIiwib25SZWxvYWRQYWdlIiwiQURERURfUEFHRSIsIlJFTU9WRURfUEFHRSIsIm9uUGFnZUFkZFJlbW92ZSIsIlNFUlZFUl9FUlJPUiIsImVycm9ySlNPTiIsInBhcnNlIiwiRXJyb3IiLCJERVZfUEFHRVNfTUFOSUZFU1RfVVBEQVRFIiwiYXNzZXRQcmVmaXgiLCJjaGlsZHJlbiIsImdsb2JhbEVycm9yIiwidXNlRXJyb3JIYW5kbGVyIiwib25VbmhhbmRsZWRFcnJvciIsIm9uVW5oYW5kbGVkUmVqZWN0aW9uIiwid2ViU29ja2V0UmVmIiwidXNlV2Vic29ja2V0IiwidXNlV2Vic29ja2V0UGluZyIsInVzZVNlbmRNZXNzYWdlIiwidXNlRm9yd2FyZENvbnNvbGVMb2ciLCJ1c2VUdXJib3BhY2siLCJ1c2VSb3V0ZXIiLCJwYXRobmFtZSIsInVzZVVudHJhY2tlZFBhdGhuYW1lIiwidXNlUmVmIiwidXNlRWZmZWN0IiwiYXBwSXNyTWFuaWZlc3QiLCJyZWFzb24iLCJET01FeGNlcHRpb24iLCJ3ZWJzb2NrZXQiLCJyZXBvcnRJbnZhbGlkSG1yTWVzc2FnZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiQXBwRGV2T3ZlcmxheUVycm9yQm91bmRhcnkiLCJSZXBsYXlTc3JPbmx5RXJyb3JzIiwib25CbG9ja2luZ0Vycm9yIiwib3BlbkVycm9yT3ZlcmxheSJdLCJtYXBwaW5ncyI6IkFBQUEsNkNBQTZDOzs7Ozs7Ozs7Ozs7Ozs7SUErYjdDLE9BaUdDLEVBQUE7ZUFqR3VCQTs7SUExWVJDLDhCQUE4QixFQUFBO2VBQTlCQTs7Ozs7dUJBbERtQztvRUFDN0I7Z0ZBQ1k7NEJBQ1I7d0JBS25COzhCQUNvQjtxQ0FDUzs0Q0FDTztpQ0FDWDtxQ0FDSTs4QkFNN0I7a0NBQ3FDO3FDQUtQOzJFQUNSOzRDQUNBO2tDQUNnQjtzQ0FFUjtBQUVyQyxJQUFJQyw0QkFBaUM7QUFDckMsSUFBSUMsb0JBQW9CQyxLQUFLQyxLQUFLLENBQUNELEtBQUtFLE1BQU0sS0FBSyxNQUFNQyxLQUFLQyxHQUFHO0FBQ2pFLElBQUlDLFlBQVk7QUFDaEIsSUFBSUMsMkJBQTBDO0FBQzlDLE1BQU1DLGVBQW9DQyxRQUFRQyxHQUFHLENBQUNDLFNBQVMsa0JBQzNELElBQUlDLDRCQUFBQSxZQUFZLEtBQ2hCO0FBRUosSUFBSUMsMEJBQTBCQyxRQUFRQyxPQUFPO0FBQzdDLElBQUlDLGlDQUE2QyxLQUFPO0FBQ3hELFNBQVNDO0lBQ1BKLDBCQUEwQixJQUFJQyxRQUFRLENBQUNDO1FBQ3JDQyxpQ0FBaUM7WUFDL0JEO1FBQ0Y7SUFDRjtBQUNGO0FBRU8sU0FBU2pCO0lBQ2QsT0FBT2U7QUFDVDtBQUVBLGtEQUFrRDtBQUNsRCxTQUFTSyxvQkFBb0JDLElBQVk7SUFDdkMsc0NBQXNDO0lBQ3RDcEIsNEJBQTRCb0I7QUFDOUI7QUFFQTs7OztDQUlDLEdBQ0QsU0FBU0M7SUFDUCxJQUFJWCxRQUFRQyxHQUFHLENBQUNDLFNBQVMsZUFBRTtRQUN6QixPQUFPO0lBQ1Q7OztBQU1GO0FBRUEsNkNBQTZDO0FBQzdDLFNBQVNXO0lBQ1AsT0FBT0MsT0FBT0MsR0FBRyxDQUFDQyxNQUFNLE9BQU87QUFDakM7QUFDQSxTQUFTQyxrQkFBa0JDLEVBQU87SUFDaEMsSUFBSUwsbUJBQW1CO1FBQ3JCSztJQUNGLE9BQU87UUFDTCxTQUFTQyxRQUFRSCxNQUFXO1lBQzFCLElBQUlBLFdBQVcsUUFBUTtnQkFDckJGLE9BQU9DLEdBQUcsQ0FBQ0ssbUJBQW1CLENBQUNEO2dCQUMvQkQ7WUFDRjtRQUNGO1FBQ0FKLE9BQU9DLEdBQUcsQ0FBQ00sZ0JBQWdCLENBQUNGO0lBQzlCO0FBQ0Y7QUFFQSxTQUFTRyxrQkFBa0JDLEdBQVEsRUFBRUMsV0FBZ0I7SUFDbkQsTUFBTUMsYUFDSkYsT0FDQyxDQUFDQSxJQUFJRyxLQUFLLElBQUlILElBQUlHLEtBQUssQ0FBQ0MsS0FBSyxDQUFDLE1BQU1DLEtBQUssQ0FBQyxHQUFHLEdBQUdDLElBQUksQ0FBQyxTQUNwRE4sSUFBSU8sT0FBTyxJQUNYUCxNQUFNLEVBQUM7SUFFWEMsWUFDRU8sS0FBS0MsU0FBUyxDQUFDO1FBQ2JDLE9BQU87UUFDUFI7UUFDQVMsaUJBQWlCLENBQUMsQ0FBQ0MscUJBQUFBLG1CQUFtQixDQUFDRCxlQUFlO1FBQ3RERSxpQkFBaUJiLE1BQU1BLElBQUlhLGVBQWUsR0FBR0M7SUFDL0M7SUFHRixJQUFJeEMsV0FBVztJQUNmQSxZQUFZO0lBQ1p5QyxPQUFPQyxRQUFRLENBQUNDLE1BQU07QUFDeEI7QUFFQSxpRUFBaUU7QUFDakUsU0FBU0MsdUJBQXVCakIsV0FBc0M7SUFDcEUsSUFBSSxDQUFDYix1QkFBdUIsQ0FBQ0UsbUJBQW1CO1FBQzlDTjtRQUNBbUMsY0FBQUEsVUFBVSxDQUFDQyxTQUFTO1FBQ3BCQyxDQUFBQSxHQUFBQSxrQkFBQUEsT0FBZ0IsRUFBQ3BCLGFBQWEsRUFBRSxFQUFFMUIsMEJBQTJCSCxLQUFLQyxHQUFHO1FBQ3JFO0lBQ0Y7SUFFQSxTQUFTaUQsbUJBQ1B0QixHQUFRLEVBQ1J1QixjQUEwQztRQUUxQyxJQUFJdkIsT0FBT1kscUJBQUFBLG1CQUFtQixDQUFDRCxlQUFlLElBQUlZLGtCQUFrQixNQUFNO1lBQ3hFLElBQUl2QixLQUFLO2dCQUNQd0IsUUFBUUMsSUFBSSxDQUFDQyxRQUFBQSx5QkFBeUI7WUFDeEMsT0FBTyxJQUFJZCxxQkFBQUEsbUJBQW1CLENBQUNELGVBQWUsRUFBRTtnQkFDOUNhLFFBQVFDLElBQUksQ0FBQ0UsUUFBQUEsb0NBQW9DO1lBQ25EO1lBQ0E1QixrQkFBa0JDLEtBQUtDO1lBQ3ZCO1FBQ0Y7UUFFQWtCLGNBQUFBLFVBQVUsQ0FBQ0MsU0FBUztRQUVwQixJQUFJaEMscUJBQXFCO1lBQ3ZCLCtEQUErRDtZQUMvRDhCLHVCQUF1QmpCO1lBQ3ZCO1FBQ0Y7UUFFQWtCLGNBQUFBLFVBQVUsQ0FBQ1MsU0FBUztRQUNwQjVDO1FBQ0FxQyxDQUFBQSxHQUFBQSxrQkFBQUEsT0FBZ0IsRUFDZHBCLGFBQ0FzQixnQkFDQWhELDBCQUNBSCxLQUFLQyxHQUFHO1FBR1YsSUFBSUksUUFBUUMsR0FBRyxDQUFDbUQsZ0JBQWdCLEVBQUU7O0lBUXBDO0lBRUEsMkRBQTJEO0lBQzNEdEMsT0FBT0MsR0FBRyxDQUNQd0MsS0FBSyxDQUFDLGFBQWEsR0FBRyxPQUN0QkMsSUFBSSxDQUFDLENBQUNWO1FBQ0wsSUFBSUEsa0JBQWtCLE1BQU07WUFDMUIsT0FBTztRQUNUO1FBRUEsMEVBQTBFO1FBQzFFLG1FQUFtRTtRQUNuRSx5R0FBeUc7UUFDekdKLGNBQUFBLFVBQVUsQ0FBQ2UsZUFBZTtRQUMxQiwyREFBMkQ7UUFDM0QsT0FBTzNDLE9BQU9DLEdBQUcsQ0FBQzJDLEtBQUs7SUFDekIsR0FDQ0YsSUFBSSxDQUNILENBQUNWO1FBQ0NELG1CQUFtQixNQUFNQztJQUMzQixHQUNBLENBQUN2QjtRQUNDc0IsbUJBQW1CdEIsS0FBSztJQUMxQjtBQUVOO0FBRUEseURBQXlELEdBQ3pELFNBQVNvQyxlQUNQQyxHQUFxQixFQUNyQnBDLFdBQXNDLEVBQ3RDcUMsdUJBQTZELEVBQzdEQyxNQUFvQyxFQUNwQ0MsaUJBQTRDLEVBQzVDQyxXQUFzQztJQUV0QyxJQUFJLENBQUUsQ0FBQSxZQUFZSixHQUFFLEdBQUk7UUFDdEI7SUFDRjtJQUVBLFNBQVNLLGFBQWFDLE1BQThCO1FBQ2xELDhCQUE4QjtRQUM5QixNQUFNQyxZQUFZQyxDQUFBQSxHQUFBQSx1QkFBQUEsT0FBcUIsRUFBQztZQUN0Q0YsUUFBUUE7WUFDUkcsVUFBVSxFQUFFO1FBQ2Q7UUFFQSw2QkFBNkI7UUFDN0IzQixjQUFBQSxVQUFVLENBQUM0QixZQUFZLENBQUNILFVBQVVELE1BQU0sQ0FBQyxFQUFFO1FBRTNDLGdDQUFnQztRQUNoQyxJQUFLLElBQUlLLElBQUksR0FBR0EsSUFBSUosVUFBVUQsTUFBTSxDQUFDTSxNQUFNLEVBQUVELElBQUs7WUFDaER4QixRQUFRMEIsS0FBSyxDQUFDQyxDQUFBQSxHQUFBQSxXQUFBQSxPQUFTLEVBQUNQLFVBQVVELE1BQU0sQ0FBQ0ssRUFBRTtRQUM3QztRQUVBLGdDQUFnQztRQUNoQywwQ0FBMEM7UUFDMUMsSUFBSXZFLFFBQVFDLEdBQUcsQ0FBQ21ELGdCQUFnQixFQUFFOztJQU1wQztJQUVBLFNBQVN1QjtRQUNQLElBQUkzRSxRQUFRQyxHQUFHLENBQUNDLFNBQVMsZUFBRTtZQUN6QixNQUFNMEUsWUFBWTdFLGFBQWM4RSxPQUFPO1lBQ3ZDLElBQUlELGFBQWEsTUFBTTtnQkFDckJoQyxDQUFBQSxHQUFBQSxrQkFBQUEsT0FBZ0IsRUFDZHBCLGFBQ0E7dUJBQUlvRCxVQUFVOUIsY0FBYztpQkFBQyxFQUM3QjhCLFVBQVVFLGlCQUFpQixFQUMzQkYsVUFBVUcsZUFBZSxFQUN6QixBQUNBSCxVQUFVSSxVQUFVLGlEQURpRDtZQUd6RTtZQUNBdEMsY0FBQUEsVUFBVSxDQUFDQyxTQUFTO1FBQ3RCLE9BQU87O0lBR1Q7SUFFQSxPQUFRaUIsSUFBSXFCLE1BQU07UUFDaEIsS0FBS0Msa0JBQUFBLDJCQUEyQixDQUFDQyxZQUFZO1lBQUU7Z0JBQzdDLElBQUluRixRQUFRQyxHQUFHLENBQUNtRixvQkFBb0IsSUFBRTtvQkFDcEMsSUFBSXJCLG1CQUFtQjt3QkFDckJBLGtCQUFrQnNCLE9BQU8sR0FBR3pCLElBQUkwQixJQUFJO3dCQUVwQyw4Q0FBOEM7d0JBQzlDLDBEQUEwRDt3QkFDMUQsMkRBQTJEO3dCQUMzRCx5QkFBeUI7d0JBQ3pCLElBQUt0QixZQUFZcUIsT0FBTyxJQUFlekIsSUFBSTBCLElBQUksRUFBRTs0QkFDL0M1QyxjQUFBQSxVQUFVLENBQUM2QyxpQkFBaUIsQ0FBQzt3QkFDL0IsT0FBTzs0QkFDTDdDLGNBQUFBLFVBQVUsQ0FBQzZDLGlCQUFpQixDQUFDO3dCQUMvQjtvQkFDRjtnQkFDRjtnQkFDQTtZQUNGO1FBQ0EsS0FBS0wsa0JBQUFBLDJCQUEyQixDQUFDTSxRQUFRO1lBQUU7Z0JBQ3pDOUMsY0FBQUEsVUFBVSxDQUFDK0MscUJBQXFCO2dCQUVoQyxJQUFJekYsUUFBUUMsR0FBRyxDQUFDQyxTQUFTLGVBQUU7b0JBQ3pCSCxhQUFjMkYsVUFBVTtnQkFDMUIsT0FBTzs7Z0JBS1A7WUFDRjtRQUNBLEtBQUtSLGtCQUFBQSwyQkFBMkIsQ0FBQ1UsS0FBSztRQUN0QyxLQUFLVixrQkFBQUEsMkJBQTJCLENBQUNXLElBQUk7WUFBRTtnQkFDckNuRCxjQUFBQSxVQUFVLENBQUNvRCxxQkFBcUI7Z0JBRWhDLElBQUlsQyxJQUFJbEQsSUFBSSxFQUFFO29CQUNaRCxvQkFBb0JtRCxJQUFJbEQsSUFBSTtnQkFDOUI7Z0JBRUEsTUFBTSxFQUFFd0QsTUFBTSxFQUFFRyxRQUFRLEVBQUUsR0FBR1Q7Z0JBRTdCLHlDQUF5QztnQkFDekMsSUFBSSxpQkFBaUJBLEtBQUtsQixjQUFBQSxVQUFVLENBQUNxRCxhQUFhLENBQUNuQyxJQUFJb0MsV0FBVztnQkFDbEUsSUFBSSxXQUFXcEMsT0FBT0EsSUFBSXFDLEtBQUssRUFBRXZELGNBQUFBLFVBQVUsQ0FBQ3dELFdBQVcsQ0FBQ3RDLElBQUlxQyxLQUFLO2dCQUNqRSxJQUFJLGtCQUFrQnJDLEtBQUtsQixjQUFBQSxVQUFVLENBQUN5RCxjQUFjLENBQUN2QyxJQUFJd0MsWUFBWTtnQkFFckUsTUFBTUMsWUFBWUMsUUFBUXBDLFVBQVVBLE9BQU9NLE1BQU07Z0JBQ2pELGtFQUFrRTtnQkFDbEUsSUFBSTZCLFdBQVc7b0JBQ2I3RSxZQUNFTyxLQUFLQyxTQUFTLENBQUM7d0JBQ2JDLE9BQU87d0JBQ1BzRSxZQUFZckMsT0FBT00sTUFBTTt3QkFDekJnQyxVQUFVakg7b0JBQ1o7b0JBR0YwRSxhQUFhQztvQkFDYjtnQkFDRjtnQkFFQSxNQUFNdUMsY0FBY0gsUUFBUWpDLFlBQVlBLFNBQVNHLE1BQU07Z0JBQ3ZELElBQUlpQyxhQUFhO29CQUNmakYsWUFDRU8sS0FBS0MsU0FBUyxDQUFDO3dCQUNiQyxPQUFPO3dCQUNQeUUsY0FBY3JDLFNBQVNHLE1BQU07d0JBQzdCZ0MsVUFBVWpIO29CQUNaO29CQUdGLGlDQUFpQztvQkFDakMsTUFBTW9ILG9CQUFvQnZDLENBQUFBLEdBQUFBLHVCQUFBQSxPQUFxQixFQUFDO3dCQUM5Q0MsVUFBVUE7d0JBQ1ZILFFBQVEsRUFBRTtvQkFDWjtvQkFFQSxJQUFLLElBQUlLLElBQUksR0FBR0EsSUFBSW9DLGtCQUFrQnRDLFFBQVEsQ0FBQ0csTUFBTSxFQUFFRCxJQUFLO3dCQUMxRCxJQUFJQSxNQUFNLEdBQUc7NEJBQ1h4QixRQUFRQyxJQUFJLENBQ1YsK0NBQ0U7NEJBRUo7d0JBQ0Y7d0JBQ0FELFFBQVFDLElBQUksQ0FBQzBCLENBQUFBLEdBQUFBLFdBQUFBLE9BQVMsRUFBQ2lDLGtCQUFrQnRDLFFBQVEsQ0FBQ0UsRUFBRTtvQkFDdEQ7Z0JBRUEsdUhBQXVIO2dCQUN6SDtnQkFFQS9DLFlBQ0VPLEtBQUtDLFNBQVMsQ0FBQztvQkFDYkMsT0FBTztvQkFDUHVFLFVBQVVqSDtnQkFDWjtnQkFHRixJQUFJcUUsSUFBSXFCLE1BQU0sS0FBS0Msa0JBQUFBLDJCQUEyQixDQUFDVSxLQUFLLEVBQUU7b0JBQ3BEakI7Z0JBQ0Y7Z0JBQ0E7WUFDRjtRQUNBLEtBQUtPLGtCQUFBQSwyQkFBMkIsQ0FBQzBCLG1CQUFtQjtZQUFFO2dCQUNwRC9DLHdCQUF3QjtvQkFDdEJnRCxNQUFNM0Isa0JBQUFBLDJCQUEyQixDQUFDMEIsbUJBQW1CO29CQUNyRHRCLE1BQU07d0JBQ0p3QixXQUFXbEQsSUFBSTBCLElBQUksQ0FBQ3dCLFNBQVM7b0JBQy9CO2dCQUNGO2dCQUNBO1lBQ0Y7UUFDQSxLQUFLNUIsa0JBQUFBLDJCQUEyQixDQUFDNkIsaUJBQWlCO1lBQUU7Z0JBQ2xEaEgsYUFBY2lILGtCQUFrQixDQUFDcEQ7Z0JBQ2pDbEIsY0FBQUEsVUFBVSxDQUFDZSxlQUFlO2dCQUMxQkksd0JBQXdCO29CQUN0QmdELE1BQU0zQixrQkFBQUEsMkJBQTJCLENBQUM2QixpQkFBaUI7b0JBQ25EekIsTUFBTTFCLElBQUkwQixJQUFJO2dCQUNoQjtnQkFDQSxJQUFJbkQscUJBQUFBLG1CQUFtQixDQUFDRCxlQUFlLEVBQUU7b0JBQ3ZDYSxRQUFRQyxJQUFJLENBQUNFLFFBQUFBLG9DQUFvQztvQkFDakQ1QixrQkFBa0IsTUFBTUU7Z0JBQzFCO2dCQUNBa0IsY0FBQUEsVUFBVSxDQUFDUyxTQUFTO2dCQUNwQjtZQUNGO1FBQ0EsdURBQXVEO1FBQ3ZELEtBQUsrQixrQkFBQUEsMkJBQTJCLENBQUMrQix3QkFBd0I7WUFBRTtnQkFDekRsSCxnQkFBQUEsT0FBQUEsS0FBQUEsSUFBQUEsYUFBY21ILHdCQUF3QjtnQkFDdEMxRixZQUNFTyxLQUFLQyxTQUFTLENBQUM7b0JBQ2JDLE9BQU87b0JBQ1B1RSxVQUFVakg7b0JBQ1ZtQixNQUFNa0QsSUFBSWxELElBQUk7Z0JBQ2hCO2dCQUdGLDBFQUEwRTtnQkFDMUUsdUNBQXVDO2dCQUN2Q3lHLFNBQVNDLE1BQU0sR0FBTUMsa0JBQUFBLDRCQUE0QixHQUFDLE1BQUd6RCxJQUFJbEQsSUFBSTtnQkFFN0QsSUFBSXlCLHFCQUFBQSxtQkFBbUIsQ0FBQ0QsZUFBZSxFQUFFO29CQUN2QyxJQUFJckMsV0FBVztvQkFDZkEsWUFBWTtvQkFDWixPQUFPeUMsT0FBT0MsUUFBUSxDQUFDQyxNQUFNO2dCQUMvQjtnQkFFQThFLENBQUFBLEdBQUFBLE9BQUFBLGVBQWUsRUFBQztvQkFDZHhELE9BQU95RCxVQUFVO29CQUNqQjdFLGNBQUFBLFVBQVUsQ0FBQ1MsU0FBUztnQkFDdEI7Z0JBRUEsSUFBSW5ELFFBQVFDLEdBQUcsQ0FBQ21ELGdCQUFnQixFQUFFOztnQkFPbEM7WUFDRjtRQUNBLEtBQUs4QixrQkFBQUEsMkJBQTJCLENBQUNzQyxXQUFXO1lBQUU7Z0JBQzVDekgsZ0JBQUFBLE9BQUFBLEtBQUFBLElBQUFBLGFBQWMwSCxZQUFZO2dCQUMxQmpHLFlBQ0VPLEtBQUtDLFNBQVMsQ0FBQztvQkFDYkMsT0FBTztvQkFDUHVFLFVBQVVqSDtnQkFDWjtnQkFFRixJQUFJTSxXQUFXO2dCQUNmQSxZQUFZO2dCQUNaLE9BQU95QyxPQUFPQyxRQUFRLENBQUNDLE1BQU07WUFDL0I7UUFDQSxLQUFLMEMsa0JBQUFBLDJCQUEyQixDQUFDd0MsVUFBVTtRQUMzQyxLQUFLeEMsa0JBQUFBLDJCQUEyQixDQUFDeUMsWUFBWTtZQUFFO2dCQUM3QzVILGdCQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxhQUFjNkgsZUFBZTtnQkFDN0IscUZBQXFGO2dCQUNyRixPQUFPOUQsT0FBT3lELFVBQVU7WUFDMUI7UUFDQSxLQUFLckMsa0JBQUFBLDJCQUEyQixDQUFDMkMsWUFBWTtZQUFFO2dCQUM3QyxNQUFNLEVBQUVDLFNBQVMsRUFBRSxHQUFHbEU7Z0JBQ3RCLElBQUlrRSxXQUFXO29CQUNiLE1BQU0sRUFBRWhHLE9BQU8sRUFBRUosS0FBSyxFQUFFLEdBQUdLLEtBQUtnRyxLQUFLLENBQUNEO29CQUN0QyxNQUFNckQsUUFBUSxPQUFBLGNBQWtCLENBQWxCLElBQUl1RCxNQUFNbEcsVUFBVixxQkFBQTsrQkFBQTtvQ0FBQTtzQ0FBQTtvQkFBaUI7b0JBQy9CMkMsTUFBTS9DLEtBQUssR0FBR0E7b0JBQ2R1QyxhQUFhO3dCQUFDUTtxQkFBTTtnQkFDdEI7Z0JBQ0E7WUFDRjtRQUNBLEtBQUtTLGtCQUFBQSwyQkFBMkIsQ0FBQytDLHlCQUF5QjtZQUFFO2dCQUMxRDtZQUNGO1FBQ0E7WUFBUyxDQUNUO0lBQ0Y7QUFDRjtBQUVlLFNBQVM3SSxVQUFVLEtBUWpDO0lBUmlDLElBQUEsRUFDaEM4SSxXQUFXLEVBQ1hDLFFBQVEsRUFDUkMsV0FBVyxFQUtaLEdBUmlDO0lBU2hDQyxDQUFBQSxHQUFBQSxpQkFBQUEsZUFBZSxFQUFDM0YsY0FBQUEsVUFBVSxDQUFDNEYsZ0JBQWdCLEVBQUU1RixjQUFBQSxVQUFVLENBQUM2RixvQkFBb0I7SUFFNUUsTUFBTUMsZUFBZUMsQ0FBQUEsR0FBQUEsY0FBQUEsWUFBWSxFQUFDUDtJQUVsQ1EsQ0FBQUEsR0FBQUEsY0FBQUEsZ0JBQWdCLEVBQUNGO0lBQ2pCLE1BQU1oSCxjQUFjbUgsQ0FBQUEsR0FBQUEsY0FBQUEsY0FBYyxFQUFDSDtJQUNuQ0ksQ0FBQUEsR0FBQUEsc0JBQUFBLG9CQUFvQixFQUFDSjtJQUNyQixNQUFNM0UsMEJBQTBCZ0YsQ0FBQUEsR0FBQUEsY0FBQUEsWUFBWSxFQUFDckgsYUFBYSxDQUFDRCxNQUN6REQsa0JBQWtCQyxLQUFLQztJQUd6QixNQUFNc0MsU0FBU2dGLENBQUFBLEdBQUFBLFlBQUFBLFNBQVM7SUFFeEIsOEVBQThFO0lBQzlFLG1FQUFtRTtJQUNuRSxNQUFNQyxXQUFXQyxDQUFBQSxHQUFBQSxxQkFBQUEsb0JBQW9CO0lBQ3JDLE1BQU1qRixvQkFBb0JrRixDQUFBQSxHQUFBQSxPQUFBQSxNQUFNLEVBQWlDLENBQUM7SUFDbEUsTUFBTWpGLGNBQWNpRixDQUFBQSxHQUFBQSxPQUFBQSxNQUFNLEVBQUNGO0lBRTNCLElBQUkvSSxRQUFRQyxHQUFHLENBQUNtRixvQkFBb0IsSUFBRTtRQUNwQywyREFBMkQ7UUFDM0QsbUVBQW1FO1FBQ25FLHNEQUFzRDtRQUN0RDhELENBQUFBLEdBQUFBLE9BQUFBLFNBQVMsRUFBQztZQUNSbEYsWUFBWXFCLE9BQU8sR0FBRzBEO1lBRXRCLE1BQU1JLGlCQUFpQnBGLGtCQUFrQnNCLE9BQU87WUFFaEQsSUFBSThELGdCQUFnQjtnQkFDbEIsSUFBSUosWUFBWUEsWUFBWUksZ0JBQWdCO29CQUMxQyxJQUFJO3dCQUNGekcsY0FBQUEsVUFBVSxDQUFDNkMsaUJBQWlCLENBQUM7b0JBQy9CLEVBQUUsT0FBTzZELFFBQVE7d0JBQ2YsSUFBSXRILFVBQVU7d0JBRWQsSUFBSXNILGtCQUFrQkMsY0FBYztnQ0FFeEJEOzRCQURWLHNFQUFzRTs0QkFDdEV0SCxVQUFVc0gsQ0FBQUEsZ0JBQUFBLE9BQU8xSCxLQUFLLEtBQUEsT0FBWjBILGdCQUFnQkEsT0FBT3RILE9BQU87d0JBQzFDLE9BQU8sSUFBSXNILGtCQUFrQnBCLE9BQU87Z0NBQ2FvQjs0QkFBL0N0SCxVQUFVLFlBQVlzSCxPQUFPdEgsT0FBTyxHQUFHLE9BQVFzSCxDQUFBQSxDQUFBQSxpQkFBQUEsT0FBTzFILEtBQUssS0FBQSxPQUFaMEgsaUJBQWdCLEVBQUM7d0JBQ2xFLE9BQU87NEJBQ0x0SCxVQUFVLDJCQUEyQnNIO3dCQUN2Qzt3QkFFQXJHLFFBQVFDLElBQUksQ0FBQyxXQUFXbEI7b0JBQzFCO2dCQUNGLE9BQU87b0JBQ0xZLGNBQUFBLFVBQVUsQ0FBQzZDLGlCQUFpQixDQUFDO2dCQUMvQjtZQUNGO1FBQ0YsR0FBRztZQUFDd0Q7U0FBUztJQUNmO0lBRUFHLENBQUFBLEdBQUFBLE9BQUFBLFNBQVMsRUFBQztRQUNSLE1BQU1JLFlBQVlkLGFBQWFuRCxPQUFPO1FBQ3RDLElBQUksQ0FBQ2lFLFdBQVc7UUFFaEIsTUFBTW5JLFVBQVUsQ0FBQ2M7WUFDZixJQUFJO2dCQUNGLE1BQU0yQixNQUFNN0IsS0FBS2dHLEtBQUssQ0FBQzlGLE1BQU1xRCxJQUFJO2dCQUNqQzNCLGVBQ0VDLEtBQ0FwQyxhQUNBcUMseUJBQ0FDLFFBQ0FDLG1CQUNBQztZQUVKLEVBQUUsT0FBT3pDLEtBQWM7Z0JBQ3JCZ0ksQ0FBQUEsR0FBQUEsUUFBQUEsdUJBQXVCLEVBQUN0SCxPQUFPVjtZQUNqQztRQUNGO1FBRUErSCxVQUFVRSxnQkFBZ0IsQ0FBQyxXQUFXckk7UUFDdEMsT0FBTyxJQUFNbUksVUFBVUcsbUJBQW1CLENBQUMsV0FBV3RJO0lBQ3hELEdBQUc7UUFDREs7UUFDQXNDO1FBQ0EwRTtRQUNBM0U7UUFDQUU7S0FDRDtJQUNELE9BQUEsV0FBQSxHQUNFLENBQUEsR0FBQSxZQUFBLElBQUEsRUFBQzJGLDRCQUFBQSwwQkFBMEIsRUFBQTtRQUFDdEIsYUFBYUE7OzBCQUN2QyxDQUFBLEdBQUEsWUFBQSxHQUFBLEVBQUN1QixxQkFBQUEsbUJBQW1CLEVBQUE7Z0JBQUNDLGlCQUFpQmxILGNBQUFBLFVBQVUsQ0FBQ21ILGdCQUFnQjs7WUFDaEUxQjs7O0FBR1AiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogOTM3NCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvY29tcG9uZW50cy9hcHAtcm91dGVyLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuaW1wb3J0IFJlYWN0LCB7XG4gIHVzZUVmZmVjdCxcbiAgdXNlTWVtbyxcbiAgc3RhcnRUcmFuc2l0aW9uLFxuICB1c2VJbnNlcnRpb25FZmZlY3QsXG4gIHVzZURlZmVycmVkVmFsdWUsXG59IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHtcbiAgQXBwUm91dGVyQ29udGV4dCxcbiAgTGF5b3V0Um91dGVyQ29udGV4dCxcbiAgR2xvYmFsTGF5b3V0Um91dGVyQ29udGV4dCxcbn0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgdHlwZSB7IENhY2hlTm9kZSB9IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHsgQUNUSU9OX1JFU1RPUkUgfSBmcm9tICcuL3JvdXRlci1yZWR1Y2VyL3JvdXRlci1yZWR1Y2VyLXR5cGVzJ1xuaW1wb3J0IHR5cGUgeyBBcHBSb3V0ZXJTdGF0ZSB9IGZyb20gJy4vcm91dGVyLXJlZHVjZXIvcm91dGVyLXJlZHVjZXItdHlwZXMnXG5pbXBvcnQgeyBjcmVhdGVIcmVmRnJvbVVybCB9IGZyb20gJy4vcm91dGVyLXJlZHVjZXIvY3JlYXRlLWhyZWYtZnJvbS11cmwnXG5pbXBvcnQge1xuICBTZWFyY2hQYXJhbXNDb250ZXh0LFxuICBQYXRobmFtZUNvbnRleHQsXG4gIFBhdGhQYXJhbXNDb250ZXh0LFxufSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL2hvb2tzLWNsaWVudC1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHsgZGlzcGF0Y2hBcHBSb3V0ZXJBY3Rpb24sIHVzZUFjdGlvblF1ZXVlIH0gZnJvbSAnLi91c2UtYWN0aW9uLXF1ZXVlJ1xuaW1wb3J0IHsgRXJyb3JCb3VuZGFyeSB9IGZyb20gJy4vZXJyb3ItYm91bmRhcnknXG5pbXBvcnQgRGVmYXVsdEdsb2JhbEVycm9yIGZyb20gJy4vYnVpbHRpbi9nbG9iYWwtZXJyb3InXG5pbXBvcnQgeyBpc0JvdCB9IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2lzLWJvdCdcbmltcG9ydCB7IGFkZEJhc2VQYXRoIH0gZnJvbSAnLi4vYWRkLWJhc2UtcGF0aCdcbmltcG9ydCB7IEFwcFJvdXRlckFubm91bmNlciB9IGZyb20gJy4vYXBwLXJvdXRlci1hbm5vdW5jZXInXG5pbXBvcnQgeyBSZWRpcmVjdEJvdW5kYXJ5IH0gZnJvbSAnLi9yZWRpcmVjdC1ib3VuZGFyeSdcbmltcG9ydCB7IGZpbmRIZWFkSW5DYWNoZSB9IGZyb20gJy4vcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvZmluZC1oZWFkLWluLWNhY2hlJ1xuaW1wb3J0IHsgdW5yZXNvbHZlZFRoZW5hYmxlIH0gZnJvbSAnLi91bnJlc29sdmVkLXRoZW5hYmxlJ1xuaW1wb3J0IHsgcmVtb3ZlQmFzZVBhdGggfSBmcm9tICcuLi9yZW1vdmUtYmFzZS1wYXRoJ1xuaW1wb3J0IHsgaGFzQmFzZVBhdGggfSBmcm9tICcuLi9oYXMtYmFzZS1wYXRoJ1xuaW1wb3J0IHsgZ2V0U2VsZWN0ZWRQYXJhbXMgfSBmcm9tICcuL3JvdXRlci1yZWR1Y2VyL2NvbXB1dGUtY2hhbmdlZC1wYXRoJ1xuaW1wb3J0IHR5cGUgeyBGbGlnaHRSb3V0ZXJTdGF0ZSB9IGZyb20gJy4uLy4uL3NlcnZlci9hcHAtcmVuZGVyL3R5cGVzJ1xuaW1wb3J0IHsgdXNlTmF2RmFpbHVyZUhhbmRsZXIgfSBmcm9tICcuL25hdi1mYWlsdXJlLWhhbmRsZXInXG5pbXBvcnQge1xuICBkaXNwYXRjaFRyYXZlcnNlQWN0aW9uLFxuICBwdWJsaWNBcHBSb3V0ZXJJbnN0YW5jZSxcbiAgdHlwZSBBcHBSb3V0ZXJBY3Rpb25RdWV1ZSxcbiAgdHlwZSBHbG9iYWxFcnJvclN0YXRlLFxufSBmcm9tICcuL2FwcC1yb3V0ZXItaW5zdGFuY2UnXG5pbXBvcnQgeyBnZXRSZWRpcmVjdFR5cGVGcm9tRXJyb3IsIGdldFVSTEZyb21SZWRpcmVjdEVycm9yIH0gZnJvbSAnLi9yZWRpcmVjdCdcbmltcG9ydCB7IGlzUmVkaXJlY3RFcnJvciwgUmVkaXJlY3RUeXBlIH0gZnJvbSAnLi9yZWRpcmVjdC1lcnJvcidcbmltcG9ydCB7IHBpbmdWaXNpYmxlTGlua3MgfSBmcm9tICcuL2xpbmtzJ1xuaW1wb3J0IEdyYWNlZnVsRGVncmFkZUJvdW5kYXJ5IGZyb20gJy4vZXJyb3JzL2dyYWNlZnVsLWRlZ3JhZGUtYm91bmRhcnknXG5cbmNvbnN0IGdsb2JhbE11dGFibGU6IHtcbiAgcGVuZGluZ01wYVBhdGg/OiBzdHJpbmdcbn0gPSB7fVxuXG5leHBvcnQgZnVuY3Rpb24gaXNFeHRlcm5hbFVSTCh1cmw6IFVSTCkge1xuICByZXR1cm4gdXJsLm9yaWdpbiAhPT0gd2luZG93LmxvY2F0aW9uLm9yaWdpblxufVxuXG4vKipcbiAqIEdpdmVuIGEgbGluayBocmVmLCBjb25zdHJ1Y3RzIHRoZSBVUkwgdGhhdCBzaG91bGQgYmUgcHJlZmV0Y2hlZC4gUmV0dXJucyBudWxsXG4gKiBpbiBjYXNlcyB3aGVyZSBwcmVmZXRjaGluZyBzaG91bGQgYmUgZGlzYWJsZWQsIGxpa2UgZXh0ZXJuYWwgVVJMcywgb3JcbiAqIGR1cmluZyBkZXZlbG9wbWVudC5cbiAqIEBwYXJhbSBocmVmIFRoZSBocmVmIHBhc3NlZCB0byA8TGluaz4sIHJvdXRlci5wcmVmZXRjaCgpLCBvciBzaW1pbGFyXG4gKiBAcmV0dXJucyBBIFVSTCBvYmplY3QgdG8gcHJlZmV0Y2gsIG9yIG51bGwgaWYgcHJlZmV0Y2hpbmcgc2hvdWxkIGJlIGRpc2FibGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQcmVmZXRjaFVSTChocmVmOiBzdHJpbmcpOiBVUkwgfCBudWxsIHtcbiAgLy8gRG9uJ3QgcHJlZmV0Y2ggZm9yIGJvdHMgYXMgdGhleSBkb24ndCBuYXZpZ2F0ZS5cbiAgaWYgKGlzQm90KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBsZXQgdXJsOiBVUkxcbiAgdHJ5IHtcbiAgICB1cmwgPSBuZXcgVVJMKGFkZEJhc2VQYXRoKGhyZWYpLCB3aW5kb3cubG9jYXRpb24uaHJlZilcbiAgfSBjYXRjaCAoXykge1xuICAgIC8vIFRPRE86IERvZXMgdGhpcyBuZWVkIHRvIHRocm93IG9yIGNhbiB3ZSBqdXN0IGNvbnNvbGUuZXJyb3IgaW5zdGVhZD8gRG9lc1xuICAgIC8vIGFueW9uZSByZWx5IG9uIHRoaXMgdGhyb3dpbmc/IChTZWVtcyB1bmxpa2VseS4pXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYENhbm5vdCBwcmVmZXRjaCAnJHtocmVmfScgYmVjYXVzZSBpdCBjYW5ub3QgYmUgY29udmVydGVkIHRvIGEgVVJMLmBcbiAgICApXG4gIH1cblxuICAvLyBEb24ndCBwcmVmZXRjaCBkdXJpbmcgZGV2ZWxvcG1lbnQgKGltcHJvdmVzIGNvbXBpbGF0aW9uIHBlcmZvcm1hbmNlKVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLy8gRXh0ZXJuYWwgdXJscyBjYW4ndCBiZSBwcmVmZXRjaGVkIGluIHRoZSBzYW1lIHdheS5cbiAgaWYgKGlzRXh0ZXJuYWxVUkwodXJsKSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICByZXR1cm4gdXJsXG59XG5cbmZ1bmN0aW9uIEhpc3RvcnlVcGRhdGVyKHtcbiAgYXBwUm91dGVyU3RhdGUsXG59OiB7XG4gIGFwcFJvdXRlclN0YXRlOiBBcHBSb3V0ZXJTdGF0ZVxufSkge1xuICB1c2VJbnNlcnRpb25FZmZlY3QoKCkgPT4ge1xuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfQVBQX05BVl9GQUlMX0hBTkRMSU5HKSB7XG4gICAgICAvLyBjbGVhciBwZW5kaW5nIFVSTCBhcyBuYXZpZ2F0aW9uIGlzIG5vIGxvbmdlclxuICAgICAgLy8gaW4gZmxpZ2h0XG4gICAgICB3aW5kb3cubmV4dC5fX3BlbmRpbmdVcmwgPSB1bmRlZmluZWRcbiAgICB9XG5cbiAgICBjb25zdCB7IHRyZWUsIHB1c2hSZWYsIGNhbm9uaWNhbFVybCB9ID0gYXBwUm91dGVyU3RhdGVcbiAgICBjb25zdCBoaXN0b3J5U3RhdGUgPSB7XG4gICAgICAuLi4ocHVzaFJlZi5wcmVzZXJ2ZUN1c3RvbUhpc3RvcnlTdGF0ZSA/IHdpbmRvdy5oaXN0b3J5LnN0YXRlIDoge30pLFxuICAgICAgLy8gSWRlbnRpZmllciBpcyBzaG9ydGVuZWQgaW50ZW50aW9uYWxseS5cbiAgICAgIC8vIF9fTkEgaXMgdXNlZCB0byBpZGVudGlmeSBpZiB0aGUgaGlzdG9yeSBlbnRyeSBjYW4gYmUgaGFuZGxlZCBieSB0aGUgYXBwLXJvdXRlci5cbiAgICAgIC8vIF9fTiBpcyB1c2VkIHRvIGlkZW50aWZ5IGlmIHRoZSBoaXN0b3J5IGVudHJ5IGNhbiBiZSBoYW5kbGVkIGJ5IHRoZSBvbGQgcm91dGVyLlxuICAgICAgX19OQTogdHJ1ZSxcbiAgICAgIF9fUFJJVkFURV9ORVhUSlNfSU5URVJOQUxTX1RSRUU6IHRyZWUsXG4gICAgfVxuICAgIGlmIChcbiAgICAgIHB1c2hSZWYucGVuZGluZ1B1c2ggJiZcbiAgICAgIC8vIFNraXAgcHVzaGluZyBhbiBhZGRpdGlvbmFsIGhpc3RvcnkgZW50cnkgaWYgdGhlIGNhbm9uaWNhbFVybCBpcyB0aGUgc2FtZSBhcyB0aGUgY3VycmVudCB1cmwuXG4gICAgICAvLyBUaGlzIG1pcnJvcnMgdGhlIGJyb3dzZXIgYmVoYXZpb3IgZm9yIG5vcm1hbCBuYXZpZ2F0aW9uLlxuICAgICAgY3JlYXRlSHJlZkZyb21VcmwobmV3IFVSTCh3aW5kb3cubG9jYXRpb24uaHJlZikpICE9PSBjYW5vbmljYWxVcmxcbiAgICApIHtcbiAgICAgIC8vIFRoaXMgaW50ZW50aW9uYWxseSBtdXRhdGVzIFJlYWN0IHN0YXRlLCBwdXNoUmVmIGlzIG92ZXJ3cml0dGVuIHRvIGVuc3VyZSBhZGRpdGlvbmFsIHB1c2gvcmVwbGFjZSBjYWxscyBkbyBub3QgdHJpZ2dlciBhbiBhZGRpdGlvbmFsIGhpc3RvcnkgZW50cnkuXG4gICAgICBwdXNoUmVmLnBlbmRpbmdQdXNoID0gZmFsc2VcbiAgICAgIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZShoaXN0b3J5U3RhdGUsICcnLCBjYW5vbmljYWxVcmwpXG4gICAgfSBlbHNlIHtcbiAgICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZShoaXN0b3J5U3RhdGUsICcnLCBjYW5vbmljYWxVcmwpXG4gICAgfVxuICB9LCBbYXBwUm91dGVyU3RhdGVdKVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gVGhlIE5leHQtVXJsIGFuZCB0aGUgYmFzZSB0cmVlIG1heSBhZmZlY3QgdGhlIHJlc3VsdCBvZiBhIHByZWZldGNoXG4gICAgLy8gdGFzay4gUmUtcHJlZmV0Y2ggYWxsIHZpc2libGUgbGlua3Mgd2l0aCB0aGUgdXBkYXRlZCB2YWx1ZXMuIEluIG1vc3RcbiAgICAvLyBjYXNlcywgdGhpcyB3aWxsIG5vdCByZXN1bHQgaW4gYW55IG5ldyBuZXR3b3JrIHJlcXVlc3RzLCBvbmx5IGlmXG4gICAgLy8gdGhlIHByZWZldGNoIHJlc3VsdCBhY3R1YWxseSB2YXJpZXMgb24gb25lIG9mIHRoZXNlIGlucHV0cy5cbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0NMSUVOVF9TRUdNRU5UX0NBQ0hFKSB7XG4gICAgICBwaW5nVmlzaWJsZUxpbmtzKGFwcFJvdXRlclN0YXRlLm5leHRVcmwsIGFwcFJvdXRlclN0YXRlLnRyZWUpXG4gICAgfVxuICB9LCBbYXBwUm91dGVyU3RhdGUubmV4dFVybCwgYXBwUm91dGVyU3RhdGUudHJlZV0pXG5cbiAgcmV0dXJuIG51bGxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUVtcHR5Q2FjaGVOb2RlKCk6IENhY2hlTm9kZSB7XG4gIHJldHVybiB7XG4gICAgbGF6eURhdGE6IG51bGwsXG4gICAgcnNjOiBudWxsLFxuICAgIHByZWZldGNoUnNjOiBudWxsLFxuICAgIGhlYWQ6IG51bGwsXG4gICAgcHJlZmV0Y2hIZWFkOiBudWxsLFxuICAgIHBhcmFsbGVsUm91dGVzOiBuZXcgTWFwKCksXG4gICAgbG9hZGluZzogbnVsbCxcbiAgICBuYXZpZ2F0ZWRBdDogLTEsXG4gIH1cbn1cblxuZnVuY3Rpb24gY29weU5leHRKc0ludGVybmFsSGlzdG9yeVN0YXRlKGRhdGE6IGFueSkge1xuICBpZiAoZGF0YSA9PSBudWxsKSBkYXRhID0ge31cbiAgY29uc3QgY3VycmVudFN0YXRlID0gd2luZG93Lmhpc3Rvcnkuc3RhdGVcbiAgY29uc3QgX19OQSA9IGN1cnJlbnRTdGF0ZT8uX19OQVxuICBpZiAoX19OQSkge1xuICAgIGRhdGEuX19OQSA9IF9fTkFcbiAgfVxuICBjb25zdCBfX1BSSVZBVEVfTkVYVEpTX0lOVEVSTkFMU19UUkVFID1cbiAgICBjdXJyZW50U3RhdGU/Ll9fUFJJVkFURV9ORVhUSlNfSU5URVJOQUxTX1RSRUVcbiAgaWYgKF9fUFJJVkFURV9ORVhUSlNfSU5URVJOQUxTX1RSRUUpIHtcbiAgICBkYXRhLl9fUFJJVkFURV9ORVhUSlNfSU5URVJOQUxTX1RSRUUgPSBfX1BSSVZBVEVfTkVYVEpTX0lOVEVSTkFMU19UUkVFXG4gIH1cblxuICByZXR1cm4gZGF0YVxufVxuXG5mdW5jdGlvbiBIZWFkKHtcbiAgaGVhZENhY2hlTm9kZSxcbn06IHtcbiAgaGVhZENhY2hlTm9kZTogQ2FjaGVOb2RlIHwgbnVsbFxufSk6IFJlYWN0LlJlYWN0Tm9kZSB7XG4gIC8vIElmIHRoaXMgc2VnbWVudCBoYXMgYSBgcHJlZmV0Y2hIZWFkYCwgaXQncyB0aGUgc3RhdGljYWxseSBwcmVmZXRjaGVkIGRhdGEuXG4gIC8vIFdlIHNob3VsZCB1c2UgdGhhdCBvbiBpbml0aWFsIHJlbmRlciBpbnN0ZWFkIG9mIGBoZWFkYC4gVGhlbiB3ZSdsbCBzd2l0Y2hcbiAgLy8gdG8gYGhlYWRgIHdoZW4gdGhlIGR5bmFtaWMgcmVzcG9uc2Ugc3RyZWFtcyBpbi5cbiAgY29uc3QgaGVhZCA9IGhlYWRDYWNoZU5vZGUgIT09IG51bGwgPyBoZWFkQ2FjaGVOb2RlLmhlYWQgOiBudWxsXG4gIGNvbnN0IHByZWZldGNoSGVhZCA9XG4gICAgaGVhZENhY2hlTm9kZSAhPT0gbnVsbCA/IGhlYWRDYWNoZU5vZGUucHJlZmV0Y2hIZWFkIDogbnVsbFxuXG4gIC8vIElmIG5vIHByZWZldGNoIGRhdGEgaXMgYXZhaWxhYmxlLCB0aGVuIHdlIGdvIHN0cmFpZ2h0IHRvIHJlbmRlcmluZyBgaGVhZGAuXG4gIGNvbnN0IHJlc29sdmVkUHJlZmV0Y2hSc2MgPSBwcmVmZXRjaEhlYWQgIT09IG51bGwgPyBwcmVmZXRjaEhlYWQgOiBoZWFkXG5cbiAgLy8gV2UgdXNlIGB1c2VEZWZlcnJlZFZhbHVlYCB0byBoYW5kbGUgc3dpdGNoaW5nIGJldHdlZW4gdGhlIHByZWZldGNoZWQgYW5kXG4gIC8vIGZpbmFsIHZhbHVlcy4gVGhlIHNlY29uZCBhcmd1bWVudCBpcyByZXR1cm5lZCBvbiBpbml0aWFsIHJlbmRlciwgdGhlbiBpdFxuICAvLyByZS1yZW5kZXJzIHdpdGggdGhlIGZpcnN0IGFyZ3VtZW50LlxuICByZXR1cm4gdXNlRGVmZXJyZWRWYWx1ZShoZWFkLCByZXNvbHZlZFByZWZldGNoUnNjKVxufVxuXG4vKipcbiAqIFRoZSBnbG9iYWwgcm91dGVyIHRoYXQgd3JhcHMgdGhlIGFwcGxpY2F0aW9uIGNvbXBvbmVudHMuXG4gKi9cbmZ1bmN0aW9uIFJvdXRlcih7XG4gIGFjdGlvblF1ZXVlLFxuICBhc3NldFByZWZpeCxcbiAgZ2xvYmFsRXJyb3IsXG4gIGdyYWNlZnVsbHlEZWdyYWRlLFxufToge1xuICBhY3Rpb25RdWV1ZTogQXBwUm91dGVyQWN0aW9uUXVldWVcbiAgYXNzZXRQcmVmaXg6IHN0cmluZ1xuICBnbG9iYWxFcnJvcjogR2xvYmFsRXJyb3JTdGF0ZVxuICBncmFjZWZ1bGx5RGVncmFkZTogYm9vbGVhblxufSkge1xuICBjb25zdCBzdGF0ZSA9IHVzZUFjdGlvblF1ZXVlKGFjdGlvblF1ZXVlKVxuICBjb25zdCB7IGNhbm9uaWNhbFVybCB9ID0gc3RhdGVcbiAgLy8gQWRkIG1lbW9pemVkIHBhdGhuYW1lL3F1ZXJ5IGZvciB1c2VTZWFyY2hQYXJhbXMgYW5kIHVzZVBhdGhuYW1lLlxuICBjb25zdCB7IHNlYXJjaFBhcmFtcywgcGF0aG5hbWUgfSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoXG4gICAgICBjYW5vbmljYWxVcmwsXG4gICAgICB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/ICdodHRwOi8vbicgOiB3aW5kb3cubG9jYXRpb24uaHJlZlxuICAgIClcblxuICAgIHJldHVybiB7XG4gICAgICAvLyBUaGlzIGlzIHR1cm5lZCBpbnRvIGEgcmVhZG9ubHkgY2xhc3MgaW4gYHVzZVNlYXJjaFBhcmFtc2BcbiAgICAgIHNlYXJjaFBhcmFtczogdXJsLnNlYXJjaFBhcmFtcyxcbiAgICAgIHBhdGhuYW1lOiBoYXNCYXNlUGF0aCh1cmwucGF0aG5hbWUpXG4gICAgICAgID8gcmVtb3ZlQmFzZVBhdGgodXJsLnBhdGhuYW1lKVxuICAgICAgICA6IHVybC5wYXRobmFtZSxcbiAgICB9XG4gIH0sIFtjYW5vbmljYWxVcmxdKVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgY29uc3QgeyBjYWNoZSwgcHJlZmV0Y2hDYWNoZSwgdHJlZSB9ID0gc3RhdGVcblxuICAgIC8vIFRoaXMgaG9vayBpcyBpbiBhIGNvbmRpdGlvbmFsIGJ1dCB0aGF0IGlzIG9rIGJlY2F1c2UgYHByb2Nlc3MuZW52Lk5PREVfRU5WYCBuZXZlciBjaGFuZ2VzXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIC8vIEFkZCBgd2luZG93Lm5kYCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLlxuICAgICAgLy8gVGhpcyBpcyBub3QgbWVhbnQgZm9yIHVzZSBpbiBhcHBsaWNhdGlvbnMgYXMgY29uY3VycmVudCByZW5kZXJpbmcgd2lsbCBhZmZlY3QgdGhlIGNhY2hlL3RyZWUvcm91dGVyLlxuICAgICAgLy8gQHRzLWlnbm9yZSB0aGlzIGlzIGZvciBkZWJ1Z2dpbmdcbiAgICAgIHdpbmRvdy5uZCA9IHtcbiAgICAgICAgcm91dGVyOiBwdWJsaWNBcHBSb3V0ZXJJbnN0YW5jZSxcbiAgICAgICAgY2FjaGUsXG4gICAgICAgIHByZWZldGNoQ2FjaGUsXG4gICAgICAgIHRyZWUsXG4gICAgICB9XG4gICAgfSwgW2NhY2hlLCBwcmVmZXRjaENhY2hlLCB0cmVlXSlcbiAgfVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gSWYgdGhlIGFwcCBpcyByZXN0b3JlZCBmcm9tIGJmY2FjaGUsIGl0J3MgcG9zc2libGUgdGhhdFxuICAgIC8vIHB1c2hSZWYubXBhTmF2aWdhdGlvbiBpcyB0cnVlLCB3aGljaCB3b3VsZCBtZWFuIHRoYXQgYW55IHJlLXJlbmRlciBvZiB0aGlzIGNvbXBvbmVudFxuICAgIC8vIHdvdWxkIHRyaWdnZXIgdGhlIG1wYSBuYXZpZ2F0aW9uIGxvZ2ljIGFnYWluIGZyb20gdGhlIGxpbmVzIGJlbG93LlxuICAgIC8vIFRoaXMgd2lsbCByZXN0b3JlIHRoZSByb3V0ZXIgdG8gdGhlIGluaXRpYWwgc3RhdGUgaW4gdGhlIGV2ZW50IHRoYXQgdGhlIGFwcCBpcyByZXN0b3JlZCBmcm9tIGJmY2FjaGUuXG4gICAgZnVuY3Rpb24gaGFuZGxlUGFnZVNob3coZXZlbnQ6IFBhZ2VUcmFuc2l0aW9uRXZlbnQpIHtcbiAgICAgIGlmIChcbiAgICAgICAgIWV2ZW50LnBlcnNpc3RlZCB8fFxuICAgICAgICAhd2luZG93Lmhpc3Rvcnkuc3RhdGU/Ll9fUFJJVkFURV9ORVhUSlNfSU5URVJOQUxTX1RSRUVcbiAgICAgICkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gQ2xlYXIgdGhlIHBlbmRpbmdNcGFQYXRoIHZhbHVlIHNvIHRoYXQgYSBzdWJzZXF1ZW50IE1QQSBuYXZpZ2F0aW9uIHRvIHRoZSBzYW1lIFVSTCBjYW4gYmUgdHJpZ2dlcmVkLlxuICAgICAgLy8gVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBpZiB0aGUgYnJvd3NlciByZXN0b3JlZCBmcm9tIGJmY2FjaGUsIHRoZSBwZW5kaW5nTXBhUGF0aCB3b3VsZCBzdGlsbCBiZSBzZXQgdG8gdGhlIHZhbHVlXG4gICAgICAvLyBvZiB0aGUgbGFzdCBNUEEgbmF2aWdhdGlvbi5cbiAgICAgIGdsb2JhbE11dGFibGUucGVuZGluZ01wYVBhdGggPSB1bmRlZmluZWRcblxuICAgICAgZGlzcGF0Y2hBcHBSb3V0ZXJBY3Rpb24oe1xuICAgICAgICB0eXBlOiBBQ1RJT05fUkVTVE9SRSxcbiAgICAgICAgdXJsOiBuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKSxcbiAgICAgICAgdHJlZTogd2luZG93Lmhpc3Rvcnkuc3RhdGUuX19QUklWQVRFX05FWFRKU19JTlRFUk5BTFNfVFJFRSxcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BhZ2VzaG93JywgaGFuZGxlUGFnZVNob3cpXG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BhZ2VzaG93JywgaGFuZGxlUGFnZVNob3cpXG4gICAgfVxuICB9LCBbXSlcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIEVuc3VyZSB0aGF0IGFueSByZWRpcmVjdCBlcnJvcnMgdGhhdCBidWJibGUgdXAgb3V0c2lkZSBvZiB0aGUgUmVkaXJlY3RCb3VuZGFyeVxuICAgIC8vIGFyZSBjYXVnaHQgYW5kIGhhbmRsZWQgYnkgdGhlIHJvdXRlci5cbiAgICBmdW5jdGlvbiBoYW5kbGVVbmhhbmRsZWRSZWRpcmVjdChcbiAgICAgIGV2ZW50OiBFcnJvckV2ZW50IHwgUHJvbWlzZVJlamVjdGlvbkV2ZW50XG4gICAgKSB7XG4gICAgICBjb25zdCBlcnJvciA9ICdyZWFzb24nIGluIGV2ZW50ID8gZXZlbnQucmVhc29uIDogZXZlbnQuZXJyb3JcbiAgICAgIGlmIChpc1JlZGlyZWN0RXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgY29uc3QgdXJsID0gZ2V0VVJMRnJvbVJlZGlyZWN0RXJyb3IoZXJyb3IpXG4gICAgICAgIGNvbnN0IHJlZGlyZWN0VHlwZSA9IGdldFJlZGlyZWN0VHlwZUZyb21FcnJvcihlcnJvcilcbiAgICAgICAgLy8gVE9ETzogVGhpcyBzaG91bGQgYWNjZXNzIHRoZSByb3V0ZXIgbWV0aG9kcyBkaXJlY3RseSwgcmF0aGVyIHRoYW5cbiAgICAgICAgLy8gZ28gdGhyb3VnaCB0aGUgcHVibGljIGludGVyZmFjZS5cbiAgICAgICAgaWYgKHJlZGlyZWN0VHlwZSA9PT0gUmVkaXJlY3RUeXBlLnB1c2gpIHtcbiAgICAgICAgICBwdWJsaWNBcHBSb3V0ZXJJbnN0YW5jZS5wdXNoKHVybCwge30pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHVibGljQXBwUm91dGVySW5zdGFuY2UucmVwbGFjZSh1cmwsIHt9KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGhhbmRsZVVuaGFuZGxlZFJlZGlyZWN0KVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd1bmhhbmRsZWRyZWplY3Rpb24nLCBoYW5kbGVVbmhhbmRsZWRSZWRpcmVjdClcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBoYW5kbGVVbmhhbmRsZWRSZWRpcmVjdClcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd1bmhhbmRsZWRyZWplY3Rpb24nLCBoYW5kbGVVbmhhbmRsZWRSZWRpcmVjdClcbiAgICB9XG4gIH0sIFtdKVxuXG4gIC8vIFdoZW4gbXBhTmF2aWdhdGlvbiBmbGFnIGlzIHNldCBkbyBhIGhhcmQgbmF2aWdhdGlvbiB0byB0aGUgbmV3IHVybC5cbiAgLy8gSW5maW5pdGVseSBzdXNwZW5kIGJlY2F1c2Ugd2UgZG9uJ3QgYWN0dWFsbHkgd2FudCB0byByZXJlbmRlciBhbnkgY2hpbGRcbiAgLy8gY29tcG9uZW50cyB3aXRoIHRoZSBuZXcgVVJMIGFuZCBhbnkgZW50YW5nbGVkIHN0YXRlIHVwZGF0ZXMgc2hvdWxkbid0XG4gIC8vIGNvbW1pdCBlaXRoZXIgKGVnOiB1c2VUcmFuc2l0aW9uIGlzUGVuZGluZyBzaG91bGQgc3RheSB0cnVlIHVudGlsIHRoZSBwYWdlXG4gIC8vIHVubG9hZHMpLlxuICAvL1xuICAvLyBUaGlzIGlzIGEgc2lkZSBlZmZlY3QgaW4gcmVuZGVyLiBEb24ndCB0cnkgdGhpcyBhdCBob21lLCBraWRzLiBJdCdzXG4gIC8vIHByb2JhYmx5IHNhZmUgYmVjYXVzZSB3ZSBrbm93IHRoaXMgaXMgYSBzaW5nbGV0b24gY29tcG9uZW50IGFuZCBpdCdzIG5ldmVyXG4gIC8vIGluIDxPZmZzY3JlZW4+LiBBdCBsZWFzdCBJIGhvcGUgc28uIChJdCB3aWxsIHJ1biB0d2ljZSBpbiBkZXYgc3RyaWN0IG1vZGUsXG4gIC8vIGJ1dCB0aGF0J3MuLi4gZmluZT8pXG4gIGNvbnN0IHsgcHVzaFJlZiB9ID0gc3RhdGVcbiAgaWYgKHB1c2hSZWYubXBhTmF2aWdhdGlvbikge1xuICAgIC8vIGlmIHRoZXJlJ3MgYSByZS1yZW5kZXIsIHdlIGRvbid0IHdhbnQgdG8gdHJpZ2dlciBhbm90aGVyIHJlZGlyZWN0IGlmIG9uZSBpcyBhbHJlYWR5IGluIGZsaWdodCB0byB0aGUgc2FtZSBVUkxcbiAgICBpZiAoZ2xvYmFsTXV0YWJsZS5wZW5kaW5nTXBhUGF0aCAhPT0gY2Fub25pY2FsVXJsKSB7XG4gICAgICBjb25zdCBsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvblxuICAgICAgaWYgKHB1c2hSZWYucGVuZGluZ1B1c2gpIHtcbiAgICAgICAgbG9jYXRpb24uYXNzaWduKGNhbm9uaWNhbFVybClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvY2F0aW9uLnJlcGxhY2UoY2Fub25pY2FsVXJsKVxuICAgICAgfVxuXG4gICAgICBnbG9iYWxNdXRhYmxlLnBlbmRpbmdNcGFQYXRoID0gY2Fub25pY2FsVXJsXG4gICAgfVxuICAgIC8vIFRPRE8tQVBQOiBTaG91bGQgd2UgbGlzdGVuIHRvIG5hdmlnYXRlZXJyb3IgaGVyZSB0byBjYXRjaCBmYWlsZWRcbiAgICAvLyBuYXZpZ2F0aW9ucyBzb21laG93PyBBbmQgc2hvdWxkIHdlIGNhbGwgd2luZG93LnN0b3AoKSBpZiBhIFNQQSBuYXZpZ2F0aW9uXG4gICAgLy8gc2hvdWxkIGludGVycnVwdCBhbiBNUEEgb25lP1xuICAgIC8vIE5PVEU6IFRoaXMgaXMgaW50ZW50aW9uYWxseSB1c2luZyBgdGhyb3dgIGluc3RlYWQgb2YgYHVzZWAgYmVjYXVzZSB3ZSdyZVxuICAgIC8vIGluc2lkZSBhbiBleHRlcm5hbGx5IG11dGFibGUgY29uZGl0aW9uIChwdXNoUmVmLm1wYU5hdmlnYXRpb24pLCB3aGljaFxuICAgIC8vIHZpb2xhdGVzIHRoZSBydWxlcyBvZiBob29rcy5cbiAgICB0aHJvdyB1bnJlc29sdmVkVGhlbmFibGVcbiAgfVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3Qgb3JpZ2luYWxQdXNoU3RhdGUgPSB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUuYmluZCh3aW5kb3cuaGlzdG9yeSlcbiAgICBjb25zdCBvcmlnaW5hbFJlcGxhY2VTdGF0ZSA9IHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZS5iaW5kKFxuICAgICAgd2luZG93Lmhpc3RvcnlcbiAgICApXG5cbiAgICAvLyBFbnN1cmUgdGhlIGNhbm9uaWNhbCBVUkwgaW4gdGhlIE5leHQuanMgUm91dGVyIGlzIHVwZGF0ZWQgd2hlbiB0aGUgVVJMIGlzIGNoYW5nZWQgc28gdGhhdCBgdXNlUGF0aG5hbWVgIGFuZCBgdXNlU2VhcmNoUGFyYW1zYCBob2xkIHRoZSBwdXNoZWQgdmFsdWVzLlxuICAgIGNvbnN0IGFwcGx5VXJsRnJvbUhpc3RvcnlQdXNoUmVwbGFjZSA9IChcbiAgICAgIHVybDogc3RyaW5nIHwgVVJMIHwgbnVsbCB8IHVuZGVmaW5lZFxuICAgICkgPT4ge1xuICAgICAgY29uc3QgaHJlZiA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmXG4gICAgICBjb25zdCB0cmVlOiBGbGlnaHRSb3V0ZXJTdGF0ZSB8IHVuZGVmaW5lZCA9XG4gICAgICAgIHdpbmRvdy5oaXN0b3J5LnN0YXRlPy5fX1BSSVZBVEVfTkVYVEpTX0lOVEVSTkFMU19UUkVFXG5cbiAgICAgIHN0YXJ0VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICAgIGRpc3BhdGNoQXBwUm91dGVyQWN0aW9uKHtcbiAgICAgICAgICB0eXBlOiBBQ1RJT05fUkVTVE9SRSxcbiAgICAgICAgICB1cmw6IG5ldyBVUkwodXJsID8/IGhyZWYsIGhyZWYpLFxuICAgICAgICAgIHRyZWUsXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhdGNoIHB1c2hTdGF0ZSB0byBlbnN1cmUgZXh0ZXJuYWwgY2hhbmdlcyB0byB0aGUgaGlzdG9yeSBhcmUgcmVmbGVjdGVkIGluIHRoZSBOZXh0LmpzIFJvdXRlci5cbiAgICAgKiBFbnN1cmVzIE5leHQuanMgaW50ZXJuYWwgaGlzdG9yeSBzdGF0ZSBpcyBjb3BpZWQgdG8gdGhlIG5ldyBoaXN0b3J5IGVudHJ5LlxuICAgICAqIEVuc3VyZXMgdXNlUGF0aG5hbWUgYW5kIHVzZVNlYXJjaFBhcmFtcyBob2xkIHRoZSBuZXdseSBwcm92aWRlZCB1cmwuXG4gICAgICovXG4gICAgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlID0gZnVuY3Rpb24gcHVzaFN0YXRlKFxuICAgICAgZGF0YTogYW55LFxuICAgICAgX3VudXNlZDogc3RyaW5nLFxuICAgICAgdXJsPzogc3RyaW5nIHwgVVJMIHwgbnVsbFxuICAgICk6IHZvaWQge1xuICAgICAgLy8gQXZvaWQgYSBsb29wIHdoZW4gTmV4dC5qcyBpbnRlcm5hbHMgdHJpZ2dlciBwdXNoU3RhdGUvcmVwbGFjZVN0YXRlXG4gICAgICBpZiAoZGF0YT8uX19OQSB8fCBkYXRhPy5fTikge1xuICAgICAgICByZXR1cm4gb3JpZ2luYWxQdXNoU3RhdGUoZGF0YSwgX3VudXNlZCwgdXJsKVxuICAgICAgfVxuXG4gICAgICBkYXRhID0gY29weU5leHRKc0ludGVybmFsSGlzdG9yeVN0YXRlKGRhdGEpXG5cbiAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgYXBwbHlVcmxGcm9tSGlzdG9yeVB1c2hSZXBsYWNlKHVybClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9yaWdpbmFsUHVzaFN0YXRlKGRhdGEsIF91bnVzZWQsIHVybClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXRjaCByZXBsYWNlU3RhdGUgdG8gZW5zdXJlIGV4dGVybmFsIGNoYW5nZXMgdG8gdGhlIGhpc3RvcnkgYXJlIHJlZmxlY3RlZCBpbiB0aGUgTmV4dC5qcyBSb3V0ZXIuXG4gICAgICogRW5zdXJlcyBOZXh0LmpzIGludGVybmFsIGhpc3Rvcnkgc3RhdGUgaXMgY29waWVkIHRvIHRoZSBuZXcgaGlzdG9yeSBlbnRyeS5cbiAgICAgKiBFbnN1cmVzIHVzZVBhdGhuYW1lIGFuZCB1c2VTZWFyY2hQYXJhbXMgaG9sZCB0aGUgbmV3bHkgcHJvdmlkZWQgdXJsLlxuICAgICAqL1xuICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSA9IGZ1bmN0aW9uIHJlcGxhY2VTdGF0ZShcbiAgICAgIGRhdGE6IGFueSxcbiAgICAgIF91bnVzZWQ6IHN0cmluZyxcbiAgICAgIHVybD86IHN0cmluZyB8IFVSTCB8IG51bGxcbiAgICApOiB2b2lkIHtcbiAgICAgIC8vIEF2b2lkIGEgbG9vcCB3aGVuIE5leHQuanMgaW50ZXJuYWxzIHRyaWdnZXIgcHVzaFN0YXRlL3JlcGxhY2VTdGF0ZVxuICAgICAgaWYgKGRhdGE/Ll9fTkEgfHwgZGF0YT8uX04pIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsUmVwbGFjZVN0YXRlKGRhdGEsIF91bnVzZWQsIHVybClcbiAgICAgIH1cbiAgICAgIGRhdGEgPSBjb3B5TmV4dEpzSW50ZXJuYWxIaXN0b3J5U3RhdGUoZGF0YSlcblxuICAgICAgaWYgKHVybCkge1xuICAgICAgICBhcHBseVVybEZyb21IaXN0b3J5UHVzaFJlcGxhY2UodXJsKVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9yaWdpbmFsUmVwbGFjZVN0YXRlKGRhdGEsIF91bnVzZWQsIHVybClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgcG9wc3RhdGUgZXZlbnQsIHRoaXMgaXMgdXNlZCB0byBoYW5kbGUgYmFjay9mb3J3YXJkIGluIHRoZSBicm93c2VyLlxuICAgICAqIEJ5IGRlZmF1bHQgZGlzcGF0Y2hlcyBBQ1RJT05fUkVTVE9SRSwgaG93ZXZlciBpZiB0aGUgaGlzdG9yeSBlbnRyeSB3YXMgbm90IHB1c2hlZC9yZXBsYWNlZCBieSBhcHAtcm91dGVyIGl0IHdpbGwgcmVsb2FkIHRoZSBwYWdlLlxuICAgICAqIFRoYXQgY2FzZSBjYW4gaGFwcGVuIHdoZW4gdGhlIG9sZCByb3V0ZXIgaW5qZWN0ZWQgdGhlIGhpc3RvcnkgZW50cnkuXG4gICAgICovXG4gICAgY29uc3Qgb25Qb3BTdGF0ZSA9IChldmVudDogUG9wU3RhdGVFdmVudCkgPT4ge1xuICAgICAgaWYgKCFldmVudC5zdGF0ZSkge1xuICAgICAgICAvLyBUT0RPLUFQUDogdGhpcyBjYXNlIG9ubHkgaGFwcGVucyB3aGVuIHB1c2hTdGF0ZS9yZXBsYWNlU3RhdGUgd2FzIGNhbGxlZCBvdXRzaWRlIG9mIE5leHQuanMuIEl0IHNob3VsZCBwcm9iYWJseSByZWxvYWQgdGhlIHBhZ2UgaW4gdGhpcyBjYXNlLlxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gVGhpcyBjYXNlIGhhcHBlbnMgd2hlbiB0aGUgaGlzdG9yeSBlbnRyeSB3YXMgcHVzaGVkIGJ5IHRoZSBgcGFnZXNgIHJvdXRlci5cbiAgICAgIGlmICghZXZlbnQuc3RhdGUuX19OQSkge1xuICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIFRPRE8tQVBQOiBJZGVhbGx5IHRoZSBiYWNrIGJ1dHRvbiBzaG91bGQgbm90IHVzZSBzdGFydFRyYW5zaXRpb24gYXMgaXQgc2hvdWxkIGFwcGx5IHRoZSB1cGRhdGVzIHN5bmNocm9ub3VzbHlcbiAgICAgIC8vIFdpdGhvdXQgc3RhcnRUcmFuc2l0aW9uIHdvcmtzIGlmIHRoZSBjYWNoZSBpcyB0aGVyZSBmb3IgdGhpcyBwYXRoXG4gICAgICBzdGFydFRyYW5zaXRpb24oKCkgPT4ge1xuICAgICAgICBkaXNwYXRjaFRyYXZlcnNlQWN0aW9uKFxuICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmLFxuICAgICAgICAgIGV2ZW50LnN0YXRlLl9fUFJJVkFURV9ORVhUSlNfSU5URVJOQUxTX1RSRUVcbiAgICAgICAgKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyBSZWdpc3RlciBwb3BzdGF0ZSBldmVudCB0byBjYWxsIG9uUG9wc3RhdGUuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgb25Qb3BTdGF0ZSlcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlID0gb3JpZ2luYWxQdXNoU3RhdGVcbiAgICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSA9IG9yaWdpbmFsUmVwbGFjZVN0YXRlXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCBvblBvcFN0YXRlKVxuICAgIH1cbiAgfSwgW10pXG5cbiAgY29uc3QgeyBjYWNoZSwgdHJlZSwgbmV4dFVybCwgZm9jdXNBbmRTY3JvbGxSZWYgfSA9IHN0YXRlXG5cbiAgY29uc3QgbWF0Y2hpbmdIZWFkID0gdXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIGZpbmRIZWFkSW5DYWNoZShjYWNoZSwgdHJlZVsxXSlcbiAgfSwgW2NhY2hlLCB0cmVlXSlcblxuICAvLyBBZGQgbWVtb2l6ZWQgcGF0aFBhcmFtcyBmb3IgdXNlUGFyYW1zLlxuICBjb25zdCBwYXRoUGFyYW1zID0gdXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIGdldFNlbGVjdGVkUGFyYW1zKHRyZWUpXG4gIH0sIFt0cmVlXSlcblxuICBjb25zdCBsYXlvdXRSb3V0ZXJDb250ZXh0ID0gdXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhcmVudFRyZWU6IHRyZWUsXG4gICAgICBwYXJlbnRDYWNoZU5vZGU6IGNhY2hlLFxuICAgICAgcGFyZW50U2VnbWVudFBhdGg6IG51bGwsXG4gICAgICAvLyBSb290IG5vZGUgYWx3YXlzIGhhcyBgdXJsYFxuICAgICAgLy8gUHJvdmlkZWQgaW4gQXBwVHJlZUNvbnRleHQgdG8gZW5zdXJlIGl0IGNhbiBiZSBvdmVyd3JpdHRlbiBpbiBsYXlvdXQtcm91dGVyXG4gICAgICB1cmw6IGNhbm9uaWNhbFVybCxcbiAgICB9XG4gIH0sIFt0cmVlLCBjYWNoZSwgY2Fub25pY2FsVXJsXSlcblxuICBjb25zdCBnbG9iYWxMYXlvdXRSb3V0ZXJDb250ZXh0ID0gdXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRyZWUsXG4gICAgICBmb2N1c0FuZFNjcm9sbFJlZixcbiAgICAgIG5leHRVcmwsXG4gICAgfVxuICB9LCBbdHJlZSwgZm9jdXNBbmRTY3JvbGxSZWYsIG5leHRVcmxdKVxuXG4gIGxldCBoZWFkXG4gIGlmIChtYXRjaGluZ0hlYWQgIT09IG51bGwpIHtcbiAgICAvLyBUaGUgaGVhZCBpcyB3cmFwcGVkIGluIGFuIGV4dHJhIGNvbXBvbmVudCBzbyB3ZSBjYW4gdXNlXG4gICAgLy8gYHVzZURlZmVycmVkVmFsdWVgIHRvIHN3YXAgYmV0d2VlbiB0aGUgcHJlZmV0Y2hlZCBhbmQgZmluYWwgdmVyc2lvbnMgb2ZcbiAgICAvLyB0aGUgaGVhZC4gKFRoaXMgaXMgd2hhdCBMYXlvdXRSb3V0ZXIgZG9lcyBmb3Igc2VnbWVudCBkYXRhLCB0b28uKVxuICAgIC8vXG4gICAgLy8gVGhlIGBrZXlgIGlzIHVzZWQgdG8gcmVtb3VudCB0aGUgY29tcG9uZW50IHdoZW5ldmVyIHRoZSBoZWFkIG1vdmVzIHRvXG4gICAgLy8gYSBkaWZmZXJlbnQgc2VnbWVudC5cbiAgICBjb25zdCBbaGVhZENhY2hlTm9kZSwgaGVhZEtleV0gPSBtYXRjaGluZ0hlYWRcbiAgICBoZWFkID0gPEhlYWQga2V5PXtoZWFkS2V5fSBoZWFkQ2FjaGVOb2RlPXtoZWFkQ2FjaGVOb2RlfSAvPlxuICB9IGVsc2Uge1xuICAgIGhlYWQgPSBudWxsXG4gIH1cblxuICBsZXQgY29udGVudCA9IChcbiAgICA8UmVkaXJlY3RCb3VuZGFyeT5cbiAgICAgIHtoZWFkfVxuICAgICAge2NhY2hlLnJzY31cbiAgICAgIDxBcHBSb3V0ZXJBbm5vdW5jZXIgdHJlZT17dHJlZX0gLz5cbiAgICA8L1JlZGlyZWN0Qm91bmRhcnk+XG4gIClcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIEluIGRldmVsb3BtZW50LCB3ZSBhcHBseSBmZXcgZXJyb3IgYm91bmRhcmllcyBhbmQgaG90LXJlbG9hZGVyOlxuICAgIC8vIC0gRGV2Um9vdEhUVFBBY2Nlc3NGYWxsYmFja0JvdW5kYXJ5OiBhdm9pZCB1c2luZyBuYXZpZ2F0aW9uIEFQSSBsaWtlIG5vdEZvdW5kKCkgaW4gcm9vdCBsYXlvdXRcbiAgICAvLyAtIEhvdFJlbG9hZGVyOlxuICAgIC8vICAtIGhvdC1yZWxvYWQgdGhlIGFwcCB3aGVuIHRoZSBjb2RlIGNoYW5nZXNcbiAgICAvLyAgLSByZW5kZXIgZGV2IG92ZXJsYXlcbiAgICAvLyAgLSBjYXRjaCBydW50aW1lIGVycm9ycyBhbmQgZGlzcGxheSBnbG9iYWwtZXJyb3Igd2hlbiBuZWNlc3NhcnlcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnN0IHsgRGV2Um9vdEhUVFBBY2Nlc3NGYWxsYmFja0JvdW5kYXJ5IH0gPVxuICAgICAgICByZXF1aXJlKCcuL2Rldi1yb290LWh0dHAtYWNjZXNzLWZhbGxiYWNrLWJvdW5kYXJ5JykgYXMgdHlwZW9mIGltcG9ydCgnLi9kZXYtcm9vdC1odHRwLWFjY2Vzcy1mYWxsYmFjay1ib3VuZGFyeScpXG4gICAgICBjb250ZW50ID0gKFxuICAgICAgICA8RGV2Um9vdEhUVFBBY2Nlc3NGYWxsYmFja0JvdW5kYXJ5PlxuICAgICAgICAgIHtjb250ZW50fVxuICAgICAgICA8L0RldlJvb3RIVFRQQWNjZXNzRmFsbGJhY2tCb3VuZGFyeT5cbiAgICAgIClcbiAgICB9XG4gICAgY29uc3QgSG90UmVsb2FkZXI6IHR5cGVvZiBpbXBvcnQoJy4uL2Rldi9ob3QtcmVsb2FkZXIvYXBwL2hvdC1yZWxvYWRlci1hcHAnKS5kZWZhdWx0ID1cbiAgICAgIChcbiAgICAgICAgcmVxdWlyZSgnLi4vZGV2L2hvdC1yZWxvYWRlci9hcHAvaG90LXJlbG9hZGVyLWFwcCcpIGFzIHR5cGVvZiBpbXBvcnQoJy4uL2Rldi9ob3QtcmVsb2FkZXIvYXBwL2hvdC1yZWxvYWRlci1hcHAnKVxuICAgICAgKS5kZWZhdWx0XG5cbiAgICBjb250ZW50ID0gKFxuICAgICAgPEhvdFJlbG9hZGVyIGFzc2V0UHJlZml4PXthc3NldFByZWZpeH0gZ2xvYmFsRXJyb3I9e2dsb2JhbEVycm9yfT5cbiAgICAgICAge2NvbnRlbnR9XG4gICAgICA8L0hvdFJlbG9hZGVyPlxuICAgIClcbiAgfSBlbHNlIHtcbiAgICAvLyBJZiBncmFjZWZ1bGx5IGRlZ3JhZGluZyBpcyBhcHBsaWVkIGluIHByb2R1Y3Rpb24sXG4gICAgLy8gbGVhdmUgdGhlIGFwcCBhcyBpdCBpcyByYXRoZXIgdGhhbiBjYXVnaHQgYnkgR2xvYmFsRXJyb3IgYm91bmRhcnkuXG4gICAgaWYgKGdyYWNlZnVsbHlEZWdyYWRlKSB7XG4gICAgICBjb250ZW50ID0gPEdyYWNlZnVsRGVncmFkZUJvdW5kYXJ5Pntjb250ZW50fTwvR3JhY2VmdWxEZWdyYWRlQm91bmRhcnk+XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRlbnQgPSAoXG4gICAgICAgIDxFcnJvckJvdW5kYXJ5XG4gICAgICAgICAgZXJyb3JDb21wb25lbnQ9e2dsb2JhbEVycm9yWzBdfVxuICAgICAgICAgIGVycm9yU3R5bGVzPXtnbG9iYWxFcnJvclsxXX1cbiAgICAgICAgPlxuICAgICAgICAgIHtjb250ZW50fVxuICAgICAgICA8L0Vycm9yQm91bmRhcnk+XG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAgPEhpc3RvcnlVcGRhdGVyIGFwcFJvdXRlclN0YXRlPXtzdGF0ZX0gLz5cbiAgICAgIDxSdW50aW1lU3R5bGVzIC8+XG4gICAgICA8UGF0aFBhcmFtc0NvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3BhdGhQYXJhbXN9PlxuICAgICAgICA8UGF0aG5hbWVDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtwYXRobmFtZX0+XG4gICAgICAgICAgPFNlYXJjaFBhcmFtc0NvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3NlYXJjaFBhcmFtc30+XG4gICAgICAgICAgICA8R2xvYmFsTGF5b3V0Um91dGVyQ29udGV4dC5Qcm92aWRlclxuICAgICAgICAgICAgICB2YWx1ZT17Z2xvYmFsTGF5b3V0Um91dGVyQ29udGV4dH1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgey8qIFRPRE86IFdlIHNob3VsZCBiZSBhYmxlIHRvIHJlbW92ZSB0aGlzIGNvbnRleHQuIHVzZVJvdXRlclxuICAgICAgICAgICAgICAgICAgc2hvdWxkIGltcG9ydCBmcm9tIGFwcC1yb3V0ZXItaW5zdGFuY2UgaW5zdGVhZC4gSXQncyBvbmx5XG4gICAgICAgICAgICAgICAgICBuZWNlc3NhcnkgYmVjYXVzZSB1c2VSb3V0ZXIgaXMgc2hhcmVkIGJldHdlZW4gUGFnZXMgYW5kXG4gICAgICAgICAgICAgICAgICBBcHAgUm91dGVyLiBXZSBzaG91bGQgZm9yayB0aGF0IG1vZHVsZSwgdGhlbiByZW1vdmUgdGhpc1xuICAgICAgICAgICAgICAgICAgY29udGV4dCBwcm92aWRlci4gKi99XG4gICAgICAgICAgICAgIDxBcHBSb3V0ZXJDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtwdWJsaWNBcHBSb3V0ZXJJbnN0YW5jZX0+XG4gICAgICAgICAgICAgICAgPExheW91dFJvdXRlckNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2xheW91dFJvdXRlckNvbnRleHR9PlxuICAgICAgICAgICAgICAgICAge2NvbnRlbnR9XG4gICAgICAgICAgICAgICAgPC9MYXlvdXRSb3V0ZXJDb250ZXh0LlByb3ZpZGVyPlxuICAgICAgICAgICAgICA8L0FwcFJvdXRlckNvbnRleHQuUHJvdmlkZXI+XG4gICAgICAgICAgICA8L0dsb2JhbExheW91dFJvdXRlckNvbnRleHQuUHJvdmlkZXI+XG4gICAgICAgICAgPC9TZWFyY2hQYXJhbXNDb250ZXh0LlByb3ZpZGVyPlxuICAgICAgICA8L1BhdGhuYW1lQ29udGV4dC5Qcm92aWRlcj5cbiAgICAgIDwvUGF0aFBhcmFtc0NvbnRleHQuUHJvdmlkZXI+XG4gICAgPC8+XG4gIClcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQXBwUm91dGVyKHtcbiAgYWN0aW9uUXVldWUsXG4gIGdsb2JhbEVycm9yU3RhdGUsXG4gIGFzc2V0UHJlZml4LFxuICBncmFjZWZ1bGx5RGVncmFkZSxcbn06IHtcbiAgYWN0aW9uUXVldWU6IEFwcFJvdXRlckFjdGlvblF1ZXVlXG4gIGdsb2JhbEVycm9yU3RhdGU6IEdsb2JhbEVycm9yU3RhdGVcbiAgYXNzZXRQcmVmaXg6IHN0cmluZ1xuICBncmFjZWZ1bGx5RGVncmFkZTogYm9vbGVhblxufSkge1xuICB1c2VOYXZGYWlsdXJlSGFuZGxlcigpXG5cbiAgY29uc3Qgcm91dGVyID0gKFxuICAgIDxSb3V0ZXJcbiAgICAgIGFjdGlvblF1ZXVlPXthY3Rpb25RdWV1ZX1cbiAgICAgIGFzc2V0UHJlZml4PXthc3NldFByZWZpeH1cbiAgICAgIGdsb2JhbEVycm9yPXtnbG9iYWxFcnJvclN0YXRlfVxuICAgICAgZ3JhY2VmdWxseURlZ3JhZGU9e2dyYWNlZnVsbHlEZWdyYWRlfVxuICAgIC8+XG4gIClcblxuICBpZiAoZ3JhY2VmdWxseURlZ3JhZGUpIHtcbiAgICByZXR1cm4gcm91dGVyXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxFcnJvckJvdW5kYXJ5XG4gICAgICAgIC8vIEF0IHRoZSB2ZXJ5IHRvcCBsZXZlbCwgdXNlIHRoZSBkZWZhdWx0IEdsb2JhbEVycm9yIGNvbXBvbmVudCBhcyB0aGUgZmluYWwgZmFsbGJhY2suXG4gICAgICAgIC8vIFdoZW4gdGhlIGFwcCByb3V0ZXIgaXRzZWxmIGZhaWxzLCB3aGljaCBtZWFucyB0aGUgZnJhbWV3b3JrIGl0c2VsZiBmYWlscywgd2Ugc2hvdyB0aGUgZGVmYXVsdCBlcnJvci5cbiAgICAgICAgZXJyb3JDb21wb25lbnQ9e0RlZmF1bHRHbG9iYWxFcnJvcn1cbiAgICAgID5cbiAgICAgICAge3JvdXRlcn1cbiAgICAgIDwvRXJyb3JCb3VuZGFyeT5cbiAgICApXG4gIH1cbn1cblxuY29uc3QgcnVudGltZVN0eWxlcyA9IG5ldyBTZXQ8c3RyaW5nPigpXG5sZXQgcnVudGltZVN0eWxlQ2hhbmdlZCA9IG5ldyBTZXQ8KCkgPT4gdm9pZD4oKVxuXG5nbG9iYWxUaGlzLl9OX0VfU1RZTEVfTE9BRCA9IGZ1bmN0aW9uIChocmVmOiBzdHJpbmcpIHtcbiAgbGV0IGxlbiA9IHJ1bnRpbWVTdHlsZXMuc2l6ZVxuICBydW50aW1lU3R5bGVzLmFkZChocmVmKVxuICBpZiAocnVudGltZVN0eWxlcy5zaXplICE9PSBsZW4pIHtcbiAgICBydW50aW1lU3R5bGVDaGFuZ2VkLmZvckVhY2goKGNiKSA9PiBjYigpKVxuICB9XG4gIC8vIFRPRE8gZmlndXJlIG91dCBob3cgdG8gZ2V0IGEgcHJvbWlzZSBoZXJlXG4gIC8vIEJ1dCBtYXliZSBpdCdzIG5vdCBuZWNlc3NhcnkgYXMgcmVhY3Qgd291bGQgYmxvY2sgcmVuZGVyaW5nIHVudGlsIGl0J3MgbG9hZGVkXG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxufVxuXG5mdW5jdGlvbiBSdW50aW1lU3R5bGVzKCkge1xuICBjb25zdCBbLCBmb3JjZVVwZGF0ZV0gPSBSZWFjdC51c2VTdGF0ZSgwKVxuICBjb25zdCByZW5kZXJlZFN0eWxlc1NpemUgPSBydW50aW1lU3R5bGVzLnNpemVcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBjaGFuZ2VkID0gKCkgPT4gZm9yY2VVcGRhdGUoKGMpID0+IGMgKyAxKVxuICAgIHJ1bnRpbWVTdHlsZUNoYW5nZWQuYWRkKGNoYW5nZWQpXG4gICAgaWYgKHJlbmRlcmVkU3R5bGVzU2l6ZSAhPT0gcnVudGltZVN0eWxlcy5zaXplKSB7XG4gICAgICBjaGFuZ2VkKClcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHJ1bnRpbWVTdHlsZUNoYW5nZWQuZGVsZXRlKGNoYW5nZWQpXG4gICAgfVxuICB9LCBbcmVuZGVyZWRTdHlsZXNTaXplLCBmb3JjZVVwZGF0ZV0pXG5cbiAgY29uc3QgZHBsSWQgPSBwcm9jZXNzLmVudi5ORVhUX0RFUExPWU1FTlRfSURcbiAgICA/IGA/ZHBsPSR7cHJvY2Vzcy5lbnYuTkVYVF9ERVBMT1lNRU5UX0lEfWBcbiAgICA6ICcnXG4gIHJldHVybiBbLi4ucnVudGltZVN0eWxlc10ubWFwKChocmVmLCBpKSA9PiAoXG4gICAgPGxpbmtcbiAgICAgIGtleT17aX1cbiAgICAgIHJlbD1cInN0eWxlc2hlZXRcIlxuICAgICAgaHJlZj17YCR7aHJlZn0ke2RwbElkfWB9XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBwcmVjZWRlbmNlPVwibmV4dFwiXG4gICAgICAvLyBUT0RPIGZpZ3VyZSBvdXQgY3Jvc3NPcmlnaW4gYW5kIG5vbmNlXG4gICAgICAvLyBjcm9zc09yaWdpbj17VE9ET31cbiAgICAgIC8vIG5vbmNlPXtUT0RPfVxuICAgIC8+XG4gICkpXG59XG4iXSwibmFtZXMiOlsiY3JlYXRlRW1wdHlDYWNoZU5vZGUiLCJjcmVhdGVQcmVmZXRjaFVSTCIsIkFwcFJvdXRlciIsImlzRXh0ZXJuYWxVUkwiLCJnbG9iYWxNdXRhYmxlIiwidXJsIiwib3JpZ2luIiwid2luZG93IiwibG9jYXRpb24iLCJocmVmIiwiaXNCb3QiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJVUkwiLCJhZGRCYXNlUGF0aCIsIl8iLCJFcnJvciIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsIkhpc3RvcnlVcGRhdGVyIiwiYXBwUm91dGVyU3RhdGUiLCJ1c2VJbnNlcnRpb25FZmZlY3QiLCJfX05FWFRfQVBQX05BVl9GQUlMX0hBTkRMSU5HIiwibmV4dCIsIl9fcGVuZGluZ1VybCIsInVuZGVmaW5lZCIsInRyZWUiLCJwdXNoUmVmIiwiY2Fub25pY2FsVXJsIiwiaGlzdG9yeVN0YXRlIiwicHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGUiLCJoaXN0b3J5Iiwic3RhdGUiLCJfX05BIiwiX19QUklWQVRFX05FWFRKU19JTlRFUk5BTFNfVFJFRSIsInBlbmRpbmdQdXNoIiwiY3JlYXRlSHJlZkZyb21VcmwiLCJwdXNoU3RhdGUiLCJyZXBsYWNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJfX05FWFRfQ0xJRU5UX1NFR01FTlRfQ0FDSEUiLCJwaW5nVmlzaWJsZUxpbmtzIiwibmV4dFVybCIsImxhenlEYXRhIiwicnNjIiwicHJlZmV0Y2hSc2MiLCJoZWFkIiwicHJlZmV0Y2hIZWFkIiwicGFyYWxsZWxSb3V0ZXMiLCJNYXAiLCJsb2FkaW5nIiwibmF2aWdhdGVkQXQiLCJjb3B5TmV4dEpzSW50ZXJuYWxIaXN0b3J5U3RhdGUiLCJkYXRhIiwiY3VycmVudFN0YXRlIiwiSGVhZCIsImhlYWRDYWNoZU5vZGUiLCJyZXNvbHZlZFByZWZldGNoUnNjIiwidXNlRGVmZXJyZWRWYWx1ZSIsIlJvdXRlciIsImFjdGlvblF1ZXVlIiwiYXNzZXRQcmVmaXgiLCJnbG9iYWxFcnJvciIsImdyYWNlZnVsbHlEZWdyYWRlIiwidXNlQWN0aW9uUXVldWUiLCJzZWFyY2hQYXJhbXMiLCJwYXRobmFtZSIsInVzZU1lbW8iLCJoYXNCYXNlUGF0aCIsInJlbW92ZUJhc2VQYXRoIiwiY2FjaGUiLCJwcmVmZXRjaENhY2hlIiwibmQiLCJyb3V0ZXIiLCJwdWJsaWNBcHBSb3V0ZXJJbnN0YW5jZSIsImhhbmRsZVBhZ2VTaG93IiwiZXZlbnQiLCJwZXJzaXN0ZWQiLCJwZW5kaW5nTXBhUGF0aCIsImRpc3BhdGNoQXBwUm91dGVyQWN0aW9uIiwidHlwZSIsIkFDVElPTl9SRVNUT1JFIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJoYW5kbGVVbmhhbmRsZWRSZWRpcmVjdCIsImVycm9yIiwicmVhc29uIiwiaXNSZWRpcmVjdEVycm9yIiwicHJldmVudERlZmF1bHQiLCJnZXRVUkxGcm9tUmVkaXJlY3RFcnJvciIsInJlZGlyZWN0VHlwZSIsImdldFJlZGlyZWN0VHlwZUZyb21FcnJvciIsIlJlZGlyZWN0VHlwZSIsInB1c2giLCJyZXBsYWNlIiwibXBhTmF2aWdhdGlvbiIsImFzc2lnbiIsInVucmVzb2x2ZWRUaGVuYWJsZSIsIm9yaWdpbmFsUHVzaFN0YXRlIiwiYmluZCIsIm9yaWdpbmFsUmVwbGFjZVN0YXRlIiwiYXBwbHlVcmxGcm9tSGlzdG9yeVB1c2hSZXBsYWNlIiwic3RhcnRUcmFuc2l0aW9uIiwiX3VudXNlZCIsIl9OIiwib25Qb3BTdGF0ZSIsInJlbG9hZCIsImRpc3BhdGNoVHJhdmVyc2VBY3Rpb24iLCJmb2N1c0FuZFNjcm9sbFJlZiIsIm1hdGNoaW5nSGVhZCIsImZpbmRIZWFkSW5DYWNoZSIsInBhdGhQYXJhbXMiLCJnZXRTZWxlY3RlZFBhcmFtcyIsImxheW91dFJvdXRlckNvbnRleHQiLCJwYXJlbnRUcmVlIiwicGFyZW50Q2FjaGVOb2RlIiwicGFyZW50U2VnbWVudFBhdGgiLCJnbG9iYWxMYXlvdXRSb3V0ZXJDb250ZXh0IiwiaGVhZEtleSIsImNvbnRlbnQiLCJSZWRpcmVjdEJvdW5kYXJ5IiwiQXBwUm91dGVyQW5ub3VuY2VyIiwiRGV2Um9vdEhUVFBBY2Nlc3NGYWxsYmFja0JvdW5kYXJ5IiwicmVxdWlyZSIsIkhvdFJlbG9hZGVyIiwiZGVmYXVsdCIsIkdyYWNlZnVsRGVncmFkZUJvdW5kYXJ5IiwiRXJyb3JCb3VuZGFyeSIsImVycm9yQ29tcG9uZW50IiwiZXJyb3JTdHlsZXMiLCJSdW50aW1lU3R5bGVzIiwiUGF0aFBhcmFtc0NvbnRleHQiLCJQcm92aWRlciIsInZhbHVlIiwiUGF0aG5hbWVDb250ZXh0IiwiU2VhcmNoUGFyYW1zQ29udGV4dCIsIkdsb2JhbExheW91dFJvdXRlckNvbnRleHQiLCJBcHBSb3V0ZXJDb250ZXh0IiwiTGF5b3V0Um91dGVyQ29udGV4dCIsImdsb2JhbEVycm9yU3RhdGUiLCJ1c2VOYXZGYWlsdXJlSGFuZGxlciIsIkRlZmF1bHRHbG9iYWxFcnJvciIsInJ1bnRpbWVTdHlsZXMiLCJTZXQiLCJydW50aW1lU3R5bGVDaGFuZ2VkIiwiZ2xvYmFsVGhpcyIsIl9OX0VfU1RZTEVfTE9BRCIsImxlbiIsInNpemUiLCJhZGQiLCJmb3JFYWNoIiwiY2IiLCJQcm9taXNlIiwicmVzb2x2ZSIsImZvcmNlVXBkYXRlIiwiUmVhY3QiLCJ1c2VTdGF0ZSIsInJlbmRlcmVkU3R5bGVzU2l6ZSIsImNoYW5nZWQiLCJjIiwiZGVsZXRlIiwiZHBsSWQiLCJORVhUX0RFUExPWU1FTlRfSUQiLCJtYXAiLCJpIiwibGluayIsInJlbCIsInByZWNlZGVuY2UiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7SUE2SWdCQSxvQkFBb0IsRUFBQTtlQUFwQkE7O0lBOUVBQyxpQkFBaUIsRUFBQTtlQUFqQkE7O0lBb2ZoQixPQW1DQyxFQUFBO2VBbkN1QkM7O0lBL2ZSQyxhQUFhLEVBQUE7ZUFBYkE7Ozs7OztpRUE1Q1Q7K0NBS0E7b0NBRXdCO21DQUVHO2lEQUszQjtnQ0FDaUQ7K0JBQzFCO3NFQUNDO3VCQUNUOzZCQUNNO29DQUNPO2tDQUNGO2lDQUNEO29DQUNHO2dDQUNKOzZCQUNIO29DQUNNO21DQUVHO21DQU05QjswQkFDMkQ7K0JBQ3BCO3VCQUNiO2tGQUNHO0FBRXBDLE1BQU1DLGdCQUVGLENBQUM7QUFFRSxTQUFTRCxjQUFjRSxHQUFRO0lBQ3BDLE9BQU9BLElBQUlDLE1BQU0sS0FBS0MsT0FBT0MsUUFBUSxDQUFDRixNQUFNO0FBQzlDO0FBU08sU0FBU0wsa0JBQWtCUSxJQUFZO0lBQzVDLGtEQUFrRDtJQUNsRCxJQUFJQyxDQUFBQSxHQUFBQSxPQUFBQSxLQUFLLEVBQUNILE9BQU9JLFNBQVMsQ0FBQ0MsU0FBUyxHQUFHO1FBQ3JDLE9BQU87SUFDVDtJQUVBLElBQUlQO0lBQ0osSUFBSTtRQUNGQSxNQUFNLElBQUlRLElBQUlDLENBQUFBLEdBQUFBLGFBQUFBLFdBQVcsRUFBQ0wsT0FBT0YsT0FBT0MsUUFBUSxDQUFDQyxJQUFJO0lBQ3ZELEVBQUUsT0FBT00sR0FBRztRQUNWLDJFQUEyRTtRQUMzRSxrREFBa0Q7UUFDbEQsTUFBTSxPQUFBLGNBRUwsQ0FGSyxJQUFJQyxNQUNQLHNCQUFtQlAsT0FBSywrQ0FEckIscUJBQUE7bUJBQUE7d0JBQUE7MEJBQUE7UUFFTjtJQUNGO0lBRUEsdUVBQXVFO0lBQ3ZFLElBQUlRLFFBQVFDLEdBQUcsQ0FBQ0MsUUFBUSxLQUFLLFdBQWU7UUFDMUMsT0FBTztJQUNUOzs7QUFRRjtBQUVBLFNBQVNDLGVBQWUsS0FJdkI7SUFKdUIsSUFBQSxFQUN0QkMsY0FBYyxFQUdmLEdBSnVCO0lBS3RCQyxDQUFBQSxHQUFBQSxPQUFBQSxrQkFBa0IsRUFBQztRQUNqQixJQUFJTCxRQUFRQyxHQUFHLENBQUNLLDRCQUE0QixFQUFFOztRQU05QyxNQUFNLEVBQUVJLElBQUksRUFBRUMsT0FBTyxFQUFFQyxZQUFZLEVBQUUsR0FBR1I7UUFDeEMsTUFBTVMsZUFBZTtZQUNuQixHQUFJRixRQUFRRywwQkFBMEIsR0FBR3hCLE9BQU95QixPQUFPLENBQUNDLEtBQUssR0FBRyxDQUFDLENBQUM7WUFDbEUseUNBQXlDO1lBQ3pDLGtGQUFrRjtZQUNsRixpRkFBaUY7WUFDakZDLE1BQU07WUFDTkMsaUNBQWlDUjtRQUNuQztRQUNBLElBQ0VDLFFBQVFRLFdBQVcsSUFDbkIsK0ZBQStGO1FBQy9GLDJEQUEyRDtRQUMzREMsQ0FBQUEsR0FBQUEsbUJBQUFBLGlCQUFpQixFQUFDLElBQUl4QixJQUFJTixPQUFPQyxRQUFRLENBQUNDLElBQUksT0FBT29CLGNBQ3JEO1lBQ0EscUpBQXFKO1lBQ3JKRCxRQUFRUSxXQUFXLEdBQUc7WUFDdEI3QixPQUFPeUIsT0FBTyxDQUFDTSxTQUFTLENBQUNSLGNBQWMsSUFBSUQ7UUFDN0MsT0FBTztZQUNMdEIsT0FBT3lCLE9BQU8sQ0FBQ08sWUFBWSxDQUFDVCxjQUFjLElBQUlEO1FBQ2hEO0lBQ0YsR0FBRztRQUFDUjtLQUFlO0lBRW5CbUIsQ0FBQUEsR0FBQUEsT0FBQUEsU0FBUyxFQUFDO1FBQ1IscUVBQXFFO1FBQ3JFLHVFQUF1RTtRQUN2RSxtRUFBbUU7UUFDbkUsOERBQThEO1FBQzlELElBQUl2QixRQUFRQyxHQUFHLENBQUN1QiwyQkFBMkIsRUFBRTs7SUFHL0MsR0FBRztRQUFDcEIsZUFBZXNCLE9BQU87UUFBRXRCLGVBQWVNLElBQUk7S0FBQztJQUVoRCxPQUFPO0FBQ1Q7QUFFTyxTQUFTM0I7SUFDZCxPQUFPO1FBQ0w0QyxVQUFVO1FBQ1ZDLEtBQUs7UUFDTEMsYUFBYTtRQUNiQyxNQUFNO1FBQ05DLGNBQWM7UUFDZEMsZ0JBQWdCLElBQUlDO1FBQ3BCQyxTQUFTO1FBQ1RDLGFBQWEsQ0FBQztJQUNoQjtBQUNGO0FBRUEsU0FBU0MsK0JBQStCQyxJQUFTO0lBQy9DLElBQUlBLFFBQVEsTUFBTUEsT0FBTyxDQUFDO0lBQzFCLE1BQU1DLGVBQWVoRCxPQUFPeUIsT0FBTyxDQUFDQyxLQUFLO0lBQ3pDLE1BQU1DLE9BQU9xQixnQkFBQUEsT0FBQUEsS0FBQUEsSUFBQUEsYUFBY3JCLElBQUk7SUFDL0IsSUFBSUEsTUFBTTtRQUNSb0IsS0FBS3BCLElBQUksR0FBR0E7SUFDZDtJQUNBLE1BQU1DLGtDQUNKb0IsZ0JBQUFBLE9BQUFBLEtBQUFBLElBQUFBLGFBQWNwQiwrQkFBK0I7SUFDL0MsSUFBSUEsaUNBQWlDO1FBQ25DbUIsS0FBS25CLCtCQUErQixHQUFHQTtJQUN6QztJQUVBLE9BQU9tQjtBQUNUO0FBRUEsU0FBU0UsS0FBSyxLQUliO0lBSmEsSUFBQSxFQUNaQyxhQUFhLEVBR2QsR0FKYTtJQUtaLDZFQUE2RTtJQUM3RSw0RUFBNEU7SUFDNUUsa0RBQWtEO0lBQ2xELE1BQU1WLE9BQU9VLGtCQUFrQixPQUFPQSxjQUFjVixJQUFJLEdBQUc7SUFDM0QsTUFBTUMsZUFDSlMsa0JBQWtCLE9BQU9BLGNBQWNULFlBQVksR0FBRztJQUV4RCw2RUFBNkU7SUFDN0UsTUFBTVUsc0JBQXNCVixpQkFBaUIsT0FBT0EsZUFBZUQ7SUFFbkUsMkVBQTJFO0lBQzNFLDJFQUEyRTtJQUMzRSxzQ0FBc0M7SUFDdEMsT0FBT1ksQ0FBQUEsR0FBQUEsT0FBQUEsZ0JBQWdCLEVBQUNaLE1BQU1XO0FBQ2hDO0FBRUE7O0NBRUMsR0FDRCxTQUFTRSxPQUFPLEtBVWY7SUFWZSxJQUFBLEVBQ2RDLFdBQVcsRUFDWEMsV0FBVyxFQUNYQyxXQUFXLEVBQ1hDLGlCQUFpQixFQU1sQixHQVZlO0lBV2QsTUFBTS9CLFFBQVFnQyxDQUFBQSxHQUFBQSxnQkFBQUEsY0FBYyxFQUFDSjtJQUM3QixNQUFNLEVBQUVoQyxZQUFZLEVBQUUsR0FBR0k7SUFDekIsbUVBQW1FO0lBQ25FLE1BQU0sRUFBRWlDLFlBQVksRUFBRUMsUUFBUSxFQUFFLEdBQUdDLENBQUFBLEdBQUFBLE9BQUFBLE9BQU8sRUFBQztRQUN6QyxNQUFNL0QsTUFBTSxJQUFJUSxJQUNkZ0IsY0FDQSxPQUFPdEIsV0FBVyxxQkFBYyxhQUFhQSxPQUFPQyxRQUFRLENBQUNDLElBQUk7UUFHbkUsT0FBTztZQUNMLDREQUE0RDtZQUM1RHlELGNBQWM3RCxJQUFJNkQsWUFBWTtZQUM5QkMsVUFBVUUsQ0FBQUEsR0FBQUEsYUFBQUEsV0FBVyxFQUFDaEUsSUFBSThELFFBQVEsSUFDOUJHLENBQUFBLEdBQUFBLGdCQUFBQSxjQUFjLEVBQUNqRSxJQUFJOEQsUUFBUSxJQUMzQjlELElBQUk4RCxRQUFRO1FBQ2xCO0lBQ0YsR0FBRztRQUFDdEM7S0FBYTtJQUVqQixJQUFJWixRQUFRQyxHQUFHLENBQUNDLFFBQVEsS0FBSyxXQUFjO1FBQ3pDLHNEQUFzRDtRQUN0RCxNQUFNLEVBQUVvRCxLQUFLLEVBQUVDLGFBQWEsRUFBRTdDLElBQUksRUFBRSxHQUFHTTtRQUV2Qyw0RkFBNEY7UUFDNUYsc0RBQXNEO1FBQ3RETyxDQUFBQSxHQUFBQSxPQUFBQSxTQUFTLEVBQUM7WUFDUiwwQ0FBMEM7WUFDMUMsdUdBQXVHO1lBQ3ZHLG1DQUFtQztZQUNuQ2pDLE9BQU9rRSxFQUFFLEdBQUc7Z0JBQ1ZDLFFBQVFDLG1CQUFBQSx1QkFBdUI7Z0JBQy9CSjtnQkFDQUM7Z0JBQ0E3QztZQUNGO1FBQ0YsR0FBRztZQUFDNEM7WUFBT0M7WUFBZTdDO1NBQUs7SUFDakM7SUFFQWEsQ0FBQUEsR0FBQUEsT0FBQUEsU0FBUyxFQUFDO1FBQ1IsMERBQTBEO1FBQzFELHVGQUF1RjtRQUN2RixxRUFBcUU7UUFDckUsd0dBQXdHO1FBQ3hHLFNBQVNvQyxlQUFlQyxLQUEwQjtnQkFHN0N0RTtZQUZILElBQ0UsQ0FBQ3NFLE1BQU1DLFNBQVMsSUFDaEIsQ0FBQSxDQUFBLENBQUN2RSx3QkFBQUEsT0FBT3lCLE9BQU8sQ0FBQ0MsS0FBSyxLQUFBLE9BQUEsS0FBQSxJQUFwQjFCLHNCQUFzQjRCLCtCQUErQixHQUN0RDtnQkFDQTtZQUNGO1lBRUEsdUdBQXVHO1lBQ3ZHLHFIQUFxSDtZQUNySCw4QkFBOEI7WUFDOUIvQixjQUFjMkUsY0FBYyxHQUFHckQ7WUFFL0JzRCxDQUFBQSxHQUFBQSxnQkFBQUEsdUJBQXVCLEVBQUM7Z0JBQ3RCQyxNQUFNQyxvQkFBQUEsY0FBYztnQkFDcEI3RSxLQUFLLElBQUlRLElBQUlOLE9BQU9DLFFBQVEsQ0FBQ0MsSUFBSTtnQkFDakNrQixNQUFNcEIsT0FBT3lCLE9BQU8sQ0FBQ0MsS0FBSyxDQUFDRSwrQkFBK0I7WUFDNUQ7UUFDRjtRQUVBNUIsT0FBTzRFLGdCQUFnQixDQUFDLFlBQVlQO1FBRXBDLE9BQU87WUFDTHJFLE9BQU82RSxtQkFBbUIsQ0FBQyxZQUFZUjtRQUN6QztJQUNGLEdBQUcsRUFBRTtJQUVMcEMsQ0FBQUEsR0FBQUEsT0FBQUEsU0FBUyxFQUFDO1FBQ1IsaUZBQWlGO1FBQ2pGLHdDQUF3QztRQUN4QyxTQUFTNkMsd0JBQ1BSLEtBQXlDO1lBRXpDLE1BQU1TLFFBQVEsWUFBWVQsUUFBUUEsTUFBTVUsTUFBTSxHQUFHVixNQUFNUyxLQUFLO1lBQzVELElBQUlFLENBQUFBLEdBQUFBLGVBQUFBLGVBQWUsRUFBQ0YsUUFBUTtnQkFDMUJULE1BQU1ZLGNBQWM7Z0JBQ3BCLE1BQU1wRixNQUFNcUYsQ0FBQUEsR0FBQUEsVUFBQUEsdUJBQXVCLEVBQUNKO2dCQUNwQyxNQUFNSyxlQUFlQyxDQUFBQSxHQUFBQSxVQUFBQSx3QkFBd0IsRUFBQ047Z0JBQzlDLG9FQUFvRTtnQkFDcEUsbUNBQW1DO2dCQUNuQyxJQUFJSyxpQkFBaUJFLGVBQUFBLFlBQVksQ0FBQ0MsSUFBSSxFQUFFO29CQUN0Q25CLG1CQUFBQSx1QkFBdUIsQ0FBQ21CLElBQUksQ0FBQ3pGLEtBQUssQ0FBQztnQkFDckMsT0FBTztvQkFDTHNFLG1CQUFBQSx1QkFBdUIsQ0FBQ29CLE9BQU8sQ0FBQzFGLEtBQUssQ0FBQztnQkFDeEM7WUFDRjtRQUNGO1FBQ0FFLE9BQU80RSxnQkFBZ0IsQ0FBQyxTQUFTRTtRQUNqQzlFLE9BQU80RSxnQkFBZ0IsQ0FBQyxzQkFBc0JFO1FBRTlDLE9BQU87WUFDTDlFLE9BQU82RSxtQkFBbUIsQ0FBQyxTQUFTQztZQUNwQzlFLE9BQU82RSxtQkFBbUIsQ0FBQyxzQkFBc0JDO1FBQ25EO0lBQ0YsR0FBRyxFQUFFO0lBRUwsc0VBQXNFO0lBQ3RFLDBFQUEwRTtJQUMxRSx3RUFBd0U7SUFDeEUsNkVBQTZFO0lBQzdFLFlBQVk7SUFDWixFQUFFO0lBQ0Ysc0VBQXNFO0lBQ3RFLDZFQUE2RTtJQUM3RSw2RUFBNkU7SUFDN0UsdUJBQXVCO0lBQ3ZCLE1BQU0sRUFBRXpELE9BQU8sRUFBRSxHQUFHSztJQUNwQixJQUFJTCxRQUFRb0UsYUFBYSxFQUFFO1FBQ3pCLGdIQUFnSDtRQUNoSCxJQUFJNUYsY0FBYzJFLGNBQWMsS0FBS2xELGNBQWM7WUFDakQsTUFBTXJCLFdBQVdELE9BQU9DLFFBQVE7WUFDaEMsSUFBSW9CLFFBQVFRLFdBQVcsRUFBRTtnQkFDdkI1QixTQUFTeUYsTUFBTSxDQUFDcEU7WUFDbEIsT0FBTztnQkFDTHJCLFNBQVN1RixPQUFPLENBQUNsRTtZQUNuQjtZQUVBekIsY0FBYzJFLGNBQWMsR0FBR2xEO1FBQ2pDO1FBQ0EsbUVBQW1FO1FBQ25FLDRFQUE0RTtRQUM1RSwrQkFBK0I7UUFDL0IsMkVBQTJFO1FBQzNFLHdFQUF3RTtRQUN4RSwrQkFBK0I7UUFDL0IsTUFBTXFFLG9CQUFBQSxrQkFBa0I7SUFDMUI7SUFFQTFELENBQUFBLEdBQUFBLE9BQUFBLFNBQVMsRUFBQztRQUNSLE1BQU0yRCxvQkFBb0I1RixPQUFPeUIsT0FBTyxDQUFDTSxTQUFTLENBQUM4RCxJQUFJLENBQUM3RixPQUFPeUIsT0FBTztRQUN0RSxNQUFNcUUsdUJBQXVCOUYsT0FBT3lCLE9BQU8sQ0FBQ08sWUFBWSxDQUFDNkQsSUFBSSxDQUMzRDdGLE9BQU95QixPQUFPO1FBR2hCLHdKQUF3SjtRQUN4SixNQUFNc0UsaUNBQWlDLENBQ3JDakc7Z0JBSUVFO1lBRkYsTUFBTUUsT0FBT0YsT0FBT0MsUUFBUSxDQUFDQyxJQUFJO1lBQ2pDLE1BQU1rQixPQUFBQSxDQUNKcEIsd0JBQUFBLE9BQU95QixPQUFPLENBQUNDLEtBQUssS0FBQSxPQUFBLEtBQUEsSUFBcEIxQixzQkFBc0I0QiwrQkFBK0I7WUFFdkRvRSxDQUFBQSxHQUFBQSxPQUFBQSxlQUFlLEVBQUM7Z0JBQ2R2QixDQUFBQSxHQUFBQSxnQkFBQUEsdUJBQXVCLEVBQUM7b0JBQ3RCQyxNQUFNQyxvQkFBQUEsY0FBYztvQkFDcEI3RSxLQUFLLElBQUlRLElBQUlSLE9BQUFBLE9BQUFBLE1BQU9JLE1BQU1BO29CQUMxQmtCO2dCQUNGO1lBQ0Y7UUFDRjtRQUVBOzs7O0tBSUMsR0FDRHBCLE9BQU95QixPQUFPLENBQUNNLFNBQVMsR0FBRyxTQUFTQSxVQUNsQ2dCLElBQVMsRUFDVGtELE9BQWUsRUFDZm5HLEdBQXlCO1lBRXpCLHFFQUFxRTtZQUNyRSxJQUFJaUQsQ0FBQUEsUUFBQUEsT0FBQUEsS0FBQUEsSUFBQUEsS0FBTXBCLElBQUksS0FBQSxDQUFJb0IsUUFBQUEsT0FBQUEsS0FBQUEsSUFBQUEsS0FBTW1ELEVBQUUsR0FBRTtnQkFDMUIsT0FBT04sa0JBQWtCN0MsTUFBTWtELFNBQVNuRztZQUMxQztZQUVBaUQsT0FBT0QsK0JBQStCQztZQUV0QyxJQUFJakQsS0FBSztnQkFDUGlHLCtCQUErQmpHO1lBQ2pDO1lBRUEsT0FBTzhGLGtCQUFrQjdDLE1BQU1rRCxTQUFTbkc7UUFDMUM7UUFFQTs7OztLQUlDLEdBQ0RFLE9BQU95QixPQUFPLENBQUNPLFlBQVksR0FBRyxTQUFTQSxhQUNyQ2UsSUFBUyxFQUNUa0QsT0FBZSxFQUNmbkcsR0FBeUI7WUFFekIscUVBQXFFO1lBQ3JFLElBQUlpRCxDQUFBQSxRQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxLQUFNcEIsSUFBSSxLQUFBLENBQUlvQixRQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxLQUFNbUQsRUFBRSxHQUFFO2dCQUMxQixPQUFPSixxQkFBcUIvQyxNQUFNa0QsU0FBU25HO1lBQzdDO1lBQ0FpRCxPQUFPRCwrQkFBK0JDO1lBRXRDLElBQUlqRCxLQUFLO2dCQUNQaUcsK0JBQStCakc7WUFDakM7WUFDQSxPQUFPZ0cscUJBQXFCL0MsTUFBTWtELFNBQVNuRztRQUM3QztRQUVBOzs7O0tBSUMsR0FDRCxNQUFNcUcsYUFBYSxDQUFDN0I7WUFDbEIsSUFBSSxDQUFDQSxNQUFNNUMsS0FBSyxFQUFFO2dCQUNoQiwrSUFBK0k7Z0JBQy9JO1lBQ0Y7WUFFQSw2RUFBNkU7WUFDN0UsSUFBSSxDQUFDNEMsTUFBTTVDLEtBQUssQ0FBQ0MsSUFBSSxFQUFFO2dCQUNyQjNCLE9BQU9DLFFBQVEsQ0FBQ21HLE1BQU07Z0JBQ3RCO1lBQ0Y7WUFFQSxnSEFBZ0g7WUFDaEgsb0VBQW9FO1lBQ3BFSixDQUFBQSxHQUFBQSxPQUFBQSxlQUFlLEVBQUM7Z0JBQ2RLLENBQUFBLEdBQUFBLG1CQUFBQSxzQkFBc0IsRUFDcEJyRyxPQUFPQyxRQUFRLENBQUNDLElBQUksRUFDcEJvRSxNQUFNNUMsS0FBSyxDQUFDRSwrQkFBK0I7WUFFL0M7UUFDRjtRQUVBLDhDQUE4QztRQUM5QzVCLE9BQU80RSxnQkFBZ0IsQ0FBQyxZQUFZdUI7UUFDcEMsT0FBTztZQUNMbkcsT0FBT3lCLE9BQU8sQ0FBQ00sU0FBUyxHQUFHNkQ7WUFDM0I1RixPQUFPeUIsT0FBTyxDQUFDTyxZQUFZLEdBQUc4RDtZQUM5QjlGLE9BQU82RSxtQkFBbUIsQ0FBQyxZQUFZc0I7UUFDekM7SUFDRixHQUFHLEVBQUU7SUFFTCxNQUFNLEVBQUVuQyxLQUFLLEVBQUU1QyxJQUFJLEVBQUVnQixPQUFPLEVBQUVrRSxpQkFBaUIsRUFBRSxHQUFHNUU7SUFFcEQsTUFBTTZFLGVBQWUxQyxDQUFBQSxHQUFBQSxPQUFBQSxPQUFPLEVBQUM7UUFDM0IsT0FBTzJDLENBQUFBLEdBQUFBLGlCQUFBQSxlQUFlLEVBQUN4QyxPQUFPNUMsSUFBSSxDQUFDLEVBQUU7SUFDdkMsR0FBRztRQUFDNEM7UUFBTzVDO0tBQUs7SUFFaEIseUNBQXlDO0lBQ3pDLE1BQU1xRixhQUFhNUMsQ0FBQUEsR0FBQUEsT0FBQUEsT0FBTyxFQUFDO1FBQ3pCLE9BQU82QyxDQUFBQSxHQUFBQSxvQkFBQUEsaUJBQWlCLEVBQUN0RjtJQUMzQixHQUFHO1FBQUNBO0tBQUs7SUFFVCxNQUFNdUYsc0JBQXNCOUMsQ0FBQUEsR0FBQUEsT0FBQUEsT0FBTyxFQUFDO1FBQ2xDLE9BQU87WUFDTCtDLFlBQVl4RjtZQUNaeUYsaUJBQWlCN0M7WUFDakI4QyxtQkFBbUI7WUFDbkIsNkJBQTZCO1lBQzdCLDhFQUE4RTtZQUM5RWhILEtBQUt3QjtRQUNQO0lBQ0YsR0FBRztRQUFDRjtRQUFNNEM7UUFBTzFDO0tBQWE7SUFFOUIsTUFBTXlGLDRCQUE0QmxELENBQUFBLEdBQUFBLE9BQUFBLE9BQU8sRUFBQztRQUN4QyxPQUFPO1lBQ0x6QztZQUNBa0Y7WUFDQWxFO1FBQ0Y7SUFDRixHQUFHO1FBQUNoQjtRQUFNa0Y7UUFBbUJsRTtLQUFRO0lBRXJDLElBQUlJO0lBQ0osSUFBSStELGlCQUFpQixNQUFNO1FBQ3pCLDBEQUEwRDtRQUMxRCwwRUFBMEU7UUFDMUUsb0VBQW9FO1FBQ3BFLEVBQUU7UUFDRix3RUFBd0U7UUFDeEUsdUJBQXVCO1FBQ3ZCLE1BQU0sQ0FBQ3JELGVBQWU4RCxRQUFRLEdBQUdUO1FBQ2pDL0QsT0FBQUEsV0FBQUEsR0FBTyxDQUFBLEdBQUEsWUFBQSxHQUFBLEVBQUNTLE1BQUFBO1lBQW1CQyxlQUFlQTtXQUF4QjhEO0lBQ3BCLE9BQU87UUFDTHhFLE9BQU87SUFDVDtJQUVBLElBQUl5RSxVQUFBQSxXQUFBQSxHQUNGLENBQUEsR0FBQSxZQUFBLElBQUEsRUFBQ0Msa0JBQUFBLGdCQUFnQixFQUFBOztZQUNkMUU7WUFDQXdCLE1BQU0xQixHQUFHOzBCQUNWLENBQUEsR0FBQSxZQUFBLEdBQUEsRUFBQzZFLG9CQUFBQSxrQkFBa0IsRUFBQTtnQkFBQy9GLE1BQU1BOzs7O0lBSTlCLElBQUlWLFFBQVFDLEdBQUcsQ0FBQ0MsUUFBUSxLQUFLLFdBQWM7UUFDekMsa0VBQWtFO1FBQ2xFLGlHQUFpRztRQUNqRyxpQkFBaUI7UUFDakIsOENBQThDO1FBQzlDLHdCQUF3QjtRQUN4QixrRUFBa0U7UUFDbEUsSUFBSSxPQUFPWixXQUFXLGFBQWE7O1FBU25DLE1BQU1zSCxjQUVGRCxRQUFRLDJIQUNSRSxPQUFPO1FBRVhOLFVBQUFBLFdBQUFBLEdBQ0UsQ0FBQSxHQUFBLFlBQUEsR0FBQSxFQUFDSyxhQUFBQTtZQUFZL0QsYUFBYUE7WUFBYUMsYUFBYUE7c0JBQ2pEeUQ7O0lBR1AsT0FBTzs7SUFpQlAsT0FBQSxXQUFBLEdBQ0UsQ0FBQSxHQUFBLFlBQUEsSUFBQSxFQUFBLFlBQUEsUUFBQSxFQUFBOzswQkFDRSxDQUFBLEdBQUEsWUFBQSxHQUFBLEVBQUNwRyxnQkFBQUE7Z0JBQWVDLGdCQUFnQlk7OzBCQUNoQyxDQUFBLEdBQUEsWUFBQSxHQUFBLEVBQUNrRyxlQUFBQSxDQUFBQTswQkFDRCxDQUFBLEdBQUEsWUFBQSxHQUFBLEVBQUNDLGlDQUFBQSxpQkFBaUIsQ0FBQ0MsUUFBUSxFQUFBO2dCQUFDQyxPQUFPdEI7MEJBQ2pDLFdBQUEsR0FBQSxDQUFBLEdBQUEsWUFBQSxHQUFBLEVBQUN1QixpQ0FBQUEsZUFBZSxDQUFDRixRQUFRLEVBQUE7b0JBQUNDLE9BQU9uRTs4QkFDL0IsV0FBQSxHQUFBLENBQUEsR0FBQSxZQUFBLEdBQUEsRUFBQ3FFLGlDQUFBQSxtQkFBbUIsQ0FBQ0gsUUFBUSxFQUFBO3dCQUFDQyxPQUFPcEU7a0NBQ25DLFdBQUEsR0FBQSxDQUFBLEdBQUEsWUFBQSxHQUFBLEVBQUN1RSwrQkFBQUEseUJBQXlCLENBQUNKLFFBQVEsRUFBQTs0QkFDakNDLE9BQU9oQjtzQ0FPUCxXQUFBLEdBQUEsQ0FBQSxHQUFBLFlBQUEsR0FBQSxFQUFDb0IsK0JBQUFBLGdCQUFnQixDQUFDTCxRQUFRLEVBQUE7Z0NBQUNDLE9BQU8zRCxtQkFBQUEsdUJBQXVCOzBDQUN2RCxXQUFBLEdBQUEsQ0FBQSxHQUFBLFlBQUEsR0FBQSxFQUFDZ0UsK0JBQUFBLG1CQUFtQixDQUFDTixRQUFRLEVBQUE7b0NBQUNDLE9BQU9wQjs4Q0FDbENNOzs7Ozs7Ozs7QUFTbkI7QUFFZSxTQUFTdEgsVUFBVSxLQVVqQztJQVZpQyxJQUFBLEVBQ2hDMkQsV0FBVyxFQUNYK0UsZ0JBQWdCLEVBQ2hCOUUsV0FBVyxFQUNYRSxpQkFBaUIsRUFNbEIsR0FWaUM7SUFXaEM2RSxDQUFBQSxHQUFBQSxtQkFBQUEsb0JBQW9CO0lBRXBCLE1BQU1uRSxTQUFBQSxXQUFBQSxHQUNKLENBQUEsR0FBQSxZQUFBLEdBQUEsRUFBQ2QsUUFBQUE7UUFDQ0MsYUFBYUE7UUFDYkMsYUFBYUE7UUFDYkMsYUFBYTZFO1FBQ2I1RSxtQkFBbUJBOztJQUl2QixJQUFJQSxtQkFBbUI7UUFDckIsT0FBT1U7SUFDVCxPQUFPO1FBQ0wsT0FBQSxXQUFBLEdBQ0UsQ0FBQSxHQUFBLFlBQUEsR0FBQSxFQUFDc0QsZUFBQUEsYUFBYSxFQUFBO1lBQ1osc0ZBQXNGO1lBQ3RGLHVHQUF1RztZQUN2R0MsZ0JBQWdCYSxhQUFBQSxPQUFrQjtzQkFFakNwRTs7SUFHUDtBQUNGO0FBRUEsTUFBTXFFLGdCQUFnQixJQUFJQztBQUMxQixJQUFJQyxzQkFBc0IsSUFBSUQ7QUFFOUJFLFdBQVdDLGVBQWUsR0FBRyxTQUFVMUksSUFBWTtJQUNqRCxJQUFJMkksTUFBTUwsY0FBY00sSUFBSTtJQUM1Qk4sY0FBY08sR0FBRyxDQUFDN0k7SUFDbEIsSUFBSXNJLGNBQWNNLElBQUksS0FBS0QsS0FBSztRQUM5Qkgsb0JBQW9CTSxPQUFPLENBQUMsQ0FBQ0MsS0FBT0E7SUFDdEM7SUFDQSw0Q0FBNEM7SUFDNUMsZ0ZBQWdGO0lBQ2hGLE9BQU9DLFFBQVFDLE9BQU87QUFDeEI7QUFFQSxTQUFTdkI7SUFDUCxNQUFNLEdBQUd3QixZQUFZLEdBQUdDLE9BQUFBLE9BQUssQ0FBQ0MsUUFBUSxDQUFDO0lBQ3ZDLE1BQU1DLHFCQUFxQmYsY0FBY00sSUFBSTtJQUM3QzdHLENBQUFBLEdBQUFBLE9BQUFBLFNBQVMsRUFBQztRQUNSLE1BQU11SCxVQUFVLElBQU1KLFlBQVksQ0FBQ0ssSUFBTUEsSUFBSTtRQUM3Q2Ysb0JBQW9CSyxHQUFHLENBQUNTO1FBQ3hCLElBQUlELHVCQUF1QmYsY0FBY00sSUFBSSxFQUFFO1lBQzdDVTtRQUNGO1FBQ0EsT0FBTztZQUNMZCxvQkFBb0JnQixNQUFNLENBQUNGO1FBQzdCO0lBQ0YsR0FBRztRQUFDRDtRQUFvQkg7S0FBWTtJQUVwQyxNQUFNTyxRQUFRakosUUFBUUMsR0FBRyxDQUFDaUosa0JBQWtCLFFBQ3ZDLFVBQU9sSixRQUFRQyxHQUFHLENBQUNpSixJQUNwQixjQURzQztJQUUxQyxPQUFPO1dBQUlwQjtLQUFjLENBQUNxQixHQUFHLENBQUMsQ0FBQzNKLE1BQU00SixJQUFBQSxXQUFBQSxHQUNuQyxDQUFBLEdBQUEsWUFBQSxHQUFBLEVBQUNDLFFBQUFBO1lBRUNDLEtBQUk7WUFDSjlKLE1BQU8sS0FBRUEsT0FBT3lKO1lBQ2hCLGFBQWE7WUFDYk0sWUFBVztXQUpOSDtBQVVYIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDk5MDUsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcHByLW5hdmlnYXRpb25zLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHtcbiAgQ2FjaGVOb2RlU2VlZERhdGEsXG4gIEZsaWdodFJvdXRlclN0YXRlLFxuICBGbGlnaHRTZWdtZW50UGF0aCxcbiAgU2VnbWVudCxcbn0gZnJvbSAnLi4vLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvdHlwZXMnXG5pbXBvcnQgdHlwZSB7XG4gIENhY2hlTm9kZSxcbiAgQ2hpbGRTZWdtZW50TWFwLFxuICBIZWFkRGF0YSxcbiAgTG9hZGluZ01vZHVsZURhdGEsXG4gIFJlYWR5Q2FjaGVOb2RlLFxufSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB7IERFRkFVTFRfU0VHTUVOVF9LRVkgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvbGliL3NlZ21lbnQnXG5pbXBvcnQgeyBtYXRjaFNlZ21lbnQgfSBmcm9tICcuLi9tYXRjaC1zZWdtZW50cydcbmltcG9ydCB7IGNyZWF0ZVJvdXRlckNhY2hlS2V5IH0gZnJvbSAnLi9jcmVhdGUtcm91dGVyLWNhY2hlLWtleSdcbmltcG9ydCB0eXBlIHsgRmV0Y2hTZXJ2ZXJSZXNwb25zZVJlc3VsdCB9IGZyb20gJy4vZmV0Y2gtc2VydmVyLXJlc3BvbnNlJ1xuaW1wb3J0IHsgaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0IH0gZnJvbSAnLi9pcy1uYXZpZ2F0aW5nLXRvLW5ldy1yb290LWxheW91dCdcbmltcG9ydCB7IERZTkFNSUNfU1RBTEVUSU1FX01TIH0gZnJvbSAnLi9wcmVmZXRjaC1jYWNoZS11dGlscydcblxuLy8gVGhpcyBpcyB5ZXQgYW5vdGhlciB0cmVlIHR5cGUgdGhhdCBpcyB1c2VkIHRvIHRyYWNrIHBlbmRpbmcgcHJvbWlzZXMgdGhhdFxuLy8gbmVlZCB0byBiZSBmdWxmaWxsZWQgb25jZSB0aGUgZHluYW1pYyBkYXRhIGlzIHJlY2VpdmVkLiBUaGUgdGVybWluYWwgbm9kZXMgb2Zcbi8vIHRoaXMgdHJlZSByZXByZXNlbnQgdGhlIG5ldyBDYWNoZSBOb2RlIHRyZWVzIHRoYXQgd2VyZSBjcmVhdGVkIGR1cmluZyB0aGlzXG4vLyByZXF1ZXN0LiBXZSBjYW4ndCB1c2UgdGhlIENhY2hlIE5vZGUgdHJlZSBvciBSb3V0ZSBTdGF0ZSB0cmVlIGRpcmVjdGx5XG4vLyBiZWNhdXNlIHRob3NlIGluY2x1ZGUgcmV1c2VkIG5vZGVzLCB0b28uIFRoaXMgdHJlZSBpcyBkaXNjYXJkZWQgYXMgc29vbiBhc1xuLy8gdGhlIG5hdmlnYXRpb24gcmVzcG9uc2UgaXMgcmVjZWl2ZWQuXG50eXBlIFNQQU5hdmlnYXRpb25UYXNrID0ge1xuICAvLyBUaGUgcm91dGVyIHN0YXRlIHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlIHRyZWUgdGhhdCB0aGlzIFRhc2sgcmVwcmVzZW50cy5cbiAgcm91dGU6IEZsaWdodFJvdXRlclN0YXRlXG4gIC8vIFRoZSBDYWNoZU5vZGUgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgdHJlZSB0aGF0IHRoaXMgVGFzayByZXByZXNlbnRzLiBJZlxuICAvLyBgY2hpbGRyZW5gIGlzIG51bGwgKGkuZS4gaWYgdGhpcyBpcyBhIHRlcm1pbmFsIHRhc2sgbm9kZSksIHRoZW4gYG5vZGVgXG4gIC8vIHJlcHJlc2VudHMgYSBicmFuZCBuZXcgQ2FjaGUgTm9kZSB0cmVlLCB3aGljaCB3YXkgb3IgbWF5IG5vdCBuZWVkIHRvIGJlXG4gIC8vIGZpbGxlZCB3aXRoIGR5bmFtaWMgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIuXG4gIG5vZGU6IENhY2hlTm9kZSB8IG51bGxcbiAgLy8gVGhlIHRyZWUgc2VudCB0byB0aGUgc2VydmVyIGR1cmluZyB0aGUgZHluYW1pYyByZXF1ZXN0LiBUaGlzIGlzIHRoZVxuICAvLyBzYW1lIGFzIGByb3V0ZWAsIGV4Y2VwdCB3aXRoIHRoZSBgcmVmZXRjaGAgbWFya2VyIHNldCBvbiBkeW5hbWljIHNlZ21lbnRzLlxuICAvLyBJZiBhbGwgdGhlIHNlZ21lbnRzIGFyZSBzdGF0aWMsIHRoZW4gdGhpcyB3aWxsIGJlIG51bGwsIGFuZCBubyBzZXJ2ZXJcbiAgLy8gcmVxdWVzdCBpcyByZXF1aXJlZC5cbiAgZHluYW1pY1JlcXVlc3RUcmVlOiBGbGlnaHRSb3V0ZXJTdGF0ZSB8IG51bGxcbiAgY2hpbGRyZW46IE1hcDxzdHJpbmcsIFNQQU5hdmlnYXRpb25UYXNrPiB8IG51bGxcbn1cblxuLy8gQSBzcGVjaWFsIHR5cGUgdXNlZCB0byBiYWlsIG91dCBhbmQgdHJpZ2dlciBhIGZ1bGwtcGFnZSBuYXZpZ2F0aW9uLlxudHlwZSBNUEFOYXZpZ2F0aW9uVGFzayA9IHtcbiAgLy8gTVBBIHRhc2tzIGFyZSBkaXN0aW5ndWlzZWQgZnJvbSBTUEEgdGFza3MgYnkgaGF2aW5nIGEgbnVsbCBgcm91dGVgLlxuICByb3V0ZTogbnVsbFxuICBub2RlOiBudWxsXG4gIGR5bmFtaWNSZXF1ZXN0VHJlZTogbnVsbFxuICBjaGlsZHJlbjogbnVsbFxufVxuXG5jb25zdCBNUEFfTkFWSUdBVElPTl9UQVNLOiBNUEFOYXZpZ2F0aW9uVGFzayA9IHtcbiAgcm91dGU6IG51bGwsXG4gIG5vZGU6IG51bGwsXG4gIGR5bmFtaWNSZXF1ZXN0VHJlZTogbnVsbCxcbiAgY2hpbGRyZW46IG51bGwsXG59XG5cbmV4cG9ydCB0eXBlIFRhc2sgPSBTUEFOYXZpZ2F0aW9uVGFzayB8IE1QQU5hdmlnYXRpb25UYXNrXG5cbi8vIENyZWF0ZXMgYSBuZXcgQ2FjaGUgTm9kZSB0cmVlIChpLmUuIGNvcHktb24td3JpdGUpIHRoYXQgcmVwcmVzZW50cyB0aGVcbi8vIG9wdGltaXN0aWMgcmVzdWx0IG9mIGEgbmF2aWdhdGlvbiwgdXNpbmcgYm90aCB0aGUgY3VycmVudCBDYWNoZSBOb2RlIHRyZWUgYW5kXG4vLyBkYXRhIHRoYXQgd2FzIHByZWZldGNoZWQgcHJpb3IgdG8gbmF2aWdhdGlvbi5cbi8vXG4vLyBBdCB0aGUgbW9tZW50IHdlIGNhbGwgdGhpcyBmdW5jdGlvbiwgd2UgaGF2ZW4ndCB5ZXQgcmVjZWl2ZWQgdGhlIG5hdmlnYXRpb25cbi8vIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlci4gSXQgY291bGQgc2VuZCBiYWNrIHNvbWV0aGluZyBjb21wbGV0ZWx5IGRpZmZlcmVudFxuLy8gZnJvbSB0aGUgdHJlZSB0aGF0IHdhcyBwcmVmZXRjaGVkIOKAlCBkdWUgdG8gcmV3cml0ZXMsIGRlZmF1bHQgcm91dGVzLCBwYXJhbGxlbFxuLy8gcm91dGVzLCBldGMuXG4vL1xuLy8gQnV0IGluIG1vc3QgY2FzZXMsIGl0IHdpbGwgcmV0dXJuIHRoZSBzYW1lIHRyZWUgdGhhdCB3ZSBwcmVmZXRjaGVkLCBqdXN0IHdpdGhcbi8vIHRoZSBkeW5hbWljIGhvbGVzIGZpbGxlZCBpbi4gU28gd2Ugb3B0aW1pc3RpY2FsbHkgYXNzdW1lIHRoaXMgd2lsbCBoYXBwZW4sXG4vLyBhbmQgYWNjZXB0IHRoYXQgdGhlIHJlYWwgcmVzdWx0IGNvdWxkIGJlIGFyYml0cmFyaWx5IGRpZmZlcmVudC5cbi8vXG4vLyBXZSdsbCByZXVzZSBhbnl0aGluZyB0aGF0IHdhcyBhbHJlYWR5IGluIHRoZSBwcmV2aW91cyB0cmVlLCBzaW5jZSB0aGF0J3Mgd2hhdFxuLy8gdGhlIHNlcnZlciBkb2VzLlxuLy9cbi8vIE5ldyBzZWdtZW50cyAob25lcyB0aGF0IGRvbid0IGFwcGVhciBpbiB0aGUgb2xkIHRyZWUpIGFyZSBhc3NpZ25lZCBhblxuLy8gdW5yZXNvbHZlZCBwcm9taXNlLiBUaGUgZGF0YSBmb3IgdGhlc2UgcHJvbWlzZXMgd2lsbCBiZSBmdWxmaWxsZWQgbGF0ZXIsIHdoZW5cbi8vIHRoZSBuYXZpZ2F0aW9uIHJlc3BvbnNlIGlzIHJlY2VpdmVkLlxuLy9cbi8vIFRoZSB0cmVlIGNhbiBiZSByZW5kZXJlZCBpbW1lZGlhdGVseSBhZnRlciBpdCBpcyBjcmVhdGVkICh0aGF0J3Mgd2h5IHRoaXMgaXNcbi8vIGEgc3luY2hyb25vdXMgZnVuY3Rpb24pLiBBbnkgbmV3IHRyZWVzIHRoYXQgZG8gbm90IGhhdmUgcHJlZmV0Y2ggZGF0YSB3aWxsXG4vLyBzdXNwZW5kIGR1cmluZyByZW5kZXJpbmcsIHVudGlsIHRoZSBkeW5hbWljIGRhdGEgc3RyZWFtcyBpbi5cbi8vXG4vLyBSZXR1cm5zIGEgVGFzayBvYmplY3QsIHdoaWNoIGNvbnRhaW5zIGJvdGggdGhlIHVwZGF0ZWQgQ2FjaGUgTm9kZSBhbmQgYSBwYXRoXG4vLyB0byB0aGUgcGVuZGluZyBzdWJ0cmVlcyB0aGF0IG5lZWQgdG8gYmUgcmVzb2x2ZWQgYnkgdGhlIG5hdmlnYXRpb24gcmVzcG9uc2UuXG4vL1xuLy8gQSByZXR1cm4gdmFsdWUgb2YgYG51bGxgIG1lYW5zIHRoZXJlIHdlcmUgbm8gY2hhbmdlcywgYW5kIHRoZSBwcmV2aW91cyB0cmVlXG4vLyBjYW4gYmUgcmV1c2VkIHdpdGhvdXQgaW5pdGlhdGluZyBhIHNlcnZlciByZXF1ZXN0LlxuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0UFBSTmF2aWdhdGlvbihcbiAgbmF2aWdhdGVkQXQ6IG51bWJlcixcbiAgb2xkQ2FjaGVOb2RlOiBDYWNoZU5vZGUsXG4gIG9sZFJvdXRlclN0YXRlOiBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgbmV3Um91dGVyU3RhdGU6IEZsaWdodFJvdXRlclN0YXRlLFxuICBwcmVmZXRjaERhdGE6IENhY2hlTm9kZVNlZWREYXRhIHwgbnVsbCxcbiAgcHJlZmV0Y2hIZWFkOiBIZWFkRGF0YSB8IG51bGwsXG4gIGlzUHJlZmV0Y2hIZWFkUGFydGlhbDogYm9vbGVhbixcbiAgaXNTYW1lUGFnZU5hdmlnYXRpb246IGJvb2xlYW4sXG4gIHNjcm9sbGFibGVTZWdtZW50c1Jlc3VsdDogQXJyYXk8RmxpZ2h0U2VnbWVudFBhdGg+XG4pOiBUYXNrIHwgbnVsbCB7XG4gIGNvbnN0IHNlZ21lbnRQYXRoOiBBcnJheTxGbGlnaHRTZWdtZW50UGF0aD4gPSBbXVxuICByZXR1cm4gdXBkYXRlQ2FjaGVOb2RlT25OYXZpZ2F0aW9uKFxuICAgIG5hdmlnYXRlZEF0LFxuICAgIG9sZENhY2hlTm9kZSxcbiAgICBvbGRSb3V0ZXJTdGF0ZSxcbiAgICBuZXdSb3V0ZXJTdGF0ZSxcbiAgICBmYWxzZSxcbiAgICBwcmVmZXRjaERhdGEsXG4gICAgcHJlZmV0Y2hIZWFkLFxuICAgIGlzUHJlZmV0Y2hIZWFkUGFydGlhbCxcbiAgICBpc1NhbWVQYWdlTmF2aWdhdGlvbixcbiAgICBzZWdtZW50UGF0aCxcbiAgICBzY3JvbGxhYmxlU2VnbWVudHNSZXN1bHRcbiAgKVxufVxuXG5mdW5jdGlvbiB1cGRhdGVDYWNoZU5vZGVPbk5hdmlnYXRpb24oXG4gIG5hdmlnYXRlZEF0OiBudW1iZXIsXG4gIG9sZENhY2hlTm9kZTogQ2FjaGVOb2RlLFxuICBvbGRSb3V0ZXJTdGF0ZTogRmxpZ2h0Um91dGVyU3RhdGUsXG4gIG5ld1JvdXRlclN0YXRlOiBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgZGlkRmluZFJvb3RMYXlvdXQ6IGJvb2xlYW4sXG4gIHByZWZldGNoRGF0YTogQ2FjaGVOb2RlU2VlZERhdGEgfCBudWxsLFxuICBwcmVmZXRjaEhlYWQ6IEhlYWREYXRhIHwgbnVsbCxcbiAgaXNQcmVmZXRjaEhlYWRQYXJ0aWFsOiBib29sZWFuLFxuICBpc1NhbWVQYWdlTmF2aWdhdGlvbjogYm9vbGVhbixcbiAgc2VnbWVudFBhdGg6IEZsaWdodFNlZ21lbnRQYXRoLFxuICBzY3JvbGxhYmxlU2VnbWVudHNSZXN1bHQ6IEFycmF5PEZsaWdodFNlZ21lbnRQYXRoPlxuKTogVGFzayB8IG51bGwge1xuICAvLyBEaWZmIHRoZSBvbGQgYW5kIG5ldyB0cmVlcyB0byByZXVzZSB0aGUgc2hhcmVkIGxheW91dHMuXG4gIGNvbnN0IG9sZFJvdXRlclN0YXRlQ2hpbGRyZW4gPSBvbGRSb3V0ZXJTdGF0ZVsxXVxuICBjb25zdCBuZXdSb3V0ZXJTdGF0ZUNoaWxkcmVuID0gbmV3Um91dGVyU3RhdGVbMV1cbiAgY29uc3QgcHJlZmV0Y2hEYXRhQ2hpbGRyZW4gPSBwcmVmZXRjaERhdGEgIT09IG51bGwgPyBwcmVmZXRjaERhdGFbMl0gOiBudWxsXG5cbiAgaWYgKCFkaWRGaW5kUm9vdExheW91dCkge1xuICAgIC8vIFdlJ3JlIGN1cnJlbnRseSB0cmF2ZXJzaW5nIHRoZSBwYXJ0IG9mIHRoZSB0cmVlIHRoYXQgd2FzIGFsc28gcGFydCBvZlxuICAgIC8vIHRoZSBwcmV2aW91cyByb3V0ZS4gSWYgd2UgZGlzY292ZXIgYSByb290IGxheW91dCwgdGhlbiB3ZSBkb24ndCBuZWVkIHRvXG4gICAgLy8gdHJpZ2dlciBhbiBNUEEgbmF2aWdhdGlvbi4gU2VlIGJlZ2luUmVuZGVyaW5nTmV3Um91dGVUcmVlIGZvciBjb250ZXh0LlxuICAgIGNvbnN0IGlzUm9vdExheW91dCA9IG5ld1JvdXRlclN0YXRlWzRdID09PSB0cnVlXG4gICAgaWYgKGlzUm9vdExheW91dCkge1xuICAgICAgLy8gRm91bmQgYSBtYXRjaGluZyByb290IGxheW91dC5cbiAgICAgIGRpZEZpbmRSb290TGF5b3V0ID0gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG9sZFBhcmFsbGVsUm91dGVzID0gb2xkQ2FjaGVOb2RlLnBhcmFsbGVsUm91dGVzXG5cbiAgLy8gQ2xvbmUgdGhlIGN1cnJlbnQgc2V0IG9mIHNlZ21lbnQgY2hpbGRyZW4sIGV2ZW4gaWYgdGhleSBhcmVuJ3QgYWN0aXZlIGluXG4gIC8vIHRoZSBuZXcgdHJlZS5cbiAgLy8gVE9ETzogV2UgY3VycmVudGx5IHJldGFpbiBhbGwgdGhlIGluYWN0aXZlIHNlZ21lbnRzIGluZGVmaW5pdGVseSwgdW50aWxcbiAgLy8gdGhlcmUncyBhbiBleHBsaWNpdCByZWZyZXNoLCBvciBhIHBhcmVudCBsYXlvdXQgaXMgbGF6aWx5IHJlZnJlc2hlZC4gV2VcbiAgLy8gcmVseSBvbiB0aGlzIGZvciBwb3BzdGF0ZSBuYXZpZ2F0aW9ucywgd2hpY2ggdXBkYXRlIHRoZSBSb3V0ZXIgU3RhdGUgVHJlZVxuICAvLyBidXQgZG8gbm90IGVhZ2VybHkgcGVyZm9ybSBhIGRhdGEgZmV0Y2gsIGJlY2F1c2UgdGhleSBleHBlY3QgdGhlIHNlZ21lbnRcbiAgLy8gZGF0YSB0byBhbHJlYWR5IGJlIGluIHRoZSBDYWNoZSBOb2RlIHRyZWUuIEZvciBoaWdobHkgc3RhdGljIHNpdGVzIHRoYXRcbiAgLy8gYXJlIG1vc3RseSByZWFkLW9ubHksIHRoaXMgbWF5IGhhcHBlbiBvbmx5IHJhcmVseSwgY2F1c2luZyBtZW1vcnkgdG9cbiAgLy8gbGVhay4gV2Ugc2hvdWxkIGZpZ3VyZSBvdXQgYSBiZXR0ZXIgbW9kZWwgZm9yIHRoZSBsaWZldGltZSBvZiBpbmFjdGl2ZVxuICAvLyBzZWdtZW50cywgc28gd2UgY2FuIG1haW50YWluIGluc3RhbnQgYmFjay9mb3J3YXJkIG5hdmlnYXRpb25zIHdpdGhvdXRcbiAgLy8gbGVha2luZyBtZW1vcnkgaW5kZWZpbml0ZWx5LlxuICBjb25zdCBwcmVmZXRjaFBhcmFsbGVsUm91dGVzID0gbmV3IE1hcChvbGRQYXJhbGxlbFJvdXRlcylcblxuICAvLyBBcyB3ZSBkaWZmIHRoZSB0cmVlcywgd2UgbWF5IHNvbWV0aW1lcyBtb2RpZnkgKGNvcHktb24td3JpdGUsIG5vdCBtdXRhdGUpXG4gIC8vIHRoZSBSb3V0ZSBUcmVlIHRoYXQgd2FzIHJldHVybmVkIGJ5IHRoZSBzZXJ2ZXIg4oCUIGZvciBleGFtcGxlLCBpbiB0aGUgY2FzZVxuICAvLyBvZiBkZWZhdWx0IHBhcmFsbGVsIHJvdXRlcywgd2UgcHJlc2VydmUgdGhlIGN1cnJlbnRseSBhY3RpdmUgc2VnbWVudC4gVG9cbiAgLy8gYXZvaWQgbXV0YXRpbmcgdGhlIG9yaWdpbmFsIHRyZWUsIHdlIGNsb25lIHRoZSByb3V0ZXIgc3RhdGUgY2hpbGRyZW4gYWxvbmdcbiAgLy8gdGhlIHJldHVybiBwYXRoLlxuICBsZXQgcGF0Y2hlZFJvdXRlclN0YXRlQ2hpbGRyZW46IHtcbiAgICBbcGFyYWxsZWxSb3V0ZUtleTogc3RyaW5nXTogRmxpZ2h0Um91dGVyU3RhdGVcbiAgfSA9IHt9XG4gIGxldCB0YXNrQ2hpbGRyZW4gPSBudWxsXG5cbiAgLy8gTW9zdCBuYXZpZ2F0aW9ucyByZXF1aXJlIGEgcmVxdWVzdCB0byBmZXRjaCBhZGRpdGlvbmFsIGRhdGEgZnJvbSB0aGVcbiAgLy8gc2VydmVyLCBlaXRoZXIgYmVjYXVzZSB0aGUgZGF0YSB3YXMgbm90IGFscmVhZHkgcHJlZmV0Y2hlZCwgb3IgYmVjYXVzZSB0aGVcbiAgLy8gdGFyZ2V0IHJvdXRlIGNvbnRhaW5zIGR5bmFtaWMgZGF0YSB0aGF0IGNhbm5vdCBiZSBwcmVmZXRjaGVkLlxuICAvL1xuICAvLyBIb3dldmVyLCBpZiB0aGUgdGFyZ2V0IHJvdXRlIGlzIGZ1bGx5IHN0YXRpYywgYW5kIGl0J3MgYWxyZWFkeSBjb21wbGV0ZWx5XG4gIC8vIGxvYWRlZCBpbnRvIHRoZSBzZWdtZW50IGNhY2hlLCB0aGVuIHdlIGNhbiBza2lwIHRoZSBzZXJ2ZXIgcmVxdWVzdC5cbiAgLy9cbiAgLy8gVGhpcyBzdGFydHMgb2ZmIGFzIGBmYWxzZWAsIGFuZCBpcyBzZXQgdG8gYHRydWVgIGlmIGFueSBvZiB0aGUgY2hpbGRcbiAgLy8gcm91dGVzIHJlcXVpcmVzIGEgZHluYW1pYyByZXF1ZXN0LlxuICBsZXQgbmVlZHNEeW5hbWljUmVxdWVzdCA9IGZhbHNlXG4gIC8vIEFzIHdlIHRyYXZlcnNlIHRoZSBjaGlsZHJlbiwgd2UnbGwgY29uc3RydWN0IGEgRmxpZ2h0Um91dGVyU3RhdGUgdGhhdCBjYW5cbiAgLy8gYmUgc2VudCB0byB0aGUgc2VydmVyIHRvIHJlcXVlc3QgdGhlIGR5bmFtaWMgZGF0YS4gSWYgaXQgdHVybnMgb3V0IHRoYXRcbiAgLy8gbm90aGluZyBpbiB0aGUgc3VidHJlZSBpcyBkeW5hbWljIChpLmUuIG5lZWRzRHluYW1pY1JlcXVlc3QgaXMgZmFsc2UgYXQgdGhlXG4gIC8vIGVuZCksIHRoZW4gdGhpcyB3aWxsIGJlIGRpc2NhcmRlZC5cbiAgLy8gVE9ETzogV2UgY2FuIHByb2JhYmx5IG9wdGltaXplIHRoZSBmb3JtYXQgb2YgdGhpcyBkYXRhIHN0cnVjdHVyZSB0byBvbmx5XG4gIC8vIGluY2x1ZGUgcGF0aHMgdGhhdCBhcmUgZHluYW1pYy4gSW5zdGVhZCBvZiByZXVzaW5nIHRoZVxuICAvLyBGbGlnaHRSb3V0ZXJTdGF0ZSB0eXBlLlxuICBsZXQgZHluYW1pY1JlcXVlc3RUcmVlQ2hpbGRyZW46IHtcbiAgICBbcGFyYWxsZWxSb3V0ZUtleTogc3RyaW5nXTogRmxpZ2h0Um91dGVyU3RhdGVcbiAgfSA9IHt9XG5cbiAgZm9yIChsZXQgcGFyYWxsZWxSb3V0ZUtleSBpbiBuZXdSb3V0ZXJTdGF0ZUNoaWxkcmVuKSB7XG4gICAgY29uc3QgbmV3Um91dGVyU3RhdGVDaGlsZDogRmxpZ2h0Um91dGVyU3RhdGUgPVxuICAgICAgbmV3Um91dGVyU3RhdGVDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XVxuICAgIGNvbnN0IG9sZFJvdXRlclN0YXRlQ2hpbGQ6IEZsaWdodFJvdXRlclN0YXRlIHwgdm9pZCA9XG4gICAgICBvbGRSb3V0ZXJTdGF0ZUNoaWxkcmVuW3BhcmFsbGVsUm91dGVLZXldXG4gICAgY29uc3Qgb2xkU2VnbWVudE1hcENoaWxkID0gb2xkUGFyYWxsZWxSb3V0ZXMuZ2V0KHBhcmFsbGVsUm91dGVLZXkpXG4gICAgY29uc3QgcHJlZmV0Y2hEYXRhQ2hpbGQ6IENhY2hlTm9kZVNlZWREYXRhIHwgdm9pZCB8IG51bGwgPVxuICAgICAgcHJlZmV0Y2hEYXRhQ2hpbGRyZW4gIT09IG51bGxcbiAgICAgICAgPyBwcmVmZXRjaERhdGFDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XVxuICAgICAgICA6IG51bGxcblxuICAgIGNvbnN0IG5ld1NlZ21lbnRDaGlsZCA9IG5ld1JvdXRlclN0YXRlQ2hpbGRbMF1cbiAgICBjb25zdCBuZXdTZWdtZW50UGF0aENoaWxkID0gc2VnbWVudFBhdGguY29uY2F0KFtcbiAgICAgIHBhcmFsbGVsUm91dGVLZXksXG4gICAgICBuZXdTZWdtZW50Q2hpbGQsXG4gICAgXSlcbiAgICBjb25zdCBuZXdTZWdtZW50S2V5Q2hpbGQgPSBjcmVhdGVSb3V0ZXJDYWNoZUtleShuZXdTZWdtZW50Q2hpbGQpXG5cbiAgICBjb25zdCBvbGRTZWdtZW50Q2hpbGQgPVxuICAgICAgb2xkUm91dGVyU3RhdGVDaGlsZCAhPT0gdW5kZWZpbmVkID8gb2xkUm91dGVyU3RhdGVDaGlsZFswXSA6IHVuZGVmaW5lZFxuXG4gICAgY29uc3Qgb2xkQ2FjaGVOb2RlQ2hpbGQgPVxuICAgICAgb2xkU2VnbWVudE1hcENoaWxkICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBvbGRTZWdtZW50TWFwQ2hpbGQuZ2V0KG5ld1NlZ21lbnRLZXlDaGlsZClcbiAgICAgICAgOiB1bmRlZmluZWRcblxuICAgIGxldCB0YXNrQ2hpbGQ6IFRhc2sgfCBudWxsXG4gICAgaWYgKG5ld1NlZ21lbnRDaGlsZCA9PT0gREVGQVVMVF9TRUdNRU5UX0tFWSkge1xuICAgICAgLy8gVGhpcyBpcyBhbm90aGVyIGtpbmQgb2YgbGVhZiBzZWdtZW50IOKAlCBhIGRlZmF1bHQgcm91dGUuXG4gICAgICAvL1xuICAgICAgLy8gRGVmYXVsdCByb3V0ZXMgaGF2ZSBzcGVjaWFsIGJlaGF2aW9yLiBXaGVuIHRoZXJlJ3Mgbm8gbWF0Y2hpbmcgc2VnbWVudFxuICAgICAgLy8gZm9yIGEgcGFyYWxsZWwgcm91dGUsIE5leHQuanMgcHJlc2VydmVzIHRoZSBjdXJyZW50bHkgYWN0aXZlIHNlZ21lbnRcbiAgICAgIC8vIGR1cmluZyBhIGNsaWVudCBuYXZpZ2F0aW9uIOKAlCBidXQgbm90IGZvciBpbml0aWFsIHJlbmRlci4gVGhlIHNlcnZlclxuICAgICAgLy8gbGVhdmVzIGl0IHRvIHRoZSBjbGllbnQgdG8gYWNjb3VudCBmb3IgdGhpcy4gU28gd2UgbmVlZCB0byBoYW5kbGVcbiAgICAgIC8vIGl0IGhlcmUuXG4gICAgICBpZiAob2xkUm91dGVyU3RhdGVDaGlsZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIFJldXNlIHRoZSBleGlzdGluZyBSb3V0ZXIgU3RhdGUgZm9yIHRoaXMgc2VnbWVudC4gV2Ugc3Bhd24gYSBcInRhc2tcIlxuICAgICAgICAvLyBqdXN0IHRvIGtlZXAgdHJhY2sgb2YgdGhlIHVwZGF0ZWQgcm91dGVyIHN0YXRlOyB1bmxpa2UgbW9zdCwgaXQnc1xuICAgICAgICAvLyBhbHJlYWR5IGZ1bGZpbGxlZCBhbmQgd29uJ3QgYmUgYWZmZWN0ZWQgYnkgdGhlIGR5bmFtaWMgcmVzcG9uc2UuXG4gICAgICAgIHRhc2tDaGlsZCA9IHNwYXduUmV1c2VkVGFzayhvbGRSb3V0ZXJTdGF0ZUNoaWxkKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhlcmUncyBubyBjdXJyZW50bHkgYWN0aXZlIHNlZ21lbnQuIFN3aXRjaCB0byB0aGUgXCJjcmVhdGVcIiBwYXRoLlxuICAgICAgICB0YXNrQ2hpbGQgPSBiZWdpblJlbmRlcmluZ05ld1JvdXRlVHJlZShcbiAgICAgICAgICBuYXZpZ2F0ZWRBdCxcbiAgICAgICAgICBvbGRSb3V0ZXJTdGF0ZUNoaWxkLFxuICAgICAgICAgIG5ld1JvdXRlclN0YXRlQ2hpbGQsXG4gICAgICAgICAgb2xkQ2FjaGVOb2RlQ2hpbGQsXG4gICAgICAgICAgZGlkRmluZFJvb3RMYXlvdXQsXG4gICAgICAgICAgcHJlZmV0Y2hEYXRhQ2hpbGQgIT09IHVuZGVmaW5lZCA/IHByZWZldGNoRGF0YUNoaWxkIDogbnVsbCxcbiAgICAgICAgICBwcmVmZXRjaEhlYWQsXG4gICAgICAgICAgaXNQcmVmZXRjaEhlYWRQYXJ0aWFsLFxuICAgICAgICAgIG5ld1NlZ21lbnRQYXRoQ2hpbGQsXG4gICAgICAgICAgc2Nyb2xsYWJsZVNlZ21lbnRzUmVzdWx0XG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgaXNTYW1lUGFnZU5hdmlnYXRpb24gJiZcbiAgICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYSBwYWdlIHNlZ21lbnQuXG4gICAgICAvLyBUT0RPOiBXZSdyZSBub3QgY29uc2lzdGVudCBhYm91dCBob3cgd2UgZG8gdGhpcyBjaGVjay4gU29tZSBwbGFjZXNcbiAgICAgIC8vIGNoZWNrIGlmIHRoZSBzZWdtZW50IHN0YXJ0cyB3aXRoIFBBR0VfU0VHTUVOVF9LRVksIGJ1dCBtb3N0IHNlZW0gdG9cbiAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGFueSBhbnkgY2hpbGRyZW4sIHdoaWNoIGlzIHdoeSBJJ20gZG9pbmcgaXQgaGVyZS4gV2VcbiAgICAgIC8vIHNob3VsZCBwcm9iYWJseSBlbmNvZGUgYW4gZW1wdHkgY2hpbGRyZW4gc2V0IGFzIGBudWxsYCB0aG91Z2guIEVpdGhlclxuICAgICAgLy8gd2F5LCB3ZSBzaG91bGQgdXBkYXRlIGFsbCB0aGUgY2hlY2tzIHRvIGJlIGNvbnNpc3RlbnQuXG4gICAgICBPYmplY3Qua2V5cyhuZXdSb3V0ZXJTdGF0ZUNoaWxkWzFdKS5sZW5ndGggPT09IDBcbiAgICApIHtcbiAgICAgIC8vIFdlIHNwZWNpYWwgY2FzZSBuYXZpZ2F0aW9ucyB0byB0aGUgZXhhY3Qgc2FtZSBVUkwgYXMgdGhlIGN1cnJlbnRcbiAgICAgIC8vIGxvY2F0aW9uLiBJdCdzIGEgY29tbW9uIFVJIHBhdHRlcm4gZm9yIGFwcHMgdG8gcmVmcmVzaCB3aGVuIHlvdSBjbGljayBhXG4gICAgICAvLyBsaW5rIHRvIHRoZSBjdXJyZW50IHBhZ2UuIFNvIHdoZW4gdGhpcyBoYXBwZW5zLCB3ZSByZWZyZXNoIHRoZSBkeW5hbWljXG4gICAgICAvLyBkYXRhIGluIHRoZSBwYWdlIHNlZ21lbnRzLlxuICAgICAgLy9cbiAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIGRvZXMgbm90IGFwcGx5IGlmIHRoZSBhbnkgcGFydCBvZiB0aGUgaGFzaCBvciBzZWFyY2hcbiAgICAgIC8vIHF1ZXJ5IGhhcyBjaGFuZ2VkLiBUaGlzIG1pZ2h0IGZlZWwgYSBiaXQgd2VpcmQgYnV0IGl0IG1ha2VzIG1vcmUgc2Vuc2VcbiAgICAgIC8vIHdoZW4geW91IGNvbnNpZGVyIHRoYXQgdGhlIHdheSB0byB0cmlnZ2VyIHRoaXMgYmVoYXZpb3IgaXMgdG8gY2xpY2tcbiAgICAgIC8vIHRoZSBzYW1lIGxpbmsgbXVsdGlwbGUgdGltZXMuXG4gICAgICAvL1xuICAgICAgLy8gVE9ETzogV2Ugc2hvdWxkIHByb2JhYmx5IHJlZnJlc2ggdGhlICplbnRpcmUqIHJvdXRlIHdoZW4gdGhpcyBjYXNlXG4gICAgICAvLyBvY2N1cnMsIG5vdCBqdXN0IHRoZSBwYWdlIHNlZ21lbnRzLiBFc3NlbnRpYWxseSB0cmVhdGluZyBpdCB0aGUgc2FtZSBhc1xuICAgICAgLy8gYSByZWZyZXNoKCkgdHJpZ2dlcmVkIGJ5IGFuIGFjdGlvbiwgd2hpY2ggaXMgdGhlIG1vcmUgZXhwbGljaXQgd2F5IG9mXG4gICAgICAvLyBtb2RlbGluZyB0aGUgVUkgcGF0dGVybiBkZXNjcmliZWQgYWJvdmUuXG4gICAgICAvL1xuICAgICAgLy8gQWxzbyBub3RlIHRoYXQgdGhpcyBvbmx5IHJlZnJlc2hlcyB0aGUgZHluYW1pYyBkYXRhLCBub3Qgc3RhdGljL1xuICAgICAgLy8gY2FjaGVkIGRhdGEuIElmIHRoZSBwYWdlIHNlZ21lbnQgaXMgZnVsbHkgc3RhdGljIGFuZCBwcmVmZXRjaGVkLCB0aGVcbiAgICAgIC8vIHJlcXVlc3QgaXMgc2tpcHBlZC4gKFRoaXMgaXMgYWxzbyBob3cgcmVmcmVzaCgpIHdvcmtzLilcbiAgICAgIHRhc2tDaGlsZCA9IGJlZ2luUmVuZGVyaW5nTmV3Um91dGVUcmVlKFxuICAgICAgICBuYXZpZ2F0ZWRBdCxcbiAgICAgICAgb2xkUm91dGVyU3RhdGVDaGlsZCxcbiAgICAgICAgbmV3Um91dGVyU3RhdGVDaGlsZCxcbiAgICAgICAgb2xkQ2FjaGVOb2RlQ2hpbGQsXG4gICAgICAgIGRpZEZpbmRSb290TGF5b3V0LFxuICAgICAgICBwcmVmZXRjaERhdGFDaGlsZCAhPT0gdW5kZWZpbmVkID8gcHJlZmV0Y2hEYXRhQ2hpbGQgOiBudWxsLFxuICAgICAgICBwcmVmZXRjaEhlYWQsXG4gICAgICAgIGlzUHJlZmV0Y2hIZWFkUGFydGlhbCxcbiAgICAgICAgbmV3U2VnbWVudFBhdGhDaGlsZCxcbiAgICAgICAgc2Nyb2xsYWJsZVNlZ21lbnRzUmVzdWx0XG4gICAgICApXG4gICAgfSBlbHNlIGlmIChcbiAgICAgIG9sZFJvdXRlclN0YXRlQ2hpbGQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgb2xkU2VnbWVudENoaWxkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIG1hdGNoU2VnbWVudChuZXdTZWdtZW50Q2hpbGQsIG9sZFNlZ21lbnRDaGlsZClcbiAgICApIHtcbiAgICAgIGlmIChcbiAgICAgICAgb2xkQ2FjaGVOb2RlQ2hpbGQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBvbGRSb3V0ZXJTdGF0ZUNoaWxkICE9PSB1bmRlZmluZWRcbiAgICAgICkge1xuICAgICAgICAvLyBUaGlzIHNlZ21lbnQgZXhpc3RzIGluIGJvdGggdGhlIG9sZCBhbmQgbmV3IHRyZWVzLiBSZWN1cnNpdmVseSB1cGRhdGVcbiAgICAgICAgLy8gdGhlIGNoaWxkcmVuLlxuICAgICAgICB0YXNrQ2hpbGQgPSB1cGRhdGVDYWNoZU5vZGVPbk5hdmlnYXRpb24oXG4gICAgICAgICAgbmF2aWdhdGVkQXQsXG4gICAgICAgICAgb2xkQ2FjaGVOb2RlQ2hpbGQsXG4gICAgICAgICAgb2xkUm91dGVyU3RhdGVDaGlsZCxcbiAgICAgICAgICBuZXdSb3V0ZXJTdGF0ZUNoaWxkLFxuICAgICAgICAgIGRpZEZpbmRSb290TGF5b3V0LFxuICAgICAgICAgIHByZWZldGNoRGF0YUNoaWxkLFxuICAgICAgICAgIHByZWZldGNoSGVhZCxcbiAgICAgICAgICBpc1ByZWZldGNoSGVhZFBhcnRpYWwsXG4gICAgICAgICAgaXNTYW1lUGFnZU5hdmlnYXRpb24sXG4gICAgICAgICAgbmV3U2VnbWVudFBhdGhDaGlsZCxcbiAgICAgICAgICBzY3JvbGxhYmxlU2VnbWVudHNSZXN1bHRcbiAgICAgICAgKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhlcmUncyBubyBleGlzdGluZyBDYWNoZSBOb2RlIGZvciB0aGlzIHNlZ21lbnQuIFN3aXRjaCB0byB0aGVcbiAgICAgICAgLy8gXCJjcmVhdGVcIiBwYXRoLlxuICAgICAgICB0YXNrQ2hpbGQgPSBiZWdpblJlbmRlcmluZ05ld1JvdXRlVHJlZShcbiAgICAgICAgICBuYXZpZ2F0ZWRBdCxcbiAgICAgICAgICBvbGRSb3V0ZXJTdGF0ZUNoaWxkLFxuICAgICAgICAgIG5ld1JvdXRlclN0YXRlQ2hpbGQsXG4gICAgICAgICAgb2xkQ2FjaGVOb2RlQ2hpbGQsXG4gICAgICAgICAgZGlkRmluZFJvb3RMYXlvdXQsXG4gICAgICAgICAgcHJlZmV0Y2hEYXRhQ2hpbGQgIT09IHVuZGVmaW5lZCA/IHByZWZldGNoRGF0YUNoaWxkIDogbnVsbCxcbiAgICAgICAgICBwcmVmZXRjaEhlYWQsXG4gICAgICAgICAgaXNQcmVmZXRjaEhlYWRQYXJ0aWFsLFxuICAgICAgICAgIG5ld1NlZ21lbnRQYXRoQ2hpbGQsXG4gICAgICAgICAgc2Nyb2xsYWJsZVNlZ21lbnRzUmVzdWx0XG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyBpcyBhIG5ldyB0cmVlLiBTd2l0Y2ggdG8gdGhlIFwiY3JlYXRlXCIgcGF0aC5cbiAgICAgIHRhc2tDaGlsZCA9IGJlZ2luUmVuZGVyaW5nTmV3Um91dGVUcmVlKFxuICAgICAgICBuYXZpZ2F0ZWRBdCxcbiAgICAgICAgb2xkUm91dGVyU3RhdGVDaGlsZCxcbiAgICAgICAgbmV3Um91dGVyU3RhdGVDaGlsZCxcbiAgICAgICAgb2xkQ2FjaGVOb2RlQ2hpbGQsXG4gICAgICAgIGRpZEZpbmRSb290TGF5b3V0LFxuICAgICAgICBwcmVmZXRjaERhdGFDaGlsZCAhPT0gdW5kZWZpbmVkID8gcHJlZmV0Y2hEYXRhQ2hpbGQgOiBudWxsLFxuICAgICAgICBwcmVmZXRjaEhlYWQsXG4gICAgICAgIGlzUHJlZmV0Y2hIZWFkUGFydGlhbCxcbiAgICAgICAgbmV3U2VnbWVudFBhdGhDaGlsZCxcbiAgICAgICAgc2Nyb2xsYWJsZVNlZ21lbnRzUmVzdWx0XG4gICAgICApXG4gICAgfVxuXG4gICAgaWYgKHRhc2tDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgLy8gUmVjdXJzaXZlbHkgcHJvcGFnYXRlIHVwIHRoZSBjaGlsZCB0YXNrcy5cblxuICAgICAgaWYgKHRhc2tDaGlsZC5yb3V0ZSA9PT0gbnVsbCkge1xuICAgICAgICAvLyBPbmUgb2YgdGhlIGNoaWxkIHRhc2tzIGRpc2NvdmVyZWQgYSBjaGFuZ2UgdG8gdGhlIHJvb3QgbGF5b3V0LlxuICAgICAgICAvLyBJbW1lZGlhdGVseSB1bndpbmQgZnJvbSB0aGlzIHJlY3Vyc2l2ZSB0cmF2ZXJzYWwuXG4gICAgICAgIHJldHVybiBNUEFfTkFWSUdBVElPTl9UQVNLXG4gICAgICB9XG5cbiAgICAgIGlmICh0YXNrQ2hpbGRyZW4gPT09IG51bGwpIHtcbiAgICAgICAgdGFza0NoaWxkcmVuID0gbmV3IE1hcCgpXG4gICAgICB9XG4gICAgICB0YXNrQ2hpbGRyZW4uc2V0KHBhcmFsbGVsUm91dGVLZXksIHRhc2tDaGlsZClcbiAgICAgIGNvbnN0IG5ld0NhY2hlTm9kZUNoaWxkID0gdGFza0NoaWxkLm5vZGVcbiAgICAgIGlmIChuZXdDYWNoZU5vZGVDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBuZXdTZWdtZW50TWFwQ2hpbGQ6IENoaWxkU2VnbWVudE1hcCA9IG5ldyBNYXAob2xkU2VnbWVudE1hcENoaWxkKVxuICAgICAgICBuZXdTZWdtZW50TWFwQ2hpbGQuc2V0KG5ld1NlZ21lbnRLZXlDaGlsZCwgbmV3Q2FjaGVOb2RlQ2hpbGQpXG4gICAgICAgIHByZWZldGNoUGFyYWxsZWxSb3V0ZXMuc2V0KHBhcmFsbGVsUm91dGVLZXksIG5ld1NlZ21lbnRNYXBDaGlsZClcbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNoaWxkIHRyZWUncyByb3V0ZSBzdGF0ZSBtYXkgYmUgZGlmZmVyZW50IGZyb20gdGhlIHByZWZldGNoZWRcbiAgICAgIC8vIHJvdXRlIHNlbnQgYnkgdGhlIHNlcnZlci4gV2UgbmVlZCB0byBjbG9uZSBpdCBhcyB3ZSB0cmF2ZXJzZSBiYWNrIHVwXG4gICAgICAvLyB0aGUgdHJlZS5cbiAgICAgIGNvbnN0IHRhc2tDaGlsZFJvdXRlID0gdGFza0NoaWxkLnJvdXRlXG4gICAgICBwYXRjaGVkUm91dGVyU3RhdGVDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XSA9IHRhc2tDaGlsZFJvdXRlXG5cbiAgICAgIGNvbnN0IGR5bmFtaWNSZXF1ZXN0VHJlZUNoaWxkID0gdGFza0NoaWxkLmR5bmFtaWNSZXF1ZXN0VHJlZVxuICAgICAgaWYgKGR5bmFtaWNSZXF1ZXN0VHJlZUNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFNvbWV0aGluZyBpbiB0aGUgY2hpbGQgdHJlZSBpcyBkeW5hbWljLlxuICAgICAgICBuZWVkc0R5bmFtaWNSZXF1ZXN0ID0gdHJ1ZVxuICAgICAgICBkeW5hbWljUmVxdWVzdFRyZWVDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XSA9IGR5bmFtaWNSZXF1ZXN0VHJlZUNoaWxkXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkeW5hbWljUmVxdWVzdFRyZWVDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XSA9IHRhc2tDaGlsZFJvdXRlXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSBjaGlsZCBkaWRuJ3QgY2hhbmdlLiBXZSBjYW4gdXNlIHRoZSBwcmVmZXRjaGVkIHJvdXRlciBzdGF0ZS5cbiAgICAgIHBhdGNoZWRSb3V0ZXJTdGF0ZUNoaWxkcmVuW3BhcmFsbGVsUm91dGVLZXldID0gbmV3Um91dGVyU3RhdGVDaGlsZFxuICAgICAgZHluYW1pY1JlcXVlc3RUcmVlQ2hpbGRyZW5bcGFyYWxsZWxSb3V0ZUtleV0gPSBuZXdSb3V0ZXJTdGF0ZUNoaWxkXG4gICAgfVxuICB9XG5cbiAgaWYgKHRhc2tDaGlsZHJlbiA9PT0gbnVsbCkge1xuICAgIC8vIE5vIG5ldyB0YXNrcyB3ZXJlIHNwYXduZWQuXG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGNvbnN0IG5ld0NhY2hlTm9kZTogUmVhZHlDYWNoZU5vZGUgPSB7XG4gICAgbGF6eURhdGE6IG51bGwsXG4gICAgcnNjOiBvbGRDYWNoZU5vZGUucnNjLFxuICAgIC8vIFdlIGludGVudGlvbmFsbHkgYXJlbid0IHVwZGF0aW5nIHRoZSBwcmVmZXRjaFJzYyBmaWVsZCwgc2luY2UgdGhpcyBub2RlXG4gICAgLy8gaXMgYWxyZWFkeSBwYXJ0IG9mIHRoZSBjdXJyZW50IHRyZWUsIGJlY2F1c2UgaXQgd291bGQgYmUgd2VpcmQgZm9yXG4gICAgLy8gcHJlZmV0Y2ggZGF0YSB0byBiZSBuZXdlciB0aGFuIHRoZSBmaW5hbCBkYXRhLiBJdCBwcm9iYWJseSB3b24ndCBldmVyIGJlXG4gICAgLy8gb2JzZXJ2YWJsZSBhbnl3YXksIGJ1dCBpdCBjb3VsZCBoYXBwZW4gaWYgdGhlIHNlZ21lbnQgaXMgdW5tb3VudGVkIHRoZW5cbiAgICAvLyBtb3VudGVkIGFnYWluLCBiZWNhdXNlIExheW91dFJvdXRlciB3aWxsIG1vbWVudGFyaWx5IHN3aXRjaCB0byByZW5kZXJpbmdcbiAgICAvLyBwcmVmZXRjaFJzYywgdmlhIHVzZURlZmVycmVkVmFsdWUuXG4gICAgcHJlZmV0Y2hSc2M6IG9sZENhY2hlTm9kZS5wcmVmZXRjaFJzYyxcbiAgICBoZWFkOiBvbGRDYWNoZU5vZGUuaGVhZCxcbiAgICBwcmVmZXRjaEhlYWQ6IG9sZENhY2hlTm9kZS5wcmVmZXRjaEhlYWQsXG4gICAgbG9hZGluZzogb2xkQ2FjaGVOb2RlLmxvYWRpbmcsXG5cbiAgICAvLyBFdmVyeXRoaW5nIGlzIGNsb25lZCBleGNlcHQgZm9yIHRoZSBjaGlsZHJlbiwgd2hpY2ggd2UgY29tcHV0ZWQgYWJvdmUuXG4gICAgcGFyYWxsZWxSb3V0ZXM6IHByZWZldGNoUGFyYWxsZWxSb3V0ZXMsXG5cbiAgICBuYXZpZ2F0ZWRBdCxcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLy8gUmV0dXJuIGEgY2xvbmVkIGNvcHkgb2YgdGhlIHJvdXRlciBzdGF0ZSB3aXRoIHVwZGF0ZWQgY2hpbGRyZW4uXG4gICAgcm91dGU6IHBhdGNoUm91dGVyU3RhdGVXaXRoTmV3Q2hpbGRyZW4oXG4gICAgICBuZXdSb3V0ZXJTdGF0ZSxcbiAgICAgIHBhdGNoZWRSb3V0ZXJTdGF0ZUNoaWxkcmVuXG4gICAgKSxcbiAgICBub2RlOiBuZXdDYWNoZU5vZGUsXG4gICAgZHluYW1pY1JlcXVlc3RUcmVlOiBuZWVkc0R5bmFtaWNSZXF1ZXN0XG4gICAgICA/IHBhdGNoUm91dGVyU3RhdGVXaXRoTmV3Q2hpbGRyZW4oXG4gICAgICAgICAgbmV3Um91dGVyU3RhdGUsXG4gICAgICAgICAgZHluYW1pY1JlcXVlc3RUcmVlQ2hpbGRyZW5cbiAgICAgICAgKVxuICAgICAgOiBudWxsLFxuICAgIGNoaWxkcmVuOiB0YXNrQ2hpbGRyZW4sXG4gIH1cbn1cblxuZnVuY3Rpb24gYmVnaW5SZW5kZXJpbmdOZXdSb3V0ZVRyZWUoXG4gIG5hdmlnYXRlZEF0OiBudW1iZXIsXG4gIG9sZFJvdXRlclN0YXRlOiBGbGlnaHRSb3V0ZXJTdGF0ZSB8IHZvaWQsXG4gIG5ld1JvdXRlclN0YXRlOiBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgZXhpc3RpbmdDYWNoZU5vZGU6IENhY2hlTm9kZSB8IHZvaWQsXG4gIGRpZEZpbmRSb290TGF5b3V0OiBib29sZWFuLFxuICBwcmVmZXRjaERhdGE6IENhY2hlTm9kZVNlZWREYXRhIHwgbnVsbCxcbiAgcG9zc2libHlQYXJ0aWFsUHJlZmV0Y2hIZWFkOiBIZWFkRGF0YSB8IG51bGwsXG4gIGlzUHJlZmV0Y2hIZWFkUGFydGlhbDogYm9vbGVhbixcbiAgc2VnbWVudFBhdGg6IEZsaWdodFNlZ21lbnRQYXRoLFxuICBzY3JvbGxhYmxlU2VnbWVudHNSZXN1bHQ6IEFycmF5PEZsaWdodFNlZ21lbnRQYXRoPlxuKTogVGFzayB7XG4gIGlmICghZGlkRmluZFJvb3RMYXlvdXQpIHtcbiAgICAvLyBUaGUgcm91dGUgdHJlZSBjaGFuZ2VkIGJlZm9yZSB3ZSByZWFjaGVkIGEgbGF5b3V0LiAoVGhlIGhpZ2hlc3QtbGV2ZWxcbiAgICAvLyBsYXlvdXQgaW4gYSByb3V0ZSB0cmVlIGlzIHJlZmVycmVkIHRvIGFzIHRoZSBcInJvb3RcIiBsYXlvdXQuKSBUaGlzIGNvdWxkXG4gICAgLy8gbWVhbiB0aGF0IHdlJ3JlIG5hdmlnYXRpbmcgYmV0d2VlbiB0d28gZGlmZmVyZW50IHJvb3QgbGF5b3V0cy4gV2hlbiB0aGlzXG4gICAgLy8gaGFwcGVucywgd2UgcGVyZm9ybSBhIGZ1bGwtcGFnZSAoTVBBLXN0eWxlKSBuYXZpZ2F0aW9uLlxuICAgIC8vXG4gICAgLy8gSG93ZXZlciwgdGhlIGFsZ29yaXRobSBmb3IgZGVjaWRpbmcgd2hlcmUgdG8gc3RhcnQgcmVuZGVyaW5nIGEgcm91dGVcbiAgICAvLyAoaS5lLiB0aGUgb25lIHBlcmZvcm1lZCBpbiBvcmRlciB0byByZWFjaCB0aGlzIGZ1bmN0aW9uKSBpcyBzdHJpY3RlclxuICAgIC8vIHRoYW4gdGhlIG9uZSB1c2VkIHRvIGRldGVjdCBhIGNoYW5nZSBpbiB0aGUgcm9vdCBsYXlvdXQuIFNvIGp1c3QgYmVjYXVzZVxuICAgIC8vIHdlJ3JlIHJlLXJlbmRlcmluZyBhIHNlZ21lbnQgb3V0c2lkZSBvZiB0aGUgcm9vdCBsYXlvdXQgZG9lcyBub3QgbWVhbiB3ZVxuICAgIC8vIHNob3VsZCB0cmlnZ2VyIGEgZnVsbC1wYWdlIG5hdmlnYXRpb24uXG4gICAgLy9cbiAgICAvLyBTcGVjaWZpY2FsbHksIHdlIGhhbmRsZSBkeW5hbWljIHBhcmFtZXRlcnMgZGlmZmVyZW50bHk6IHR3byBzZWdtZW50cyBhcmVcbiAgICAvLyBjb25zaWRlcmVkIHRoZSBzYW1lIGV2ZW4gaWYgdGhlaXIgcGFyYW1ldGVyIHZhbHVlcyBhcmUgZGlmZmVyZW50LlxuICAgIC8vXG4gICAgLy8gUmVmZXIgdG8gaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0IGZvciBkZXRhaWxzLlxuICAgIC8vXG4gICAgLy8gTm90ZSB0aGF0IHdlIG9ubHkgaGF2ZSB0byBwZXJmb3JtIHRoaXMgZXh0cmEgdHJhdmVyc2FsIGlmIHdlIGRpZG4ndFxuICAgIC8vIGFscmVhZHkgZGlzY292ZXIgYSByb290IGxheW91dCBpbiB0aGUgcGFydCBvZiB0aGUgdHJlZSB0aGF0IGlzIHVuY2hhbmdlZC5cbiAgICAvLyBJbiB0aGUgY29tbW9uIGNhc2UsIHRoaXMgYnJhbmNoIGlzIHNraXBwZWQgY29tcGxldGVseS5cbiAgICBpZiAoXG4gICAgICBvbGRSb3V0ZXJTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICBpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQob2xkUm91dGVyU3RhdGUsIG5ld1JvdXRlclN0YXRlKVxuICAgICkge1xuICAgICAgLy8gVGhlIHJvb3QgbGF5b3V0IGNoYW5nZWQuIFBlcmZvcm0gYSBmdWxsLXBhZ2UgbmF2aWdhdGlvbi5cbiAgICAgIHJldHVybiBNUEFfTkFWSUdBVElPTl9UQVNLXG4gICAgfVxuICB9XG4gIHJldHVybiBjcmVhdGVDYWNoZU5vZGVPbk5hdmlnYXRpb24oXG4gICAgbmF2aWdhdGVkQXQsXG4gICAgbmV3Um91dGVyU3RhdGUsXG4gICAgZXhpc3RpbmdDYWNoZU5vZGUsXG4gICAgcHJlZmV0Y2hEYXRhLFxuICAgIHBvc3NpYmx5UGFydGlhbFByZWZldGNoSGVhZCxcbiAgICBpc1ByZWZldGNoSGVhZFBhcnRpYWwsXG4gICAgc2VnbWVudFBhdGgsXG4gICAgc2Nyb2xsYWJsZVNlZ21lbnRzUmVzdWx0XG4gIClcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ2FjaGVOb2RlT25OYXZpZ2F0aW9uKFxuICBuYXZpZ2F0ZWRBdDogbnVtYmVyLFxuICByb3V0ZXJTdGF0ZTogRmxpZ2h0Um91dGVyU3RhdGUsXG4gIGV4aXN0aW5nQ2FjaGVOb2RlOiBDYWNoZU5vZGUgfCB2b2lkLFxuICBwcmVmZXRjaERhdGE6IENhY2hlTm9kZVNlZWREYXRhIHwgbnVsbCxcbiAgcG9zc2libHlQYXJ0aWFsUHJlZmV0Y2hIZWFkOiBIZWFkRGF0YSB8IG51bGwsXG4gIGlzUHJlZmV0Y2hIZWFkUGFydGlhbDogYm9vbGVhbixcbiAgc2VnbWVudFBhdGg6IEZsaWdodFNlZ21lbnRQYXRoLFxuICBzY3JvbGxhYmxlU2VnbWVudHNSZXN1bHQ6IEFycmF5PEZsaWdodFNlZ21lbnRQYXRoPlxuKTogU1BBTmF2aWdhdGlvblRhc2sge1xuICAvLyBTYW1lIHRyYXZlcnNhbCBhcyB1cGRhdGVDYWNoZU5vZGVOYXZpZ2F0aW9uLCBidXQgd2Ugc3dpdGNoIHRvIHRoaXMgcGF0aFxuICAvLyBvbmNlIHdlIHJlYWNoIHRoZSBwYXJ0IG9mIHRoZSB0cmVlIHRoYXQgd2FzIG5vdCBpbiB0aGUgcHJldmlvdXMgcm91dGUuIFdlXG4gIC8vIGRvbid0IG5lZWQgdG8gZGlmZiBhZ2FpbnN0IHRoZSBvbGQgdHJlZSwgd2UganVzdCBuZWVkIHRvIGNyZWF0ZSBhIG5ldyBvbmUuXG5cbiAgLy8gVGhlIGhlYWQgaXMgYXNzaWduZWQgdG8gZXZlcnkgbGVhZiBzZWdtZW50IGRlbGl2ZXJlZCBieSB0aGUgc2VydmVyLiBCYXNlZFxuICAvLyBvbiBjb3JyZXNwb25kaW5nIGxvZ2ljIGluIGZpbGwtbGF6eS1pdGVtcy10aWxsLWxlYWYtd2l0aC1oZWFkLnRzXG4gIGNvbnN0IHJvdXRlclN0YXRlQ2hpbGRyZW4gPSByb3V0ZXJTdGF0ZVsxXVxuICBjb25zdCBpc0xlYWZTZWdtZW50ID0gT2JqZWN0LmtleXMocm91dGVyU3RhdGVDaGlsZHJlbikubGVuZ3RoID09PSAwXG5cbiAgLy8gRXZlbiB3ZSdyZSByZW5kZXJpbmcgaW5zaWRlIHRoZSBcIm5ld1wiIHBhcnQgb2YgdGhlIHRhcmdldCB0cmVlLCB3ZSBtYXkgaGF2ZVxuICAvLyBhIGxvY2FsbHkgY2FjaGVkIHNlZ21lbnQgdGhhdCB3ZSBjYW4gcmV1c2UuIFRoaXMgbWF5IGNvbWUgZnJvbSBlaXRoZXIgMSlcbiAgLy8gdGhlIENhY2hlTm9kZSB0cmVlLCB3aGljaCBsaXZlcyBpbiBSZWFjdCBzdGF0ZSBhbmQgaXMgcG9wdWxhdGVkIGJ5IHByZXZpb3VzXG4gIC8vIG5hdmlnYXRpb25zOyBvciAyKSB0aGUgcHJlZmV0Y2ggY2FjaGUsIHdoaWNoIGlzIGEgc2VwYXJhdGUgY2FjaGUgdGhhdCBpc1xuICAvLyBwb3B1bGF0ZWQgYnkgcHJlZmV0Y2hlcy5cbiAgbGV0IHJzYzogUmVhY3QuUmVhY3ROb2RlXG4gIGxldCBsb2FkaW5nOiBMb2FkaW5nTW9kdWxlRGF0YSB8IFByb21pc2U8TG9hZGluZ01vZHVsZURhdGE+XG4gIGxldCBoZWFkOiBIZWFkRGF0YSB8IG51bGxcbiAgbGV0IGNhY2hlTm9kZU5hdmlnYXRlZEF0OiBudW1iZXJcbiAgaWYgKFxuICAgIGV4aXN0aW5nQ2FjaGVOb2RlICE9PSB1bmRlZmluZWQgJiZcbiAgICAvLyBEWU5BTUlDX1NUQUxFVElNRV9NUyBkZWZhdWx0cyB0byAwLCBidXQgaXQgY2FuIGJlIGluY3JlYXNlZCB1c2luZ1xuICAgIC8vIHRoZSBleHBlcmltZW50YWwuc3RhbGVUaW1lcy5keW5hbWljIGNvbmZpZy4gV2hlbiBzZXQsIHdlJ2xsIGF2b2lkXG4gICAgLy8gcmVmZXRjaGluZyBkeW5hbWljIGRhdGEgaWYgaXQgd2FzIGZldGNoZWQgd2l0aGluIHRoZSBnaXZlbiB0aHJlc2hvbGQuXG4gICAgZXhpc3RpbmdDYWNoZU5vZGUubmF2aWdhdGVkQXQgKyBEWU5BTUlDX1NUQUxFVElNRV9NUyA+IG5hdmlnYXRlZEF0XG4gICkge1xuICAgIC8vIFdlIGhhdmUgYW4gZXhpc3RpbmcgQ2FjaGVOb2RlIGZvciB0aGlzIHNlZ21lbnQsIGFuZCBpdCdzIG5vdCBzdGFsZS4gV2VcbiAgICAvLyBzaG91bGQgcmV1c2UgaXQgcmF0aGVyIHRoYW4gcmVxdWVzdCBhIG5ldyBvbmUuXG4gICAgcnNjID0gZXhpc3RpbmdDYWNoZU5vZGUucnNjXG4gICAgbG9hZGluZyA9IGV4aXN0aW5nQ2FjaGVOb2RlLmxvYWRpbmdcbiAgICBoZWFkID0gZXhpc3RpbmdDYWNoZU5vZGUuaGVhZFxuXG4gICAgLy8gRG9uJ3QgdXBkYXRlIHRoZSBuYXZpZ2F0ZWRBdCB0aW1lc3RhbXAsIHNpbmNlIHdlJ3JlIHJldXNpbmcgc3RhbGUgZGF0YS5cbiAgICBjYWNoZU5vZGVOYXZpZ2F0ZWRBdCA9IGV4aXN0aW5nQ2FjaGVOb2RlLm5hdmlnYXRlZEF0XG4gIH0gZWxzZSBpZiAocHJlZmV0Y2hEYXRhICE9PSBudWxsKSB7XG4gICAgLy8gVGhlcmUncyBubyBleGlzdGluZyBDYWNoZU5vZGUgZm9yIHRoaXMgc2VnbWVudCwgYnV0IHdlIGRvIGhhdmUgcHJlZmV0Y2hcbiAgICAvLyBkYXRhLiBJZiB0aGUgcHJlZmV0Y2ggZGF0YSBpcyBmdWxseSBzdGF0aWMgKGkuZS4gZG9lcyBub3QgY29udGFpbiBhbnlcbiAgICAvLyBkeW5hbWljIGhvbGVzKSwgd2UgZG9uJ3QgbmVlZCB0byByZXF1ZXN0IGl0IGZyb20gdGhlIHNlcnZlci5cbiAgICByc2MgPSBwcmVmZXRjaERhdGFbMV1cbiAgICBsb2FkaW5nID0gcHJlZmV0Y2hEYXRhWzNdXG4gICAgaGVhZCA9IGlzTGVhZlNlZ21lbnQgPyBwb3NzaWJseVBhcnRpYWxQcmVmZXRjaEhlYWQgOiBudWxsXG4gICAgLy8gRXZlbiB0aG91Z2ggd2UncmUgYWNjZXNzaW5nIHRoZSBkYXRhIGZyb20gdGhlIHByZWZldGNoIGNhY2hlLCB0aGlzIGlzXG4gICAgLy8gY29uY2VwdHVhbGx5IGEgbmV3IHNlZ21lbnQsIG5vdCBhIHJldXNlZCBvbmUuIFNvIHdlIHNob3VsZCB1cGRhdGUgdGhlXG4gICAgLy8gbmF2aWdhdGVkQXQgdGltZXN0YW1wLlxuICAgIGNhY2hlTm9kZU5hdmlnYXRlZEF0ID0gbmF2aWdhdGVkQXRcbiAgICBjb25zdCBpc1ByZWZldGNoUnNjUGFydGlhbCA9IHByZWZldGNoRGF0YVs0XVxuICAgIGlmIChcbiAgICAgIC8vIENoZWNrIGlmIHRoZSBzZWdtZW50IGRhdGEgaXMgcGFydGlhbFxuICAgICAgaXNQcmVmZXRjaFJzY1BhcnRpYWwgfHxcbiAgICAgIC8vIENoZWNrIGlmIHRoZSBoZWFkIGlzIHBhcnRpYWwgKG9ubHkgcmVsZXZhbnQgaWYgdGhpcyBpcyBhIGxlYWYgc2VnbWVudClcbiAgICAgIChpc1ByZWZldGNoSGVhZFBhcnRpYWwgJiYgaXNMZWFmU2VnbWVudClcbiAgICApIHtcbiAgICAgIC8vIFdlIG9ubHkgaGF2ZSBwYXJ0aWFsIGRhdGEgZnJvbSB0aGlzIHNlZ21lbnQuIExpa2UgbWlzc2luZyBzZWdtZW50cywgd2VcbiAgICAgIC8vIG11c3QgcmVxdWVzdCB0aGUgZnVsbCBkYXRhIGZyb20gdGhlIHNlcnZlci5cbiAgICAgIHJldHVybiBzcGF3blBlbmRpbmdUYXNrKFxuICAgICAgICBuYXZpZ2F0ZWRBdCxcbiAgICAgICAgcm91dGVyU3RhdGUsXG4gICAgICAgIHByZWZldGNoRGF0YSxcbiAgICAgICAgcG9zc2libHlQYXJ0aWFsUHJlZmV0Y2hIZWFkLFxuICAgICAgICBpc1ByZWZldGNoSGVhZFBhcnRpYWwsXG4gICAgICAgIHNlZ21lbnRQYXRoLFxuICAgICAgICBzY3JvbGxhYmxlU2VnbWVudHNSZXN1bHRcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlIHByZWZldGNoIGRhdGEgaXMgZnVsbHkgc3RhdGljLCBzbyB3ZSBjYW4gb21pdCBpdCBmcm9tIHRoZVxuICAgICAgLy8gbmF2aWdhdGlvbiByZXF1ZXN0LlxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBUaGVyZSdzIG5vIHByZWZldGNoIGZvciB0aGlzIHNlZ21lbnQuIEV2ZXJ5dGhpbmcgZnJvbSB0aGlzIHBvaW50IHdpbGwgYmVcbiAgICAvLyByZXF1ZXN0ZWQgZnJvbSB0aGUgc2VydmVyLCBldmVuIGlmIHRoZXJlIGFyZSBzdGF0aWMgY2hpbGRyZW4gYmVsb3cgaXQuXG4gICAgLy8gQ3JlYXRlIGEgdGVybWluYWwgdGFzayBub2RlIHRoYXQgd2lsbCBsYXRlciBiZSBmdWxmaWxsZWQgYnlcbiAgICAvLyBzZXJ2ZXIgcmVzcG9uc2UuXG4gICAgcmV0dXJuIHNwYXduUGVuZGluZ1Rhc2soXG4gICAgICBuYXZpZ2F0ZWRBdCxcbiAgICAgIHJvdXRlclN0YXRlLFxuICAgICAgbnVsbCxcbiAgICAgIHBvc3NpYmx5UGFydGlhbFByZWZldGNoSGVhZCxcbiAgICAgIGlzUHJlZmV0Y2hIZWFkUGFydGlhbCxcbiAgICAgIHNlZ21lbnRQYXRoLFxuICAgICAgc2Nyb2xsYWJsZVNlZ21lbnRzUmVzdWx0XG4gICAgKVxuICB9XG5cbiAgLy8gV2UgYWxyZWFkeSBoYXZlIGEgZnVsbCBzZWdtZW50IHdlIGNhbiByZW5kZXIsIHNvIHdlIGRvbid0IG5lZWQgdG8gcmVxdWVzdCBhXG4gIC8vIG5ldyBvbmUgZnJvbSB0aGUgc2VydmVyLiBLZWVwIHRyYXZlcnNpbmcgZG93biB0aGUgdHJlZSB1bnRpbCB3ZSByZWFjaFxuICAvLyBzb21ldGhpbmcgdGhhdCByZXF1aXJlcyBhIGR5bmFtaWMgcmVxdWVzdC5cbiAgY29uc3QgcHJlZmV0Y2hEYXRhQ2hpbGRyZW4gPSBwcmVmZXRjaERhdGEgIT09IG51bGwgPyBwcmVmZXRjaERhdGFbMl0gOiBudWxsXG4gIGNvbnN0IHRhc2tDaGlsZHJlbiA9IG5ldyBNYXAoKVxuICBjb25zdCBleGlzdGluZ0NhY2hlTm9kZUNoaWxkcmVuID1cbiAgICBleGlzdGluZ0NhY2hlTm9kZSAhPT0gdW5kZWZpbmVkID8gZXhpc3RpbmdDYWNoZU5vZGUucGFyYWxsZWxSb3V0ZXMgOiBudWxsXG4gIGNvbnN0IGNhY2hlTm9kZUNoaWxkcmVuID0gbmV3IE1hcChleGlzdGluZ0NhY2hlTm9kZUNoaWxkcmVuKVxuICBsZXQgZHluYW1pY1JlcXVlc3RUcmVlQ2hpbGRyZW46IHtcbiAgICBbcGFyYWxsZWxSb3V0ZUtleTogc3RyaW5nXTogRmxpZ2h0Um91dGVyU3RhdGVcbiAgfSA9IHt9XG4gIGxldCBuZWVkc0R5bmFtaWNSZXF1ZXN0ID0gZmFsc2VcbiAgaWYgKGlzTGVhZlNlZ21lbnQpIHtcbiAgICAvLyBUaGUgc2VnbWVudCBwYXRoIG9mIGV2ZXJ5IGxlYWYgc2VnbWVudCAoaS5lLiBwYWdlKSBpcyBjb2xsZWN0ZWQgaW50b1xuICAgIC8vIGEgcmVzdWx0IGFycmF5LiBUaGlzIGlzIHVzZWQgYnkgdGhlIExheW91dFJvdXRlciB0byBzY3JvbGwgdG8gZW5zdXJlIHRoYXRcbiAgICAvLyBuZXcgcGFnZXMgYXJlIHZpc2libGUgYWZ0ZXIgYSBuYXZpZ2F0aW9uLlxuICAgIC8vIFRPRE86IFdlIHNob3VsZCB1c2UgYSBzdHJpbmcgdG8gcmVwcmVzZW50IHRoZSBzZWdtZW50IHBhdGggaW5zdGVhZCBvZlxuICAgIC8vIGFuIGFycmF5LiBXZSBhbHJlYWR5IHVzZSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBmb3IgdGhlIHBhdGggd2hlblxuICAgIC8vIGFjY2Vzc2luZyB0aGUgU2VnbWVudCBDYWNoZSwgc28gd2UgY2FuIHVzZSB0aGUgc2FtZSBvbmUuXG4gICAgc2Nyb2xsYWJsZVNlZ21lbnRzUmVzdWx0LnB1c2goc2VnbWVudFBhdGgpXG4gIH0gZWxzZSB7XG4gICAgZm9yIChsZXQgcGFyYWxsZWxSb3V0ZUtleSBpbiByb3V0ZXJTdGF0ZUNoaWxkcmVuKSB7XG4gICAgICBjb25zdCByb3V0ZXJTdGF0ZUNoaWxkOiBGbGlnaHRSb3V0ZXJTdGF0ZSA9XG4gICAgICAgIHJvdXRlclN0YXRlQ2hpbGRyZW5bcGFyYWxsZWxSb3V0ZUtleV1cbiAgICAgIGNvbnN0IHByZWZldGNoRGF0YUNoaWxkOiBDYWNoZU5vZGVTZWVkRGF0YSB8IHZvaWQgfCBudWxsID1cbiAgICAgICAgcHJlZmV0Y2hEYXRhQ2hpbGRyZW4gIT09IG51bGxcbiAgICAgICAgICA/IHByZWZldGNoRGF0YUNoaWxkcmVuW3BhcmFsbGVsUm91dGVLZXldXG4gICAgICAgICAgOiBudWxsXG4gICAgICBjb25zdCBleGlzdGluZ1NlZ21lbnRNYXBDaGlsZCA9XG4gICAgICAgIGV4aXN0aW5nQ2FjaGVOb2RlQ2hpbGRyZW4gIT09IG51bGxcbiAgICAgICAgICA/IGV4aXN0aW5nQ2FjaGVOb2RlQ2hpbGRyZW4uZ2V0KHBhcmFsbGVsUm91dGVLZXkpXG4gICAgICAgICAgOiB1bmRlZmluZWRcbiAgICAgIGNvbnN0IHNlZ21lbnRDaGlsZCA9IHJvdXRlclN0YXRlQ2hpbGRbMF1cbiAgICAgIGNvbnN0IHNlZ21lbnRQYXRoQ2hpbGQgPSBzZWdtZW50UGF0aC5jb25jYXQoW1xuICAgICAgICBwYXJhbGxlbFJvdXRlS2V5LFxuICAgICAgICBzZWdtZW50Q2hpbGQsXG4gICAgICBdKVxuICAgICAgY29uc3Qgc2VnbWVudEtleUNoaWxkID0gY3JlYXRlUm91dGVyQ2FjaGVLZXkoc2VnbWVudENoaWxkKVxuXG4gICAgICBjb25zdCBleGlzdGluZ0NhY2hlTm9kZUNoaWxkID1cbiAgICAgICAgZXhpc3RpbmdTZWdtZW50TWFwQ2hpbGQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gZXhpc3RpbmdTZWdtZW50TWFwQ2hpbGQuZ2V0KHNlZ21lbnRLZXlDaGlsZClcbiAgICAgICAgICA6IHVuZGVmaW5lZFxuXG4gICAgICBjb25zdCB0YXNrQ2hpbGQgPSBjcmVhdGVDYWNoZU5vZGVPbk5hdmlnYXRpb24oXG4gICAgICAgIG5hdmlnYXRlZEF0LFxuICAgICAgICByb3V0ZXJTdGF0ZUNoaWxkLFxuICAgICAgICBleGlzdGluZ0NhY2hlTm9kZUNoaWxkLFxuICAgICAgICBwcmVmZXRjaERhdGFDaGlsZCxcbiAgICAgICAgcG9zc2libHlQYXJ0aWFsUHJlZmV0Y2hIZWFkLFxuICAgICAgICBpc1ByZWZldGNoSGVhZFBhcnRpYWwsXG4gICAgICAgIHNlZ21lbnRQYXRoQ2hpbGQsXG4gICAgICAgIHNjcm9sbGFibGVTZWdtZW50c1Jlc3VsdFxuICAgICAgKVxuICAgICAgdGFza0NoaWxkcmVuLnNldChwYXJhbGxlbFJvdXRlS2V5LCB0YXNrQ2hpbGQpXG4gICAgICBjb25zdCBkeW5hbWljUmVxdWVzdFRyZWVDaGlsZCA9IHRhc2tDaGlsZC5keW5hbWljUmVxdWVzdFRyZWVcbiAgICAgIGlmIChkeW5hbWljUmVxdWVzdFRyZWVDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBTb21ldGhpbmcgaW4gdGhlIGNoaWxkIHRyZWUgaXMgZHluYW1pYy5cbiAgICAgICAgbmVlZHNEeW5hbWljUmVxdWVzdCA9IHRydWVcbiAgICAgICAgZHluYW1pY1JlcXVlc3RUcmVlQ2hpbGRyZW5bcGFyYWxsZWxSb3V0ZUtleV0gPSBkeW5hbWljUmVxdWVzdFRyZWVDaGlsZFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZHluYW1pY1JlcXVlc3RUcmVlQ2hpbGRyZW5bcGFyYWxsZWxSb3V0ZUtleV0gPSByb3V0ZXJTdGF0ZUNoaWxkXG4gICAgICB9XG4gICAgICBjb25zdCBuZXdDYWNoZU5vZGVDaGlsZCA9IHRhc2tDaGlsZC5ub2RlXG4gICAgICBpZiAobmV3Q2FjaGVOb2RlQ2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgbmV3U2VnbWVudE1hcENoaWxkOiBDaGlsZFNlZ21lbnRNYXAgPSBuZXcgTWFwKClcbiAgICAgICAgbmV3U2VnbWVudE1hcENoaWxkLnNldChzZWdtZW50S2V5Q2hpbGQsIG5ld0NhY2hlTm9kZUNoaWxkKVxuICAgICAgICBjYWNoZU5vZGVDaGlsZHJlbi5zZXQocGFyYWxsZWxSb3V0ZUtleSwgbmV3U2VnbWVudE1hcENoaWxkKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLy8gU2luY2Ugd2UncmUgaW5zaWRlIGEgbmV3IHJvdXRlIHRyZWUsIHVubGlrZSB0aGVcbiAgICAvLyBgdXBkYXRlQ2FjaGVOb2RlT25OYXZpZ2F0aW9uYCBwYXRoLCB0aGUgcm91dGVyIHN0YXRlIG9uIHRoZSBjaGlsZHJlblxuICAgIC8vIHRhc2tzIGlzIGFsd2F5cyB0aGUgc2FtZSBhcyB0aGUgcm91dGVyIHN0YXRlIHdlIHBhc3MgaW4uIFNvIHdlIGRvbid0IG5lZWRcbiAgICAvLyB0byBjbG9uZS9tb2RpZnkgaXQuXG4gICAgcm91dGU6IHJvdXRlclN0YXRlLFxuICAgIG5vZGU6IHtcbiAgICAgIGxhenlEYXRhOiBudWxsLFxuICAgICAgLy8gU2luY2UgdGhpcyBzZWdtZW50IGlzIGFscmVhZHkgZnVsbCwgd2UgZG9uJ3QgbmVlZCB0byB1c2UgdGhlXG4gICAgICAvLyBgcHJlZmV0Y2hSc2NgIGZpZWxkLlxuICAgICAgcnNjLFxuICAgICAgcHJlZmV0Y2hSc2M6IG51bGwsXG4gICAgICBoZWFkLFxuICAgICAgcHJlZmV0Y2hIZWFkOiBudWxsLFxuICAgICAgbG9hZGluZyxcbiAgICAgIHBhcmFsbGVsUm91dGVzOiBjYWNoZU5vZGVDaGlsZHJlbixcbiAgICAgIG5hdmlnYXRlZEF0OiBjYWNoZU5vZGVOYXZpZ2F0ZWRBdCxcbiAgICB9LFxuICAgIGR5bmFtaWNSZXF1ZXN0VHJlZTogbmVlZHNEeW5hbWljUmVxdWVzdFxuICAgICAgPyBwYXRjaFJvdXRlclN0YXRlV2l0aE5ld0NoaWxkcmVuKHJvdXRlclN0YXRlLCBkeW5hbWljUmVxdWVzdFRyZWVDaGlsZHJlbilcbiAgICAgIDogbnVsbCxcbiAgICBjaGlsZHJlbjogdGFza0NoaWxkcmVuLFxuICB9XG59XG5cbmZ1bmN0aW9uIHBhdGNoUm91dGVyU3RhdGVXaXRoTmV3Q2hpbGRyZW4oXG4gIGJhc2VSb3V0ZXJTdGF0ZTogRmxpZ2h0Um91dGVyU3RhdGUsXG4gIG5ld0NoaWxkcmVuOiB7IFtwYXJhbGxlbFJvdXRlS2V5OiBzdHJpbmddOiBGbGlnaHRSb3V0ZXJTdGF0ZSB9XG4pOiBGbGlnaHRSb3V0ZXJTdGF0ZSB7XG4gIGNvbnN0IGNsb25lOiBGbGlnaHRSb3V0ZXJTdGF0ZSA9IFtiYXNlUm91dGVyU3RhdGVbMF0sIG5ld0NoaWxkcmVuXVxuICAvLyBCYXNlZCBvbiBlcXVpdmFsZW50IGxvZ2ljIGluIGFwcGx5LXJvdXRlci1zdGF0ZS1wYXRjaC10by10cmVlLCBidXQgc2hvdWxkXG4gIC8vIGNvbmZpcm0gd2hldGhlciB3ZSBuZWVkIHRvIGNvcHkgYWxsIG9mIHRoZXNlIGZpZWxkcy4gTm90IHN1cmUgdGhlIHNlcnZlclxuICAvLyBldmVyIHNlbmRzLCBlLmcuIHRoZSByZWZldGNoIG1hcmtlci5cbiAgaWYgKDIgaW4gYmFzZVJvdXRlclN0YXRlKSB7XG4gICAgY2xvbmVbMl0gPSBiYXNlUm91dGVyU3RhdGVbMl1cbiAgfVxuICBpZiAoMyBpbiBiYXNlUm91dGVyU3RhdGUpIHtcbiAgICBjbG9uZVszXSA9IGJhc2VSb3V0ZXJTdGF0ZVszXVxuICB9XG4gIGlmICg0IGluIGJhc2VSb3V0ZXJTdGF0ZSkge1xuICAgIGNsb25lWzRdID0gYmFzZVJvdXRlclN0YXRlWzRdXG4gIH1cbiAgcmV0dXJuIGNsb25lXG59XG5cbmZ1bmN0aW9uIHNwYXduUGVuZGluZ1Rhc2soXG4gIG5hdmlnYXRlZEF0OiBudW1iZXIsXG4gIHJvdXRlclN0YXRlOiBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgcHJlZmV0Y2hEYXRhOiBDYWNoZU5vZGVTZWVkRGF0YSB8IG51bGwsXG4gIHByZWZldGNoSGVhZDogSGVhZERhdGEgfCBudWxsLFxuICBpc1ByZWZldGNoSGVhZFBhcnRpYWw6IGJvb2xlYW4sXG4gIHNlZ21lbnRQYXRoOiBGbGlnaHRTZWdtZW50UGF0aCxcbiAgc2Nyb2xsYWJsZVNlZ21lbnRzUmVzdWx0OiBBcnJheTxGbGlnaHRTZWdtZW50UGF0aD5cbik6IFNQQU5hdmlnYXRpb25UYXNrIHtcbiAgLy8gQ3JlYXRlIGEgdGFzayB0aGF0IHdpbGwgbGF0ZXIgYmUgZnVsZmlsbGVkIGJ5IGRhdGEgZnJvbSB0aGUgc2VydmVyLlxuXG4gIC8vIENsb25lIHRoZSBwcmVmZXRjaGVkIHJvdXRlIHRyZWUgYW5kIHRoZSBgcmVmZXRjaGAgbWFya2VyIHRvIGl0LiBXZSdsbCBzZW5kXG4gIC8vIHRoaXMgdG8gdGhlIHNlcnZlciBzbyBpdCBrbm93cyB3aGVyZSB0byBzdGFydCByZW5kZXJpbmcuXG4gIGNvbnN0IGR5bmFtaWNSZXF1ZXN0VHJlZSA9IHBhdGNoUm91dGVyU3RhdGVXaXRoTmV3Q2hpbGRyZW4oXG4gICAgcm91dGVyU3RhdGUsXG4gICAgcm91dGVyU3RhdGVbMV1cbiAgKVxuICBkeW5hbWljUmVxdWVzdFRyZWVbM10gPSAncmVmZXRjaCdcblxuICBjb25zdCBuZXdUYXNrOiBUYXNrID0ge1xuICAgIHJvdXRlOiByb3V0ZXJTdGF0ZSxcblxuICAgIC8vIENvcnJlc3BvbmRzIHRvIHRoZSBwYXJ0IG9mIHRoZSByb3V0ZSB0aGF0IHdpbGwgYmUgcmVuZGVyZWQgb24gdGhlIHNlcnZlci5cbiAgICBub2RlOiBjcmVhdGVQZW5kaW5nQ2FjaGVOb2RlKFxuICAgICAgbmF2aWdhdGVkQXQsXG4gICAgICByb3V0ZXJTdGF0ZSxcbiAgICAgIHByZWZldGNoRGF0YSxcbiAgICAgIHByZWZldGNoSGVhZCxcbiAgICAgIGlzUHJlZmV0Y2hIZWFkUGFydGlhbCxcbiAgICAgIHNlZ21lbnRQYXRoLFxuICAgICAgc2Nyb2xsYWJsZVNlZ21lbnRzUmVzdWx0XG4gICAgKSxcbiAgICAvLyBCZWNhdXNlIHRoaXMgaXMgbm9uLW51bGwsIGFuZCBpdCBnZXRzIHByb3BhZ2F0ZWQgdXAgdGhyb3VnaCB0aGUgcGFyZW50XG4gICAgLy8gdGFza3MsIHRoZSByb290IHRhc2sgd2lsbCBrbm93IHRoYXQgaXQgbmVlZHMgdG8gcGVyZm9ybSBhIHNlcnZlciByZXF1ZXN0LlxuICAgIGR5bmFtaWNSZXF1ZXN0VHJlZSxcbiAgICBjaGlsZHJlbjogbnVsbCxcbiAgfVxuICByZXR1cm4gbmV3VGFza1xufVxuXG5mdW5jdGlvbiBzcGF3blJldXNlZFRhc2socmV1c2VkUm91dGVyU3RhdGU6IEZsaWdodFJvdXRlclN0YXRlKTogVGFzayB7XG4gIC8vIENyZWF0ZSBhIHRhc2sgdGhhdCByZXVzZXMgYW4gZXhpc3Rpbmcgc2VnbWVudCwgZS5nLiB3aGVuIHJldXNpbmdcbiAgLy8gdGhlIGN1cnJlbnQgYWN0aXZlIHNlZ21lbnQgaW4gcGxhY2Ugb2YgYSBkZWZhdWx0IHJvdXRlLlxuICByZXR1cm4ge1xuICAgIHJvdXRlOiByZXVzZWRSb3V0ZXJTdGF0ZSxcbiAgICBub2RlOiBudWxsLFxuICAgIGR5bmFtaWNSZXF1ZXN0VHJlZTogbnVsbCxcbiAgICBjaGlsZHJlbjogbnVsbCxcbiAgfVxufVxuXG4vLyBXcml0ZXMgYSBkeW5hbWljIHNlcnZlciByZXNwb25zZSBpbnRvIHRoZSB0cmVlIGNyZWF0ZWQgYnlcbi8vIHVwZGF0ZUNhY2hlTm9kZU9uTmF2aWdhdGlvbi4gQWxsIHBlbmRpbmcgcHJvbWlzZXMgdGhhdCB3ZXJlIHNwYXduZWQgYnkgdGhlXG4vLyBuYXZpZ2F0aW9uIHdpbGwgYmUgcmVzb2x2ZWQsIGVpdGhlciB3aXRoIGR5bmFtaWMgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIsIG9yXG4vLyBgbnVsbGAgdG8gaW5kaWNhdGUgdGhhdCB0aGUgZGF0YSBpcyBtaXNzaW5nLlxuLy9cbi8vIEEgYG51bGxgIHZhbHVlIHdpbGwgdHJpZ2dlciBhIGxhenkgZmV0Y2ggZHVyaW5nIHJlbmRlciwgd2hpY2ggd2lsbCB0aGVuIHBhdGNoXG4vLyB1cCB0aGUgdHJlZSB1c2luZyB0aGUgc2FtZSBtZWNoYW5pc20gYXMgdGhlIG5vbi1QUFIgaW1wbGVtZW50YXRpb25cbi8vIChzZXJ2ZXJQYXRjaFJlZHVjZXIpLlxuLy9cbi8vIFVzdWFsbHksIHRoZSBzZXJ2ZXIgd2lsbCByZXNwb25kIHdpdGggZXhhY3RseSB0aGUgc3Vic2V0IG9mIGRhdGEgdGhhdCB3ZSdyZVxuLy8gd2FpdGluZyBmb3Ig4oCUIGV2ZXJ5dGhpbmcgYmVsb3cgdGhlIG5lYXJlc3Qgc2hhcmVkIGxheW91dC4gQnV0IHRlY2huaWNhbGx5LFxuLy8gdGhlIHNlcnZlciBjYW4gcmV0dXJuIGFueXRoaW5nIGl0IHdhbnRzLlxuLy9cbi8vIFRoaXMgZG9lcyBfbm90XyBjcmVhdGUgYSBuZXcgdHJlZTsgaXQgbW9kaWZpZXMgdGhlIGV4aXN0aW5nIG9uZSBpbiBwbGFjZS5cbi8vIFdoaWNoIG1lYW5zIGl0IG11c3QgZm9sbG93IHRoZSBTdXNwZW5zZSBydWxlcyBvZiBjYWNoZSBzYWZldHkuXG5leHBvcnQgZnVuY3Rpb24gbGlzdGVuRm9yRHluYW1pY1JlcXVlc3QoXG4gIHRhc2s6IFNQQU5hdmlnYXRpb25UYXNrLFxuICByZXNwb25zZVByb21pc2U6IFByb21pc2U8RmV0Y2hTZXJ2ZXJSZXNwb25zZVJlc3VsdD5cbikge1xuICByZXNwb25zZVByb21pc2UudGhlbihcbiAgICAoeyBmbGlnaHREYXRhIH06IEZldGNoU2VydmVyUmVzcG9uc2VSZXN1bHQpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgZmxpZ2h0RGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gSGFwcGVucyB3aGVuIG5hdmlnYXRpbmcgdG8gcGFnZSBpbiBgcGFnZXNgIGZyb20gYGFwcGAuIFdlIHNob3VsZG4ndFxuICAgICAgICAvLyBnZXQgaGVyZSBiZWNhdXNlIHNob3VsZCBoYXZlIGFscmVhZHkgaGFuZGxlZCB0aGlzIGR1cmluZ1xuICAgICAgICAvLyB0aGUgcHJlZmV0Y2guXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBub3JtYWxpemVkRmxpZ2h0RGF0YSBvZiBmbGlnaHREYXRhKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBzZWdtZW50UGF0aCxcbiAgICAgICAgICB0cmVlOiBzZXJ2ZXJSb3V0ZXJTdGF0ZSxcbiAgICAgICAgICBzZWVkRGF0YTogZHluYW1pY0RhdGEsXG4gICAgICAgICAgaGVhZDogZHluYW1pY0hlYWQsXG4gICAgICAgIH0gPSBub3JtYWxpemVkRmxpZ2h0RGF0YVxuXG4gICAgICAgIGlmICghZHluYW1pY0RhdGEpIHtcbiAgICAgICAgICAvLyBUaGlzIHNob3VsZG4ndCBoYXBwZW4uIFBQUiBzaG91bGQgYWx3YXlzIHNlbmQgYmFjayBhIHJlc3BvbnNlLlxuICAgICAgICAgIC8vIEhvd2V2ZXIsIGBGbGlnaHREYXRhUGF0aGAgaXMgYSBzaGFyZWQgdHlwZSBhbmQgdGhlIHByZS1QUFIgaGFuZGxpbmcgb2ZcbiAgICAgICAgICAvLyB0aGlzIG1pZ2h0IHJldHVybiBudWxsLlxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICB3cml0ZUR5bmFtaWNEYXRhSW50b1BlbmRpbmdUYXNrKFxuICAgICAgICAgIHRhc2ssXG4gICAgICAgICAgc2VnbWVudFBhdGgsXG4gICAgICAgICAgc2VydmVyUm91dGVyU3RhdGUsXG4gICAgICAgICAgZHluYW1pY0RhdGEsXG4gICAgICAgICAgZHluYW1pY0hlYWRcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICAvLyBOb3cgdGhhdCB3ZSd2ZSBleGhhdXN0ZWQgYWxsIHRoZSBkYXRhIHdlIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlciwgaWZcbiAgICAgIC8vIHRoZXJlIGFyZSBhbnkgcmVtYWluaW5nIHBlbmRpbmcgdGFza3MgaW4gdGhlIHRyZWUsIGFib3J0IHRoZW0gbm93LlxuICAgICAgLy8gSWYgdGhlcmUncyBhbnkgbWlzc2luZyBkYXRhLCBpdCB3aWxsIHRyaWdnZXIgYSBsYXp5IGZldGNoLlxuICAgICAgYWJvcnRUYXNrKHRhc2ssIG51bGwpXG4gICAgfSxcbiAgICAoZXJyb3I6IGFueSkgPT4ge1xuICAgICAgLy8gVGhpcyB3aWxsIHRyaWdnZXIgYW4gZXJyb3IgZHVyaW5nIHJlbmRlclxuICAgICAgYWJvcnRUYXNrKHRhc2ssIGVycm9yKVxuICAgIH1cbiAgKVxufVxuXG5mdW5jdGlvbiB3cml0ZUR5bmFtaWNEYXRhSW50b1BlbmRpbmdUYXNrKFxuICByb290VGFzazogU1BBTmF2aWdhdGlvblRhc2ssXG4gIHNlZ21lbnRQYXRoOiBGbGlnaHRTZWdtZW50UGF0aCxcbiAgc2VydmVyUm91dGVyU3RhdGU6IEZsaWdodFJvdXRlclN0YXRlLFxuICBkeW5hbWljRGF0YTogQ2FjaGVOb2RlU2VlZERhdGEsXG4gIGR5bmFtaWNIZWFkOiBIZWFkRGF0YVxuKSB7XG4gIC8vIFRoZSBkYXRhIHNlbnQgYnkgdGhlIHNlcnZlciByZXByZXNlbnRzIG9ubHkgYSBzdWJ0cmVlIG9mIHRoZSBhcHAuIFdlIG5lZWRcbiAgLy8gdG8gZmluZCB0aGUgcGFydCBvZiB0aGUgdGFzayB0cmVlIHRoYXQgbWF0Y2hlcyB0aGUgc2VydmVyIHJlc3BvbnNlLCBhbmRcbiAgLy8gZnVsZmlsbCBpdCB1c2luZyB0aGUgZHluYW1pYyBkYXRhLlxuICAvL1xuICAvLyBzZWdtZW50UGF0aCByZXByZXNlbnRzIHRoZSBwYXJlbnQgcGF0aCBvZiBzdWJ0cmVlLiBJdCdzIGEgcmVwZWF0aW5nIHBhdHRlcm5cbiAgLy8gb2YgcGFyYWxsZWwgcm91dGUga2V5IGFuZCBzZWdtZW50OlxuICAvL1xuICAvLyAgIFtzdHJpbmcsIFNlZ21lbnQsIHN0cmluZywgU2VnbWVudCwgc3RyaW5nLCBTZWdtZW50LCAuLi5dXG4gIC8vXG4gIC8vIEl0ZXJhdGUgdGhyb3VnaCB0aGUgcGF0aCBhbmQgZmluaXNoIGFueSB0YXNrcyB0aGF0IG1hdGNoIHRoaXMgcGF5bG9hZC5cbiAgbGV0IHRhc2sgPSByb290VGFza1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRQYXRoLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgY29uc3QgcGFyYWxsZWxSb3V0ZUtleTogc3RyaW5nID0gc2VnbWVudFBhdGhbaV1cbiAgICBjb25zdCBzZWdtZW50OiBTZWdtZW50ID0gc2VnbWVudFBhdGhbaSArIDFdXG4gICAgY29uc3QgdGFza0NoaWxkcmVuID0gdGFzay5jaGlsZHJlblxuICAgIGlmICh0YXNrQ2hpbGRyZW4gIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHRhc2tDaGlsZCA9IHRhc2tDaGlsZHJlbi5nZXQocGFyYWxsZWxSb3V0ZUtleSlcbiAgICAgIGlmICh0YXNrQ2hpbGQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCB0YXNrU2VnbWVudCA9IHRhc2tDaGlsZC5yb3V0ZVswXVxuICAgICAgICBpZiAobWF0Y2hTZWdtZW50KHNlZ21lbnQsIHRhc2tTZWdtZW50KSkge1xuICAgICAgICAgIC8vIEZvdW5kIGEgbWF0Y2ggZm9yIHRoaXMgdGFzay4gS2VlcCB0cmF2ZXJzaW5nIGRvd24gdGhlIHRhc2sgdHJlZS5cbiAgICAgICAgICB0YXNrID0gdGFza0NoaWxkXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBXZSBkaWRuJ3QgZmluZCBhIGNoaWxkIHRhc2sgdGhhdCBtYXRjaGVzIHRoZSBzZXJ2ZXIgZGF0YS4gRXhpdC4gV2Ugd29uJ3RcbiAgICAvLyBhYm9ydCB0aGUgdGFzaywgdGhvdWdoLCBiZWNhdXNlIGEgZGlmZmVyZW50IEZsaWdodERhdGFQYXRoIG1heSBiZSBhYmxlIHRvXG4gICAgLy8gZnVsZmlsbCBpdCAoc2VlIGxvb3AgaW4gbGlzdGVuRm9yRHluYW1pY1JlcXVlc3QpLiBXZSBvbmx5IGFib3J0IHRhc2tzXG4gICAgLy8gb25jZSB3ZSd2ZSBydW4gb3V0IG9mIGRhdGEuXG4gICAgcmV0dXJuXG4gIH1cblxuICBmaW5pc2hUYXNrVXNpbmdEeW5hbWljRGF0YVBheWxvYWQoXG4gICAgdGFzayxcbiAgICBzZXJ2ZXJSb3V0ZXJTdGF0ZSxcbiAgICBkeW5hbWljRGF0YSxcbiAgICBkeW5hbWljSGVhZFxuICApXG59XG5cbmZ1bmN0aW9uIGZpbmlzaFRhc2tVc2luZ0R5bmFtaWNEYXRhUGF5bG9hZChcbiAgdGFzazogU1BBTmF2aWdhdGlvblRhc2ssXG4gIHNlcnZlclJvdXRlclN0YXRlOiBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgZHluYW1pY0RhdGE6IENhY2hlTm9kZVNlZWREYXRhLFxuICBkeW5hbWljSGVhZDogSGVhZERhdGFcbikge1xuICBpZiAodGFzay5keW5hbWljUmVxdWVzdFRyZWUgPT09IG51bGwpIHtcbiAgICAvLyBFdmVyeXRoaW5nIGluIHRoaXMgc3VidHJlZSBpcyBhbHJlYWR5IGNvbXBsZXRlLiBCYWlsIG91dC5cbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGR5bmFtaWNEYXRhIG1heSByZXByZXNlbnQgYSBsYXJnZXIgc3VidHJlZSB0aGFuIHRoZSB0YXNrLiBCZWZvcmUgd2UgY2FuXG4gIC8vIGZpbmlzaCB0aGUgdGFzaywgd2UgbmVlZCB0byBsaW5lIHRoZW0gdXAuXG4gIGNvbnN0IHRhc2tDaGlsZHJlbiA9IHRhc2suY2hpbGRyZW5cbiAgY29uc3QgdGFza05vZGUgPSB0YXNrLm5vZGVcbiAgaWYgKHRhc2tDaGlsZHJlbiA9PT0gbnVsbCkge1xuICAgIC8vIFdlJ3ZlIHJlYWNoZWQgdGhlIGxlYWYgbm9kZSBvZiB0aGUgcGVuZGluZyB0YXNrLiBUaGUgc2VydmVyIGRhdGEgdHJlZVxuICAgIC8vIGxpbmVzIHVwIHRoZSBwZW5kaW5nIENhY2hlIE5vZGUgdHJlZS4gV2UgY2FuIG5vdyBzd2l0Y2ggdG8gdGhlXG4gICAgLy8gbm9ybWFsIGFsZ29yaXRobS5cbiAgICBpZiAodGFza05vZGUgIT09IG51bGwpIHtcbiAgICAgIGZpbmlzaFBlbmRpbmdDYWNoZU5vZGUoXG4gICAgICAgIHRhc2tOb2RlLFxuICAgICAgICB0YXNrLnJvdXRlLFxuICAgICAgICBzZXJ2ZXJSb3V0ZXJTdGF0ZSxcbiAgICAgICAgZHluYW1pY0RhdGEsXG4gICAgICAgIGR5bmFtaWNIZWFkXG4gICAgICApXG4gICAgICAvLyBTZXQgdGhpcyB0byBudWxsIHRvIGluZGljYXRlIHRoYXQgdGhpcyB0YXNrIGlzIG5vdyBjb21wbGV0ZS5cbiAgICAgIHRhc2suZHluYW1pY1JlcXVlc3RUcmVlID0gbnVsbFxuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuICAvLyBUaGUgc2VydmVyIHJldHVybmVkIG1vcmUgZGF0YSB0aGFuIHdlIG5lZWQgdG8gZmluaXNoIHRoZSB0YXNrLiBTa2lwIG92ZXJcbiAgLy8gdGhlIGV4dHJhIHNlZ21lbnRzIHVudGlsIHdlIHJlYWNoIHRoZSBsZWFmIHRhc2sgbm9kZS5cbiAgY29uc3Qgc2VydmVyQ2hpbGRyZW4gPSBzZXJ2ZXJSb3V0ZXJTdGF0ZVsxXVxuICBjb25zdCBkeW5hbWljRGF0YUNoaWxkcmVuID0gZHluYW1pY0RhdGFbMl1cblxuICBmb3IgKGNvbnN0IHBhcmFsbGVsUm91dGVLZXkgaW4gc2VydmVyUm91dGVyU3RhdGUpIHtcbiAgICBjb25zdCBzZXJ2ZXJSb3V0ZXJTdGF0ZUNoaWxkOiBGbGlnaHRSb3V0ZXJTdGF0ZSA9XG4gICAgICBzZXJ2ZXJDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XVxuICAgIGNvbnN0IGR5bmFtaWNEYXRhQ2hpbGQ6IENhY2hlTm9kZVNlZWREYXRhIHwgbnVsbCB8IHZvaWQgPVxuICAgICAgZHluYW1pY0RhdGFDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XVxuXG4gICAgY29uc3QgdGFza0NoaWxkID0gdGFza0NoaWxkcmVuLmdldChwYXJhbGxlbFJvdXRlS2V5KVxuICAgIGlmICh0YXNrQ2hpbGQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgdGFza1NlZ21lbnQgPSB0YXNrQ2hpbGQucm91dGVbMF1cbiAgICAgIGlmIChcbiAgICAgICAgbWF0Y2hTZWdtZW50KHNlcnZlclJvdXRlclN0YXRlQ2hpbGRbMF0sIHRhc2tTZWdtZW50KSAmJlxuICAgICAgICBkeW5hbWljRGF0YUNoaWxkICE9PSBudWxsICYmXG4gICAgICAgIGR5bmFtaWNEYXRhQ2hpbGQgIT09IHVuZGVmaW5lZFxuICAgICAgKSB7XG4gICAgICAgIC8vIEZvdW5kIGEgbWF0Y2ggZm9yIHRoaXMgdGFzay4gS2VlcCB0cmF2ZXJzaW5nIGRvd24gdGhlIHRhc2sgdHJlZS5cbiAgICAgICAgcmV0dXJuIGZpbmlzaFRhc2tVc2luZ0R5bmFtaWNEYXRhUGF5bG9hZChcbiAgICAgICAgICB0YXNrQ2hpbGQsXG4gICAgICAgICAgc2VydmVyUm91dGVyU3RhdGVDaGlsZCxcbiAgICAgICAgICBkeW5hbWljRGF0YUNoaWxkLFxuICAgICAgICAgIGR5bmFtaWNIZWFkXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gV2UgZGlkbid0IGZpbmQgYSBjaGlsZCB0YXNrIHRoYXQgbWF0Y2hlcyB0aGUgc2VydmVyIGRhdGEuIFdlIHdvbid0IGFib3J0XG4gICAgLy8gdGhlIHRhc2ssIHRob3VnaCwgYmVjYXVzZSBhIGRpZmZlcmVudCBGbGlnaHREYXRhUGF0aCBtYXkgYmUgYWJsZSB0b1xuICAgIC8vIGZ1bGZpbGwgaXQgKHNlZSBsb29wIGluIGxpc3RlbkZvckR5bmFtaWNSZXF1ZXN0KS4gV2Ugb25seSBhYm9ydCB0YXNrc1xuICAgIC8vIG9uY2Ugd2UndmUgcnVuIG91dCBvZiBkYXRhLlxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBlbmRpbmdDYWNoZU5vZGUoXG4gIG5hdmlnYXRlZEF0OiBudW1iZXIsXG4gIHJvdXRlclN0YXRlOiBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgcHJlZmV0Y2hEYXRhOiBDYWNoZU5vZGVTZWVkRGF0YSB8IG51bGwsXG4gIHByZWZldGNoSGVhZDogSGVhZERhdGEgfCBudWxsLFxuICBpc1ByZWZldGNoSGVhZFBhcnRpYWw6IGJvb2xlYW4sXG4gIHNlZ21lbnRQYXRoOiBGbGlnaHRTZWdtZW50UGF0aCxcbiAgc2Nyb2xsYWJsZVNlZ21lbnRzUmVzdWx0OiBBcnJheTxGbGlnaHRTZWdtZW50UGF0aD5cbik6IFJlYWR5Q2FjaGVOb2RlIHtcbiAgY29uc3Qgcm91dGVyU3RhdGVDaGlsZHJlbiA9IHJvdXRlclN0YXRlWzFdXG4gIGNvbnN0IHByZWZldGNoRGF0YUNoaWxkcmVuID0gcHJlZmV0Y2hEYXRhICE9PSBudWxsID8gcHJlZmV0Y2hEYXRhWzJdIDogbnVsbFxuXG4gIGNvbnN0IHBhcmFsbGVsUm91dGVzID0gbmV3IE1hcCgpXG4gIGZvciAobGV0IHBhcmFsbGVsUm91dGVLZXkgaW4gcm91dGVyU3RhdGVDaGlsZHJlbikge1xuICAgIGNvbnN0IHJvdXRlclN0YXRlQ2hpbGQ6IEZsaWdodFJvdXRlclN0YXRlID1cbiAgICAgIHJvdXRlclN0YXRlQ2hpbGRyZW5bcGFyYWxsZWxSb3V0ZUtleV1cbiAgICBjb25zdCBwcmVmZXRjaERhdGFDaGlsZDogQ2FjaGVOb2RlU2VlZERhdGEgfCBudWxsIHwgdm9pZCA9XG4gICAgICBwcmVmZXRjaERhdGFDaGlsZHJlbiAhPT0gbnVsbFxuICAgICAgICA/IHByZWZldGNoRGF0YUNoaWxkcmVuW3BhcmFsbGVsUm91dGVLZXldXG4gICAgICAgIDogbnVsbFxuXG4gICAgY29uc3Qgc2VnbWVudENoaWxkID0gcm91dGVyU3RhdGVDaGlsZFswXVxuICAgIGNvbnN0IHNlZ21lbnRQYXRoQ2hpbGQgPSBzZWdtZW50UGF0aC5jb25jYXQoW1xuICAgICAgcGFyYWxsZWxSb3V0ZUtleSxcbiAgICAgIHNlZ21lbnRDaGlsZCxcbiAgICBdKVxuICAgIGNvbnN0IHNlZ21lbnRLZXlDaGlsZCA9IGNyZWF0ZVJvdXRlckNhY2hlS2V5KHNlZ21lbnRDaGlsZClcblxuICAgIGNvbnN0IG5ld0NhY2hlTm9kZUNoaWxkID0gY3JlYXRlUGVuZGluZ0NhY2hlTm9kZShcbiAgICAgIG5hdmlnYXRlZEF0LFxuICAgICAgcm91dGVyU3RhdGVDaGlsZCxcbiAgICAgIHByZWZldGNoRGF0YUNoaWxkID09PSB1bmRlZmluZWQgPyBudWxsIDogcHJlZmV0Y2hEYXRhQ2hpbGQsXG4gICAgICBwcmVmZXRjaEhlYWQsXG4gICAgICBpc1ByZWZldGNoSGVhZFBhcnRpYWwsXG4gICAgICBzZWdtZW50UGF0aENoaWxkLFxuICAgICAgc2Nyb2xsYWJsZVNlZ21lbnRzUmVzdWx0XG4gICAgKVxuXG4gICAgY29uc3QgbmV3U2VnbWVudE1hcENoaWxkOiBDaGlsZFNlZ21lbnRNYXAgPSBuZXcgTWFwKClcbiAgICBuZXdTZWdtZW50TWFwQ2hpbGQuc2V0KHNlZ21lbnRLZXlDaGlsZCwgbmV3Q2FjaGVOb2RlQ2hpbGQpXG4gICAgcGFyYWxsZWxSb3V0ZXMuc2V0KHBhcmFsbGVsUm91dGVLZXksIG5ld1NlZ21lbnRNYXBDaGlsZClcbiAgfVxuXG4gIC8vIFRoZSBoZWFkIGlzIGFzc2lnbmVkIHRvIGV2ZXJ5IGxlYWYgc2VnbWVudCBkZWxpdmVyZWQgYnkgdGhlIHNlcnZlci4gQmFzZWRcbiAgLy8gb24gY29ycmVzcG9uZGluZyBsb2dpYyBpbiBmaWxsLWxhenktaXRlbXMtdGlsbC1sZWFmLXdpdGgtaGVhZC50c1xuICBjb25zdCBpc0xlYWZTZWdtZW50ID0gcGFyYWxsZWxSb3V0ZXMuc2l6ZSA9PT0gMFxuXG4gIGlmIChpc0xlYWZTZWdtZW50KSB7XG4gICAgLy8gVGhlIHNlZ21lbnQgcGF0aCBvZiBldmVyeSBsZWFmIHNlZ21lbnQgKGkuZS4gcGFnZSkgaXMgY29sbGVjdGVkIGludG9cbiAgICAvLyBhIHJlc3VsdCBhcnJheS4gVGhpcyBpcyB1c2VkIGJ5IHRoZSBMYXlvdXRSb3V0ZXIgdG8gc2Nyb2xsIHRvIGVuc3VyZSB0aGF0XG4gICAgLy8gbmV3IHBhZ2VzIGFyZSB2aXNpYmxlIGFmdGVyIGEgbmF2aWdhdGlvbi5cbiAgICAvLyBUT0RPOiBXZSBzaG91bGQgdXNlIGEgc3RyaW5nIHRvIHJlcHJlc2VudCB0aGUgc2VnbWVudCBwYXRoIGluc3RlYWQgb2ZcbiAgICAvLyBhbiBhcnJheS4gV2UgYWxyZWFkeSB1c2UgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gZm9yIHRoZSBwYXRoIHdoZW5cbiAgICAvLyBhY2Nlc3NpbmcgdGhlIFNlZ21lbnQgQ2FjaGUsIHNvIHdlIGNhbiB1c2UgdGhlIHNhbWUgb25lLlxuICAgIHNjcm9sbGFibGVTZWdtZW50c1Jlc3VsdC5wdXNoKHNlZ21lbnRQYXRoKVxuICB9XG5cbiAgY29uc3QgbWF5YmVQcmVmZXRjaFJzYyA9IHByZWZldGNoRGF0YSAhPT0gbnVsbCA/IHByZWZldGNoRGF0YVsxXSA6IG51bGxcbiAgY29uc3QgbWF5YmVQcmVmZXRjaExvYWRpbmcgPSBwcmVmZXRjaERhdGEgIT09IG51bGwgPyBwcmVmZXRjaERhdGFbM10gOiBudWxsXG4gIHJldHVybiB7XG4gICAgbGF6eURhdGE6IG51bGwsXG4gICAgcGFyYWxsZWxSb3V0ZXM6IHBhcmFsbGVsUm91dGVzLFxuXG4gICAgcHJlZmV0Y2hSc2M6IG1heWJlUHJlZmV0Y2hSc2MgIT09IHVuZGVmaW5lZCA/IG1heWJlUHJlZmV0Y2hSc2MgOiBudWxsLFxuICAgIHByZWZldGNoSGVhZDogaXNMZWFmU2VnbWVudCA/IHByZWZldGNoSGVhZCA6IFtudWxsLCBudWxsXSxcblxuICAgIC8vIFRPRE86IFRlY2huaWNhbGx5LCBhIGxvYWRpbmcgYm91bmRhcnkgY291bGQgY29udGFpbiBkeW5hbWljIGRhdGEuIFdlIG11c3RcbiAgICAvLyBoYXZlIHNlcGFyYXRlIGBsb2FkaW5nYCBhbmQgYHByZWZldGNoTG9hZGluZ2AgZmllbGRzIHRvIGhhbmRsZSB0aGlzLCBsaWtlXG4gICAgLy8gd2UgZG8gZm9yIHRoZSBzZWdtZW50IGRhdGEgYW5kIGhlYWQuXG4gICAgbG9hZGluZzogbWF5YmVQcmVmZXRjaExvYWRpbmcgIT09IHVuZGVmaW5lZCA/IG1heWJlUHJlZmV0Y2hMb2FkaW5nIDogbnVsbCxcblxuICAgIC8vIENyZWF0ZSBhIGRlZmVycmVkIHByb21pc2UuIFRoaXMgd2lsbCBiZSBmdWxmaWxsZWQgb25jZSB0aGUgZHluYW1pY1xuICAgIC8vIHJlc3BvbnNlIGlzIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlci5cbiAgICByc2M6IGNyZWF0ZURlZmVycmVkUnNjKCkgYXMgUmVhY3QuUmVhY3ROb2RlLFxuICAgIGhlYWQ6IGlzTGVhZlNlZ21lbnQgPyAoY3JlYXRlRGVmZXJyZWRSc2MoKSBhcyBSZWFjdC5SZWFjdE5vZGUpIDogbnVsbCxcblxuICAgIG5hdmlnYXRlZEF0LFxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaFBlbmRpbmdDYWNoZU5vZGUoXG4gIGNhY2hlTm9kZTogQ2FjaGVOb2RlLFxuICB0YXNrU3RhdGU6IEZsaWdodFJvdXRlclN0YXRlLFxuICBzZXJ2ZXJTdGF0ZTogRmxpZ2h0Um91dGVyU3RhdGUsXG4gIGR5bmFtaWNEYXRhOiBDYWNoZU5vZGVTZWVkRGF0YSxcbiAgZHluYW1pY0hlYWQ6IEhlYWREYXRhXG4pOiB2b2lkIHtcbiAgLy8gV3JpdGVzIGEgZHluYW1pYyByZXNwb25zZSBpbnRvIGFuIGV4aXN0aW5nIENhY2hlIE5vZGUgdHJlZS4gVGhpcyBkb2VzIF9ub3RfXG4gIC8vIGNyZWF0ZSBhIG5ldyB0cmVlLCBpdCB1cGRhdGVzIHRoZSBleGlzdGluZyB0cmVlIGluLXBsYWNlLiBTbyBpdCBtdXN0IGZvbGxvd1xuICAvLyB0aGUgU3VzcGVuc2UgcnVsZXMgb2YgY2FjaGUgc2FmZXR5IOKAlCBpdCBjYW4gcmVzb2x2ZSBwZW5kaW5nIHByb21pc2VzLCBidXRcbiAgLy8gaXQgY2Fubm90IG92ZXJ3cml0ZSBleGlzdGluZyBkYXRhLiBJdCBjYW4gYWRkIHNlZ21lbnRzIHRvIHRoZSB0cmVlIChiZWNhdXNlXG4gIC8vIGEgbWlzc2luZyBzZWdtZW50IHdpbGwgY2F1c2UgdGhlIGxheW91dCByb3V0ZXIgdG8gc3VzcGVuZCkuXG4gIC8vIGJ1dCBpdCBjYW5ub3QgZGVsZXRlIHRoZW0uXG4gIC8vXG4gIC8vIFdlIG11c3QgcmVzb2x2ZSBldmVyeSBwcm9taXNlIGluIHRoZSB0cmVlLCBvciBlbHNlIGl0IHdpbGwgc3VzcGVuZFxuICAvLyBpbmRlZmluaXRlbHkuIElmIHdlIGRpZCBub3QgcmVjZWl2ZSBkYXRhIGZvciBhIHNlZ21lbnQsIHdlIHdpbGwgcmVzb2x2ZSBpdHNcbiAgLy8gZGF0YSBwcm9taXNlIHRvIGBudWxsYCB0byB0cmlnZ2VyIGEgbGF6eSBmZXRjaCBkdXJpbmcgcmVuZGVyLlxuICBjb25zdCB0YXNrU3RhdGVDaGlsZHJlbiA9IHRhc2tTdGF0ZVsxXVxuICBjb25zdCBzZXJ2ZXJTdGF0ZUNoaWxkcmVuID0gc2VydmVyU3RhdGVbMV1cbiAgY29uc3QgZGF0YUNoaWxkcmVuID0gZHluYW1pY0RhdGFbMl1cblxuICAvLyBUaGUgcm91dGVyIHN0YXRlIHRoYXQgd2UgdHJhdmVyc2UgdGhlIHRyZWUgd2l0aCAodGFza1N0YXRlKSBpcyB0aGUgc2FtZSBvbmVcbiAgLy8gdGhhdCB3ZSB1c2VkIHRvIGNvbnN0cnVjdCB0aGUgcGVuZGluZyBDYWNoZSBOb2RlIHRyZWUuIFRoYXQgd2F5IHdlJ3JlIHN1cmVcbiAgLy8gdG8gcmVzb2x2ZSBhbGwgdGhlIHBlbmRpbmcgcHJvbWlzZXMuXG4gIGNvbnN0IHBhcmFsbGVsUm91dGVzID0gY2FjaGVOb2RlLnBhcmFsbGVsUm91dGVzXG4gIGZvciAobGV0IHBhcmFsbGVsUm91dGVLZXkgaW4gdGFza1N0YXRlQ2hpbGRyZW4pIHtcbiAgICBjb25zdCB0YXNrU3RhdGVDaGlsZDogRmxpZ2h0Um91dGVyU3RhdGUgPVxuICAgICAgdGFza1N0YXRlQ2hpbGRyZW5bcGFyYWxsZWxSb3V0ZUtleV1cbiAgICBjb25zdCBzZXJ2ZXJTdGF0ZUNoaWxkOiBGbGlnaHRSb3V0ZXJTdGF0ZSB8IHZvaWQgPVxuICAgICAgc2VydmVyU3RhdGVDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XVxuICAgIGNvbnN0IGRhdGFDaGlsZDogQ2FjaGVOb2RlU2VlZERhdGEgfCBudWxsIHwgdm9pZCA9XG4gICAgICBkYXRhQ2hpbGRyZW5bcGFyYWxsZWxSb3V0ZUtleV1cblxuICAgIGNvbnN0IHNlZ21lbnRNYXBDaGlsZCA9IHBhcmFsbGVsUm91dGVzLmdldChwYXJhbGxlbFJvdXRlS2V5KVxuICAgIGNvbnN0IHRhc2tTZWdtZW50Q2hpbGQgPSB0YXNrU3RhdGVDaGlsZFswXVxuICAgIGNvbnN0IHRhc2tTZWdtZW50S2V5Q2hpbGQgPSBjcmVhdGVSb3V0ZXJDYWNoZUtleSh0YXNrU2VnbWVudENoaWxkKVxuXG4gICAgY29uc3QgY2FjaGVOb2RlQ2hpbGQgPVxuICAgICAgc2VnbWVudE1hcENoaWxkICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBzZWdtZW50TWFwQ2hpbGQuZ2V0KHRhc2tTZWdtZW50S2V5Q2hpbGQpXG4gICAgICAgIDogdW5kZWZpbmVkXG5cbiAgICBpZiAoY2FjaGVOb2RlQ2hpbGQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKFxuICAgICAgICBzZXJ2ZXJTdGF0ZUNoaWxkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgbWF0Y2hTZWdtZW50KHRhc2tTZWdtZW50Q2hpbGQsIHNlcnZlclN0YXRlQ2hpbGRbMF0pXG4gICAgICApIHtcbiAgICAgICAgaWYgKGRhdGFDaGlsZCAhPT0gdW5kZWZpbmVkICYmIGRhdGFDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGhhcHB5IHBhdGguIFJlY3Vyc2l2ZWx5IHVwZGF0ZSBhbGwgdGhlIGNoaWxkcmVuLlxuICAgICAgICAgIGZpbmlzaFBlbmRpbmdDYWNoZU5vZGUoXG4gICAgICAgICAgICBjYWNoZU5vZGVDaGlsZCxcbiAgICAgICAgICAgIHRhc2tTdGF0ZUNoaWxkLFxuICAgICAgICAgICAgc2VydmVyU3RhdGVDaGlsZCxcbiAgICAgICAgICAgIGRhdGFDaGlsZCxcbiAgICAgICAgICAgIGR5bmFtaWNIZWFkXG4gICAgICAgICAgKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoZSBzZXJ2ZXIgbmV2ZXIgcmV0dXJuZWQgZGF0YSBmb3IgdGhpcyBzZWdtZW50LiBUcmlnZ2VyIGEgbGF6eVxuICAgICAgICAgIC8vIGZldGNoIGR1cmluZyByZW5kZXIuIFRoaXMgc2hvdWxkbid0IGhhcHBlbiBiZWNhdXNlIHRoZSBSb3V0ZSBUcmVlXG4gICAgICAgICAgLy8gYW5kIHRoZSBTZWVkIERhdGEgdHJlZSBzZW50IGJ5IHRoZSBzZXJ2ZXIgc2hvdWxkIGFsd2F5cyBiZSB0aGUgc2FtZVxuICAgICAgICAgIC8vIHNoYXBlIHdoZW4gcGFydCBvZiB0aGUgc2FtZSBzZXJ2ZXIgcmVzcG9uc2UuXG4gICAgICAgICAgYWJvcnRQZW5kaW5nQ2FjaGVOb2RlKHRhc2tTdGF0ZUNoaWxkLCBjYWNoZU5vZGVDaGlsZCwgbnVsbClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhlIHNlcnZlciBuZXZlciByZXR1cm5lZCBkYXRhIGZvciB0aGlzIHNlZ21lbnQuIFRyaWdnZXIgYSBsYXp5XG4gICAgICAgIC8vIGZldGNoIGR1cmluZyByZW5kZXIuXG4gICAgICAgIGFib3J0UGVuZGluZ0NhY2hlTm9kZSh0YXNrU3RhdGVDaGlsZCwgY2FjaGVOb2RlQ2hpbGQsIG51bGwpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSBzZXJ2ZXIgcmVzcG9uc2UgbWF0Y2hlcyB3aGF0IHdhcyBleHBlY3RlZCB0byByZWNlaXZlLCBidXQgdGhlcmUnc1xuICAgICAgLy8gbm8gbWF0Y2hpbmcgQ2FjaGUgTm9kZSBpbiB0aGUgdGFzayB0cmVlLiBUaGlzIGlzIGEgYnVnIGluIHRoZVxuICAgICAgLy8gaW1wbGVtZW50YXRpb24gYmVjYXVzZSB3ZSBzaG91bGQgaGF2ZSBjcmVhdGVkIGEgbm9kZSBmb3IgZXZlcnlcbiAgICAgIC8vIHNlZ21lbnQgaW4gdGhlIHRyZWUgdGhhdCdzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHRhc2suXG4gICAgfVxuICB9XG5cbiAgLy8gVXNlIHRoZSBkeW5hbWljIGRhdGEgZnJvbSB0aGUgc2VydmVyIHRvIGZ1bGZpbGwgdGhlIGRlZmVycmVkIFJTQyBwcm9taXNlXG4gIC8vIG9uIHRoZSBDYWNoZSBOb2RlLlxuICBjb25zdCByc2MgPSBjYWNoZU5vZGUucnNjXG4gIGNvbnN0IGR5bmFtaWNTZWdtZW50RGF0YSA9IGR5bmFtaWNEYXRhWzFdXG4gIGlmIChyc2MgPT09IG51bGwpIHtcbiAgICAvLyBUaGlzIGlzIGEgbGF6eSBjYWNoZSBub2RlLiBXZSBjYW4gb3ZlcndyaXRlIGl0LiBUaGlzIGlzIG9ubHkgc2FmZVxuICAgIC8vIGJlY2F1c2Ugd2Uga25vdyB0aGF0IHRoZSBMYXlvdXRSb3V0ZXIgc3VzcGVuZHMgaWYgYHJzY2AgaXMgYG51bGxgLlxuICAgIGNhY2hlTm9kZS5yc2MgPSBkeW5hbWljU2VnbWVudERhdGFcbiAgfSBlbHNlIGlmIChpc0RlZmVycmVkUnNjKHJzYykpIHtcbiAgICAvLyBUaGlzIGlzIGEgZGVmZXJyZWQgUlNDIHByb21pc2UuIFdlIGNhbiBmdWxmaWxsIGl0IHdpdGggdGhlIGRhdGEgd2UganVzdFxuICAgIC8vIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlci4gSWYgaXQgd2FzIGFscmVhZHkgcmVzb2x2ZWQgYnkgYSBkaWZmZXJlbnRcbiAgICAvLyBuYXZpZ2F0aW9uLCB0aGVuIHRoaXMgZG9lcyBub3RoaW5nIGJlY2F1c2Ugd2UgY2FuJ3Qgb3ZlcndyaXRlIGRhdGEuXG4gICAgcnNjLnJlc29sdmUoZHluYW1pY1NlZ21lbnREYXRhKVxuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgaXMgbm90IGEgZGVmZXJyZWQgUlNDIHByb21pc2UsIG5vciBpcyBpdCBlbXB0eSwgc28gaXQgbXVzdCBoYXZlXG4gICAgLy8gYmVlbiBwb3B1bGF0ZWQgYnkgYSBkaWZmZXJlbnQgbmF2aWdhdGlvbi4gV2UgbXVzdCBub3Qgb3ZlcndyaXRlIGl0LlxuICB9XG5cbiAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIGxlYWYgc2VnbWVudC4gSWYgc28sIGl0IHdpbGwgaGF2ZSBhIGBoZWFkYCBwcm9wZXJ0eSB3aXRoXG4gIC8vIGEgcGVuZGluZyBwcm9taXNlIHRoYXQgbmVlZHMgdG8gYmUgcmVzb2x2ZWQgd2l0aCB0aGUgZHluYW1pYyBoZWFkIGZyb21cbiAgLy8gdGhlIHNlcnZlci5cbiAgY29uc3QgaGVhZCA9IGNhY2hlTm9kZS5oZWFkXG4gIGlmIChpc0RlZmVycmVkUnNjKGhlYWQpKSB7XG4gICAgaGVhZC5yZXNvbHZlKGR5bmFtaWNIZWFkKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhYm9ydFRhc2sodGFzazogU1BBTmF2aWdhdGlvblRhc2ssIGVycm9yOiBhbnkpOiB2b2lkIHtcbiAgY29uc3QgY2FjaGVOb2RlID0gdGFzay5ub2RlXG4gIGlmIChjYWNoZU5vZGUgPT09IG51bGwpIHtcbiAgICAvLyBUaGlzIGluZGljYXRlcyB0aGUgdGFzayBpcyBhbHJlYWR5IGNvbXBsZXRlLlxuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3QgdGFza0NoaWxkcmVuID0gdGFzay5jaGlsZHJlblxuICBpZiAodGFza0NoaWxkcmVuID09PSBudWxsKSB7XG4gICAgLy8gUmVhY2hlZCB0aGUgbGVhZiB0YXNrIG5vZGUuIFRoaXMgaXMgdGhlIHJvb3Qgb2YgYSBwZW5kaW5nIGNhY2hlXG4gICAgLy8gbm9kZSB0cmVlLlxuICAgIGFib3J0UGVuZGluZ0NhY2hlTm9kZSh0YXNrLnJvdXRlLCBjYWNoZU5vZGUsIGVycm9yKVxuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgaXMgYW4gaW50ZXJtZWRpYXRlIHRhc2sgbm9kZS4gS2VlcCB0cmF2ZXJzaW5nIHVudGlsIHdlIHJlYWNoIGFcbiAgICAvLyB0YXNrIG5vZGUgd2l0aCBubyBjaGlsZHJlbi4gVGhhdCB3aWxsIGJlIHRoZSByb290IG9mIHRoZSBjYWNoZSBub2RlIHRyZWVcbiAgICAvLyB0aGF0IG5lZWRzIHRvIGJlIHJlc29sdmVkLlxuICAgIGZvciAoY29uc3QgdGFza0NoaWxkIG9mIHRhc2tDaGlsZHJlbi52YWx1ZXMoKSkge1xuICAgICAgYWJvcnRUYXNrKHRhc2tDaGlsZCwgZXJyb3IpXG4gICAgfVxuICB9XG5cbiAgLy8gU2V0IHRoaXMgdG8gbnVsbCB0byBpbmRpY2F0ZSB0aGF0IHRoaXMgdGFzayBpcyBub3cgY29tcGxldGUuXG4gIHRhc2suZHluYW1pY1JlcXVlc3RUcmVlID0gbnVsbFxufVxuXG5mdW5jdGlvbiBhYm9ydFBlbmRpbmdDYWNoZU5vZGUoXG4gIHJvdXRlclN0YXRlOiBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgY2FjaGVOb2RlOiBDYWNoZU5vZGUsXG4gIGVycm9yOiBhbnlcbik6IHZvaWQge1xuICAvLyBGb3IgZXZlcnkgcGVuZGluZyBzZWdtZW50IGluIHRoZSB0cmVlLCByZXNvbHZlIGl0cyBgcnNjYCBwcm9taXNlIHRvIGBudWxsYFxuICAvLyB0byB0cmlnZ2VyIGEgbGF6eSBmZXRjaCBkdXJpbmcgcmVuZGVyLlxuICAvL1xuICAvLyBPciwgaWYgYW4gZXJyb3Igb2JqZWN0IGlzIHByb3ZpZGVkLCBpdCB3aWxsIGVycm9yIGluc3RlYWQuXG4gIGNvbnN0IHJvdXRlclN0YXRlQ2hpbGRyZW4gPSByb3V0ZXJTdGF0ZVsxXVxuICBjb25zdCBwYXJhbGxlbFJvdXRlcyA9IGNhY2hlTm9kZS5wYXJhbGxlbFJvdXRlc1xuICBmb3IgKGxldCBwYXJhbGxlbFJvdXRlS2V5IGluIHJvdXRlclN0YXRlQ2hpbGRyZW4pIHtcbiAgICBjb25zdCByb3V0ZXJTdGF0ZUNoaWxkOiBGbGlnaHRSb3V0ZXJTdGF0ZSA9XG4gICAgICByb3V0ZXJTdGF0ZUNoaWxkcmVuW3BhcmFsbGVsUm91dGVLZXldXG4gICAgY29uc3Qgc2VnbWVudE1hcENoaWxkID0gcGFyYWxsZWxSb3V0ZXMuZ2V0KHBhcmFsbGVsUm91dGVLZXkpXG4gICAgaWYgKHNlZ21lbnRNYXBDaGlsZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBUaGlzIHNob3VsZG4ndCBoYXBwZW4gYmVjYXVzZSB3ZSdyZSB0cmF2ZXJzaW5nIHRoZSBzYW1lIHRyZWUgdGhhdCB3YXNcbiAgICAgIC8vIHVzZWQgdG8gY29uc3RydWN0IHRoZSBjYWNoZSBub2RlcyBpbiB0aGUgZmlyc3QgcGxhY2UuXG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBjb25zdCBzZWdtZW50Q2hpbGQgPSByb3V0ZXJTdGF0ZUNoaWxkWzBdXG4gICAgY29uc3Qgc2VnbWVudEtleUNoaWxkID0gY3JlYXRlUm91dGVyQ2FjaGVLZXkoc2VnbWVudENoaWxkKVxuICAgIGNvbnN0IGNhY2hlTm9kZUNoaWxkID0gc2VnbWVudE1hcENoaWxkLmdldChzZWdtZW50S2V5Q2hpbGQpXG4gICAgaWYgKGNhY2hlTm9kZUNoaWxkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGFib3J0UGVuZGluZ0NhY2hlTm9kZShyb3V0ZXJTdGF0ZUNoaWxkLCBjYWNoZU5vZGVDaGlsZCwgZXJyb3IpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgc2hvdWxkbid0IGhhcHBlbiBiZWNhdXNlIHdlJ3JlIHRyYXZlcnNpbmcgdGhlIHNhbWUgdHJlZSB0aGF0IHdhc1xuICAgICAgLy8gdXNlZCB0byBjb25zdHJ1Y3QgdGhlIGNhY2hlIG5vZGVzIGluIHRoZSBmaXJzdCBwbGFjZS5cbiAgICB9XG4gIH1cbiAgY29uc3QgcnNjID0gY2FjaGVOb2RlLnJzY1xuICBpZiAoaXNEZWZlcnJlZFJzYyhyc2MpKSB7XG4gICAgaWYgKGVycm9yID09PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIHdpbGwgdHJpZ2dlciBhIGxhenkgZmV0Y2ggZHVyaW5nIHJlbmRlci5cbiAgICAgIHJzYy5yZXNvbHZlKG51bGwpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgd2lsbCB0cmlnZ2VyIGFuIGVycm9yIGR1cmluZyByZW5kZXJpbmcuXG4gICAgICByc2MucmVqZWN0KGVycm9yKVxuICAgIH1cbiAgfVxuXG4gIC8vIENoZWNrIGlmIHRoaXMgaXMgYSBsZWFmIHNlZ21lbnQuIElmIHNvLCBpdCB3aWxsIGhhdmUgYSBgaGVhZGAgcHJvcGVydHkgd2l0aFxuICAvLyBhIHBlbmRpbmcgcHJvbWlzZSB0aGF0IG5lZWRzIHRvIGJlIHJlc29sdmVkLiBJZiBhbiBlcnJvciB3YXMgcHJvdmlkZWQsIHdlXG4gIC8vIHdpbGwgbm90IHJlc29sdmUgaXQgd2l0aCBhbiBlcnJvciwgc2luY2UgdGhpcyBpcyByZW5kZXJlZCBhdCB0aGUgcm9vdCBvZlxuICAvLyB0aGUgYXBwLiBXZSB3YW50IHRoZSBzZWdtZW50IHRvIGVycm9yLCBub3QgdGhlIGVudGlyZSBhcHAuXG4gIGNvbnN0IGhlYWQgPSBjYWNoZU5vZGUuaGVhZFxuICBpZiAoaXNEZWZlcnJlZFJzYyhoZWFkKSkge1xuICAgIGhlYWQucmVzb2x2ZShudWxsKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVDYWNoZU5vZGVPblBvcHN0YXRlUmVzdG9yYXRpb24oXG4gIG9sZENhY2hlTm9kZTogQ2FjaGVOb2RlLFxuICByb3V0ZXJTdGF0ZTogRmxpZ2h0Um91dGVyU3RhdGVcbik6IFJlYWR5Q2FjaGVOb2RlIHtcbiAgLy8gQSBwb3BzdGF0ZSBuYXZpZ2F0aW9uIHJlYWRzIGRhdGEgZnJvbSB0aGUgbG9jYWwgY2FjaGUuIEl0IGRvZXMgbm90IGlzc3VlXG4gIC8vIG5ldyBuZXR3b3JrIHJlcXVlc3RzICh1bmxlc3MgdGhlIGNhY2hlIGVudHJpZXMgaGF2ZSBiZWVuIGV2aWN0ZWQpLiBTbywgd2VcbiAgLy8gdXBkYXRlIHRoZSBjYWNoZSB0byBkcm9wIHRoZSBwcmVmZXRjaCBkYXRhIGZvciBhbnkgc2VnbWVudCB3aG9zZSBkeW5hbWljXG4gIC8vIGRhdGEgd2FzIGFscmVhZHkgcmVjZWl2ZWQuIFRoaXMgcHJldmVudHMgYW4gdW5uZWNlc3NhcnkgZmxhc2ggYmFjayB0byBQUFJcbiAgLy8gc3RhdGUgZHVyaW5nIGEgYmFjay9mb3J3YXJkIG5hdmlnYXRpb24uXG4gIC8vXG4gIC8vIFRoaXMgZnVuY3Rpb24gY2xvbmVzIHRoZSBlbnRpcmUgY2FjaGUgbm9kZSB0cmVlIGFuZCBzZXRzIHRoZSBgcHJlZmV0Y2hSc2NgXG4gIC8vIGZpZWxkIHRvIGBudWxsYCB0byBwcmV2ZW50IGl0IGZyb20gYmVpbmcgcmVuZGVyZWQuIFdlIGNhbid0IG11dGF0ZSB0aGUgbm9kZVxuICAvLyBpbiBwbGFjZSBiZWNhdXNlIHRoaXMgaXMgYSBjb25jdXJyZW50IGRhdGEgc3RydWN0dXJlLlxuXG4gIGNvbnN0IHJvdXRlclN0YXRlQ2hpbGRyZW4gPSByb3V0ZXJTdGF0ZVsxXVxuICBjb25zdCBvbGRQYXJhbGxlbFJvdXRlcyA9IG9sZENhY2hlTm9kZS5wYXJhbGxlbFJvdXRlc1xuICBjb25zdCBuZXdQYXJhbGxlbFJvdXRlcyA9IG5ldyBNYXAob2xkUGFyYWxsZWxSb3V0ZXMpXG4gIGZvciAobGV0IHBhcmFsbGVsUm91dGVLZXkgaW4gcm91dGVyU3RhdGVDaGlsZHJlbikge1xuICAgIGNvbnN0IHJvdXRlclN0YXRlQ2hpbGQ6IEZsaWdodFJvdXRlclN0YXRlID1cbiAgICAgIHJvdXRlclN0YXRlQ2hpbGRyZW5bcGFyYWxsZWxSb3V0ZUtleV1cbiAgICBjb25zdCBzZWdtZW50Q2hpbGQgPSByb3V0ZXJTdGF0ZUNoaWxkWzBdXG4gICAgY29uc3Qgc2VnbWVudEtleUNoaWxkID0gY3JlYXRlUm91dGVyQ2FjaGVLZXkoc2VnbWVudENoaWxkKVxuICAgIGNvbnN0IG9sZFNlZ21lbnRNYXBDaGlsZCA9IG9sZFBhcmFsbGVsUm91dGVzLmdldChwYXJhbGxlbFJvdXRlS2V5KVxuICAgIGlmIChvbGRTZWdtZW50TWFwQ2hpbGQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3Qgb2xkQ2FjaGVOb2RlQ2hpbGQgPSBvbGRTZWdtZW50TWFwQ2hpbGQuZ2V0KHNlZ21lbnRLZXlDaGlsZClcbiAgICAgIGlmIChvbGRDYWNoZU5vZGVDaGlsZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IG5ld0NhY2hlTm9kZUNoaWxkID0gdXBkYXRlQ2FjaGVOb2RlT25Qb3BzdGF0ZVJlc3RvcmF0aW9uKFxuICAgICAgICAgIG9sZENhY2hlTm9kZUNoaWxkLFxuICAgICAgICAgIHJvdXRlclN0YXRlQ2hpbGRcbiAgICAgICAgKVxuICAgICAgICBjb25zdCBuZXdTZWdtZW50TWFwQ2hpbGQgPSBuZXcgTWFwKG9sZFNlZ21lbnRNYXBDaGlsZClcbiAgICAgICAgbmV3U2VnbWVudE1hcENoaWxkLnNldChzZWdtZW50S2V5Q2hpbGQsIG5ld0NhY2hlTm9kZUNoaWxkKVxuICAgICAgICBuZXdQYXJhbGxlbFJvdXRlcy5zZXQocGFyYWxsZWxSb3V0ZUtleSwgbmV3U2VnbWVudE1hcENoaWxkKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIE9ubHkgc2hvdyBwcmVmZXRjaGVkIGRhdGEgaWYgdGhlIGR5bmFtaWMgZGF0YSBpcyBzdGlsbCBwZW5kaW5nLlxuICAvL1xuICAvLyBUZWhuaWNhbGx5LCB3aGF0IHdlJ3JlIGFjdHVhbGx5IGNoZWNraW5nIGlzIHdoZXRoZXIgdGhlIGR5bmFtaWMgbmV0d29ya1xuICAvLyByZXNwb25zZSB3YXMgcmVjZWl2ZWQuIEJ1dCBzaW5jZSBpdCdzIGEgc3RyZWFtaW5nIHJlc3BvbnNlLCB0aGlzIGRvZXMgbm90XG4gIC8vIG1lYW4gdGhhdCBhbGwgdGhlIGR5bmFtaWMgZGF0YSBoYXMgZnVsbHkgc3RyZWFtZWQgaW4uIEl0IGp1c3QgbWVhbnMgdGhhdFxuICAvLyBfc29tZV8gb2YgdGhlIGR5bmFtaWMgZGF0YSB3YXMgcmVjZWl2ZWQuIEJ1dCBhcyBhIGhldXJpc3RpYywgd2UgYXNzdW1lIHRoYXRcbiAgLy8gdGhlIHJlc3QgZHluYW1pYyBkYXRhIHdpbGwgc3RyZWFtIGluIHF1aWNrbHksIHNvIGl0J3Mgc3RpbGwgYmV0dGVyIHRvIHNraXBcbiAgLy8gdGhlIHByZWZldGNoIHN0YXRlLlxuICBjb25zdCByc2MgPSBvbGRDYWNoZU5vZGUucnNjXG4gIGNvbnN0IHNob3VsZFVzZVByZWZldGNoID0gaXNEZWZlcnJlZFJzYyhyc2MpICYmIHJzYy5zdGF0dXMgPT09ICdwZW5kaW5nJ1xuXG4gIHJldHVybiB7XG4gICAgbGF6eURhdGE6IG51bGwsXG4gICAgcnNjLFxuICAgIGhlYWQ6IG9sZENhY2hlTm9kZS5oZWFkLFxuXG4gICAgcHJlZmV0Y2hIZWFkOiBzaG91bGRVc2VQcmVmZXRjaCA/IG9sZENhY2hlTm9kZS5wcmVmZXRjaEhlYWQgOiBbbnVsbCwgbnVsbF0sXG4gICAgcHJlZmV0Y2hSc2M6IHNob3VsZFVzZVByZWZldGNoID8gb2xkQ2FjaGVOb2RlLnByZWZldGNoUnNjIDogbnVsbCxcbiAgICBsb2FkaW5nOiBvbGRDYWNoZU5vZGUubG9hZGluZyxcblxuICAgIC8vIFRoZXNlIGFyZSB0aGUgY2xvbmVkIGNoaWxkcmVuIHdlIGNvbXB1dGVkIGFib3ZlXG4gICAgcGFyYWxsZWxSb3V0ZXM6IG5ld1BhcmFsbGVsUm91dGVzLFxuXG4gICAgbmF2aWdhdGVkQXQ6IG9sZENhY2hlTm9kZS5uYXZpZ2F0ZWRBdCxcbiAgfVxufVxuXG5jb25zdCBERUZFUlJFRCA9IFN5bWJvbCgpXG5cbnR5cGUgUGVuZGluZ0RlZmVycmVkUnNjID0gUHJvbWlzZTxSZWFjdC5SZWFjdE5vZGU+ICYge1xuICBzdGF0dXM6ICdwZW5kaW5nJ1xuICByZXNvbHZlOiAodmFsdWU6IFJlYWN0LlJlYWN0Tm9kZSkgPT4gdm9pZFxuICByZWplY3Q6IChlcnJvcjogYW55KSA9PiB2b2lkXG4gIHRhZzogU3ltYm9sXG59XG5cbnR5cGUgRnVsZmlsbGVkRGVmZXJyZWRSc2MgPSBQcm9taXNlPFJlYWN0LlJlYWN0Tm9kZT4gJiB7XG4gIHN0YXR1czogJ2Z1bGZpbGxlZCdcbiAgdmFsdWU6IFJlYWN0LlJlYWN0Tm9kZVxuICByZXNvbHZlOiAodmFsdWU6IFJlYWN0LlJlYWN0Tm9kZSkgPT4gdm9pZFxuICByZWplY3Q6IChlcnJvcjogYW55KSA9PiB2b2lkXG4gIHRhZzogU3ltYm9sXG59XG5cbnR5cGUgUmVqZWN0ZWREZWZlcnJlZFJzYyA9IFByb21pc2U8UmVhY3QuUmVhY3ROb2RlPiAmIHtcbiAgc3RhdHVzOiAncmVqZWN0ZWQnXG4gIHJlYXNvbjogYW55XG4gIHJlc29sdmU6ICh2YWx1ZTogUmVhY3QuUmVhY3ROb2RlKSA9PiB2b2lkXG4gIHJlamVjdDogKGVycm9yOiBhbnkpID0+IHZvaWRcbiAgdGFnOiBTeW1ib2xcbn1cblxudHlwZSBEZWZlcnJlZFJzYyA9XG4gIHwgUGVuZGluZ0RlZmVycmVkUnNjXG4gIHwgRnVsZmlsbGVkRGVmZXJyZWRSc2NcbiAgfCBSZWplY3RlZERlZmVycmVkUnNjXG5cbi8vIFRoaXMgdHlwZSBleGlzdHMgdG8gZGlzdGluZ3Vpc2ggYSBEZWZlcnJlZFJzYyBmcm9tIGEgRmxpZ2h0IHByb21pc2UuIEl0J3MgYVxuLy8gY29tcHJvbWlzZSB0byBhdm9pZCBhZGRpbmcgYW4gZXh0cmEgZmllbGQgb24gZXZlcnkgQ2FjaGUgTm9kZSwgd2hpY2ggd291bGQgYmVcbi8vIGF3a3dhcmQgYmVjYXVzZSB0aGUgcHJlLVBQUiBwYXJ0cyBvZiBjb2RlYmFzZSB3b3VsZCBuZWVkIHRvIGFjY291bnQgZm9yIGl0LFxuLy8gdG9vLiBXZSBjYW4gcmVtb3ZlIGl0IG9uY2UgdHlwZSBDYWNoZSBOb2RlIHR5cGUgaXMgbW9yZSBzZXR0bGVkLlxuZnVuY3Rpb24gaXNEZWZlcnJlZFJzYyh2YWx1ZTogYW55KTogdmFsdWUgaXMgRGVmZXJyZWRSc2Mge1xuICByZXR1cm4gdmFsdWUgJiYgdmFsdWUudGFnID09PSBERUZFUlJFRFxufVxuXG5mdW5jdGlvbiBjcmVhdGVEZWZlcnJlZFJzYygpOiBQZW5kaW5nRGVmZXJyZWRSc2Mge1xuICBsZXQgcmVzb2x2ZTogYW55XG4gIGxldCByZWplY3Q6IGFueVxuICBjb25zdCBwZW5kaW5nUnNjID0gbmV3IFByb21pc2U8UmVhY3QuUmVhY3ROb2RlPigocmVzLCByZWopID0+IHtcbiAgICByZXNvbHZlID0gcmVzXG4gICAgcmVqZWN0ID0gcmVqXG4gIH0pIGFzIFBlbmRpbmdEZWZlcnJlZFJzY1xuICBwZW5kaW5nUnNjLnN0YXR1cyA9ICdwZW5kaW5nJ1xuICBwZW5kaW5nUnNjLnJlc29sdmUgPSAodmFsdWU6IFJlYWN0LlJlYWN0Tm9kZSkgPT4ge1xuICAgIGlmIChwZW5kaW5nUnNjLnN0YXR1cyA9PT0gJ3BlbmRpbmcnKSB7XG4gICAgICBjb25zdCBmdWxmaWxsZWRSc2M6IEZ1bGZpbGxlZERlZmVycmVkUnNjID0gcGVuZGluZ1JzYyBhcyBhbnlcbiAgICAgIGZ1bGZpbGxlZFJzYy5zdGF0dXMgPSAnZnVsZmlsbGVkJ1xuICAgICAgZnVsZmlsbGVkUnNjLnZhbHVlID0gdmFsdWVcbiAgICAgIHJlc29sdmUodmFsdWUpXG4gICAgfVxuICB9XG4gIHBlbmRpbmdSc2MucmVqZWN0ID0gKGVycm9yOiBhbnkpID0+IHtcbiAgICBpZiAocGVuZGluZ1JzYy5zdGF0dXMgPT09ICdwZW5kaW5nJykge1xuICAgICAgY29uc3QgcmVqZWN0ZWRSc2M6IFJlamVjdGVkRGVmZXJyZWRSc2MgPSBwZW5kaW5nUnNjIGFzIGFueVxuICAgICAgcmVqZWN0ZWRSc2Muc3RhdHVzID0gJ3JlamVjdGVkJ1xuICAgICAgcmVqZWN0ZWRSc2MucmVhc29uID0gZXJyb3JcbiAgICAgIHJlamVjdChlcnJvcilcbiAgICB9XG4gIH1cbiAgcGVuZGluZ1JzYy50YWcgPSBERUZFUlJFRFxuICByZXR1cm4gcGVuZGluZ1JzY1xufVxuIl0sIm5hbWVzIjpbImFib3J0VGFzayIsImxpc3RlbkZvckR5bmFtaWNSZXF1ZXN0Iiwic3RhcnRQUFJOYXZpZ2F0aW9uIiwidXBkYXRlQ2FjaGVOb2RlT25Qb3BzdGF0ZVJlc3RvcmF0aW9uIiwiTVBBX05BVklHQVRJT05fVEFTSyIsInJvdXRlIiwibm9kZSIsImR5bmFtaWNSZXF1ZXN0VHJlZSIsImNoaWxkcmVuIiwibmF2aWdhdGVkQXQiLCJvbGRDYWNoZU5vZGUiLCJvbGRSb3V0ZXJTdGF0ZSIsIm5ld1JvdXRlclN0YXRlIiwicHJlZmV0Y2hEYXRhIiwicHJlZmV0Y2hIZWFkIiwiaXNQcmVmZXRjaEhlYWRQYXJ0aWFsIiwiaXNTYW1lUGFnZU5hdmlnYXRpb24iLCJzY3JvbGxhYmxlU2VnbWVudHNSZXN1bHQiLCJzZWdtZW50UGF0aCIsInVwZGF0ZUNhY2hlTm9kZU9uTmF2aWdhdGlvbiIsImRpZEZpbmRSb290TGF5b3V0Iiwib2xkUm91dGVyU3RhdGVDaGlsZHJlbiIsIm5ld1JvdXRlclN0YXRlQ2hpbGRyZW4iLCJwcmVmZXRjaERhdGFDaGlsZHJlbiIsImlzUm9vdExheW91dCIsIm9sZFBhcmFsbGVsUm91dGVzIiwicGFyYWxsZWxSb3V0ZXMiLCJwcmVmZXRjaFBhcmFsbGVsUm91dGVzIiwiTWFwIiwicGF0Y2hlZFJvdXRlclN0YXRlQ2hpbGRyZW4iLCJ0YXNrQ2hpbGRyZW4iLCJuZWVkc0R5bmFtaWNSZXF1ZXN0IiwiZHluYW1pY1JlcXVlc3RUcmVlQ2hpbGRyZW4iLCJwYXJhbGxlbFJvdXRlS2V5IiwibmV3Um91dGVyU3RhdGVDaGlsZCIsIm9sZFJvdXRlclN0YXRlQ2hpbGQiLCJvbGRTZWdtZW50TWFwQ2hpbGQiLCJnZXQiLCJwcmVmZXRjaERhdGFDaGlsZCIsIm5ld1NlZ21lbnRDaGlsZCIsIm5ld1NlZ21lbnRQYXRoQ2hpbGQiLCJjb25jYXQiLCJuZXdTZWdtZW50S2V5Q2hpbGQiLCJjcmVhdGVSb3V0ZXJDYWNoZUtleSIsIm9sZFNlZ21lbnRDaGlsZCIsInVuZGVmaW5lZCIsIm9sZENhY2hlTm9kZUNoaWxkIiwidGFza0NoaWxkIiwiREVGQVVMVF9TRUdNRU5UX0tFWSIsInNwYXduUmV1c2VkVGFzayIsImJlZ2luUmVuZGVyaW5nTmV3Um91dGVUcmVlIiwiT2JqZWN0Iiwia2V5cyIsImxlbmd0aCIsIm1hdGNoU2VnbWVudCIsInNldCIsIm5ld0NhY2hlTm9kZUNoaWxkIiwibmV3U2VnbWVudE1hcENoaWxkIiwidGFza0NoaWxkUm91dGUiLCJkeW5hbWljUmVxdWVzdFRyZWVDaGlsZCIsIm5ld0NhY2hlTm9kZSIsImxhenlEYXRhIiwicnNjIiwicHJlZmV0Y2hSc2MiLCJoZWFkIiwibG9hZGluZyIsInBhdGNoUm91dGVyU3RhdGVXaXRoTmV3Q2hpbGRyZW4iLCJleGlzdGluZ0NhY2hlTm9kZSIsInBvc3NpYmx5UGFydGlhbFByZWZldGNoSGVhZCIsImlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dCIsImNyZWF0ZUNhY2hlTm9kZU9uTmF2aWdhdGlvbiIsInJvdXRlclN0YXRlIiwicm91dGVyU3RhdGVDaGlsZHJlbiIsImlzTGVhZlNlZ21lbnQiLCJjYWNoZU5vZGVOYXZpZ2F0ZWRBdCIsIkRZTkFNSUNfU1RBTEVUSU1FX01TIiwiaXNQcmVmZXRjaFJzY1BhcnRpYWwiLCJzcGF3blBlbmRpbmdUYXNrIiwiZXhpc3RpbmdDYWNoZU5vZGVDaGlsZHJlbiIsImNhY2hlTm9kZUNoaWxkcmVuIiwicHVzaCIsInJvdXRlclN0YXRlQ2hpbGQiLCJleGlzdGluZ1NlZ21lbnRNYXBDaGlsZCIsInNlZ21lbnRDaGlsZCIsInNlZ21lbnRQYXRoQ2hpbGQiLCJzZWdtZW50S2V5Q2hpbGQiLCJleGlzdGluZ0NhY2hlTm9kZUNoaWxkIiwiYmFzZVJvdXRlclN0YXRlIiwibmV3Q2hpbGRyZW4iLCJjbG9uZSIsIm5ld1Rhc2siLCJjcmVhdGVQZW5kaW5nQ2FjaGVOb2RlIiwicmV1c2VkUm91dGVyU3RhdGUiLCJ0YXNrIiwicmVzcG9uc2VQcm9taXNlIiwidGhlbiIsImZsaWdodERhdGEiLCJub3JtYWxpemVkRmxpZ2h0RGF0YSIsInRyZWUiLCJzZXJ2ZXJSb3V0ZXJTdGF0ZSIsInNlZWREYXRhIiwiZHluYW1pY0RhdGEiLCJkeW5hbWljSGVhZCIsIndyaXRlRHluYW1pY0RhdGFJbnRvUGVuZGluZ1Rhc2siLCJlcnJvciIsInJvb3RUYXNrIiwiaSIsInNlZ21lbnQiLCJ0YXNrU2VnbWVudCIsImZpbmlzaFRhc2tVc2luZ0R5bmFtaWNEYXRhUGF5bG9hZCIsInRhc2tOb2RlIiwiZmluaXNoUGVuZGluZ0NhY2hlTm9kZSIsInNlcnZlckNoaWxkcmVuIiwiZHluYW1pY0RhdGFDaGlsZHJlbiIsInNlcnZlclJvdXRlclN0YXRlQ2hpbGQiLCJkeW5hbWljRGF0YUNoaWxkIiwic2l6ZSIsIm1heWJlUHJlZmV0Y2hSc2MiLCJtYXliZVByZWZldGNoTG9hZGluZyIsImNyZWF0ZURlZmVycmVkUnNjIiwiY2FjaGVOb2RlIiwidGFza1N0YXRlIiwic2VydmVyU3RhdGUiLCJ0YXNrU3RhdGVDaGlsZHJlbiIsInNlcnZlclN0YXRlQ2hpbGRyZW4iLCJkYXRhQ2hpbGRyZW4iLCJ0YXNrU3RhdGVDaGlsZCIsInNlcnZlclN0YXRlQ2hpbGQiLCJkYXRhQ2hpbGQiLCJzZWdtZW50TWFwQ2hpbGQiLCJ0YXNrU2VnbWVudENoaWxkIiwidGFza1NlZ21lbnRLZXlDaGlsZCIsImNhY2hlTm9kZUNoaWxkIiwiYWJvcnRQZW5kaW5nQ2FjaGVOb2RlIiwiZHluYW1pY1NlZ21lbnREYXRhIiwiaXNEZWZlcnJlZFJzYyIsInJlc29sdmUiLCJ2YWx1ZXMiLCJyZWplY3QiLCJuZXdQYXJhbGxlbFJvdXRlcyIsInNob3VsZFVzZVByZWZldGNoIiwic3RhdHVzIiwiREVGRVJSRUQiLCJTeW1ib2wiLCJ2YWx1ZSIsInRhZyIsInBlbmRpbmdSc2MiLCJQcm9taXNlIiwicmVzIiwicmVqIiwiZnVsZmlsbGVkUnNjIiwicmVqZWN0ZWRSc2MiLCJyZWFzb24iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7SUEwa0NnQkEsU0FBUyxFQUFBO2VBQVRBOztJQTFWQUMsdUJBQXVCLEVBQUE7ZUFBdkJBOztJQXZwQkFDLGtCQUFrQixFQUFBO2VBQWxCQTs7SUE2akNBQyxvQ0FBb0MsRUFBQTtlQUFwQ0E7Ozt5QkF6b0NvQjsrQkFDUDtzQ0FDUTs2Q0FFTztvQ0FDUDtBQWlDckMsTUFBTUMsc0JBQXlDO0lBQzdDQyxPQUFPO0lBQ1BDLE1BQU07SUFDTkMsb0JBQW9CO0lBQ3BCQyxVQUFVO0FBQ1o7QUFpQ08sU0FBU04sbUJBQ2RPLFdBQW1CLEVBQ25CQyxZQUF1QixFQUN2QkMsY0FBaUMsRUFDakNDLGNBQWlDLEVBQ2pDQyxZQUFzQyxFQUN0Q0MsWUFBNkIsRUFDN0JDLHFCQUE4QixFQUM5QkMsb0JBQTZCLEVBQzdCQyx3QkFBa0Q7SUFFbEQsTUFBTUMsY0FBd0MsRUFBRTtJQUNoRCxPQUFPQyw0QkFDTFYsYUFDQUMsY0FDQUMsZ0JBQ0FDLGdCQUNBLE9BQ0FDLGNBQ0FDLGNBQ0FDLHVCQUNBQyxzQkFDQUUsYUFDQUQ7QUFFSjtBQUVBLFNBQVNFLDRCQUNQVixXQUFt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Q1Y7SUFDRjtJQUNBRSxXQUFXUixNQUFNLEdBQUcsQ0FBQ2xDO1FBQ25CLElBQUkwQyxXQUFXTCxNQUFNLEtBQUssV0FBVztZQUNuQyxNQUFNVSxjQUFtQ0w7WUFDekNLLFlBQVlWLE1BQU0sR0FBRztZQUNyQlUsWUFBWUMsTUFBTSxHQUFHaEQ7WUFDckJrQyxPQUFPbEM7UUFDVDtJQUNGO0lBQ0EwQyxXQUFXRCxHQUFHLEdBQUdIO0lBQ2pCLE9BQU9JO0FBQ1QiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTA3MjksICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvY2xlYXItY2FjaGUtbm9kZS1kYXRhLWZvci1zZWdtZW50LXBhdGgudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBGbGlnaHRTZWdtZW50UGF0aCB9IGZyb20gJy4uLy4uLy4uL3NlcnZlci9hcHAtcmVuZGVyL3R5cGVzJ1xuaW1wb3J0IHR5cGUgeyBDYWNoZU5vZGUgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB7IGdldE5leHRGbGlnaHRTZWdtZW50UGF0aCB9IGZyb20gJy4uLy4uL2ZsaWdodC1kYXRhLWhlbHBlcnMnXG5pbXBvcnQgeyBjcmVhdGVSb3V0ZXJDYWNoZUtleSB9IGZyb20gJy4vY3JlYXRlLXJvdXRlci1jYWNoZS1rZXknXG5cbi8qKlxuICogVGhpcyB3aWxsIGNsZWFyIHRoZSBDYWNoZU5vZGUgZGF0YSBmb3IgYSBwYXJ0aWN1bGFyIHNlZ21lbnQgcGF0aC4gVGhpcyB3aWxsIGNhdXNlIGEgbGF6eS1mZXRjaCBpbiBsYXlvdXQgcm91dGVyIHRvIGZpbGwgaW4gbmV3IGRhdGEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhckNhY2hlTm9kZURhdGFGb3JTZWdtZW50UGF0aChcbiAgbmV3Q2FjaGU6IENhY2hlTm9kZSxcbiAgZXhpc3RpbmdDYWNoZTogQ2FjaGVOb2RlLFxuICBmbGlnaHRTZWdtZW50UGF0aDogRmxpZ2h0U2VnbWVudFBhdGhcbik6IHZvaWQge1xuICBjb25zdCBpc0xhc3RFbnRyeSA9IGZsaWdodFNlZ21lbnRQYXRoLmxlbmd0aCA8PSAyXG5cbiAgY29uc3QgW3BhcmFsbGVsUm91dGVLZXksIHNlZ21lbnRdID0gZmxpZ2h0U2VnbWVudFBhdGhcbiAgY29uc3QgY2FjaGVLZXkgPSBjcmVhdGVSb3V0ZXJDYWNoZUtleShzZWdtZW50KVxuXG4gIGNvbnN0IGV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwID1cbiAgICBleGlzdGluZ0NhY2hlLnBhcmFsbGVsUm91dGVzLmdldChwYXJhbGxlbFJvdXRlS2V5KVxuXG4gIGxldCBjaGlsZFNlZ21lbnRNYXAgPSBuZXdDYWNoZS5wYXJhbGxlbFJvdXRlcy5nZXQocGFyYWxsZWxSb3V0ZUtleSlcblxuICBpZiAoIWNoaWxkU2VnbWVudE1hcCB8fCBjaGlsZFNlZ21lbnRNYXAgPT09IGV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwKSB7XG4gICAgY2hpbGRTZWdtZW50TWFwID0gbmV3IE1hcChleGlzdGluZ0NoaWxkU2VnbWVudE1hcClcbiAgICBuZXdDYWNoZS5wYXJhbGxlbFJvdXRlcy5zZXQocGFyYWxsZWxSb3V0ZUtleSwgY2hpbGRTZWdtZW50TWFwKVxuICB9XG5cbiAgY29uc3QgZXhpc3RpbmdDaGlsZENhY2hlTm9kZSA9IGV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwPy5nZXQoY2FjaGVLZXkpXG4gIGxldCBjaGlsZENhY2hlTm9kZSA9IGNoaWxkU2VnbWVudE1hcC5nZXQoY2FjaGVLZXkpXG5cbiAgLy8gSW4gY2FzZSBvZiBsYXN0IHNlZ21lbnQgc3RhcnQgb2ZmIHRoZSBmZXRjaCBhdCB0aGlzIGxldmVsIGFuZCBkb24ndCBjb3B5IGZ1cnRoZXIgZG93bi5cbiAgaWYgKGlzTGFzdEVudHJ5KSB7XG4gICAgaWYgKFxuICAgICAgIWNoaWxkQ2FjaGVOb2RlIHx8XG4gICAgICAhY2hpbGRDYWNoZU5vZGUubGF6eURhdGEgfHxcbiAgICAgIGNoaWxkQ2FjaGVOb2RlID09PSBleGlzdGluZ0NoaWxkQ2FjaGVOb2RlXG4gICAgKSB7XG4gICAgICBjaGlsZFNlZ21lbnRNYXAuc2V0KGNhY2hlS2V5LCB7XG4gICAgICAgIGxhenlEYXRhOiBudWxsLFxuICAgICAgICByc2M6IG51bGwsXG4gICAgICAgIHByZWZldGNoUnNjOiBudWxsLFxuICAgICAgICBoZWFkOiBudWxsLFxuICAgICAgICBwcmVmZXRjaEhlYWQ6IG51bGwsXG4gICAgICAgIHBhcmFsbGVsUm91dGVzOiBuZXcgTWFwKCksXG4gICAgICAgIGxvYWRpbmc6IG51bGwsXG4gICAgICAgIG5hdmlnYXRlZEF0OiAtMSxcbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKCFjaGlsZENhY2hlTm9kZSB8fCAhZXhpc3RpbmdDaGlsZENhY2hlTm9kZSkge1xuICAgIC8vIFN0YXJ0IGZldGNoIGluIHRoZSBwbGFjZSB3aGVyZSB0aGUgZXhpc3RpbmcgY2FjaGUgZG9lc24ndCBoYXZlIHRoZSBkYXRhIHlldC5cbiAgICBpZiAoIWNoaWxkQ2FjaGVOb2RlKSB7XG4gICAgICBjaGlsZFNlZ21lbnRNYXAuc2V0KGNhY2hlS2V5LCB7XG4gICAgICAgIGxhenlEYXRhOiBudWxsLFxuICAgICAgICByc2M6IG51bGwsXG4gICAgICAgIHByZWZldGNoUnNjOiBudWxsLFxuICAgICAgICBoZWFkOiBudWxsLFxuICAgICAgICBwcmVmZXRjaEhlYWQ6IG51bGwsXG4gICAgICAgIHBhcmFsbGVsUm91dGVzOiBuZXcgTWFwKCksXG4gICAgICAgIGxvYWRpbmc6IG51bGwsXG4gICAgICAgIG5hdmlnYXRlZEF0OiAtMSxcbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKGNoaWxkQ2FjaGVOb2RlID09PSBleGlzdGluZ0NoaWxkQ2FjaGVOb2RlKSB7XG4gICAgY2hpbGRDYWNoZU5vZGUgPSB7XG4gICAgICBsYXp5RGF0YTogY2hpbGRDYWNoZU5vZGUubGF6eURhdGEsXG4gICAgICByc2M6IGNoaWxkQ2FjaGVOb2RlLnJzYyxcbiAgICAgIHByZWZldGNoUnNjOiBjaGlsZENhY2hlTm9kZS5wcmVmZXRjaFJzYyxcbiAgICAgIGhlYWQ6IGNoaWxkQ2FjaGVOb2RlLmhlYWQsXG4gICAgICBwcmVmZXRjaEhlYWQ6IGNoaWxkQ2FjaGVOb2RlLnByZWZldGNoSGVhZCxcbiAgICAgIHBhcmFsbGVsUm91dGVzOiBuZXcgTWFwKGNoaWxkQ2FjaGVOb2RlLnBhcmFsbGVsUm91dGVzKSxcbiAgICAgIGxvYWRpbmc6IGNoaWxkQ2FjaGVOb2RlLmxvYWRpbmcsXG4gICAgfSBhcyBDYWNoZU5vZGVcbiAgICBjaGlsZFNlZ21lbnRNYXAuc2V0KGNhY2hlS2V5LCBjaGlsZENhY2hlTm9kZSlcbiAgfVxuXG4gIHJldHVybiBjbGVhckNhY2hlTm9kZURhdGFGb3JTZWdtZW50UGF0aChcbiAgICBjaGlsZENhY2hlTm9kZSxcbiAgICBleGlzdGluZ0NoaWxkQ2FjaGVOb2RlLFxuICAgIGdldE5leHRGbGlnaHRTZWdtZW50UGF0aChmbGlnaHRTZWdtZW50UGF0aClcbiAgKVxufVxuIl0sIm5hbWVzIjpbImNsZWFyQ2FjaGVOb2RlRGF0YUZvclNlZ21lbnRQYXRoIiwibmV3Q2FjaGUiLCJleGlzdGluZ0NhY2hlIiwiZmxpZ2h0U2VnbWVudFBhdGgiLCJpc0xhc3RFbnRyeSIsImxlbmd0aCIsInBhcmFsbGVsUm91dGVLZXkiLCJzZWdtZW50IiwiY2FjaGVLZXkiLCJjcmVhdGVSb3V0ZXJDYWNoZUtleSIsImV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwIiwicGFyYWxsZWxSb3V0ZXMiLCJnZXQiLCJjaGlsZFNlZ21lbnRNYXAiLCJNYXAiLCJzZXQiLCJleGlzdGluZ0NoaWxkQ2FjaGVOb2RlIiwiY2hpbGRDYWNoZU5vZGUiLCJsYXp5RGF0YSIsInJzYyIsInByZWZldGNoUnNjIiwiaGVhZCIsInByZWZldGNoSGVhZCIsImxvYWRpbmciLCJuYXZpZ2F0ZWRBdCIsImdldE5leHRGbGlnaHRTZWdtZW50UGF0aCJdLCJtYXBwaW5ncyI6Ijs7OytCQVFnQkEsb0NBQUFBOzs7ZUFBQUE7OzttQ0FOeUI7c0NBQ0o7QUFLOUIsU0FBU0EsaUNBQ2RDLFFBQW1CLEVBQ25CQyxhQUF3QixFQUN4QkMsaUJBQW9DO0lBRXBDLE1BQU1DLGNBQWNELGtCQUFrQkUsTUFBTSxJQUFJO0lBRWhELE1BQU0sQ0FBQ0Msa0JBQWtCQyxRQUFRLEdBQUdKO0lBQ3BDLE1BQU1LLFdBQVdDLENBQUFBLEdBQUFBLHNCQUFBQSxvQkFBb0IsRUFBQ0Y7SUFFdEMsTUFBTUcsMEJBQ0pSLGNBQWNTLGNBQWMsQ0FBQ0MsR0FBRyxDQUFDTjtJQUVuQyxJQUFJTyxrQkFBa0JaLFNBQVNVLGNBQWMsQ0FBQ0MsR0FBRyxDQUFDTjtJQUVsRCxJQUFJLENBQUNPLG1CQUFtQkEsb0JBQW9CSCx5QkFBeUI7UUFDbkVHLGtCQUFrQixJQUFJQyxJQUFJSjtRQUMxQlQsU0FBU1UsY0FBYyxDQUFDSSxHQUFHLENBQUNULGtCQUFrQk87SUFDaEQ7SUFFQSxNQUFNRyx5QkFBeUJOLDJCQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSx3QkFBeUJFLEdBQUcsQ0FBQ0o7SUFDNUQsSUFBSVMsaUJBQWlCSixnQkFBZ0JELEdBQUcsQ0FBQ0o7SUFFekMseUZBQXlGO0lBQ3pGLElBQUlKLGFBQWE7UUFDZixJQUNFLENBQUNhLGtCQUNELENBQUNBLGVBQWVDLFFBQVEsSUFDeEJELG1CQUFtQkQsd0JBQ25CO1lBQ0FILGdCQUFnQkUsR0FBRyxDQUFDUCxVQUFVO2dCQUM1QlUsVUFBVTtnQkFDVkMsS0FBSztnQkFDTEMsYUFBYTtnQkFDYkMsTUFBTTtnQkFDTkMsY0FBYztnQkFDZFgsZ0JBQWdCLElBQUlHO2dCQUNwQlMsU0FBUztnQkFDVEMsYUFBYSxDQUFDO1lBQ2hCO1FBQ0Y7UUFDQTtJQUNGO0lBRUEsSUFBSSxDQUFDUCxrQkFBa0IsQ0FBQ0Qsd0JBQXdCO1FBQzlDLCtFQUErRTtRQUMvRSxJQUFJLENBQUNDLGdCQUFnQjtZQUNuQkosZ0JBQWdCRSxHQUFHLENBQUNQLFVBQVU7Z0JBQzVCVSxVQUFVO2dCQUNWQyxLQUFLO2dCQUNMQyxhQUFhO2dCQUNiQyxNQUFNO2dCQUNOQyxjQUFjO2dCQUNkWCxnQkFBZ0IsSUFBSUc7Z0JBQ3BCUyxTQUFTO2dCQUNUQyxhQUFhLENBQUM7WUFDaEI7UUFDRjtRQUNBO0lBQ0Y7SUFFQSxJQUFJUCxtQkFBbUJELHdCQUF3QjtRQUM3Q0MsaUJBQWlCO1lBQ2ZDLFVBQVVELGVBQWVDLFFBQVE7WUFDakNDLEtBQUtGLGVBQWVFLEdBQUc7WUFDdkJDLGFBQWFILGVBQWVHLFdBQVc7WUFDdkNDLE1BQU1KLGVBQWVJLElBQUk7WUFDekJDLGNBQWNMLGVBQWVLLFlBQVk7WUFDekNYLGdCQUFnQixJQUFJRyxJQUFJRyxlQUFlTixjQUFjO1lBQ3JEWSxTQUFTTixlQUFlTSxPQUFPO1FBQ2pDO1FBQ0FWLGdCQUFnQkUsR0FBRyxDQUFDUCxVQUFVUztJQUNoQztJQUVBLE9BQU9qQixpQ0FDTGlCLGdCQUNBRCx3QkFDQVMsQ0FBQUEsR0FBQUEsbUJBQUFBLHdCQUF3QixFQUFDdEI7QUFFN0IiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTA4MTEsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvYWxpYXNlZC1wcmVmZXRjaC1uYXZpZ2F0aW9ucy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7XG4gIENhY2hlTm9kZVNlZWREYXRhLFxuICBGbGlnaHRSb3V0ZXJTdGF0ZSxcbn0gZnJvbSAnLi4vLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvdHlwZXMnXG5pbXBvcnQgdHlwZSB7IENhY2hlTm9kZSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHtcbiAgYWRkU2VhcmNoUGFyYW1zSWZQYWdlU2VnbWVudCxcbiAgUEFHRV9TRUdNRU5UX0tFWSxcbn0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2xpYi9zZWdtZW50J1xuaW1wb3J0IHR5cGUgeyBOb3JtYWxpemVkRmxpZ2h0RGF0YSB9IGZyb20gJy4uLy4uL2ZsaWdodC1kYXRhLWhlbHBlcnMnXG5pbXBvcnQgeyBjcmVhdGVFbXB0eUNhY2hlTm9kZSB9IGZyb20gJy4uL2FwcC1yb3V0ZXInXG5pbXBvcnQgeyBhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUgfSBmcm9tICcuL2FwcGx5LXJvdXRlci1zdGF0ZS1wYXRjaC10by10cmVlJ1xuaW1wb3J0IHsgY3JlYXRlSHJlZkZyb21VcmwgfSBmcm9tICcuL2NyZWF0ZS1ocmVmLWZyb20tdXJsJ1xuaW1wb3J0IHsgY3JlYXRlUm91dGVyQ2FjaGVLZXkgfSBmcm9tICcuL2NyZWF0ZS1yb3V0ZXItY2FjaGUta2V5J1xuaW1wb3J0IHsgZmlsbENhY2hlV2l0aE5ld1N1YlRyZWVEYXRhQnV0T25seUxvYWRpbmcgfSBmcm9tICcuL2ZpbGwtY2FjaGUtd2l0aC1uZXctc3VidHJlZS1kYXRhJ1xuaW1wb3J0IHsgaGFuZGxlTXV0YWJsZSB9IGZyb20gJy4vaGFuZGxlLW11dGFibGUnXG5pbXBvcnQgdHlwZSB7IE11dGFibGUsIFJlYWRvbmx5UmVkdWNlclN0YXRlIH0gZnJvbSAnLi9yb3V0ZXItcmVkdWNlci10eXBlcydcblxuLyoqXG4gKiBUaGlzIGlzIGEgc3RvcC1nYXAgdW50aWwgcGVyLXNlZ21lbnQgY2FjaGluZyBpcyBpbXBsZW1lbnRlZC4gSXQgbGV2ZXJhZ2VzIHRoZSBgYWxpYXNlZGAgZmxhZyB0aGF0IGlzIGFkZGVkXG4gKiB0byBwcmVmZXRjaCBlbnRyaWVzIHdoZW4gaXQncyBkZXRlcm1pbmVkIHRoYXQgdGhlIGxvYWRpbmcgc3RhdGUgZnJvbSB0aGF0IGVudHJ5IHNob3VsZCBiZSB1c2VkIGZvciB0aGlzIG5hdmlnYXRpb24uXG4gKiBUaGlzIGZ1bmN0aW9uIHRha2VzIHRoZSBhbGlhc2VkIGVudHJ5IGFuZCBvbmx5IGFwcGxpZXMgdGhlIGxvYWRpbmcgc3RhdGUgdG8gdGhlIHVwZGF0ZWQgY2FjaGUgbm9kZS5cbiAqIFdlIHNob3VsZCByZW1vdmUgdGhpcyBvbmNlIHBlci1zZWdtZW50IGZldGNoaW5nIGlzIGltcGxlbWVudGVkIGFzIGlkZWFsbHkgdGhlIHByZWZldGNoIGNhY2hlIHdpbGwgY29udGFpbiBhXG4gKiBtb3JlIGdyYW51bGFyIHNlZ21lbnQgbWFwIGFuZCBzbyB0aGUgcm91dGVyIHdpbGwgYmUgYWJsZSB0byBzaW1wbHkgcmUtdXNlIHRoZSBsb2FkaW5nIHNlZ21lbnQgZm9yIHRoZSBuZXcgbmF2aWdhdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhbmRsZUFsaWFzZWRQcmVmZXRjaEVudHJ5KFxuICBuYXZpZ2F0ZWRBdDogbnVtYmVyLFxuICBzdGF0ZTogUmVhZG9ubHlSZWR1Y2VyU3RhdGUsXG4gIGZsaWdodERhdGE6IHN0cmluZyB8IE5vcm1hbGl6ZWRGbGlnaHREYXRhW10sXG4gIHVybDogVVJMLFxuICBtdXRhYmxlOiBNdXRhYmxlXG4pIHtcbiAgbGV0IGN1cnJlbnRUcmVlID0gc3RhdGUudHJlZVxuICBsZXQgY3VycmVudENhY2hlID0gc3RhdGUuY2FjaGVcbiAgY29uc3QgaHJlZiA9IGNyZWF0ZUhyZWZGcm9tVXJsKHVybClcbiAgbGV0IGFwcGxpZWRcblxuICBpZiAodHlwZW9mIGZsaWdodERhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBmb3IgKGNvbnN0IG5vcm1hbGl6ZWRGbGlnaHREYXRhIG9mIGZsaWdodERhdGEpIHtcbiAgICAvLyBJZiB0aGUgc2VnbWVudCBkb2Vzbid0IGhhdmUgYSBsb2FkaW5nIGNvbXBvbmVudCwgd2UgZG9uJ3QgbmVlZCB0byBkbyBhbnl0aGluZy5cbiAgICBpZiAoIWhhc0xvYWRpbmdDb21wb25lbnRJblNlZWREYXRhKG5vcm1hbGl6ZWRGbGlnaHREYXRhLnNlZWREYXRhKSkge1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBsZXQgdHJlZVBhdGNoID0gbm9ybWFsaXplZEZsaWdodERhdGEudHJlZVxuICAgIC8vIFNlZ21lbnRzIGFyZSBrZXllZCBieSBzZWFyY2hQYXJhbXMgKGUuZy4gX19QQUdFX18/e1wiZm9vXCI6XCJiYXJcIn0pLiBXZSBtaWdodCByZXR1cm4gYSBsZXNzIHNwZWNpZmljLCBwYXJhbS1sZXNzIGVudHJ5LFxuICAgIC8vIHNvIHdlIGVuc3VyZSB0aGF0IHRoZSBmaW5hbCB0cmVlIGNvbnRhaW5zIHRoZSBjb3JyZWN0IHNlYXJjaFBhcmFtcyAocmVmbGVjdGVkIGluIHRoZSBVUkwpIGFyZSBwcm92aWRlZCBpbiB0aGUgdXBkYXRlZCBGbGlnaHRSb3V0ZXJTdGF0ZSB0cmVlLlxuICAgIC8vIFdlIG9ubHkgZG8gdGhpcyBvbiB0aGUgZmlyc3QgcmVhZCwgYXMgb3RoZXJ3aXNlIHdlJ2QgYmUgb3ZlcndyaXRpbmcgdGhlIHNlYXJjaFBhcmFtcyB0aGF0IG1heSBoYXZlIGFscmVhZHkgYmVlbiBzZXRcbiAgICB0cmVlUGF0Y2ggPSBhZGRTZWFyY2hQYXJhbXNUb1BhZ2VTZWdtZW50cyhcbiAgICAgIHRyZWVQYXRjaCxcbiAgICAgIE9iamVjdC5mcm9tRW50cmllcyh1cmwuc2VhcmNoUGFyYW1zKVxuICAgIClcblxuICAgIGNvbnN0IHsgc2VlZERhdGEsIGlzUm9vdFJlbmRlciwgcGF0aFRvU2VnbWVudCB9ID0gbm9ybWFsaXplZEZsaWdodERhdGFcbiAgICAvLyBUT0RPLUFQUDogcmVtb3ZlICcnXG4gICAgY29uc3QgZmxpZ2h0U2VnbWVudFBhdGhXaXRoTGVhZGluZ0VtcHR5ID0gWycnLCAuLi5wYXRoVG9TZWdtZW50XVxuXG4gICAgLy8gU2VnbWVudHMgYXJlIGtleWVkIGJ5IHNlYXJjaFBhcmFtcyAoZS5nLiBfX1BBR0VfXz97XCJmb29cIjpcImJhclwifSkuIFdlIG1pZ2h0IHJldHVybiBhIGxlc3Mgc3BlY2lmaWMsIHBhcmFtLWxlc3MgZW50cnksXG4gICAgLy8gc28gd2UgZW5zdXJlIHRoYXQgdGhlIGZpbmFsIHRyZWUgY29udGFpbnMgdGhlIGNvcnJlY3Qgc2VhcmNoUGFyYW1zIChyZWZsZWN0ZWQgaW4gdGhlIFVSTCkgYXJlIHByb3ZpZGVkIGluIHRoZSB1cGRhdGVkIEZsaWdodFJvdXRlclN0YXRlIHRyZWUuXG4gICAgLy8gV2Ugb25seSBkbyB0aGlzIG9uIHRoZSBmaXJzdCByZWFkLCBhcyBvdGhlcndpc2Ugd2UnZCBiZSBvdmVyd3JpdGluZyB0aGUgc2VhcmNoUGFyYW1zIHRoYXQgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIHNldFxuICAgIHRyZWVQYXRjaCA9IGFkZFNlYXJjaFBhcmFtc1RvUGFnZVNlZ21lbnRzKFxuICAgICAgdHJlZVBhdGNoLFxuICAgICAgT2JqZWN0LmZyb21FbnRyaWVzKHVybC5zZWFyY2hQYXJhbXMpXG4gICAgKVxuXG4gICAgbGV0IG5ld1RyZWUgPSBhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUoXG4gICAgICBmbGlnaHRTZWdtZW50UGF0aFdpdGhMZWFkaW5nRW1wdHksXG4gICAgICBjdXJyZW50VHJlZSxcbiAgICAgIHRyZWVQYXRjaCxcbiAgICAgIGhyZWZcbiAgICApXG5cbiAgICBjb25zdCBuZXdDYWNoZSA9IGNyZWF0ZUVtcHR5Q2FjaGVOb2RlKClcblxuICAgIC8vIFRoZSBwcmVmZXRjaCBjYWNoZSBlbnRyeSB3YXMgYWxpYXNlZCAtLSB0aGlzIHNpZ25hbHMgdGhhdCB3ZSBvbmx5IGZpbGwgaW4gdGhlIGNhY2hlIHdpdGggdGhlXG4gICAgLy8gbG9hZGluZyBzdGF0ZSBhbmQgbm90IHRoZSBhY3R1YWwgcGFyYWxsZWwgcm91dGUgc2VlZCBkYXRhLlxuICAgIGlmIChpc1Jvb3RSZW5kZXIgJiYgc2VlZERhdGEpIHtcbiAgICAgIC8vIEZpbGwgaW4gdGhlIGNhY2hlIHdpdGggdGhlIG5ldyBsb2FkaW5nIC8gcnNjIGRhdGFcbiAgICAgIGNvbnN0IHJzYyA9IHNlZWREYXRhWzFdXG4gICAgICBjb25zdCBsb2FkaW5nID0gc2VlZERhdGFbM11cbiAgICAgIG5ld0NhY2hlLmxvYWRpbmcgPSBsb2FkaW5nXG4gICAgICBuZXdDYWNoZS5yc2MgPSByc2NcblxuICAgICAgLy8gQ29uc3RydWN0IGEgbmV3IHRyZWUgYW5kIGFwcGx5IHRoZSBhbGlhc2VkIGxvYWRpbmcgc3RhdGUgZm9yIGVhY2ggcGFyYWxsZWwgcm91dGVcbiAgICAgIGZpbGxOZXdUcmVlV2l0aE9ubHlMb2FkaW5nU2VnbWVudHMoXG4gICAgICAgIG5hdmlnYXRlZEF0LFxuICAgICAgICBuZXdDYWNoZSxcbiAgICAgICAgY3VycmVudENhY2hlLFxuICAgICAgICB0cmVlUGF0Y2gsXG4gICAgICAgIHNlZWREYXRhXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENvcHkgcnNjIGZvciB0aGUgcm9vdCBub2RlIG9mIHRoZSBjYWNoZS5cbiAgICAgIG5ld0NhY2hlLnJzYyA9IGN1cnJlbnRDYWNoZS5yc2NcbiAgICAgIG5ld0NhY2hlLnByZWZldGNoUnNjID0gY3VycmVudENhY2hlLnByZWZldGNoUnNjXG4gICAgICBuZXdDYWNoZS5sb2FkaW5nID0gY3VycmVudENhY2hlLmxvYWRpbmdcbiAgICAgIG5ld0NhY2hlLnBhcmFsbGVsUm91dGVzID0gbmV3IE1hcChjdXJyZW50Q2FjaGUucGFyYWxsZWxSb3V0ZXMpXG5cbiAgICAgIC8vIGNvcHkgdGhlIGxvYWRpbmcgc3RhdGUgb25seSBpbnRvIHRoZSBsZWFmIG5vZGUgKHRoZSBwYXJ0IHRoYXQgY2hhbmdlZClcbiAgICAgIGZpbGxDYWNoZVdpdGhOZXdTdWJUcmVlRGF0YUJ1dE9ubHlMb2FkaW5nKFxuICAgICAgICBuYXZpZ2F0ZWRBdCxcbiAgICAgICAgbmV3Q2FjaGUsXG4gICAgICAgIGN1cnJlbnRDYWNoZSxcbiAgICAgICAgbm9ybWFsaXplZEZsaWdodERhdGFcbiAgICAgIClcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGFuIHVwZGF0ZWQgdHJlZSwgdGhlcmUncyBubyByZWFzb24gdG8gdXBkYXRlIHRoZSBjYWNoZSwgYXMgdGhlIHRyZWVcbiAgICAvLyBkaWN0YXRlcyB3aGF0IGNhY2hlIG5vZGVzIHRvIHJlbmRlci5cbiAgICBpZiAobmV3VHJlZSkge1xuICAgICAgY3VycmVudFRyZWUgPSBuZXdUcmVlXG4gICAgICBjdXJyZW50Q2FjaGUgPSBuZXdDYWNoZVxuICAgICAgYXBwbGllZCA9IHRydWVcbiAgICB9XG4gIH1cblxuICBpZiAoIWFwcGxpZWQpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIG11dGFibGUucGF0Y2hlZFRyZWUgPSBjdXJyZW50VHJlZVxuICBtdXRhYmxlLmNhY2hlID0gY3VycmVudENhY2hlXG4gIG11dGFibGUuY2Fub25pY2FsVXJsID0gaHJlZlxuICBtdXRhYmxlLmhhc2hGcmFnbWVudCA9IHVybC5oYXNoXG5cbiAgcmV0dXJuIGhhbmRsZU11dGFibGUoc3RhdGUsIG11dGFibGUpXG59XG5cbmZ1bmN0aW9uIGhhc0xvYWRpbmdDb21wb25lbnRJblNlZWREYXRhKHNlZWREYXRhOiBDYWNoZU5vZGVTZWVkRGF0YSB8IG51bGwpIHtcbiAgaWYgKCFzZWVkRGF0YSkgcmV0dXJuIGZhbHNlXG5cbiAgY29uc3QgcGFyYWxsZWxSb3V0ZXMgPSBzZWVkRGF0YVsyXVxuICBjb25zdCBsb2FkaW5nID0gc2VlZERhdGFbM11cblxuICBpZiAobG9hZGluZykge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbGxlbFJvdXRlcykge1xuICAgIGlmIChoYXNMb2FkaW5nQ29tcG9uZW50SW5TZWVkRGF0YShwYXJhbGxlbFJvdXRlc1trZXldKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gZmlsbE5ld1RyZWVXaXRoT25seUxvYWRpbmdTZWdtZW50cyhcbiAgbmF2aWdhdGVkQXQ6IG51bWJlcixcbiAgbmV3Q2FjaGU6IENhY2hlTm9kZSxcbiAgZXhpc3RpbmdDYWNoZTogQ2FjaGVOb2RlLFxuICByb3V0ZXJTdGF0ZTogRmxpZ2h0Um91dGVyU3RhdGUsXG4gIGNhY2hlTm9kZVNlZWREYXRhOiBDYWNoZU5vZGVTZWVkRGF0YSB8IG51bGxcbikge1xuICBjb25zdCBpc0xhc3RTZWdtZW50ID0gT2JqZWN0LmtleXMocm91dGVyU3RhdGVbMV0pLmxlbmd0aCA9PT0gMFxuICBpZiAoaXNMYXN0U2VnbWVudCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgZm9yIChjb25zdCBrZXkgaW4gcm91dGVyU3RhdGVbMV0pIHtcbiAgICBjb25zdCBwYXJhbGxlbFJvdXRlU3RhdGUgPSByb3V0ZXJTdGF0ZVsxXVtrZXldXG4gICAgY29uc3Qgc2VnbWVudEZvclBhcmFsbGVsUm91dGUgPSBwYXJhbGxlbFJvdXRlU3RhdGVbMF1cbiAgICBjb25zdCBjYWNoZUtleSA9IGNyZWF0ZVJvdXRlckNhY2hlS2V5KHNlZ21lbnRGb3JQYXJhbGxlbFJvdXRlKVxuXG4gICAgY29uc3QgcGFyYWxsZWxTZWVkRGF0YSA9XG4gICAgICBjYWNoZU5vZGVTZWVkRGF0YSAhPT0gbnVsbCAmJiBjYWNoZU5vZGVTZWVkRGF0YVsyXVtrZXldICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBjYWNoZU5vZGVTZWVkRGF0YVsyXVtrZXldXG4gICAgICAgIDogbnVsbFxuXG4gICAgbGV0IG5ld0NhY2hlTm9kZTogQ2FjaGVOb2RlXG4gICAgaWYgKHBhcmFsbGVsU2VlZERhdGEgIT09IG51bGwpIHtcbiAgICAgIC8vIE5ldyBkYXRhIHdhcyBzZW50IGZyb20gdGhlIHNlcnZlci5cbiAgICAgIGNvbnN0IHJzYyA9IHBhcmFsbGVsU2VlZERhdGFbMV1cbiAgICAgIGNvbnN0IGxvYWRpbmcgPSBwYXJhbGxlbFNlZWREYXRhWzNdXG4gICAgICBuZXdDYWNoZU5vZGUgPSB7XG4gICAgICAgIGxhenlEYXRhOiBudWxsLFxuICAgICAgICAvLyBjb3B5IHRoZSBsYXlvdXQgYnV0IG51bGwgdGhlIHBhZ2Ugc2VnbWVudCBhcyB0aGF0J3Mgbm90IG1lYW50IHRvIGJlIHVzZWRcbiAgICAgICAgcnNjOiBzZWdtZW50Rm9yUGFyYWxsZWxSb3V0ZS5pbmNsdWRlcyhQQUdFX1NFR01FTlRfS0VZKSA/IG51bGwgOiByc2MsXG4gICAgICAgIHByZWZldGNoUnNjOiBudWxsLFxuICAgICAgICBoZWFkOiBudWxsLFxuICAgICAgICBwcmVmZXRjaEhlYWQ6IG51bGwsXG4gICAgICAgIHBhcmFsbGVsUm91dGVzOiBuZXcgTWFwKCksXG4gICAgICAgIGxvYWRpbmcsXG4gICAgICAgIG5hdmlnYXRlZEF0LFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBObyBkYXRhIGF2YWlsYWJsZSBmb3IgdGhpcyBub2RlLiBUaGlzIHdpbGwgdHJpZ2dlciBhIGxhenkgZmV0Y2hcbiAgICAgIC8vIGR1cmluZyByZW5kZXIuXG4gICAgICBuZXdDYWNoZU5vZGUgPSB7XG4gICAgICAgIGxhenlEYXRhOiBudWxsLFxuICAgICAgICByc2M6IG51bGwsXG4gICAgICAgIHByZWZldGNoUnNjOiBudWxsLFxuICAgICAgICBoZWFkOiBudWxsLFxuICAgICAgICBwcmVmZXRjaEhlYWQ6IG51bGwsXG4gICAgICAgIHBhcmFsbGVsUm91dGVzOiBuZXcgTWFwKCksXG4gICAgICAgIGxvYWRpbmc6IG51bGwsXG4gICAgICAgIG5hdmlnYXRlZEF0OiAtMSxcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBleGlzdGluZ1BhcmFsbGVsUm91dGVzID0gbmV3Q2FjaGUucGFyYWxsZWxSb3V0ZXMuZ2V0KGtleSlcbiAgICBpZiAoZXhpc3RpbmdQYXJhbGxlbFJvdXRlcykge1xuICAgICAgZXhpc3RpbmdQYXJhbGxlbFJvdXRlcy5zZXQoY2FjaGVLZXksIG5ld0NhY2hlTm9kZSlcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3Q2FjaGUucGFyYWxsZWxSb3V0ZXMuc2V0KGtleSwgbmV3IE1hcChbW2NhY2hlS2V5LCBuZXdDYWNoZU5vZGVdXSkpXG4gICAgfVxuXG4gICAgZmlsbE5ld1RyZWVXaXRoT25seUxvYWRpbmdTZWdtZW50cyhcbiAgICAgIG5hdmlnYXRlZEF0LFxuICAgICAgbmV3Q2FjaGVOb2RlLFxuICAgICAgZXhpc3RpbmdDYWNoZSxcbiAgICAgIHBhcmFsbGVsUm91dGVTdGF0ZSxcbiAgICAgIHBhcmFsbGVsU2VlZERhdGFcbiAgICApXG4gIH1cbn1cblxuLyoqXG4gKiBBZGQgc2VhcmNoIHBhcmFtcyB0byB0aGUgcGFnZSBzZWdtZW50cyBpbiB0aGUgZmxpZ2h0IHJvdXRlciBzdGF0ZVxuICogUGFnZSBzZWdtZW50cyB0aGF0IGFyZSBhc3NvY2lhdGVkIHdpdGggc2VhcmNoIHBhcmFtcyBoYXZlIGEgcGFnZSBzZWdtZW50IGtleVxuICogZm9sbG93ZWQgYnkgYSBxdWVyeSBzdHJpbmcuIFRoaXMgZnVuY3Rpb24gd2lsbCBhZGQgdGhvc2UgcGFyYW1zIHRvIHRoZSBwYWdlIHNlZ21lbnQuXG4gKiBUaGlzIGlzIHVzZWZ1bCBpZiB3ZSByZXR1cm4gYW4gYWxpYXNlZCBwcmVmZXRjaCBlbnRyeSAoaWUsIHdvbid0IGhhdmUgc2VhcmNoIHBhcmFtcylcbiAqIGJ1dCB0aGUgY2Fub25pY2FsIHJvdXRlciBVUkwgaGFzIHNlYXJjaCBwYXJhbXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRTZWFyY2hQYXJhbXNUb1BhZ2VTZWdtZW50cyhcbiAgZmxpZ2h0Um91dGVyU3RhdGU6IEZsaWdodFJvdXRlclN0YXRlLFxuICBzZWFyY2hQYXJhbXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IHN0cmluZ1tdIHwgdW5kZWZpbmVkPlxuKTogRmxpZ2h0Um91dGVyU3RhdGUge1xuICBjb25zdCBbc2VnbWVudCwgcGFyYWxsZWxSb3V0ZXMsIC4uLnJlc3RdID0gZmxpZ2h0Um91dGVyU3RhdGVcblxuICAvLyBJZiBpdCdzIGEgcGFnZSBzZWdtZW50LCBtb2RpZnkgdGhlIHNlZ21lbnQgYnkgYWRkaW5nIHNlYXJjaCBwYXJhbXNcbiAgaWYgKHNlZ21lbnQuaW5jbHVkZXMoUEFHRV9TRUdNRU5UX0tFWSkpIHtcbiAgICBjb25zdCBuZXdTZWdtZW50ID0gYWRkU2VhcmNoUGFyYW1zSWZQYWdlU2VnbWVudChzZWdtZW50LCBzZWFyY2hQYXJhbXMpXG4gICAgcmV0dXJuIFtuZXdTZWdtZW50LCBwYXJhbGxlbFJvdXRlcywgLi4ucmVzdF1cbiAgfVxuXG4gIC8vIE90aGVyd2lzZSwgcmVjdXJzZSB0aHJvdWdoIHRoZSBwYXJhbGxlbCByb3V0ZXMgYW5kIHJldHVybiBhIG5ldyB0cmVlXG4gIGNvbnN0IHVwZGF0ZWRQYXJhbGxlbFJvdXRlczogeyBba2V5OiBzdHJpbmddOiBGbGlnaHRSb3V0ZXJTdGF0ZSB9ID0ge31cblxuICBmb3IgKGNvbnN0IFtrZXksIHBhcmFsbGVsUm91dGVdIG9mIE9iamVjdC5lbnRyaWVzKHBhcmFsbGVsUm91dGVzKSkge1xuICAgIHVwZGF0ZWRQYXJhbGxlbFJvdXRlc1trZXldID0gYWRkU2VhcmNoUGFyYW1zVG9QYWdlU2VnbWVudHMoXG4gICAgICBwYXJhbGxlbFJvdXRlLFxuICAgICAgc2VhcmNoUGFyYW1zXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIFtzZWdtZW50LCB1cGRhdGVkUGFyYWxsZWxSb3V0ZXMsIC4uLnJlc3RdXG59XG4iXSwibmFtZXMiOlsiYWRkU2VhcmNoUGFyYW1zVG9QYWdlU2VnbWVudHMiLCJoYW5kbGVBbGlhc2VkUHJlZmV0Y2hFbnRyeSIsIm5hdmlnYXRlZEF0Iiwic3RhdGUiLCJmbGlnaHREYXRhIiwidXJsIiwibXV0YWJsZSIsImN1cnJlbnRUcmVlIiwidHJlZSIsImN1cnJlbnRDYWNoZSIsImNhY2hlIiwiaHJlZiIsImNyZWF0ZUhyZWZGcm9tVXJsIiwiYXBwbGllZCIsIm5vcm1hbGl6ZWRGbGlnaHREYXRhIiwiaGFzTG9hZGluZ0NvbXBvbmVudEluU2VlZERhdGEiLCJzZWVkRGF0YSIsInRyZWVQYXRjaCIsIk9iamVjdCIsImZyb21FbnRyaWVzIiwic2VhcmNoUGFyYW1zIiwiaXNSb290UmVuZGVyIiwicGF0aFRvU2VnbWVudCIsImZsaWdodFNlZ21lbnRQYXRoV2l0aExlYWRpbmdFbXB0eSIsIm5ld1RyZWUiLCJhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUiLCJuZXdDYWNoZSIsImNyZWF0ZUVtcHR5Q2FjaGVOb2RlIiwicnNjIiwibG9hZGluZyIsImZpbGxOZXdUcmVlV2l0aE9ubHlMb2FkaW5nU2VnbWVudHMiLCJwcmVmZXRjaFJzYyIsInBhcmFsbGVsUm91dGVzIiwiTWFwIiwiZmlsbENhY2hlV2l0aE5ld1N1YlRyZWVEYXRhQnV0T25seUxvYWRpbmciLCJwYXRjaGVkVHJlZSIsImNhbm9uaWNhbFVybCIsImhhc2hGcmFnbWVudCIsImhhc2giLCJoYW5kbGVNdXRhYmxlIiwia2V5IiwiZXhpc3RpbmdDYWNoZSIsInJvdXRlclN0YXRlIiwiY2FjaGVOb2RlU2VlZERhdGEiLCJpc0xhc3RTZWdtZW50Iiwia2V5cyIsImxlbmd0aCIsInBhcmFsbGVsUm91dGVTdGF0ZSIsInNlZ21lbnRGb3JQYXJhbGxlbFJvdXRlIiwiY2FjaGVLZXkiLCJjcmVhdGVSb3V0ZXJDYWNoZUtleSIsInBhcmFsbGVsU2VlZERhdGEiLCJ1bmRlZmluZWQiLCJuZXdDYWNoZU5vZGUiLCJsYXp5RGF0YSIsImluY2x1ZGVzIiwiUEFHRV9TRUdNRU5UX0tFWSIsImhlYWQiLCJwcmVmZXRjaEhlYWQiLCJleGlzdGluZ1BhcmFsbGVsUm91dGVzIiwiZ2V0Iiwic2V0IiwiZmxpZ2h0Um91dGVyU3RhdGUiLCJzZWdtZW50IiwicmVzdCIsIm5ld1NlZ21lbnQiLCJhZGRTZWFyY2hQYXJhbXNJZlBhZ2VTZWdtZW50IiwidXBkYXRlZFBhcmFsbGVsUm91dGVzIiwicGFyYWxsZWxSb3V0ZSIsImVudHJpZXMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0lBbU9nQkEsNkJBQTZCLEVBQUE7ZUFBN0JBOztJQTFNQUMsMEJBQTBCLEVBQUE7ZUFBMUJBOzs7eUJBakJUOzJCQUU4Qjs2Q0FDTzttQ0FDVjtzQ0FDRzs2Q0FDcUI7K0JBQzVCO0FBVXZCLFNBQVNBLDJCQUNkQyxXQUFtQixFQUNuQkMsS0FBMkIsRUFDM0JDLFVBQTJDLEVBQzNDQyxHQUFRLEVBQ1JDLE9BQWdCO0lBRWhCLElBQUlDLGNBQWNKLE1BQU1LLElBQUk7SUFDNUIsSUFBSUMsZUFBZU4sTUFBTU8sS0FBSztJQUM5QixNQUFNQyxPQUFPQyxDQUFBQSxHQUFBQSxtQkFBQUEsaUJBQWlCLEVBQUNQO0lBQy9CLElBQUlRO0lBRUosSUFBSSxPQUFPVCxlQUFlLFVBQVU7UUFDbEMsT0FBTztJQUNUO0lBRUEsS0FBSyxNQUFNVSx3QkFBd0JWLFdBQVk7UUFDN0MsaUZBQWlGO1FBQ2pGLElBQUksQ0FBQ1csOEJBQThCRCxxQkFBcUJFLFFBQVEsR0FBRztZQUNqRTtRQUNGO1FBRUEsSUFBSUMsWUFBWUgscUJBQXFCTixJQUFJO1FBQ3pDLHVIQUF1SDtRQUN2SCxnSkFBZ0o7UUFDaEosc0hBQXNIO1FBQ3RIUyxZQUFZakIsOEJBQ1ZpQixXQUNBQyxPQUFPQyxXQUFXLENBQUNkLElBQUllLFlBQVk7UUFHckMsTUFBTSxFQUFFSixRQUFRLEVBQUVLLFlBQVksRUFBRUMsYUFBYSxFQUFFLEdBQUdSO1FBQ2xELHNCQUFzQjtRQUN0QixNQUFNUyxvQ0FBb0M7WUFBQztlQUFPRDtTQUFjO1FBRWhFLHVIQUF1SDtRQUN2SCxnSkFBZ0o7UUFDaEosc0hBQXNIO1FBQ3RITCxZQUFZakIsOEJBQ1ZpQixXQUNBQyxPQUFPQyxXQUFXLENBQUNkLElBQUllLFlBQVk7UUFHckMsSUFBSUksVUFBVUMsQ0FBQUEsR0FBQUEsNkJBQUFBLDJC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b0UsZUFDQWhEO0lBRUo7SUFFQSxPQUFPO1FBQUMyQztRQUFTSTtXQUEwQkg7S0FBSztBQUNsRCIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxMTAwOCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvY29tcG9uZW50cy9zZWdtZW50LWNhY2hlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRW50cnkgcG9pbnQgdG8gdGhlIFNlZ21lbnQgQ2FjaGUgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQWxsIGNvZGUgcmVsYXRlZCB0byB0aGUgU2VnbWVudCBDYWNoZSBsaXZlcyBgc2VnbWVudC1jYWNoZS1pbXBsYCBkaXJlY3RvcnkuXG4gKiBDYWxsZXJzIGFjY2VzcyBpdCB0aHJvdWdoIHRoaXMgaW5kaXJlY3Rpb24uXG4gKlxuICogVGhpcyBpcyB0byBlbnN1cmUgdGhlIGNvZGUgaXMgZGVhZCBjb2RlIGVsaW1pbmF0ZWQgZnJvbSB0aGUgYnVuZGxlIGlmIHRoZVxuICogZmxhZyBpcyBkaXNhYmxlZC5cbiAqXG4gKiBUT0RPOiBUaGlzIGlzIHN1cGVyIHRlZGlvdXMuIFNpbmNlIGV4cGVyaW1lbnRhbCBmbGFncyBhcmUgYW4gZXNzZW50aWFsIHBhcnRcbiAqIG9mIG91ciB3b3JrZmxvdywgd2Ugc2hvdWxkIGVzdGFibGlzaCBhIGJldHRlciBwYXR0ZXJuIGZvciBkZWFkIGNvZGVcbiAqIGVsaW1pbmF0aW9uLiBJZGVhbGx5IGl0IHdvdWxkIGJlIGRvbmUgYXQgdGhlIGJ1bmRsZXIgbGV2ZWwsIGxpa2UgaG93IFJlYWN0J3NcbiAqIGJ1aWxkIHByb2Nlc3Mgd29ya3MuIEluIHRoZSBSZWFjdCByZXBvLCB5b3UgZG9uJ3QgZXZlbiBuZWVkIHRvIGFkZCBhbnkgZXh0cmFcbiAqIGNvbmZpZ3VyYXRpb24gcGVyIGV4cGVyaW1lbnQg4oCUIGlmIHRoZSBjb2RlIGlzIG5vdCByZWFjaGFibGUsIGl0IGdldHMgc3RyaXBwZWRcbiAqIGZyb20gdGhlIGJ1aWxkIGF1dG9tYXRpY2FsbHkgYnkgUm9sbHVwLiBPciwgc2hvcnRlciB0ZXJtLCB3ZSBjb3VsZCBzdHViIG91dFxuICogZXhwZXJpbWVudGFsIG1vZHVsZXMgYXQgYnVpbGQgdGltZSBieSB1cGRhdGluZyB0aGUgYnVpbGQgY29uZmlnLCBpLmUuIGEgbW9yZVxuICogYXV0b21hdGVkIHZlcnNpb24gb2Ygd2hhdCBJJ20gZG9pbmcgbWFudWFsbHkgaW4gdGhpcyBmaWxlLlxuICovXG5cbmV4cG9ydCB0eXBlIHsgTmF2aWdhdGlvblJlc3VsdCB9IGZyb20gJy4vc2VnbWVudC1jYWNoZS1pbXBsL25hdmlnYXRpb24nXG5leHBvcnQgdHlwZSB7IFByZWZldGNoVGFzayB9IGZyb20gJy4vc2VnbWVudC1jYWNoZS1pbXBsL3NjaGVkdWxlcidcblxuY29uc3Qgbm90RW5hYmxlZDogYW55ID0gKCkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ1NlZ21lbnQgQ2FjaGUgZXhwZXJpbWVudCBpcyBub3QgZW5hYmxlZC4gVGhpcyBpcyBhIGJ1ZyBpbiBOZXh0LmpzLidcbiAgKVxufVxuXG5leHBvcnQgY29uc3QgcHJlZmV0Y2g6IHR5cGVvZiBpbXBvcnQoJy4vc2VnbWVudC1jYWNoZS1pbXBsL3ByZWZldGNoJykucHJlZmV0Y2ggPVxuICBwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1NFR01FTlRfQ0FDSEVcbiAgICA/IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgcmVxdWlyZSgnLi9zZWdtZW50LWNhY2hlLWltcGwvcHJlZmV0Y2gnKSBhcyB0eXBlb2YgaW1wb3J0KCcuL3NlZ21lbnQtY2FjaGUtaW1wbC9wcmVmZXRjaCcpXG4gICAgICAgICkucHJlZmV0Y2goLi4uYXJncylcbiAgICAgIH1cbiAgICA6IG5vdEVuYWJsZWRcblxuZXhwb3J0IGNvbnN0IG5hdmlnYXRlOiB0eXBlb2YgaW1wb3J0KCcuL3NlZ21lbnQtY2FjaGUtaW1wbC9uYXZpZ2F0aW9uJykubmF2aWdhdGUgPVxuICBwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1NFR01FTlRfQ0FDSEVcbiAgICA/IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgcmVxdWlyZSgnLi9zZWdtZW50LWNhY2hlLWltcGwvbmF2aWdhdGlvbicpIGFzIHR5cGVvZiBpbXBvcnQoJy4vc2VnbWVudC1jYWNoZS1pbXBsL25hdmlnYXRpb24nKVxuICAgICAgICApLm5hdmlnYXRlKC4uLmFyZ3MpXG4gICAgICB9XG4gICAgOiBub3RFbmFibGVkXG5cbmV4cG9ydCBjb25zdCByZXZhbGlkYXRlRW50aXJlQ2FjaGU6IHR5cGVvZiBpbXBvcnQoJy4vc2VnbWVudC1jYWNoZS1pbXBsL2NhY2hlJykucmV2YWxpZGF0ZUVudGlyZUNhY2hlID1cbiAgcHJvY2Vzcy5lbnYuX19ORVhUX0NMSUVOVF9TRUdNRU5UX0NBQ0hFXG4gICAgPyBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIHJlcXVpcmUoJy4vc2VnbWVudC1jYWNoZS1pbXBsL2NhY2hlJykgYXMgdHlwZW9mIGltcG9ydCgnLi9zZWdtZW50LWNhY2hlLWltcGwvY2FjaGUnKVxuICAgICAgICApLnJldmFsaWRhdGVFbnRpcmVDYWNoZSguLi5hcmdzKVxuICAgICAgfVxuICAgIDogbm90RW5hYmxlZFxuXG5leHBvcnQgY29uc3QgZ2V0Q3VycmVudENhY2hlVmVyc2lvbjogdHlwZW9mIGltcG9ydCgnLi9zZWdtZW50LWNhY2hlLWltcGwvY2FjaGUnKS5nZXRDdXJyZW50Q2FjaGVWZXJzaW9uID1cbiAgcHJvY2Vzcy5lbnYuX19ORVhUX0NMSUVOVF9TRUdNRU5UX0NBQ0hFXG4gICAgPyBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIHJlcXVpcmUoJy4vc2VnbWVudC1jYWNoZS1pbXBsL2NhY2hlJykgYXMgdHlwZW9mIGltcG9ydCgnLi9zZWdtZW50LWNhY2hlLWltcGwvY2FjaGUnKVxuICAgICAgICApLmdldEN1cnJlbnRDYWNoZVZlcnNpb24oLi4uYXJncylcbiAgICAgIH1cbiAgICA6IG5vdEVuYWJsZWRcblxuZXhwb3J0IGNvbnN0IHNjaGVkdWxlUHJlZmV0Y2hUYXNrOiB0eXBlb2YgaW1wb3J0KCcuL3NlZ21lbnQtY2FjaGUtaW1wbC9zY2hlZHVsZXInKS5zY2hlZHVsZVByZWZldGNoVGFzayA9XG4gIHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfU0VHTUVOVF9DQUNIRVxuICAgID8gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICByZXF1aXJlKCcuL3NlZ21lbnQtY2FjaGUtaW1wbC9zY2hlZHVsZXInKSBhcyB0eXBlb2YgaW1wb3J0KCcuL3NlZ21lbnQtY2FjaGUtaW1wbC9zY2hlZHVsZXInKVxuICAgICAgICApLnNjaGVkdWxlUHJlZmV0Y2hUYXNrKC4uLmFyZ3MpXG4gICAgICB9XG4gICAgOiBub3RFbmFibGVkXG5cbmV4cG9ydCBjb25zdCBjYW5jZWxQcmVmZXRjaFRhc2s6IHR5cGVvZiBpbXBvcnQoJy4vc2VnbWVudC1jYWNoZS1pbXBsL3NjaGVkdWxlcicpLmNhbmNlbFByZWZldGNoVGFzayA9XG4gIHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfU0VHTUVOVF9DQUNIRVxuICAgID8gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICByZXF1aXJlKCcuL3NlZ21lbnQtY2FjaGUtaW1wbC9zY2hlZHVsZXInKSBhcyB0eXBlb2YgaW1wb3J0KCcuL3NlZ21lbnQtY2FjaGUtaW1wbC9zY2hlZHVsZXInKVxuICAgICAgICApLmNhbmNlbFByZWZldGNoVGFzayguLi5hcmdzKVxuICAgICAgfVxuICAgIDogbm90RW5hYmxlZFxuXG5leHBvcnQgY29uc3QgcmVzY2hlZHVsZVByZWZldGNoVGFzazogdHlwZW9mIGltcG9ydCgnLi9zZWdtZW50LWNhY2hlLWltcGwvc2NoZWR1bGVyJykucmVzY2hlZHVsZVByZWZldGNoVGFzayA9XG4gIHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfU0VHTUVOVF9DQUNIRVxuICAgID8gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICByZXF1aXJlKCcuL3NlZ21lbnQtY2FjaGUtaW1wbC9zY2hlZHVsZXInKSBhcyB0eXBlb2YgaW1wb3J0KCcuL3NlZ21lbnQtY2FjaGUtaW1wbC9zY2hlZHVsZXInKVxuICAgICAgICApLnJlc2NoZWR1bGVQcmVmZXRjaFRhc2soLi4uYXJncylcbiAgICAgIH1cbiAgICA6IG5vdEVuYWJsZWRcblxuZXhwb3J0IGNvbnN0IGlzUHJlZmV0Y2hUYXNrRGlydHk6IHR5cGVvZiBpbXBvcnQoJy4vc2VnbWVudC1jYWNoZS1pbXBsL3NjaGVkdWxlcicpLmlzUHJlZmV0Y2hUYXNrRGlydHkgPVxuICBwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1NFR01FTlRfQ0FDSEVcbiAgICA/IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgcmVxdWlyZSgnLi9zZWdtZW50LWNhY2hlLWltcGwvc2NoZWR1bGVyJykgYXMgdHlwZW9mIGltcG9ydCgnLi9zZWdtZW50LWNhY2hlLWltcGwvc2NoZWR1bGVyJylcbiAgICAgICAgKS5pc1ByZWZldGNoVGFza0RpcnR5KC4uLmFyZ3MpXG4gICAgICB9XG4gICAgOiBub3RFbmFibGVkXG5cbmV4cG9ydCBjb25zdCBjcmVhdGVDYWNoZUtleTogdHlwZW9mIGltcG9ydCgnLi9zZWdtZW50LWNhY2hlLWltcGwvY2FjaGUta2V5JykuY3JlYXRlQ2FjaGVLZXkgPVxuICBwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1NFR01FTlRfQ0FDSEVcbiAgICA/IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgcmVxdWlyZSgnLi9zZWdtZW50LWNhY2hlLWltcGwvY2FjaGUta2V5JykgYXMgdHlwZW9mIGltcG9ydCgnLi9zZWdtZW50LWNhY2hlLWltcGwvY2FjaGUta2V5JylcbiAgICAgICAgKS5jcmVhdGVDYWNoZUtleSguLi5hcmdzKVxuICAgICAgfVxuICAgIDogbm90RW5hYmxlZFxuXG4vKipcbiAqIEJlbG93IGFyZSBwdWJsaWMgY29uc3RhbnRzLiBUaGV5J3JlIHNtYWxsIGVub3VnaCB0aGF0IHdlIGRvbid0IG5lZWQgdG9cbiAqIERDRSB0aGVtLlxuICovXG5cbmV4cG9ydCBjb25zdCBlbnVtIE5hdmlnYXRpb25SZXN1bHRUYWcge1xuICBNUEEsXG4gIFN1Y2Nlc3MsXG4gIE5vT3AsXG4gIEFzeW5jLFxufVxuXG4vKipcbiAqIFRoZSBwcmlvcml0eSBvZiB0aGUgcHJlZmV0Y2ggdGFzay4gSGlnaGVyIG51bWJlcnMgYXJlIGhpZ2hlciBwcmlvcml0eS5cbiAqL1xuZXhwb3J0IGNvbnN0IGVudW0gUHJlZmV0Y2hQcmlvcml0eSB7XG4gIC8qKlxuICAgKiBBc3NpZ25lZCB0byB0aGUgbW9zdCByZWNlbnRseSBob3ZlcmVkL3RvdWNoZWQgbGluay4gU3BlY2lhbCBuZXR3b3JrXG4gICAqIGJhbmR3aWR0aCBpcyByZXNlcnZlZCBmb3IgdGhpcyB0YXNrIG9ubHkuIFRoZXJlJ3Mgb25seSBldmVyIG9uZSBJbnRlbnQtXG4gICAqIHByaW9yaXR5IHRhc2sgYXQgYSB0aW1lOyB3aGVuIGEgbmV3IEludGVudCB0YXNrIGlzIHNjaGVkdWxlZCwgdGhlIHByZXZpb3VzXG4gICAqIG9uZSBpcyBidW1wZWQgZG93biB0byBEZWZhdWx0LlxuICAgKi9cbiAgSW50ZW50ID0gMixcbiAgLyoqXG4gICAqIFRoZSBkZWZhdWx0IHByaW9yaXR5IGZvciBwcmVmZXRjaCB0YXNrcy5cbiAgICovXG4gIERlZmF1bHQgPSAxLFxuICAvKipcbiAgICogQXNzaWduZWQgdG8gdGFza3Mgd2hlbiB0aGV5IHNwYXduIG5vbi1ibG9ja2luZyBiYWNrZ3JvdW5kIHdvcmssIGxpa2VcbiAgICogcmV2YWxpZGF0aW5nIGEgcGFydGlhbGx5IGNhY2hlZCBlbnRyeSB0byBzZWUgaWYgbW9yZSBkYXRhIGlzIGF2YWlsYWJsZS5cbiAgICovXG4gIEJhY2tncm91bmQgPSAwLFxufVxuIl0sIm5hbWVzIjpbIk5hdmlnYXRpb25SZXN1bHRUYWciLCJQcmVmZXRjaFByaW9yaXR5IiwiY2FuY2VsUHJlZmV0Y2hUYXNrIiwiY3JlYXRlQ2FjaGVLZXkiLCJnZXRDdXJyZW50Q2FjaGVWZXJzaW9uIiwiaXNQcmVmZXRjaFRhc2tEaXJ0eSIsIm5hdmlnYXRlIiwicHJlZmV0Y2giLCJyZXNjaGVkdWxlUHJlZmV0Y2hUYXNrIiwicmV2YWxpZGF0ZUVudGlyZUNhY2hlIiwic2NoZWR1bGVQcmVmZXRjaFRhc2siLCJub3RFbmFibGVkIiwiRXJyb3IiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX0NMSUVOVF9TRUdNRU5UX0NBQ0hFIiwiYXJncyIsInJlcXVpcmUiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7OztDQWlCQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFpR2lCQSxtQkFBbUIsRUFBQTtlQUFuQkE7O0lBVUFDLGdCQUFnQixFQUFBO2VBQWhCQTs7SUFuRExDLGtCQUFrQixFQUFBO2VBQWxCQTs7SUEyQkFDLGNBQWMsRUFBQTtlQUFkQTs7SUE3Q0FDLHNCQUFzQixFQUFBO2VBQXRCQTs7SUFvQ0FDLG1CQUFtQixFQUFBO2VBQW5CQTs7SUF0REFDLFFBQVEsRUFBQTtlQUFSQTs7SUFUQUMsUUFBUSxFQUFBO2VBQVJBOztJQXNEQUMsc0JBQXNCLEVBQUE7ZUFBdEJBOztJQXBDQUMscUJBQXFCLEVBQUE7ZUFBckJBOztJQWtCQUMsb0JBQW9CLEVBQUE7ZUFBcEJBOzs7QUExQ2IsTUFBTUMsYUFBa0I7SUFDdEIsTUFBTSxPQUFBLGNBRUwsQ0FGSyxJQUFJQyxNQUNSLHVFQURJLHFCQUFBO2VBQUE7b0JBQUE7c0JBQUE7SUFFTjtBQUNGO0FBRU8sTUFBTUwsV0FDWE0sUUFBUUMsR0FBRyxDQUFDQywwQkFDUixDQURtQyx5QkFNbkNKO0FBRUMsTUFBTUwsV0FDWE8sUUFBUUMsR0FBRyxDQUFDQywwQkFDUixDQURtQyx5QkFNbkNKO0FBRUMsTUFBTUYsd0JBQ1hJLFFBQVFDLEdBQUcsQ0FBQ0MsMEJBQ1IsQ0FEbUMseUJBTW5DSjtBQUVDLE1BQU1QLHlCQUNYUyxRQUFRQyxHQUFHLENBQUNDLDBCQUNSLENBRG1DLHlCQU1uQ0o7QUFFQyxNQUFNRCx1QkFDWEcsUUFBUUMsR0FBRyxDQUFDQywwQkFDUixDQURtQyx5QkFNbkNKO0FBRUMsTUFBTVQscUJBQ1hXLFFBQVFDLEdBQUcsQ0FBQ0MsMEJBQ1IsQ0FEbUMseUJBTW5DSjtBQUVDLE1BQU1ILHlCQUNYSyxRQUFRQyxHQUFHLENBQUNDLDBCQUNSLENBRG1DLHlCQU1uQ0o7QUFFQyxNQUFNTixzQkFDWFEsUUFBUUMsR0FBRyxDQUFDQywwQkFDUixDQURtQyx5QkFNbkNKO0FBRUMsTUFBTVIsaUJBQ1hVLFFBQVFDLEdBQUcsQ0FBQ0MsMEJBQ1IsQ0FEbUMseUJBTW5DSjtBQU9DLElBQVdYLHNCQUFBQSxXQUFBQSxHQUFBQSxTQUFBQSxtQkFBQUE7Ozs7O1dBQUFBOztBQVVYLElBQVdDLG1CQUFBQSxXQUFBQSxHQUFBQSxTQUFBQSxnQkFBQUE7SUFDaEI7Ozs7O0dBS0MsR0FBQSxnQkFBQSxDQUFBLGdCQUFBLENBQUEsU0FBQSxHQUFBLEVBQUEsR0FBQTtJQUVEOztHQUVDLEdBQUEsZ0JBQUEsQ0FBQSxnQkFBQSxDQUFBLFVBQUEsR0FBQSxFQUFBLEdBQUE7SUFFRDs7O0dBR0MsR0FBQSxnQkFBQSxDQUFBLGdCQUFBLENBQUEsYUFBQSxHQUFBLEVBQUEsR0FBQTtXQWZlQSIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxMTEzNCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yZWR1Y2Vycy9uYXZpZ2F0ZS1yZWR1Y2VyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgQ2FjaGVOb2RlIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgdHlwZSB7XG4gIEZsaWdodFJvdXRlclN0YXRlLFxuICBGbGlnaHRTZWdtZW50UGF0aCxcbn0gZnJvbSAnLi4vLi4vLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvdHlwZXMnXG5pbXBvcnQgeyBmZXRjaFNlcnZlclJlc3BvbnNlIH0gZnJvbSAnLi4vZmV0Y2gtc2VydmVyLXJlc3BvbnNlJ1xuaW1wb3J0IHsgY3JlYXRlSHJlZkZyb21VcmwgfSBmcm9tICcuLi9jcmVhdGUtaHJlZi1mcm9tLXVybCdcbmltcG9ydCB7IGludmFsaWRhdGVDYWNoZUJlbG93RmxpZ2h0U2VnbWVudFBhdGggfSBmcm9tICcuLi9pbnZhbGlkYXRlLWNhY2hlLWJlbG93LWZsaWdodC1zZWdtZW50cGF0aCdcbmltcG9ydCB7IGFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZSB9IGZyb20gJy4uL2FwcGx5LXJvdXRlci1zdGF0ZS1wYXRjaC10by10cmVlJ1xuaW1wb3J0IHsgc2hvdWxkSGFyZE5hdmlnYXRlIH0gZnJvbSAnLi4vc2hvdWxkLWhhcmQtbmF2aWdhdGUnXG5pbXBvcnQgeyBpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQgfSBmcm9tICcuLi9pcy1uYXZpZ2F0aW5nLXRvLW5ldy1yb290LWxheW91dCdcbmltcG9ydCB7XG4gIFByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cyxcbiAgdHlwZSBNdXRhYmxlLFxuICB0eXBlIE5hdmlnYXRlQWN0aW9uLFxuICB0eXBlIFJlYWRvbmx5UmVkdWNlclN0YXRlLFxuICB0eXBlIFJlZHVjZXJTdGF0ZSxcbn0gZnJvbSAnLi4vcm91dGVyLXJlZHVjZXItdHlwZXMnXG5pbXBvcnQgeyBoYW5kbGVNdXRhYmxlIH0gZnJvbSAnLi4vaGFuZGxlLW11dGFibGUnXG5pbXBvcnQgeyBhcHBseUZsaWdodERhdGEgfSBmcm9tICcuLi9hcHBseS1mbGlnaHQtZGF0YSdcbmltcG9ydCB7IHByZWZldGNoUXVldWUgfSBmcm9tICcuL3ByZWZldGNoLXJlZHVjZXInXG5pbXBvcnQgeyBjcmVhdGVFbXB0eUNhY2hlTm9kZSB9IGZyb20gJy4uLy4uL2FwcC1yb3V0ZXInXG5pbXBvcnQgeyBERUZBVUxUX1NFR01FTlRfS0VZIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL2xpYi9zZWdtZW50J1xuaW1wb3J0IHsgbGlzdGVuRm9yRHluYW1pY1JlcXVlc3QsIHN0YXJ0UFBSTmF2aWdhdGlvbiB9IGZyb20gJy4uL3Bwci1uYXZpZ2F0aW9ucydcbmltcG9ydCB7XG4gIGdldE9yQ3JlYXRlUHJlZmV0Y2hDYWNoZUVudHJ5LFxuICBwcnVuZVByZWZldGNoQ2FjaGUsXG59IGZyb20gJy4uL3ByZWZldGNoLWNhY2hlLXV0aWxzJ1xuaW1wb3J0IHsgY2xlYXJDYWNoZU5vZGVEYXRhRm9yU2VnbWVudFBhdGggfSBmcm9tICcuLi9jbGVhci1jYWNoZS1ub2RlLWRhdGEtZm9yLXNlZ21lbnQtcGF0aCdcbmltcG9ydCB7IGhhbmRsZUFsaWFzZWRQcmVmZXRjaEVudHJ5IH0gZnJvbSAnLi4vYWxpYXNlZC1wcmVmZXRjaC1uYXZpZ2F0aW9ucydcbmltcG9ydCB7XG4gIG5hdmlnYXRlIGFzIG5hdmlnYXRlVXNpbmdTZWdtZW50Q2FjaGUsXG4gIE5hdmlnYXRpb25SZXN1bHRUYWcsXG4gIHR5cGUgTmF2aWdhdGlvblJlc3VsdCxcbn0gZnJvbSAnLi4vLi4vc2VnbWVudC1jYWNoZSdcblxuZXhwb3J0IGZ1bmN0aW9uIGhhbmRsZUV4dGVybmFsVXJsKFxuICBzdGF0ZTogUmVhZG9ubHlSZWR1Y2VyU3RhdGUsXG4gIG11dGFibGU6IE11dGFibGUsXG4gIHVybDogc3RyaW5nLFxuICBwZW5kaW5nUHVzaDogYm9vbGVhblxuKSB7XG4gIG11dGFibGUubXBhTmF2aWdhdGlvbiA9IHRydWVcbiAgbXV0YWJsZS5jYW5vbmljYWxVcmwgPSB1cmxcbiAgbXV0YWJsZS5wZW5kaW5nUHVzaCA9IHBlbmRpbmdQdXNoXG4gIG11dGFibGUuc2Nyb2xsYWJsZVNlZ21lbnRzID0gdW5kZWZpbmVkXG5cbiAgcmV0dXJuIGhhbmRsZU11dGFibGUoc3RhdGUsIG11dGFibGUpXG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlU2VnbWVudHNGcm9tUGF0Y2goXG4gIGZsaWdodFJvdXRlclBhdGNoOiBGbGlnaHRSb3V0ZXJTdGF0ZVxuKTogRmxpZ2h0U2VnbWVudFBhdGhbXSB7XG4gIGNvbnN0IHNlZ21lbnRzOiBGbGlnaHRTZWdtZW50UGF0aFtdID0gW11cbiAgY29uc3QgW3NlZ21lbnQsIHBhcmFsbGVsUm91dGVzXSA9IGZsaWdodFJvdXRlclBhdGNoXG5cbiAgaWYgKE9iamVjdC5rZXlzKHBhcmFsbGVsUm91dGVzKS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW1tzZWdtZW50XV1cbiAgfVxuXG4gIGZvciAoY29uc3QgW3BhcmFsbGVsUm91dGVLZXksIHBhcmFsbGVsUm91dGVdIG9mIE9iamVjdC5lbnRyaWVzKFxuICAgIHBhcmFsbGVsUm91dGVzXG4gICkpIHtcbiAgICBmb3IgKGNvbnN0IGNoaWxkU2VnbWVudCBvZiBnZW5lcmF0ZVNlZ21lbnRzRnJvbVBhdGNoKHBhcmFsbGVsUm91dGUpKSB7XG4gICAgICAvLyBJZiB0aGUgc2VnbWVudCBpcyBlbXB0eSwgaXQgbWVhbnMgd2UgYXJlIGF0IHRoZSByb290IG9mIHRoZSB0cmVlXG4gICAgICBpZiAoc2VnbWVudCA9PT0gJycpIHtcbiAgICAgICAgc2VnbWVudHMucHVzaChbcGFyYWxsZWxSb3V0ZUtleSwgLi4uY2hpbGRTZWdtZW50XSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlZ21lbnRzLnB1c2goW3NlZ21lbnQsIHBhcmFsbGVsUm91dGVLZXksIC4uLmNoaWxkU2VnbWVudF0pXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNlZ21lbnRzXG59XG5cbmZ1bmN0aW9uIHRyaWdnZXJMYXp5RmV0Y2hGb3JMZWFmU2VnbWVudHMoXG4gIG5ld0NhY2hlOiBDYWNoZU5vZGUsXG4gIGN1cnJlbnRDYWNoZTogQ2FjaGVOb2RlLFxuICBmbGlnaHRTZWdtZW50UGF0aDogRmxpZ2h0U2VnbWVudFBhdGgsXG4gIHRyZWVQYXRjaDogRmxpZ2h0Um91dGVyU3RhdGVcbikge1xuICBsZXQgYXBwbGllZFBhdGNoID0gZmFsc2VcblxuICBuZXdDYWNoZS5yc2MgPSBjdXJyZW50Q2FjaGUucnNjXG4gIG5ld0NhY2hlLnByZWZldGNoUnNjID0gY3VycmVudENhY2hlLnByZWZldGNoUnNjXG4gIG5ld0NhY2hlLmxvYWRpbmcgPSBjdXJyZW50Q2FjaGUubG9hZGluZ1xuICBuZXdDYWNoZS5wYXJhbGxlbFJvdXRlcyA9IG5ldyBNYXAoY3VycmVudENhY2hlLnBhcmFsbGVsUm91dGVzKVxuXG4gIGNvbnN0IHNlZ21lbnRQYXRoc1RvRmlsbCA9IGdlbmVyYXRlU2VnbWVudHNGcm9tUGF0Y2godHJlZVBhdGNoKS5tYXAoXG4gICAgKHNlZ21lbnQpID0+IFsuLi5mbGlnaHRTZWdtZW50UGF0aCwgLi4uc2VnbWVudF1cbiAgKVxuXG4gIGZvciAoY29uc3Qgc2VnbWVudFBhdGhzIG9mIHNlZ21lbnRQYXRoc1RvRmlsbCkge1xuICAgIGNsZWFyQ2FjaGVOb2RlRGF0YUZvclNlZ21lbnRQYXRoKG5ld0NhY2hlLCBjdXJyZW50Q2FjaGUsIHNlZ21lbnRQYXRocylcblxuICAgIGFwcGxpZWRQYXRjaCA9IHRydWVcbiAgfVxuXG4gIHJldHVybiBhcHBsaWVkUGF0Y2hcbn1cblxuZnVuY3Rpb24gaGFuZGxlTmF2aWdhdGlvblJlc3VsdChcbiAgdXJsOiBVUkwsXG4gIHN0YXRlOiBSZWFkb25seVJlZHVjZXJTdGF0ZSxcbiAgbXV0YWJsZTogTXV0YWJsZSxcbiAgcGVuZGluZ1B1c2g6IGJvb2xlYW4sXG4gIHJlc3VsdDogTmF2aWdhdGlvblJlc3VsdFxuKTogUmVkdWNlclN0YXRlIHtcbiAgc3dpdGNoIChyZXN1bHQudGFnKSB7XG4gICAgY2FzZSBOYXZpZ2F0aW9uUmVzdWx0VGFnLk1QQToge1xuICAgICAgLy8gUGVyZm9ybSBhbiBNUEEgbmF2aWdhdGlvbi5cbiAgICAgIGNvbnN0IG5ld1VybCA9IHJlc3VsdC5kYXRhXG4gICAgICByZXR1cm4gaGFuZGxlRXh0ZXJuYWxVcmwoc3RhdGUsIG11dGFibGUsIG5ld1VybCwgcGVuZGluZ1B1c2gpXG4gICAgfVxuICAgIGNhc2UgTmF2aWdhdGlvblJlc3VsdFRhZy5Ob09wOiB7XG4gICAgICAvLyBUaGUgc2VydmVyIHJlc3BvbmRlZCB3aXRoIG5vIGNoYW5nZSB0byB0aGUgY3VycmVudCBwYWdlLiBIb3dldmVyLCBpZlxuICAgICAgLy8gdGhlIFVSTCBjaGFuZ2VkLCB3ZSBzdGlsbCBuZWVkIHRvIHVwZGF0ZSB0aGF0LlxuICAgICAgY29uc3QgbmV3Q2Fub25pY2FsVXJsID0gcmVzdWx0LmRhdGEuY2Fub25pY2FsVXJsXG4gICAgICBtdXRhYmxlLmNhbm9uaWNhbFVybCA9IG5ld0Nhbm9uaWNhbFVybFxuXG4gICAgICAvLyBDaGVjayBpZiB0aGUgb25seSB0aGluZyB0aGF0IGNoYW5nZWQgd2FzIHRoZSBoYXNoIGZyYWdtZW50LlxuICAgICAgY29uc3Qgb2xkVXJsID0gbmV3IFVSTChzdGF0ZS5jYW5vbmljYWxVcmwsIHVybClcbiAgICAgIGNvbnN0IG9ubHlIYXNoQ2hhbmdlID1cbiAgICAgICAgLy8gV2UgZG9uJ3QgbmVlZCB0byBjb21wYXJlIHRoZSBvcmlnaW5zLCBiZWNhdXNlIGNsaWVudC1kcml2ZW5cbiAgICAgICAgLy8gbmF2aWdhdGlvbnMgYXJlIGFsd2F5cyBzYW1lLW9yaWdpbi5cbiAgICAgICAgdXJsLnBhdGhuYW1lID09PSBvbGRVcmwucGF0aG5hbWUgJiZcbiAgICAgICAgdXJsLnNlYXJjaCA9PT0gb2xkVXJsLnNlYXJjaCAmJlxuICAgICAgICB1cmwuaGFzaCAhPT0gb2xkVXJsLmhhc2hcbiAgICAgIGlmIChvbmx5SGFzaENoYW5nZSkge1xuICAgICAgICAvLyBUaGUgb25seSB1cGRhdGVkIHBhcnQgb2YgdGhlIFVSTCBpcyB0aGUgaGFzaC5cbiAgICAgICAgbXV0YWJsZS5vbmx5SGFzaENoYW5nZSA9IHRydWVcbiAgICAgICAgbXV0YWJsZS5zaG91bGRTY3JvbGwgPSByZXN1bHQuZGF0YS5zaG91bGRTY3JvbGxcbiAgICAgICAgbXV0YWJsZS5oYXNoRnJhZ21lbnQgPSB1cmwuaGFzaFxuICAgICAgICAvLyBTZXR0aW5nIHRoaXMgdG8gYW4gZW1wdHkgYXJyYXkgdHJpZ2dlcnMgYSBzY3JvbGwgZm9yIGFsbCBuZXcgYW5kXG4gICAgICAgIC8vIHVwZGF0ZWQgc2VnbWVudHMuIFNlZSBgU2Nyb2xsQW5kRm9jdXNIYW5kbGVyYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICBtdXRhYmxlLnNjcm9sbGFibGVTZWdtZW50cyA9IFtdXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYW5kbGVNdXRhYmxlKHN0YXRlLCBtdXRhYmxlKVxuICAgIH1cbiAgICBjYXNlIE5hdmlnYXRpb25SZXN1bHRUYWcuU3VjY2Vzczoge1xuICAgICAgLy8gUmVjZWl2ZWQgYSBuZXcgcmVzdWx0LlxuICAgICAgbXV0YWJsZS5jYWNoZSA9IHJlc3VsdC5kYXRhLmNhY2hlTm9kZVxuICAgICAgbXV0YWJsZS5wYXRjaGVkVHJlZSA9IHJlc3VsdC5kYXRhLmZsaWdodFJvdXRlclN0YXRlXG4gICAgICBtdXRhYmxlLmNhbm9uaWNhbFVybCA9IHJlc3VsdC5kYXRhLmNhbm9uaWNhbFVybFxuICAgICAgbXV0YWJsZS5zY3JvbGxhYmxlU2VnbWVudHMgPSByZXN1bHQuZGF0YS5zY3JvbGxhYmxlU2VnbWVudHNcbiAgICAgIG11dGFibGUuc2hvdWxkU2Nyb2xsID0gcmVzdWx0LmRhdGEuc2hvdWxkU2Nyb2xsXG4gICAgICBtdXRhYmxlLmhhc2hGcmFnbWVudCA9IHJlc3VsdC5kYXRhLmhhc2hcbiAgICAgIHJldHVybiBoYW5kbGVNdXRhYmxlKHN0YXRlLCBtdXRhYmxlKVxuICAgIH1cbiAgICBjYXNlIE5hdmlnYXRpb25SZXN1bHRUYWcuQXN5bmM6IHtcbiAgICAgIHJldHVybiByZXN1bHQuZGF0YS50aGVuKFxuICAgICAgICAoYXN5bmNSZXN1bHQpID0+XG4gICAgICAgICAgaGFuZGxlTmF2aWdhdGlvblJlc3VsdCh1cmwsIHN0YXRlLCBtdXRhYmxlLCBwZW5kaW5nUHVzaCwgYXN5bmNSZXN1bHQpLFxuICAgICAgICAvLyBJZiB0aGUgbmF2aWdhdGlvbiBmYWlsZWQsIHJldHVybiB0aGUgY3VycmVudCBzdGF0ZS5cbiAgICAgICAgLy8gVE9ETzogVGhpcyBtYXRjaGVzIHRoZSBjdXJyZW50IGJlaGF2aW9yIGJ1dCB3ZSBuZWVkIHRvIGRvIHNvbWV0aGluZ1xuICAgICAgICAvLyBiZXR0ZXIgaGVyZSBpZiB0aGUgbmV0d29yayBmYWlscy5cbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIHJldHVybiBzdGF0ZVxuICAgICAgICB9XG4gICAgICApXG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHJlc3VsdCBzYXRpc2ZpZXMgbmV2ZXJcbiAgICAgIHJldHVybiBzdGF0ZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbmF2aWdhdGVSZWR1Y2VyKFxuICBzdGF0ZTogUmVhZG9ubHlSZWR1Y2VyU3RhdGUsXG4gIGFjdGlvbjogTmF2aWdhdGVBY3Rpb25cbik6IFJlZHVjZXJTdGF0ZSB7XG4gIGNvbnN0IHsgdXJsLCBpc0V4dGVybmFsVXJsLCBuYXZpZ2F0ZVR5cGUsIHNob3VsZFNjcm9sbCwgYWxsb3dBbGlhc2luZyB9ID1cbiAgICBhY3Rpb25cbiAgY29uc3QgbXV0YWJsZTogTXV0YWJsZSA9IHt9XG4gIGNvbnN0IHsgaGFzaCB9ID0gdXJsXG4gIGNvbnN0IGhyZWYgPSBjcmVhdGVIcmVmRnJvbVVybCh1cmwpXG4gIGNvbnN0IHBlbmRpbmdQdXNoID0gbmF2aWdhdGVUeXBlID09PSAncHVzaCdcbiAgLy8gd2Ugd2FudCB0byBwcnVuZSB0aGUgcHJlZmV0Y2ggY2FjaGUgb24gZXZlcnkgbmF2aWdhdGlvbiB0byBhdm9pZCBpdCBncm93aW5nIHRvbyBsYXJnZVxuICBwcnVuZVByZWZldGNoQ2FjaGUoc3RhdGUucHJlZmV0Y2hDYWNoZSlcblxuICBtdXRhYmxlLnByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlID0gZmFsc2VcbiAgbXV0YWJsZS5wZW5kaW5nUHVzaCA9IHBlbmRpbmdQdXNoXG5cbiAgaWYgKGlzRXh0ZXJuYWxVcmwpIHtcbiAgICByZXR1cm4gaGFuZGxlRXh0ZXJuYWxVcmwoc3RhdGUsIG11dGFibGUsIHVybC50b1N0cmluZygpLCBwZW5kaW5nUHVzaClcbiAgfVxuXG4gIC8vIEhhbmRsZXMgY2FzZSB3aGVyZSBgPG1ldGEgaHR0cC1lcXVpdj1cInJlZnJlc2hcIj5gIHRhZyBpcyBwcmVzZW50LFxuICAvLyB3aGljaCB3aWxsIHRyaWdnZXIgYW4gTVBBIG5hdmlnYXRpb24uXG4gIGlmIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnX19uZXh0LXBhZ2UtcmVkaXJlY3QnKSkge1xuICAgIHJldHVybiBoYW5kbGVFeHRlcm5hbFVybChzdGF0ZSwgbXV0YWJsZSwgaHJlZiwgcGVuZGluZ1B1c2gpXG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0NMSUVOVF9TRUdNRU5UX0NBQ0hFKSB7XG4gICAgLy8gKFZlcnkgRWFybHkgRXhwZXJpbWVudGFsIEZlYXR1cmUpIFNlZ21lbnQgQ2FjaGVcbiAgICAvL1xuICAgIC8vIEJ5cGFzcyB0aGUgbm9ybWFsIHByZWZldGNoIGNhY2hlIGFuZCB1c2UgdGhlIG5ldyBwZXItc2VnbWVudCBjYWNoZVxuICAgIC8vIGltcGxlbWVudGF0aW9uIGluc3RlYWQuIFRoaXMgaXMgb25seSBzdXBwb3J0ZWQgaWYgUFBSIGlzIGVuYWJsZWQsIHRvby5cbiAgICAvL1xuICAgIC8vIFRlbXBvcmFyeSBnbHVlIGNvZGUgYmV0d2VlbiB0aGUgcm91dGVyIHJlZHVjZXIgYW5kIHRoZSBuZXcgbmF2aWdhdGlvblxuICAgIC8vIGltcGxlbWVudGF0aW9uLiBFdmVudHVhbGx5IHdlJ2xsIHJld3JpdGUgdGhlIHJvdXRlciByZWR1Y2VyIHRvIGFcbiAgICAvLyBzdGF0ZSBtYWNoaW5lLlxuICAgIGNvbnN0IHJlc3VsdCA9IG5hdmlnYXRlVXNpbmdTZWdtZW50Q2FjaGUoXG4gICAgICB1cmwsXG4gICAgICBzdGF0ZS5jYWNoZSxcbiAgICAgIHN0YXRlLnRyZWUsXG4gICAgICBzdGF0ZS5uZXh0VXJsLFxuICAgICAgc2hvdWxkU2Nyb2xsXG4gICAgKVxuICAgIHJldHVybiBoYW5kbGVOYXZpZ2F0aW9uUmVzdWx0KHVybCwgc3RhdGUsIG11dGFibGUsIHBlbmRpbmdQdXNoLCByZXN1bHQpXG4gIH1cblxuICBjb25zdCBwcmVmZXRjaFZhbHVlcyA9IGdldE9yQ3JlYXRlUHJlZmV0Y2hDYWNoZUVudHJ5KHtcbiAgICB1cmwsXG4gICAgbmV4dFVybDogc3RhdGUubmV4dFVybCxcbiAgICB0cmVlOiBzdGF0ZS50cmVlLFxuICAgIHByZWZldGNoQ2FjaGU6IHN0YXRlLnByZWZldGNoQ2FjaGUsXG4gICAgYWxsb3dBbGlhc2luZyxcbiAgfSlcbiAgY29uc3QgeyB0cmVlQXRUaW1lT2ZQcmVmZXRjaCwgZGF0YSB9ID0gcHJlZmV0Y2hWYWx1ZXNcblxuICBwcmVmZXRjaFF1ZXVlLmJ1bXAoZGF0YSlcblxuICByZXR1cm4gZGF0YS50aGVuKFxuICAgICh7IGZsaWdodERhdGEsIGNhbm9uaWNhbFVybDogY2Fub25pY2FsVXJsT3ZlcnJpZGUsIHBvc3Rwb25lZCB9KSA9PiB7XG4gICAgICBjb25zdCBuYXZpZ2F0ZWRBdCA9IERhdGUubm93KClcblxuICAgICAgbGV0IGlzRmlyc3RSZWFkID0gZmFsc2VcbiAgICAgIC8vIHdlIG9ubHkgd2FudCB0byBtYXJrIHRoaXMgb25jZVxuICAgICAgaWYgKCFwcmVmZXRjaFZhbHVlcy5sYXN0VXNlZFRpbWUpIHtcbiAgICAgICAgLy8gaW1wb3J0YW50OiB3ZSBzaG91bGQgb25seSBtYXJrIHRoZSBjYWNoZSBub2RlIGFzIGRpcnR5IGFmdGVyIHdlIHVuc3VzcGVuZCBmcm9tIHRoZSBjYWxsIGFib3ZlXG4gICAgICAgIHByZWZldGNoVmFsdWVzLmxhc3RVc2VkVGltZSA9IG5hdmlnYXRlZEF0XG4gICAgICAgIGlzRmlyc3RSZWFkID0gdHJ1ZVxuICAgICAgfVxuXG4gICAgICBpZiAocHJlZmV0Y2hWYWx1ZXMuYWxpYXNlZCkge1xuICAgICAgICAvLyBXaGVuIGFsaWFzIGlzIGVuYWJsZWQsIHNlYXJjaCBwYXJhbSBtYXkgbm90IGJlIGluY2x1ZGVkIGluIHRoZSBjYW5vbmljYWxVcmwuXG4gICAgICAgIC8vIEJ1dCB3ZSB3YW50IHRvIHNldCB1cmwgdG8gY2Fub25pY2FsVXJsIHNvIHRoYXQgd2UgdXNlIHJlZGlyZWN0ZWQgcGF0aCBmb3IgZmV0Y2hpbmcgZHluYW1pYyBkYXRhLlxuICAgICAgICBjb25zdCB1cmxXaXRoQ2Fub25pY2FsUGF0aG5hbWUgPSBuZXcgVVJMKHVybC5ocmVmKVxuICAgICAgICBpZiAoY2Fub25pY2FsVXJsT3ZlcnJpZGUpIHtcbiAgICAgICAgICB1cmxXaXRoQ2Fub25pY2FsUGF0aG5hbWUucGF0aG5hbWUgPSBjYW5vbmljYWxVcmxPdmVycmlkZS5wYXRobmFtZVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gaGFuZGxlQWxpYXNlZFByZWZldGNoRW50cnkoXG4gICAgICAgICAgbmF2aWdhdGVkQXQsXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgZmxpZ2h0RGF0YSxcbiAgICAgICAgICB1cmxXaXRoQ2Fub25pY2FsUGF0aG5hbWUsXG4gICAgICAgICAgbXV0YWJsZVxuICAgICAgICApXG5cbiAgICAgICAgLy8gV2UgZGlkbid0IHJldHVybiBuZXcgcm91dGVyIHN0YXRlIGJlY2F1c2Ugd2UgZGlkbid0IGFwcGx5IHRoZSBhbGlhc2VkIGVudHJ5IGZvciBzb21lIHJlYXNvbi5cbiAgICAgICAgLy8gV2UnbGwgcmUtaW52b2tlIHRoZSBuYXZpZ2F0aW9uIGhhbmRsZXIgYnV0IGVuc3VyZSB0aGF0IHdlIGRvbid0IGF0dGVtcHQgdG8gdXNlIHRoZSBhbGlhc2VkIGVudHJ5LiBUaGlzXG4gICAgICAgIC8vIHdpbGwgY3JlYXRlIGFuIG9uLWRlbWFuZCBwcmVmZXRjaCBlbnRyeS5cbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gbmF2aWdhdGVSZWR1Y2VyKHN0YXRlLCB7IC4uLmFjdGlvbiwgYWxsb3dBbGlhc2luZzogZmFsc2UgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgIH1cblxuICAgICAgLy8gSGFuZGxlIGNhc2Ugd2hlbiBuYXZpZ2F0aW5nIHRvIHBhZ2UgaW4gYHBhZ2VzYCBmcm9tIGBhcHBgXG4gICAgICBpZiAodHlwZW9mIGZsaWdodERhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVFeHRlcm5hbFVybChzdGF0ZSwgbXV0YWJsZSwgZmxpZ2h0RGF0YSwgcGVuZGluZ1B1c2gpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVwZGF0ZWRDYW5vbmljYWxVcmwgPSBjYW5vbmljYWxVcmxPdmVycmlkZVxuICAgICAgICA/IGNyZWF0ZUhyZWZGcm9tVXJsKGNhbm9uaWNhbFVybE92ZXJyaWRlKVxuICAgICAgICA6IGhyZWZcblxuICAgICAgY29uc3Qgb25seUhhc2hDaGFuZ2UgPVxuICAgICAgICAhIWhhc2ggJiZcbiAgICAgICAgc3RhdGUuY2Fub25pY2FsVXJsLnNwbGl0KCcjJywgMSlbMF0gPT09XG4gICAgICAgICAgdXBkYXRlZENhbm9uaWNhbFVybC5zcGxpdCgnIycsIDEpWzBdXG5cbiAgICAgIC8vIElmIG9ubHkgdGhlIGhhc2ggaGFzIGNoYW5nZWQsIHRoZSBzZXJ2ZXIgaGFzbid0IHNlbnQgdXMgYW55IG5ldyBkYXRhLiBXZSBjYW4ganVzdCB1cGRhdGVcbiAgICAgIC8vIHRoZSBtdXRhYmxlIHByb3BlcnRpZXMgcmVzcG9uc2libGUgZm9yIFVSTCBhbmQgc2Nyb2xsIGhhbmRsaW5nIGFuZCByZXR1cm4gZWFybHkuXG4gICAgICBpZiAob25seUhhc2hDaGFuZ2UpIHtcbiAgICAgICAgbXV0YWJsZS5vbmx5SGFzaENoYW5nZSA9IHRydWVcbiAgICAgICAgbXV0YWJsZS5jYW5vbmljYWxVcmwgPSB1cGRhdGVkQ2Fub25pY2FsVXJsXG4gICAgICAgIG11dGFibGUuc2hvdWxkU2Nyb2xsID0gc2hvdWxkU2Nyb2xsXG4gICAgICAgIG11dGFibGUuaGFzaEZyYWdtZW50ID0gaGFzaFxuICAgICAgICBtdXRhYmxlLnNjcm9sbGFibGVTZWdtZW50cyA9IFtdXG4gICAgICAgIHJldHVybiBoYW5kbGVNdXRhYmxlKHN0YXRlLCBtdXRhYmxlKVxuICAgICAgfVxuXG4gICAgICBsZXQgY3VycmVudFRyZWUgPSBzdGF0ZS50cmVlXG4gICAgICBsZXQgY3VycmVudENhY2hlID0gc3RhdGUuY2FjaGVcbiAgICAgIGxldCBzY3JvbGxhYmxlU2VnbWVudHM6IEZsaWdodFNlZ21lbnRQYXRoW10gPSBbXVxuICAgICAgZm9yIChjb25zdCBub3JtYWxpemVkRmxpZ2h0RGF0YSBvZiBmbGlnaHREYXRhKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBwYXRoVG9TZWdtZW50OiBmbGlnaHRTZWdtZW50UGF0aCxcbiAgICAgICAgICBzZWVkRGF0YSxcbiAgICAgICAgICBoZWFkLFxuICAgICAgICAgIGlzSGVhZFBhcnRpYWwsXG4gICAgICAgICAgaXNSb290UmVuZGVyLFxuICAgICAgICB9ID0gbm9ybWFsaXplZEZsaWdodERhdGFcbiAgICAgICAgbGV0IHRyZWVQYXRjaCA9IG5vcm1hbGl6ZWRGbGlnaHREYXRhLnRyZWVcblxuICAgICAgICAvLyBUT0RPLUFQUDogcmVtb3ZlICcnXG4gICAgICAgIGNvbnN0IGZsaWdodFNlZ21lbnRQYXRoV2l0aExlYWRpbmdFbXB0eSA9IFsnJywgLi4uZmxpZ2h0U2VnbWVudFBhdGhdXG5cbiAgICAgICAgLy8gQ3JlYXRlIG5ldyB0cmVlIGJhc2VkIG9uIHRoZSBmbGlnaHRTZWdtZW50UGF0aCBhbmQgcm91dGVyIHN0YXRlIHBhdGNoXG4gICAgICAgIGxldCBuZXdUcmVlID0gYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlKFxuICAgICAgICAgIC8vIFRPRE8tQVBQOiByZW1vdmUgJydcbiAgICAgICAgICBmbGlnaHRTZWdtZW50UGF0aFdpdGhMZWFkaW5nRW1wdHksXG4gICAgICAgICAgY3VycmVudFRyZWUsXG4gICAgICAgICAgdHJlZVBhdGNoLFxuICAgICAgICAgIGhyZWZcbiAgICAgICAgKVxuXG4gICAgICAgIC8vIElmIHRoZSB0cmVlIHBhdGNoIGNhbid0IGJlIGFwcGxpZWQgdG8gdGhlIGN1cnJlbnQgdHJlZSB0aGVuIHdlIHVzZSB0aGUgdHJlZSBhdCB0aW1lIG9mIHByZWZldGNoXG4gICAgICAgIC8vIFRPRE8tQVBQOiBUaGlzIHNob3VsZCBpbnN0ZWFkIGZpbGwgaW4gdGhlIG1pc3NpbmcgcGllY2VzIGluIGBjdXJyZW50VHJlZWAgd2l0aCB0aGUgZGF0YSBmcm9tIGB0cmVlQXRUaW1lT2ZQcmVmZXRjaGAsIHRoZW4gYXBwbHkgdGhlIHBhdGNoLlxuICAgICAgICBpZiAobmV3VHJlZSA9PT0gbnVsbCkge1xuICAgICAgICAgIG5ld1RyZWUgPSBhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUoXG4gICAgICAgICAgICAvLyBUT0RPLUFQUDogcmVtb3ZlICcnXG4gICAgICAgICAgICBmbGlnaHRTZWdtZW50UGF0aFdpdGhMZWFkaW5nRW1wdHksXG4gICAgICAgICAgICB0cmVlQXRUaW1lT2ZQcmVmZXRjaCxcbiAgICAgICAgICAgIHRyZWVQYXRjaCxcbiAgICAgICAgICAgIGhyZWZcbiAgICAgICAgICApXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmV3VHJlZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIC8vIFRoaXMgaXMganVzdCBhIHBhcmFub2lkIGNoZWNrLiBXaGVuIGEgcm91dGUgaXMgUFBSZWQsIHRoZSBzZXJ2ZXJcbiAgICAgICAgICAgIC8vIHdpbGwgc2VuZCBiYWNrIGEgc3RhdGljIHJlc3BvbnNlIHRoYXQncyByZW5kZXJlZCBmcm9tXG4gICAgICAgICAgICAvLyB0aGUgcm9vdC4gSWYgZm9yIHNvbWUgcmVhc29uIGl0IGRvZXNuJ3QsIHdlIGZhbGwgYmFjayB0byB0aGVcbiAgICAgICAgICAgIC8vIG5vbi1QUFIgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgICAvLyBUT0RPOiBXZSBzaG91bGQgZ2V0IHJpZCBvZiB0aGUgZWxzZSBicmFuY2ggYW5kIGRvIGFsbCBuYXZpZ2F0aW9uc1xuICAgICAgICAgICAgLy8gdmlhIHN0YXJ0UFBSTmF2aWdhdGlvbi4gVGhlIGN1cnJlbnQgc3RydWN0dXJlIGlzIGp1c3RcbiAgICAgICAgICAgIC8vIGFuIGluY3JlbWVudGFsIHN0ZXAuXG4gICAgICAgICAgICBzZWVkRGF0YSAmJlxuICAgICAgICAgICAgaXNSb290UmVuZGVyICYmXG4gICAgICAgICAgICBwb3N0cG9uZWRcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnN0IHRhc2sgPSBzdGFydFBQUk5hdmlnYXRpb24oXG4gICAgICAgICAgICAgIG5hdmlnYXRlZEF0LFxuICAgICAgICAgICAgICBjdXJyZW50Q2FjaGUsXG4gICAgICAgICAgICAgIGN1cnJlbnRUcmVlLFxuICAgICAgICAgICAgICB0cmVlUGF0Y2gsXG4gICAgICAgICAgICAgIHNlZWREYXRhLFxuICAgICAgICAgICAgICBoZWFkLFxuICAgICAgICAgICAgICBpc0hlYWRQYXJ0aWFsLFxuICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgc2Nyb2xsYWJsZVNlZ21lbnRzXG4gICAgICAgICAgICApXG5cbiAgICAgICAgICAgIGlmICh0YXNrICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGlmICh0YXNrLnJvdXRlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gRGV0ZWN0ZWQgYSBjaGFuZ2UgdG8gdGhlIHJvb3QgbGF5b3V0LiBQZXJmb3JtIGFuIGZ1bGwtXG4gICAgICAgICAgICAgICAgLy8gcGFnZSBuYXZpZ2F0aW9uLlxuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVFeHRlcm5hbFVybChzdGF0ZSwgbXV0YWJsZSwgaHJlZiwgcGVuZGluZ1B1c2gpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gVXNlIHRoZSB0cmVlIGNvbXB1dGVkIGJ5IHN0YXJ0UFBSTmF2aWdhdGlvbiBpbnN0ZWFkXG4gICAgICAgICAgICAgIC8vIG9mIHRoZSBvbmUgY29tcHV0ZWQgYnkgYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlLlxuICAgICAgICAgICAgICAvLyBUT0RPOiBXZSBzaG91bGQgcmVtb3ZlIGFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZVxuICAgICAgICAgICAgICAvLyBmcm9tIHRoZSBQUFIgcGF0aCBlbnRpcmVseS5cbiAgICAgICAgICAgICAgY29uc3QgcGF0Y2hlZFJvdXRlclN0YXRlOiBGbGlnaHRSb3V0ZXJTdGF0ZSA9IHRhc2sucm91dGVcbiAgICAgICAgICAgICAgbmV3VHJlZSA9IHBhdGNoZWRSb3V0ZXJTdGF0ZVxuXG4gICAgICAgICAgICAgIGNvbnN0IG5ld0NhY2hlID0gdGFzay5ub2RlXG4gICAgICAgICAgICAgIGlmIChuZXdDYWNoZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIFdlJ3ZlIGNyZWF0ZWQgYSBuZXcgQ2FjaGUgTm9kZSB0cmVlIHRoYXQgY29udGFpbnMgYSBwcmVmZXRjaGVkXG4gICAgICAgICAgICAgICAgLy8gdmVyc2lvbiBvZiB0aGUgbmV4dCBwYWdlLiBUaGlzIGNhbiBiZSByZW5kZXJlZCBpbnN0YW50bHkuXG4gICAgICAgICAgICAgICAgbXV0YWJsZS5jYWNoZSA9IG5ld0NhY2hlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgZHluYW1pY1JlcXVlc3RUcmVlID0gdGFzay5keW5hbWljUmVxdWVzdFRyZWVcbiAgICAgICAgICAgICAgaWYgKGR5bmFtaWNSZXF1ZXN0VHJlZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBwcmVmZXRjaGVkIHRyZWUgaGFzIGR5bmFtaWMgaG9sZXMgaW4gaXQuIFdlIGluaXRpYXRlIGFcbiAgICAgICAgICAgICAgICAvLyBkeW5hbWljIHJlcXVlc3QgdG8gZmlsbCB0aGVtIGluLlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gRG8gbm90IGJsb2NrIG9uIHRoZSByZXN1bHQuIFdlJ2xsIGltbWVkaWF0ZWx5IHJlbmRlciB0aGUgQ2FjaGVcbiAgICAgICAgICAgICAgICAvLyBOb2RlIHRyZWUgYW5kIHN1c3BlbmQgb24gdGhlIGR5bmFtaWMgcGFydHMuIFdoZW4gdGhlIHJlcXVlc3RcbiAgICAgICAgICAgICAgICAvLyBjb21lcyBpbiwgd2UnbGwgZmlsbCBpbiBtaXNzaW5nIGRhdGEgYW5kIHBpbmcgUmVhY3QgdG9cbiAgICAgICAgICAgICAgICAvLyByZS1yZW5kZXIuIFVubGlrZSB0aGUgbGF6eSBmZXRjaGluZyBtb2RlbCBpbiB0aGUgbm9uLVBQUlxuICAgICAgICAgICAgICAgIC8vIGltcGxlbWVudGF0aW9uLCB0aGlzIGlzIG1vZGVsZWQgYXMgYSBzaW5nbGUgUmVhY3QgdXBkYXRlICtcbiAgICAgICAgICAgICAgICAvLyBzdHJlYW1pbmcsIHJhdGhlciB0aGFuIG11bHRpcGxlIHRvcC1sZXZlbCB1cGRhdGVzLiAoSG93ZXZlcixcbiAgICAgICAgICAgICAgICAvLyBldmVuIGluIHRoZSBuZXcgbW9kZWwsIHdlJ2xsIHN0aWxsIG5lZWQgdG8gc29tZXRpbWVzIHVwZGF0ZSB0aGVcbiAgICAgICAgICAgICAgICAvLyByb290IG11bHRpcGxlIHRpbWVzIHBlciBuYXZpZ2F0aW9uLCBsaWtlIGlmIHRoZSBzZXJ2ZXIgc2VuZHMgdXNcbiAgICAgICAgICAgICAgICAvLyBhIGRpZmZlcmVudCByZXNwb25zZSB0aGFuIHdlIGV4cGVjdGVkLiBGb3Igbm93LCB3ZSByZXZlcnQgYmFja1xuICAgICAgICAgICAgICAgIC8vIHRvIHRoZSBsYXp5IGZldGNoaW5nIG1lY2hhbmlzbSBpbiB0aGF0IGNhc2UuKVxuICAgICAgICAgICAgICAgIGNvbnN0IGR5bmFtaWNSZXF1ZXN0ID0gZmV0Y2hTZXJ2ZXJSZXNwb25zZShcbiAgICAgICAgICAgICAgICAgIG5ldyBVUkwodXBkYXRlZENhbm9uaWNhbFVybCwgdXJsLm9yaWdpbiksXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGZsaWdodFJvdXRlclN0YXRlOiBkeW5hbWljUmVxdWVzdFRyZWUsXG4gICAgICAgICAgICAgICAgICAgIG5leHRVcmw6IHN0YXRlLm5leHRVcmwsXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICAgICAgbGlzdGVuRm9yRHluYW1pY1JlcXVlc3QodGFzaywgZHluYW1pY1JlcXVlc3QpXG4gICAgICAgICAgICAgICAgLy8gV2Ugc3RvcmUgdGhlIGR5bmFtaWMgcmVxdWVzdCBvbiB0aGUgYGxhenlEYXRhYCBwcm9wZXJ0eSBvZiB0aGUgQ2FjaGVOb2RlXG4gICAgICAgICAgICAgICAgLy8gYmVjYXVzZSB3ZSdyZSBub3QgZ29pbmcgdG8gYXdhaXQgdGhlIGR5bmFtaWMgcmVxdWVzdCBoZXJlLiBTaW5jZSB3ZSdyZSBub3QgYmxvY2tpbmdcbiAgICAgICAgICAgICAgICAvLyBvbiB0aGUgZHluYW1pYyByZXF1ZXN0LCBgbGF5b3V0LXJvdXRlcmAgd2lsbFxuICAgICAgICAgICAgICAgIC8vIHRhc2subm9kZS5sYXp5RGF0YSA9IGR5bmFtaWNSZXF1ZXN0XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHByZWZldGNoZWQgdHJlZSBkb2VzIG5vdCBjb250YWluIGR5bmFtaWMgaG9sZXMg4oCUIGl0J3NcbiAgICAgICAgICAgICAgICAvLyBmdWxseSBzdGF0aWMuIFdlIGNhbiBza2lwIHRoZSBkeW5hbWljIHJlcXVlc3QuXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIE5vdGhpbmcgY2hhbmdlZCwgc28gcmV1c2UgdGhlIG9sZCBjYWNoZS5cbiAgICAgICAgICAgICAgLy8gVE9ETzogV2hhdCBpZiB0aGUgaGVhZCBjaGFuZ2VkIGJ1dCBub3QgYW55IG9mIHRoZSBzZWdtZW50IGRhdGE/XG4gICAgICAgICAgICAgIC8vIElzIHRoYXQgcG9zc2libGU/IElmIHNvLCB3ZSBzaG91bGQgY2xvbmUgdGhlIHdob2xlIHRyZWUgYW5kXG4gICAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgaGVhZC5cbiAgICAgICAgICAgICAgbmV3VHJlZSA9IHRyZWVQYXRjaFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGUgc3RhdGljIHJlc3BvbnNlIGRvZXMgbm90IGluY2x1ZGUgYW55IGR5bmFtaWMgaG9sZXMsIHNvXG4gICAgICAgICAgICAvLyB0aGVyZSdzIG5vIG5lZWQgdG8gZG8gYSBzZWNvbmQgcmVxdWVzdC5cbiAgICAgICAgICAgIC8vIFRPRE86IEFzIGFuIGluY3JlbWVudGFsIHN0ZXAgdGhpcyBqdXN0IHJldmVydHMgYmFjayB0byB0aGVcbiAgICAgICAgICAgIC8vIG5vbi1QUFIgaW1wbGVtZW50YXRpb24uIFdlIGNhbiBzaW1wbGlmeSB0aGlzIGJyYW5jaCBmdXJ0aGVyLFxuICAgICAgICAgICAgLy8gZ2l2ZW4gdGhhdCBQUFIgcHJlZmV0Y2hlcyBhcmUgYWx3YXlzIHN0YXRpYyBhbmQgcmV0dXJuIHRoZSB3aG9sZVxuICAgICAgICAgICAgLy8gdHJlZS4gT3IgaW4gdGhlIG1lYW50aW1lIHdlIGNvdWxkIGZhY3RvciBpdCBvdXQgaW50byBhXG4gICAgICAgICAgICAvLyBzZXBhcmF0ZSBmdW5jdGlvbi5cblxuICAgICAgICAgICAgaWYgKGlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dChjdXJyZW50VHJlZSwgbmV3VHJlZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUV4dGVybmFsVXJsKHN0YXRlLCBtdXRhYmxlLCBocmVmLCBwZW5kaW5nUHVzaClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgY2FjaGU6IENhY2hlTm9kZSA9IGNyZWF0ZUVtcHR5Q2FjaGVOb2RlKClcbiAgICAgICAgICAgIGxldCBhcHBsaWVkID0gZmFsc2VcblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBwcmVmZXRjaFZhbHVlcy5zdGF0dXMgPT09IFByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cy5zdGFsZSAmJlxuICAgICAgICAgICAgICAhaXNGaXJzdFJlYWRcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAvLyBXaGVuIHdlIGhhdmUgYSBzdGFsZSBwcmVmZXRjaCBlbnRyeSwgd2Ugb25seSB3YW50IHRvIHJlLXVzZSB0aGUgbG9hZGluZyBzdGF0ZSBvZiB0aGUgcm91dGUgd2UncmUgbmF2aWdhdGluZyB0bywgdG8gc3VwcG9ydCBpbnN0YW50IGxvYWRpbmcgbmF2aWdhdGlvbnNcbiAgICAgICAgICAgICAgLy8gdGhpcyB3aWxsIHRyaWdnZXIgYSBsYXp5IGZldGNoIGZvciB0aGUgYWN0dWFsIHBhZ2UgZGF0YSBieSBudWxsaW5nIHRoZSBgcnNjYCBhbmQgYHByZWZldGNoUnNjYCB2YWx1ZXMgZm9yIHBhZ2UgZGF0YSxcbiAgICAgICAgICAgICAgLy8gd2hpbGUgY29weWluZyBvdmVyIHRoZSBgbG9hZGluZ2AgZm9yIHRoZSBzZWdtZW50IHRoYXQgY29udGFpbnMgdGhlIHBhZ2UgZGF0YS5cbiAgICAgICAgICAgICAgLy8gV2Ugb25seSBkbyB0aGlzIG9uIHN1YnNlcXVlbnQgcmVhZHMsIGFzIG90aGVyd2lzZSB0aGVyZSdkIGJlIG5vIGxvYWRpbmcgZGF0YSB0byByZS11c2UuXG5cbiAgICAgICAgICAgICAgLy8gV2Ugc2tpcCB0aGlzIGJyYW5jaCBpZiBvbmx5IHRoZSBoYXNoIGZyYWdtZW50IGhhcyBjaGFuZ2VkLCBhcyB3ZSBkb24ndCB3YW50IHRvIHRyaWdnZXIgYSBsYXp5IGZldGNoIGluIHRoYXQgY2FzZVxuICAgICAgICAgICAgICBhcHBsaWVkID0gdHJpZ2dlckxhenlGZXRjaEZvckxlYWZTZWdtZW50cyhcbiAgICAgICAgICAgICAgICBjYWNoZSxcbiAgICAgICAgICAgICAgICBjdXJyZW50Q2FjaGUsXG4gICAgICAgICAgICAgICAgZmxpZ2h0U2VnbWVudFBhdGgsXG4gICAgICAgICAgICAgICAgdHJlZVBhdGNoXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgLy8gc2luY2Ugd2UgcmUtdXNlZCB0aGUgc3RhbGUgY2FjaGUncyBsb2FkaW5nIHN0YXRlICYgcmVmcmVzaGVkIHRoZSBkYXRhLFxuICAgICAgICAgICAgICAvLyB1cGRhdGUgdGhlIGBsYXN0VXNlZFRpbWVgIHNvIHRoYXQgaXQgY2FuIGNvbnRpbnVlIHRvIGJlIHJlLXVzZWQgZm9yIHRoZSBuZXh0IDMwc1xuICAgICAgICAgICAgICBwcmVmZXRjaFZhbHVlcy5sYXN0VXNlZFRpbWUgPSBuYXZpZ2F0ZWRBdFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYXBwbGllZCA9IGFwcGx5RmxpZ2h0RGF0YShcbiAgICAgICAgICAgICAgICBuYXZpZ2F0ZWRBdCxcbiAgICAgICAgICAgICAgICBjdXJyZW50Q2FjaGUsXG4gICAgICAgICAgICAgICAgY2FjaGUsXG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZEZsaWdodERhdGEsXG4gICAgICAgICAgICAgICAgcHJlZmV0Y2hWYWx1ZXNcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBoYXJkTmF2aWdhdGUgPSBzaG91bGRIYXJkTmF2aWdhdGUoXG4gICAgICAgICAgICAgIC8vIFRPRE8tQVBQOiByZW1vdmUgJydcbiAgICAgICAgICAgICAgZmxpZ2h0U2VnbWVudFBhdGhXaXRoTGVhZGluZ0VtcHR5LFxuICAgICAgICAgICAgICBjdXJyZW50VHJlZVxuICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICBpZiAoaGFyZE5hdmlnYXRlKSB7XG4gICAgICAgICAgICAgIC8vIENvcHkgcnNjIGZvciB0aGUgcm9vdCBub2RlIG9mIHRoZSBjYWNoZS5cbiAgICAgICAgICAgICAgY2FjaGUucnNjID0gY3VycmVudENhY2hlLnJzY1xuICAgICAgICAgICAgICBjYWNoZS5wcmVmZXRjaFJzYyA9IGN1cnJlbnRDYWNoZS5wcmVmZXRjaFJzY1xuXG4gICAgICAgICAgICAgIGludmFsaWRhdGVDYWNoZUJlbG93RmxpZ2h0U2VnbWVudFBhdGgoXG4gICAgICAgICAgICAgICAgY2FjaGUsXG4gICAgICAgICAgICAgICAgY3VycmVudENhY2hlLFxuICAgICAgICAgICAgICAgIGZsaWdodFNlZ21lbnRQYXRoXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgLy8gRW5zdXJlIHRoZSBleGlzdGluZyBjYWNoZSB2YWx1ZSBpcyB1c2VkIHdoZW4gdGhlIGNhY2hlIHdhcyBub3QgaW52YWxpZGF0ZWQuXG4gICAgICAgICAgICAgIG11dGFibGUuY2FjaGUgPSBjYWNoZVxuICAgICAgICAgICAgfSBlbHNlIGlmIChhcHBsaWVkKSB7XG4gICAgICAgICAgICAgIG11dGFibGUuY2FjaGUgPSBjYWNoZVxuICAgICAgICAgICAgICAvLyBJZiB3ZSBhcHBsaWVkIHRoZSBjYWNoZSwgd2UgdXBkYXRlIHRoZSBcImN1cnJlbnQgY2FjaGVcIiB2YWx1ZSBzbyBhbnkgb3RoZXJcbiAgICAgICAgICAgICAgLy8gc2VnbWVudHMgaW4gdGhlIEZsaWdodERhdGFQYXRoIHdpbGwgYmUgYWJsZSB0byByZWZlcmVuY2UgdGhlIHVwZGF0ZWQgY2FjaGUuXG4gICAgICAgICAgICAgIGN1cnJlbnRDYWNoZSA9IGNhY2hlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoY29uc3Qgc3ViU2VnbWVudCBvZiBnZW5lcmF0ZVNlZ21lbnRzRnJvbVBhdGNoKHRyZWVQYXRjaCkpIHtcbiAgICAgICAgICAgICAgY29uc3Qgc2Nyb2xsYWJsZVNlZ21lbnRQYXRoID0gW1xuICAgICAgICAgICAgICAgIC4uLmZsaWdodFNlZ21lbnRQYXRoLFxuICAgICAgICAgICAgICAgIC4uLnN1YlNlZ21lbnQsXG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgLy8gRmlsdGVyIG91dCB0aGUgX19ERUZBVUxUX18gcGF0aHMgYXMgdGhleSBzaG91bGRuJ3QgYmUgc2Nyb2xsZWQgdG8gaW4gdGhpcyBjYXNlLlxuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgc2Nyb2xsYWJsZVNlZ21lbnRQYXRoW3Njcm9sbGFibGVTZWdtZW50UGF0aC5sZW5ndGggLSAxXSAhPT1cbiAgICAgICAgICAgICAgICBERUZBVUxUX1NFR01FTlRfS0VZXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHNjcm9sbGFibGVTZWdtZW50cy5wdXNoKHNjcm9sbGFibGVTZWdtZW50UGF0aClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGN1cnJlbnRUcmVlID0gbmV3VHJlZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG11dGFibGUucGF0Y2hlZFRyZWUgPSBjdXJyZW50VHJlZVxuICAgICAgbXV0YWJsZS5jYW5vbmljYWxVcmwgPSB1cGRhdGVkQ2Fub25pY2FsVXJsXG4gICAgICBtdXRhYmxlLnNjcm9sbGFibGVTZWdtZW50cyA9IHNjcm9sbGFibGVTZWdtZW50c1xuICAgICAgbXV0YWJsZS5oYXNoRnJhZ21lbnQgPSBoYXNoXG4gICAgICBtdXRhYmxlLnNob3VsZFNjcm9sbCA9IHNob3VsZFNjcm9sbFxuXG4gICAgICByZXR1cm4gaGFuZGxlTXV0YWJsZShzdGF0ZSwgbXV0YWJsZSlcbiAgICB9LFxuICAgICgpID0+IHN0YXRlXG4gIClcbn1cbiJdLCJuYW1lcyI6WyJoYW5kbGVFeHRlcm5hbFVybCIsIm5hdmlnYXRlUmVkdWNlciIsInN0YXRlIiwibXV0YWJsZSIsInVybCIsInBlbmRpbmdQdXNoIiwibXBhTmF2aWdhdGlvbiIsImNhbm9uaWNhbFVybCIsInNjcm9sbGFibGVTZWdtZW50cyIsInVuZGVmaW5lZCIsImhhbmRsZU11dGFibGUiLCJnZW5lcmF0ZVNlZ21lbnRzRnJvbVBhdGNoIiwiZmxpZ2h0Um91dGVyUGF0Y2giLCJzZWdtZW50cyIsInNlZ21lbnQiLCJwYXJhbGxlbFJvdXRlcyIsIk9iamVjdCIsImtleXMiLCJsZW5ndGgiLCJwYXJhbGxlbFJvdXRlS2V5IiwicGFyYWxsZWxSb3V0ZSIsImVudHJpZXMiLCJjaGlsZFNlZ21lbnQiLCJwdXNoIiwidHJpZ2dlckxhenlGZXRjaEZvckxlYWZTZWdtZW50cyIsIm5ld0NhY2hlIiwiY3VycmVudENhY2hlIiwiZmxpZ2h0U2VnbWVudFBhdGgiLCJ0cmVlUGF0Y2giLCJhcHBsaWVkUGF0Y2giLCJyc2MiLCJwcmVmZXRjaFJzYyIsImxvYWRpbmciLCJNYXAiLCJzZWdtZW50UGF0aHNUb0ZpbGwiLCJtYXAiLCJzZWdtZW50UGF0aHMiLCJjbGVhckNhY2hlTm9kZURhdGFGb3JTZWdtZW50UGF0aCIsImhhbmRsZU5hdmlnYXRpb25SZXN1bHQiLCJyZXN1bHQiLCJ0YWciLCJOYXZpZ2F0aW9uUmVzdWx0VGFnIiwiTVBBIiwibmV3VXJsIiwiZGF0YSIsIk5vT3AiLCJuZXdDYW5vbmljYWxVcmwiLCJvbGRVcmwiLCJVUkwiLCJvbmx5SGFzaENoYW5nZSIsInBhdGhuYW1lIiwic2VhcmNoIiwiaGFzaCIsInNob3VsZFNjcm9sbCIsImhhc2hGcmFnbWVudCIsIlN1Y2Nlc3MiLCJjYWNoZSIsImNhY2hlTm9kZSIsInBhdGNoZWRUcmVlIiwiZmxpZ2h0Um91dGVyU3RhdGUiLCJBc3luYyIsInRoZW4iLCJhc3luY1Jlc3VsdCIsImFjdGlvbiIsImlzRXh0ZXJuYWxVcmwiLCJuYXZpZ2F0ZVR5cGUiLCJhbGxvd0FsaWFzaW5nIiwiaHJlZiIsImNyZWF0ZUhyZWZGcm9tVXJsIiwicHJ1bmVQcmVmZXRjaENhY2hlIiwicHJlZmV0Y2hDYWNoZSIsInByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlIiwidG9TdHJpbmciLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9DTElFTlRfU0VHTUVOVF9DQUNIRSIsIm5hdmlnYXRlVXNpbmdTZWdtZW50Q2FjaGUiLCJ0cmVlIiwibmV4dFVybCIsInByZWZldGNoVmFsdWVzIiwiZ2V0T3JDcmVhdGVQcmVmZXRjaENhY2hlRW50cnkiLCJ0cmVlQXRUaW1lT2ZQcmVmZXRjaCIsInByZWZldGNoUXVldWUiLCJidW1wIiwiZmxpZ2h0RGF0YSIsImNhbm9uaWNhbFVybE92ZXJyaWRlIiwicG9zdHBvbmVkIiwibmF2aWdhdGVkQXQiLCJEYXRlIiwibm93IiwiaXNGaXJzdFJlYWQiLCJsYXN0VXNlZFRpbWUiLCJhbGlhc2VkIiwidXJsV2l0aENhbm9uaWNhbFBhdGhuYW1lIiwiaGFuZGxlQWxpYXNlZFByZWZldGNoRW50cnkiLCJ1cGRhdGVkQ2Fub25pY2FsVXJsIiwic3BsaXQiLCJjdXJyZW50VHJlZSIsIm5vcm1hbGl6ZWRGbGlnaHREYXRhIiwicGF0aFRvU2VnbWVudCIsInNlZWREYXRhIiwiaGVhZCIsImlzSGVhZFBhcnRpYWwiLCJpc1Jvb3RSZW5kZXIiLCJmbGlnaHRTZWdtZW50UGF0aFdpdGhMZWFkaW5nRW1wdHkiLCJuZXdUcmVlIiwiYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlIiwidGFzayIsInN0YXJ0UFBSTmF2aWdhdGlvbiIsInJvdXRlIiwicGF0Y2hlZFJvdXRlclN0YXRlIiwibm9kZSIsImR5bmFtaWNSZXF1ZXN0VHJlZSIsImR5bmFtaWNSZXF1ZXN0IiwiZmV0Y2hTZXJ2ZXJSZXNwb25zZSIsIm9yaWdpbiIsImxpc3RlbkZvckR5bmFtaWNSZXF1ZXN0IiwiaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0IiwiY3JlYXRlRW1wdHlDYWNoZU5vZGUiLCJhcHBsaWVkIiwic3RhdHVzIiwiUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzIiwic3RhbGUiLCJhcHBseUZsaWdodERhdGEiLCJoYXJkTmF2aWdhdGUiLCJzaG91bGRIYXJkTmF2aWdhdGUiLCJpbnZhbGlkYXRlQ2FjaGVCZWxvd0ZsaWdodFNlZ21lbnRQYXRoIiwic3ViU2VnbWVudCIsInNjcm9sbGFibGVTZWdtZW50UGF0aCIsIkRFRkFVTFRfU0VHTUVOVF9LRVkiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0lBb0NnQkEsaUJBQWlCLEVBQUE7ZUFBakJBOztJQXNJQUMsZUFBZSxFQUFBO2VBQWZBOzs7cUNBcktvQjttQ0FDRjt1REFDb0I7NkNBQ1Y7b0NBQ1Q7NkNBQ1M7b0NBT3JDOytCQUN1QjtpQ0FDRTtpQ0FDRjsyQkFDTzt5QkFDRDtnQ0FDd0I7b0NBSXJEO2tEQUMwQzs0Q0FDTjs4QkFLcEM7QUFFQSxTQUFTRCxrQkFDZEUsS0FBMkIsRUFDM0JDLE9BQWdCLEVBQ2hCQyxHQUFXLEVBQ1hDLFdBQW9CO0lBRXBCRixRQUFRRyxhQUFhLEdBQUc7SUFDeEJILFFBQVFJLFlBQVksR0FBR0g7SUFDdkJELFFBQVFFLFdBQVcsR0FBR0E7SUFDdEJGLFFBQVFLLGtCQUFrQixHQUFHQztJQUU3QixPQUFPQyxDQUFBQSxHQUFBQSxlQUFBQSxhQUFhLEVBQUNSLE9BQU9DO0FBQzlCO0FBRUEsU0FBU1EsMEJBQ1BDLGlCQUFvQztJQUVwQyxNQUFNQyxXQUFnQyxFQUFF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SCxNQUFNLEdBQUcsRUFBRSxLQUN2RGlILFNBQUFBLG1CQUFtQixFQUNuQjs0QkFDQTNILG1CQUFtQmUsSUFBSSxDQUFDMkc7d0JBQzFCO29CQUNGO2dCQUNGO2dCQUVBL0IsY0FBY1E7WUFDaEI7UUFDRjtRQUVBeEcsUUFBUXVELFdBQVcsR0FBR3lDO1FBQ3RCaEcsUUFBUUksWUFBWSxHQUFHMEY7UUFDdkI5RixRQUFRSyxrQkFBa0IsR0FBR0E7UUFDN0JMLFFBQVFtRCxZQUFZLEdBQUdGO1FBQ3ZCakQsUUFBUWtELFlBQVksR0FBR0E7UUFFdkIsT0FBTzNDLENBQUFBLEdBQUFBLGVBQUFBLGFBQWEsRUFBQ1IsT0FBT0M7SUFDOUIsR0FDQSxJQUFNRDtBQUVWIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDExNTA4LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL3NlcnZlci1wYXRjaC1yZWR1Y2VyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUhyZWZGcm9tVXJsIH0gZnJvbSAnLi4vY3JlYXRlLWhyZWYtZnJvbS11cmwnXG5pbXBvcnQgeyBhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUgfSBmcm9tICcuLi9hcHBseS1yb3V0ZXItc3RhdGUtcGF0Y2gtdG8tdHJlZSdcbmltcG9ydCB7IGlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dCB9IGZyb20gJy4uL2lzLW5hdmlnYXRpbmctdG8tbmV3LXJvb3QtbGF5b3V0J1xuaW1wb3J0IHR5cGUge1xuICBTZXJ2ZXJQYXRjaEFjdGlvbixcbiAgUmVkdWNlclN0YXRlLFxuICBSZWFkb25seVJlZHVjZXJTdGF0ZSxcbiAgTXV0YWJsZSxcbn0gZnJvbSAnLi4vcm91dGVyLXJlZHVjZXItdHlwZXMnXG5pbXBvcnQgeyBoYW5kbGVFeHRlcm5hbFVybCB9IGZyb20gJy4vbmF2aWdhdGUtcmVkdWNlcidcbmltcG9ydCB7IGFwcGx5RmxpZ2h0RGF0YSB9IGZyb20gJy4uL2FwcGx5LWZsaWdodC1kYXRhJ1xuaW1wb3J0IHsgaGFuZGxlTXV0YWJsZSB9IGZyb20gJy4uL2hhbmRsZS1tdXRhYmxlJ1xuaW1wb3J0IHR5cGUgeyBDYWNoZU5vZGUgfSBmcm9tICcuLi8uLi8uLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB7IGNyZWF0ZUVtcHR5Q2FjaGVOb2RlIH0gZnJvbSAnLi4vLi4vYXBwLXJvdXRlcidcblxuZXhwb3J0IGZ1bmN0aW9uIHNlcnZlclBhdGNoUmVkdWNlcihcbiAgc3RhdGU6IFJlYWRvbmx5UmVkdWNlclN0YXRlLFxuICBhY3Rpb246IFNlcnZlclBhdGNoQWN0aW9uXG4pOiBSZWR1Y2VyU3RhdGUge1xuICBjb25zdCB7XG4gICAgc2VydmVyUmVzcG9uc2U6IHsgZmxpZ2h0RGF0YSwgY2Fub25pY2FsVXJsOiBjYW5vbmljYWxVcmxPdmVycmlkZSB9LFxuICAgIG5hdmlnYXRlZEF0LFxuICB9ID0gYWN0aW9uXG5cbiAgY29uc3QgbXV0YWJsZTogTXV0YWJsZSA9IHt9XG5cbiAgbXV0YWJsZS5wcmVzZXJ2ZUN1c3RvbUhpc3RvcnlTdGF0ZSA9IGZhbHNlXG5cbiAgLy8gSGFuZGxlIGNhc2Ugd2hlbiBuYXZpZ2F0aW5nIHRvIHBhZ2UgaW4gYHBhZ2VzYCBmcm9tIGBhcHBgXG4gIGlmICh0eXBlb2YgZmxpZ2h0RGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gaGFuZGxlRXh0ZXJuYWxVcmwoXG4gICAgICBzdGF0ZSxcbiAgICAgIG11dGFibGUsXG4gICAgICBmbGlnaHREYXRhLFxuICAgICAgc3RhdGUucHVzaFJlZi5wZW5kaW5nUHVzaFxuICAgIClcbiAgfVxuXG4gIGxldCBjdXJyZW50VHJlZSA9IHN0YXRlLnRyZWVcbiAgbGV0IGN1cnJlbnRDYWNoZSA9IHN0YXRlLmNhY2hlXG5cbiAgZm9yIChjb25zdCBub3JtYWxpemVkRmxpZ2h0RGF0YSBvZiBmbGlnaHREYXRhKSB7XG4gICAgY29uc3QgeyBzZWdtZW50UGF0aDogZmxpZ2h0U2VnbWVudFBhdGgsIHRyZWU6IHRyZWVQYXRjaCB9ID1cbiAgICAgIG5vcm1hbGl6ZWRGbGlnaHREYXRhXG5cbiAgICBjb25zdCBuZXdUcmVlID0gYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlKFxuICAgICAgLy8gVE9ETy1BUFA6IHJlbW92ZSAnJ1xuICAgICAgWycnLCAuLi5mbGlnaHRTZWdtZW50UGF0aF0sXG4gICAgICBjdXJyZW50VHJlZSxcbiAgICAgIHRyZWVQYXRjaCxcbiAgICAgIHN0YXRlLmNhbm9uaWNhbFVybFxuICAgIClcblxuICAgIC8vIGBhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWVgIHJldHVybnMgYG51bGxgIHdoZW4gaXQgZGV0ZXJtaW5lZCB0aGF0IHRoZSBzZXJ2ZXIgcmVzcG9uc2UgaXMgbm90IGFwcGxpY2FibGUgdG8gdGhlIGN1cnJlbnQgdHJlZS5cbiAgICAvLyBJbiBvdGhlciB3b3JkcywgdGhlIHNlcnZlciByZXNwb25kZWQgd2l0aCBhIHRyZWUgdGhhdCBkb2Vzbid0IG1hdGNoIHdoYXQgdGhlIGNsaWVudCBpcyBjdXJyZW50bHkgcmVuZGVyaW5nLlxuICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB0aGUgc2VydmVyIHBhdGNoIGFjdGlvbiB0b29rIGxvbmdlciB0byByZXNvbHZlIHRoYW4gYSBzdWJzZXF1ZW50IG5hdmlnYXRpb24gd2hpY2ggd291bGQgaGF2ZSBjaGFuZ2VkIHRoZSB0cmVlLlxuICAgIC8vIFByZXZpb3VzbHkgdGhpcyBjYXNlIHRyaWdnZXJlZCBhbiBNUEEgbmF2aWdhdGlvbiBidXQgaXQgc2hvdWxkIGJlIHNhZmUgdG8gc2ltcGx5IGRpc2NhcmQgdGhlIHNlcnZlciByZXNwb25zZSByYXRoZXIgdGhhbiBmb3JjaW5nXG4gICAgLy8gdGhlIGVudGlyZSBwYWdlIHRvIHJlbG9hZC5cbiAgICBpZiAobmV3VHJlZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHN0YXRlXG4gICAgfVxuXG4gICAgaWYgKGlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dChjdXJyZW50VHJlZSwgbmV3VHJlZSkpIHtcbiAgICAgIHJldHVybiBoYW5kbGVFeHRlcm5hbFVybChcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIG11dGFibGUsXG4gICAgICAgIHN0YXRlLmNhbm9uaWNhbFVybCxcbiAgICAgICAgc3RhdGUucHVzaFJlZi5wZW5kaW5nUHVzaFxuICAgICAgKVxuICAgIH1cblxuICAgIGNvbnN0IGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZiA9IGNhbm9uaWNhbFVybE92ZXJyaWRlXG4gICAgICA/IGNyZWF0ZUhyZWZGcm9tVXJsKGNhbm9uaWNhbFVybE92ZXJyaWRlKVxuICAgICAgOiB1bmRlZmluZWRcblxuICAgIGlmIChjYW5vbmljYWxVcmxPdmVycmlkZUhyZWYpIHtcbiAgICAgIG11dGFibGUuY2Fub25pY2FsVXJsID0gY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmXG4gICAgfVxuXG4gICAgY29uc3QgY2FjaGU6IENhY2hlTm9kZSA9IGNyZWF0ZUVtcHR5Q2FjaGVOb2RlKClcbiAgICBhcHBseUZsaWdodERhdGEobmF2aWdhdGVkQXQsIGN1cnJlbnRDYWNoZSwgY2FjaGUsIG5vcm1hbGl6ZWRGbGlnaHREYXRhKVxuXG4gICAgbXV0YWJsZS5wYXRjaGVkVHJlZSA9IG5ld1RyZWVcbiAgICBtdXRhYmxlLmNhY2hlID0gY2FjaGVcblxuICAgIGN1cnJlbnRDYWNoZSA9IGNhY2hlXG4gICAgY3VycmVudFRyZWUgPSBuZXdUcmVlXG4gIH1cblxuICByZXR1cm4gaGFuZGxlTXV0YWJsZShzdGF0ZSwgbXV0YWJsZSlcbn1cbiJdLCJuYW1lcyI6WyJzZXJ2ZXJQYXRjaFJlZHVjZXIiLCJzdGF0ZSIsImFjdGlvbiIsInNlcnZlclJlc3BvbnNlIiwiZmxpZ2h0RGF0YSIsImNhbm9uaWNhbFVybCIsImNhbm9uaWNhbFVybE92ZXJyaWRlIiwibmF2aWdhdGVkQXQiLCJtdXRhYmxlIiwicHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGUiLCJoYW5kbGVFeHRlcm5hbFVybCIsInB1c2hSZWYiLCJwZW5kaW5nUHVzaCIsImN1cnJlbnRUcmVlIiwidHJlZSIsImN1cnJlbnRDYWNoZSIsImNhY2hlIiwibm9ybWFsaXplZEZsaWdodERhdGEiLCJzZWdtZW50UGF0aCIsImZsaWdodFNlZ21lbnRQYXRoIiwidHJlZVBhdGNoIiwibmV3VHJlZSIsImFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZSIsImlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dCIsImNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZiIsImNyZWF0ZUhyZWZGcm9tVXJsIiwidW5kZWZpbmVkIiwiY3JlYXRlRW1wdHlDYWNoZU5vZGUiLCJhcHBseUZsaWdodERhdGEiLCJwYXRjaGVkVHJlZSIsImhhbmRsZU11dGFibGUiXSwibWFwcGluZ3MiOiI7OzsrQkFlZ0JBLHNCQUFBQTs7O2VBQUFBOzs7bUNBZmtCOzZDQUNVOzZDQUNBO2lDQU9WO2lDQUNGOytCQUNGOzJCQUVPO0FBRTlCLFNBQVNBLG1CQUNkQyxLQUEyQixFQUMzQkMsTUFBeUI7SUFFekIsTUFBTSxFQUNKQyxnQkFBZ0IsRUFBRUMsVUFBVSxFQUFFQyxjQUFjQyxvQkFBb0IsRUFBRSxFQUNsRUMsV0FBVyxFQUNaLEdBQUdMO0lBRUosTUFBTU0sVUFBbUIsQ0FBQztJQUUxQkEsUUFBUUMsMEJBQTBCLEdBQUc7SUFFckMsNERBQTREO0lBQzVELElBQUksT0FBT0wsZUFBZSxVQUFVO1FBQ2xDLE9BQU9NLENBQUFBLEdBQUFBLGlCQUFBQSxpQkFBaUIsRUFDdEJULE9BQ0FPLFNBQ0FKLFlBQ0FILE1BQU1VLE9BQU8sQ0FBQ0MsV0FBVztJQUU3QjtJQUVBLElBQUlDLGNBQWNaLE1BQU1hLElBQUk7SUFDNUIsSUFBSUMsZUFBZWQsTUFBTWUsS0FBSztJQUU5QixLQUFLLE1BQU1DLHdCQUF3QmIsV0FBWTtRQUM3QyxNQUFNLEVBQUVjLGFBQWFDLGlCQUFpQixFQUFFTCxNQUFNTSxTQUFTLEVBQUUsR0FDdkRIO1FBRUYsTUFBTUksVUFBVUMsQ0FBQUEsR0FBQUEsNkJBQUFBLDJCQUEyQixFQUN6QyxBQUNBLHNCQURzQjtZQUNyQjtlQUFPSDtTQUFrQixFQUMxQk4sYUFDQU8sV0FDQW5CLE1BQU1JLFlBQVk7UUFHcEIsa0lBQWtJO1FBQ2xJLDhHQUE4RztRQUM5RyxvSUFBb0k7UUFDcEksbUlBQW1JO1FBQ25JLDZCQUE2QjtRQUM3QixJQUFJZ0IsWUFBWSxNQUFNO1lBQ3BCLE9BQU9wQjtRQUNUO1FBRUEsSUFBSXNCLENBQUFBLEdBQUFBLDZCQUFBQSwyQkFBMkIsRUFBQ1YsYUFBYVEsVUFBVTtZQUNyRCxPQUFPWCxDQUFBQSxHQUFBQSxpQkFBQUEsaUJBQWlCLEVBQ3RCVCxPQUNBTyxTQUNBUCxNQUFNSSxZQUFZLEVBQ2xCSixNQUFNVSxPQUFPLENBQUNDLFdBQVc7UUFFN0I7UUFFQSxNQUFNWSwyQkFBMkJsQix1QkFDN0JtQixDQUFBQSxHQUFBQSxtQkFBQUEsaUJBQWlCLEVBQUNuQix3QkFDbEJvQjtRQUVKLElBQUlGLDBCQUEwQjtZQUM1QmhCLFFBQVFILFlBQVksR0FBR21CO1FBQ3pCO1FBRUEsTUFBTVIsUUFBbUJXLENBQUFBLEdBQUFBLFdBQUFBLG9CQUFvQjtRQUM3Q0MsQ0FBQUEsR0FBQUEsaUJBQUFBLGVBQWUsRUFBQ3JCLGFBQWFRLGNBQWNDLE9BQU9DO1FBRWxEVCxRQUFRcUIsV0FBVyxHQUFHUjtRQUN0QmIsUUFBUVEsS0FBSyxHQUFHQTtRQUVoQkQsZUFBZUM7UUFDZkgsY0FBY1E7SUFDaEI7SUFFQSxPQUFPUyxDQUFBQSxHQUFBQSxlQUFBQSxhQUFhLEVBQUM3QixPQUFPTztBQUM5QiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxMTU3NywgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yZWR1Y2Vycy9yZXN0b3JlLXJlZHVjZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlSHJlZkZyb21VcmwgfSBmcm9tICcuLi9jcmVhdGUtaHJlZi1mcm9tLXVybCdcbmltcG9ydCB0eXBlIHtcbiAgUmVhZG9ubHlSZWR1Y2VyU3RhdGUsXG4gIFJlZHVjZXJTdGF0ZSxcbiAgUmVzdG9yZUFjdGlvbixcbn0gZnJvbSAnLi4vcm91dGVyLXJlZHVjZXItdHlwZXMnXG5pbXBvcnQgeyBleHRyYWN0UGF0aEZyb21GbGlnaHRSb3V0ZXJTdGF0ZSB9IGZyb20gJy4uL2NvbXB1dGUtY2hhbmdlZC1wYXRoJ1xuaW1wb3J0IHsgdXBkYXRlQ2FjaGVOb2RlT25Qb3BzdGF0ZVJlc3RvcmF0aW9uIH0gZnJvbSAnLi4vcHByLW5hdmlnYXRpb25zJ1xuXG5leHBvcnQgZnVuY3Rpb24gcmVzdG9yZVJlZHVjZXIoXG4gIHN0YXRlOiBSZWFkb25seVJlZHVjZXJTdGF0ZSxcbiAgYWN0aW9uOiBSZXN0b3JlQWN0aW9uXG4pOiBSZWR1Y2VyU3RhdGUge1xuICBjb25zdCB7IHVybCwgdHJlZSB9ID0gYWN0aW9uXG4gIGNvbnN0IGhyZWYgPSBjcmVhdGVIcmVmRnJvbVVybCh1cmwpXG4gIC8vIFRoaXMgYWN0aW9uIGlzIHVzZWQgdG8gcmVzdG9yZSB0aGUgcm91dGVyIHN0YXRlIGZyb20gdGhlIGhpc3Rvcnkgc3RhdGUuXG4gIC8vIEhvd2V2ZXIsIGl0J3MgcG9zc2libGUgdGhhdCB0aGUgaGlzdG9yeSBzdGF0ZSBubyBsb25nZXIgY29udGFpbnMgdGhlIGBGbGlnaHRSb3V0ZXJTdGF0ZWAuXG4gIC8vIFdlIHdpbGwgY29weSBvdmVyIHRoZSBpbnRlcm5hbCBzdGF0ZSBvbiBwdXNoU3RhdGUvcmVwbGFjZVN0YXRlIGV2ZW50cywgYnV0IGlmIGEgaGlzdG9yeSBlbnRyeVxuICAvLyBvY2N1cnJlZCBiZWZvcmUgaHlkcmF0aW9uLCBvciBpZiB0aGUgdXNlciBuYXZpZ2F0ZWQgdG8gYSBoYXNoIHVzaW5nIGEgcmVndWxhciBhbmNob3IgbGluayxcbiAgLy8gdGhlIGhpc3Rvcnkgc3RhdGUgd2lsbCBub3QgY29udGFpbiB0aGUgYEZsaWdodFJvdXRlclN0YXRlYC5cbiAgLy8gSW4gdGhpcyBjYXNlLCB3ZSdsbCBjb250aW51ZSB0byB1c2UgdGhlIGV4aXN0aW5nIHRyZWUgc28gdGhlIHJvdXRlciBkb2Vzbid0IGdldCBpbnRvIGFuIGludmFsaWQgc3RhdGUuXG4gIGNvbnN0IHRyZWVUb1Jlc3RvcmUgPSB0cmVlIHx8IHN0YXRlLnRyZWVcblxuICBjb25zdCBvbGRDYWNoZSA9IHN0YXRlLmNhY2hlXG4gIGNvbnN0IG5ld0NhY2hlID0gcHJvY2Vzcy5lbnYuX19ORVhUX1BQUlxuICAgID8gLy8gV2hlbiBQUFIgaXMgZW5hYmxlZCwgd2UgdXBkYXRlIHRoZSBjYWNoZSB0byBkcm9wIHRoZSBwcmVmZXRjaFxuICAgICAgLy8gZGF0YSBmb3IgYW55IHNlZ21lbnQgd2hvc2UgZHluYW1pYyBkYXRhIHdhcyBhbHJlYWR5IHJlY2VpdmVkLiBUaGlzXG4gICAgICAvLyBwcmV2ZW50cyBhbiB1bm5lY2Vzc2FyeSBmbGFzaCBiYWNrIHRvIFBQUiBzdGF0ZSBkdXJpbmcgYVxuICAgICAgLy8gYmFjay9mb3J3YXJkIG5hdmlnYXRpb24uXG4gICAgICB1cGRhdGVDYWNoZU5vZGVPblBvcHN0YXRlUmVzdG9yYXRpb24ob2xkQ2FjaGUsIHRyZWVUb1Jlc3RvcmUpXG4gICAgOiBvbGRDYWNoZVxuXG4gIHJldHVybiB7XG4gICAgLy8gU2V0IGNhbm9uaWNhbCB1cmxcbiAgICBjYW5vbmljYWxVcmw6IGhyZWYsXG4gICAgcHVzaFJlZjoge1xuICAgICAgcGVuZGluZ1B1c2g6IGZhbHNlLFxuICAgICAgbXBhTmF2aWdhdGlvbjogZmFsc2UsXG4gICAgICAvLyBFbnN1cmVzIHRoYXQgdGhlIGN1c3RvbSBoaXN0b3J5IHN0YXRlIHRoYXQgd2FzIHNldCBpcyBwcmVzZXJ2ZWQgd2hlbiBhcHBseWluZyB0aGlzIHVwZGF0ZS5cbiAgICAgIHByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlOiB0cnVlLFxuICAgIH0sXG4gICAgZm9jdXNBbmRTY3JvbGxSZWY6IHN0YXRlLmZvY3VzQW5kU2Nyb2xsUmVmLFxuICAgIGNhY2hlOiBuZXdDYWNoZSxcbiAgICBwcmVmZXRjaENhY2hlOiBzdGF0ZS5wcmVmZXRjaENhY2hlLFxuICAgIC8vIFJlc3RvcmUgcHJvdmlkZWQgdHJlZVxuICAgIHRyZWU6IHRyZWVUb1Jlc3RvcmUsXG4gICAgbmV4dFVybDogZXh0cmFjdFBhdGhGcm9tRmxpZ2h0Um91dGVyU3RhdGUodHJlZVRvUmVzdG9yZSkgPz8gdXJsLnBhdGhuYW1lLFxuICB9XG59XG4iXSwibmFtZXMiOlsicmVzdG9yZVJlZHVjZXIiLCJzdGF0ZSIsImFjdGlvbiIsInVybCIsInRyZWUiLCJocmVmIiwiY3JlYXRlSHJlZkZyb21VcmwiLCJ0cmVlVG9SZXN0b3JlIiwib2xkQ2FjaGUiLCJjYWNoZSIsIm5ld0NhY2hlIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9QUFIiLCJ1cGRhdGVDYWNoZU5vZGVPblBvcHN0YXRlUmVzdG9yYXRpb24iLCJleHRyYWN0UGF0aEZyb21GbGlnaHRSb3V0ZXJTdGF0ZSIsImNhbm9uaWNhbFVybCIsInB1c2hSZWYiLCJwZW5kaW5nUHVzaCIsIm1wYU5hdmlnYXRpb24iLCJwcmVzZXJ2ZUN1c3RvbUhpc3RvcnlTdGF0ZSIsImZvY3VzQW5kU2Nyb2xsUmVmIiwicHJlZmV0Y2hDYWNoZSIsIm5leHRVcmwiLCJwYXRobmFtZSJdLCJtYXBwaW5ncyI6Ijs7OytCQVNnQkEsa0JBQUFBOzs7ZUFBQUE7OzttQ0FUa0I7b0NBTWU7Z0NBQ0k7QUFFOUMsU0FBU0EsZUFDZEMsS0FBMkIsRUFDM0JDLE1BQXFCO0lBRXJCLE1BQU0sRUFBRUMsR0FBRyxFQUFFQyxJQUFJLEVBQUUsR0FBR0Y7SUFDdEIsTUFBTUcsT0FBT0MsQ0FBQUEsR0FBQUEsbUJBQUFBLGlCQUFpQixFQUFDSDtJQUMvQiwwRUFBMEU7SUFDMUUsNEZBQTRGO0lBQzVGLGdHQUFnRztJQUNoRyw2RkFBNkY7SUFDN0YsOERBQThEO0lBQzlELHlHQUF5RztJQUN6RyxNQUFNSSxnQkFBZ0JILFFBQVFILE1BQU1HLElBQUk7SUFFeEMsTUFBTUksV0FBV1AsTUFBTVEsS0FBSztJQUM1QixNQUFNQyxXQUFXQyxRQUFRQyxHQUFHLENBQUNDLFVBQVUsR0FFbkMsYUFDQSx3REFEcUUsR0FDVjtJQUMzRCwyQkFBMkI7SUFDM0JDLElBQUFBLHNCQUNBTiw4QkFEb0MsRUFBQ0EsVUFBVUQ7UUFpQnhDUTtJQWRYLE9BQU87UUFDTCxvQkFBb0I7UUFDcEJDLGNBQWNYO1FBQ2RZLFNBQVM7WUFDUEMsYUFBYTtZQUNiQyxlQUFlO1lBQ2YsNkZBQTZGO1lBQzdGQyw0QkFBNEI7UUFDOUI7UUFDQUMsbUJBQW1CcEIsTUFBTW9CLGlCQUFpQjtRQUMxQ1osT0FBT0M7UUFDUFksZUFBZXJCLE1BQU1xQixhQUFhO1FBQ2xDLHdCQUF3QjtRQUN4QmxCLE1BQU1HO1FBQ05nQixTQUFTUixDQUFBQSxvQ0FBQUEsQ0FBQUEsR0FBQUEsb0JBQUFBLGdDQUFnQyxFQUFDUixjQUFBQSxLQUFBQSxPQUFqQ1Esb0NBQW1EWixJQUFJcUIsUUFBUTtJQUMxRTtBQUNGIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDExNjM0LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2hhbmRsZS1zZWdtZW50LW1pc21hdGNoLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgRmxpZ2h0Um91dGVyU3RhdGUgfSBmcm9tICcuLi8uLi8uLi9zZXJ2ZXIvYXBwLXJlbmRlci90eXBlcydcbmltcG9ydCB7IGhhbmRsZUV4dGVybmFsVXJsIH0gZnJvbSAnLi9yZWR1Y2Vycy9uYXZpZ2F0ZS1yZWR1Y2VyJ1xuaW1wb3J0IHR5cGUge1xuICBSZWFkb25seVJlZHVjZXJTdGF0ZSxcbiAgUmVkdWNlckFjdGlvbnMsXG59IGZyb20gJy4vcm91dGVyLXJlZHVjZXItdHlwZXMnXG5cbi8qKlxuICogSGFuZGxlcyB0aGUgY2FzZSB3aGVyZSB0aGUgY2xpZW50IHJvdXRlciBhdHRlbXB0ZWQgdG8gcGF0Y2ggdGhlIHRyZWUgYnV0LCBkdWUgdG8gYSBtaXNtYXRjaCwgdGhlIHBhdGNoIGZhaWxlZC5cbiAqIFRoaXMgd2lsbCBwZXJmb3JtIGFuIE1QQSBuYXZpZ2F0aW9uIHRvIHJldHVybiB0aGUgcm91dGVyIHRvIGEgdmFsaWQgc3RhdGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYW5kbGVTZWdtZW50TWlzbWF0Y2goXG4gIHN0YXRlOiBSZWFkb25seVJlZHVjZXJTdGF0ZSxcbiAgYWN0aW9uOiBSZWR1Y2VyQWN0aW9ucyxcbiAgdHJlZVBhdGNoOiBGbGlnaHRSb3V0ZXJTdGF0ZVxuKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgICdQZXJmb3JtaW5nIGhhcmQgbmF2aWdhdGlvbiBiZWNhdXNlIHlvdXIgYXBwbGljYXRpb24gZXhwZXJpZW5jZWQgYW4gdW5yZWNvdmVyYWJsZSBlcnJvci4gSWYgdGhpcyBrZWVwcyBvY2N1cnJpbmcsIHBsZWFzZSBmaWxlIGEgTmV4dC5qcyBpc3N1ZS5cXG5cXG4nICtcbiAgICAgICAgJ1JlYXNvbjogU2VnbWVudCBtaXNtYXRjaFxcbicgK1xuICAgICAgICBgTGFzdCBBY3Rpb246ICR7YWN0aW9uLnR5cGV9XFxuXFxuYCArXG4gICAgICAgIGBDdXJyZW50IFRyZWU6ICR7SlNPTi5zdHJpbmdpZnkoc3RhdGUudHJlZSl9XFxuXFxuYCArXG4gICAgICAgIGBUcmVlIFBhdGNoIFBheWxvYWQ6ICR7SlNPTi5zdHJpbmdpZnkodHJlZVBhdGNoKX1gXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGhhbmRsZUV4dGVybmFsVXJsKHN0YXRlLCB7fSwgc3RhdGUuY2Fub25pY2FsVXJsLCB0cnVlKVxufVxuIl0sIm5hbWVzIjpbImhhbmRsZVNlZ21lbnRNaXNtYXRjaCIsInN0YXRlIiwiYWN0aW9uIiwidHJlZVBhdGNoIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiY29uc29sZSIsIndhcm4iLCJ0eXBlIiwiSlNPTiIsInN0cmluZ2lmeSIsInRyZWUiLCJoYW5kbGVFeHRlcm5hbFVybCIsImNhbm9uaWNhbFVybCJdLCJtYXBwaW5ncyI6Ijs7OytCQVdnQkEseUJBQUFBOzs7ZUFBQUE7OztpQ0FWa0I7QUFVM0IsU0FBU0Esc0JBQ2RDLEtBQTJCLEVBQzNCQyxNQUFzQixFQUN0QkMsU0FBNEI7SUFFNUIsSUFBSUMsUUFBUUMsR0FBRyxDQUFDQyxRQUFRLEtBQUssV0FBZTtRQUMxQ0MsUUFBUUMsSUFBSSxDQUNWLHNKQUNFLCtCQUNBLENBQUMsa0JBQWVOLE9BQU9PLElBQUksR0FBQyxNQUFJLElBQ2hDLENBQUMsbUJBQWdCQyxLQUFLQyxTQUFTLENBQUNWLE1BQU1XLElBQUksSUFBRSxNQUFJLElBQ2hELENBQUMseUJBQXNCRixLQUFLQyxTQUFTLENBQUNSLFVBQVc7SUFFdkQ7SUFFQSxPQUFPVSxDQUFBQSxHQUFBQSxpQkFBQUEsaUJBQWlCLEVBQUNaLE9BQU8sQ0FBQyxHQUFHQSxNQUFNYSxZQUFZLEVBQUU7QUFDMUQiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTE2NjMsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvaGFzLWludGVyY2VwdGlvbi1yb3V0ZS1pbi1jdXJyZW50LXRyZWUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBGbGlnaHRSb3V0ZXJTdGF0ZSB9IGZyb20gJy4uLy4uLy4uLy4uL3NlcnZlci9hcHAtcmVuZGVyL3R5cGVzJ1xuaW1wb3J0IHsgaXNJbnRlcmNlcHRpb25Sb3V0ZUFwcFBhdGggfSBmcm9tICcuLi8uLi8uLi8uLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9pbnRlcmNlcHRpb24tcm91dGVzJ1xuXG5leHBvcnQgZnVuY3Rpb24gaGFzSW50ZXJjZXB0aW9uUm91dGVJbkN1cnJlbnRUcmVlKFtcbiAgc2VnbWVudCxcbiAgcGFyYWxsZWxSb3V0ZXMsXG5dOiBGbGlnaHRSb3V0ZXJTdGF0ZSk6IGJvb2xlYW4ge1xuICAvLyBJZiB3ZSBoYXZlIGEgZHluYW1pYyBzZWdtZW50LCBpdCdzIG1hcmtlZCBhcyBhbiBpbnRlcmNlcHRpb24gcm91dGUgYnkgdGhlIHByZXNlbmNlIG9mIHRoZSBgaWAgc3VmZml4LlxuICBpZiAoQXJyYXkuaXNBcnJheShzZWdtZW50KSAmJiAoc2VnbWVudFsyXSA9PT0gJ2RpJyB8fCBzZWdtZW50WzJdID09PSAnY2knKSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvLyBJZiBzZWdtZW50IGlzIG5vdCBhbiBhcnJheSwgYXBwbHkgdGhlIGV4aXN0aW5nIHN0cmluZy1iYXNlZCBjaGVja1xuICBpZiAodHlwZW9mIHNlZ21lbnQgPT09ICdzdHJpbmcnICYmIGlzSW50ZXJjZXB0aW9uUm91dGVBcHBQYXRoKHNlZ21lbnQpKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8vIEl0ZXJhdGUgdGhyb3VnaCBwYXJhbGxlbFJvdXRlcyBpZiB0aGV5IGV4aXN0XG4gIGlmIChwYXJhbGxlbFJvdXRlcykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFsbGVsUm91dGVzKSB7XG4gICAgICBpZiAoaGFzSW50ZXJjZXB0aW9uUm91dGVJbkN1cnJlbnRUcmVlKHBhcmFsbGVsUm91dGVzW2tleV0pKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59XG4iXSwibmFtZXMiOlsiaGFzSW50ZXJjZXB0aW9uUm91dGVJbkN1cnJlbnRUcmVlIiwic2VnbWVudCIsInBhcmFsbGVsUm91dGVzIiwiQXJyYXkiLCJpc0FycmF5IiwiaXNJbnRlcmNlcHRpb25Sb3V0ZUFwcFBhdGgiLCJrZXkiXSwibWFwcGluZ3MiOiI7OzsrQkFHZ0JBLHFDQUFBQTs7O2VBQUFBOzs7b0NBRjJCO0FBRXBDLFNBQVNBLGtDQUFrQyxLQUc5QjtJQUg4QixJQUFBLENBQ2hEQyxTQUNBQyxlQUNrQixHQUg4QjtJQUloRCx3R0FBd0c7SUFDeEcsSUFBSUMsTUFBTUMsT0FBTyxDQUFDSCxZQUFhQSxDQUFBQSxPQUFPLENBQUMsRUFBRSxLQUFLLFFBQVFBLE9BQU8sQ0FBQyxFQUFFLEtBQUssSUFBRyxHQUFJO1FBQzFFLE9BQU87SUFDVDtJQUVBLG9FQUFvRTtJQUNwRSxJQUFJLE9BQU9BLFlBQVksWUFBWUksQ0FBQUEsR0FBQUEsb0JBQUFBLDBCQUEwQixFQUFDSixVQUFVO1FBQ3RFLE9BQU87SUFDVDtJQUVBLCtDQUErQztJQUMvQyxJQUFJQyxnQkFBZ0I7UUFDbEIsSUFBSyxNQUFNSSxPQUFPSixlQUFnQjtZQUNoQyxJQUFJRixrQ0FBa0NFLGNBQWMsQ0FBQ0ksSUFBSSxHQUFHO2dCQUMxRCxPQUFPO1lBQ1Q7UUFDRjtJQUNGO0lBRUEsT0FBTztBQUNUIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDExNzA2LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL3JlZnJlc2gtcmVkdWNlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBmZXRjaFNlcnZlclJlc3BvbnNlIH0gZnJvbSAnLi4vZmV0Y2gtc2VydmVyLXJlc3BvbnNlJ1xuaW1wb3J0IHsgY3JlYXRlSHJlZkZyb21VcmwgfSBmcm9tICcuLi9jcmVhdGUtaHJlZi1mcm9tLXVybCdcbmltcG9ydCB7IGFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZSB9IGZyb20gJy4uL2FwcGx5LXJvdXRlci1zdGF0ZS1wYXRjaC10by10cmVlJ1xuaW1wb3J0IHsgaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0IH0gZnJvbSAnLi4vaXMtbmF2aWdhdGluZy10by1uZXctcm9vdC1sYXlvdXQnXG5pbXBvcnQgdHlwZSB7XG4gIE11dGFibGUsXG4gIFJlYWRvbmx5UmVkdWNlclN0YXRlLFxuICBSZWR1Y2VyU3RhdGUsXG4gIFJlZnJlc2hBY3Rpb24sXG59IGZyb20gJy4uL3JvdXRlci1yZWR1Y2VyLXR5cGVzJ1xuaW1wb3J0IHsgaGFuZGxlRXh0ZXJuYWxVcmwgfSBmcm9tICcuL25hdmlnYXRlLXJlZHVjZXInXG5pbXBvcnQgeyBoYW5kbGVNdXRhYmxlIH0gZnJvbSAnLi4vaGFuZGxlLW11dGFibGUnXG5pbXBvcnQgdHlwZSB7IENhY2hlTm9kZSB9IGZyb20gJy4uLy4uLy4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHsgZmlsbExhenlJdGVtc1RpbGxMZWFmV2l0aEhlYWQgfSBmcm9tICcuLi9maWxsLWxhenktaXRlbXMtdGlsbC1sZWFmLXdpdGgtaGVhZCdcbmltcG9ydCB7IGNyZWF0ZUVtcHR5Q2FjaGVOb2RlIH0gZnJvbSAnLi4vLi4vYXBwLXJvdXRlcidcbmltcG9ydCB7IGhhbmRsZVNlZ21lbnRNaXNtYXRjaCB9IGZyb20gJy4uL2hhbmRsZS1zZWdtZW50LW1pc21hdGNoJ1xuaW1wb3J0IHsgaGFzSW50ZXJjZXB0aW9uUm91dGVJbkN1cnJlbnRUcmVlIH0gZnJvbSAnLi9oYXMtaW50ZXJjZXB0aW9uLXJvdXRlLWluLWN1cnJlbnQtdHJlZSdcbmltcG9ydCB7IHJlZnJlc2hJbmFjdGl2ZVBhcmFsbGVsU2VnbWVudHMgfSBmcm9tICcuLi9yZWZldGNoLWluYWN0aXZlLXBhcmFsbGVsLXNlZ21lbnRzJ1xuaW1wb3J0IHsgcmV2YWxpZGF0ZUVudGlyZUNhY2hlIH0gZnJvbSAnLi4vLi4vc2VnbWVudC1jYWNoZSdcblxuZXhwb3J0IGZ1bmN0aW9uIHJlZnJlc2hSZWR1Y2VyKFxuICBzdGF0ZTogUmVhZG9ubHlSZWR1Y2VyU3RhdGUsXG4gIGFjdGlvbjogUmVmcmVzaEFjdGlvblxuKTogUmVkdWNlclN0YXRlIHtcbiAgY29uc3QgeyBvcmlnaW4gfSA9IGFjdGlvblxuICBjb25zdCBtdXRhYmxlOiBNdXRhYmxlID0ge31cbiAgY29uc3QgaHJlZiA9IHN0YXRlLmNhbm9uaWNhbFVybFxuXG4gIGxldCBjdXJyZW50VHJlZSA9IHN0YXRlLnRyZWVcblxuICBtdXRhYmxlLnByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlID0gZmFsc2VcblxuICBjb25zdCBjYWNoZTogQ2FjaGVOb2RlID0gY3JlYXRlRW1wdHlDYWNoZU5vZGUoKVxuXG4gIC8vIElmIHRoZSBjdXJyZW50IHRyZWUgd2FzIGludGVyY2VwdGVkLCB0aGUgbmV4dFVybCBzaG91bGQgYmUgaW5jbHVkZWQgaW4gdGhlIHJlcXVlc3QuXG4gIC8vIFRoaXMgaXMgdG8gZW5zdXJlIHRoYXQgdGhlIHJlZnJlc2ggcmVxdWVzdCBkb2Vzbid0IGdldCBpbnRlcmNlcHRlZCwgYWNjaWRlbnRhbGx5IHRyaWdnZXJpbmcgdGhlIGludGVyY2VwdGlvbiByb3V0ZS5cbiAgY29uc3QgaW5jbHVkZU5leHRVcmwgPSBoYXNJbnRlcmNlcHRpb25Sb3V0ZUluQ3VycmVudFRyZWUoc3RhdGUudHJlZSlcblxuICAvLyBUT0RPLUFQUDogdmVyaWZ5IHRoYXQgYGhyZWZgIGlzIG5vdCBhbiBleHRlcm5hbCB1cmwuXG4gIC8vIEZldGNoIGRhdGEgZnJvbSB0aGUgcm9vdCBvZiB0aGUgdHJlZS5cbiAgY2FjaGUubGF6eURhdGEgPSBmZXRjaFNlcnZlclJlc3BvbnNlKG5ldyBVUkwoaHJlZiwgb3JpZ2luKSwge1xuICAgIGZsaWdodFJvdXRlclN0YXRlOiBbXG4gICAgICBjdXJyZW50VHJlZVswXSxcbiAgICAgIGN1cnJlbnRUcmVlWzFdLFxuICAgICAgY3VycmVudFRyZWVbMl0sXG4gICAgICAncmVmZXRjaCcsXG4gICAgXSxcbiAgICBuZXh0VXJsOiBpbmNsdWRlTmV4dFVybCA/IHN0YXRlLm5leHRVcmwgOiBudWxsLFxuICB9KVxuXG4gIGNvbnN0IG5hdmlnYXRlZEF0ID0gRGF0ZS5ub3coKVxuICByZXR1cm4gY2FjaGUubGF6eURhdGEudGhlbihcbiAgICBhc3luYyAoeyBmbGlnaHREYXRhLCBjYW5vbmljYWxVcmw6IGNhbm9uaWNhbFVybE92ZXJyaWRlIH0pID0+IHtcbiAgICAgIC8vIEhhbmRsZSBjYXNlIHdoZW4gbmF2aWdhdGluZyB0byBwYWdlIGluIGBwYWdlc2AgZnJvbSBgYXBwYFxuICAgICAgaWYgKHR5cGVvZiBmbGlnaHREYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gaGFuZGxlRXh0ZXJuYWxVcmwoXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgbXV0YWJsZSxcbiAgICAgICAgICBmbGlnaHREYXRhLFxuICAgICAgICAgIHN0YXRlLnB1c2hSZWYucGVuZGluZ1B1c2hcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgY2FjaGUubGF6eURhdGEgYXMgaXQgaGFzIGJlZW4gcmVzb2x2ZWQgYXQgdGhpcyBwb2ludC5cbiAgICAgIGNhY2hlLmxhenlEYXRhID0gbnVsbFxuXG4gICAgICBmb3IgKGNvbnN0IG5vcm1hbGl6ZWRGbGlnaHREYXRhIG9mIGZsaWdodERhdGEpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHRyZWU6IHRyZWVQYXRjaCxcbiAgICAgICAgICBzZWVkRGF0YTogY2FjaGVOb2RlU2VlZERhdGEsXG4gICAgICAgICAgaGVhZCxcbiAgICAgICAgICBpc1Jvb3RSZW5kZXIsXG4gICAgICAgIH0gPSBub3JtYWxpemVkRmxpZ2h0RGF0YVxuXG4gICAgICAgIGlmICghaXNSb290UmVuZGVyKSB7XG4gICAgICAgICAgLy8gVE9ETy1BUFA6IGhhbmRsZSB0aGlzIGNhc2UgYmV0dGVyXG4gICAgICAgICAgY29uc29sZS5sb2coJ1JFRlJFU0ggRkFJTEVEJylcbiAgICAgICAgICByZXR1cm4gc3RhdGVcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5ld1RyZWUgPSBhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUoXG4gICAgICAgICAgLy8gVE9ETy1BUFA6IHJlbW92ZSAnJ1xuICAgICAgICAgIFsnJ10sXG4gICAgICAgICAgY3VycmVudFRyZWUsXG4gICAgICAgICAgdHJlZVBhdGNoLFxuICAgICAgICAgIHN0YXRlLmNhbm9uaWNhbFVybFxuICAgICAgICApXG5cbiAgICAgICAgaWYgKG5ld1RyZWUgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gaGFuZGxlU2VnbWVudE1pc21hdGNoKHN0YXRlLCBhY3Rpb24sIHRyZWVQYXRjaClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQoY3VycmVudFRyZWUsIG5ld1RyZWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZUV4dGVybmFsVXJsKFxuICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICBtdXRhYmxlLFxuICAgICAgICAgICAgaHJlZixcbiAgICAgICAgICAgIHN0YXRlLnB1c2hSZWYucGVuZGluZ1B1c2hcbiAgICAgICAgICApXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjYW5vbmljYWxVcmxPdmVycmlkZUhyZWYgPSBjYW5vbmljYWxVcmxPdmVycmlkZVxuICAgICAgICAgID8gY3JlYXRlSHJlZkZyb21VcmwoY2Fub25pY2FsVXJsT3ZlcnJpZGUpXG4gICAgICAgICAgOiB1bmRlZmluZWRcblxuICAgICAgICBpZiAoY2Fub25pY2FsVXJsT3ZlcnJpZGUpIHtcbiAgICAgICAgICBtdXRhYmxlLmNhbm9uaWNhbFVybCA9IGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZlxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGFuZGxlcyBjYXNlIHdoZXJlIHByZWZldGNoIG9ubHkgcmV0dXJucyB0aGUgcm91dGVyIHRyZWUgcGF0Y2ggd2l0aG91dCByZW5kZXJlZCBjb21wb25lbnRzLlxuICAgICAgICBpZiAoY2FjaGVOb2RlU2VlZERhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICBjb25zdCByc2MgPSBjYWNoZU5vZGVTZWVkRGF0YVsxXVxuICAgICAgICAgIGNvbnN0IGxvYWRpbmcgPSBjYWNoZU5vZGVTZWVkRGF0YVszXVxuICAgICAgICAgIGNhY2hlLnJzYyA9IHJzY1xuICAgICAgICAgIGNhY2hlLnByZWZldGNoUnNjID0gbnVsbFxuICAgICAgICAgIGNhY2hlLmxvYWRpbmcgPSBsb2FkaW5nXG4gICAgICAgICAgZmlsbExhenlJdGVtc1RpbGxMZWFmV2l0aEhlYWQoXG4gICAgICAgICAgICBuYXZpZ2F0ZWRBdCxcbiAgICAgICAgICAgIGNhY2hlLFxuICAgICAgICAgICAgLy8gRXhpc3RpbmcgY2FjaGUgaXMgbm90IHBhc3NlZCBpbiBhcyBgcm91dGVyLnJlZnJlc2goKWAgaGFzIHRvIGludmFsaWRhdGUgdGhlIGVudGlyZSBjYWNoZS5cbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHRyZWVQYXRjaCxcbiAgICAgICAgICAgIGNhY2hlTm9kZVNlZWREYXRhLFxuICAgICAgICAgICAgaGVhZCxcbiAgICAgICAgICAgIHVuZGVmaW5lZFxuICAgICAgICAgIClcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0NMSUVOVF9TRUdNRU5UX0NBQ0hFKSB7XG4gICAgICAgICAgICByZXZhbGlkYXRlRW50aXJlQ2FjaGUoc3RhdGUubmV4dFVybCwgbmV3VHJlZSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbXV0YWJsZS5wcmVmZXRjaENhY2hlID0gbmV3IE1hcCgpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgcmVmcmVzaEluYWN0aXZlUGFyYWxsZWxTZWdtZW50cyh7XG4gICAgICAgICAgbmF2aWdhdGVkQXQsXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgdXBkYXRlZFRyZWU6IG5ld1RyZWUsXG4gICAgICAgICAgdXBkYXRlZENhY2hlOiBjYWNoZSxcbiAgICAgICAgICBpbmNsdWRlTmV4dFVybCxcbiAgICAgICAgICBjYW5vbmljYWxVcmw6IG11dGFibGUuY2Fub25pY2FsVXJsIHx8IHN0YXRlLmNhbm9uaWNhbFVybCxcbiAgICAgICAgfSlcblxuICAgICAgICBtdXRhYmxlLmNhY2hlID0gY2FjaGVcbiAgICAgICAgbXV0YWJsZS5wYXRjaGVkVHJlZSA9IG5ld1RyZWVcblxuICAgICAgICBjdXJyZW50VHJlZSA9IG5ld1RyZWVcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhbmRsZU11dGFibGUoc3RhdGUsIG11dGFibGUpXG4gICAgfSxcbiAgICAoKSA9PiBzdGF0ZVxuICApXG59XG4iXSwibmFtZXMiOlsicmVmcmVzaFJlZHVjZXIiLCJzdGF0ZSIsImFjdGlvbiIsIm9yaWdpbiIsIm11dGFibGUiLCJocmVmIiwiY2Fub25pY2FsVXJsIiwiY3VycmVudFRyZWUiLCJ0cmVlIiwicHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGUiLCJjYWNoZSIsImNyZWF0ZUVtcHR5Q2FjaGVOb2RlIiwiaW5jbHVkZU5leHRVcmwiLCJoYXNJbnRlcmNlcHRpb25Sb3V0ZUluQ3VycmVudFRyZWUiLCJsYXp5RGF0YSIsImZldGNoU2VydmVyUmVzcG9uc2UiLCJVUkwiLCJmbGlnaHRSb3V0ZXJTdGF0ZSIsIm5leHRVcmwiLCJuYXZpZ2F0ZWRBdCIsIkRhdGUiLCJub3ciLCJ0aGVuIiwiZmxpZ2h0RGF0YSIsImNhbm9uaWNhbFVybE92ZXJyaWRlIiwiaGFuZGxlRXh0ZXJuYWxVcmwiLCJwdXNoUmVmIiwicGVuZGluZ1B1c2giLCJub3JtYWxpemVkRmxpZ2h0RGF0YSIsInRyZWVQYXRjaCIsInNlZWREYXRhIiwiY2FjaGVOb2RlU2VlZERhdGEiLCJoZWFkIiwiaXNSb290UmVuZGVyIiwiY29uc29sZSIsImxvZyIsIm5ld1RyZWUiLCJhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUiLCJoYW5kbGVTZWdtZW50TWlzbWF0Y2giLCJpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQiLCJjYW5vbmljYWxVcmxPdmVycmlkZUhyZWYiLCJjcmVhdGVIcmVmRnJvbVVybCIsInVuZGVmaW5lZCIsInJzYyIsImxvYWRpbmciLCJwcmVmZXRjaFJzYyIsImZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9DTElFTlRfU0VHTUVOVF9DQUNIRSIsInJldmFsaWRhdGVFbnRpcmVDYWNoZSIsInByZWZldGNoQ2FjaGUiLCJNYXAiLCJyZWZyZXNoSW5hY3RpdmVQYXJhbGxlbFNlZ21lbnRzIiwidXBkYXRlZFRyZWUiLCJ1cGRhdGVkQ2FjaGUiLCJwYXRjaGVkVHJlZSIsImhhbmRsZU11dGFibGUiXSwibWFwcGluZ3MiOiI7OzsrQkFvQmdCQSxrQkFBQUE7OztlQUFBQTs7O3FDQXBCb0I7bUNBQ0Y7NkNBQ1U7NkNBQ0E7aUNBT1Y7K0JBQ0o7K0NBRWdCOzJCQUNUO3VDQUNDO21EQUNZO2lEQUNGOzhCQUNWO0FBRS9C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QixFQUFFOztxQkFFdEM7b0JBQ0w3QyxRQUFRK0MsYUFBYSxHQUFHLElBQUlDO2dCQUM5QjtZQUNGO1lBRUEsTUFBTUMsQ0FBQUEsR0FBQUEsaUNBQUFBLCtCQUErQixFQUFDO2dCQUNwQ2xDO2dCQUNBbEI7Z0JBQ0FxRCxhQUFhbEI7Z0JBQ2JtQixjQUFjN0M7Z0JBQ2RFO2dCQUNBTixjQUFjRixRQUFRRSxZQUFZLElBQUlMLE1BQU1LLFlBQVk7WUFDMUQ7WUFFQUYsUUFBUU0sS0FBSyxHQUFHQTtZQUNoQk4sUUFBUW9ELFdBQVcsR0FBR3BCO1lBRXRCN0IsY0FBYzZCO1FBQ2hCO1FBRUEsT0FBT3FCLENBQUFBLEdBQUFBLGVBQUFBLGFBQWEsRUFBQ3hELE9BQU9HO0lBQzlCLEdBQ0EsSUFBTUg7QUFFViIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxMTgxOSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yZWR1Y2Vycy9obXItcmVmcmVzaC1yZWR1Y2VyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGZldGNoU2VydmVyUmVzcG9uc2UgfSBmcm9tICcuLi9mZXRjaC1zZXJ2ZXItcmVzcG9uc2UnXG5pbXBvcnQgeyBjcmVhdGVIcmVmRnJvbVVybCB9IGZyb20gJy4uL2NyZWF0ZS1ocmVmLWZyb20tdXJsJ1xuaW1wb3J0IHsgYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlIH0gZnJvbSAnLi4vYXBwbHktcm91dGVyLXN0YXRlLXBhdGNoLXRvLXRyZWUnXG5pbXBvcnQgeyBpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQgfSBmcm9tICcuLi9pcy1uYXZpZ2F0aW5nLXRvLW5ldy1yb290LWxheW91dCdcbmltcG9ydCB0eXBlIHtcbiAgUmVhZG9ubHlSZWR1Y2VyU3RhdGUsXG4gIFJlZHVjZXJTdGF0ZSxcbiAgSG1yUmVmcmVzaEFjdGlvbixcbiAgTXV0YWJsZSxcbn0gZnJvbSAnLi4vcm91dGVyLXJlZHVjZXItdHlwZXMnXG5pbXBvcnQgeyBoYW5kbGVFeHRlcm5hbFVybCB9IGZyb20gJy4vbmF2aWdhdGUtcmVkdWNlcidcbmltcG9ydCB7IGhhbmRsZU11dGFibGUgfSBmcm9tICcuLi9oYW5kbGUtbXV0YWJsZSdcbmltcG9ydCB7IGFwcGx5RmxpZ2h0RGF0YSB9IGZyb20gJy4uL2FwcGx5LWZsaWdodC1kYXRhJ1xuaW1wb3J0IHR5cGUgeyBDYWNoZU5vZGUgfSBmcm9tICcuLi8uLi8uLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB7IGNyZWF0ZUVtcHR5Q2FjaGVOb2RlIH0gZnJvbSAnLi4vLi4vYXBwLXJvdXRlcidcbmltcG9ydCB7IGhhbmRsZVNlZ21lbnRNaXNtYXRjaCB9IGZyb20gJy4uL2hhbmRsZS1zZWdtZW50LW1pc21hdGNoJ1xuaW1wb3J0IHsgaGFzSW50ZXJjZXB0aW9uUm91dGVJbkN1cnJlbnRUcmVlIH0gZnJvbSAnLi9oYXMtaW50ZXJjZXB0aW9uLXJvdXRlLWluLWN1cnJlbnQtdHJlZSdcblxuLy8gQSB2ZXJzaW9uIG9mIHJlZnJlc2ggcmVkdWNlciB0aGF0IGtlZXBzIHRoZSBjYWNoZSBhcm91bmQgaW5zdGVhZCBvZiB3aXBpbmcgYWxsIG9mIGl0LlxuZnVuY3Rpb24gaG1yUmVmcmVzaFJlZHVjZXJJbXBsKFxuICBzdGF0ZTogUmVhZG9ubHlSZWR1Y2VyU3RhdGUsXG4gIGFjdGlvbjogSG1yUmVmcmVzaEFjdGlvblxuKTogUmVkdWNlclN0YXRlIHtcbiAgY29uc3QgeyBvcmlnaW4gfSA9IGFjdGlvblxuICBjb25zdCBtdXRhYmxlOiBNdXRhYmxlID0ge31cbiAgY29uc3QgaHJlZiA9IHN0YXRlLmNhbm9uaWNhbFVybFxuXG4gIG11dGFibGUucHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGUgPSBmYWxzZVxuXG4gIGNvbnN0IGNhY2hlOiBDYWNoZU5vZGUgPSBjcmVhdGVFbXB0eUNhY2hlTm9kZSgpXG4gIC8vIElmIHRoZSBjdXJyZW50IHRyZWUgd2FzIGludGVyY2VwdGVkLCB0aGUgbmV4dFVybCBzaG91bGQgYmUgaW5jbHVkZWQgaW4gdGhlIHJlcXVlc3QuXG4gIC8vIFRoaXMgaXMgdG8gZW5zdXJlIHRoYXQgdGhlIHJlZnJlc2ggcmVxdWVzdCBkb2Vzbid0IGdldCBpbnRlcmNlcHRlZCwgYWNjaWRlbnRhbGx5IHRyaWdnZXJpbmcgdGhlIGludGVyY2VwdGlvbiByb3V0ZS5cbiAgY29uc3QgaW5jbHVkZU5leHRVcmwgPSBoYXNJbnRlcmNlcHRpb25Sb3V0ZUluQ3VycmVudFRyZWUoc3RhdGUudHJlZSlcblxuICAvLyBUT0RPLUFQUDogdmVyaWZ5IHRoYXQgYGhyZWZgIGlzIG5vdCBhbiBleHRlcm5hbCB1cmwuXG4gIC8vIEZldGNoIGRhdGEgZnJvbSB0aGUgcm9vdCBvZiB0aGUgdHJlZS5cbiAgY29uc3QgbmF2aWdhdGVkQXQgPSBEYXRlLm5vdygpXG4gIGNhY2hlLmxhenlEYXRhID0gZmV0Y2hTZXJ2ZXJSZXNwb25zZShuZXcgVVJMKGhyZWYsIG9yaWdpbiksIHtcbiAgICBmbGlnaHRSb3V0ZXJTdGF0ZTogW3N0YXRlLnRyZWVbMF0sIHN0YXRlLnRyZWVbMV0sIHN0YXRlLnRyZWVbMl0sICdyZWZldGNoJ10sXG4gICAgbmV4dFVybDogaW5jbHVkZU5leHRVcmwgPyBzdGF0ZS5uZXh0VXJsIDogbnVsbCxcbiAgICBpc0htclJlZnJlc2g6IHRydWUsXG4gIH0pXG5cbiAgcmV0dXJuIGNhY2hlLmxhenlEYXRhLnRoZW4oXG4gICAgKHsgZmxpZ2h0RGF0YSwgY2Fub25pY2FsVXJsOiBjYW5vbmljYWxVcmxPdmVycmlkZSB9KSA9PiB7XG4gICAgICAvLyBIYW5kbGUgY2FzZSB3aGVuIG5hdmlnYXRpbmcgdG8gcGFnZSBpbiBgcGFnZXNgIGZyb20gYGFwcGBcbiAgICAgIGlmICh0eXBlb2YgZmxpZ2h0RGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZUV4dGVybmFsVXJsKFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIG11dGFibGUsXG4gICAgICAgICAgZmxpZ2h0RGF0YSxcbiAgICAgICAgICBzdGF0ZS5wdXNoUmVmLnBlbmRpbmdQdXNoXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIGNhY2hlLmxhenlEYXRhIGFzIGl0IGhhcyBiZWVuIHJlc29sdmVkIGF0IHRoaXMgcG9pbnQuXG4gICAgICBjYWNoZS5sYXp5RGF0YSA9IG51bGxcblxuICAgICAgbGV0IGN1cnJlbnRUcmVlID0gc3RhdGUudHJlZVxuICAgICAgbGV0IGN1cnJlbnRDYWNoZSA9IHN0YXRlLmNhY2hlXG5cbiAgICAgIGZvciAoY29uc3Qgbm9ybWFsaXplZEZsaWdodERhdGEgb2YgZmxpZ2h0RGF0YSkge1xuICAgICAgICBjb25zdCB7IHRyZWU6IHRyZWVQYXRjaCwgaXNSb290UmVuZGVyIH0gPSBub3JtYWxpemVkRmxpZ2h0RGF0YVxuICAgICAgICBpZiAoIWlzUm9vdFJlbmRlcikge1xuICAgICAgICAgIC8vIFRPRE8tQVBQOiBoYW5kbGUgdGhpcyBjYXNlIGJldHRlclxuICAgICAgICAgIGNvbnNvbGUubG9nKCdSRUZSRVNIIEZBSUxFRCcpXG4gICAgICAgICAgcmV0dXJuIHN0YXRlXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBuZXdUcmVlID0gYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlKFxuICAgICAgICAgIC8vIFRPRE8tQVBQOiByZW1vdmUgJydcbiAgICAgICAgICBbJyddLFxuICAgICAgICAgIGN1cnJlbnRUcmVlLFxuICAgICAgICAgIHRyZWVQYXRjaCxcbiAgICAgICAgICBzdGF0ZS5jYW5vbmljYWxVcmxcbiAgICAgICAgKVxuXG4gICAgICAgIGlmIChuZXdUcmVlID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZVNlZ21lbnRNaXNtYXRjaChzdGF0ZSwgYWN0aW9uLCB0cmVlUGF0Y2gpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0KGN1cnJlbnRUcmVlLCBuZXdUcmVlKSkge1xuICAgICAgICAgIHJldHVybiBoYW5kbGVFeHRlcm5hbFVybChcbiAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgbXV0YWJsZSxcbiAgICAgICAgICAgIGhyZWYsXG4gICAgICAgICAgICBzdGF0ZS5wdXNoUmVmLnBlbmRpbmdQdXNoXG4gICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmID0gY2Fub25pY2FsVXJsT3ZlcnJpZGVcbiAgICAgICAgICA/IGNyZWF0ZUhyZWZGcm9tVXJsKGNhbm9uaWNhbFVybE92ZXJyaWRlKVxuICAgICAgICAgIDogdW5kZWZpbmVkXG5cbiAgICAgICAgaWYgKGNhbm9uaWNhbFVybE92ZXJyaWRlKSB7XG4gICAgICAgICAgbXV0YWJsZS5jYW5vbmljYWxVcmwgPSBjYW5vbmljYWxVcmxPdmVycmlkZUhyZWZcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcHBsaWVkID0gYXBwbHlGbGlnaHREYXRhKFxuICAgICAgICAgIG5hdmlnYXRlZEF0LFxuICAgICAgICAgIGN1cnJlbnRDYWNoZSxcbiAgICAgICAgICBjYWNoZSxcbiAgICAgICAgICBub3JtYWxpemVkRmxpZ2h0RGF0YVxuICAgICAgICApXG5cbiAgICAgICAgaWYgKGFwcGxpZWQpIHtcbiAgICAgICAgICBtdXRhYmxlLmNhY2hlID0gY2FjaGVcbiAgICAgICAgICBjdXJyZW50Q2FjaGUgPSBjYWNoZVxuICAgICAgICB9XG5cbiAgICAgICAgbXV0YWJsZS5wYXRjaGVkVHJlZSA9IG5ld1RyZWVcbiAgICAgICAgbXV0YWJsZS5jYW5vbmljYWxVcmwgPSBocmVmXG5cbiAgICAgICAgY3VycmVudFRyZWUgPSBuZXdUcmVlXG4gICAgICB9XG4gICAgICByZXR1cm4gaGFuZGxlTXV0YWJsZShzdGF0ZSwgbXV0YWJsZSlcbiAgICB9LFxuICAgICgpID0+IHN0YXRlXG4gIClcbn1cblxuZnVuY3Rpb24gaG1yUmVmcmVzaFJlZHVjZXJOb29wKFxuICBzdGF0ZTogUmVhZG9ubHlSZWR1Y2VyU3RhdGUsXG4gIF9hY3Rpb246IEhtclJlZnJlc2hBY3Rpb25cbik6IFJlZHVjZXJTdGF0ZSB7XG4gIHJldHVybiBzdGF0ZVxufVxuXG5leHBvcnQgY29uc3QgaG1yUmVmcmVzaFJlZHVjZXIgPVxuICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nXG4gICAgPyBobXJSZWZyZXNoUmVkdWNlck5vb3BcbiAgICA6IGhtclJlZnJlc2hSZWR1Y2VySW1wbFxuIl0sIm5hbWVzIjpbImhtclJlZnJlc2hSZWR1Y2VyIiwiaG1yUmVmcmVzaFJlZHVjZXJJbXBsIiwic3RhdGUiLCJhY3Rpb24iLCJvcmlnaW4iLCJtdXRhYmxlIiwiaHJlZiIsImNhbm9uaWNhbFVybCIsInByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlIiwiY2FjaGUiLCJjcmVhdGVFbXB0eUNhY2hlTm9kZSIsImluY2x1ZGVOZXh0VXJsIiwiaGFzSW50ZXJjZXB0aW9uUm91dGVJbkN1cnJlbnRUcmVlIiwidHJlZSIsIm5hdmlnYXRlZEF0IiwiRGF0ZSIsIm5vdyIsImxhenlEYXRhIiwiZmV0Y2hTZXJ2ZXJSZXNwb25zZSIsIlVSTCIsImZsaWdodFJvdXRlclN0YXRlIiwibmV4dFVybCIsImlzSG1yUmVmcmVzaCIsInRoZW4iLCJmbGlnaHREYXRhIiwiY2Fub25pY2FsVXJsT3ZlcnJpZGUiLCJoYW5kbGVFeHRlcm5hbFVybCIsInB1c2hSZWYiLCJwZW5kaW5nUHVzaCIsImN1cnJlbnRUcmVlIiwiY3VycmVudENhY2hlIiwibm9ybWFsaXplZEZsaWdodERhdGEiLCJ0cmVlUGF0Y2giLCJpc1Jvb3RSZW5kZXIiLCJjb25zb2xlIiwibG9nIiwibmV3VHJlZSIsImFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZSIsImhhbmRsZVNlZ21lbnRNaXNtYXRjaCIsImlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dCIsImNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZiIsImNyZWF0ZUhyZWZGcm9tVXJsIiwidW5kZWZpbmVkIiwiYXBwbGllZCIsImFwcGx5RmxpZ2h0RGF0YSIsInBhdGNoZWRUcmVlIiwiaGFuZGxlTXV0YWJsZSIsImhtclJlZnJlc2hSZWR1Y2VyTm9vcCIsIl9hY3Rpb24iLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiXSwibWFwcGluZ3MiOiI7OzsrQkErSGFBLHFCQUFBQTs7O2VBQUFBOzs7cUNBL0h1QjttQ0FDRjs2Q0FDVTs2Q0FDQTtpQ0FPVjsrQkFDSjtpQ0FDRTsyQkFFSzt1Q0FDQzttREFDWTtBQUVsRCx3RkFBd0Y7QUFDeEYsU0FBU0Msc0JBQ1BDLEtBQTJCLEVBQzNCQyxNQUF3QjtJQUV4QixNQUFNLEVBQUVDLE1BQU0sRUFBRSxHQUFHRDtJQUNuQixNQUFNRSxVQUFtQixDQUFDO0lBQzFCLE1BQU1DLE9BQU9KLE1BQU1LLFlBQVk7SUFFL0JGLFFBQVFHLDBCQUEwQixHQUFHO0lBRXJDLE1BQU1DLFFBQW1CQyxDQUFBQSxHQUFBQSxXQUFBQSxvQkFBb0I7SUFDN0Msc0ZBQXNGO0lBQ3RGLHNIQUFzSDtJQUN0SCxNQUFNQyxpQkFBaUJDLENBQUFBLEdBQUFBLG1DQUFBQSxpQ0FBaUMsRUFBQ1YsTUFBTVcsSUFBSTtJQUVuRSx1REFBdUQ7SUFDdkQsd0NBQXdDO0lBQ3hDLE1BQU1DLGNBQWNDLEtBQUtDLEdBQUc7SUFDNUJQLE1BQU1RLFFBQVEsR0FBR0MsQ0FBQUEsR0FBQUEscUJBQUFBLG1CQUFtQixFQUFDLElBQUlDLElBQUliLE1BQU1GLFNBQVM7UUFDMURnQixtQkFBbUI7WUFBQ2xCLE1BQU1XLElBQUksQ0FBQyxFQUFFO1lBQUVYLE1BQU1XLElBQUksQ0FBQyxFQUFFO1lBQUVYLE1BQU1XLElBQUksQ0FBQyxFQUFFO1lBQUU7U0FBVTtRQUMzRVEsU0FBU1YsaUJBQWlCVCxNQUFNbUIsT0FBTyxHQUFHO1FBQzFDQyxjQUFjO0lBQ2hCO0lBRUEsT0FBT2IsTUFBTVEsUUFBUSxDQUFDTSxJQUFJLENBQ3hCLENBQUE7WUFBQyxFQUFFQyxVQUFVLEVBQUVqQixjQUFja0Isb0JBQW9CLEVBQUUsR0FBQTtRQUNqRCw0REFBNEQ7UUFDNUQsSUFBSSxPQUFPRCxlQUFlLFVBQVU7WUFDbEMsT0FBT0UsQ0FBQUEsR0FBQUEsaUJBQUFBLGlCQUFpQixFQUN0QnhCLE9BQ0FHLFNBQ0FtQixZQUNBdEIsTUFBTXlCLE9BQU8sQ0FBQ0MsV0FBVztRQUU3QjtRQUVBLCtEQUErRDtRQUMvRG5CLE1BQU1RLFFBQVEsR0FBRztRQUVqQixJQUFJWSxjQUFjM0IsTUFBTVcsSUFBSTtRQUM1QixJQUFJaUIsZUFBZTVCLE1BQU1PLEtBQUs7UUFFOUIsS0FBSyxNQUFNc0Isd0JBQXdCUCxXQUFZO1lBQzdDLE1BQU0sRUFBRVgsTUFBTW1CLFNBQVMsRUFBRUMsWUFBWSxFQUFFLEdBQUdGO1lBQzFDLElBQUksQ0FBQ0UsY0FBYztnQkFDakIsb0NBQW9DO2dCQUNwQ0MsUUFBUUMsR0FBRyxDQUFDO2dCQUNaLE9BQU9qQztZQUNUO1lBRUEsTUFBTWtDLFVBQVVDLENBQUFBLEdBQUFBLDZCQUFBQSwyQkFBMkIsRUFDekMsQUFDQSxzQkFEc0I7Z0JBQ3JCO2FBQUcsRUFDSlIsYUFDQUcsV0FDQTlCLE1BQU1LLFlBQVk7WUFHcEIsSUFBSTZCLFlBQVksTUFBTTtnQkFDcEIsT0FBT0UsQ0FBQUEsR0FBQUEsdUJBQUFBLHFCQUFxQixFQUFDcEMsT0FBT0MsUUFBUTZCO1lBQzlDO1lBRUEsSUFBSU8sQ0FBQUEsR0FBQUEsNkJBQUFBLDJCQUEyQixFQUFDVixhQUFhTyxVQUFVO2dCQUNyRCxPQUFPVixDQUFBQSxHQUFBQSxpQkFBQUEsaUJBQWlCLEVBQ3RCeEIsT0FDQUcsU0FDQUMsTUFDQUosTUFBTXlCLE9BQU8sQ0FBQ0MsV0FBVztZQUU3QjtZQUVBLE1BQU1ZLDJCQUEyQmYsdUJBQzdCZ0IsQ0FBQUEsR0FBQUEsbUJBQUFBLGlCQUFpQixFQUFDaEIsd0JBQ2xCaUI7WUFFSixJQUFJakIsc0JBQXNCO2dCQUN4QnBCLFFBQVFFLFlBQVksR0FBR2lDO1lBQ3pCO1lBQ0EsTUFBTUcsVUFBVUMsQ0FBQUEsR0FBQUEsaUJBQUFBLGVBQWUsRUFDN0I5QixhQUNBZ0IsY0FDQXJCLE9BQ0FzQjtZQUdGLElBQUlZLFNBQVM7Z0JBQ1h0QyxRQUFRSSxLQUFLLEdBQUdBO2dCQUNoQnFCLGVBQWVyQjtZQUNqQjtZQUVBSixRQUFRd0MsV0FBVyxHQUFHVDtZQUN0Qi9CLFFBQVFFLFlBQVksR0FBR0Q7WUFFdkJ1QixjQUFjTztRQUNoQjtRQUNBLE9BQU9VLENBQUFBLEdBQUFBLGVBQUFBLGFBQWEsRUFBQzVDLE9BQU9HO0lBQzlCLEdBQ0EsSUFBTUg7QUFFVjtBQUVBLFNBQVM2QyxzQkFDUDdDLEtBQTJCLEVBQzNCOEMsT0FBeUI7SUFFekIsT0FBTzlDO0FBQ1Q7QUFFTyxNQUFNRixvQkFDWGlELFFBQVFDLEdBQUcsQ0FBQ0MsUUFBUSxLQUFLLGFBQ3JCSiwwQkFDQTlDIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDExOTIwLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2NsaWVudC9hc3NpZ24tbG9jYXRpb24udHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYWRkQmFzZVBhdGggfSBmcm9tICcuL2FkZC1iYXNlLXBhdGgnXG5cbi8qKlxuICogRnVuY3Rpb24gdG8gY29ycmVjdGx5IGFzc2lnbiBsb2NhdGlvbiB0byBVUkxcbiAqXG4gKiBUaGUgbWV0aG9kIHdpbGwgYWRkIGJhc2VQYXRoLCBhbmQgd2lsbCBhbHNvIGNvcnJlY3RseSBhZGQgbG9jYXRpb24gKGluY2x1ZGluZyBpZiBpdCBpcyBhIHJlbGF0aXZlIHBhdGgpXG4gKiBAcGFyYW0gbG9jYXRpb24gTG9jYXRpb24gdGhhdCBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIHVybFxuICogQHBhcmFtIHVybCBCYXNlIFVSTCB0byB3aGljaCB0aGUgbG9jYXRpb24gc2hvdWxkIGJlIGFzc2lnbmVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ25Mb2NhdGlvbihsb2NhdGlvbjogc3RyaW5nLCB1cmw6IFVSTCk6IFVSTCB7XG4gIGlmIChsb2NhdGlvbi5zdGFydHNXaXRoKCcuJykpIHtcbiAgICBjb25zdCB1cmxCYXNlID0gdXJsLm9yaWdpbiArIHVybC5wYXRobmFtZVxuICAgIHJldHVybiBuZXcgVVJMKFxuICAgICAgLy8gSW4gb3JkZXIgZm9yIGEgcmVsYXRpdmUgcGF0aCB0byBiZSBhZGRlZCB0byB0aGUgY3VycmVudCB1cmwgY29ycmVjdGx5LCB0aGUgY3VycmVudCB1cmwgbXVzdCBlbmQgd2l0aCBhIHNsYXNoXG4gICAgICAvLyBuZXcgVVJMKCcuL3JlbGF0aXZlJywgJ2h0dHBzOi8vZXhhbXBsZS5jb20vc3ViZGlyJykuaHJlZiAtPiAnaHR0cHM6Ly9leGFtcGxlLmNvbS9yZWxhdGl2ZSdcbiAgICAgIC8vIG5ldyBVUkwoJy4vcmVsYXRpdmUnLCAnaHR0cHM6Ly9leGFtcGxlLmNvbS9zdWJkaXIvJykuaHJlZiAtPiAnaHR0cHM6Ly9leGFtcGxlLmNvbS9zdWJkaXIvcmVsYXRpdmUnXG4gICAgICAodXJsQmFzZS5lbmRzV2l0aCgnLycpID8gdXJsQmFzZSA6IHVybEJhc2UgKyAnLycpICsgbG9jYXRpb25cbiAgICApXG4gIH1cblxuICByZXR1cm4gbmV3IFVSTChhZGRCYXNlUGF0aChsb2NhdGlvbiksIHVybC5ocmVmKVxufVxuIl0sIm5hbWVzIjpbImFzc2lnbkxvY2F0aW9uIiwibG9jYXRpb24iLCJ1cmwiLCJzdGFydHNXaXRoIiwidXJsQmFzZSIsIm9yaWdpbiIsInBhdGhuYW1lIiwiVVJMIiwiZW5kc1dpdGgiLCJhZGRCYXNlUGF0aCIsImhyZWYiXSwibWFwcGluZ3MiOiI7OzsrQkFTZ0JBLGtCQUFBQTs7O2VBQUFBOzs7NkJBVFk7QUFTckIsU0FBU0EsZUFBZUMsUUFBZ0IsRUFBRUMsR0FBUTtJQUN2RCxJQUFJRCxTQUFTRSxVQUFVLENBQUMsTUFBTTtRQUM1QixNQUFNQyxVQUFVRixJQUFJRyxNQUFNLEdBQUdILElBQUlJLFFBQVE7UUFDekMsT0FBTyxJQUFJQyxJQUNULEFBR0EsQUFGQSw2RkFBNkYsa0JBRGtCO1FBRS9HLHFHQUFxRztRQUNwR0gsQ0FBQUEsUUFBUUksUUFBUSxDQUFDLE9BQU9KLFVBQVVBLFVBQVUsR0FBRSxJQUFLSDtJQUV4RDtJQUVBLE9BQU8sSUFBSU0sSUFBSUUsQ0FBQUEsR0FBQUEsYUFBQUEsV0FBVyxFQUFDUixXQUFXQyxJQUFJUSxJQUFJO0FBQ2hEIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDExOTUyLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL3NoYXJlZC9saWIvc2VydmVyLXJlZmVyZW5jZS1pbmZvLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBpbnRlcmZhY2UgU2VydmVyUmVmZXJlbmNlSW5mbyB7XG4gIHR5cGU6ICdzZXJ2ZXItYWN0aW9uJyB8ICd1c2UtY2FjaGUnXG4gIHVzZWRBcmdzOiBbYm9vbGVhbiwgYm9vbGVhbiwgYm9vbGVhbiwgYm9vbGVhbiwgYm9vbGVhbiwgYm9vbGVhbl1cbiAgaGFzUmVzdEFyZ3M6IGJvb2xlYW5cbn1cblxuLyoqXG4gKiBFeHRyYWN0cyBpbmZvIGFib3V0IHRoZSBzZXJ2ZXIgcmVmZXJlbmNlIGZvciB0aGUgZ2l2ZW4gc2VydmVyIHJlZmVyZW5jZSBJRCBieVxuICogcGFyc2luZyB0aGUgZmlyc3QgYnl0ZSBvZiB0aGUgaGV4LWVuY29kZWQgSUQuXG4gKlxuICogYGBgXG4gKiBCaXQgcG9zaXRpb25zOiBbN10gICAgICBbNl0gWzVdIFs0XSBbM10gWzJdIFsxXSAgWzBdXG4gKiBCaXRzOiAgICAgICAgICB0eXBlQml0ICBhcmdNYXNrICAgICAgICAgICAgICAgICAgcmVzdEFyZ3NcbiAqIGBgYFxuICpcbiAqIElmIHRoZSBgdHlwZUJpdGAgaXMgYDFgIHRoZSBzZXJ2ZXIgcmVmZXJlbmNlIHJlcHJlc2VudHMgYSBgXCJ1c2UgY2FjaGVcImBcbiAqIGZ1bmN0aW9uLCBvdGhlcndpc2UgYSBzZXJ2ZXIgYWN0aW9uLlxuICpcbiAqIFRoZSBgYXJnTWFza2AgZW5jb2RlcyB3aGV0aGVyIHRoZSBmdW5jdGlvbiB1c2VzIHRoZSBhcmd1bWVudCBhdCB0aGVcbiAqIHJlc3BlY3RpdmUgcG9zaXRpb24uXG4gKlxuICogVGhlIGByZXN0QXJnc2AgYml0IGluZGljYXRlcyB3aGV0aGVyIHRoZSBmdW5jdGlvbiB1c2VzIGEgcmVzdCBwYXJhbWV0ZXIuIEl0J3NcbiAqIGFsc28gc2V0IHRvIDEgaWYgdGhlIGZ1bmN0aW9uIGhhcyBtb3JlIHRoYW4gNiBhcmdzLlxuICpcbiAqIEBwYXJhbSBpZCBoZXgtZW5jb2RlZCBzZXJ2ZXIgcmVmZXJlbmNlIElEXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0SW5mb0Zyb21TZXJ2ZXJSZWZlcmVuY2VJZChcbiAgaWQ6IHN0cmluZ1xuKTogU2VydmVyUmVmZXJlbmNlSW5mbyB7XG4gIGNvbnN0IGluZm9CeXRlID0gcGFyc2VJbnQoaWQuc2xpY2UoMCwgMiksIDE2KVxuICBjb25zdCB0eXBlQml0ID0gKGluZm9CeXRlID4+IDcpICYgMHgxXG4gIGNvbnN0IGFyZ01hc2sgPSAoaW5mb0J5dGUgPj4gMSkgJiAweDNmXG4gIGNvbnN0IHJlc3RBcmdzID0gaW5mb0J5dGUgJiAweDFcbiAgY29uc3QgdXNlZEFyZ3MgPSBBcnJheSg2KVxuXG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCA2OyBpbmRleCsrKSB7XG4gICAgY29uc3QgYml0UG9zaXRpb24gPSA1IC0gaW5kZXhcbiAgICBjb25zdCBiaXQgPSAoYXJnTWFzayA+PiBiaXRQb3NpdGlvbikgJiAweDFcbiAgICB1c2VkQXJnc1tpbmRleF0gPSBiaXQgPT09IDFcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdHlwZTogdHlwZUJpdCA9PT0gMSA/ICd1c2UtY2FjaGUnIDogJ3NlcnZlci1hY3Rpb24nLFxuICAgIHVzZWRBcmdzOiB1c2VkQXJncyBhcyBbXG4gICAgICBib29sZWFuLFxuICAgICAgYm9vbGVhbixcbiAgICAgIGJvb2xlYW4sXG4gICAgICBib29sZWFuLFxuICAgICAgYm9vbGVhbixcbiAgICAgIGJvb2xlYW4sXG4gICAgXSxcbiAgICBoYXNSZXN0QXJnczogcmVzdEFyZ3MgPT09IDEsXG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc3BhcnNlIGFycmF5IGNvbnRhaW5pbmcgb25seSB0aGUgdXNlZCBhcmd1bWVudHMgYmFzZWQgb24gdGhlXG4gKiBwcm92aWRlZCBhY3Rpb24gaW5mby5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9taXRVbnVzZWRBcmdzKFxuICBhcmdzOiB1bmtub3duW10sXG4gIGluZm86IFNlcnZlclJlZmVyZW5jZUluZm9cbik6IHVua25vd25bXSB7XG4gIGNvbnN0IGZpbHRlcmVkQXJncyA9IG5ldyBBcnJheShhcmdzLmxlbmd0aClcblxuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgYXJncy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBpZiAoXG4gICAgICAoaW5kZXggPCA2ICYmIGluZm8udXNlZEFyZ3NbaW5kZXhdKSB8fFxuICAgICAgLy8gVGhpcyBhc3N1bWVzIHRoYXQgdGhlIHNlcnZlciByZWZlcmVuY2UgaW5mbyBieXRlIGhhcyB0aGUgcmVzdEFyZ3MgYml0XG4gICAgICAvLyBzZXQgdG8gMSBpZiB0aGVyZSBhcmUgbW9yZSB0aGFuIDYgYXJncy5cbiAgICAgIChpbmRleCA+PSA2ICYmIGluZm8uaGFzUmVzdEFyZ3MpXG4gICAgKSB7XG4gICAgICBmaWx0ZXJlZEFyZ3NbaW5kZXhdID0gYXJnc1tpbmRleF1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmlsdGVyZWRBcmdzXG59XG4iXSwibmFtZXMiOlsiZXh0cmFjdEluZm9Gcm9tU2VydmVyUmVmZXJlbmNlSWQiLCJvbWl0VW51c2VkQXJncyIsImlkIiwiaW5mb0J5dGUiLCJwYXJzZUludCIsInNsaWNlIiwidHlwZUJpdCIsImFyZ01hc2siLCJyZXN0QXJncyIsInVzZWRBcmdzIiwiQXJyYXkiLCJpbmRleCIsImJpdFBvc2l0aW9uIiwiYml0IiwidHlwZSIsImhhc1Jlc3RBcmdzIiwiYXJncyIsImluZm8iLCJmaWx0ZXJlZEFyZ3MiLCJsZW5ndGgiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0lBMEJnQkEsZ0NBQWdDLEVBQUE7ZUFBaENBOztJQWlDQUMsY0FBYyxFQUFBO2VBQWRBOzs7QUFqQ1QsU0FBU0QsaUNBQ2RFLEVBQVU7SUFFVixNQUFNQyxXQUFXQyxTQUFTRixHQUFHRyxLQUFLLENBQUMsR0FBRyxJQUFJO0lBQzFDLE1BQU1DLFVBQVdILFlBQVksSUFBSztJQUNsQyxNQUFNSSxVQUFXSixZQUFZLElBQUs7SUFDbEMsTUFBTUssV0FBV0wsV0FBVztJQUM1QixNQUFNTSxXQUFXQyxNQUFNO0lBRXZCLElBQUssSUFBSUMsUUFBUSxHQUFHQSxRQUFRLEdBQUdBLFFBQVM7UUFDdEMsTUFBTUMsY0FBYyxJQUFJRDtRQUN4QixNQUFNRSxNQUFPTixXQUFXSyxjQUFlO1FBQ3ZDSCxRQUFRLENBQUNFLE1BQU0sR0FBR0UsUUFBUTtJQUM1QjtJQUVBLE9BQU87UUFDTEMsTUFBTVIsWUFBWSxJQUFJLGNBQWM7UUFDcENHLFVBQVVBO1FBUVZNLGFBQWFQLGFBQWE7SUFDNUI7QUFDRjtBQU1PLFNBQVNQLGVBQ2RlLElBQWUsRUFDZkMsSUFBeUI7SUFFekIsTUFBTUMsZUFBZSxJQUFJUixNQUFNTSxLQUFLRyxNQUFNO0lBRTFDLElBQUssSUFBSVIsUUFBUSxHQUFHQSxRQUFRSyxLQUFLRyxNQUFNLEVBQUVSLFFBQVM7UUFDaEQsSUFDR0EsUUFBUSxLQUFLTSxLQUFLUixRQUFRLENBQUNFLE1BQU0sSUFDbEMsd0VBQXdFO1FBQ3hFLDBDQUEwQztRQUN6Q0EsU0FBUyxLQUFLTSxLQUFLRixXQUFXLEVBQy9CO1lBQ0FHLFlBQVksQ0FBQ1AsTUFBTSxHQUFHSyxJQUFJLENBQUNMLE1BQU07UUFDbkM7SUFDRjtJQUVBLE9BQU9PO0FBQ1QiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTIwMDcsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvc2VydmVyLWFjdGlvbi1yZWR1Y2VyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHtcbiAgQWN0aW9uRmxpZ2h0UmVzcG9uc2UsXG4gIEFjdGlvblJlc3VsdCxcbn0gZnJvbSAnLi4vLi4vLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvdHlwZXMnXG5pbXBvcnQgeyBjYWxsU2VydmVyIH0gZnJvbSAnLi4vLi4vLi4vYXBwLWNhbGwtc2VydmVyJ1xuaW1wb3J0IHsgZmluZFNvdXJjZU1hcFVSTCB9IGZyb20gJy4uLy4uLy4uL2FwcC1maW5kLXNvdXJjZS1tYXAtdXJsJ1xuaW1wb3J0IHtcbiAgQUNUSU9OX0hFQURFUixcbiAgTkVYVF9BQ1RJT05fTk9UX0ZPVU5EX0hFQURFUixcbiAgTkVYVF9JU19QUkVSRU5ERVJfSEVBREVSLFxuICBORVhUX1JPVVRFUl9TVEFURV9UUkVFX0hFQURFUixcbiAgTkVYVF9VUkwsXG4gIFJTQ19DT05URU5UX1RZUEVfSEVBREVSLFxufSBmcm9tICcuLi8uLi9hcHAtcm91dGVyLWhlYWRlcnMnXG5cbi8vIFRPRE86IEV4cGxpY2l0bHkgaW1wb3J0IGZyb20gY2xpZW50LmJyb3dzZXJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tZXh0cmFuZW91cy1kZXBlbmRlbmNpZXNcbmltcG9ydCB7XG4gIGNyZWF0ZUZyb21GZXRjaCBhcyBjcmVhdGVGcm9tRmV0Y2hCcm93c2VyLFxuICBjcmVhdGVUZW1wb3JhcnlSZWZlcmVuY2VTZXQsXG4gIGVuY29kZVJlcGx5LFxufSBmcm9tICdyZWFjdC1zZXJ2ZXItZG9tLXdlYnBhY2svY2xpZW50J1xuXG5pbXBvcnQge1xuICBQcmVmZXRjaEtpbmQsXG4gIHR5cGUgUmVhZG9ubHlSZWR1Y2VyU3RhdGUsXG4gIHR5cGUgUmVkdWNlclN0YXRlLFxuICB0eXBlIFNlcnZlckFjdGlvbkFjdGlvbixcbiAgdHlwZSBTZXJ2ZXJBY3Rpb25NdXRhYmxlLFxufSBmcm9tICcuLi9yb3V0ZXItcmVkdWNlci10eXBlcydcbmltcG9ydCB7IGFzc2lnbkxvY2F0aW9uIH0gZnJvbSAnLi4vLi4vLi4vYXNzaWduLWxvY2F0aW9uJ1xuaW1wb3J0IHsgY3JlYXRlSHJlZkZyb21VcmwgfSBmcm9tICcuLi9jcmVhdGUtaHJlZi1mcm9tLXVybCdcbmltcG9ydCB7IGhhbmRsZUV4dGVybmFsVXJsIH0gZnJvbSAnLi9uYXZpZ2F0ZS1yZWR1Y2VyJ1xuaW1wb3J0IHsgYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlIH0gZnJvbSAnLi4vYXBwbHktcm91dGVyLXN0YXRlLXBhdGNoLXRvLXRyZWUnXG5pbXBvcnQgeyBpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQgfSBmcm9tICcuLi9pcy1uYXZpZ2F0aW5nLXRvLW5ldy1yb290LWxheW91dCdcbmltcG9ydCB0eXBlIHsgQ2FjaGVOb2RlIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgeyBoYW5kbGVNdXRhYmxlIH0gZnJvbSAnLi4vaGFuZGxlLW11dGFibGUnXG5pbXBvcnQgeyBmaWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZCB9IGZyb20gJy4uL2ZpbGwtbGF6eS1pdGVtcy10aWxsLWxlYWYtd2l0aC1oZWFkJ1xuaW1wb3J0IHsgY3JlYXRlRW1wdHlDYWNoZU5vZGUgfSBmcm9tICcuLi8uLi9hcHAtcm91dGVyJ1xuaW1wb3J0IHsgaGFzSW50ZXJjZXB0aW9uUm91dGVJbkN1cnJlbnRUcmVlIH0gZnJvbSAnLi9oYXMtaW50ZXJjZXB0aW9uLXJvdXRlLWluLWN1cnJlbnQtdHJlZSdcbmltcG9ydCB7IGhhbmRsZVNlZ21lbnRNaXNtYXRjaCB9IGZyb20gJy4uL2hhbmRsZS1zZWdtZW50LW1pc21hdGNoJ1xuaW1wb3J0IHsgcmVmcmVzaEluYWN0aXZlUGFyYWxsZWxTZWdtZW50cyB9IGZyb20gJy4uL3JlZmV0Y2gtaW5hY3RpdmUtcGFyYWxsZWwtc2VnbWVudHMnXG5pbXBvcnQge1xuICBub3JtYWxpemVGbGlnaHREYXRhLFxuICBwcmVwYXJlRmxpZ2h0Um91dGVyU3RhdGVGb3JSZXF1ZXN0LFxuICB0eXBlIE5vcm1hbGl6ZWRGbGlnaHREYXRhLFxufSBmcm9tICcuLi8uLi8uLi9mbGlnaHQtZGF0YS1oZWxwZXJzJ1xuaW1wb3J0IHsgZ2V0UmVkaXJlY3RFcnJvciB9IGZyb20gJy4uLy4uL3JlZGlyZWN0J1xuaW1wb3J0IHsgUmVkaXJlY3RUeXBlIH0gZnJvbSAnLi4vLi4vcmVkaXJlY3QtZXJyb3InXG5pbXBvcnQgeyBjcmVhdGVTZWVkZWRQcmVmZXRjaENhY2hlRW50cnkgfSBmcm9tICcuLi9wcmVmZXRjaC1jYWNoZS11dGlscydcbmltcG9ydCB7IHJlbW92ZUJhc2VQYXRoIH0gZnJvbSAnLi4vLi4vLi4vcmVtb3ZlLWJhc2UtcGF0aCdcbmltcG9ydCB7IGhhc0Jhc2VQYXRoIH0gZnJvbSAnLi4vLi4vLi4vaGFzLWJhc2UtcGF0aCdcbmltcG9ydCB7XG4gIGV4dHJhY3RJbmZvRnJvbVNlcnZlclJlZmVyZW5jZUlkLFxuICBvbWl0VW51c2VkQXJncyxcbn0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL2xpYi9zZXJ2ZXItcmVmZXJlbmNlLWluZm8nXG5pbXBvcnQgeyByZXZhbGlkYXRlRW50aXJlQ2FjaGUgfSBmcm9tICcuLi8uLi9zZWdtZW50LWNhY2hlJ1xuXG5jb25zdCBjcmVhdGVGcm9tRmV0Y2ggPVxuICBjcmVhdGVGcm9tRmV0Y2hCcm93c2VyIGFzICh0eXBlb2YgaW1wb3J0KCdyZWFjdC1zZXJ2ZXItZG9tLXdlYnBhY2svY2xpZW50LmJyb3dzZXInKSlbJ2NyZWF0ZUZyb21GZXRjaCddXG5cbnR5cGUgRmV0Y2hTZXJ2ZXJBY3Rpb25SZXN1bHQgPSB7XG4gIHJlZGlyZWN0TG9jYXRpb246IFVSTCB8IHVuZGVmaW5lZFxuICByZWRpcmVjdFR5cGU6IFJlZGlyZWN0VHlwZSB8IHVuZGVmaW5lZFxuICBhY3Rpb25SZXN1bHQ6IEFjdGlvblJlc3VsdCB8IHVuZGVmaW5lZFxuICBhY3Rpb25GbGlnaHREYXRhOiBOb3JtYWxpemVkRmxpZ2h0RGF0YVtdIHwgc3RyaW5nIHwgdW5kZWZpbmVkXG4gIGlzUHJlcmVuZGVyOiBib29sZWFuXG4gIHJldmFsaWRhdGVkUGFydHM6IHtcbiAgICB0YWc6IGJvb2xlYW5cbiAgICBjb29raWU6IGJvb2xlYW5cbiAgICBwYXRoczogc3RyaW5nW11cbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBmZXRjaFNlcnZlckFjdGlvbihcbiAgc3RhdGU6IFJlYWRvbmx5UmVkdWNlclN0YXRlLFxuICBuZXh0VXJsOiBSZWFkb25seVJlZHVjZXJTdGF0ZVsnbmV4dFVybCddLFxuICB7IGFjdGlvbklkLCBhY3Rpb25BcmdzIH06IFNlcnZlckFjdGlvbkFjdGlvblxuKTogUHJvbWlzZTxGZXRjaFNlcnZlckFjdGlvblJlc3VsdD4ge1xuICBjb25zdCB0ZW1wb3JhcnlSZWZlcmVuY2VzID0gY3JlYXRlVGVtcG9yYXJ5UmVmZXJlbmNlU2V0KClcbiAgY29uc3QgaW5mbyA9IGV4dHJhY3RJbmZvRnJvbVNlcnZlclJlZmVyZW5jZUlkKGFjdGlvbklkKVxuXG4gIC8vIFRPRE86IEN1cnJlbnRseSwgd2UncmUgb25seSBvbWl0dGluZyB1bnVzZWQgYXJncyBmb3IgdGhlIGV4cGVyaW1lbnRhbCBcInVzZVxuICAvLyBjYWNoZVwiIGZ1bmN0aW9ucy4gT25jZSB0aGUgc2VydmVyIHJlZmVyZW5jZSBpbmZvIGJ5dGUgZmVhdHVyZSBpcyBzdGFibGUsIHdlXG4gIC8vIHNob3VsZCBhcHBseSB0aGlzIHRvIHNlcnZlciBhY3Rpb25zIGFzIHdlbGwuXG4gIGNvbnN0IHVzZWRBcmdzID1cbiAgICBpbmZvLnR5cGUgPT09ICd1c2UtY2FjaGUnID8gb21pdFVudXNlZEFyZ3MoYWN0aW9uQXJncywgaW5mbykgOiBhY3Rpb25BcmdzXG5cbiAgY29uc3QgYm9keSA9IGF3YWl0IGVuY29kZVJlcGx5KHVzZWRBcmdzLCB7IHRlbXBvcmFyeVJlZmVyZW5jZXMgfSlcblxuICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChzdGF0ZS5jYW5vbmljYWxVcmwsIHtcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICBoZWFkZXJzOiB7XG4gICAgICBBY2NlcHQ6IFJTQ19DT05URU5UX1RZUEVfSEVBREVSLFxuICAgICAgW0FDVElPTl9IRUFERVJdOiBhY3Rpb25JZCxcbiAgICAgIFtORVhUX1JPVVRFUl9TVEFURV9UUkVFX0hFQURFUl06IHByZXBhcmVGbGlnaHRSb3V0ZXJTdGF0ZUZvclJlcXVlc3QoXG4gICAgICAgIHN0YXRlLnRyZWVcbiAgICAgICksXG4gICAgICAuLi4ocHJvY2Vzcy5lbnYuTkVYVF9ERVBMT1lNRU5UX0lEXG4gICAgICAgID8ge1xuICAgICAgICAgICAgJ3gtZGVwbG95bWVudC1pZCc6IHByb2Nlc3MuZW52Lk5FWFRfREVQTE9ZTUVOVF9JRCxcbiAgICAgICAgICB9XG4gICAgICAgIDoge30pLFxuICAgICAgLi4uKG5leHRVcmxcbiAgICAgICAgPyB7XG4gICAgICAgICAgICBbTkVYVF9VUkxdOiBuZXh0VXJsLFxuICAgICAgICAgIH1cbiAgICAgICAgOiB7fSksXG4gICAgfSxcbiAgICBib2R5LFxuICB9KVxuXG4gIC8vIEhhbmRsZSBzZXJ2ZXIgYWN0aW9ucyB0aGF0IHRoZSBzZXJ2ZXIgZGlkbid0IHJlY29nbml6ZS5cbiAgY29uc3QgdW5yZWNvZ25pemVkQWN0aW9uSGVhZGVyID0gcmVzLmhlYWRlcnMuZ2V0KE5FWFRfQUNUSU9OX05PVF9GT1VORF9IRUFERVIpXG4gIGlmICh1bnJlY29nbml6ZWRBY3Rpb25IZWFkZXIgPT09ICcxJykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBTZXJ2ZXIgQWN0aW9uIFwiJHthY3Rpb25JZH1cIiB3YXMgbm90IGZvdW5kIG9uIHRoZSBzZXJ2ZXIuIFxcblJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvZmFpbGVkLXRvLWZpbmQtc2VydmVyLWFjdGlvbmBcbiAgICApXG4gIH1cblxuICBjb25zdCByZWRpcmVjdEhlYWRlciA9IHJlcy5oZWFkZXJzLmdldCgneC1hY3Rpb24tcmVkaXJlY3QnKVxuICBjb25zdCBbbG9jYXRpb24sIF9yZWRpcmVjdFR5cGVdID0gcmVkaXJlY3RIZWFkZXI/LnNwbGl0KCc7JykgfHwgW11cbiAgbGV0IHJlZGlyZWN0VHlwZTogUmVkaXJlY3RUeXBlIHwgdW5kZWZpbmVkXG4gIHN3aXRjaCAoX3JlZGlyZWN0VHlwZSkge1xuICAgIGNhc2UgJ3B1c2gnOlxuICAgICAgcmVkaXJlY3RUeXBlID0gUmVkaXJlY3RUeXBlLnB1c2hcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAncmVwbGFjZSc6XG4gICAgICByZWRpcmVjdFR5cGUgPSBSZWRpcmVjdFR5cGUucmVwbGFjZVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgcmVkaXJlY3RUeXBlID0gdW5kZWZpbmVkXG4gIH1cblxuICBjb25zdCBpc1ByZXJlbmRlciA9ICEhcmVzLmhlYWRlcnMuZ2V0KE5FWFRfSVNfUFJFUkVOREVSX0hFQURFUilcbiAgbGV0IHJldmFsaWRhdGVkUGFydHM6IEZldGNoU2VydmVyQWN0aW9uUmVzdWx0WydyZXZhbGlkYXRlZFBhcnRzJ11cbiAgdHJ5IHtcbiAgICBjb25zdCByZXZhbGlkYXRlZEhlYWRlciA9IEpTT04ucGFyc2UoXG4gICAgICByZXMuaGVhZGVycy5nZXQoJ3gtYWN0aW9uLXJldmFsaWRhdGVkJykgfHwgJ1tbXSwwLDBdJ1xuICAgIClcbiAgICByZXZhbGlkYXRlZFBhcnRzID0ge1xuICAgICAgcGF0aHM6IHJldmFsaWRhdGVkSGVhZGVyWzBdIHx8IFtdLFxuICAgICAgdGFnOiAhIXJldmFsaWRhdGVkSGVhZGVyWzFdLFxuICAgICAgY29va2llOiByZXZhbGlkYXRlZEhlYWRlclsyXSxcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXZhbGlkYXRlZFBhcnRzID0gTk9fUkVWQUxJREFURURfUEFSVFNcbiAgfVxuXG4gIGNvbnN0IHJlZGlyZWN0TG9jYXRpb24gPSBsb2NhdGlvblxuICAgID8gYXNzaWduTG9jYXRpb24oXG4gICAgICAgIGxvY2F0aW9uLFxuICAgICAgICBuZXcgVVJMKHN0YXRlLmNhbm9uaWNhbFVybCwgd2luZG93LmxvY2F0aW9uLmhyZWYpXG4gICAgICApXG4gICAgOiB1bmRlZmluZWRcblxuICBjb25zdCBjb250ZW50VHlwZSA9IHJlcy5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJylcbiAgY29uc3QgaXNSc2NSZXNwb25zZSA9ICEhKFxuICAgIGNvbnRlbnRUeXBlICYmIGNvbnRlbnRUeXBlLnN0YXJ0c1dpdGgoUlNDX0NPTlRFTlRfVFlQRV9IRUFERVIpXG4gIClcblxuICAvLyBIYW5kbGUgaW52YWxpZCBzZXJ2ZXIgYWN0aW9uIHJlc3BvbnNlcy5cbiAgLy8gQSB2YWxpZCByZXNwb25zZSBtdXN0IGhhdmUgYGNvbnRlbnQtdHlwZTogdGV4dC94LWNvbXBvbmVudGAsIHVubGVzcyBpdCdzIGFuIGV4dGVybmFsIHJlZGlyZWN0LlxuICAvLyAoZXh0ZXJuYWwgcmVkaXJlY3RzIGhhdmUgYW4gJ3gtYWN0aW9uLXJlZGlyZWN0JyBoZWFkZXIsIGJ1dCB0aGUgYm9keSBpcyBhbiBlbXB0eSAndGV4dC9wbGFpbicpXG4gIGlmICghaXNSc2NSZXNwb25zZSAmJiAhcmVkaXJlY3RMb2NhdGlvbikge1xuICAgIC8vIFRoZSBzZXJ2ZXIgY2FuIHJlc3BvbmQgd2l0aCBhIHRleHQvcGxhaW4gZXJyb3IgbWVzc2FnZSwgYnV0IHdlJ2xsIGZhbGxiYWNrIHRvIHNvbWV0aGluZyBnZW5lcmljXG4gICAgLy8gaWYgdGhlcmUgaXNuJ3Qgb25lLlxuICAgIGNvbnN0IG1lc3NhZ2UgPVxuICAgICAgcmVzLnN0YXR1cyA+PSA0MDAgJiYgY29udGVudFR5cGUgPT09ICd0ZXh0L3BsYWluJ1xuICAgICAgICA/IGF3YWl0IHJlcy50ZXh0KClcbiAgICAgICAgOiAnQW4gdW5leHBlY3RlZCByZXNwb25zZSB3YXMgcmVjZWl2ZWQgZnJvbSB0aGUgc2VydmVyLidcblxuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKVxuICB9XG5cbiAgbGV0IGFjdGlvblJlc3VsdDogRmV0Y2hTZXJ2ZXJBY3Rpb25SZXN1bHRbJ2FjdGlvblJlc3VsdCddXG4gIGxldCBhY3Rpb25GbGlnaHREYXRhOiBGZXRjaFNlcnZlckFjdGlvblJlc3VsdFsnYWN0aW9uRmxpZ2h0RGF0YSddXG4gIGlmIChpc1JzY1Jlc3BvbnNlKSB7XG4gICAgY29uc3QgcmVzcG9uc2U6IEFjdGlvbkZsaWdodFJlc3BvbnNlID0gYXdhaXQgY3JlYXRlRnJvbUZldGNoKFxuICAgICAgUHJvbWlzZS5yZXNvbHZlKHJlcyksXG4gICAgICB7IGNhbGxTZXJ2ZXIsIGZpbmRTb3VyY2VNYXBVUkwsIHRlbXBvcmFyeVJlZmVyZW5jZXMgfVxuICAgIClcbiAgICAvLyBBbiBpbnRlcm5hbCByZWRpcmVjdCBjYW4gc2VuZCBhbiBSU0MgcmVzcG9uc2UsIGJ1dCBkb2VzIG5vdCBoYXZlIGEgdXNlZnVsIGBhY3Rpb25SZXN1bHRgLlxuICAgIGFjdGlvblJlc3VsdCA9IHJlZGlyZWN0TG9jYXRpb24gPyB1bmRlZmluZWQgOiByZXNwb25zZS5hXG4gICAgYWN0aW9uRmxpZ2h0RGF0YSA9IG5vcm1hbGl6ZUZsaWdodERhdGEocmVzcG9uc2UuZilcbiAgfSBlbHNlIHtcbiAgICAvLyBBbiBleHRlcm5hbCByZWRpcmVjdCBkb2Vzbid0IGNvbnRhaW4gUlNDIGRhdGEuXG4gICAgYWN0aW9uUmVzdWx0ID0gdW5kZWZpbmVkXG4gICAgYWN0aW9uRmxpZ2h0RGF0YSA9IHVuZGVmaW5lZFxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBhY3Rpb25SZXN1bHQsXG4gICAgYWN0aW9uRmxpZ2h0RGF0YSxcbiAgICByZWRpcmVjdExvY2F0aW9uLFxuICAgIHJlZGlyZWN0VHlwZSxcbiAgICByZXZhbGlkYXRlZFBhcnRzLFxuICAgIGlzUHJlcmVuZGVyLFxuICB9XG59XG5cbmNvbnN0IE5PX1JFVkFMSURBVEVEX1BBUlRTID0ge1xuICBwYXRoczogW10sXG4gIHRhZzogZmFsc2UsXG4gIGNvb2tpZTogZmFsc2UsXG59XG5cbi8qXG4gKiBUaGlzIHJlZHVjZXIgaXMgcmVzcG9uc2libGUgZm9yIGNhbGxpbmcgdGhlIHNlcnZlciBhY3Rpb24gYW5kIHByb2Nlc3NpbmcgYW55IHNpZGUtZWZmZWN0cyBmcm9tIHRoZSBzZXJ2ZXIgYWN0aW9uLlxuICogSXQgZG9lcyBub3QgbXV0YXRlIHRoZSBzdGF0ZSBieSBpdHNlbGYgYnV0IHJhdGhlciBkZWxlZ2F0ZXMgdG8gb3RoZXIgcmVkdWNlcnMgdG8gZG8gdGhlIGFjdHVhbCBtdXRhdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlcnZlckFjdGlvblJlZHVjZXIoXG4gIHN0YXRlOiBSZWFkb25seVJlZHVjZXJTdGF0ZSxcbiAgYWN0aW9uOiBTZXJ2ZXJBY3Rpb25BY3Rpb25cbik6IFJlZHVjZXJTdGF0ZSB7XG4gIGNvbnN0IHsgcmVzb2x2ZSwgcmVqZWN0IH0gPSBhY3Rpb25cbiAgY29uc3QgbXV0YWJsZTogU2VydmVyQWN0aW9uTXV0YWJsZSA9IHt9XG5cbiAgbGV0IGN1cnJlbnRUcmVlID0gc3RhdGUudHJlZVxuXG4gIG11dGFibGUucHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGUgPSBmYWxzZVxuXG4gIC8vIG9ubHkgcGFzcyBhbG9uZyB0aGUgYG5leHRVcmxgIHBhcmFtICh1c2VkIGZvciBpbnRlcmNlcHRpb24gcm91dGVzKSBpZiB0aGUgY3VycmVudCByb3V0ZSB3YXMgaW50ZXJjZXB0ZWQuXG4gIC8vIElmIHRoZSByb3V0ZSBoYXMgYmVlbiBpbnRlcmNlcHRlZCwgdGhlIGFjdGlvbiBzaG91bGQgYmUgYXMgd2VsbC5cbiAgLy8gT3RoZXJ3aXNlIHRoZSBzZXJ2ZXIgYWN0aW9uIG1pZ2h0IGJlIGludGVyY2VwdGVkIHdpdGggdGhlIHdyb25nIGFjdGlvbiBpZFxuICAvLyAoaWUsIG9uZSB0aGF0IGNvcnJlc3BvbmRzIHdpdGggdGhlIGludGVyY2VwdGVkIHJvdXRlKVxuICBjb25zdCBuZXh0VXJsID1cbiAgICBzdGF0ZS5uZXh0VXJsICYmIGhhc0ludGVyY2VwdGlvblJvdXRlSW5DdXJyZW50VHJlZShzdGF0ZS50cmVlKVxuICAgICAgPyBzdGF0ZS5uZXh0VXJsXG4gICAgICA6IG51bGxcblxuICBjb25zdCBuYXZpZ2F0ZWRBdCA9IERhdGUubm93KClcblxuICByZXR1cm4gZmV0Y2hTZXJ2ZXJBY3Rpb24oc3RhdGUsIG5leHRVcmwsIGFjdGlvbikudGhlbihcbiAgICBhc3luYyAoe1xuICAgICAgYWN0aW9uUmVzdWx0LFxuICAgICAgYWN0aW9uRmxpZ2h0RGF0YTogZmxpZ2h0RGF0YSxcbiAgICAgIHJlZGlyZWN0TG9jYXRpb24sXG4gICAgICByZWRpcmVjdFR5cGUsXG4gICAgICBpc1ByZXJlbmRlcixcbiAgICAgIHJldmFsaWRhdGVkUGFydHMsXG4gICAgfSkgPT4ge1xuICAgICAgbGV0IHJlZGlyZWN0SHJlZjogc3RyaW5nIHwgdW5kZWZpbmVkXG5cbiAgICAgIC8vIGhvbm9yIHRoZSByZWRpcmVjdCB0eXBlIGluc3RlYWQgb2YgZGVmYXVsdGluZyB0byBwdXNoIGluIGNhc2Ugb2Ygc2VydmVyIGFjdGlvbnMuXG4gICAgICBpZiAocmVkaXJlY3RMb2NhdGlvbikge1xuICAgICAgICBpZiAocmVkaXJlY3RUeXBlID09PSBSZWRpcmVjdFR5cGUucmVwbGFjZSkge1xuICAgICAgICAgIHN0YXRlLnB1c2hSZWYucGVuZGluZ1B1c2ggPSBmYWxzZVxuICAgICAgICAgIG11dGFibGUucGVuZGluZ1B1c2ggPSBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlLnB1c2hSZWYucGVuZGluZ1B1c2ggPSB0cnVlXG4gICAgICAgICAgbXV0YWJsZS5wZW5kaW5nUHVzaCA9IHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZGlyZWN0SHJlZiA9IGNyZWF0ZUhyZWZGcm9tVXJsKHJlZGlyZWN0TG9jYXRpb24sIGZhbHNlKVxuICAgICAgICBtdXRhYmxlLmNhbm9uaWNhbFVybCA9IHJlZGlyZWN0SHJlZlxuICAgICAgfVxuXG4gICAgICBpZiAoIWZsaWdodERhdGEpIHtcbiAgICAgICAgcmVzb2x2ZShhY3Rpb25SZXN1bHQpXG5cbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSByZWRpcmVjdCBidXQgbm8gZmxpZ2h0IGRhdGEgd2UgbmVlZCB0byBkbyBhIG1wYU5hdmlnYXRpb24uXG4gICAgICAgIGlmIChyZWRpcmVjdExvY2F0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZUV4dGVybmFsVXJsKFxuICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICBtdXRhYmxlLFxuICAgICAgICAgICAgcmVkaXJlY3RMb2NhdGlvbi5ocmVmLFxuICAgICAgICAgICAgc3RhdGUucHVzaFJlZi5wZW5kaW5nUHVzaFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdGVcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBmbGlnaHREYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBIYW5kbGUgY2FzZSB3aGVuIG5hdmlnYXRpbmcgdG8gcGFnZSBpbiBgcGFnZXNgIGZyb20gYGFwcGBcbiAgICAgICAgcmVzb2x2ZShhY3Rpb25SZXN1bHQpXG5cbiAgICAgICAgcmV0dXJuIGhhbmRsZUV4dGVybmFsVXJsKFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIG11dGFibGUsXG4gICAgICAgICAgZmxpZ2h0RGF0YSxcbiAgICAgICAgICBzdGF0ZS5wdXNoUmVmLnBlbmRpbmdQdXNoXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgY29uc3QgYWN0aW9uUmV2YWxpZGF0ZWQgPVxuICAgICAgICByZXZhbGlkYXRlZFBhcnRzLnBhdGhzLmxlbmd0aCA+IDAgfHxcbiAgICAgICAgcmV2YWxpZGF0ZWRQYXJ0cy50YWcgfHxcbiAgICAgICAgcmV2YWxpZGF0ZWRQYXJ0cy5jb29raWVcblxuICAgICAgZm9yIChjb25zdCBub3JtYWxpemVkRmxpZ2h0RGF0YSBvZiBmbGlnaHREYXRhKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICB0cmVlOiB0cmVlUGF0Y2gsXG4gICAgICAgICAgc2VlZERhdGE6IGNhY2hlTm9kZVNlZWREYXRhLFxuICAgICAgICAgIGhlYWQsXG4gICAgICAgICAgaXNSb290UmVuZGVyLFxuICAgICAgICB9ID0gbm9ybWFsaXplZEZsaWdodERhdGFcblxuICAgICAgICBpZiAoIWlzUm9vdFJlbmRlcikge1xuICAgICAgICAgIC8vIFRPRE8tQVBQOiBoYW5kbGUgdGhpcyBjYXNlIGJldHRlclxuICAgICAgICAgIGNvbnNvbGUubG9nKCdTRVJWRVIgQUNUSU9OIEFQUExZIEZBSUxFRCcpXG4gICAgICAgICAgcmVzb2x2ZShhY3Rpb25SZXN1bHQpXG5cbiAgICAgICAgICByZXR1cm4gc3RhdGVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdpdmVuIHRoZSBwYXRoIGNhbiBvbmx5IGhhdmUgdHdvIGl0ZW1zIHRoZSBpdGVtcyBhcmUgb25seSB0aGUgcm91dGVyIHN0YXRlIGFuZCByc2MgZm9yIHRoZSByb290LlxuICAgICAgICBjb25zdCBuZXdUcmVlID0gYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlKFxuICAgICAgICAgIC8vIFRPRE8tQVBQOiByZW1vdmUgJydcbiAgICAgICAgICBbJyddLFxuICAgICAgICAgIGN1cnJlbnRUcmVlLFxuICAgICAgICAgIHRyZWVQYXRjaCxcbiAgICAgICAgICByZWRpcmVjdEhyZWYgPyByZWRpcmVjdEhyZWYgOiBzdGF0ZS5jYW5vbmljYWxVcmxcbiAgICAgICAgKVxuXG4gICAgICAgIGlmIChuZXdUcmVlID09PSBudWxsKSB7XG4gICAgICAgICAgcmVzb2x2ZShhY3Rpb25SZXN1bHQpXG5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlU2VnbWVudE1pc21hdGNoKHN0YXRlLCBhY3Rpb24sIHRyZWVQYXRjaClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQoY3VycmVudFRyZWUsIG5ld1RyZWUpKSB7XG4gICAgICAgICAgcmVzb2x2ZShhY3Rpb25SZXN1bHQpXG5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlRXh0ZXJuYWxVcmwoXG4gICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgIG11dGFibGUsXG4gICAgICAgICAgICByZWRpcmVjdEhyZWYgfHwgc3RhdGUuY2Fub25pY2FsVXJsLFxuICAgICAgICAgICAgc3RhdGUucHVzaFJlZi5wZW5kaW5nUHVzaFxuICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSBzZXJ2ZXIgc2VudCBiYWNrIFJTQyBkYXRhIGZvciB0aGUgc2VydmVyIGFjdGlvbiwgc28gd2UgbmVlZCB0byBhcHBseSBpdCB0byB0aGUgY2FjaGUuXG4gICAgICAgIGlmIChjYWNoZU5vZGVTZWVkRGF0YSAhPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IHJzYyA9IGNhY2hlTm9kZVNlZWREYXRhWzFdXG4gICAgICAgICAgY29uc3QgY2FjaGU6IENhY2hlTm9kZSA9IGNyZWF0ZUVtcHR5Q2FjaGVOb2RlKClcbiAgICAgICAgICBjYWNoZS5yc2MgPSByc2NcbiAgICAgICAgICBjYWNoZS5wcmVmZXRjaFJzYyA9IG51bGxcbiAgICAgICAgICBjYWNoZS5sb2FkaW5nID0gY2FjaGVOb2RlU2VlZERhdGFbM11cbiAgICAgICAgICBmaWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZChcbiAgICAgICAgICAgIG5hdmlnYXRlZEF0LFxuICAgICAgICAgICAgY2FjaGUsXG4gICAgICAgICAgICAvLyBFeGlzdGluZyBjYWNoZSBpcyBub3QgcGFzc2VkIGluIGFzIHNlcnZlciBhY3Rpb25zIGhhdmUgdG8gaW52YWxpZGF0ZSB0aGUgZW50aXJlIGNhY2hlLlxuICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgdHJlZVBhdGNoLFxuICAgICAgICAgICAgY2FjaGVOb2RlU2VlZERhdGEsXG4gICAgICAgICAgICBoZWFkLFxuICAgICAgICAgICAgdW5kZWZpbmVkXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgbXV0YWJsZS5jYWNoZSA9IGNhY2hlXG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfU0VHTUVOVF9DQUNIRSkge1xuICAgICAgICAgICAgcmV2YWxpZGF0ZUVudGlyZUNhY2hlKHN0YXRlLm5leHRVcmwsIG5ld1RyZWUpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG11dGFibGUucHJlZmV0Y2hDYWNoZSA9IG5ldyBNYXAoKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYWN0aW9uUmV2YWxpZGF0ZWQpIHtcbiAgICAgICAgICAgIGF3YWl0IHJlZnJlc2hJbmFjdGl2ZVBhcmFsbGVsU2VnbWVudHMoe1xuICAgICAgICAgICAgICBuYXZpZ2F0ZWRBdCxcbiAgICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICAgIHVwZGF0ZWRUcmVlOiBuZXdUcmVlLFxuICAgICAgICAgICAgICB1cGRhdGVkQ2FjaGU6IGNhY2hlLFxuICAgICAgICAgICAgICBpbmNsdWRlTmV4dFVybDogQm9vbGVhbihuZXh0VXJsKSxcbiAgICAgICAgICAgICAgY2Fub25pY2FsVXJsOiBtdXRhYmxlLmNhbm9uaWNhbFVybCB8fCBzdGF0ZS5jYW5vbmljYWxVcmwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG11dGFibGUucGF0Y2hlZFRyZWUgPSBuZXdUcmVlXG4gICAgICAgIGN1cnJlbnRUcmVlID0gbmV3VHJlZVxuICAgICAgfVxuXG4gICAgICBpZiAocmVkaXJlY3RMb2NhdGlvbiAmJiByZWRpcmVjdEhyZWYpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1NFR01FTlRfQ0FDSEUgJiYgIWFjdGlvblJldmFsaWRhdGVkKSB7XG4gICAgICAgICAgLy8gQmVjYXVzZSB0aGUgUmVkaXJlY3RCb3VuZGFyeSB3aWxsIHRyaWdnZXIgYSBuYXZpZ2F0aW9uLCB3ZSBuZWVkIHRvIHNlZWQgdGhlIHByZWZldGNoIGNhY2hlXG4gICAgICAgICAgLy8gd2l0aCB0aGUgRmxpZ2h0RGF0YSB0aGF0IHdlIGdvdCBmcm9tIHRoZSBzZXJ2ZXIgYWN0aW9uIGZvciB0aGUgdGFyZ2V0IHBhZ2UsIHNvIHRoYXQgaXQnc1xuICAgICAgICAgIC8vIGF2YWlsYWJsZSB3aGVuIHRoZSBwYWdlIGlzIG5hdmlnYXRlZCB0byBhbmQgZG9lc24ndCBuZWVkIHRvIGJlIHJlLWZldGNoZWQuXG4gICAgICAgICAgLy8gV2Ugb25seSBkbyB0aGlzIGlmIHRoZSBzZXJ2ZXIgYWN0aW9uIGRpZG4ndCByZXZhbGlkYXRlIGFueSBkYXRhLCBhcyBpbiB0aGF0IGNhc2UgdGhlXG4gICAgICAgICAgLy8gY2xpZW50IGNhY2hlIHdpbGwgYmUgY2xlYXJlZCBhbmQgdGhlIGRhdGEgd2lsbCBiZSByZS1mZXRjaGVkIGFueXdheS5cbiAgICAgICAgICAvLyBOT1RFOiBXZSBkb24ndCBkbyB0aGlzIGluIHRoZSBTZWdtZW50IENhY2hlIGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIC8vIER5bmFtaWMgZGF0YSBzaG91bGQgbmV2ZXIgYmUgcGxhY2VkIGludG8gdGhlIGNhY2hlLCB1bmxlc3MgaXQnc1xuICAgICAgICAgIC8vIFwiY29udmVydGVkXCIgdG8gc3RhdGljIGRhdGEgdXNpbmcgPExpbmsgcHJlZmV0Y2g9e3RydWV9Pi4gV2hhdCB3ZVxuICAgICAgICAgIC8vIGRvIGluc3RlYWQgaXMgcmUtcHJlZmV0Y2ggbGlua3MgYW5kIGZvcm1zIHdoZW5ldmVyIHRoZSBjYWNoZSBpc1xuICAgICAgICAgIC8vIGludmFsaWRhdGVkLlxuICAgICAgICAgIGNyZWF0ZVNlZWRlZFByZWZldGNoQ2FjaGVFbnRyeSh7XG4gICAgICAgICAgICB1cmw6IHJlZGlyZWN0TG9jYXRpb24sXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIGZsaWdodERhdGEsXG4gICAgICAgICAgICAgIGNhbm9uaWNhbFVybDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICBjb3VsZEJlSW50ZXJjZXB0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICBwcmVyZW5kZXJlZDogZmFsc2UsXG4gICAgICAgICAgICAgIHBvc3Rwb25lZDogZmFsc2UsXG4gICAgICAgICAgICAgIC8vIFRPRE86IFdlIHNob3VsZCBiZSBhYmxlIHRvIHNldCB0aGlzIGlmIHRoZSBzZXJ2ZXIgYWN0aW9uXG4gICAgICAgICAgICAgIC8vIHJldHVybmVkIGEgZnVsbHkgc3RhdGljIHJlc3BvbnNlLlxuICAgICAgICAgICAgICBzdGFsZVRpbWU6IC0xLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRyZWU6IHN0YXRlLnRyZWUsXG4gICAgICAgICAgICBwcmVmZXRjaENhY2hlOiBzdGF0ZS5wcmVmZXRjaENhY2hlLFxuICAgICAgICAgICAgbmV4dFVybDogc3RhdGUubmV4dFVybCxcbiAgICAgICAgICAgIGtpbmQ6IGlzUHJlcmVuZGVyID8gUHJlZmV0Y2hLaW5kLkZVTEwgOiBQcmVmZXRjaEtpbmQuQVVUTyxcbiAgICAgICAgICB9KVxuICAgICAgICAgIG11dGFibGUucHJlZmV0Y2hDYWNoZSA9IHN0YXRlLnByZWZldGNoQ2FjaGVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZSBhY3Rpb24gdHJpZ2dlcmVkIGEgcmVkaXJlY3QsIHRoZSBhY3Rpb24gcHJvbWlzZSB3aWxsIGJlIHJlamVjdGVkIHdpdGhcbiAgICAgICAgLy8gYSByZWRpcmVjdCBzbyB0aGF0IGl0J3MgaGFuZGxlZCBieSBSZWRpcmVjdEJvdW5kYXJ5IGFzIHdlIHdvbid0IGhhdmUgYSB2YWxpZFxuICAgICAgICAvLyBhY3Rpb24gcmVzdWx0IHRvIHJlc29sdmUgdGhlIHByb21pc2Ugd2l0aC4gVGhpcyB3aWxsIGVmZmVjdGl2ZWx5IHJlc2V0IHRoZSBzdGF0ZSBvZlxuICAgICAgICAvLyB0aGUgY29tcG9uZW50IHRoYXQgY2FsbGVkIHRoZSBhY3Rpb24gYXMgdGhlIGVycm9yIGJvdW5kYXJ5IHdpbGwgcmVtb3VudCB0aGUgdHJlZS5cbiAgICAgICAgLy8gVGhlIHN0YXR1cyBjb2RlIGRvZXNuJ3QgbWF0dGVyIGhlcmUgYXMgdGhlIGFjdGlvbiBoYW5kbGVyIHdpbGwgaGF2ZSBhbHJlYWR5IHNlbnRcbiAgICAgICAgLy8gYSByZXNwb25zZSB3aXRoIHRoZSBjb3JyZWN0IHN0YXR1cyBjb2RlLlxuICAgICAgICByZWplY3QoXG4gICAgICAgICAgZ2V0UmVkaXJlY3RFcnJvcihcbiAgICAgICAgICAgIGhhc0Jhc2VQYXRoKHJlZGlyZWN0SHJlZilcbiAgICAgICAgICAgICAgPyByZW1vdmVCYXNlUGF0aChyZWRpcmVjdEhyZWYpXG4gICAgICAgICAgICAgIDogcmVkaXJlY3RIcmVmLFxuICAgICAgICAgICAgcmVkaXJlY3RUeXBlIHx8IFJlZGlyZWN0VHlwZS5wdXNoXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKGFjdGlvblJlc3VsdClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhbmRsZU11dGFibGUoc3RhdGUsIG11dGFibGUpXG4gICAgfSxcbiAgICAoZTogYW55KSA9PiB7XG4gICAgICAvLyBXaGVuIHRoZSBzZXJ2ZXIgYWN0aW9uIGlzIHJlamVjdGVkIHdlIGRvbid0IHVwZGF0ZSB0aGUgc3RhdGUgYW5kIGluc3RlYWQgY2FsbCB0aGUgcmVqZWN0IGhhbmRsZXIgb2YgdGhlIHByb21pc2UuXG4gICAgICByZWplY3QoZSlcblxuICAgICAgcmV0dXJuIHN0YXRlXG4gICAgfVxuICApXG59XG4iXSwibmFtZXMiOlsic2VydmVyQWN0aW9uUmVkdWNlciIsImNyZWF0ZUZyb21GZXRjaCIsImNyZWF0ZUZyb21GZXRjaEJyb3dzZXIiLCJmZXRjaFNlcnZlckFjdGlvbiIsInN0YXRlIiwibmV4dFVybCIsImFjdGlvbklkIiwiYWN0aW9uQXJncyIsInRlbXBvcmFyeVJlZmVyZW5jZXMiLCJjcmVhdGVUZW1wb3JhcnlSZWZlcmVuY2VTZXQiLCJpbmZvIiwiZXh0cmFjdEluZm9Gcm9tU2VydmVyUmVmZXJlbmNlSWQiLCJ1c2VkQXJncyIsInR5cGUiLCJvbWl0VW51c2VkQXJncyIsImJvZHkiLCJlbmNvZGVSZXBseSIsInJlcyIsImZldGNoIiwiY2Fub25pY2FsVXJsIiwibWV0aG9kIiwiaGVhZGVycyIsIkFjY2VwdCIsIlJTQ19DT05URU5UX1RZUEVfSEVBREVSIiwiQUNUSU9OX0hFQURFUiIsIk5FWFRfUk9VVEVSX1NUQVRFX1RSRUVfSEVBREVSIiwicHJlcGFyZUZsaWdodFJvdXRlclN0YXRlRm9yUmVxdWVzdCIsInRyZWUiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9ERVBMT1lNRU5UX0lEIiwiTkVYVF9VUkwiLCJ1bnJlY29nbml6ZWRBY3Rpb25IZWFkZXIiLCJnZXQiLCJORVhUX0FDVElPTl9OT1RfRk9VTkRfSEVBREVSIiwiRXJyb3IiLCJyZWRpcmVjdEhlYWRlciIsImxvY2F0aW9uIiwiX3JlZGlyZWN0VHlwZSIsInNwbGl0IiwicmVkaXJlY3RUeXBlIiwiUmVkaXJlY3RUeXBlIiwicHVzaCIsInJlcGxhY2UiLCJ1bmRlZmluZWQiLCJpc1ByZXJlbmRlciIsIk5FWFRfSVNfUFJFUkVOREVSX0hFQURFUiIsInJldmFsaWRhdGVkUGFydHMiLCJyZXZhbGlkYXRlZEhlYWRlciIsIkpTT04iLCJwYXJzZSIsInBhdGhzIiwidGFnIiwiY29va2llIiwiZSIsIk5PX1JFVkFMSURBVEVEX1BBUlRTIiwicmVkaXJlY3RMb2NhdGlvbiIsImFzc2lnbkxvY2F0aW9uIiwiVVJMIiwid2luZG93IiwiaHJlZiIsImNvbnRlbnRUeXBlIiwiaXNSc2NSZXNwb25zZSIsInN0YXJ0c1dpdGgiLCJtZXNzYWdlIiwic3RhdHVzIiwidGV4dCIsImFjdGlvblJlc3VsdCIsImFjdGlvbkZsaWdodERhdGEiLCJyZXNwb25zZSIsIlByb21pc2UiLCJyZXNvbHZlIiwiY2FsbFNlcnZlciIsImZpbmRTb3VyY2VNYXBVUkwiLCJhIiwibm9ybWFsaXplRmxpZ2h0RGF0YSIsImYiLCJhY3Rpb24iLCJyZWplY3QiLCJtdXRhYmxlIiwiY3VycmVudFRyZWUiLCJwcmVzZXJ2ZUN1c3RvbUhpc3RvcnlTdGF0ZSIsImhhc0ludGVyY2VwdGlvblJvdXRlSW5DdXJyZW50VHJlZSIsIm5hdmlnYXRlZEF0IiwiRGF0ZSIsIm5vdyIsInRoZW4iLCJmbGlnaHREYXRhIiwicmVkaXJlY3RIcmVmIiwicHVzaFJlZiIsInBlbmRpbmdQdXNoIiwiY3JlYXRlSHJlZkZyb21VcmwiLCJoYW5kbGVFeHRlcm5hbFVybCIsImFjdGlvblJldmFsaWRhdGVkIiwibGVuZ3RoIiwibm9ybWFsaXplZEZsaWdodERhdGEiLCJ0cmVlUGF0Y2giLCJzZWVkRGF0YSIsImNhY2hlTm9kZVNlZWREYXRhIiwiaGVhZCIsImlzUm9vdFJlbmRlciIsImNvbnNvbGUiLCJsb2ciLCJuZXdUcmVlIiwiYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlIiwiaGFuZGxlU2VnbWVudE1pc21hdGNoIiwiaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0IiwicnNjIiwiY2FjaGUiLCJjcmVhdGVFbXB0eUNhY2hlTm9kZSIsInByZWZldGNoUnNjIiwibG9hZGluZyIsImZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkIiwiX19ORVhUX0NMSUVOVF9TRUdNRU5UX0NBQ0hFIiwicmV2YWxpZGF0ZUVudGlyZUNhY2hlIiwicHJlZmV0Y2hDYWNoZSIsIk1hcCIsInJlZnJlc2hJbmFjdGl2ZVBhcmFsbGVsU2VnbWVudHMiLCJ1cGRhdGVkVHJlZSIsInVwZGF0ZWRDYWNoZSIsImluY2x1ZGVOZXh0VXJsIiwiQm9vbGVhbiIsInBhdGNoZWRUcmVlIiwiY3JlYXRlU2VlZGVkUHJlZmV0Y2hDYWNoZUVudHJ5IiwidXJsIiwiZGF0YSIsImNvdWxkQmVJbnRlcmNlcHRlZCIsInByZXJlbmRlcmVkIiwicG9zdHBvbmVkIiwic3RhbGVUaW1lIiwia2luZCIsIlByZWZldGNoS2luZCIsIkZVTEwiLCJBVVRPIiwiZ2V0UmVkaXJlY3RFcnJvciIsImhhc0Jhc2VQYXRoIiwicmVtb3ZlQmFzZVBhdGgiLCJoYW5kbGVNdXRhYmxlIl0sIm1hcHBpbmdzIjoiOzs7K0JBbU5nQkEsdUJBQUFBOzs7ZUFBQUE7OzsrQkEvTVc7cUNBQ007a0NBUTFCO3dCQVFBO29DQVFBO2dDQUN3QjttQ0FDRztpQ0FDQTs2Q0FDVTs2Q0FDQTsrQkFFZDsrQ0FDZ0I7MkJBQ1Q7bURBQ2E7dUNBQ1o7aURBQ1U7bUNBS3pDOzBCQUMwQjsrQkFDSjtvQ0FDa0I7Z0NBQ2hCOzZCQUNIO3FDQUlyQjs4QkFDK0I7QUFFdEMsTUFBTUMsa0JBQ0pDLFFBQUFBLGVBQXNCO0FBZXhCLGVBQWVDLGtCQUNiQyxLQUEyQixFQUMzQkMsT0FBd0MsRUFDeEMsS0FBNEM7SUFBNUMsSUFBQSxFQUFFQyxRQUFRLEVBQUVDLFVBQVUsRUFBc0IsR0FBNUM7SUFFQSxNQUFN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Q2hCd0YsZUFBZS9HLE1BQU0rRyxhQUFhO29CQUNsQzlHLFNBQVNELE1BQU1DLE9BQU87b0JBQ3RCNkgsTUFBTXJGLGNBQWNzRixvQkFBQUEsWUFBWSxDQUFDQyxJQUFJLEdBQUdELG9CQUFBQSxZQUFZLENBQUNFLElBQUk7Z0JBQzNEO2dCQUNBdEQsUUFBUW9DLGFBQWEsR0FBRy9HLE1BQU0rRyxhQUFhO1lBQzdDO1lBRUEsK0VBQStFO1lBQy9FLCtFQUErRTtZQUMvRSxzRkFBc0Y7WUFDdEYsb0ZBQW9GO1lBQ3BGLG1GQUFtRjtZQUNuRiwyQ0FBMkM7WUFDM0NyQyxPQUNFd0QsQ0FBQUEsR0FBQUEsVUFBQUEsZ0JBQWdCLEVBQ2RDLENBQUFBLEdBQUFBLGFBQUFBLFdBQVcsRUFBQy9DLGdCQUNSZ0QsQ0FBQUEsR0FBQUEsZ0JBQUFBLGNBQWMsRUFBQ2hELGdCQUNmQSxjQUNKaEQsZ0JBQWdCQyxlQUFBQSxZQUFZLENBQUNDLElBQUk7UUFHdkMsT0FBTztZQUNMNkIsUUFBUUo7UUFDVjtRQUVBLE9BQU9zRSxDQUFBQSxHQUFBQSxlQUFBQSxhQUFhLEVBQUNySSxPQUFPMkU7SUFDOUIsR0FDQSxDQUFDekI7UUFDQyxtSEFBbUg7UUFDbkh3QixPQUFPeEI7UUFFUCxPQUFPbEQ7SUFDVDtBQUVKIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDEyMjk0LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JvdXRlci1yZWR1Y2VyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEFDVElPTl9OQVZJR0FURSxcbiAgQUNUSU9OX1NFUlZFUl9QQVRDSCxcbiAgQUNUSU9OX1JFU1RPUkUsXG4gIEFDVElPTl9SRUZSRVNILFxuICBBQ1RJT05fUFJFRkVUQ0gsXG4gIEFDVElPTl9ITVJfUkVGUkVTSCxcbiAgQUNUSU9OX1NFUlZFUl9BQ1RJT04sXG59IGZyb20gJy4vcm91dGVyLXJlZHVjZXItdHlwZXMnXG5pbXBvcnQgdHlwZSB7XG4gIFJlZHVjZXJBY3Rpb25zLFxuICBSZWR1Y2VyU3RhdGUsXG4gIFJlYWRvbmx5UmVkdWNlclN0YXRlLFxufSBmcm9tICcuL3JvdXRlci1yZWR1Y2VyLXR5cGVzJ1xuaW1wb3J0IHsgbmF2aWdhdGVSZWR1Y2VyIH0gZnJvbSAnLi9yZWR1Y2Vycy9uYXZpZ2F0ZS1yZWR1Y2VyJ1xuaW1wb3J0IHsgc2VydmVyUGF0Y2hSZWR1Y2VyIH0gZnJvbSAnLi9yZWR1Y2Vycy9zZXJ2ZXItcGF0Y2gtcmVkdWNlcidcbmltcG9ydCB7IHJlc3RvcmVSZWR1Y2VyIH0gZnJvbSAnLi9yZWR1Y2Vycy9yZXN0b3JlLXJlZHVjZXInXG5pbXBvcnQgeyByZWZyZXNoUmVkdWNlciB9IGZyb20gJy4vcmVkdWNlcnMvcmVmcmVzaC1yZWR1Y2VyJ1xuaW1wb3J0IHsgcHJlZmV0Y2hSZWR1Y2VyIH0gZnJvbSAnLi9yZWR1Y2Vycy9wcmVmZXRjaC1yZWR1Y2VyJ1xuaW1wb3J0IHsgaG1yUmVmcmVzaFJlZHVjZXIgfSBmcm9tICcuL3JlZHVjZXJzL2htci1yZWZyZXNoLXJlZHVjZXInXG5pbXBvcnQgeyBzZXJ2ZXJBY3Rpb25SZWR1Y2VyIH0gZnJvbSAnLi9yZWR1Y2Vycy9zZXJ2ZXItYWN0aW9uLXJlZHVjZXInXG5cbi8qKlxuICogUmVkdWNlciB0aGF0IGhhbmRsZXMgdGhlIGFwcC1yb3V0ZXIgc3RhdGUgdXBkYXRlcy5cbiAqL1xuZnVuY3Rpb24gY2xpZW50UmVkdWNlcihcbiAgc3RhdGU6IFJlYWRvbmx5UmVkdWNlclN0YXRlLFxuICBhY3Rpb246IFJlZHVjZXJBY3Rpb25zXG4pOiBSZWR1Y2VyU3RhdGUge1xuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSBBQ1RJT05fTkFWSUdBVEU6IHtcbiAgICAgIHJldHVybiBuYXZpZ2F0ZVJlZHVjZXIoc3RhdGUsIGFjdGlvbilcbiAgICB9XG4gICAgY2FzZSBBQ1RJT05fU0VSVkVSX1BBVENIOiB7XG4gICAgICByZXR1cm4gc2VydmVyUGF0Y2hSZWR1Y2VyKHN0YXRlLCBhY3Rpb24pXG4gICAgfVxuICAgIGNhc2UgQUNUSU9OX1JFU1RPUkU6IHtcbiAgICAgIHJldHVybiByZXN0b3JlUmVkdWNlcihzdGF0ZSwgYWN0aW9uKVxuICAgIH1cbiAgICBjYXNlIEFDVElPTl9SRUZSRVNIOiB7XG4gICAgICByZXR1cm4gcmVmcmVzaFJlZHVjZXIoc3RhdGUsIGFjdGlvbilcbiAgICB9XG4gICAgY2FzZSBBQ1RJT05fSE1SX1JFRlJFU0g6IHtcbiAgICAgIHJldHVybiBobXJSZWZyZXNoUmVkdWNlcihzdGF0ZSwgYWN0aW9uKVxuICAgIH1cbiAgICBjYXNlIEFDVElPTl9QUkVGRVRDSDoge1xuICAgICAgcmV0dXJuIHByZWZldGNoUmVkdWNlcihzdGF0ZSwgYWN0aW9uKVxuICAgIH1cbiAgICBjYXNlIEFDVElPTl9TRVJWRVJfQUNUSU9OOiB7XG4gICAgICByZXR1cm4gc2VydmVyQWN0aW9uUmVkdWNlcihzdGF0ZSwgYWN0aW9uKVxuICAgIH1cbiAgICAvLyBUaGlzIGNhc2Ugc2hvdWxkIG5ldmVyIGJlIGhpdCBhcyBkaXNwYXRjaCBpcyBzdHJvbmdseSB0eXBlZC5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGFjdGlvbicpXG4gIH1cbn1cblxuZnVuY3Rpb24gc2VydmVyUmVkdWNlcihcbiAgc3RhdGU6IFJlYWRvbmx5UmVkdWNlclN0YXRlLFxuICBfYWN0aW9uOiBSZWR1Y2VyQWN0aW9uc1xuKTogUmVkdWNlclN0YXRlIHtcbiAgcmV0dXJuIHN0YXRlXG59XG5cbi8vIHdlIGRvbid0IHJ1biB0aGUgY2xpZW50IHJlZHVjZXIgb24gdGhlIHNlcnZlciwgc28gd2UgdXNlIGEgbm9vcCBmdW5jdGlvbiBmb3IgYmV0dGVyIHRyZWUgc2hha2luZ1xuZXhwb3J0IGNvbnN0IHJlZHVjZXIgPVxuICB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IHNlcnZlclJlZHVjZXIgOiBjbGllbnRSZWR1Y2VyXG4iXSwibmFtZXMiOlsicmVkdWNlciIsImNsaWVudFJlZHVjZXIiLCJzdGF0ZSIsImFjdGlvbiIsInR5cGUiLCJBQ1RJT05fTkFWSUdBVEUiLCJuYXZpZ2F0ZVJlZHVjZXIiLCJBQ1RJT05fU0VSVkVSX1BBVENIIiwic2VydmVyUGF0Y2hSZWR1Y2VyIiwiQUNUSU9OX1JFU1RPUkUiLCJyZXN0b3JlUmVkdWNlciIsIkFDVElPTl9SRUZSRVNIIiwicmVmcmVzaFJlZHVjZXIiLCJBQ1RJT05fSE1SX1JFRlJFU0giLCJobXJSZWZyZXNoUmVkdWNlciIsIkFDVElPTl9QUkVGRVRDSCIsInByZWZldGNoUmVkdWNlciIsIkFDVElPTl9TRVJWRVJfQUNUSU9OIiwic2VydmVyQWN0aW9uUmVkdWNlciIsIkVycm9yIiwic2VydmVyUmVkdWNlciIsIl9hY3Rpb24iLCJ3aW5kb3ciXSwibWFwcGluZ3MiOiI7OzsrQkFpRWFBLFdBQUFBOzs7ZUFBQUE7OztvQ0F6RE47aUNBTXlCO29DQUNHO2dDQUNKO2dDQUNBO2lDQUNDO21DQUNFO3FDQUNFO0FBRXBDOztDQUVDLEdBQ0QsU0FBU0MsY0FDUEMsS0FBMkIsRUFDM0JDLE1BQXNCO0lBRXRCLE9BQVFBLE9BQU9DLElBQUk7UUFDakIsS0FBS0Msb0JBQUFBLGVBQWU7WUFBRTtnQkFDcEIsT0FBT0MsQ0FBQUEsR0FBQUEsaUJBQUFBLGVBQWUsRUFBQ0osT0FBT0M7WUFDaEM7UUFDQSxLQUFLSSxvQkFBQUEsbUJBQW1CO1lBQUU7Z0JBQ3hCLE9BQU9DLENBQUFBLEdBQUFBLG9CQUFBQSxrQkFBa0IsRUFBQ04sT0FBT0M7WUFDbkM7UUFDQSxLQUFLTSxvQkFBQUEsY0FBYztZQUFFO2dCQUNuQixPQUFPQyxDQUFBQSxHQUFBQSxnQkFBQUEsY0FBYyxFQUFDUixPQUFPQztZQUMvQjtRQUNBLEtBQUtRLG9CQUFBQSxjQUFjO1lBQUU7Z0JBQ25CLE9BQU9DLENBQUFBLEdBQUFBLGdCQUFBQSxjQUFjLEVBQUNWLE9BQU9DO1lBQy9CO1FBQ0EsS0FBS1Usb0JBQUFBLGtCQUFrQjtZQUFFO2dCQUN2QixPQUFPQyxDQUFBQSxHQUFBQSxtQkFBQUEsaUJBQWlCLEVBQUNaLE9BQU9DO1lBQ2xDO1FBQ0EsS0FBS1ksb0JBQUFBLGVBQWU7WUFBRTtnQkFDcEIsT0FBT0MsQ0FBQUEsR0FBQUEsaUJBQUFBLGVBQWUsRUFBQ2QsT0FBT0M7WUFDaEM7UUFDQSxLQUFLYyxvQkFBQUEsb0JBQW9CO1lBQUU7Z0JBQ3pCLE9BQU9DLENBQUFBLEdBQUFBLHFCQUFBQSxtQkFBbUIsRUFBQ2hCLE9BQU9DO1lBQ3BDO1FBQ0EsK0RBQStEO1FBQy9EO1lBQ0UsTUFBTSxPQUFBLGNBQTJCLENBQTNCLElBQUlnQixNQUFNLG1CQUFWLHFCQUFBO3VCQUFBOzRCQUFBOzhCQUFBO1lBQTBCO0lBQ3BDO0FBQ0Y7QUFFQSxTQUFTQyxjQUNQbEIsS0FBMkIsRUFDM0JtQixPQUF1QjtJQUV2QixPQUFPbkI7QUFDVDtBQUdPLE1BQU1GLFVBQ1gsT0FBT3NCLFdBQVcscUJBQWNGLGdCQUFnQm5CIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDEyMzY5LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2NsaWVudC9jb21wb25lbnRzL2FwcC1yb3V0ZXItaW5zdGFuY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgdHlwZSBBcHBSb3V0ZXJTdGF0ZSxcbiAgdHlwZSBSZWR1Y2VyQWN0aW9ucyxcbiAgdHlwZSBSZWR1Y2VyU3RhdGUsXG4gIEFDVElPTl9SRUZSRVNILFxuICBBQ1RJT05fU0VSVkVSX0FDVElPTixcbiAgQUNUSU9OX05BVklHQVRFLFxuICBBQ1RJT05fUkVTVE9SRSxcbiAgdHlwZSBOYXZpZ2F0ZUFjdGlvbixcbiAgQUNUSU9OX0hNUl9SRUZSRVNILFxuICBQcmVmZXRjaEtpbmQsXG4gIEFDVElPTl9QUkVGRVRDSCxcbn0gZnJvbSAnLi9yb3V0ZXItcmVkdWNlci9yb3V0ZXItcmVkdWNlci10eXBlcydcbmltcG9ydCB7IHJlZHVjZXIgfSBmcm9tICcuL3JvdXRlci1yZWR1Y2VyL3JvdXRlci1yZWR1Y2VyJ1xuaW1wb3J0IHsgc3RhcnRUcmFuc2l0aW9uIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBpc1RoZW5hYmxlIH0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi9pcy10aGVuYWJsZSdcbmltcG9ydCB7IHByZWZldGNoIGFzIHByZWZldGNoV2l0aFNlZ21lbnRDYWNoZSB9IGZyb20gJy4vc2VnbWVudC1jYWNoZSdcbmltcG9ydCB7IGRpc3BhdGNoQXBwUm91dGVyQWN0aW9uIH0gZnJvbSAnLi91c2UtYWN0aW9uLXF1ZXVlJ1xuaW1wb3J0IHsgYWRkQmFzZVBhdGggfSBmcm9tICcuLi9hZGQtYmFzZS1wYXRoJ1xuaW1wb3J0IHsgY3JlYXRlUHJlZmV0Y2hVUkwsIGlzRXh0ZXJuYWxVUkwgfSBmcm9tICcuL2FwcC1yb3V0ZXInXG5pbXBvcnQgeyBwcmVmZXRjaFJlZHVjZXIgfSBmcm9tICcuL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL3ByZWZldGNoLXJlZHVjZXInXG5pbXBvcnQgdHlwZSB7XG4gIEFwcFJvdXRlckluc3RhbmNlLFxuICBOYXZpZ2F0ZU9wdGlvbnMsXG4gIFByZWZldGNoT3B0aW9ucyxcbn0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgeyBzZXRMaW5rRm9yQ3VycmVudE5hdmlnYXRpb24sIHR5cGUgTGlua0luc3RhbmNlIH0gZnJvbSAnLi9saW5rcydcbmltcG9ydCB0eXBlIHsgRmxpZ2h0Um91dGVyU3RhdGUgfSBmcm9tICcuLi8uLi9zZXJ2ZXIvYXBwLXJlbmRlci90eXBlcydcbmltcG9ydCB0eXBlIHsgQ2xpZW50SW5zdHJ1bWVudGF0aW9uSG9va3MgfSBmcm9tICcuLi9hcHAtaW5kZXgnXG5pbXBvcnQgdHlwZSB7IEdsb2JhbEVycm9yQ29tcG9uZW50IH0gZnJvbSAnLi9idWlsdGluL2dsb2JhbC1lcnJvcidcblxuZXhwb3J0IHR5cGUgRGlzcGF0Y2hTdGF0ZVByb21pc2UgPSBSZWFjdC5EaXNwYXRjaDxSZWR1Y2VyU3RhdGU+XG5cbmV4cG9ydCB0eXBlIEFwcFJvdXRlckFjdGlvblF1ZXVlID0ge1xuICBzdGF0ZTogQXBwUm91dGVyU3RhdGVcbiAgZGlzcGF0Y2g6IChwYXlsb2FkOiBSZWR1Y2VyQWN0aW9ucywgc2V0U3RhdGU6IERpc3BhdGNoU3RhdGVQcm9taXNlKSA9PiB2b2lkXG4gIGFjdGlvbjogKHN0YXRlOiBBcHBSb3V0ZXJTdGF0ZSwgYWN0aW9uOiBSZWR1Y2VyQWN0aW9ucykgPT4gUmVkdWNlclN0YXRlXG5cbiAgb25Sb3V0ZXJUcmFuc2l0aW9uU3RhcnQ6XG4gICAgfCAoKHVybDogc3RyaW5nLCB0eXBlOiAncHVzaCcgfCAncmVwbGFjZScgfCAndHJhdmVyc2UnKSA9PiB2b2lkKVxuICAgIHwgbnVsbFxuXG4gIHBlbmRpbmc6IEFjdGlvblF1ZXVlTm9kZSB8IG51bGxcbiAgbmVlZHNSZWZyZXNoPzogYm9vbGVhblxuICBsYXN0OiBBY3Rpb25RdWV1ZU5vZGUgfCBudWxsXG59XG5cbmV4cG9ydCB0eXBlIEdsb2JhbEVycm9yU3RhdGUgPSBbXG4gIEdsb2JhbEVycm9yOiBHbG9iYWxFcnJvckNvbXBvbmVudCxcbiAgc3R5bGVzOiBSZWFjdC5SZWFjdE5vZGUsXG5dXG5cbmV4cG9ydCB0eXBlIEFjdGlvblF1ZXVlTm9kZSA9IHtcbiAgcGF5bG9hZDogUmVkdWNlckFjdGlvbnNcbiAgbmV4dDogQWN0aW9uUXVldWVOb2RlIHwgbnVsbFxuICByZXNvbHZlOiAodmFsdWU6IFJlZHVjZXJTdGF0ZSkgPT4gdm9pZFxuICByZWplY3Q6IChlcnI6IEVycm9yKSA9PiB2b2lkXG4gIGRpc2NhcmRlZD86IGJvb2xlYW5cbn1cblxuZnVuY3Rpb24gcnVuUmVtYWluaW5nQWN0aW9ucyhcbiAgYWN0aW9uUXVldWU6IEFwcFJvdXRlckFjdGlvblF1ZXVlLFxuICBzZXRTdGF0ZTogRGlzcGF0Y2hTdGF0ZVByb21pc2Vcbikge1xuICBpZiAoYWN0aW9uUXVldWUucGVuZGluZyAhPT0gbnVsbCkge1xuICAgIGFjdGlvblF1ZXVlLnBlbmRpbmcgPSBhY3Rpb25RdWV1ZS5wZW5kaW5nLm5leHRcbiAgICBpZiAoYWN0aW9uUXVldWUucGVuZGluZyAhPT0gbnVsbCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgcnVuQWN0aW9uKHtcbiAgICAgICAgYWN0aW9uUXVldWUsXG4gICAgICAgIGFjdGlvbjogYWN0aW9uUXVldWUucGVuZGluZyxcbiAgICAgICAgc2V0U3RhdGUsXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBObyBtb3JlIGFjdGlvbnMgYXJlIHBlbmRpbmcsIGNoZWNrIGlmIGEgcmVmcmVzaCBpcyBuZWVkZWRcbiAgICAgIGlmIChhY3Rpb25RdWV1ZS5uZWVkc1JlZnJlc2gpIHtcbiAgICAgICAgYWN0aW9uUXVldWUubmVlZHNSZWZyZXNoID0gZmFsc2VcbiAgICAgICAgYWN0aW9uUXVldWUuZGlzcGF0Y2goXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogQUNUSU9OX1JFRlJFU0gsXG4gICAgICAgICAgICBvcmlnaW46IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4sXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXRTdGF0ZVxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJ1bkFjdGlvbih7XG4gIGFjdGlvblF1ZXVlLFxuICBhY3Rpb24sXG4gIHNldFN0YXRlLFxufToge1xuICBhY3Rpb25RdWV1ZTogQXBwUm91dGVyQWN0aW9uUXVldWVcbiAgYWN0aW9uOiBBY3Rpb25RdWV1ZU5vZGVcbiAgc2V0U3RhdGU6IERpc3BhdGNoU3RhdGVQcm9taXNlXG59KSB7XG4gIGNvbnN0IHByZXZTdGF0ZSA9IGFjdGlvblF1ZXVlLnN0YXRlXG5cbiAgYWN0aW9uUXVldWUucGVuZGluZyA9IGFjdGlvblxuXG4gIGNvbnN0IHBheWxvYWQgPSBhY3Rpb24ucGF5bG9hZFxuICBjb25zdCBhY3Rpb25SZXN1bHQgPSBhY3Rpb25RdWV1ZS5hY3Rpb24ocHJldlN0YXRlLCBwYXlsb2FkKVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVJlc3VsdChuZXh0U3RhdGU6IEFwcFJvdXRlclN0YXRlKSB7XG4gICAgLy8gaWYgd2UgZGlzY2FyZGVkIHRoaXMgYWN0aW9uLCB0aGUgc3RhdGUgc2hvdWxkIGFsc28gYmUgZGlzY2FyZGVkXG4gICAgaWYgKGFjdGlvbi5kaXNjYXJkZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGFjdGlvblF1ZXVlLnN0YXRlID0gbmV4dFN0YXRlXG5cbiAgICBydW5SZW1haW5pbmdBY3Rpb25zKGFjdGlvblF1ZXVlLCBzZXRTdGF0ZSlcbiAgICBhY3Rpb24ucmVzb2x2ZShuZXh0U3RhdGUpXG4gIH1cblxuICAvLyBpZiB0aGUgYWN0aW9uIGlzIGEgcHJvbWlzZSwgc2V0IHVwIGEgY2FsbGJhY2sgdG8gcmVzb2x2ZSBpdFxuICBpZiAoaXNUaGVuYWJsZShhY3Rpb25SZXN1bHQpKSB7XG4gICAgYWN0aW9uUmVzdWx0LnRoZW4oaGFuZGxlUmVzdWx0LCAoZXJyKSA9PiB7XG4gICAgICBydW5SZW1haW5pbmdBY3Rpb25zKGFjdGlvblF1ZXVlLCBzZXRTdGF0ZSlcbiAgICAgIGFjdGlvbi5yZWplY3QoZXJyKVxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgaGFuZGxlUmVzdWx0KGFjdGlvblJlc3VsdClcbiAgfVxufVxuXG5mdW5jdGlvbiBkaXNwYXRjaEFjdGlvbihcbiAgYWN0aW9uUXVldWU6IEFwcFJvdXRlckFjdGlvblF1ZXVlLFxuICBwYXlsb2FkOiBSZWR1Y2VyQWN0aW9ucyxcbiAgc2V0U3RhdGU6IERpc3BhdGNoU3RhdGVQcm9taXNlXG4pIHtcbiAgbGV0IHJlc29sdmVyczoge1xuICAgIHJlc29sdmU6ICh2YWx1ZTogUmVkdWNlclN0YXRlKSA9PiB2b2lkXG4gICAgcmVqZWN0OiAocmVhc29uOiBhbnkpID0+IHZvaWRcbiAgfSA9IHsgcmVzb2x2ZTogc2V0U3RhdGUsIHJlamVjdDogKCkgPT4ge30gfVxuXG4gIC8vIG1vc3Qgb2YgdGhlIGFjdGlvbiB0eXBlcyBhcmUgYXN5bmMgd2l0aCB0aGUgZXhjZXB0aW9uIG9mIHJlc3RvcmVcbiAgLy8gaXQncyBpbXBvcnRhbnQgdGhhdCByZXN0b3JlIGlzIGhhbmRsZWQgcXVpY2tseSBzaW5jZSBpdCdzIGZpcmVkIG9uIHRoZSBwb3BzdGF0ZSBldmVudFxuICAvLyBhbmQgd2UgZG9uJ3Qgd2FudCB0byBhZGQgYW55IGRlbGF5IG9uIGEgYmFjay9mb3J3YXJkIG5hdlxuICAvLyB0aGlzIG9ubHkgY3JlYXRlcyBhIHByb21pc2UgZm9yIHRoZSBhc3luYyBhY3Rpb25zXG4gIGlmIChwYXlsb2FkLnR5cGUgIT09IEFDVElPTl9SRVNUT1JFKSB7XG4gICAgLy8gQ3JlYXRlIHRoZSBwcm9taXNlIGFuZCBhc3NpZ24gdGhlIHJlc29sdmVycyB0byB0aGUgb2JqZWN0LlxuICAgIGNvbnN0IGRlZmVycmVkUHJvbWlzZSA9IG5ldyBQcm9taXNlPEFwcFJvdXRlclN0YXRlPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICByZXNvbHZlcnMgPSB7IHJlc29sdmUsIHJlamVjdCB9XG4gICAgfSlcblxuICAgIHN0YXJ0VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICAvLyB3ZSBpbW1lZGlhdGVseSBub3RpZnkgUmVhY3Qgb2YgdGhlIHBlbmRpbmcgcHJvbWlzZSAtLSB0aGUgcmVzb2x2ZXIgaXMgYXR0YWNoZWQgdG8gdGhlIGFjdGlvbiBub2RlXG4gICAgICAvLyBhbmQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgYXNzb2NpYXRlZCBhY3Rpb24gcHJvbWlzZSByZXNvbHZlc1xuICAgICAgc2V0U3RhdGUoZGVmZXJyZWRQcm9taXNlKVxuICAgIH0pXG4gIH1cblxuICBjb25zdCBuZXdBY3Rpb246IEFjdGlvblF1ZXVlTm9kZSA9IHtcbiAgICBwYXlsb2FkLFxuICAgIG5leHQ6IG51bGwsXG4gICAgcmVzb2x2ZTogcmVzb2x2ZXJzLnJlc29sdmUsXG4gICAgcmVqZWN0OiByZXNvbHZlcnMucmVqZWN0LFxuICB9XG5cbiAgLy8gQ2hlY2sgaWYgdGhlIHF1ZXVlIGlzIGVtcHR5XG4gIGlmIChhY3Rpb25RdWV1ZS5wZW5kaW5nID09PSBudWxsKSB7XG4gICAgLy8gVGhlIHF1ZXVlIGlzIGVtcHR5LCBzbyBhZGQgdGhlIGFjdGlvbiBhbmQgc3RhcnQgaXQgaW1tZWRpYXRlbHlcbiAgICAvLyBNYXJrIHRoaXMgYWN0aW9uIGFzIHRoZSBsYXN0IGluIHRoZSBxdWV1ZVxuICAgIGFjdGlvblF1ZXVlLmxhc3QgPSBuZXdBY3Rpb25cblxuICAgIHJ1bkFjdGlvbih7XG4gICAgICBhY3Rpb25RdWV1ZSxcbiAgICAgIGFjdGlvbjogbmV3QWN0aW9uLFxuICAgICAgc2V0U3RhdGUsXG4gICAgfSlcbiAgfSBlbHNlIGlmIChcbiAgICBwYXlsb2FkLnR5cGUgPT09IEFDVElPTl9OQVZJR0FURSB8fFxuICAgIHBheWxvYWQudHlwZSA9PT0gQUNUSU9OX1JFU1RPUkVcbiAgKSB7XG4gICAgLy8gTmF2aWdhdGlvbnMgKGluY2x1ZGluZyBiYWNrL2ZvcndhcmQpIHRha2UgcHJpb3JpdHkgb3ZlciBhbnkgcGVuZGluZyBhY3Rpb25zLlxuICAgIC8vIE1hcmsgdGhlIHBlbmRpbmcgYWN0aW9uIGFzIGRpc2NhcmRlZCAoc28gdGhlIHN0YXRlIGlzIG5ldmVyIGFwcGxpZWQpIGFuZCBzdGFydCB0aGUgbmF2aWdhdGlvbiBhY3Rpb24gaW1tZWRpYXRlbHkuXG4gICAgYWN0aW9uUXVldWUucGVuZGluZy5kaXNjYXJkZWQgPSB0cnVlXG5cbiAgICAvLyBUaGUgcmVzdCBvZiB0aGUgY3VycmVudCBxdWV1ZSBzaG91bGQgc3RpbGwgZXhlY3V0ZSBhZnRlciB0aGlzIG5hdmlnYXRpb24uXG4gICAgLy8gKE5vdGUgdGhhdCBpdCBjYW4ndCBjb250YWluIGFueSBlYXJsaWVyIG5hdmlnYXRpb25zLCBiZWNhdXNlIHdlIGFsd2F5cyBwdXQgdGhvc2UgaW50byBgYWN0aW9uUXVldWUucGVuZGluZ2AgYnkgY2FsbGluZyBgcnVuQWN0aW9uYClcbiAgICBuZXdBY3Rpb24ubmV4dCA9IGFjdGlvblF1ZXVlLnBlbmRpbmcubmV4dFxuXG4gICAgLy8gaWYgdGhlIHBlbmRpbmcgYWN0aW9uIHdhcyBhIHNlcnZlciBhY3Rpb24sIG1hcmsgdGhlIHF1ZXVlIGFzIG5lZWRpbmcgYSByZWZyZXNoIG9uY2UgZXZlbnRzIGFyZSBwcm9jZXNzZWRcbiAgICBpZiAoYWN0aW9uUXVldWUucGVuZGluZy5wYXlsb2FkLnR5cGUgPT09IEFDVElPTl9TRVJWRVJfQUNUSU9OKSB7XG4gICAgICBhY3Rpb25RdWV1ZS5uZWVkc1JlZnJlc2ggPSB0cnVlXG4gICAgfVxuXG4gICAgcnVuQWN0aW9uKHtcbiAgICAgIGFjdGlvblF1ZXVlLFxuICAgICAgYWN0aW9uOiBuZXdBY3Rpb24sXG4gICAgICBzZXRTdGF0ZSxcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIC8vIFRoZSBxdWV1ZSBpcyBub3QgZW1wdHksIHNvIGFkZCB0aGUgYWN0aW9uIHRvIHRoZSBlbmQgb2YgdGhlIHF1ZXVlXG4gICAgLy8gSXQgd2lsbCBiZSBzdGFydGVkIGJ5IHJ1blJlbWFpbmluZ0FjdGlvbnMgYWZ0ZXIgdGhlIHByZXZpb3VzIGFjdGlvbiBmaW5pc2hlc1xuICAgIGlmIChhY3Rpb25RdWV1ZS5sYXN0ICE9PSBudWxsKSB7XG4gICAgICBhY3Rpb25RdWV1ZS5sYXN0Lm5leHQgPSBuZXdBY3Rpb25cbiAgICB9XG4gICAgYWN0aW9uUXVldWUubGFzdCA9IG5ld0FjdGlvblxuICB9XG59XG5cbmxldCBnbG9iYWxBY3Rpb25RdWV1ZTogQXBwUm91dGVyQWN0aW9uUXVldWUgfCBudWxsID0gbnVsbFxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTXV0YWJsZUFjdGlvblF1ZXVlKFxuICBpbml0aWFsU3RhdGU6IEFwcFJvdXRlclN0YXRlLFxuICBpbnN0cnVtZW50YXRpb25Ib29rczogQ2xpZW50SW5zdHJ1bWVudGF0aW9uSG9va3MgfCBudWxsXG4pOiBBcHBSb3V0ZXJBY3Rpb25RdWV1ZSB7XG4gIGNvbnN0IGFjdGlvblF1ZXVlOiBBcHBSb3V0ZXJBY3Rpb25RdWV1ZSA9IHtcbiAgICBzdGF0ZTogaW5pdGlhbFN0YXRlLFxuICAgIGRpc3BhdGNoOiAocGF5bG9hZDogUmVkdWNlckFjdGlvbnMsIHNldFN0YXRlOiBEaXNwYXRjaFN0YXRlUHJvbWlzZSkgPT5cbiAgICAgIGRpc3BhdGNoQWN0aW9uKGFjdGlvblF1ZXVlLCBwYXlsb2FkLCBzZXRTdGF0ZSksXG4gICAgYWN0aW9uOiBhc3luYyAoc3RhdGU6IEFwcFJvdXRlclN0YXRlLCBhY3Rpb246IFJlZHVjZXJBY3Rpb25zKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSByZWR1Y2VyKHN0YXRlLCBhY3Rpb24pXG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfSxcbiAgICBwZW5kaW5nOiBudWxsLFxuICAgIGxhc3Q6IG51bGwsXG4gICAgb25Sb3V0ZXJUcmFuc2l0aW9uU3RhcnQ6XG4gICAgICBpbnN0cnVtZW50YXRpb25Ib29rcyAhPT0gbnVsbCAmJlxuICAgICAgdHlwZW9mIGluc3RydW1lbnRhdGlvbkhvb2tzLm9uUm91dGVyVHJhbnNpdGlvblN0YXJ0ID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gLy8gVGhpcyBwcm9maWxpbmcgaG9vayB3aWxsIGJlIGNhbGxlZCBhdCB0aGUgc3RhcnQgb2YgZXZlcnkgbmF2aWdhdGlvbi5cbiAgICAgICAgICBpbnN0cnVtZW50YXRpb25Ib29rcy5vblJvdXRlclRyYW5zaXRpb25TdGFydFxuICAgICAgICA6IG51bGwsXG4gIH1cblxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBUaGUgYWN0aW9uIHF1ZXVlIGlzIGxhemlseSBjcmVhdGVkIG9uIGh5ZHJhdGlvbiwgYnV0IGFmdGVyIHRoYXQgcG9pbnRcbiAgICAvLyBpdCBkb2Vzbid0IGNoYW5nZS4gU28gd2UgY2FuIHN0b3JlIGl0IGluIGEgZ2xvYmFsIHJhdGhlciB0aGFuIHBhc3NcbiAgICAvLyBpdCBhcm91bmQgZXZlcnl3aGVyZSB2aWEgcHJvcHMvY29udGV4dC5cbiAgICBpZiAoZ2xvYmFsQWN0aW9uUXVldWUgIT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0ludGVybmFsIE5leHQuanMgRXJyb3I6IGNyZWF0ZU11dGFibGVBY3Rpb25RdWV1ZSB3YXMgY2FsbGVkIG1vcmUgJyArXG4gICAgICAgICAgJ3RoYW4gb25jZSdcbiAgICAgIClcbiAgICB9XG4gICAgZ2xvYmFsQWN0aW9uUXVldWUgPSBhY3Rpb25RdWV1ZVxuICB9XG5cbiAgcmV0dXJuIGFjdGlvblF1ZXVlXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDdXJyZW50QXBwUm91dGVyU3RhdGUoKTogQXBwUm91dGVyU3RhdGUgfCBudWxsIHtcbiAgcmV0dXJuIGdsb2JhbEFjdGlvblF1ZXVlICE9PSBudWxsID8gZ2xvYmFsQWN0aW9uUXVldWUuc3RhdGUgOiBudWxsXG59XG5cbmZ1bmN0aW9uIGdldEFwcFJvdXRlckFjdGlvblF1ZXVlKCk6IEFwcFJvdXRlckFjdGlvblF1ZXVlIHtcbiAgaWYgKGdsb2JhbEFjdGlvblF1ZXVlID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0ludGVybmFsIE5leHQuanMgZXJyb3I6IFJvdXRlciBhY3Rpb24gZGlzcGF0Y2hlZCBiZWZvcmUgaW5pdGlhbGl6YXRpb24uJ1xuICAgIClcbiAgfVxuICByZXR1cm4gZ2xvYmFsQWN0aW9uUXVldWVcbn1cblxuZnVuY3Rpb24gZ2V0UHJvZmlsaW5nSG9va0Zvck9uTmF2aWdhdGlvblN0YXJ0KCkge1xuICBpZiAoZ2xvYmFsQWN0aW9uUXVldWUgIT09IG51bGwpIHtcbiAgICByZXR1cm4gZ2xvYmFsQWN0aW9uUXVldWUub25Sb3V0ZXJUcmFuc2l0aW9uU3RhcnRcbiAgfVxuICByZXR1cm4gbnVsbFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGlzcGF0Y2hOYXZpZ2F0ZUFjdGlvbihcbiAgaHJlZjogc3RyaW5nLFxuICBuYXZpZ2F0ZVR5cGU6IE5hdmlnYXRlQWN0aW9uWyduYXZpZ2F0ZVR5cGUnXSxcbiAgc2hvdWxkU2Nyb2xsOiBib29sZWFuLFxuICBsaW5rSW5zdGFuY2VSZWY6IExpbmtJbnN0YW5jZSB8IG51bGxcbik6IHZvaWQge1xuICAvLyBUT0RPOiBUaGlzIHN0dWZmIGNvdWxkIGp1c3QgZ28gaW50byB0aGUgcmVkdWNlci4gTGVhdmluZyBhcy1pcyBmb3Igbm93XG4gIC8vIHNpbmNlIHdlJ3JlIGFib3V0IHRvIHJld3JpdGUgYWxsIHRoZSByb3V0ZXIgcmVkdWNlciBzdHVmZiBhbnl3YXkuXG4gIGNvbnN0IHVybCA9IG5ldyBVUkwoYWRkQmFzZVBhdGgoaHJlZiksIGxvY2F0aW9uLmhyZWYpXG4gIGlmIChwcm9jZXNzLmVudi5fX05FWFRfQVBQX05BVl9GQUlMX0hBTkRMSU5HKSB7XG4gICAgd2luZG93Lm5leHQuX19wZW5kaW5nVXJsID0gdXJsXG4gIH1cblxuICBzZXRMaW5rRm9yQ3VycmVudE5hdmlnYXRpb24obGlua0luc3RhbmNlUmVmKVxuXG4gIGNvbnN0IG9uUm91dGVyVHJhbnNpdGlvblN0YXJ0ID0gZ2V0UHJvZmlsaW5nSG9va0Zvck9uTmF2aWdhdGlvblN0YXJ0KClcbiAgaWYgKG9uUm91dGVyVHJhbnNpdGlvblN0YXJ0ICE9PSBudWxsKSB7XG4gICAgb25Sb3V0ZXJUcmFuc2l0aW9uU3RhcnQoaHJlZiwgbmF2aWdhdGVUeXBlKVxuICB9XG5cbiAgZGlzcGF0Y2hBcHBSb3V0ZXJBY3Rpb24oe1xuICAgIHR5cGU6IEFDVElPTl9OQVZJR0FURSxcbiAgICB1cmwsXG4gICAgaXNFeHRlcm5hbFVybDogaXNFeHRlcm5hbFVSTCh1cmwpLFxuICAgIGxvY2F0aW9uU2VhcmNoOiBsb2NhdGlvbi5zZWFyY2gsXG4gICAgc2hvdWxkU2Nyb2xsLFxuICAgIG5hdmlnYXRlVHlwZSxcbiAgICBhbGxvd0FsaWFzaW5nOiB0cnVlLFxuICB9KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGlzcGF0Y2hUcmF2ZXJzZUFjdGlvbihcbiAgaHJlZjogc3RyaW5nLFxuICB0cmVlOiBGbGlnaHRSb3V0ZXJTdGF0ZSB8IHVuZGVmaW5lZFxuKSB7XG4gIGNvbnN0IG9uUm91dGVyVHJhbnNpdGlvblN0YXJ0ID0gZ2V0UHJvZmlsaW5nSG9va0Zvck9uTmF2aWdhdGlvblN0YXJ0KClcbiAgaWYgKG9uUm91dGVyVHJhbnNpdGlvblN0YXJ0ICE9PSBudWxsKSB7XG4gICAgb25Sb3V0ZXJUcmFuc2l0aW9uU3RhcnQoaHJlZiwgJ3RyYXZlcnNlJylcbiAgfVxuICBkaXNwYXRjaEFwcFJvdXRlckFjdGlvbih7XG4gICAgdHlwZTogQUNUSU9OX1JFU1RPUkUsXG4gICAgdXJsOiBuZXcgVVJMKGhyZWYpLFxuICAgIHRyZWUsXG4gIH0pXG59XG5cbi8qKlxuICogVGhlIGFwcCByb3V0ZXIgdGhhdCBpcyBleHBvc2VkIHRocm91Z2ggYHVzZVJvdXRlcmAuIFRoZXNlIGFyZSBwdWJsaWMgQVBJXG4gKiBtZXRob2RzLiBJbnRlcm5hbCBOZXh0LmpzIGNvZGUgc2hvdWxkIGNhbGwgdGhlIGxvd2VyIGxldmVsIG1ldGhvZHMgZGlyZWN0bHlcbiAqIChhbHRob3VnaCB0aGVyZSdzIGxvdHMgb2YgZXhpc3RpbmcgY29kZSB0aGF0IGRvZXNuJ3QgZG8gdGhhdCkuXG4gKi9cbmV4cG9ydCBjb25zdCBwdWJsaWNBcHBSb3V0ZXJJbnN0YW5jZTogQXBwUm91dGVySW5zdGFuY2UgPSB7XG4gIGJhY2s6ICgpID0+IHdpbmRvdy5oaXN0b3J5LmJhY2soKSxcbiAgZm9yd2FyZDogKCkgPT4gd2luZG93Lmhpc3RvcnkuZm9yd2FyZCgpLFxuICBwcmVmZXRjaDogcHJvY2Vzcy5lbnYuX19ORVhUX0NMSUVOVF9TRUdNRU5UX0NBQ0hFXG4gICAgPyAvLyBVbmxpa2UgdGhlIG9sZCBpbXBsZW1lbnRhdGlvbiwgdGhlIFNlZ21lbnQgQ2FjaGUgZG9lc24ndCBzdG9yZSBpdHNcbiAgICAgIC8vIGRhdGEgaW4gdGhlIHJvdXRlciByZWR1Y2VyIHN0YXRlOyBpdCB3cml0ZXMgaW50byBhIGdsb2JhbCBtdXRhYmxlXG4gICAgICAvLyBjYWNoZS4gU28gd2UgZG9uJ3QgbmVlZCB0byBkaXNwYXRjaCBhbiBhY3Rpb24uXG4gICAgICAoaHJlZjogc3RyaW5nLCBvcHRpb25zPzogUHJlZmV0Y2hPcHRpb25zKSA9PiB7XG4gICAgICAgIGNvbnN0IGFjdGlvblF1ZXVlID0gZ2V0QXBwUm91dGVyQWN0aW9uUXVldWUoKVxuICAgICAgICBwcmVmZXRjaFdpdGhTZWdtZW50Q2FjaGUoXG4gICAgICAgICAgaHJlZixcbiAgICAgICAgICBhY3Rpb25RdWV1ZS5zdGF0ZS5uZXh0VXJsLFxuICAgICAgICAgIGFjdGlvblF1ZXVlLnN0YXRlLnRyZWUsXG4gICAgICAgICAgb3B0aW9ucz8ua2luZCA9PT0gUHJlZmV0Y2hLaW5kLkZVTEwsXG4gICAgICAgICAgb3B0aW9ucz8ub25JbnZhbGlkYXRlID8/IG51bGxcbiAgICAgICAgKVxuICAgICAgfVxuICAgIDogKGhyZWY6IHN0cmluZywgb3B0aW9ucz86IFByZWZldGNoT3B0aW9ucykgPT4ge1xuICAgICAgICAvLyBVc2UgdGhlIG9sZCBwcmVmZXRjaCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgY29uc3QgYWN0aW9uUXVldWUgPSBnZXRBcHBSb3V0ZXJBY3Rpb25RdWV1ZSgpXG4gICAgICAgIGNvbnN0IHVybCA9IGNyZWF0ZVByZWZldGNoVVJMKGhyZWYpXG4gICAgICAgIGlmICh1cmwgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBUaGUgcHJlZmV0Y2ggcmVkdWNlciBkb2Vzbid0IGFjdHVhbGx5IHVwZGF0ZSBhbnkgc3RhdGUgb3JcbiAgICAgICAgICAvLyB0cmlnZ2VyIGEgcmVyZW5kZXIuIEl0IGp1c3Qgd3JpdGVzIHRvIGEgbXV0YWJsZSBjYWNoZS4gU28gd2VcbiAgICAgICAgICAvLyBzaG91bGRuJ3QgYm90aGVyIGNhbGxpbmcgc2V0U3RhdGUvZGlzcGF0Y2g7IHdlIGNhbiBqdXN0IHJlLXJ1blxuICAgICAgICAgIC8vIHRoZSByZWR1Y2VyIGRpcmVjdGx5IHVzaW5nIHRoZSBjdXJyZW50IHN0YXRlLlxuICAgICAgICAgIC8vIFRPRE86IFJlZmFjdG9yIHRoaXMgYXdheSBmcm9tIGEgXCJyZWR1Y2VyXCIgc28gaXQnc1xuICAgICAgICAgIC8vIGxlc3MgY29uZnVzaW5nLlxuICAgICAgICAgIHByZWZldGNoUmVkdWNlcihhY3Rpb25RdWV1ZS5zdGF0ZSwge1xuICAgICAgICAgICAgdHlwZTogQUNUSU9OX1BSRUZFVENILFxuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAga2luZDogb3B0aW9ucz8ua2luZCA/PyBQcmVmZXRjaEtpbmQuRlVMTCxcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9LFxuICByZXBsYWNlOiAoaHJlZjogc3RyaW5nLCBvcHRpb25zPzogTmF2aWdhdGVPcHRpb25zKSA9PiB7XG4gICAgc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgIGRpc3BhdGNoTmF2aWdhdGVBY3Rpb24oaHJlZiwgJ3JlcGxhY2UnLCBvcHRpb25zPy5zY3JvbGwgPz8gdHJ1ZSwgbnVsbClcbiAgICB9KVxuICB9LFxuICBwdXNoOiAoaHJlZjogc3RyaW5nLCBvcHRpb25zPzogTmF2aWdhdGVPcHRpb25zKSA9PiB7XG4gICAgc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgIGRpc3BhdGNoTmF2aWdhdGVBY3Rpb24oaHJlZiwgJ3B1c2gnLCBvcHRpb25zPy5zY3JvbGwgPz8gdHJ1ZSwgbnVsbClcbiAgICB9KVxuICB9LFxuICByZWZyZXNoOiAoKSA9PiB7XG4gICAgc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgIGRpc3BhdGNoQXBwUm91dGVyQWN0aW9uKHtcbiAgICAgICAgdHlwZTogQUNUSU9OX1JFRlJFU0gsXG4gICAgICAgIG9yaWdpbjogd2luZG93LmxvY2F0aW9uLm9yaWdpbixcbiAgICAgIH0pXG4gICAgfSlcbiAgfSxcbiAgaG1yUmVmcmVzaDogKCkgPT4ge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnaG1yUmVmcmVzaCBjYW4gb25seSBiZSB1c2VkIGluIGRldmVsb3BtZW50IG1vZGUuIFBsZWFzZSB1c2UgcmVmcmVzaCBpbnN0ZWFkLidcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgICAgZGlzcGF0Y2hBcHBSb3V0ZXJBY3Rpb24oe1xuICAgICAgICAgIHR5cGU6IEFDVElPTl9ITVJfUkVGUkVTSCxcbiAgICAgICAgICBvcmlnaW46IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4sXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH1cbiAgfSxcbn1cblxuLy8gRXhpc3RzIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMuIERvbid0IHVzZSBpbiBhcHBsaWNhdGlvbiBjb2RlLlxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5uZXh0KSB7XG4gIHdpbmRvdy5uZXh0LnJvdXRlciA9IHB1YmxpY0FwcFJvdXRlckluc3RhbmNlXG59XG4iXSwibmFtZXMiOlsiY3JlYXRlTXV0YWJsZUFjdGlvblF1ZXVlIiwiZGlzcGF0Y2hOYXZpZ2F0ZUFjdGlvbiIsImRpc3BhdGNoVHJhdmVyc2VBY3Rpb24iLCJnZXRDdXJyZW50QXBwUm91dGVyU3RhdGUiLCJwdWJsaWNBcHBSb3V0ZXJJbnN0YW5jZSIsInJ1blJlbWFpbmluZ0FjdGlvbnMiLCJhY3Rpb25RdWV1ZSIsInNldFN0YXRlIiwicGVuZGluZyIsIm5leHQiLCJydW5BY3Rpb24iLCJhY3Rpb24iLCJuZWVkc1JlZnJlc2giLCJkaXNwYXRjaCIsInR5cGUiLCJBQ1RJT05fUkVGUkVTSCIsIm9yaWdpbiIsIndpbmRvdyIsImxvY2F0aW9uIiwicHJldlN0YXRlIiwic3RhdGUiLCJwYXlsb2FkIiwiYWN0aW9uUmVzdWx0IiwiaGFuZGxlUmVzdWx0IiwibmV4dFN0YXRlIiwiZGlzY2FyZGVkIiwicmVzb2x2ZSIsImlzVGhlbmFibGUiLCJ0aGVuIiwiZXJyIiwicmVqZWN0IiwiZGlzcGF0Y2hBY3Rpb24iLCJyZXNvbHZlcnMiLCJBQ1RJT05fUkVTVE9SRSIsImRlZmVycmVkUHJvbWlzZSIsIlByb21pc2UiLCJzdGFydFRyYW5zaXRpb24iLCJuZXdBY3Rpb24iLCJsYXN0IiwiQUNUSU9OX05BVklHQVRFIiwiQUNUSU9OX1NFUlZFUl9BQ1RJT04iLCJnbG9iYWxBY3Rpb25RdWV1ZSIsImluaXRpYWxTdGF0ZSIsImluc3RydW1lbnRhdGlvbkhvb2tzIiwicmVzdWx0IiwicmVkdWNlciIsIm9uUm91dGVyVHJhbnNpdGlvblN0YXJ0IiwiRXJyb3IiLCJnZXRBcHBSb3V0ZXJBY3Rpb25RdWV1ZSIsImdldFByb2ZpbGluZ0hvb2tGb3JPbk5hdmlnYXRpb25TdGFydCIsImhyZWYiLCJuYXZpZ2F0ZVR5cGUiLCJzaG91bGRTY3JvbGwiLCJsaW5rSW5zdGFuY2VSZWYiLCJ1cmwiLCJVUkwiLCJhZGRCYXNlUGF0aCIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfQVBQX05BVl9GQUlMX0hBTkRMSU5HIiwiX19wZW5kaW5nVXJsIiwic2V0TGlua0ZvckN1cnJlbnROYXZpZ2F0aW9uIiwiZGlzcGF0Y2hBcHBSb3V0ZXJBY3Rpb24iLCJpc0V4dGVybmFsVXJsIiwiaXNFeHRlcm5hbFVSTCIsImxvY2F0aW9uU2VhcmNoIiwic2VhcmNoIiwiYWxsb3dBbGlhc2luZyIsInRyZWUiLCJiYWNrIiwiaGlzdG9yeSIsImZvcndhcmQiLCJwcmVmZXRjaCIsIl9fTkVYVF9DTElFTlRfU0VHTUVOVF9DQUNIRSIsIm9wdGlvbnMiLCJwcmVmZXRjaFdpdGhTZWdtZW50Q2FjaGUiLCJuZXh0VXJsIiwia2luZCIsIlByZWZldGNoS2luZCIsIkZVTEwiLCJvbkludmFsaWRhdGUiLCJjcmVhdGVQcmVmZXRjaFVSTCIsInByZWZldGNoUmVkdWNlciIsIkFDVElPTl9QUkVGRVRDSCIsInJlcGxhY2UiLCJzY3JvbGwiLCJwdXNoIiwicmVmcmVzaCIsImhtclJlZnJlc2giLCJOT0RFX0VOViIsIkFDVElPTl9ITVJfUkVGUkVTSCIsInJvdXRlciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7SUErTWdCQSx3QkFBd0IsRUFBQTtlQUF4QkE7O0lBMERBQyxzQkFBc0IsRUFBQTtlQUF0QkE7O0lBK0JBQyxzQkFBc0IsRUFBQTtlQUF0QkE7O0lBbkRBQyx3QkFBd0IsRUFBQTtlQUF4QkE7O0lBdUVIQyx1QkFBdUIsRUFBQTtlQUF2QkE7OztvQ0FoVE47K0JBQ2lCO3VCQUNROzRCQUNMOzhCQUMwQjtnQ0FDYjs2QkFDWjsyQkFDcUI7aUNBQ2pCO3VCQU0rQjtBQWtDL0QsU0FBU0Msb0JBQ1BDLFdBQWlDLEVBQ2pDQyxRQUE4QjtJQUU5QixJQUFJRCxZQUFZRSxPQUFPLEtBQUssTUFBTTtRQUNoQ0YsWUFBWUUsT0FBTyxHQUFHRixZQUFZRSxPQUFPLENBQUNDLElBQUk7UUFDOUMsSUFBSUgsWUFBWUUsT0FBTyxLQUFLLE1BQU07WUFDaEMsbUVBQW1FO1lBQ25FRSxVQUFVO2dCQUNSSjtnQkFDQUssUUFBUUwsWUFBWUUsT0FBTztnQkFDM0JEO1lBQ0Y7UUFDRixPQUFPO1lBQ0wsNERBQTREO1lBQzVELElBQUlELFlBQVlNLFlBQVksRUFBRTtnQkFDNUJOLFlBQVlNLFlBQVksR0FBRztnQkFDM0JOLFlBQVlPLFFB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QUNGO0lBQ0Y7QUFDRjtBQUVBLGdFQUFnRTtBQUNoRSxJQUFJLE9BQU9DLFdBQVcsZUFBZUEsT0FBT1IsSUFBSSxFQUFFIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDEyNjYzLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2NsaWVudC9jb21wb25lbnRzL2xpbmtzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgRmxpZ2h0Um91dGVyU3RhdGUgfSBmcm9tICcuLi8uLi9zZXJ2ZXIvYXBwLXJlbmRlci90eXBlcydcbmltcG9ydCB0eXBlIHsgQXBwUm91dGVySW5zdGFuY2UgfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB7IGdldEN1cnJlbnRBcHBSb3V0ZXJTdGF0ZSB9IGZyb20gJy4vYXBwLXJvdXRlci1pbnN0YW5jZSdcbmltcG9ydCB7IGNyZWF0ZVByZWZldGNoVVJMIH0gZnJvbSAnLi9hcHAtcm91dGVyJ1xuaW1wb3J0IHsgUHJlZmV0Y2hLaW5kIH0gZnJvbSAnLi9yb3V0ZXItcmVkdWNlci9yb3V0ZXItcmVkdWNlci10eXBlcydcbmltcG9ydCB7IGlzUHJlZmV0Y2hUYXNrRGlydHkgfSBmcm9tICcuL3NlZ21lbnQtY2FjaGUnXG5pbXBvcnQgeyBjcmVhdGVDYWNoZUtleSB9IGZyb20gJy4vc2VnbWVudC1jYWNoZSdcbmltcG9ydCB7XG4gIHR5cGUgUHJlZmV0Y2hUYXNrLFxuICBQcmVmZXRjaFByaW9yaXR5LFxuICBzY2hlZHVsZVByZWZldGNoVGFzayBhcyBzY2hlZHVsZVNlZ21lbnRQcmVmZXRjaFRhc2ssXG4gIGNhbmNlbFByZWZldGNoVGFzayxcbiAgcmVzY2hlZHVsZVByZWZldGNoVGFzayxcbn0gZnJvbSAnLi9zZWdtZW50LWNhY2hlJ1xuaW1wb3J0IHsgc3RhcnRUcmFuc2l0aW9uIH0gZnJvbSAncmVhY3QnXG5cbnR5cGUgTGlua0VsZW1lbnQgPSBIVE1MQW5jaG9yRWxlbWVudCB8IFNWR0FFbGVtZW50XG5cbnR5cGUgRWxlbWVudCA9IExpbmtFbGVtZW50IHwgSFRNTEZvcm1FbGVtZW50XG5cbi8vIFByb3BlcnRpZXMgdGhhdCBhcmUgc2hhcmVkIGJldHdlZW4gTGluayBhbmQgRm9ybSBpbnN0YW5jZXMuIFdlIHVzZSB0aGUgc2FtZVxuLy8gc2hhcGUgZm9yIGJvdGggdG8gcHJldmVudCBhIHBvbHltb3JwaGljIGRlLW9wdCBpbiB0aGUgVk0uXG50eXBlIExpbmtPckZvcm1JbnN0YW5jZVNoYXJlZCA9IHtcbiAgcm91dGVyOiBBcHBSb3V0ZXJJbnN0YW5jZVxuICBraW5kOiBQcmVmZXRjaEtpbmQuQVVUTyB8IFByZWZldGNoS2luZC5GVUxMXG5cbiAgaXNWaXNpYmxlOiBib29sZWFuXG5cbiAgLy8gVGhlIG1vc3QgcmVjZW50bHkgaW5pdGlhdGVkIHByZWZldGNoIHRhc2suIEl0IG1heSBvciBtYXkgbm90IGhhdmVcbiAgLy8gYWxyZWFkeSBjb21wbGV0ZWQuIFRoZSBzYW1lIHByZWZldGNoIHRhc2sgb2JqZWN0IGNhbiBiZSByZXVzZWQgYWNyb3NzXG4gIC8vIG11bHRpcGxlIHByZWZldGNoZXMgb2YgdGhlIHNhbWUgbGluay5cbiAgcHJlZmV0Y2hUYXNrOiBQcmVmZXRjaFRhc2sgfCBudWxsXG59XG5cbmV4cG9ydCB0eXBlIEZvcm1JbnN0YW5jZSA9IExpbmtPckZvcm1JbnN0YW5jZVNoYXJlZCAmIHtcbiAgcHJlZmV0Y2hIcmVmOiBzdHJpbmdcbiAgc2V0T3B0aW1pc3RpY0xpbmtTdGF0dXM6IG51bGxcbn1cblxudHlwZSBQcmVmZXRjaGFibGVMaW5rSW5zdGFuY2UgPSBMaW5rT3JGb3JtSW5zdGFuY2VTaGFyZWQgJiB7XG4gIHByZWZldGNoSHJlZjogc3RyaW5nXG4gIHNldE9wdGltaXN0aWNMaW5rU3RhdHVzOiAoc3RhdHVzOiB7IHBlbmRpbmc6IGJvb2xlYW4gfSkgPT4gdm9pZFxufVxuXG50eXBlIE5vblByZWZldGNoYWJsZUxpbmtJbnN0YW5jZSA9IExpbmtPckZvcm1JbnN0YW5jZVNoYXJlZCAmIHtcbiAgcHJlZmV0Y2hIcmVmOiBudWxsXG4gIHNldE9wdGltaXN0aWNMaW5rU3RhdHVzOiAoc3RhdHVzOiB7IHBlbmRpbmc6IGJvb2xlYW4gfSkgPT4gdm9pZFxufVxuXG50eXBlIFByZWZldGNoYWJsZUluc3RhbmNlID0gUHJlZmV0Y2hhYmxlTGlua0luc3RhbmNlIHwgRm9ybUluc3RhbmNlXG5cbmV4cG9ydCB0eXBlIExpbmtJbnN0YW5jZSA9XG4gIHwgUHJlZmV0Y2hhYmxlTGlua0luc3RhbmNlXG4gIHwgTm9uUHJlZmV0Y2hhYmxlTGlua0luc3RhbmNlXG5cbi8vIFRyYWNrcyB0aGUgbW9zdCByZWNlbnRseSBuYXZpZ2F0ZWQgbGluayBpbnN0YW5jZS4gV2hlbiBudWxsLCBpbmRpY2F0ZXNcbi8vIHRoZSBjdXJyZW50IG5hdmlnYXRpb24gd2FzIG5vdCBpbml0aWF0ZWQgYnkgYSBsaW5rIGNsaWNrLlxubGV0IGxpbmtGb3JNb3N0UmVjZW50TmF2aWdhdGlvbjogTGlua0luc3RhbmNlIHwgbnVsbCA9IG51bGxcblxuLy8gU3RhdHVzIG9iamVjdCBpbmRpY2F0aW5nIGxpbmsgaXMgcGVuZGluZ1xuZXhwb3J0IGNvbnN0IFBFTkRJTkdfTElOS19TVEFUVVMgPSB7IHBlbmRpbmc6IHRydWUgfVxuXG4vLyBTdGF0dXMgb2JqZWN0IGluZGljYXRpbmcgbGluayBpcyBpZGxlXG5leHBvcnQgY29uc3QgSURMRV9MSU5LX1NUQVRVUyA9IHsgcGVuZGluZzogZmFsc2UgfVxuXG4vLyBVcGRhdGVzIHRoZSBsb2FkaW5nIHN0YXRlIHdoZW4gbmF2aWdhdGluZyBiZXR3ZWVuIGxpbmtzXG4vLyAtIFJlc2V0cyB0aGUgcHJldmlvdXMgbGluaydzIGxvYWRpbmcgc3RhdGVcbi8vIC0gU2V0cyB0aGUgbmV3IGxpbmsncyBsb2FkaW5nIHN0YXRlXG4vLyAtIFVwZGF0ZXMgdHJhY2tpbmcgb2YgY3VycmVudCBuYXZpZ2F0aW9uXG5leHBvcnQgZnVuY3Rpb24gc2V0TGlua0ZvckN1cnJlbnROYXZpZ2F0aW9uKGxpbms6IExpbmtJbnN0YW5jZSB8IG51bGwpIHtcbiAgc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICBsaW5rRm9yTW9zdFJlY2VudE5hdmlnYXRpb24/LnNldE9wdGltaXN0aWNMaW5rU3RhdHVzKElETEVfTElOS19TVEFUVVMpXG4gICAgbGluaz8uc2V0T3B0aW1pc3RpY0xpbmtTdGF0dXMoUEVORElOR19MSU5LX1NUQVRVUylcbiAgICBsaW5rRm9yTW9zdFJlY2VudE5hdmlnYXRpb24gPSBsaW5rXG4gIH0pXG59XG5cbi8vIFVubW91bnRzIHRoZSBjdXJyZW50IGxpbmsgaW5zdGFuY2UgZnJvbSBuYXZpZ2F0aW9uIHRyYWNraW5nXG5leHBvcnQgZnVuY3Rpb24gdW5tb3VudExpbmtGb3JDdXJyZW50TmF2aWdhdGlvbihsaW5rOiBMaW5rSW5zdGFuY2UpIHtcbiAgaWYgKGxpbmtGb3JNb3N0UmVjZW50TmF2aWdhdGlvbiA9PT0gbGluaykge1xuICAgIGxpbmtGb3JNb3N0UmVjZW50TmF2aWdhdGlvbiA9IG51bGxcbiAgfVxufVxuXG4vLyBVc2UgYSBXZWFrTWFwIHRvIGFzc29jaWF0ZSBhIExpbmsgaW5zdGFuY2Ugd2l0aCBpdHMgRE9NIGVsZW1lbnQuIFRoaXMgaXNcbi8vIHVzZWQgYnkgdGhlIEludGVyc2VjdGlvbk9ic2VydmVyIHRvIHRyYWNrIHRoZSBsaW5rJ3MgdmlzaWJpbGl0eS5cbmNvbnN0IHByZWZldGNoYWJsZTpcbiAgfCBXZWFrTWFwPEVsZW1lbnQsIFByZWZldGNoYWJsZUluc3RhbmNlPlxuICB8IE1hcDxFbGVtZW50LCBQcmVmZXRjaGFibGVJbnN0YW5jZT4gPVxuICB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IG5ldyBXZWFrTWFwKCkgOiBuZXcgTWFwKClcblxuLy8gQSBTZXQgb2YgdGhlIGN1cnJlbnRseSB2aXNpYmxlIGxpbmtzLiBXZSByZS1wcmVmZXRjaCB2aXNpYmxlIGxpbmtzIGFmdGVyIGFcbi8vIGNhY2hlIGludmFsaWRhdGlvbiwgb3Igd2hlbiB0aGUgY3VycmVudCBVUkwgY2hhbmdlcy4gSXQncyBhIHNlcGFyYXRlIGRhdGFcbi8vIHN0cnVjdHVyZSBmcm9tIHRoZSBXZWFrTWFwIGFib3ZlIGJlY2F1c2Ugb25seSB0aGUgdmlzaWJsZSBsaW5rcyBuZWVkIHRvXG4vLyBiZSBlbnVtZXJhdGVkLlxuY29uc3QgcHJlZmV0Y2hhYmxlQW5kVmlzaWJsZTogU2V0PFByZWZldGNoYWJsZUluc3RhbmNlPiA9IG5ldyBTZXQoKVxuXG4vLyBBIHNpbmdsZSBJbnRlcnNlY3Rpb25PYnNlcnZlciBpbnN0YW5jZSBzaGFyZWQgYnkgYWxsIDxMaW5rPiBjb21wb25lbnRzLlxuY29uc3Qgb2JzZXJ2ZXI6IEludGVyc2VjdGlvbk9ic2VydmVyIHwgbnVsbCA9XG4gIHR5cGVvZiBJbnRlcnNlY3Rpb25PYnNlcnZlciA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGhhbmRsZUludGVyc2VjdCwge1xuICAgICAgICByb290TWFyZ2luOiAnMjAwcHgnLFxuICAgICAgfSlcbiAgICA6IG51bGxcblxuZnVuY3Rpb24gb2JzZXJ2ZVZpc2liaWxpdHkoZWxlbWVudDogRWxlbWVudCwgaW5zdGFuY2U6IFByZWZldGNoYWJsZUluc3RhbmNlKSB7XG4gIGNvbnN0IGV4aXN0aW5nSW5zdGFuY2UgPSBwcmVmZXRjaGFibGUuZ2V0KGVsZW1lbnQpXG4gIGlmIChleGlzdGluZ0luc3RhbmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBUaGlzIHNob3VsZG4ndCBoYXBwZW4gYmVjYXVzZSBlYWNoIDxMaW5rPiBjb21wb25lbnQgc2hvdWxkIGhhdmUgaXRzIG93blxuICAgIC8vIGFuY2hvciB0YWcgaW5zdGFuY2UsIGJ1dCBpdCdzIGRlZmVuc2l2ZSBjb2RpbmcgdG8gYXZvaWQgYSBtZW1vcnkgbGVhayBpblxuICAgIC8vIGNhc2UgdGhlcmUncyBhIGxvZ2ljYWwgZXJyb3Igc29tZXdoZXJlIGVsc2UuXG4gICAgdW5tb3VudFByZWZldGNoYWJsZUluc3RhbmNlKGVsZW1lbnQpXG4gIH1cbiAgLy8gT25seSB0cmFjayBwcmVmZXRjaGFibGUgbGlua3MgdGhhdCBoYXZlIGEgdmFsaWQgcHJlZmV0Y2ggVVJMXG4gIHByZWZldGNoYWJsZS5zZXQoZWxlbWVudCwgaW5zdGFuY2UpXG4gIGlmIChvYnNlcnZlciAhPT0gbnVsbCkge1xuICAgIG9ic2VydmVyLm9ic2VydmUoZWxlbWVudClcbiAgfVxufVxuXG5mdW5jdGlvbiBjb2VyY2VQcmVmZXRjaGFibGVVcmwoaHJlZjogc3RyaW5nKTogVVJMIHwgbnVsbCB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGNyZWF0ZVByZWZldGNoVVJMKGhyZWYpXG4gIH0gY2F0Y2gge1xuICAgIC8vIGNyZWF0ZVByZWZldGNoVVJMIHNvbWV0aW1lcyB0aHJvd3MgYW4gZXJyb3IgaWYgYW4gaW52YWxpZCBVUkwgaXNcbiAgICAvLyBwcm92aWRlZCwgdGhvdWdoIEknbSBub3Qgc3VyZSBpZiBpdCdzIGFjdHVhbGx5IG5lY2Vzc2FyeS5cbiAgICAvLyBUT0RPOiBDb25zaWRlciByZW1vdmluZyB0aGUgdGhyb3cgZnJvbSB0aGUgaW5uZXIgZnVuY3Rpb24sIG9yIGNoYW5nZSBpdFxuICAgIC8vIHRvIHJlcG9ydEVycm9yLiBPciBtYXliZSB0aGUgZXJyb3IgaXNuJ3QgZXZlbiBuZWNlc3NhcnkgZm9yIGF1dG9tYXRpY1xuICAgIC8vIHByZWZldGNoZXMsIGp1c3QgbmF2aWdhdGlvbnMuXG4gICAgY29uc3QgcmVwb3J0RXJyb3JGbiA9XG4gICAgICB0eXBlb2YgcmVwb3J0RXJyb3IgPT09ICdmdW5jdGlvbicgPyByZXBvcnRFcnJvciA6IGNvbnNvbGUuZXJyb3JcbiAgICByZXBvcnRFcnJvckZuKFxuICAgICAgYENhbm5vdCBwcmVmZXRjaCAnJHtocmVmfScgYmVjYXVzZSBpdCBjYW5ub3QgYmUgY29udmVydGVkIHRvIGEgVVJMLmBcbiAgICApXG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbW91bnRMaW5rSW5zdGFuY2UoXG4gIGVsZW1lbnQ6IExpbmtFbGVtZW50LFxuICBocmVmOiBzdHJpbmcsXG4gIHJvdXRlcjogQXBwUm91dGVySW5zdGFuY2UsXG4gIGtpbmQ6IFByZWZldGNoS2luZC5BVVRPIHwgUHJlZmV0Y2hLaW5kLkZVTEwsXG4gIHByZWZldGNoRW5hYmxlZDogYm9vbGVhbixcbiAgc2V0T3B0aW1pc3RpY0xpbmtTdGF0dXM6IChzdGF0dXM6IHsgcGVuZGluZzogYm9vbGVhbiB9KSA9PiB2b2lkXG4pOiBMaW5rSW5zdGFuY2Uge1xuICBpZiAocHJlZmV0Y2hFbmFibGVkKSB7XG4gICAgY29uc3QgcHJlZmV0Y2hVUkwgPSBjb2VyY2VQcmVmZXRjaGFibGVVcmwoaHJlZilcbiAgICBpZiAocHJlZmV0Y2hVUkwgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGluc3RhbmNlOiBQcmVmZXRjaGFibGVMaW5rSW5zdGFuY2UgPSB7XG4gICAgICAgIHJvdXRlcixcbiAgICAgICAga2luZCxcbiAgICAgICAgaXNWaXNpYmxlOiBmYWxzZSxcbiAgICAgICAgcHJlZmV0Y2hUYXNrOiBudWxsLFxuICAgICAgICBwcmVmZXRjaEhyZWY6IHByZWZldGNoVVJMLmhyZWYsXG4gICAgICAgIHNldE9wdGltaXN0aWNMaW5rU3RhdHVzLFxuICAgICAgfVxuICAgICAgLy8gV2Ugb25seSBvYnNlcnZlIHRoZSBsaW5rJ3MgdmlzaWJpbGl0eSBpZiBpdCdzIHByZWZldGNoYWJsZS4gRm9yXG4gICAgICAvLyBleGFtcGxlLCB0aGlzIGV4Y2x1ZGVzIGxpbmtzIHRvIGV4dGVybmFsIFVSTHMuXG4gICAgICBvYnNlcnZlVmlzaWJpbGl0eShlbGVtZW50LCBpbnN0YW5jZSlcbiAgICAgIHJldHVybiBpbnN0YW5jZVxuICAgIH1cbiAgfVxuICAvLyBJZiB0aGUgbGluayBpcyBub3QgcHJlZmV0Y2hhYmxlLCB3ZSBzdGlsbCBjcmVhdGUgYW4gaW5zdGFuY2Ugc28gd2UgY2FuXG4gIC8vIHRyYWNrIGl0cyBvcHRpbWlzdGljIHN0YXRlIChpLmUuIHVzZUxpbmtTdGF0dXMpLlxuICBjb25zdCBpbnN0YW5jZTogTm9uUHJlZmV0Y2hhYmxlTGlua0luc3RhbmNlID0ge1xuICAgIHJvdXRlcixcbiAgICBraW5kLFxuICAgIGlzVmlzaWJsZTogZmFsc2UsXG4gICAgcHJlZmV0Y2hUYXNrOiBudWxsLFxuICAgIHByZWZldGNoSHJlZjogbnVsbCxcbiAgICBzZXRPcHRpbWlzdGljTGlua1N0YXR1cyxcbiAgfVxuICByZXR1cm4gaW5zdGFuY2Vcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1vdW50Rm9ybUluc3RhbmNlKFxuICBlbGVtZW50OiBIVE1MRm9ybUVsZW1lbnQsXG4gIGhyZWY6IHN0cmluZyxcbiAgcm91dGVyOiBBcHBSb3V0ZXJJbnN0YW5jZSxcbiAga2luZDogUHJlZmV0Y2hLaW5kLkFVVE8gfCBQcmVmZXRjaEtpbmQuRlVMTFxuKTogdm9pZCB7XG4gIGNvbnN0IHByZWZldGNoVVJMID0gY29lcmNlUHJlZmV0Y2hhYmxlVXJsKGhyZWYpXG4gIGlmIChwcmVmZXRjaFVSTCA9PT0gbnVsbCkge1xuICAgIC8vIFRoaXMgaHJlZiBpcyBub3QgcHJlZmV0Y2hhYmxlLCBzbyB3ZSBkb24ndCB0cmFjayBpdC5cbiAgICAvLyBUT0RPOiBXZSBjdXJyZW50bHkgb2JzZXJ2ZS91bm9ic2VydmUgYSBmb3JtIGV2ZXJ5IHRpbWUgaXRzIGhyZWYgY2hhbmdlcy5cbiAgICAvLyBGb3IgTGlua3MsIHRoaXMgaXNuJ3QgYSBiaWcgZGVhbCBiZWNhdXNlIHRoZSBocmVmIGRvZXNuJ3QgdXN1YWxseSBjaGFuZ2UsXG4gICAgLy8gYnV0IGZvciBmb3JtcyBpdCdzIGV4dHJlbWVseSBjb21tb24uIFdlIHNob3VsZCBvcHRpbWl6ZSB0aGlzLlxuICAgIHJldHVyblxuICB9XG4gIGNvbnN0IGluc3RhbmNlOiBGb3JtSW5zdGFuY2UgPSB7XG4gICAgcm91dGVyLFxuICAgIGtpbmQsXG4gICAgaXNWaXNpYmxlOiBmYWxzZSxcbiAgICBwcmVmZXRjaFRhc2s6IG51bGwsXG4gICAgcHJlZmV0Y2hIcmVmOiBwcmVmZXRjaFVSTC5ocmVmLFxuICAgIHNldE9wdGltaXN0aWNMaW5rU3RhdHVzOiBudWxsLFxuICB9XG4gIG9ic2VydmVWaXNpYmlsaXR5KGVsZW1lbnQsIGluc3RhbmNlKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdW5tb3VudFByZWZldGNoYWJsZUluc3RhbmNlKGVsZW1lbnQ6IEVsZW1lbnQpIHtcbiAgY29uc3QgaW5zdGFuY2UgPSBwcmVmZXRjaGFibGUuZ2V0KGVsZW1lbnQpXG4gIGlmIChpbnN0YW5jZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcHJlZmV0Y2hhYmxlLmRlbGV0ZShlbGVtZW50KVxuICAgIHByZWZldGNoYWJsZUFuZFZpc2libGUuZGVsZXRlKGluc3RhbmNlKVxuICAgIGNvbnN0IHByZWZldGNoVGFzayA9IGluc3RhbmNlLnByZWZldGNoVGFza1xuICAgIGlmIChwcmVmZXRjaFRhc2sgIT09IG51bGwpIHtcbiAgICAgIGNhbmNlbFByZWZldGNoVGFzayhwcmVmZXRjaFRhc2spXG4gICAgfVxuICB9XG4gIGlmIChvYnNlcnZlciAhPT0gbnVsbCkge1xuICAgIG9ic2VydmVyLnVub2JzZXJ2ZShlbGVtZW50KVxuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUludGVyc2VjdChlbnRyaWVzOiBBcnJheTxJbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5Pikge1xuICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICAvLyBTb21lIGV4dHJlbWVseSBvbGQgYnJvd3NlcnMgb3IgcG9seWZpbGxzIGRvbid0IHJlbGlhYmx5IHN1cHBvcnRcbiAgICAvLyBpc0ludGVyc2VjdGluZyBzbyB3ZSBjaGVjayBpbnRlcnNlY3Rpb25SYXRpbyBpbnN0ZWFkLiAoRG8gd2UgY2FyZT8gTm90XG4gICAgLy8gcmVhbGx5LiBCdXQgd2hhdGV2ZXIgdGhpcyBpcyBmaW5lLilcbiAgICBjb25zdCBpc1Zpc2libGUgPSBlbnRyeS5pbnRlcnNlY3Rpb25SYXRpbyA+IDBcbiAgICBvbkxpbmtWaXNpYmlsaXR5Q2hhbmdlZChlbnRyeS50YXJnZXQgYXMgSFRNTEFuY2hvckVsZW1lbnQsIGlzVmlzaWJsZSlcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gb25MaW5rVmlzaWJpbGl0eUNoYW5nZWQoZWxlbWVudDogRWxlbWVudCwgaXNWaXNpYmxlOiBib29sZWFuKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gUHJlZmV0Y2hpbmcgb24gdmlld3BvcnQgaXMgZGlzYWJsZWQgaW4gZGV2ZWxvcG1lbnQgZm9yIHBlcmZvcm1hbmNlXG4gICAgLy8gcmVhc29ucywgYmVjYXVzZSBpdCByZXF1aXJlcyBjb21waWxpbmcgdGhlIHRhcmdldCBwYWdlLlxuICAgIC8vIFRPRE86IEludmVzdGlnYXRlIHJlLWVuYWJsaW5nIHRoaXMuXG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCBpbnN0YW5jZSA9IHByZWZldGNoYWJsZS5nZXQoZWxlbWVudClcbiAgaWYgKGluc3RhbmNlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGluc3RhbmNlLmlzVmlzaWJsZSA9IGlzVmlzaWJsZVxuICBpZiAoaXNWaXNpYmxlKSB7XG4gICAgcHJlZmV0Y2hhYmxlQW5kVmlzaWJsZS5hZGQoaW5zdGFuY2UpXG4gIH0gZWxzZSB7XG4gICAgcHJlZmV0Y2hhYmxlQW5kVmlzaWJsZS5kZWxldGUoaW5zdGFuY2UpXG4gIH1cbiAgcmVzY2hlZHVsZUxpbmtQcmVmZXRjaChpbnN0YW5jZSwgUHJlZmV0Y2hQcmlvcml0eS5EZWZhdWx0KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gb25OYXZpZ2F0aW9uSW50ZW50KFxuICBlbGVtZW50OiBIVE1MQW5jaG9yRWxlbWVudCB8IFNWR0FFbGVtZW50LFxuICB1bnN0YWJsZV91cGdyYWRlVG9EeW5hbWljUHJlZmV0Y2g6IGJvb2xlYW5cbikge1xuICBjb25zdCBpbnN0YW5jZSA9IHByZWZldGNoYWJsZS5nZXQoZWxlbWVudClcbiAgaWYgKGluc3RhbmNlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm5cbiAgfVxuICAvLyBQcmVmZXRjaCB0aGUgbGluayBvbiBob3Zlci90b3VjaHN0YXJ0LlxuICBpZiAoaW5zdGFuY2UgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChcbiAgICAgIHByb2Nlc3MuZW52Ll9fTkVYVF9EWU5BTUlDX09OX0hPVkVSICYmXG4gICAgICB1bnN0YWJsZV91cGdyYWRlVG9EeW5hbWljUHJlZmV0Y2hcbiAgICApIHtcbiAgICAgIC8vIFN3aXRjaCB0byBhIGZ1bGwsIGR5bmFtaWMgcHJlZmV0Y2hcbiAgICAgIGluc3RhbmNlLmtpbmQgPSBQcmVmZXRjaEtpbmQuRlVMTFxuICAgIH1cbiAgICByZXNjaGVkdWxlTGlua1ByZWZldGNoKGluc3RhbmNlLCBQcmVmZXRjaFByaW9yaXR5LkludGVudClcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNjaGVkdWxlTGlua1ByZWZldGNoKFxuICBpbnN0YW5jZTogUHJlZmV0Y2hhYmxlSW5zdGFuY2UsXG4gIHByaW9yaXR5OiBQcmVmZXRjaFByaW9yaXR5LkRlZmF1bHQgfCBQcmVmZXRjaFByaW9yaXR5LkludGVudFxuKSB7XG4gIGNvbnN0IGV4aXN0aW5nUHJlZmV0Y2hUYXNrID0gaW5zdGFuY2UucHJlZmV0Y2hUYXNrXG5cbiAgaWYgKCFpbnN0YW5jZS5pc1Zpc2libGUpIHtcbiAgICAvLyBDYW5jZWwgYW55IGluLXByb2dyZXNzIHByZWZldGNoIHRhc2suIChJZiBpdCBhbHJlYWR5IGZpbmlzaGVkIHRoZW4gdGhpc1xuICAgIC8vIGlzIGEgbm8tb3AuKVxuICAgIGlmIChleGlzdGluZ1ByZWZldGNoVGFzayAhPT0gbnVsbCkge1xuICAgICAgY2FuY2VsUHJlZmV0Y2hUYXNrKGV4aXN0aW5nUHJlZmV0Y2hUYXNrKVxuICAgIH1cbiAgICAvLyBXZSBkb24ndCBuZWVkIHRvIHJlc2V0IHRoZSBwcmVmZXRjaFRhc2sgdG8gbnVsbCB1cG9uIGNhbmNlbGxhdGlvbjsgYW5cbiAgICAvLyBvbGQgdGFzayBvYmplY3QgY2FuIGJlIHJlc2NoZWR1bGVkIHdpdGggcmVzY2hlZHVsZVByZWZldGNoVGFzay4gVGhpcyBpcyBhXG4gICAgLy8gbWljcm8tb3B0aW1pemF0aW9uIGJ1dCBhbHNvIG1ha2VzIHRoZSBjb2RlIHNpbXBsZXIgKGRvbid0IG5lZWQgdG9cbiAgICAvLyB3b3JyeSBhYm91dCB3aGV0aGVyIGFuIG9sZCB0YXNrIG9iamVjdCBpcyBzdGFsZSkuXG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAoIXByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfU0VHTUVOVF9DQUNIRSkge1xuICAgIC8vIFRoZSBvbGQgcHJlZmV0Y2ggaW1wbGVtZW50YXRpb24gZG9lcyBub3QgaGF2ZSBkaWZmZXJlbnQgcHJpb3JpdHkgbGV2ZWxzLlxuICAgIC8vIEp1c3Qgc2NoZWR1bGUgYSBuZXcgcHJlZmV0Y2ggdGFzay5cbiAgICBwcmVmZXRjaFdpdGhPbGRDYWNoZUltcGxlbWVudGF0aW9uKGluc3RhbmNlKVxuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3QgYXBwUm91dGVyU3RhdGUgPSBnZXRDdXJyZW50QXBwUm91dGVyU3RhdGUoKVxuICBpZiAoYXBwUm91dGVyU3RhdGUgIT09IG51bGwpIHtcbiAgICBjb25zdCB0cmVlQXRUaW1lT2ZQcmVmZXRjaCA9IGFwcFJvdXRlclN0YXRlLnRyZWVcbiAgICBpZiAoZXhpc3RpbmdQcmVmZXRjaFRhc2sgPT09IG51bGwpIHtcbiAgICAgIC8vIEluaXRpYXRlIGEgcHJlZmV0Y2ggdGFzay5cbiAgICAgIGNvbnN0IG5leHRVcmwgPSBhcHBSb3V0ZXJTdGF0ZS5uZXh0VXJsXG4gICAgICBjb25zdCBjYWNoZUtleSA9IGNyZWF0ZUNhY2hlS2V5KGluc3RhbmNlLnByZWZldGNoSHJlZiwgbmV4dFVybClcbiAgICAgIGluc3RhbmNlLnByZWZldGNoVGFzayA9IHNjaGVkdWxlU2VnbWVudFByZWZldGNoVGFzayhcbiAgICAgICAgY2FjaGVLZXksXG4gICAgICAgIHRyZWVBdFRpbWVPZlByZWZldGNoLFxuICAgICAgICBpbnN0YW5jZS5raW5kID09PSBQcmVmZXRjaEtpbmQuRlVMTCxcbiAgICAgICAgcHJpb3JpdHksXG4gICAgICAgIG51bGxcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gV2UgYWxyZWFkeSBoYXZlIGFuIG9sZCB0YXNrIG9iamVjdCB0aGF0IHdlIGNhbiByZXNjaGVkdWxlLiBUaGlzIGlzXG4gICAgICAvLyBlZmZlY3RpdmVseSB0aGUgc2FtZSBhcyBjYW5jZWxpbmcgdGhlIG9sZCB0YXNrIGFuZCBjcmVhdGluZyBhIG5ldyBvbmUuXG4gICAgICByZXNjaGVkdWxlUHJlZmV0Y2hUYXNrKFxuICAgICAgICBleGlzdGluZ1ByZWZldGNoVGFzayxcbiAgICAgICAgdHJlZUF0VGltZU9mUHJlZmV0Y2gsXG4gICAgICAgIGluc3RhbmNlLmtpbmQgPT09IFByZWZldGNoS2luZC5GVUxMLFxuICAgICAgICBwcmlvcml0eVxuICAgICAgKVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcGluZ1Zpc2libGVMaW5rcyhcbiAgbmV4dFVybDogc3RyaW5nIHwgbnVsbCxcbiAgdHJlZTogRmxpZ2h0Um91dGVyU3RhdGVcbikge1xuICAvLyBGb3IgZWFjaCBjdXJyZW50bHkgdmlzaWJsZSBsaW5rLCBjYW5jZWwgdGhlIGV4aXN0aW5nIHByZWZldGNoIHRhc2sgKGlmIGl0XG4gIC8vIGV4aXN0cykgYW5kIHNjaGVkdWxlIGEgbmV3IG9uZS4gVGhpcyBpcyBlZmZlY3RpdmVseSB0aGUgc2FtZSBhcyBpZiBhbGwgdGhlXG4gIC8vIHZpc2libGUgbGlua3MgbGVmdCBhbmQgdGhlbiByZS1lbnRlcmVkIHRoZSB2aWV3cG9ydC5cbiAgLy9cbiAgLy8gVGhpcyBpcyBjYWxsZWQgd2hlbiB0aGUgTmV4dC1Vcmwgb3IgdGhlIGJhc2UgdHJlZSBjaGFuZ2VzLCBzaW5jZSB0aG9zZVxuICAvLyBtYXkgYWZmZWN0IHRoZSByZXN1bHQgb2YgYSBwcmVmZXRjaCB0YXNrLiBJdCdzIGFsc28gY2FsbGVkIGFmdGVyIGFcbiAgLy8gY2FjaGUgaW52YWxpZGF0aW9uLlxuICBmb3IgKGNvbnN0IGluc3RhbmNlIG9mIHByZWZldGNoYWJsZUFuZFZpc2libGUpIHtcbiAgICBjb25zdCB0YXNrID0gaW5zdGFuY2UucHJlZmV0Y2hUYXNrXG4gICAgaWYgKHRhc2sgIT09IG51bGwgJiYgIWlzUHJlZmV0Y2hUYXNrRGlydHkodGFzaywgbmV4dFVybCwgdHJlZSkpIHtcbiAgICAgIC8vIFRoZSBjYWNoZSBoYXMgbm90IGJlZW4gaW52YWxpZGF0ZWQsIGFuZCBub25lIG9mIHRoZSBpbnB1dHMgaGF2ZVxuICAgICAgLy8gY2hhbmdlZC4gQmFpbCBvdXQuXG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICAvLyBTb21ldGhpbmcgY2hhbmdlZC4gQ2FuY2VsIHRoZSBleGlzdGluZyBwcmVmZXRjaCB0YXNrIGFuZCBzY2hlZHVsZSBhXG4gICAgLy8gbmV3IG9uZS5cbiAgICBpZiAodGFzayAhPT0gbnVsbCkge1xuICAgICAgY2FuY2VsUHJlZmV0Y2hUYXNrKHRhc2spXG4gICAgfVxuICAgIGNvbnN0IGNhY2hlS2V5ID0gY3JlYXRlQ2FjaGVLZXkoaW5zdGFuY2UucHJlZmV0Y2hIcmVmLCBuZXh0VXJsKVxuICAgIGluc3RhbmNlLnByZWZldGNoVGFzayA9IHNjaGVkdWxlU2VnbWVudFByZWZldGNoVGFzayhcbiAgICAgIGNhY2hlS2V5LFxuICAgICAgdHJlZSxcbiAgICAgIGluc3RhbmNlLmtpbmQgPT09IFByZWZldGNoS2luZC5GVUxMLFxuICAgICAgUHJlZmV0Y2hQcmlvcml0eS5EZWZhdWx0LFxuICAgICAgbnVsbFxuICAgIClcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmVmZXRjaFdpdGhPbGRDYWNoZUltcGxlbWVudGF0aW9uKGluc3RhbmNlOiBQcmVmZXRjaGFibGVJbnN0YW5jZSkge1xuICAvLyBUaGlzIGlzIHRoZSBwYXRoIHVzZWQgd2hlbiB0aGUgU2VnbWVudCBDYWNoZSBpcyBub3QgZW5hYmxlZC5cbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCBkb1ByZWZldGNoID0gYXN5bmMgKCkgPT4ge1xuICAgIC8vIG5vdGUgdGhhdCBgYXBwUm91dGVyLnByZWZldGNoKClgIGlzIGN1cnJlbnRseSBzeW5jLFxuICAgIC8vIHNvIHdlIGhhdmUgdG8gd3JhcCB0aGlzIGNhbGwgaW4gYW4gYXN5bmMgZnVuY3Rpb24gdG8gYmUgYWJsZSB0byBjYXRjaCgpIGVycm9ycyBiZWxvdy5cbiAgICByZXR1cm4gaW5zdGFuY2Uucm91dGVyLnByZWZldGNoKGluc3RhbmNlLnByZWZldGNoSHJlZiwge1xuICAgICAga2luZDogaW5zdGFuY2Uua2luZCxcbiAgICB9KVxuICB9XG5cbiAgLy8gUHJlZmV0Y2ggdGhlIHBhZ2UgaWYgYXNrZWQgKG9ubHkgaW4gdGhlIGNsaWVudClcbiAgLy8gV2UgbmVlZCB0byBoYW5kbGUgYSBwcmVmZXRjaCBlcnJvciBoZXJlIHNpbmNlIHdlIG1heSBiZVxuICAvLyBsb2FkaW5nIHdpdGggcHJpb3JpdHkgd2hpY2ggY2FuIHJlamVjdCBidXQgd2UgZG9uJ3RcbiAgLy8gd2FudCB0byBmb3JjZSBuYXZpZ2F0aW9uIHNpbmNlIHRoaXMgaXMgb25seSBhIHByZWZldGNoXG4gIGRvUHJlZmV0Y2goKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIHJldGhyb3cgdG8gc2hvdyBpbnZhbGlkIFVSTCBlcnJvcnNcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfSlcbn1cbiJdLCJuYW1lcyI6WyJJRExFX0xJTktfU1RBVFVTIiwiUEVORElOR19MSU5LX1NUQVRVUyIsIm1vdW50Rm9ybUluc3RhbmNlIiwibW91bnRMaW5rSW5zdGFuY2UiLCJvbkxpbmtWaXNpYmlsaXR5Q2hhbmdlZCIsIm9uTmF2aWdhdGlvbkludGVudCIsInBpbmdWaXNpYmxlTGlua3MiLCJzZXRMaW5rRm9yQ3VycmVudE5hdmlnYXRpb24iLCJ1bm1vdW50TGlua0ZvckN1cnJlbnROYXZpZ2F0aW9uIiwidW5tb3VudFByZWZldGNoYWJsZUluc3RhbmNlIiwibGlua0Zvck1vc3RSZWNlbnROYXZpZ2F0aW9uIiwicGVuZGluZyIsImxpbmsiLCJzdGFydFRyYW5zaXRpb24iLCJzZXRPcHRpbWlzdGljTGlua1N0YXR1cyIsInByZWZldGNoYWJsZSIsIldlYWtNYXAiLCJNYXAiLCJwcmVmZXRjaGFibGVBbmRWaXNpYmxlIiwiU2V0Iiwib2JzZXJ2ZXIiLCJJbnRlcnNlY3Rpb25PYnNlcnZlciIsImhhbmRsZUludGVyc2VjdCIsInJvb3RNYXJnaW4iLCJvYnNlcnZlVmlzaWJpbGl0eSIsImVsZW1lbnQiLCJpbnN0YW5jZSIsImV4aXN0aW5nSW5zdGFuY2UiLCJnZXQiLCJ1bmRlZmluZWQiLCJzZXQiLCJvYnNlcnZlIiwiY29lcmNlUHJlZmV0Y2hhYmxlVXJsIiwiaHJlZiIsImNyZWF0ZVByZWZldGNoVVJMIiwicmVwb3J0RXJyb3JGbiIsInJlcG9ydEVycm9yIiwiY29uc29sZSIsImVycm9yIiwicm91dGVyIiwia2luZCIsInByZWZldGNoRW5hYmxlZCIsInByZWZldGNoVVJMIiwiaXNWaXNpYmxlIiwicHJlZmV0Y2hUYXNrIiwicHJlZmV0Y2hIcmVmIiwiZGVsZXRlIiwiY2FuY2VsUHJlZmV0Y2hUYXNrIiwidW5vYnNlcnZlIiwiZW50cmllcyIsImVudHJ5IiwiaW50ZXJzZWN0aW9uUmF0aW8iLCJ0YXJnZXQiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJhZGQiLCJyZXNjaGVkdWxlTGlua1ByZWZldGNoIiwiUHJlZmV0Y2hQcmlvcml0eSIsIkRlZmF1bHQiLCJ1bnN0YWJsZV91cGdyYWRlVG9EeW5hbWljUHJlZmV0Y2giLCJfX05FWFRfRFlOQU1JQ19PTl9IT1ZFUiIsIlByZWZldGNoS2luZCIsIkZVTEwiLCJJbnRlbnQiLCJwcmlvcml0eSIsImV4aXN0aW5nUHJlZmV0Y2hUYXNrIiwiX19ORVhUX0NMSUVOVF9TRUdNRU5UX0NBQ0hFIiwicHJlZmV0Y2hXaXRoT2xkQ2FjaGVJbXBsZW1lbnRhdGlvbiIsImFwcFJvdXRlclN0YXRlIiwiZ2V0Q3VycmVudEFwcFJvdXRlclN0YXRlIiwidHJlZUF0VGltZU9mUHJlZmV0Y2giLCJ0cmVlIiwibmV4dFVybCIsImNhY2hlS2V5IiwiY3JlYXRlQ2FjaGVLZXkiLCJzY2hlZHVsZVNlZ21lbnRQcmVmZXRjaFRhc2siLCJyZXNjaGVkdWxlUHJlZmV0Y2hUYXNrIiwidGFzayIsImlzUHJlZmV0Y2hUYXNrRGlydHkiLCJ3aW5kb3ciLCJkb1ByZWZldGNoIiwicHJlZmV0Y2giLCJjYXRjaCIsImVyciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQStEYUEsZ0JBQWdCLEVBQUE7ZUFBaEJBOztJQUhBQyxtQkFBbUIsRUFBQTtlQUFuQkE7O0lBb0hHQyxpQkFBaUIsRUFBQTtlQUFqQkE7O0lBdENBQyxpQkFBaUIsRUFBQTtlQUFqQkE7O0lBd0ZBQyx1QkFBdUIsRUFBQTtlQUF2QkE7O0lBc0JBQyxrQkFBa0IsRUFBQTtlQUFsQkE7O0lBMEVBQyxnQkFBZ0IsRUFBQTtlQUFoQkE7O0lBN1BBQywyQkFBMkIsRUFBQTtlQUEzQkE7O0lBU0FDLCtCQUErQixFQUFBO2VBQS9CQTs7SUEySEFDLDJCQUEyQixFQUFBO2VBQTNCQTs7O21DQXZNeUI7MkJBQ1A7b0NBQ0w7OEJBQ087dUJBU0o7QUF5Q2hDLHlFQUF5RTtBQUN6RSw0REFBNEQ7QUFDNUQsSUFBSUMsOEJBQW1EO0FBR2hELE1BQU1ULHNCQUFzQjtJQUFF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QUEsY0FBQUEsb0JBQTJCLEVBQ2pERixVQUNBRixNQUNBOUMsU0FBU2MsSUFBSSxLQUFLc0Isb0JBQUFBLFlBQVksQ0FBQ0MsSUFBSSxFQUNuQ0wsY0FBQUEsZ0JBQWdCLENBQUNDLE9BQU8sRUFDeEI7SUFFSjtBQUNGO0FBRUEsU0FBU1MsbUNBQW1DMUMsUUFBOEI7SUFDeEUsK0RBQStEO0lBQy9ELElBQUksT0FBT3NELFdBQVcsa0JBQWE7UUFDakM7SUFDRjs7O0lBRUEsTUFBTUMsYUFBYTtBQWtCckIiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTI5NDUsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtbG9jYWwtdXJsLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzQWJzb2x1dGVVcmwsIGdldExvY2F0aW9uT3JpZ2luIH0gZnJvbSAnLi4vLi4vdXRpbHMnXG5pbXBvcnQgeyBoYXNCYXNlUGF0aCB9IGZyb20gJy4uLy4uLy4uLy4uL2NsaWVudC9oYXMtYmFzZS1wYXRoJ1xuXG4vKipcbiAqIERldGVjdHMgd2hldGhlciBhIGdpdmVuIHVybCBpcyByb3V0YWJsZSBieSB0aGUgTmV4dC5qcyByb3V0ZXIgKGJyb3dzZXIgb25seSkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0xvY2FsVVJMKHVybDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIC8vIHByZXZlbnQgYSBoeWRyYXRpb24gbWlzbWF0Y2ggb24gaHJlZiBmb3IgdXJsIHdpdGggYW5jaG9yIHJlZnNcbiAgaWYgKCFpc0Fic29sdXRlVXJsKHVybCkpIHJldHVybiB0cnVlXG4gIHRyeSB7XG4gICAgLy8gYWJzb2x1dGUgdXJscyBjYW4gYmUgbG9jYWwgaWYgdGhleSBhcmUgb24gdGhlIHNhbWUgb3JpZ2luXG4gICAgY29uc3QgbG9jYXRpb25PcmlnaW4gPSBnZXRMb2NhdGlvbk9yaWdpbigpXG4gICAgY29uc3QgcmVzb2x2ZWQgPSBuZXcgVVJMKHVybCwgbG9jYXRpb25PcmlnaW4pXG4gICAgcmV0dXJuIHJlc29sdmVkLm9yaWdpbiA9PT0gbG9jYXRpb25PcmlnaW4gJiYgaGFzQmFzZVBhdGgocmVzb2x2ZWQucGF0aG5hbWUpXG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuIl0sIm5hbWVzIjpbImlzTG9jYWxVUkwiLCJ1cmwiLCJpc0Fic29sdXRlVXJsIiwibG9jYXRpb25PcmlnaW4iLCJnZXRMb2NhdGlvbk9yaWdpbiIsInJlc29sdmVkIiwiVVJMIiwib3JpZ2luIiwiaGFzQmFzZVBhdGgiLCJwYXRobmFtZSIsIl8iXSwibWFwcGluZ3MiOiI7OzsrQkFNZ0JBLGNBQUFBOzs7ZUFBQUE7Ozt1QkFOaUM7NkJBQ3JCO0FBS3JCLFNBQVNBLFdBQVdDLEdBQVc7SUFDcEMsZ0VBQWdFO0lBQ2hFLElBQUksQ0FBQ0MsQ0FBQUEsR0FBQUEsT0FBQUEsYUFBYSxFQUFDRCxNQUFNLE9BQU87SUFDaEMsSUFBSTtRQUNGLDREQUE0RDtRQUM1RCxNQUFNRSxpQkFBaUJDLENBQUFBLEdBQUFBLE9BQUFBLGlCQUFpQjtRQUN4QyxNQUFNQyxXQUFXLElBQUlDLElBQUlMLEtBQUtFO1FBQzlCLE9BQU9FLFNBQVNFLE1BQU0sS0FBS0osa0JBQWtCSyxDQUFBQSxHQUFBQSxhQUFBQSxXQUFXLEVBQUNILFNBQVNJLFFBQVE7SUFDNUUsRUFBRSxPQUFPQyxHQUFHO1FBQ1YsT0FBTztJQUNUO0FBQ0YiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTI5NzQsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvc2hhcmVkL2xpYi91dGlscy9lcnJvci1vbmNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImxldCBlcnJvck9uY2UgPSAoXzogc3RyaW5nKSA9PiB7fVxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgY29uc3QgZXJyb3JzID0gbmV3IFNldDxzdHJpbmc+KClcbiAgZXJyb3JPbmNlID0gKG1zZzogc3RyaW5nKSA9PiB7XG4gICAgaWYgKCFlcnJvcnMuaGFzKG1zZykpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobXNnKVxuICAgIH1cbiAgICBlcnJvcnMuYWRkKG1zZylcbiAgfVxufVxuXG5leHBvcnQgeyBlcnJvck9uY2UgfVxuIl0sIm5hbWVzIjpbImVycm9yT25jZSIsIl8iLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJlcnJvcnMiLCJTZXQiLCJtc2ciLCJoYXMiLCJjb25zb2xlIiwiZXJyb3IiLCJhZGQiXSwibWFwcGluZ3MiOiI7OzsrQkFXU0EsYUFBQUE7OztlQUFBQTs7O0FBWFQsSUFBSUEsWUFBWSxDQUFDQyxLQUFlO0FBQ2hDLElBQUlDLFFBQVFDLEdBQUcsQ0FBQ0MsUUFBUSxLQUFLLFdBQWM7SUFDekMsTUFBTUMsU0FBUyxJQUFJQztJQUNuQk4sWUFBWSxDQUFDTztRQUNYLElBQUksQ0FBQ0YsT0FBT0csR0FBRyxDQUFDRCxNQUFNO1lBQ3BCRSxRQUFRQyxLQUFLLENBQUNIO1FBQ2hCO1FBQ0FGLE9BQU9NLEdBQUcsQ0FBQ0o7SUFDYjtBQUNGIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDEyOTk5LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2NsaWVudC9hcHAtZGlyL2xpbmsudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuXG5pbXBvcnQgUmVhY3QsIHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlT3B0aW1pc3RpYywgdXNlUmVmIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgdHlwZSB7IFVybE9iamVjdCB9IGZyb20gJ3VybCdcbmltcG9ydCB7IGZvcm1hdFVybCB9IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2Zvcm1hdC11cmwnXG5pbXBvcnQgeyBBcHBSb3V0ZXJDb250ZXh0IH0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgeyBQcmVmZXRjaEtpbmQgfSBmcm9tICcuLi9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JvdXRlci1yZWR1Y2VyLXR5cGVzJ1xuaW1wb3J0IHsgdXNlTWVyZ2VkUmVmIH0gZnJvbSAnLi4vdXNlLW1lcmdlZC1yZWYnXG5pbXBvcnQgeyBpc0Fic29sdXRlVXJsIH0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi91dGlscydcbmltcG9ydCB7IGFkZEJhc2VQYXRoIH0gZnJvbSAnLi4vYWRkLWJhc2UtcGF0aCdcbmltcG9ydCB7IHdhcm5PbmNlIH0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi91dGlscy93YXJuLW9uY2UnXG5pbXBvcnQgdHlwZSB7IFBFTkRJTkdfTElOS19TVEFUVVMgfSBmcm9tICcuLi9jb21wb25lbnRzL2xpbmtzJ1xuaW1wb3J0IHtcbiAgSURMRV9MSU5LX1NUQVRVUyxcbiAgbW91bnRMaW5rSW5zdGFuY2UsXG4gIG9uTmF2aWdhdGlvbkludGVudCxcbiAgdW5tb3VudExpbmtGb3JDdXJyZW50TmF2aWdhdGlvbixcbiAgdW5tb3VudFByZWZldGNoYWJsZUluc3RhbmNlLFxuICB0eXBlIExpbmtJbnN0YW5jZSxcbn0gZnJvbSAnLi4vY29tcG9uZW50cy9saW5rcydcbmltcG9ydCB7IGlzTG9jYWxVUkwgfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9pcy1sb2NhbC11cmwnXG5pbXBvcnQgeyBkaXNwYXRjaE5hdmlnYXRlQWN0aW9uIH0gZnJvbSAnLi4vY29tcG9uZW50cy9hcHAtcm91dGVyLWluc3RhbmNlJ1xuaW1wb3J0IHsgZXJyb3JPbmNlIH0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi91dGlscy9lcnJvci1vbmNlJ1xuXG50eXBlIFVybCA9IHN0cmluZyB8IFVybE9iamVjdFxudHlwZSBSZXF1aXJlZEtleXM8VD4gPSB7XG4gIFtLIGluIGtleW9mIFRdLT86IHt9IGV4dGVuZHMgUGljazxULCBLPiA/IG5ldmVyIDogS1xufVtrZXlvZiBUXVxudHlwZSBPcHRpb25hbEtleXM8VD4gPSB7XG4gIFtLIGluIGtleW9mIFRdLT86IHt9IGV4dGVuZHMgUGljazxULCBLPiA/IEsgOiBuZXZlclxufVtrZXlvZiBUXVxuXG50eXBlIE9uTmF2aWdhdGVFdmVudEhhbmRsZXIgPSAoZXZlbnQ6IHsgcHJldmVudERlZmF1bHQ6ICgpID0+IHZvaWQgfSkgPT4gdm9pZFxuXG50eXBlIEludGVybmFsTGlua1Byb3BzID0ge1xuICAvKipcbiAgICogKipSZXF1aXJlZCoqLiBUaGUgcGF0aCBvciBVUkwgdG8gbmF2aWdhdGUgdG8uIEl0IGNhbiBhbHNvIGJlIGFuIG9iamVjdCAoc2ltaWxhciB0byBgVVJMYCkuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzeFxuICAgKiAvLyBOYXZpZ2F0ZSB0byAvZGFzaGJvYXJkOlxuICAgKiA8TGluayBocmVmPVwiL2Rhc2hib2FyZFwiPkRhc2hib2FyZDwvTGluaz5cbiAgICpcbiAgICogLy8gTmF2aWdhdGUgdG8gL2Fib3V0P25hbWU9dGVzdDpcbiAgICogPExpbmsgaHJlZj17eyBwYXRobmFtZTogJy9hYm91dCcsIHF1ZXJ5OiB7IG5hbWU6ICd0ZXN0JyB9IH19PlxuICAgKiAgIEFib3V0XG4gICAqIDwvTGluaz5cbiAgICogYGBgXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIC0gRm9yIGV4dGVybmFsIFVSTHMsIHVzZSBhIGZ1bGx5IHF1YWxpZmllZCBVUkwgc3VjaCBhcyBgaHR0cHM6Ly8uLi5gLlxuICAgKiAtIEluIHRoZSBBcHAgUm91dGVyLCBkeW5hbWljIHJvdXRlcyBtdXN0IG5vdCBpbmNsdWRlIGJyYWNrZXRlZCBzZWdtZW50cyBpbiBgaHJlZmAuXG4gICAqL1xuICBocmVmOiBVcmxcblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdjEwLjAuMDogYGhyZWZgIHByb3BzIHBvaW50aW5nIHRvIGEgZHluYW1pYyByb3V0ZSBhcmVcbiAgICogYXV0b21hdGljYWxseSByZXNvbHZlZCBhbmQgbm8gbG9uZ2VyIHJlcXVpcmUgdGhlIGBhc2AgcHJvcC5cbiAgICovXG4gIGFzPzogVXJsXG5cbiAgLyoqXG4gICAqIFJlcGxhY2UgdGhlIGN1cnJlbnQgYGhpc3RvcnlgIHN0YXRlIGluc3RlYWQgb2YgYWRkaW5nIGEgbmV3IFVSTCBpbnRvIHRoZSBzdGFjay5cbiAgICpcbiAgICogQGRlZmF1bHRWYWx1ZSBgZmFsc2VgXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzeFxuICAgKiA8TGluayBocmVmPVwiL2Fib3V0XCIgcmVwbGFjZT5cbiAgICogICBBYm91dCAocmVwbGFjZXMgdGhlIGhpc3Rvcnkgc3RhdGUpXG4gICAqIDwvTGluaz5cbiAgICogYGBgXG4gICAqL1xuICByZXBsYWNlPzogYm9vbGVhblxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IHNjcm9sbCBiZWhhdmlvci4gSWYgYHRydWVgLCBOZXh0LmpzIGF0dGVtcHRzIHRvIG1haW50YWluXG4gICAqIHRoZSBzY3JvbGwgcG9zaXRpb24gaWYgdGhlIG5ld2x5IG5hdmlnYXRlZCBwYWdlIGlzIHN0aWxsIHZpc2libGUuIElmIG5vdCwgaXQgc2Nyb2xscyB0byB0aGUgdG9wLlxuICAgKlxuICAgKiBJZiBgZmFsc2VgLCBOZXh0LmpzIHdpbGwgbm90IG1vZGlmeSB0aGUgc2Nyb2xsIGJlaGF2aW9yIGF0IGFsbC5cbiAgICpcbiAgICogQGRlZmF1bHRWYWx1ZSBgdHJ1ZWBcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHN4XG4gICAqIDxMaW5rIGhyZWY9XCIvZGFzaGJvYXJkXCIgc2Nyb2xsPXtmYWxzZX0+XG4gICAqICAgTm8gYXV0byBzY3JvbGxcbiAgICogPC9MaW5rPlxuICAgKiBgYGBcbiAgICovXG4gIHNjcm9sbD86IGJvb2xlYW5cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBwYXRoIG9mIHRoZSBjdXJyZW50IHBhZ2Ugd2l0aG91dCByZXJ1bm5pbmcgZGF0YSBmZXRjaGluZyBtZXRob2RzXG4gICAqIGxpa2UgYGdldFN0YXRpY1Byb3BzYCwgYGdldFNlcnZlclNpZGVQcm9wc2AsIG9yIGBnZXRJbml0aWFsUHJvcHNgLlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBgc2hhbGxvd2Agb25seSBhcHBsaWVzIHRvIHRoZSBQYWdlcyBSb3V0ZXIuIEZvciB0aGUgQXBwIFJvdXRlciwgc2VlIHRoZVxuICAgKiBbZm9sbG93aW5nIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL3JvdXRpbmcvbGlua2luZy1hbmQtbmF2aWdhdGluZyN1c2luZy10aGUtbmF0aXZlLWhpc3RvcnktYXBpKS5cbiAgICpcbiAgICogQGRlZmF1bHRWYWx1ZSBgZmFsc2VgXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzeFxuICAgKiA8TGluayBocmVmPVwiL2Jsb2dcIiBzaGFsbG93PlxuICAgKiAgIFNoYWxsb3cgbmF2aWdhdGlvblxuICAgKiA8L0xpbms+XG4gICAqIGBgYFxuICAgKi9cbiAgc2hhbGxvdz86IGJvb2xlYW5cblxuICAvKipcbiAgICogRm9yY2VzIGBMaW5rYCB0byBwYXNzIGl0cyBgaHJlZmAgdG8gdGhlIGNoaWxkIGNvbXBvbmVudC4gVXNlZnVsIGlmIHRoZSBjaGlsZCBpcyBhIGN1c3RvbVxuICAgKiBjb21wb25lbnQgdGhhdCB3cmFwcyBhbiBgPGE+YCB0YWcsIG9yIGlmIHlvdSdyZSB1c2luZyBjZXJ0YWluIHN0eWxpbmcgbGlicmFyaWVzLlxuICAgKlxuICAgKiBAZGVmYXVsdFZhbHVlIGBmYWxzZWBcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHN4XG4gICAqIDxMaW5rIGhyZWY9XCIvZGFzaGJvYXJkXCIgcGFzc0hyZWY+XG4gICAqICAgPE15U3R5bGVkQW5jaG9yPkRhc2hib2FyZDwvTXlTdHlsZWRBbmNob3I+XG4gICAqIDwvTGluaz5cbiAgICogYGBgXG4gICAqL1xuICBwYXNzSHJlZj86IGJvb2xlYW5cblxuICAvKipcbiAgICogUHJlZmV0Y2ggdGhlIHBhZ2UgaW4gdGhlIGJhY2tncm91bmQuXG4gICAqIEFueSBgPExpbmsgLz5gIHRoYXQgaXMgaW4gdGhlIHZpZXdwb3J0IChpbml0aWFsbHkgb3IgdGhyb3VnaCBzY3JvbGwpIHdpbGwgYmUgcHJlZmV0Y2hlZC5cbiAgICogUHJlZmV0Y2ggY2FuIGJlIGRpc2FibGVkIGJ5IHBhc3NpbmcgYHByZWZldGNoPXtmYWxzZX1gLlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBQcmVmZXRjaGluZyBpcyBvbmx5IGVuYWJsZWQgaW4gcHJvZHVjdGlvbi5cbiAgICpcbiAgICogLSBJbiB0aGUgKipBcHAgUm91dGVyKio6XG4gICAqICAgLSBgXCJhdXRvXCJgLCBgbnVsbGAsIGB1bmRlZmluZWRgIChkZWZhdWx0KTogUHJlZmV0Y2ggYmVoYXZpb3IgZGVwZW5kcyBvbiBzdGF0aWMgdnMgZHluYW1pYyByb3V0ZXM6XG4gICAqICAgICAtIFN0YXRpYyByb3V0ZXM6IGZ1bGx5IHByZWZldGNoZWRcbiAgICogICAgIC0gRHluYW1pYyByb3V0ZXM6IHBhcnRpYWwgcHJlZmV0Y2ggdG8gdGhlIG5lYXJlc3Qgc2VnbWVudCB3aXRoIGEgYGxvYWRpbmcuanNgXG4gICAqICAgLSBgdHJ1ZWA6IEFsd2F5cyBwcmVmZXRjaCB0aGUgZnVsbCByb3V0ZSBhbmQgZGF0YS5cbiAgICogICAtIGBmYWxzZWA6IERpc2FibGUgcHJlZmV0Y2hpbmcgb24gYm90aCB2aWV3cG9ydCBhbmQgaG92ZXIuXG4gICAqIC0gSW4gdGhlICoqUGFnZXMgUm91dGVyKio6XG4gICAqICAgLSBgdHJ1ZWAgKGRlZmF1bHQpOiBQcmVmZXRjaGVzIHRoZSByb3V0ZSBhbmQgZGF0YSBpbiB0aGUgYmFja2dyb3VuZCBvbiB2aWV3cG9ydCBvciBob3Zlci5cbiAgICogICAtIGBmYWxzZWA6IFByZWZldGNoIG9ubHkgb24gaG92ZXIsIG5vdCBvbiB2aWV3cG9ydC5cbiAgICpcbiAgICogQGRlZmF1bHRWYWx1ZSBgdHJ1ZWAgKFBhZ2VzIFJvdXRlcikgb3IgYG51bGxgIChBcHAgUm91dGVyKVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c3hcbiAgICogPExpbmsgaHJlZj1cIi9kYXNoYm9hcmRcIiBwcmVmZXRjaD17ZmFsc2V9PlxuICAgKiAgIERhc2hib2FyZFxuICAgKiA8L0xpbms+XG4gICAqIGBgYFxuICAgKi9cbiAgcHJlZmV0Y2g/OiBib29sZWFuIHwgJ2F1dG8nIHwgbnVsbFxuXG4gIC8qKlxuICAgKiAodW5zdGFibGUpIFN3aXRjaCB0byBhIGR5bmFtaWMgcHJlZmV0Y2ggb24gaG92ZXIuIEVmZmVjdGl2ZWx5IHRoZSBzYW1lIGFzXG4gICAqIHVwZGF0aW5nIHRoZSBwcmVmZXRjaCBwcm9wIHRvIGB0cnVlYCBpbiBhIG1vdXNlIGV2ZW50LlxuICAgKi9cbiAgdW5zdGFibGVfZHluYW1pY09uSG92ZXI/OiBib29sZWFuXG5cbiAgLyoqXG4gICAqIFRoZSBhY3RpdmUgbG9jYWxlIGlzIGF1dG9tYXRpY2FsbHkgcHJlcGVuZGVkIGluIHRoZSBQYWdlcyBSb3V0ZXIuIGBsb2NhbGVgIGFsbG93cyBmb3IgcHJvdmlkaW5nXG4gICAqIGEgZGlmZmVyZW50IGxvY2FsZSwgb3IgY2FuIGJlIHNldCB0byBgZmFsc2VgIHRvIG9wdCBvdXQgb2YgYXV0b21hdGljIGxvY2FsZSBiZWhhdmlvci5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogTm90ZTogbG9jYWxlIG9ubHkgYXBwbGllcyBpbiB0aGUgUGFnZXMgUm91dGVyIGFuZCBpcyBpZ25vcmVkIGluIHRoZSBBcHAgUm91dGVyLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c3hcbiAgICogLy8gVXNlIHRoZSAnZnInIGxvY2FsZTpcbiAgICogPExpbmsgaHJlZj1cIi9hYm91dFwiIGxvY2FsZT1cImZyXCI+XG4gICAqICAgQWJvdXQgKEZyZW5jaClcbiAgICogPC9MaW5rPlxuICAgKlxuICAgKiAvLyBEaXNhYmxlIGxvY2FsZSBwcmVmaXg6XG4gICAqIDxMaW5rIGhyZWY9XCIvYWJvdXRcIiBsb2NhbGU9e2ZhbHNlfT5cbiAgICogICBBYm91dCAobm8gbG9jYWxlIHByZWZpeClcbiAgICogPC9MaW5rPlxuICAgKiBgYGBcbiAgICovXG4gIGxvY2FsZT86IHN0cmluZyB8IGZhbHNlXG5cbiAgLyoqXG4gICAqIEVuYWJsZSBsZWdhY3kgbGluayBiZWhhdmlvciwgcmVxdWlyaW5nIGFuIGA8YT5gIHRhZyB0byB3cmFwIHRoZSBjaGlsZCBjb250ZW50XG4gICAqIGlmIHRoZSBjaGlsZCBpcyBhIHN0cmluZyBvciBudW1iZXIuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFRoaXMgd2lsbCBiZSByZW1vdmVkIGluIHYxNlxuICAgKiBAZGVmYXVsdFZhbHVlIGBmYWxzZWBcbiAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL25leHQuanMvY29tbWl0LzQ4OWU2NWVkOTg1NDRlNjliMGFmZDdlMGNmYzNmOWY2YzJiODAzYjdcbiAgICovXG4gIGxlZ2FjeUJlaGF2aW9yPzogYm9vbGVhblxuXG4gIC8qKlxuICAgKiBPcHRpb25hbCBldmVudCBoYW5kbGVyIGZvciB3aGVuIHRoZSBtb3VzZSBwb2ludGVyIGlzIG1vdmVkIG9udG8gdGhlIGA8TGluaz5gLlxuICAgKi9cbiAgb25Nb3VzZUVudGVyPzogUmVhY3QuTW91c2VFdmVudEhhbmRsZXI8SFRNTEFuY2hvckVsZW1lbnQ+XG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsIGV2ZW50IGhhbmRsZXIgZm9yIHdoZW4gdGhlIGA8TGluaz5gIGlzIHRvdWNoZWQuXG4gICAqL1xuICBvblRvdWNoU3RhcnQ/OiBSZWFjdC5Ub3VjaEV2ZW50SGFuZGxlcjxIVE1MQW5jaG9yRWxlbWVudD5cblxuICAvKipcbiAgICogT3B0aW9uYWwgZXZlbnQgaGFuZGxlciBmb3Igd2hlbiB0aGUgYDxMaW5rPmAgaXMgY2xpY2tlZC5cbiAgICovXG4gIG9uQ2xpY2s/OiBSZWFjdC5Nb3VzZUV2ZW50SGFuZGxlcjxIVE1MQW5jaG9yRWxlbWVudD5cblxuICAvKipcbiAgICogT3B0aW9uYWwgZXZlbnQgaGFuZGxlciBmb3Igd2hlbiB0aGUgYDxMaW5rPmAgaXMgbmF2aWdhdGVkLlxuICAgKi9cbiAgb25OYXZpZ2F0ZT86IE9uTmF2aWdhdGVFdmVudEhhbmRsZXJcbn1cblxuLy8gVE9ETy1BUFA6IEluY2x1ZGUgdGhlIGZ1bGwgc2V0IG9mIEFuY2hvciBwcm9wc1xuLy8gYWRkaW5nIHRoaXMgdG8gdGhlIHB1YmxpY2x5IGV4cG9ydGVkIHR5cGUgY3VycmVudGx5IGJyZWFrcyBleGlzdGluZyBhcHBzXG5cbi8vIGBSb3V0ZUluZmVyVHlwZWAgaXMgYSBzdHViIGhlcmUgdG8gYXZvaWQgYnJlYWtpbmcgYHR5cGVkUm91dGVzYCB3aGVuIHRoZSB0eXBlXG4vLyBpc24ndCBnZW5lcmF0ZWQgeWV0LiBJdCB3aWxsIGJlIHJlcGxhY2VkIHdoZW4gdGhlIHdlYnBhY2sgcGx1Z2luIHJ1bnMuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG5leHBvcnQgdHlwZSBMaW5rUHJvcHM8Um91dGVJbmZlclR5cGUgPSBhbnk+ID0gSW50ZXJuYWxMaW5rUHJvcHNcbnR5cGUgTGlua1Byb3BzUmVxdWlyZWQgPSBSZXF1aXJlZEtleXM8TGlua1Byb3BzPlxudHlwZSBMaW5rUHJvcHNPcHRpb25hbCA9IE9wdGlvbmFsS2V5czxPbWl0PEludGVybmFsTGlua1Byb3BzLCAnbG9jYWxlJz4+XG5cbmZ1bmN0aW9uIGlzTW9kaWZpZWRFdmVudChldmVudDogUmVhY3QuTW91c2VFdmVudCk6IGJvb2xlYW4ge1xuICBjb25zdCBldmVudFRhcmdldCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQgYXMgSFRNTEFuY2hvckVsZW1lbnQgfCBTVkdBRWxlbWVudFxuICBjb25zdCB0YXJnZXQgPSBldmVudFRhcmdldC5nZXRBdHRyaWJ1dGUoJ3RhcmdldCcpXG4gIHJldHVybiAoXG4gICAgKHRhcmdldCAmJiB0YXJnZXQgIT09ICdfc2VsZicpIHx8XG4gICAgZXZlbnQubWV0YUtleSB8fFxuICAgIGV2ZW50LmN0cmxLZXkgfHxcbiAgICBldmVudC5zaGlmdEtleSB8fFxuICAgIGV2ZW50LmFsdEtleSB8fCAvLyB0cmlnZ2VycyByZXNvdXJjZSBkb3dubG9hZFxuICAgIChldmVudC5uYXRpdmVFdmVudCAmJiBldmVudC5uYXRpdmVFdmVudC53aGljaCA9PT0gMilcbiAgKVxufVxuXG5mdW5jdGlvbiBsaW5rQ2xpY2tlZChcbiAgZTogUmVhY3QuTW91c2VFdmVudCxcbiAgaHJlZjogc3RyaW5nLFxuICBhczogc3RyaW5nLFxuICBsaW5rSW5zdGFuY2VSZWY6IFJlYWN0LlJlZk9iamVjdDxMaW5rSW5zdGFuY2UgfCBudWxsPixcbiAgcmVwbGFjZT86IGJvb2xlYW4sXG4gIHNjcm9sbD86IGJvb2xlYW4sXG4gIG9uTmF2aWdhdGU/OiBPbk5hdmlnYXRlRXZlbnRIYW5kbGVyXG4pOiB2b2lkIHtcbiAgY29uc3QgeyBub2RlTmFtZSB9ID0gZS5jdXJyZW50VGFyZ2V0XG5cbiAgLy8gYW5jaG9ycyBpbnNpZGUgYW4gc3ZnIGhhdmUgYSBsb3dlcmNhc2Ugbm9kZU5hbWVcbiAgY29uc3QgaXNBbmNob3JOb2RlTmFtZSA9IG5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdBJ1xuXG4gIGlmIChcbiAgICAoaXNBbmNob3JOb2RlTmFtZSAmJiBpc01vZGlmaWVkRXZlbnQoZSkpIHx8XG4gICAgZS5jdXJyZW50VGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnZG93bmxvYWQnKVxuICApIHtcbiAgICAvLyBpZ25vcmUgY2xpY2sgZm9yIGJyb3dzZXLigJlzIGRlZmF1bHQgYmVoYXZpb3JcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmICghaXNMb2NhbFVSTChocmVmKSkge1xuICAgIGlmIChyZXBsYWNlKSB7XG4gICAgICAvLyBicm93c2VyIGRlZmF1bHQgYmVoYXZpb3IgZG9lcyBub3QgcmVwbGFjZSB0aGUgaGlzdG9yeSBzdGF0ZVxuICAgICAgLy8gc28gd2UgbmVlZCB0byBkbyBpdCBtYW51YWxseVxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICBsb2NhdGlvbi5yZXBsYWNlKGhyZWYpXG4gICAgfVxuXG4gICAgLy8gaWdub3JlIGNsaWNrIGZvciBicm93c2Vy4oCZcyBkZWZhdWx0IGJlaGF2aW9yXG4gICAgcmV0dXJuXG4gIH1cblxuICBlLnByZXZlbnREZWZhdWx0KClcblxuICBpZiAob25OYXZpZ2F0ZSkge1xuICAgIGxldCBpc0RlZmF1bHRQcmV2ZW50ZWQgPSBmYWxzZVxuXG4gICAgb25OYXZpZ2F0ZSh7XG4gICAgICBwcmV2ZW50RGVmYXVsdDogKCkgPT4ge1xuICAgICAgICBpc0RlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlXG4gICAgICB9LFxuICAgIH0pXG5cbiAgICBpZiAoaXNEZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cblxuICBSZWFjdC5zdGFydFRyYW5zaXRpb24oKCkgPT4ge1xuICAgIGRpc3BhdGNoTmF2aWdhdGVBY3Rpb24oXG4gICAgICBhcyB8fCBocmVmLFxuICAgICAgcmVwbGFjZSA/ICdyZXBsYWNlJyA6ICdwdXNoJyxcbiAgICAgIHNjcm9sbCA/PyB0cnVlLFxuICAgICAgbGlua0luc3RhbmNlUmVmLmN1cnJlbnRcbiAgICApXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGZvcm1hdFN0cmluZ09yVXJsKHVybE9iak9yU3RyaW5nOiBVcmxPYmplY3QgfCBzdHJpbmcpOiBzdHJpbmcge1xuICBpZiAodHlwZW9mIHVybE9iak9yU3RyaW5nID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB1cmxPYmpPclN0cmluZ1xuICB9XG5cbiAgcmV0dXJuIGZvcm1hdFVybCh1cmxPYmpPclN0cmluZylcbn1cblxuLyoqXG4gKiBBIFJlYWN0IGNvbXBvbmVudCB0aGF0IGV4dGVuZHMgdGhlIEhUTUwgYDxhPmAgZWxlbWVudCB0byBwcm92aWRlXG4gKiBbcHJlZmV0Y2hpbmddKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL3JvdXRpbmcvbGlua2luZy1hbmQtbmF2aWdhdGluZyMyLXByZWZldGNoaW5nKVxuICogYW5kIGNsaWVudC1zaWRlIG5hdmlnYXRpb24uIFRoaXMgaXMgdGhlIHByaW1hcnkgd2F5IHRvIG5hdmlnYXRlIGJldHdlZW4gcm91dGVzIGluIE5leHQuanMuXG4gKlxuICogQHJlbWFya3NcbiAqIC0gUHJlZmV0Y2hpbmcgaXMgb25seSBlbmFibGVkIGluIHByb2R1Y3Rpb24uXG4gKlxuICogQHNlZSBodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYXBpLXJlZmVyZW5jZS9jb21wb25lbnRzL2xpbmtcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTGlua0NvbXBvbmVudChcbiAgcHJvcHM6IExpbmtQcm9wcyAmIHtcbiAgICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlXG4gICAgcmVmOiBSZWFjdC5SZWY8SFRNTEFuY2hvckVsZW1lbnQ+XG4gIH1cbikge1xuICBjb25zdCBbbGlua1N0YXR1cywgc2V0T3B0aW1pc3RpY0xpbmtTdGF0dXNdID0gdXNlT3B0aW1pc3RpYyhJRExFX0xJTktfU1RBVFVTKVxuXG4gIGxldCBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlXG5cbiAgY29uc3QgbGlua0luc3RhbmNlUmVmID0gdXNlUmVmPExpbmtJbnN0YW5jZSB8IG51bGw+KG51bGwpXG5cbiAgY29uc3Qge1xuICAgIGhyZWY6IGhyZWZQcm9wLFxuICAgIGFzOiBhc1Byb3AsXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuUHJvcCxcbiAgICBwcmVmZXRjaDogcHJlZmV0Y2hQcm9wID0gbnVsbCxcbiAgICBwYXNzSHJlZixcbiAgICByZXBsYWNlLFxuICAgIHNoYWxsb3csXG4gICAgc2Nyb2xsLFxuICAgIG9uQ2xpY2ssXG4gICAgb25Nb3VzZUVudGVyOiBvbk1vdXNlRW50ZXJQcm9wLFxuICAgIG9uVG91Y2hTdGFydDogb25Ub3VjaFN0YXJ0UHJvcCxcbiAgICBsZWdhY3lCZWhhdmlvciA9IGZhbHNlLFxuICAgIG9uTmF2aWdhdGUsXG4gICAgcmVmOiBmb3J3YXJkZWRSZWYsXG4gICAgdW5zdGFibGVfZHluYW1pY09uSG92ZXIsXG4gICAgLi4ucmVzdFByb3BzXG4gIH0gPSBwcm9wc1xuXG4gIGNoaWxkcmVuID0gY2hpbGRyZW5Qcm9wXG5cbiAgaWYgKFxuICAgIGxlZ2FjeUJlaGF2aW9yICYmXG4gICAgKHR5cGVvZiBjaGlsZHJlbiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGNoaWxkcmVuID09PSAnbnVtYmVyJylcbiAgKSB7XG4gICAgY2hpbGRyZW4gPSA8YT57Y2hpbGRyZW59PC9hPlxuICB9XG5cbiAgY29uc3Qgcm91dGVyID0gUmVhY3QudXNlQ29udGV4dChBcHBSb3V0ZXJDb250ZXh0KVxuXG4gIGNvbnN0IHByZWZldGNoRW5hYmxlZCA9IHByZWZldGNoUHJvcCAhPT0gZmFsc2VcbiAgLyoqXG4gICAqIFRoZSBwb3NzaWJsZSBzdGF0ZXMgZm9yIHByZWZldGNoIGFyZTpcbiAgICogLSBudWxsOiB0aGlzIGlzIHRoZSBkZWZhdWx0IFwiYXV0b1wiIG1vZGUsIHdoZXJlIHdlIHdpbGwgcHJlZmV0Y2ggcGFydGlhbGx5IGlmIHRoZSBsaW5rIGlzIGluIHRoZSB2aWV3cG9ydFxuICAgKiAtIHRydWU6IHdlIHdpbGwgcHJlZmV0Y2ggaWYgdGhlIGxpbmsgaXMgdmlzaWJsZSBhbmQgcHJlZmV0Y2ggdGhlIGZ1bGwgcGFnZSwgbm90IGp1c3QgcGFydGlhbGx5XG4gICAqIC0gZmFsc2U6IHdlIHdpbGwgbm90IHByZWZldGNoIGlmIGluIHRoZSB2aWV3cG9ydCBhdCBhbGxcbiAgICogLSAndW5zdGFibGVfZHluYW1pY09uSG92ZXInOiB0aGlzIHN0YXJ0cyBpbiBcImF1dG9cIiBtb2RlLCBidXQgc3dpdGNoZXMgdG8gXCJmdWxsXCIgd2hlbiB0aGUgbGluayBpcyBob3ZlcmVkXG4gICAqL1xuICBjb25zdCBhcHBQcmVmZXRjaEtpbmQgPVxuICAgIHByZWZldGNoUHJvcCA9PT0gbnVsbCB8fCBwcmVmZXRjaFByb3AgPT09ICdhdXRvJ1xuICAgICAgPyBQcmVmZXRjaEtpbmQuQVVUT1xuICAgICAgOiBQcmVmZXRjaEtpbmQuRlVMTFxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlUHJvcEVycm9yKGFyZ3M6IHtcbiAgICAgIGtleTogc3RyaW5nXG4gICAgICBleHBlY3RlZDogc3RyaW5nXG4gICAgICBhY3R1YWw6IHN0cmluZ1xuICAgIH0pIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gICAgICAgIGBGYWlsZWQgcHJvcCB0eXBlOiBUaGUgcHJvcCBcXGAke2FyZ3Mua2V5fVxcYCBleHBlY3RzIGEgJHthcmdzLmV4cGVjdGVkfSBpbiBcXGA8TGluaz5cXGAsIGJ1dCBnb3QgXFxgJHthcmdzLmFjdHVhbH1cXGAgaW5zdGVhZC5gICtcbiAgICAgICAgICAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgID8gXCJcXG5PcGVuIHlvdXIgYnJvd3NlcidzIGNvbnNvbGUgdG8gdmlldyB0aGUgQ29tcG9uZW50IHN0YWNrIHRyYWNlLlwiXG4gICAgICAgICAgICA6ICcnKVxuICAgICAgKVxuICAgIH1cblxuICAgIC8vIFR5cGVTY3JpcHQgdHJpY2sgZm9yIHR5cGUtZ3VhcmRpbmc6XG4gICAgY29uc3QgcmVxdWlyZWRQcm9wc0d1YXJkOiBSZWNvcmQ8TGlua1Byb3BzUmVxdWlyZWQsIHRydWU+ID0ge1xuICAgICAgaHJlZjogdHJ1ZSxcbiAgICB9IGFzIGNvbnN0XG4gICAgY29uc3QgcmVxdWlyZWRQcm9wczogTGlua1Byb3BzUmVxdWlyZWRbXSA9IE9iamVjdC5rZXlzKFxuICAgICAgcmVxdWlyZWRQcm9wc0d1YXJkXG4gICAgKSBhcyBMaW5rUHJvcHNSZXF1aXJlZFtdXG4gICAgcmVxdWlyZWRQcm9wcy5mb3JFYWNoKChrZXk6IExpbmtQcm9wc1JlcXVpcmVkKSA9PiB7XG4gICAgICBpZiAoa2V5ID09PSAnaHJlZicpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHByb3BzW2tleV0gPT0gbnVsbCB8fFxuICAgICAgICAgICh0eXBlb2YgcHJvcHNba2V5XSAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIHByb3BzW2tleV0gIT09ICdvYmplY3QnKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aHJvdyBjcmVhdGVQcm9wRXJyb3Ioe1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgZXhwZWN0ZWQ6ICdgc3RyaW5nYCBvciBgb2JqZWN0YCcsXG4gICAgICAgICAgICBhY3R1YWw6IHByb3BzW2tleV0gPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2YgcHJvcHNba2V5XSxcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUeXBlU2NyaXB0IHRyaWNrIGZvciB0eXBlLWd1YXJkaW5nOlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgICAgIGNvbnN0IF86IG5ldmVyID0ga2V5XG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIFR5cGVTY3JpcHQgdHJpY2sgZm9yIHR5cGUtZ3VhcmRpbmc6XG4gICAgY29uc3Qgb3B0aW9uYWxQcm9wc0d1YXJkOiBSZWNvcmQ8TGlua1Byb3BzT3B0aW9uYWwsIHRydWU+ID0ge1xuICAgICAgYXM6IHRydWUsXG4gICAgICByZXBsYWNlOiB0cnVlLFxuICAgICAgc2Nyb2xsOiB0cnVlLFxuICAgICAgc2hhbGxvdzogdHJ1ZSxcbiAgICAgIHBhc3NIcmVmOiB0cnVlLFxuICAgICAgcHJlZmV0Y2g6IHRydWUsXG4gICAgICB1bnN0YWJsZV9keW5hbWljT25Ib3ZlcjogdHJ1ZSxcbiAgICAgIG9uQ2xpY2s6IHRydWUsXG4gICAgICBvbk1vdXNlRW50ZXI6IHRydWUsXG4gICAgICBvblRvdWNoU3RhcnQ6IHRydWUsXG4gICAgICBsZWdhY3lCZWhhdmlvcjogdHJ1ZSxcbiAgICAgIG9uTmF2aWdhdGU6IHRydWUsXG4gICAgfSBhcyBjb25zdFxuICAgIGNvbnN0IG9wdGlvbmFsUHJvcHM6IExpbmtQcm9wc09wdGlvbmFsW10gPSBPYmplY3Qua2V5cyhcbiAgICAgIG9wdGlvbmFsUHJvcHNHdWFyZFxuICAgICkgYXMgTGlua1Byb3BzT3B0aW9uYWxbXVxuICAgIG9wdGlvbmFsUHJvcHMuZm9yRWFjaCgoa2V5OiBMaW5rUHJvcHNPcHRpb25hbCkgPT4ge1xuICAgICAgY29uc3QgdmFsVHlwZSA9IHR5cGVvZiBwcm9wc1trZXldXG5cbiAgICAgIGlmIChrZXkgPT09ICdhcycpIHtcbiAgICAgICAgaWYgKHByb3BzW2tleV0gJiYgdmFsVHlwZSAhPT0gJ3N0cmluZycgJiYgdmFsVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICB0aHJvdyBjcmVhdGVQcm9wRXJyb3Ioe1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgZXhwZWN0ZWQ6ICdgc3RyaW5nYCBvciBgb2JqZWN0YCcsXG4gICAgICAgICAgICBhY3R1YWw6IHZhbFR5cGUsXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAga2V5ID09PSAnb25DbGljaycgfHxcbiAgICAgICAga2V5ID09PSAnb25Nb3VzZUVudGVyJyB8fFxuICAgICAgICBrZXkgPT09ICdvblRvdWNoU3RhcnQnIHx8XG4gICAgICAgIGtleSA9PT0gJ29uTmF2aWdhdGUnXG4gICAgICApIHtcbiAgICAgICAgaWYgKHByb3BzW2tleV0gJiYgdmFsVHlwZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRocm93IGNyZWF0ZVByb3BFcnJvcih7XG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBleHBlY3RlZDogJ2BmdW5jdGlvbmAnLFxuICAgICAgICAgICAgYWN0dWFsOiB2YWxUeXBlLFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGtleSA9PT0gJ3JlcGxhY2UnIHx8XG4gICAgICAgIGtleSA9PT0gJ3Njcm9sbCcgfHxcbiAgICAgICAga2V5ID09PSAnc2hhbGxvdycgfHxcbiAgICAgICAga2V5ID09PSAncGFzc0hyZWYnIHx8XG4gICAgICAgIGtleSA9PT0gJ2xlZ2FjeUJlaGF2aW9yJyB8fFxuICAgICAgICBrZXkgPT09ICd1bnN0YWJsZV9keW5hbWljT25Ib3ZlcidcbiAgICAgICkge1xuICAgICAgICBpZiAocHJvcHNba2V5XSAhPSBudWxsICYmIHZhbFR5cGUgIT09ICdib29sZWFuJykge1xuICAgICAgICAgIHRocm93IGNyZWF0ZVByb3BFcnJvcih7XG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBleHBlY3RlZDogJ2Bib29sZWFuYCcsXG4gICAgICAgICAgICBhY3R1YWw6IHZhbFR5cGUsXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdwcmVmZXRjaCcpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHByb3BzW2tleV0gIT0gbnVsbCAmJlxuICAgICAgICAgIHZhbFR5cGUgIT09ICdib29sZWFuJyAmJlxuICAgICAgICAgIHByb3BzW2tleV0gIT09ICdhdXRvJ1xuICAgICAgICApIHtcbiAgICAgICAgICB0aHJvdyBjcmVhdGVQcm9wRXJyb3Ioe1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgZXhwZWN0ZWQ6ICdgYm9vbGVhbiB8IFwiYXV0b1wiYCcsXG4gICAgICAgICAgICBhY3R1YWw6IHZhbFR5cGUsXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVHlwZVNjcmlwdCB0cmljayBmb3IgdHlwZS1ndWFyZGluZzpcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgICBjb25zdCBfOiBuZXZlciA9IGtleVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChwcm9wcy5sb2NhbGUpIHtcbiAgICAgIHdhcm5PbmNlKFxuICAgICAgICAnVGhlIGBsb2NhbGVgIHByb3AgaXMgbm90IHN1cHBvcnRlZCBpbiBgbmV4dC9saW5rYCB3aGlsZSB1c2luZyB0aGUgYGFwcGAgcm91dGVyLiBSZWFkIG1vcmUgYWJvdXQgYXBwIHJvdXRlciBpbnRlcm5hbGl6YXRpb246IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL3JvdXRpbmcvaW50ZXJuYXRpb25hbGl6YXRpb24nXG4gICAgICApXG4gICAgfVxuICAgIGlmICghYXNQcm9wKSB7XG4gICAgICBsZXQgaHJlZjogc3RyaW5nIHwgdW5kZWZpbmVkXG4gICAgICBpZiAodHlwZW9mIGhyZWZQcm9wID09PSAnc3RyaW5nJykge1xuICAgICAgICBocmVmID0gaHJlZlByb3BcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIHR5cGVvZiBocmVmUHJvcCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgdHlwZW9mIGhyZWZQcm9wLnBhdGhuYW1lID09PSAnc3RyaW5nJ1xuICAgICAgKSB7XG4gICAgICAgIGhyZWYgPSBocmVmUHJvcC5wYXRobmFtZVxuICAgICAgfVxuXG4gICAgICBpZiAoaHJlZikge1xuICAgICAgICBjb25zdCBoYXNEeW5hbWljU2VnbWVudCA9IGhyZWZcbiAgICAgICAgICAuc3BsaXQoJy8nKVxuICAgICAgICAgIC5zb21lKChzZWdtZW50KSA9PiBzZWdtZW50LnN0YXJ0c1dpdGgoJ1snKSAmJiBzZWdtZW50LmVuZHNXaXRoKCddJykpXG5cbiAgICAgICAgaWYgKGhhc0R5bmFtaWNTZWdtZW50KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYER5bmFtaWMgaHJlZiBcXGAke2hyZWZ9XFxgIGZvdW5kIGluIDxMaW5rPiB3aGlsZSB1c2luZyB0aGUgXFxgL2FwcFxcYCByb3V0ZXIsIHRoaXMgaXMgbm90IHN1cHBvcnRlZC4gUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9hcHAtZGlyLWR5bmFtaWMtaHJlZmBcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCB7IGhyZWYsIGFzIH0gPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCByZXNvbHZlZEhyZWYgPSBmb3JtYXRTdHJpbmdPclVybChocmVmUHJvcClcbiAgICByZXR1cm4ge1xuICAgICAgaHJlZjogcmVzb2x2ZWRIcmVmLFxuICAgICAgYXM6IGFzUHJvcCA/IGZvcm1hdFN0cmluZ09yVXJsKGFzUHJvcCkgOiByZXNvbHZlZEhyZWYsXG4gICAgfVxuICB9LCBbaHJlZlByb3AsIGFzUHJvcF0pXG5cbiAgLy8gVGhpcyB3aWxsIHJldHVybiB0aGUgZmlyc3QgY2hpbGQsIGlmIG11bHRpcGxlIGFyZSBwcm92aWRlZCBpdCB3aWxsIHRocm93IGFuIGVycm9yXG4gIGxldCBjaGlsZDogYW55XG4gIGlmIChsZWdhY3lCZWhhdmlvcikge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgaWYgKG9uQ2xpY2spIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIGBcIm9uQ2xpY2tcIiB3YXMgcGFzc2VkIHRvIDxMaW5rPiB3aXRoIFxcYGhyZWZcXGAgb2YgXFxgJHtocmVmUHJvcH1cXGAgYnV0IFwibGVnYWN5QmVoYXZpb3JcIiB3YXMgc2V0LiBUaGUgbGVnYWN5IGJlaGF2aW9yIHJlcXVpcmVzIG9uQ2xpY2sgYmUgc2V0IG9uIHRoZSBjaGlsZCBvZiBuZXh0L2xpbmtgXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIGlmIChvbk1vdXNlRW50ZXJQcm9wKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBgXCJvbk1vdXNlRW50ZXJcIiB3YXMgcGFzc2VkIHRvIDxMaW5rPiB3aXRoIFxcYGhyZWZcXGAgb2YgXFxgJHtocmVmUHJvcH1cXGAgYnV0IFwibGVnYWN5QmVoYXZpb3JcIiB3YXMgc2V0LiBUaGUgbGVnYWN5IGJlaGF2aW9yIHJlcXVpcmVzIG9uTW91c2VFbnRlciBiZSBzZXQgb24gdGhlIGNoaWxkIG9mIG5leHQvbGlua2BcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgY2hpbGQgPSBSZWFjdC5DaGlsZHJlbi5vbmx5KGNoaWxkcmVuKVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgTm8gY2hpbGRyZW4gd2VyZSBwYXNzZWQgdG8gPExpbms+IHdpdGggXFxgaHJlZlxcYCBvZiBcXGAke2hyZWZQcm9wfVxcYCBidXQgb25lIGNoaWxkIGlzIHJlcXVpcmVkIGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2xpbmstbm8tY2hpbGRyZW5gXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgTXVsdGlwbGUgY2hpbGRyZW4gd2VyZSBwYXNzZWQgdG8gPExpbms+IHdpdGggXFxgaHJlZlxcYCBvZiBcXGAke2hyZWZQcm9wfVxcYCBidXQgb25seSBvbmUgY2hpbGQgaXMgc3VwcG9ydGVkIGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2xpbmstbXVsdGlwbGUtY2hpbGRyZW5gICtcbiAgICAgICAgICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICA/IFwiIFxcbk9wZW4geW91ciBicm93c2VyJ3MgY29uc29sZSB0byB2aWV3IHRoZSBDb21wb25lbnQgc3RhY2sgdHJhY2UuXCJcbiAgICAgICAgICAgICAgOiAnJylcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjaGlsZCA9IFJlYWN0LkNoaWxkcmVuLm9ubHkoY2hpbGRyZW4pXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgaWYgKChjaGlsZHJlbiBhcyBhbnkpPy50eXBlID09PSAnYScpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdJbnZhbGlkIDxMaW5rPiB3aXRoIDxhPiBjaGlsZC4gUGxlYXNlIHJlbW92ZSA8YT4gb3IgdXNlIDxMaW5rIGxlZ2FjeUJlaGF2aW9yPi5cXG5MZWFybiBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9pbnZhbGlkLW5ldy1saW5rLXdpdGgtZXh0cmEtYW5jaG9yJ1xuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29uc3QgY2hpbGRSZWY6IGFueSA9IGxlZ2FjeUJlaGF2aW9yXG4gICAgPyBjaGlsZCAmJiB0eXBlb2YgY2hpbGQgPT09ICdvYmplY3QnICYmIGNoaWxkLnJlZlxuICAgIDogZm9yd2FyZGVkUmVmXG5cbiAgLy8gVXNlIGEgY2FsbGJhY2sgcmVmIHRvIGF0dGFjaCBhbiBJbnRlcnNlY3Rpb25PYnNlcnZlciB0byB0aGUgYW5jaG9yIHRhZyBvblxuICAvLyBtb3VudC4gSW4gdGhlIGZ1dHVyZSB3ZSB3aWxsIGFsc28gdXNlIHRoaXMgdG8ga2VlcCB0cmFjayBvZiBhbGwgdGhlXG4gIC8vIGN1cnJlbnRseSBtb3VudGVkIDxMaW5rPiBpbnN0YW5jZXMsIGUuZy4gc28gd2UgY2FuIHJlLXByZWZldGNoIHRoZW0gYWZ0ZXJcbiAgLy8gYSByZXZhbGlkYXRpb24gb3IgcmVmcmVzaC5cbiAgY29uc3Qgb2JzZXJ2ZUxpbmtWaXNpYmlsaXR5T25Nb3VudCA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgIChlbGVtZW50OiBIVE1MQW5jaG9yRWxlbWVudCB8IFNWR0FFbGVtZW50KSA9PiB7XG4gICAgICBpZiAocm91dGVyICE9PSBudWxsKSB7XG4gICAgICAgIGxpbmtJbnN0YW5jZVJlZi5jdXJyZW50ID0gbW91bnRMaW5rSW5zdGFuY2UoXG4gICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICBocmVmLFxuICAgICAgICAgIHJvdXRlcixcbiAgICAgICAgICBhcHBQcmVmZXRjaEtpbmQsXG4gICAgICAgICAgcHJlZmV0Y2hFbmFibGVkLFxuICAgICAgICAgIHNldE9wdGltaXN0aWNMaW5rU3RhdHVzXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaWYgKGxpbmtJbnN0YW5jZVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgdW5tb3VudExpbmtGb3JDdXJyZW50TmF2aWdhdGlvbihsaW5rSW5zdGFuY2VSZWYuY3VycmVudClcbiAgICAgICAgICBsaW5rSW5zdGFuY2VSZWYuY3VycmVudCA9IG51bGxcbiAgICAgICAgfVxuICAgICAgICB1bm1vdW50UHJlZmV0Y2hhYmxlSW5zdGFuY2UoZWxlbWVudClcbiAgICAgIH1cbiAgICB9LFxuICAgIFtwcmVmZXRjaEVuYWJsZWQsIGhyZWYsIHJvdXRlciwgYXBwUHJlZmV0Y2hLaW5kLCBzZXRPcHRpbWlzdGljTGlua1N0YXR1c11cbiAgKVxuXG4gIGNvbnN0IG1lcmdlZFJlZiA9IHVzZU1lcmdlZFJlZihvYnNlcnZlTGlua1Zpc2liaWxpdHlPbk1vdW50LCBjaGlsZFJlZilcblxuICBjb25zdCBjaGlsZFByb3BzOiB7XG4gICAgb25Ub3VjaFN0YXJ0PzogUmVhY3QuVG91Y2hFdmVudEhhbmRsZXI8SFRNTEFuY2hvckVsZW1lbnQ+XG4gICAgb25Nb3VzZUVudGVyOiBSZWFjdC5Nb3VzZUV2ZW50SGFuZGxlcjxIVE1MQW5jaG9yRWxlbWVudD5cbiAgICBvbkNsaWNrOiBSZWFjdC5Nb3VzZUV2ZW50SGFuZGxlcjxIVE1MQW5jaG9yRWxlbWVudD5cbiAgICBocmVmPzogc3RyaW5nXG4gICAgcmVmPzogYW55XG4gIH0gPSB7XG4gICAgcmVmOiBtZXJnZWRSZWYsXG4gICAgb25DbGljayhlKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAoIWUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgQ29tcG9uZW50IHJlbmRlcmVkIGluc2lkZSBuZXh0L2xpbmsgaGFzIHRvIHBhc3MgY2xpY2sgZXZlbnQgdG8gXCJvbkNsaWNrXCIgcHJvcC5gXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghbGVnYWN5QmVoYXZpb3IgJiYgdHlwZW9mIG9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb25DbGljayhlKVxuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgIGxlZ2FjeUJlaGF2aW9yICYmXG4gICAgICAgIGNoaWxkLnByb3BzICYmXG4gICAgICAgIHR5cGVvZiBjaGlsZC5wcm9wcy5vbkNsaWNrID09PSAnZnVuY3Rpb24nXG4gICAgICApIHtcbiAgICAgICAgY2hpbGQucHJvcHMub25DbGljayhlKVxuICAgICAgfVxuXG4gICAgICBpZiAoIXJvdXRlcikge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgaWYgKGUuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgbGlua0NsaWNrZWQoZSwgaHJlZiwgYXMsIGxpbmtJbnN0YW5jZVJlZiwgcmVwbGFjZSwgc2Nyb2xsLCBvbk5hdmlnYXRlKVxuICAgIH0sXG4gICAgb25Nb3VzZUVudGVyKGUpIHtcbiAgICAgIGlmICghbGVnYWN5QmVoYXZpb3IgJiYgdHlwZW9mIG9uTW91c2VFbnRlclByb3AgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb25Nb3VzZUVudGVyUHJvcChlKVxuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgIGxlZ2FjeUJlaGF2aW9yICYmXG4gICAgICAgIGNoaWxkLnByb3BzICYmXG4gICAgICAgIHR5cGVvZiBjaGlsZC5wcm9wcy5vbk1vdXNlRW50ZXIgPT09ICdmdW5jdGlvbidcbiAgICAgICkge1xuICAgICAgICBjaGlsZC5wcm9wcy5vbk1vdXNlRW50ZXIoZSlcbiAgICAgIH1cblxuICAgICAgaWYgKCFyb3V0ZXIpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGlmICghcHJlZmV0Y2hFbmFibGVkIHx8IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cGdyYWRlVG9EeW5hbWljUHJlZmV0Y2ggPSB1bnN0YWJsZV9keW5hbWljT25Ib3ZlciA9PT0gdHJ1ZVxuICAgICAgb25OYXZpZ2F0aW9uSW50ZW50KFxuICAgICAgICBlLmN1cnJlbnRUYXJnZXQgYXMgSFRNTEFuY2hvckVsZW1lbnQgfCBTVkdBRWxlbWVudCxcbiAgICAgICAgdXBncmFkZVRvRHluYW1pY1ByZWZldGNoXG4gICAgICApXG4gICAgfSxcbiAgICBvblRvdWNoU3RhcnQ6IHByb2Nlc3MuZW52Ll9fTkVYVF9MSU5LX05PX1RPVUNIX1NUQVJUXG4gICAgICA/IHVuZGVmaW5lZFxuICAgICAgOiBmdW5jdGlvbiBvblRvdWNoU3RhcnQoZSkge1xuICAgICAgICAgIGlmICghbGVnYWN5QmVoYXZpb3IgJiYgdHlwZW9mIG9uVG91Y2hTdGFydFByb3AgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG9uVG91Y2hTdGFydFByb3AoZSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBsZWdhY3lCZWhhdmlvciAmJlxuICAgICAgICAgICAgY2hpbGQucHJvcHMgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjaGlsZC5wcm9wcy5vblRvdWNoU3RhcnQgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGNoaWxkLnByb3BzLm9uVG91Y2hTdGFydChlKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghcm91dGVyKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIXByZWZldGNoRW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgdXBncmFkZVRvRHluYW1pY1ByZWZldGNoID0gdW5zdGFibGVfZHluYW1pY09uSG92ZXIgPT09IHRydWVcbiAgICAgICAgICBvbk5hdmlnYXRpb25JbnRlbnQoXG4gICAgICAgICAgICBlLmN1cnJlbnRUYXJnZXQgYXMgSFRNTEFuY2hvckVsZW1lbnQgfCBTVkdBRWxlbWVudCxcbiAgICAgICAgICAgIHVwZ3JhZGVUb0R5bmFtaWNQcmVmZXRjaFxuICAgICAgICAgIClcbiAgICAgICAgfSxcbiAgfVxuXG4gIC8vIElmIGNoaWxkIGlzIGFuIDxhPiB0YWcgYW5kIGRvZXNuJ3QgaGF2ZSBhIGhyZWYgYXR0cmlidXRlLCBvciBpZiB0aGUgJ3Bhc3NIcmVmJyBwcm9wZXJ0eSBpc1xuICAvLyBkZWZpbmVkLCB3ZSBzcGVjaWZ5IHRoZSBjdXJyZW50ICdocmVmJywgc28gdGhhdCByZXBldGl0aW9uIGlzIG5vdCBuZWVkZWQgYnkgdGhlIHVzZXIuXG4gIC8vIElmIHRoZSB1cmwgaXMgYWJzb2x1dGUsIHdlIGNhbiBieXBhc3MgdGhlIGxvZ2ljIHRvIHByZXBlbmQgdGhlIGJhc2VQYXRoLlxuICBpZiAoaXNBYnNvbHV0ZVVybChhcykpIHtcbiAgICBjaGlsZFByb3BzLmhyZWYgPSBhc1xuICB9IGVsc2UgaWYgKFxuICAgICFsZWdhY3lCZWhhdmlvciB8fFxuICAgIHBhc3NIcmVmIHx8XG4gICAgKGNoaWxkLnR5cGUgPT09ICdhJyAmJiAhKCdocmVmJyBpbiBjaGlsZC5wcm9wcykpXG4gICkge1xuICAgIGNoaWxkUHJvcHMuaHJlZiA9IGFkZEJhc2VQYXRoKGFzKVxuICB9XG5cbiAgbGV0IGxpbms6IFJlYWN0LlJlYWN0Tm9kZVxuXG4gIGlmIChsZWdhY3lCZWhhdmlvcikge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgZXJyb3JPbmNlKFxuICAgICAgICAnYGxlZ2FjeUJlaGF2aW9yYCBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgJyArXG4gICAgICAgICAgJ3JlbGVhc2UuIEEgY29kZW1vZCBpcyBhdmFpbGFibGUgdG8gdXBncmFkZSB5b3VyIGNvbXBvbmVudHM6XFxuXFxuJyArXG4gICAgICAgICAgJ25weCBAbmV4dC9jb2RlbW9kQGxhdGVzdCBuZXctbGluayAuXFxuXFxuJyArXG4gICAgICAgICAgJ0xlYXJuIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL3VwZ3JhZGluZy9jb2RlbW9kcyNyZW1vdmUtYS10YWdzLWZyb20tbGluay1jb21wb25lbnRzJ1xuICAgICAgKVxuICAgIH1cbiAgICBsaW5rID0gUmVhY3QuY2xvbmVFbGVtZW50KGNoaWxkLCBjaGlsZFByb3BzKVxuICB9IGVsc2Uge1xuICAgIGxpbmsgPSAoXG4gICAgICA8YSB7Li4ucmVzdFByb3BzfSB7Li4uY2hpbGRQcm9wc30+XG4gICAgICAgIHtjaGlsZHJlbn1cbiAgICAgIDwvYT5cbiAgICApXG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxMaW5rU3RhdHVzQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17bGlua1N0YXR1c30+XG4gICAgICB7bGlua31cbiAgICA8L0xpbmtTdGF0dXNDb250ZXh0LlByb3ZpZGVyPlxuICApXG59XG5cbmNvbnN0IExpbmtTdGF0dXNDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxcbiAgdHlwZW9mIFBFTkRJTkdfTElOS19TVEFUVVMgfCB0eXBlb2YgSURMRV9MSU5LX1NUQVRVU1xuPihJRExFX0xJTktfU1RBVFVTKVxuXG5leHBvcnQgY29uc3QgdXNlTGlua1N0YXR1cyA9ICgpID0+IHtcbiAgcmV0dXJuIHVzZUNvbnRleHQoTGlua1N0YXR1c0NvbnRleHQpXG59XG4iXSwibmFtZXMiOlsiTGlua0NvbXBvbmVudCIsInVzZUxpbmtTdGF0dXMiLCJpc01vZGlmaWVkRXZlbnQiLCJldmVudCIsImV2ZW50VGFyZ2V0IiwiY3VycmVudFRhcmdldCIsInRhcmdldCIsImdldEF0dHJpYnV0ZSIsIm1ldGFLZXkiLCJjdHJsS2V5Iiwic2hpZnRLZXkiLCJhbHRLZXkiLCJuYXRpdmVFdmVudCIsIndoaWNoIiwibGlua0NsaWNrZWQiLCJlIiwiaHJlZiIsImFzIiwibGlua0luc3RhbmNlUmVmIiwicmVwbGFjZSIsInNjcm9sbCIsIm9uTmF2aWdhdGUiLCJub2RlTmFtZSIsImlzQW5jaG9yTm9kZU5hbWUiLCJ0b1VwcGVyQ2FzZSIsImhhc0F0dHJpYnV0ZSIsImlzTG9jYWxVUkwiLCJwcmV2ZW50RGVmYXVsdCIsImxvY2F0aW9uIiwiaXNEZWZhdWx0UHJldmVudGVkIiwiUmVhY3QiLCJzdGFydFRyYW5zaXRpb24iLCJkaXNwYXRjaE5hdmlnYXRlQWN0aW9uIiwiY3VycmVudCIsImZvcm1hdFN0cmluZ09yVXJsIiwidXJsT2JqT3JTdHJpbmciLCJmb3JtYXRVcmwiLCJwcm9wcyIsImxpbmtTdGF0dXMiLCJzZXRPcHRpbWlzdGljTGlua1N0YXR1cyIsInVzZU9wdGltaXN0aWMiLCJJRExFX0xJTktfU1RBVFVTIiwiY2hpbGRyZW4iLCJ1c2VSZWYiLCJocmVmUHJvcCIsImFzUHJvcCIsImNoaWxkcmVuUHJvcCIsInByZWZldGNoIiwicHJlZmV0Y2hQcm9wIiwicGFzc0hyZWYiLCJzaGFsbG93Iiwib25DbGljayIsIm9uTW91c2VFbnRlciIsIm9uTW91c2VFbnRlclByb3AiLCJvblRvdWNoU3RhcnQiLCJvblRvdWNoU3RhcnRQcm9wIiwibGVnYWN5QmVoYXZpb3IiLCJyZWYiLCJmb3J3YXJkZWRSZWYiLCJ1bnN0YWJsZV9keW5hbWljT25Ib3ZlciIsInJlc3RQcm9wcyIsImEiLCJyb3V0ZXIiLCJ1c2VDb250ZXh0IiwiQXBwUm91dGVyQ29udGV4dCIsInByZWZldGNoRW5hYmxlZCIsImFwcFByZWZldGNoS2luZCIsIlByZWZldGNoS2luZCIsIkFVVE8iLCJGVUxMIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiY3JlYXRlUHJvcEVycm9yIiwiYXJncyIsIkVycm9yIiwia2V5IiwiZXhwZWN0ZWQiLCJhY3R1YWwiLCJ3aW5kb3ciLCJyZXF1aXJlZFByb3BzR3VhcmQiLCJyZXF1aXJlZFByb3BzIiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJfIiwib3B0aW9uYWxQcm9wc0d1YXJkIiwib3B0aW9uYWxQcm9wcyIsInZhbFR5cGUiLCJsb2NhbGUiLCJ3YXJuT25jZSIsInBhdGhuYW1lIiwiaGFzRHluYW1pY1NlZ21lbnQiLCJzcGxpdCIsInNvbWUiLCJzZWdtZW50Iiwic3RhcnRzV2l0aCIsImVuZHNXaXRoIiwidXNlTWVtbyIsInJlc29sdmVkSHJlZiIsImNoaWxkIiwiY29uc29sZSIsIndhcm4iLCJDaGlsZHJlbiIsIm9ubHkiLCJlcnIiLCJ0eXBlIiwiY2hpbGRSZWYiLCJvYnNlcnZlTGlua1Zpc2liaWxpdHlPbk1vdW50IiwidXNlQ2FsbGJhY2siLCJlbGVtZW50IiwibW91bnRMaW5rSW5zdGFuY2UiLCJ1bm1vdW50TGlua0ZvckN1cnJlbnROYXZpZ2F0aW9uIiwidW5tb3VudFByZWZldGNoYWJsZUluc3RhbmNlIiwibWVyZ2VkUmVmIiwidXNlTWVyZ2VkUmVmIiwiY2hpbGRQcm9wcyIsImRlZmF1bHRQcmV2ZW50ZWQiLCJ1cGdyYWRlVG9EeW5hbWljUHJlZmV0Y2giLCJvbk5hdmlnYXRpb25JbnRlbnQiLCJfX05FWFRfTElOS19OT19UT1VDSF9TVEFSVCIsInVuZGVmaW5lZCIsImlzQWJzb2x1dGVVcmwiLCJhZGRCYXNlUGF0aCIsImxpbmsiLCJlcnJvck9uY2UiLCJjbG9uZUVsZW1lbnQiLCJMaW5rU3RhdHVzQ29udGV4dCIsIlByb3ZpZGVyIiwidmFsdWUiLCJjcmVhdGVDb250ZXh0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztJQWlUQTs7Ozs7Ozs7O0NBU0MsR0FDRCxPQXNhQyxFQUFBO2VBdGF1QkE7O0lBNGFYQyxhQUFhLEVBQUE7ZUFBYkE7Ozs7O2lFQXJ1QjJEOzJCQUU5QzsrQ0FDTztvQ0FDSjs4QkFDQTt1QkFDQzs2QkFDRjswQkFDSDt1QkFTbEI7NEJBQ29CO21DQUNZOzJCQUNiO0FBME0xQixTQUFTQyxnQkFBZ0JDLEtBQXVCO0lBQzlDLE1BQU1DLGNBQWNELE1BQU1FLGFBQWE7SUFDdkMsTUFBTUMsU0FBU0YsWUFBWUcsWUFBWSxDQUFDO0lBQ3hDLE9BQ0dELFVBQVVBLFdBQVcsV0FDdEJILE1BQU1LLE9BQU8sSUFDYkwsTUFBTU0sT0FBTyxJQUNiTixNQUFNTyxRQUFRLElBQ2RQLE1BQU1RLE1BQU0sSUFBSSw2QkFBNkI7SUFDNUNSLE1BQU1TLFdBQVcsSUFBSVQsTUFBTVMsV0FBVyxDQUFDQyxLQUFL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WSxDQUFDMUIsT0FBT2dCO0lBQ25DLE9BQU87UUFDTFEsT0FBQUEsV0FBQUEsR0FDRSxDQUFBLEdBQUEsWUFBQSxHQUFBLEVBQUMvRCxLQUFBQTtZQUFHLEdBQUdELFNBQVM7WUFBRyxHQUFHd0QsVUFBVTtzQkFDN0IxRTs7SUFHUDtJQUVBLE9BQUEsV0FBQSxHQUNFLENBQUEsR0FBQSxZQUFBLEdBQUEsRUFBQ3FGLGtCQUFrQkMsUUFBUSxFQUFBO1FBQUNDLE9BQU8zRjtrQkFDaENzRjs7QUFHUDtBQUVBLE1BQU1HLG9CQUFBQSxXQUFBQSxHQUFvQkcsQ0FBQUEsR0FBQUEsT0FBQUEsYUFBYSxFQUVyQ3pGLE9BQUFBLGdCQUFnQjtBQUVYLE1BQU14QyxnQkFBZ0I7SUFDM0IsT0FBTzhELENBQUFBLEdBQUFBLE9BQUFBLFVBQVUsRUFBQ2dFO0FBQ3BCIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDEzMzkxLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzLyU0MHJhZGl4LXVpL3JlYWN0LWNvbXBvc2UtcmVmcy9zcmMvY29tcG9zZS1yZWZzLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbnR5cGUgUG9zc2libGVSZWY8VD4gPSBSZWFjdC5SZWY8VD4gfCB1bmRlZmluZWQ7XG5cbi8qKlxuICogU2V0IGEgZ2l2ZW4gcmVmIHRvIGEgZ2l2ZW4gdmFsdWVcbiAqIFRoaXMgdXRpbGl0eSB0YWtlcyBjYXJlIG9mIGRpZmZlcmVudCB0eXBlcyBvZiByZWZzOiBjYWxsYmFjayByZWZzIGFuZCBSZWZPYmplY3QocylcbiAqL1xuZnVuY3Rpb24gc2V0UmVmPFQ+KHJlZjogUG9zc2libGVSZWY8VD4sIHZhbHVlOiBUKSB7XG4gIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHJlZih2YWx1ZSk7XG4gIH0gZWxzZSBpZiAocmVmICE9PSBudWxsICYmIHJlZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgfVxufVxuXG4vKipcbiAqIEEgdXRpbGl0eSB0byBjb21wb3NlIG11bHRpcGxlIHJlZnMgdG9nZXRoZXJcbiAqIEFjY2VwdHMgY2FsbGJhY2sgcmVmcyBhbmQgUmVmT2JqZWN0KHMpXG4gKi9cbmZ1bmN0aW9uIGNvbXBvc2VSZWZzPFQ+KC4uLnJlZnM6IFBvc3NpYmxlUmVmPFQ+W10pOiBSZWFjdC5SZWZDYWxsYmFjazxUPiB7XG4gIHJldHVybiAobm9kZSkgPT4ge1xuICAgIGxldCBoYXNDbGVhbnVwID0gZmFsc2U7XG4gICAgY29uc3QgY2xlYW51cHMgPSByZWZzLm1hcCgocmVmKSA9PiB7XG4gICAgICBjb25zdCBjbGVhbnVwID0gc2V0UmVmKHJlZiwgbm9kZSk7XG4gICAgICBpZiAoIWhhc0NsZWFudXAgJiYgdHlwZW9mIGNsZWFudXAgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBoYXNDbGVhbnVwID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjbGVhbnVwO1xuICAgIH0pO1xuXG4gICAgLy8gUmVhY3QgPDE5IHdpbGwgbG9nIGFuIGVycm9yIHRvIHRoZSBjb25zb2xlIGlmIGEgY2FsbGJhY2sgcmVmIHJldHVybnMgYVxuICAgIC8vIHZhbHVlLiBXZSBkb24ndCB1c2UgcmVmIGNsZWFudXBzIGludGVybmFsbHkgc28gdGhpcyB3aWxsIG9ubHkgaGFwcGVuIGlmIGFcbiAgICAvLyB1c2VyJ3MgcmVmIGNhbGxiYWNrIHJldHVybnMgYSB2YWx1ZSwgd2hpY2ggd2Ugb25seSBleHBlY3QgaWYgdGhleSBhcmVcbiAgICAvLyB1c2luZyB0aGUgY2xlYW51cCBmdW5jdGlvbmFsaXR5IGFkZGVkIGluIFJlYWN0IDE5LlxuICAgIGlmIChoYXNDbGVhbnVwKSB7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNsZWFudXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgY2xlYW51cCA9IGNsZWFudXBzW2ldO1xuICAgICAgICAgIGlmICh0eXBlb2YgY2xlYW51cCA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldFJlZihyZWZzW2ldLCBudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIEEgY3VzdG9tIGhvb2sgdGhhdCBjb21wb3NlcyBtdWx0aXBsZSByZWZzXG4gKiBBY2NlcHRzIGNhbGxiYWNrIHJlZnMgYW5kIFJlZk9iamVjdChzKVxuICovXG5mdW5jdGlvbiB1c2VDb21wb3NlZFJlZnM8VD4oLi4ucmVmczogUG9zc2libGVSZWY8VD5bXSk6IFJlYWN0LlJlZkNhbGxiYWNrPFQ+IHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICByZXR1cm4gUmVhY3QudXNlQ2FsbGJhY2soY29tcG9zZVJlZnMoLi4ucmVmcyksIHJlZnMpO1xufVxuXG5leHBvcnQgeyBjb21wb3NlUmVmcywgdXNlQ29tcG9zZWRSZWZzIH07XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxZQUFZLFdBQVc7O0FBUXZCLFNBQVMsT0FBVSxHQUFBLEVBQXFCLEtBQUEsRUFBVTtJQUNoRCxJQUFJLE9BQU8sUUFBUSxZQUFZO1FBQzdCLE9BQU8sSUFBSSxLQUFLO0lBQ2xCLE9BQUEsSUFBVyxRQUFRLFFBQVEsUUFBUSxLQUFBLEdBQVc7UUFDNUMsSUFBSSxPQUFBLEdBQVU7SUFDaEI7QUFDRjtBQU1BLFNBQVMsWUFBQSxHQUFrQixJQUFBLEVBQThDO0lBQ3ZFLE9BQU8sQ0FBQyxTQUFTO1FBQ2YsSUFBSSxhQUFhO1FBQ2pCLE1BQU0sV0FBVyxLQUFLLEdBQUEsQ0FBSSxDQUFDLFFBQVE7WUFDakMsTUFBTSxVQUFVLE9BQU8sS0FBSyxJQUFJO1lBQ2hDLElBQUksQ0FBQyxjQUFjLE9BQU8sV0FBVyxZQUFZO2dCQUMvQyxhQUFhO1lBQ2Y7WUFDQSxPQUFPO1FBQ1QsQ0FBQztRQU1ELElBQUksWUFBWTtZQUNkLE9BQU8sTUFBTTtnQkFDWCxJQUFBLElBQVMsSUFBSSxHQUFHLElBQUksU0FBUyxNQUFBLEVBQVEsSUFBSztvQkFDeEMsTUFBTSxVQUFVLFFBQUEsQ0FBUyxDQUFDLENBQUE7b0JBQzFCLElBQUksT0FBTyxXQUFXLFlBQVk7d0JBQ2hDLFFBQVE7b0JBQ1YsT0FBTzt3QkFDTCxPQUFPLElBQUEsQ0FBSyxDQUFDLENBQUEsRUFBRyxJQUFJO29CQUN0QjtnQkFDRjtZQUNGO1FBQ0Y7SUFDRjtBQUNGO0FBTUEsU0FBUyxnQkFBQSxHQUFzQixJQUFBLEVBQThDO0lBRTNFLDZNQUFhLGNBQUEsQ0FBWSxZQUFZLEdBQUcsSUFBSSxHQUFHLElBQUk7QUFDckQiLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDEzNDM4LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzLyU0MHJhZGl4LXVpL3JlYWN0LXNsb3Qvc3JjL3Nsb3QudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNvbXBvc2VSZWZzIH0gZnJvbSAnQHJhZGl4LXVpL3JlYWN0LWNvbXBvc2UtcmVmcyc7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFNsb3RcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuaW50ZXJmYWNlIFNsb3RQcm9wcyBleHRlbmRzIFJlYWN0LkhUTUxBdHRyaWJ1dGVzPEhUTUxFbGVtZW50PiB7XG4gIGNoaWxkcmVuPzogUmVhY3QuUmVhY3ROb2RlO1xufVxuXG4vKiBAX19OT19TSURFX0VGRkVDVFNfXyAqLyBleHBvcnQgZnVuY3Rpb24gY3JlYXRlU2xvdChvd25lck5hbWU6IHN0cmluZykge1xuICBjb25zdCBTbG90Q2xvbmUgPSBjcmVhdGVTbG90Q2xvbmUob3duZXJOYW1lKTtcbiAgY29uc3QgU2xvdCA9IFJlYWN0LmZvcndhcmRSZWY8SFRNTEVsZW1lbnQsIFNsb3RQcm9wcz4oKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgICBjb25zdCB7IGNoaWxkcmVuLCAuLi5zbG90UHJvcHMgfSA9IHByb3BzO1xuICAgIGNvbnN0IGNoaWxkcmVuQXJyYXkgPSBSZWFjdC5DaGlsZHJlbi50b0FycmF5KGNoaWxkcmVuKTtcbiAgICBjb25zdCBzbG90dGFibGUgPSBjaGlsZHJlbkFycmF5LmZpbmQoaXNTbG90dGFibGUpO1xuXG4gICAgaWYgKHNsb3R0YWJsZSkge1xuICAgICAgLy8gdGhlIG5ldyBlbGVtZW50IHRvIHJlbmRlciBpcyB0aGUgb25lIHBhc3NlZCBhcyBhIGNoaWxkIG9mIGBTbG90dGFibGVgXG4gICAgICBjb25zdCBuZXdFbGVtZW50ID0gc2xvdHRhYmxlLnByb3BzLmNoaWxkcmVuO1xuXG4gICAgICBjb25zdCBuZXdDaGlsZHJlbiA9IGNoaWxkcmVuQXJyYXkubWFwKChjaGlsZCkgPT4ge1xuICAgICAgICBpZiAoY2hpbGQgPT09IHNsb3R0YWJsZSkge1xuICAgICAgICAgIC8vIGJlY2F1c2UgdGhlIG5ldyBlbGVtZW50IHdpbGwgYmUgdGhlIG9uZSByZW5kZXJlZCwgd2UgYXJlIG9ubHkgaW50ZXJlc3RlZFxuICAgICAgICAgIC8vIGluIGdyYWJiaW5nIGl0cyBjaGlsZHJlbiAoYG5ld0VsZW1lbnQucHJvcHMuY2hpbGRyZW5gKVxuICAgICAgICAgIGlmIChSZWFjdC5DaGlsZHJlbi5jb3VudChuZXdFbGVtZW50KSA+IDEpIHJldHVybiBSZWFjdC5DaGlsZHJlbi5vbmx5KG51bGwpO1xuICAgICAgICAgIHJldHVybiBSZWFjdC5pc1ZhbGlkRWxlbWVudChuZXdFbGVtZW50KVxuICAgICAgICAgICAgPyAobmV3RWxlbWVudC5wcm9wcyBhcyB7IGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGUgfSkuY2hpbGRyZW5cbiAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gKFxuICAgICAgICA8U2xvdENsb25lIHsuLi5zbG90UHJvcHN9IHJlZj17Zm9yd2FyZGVkUmVmfT5cbiAgICAgICAgICB7UmVhY3QuaXNWYWxpZEVsZW1lbnQobmV3RWxlbWVudClcbiAgICAgICAgICAgID8gUmVhY3QuY2xvbmVFbGVtZW50KG5ld0VsZW1lbnQsIHVuZGVmaW5lZCwgbmV3Q2hpbGRyZW4pXG4gICAgICAgICAgICA6IG51bGx9XG4gICAgICAgIDwvU2xvdENsb25lPlxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgPFNsb3RDbG9uZSB7Li4uc2xvdFByb3BzfSByZWY9e2ZvcndhcmRlZFJlZn0+XG4gICAgICAgIHtjaGlsZHJlbn1cbiAgICAgIDwvU2xvdENsb25lPlxuICAgICk7XG4gIH0pO1xuXG4gIFNsb3QuZGlzcGxheU5hbWUgPSBgJHtvd25lck5hbWV9LlNsb3RgO1xuICByZXR1cm4gU2xvdDtcbn1cblxuY29uc3QgU2xvdCA9IGNyZWF0ZVNsb3QoJ1Nsb3QnKTtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogU2xvdENsb25lXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbmludGVyZmFjZSBTbG90Q2xvbmVQcm9wcyB7XG4gIGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGU7XG59XG5cbi8qIEBfX05PX1NJREVfRUZGRUNUU19fICovIGZ1bmN0aW9uIGNyZWF0ZVNsb3RDbG9uZShvd25lck5hbWU6IHN0cmluZykge1xuICBjb25zdCBTbG90Q2xvbmUgPSBSZWFjdC5mb3J3YXJkUmVmPGFueSwgU2xvdENsb25lUHJvcHM+KChwcm9wcywgZm9yd2FyZGVkUmVmKSA9PiB7XG4gICAgY29uc3QgeyBjaGlsZHJlbiwgLi4uc2xvdFByb3BzIH0gPSBwcm9wcztcblxuICAgIGlmIChSZWFjdC5pc1ZhbGlkRWxlbWVudChjaGlsZHJlbikpIHtcbiAgICAgIGNvbnN0IGNoaWxkcmVuUmVmID0gZ2V0RWxlbWVudFJlZihjaGlsZHJlbik7XG4gICAgICBjb25zdCBwcm9wcyA9IG1lcmdlUHJvcHMoc2xvdFByb3BzLCBjaGlsZHJlbi5wcm9wcyBhcyBBbnlQcm9wcyk7XG4gICAgICAvLyBkbyBub3QgcGFzcyByZWYgdG8gUmVhY3QuRnJhZ21lbnQgZm9yIFJlYWN0IDE5IGNvbXBhdGliaWxpdHlcbiAgICAgIGlmIChjaGlsZHJlbi50eXBlICE9PSBSZWFjdC5GcmFnbWVudCkge1xuICAgICAgICBwcm9wcy5yZWYgPSBmb3J3YXJkZWRSZWYgPyBjb21wb3NlUmVmcyhmb3J3YXJkZWRSZWYsIGNoaWxkcmVuUmVmKSA6IGNoaWxkcmVuUmVmO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFJlYWN0LmNsb25lRWxlbWVudChjaGlsZHJlbiwgcHJvcHMpO1xuICAgIH1cblxuICAgIHJldHVybiBSZWFjdC5DaGlsZHJlbi5jb3VudChjaGlsZHJlbikgPiAxID8gUmVhY3QuQ2hpbGRyZW4ub25seShudWxsKSA6IG51bGw7XG4gIH0pO1xuXG4gIFNsb3RDbG9uZS5kaXNwbGF5TmFtZSA9IGAke293bmVyTmFtZX0uU2xvdENsb25lYDtcbiAgcmV0dXJuIFNsb3RDbG9uZTtcbn1cblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogU2xvdHRhYmxlXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbmNvbnN0IFNMT1RUQUJMRV9JREVOVElGSUVSID0gU3ltYm9sKCdyYWRpeC5zbG90dGFibGUnKTtcblxuaW50ZXJmYWNlIFNsb3R0YWJsZVByb3BzIHtcbiAgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZTtcbn1cblxuaW50ZXJmYWNlIFNsb3R0YWJsZUNvbXBvbmVudCBleHRlbmRzIFJlYWN0LkZDPFNsb3R0YWJsZVByb3BzPiB7XG4gIF9fcmFkaXhJZDogc3ltYm9sO1xufVxuXG4vKiBAX19OT19TSURFX0VGRkVDVFNfXyAqLyBleHBvcnQgZnVuY3Rpb24gY3JlYXRlU2xvdHRhYmxlKG93bmVyTmFtZTogc3RyaW5nKSB7XG4gIGNvbnN0IFNsb3R0YWJsZTogU2xvdHRhYmxlQ29tcG9uZW50ID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICAgIHJldHVybiA8PntjaGlsZHJlbn08Lz47XG4gIH07XG4gIFNsb3R0YWJsZS5kaXNwbGF5TmFtZSA9IGAke293bmVyTmFtZX0uU2xvdHRhYmxlYDtcbiAgU2xvdHRhYmxlLl9fcmFkaXhJZCA9IFNMT1RUQUJMRV9JREVOVElGSUVSO1xuICByZXR1cm4gU2xvdHRhYmxlO1xufVxuXG5jb25zdCBTbG90dGFibGUgPSBjcmVhdGVTbG90dGFibGUoJ1Nsb3R0YWJsZScpO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbnR5cGUgQW55UHJvcHMgPSBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuXG5mdW5jdGlvbiBpc1Nsb3R0YWJsZShcbiAgY2hpbGQ6IFJlYWN0LlJlYWN0Tm9kZVxuKTogY2hpbGQgaXMgUmVhY3QuUmVhY3RFbGVtZW50PFNsb3R0YWJsZVByb3BzLCB0eXBlb2YgU2xvdHRhYmxlPiB7XG4gIHJldHVybiAoXG4gICAgUmVhY3QuaXNWYWxpZEVsZW1lbnQoY2hpbGQpICYmXG4gICAgdHlwZW9mIGNoaWxkLnR5cGUgPT09ICdmdW5jdGlvbicgJiZcbiAgICAnX19yYWRpeElkJyBpbiBjaGlsZC50eXBlICYmXG4gICAgY2hpbGQudHlwZS5fX3JhZGl4SWQgPT09IFNMT1RUQUJMRV9JREVOVElGSUVSXG4gICk7XG59XG5cbmZ1bmN0aW9uIG1lcmdlUHJvcHMoc2xvdFByb3BzOiBBbnlQcm9wcywgY2hpbGRQcm9wczogQW55UHJvcHMpIHtcbiAgLy8gYWxsIGNoaWxkIHByb3BzIHNob3VsZCBvdmVycmlkZVxuICBjb25zdCBvdmVycmlkZVByb3BzID0geyAuLi5jaGlsZFByb3BzIH07XG5cbiAgZm9yIChjb25zdCBwcm9wTmFtZSBpbiBjaGlsZFByb3BzKSB7XG4gICAgY29uc3Qgc2xvdFByb3BWYWx1ZSA9IHNsb3RQcm9wc1twcm9wTmFtZV07XG4gICAgY29uc3QgY2hpbGRQcm9wVmFsdWUgPSBjaGlsZFByb3BzW3Byb3BOYW1lXTtcblxuICAgIGNvbnN0IGlzSGFuZGxlciA9IC9eb25bQS1aXS8udGVzdChwcm9wTmFtZSk7XG4gICAgaWYgKGlzSGFuZGxlcikge1xuICAgICAgLy8gaWYgdGhlIGhhbmRsZXIgZXhpc3RzIG9uIGJvdGgsIHdlIGNvbXBvc2UgdGhlbVxuICAgICAgaWYgKHNsb3RQcm9wVmFsdWUgJiYgY2hpbGRQcm9wVmFsdWUpIHtcbiAgICAgICAgb3ZlcnJpZGVQcm9wc1twcm9wTmFtZV0gPSAoLi4uYXJnczogdW5rbm93bltdKSA9PiB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gY2hpbGRQcm9wVmFsdWUoLi4uYXJncyk7XG4gICAgICAgICAgc2xvdFByb3BWYWx1ZSguLi5hcmdzKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgLy8gYnV0IGlmIGl0IGV4aXN0cyBvbmx5IG9uIHRoZSBzbG90LCB3ZSB1c2Ugb25seSB0aGlzIG9uZVxuICAgICAgZWxzZSBpZiAoc2xvdFByb3BWYWx1ZSkge1xuICAgICAgICBvdmVycmlkZVByb3BzW3Byb3BOYW1lXSA9IHNsb3RQcm9wVmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGlmIGl0J3MgYHN0eWxlYCwgd2UgbWVyZ2UgdGhlbVxuICAgIGVsc2UgaWYgKHByb3BOYW1lID09PSAnc3R5bGUnKSB7XG4gICAgICBvdmVycmlkZVByb3BzW3Byb3BOYW1lXSA9IHsgLi4uc2xvdFByb3BWYWx1ZSwgLi4uY2hpbGRQcm9wVmFsdWUgfTtcbiAgICB9IGVsc2UgaWYgKHByb3BOYW1lID09PSAnY2xhc3NOYW1lJykge1xuICAgICAgb3ZlcnJpZGVQcm9wc1twcm9wTmFtZV0gPSBbc2xvdFByb3BWYWx1ZSwgY2hpbGRQcm9wVmFsdWVdLmZpbHRlcihCb29sZWFuKS5qb2luKCcgJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHsgLi4uc2xvdFByb3BzLCAuLi5vdmVycmlkZVByb3BzIH07XG59XG5cbi8vIEJlZm9yZSBSZWFjdCAxOSBhY2Nlc3NpbmcgYGVsZW1lbnQucHJvcHMucmVmYCB3aWxsIHRocm93IGEgd2FybmluZyBhbmQgc3VnZ2VzdCB1c2luZyBgZWxlbWVudC5yZWZgXG4vLyBBZnRlciBSZWFjdCAxOSBhY2Nlc3NpbmcgYGVsZW1lbnQucmVmYCBkb2VzIHRoZSBvcHBvc2l0ZS5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzI4MzQ4XG4vL1xuLy8gQWNjZXNzIHRoZSByZWYgdXNpbmcgdGhlIG1ldGhvZCB0aGF0IGRvZXNuJ3QgeWllbGQgYSB3YXJuaW5nLlxuZnVuY3Rpb24gZ2V0RWxlbWVudFJlZihlbGVtZW50OiBSZWFjdC5SZWFjdEVsZW1lbnQpIHtcbiAgLy8gUmVhY3QgPD0xOCBpbiBERVZcbiAgbGV0IGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZWxlbWVudC5wcm9wcywgJ3JlZicpPy5nZXQ7XG4gIGxldCBtYXlXYXJuID0gZ2V0dGVyICYmICdpc1JlYWN0V2FybmluZycgaW4gZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZztcbiAgaWYgKG1heVdhcm4pIHtcbiAgICByZXR1cm4gKGVsZW1lbnQgYXMgYW55KS5yZWY7XG4gIH1cblxuICAvLyBSZWFjdCAxOSBpbiBERVZcbiAgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlbGVtZW50LCAncmVmJyk/LmdldDtcbiAgbWF5V2FybiA9IGdldHRlciAmJiAnaXNSZWFjdFdhcm5pbmcnIGluIGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmc7XG4gIGlmIChtYXlXYXJuKSB7XG4gICAgcmV0dXJuIChlbGVtZW50LnByb3BzIGFzIHsgcmVmPzogUmVhY3QuUmVmPHVua25vd24+IH0pLnJlZjtcbiAgfVxuXG4gIC8vIE5vdCBERVZcbiAgcmV0dXJuIChlbGVtZW50LnByb3BzIGFzIHsgcmVmPzogUmVhY3QuUmVmPHVua25vd24+IH0pLnJlZiB8fCAoZWxlbWVudCBhcyBhbnkpLnJlZjtcbn1cblxuZXhwb3J0IHtcbiAgU2xvdCxcbiAgU2xvdHRhYmxlLFxuICAvL1xuICBTbG90IGFzIFJvb3QsXG59O1xuZXhwb3J0IHR5cGUgeyBTbG90UHJv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QUFFLEdBQUcsU0FBQTtRQUFXLEdBQUcsYUFBQTtJQUFjO0FBQzFDO0FBT0EsU0FBUyxjQUFjLE9BQUEsRUFBNkI7SUFFbEQsSUFBSSxTQUFTLE9BQU8sd0JBQUEsQ0FBeUIsUUFBUSxLQUFBLEVBQU8sS0FBSyxHQUFHO0lBQ3BFLElBQUksVUFBVSxVQUFVLG9CQUFvQixVQUFVLE9BQU8sY0FBQTtJQUM3RCxJQUFJLFNBQVM7UUFDWCxPQUFRLFFBQWdCLEdBQUE7SUFDMUI7SUFHQSxTQUFTLE9BQU8sd0JBQUEsQ0FBeUIsU0FBUyxLQUFLLEdBQUc7SUFDMUQsVUFBVSxVQUFVLG9CQUFvQixVQUFVLE9BQU8sY0FBQTtJQUN6RCxJQUFJLFNBQVM7UUFDWCxPQUFRLFFBQVEsS0FBQSxDQUF1QyxHQUFBO0lBQ3pEO0lBR0EsT0FBUSxRQUFRLEtBQUEsQ0FBdUMsR0FBQSxJQUFRLFFBQWdCLEdBQUE7QUFDakYiLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDEzNTcyLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL2Nsc3gvZGlzdC9jbHN4Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiByKGUpe3ZhciB0LGYsbj1cIlwiO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlfHxcIm51bWJlclwiPT10eXBlb2YgZSluKz1lO2Vsc2UgaWYoXCJvYmplY3RcIj09dHlwZW9mIGUpaWYoQXJyYXkuaXNBcnJheShlKSl7dmFyIG89ZS5sZW5ndGg7Zm9yKHQ9MDt0PG87dCsrKWVbdF0mJihmPXIoZVt0XSkpJiYobiYmKG4rPVwiIFwiKSxuKz1mKX1lbHNlIGZvcihmIGluIGUpZVtmXSYmKG4mJihuKz1cIiBcIiksbis9Zik7cmV0dXJuIG59ZXhwb3J0IGZ1bmN0aW9uIGNsc3goKXtmb3IodmFyIGUsdCxmPTAsbj1cIlwiLG89YXJndW1lbnRzLmxlbmd0aDtmPG87ZisrKShlPWFyZ3VtZW50c1tmXSkmJih0PXIoZSkpJiYobiYmKG4rPVwiIFwiKSxuKz10KTtyZXR1cm4gbn1leHBvcnQgZGVmYXVsdCBjbHN4OyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsU0FBUyxFQUFFLENBQUM7SUFBRSxJQUFJLEdBQUUsR0FBRSxJQUFFO0lBQUcsSUFBRyxZQUFVLE9BQU8sS0FBRyxZQUFVLE9BQU8sR0FBRSxLQUFHO1NBQU8sSUFBRyxZQUFVLE9BQU8sR0FBRSxJQUFHLE1BQU0sT0FBTyxDQUFDLElBQUc7UUFBQyxJQUFJLElBQUUsRUFBRSxNQUFNO1FBQUMsSUFBSSxJQUFFLEdBQUUsSUFBRSxHQUFFLElBQUksQ0FBQyxDQUFDLEVBQUUsSUFBRSxDQUFDLElBQUUsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUcsQ0FBQyxLQUFHLENBQUMsS0FBRyxHQUFHLEdBQUUsS0FBRyxDQUFDO0lBQUMsT0FBTSxJQUFJLEtBQUssRUFBRSxDQUFDLENBQUMsRUFBRSxJQUFFLENBQUMsS0FBRyxDQUFDLEtBQUcsR0FBRyxHQUFFLEtBQUcsQ0FBQztJQUFFLE9BQU87QUFBQztBQUFRLFNBQVM7SUFBTyxJQUFJLElBQUksR0FBRSxHQUFFLElBQUUsR0FBRSxJQUFFLElBQUcsSUFBRSxVQUFVLE1BQU0sRUFBQyxJQUFFLEdBQUUsSUFBSSxDQUFDLElBQUUsU0FBUyxDQUFDLEVBQUUsS0FBRyxDQUFDLElBQUUsRUFBRSxFQUFFLEtBQUcsQ0FBQyxLQUFHLENBQUMsS0FBRyxHQUFHLEdBQUUsS0FBRyxDQUFDO0lBQUUsT0FBTztBQUFDO3VDQUFnQiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxMzU5NCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9jbGFzcy12YXJpYW5jZS1hdXRob3JpdHkvZGlzdC9pbmRleC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgMjAyMiBKb2UgQmVsbC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjBcbiAqICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlXG4gKiBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVFxuICogV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGVcbiAqIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyXG4gKiB0aGUgTGljZW5zZS5cbiAqLyBpbXBvcnQgeyBjbHN4IH0gZnJvbSBcImNsc3hcIjtcbmNvbnN0IGZhbHN5VG9TdHJpbmcgPSAodmFsdWUpPT50eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiID8gYCR7dmFsdWV9YCA6IHZhbHVlID09PSAwID8gXCIwXCIgOiB2YWx1ZTtcbmV4cG9ydCBjb25zdCBjeCA9IGNsc3g7XG5leHBvcnQgY29uc3QgY3ZhID0gKGJhc2UsIGNvbmZpZyk9Pihwcm9wcyk9PntcbiAgICAgICAgdmFyIF9jb25maWdfY29tcG91bmRWYXJpYW50cztcbiAgICAgICAgaWYgKChjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcudmFyaWFudHMpID09IG51bGwpIHJldHVybiBjeChiYXNlLCBwcm9wcyA9PT0gbnVsbCB8fCBwcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvcHMuY2xhc3MsIHByb3BzID09PSBudWxsIHx8IHByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm9wcy5jbGFzc05hbWUpO1xuICAgICAgICBjb25zdCB7IHZhcmlhbnRzLCBkZWZhdWx0VmFyaWFudHMgfSA9IGNvbmZpZztcbiAgICAgICAgY29uc3QgZ2V0VmFyaWFudENsYXNzTmFtZXMgPSBPYmplY3Qua2V5cyh2YXJpYW50cykubWFwKCh2YXJpYW50KT0+e1xuICAgICAgICAgICAgY29uc3QgdmFyaWFudFByb3AgPSBwcm9wcyA9PT0gbnVsbCB8fCBwcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvcHNbdmFyaWFudF07XG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0VmFyaWFudFByb3AgPSBkZWZhdWx0VmFyaWFudHMgPT09IG51bGwgfHwgZGVmYXVsdFZhcmlhbnRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkZWZhdWx0VmFyaWFudHNbdmFyaWFudF07XG4gICAgICAgICAgICBpZiAodmFyaWFudFByb3AgPT09IG51bGwpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgY29uc3QgdmFyaWFudEtleSA9IGZhbHN5VG9TdHJpbmcodmFyaWFudFByb3ApIHx8IGZhbHN5VG9TdHJpbmcoZGVmYXVsdFZhcmlhbnRQcm9wKTtcbiAgICAgICAgICAgIHJldHVybiB2YXJpYW50c1t2YXJpYW50XVt2YXJpYW50S2V5XTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHByb3BzV2l0aG91dFVuZGVmaW5lZCA9IHByb3BzICYmIE9iamVjdC5lbnRyaWVzKHByb3BzKS5yZWR1Y2UoKGFjYywgcGFyYW0pPT57XG4gICAgICAgICAgICBsZXQgW2tleSwgdmFsdWVdID0gcGFyYW07XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhY2Nba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge30pO1xuICAgICAgICBjb25zdCBnZXRDb21wb3VuZFZhcmlhbnRDbGFzc05hbWVzID0gY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9jb25maWdfY29tcG91bmRWYXJpYW50cyA9IGNvbmZpZy5jb21wb3VuZFZhcmlhbnRzKSA9PT0gbnVsbCB8fCBfY29uZmlnX2NvbXBvdW5kVmFyaWFudHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jb25maWdfY29tcG91bmRWYXJpYW50cy5yZWR1Y2UoKGFjYywgcGFyYW0pPT57XG4gICAgICAgICAgICBsZXQgeyBjbGFzczogY3ZDbGFzcywgY2xhc3NOYW1lOiBjdkNsYXNzTmFtZSwgLi4uY29tcG91bmRWYXJpYW50T3B0aW9ucyB9ID0gcGFyYW07XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMoY29tcG91bmRWYXJpYW50T3B0aW9ucykuZXZlcnkoKHBhcmFtKT0+e1xuICAgICAgICAgICAgICAgIGxldCBba2V5LCB2YWx1ZV0gPSBwYXJhbTtcbiAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5pbmNsdWRlcyh7XG4gICAgICAgICAgICAgICAgICAgIC4uLmRlZmF1bHRWYXJpYW50cyxcbiAgICAgICAgICAgICAgICAgICAgLi4ucHJvcHNXaXRob3V0VW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgfVtrZXldKSA6ICh7XG4gICAgICAgICAgICAgICAgICAgIC4uLmRlZmF1bHRWYXJpYW50cyxcbiAgICAgICAgICAgICAgICAgICAgLi4ucHJvcHNXaXRob3V0VW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgfSlba2V5XSA9PT0gdmFsdWU7XG4gICAgICAgICAgICB9KSA/IFtcbiAgICAgICAgICAgICAgICAuLi5hY2MsXG4gICAgICAgICAgICAgICAgY3ZDbGFzcyxcbiAgICAgICAgICAgICAgICBjdkNsYXNzTmFtZVxuICAgICAgICAgICAgXSA6IGFjYztcbiAgICAgICAgfSwgW10pO1xuICAgICAgICByZXR1cm4gY3goYmFzZSwgZ2V0VmFyaWFudENsYXNzTmFtZXMsIGdldENvbXBvdW5kVmFyaWFudENsYXNzTmFtZXMsIHByb3BzID09PSBudWxsIHx8IHByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm9wcy5jbGFzcywgcHJvcHMgPT09IG51bGwgfHwgcHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb3BzLmNsYXNzTmFtZSk7XG4gICAgfTtcblxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7OztDQWNDOzs7O0FBQUc7O0FBQ0osTUFBTSxnQkFBZ0IsQ0FBQyxRQUFRLE9BQU8sVUFBVSxZQUFZLEdBQUcsT0FBTyxHQUFHLFVBQVUsSUFBSSxNQUFNO0FBQ3RGLE1BQU0sS0FBSyxxSUFBQSxDQUFBLE9BQUk7QUFDZixNQUFNLE1BQU0sQ0FBQyxNQUFNLFNBQVMsQ0FBQztRQUM1QixJQUFJO1FBQ0osSUFBSSxDQUFDLFdBQVcsUUFBUSxXQUFXLEtBQUssSUFBSSxLQUFLLElBQUksT0FBTyxRQUFRLEtBQUssTUFBTSxPQUFPLEdBQUcsTUFBTSxVQUFVLFFBQVEsVUFBVSxLQUFLLElBQUksS0FBSyxJQUFJLE1BQU0sS0FBSyxFQUFFLFVBQVUsUUFBUSxVQUFVLEtBQUssSUFBSSxLQUFLLElBQUksTUFBTSxTQUFTO1FBQ3ZOLE1BQU0sRUFBRSxRQUFRLEVBQUUsZUFBZSxFQUFFLEdBQUc7UUFDdEMsTUFBTSx1QkFBdUIsT0FBTyxJQUFJLENBQUMsVUFBVSxHQUFHLENBQUMsQ0FBQztZQUNwRCxNQUFNLGNBQWMsVUFBVSxRQUFRLFVBQVUsS0FBSyxJQUFJLEtBQUssSUFBSSxLQUFLLENBQUMsUUFBUTtZQUNoRixNQUFNLHFCQUFxQixvQkFBb0IsUUFBUSxvQkFBb0IsS0FBSyxJQUFJLEtBQUssSUFBSSxlQUFlLENBQUMsUUFBUTtZQUNySCxJQUFJLGdCQUFnQixNQUFNLE9BQU87WUFDakMsTUFBTSxhQUFhLGNBQWMsZ0JBQWdCLGNBQWM7WUFDL0QsT0FBTyxRQUFRLENBQUMsUUFBUSxDQUFDLFdBQVc7UUFDeEM7UUFDQSxNQUFNLHdCQUF3QixTQUFTLE9BQU8sT0FBTyxDQUFDLE9BQU8sTUFBTSxDQUFDLENBQUMsS0FBSztZQUN0RSxJQUFJLENBQUMsS0FBSyxNQUFNLEdBQUc7WUFDbkIsSUFBSSxVQUFVLFdBQVc7Z0JBQ3JCLE9BQU87WUFDWDtZQUNBLEdBQUcsQ0FBQyxJQUFJLEdBQUc7WUFDWCxPQUFPO1FBQ1gsR0FBRyxDQUFDO1FBQ0osTUFBTSwrQkFBK0IsV0FBVyxRQUFRLFdBQVcsS0FBSyxJQUFJLEtBQUssSUFBSSxDQUFDLDJCQUEyQixPQUFPLGdCQUFnQixNQUFNLFFBQVEsNkJBQTZCLEtBQUssSUFBSSxLQUFLLElBQUkseUJBQXlCLE1BQU0sQ0FBQyxDQUFDLEtBQUs7WUFDdk8sSUFBSSxFQUFFLE9BQU8sT0FBTyxFQUFFLFdBQVcsV0FBVyxFQUFFLEdBQUcsd0JBQXdCLEdBQUc7WUFDNUUsT0FBTyxPQUFPLE9BQU8sQ0FBQyx3QkFBd0IsS0FBSyxDQUFDLENBQUM7Z0JBQ2pELElBQUksQ0FBQyxLQUFLLE1BQU0sR0FBRztnQkFDbkIsT0FBTyxNQUFNLE9BQU8sQ0FBQyxTQUFTLE1BQU0sUUFBUSxDQUFDO29CQUN6QyxHQUFHLGVBQWU7b0JBQ2xCLEdBQUcscUJBQXFCO2dCQUM1QixDQUFDLENBQUMsSUFBSSxJQUFJLENBQUM7b0JBQ1AsR0FBRyxlQUFlO29CQUNsQixHQUFHLHFCQUFxQjtnQkFDNUIsQ0FBQyxDQUFDLENBQUMsSUFBSSxLQUFLO1lBQ2hCLEtBQUs7bUJBQ0U7Z0JBQ0g7Z0JBQ0E7YUFDSCxHQUFHO1FBQ1IsR0FBRyxFQUFFO1FBQ0wsT0FBTyxHQUFHLE1BQU0sc0JBQXNCLDhCQUE4QixVQUFVLFFBQVEsVUFBVSxLQUFLLElBQUksS0FBSyxJQUFJLE1BQU0sS0FBSyxFQUFFLFVBQVUsUUFBUSxVQUFVLEtBQUssSUFBSSxLQUFLLElBQUksTUFBTSxTQUFTO0lBQ2hNIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDEzNjU4LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsImZpbGUiOiJ0dXJib3BhY2s6Ly8vW3Byb2plY3RdL25vZGVfbW9kdWxlcy90YWlsd2luZC1tZXJnZS9kaXN0L2J1bmRsZS1tanMubWpzIiwic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvdGFpbHdpbmQtbWVyZ2Uvc3JjL2xpYi9jbGFzcy1ncm91cC11dGlscy50cyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy90YWlsd2luZC1tZXJnZS9zcmMvbGliL2xydS1jYWNoZS50cyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy90YWlsd2luZC1tZXJnZS9zcmMvbGliL3BhcnNlLWNsYXNzLW5hbWUudHMiLCJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvdGFpbHdpbmQtbWVyZ2Uvc3JjL2xpYi9zb3J0LW1vZGlmaWVycy50cyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy90YWlsd2luZC1tZXJnZS9zcmMvbGliL2NvbmZpZy11dGlscy50cyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy90YWlsd2luZC1tZXJnZS9zcmMvbGliL21lcmdlLWNsYXNzbGlzdC50cyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy90YWlsd2luZC1tZXJnZS9zcmMvbGliL3R3LWpvaW4udHMiLCJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvdGFpbHdpbmQtbWVyZ2Uvc3JjL2xpYi9jcmVhdGUtdGFpbHdpbmQtbWVyZ2UudHMiLCJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvdGFpbHdpbmQtbWVyZ2Uvc3JjL2xpYi9mcm9tLXRoZW1lLnRzIiwiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL3RhaWx3aW5kLW1lcmdlL3NyYy9saWIvdmFsaWRhdG9ycy50cyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy90YWlsd2luZC1tZXJnZS9zcmMvbGliL2RlZmF1bHQtY29uZmlnLnRzIiwiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL3RhaWx3aW5kLW1lcmdlL3NyYy9saWIvbWVyZ2UtY29uZmlncy50cyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy90YWlsd2luZC1tZXJnZS9zcmMvbGliL2V4dGVuZC10YWlsd2luZC1tZXJnZS50cyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy90YWlsd2luZC1tZXJnZS9zcmMvbGliL3R3LW1lcmdlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgQW55Q2xhc3NHcm91cElkcyxcbiAgICBBbnlDb25maWcsXG4gICAgQW55VGhlbWVHcm91cElkcyxcbiAgICBDbGFzc0dyb3VwLFxuICAgIENsYXNzVmFsaWRhdG9yLFxuICAgIENvbmZpZyxcbiAgICBUaGVtZUdldHRlcixcbiAgICBUaGVtZU9iamVjdCxcbn0gZnJvbSAnLi90eXBlcydcblxuZXhwb3J0IGludGVyZmFjZSBDbGFzc1BhcnRPYmplY3Qge1xuICAgIG5leHRQYXJ0OiBNYXA8c3RyaW5nLCBDbGFzc1BhcnRPYmplY3Q+XG4gICAgdmFsaWRhdG9yczogQ2xhc3NWYWxpZGF0b3JPYmplY3RbXVxuICAgIGNsYXNzR3JvdXBJZD86IEFueUNsYXNzR3JvdXBJZHNcbn1cblxuaW50ZXJmYWNlIENsYXNzVmFsaWRhdG9yT2JqZWN0IHtcbiAgICBjbGFzc0dyb3VwSWQ6IEFueUNsYXNzR3JvdXBJZHNcbiAgICB2YWxpZGF0b3I6IENsYXNzVmFsaWRhdG9yXG59XG5cbmNvbnN0IENMQVNTX1BBUlRfU0VQQVJBVE9SID0gJy0nXG5cbmV4cG9ydCBjb25zdCBjcmVhdGVDbGFzc0dyb3VwVXRpbHMgPSAoY29uZmlnOiBBbnlDb25maWcpID0+IHtcbiAgICBjb25zdCBjbGFzc01hcCA9IGNyZWF0ZUNsYXNzTWFwKGNvbmZpZylcbiAgICBjb25zdCB7IGNvbmZsaWN0aW5nQ2xhc3NHcm91cHMsIGNvbmZsaWN0aW5nQ2xhc3NHcm91cE1vZGlmaWVycyB9ID0gY29uZmlnXG5cbiAgICBjb25zdCBnZXRDbGFzc0dyb3VwSWQgPSAoY2xhc3NOYW1lOiBzdHJpbmcpID0+IHtcbiAgICAgICAgY29uc3QgY2xhc3NQYXJ0cyA9IGNsYXNzTmFtZS5zcGxpdChDTEFTU19QQVJUX1NFUEFSQVRPUilcblxuICAgICAgICAvLyBDbGFzc2VzIGxpa2UgYC1pbnNldC0xYCBwcm9kdWNlIGFuIGVtcHR5IHN0cmluZyBhcyBmaXJzdCBjbGFzc1BhcnQuIFdlIGFzc3VtZSB0aGF0IGNsYXNzZXMgZm9yIG5lZ2F0aXZlIHZhbHVlcyBhcmUgdXNlZCBjb3JyZWN0bHkgYW5kIHJlbW92ZSBpdCBmcm9tIGNsYXNzUGFydHMuXG4gICAgICAgIGlmIChjbGFzc1BhcnRzWzBdID09PSAnJyAmJiBjbGFzc1BhcnRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgY2xhc3NQYXJ0cy5zaGlmdCgpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2V0R3JvdXBSZWN1cnNpdmUoY2xhc3NQYXJ0cywgY2xhc3NNYXApIHx8IGdldEdyb3VwSWRGb3JBcmJpdHJhcnlQcm9wZXJ0eShjbGFzc05hbWUpXG4gICAgfVxuXG4gICAgY29uc3QgZ2V0Q29uZmxpY3RpbmdDbGFzc0dyb3VwSWRzID0gKFxuICAgICAgICBjbGFzc0dyb3VwSWQ6IEFueUNsYXNzR3JvdXBJZHMsXG4gICAgICAgIGhhc1Bvc3RmaXhNb2RpZmllcjogYm9vbGVhbixcbiAgICApID0+IHtcbiAgICAgICAgY29uc3QgY29uZmxpY3RzID0gY29uZmxpY3RpbmdDbGFzc0dyb3Vwc1tjbGFzc0dyb3VwSWRdIHx8IFtdXG5cbiAgICAgICAgaWYgKGhhc1Bvc3RmaXhNb2RpZmllciAmJiBjb25mbGljdGluZ0NsYXNzR3JvdXBNb2RpZmllcnNbY2xhc3NHcm91cElkXSkge1xuICAgICAgICAgICAgcmV0dXJuIFsuLi5jb25mbGljdHMsIC4uLmNvbmZsaWN0aW5nQ2xhc3NHcm91cE1vZGlmaWVyc1tjbGFzc0dyb3VwSWRdIV1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb25mbGljdHNcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBnZXRDbGFzc0dyb3VwSWQsXG4gICAgICAgIGdldENvbmZsaWN0aW5nQ2xhc3NHcm91cElkcyxcbiAgICB9XG59XG5cbmNvbnN0IGdldEdyb3VwUmVjdXJzaXZlID0gKFxuICAgIGNsYXNzUGFydHM6IHN0cmluZ1tdLFxuICAgIGNsYXNzUGFydE9iamVjdDogQ2xhc3NQYXJ0T2JqZWN0LFxuKTogQW55Q2xhc3NHcm91cElkcyB8IHVuZGVmaW5lZCA9PiB7XG4gICAgaWYgKGNsYXNzUGFydHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBjbGFzc1BhcnRPYmplY3QuY2xhc3NHcm91cElkXG4gICAgfVxuXG4gICAgY29uc3QgY3VycmVudENsYXNzUGFydCA9IGNsYXNzUGFydHNbMF0hXG4gICAgY29uc3QgbmV4dENsYXNzUGFydE9iamVjdCA9IGNsYXNzUGFydE9iamVjdC5uZXh0UGFydC5nZXQoY3VycmVudENsYXNzUGFydClcbiAgICBjb25zdCBjbGFzc0dyb3VwRnJvbU5leHRDbGFzc1BhcnQgPSBuZXh0Q2xhc3NQYXJ0T2JqZWN0XG4gICAgICAgID8gZ2V0R3JvdXBSZWN1cnNpdmUoY2xhc3NQYXJ0cy5zbGljZSgxKSwgbmV4dENsYXNzUGFydE9iamVjdClcbiAgICAgICAgOiB1bmRlZmluZWRcblxuICAgIGlmIChjbGFzc0dyb3VwRnJvbU5leHRDbGFzc1BhcnQpIHtcbiAgICAgICAgcmV0dXJuIGNsYXNzR3JvdXBGcm9tTmV4dENsYXNzUGFydFxuICAgIH1cblxuICAgIGlmIChjbGFzc1BhcnRPYmplY3QudmFsaWRhdG9ycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH1cblxuICAgIGNvbnN0IGNsYXNzUmVzdCA9IGNsYXNzUGFydHMuam9pbihDTEFTU19QQVJUX1NFUEFSQVRPUilcblxuICAgIHJldHVybiBjbGFzc1BhcnRPYmplY3QudmFsaWRhdG9ycy5maW5kKCh7IHZhbGlkYXRvciB9KSA9PiB2YWxpZGF0b3IoY2xhc3NSZXN0KSk/LmNsYXNzR3JvdXBJZFxufVxuXG5jb25zdCBhcmJpdHJhcnlQcm9wZXJ0eVJlZ2V4ID0gL15cXFsoLispXFxdJC9cblxuY29uc3QgZ2V0R3JvdXBJZEZvckFyYml0cmFyeVByb3BlcnR5ID0gKGNsYXNzTmFtZTogc3RyaW5nKSA9PiB7XG4gICAgaWYgKGFyYml0cmFyeVByb3BlcnR5UmVnZXgudGVzdChjbGFzc05hbWUpKSB7XG4gICAgICAgIGNvbnN0IGFyYml0cmFyeVByb3BlcnR5Q2xhc3NOYW1lID0gYXJiaXRyYXJ5UHJvcGVydHlSZWdleC5leGVjKGNsYXNzTmFtZSkhWzFdXG4gICAgICAgIGNvbnN0IHByb3BlcnR5ID0gYXJiaXRyYXJ5UHJvcGVydHlDbGFzc05hbWU/LnN1YnN0cmluZyhcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICBhcmJpdHJhcnlQcm9wZXJ0eUNsYXNzTmFtZS5pbmRleE9mKCc6JyksXG4gICAgICAgIClcblxuICAgICAgICBpZiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgIC8vIEkgdXNlIHR3byBkb3RzIGhlcmUgYmVjYXVzZSBvbmUgZG90IGlzIHVzZWQgYXMgcHJlZml4IGZvciBjbGFzcyBncm91cHMgaW4gcGx1Z2luc1xuICAgICAgICAgICAgcmV0dXJuICdhcmJpdHJhcnkuLicgKyBwcm9wZXJ0eVxuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEV4cG9ydGVkIGZvciB0ZXN0aW5nIG9ubHlcbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUNsYXNzTWFwID0gKGNvbmZpZzogQ29uZmlnPEFueUNsYXNzR3JvdXBJZHMsIEFueVRoZW1lR3JvdXBJZHM+KSA9PiB7XG4gICAgY29uc3QgeyB0aGVtZSwgY2xhc3NHcm91cHMgfSA9IGNvbmZpZ1xuICAgIGNvbnN0IGNsYXNzTWFwOiBDbGFzc1BhcnRPYmplY3QgPSB7XG4gICAgICAgIG5leHRQYXJ0OiBuZXcgTWFwPHN0cmluZywgQ2xhc3NQYXJ0T2JqZWN0PigpLFxuICAgICAgICB2YWxpZGF0b3JzOiBbXSxcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGNsYXNzR3JvdXBJZCBpbiBjbGFzc0dyb3Vwcykge1xuICAgICAgICBwcm9jZXNzQ2xhc3Nlc1JlY3Vyc2l2ZWx5KGNsYXNzR3JvdXBzW2NsYXNzR3JvdXBJZF0hLCBjbGFzc01hcCwgY2xhc3NHcm91cElkLCB0aGVtZSlcbiAgICB9XG5cbiAgICByZXR1cm4gY2xhc3NNYXBcbn1cblxuY29uc3QgcHJvY2Vzc0NsYXNzZXNSZWN1cnNpdmVseSA9IChcbiAgICBjbGFzc0dyb3VwOiBDbGFzc0dyb3VwPEFueVRoZW1lR3JvdXBJZHM+LFxuICAgIGNsYXNzUGFydE9iamVjdDogQ2xhc3NQYXJ0T2JqZWN0LFxuICAgIGNsYXNzR3JvdXBJZDogQW55Q2xhc3NHcm91cElkcyxcbiAgICB0aGVtZTogVGhlbWVPYmplY3Q8QW55VGhlbWVHcm91cElkcz4sXG4pID0+IHtcbiAgICBjbGFzc0dyb3VwLmZvckVhY2goKGNsYXNzRGVmaW5pdGlvbikgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGNsYXNzRGVmaW5pdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnN0IGNsYXNzUGFydE9iamVjdFRvRWRpdCA9XG4gICAgICAgICAgICAgICAgY2xhc3NEZWZpbml0aW9uID09PSAnJyA/IGNsYXNzUGFydE9iamVjdCA6IGdldFBhcnQoY2xhc3NQYXJ0T2JqZWN0LCBjbGFzc0RlZmluaXRpb24pXG4gICAgICAgICAgICBjbGFzc1BhcnRPYmplY3RUb0VkaXQuY2xhc3NHcm91cElkID0gY2xhc3NHcm91cElkXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY2xhc3NEZWZpbml0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAoaXNUaGVtZUdldHRlcihjbGFzc0RlZmluaXRpb24pKSB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc0NsYXNzZXNSZWN1cnNpdmVseShcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NEZWZpbml0aW9uKHRoZW1lKSxcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NQYXJ0T2JqZWN0LFxuICAgICAgICAgICAgICAgICAgICBjbGFzc0dyb3VwSWQsXG4gICAgICAgICAgICAgICAgICAgIHRoZW1lLFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2xhc3NQYXJ0T2JqZWN0LnZhbGlkYXRvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdmFsaWRhdG9yOiBjbGFzc0RlZmluaXRpb24sXG4gICAgICAgICAgICAgICAgY2xhc3NHcm91cElkLFxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBPYmplY3QuZW50cmllcyhjbGFzc0RlZmluaXRpb24pLmZvckVhY2goKFtrZXksIGNsYXNzR3JvdXBdKSA9PiB7XG4gICAgICAgICAgICBwcm9jZXNzQ2xhc3Nlc1JlY3Vyc2l2ZWx5KFxuICAgICAgICAgICAgICAgIGNsYXNzR3JvdXAsXG4gICAgICAgICAgICAgICAgZ2V0UGFydChjbGFzc1BhcnRPYmplY3QsIGtleSksXG4gICAgICAgICAgICAgICAgY2xhc3NHcm91cElkLFxuICAgICAgICAgICAgICAgIHRoZW1lLFxuICAgICAgICAgICAgKVxuICAgICAgICB9KVxuICAgIH0pXG59XG5cbmNvbnN0IGdldFBhcnQgPSAoY2xhc3NQYXJ0T2JqZWN0OiBDbGFzc1BhcnRPYmplY3QsIHBhdGg6IHN0cmluZykgPT4ge1xuICAgIGxldCBjdXJyZW50Q2xhc3NQYXJ0T2JqZWN0ID0gY2xhc3NQYXJ0T2JqZWN0XG5cbiAgICBwYXRoLnNwbGl0KENMQVNTX1BBUlRfU0VQQVJBVE9SKS5mb3JFYWNoKChwYXRoUGFydCkgPT4ge1xuICAgICAgICBpZiAoIWN1cnJlbnRDbGFzc1BhcnRPYmplY3QubmV4dFBhcnQuaGFzKHBhdGhQYXJ0KSkge1xuICAgICAgICAgICAgY3VycmVudENsYXNzUGFydE9iamVjdC5uZXh0UGFydC5zZXQocGF0aFBhcnQsIHtcbiAgICAgICAgICAgICAgICBuZXh0UGFydDogbmV3IE1hcCgpLFxuICAgICAgICAgICAgICAgIHZhbGlkYXRvcnM6IFtdLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnRDbGFzc1BhcnRPYmplY3QgPSBjdXJyZW50Q2xhc3NQYXJ0T2JqZWN0Lm5leHRQYXJ0LmdldChwYXRoUGFydCkhXG4gICAgfSlcblxuICAgIHJldHVybiBjdXJyZW50Q2xhc3NQYXJ0T2JqZWN0XG59XG5cbmNvbnN0IGlzVGhlbWVHZXR0ZXIgPSAoZnVuYzogQ2xhc3NWYWxpZGF0b3IgfCBUaGVtZUdldHRlcik6IGZ1bmMgaXMgVGhlbWVHZXR0ZXIgPT5cbiAgICAoZnVuYyBhcyBUaGVtZUdldHRlcikuaXNUaGVtZUdldHRlclxuIiwiLy8gRXhwb3J0IGlzIG5lZWRlZCBiZWNhdXNlIFR5cGVTY3JpcHQgY29tcGxhaW5zIGFib3V0IGFuIGVycm9yIG90aGVyd2lzZTpcbi8vIEVycm9yOiDigKYvdGFpbHdpbmQtbWVyZ2Uvc3JjL2NvbmZpZy11dGlscy50cyg4LDE3KTogc2VtYW50aWMgZXJyb3IgVFM0MDU4OiBSZXR1cm4gdHlwZSBvZiBleHBvcnRlZCBmdW5jdGlvbiBoYXMgb3IgaXMgdXNpbmcgbmFtZSAnTHJ1Q2FjaGUnIGZyb20gZXh0ZXJuYWwgbW9kdWxlIFwi4oCmL3RhaWx3aW5kLW1lcmdlL3NyYy9scnUtY2FjaGVcIiBidXQgY2Fubm90IGJlIG5hbWVkLlxuZXhwb3J0IGludGVyZmFjZSBMcnVDYWNoZTxLZXksIFZhbHVlPiB7XG4gICAgZ2V0KGtleTogS2V5KTogVmFsdWUgfCB1bmRlZmluZWRcbiAgICBzZXQoa2V5OiBLZXksIHZhbHVlOiBWYWx1ZSk6IHZvaWRcbn1cblxuLy8gTFJVIGNhY2hlIGluc3BpcmVkIGZyb20gaGFzaGxydSAoaHR0cHM6Ly9naXRodWIuY29tL2RvbWluaWN0YXJyL2hhc2hscnUvYmxvYi92MS4wLjQvaW5kZXguanMpIGJ1dCBvYmplY3QgcmVwbGFjZWQgd2l0aCBNYXAgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZVxuZXhwb3J0IGNvbnN0IGNyZWF0ZUxydUNhY2hlID0gPEtleSwgVmFsdWU+KG1heENhY2hlU2l6ZTogbnVtYmVyKTogTHJ1Q2FjaGU8S2V5LCBWYWx1ZT4gPT4ge1xuICAgIGlmIChtYXhDYWNoZVNpemUgPCAxKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBnZXQ6ICgpID0+IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHNldDogKCkgPT4ge30sXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgY2FjaGVTaXplID0gMFxuICAgIGxldCBjYWNoZSA9IG5ldyBNYXA8S2V5LCBWYWx1ZT4oKVxuICAgIGxldCBwcmV2aW91c0NhY2hlID0gbmV3IE1hcDxLZXksIFZhbHVlPigpXG5cbiAgICBjb25zdCB1cGRhdGUgPSAoa2V5OiBLZXksIHZhbHVlOiBWYWx1ZSkgPT4ge1xuICAgICAgICBjYWNoZS5zZXQoa2V5LCB2YWx1ZSlcbiAgICAgICAgY2FjaGVTaXplKytcblxuICAgICAgICBpZiAoY2FjaGVTaXplID4gbWF4Q2FjaGVTaXplKSB7XG4gICAgICAgICAgICBjYWNoZVNpemUgPSAwXG4gICAgICAgICAgICBwcmV2aW91c0NhY2hlID0gY2FjaGVcbiAgICAgICAgICAgIGNhY2hlID0gbmV3IE1hcCgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBnZXQoa2V5KSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBjYWNoZS5nZXQoa2V5KVxuXG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCh2YWx1ZSA9IHByZXZpb3VzQ2FjaGUuZ2V0KGtleSkpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGUoa2V5LCB2YWx1ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNhY2hlLnNldChrZXksIHZhbHVlKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cGRhdGUoa2V5LCB2YWx1ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBBbnlDb25maWcsIFBhcnNlZENsYXNzTmFtZSB9IGZyb20gJy4vdHlwZXMnXG5cbmV4cG9ydCBjb25zdCBJTVBPUlRBTlRfTU9ESUZJRVIgPSAnISdcbmNvbnN0IE1PRElGSUVSX1NFUEFSQVRPUiA9ICc6J1xuY29uc3QgTU9ESUZJRVJfU0VQQVJBVE9SX0xFTkdUSCA9IE1PRElGSUVSX1NFUEFSQVRPUi5sZW5ndGhcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVBhcnNlQ2xhc3NOYW1lID0gKGNvbmZpZzogQW55Q29uZmlnKSA9PiB7XG4gICAgY29uc3QgeyBwcmVmaXgsIGV4cGVyaW1lbnRhbFBhcnNlQ2xhc3NOYW1lIH0gPSBjb25maWdcblxuICAgIC8qKlxuICAgICAqIFBhcnNlIGNsYXNzIG5hbWUgaW50byBwYXJ0cy5cbiAgICAgKlxuICAgICAqIEluc3BpcmVkIGJ5IGBzcGxpdEF0VG9wTGV2ZWxPbmx5YCB1c2VkIGluIFRhaWx3aW5kIENTU1xuICAgICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3RhaWx3aW5kbGFicy90YWlsd2luZGNzcy9ibG9iL3YzLjIuMi9zcmMvdXRpbC9zcGxpdEF0VG9wTGV2ZWxPbmx5LmpzXG4gICAgICovXG4gICAgbGV0IHBhcnNlQ2xhc3NOYW1lID0gKGNsYXNzTmFtZTogc3RyaW5nKTogUGFyc2VkQ2xhc3NOYW1lID0+IHtcbiAgICAgICAgY29uc3QgbW9kaWZpZXJzID0gW11cblxuICAgICAgICBsZXQgYnJhY2tldERlcHRoID0gMFxuICAgICAgICBsZXQgcGFyZW5EZXB0aCA9IDBcbiAgICAgICAgbGV0IG1vZGlmaWVyU3RhcnQgPSAwXG4gICAgICAgIGxldCBwb3N0Zml4TW9kaWZpZXJQb3NpdGlvbjogbnVtYmVyIHwgdW5kZWZpbmVkXG5cbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGNsYXNzTmFtZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50Q2hhcmFjdGVyID0gY2xhc3NOYW1lW2luZGV4XVxuXG4gICAgICAgICAgICBpZiAoYnJhY2tldERlcHRoID09PSAwICYmIHBhcmVuRGVwdGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudENoYXJhY3RlciA9PT0gTU9ESUZJRVJfU0VQQVJBVE9SKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGlmaWVycy5wdXNoKGNsYXNzTmFtZS5zbGljZShtb2RpZmllclN0YXJ0LCBpbmRleCkpXG4gICAgICAgICAgICAgICAgICAgIG1vZGlmaWVyU3RhcnQgPSBpbmRleCArIE1PRElGSUVSX1NFUEFSQVRPUl9MRU5HVEhcbiAgICAgICAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudENoYXJhY3RlciA9PT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc3RmaXhNb2RpZmllclBvc2l0aW9uID0gaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjdXJyZW50Q2hhcmFjdGVyID09PSAnWycpIHtcbiAgICAgICAgICAgICAgICBicmFja2V0RGVwdGgrK1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50Q2hhcmFjdGVyID09PSAnXScpIHtcbiAgICAgICAgICAgICAgICBicmFja2V0RGVwdGgtLVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50Q2hhcmFjdGVyID09PSAnKCcpIHtcbiAgICAgICAgICAgICAgICBwYXJlbkRlcHRoKytcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudENoYXJhY3RlciA9PT0gJyknKSB7XG4gICAgICAgICAgICAgICAgcGFyZW5EZXB0aC0tXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBiYXNlQ2xhc3NOYW1lV2l0aEltcG9ydGFudE1vZGlmaWVyID1cbiAgICAgICAgICAgIG1vZGlmaWVycy5sZW5ndGggPT09IDAgPyBjbGFzc05hbWUgOiBjbGFzc05hbWUuc3Vic3RyaW5nKG1vZGlmaWVyU3RhcnQpXG4gICAgICAgIGNvbnN0IGJhc2VDbGFzc05hbWUgPSBzdHJpcEltcG9ydGFudE1vZGlmaWVyKGJhc2VDbGFzc05hbWVXaXRoSW1wb3J0YW50TW9kaWZpZXIpXG4gICAgICAgIGNvbnN0IGhhc0ltcG9ydGFudE1vZGlmaWVyID0gYmFzZUNsYXNzTmFtZSAhPT0gYmFzZUNsYXNzTmFtZVdpdGhJbXBvcnRhbnRNb2RpZmllclxuICAgICAgICBjb25zdCBtYXliZVBvc3RmaXhNb2RpZmllclBvc2l0aW9uID1cbiAgICAgICAgICAgIHBvc3RmaXhNb2RpZmllclBvc2l0aW9uICYmIHBvc3RmaXhNb2RpZmllclBvc2l0aW9uID4gbW9kaWZpZXJTdGFydFxuICAgICAgICAgICAgICAgID8gcG9zdGZpeE1vZGlmaWVyUG9zaXRpb24gLSBtb2RpZmllclN0YXJ0XG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWRcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbW9kaWZpZXJzLFxuICAgICAgICAgICAgaGFzSW1wb3J0YW50TW9kaWZpZXIsXG4gICAgICAgICAgICBiYXNlQ2xhc3NOYW1lLFxuICAgICAgICAgICAgbWF5YmVQb3N0Zml4TW9kaWZpZXJQb3NpdGlvbixcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgY29uc3QgZnVsbFByZWZpeCA9IHByZWZpeCArIE1PRElGSUVSX1NFUEFSQVRPUlxuICAgICAgICBjb25zdCBwYXJzZUNsYXNzTmFtZU9yaWdpbmFsID0gcGFyc2VDbGFzc05hbWVcbiAgICAgICAgcGFyc2VDbGFzc05hbWUgPSAoY2xhc3NOYW1lKSA9PlxuICAgICAgICAgICAgY2xhc3NOYW1lLnN0YXJ0c1dpdGgoZnVsbFByZWZpeClcbiAgICAgICAgICAgICAgICA/IHBhcnNlQ2xhc3NOYW1lT3JpZ2luYWwoY2xhc3NOYW1lLnN1YnN0cmluZyhmdWxsUHJlZml4Lmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgaXNFeHRlcm5hbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllcnM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgIGhhc0ltcG9ydGFudE1vZGlmaWVyOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICBiYXNlQ2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgbWF5YmVQb3N0Zml4TW9kaWZpZXJQb3NpdGlvbjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChleHBlcmltZW50YWxQYXJzZUNsYXNzTmFtZSkge1xuICAgICAgICBjb25zdCBwYXJzZUNsYXNzTmFtZU9yaWdpbmFsID0gcGFyc2VDbGFzc05hbWVcbiAgICAgICAgcGFyc2VDbGFzc05hbWUgPSAoY2xhc3NOYW1lKSA9PlxuICAgICAgICAgICAgZXhwZXJpbWVudGFsUGFyc2VDbGFzc05hbWUoeyBjbGFzc05hbWUsIHBhcnNlQ2xhc3NOYW1lOiBwYXJzZUNsYXNzTmFtZU9yaWdpbmFsIH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlQ2xhc3NOYW1lXG59XG5cbmNvbnN0IHN0cmlwSW1wb3J0YW50TW9kaWZpZXIgPSAoYmFzZUNsYXNzTmFtZTogc3RyaW5nKSA9PiB7XG4gICAgaWYgKGJhc2VDbGFzc05hbWUuZW5kc1dpdGgoSU1QT1JUQU5UX01PRElGSUVSKSkge1xuICAgICAgICByZXR1cm4gYmFzZUNsYXNzTmFtZS5zdWJzdHJpbmcoMCwgYmFzZUNsYXNzTmFtZS5sZW5ndGggLSAxKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluIFRhaWx3aW5kIENTUyB2MyB0aGUgaW1wb3J0YW50IG1vZGlmaWVyIHdhcyBhdCB0aGUgc3RhcnQgb2YgdGhlIGJhc2UgY2xhc3MgbmFtZS4gVGhpcyBpcyBzdGlsbCBzdXBwb3J0ZWQgZm9yIGxlZ2FjeSByZWFzb25zLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2RjYXN0aWwvdGFpbHdpbmQtbWVyZ2UvaXNzdWVzLzUxMyNpc3N1ZWNvbW1lbnQtMjYxNDAyOTg2NFxuICAgICAqL1xuICAgIGlmIChiYXNlQ2xhc3NOYW1lLnN0YXJ0c1dpdGgoSU1QT1JUQU5UX01PRElGSUVSKSkge1xuICAgICAgICByZXR1cm4gYmFzZUNsYXNzTmFtZS5zdWJzdHJpbmcoMSlcbiAgICB9XG5cbiAgICByZXR1cm4gYmFzZUNsYXNzTmFtZVxufVxuIiwiaW1wb3J0IHsgQW55Q29uZmlnIH0gZnJvbSAnLi90eXBlcydcblxuLyoqXG4gKiBTb3J0cyBtb2RpZmllcnMgYWNjb3JkaW5nIHRvIGZvbGxvd2luZyBzY2hlbWE6XG4gKiAtIFByZWRlZmluZWQgbW9kaWZpZXJzIGFyZSBzb3J0ZWQgYWxwaGFiZXRpY2FsbHlcbiAqIC0gV2hlbiBhbiBhcmJpdHJhcnkgdmFyaWFudCBhcHBlYXJzLCBpdCBtdXN0IGJlIHByZXNlcnZlZCB3aGljaCBtb2RpZmllcnMgYXJlIGJlZm9yZSBhbmQgYWZ0ZXIgaXRcbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVNvcnRNb2RpZmllcnMgPSAoY29uZmlnOiBBbnlDb25maWcpID0+IHtcbiAgICBjb25zdCBvcmRlclNlbnNpdGl2ZU1vZGlmaWVycyA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgY29uZmlnLm9yZGVyU2Vuc2l0aXZlTW9kaWZpZXJzLm1hcCgobW9kaWZpZXIpID0+IFttb2RpZmllciwgdHJ1ZV0pLFxuICAgIClcblxuICAgIGNvbnN0IHNvcnRNb2RpZmllcnMgPSAobW9kaWZpZXJzOiBzdHJpbmdbXSkgPT4ge1xuICAgICAgICBpZiAobW9kaWZpZXJzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kaWZpZXJzXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzb3J0ZWRNb2RpZmllcnM6IHN0cmluZ1tdID0gW11cbiAgICAgICAgbGV0IHVuc29ydGVkTW9kaWZpZXJzOiBzdHJpbmdbXSA9IFtdXG5cbiAgICAgICAgbW9kaWZpZXJzLmZvckVhY2goKG1vZGlmaWVyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpc1Bvc2l0aW9uU2Vuc2l0aXZlID0gbW9kaWZpZXJbMF0gPT09ICdbJyB8fCBvcmRlclNlbnNpdGl2ZU1vZGlmaWVyc1ttb2RpZmllcl1cblxuICAgICAgICAgICAgaWYgKGlzUG9zaXRpb25TZW5zaXRpdmUpIHtcbiAgICAgICAgICAgICAgICBzb3J0ZWRNb2RpZmllcnMucHVzaCguLi51bnNvcnRlZE1vZGlmaWVycy5zb3J0KCksIG1vZGlmaWVyKVxuICAgICAgICAgICAgICAgIHVuc29ydGVkTW9kaWZpZXJzID0gW11cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdW5zb3J0ZWRNb2RpZmllcnMucHVzaChtb2RpZmllcilcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICBzb3J0ZWRNb2RpZmllcnMucHVzaCguLi51bnNvcnRlZE1vZGlmaWVycy5zb3J0KCkpXG5cbiAgICAgICAgcmV0dXJuIHNvcnRlZE1vZGlmaWVyc1xuICAgIH1cblxuICAgIHJldHVybiBzb3J0TW9kaWZpZXJzXG59XG4iLCJpbXBvcnQgeyBjcmVhdGVDbGFzc0dyb3VwVXRpbHMgfSBmcm9tICcuL2NsYXNzLWdyb3VwLXV0aWxzJ1xuaW1wb3J0IHsgY3JlYXRlTHJ1Q2FjaGUgfSBmcm9tICcuL2xydS1jYWNoZSdcbmltcG9ydCB7IGNyZWF0ZVBhcnNlQ2xhc3NOYW1lIH0gZnJvbSAnLi9wYXJzZS1jbGFzcy1uYW1lJ1xuaW1wb3J0IHsgY3JlYXRlU29ydE1vZGlmaWVycyB9IGZyb20gJy4vc29ydC1tb2RpZmllcnMnXG5pbXBvcnQgeyBBbnlDb25maWcgfSBmcm9tICcuL3R5cGVzJ1xuXG5leHBvcnQgdHlwZSBDb25maWdVdGlscyA9IFJldHVyblR5cGU8dHlwZW9mIGNyZWF0ZUNvbmZpZ1V0aWxzPlxuXG5leHBvcnQgY29uc3QgY3JlYXRlQ29uZmlnVXRpbHMgPSAoY29uZmlnOiBBbnlDb25maWcpID0+ICh7XG4gICAgY2FjaGU6IGNyZWF0ZUxydUNhY2hlPHN0cmluZywgc3RyaW5nPihjb25maWcuY2FjaGVTaXplKSxcbiAgICBwYXJzZUNsYXNzTmFtZTogY3JlYXRlUGFyc2VDbGFzc05hbWUoY29uZmlnKSxcbiAgICBzb3J0TW9kaWZpZXJzOiBjcmVhdGVTb3J0TW9kaWZpZXJzKGNvbmZpZyksXG4gICAgLi4uY3JlYXRlQ2xhc3NHcm91cFV0aWxzKGNvbmZpZyksXG59KVxuIiwiaW1wb3J0IHsgQ29uZmlnVXRpbHMgfSBmcm9tICcuL2NvbmZpZy11dGlscydcbmltcG9ydCB7IElNUE9SVEFOVF9NT0RJRklFUiB9IGZyb20gJy4vcGFyc2UtY2xhc3MtbmFtZSdcblxuY29uc3QgU1BMSVRfQ0xBU1NFU19SRUdFWCA9IC9cXHMrL1xuXG5leHBvcnQgY29uc3QgbWVyZ2VDbGFzc0xpc3QgPSAoY2xhc3NMaXN0OiBzdHJpbmcsIGNvbmZpZ1V0aWxzOiBDb25maWdVdGlscykgPT4ge1xuICAgIGNvbnN0IHsgcGFyc2VDbGFzc05hbWUsIGdldENsYXNzR3JvdXBJZCwgZ2V0Q29uZmxpY3RpbmdDbGFzc0dyb3VwSWRzLCBzb3J0TW9kaWZpZXJzIH0gPVxuICAgICAgICBjb25maWdVdGlsc1xuXG4gICAgLyoqXG4gICAgICogU2V0IG9mIGNsYXNzR3JvdXBJZHMgaW4gZm9sbG93aW5nIGZvcm1hdDpcbiAgICAgKiBge2ltcG9ydGFudE1vZGlmaWVyfXt2YXJpYW50TW9kaWZpZXJzfXtjbGFzc0dyb3VwSWR9YFxuICAgICAqIEBleGFtcGxlICdmbG9hdCdcbiAgICAgKiBAZXhhbXBsZSAnaG92ZXI6Zm9jdXM6YmctY29sb3InXG4gICAgICogQGV4YW1wbGUgJ21kOiFwcidcbiAgICAgKi9cbiAgICBjb25zdCBjbGFzc0dyb3Vwc0luQ29uZmxpY3Q6IHN0cmluZ1tdID0gW11cbiAgICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NMaXN0LnRyaW0oKS5zcGxpdChTUExJVF9DTEFTU0VTX1JFR0VYKVxuXG4gICAgbGV0IHJlc3VsdCA9ICcnXG5cbiAgICBmb3IgKGxldCBpbmRleCA9IGNsYXNzTmFtZXMubGVuZ3RoIC0gMTsgaW5kZXggPj0gMDsgaW5kZXggLT0gMSkge1xuICAgICAgICBjb25zdCBvcmlnaW5hbENsYXNzTmFtZSA9IGNsYXNzTmFtZXNbaW5kZXhdIVxuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGlzRXh0ZXJuYWwsXG4gICAgICAgICAgICBtb2RpZmllcnMsXG4gICAgICAgICAgICBoYXNJbXBvcnRhbnRNb2RpZmllcixcbiAgICAgICAgICAgIGJhc2VDbGFzc05hbWUsXG4gICAgICAgICAgICBtYXliZVBvc3RmaXhNb2RpZmllclBvc2l0aW9uLFxuICAgICAgICB9ID0gcGFyc2VDbGFzc05hbWUob3JpZ2luYWxDbGFzc05hbWUpXG5cbiAgICAgICAgaWYgKGlzRXh0ZXJuYWwpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG9yaWdpbmFsQ2xhc3NOYW1lICsgKHJlc3VsdC5sZW5ndGggPiAwID8gJyAnICsgcmVzdWx0IDogcmVzdWx0KVxuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBoYXNQb3N0Zml4TW9kaWZpZXIgPSAhIW1heWJlUG9zdGZpeE1vZGlmaWVyUG9zaXRpb25cbiAgICAgICAgbGV0IGNsYXNzR3JvdXBJZCA9IGdldENsYXNzR3JvdXBJZChcbiAgICAgICAgICAgIGhhc1Bvc3RmaXhNb2RpZmllclxuICAgICAgICAgICAgICAgID8gYmFzZUNsYXNzTmFtZS5zdWJzdHJpbmcoMCwgbWF5YmVQb3N0Zml4TW9kaWZpZXJQb3NpdGlvbilcbiAgICAgICAgICAgICAgICA6IGJhc2VDbGFzc05hbWUsXG4gICAgICAgIClcblxuICAgICAgICBpZiAoIWNsYXNzR3JvdXBJZCkge1xuICAgICAgICAgICAgaWYgKCFoYXNQb3N0Zml4TW9kaWZpZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBOb3QgYSBUYWlsd2luZCBjbGFzc1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG9yaWdpbmFsQ2xhc3NOYW1lICsgKHJlc3VsdC5sZW5ndGggPiAwID8gJyAnICsgcmVzdWx0IDogcmVzdWx0KVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNsYXNzR3JvdXBJZCA9IGdldENsYXNzR3JvdXBJZChiYXNlQ2xhc3NOYW1lKVxuXG4gICAgICAgICAgICBpZiAoIWNsYXNzR3JvdXBJZCkge1xuICAgICAgICAgICAgICAgIC8vIE5vdCBhIFRhaWx3aW5kIGNsYXNzXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gb3JpZ2luYWxDbGFzc05hbWUgKyAocmVzdWx0Lmxlbmd0aCA+IDAgPyAnICcgKyByZXN1bHQgOiByZXN1bHQpXG4gICAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaGFzUG9zdGZpeE1vZGlmaWVyID0gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHZhcmlhbnRNb2RpZmllciA9IHNvcnRNb2RpZmllcnMobW9kaWZpZXJzKS5qb2luKCc6JylcblxuICAgICAgICBjb25zdCBtb2RpZmllcklkID0gaGFzSW1wb3J0YW50TW9kaWZpZXJcbiAgICAgICAgICAgID8gdmFyaWFudE1vZGlmaWVyICsgSU1QT1JUQU5UX01PRElGSUVSXG4gICAgICAgICAgICA6IHZhcmlhbnRNb2RpZmllclxuXG4gICAgICAgIGNvbnN0IGNsYXNzSWQgPSBtb2RpZmllcklkICsgY2xhc3NHcm91cElkXG5cbiAgICAgICAgaWYgKGNsYXNzR3JvdXBzSW5Db25mbGljdC5pbmNsdWRlcyhjbGFzc0lkKSkge1xuICAgICAgICAgICAgLy8gVGFpbHdpbmQgY2xhc3Mgb21pdHRlZCBkdWUgdG8gY29uZmxpY3RcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICBjbGFzc0dyb3Vwc0luQ29uZmxpY3QucHVzaChjbGFzc0lkKVxuXG4gICAgICAgIGNvbnN0IGNvbmZsaWN0R3JvdXBzID0gZ2V0Q29uZmxpY3RpbmdDbGFzc0dyb3VwSWRzKGNsYXNzR3JvdXBJZCwgaGFzUG9zdGZpeE1vZGlmaWVyKVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbmZsaWN0R3JvdXBzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBncm91cCA9IGNvbmZsaWN0R3JvdXBzW2ldIVxuICAgICAgICAgICAgY2xhc3NHcm91cHNJbkNvbmZsaWN0LnB1c2gobW9kaWZpZXJJZCArIGdyb3VwKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGFpbHdpbmQgY2xhc3Mgbm90IGluIGNvbmZsaWN0XG4gICAgICAgIHJlc3VsdCA9IG9yaWdpbmFsQ2xhc3NOYW1lICsgKHJlc3VsdC5sZW5ndGggPiAwID8gJyAnICsgcmVzdWx0IDogcmVzdWx0KVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRcbn1cbiIsIi8qKlxuICogVGhlIGNvZGUgaW4gdGhpcyBmaWxlIGlzIGNvcGllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9sdWtlZWQvY2xzeCBhbmQgbW9kaWZpZWQgdG8gc3VpdCB0aGUgbmVlZHMgb2YgdGFpbHdpbmQtbWVyZ2UgYmV0dGVyLlxuICpcbiAqIFNwZWNpZmljYWxseTpcbiAqIC0gUnVudGltZSBjb2RlIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2x1a2VlZC9jbHN4L2Jsb2IvdjEuMi4xL3NyYy9pbmRleC5qc1xuICogLSBUeXBlU2NyaXB0IHR5cGVzIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2x1a2VlZC9jbHN4L2Jsb2IvdjEuMi4xL2Nsc3guZC50c1xuICpcbiAqIE9yaWdpbmFsIGNvZGUgaGFzIE1JVCBsaWNlbnNlOiBDb3B5cmlnaHQgKGMpIEx1a2UgRWR3YXJkcyA8bHVrZS5lZHdhcmRzMDVAZ21haWwuY29tPiAobHVrZWVkLmNvbSlcbiAqL1xuXG5leHBvcnQgdHlwZSBDbGFzc05hbWVWYWx1ZSA9IENsYXNzTmFtZUFycmF5IHwgc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZCB8IDAgfCAwbiB8IGZhbHNlXG50eXBlIENsYXNzTmFtZUFycmF5ID0gQ2xhc3NOYW1lVmFsdWVbXVxuXG5leHBvcnQgZnVuY3Rpb24gdHdKb2luKC4uLmNsYXNzTGlzdHM6IENsYXNzTmFtZVZhbHVlW10pOiBzdHJpbmdcbmV4cG9ydCBmdW5jdGlvbiB0d0pvaW4oKSB7XG4gICAgbGV0IGluZGV4ID0gMFxuICAgIGxldCBhcmd1bWVudDogQ2xhc3NOYW1lVmFsdWVcbiAgICBsZXQgcmVzb2x2ZWRWYWx1ZTogc3RyaW5nXG4gICAgbGV0IHN0cmluZyA9ICcnXG5cbiAgICB3aGlsZSAoaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIGlmICgoYXJndW1lbnQgPSBhcmd1bWVudHNbaW5kZXgrK10pKSB7XG4gICAgICAgICAgICBpZiAoKHJlc29sdmVkVmFsdWUgPSB0b1ZhbHVlKGFyZ3VtZW50KSkpIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcgJiYgKHN0cmluZyArPSAnICcpXG4gICAgICAgICAgICAgICAgc3RyaW5nICs9IHJlc29sdmVkVmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RyaW5nXG59XG5cbmNvbnN0IHRvVmFsdWUgPSAobWl4OiBDbGFzc05hbWVBcnJheSB8IHN0cmluZykgPT4ge1xuICAgIGlmICh0eXBlb2YgbWl4ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gbWl4XG4gICAgfVxuXG4gICAgbGV0IHJlc29sdmVkVmFsdWU6IHN0cmluZ1xuICAgIGxldCBzdHJpbmcgPSAnJ1xuXG4gICAgZm9yIChsZXQgayA9IDA7IGsgPCBtaXgubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgaWYgKG1peFtrXSkge1xuICAgICAgICAgICAgaWYgKChyZXNvbHZlZFZhbHVlID0gdG9WYWx1ZShtaXhba10gYXMgQ2xhc3NOYW1lQXJyYXkgfCBzdHJpbmcpKSkge1xuICAgICAgICAgICAgICAgIHN0cmluZyAmJiAoc3RyaW5nICs9ICcgJylcbiAgICAgICAgICAgICAgICBzdHJpbmcgKz0gcmVzb2x2ZWRWYWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmluZ1xufVxuIiwiaW1wb3J0IHsgY3JlYXRlQ29uZmlnVXRpbHMgfSBmcm9tICcuL2NvbmZpZy11dGlscydcbmltcG9ydCB7IG1lcmdlQ2xhc3NMaXN0IH0gZnJvbSAnLi9tZXJnZS1jbGFzc2xpc3QnXG5pbXBvcnQgeyBDbGFzc05hbWVWYWx1ZSwgdHdKb2luIH0gZnJvbSAnLi90dy1qb2luJ1xuaW1wb3J0IHsgQW55Q29uZmlnIH0gZnJvbSAnLi90eXBlcydcblxudHlwZSBDcmVhdGVDb25maWdGaXJzdCA9ICgpID0+IEFueUNvbmZpZ1xudHlwZSBDcmVhdGVDb25maWdTdWJzZXF1ZW50ID0gKGNvbmZpZzogQW55Q29uZmlnKSA9PiBBbnlDb25maWdcbnR5cGUgVGFpbHdpbmRNZXJnZSA9ICguLi5jbGFzc0xpc3RzOiBDbGFzc05hbWVWYWx1ZVtdKSA9PiBzdHJpbmdcbnR5cGUgQ29uZmlnVXRpbHMgPSBSZXR1cm5UeXBlPHR5cGVvZiBjcmVhdGVDb25maWdVdGlscz5cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVRhaWx3aW5kTWVyZ2UoXG4gICAgY3JlYXRlQ29uZmlnRmlyc3Q6IENyZWF0ZUNvbmZpZ0ZpcnN0LFxuICAgIC4uLmNyZWF0ZUNvbmZpZ1Jlc3Q6IENyZWF0ZUNvbmZpZ1N1YnNlcXVlbnRbXVxuKTogVGFpbHdpbmRNZXJnZSB7XG4gICAgbGV0IGNvbmZpZ1V0aWxzOiBDb25maWdVdGlsc1xuICAgIGxldCBjYWNoZUdldDogQ29uZmlnVXRpbHNbJ2NhY2hlJ11bJ2dldCddXG4gICAgbGV0IGNhY2hlU2V0OiBDb25maWdVdGlsc1snY2FjaGUnXVsnc2V0J11cbiAgICBsZXQgZnVuY3Rpb25Ub0NhbGwgPSBpbml0VGFpbHdpbmRNZXJnZVxuXG4gICAgZnVuY3Rpb24gaW5pdFRhaWx3aW5kTWVyZ2UoY2xhc3NMaXN0OiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgY29uZmlnID0gY3JlYXRlQ29uZmlnUmVzdC5yZWR1Y2UoXG4gICAgICAgICAgICAocHJldmlvdXNDb25maWcsIGNyZWF0ZUNvbmZpZ0N1cnJlbnQpID0+IGNyZWF0ZUNvbmZpZ0N1cnJlbnQocHJldmlvdXNDb25maWcpLFxuICAgICAgICAgICAgY3JlYXRlQ29uZmlnRmlyc3QoKSBhcyBBbnlDb25maWcsXG4gICAgICAgIClcblxuICAgICAgICBjb25maWdVdGlscyA9IGNyZWF0ZUNvbmZpZ1V0aWxzKGNvbmZpZylcbiAgICAgICAgY2FjaGVHZXQgPSBjb25maWdVdGlscy5jYWNoZS5nZXRcbiAgICAgICAgY2FjaGVTZXQgPSBjb25maWdVdGlscy5jYWNoZS5zZXRcbiAgICAgICAgZnVuY3Rpb25Ub0NhbGwgPSB0YWlsd2luZE1lcmdlXG5cbiAgICAgICAgcmV0dXJuIHRhaWx3aW5kTWVyZ2UoY2xhc3NMaXN0KVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRhaWx3aW5kTWVyZ2UoY2xhc3NMaXN0OiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgY2FjaGVkUmVzdWx0ID0gY2FjaGVHZXQoY2xhc3NMaXN0KVxuXG4gICAgICAgIGlmIChjYWNoZWRSZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRSZXN1bHRcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG1lcmdlQ2xhc3NMaXN0KGNsYXNzTGlzdCwgY29uZmlnVXRpbHMpXG4gICAgICAgIGNhY2hlU2V0KGNsYXNzTGlzdCwgcmVzdWx0KVxuXG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gY2FsbFRhaWx3aW5kTWVyZ2UoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvblRvQ2FsbCh0d0pvaW4uYXBwbHkobnVsbCwgYXJndW1lbnRzIGFzIGFueSkpXG4gICAgfVxufVxuIiwiaW1wb3J0IHsgRGVmYXVsdFRoZW1lR3JvdXBJZHMsIE5vSW5mZXIsIFRoZW1lR2V0dGVyLCBUaGVtZU9iamVjdCB9IGZyb20gJy4vdHlwZXMnXG5cbmV4cG9ydCBjb25zdCBmcm9tVGhlbWUgPSA8XG4gICAgQWRkaXRpb25hbFRoZW1lR3JvdXBJZHMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBEZWZhdWx0VGhlbWVHcm91cElkc0lubmVyIGV4dGVuZHMgc3RyaW5nID0gRGVmYXVsdFRoZW1lR3JvdXBJZHMsXG4+KGtleTogTm9JbmZlcjxEZWZhdWx0VGhlbWVHcm91cElkc0lubmVyIHwgQWRkaXRpb25hbFRoZW1lR3JvdXBJZHM+KTogVGhlbWVHZXR0ZXIgPT4ge1xuICAgIGNvbnN0IHRoZW1lR2V0dGVyID0gKHRoZW1lOiBUaGVtZU9iamVjdDxEZWZhdWx0VGhlbWVHcm91cElkc0lubmVyIHwgQWRkaXRpb25hbFRoZW1lR3JvdXBJZHM+KSA9PlxuICAgICAgICB0aGVtZVtrZXldIHx8IFtdXG5cbiAgICB0aGVtZUdldHRlci5pc1RoZW1lR2V0dGVyID0gdHJ1ZSBhcyBjb25zdFxuXG4gICAgcmV0dXJuIHRoZW1lR2V0dGVyXG59XG4iLCJjb25zdCBhcmJpdHJhcnlWYWx1ZVJlZ2V4ID0gL15cXFsoPzooXFx3W1xcdy1dKik6KT8oLispXFxdJC9pXG5jb25zdCBhcmJpdHJhcnlWYXJpYWJsZVJlZ2V4ID0gL15cXCgoPzooXFx3W1xcdy1dKik6KT8oLispXFwpJC9pXG5jb25zdCBmcmFjdGlvblJlZ2V4ID0gL15cXGQrXFwvXFxkKyQvXG5jb25zdCB0c2hpcnRVbml0UmVnZXggPSAvXihcXGQrKFxcLlxcZCspPyk/KHhzfHNtfG1kfGxnfHhsKSQvXG5jb25zdCBsZW5ndGhVbml0UmVnZXggPVxuICAgIC9cXGQrKCV8cHh8cj9lbXxbc2RsXT92KFtod2liXXxtaW58bWF4KXxwdHxwY3xpbnxjbXxtbXxjYXB8Y2h8ZXh8cj9saHxjcSh3fGh8aXxifG1pbnxtYXgpKXxcXGIoY2FsY3xtaW58bWF4fGNsYW1wKVxcKC4rXFwpfF4wJC9cbmNvbnN0IGNvbG9yRnVuY3Rpb25SZWdleCA9IC9eKHJnYmE/fGhzbGE/fGh3Ynwob2spPyhsYWJ8bGNoKXxjb2xvci1taXgpXFwoLitcXCkkL1xuLy8gU2hhZG93IGFsd2F5cyBiZWdpbnMgd2l0aCB4IGFuZCB5IG9mZnNldCBzZXBhcmF0ZWQgYnkgdW5kZXJzY29yZSBvcHRpb25hbGx5IHByZXBlbmRlZCBieSBpbnNldFxuY29uc3Qgc2hhZG93UmVnZXggPSAvXihpbnNldF8pPy0/KChcXGQrKT9cXC4/KFxcZCspW2Etel0rfDApXy0/KChcXGQrKT9cXC4/KFxcZCspW2Etel0rfDApL1xuY29uc3QgaW1hZ2VSZWdleCA9XG4gICAgL14odXJsfGltYWdlfGltYWdlLXNldHxjcm9zcy1mYWRlfGVsZW1lbnR8KHJlcGVhdGluZy0pPyhsaW5lYXJ8cmFkaWFsfGNvbmljKS1ncmFkaWVudClcXCguK1xcKSQvXG5cbmV4cG9ydCBjb25zdCBpc0ZyYWN0aW9uID0gKHZhbHVlOiBzdHJpbmcpID0+IGZyYWN0aW9uUmVnZXgudGVzdCh2YWx1ZSlcblxuZXhwb3J0IGNvbnN0IGlzTnVtYmVyID0gKHZhbHVlOiBzdHJpbmcpID0+ICEhdmFsdWUgJiYgIU51bWJlci5pc05hTihOdW1iZXIodmFsdWUpKVxuXG5leHBvcnQgY29uc3QgaXNJbnRlZ2VyID0gKHZhbHVlOiBzdHJpbmcpID0+ICEhdmFsdWUgJiYgTnVtYmVyLmlzSW50ZWdlcihOdW1iZXIodmFsdWUpKVxuXG5leHBvcnQgY29uc3QgaXNQZXJjZW50ID0gKHZhbHVlOiBzdHJpbmcpID0+IHZhbHVlLmVuZHNXaXRoKCclJykgJiYgaXNOdW1iZXIodmFsdWUuc2xpY2UoMCwgLTEpKVxuXG5leHBvcnQgY29uc3QgaXNUc2hpcnRTaXplID0gKHZhbHVlOiBzdHJpbmcpID0+IHRzaGlydFVuaXRSZWdleC50ZXN0KHZhbHVlKVxuXG5leHBvcnQgY29uc3QgaXNBbnkgPSAoKSA9PiB0cnVlXG5cbmNvbnN0IGlzTGVuZ3RoT25seSA9ICh2YWx1ZTogc3RyaW5nKSA9PlxuICAgIC8vIGBjb2xvckZ1bmN0aW9uUmVnZXhgIGNoZWNrIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIGNvbG9yIGZ1bmN0aW9ucyBjYW4gaGF2ZSBwZXJjZW50YWdlcyBpbiB0aGVtIHdoaWNoIHdoaWNoIHdvdWxkIGJlIGluY29ycmVjdGx5IGNsYXNzaWZpZWQgYXMgbGVuZ3Rocy5cbiAgICAvLyBGb3IgZXhhbXBsZSwgYGhzbCgwIDAlIDAlKWAgd291bGQgYmUgY2xhc3NpZmllZCBhcyBhIGxlbmd0aCB3aXRob3V0IHRoaXMgY2hlY2suXG4gICAgLy8gSSBjb3VsZCBhbHNvIHVzZSBsb29rYmVoaW5kIGFzc2VydGlvbiBpbiBgbGVuZ3RoVW5pdFJlZ2V4YCBidXQgdGhhdCBpc24ndCBzdXBwb3J0ZWQgd2lkZWx5IGVub3VnaC5cbiAgICBsZW5ndGhVbml0UmVnZXgudGVzdCh2YWx1ZSkgJiYgIWNvbG9yRnVuY3Rpb25SZWdleC50ZXN0KHZhbHVlKVxuXG5jb25zdCBpc05ldmVyID0gKCkgPT4gZmFsc2VcblxuY29uc3QgaXNTaGFkb3cgPSAodmFsdWU6IHN0cmluZykgPT4gc2hhZG93UmVnZXgudGVzdCh2YWx1ZSlcblxuY29uc3QgaXNJbWFnZSA9ICh2YWx1ZTogc3RyaW5nKSA9PiBpbWFnZVJlZ2V4LnRlc3QodmFsdWUpXG5cbmV4cG9ydCBjb25zdCBpc0FueU5vbkFyYml0cmFyeSA9ICh2YWx1ZTogc3RyaW5nKSA9PlxuICAgICFpc0FyYml0cmFyeVZhbHVlKHZhbHVlKSAmJiAhaXNBcmJpdHJhcnlWYXJpYWJsZSh2YWx1ZSlcblxuZXhwb3J0IGNvbnN0IGlzQXJiaXRyYXJ5U2l6ZSA9ICh2YWx1ZTogc3RyaW5nKSA9PiBnZXRJc0FyYml0cmFyeVZhbHVlKHZhbHVlLCBpc0xhYmVsU2l6ZSwgaXNOZXZlcilcblxuZXhwb3J0IGNvbnN0IGlzQXJiaXRyYXJ5VmFsdWUgPSAodmFsdWU6IHN0cmluZykgPT4gYXJiaXRyYXJ5VmFsdWVSZWdleC50ZXN0KHZhbHVlKVxuXG5leHBvcnQgY29uc3QgaXNBcmJpdHJhcnlMZW5ndGggPSAodmFsdWU6IHN0cmluZykgPT5cbiAgICBnZXRJc0FyYml0cmFyeVZhbHVlKHZhbHVlLCBpc0xhYmVsTGVuZ3RoLCBpc0xlbmd0aE9ubHkpXG5cbmV4cG9ydCBjb25zdCBpc0FyYml0cmFyeU51bWJlciA9ICh2YWx1ZTogc3RyaW5nKSA9PlxuICAgIGdldElzQXJiaXRyYXJ5VmFsdWUodmFsdWUsIGlzTGFiZWxOdW1iZXIsIGlzTnVtYmVyKVxuXG5leHBvcnQgY29uc3QgaXNBcmJpdHJhcnlQb3NpdGlvbiA9ICh2YWx1ZTogc3RyaW5nKSA9PlxuICAgIGdldElzQXJiaXRyYXJ5VmFsdWUodmFsdWUsIGlzTGFiZWxQb3NpdGlvbiwgaXNOZXZlcilcblxuZXhwb3J0IGNvbnN0IGlzQXJiaXRyYXJ5SW1hZ2UgPSAodmFsdWU6IHN0cmluZykgPT4gZ2V0SXNBcmJpdHJhcnlWYWx1ZSh2YWx1ZSwgaXNMYWJlbEltYWdlLCBpc0ltYWdlKVxuXG5leHBvcnQgY29uc3QgaXNBcmJpdHJhcnlTaGFkb3cgPSAodmFsdWU6IHN0cmluZykgPT5cbiAgICBnZXRJc0FyYml0cmFyeVZhbHVlKHZhbHVlLCBpc0xhYmVsU2hhZG93LCBpc1NoYWRvdylcblxuZXhwb3J0IGNvbnN0IGlzQXJiaXRyYXJ5VmFyaWFibGUgPSAodmFsdWU6IHN0cmluZykgPT4gYXJiaXRyYXJ5VmFyaWFibGVSZWdleC50ZXN0KHZhbHVlKVxuXG5leHBvcnQgY29uc3QgaXNBcmJpdHJhcnlWYXJpYWJsZUxlbmd0aCA9ICh2YWx1ZTogc3RyaW5nKSA9PlxuICAgIGdldElzQXJiaXRyYXJ5VmFyaWFibGUodmFsdWUsIGlzTGFiZWxMZW5ndGgpXG5cbmV4cG9ydCBjb25zdCBpc0FyYml0cmFyeVZhcmlhYmxlRmFtaWx5TmFtZSA9ICh2YWx1ZTogc3RyaW5nKSA9PlxuICAgIGdldElzQXJiaXRyYXJ5VmFyaWFibGUodmFsdWUsIGlzTGFiZWxGYW1pbHlOYW1lKVxuXG5leHBvcnQgY29uc3QgaXNBcmJpdHJhcnlWYXJpYWJsZVBvc2l0aW9uID0gKHZhbHVlOiBzdHJpbmcpID0+XG4gICAgZ2V0SXNBcmJpdHJhcnlWYXJpYWJsZSh2YWx1ZSwgaXNMYWJlbFBvc2l0aW9uKVxuXG5leHBvcnQgY29uc3QgaXNBcmJpdHJhcnlWYXJpYWJsZVNpemUgPSAodmFsdWU6IHN0cmluZykgPT4gZ2V0SXNBcmJpdHJhcnlWYXJpYWJsZSh2YWx1ZSwgaXNMYWJlbFNpemUpXG5cbmV4cG9ydCBjb25zdCBpc0FyYml0cmFyeVZhcmlhYmxlSW1hZ2UgPSAodmFsdWU6IHN0cmluZykgPT5cbiAgICBnZXRJc0FyYml0cmFyeVZhcmlhYmxlKHZhbHVlLCBpc0xhYmVsSW1hZ2UpXG5cbmV4cG9ydCBjb25zdCBpc0FyYml0cmFyeVZhcmlhYmxlU2hhZG93ID0gKHZhbHVlOiBzdHJpbmcpID0+XG4gICAgZ2V0SXNBcmJpdHJhcnlWYXJpYWJsZSh2YWx1ZSwgaXNMYWJlbFNoYWRvdywgdHJ1ZSlcblxuLy8gSGVscGVyc1xuXG5jb25zdCBnZXRJc0FyYml0cmFyeVZhbHVlID0gKFxuICAgIHZhbHVlOiBzdHJpbmcsXG4gICAgdGVzdExhYmVsOiAobGFiZWw6IHN0cmluZykgPT4gYm9vbGVhbixcbiAgICB0ZXN0VmFsdWU6ICh2YWx1ZTogc3RyaW5nKSA9PiBib29sZWFuLFxuKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXJiaXRyYXJ5VmFsdWVSZWdleC5leGVjKHZhbHVlKVxuXG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgICBpZiAocmVzdWx0WzFdKSB7XG4gICAgICAgICAgICByZXR1cm4gdGVzdExhYmVsKHJlc3VsdFsxXSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0ZXN0VmFsdWUocmVzdWx0WzJdISlcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2Vcbn1cblxuY29uc3QgZ2V0SXNBcmJpdHJhcnlWYXJpYWJsZSA9IChcbiAgICB2YWx1ZTogc3RyaW5nLFxuICAgIHRlc3RMYWJlbDogKGxhYmVsOiBzdHJpbmcpID0+IGJvb2xlYW4sXG4gICAgc2hvdWxkTWF0Y2hOb0xhYmVsID0gZmFsc2UsXG4pID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBhcmJpdHJhcnlWYXJpYWJsZVJlZ2V4LmV4ZWModmFsdWUpXG5cbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIGlmIChyZXN1bHRbMV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXN0TGFiZWwocmVzdWx0WzFdKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaG91bGRNYXRjaE5vTGFiZWxcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2Vcbn1cblxuLy8gTGFiZWxzXG5cbmNvbnN0IGlzTGFiZWxQb3NpdGlvbiA9IChsYWJlbDogc3RyaW5nKSA9PiBsYWJlbCA9PT0gJ3Bvc2l0aW9uJyB8fCBsYWJlbCA9PT0gJ3BlcmNlbnRhZ2UnXG5cbmNvbnN0IGlzTGFiZWxJbWFnZSA9IChsYWJlbDogc3RyaW5nKSA9PiBsYWJlbCA9PT0gJ2ltYWdlJyB8fCBsYWJlbCA9PT0gJ3VybCdcblxuY29uc3QgaXNMYWJlbFNpemUgPSAobGFiZWw6IHN0cmluZykgPT4gbGFiZWwgPT09ICdsZW5ndGgnIHx8IGxhYmVsID09PSAnc2l6ZScgfHwgbGFiZWwgPT09ICdiZy1zaXplJ1xuXG5jb25zdCBpc0xhYmVsTGVuZ3RoID0gKGxhYmVsOiBzdHJpbmcpID0+IGxhYmVsID09PSAnbGVuZ3RoJ1xuXG5jb25zdCBpc0xhYmVsTnVtYmVyID0gKGxhYmVsOiBzdHJpbmcpID0+IGxhYmVsID09PSAnbnVtYmVyJ1xuXG5jb25zdCBpc0xhYmVsRmFtaWx5TmFtZSA9IChsYWJlbDogc3RyaW5nKSA9PiBsYWJlbCA9PT0gJ2ZhbWlseS1uYW1lJ1xuXG5jb25zdCBpc0xhYmVsU2hhZG93ID0gKGxhYmVsOiBzdHJpbmcpID0+IGxhYmVsID09PSAnc2hhZG93J1xuIiwiaW1wb3J0IHsgZnJvbVRoZW1lIH0gZnJvbSAnLi9mcm9tLXRoZW1lJ1xuaW1wb3J0IHsgQ29uZmlnLCBEZWZhdWx0Q2xhc3NHcm91cElkcywgRGVmYXVsdFRoZW1lR3JvdXBJZHMgfSBmcm9tICcuL3R5cGVzJ1xuaW1wb3J0IHtcbiAgICBpc0FueSxcbiAgICBpc0FueU5vbkFyYml0cmFyeSxcbiAgICBpc0FyYml0cmFyeUltYWdlLFxuICAgIGlzQXJiaXRyYXJ5TGVuZ3RoLFxuICAgIGlzQXJiaXRyYXJ5TnVtYmVyLFxuICAgIGlzQXJiaXRyYXJ5UG9zaXRpb24sXG4gICAgaXNBcmJpdHJhcnlTaGFkb3csXG4gICAgaXNBcmJpdHJhcnlTaXplLFxuICAgIGlzQXJiaXRyYXJ5VmFsdWUsXG4gICAgaXNBcmJpdHJhcnlWYXJpYWJsZSxcbiAgICBpc0FyYml0cmFyeVZhcmlhYmxlRmFtaWx5TmFtZSxcbiAgICBpc0FyYml0cmFyeVZhcmlhYmxlSW1hZ2UsXG4gICAgaXNBcmJpdHJhcnlWYXJpYWJsZUxlbmd0aCxcbiAgICBpc0FyYml0cmFyeVZhcmlhYmxlUG9zaXRpb24sXG4gICAgaXNBcmJpdHJhcnlWYXJpYWJsZVNoYWRvdyxcbiAgICBpc0FyYml0cmFyeVZhcmlhYmxlU2l6ZSxcbiAgICBpc0ZyYWN0aW9uLFxuICAgIGlzSW50ZWdlcixcbiAgICBpc051bWJlcixcbiAgICBpc1BlcmNlbnQsXG4gICAgaXNUc2hpcnRTaXplLFxufSBmcm9tICcuL3ZhbGlkYXRvcnMnXG5cbmV4cG9ydCBjb25zdCBnZXREZWZhdWx0Q29uZmlnID0gKCkgPT4ge1xuICAgIC8qKlxuICAgICAqIFRoZW1lIGdldHRlcnMgZm9yIHRoZW1lIHZhcmlhYmxlIG5hbWVzcGFjZXNcbiAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdGhlbWUjdGhlbWUtdmFyaWFibGUtbmFtZXNwYWNlc1xuICAgICAqL1xuICAgIC8qKiovXG5cbiAgICBjb25zdCB0aGVtZUNvbG9yID0gZnJvbVRoZW1lKCdjb2xvcicpXG4gICAgY29uc3QgdGhlbWVGb250ID0gZnJvbVRoZW1lKCdmb250JylcbiAgICBjb25zdCB0aGVtZVRleHQgPSBmcm9tVGhlbWUoJ3RleHQnKVxuICAgIGNvbnN0IHRoZW1lRm9udFdlaWdodCA9IGZyb21UaGVtZSgnZm9udC13ZWlnaHQnKVxuICAgIGNvbnN0IHRoZW1lVHJhY2tpbmcgPSBmcm9tVGhlbWUoJ3RyYWNraW5nJylcbiAgICBjb25zdCB0aGVtZUxlYWRpbmcgPSBmcm9tVGhlbWUoJ2xlYWRpbmcnKVxuICAgIGNvbnN0IHRoZW1lQnJlYWtwb2ludCA9IGZyb21UaGVtZSgnYnJlYWtwb2ludCcpXG4gICAgY29uc3QgdGhlbWVDb250YWluZXIgPSBmcm9tVGhlbWUoJ2NvbnRhaW5lcicpXG4gICAgY29uc3QgdGhlbWVTcGFjaW5nID0gZnJvbVRoZW1lKCdzcGFjaW5nJylcbiAgICBjb25zdCB0aGVtZVJhZGl1cyA9IGZyb21UaGVtZSgncmFkaXVzJylcbiAgICBjb25zdCB0aGVtZVNoYWRvdyA9IGZyb21UaGVtZSgnc2hhZG93JylcbiAgICBjb25zdCB0aGVtZUluc2V0U2hhZG93ID0gZnJvbVRoZW1lKCdpbnNldC1zaGFkb3cnKVxuICAgIGNvbnN0IHRoZW1lVGV4dFNoYWRvdyA9IGZyb21UaGVtZSgndGV4dC1zaGFkb3cnKVxuICAgIGNvbnN0IHRoZW1lRHJvcFNoYWRvdyA9IGZyb21UaGVtZSgnZHJvcC1zaGFkb3cnKVxuICAgIGNvbnN0IHRoZW1lQmx1ciA9IGZyb21UaGVtZSgnYmx1cicpXG4gICAgY29uc3QgdGhlbWVQZXJzcGVjdGl2ZSA9IGZyb21UaGVtZSgncGVyc3BlY3RpdmUnKVxuICAgIGNvbnN0IHRoZW1lQXNwZWN0ID0gZnJvbVRoZW1lKCdhc3BlY3QnKVxuICAgIGNvbnN0IHRoZW1lRWFzZSA9IGZyb21UaGVtZSgnZWFzZScpXG4gICAgY29uc3QgdGhlbWVBbmltYXRlID0gZnJvbVRoZW1lKCdhbmltYXRlJylcblxuICAgIC8qKlxuICAgICAqIEhlbHBlcnMgdG8gYXZvaWQgcmVwZWF0aW5nIHRoZSBzYW1lIHNjYWxlc1xuICAgICAqXG4gICAgICogV2UgdXNlIGZ1bmN0aW9ucyB0aGF0IGNyZWF0ZSBhIG5ldyBhcnJheSBldmVyeSB0aW1lIHRoZXkncmUgY2FsbGVkIGluc3RlYWQgb2Ygc3RhdGljIGFycmF5cy5cbiAgICAgKiBUaGlzIGVuc3VyZXMgdGhhdCB1c2VycyB3aG8gbW9kaWZ5IGFueSBzY2FsZSBieSBtdXRhdGluZyB0aGUgYXJyYXkgKGUuZy4gd2l0aCBgYXJyYXkucHVzaChlbGVtZW50KWApIGRvbid0IGFjY2lkZW50YWxseSBtdXRhdGUgYXJyYXlzIGluIG90aGVyIHBhcnRzIG9mIHRoZSBjb25maWcuXG4gICAgICovXG4gICAgLyoqKi9cblxuICAgIGNvbnN0IHNjYWxlQnJlYWsgPSAoKSA9PlxuICAgICAgICBbJ2F1dG8nLCAnYXZvaWQnLCAnYWxsJywgJ2F2b2lkLXBhZ2UnLCAncGFnZScsICdsZWZ0JywgJ3JpZ2h0JywgJ2NvbHVtbiddIGFzIGNvbnN0XG4gICAgY29uc3Qgc2NhbGVQb3NpdGlvbiA9ICgpID0+XG4gICAgICAgIFtcbiAgICAgICAgICAgICdjZW50ZXInLFxuICAgICAgICAgICAgJ3RvcCcsXG4gICAgICAgICAgICAnYm90dG9tJyxcbiAgICAgICAgICAgICdsZWZ0JyxcbiAgICAgICAgICAgICdyaWdodCcsXG4gICAgICAgICAgICAndG9wLWxlZnQnLFxuICAgICAgICAgICAgLy8gRGVwcmVjYXRlZCBzaW5jZSBUYWlsd2luZCBDU1MgdjQuMS4wLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3RhaWx3aW5kbGFicy90YWlsd2luZGNzcy9wdWxsLzE3Mzc4XG4gICAgICAgICAgICAnbGVmdC10b3AnLFxuICAgICAgICAgICAgJ3RvcC1yaWdodCcsXG4gICAgICAgICAgICAvLyBEZXByZWNhdGVkIHNpbmNlIFRhaWx3aW5kIENTUyB2NC4xLjAsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vdGFpbHdpbmRsYWJzL3RhaWx3aW5kY3NzL3B1bGwvMTczNzhcbiAgICAgICAgICAgICdyaWdodC10b3AnLFxuICAgICAgICAgICAgJ2JvdHRvbS1yaWdodCcsXG4gICAgICAgICAgICAvLyBEZXByZWNhdGVkIHNpbmNlIFRhaWx3aW5kIENTUyB2NC4xLjAsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vdGFpbHdpbmRsYWJzL3RhaWx3aW5kY3NzL3B1bGwvMTczNzhcbiAgICAgICAgICAgICdyaWdodC1ib3R0b20nLFxuICAgICAgICAgICAgJ2JvdHRvbS1sZWZ0JyxcbiAgICAgICAgICAgIC8vIERlcHJlY2F0ZWQgc2luY2UgVGFpbHdpbmQgQ1NTIHY0LjEuMCwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90YWlsd2luZGxhYnMvdGFpbHdpbmRjc3MvcHVsbC8xNzM3OFxuICAgICAgICAgICAgJ2xlZnQtYm90dG9tJyxcbiAgICAgICAgXSBhcyBjb25zdFxuICAgIGNvbnN0IHNjYWxlUG9zaXRpb25XaXRoQXJiaXRyYXJ5ID0gKCkgPT5cbiAgICAgICAgWy4uLnNjYWxlUG9zaXRpb24oKSwgaXNBcmJpdHJhcnlWYXJpYWJsZSwgaXNBcmJpdHJhcnlWYWx1ZV0gYXMgY29uc3RcbiAgICBjb25zdCBzY2FsZU92ZXJmbG93ID0gKCkgPT4gWydhdXRvJywgJ2hpZGRlbicsICdjbGlwJywgJ3Zpc2libGUnLCAnc2Nyb2xsJ10gYXMgY29uc3RcbiAgICBjb25zdCBzY2FsZU92ZXJzY3JvbGwgPSAoKSA9PiBbJ2F1dG8nLCAnY29udGFpbicsICdub25lJ10gYXMgY29uc3RcbiAgICBjb25zdCBzY2FsZVVuYW1iaWd1b3VzU3BhY2luZyA9ICgpID0+XG4gICAgICAgIFtpc0FyYml0cmFyeVZhcmlhYmxlLCBpc0FyYml0cmFyeVZhbHVlLCB0aGVtZVNwYWNpbmddIGFzIGNvbnN0XG4gICAgY29uc3Qgc2NhbGVJbnNldCA9ICgpID0+IFtpc0ZyYWN0aW9uLCAnZnVsbCcsICdhdXRvJywgLi4uc2NhbGVVbmFtYmlndW91c1NwYWNpbmcoKV0gYXMgY29uc3RcbiAgICBjb25zdCBzY2FsZUdyaWRUZW1wbGF0ZUNvbHNSb3dzID0gKCkgPT5cbiAgICAgICAgW2lzSW50ZWdlciwgJ25vbmUnLCAnc3ViZ3JpZCcsIGlzQXJiaXRyYXJ5VmFyaWFibGUsIGlzQXJiaXRyYXJ5VmFsdWVdIGFzIGNvbnN0XG4gICAgY29uc3Qgc2NhbGVHcmlkQ29sUm93U3RhcnRBbmRFbmQgPSAoKSA9PlxuICAgICAgICBbXG4gICAgICAgICAgICAnYXV0bycsXG4gICAgICAgICAgICB7IHNwYW46IFsnZnVsbCcsIGlzSW50ZWdlciwgaXNBcmJpdHJhcnlWYXJpYWJsZSwgaXNBcmJpdHJhcnlWYWx1ZV0gfSxcbiAgICAgICAgICAgIGlzSW50ZWdlcixcbiAgICAgICAgICAgIGlzQXJiaXRyYXJ5VmFyaWFibGUsXG4gICAgICAgICAgICBpc0FyYml0cmFyeVZhbHVlLFxuICAgICAgICBdIGFzIGNvbnN0XG4gICAgY29uc3Qgc2NhbGVHcmlkQ29sUm93U3RhcnRPckVuZCA9ICgpID0+XG4gICAgICAgIFtpc0ludGVnZXIsICdhdXRvJywgaXNBcmJpdHJhcnlWYXJpYWJsZSwgaXNBcmJpdHJhcnlWYWx1ZV0gYXMgY29uc3RcbiAgICBjb25zdCBzY2FsZUdyaWRBdXRvQ29sc1Jvd3MgPSAoKSA9PlxuICAgICAgICBbJ2F1dG8nLCAnbWluJywgJ21heCcsICdmcicsIGlzQXJiaXRyYXJ5VmFyaWFibGUsIGlzQXJiaXRyYXJ5VmFsdWVdIGFzIGNvbnN0XG4gICAgY29uc3Qgc2NhbGVBbGlnblByaW1hcnlBeGlzID0gKCkgPT5cbiAgICAgICAgW1xuICAgICAgICAgICAgJ3N0YXJ0JyxcbiAgICAgICAgICAgICdlbmQnLFxuICAgICAgICAgICAgJ2NlbnRlcicsXG4gICAgICAgICAgICAnYmV0d2VlbicsXG4gICAgICAgICAgICAnYXJvdW5kJyxcbiAgICAgICAgICAgICdldmVubHknLFxuICAgICAgICAgICAgJ3N0cmV0Y2gnLFxuICAgICAgICAgICAgJ2Jhc2VsaW5lJyxcbiAgICAgICAgICAgICdjZW50ZXItc2FmZScsXG4gICAgICAgICAgICAnZW5kLXNhZmUnLFxuICAgICAgICBdIGFzIGNvbnN0XG4gICAgY29uc3Qgc2NhbGVBbGlnblNlY29uZGFyeUF4aXMgPSAoKSA9PlxuICAgICAgICBbJ3N0YXJ0JywgJ2VuZCcsICdjZW50ZXInLCAnc3RyZXRjaCcsICdjZW50ZXItc2FmZScsICdlbmQtc2FmZSddIGFzIGNvbnN0XG4gICAgY29uc3Qgc2NhbGVNYXJnaW4gPSAoKSA9PiBbJ2F1dG8nLCAuLi5zY2FsZVVuYW1iaWd1b3VzU3BhY2luZygpXSBhcyBjb25zdFxuICAgIGNvbnN0IHNjYWxlU2l6aW5nID0gKCkgPT5cbiAgICAgICAgW1xuICAgICAgICAgICAgaXNGcmFjdGlvbixcbiAgICAgICAgICAgICdhdXRvJyxcbiAgICAgICAgICAgICdmdWxsJyxcbiAgICAgICAgICAgICdkdncnLFxuICAgICAgICAgICAgJ2R2aCcsXG4gICAgICAgICAgICAnbHZ3JyxcbiAgICAgICAgICAgICdsdmgnLFxuICAgICAgICAgICAgJ3N2dycsXG4gICAgICAgICAgICAnc3ZoJyxcbiAgICAgICAgICAgICdtaW4nLFxuICAgICAgICAgICAgJ21heCcsXG4gICAgICAgICAgICAnZml0JyxcbiAgICAgICAgICAgIC4uLnNjYWxlVW5hbWJpZ3VvdXNTcGFjaW5nKCksXG4gICAgICAgIF0gYXMgY29uc3RcbiAgICBjb25zdCBzY2FsZUNvbG9yID0gKCkgPT4gW3RoZW1lQ29sb3IsIGlzQXJiaXRyYXJ5VmFyaWFibGUsIGlzQXJiaXRyYXJ5VmFsdWVdIGFzIGNvbnN0XG4gICAgY29uc3Qgc2NhbGVCZ1Bvc2l0aW9uID0gKCkgPT5cbiAgICAgICAgW1xuICAgICAgICAgICAgLi4uc2NhbGVQb3NpdGlvbigpLFxuICAgICAgICAgICAgaXNBcmJpdHJhcnlWYXJpYWJsZVBvc2l0aW9uLFxuICAgICAgICAgICAgaXNBcmJpdHJhcnlQb3NpdGlvbixcbiAgICAgICAgICAgIHsgcG9zaXRpb246IFtpc0FyYml0cmFyeVZhcmlhYmxlLCBpc0FyYml0cmFyeVZhbHVlXSB9LFxuICAgICAgICBdIGFzIGNvbnN0XG4gICAgY29uc3Qgc2NhbGVCZ1JlcGVhdCA9ICgpID0+IFsnbm8tcmVwZWF0JywgeyByZXBlYXQ6IFsnJywgJ3gnLCAneScsICdzcGFjZScsICdyb3VuZCddIH1dIGFzIGNvbnN0XG4gICAgY29uc3Qgc2NhbGVCZ1NpemUgPSAoKSA9PlxuICAgICAgICBbXG4gICAgICAgICAgICAnYXV0bycsXG4gICAgICAgICAgICAnY292ZXInLFxuICAgICAgICAgICAgJ2NvbnRhaW4nLFxuICAgICAgICAgICAgaXNBcmJpdHJhcnlWYXJpYWJsZVNpemUsXG4gICAgICAgICAgICBpc0FyYml0cmFyeVNpemUsXG4gICAgICAgICAgICB7IHNpemU6IFtpc0FyYml0cmFyeVZhcmlhYmxlLCBpc0FyYml0cmFyeVZhbHVlXSB9LFxuICAgICAgICBdIGFzIGNvbnN0XG4gICAgY29uc3Qgc2NhbGVHcmFkaWVudFN0b3BQb3NpdGlvbiA9ICgpID0+XG4gICAgICAgIFtpc1BlcmNlbnQsIGlzQXJiaXRyYXJ5VmFyaWFibGVMZW5ndGgsIGlzQXJiaXRyYXJ5TGVuZ3RoXSBhcyBjb25zdFxuICAgIGNvbnN0IHNjYWxlUmFkaXVzID0gKCkgPT5cbiAgICAgICAgW1xuICAgICAgICAgICAgLy8gRGVwcmVjYXRlZCBzaW5jZSBUYWlsd2luZCBDU1MgdjQuMC4wXG4gICAgICAgICAgICAnJyxcbiAgICAgICAgICAgICdub25lJyxcbiAgICAgICAgICAgICdmdWxsJyxcbiAgICAgICAgICAgIHRoZW1lUmFkaXVzLFxuICAgICAgICAgICAgaXNBcmJpdHJhcnlWYXJpYWJsZSxcbiAgICAgICAgICAgIGlzQXJiaXRyYXJ5VmFsdWUsXG4gICAgICAgIF0gYXMgY29uc3RcbiAgICBjb25zdCBzY2FsZUJvcmRlcldpZHRoID0gKCkgPT5cbiAgICAgICAgWycnLCBpc051bWJlciwgaXNBcmJpdHJhcnlWYXJpYWJsZUxlbmd0aCwgaXNBcmJpdHJhcnlMZW5ndGhdIGFzIGNvbnN0XG4gICAgY29uc3Qgc2NhbGVMaW5lU3R5bGUgPSAoKSA9PiBbJ3NvbGlkJywgJ2Rhc2hlZCcsICdkb3R0ZWQnLCAnZG91YmxlJ10gYXMgY29uc3RcbiAgICBjb25zdCBzY2FsZUJsZW5kTW9kZSA9ICgpID0+XG4gICAgICAgIFtcbiAgICAgICAgICAgICdub3JtYWwnLFxuICAgICAgICAgICAgJ211bHRpcGx5JyxcbiAgICAgICAgICAgICdzY3JlZW4nLFxuICAgICAgICAgICAgJ292ZXJsYXknLFxuICAgICAgICAgICAgJ2RhcmtlbicsXG4gICAgICAgICAgICAnbGlnaHRlbicsXG4gICAgICAgICAgICAnY29sb3ItZG9kZ2UnLFxuICAgICAgICAgICAgJ2NvbG9yLWJ1cm4nLFxuICAgICAgICAgICAgJ2hhcmQtbGlnaHQnLFxuICAgICAgICAgICAgJ3NvZnQtbGlnaHQnLFxuICAgICAgICAgICAgJ2RpZmZlcmVuY2UnLFxuICAgICAgICAgICAgJ2V4Y2x1c2lvbicsXG4gICAgICAgICAgICAnaHVlJyxcbiAgICAgICAgICAgICdzYXR1cmF0aW9uJyxcbiAgICAgICAgICAgICdjb2xvcicsXG4gICAgICAgICAgICAnbHVtaW5vc2l0eScsXG4gICAgICAgIF0gYXMgY29uc3RcbiAgICBjb25zdCBzY2FsZU1hc2tJbWFnZVBvc2l0aW9uID0gKCkgPT5cbiAgICAgICAgW2lzTnVtYmVyLCBpc1BlcmNlbnQsIGlzQXJiaXRyYXJ5VmFyaWFibGVQb3NpdGlvbiwgaXNBcmJpdHJhcnlQb3NpdGlvbl0gYXMgY29uc3RcbiAgICBjb25zdCBzY2FsZUJsdXIgPSAoKSA9PlxuICAgICAgICBbXG4gICAgICAgICAgICAvLyBEZXByZWNhdGVkIHNpbmNlIFRhaWx3aW5kIENTUyB2NC4wLjBcbiAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgJ25vbmUnLFxuICAgICAgICAgICAgdGhlbWVCbHVyLFxuICAgICAgICAgICAgaXNBcmJpdHJhcnlWYXJpYWJsZSxcbiAgICAgICAgICAgIGlzQXJiaXRyYXJ5VmFsdWUsXG4gICAgICAgIF0gYXMgY29uc3RcbiAgICBjb25zdCBzY2FsZVJvdGF0ZSA9ICgpID0+IFsnbm9uZScsIGlzTnVtYmVyLCBpc0FyYml0cmFyeVZhcmlhYmxlLCBpc0FyYml0cmFyeVZhbHVlXSBhcyBjb25zdFxuICAgIGNvbnN0IHNjYWxlU2NhbGUgPSAoKSA9PiBbJ25vbmUnLCBpc051bWJlciwgaXNBcmJpdHJhcnlWYXJpYWJsZSwgaXNBcmJpdHJhcnlWYWx1ZV0gYXMgY29uc3RcbiAgICBjb25zdCBzY2FsZVNrZXcgPSAoKSA9PiBbaXNOdW1iZXIsIGlzQXJiaXRyYXJ5VmFyaWFibGUsIGlzQXJiaXRyYXJ5VmFsdWVdIGFzIGNvbnN0XG4gICAgY29uc3Qgc2NhbGVUcmFuc2xhdGUgPSAoKSA9PiBbaXNGcmFjdGlvbiwgJ2Z1bGwnLCAuLi5zY2FsZVVuYW1iaWd1b3VzU3BhY2luZygpXSBhcyBjb25zdFxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2FjaGVTaXplOiA1MDAsXG4gICAgICAgIHRoZW1lOiB7XG4gICAgICAgICAgICBhbmltYXRlOiBbJ3NwaW4nLCAncGluZycsICdwdWxzZScsICdib3VuY2UnXSxcbiAgICAgICAgICAgIGFzcGVjdDogWyd2aWRlbyddLFxuICAgICAgICAgICAgYmx1cjogW2lzVHNoaXJ0U2l6ZV0sXG4gICAgICAgICAgICBicmVha3BvaW50OiBbaXNUc2hpcnRTaXplXSxcbiAgICAgICAgICAgIGNvbG9yOiBbaXNBbnldLFxuICAgICAgICAgICAgY29udGFpbmVyOiBbaXNUc2hpcnRTaXplXSxcbiAgICAgICAgICAgICdkcm9wLXNoYWRvdyc6IFtpc1RzaGlydFNpemVdLFxuICAgICAgICAgICAgZWFzZTogWydpbicsICdvdXQnLCAnaW4tb3V0J10sXG4gICAgICAgICAgICBmb250OiBbaXNBbnlOb25BcmJpdHJhcnldLFxuICAgICAgICAgICAgJ2ZvbnQtd2VpZ2h0JzogW1xuICAgICAgICAgICAgICAgICd0aGluJyxcbiAgICAgICAgICAgICAgICAnZXh0cmFsaWdodCcsXG4gICAgICAgICAgICAgICAgJ2xpZ2h0JyxcbiAgICAgICAgICAgICAgICAnbm9ybWFsJyxcbiAgICAgICAgICAgICAgICAnbWVkaXVtJyxcbiAgICAgICAgICAgICAgICAnc2VtaWJvbGQnLFxuICAgICAgICAgICAgICAgICdib2xkJyxcbiAgICAgICAgICAgICAgICAnZXh0cmFib2xkJyxcbiAgICAgICAgICAgICAgICAnYmxhY2snLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICdpbnNldC1zaGFkb3cnOiBbaXNUc2hpcnRTaXplXSxcbiAgICAgICAgICAgIGxlYWRpbmc6IFsnbm9uZScsICd0aWdodCcsICdzbnVnJywgJ25vcm1hbCcsICdyZWxheGVkJywgJ2xvb3NlJ10sXG4gICAgICAgICAgICBwZXJzcGVjdGl2ZTogWydkcmFtYXRpYycsICduZWFyJywgJ25vcm1hbCcsICdtaWRyYW5nZScsICdkaXN0YW50JywgJ25vbmUnXSxcbiAgICAgICAgICAgIHJhZGl1czogW2lzVHNoaXJ0U2l6ZV0sXG4gICAgICAgICAgICBzaGFkb3c6IFtpc1RzaGlydFNpemVdLFxuICAgICAgICAgICAgc3BhY2luZzogWydweCcsIGlzTnVtYmVyXSxcbiAgICAgICAgICAgIHRleHQ6IFtpc1RzaGlydFNpemVdLFxuICAgICAgICAgICAgJ3RleHQtc2hhZG93JzogW2lzVHNoaXJ0U2l6ZV0sXG4gICAgICAgICAgICB0cmFja2luZzogWyd0aWdodGVyJywgJ3RpZ2h0JywgJ25vcm1hbCcsICd3aWRlJywgJ3dpZGVyJywgJ3dpZGVzdCddLFxuICAgICAgICB9LFxuICAgICAgICBjbGFzc0dyb3Vwczoge1xuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIC8vIC0tLSBMYXlvdXQgLS0tXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEFzcGVjdCBSYXRpb1xuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2FzcGVjdC1yYXRpb1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBhc3BlY3Q6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGFzcGVjdDogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2F1dG8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3NxdWFyZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZyYWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNBcmJpdHJhcnlWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQXJiaXRyYXJ5VmFyaWFibGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGVtZUFzcGVjdCxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ29udGFpbmVyXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvY29udGFpbmVyXG4gICAgICAgICAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSBUYWlsd2luZCBDU1MgdjQuMC4wXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnRhaW5lcjogWydjb250YWluZXInXSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ29sdW1uc1xuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2NvbHVtbnNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29sdW1uczogW1xuICAgICAgICAgICAgICAgIHsgY29sdW1uczogW2lzTnVtYmVyLCBpc0FyYml0cmFyeVZhbHVlLCBpc0FyYml0cmFyeVZhcmlhYmxlLCB0aGVtZUNvbnRhaW5lcl0gfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEJyZWFrIEFmdGVyXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYnJlYWstYWZ0ZXJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ2JyZWFrLWFmdGVyJzogW3sgJ2JyZWFrLWFmdGVyJzogc2NhbGVCcmVhaygpIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBCcmVhayBCZWZvcmVcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9icmVhay1iZWZvcmVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ2JyZWFrLWJlZm9yZSc6IFt7ICdicmVhay1iZWZvcmUnOiBzY2FsZUJyZWFrKCkgfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEJyZWFrIEluc2lkZVxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JyZWFrLWluc2lkZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnYnJlYWstaW5zaWRlJzogW3sgJ2JyZWFrLWluc2lkZSc6IFsnYXV0bycsICdhdm9pZCcsICdhdm9pZC1wYWdlJywgJ2F2b2lkLWNvbHVtbiddIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBCb3ggRGVjb3JhdGlvbiBCcmVha1xuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JveC1kZWNvcmF0aW9uLWJyZWFrXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdib3gtZGVjb3JhdGlvbic6IFt7ICdib3gtZGVjb3JhdGlvbic6IFsnc2xpY2UnLCAnY2xvbmUnXSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQm94IFNpemluZ1xuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JveC1zaXppbmdcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgYm94OiBbeyBib3g6IFsnYm9yZGVyJywgJ2NvbnRlbnQnXSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRGlzcGxheVxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2Rpc3BsYXlcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZGlzcGxheTogW1xuICAgICAgICAgICAgICAgICdibG9jaycsXG4gICAgICAgICAgICAgICAgJ2lubGluZS1ibG9jaycsXG4gICAgICAgICAgICAgICAgJ2lubGluZScsXG4gICAgICAgICAgICAgICAgJ2ZsZXgnLFxuICAgICAgICAgICAgICAgICdpbmxpbmUtZmxleCcsXG4gICAgICAgICAgICAgICAgJ3RhYmxlJyxcbiAgICAgICAgICAgICAgICAnaW5saW5lLXRhYmxlJyxcbiAgICAgICAgICAgICAgICAndGFibGUtY2FwdGlvbicsXG4gICAgICAgICAgICAgICAgJ3RhYmxlLWNlbGwnLFxuICAgICAgICAgICAgICAgICd0YWJsZS1jb2x1bW4nLFxuICAgICAgICAgICAgICAgICd0YWJsZS1jb2x1bW4tZ3JvdXAnLFxuICAgICAgICAgICAgICAgICd0YWJsZS1mb290ZXItZ3JvdXAnLFxuICAgICAgICAgICAgICAgICd0YWJsZS1oZWFkZXItZ3JvdXAnLFxuICAgICAgICAgICAgICAgICd0YWJsZS1yb3ctZ3JvdXAnLFxuICAgICAgICAgICAgICAgICd0YWJsZS1yb3cnLFxuICAgICAgICAgICAgICAgICdmbG93LXJvb3QnLFxuICAgICAgICAgICAgICAgICdncmlkJyxcbiAgICAgICAgICAgICAgICAnaW5saW5lLWdyaWQnLFxuICAgICAgICAgICAgICAgICdjb250ZW50cycsXG4gICAgICAgICAgICAgICAgJ2xpc3QtaXRlbScsXG4gICAgICAgICAgICAgICAgJ2hpZGRlbicsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTY3JlZW4gUmVhZGVyIE9ubHlcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9kaXNwbGF5I3NjcmVlbi1yZWFkZXItb25seVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzcjogWydzci1vbmx5JywgJ25vdC1zci1vbmx5J10sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEZsb2F0c1xuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2Zsb2F0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZsb2F0OiBbeyBmbG9hdDogWydyaWdodCcsICdsZWZ0JywgJ25vbmUnLCAnc3RhcnQnLCAnZW5kJ10gfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENsZWFyXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvY2xlYXJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY2xlYXI6IFt7IGNsZWFyOiBbJ2xlZnQnLCAncmlnaHQnLCAnYm90aCcsICdub25lJywgJ3N0YXJ0JywgJ2VuZCddIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJc29sYXRpb25cbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9pc29sYXRpb25cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaXNvbGF0aW9uOiBbJ2lzb2xhdGUnLCAnaXNvbGF0aW9uLWF1dG8nXSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogT2JqZWN0IEZpdFxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL29iamVjdC1maXRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ29iamVjdC1maXQnOiBbeyBvYmplY3Q6IFsnY29udGFpbicsICdjb3ZlcicsICdmaWxsJywgJ25vbmUnLCAnc2NhbGUtZG93biddIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBPYmplY3QgUG9zaXRpb25cbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9vYmplY3QtcG9zaXRpb25cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ29iamVjdC1wb3NpdGlvbic6IFt7IG9iamVjdDogc2NhbGVQb3NpdGlvbldpdGhBcmJpdHJhcnkoKSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogT3ZlcmZsb3dcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9vdmVyZmxvd1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBvdmVyZmxvdzogW3sgb3ZlcmZsb3c6IHNjYWxlT3ZlcmZsb3coKSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogT3ZlcmZsb3cgWFxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL292ZXJmbG93XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdvdmVyZmxvdy14JzogW3sgJ292ZXJmbG93LXgnOiBzY2FsZU92ZXJmbG93KCkgfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE92ZXJmbG93IFlcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9vdmVyZmxvd1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnb3ZlcmZsb3cteSc6IFt7ICdvdmVyZmxvdy15Jzogc2NhbGVPdmVyZmxvdygpIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBPdmVyc2Nyb2xsIEJlaGF2aW9yXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvb3ZlcnNjcm9sbC1iZWhhdmlvclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBvdmVyc2Nyb2xsOiBbeyBvdmVyc2Nyb2xsOiBzY2FsZU92ZXJzY3JvbGwoKSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogT3ZlcnNjcm9sbCBCZWhhdmlvciBYXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvb3ZlcnNjcm9sbC1iZWhhdmlvclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnb3ZlcnNjcm9sbC14JzogW3sgJ292ZXJzY3JvbGwteCc6IHNjYWxlT3ZlcnNjcm9sbCgpIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBPdmVyc2Nyb2xsIEJlaGF2aW9yIFlcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9vdmVyc2Nyb2xsLWJlaGF2aW9yXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdvdmVyc2Nyb2xsLXknOiBbeyAnb3ZlcnNjcm9sbC15Jzogc2NhbGVPdmVyc2Nyb2xsKCkgfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFBvc2l0aW9uXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcG9zaXRpb25cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcG9zaXRpb246IFsnc3RhdGljJywgJ2ZpeGVkJywgJ2Fic29sdXRlJywgJ3JlbGF0aXZlJywgJ3N0aWNreSddLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUb3AgLyBSaWdodCAvIEJvdHRvbSAvIExlZnRcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90b3AtcmlnaHQtYm90dG9tLWxlZnRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaW5zZXQ6IFt7IGluc2V0OiBzY2FsZUluc2V0KCkgfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJpZ2h0IC8gTGVmdFxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RvcC1yaWdodC1ib3R0b20tbGVmdFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnaW5zZXQteCc6IFt7ICdpbnNldC14Jzogc2NhbGVJbnNldCgpIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUb3AgLyBCb3R0b21cbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90b3AtcmlnaHQtYm90dG9tLWxlZnRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ2luc2V0LXknOiBbeyAnaW5zZXQteSc6IHNjYWxlSW5zZXQoKSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU3RhcnRcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90b3AtcmlnaHQtYm90dG9tLWxlZnRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc3RhcnQ6IFt7IHN0YXJ0OiBzY2FsZUluc2V0KCkgfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEVuZFxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RvcC1yaWdodC1ib3R0b20tbGVmdFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBlbmQ6IFt7IGVuZDogc2NhbGVJbnNldCgpIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUb3BcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90b3AtcmlnaHQtYm90dG9tLWxlZnRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdG9wOiBbeyB0b3A6IHNjYWxlSW5zZXQoKSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmlnaHRcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90b3AtcmlnaHQtYm90dG9tLWxlZnRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcmlnaHQ6IFt7IHJpZ2h0OiBzY2FsZUluc2V0KCkgfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEJvdHRvbVxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RvcC1yaWdodC1ib3R0b20tbGVmdFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBib3R0b206IFt7IGJvdHRvbTogc2NhbGVJbnNldCgpIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBMZWZ0XG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdG9wLXJpZ2h0LWJvdHRvbS1sZWZ0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGxlZnQ6IFt7IGxlZnQ6IHNjYWxlSW5zZXQoKSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVmlzaWJpbGl0eVxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Zpc2liaWxpdHlcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmlzaWJpbGl0eTogWyd2aXNpYmxlJywgJ2ludmlzaWJsZScsICdjb2xsYXBzZSddLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBaLUluZGV4XG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvei1pbmRleFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB6OiBbeyB6OiBbaXNJbnRlZ2VyLCAnYXV0bycsIGlzQXJiaXRyYXJ5VmFyaWFibGUsIGlzQXJiaXRyYXJ5VmFsdWVdIH1dLFxuXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIC8vIC0tLSBGbGV4Ym94IGFuZCBHcmlkIC0tLVxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRmxleCBCYXNpc1xuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ZsZXgtYmFzaXNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgYmFzaXM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGJhc2lzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZyYWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Z1bGwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2F1dG8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhlbWVDb250YWluZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5zY2FsZVVuYW1iaWd1b3VzU3BhY2luZygpLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBGbGV4IERpcmVjdGlvblxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ZsZXgtZGlyZWN0aW9uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdmbGV4LWRpcmVjdGlvbic6IFt7IGZsZXg6IFsncm93JywgJ3Jvdy1yZXZlcnNlJywgJ2NvbCcsICdjb2wtcmV2ZXJzZSddIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBGbGV4IFdyYXBcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mbGV4LXdyYXBcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ2ZsZXgtd3JhcCc6IFt7IGZsZXg6IFsnbm93cmFwJywgJ3dyYXAnLCAnd3JhcC1yZXZlcnNlJ10gfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEZsZXhcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mbGV4XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZsZXg6IFt7IGZsZXg6IFtpc051bWJlciwgaXNGcmFjdGlvbiwgJ2F1dG8nLCAnaW5pdGlhbCcsICdub25lJywgaXNBcmJpdHJhcnlWYWx1ZV0gfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEZsZXggR3Jvd1xuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ZsZXgtZ3Jvd1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBncm93OiBbeyBncm93OiBbJycsIGlzTnVtYmVyLCBpc0FyYml0cmFyeVZhcmlhYmxlLCBpc0FyYml0cmFyeVZhbHVlXSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRmxleCBTaHJpbmtcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mbGV4LXNocmlua1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzaHJpbms6IFt7IHNocmluazogWycnLCBpc051bWJlciwgaXNBcmJpdHJhcnlWYXJpYWJsZSwgaXNBcmJpdHJhcnlWYWx1ZV0gfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE9yZGVyXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvb3JkZXJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgb3JkZXI6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG9yZGVyOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ludGVnZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZmlyc3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2xhc3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ25vbmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNBcmJpdHJhcnlWYXJpYWJsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQXJiaXRyYXJ5VmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdyaWQgVGVtcGxhdGUgQ29sdW1uc1xuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dyaWQtdGVtcGxhdGUtY29sdW1uc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnZ3JpZC1jb2xzJzogW3sgJ2dyaWQtY29scyc6IHNjYWxlR3JpZFRlbXBsYXRlQ29sc1Jvd3MoKSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR3JpZCBDb2x1bW4gU3RhcnQgLyBFbmRcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ncmlkLWNvbHVtblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnY29sLXN0YXJ0LWVuZCc6IFt7IGNvbDogc2NhbGVHcmlkQ29sUm93U3RhcnRBbmRFbmQoKSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR3JpZCBDb2x1bW4gU3RhcnRcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ncmlkLWNvbHVtblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnY29sLXN0YXJ0JzogW3sgJ2NvbC1zdGFydCc6IHNjYWxlR3JpZENvbFJvd1N0YXJ0T3JFbmQoKSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR3JpZCBDb2x1bW4gRW5kXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZ3JpZC1jb2x1bW5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ2NvbC1lbmQnOiBbeyAnY29sLWVuZCc6IHNjYWxlR3JpZENvbFJvd1N0YXJ0T3JFbmQoKSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR3JpZCBUZW1wbGF0ZSBSb3dzXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZ3JpZC10ZW1wbGF0ZS1yb3dzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdncmlkLXJvd3MnOiBbeyAnZ3JpZC1yb3dzJzogc2NhbGVHcmlkVGVtcGxhdGVDb2xzUm93cygpIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHcmlkIFJvdyBTdGFydCAvIEVuZFxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dyaWQtcm93XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdyb3ctc3RhcnQtZW5kJzogW3sgcm93OiBzY2FsZUdyaWRDb2xSb3dTdGFydEFuZEVuZCgpIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHcmlkIFJvdyBTdGFydFxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dyaWQtcm93XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdyb3ctc3RhcnQnOiBbeyAncm93LXN0YXJ0Jzogc2NhbGVHcmlkQ29sUm93U3RhcnRPckVuZCgpIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHcmlkIFJvdyBFbmRcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ncmlkLXJvd1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAncm93LWVuZCc6IFt7ICdyb3ctZW5kJzogc2NhbGVHcmlkQ29sUm93U3RhcnRPckVuZCgpIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHcmlkIEF1dG8gRmxvd1xuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dyaWQtYXV0by1mbG93XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdncmlkLWZsb3cnOiBbeyAnZ3JpZC1mbG93JzogWydyb3cnLCAnY29sJywgJ2RlbnNlJywgJ3Jvdy1kZW5zZScsICdjb2wtZGVuc2UnXSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR3JpZCBBdXRvIENvbHVtbnNcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ncmlkLWF1dG8tY29sdW1uc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnYXV0by1jb2xzJzogW3sgJ2F1dG8tY29scyc6IHNjYWxlR3JpZEF1dG9Db2xzUm93cygpIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHcmlkIEF1dG8gUm93c1xuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dyaWQtYXV0by1yb3dzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdhdXRvLXJvd3MnOiBbeyAnYXV0by1yb3dzJzogc2NhbGVHcmlkQXV0b0NvbHNSb3dzKCkgfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdhcFxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dhcFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnYXA6IFt7IGdhcDogc2NhbGVVbmFtYmlndW91c1NwYWNpbmcoKSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2FwIFhcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9nYXBcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ2dhcC14JzogW3sgJ2dhcC14Jzogc2NhbGVVbmFtYmlndW91c1NwYWNpbmcoKSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2FwIFlcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9nYXBcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ2dhcC15JzogW3sgJ2dhcC15Jzogc2NhbGVVbmFtYmlndW91c1NwYWNpbmcoKSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSnVzdGlmeSBDb250ZW50XG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvanVzdGlmeS1jb250ZW50XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdqdXN0aWZ5LWNvbnRlbnQnOiBbeyBqdXN0aWZ5OiBbLi4uc2NhbGVBbGlnblByaW1hcnlBeGlzKCksICdub3JtYWwnXSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSnVzdGlmeSBJdGVtc1xuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2p1c3RpZnktaXRlbXNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ2p1c3RpZnktaXRlbXMnOiBbeyAnanVzdGlmeS1pdGVtcyc6IFsuLi5zY2FsZUFsaWduU2Vjb25kYXJ5QXhpcygpLCAnbm9ybWFsJ10gfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEp1c3RpZnkgU2VsZlxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2p1c3RpZnktc2VsZlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnanVzdGlmeS1zZWxmJzogW3sgJ2p1c3RpZnktc2VsZic6IFsnYXV0bycsIC4uLnNjYWxlQWxpZ25TZWNvbmRhcnlBeGlzKCldIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBbGlnbiBDb250ZW50XG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYWxpZ24tY29udGVudFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnYWxpZ24tY29udGVudCc6IFt7IGNvbnRlbnQ6IFsnbm9ybWFsJywgLi4uc2NhbGVBbGlnblByaW1hcnlBeGlzKCldIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBbGlnbiBJdGVtc1xuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2FsaWduLWl0ZW1zXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdhbGlnbi1pdGVtcyc6IFt7IGl0ZW1zOiBbLi4uc2NhbGVBbGlnblNlY29uZGFyeUF4aXMoKSwgeyBiYXNlbGluZTogWycnLCAnbGFzdCddIH1dIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBbGlnbiBTZWxmXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYWxpZ24tc2VsZlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnYWxpZ24tc2VsZic6IFtcbiAgICAgICAgICAgICAgICB7IHNlbGY6IFsnYXV0bycsIC4uLnNjYWxlQWxpZ25TZWNvbmRhcnlBeGlzKCksIHsgYmFzZWxpbmU6IFsnJywgJ2xhc3QnXSB9XSB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUGxhY2UgQ29udGVudFxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3BsYWNlLWNvbnRlbnRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ3BsYWNlLWNvbnRlbnQnOiBbeyAncGxhY2UtY29udGVudCc6IHNjYWxlQWxpZ25QcmltYXJ5QXhpcygpIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBQbGFjZSBJdGVtc1xuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3BsYWNlLWl0ZW1zXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdwbGFjZS1pdGVtcyc6IFt7ICdwbGFjZS1pdGVtcyc6IFsuLi5zY2FsZUFsaWduU2Vjb25kYXJ5QXhpcygpLCAnYmFzZWxpbmUnXSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUGxhY2UgU2VsZlxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3BsYWNlLXNlbGZcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ3BsYWNlLXNlbGYnOiBbeyAncGxhY2Utc2VsZic6IFsnYXV0bycsIC4uLnNjYWxlQWxpZ25TZWNvbmRhcnlBeGlzKCldIH1dLFxuICAgICAgICAgICAgLy8gU3BhY2luZ1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBQYWRkaW5nXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcGFkZGluZ1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBwOiBbeyBwOiBzY2FsZVVuYW1iaWd1b3VzU3BhY2luZygpIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBQYWRkaW5nIFhcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9wYWRkaW5nXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHB4OiBbeyBweDogc2NhbGVVbmFtYmlndW91c1NwYWNpbmcoKSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUGFkZGluZyBZXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcGFkZGluZ1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBweTogW3sgcHk6IHNjYWxlVW5hbWJpZ3VvdXNTcGFjaW5nKCkgfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFBhZGRpbmcgU3RhcnRcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9wYWRkaW5nXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHBzOiBbeyBwczogc2NhbGVVbmFtYmlndW91c1NwYWNpbmcoKSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUGFkZGluZyBFbmRcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9wYWRkaW5nXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHBlOiBbeyBwZTogc2NhbGVVbmFtYmlndW91c1NwYWNpbmcoKSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUGFkZGluZyBUb3BcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9wYWRkaW5nXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHB0OiBbeyBwdDogc2NhbGVVbmFtYmlndW91c1NwYWNpbmcoKSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUGFkZGluZyBSaWdodFxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3BhZGRpbmdcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcHI6IFt7IHByOiBzY2FsZVVuYW1iaWd1b3VzU3BhY2luZygpIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBQYWRkaW5nIEJvdHRvbVxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3BhZGRpbmdcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcGI6IFt7IHBiOiBzY2FsZVVuYW1iaWd1b3VzU3BhY2luZygpIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBQYWRkaW5nIExlZnRcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9wYWRkaW5nXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHBsOiBbeyBwbDogc2NhbGVVbmFtYmlndW91c1NwYWNpbmcoKSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTWFyZ2luXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbWFyZ2luXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIG06IFt7IG06IHNjYWxlTWFyZ2luKCkgfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE1hcmdpbiBYXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbWFyZ2luXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIG14OiBbeyBteDogc2NhbGVNYXJnaW4oKSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTWFyZ2luIFlcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9tYXJnaW5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbXk6IFt7IG15OiBzY2FsZU1hcmdpbigpIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBNYXJnaW4gU3RhcnRcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9tYXJnaW5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbXM6IFt7IG1zOiBzY2FsZU1hcmdpbigpIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBNYXJnaW4gRW5kXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbWFyZ2luXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIG1lOiBbeyBtZTogc2NhbGVNYXJnaW4oKSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTWFyZ2luIFRvcFxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21hcmdpblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBtdDogW3sgbXQ6IHNjYWxlTWFyZ2luKCkgfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE1hcmdpbiBSaWdodFxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21hcmdpblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBtcjogW3sgbXI6IHNjYWxlTWFyZ2luKCkgfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE1hcmdpbiBCb3R0b21cbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9tYXJnaW5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbWI6IFt7IG1iOiBzY2FsZU1hcmdpbigpIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBNYXJnaW4gTGVmdFxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21hcmdpblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBtbDogW3sgbWw6IHNjYWxlTWFyZ2luKCkgfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNwYWNlIEJldHdlZW4gWFxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21hcmdpbiNhZGRpbmctc3BhY2UtYmV0d2Vlbi1jaGlsZHJlblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnc3BhY2UteCc6IFt7ICdzcGFjZS14Jzogc2NhbGVVbmFtYmlndW91c1NwYWNpbmcoKSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU3BhY2UgQmV0d2VlbiBYIFJldmVyc2VcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9tYXJnaW4jYWRkaW5nLXNwYWNlLWJldHdlZW4tY2hpbGRyZW5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ3NwYWNlLXgtcmV2ZXJzZSc6IFsnc3BhY2UteC1yZXZlcnNlJ10sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNwYWNlIEJldHdlZW4gWVxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21hcmdpbiNhZGRpbmctc3BhY2UtYmV0d2Vlbi1jaGlsZHJlblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnc3BhY2UteSc6IFt7ICdzcGFjZS15Jzogc2NhbGVVbmFtYmlndW91c1NwYWNpbmcoKSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU3BhY2UgQmV0d2VlbiBZIFJldmVyc2VcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9tYXJnaW4jYWRkaW5nLXNwYWNlLWJldHdlZW4tY2hpbGRyZW5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ3NwYWNlLXktcmV2ZXJzZSc6IFsnc3BhY2UteS1yZXZlcnNlJ10sXG5cbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICAvLyAtLS0gU2l6aW5nIC0tLVxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTaXplXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvd2lkdGgjc2V0dGluZy1ib3RoLXdpZHRoLWFuZC1oZWlnaHRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc2l6ZTogW3sgc2l6ZTogc2NhbGVTaXppbmcoKSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2lkdGhcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy93aWR0aFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB3OiBbeyB3OiBbdGhlbWVDb250YWluZXIsICdzY3JlZW4nLCAuLi5zY2FsZVNpemluZygpXSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTWluLVdpZHRoXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbWluLXdpZHRoXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdtaW4tdyc6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICdtaW4tdyc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoZW1lQ29udGFpbmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3NjcmVlbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAvKiogRGVwcmVjYXRlZC4gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vdGFpbHdpbmRsYWJzL3RhaWx3aW5kY3NzLmNvbS9pc3N1ZXMvMjAyNyNpc3N1ZWNvbW1lbnQtMjYyMDE1Mjc1NyAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgJ25vbmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uc2NhbGVTaXppbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTWF4LVdpZHRoXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbWF4LXdpZHRoXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdtYXgtdyc6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICdtYXgtdyc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoZW1lQ29udGFpbmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3NjcmVlbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbm9uZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAvKiogRGVwcmVjYXRlZCBzaW5jZSBUYWlsd2luZCBDU1MgdjQuMC4wLiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90YWlsd2luZGxhYnMvdGFpbHdpbmRjc3MuY29tL2lzc3Vlcy8yMDI3I2lzc3VlY29tbWVudC0yNjIwMTUyNzU3ICovXG4gICAgICAgICAgICAgICAgICAgICAgICAncHJvc2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgLyoqIERlcHJlY2F0ZWQgc2luY2UgVGFpbHdpbmQgQ1NTIHY0LjAuMC4gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vdGFpbHdpbmRsYWJzL3RhaWx3aW5kY3NzLmNvbS9pc3N1ZXMvMjAyNyNpc3N1ZWNvbW1lbnQtMjYyMDE1Mjc1NyAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBzY3JlZW46IFt0aGVtZUJyZWFrcG9pbnRdIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5zY2FsZVNpemluZygpLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBIZWlnaHRcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9oZWlnaHRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaDogW3sgaDogWydzY3JlZW4nLCAnbGgnLCAuLi5zY2FsZVNpemluZygpXSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTWluLUhlaWdodFxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21pbi1oZWlnaHRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ21pbi1oJzogW3sgJ21pbi1oJzogWydzY3JlZW4nLCAnbGgnLCAnbm9uZScsIC4uLnNjYWxlU2l6aW5nKCldIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBNYXgtSGVpZ2h0XG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbWF4LWhlaWdodFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnbWF4LWgnOiBbeyAnbWF4LWgnOiBbJ3NjcmVlbicsICdsaCcsIC4uLnNjYWxlU2l6aW5nKCldIH1dLFxuXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIC8vIC0tLSBUeXBvZ3JhcGh5IC0tLVxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRm9udCBTaXplXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZm9udC1zaXplXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdmb250LXNpemUnOiBbXG4gICAgICAgICAgICAgICAgeyB0ZXh0OiBbJ2Jhc2UnLCB0aGVtZVRleHQsIGlzQXJiaXRyYXJ5VmFyaWFibGVMZW5ndGgsIGlzQXJiaXRyYXJ5TGVuZ3RoXSB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRm9udCBTbW9vdGhpbmdcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mb250LXNtb290aGluZ1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnZm9udC1zbW9vdGhpbmcnOiBbJ2FudGlhbGlhc2VkJywgJ3N1YnBpeGVsLWFudGlhbGlhc2VkJ10sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEZvbnQgU3R5bGVcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mb250LXN0eWxlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdmb250LXN0eWxlJzogWydpdGFsaWMnLCAnbm90LWl0YWxpYyddLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBGb250IFdlaWdodFxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ZvbnQtd2VpZ2h0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdmb250LXdlaWdodCc6IFt7IGZvbnQ6IFt0aGVtZUZvbnRXZWlnaHQsIGlzQXJiaXRyYXJ5VmFyaWFibGUsIGlzQXJiaXRyYXJ5TnVtYmVyXSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRm9udCBTdHJldGNoXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZm9udC1zdHJldGNoXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdmb250LXN0cmV0Y2gnOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAnZm9udC1zdHJldGNoJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3VsdHJhLWNvbmRlbnNlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZXh0cmEtY29uZGVuc2VkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjb25kZW5zZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3NlbWktY29uZGVuc2VkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdub3JtYWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3NlbWktZXhwYW5kZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2V4cGFuZGVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdleHRyYS1leHBhbmRlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAndWx0cmEtZXhwYW5kZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNQZXJjZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNBcmJpdHJhcnlWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRm9udCBGYW1pbHlcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mb250LWZhbWlseVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnZm9udC1mYW1pbHknOiBbeyBmb250OiBbaXNBcmJpdHJhcnlWYXJpYWJsZUZhbWlseU5hbWUsIGlzQXJiaXRyYXJ5VmFsdWUsIHRoZW1lRm9udF0gfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEZvbnQgVmFyaWFudCBOdW1lcmljXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZm9udC12YXJpYW50LW51bWVyaWNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ2Z2bi1ub3JtYWwnOiBbJ25vcm1hbC1udW1zJ10sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEZvbnQgVmFyaWFudCBOdW1lcmljXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZm9udC12YXJpYW50LW51bWVyaWNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ2Z2bi1vcmRpbmFsJzogWydvcmRpbmFsJ10sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEZvbnQgVmFyaWFudCBOdW1lcmljXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZm9udC12YXJpYW50LW51bWVyaWNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ2Z2bi1zbGFzaGVkLXplcm8nOiBbJ3NsYXNoZWQtemVybyddLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBGb250IFZhcmlhbnQgTnVtZXJpY1xuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ZvbnQtdmFyaWFudC1udW1lcmljXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdmdm4tZmlndXJlJzogWydsaW5pbmctbnVtcycsICdvbGRzdHlsZS1udW1zJ10sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEZvbnQgVmFyaWFudCBOdW1lcmljXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZm9udC12YXJpYW50LW51bWVyaWNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ2Z2bi1zcGFjaW5nJzogWydwcm9wb3J0aW9uYWwtbnVtcycsICd0YWJ1bGFyLW51bXMnXSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRm9udCBWYXJpYW50IE51bWVyaWNcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mb250LXZhcmlhbnQtbnVtZXJpY1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnZnZuLWZyYWN0aW9uJzogWydkaWFnb25hbC1mcmFjdGlvbnMnLCAnc3RhY2tlZC1mcmFjdGlvbnMnXSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTGV0dGVyIFNwYWNpbmdcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9sZXR0ZXItc3BhY2luZ1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0cmFja2luZzogW3sgdHJhY2tpbmc6IFt0aGVtZVRyYWNraW5nLCBpc0FyYml0cmFyeVZhcmlhYmxlLCBpc0FyYml0cmFyeVZhbHVlXSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTGluZSBDbGFtcFxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2xpbmUtY2xhbXBcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ2xpbmUtY2xhbXAnOiBbXG4gICAgICAgICAgICAgICAgeyAnbGluZS1jbGFtcCc6IFtpc051bWJlciwgJ25vbmUnLCBpc0FyYml0cmFyeVZhcmlhYmxlLCBpc0FyYml0cmFyeU51bWJlcl0gfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIExpbmUgSGVpZ2h0XG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbGluZS1oZWlnaHRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbGVhZGluZzogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbGVhZGluZzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgLyoqIERlcHJlY2F0ZWQgc2luY2UgVGFpbHdpbmQgQ1NTIHY0LjAuMC4gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vdGFpbHdpbmRsYWJzL3RhaWx3aW5kY3NzLmNvbS9pc3N1ZXMvMjAyNyNpc3N1ZWNvbW1lbnQtMjYyMDE1Mjc1NyAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhlbWVMZWFkaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uc2NhbGVVbmFtYmlndW91c1NwYWNpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTGlzdCBTdHlsZSBJbWFnZVxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2xpc3Qtc3R5bGUtaW1hZ2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ2xpc3QtaW1hZ2UnOiBbeyAnbGlzdC1pbWFnZSc6IFsnbm9uZScsIGlzQXJiaXRyYXJ5VmFyaWFibGUsIGlzQXJiaXRyYXJ5VmFsdWVdIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBMaXN0IFN0eWxlIFBvc2l0aW9uXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbGlzdC1zdHlsZS1wb3NpdGlvblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnbGlzdC1zdHlsZS1wb3NpdGlvbic6IFt7IGxpc3Q6IFsnaW5zaWRlJywgJ291dHNpZGUnXSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTGlzdCBTdHlsZSBUeXBlXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbGlzdC1zdHlsZS10eXBlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdsaXN0LXN0eWxlLXR5cGUnOiBbXG4gICAgICAgICAgICAgICAgeyBsaXN0OiBbJ2Rpc2MnLCAnZGVjaW1hbCcsICdub25lJywgaXNBcmJpdHJhcnlWYXJpYWJsZSwgaXNBcmJpdHJhcnlWYWx1ZV0gfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRleHQgQWxpZ25tZW50XG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdGV4dC1hbGlnblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAndGV4dC1hbGlnbm1lbnQnOiBbeyB0ZXh0OiBbJ2xlZnQnLCAnY2VudGVyJywgJ3JpZ2h0JywgJ2p1c3RpZnknLCAnc3RhcnQnLCAnZW5kJ10gfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFBsYWNlaG9sZGVyIENvbG9yXG4gICAgICAgICAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSBUYWlsd2luZCBDU1MgdjMuMC4wXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdjMudGFpbHdpbmRjc3MuY29tL2RvY3MvcGxhY2Vob2xkZXItY29sb3JcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ3BsYWNlaG9sZGVyLWNvbG9yJzogW3sgcGxhY2Vob2xkZXI6IHNjYWxlQ29sb3IoKSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGV4dCBDb2xvclxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RleHQtY29sb3JcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ3RleHQtY29sb3InOiBbeyB0ZXh0OiBzY2FsZUNvbG9yKCkgfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRleHQgRGVjb3JhdGlvblxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RleHQtZGVjb3JhdGlvblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAndGV4dC1kZWNvcmF0aW9uJzogWyd1bmRlcmxpbmUnLCAnb3ZlcmxpbmUnLCAnbGluZS10aHJvdWdoJywgJ25vLXVuZGVybGluZSddLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUZXh0IERlY29yYXRpb24gU3R5bGVcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90ZXh0LWRlY29yYXRpb24tc3R5bGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ3RleHQtZGVjb3JhdGlvbi1zdHlsZSc6IFt7IGRlY29yYXRpb246IFsuLi5zY2FsZUxpbmVTdHlsZSgpLCAnd2F2eSddIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUZXh0IERlY29yYXRpb24gVGhpY2tuZXNzXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdGV4dC1kZWNvcmF0aW9uLXRoaWNrbmVzc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAndGV4dC1kZWNvcmF0aW9uLXRoaWNrbmVzcyc6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGRlY29yYXRpb246IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Zyb20tZm9udCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYXV0bycsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0FyYml0cmFyeVZhcmlhYmxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNBcmJpdHJhcnlMZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRleHQgRGVjb3JhdGlvbiBDb2xvclxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RleHQtZGVjb3JhdGlvbi1jb2xvclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAndGV4dC1kZWNvcmF0aW9uLWNvbG9yJzogW3sgZGVjb3JhdGlvbjogc2NhbGVDb2xvcigpIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUZXh0IFVuZGVybGluZSBPZmZzZXRcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90ZXh0LXVuZGVybGluZS1vZmZzZXRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ3VuZGVybGluZS1vZmZzZXQnOiBbXG4gICAgICAgICAgICAgICAgeyAndW5kZXJsaW5lLW9mZnNldCc6IFtpc051bWJlciwgJ2F1dG8nLCBpc0FyYml0cmFyeVZhcmlhYmxlLCBpc0FyYml0cmFyeVZhbHVlXSB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGV4dCBUcmFuc2Zvcm1cbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90ZXh0LXRyYW5zZm9ybVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAndGV4dC10cmFuc2Zvcm0nOiBbJ3VwcGVyY2FzZScsICdsb3dlcmNhc2UnLCAnY2FwaXRhbGl6ZScsICdub3JtYWwtY2FzZSddLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUZXh0IE92ZXJmbG93XG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdGV4dC1vdmVyZmxvd1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAndGV4dC1vdmVyZmxvdyc6IFsndHJ1bmNhdGUnLCAndGV4dC1lbGxpcHNpcycsICd0ZXh0LWNsaXAnXSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGV4dCBXcmFwXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdGV4dC13cmFwXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICd0ZXh0LXdyYXAnOiBbeyB0ZXh0OiBbJ3dyYXAnLCAnbm93cmFwJywgJ2JhbGFuY2UnLCAncHJldHR5J10gfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRleHQgSW5kZW50XG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdGV4dC1pbmRlbnRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaW5kZW50OiBbeyBpbmRlbnQ6IHNjYWxlVW5hbWJpZ3VvdXNTcGFjaW5nKCkgfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFZlcnRpY2FsIEFsaWdubWVudFxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3ZlcnRpY2FsLWFsaWduXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICd2ZXJ0aWNhbC1hbGlnbic6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGFsaWduOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnYmFzZWxpbmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RvcCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWlkZGxlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdib3R0b20nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RleHQtdG9wJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0ZXh0LWJvdHRvbScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc3ViJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzdXBlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0FyYml0cmFyeVZhcmlhYmxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNBcmJpdHJhcnlWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2hpdGVzcGFjZVxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3doaXRlc3BhY2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgd2hpdGVzcGFjZTogW1xuICAgICAgICAgICAgICAgIHsgd2hpdGVzcGFjZTogWydub3JtYWwnLCAnbm93cmFwJywgJ3ByZScsICdwcmUtbGluZScsICdwcmUtd3JhcCcsICdicmVhay1zcGFjZXMnXSB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV29yZCBCcmVha1xuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3dvcmQtYnJlYWtcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgYnJlYWs6IFt7IGJyZWFrOiBbJ25vcm1hbCcsICd3b3JkcycsICdhbGwnLCAna2VlcCddIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBPdmVyZmxvdyBXcmFwXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvb3ZlcmZsb3ctd3JhcFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB3cmFwOiBbeyB3cmFwOiBbJ2JyZWFrLXdvcmQnLCAnYW55d2hlcmUnLCAnbm9ybWFsJ10gfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEh5cGhlbnNcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9oeXBoZW5zXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGh5cGhlbnM6IFt7IGh5cGhlbnM6IFsnbm9uZScsICdtYW51YWwnLCAnYXV0byddIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDb250ZW50XG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvY29udGVudFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb250ZW50OiBbeyBjb250ZW50OiBbJ25vbmUnLCBpc0FyYml0cmFyeVZhcmlhYmxlLCBpc0FyYml0cmFyeVZhbHVlXSB9XSxcblxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgLy8gLS0tIEJhY2tncm91bmRzIC0tLVxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEJhY2tncm91bmQgQXR0YWNobWVudFxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tncm91bmQtYXR0YWNobWVudFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnYmctYXR0YWNobWVudCc6IFt7IGJnOiBbJ2ZpeGVkJywgJ2xvY2FsJywgJ3Njcm9sbCddIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBCYWNrZ3JvdW5kIENsaXBcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZ3JvdW5kLWNsaXBcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ2JnLWNsaXAnOiBbeyAnYmctY2xpcCc6IFsnYm9yZGVyJywgJ3BhZGRpbmcnLCAnY29udGVudCcsICd0ZXh0J10gfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEJhY2tncm91bmQgT3JpZ2luXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYmFja2dyb3VuZC1vcmlnaW5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ2JnLW9yaWdpbic6IFt7ICdiZy1vcmlnaW4nOiBbJ2JvcmRlcicsICdwYWRkaW5nJywgJ2NvbnRlbnQnXSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQmFja2dyb3VuZCBQb3NpdGlvblxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tncm91bmQtcG9zaXRpb25cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ2JnLXBvc2l0aW9uJzogW3sgYmc6IHNjYWxlQmdQb3NpdGlvbigpIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBCYWNrZ3JvdW5kIFJlcGVhdFxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tncm91bmQtcmVwZWF0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdiZy1yZXBlYXQnOiBbeyBiZzogc2NhbGVCZ1JlcGVhdCgpIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBCYWNrZ3JvdW5kIFNpemVcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZ3JvdW5kLXNpemVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ2JnLXNpemUnOiBbeyBiZzogc2NhbGVCZ1NpemUoKSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQmFja2dyb3VuZCBJbWFnZVxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tncm91bmQtaW1hZ2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ2JnLWltYWdlJzogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYmc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdub25lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lYXI6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyB0bzogWyd0JywgJ3RyJywgJ3InLCAnYnInLCAnYicsICdibCcsICdsJywgJ3RsJ10gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNJbnRlZ2VyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0FyYml0cmFyeVZhcmlhYmxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0FyYml0cmFyeVZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFkaWFsOiBbJycsIGlzQXJiaXRyYXJ5VmFyaWFibGUsIGlzQXJiaXRyYXJ5VmFsdWVdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmljOiBbaXNJbnRlZ2VyLCBpc0FyYml0cmFyeVZhcmlhYmxlLCBpc0FyYml0cmFyeVZhbHVlXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0FyYml0cmFyeVZhcmlhYmxlSW1hZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0FyYml0cmFyeUltYWdlLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBCYWNrZ3JvdW5kIENvbG9yXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYmFja2dyb3VuZC1jb2xvclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnYmctY29sb3InOiBbeyBiZzogc2NhbGVDb2xvcigpIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHcmFkaWVudCBDb2xvciBTdG9wcyBGcm9tIFBvc2l0aW9uXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZ3JhZGllbnQtY29sb3Itc3RvcHNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ2dyYWRpZW50LWZyb20tcG9zJzogW3sgZnJvbTogc2NhbGVHcmFkaWVudFN0b3BQb3NpdGlvbigpIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHcmFkaWVudCBDb2xvciBTdG9wcyBWaWEgUG9zaXRpb25cbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ncmFkaWVudC1jb2xvci1zdG9wc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnZ3JhZGllbnQtdmlhLXBvcyc6IFt7IHZpYTogc2NhbGVHcmFkaWVudFN0b3BQb3NpdGlvbigpIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHcmFkaWVudCBDb2xvciBTdG9wcyBUbyBQb3NpdGlvblxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dyYWRpZW50LWNvbG9yLXN0b3BzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdncmFkaWVudC10by1wb3MnOiBbeyB0bzogc2NhbGVHcmFkaWVudFN0b3BQb3NpdGlvbigpIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHcmFkaWVudCBDb2xvciBTdG9wcyBGcm9tXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZ3JhZGllbnQtY29sb3Itc3RvcHNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ2dyYWRpZW50LWZyb20nOiBbeyBmcm9tOiBzY2FsZUNvbG9yKCkgfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdyYWRpZW50IENvbG9yIFN0b3BzIFZpYVxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dyYWRpZW50LWNvbG9yLXN0b3BzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdncmFkaWVudC12aWEnOiBbeyB2aWE6IHNjYWxlQ29sb3IoKSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR3JhZGllbnQgQ29sb3IgU3RvcHMgVG9cbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ncmFkaWVudC1jb2xvci1zdG9wc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnZ3JhZGllbnQtdG8nOiBbeyB0bzogc2NhbGVDb2xvcigpIH1dLFxuXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIC8vIC0tLSBCb3JkZXJzIC0tLVxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQm9yZGVyIFJhZGl1c1xuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1yYWRpdXNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcm91bmRlZDogW3sgcm91bmRlZDogc2NhbGVSYWRpdXMoKSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQm9yZGVyIFJhZGl1cyBTdGFydFxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1yYWRpdXNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ3JvdW5kZWQtcyc6IFt7ICdyb3VuZGVkLXMnOiBzY2FsZVJhZGl1cygpIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBCb3JkZXIgUmFkaXVzIEVuZFxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1yYWRpdXNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ3JvdW5kZWQtZSc6IFt7ICdyb3VuZGVkLWUnOiBzY2FsZVJhZGl1cygpIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBCb3JkZXIgUmFkaXVzIFRvcFxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1yYWRpdXNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ3JvdW5kZWQtdCc6IFt7ICdyb3VuZGVkLXQnOiBzY2FsZVJhZGl1cygpIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBCb3JkZXIgUmFkaXVzIFJpZ2h0XG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXJhZGl1c1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAncm91bmRlZC1yJzogW3sgJ3JvdW5kZWQtcic6IHNjYWxlUmFkaXVzKCkgfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEJvcmRlciBSYWRpdXMgQm90dG9tXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXJhZGl1c1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAncm91bmRlZC1iJzogW3sgJ3JvdW5kZWQtYic6IHNjYWxlUmFkaXVzKCkgfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEJvcmRlciBSYWRpdXMgTGVmdFxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1yYWRpdXNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ3JvdW5kZWQtbCc6IFt7ICdyb3VuZGVkLWwnOiBzY2FsZVJhZGl1cygpIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBCb3JkZXIgUmFkaXVzIFN0YXJ0IFN0YXJ0XG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXJhZGl1c1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAncm91bmRlZC1zcyc6IFt7ICdyb3VuZGVkLXNzJzogc2NhbGVSYWRpdXMoKSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQm9yZGVyIFJhZGl1cyBTdGFydCBFbmRcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItcmFkaXVzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdyb3VuZGVkLXNlJzogW3sgJ3JvdW5kZWQtc2UnOiBzY2FsZVJhZGl1cygpIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBCb3JkZXIgUmFkaXVzIEVuZCBFbmRcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItcmFkaXVzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdyb3VuZGVkLWVlJzogW3sgJ3JvdW5kZWQtZWUnOiBzY2FsZVJhZGl1cygpIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBCb3JkZXIgUmFkaXVzIEVuZCBTdGFydFxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1yYWRpdXNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ3JvdW5kZWQtZXMnOiBbeyAncm91bmRlZC1lcyc6IHNjYWxlUmFkaXVzKCkgfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEJvcmRlciBSYWRpdXMgVG9wIExlZnRcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItcmFkaXVzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdyb3VuZGVkLXRsJzogW3sgJ3JvdW5kZWQtdGwnOiBzY2FsZVJhZGl1cygpIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBCb3JkZXIgUmFkaXVzIFRvcCBSaWdodFxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1yYWRpdXNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ3JvdW5kZWQtdHInOiBbeyAncm91bmRlZC10cic6IHNjYWxlUmFkaXVzKCkgfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEJvcmRlciBSYWRpdXMgQm90dG9tIFJpZ2h0XG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXJhZGl1c1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAncm91bmRlZC1icic6IFt7ICdyb3VuZGVkLWJyJzogc2NhbGVSYWRpdXMoKSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQm9yZGVyIFJhZGl1cyBCb3R0b20gTGVmdFxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1yYWRpdXNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ3JvdW5kZWQtYmwnOiBbeyAncm91bmRlZC1ibCc6IHNjYWxlUmFkaXVzKCkgfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEJvcmRlciBXaWR0aFxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci13aWR0aFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnYm9yZGVyLXcnOiBbeyBib3JkZXI6IHNjYWxlQm9yZGVyV2lkdGgoKSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQm9yZGVyIFdpZHRoIFhcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItd2lkdGhcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ2JvcmRlci13LXgnOiBbeyAnYm9yZGVyLXgnOiBzY2FsZUJvcmRlcldpZHRoKCkgfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEJvcmRlciBXaWR0aCBZXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXdpZHRoXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdib3JkZXItdy15JzogW3sgJ2JvcmRlci15Jzogc2NhbGVCb3JkZXJXaWR0aCgpIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBCb3JkZXIgV2lkdGggU3RhcnRcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItd2lkdGhcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ2JvcmRlci13LXMnOiBbeyAnYm9yZGVyLXMnOiBzY2FsZUJvcmRlcldpZHRoKCkgfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEJvcmRlciBXaWR0aCBFbmRcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItd2lkdGhcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ2JvcmRlci13LWUnOiBbeyAnYm9yZGVyLWUnOiBzY2FsZUJvcmRlcldpZHRoKCkgfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEJvcmRlciBXaWR0aCBUb3BcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItd2lkdGhcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ2JvcmRlci13LXQnOiBbeyAnYm9yZGVyLXQnOiBzY2FsZUJvcmRlcldpZHRoKCkgfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEJvcmRlciBXaWR0aCBSaWdodFxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci13aWR0aFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnYm9yZGVyLXctcic6IFt7ICdib3JkZXItcic6IHNjYWxlQm9yZGVyV2lkdGgoKSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQm9yZGVyIFdpZHRoIEJvdHRvbVxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci13aWR0aFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnYm9yZGVyLXctYic6IFt7ICdib3JkZXItYic6IHNjYWxlQm9yZGVyV2lkdGgoKSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQm9yZGVyIFdpZHRoIExlZnRcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItd2lkdGhcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ2JvcmRlci13LWwnOiBbeyAnYm9yZGVyLWwnOiBzY2FsZUJvcmRlcldpZHRoKCkgfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIERpdmlkZSBXaWR0aCBYXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXdpZHRoI2JldHdlZW4tY2hpbGRyZW5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ2RpdmlkZS14JzogW3sgJ2RpdmlkZS14Jzogc2NhbGVCb3JkZXJXaWR0aCgpIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEaXZpZGUgV2lkdGggWCBSZXZlcnNlXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXdpZHRoI2JldHdlZW4tY2hpbGRyZW5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ2RpdmlkZS14LXJldmVyc2UnOiBbJ2RpdmlkZS14LXJldmVyc2UnXSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRGl2aWRlIFdpZHRoIFlcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItd2lkdGgjYmV0d2Vlbi1jaGlsZHJlblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnZGl2aWRlLXknOiBbeyAnZGl2aWRlLXknOiBzY2FsZUJvcmRlcldpZHRoKCkgfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIERpdmlkZSBXaWR0aCBZIFJldmVyc2VcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItd2lkdGgjYmV0d2Vlbi1jaGlsZHJlblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnZGl2aWRlLXktcmV2ZXJzZSc6IFsnZGl2aWRlLXktcmV2ZXJzZSddLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBCb3JkZXIgU3R5bGVcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItc3R5bGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ2JvcmRlci1zdHlsZSc6IFt7IGJvcmRlcjogWy4uLnNjYWxlTGluZVN0eWxlKCksICdoaWRkZW4nLCAnbm9uZSddIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEaXZpZGUgU3R5bGVcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItc3R5bGUjc2V0dGluZy10aGUtZGl2aWRlci1zdHlsZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnZGl2aWRlLXN0eWxlJzogW3sgZGl2aWRlOiBbLi4uc2NhbGVMaW5lU3R5bGUoKSwgJ2hpZGRlbicsICdub25lJ10gfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEJvcmRlciBDb2xvclxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1jb2xvclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnYm9yZGVyLWNvbG9yJzogW3sgYm9yZGVyOiBzY2FsZUNvbG9yKCkgfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEJvcmRlciBDb2xvciBYXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLWNvbG9yXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdib3JkZXItY29sb3IteCc6IFt7ICdib3JkZXIteCc6IHNjYWxlQ29sb3IoKSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQm9yZGVyIENvbG9yIFlcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItY29sb3JcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ2JvcmRlci1jb2xvci15JzogW3sgJ2JvcmRlci15Jzogc2NhbGVDb2xvcigpIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBCb3JkZXIgQ29sb3IgU1xuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1jb2xvclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnYm9yZGVyLWNvbG9yLXMnOiBbeyAnYm9yZGVyLXMnOiBzY2FsZUNvbG9yKCkgfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEJvcmRlciBDb2xvciBFXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLWNvbG9yXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdib3JkZXItY29sb3ItZSc6IFt7ICdib3JkZXItZSc6IHNjYWxlQ29sb3IoKSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQm9yZGVyIENvbG9yIFRvcFxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1jb2xvclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnYm9yZGVyLWNvbG9yLXQnOiBbeyAnYm9yZGVyLXQnOiBzY2FsZUNvbG9yKCkgfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEJvcmRlciBDb2xvciBSaWdodFxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1jb2xvclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnYm9yZGVyLWNvbG9yLXInOiBbeyAnYm9yZGVyLXInOiBzY2FsZUNvbG9yKCkgfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEJvcmRlciBDb2xvciBCb3R0b21cbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItY29sb3JcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ2JvcmRlci1jb2xvci1iJzogW3sgJ2JvcmRlci1iJzogc2NhbGVDb2xvcigpIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBCb3JkZXIgQ29sb3IgTGVmdFxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1jb2xvclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnYm9yZGVyLWNvbG9yLWwnOiBbeyAnYm9yZGVyLWwnOiBzY2FsZUNvbG9yKCkgfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIERpdmlkZSBDb2xvclxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2RpdmlkZS1jb2xvclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnZGl2aWRlLWNvbG9yJzogW3sgZGl2aWRlOiBzY2FsZUNvbG9yKCkgfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE91dGxpbmUgU3R5bGVcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9vdXRsaW5lLXN0eWxlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdvdXRsaW5lLXN0eWxlJzogW3sgb3V0bGluZTogWy4uLnNjYWxlTGluZVN0eWxlKCksICdub25lJywgJ2hpZGRlbiddIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBPdXRsaW5lIE9mZnNldFxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL291dGxpbmUtb2Zmc2V0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdvdXRsaW5lLW9mZnNldCc6IFtcbiAgICAgICAgICAgICAgICB7ICdvdXRsaW5lLW9mZnNldCc6IFtpc051bWJlciwgaXNBcmJpdHJhcnlWYXJpYWJsZSwgaXNBcmJpdHJhcnlWYWx1ZV0gfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE91dGxpbmUgV2lkdGhcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9vdXRsaW5lLXdpZHRoXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdvdXRsaW5lLXcnOiBbXG4gICAgICAgICAgICAgICAgeyBvdXRsaW5lOiBbJycsIGlzTnVtYmVyLCBpc0FyYml0cmFyeVZhcmlhYmxlTGVuZ3RoLCBpc0FyYml0cmFyeUxlbmd0aF0gfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE91dGxpbmUgQ29sb3JcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9vdXRsaW5lLWNvbG9yXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdvdXRsaW5lLWNvbG9yJzogW3sgb3V0bGluZTogc2NhbGVDb2xvcigpIH1dLFxuXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIC8vIC0tLSBFZmZlY3RzIC0tLVxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQm94IFNoYWRvd1xuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JveC1zaGFkb3dcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc2hhZG93OiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBzaGFkb3c6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlcHJlY2F0ZWQgc2luY2UgVGFpbHdpbmQgQ1NTIHY0LjAuMFxuICAgICAgICAgICAgICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbm9uZScsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGVtZVNoYWRvdyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQXJiaXRyYXJ5VmFyaWFibGVTaGFkb3csXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0FyYml0cmFyeVNoYWRvdyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQm94IFNoYWRvdyBDb2xvclxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JveC1zaGFkb3cjc2V0dGluZy10aGUtc2hhZG93LWNvbG9yXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdzaGFkb3ctY29sb3InOiBbeyBzaGFkb3c6IHNjYWxlQ29sb3IoKSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSW5zZXQgQm94IFNoYWRvd1xuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JveC1zaGFkb3cjYWRkaW5nLWFuLWluc2V0LXNoYWRvd1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnaW5zZXQtc2hhZG93JzogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgJ2luc2V0LXNoYWRvdyc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdub25lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoZW1lSW5zZXRTaGFkb3csXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0FyYml0cmFyeVZhcmlhYmxlU2hhZG93LFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNBcmJpdHJhcnlTaGFkb3csXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEluc2V0IEJveCBTaGFkb3cgQ29sb3JcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3gtc2hhZG93I3NldHRpbmctdGhlLWluc2V0LXNoYWRvdy1jb2xvclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnaW5zZXQtc2hhZG93LWNvbG9yJzogW3sgJ2luc2V0LXNoYWRvdyc6IHNjYWxlQ29sb3IoKSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmluZyBXaWR0aFxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JveC1zaGFkb3cjYWRkaW5nLWEtcmluZ1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAncmluZy13JzogW3sgcmluZzogc2NhbGVCb3JkZXJXaWR0aCgpIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSaW5nIFdpZHRoIEluc2V0XG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdjMudGFpbHdpbmRjc3MuY29tL2RvY3MvcmluZy13aWR0aCNpbnNldC1yaW5nc1xuICAgICAgICAgICAgICogQGRlcHJlY2F0ZWQgc2luY2UgVGFpbHdpbmQgQ1NTIHY0LjAuMFxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vdGFpbHdpbmRsYWJzL3RhaWx3aW5kY3NzL2Jsb2IvdjQuMC4wL3BhY2thZ2VzL3RhaWx3aW5kY3NzL3NyYy91dGlsaXRpZXMudHMjTDQxNThcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ3Jpbmctdy1pbnNldCc6IFsncmluZy1pbnNldCddLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSaW5nIENvbG9yXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm94LXNoYWRvdyNzZXR0aW5nLXRoZS1yaW5nLWNvbG9yXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdyaW5nLWNvbG9yJzogW3sgcmluZzogc2NhbGVDb2xvcigpIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSaW5nIE9mZnNldCBXaWR0aFxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3YzLnRhaWx3aW5kY3NzLmNvbS9kb2NzL3Jpbmctb2Zmc2V0LXdpZHRoXG4gICAgICAgICAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSBUYWlsd2luZCBDU1MgdjQuMC4wXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90YWlsd2luZGxhYnMvdGFpbHdpbmRjc3MvYmxvYi92NC4wLjAvcGFja2FnZXMvdGFpbHdpbmRjc3Mvc3JjL3V0aWxpdGllcy50cyNMNDE1OFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAncmluZy1vZmZzZXQtdyc6IFt7ICdyaW5nLW9mZnNldCc6IFtpc051bWJlciwgaXNBcmJpdHJhcnlMZW5ndGhdIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSaW5nIE9mZnNldCBDb2xvclxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3YzLnRhaWx3aW5kY3NzLmNvbS9kb2NzL3Jpbmctb2Zmc2V0LWNvbG9yXG4gICAgICAgICAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSBUYWlsd2luZCBDU1MgdjQuMC4wXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90YWlsd2luZGxhYnMvdGFpbHdpbmRjc3MvYmxvYi92NC4wLjAvcGFja2FnZXMvdGFpbHdpbmRjc3Mvc3JjL3V0aWxpdGllcy50cyNMNDE1OFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAncmluZy1vZmZzZXQtY29sb3InOiBbeyAncmluZy1vZmZzZXQnOiBzY2FsZUNvbG9yKCkgfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEluc2V0IFJpbmcgV2lkdGhcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3gtc2hhZG93I2FkZGluZy1hbi1pbnNldC1yaW5nXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdpbnNldC1yaW5nLXcnOiBbeyAnaW5zZXQtcmluZyc6IHNjYWxlQm9yZGVyV2lkdGgoKSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSW5zZXQgUmluZyBDb2xvclxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JveC1zaGFkb3cjc2V0dGluZy10aGUtaW5zZXQtcmluZy1jb2xvclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnaW5zZXQtcmluZy1jb2xvcic6IFt7ICdpbnNldC1yaW5nJzogc2NhbGVDb2xvcigpIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUZXh0IFNoYWRvd1xuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RleHQtc2hhZG93XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICd0ZXh0LXNoYWRvdyc6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICd0ZXh0LXNoYWRvdyc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdub25lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoZW1lVGV4dFNoYWRvdyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQXJiaXRyYXJ5VmFyaWFibGVTaGFkb3csXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0FyYml0cmFyeVNoYWRvdyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGV4dCBTaGFkb3cgQ29sb3JcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90ZXh0LXNoYWRvdyNzZXR0aW5nLXRoZS1zaGFkb3ctY29sb3JcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ3RleHQtc2hhZG93LWNvbG9yJzogW3sgJ3RleHQtc2hhZG93Jzogc2NhbGVDb2xvcigpIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBPcGFjaXR5XG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvb3BhY2l0eVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBvcGFjaXR5OiBbeyBvcGFjaXR5OiBbaXNOdW1iZXIsIGlzQXJiaXRyYXJ5VmFyaWFibGUsIGlzQXJiaXRyYXJ5VmFsdWVdIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBNaXggQmxlbmQgTW9kZVxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21peC1ibGVuZC1tb2RlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdtaXgtYmxlbmQnOiBbeyAnbWl4LWJsZW5kJzogWy4uLnNjYWxlQmxlbmRNb2RlKCksICdwbHVzLWRhcmtlcicsICdwbHVzLWxpZ2h0ZXInXSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQmFja2dyb3VuZCBCbGVuZCBNb2RlXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYmFja2dyb3VuZC1ibGVuZC1tb2RlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdiZy1ibGVuZCc6IFt7ICdiZy1ibGVuZCc6IHNjYWxlQmxlbmRNb2RlKCkgfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE1hc2sgQ2xpcFxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21hc2stY2xpcFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnbWFzay1jbGlwJzogW1xuICAgICAgICAgICAgICAgIHsgJ21hc2stY2xpcCc6IFsnYm9yZGVyJywgJ3BhZGRpbmcnLCAnY29udGVudCcsICdmaWxsJywgJ3N0cm9rZScsICd2aWV3J10gfSxcbiAgICAgICAgICAgICAgICAnbWFzay1uby1jbGlwJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE1hc2sgQ29tcG9zaXRlXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbWFzay1jb21wb3NpdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ21hc2stY29tcG9zaXRlJzogW3sgbWFzazogWydhZGQnLCAnc3VidHJhY3QnLCAnaW50ZXJzZWN0JywgJ2V4Y2x1ZGUnXSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTWFzayBJbWFnZVxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21hc2staW1hZ2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ21hc2staW1hZ2UtbGluZWFyLXBvcyc6IFt7ICdtYXNrLWxpbmVhcic6IFtpc051bWJlcl0gfV0sXG4gICAgICAgICAgICAnbWFzay1pbWFnZS1saW5lYXItZnJvbS1wb3MnOiBbeyAnbWFzay1saW5lYXItZnJvbSc6IHNjYWxlTWFza0ltYWdlUG9zaXRpb24oKSB9XSxcbiAgICAgICAgICAgICdtYXNrLWltYWdlLWxpbmVhci10by1wb3MnOiBbeyAnbWFzay1saW5lYXItdG8nOiBzY2FsZU1hc2tJbWFnZVBvc2l0aW9uKCkgfV0sXG4gICAgICAgICAgICAnbWFzay1pbWFnZS1saW5lYXItZnJvbS1jb2xvcic6IFt7ICdtYXNrLWxpbmVhci1mcm9tJzogc2NhbGVDb2xvcigpIH1dLFxuICAgICAgICAgICAgJ21hc2staW1hZ2UtbGluZWFyLXRvLWNvbG9yJzogW3sgJ21hc2stbGluZWFyLXRvJzogc2NhbGVDb2xvcigpIH1dLFxuICAgICAgICAgICAgJ21hc2staW1hZ2UtdC1mcm9tLXBvcyc6IFt7ICdtYXNrLXQtZnJvbSc6IHNjYWxlTWFza0ltYWdlUG9zaXRpb24oKSB9XSxcbiAgICAgICAgICAgICdtYXNrLWltYWdlLXQtdG8tcG9zJzogW3sgJ21hc2stdC10byc6IHNjYWxlTWFza0ltYWdlUG9zaXRpb24oKSB9XSxcbiAgICAgICAgICAgICdtYXNrLWltYWdlLXQtZnJvbS1jb2xvcic6IFt7ICdtYXNrLXQtZnJvbSc6IHNjYWxlQ29sb3IoKSB9XSxcbiAgICAgICAgICAgICdtYXNrLWltYWdlLXQtdG8tY29sb3InOiBbeyAnbWFzay10LXRvJzogc2NhbGVDb2xvcigpIH1dLFxuICAgICAgICAgICAgJ21hc2staW1hZ2Utci1mcm9tLXBvcyc6IFt7ICdtYXNrLXItZnJvbSc6IHNjYWxlTWFza0ltYWdlUG9zaXRpb24oKSB9XSxcbiAgICAgICAgICAgICdtYXNrLWltYWdlLXItdG8tcG9zJzogW3sgJ21hc2stci10byc6IHNjYWxlTWFza0ltYWdlUG9zaXRpb24oKSB9XSxcbiAgICAgICAgICAgICdtYXNrLWltYWdlLXItZnJvbS1jb2xvcic6IFt7ICdtYXNrLXItZnJvbSc6IHNjYWxlQ29sb3IoKSB9XSxcbiAgICAgICAgICAgICdtYXNrLWltYWdlLXItdG8tY29sb3InOiBbeyAnbWFzay1yLXRvJzogc2NhbGVDb2xvcigpIH1dLFxuICAgICAgICAgICAgJ21hc2staW1hZ2UtYi1mcm9tLXBvcyc6IFt7ICdtYXNrLWItZnJvbSc6IHNjYWxlTWFza0ltYWdlUG9zaXRpb24oKSB9XSxcbiAgICAgICAgICAgICdtYXNrLWltYWdlLWItdG8tcG9zJzogW3sgJ21hc2stYi10byc6IHNjYWxlTWFza0ltYWdlUG9zaXRpb24oKSB9XSxcbiAgICAgICAgICAgICdtYXNrLWltYWdlLWItZnJvbS1jb2xvcic6IFt7ICdtYXNrLWItZnJvbSc6IHNjYWxlQ29sb3IoKSB9XSxcbiAgICAgICAgICAgICdtYXNrLWltYWdlLWItdG8tY29sb3InOiBbeyAnbWFzay1iLXRvJzogc2NhbGVDb2xvcigpIH1dLFxuICAgICAgICAgICAgJ21hc2staW1hZ2UtbC1mcm9tLXBvcyc6IFt7ICdtYXNrLWwtZnJvbSc6IHNjYWxlTWFza0ltYWdlUG9zaXRpb24oKSB9XSxcbiAgICAgICAgICAgICdtYXNrLWltYWdlLWwtdG8tcG9zJzogW3sgJ21hc2stbC10byc6IHNjYWxlTWFza0ltYWdlUG9zaXRpb24oKSB9XSxcbiAgICAgICAgICAgICdtYXNrLWltYWdlLWwtZnJvbS1jb2xvcic6IFt7ICdtYXNrLWwtZnJvbSc6IHNjYWxlQ29sb3IoKSB9XSxcbiAgICAgICAgICAgICdtYXNrLWltYWdlLWwtdG8tY29sb3InOiBbeyAnbWFzay1sLXRvJzogc2NhbGVDb2xvcigpIH1dLFxuICAgICAgICAgICAgJ21hc2staW1hZ2UteC1mcm9tLXBvcyc6IFt7ICdtYXNrLXgtZnJvbSc6IHNjYWxlTWFza0ltYWdlUG9zaXRpb24oKSB9XSxcbiAgICAgICAgICAgICdtYXNrLWltYWdlLXgtdG8tcG9zJzogW3sgJ21hc2steC10byc6IHNjYWxlTWFza0ltYWdlUG9zaXRpb24oKSB9XSxcbiAgICAgICAgICAgICdtYXNrLWltYWdlLXgtZnJvbS1jb2xvcic6IFt7ICdtYXNrLXgtZnJvbSc6IHNjYWxlQ29sb3IoKSB9XSxcbiAgICAgICAgICAgICdtYXNrLWltYWdlLXgtdG8tY29sb3InOiBbeyAnbWFzay14LXRvJzogc2NhbGVDb2xvcigpIH1dLFxuICAgICAgICAgICAgJ21hc2staW1hZ2UteS1mcm9tLXBvcyc6IFt7ICdtYXNrLXktZnJvbSc6IHNjYWxlTWFza0ltYWdlUG9zaXRpb24oKSB9XSxcbiAgICAgICAgICAgICdtYXNrLWltYWdlLXktdG8tcG9zJzogW3sgJ21hc2steS10byc6IHNjYWxlTWFza0ltYWdlUG9zaXRpb24oKSB9XSxcbiAgICAgICAgICAgICdtYXNrLWltYWdlLXktZnJvbS1jb2xvcic6IFt7ICdtYXNrLXktZnJvbSc6IHNjYWxlQ29sb3IoKSB9XSxcbiAgICAgICAgICAgICdtYXNrLWltYWdlLXktdG8tY29sb3InOiBbeyAnbWFzay15LXRvJzogc2NhbGVDb2xvcigpIH1dLFxuICAgICAgICAgICAgJ21hc2staW1hZ2UtcmFkaWFsJzogW3sgJ21hc2stcmFkaWFsJzogW2lzQXJiaXRyYXJ5VmFyaWFibGUsIGlzQXJiaXRyYXJ5VmFsdWVdIH1dLFxuICAgICAgICAgICAgJ21hc2staW1hZ2UtcmFkaWFsLWZyb20tcG9zJzogW3sgJ21hc2stcmFkaWFsLWZyb20nOiBzY2FsZU1hc2tJbWFnZVBvc2l0aW9uKCkgfV0sXG4gICAgICAgICAgICAnbWFzay1pbWFnZS1yYWRpYWwtdG8tcG9zJzogW3sgJ21hc2stcmFkaWFsLXRvJzogc2NhbGVNYXNrSW1hZ2VQb3NpdGlvbigpIH1dLFxuICAgICAgICAgICAgJ21hc2staW1hZ2UtcmFkaWFsLWZyb20tY29sb3InOiBbeyAnbWFzay1yYWRpYWwtZnJvbSc6IHNjYWxlQ29sb3IoKSB9XSxcbiAgICAgICAgICAgICdtYXNrLWltYWdlLXJhZGlhbC10by1jb2xvcic6IFt7ICdtYXNrLXJhZGlhbC10byc6IHNjYWxlQ29sb3IoKSB9XSxcbiAgICAgICAgICAgICdtYXNrLWltYWdlLXJhZGlhbC1zaGFwZSc6IFt7ICdtYXNrLXJhZGlhbCc6IFsnY2lyY2xlJywgJ2VsbGlwc2UnXSB9XSxcbiAgICAgICAgICAgICdtYXNrLWltYWdlLXJhZGlhbC1zaXplJzogW1xuICAgICAgICAgICAgICAgIHsgJ21hc2stcmFkaWFsJzogW3sgY2xvc2VzdDogWydzaWRlJywgJ2Nvcm5lciddLCBmYXJ0aGVzdDogWydzaWRlJywgJ2Nvcm5lciddIH1dIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgJ21hc2staW1hZ2UtcmFkaWFsLXBvcyc6IFt7ICdtYXNrLXJhZGlhbC1hdCc6IHNjYWxlUG9zaXRpb24oKSB9XSxcbiAgICAgICAgICAgICdtYXNrLWltYWdlLWNvbmljLXBvcyc6IFt7ICdtYXNrLWNvbmljJzogW2lzTnVtYmVyXSB9XSxcbiAgICAgICAgICAgICdtYXNrLWltYWdlLWNvbmljLWZyb20tcG9zJzogW3sgJ21hc2stY29uaWMtZnJvbSc6IHNjYWxlTWFza0ltYWdlUG9zaXRpb24oKSB9XSxcbiAgICAgICAgICAgICdtYXNrLWltYWdlLWNvbmljLXRvLXBvcyc6IFt7ICdtYXNrLWNvbmljLXRvJzogc2NhbGVNYXNrSW1hZ2VQb3NpdGlvbigpIH1dLFxuICAgICAgICAgICAgJ21hc2staW1hZ2UtY29uaWMtZnJvbS1jb2xvcic6IFt7ICdtYXNrLWNvbmljLWZyb20nOiBzY2FsZUNvbG9yKCkgfV0sXG4gICAgICAgICAgICAnbWFzay1pbWFnZS1jb25pYy10by1jb2xvcic6IFt7ICdtYXNrLWNvbmljLXRvJzogc2NhbGVDb2xvcigpIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBNYXNrIE1vZGVcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9tYXNrLW1vZGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ21hc2stbW9kZSc6IFt7IG1hc2s6IFsnYWxwaGEnLCAnbHVtaW5hbmNlJywgJ21hdGNoJ10gfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE1hc2sgT3JpZ2luXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbWFzay1vcmlnaW5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ21hc2stb3JpZ2luJzogW1xuICAgICAgICAgICAgICAgIHsgJ21hc2stb3JpZ2luJzogWydib3JkZXInLCAncGFkZGluZycsICdjb250ZW50JywgJ2ZpbGwnLCAnc3Ryb2tlJywgJ3ZpZXcnXSB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTWFzayBQb3NpdGlvblxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21hc2stcG9zaXRpb25cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ21hc2stcG9zaXRpb24nOiBbeyBtYXNrOiBzY2FsZUJnUG9zaXRpb24oKSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTWFzayBSZXBlYXRcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9tYXNrLXJlcGVhdFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnbWFzay1yZXBlYXQnOiBbeyBtYXNrOiBzY2FsZUJnUmVwZWF0KCkgfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE1hc2sgU2l6ZVxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21hc2stc2l6ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnbWFzay1zaXplJzogW3sgbWFzazogc2NhbGVCZ1NpemUoKSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTWFzayBUeXBlXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbWFzay10eXBlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdtYXNrLXR5cGUnOiBbeyAnbWFzay10eXBlJzogWydhbHBoYScsICdsdW1pbmFuY2UnXSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTWFzayBJbWFnZVxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21hc2staW1hZ2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ21hc2staW1hZ2UnOiBbeyBtYXNrOiBbJ25vbmUnLCBpc0FyYml0cmFyeVZhcmlhYmxlLCBpc0FyYml0cmFyeVZhbHVlXSB9XSxcblxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICAvLyAtLS0gRmlsdGVycyAtLS1cbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEZpbHRlclxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ZpbHRlclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmaWx0ZXI6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcjogW1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVwcmVjYXRlZCBzaW5jZSBUYWlsd2luZCBDU1MgdjMuMC4wXG4gICAgICAgICAgICAgICAgICAgICAgICAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdub25lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQXJiaXRyYXJ5VmFyaWFibGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0FyYml0cmFyeVZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBCbHVyXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYmx1clxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBibHVyOiBbeyBibHVyOiBzY2FsZUJsdXIoKSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQnJpZ2h0bmVzc1xuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JyaWdodG5lc3NcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgYnJpZ2h0bmVzczogW3sgYnJpZ2h0bmVzczogW2lzTnVtYmVyLCBpc0FyYml0cmFyeVZhcmlhYmxlLCBpc0FyYml0cmFyeVZhbHVlXSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ29udHJhc3RcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9jb250cmFzdFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb250cmFzdDogW3sgY29udHJhc3Q6IFtpc051bWJlciwgaXNBcmJpdHJhcnlWYXJpYWJsZSwgaXNBcmJpdHJhcnlWYWx1ZV0gfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIERyb3AgU2hhZG93XG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZHJvcC1zaGFkb3dcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ2Ryb3Atc2hhZG93JzogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgJ2Ryb3Atc2hhZG93JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVwcmVjYXRlZCBzaW5jZSBUYWlsd2luZCBDU1MgdjQuMC4wXG4gICAgICAgICAgICAgICAgICAgICAgICAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdub25lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoZW1lRHJvcFNoYWRvdyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQXJiaXRyYXJ5VmFyaWFibGVTaGFkb3csXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0FyYml0cmFyeVNoYWRvdyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRHJvcCBTaGFkb3cgQ29sb3JcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9maWx0ZXItZHJvcC1zaGFkb3cjc2V0dGluZy10aGUtc2hhZG93LWNvbG9yXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdkcm9wLXNoYWRvdy1jb2xvcic6IFt7ICdkcm9wLXNoYWRvdyc6IHNjYWxlQ29sb3IoKSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR3JheXNjYWxlXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZ3JheXNjYWxlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdyYXlzY2FsZTogW3sgZ3JheXNjYWxlOiBbJycsIGlzTnVtYmVyLCBpc0FyYml0cmFyeVZhcmlhYmxlLCBpc0FyYml0cmFyeVZhbHVlXSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSHVlIFJvdGF0ZVxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2h1ZS1yb3RhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ2h1ZS1yb3RhdGUnOiBbeyAnaHVlLXJvdGF0ZSc6IFtpc051bWJlciwgaXNBcmJpdHJhcnlWYXJpYWJsZSwgaXNBcmJpdHJhcnlWYWx1ZV0gfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEludmVydFxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ludmVydFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpbnZlcnQ6IFt7IGludmVydDogWycnLCBpc051bWJlciwgaXNBcmJpdHJhcnlWYXJpYWJsZSwgaXNBcmJpdHJhcnlWYWx1ZV0gfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNhdHVyYXRlXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2F0dXJhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc2F0dXJhdGU6IFt7IHNhdHVyYXRlOiBbaXNOdW1iZXIsIGlzQXJiaXRyYXJ5VmFyaWFibGUsIGlzQXJiaXRyYXJ5VmFsdWVdIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTZXBpYVxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3NlcGlhXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHNlcGlhOiBbeyBzZXBpYTogWycnLCBpc051bWJlciwgaXNBcmJpdHJhcnlWYXJpYWJsZSwgaXNBcmJpdHJhcnlWYWx1ZV0gfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEJhY2tkcm9wIEZpbHRlclxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tkcm9wLWZpbHRlclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnYmFja2Ryb3AtZmlsdGVyJzogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgJ2JhY2tkcm9wLWZpbHRlcic6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlcHJlY2F0ZWQgc2luY2UgVGFpbHdpbmQgQ1NTIHYzLjAuMFxuICAgICAgICAgICAgICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbm9uZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0FyYml0cmFyeVZhcmlhYmxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNBcmJpdHJhcnlWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQmFja2Ryb3AgQmx1clxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tkcm9wLWJsdXJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ2JhY2tkcm9wLWJsdXInOiBbeyAnYmFja2Ryb3AtYmx1cic6IHNjYWxlQmx1cigpIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBCYWNrZHJvcCBCcmlnaHRuZXNzXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYmFja2Ryb3AtYnJpZ2h0bmVzc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnYmFja2Ryb3AtYnJpZ2h0bmVzcyc6IFtcbiAgICAgICAgICAgICAgICB7ICdiYWNrZHJvcC1icmlnaHRuZXNzJzogW2lzTnVtYmVyLCBpc0FyYml0cmFyeVZhcmlhYmxlLCBpc0FyYml0cmFyeVZhbHVlXSB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQmFja2Ryb3AgQ29udHJhc3RcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZHJvcC1jb250cmFzdFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnYmFja2Ryb3AtY29udHJhc3QnOiBbXG4gICAgICAgICAgICAgICAgeyAnYmFja2Ryb3AtY29udHJhc3QnOiBbaXNOdW1iZXIsIGlzQXJiaXRyYXJ5VmFyaWFibGUsIGlzQXJiaXRyYXJ5VmFsdWVdIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBCYWNrZHJvcCBHcmF5c2NhbGVcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZHJvcC1ncmF5c2NhbGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ2JhY2tkcm9wLWdyYXlzY2FsZSc6IFtcbiAgICAgICAgICAgICAgICB7ICdiYWNrZHJvcC1ncmF5c2NhbGUnOiBbJycsIGlzTnVtYmVyLCBpc0FyYml0cmFyeVZhcmlhYmxlLCBpc0FyYml0cmFyeVZhbHVlXSB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQmFja2Ryb3AgSHVlIFJvdGF0ZVxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tkcm9wLWh1ZS1yb3RhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ2JhY2tkcm9wLWh1ZS1yb3RhdGUnOiBbXG4gICAgICAgICAgICAgICAgeyAnYmFja2Ryb3AtaHVlLXJvdGF0ZSc6IFtpc051bWJlciwgaXNBcmJpdHJhcnlWYXJpYWJsZSwgaXNBcmJpdHJhcnlWYWx1ZV0gfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEJhY2tkcm9wIEludmVydFxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tkcm9wLWludmVydFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnYmFja2Ryb3AtaW52ZXJ0JzogW1xuICAgICAgICAgICAgICAgIHsgJ2JhY2tkcm9wLWludmVydCc6IFsnJywgaXNOdW1iZXIsIGlzQXJiaXRyYXJ5VmFyaWFibGUsIGlzQXJiaXRyYXJ5VmFsdWVdIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBCYWNrZHJvcCBPcGFjaXR5XG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYmFja2Ryb3Atb3BhY2l0eVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnYmFja2Ryb3Atb3BhY2l0eSc6IFtcbiAgICAgICAgICAgICAgICB7ICdiYWNrZHJvcC1vcGFjaXR5JzogW2lzTnVtYmVyLCBpc0FyYml0cmFyeVZhcmlhYmxlLCBpc0FyYml0cmFyeVZhbHVlXSB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQmFja2Ryb3AgU2F0dXJhdGVcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZHJvcC1zYXR1cmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnYmFja2Ryb3Atc2F0dXJhdGUnOiBbXG4gICAgICAgICAgICAgICAgeyAnYmFja2Ryb3Atc2F0dXJhdGUnOiBbaXNOdW1iZXIsIGlzQXJiaXRyYXJ5VmFyaWFibGUsIGlzQXJiaXRyYXJ5VmFsdWVdIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBCYWNrZHJvcCBTZXBpYVxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tkcm9wLXNlcGlhXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdiYWNrZHJvcC1zZXBpYSc6IFtcbiAgICAgICAgICAgICAgICB7ICdiYWNrZHJvcC1zZXBpYSc6IFsnJywgaXNOdW1iZXIsIGlzQXJiaXRyYXJ5VmFyaWFibGUsIGlzQXJiaXRyYXJ5VmFsdWVdIH0sXG4gICAgICAgICAgICBdLFxuXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgLy8gLS0tIFRhYmxlcyAtLS1cbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQm9yZGVyIENvbGxhcHNlXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLWNvbGxhcHNlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdib3JkZXItY29sbGFwc2UnOiBbeyBib3JkZXI6IFsnY29sbGFwc2UnLCAnc2VwYXJhdGUnXSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQm9yZGVyIFNwYWNpbmdcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItc3BhY2luZ1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnYm9yZGVyLXNwYWNpbmcnOiBbeyAnYm9yZGVyLXNwYWNpbmcnOiBzY2FsZVVuYW1iaWd1b3VzU3BhY2luZygpIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBCb3JkZXIgU3BhY2luZyBYXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXNwYWNpbmdcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ2JvcmRlci1zcGFjaW5nLXgnOiBbeyAnYm9yZGVyLXNwYWNpbmcteCc6IHNjYWxlVW5hbWJpZ3VvdXNTcGFjaW5nKCkgfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEJvcmRlciBTcGFjaW5nIFlcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItc3BhY2luZ1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnYm9yZGVyLXNwYWNpbmcteSc6IFt7ICdib3JkZXItc3BhY2luZy15Jzogc2NhbGVVbmFtYmlndW91c1NwYWNpbmcoKSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGFibGUgTGF5b3V0XG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdGFibGUtbGF5b3V0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICd0YWJsZS1sYXlvdXQnOiBbeyB0YWJsZTogWydhdXRvJywgJ2ZpeGVkJ10gfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENhcHRpb24gU2lkZVxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2NhcHRpb24tc2lkZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjYXB0aW9uOiBbeyBjYXB0aW9uOiBbJ3RvcCcsICdib3R0b20nXSB9XSxcblxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICAvLyAtLS0gVHJhbnNpdGlvbnMgYW5kIEFuaW1hdGlvbiAtLS1cbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRyYW5zaXRpb24gUHJvcGVydHlcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90cmFuc2l0aW9uLXByb3BlcnR5XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRyYW5zaXRpb246IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb246IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2FsbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnY29sb3JzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcGFjaXR5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzaGFkb3cnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYW5zZm9ybScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbm9uZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0FyYml0cmFyeVZhcmlhYmxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNBcmJpdHJhcnlWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVHJhbnNpdGlvbiBCZWhhdmlvclxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RyYW5zaXRpb24tYmVoYXZpb3JcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ3RyYW5zaXRpb24tYmVoYXZpb3InOiBbeyB0cmFuc2l0aW9uOiBbJ25vcm1hbCcsICdkaXNjcmV0ZSddIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUcmFuc2l0aW9uIER1cmF0aW9uXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdHJhbnNpdGlvbi1kdXJhdGlvblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBkdXJhdGlvbjogW3sgZHVyYXRpb246IFtpc051bWJlciwgJ2luaXRpYWwnLCBpc0FyYml0cmFyeVZhcmlhYmxlLCBpc0FyYml0cmFyeVZhbHVlXSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVHJhbnNpdGlvbiBUaW1pbmcgRnVuY3Rpb25cbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBlYXNlOiBbXG4gICAgICAgICAgICAgICAgeyBlYXNlOiBbJ2xpbmVhcicsICdpbml0aWFsJywgdGhlbWVFYXNlLCBpc0FyYml0cmFyeVZhcmlhYmxlLCBpc0FyYml0cmFyeVZhbHVlXSB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVHJhbnNpdGlvbiBEZWxheVxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RyYW5zaXRpb24tZGVsYXlcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZGVsYXk6IFt7IGRlbGF5OiBbaXNOdW1iZXIsIGlzQXJiaXRyYXJ5VmFyaWFibGUsIGlzQXJiaXRyYXJ5VmFsdWVdIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBbmltYXRpb25cbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9hbmltYXRpb25cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgYW5pbWF0ZTogW3sgYW5pbWF0ZTogWydub25lJywgdGhlbWVBbmltYXRlLCBpc0FyYml0cmFyeVZhcmlhYmxlLCBpc0FyYml0cmFyeVZhbHVlXSB9XSxcblxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICAvLyAtLS0gVHJhbnNmb3JtcyAtLS1cbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEJhY2tmYWNlIFZpc2liaWxpdHlcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZmFjZS12aXNpYmlsaXR5XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGJhY2tmYWNlOiBbeyBiYWNrZmFjZTogWydoaWRkZW4nLCAndmlzaWJsZSddIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBQZXJzcGVjdGl2ZVxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3BlcnNwZWN0aXZlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHBlcnNwZWN0aXZlOiBbXG4gICAgICAgICAgICAgICAgeyBwZXJzcGVjdGl2ZTogW3RoZW1lUGVyc3BlY3RpdmUsIGlzQXJiaXRyYXJ5VmFyaWFibGUsIGlzQXJiaXRyYXJ5VmFsdWVdIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBQZXJzcGVjdGl2ZSBPcmlnaW5cbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9wZXJzcGVjdGl2ZS1vcmlnaW5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ3BlcnNwZWN0aXZlLW9yaWdpbic6IFt7ICdwZXJzcGVjdGl2ZS1vcmlnaW4nOiBzY2FsZVBvc2l0aW9uV2l0aEFyYml0cmFyeSgpIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSb3RhdGVcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9yb3RhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcm90YXRlOiBbeyByb3RhdGU6IHNjYWxlUm90YXRlKCkgfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJvdGF0ZSBYXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvcm90YXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdyb3RhdGUteCc6IFt7ICdyb3RhdGUteCc6IHNjYWxlUm90YXRlKCkgfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJvdGF0ZSBZXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvcm90YXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdyb3RhdGUteSc6IFt7ICdyb3RhdGUteSc6IHNjYWxlUm90YXRlKCkgfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJvdGF0ZSBaXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvcm90YXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdyb3RhdGUteic6IFt7ICdyb3RhdGUteic6IHNjYWxlUm90YXRlKCkgfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNjYWxlXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2NhbGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc2NhbGU6IFt7IHNjYWxlOiBzY2FsZVNjYWxlKCkgfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNjYWxlIFhcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY2FsZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnc2NhbGUteCc6IFt7ICdzY2FsZS14Jzogc2NhbGVTY2FsZSgpIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTY2FsZSBZXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2NhbGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ3NjYWxlLXknOiBbeyAnc2NhbGUteSc6IHNjYWxlU2NhbGUoKSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2NhbGUgWlxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3NjYWxlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdzY2FsZS16JzogW3sgJ3NjYWxlLXonOiBzY2FsZVNjYWxlKCkgfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNjYWxlIDNEXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2NhbGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ3NjYWxlLTNkJzogWydzY2FsZS0zZCddLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTa2V3XG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2tld1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBza2V3OiBbeyBza2V3OiBzY2FsZVNrZXcoKSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2tldyBYXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2tld1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnc2tldy14JzogW3sgJ3NrZXcteCc6IHNjYWxlU2tldygpIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTa2V3IFlcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9za2V3XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdza2V3LXknOiBbeyAnc2tldy15Jzogc2NhbGVTa2V3KCkgfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRyYW5zZm9ybVxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RyYW5zZm9ybVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0cmFuc2Zvcm06IFtcbiAgICAgICAgICAgICAgICB7IHRyYW5zZm9ybTogW2lzQXJiaXRyYXJ5VmFyaWFibGUsIGlzQXJiaXRyYXJ5VmFsdWUsICcnLCAnbm9uZScsICdncHUnLCAnY3B1J10gfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRyYW5zZm9ybSBPcmlnaW5cbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90cmFuc2Zvcm0tb3JpZ2luXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICd0cmFuc2Zvcm0tb3JpZ2luJzogW3sgb3JpZ2luOiBzY2FsZVBvc2l0aW9uV2l0aEFyYml0cmFyeSgpIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUcmFuc2Zvcm0gU3R5bGVcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90cmFuc2Zvcm0tc3R5bGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ3RyYW5zZm9ybS1zdHlsZSc6IFt7IHRyYW5zZm9ybTogWyczZCcsICdmbGF0J10gfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRyYW5zbGF0ZVxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RyYW5zbGF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0cmFuc2xhdGU6IFt7IHRyYW5zbGF0ZTogc2NhbGVUcmFuc2xhdGUoKSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVHJhbnNsYXRlIFhcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90cmFuc2xhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ3RyYW5zbGF0ZS14JzogW3sgJ3RyYW5zbGF0ZS14Jzogc2NhbGVUcmFuc2xhdGUoKSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVHJhbnNsYXRlIFlcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90cmFuc2xhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ3RyYW5zbGF0ZS15JzogW3sgJ3RyYW5zbGF0ZS15Jzogc2NhbGVUcmFuc2xhdGUoKSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVHJhbnNsYXRlIFpcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90cmFuc2xhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ3RyYW5zbGF0ZS16JzogW3sgJ3RyYW5zbGF0ZS16Jzogc2NhbGVUcmFuc2xhdGUoKSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVHJhbnNsYXRlIE5vbmVcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90cmFuc2xhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ3RyYW5zbGF0ZS1ub25lJzogWyd0cmFuc2xhdGUtbm9uZSddLFxuXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIC8vIC0tLSBJbnRlcmFjdGl2aXR5IC0tLVxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQWNjZW50IENvbG9yXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYWNjZW50LWNvbG9yXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGFjY2VudDogW3sgYWNjZW50OiBzY2FsZUNvbG9yKCkgfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEFwcGVhcmFuY2VcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9hcHBlYXJhbmNlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGFwcGVhcmFuY2U6IFt7IGFwcGVhcmFuY2U6IFsnbm9uZScsICdhdXRvJ10gfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENhcmV0IENvbG9yXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvanVzdC1pbi10aW1lLW1vZGUjY2FyZXQtY29sb3ItdXRpbGl0aWVzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdjYXJldC1jb2xvcic6IFt7IGNhcmV0OiBzY2FsZUNvbG9yKCkgfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENvbG9yIFNjaGVtZVxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2NvbG9yLXNjaGVtZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnY29sb3Itc2NoZW1lJzogW1xuICAgICAgICAgICAgICAgIHsgc2NoZW1lOiBbJ25vcm1hbCcsICdkYXJrJywgJ2xpZ2h0JywgJ2xpZ2h0LWRhcmsnLCAnb25seS1kYXJrJywgJ29ubHktbGlnaHQnXSB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ3Vyc29yXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvY3Vyc29yXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGN1cnNvcjogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnYXV0bycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZGVmYXVsdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAncG9pbnRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2FpdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGV4dCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbW92ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnaGVscCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbm90LWFsbG93ZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ25vbmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbnRleHQtbWVudScsXG4gICAgICAgICAgICAgICAgICAgICAgICAncHJvZ3Jlc3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NlbGwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Nyb3NzaGFpcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAndmVydGljYWwtdGV4dCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYWxpYXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NvcHknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ25vLWRyb3AnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dyYWInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dyYWJiaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdhbGwtc2Nyb2xsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjb2wtcmVzaXplJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdyb3ctcmVzaXplJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICduLXJlc2l6ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZS1yZXNpemUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3MtcmVzaXplJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd3LXJlc2l6ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbmUtcmVzaXplJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdudy1yZXNpemUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3NlLXJlc2l6ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc3ctcmVzaXplJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdldy1yZXNpemUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ25zLXJlc2l6ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbmVzdy1yZXNpemUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ253c2UtcmVzaXplJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd6b29tLWluJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd6b29tLW91dCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0FyYml0cmFyeVZhcmlhYmxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNBcmJpdHJhcnlWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRmllbGQgU2l6aW5nXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZmllbGQtc2l6aW5nXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdmaWVsZC1zaXppbmcnOiBbeyAnZmllbGQtc2l6aW5nJzogWydmaXhlZCcsICdjb250ZW50J10gfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFBvaW50ZXIgRXZlbnRzXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcG9pbnRlci1ldmVudHNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ3BvaW50ZXItZXZlbnRzJzogW3sgJ3BvaW50ZXItZXZlbnRzJzogWydhdXRvJywgJ25vbmUnXSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmVzaXplXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcmVzaXplXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHJlc2l6ZTogW3sgcmVzaXplOiBbJ25vbmUnLCAnJywgJ3knLCAneCddIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTY3JvbGwgQmVoYXZpb3JcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtYmVoYXZpb3JcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ3Njcm9sbC1iZWhhdmlvcic6IFt7IHNjcm9sbDogWydhdXRvJywgJ3Ntb290aCddIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTY3JvbGwgTWFyZ2luXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLW1hcmdpblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnc2Nyb2xsLW0nOiBbeyAnc2Nyb2xsLW0nOiBzY2FsZVVuYW1iaWd1b3VzU3BhY2luZygpIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTY3JvbGwgTWFyZ2luIFhcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtbWFyZ2luXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdzY3JvbGwtbXgnOiBbeyAnc2Nyb2xsLW14Jzogc2NhbGVVbmFtYmlndW91c1NwYWNpbmcoKSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2Nyb2xsIE1hcmdpbiBZXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLW1hcmdpblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnc2Nyb2xsLW15JzogW3sgJ3Njcm9sbC1teSc6IHNjYWxlVW5hbWJpZ3VvdXNTcGFjaW5nKCkgfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNjcm9sbCBNYXJnaW4gU3RhcnRcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtbWFyZ2luXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdzY3JvbGwtbXMnOiBbeyAnc2Nyb2xsLW1zJzogc2NhbGVVbmFtYmlndW91c1NwYWNpbmcoKSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2Nyb2xsIE1hcmdpbiBFbmRcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtbWFyZ2luXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdzY3JvbGwtbWUnOiBbeyAnc2Nyb2xsLW1lJzogc2NhbGVVbmFtYmlndW91c1NwYWNpbmcoKSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2Nyb2xsIE1hcmdpbiBUb3BcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtbWFyZ2luXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdzY3JvbGwtbXQnOiBbeyAnc2Nyb2xsLW10Jzogc2NhbGVVbmFtYmlndW91c1NwYWNpbmcoKSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2Nyb2xsIE1hcmdpbiBSaWdodFxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Njcm9sbC1tYXJnaW5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ3Njcm9sbC1tcic6IFt7ICdzY3JvbGwtbXInOiBzY2FsZVVuYW1iaWd1b3VzU3BhY2luZygpIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTY3JvbGwgTWFyZ2luIEJvdHRvbVxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Njcm9sbC1tYXJnaW5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ3Njcm9sbC1tYic6IFt7ICdzY3JvbGwtbWInOiBzY2FsZVVuYW1iaWd1b3VzU3BhY2luZygpIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTY3JvbGwgTWFyZ2luIExlZnRcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtbWFyZ2luXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdzY3JvbGwtbWwnOiBbeyAnc2Nyb2xsLW1sJzogc2NhbGVVbmFtYmlndW91c1NwYWNpbmcoKSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2Nyb2xsIFBhZGRpbmdcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtcGFkZGluZ1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnc2Nyb2xsLXAnOiBbeyAnc2Nyb2xsLXAnOiBzY2FsZVVuYW1iaWd1b3VzU3BhY2luZygpIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTY3JvbGwgUGFkZGluZyBYXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLXBhZGRpbmdcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ3Njcm9sbC1weCc6IFt7ICdzY3JvbGwtcHgnOiBzY2FsZVVuYW1iaWd1b3VzU3BhY2luZygpIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTY3JvbGwgUGFkZGluZyBZXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLXBhZGRpbmdcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ3Njcm9sbC1weSc6IFt7ICdzY3JvbGwtcHknOiBzY2FsZVVuYW1iaWd1b3VzU3BhY2luZygpIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTY3JvbGwgUGFkZGluZyBTdGFydFxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Njcm9sbC1wYWRkaW5nXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdzY3JvbGwtcHMnOiBbeyAnc2Nyb2xsLXBzJzogc2NhbGVVbmFtYmlndW91c1NwYWNpbmcoKSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2Nyb2xsIFBhZGRpbmcgRW5kXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLXBhZGRpbmdcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ3Njcm9sbC1wZSc6IFt7ICdzY3JvbGwtcGUnOiBzY2FsZVVuYW1iaWd1b3VzU3BhY2luZygpIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTY3JvbGwgUGFkZGluZyBUb3BcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtcGFkZGluZ1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnc2Nyb2xsLXB0JzogW3sgJ3Njcm9sbC1wdCc6IHNjYWxlVW5hbWJpZ3VvdXNTcGFjaW5nKCkgfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNjcm9sbCBQYWRkaW5nIFJpZ2h0XG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLXBhZGRpbmdcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ3Njcm9sbC1wcic6IFt7ICdzY3JvbGwtcHInOiBzY2FsZVVuYW1iaWd1b3VzU3BhY2luZygpIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTY3JvbGwgUGFkZGluZyBCb3R0b21cbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtcGFkZGluZ1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnc2Nyb2xsLXBiJzogW3sgJ3Njcm9sbC1wYic6IHNjYWxlVW5hbWJpZ3VvdXNTcGFjaW5nKCkgfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNjcm9sbCBQYWRkaW5nIExlZnRcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtcGFkZGluZ1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnc2Nyb2xsLXBsJzogW3sgJ3Njcm9sbC1wbCc6IHNjYWxlVW5hbWJpZ3VvdXNTcGFjaW5nKCkgfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNjcm9sbCBTbmFwIEFsaWduXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLXNuYXAtYWxpZ25cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ3NuYXAtYWxpZ24nOiBbeyBzbmFwOiBbJ3N0YXJ0JywgJ2VuZCcsICdjZW50ZXInLCAnYWxpZ24tbm9uZSddIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTY3JvbGwgU25hcCBTdG9wXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLXNuYXAtc3RvcFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnc25hcC1zdG9wJzogW3sgc25hcDogWydub3JtYWwnLCAnYWx3YXlzJ10gfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNjcm9sbCBTbmFwIFR5cGVcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtc25hcC10eXBlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdzbmFwLXR5cGUnOiBbeyBzbmFwOiBbJ25vbmUnLCAneCcsICd5JywgJ2JvdGgnXSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2Nyb2xsIFNuYXAgVHlwZSBTdHJpY3RuZXNzXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLXNuYXAtdHlwZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnc25hcC1zdHJpY3RuZXNzJzogW3sgc25hcDogWydtYW5kYXRvcnknLCAncHJveGltaXR5J10gfV0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRvdWNoIEFjdGlvblxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RvdWNoLWFjdGlvblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0b3VjaDogW3sgdG91Y2g6IFsnYXV0bycsICdub25lJywgJ21hbmlwdWxhdGlvbiddIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUb3VjaCBBY3Rpb24gWFxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RvdWNoLWFjdGlvblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAndG91Y2gteCc6IFt7ICd0b3VjaC1wYW4nOiBbJ3gnLCAnbGVmdCcsICdyaWdodCddIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUb3VjaCBBY3Rpb24gWVxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RvdWNoLWFjdGlvblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAndG91Y2gteSc6IFt7ICd0b3VjaC1wYW4nOiBbJ3knLCAndXAnLCAnZG93biddIH1dLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUb3VjaCBBY3Rpb24gUGluY2ggWm9vbVxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RvdWNoLWFjdGlvblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAndG91Y2gtcHonOiBbJ3RvdWNoLXBpbmNoLXpvb20nXSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVXNlciBTZWxlY3RcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy91c2VyLXNlbGVjdFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzZWxlY3Q6IFt7IHNlbGVjdDogWydub25lJywgJ3RleHQnLCAnYWxsJywgJ2F1dG8nXSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2lsbCBDaGFuZ2VcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy93aWxsLWNoYW5nZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnd2lsbC1jaGFuZ2UnOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAnd2lsbC1jaGFuZ2UnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnYXV0bycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc2Nyb2xsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjb250ZW50cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhbnNmb3JtJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQXJiaXRyYXJ5VmFyaWFibGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0FyYml0cmFyeVZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLVxuICAgICAgICAgICAgLy8gLS0tIFNWRyAtLS1cbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRmlsbFxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ZpbGxcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZmlsbDogW3sgZmlsbDogWydub25lJywgLi4uc2NhbGVDb2xvcigpXSB9XSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU3Ryb2tlIFdpZHRoXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc3Ryb2tlLXdpZHRoXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdzdHJva2Utdyc6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZTogW1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0FyYml0cmFyeVZhcmlhYmxlTGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNBcmJpdHJhcnlMZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0FyYml0cmFyeU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU3Ryb2tlXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc3Ryb2tlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHN0cm9rZTogW3sgc3Ryb2tlOiBbJ25vbmUnLCAuLi5zY2FsZUNvbG9yKCldIH1dLFxuXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIC8vIC0tLSBBY2Nlc3NpYmlsaXR5IC0tLVxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRm9yY2VkIENvbG9yIEFkanVzdFxuICAgICAgICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ZvcmNlZC1jb2xvci1hZGp1c3RcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ2ZvcmNlZC1jb2xvci1hZGp1c3QnOiBbeyAnZm9yY2VkLWNvbG9yLWFkanVzdCc6IFsnYXV0bycsICdub25lJ10gfV0sXG4gICAgICAgIH0sXG4gICAgICAgIGNvbmZsaWN0aW5nQ2xhc3NHcm91cHM6IHtcbiAgICAgICAgICAgIG92ZXJmbG93OiBbJ292ZXJmbG93LXgnLCAnb3ZlcmZsb3cteSddLFxuICAgICAgICAgICAgb3ZlcnNjcm9sbDogWydvdmVyc2Nyb2xsLXgnLCAnb3ZlcnNjcm9sbC15J10sXG4gICAgICAgICAgICBpbnNldDogWydpbnNldC14JywgJ2luc2V0LXknLCAnc3RhcnQnLCAnZW5kJywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddLFxuICAgICAgICAgICAgJ2luc2V0LXgnOiBbJ3JpZ2h0JywgJ2xlZnQnXSxcbiAgICAgICAgICAgICdpbnNldC15JzogWyd0b3AnLCAnYm90dG9tJ10sXG4gICAgICAgICAgICBmbGV4OiBbJ2Jhc2lzJywgJ2dyb3cnLCAnc2hyaW5rJ10sXG4gICAgICAgICAgICBnYXA6IFsnZ2FwLXgnLCAnZ2FwLXknXSxcbiAgICAgICAgICAgIHA6IFsncHgnLCAncHknLCAncHMnLCAncGUnLCAncHQnLCAncHInLCAncGInLCAncGwnXSxcbiAgICAgICAgICAgIHB4OiBbJ3ByJywgJ3BsJ10sXG4gICAgICAgICAgICBweTogWydwdCcsICdwYiddLFxuICAgICAgICAgICAgbTogWydteCcsICdteScsICdtcycsICdtZScsICdtdCcsICdtcicsICdtYicsICdtbCddLFxuICAgICAgICAgICAgbXg6IFsnbXInLCAnbWwnXSxcbiAgICAgICAgICAgIG15OiBbJ210JywgJ21iJ10sXG4gICAgICAgICAgICBzaXplOiBbJ3cnLCAnaCddLFxuICAgICAgICAgICAgJ2ZvbnQtc2l6ZSc6IFsnbGVhZGluZyddLFxuICAgICAgICAgICAgJ2Z2bi1ub3JtYWwnOiBbXG4gICAgICAgICAgICAgICAgJ2Z2bi1vcmRpbmFsJyxcbiAgICAgICAgICAgICAgICAnZnZuLXNsYXNoZWQtemVybycsXG4gICAgICAgICAgICAgICAgJ2Z2bi1maWd1cmUnLFxuICAgICAgICAgICAgICAgICdmdm4tc3BhY2luZycsXG4gICAgICAgICAgICAgICAgJ2Z2bi1mcmFjdGlvbicsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgJ2Z2bi1vcmRpbmFsJzogWydmdm4tbm9ybWFsJ10sXG4gICAgICAgICAgICAnZnZuLXNsYXNoZWQtemVybyc6IFsnZnZuLW5vcm1hbCddLFxuICAgICAgICAgICAgJ2Z2bi1maWd1cmUnOiBbJ2Z2bi1ub3JtYWwnXSxcbiAgICAgICAgICAgICdmdm4tc3BhY2luZyc6IFsnZnZuLW5vcm1hbCddLFxuICAgICAgICAgICAgJ2Z2bi1mcmFjdGlvbic6IFsnZnZuLW5vcm1hbCddLFxuICAgICAgICAgICAgJ2xpbmUtY2xhbXAnOiBbJ2Rpc3BsYXknLCAnb3ZlcmZsb3cnXSxcbiAgICAgICAgICAgIHJvdW5kZWQ6IFtcbiAgICAgICAgICAgICAgICAncm91bmRlZC1zJyxcbiAgICAgICAgICAgICAgICAncm91bmRlZC1lJyxcbiAgICAgICAgICAgICAgICAncm91bmRlZC10JyxcbiAgICAgICAgICAgICAgICAncm91bmRlZC1yJyxcbiAgICAgICAgICAgICAgICAncm91bmRlZC1iJyxcbiAgICAgICAgICAgICAgICAncm91bmRlZC1sJyxcbiAgICAgICAgICAgICAgICAncm91bmRlZC1zcycsXG4gICAgICAgICAgICAgICAgJ3JvdW5kZWQtc2UnLFxuICAgICAgICAgICAgICAgICdyb3VuZGVkLWVlJyxcbiAgICAgICAgICAgICAgICAncm91bmRlZC1lcycsXG4gICAgICAgICAgICAgICAgJ3JvdW5kZWQtdGwnLFxuICAgICAgICAgICAgICAgICdyb3VuZGVkLXRyJyxcbiAgICAgICAgICAgICAgICAncm91bmRlZC1icicsXG4gICAgICAgICAgICAgICAgJ3JvdW5kZWQtYmwnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICdyb3VuZGVkLXMnOiBbJ3JvdW5kZWQtc3MnLCAncm91bmRlZC1lcyddLFxuICAgICAgICAgICAgJ3JvdW5kZWQtZSc6IFsncm91bmRlZC1zZScsICdyb3VuZGVkLWVlJ10sXG4gICAgICAgICAgICAncm91bmRlZC10JzogWydyb3VuZGVkLXRsJywgJ3JvdW5kZWQtdHInXSxcbiAgICAgICAgICAgICdyb3VuZGVkLXInOiBbJ3JvdW5kZWQtdHInLCAncm91bmRlZC1iciddLFxuICAgICAgICAgICAgJ3JvdW5kZWQtYic6IFsncm91bmRlZC1icicsICdyb3VuZGVkLWJsJ10sXG4gICAgICAgICAgICAncm91bmRlZC1sJzogWydyb3VuZGVkLXRsJywgJ3JvdW5kZWQtYmwnXSxcbiAgICAgICAgICAgICdib3JkZXItc3BhY2luZyc6IFsnYm9yZGVyLXNwYWNpbmcteCcsICdib3JkZXItc3BhY2luZy15J10sXG4gICAgICAgICAgICAnYm9yZGVyLXcnOiBbXG4gICAgICAgICAgICAgICAgJ2JvcmRlci13LXgnLFxuICAgICAgICAgICAgICAgICdib3JkZXItdy15JyxcbiAgICAgICAgICAgICAgICAnYm9yZGVyLXctcycsXG4gICAgICAgICAgICAgICAgJ2JvcmRlci13LWUnLFxuICAgICAgICAgICAgICAgICdib3JkZXItdy10JyxcbiAgICAgICAgICAgICAgICAnYm9yZGVyLXctcicsXG4gICAgICAgICAgICAgICAgJ2JvcmRlci13LWInLFxuICAgICAgICAgICAgICAgICdib3JkZXItdy1sJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAnYm9yZGVyLXcteCc6IFsnYm9yZGVyLXctcicsICdib3JkZXItdy1sJ10sXG4gICAgICAgICAgICAnYm9yZGVyLXcteSc6IFsnYm9yZGVyLXctdCcsICdib3JkZXItdy1iJ10sXG4gICAgICAgICAgICAnYm9yZGVyLWNvbG9yJzogW1xuICAgICAgICAgICAgICAgICdib3JkZXItY29sb3IteCcsXG4gICAgICAgICAgICAgICAgJ2JvcmRlci1jb2xvci15JyxcbiAgICAgICAgICAgICAgICAnYm9yZGVyLWNvbG9yLXMnLFxuICAgICAgICAgICAgICAgICdib3JkZXItY29sb3ItZScsXG4gICAgICAgICAgICAgICAgJ2JvcmRlci1jb2xvci10JyxcbiAgICAgICAgICAgICAgICAnYm9yZGVyLWNvbG9yLXInLFxuICAgICAgICAgICAgICAgICdib3JkZXItY29sb3ItYicsXG4gICAgICAgICAgICAgICAgJ2JvcmRlci1jb2xvci1sJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAnYm9yZGVyLWNvbG9yLXgnOiBbJ2JvcmRlci1jb2xvci1yJywgJ2JvcmRlci1jb2xvci1sJ10sXG4gICAgICAgICAgICAnYm9yZGVyLWNvbG9yLXknOiBbJ2JvcmRlci1jb2xvci10JywgJ2JvcmRlci1jb2xvci1iJ10sXG4gICAgICAgICAgICB0cmFuc2xhdGU6IFsndHJhbnNsYXRlLXgnLCAndHJhbnNsYXRlLXknLCAndHJhbnNsYXRlLW5vbmUnXSxcbiAgICAgICAgICAgICd0cmFuc2xhdGUtbm9uZSc6IFsndHJhbnNsYXRlJywgJ3RyYW5zbGF0ZS14JywgJ3RyYW5zbGF0ZS15JywgJ3RyYW5zbGF0ZS16J10sXG4gICAgICAgICAgICAnc2Nyb2xsLW0nOiBbXG4gICAgICAgICAgICAgICAgJ3Njcm9sbC1teCcsXG4gICAgICAgICAgICAgICAgJ3Njcm9sbC1teScsXG4gICAgICAgICAgICAgICAgJ3Njcm9sbC1tcycsXG4gICAgICAgICAgICAgICAgJ3Njcm9sbC1tZScsXG4gICAgICAgICAgICAgICAgJ3Njcm9sbC1tdCcsXG4gICAgICAgICAgICAgICAgJ3Njcm9sbC1tcicsXG4gICAgICAgICAgICAgICAgJ3Njcm9sbC1tYicsXG4gICAgICAgICAgICAgICAgJ3Njcm9sbC1tbCcsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgJ3Njcm9sbC1teCc6IFsnc2Nyb2xsLW1yJywgJ3Njcm9sbC1tbCddLFxuICAgICAgICAgICAgJ3Njcm9sbC1teSc6IFsnc2Nyb2xsLW10JywgJ3Njcm9sbC1tYiddLFxuICAgICAgICAgICAgJ3Njcm9sbC1wJzogW1xuICAgICAgICAgICAgICAgICdzY3JvbGwtcHgnLFxuICAgICAgICAgICAgICAgICdzY3JvbGwtcHknLFxuICAgICAgICAgICAgICAgICdzY3JvbGwtcHMnLFxuICAgICAgICAgICAgICAgICdzY3JvbGwtcGUnLFxuICAgICAgICAgICAgICAgICdzY3JvbGwtcHQnLFxuICAgICAgICAgICAgICAgICdzY3JvbGwtcHInLFxuICAgICAgICAgICAgICAgICdzY3JvbGwtcGInLFxuICAgICAgICAgICAgICAgICdzY3JvbGwtcGwnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICdzY3JvbGwtcHgnOiBbJ3Njcm9sbC1wcicsICdzY3JvbGwtcGwnXSxcbiAgICAgICAgICAgICdzY3JvbGwtcHknOiBbJ3Njcm9sbC1wdCcsICdzY3JvbGwtcGInXSxcbiAgICAgICAgICAgIHRvdWNoOiBbJ3RvdWNoLXgnLCAndG91Y2gteScsICd0b3VjaC1weiddLFxuICAgICAgICAgICAgJ3RvdWNoLXgnOiBbJ3RvdWNoJ10sXG4gICAgICAgICAgICAndG91Y2gteSc6IFsndG91Y2gnXSxcbiAgICAgICAgICAgICd0b3VjaC1weic6IFsndG91Y2gnXSxcbiAgICAgICAgfSxcbiAgICAgICAgY29uZmxpY3RpbmdDbGFzc0dyb3VwTW9kaWZpZXJzOiB7XG4gICAgICAgICAgICAnZm9udC1zaXplJzogWydsZWFkaW5nJ10sXG4gICAgICAgIH0sXG4gICAgICAgIG9yZGVyU2Vuc2l0aXZlTW9kaWZpZXJzOiBbXG4gICAgICAgICAgICAnKicsXG4gICAgICAgICAgICAnKionLFxuICAgICAgICAgICAgJ2FmdGVyJyxcbiAgICAgICAgICAgICdiYWNrZHJvcCcsXG4gICAgICAgICAgICAnYmVmb3JlJyxcbiAgICAgICAgICAgICdkZXRhaWxzLWNvbnRlbnQnLFxuICAgICAgICAgICAgJ2ZpbGUnLFxuICAgICAgICAgICAgJ2ZpcnN0LWxldHRlcicsXG4gICAgICAgICAgICAnZmlyc3QtbGluZScsXG4gICAgICAgICAgICAnbWFya2VyJyxcbiAgICAgICAgICAgICdwbGFjZWhvbGRlcicsXG4gICAgICAgICAgICAnc2VsZWN0aW9uJyxcbiAgICAgICAgXSxcbiAgICB9IGFzIGNvbnN0IHNhdGlzZmllcyBDb25maWc8RGVmYXVsdENsYXNzR3JvdXBJZHMsIERlZmF1bHRUaGVtZUdyb3VwSWRzPlxufVxuIiwiaW1wb3J0IHsgQW55Q29uZmlnLCBDb25maWdFeHRlbnNpb24sIE5vSW5mZXIgfSBmcm9tICcuL3R5cGVzJ1xuXG4vKipcbiAqIEBwYXJhbSBiYXNlQ29uZmlnIENvbmZpZyB3aGVyZSBvdGhlciBjb25maWcgd2lsbCBiZSBtZXJnZWQgaW50by4gVGhpcyBvYmplY3Qgd2lsbCBiZSBtdXRhdGVkLlxuICogQHBhcmFtIGNvbmZpZ0V4dGVuc2lvbiBQYXJ0aWFsIGNvbmZpZyB0byBtZXJnZSBpbnRvIHRoZSBgYmFzZUNvbmZpZ2AuXG4gKi9cbmV4cG9ydCBjb25zdCBtZXJnZUNvbmZpZ3MgPSA8Q2xhc3NHcm91cElkcyBleHRlbmRzIHN0cmluZywgVGhlbWVHcm91cElkcyBleHRlbmRzIHN0cmluZyA9IG5ldmVyPihcbiAgICBiYXNlQ29uZmlnOiBBbnlDb25maWcsXG4gICAge1xuICAgICAgICBjYWNoZVNpemUsXG4gICAgICAgIHByZWZpeCxcbiAgICAgICAgZXhwZXJpbWVudGFsUGFyc2VDbGFzc05hbWUsXG4gICAgICAgIGV4dGVuZCA9IHt9LFxuICAgICAgICBvdmVycmlkZSA9IHt9LFxuICAgIH06IENvbmZpZ0V4dGVuc2lvbjxDbGFzc0dyb3VwSWRzLCBUaGVtZUdyb3VwSWRzPixcbikgPT4ge1xuICAgIG92ZXJyaWRlUHJvcGVydHkoYmFzZUNvbmZpZywgJ2NhY2hlU2l6ZScsIGNhY2hlU2l6ZSlcbiAgICBvdmVycmlkZVByb3BlcnR5KGJhc2VDb25maWcsICdwcmVmaXgnLCBwcmVmaXgpXG4gICAgb3ZlcnJpZGVQcm9wZXJ0eShiYXNlQ29uZmlnLCAnZXhwZXJpbWVudGFsUGFyc2VDbGFzc05hbWUnLCBleHBlcmltZW50YWxQYXJzZUNsYXNzTmFtZSlcblxuICAgIG92ZXJyaWRlQ29uZmlnUHJvcGVydGllcyhiYXNlQ29uZmlnLnRoZW1lLCBvdmVycmlkZS50aGVtZSlcbiAgICBvdmVycmlkZUNvbmZpZ1Byb3BlcnRpZXMoYmFzZUNvbmZpZy5jbGFzc0dyb3Vwcywgb3ZlcnJpZGUuY2xhc3NHcm91cHMpXG4gICAgb3ZlcnJpZGVDb25maWdQcm9wZXJ0aWVzKGJhc2VDb25maWcuY29uZmxpY3RpbmdDbGFzc0dyb3Vwcywgb3ZlcnJpZGUuY29uZmxpY3RpbmdDbGFzc0dyb3VwcylcbiAgICBvdmVycmlkZUNvbmZpZ1Byb3BlcnRpZXMoXG4gICAgICAgIGJhc2VDb25maWcuY29uZmxpY3RpbmdDbGFzc0dyb3VwTW9kaWZpZXJzLFxuICAgICAgICBvdmVycmlkZS5jb25mbGljdGluZ0NsYXNzR3JvdXBNb2RpZmllcnMsXG4gICAgKVxuICAgIG92ZXJyaWRlUHJvcGVydHkoYmFzZUNvbmZpZywgJ29yZGVyU2Vuc2l0aXZlTW9kaWZpZXJzJywgb3ZlcnJpZGUub3JkZXJTZW5zaXRpdmVNb2RpZmllcnMpXG5cbiAgICBtZXJnZUNvbmZpZ1Byb3BlcnRpZXMoYmFzZUNvbmZpZy50aGVtZSwgZXh0ZW5kLnRoZW1lKVxuICAgIG1lcmdlQ29uZmlnUHJvcGVydGllcyhiYXNlQ29uZmlnLmNsYXNzR3JvdXBzLCBleHRlbmQuY2xhc3NHcm91cHMpXG4gICAgbWVyZ2VDb25maWdQcm9wZXJ0aWVzKGJhc2VDb25maWcuY29uZmxpY3RpbmdDbGFzc0dyb3VwcywgZXh0ZW5kLmNvbmZsaWN0aW5nQ2xhc3NHcm91cHMpXG4gICAgbWVyZ2VDb25maWdQcm9wZXJ0aWVzKFxuICAgICAgICBiYXNlQ29uZmlnLmNvbmZsaWN0aW5nQ2xhc3NHcm91cE1vZGlmaWVycyxcbiAgICAgICAgZXh0ZW5kLmNvbmZsaWN0aW5nQ2xhc3NHcm91cE1vZGlmaWVycyxcbiAgICApXG4gICAgbWVyZ2VBcnJheVByb3BlcnRpZXMoYmFzZUNvbmZpZywgZXh0ZW5kLCAnb3JkZXJTZW5zaXRpdmVNb2RpZmllcnMnKVxuXG4gICAgcmV0dXJuIGJhc2VDb25maWdcbn1cblxuY29uc3Qgb3ZlcnJpZGVQcm9wZXJ0eSA9IDxUIGV4dGVuZHMgb2JqZWN0LCBLIGV4dGVuZHMga2V5b2YgVD4oXG4gICAgYmFzZU9iamVjdDogVCxcbiAgICBvdmVycmlkZUtleTogSyxcbiAgICBvdmVycmlkZVZhbHVlOiBUW0tdIHwgdW5kZWZpbmVkLFxuKSA9PiB7XG4gICAgaWYgKG92ZXJyaWRlVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBiYXNlT2JqZWN0W292ZXJyaWRlS2V5XSA9IG92ZXJyaWRlVmFsdWVcbiAgICB9XG59XG5cbmNvbnN0IG92ZXJyaWRlQ29uZmlnUHJvcGVydGllcyA9IChcbiAgICBiYXNlT2JqZWN0OiBQYXJ0aWFsPFJlY29yZDxzdHJpbmcsIHJlYWRvbmx5IHVua25vd25bXT4+LFxuICAgIG92ZXJyaWRlT2JqZWN0OiBQYXJ0aWFsPFJlY29yZDxzdHJpbmcsIHJlYWRvbmx5IHVua25vd25bXT4+IHwgdW5kZWZpbmVkLFxuKSA9PiB7XG4gICAgaWYgKG92ZXJyaWRlT2JqZWN0KSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG92ZXJyaWRlT2JqZWN0KSB7XG4gICAgICAgICAgICBvdmVycmlkZVByb3BlcnR5KGJhc2VPYmplY3QsIGtleSwgb3ZlcnJpZGVPYmplY3Rba2V5XSlcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgbWVyZ2VDb25maWdQcm9wZXJ0aWVzID0gKFxuICAgIGJhc2VPYmplY3Q6IFBhcnRpYWw8UmVjb3JkPHN0cmluZywgcmVhZG9ubHkgdW5rbm93bltdPj4sXG4gICAgbWVyZ2VPYmplY3Q6IFBhcnRpYWw8UmVjb3JkPHN0cmluZywgcmVhZG9ubHkgdW5rbm93bltdPj4gfCB1bmRlZmluZWQsXG4pID0+IHtcbiAgICBpZiAobWVyZ2VPYmplY3QpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbWVyZ2VPYmplY3QpIHtcbiAgICAgICAgICAgIG1lcmdlQXJyYXlQcm9wZXJ0aWVzKGJhc2VPYmplY3QsIG1lcmdlT2JqZWN0LCBrZXkpXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNvbnN0IG1lcmdlQXJyYXlQcm9wZXJ0aWVzID0gPEtleSBleHRlbmRzIHN0cmluZz4oXG4gICAgYmFzZU9iamVjdDogUGFydGlhbDxSZWNvcmQ8Tm9JbmZlcjxLZXk+LCByZWFkb25seSB1bmtub3duW10+PixcbiAgICBtZXJnZU9iamVjdDogUGFydGlhbDxSZWNvcmQ8Tm9JbmZlcjxLZXk+LCByZWFkb25seSB1bmtub3duW10+PixcbiAgICBrZXk6IEtleSxcbikgPT4ge1xuICAgIGNvbnN0IG1lcmdlVmFsdWUgPSBtZXJnZU9iamVjdFtrZXldXG5cbiAgICBpZiAobWVyZ2VWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGJhc2VPYmplY3Rba2V5XSA9IGJhc2VPYmplY3Rba2V5XSA/IGJhc2VPYmplY3Rba2V5XS5jb25jYXQobWVyZ2VWYWx1ZSkgOiBtZXJnZVZhbHVlXG4gICAgfVxufVxuIiwiaW1wb3J0IHsgY3JlYXRlVGFpbHdpbmRNZXJnZSB9IGZyb20gJy4vY3JlYXRlLXRhaWx3aW5kLW1lcmdlJ1xuaW1wb3J0IHsgZ2V0RGVmYXVsdENvbmZpZyB9IGZyb20gJy4vZGVmYXVsdC1jb25maWcnXG5pbXBvcnQgeyBtZXJnZUNvbmZpZ3MgfSBmcm9tICcuL21lcmdlLWNvbmZpZ3MnXG5pbXBvcnQgeyBBbnlDb25maWcsIENvbmZpZ0V4dGVuc2lvbiwgRGVmYXVsdENsYXNzR3JvdXBJZHMsIERlZmF1bHRUaGVtZUdyb3VwSWRzIH0gZnJvbSAnLi90eXBlcydcblxudHlwZSBDcmVhdGVDb25maWdTdWJzZXF1ZW50ID0gKGNvbmZpZzogQW55Q29uZmlnKSA9PiBBbnlDb25maWdcblxuZXhwb3J0IGNvbnN0IGV4dGVuZFRhaWx3aW5kTWVyZ2UgPSA8XG4gICAgQWRkaXRpb25hbENsYXNzR3JvdXBJZHMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbiAgICBBZGRpdGlvbmFsVGhlbWVHcm91cElkcyBleHRlbmRzIHN0cmluZyA9IG5ldmVyLFxuPihcbiAgICBjb25maWdFeHRlbnNpb246XG4gICAgICAgIHwgQ29uZmlnRXh0ZW5zaW9uPFxuICAgICAgICAgICAgICBEZWZhdWx0Q2xhc3NHcm91cElkcyB8IEFkZGl0aW9uYWxDbGFzc0dyb3VwSWRzLFxuICAgICAgICAgICAgICBEZWZhdWx0VGhlbWVHcm91cElkcyB8IEFkZGl0aW9uYWxUaGVtZUdyb3VwSWRzXG4gICAgICAgICAgPlxuICAgICAgICB8IENyZWF0ZUNvbmZpZ1N1YnNlcXVlbnQsXG4gICAgLi4uY3JlYXRlQ29uZmlnOiBDcmVhdGVDb25maWdTdWJzZXF1ZW50W11cbikgPT5cbiAgICB0eXBlb2YgY29uZmlnRXh0ZW5zaW9uID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gY3JlYXRlVGFpbHdpbmRNZXJnZShnZXREZWZhdWx0Q29uZmlnLCBjb25maWdFeHRlbnNpb24sIC4uLmNyZWF0ZUNvbmZpZylcbiAgICAgICAgOiBjcmVhdGVUYWlsd2luZE1lcmdlKFxuICAgICAgICAgICAgICAoKSA9PiBtZXJnZUNvbmZpZ3MoZ2V0RGVmYXVsdENvbmZpZygpLCBjb25maWdFeHRlbnNpb24pLFxuICAgICAgICAgICAgICAuLi5jcmVhdGVDb25maWcsXG4gICAgICAgICAgKVxuIiwiaW1wb3J0IHsgY3JlYXRlVGFpbHdpbmRNZXJnZSB9IGZyb20gJy4vY3JlYXRlLXRhaWx3aW5kLW1lcmdlJ1xuaW1wb3J0IHsgZ2V0RGVmYXVsdENvbmZpZyB9IGZyb20gJy4vZGVmYXVsdC1jb25maWcnXG5cbmV4cG9ydCBjb25zdCB0d01lcmdlID0gY3JlYXRlVGFpbHdpbmRNZXJnZShnZXREZWZhdWx0Q29uZmlnKVxuIl0sIm5hbWVzIjpbIkNMQVNTX1BBUlRfU0VQQVJBVE9SIiwiY3JlYXRlQ2xhc3NHcm91cFV0aWxzIiwiY29uZmlnIiwiY2xhc3NNYXAiLCJjcmVhdGVDbGFzc01hcCIsImNvbmZsaWN0aW5nQ2xhc3NHcm91cHMiLCJjb25mbGljdGluZ0NsYXNzR3JvdXBNb2RpZmllcnMiLCJnZXRDbGFzc0dyb3VwSWQiLCJjbGFzc05hbWUiLCJjbGFzc1BhcnRzIiwic3BsaXQiLCJsZW5ndGgiLCJzaGlmdCIsImdldEdyb3VwUmVjdXJzaXZlIiwiZ2V0R3JvdXBJZEZvckFyYml0cmFyeVByb3BlcnR5IiwiZ2V0Q29uZmxpY3RpbmdDbGFzc0dyb3VwSWRzIiwiY2xhc3NHcm91cElkIiwiaGFzUG9zdGZpeE1vZGlmaWVyIiwiY29uZmxpY3RzIiwiY2xhc3NQYXJ0T2JqZWN0IiwiY3VycmVudENsYXNzUGFydCIsIm5leHRDbGFzc1BhcnRPYmplY3QiLCJuZXh0UGFydCIsImdldCIsImNsYXNzR3JvdXBGcm9tTmV4dENsYXNzUGFydCIsInNsaWNlIiwidW5kZWZpbmVkIiwidmFsaWRhdG9ycyIsImNsYXNzUmVzdCIsImpvaW4iLCJmaW5kIiwidmFsaWRhdG9yIiwiYXJiaXRyYXJ5UHJvcGVydHlSZWdleCIsInRlc3QiLCJhcmJpdHJhcnlQcm9wZXJ0eUNsYXNzTmFtZSIsImV4ZWMiLCJwcm9wZXJ0eSIsInN1YnN0cmluZyIsImluZGV4T2YiLCJ0aGVtZSIsImNsYXNzR3JvdXBzIiwiTWFwIiwicHJvY2Vzc0NsYXNzZXNSZWN1cnNpdmVseSIsImNsYXNzR3JvdXAiLCJmb3JFYWNoIiwiY2xhc3NEZWZpbml0aW9uIiwiY2xhc3NQYXJ0T2JqZWN0VG9FZGl0IiwiZ2V0UGFydCIsImlzVGhlbWVHZXR0ZXIiLCJwdXNoIiwiT2JqZWN0IiwiZW50cmllcyIsImtleSIsInBhdGgiLCJjdXJyZW50Q2xhc3NQYXJ0T2JqZWN0IiwicGF0aFBhcnQiLCJoYXMiLCJzZXQiLCJmdW5jIiwiY3JlYXRlTHJ1Q2FjaGUiLCJtYXhDYWNoZVNpemUiLCJjYWNoZVNpemUiLCJjYWNoZSIsInByZXZpb3VzQ2FjaGUiLCJ1cGRhdGUiLCJ2YWx1ZSIsIklNUE9SVEFOVF9NT0RJRklFUiIsIk1PRElGSUVSX1NFUEFSQVRPUiIsIk1PRElGSUVSX1NFUEFSQVRPUl9MRU5HVEgiLCJjcmVhdGVQYXJzZUNsYXNzTmFtZSIsInByZWZpeCIsImV4cGVyaW1lbnRhbFBhcnNlQ2xhc3NOYW1lIiwicGFyc2VDbGFzc05hbWUiLCJtb2RpZmllcnMiLCJicmFja2V0RGVwdGgiLCJwYXJlbkRlcHRoIiwibW9kaWZpZXJTdGFydCIsInBvc3RmaXhNb2RpZmllclBvc2l0aW9uIiwiaW5kZXgiLCJjdXJyZW50Q2hhcmFjdGVyIiwiYmFzZUNsYXNzTmFtZVdpdGhJbXBvcnRhbnRNb2RpZmllciIsImJhc2VDbGFzc05hbWUiLCJzdHJpcEltcG9ydGFudE1vZGlmaWVyIiwiaGFzSW1wb3J0YW50TW9kaWZpZXIiLCJtYXliZVBvc3RmaXhNb2RpZmllclBvc2l0aW9uIiwiZnVsbFByZWZpeCIsInBhcnNlQ2xhc3NOYW1lT3JpZ2luYWwiLCJzdGFydHNXaXRoIiwiaXNFeHRlcm5hbCIsImVuZHNXaXRoIiwiY3JlYXRlU29ydE1vZGlmaWVycyIsIm9yZGVyU2Vuc2l0aXZlTW9kaWZpZXJzIiwiZnJvbUVudHJpZXMiLCJtYXAiLCJtb2RpZmllciIsInNvcnRNb2RpZmllcnMiLCJzb3J0ZWRNb2RpZmllcnMiLCJ1bnNvcnRlZE1vZGlmaWVycyIsImlzUG9zaXRpb25TZW5zaXRpdmUiLCJzb3J0IiwiY3JlYXRlQ29uZmlnVXRpbHMiLCJTUExJVF9DTEFTU0VTX1JFR0VYIiwibWVyZ2VDbGFzc0xpc3QiLCJjbGFzc0xpc3QiLCJjb25maWdVdGlscyIsImNsYXNzR3JvdXBzSW5Db25mbGljdCIsImNsYXNzTmFtZXMiLCJ0cmltIiwicmVzdWx0Iiwib3JpZ2luYWxDbGFzc05hbWUiLCJ2YXJpYW50TW9kaWZpZXIiLCJtb2RpZmllcklkIiwiY2xhc3NJZCIsImluY2x1ZGVzIiwiY29uZmxpY3RHcm91cHMiLCJpIiwiZ3JvdXAiLCJ0d0pvaW4iLCJhcmd1bWVudCIsInJlc29sdmVkVmFsdWUiLCJzdHJpbmciLCJhcmd1bWVudHMiLCJ0b1ZhbHVlIiwibWl4IiwiayIsImNyZWF0ZVRhaWx3aW5kTWVyZ2UiLCJjcmVhdGVDb25maWdGaXJzdCIsImNyZWF0ZUNvbmZpZ1Jlc3QiLCJjYWNoZUdldCIsImNhY2hlU2V0IiwiZnVuY3Rpb25Ub0NhbGwiLCJpbml0VGFpbHdpbmRNZXJnZSIsInJlZHVjZSIsInByZXZpb3VzQ29uZmlnIiwiY3JlYXRlQ29uZmlnQ3VycmVudCIsInRhaWx3aW5kTWVyZ2UiLCJjYWNoZWRSZXN1bHQiLCJjYWxsVGFpbHdpbmRNZXJnZSIsImFwcGx5IiwiZnJvbVRoZW1lIiwidGhlbWVHZXR0ZXIiLCJhcmJpdHJhcnlWYWx1ZVJlZ2V4IiwiYXJiaXRyYXJ5VmFyaWFibGVSZWdleCIsImZyYWN0aW9uUmVnZXgiLCJ0c2hpcnRVbml0UmVnZXgiLCJsZW5ndGhVbml0UmVnZXgiLCJjb2xvckZ1bmN0aW9uUmVnZXgiLCJzaGFkb3dSZWdleCIsImltYWdlUmVnZXgiLCJpc0ZyYWN0aW9uIiwiaXNOdW1iZXIiLCJOdW1iZXIiLCJpc05hTiIsImlzSW50ZWdlciIsImlzUGVyY2VudCIsImlzVHNoaXJ0U2l6ZSIsImlzQW55IiwiaXNMZW5ndGhPbmx5IiwiaXNOZXZlciIsImlzU2hhZG93IiwiaXNJbWFnZSIsImlzQW55Tm9uQXJiaXRyYXJ5IiwiaXNBcmJpdHJhcnlWYWx1ZSIsImlzQXJiaXRyYXJ5VmFyaWFibGUiLCJpc0FyYml0cmFyeVNpemUiLCJnZXRJc0FyYml0cmFyeVZhbHVlIiwiaXNMYWJlbFNpemUiLCJpc0FyYml0cmFyeUxlbmd0aCIsImlzTGFiZWxMZW5ndGgiLCJpc0FyYml0cmFyeU51bWJlciIsImlzTGFiZWxOdW1iZXIiLCJpc0FyYml0cmFyeVBvc2l0aW9uIiwiaXNMYWJlbFBvc2l0aW9uIiwiaXNBcmJpdHJhcnlJbWFnZSIsImlzTGFiZWxJbWFnZSIsImlzQXJiaXRyYXJ5U2hhZG93IiwiaXNMYWJlbFNoYWRvdyIsImlzQXJiaXRyYXJ5VmFyaWFibGVMZW5ndGgiLCJnZXRJc0FyYml0cmFyeVZhcmlhYmxlIiwiaXNBcmJpdHJhcnlWYXJpYWJsZUZhbWlseU5hbWUiLCJpc0xhYmVsRmFtaWx5TmFtZSIsImlzQXJiaXRyYXJ5VmFyaWFibGVQb3NpdGlvbiIsImlzQXJiaXRyYXJ5VmFyaWFibGVTaXplIiwiaXNBcmJpdHJhcnlWYXJpYWJsZUltYWdlIiwiaXNBcmJpdHJhcnlWYXJpYWJsZVNoYWRvdyIsInRlc3RMYWJlbCIsInRlc3RWYWx1ZSIsInNob3VsZE1hdGNoTm9MYWJlbCIsImxhYmVsIiwiZ2V0RGVmYXVsdENvbmZpZyIsInRoZW1lQ29sb3IiLCJ0aGVtZUZvbnQiLCJ0aGVtZVRleHQiLCJ0aGVtZUZvbnRXZWlnaHQiLCJ0aGVtZVRyYWNraW5nIiwidGhlbWVMZWFkaW5nIiwidGhlbWVCcmVha3BvaW50IiwidGhlbWVDb250YWluZXIiLCJ0aGVtZVNwYWNpbmciLCJ0aGVtZVJhZGl1cyIsInRoZW1lU2hhZG93IiwidGhlbWVJbnNldFNoYWRvdyIsInRoZW1lVGV4dFNoYWRvdyIsInRoZW1lRHJvcFNoYWRvdyIsInRoZW1lQmx1ciIsInRoZW1lUGVyc3BlY3RpdmUiLCJ0aGVtZUFzcGVjdCIsInRoZW1lRWFzZSIsInRoZW1lQW5pbWF0ZSIsInNjYWxlQnJlYWsiLCJzY2FsZVBvc2l0aW9uIiwic2NhbGVQb3NpdGlvbldpdGhBcmJpdHJhcnkiLCJzY2FsZU92ZXJmbG93Iiwic2NhbGVPdmVyc2Nyb2xsIiwic2NhbGVVbmFtYmlndW91c1NwYWNpbmciLCJzY2FsZUluc2V0Iiwic2NhbGVHcmlkVGVtcGxhdGVDb2xzUm93cyIsInNjYWxlR3JpZENvbFJvd1N0YXJ0QW5kRW5kIiwic3BhbiIsInNjYWxlR3JpZENvbFJvd1N0YXJ0T3JFbmQiLCJzY2FsZUdyaWRBdXRvQ29sc1Jvd3MiLCJzY2FsZUFsaWduUHJpbWFyeUF4aXMiLCJzY2FsZUFsaWduU2Vjb25kYXJ5QXhpcyIsInNjYWxlTWFyZ2luIiwic2NhbGVTaXppbmciLCJzY2FsZUNvbG9yIiwic2NhbGVCZ1Bvc2l0aW9uIiwicG9zaXRpb24iLCJzY2FsZUJnUmVwZWF0IiwicmVwZWF0Iiwic2NhbGVCZ1NpemUiLCJzaXplIiwic2NhbGVHcmFkaWVudFN0b3BQb3NpdGlvbiIsInNjYWxlUmFkaXVzIiwic2NhbGVCb3JkZXJXaWR0aCIsInNjYWxlTGluZVN0eWxlIiwic2NhbGVCbGVuZE1vZGUiLCJzY2FsZU1hc2tJbWFnZVBvc2l0aW9uIiwic2NhbGVCbHVyIiwic2NhbGVSb3RhdGUiLCJzY2FsZVNjYWxlIiwic2NhbGVTa2V3Iiwic2NhbGVUcmFuc2xhdGUiLCJhbmltYXRlIiwiYXNwZWN0IiwiYmx1ciIsImJyZWFrcG9pbnQiLCJjb2xvciIsImNvbnRhaW5lciIsImVhc2UiLCJmb250IiwibGVhZGluZyIsInBlcnNwZWN0aXZlIiwicmFkaXVzIiwic2hhZG93Iiwic3BhY2luZyIsInRleHQiLCJ0cmFja2luZyIsImNvbHVtbnMiLCJib3giLCJkaXNwbGF5Iiwic3IiLCJmbG9hdCIsImNsZWFyIiwiaXNvbGF0aW9uIiwib2JqZWN0Iiwib3ZlcmZsb3ciLCJvdmVyc2Nyb2xsIiwiaW5zZXQiLCJzdGFydCIsImVuZCIsInRvcCIsInJpZ2h0IiwiYm90dG9tIiwibGVmdCIsInZpc2liaWxpdHkiLCJ6IiwiYmFzaXMiLCJmbGV4IiwiZ3JvdyIsInNocmluayIsIm9yZGVyIiwiY29sIiwicm93IiwiZ2FwIiwianVzdGlmeSIsImNvbnRlbnQiLCJpdGVtcyIsImJhc2VsaW5lIiwic2VsZiIsInAiLCJweCIsInB5IiwicHMiLCJwZSIsInB0IiwicHIiLCJwYiIsInBsIiwibSIsIm14IiwibXkiLCJtcyIsIm1lIiwibXQiLCJtciIsIm1iIiwibWwiLCJ3Iiwic2NyZWVuIiwiaCIsImxpc3QiLCJwbGFjZWhvbGRlciIsImRlY29yYXRpb24iLCJpbmRlbnQiLCJhbGlnbiIsIndoaXRlc3BhY2UiLCJicmVhayIsIndyYXAiLCJoeXBoZW5zIiwiYmciLCJsaW5lYXIiLCJ0byIsInJhZGlhbCIsImNvbmljIiwiZnJvbSIsInZpYSIsInJvdW5kZWQiLCJib3JkZXIiLCJkaXZpZGUiLCJvdXRsaW5lIiwicmluZyIsIm9wYWNpdHkiLCJtYXNrIiwiY2xvc2VzdCIsImZhcnRoZXN0IiwiZmlsdGVyIiwiYnJpZ2h0bmVzcyIsImNvbnRyYXN0IiwiZ3JheXNjYWxlIiwiaW52ZXJ0Iiwic2F0dXJhdGUiLCJzZXBpYSIsInRhYmxlIiwiY2FwdGlvbiIsInRyYW5zaXRpb24iLCJkdXJhdGlvbiIsImRlbGF5IiwiYmFja2ZhY2UiLCJyb3RhdGUiLCJzY2FsZSIsInNrZXciLCJ0cmFuc2Zvcm0iLCJvcmlnaW4iLCJ0cmFuc2xhdGUiLCJhY2NlbnQiLCJhcHBlYXJhbmNlIiwiY2FyZXQiLCJzY2hlbWUiLCJjdXJzb3IiLCJyZXNpemUiLCJzY3JvbGwiLCJzbmFwIiwidG91Y2giLCJzZWxlY3QiLCJmaWxsIiwic3Ryb2tlIiwibWVyZ2VDb25maWdzIiwiYmFzZUNvbmZpZyIsImV4dGVuZCIsIm92ZXJyaWRlIiwib3ZlcnJpZGVQcm9wZXJ0eSIsIm92ZXJyaWRlQ29uZmlnUHJvcGVydGllcyIsIm1lcmdlQ29uZmlnUHJvcGVydGllcyIsIm1lcmdlQXJyYXlQcm9wZXJ0aWVzIiwiYmFzZU9iamVjdCIsIm92ZXJyaWRlS2V5Iiwib3ZlcnJpZGVWYWx1ZSIsIm92ZXJyaWRlT2JqZWN0IiwibWVyZ2VPYmplY3QiLCJtZXJnZVZhbHVlIiwiY29uY2F0IiwiZXh0ZW5kVGFpbHdpbmRNZXJnZSIsImNvbmZpZ0V4dGVuc2lvbiIsImNyZWF0ZUNvbmZpZyIsInR3TWVyZ2UiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFzQkEsTUFBTUEsb0JBQW9CLEdBQUcsR0FBRztBQUV6QixNQUFNQyxxQkFBcUIsSUFBSUMsTUFBaUIsSUFBSTtJQUN2RCxNQUFNQyxRQUFRLEdBQUdDLGNBQWMsQ0FBQ0YsTUFBTSxDQUFDO0lBQ3ZDLE1BQU0sRUFBRUcsc0JBQXNCLEVBQUVDLDhCQUFBQSxFQUFnQyxHQUFHSixNQUFNO0lBRXpFLE1BQU1LLGVBQWUsSUFBSUMsU0FBaUIsSUFBSTtRQUMxQyxNQUFNQyxVQUFVLEdBQUdELFNBQVMsQ0FBQ0UsS0FBSyxDQUFDVixvQkFBb0IsQ0FBQzs7UUFHeEQsSUFBSVMsVUFBVSxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsSUFBSUEsVUFBVSxDQUFDRSxNQUFNLEtBQUssQ0FBQyxFQUFFO1lBQ2pERixVQUFVLENBQUNHLEtBQUssQ0FBRSxDQUFBOztRQUd0QixPQUFPQyxpQkFBaUIsQ0FBQ0osVUFBVSxFQUFFTixRQUFRLENBQUMsSUFBSVcsOEJBQThCLENBQUNOLFNBQVMs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OztBQUUzRixDQUFDO0FDNUVNLE1BQU1FLG1CQUFtQixHQUFHQSxDQUkvQkMsZUFLNEIsRUFDNUIsR0FBR0MsWUFBc0MsR0FFekMsT0FBT0QsZUFBZSxLQUFLLFVBQUEsR0FDckJsUSxtQkFBbUIsQ0FBQ2dFLGdCQUFnQixFQUFFa00sZUFBZSxFQUFFLEdBQUdDLFlBQVksQ0FBQSxHQUN0RW5RLG1CQUFtQixDQUNmLElBQU1rUCxZQUFZLENBQUNsTCxnQkFBZ0IsQ0FBRSxDQUFBLEVBQUVrTSxlQUFlLENBQUMsRUFDdkQsR0FBR0MsWUFBWSxDQUFBO01DcEJoQkMsT0FBTyxHQUFBLFdBQUEsR0FBR3BRLG1CQUFtQixDQUFDZ0UsZ0JBQWdCLENBQUEiLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDE4MjMzLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsImZpbGUiOiJ0dXJib3BhY2s6Ly8vW3Byb2plY3RdL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vc2hhcmVkL3NyYy91dGlscy5qcyIsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL3NoYXJlZC9zcmMvdXRpbHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2FtZWxUb1Bhc2NhbCB9IGZyb20gJy4vdXRpbGl0eS10eXBlcyc7XG5cbi8qKlxuICogQ29udmVydHMgc3RyaW5nIHRvIGtlYmFiIGNhc2VcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBBIGtlYmFiaXplZCBzdHJpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IHRvS2ViYWJDYXNlID0gKHN0cmluZzogc3RyaW5nKSA9PlxuICBzdHJpbmcucmVwbGFjZSgvKFthLXowLTldKShbQS1aXSkvZywgJyQxLSQyJykudG9Mb3dlckNhc2UoKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBzdHJpbmcgdG8gY2FtZWwgY2FzZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEEgY2FtZWxpemVkIHN0cmluZ1xuICovXG5leHBvcnQgY29uc3QgdG9DYW1lbENhc2UgPSA8VCBleHRlbmRzIHN0cmluZz4oc3RyaW5nOiBUKSA9PlxuICBzdHJpbmcucmVwbGFjZSgvXihbQS1aXSl8W1xccy1fXSsoXFx3KS9nLCAobWF0Y2gsIHAxLCBwMikgPT5cbiAgICBwMiA/IHAyLnRvVXBwZXJDYXNlKCkgOiBwMS50b0xvd2VyQ2FzZSgpLFxuICApO1xuXG4vKipcbiAqIENvbnZlcnRzIHN0cmluZyB0byBwYXNjYWwgY2FzZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEEgcGFzY2FsaXplZCBzdHJpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IHRvUGFzY2FsQ2FzZSA9IDxUIGV4dGVuZHMgc3RyaW5nPihzdHJpbmc6IFQpOiBDYW1lbFRvUGFzY2FsPFQ+ID0+IHtcbiAgY29uc3QgY2FtZWxDYXNlID0gdG9DYW1lbENhc2Uoc3RyaW5nKTtcblxuICByZXR1cm4gKGNhbWVsQ2FzZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGNhbWVsQ2FzZS5zbGljZSgxKSkgYXMgQ2FtZWxUb1Bhc2NhbDxUPjtcbn07XG5cbi8qKlxuICogTWVyZ2VzIGNsYXNzZXMgaW50byBhIHNpbmdsZSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge2FycmF5fSBjbGFzc2VzXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBBIHN0cmluZyBvZiBjbGFzc2VzXG4gKi9cbmV4cG9ydCBjb25zdCBtZXJnZUNsYXNzZXMgPSA8Q2xhc3NUeXBlID0gc3RyaW5nIHwgdW5kZWZpbmVkIHwgbnVsbD4oLi4uY2xhc3NlczogQ2xhc3NUeXBlW10pID0+XG4gIGNsYXNzZXNcbiAgICAuZmlsdGVyKChjbGFzc05hbWUsIGluZGV4LCBhcnJheSkgPT4ge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgQm9vbGVhbihjbGFzc05hbWUpICYmXG4gICAgICAgIChjbGFzc05hbWUgYXMgc3RyaW5nKS50cmltKCkgIT09ICcnICYmXG4gICAgICAgIGFycmF5LmluZGV4T2YoY2xhc3NOYW1lKSA9PT0gaW5kZXhcbiAgICAgICk7XG4gICAgfSlcbiAgICAuam9pbignICcpXG4gICAgLnRyaW0oKTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIGNvbXBvbmVudCBoYXMgYW4gYWNjZXNzaWJpbGl0eSBwcm9wXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciB0aGUgY29tcG9uZW50IGhhcyBhbiBhY2Nlc3NpYmlsaXR5IHByb3BcbiAqL1xuZXhwb3J0IGNvbnN0IGhhc0ExMXlQcm9wID0gKHByb3BzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSA9PiB7XG4gIGZvciAoY29uc3QgcHJvcCBpbiBwcm9wcykge1xuICAgIGlmIChwcm9wLnN0YXJ0c1dpdGgoJ2FyaWEtJykgfHwgcHJvcCA9PT0gJ3JvbGUnIHx8IHByb3AgPT09ICd0aXRsZScpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFRYSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQWMsQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FDMUIsR0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFPLE9BQUEsQ0FBUSxDQUFzQixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFPLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLEVBQUUsQ0FBWSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQVEvQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxXQUFBLENBQWMsQ0FBQSxDQUFBLENBQW1CLE1BQUEsQ0FDNUMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFPLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFRLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxFQUF5QixDQUFDLE9BQU8sQ0FBSSxDQUFBLENBQUEsQ0FBQSxFQUFBLENBQ2xELENBQUEsQ0FBQSxDQUFBLEVBQUssQ0FBQSxDQUFBLENBQUEsQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQWdCLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFHLENBQVksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBUzlCLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFlLENBQW1CLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFnQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7SUFDdkUsTUFBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBWSxZQUFZLE1BQU0sQ0FBQTtJQUU1QixPQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVUsTUFBQSxDQUFPLENBQUMsQ0FBQSxDQUFFLFdBQUEsRUFBZ0IsR0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFVLEtBQUEsQ0FBTSxDQUFDLENBQUE7QUFDL0QsQ0FBQTtBQVFhLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLFlBQUEsQ0FBZSxDQUFBLENBQUEsQ0FBQSxDQUEyQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FDckUsR0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQ0csTUFBQSxDQUFPLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFXLE9BQU8sS0FBVSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7UUFFakMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxPQUFBLENBQVEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVMsQ0FBQSxDQUNoQixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBcUIsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsTUFBVyxDQUNqQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsS0FBQSxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVEsQ0FBQSxDQUFTLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLEtBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0lBRWpDLENBQUMsQ0FDQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSyxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQ1IsQ0FBSyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFRRyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQWMsQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQStCLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtJQUN6RCxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFXLFFBQVEsS0FBTyxDQUFBO1FBQ3hCLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsRUFBSyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFXLENBQUEsQ0FBTyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxFQUFLLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVMsS0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFVLFNBQVMsT0FBUyxDQUFBLENBQUE7WUFDNUQsT0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO1FBQUE7SUFDVDtBQUVKLENBQUEiLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDE4MjY3LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsImZpbGUiOiJ0dXJib3BhY2s6Ly8vW3Byb2plY3RdL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vZGVmYXVsdEF0dHJpYnV0ZXMuanMiLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3Qvc3JjL2RlZmF1bHRBdHRyaWJ1dGVzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IHtcbiAgeG1sbnM6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG4gIHdpZHRoOiAyNCxcbiAgaGVpZ2h0OiAyNCxcbiAgdmlld0JveDogJzAgMCAyNCAyNCcsXG4gIGZpbGw6ICdub25lJyxcbiAgc3Ryb2tlOiAnY3VycmVudENvbG9yJyxcbiAgc3Ryb2tlV2lkdGg6IDIsXG4gIHN0cm9rZUxpbmVjYXA6ICdyb3VuZCcsXG4gIHN0cm9rZUxpbmVqb2luOiAncm91bmQnLFxufTtcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLENBQWUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0lBQ2IsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFPLEVBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtJQUNQLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTyxFQUFBLENBQUEsQ0FBQTtJQUNQLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFRLEVBQUEsQ0FBQSxDQUFBO0lBQ1IsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBUyxFQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtJQUNULENBQUEsQ0FBQSxDQUFBLENBQU0sRUFBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtJQUNOLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFRLEVBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0lBQ1IsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFhLEVBQUEsQ0FBQTtJQUNiLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQWUsRUFBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0lBQ2YsY0FBZ0IsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ2xCLENBQUEiLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDE4MjkyLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsImZpbGUiOiJ0dXJib3BhY2s6Ly8vW3Byb2plY3RdL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vSWNvbi5qcyIsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL2x1Y2lkZS1yZWFjdC9zcmMvSWNvbi50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVFbGVtZW50LCBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IGRlZmF1bHRBdHRyaWJ1dGVzIGZyb20gJy4vZGVmYXVsdEF0dHJpYnV0ZXMnO1xuaW1wb3J0IHsgSWNvbk5vZGUsIEx1Y2lkZVByb3BzIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBtZXJnZUNsYXNzZXMsIGhhc0ExMXlQcm9wIH0gZnJvbSAnQGx1Y2lkZS9zaGFyZWQnO1xuXG5pbnRlcmZhY2UgSWNvbkNvbXBvbmVudFByb3BzIGV4dGVuZHMgTHVjaWRlUHJvcHMge1xuICBpY29uTm9kZTogSWNvbk5vZGU7XG59XG5cbi8qKlxuICogTHVjaWRlIGljb24gY29tcG9uZW50XG4gKlxuICogQGNvbXBvbmVudCBJY29uXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wcy5jb2xvciAtIFRoZSBjb2xvciBvZiB0aGUgaWNvblxuICogQHBhcmFtIHtudW1iZXJ9IHByb3BzLnNpemUgLSBUaGUgc2l6ZSBvZiB0aGUgaWNvblxuICogQHBhcmFtIHtudW1iZXJ9IHByb3BzLnN0cm9rZVdpZHRoIC0gVGhlIHN0cm9rZSB3aWR0aCBvZiB0aGUgaWNvblxuICogQHBhcmFtIHtib29sZWFufSBwcm9wcy5hYnNvbHV0ZVN0cm9rZVdpZHRoIC0gV2hldGhlciB0byB1c2UgYWJzb2x1dGUgc3Ryb2tlIHdpZHRoXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcHMuY2xhc3NOYW1lIC0gVGhlIGNsYXNzIG5hbWUgb2YgdGhlIGljb25cbiAqIEBwYXJhbSB7SWNvbk5vZGV9IHByb3BzLmNoaWxkcmVuIC0gVGhlIGNoaWxkcmVuIG9mIHRoZSBpY29uXG4gKiBAcGFyYW0ge0ljb25Ob2RlfSBwcm9wcy5pY29uTm9kZSAtIFRoZSBpY29uIG5vZGUgb2YgdGhlIGljb25cbiAqXG4gKiBAcmV0dXJucyB7Rm9yd2FyZFJlZkV4b3RpY0NvbXBvbmVudH0gTHVjaWRlSWNvblxuICovXG5jb25zdCBJY29uID0gZm9yd2FyZFJlZjxTVkdTVkdFbGVtZW50LCBJY29uQ29tcG9uZW50UHJvcHM+KFxuICAoXG4gICAge1xuICAgICAgY29sb3IgPSAnY3VycmVudENvbG9yJyxcbiAgICAgIHNpemUgPSAyNCxcbiAgICAgIHN0cm9rZVdpZHRoID0gMixcbiAgICAgIGFic29sdXRlU3Ryb2tlV2lkdGgsXG4gICAgICBjbGFzc05hbWUgPSAnJyxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgaWNvbk5vZGUsXG4gICAgICAuLi5yZXN0XG4gICAgfSxcbiAgICByZWYsXG4gICkgPT5cbiAgICBjcmVhdGVFbGVtZW50KFxuICAgICAgJ3N2ZycsXG4gICAgICB7XG4gICAgICAgIHJlZixcbiAgICAgICAgLi4uZGVmYXVsdEF0dHJpYnV0ZXMsXG4gICAgICAgIHdpZHRoOiBzaXplLFxuICAgICAgICBoZWlnaHQ6IHNpemUsXG4gICAgICAgIHN0cm9rZTogY29sb3IsXG4gICAgICAgIHN0cm9rZVdpZHRoOiBhYnNvbHV0ZVN0cm9rZVdpZHRoID8gKE51bWJlcihzdHJva2VXaWR0aCkgKiAyNCkgLyBOdW1iZXIoc2l6ZSkgOiBzdHJva2VXaWR0aCxcbiAgICAgICAgY2xhc3NOYW1lOiBtZXJnZUNsYXNzZXMoJ2x1Y2lkZScsIGNsYXNzTmFtZSksXG4gICAgICAgIC4uLighY2hpbGRyZW4gJiYgIWhhc0ExMXlQcm9wKHJlc3QpICYmIHsgJ2FyaWEtaGlkZGVuJzogJ3RydWUnIH0pLFxuICAgICAgICAuLi5yZXN0LFxuICAgICAgfSxcbiAgICAgIFtcbiAgICAgICAgLi4uaWNvbk5vZGUubWFwKChbdGFnLCBhdHRyc10pID0+IGNyZWF0ZUVsZW1lbnQodGFnLCBhdHRycykpLFxuICAgICAgICAuLi4oQXJyYXkuaXNBcnJheShjaGlsZHJlbikgPyBjaGlsZHJlbiA6IFtjaGlsZHJlbl0pLFxuICAgICAgXSxcbiAgICApLFxuKTtcblxuZXhwb3J0IGRlZmF1bHQgSWNvbjtcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQXdCQSxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFPLDZNQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxLQUFBLEVBQ1gsQ0FDRSxFQUNFLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBUSxHQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxFQUNSLENBQUEsQ0FBQSxDQUFBLENBQU8sR0FBQSxDQUFBLENBQUEsRUFDUCxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQWMsR0FBQSxDQUFBLEVBQ2QsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxFQUNBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFZLEdBQUEsQ0FBQSxDQUFBLEVBQ1osQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLEVBQ0EsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLEVBQ0EsQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsR0FBQSxFQUVMLENBRUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSwrTUFBQSxFQUNFLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxFQUNBO1FBQ0UsQ0FBQSxDQUFBLENBQUE7UUFDQSx1S0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO1FBQ0gsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFPLEVBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtRQUNQLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFRLEVBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtRQUNSLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFRLEVBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO1FBQ1IsV0FBQSxDQUFhLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsRUFBdUIsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFPLENBQUEsQ0FBVyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLEVBQUksQ0FBQSxDQUFBLENBQUEsQ0FBTSxHQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU8sQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFJLEdBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO1FBQy9FLFNBQUEsQ0FBVyw4S0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLEtBQUEsQUFBYSxFQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVUsU0FBUyxDQUFBO1FBQzNDLENBQUksQ0FBQSxDQUFBLENBQUMsQ0FBWSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsOEtBQUMsY0FBQSxFQUFZLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFLLENBQUEsQ0FBQSxDQUFBLENBQUE7WUFBRSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBZSxNQUFPO1FBQUEsQ0FBQTtRQUMvRCxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0lBQ0wsQ0FBQSxFQUNBO1dBQ0ssQ0FBUyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsR0FBQSxDQUFJLENBQUMsQ0FBQyxDQUFLLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sNk1BQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLEtBQUEsRUFBYyxHQUFLLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUssQ0FBQyxDQUFBO1dBQ3ZELENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBUSxDQUFRLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBVyxDQUFBLENBQUE7WUFBQyxDQUFRLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7U0FBQTtLQUFBIiwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxODMzMCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJmaWxlIjoidHVyYm9wYWNrOi8vL1twcm9qZWN0XS9ub2RlX21vZHVsZXMvbHVjaWRlLXJlYWN0L2Rpc3QvZXNtL2NyZWF0ZUx1Y2lkZUljb24uanMiLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3Qvc3JjL2NyZWF0ZUx1Y2lkZUljb24udHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlRWxlbWVudCwgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IG1lcmdlQ2xhc3NlcywgdG9LZWJhYkNhc2UsIHRvUGFzY2FsQ2FzZSB9IGZyb20gJ0BsdWNpZGUvc2hhcmVkJztcbmltcG9ydCB7IEljb25Ob2RlLCBMdWNpZGVQcm9wcyB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IEljb24gZnJvbSAnLi9JY29uJztcblxuLyoqXG4gKiBDcmVhdGUgYSBMdWNpZGUgaWNvbiBjb21wb25lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBpY29uTmFtZVxuICogQHBhcmFtIHthcnJheX0gaWNvbk5vZGVcbiAqIEByZXR1cm5zIHtGb3J3YXJkUmVmRXhvdGljQ29tcG9uZW50fSBMdWNpZGVJY29uXG4gKi9cbmNvbnN0IGNyZWF0ZUx1Y2lkZUljb24gPSAoaWNvbk5hbWU6IHN0cmluZywgaWNvbk5vZGU6IEljb25Ob2RlKSA9PiB7XG4gIGNvbnN0IENvbXBvbmVudCA9IGZvcndhcmRSZWY8U1ZHU1ZHRWxlbWVudCwgTHVjaWRlUHJvcHM+KCh7IGNsYXNzTmFtZSwgLi4ucHJvcHMgfSwgcmVmKSA9PlxuICAgIGNyZWF0ZUVsZW1lbnQoSWNvbiwge1xuICAgICAgcmVmLFxuICAgICAgaWNvbk5vZGUsXG4gICAgICBjbGFzc05hbWU6IG1lcmdlQ2xhc3NlcyhcbiAgICAgICAgYGx1Y2lkZS0ke3RvS2ViYWJDYXNlKHRvUGFzY2FsQ2FzZShpY29uTmFtZSkpfWAsXG4gICAgICAgIGBsdWNpZGUtJHtpY29uTmFtZX1gLFxuICAgICAgICBjbGFzc05hbWUsXG4gICAgICApLFxuICAgICAgLi4ucHJvcHMsXG4gICAgfSksXG4gICk7XG5cbiAgQ29tcG9uZW50LmRpc3BsYXlOYW1lID0gdG9QYXNjYWxDYXNlKGljb25OYW1lKTtcblxuICByZXR1cm4gQ29tcG9uZW50O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlTHVjaWRlSWNvbjtcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQVdNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLGdCQUFBLENBQW1CLENBQUEsQ0FBQSxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQWtCLFFBQXVCLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtJQUNqRSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxDQUFZLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsMk1BQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLEtBQUEsRUFBdUMsQ0FBQyxDQUFBLENBQUUsQ0FBVyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsRUFBUyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLHlNQUNqRixnQkFBQSx5SkFBYyxVQUFNLENBQUEsQ0FBQTtZQUNsQixDQUFBLENBQUEsQ0FBQTtZQUNBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtZQUNBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFXLCtLQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsS0FBQSxFQUNULENBQVUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLDhLQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLEtBQUEsK0tBQVksQ0FBYSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxLQUFBLEVBQUEsQ0FBUSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsQ0FBQyxDQUFBLENBQUEsRUFDN0MsQ0FBQSxPQUFBLENBQVUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVEsQ0FBQSxDQUFBLEVBQ2xCLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtZQUVGLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtRQUNKLENBQUE7SUFHTyxTQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLGdMQUFjLGVBQUEsRUFBYSxRQUFRLENBQUE7SUFFdEMsT0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNULENBQUEiLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDE4MzYwLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsImZpbGUiOiJ0dXJib3BhY2s6Ly8vW3Byb2plY3RdL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvZ2hvc3QuanMiLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3Qvc3JjL2ljb25zL2dob3N0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcmVhdGVMdWNpZGVJY29uIGZyb20gJy4uL2NyZWF0ZUx1Y2lkZUljb24nO1xuaW1wb3J0IHsgSWNvbk5vZGUgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBjb25zdCBfX2ljb25Ob2RlOiBJY29uTm9kZSA9IFtcbiAgWydwYXRoJywgeyBkOiAnTTkgMTBoLjAxJywga2V5OiAncWJ0eHV3JyB9XSxcbiAgWydwYXRoJywgeyBkOiAnTTE1IDEwaC4wMScsIGtleTogJzFxbWpzbCcgfV0sXG4gIFtcbiAgICAncGF0aCcsXG4gICAge1xuICAgICAgZDogJ00xMiAyYTggOCAwIDAgMC04IDh2MTJsMy0zIDIuNSAyLjVMMTIgMTlsMi41IDIuNUwxNyAxOWwzIDNWMTBhOCA4IDAgMCAwLTgtOHonLFxuICAgICAga2V5OiAndXd3YjA3JyxcbiAgICB9LFxuICBdLFxuXTtcblxuLyoqXG4gKiBAY29tcG9uZW50IEBuYW1lIEdob3N0XG4gKiBAZGVzY3JpcHRpb24gTHVjaWRlIFNWRyBpY29uIGNvbXBvbmVudCwgcmVuZGVycyBTVkcgRWxlbWVudCB3aXRoIGNoaWxkcmVuLlxuICpcbiAqIEBwcmV2aWV3ICFbaW1nXShkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUFnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JZ29nSUhkcFpIUm9QU0l5TkNJS0lDQm9aV2xuYUhROUlqSTBJZ29nSUhacFpYZENiM2c5SWpBZ01DQXlOQ0F5TkNJS0lDQm1hV3hzUFNKdWIyNWxJZ29nSUhOMGNtOXJaVDBpSXpBd01DSWdjM1I1YkdVOUltSmhZMnRuY205MWJtUXRZMjlzYjNJNklDTm1abVk3SUdKdmNtUmxjaTF5WVdScGRYTTZJREp3ZUNJS0lDQnpkSEp2YTJVdGQybGtkR2c5SWpJaUNpQWdjM1J5YjJ0bExXeHBibVZqWVhBOUluSnZkVzVrSWdvZ0lITjBjbTlyWlMxc2FXNWxhbTlwYmowaWNtOTFibVFpQ2o0S0lDQThjR0YwYUNCa1BTSk5PU0F4TUdndU1ERWlJQzgrQ2lBZ1BIQmhkR2dnWkQwaVRURTFJREV3YUM0d01TSWdMejRLSUNBOGNHRjBhQ0JrUFNKTk1USWdNbUU0SURnZ01DQXdJREF0T0NBNGRqRXliRE10TXlBeUxqVWdNaTQxVERFeUlERTViREl1TlNBeUxqVk1NVGNnTVRsc015QXpWakV3WVRnZ09DQXdJREFnTUMwNExUaDZJaUF2UGdvOEwzTjJaejRLKSAtIGh0dHBzOi8vbHVjaWRlLmRldi9pY29ucy9naG9zdFxuICogQHNlZSBodHRwczovL2x1Y2lkZS5kZXYvZ3VpZGUvcGFja2FnZXMvbHVjaWRlLXJlYWN0IC0gRG9jdW1lbnRhdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyAtIEx1Y2lkZSBpY29ucyBwcm9wcyBhbmQgYW55IHZhbGlkIFNWRyBhdHRyaWJ1dGVcbiAqIEByZXR1cm5zIHtKU1guRWxlbWVudH0gSlNYIEVsZW1lbnRcbiAqXG4gKi9cbmNvbnN0IEdob3N0ID0gY3JlYXRlTHVjaWRlSWNvbignZ2hvc3QnLCBfX2ljb25Ob2RlKTtcblxuZXhwb3J0IGRlZmF1bHQgR2hvc3Q7XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFHTyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxVQUF1QixDQUFBLENBQUEsQ0FBQTtJQUNsQztRQUFDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFRLENBQUE7UUFBQSxDQUFBO1lBQUUsR0FBRyxDQUFhLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtZQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSztRQUFBLENBQVU7S0FBQTtJQUMxQztRQUFDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFRLENBQUE7UUFBQSxDQUFBO1lBQUUsR0FBRyxDQUFjLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO1lBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFLO1FBQUEsQ0FBVTtLQUFBO0lBQzNDO1FBQ0UsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7UUFDQTtZQUNFLENBQUcsRUFBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtZQUNILEdBQUssQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7UUFBQTtLQUNQO0NBRUo7QUFhTSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxLQUFBLENBQVEsQ0FBQSx3S0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLEFBQWlCLENBQWpCLENBQUEsQUFBaUIsQ0FBakIsQUFBaUIsQ0FBakIsQUFBaUIsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLEVBQVMsQ0FBVSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBIiwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxODQwOSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJmaWxlIjoidHVyYm9wYWNrOi8vL1twcm9qZWN0XS9ub2RlX21vZHVsZXMvbHVjaWRlLXJlYWN0L2Rpc3QvZXNtL2ljb25zL2hvdXNlLmpzIiwic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbHVjaWRlLXJlYWN0L3NyYy9pY29ucy9ob3VzZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3JlYXRlTHVjaWRlSWNvbiBmcm9tICcuLi9jcmVhdGVMdWNpZGVJY29uJztcbmltcG9ydCB7IEljb25Ob2RlIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgY29uc3QgX19pY29uTm9kZTogSWNvbk5vZGUgPSBbXG4gIFsncGF0aCcsIHsgZDogJ00xNSAyMXYtOGExIDEgMCAwIDAtMS0xaC00YTEgMSAwIDAgMC0xIDF2OCcsIGtleTogJzV3d2xyNScgfV0sXG4gIFtcbiAgICAncGF0aCcsXG4gICAge1xuICAgICAgZDogJ00zIDEwYTIgMiAwIDAgMSAuNzA5LTEuNTI4bDctNS45OTlhMiAyIDAgMCAxIDIuNTgyIDBsNyA1Ljk5OUEyIDIgMCAwIDEgMjEgMTB2OWEyIDIgMCAwIDEtMiAySDVhMiAyIDAgMCAxLTItMnonLFxuICAgICAga2V5OiAnMWQwa2d0JyxcbiAgICB9LFxuICBdLFxuXTtcblxuLyoqXG4gKiBAY29tcG9uZW50IEBuYW1lIEhvdXNlXG4gKiBAZGVzY3JpcHRpb24gTHVjaWRlIFNWRyBpY29uIGNvbXBvbmVudCwgcmVuZGVycyBTVkcgRWxlbWVudCB3aXRoIGNoaWxkcmVuLlxuICpcbiAqIEBwcmV2aWV3ICFbaW1nXShkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUFnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JZ29nSUhkcFpIUm9QU0l5TkNJS0lDQm9aV2xuYUhROUlqSTBJZ29nSUhacFpYZENiM2c5SWpBZ01DQXlOQ0F5TkNJS0lDQm1hV3hzUFNKdWIyNWxJZ29nSUhOMGNtOXJaVDBpSXpBd01DSWdjM1I1YkdVOUltSmhZMnRuY205MWJtUXRZMjlzYjNJNklDTm1abVk3SUdKdmNtUmxjaTF5WVdScGRYTTZJREp3ZUNJS0lDQnpkSEp2YTJVdGQybGtkR2c5SWpJaUNpQWdjM1J5YjJ0bExXeHBibVZqWVhBOUluSnZkVzVrSWdvZ0lITjBjbTlyWlMxc2FXNWxhbTlwYmowaWNtOTFibVFpQ2o0S0lDQThjR0YwYUNCa1BTSk5NVFVnTWpGMkxUaGhNU0F4SURBZ01DQXdMVEV0TVdndE5HRXhJREVnTUNBd0lEQXRNU0F4ZGpnaUlDOCtDaUFnUEhCaGRHZ2daRDBpVFRNZ01UQmhNaUF5SURBZ01DQXhJQzQzTURrdE1TNDFNamhzTnkwMUxqazVPV0V5SURJZ01DQXdJREVnTWk0MU9ESWdNR3czSURVdU9UazVRVElnTWlBd0lEQWdNU0F5TVNBeE1IWTVZVElnTWlBd0lEQWdNUzB5SURKSU5XRXlJRElnTUNBd0lERXRNaTB5ZWlJZ0x6NEtQQzl6ZG1jK0NnPT0pIC0gaHR0cHM6Ly9sdWNpZGUuZGV2L2ljb25zL2hvdXNlXG4gKiBAc2VlIGh0dHBzOi8vbHVjaWRlLmRldi9ndWlkZS9wYWNrYWdlcy9sdWNpZGUtcmVhY3QgLSBEb2N1bWVudGF0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIC0gTHVjaWRlIGljb25zIHByb3BzIGFuZCBhbnkgdmFsaWQgU1ZHIGF0dHJpYnV0ZVxuICogQHJldHVybnMge0pTWC5FbGVtZW50fSBKU1ggRWxlbWVudFxuICpcbiAqL1xuY29uc3QgSG91c2UgPSBjcmVhdGVMdWNpZGVJY29uKCdob3VzZScsIF9faWNvbk5vZGUpO1xuXG5leHBvcnQgZGVmYXVsdCBIb3VzZTtcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUdPLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLFVBQXVCLENBQUEsQ0FBQSxDQUFBO0lBQ2xDO1FBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVEsQ0FBQTtRQUFBLENBQUE7WUFBRSxHQUFHLENBQThDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtZQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSztRQUFBLENBQVU7S0FBQTtJQUMzRTtRQUNFLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO1FBQ0E7WUFDRSxDQUFHLEVBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7WUFDSCxHQUFLLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO1FBQUE7S0FDUDtDQUVKO0FBYU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsS0FBQSxDQUFRLENBQUEsd0tBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxBQUFpQixDQUFqQixDQUFBLEFBQWlCLENBQWpCLEFBQWlCLENBQWpCLEFBQWlCLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxFQUFTLENBQVUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSIsImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTg0NTEsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6MywiZmlsZSI6InR1cmJvcGFjazovLy9bcHJvamVjdF0vbm9kZV9tb2R1bGVzL2x1Y2lkZS1yZWFjdC9kaXN0L2VzbS9pY29ucy9hcnJvdy1sZWZ0LmpzIiwic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbHVjaWRlLXJlYWN0L3NyYy9pY29ucy9hcnJvdy1sZWZ0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcmVhdGVMdWNpZGVJY29uIGZyb20gJy4uL2NyZWF0ZUx1Y2lkZUljb24nO1xuaW1wb3J0IHsgSWNvbk5vZGUgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBjb25zdCBfX2ljb25Ob2RlOiBJY29uTm9kZSA9IFtcbiAgWydwYXRoJywgeyBkOiAnbTEyIDE5LTctNyA3LTcnLCBrZXk6ICcxbDcyOW4nIH1dLFxuICBbJ3BhdGgnLCB7IGQ6ICdNMTkgMTJINScsIGtleTogJ3gzeDB6bCcgfV0sXG5dO1xuXG4vKipcbiAqIEBjb21wb25lbnQgQG5hbWUgQXJyb3dMZWZ0XG4gKiBAZGVzY3JpcHRpb24gTHVjaWRlIFNWRyBpY29uIGNvbXBvbmVudCwgcmVuZGVycyBTVkcgRWxlbWVudCB3aXRoIGNoaWxkcmVuLlxuICpcbiAqIEBwcmV2aWV3ICFbaW1nXShkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUFnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JZ29nSUhkcFpIUm9QU0l5TkNJS0lDQm9aV2xuYUhROUlqSTBJZ29nSUhacFpYZENiM2c5SWpBZ01DQXlOQ0F5TkNJS0lDQm1hV3hzUFNKdWIyNWxJZ29nSUhOMGNtOXJaVDBpSXpBd01DSWdjM1I1YkdVOUltSmhZMnRuY205MWJtUXRZMjlzYjNJNklDTm1abVk3SUdKdmNtUmxjaTF5WVdScGRYTTZJREp3ZUNJS0lDQnpkSEp2YTJVdGQybGtkR2c5SWpJaUNpQWdjM1J5YjJ0bExXeHBibVZqWVhBOUluSnZkVzVrSWdvZ0lITjBjbTlyWlMxc2FXNWxhbTlwYmowaWNtOTFibVFpQ2o0S0lDQThjR0YwYUNCa1BTSnRNVElnTVRrdE55MDNJRGN0TnlJZ0x6NEtJQ0E4Y0dGMGFDQmtQU0pOTVRrZ01USklOU0lnTHo0S1BDOXpkbWMrQ2c9PSkgLSBodHRwczovL2x1Y2lkZS5kZXYvaWNvbnMvYXJyb3ctbGVmdFxuICogQHNlZSBodHRwczovL2x1Y2lkZS5kZXYvZ3VpZGUvcGFja2FnZXMvbHVjaWRlLXJlYWN0IC0gRG9jdW1lbnRhdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyAtIEx1Y2lkZSBpY29ucyBwcm9wcyBhbmQgYW55IHZhbGlkIFNWRyBhdHRyaWJ1dGVcbiAqIEByZXR1cm5zIHtKU1guRWxlbWVudH0gSlNYIEVsZW1lbnRcbiAqXG4gKi9cbmNvbnN0IEFycm93TGVmdCA9IGNyZWF0ZUx1Y2lkZUljb24oJ2Fycm93LWxlZnQnLCBfX2ljb25Ob2RlKTtcblxuZXhwb3J0IGRlZmF1bHQgQXJyb3dMZWZ0O1xuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBR08sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sVUFBdUIsQ0FBQSxDQUFBLENBQUE7SUFDbEM7UUFBQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBUSxDQUFBO1FBQUEsQ0FBQTtZQUFFLEdBQUcsQ0FBa0IsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtZQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSztRQUFBLENBQVU7S0FBQTtJQUMvQztRQUFDLENBQVEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7UUFBQSxDQUFFO1lBQUEsRUFBRyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVksQ0FBQTtZQUFBLENBQUEsQ0FBQSxDQUFBLENBQUssQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO1FBQVUsQ0FBQTtLQUFBO0NBQzNDO0FBYU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsU0FBQSxDQUFZLENBQUEsd0tBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxBQUFpQixDQUFqQixDQUFBLEFBQWlCLENBQWpCLEFBQWlCLENBQWpCLEFBQWlCLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsRUFBYyxDQUFVLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEiLCJkZWJ1Z0lkIjpudWxsfX1dCn0=