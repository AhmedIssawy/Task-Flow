module.exports = {

"[project]/node_modules/next/dist/client/components/router-reducer/reducers/get-segment-value.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "getSegmentValue", {
    enumerable: true,
    get: function() {
        return getSegmentValue;
    }
});
function getSegmentValue(segment) {
    return Array.isArray(segment) ? segment[1] : segment;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=get-segment-value.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/segment.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    DEFAULT_SEGMENT_KEY: null,
    PAGE_SEGMENT_KEY: null,
    addSearchParamsIfPageSegment: null,
    isGroupSegment: null,
    isParallelRouteSegment: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    DEFAULT_SEGMENT_KEY: function() {
        return DEFAULT_SEGMENT_KEY;
    },
    PAGE_SEGMENT_KEY: function() {
        return PAGE_SEGMENT_KEY;
    },
    addSearchParamsIfPageSegment: function() {
        return addSearchParamsIfPageSegment;
    },
    isGroupSegment: function() {
        return isGroupSegment;
    },
    isParallelRouteSegment: function() {
        return isParallelRouteSegment;
    }
});
function isGroupSegment(segment) {
    // Use array[0] for performant purpose
    return segment[0] === '(' && segment.endsWith(')');
}
function isParallelRouteSegment(segment) {
    return segment.startsWith('@') && segment !== '@children';
}
function addSearchParamsIfPageSegment(segment, searchParams) {
    const isPageSegment = segment.includes(PAGE_SEGMENT_KEY);
    if (isPageSegment) {
        const stringifiedQuery = JSON.stringify(searchParams);
        return stringifiedQuery !== '{}' ? PAGE_SEGMENT_KEY + '?' + stringifiedQuery : PAGE_SEGMENT_KEY;
    }
    return segment;
}
const PAGE_SEGMENT_KEY = '__PAGE__';
const DEFAULT_SEGMENT_KEY = '__DEFAULT__'; //# sourceMappingURL=segment.js.map
}}),
"[project]/node_modules/next/dist/client/components/redirect-status-code.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "RedirectStatusCode", {
    enumerable: true,
    get: function() {
        return RedirectStatusCode;
    }
});
var RedirectStatusCode = /*#__PURE__*/ function(RedirectStatusCode) {
    RedirectStatusCode[RedirectStatusCode["SeeOther"] = 303] = "SeeOther";
    RedirectStatusCode[RedirectStatusCode["TemporaryRedirect"] = 307] = "TemporaryRedirect";
    RedirectStatusCode[RedirectStatusCode["PermanentRedirect"] = 308] = "PermanentRedirect";
    return RedirectStatusCode;
}({});
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=redirect-status-code.js.map
}}),
"[project]/node_modules/next/dist/client/components/redirect-error.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    REDIRECT_ERROR_CODE: null,
    RedirectType: null,
    isRedirectError: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    REDIRECT_ERROR_CODE: function() {
        return REDIRECT_ERROR_CODE;
    },
    RedirectType: function() {
        return RedirectType;
    },
    isRedirectError: function() {
        return isRedirectError;
    }
});
const _redirectstatuscode = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/redirect-status-code.js [app-ssr] (ecmascript)");
const REDIRECT_ERROR_CODE = 'NEXT_REDIRECT';
var RedirectType = /*#__PURE__*/ function(RedirectType) {
    RedirectType["push"] = "push";
    RedirectType["replace"] = "replace";
    return RedirectType;
}({});
function isRedirectError(error) {
    if (typeof error !== 'object' || error === null || !('digest' in error) || typeof error.digest !== 'string') {
        return false;
    }
    const digest = error.digest.split(';');
    const [errorCode, type] = digest;
    const destination = digest.slice(2, -2).join(';');
    const status = digest.at(-2);
    const statusCode = Number(status);
    return errorCode === REDIRECT_ERROR_CODE && (type === 'replace' || type === 'push') && typeof destination === 'string' && !isNaN(statusCode) && statusCode in _redirectstatuscode.RedirectStatusCode;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=redirect-error.js.map
}}),
"[project]/node_modules/next/dist/client/components/redirect.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    getRedirectError: null,
    getRedirectStatusCodeFromError: null,
    getRedirectTypeFromError: null,
    getURLFromRedirectError: null,
    permanentRedirect: null,
    redirect: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    getRedirectError: function() {
        return getRedirectError;
    },
    getRedirectStatusCodeFromError: function() {
        return getRedirectStatusCodeFromError;
    },
    getRedirectTypeFromError: function() {
        return getRedirectTypeFromError;
    },
    getURLFromRedirectError: function() {
        return getURLFromRedirectError;
    },
    permanentRedirect: function() {
        return permanentRedirect;
    },
    redirect: function() {
        return redirect;
    }
});
const _redirectstatuscode = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/redirect-status-code.js [app-ssr] (ecmascript)");
const _redirecterror = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/redirect-error.js [app-ssr] (ecmascript)");
const actionAsyncStorage = ("TURBOPACK compile-time truthy", 1) ? __turbopack_context__.r("[externals]/next/dist/server/app-render/action-async-storage.external.js [external] (next/dist/server/app-render/action-async-storage.external.js, cjs)").actionAsyncStorage : "TURBOPACK unreachable";
function getRedirectError(url, type, statusCode) {
    if (statusCode === void 0) statusCode = _redirectstatuscode.RedirectStatusCode.TemporaryRedirect;
    const error = Object.defineProperty(new Error(_redirecterror.REDIRECT_ERROR_CODE), "__NEXT_ERROR_CODE", {
        value: "E394",
        enumerable: false,
        configurable: true
    });
    error.digest = _redirecterror.REDIRECT_ERROR_CODE + ";" + type + ";" + url + ";" + statusCode + ";";
    return error;
}
function redirect(/** The URL to redirect to */ url, type) {
    var _actionAsyncStorage_getStore;
    type != null ? type : type = (actionAsyncStorage == null ? void 0 : (_actionAsyncStorage_getStore = actionAsyncStorage.getStore()) == null ? void 0 : _actionAsyncStorage_getStore.isAction) ? _redirecterror.RedirectType.push : _redirecterror.RedirectType.replace;
    throw getRedirectError(url, type, _redirectstatuscode.RedirectStatusCode.TemporaryRedirect);
}
function permanentRedirect(/** The URL to redirect to */ url, type) {
    if (type === void 0) type = _redirecterror.RedirectType.replace;
    throw getRedirectError(url, type, _redirectstatuscode.RedirectStatusCode.PermanentRedirect);
}
function getURLFromRedirectError(error) {
    if (!(0, _redirecterror.isRedirectError)(error)) return null;
    // Slices off the beginning of the digest that contains the code and the
    // separating ';'.
    return error.digest.split(';').slice(2, -2).join(';');
}
function getRedirectTypeFromError(error) {
    if (!(0, _redirecterror.isRedirectError)(error)) {
        throw Object.defineProperty(new Error('Not a redirect error'), "__NEXT_ERROR_CODE", {
            value: "E260",
            enumerable: false,
            configurable: true
        });
    }
    return error.digest.split(';', 2)[1];
}
function getRedirectStatusCodeFromError(error) {
    if (!(0, _redirecterror.isRedirectError)(error)) {
        throw Object.defineProperty(new Error('Not a redirect error'), "__NEXT_ERROR_CODE", {
            value: "E260",
            enumerable: false,
            configurable: true
        });
    }
    return Number(error.digest.split(';').at(-2));
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=redirect.js.map
}}),
"[project]/node_modules/next/dist/client/components/http-access-fallback/http-access-fallback.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    HTTPAccessErrorStatus: null,
    HTTP_ERROR_FALLBACK_ERROR_CODE: null,
    getAccessFallbackErrorTypeByStatus: null,
    getAccessFallbackHTTPStatus: null,
    isHTTPAccessFallbackError: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    HTTPAccessErrorStatus: function() {
        return HTTPAccessErrorStatus;
    },
    HTTP_ERROR_FALLBACK_ERROR_CODE: function() {
        return HTTP_ERROR_FALLBACK_ERROR_CODE;
    },
    getAccessFallbackErrorTypeByStatus: function() {
        return getAccessFallbackErrorTypeByStatus;
    },
    getAccessFallbackHTTPStatus: function() {
        return getAccessFallbackHTTPStatus;
    },
    isHTTPAccessFallbackError: function() {
        return isHTTPAccessFallbackError;
    }
});
const HTTPAccessErrorStatus = {
    NOT_FOUND: 404,
    FORBIDDEN: 403,
    UNAUTHORIZED: 401
};
const ALLOWED_CODES = new Set(Object.values(HTTPAccessErrorStatus));
const HTTP_ERROR_FALLBACK_ERROR_CODE = 'NEXT_HTTP_ERROR_FALLBACK';
function isHTTPAccessFallbackError(error) {
    if (typeof error !== 'object' || error === null || !('digest' in error) || typeof error.digest !== 'string') {
        return false;
    }
    const [prefix, httpStatus] = error.digest.split(';');
    return prefix === HTTP_ERROR_FALLBACK_ERROR_CODE && ALLOWED_CODES.has(Number(httpStatus));
}
function getAccessFallbackHTTPStatus(error) {
    const httpStatus = error.digest.split(';')[1];
    return Number(httpStatus);
}
function getAccessFallbackErrorTypeByStatus(status) {
    switch(status){
        case 401:
            return 'unauthorized';
        case 403:
            return 'forbidden';
        case 404:
            return 'not-found';
        default:
            return;
    }
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=http-access-fallback.js.map
}}),
"[project]/node_modules/next/dist/client/components/not-found.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "notFound", {
    enumerable: true,
    get: function() {
        return notFound;
    }
});
const _httpaccessfallback = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/http-access-fallback/http-access-fallback.js [app-ssr] (ecmascript)");
/**
 * This function allows you to render the [not-found.js file](https://nextjs.org/docs/app/api-reference/file-conventions/not-found)
 * within a route segment as well as inject a tag.
 *
 * `notFound()` can be used in
 * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),
 * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and
 * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).
 *
 * - In a Server Component, this will insert a `<meta name="robots" content="noindex" />` meta tag and set the status code to 404.
 * - In a Route Handler or Server Action, it will serve a 404 to the caller.
 *
 * Read more: [Next.js Docs: `notFound`](https://nextjs.org/docs/app/api-reference/functions/not-found)
 */ const DIGEST = "" + _httpaccessfallback.HTTP_ERROR_FALLBACK_ERROR_CODE + ";404";
function notFound() {
    // eslint-disable-next-line no-throw-literal
    const error = Object.defineProperty(new Error(DIGEST), "__NEXT_ERROR_CODE", {
        value: "E394",
        enumerable: false,
        configurable: true
    });
    error.digest = DIGEST;
    throw error;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=not-found.js.map
}}),
"[project]/node_modules/next/dist/client/components/forbidden.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "forbidden", {
    enumerable: true,
    get: function() {
        return forbidden;
    }
});
const _httpaccessfallback = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/http-access-fallback/http-access-fallback.js [app-ssr] (ecmascript)");
// TODO: Add `forbidden` docs
/**
 * @experimental
 * This function allows you to render the [forbidden.js file](https://nextjs.org/docs/app/api-reference/file-conventions/forbidden)
 * within a route segment as well as inject a tag.
 *
 * `forbidden()` can be used in
 * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),
 * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and
 * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).
 *
 * Read more: [Next.js Docs: `forbidden`](https://nextjs.org/docs/app/api-reference/functions/forbidden)
 */ const DIGEST = "" + _httpaccessfallback.HTTP_ERROR_FALLBACK_ERROR_CODE + ";403";
function forbidden() {
    if ("TURBOPACK compile-time truthy", 1) {
        throw Object.defineProperty(new Error("`forbidden()` is experimental and only allowed to be enabled when `experimental.authInterrupts` is enabled."), "__NEXT_ERROR_CODE", {
            value: "E488",
            enumerable: false,
            configurable: true
        });
    }
    // eslint-disable-next-line no-throw-literal
    const error = Object.defineProperty(new Error(DIGEST), "__NEXT_ERROR_CODE", {
        value: "E394",
        enumerable: false,
        configurable: true
    });
    error.digest = DIGEST;
    throw error;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=forbidden.js.map
}}),
"[project]/node_modules/next/dist/client/components/unauthorized.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "unauthorized", {
    enumerable: true,
    get: function() {
        return unauthorized;
    }
});
const _httpaccessfallback = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/http-access-fallback/http-access-fallback.js [app-ssr] (ecmascript)");
// TODO: Add `unauthorized` docs
/**
 * @experimental
 * This function allows you to render the [unauthorized.js file](https://nextjs.org/docs/app/api-reference/file-conventions/unauthorized)
 * within a route segment as well as inject a tag.
 *
 * `unauthorized()` can be used in
 * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),
 * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and
 * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).
 *
 *
 * Read more: [Next.js Docs: `unauthorized`](https://nextjs.org/docs/app/api-reference/functions/unauthorized)
 */ const DIGEST = "" + _httpaccessfallback.HTTP_ERROR_FALLBACK_ERROR_CODE + ";401";
function unauthorized() {
    if ("TURBOPACK compile-time truthy", 1) {
        throw Object.defineProperty(new Error("`unauthorized()` is experimental and only allowed to be used when `experimental.authInterrupts` is enabled."), "__NEXT_ERROR_CODE", {
            value: "E411",
            enumerable: false,
            configurable: true
        });
    }
    // eslint-disable-next-line no-throw-literal
    const error = Object.defineProperty(new Error(DIGEST), "__NEXT_ERROR_CODE", {
        value: "E394",
        enumerable: false,
        configurable: true
    });
    error.digest = DIGEST;
    throw error;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=unauthorized.js.map
}}),
"[project]/node_modules/next/dist/server/dynamic-rendering-utils.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    isHangingPromiseRejectionError: null,
    makeHangingPromise: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    isHangingPromiseRejectionError: function() {
        return isHangingPromiseRejectionError;
    },
    makeHangingPromise: function() {
        return makeHangingPromise;
    }
});
function isHangingPromiseRejectionError(err) {
    if (typeof err !== 'object' || err === null || !('digest' in err)) {
        return false;
    }
    return err.digest === HANGING_PROMISE_REJECTION;
}
const HANGING_PROMISE_REJECTION = 'HANGING_PROMISE_REJECTION';
class HangingPromiseRejectionError extends Error {
    constructor(expression){
        super(`During prerendering, ${expression} rejects when the prerender is complete. Typically these errors are handled by React but if you move ${expression} to a different context by using \`setTimeout\`, \`after\`, or similar functions you may observe this error and you should handle it in that context.`), this.expression = expression, this.digest = HANGING_PROMISE_REJECTION;
    }
}
const abortListenersBySignal = new WeakMap();
function makeHangingPromise(signal, expression) {
    if (signal.aborted) {
        return Promise.reject(new HangingPromiseRejectionError(expression));
    } else {
        const hangingPromise = new Promise((_, reject)=>{
            const boundRejection = reject.bind(null, new HangingPromiseRejectionError(expression));
            let currentListeners = abortListenersBySignal.get(signal);
            if (currentListeners) {
                currentListeners.push(boundRejection);
            } else {
                const listeners = [
                    boundRejection
                ];
                abortListenersBySignal.set(signal, listeners);
                signal.addEventListener('abort', ()=>{
                    for(let i = 0; i < listeners.length; i++){
                        listeners[i]();
                    }
                }, {
                    once: true
                });
            }
        });
        // We are fine if no one actually awaits this promise. We shouldn't consider this an unhandled rejection so
        // we attach a noop catch handler here to suppress this warning. If you actually await somewhere or construct
        // your own promise out of it you'll need to ensure you handle the error when it rejects.
        hangingPromise.catch(ignoreReject);
        return hangingPromise;
    }
}
function ignoreReject() {} //# sourceMappingURL=dynamic-rendering-utils.js.map
}}),
"[project]/node_modules/next/dist/server/lib/router-utils/is-postpone.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "isPostpone", {
    enumerable: true,
    get: function() {
        return isPostpone;
    }
});
const REACT_POSTPONE_TYPE = Symbol.for('react.postpone');
function isPostpone(error) {
    return typeof error === 'object' && error !== null && error.$$typeof === REACT_POSTPONE_TYPE;
} //# sourceMappingURL=is-postpone.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/lazy-dynamic/bailout-to-csr.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
// This has to be a shared module which is shared between client component error boundary and dynamic component
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    BailoutToCSRError: null,
    isBailoutToCSRError: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    BailoutToCSRError: function() {
        return BailoutToCSRError;
    },
    isBailoutToCSRError: function() {
        return isBailoutToCSRError;
    }
});
const BAILOUT_TO_CSR = 'BAILOUT_TO_CLIENT_SIDE_RENDERING';
class BailoutToCSRError extends Error {
    constructor(reason){
        super("Bail out to client-side rendering: " + reason), this.reason = reason, this.digest = BAILOUT_TO_CSR;
    }
}
function isBailoutToCSRError(err) {
    if (typeof err !== 'object' || err === null || !('digest' in err)) {
        return false;
    }
    return err.digest === BAILOUT_TO_CSR;
} //# sourceMappingURL=bailout-to-csr.js.map
}}),
"[project]/node_modules/next/dist/client/components/is-next-router-error.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "isNextRouterError", {
    enumerable: true,
    get: function() {
        return isNextRouterError;
    }
});
const _httpaccessfallback = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/http-access-fallback/http-access-fallback.js [app-ssr] (ecmascript)");
const _redirecterror = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/redirect-error.js [app-ssr] (ecmascript)");
function isNextRouterError(error) {
    return (0, _redirecterror.isRedirectError)(error) || (0, _httpaccessfallback.isHTTPAccessFallbackError)(error);
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=is-next-router-error.js.map
}}),
"[project]/node_modules/next/dist/client/components/hooks-server-context.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    DynamicServerError: null,
    isDynamicServerError: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    DynamicServerError: function() {
        return DynamicServerError;
    },
    isDynamicServerError: function() {
        return isDynamicServerError;
    }
});
const DYNAMIC_ERROR_CODE = 'DYNAMIC_SERVER_USAGE';
class DynamicServerError extends Error {
    constructor(description){
        super("Dynamic server usage: " + description), this.description = description, this.digest = DYNAMIC_ERROR_CODE;
    }
}
function isDynamicServerError(err) {
    if (typeof err !== 'object' || err === null || !('digest' in err) || typeof err.digest !== 'string') {
        return false;
    }
    return err.digest === DYNAMIC_ERROR_CODE;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=hooks-server-context.js.map
}}),
"[project]/node_modules/next/dist/client/components/static-generation-bailout.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    StaticGenBailoutError: null,
    isStaticGenBailoutError: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    StaticGenBailoutError: function() {
        return StaticGenBailoutError;
    },
    isStaticGenBailoutError: function() {
        return isStaticGenBailoutError;
    }
});
const NEXT_STATIC_GEN_BAILOUT = 'NEXT_STATIC_GEN_BAILOUT';
class StaticGenBailoutError extends Error {
    constructor(...args){
        super(...args), this.code = NEXT_STATIC_GEN_BAILOUT;
    }
}
function isStaticGenBailoutError(error) {
    if (typeof error !== 'object' || error === null || !('code' in error)) {
        return false;
    }
    return error.code === NEXT_STATIC_GEN_BAILOUT;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=static-generation-bailout.js.map
}}),
"[project]/node_modules/next/dist/lib/metadata/metadata-constants.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    METADATA_BOUNDARY_NAME: null,
    OUTLET_BOUNDARY_NAME: null,
    VIEWPORT_BOUNDARY_NAME: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    METADATA_BOUNDARY_NAME: function() {
        return METADATA_BOUNDARY_NAME;
    },
    OUTLET_BOUNDARY_NAME: function() {
        return OUTLET_BOUNDARY_NAME;
    },
    VIEWPORT_BOUNDARY_NAME: function() {
        return VIEWPORT_BOUNDARY_NAME;
    }
});
const METADATA_BOUNDARY_NAME = '__next_metadata_boundary__';
const VIEWPORT_BOUNDARY_NAME = '__next_viewport_boundary__';
const OUTLET_BOUNDARY_NAME = '__next_outlet_boundary__'; //# sourceMappingURL=metadata-constants.js.map
}}),
"[project]/node_modules/next/dist/lib/scheduler.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    atLeastOneTask: null,
    scheduleImmediate: null,
    scheduleOnNextTick: null,
    waitAtLeastOneReactRenderTask: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    atLeastOneTask: function() {
        return atLeastOneTask;
    },
    scheduleImmediate: function() {
        return scheduleImmediate;
    },
    scheduleOnNextTick: function() {
        return scheduleOnNextTick;
    },
    waitAtLeastOneReactRenderTask: function() {
        return waitAtLeastOneReactRenderTask;
    }
});
const scheduleOnNextTick = (cb)=>{
    // We use Promise.resolve().then() here so that the operation is scheduled at
    // the end of the promise job queue, we then add it to the next process tick
    // to ensure it's evaluated afterwards.
    //
    // This was inspired by the implementation of the DataLoader interface: https://github.com/graphql/dataloader/blob/d336bd15282664e0be4b4a657cb796f09bafbc6b/src/index.js#L213-L255
    //
    Promise.resolve().then(()=>{
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        else {
            process.nextTick(cb);
        }
    });
};
const scheduleImmediate = (cb)=>{
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    else {
        setImmediate(cb);
    }
};
function atLeastOneTask() {
    return new Promise((resolve)=>scheduleImmediate(resolve));
}
function waitAtLeastOneReactRenderTask() {
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    else {
        return new Promise((r)=>setImmediate(r));
    }
} //# sourceMappingURL=scheduler.js.map
}}),
"[project]/node_modules/next/dist/server/app-render/dynamic-rendering.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/**
 * The functions provided by this module are used to communicate certain properties
 * about the currently running code so that Next.js can make decisions on how to handle
 * the current execution in different rendering modes such as pre-rendering, resuming, and SSR.
 *
 * Today Next.js treats all code as potentially static. Certain APIs may only make sense when dynamically rendering.
 * Traditionally this meant deopting the entire render to dynamic however with PPR we can now deopt parts
 * of a React tree as dynamic while still keeping other parts static. There are really two different kinds of
 * Dynamic indications.
 *
 * The first is simply an intention to be dynamic. unstable_noStore is an example of this where
 * the currently executing code simply declares that the current scope is dynamic but if you use it
 * inside unstable_cache it can still be cached. This type of indication can be removed if we ever
 * make the default dynamic to begin with because the only way you would ever be static is inside
 * a cache scope which this indication does not affect.
 *
 * The second is an indication that a dynamic data source was read. This is a stronger form of dynamic
 * because it means that it is inappropriate to cache this at all. using a dynamic data source inside
 * unstable_cache should error. If you want to use some dynamic data inside unstable_cache you should
 * read that data outside the cache and pass it in as an argument to the cached function.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    Postpone: null,
    PreludeState: null,
    abortAndThrowOnSynchronousRequestDataAccess: null,
    abortOnSynchronousPlatformIOAccess: null,
    accessedDynamicData: null,
    annotateDynamicAccess: null,
    consumeDynamicAccess: null,
    createDynamicTrackingState: null,
    createDynamicValidationState: null,
    createHangingInputAbortSignal: null,
    createPostponedAbortSignal: null,
    formatDynamicAPIAccesses: null,
    getFirstDynamicReason: null,
    isDynamicPostpone: null,
    isPrerenderInterruptedError: null,
    markCurrentScopeAsDynamic: null,
    postponeWithTracking: null,
    throwIfDisallowedDynamic: null,
    throwToInterruptStaticGeneration: null,
    trackAllowedDynamicAccess: null,
    trackDynamicDataInDynamicRender: null,
    trackFallbackParamAccessed: null,
    trackSynchronousPlatformIOAccessInDev: null,
    trackSynchronousRequestDataAccessInDev: null,
    useDynamicRouteParams: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    Postpone: function() {
        return Postpone;
    },
    PreludeState: function() {
        return PreludeState;
    },
    abortAndThrowOnSynchronousRequestDataAccess: function() {
        return abortAndThrowOnSynchronousRequestDataAccess;
    },
    abortOnSynchronousPlatformIOAccess: function() {
        return abortOnSynchronousPlatformIOAccess;
    },
    accessedDynamicData: function() {
        return accessedDynamicData;
    },
    annotateDynamicAccess: function() {
        return annotateDynamicAccess;
    },
    consumeDynamicAccess: function() {
        return consumeDynamicAccess;
    },
    createDynamicTrackingState: function() {
        return createDynamicTrackingState;
    },
    createDynamicValidationState: function() {
        return createDynamicValidationState;
    },
    createHangingInputAbortSignal: function() {
        return createHangingInputAbortSignal;
    },
    createPostponedAbortSignal: function() {
        return createPostponedAbortSignal;
    },
    formatDynamicAPIAccesses: function() {
        return formatDynamicAPIAccesses;
    },
    getFirstDynamicReason: function() {
        return getFirstDynamicReason;
    },
    isDynamicPostpone: function() {
        return isDynamicPostpone;
    },
    isPrerenderInterruptedError: function() {
        return isPrerenderInterruptedError;
    },
    markCurrentScopeAsDynamic: function() {
        return markCurrentScopeAsDynamic;
    },
    postponeWithTracking: function() {
        return postponeWithTracking;
    },
    throwIfDisallowedDynamic: function() {
        return throwIfDisallowedDynamic;
    },
    throwToInterruptStaticGeneration: function() {
        return throwToInterruptStaticGeneration;
    },
    trackAllowedDynamicAccess: function() {
        return trackAllowedDynamicAccess;
    },
    trackDynamicDataInDynamicRender: function() {
        return trackDynamicDataInDynamicRender;
    },
    trackFallbackParamAccessed: function() {
        return trackFallbackParamAccessed;
    },
    trackSynchronousPlatformIOAccessInDev: function() {
        return trackSynchronousPlatformIOAccessInDev;
    },
    trackSynchronousRequestDataAccessInDev: function() {
        return trackSynchronousRequestDataAccessInDev;
    },
    useDynamicRouteParams: function() {
        return useDynamicRouteParams;
    }
});
const _react = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)"));
const _hooksservercontext = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/hooks-server-context.js [app-ssr] (ecmascript)");
const _staticgenerationbailout = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/static-generation-bailout.js [app-ssr] (ecmascript)");
const _workunitasyncstorageexternal = __turbopack_context__.r("[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)");
const _workasyncstorageexternal = __turbopack_context__.r("[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)");
const _dynamicrenderingutils = __turbopack_context__.r("[project]/node_modules/next/dist/server/dynamic-rendering-utils.js [app-ssr] (ecmascript)");
const _metadataconstants = __turbopack_context__.r("[project]/node_modules/next/dist/lib/metadata/metadata-constants.js [app-ssr] (ecmascript)");
const _scheduler = __turbopack_context__.r("[project]/node_modules/next/dist/lib/scheduler.js [app-ssr] (ecmascript)");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const hasPostpone = typeof _react.default.unstable_postpone === 'function';
function createDynamicTrackingState(isDebugDynamicAccesses) {
    return {
        isDebugDynamicAccesses,
        dynamicAccesses: [],
        syncDynamicErrorWithStack: null
    };
}
function createDynamicValidationState() {
    return {
        hasSuspenseAboveBody: false,
        hasDynamicMetadata: false,
        hasDynamicViewport: false,
        hasAllowedDynamic: false,
        dynamicErrors: []
    };
}
function getFirstDynamicReason(trackingState) {
    var _trackingState_dynamicAccesses_;
    return (_trackingState_dynamicAccesses_ = trackingState.dynamicAccesses[0]) == null ? void 0 : _trackingState_dynamicAccesses_.expression;
}
function markCurrentScopeAsDynamic(store, workUnitStore, expression) {
    if (workUnitStore) {
        if (workUnitStore.type === 'cache' || workUnitStore.type === 'unstable-cache') {
            // inside cache scopes marking a scope as dynamic has no effect because the outer cache scope
            // creates a cache boundary. This is subtly different from reading a dynamic data source which is
            // forbidden inside a cache scope.
            return;
        }
    }
    // If we're forcing dynamic rendering or we're forcing static rendering, we
    // don't need to do anything here because the entire page is already dynamic
    // or it's static and it should not throw or postpone here.
    if (store.forceDynamic || store.forceStatic) return;
    if (store.dynamicShouldError) {
        throw Object.defineProperty(new _staticgenerationbailout.StaticGenBailoutError(`Route ${store.route} with \`dynamic = "error"\` couldn't be rendered statically because it used \`${expression}\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`), "__NEXT_ERROR_CODE", {
            value: "E553",
            enumerable: false,
            configurable: true
        });
    }
    if (workUnitStore) {
        if (workUnitStore.type === 'prerender-ppr') {
            postponeWithTracking(store.route, expression, workUnitStore.dynamicTracking);
        } else if (workUnitStore.type === 'prerender-legacy') {
            workUnitStore.revalidate = 0;
            // We aren't prerendering but we are generating a static page. We need to bail out of static generation
            const err = Object.defineProperty(new _hooksservercontext.DynamicServerError(`Route ${store.route} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`), "__NEXT_ERROR_CODE", {
                value: "E550",
                enumerable: false,
                configurable: true
            });
            store.dynamicUsageDescription = expression;
            store.dynamicUsageStack = err.stack;
            throw err;
        } else if (("TURBOPACK compile-time value", "development") === 'development' && workUnitStore && workUnitStore.type === 'request') {
            workUnitStore.usedDynamic = true;
        }
    }
}
function trackFallbackParamAccessed(store, expression) {
    const prerenderStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
    if (!prerenderStore || prerenderStore.type !== 'prerender-ppr') return;
    postponeWithTracking(store.route, expression, prerenderStore.dynamicTracking);
}
function throwToInterruptStaticGeneration(expression, store, prerenderStore) {
    // We aren't prerendering but we are generating a static page. We need to bail out of static generation
    const err = Object.defineProperty(new _hooksservercontext.DynamicServerError(`Route ${store.route} couldn't be rendered statically because it used \`${expression}\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`), "__NEXT_ERROR_CODE", {
        value: "E558",
        enumerable: false,
        configurable: true
    });
    prerenderStore.revalidate = 0;
    store.dynamicUsageDescription = expression;
    store.dynamicUsageStack = err.stack;
    throw err;
}
function trackDynamicDataInDynamicRender(_store, workUnitStore) {
    if (workUnitStore) {
        if (workUnitStore.type === 'cache' || workUnitStore.type === 'unstable-cache') {
            // inside cache scopes marking a scope as dynamic has no effect because the outer cache scope
            // creates a cache boundary. This is subtly different from reading a dynamic data source which is
            // forbidden inside a cache scope.
            return;
        }
        // TODO: it makes no sense to have these work unit store types during a dev render.
        if (workUnitStore.type === 'prerender' || workUnitStore.type === 'prerender-client' || workUnitStore.type === 'prerender-legacy') {
            workUnitStore.revalidate = 0;
        }
        if (("TURBOPACK compile-time value", "development") === 'development' && workUnitStore.type === 'request') {
            workUnitStore.usedDynamic = true;
        }
    }
}
function abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore) {
    const reason = `Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`;
    const error = createPrerenderInterruptedError(reason);
    prerenderStore.controller.abort(error);
    const dynamicTracking = prerenderStore.dynamicTracking;
    if (dynamicTracking) {
        dynamicTracking.dynamicAccesses.push({
            // When we aren't debugging, we don't need to create another error for the
            // stack trace.
            stack: dynamicTracking.isDebugDynamicAccesses ? new Error().stack : undefined,
            expression
        });
    }
}
function abortOnSynchronousPlatformIOAccess(route, expression, errorWithStack, prerenderStore) {
    const dynamicTracking = prerenderStore.dynamicTracking;
    abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore);
    // It is important that we set this tracking value after aborting. Aborts are executed
    // synchronously except for the case where you abort during render itself. By setting this
    // value late we can use it to determine if any of the aborted tasks are the task that
    // called the sync IO expression in the first place.
    if (dynamicTracking) {
        if (dynamicTracking.syncDynamicErrorWithStack === null) {
            dynamicTracking.syncDynamicErrorWithStack = errorWithStack;
        }
    }
}
function trackSynchronousPlatformIOAccessInDev(requestStore) {
    // We don't actually have a controller to abort but we do the semantic equivalent by
    // advancing the request store out of prerender mode
    requestStore.prerenderPhase = false;
}
function abortAndThrowOnSynchronousRequestDataAccess(route, expression, errorWithStack, prerenderStore) {
    const prerenderSignal = prerenderStore.controller.signal;
    if (prerenderSignal.aborted === false) {
        // TODO it would be better to move this aborted check into the callsite so we can avoid making
        // the error object when it isn't relevant to the aborting of the prerender however
        // since we need the throw semantics regardless of whether we abort it is easier to land
        // this way. See how this was handled with `abortOnSynchronousPlatformIOAccess` for a closer
        // to ideal implementation
        abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore);
        // It is important that we set this tracking value after aborting. Aborts are executed
        // synchronously except for the case where you abort during render itself. By setting this
        // value late we can use it to determine if any of the aborted tasks are the task that
        // called the sync IO expression in the first place.
        const dynamicTracking = prerenderStore.dynamicTracking;
        if (dynamicTracking) {
            if (dynamicTracking.syncDynamicErrorWithStack === null) {
                dynamicTracking.syncDynamicErrorWithStack = errorWithStack;
            }
        }
    }
    throw createPrerenderInterruptedError(`Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`);
}
const trackSynchronousRequestDataAccessInDev = trackSynchronousPlatformIOAccessInDev;
function Postpone({ reason, route }) {
    const prerenderStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
    const dynamicTracking = prerenderStore && prerenderStore.type === 'prerender-ppr' ? prerenderStore.dynamicTracking : null;
    postponeWithTracking(route, reason, dynamicTracking);
}
function postponeWithTracking(route, expression, dynamicTracking) {
    assertPostpone();
    if (dynamicTracking) {
        dynamicTracking.dynamicAccesses.push({
            // When we aren't debugging, we don't need to create another error for the
            // stack trace.
            stack: dynamicTracking.isDebugDynamicAccesses ? new Error().stack : undefined,
            expression
        });
    }
    _react.default.unstable_postpone(createPostponeReason(route, expression));
}
function createPostponeReason(route, expression) {
    return `Route ${route} needs to bail out of prerendering at this point because it used ${expression}. ` + `React throws this special object to indicate where. It should not be caught by ` + `your own try/catch. Learn more: https://nextjs.org/docs/messages/ppr-caught-error`;
}
function isDynamicPostpone(err) {
    if (typeof err === 'object' && err !== null && typeof err.message === 'string') {
        return isDynamicPostponeReason(err.message);
    }
    return false;
}
function isDynamicPostponeReason(reason) {
    return reason.includes('needs to bail out of prerendering at this point because it used') && reason.includes('Learn more: https://nextjs.org/docs/messages/ppr-caught-error');
}
if (isDynamicPostponeReason(createPostponeReason('%%%', '^^^')) === false) {
    throw Object.defineProperty(new Error('Invariant: isDynamicPostpone misidentified a postpone reason. This is a bug in Next.js'), "__NEXT_ERROR_CODE", {
        value: "E296",
        enumerable: false,
        configurable: true
    });
}
const NEXT_PRERENDER_INTERRUPTED = 'NEXT_PRERENDER_INTERRUPTED';
function createPrerenderInterruptedError(message) {
    const error = Object.defineProperty(new Error(message), "__NEXT_ERROR_CODE", {
        value: "E394",
        enumerable: false,
        configurable: true
    });
    error.digest = NEXT_PRERENDER_INTERRUPTED;
    return error;
}
function isPrerenderInterruptedError(error) {
    return typeof error === 'object' && error !== null && error.digest === NEXT_PRERENDER_INTERRUPTED && 'name' in error && 'message' in error && error instanceof Error;
}
function accessedDynamicData(dynamicAccesses) {
    return dynamicAccesses.length > 0;
}
function consumeDynamicAccess(serverDynamic, clientDynamic) {
    // We mutate because we only call this once we are no longer writing
    // to the dynamicTrackingState and it's more efficient than creating a new
    // array.
    serverDynamic.dynamicAccesses.push(...clientDynamic.dynamicAccesses);
    return serverDynamic.dynamicAccesses;
}
function formatDynamicAPIAccesses(dynamicAccesses) {
    return dynamicAccesses.filter((access)=>typeof access.stack === 'string' && access.stack.length > 0).map(({ expression, stack })=>{
        stack = stack.split('\n') // Remove the "Error: " prefix from the first line of the stack trace as
        // well as the first 4 lines of the stack trace which is the distance
        // from the user code and the `new Error().stack` call.
        .slice(4).filter((line)=>{
            // Exclude Next.js internals from the stack trace.
            if (line.includes('node_modules/next/')) {
                return false;
            }
            // Exclude anonymous functions from the stack trace.
            if (line.includes(' (<anonymous>)')) {
                return false;
            }
            // Exclude Node.js internals from the stack trace.
            if (line.includes(' (node:')) {
                return false;
            }
            return true;
        }).join('\n');
        return `Dynamic API Usage Debug - ${expression}:\n${stack}`;
    });
}
function assertPostpone() {
    if (!hasPostpone) {
        throw Object.defineProperty(new Error(`Invariant: React.unstable_postpone is not defined. This suggests the wrong version of React was loaded. This is a bug in Next.js`), "__NEXT_ERROR_CODE", {
            value: "E224",
            enumerable: false,
            configurable: true
        });
    }
}
function createPostponedAbortSignal(reason) {
    assertPostpone();
    const controller = new AbortController();
    // We get our hands on a postpone instance by calling postpone and catching the throw
    try {
        _react.default.unstable_postpone(reason);
    } catch (x) {
        controller.abort(x);
    }
    return controller.signal;
}
function createHangingInputAbortSignal(workUnitStore) {
    const controller = new AbortController();
    if (workUnitStore.cacheSignal) {
        // If we have a cacheSignal it means we're in a prospective render. If the input
        // we're waiting on is coming from another cache, we do want to wait for it so that
        // we can resolve this cache entry too.
        workUnitStore.cacheSignal.inputReady().then(()=>{
            controller.abort();
        });
    } else {
        // Otherwise we're in the final render and we should already have all our caches
        // filled. We might still be waiting on some microtasks so we wait one tick before
        // giving up. When we give up, we still want to render the content of this cache
        // as deeply as we can so that we can suspend as deeply as possible in the tree
        // or not at all if we don't end up waiting for the input.
        (0, _scheduler.scheduleOnNextTick)(()=>controller.abort());
    }
    return controller.signal;
}
function annotateDynamicAccess(expression, prerenderStore) {
    const dynamicTracking = prerenderStore.dynamicTracking;
    if (dynamicTracking) {
        dynamicTracking.dynamicAccesses.push({
            stack: dynamicTracking.isDebugDynamicAccesses ? new Error().stack : undefined,
            expression
        });
    }
}
function useDynamicRouteParams(expression) {
    const workStore = _workasyncstorageexternal.workAsyncStorage.getStore();
    if (workStore && workStore.isStaticGeneration && workStore.fallbackRouteParams && workStore.fallbackRouteParams.size > 0) {
        // There are fallback route params, we should track these as dynamic
        // accesses.
        const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
        if (workUnitStore) {
            // We're prerendering with dynamicIO or PPR or both
            if (workUnitStore.type === 'prerender-client') {
                // We are in a prerender with dynamicIO semantics
                // We are going to hang here and never resolve. This will cause the currently
                // rendering component to effectively be a dynamic hole
                _react.default.use((0, _dynamicrenderingutils.makeHangingPromise)(workUnitStore.renderSignal, expression));
            } else if (workUnitStore.type === 'prerender-ppr') {
                // We're prerendering with PPR
                postponeWithTracking(workStore.route, expression, workUnitStore.dynamicTracking);
            } else if (workUnitStore.type === 'prerender-legacy') {
                throwToInterruptStaticGeneration(expression, workStore, workUnitStore);
            }
        }
    }
}
const hasSuspenseRegex = /\n\s+at Suspense \(<anonymous>\)/;
const hasSuspenseAfterBodyOrHtmlRegex = /\n\s+at (?:body|html) \(<anonymous>\)[\s\S]*?\n\s+at Suspense \(<anonymous>\)/;
const hasMetadataRegex = new RegExp(`\\n\\s+at ${_metadataconstants.METADATA_BOUNDARY_NAME}[\\n\\s]`);
const hasViewportRegex = new RegExp(`\\n\\s+at ${_metadataconstants.VIEWPORT_BOUNDARY_NAME}[\\n\\s]`);
const hasOutletRegex = new RegExp(`\\n\\s+at ${_metadataconstants.OUTLET_BOUNDARY_NAME}[\\n\\s]`);
function trackAllowedDynamicAccess(workStore, componentStack, dynamicValidation, clientDynamic) {
    if (hasOutletRegex.test(componentStack)) {
        // We don't need to track that this is dynamic. It is only so when something else is also dynamic.
        return;
    } else if (hasMetadataRegex.test(componentStack)) {
        dynamicValidation.hasDynamicMetadata = true;
        return;
    } else if (hasViewportRegex.test(componentStack)) {
        dynamicValidation.hasDynamicViewport = true;
        return;
    } else if (hasSuspenseAfterBodyOrHtmlRegex.test(componentStack)) {
        // This prerender has a Suspense boundary above the body which
        // effectively opts the page into allowing 100% dynamic rendering
        dynamicValidation.hasAllowedDynamic = true;
        dynamicValidation.hasSuspenseAboveBody = true;
        return;
    } else if (hasSuspenseRegex.test(componentStack)) {
        // this error had a Suspense boundary above it so we don't need to report it as a source
        // of disallowed
        dynamicValidation.hasAllowedDynamic = true;
        return;
    } else if (clientDynamic.syncDynamicErrorWithStack) {
        // This task was the task that called the sync error.
        dynamicValidation.dynamicErrors.push(clientDynamic.syncDynamicErrorWithStack);
        return;
    } else {
        const message = `Route "${workStore.route}": A component accessed data, headers, params, searchParams, or a short-lived cache without a Suspense boundary nor a "use cache" above it. See more info: https://nextjs.org/docs/messages/next-prerender-missing-suspense`;
        const error = createErrorWithComponentOrOwnerStack(message, componentStack);
        dynamicValidation.dynamicErrors.push(error);
        return;
    }
}
/**
 * In dev mode, we prefer using the owner stack, otherwise the provided
 * component stack is used.
 */ function createErrorWithComponentOrOwnerStack(message, componentStack) {
    const ownerStack = ("TURBOPACK compile-time value", "development") !== 'production' && _react.default.captureOwnerStack ? _react.default.captureOwnerStack() : null;
    const error = Object.defineProperty(new Error(message), "__NEXT_ERROR_CODE", {
        value: "E394",
        enumerable: false,
        configurable: true
    });
    error.stack = error.name + ': ' + message + (ownerStack ?? componentStack);
    return error;
}
var PreludeState = /*#__PURE__*/ function(PreludeState) {
    PreludeState[PreludeState["Full"] = 0] = "Full";
    PreludeState[PreludeState["Empty"] = 1] = "Empty";
    PreludeState[PreludeState["Errored"] = 2] = "Errored";
    return PreludeState;
}({});
function logDisallowedDynamicError(workStore, error) {
    console.error(error);
    if (!workStore.dev) {
        if (workStore.hasReadableErrorStacks) {
            console.error(`To get a more detailed stack trace and pinpoint the issue, start the app in development mode by running \`next dev\`, then open "${workStore.route}" in your browser to investigate the error.`);
        } else {
            console.error(`To get a more detailed stack trace and pinpoint the issue, try one of the following:
  - Start the app in development mode by running \`next dev\`, then open "${workStore.route}" in your browser to investigate the error.
  - Rerun the production build with \`next build --debug-prerender\` to generate better stack traces.`);
        }
    }
}
function throwIfDisallowedDynamic(workStore, prelude, dynamicValidation, serverDynamic) {
    if (workStore.invalidDynamicUsageError) {
        logDisallowedDynamicError(workStore, workStore.invalidDynamicUsageError);
        throw new _staticgenerationbailout.StaticGenBailoutError();
    }
    if (prelude !== 0) {
        if (dynamicValidation.hasSuspenseAboveBody) {
            // This route has opted into allowing fully dynamic rendering
            // by including a Suspense boundary above the body. In this case
            // a lack of a shell is not considered disallowed so we simply return
            return;
        }
        if (serverDynamic.syncDynamicErrorWithStack) {
            // There is no shell and the server did something sync dynamic likely
            // leading to an early termination of the prerender before the shell
            // could be completed. We terminate the build/validating render.
            logDisallowedDynamicError(workStore, serverDynamic.syncDynamicErrorWithStack);
            throw new _staticgenerationbailout.StaticGenBailoutError();
        }
        // We didn't have any sync bailouts but there may be user code which
        // blocked the root. We would have captured these during the prerender
        // and can log them here and then terminate the build/validating render
        const dynamicErrors = dynamicValidation.dynamicErrors;
        if (dynamicErrors.length > 0) {
            for(let i = 0; i < dynamicErrors.length; i++){
                logDisallowedDynamicError(workStore, dynamicErrors[i]);
            }
            throw new _staticgenerationbailout.StaticGenBailoutError();
        }
        // If we got this far then the only other thing that could be blocking
        // the root is dynamic Viewport. If this is dynamic then
        // you need to opt into that by adding a Suspense boundary above the body
        // to indicate your are ok with fully dynamic rendering.
        if (dynamicValidation.hasDynamicViewport) {
            console.error(`Route "${workStore.route}" has a \`generateViewport\` that depends on Request data (\`cookies()\`, etc...) or uncached external data (\`fetch(...)\`, etc...) without explicitly allowing fully dynamic rendering. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-viewport`);
            throw new _staticgenerationbailout.StaticGenBailoutError();
        }
        if (prelude === 1) {
            // If we ever get this far then we messed up the tracking of invalid dynamic.
            // We still adhere to the constraint that you must produce a shell but invite the
            // user to report this as a bug in Next.js.
            console.error(`Route "${workStore.route}" did not produce a static shell and Next.js was unable to determine a reason. This is a bug in Next.js.`);
            throw new _staticgenerationbailout.StaticGenBailoutError();
        }
    } else {
        if (dynamicValidation.hasAllowedDynamic === false && dynamicValidation.hasDynamicMetadata) {
            console.error(`Route "${workStore.route}" has a \`generateMetadata\` that depends on Request data (\`cookies()\`, etc...) or uncached external data (\`fetch(...)\`, etc...) when the rest of the route does not. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-metadata`);
            throw new _staticgenerationbailout.StaticGenBailoutError();
        }
    }
} //# sourceMappingURL=dynamic-rendering.js.map
}}),
"[project]/node_modules/next/dist/client/components/unstable-rethrow.server.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "unstable_rethrow", {
    enumerable: true,
    get: function() {
        return unstable_rethrow;
    }
});
const _dynamicrenderingutils = __turbopack_context__.r("[project]/node_modules/next/dist/server/dynamic-rendering-utils.js [app-ssr] (ecmascript)");
const _ispostpone = __turbopack_context__.r("[project]/node_modules/next/dist/server/lib/router-utils/is-postpone.js [app-ssr] (ecmascript)");
const _bailouttocsr = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/lazy-dynamic/bailout-to-csr.js [app-ssr] (ecmascript)");
const _isnextroutererror = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/is-next-router-error.js [app-ssr] (ecmascript)");
const _dynamicrendering = __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/dynamic-rendering.js [app-ssr] (ecmascript)");
const _hooksservercontext = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/hooks-server-context.js [app-ssr] (ecmascript)");
function unstable_rethrow(error) {
    if ((0, _isnextroutererror.isNextRouterError)(error) || (0, _bailouttocsr.isBailoutToCSRError)(error) || (0, _hooksservercontext.isDynamicServerError)(error) || (0, _dynamicrendering.isDynamicPostpone)(error) || (0, _ispostpone.isPostpone)(error) || (0, _dynamicrenderingutils.isHangingPromiseRejectionError)(error)) {
        throw error;
    }
    if (error instanceof Error && 'cause' in error) {
        unstable_rethrow(error.cause);
    }
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=unstable-rethrow.server.js.map
}}),
"[project]/node_modules/next/dist/client/components/unstable-rethrow.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/**
 * This function should be used to rethrow internal Next.js errors so that they can be handled by the framework.
 * When wrapping an API that uses errors to interrupt control flow, you should use this function before you do any error handling.
 * This function will rethrow the error if it is a Next.js error so it can be handled, otherwise it will do nothing.
 *
 * Read more: [Next.js Docs: `unstable_rethrow`](https://nextjs.org/docs/app/api-reference/functions/unstable_rethrow)
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "unstable_rethrow", {
    enumerable: true,
    get: function() {
        return unstable_rethrow;
    }
});
const unstable_rethrow = ("TURBOPACK compile-time truthy", 1) ? __turbopack_context__.r("[project]/node_modules/next/dist/client/components/unstable-rethrow.server.js [app-ssr] (ecmascript)").unstable_rethrow : "TURBOPACK unreachable";
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=unstable-rethrow.js.map
}}),
"[project]/node_modules/next/dist/client/components/navigation.react-server.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/** @internal */ Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    ReadonlyURLSearchParams: null,
    RedirectType: null,
    forbidden: null,
    notFound: null,
    permanentRedirect: null,
    redirect: null,
    unauthorized: null,
    unstable_rethrow: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    ReadonlyURLSearchParams: function() {
        return ReadonlyURLSearchParams;
    },
    RedirectType: function() {
        return _redirecterror.RedirectType;
    },
    forbidden: function() {
        return _forbidden.forbidden;
    },
    notFound: function() {
        return _notfound.notFound;
    },
    permanentRedirect: function() {
        return _redirect.permanentRedirect;
    },
    redirect: function() {
        return _redirect.redirect;
    },
    unauthorized: function() {
        return _unauthorized.unauthorized;
    },
    unstable_rethrow: function() {
        return _unstablerethrow.unstable_rethrow;
    }
});
const _redirect = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/redirect.js [app-ssr] (ecmascript)");
const _redirecterror = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/redirect-error.js [app-ssr] (ecmascript)");
const _notfound = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/not-found.js [app-ssr] (ecmascript)");
const _forbidden = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/forbidden.js [app-ssr] (ecmascript)");
const _unauthorized = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/unauthorized.js [app-ssr] (ecmascript)");
const _unstablerethrow = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/unstable-rethrow.js [app-ssr] (ecmascript)");
class ReadonlyURLSearchParamsError extends Error {
    constructor(){
        super('Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams');
    }
}
class ReadonlyURLSearchParams extends URLSearchParams {
    /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */ append() {
        throw new ReadonlyURLSearchParamsError();
    }
    /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */ delete() {
        throw new ReadonlyURLSearchParamsError();
    }
    /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */ set() {
        throw new ReadonlyURLSearchParamsError();
    }
    /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */ sort() {
        throw new ReadonlyURLSearchParamsError();
    }
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=navigation.react-server.js.map
}}),
"[project]/node_modules/next/dist/client/components/bailout-to-client-rendering.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "bailoutToClientRendering", {
    enumerable: true,
    get: function() {
        return bailoutToClientRendering;
    }
});
const _bailouttocsr = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/lazy-dynamic/bailout-to-csr.js [app-ssr] (ecmascript)");
const _workasyncstorageexternal = __turbopack_context__.r("[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)");
const _workunitasyncstorageexternal = __turbopack_context__.r("[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)");
function bailoutToClientRendering(reason) {
    const workStore = _workasyncstorageexternal.workAsyncStorage.getStore();
    if (workStore == null ? void 0 : workStore.forceStatic) return;
    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
    if (workUnitStore) {
        switch(workUnitStore.type){
            case 'prerender':
            case 'prerender-client':
            case 'prerender-ppr':
            case 'prerender-legacy':
                throw Object.defineProperty(new _bailouttocsr.BailoutToCSRError(reason), "__NEXT_ERROR_CODE", {
                    value: "E394",
                    enumerable: false,
                    configurable: true
                });
            default:
        }
    }
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=bailout-to-client-rendering.js.map
}}),
"[project]/node_modules/next/dist/client/components/navigation.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    ReadonlyURLSearchParams: null,
    RedirectType: null,
    ServerInsertedHTMLContext: null,
    forbidden: null,
    notFound: null,
    permanentRedirect: null,
    redirect: null,
    unauthorized: null,
    unstable_rethrow: null,
    useParams: null,
    usePathname: null,
    useRouter: null,
    useSearchParams: null,
    useSelectedLayoutSegment: null,
    useSelectedLayoutSegments: null,
    useServerInsertedHTML: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    ReadonlyURLSearchParams: function() {
        return _navigationreactserver.ReadonlyURLSearchParams;
    },
    RedirectType: function() {
        return _navigationreactserver.RedirectType;
    },
    ServerInsertedHTMLContext: function() {
        return _serverinsertedhtmlsharedruntime.ServerInsertedHTMLContext;
    },
    forbidden: function() {
        return _navigationreactserver.forbidden;
    },
    notFound: function() {
        return _navigationreactserver.notFound;
    },
    permanentRedirect: function() {
        return _navigationreactserver.permanentRedirect;
    },
    redirect: function() {
        return _navigationreactserver.redirect;
    },
    unauthorized: function() {
        return _navigationreactserver.unauthorized;
    },
    unstable_rethrow: function() {
        return _navigationreactserver.unstable_rethrow;
    },
    useParams: function() {
        return useParams;
    },
    usePathname: function() {
        return usePathname;
    },
    useRouter: function() {
        return useRouter;
    },
    useSearchParams: function() {
        return useSearchParams;
    },
    useSelectedLayoutSegment: function() {
        return useSelectedLayoutSegment;
    },
    useSelectedLayoutSegments: function() {
        return useSelectedLayoutSegments;
    },
    useServerInsertedHTML: function() {
        return _serverinsertedhtmlsharedruntime.useServerInsertedHTML;
    }
});
const _react = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
const _approutercontextsharedruntime = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/contexts/app-router-context.js [app-ssr] (ecmascript)");
const _hooksclientcontextsharedruntime = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/contexts/hooks-client-context.js [app-ssr] (ecmascript)");
const _getsegmentvalue = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/reducers/get-segment-value.js [app-ssr] (ecmascript)");
const _segment = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/segment.js [app-ssr] (ecmascript)");
const _navigationreactserver = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/navigation.react-server.js [app-ssr] (ecmascript)");
const _serverinsertedhtmlsharedruntime = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/contexts/server-inserted-html.js [app-ssr] (ecmascript)");
const useDynamicRouteParams = ("TURBOPACK compile-time truthy", 1) ? __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/dynamic-rendering.js [app-ssr] (ecmascript)").useDynamicRouteParams : "TURBOPACK unreachable";
function useSearchParams() {
    const searchParams = (0, _react.useContext)(_hooksclientcontextsharedruntime.SearchParamsContext);
    // In the case where this is `null`, the compat types added in
    // `next-env.d.ts` will add a new overload that changes the return type to
    // include `null`.
    const readonlySearchParams = (0, _react.useMemo)(()=>{
        if (!searchParams) {
            // When the router is not ready in pages, we won't have the search params
            // available.
            return null;
        }
        return new _navigationreactserver.ReadonlyURLSearchParams(searchParams);
    }, [
        searchParams
    ]);
    if ("TURBOPACK compile-time truthy", 1) {
        // AsyncLocalStorage should not be included in the client bundle.
        const { bailoutToClientRendering } = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/bailout-to-client-rendering.js [app-ssr] (ecmascript)");
        // TODO-APP: handle dynamic = 'force-static' here and on the client
        bailoutToClientRendering('useSearchParams()');
    }
    return readonlySearchParams;
}
function usePathname() {
    useDynamicRouteParams == null ? void 0 : useDynamicRouteParams('usePathname()');
    // In the case where this is `null`, the compat types added in `next-env.d.ts`
    // will add a new overload that changes the return type to include `null`.
    return (0, _react.useContext)(_hooksclientcontextsharedruntime.PathnameContext);
}
function useRouter() {
    const router = (0, _react.useContext)(_approutercontextsharedruntime.AppRouterContext);
    if (router === null) {
        throw Object.defineProperty(new Error('invariant expected app router to be mounted'), "__NEXT_ERROR_CODE", {
            value: "E238",
            enumerable: false,
            configurable: true
        });
    }
    return router;
}
function useParams() {
    useDynamicRouteParams == null ? void 0 : useDynamicRouteParams('useParams()');
    return (0, _react.useContext)(_hooksclientcontextsharedruntime.PathParamsContext);
}
/** Get the canonical parameters from the current level to the leaf node. */ // Client components API
function getSelectedLayoutSegmentPath(tree, parallelRouteKey, first, segmentPath) {
    if (first === void 0) first = true;
    if (segmentPath === void 0) segmentPath = [];
    let node;
    if (first) {
        // Use the provided parallel route key on the first parallel route
        node = tree[1][parallelRouteKey];
    } else {
        // After first parallel route prefer children, if there's no children pick the first parallel route.
        const parallelRoutes = tree[1];
        var _parallelRoutes_children;
        node = (_parallelRoutes_children = parallelRoutes.children) != null ? _parallelRoutes_children : Object.values(parallelRoutes)[0];
    }
    if (!node) return segmentPath;
    const segment = node[0];
    let segmentValue = (0, _getsegmentvalue.getSegmentValue)(segment);
    if (!segmentValue || segmentValue.startsWith(_segment.PAGE_SEGMENT_KEY)) {
        return segmentPath;
    }
    segmentPath.push(segmentValue);
    return getSelectedLayoutSegmentPath(node, parallelRouteKey, false, segmentPath);
}
function useSelectedLayoutSegments(parallelRouteKey) {
    if (parallelRouteKey === void 0) parallelRouteKey = 'children';
    useDynamicRouteParams == null ? void 0 : useDynamicRouteParams('useSelectedLayoutSegments()');
    const context = (0, _react.useContext)(_approutercontextsharedruntime.LayoutRouterContext);
    // @ts-expect-error This only happens in `pages`. Type is overwritten in navigation.d.ts
    if (!context) return null;
    return getSelectedLayoutSegmentPath(context.parentTree, parallelRouteKey);
}
function useSelectedLayoutSegment(parallelRouteKey) {
    if (parallelRouteKey === void 0) parallelRouteKey = 'children';
    useDynamicRouteParams == null ? void 0 : useDynamicRouteParams('useSelectedLayoutSegment()');
    const selectedLayoutSegments = useSelectedLayoutSegments(parallelRouteKey);
    if (!selectedLayoutSegments || selectedLayoutSegments.length === 0) {
        return null;
    }
    const selectedLayoutSegment = parallelRouteKey === 'children' ? selectedLayoutSegments[0] : selectedLayoutSegments[selectedLayoutSegments.length - 1];
    // if the default slot is showing, we return null since it's not technically "selected" (it's a fallback)
    // and returning an internal value like `__DEFAULT__` would be confusing.
    return selectedLayoutSegment === _segment.DEFAULT_SEGMENT_KEY ? null : selectedLayoutSegment;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=navigation.js.map
}}),
"[project]/node_modules/next/navigation.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/navigation.js [app-ssr] (ecmascript)");
}}),
"[project]/node_modules/next/dist/shared/lib/router/utils/querystring.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    assign: null,
    searchParamsToUrlQuery: null,
    urlQueryToSearchParams: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    assign: function() {
        return assign;
    },
    searchParamsToUrlQuery: function() {
        return searchParamsToUrlQuery;
    },
    urlQueryToSearchParams: function() {
        return urlQueryToSearchParams;
    }
});
function searchParamsToUrlQuery(searchParams) {
    const query = {};
    for (const [key, value] of searchParams.entries()){
        const existing = query[key];
        if (typeof existing === 'undefined') {
            query[key] = value;
        } else if (Array.isArray(existing)) {
            existing.push(value);
        } else {
            query[key] = [
                existing,
                value
            ];
        }
    }
    return query;
}
function stringifyUrlQueryParam(param) {
    if (typeof param === 'string') {
        return param;
    }
    if (typeof param === 'number' && !isNaN(param) || typeof param === 'boolean') {
        return String(param);
    } else {
        return '';
    }
}
function urlQueryToSearchParams(query) {
    const searchParams = new URLSearchParams();
    for (const [key, value] of Object.entries(query)){
        if (Array.isArray(value)) {
            for (const item of value){
                searchParams.append(key, stringifyUrlQueryParam(item));
            }
        } else {
            searchParams.set(key, stringifyUrlQueryParam(value));
        }
    }
    return searchParams;
}
function assign(target) {
    for(var _len = arguments.length, searchParamsList = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
        searchParamsList[_key - 1] = arguments[_key];
    }
    for (const searchParams of searchParamsList){
        for (const key of searchParams.keys()){
            target.delete(key);
        }
        for (const [key, value] of searchParams.entries()){
            target.append(key, value);
        }
    }
    return target;
} //# sourceMappingURL=querystring.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/router/utils/format-url.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
// Format function modified from nodejs
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    formatUrl: null,
    formatWithValidation: null,
    urlObjectKeys: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    formatUrl: function() {
        return formatUrl;
    },
    formatWithValidation: function() {
        return formatWithValidation;
    },
    urlObjectKeys: function() {
        return urlObjectKeys;
    }
});
const _interop_require_wildcard = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [app-ssr] (ecmascript)");
const _querystring = /*#__PURE__*/ _interop_require_wildcard._(__turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/querystring.js [app-ssr] (ecmascript)"));
const slashedProtocols = /https?|ftp|gopher|file/;
function formatUrl(urlObj) {
    let { auth, hostname } = urlObj;
    let protocol = urlObj.protocol || '';
    let pathname = urlObj.pathname || '';
    let hash = urlObj.hash || '';
    let query = urlObj.query || '';
    let host = false;
    auth = auth ? encodeURIComponent(auth).replace(/%3A/i, ':') + '@' : '';
    if (urlObj.host) {
        host = auth + urlObj.host;
    } else if (hostname) {
        host = auth + (~hostname.indexOf(':') ? "[" + hostname + "]" : hostname);
        if (urlObj.port) {
            host += ':' + urlObj.port;
        }
    }
    if (query && typeof query === 'object') {
        query = String(_querystring.urlQueryToSearchParams(query));
    }
    let search = urlObj.search || query && "?" + query || '';
    if (protocol && !protocol.endsWith(':')) protocol += ':';
    if (urlObj.slashes || (!protocol || slashedProtocols.test(protocol)) && host !== false) {
        host = '//' + (host || '');
        if (pathname && pathname[0] !== '/') pathname = '/' + pathname;
    } else if (!host) {
        host = '';
    }
    if (hash && hash[0] !== '#') hash = '#' + hash;
    if (search && search[0] !== '?') search = '?' + search;
    pathname = pathname.replace(/[?#]/g, encodeURIComponent);
    search = search.replace('#', '%23');
    return "" + protocol + host + pathname + search + hash;
}
const urlObjectKeys = [
    'auth',
    'hash',
    'host',
    'hostname',
    'href',
    'path',
    'pathname',
    'port',
    'protocol',
    'query',
    'search',
    'slashes'
];
function formatWithValidation(url) {
    if ("TURBOPACK compile-time truthy", 1) {
        if (url !== null && typeof url === 'object') {
            Object.keys(url).forEach((key)=>{
                if (!urlObjectKeys.includes(key)) {
                    console.warn("Unknown key passed via urlObject into url.format: " + key);
                }
            });
        }
    }
    return formatUrl(url);
} //# sourceMappingURL=format-url.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/router-reducer-types.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    ACTION_HMR_REFRESH: null,
    ACTION_NAVIGATE: null,
    ACTION_PREFETCH: null,
    ACTION_REFRESH: null,
    ACTION_RESTORE: null,
    ACTION_SERVER_ACTION: null,
    ACTION_SERVER_PATCH: null,
    PrefetchCacheEntryStatus: null,
    PrefetchKind: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    ACTION_HMR_REFRESH: function() {
        return ACTION_HMR_REFRESH;
    },
    ACTION_NAVIGATE: function() {
        return ACTION_NAVIGATE;
    },
    ACTION_PREFETCH: function() {
        return ACTION_PREFETCH;
    },
    ACTION_REFRESH: function() {
        return ACTION_REFRESH;
    },
    ACTION_RESTORE: function() {
        return ACTION_RESTORE;
    },
    ACTION_SERVER_ACTION: function() {
        return ACTION_SERVER_ACTION;
    },
    ACTION_SERVER_PATCH: function() {
        return ACTION_SERVER_PATCH;
    },
    PrefetchCacheEntryStatus: function() {
        return PrefetchCacheEntryStatus;
    },
    PrefetchKind: function() {
        return PrefetchKind;
    }
});
const ACTION_REFRESH = 'refresh';
const ACTION_NAVIGATE = 'navigate';
const ACTION_RESTORE = 'restore';
const ACTION_SERVER_PATCH = 'server-patch';
const ACTION_PREFETCH = 'prefetch';
const ACTION_HMR_REFRESH = 'hmr-refresh';
const ACTION_SERVER_ACTION = 'server-action';
var PrefetchKind = /*#__PURE__*/ function(PrefetchKind) {
    PrefetchKind["AUTO"] = "auto";
    PrefetchKind["FULL"] = "full";
    PrefetchKind["TEMPORARY"] = "temporary";
    return PrefetchKind;
}({});
var PrefetchCacheEntryStatus = /*#__PURE__*/ function(PrefetchCacheEntryStatus) {
    PrefetchCacheEntryStatus["fresh"] = "fresh";
    PrefetchCacheEntryStatus["reusable"] = "reusable";
    PrefetchCacheEntryStatus["expired"] = "expired";
    PrefetchCacheEntryStatus["stale"] = "stale";
    return PrefetchCacheEntryStatus;
}({});
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=router-reducer-types.js.map
}}),
"[project]/node_modules/next/dist/client/use-merged-ref.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useMergedRef", {
    enumerable: true,
    get: function() {
        return useMergedRef;
    }
});
const _react = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
function useMergedRef(refA, refB) {
    const cleanupA = (0, _react.useRef)(null);
    const cleanupB = (0, _react.useRef)(null);
    // NOTE: In theory, we could skip the wrapping if only one of the refs is non-null.
    // (this happens often if the user doesn't pass a ref to Link/Form/Image)
    // But this can cause us to leak a cleanup-ref into user code (e.g. via `<Link legacyBehavior>`),
    // and the user might pass that ref into ref-merging library that doesn't support cleanup refs
    // (because it hasn't been updated for React 19)
    // which can then cause things to blow up, because a cleanup-returning ref gets called with `null`.
    // So in practice, it's safer to be defensive and always wrap the ref, even on React 19.
    return (0, _react.useCallback)((current)=>{
        if (current === null) {
            const cleanupFnA = cleanupA.current;
            if (cleanupFnA) {
                cleanupA.current = null;
                cleanupFnA();
            }
            const cleanupFnB = cleanupB.current;
            if (cleanupFnB) {
                cleanupB.current = null;
                cleanupFnB();
            }
        } else {
            if (refA) {
                cleanupA.current = applyRef(refA, current);
            }
            if (refB) {
                cleanupB.current = applyRef(refB, current);
            }
        }
    }, [
        refA,
        refB
    ]);
}
function applyRef(refA, current) {
    if (typeof refA === 'function') {
        const cleanup = refA(current);
        if (typeof cleanup === 'function') {
            return cleanup;
        } else {
            return ()=>refA(null);
        }
    } else {
        refA.current = current;
        return ()=>{
            refA.current = null;
        };
    }
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=use-merged-ref.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/utils.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    DecodeError: null,
    MiddlewareNotFoundError: null,
    MissingStaticPage: null,
    NormalizeError: null,
    PageNotFoundError: null,
    SP: null,
    ST: null,
    WEB_VITALS: null,
    execOnce: null,
    getDisplayName: null,
    getLocationOrigin: null,
    getURL: null,
    isAbsoluteUrl: null,
    isResSent: null,
    loadGetInitialProps: null,
    normalizeRepeatedSlashes: null,
    stringifyError: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    DecodeError: function() {
        return DecodeError;
    },
    MiddlewareNotFoundError: function() {
        return MiddlewareNotFoundError;
    },
    MissingStaticPage: function() {
        return MissingStaticPage;
    },
    NormalizeError: function() {
        return NormalizeError;
    },
    PageNotFoundError: function() {
        return PageNotFoundError;
    },
    SP: function() {
        return SP;
    },
    ST: function() {
        return ST;
    },
    WEB_VITALS: function() {
        return WEB_VITALS;
    },
    execOnce: function() {
        return execOnce;
    },
    getDisplayName: function() {
        return getDisplayName;
    },
    getLocationOrigin: function() {
        return getLocationOrigin;
    },
    getURL: function() {
        return getURL;
    },
    isAbsoluteUrl: function() {
        return isAbsoluteUrl;
    },
    isResSent: function() {
        return isResSent;
    },
    loadGetInitialProps: function() {
        return loadGetInitialProps;
    },
    normalizeRepeatedSlashes: function() {
        return normalizeRepeatedSlashes;
    },
    stringifyError: function() {
        return stringifyError;
    }
});
const WEB_VITALS = [
    'CLS',
    'FCP',
    'FID',
    'INP',
    'LCP',
    'TTFB'
];
function execOnce(fn) {
    let used = false;
    let result;
    return function() {
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        if (!used) {
            used = true;
            result = fn(...args);
        }
        return result;
    };
}
// Scheme: https://tools.ietf.org/html/rfc3986#section-3.1
// Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3
const ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\d+\-.]*?:/;
const isAbsoluteUrl = (url)=>ABSOLUTE_URL_REGEX.test(url);
function getLocationOrigin() {
    const { protocol, hostname, port } = window.location;
    return protocol + "//" + hostname + (port ? ':' + port : '');
}
function getURL() {
    const { href } = window.location;
    const origin = getLocationOrigin();
    return href.substring(origin.length);
}
function getDisplayName(Component) {
    return typeof Component === 'string' ? Component : Component.displayName || Component.name || 'Unknown';
}
function isResSent(res) {
    return res.finished || res.headersSent;
}
function normalizeRepeatedSlashes(url) {
    const urlParts = url.split('?');
    const urlNoQuery = urlParts[0];
    return urlNoQuery // first we replace any non-encoded backslashes with forward
    // then normalize repeated forward slashes
    .replace(/\\/g, '/').replace(/\/\/+/g, '/') + (urlParts[1] ? "?" + urlParts.slice(1).join('?') : '');
}
async function loadGetInitialProps(App, ctx) {
    if ("TURBOPACK compile-time truthy", 1) {
        var _App_prototype;
        if ((_App_prototype = App.prototype) == null ? void 0 : _App_prototype.getInitialProps) {
            const message = '"' + getDisplayName(App) + '.getInitialProps()" is defined as an instance method - visit https://nextjs.org/docs/messages/get-initial-props-as-an-instance-method for more information.';
            throw Object.defineProperty(new Error(message), "__NEXT_ERROR_CODE", {
                value: "E394",
                enumerable: false,
                configurable: true
            });
        }
    }
    // when called from _app `ctx` is nested in `ctx`
    const res = ctx.res || ctx.ctx && ctx.ctx.res;
    if (!App.getInitialProps) {
        if (ctx.ctx && ctx.Component) {
            // @ts-ignore pageProps default
            return {
                pageProps: await loadGetInitialProps(ctx.Component, ctx.ctx)
            };
        }
        return {};
    }
    const props = await App.getInitialProps(ctx);
    if (res && isResSent(res)) {
        return props;
    }
    if (!props) {
        const message = '"' + getDisplayName(App) + '.getInitialProps()" should resolve to an object. But found "' + props + '" instead.';
        throw Object.defineProperty(new Error(message), "__NEXT_ERROR_CODE", {
            value: "E394",
            enumerable: false,
            configurable: true
        });
    }
    if ("TURBOPACK compile-time truthy", 1) {
        if (Object.keys(props).length === 0 && !ctx.ctx) {
            console.warn("" + getDisplayName(App) + " returned an empty object from `getInitialProps`. This de-optimizes and prevents automatic static optimization. https://nextjs.org/docs/messages/empty-object-getInitialProps");
        }
    }
    return props;
}
const SP = typeof performance !== 'undefined';
const ST = SP && [
    'mark',
    'measure',
    'getEntriesByName'
].every((method)=>typeof performance[method] === 'function');
class DecodeError extends Error {
}
class NormalizeError extends Error {
}
class PageNotFoundError extends Error {
    constructor(page){
        super();
        this.code = 'ENOENT';
        this.name = 'PageNotFoundError';
        this.message = "Cannot find module for page: " + page;
    }
}
class MissingStaticPage extends Error {
    constructor(page, message){
        super();
        this.message = "Failed to load static file for page: " + page + " " + message;
    }
}
class MiddlewareNotFoundError extends Error {
    constructor(){
        super();
        this.code = 'ENOENT';
        this.message = "Cannot find the middleware module";
    }
}
function stringifyError(error) {
    return JSON.stringify({
        message: error.message,
        stack: error.stack
    });
} //# sourceMappingURL=utils.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/router/utils/parse-path.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/**
 * Given a path this function will find the pathname, query and hash and return
 * them. This is useful to parse full paths on the client side.
 * @param path A path to parse e.g. /foo/bar?id=1#hash
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "parsePath", {
    enumerable: true,
    get: function() {
        return parsePath;
    }
});
function parsePath(path) {
    const hashIndex = path.indexOf('#');
    const queryIndex = path.indexOf('?');
    const hasQuery = queryIndex > -1 && (hashIndex < 0 || queryIndex < hashIndex);
    if (hasQuery || hashIndex > -1) {
        return {
            pathname: path.substring(0, hasQuery ? queryIndex : hashIndex),
            query: hasQuery ? path.substring(queryIndex, hashIndex > -1 ? hashIndex : undefined) : '',
            hash: hashIndex > -1 ? path.slice(hashIndex) : ''
        };
    }
    return {
        pathname: path,
        query: '',
        hash: ''
    };
} //# sourceMappingURL=parse-path.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "addPathPrefix", {
    enumerable: true,
    get: function() {
        return addPathPrefix;
    }
});
const _parsepath = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/parse-path.js [app-ssr] (ecmascript)");
function addPathPrefix(path, prefix) {
    if (!path.startsWith('/') || !prefix) {
        return path;
    }
    const { pathname, query, hash } = (0, _parsepath.parsePath)(path);
    return "" + prefix + pathname + query + hash;
} //# sourceMappingURL=add-path-prefix.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/**
 * Removes the trailing slash for a given route or page path. Preserves the
 * root page. Examples:
 *   - `/foo/bar/` -> `/foo/bar`
 *   - `/foo/bar` -> `/foo/bar`
 *   - `/` -> `/`
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "removeTrailingSlash", {
    enumerable: true,
    get: function() {
        return removeTrailingSlash;
    }
});
function removeTrailingSlash(route) {
    return route.replace(/\/$/, '') || '/';
} //# sourceMappingURL=remove-trailing-slash.js.map
}}),
"[project]/node_modules/next/dist/client/normalize-trailing-slash.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "normalizePathTrailingSlash", {
    enumerable: true,
    get: function() {
        return normalizePathTrailingSlash;
    }
});
const _removetrailingslash = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js [app-ssr] (ecmascript)");
const _parsepath = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/parse-path.js [app-ssr] (ecmascript)");
const normalizePathTrailingSlash = (path)=>{
    if (!path.startsWith('/') || ("TURBOPACK compile-time value", void 0)) {
        return path;
    }
    const { pathname, query, hash } = (0, _parsepath.parsePath)(path);
    if ("TURBOPACK compile-time truthy", 1) {
        if (/\.[^/]+\/?$/.test(pathname)) {
            return "" + (0, _removetrailingslash.removeTrailingSlash)(pathname) + query + hash;
        } else if (pathname.endsWith('/')) {
            return "" + pathname + query + hash;
        } else {
            return pathname + "/" + query + hash;
        }
    }
    //TURBOPACK unreachable
    ;
};
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=normalize-trailing-slash.js.map
}}),
"[project]/node_modules/next/dist/client/add-base-path.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "addBasePath", {
    enumerable: true,
    get: function() {
        return addBasePath;
    }
});
const _addpathprefix = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js [app-ssr] (ecmascript)");
const _normalizetrailingslash = __turbopack_context__.r("[project]/node_modules/next/dist/client/normalize-trailing-slash.js [app-ssr] (ecmascript)");
const basePath = ("TURBOPACK compile-time value", "") || '';
function addBasePath(path, required) {
    return (0, _normalizetrailingslash.normalizePathTrailingSlash)(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : (0, _addpathprefix.addPathPrefix)(path, basePath));
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=add-base-path.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/utils/warn-once.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "warnOnce", {
    enumerable: true,
    get: function() {
        return warnOnce;
    }
});
let warnOnce = (_)=>{};
if ("TURBOPACK compile-time truthy", 1) {
    const warnings = new Set();
    warnOnce = (msg)=>{
        if (!warnings.has(msg)) {
            console.warn(msg);
        }
        warnings.add(msg);
    };
} //# sourceMappingURL=warn-once.js.map
}}),
"[project]/node_modules/next/dist/client/components/app-router-headers.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    ACTION_HEADER: null,
    FLIGHT_HEADERS: null,
    NEXT_ACTION_NOT_FOUND_HEADER: null,
    NEXT_DID_POSTPONE_HEADER: null,
    NEXT_HMR_REFRESH_HASH_COOKIE: null,
    NEXT_HMR_REFRESH_HEADER: null,
    NEXT_IS_PRERENDER_HEADER: null,
    NEXT_REWRITTEN_PATH_HEADER: null,
    NEXT_REWRITTEN_QUERY_HEADER: null,
    NEXT_ROUTER_PREFETCH_HEADER: null,
    NEXT_ROUTER_SEGMENT_PREFETCH_HEADER: null,
    NEXT_ROUTER_STALE_TIME_HEADER: null,
    NEXT_ROUTER_STATE_TREE_HEADER: null,
    NEXT_RSC_UNION_QUERY: null,
    NEXT_URL: null,
    RSC_CONTENT_TYPE_HEADER: null,
    RSC_HEADER: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    ACTION_HEADER: function() {
        return ACTION_HEADER;
    },
    FLIGHT_HEADERS: function() {
        return FLIGHT_HEADERS;
    },
    NEXT_ACTION_NOT_FOUND_HEADER: function() {
        return NEXT_ACTION_NOT_FOUND_HEADER;
    },
    NEXT_DID_POSTPONE_HEADER: function() {
        return NEXT_DID_POSTPONE_HEADER;
    },
    NEXT_HMR_REFRESH_HASH_COOKIE: function() {
        return NEXT_HMR_REFRESH_HASH_COOKIE;
    },
    NEXT_HMR_REFRESH_HEADER: function() {
        return NEXT_HMR_REFRESH_HEADER;
    },
    NEXT_IS_PRERENDER_HEADER: function() {
        return NEXT_IS_PRERENDER_HEADER;
    },
    NEXT_REWRITTEN_PATH_HEADER: function() {
        return NEXT_REWRITTEN_PATH_HEADER;
    },
    NEXT_REWRITTEN_QUERY_HEADER: function() {
        return NEXT_REWRITTEN_QUERY_HEADER;
    },
    NEXT_ROUTER_PREFETCH_HEADER: function() {
        return NEXT_ROUTER_PREFETCH_HEADER;
    },
    NEXT_ROUTER_SEGMENT_PREFETCH_HEADER: function() {
        return NEXT_ROUTER_SEGMENT_PREFETCH_HEADER;
    },
    NEXT_ROUTER_STALE_TIME_HEADER: function() {
        return NEXT_ROUTER_STALE_TIME_HEADER;
    },
    NEXT_ROUTER_STATE_TREE_HEADER: function() {
        return NEXT_ROUTER_STATE_TREE_HEADER;
    },
    NEXT_RSC_UNION_QUERY: function() {
        return NEXT_RSC_UNION_QUERY;
    },
    NEXT_URL: function() {
        return NEXT_URL;
    },
    RSC_CONTENT_TYPE_HEADER: function() {
        return RSC_CONTENT_TYPE_HEADER;
    },
    RSC_HEADER: function() {
        return RSC_HEADER;
    }
});
const RSC_HEADER = 'RSC';
const ACTION_HEADER = 'Next-Action';
const NEXT_ROUTER_STATE_TREE_HEADER = 'Next-Router-State-Tree';
const NEXT_ROUTER_PREFETCH_HEADER = 'Next-Router-Prefetch';
const NEXT_ROUTER_SEGMENT_PREFETCH_HEADER = 'Next-Router-Segment-Prefetch';
const NEXT_HMR_REFRESH_HEADER = 'Next-HMR-Refresh';
const NEXT_HMR_REFRESH_HASH_COOKIE = '__next_hmr_refresh_hash__';
const NEXT_URL = 'Next-Url';
const RSC_CONTENT_TYPE_HEADER = 'text/x-component';
const FLIGHT_HEADERS = [
    RSC_HEADER,
    NEXT_ROUTER_STATE_TREE_HEADER,
    NEXT_ROUTER_PREFETCH_HEADER,
    NEXT_HMR_REFRESH_HEADER,
    NEXT_ROUTER_SEGMENT_PREFETCH_HEADER
];
const NEXT_RSC_UNION_QUERY = '_rsc';
const NEXT_ROUTER_STALE_TIME_HEADER = 'x-nextjs-stale-time';
const NEXT_DID_POSTPONE_HEADER = 'x-nextjs-postponed';
const NEXT_REWRITTEN_PATH_HEADER = 'x-nextjs-rewritten-path';
const NEXT_REWRITTEN_QUERY_HEADER = 'x-nextjs-rewritten-query';
const NEXT_IS_PRERENDER_HEADER = 'x-nextjs-prerender';
const NEXT_ACTION_NOT_FOUND_HEADER = 'x-nextjs-action-not-found';
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=app-router-headers.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/is-thenable.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/**
 * Check to see if a value is Thenable.
 *
 * @param promise the maybe-thenable value
 * @returns true if the value is thenable
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "isThenable", {
    enumerable: true,
    get: function() {
        return isThenable;
    }
});
function isThenable(promise) {
    return promise !== null && typeof promise === 'object' && 'then' in promise && typeof promise.then === 'function';
} //# sourceMappingURL=is-thenable.js.map
}}),
"[project]/node_modules/next/dist/next-devtools/userspace/use-app-dev-rendering-indicator.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useAppDevRenderingIndicator", {
    enumerable: true,
    get: function() {
        return useAppDevRenderingIndicator;
    }
});
const _react = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
const _nextdevtools = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/next-devtools/index.js [app-ssr] (ecmascript)");
const useAppDevRenderingIndicator = ()=>{
    const [isPending, startTransition] = (0, _react.useTransition)();
    (0, _react.useEffect)(()=>{
        if (isPending) {
            _nextdevtools.dispatcher.renderingIndicatorShow();
        } else {
            _nextdevtools.dispatcher.renderingIndicatorHide();
        }
    }, [
        isPending
    ]);
    return startTransition;
};
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=use-app-dev-rendering-indicator.js.map
}}),
"[project]/node_modules/next/dist/client/components/use-action-queue.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    dispatchAppRouterAction: null,
    useActionQueue: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    dispatchAppRouterAction: function() {
        return dispatchAppRouterAction;
    },
    useActionQueue: function() {
        return useActionQueue;
    }
});
const _interop_require_wildcard = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [app-ssr] (ecmascript)");
const _react = /*#__PURE__*/ _interop_require_wildcard._(__turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)"));
const _isthenable = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/is-thenable.js [app-ssr] (ecmascript)");
// The app router state lives outside of React, so we can import the dispatch
// method directly wherever we need it, rather than passing it around via props
// or context.
let dispatch = null;
function dispatchAppRouterAction(action) {
    if (dispatch === null) {
        throw Object.defineProperty(new Error('Internal Next.js error: Router action dispatched before initialization.'), "__NEXT_ERROR_CODE", {
            value: "E668",
            enumerable: false,
            configurable: true
        });
    }
    dispatch(action);
}
function useActionQueue(actionQueue) {
    const [state, setState] = _react.default.useState(actionQueue.state);
    // Because of a known issue that requires to decode Flight streams inside the
    // render phase, we have to be a bit clever and assign the dispatch method to
    // a module-level variable upon initialization. The useState hook in this
    // module only exists to synchronize state that lives outside of React.
    // Ideally, what we'd do instead is pass the state as a prop to root.render;
    // this is conceptually how we're modeling the app router state, despite the
    // weird implementation details.
    if ("TURBOPACK compile-time truthy", 1) {
        const { useAppDevRenderingIndicator } = __turbopack_context__.r("[project]/node_modules/next/dist/next-devtools/userspace/use-app-dev-rendering-indicator.js [app-ssr] (ecmascript)");
        // eslint-disable-next-line react-hooks/rules-of-hooks
        const appDevRenderingIndicator = useAppDevRenderingIndicator();
        dispatch = (action)=>{
            appDevRenderingIndicator(()=>{
                actionQueue.dispatch(action, setState);
            });
        };
    } else //TURBOPACK unreachable
    ;
    return (0, _isthenable.isThenable)(state) ? (0, _react.use)(state) : state;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=use-action-queue.js.map
}}),
"[project]/node_modules/next/dist/client/app-call-server.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "callServer", {
    enumerable: true,
    get: function() {
        return callServer;
    }
});
const _react = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
const _routerreducertypes = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/router-reducer-types.js [app-ssr] (ecmascript)");
const _useactionqueue = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/use-action-queue.js [app-ssr] (ecmascript)");
async function callServer(actionId, actionArgs) {
    return new Promise((resolve, reject)=>{
        (0, _react.startTransition)(()=>{
            (0, _useactionqueue.dispatchAppRouterAction)({
                type: _routerreducertypes.ACTION_SERVER_ACTION,
                actionId,
                actionArgs,
                resolve,
                reject
            });
        });
    });
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=app-call-server.js.map
}}),
"[project]/node_modules/next/dist/client/app-find-source-map-url.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "findSourceMapURL", {
    enumerable: true,
    get: function() {
        return findSourceMapURL;
    }
});
const basePath = ("TURBOPACK compile-time value", "") || '';
const pathname = "" + basePath + "/__nextjs_source-map";
const findSourceMapURL = ("TURBOPACK compile-time truthy", 1) ? function findSourceMapURL(filename) {
    if (filename === '') {
        return null;
    }
    if (filename.startsWith(document.location.origin) && filename.includes('/_next/static')) {
        // This is a request for a client chunk. This can only happen when
        // using Turbopack. In this case, since we control how those source
        // maps are generated, we can safely assume that the sourceMappingURL
        // is relative to the filename, with an added `.map` extension. The
        // browser can just request this file, and it gets served through the
        // normal dev server, without the need to route this through
        // the `/__nextjs_source-map` dev middleware.
        return "" + filename + ".map";
    }
    const url = new URL(pathname, document.location.origin);
    url.searchParams.set('filename', filename);
    return url.href;
} : "TURBOPACK unreachable";
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=app-find-source-map-url.js.map
}}),
"[project]/node_modules/next/dist/client/flight-data-helpers.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    getFlightDataPartsFromPath: null,
    getNextFlightSegmentPath: null,
    normalizeFlightData: null,
    prepareFlightRouterStateForRequest: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    getFlightDataPartsFromPath: function() {
        return getFlightDataPartsFromPath;
    },
    getNextFlightSegmentPath: function() {
        return getNextFlightSegmentPath;
    },
    normalizeFlightData: function() {
        return normalizeFlightData;
    },
    prepareFlightRouterStateForRequest: function() {
        return prepareFlightRouterStateForRequest;
    }
});
const _segment = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/segment.js [app-ssr] (ecmascript)");
function getFlightDataPartsFromPath(flightDataPath) {
    // Pick the last 4 items from the `FlightDataPath` to get the [tree, seedData, viewport, isHeadPartial].
    const flightDataPathLength = 4;
    // tree, seedData, and head are *always* the last three items in the `FlightDataPath`.
    const [tree, seedData, head, isHeadPartial] = flightDataPath.slice(-flightDataPathLength);
    // The `FlightSegmentPath` is everything except the last three items. For a root render, it won't be present.
    const segmentPath = flightDataPath.slice(0, -flightDataPathLength);
    var _segmentPath_;
    return {
        // TODO: Unify these two segment path helpers. We are inconsistently pushing an empty segment ("")
        // to the start of the segment path in some places which makes it hard to use solely the segment path.
        // Look for "// TODO-APP: remove ''" in the codebase.
        pathToSegment: segmentPath.slice(0, -1),
        segmentPath,
        // if the `FlightDataPath` corresponds with the root, there'll be no segment path,
        // in which case we default to ''.
        segment: (_segmentPath_ = segmentPath[segmentPath.length - 1]) != null ? _segmentPath_ : '',
        tree,
        seedData,
        head,
        isHeadPartial,
        isRootRender: flightDataPath.length === flightDataPathLength
    };
}
function getNextFlightSegmentPath(flightSegmentPath) {
    // Since `FlightSegmentPath` is a repeated tuple of `Segment` and `ParallelRouteKey`, we slice off two items
    // to get the next segment path.
    return flightSegmentPath.slice(2);
}
function normalizeFlightData(flightData) {
    // FlightData can be a string when the server didn't respond with a proper flight response,
    // or when a redirect happens, to signal to the client that it needs to perform an MPA navigation.
    if (typeof flightData === 'string') {
        return flightData;
    }
    return flightData.map(getFlightDataPartsFromPath);
}
function prepareFlightRouterStateForRequest(flightRouterState, isHmrRefresh) {
    // HMR requests need the complete, unmodified state for proper functionality
    if (isHmrRefresh) {
        return encodeURIComponent(JSON.stringify(flightRouterState));
    }
    return encodeURIComponent(JSON.stringify(stripClientOnlyDataFromFlightRouterState(flightRouterState)));
}
/**
 * Recursively strips client-only data from FlightRouterState while preserving
 * server-needed information for proper rendering decisions.
 */ function stripClientOnlyDataFromFlightRouterState(flightRouterState) {
    const [segment, parallelRoutes, _url, refreshMarker, isRootLayout, hasLoadingBoundary] = flightRouterState;
    // __PAGE__ segments are always fetched from the server, so there's
    // no need to send them up
    const cleanedSegment = stripSearchParamsFromPageSegment(segment);
    // Recursively process parallel routes
    const cleanedParallelRoutes = {};
    for (const [key, childState] of Object.entries(parallelRoutes)){
        cleanedParallelRoutes[key] = stripClientOnlyDataFromFlightRouterState(childState);
    }
    const result = [
        cleanedSegment,
        cleanedParallelRoutes,
        null,
        shouldPreserveRefreshMarker(refreshMarker) ? refreshMarker : null
    ];
    // Append optional fields if present
    if (isRootLayout !== undefined) {
        result[4] = isRootLayout;
    }
    if (hasLoadingBoundary !== undefined) {
        result[5] = hasLoadingBoundary;
    }
    return result;
}
/**
 * Strips search parameters from __PAGE__ segments to prevent sensitive
 * client-side data from being sent to the server.
 */ function stripSearchParamsFromPageSegment(segment) {
    if (typeof segment === 'string' && segment.startsWith(_segment.PAGE_SEGMENT_KEY + '?')) {
        return _segment.PAGE_SEGMENT_KEY;
    }
    return segment;
}
/**
 * Determines whether the refresh marker should be sent to the server
 * Client-only markers like 'refresh' are stripped, while server-needed markers
 * like 'refetch' and 'inside-shared-layout' are preserved.
 */ function shouldPreserveRefreshMarker(refreshMarker) {
    return Boolean(refreshMarker && refreshMarker !== 'refresh');
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=flight-data-helpers.js.map
}}),
"[project]/node_modules/next/dist/client/app-build-id.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
// This gets assigned as a side-effect during app initialization. Because it
// represents the build used to create the JS bundle, it should never change
// after being set, so we store it in a global variable.
//
// When performing RSC requests, if the incoming data has a different build ID,
// we perform an MPA navigation/refresh to load the updated build and ensure
// that the client and server in sync.
// Starts as an empty string. In practice, because setAppBuildId is called
// during initialization before hydration starts, this will always get
// reassigned to the actual build ID before it's ever needed by a navigation.
// If for some reasons it didn't, due to a bug or race condition, then on
// navigation the build comparision would fail and trigger an MPA navigation.
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    getAppBuildId: null,
    setAppBuildId: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    getAppBuildId: function() {
        return getAppBuildId;
    },
    setAppBuildId: function() {
        return setAppBuildId;
    }
});
let globalBuildId = '';
function setAppBuildId(buildId) {
    globalBuildId = buildId;
}
function getAppBuildId() {
    return globalBuildId;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=app-build-id.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/hash.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
// http://www.cse.yorku.ca/~oz/hash.html
// More specifically, 32-bit hash via djbxor
// (ref: https://gist.github.com/eplawless/52813b1d8ad9af510d85?permalink_comment_id=3367765#gistcomment-3367765)
// This is due to number type differences between rust for turbopack to js number types,
// where rust does not have easy way to repreesnt js's 53-bit float number type for the matching
// overflow behavior. This is more `correct` in terms of having canonical hash across different runtime / implementation
// as can gaurantee determinstic output from 32bit hash.
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    djb2Hash: null,
    hexHash: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    djb2Hash: function() {
        return djb2Hash;
    },
    hexHash: function() {
        return hexHash;
    }
});
function djb2Hash(str) {
    let hash = 5381;
    for(let i = 0; i < str.length; i++){
        const char = str.charCodeAt(i);
        hash = (hash << 5) + hash + char & 0xffffffff;
    }
    return hash >>> 0;
}
function hexHash(str) {
    return djb2Hash(str).toString(36).slice(0, 5);
} //# sourceMappingURL=hash.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/router/utils/cache-busting-search-param.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "computeCacheBustingSearchParam", {
    enumerable: true,
    get: function() {
        return computeCacheBustingSearchParam;
    }
});
const _hash = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/hash.js [app-ssr] (ecmascript)");
function computeCacheBustingSearchParam(prefetchHeader, segmentPrefetchHeader, stateTreeHeader, nextUrlHeader) {
    if (prefetchHeader === undefined && segmentPrefetchHeader === undefined && stateTreeHeader === undefined && nextUrlHeader === undefined) {
        return '';
    }
    return (0, _hash.hexHash)([
        prefetchHeader || '0',
        segmentPrefetchHeader || '0',
        stateTreeHeader || '0',
        nextUrlHeader || '0'
    ].join(','));
} //# sourceMappingURL=cache-busting-search-param.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/set-cache-busting-search-param.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    setCacheBustingSearchParam: null,
    setCacheBustingSearchParamWithHash: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    setCacheBustingSearchParam: function() {
        return setCacheBustingSearchParam;
    },
    setCacheBustingSearchParamWithHash: function() {
        return setCacheBustingSearchParamWithHash;
    }
});
const _cachebustingsearchparam = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/cache-busting-search-param.js [app-ssr] (ecmascript)");
const _approuterheaders = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/app-router-headers.js [app-ssr] (ecmascript)");
const setCacheBustingSearchParam = (url, headers)=>{
    const uniqueCacheKey = (0, _cachebustingsearchparam.computeCacheBustingSearchParam)(headers[_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER], headers[_approuterheaders.NEXT_ROUTER_SEGMENT_PREFETCH_HEADER], headers[_approuterheaders.NEXT_ROUTER_STATE_TREE_HEADER], headers[_approuterheaders.NEXT_URL]);
    setCacheBustingSearchParamWithHash(url, uniqueCacheKey);
};
const setCacheBustingSearchParamWithHash = (url, hash)=>{
    /**
   * Note that we intentionally do not use `url.searchParams.set` here:
   *
   * const url = new URL('https://example.com/search?q=custom%20spacing');
   * url.searchParams.set('_rsc', 'abc123');
   * console.log(url.toString()); // Outputs: https://example.com/search?q=custom+spacing&_rsc=abc123
   *                                                                             ^ <--- this is causing confusion
   * This is in fact intended based on https://url.spec.whatwg.org/#interface-urlsearchparams, but
   * we want to preserve the %20 as %20 if that's what the user passed in, hence the custom
   * logic below.
   */ const existingSearch = url.search;
    const rawQuery = existingSearch.startsWith('?') ? existingSearch.slice(1) : existingSearch;
    // Always remove any existing cache busting param and add a fresh one to ensure
    // we have the correct value based on current request headers
    const pairs = rawQuery.split('&').filter((pair)=>pair && !pair.startsWith("" + _approuterheaders.NEXT_RSC_UNION_QUERY + "="));
    if (hash.length > 0) {
        pairs.push(_approuterheaders.NEXT_RSC_UNION_QUERY + "=" + hash);
    } else {
        pairs.push("" + _approuterheaders.NEXT_RSC_UNION_QUERY);
    }
    url.search = pairs.length ? "?" + pairs.join('&') : '';
};
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=set-cache-busting-search-param.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/fetch-server-response.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    createFetch: null,
    createFromNextReadableStream: null,
    fetchServerResponse: null,
    urlToUrlWithoutFlightMarker: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    createFetch: function() {
        return createFetch;
    },
    createFromNextReadableStream: function() {
        return createFromNextReadableStream;
    },
    fetchServerResponse: function() {
        return fetchServerResponse;
    },
    urlToUrlWithoutFlightMarker: function() {
        return urlToUrlWithoutFlightMarker;
    }
});
const _client = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-server-dom-turbopack-client.js [app-ssr] (ecmascript)");
const _approuterheaders = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/app-router-headers.js [app-ssr] (ecmascript)");
const _appcallserver = __turbopack_context__.r("[project]/node_modules/next/dist/client/app-call-server.js [app-ssr] (ecmascript)");
const _appfindsourcemapurl = __turbopack_context__.r("[project]/node_modules/next/dist/client/app-find-source-map-url.js [app-ssr] (ecmascript)");
const _routerreducertypes = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/router-reducer-types.js [app-ssr] (ecmascript)");
const _flightdatahelpers = __turbopack_context__.r("[project]/node_modules/next/dist/client/flight-data-helpers.js [app-ssr] (ecmascript)");
const _appbuildid = __turbopack_context__.r("[project]/node_modules/next/dist/client/app-build-id.js [app-ssr] (ecmascript)");
const _setcachebustingsearchparam = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/set-cache-busting-search-param.js [app-ssr] (ecmascript)");
const createFromReadableStream = _client.createFromReadableStream;
function urlToUrlWithoutFlightMarker(url) {
    const urlWithoutFlightParameters = new URL(url, location.origin);
    urlWithoutFlightParameters.searchParams.delete(_approuterheaders.NEXT_RSC_UNION_QUERY);
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    return urlWithoutFlightParameters;
}
function doMpaNavigation(url) {
    return {
        flightData: urlToUrlWithoutFlightMarker(url).toString(),
        canonicalUrl: undefined,
        couldBeIntercepted: false,
        prerendered: false,
        postponed: false,
        staleTime: -1
    };
}
let abortController = new AbortController();
if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
async function fetchServerResponse(url, options) {
    const { flightRouterState, nextUrl, prefetchKind } = options;
    const headers = {
        // Enable flight response
        [_approuterheaders.RSC_HEADER]: '1',
        // Provide the current router state
        [_approuterheaders.NEXT_ROUTER_STATE_TREE_HEADER]: (0, _flightdatahelpers.prepareFlightRouterStateForRequest)(flightRouterState, options.isHmrRefresh)
    };
    /**
   * Three cases:
   * - `prefetchKind` is `undefined`, it means it's a normal navigation, so we want to prefetch the page data fully
   * - `prefetchKind` is `full` - we want to prefetch the whole page so same as above
   * - `prefetchKind` is `auto` - if the page is dynamic, prefetch the page data partially, if static prefetch the page data fully
   */ if (prefetchKind === _routerreducertypes.PrefetchKind.AUTO) {
        headers[_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER] = '1';
    }
    if (("TURBOPACK compile-time value", "development") === 'development' && options.isHmrRefresh) {
        headers[_approuterheaders.NEXT_HMR_REFRESH_HEADER] = '1';
    }
    if (nextUrl) {
        headers[_approuterheaders.NEXT_URL] = nextUrl;
    }
    try {
        var _res_headers_get;
        // When creating a "temporary" prefetch (the "on-demand" prefetch that gets created on navigation, if one doesn't exist)
        // we send the request with a "high" priority as it's in response to a user interaction that could be blocking a transition.
        // Otherwise, all other prefetches are sent with a "low" priority.
        // We use "auto" for in all other cases to match the existing default, as this function is shared outside of prefetching.
        const fetchPriority = prefetchKind ? prefetchKind === _routerreducertypes.PrefetchKind.TEMPORARY ? 'high' : 'low' : 'auto';
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        const res = await createFetch(url, headers, fetchPriority, abortController.signal);
        const responseUrl = urlToUrlWithoutFlightMarker(res.url);
        const canonicalUrl = res.redirected ? responseUrl : undefined;
        const contentType = res.headers.get('content-type') || '';
        const interception = !!((_res_headers_get = res.headers.get('vary')) == null ? void 0 : _res_headers_get.includes(_approuterheaders.NEXT_URL));
        const postponed = !!res.headers.get(_approuterheaders.NEXT_DID_POSTPONE_HEADER);
        const staleTimeHeaderSeconds = res.headers.get(_approuterheaders.NEXT_ROUTER_STALE_TIME_HEADER);
        const staleTime = staleTimeHeaderSeconds !== null ? parseInt(staleTimeHeaderSeconds, 10) * 1000 : -1;
        let isFlightResponse = contentType.startsWith(_approuterheaders.RSC_CONTENT_TYPE_HEADER);
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        // If fetch returns something different than flight response handle it like a mpa navigation
        // If the fetch was not 200, we also handle it like a mpa navigation
        if (!isFlightResponse || !res.ok || !res.body) {
            // in case the original URL came with a hash, preserve it before redirecting to the new URL
            if (url.hash) {
                responseUrl.hash = url.hash;
            }
            return doMpaNavigation(responseUrl.toString());
        }
        // We may navigate to a page that requires a different Webpack runtime.
        // In prod, every page will have the same Webpack runtime.
        // In dev, the Webpack runtime is minimal for each page.
        // We need to ensure the Webpack runtime is updated before executing client-side JS of the new page.
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        // Handle the `fetch` readable stream that can be unwrapped by `React.use`.
        const flightStream = postponed ? createUnclosingPrefetchStream(res.body) : res.body;
        const response = await createFromNextReadableStream(flightStream);
        if ((0, _appbuildid.getAppBuildId)() !== response.b) {
            return doMpaNavigation(res.url);
        }
        return {
            flightData: (0, _flightdatahelpers.normalizeFlightData)(response.f),
            canonicalUrl: canonicalUrl,
            couldBeIntercepted: interception,
            prerendered: response.S,
            postponed,
            staleTime
        };
    } catch (err) {
        if (!abortController.signal.aborted) {
            console.error("Failed to fetch RSC payload for " + url + ". Falling back to browser navigation.", err);
        }
        // If fetch fails handle it like a mpa navigation
        // TODO-APP: Add a test for the case where a CORS request fails, e.g. external url redirect coming from the response.
        // See https://github.com/vercel/next.js/issues/43605#issuecomment-1451617521 for a reproduction.
        return {
            flightData: url.toString(),
            canonicalUrl: undefined,
            couldBeIntercepted: false,
            prerendered: false,
            postponed: false,
            staleTime: -1
        };
    }
}
async function createFetch(url, headers, fetchPriority, signal) {
    // TODO: In output: "export" mode, the headers do nothing. Omit them (and the
    // cache busting search param) from the request so they're
    // maximally cacheable.
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    const fetchOptions = {
        // Backwards compat for older browsers. `same-origin` is the default in modern browsers.
        credentials: 'same-origin',
        headers,
        priority: fetchPriority || undefined,
        signal
    };
    // `fetchUrl` is slightly different from `url` because we add a cache-busting
    // search param to it. This should not leak outside of this function, so we
    // track them separately.
    let fetchUrl = new URL(url);
    (0, _setcachebustingsearchparam.setCacheBustingSearchParam)(fetchUrl, headers);
    let browserResponse = await fetch(fetchUrl, fetchOptions);
    // If the server responds with a redirect (e.g. 307), and the redirected
    // location does not contain the cache busting search param set in the
    // original request, the response is likely invalid  when following the
    // redirect, the browser forwards the request headers, but since the cache
    // busting search param is missing, the server will reject the request due to
    // a mismatch.
    //
    // Ideally, we would be able to intercept the redirect response and perform it
    // manually, instead of letting the browser automatically follow it, but this
    // is not allowed by the fetch API.
    //
    // So instead, we must "replay" the redirect by fetching the new location
    // again, but this time we'll append the cache busting search param to prevent
    // a mismatch.
    //
    // TODO: We can optimize Next.js's built-in middleware APIs by returning a
    // custom status code, to prevent the browser from automatically following it.
    //
    // This does not affect Server Action-based redirects; those are encoded
    // differently, as part of the Flight body. It only affects redirects that
    // occur in a middleware or a third-party proxy.
    let redirected = browserResponse.redirected;
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    // Remove the cache busting search param from the response URL, to prevent it
    // from leaking outside of this function.
    const responseUrl = new URL(browserResponse.url, fetchUrl);
    responseUrl.searchParams.delete(_approuterheaders.NEXT_RSC_UNION_QUERY);
    const rscResponse = {
        url: responseUrl.href,
        // This is true if any redirects occurred, either automatically by the
        // browser, or manually by us. So it's different from
        // `browserResponse.redirected`, which only tells us whether the browser
        // followed a redirect, and only for the last response in the chain.
        redirected,
        // These can be copied from the last browser response we received. We
        // intentionally only expose the subset of fields that are actually used
        // elsewhere in the codebase.
        ok: browserResponse.ok,
        headers: browserResponse.headers,
        body: browserResponse.body,
        status: browserResponse.status
    };
    return rscResponse;
}
function createFromNextReadableStream(flightStream) {
    return createFromReadableStream(flightStream, {
        callServer: _appcallserver.callServer,
        findSourceMapURL: _appfindsourcemapurl.findSourceMapURL
    });
}
function createUnclosingPrefetchStream(originalFlightStream) {
    // When PPR is enabled, prefetch streams may contain references that never
    // resolve, because that's how we encode dynamic data access. In the decoded
    // object returned by the Flight client, these are reified into hanging
    // promises that suspend during render, which is effectively what we want.
    // The UI resolves when it switches to the dynamic data stream
    // (via useDeferredValue(dynamic, static)).
    //
    // However, the Flight implementation currently errors if the server closes
    // the response before all the references are resolved. As a cheat to work
    // around this, we wrap the original stream in a new stream that never closes,
    // and therefore doesn't error.
    const reader = originalFlightStream.getReader();
    return new ReadableStream({
        async pull (controller) {
            while(true){
                const { done, value } = await reader.read();
                if (!done) {
                    // Pass to the target stream and keep consuming the Flight response
                    // from the server.
                    controller.enqueue(value);
                    continue;
                }
                // The server stream has closed. Exit, but intentionally do not close
                // the target stream.
                return;
            }
        }
    });
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=fetch-server-response.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/create-href-from-url.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "createHrefFromUrl", {
    enumerable: true,
    get: function() {
        return createHrefFromUrl;
    }
});
function createHrefFromUrl(url, includeHash) {
    if (includeHash === void 0) includeHash = true;
    return url.pathname + url.search + (includeHash ? url.hash : '');
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=create-href-from-url.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "createRouterCacheKey", {
    enumerable: true,
    get: function() {
        return createRouterCacheKey;
    }
});
const _segment = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/segment.js [app-ssr] (ecmascript)");
function createRouterCacheKey(segment, withoutSearchParameters) {
    if (withoutSearchParameters === void 0) withoutSearchParameters = false;
    // if the segment is an array, it means it's a dynamic segment
    // for example, ['lang', 'en', 'd']. We need to convert it to a string to store it as a cache node key.
    if (Array.isArray(segment)) {
        return segment[0] + "|" + segment[1] + "|" + segment[2];
    }
    // Page segments might have search parameters, ie __PAGE__?foo=bar
    // When `withoutSearchParameters` is true, we only want to return the page segment
    if (withoutSearchParameters && segment.startsWith(_segment.PAGE_SEGMENT_KEY)) {
        return _segment.PAGE_SEGMENT_KEY;
    }
    return segment;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=create-router-cache-key.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/invalidate-cache-below-flight-segmentpath.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "invalidateCacheBelowFlightSegmentPath", {
    enumerable: true,
    get: function() {
        return invalidateCacheBelowFlightSegmentPath;
    }
});
const _createroutercachekey = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js [app-ssr] (ecmascript)");
const _flightdatahelpers = __turbopack_context__.r("[project]/node_modules/next/dist/client/flight-data-helpers.js [app-ssr] (ecmascript)");
function invalidateCacheBelowFlightSegmentPath(newCache, existingCache, flightSegmentPath) {
    const isLastEntry = flightSegmentPath.length <= 2;
    const [parallelRouteKey, segment] = flightSegmentPath;
    const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(segment);
    const existingChildSegmentMap = existingCache.parallelRoutes.get(parallelRouteKey);
    if (!existingChildSegmentMap) {
        // Bailout because the existing cache does not have the path to the leaf node
        // Will trigger lazy fetch in layout-router because of missing segment
        return;
    }
    let childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey);
    if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {
        childSegmentMap = new Map(existingChildSegmentMap);
        newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap);
    }
    // In case of last entry don't copy further down.
    if (isLastEntry) {
        childSegmentMap.delete(cacheKey);
        return;
    }
    const existingChildCacheNode = existingChildSegmentMap.get(cacheKey);
    let childCacheNode = childSegmentMap.get(cacheKey);
    if (!childCacheNode || !existingChildCacheNode) {
        // Bailout because the existing cache does not have the path to the leaf node
        // Will trigger lazy fetch in layout-router because of missing segment
        return;
    }
    if (childCacheNode === existingChildCacheNode) {
        childCacheNode = {
            lazyData: childCacheNode.lazyData,
            rsc: childCacheNode.rsc,
            prefetchRsc: childCacheNode.prefetchRsc,
            head: childCacheNode.head,
            prefetchHead: childCacheNode.prefetchHead,
            parallelRoutes: new Map(childCacheNode.parallelRoutes)
        };
        childSegmentMap.set(cacheKey, childCacheNode);
    }
    invalidateCacheBelowFlightSegmentPath(childCacheNode, existingChildCacheNode, (0, _flightdatahelpers.getNextFlightSegmentPath)(flightSegmentPath));
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=invalidate-cache-below-flight-segmentpath.js.map
}}),
"[project]/node_modules/next/dist/client/components/match-segments.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "matchSegment", {
    enumerable: true,
    get: function() {
        return matchSegment;
    }
});
const matchSegment = (existingSegment, segment)=>{
    // segment is either Array or string
    if (typeof existingSegment === 'string') {
        if (typeof segment === 'string') {
            // Common case: segment is just a string
            return existingSegment === segment;
        }
        return false;
    }
    if (typeof segment === 'string') {
        return false;
    }
    return existingSegment[0] === segment[0] && existingSegment[1] === segment[1];
};
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=match-segments.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "fillLazyItemsTillLeafWithHead", {
    enumerable: true,
    get: function() {
        return fillLazyItemsTillLeafWithHead;
    }
});
const _createroutercachekey = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js [app-ssr] (ecmascript)");
const _routerreducertypes = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/router-reducer-types.js [app-ssr] (ecmascript)");
function fillLazyItemsTillLeafWithHead(navigatedAt, newCache, existingCache, routerState, cacheNodeSeedData, head, prefetchEntry) {
    const isLastSegment = Object.keys(routerState[1]).length === 0;
    if (isLastSegment) {
        newCache.head = head;
        return;
    }
    // Remove segment that we got data for so that it is filled in during rendering of rsc.
    for(const key in routerState[1]){
        const parallelRouteState = routerState[1][key];
        const segmentForParallelRoute = parallelRouteState[0];
        const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(segmentForParallelRoute);
        // TODO: We should traverse the cacheNodeSeedData tree instead of the router
        // state tree. Ideally, they would always be the same shape, but because of
        // the loading.js pattern, cacheNodeSeedData sometimes only represents a
        // partial tree. That's why this node is sometimes null. Once PPR lands,
        // loading.js will no longer have special behavior and we can traverse the
        // data tree instead.
        //
        // We should also consider merging the router state tree and the data tree
        // in the response format, so that we don't have to send the keys twice.
        // Then the client can convert them into separate representations.
        const parallelSeedData = cacheNodeSeedData !== null && cacheNodeSeedData[2][key] !== undefined ? cacheNodeSeedData[2][key] : null;
        if (existingCache) {
            const existingParallelRoutesCacheNode = existingCache.parallelRoutes.get(key);
            if (existingParallelRoutesCacheNode) {
                const hasReusablePrefetch = (prefetchEntry == null ? void 0 : prefetchEntry.kind) === 'auto' && prefetchEntry.status === _routerreducertypes.PrefetchCacheEntryStatus.reusable;
                let parallelRouteCacheNode = new Map(existingParallelRoutesCacheNode);
                const existingCacheNode = parallelRouteCacheNode.get(cacheKey);
                let newCacheNode;
                if (parallelSeedData !== null) {
                    // New data was sent from the server.
                    const seedNode = parallelSeedData[1];
                    const loading = parallelSeedData[3];
                    newCacheNode = {
                        lazyData: null,
                        rsc: seedNode,
                        // This is a PPR-only field. When PPR is enabled, we shouldn't hit
                        // this path during a navigation, but until PPR is fully implemented
                        // yet it's possible the existing node does have a non-null
                        // `prefetchRsc`. As an incremental step, we'll just de-opt to the
                        // old behavior  no PPR value.
                        prefetchRsc: null,
                        head: null,
                        prefetchHead: null,
                        loading,
                        parallelRoutes: new Map(existingCacheNode == null ? void 0 : existingCacheNode.parallelRoutes),
                        navigatedAt
                    };
                } else if (hasReusablePrefetch && existingCacheNode) {
                    // No new data was sent from the server, but the existing cache node
                    // was prefetched, so we should reuse that.
                    newCacheNode = {
                        lazyData: existingCacheNode.lazyData,
                        rsc: existingCacheNode.rsc,
                        // This is a PPR-only field. Unlike the previous branch, since we're
                        // just cloning the existing cache node, we might as well keep the
                        // PPR value, if it exists.
                        prefetchRsc: existingCacheNode.prefetchRsc,
                        head: existingCacheNode.head,
                        prefetchHead: existingCacheNode.prefetchHead,
                        parallelRoutes: new Map(existingCacheNode.parallelRoutes),
                        loading: existingCacheNode.loading
                    };
                } else {
                    // No data available for this node. This will trigger a lazy fetch
                    // during render.
                    newCacheNode = {
                        lazyData: null,
                        rsc: null,
                        prefetchRsc: null,
                        head: null,
                        prefetchHead: null,
                        parallelRoutes: new Map(existingCacheNode == null ? void 0 : existingCacheNode.parallelRoutes),
                        loading: null,
                        navigatedAt
                    };
                }
                // Overrides the cache key with the new cache node.
                parallelRouteCacheNode.set(cacheKey, newCacheNode);
                // Traverse deeper to apply the head / fill lazy items till the head.
                fillLazyItemsTillLeafWithHead(navigatedAt, newCacheNode, existingCacheNode, parallelRouteState, parallelSeedData ? parallelSeedData : null, head, prefetchEntry);
                newCache.parallelRoutes.set(key, parallelRouteCacheNode);
                continue;
            }
        }
        let newCacheNode;
        if (parallelSeedData !== null) {
            // New data was sent from the server.
            const seedNode = parallelSeedData[1];
            const loading = parallelSeedData[3];
            newCacheNode = {
                lazyData: null,
                rsc: seedNode,
                prefetchRsc: null,
                head: null,
                prefetchHead: null,
                parallelRoutes: new Map(),
                loading,
                navigatedAt
            };
        } else {
            // No data available for this node. This will trigger a lazy fetch
            // during render.
            newCacheNode = {
                lazyData: null,
                rsc: null,
                prefetchRsc: null,
                head: null,
                prefetchHead: null,
                parallelRoutes: new Map(),
                loading: null,
                navigatedAt
            };
        }
        const existingParallelRoutes = newCache.parallelRoutes.get(key);
        if (existingParallelRoutes) {
            existingParallelRoutes.set(cacheKey, newCacheNode);
        } else {
            newCache.parallelRoutes.set(key, new Map([
                [
                    cacheKey,
                    newCacheNode
                ]
            ]));
        }
        fillLazyItemsTillLeafWithHead(navigatedAt, newCacheNode, undefined, parallelRouteState, parallelSeedData, head, prefetchEntry);
    }
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=fill-lazy-items-till-leaf-with-head.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/invalidate-cache-by-router-state.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "invalidateCacheByRouterState", {
    enumerable: true,
    get: function() {
        return invalidateCacheByRouterState;
    }
});
const _createroutercachekey = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js [app-ssr] (ecmascript)");
function invalidateCacheByRouterState(newCache, existingCache, routerState) {
    // Remove segment that we got data for so that it is filled in during rendering of rsc.
    for(const key in routerState[1]){
        const segmentForParallelRoute = routerState[1][key][0];
        const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(segmentForParallelRoute);
        const existingParallelRoutesCacheNode = existingCache.parallelRoutes.get(key);
        if (existingParallelRoutesCacheNode) {
            let parallelRouteCacheNode = new Map(existingParallelRoutesCacheNode);
            parallelRouteCacheNode.delete(cacheKey);
            newCache.parallelRoutes.set(key, parallelRouteCacheNode);
        }
    }
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=invalidate-cache-by-router-state.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/fill-cache-with-new-subtree-data.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    fillCacheWithNewSubTreeData: null,
    fillCacheWithNewSubTreeDataButOnlyLoading: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    fillCacheWithNewSubTreeData: function() {
        return fillCacheWithNewSubTreeData;
    },
    fillCacheWithNewSubTreeDataButOnlyLoading: function() {
        return fillCacheWithNewSubTreeDataButOnlyLoading;
    }
});
const _invalidatecachebyrouterstate = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/invalidate-cache-by-router-state.js [app-ssr] (ecmascript)");
const _filllazyitemstillleafwithhead = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js [app-ssr] (ecmascript)");
const _createroutercachekey = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js [app-ssr] (ecmascript)");
const _segment = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/segment.js [app-ssr] (ecmascript)");
/**
 * Common logic for filling cache with new sub tree data.
 */ function fillCacheHelper(navigatedAt, newCache, existingCache, flightData, prefetchEntry, fillLazyItems) {
    const { segmentPath, seedData: cacheNodeSeedData, tree: treePatch, head } = flightData;
    let newCacheNode = newCache;
    let existingCacheNode = existingCache;
    for(let i = 0; i < segmentPath.length; i += 2){
        const parallelRouteKey = segmentPath[i];
        const segment = segmentPath[i + 1];
        // segmentPath is a repeating tuple of parallelRouteKey and segment
        // we know we've hit the last entry we've reached our final pair
        const isLastEntry = i === segmentPath.length - 2;
        const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(segment);
        const existingChildSegmentMap = existingCacheNode.parallelRoutes.get(parallelRouteKey);
        if (!existingChildSegmentMap) {
            continue;
        }
        let childSegmentMap = newCacheNode.parallelRoutes.get(parallelRouteKey);
        if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {
            childSegmentMap = new Map(existingChildSegmentMap);
            newCacheNode.parallelRoutes.set(parallelRouteKey, childSegmentMap);
        }
        const existingChildCacheNode = existingChildSegmentMap.get(cacheKey);
        let childCacheNode = childSegmentMap.get(cacheKey);
        if (isLastEntry) {
            if (cacheNodeSeedData && (!childCacheNode || !childCacheNode.lazyData || childCacheNode === existingChildCacheNode)) {
                const incomingSegment = cacheNodeSeedData[0];
                const rsc = cacheNodeSeedData[1];
                const loading = cacheNodeSeedData[3];
                childCacheNode = {
                    lazyData: null,
                    // When `fillLazyItems` is false, we only want to fill the RSC data for the layout,
                    // not the page segment.
                    rsc: fillLazyItems || incomingSegment !== _segment.PAGE_SEGMENT_KEY ? rsc : null,
                    prefetchRsc: null,
                    head: null,
                    prefetchHead: null,
                    loading,
                    parallelRoutes: fillLazyItems && existingChildCacheNode ? new Map(existingChildCacheNode.parallelRoutes) : new Map(),
                    navigatedAt
                };
                if (existingChildCacheNode && fillLazyItems) {
                    (0, _invalidatecachebyrouterstate.invalidateCacheByRouterState)(childCacheNode, existingChildCacheNode, treePatch);
                }
                if (fillLazyItems) {
                    (0, _filllazyitemstillleafwithhead.fillLazyItemsTillLeafWithHead)(navigatedAt, childCacheNode, existingChildCacheNode, treePatch, cacheNodeSeedData, head, prefetchEntry);
                }
                childSegmentMap.set(cacheKey, childCacheNode);
            }
            continue;
        }
        if (!childCacheNode || !existingChildCacheNode) {
            continue;
        }
        if (childCacheNode === existingChildCacheNode) {
            childCacheNode = {
                lazyData: childCacheNode.lazyData,
                rsc: childCacheNode.rsc,
                prefetchRsc: childCacheNode.prefetchRsc,
                head: childCacheNode.head,
                prefetchHead: childCacheNode.prefetchHead,
                parallelRoutes: new Map(childCacheNode.parallelRoutes),
                loading: childCacheNode.loading
            };
            childSegmentMap.set(cacheKey, childCacheNode);
        }
        // Move deeper into the cache nodes
        newCacheNode = childCacheNode;
        existingCacheNode = existingChildCacheNode;
    }
}
function fillCacheWithNewSubTreeData(navigatedAt, newCache, existingCache, flightData, prefetchEntry) {
    fillCacheHelper(navigatedAt, newCache, existingCache, flightData, prefetchEntry, true);
}
function fillCacheWithNewSubTreeDataButOnlyLoading(navigatedAt, newCache, existingCache, flightData, prefetchEntry) {
    fillCacheHelper(navigatedAt, newCache, existingCache, flightData, prefetchEntry, false);
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=fill-cache-with-new-subtree-data.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/apply-flight-data.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "applyFlightData", {
    enumerable: true,
    get: function() {
        return applyFlightData;
    }
});
const _filllazyitemstillleafwithhead = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js [app-ssr] (ecmascript)");
const _fillcachewithnewsubtreedata = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/fill-cache-with-new-subtree-data.js [app-ssr] (ecmascript)");
function applyFlightData(navigatedAt, existingCache, cache, flightData, prefetchEntry) {
    // The one before last item is the router state tree patch
    const { tree: treePatch, seedData, head, isRootRender } = flightData;
    // Handles case where prefetch only returns the router tree patch without rendered components.
    if (seedData === null) {
        return false;
    }
    if (isRootRender) {
        const rsc = seedData[1];
        const loading = seedData[3];
        cache.loading = loading;
        cache.rsc = rsc;
        // This is a PPR-only field. When PPR is enabled, we shouldn't hit
        // this path during a navigation, but until PPR is fully implemented
        // yet it's possible the existing node does have a non-null
        // `prefetchRsc`. As an incremental step, we'll just de-opt to the
        // old behavior  no PPR value.
        cache.prefetchRsc = null;
        (0, _filllazyitemstillleafwithhead.fillLazyItemsTillLeafWithHead)(navigatedAt, cache, existingCache, treePatch, seedData, head, prefetchEntry);
    } else {
        // Copy rsc for the root node of the cache.
        cache.rsc = existingCache.rsc;
        // This is a PPR-only field. Unlike the previous branch, since we're
        // just cloning the existing cache node, we might as well keep the
        // PPR value, if it exists.
        cache.prefetchRsc = existingCache.prefetchRsc;
        cache.parallelRoutes = new Map(existingCache.parallelRoutes);
        cache.loading = existingCache.loading;
        // Create a copy of the existing cache with the rsc applied.
        (0, _fillcachewithnewsubtreedata.fillCacheWithNewSubTreeData)(navigatedAt, cache, existingCache, flightData, prefetchEntry);
    }
    return true;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=apply-flight-data.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/refetch-inactive-parallel-segments.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    addRefreshMarkerToActiveParallelSegments: null,
    refreshInactiveParallelSegments: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    addRefreshMarkerToActiveParallelSegments: function() {
        return addRefreshMarkerToActiveParallelSegments;
    },
    refreshInactiveParallelSegments: function() {
        return refreshInactiveParallelSegments;
    }
});
const _applyflightdata = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/apply-flight-data.js [app-ssr] (ecmascript)");
const _fetchserverresponse = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/fetch-server-response.js [app-ssr] (ecmascript)");
const _segment = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/segment.js [app-ssr] (ecmascript)");
async function refreshInactiveParallelSegments(options) {
    const fetchedSegments = new Set();
    await refreshInactiveParallelSegmentsImpl({
        ...options,
        rootTree: options.updatedTree,
        fetchedSegments
    });
}
async function refreshInactiveParallelSegmentsImpl(param) {
    let { navigatedAt, state, updatedTree, updatedCache, includeNextUrl, fetchedSegments, rootTree = updatedTree, canonicalUrl } = param;
    const [, parallelRoutes, refetchPath, refetchMarker] = updatedTree;
    const fetchPromises = [];
    if (refetchPath && refetchPath !== canonicalUrl && refetchMarker === 'refresh' && // it's possible for the tree to contain multiple segments that contain data at the same URL
    // we keep track of them so we can dedupe the requests
    !fetchedSegments.has(refetchPath)) {
        fetchedSegments.add(refetchPath) // Mark this URL as fetched
        ;
        // Eagerly kick off the fetch for the refetch path & the parallel routes. This should be fine to do as they each operate
        // independently on their own cache nodes, and `applyFlightData` will copy anything it doesn't care about from the existing cache.
        const fetchPromise = (0, _fetchserverresponse.fetchServerResponse)(new URL(refetchPath, location.origin), {
            // refetch from the root of the updated tree, otherwise it will be scoped to the current segment
            // and might not contain the data we need to patch in interception route data (such as dynamic params from a previous segment)
            flightRouterState: [
                rootTree[0],
                rootTree[1],
                rootTree[2],
                'refetch'
            ],
            nextUrl: includeNextUrl ? state.nextUrl : null
        }).then((param)=>{
            let { flightData } = param;
            if (typeof flightData !== 'string') {
                for (const flightDataPath of flightData){
                    // we only pass the new cache as this function is called after clearing the router cache
                    // and filling in the new page data from the server. Meaning the existing cache is actually the cache that's
                    // just been created & has been written to, but hasn't been "committed" yet.
                    (0, _applyflightdata.applyFlightData)(navigatedAt, updatedCache, updatedCache, flightDataPath);
                }
            } else {
            // When flightData is a string, it suggests that the server response should have triggered an MPA navigation
            // I'm not 100% sure of this decision, but it seems unlikely that we'd want to introduce a redirect side effect
            // when refreshing on-screen data, so handling this has been ommitted.
            }
        });
        fetchPromises.push(fetchPromise);
    }
    for(const key in parallelRoutes){
        const parallelFetchPromise = refreshInactiveParallelSegmentsImpl({
            navigatedAt,
            state,
            updatedTree: parallelRoutes[key],
            updatedCache,
            includeNextUrl,
            fetchedSegments,
            rootTree,
            canonicalUrl
        });
        fetchPromises.push(parallelFetchPromise);
    }
    await Promise.all(fetchPromises);
}
function addRefreshMarkerToActiveParallelSegments(tree, path) {
    const [segment, parallelRoutes, , refetchMarker] = tree;
    // a page segment might also contain concatenated search params, so we do a partial match on the key
    if (segment.includes(_segment.PAGE_SEGMENT_KEY) && refetchMarker !== 'refresh') {
        tree[2] = path;
        tree[3] = 'refresh';
    }
    for(const key in parallelRoutes){
        addRefreshMarkerToActiveParallelSegments(parallelRoutes[key], path);
    }
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=refetch-inactive-parallel-segments.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "applyRouterStatePatchToTree", {
    enumerable: true,
    get: function() {
        return applyRouterStatePatchToTree;
    }
});
const _segment = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/segment.js [app-ssr] (ecmascript)");
const _flightdatahelpers = __turbopack_context__.r("[project]/node_modules/next/dist/client/flight-data-helpers.js [app-ssr] (ecmascript)");
const _matchsegments = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/match-segments.js [app-ssr] (ecmascript)");
const _refetchinactiveparallelsegments = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/refetch-inactive-parallel-segments.js [app-ssr] (ecmascript)");
/**
 * Deep merge of the two router states. Parallel route keys are preserved if the patch doesn't have them.
 */ function applyPatch(initialTree, patchTree) {
    const [initialSegment, initialParallelRoutes] = initialTree;
    const [patchSegment, patchParallelRoutes] = patchTree;
    // if the applied patch segment is __DEFAULT__ then it can be ignored in favor of the initial tree
    // this is because the __DEFAULT__ segment is used as a placeholder on navigation
    if (patchSegment === _segment.DEFAULT_SEGMENT_KEY && initialSegment !== _segment.DEFAULT_SEGMENT_KEY) {
        return initialTree;
    }
    if ((0, _matchsegments.matchSegment)(initialSegment, patchSegment)) {
        const newParallelRoutes = {};
        for(const key in initialParallelRoutes){
            const isInPatchTreeParallelRoutes = typeof patchParallelRoutes[key] !== 'undefined';
            if (isInPatchTreeParallelRoutes) {
                newParallelRoutes[key] = applyPatch(initialParallelRoutes[key], patchParallelRoutes[key]);
            } else {
                newParallelRoutes[key] = initialParallelRoutes[key];
            }
        }
        for(const key in patchParallelRoutes){
            if (newParallelRoutes[key]) {
                continue;
            }
            newParallelRoutes[key] = patchParallelRoutes[key];
        }
        const tree = [
            initialSegment,
            newParallelRoutes
        ];
        // Copy over the existing tree
        if (initialTree[2]) {
            tree[2] = initialTree[2];
        }
        if (initialTree[3]) {
            tree[3] = initialTree[3];
        }
        if (initialTree[4]) {
            tree[4] = initialTree[4];
        }
        return tree;
    }
    return patchTree;
}
function applyRouterStatePatchToTree(flightSegmentPath, flightRouterState, treePatch, path) {
    const [segment, parallelRoutes, url, refetch, isRootLayout] = flightRouterState;
    // Root refresh
    if (flightSegmentPath.length === 1) {
        const tree = applyPatch(flightRouterState, treePatch);
        (0, _refetchinactiveparallelsegments.addRefreshMarkerToActiveParallelSegments)(tree, path);
        return tree;
    }
    const [currentSegment, parallelRouteKey] = flightSegmentPath;
    // Tree path returned from the server should always match up with the current tree in the browser
    if (!(0, _matchsegments.matchSegment)(currentSegment, segment)) {
        return null;
    }
    const lastSegment = flightSegmentPath.length === 2;
    let parallelRoutePatch;
    if (lastSegment) {
        parallelRoutePatch = applyPatch(parallelRoutes[parallelRouteKey], treePatch);
    } else {
        parallelRoutePatch = applyRouterStatePatchToTree((0, _flightdatahelpers.getNextFlightSegmentPath)(flightSegmentPath), parallelRoutes[parallelRouteKey], treePatch, path);
        if (parallelRoutePatch === null) {
            return null;
        }
    }
    const tree = [
        flightSegmentPath[0],
        {
            ...parallelRoutes,
            [parallelRouteKey]: parallelRoutePatch
        },
        url,
        refetch
    ];
    // Current segment is the root layout
    if (isRootLayout) {
        tree[4] = true;
    }
    (0, _refetchinactiveparallelsegments.addRefreshMarkerToActiveParallelSegments)(tree, path);
    return tree;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=apply-router-state-patch-to-tree.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/should-hard-navigate.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "shouldHardNavigate", {
    enumerable: true,
    get: function() {
        return shouldHardNavigate;
    }
});
const _flightdatahelpers = __turbopack_context__.r("[project]/node_modules/next/dist/client/flight-data-helpers.js [app-ssr] (ecmascript)");
const _matchsegments = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/match-segments.js [app-ssr] (ecmascript)");
function shouldHardNavigate(flightSegmentPath, flightRouterState) {
    const [segment, parallelRoutes] = flightRouterState;
    // TODO-APP: Check if `as` can be replaced.
    const [currentSegment, parallelRouteKey] = flightSegmentPath;
    // Check if current segment matches the existing segment.
    if (!(0, _matchsegments.matchSegment)(currentSegment, segment)) {
        // If dynamic parameter in tree doesn't match up with segment path a hard navigation is triggered.
        if (Array.isArray(currentSegment)) {
            return true;
        }
        // If the existing segment did not match soft navigation is triggered.
        return false;
    }
    const lastSegment = flightSegmentPath.length <= 2;
    if (lastSegment) {
        return false;
    }
    return shouldHardNavigate((0, _flightdatahelpers.getNextFlightSegmentPath)(flightSegmentPath), parallelRoutes[parallelRouteKey]);
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=should-hard-navigate.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "isNavigatingToNewRootLayout", {
    enumerable: true,
    get: function() {
        return isNavigatingToNewRootLayout;
    }
});
function isNavigatingToNewRootLayout(currentTree, nextTree) {
    // Compare segments
    const currentTreeSegment = currentTree[0];
    const nextTreeSegment = nextTree[0];
    // If any segment is different before we find the root layout, the root layout has changed.
    // E.g. /same/(group1)/layout.js -> /same/(group2)/layout.js
    // First segment is 'same' for both, keep looking. (group1) changed to (group2) before the root layout was found, it must have changed.
    if (Array.isArray(currentTreeSegment) && Array.isArray(nextTreeSegment)) {
        // Compare dynamic param name and type but ignore the value, different values would not affect the current root layout
        // /[name] - /slug1 and /slug2, both values (slug1 & slug2) still has the same layout /[name]/layout.js
        if (currentTreeSegment[0] !== nextTreeSegment[0] || currentTreeSegment[2] !== nextTreeSegment[2]) {
            return true;
        }
    } else if (currentTreeSegment !== nextTreeSegment) {
        return true;
    }
    // Current tree root layout found
    if (currentTree[4]) {
        // If the next tree doesn't have the root layout flag, it must have changed.
        return !nextTree[4];
    }
    // Current tree didn't have its root layout here, must have changed.
    if (nextTree[4]) {
        return true;
    }
    // We can't assume it's `parallelRoutes.children` here in case the root layout is `app/@something/layout.js`
    // But it's not possible to be more than one parallelRoutes before the root layout is found
    // TODO-APP: change to traverse all parallel routes
    const currentTreeChild = Object.values(currentTree[1])[0];
    const nextTreeChild = Object.values(nextTree[1])[0];
    if (!currentTreeChild || !nextTreeChild) return true;
    return isNavigatingToNewRootLayout(currentTreeChild, nextTreeChild);
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=is-navigating-to-new-root-layout.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/page-path/ensure-leading-slash.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/**
 * For a given page path, this function ensures that there is a leading slash.
 * If there is not a leading slash, one is added, otherwise it is noop.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "ensureLeadingSlash", {
    enumerable: true,
    get: function() {
        return ensureLeadingSlash;
    }
});
function ensureLeadingSlash(path) {
    return path.startsWith('/') ? path : "/" + path;
} //# sourceMappingURL=ensure-leading-slash.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/router/utils/app-paths.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    normalizeAppPath: null,
    normalizeRscURL: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    normalizeAppPath: function() {
        return normalizeAppPath;
    },
    normalizeRscURL: function() {
        return normalizeRscURL;
    }
});
const _ensureleadingslash = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/page-path/ensure-leading-slash.js [app-ssr] (ecmascript)");
const _segment = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/segment.js [app-ssr] (ecmascript)");
function normalizeAppPath(route) {
    return (0, _ensureleadingslash.ensureLeadingSlash)(route.split('/').reduce((pathname, segment, index, segments)=>{
        // Empty segments are ignored.
        if (!segment) {
            return pathname;
        }
        // Groups are ignored.
        if ((0, _segment.isGroupSegment)(segment)) {
            return pathname;
        }
        // Parallel segments are ignored.
        if (segment[0] === '@') {
            return pathname;
        }
        // The last segment (if it's a leaf) should be ignored.
        if ((segment === 'page' || segment === 'route') && index === segments.length - 1) {
            return pathname;
        }
        return pathname + "/" + segment;
    }, ''));
}
function normalizeRscURL(url) {
    return url.replace(/\.rsc($|\?)/, '$1');
} //# sourceMappingURL=app-paths.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/router/utils/interception-routes.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    INTERCEPTION_ROUTE_MARKERS: null,
    extractInterceptionRouteInformation: null,
    isInterceptionRouteAppPath: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    INTERCEPTION_ROUTE_MARKERS: function() {
        return INTERCEPTION_ROUTE_MARKERS;
    },
    extractInterceptionRouteInformation: function() {
        return extractInterceptionRouteInformation;
    },
    isInterceptionRouteAppPath: function() {
        return isInterceptionRouteAppPath;
    }
});
const _apppaths = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/app-paths.js [app-ssr] (ecmascript)");
const INTERCEPTION_ROUTE_MARKERS = [
    '(..)(..)',
    '(.)',
    '(..)',
    '(...)'
];
function isInterceptionRouteAppPath(path) {
    // TODO-APP: add more serious validation
    return path.split('/').find((segment)=>INTERCEPTION_ROUTE_MARKERS.find((m)=>segment.startsWith(m))) !== undefined;
}
function extractInterceptionRouteInformation(path) {
    let interceptingRoute, marker, interceptedRoute;
    for (const segment of path.split('/')){
        marker = INTERCEPTION_ROUTE_MARKERS.find((m)=>segment.startsWith(m));
        if (marker) {
            ;
            [interceptingRoute, interceptedRoute] = path.split(marker, 2);
            break;
        }
    }
    if (!interceptingRoute || !marker || !interceptedRoute) {
        throw Object.defineProperty(new Error("Invalid interception route: " + path + ". Must be in the format /<intercepting route>/(..|...|..)(..)/<intercepted route>"), "__NEXT_ERROR_CODE", {
            value: "E269",
            enumerable: false,
            configurable: true
        });
    }
    interceptingRoute = (0, _apppaths.normalizeAppPath)(interceptingRoute) // normalize the path, e.g. /(blog)/feed -> /feed
    ;
    switch(marker){
        case '(.)':
            // (.) indicates that we should match with sibling routes, so we just need to append the intercepted route to the intercepting route
            if (interceptingRoute === '/') {
                interceptedRoute = "/" + interceptedRoute;
            } else {
                interceptedRoute = interceptingRoute + '/' + interceptedRoute;
            }
            break;
        case '(..)':
            // (..) indicates that we should match at one level up, so we need to remove the last segment of the intercepting route
            if (interceptingRoute === '/') {
                throw Object.defineProperty(new Error("Invalid interception route: " + path + ". Cannot use (..) marker at the root level, use (.) instead."), "__NEXT_ERROR_CODE", {
                    value: "E207",
                    enumerable: false,
                    configurable: true
                });
            }
            interceptedRoute = interceptingRoute.split('/').slice(0, -1).concat(interceptedRoute).join('/');
            break;
        case '(...)':
            // (...) will match the route segment in the root directory, so we need to use the root directory to prepend the intercepted route
            interceptedRoute = '/' + interceptedRoute;
            break;
        case '(..)(..)':
            // (..)(..) indicates that we should match at two levels up, so we need to remove the last two segments of the intercepting route
            const splitInterceptingRoute = interceptingRoute.split('/');
            if (splitInterceptingRoute.length <= 2) {
                throw Object.defineProperty(new Error("Invalid interception route: " + path + ". Cannot use (..)(..) marker at the root level or one level up."), "__NEXT_ERROR_CODE", {
                    value: "E486",
                    enumerable: false,
                    configurable: true
                });
            }
            interceptedRoute = splitInterceptingRoute.slice(0, -2).concat(interceptedRoute).join('/');
            break;
        default:
            throw Object.defineProperty(new Error('Invariant: unexpected marker'), "__NEXT_ERROR_CODE", {
                value: "E112",
                enumerable: false,
                configurable: true
            });
    }
    return {
        interceptingRoute,
        interceptedRoute
    };
} //# sourceMappingURL=interception-routes.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/compute-changed-path.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    computeChangedPath: null,
    extractPathFromFlightRouterState: null,
    getSelectedParams: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    computeChangedPath: function() {
        return computeChangedPath;
    },
    extractPathFromFlightRouterState: function() {
        return extractPathFromFlightRouterState;
    },
    getSelectedParams: function() {
        return getSelectedParams;
    }
});
const _interceptionroutes = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/interception-routes.js [app-ssr] (ecmascript)");
const _segment = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/segment.js [app-ssr] (ecmascript)");
const _matchsegments = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/match-segments.js [app-ssr] (ecmascript)");
const removeLeadingSlash = (segment)=>{
    return segment[0] === '/' ? segment.slice(1) : segment;
};
const segmentToPathname = (segment)=>{
    if (typeof segment === 'string') {
        // 'children' is not a valid path -- it's technically a parallel route that corresponds with the current segment's page
        // if we don't skip it, then the computed pathname might be something like `/children` which doesn't make sense.
        if (segment === 'children') return '';
        return segment;
    }
    return segment[1];
};
function normalizeSegments(segments) {
    return segments.reduce((acc, segment)=>{
        segment = removeLeadingSlash(segment);
        if (segment === '' || (0, _segment.isGroupSegment)(segment)) {
            return acc;
        }
        return acc + "/" + segment;
    }, '') || '/';
}
function extractPathFromFlightRouterState(flightRouterState) {
    const segment = Array.isArray(flightRouterState[0]) ? flightRouterState[0][1] : flightRouterState[0];
    if (segment === _segment.DEFAULT_SEGMENT_KEY || _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.some((m)=>segment.startsWith(m))) return undefined;
    if (segment.startsWith(_segment.PAGE_SEGMENT_KEY)) return '';
    const segments = [
        segmentToPathname(segment)
    ];
    var _flightRouterState_;
    const parallelRoutes = (_flightRouterState_ = flightRouterState[1]) != null ? _flightRouterState_ : {};
    const childrenPath = parallelRoutes.children ? extractPathFromFlightRouterState(parallelRoutes.children) : undefined;
    if (childrenPath !== undefined) {
        segments.push(childrenPath);
    } else {
        for (const [key, value] of Object.entries(parallelRoutes)){
            if (key === 'children') continue;
            const childPath = extractPathFromFlightRouterState(value);
            if (childPath !== undefined) {
                segments.push(childPath);
            }
        }
    }
    return normalizeSegments(segments);
}
function computeChangedPathImpl(treeA, treeB) {
    const [segmentA, parallelRoutesA] = treeA;
    const [segmentB, parallelRoutesB] = treeB;
    const normalizedSegmentA = segmentToPathname(segmentA);
    const normalizedSegmentB = segmentToPathname(segmentB);
    if (_interceptionroutes.INTERCEPTION_ROUTE_MARKERS.some((m)=>normalizedSegmentA.startsWith(m) || normalizedSegmentB.startsWith(m))) {
        return '';
    }
    if (!(0, _matchsegments.matchSegment)(segmentA, segmentB)) {
        var _extractPathFromFlightRouterState;
        // once we find where the tree changed, we compute the rest of the path by traversing the tree
        return (_extractPathFromFlightRouterState = extractPathFromFlightRouterState(treeB)) != null ? _extractPathFromFlightRouterState : '';
    }
    for(const parallelRouterKey in parallelRoutesA){
        if (parallelRoutesB[parallelRouterKey]) {
            const changedPath = computeChangedPathImpl(parallelRoutesA[parallelRouterKey], parallelRoutesB[parallelRouterKey]);
            if (changedPath !== null) {
                return segmentToPathname(segmentB) + "/" + changedPath;
            }
        }
    }
    return null;
}
function computeChangedPath(treeA, treeB) {
    const changedPath = computeChangedPathImpl(treeA, treeB);
    if (changedPath == null || changedPath === '/') {
        return changedPath;
    }
    // lightweight normalization to remove route groups
    return normalizeSegments(changedPath.split('/'));
}
function getSelectedParams(currentTree, params) {
    if (params === void 0) params = {};
    const parallelRoutes = currentTree[1];
    for (const parallelRoute of Object.values(parallelRoutes)){
        const segment = parallelRoute[0];
        const isDynamicParameter = Array.isArray(segment);
        const segmentValue = isDynamicParameter ? segment[1] : segment;
        if (!segmentValue || segmentValue.startsWith(_segment.PAGE_SEGMENT_KEY)) continue;
        // Ensure catchAll and optional catchall are turned into an array
        const isCatchAll = isDynamicParameter && (segment[2] === 'c' || segment[2] === 'oc');
        if (isCatchAll) {
            params[segment[0]] = segment[1].split('/');
        } else if (isDynamicParameter) {
            params[segment[0]] = segment[1];
        }
        params = getSelectedParams(parallelRoute, params);
    }
    return params;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=compute-changed-path.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/handle-mutable.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "handleMutable", {
    enumerable: true,
    get: function() {
        return handleMutable;
    }
});
const _computechangedpath = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/compute-changed-path.js [app-ssr] (ecmascript)");
function isNotUndefined(value) {
    return typeof value !== 'undefined';
}
function handleMutable(state, mutable) {
    var _mutable_shouldScroll;
    // shouldScroll is true by default, can override to false.
    const shouldScroll = (_mutable_shouldScroll = mutable.shouldScroll) != null ? _mutable_shouldScroll : true;
    let nextUrl = state.nextUrl;
    if (isNotUndefined(mutable.patchedTree)) {
        // If we received a patched tree, we need to compute the changed path.
        const changedPath = (0, _computechangedpath.computeChangedPath)(state.tree, mutable.patchedTree);
        if (changedPath) {
            // If the tree changed, we need to update the nextUrl
            nextUrl = changedPath;
        } else if (!nextUrl) {
            // if the tree ends up being the same (ie, no changed path), and we don't have a nextUrl, then we should use the canonicalUrl
            nextUrl = state.canonicalUrl;
        }
    // otherwise this will be a no-op and continue to use the existing nextUrl
    }
    var _mutable_scrollableSegments;
    return {
        // Set href.
        canonicalUrl: isNotUndefined(mutable.canonicalUrl) ? mutable.canonicalUrl === state.canonicalUrl ? state.canonicalUrl : mutable.canonicalUrl : state.canonicalUrl,
        pushRef: {
            pendingPush: isNotUndefined(mutable.pendingPush) ? mutable.pendingPush : state.pushRef.pendingPush,
            mpaNavigation: isNotUndefined(mutable.mpaNavigation) ? mutable.mpaNavigation : state.pushRef.mpaNavigation,
            preserveCustomHistoryState: isNotUndefined(mutable.preserveCustomHistoryState) ? mutable.preserveCustomHistoryState : state.pushRef.preserveCustomHistoryState
        },
        // All navigation requires scroll and focus management to trigger.
        focusAndScrollRef: {
            apply: shouldScroll ? isNotUndefined(mutable == null ? void 0 : mutable.scrollableSegments) ? true : state.focusAndScrollRef.apply : false,
            onlyHashChange: mutable.onlyHashChange || false,
            hashFragment: shouldScroll ? mutable.hashFragment && mutable.hashFragment !== '' ? decodeURIComponent(mutable.hashFragment.slice(1)) : state.focusAndScrollRef.hashFragment : null,
            segmentPaths: shouldScroll ? (_mutable_scrollableSegments = mutable == null ? void 0 : mutable.scrollableSegments) != null ? _mutable_scrollableSegments : state.focusAndScrollRef.segmentPaths : []
        },
        // Apply cache.
        cache: mutable.cache ? mutable.cache : state.cache,
        prefetchCache: mutable.prefetchCache ? mutable.prefetchCache : state.prefetchCache,
        // Apply patched router state.
        tree: isNotUndefined(mutable.patchedTree) ? mutable.patchedTree : state.tree,
        nextUrl
    };
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=handle-mutable.js.map
}}),
"[project]/node_modules/next/dist/client/components/promise-queue.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*
    This is a simple promise queue that allows you to limit the number of concurrent promises
    that are running at any given time. It's used to limit the number of concurrent
    prefetch requests that are being made to the server but could be used for other
    things as well.
*/ Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "PromiseQueue", {
    enumerable: true,
    get: function() {
        return PromiseQueue;
    }
});
const _class_private_field_loose_base = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_class_private_field_loose_base.cjs [app-ssr] (ecmascript)");
const _class_private_field_loose_key = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_class_private_field_loose_key.cjs [app-ssr] (ecmascript)");
var _maxConcurrency = /*#__PURE__*/ _class_private_field_loose_key._("_maxConcurrency"), _runningCount = /*#__PURE__*/ _class_private_field_loose_key._("_runningCount"), _queue = /*#__PURE__*/ _class_private_field_loose_key._("_queue"), _processNext = /*#__PURE__*/ _class_private_field_loose_key._("_processNext");
class PromiseQueue {
    enqueue(promiseFn) {
        let taskResolve;
        let taskReject;
        const taskPromise = new Promise((resolve, reject)=>{
            taskResolve = resolve;
            taskReject = reject;
        });
        const task = async ()=>{
            try {
                _class_private_field_loose_base._(this, _runningCount)[_runningCount]++;
                const result = await promiseFn();
                taskResolve(result);
            } catch (error) {
                taskReject(error);
            } finally{
                _class_private_field_loose_base._(this, _runningCount)[_runningCount]--;
                _class_private_field_loose_base._(this, _processNext)[_processNext]();
            }
        };
        const enqueueResult = {
            promiseFn: taskPromise,
            task
        };
        // wonder if we should take a LIFO approach here
        _class_private_field_loose_base._(this, _queue)[_queue].push(enqueueResult);
        _class_private_field_loose_base._(this, _processNext)[_processNext]();
        return taskPromise;
    }
    bump(promiseFn) {
        const index = _class_private_field_loose_base._(this, _queue)[_queue].findIndex((item)=>item.promiseFn === promiseFn);
        if (index > -1) {
            const bumpedItem = _class_private_field_loose_base._(this, _queue)[_queue].splice(index, 1)[0];
            _class_private_field_loose_base._(this, _queue)[_queue].unshift(bumpedItem);
            _class_private_field_loose_base._(this, _processNext)[_processNext](true);
        }
    }
    constructor(maxConcurrency = 5){
        Object.defineProperty(this, _processNext, {
            value: processNext
        });
        Object.defineProperty(this, _maxConcurrency, {
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _runningCount, {
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _queue, {
            writable: true,
            value: void 0
        });
        _class_private_field_loose_base._(this, _maxConcurrency)[_maxConcurrency] = maxConcurrency;
        _class_private_field_loose_base._(this, _runningCount)[_runningCount] = 0;
        _class_private_field_loose_base._(this, _queue)[_queue] = [];
    }
}
function processNext(forced) {
    if (forced === void 0) forced = false;
    if ((_class_private_field_loose_base._(this, _runningCount)[_runningCount] < _class_private_field_loose_base._(this, _maxConcurrency)[_maxConcurrency] || forced) && _class_private_field_loose_base._(this, _queue)[_queue].length > 0) {
        var _class_private_field_loose_base__queue_shift;
        (_class_private_field_loose_base__queue_shift = _class_private_field_loose_base._(this, _queue)[_queue].shift()) == null ? void 0 : _class_private_field_loose_base__queue_shift.task();
    }
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=promise-queue.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    DYNAMIC_STALETIME_MS: null,
    STATIC_STALETIME_MS: null,
    createSeededPrefetchCacheEntry: null,
    getOrCreatePrefetchCacheEntry: null,
    prunePrefetchCache: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    DYNAMIC_STALETIME_MS: function() {
        return DYNAMIC_STALETIME_MS;
    },
    STATIC_STALETIME_MS: function() {
        return STATIC_STALETIME_MS;
    },
    createSeededPrefetchCacheEntry: function() {
        return createSeededPrefetchCacheEntry;
    },
    getOrCreatePrefetchCacheEntry: function() {
        return getOrCreatePrefetchCacheEntry;
    },
    prunePrefetchCache: function() {
        return prunePrefetchCache;
    }
});
const _fetchserverresponse = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/fetch-server-response.js [app-ssr] (ecmascript)");
const _routerreducertypes = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/router-reducer-types.js [app-ssr] (ecmascript)");
const _prefetchreducer = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js [app-ssr] (ecmascript)");
const INTERCEPTION_CACHE_KEY_MARKER = '%';
/**
 * Creates a cache key for the router prefetch cache
 *
 * @param url - The URL being navigated to
 * @param nextUrl - an internal URL, primarily used for handling rewrites. Defaults to '/'.
 * @return The generated prefetch cache key.
 */ function createPrefetchCacheKeyImpl(url, includeSearchParams, prefix) {
    // Initially we only use the pathname as the cache key. We don't want to include
    // search params so that multiple URLs with the same search parameter can re-use
    // loading states.
    let pathnameFromUrl = url.pathname;
    // RSC responses can differ based on search params, specifically in the case where we aren't
    // returning a partial response (ie with `PrefetchKind.AUTO`).
    // In the auto case, since loading.js & layout.js won't have access to search params,
    // we can safely re-use that cache entry. But for full prefetches, we should not
    // re-use the cache entry as the response may differ.
    if (includeSearchParams) {
        // if we have a full prefetch, we can include the search param in the key,
        // as we'll be getting back a full response. The server might have read the search
        // params when generating the full response.
        pathnameFromUrl += url.search;
    }
    if (prefix) {
        return "" + prefix + INTERCEPTION_CACHE_KEY_MARKER + pathnameFromUrl;
    }
    return pathnameFromUrl;
}
function createPrefetchCacheKey(url, kind, nextUrl) {
    return createPrefetchCacheKeyImpl(url, kind === _routerreducertypes.PrefetchKind.FULL, nextUrl);
}
function getExistingCacheEntry(url, kind, nextUrl, prefetchCache, allowAliasing) {
    if (kind === void 0) kind = _routerreducertypes.PrefetchKind.TEMPORARY;
    // We first check if there's a more specific interception route prefetch entry
    // This is because when we detect a prefetch that corresponds with an interception route, we prefix it with nextUrl (see `createPrefetchCacheKey`)
    // to avoid conflicts with other pages that may have the same URL but render different things depending on the `Next-URL` header.
    for (const maybeNextUrl of [
        nextUrl,
        null
    ]){
        const cacheKeyWithParams = createPrefetchCacheKeyImpl(url, true, maybeNextUrl);
        const cacheKeyWithoutParams = createPrefetchCacheKeyImpl(url, false, maybeNextUrl);
        // First, we check if we have a cache entry that exactly matches the URL
        const cacheKeyToUse = url.search ? cacheKeyWithParams : cacheKeyWithoutParams;
        const existingEntry = prefetchCache.get(cacheKeyToUse);
        if (existingEntry && allowAliasing) {
            // We know we're returning an aliased entry when the pathname matches but the search params don't,
            const isAliased = existingEntry.url.pathname === url.pathname && existingEntry.url.search !== url.search;
            if (isAliased) {
                return {
                    ...existingEntry,
                    aliased: true
                };
            }
            return existingEntry;
        }
        // If the request contains search params, and we're not doing a full prefetch, we can return the
        // param-less entry if it exists.
        // This is technically covered by the check at the bottom of this function, which iterates over cache entries,
        // but lets us arrive there quicker in the param-full case.
        const entryWithoutParams = prefetchCache.get(cacheKeyWithoutParams);
        if (("TURBOPACK compile-time value", "development") !== 'development' && allowAliasing && url.search && kind !== _routerreducertypes.PrefetchKind.FULL && entryWithoutParams && // We shouldn't return the aliased entry if it was relocated to a new cache key.
        // Since it's rewritten, it could respond with a completely different loading state.
        !entryWithoutParams.key.includes(INTERCEPTION_CACHE_KEY_MARKER)) //TURBOPACK unreachable
        ;
    }
    // If we've gotten to this point, we didn't find a specific cache entry that matched
    // the request URL.
    // We attempt a partial match by checking if there's a cache entry with the same pathname.
    // Regardless of what we find, since it doesn't correspond with the requested URL, we'll mark it "aliased".
    // This will signal to the router that it should only apply the loading state on the prefetched data.
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    return undefined;
}
function getOrCreatePrefetchCacheEntry(param) {
    let { url, nextUrl, tree, prefetchCache, kind, allowAliasing = true } = param;
    const existingCacheEntry = getExistingCacheEntry(url, kind, nextUrl, prefetchCache, allowAliasing);
    if (existingCacheEntry) {
        // Grab the latest status of the cache entry and update it
        existingCacheEntry.status = getPrefetchEntryCacheStatus(existingCacheEntry);
        // when `kind` is provided, an explicit prefetch was requested.
        // if the requested prefetch is "full" and the current cache entry wasn't, we want to re-prefetch with the new intent
        const switchedToFullPrefetch = existingCacheEntry.kind !== _routerreducertypes.PrefetchKind.FULL && kind === _routerreducertypes.PrefetchKind.FULL;
        if (switchedToFullPrefetch) {
            // If we switched to a full prefetch, validate that the existing cache entry contained partial data.
            // It's possible that the cache entry was seeded with full data but has a cache type of "auto" (ie when cache entries
            // are seeded but without a prefetch intent)
            existingCacheEntry.data.then((prefetchResponse)=>{
                const isFullPrefetch = Array.isArray(prefetchResponse.flightData) && prefetchResponse.flightData.some((flightData)=>{
                    // If we started rendering from the root and we returned RSC data (seedData), we already had a full prefetch.
                    return flightData.isRootRender && flightData.seedData !== null;
                });
                if (!isFullPrefetch) {
                    return createLazyPrefetchEntry({
                        tree,
                        url,
                        nextUrl,
                        prefetchCache,
                        // If we didn't get an explicit prefetch kind, we want to set a temporary kind
                        // rather than assuming the same intent as the previous entry, to be consistent with how we
                        // lazily create prefetch entries when intent is left unspecified.
                        kind: kind != null ? kind : _routerreducertypes.PrefetchKind.TEMPORARY
                    });
                }
            });
        }
        // If the existing cache entry was marked as temporary, it means it was lazily created when attempting to get an entry,
        // where we didn't have the prefetch intent. Now that we have the intent (in `kind`), we want to update the entry to the more accurate kind.
        if (kind && existingCacheEntry.kind === _routerreducertypes.PrefetchKind.TEMPORARY) {
            existingCacheEntry.kind = kind;
        }
        // We've determined that the existing entry we found is still valid, so we return it.
        return existingCacheEntry;
    }
    // If we didn't return an entry, create a new one.
    return createLazyPrefetchEntry({
        tree,
        url,
        nextUrl,
        prefetchCache,
        kind: kind || _routerreducertypes.PrefetchKind.TEMPORARY
    });
}
/*
 * Used to take an existing cache entry and prefix it with the nextUrl, if it exists.
 * This ensures that we don't have conflicting cache entries for the same URL (as is the case with route interception).
 */ function prefixExistingPrefetchCacheEntry(param) {
    let { url, nextUrl, prefetchCache, existingCacheKey } = param;
    const existingCacheEntry = prefetchCache.get(existingCacheKey);
    if (!existingCacheEntry) {
        // no-op -- there wasn't an entry to move
        return;
    }
    const newCacheKey = createPrefetchCacheKey(url, existingCacheEntry.kind, nextUrl);
    prefetchCache.set(newCacheKey, {
        ...existingCacheEntry,
        key: newCacheKey
    });
    prefetchCache.delete(existingCacheKey);
    return newCacheKey;
}
function createSeededPrefetchCacheEntry(param) {
    let { nextUrl, tree, prefetchCache, url, data, kind } = param;
    // The initial cache entry technically includes full data, but it isn't explicitly prefetched -- we just seed the
    // prefetch cache so that we can skip an extra prefetch request later, since we already have the data.
    // if the prefetch corresponds with an interception route, we use the nextUrl to prefix the cache key
    const prefetchCacheKey = data.couldBeIntercepted ? createPrefetchCacheKey(url, kind, nextUrl) : createPrefetchCacheKey(url, kind);
    const prefetchEntry = {
        treeAtTimeOfPrefetch: tree,
        data: Promise.resolve(data),
        kind,
        prefetchTime: Date.now(),
        lastUsedTime: Date.now(),
        staleTime: data.staleTime,
        key: prefetchCacheKey,
        status: _routerreducertypes.PrefetchCacheEntryStatus.fresh,
        url
    };
    prefetchCache.set(prefetchCacheKey, prefetchEntry);
    return prefetchEntry;
}
/**
 * Creates a prefetch entry entry and enqueues a fetch request to retrieve the data.
 */ function createLazyPrefetchEntry(param) {
    let { url, kind, tree, nextUrl, prefetchCache } = param;
    const prefetchCacheKey = createPrefetchCacheKey(url, kind);
    // initiates the fetch request for the prefetch and attaches a listener
    // to the promise to update the prefetch cache entry when the promise resolves (if necessary)
    const data = _prefetchreducer.prefetchQueue.enqueue(()=>(0, _fetchserverresponse.fetchServerResponse)(url, {
            flightRouterState: tree,
            nextUrl,
            prefetchKind: kind
        }).then((prefetchResponse)=>{
            // TODO: `fetchServerResponse` should be more tighly coupled to these prefetch cache operations
            // to avoid drift between this cache key prefixing logic
            // (which is currently directly influenced by the server response)
            let newCacheKey;
            if (prefetchResponse.couldBeIntercepted) {
                // Determine if we need to prefix the cache key with the nextUrl
                newCacheKey = prefixExistingPrefetchCacheEntry({
                    url,
                    existingCacheKey: prefetchCacheKey,
                    nextUrl,
                    prefetchCache
                });
            }
            // If the prefetch was a cache hit, we want to update the existing cache entry to reflect that it was a full prefetch.
            // This is because we know that a static response will contain the full RSC payload, and can be updated to respect the `static`
            // staleTime.
            if (prefetchResponse.prerendered) {
                const existingCacheEntry = prefetchCache.get(newCacheKey != null ? newCacheKey : prefetchCacheKey);
                if (existingCacheEntry) {
                    existingCacheEntry.kind = _routerreducertypes.PrefetchKind.FULL;
                    if (prefetchResponse.staleTime !== -1) {
                        // This is the stale time that was collected by the server during
                        // static generation. Use this in place of the default stale time.
                        existingCacheEntry.staleTime = prefetchResponse.staleTime;
                    }
                }
            }
            return prefetchResponse;
        }));
    const prefetchEntry = {
        treeAtTimeOfPrefetch: tree,
        data,
        kind,
        prefetchTime: Date.now(),
        lastUsedTime: null,
        staleTime: -1,
        key: prefetchCacheKey,
        status: _routerreducertypes.PrefetchCacheEntryStatus.fresh,
        url
    };
    prefetchCache.set(prefetchCacheKey, prefetchEntry);
    return prefetchEntry;
}
function prunePrefetchCache(prefetchCache) {
    for (const [href, prefetchCacheEntry] of prefetchCache){
        if (getPrefetchEntryCacheStatus(prefetchCacheEntry) === _routerreducertypes.PrefetchCacheEntryStatus.expired) {
            prefetchCache.delete(href);
        }
    }
}
const DYNAMIC_STALETIME_MS = Number(("TURBOPACK compile-time value", "0")) * 1000;
const STATIC_STALETIME_MS = Number(("TURBOPACK compile-time value", "300")) * 1000;
function getPrefetchEntryCacheStatus(param) {
    let { kind, prefetchTime, lastUsedTime, staleTime } = param;
    if (staleTime !== -1) {
        // `staleTime` is the value sent by the server during static generation.
        // When this is available, it takes precedence over any of the heuristics
        // that follow.
        //
        // TODO: When PPR is enabled, the server will *always* return a stale time
        // when prefetching. We should never use a prefetch entry that hasn't yet
        // received data from the server. So the only two cases should be 1) we use
        // the server-generated stale time 2) the unresolved entry is discarded.
        return Date.now() < prefetchTime + staleTime ? _routerreducertypes.PrefetchCacheEntryStatus.fresh : _routerreducertypes.PrefetchCacheEntryStatus.stale;
    }
    // We will re-use the cache entry data for up to the `dynamic` staletime window.
    if (Date.now() < (lastUsedTime != null ? lastUsedTime : prefetchTime) + DYNAMIC_STALETIME_MS) {
        return lastUsedTime ? _routerreducertypes.PrefetchCacheEntryStatus.reusable : _routerreducertypes.PrefetchCacheEntryStatus.fresh;
    }
    // For "auto" prefetching, we'll re-use only the loading boundary for up to `static` staletime window.
    // A stale entry will only re-use the `loading` boundary, not the full data.
    // This will trigger a "lazy fetch" for the full data.
    if (kind === _routerreducertypes.PrefetchKind.AUTO) {
        if (Date.now() < prefetchTime + STATIC_STALETIME_MS) {
            return _routerreducertypes.PrefetchCacheEntryStatus.stale;
        }
    }
    // for "full" prefetching, we'll re-use the cache entry data for up to `static` staletime window.
    if (kind === _routerreducertypes.PrefetchKind.FULL) {
        if (Date.now() < prefetchTime + STATIC_STALETIME_MS) {
            return _routerreducertypes.PrefetchCacheEntryStatus.reusable;
        }
    }
    return _routerreducertypes.PrefetchCacheEntryStatus.expired;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=prefetch-cache-utils.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    prefetchQueue: null,
    prefetchReducer: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    prefetchQueue: function() {
        return prefetchQueue;
    },
    prefetchReducer: function() {
        return prefetchReducer;
    }
});
const _promisequeue = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/promise-queue.js [app-ssr] (ecmascript)");
const _prefetchcacheutils = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js [app-ssr] (ecmascript)");
const prefetchQueue = new _promisequeue.PromiseQueue(5);
const prefetchReducer = ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : prefetchReducerImpl;
function identityReducerWhenSegmentCacheIsEnabled(state) {
    // Unlike the old implementation, the Segment Cache doesn't store its data in
    // the router reducer state.
    //
    // This shouldn't be reachable because we wrap the prefetch API in a check,
    // too, which prevents the action from being dispatched. But it's here for
    // clarity + code elimination.
    return state;
}
function prefetchReducerImpl(state, action) {
    // let's prune the prefetch cache before we do anything else
    (0, _prefetchcacheutils.prunePrefetchCache)(state.prefetchCache);
    const { url } = action;
    (0, _prefetchcacheutils.getOrCreatePrefetchCacheEntry)({
        url,
        nextUrl: state.nextUrl,
        prefetchCache: state.prefetchCache,
        kind: action.kind,
        tree: state.tree,
        allowAliasing: true
    });
    return state;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=prefetch-reducer.js.map
}}),
"[project]/node_modules/next/dist/client/components/navigation-untracked.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useUntrackedPathname", {
    enumerable: true,
    get: function() {
        return useUntrackedPathname;
    }
});
const _react = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
const _hooksclientcontextsharedruntime = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/contexts/hooks-client-context.js [app-ssr] (ecmascript)");
/**
 * This checks to see if the current render has any unknown route parameters.
 * It's used to trigger a different render path in the error boundary.
 *
 * @returns true if there are any unknown route parameters, false otherwise
 */ function hasFallbackRouteParams() {
    if ("TURBOPACK compile-time truthy", 1) {
        // AsyncLocalStorage should not be included in the client bundle.
        const { workAsyncStorage } = __turbopack_context__.r("[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)");
        const workStore = workAsyncStorage.getStore();
        if (!workStore) return false;
        const { fallbackRouteParams } = workStore;
        if (!fallbackRouteParams || fallbackRouteParams.size === 0) return false;
        return true;
    }
    //TURBOPACK unreachable
    ;
}
function useUntrackedPathname() {
    // If there are any unknown route parameters we would typically throw
    // an error, but this internal method allows us to return a null value instead
    // for components that do not propagate the pathname to the static shell (like
    // the error boundary).
    if (hasFallbackRouteParams()) {
        return null;
    }
    // This shouldn't cause any issues related to conditional rendering because
    // the environment will be consistent for the render.
    // eslint-disable-next-line react-hooks/rules-of-hooks
    return (0, _react.useContext)(_hooksclientcontextsharedruntime.PathnameContext);
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=navigation-untracked.js.map
}}),
"[project]/node_modules/next/dist/client/components/nav-failure-handler.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    handleHardNavError: null,
    useNavFailureHandler: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    handleHardNavError: function() {
        return handleHardNavError;
    },
    useNavFailureHandler: function() {
        return useNavFailureHandler;
    }
});
const _react = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
const _createhreffromurl = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/create-href-from-url.js [app-ssr] (ecmascript)");
function handleHardNavError(error) {
    if (error && "undefined" !== 'undefined' && window.next.__pendingUrl && (0, _createhreffromurl.createHrefFromUrl)(new URL(window.location.href)) !== (0, _createhreffromurl.createHrefFromUrl)(window.next.__pendingUrl)) //TURBOPACK unreachable
    ;
    return false;
}
function useNavFailureHandler() {
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=nav-failure-handler.js.map
}}),
"[project]/node_modules/next/dist/client/components/handle-isr-error.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "HandleISRError", {
    enumerable: true,
    get: function() {
        return HandleISRError;
    }
});
const workAsyncStorage = ("TURBOPACK compile-time truthy", 1) ? __turbopack_context__.r("[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)").workAsyncStorage : "TURBOPACK unreachable";
function HandleISRError(param) {
    let { error } = param;
    if (workAsyncStorage) {
        const store = workAsyncStorage.getStore();
        if ((store == null ? void 0 : store.isRevalidate) || (store == null ? void 0 : store.isStaticGeneration)) {
            console.error(error);
            throw error;
        }
    }
    return null;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=handle-isr-error.js.map
}}),
"[project]/node_modules/next/dist/client/components/error-boundary.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    ErrorBoundary: null,
    ErrorBoundaryHandler: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    ErrorBoundary: function() {
        return ErrorBoundary;
    },
    ErrorBoundaryHandler: function() {
        return ErrorBoundaryHandler;
    }
});
const _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-ssr] (ecmascript)");
const _jsxruntime = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js [app-ssr] (ecmascript)");
const _react = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)"));
const _navigationuntracked = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/navigation-untracked.js [app-ssr] (ecmascript)");
const _isnextroutererror = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/is-next-router-error.js [app-ssr] (ecmascript)");
const _navfailurehandler = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/nav-failure-handler.js [app-ssr] (ecmascript)");
const _handleisrerror = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/handle-isr-error.js [app-ssr] (ecmascript)");
class ErrorBoundaryHandler extends _react.default.Component {
    static getDerivedStateFromError(error) {
        if ((0, _isnextroutererror.isNextRouterError)(error)) {
            // Re-throw if an expected internal Next.js router error occurs
            // this means it should be handled by a different boundary (such as a NotFound boundary in a parent segment)
            throw error;
        }
        return {
            error
        };
    }
    static getDerivedStateFromProps(props, state) {
        const { error } = state;
        // if we encounter an error while
        // a navigation is pending we shouldn't render
        // the error boundary and instead should fallback
        // to a hard navigation to attempt recovering
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        /**
     * Handles reset of the error boundary when a navigation happens.
     * Ensures the error boundary does not stay enabled when navigating to a new page.
     * Approach of setState in render is safe as it checks the previous pathname and then overrides
     * it as outlined in https://react.dev/reference/react/useState#storing-information-from-previous-renders
     */ if (props.pathname !== state.previousPathname && state.error) {
            return {
                error: null,
                previousPathname: props.pathname
            };
        }
        return {
            error: state.error,
            previousPathname: props.pathname
        };
    }
    // Explicit type is needed to avoid the generated `.d.ts` having a wide return type that could be specific to the `@types/react` version.
    render() {
        if (this.state.error) {
            return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
                children: [
                    /*#__PURE__*/ (0, _jsxruntime.jsx)(_handleisrerror.HandleISRError, {
                        error: this.state.error
                    }),
                    this.props.errorStyles,
                    this.props.errorScripts,
                    /*#__PURE__*/ (0, _jsxruntime.jsx)(this.props.errorComponent, {
                        error: this.state.error,
                        reset: this.reset
                    })
                ]
            });
        }
        return this.props.children;
    }
    constructor(props){
        super(props), this.reset = ()=>{
            this.setState({
                error: null
            });
        };
        this.state = {
            error: null,
            previousPathname: this.props.pathname
        };
    }
}
function ErrorBoundary(param) {
    let { errorComponent, errorStyles, errorScripts, children } = param;
    // When we're rendering the missing params shell, this will return null. This
    // is because we won't be rendering any not found boundaries or error
    // boundaries for the missing params shell. When this runs on the client
    // (where these errors can occur), we will get the correct pathname.
    const pathname = (0, _navigationuntracked.useUntrackedPathname)();
    if (errorComponent) {
        return /*#__PURE__*/ (0, _jsxruntime.jsx)(ErrorBoundaryHandler, {
            pathname: pathname,
            errorComponent: errorComponent,
            errorStyles: errorStyles,
            errorScripts: errorScripts,
            children: children
        });
    }
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_jsxruntime.Fragment, {
        children: children
    });
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=error-boundary.js.map
}}),
"[project]/node_modules/next/dist/client/components/builtin/global-error.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, // supplied custom global error signatures.
"default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
const _jsxruntime = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js [app-ssr] (ecmascript)");
const _handleisrerror = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/handle-isr-error.js [app-ssr] (ecmascript)");
const styles = {
    error: {
        // https://github.com/sindresorhus/modern-normalize/blob/main/modern-normalize.css#L38-L52
        fontFamily: 'system-ui,"Segoe UI",Roboto,Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji"',
        height: '100vh',
        textAlign: 'center',
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        justifyContent: 'center'
    },
    text: {
        fontSize: '14px',
        fontWeight: 400,
        lineHeight: '28px',
        margin: '0 8px'
    }
};
function DefaultGlobalError(param) {
    let { error } = param;
    const digest = error == null ? void 0 : error.digest;
    return /*#__PURE__*/ (0, _jsxruntime.jsxs)("html", {
        id: "__next_error__",
        children: [
            /*#__PURE__*/ (0, _jsxruntime.jsx)("head", {}),
            /*#__PURE__*/ (0, _jsxruntime.jsxs)("body", {
                children: [
                    /*#__PURE__*/ (0, _jsxruntime.jsx)(_handleisrerror.HandleISRError, {
                        error: error
                    }),
                    /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        style: styles.error,
                        children: /*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {
                            children: [
                                /*#__PURE__*/ (0, _jsxruntime.jsxs)("h2", {
                                    style: styles.text,
                                    children: [
                                        "Application error: a ",
                                        digest ? 'server' : 'client',
                                        "-side exception has occurred while loading ",
                                        window.location.hostname,
                                        " (see the",
                                        ' ',
                                        digest ? 'server logs' : 'browser console',
                                        " for more information)."
                                    ]
                                }),
                                digest ? /*#__PURE__*/ (0, _jsxruntime.jsx)("p", {
                                    style: styles.text,
                                    children: "Digest: " + digest
                                }) : null
                            ]
                        })
                    })
                ]
            })
        ]
    });
}
const _default = DefaultGlobalError;
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=global-error.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/router/utils/html-bots.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
// This regex contains the bots that we need to do a blocking render for and can't safely stream the response
// due to how they parse the DOM. For example, they might explicitly check for metadata in the `head` tag, so we can't stream metadata tags after the `head` was sent.
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "HTML_LIMITED_BOT_UA_RE", {
    enumerable: true,
    get: function() {
        return HTML_LIMITED_BOT_UA_RE;
    }
});
const HTML_LIMITED_BOT_UA_RE = /Mediapartners-Google|Chrome-Lighthouse|Slurp|DuckDuckBot|baiduspider|yandex|sogou|bitlybot|tumblr|vkShare|quora link preview|redditbot|ia_archiver|Bingbot|BingPreview|applebot|facebookexternalhit|facebookcatalog|Twitterbot|LinkedInBot|Slackbot|Discordbot|WhatsApp|SkypeUriPreview|Yeti/i; //# sourceMappingURL=html-bots.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/router/utils/is-bot.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    HTML_LIMITED_BOT_UA_RE: null,
    HTML_LIMITED_BOT_UA_RE_STRING: null,
    getBotType: null,
    isBot: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    HTML_LIMITED_BOT_UA_RE: function() {
        return _htmlbots.HTML_LIMITED_BOT_UA_RE;
    },
    HTML_LIMITED_BOT_UA_RE_STRING: function() {
        return HTML_LIMITED_BOT_UA_RE_STRING;
    },
    getBotType: function() {
        return getBotType;
    },
    isBot: function() {
        return isBot;
    }
});
const _htmlbots = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/html-bots.js [app-ssr] (ecmascript)");
// Bot crawler that will spin up a headless browser and execute JS.
// By default, only googlebots are considered as DOM bots. Blow is where the regex is computed from:
// x-ref: https://developers.google.com/search/docs/crawling-indexing/google-common-crawlers
const HEADLESS_BROWSER_BOT_UA_RE = /google/i;
const HTML_LIMITED_BOT_UA_RE_STRING = _htmlbots.HTML_LIMITED_BOT_UA_RE.source;
function isDomBotUA(userAgent) {
    return HEADLESS_BROWSER_BOT_UA_RE.test(userAgent);
}
function isHtmlLimitedBotUA(userAgent) {
    return _htmlbots.HTML_LIMITED_BOT_UA_RE.test(userAgent);
}
function isBot(userAgent) {
    return isDomBotUA(userAgent) || isHtmlLimitedBotUA(userAgent);
}
function getBotType(userAgent) {
    if (isDomBotUA(userAgent)) {
        return 'dom';
    }
    if (isHtmlLimitedBotUA(userAgent)) {
        return 'html';
    }
    return undefined;
} //# sourceMappingURL=is-bot.js.map
}}),
"[project]/node_modules/next/dist/client/components/app-router-announcer.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "AppRouterAnnouncer", {
    enumerable: true,
    get: function() {
        return AppRouterAnnouncer;
    }
});
const _react = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
const _reactdom = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-dom.js [app-ssr] (ecmascript)");
const ANNOUNCER_TYPE = 'next-route-announcer';
const ANNOUNCER_ID = '__next-route-announcer__';
function getAnnouncerNode() {
    var _existingAnnouncer_shadowRoot;
    const existingAnnouncer = document.getElementsByName(ANNOUNCER_TYPE)[0];
    if (existingAnnouncer == null ? void 0 : (_existingAnnouncer_shadowRoot = existingAnnouncer.shadowRoot) == null ? void 0 : _existingAnnouncer_shadowRoot.childNodes[0]) {
        return existingAnnouncer.shadowRoot.childNodes[0];
    } else {
        const container = document.createElement(ANNOUNCER_TYPE);
        container.style.cssText = 'position:absolute';
        const announcer = document.createElement('div');
        announcer.ariaLive = 'assertive';
        announcer.id = ANNOUNCER_ID;
        announcer.role = 'alert';
        announcer.style.cssText = 'position:absolute;border:0;height:1px;margin:-1px;padding:0;width:1px;clip:rect(0 0 0 0);overflow:hidden;white-space:nowrap;word-wrap:normal';
        // Use shadow DOM here to avoid any potential CSS bleed
        const shadow = container.attachShadow({
            mode: 'open'
        });
        shadow.appendChild(announcer);
        document.body.appendChild(container);
        return announcer;
    }
}
function AppRouterAnnouncer(param) {
    let { tree } = param;
    const [portalNode, setPortalNode] = (0, _react.useState)(null);
    (0, _react.useEffect)(()=>{
        const announcer = getAnnouncerNode();
        setPortalNode(announcer);
        return ()=>{
            const container = document.getElementsByTagName(ANNOUNCER_TYPE)[0];
            if (container == null ? void 0 : container.isConnected) {
                document.body.removeChild(container);
            }
        };
    }, []);
    const [routeAnnouncement, setRouteAnnouncement] = (0, _react.useState)('');
    const previousTitle = (0, _react.useRef)(undefined);
    (0, _react.useEffect)(()=>{
        let currentTitle = '';
        if (document.title) {
            currentTitle = document.title;
        } else {
            const pageHeader = document.querySelector('h1');
            if (pageHeader) {
                currentTitle = pageHeader.innerText || pageHeader.textContent || '';
            }
        }
        // Only announce the title change, but not for the first load because screen
        // readers do that automatically.
        if (previousTitle.current !== undefined && previousTitle.current !== currentTitle) {
            setRouteAnnouncement(currentTitle);
        }
        previousTitle.current = currentTitle;
    }, [
        tree
    ]);
    return portalNode ? /*#__PURE__*/ (0, _reactdom.createPortal)(routeAnnouncement, portalNode) : null;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=app-router-announcer.js.map
}}),
"[project]/node_modules/next/dist/client/components/redirect-boundary.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    RedirectBoundary: null,
    RedirectErrorBoundary: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    RedirectBoundary: function() {
        return RedirectBoundary;
    },
    RedirectErrorBoundary: function() {
        return RedirectErrorBoundary;
    }
});
const _interop_require_wildcard = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [app-ssr] (ecmascript)");
const _jsxruntime = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js [app-ssr] (ecmascript)");
const _react = /*#__PURE__*/ _interop_require_wildcard._(__turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)"));
const _navigation = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/navigation.js [app-ssr] (ecmascript)");
const _redirect = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/redirect.js [app-ssr] (ecmascript)");
const _redirecterror = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/redirect-error.js [app-ssr] (ecmascript)");
function HandleRedirect(param) {
    let { redirect, reset, redirectType } = param;
    const router = (0, _navigation.useRouter)();
    (0, _react.useEffect)(()=>{
        _react.default.startTransition(()=>{
            if (redirectType === _redirecterror.RedirectType.push) {
                router.push(redirect, {});
            } else {
                router.replace(redirect, {});
            }
            reset();
        });
    }, [
        redirect,
        redirectType,
        reset,
        router
    ]);
    return null;
}
class RedirectErrorBoundary extends _react.default.Component {
    static getDerivedStateFromError(error) {
        if ((0, _redirecterror.isRedirectError)(error)) {
            const url = (0, _redirect.getURLFromRedirectError)(error);
            const redirectType = (0, _redirect.getRedirectTypeFromError)(error);
            return {
                redirect: url,
                redirectType
            };
        }
        // Re-throw if error is not for redirect
        throw error;
    }
    // Explicit type is needed to avoid the generated `.d.ts` having a wide return type that could be specific to the `@types/react` version.
    render() {
        const { redirect, redirectType } = this.state;
        if (redirect !== null && redirectType !== null) {
            return /*#__PURE__*/ (0, _jsxruntime.jsx)(HandleRedirect, {
                redirect: redirect,
                redirectType: redirectType,
                reset: ()=>this.setState({
                        redirect: null
                    })
            });
        }
        return this.props.children;
    }
    constructor(props){
        super(props);
        this.state = {
            redirect: null,
            redirectType: null
        };
    }
}
function RedirectBoundary(param) {
    let { children } = param;
    const router = (0, _navigation.useRouter)();
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(RedirectErrorBoundary, {
        router: router,
        children: children
    });
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=redirect-boundary.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/reducers/find-head-in-cache.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "findHeadInCache", {
    enumerable: true,
    get: function() {
        return findHeadInCache;
    }
});
const _segment = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/segment.js [app-ssr] (ecmascript)");
const _createroutercachekey = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js [app-ssr] (ecmascript)");
function findHeadInCache(cache, parallelRoutes) {
    return findHeadInCacheImpl(cache, parallelRoutes, '');
}
function findHeadInCacheImpl(cache, parallelRoutes, keyPrefix) {
    const isLastItem = Object.keys(parallelRoutes).length === 0;
    if (isLastItem) {
        // Returns the entire Cache Node of the segment whose head we will render.
        return [
            cache,
            keyPrefix
        ];
    }
    // First try the 'children' parallel route if it exists
    // when starting from the "root", this corresponds with the main page component
    const parallelRoutesKeys = Object.keys(parallelRoutes).filter((key)=>key !== 'children');
    // if we are at the root, we need to check the children slot first
    if ('children' in parallelRoutes) {
        parallelRoutesKeys.unshift('children');
    }
    for (const key of parallelRoutesKeys){
        const [segment, childParallelRoutes] = parallelRoutes[key];
        // If the parallel is not matched and using the default segment,
        // skip searching the head from it.
        if (segment === _segment.DEFAULT_SEGMENT_KEY) {
            continue;
        }
        const childSegmentMap = cache.parallelRoutes.get(key);
        if (!childSegmentMap) {
            continue;
        }
        const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(segment);
        const cacheNode = childSegmentMap.get(cacheKey);
        if (!cacheNode) {
            continue;
        }
        const item = findHeadInCacheImpl(cacheNode, childParallelRoutes, keyPrefix + '/' + cacheKey);
        if (item) {
            return item;
        }
    }
    return null;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=find-head-in-cache.js.map
}}),
"[project]/node_modules/next/dist/client/components/unresolved-thenable.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/**
 * Create a "Thenable" that does not resolve. This is used to suspend indefinitely when data is not available yet.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "unresolvedThenable", {
    enumerable: true,
    get: function() {
        return unresolvedThenable;
    }
});
const unresolvedThenable = {
    then: ()=>{}
};
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=unresolved-thenable.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "pathHasPrefix", {
    enumerable: true,
    get: function() {
        return pathHasPrefix;
    }
});
const _parsepath = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/parse-path.js [app-ssr] (ecmascript)");
function pathHasPrefix(path, prefix) {
    if (typeof path !== 'string') {
        return false;
    }
    const { pathname } = (0, _parsepath.parsePath)(path);
    return pathname === prefix || pathname.startsWith(prefix + '/');
} //# sourceMappingURL=path-has-prefix.js.map
}}),
"[project]/node_modules/next/dist/client/has-base-path.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "hasBasePath", {
    enumerable: true,
    get: function() {
        return hasBasePath;
    }
});
const _pathhasprefix = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js [app-ssr] (ecmascript)");
const basePath = ("TURBOPACK compile-time value", "") || '';
function hasBasePath(path) {
    return (0, _pathhasprefix.pathHasPrefix)(path, basePath);
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=has-base-path.js.map
}}),
"[project]/node_modules/next/dist/client/remove-base-path.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "removeBasePath", {
    enumerable: true,
    get: function() {
        return removeBasePath;
    }
});
const _hasbasepath = __turbopack_context__.r("[project]/node_modules/next/dist/client/has-base-path.js [app-ssr] (ecmascript)");
const basePath = ("TURBOPACK compile-time value", "") || '';
function removeBasePath(path) {
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    // Can't trim the basePath if it has zero length!
    if (basePath.length === 0) return path;
    path = path.slice(basePath.length);
    if (!path.startsWith('/')) path = "/" + path;
    return path;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=remove-base-path.js.map
}}),
"[project]/node_modules/next/dist/client/components/errors/graceful-degrade-boundary.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    GracefulDegradeBoundary: null,
    default: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    GracefulDegradeBoundary: function() {
        return GracefulDegradeBoundary;
    },
    default: function() {
        return _default;
    }
});
const _jsxruntime = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js [app-ssr] (ecmascript)");
const _react = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
function getDomNodeAttributes(node) {
    const result = {};
    for(let i = 0; i < node.attributes.length; i++){
        const attr = node.attributes[i];
        result[attr.name] = attr.value;
    }
    return result;
}
class GracefulDegradeBoundary extends _react.Component {
    static getDerivedStateFromError(_) {
        return {
            hasError: true
        };
    }
    componentDidMount() {
        const htmlNode = this.htmlRef.current;
        if (this.state.hasError && htmlNode) {
            // Reapply the cached HTML attributes to the root element
            Object.entries(this.htmlAttributes).forEach((param)=>{
                let [key, value] = param;
                htmlNode.setAttribute(key, value);
            });
        }
    }
    render() {
        const { hasError } = this.state;
        // Cache the root HTML content on the first render
        if ("undefined" !== 'undefined' && !this.rootHtml) //TURBOPACK unreachable
        ;
        if (hasError) {
            // Render the current HTML content without hydration
            return /*#__PURE__*/ (0, _jsxruntime.jsx)("html", {
                ref: this.htmlRef,
                suppressHydrationWarning: true,
                dangerouslySetInnerHTML: {
                    __html: this.rootHtml
                }
            });
        }
        return this.props.children;
    }
    constructor(props){
        super(props);
        this.state = {
            hasError: false
        };
        this.rootHtml = '';
        this.htmlAttributes = {};
        this.htmlRef = /*#__PURE__*/ (0, _react.createRef)();
    }
}
const _default = GracefulDegradeBoundary;
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=graceful-degrade-boundary.js.map
}}),
"[project]/node_modules/next/dist/compiled/strip-ansi/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
(()=>{
    "use strict";
    var e = {
        511: (e)=>{
            e.exports = ({ onlyFirst: e = false } = {})=>{
                const r = [
                    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
                    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
                ].join("|");
                return new RegExp(r, e ? undefined : "g");
            };
        },
        532: (e, r, _)=>{
            const t = _(511);
            e.exports = (e)=>typeof e === "string" ? e.replace(t(), "") : e;
        }
    };
    var r = {};
    function __nccwpck_require__(_) {
        var t = r[_];
        if (t !== undefined) {
            return t.exports;
        }
        var a = r[_] = {
            exports: {}
        };
        var n = true;
        try {
            e[_](a, a.exports, __nccwpck_require__);
            n = false;
        } finally{
            if (n) delete r[_];
        }
        return a.exports;
    }
    if (typeof __nccwpck_require__ !== "undefined") __nccwpck_require__.ab = ("TURBOPACK compile-time value", "/ROOT/node_modules/next/dist/compiled/strip-ansi") + "/";
    var _ = __nccwpck_require__(532);
    module.exports = _;
})();
}}),
"[project]/node_modules/next/dist/shared/lib/format-webpack-messages.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/**
MIT License

Copyright (c) 2015-present, Facebook, Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/ Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return formatWebpackMessages;
    }
});
const _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-ssr] (ecmascript)");
const _stripansi = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/strip-ansi/index.js [app-ssr] (ecmascript)"));
// This file is based on https://github.com/facebook/create-react-app/blob/7b1a32be6ec9f99a6c9a3c66813f3ac09c4736b9/packages/react-dev-utils/formatWebpackMessages.js
// It's been edited to remove chalk and CRA-specific logic
const friendlySyntaxErrorLabel = 'Syntax error:';
const WEBPACK_BREAKING_CHANGE_POLYFILLS = '\n\nBREAKING CHANGE: webpack < 5 used to include polyfills for node.js core modules by default.';
function isLikelyASyntaxError(message) {
    return (0, _stripansi.default)(message).includes(friendlySyntaxErrorLabel);
}
let hadMissingSassError = false;
// Cleans up webpack error messages.
function formatMessage(message, verbose, importTraceNote) {
    // TODO: Replace this once webpack 5 is stable
    if (typeof message === 'object' && message.message) {
        const filteredModuleTrace = message.moduleTrace && message.moduleTrace.filter((trace)=>!/next-(middleware|client-pages|route|edge-function)-loader\.js/.test(trace.originName));
        let body = message.message;
        const breakingChangeIndex = body.indexOf(WEBPACK_BREAKING_CHANGE_POLYFILLS);
        if (breakingChangeIndex >= 0) {
            body = body.slice(0, breakingChangeIndex);
        }
        message = (message.moduleName ? (0, _stripansi.default)(message.moduleName) + '\n' : '') + (message.file ? (0, _stripansi.default)(message.file) + '\n' : '') + body + (message.details && verbose ? '\n' + message.details : '') + (filteredModuleTrace && filteredModuleTrace.length ? (importTraceNote || '\n\nImport trace for requested module:') + filteredModuleTrace.map((trace)=>"\n" + trace.moduleName).join('') : '') + (message.stack && verbose ? '\n' + message.stack : '');
    }
    let lines = message.split('\n');
    // Strip Webpack-added headers off errors/warnings
    // https://github.com/webpack/webpack/blob/master/lib/ModuleError.js
    lines = lines.filter((line)=>!/Module [A-z ]+\(from/.test(line));
    // Transform parsing error into syntax error
    // TODO: move this to our ESLint formatter?
    lines = lines.map((line)=>{
        const parsingError = /Line (\d+):(?:(\d+):)?\s*Parsing error: (.+)$/.exec(line);
        if (!parsingError) {
            return line;
        }
        const [, errorLine, errorColumn, errorMessage] = parsingError;
        return friendlySyntaxErrorLabel + " " + errorMessage + " (" + errorLine + ":" + errorColumn + ")";
    });
    message = lines.join('\n');
    // Smoosh syntax errors (commonly found in CSS)
    message = message.replace(/SyntaxError\s+\((\d+):(\d+)\)\s*(.+?)\n/g, "" + friendlySyntaxErrorLabel + " $3 ($1:$2)\n");
    // Clean up export errors
    message = message.replace(/^.*export '(.+?)' was not found in '(.+?)'.*$/gm, "Attempted import error: '$1' is not exported from '$2'.");
    message = message.replace(/^.*export 'default' \(imported as '(.+?)'\) was not found in '(.+?)'.*$/gm, "Attempted import error: '$2' does not contain a default export (imported as '$1').");
    message = message.replace(/^.*export '(.+?)' \(imported as '(.+?)'\) was not found in '(.+?)'.*$/gm, "Attempted import error: '$1' is not exported from '$3' (imported as '$2').");
    lines = message.split('\n');
    // Remove leading newline
    if (lines.length > 2 && lines[1].trim() === '') {
        lines.splice(1, 1);
    }
    // Cleans up verbose "module not found" messages for files and packages.
    if (lines[1] && lines[1].startsWith('Module not found: ')) {
        lines = [
            lines[0],
            lines[1].replace('Error: ', '').replace('Module not found: Cannot find file:', 'Cannot find file:'),
            ...lines.slice(2)
        ];
    }
    // Add helpful message for users trying to use Sass for the first time
    if (lines[1] && lines[1].match(/Cannot find module.+sass/)) {
        // ./file.module.scss (<<loader info>>) => ./file.module.scss
        const firstLine = lines[0].split('!');
        lines[0] = firstLine[firstLine.length - 1];
        lines[1] = "To use Next.js' built-in Sass support, you first need to install `sass`.\n";
        lines[1] += 'Run `npm i sass` or `yarn add sass` inside your workspace.\n';
        lines[1] += '\nLearn more: https://nextjs.org/docs/messages/install-sass';
        // dispose of unhelpful stack trace
        lines = lines.slice(0, 2);
        hadMissingSassError = true;
    } else if (hadMissingSassError && message.match(/(sass-loader|resolve-url-loader: CSS error)/)) {
        // dispose of unhelpful stack trace following missing sass module
        lines = [];
    }
    if (!verbose) {
        message = lines.join('\n');
        // Internal stacks are generally useless so we strip them... with the
        // exception of stacks containing `webpack:` because they're normally
        // from user code generated by Webpack. For more information see
        // https://github.com/facebook/create-react-app/pull/1050
        message = message.replace(/^\s*at\s((?!webpack:).)*:\d+:\d+[\s)]*(\n|$)/gm, '') // at ... ...:x:y
        ;
        message = message.replace(/^\s*at\s<anonymous>(\n|$)/gm, '') // at <anonymous>
        ;
        message = message.replace(/File was processed with these loaders:\n(.+[\\/](next[\\/]dist[\\/].+|@next[\\/]react-refresh-utils[\\/]loader)\.js\n)*You may need an additional loader to handle the result of these loaders.\n/g, '');
        lines = message.split('\n');
    }
    // Remove duplicated newlines
    lines = lines.filter((line, index, arr)=>index === 0 || line.trim() !== '' || line.trim() !== arr[index - 1].trim());
    // Reassemble the message
    message = lines.join('\n');
    return message.trim();
}
function formatWebpackMessages(json, verbose) {
    const formattedErrors = json.errors.map((message)=>{
        const isUnknownNextFontError = message.message.includes('An error occurred in `next/font`.');
        return formatMessage(message, isUnknownNextFontError || verbose);
    });
    const formattedWarnings = json.warnings.map((message)=>{
        return formatMessage(message, verbose);
    });
    // Reorder errors to put the most relevant ones first.
    let reactServerComponentsError = -1;
    for(let i = 0; i < formattedErrors.length; i++){
        const error = formattedErrors[i];
        if (error.includes('ReactServerComponentsError')) {
            reactServerComponentsError = i;
            break;
        }
    }
    // Move the reactServerComponentsError to the top if it exists
    if (reactServerComponentsError !== -1) {
        const error = formattedErrors.splice(reactServerComponentsError, 1);
        formattedErrors.unshift(error[0]);
    }
    const result = {
        ...json,
        errors: formattedErrors,
        warnings: formattedWarnings
    };
    if (!verbose && result.errors.some(isLikelyASyntaxError)) {
        // If there are any syntax errors, show just them.
        result.errors = result.errors.filter(isLikelyASyntaxError);
        result.warnings = [];
    }
    return result;
} //# sourceMappingURL=format-webpack-messages.js.map
}}),
"[project]/node_modules/next/dist/client/dev/hot-reloader/shared.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    REACT_REFRESH_FULL_RELOAD: null,
    REACT_REFRESH_FULL_RELOAD_FROM_ERROR: null,
    reportInvalidHmrMessage: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    REACT_REFRESH_FULL_RELOAD: function() {
        return REACT_REFRESH_FULL_RELOAD;
    },
    REACT_REFRESH_FULL_RELOAD_FROM_ERROR: function() {
        return REACT_REFRESH_FULL_RELOAD_FROM_ERROR;
    },
    reportInvalidHmrMessage: function() {
        return reportInvalidHmrMessage;
    }
});
const REACT_REFRESH_FULL_RELOAD = '[Fast Refresh] performing full reload\n\n' + "Fast Refresh will perform a full reload when you edit a file that's imported by modules outside of the React rendering tree.\n" + 'You might have a file which exports a React component but also exports a value that is imported by a non-React component file.\n' + 'Consider migrating the non-React component export to a separate file and importing it into both files.\n\n' + 'It is also possible the parent component of the component you edited is a class component, which disables Fast Refresh.\n' + 'Fast Refresh requires at least one parent function component in your React tree.';
const REACT_REFRESH_FULL_RELOAD_FROM_ERROR = '[Fast Refresh] performing full reload because your application had an unrecoverable error';
function reportInvalidHmrMessage(message, err) {
    console.warn('[HMR] Invalid message: ' + JSON.stringify(message) + '\n' + (err instanceof Error && (err == null ? void 0 : err.stack) || ''));
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=shared.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/is-plain-object.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    getObjectClassLabel: null,
    isPlainObject: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    getObjectClassLabel: function() {
        return getObjectClassLabel;
    },
    isPlainObject: function() {
        return isPlainObject;
    }
});
function getObjectClassLabel(value) {
    return Object.prototype.toString.call(value);
}
function isPlainObject(value) {
    if (getObjectClassLabel(value) !== '[object Object]') {
        return false;
    }
    const prototype = Object.getPrototypeOf(value);
    /**
   * this used to be previously:
   *
   * `return prototype === null || prototype === Object.prototype`
   *
   * but Edge Runtime expose Object from vm, being that kind of type-checking wrongly fail.
   *
   * It was changed to the current implementation since it's resilient to serialization.
   */ return prototype === null || prototype.hasOwnProperty('isPrototypeOf');
} //# sourceMappingURL=is-plain-object.js.map
}}),
"[project]/node_modules/next/dist/lib/is-error.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    default: null,
    getProperError: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    /**
 * Checks whether the given value is a NextError.
 * This can be used to print a more detailed error message with properties like `code` & `digest`.
 */ default: function() {
        return isError;
    },
    getProperError: function() {
        return getProperError;
    }
});
const _isplainobject = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/is-plain-object.js [app-ssr] (ecmascript)");
function isError(err) {
    return typeof err === 'object' && err !== null && 'name' in err && 'message' in err;
}
function safeStringify(obj) {
    const seen = new WeakSet();
    return JSON.stringify(obj, (_key, value)=>{
        // If value is an object and already seen, replace with "[Circular]"
        if (typeof value === 'object' && value !== null) {
            if (seen.has(value)) {
                return '[Circular]';
            }
            seen.add(value);
        }
        return value;
    });
}
function getProperError(err) {
    if (isError(err)) {
        return err;
    }
    if ("TURBOPACK compile-time truthy", 1) {
        // provide better error for case where `throw undefined`
        // is called in development
        if (typeof err === 'undefined') {
            return Object.defineProperty(new Error('An undefined error was thrown, ' + 'see here for more info: https://nextjs.org/docs/messages/threw-undefined'), "__NEXT_ERROR_CODE", {
                value: "E98",
                enumerable: false,
                configurable: true
            });
        }
        if (err === null) {
            return Object.defineProperty(new Error('A null error was thrown, ' + 'see here for more info: https://nextjs.org/docs/messages/threw-undefined'), "__NEXT_ERROR_CODE", {
                value: "E336",
                enumerable: false,
                configurable: true
            });
        }
    }
    return Object.defineProperty(new Error((0, _isplainobject.isPlainObject)(err) ? safeStringify(err) : err + ''), "__NEXT_ERROR_CODE", {
        value: "E394",
        enumerable: false,
        configurable: true
    });
} //# sourceMappingURL=is-error.js.map
}}),
"[project]/node_modules/next/dist/client/lib/console.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    formatConsoleArgs: null,
    parseConsoleArgs: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    formatConsoleArgs: function() {
        return formatConsoleArgs;
    },
    parseConsoleArgs: function() {
        return parseConsoleArgs;
    }
});
const _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-ssr] (ecmascript)");
const _iserror = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/lib/is-error.js [app-ssr] (ecmascript)"));
function formatObject(arg, depth) {
    switch(typeof arg){
        case 'object':
            if (arg === null) {
                return 'null';
            } else if (Array.isArray(arg)) {
                let result = '[';
                if (depth < 1) {
                    for(let i = 0; i < arg.length; i++){
                        if (result !== '[') {
                            result += ',';
                        }
                        if (Object.prototype.hasOwnProperty.call(arg, i)) {
                            result += formatObject(arg[i], depth + 1);
                        }
                    }
                } else {
                    result += arg.length > 0 ? '...' : '';
                }
                result += ']';
                return result;
            } else if (arg instanceof Error) {
                return arg + '';
            } else {
                const keys = Object.keys(arg);
                let result = '{';
                if (depth < 1) {
                    for(let i = 0; i < keys.length; i++){
                        const key = keys[i];
                        const desc = Object.getOwnPropertyDescriptor(arg, 'key');
                        if (desc && !desc.get && !desc.set) {
                            const jsonKey = JSON.stringify(key);
                            if (jsonKey !== '"' + key + '"') {
                                result += jsonKey + ': ';
                            } else {
                                result += key + ': ';
                            }
                            result += formatObject(desc.value, depth + 1);
                        }
                    }
                } else {
                    result += keys.length > 0 ? '...' : '';
                }
                result += '}';
                return result;
            }
        case 'string':
            return JSON.stringify(arg);
        default:
            return String(arg);
    }
}
function formatConsoleArgs(args) {
    let message;
    let idx;
    if (typeof args[0] === 'string') {
        message = args[0];
        idx = 1;
    } else {
        message = '';
        idx = 0;
    }
    let result = '';
    let startQuote = false;
    for(let i = 0; i < message.length; ++i){
        const char = message[i];
        if (char !== '%' || i === message.length - 1 || idx >= args.length) {
            result += char;
            continue;
        }
        const code = message[++i];
        switch(code){
            case 'c':
                {
                    // TODO: We should colorize with HTML instead of turning into a string.
                    // Ignore for now.
                    result = startQuote ? "" + result + "]" : "[" + result;
                    startQuote = !startQuote;
                    idx++;
                    break;
                }
            case 'O':
            case 'o':
                {
                    result += formatObject(args[idx++], 0);
                    break;
                }
            case 'd':
            case 'i':
                {
                    result += parseInt(args[idx++], 10);
                    break;
                }
            case 'f':
                {
                    result += parseFloat(args[idx++]);
                    break;
                }
            case 's':
                {
                    result += String(args[idx++]);
                    break;
                }
            default:
                result += '%' + code;
        }
    }
    for(; idx < args.length; idx++){
        result += (idx > 0 ? ' ' : '') + formatObject(args[idx], 0);
    }
    return result;
}
function parseConsoleArgs(args) {
    // See
    // https://github.com/facebook/react/blob/65a56d0e99261481c721334a3ec4561d173594cd/packages/react-devtools-shared/src/backend/flight/renderer.js#L88-L93
    //
    // Logs replayed from the server look like this:
    // [
    //   "%c%s%c %o\n\n%s\n\n%s\n",
    //   "background: #e6e6e6; ...",
    //   " Server ", // can also be e.g. " Prerender "
    //   "",
    //   Error,
    //   "The above error occurred in the <Page> component.",
    //   ...
    // ]
    if (args.length > 3 && typeof args[0] === 'string' && args[0].startsWith('%c%s%c ') && typeof args[1] === 'string' && typeof args[2] === 'string' && typeof args[3] === 'string') {
        const environmentName = args[2];
        const maybeError = args[4];
        return {
            environmentName: environmentName.trim(),
            error: (0, _iserror.default)(maybeError) ? maybeError : null
        };
    }
    return {
        environmentName: null,
        error: null
    };
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=console.js.map
}}),
"[project]/node_modules/next/dist/next-devtools/shared/console-error.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
// To distinguish from React error.digest, we use a different symbol here to determine if the error is from console.error or unhandled promise rejection.
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    createConsoleError: null,
    isConsoleError: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    createConsoleError: function() {
        return createConsoleError;
    },
    isConsoleError: function() {
        return isConsoleError;
    }
});
const digestSym = Symbol.for('next.console.error.digest');
function createConsoleError(message, environmentName) {
    const error = typeof message === 'string' ? Object.defineProperty(new Error(message), "__NEXT_ERROR_CODE", {
        value: "E394",
        enumerable: false,
        configurable: true
    }) : message;
    error[digestSym] = 'NEXT_CONSOLE_ERROR';
    if (environmentName && !error.environmentName) {
        error.environmentName = environmentName;
    }
    return error;
}
const isConsoleError = (error)=>{
    return error && error[digestSym] === 'NEXT_CONSOLE_ERROR';
};
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=console-error.js.map
}}),
"[project]/node_modules/next/dist/next-devtools/userspace/app/errors/stitched-error.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    coerceError: null,
    decorateDevError: null,
    getComponentStack: null,
    getOwnerStack: null,
    setComponentStack: null,
    setOwnerStack: null,
    setOwnerStackIfAvailable: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    coerceError: function() {
        return coerceError;
    },
    decorateDevError: function() {
        return decorateDevError;
    },
    getComponentStack: function() {
        return getComponentStack;
    },
    getOwnerStack: function() {
        return getOwnerStack;
    },
    setComponentStack: function() {
        return setComponentStack;
    },
    setOwnerStack: function() {
        return setOwnerStack;
    },
    setOwnerStackIfAvailable: function() {
        return setOwnerStackIfAvailable;
    }
});
const _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-ssr] (ecmascript)");
const _react = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)"));
const _iserror = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/lib/is-error.js [app-ssr] (ecmascript)"));
const ownerStacks = new WeakMap();
const componentStacks = new WeakMap();
function getComponentStack(error) {
    return componentStacks.get(error);
}
function setComponentStack(error, stack) {
    componentStacks.set(error, stack);
}
function getOwnerStack(error) {
    return ownerStacks.get(error);
}
function setOwnerStack(error, stack) {
    ownerStacks.set(error, stack);
}
function coerceError(value) {
    return (0, _iserror.default)(value) ? value : Object.defineProperty(new Error('' + value), "__NEXT_ERROR_CODE", {
        value: "E394",
        enumerable: false,
        configurable: true
    });
}
function setOwnerStackIfAvailable(error) {
    // React 18 and prod does not have `captureOwnerStack`
    if ('captureOwnerStack' in _react.default) {
        setOwnerStack(error, _react.default.captureOwnerStack());
    }
}
function decorateDevError(thrownValue, errorInfo) {
    const error = coerceError(thrownValue);
    setOwnerStackIfAvailable(error);
    // TODO: change to passing down errorInfo later
    // In development mode, pass along the component stack to the error
    if (errorInfo.componentStack) {
        setComponentStack(error, errorInfo.componentStack);
    }
    return error;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=stitched-error.js.map
}}),
"[project]/node_modules/next/dist/compiled/safe-stable-stringify/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
(function() {
    "use strict";
    var e = {
        879: function(e, t) {
            const { hasOwnProperty: n } = Object.prototype;
            const r = configure();
            r.configure = configure;
            r.stringify = r;
            r.default = r;
            t.stringify = r;
            t.configure = configure;
            e.exports = r;
            const i = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/;
            function strEscape(e) {
                if (e.length < 5e3 && !i.test(e)) {
                    return `"${e}"`;
                }
                return JSON.stringify(e);
            }
            function sort(e, t) {
                if (e.length > 200 || t) {
                    return e.sort(t);
                }
                for(let t = 1; t < e.length; t++){
                    const n = e[t];
                    let r = t;
                    while(r !== 0 && e[r - 1] > n){
                        e[r] = e[r - 1];
                        r--;
                    }
                    e[r] = n;
                }
                return e;
            }
            const f = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Object.getPrototypeOf(new Int8Array)), Symbol.toStringTag).get;
            function isTypedArrayWithEntries(e) {
                return f.call(e) !== undefined && e.length !== 0;
            }
            function stringifyTypedArray(e, t, n) {
                if (e.length < n) {
                    n = e.length;
                }
                const r = t === "," ? "" : " ";
                let i = `"0":${r}${e[0]}`;
                for(let f = 1; f < n; f++){
                    i += `${t}"${f}":${r}${e[f]}`;
                }
                return i;
            }
            function getCircularValueOption(e) {
                if (n.call(e, "circularValue")) {
                    const t = e.circularValue;
                    if (typeof t === "string") {
                        return `"${t}"`;
                    }
                    if (t == null) {
                        return t;
                    }
                    if (t === Error || t === TypeError) {
                        return {
                            toString () {
                                throw new TypeError("Converting circular structure to JSON");
                            }
                        };
                    }
                    throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined');
                }
                return '"[Circular]"';
            }
            function getDeterministicOption(e) {
                let t;
                if (n.call(e, "deterministic")) {
                    t = e.deterministic;
                    if (typeof t !== "boolean" && typeof t !== "function") {
                        throw new TypeError('The "deterministic" argument must be of type boolean or comparator function');
                    }
                }
                return t === undefined ? true : t;
            }
            function getBooleanOption(e, t) {
                let r;
                if (n.call(e, t)) {
                    r = e[t];
                    if (typeof r !== "boolean") {
                        throw new TypeError(`The "${t}" argument must be of type boolean`);
                    }
                }
                return r === undefined ? true : r;
            }
            function getPositiveIntegerOption(e, t) {
                let r;
                if (n.call(e, t)) {
                    r = e[t];
                    if (typeof r !== "number") {
                        throw new TypeError(`The "${t}" argument must be of type number`);
                    }
                    if (!Number.isInteger(r)) {
                        throw new TypeError(`The "${t}" argument must be an integer`);
                    }
                    if (r < 1) {
                        throw new RangeError(`The "${t}" argument must be >= 1`);
                    }
                }
                return r === undefined ? Infinity : r;
            }
            function getItemCount(e) {
                if (e === 1) {
                    return "1 item";
                }
                return `${e} items`;
            }
            function getUniqueReplacerSet(e) {
                const t = new Set;
                for (const n of e){
                    if (typeof n === "string" || typeof n === "number") {
                        t.add(String(n));
                    }
                }
                return t;
            }
            function getStrictOption(e) {
                if (n.call(e, "strict")) {
                    const t = e.strict;
                    if (typeof t !== "boolean") {
                        throw new TypeError('The "strict" argument must be of type boolean');
                    }
                    if (t) {
                        return (e)=>{
                            let t = `Object can not safely be stringified. Received type ${typeof e}`;
                            if (typeof e !== "function") t += ` (${e.toString()})`;
                            throw new Error(t);
                        };
                    }
                }
            }
            function configure(e) {
                e = {
                    ...e
                };
                const t = getStrictOption(e);
                if (t) {
                    if (e.bigint === undefined) {
                        e.bigint = false;
                    }
                    if (!("circularValue" in e)) {
                        e.circularValue = Error;
                    }
                }
                const n = getCircularValueOption(e);
                const r = getBooleanOption(e, "bigint");
                const i = getDeterministicOption(e);
                const f = typeof i === "function" ? i : undefined;
                const u = getPositiveIntegerOption(e, "maximumDepth");
                const o = getPositiveIntegerOption(e, "maximumBreadth");
                function stringifyFnReplacer(e, s, l, c, a, g) {
                    let p = s[e];
                    if (typeof p === "object" && p !== null && typeof p.toJSON === "function") {
                        p = p.toJSON(e);
                    }
                    p = c.call(s, e, p);
                    switch(typeof p){
                        case "string":
                            return strEscape(p);
                        case "object":
                            {
                                if (p === null) {
                                    return "null";
                                }
                                if (l.indexOf(p) !== -1) {
                                    return n;
                                }
                                let e = "";
                                let t = ",";
                                const r = g;
                                if (Array.isArray(p)) {
                                    if (p.length === 0) {
                                        return "[]";
                                    }
                                    if (u < l.length + 1) {
                                        return '"[Array]"';
                                    }
                                    l.push(p);
                                    if (a !== "") {
                                        g += a;
                                        e += `\n${g}`;
                                        t = `,\n${g}`;
                                    }
                                    const n = Math.min(p.length, o);
                                    let i = 0;
                                    for(; i < n - 1; i++){
                                        const n = stringifyFnReplacer(String(i), p, l, c, a, g);
                                        e += n !== undefined ? n : "null";
                                        e += t;
                                    }
                                    const f = stringifyFnReplacer(String(i), p, l, c, a, g);
                                    e += f !== undefined ? f : "null";
                                    if (p.length - 1 > o) {
                                        const n = p.length - o - 1;
                                        e += `${t}"... ${getItemCount(n)} not stringified"`;
                                    }
                                    if (a !== "") {
                                        e += `\n${r}`;
                                    }
                                    l.pop();
                                    return `[${e}]`;
                                }
                                let s = Object.keys(p);
                                const y = s.length;
                                if (y === 0) {
                                    return "{}";
                                }
                                if (u < l.length + 1) {
                                    return '"[Object]"';
                                }
                                let d = "";
                                let h = "";
                                if (a !== "") {
                                    g += a;
                                    t = `,\n${g}`;
                                    d = " ";
                                }
                                const $ = Math.min(y, o);
                                if (i && !isTypedArrayWithEntries(p)) {
                                    s = sort(s, f);
                                }
                                l.push(p);
                                for(let n = 0; n < $; n++){
                                    const r = s[n];
                                    const i = stringifyFnReplacer(r, p, l, c, a, g);
                                    if (i !== undefined) {
                                        e += `${h}${strEscape(r)}:${d}${i}`;
                                        h = t;
                                    }
                                }
                                if (y > o) {
                                    const n = y - o;
                                    e += `${h}"...":${d}"${getItemCount(n)} not stringified"`;
                                    h = t;
                                }
                                if (a !== "" && h.length > 1) {
                                    e = `\n${g}${e}\n${r}`;
                                }
                                l.pop();
                                return `{${e}}`;
                            }
                        case "number":
                            return isFinite(p) ? String(p) : t ? t(p) : "null";
                        case "boolean":
                            return p === true ? "true" : "false";
                        case "undefined":
                            return undefined;
                        case "bigint":
                            if (r) {
                                return String(p);
                            }
                        default:
                            return t ? t(p) : undefined;
                    }
                }
                function stringifyArrayReplacer(e, i, f, s, l, c) {
                    if (typeof i === "object" && i !== null && typeof i.toJSON === "function") {
                        i = i.toJSON(e);
                    }
                    switch(typeof i){
                        case "string":
                            return strEscape(i);
                        case "object":
                            {
                                if (i === null) {
                                    return "null";
                                }
                                if (f.indexOf(i) !== -1) {
                                    return n;
                                }
                                const e = c;
                                let t = "";
                                let r = ",";
                                if (Array.isArray(i)) {
                                    if (i.length === 0) {
                                        return "[]";
                                    }
                                    if (u < f.length + 1) {
                                        return '"[Array]"';
                                    }
                                    f.push(i);
                                    if (l !== "") {
                                        c += l;
                                        t += `\n${c}`;
                                        r = `,\n${c}`;
                                    }
                                    const n = Math.min(i.length, o);
                                    let a = 0;
                                    for(; a < n - 1; a++){
                                        const e = stringifyArrayReplacer(String(a), i[a], f, s, l, c);
                                        t += e !== undefined ? e : "null";
                                        t += r;
                                    }
                                    const g = stringifyArrayReplacer(String(a), i[a], f, s, l, c);
                                    t += g !== undefined ? g : "null";
                                    if (i.length - 1 > o) {
                                        const e = i.length - o - 1;
                                        t += `${r}"... ${getItemCount(e)} not stringified"`;
                                    }
                                    if (l !== "") {
                                        t += `\n${e}`;
                                    }
                                    f.pop();
                                    return `[${t}]`;
                                }
                                f.push(i);
                                let a = "";
                                if (l !== "") {
                                    c += l;
                                    r = `,\n${c}`;
                                    a = " ";
                                }
                                let g = "";
                                for (const e of s){
                                    const n = stringifyArrayReplacer(e, i[e], f, s, l, c);
                                    if (n !== undefined) {
                                        t += `${g}${strEscape(e)}:${a}${n}`;
                                        g = r;
                                    }
                                }
                                if (l !== "" && g.length > 1) {
                                    t = `\n${c}${t}\n${e}`;
                                }
                                f.pop();
                                return `{${t}}`;
                            }
                        case "number":
                            return isFinite(i) ? String(i) : t ? t(i) : "null";
                        case "boolean":
                            return i === true ? "true" : "false";
                        case "undefined":
                            return undefined;
                        case "bigint":
                            if (r) {
                                return String(i);
                            }
                        default:
                            return t ? t(i) : undefined;
                    }
                }
                function stringifyIndent(e, s, l, c, a) {
                    switch(typeof s){
                        case "string":
                            return strEscape(s);
                        case "object":
                            {
                                if (s === null) {
                                    return "null";
                                }
                                if (typeof s.toJSON === "function") {
                                    s = s.toJSON(e);
                                    if (typeof s !== "object") {
                                        return stringifyIndent(e, s, l, c, a);
                                    }
                                    if (s === null) {
                                        return "null";
                                    }
                                }
                                if (l.indexOf(s) !== -1) {
                                    return n;
                                }
                                const t = a;
                                if (Array.isArray(s)) {
                                    if (s.length === 0) {
                                        return "[]";
                                    }
                                    if (u < l.length + 1) {
                                        return '"[Array]"';
                                    }
                                    l.push(s);
                                    a += c;
                                    let e = `\n${a}`;
                                    const n = `,\n${a}`;
                                    const r = Math.min(s.length, o);
                                    let i = 0;
                                    for(; i < r - 1; i++){
                                        const t = stringifyIndent(String(i), s[i], l, c, a);
                                        e += t !== undefined ? t : "null";
                                        e += n;
                                    }
                                    const f = stringifyIndent(String(i), s[i], l, c, a);
                                    e += f !== undefined ? f : "null";
                                    if (s.length - 1 > o) {
                                        const t = s.length - o - 1;
                                        e += `${n}"... ${getItemCount(t)} not stringified"`;
                                    }
                                    e += `\n${t}`;
                                    l.pop();
                                    return `[${e}]`;
                                }
                                let r = Object.keys(s);
                                const g = r.length;
                                if (g === 0) {
                                    return "{}";
                                }
                                if (u < l.length + 1) {
                                    return '"[Object]"';
                                }
                                a += c;
                                const p = `,\n${a}`;
                                let y = "";
                                let d = "";
                                let h = Math.min(g, o);
                                if (isTypedArrayWithEntries(s)) {
                                    y += stringifyTypedArray(s, p, o);
                                    r = r.slice(s.length);
                                    h -= s.length;
                                    d = p;
                                }
                                if (i) {
                                    r = sort(r, f);
                                }
                                l.push(s);
                                for(let e = 0; e < h; e++){
                                    const t = r[e];
                                    const n = stringifyIndent(t, s[t], l, c, a);
                                    if (n !== undefined) {
                                        y += `${d}${strEscape(t)}: ${n}`;
                                        d = p;
                                    }
                                }
                                if (g > o) {
                                    const e = g - o;
                                    y += `${d}"...": "${getItemCount(e)} not stringified"`;
                                    d = p;
                                }
                                if (d !== "") {
                                    y = `\n${a}${y}\n${t}`;
                                }
                                l.pop();
                                return `{${y}}`;
                            }
                        case "number":
                            return isFinite(s) ? String(s) : t ? t(s) : "null";
                        case "boolean":
                            return s === true ? "true" : "false";
                        case "undefined":
                            return undefined;
                        case "bigint":
                            if (r) {
                                return String(s);
                            }
                        default:
                            return t ? t(s) : undefined;
                    }
                }
                function stringifySimple(e, s, l) {
                    switch(typeof s){
                        case "string":
                            return strEscape(s);
                        case "object":
                            {
                                if (s === null) {
                                    return "null";
                                }
                                if (typeof s.toJSON === "function") {
                                    s = s.toJSON(e);
                                    if (typeof s !== "object") {
                                        return stringifySimple(e, s, l);
                                    }
                                    if (s === null) {
                                        return "null";
                                    }
                                }
                                if (l.indexOf(s) !== -1) {
                                    return n;
                                }
                                let t = "";
                                const r = s.length !== undefined;
                                if (r && Array.isArray(s)) {
                                    if (s.length === 0) {
                                        return "[]";
                                    }
                                    if (u < l.length + 1) {
                                        return '"[Array]"';
                                    }
                                    l.push(s);
                                    const e = Math.min(s.length, o);
                                    let n = 0;
                                    for(; n < e - 1; n++){
                                        const e = stringifySimple(String(n), s[n], l);
                                        t += e !== undefined ? e : "null";
                                        t += ",";
                                    }
                                    const r = stringifySimple(String(n), s[n], l);
                                    t += r !== undefined ? r : "null";
                                    if (s.length - 1 > o) {
                                        const e = s.length - o - 1;
                                        t += `,"... ${getItemCount(e)} not stringified"`;
                                    }
                                    l.pop();
                                    return `[${t}]`;
                                }
                                let c = Object.keys(s);
                                const a = c.length;
                                if (a === 0) {
                                    return "{}";
                                }
                                if (u < l.length + 1) {
                                    return '"[Object]"';
                                }
                                let g = "";
                                let p = Math.min(a, o);
                                if (r && isTypedArrayWithEntries(s)) {
                                    t += stringifyTypedArray(s, ",", o);
                                    c = c.slice(s.length);
                                    p -= s.length;
                                    g = ",";
                                }
                                if (i) {
                                    c = sort(c, f);
                                }
                                l.push(s);
                                for(let e = 0; e < p; e++){
                                    const n = c[e];
                                    const r = stringifySimple(n, s[n], l);
                                    if (r !== undefined) {
                                        t += `${g}${strEscape(n)}:${r}`;
                                        g = ",";
                                    }
                                }
                                if (a > o) {
                                    const e = a - o;
                                    t += `${g}"...":"${getItemCount(e)} not stringified"`;
                                }
                                l.pop();
                                return `{${t}}`;
                            }
                        case "number":
                            return isFinite(s) ? String(s) : t ? t(s) : "null";
                        case "boolean":
                            return s === true ? "true" : "false";
                        case "undefined":
                            return undefined;
                        case "bigint":
                            if (r) {
                                return String(s);
                            }
                        default:
                            return t ? t(s) : undefined;
                    }
                }
                function stringify(e, t, n) {
                    if (arguments.length > 1) {
                        let r = "";
                        if (typeof n === "number") {
                            r = " ".repeat(Math.min(n, 10));
                        } else if (typeof n === "string") {
                            r = n.slice(0, 10);
                        }
                        if (t != null) {
                            if (typeof t === "function") {
                                return stringifyFnReplacer("", {
                                    "": e
                                }, [], t, r, "");
                            }
                            if (Array.isArray(t)) {
                                return stringifyArrayReplacer("", e, [], getUniqueReplacerSet(t), r, "");
                            }
                        }
                        if (r.length !== 0) {
                            return stringifyIndent("", e, [], r, "");
                        }
                    }
                    return stringifySimple("", e, []);
                }
                return stringify;
            }
        }
    };
    var t = {};
    function __nccwpck_require__(n) {
        var r = t[n];
        if (r !== undefined) {
            return r.exports;
        }
        var i = t[n] = {
            exports: {}
        };
        var f = true;
        try {
            e[n](i, i.exports, __nccwpck_require__);
            f = false;
        } finally{
            if (f) delete t[n];
        }
        return i.exports;
    }
    if (typeof __nccwpck_require__ !== "undefined") __nccwpck_require__.ab = ("TURBOPACK compile-time value", "/ROOT/node_modules/next/dist/compiled/safe-stable-stringify") + "/";
    var n = __nccwpck_require__(879);
    module.exports = n;
})();
}}),
"[project]/node_modules/next/dist/shared/lib/error-source.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    decorateServerError: null,
    getErrorSource: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    decorateServerError: function() {
        return decorateServerError;
    },
    getErrorSource: function() {
        return getErrorSource;
    }
});
const symbolError = Symbol.for('NextjsError');
function getErrorSource(error) {
    return error[symbolError] || null;
}
function decorateServerError(error, type) {
    Object.defineProperty(error, symbolError, {
        writable: false,
        enumerable: false,
        configurable: false,
        value: type
    });
} //# sourceMappingURL=error-source.js.map
}}),
"[project]/node_modules/next/dist/next-devtools/userspace/app/terminal-logging-config.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    getIsTerminalLoggingEnabled: null,
    getTerminalLoggingConfig: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    getIsTerminalLoggingEnabled: function() {
        return getIsTerminalLoggingEnabled;
    },
    getTerminalLoggingConfig: function() {
        return getTerminalLoggingConfig;
    }
});
function getTerminalLoggingConfig() {
    try {
        return JSON.parse(("TURBOPACK compile-time value", "false") || 'false');
    } catch (e) {
        return false;
    }
}
function getIsTerminalLoggingEnabled() {
    const config = getTerminalLoggingConfig();
    return Boolean(config);
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=terminal-logging-config.js.map
}}),
"[project]/node_modules/next/dist/next-devtools/shared/forward-logs-shared.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    UNDEFINED_MARKER: null,
    patchConsoleMethod: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    UNDEFINED_MARKER: function() {
        return UNDEFINED_MARKER;
    },
    patchConsoleMethod: function() {
        return patchConsoleMethod;
    }
});
const UNDEFINED_MARKER = '__next_tagged_undefined';
function patchConsoleMethod(methodName, wrapper) {
    const descriptor = Object.getOwnPropertyDescriptor(console, methodName);
    if (descriptor && (descriptor.configurable || descriptor.writable) && typeof descriptor.value === 'function') {
        const originalMethod = descriptor.value;
        const originalName = Object.getOwnPropertyDescriptor(originalMethod, 'name');
        const wrapperMethod = function() {
            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                args[_key] = arguments[_key];
            }
            wrapper(methodName, ...args);
            originalMethod.apply(this, args);
        };
        if (originalName) {
            Object.defineProperty(wrapperMethod, 'name', originalName);
        }
        Object.defineProperty(console, methodName, {
            value: wrapperMethod
        });
        return ()=>{
            Object.defineProperty(console, methodName, {
                value: originalMethod,
                writable: descriptor.writable,
                configurable: descriptor.configurable
            });
        };
    }
    return ()=>{};
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=forward-logs-shared.js.map
}}),
"[project]/node_modules/next/dist/next-devtools/userspace/app/forward-logs.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    PROMISE_MARKER: null,
    UNAVAILABLE_MARKER: null,
    forwardErrorLog: null,
    forwardUnhandledError: null,
    initializeDebugLogForwarding: null,
    isTerminalLoggingEnabled: null,
    logQueue: null,
    logStringify: null,
    logUnhandledRejection: null,
    preLogSerializationClone: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    PROMISE_MARKER: function() {
        return PROMISE_MARKER;
    },
    UNAVAILABLE_MARKER: function() {
        return UNAVAILABLE_MARKER;
    },
    forwardErrorLog: function() {
        return forwardErrorLog;
    },
    forwardUnhandledError: function() {
        return forwardUnhandledError;
    },
    initializeDebugLogForwarding: function() {
        return initializeDebugLogForwarding;
    },
    isTerminalLoggingEnabled: function() {
        return isTerminalLoggingEnabled;
    },
    logQueue: function() {
        return logQueue;
    },
    logStringify: function() {
        return logStringify;
    },
    logUnhandledRejection: function() {
        return logUnhandledRejection;
    },
    preLogSerializationClone: function() {
        return preLogSerializationClone;
    }
});
const _safestablestringify = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/safe-stable-stringify/index.js [app-ssr] (ecmascript)");
const _stitchederror = __turbopack_context__.r("[project]/node_modules/next/dist/next-devtools/userspace/app/errors/stitched-error.js [app-ssr] (ecmascript)");
const _errorsource = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/error-source.js [app-ssr] (ecmascript)");
const _terminalloggingconfig = __turbopack_context__.r("[project]/node_modules/next/dist/next-devtools/userspace/app/terminal-logging-config.js [app-ssr] (ecmascript)");
const _forwardlogsshared = __turbopack_context__.r("[project]/node_modules/next/dist/next-devtools/shared/forward-logs-shared.js [app-ssr] (ecmascript)");
const terminalLoggingConfig = (0, _terminalloggingconfig.getTerminalLoggingConfig)();
const PROMISE_MARKER = 'Promise {}';
const UNAVAILABLE_MARKER = '[Unable to view]';
const maximumDepth = typeof terminalLoggingConfig === 'object' && terminalLoggingConfig.depthLimit ? terminalLoggingConfig.depthLimit : 5;
const maximumBreadth = typeof terminalLoggingConfig === 'object' && terminalLoggingConfig.edgeLimit ? terminalLoggingConfig.edgeLimit : 100;
const stringify = (0, _safestablestringify.configure)({
    maximumDepth,
    maximumBreadth
});
const isTerminalLoggingEnabled = (0, _terminalloggingconfig.getIsTerminalLoggingEnabled)();
const methods = [
    'log',
    'info',
    'warn',
    'debug',
    'table',
    'assert',
    'dir',
    'dirxml',
    'group',
    'groupCollapsed',
    'groupEnd',
    'trace'
];
function preLogSerializationClone(value, seen) {
    if (seen === void 0) seen = new WeakMap();
    if (value === undefined) return _forwardlogsshared.UNDEFINED_MARKER;
    if (value === null || typeof value !== 'object') return value;
    if (seen.has(value)) return seen.get(value);
    try {
        Object.keys(value);
    } catch (e) {
        return UNAVAILABLE_MARKER;
    }
    try {
        if (typeof value.then === 'function') return PROMISE_MARKER;
    } catch (e) {
        return UNAVAILABLE_MARKER;
    }
    if (Array.isArray(value)) {
        const out = [];
        seen.set(value, out);
        for (const item of value){
            try {
                out.push(preLogSerializationClone(item, seen));
            } catch (e) {
                out.push(UNAVAILABLE_MARKER);
            }
        }
        return out;
    }
    const proto = Object.getPrototypeOf(value);
    if (proto === Object.prototype || proto === null) {
        const out = {};
        seen.set(value, out);
        for (const key of Object.keys(value)){
            try {
                out[key] = preLogSerializationClone(value[key], seen);
            } catch (e) {
                out[key] = UNAVAILABLE_MARKER;
            }
        }
        return out;
    }
    return Object.prototype.toString.call(value);
}
const logStringify = (data)=>{
    try {
        const result = stringify(data);
        return result != null ? result : '"' + UNAVAILABLE_MARKER + '"';
    } catch (e) {
        return '"' + UNAVAILABLE_MARKER + '"';
    }
};
const afterThisFrame = (cb)=>{
    let timeout;
    const rafId = requestAnimationFrame(()=>{
        timeout = setTimeout(()=>{
            cb();
        });
    });
    return ()=>{
        cancelAnimationFrame(rafId);
        clearTimeout(timeout);
    };
};
let isPatched = false;
const serializeEntries = (entries)=>entries.map((clientEntry)=>{
        switch(clientEntry.kind){
            case 'any-logged-error':
            case 'console':
                {
                    return {
                        ...clientEntry,
                        args: clientEntry.args.map(stringifyUserArg)
                    };
                }
            case 'formatted-error':
                {
                    return clientEntry;
                }
            default:
                {
                    return null;
                }
        }
    });
const logQueue = {
    entries: [],
    flushScheduled: false,
    cancelFlush: null,
    socket: null,
    sourceType: undefined,
    router: null,
    scheduleLogSend: (entry)=>{
        logQueue.entries.push(entry);
        if (logQueue.flushScheduled) {
            return;
        }
        // safe to deref and use in setTimeout closure since we cancel on new socket
        const socket = logQueue.socket;
        if (!socket) {
            return;
        }
        // we probably dont need this
        logQueue.flushScheduled = true;
        // non blocking log flush, runs at most once per frame
        logQueue.cancelFlush = afterThisFrame(()=>{
            logQueue.flushScheduled = false;
            // just incase
            try {
                const payload = JSON.stringify({
                    event: 'browser-logs',
                    entries: serializeEntries(logQueue.entries),
                    router: logQueue.router,
                    // needed for source mapping, we just assign the sourceType from the last error for the whole batch
                    sourceType: logQueue.sourceType
                });
                socket.send(payload);
                logQueue.entries = [];
                logQueue.sourceType = undefined;
            } catch (e) {
            // error (make sure u don't infinite loop)
            /* noop */ }
        });
    },
    onSocketReady: (socket)=>{
        if (socket.readyState !== WebSocket.OPEN) {
            // invariant
            return;
        }
        // incase an existing timeout was going to run with a stale socket
        logQueue.cancelFlush == null ? void 0 : logQueue.cancelFlush.call(logQueue);
        logQueue.socket = socket;
        try {
            const payload = JSON.stringify({
                event: 'browser-logs',
                entries: serializeEntries(logQueue.entries),
                router: logQueue.router,
                sourceType: logQueue.sourceType
            });
            socket.send(payload);
            logQueue.entries = [];
            logQueue.sourceType = undefined;
        } catch (e) {
        /** noop just incase */ }
    }
};
const stringifyUserArg = (arg)=>{
    if (arg.kind !== 'arg') {
        return arg;
    }
    return {
        ...arg,
        data: logStringify(arg.data)
    };
};
const createErrorArg = (error)=>{
    const stack = stackWithOwners(error);
    return {
        kind: 'formatted-error-arg',
        prefix: error.message ? error.name + ": " + error.message : "" + error.name,
        stack
    };
};
const createLogEntry = (level, args)=>{
    // do not abstract this, it implicitly relies on which functions call it. forcing the inlined implementation makes you think about callers
    // error capture stack trace maybe
    const stack = stackWithOwners(new Error());
    const stackLines = stack == null ? void 0 : stack.split('\n');
    const cleanStack = stackLines == null ? void 0 : stackLines.slice(3).join('\n') // this is probably ignored anyways
    ;
    const entry = {
        kind: 'console',
        consoleMethodStack: cleanStack != null ? cleanStack : null,
        method: level,
        args: args.map((arg)=>{
            if (arg instanceof Error) {
                return createErrorArg(arg);
            }
            return {
                kind: 'arg',
                data: preLogSerializationClone(arg)
            };
        })
    };
    logQueue.scheduleLogSend(entry);
};
const forwardErrorLog = (args)=>{
    const errorObjects = args.filter((arg)=>arg instanceof Error);
    const first = errorObjects.at(0);
    if (first) {
        const source = (0, _errorsource.getErrorSource)(first);
        if (source) {
            logQueue.sourceType = source;
        }
    }
    /**
   * browser shows stack regardless of type of data passed to console.error, so we should do the same
   *
   * do not abstract this, it implicitly relies on which functions call it. forcing the inlined implementation makes you think about callers
   */ const stack = stackWithOwners(new Error());
    const stackLines = stack == null ? void 0 : stack.split('\n');
    const cleanStack = stackLines == null ? void 0 : stackLines.slice(3).join('\n');
    const entry = {
        kind: 'any-logged-error',
        method: 'error',
        consoleErrorStack: cleanStack != null ? cleanStack : '',
        args: args.map((arg)=>{
            if (arg instanceof Error) {
                return createErrorArg(arg);
            }
            return {
                kind: 'arg',
                data: preLogSerializationClone(arg)
            };
        })
    };
    logQueue.scheduleLogSend(entry);
};
const createUncaughtErrorEntry = (errorName, errorMessage, fullStack)=>{
    const entry = {
        kind: 'formatted-error',
        prefix: "Uncaught " + errorName + ": " + errorMessage,
        stack: fullStack,
        method: 'error'
    };
    logQueue.scheduleLogSend(entry);
};
const stackWithOwners = (error)=>{
    let ownerStack = '';
    (0, _stitchederror.setOwnerStackIfAvailable)(error);
    ownerStack = (0, _stitchederror.getOwnerStack)(error) || '';
    const stack = (error.stack || '') + ownerStack;
    return stack;
};
function logUnhandledRejection(reason) {
    if (reason instanceof Error) {
        createUnhandledRejectionErrorEntry(reason, stackWithOwners(reason));
        return;
    }
    createUnhandledRejectionNonErrorEntry(reason);
}
const createUnhandledRejectionErrorEntry = (error, fullStack)=>{
    const source = (0, _errorsource.getErrorSource)(error);
    if (source) {
        logQueue.sourceType = source;
    }
    const entry = {
        kind: 'formatted-error',
        prefix: " unhandledRejection: " + error.name + ": " + error.message,
        stack: fullStack,
        method: 'error'
    };
    logQueue.scheduleLogSend(entry);
};
const createUnhandledRejectionNonErrorEntry = (reason)=>{
    const entry = {
        kind: 'any-logged-error',
        // we can't access the stack since the event is dispatched async and creating an inline error would be meaningless
        consoleErrorStack: '',
        method: 'error',
        args: [
            {
                kind: 'arg',
                data: " unhandledRejection:",
                isRejectionMessage: true
            },
            {
                kind: 'arg',
                data: preLogSerializationClone(reason)
            }
        ]
    };
    logQueue.scheduleLogSend(entry);
};
const isHMR = (args)=>{
    const firstArg = args[0];
    if (typeof firstArg !== 'string') {
        return false;
    }
    if (firstArg.startsWith('[Fast Refresh]')) {
        return true;
    }
    if (firstArg.startsWith('[HMR]')) {
        return true;
    }
    return false;
};
const isIgnoredLog = (args)=>{
    if (args.length < 3) {
        return false;
    }
    const [format, styles, label] = args;
    if (typeof format !== 'string' || typeof styles !== 'string' || typeof label !== 'string') {
        return false;
    }
    // kinda hacky, we should define a common format for these strings so we can safely ignore
    return format.startsWith('%c%s%c') && styles.includes('background:');
};
function forwardUnhandledError(error) {
    createUncaughtErrorEntry(error.name, error.message, stackWithOwners(error));
}
const initializeDebugLogForwarding = (router)=>{
    // probably don't need this
    if (isPatched) {
        return;
    }
    // TODO(rob): why does this break rendering on server, important to know incase the same bug appears in browser
    if ("TURBOPACK compile-time truthy", 1) {
        return;
    }
    //TURBOPACK unreachable
    ;
};
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=forward-logs.js.map
}}),
"[project]/node_modules/next/dist/next-devtools/userspace/app/errors/use-error-handler.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    handleClientError: null,
    handleConsoleError: null,
    handleGlobalErrors: null,
    useErrorHandler: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    handleClientError: function() {
        return handleClientError;
    },
    handleConsoleError: function() {
        return handleConsoleError;
    },
    handleGlobalErrors: function() {
        return handleGlobalErrors;
    },
    useErrorHandler: function() {
        return useErrorHandler;
    }
});
const _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-ssr] (ecmascript)");
const _react = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
const _isnextroutererror = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/is-next-router-error.js [app-ssr] (ecmascript)");
const _console = __turbopack_context__.r("[project]/node_modules/next/dist/client/lib/console.js [app-ssr] (ecmascript)");
const _iserror = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/lib/is-error.js [app-ssr] (ecmascript)"));
const _consoleerror = __turbopack_context__.r("[project]/node_modules/next/dist/next-devtools/shared/console-error.js [app-ssr] (ecmascript)");
const _stitchederror = __turbopack_context__.r("[project]/node_modules/next/dist/next-devtools/userspace/app/errors/stitched-error.js [app-ssr] (ecmascript)");
const _forwardlogs = __turbopack_context__.r("[project]/node_modules/next/dist/next-devtools/userspace/app/forward-logs.js [app-ssr] (ecmascript)");
const queueMicroTask = globalThis.queueMicrotask || ((cb)=>Promise.resolve().then(cb));
const errorQueue = [];
const errorHandlers = [];
const rejectionQueue = [];
const rejectionHandlers = [];
function handleConsoleError(originError, consoleErrorArgs) {
    let error;
    const { environmentName } = (0, _console.parseConsoleArgs)(consoleErrorArgs);
    if ((0, _iserror.default)(originError)) {
        error = (0, _consoleerror.createConsoleError)(originError, environmentName);
    } else {
        error = (0, _consoleerror.createConsoleError)((0, _console.formatConsoleArgs)(consoleErrorArgs), environmentName);
    }
    (0, _stitchederror.setOwnerStackIfAvailable)(error);
    errorQueue.push(error);
    for (const handler of errorHandlers){
        // Delayed the error being passed to React Dev Overlay,
        // avoid the state being synchronously updated in the component.
        queueMicroTask(()=>{
            handler(error);
        });
    }
}
function handleClientError(error) {
    errorQueue.push(error);
    for (const handler of errorHandlers){
        // Delayed the error being passed to React Dev Overlay,
        // avoid the state being synchronously updated in the component.
        queueMicroTask(()=>{
            handler(error);
        });
    }
}
function useErrorHandler(handleOnUnhandledError, handleOnUnhandledRejection) {
    (0, _react.useEffect)(()=>{
        // Handle queued errors.
        errorQueue.forEach(handleOnUnhandledError);
        rejectionQueue.forEach(handleOnUnhandledRejection);
        // Listen to new errors.
        errorHandlers.push(handleOnUnhandledError);
        rejectionHandlers.push(handleOnUnhandledRejection);
        return ()=>{
            // Remove listeners.
            errorHandlers.splice(errorHandlers.indexOf(handleOnUnhandledError), 1);
            rejectionHandlers.splice(rejectionHandlers.indexOf(handleOnUnhandledRejection), 1);
            // Reset error queues.
            errorQueue.splice(0, errorQueue.length);
            rejectionQueue.splice(0, rejectionQueue.length);
        };
    }, [
        handleOnUnhandledError,
        handleOnUnhandledRejection
    ]);
}
function onUnhandledError(event) {
    const thrownValue = event.error;
    if ((0, _isnextroutererror.isNextRouterError)(thrownValue)) {
        event.preventDefault();
        return false;
    }
    // When there's an error property present, we log the error to error overlay.
    // Otherwise we don't do anything as it's not logging in the console either.
    if (thrownValue) {
        const error = (0, _stitchederror.coerceError)(thrownValue);
        (0, _stitchederror.setOwnerStackIfAvailable)(error);
        handleClientError(error);
        if (_forwardlogs.isTerminalLoggingEnabled) {
            (0, _forwardlogs.forwardUnhandledError)(error);
        }
    }
}
function onUnhandledRejection(ev) {
    const reason = ev == null ? void 0 : ev.reason;
    if ((0, _isnextroutererror.isNextRouterError)(reason)) {
        ev.preventDefault();
        return;
    }
    const error = (0, _stitchederror.coerceError)(reason);
    (0, _stitchederror.setOwnerStackIfAvailable)(error);
    rejectionQueue.push(error);
    for (const handler of rejectionHandlers){
        handler(error);
    }
    if (_forwardlogs.isTerminalLoggingEnabled) {
        (0, _forwardlogs.logUnhandledRejection)(reason);
    }
}
function handleGlobalErrors() {
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=use-error-handler.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/errors/constants.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "MISSING_ROOT_TAGS_ERROR", {
    enumerable: true,
    get: function() {
        return MISSING_ROOT_TAGS_ERROR;
    }
});
const MISSING_ROOT_TAGS_ERROR = 'NEXT_MISSING_ROOT_TAGS';
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=constants.js.map
}}),
"[project]/node_modules/next/dist/next-devtools/userspace/app/errors/replay-ssr-only-errors.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "ReplaySsrOnlyErrors", {
    enumerable: true,
    get: function() {
        return ReplaySsrOnlyErrors;
    }
});
const _react = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
const _useerrorhandler = __turbopack_context__.r("[project]/node_modules/next/dist/next-devtools/userspace/app/errors/use-error-handler.js [app-ssr] (ecmascript)");
const _isnextroutererror = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/is-next-router-error.js [app-ssr] (ecmascript)");
const _constants = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/errors/constants.js [app-ssr] (ecmascript)");
function readSsrError() {
    if (typeof document === 'undefined') {
        return null;
    }
    const ssrErrorTemplateTag = document.querySelector('template[data-next-error-message]');
    if (ssrErrorTemplateTag) {
        const message = ssrErrorTemplateTag.getAttribute('data-next-error-message');
        const stack = ssrErrorTemplateTag.getAttribute('data-next-error-stack');
        const digest = ssrErrorTemplateTag.getAttribute('data-next-error-digest');
        const error = Object.defineProperty(new Error(message), "__NEXT_ERROR_CODE", {
            value: "E394",
            enumerable: false,
            configurable: true
        });
        if (digest) {
            ;
            error.digest = digest;
        }
        // Skip Next.js SSR'd internal errors that which will be handled by the error boundaries.
        if ((0, _isnextroutererror.isNextRouterError)(error)) {
            return null;
        }
        error.stack = stack || '';
        return error;
    }
    return null;
}
function ReplaySsrOnlyErrors(param) {
    let { onBlockingError } = param;
    if ("TURBOPACK compile-time truthy", 1) {
        // Need to read during render. The attributes will be gone after commit.
        const ssrError = readSsrError();
        // eslint-disable-next-line react-hooks/rules-of-hooks
        (0, _react.useEffect)(()=>{
            if (ssrError !== null) {
                // TODO(veil): Include original Owner Stack (NDX-905)
                // TODO(veil): Mark as recoverable error
                // TODO(veil): console.error
                (0, _useerrorhandler.handleClientError)(ssrError);
                // If it's missing root tags, we can't recover, make it blocking.
                if (ssrError.digest === _constants.MISSING_ROOT_TAGS_ERROR) {
                    onBlockingError();
                }
            }
        }, [
            ssrError,
            onBlockingError
        ]);
    }
    return null;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=replay-ssr-only-errors.js.map
}}),
"[project]/node_modules/next/dist/client/dev/runtime-error-handler.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "RuntimeErrorHandler", {
    enumerable: true,
    get: function() {
        return RuntimeErrorHandler;
    }
});
const RuntimeErrorHandler = {
    hadRuntimeError: false
};
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=runtime-error-handler.js.map
}}),
"[project]/node_modules/next/dist/next-devtools/userspace/app/segment-explorer-node.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE: null,
    SegmentBoundaryTriggerNode: null,
    SegmentStateProvider: null,
    SegmentViewNode: null,
    SegmentViewStateNode: null,
    useSegmentState: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE: function() {
        return SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE;
    },
    SegmentBoundaryTriggerNode: function() {
        return SegmentBoundaryTriggerNode;
    },
    SegmentStateProvider: function() {
        return SegmentStateProvider;
    },
    SegmentViewNode: function() {
        return SegmentViewNode;
    },
    SegmentViewStateNode: function() {
        return SegmentViewStateNode;
    },
    useSegmentState: function() {
        return useSegmentState;
    }
});
const _jsxruntime = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js [app-ssr] (ecmascript)");
const _react = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
const _nextdevtools = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/next-devtools/index.js [app-ssr] (ecmascript)");
const _notfound = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/not-found.js [app-ssr] (ecmascript)");
const SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE = 'NEXT_DEVTOOLS_SIMULATED_ERROR';
function SegmentTrieNode(param) {
    let { type, pagePath } = param;
    const { boundaryType, setBoundaryType } = useSegmentState();
    const nodeState = (0, _react.useMemo)(()=>{
        return {
            type,
            pagePath,
            boundaryType,
            setBoundaryType
        };
    }, [
        type,
        pagePath,
        boundaryType,
        setBoundaryType
    ]);
    // Use `useLayoutEffect` to ensure the state is updated during suspense.
    // `useEffect` won't work as the state is preserved during suspense.
    (0, _react.useLayoutEffect)(()=>{
        _nextdevtools.dispatcher.segmentExplorerNodeAdd(nodeState);
        return ()=>{
            _nextdevtools.dispatcher.segmentExplorerNodeRemove(nodeState);
        };
    }, [
        nodeState
    ]);
    return null;
}
function NotFoundSegmentNode() {
    (0, _notfound.notFound)();
}
function ErrorSegmentNode() {
    throw Object.defineProperty(new Error(SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE), "__NEXT_ERROR_CODE", {
        value: "E394",
        enumerable: false,
        configurable: true
    });
}
const forever = new Promise(()=>{});
function LoadingSegmentNode() {
    (0, _react.use)(forever);
    return null;
}
function SegmentViewStateNode(param) {
    let { page } = param;
    (0, _react.useLayoutEffect)(()=>{
        _nextdevtools.dispatcher.segmentExplorerUpdateRouteState(page);
        return ()=>{
            _nextdevtools.dispatcher.segmentExplorerUpdateRouteState('');
        };
    }, [
        page
    ]);
    return null;
}
function SegmentBoundaryTriggerNode() {
    const { boundaryType } = useSegmentState();
    let segmentNode = null;
    if (boundaryType === 'loading') {
        segmentNode = /*#__PURE__*/ (0, _jsxruntime.jsx)(LoadingSegmentNode, {});
    } else if (boundaryType === 'not-found') {
        segmentNode = /*#__PURE__*/ (0, _jsxruntime.jsx)(NotFoundSegmentNode, {});
    } else if (boundaryType === 'error') {
        segmentNode = /*#__PURE__*/ (0, _jsxruntime.jsx)(ErrorSegmentNode, {});
    }
    return segmentNode;
}
function SegmentViewNode(param) {
    let { type, pagePath, children } = param;
    const segmentNode = /*#__PURE__*/ (0, _jsxruntime.jsx)(SegmentTrieNode, {
        type: type,
        pagePath: pagePath
    }, type);
    return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
        children: [
            segmentNode,
            children
        ]
    });
}
const SegmentStateContext = /*#__PURE__*/ (0, _react.createContext)({
    boundaryType: null,
    setBoundaryType: ()=>{}
});
function SegmentStateProvider(param) {
    let { children } = param;
    const [boundaryType, setBoundaryType] = (0, _react.useState)(null);
    const [errorBoundaryKey, setErrorBoundaryKey] = (0, _react.useState)(0);
    const reloadBoundary = (0, _react.useCallback)(()=>setErrorBoundaryKey((prev)=>prev + 1), []);
    const setBoundaryTypeAndReload = (0, _react.useCallback)((type)=>{
        if (type === null) {
            reloadBoundary();
        }
        setBoundaryType(type);
    }, [
        reloadBoundary
    ]);
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(SegmentStateContext.Provider, {
        value: {
            boundaryType,
            setBoundaryType: setBoundaryTypeAndReload
        },
        children: children
    }, errorBoundaryKey);
}
function useSegmentState() {
    return (0, _react.useContext)(SegmentStateContext);
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=segment-explorer-node.js.map
}}),
"[project]/node_modules/next/dist/next-devtools/userspace/app/app-dev-overlay-error-boundary.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "AppDevOverlayErrorBoundary", {
    enumerable: true,
    get: function() {
        return AppDevOverlayErrorBoundary;
    }
});
const _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-ssr] (ecmascript)");
const _jsxruntime = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js [app-ssr] (ecmascript)");
const _react = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
const _nextdevtools = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/next-devtools/index.js [app-ssr] (ecmascript)");
const _runtimeerrorhandler = __turbopack_context__.r("[project]/node_modules/next/dist/client/dev/runtime-error-handler.js [app-ssr] (ecmascript)");
const _errorboundary = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/error-boundary.js [app-ssr] (ecmascript)");
const _globalerror = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/client/components/builtin/global-error.js [app-ssr] (ecmascript)"));
const _segmentexplorernode = __turbopack_context__.r("[project]/node_modules/next/dist/next-devtools/userspace/app/segment-explorer-node.js [app-ssr] (ecmascript)");
function ErroredHtml(param) {
    let { globalError: [GlobalError, globalErrorStyles], error } = param;
    if (!error) {
        return /*#__PURE__*/ (0, _jsxruntime.jsxs)("html", {
            children: [
                /*#__PURE__*/ (0, _jsxruntime.jsx)("head", {}),
                /*#__PURE__*/ (0, _jsxruntime.jsx)("body", {})
            ]
        });
    }
    return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_errorboundary.ErrorBoundary, {
        errorComponent: _globalerror.default,
        children: [
            globalErrorStyles,
            /*#__PURE__*/ (0, _jsxruntime.jsx)(GlobalError, {
                error: error
            })
        ]
    });
}
class AppDevOverlayErrorBoundary extends _react.PureComponent {
    static getDerivedStateFromError(error) {
        _runtimeerrorhandler.RuntimeErrorHandler.hadRuntimeError = true;
        return {
            reactError: error
        };
    }
    componentDidCatch(err) {
        if (("TURBOPACK compile-time value", "development") === 'development' && err.message === _segmentexplorernode.SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE) {
            return;
        }
        _nextdevtools.dispatcher.openErrorOverlay();
    }
    render() {
        const { children, globalError } = this.props;
        const { reactError } = this.state;
        const fallback = /*#__PURE__*/ (0, _jsxruntime.jsx)(ErroredHtml, {
            globalError: globalError,
            error: reactError
        });
        return reactError !== null ? fallback : children;
    }
    constructor(...args){
        super(...args), this.state = {
            reactError: null
        };
    }
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=app-dev-overlay-error-boundary.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/normalized-asset-prefix.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "normalizedAssetPrefix", {
    enumerable: true,
    get: function() {
        return normalizedAssetPrefix;
    }
});
function normalizedAssetPrefix(assetPrefix) {
    // remove all leading slashes and trailing slashes
    const escapedAssetPrefix = (assetPrefix == null ? void 0 : assetPrefix.replace(/^\/+|\/+$/g, '')) || false;
    // if an assetPrefix was '/', we return empty string
    // because it could be an unnecessary trailing slash
    if (!escapedAssetPrefix) {
        return '';
    }
    if (URL.canParse(escapedAssetPrefix)) {
        const url = new URL(escapedAssetPrefix).toString();
        return url.endsWith('/') ? url.slice(0, -1) : url;
    }
    // assuming assetPrefix here is a pathname-style,
    // restore the leading slash
    return "/" + escapedAssetPrefix;
} //# sourceMappingURL=normalized-asset-prefix.js.map
}}),
"[project]/node_modules/next/dist/client/dev/hot-reloader/get-socket-url.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "getSocketUrl", {
    enumerable: true,
    get: function() {
        return getSocketUrl;
    }
});
const _normalizedassetprefix = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/normalized-asset-prefix.js [app-ssr] (ecmascript)");
function getSocketProtocol(assetPrefix) {
    let protocol = window.location.protocol;
    try {
        // assetPrefix is a url
        protocol = new URL(assetPrefix).protocol;
    } catch (e) {}
    return protocol === 'http:' ? 'ws:' : 'wss:';
}
function getSocketUrl(assetPrefix) {
    const prefix = (0, _normalizedassetprefix.normalizedAssetPrefix)(assetPrefix);
    const protocol = getSocketProtocol(assetPrefix || '');
    if (URL.canParse(prefix)) {
        // since normalized asset prefix is ensured to be a URL format,
        // we can safely replace the protocol
        return prefix.replace(/^http/, 'ws');
    }
    const { hostname, port } = window.location;
    return protocol + "//" + hostname + (port ? ":" + port : '') + prefix;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=get-socket-url.js.map
}}),
"[project]/node_modules/next/dist/client/dev/hot-reloader/app/use-websocket.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    useSendMessage: null,
    useTurbopack: null,
    useWebsocket: null,
    useWebsocketPing: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    useSendMessage: function() {
        return useSendMessage;
    },
    useTurbopack: function() {
        return useTurbopack;
    },
    useWebsocket: function() {
        return useWebsocket;
    },
    useWebsocketPing: function() {
        return useWebsocketPing;
    }
});
const _react = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
const _approutercontextsharedruntime = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/contexts/app-router-context.js [app-ssr] (ecmascript)");
const _getsocketurl = __turbopack_context__.r("[project]/node_modules/next/dist/client/dev/hot-reloader/get-socket-url.js [app-ssr] (ecmascript)");
function useWebsocket(assetPrefix) {
    const webSocketRef = (0, _react.useRef)(undefined);
    (0, _react.useEffect)(()=>{
        if (webSocketRef.current) {
            return;
        }
        const url = (0, _getsocketurl.getSocketUrl)(assetPrefix);
        webSocketRef.current = new window.WebSocket("" + url + "/_next/webpack-hmr");
    }, [
        assetPrefix
    ]);
    return webSocketRef;
}
function useSendMessage(webSocketRef) {
    const sendMessage = (0, _react.useCallback)((data)=>{
        const socket = webSocketRef.current;
        if (!socket || socket.readyState !== socket.OPEN) {
            return;
        }
        return socket.send(data);
    }, [
        webSocketRef
    ]);
    return sendMessage;
}
function useTurbopack(sendMessage, onUpdateError) {
    const turbopackState = (0, _react.useRef)({
        init: false,
        // Until the dynamic import resolves, queue any turbopack messages which will be replayed.
        queue: [],
        callback: undefined
    });
    const processTurbopackMessage = (0, _react.useCallback)((msg)=>{
        const { callback, queue } = turbopackState.current;
        if (callback) {
            callback(msg);
        } else {
            queue.push(msg);
        }
    }, []);
    (0, _react.useEffect)(()=>{
        const { current: initCurrent } = turbopackState;
        // TODO(WEB-1589): only install if `process.turbopack` set.
        if (initCurrent.init) {
            return;
        }
        initCurrent.init = true;
        __turbopack_context__.r("[turbopack]/browser/dev/hmr-client/hmr-client.ts [app-ssr] (ecmascript, async loader)")(__turbopack_context__.i).then((param)=>{
            let { connect } = param;
            const { current } = turbopackState;
            connect({
                addMessageListener (cb) {
                    current.callback = cb;
                    // Replay all Turbopack messages before we were able to establish the HMR client.
                    for (const msg of current.queue){
                        cb(msg);
                    }
                    current.queue = undefined;
                },
                sendMessage,
                onUpdateError
            });
        });
    }, [
        sendMessage,
        onUpdateError
    ]);
    return processTurbopackMessage;
}
function useWebsocketPing(websocketRef) {
    const sendMessage = useSendMessage(websocketRef);
    const { tree } = (0, _react.useContext)(_approutercontextsharedruntime.GlobalLayoutRouterContext);
    (0, _react.useEffect)(()=>{
        // Never send pings when using Turbopack as it's not used.
        // Pings were originally used to keep track of active routes in on-demand-entries with webpack.
        if ("TURBOPACK compile-time truthy", 1) {
            return;
        }
        //TURBOPACK unreachable
        ;
        // Taken from on-demand-entries-client.js
        const interval = undefined;
    }, [
        tree,
        sendMessage
    ]);
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=use-websocket.js.map
}}),
"[project]/node_modules/next/dist/server/dev/hot-reloader-types.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "HMR_ACTIONS_SENT_TO_BROWSER", {
    enumerable: true,
    get: function() {
        return HMR_ACTIONS_SENT_TO_BROWSER;
    }
});
var HMR_ACTIONS_SENT_TO_BROWSER = /*#__PURE__*/ function(HMR_ACTIONS_SENT_TO_BROWSER) {
    HMR_ACTIONS_SENT_TO_BROWSER["ADDED_PAGE"] = "addedPage";
    HMR_ACTIONS_SENT_TO_BROWSER["REMOVED_PAGE"] = "removedPage";
    HMR_ACTIONS_SENT_TO_BROWSER["RELOAD_PAGE"] = "reloadPage";
    HMR_ACTIONS_SENT_TO_BROWSER["SERVER_COMPONENT_CHANGES"] = "serverComponentChanges";
    HMR_ACTIONS_SENT_TO_BROWSER["MIDDLEWARE_CHANGES"] = "middlewareChanges";
    HMR_ACTIONS_SENT_TO_BROWSER["CLIENT_CHANGES"] = "clientChanges";
    HMR_ACTIONS_SENT_TO_BROWSER["SERVER_ONLY_CHANGES"] = "serverOnlyChanges";
    HMR_ACTIONS_SENT_TO_BROWSER["SYNC"] = "sync";
    HMR_ACTIONS_SENT_TO_BROWSER["BUILT"] = "built";
    HMR_ACTIONS_SENT_TO_BROWSER["BUILDING"] = "building";
    HMR_ACTIONS_SENT_TO_BROWSER["DEV_PAGES_MANIFEST_UPDATE"] = "devPagesManifestUpdate";
    HMR_ACTIONS_SENT_TO_BROWSER["TURBOPACK_MESSAGE"] = "turbopack-message";
    HMR_ACTIONS_SENT_TO_BROWSER["SERVER_ERROR"] = "serverError";
    HMR_ACTIONS_SENT_TO_BROWSER["TURBOPACK_CONNECTED"] = "turbopack-connected";
    HMR_ACTIONS_SENT_TO_BROWSER["ISR_MANIFEST"] = "isrManifest";
    HMR_ACTIONS_SENT_TO_BROWSER["DEV_INDICATOR"] = "devIndicator";
    return HMR_ACTIONS_SENT_TO_BROWSER;
}({}); //# sourceMappingURL=hot-reloader-types.js.map
}}),
"[project]/node_modules/next/dist/client/dev/report-hmr-latency.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, /**
 * Logs information about a completed HMR to the console, the server (via a
 * `client-hmr-latency` event), and to `self.__NEXT_HMR_LATENCY_CB` (a debugging
 * hook).
 *
 * @param hasUpdate Set this to `false` to avoid reporting the HMR event via a
 *   `client-hmr-latency` event or to `self.__NEXT_HMR_LATENCY_CB`. Used by
 *   turbopack when we must report a message to the browser console (because we
 *   already logged a "rebuilding" message), but it's not a real HMR, so we
 *   don't want to impact our telemetry.
 */ "default", {
    enumerable: true,
    get: function() {
        return reportHmrLatency;
    }
});
function reportHmrLatency(sendMessage, updatedModules, startMsSinceEpoch, endMsSinceEpoch, hasUpdate) {
    if (hasUpdate === void 0) hasUpdate = true;
    const latencyMs = endMsSinceEpoch - startMsSinceEpoch;
    console.log("[Fast Refresh] done in " + latencyMs + "ms");
    if (!hasUpdate) {
        return;
    }
    sendMessage(JSON.stringify({
        event: 'client-hmr-latency',
        id: window.__nextDevClientId,
        startTime: startMsSinceEpoch,
        endTime: endMsSinceEpoch,
        page: window.location.pathname,
        updatedModules,
        // Whether the page (tab) was hidden at the time the event occurred.
        // This can impact the accuracy of the event's timing.
        isPageHidden: document.visibilityState === 'hidden'
    }));
    if (self.__NEXT_HMR_LATENCY_CB) {
        self.__NEXT_HMR_LATENCY_CB(latencyMs);
    }
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=report-hmr-latency.js.map
}}),
"[project]/node_modules/next/dist/client/dev/hot-reloader/turbopack-hot-reloader-common.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "TurbopackHmr", {
    enumerable: true,
    get: function() {
        return TurbopackHmr;
    }
});
const _class_private_field_loose_base = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_class_private_field_loose_base.cjs [app-ssr] (ecmascript)");
const _class_private_field_loose_key = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_class_private_field_loose_key.cjs [app-ssr] (ecmascript)");
// How long to wait before reporting the HMR start, used to suppress irrelevant
// `BUILDING` events. Does not impact reported latency.
const TURBOPACK_HMR_START_DELAY_MS = 100;
var _updatedModules = /*#__PURE__*/ _class_private_field_loose_key._("_updatedModules"), _startMsSinceEpoch = /*#__PURE__*/ _class_private_field_loose_key._("_startMsSinceEpoch"), _lastUpdateMsSinceEpoch = /*#__PURE__*/ _class_private_field_loose_key._("_lastUpdateMsSinceEpoch"), _deferredReportHmrStartId = /*#__PURE__*/ _class_private_field_loose_key._("_deferredReportHmrStartId"), // as it reports *any* compilation, including fully no-op/cached compilations
// and those unrelated to HMR. Fixing this would require significant
// architectural changes.
//
// Work around this by deferring any "rebuilding" message by 100ms. If we get
// a BUILT event within that threshold and nothing has changed, just suppress
// the message entirely.
_runDeferredReportHmrStart = /*#__PURE__*/ _class_private_field_loose_key._("_runDeferredReportHmrStart"), _cancelDeferredReportHmrStart = /*#__PURE__*/ _class_private_field_loose_key._("_cancelDeferredReportHmrStart"), /** Helper for other `onEvent` methods. */ _onUpdate = /*#__PURE__*/ _class_private_field_loose_key._("_onUpdate");
class TurbopackHmr {
    onBuilding() {
        _class_private_field_loose_base._(this, _lastUpdateMsSinceEpoch)[_lastUpdateMsSinceEpoch] = undefined;
        _class_private_field_loose_base._(this, _cancelDeferredReportHmrStart)[_cancelDeferredReportHmrStart]();
        _class_private_field_loose_base._(this, _startMsSinceEpoch)[_startMsSinceEpoch] = Date.now();
        // report the HMR start after a short delay
        _class_private_field_loose_base._(this, _deferredReportHmrStartId)[_deferredReportHmrStartId] = setTimeout(()=>_class_private_field_loose_base._(this, _runDeferredReportHmrStart)[_runDeferredReportHmrStart](), self.__NEXT_HMR_TURBOPACK_REPORT_NOISY_NOOP_EVENTS ? 0 : TURBOPACK_HMR_START_DELAY_MS);
    }
    onTurbopackMessage(msg) {
        _class_private_field_loose_base._(this, _onUpdate)[_onUpdate]();
        const updatedModules = extractModulesFromTurbopackMessage(msg.data);
        for (const module1 of updatedModules){
            _class_private_field_loose_base._(this, _updatedModules)[_updatedModules].add(module1);
        }
    }
    onServerComponentChanges() {
        _class_private_field_loose_base._(this, _onUpdate)[_onUpdate]();
    }
    onReloadPage() {
        _class_private_field_loose_base._(this, _onUpdate)[_onUpdate]();
    }
    onPageAddRemove() {
        _class_private_field_loose_base._(this, _onUpdate)[_onUpdate]();
    }
    /**
   * @returns `null` if the caller should ignore the update entirely. Returns an
   *   object with `hasUpdates: false` if the caller should report the end of
   *   the HMR in the browser console, but the HMR was a no-op.
   */ onBuilt() {
        // Check that we got *any* `TurbopackMessageAction`, even if
        // `updatedModules` is empty (not everything gets recorded there).
        //
        // There's also a case where `onBuilt` gets called before `onBuilding`,
        // which can happen during initial page load. Ignore that too!
        const hasUpdates = _class_private_field_loose_base._(this, _lastUpdateMsSinceEpoch)[_lastUpdateMsSinceEpoch] != null && _class_private_field_loose_base._(this, _startMsSinceEpoch)[_startMsSinceEpoch] != null;
        if (!hasUpdates && _class_private_field_loose_base._(this, _deferredReportHmrStartId)[_deferredReportHmrStartId] != null) {
            // suppress the update entirely
            _class_private_field_loose_base._(this, _cancelDeferredReportHmrStart)[_cancelDeferredReportHmrStart]();
            return null;
        }
        _class_private_field_loose_base._(this, _runDeferredReportHmrStart)[_runDeferredReportHmrStart]();
        var _class_private_field_loose_base__lastUpdateMsSinceEpoch;
        const result = {
            hasUpdates,
            updatedModules: _class_private_field_loose_base._(this, _updatedModules)[_updatedModules],
            startMsSinceEpoch: _class_private_field_loose_base._(this, _startMsSinceEpoch)[_startMsSinceEpoch],
            endMsSinceEpoch: (_class_private_field_loose_base__lastUpdateMsSinceEpoch = _class_private_field_loose_base._(this, _lastUpdateMsSinceEpoch)[_lastUpdateMsSinceEpoch]) != null ? _class_private_field_loose_base__lastUpdateMsSinceEpoch : Date.now()
        };
        _class_private_field_loose_base._(this, _updatedModules)[_updatedModules] = new Set();
        return result;
    }
    constructor(){
        Object.defineProperty(this, _runDeferredReportHmrStart, {
            value: runDeferredReportHmrStart
        });
        Object.defineProperty(this, _cancelDeferredReportHmrStart, {
            value: cancelDeferredReportHmrStart
        });
        Object.defineProperty(this, _onUpdate, {
            value: onUpdate
        });
        Object.defineProperty(this, _updatedModules, {
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _startMsSinceEpoch, {
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _lastUpdateMsSinceEpoch, {
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _deferredReportHmrStartId, {
            writable: true,
            value: void 0
        });
        _class_private_field_loose_base._(this, _updatedModules)[_updatedModules] = new Set();
    }
}
function runDeferredReportHmrStart() {
    if (_class_private_field_loose_base._(this, _deferredReportHmrStartId)[_deferredReportHmrStartId] != null) {
        console.log('[Fast Refresh] rebuilding');
        _class_private_field_loose_base._(this, _cancelDeferredReportHmrStart)[_cancelDeferredReportHmrStart]();
    }
}
function cancelDeferredReportHmrStart() {
    clearTimeout(_class_private_field_loose_base._(this, _deferredReportHmrStartId)[_deferredReportHmrStartId]);
    _class_private_field_loose_base._(this, _deferredReportHmrStartId)[_deferredReportHmrStartId] = undefined;
}
function onUpdate() {
    _class_private_field_loose_base._(this, _runDeferredReportHmrStart)[_runDeferredReportHmrStart]();
    _class_private_field_loose_base._(this, _lastUpdateMsSinceEpoch)[_lastUpdateMsSinceEpoch] = Date.now();
}
function extractModulesFromTurbopackMessage(data) {
    const updatedModules = new Set();
    const updates = Array.isArray(data) ? data : [
        data
    ];
    for (const update of updates){
        // TODO this won't capture changes to CSS since they don't result in a "merged" update
        if (update.type !== 'partial' || update.instruction.type !== 'ChunkListUpdate' || update.instruction.merged === undefined) {
            continue;
        }
        for (const mergedUpdate of update.instruction.merged){
            for (const name of Object.keys(mergedUpdate.entries)){
                const res = /(.*)\s+\[.*/.exec(name);
                if (res === null) {
                    console.error('[Turbopack HMR] Expected module to match pattern: ' + name);
                    continue;
                }
                updatedModules.add(res[1]);
            }
        }
    }
    return updatedModules;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=turbopack-hot-reloader-common.js.map
}}),
"[project]/node_modules/next/dist/next-devtools/userspace/app/errors/use-forward-console-log.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useForwardConsoleLog", {
    enumerable: true,
    get: function() {
        return useForwardConsoleLog;
    }
});
const _react = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
const _forwardlogs = __turbopack_context__.r("[project]/node_modules/next/dist/next-devtools/userspace/app/forward-logs.js [app-ssr] (ecmascript)");
const useForwardConsoleLog = (socketRef)=>{
    (0, _react.useEffect)(()=>{
        if (!_forwardlogs.isTerminalLoggingEnabled) {
            return;
        }
        const socket = socketRef.current;
        if (!socket) {
            return;
        }
        const onOpen = ()=>{
            _forwardlogs.logQueue.onSocketReady(socket);
        };
        socket.addEventListener('open', onOpen);
        return ()=>{
            socket.removeEventListener('open', onOpen);
        };
    }, [
        socketRef
    ]);
};
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=use-forward-console-log.js.map
}}),
"[project]/node_modules/next/dist/client/dev/hot-reloader/app/hot-reloader-app.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/// <reference types="webpack/module.d.ts" />
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    default: null,
    waitForWebpackRuntimeHotUpdate: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    default: function() {
        return HotReload;
    },
    waitForWebpackRuntimeHotUpdate: function() {
        return waitForWebpackRuntimeHotUpdate;
    }
});
const _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-ssr] (ecmascript)");
const _jsxruntime = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js [app-ssr] (ecmascript)");
const _react = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
const _stripansi = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/strip-ansi/index.js [app-ssr] (ecmascript)"));
const _formatwebpackmessages = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/format-webpack-messages.js [app-ssr] (ecmascript)"));
const _navigation = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/navigation.js [app-ssr] (ecmascript)");
const _shared = __turbopack_context__.r("[project]/node_modules/next/dist/client/dev/hot-reloader/shared.js [app-ssr] (ecmascript)");
const _nextdevtools = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/next-devtools/index.js [app-ssr] (ecmascript)");
const _replayssronlyerrors = __turbopack_context__.r("[project]/node_modules/next/dist/next-devtools/userspace/app/errors/replay-ssr-only-errors.js [app-ssr] (ecmascript)");
const _appdevoverlayerrorboundary = __turbopack_context__.r("[project]/node_modules/next/dist/next-devtools/userspace/app/app-dev-overlay-error-boundary.js [app-ssr] (ecmascript)");
const _useerrorhandler = __turbopack_context__.r("[project]/node_modules/next/dist/next-devtools/userspace/app/errors/use-error-handler.js [app-ssr] (ecmascript)");
const _runtimeerrorhandler = __turbopack_context__.r("[project]/node_modules/next/dist/client/dev/runtime-error-handler.js [app-ssr] (ecmascript)");
const _usewebsocket = __turbopack_context__.r("[project]/node_modules/next/dist/client/dev/hot-reloader/app/use-websocket.js [app-ssr] (ecmascript)");
const _hotreloadertypes = __turbopack_context__.r("[project]/node_modules/next/dist/server/dev/hot-reloader-types.js [app-ssr] (ecmascript)");
const _navigationuntracked = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/navigation-untracked.js [app-ssr] (ecmascript)");
const _reporthmrlatency = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/client/dev/report-hmr-latency.js [app-ssr] (ecmascript)"));
const _turbopackhotreloadercommon = __turbopack_context__.r("[project]/node_modules/next/dist/client/dev/hot-reloader/turbopack-hot-reloader-common.js [app-ssr] (ecmascript)");
const _approuterheaders = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/app-router-headers.js [app-ssr] (ecmascript)");
const _useforwardconsolelog = __turbopack_context__.r("[project]/node_modules/next/dist/next-devtools/userspace/app/errors/use-forward-console-log.js [app-ssr] (ecmascript)");
let mostRecentCompilationHash = null;
let __nextDevClientId = Math.round(Math.random() * 100 + Date.now());
let reloading = false;
let webpackStartMsSinceEpoch = null;
const turbopackHmr = ("TURBOPACK compile-time truthy", 1) ? new _turbopackhotreloadercommon.TurbopackHmr() : "TURBOPACK unreachable";
let pendingHotUpdateWebpack = Promise.resolve();
let resolvePendingHotUpdateWebpack = ()=>{};
function setPendingHotUpdateWebpack() {
    pendingHotUpdateWebpack = new Promise((resolve)=>{
        resolvePendingHotUpdateWebpack = ()=>{
            resolve();
        };
    });
}
function waitForWebpackRuntimeHotUpdate() {
    return pendingHotUpdateWebpack;
}
// There is a newer version of the code available.
function handleAvailableHash(hash) {
    // Update last known compilation hash.
    mostRecentCompilationHash = hash;
}
/**
 * Is there a newer version of this code available?
 * For webpack: Check if the hash changed compared to __webpack_hash__
 * For Turbopack: Always true because it doesn't have __webpack_hash__
 */ function isUpdateAvailable() {
    if ("TURBOPACK compile-time truthy", 1) {
        return true;
    }
    //TURBOPACK unreachable
    ;
}
// Webpack disallows updates in other states.
function canApplyUpdates() {
    return module.hot.status() === 'idle';
}
function afterApplyUpdates(fn) {
    if (canApplyUpdates()) {
        fn();
    } else {
        function handler(status) {
            if (status === 'idle') {
                module.hot.removeStatusHandler(handler);
                fn();
            }
        }
        module.hot.addStatusHandler(handler);
    }
}
function performFullReload(err, sendMessage) {
    const stackTrace = err && (err.stack && err.stack.split('\n').slice(0, 5).join('\n') || err.message || err + '');
    sendMessage(JSON.stringify({
        event: 'client-full-reload',
        stackTrace,
        hadRuntimeError: !!_runtimeerrorhandler.RuntimeErrorHandler.hadRuntimeError,
        dependencyChain: err ? err.dependencyChain : undefined
    }));
    if (reloading) return;
    reloading = true;
    window.location.reload();
}
// Attempt to update code on the fly, fall back to a hard reload.
function tryApplyUpdatesWebpack(sendMessage) {
    if (!isUpdateAvailable() || !canApplyUpdates()) {
        resolvePendingHotUpdateWebpack();
        _nextdevtools.dispatcher.onBuildOk();
        (0, _reporthmrlatency.default)(sendMessage, [], webpackStartMsSinceEpoch, Date.now());
        return;
    }
    function handleApplyUpdates(err, updatedModules) {
        if (err || _runtimeerrorhandler.RuntimeErrorHandler.hadRuntimeError || updatedModules == null) {
            if (err) {
                console.warn(_shared.REACT_REFRESH_FULL_RELOAD);
            } else if (_runtimeerrorhandler.RuntimeErrorHandler.hadRuntimeError) {
                console.warn(_shared.REACT_REFRESH_FULL_RELOAD_FROM_ERROR);
            }
            performFullReload(err, sendMessage);
            return;
        }
        _nextdevtools.dispatcher.onBuildOk();
        if (isUpdateAvailable()) {
            // While we were updating, there was a new update! Do it again.
            tryApplyUpdatesWebpack(sendMessage);
            return;
        }
        _nextdevtools.dispatcher.onRefresh();
        resolvePendingHotUpdateWebpack();
        (0, _reporthmrlatency.default)(sendMessage, updatedModules, webpackStartMsSinceEpoch, Date.now());
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
    }
    // https://webpack.js.org/api/hot-module-replacement/#check
    module.hot.check(/* autoApply */ false).then((updatedModules)=>{
        if (updatedModules == null) {
            return null;
        }
        // We should always handle an update, even if updatedModules is empty (but
        // non-null) for any reason. That's what webpack would normally do:
        // https://github.com/webpack/webpack/blob/3aa6b6bc3a64/lib/hmr/HotModuleReplacement.runtime.js#L296-L298
        _nextdevtools.dispatcher.onBeforeRefresh();
        // https://webpack.js.org/api/hot-module-replacement/#apply
        return module.hot.apply();
    }).then((updatedModules)=>{
        handleApplyUpdates(null, updatedModules);
    }, (err)=>{
        handleApplyUpdates(err, null);
    });
}
/** Handles messages from the server for the App Router. */ function processMessage(obj, sendMessage, processTurbopackMessage, router, appIsrManifestRef, pathnameRef) {
    if (!('action' in obj)) {
        return;
    }
    function handleErrors(errors) {
        // "Massage" webpack messages.
        const formatted = (0, _formatwebpackmessages.default)({
            errors: errors,
            warnings: []
        });
        // Only show the first error.
        _nextdevtools.dispatcher.onBuildError(formatted.errors[0]);
        // Also log them to the console.
        for(let i = 0; i < formatted.errors.length; i++){
            console.error((0, _stripansi.default)(formatted.errors[i]));
        }
        // Do not attempt to reload now.
        // We will reload on next success instead.
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
    }
    function handleHotUpdate() {
        if ("TURBOPACK compile-time truthy", 1) {
            const hmrUpdate = turbopackHmr.onBuilt();
            if (hmrUpdate != null) {
                (0, _reporthmrlatency.default)(sendMessage, [
                    ...hmrUpdate.updatedModules
                ], hmrUpdate.startMsSinceEpoch, hmrUpdate.endMsSinceEpoch, hmrUpdate.hasUpdates);
            }
            _nextdevtools.dispatcher.onBuildOk();
        } else //TURBOPACK unreachable
        ;
    }
    switch(obj.action){
        case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.ISR_MANIFEST:
            {
                if ("TURBOPACK compile-time truthy", 1) {
                    if (appIsrManifestRef) {
                        appIsrManifestRef.current = obj.data;
                        // handle initial status on receiving manifest
                        // navigation is handled in useEffect for pathname changes
                        // as we'll receive the updated manifest before usePathname
                        // triggers for new value
                        if (pathnameRef.current in obj.data) {
                            _nextdevtools.dispatcher.onStaticIndicator(true);
                        } else {
                            _nextdevtools.dispatcher.onStaticIndicator(false);
                        }
                    }
                }
                break;
            }
        case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.BUILDING:
            {
                _nextdevtools.dispatcher.buildingIndicatorShow();
                if ("TURBOPACK compile-time truthy", 1) {
                    turbopackHmr.onBuilding();
                } else //TURBOPACK unreachable
                ;
                break;
            }
        case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.BUILT:
        case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.SYNC:
            {
                _nextdevtools.dispatcher.buildingIndicatorHide();
                if (obj.hash) {
                    handleAvailableHash(obj.hash);
                }
                const { errors, warnings } = obj;
                // Is undefined when it's a 'built' event
                if ('versionInfo' in obj) _nextdevtools.dispatcher.onVersionInfo(obj.versionInfo);
                if ('debug' in obj && obj.debug) _nextdevtools.dispatcher.onDebugInfo(obj.debug);
                if ('devIndicator' in obj) _nextdevtools.dispatcher.onDevIndicator(obj.devIndicator);
                const hasErrors = Boolean(errors && errors.length);
                // Compilation with errors (e.g. syntax error or missing modules).
                if (hasErrors) {
                    sendMessage(JSON.stringify({
                        event: 'client-error',
                        errorCount: errors.length,
                        clientId: __nextDevClientId
                    }));
                    handleErrors(errors);
                    return;
                }
                const hasWarnings = Boolean(warnings && warnings.length);
                if (hasWarnings) {
                    sendMessage(JSON.stringify({
                        event: 'client-warning',
                        warningCount: warnings.length,
                        clientId: __nextDevClientId
                    }));
                    // Print warnings to the console.
                    const formattedMessages = (0, _formatwebpackmessages.default)({
                        warnings: warnings,
                        errors: []
                    });
                    for(let i = 0; i < formattedMessages.warnings.length; i++){
                        if (i === 5) {
                            console.warn('There were more warnings in other files.\n' + 'You can find a complete log in the terminal.');
                            break;
                        }
                        console.warn((0, _stripansi.default)(formattedMessages.warnings[i]));
                    }
                // No early return here as we need to apply modules in the same way between warnings only and compiles without warnings
                }
                sendMessage(JSON.stringify({
                    event: 'client-success',
                    clientId: __nextDevClientId
                }));
                if (obj.action === _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.BUILT) {
                    handleHotUpdate();
                }
                return;
            }
        case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_CONNECTED:
            {
                processTurbopackMessage({
                    type: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_CONNECTED,
                    data: {
                        sessionId: obj.data.sessionId
                    }
                });
                break;
            }
        case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_MESSAGE:
            {
                turbopackHmr.onTurbopackMessage(obj);
                _nextdevtools.dispatcher.onBeforeRefresh();
                processTurbopackMessage({
                    type: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_MESSAGE,
                    data: obj.data
                });
                if (_runtimeerrorhandler.RuntimeErrorHandler.hadRuntimeError) {
                    console.warn(_shared.REACT_REFRESH_FULL_RELOAD_FROM_ERROR);
                    performFullReload(null, sendMessage);
                }
                _nextdevtools.dispatcher.onRefresh();
                break;
            }
        // TODO-APP: make server component change more granular
        case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.SERVER_COMPONENT_CHANGES:
            {
                turbopackHmr == null ? void 0 : turbopackHmr.onServerComponentChanges();
                sendMessage(JSON.stringify({
                    event: 'server-component-reload-page',
                    clientId: __nextDevClientId,
                    hash: obj.hash
                }));
                // Store the latest hash in a session cookie so that it's sent back to the
                // server with any subsequent requests.
                document.cookie = _approuterheaders.NEXT_HMR_REFRESH_HASH_COOKIE + "=" + obj.hash;
                if (_runtimeerrorhandler.RuntimeErrorHandler.hadRuntimeError) {
                    if (reloading) return;
                    reloading = true;
                    return window.location.reload();
                }
                (0, _react.startTransition)(()=>{
                    router.hmrRefresh();
                    _nextdevtools.dispatcher.onRefresh();
                });
                if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
                ;
                return;
            }
        case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.RELOAD_PAGE:
            {
                turbopackHmr == null ? void 0 : turbopackHmr.onReloadPage();
                sendMessage(JSON.stringify({
                    event: 'client-reload-page',
                    clientId: __nextDevClientId
                }));
                if (reloading) return;
                reloading = true;
                return window.location.reload();
            }
        case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.ADDED_PAGE:
        case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.REMOVED_PAGE:
            {
                turbopackHmr == null ? void 0 : turbopackHmr.onPageAddRemove();
                // TODO-APP: potentially only refresh if the currently viewed page was added/removed.
                return router.hmrRefresh();
            }
        case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.SERVER_ERROR:
            {
                const { errorJSON } = obj;
                if (errorJSON) {
                    const { message, stack } = JSON.parse(errorJSON);
                    const error = Object.defineProperty(new Error(message), "__NEXT_ERROR_CODE", {
                        value: "E394",
                        enumerable: false,
                        configurable: true
                    });
                    error.stack = stack;
                    handleErrors([
                        error
                    ]);
                }
                return;
            }
        case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.DEV_PAGES_MANIFEST_UPDATE:
            {
                return;
            }
        default:
            {}
    }
}
function HotReload(param) {
    let { assetPrefix, children, globalError } = param;
    (0, _useerrorhandler.useErrorHandler)(_nextdevtools.dispatcher.onUnhandledError, _nextdevtools.dispatcher.onUnhandledRejection);
    const webSocketRef = (0, _usewebsocket.useWebsocket)(assetPrefix);
    (0, _usewebsocket.useWebsocketPing)(webSocketRef);
    const sendMessage = (0, _usewebsocket.useSendMessage)(webSocketRef);
    (0, _useforwardconsolelog.useForwardConsoleLog)(webSocketRef);
    const processTurbopackMessage = (0, _usewebsocket.useTurbopack)(sendMessage, (err)=>performFullReload(err, sendMessage));
    const router = (0, _navigation.useRouter)();
    // We don't want access of the pathname for the dev tools to trigger a dynamic
    // access (as the dev overlay will never be present in production).
    const pathname = (0, _navigationuntracked.useUntrackedPathname)();
    const appIsrManifestRef = (0, _react.useRef)({});
    const pathnameRef = (0, _react.useRef)(pathname);
    if ("TURBOPACK compile-time truthy", 1) {
        // this conditional is only for dead-code elimination which
        // isn't a runtime conditional only build-time so ignore hooks rule
        // eslint-disable-next-line react-hooks/rules-of-hooks
        (0, _react.useEffect)(()=>{
            pathnameRef.current = pathname;
            const appIsrManifest = appIsrManifestRef.current;
            if (appIsrManifest) {
                if (pathname && pathname in appIsrManifest) {
                    try {
                        _nextdevtools.dispatcher.onStaticIndicator(true);
                    } catch (reason) {
                        let message = '';
                        if (reason instanceof DOMException) {
                            var _reason_stack;
                            // Most likely a SecurityError, because of an unavailable localStorage
                            message = (_reason_stack = reason.stack) != null ? _reason_stack : reason.message;
                        } else if (reason instanceof Error) {
                            var _reason_stack1;
                            message = 'Error: ' + reason.message + '\n' + ((_reason_stack1 = reason.stack) != null ? _reason_stack1 : '');
                        } else {
                            message = 'Unexpected Exception: ' + reason;
                        }
                        console.warn('[HMR] ' + message);
                    }
                } else {
                    _nextdevtools.dispatcher.onStaticIndicator(false);
                }
            }
        }, [
            pathname
        ]);
    }
    (0, _react.useEffect)(()=>{
        const websocket = webSocketRef.current;
        if (!websocket) return;
        const handler = (event)=>{
            try {
                const obj = JSON.parse(event.data);
                processMessage(obj, sendMessage, processTurbopackMessage, router, appIsrManifestRef, pathnameRef);
            } catch (err) {
                (0, _shared.reportInvalidHmrMessage)(event, err);
            }
        };
        websocket.addEventListener('message', handler);
        return ()=>websocket.removeEventListener('message', handler);
    }, [
        sendMessage,
        router,
        webSocketRef,
        processTurbopackMessage,
        appIsrManifestRef
    ]);
    return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_appdevoverlayerrorboundary.AppDevOverlayErrorBoundary, {
        globalError: globalError,
        children: [
            /*#__PURE__*/ (0, _jsxruntime.jsx)(_replayssronlyerrors.ReplaySsrOnlyErrors, {
                onBlockingError: _nextdevtools.dispatcher.openErrorOverlay
            }),
            children
        ]
    });
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=hot-reloader-app.js.map
}}),
"[project]/node_modules/next/dist/client/components/app-router.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    createEmptyCacheNode: null,
    createPrefetchURL: null,
    default: null,
    isExternalURL: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    createEmptyCacheNode: function() {
        return createEmptyCacheNode;
    },
    createPrefetchURL: function() {
        return createPrefetchURL;
    },
    default: function() {
        return AppRouter;
    },
    isExternalURL: function() {
        return isExternalURL;
    }
});
const _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-ssr] (ecmascript)");
const _interop_require_wildcard = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [app-ssr] (ecmascript)");
const _jsxruntime = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js [app-ssr] (ecmascript)");
const _react = /*#__PURE__*/ _interop_require_wildcard._(__turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)"));
const _approutercontextsharedruntime = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/contexts/app-router-context.js [app-ssr] (ecmascript)");
const _routerreducertypes = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/router-reducer-types.js [app-ssr] (ecmascript)");
const _createhreffromurl = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/create-href-from-url.js [app-ssr] (ecmascript)");
const _hooksclientcontextsharedruntime = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/contexts/hooks-client-context.js [app-ssr] (ecmascript)");
const _useactionqueue = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/use-action-queue.js [app-ssr] (ecmascript)");
const _errorboundary = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/error-boundary.js [app-ssr] (ecmascript)");
const _globalerror = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/client/components/builtin/global-error.js [app-ssr] (ecmascript)"));
const _isbot = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/is-bot.js [app-ssr] (ecmascript)");
const _addbasepath = __turbopack_context__.r("[project]/node_modules/next/dist/client/add-base-path.js [app-ssr] (ecmascript)");
const _approuterannouncer = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/app-router-announcer.js [app-ssr] (ecmascript)");
const _redirectboundary = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/redirect-boundary.js [app-ssr] (ecmascript)");
const _findheadincache = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/reducers/find-head-in-cache.js [app-ssr] (ecmascript)");
const _unresolvedthenable = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/unresolved-thenable.js [app-ssr] (ecmascript)");
const _removebasepath = __turbopack_context__.r("[project]/node_modules/next/dist/client/remove-base-path.js [app-ssr] (ecmascript)");
const _hasbasepath = __turbopack_context__.r("[project]/node_modules/next/dist/client/has-base-path.js [app-ssr] (ecmascript)");
const _computechangedpath = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/compute-changed-path.js [app-ssr] (ecmascript)");
const _navfailurehandler = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/nav-failure-handler.js [app-ssr] (ecmascript)");
const _approuterinstance = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/app-router-instance.js [app-ssr] (ecmascript)");
const _redirect = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/redirect.js [app-ssr] (ecmascript)");
const _redirecterror = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/redirect-error.js [app-ssr] (ecmascript)");
const _links = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/links.js [app-ssr] (ecmascript)");
const _gracefuldegradeboundary = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/client/components/errors/graceful-degrade-boundary.js [app-ssr] (ecmascript)"));
const globalMutable = {};
function isExternalURL(url) {
    return url.origin !== window.location.origin;
}
function createPrefetchURL(href) {
    // Don't prefetch for bots as they don't navigate.
    if ((0, _isbot.isBot)(window.navigator.userAgent)) {
        return null;
    }
    let url;
    try {
        url = new URL((0, _addbasepath.addBasePath)(href), window.location.href);
    } catch (_) {
        // TODO: Does this need to throw or can we just console.error instead? Does
        // anyone rely on this throwing? (Seems unlikely.)
        throw Object.defineProperty(new Error("Cannot prefetch '" + href + "' because it cannot be converted to a URL."), "__NEXT_ERROR_CODE", {
            value: "E234",
            enumerable: false,
            configurable: true
        });
    }
    // Don't prefetch during development (improves compilation performance)
    if ("TURBOPACK compile-time truthy", 1) {
        return null;
    }
    //TURBOPACK unreachable
    ;
}
function HistoryUpdater(param) {
    let { appRouterState } = param;
    (0, _react.useInsertionEffect)(()=>{
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        const { tree, pushRef, canonicalUrl } = appRouterState;
        const historyState = {
            ...pushRef.preserveCustomHistoryState ? window.history.state : {},
            // Identifier is shortened intentionally.
            // __NA is used to identify if the history entry can be handled by the app-router.
            // __N is used to identify if the history entry can be handled by the old router.
            __NA: true,
            __PRIVATE_NEXTJS_INTERNALS_TREE: tree
        };
        if (pushRef.pendingPush && // Skip pushing an additional history entry if the canonicalUrl is the same as the current url.
        // This mirrors the browser behavior for normal navigation.
        (0, _createhreffromurl.createHrefFromUrl)(new URL(window.location.href)) !== canonicalUrl) {
            // This intentionally mutates React state, pushRef is overwritten to ensure additional push/replace calls do not trigger an additional history entry.
            pushRef.pendingPush = false;
            window.history.pushState(historyState, '', canonicalUrl);
        } else {
            window.history.replaceState(historyState, '', canonicalUrl);
        }
    }, [
        appRouterState
    ]);
    (0, _react.useEffect)(()=>{
        // The Next-Url and the base tree may affect the result of a prefetch
        // task. Re-prefetch all visible links with the updated values. In most
        // cases, this will not result in any new network requests, only if
        // the prefetch result actually varies on one of these inputs.
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
    }, [
        appRouterState.nextUrl,
        appRouterState.tree
    ]);
    return null;
}
function createEmptyCacheNode() {
    return {
        lazyData: null,
        rsc: null,
        prefetchRsc: null,
        head: null,
        prefetchHead: null,
        parallelRoutes: new Map(),
        loading: null,
        navigatedAt: -1
    };
}
function copyNextJsInternalHistoryState(data) {
    if (data == null) data = {};
    const currentState = window.history.state;
    const __NA = currentState == null ? void 0 : currentState.__NA;
    if (__NA) {
        data.__NA = __NA;
    }
    const __PRIVATE_NEXTJS_INTERNALS_TREE = currentState == null ? void 0 : currentState.__PRIVATE_NEXTJS_INTERNALS_TREE;
    if (__PRIVATE_NEXTJS_INTERNALS_TREE) {
        data.__PRIVATE_NEXTJS_INTERNALS_TREE = __PRIVATE_NEXTJS_INTERNALS_TREE;
    }
    return data;
}
function Head(param) {
    let { headCacheNode } = param;
    // If this segment has a `prefetchHead`, it's the statically prefetched data.
    // We should use that on initial render instead of `head`. Then we'll switch
    // to `head` when the dynamic response streams in.
    const head = headCacheNode !== null ? headCacheNode.head : null;
    const prefetchHead = headCacheNode !== null ? headCacheNode.prefetchHead : null;
    // If no prefetch data is available, then we go straight to rendering `head`.
    const resolvedPrefetchRsc = prefetchHead !== null ? prefetchHead : head;
    // We use `useDeferredValue` to handle switching between the prefetched and
    // final values. The second argument is returned on initial render, then it
    // re-renders with the first argument.
    return (0, _react.useDeferredValue)(head, resolvedPrefetchRsc);
}
/**
 * The global router that wraps the application components.
 */ function Router(param) {
    let { actionQueue, assetPrefix, globalError, gracefullyDegrade } = param;
    const state = (0, _useactionqueue.useActionQueue)(actionQueue);
    const { canonicalUrl } = state;
    // Add memoized pathname/query for useSearchParams and usePathname.
    const { searchParams, pathname } = (0, _react.useMemo)(()=>{
        const url = new URL(canonicalUrl, ("TURBOPACK compile-time truthy", 1) ? 'http://n' : "TURBOPACK unreachable");
        return {
            // This is turned into a readonly class in `useSearchParams`
            searchParams: url.searchParams,
            pathname: (0, _hasbasepath.hasBasePath)(url.pathname) ? (0, _removebasepath.removeBasePath)(url.pathname) : url.pathname
        };
    }, [
        canonicalUrl
    ]);
    if ("TURBOPACK compile-time truthy", 1) {
        // eslint-disable-next-line react-hooks/rules-of-hooks
        const { cache, prefetchCache, tree } = state;
        // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes
        // eslint-disable-next-line react-hooks/rules-of-hooks
        (0, _react.useEffect)(()=>{
            // Add `window.nd` for debugging purposes.
            // This is not meant for use in applications as concurrent rendering will affect the cache/tree/router.
            // @ts-ignore this is for debugging
            window.nd = {
                router: _approuterinstance.publicAppRouterInstance,
                cache,
                prefetchCache,
                tree
            };
        }, [
            cache,
            prefetchCache,
            tree
        ]);
    }
    (0, _react.useEffect)(()=>{
        // If the app is restored from bfcache, it's possible that
        // pushRef.mpaNavigation is true, which would mean that any re-render of this component
        // would trigger the mpa navigation logic again from the lines below.
        // This will restore the router to the initial state in the event that the app is restored from bfcache.
        function handlePageShow(event) {
            var _window_history_state;
            if (!event.persisted || !((_window_history_state = window.history.state) == null ? void 0 : _window_history_state.__PRIVATE_NEXTJS_INTERNALS_TREE)) {
                return;
            }
            // Clear the pendingMpaPath value so that a subsequent MPA navigation to the same URL can be triggered.
            // This is necessary because if the browser restored from bfcache, the pendingMpaPath would still be set to the value
            // of the last MPA navigation.
            globalMutable.pendingMpaPath = undefined;
            (0, _useactionqueue.dispatchAppRouterAction)({
                type: _routerreducertypes.ACTION_RESTORE,
                url: new URL(window.location.href),
                tree: window.history.state.__PRIVATE_NEXTJS_INTERNALS_TREE
            });
        }
        window.addEventListener('pageshow', handlePageShow);
        return ()=>{
            window.removeEventListener('pageshow', handlePageShow);
        };
    }, []);
    (0, _react.useEffect)(()=>{
        // Ensure that any redirect errors that bubble up outside of the RedirectBoundary
        // are caught and handled by the router.
        function handleUnhandledRedirect(event) {
            const error = 'reason' in event ? event.reason : event.error;
            if ((0, _redirecterror.isRedirectError)(error)) {
                event.preventDefault();
                const url = (0, _redirect.getURLFromRedirectError)(error);
                const redirectType = (0, _redirect.getRedirectTypeFromError)(error);
                // TODO: This should access the router methods directly, rather than
                // go through the public interface.
                if (redirectType === _redirecterror.RedirectType.push) {
                    _approuterinstance.publicAppRouterInstance.push(url, {});
                } else {
                    _approuterinstance.publicAppRouterInstance.replace(url, {});
                }
            }
        }
        window.addEventListener('error', handleUnhandledRedirect);
        window.addEventListener('unhandledrejection', handleUnhandledRedirect);
        return ()=>{
            window.removeEventListener('error', handleUnhandledRedirect);
            window.removeEventListener('unhandledrejection', handleUnhandledRedirect);
        };
    }, []);
    // When mpaNavigation flag is set do a hard navigation to the new url.
    // Infinitely suspend because we don't actually want to rerender any child
    // components with the new URL and any entangled state updates shouldn't
    // commit either (eg: useTransition isPending should stay true until the page
    // unloads).
    //
    // This is a side effect in render. Don't try this at home, kids. It's
    // probably safe because we know this is a singleton component and it's never
    // in <Offscreen>. At least I hope so. (It will run twice in dev strict mode,
    // but that's... fine?)
    const { pushRef } = state;
    if (pushRef.mpaNavigation) {
        // if there's a re-render, we don't want to trigger another redirect if one is already in flight to the same URL
        if (globalMutable.pendingMpaPath !== canonicalUrl) {
            const location = window.location;
            if (pushRef.pendingPush) {
                location.assign(canonicalUrl);
            } else {
                location.replace(canonicalUrl);
            }
            globalMutable.pendingMpaPath = canonicalUrl;
        }
        // TODO-APP: Should we listen to navigateerror here to catch failed
        // navigations somehow? And should we call window.stop() if a SPA navigation
        // should interrupt an MPA one?
        // NOTE: This is intentionally using `throw` instead of `use` because we're
        // inside an externally mutable condition (pushRef.mpaNavigation), which
        // violates the rules of hooks.
        throw _unresolvedthenable.unresolvedThenable;
    }
    (0, _react.useEffect)(()=>{
        const originalPushState = window.history.pushState.bind(window.history);
        const originalReplaceState = window.history.replaceState.bind(window.history);
        // Ensure the canonical URL in the Next.js Router is updated when the URL is changed so that `usePathname` and `useSearchParams` hold the pushed values.
        const applyUrlFromHistoryPushReplace = (url)=>{
            var _window_history_state;
            const href = window.location.href;
            const tree = (_window_history_state = window.history.state) == null ? void 0 : _window_history_state.__PRIVATE_NEXTJS_INTERNALS_TREE;
            (0, _react.startTransition)(()=>{
                (0, _useactionqueue.dispatchAppRouterAction)({
                    type: _routerreducertypes.ACTION_RESTORE,
                    url: new URL(url != null ? url : href, href),
                    tree
                });
            });
        };
        /**
     * Patch pushState to ensure external changes to the history are reflected in the Next.js Router.
     * Ensures Next.js internal history state is copied to the new history entry.
     * Ensures usePathname and useSearchParams hold the newly provided url.
     */ window.history.pushState = function pushState(data, _unused, url) {
            // Avoid a loop when Next.js internals trigger pushState/replaceState
            if ((data == null ? void 0 : data.__NA) || (data == null ? void 0 : data._N)) {
                return originalPushState(data, _unused, url);
            }
            data = copyNextJsInternalHistoryState(data);
            if (url) {
                applyUrlFromHistoryPushReplace(url);
            }
            return originalPushState(data, _unused, url);
        };
        /**
     * Patch replaceState to ensure external changes to the history are reflected in the Next.js Router.
     * Ensures Next.js internal history state is copied to the new history entry.
     * Ensures usePathname and useSearchParams hold the newly provided url.
     */ window.history.replaceState = function replaceState(data, _unused, url) {
            // Avoid a loop when Next.js internals trigger pushState/replaceState
            if ((data == null ? void 0 : data.__NA) || (data == null ? void 0 : data._N)) {
                return originalReplaceState(data, _unused, url);
            }
            data = copyNextJsInternalHistoryState(data);
            if (url) {
                applyUrlFromHistoryPushReplace(url);
            }
            return originalReplaceState(data, _unused, url);
        };
        /**
     * Handle popstate event, this is used to handle back/forward in the browser.
     * By default dispatches ACTION_RESTORE, however if the history entry was not pushed/replaced by app-router it will reload the page.
     * That case can happen when the old router injected the history entry.
     */ const onPopState = (event)=>{
            if (!event.state) {
                // TODO-APP: this case only happens when pushState/replaceState was called outside of Next.js. It should probably reload the page in this case.
                return;
            }
            // This case happens when the history entry was pushed by the `pages` router.
            if (!event.state.__NA) {
                window.location.reload();
                return;
            }
            // TODO-APP: Ideally the back button should not use startTransition as it should apply the updates synchronously
            // Without startTransition works if the cache is there for this path
            (0, _react.startTransition)(()=>{
                (0, _approuterinstance.dispatchTraverseAction)(window.location.href, event.state.__PRIVATE_NEXTJS_INTERNALS_TREE);
            });
        };
        // Register popstate event to call onPopstate.
        window.addEventListener('popstate', onPopState);
        return ()=>{
            window.history.pushState = originalPushState;
            window.history.replaceState = originalReplaceState;
            window.removeEventListener('popstate', onPopState);
        };
    }, []);
    const { cache, tree, nextUrl, focusAndScrollRef } = state;
    const matchingHead = (0, _react.useMemo)(()=>{
        return (0, _findheadincache.findHeadInCache)(cache, tree[1]);
    }, [
        cache,
        tree
    ]);
    // Add memoized pathParams for useParams.
    const pathParams = (0, _react.useMemo)(()=>{
        return (0, _computechangedpath.getSelectedParams)(tree);
    }, [
        tree
    ]);
    const layoutRouterContext = (0, _react.useMemo)(()=>{
        return {
            parentTree: tree,
            parentCacheNode: cache,
            parentSegmentPath: null,
            // Root node always has `url`
            // Provided in AppTreeContext to ensure it can be overwritten in layout-router
            url: canonicalUrl
        };
    }, [
        tree,
        cache,
        canonicalUrl
    ]);
    const globalLayoutRouterContext = (0, _react.useMemo)(()=>{
        return {
            tree,
            focusAndScrollRef,
            nextUrl
        };
    }, [
        tree,
        focusAndScrollRef,
        nextUrl
    ]);
    let head;
    if (matchingHead !== null) {
        // The head is wrapped in an extra component so we can use
        // `useDeferredValue` to swap between the prefetched and final versions of
        // the head. (This is what LayoutRouter does for segment data, too.)
        //
        // The `key` is used to remount the component whenever the head moves to
        // a different segment.
        const [headCacheNode, headKey] = matchingHead;
        head = /*#__PURE__*/ (0, _jsxruntime.jsx)(Head, {
            headCacheNode: headCacheNode
        }, headKey);
    } else {
        head = null;
    }
    let content = /*#__PURE__*/ (0, _jsxruntime.jsxs)(_redirectboundary.RedirectBoundary, {
        children: [
            head,
            cache.rsc,
            /*#__PURE__*/ (0, _jsxruntime.jsx)(_approuterannouncer.AppRouterAnnouncer, {
                tree: tree
            })
        ]
    });
    if ("TURBOPACK compile-time truthy", 1) {
        // In development, we apply few error boundaries and hot-reloader:
        // - DevRootHTTPAccessFallbackBoundary: avoid using navigation API like notFound() in root layout
        // - HotReloader:
        //  - hot-reload the app when the code changes
        //  - render dev overlay
        //  - catch runtime errors and display global-error when necessary
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        const HotReloader = __turbopack_context__.r("[project]/node_modules/next/dist/client/dev/hot-reloader/app/hot-reloader-app.js [app-ssr] (ecmascript)").default;
        content = /*#__PURE__*/ (0, _jsxruntime.jsx)(HotReloader, {
            assetPrefix: assetPrefix,
            globalError: globalError,
            children: content
        });
    } else //TURBOPACK unreachable
    ;
    return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
        children: [
            /*#__PURE__*/ (0, _jsxruntime.jsx)(HistoryUpdater, {
                appRouterState: state
            }),
            /*#__PURE__*/ (0, _jsxruntime.jsx)(RuntimeStyles, {}),
            /*#__PURE__*/ (0, _jsxruntime.jsx)(_hooksclientcontextsharedruntime.PathParamsContext.Provider, {
                value: pathParams,
                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_hooksclientcontextsharedruntime.PathnameContext.Provider, {
                    value: pathname,
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_hooksclientcontextsharedruntime.SearchParamsContext.Provider, {
                        value: searchParams,
                        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_approutercontextsharedruntime.GlobalLayoutRouterContext.Provider, {
                            value: globalLayoutRouterContext,
                            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_approutercontextsharedruntime.AppRouterContext.Provider, {
                                value: _approuterinstance.publicAppRouterInstance,
                                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_approutercontextsharedruntime.LayoutRouterContext.Provider, {
                                    value: layoutRouterContext,
                                    children: content
                                })
                            })
                        })
                    })
                })
            })
        ]
    });
}
function AppRouter(param) {
    let { actionQueue, globalErrorState, assetPrefix, gracefullyDegrade } = param;
    (0, _navfailurehandler.useNavFailureHandler)();
    const router = /*#__PURE__*/ (0, _jsxruntime.jsx)(Router, {
        actionQueue: actionQueue,
        assetPrefix: assetPrefix,
        globalError: globalErrorState,
        gracefullyDegrade: gracefullyDegrade
    });
    if (gracefullyDegrade) {
        return router;
    } else {
        return /*#__PURE__*/ (0, _jsxruntime.jsx)(_errorboundary.ErrorBoundary, {
            // At the very top level, use the default GlobalError component as the final fallback.
            // When the app router itself fails, which means the framework itself fails, we show the default error.
            errorComponent: _globalerror.default,
            children: router
        });
    }
}
const runtimeStyles = new Set();
let runtimeStyleChanged = new Set();
globalThis._N_E_STYLE_LOAD = function(href) {
    let len = runtimeStyles.size;
    runtimeStyles.add(href);
    if (runtimeStyles.size !== len) {
        runtimeStyleChanged.forEach((cb)=>cb());
    }
    // TODO figure out how to get a promise here
    // But maybe it's not necessary as react would block rendering until it's loaded
    return Promise.resolve();
};
function RuntimeStyles() {
    const [, forceUpdate] = _react.default.useState(0);
    const renderedStylesSize = runtimeStyles.size;
    (0, _react.useEffect)(()=>{
        const changed = ()=>forceUpdate((c)=>c + 1);
        runtimeStyleChanged.add(changed);
        if (renderedStylesSize !== runtimeStyles.size) {
            changed();
        }
        return ()=>{
            runtimeStyleChanged.delete(changed);
        };
    }, [
        renderedStylesSize,
        forceUpdate
    ]);
    const dplId = ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : '';
    return [
        ...runtimeStyles
    ].map((href, i)=>/*#__PURE__*/ (0, _jsxruntime.jsx)("link", {
            rel: "stylesheet",
            href: "" + href + dplId,
            // @ts-ignore
            precedence: "next"
        }, i));
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=app-router.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/ppr-navigations.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    abortTask: null,
    listenForDynamicRequest: null,
    startPPRNavigation: null,
    updateCacheNodeOnPopstateRestoration: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    abortTask: function() {
        return abortTask;
    },
    listenForDynamicRequest: function() {
        return listenForDynamicRequest;
    },
    startPPRNavigation: function() {
        return startPPRNavigation;
    },
    updateCacheNodeOnPopstateRestoration: function() {
        return updateCacheNodeOnPopstateRestoration;
    }
});
const _segment = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/segment.js [app-ssr] (ecmascript)");
const _matchsegments = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/match-segments.js [app-ssr] (ecmascript)");
const _createroutercachekey = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js [app-ssr] (ecmascript)");
const _isnavigatingtonewrootlayout = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js [app-ssr] (ecmascript)");
const _prefetchcacheutils = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js [app-ssr] (ecmascript)");
const MPA_NAVIGATION_TASK = {
    route: null,
    node: null,
    dynamicRequestTree: null,
    children: null
};
function startPPRNavigation(navigatedAt, oldCacheNode, oldRouterState, newRouterState, prefetchData, prefetchHead, isPrefetchHeadPartial, isSamePageNavigation, scrollableSegmentsResult) {
    const segmentPath = [];
    return updateCacheNodeOnNavigation(navigatedAt, oldCacheNode, oldRouterState, newRouterState, false, prefetchData, prefetchHead, isPrefetchHeadPartial, isSamePageNavigation, segmentPath, scrollableSegmentsResult);
}
function updateCacheNodeOnNavigation(navigatedAt, oldCacheNode, oldRouterState, newRouterState, didFindRootLayout, prefetchData, prefetchHead, isPrefetchHeadPartial, isSamePageNavigation, segmentPath, scrollableSegmentsResult) {
    // Diff the old and new trees to reuse the shared layouts.
    const oldRouterStateChildren = oldRouterState[1];
    const newRouterStateChildren = newRouterState[1];
    const prefetchDataChildren = prefetchData !== null ? prefetchData[2] : null;
    if (!didFindRootLayout) {
        // We're currently traversing the part of the tree that was also part of
        // the previous route. If we discover a root layout, then we don't need to
        // trigger an MPA navigation. See beginRenderingNewRouteTree for context.
        const isRootLayout = newRouterState[4] === true;
        if (isRootLayout) {
            // Found a matching root layout.
            didFindRootLayout = true;
        }
    }
    const oldParallelRoutes = oldCacheNode.parallelRoutes;
    // Clone the current set of segment children, even if they aren't active in
    // the new tree.
    // TODO: We currently retain all the inactive segments indefinitely, until
    // there's an explicit refresh, or a parent layout is lazily refreshed. We
    // rely on this for popstate navigations, which update the Router State Tree
    // but do not eagerly perform a data fetch, because they expect the segment
    // data to already be in the Cache Node tree. For highly static sites that
    // are mostly read-only, this may happen only rarely, causing memory to
    // leak. We should figure out a better model for the lifetime of inactive
    // segments, so we can maintain instant back/forward navigations without
    // leaking memory indefinitely.
    const prefetchParallelRoutes = new Map(oldParallelRoutes);
    // As we diff the trees, we may sometimes modify (copy-on-write, not mutate)
    // the Route Tree that was returned by the server  for example, in the case
    // of default parallel routes, we preserve the currently active segment. To
    // avoid mutating the original tree, we clone the router state children along
    // the return path.
    let patchedRouterStateChildren = {};
    let taskChildren = null;
    // Most navigations require a request to fetch additional data from the
    // server, either because the data was not already prefetched, or because the
    // target route contains dynamic data that cannot be prefetched.
    //
    // However, if the target route is fully static, and it's already completely
    // loaded into the segment cache, then we can skip the server request.
    //
    // This starts off as `false`, and is set to `true` if any of the child
    // routes requires a dynamic request.
    let needsDynamicRequest = false;
    // As we traverse the children, we'll construct a FlightRouterState that can
    // be sent to the server to request the dynamic data. If it turns out that
    // nothing in the subtree is dynamic (i.e. needsDynamicRequest is false at the
    // end), then this will be discarded.
    // TODO: We can probably optimize the format of this data structure to only
    // include paths that are dynamic. Instead of reusing the
    // FlightRouterState type.
    let dynamicRequestTreeChildren = {};
    for(let parallelRouteKey in newRouterStateChildren){
        const newRouterStateChild = newRouterStateChildren[parallelRouteKey];
        const oldRouterStateChild = oldRouterStateChildren[parallelRouteKey];
        const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey);
        const prefetchDataChild = prefetchDataChildren !== null ? prefetchDataChildren[parallelRouteKey] : null;
        const newSegmentChild = newRouterStateChild[0];
        const newSegmentPathChild = segmentPath.concat([
            parallelRouteKey,
            newSegmentChild
        ]);
        const newSegmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(newSegmentChild);
        const oldSegmentChild = oldRouterStateChild !== undefined ? oldRouterStateChild[0] : undefined;
        const oldCacheNodeChild = oldSegmentMapChild !== undefined ? oldSegmentMapChild.get(newSegmentKeyChild) : undefined;
        let taskChild;
        if (newSegmentChild === _segment.DEFAULT_SEGMENT_KEY) {
            // This is another kind of leaf segment  a default route.
            //
            // Default routes have special behavior. When there's no matching segment
            // for a parallel route, Next.js preserves the currently active segment
            // during a client navigation  but not for initial render. The server
            // leaves it to the client to account for this. So we need to handle
            // it here.
            if (oldRouterStateChild !== undefined) {
                // Reuse the existing Router State for this segment. We spawn a "task"
                // just to keep track of the updated router state; unlike most, it's
                // already fulfilled and won't be affected by the dynamic response.
                taskChild = spawnReusedTask(oldRouterStateChild);
            } else {
                // There's no currently active segment. Switch to the "create" path.
                taskChild = beginRenderingNewRouteTree(navigatedAt, oldRouterStateChild, newRouterStateChild, oldCacheNodeChild, didFindRootLayout, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead, isPrefetchHeadPartial, newSegmentPathChild, scrollableSegmentsResult);
            }
        } else if (isSamePageNavigation && // Check if this is a page segment.
        // TODO: We're not consistent about how we do this check. Some places
        // check if the segment starts with PAGE_SEGMENT_KEY, but most seem to
        // check if there any any children, which is why I'm doing it here. We
        // should probably encode an empty children set as `null` though. Either
        // way, we should update all the checks to be consistent.
        Object.keys(newRouterStateChild[1]).length === 0) {
            // We special case navigations to the exact same URL as the current
            // location. It's a common UI pattern for apps to refresh when you click a
            // link to the current page. So when this happens, we refresh the dynamic
            // data in the page segments.
            //
            // Note that this does not apply if the any part of the hash or search
            // query has changed. This might feel a bit weird but it makes more sense
            // when you consider that the way to trigger this behavior is to click
            // the same link multiple times.
            //
            // TODO: We should probably refresh the *entire* route when this case
            // occurs, not just the page segments. Essentially treating it the same as
            // a refresh() triggered by an action, which is the more explicit way of
            // modeling the UI pattern described above.
            //
            // Also note that this only refreshes the dynamic data, not static/
            // cached data. If the page segment is fully static and prefetched, the
            // request is skipped. (This is also how refresh() works.)
            taskChild = beginRenderingNewRouteTree(navigatedAt, oldRouterStateChild, newRouterStateChild, oldCacheNodeChild, didFindRootLayout, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead, isPrefetchHeadPartial, newSegmentPathChild, scrollableSegmentsResult);
        } else if (oldRouterStateChild !== undefined && oldSegmentChild !== undefined && (0, _matchsegments.matchSegment)(newSegmentChild, oldSegmentChild)) {
            if (oldCacheNodeChild !== undefined && oldRouterStateChild !== undefined) {
                // This segment exists in both the old and new trees. Recursively update
                // the children.
                taskChild = updateCacheNodeOnNavigation(navigatedAt, oldCacheNodeChild, oldRouterStateChild, newRouterStateChild, didFindRootLayout, prefetchDataChild, prefetchHead, isPrefetchHeadPartial, isSamePageNavigation, newSegmentPathChild, scrollableSegmentsResult);
            } else {
                // There's no existing Cache Node for this segment. Switch to the
                // "create" path.
                taskChild = beginRenderingNewRouteTree(navigatedAt, oldRouterStateChild, newRouterStateChild, oldCacheNodeChild, didFindRootLayout, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead, isPrefetchHeadPartial, newSegmentPathChild, scrollableSegmentsResult);
            }
        } else {
            // This is a new tree. Switch to the "create" path.
            taskChild = beginRenderingNewRouteTree(navigatedAt, oldRouterStateChild, newRouterStateChild, oldCacheNodeChild, didFindRootLayout, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead, isPrefetchHeadPartial, newSegmentPathChild, scrollableSegmentsResult);
        }
        if (taskChild !== null) {
            // Recursively propagate up the child tasks.
            if (taskChild.route === null) {
                // One of the child tasks discovered a change to the root layout.
                // Immediately unwind from this recursive traversal.
                return MPA_NAVIGATION_TASK;
            }
            if (taskChildren === null) {
                taskChildren = new Map();
            }
            taskChildren.set(parallelRouteKey, taskChild);
            const newCacheNodeChild = taskChild.node;
            if (newCacheNodeChild !== null) {
                const newSegmentMapChild = new Map(oldSegmentMapChild);
                newSegmentMapChild.set(newSegmentKeyChild, newCacheNodeChild);
                prefetchParallelRoutes.set(parallelRouteKey, newSegmentMapChild);
            }
            // The child tree's route state may be different from the prefetched
            // route sent by the server. We need to clone it as we traverse back up
            // the tree.
            const taskChildRoute = taskChild.route;
            patchedRouterStateChildren[parallelRouteKey] = taskChildRoute;
            const dynamicRequestTreeChild = taskChild.dynamicRequestTree;
            if (dynamicRequestTreeChild !== null) {
                // Something in the child tree is dynamic.
                needsDynamicRequest = true;
                dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild;
            } else {
                dynamicRequestTreeChildren[parallelRouteKey] = taskChildRoute;
            }
        } else {
            // The child didn't change. We can use the prefetched router state.
            patchedRouterStateChildren[parallelRouteKey] = newRouterStateChild;
            dynamicRequestTreeChildren[parallelRouteKey] = newRouterStateChild;
        }
    }
    if (taskChildren === null) {
        // No new tasks were spawned.
        return null;
    }
    const newCacheNode = {
        lazyData: null,
        rsc: oldCacheNode.rsc,
        // We intentionally aren't updating the prefetchRsc field, since this node
        // is already part of the current tree, because it would be weird for
        // prefetch data to be newer than the final data. It probably won't ever be
        // observable anyway, but it could happen if the segment is unmounted then
        // mounted again, because LayoutRouter will momentarily switch to rendering
        // prefetchRsc, via useDeferredValue.
        prefetchRsc: oldCacheNode.prefetchRsc,
        head: oldCacheNode.head,
        prefetchHead: oldCacheNode.prefetchHead,
        loading: oldCacheNode.loading,
        // Everything is cloned except for the children, which we computed above.
        parallelRoutes: prefetchParallelRoutes,
        navigatedAt
    };
    return {
        // Return a cloned copy of the router state with updated children.
        route: patchRouterStateWithNewChildren(newRouterState, patchedRouterStateChildren),
        node: newCacheNode,
        dynamicRequestTree: needsDynamicRequest ? patchRouterStateWithNewChildren(newRouterState, dynamicRequestTreeChildren) : null,
        children: taskChildren
    };
}
function beginRenderingNewRouteTree(navigatedAt, oldRouterState, newRouterState, existingCacheNode, didFindRootLayout, prefetchData, possiblyPartialPrefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult) {
    if (!didFindRootLayout) {
        // The route tree changed before we reached a layout. (The highest-level
        // layout in a route tree is referred to as the "root" layout.) This could
        // mean that we're navigating between two different root layouts. When this
        // happens, we perform a full-page (MPA-style) navigation.
        //
        // However, the algorithm for deciding where to start rendering a route
        // (i.e. the one performed in order to reach this function) is stricter
        // than the one used to detect a change in the root layout. So just because
        // we're re-rendering a segment outside of the root layout does not mean we
        // should trigger a full-page navigation.
        //
        // Specifically, we handle dynamic parameters differently: two segments are
        // considered the same even if their parameter values are different.
        //
        // Refer to isNavigatingToNewRootLayout for details.
        //
        // Note that we only have to perform this extra traversal if we didn't
        // already discover a root layout in the part of the tree that is unchanged.
        // In the common case, this branch is skipped completely.
        if (oldRouterState === undefined || (0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(oldRouterState, newRouterState)) {
            // The root layout changed. Perform a full-page navigation.
            return MPA_NAVIGATION_TASK;
        }
    }
    return createCacheNodeOnNavigation(navigatedAt, newRouterState, existingCacheNode, prefetchData, possiblyPartialPrefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult);
}
function createCacheNodeOnNavigation(navigatedAt, routerState, existingCacheNode, prefetchData, possiblyPartialPrefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult) {
    // Same traversal as updateCacheNodeNavigation, but we switch to this path
    // once we reach the part of the tree that was not in the previous route. We
    // don't need to diff against the old tree, we just need to create a new one.
    // The head is assigned to every leaf segment delivered by the server. Based
    // on corresponding logic in fill-lazy-items-till-leaf-with-head.ts
    const routerStateChildren = routerState[1];
    const isLeafSegment = Object.keys(routerStateChildren).length === 0;
    // Even we're rendering inside the "new" part of the target tree, we may have
    // a locally cached segment that we can reuse. This may come from either 1)
    // the CacheNode tree, which lives in React state and is populated by previous
    // navigations; or 2) the prefetch cache, which is a separate cache that is
    // populated by prefetches.
    let rsc;
    let loading;
    let head;
    let cacheNodeNavigatedAt;
    if (existingCacheNode !== undefined && // DYNAMIC_STALETIME_MS defaults to 0, but it can be increased using
    // the experimental.staleTimes.dynamic config. When set, we'll avoid
    // refetching dynamic data if it was fetched within the given threshold.
    existingCacheNode.navigatedAt + _prefetchcacheutils.DYNAMIC_STALETIME_MS > navigatedAt) {
        // We have an existing CacheNode for this segment, and it's not stale. We
        // should reuse it rather than request a new one.
        rsc = existingCacheNode.rsc;
        loading = existingCacheNode.loading;
        head = existingCacheNode.head;
        // Don't update the navigatedAt timestamp, since we're reusing stale data.
        cacheNodeNavigatedAt = existingCacheNode.navigatedAt;
    } else if (prefetchData !== null) {
        // There's no existing CacheNode for this segment, but we do have prefetch
        // data. If the prefetch data is fully static (i.e. does not contain any
        // dynamic holes), we don't need to request it from the server.
        rsc = prefetchData[1];
        loading = prefetchData[3];
        head = isLeafSegment ? possiblyPartialPrefetchHead : null;
        // Even though we're accessing the data from the prefetch cache, this is
        // conceptually a new segment, not a reused one. So we should update the
        // navigatedAt timestamp.
        cacheNodeNavigatedAt = navigatedAt;
        const isPrefetchRscPartial = prefetchData[4];
        if (isPrefetchRscPartial || // Check if the head is partial (only relevant if this is a leaf segment)
        isPrefetchHeadPartial && isLeafSegment) {
            // We only have partial data from this segment. Like missing segments, we
            // must request the full data from the server.
            return spawnPendingTask(navigatedAt, routerState, prefetchData, possiblyPartialPrefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult);
        } else {
        // The prefetch data is fully static, so we can omit it from the
        // navigation request.
        }
    } else {
        // There's no prefetch for this segment. Everything from this point will be
        // requested from the server, even if there are static children below it.
        // Create a terminal task node that will later be fulfilled by
        // server response.
        return spawnPendingTask(navigatedAt, routerState, null, possiblyPartialPrefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult);
    }
    // We already have a full segment we can render, so we don't need to request a
    // new one from the server. Keep traversing down the tree until we reach
    // something that requires a dynamic request.
    const prefetchDataChildren = prefetchData !== null ? prefetchData[2] : null;
    const taskChildren = new Map();
    const existingCacheNodeChildren = existingCacheNode !== undefined ? existingCacheNode.parallelRoutes : null;
    const cacheNodeChildren = new Map(existingCacheNodeChildren);
    let dynamicRequestTreeChildren = {};
    let needsDynamicRequest = false;
    if (isLeafSegment) {
        // The segment path of every leaf segment (i.e. page) is collected into
        // a result array. This is used by the LayoutRouter to scroll to ensure that
        // new pages are visible after a navigation.
        // TODO: We should use a string to represent the segment path instead of
        // an array. We already use a string representation for the path when
        // accessing the Segment Cache, so we can use the same one.
        scrollableSegmentsResult.push(segmentPath);
    } else {
        for(let parallelRouteKey in routerStateChildren){
            const routerStateChild = routerStateChildren[parallelRouteKey];
            const prefetchDataChild = prefetchDataChildren !== null ? prefetchDataChildren[parallelRouteKey] : null;
            const existingSegmentMapChild = existingCacheNodeChildren !== null ? existingCacheNodeChildren.get(parallelRouteKey) : undefined;
            const segmentChild = routerStateChild[0];
            const segmentPathChild = segmentPath.concat([
                parallelRouteKey,
                segmentChild
            ]);
            const segmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(segmentChild);
            const existingCacheNodeChild = existingSegmentMapChild !== undefined ? existingSegmentMapChild.get(segmentKeyChild) : undefined;
            const taskChild = createCacheNodeOnNavigation(navigatedAt, routerStateChild, existingCacheNodeChild, prefetchDataChild, possiblyPartialPrefetchHead, isPrefetchHeadPartial, segmentPathChild, scrollableSegmentsResult);
            taskChildren.set(parallelRouteKey, taskChild);
            const dynamicRequestTreeChild = taskChild.dynamicRequestTree;
            if (dynamicRequestTreeChild !== null) {
                // Something in the child tree is dynamic.
                needsDynamicRequest = true;
                dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild;
            } else {
                dynamicRequestTreeChildren[parallelRouteKey] = routerStateChild;
            }
            const newCacheNodeChild = taskChild.node;
            if (newCacheNodeChild !== null) {
                const newSegmentMapChild = new Map();
                newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild);
                cacheNodeChildren.set(parallelRouteKey, newSegmentMapChild);
            }
        }
    }
    return {
        // Since we're inside a new route tree, unlike the
        // `updateCacheNodeOnNavigation` path, the router state on the children
        // tasks is always the same as the router state we pass in. So we don't need
        // to clone/modify it.
        route: routerState,
        node: {
            lazyData: null,
            // Since this segment is already full, we don't need to use the
            // `prefetchRsc` field.
            rsc,
            prefetchRsc: null,
            head,
            prefetchHead: null,
            loading,
            parallelRoutes: cacheNodeChildren,
            navigatedAt: cacheNodeNavigatedAt
        },
        dynamicRequestTree: needsDynamicRequest ? patchRouterStateWithNewChildren(routerState, dynamicRequestTreeChildren) : null,
        children: taskChildren
    };
}
function patchRouterStateWithNewChildren(baseRouterState, newChildren) {
    const clone = [
        baseRouterState[0],
        newChildren
    ];
    // Based on equivalent logic in apply-router-state-patch-to-tree, but should
    // confirm whether we need to copy all of these fields. Not sure the server
    // ever sends, e.g. the refetch marker.
    if (2 in baseRouterState) {
        clone[2] = baseRouterState[2];
    }
    if (3 in baseRouterState) {
        clone[3] = baseRouterState[3];
    }
    if (4 in baseRouterState) {
        clone[4] = baseRouterState[4];
    }
    return clone;
}
function spawnPendingTask(navigatedAt, routerState, prefetchData, prefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult) {
    // Create a task that will later be fulfilled by data from the server.
    // Clone the prefetched route tree and the `refetch` marker to it. We'll send
    // this to the server so it knows where to start rendering.
    const dynamicRequestTree = patchRouterStateWithNewChildren(routerState, routerState[1]);
    dynamicRequestTree[3] = 'refetch';
    const newTask = {
        route: routerState,
        // Corresponds to the part of the route that will be rendered on the server.
        node: createPendingCacheNode(navigatedAt, routerState, prefetchData, prefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult),
        // Because this is non-null, and it gets propagated up through the parent
        // tasks, the root task will know that it needs to perform a server request.
        dynamicRequestTree,
        children: null
    };
    return newTask;
}
function spawnReusedTask(reusedRouterState) {
    // Create a task that reuses an existing segment, e.g. when reusing
    // the current active segment in place of a default route.
    return {
        route: reusedRouterState,
        node: null,
        dynamicRequestTree: null,
        children: null
    };
}
function listenForDynamicRequest(task, responsePromise) {
    responsePromise.then((param)=>{
        let { flightData } = param;
        if (typeof flightData === 'string') {
            // Happens when navigating to page in `pages` from `app`. We shouldn't
            // get here because should have already handled this during
            // the prefetch.
            return;
        }
        for (const normalizedFlightData of flightData){
            const { segmentPath, tree: serverRouterState, seedData: dynamicData, head: dynamicHead } = normalizedFlightData;
            if (!dynamicData) {
                continue;
            }
            writeDynamicDataIntoPendingTask(task, segmentPath, serverRouterState, dynamicData, dynamicHead);
        }
        // Now that we've exhausted all the data we received from the server, if
        // there are any remaining pending tasks in the tree, abort them now.
        // If there's any missing data, it will trigger a lazy fetch.
        abortTask(task, null);
    }, (error)=>{
        // This will trigger an error during render
        abortTask(task, error);
    });
}
function writeDynamicDataIntoPendingTask(rootTask, segmentPath, serverRouterState, dynamicData, dynamicHead) {
    // The data sent by the server represents only a subtree of the app. We need
    // to find the part of the task tree that matches the server response, and
    // fulfill it using the dynamic data.
    //
    // segmentPath represents the parent path of subtree. It's a repeating pattern
    // of parallel route key and segment:
    //
    //   [string, Segment, string, Segment, string, Segment, ...]
    //
    // Iterate through the path and finish any tasks that match this payload.
    let task = rootTask;
    for(let i = 0; i < segmentPath.length; i += 2){
        const parallelRouteKey = segmentPath[i];
        const segment = segmentPath[i + 1];
        const taskChildren = task.children;
        if (taskChildren !== null) {
            const taskChild = taskChildren.get(parallelRouteKey);
            if (taskChild !== undefined) {
                const taskSegment = taskChild.route[0];
                if ((0, _matchsegments.matchSegment)(segment, taskSegment)) {
                    // Found a match for this task. Keep traversing down the task tree.
                    task = taskChild;
                    continue;
                }
            }
        }
        // We didn't find a child task that matches the server data. Exit. We won't
        // abort the task, though, because a different FlightDataPath may be able to
        // fulfill it (see loop in listenForDynamicRequest). We only abort tasks
        // once we've run out of data.
        return;
    }
    finishTaskUsingDynamicDataPayload(task, serverRouterState, dynamicData, dynamicHead);
}
function finishTaskUsingDynamicDataPayload(task, serverRouterState, dynamicData, dynamicHead) {
    if (task.dynamicRequestTree === null) {
        // Everything in this subtree is already complete. Bail out.
        return;
    }
    // dynamicData may represent a larger subtree than the task. Before we can
    // finish the task, we need to line them up.
    const taskChildren = task.children;
    const taskNode = task.node;
    if (taskChildren === null) {
        // We've reached the leaf node of the pending task. The server data tree
        // lines up the pending Cache Node tree. We can now switch to the
        // normal algorithm.
        if (taskNode !== null) {
            finishPendingCacheNode(taskNode, task.route, serverRouterState, dynamicData, dynamicHead);
            // Set this to null to indicate that this task is now complete.
            task.dynamicRequestTree = null;
        }
        return;
    }
    // The server returned more data than we need to finish the task. Skip over
    // the extra segments until we reach the leaf task node.
    const serverChildren = serverRouterState[1];
    const dynamicDataChildren = dynamicData[2];
    for(const parallelRouteKey in serverRouterState){
        const serverRouterStateChild = serverChildren[parallelRouteKey];
        const dynamicDataChild = dynamicDataChildren[parallelRouteKey];
        const taskChild = taskChildren.get(parallelRouteKey);
        if (taskChild !== undefined) {
            const taskSegment = taskChild.route[0];
            if ((0, _matchsegments.matchSegment)(serverRouterStateChild[0], taskSegment) && dynamicDataChild !== null && dynamicDataChild !== undefined) {
                // Found a match for this task. Keep traversing down the task tree.
                return finishTaskUsingDynamicDataPayload(taskChild, serverRouterStateChild, dynamicDataChild, dynamicHead);
            }
        }
    // We didn't find a child task that matches the server data. We won't abort
    // the task, though, because a different FlightDataPath may be able to
    // fulfill it (see loop in listenForDynamicRequest). We only abort tasks
    // once we've run out of data.
    }
}
function createPendingCacheNode(navigatedAt, routerState, prefetchData, prefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult) {
    const routerStateChildren = routerState[1];
    const prefetchDataChildren = prefetchData !== null ? prefetchData[2] : null;
    const parallelRoutes = new Map();
    for(let parallelRouteKey in routerStateChildren){
        const routerStateChild = routerStateChildren[parallelRouteKey];
        const prefetchDataChild = prefetchDataChildren !== null ? prefetchDataChildren[parallelRouteKey] : null;
        const segmentChild = routerStateChild[0];
        const segmentPathChild = segmentPath.concat([
            parallelRouteKey,
            segmentChild
        ]);
        const segmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(segmentChild);
        const newCacheNodeChild = createPendingCacheNode(navigatedAt, routerStateChild, prefetchDataChild === undefined ? null : prefetchDataChild, prefetchHead, isPrefetchHeadPartial, segmentPathChild, scrollableSegmentsResult);
        const newSegmentMapChild = new Map();
        newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild);
        parallelRoutes.set(parallelRouteKey, newSegmentMapChild);
    }
    // The head is assigned to every leaf segment delivered by the server. Based
    // on corresponding logic in fill-lazy-items-till-leaf-with-head.ts
    const isLeafSegment = parallelRoutes.size === 0;
    if (isLeafSegment) {
        // The segment path of every leaf segment (i.e. page) is collected into
        // a result array. This is used by the LayoutRouter to scroll to ensure that
        // new pages are visible after a navigation.
        // TODO: We should use a string to represent the segment path instead of
        // an array. We already use a string representation for the path when
        // accessing the Segment Cache, so we can use the same one.
        scrollableSegmentsResult.push(segmentPath);
    }
    const maybePrefetchRsc = prefetchData !== null ? prefetchData[1] : null;
    const maybePrefetchLoading = prefetchData !== null ? prefetchData[3] : null;
    return {
        lazyData: null,
        parallelRoutes: parallelRoutes,
        prefetchRsc: maybePrefetchRsc !== undefined ? maybePrefetchRsc : null,
        prefetchHead: isLeafSegment ? prefetchHead : [
            null,
            null
        ],
        // TODO: Technically, a loading boundary could contain dynamic data. We must
        // have separate `loading` and `prefetchLoading` fields to handle this, like
        // we do for the segment data and head.
        loading: maybePrefetchLoading !== undefined ? maybePrefetchLoading : null,
        // Create a deferred promise. This will be fulfilled once the dynamic
        // response is received from the server.
        rsc: createDeferredRsc(),
        head: isLeafSegment ? createDeferredRsc() : null,
        navigatedAt
    };
}
function finishPendingCacheNode(cacheNode, taskState, serverState, dynamicData, dynamicHead) {
    // Writes a dynamic response into an existing Cache Node tree. This does _not_
    // create a new tree, it updates the existing tree in-place. So it must follow
    // the Suspense rules of cache safety  it can resolve pending promises, but
    // it cannot overwrite existing data. It can add segments to the tree (because
    // a missing segment will cause the layout router to suspend).
    // but it cannot delete them.
    //
    // We must resolve every promise in the tree, or else it will suspend
    // indefinitely. If we did not receive data for a segment, we will resolve its
    // data promise to `null` to trigger a lazy fetch during render.
    const taskStateChildren = taskState[1];
    const serverStateChildren = serverState[1];
    const dataChildren = dynamicData[2];
    // The router state that we traverse the tree with (taskState) is the same one
    // that we used to construct the pending Cache Node tree. That way we're sure
    // to resolve all the pending promises.
    const parallelRoutes = cacheNode.parallelRoutes;
    for(let parallelRouteKey in taskStateChildren){
        const taskStateChild = taskStateChildren[parallelRouteKey];
        const serverStateChild = serverStateChildren[parallelRouteKey];
        const dataChild = dataChildren[parallelRouteKey];
        const segmentMapChild = parallelRoutes.get(parallelRouteKey);
        const taskSegmentChild = taskStateChild[0];
        const taskSegmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(taskSegmentChild);
        const cacheNodeChild = segmentMapChild !== undefined ? segmentMapChild.get(taskSegmentKeyChild) : undefined;
        if (cacheNodeChild !== undefined) {
            if (serverStateChild !== undefined && (0, _matchsegments.matchSegment)(taskSegmentChild, serverStateChild[0])) {
                if (dataChild !== undefined && dataChild !== null) {
                    // This is the happy path. Recursively update all the children.
                    finishPendingCacheNode(cacheNodeChild, taskStateChild, serverStateChild, dataChild, dynamicHead);
                } else {
                    // The server never returned data for this segment. Trigger a lazy
                    // fetch during render. This shouldn't happen because the Route Tree
                    // and the Seed Data tree sent by the server should always be the same
                    // shape when part of the same server response.
                    abortPendingCacheNode(taskStateChild, cacheNodeChild, null);
                }
            } else {
                // The server never returned data for this segment. Trigger a lazy
                // fetch during render.
                abortPendingCacheNode(taskStateChild, cacheNodeChild, null);
            }
        } else {
        // The server response matches what was expected to receive, but there's
        // no matching Cache Node in the task tree. This is a bug in the
        // implementation because we should have created a node for every
        // segment in the tree that's associated with this task.
        }
    }
    // Use the dynamic data from the server to fulfill the deferred RSC promise
    // on the Cache Node.
    const rsc = cacheNode.rsc;
    const dynamicSegmentData = dynamicData[1];
    if (rsc === null) {
        // This is a lazy cache node. We can overwrite it. This is only safe
        // because we know that the LayoutRouter suspends if `rsc` is `null`.
        cacheNode.rsc = dynamicSegmentData;
    } else if (isDeferredRsc(rsc)) {
        // This is a deferred RSC promise. We can fulfill it with the data we just
        // received from the server. If it was already resolved by a different
        // navigation, then this does nothing because we can't overwrite data.
        rsc.resolve(dynamicSegmentData);
    } else {
    // This is not a deferred RSC promise, nor is it empty, so it must have
    // been populated by a different navigation. We must not overwrite it.
    }
    // Check if this is a leaf segment. If so, it will have a `head` property with
    // a pending promise that needs to be resolved with the dynamic head from
    // the server.
    const head = cacheNode.head;
    if (isDeferredRsc(head)) {
        head.resolve(dynamicHead);
    }
}
function abortTask(task, error) {
    const cacheNode = task.node;
    if (cacheNode === null) {
        // This indicates the task is already complete.
        return;
    }
    const taskChildren = task.children;
    if (taskChildren === null) {
        // Reached the leaf task node. This is the root of a pending cache
        // node tree.
        abortPendingCacheNode(task.route, cacheNode, error);
    } else {
        // This is an intermediate task node. Keep traversing until we reach a
        // task node with no children. That will be the root of the cache node tree
        // that needs to be resolved.
        for (const taskChild of taskChildren.values()){
            abortTask(taskChild, error);
        }
    }
    // Set this to null to indicate that this task is now complete.
    task.dynamicRequestTree = null;
}
function abortPendingCacheNode(routerState, cacheNode, error) {
    // For every pending segment in the tree, resolve its `rsc` promise to `null`
    // to trigger a lazy fetch during render.
    //
    // Or, if an error object is provided, it will error instead.
    const routerStateChildren = routerState[1];
    const parallelRoutes = cacheNode.parallelRoutes;
    for(let parallelRouteKey in routerStateChildren){
        const routerStateChild = routerStateChildren[parallelRouteKey];
        const segmentMapChild = parallelRoutes.get(parallelRouteKey);
        if (segmentMapChild === undefined) {
            continue;
        }
        const segmentChild = routerStateChild[0];
        const segmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(segmentChild);
        const cacheNodeChild = segmentMapChild.get(segmentKeyChild);
        if (cacheNodeChild !== undefined) {
            abortPendingCacheNode(routerStateChild, cacheNodeChild, error);
        } else {
        // This shouldn't happen because we're traversing the same tree that was
        // used to construct the cache nodes in the first place.
        }
    }
    const rsc = cacheNode.rsc;
    if (isDeferredRsc(rsc)) {
        if (error === null) {
            // This will trigger a lazy fetch during render.
            rsc.resolve(null);
        } else {
            // This will trigger an error during rendering.
            rsc.reject(error);
        }
    }
    // Check if this is a leaf segment. If so, it will have a `head` property with
    // a pending promise that needs to be resolved. If an error was provided, we
    // will not resolve it with an error, since this is rendered at the root of
    // the app. We want the segment to error, not the entire app.
    const head = cacheNode.head;
    if (isDeferredRsc(head)) {
        head.resolve(null);
    }
}
function updateCacheNodeOnPopstateRestoration(oldCacheNode, routerState) {
    // A popstate navigation reads data from the local cache. It does not issue
    // new network requests (unless the cache entries have been evicted). So, we
    // update the cache to drop the prefetch data for any segment whose dynamic
    // data was already received. This prevents an unnecessary flash back to PPR
    // state during a back/forward navigation.
    //
    // This function clones the entire cache node tree and sets the `prefetchRsc`
    // field to `null` to prevent it from being rendered. We can't mutate the node
    // in place because this is a concurrent data structure.
    const routerStateChildren = routerState[1];
    const oldParallelRoutes = oldCacheNode.parallelRoutes;
    const newParallelRoutes = new Map(oldParallelRoutes);
    for(let parallelRouteKey in routerStateChildren){
        const routerStateChild = routerStateChildren[parallelRouteKey];
        const segmentChild = routerStateChild[0];
        const segmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(segmentChild);
        const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey);
        if (oldSegmentMapChild !== undefined) {
            const oldCacheNodeChild = oldSegmentMapChild.get(segmentKeyChild);
            if (oldCacheNodeChild !== undefined) {
                const newCacheNodeChild = updateCacheNodeOnPopstateRestoration(oldCacheNodeChild, routerStateChild);
                const newSegmentMapChild = new Map(oldSegmentMapChild);
                newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild);
                newParallelRoutes.set(parallelRouteKey, newSegmentMapChild);
            }
        }
    }
    // Only show prefetched data if the dynamic data is still pending.
    //
    // Tehnically, what we're actually checking is whether the dynamic network
    // response was received. But since it's a streaming response, this does not
    // mean that all the dynamic data has fully streamed in. It just means that
    // _some_ of the dynamic data was received. But as a heuristic, we assume that
    // the rest dynamic data will stream in quickly, so it's still better to skip
    // the prefetch state.
    const rsc = oldCacheNode.rsc;
    const shouldUsePrefetch = isDeferredRsc(rsc) && rsc.status === 'pending';
    return {
        lazyData: null,
        rsc,
        head: oldCacheNode.head,
        prefetchHead: shouldUsePrefetch ? oldCacheNode.prefetchHead : [
            null,
            null
        ],
        prefetchRsc: shouldUsePrefetch ? oldCacheNode.prefetchRsc : null,
        loading: oldCacheNode.loading,
        // These are the cloned children we computed above
        parallelRoutes: newParallelRoutes,
        navigatedAt: oldCacheNode.navigatedAt
    };
}
const DEFERRED = Symbol();
// This type exists to distinguish a DeferredRsc from a Flight promise. It's a
// compromise to avoid adding an extra field on every Cache Node, which would be
// awkward because the pre-PPR parts of codebase would need to account for it,
// too. We can remove it once type Cache Node type is more settled.
function isDeferredRsc(value) {
    return value && value.tag === DEFERRED;
}
function createDeferredRsc() {
    let resolve;
    let reject;
    const pendingRsc = new Promise((res, rej)=>{
        resolve = res;
        reject = rej;
    });
    pendingRsc.status = 'pending';
    pendingRsc.resolve = (value)=>{
        if (pendingRsc.status === 'pending') {
            const fulfilledRsc = pendingRsc;
            fulfilledRsc.status = 'fulfilled';
            fulfilledRsc.value = value;
            resolve(value);
        }
    };
    pendingRsc.reject = (error)=>{
        if (pendingRsc.status === 'pending') {
            const rejectedRsc = pendingRsc;
            rejectedRsc.status = 'rejected';
            rejectedRsc.reason = error;
            reject(error);
        }
    };
    pendingRsc.tag = DEFERRED;
    return pendingRsc;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=ppr-navigations.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/clear-cache-node-data-for-segment-path.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "clearCacheNodeDataForSegmentPath", {
    enumerable: true,
    get: function() {
        return clearCacheNodeDataForSegmentPath;
    }
});
const _flightdatahelpers = __turbopack_context__.r("[project]/node_modules/next/dist/client/flight-data-helpers.js [app-ssr] (ecmascript)");
const _createroutercachekey = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js [app-ssr] (ecmascript)");
function clearCacheNodeDataForSegmentPath(newCache, existingCache, flightSegmentPath) {
    const isLastEntry = flightSegmentPath.length <= 2;
    const [parallelRouteKey, segment] = flightSegmentPath;
    const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(segment);
    const existingChildSegmentMap = existingCache.parallelRoutes.get(parallelRouteKey);
    let childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey);
    if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {
        childSegmentMap = new Map(existingChildSegmentMap);
        newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap);
    }
    const existingChildCacheNode = existingChildSegmentMap == null ? void 0 : existingChildSegmentMap.get(cacheKey);
    let childCacheNode = childSegmentMap.get(cacheKey);
    // In case of last segment start off the fetch at this level and don't copy further down.
    if (isLastEntry) {
        if (!childCacheNode || !childCacheNode.lazyData || childCacheNode === existingChildCacheNode) {
            childSegmentMap.set(cacheKey, {
                lazyData: null,
                rsc: null,
                prefetchRsc: null,
                head: null,
                prefetchHead: null,
                parallelRoutes: new Map(),
                loading: null,
                navigatedAt: -1
            });
        }
        return;
    }
    if (!childCacheNode || !existingChildCacheNode) {
        // Start fetch in the place where the existing cache doesn't have the data yet.
        if (!childCacheNode) {
            childSegmentMap.set(cacheKey, {
                lazyData: null,
                rsc: null,
                prefetchRsc: null,
                head: null,
                prefetchHead: null,
                parallelRoutes: new Map(),
                loading: null,
                navigatedAt: -1
            });
        }
        return;
    }
    if (childCacheNode === existingChildCacheNode) {
        childCacheNode = {
            lazyData: childCacheNode.lazyData,
            rsc: childCacheNode.rsc,
            prefetchRsc: childCacheNode.prefetchRsc,
            head: childCacheNode.head,
            prefetchHead: childCacheNode.prefetchHead,
            parallelRoutes: new Map(childCacheNode.parallelRoutes),
            loading: childCacheNode.loading
        };
        childSegmentMap.set(cacheKey, childCacheNode);
    }
    return clearCacheNodeDataForSegmentPath(childCacheNode, existingChildCacheNode, (0, _flightdatahelpers.getNextFlightSegmentPath)(flightSegmentPath));
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=clear-cache-node-data-for-segment-path.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/aliased-prefetch-navigations.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    addSearchParamsToPageSegments: null,
    handleAliasedPrefetchEntry: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    addSearchParamsToPageSegments: function() {
        return addSearchParamsToPageSegments;
    },
    handleAliasedPrefetchEntry: function() {
        return handleAliasedPrefetchEntry;
    }
});
const _segment = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/segment.js [app-ssr] (ecmascript)");
const _approuter = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/app-router.js [app-ssr] (ecmascript)");
const _applyrouterstatepatchtotree = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js [app-ssr] (ecmascript)");
const _createhreffromurl = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/create-href-from-url.js [app-ssr] (ecmascript)");
const _createroutercachekey = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js [app-ssr] (ecmascript)");
const _fillcachewithnewsubtreedata = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/fill-cache-with-new-subtree-data.js [app-ssr] (ecmascript)");
const _handlemutable = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/handle-mutable.js [app-ssr] (ecmascript)");
function handleAliasedPrefetchEntry(navigatedAt, state, flightData, url, mutable) {
    let currentTree = state.tree;
    let currentCache = state.cache;
    const href = (0, _createhreffromurl.createHrefFromUrl)(url);
    let applied;
    if (typeof flightData === 'string') {
        return false;
    }
    for (const normalizedFlightData of flightData){
        // If the segment doesn't have a loading component, we don't need to do anything.
        if (!hasLoadingComponentInSeedData(normalizedFlightData.seedData)) {
            continue;
        }
        let treePatch = normalizedFlightData.tree;
        // Segments are keyed by searchParams (e.g. __PAGE__?{"foo":"bar"}). We might return a less specific, param-less entry,
        // so we ensure that the final tree contains the correct searchParams (reflected in the URL) are provided in the updated FlightRouterState tree.
        // We only do this on the first read, as otherwise we'd be overwriting the searchParams that may have already been set
        treePatch = addSearchParamsToPageSegments(treePatch, Object.fromEntries(url.searchParams));
        const { seedData, isRootRender, pathToSegment } = normalizedFlightData;
        // TODO-APP: remove ''
        const flightSegmentPathWithLeadingEmpty = [
            '',
            ...pathToSegment
        ];
        // Segments are keyed by searchParams (e.g. __PAGE__?{"foo":"bar"}). We might return a less specific, param-less entry,
        // so we ensure that the final tree contains the correct searchParams (reflected in the URL) are provided in the updated FlightRouterState tree.
        // We only do this on the first read, as otherwise we'd be overwriting the searchParams that may have already been set
        treePatch = addSearchParamsToPageSegments(treePatch, Object.fromEntries(url.searchParams));
        let newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)(flightSegmentPathWithLeadingEmpty, currentTree, treePatch, href);
        const newCache = (0, _approuter.createEmptyCacheNode)();
        // The prefetch cache entry was aliased -- this signals that we only fill in the cache with the
        // loading state and not the actual parallel route seed data.
        if (isRootRender && seedData) {
            // Fill in the cache with the new loading / rsc data
            const rsc = seedData[1];
            const loading = seedData[3];
            newCache.loading = loading;
            newCache.rsc = rsc;
            // Construct a new tree and apply the aliased loading state for each parallel route
            fillNewTreeWithOnlyLoadingSegments(navigatedAt, newCache, currentCache, treePatch, seedData);
        } else {
            // Copy rsc for the root node of the cache.
            newCache.rsc = currentCache.rsc;
            newCache.prefetchRsc = currentCache.prefetchRsc;
            newCache.loading = currentCache.loading;
            newCache.parallelRoutes = new Map(currentCache.parallelRoutes);
            // copy the loading state only into the leaf node (the part that changed)
            (0, _fillcachewithnewsubtreedata.fillCacheWithNewSubTreeDataButOnlyLoading)(navigatedAt, newCache, currentCache, normalizedFlightData);
        }
        // If we don't have an updated tree, there's no reason to update the cache, as the tree
        // dictates what cache nodes to render.
        if (newTree) {
            currentTree = newTree;
            currentCache = newCache;
            applied = true;
        }
    }
    if (!applied) {
        return false;
    }
    mutable.patchedTree = currentTree;
    mutable.cache = currentCache;
    mutable.canonicalUrl = href;
    mutable.hashFragment = url.hash;
    return (0, _handlemutable.handleMutable)(state, mutable);
}
function hasLoadingComponentInSeedData(seedData) {
    if (!seedData) return false;
    const parallelRoutes = seedData[2];
    const loading = seedData[3];
    if (loading) {
        return true;
    }
    for(const key in parallelRoutes){
        if (hasLoadingComponentInSeedData(parallelRoutes[key])) {
            return true;
        }
    }
    return false;
}
function fillNewTreeWithOnlyLoadingSegments(navigatedAt, newCache, existingCache, routerState, cacheNodeSeedData) {
    const isLastSegment = Object.keys(routerState[1]).length === 0;
    if (isLastSegment) {
        return;
    }
    for(const key in routerState[1]){
        const parallelRouteState = routerState[1][key];
        const segmentForParallelRoute = parallelRouteState[0];
        const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(segmentForParallelRoute);
        const parallelSeedData = cacheNodeSeedData !== null && cacheNodeSeedData[2][key] !== undefined ? cacheNodeSeedData[2][key] : null;
        let newCacheNode;
        if (parallelSeedData !== null) {
            // New data was sent from the server.
            const rsc = parallelSeedData[1];
            const loading = parallelSeedData[3];
            newCacheNode = {
                lazyData: null,
                // copy the layout but null the page segment as that's not meant to be used
                rsc: segmentForParallelRoute.includes(_segment.PAGE_SEGMENT_KEY) ? null : rsc,
                prefetchRsc: null,
                head: null,
                prefetchHead: null,
                parallelRoutes: new Map(),
                loading,
                navigatedAt
            };
        } else {
            // No data available for this node. This will trigger a lazy fetch
            // during render.
            newCacheNode = {
                lazyData: null,
                rsc: null,
                prefetchRsc: null,
                head: null,
                prefetchHead: null,
                parallelRoutes: new Map(),
                loading: null,
                navigatedAt: -1
            };
        }
        const existingParallelRoutes = newCache.parallelRoutes.get(key);
        if (existingParallelRoutes) {
            existingParallelRoutes.set(cacheKey, newCacheNode);
        } else {
            newCache.parallelRoutes.set(key, new Map([
                [
                    cacheKey,
                    newCacheNode
                ]
            ]));
        }
        fillNewTreeWithOnlyLoadingSegments(navigatedAt, newCacheNode, existingCache, parallelRouteState, parallelSeedData);
    }
}
function addSearchParamsToPageSegments(flightRouterState, searchParams) {
    const [segment, parallelRoutes, ...rest] = flightRouterState;
    // If it's a page segment, modify the segment by adding search params
    if (segment.includes(_segment.PAGE_SEGMENT_KEY)) {
        const newSegment = (0, _segment.addSearchParamsIfPageSegment)(segment, searchParams);
        return [
            newSegment,
            parallelRoutes,
            ...rest
        ];
    }
    // Otherwise, recurse through the parallel routes and return a new tree
    const updatedParallelRoutes = {};
    for (const [key, parallelRoute] of Object.entries(parallelRoutes)){
        updatedParallelRoutes[key] = addSearchParamsToPageSegments(parallelRoute, searchParams);
    }
    return [
        segment,
        updatedParallelRoutes,
        ...rest
    ];
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=aliased-prefetch-navigations.js.map
}}),
"[project]/node_modules/next/dist/client/components/segment-cache.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/**
 * Entry point to the Segment Cache implementation.
 *
 * All code related to the Segment Cache lives `segment-cache-impl` directory.
 * Callers access it through this indirection.
 *
 * This is to ensure the code is dead code eliminated from the bundle if the
 * flag is disabled.
 *
 * TODO: This is super tedious. Since experimental flags are an essential part
 * of our workflow, we should establish a better pattern for dead code
 * elimination. Ideally it would be done at the bundler level, like how React's
 * build process works. In the React repo, you don't even need to add any extra
 * configuration per experiment  if the code is not reachable, it gets stripped
 * from the build automatically by Rollup. Or, shorter term, we could stub out
 * experimental modules at build time by updating the build config, i.e. a more
 * automated version of what I'm doing manually in this file.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    NavigationResultTag: null,
    PrefetchPriority: null,
    cancelPrefetchTask: null,
    createCacheKey: null,
    getCurrentCacheVersion: null,
    isPrefetchTaskDirty: null,
    navigate: null,
    prefetch: null,
    reschedulePrefetchTask: null,
    revalidateEntireCache: null,
    schedulePrefetchTask: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    NavigationResultTag: function() {
        return NavigationResultTag;
    },
    PrefetchPriority: function() {
        return PrefetchPriority;
    },
    cancelPrefetchTask: function() {
        return cancelPrefetchTask;
    },
    createCacheKey: function() {
        return createCacheKey;
    },
    getCurrentCacheVersion: function() {
        return getCurrentCacheVersion;
    },
    isPrefetchTaskDirty: function() {
        return isPrefetchTaskDirty;
    },
    navigate: function() {
        return navigate;
    },
    prefetch: function() {
        return prefetch;
    },
    reschedulePrefetchTask: function() {
        return reschedulePrefetchTask;
    },
    revalidateEntireCache: function() {
        return revalidateEntireCache;
    },
    schedulePrefetchTask: function() {
        return schedulePrefetchTask;
    }
});
const notEnabled = ()=>{
    throw Object.defineProperty(new Error('Segment Cache experiment is not enabled. This is a bug in Next.js.'), "__NEXT_ERROR_CODE", {
        value: "E654",
        enumerable: false,
        configurable: true
    });
};
const prefetch = ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : notEnabled;
const navigate = ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : notEnabled;
const revalidateEntireCache = ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : notEnabled;
const getCurrentCacheVersion = ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : notEnabled;
const schedulePrefetchTask = ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : notEnabled;
const cancelPrefetchTask = ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : notEnabled;
const reschedulePrefetchTask = ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : notEnabled;
const isPrefetchTaskDirty = ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : notEnabled;
const createCacheKey = ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : notEnabled;
var NavigationResultTag = /*#__PURE__*/ function(NavigationResultTag) {
    NavigationResultTag[NavigationResultTag["MPA"] = 0] = "MPA";
    NavigationResultTag[NavigationResultTag["Success"] = 1] = "Success";
    NavigationResultTag[NavigationResultTag["NoOp"] = 2] = "NoOp";
    NavigationResultTag[NavigationResultTag["Async"] = 3] = "Async";
    return NavigationResultTag;
}({});
var PrefetchPriority = /*#__PURE__*/ function(PrefetchPriority) {
    /**
   * Assigned to the most recently hovered/touched link. Special network
   * bandwidth is reserved for this task only. There's only ever one Intent-
   * priority task at a time; when a new Intent task is scheduled, the previous
   * one is bumped down to Default.
   */ PrefetchPriority[PrefetchPriority["Intent"] = 2] = "Intent";
    /**
   * The default priority for prefetch tasks.
   */ PrefetchPriority[PrefetchPriority["Default"] = 1] = "Default";
    /**
   * Assigned to tasks when they spawn non-blocking background work, like
   * revalidating a partially cached entry to see if more data is available.
   */ PrefetchPriority[PrefetchPriority["Background"] = 0] = "Background";
    return PrefetchPriority;
}({});
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=segment-cache.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    handleExternalUrl: null,
    navigateReducer: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    handleExternalUrl: function() {
        return handleExternalUrl;
    },
    navigateReducer: function() {
        return navigateReducer;
    }
});
const _fetchserverresponse = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/fetch-server-response.js [app-ssr] (ecmascript)");
const _createhreffromurl = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/create-href-from-url.js [app-ssr] (ecmascript)");
const _invalidatecachebelowflightsegmentpath = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/invalidate-cache-below-flight-segmentpath.js [app-ssr] (ecmascript)");
const _applyrouterstatepatchtotree = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js [app-ssr] (ecmascript)");
const _shouldhardnavigate = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/should-hard-navigate.js [app-ssr] (ecmascript)");
const _isnavigatingtonewrootlayout = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js [app-ssr] (ecmascript)");
const _routerreducertypes = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/router-reducer-types.js [app-ssr] (ecmascript)");
const _handlemutable = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/handle-mutable.js [app-ssr] (ecmascript)");
const _applyflightdata = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/apply-flight-data.js [app-ssr] (ecmascript)");
const _prefetchreducer = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js [app-ssr] (ecmascript)");
const _approuter = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/app-router.js [app-ssr] (ecmascript)");
const _segment = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/segment.js [app-ssr] (ecmascript)");
const _pprnavigations = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/ppr-navigations.js [app-ssr] (ecmascript)");
const _prefetchcacheutils = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js [app-ssr] (ecmascript)");
const _clearcachenodedataforsegmentpath = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/clear-cache-node-data-for-segment-path.js [app-ssr] (ecmascript)");
const _aliasedprefetchnavigations = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/aliased-prefetch-navigations.js [app-ssr] (ecmascript)");
const _segmentcache = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/segment-cache.js [app-ssr] (ecmascript)");
function handleExternalUrl(state, mutable, url, pendingPush) {
    mutable.mpaNavigation = true;
    mutable.canonicalUrl = url;
    mutable.pendingPush = pendingPush;
    mutable.scrollableSegments = undefined;
    return (0, _handlemutable.handleMutable)(state, mutable);
}
function generateSegmentsFromPatch(flightRouterPatch) {
    const segments = [];
    const [segment, parallelRoutes] = flightRouterPatch;
    if (Object.keys(parallelRoutes).length === 0) {
        return [
            [
                segment
            ]
        ];
    }
    for (const [parallelRouteKey, parallelRoute] of Object.entries(parallelRoutes)){
        for (const childSegment of generateSegmentsFromPatch(parallelRoute)){
            // If the segment is empty, it means we are at the root of the tree
            if (segment === '') {
                segments.push([
                    parallelRouteKey,
                    ...childSegment
                ]);
            } else {
                segments.push([
                    segment,
                    parallelRouteKey,
                    ...childSegment
                ]);
            }
        }
    }
    return segments;
}
function triggerLazyFetchForLeafSegments(newCache, currentCache, flightSegmentPath, treePatch) {
    let appliedPatch = false;
    newCache.rsc = currentCache.rsc;
    newCache.prefetchRsc = currentCache.prefetchRsc;
    newCache.loading = currentCache.loading;
    newCache.parallelRoutes = new Map(currentCache.parallelRoutes);
    const segmentPathsToFill = generateSegmentsFromPatch(treePatch).map((segment)=>[
            ...flightSegmentPath,
            ...segment
        ]);
    for (const segmentPaths of segmentPathsToFill){
        (0, _clearcachenodedataforsegmentpath.clearCacheNodeDataForSegmentPath)(newCache, currentCache, segmentPaths);
        appliedPatch = true;
    }
    return appliedPatch;
}
function handleNavigationResult(url, state, mutable, pendingPush, result) {
    switch(result.tag){
        case _segmentcache.NavigationResultTag.MPA:
            {
                // Perform an MPA navigation.
                const newUrl = result.data;
                return handleExternalUrl(state, mutable, newUrl, pendingPush);
            }
        case _segmentcache.NavigationResultTag.NoOp:
            {
                // The server responded with no change to the current page. However, if
                // the URL changed, we still need to update that.
                const newCanonicalUrl = result.data.canonicalUrl;
                mutable.canonicalUrl = newCanonicalUrl;
                // Check if the only thing that changed was the hash fragment.
                const oldUrl = new URL(state.canonicalUrl, url);
                const onlyHashChange = // navigations are always same-origin.
                url.pathname === oldUrl.pathname && url.search === oldUrl.search && url.hash !== oldUrl.hash;
                if (onlyHashChange) {
                    // The only updated part of the URL is the hash.
                    mutable.onlyHashChange = true;
                    mutable.shouldScroll = result.data.shouldScroll;
                    mutable.hashFragment = url.hash;
                    // Setting this to an empty array triggers a scroll for all new and
                    // updated segments. See `ScrollAndFocusHandler` for more details.
                    mutable.scrollableSegments = [];
                }
                return (0, _handlemutable.handleMutable)(state, mutable);
            }
        case _segmentcache.NavigationResultTag.Success:
            {
                // Received a new result.
                mutable.cache = result.data.cacheNode;
                mutable.patchedTree = result.data.flightRouterState;
                mutable.canonicalUrl = result.data.canonicalUrl;
                mutable.scrollableSegments = result.data.scrollableSegments;
                mutable.shouldScroll = result.data.shouldScroll;
                mutable.hashFragment = result.data.hash;
                return (0, _handlemutable.handleMutable)(state, mutable);
            }
        case _segmentcache.NavigationResultTag.Async:
            {
                return result.data.then((asyncResult)=>handleNavigationResult(url, state, mutable, pendingPush, asyncResult), // TODO: This matches the current behavior but we need to do something
                // better here if the network fails.
                ()=>{
                    return state;
                });
            }
        default:
            {
                result;
                return state;
            }
    }
}
function navigateReducer(state, action) {
    const { url, isExternalUrl, navigateType, shouldScroll, allowAliasing } = action;
    const mutable = {};
    const { hash } = url;
    const href = (0, _createhreffromurl.createHrefFromUrl)(url);
    const pendingPush = navigateType === 'push';
    // we want to prune the prefetch cache on every navigation to avoid it growing too large
    (0, _prefetchcacheutils.prunePrefetchCache)(state.prefetchCache);
    mutable.preserveCustomHistoryState = false;
    mutable.pendingPush = pendingPush;
    if (isExternalUrl) {
        return handleExternalUrl(state, mutable, url.toString(), pendingPush);
    }
    // Handles case where `<meta http-equiv="refresh">` tag is present,
    // which will trigger an MPA navigation.
    if (document.getElementById('__next-page-redirect')) {
        return handleExternalUrl(state, mutable, href, pendingPush);
    }
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    const prefetchValues = (0, _prefetchcacheutils.getOrCreatePrefetchCacheEntry)({
        url,
        nextUrl: state.nextUrl,
        tree: state.tree,
        prefetchCache: state.prefetchCache,
        allowAliasing
    });
    const { treeAtTimeOfPrefetch, data } = prefetchValues;
    _prefetchreducer.prefetchQueue.bump(data);
    return data.then((param)=>{
        let { flightData, canonicalUrl: canonicalUrlOverride, postponed } = param;
        const navigatedAt = Date.now();
        let isFirstRead = false;
        // we only want to mark this once
        if (!prefetchValues.lastUsedTime) {
            // important: we should only mark the cache node as dirty after we unsuspend from the call above
            prefetchValues.lastUsedTime = navigatedAt;
            isFirstRead = true;
        }
        if (prefetchValues.aliased) {
            // When alias is enabled, search param may not be included in the canonicalUrl.
            // But we want to set url to canonicalUrl so that we use redirected path for fetching dynamic data.
            const urlWithCanonicalPathname = new URL(url.href);
            if (canonicalUrlOverride) {
                urlWithCanonicalPathname.pathname = canonicalUrlOverride.pathname;
            }
            const result = (0, _aliasedprefetchnavigations.handleAliasedPrefetchEntry)(navigatedAt, state, flightData, urlWithCanonicalPathname, mutable);
            // We didn't return new router state because we didn't apply the aliased entry for some reason.
            // We'll re-invoke the navigation handler but ensure that we don't attempt to use the aliased entry. This
            // will create an on-demand prefetch entry.
            if (result === false) {
                return navigateReducer(state, {
                    ...action,
                    allowAliasing: false
                });
            }
            return result;
        }
        // Handle case when navigating to page in `pages` from `app`
        if (typeof flightData === 'string') {
            return handleExternalUrl(state, mutable, flightData, pendingPush);
        }
        const updatedCanonicalUrl = canonicalUrlOverride ? (0, _createhreffromurl.createHrefFromUrl)(canonicalUrlOverride) : href;
        const onlyHashChange = !!hash && state.canonicalUrl.split('#', 1)[0] === updatedCanonicalUrl.split('#', 1)[0];
        // If only the hash has changed, the server hasn't sent us any new data. We can just update
        // the mutable properties responsible for URL and scroll handling and return early.
        if (onlyHashChange) {
            mutable.onlyHashChange = true;
            mutable.canonicalUrl = updatedCanonicalUrl;
            mutable.shouldScroll = shouldScroll;
            mutable.hashFragment = hash;
            mutable.scrollableSegments = [];
            return (0, _handlemutable.handleMutable)(state, mutable);
        }
        let currentTree = state.tree;
        let currentCache = state.cache;
        let scrollableSegments = [];
        for (const normalizedFlightData of flightData){
            const { pathToSegment: flightSegmentPath, seedData, head, isHeadPartial, isRootRender } = normalizedFlightData;
            let treePatch = normalizedFlightData.tree;
            // TODO-APP: remove ''
            const flightSegmentPathWithLeadingEmpty = [
                '',
                ...flightSegmentPath
            ];
            // Create new tree based on the flightSegmentPath and router state patch
            let newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)(flightSegmentPathWithLeadingEmpty, currentTree, treePatch, href);
            // If the tree patch can't be applied to the current tree then we use the tree at time of prefetch
            // TODO-APP: This should instead fill in the missing pieces in `currentTree` with the data from `treeAtTimeOfPrefetch`, then apply the patch.
            if (newTree === null) {
                newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)(flightSegmentPathWithLeadingEmpty, treeAtTimeOfPrefetch, treePatch, href);
            }
            if (newTree !== null) {
                if (// will send back a static response that's rendered from
                // the root. If for some reason it doesn't, we fall back to the
                // non-PPR implementation.
                // TODO: We should get rid of the else branch and do all navigations
                // via startPPRNavigation. The current structure is just
                // an incremental step.
                seedData && isRootRender && postponed) {
                    const task = (0, _pprnavigations.startPPRNavigation)(navigatedAt, currentCache, currentTree, treePatch, seedData, head, isHeadPartial, false, scrollableSegments);
                    if (task !== null) {
                        if (task.route === null) {
                            // Detected a change to the root layout. Perform an full-
                            // page navigation.
                            return handleExternalUrl(state, mutable, href, pendingPush);
                        }
                        // Use the tree computed by startPPRNavigation instead
                        // of the one computed by applyRouterStatePatchToTree.
                        // TODO: We should remove applyRouterStatePatchToTree
                        // from the PPR path entirely.
                        const patchedRouterState = task.route;
                        newTree = patchedRouterState;
                        const newCache = task.node;
                        if (newCache !== null) {
                            // We've created a new Cache Node tree that contains a prefetched
                            // version of the next page. This can be rendered instantly.
                            mutable.cache = newCache;
                        }
                        const dynamicRequestTree = task.dynamicRequestTree;
                        if (dynamicRequestTree !== null) {
                            // The prefetched tree has dynamic holes in it. We initiate a
                            // dynamic request to fill them in.
                            //
                            // Do not block on the result. We'll immediately render the Cache
                            // Node tree and suspend on the dynamic parts. When the request
                            // comes in, we'll fill in missing data and ping React to
                            // re-render. Unlike the lazy fetching model in the non-PPR
                            // implementation, this is modeled as a single React update +
                            // streaming, rather than multiple top-level updates. (However,
                            // even in the new model, we'll still need to sometimes update the
                            // root multiple times per navigation, like if the server sends us
                            // a different response than we expected. For now, we revert back
                            // to the lazy fetching mechanism in that case.)
                            const dynamicRequest = (0, _fetchserverresponse.fetchServerResponse)(new URL(updatedCanonicalUrl, url.origin), {
                                flightRouterState: dynamicRequestTree,
                                nextUrl: state.nextUrl
                            });
                            (0, _pprnavigations.listenForDynamicRequest)(task, dynamicRequest);
                        // We store the dynamic request on the `lazyData` property of the CacheNode
                        // because we're not going to await the dynamic request here. Since we're not blocking
                        // on the dynamic request, `layout-router` will
                        // task.node.lazyData = dynamicRequest
                        } else {
                        // The prefetched tree does not contain dynamic holes  it's
                        // fully static. We can skip the dynamic request.
                        }
                    } else {
                        // Nothing changed, so reuse the old cache.
                        // TODO: What if the head changed but not any of the segment data?
                        // Is that possible? If so, we should clone the whole tree and
                        // update the head.
                        newTree = treePatch;
                    }
                } else {
                    // The static response does not include any dynamic holes, so
                    // there's no need to do a second request.
                    // TODO: As an incremental step this just reverts back to the
                    // non-PPR implementation. We can simplify this branch further,
                    // given that PPR prefetches are always static and return the whole
                    // tree. Or in the meantime we could factor it out into a
                    // separate function.
                    if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {
                        return handleExternalUrl(state, mutable, href, pendingPush);
                    }
                    const cache = (0, _approuter.createEmptyCacheNode)();
                    let applied = false;
                    if (prefetchValues.status === _routerreducertypes.PrefetchCacheEntryStatus.stale && !isFirstRead) {
                        // When we have a stale prefetch entry, we only want to re-use the loading state of the route we're navigating to, to support instant loading navigations
                        // this will trigger a lazy fetch for the actual page data by nulling the `rsc` and `prefetchRsc` values for page data,
                        // while copying over the `loading` for the segment that contains the page data.
                        // We only do this on subsequent reads, as otherwise there'd be no loading data to re-use.
                        // We skip this branch if only the hash fragment has changed, as we don't want to trigger a lazy fetch in that case
                        applied = triggerLazyFetchForLeafSegments(cache, currentCache, flightSegmentPath, treePatch);
                        // since we re-used the stale cache's loading state & refreshed the data,
                        // update the `lastUsedTime` so that it can continue to be re-used for the next 30s
                        prefetchValues.lastUsedTime = navigatedAt;
                    } else {
                        applied = (0, _applyflightdata.applyFlightData)(navigatedAt, currentCache, cache, normalizedFlightData, prefetchValues);
                    }
                    const hardNavigate = (0, _shouldhardnavigate.shouldHardNavigate)(flightSegmentPathWithLeadingEmpty, currentTree);
                    if (hardNavigate) {
                        // Copy rsc for the root node of the cache.
                        cache.rsc = currentCache.rsc;
                        cache.prefetchRsc = currentCache.prefetchRsc;
                        (0, _invalidatecachebelowflightsegmentpath.invalidateCacheBelowFlightSegmentPath)(cache, currentCache, flightSegmentPath);
                        // Ensure the existing cache value is used when the cache was not invalidated.
                        mutable.cache = cache;
                    } else if (applied) {
                        mutable.cache = cache;
                        // If we applied the cache, we update the "current cache" value so any other
                        // segments in the FlightDataPath will be able to reference the updated cache.
                        currentCache = cache;
                    }
                    for (const subSegment of generateSegmentsFromPatch(treePatch)){
                        const scrollableSegmentPath = [
                            ...flightSegmentPath,
                            ...subSegment
                        ];
                        // Filter out the __DEFAULT__ paths as they shouldn't be scrolled to in this case.
                        if (scrollableSegmentPath[scrollableSegmentPath.length - 1] !== _segment.DEFAULT_SEGMENT_KEY) {
                            scrollableSegments.push(scrollableSegmentPath);
                        }
                    }
                }
                currentTree = newTree;
            }
        }
        mutable.patchedTree = currentTree;
        mutable.canonicalUrl = updatedCanonicalUrl;
        mutable.scrollableSegments = scrollableSegments;
        mutable.hashFragment = hash;
        mutable.shouldScroll = shouldScroll;
        return (0, _handlemutable.handleMutable)(state, mutable);
    }, ()=>state);
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=navigate-reducer.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/reducers/server-patch-reducer.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "serverPatchReducer", {
    enumerable: true,
    get: function() {
        return serverPatchReducer;
    }
});
const _createhreffromurl = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/create-href-from-url.js [app-ssr] (ecmascript)");
const _applyrouterstatepatchtotree = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js [app-ssr] (ecmascript)");
const _isnavigatingtonewrootlayout = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js [app-ssr] (ecmascript)");
const _navigatereducer = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js [app-ssr] (ecmascript)");
const _applyflightdata = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/apply-flight-data.js [app-ssr] (ecmascript)");
const _handlemutable = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/handle-mutable.js [app-ssr] (ecmascript)");
const _approuter = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/app-router.js [app-ssr] (ecmascript)");
function serverPatchReducer(state, action) {
    const { serverResponse: { flightData, canonicalUrl: canonicalUrlOverride }, navigatedAt } = action;
    const mutable = {};
    mutable.preserveCustomHistoryState = false;
    // Handle case when navigating to page in `pages` from `app`
    if (typeof flightData === 'string') {
        return (0, _navigatereducer.handleExternalUrl)(state, mutable, flightData, state.pushRef.pendingPush);
    }
    let currentTree = state.tree;
    let currentCache = state.cache;
    for (const normalizedFlightData of flightData){
        const { segmentPath: flightSegmentPath, tree: treePatch } = normalizedFlightData;
        const newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)([
            '',
            ...flightSegmentPath
        ], currentTree, treePatch, state.canonicalUrl);
        // `applyRouterStatePatchToTree` returns `null` when it determined that the server response is not applicable to the current tree.
        // In other words, the server responded with a tree that doesn't match what the client is currently rendering.
        // This can happen if the server patch action took longer to resolve than a subsequent navigation which would have changed the tree.
        // Previously this case triggered an MPA navigation but it should be safe to simply discard the server response rather than forcing
        // the entire page to reload.
        if (newTree === null) {
            return state;
        }
        if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {
            return (0, _navigatereducer.handleExternalUrl)(state, mutable, state.canonicalUrl, state.pushRef.pendingPush);
        }
        const canonicalUrlOverrideHref = canonicalUrlOverride ? (0, _createhreffromurl.createHrefFromUrl)(canonicalUrlOverride) : undefined;
        if (canonicalUrlOverrideHref) {
            mutable.canonicalUrl = canonicalUrlOverrideHref;
        }
        const cache = (0, _approuter.createEmptyCacheNode)();
        (0, _applyflightdata.applyFlightData)(navigatedAt, currentCache, cache, normalizedFlightData);
        mutable.patchedTree = newTree;
        mutable.cache = cache;
        currentCache = cache;
        currentTree = newTree;
    }
    return (0, _handlemutable.handleMutable)(state, mutable);
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=server-patch-reducer.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/reducers/restore-reducer.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "restoreReducer", {
    enumerable: true,
    get: function() {
        return restoreReducer;
    }
});
const _createhreffromurl = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/create-href-from-url.js [app-ssr] (ecmascript)");
const _computechangedpath = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/compute-changed-path.js [app-ssr] (ecmascript)");
const _pprnavigations = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/ppr-navigations.js [app-ssr] (ecmascript)");
function restoreReducer(state, action) {
    const { url, tree } = action;
    const href = (0, _createhreffromurl.createHrefFromUrl)(url);
    // This action is used to restore the router state from the history state.
    // However, it's possible that the history state no longer contains the `FlightRouterState`.
    // We will copy over the internal state on pushState/replaceState events, but if a history entry
    // occurred before hydration, or if the user navigated to a hash using a regular anchor link,
    // the history state will not contain the `FlightRouterState`.
    // In this case, we'll continue to use the existing tree so the router doesn't get into an invalid state.
    const treeToRestore = tree || state.tree;
    const oldCache = state.cache;
    const newCache = ("TURBOPACK compile-time falsy", 0) ? // prevents an unnecessary flash back to PPR state during a
    // back/forward navigation.
    "TURBOPACK unreachable" : oldCache;
    var _extractPathFromFlightRouterState;
    return {
        // Set canonical url
        canonicalUrl: href,
        pushRef: {
            pendingPush: false,
            mpaNavigation: false,
            // Ensures that the custom history state that was set is preserved when applying this update.
            preserveCustomHistoryState: true
        },
        focusAndScrollRef: state.focusAndScrollRef,
        cache: newCache,
        prefetchCache: state.prefetchCache,
        // Restore provided tree
        tree: treeToRestore,
        nextUrl: (_extractPathFromFlightRouterState = (0, _computechangedpath.extractPathFromFlightRouterState)(treeToRestore)) != null ? _extractPathFromFlightRouterState : url.pathname
    };
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=restore-reducer.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/handle-segment-mismatch.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "handleSegmentMismatch", {
    enumerable: true,
    get: function() {
        return handleSegmentMismatch;
    }
});
const _navigatereducer = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js [app-ssr] (ecmascript)");
function handleSegmentMismatch(state, action, treePatch) {
    if ("TURBOPACK compile-time truthy", 1) {
        console.warn('Performing hard navigation because your application experienced an unrecoverable error. If this keeps occurring, please file a Next.js issue.\n\n' + 'Reason: Segment mismatch\n' + ("Last Action: " + action.type + "\n\n") + ("Current Tree: " + JSON.stringify(state.tree) + "\n\n") + ("Tree Patch Payload: " + JSON.stringify(treePatch)));
    }
    return (0, _navigatereducer.handleExternalUrl)(state, {}, state.canonicalUrl, true);
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=handle-segment-mismatch.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "hasInterceptionRouteInCurrentTree", {
    enumerable: true,
    get: function() {
        return hasInterceptionRouteInCurrentTree;
    }
});
const _interceptionroutes = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/interception-routes.js [app-ssr] (ecmascript)");
function hasInterceptionRouteInCurrentTree(param) {
    let [segment, parallelRoutes] = param;
    // If we have a dynamic segment, it's marked as an interception route by the presence of the `i` suffix.
    if (Array.isArray(segment) && (segment[2] === 'di' || segment[2] === 'ci')) {
        return true;
    }
    // If segment is not an array, apply the existing string-based check
    if (typeof segment === 'string' && (0, _interceptionroutes.isInterceptionRouteAppPath)(segment)) {
        return true;
    }
    // Iterate through parallelRoutes if they exist
    if (parallelRoutes) {
        for(const key in parallelRoutes){
            if (hasInterceptionRouteInCurrentTree(parallelRoutes[key])) {
                return true;
            }
        }
    }
    return false;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=has-interception-route-in-current-tree.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/reducers/refresh-reducer.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "refreshReducer", {
    enumerable: true,
    get: function() {
        return refreshReducer;
    }
});
const _fetchserverresponse = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/fetch-server-response.js [app-ssr] (ecmascript)");
const _createhreffromurl = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/create-href-from-url.js [app-ssr] (ecmascript)");
const _applyrouterstatepatchtotree = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js [app-ssr] (ecmascript)");
const _isnavigatingtonewrootlayout = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js [app-ssr] (ecmascript)");
const _navigatereducer = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js [app-ssr] (ecmascript)");
const _handlemutable = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/handle-mutable.js [app-ssr] (ecmascript)");
const _filllazyitemstillleafwithhead = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js [app-ssr] (ecmascript)");
const _approuter = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/app-router.js [app-ssr] (ecmascript)");
const _handlesegmentmismatch = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/handle-segment-mismatch.js [app-ssr] (ecmascript)");
const _hasinterceptionrouteincurrenttree = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js [app-ssr] (ecmascript)");
const _refetchinactiveparallelsegments = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/refetch-inactive-parallel-segments.js [app-ssr] (ecmascript)");
const _segmentcache = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/segment-cache.js [app-ssr] (ecmascript)");
function refreshReducer(state, action) {
    const { origin } = action;
    const mutable = {};
    const href = state.canonicalUrl;
    let currentTree = state.tree;
    mutable.preserveCustomHistoryState = false;
    const cache = (0, _approuter.createEmptyCacheNode)();
    // If the current tree was intercepted, the nextUrl should be included in the request.
    // This is to ensure that the refresh request doesn't get intercepted, accidentally triggering the interception route.
    const includeNextUrl = (0, _hasinterceptionrouteincurrenttree.hasInterceptionRouteInCurrentTree)(state.tree);
    // TODO-APP: verify that `href` is not an external url.
    // Fetch data from the root of the tree.
    cache.lazyData = (0, _fetchserverresponse.fetchServerResponse)(new URL(href, origin), {
        flightRouterState: [
            currentTree[0],
            currentTree[1],
            currentTree[2],
            'refetch'
        ],
        nextUrl: includeNextUrl ? state.nextUrl : null
    });
    const navigatedAt = Date.now();
    return cache.lazyData.then(async (param)=>{
        let { flightData, canonicalUrl: canonicalUrlOverride } = param;
        // Handle case when navigating to page in `pages` from `app`
        if (typeof flightData === 'string') {
            return (0, _navigatereducer.handleExternalUrl)(state, mutable, flightData, state.pushRef.pendingPush);
        }
        // Remove cache.lazyData as it has been resolved at this point.
        cache.lazyData = null;
        for (const normalizedFlightData of flightData){
            const { tree: treePatch, seedData: cacheNodeSeedData, head, isRootRender } = normalizedFlightData;
            if (!isRootRender) {
                // TODO-APP: handle this case better
                console.log('REFRESH FAILED');
                return state;
            }
            const newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)([
                ''
            ], currentTree, treePatch, state.canonicalUrl);
            if (newTree === null) {
                return (0, _handlesegmentmismatch.handleSegmentMismatch)(state, action, treePatch);
            }
            if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {
                return (0, _navigatereducer.handleExternalUrl)(state, mutable, href, state.pushRef.pendingPush);
            }
            const canonicalUrlOverrideHref = canonicalUrlOverride ? (0, _createhreffromurl.createHrefFromUrl)(canonicalUrlOverride) : undefined;
            if (canonicalUrlOverride) {
                mutable.canonicalUrl = canonicalUrlOverrideHref;
            }
            // Handles case where prefetch only returns the router tree patch without rendered components.
            if (cacheNodeSeedData !== null) {
                const rsc = cacheNodeSeedData[1];
                const loading = cacheNodeSeedData[3];
                cache.rsc = rsc;
                cache.prefetchRsc = null;
                cache.loading = loading;
                (0, _filllazyitemstillleafwithhead.fillLazyItemsTillLeafWithHead)(navigatedAt, cache, undefined, treePatch, cacheNodeSeedData, head, undefined);
                if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
                ;
                else {
                    mutable.prefetchCache = new Map();
                }
            }
            await (0, _refetchinactiveparallelsegments.refreshInactiveParallelSegments)({
                navigatedAt,
                state,
                updatedTree: newTree,
                updatedCache: cache,
                includeNextUrl,
                canonicalUrl: mutable.canonicalUrl || state.canonicalUrl
            });
            mutable.cache = cache;
            mutable.patchedTree = newTree;
            currentTree = newTree;
        }
        return (0, _handlemutable.handleMutable)(state, mutable);
    }, ()=>state);
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=refresh-reducer.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/reducers/hmr-refresh-reducer.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "hmrRefreshReducer", {
    enumerable: true,
    get: function() {
        return hmrRefreshReducer;
    }
});
const _fetchserverresponse = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/fetch-server-response.js [app-ssr] (ecmascript)");
const _createhreffromurl = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/create-href-from-url.js [app-ssr] (ecmascript)");
const _applyrouterstatepatchtotree = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js [app-ssr] (ecmascript)");
const _isnavigatingtonewrootlayout = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js [app-ssr] (ecmascript)");
const _navigatereducer = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js [app-ssr] (ecmascript)");
const _handlemutable = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/handle-mutable.js [app-ssr] (ecmascript)");
const _applyflightdata = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/apply-flight-data.js [app-ssr] (ecmascript)");
const _approuter = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/app-router.js [app-ssr] (ecmascript)");
const _handlesegmentmismatch = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/handle-segment-mismatch.js [app-ssr] (ecmascript)");
const _hasinterceptionrouteincurrenttree = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js [app-ssr] (ecmascript)");
// A version of refresh reducer that keeps the cache around instead of wiping all of it.
function hmrRefreshReducerImpl(state, action) {
    const { origin } = action;
    const mutable = {};
    const href = state.canonicalUrl;
    mutable.preserveCustomHistoryState = false;
    const cache = (0, _approuter.createEmptyCacheNode)();
    // If the current tree was intercepted, the nextUrl should be included in the request.
    // This is to ensure that the refresh request doesn't get intercepted, accidentally triggering the interception route.
    const includeNextUrl = (0, _hasinterceptionrouteincurrenttree.hasInterceptionRouteInCurrentTree)(state.tree);
    // TODO-APP: verify that `href` is not an external url.
    // Fetch data from the root of the tree.
    const navigatedAt = Date.now();
    cache.lazyData = (0, _fetchserverresponse.fetchServerResponse)(new URL(href, origin), {
        flightRouterState: [
            state.tree[0],
            state.tree[1],
            state.tree[2],
            'refetch'
        ],
        nextUrl: includeNextUrl ? state.nextUrl : null,
        isHmrRefresh: true
    });
    return cache.lazyData.then((param)=>{
        let { flightData, canonicalUrl: canonicalUrlOverride } = param;
        // Handle case when navigating to page in `pages` from `app`
        if (typeof flightData === 'string') {
            return (0, _navigatereducer.handleExternalUrl)(state, mutable, flightData, state.pushRef.pendingPush);
        }
        // Remove cache.lazyData as it has been resolved at this point.
        cache.lazyData = null;
        let currentTree = state.tree;
        let currentCache = state.cache;
        for (const normalizedFlightData of flightData){
            const { tree: treePatch, isRootRender } = normalizedFlightData;
            if (!isRootRender) {
                // TODO-APP: handle this case better
                console.log('REFRESH FAILED');
                return state;
            }
            const newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)([
                ''
            ], currentTree, treePatch, state.canonicalUrl);
            if (newTree === null) {
                return (0, _handlesegmentmismatch.handleSegmentMismatch)(state, action, treePatch);
            }
            if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {
                return (0, _navigatereducer.handleExternalUrl)(state, mutable, href, state.pushRef.pendingPush);
            }
            const canonicalUrlOverrideHref = canonicalUrlOverride ? (0, _createhreffromurl.createHrefFromUrl)(canonicalUrlOverride) : undefined;
            if (canonicalUrlOverride) {
                mutable.canonicalUrl = canonicalUrlOverrideHref;
            }
            const applied = (0, _applyflightdata.applyFlightData)(navigatedAt, currentCache, cache, normalizedFlightData);
            if (applied) {
                mutable.cache = cache;
                currentCache = cache;
            }
            mutable.patchedTree = newTree;
            mutable.canonicalUrl = href;
            currentTree = newTree;
        }
        return (0, _handlemutable.handleMutable)(state, mutable);
    }, ()=>state);
}
function hmrRefreshReducerNoop(state, _action) {
    return state;
}
const hmrRefreshReducer = ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : hmrRefreshReducerImpl;
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=hmr-refresh-reducer.js.map
}}),
"[project]/node_modules/next/dist/client/assign-location.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "assignLocation", {
    enumerable: true,
    get: function() {
        return assignLocation;
    }
});
const _addbasepath = __turbopack_context__.r("[project]/node_modules/next/dist/client/add-base-path.js [app-ssr] (ecmascript)");
function assignLocation(location, url) {
    if (location.startsWith('.')) {
        const urlBase = url.origin + url.pathname;
        return new URL(// new URL('./relative', 'https://example.com/subdir').href -> 'https://example.com/relative'
        // new URL('./relative', 'https://example.com/subdir/').href -> 'https://example.com/subdir/relative'
        (urlBase.endsWith('/') ? urlBase : urlBase + '/') + location);
    }
    return new URL((0, _addbasepath.addBasePath)(location), url.href);
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=assign-location.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/server-reference-info.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    extractInfoFromServerReferenceId: null,
    omitUnusedArgs: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    extractInfoFromServerReferenceId: function() {
        return extractInfoFromServerReferenceId;
    },
    omitUnusedArgs: function() {
        return omitUnusedArgs;
    }
});
function extractInfoFromServerReferenceId(id) {
    const infoByte = parseInt(id.slice(0, 2), 16);
    const typeBit = infoByte >> 7 & 0x1;
    const argMask = infoByte >> 1 & 0x3f;
    const restArgs = infoByte & 0x1;
    const usedArgs = Array(6);
    for(let index = 0; index < 6; index++){
        const bitPosition = 5 - index;
        const bit = argMask >> bitPosition & 0x1;
        usedArgs[index] = bit === 1;
    }
    return {
        type: typeBit === 1 ? 'use-cache' : 'server-action',
        usedArgs: usedArgs,
        hasRestArgs: restArgs === 1
    };
}
function omitUnusedArgs(args, info) {
    const filteredArgs = new Array(args.length);
    for(let index = 0; index < args.length; index++){
        if (index < 6 && info.usedArgs[index] || // This assumes that the server reference info byte has the restArgs bit
        // set to 1 if there are more than 6 args.
        index >= 6 && info.hasRestArgs) {
            filteredArgs[index] = args[index];
        }
    }
    return filteredArgs;
} //# sourceMappingURL=server-reference-info.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/reducers/server-action-reducer.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "serverActionReducer", {
    enumerable: true,
    get: function() {
        return serverActionReducer;
    }
});
const _appcallserver = __turbopack_context__.r("[project]/node_modules/next/dist/client/app-call-server.js [app-ssr] (ecmascript)");
const _appfindsourcemapurl = __turbopack_context__.r("[project]/node_modules/next/dist/client/app-find-source-map-url.js [app-ssr] (ecmascript)");
const _approuterheaders = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/app-router-headers.js [app-ssr] (ecmascript)");
const _client = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-server-dom-turbopack-client.js [app-ssr] (ecmascript)");
const _routerreducertypes = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/router-reducer-types.js [app-ssr] (ecmascript)");
const _assignlocation = __turbopack_context__.r("[project]/node_modules/next/dist/client/assign-location.js [app-ssr] (ecmascript)");
const _createhreffromurl = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/create-href-from-url.js [app-ssr] (ecmascript)");
const _navigatereducer = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js [app-ssr] (ecmascript)");
const _applyrouterstatepatchtotree = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js [app-ssr] (ecmascript)");
const _isnavigatingtonewrootlayout = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js [app-ssr] (ecmascript)");
const _handlemutable = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/handle-mutable.js [app-ssr] (ecmascript)");
const _filllazyitemstillleafwithhead = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js [app-ssr] (ecmascript)");
const _approuter = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/app-router.js [app-ssr] (ecmascript)");
const _hasinterceptionrouteincurrenttree = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js [app-ssr] (ecmascript)");
const _handlesegmentmismatch = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/handle-segment-mismatch.js [app-ssr] (ecmascript)");
const _refetchinactiveparallelsegments = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/refetch-inactive-parallel-segments.js [app-ssr] (ecmascript)");
const _flightdatahelpers = __turbopack_context__.r("[project]/node_modules/next/dist/client/flight-data-helpers.js [app-ssr] (ecmascript)");
const _redirect = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/redirect.js [app-ssr] (ecmascript)");
const _redirecterror = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/redirect-error.js [app-ssr] (ecmascript)");
const _prefetchcacheutils = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js [app-ssr] (ecmascript)");
const _removebasepath = __turbopack_context__.r("[project]/node_modules/next/dist/client/remove-base-path.js [app-ssr] (ecmascript)");
const _hasbasepath = __turbopack_context__.r("[project]/node_modules/next/dist/client/has-base-path.js [app-ssr] (ecmascript)");
const _serverreferenceinfo = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/server-reference-info.js [app-ssr] (ecmascript)");
const _segmentcache = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/segment-cache.js [app-ssr] (ecmascript)");
const createFromFetch = _client.createFromFetch;
async function fetchServerAction(state, nextUrl, param) {
    let { actionId, actionArgs } = param;
    const temporaryReferences = (0, _client.createTemporaryReferenceSet)();
    const info = (0, _serverreferenceinfo.extractInfoFromServerReferenceId)(actionId);
    // TODO: Currently, we're only omitting unused args for the experimental "use
    // cache" functions. Once the server reference info byte feature is stable, we
    // should apply this to server actions as well.
    const usedArgs = info.type === 'use-cache' ? (0, _serverreferenceinfo.omitUnusedArgs)(actionArgs, info) : actionArgs;
    const body = await (0, _client.encodeReply)(usedArgs, {
        temporaryReferences
    });
    const res = await fetch(state.canonicalUrl, {
        method: 'POST',
        headers: {
            Accept: _approuterheaders.RSC_CONTENT_TYPE_HEADER,
            [_approuterheaders.ACTION_HEADER]: actionId,
            [_approuterheaders.NEXT_ROUTER_STATE_TREE_HEADER]: (0, _flightdatahelpers.prepareFlightRouterStateForRequest)(state.tree),
            ...("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : {},
            ...nextUrl ? {
                [_approuterheaders.NEXT_URL]: nextUrl
            } : {}
        },
        body
    });
    // Handle server actions that the server didn't recognize.
    const unrecognizedActionHeader = res.headers.get(_approuterheaders.NEXT_ACTION_NOT_FOUND_HEADER);
    if (unrecognizedActionHeader === '1') {
        throw Object.defineProperty(new Error('Server Action "' + actionId + '" was not found on the server. \nRead more: https://nextjs.org/docs/messages/failed-to-find-server-action'), "__NEXT_ERROR_CODE", {
            value: "E715",
            enumerable: false,
            configurable: true
        });
    }
    const redirectHeader = res.headers.get('x-action-redirect');
    const [location, _redirectType] = (redirectHeader == null ? void 0 : redirectHeader.split(';')) || [];
    let redirectType;
    switch(_redirectType){
        case 'push':
            redirectType = _redirecterror.RedirectType.push;
            break;
        case 'replace':
            redirectType = _redirecterror.RedirectType.replace;
            break;
        default:
            redirectType = undefined;
    }
    const isPrerender = !!res.headers.get(_approuterheaders.NEXT_IS_PRERENDER_HEADER);
    let revalidatedParts;
    try {
        const revalidatedHeader = JSON.parse(res.headers.get('x-action-revalidated') || '[[],0,0]');
        revalidatedParts = {
            paths: revalidatedHeader[0] || [],
            tag: !!revalidatedHeader[1],
            cookie: revalidatedHeader[2]
        };
    } catch (e) {
        revalidatedParts = NO_REVALIDATED_PARTS;
    }
    const redirectLocation = location ? (0, _assignlocation.assignLocation)(location, new URL(state.canonicalUrl, window.location.href)) : undefined;
    const contentType = res.headers.get('content-type');
    const isRscResponse = !!(contentType && contentType.startsWith(_approuterheaders.RSC_CONTENT_TYPE_HEADER));
    // Handle invalid server action responses.
    // A valid response must have `content-type: text/x-component`, unless it's an external redirect.
    // (external redirects have an 'x-action-redirect' header, but the body is an empty 'text/plain')
    if (!isRscResponse && !redirectLocation) {
        // The server can respond with a text/plain error message, but we'll fallback to something generic
        // if there isn't one.
        const message = res.status >= 400 && contentType === 'text/plain' ? await res.text() : 'An unexpected response was received from the server.';
        throw Object.defineProperty(new Error(message), "__NEXT_ERROR_CODE", {
            value: "E394",
            enumerable: false,
            configurable: true
        });
    }
    let actionResult;
    let actionFlightData;
    if (isRscResponse) {
        const response = await createFromFetch(Promise.resolve(res), {
            callServer: _appcallserver.callServer,
            findSourceMapURL: _appfindsourcemapurl.findSourceMapURL,
            temporaryReferences
        });
        // An internal redirect can send an RSC response, but does not have a useful `actionResult`.
        actionResult = redirectLocation ? undefined : response.a;
        actionFlightData = (0, _flightdatahelpers.normalizeFlightData)(response.f);
    } else {
        // An external redirect doesn't contain RSC data.
        actionResult = undefined;
        actionFlightData = undefined;
    }
    return {
        actionResult,
        actionFlightData,
        redirectLocation,
        redirectType,
        revalidatedParts,
        isPrerender
    };
}
const NO_REVALIDATED_PARTS = {
    paths: [],
    tag: false,
    cookie: false
};
function serverActionReducer(state, action) {
    const { resolve, reject } = action;
    const mutable = {};
    let currentTree = state.tree;
    mutable.preserveCustomHistoryState = false;
    // only pass along the `nextUrl` param (used for interception routes) if the current route was intercepted.
    // If the route has been intercepted, the action should be as well.
    // Otherwise the server action might be intercepted with the wrong action id
    // (ie, one that corresponds with the intercepted route)
    const nextUrl = state.nextUrl && (0, _hasinterceptionrouteincurrenttree.hasInterceptionRouteInCurrentTree)(state.tree) ? state.nextUrl : null;
    const navigatedAt = Date.now();
    return fetchServerAction(state, nextUrl, action).then(async (param)=>{
        let { actionResult, actionFlightData: flightData, redirectLocation, redirectType, isPrerender, revalidatedParts } = param;
        let redirectHref;
        // honor the redirect type instead of defaulting to push in case of server actions.
        if (redirectLocation) {
            if (redirectType === _redirecterror.RedirectType.replace) {
                state.pushRef.pendingPush = false;
                mutable.pendingPush = false;
            } else {
                state.pushRef.pendingPush = true;
                mutable.pendingPush = true;
            }
            redirectHref = (0, _createhreffromurl.createHrefFromUrl)(redirectLocation, false);
            mutable.canonicalUrl = redirectHref;
        }
        if (!flightData) {
            resolve(actionResult);
            // If there is a redirect but no flight data we need to do a mpaNavigation.
            if (redirectLocation) {
                return (0, _navigatereducer.handleExternalUrl)(state, mutable, redirectLocation.href, state.pushRef.pendingPush);
            }
            return state;
        }
        if (typeof flightData === 'string') {
            // Handle case when navigating to page in `pages` from `app`
            resolve(actionResult);
            return (0, _navigatereducer.handleExternalUrl)(state, mutable, flightData, state.pushRef.pendingPush);
        }
        const actionRevalidated = revalidatedParts.paths.length > 0 || revalidatedParts.tag || revalidatedParts.cookie;
        for (const normalizedFlightData of flightData){
            const { tree: treePatch, seedData: cacheNodeSeedData, head, isRootRender } = normalizedFlightData;
            if (!isRootRender) {
                // TODO-APP: handle this case better
                console.log('SERVER ACTION APPLY FAILED');
                resolve(actionResult);
                return state;
            }
            // Given the path can only have two items the items are only the router state and rsc for the root.
            const newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)([
                ''
            ], currentTree, treePatch, redirectHref ? redirectHref : state.canonicalUrl);
            if (newTree === null) {
                resolve(actionResult);
                return (0, _handlesegmentmismatch.handleSegmentMismatch)(state, action, treePatch);
            }
            if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {
                resolve(actionResult);
                return (0, _navigatereducer.handleExternalUrl)(state, mutable, redirectHref || state.canonicalUrl, state.pushRef.pendingPush);
            }
            // The server sent back RSC data for the server action, so we need to apply it to the cache.
            if (cacheNodeSeedData !== null) {
                const rsc = cacheNodeSeedData[1];
                const cache = (0, _approuter.createEmptyCacheNode)();
                cache.rsc = rsc;
                cache.prefetchRsc = null;
                cache.loading = cacheNodeSeedData[3];
                (0, _filllazyitemstillleafwithhead.fillLazyItemsTillLeafWithHead)(navigatedAt, cache, undefined, treePatch, cacheNodeSeedData, head, undefined);
                mutable.cache = cache;
                if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
                ;
                else {
                    mutable.prefetchCache = new Map();
                }
                if (actionRevalidated) {
                    await (0, _refetchinactiveparallelsegments.refreshInactiveParallelSegments)({
                        navigatedAt,
                        state,
                        updatedTree: newTree,
                        updatedCache: cache,
                        includeNextUrl: Boolean(nextUrl),
                        canonicalUrl: mutable.canonicalUrl || state.canonicalUrl
                    });
                }
            }
            mutable.patchedTree = newTree;
            currentTree = newTree;
        }
        if (redirectLocation && redirectHref) {
            if (!("TURBOPACK compile-time value", false) && !actionRevalidated) {
                // Because the RedirectBoundary will trigger a navigation, we need to seed the prefetch cache
                // with the FlightData that we got from the server action for the target page, so that it's
                // available when the page is navigated to and doesn't need to be re-fetched.
                // We only do this if the server action didn't revalidate any data, as in that case the
                // client cache will be cleared and the data will be re-fetched anyway.
                // NOTE: We don't do this in the Segment Cache implementation.
                // Dynamic data should never be placed into the cache, unless it's
                // "converted" to static data using <Link prefetch={true}>. What we
                // do instead is re-prefetch links and forms whenever the cache is
                // invalidated.
                (0, _prefetchcacheutils.createSeededPrefetchCacheEntry)({
                    url: redirectLocation,
                    data: {
                        flightData,
                        canonicalUrl: undefined,
                        couldBeIntercepted: false,
                        prerendered: false,
                        postponed: false,
                        // TODO: We should be able to set this if the server action
                        // returned a fully static response.
                        staleTime: -1
                    },
                    tree: state.tree,
                    prefetchCache: state.prefetchCache,
                    nextUrl: state.nextUrl,
                    kind: isPrerender ? _routerreducertypes.PrefetchKind.FULL : _routerreducertypes.PrefetchKind.AUTO
                });
                mutable.prefetchCache = state.prefetchCache;
            }
            // If the action triggered a redirect, the action promise will be rejected with
            // a redirect so that it's handled by RedirectBoundary as we won't have a valid
            // action result to resolve the promise with. This will effectively reset the state of
            // the component that called the action as the error boundary will remount the tree.
            // The status code doesn't matter here as the action handler will have already sent
            // a response with the correct status code.
            reject((0, _redirect.getRedirectError)((0, _hasbasepath.hasBasePath)(redirectHref) ? (0, _removebasepath.removeBasePath)(redirectHref) : redirectHref, redirectType || _redirecterror.RedirectType.push));
        } else {
            resolve(actionResult);
        }
        return (0, _handlemutable.handleMutable)(state, mutable);
    }, (e)=>{
        // When the server action is rejected we don't update the state and instead call the reject handler of the promise.
        reject(e);
        return state;
    });
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=server-action-reducer.js.map
}}),
"[project]/node_modules/next/dist/client/components/router-reducer/router-reducer.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "reducer", {
    enumerable: true,
    get: function() {
        return reducer;
    }
});
const _routerreducertypes = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/router-reducer-types.js [app-ssr] (ecmascript)");
const _navigatereducer = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js [app-ssr] (ecmascript)");
const _serverpatchreducer = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/reducers/server-patch-reducer.js [app-ssr] (ecmascript)");
const _restorereducer = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/reducers/restore-reducer.js [app-ssr] (ecmascript)");
const _refreshreducer = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/reducers/refresh-reducer.js [app-ssr] (ecmascript)");
const _prefetchreducer = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js [app-ssr] (ecmascript)");
const _hmrrefreshreducer = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/reducers/hmr-refresh-reducer.js [app-ssr] (ecmascript)");
const _serveractionreducer = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/reducers/server-action-reducer.js [app-ssr] (ecmascript)");
/**
 * Reducer that handles the app-router state updates.
 */ function clientReducer(state, action) {
    switch(action.type){
        case _routerreducertypes.ACTION_NAVIGATE:
            {
                return (0, _navigatereducer.navigateReducer)(state, action);
            }
        case _routerreducertypes.ACTION_SERVER_PATCH:
            {
                return (0, _serverpatchreducer.serverPatchReducer)(state, action);
            }
        case _routerreducertypes.ACTION_RESTORE:
            {
                return (0, _restorereducer.restoreReducer)(state, action);
            }
        case _routerreducertypes.ACTION_REFRESH:
            {
                return (0, _refreshreducer.refreshReducer)(state, action);
            }
        case _routerreducertypes.ACTION_HMR_REFRESH:
            {
                return (0, _hmrrefreshreducer.hmrRefreshReducer)(state, action);
            }
        case _routerreducertypes.ACTION_PREFETCH:
            {
                return (0, _prefetchreducer.prefetchReducer)(state, action);
            }
        case _routerreducertypes.ACTION_SERVER_ACTION:
            {
                return (0, _serveractionreducer.serverActionReducer)(state, action);
            }
        // This case should never be hit as dispatch is strongly typed.
        default:
            throw Object.defineProperty(new Error('Unknown action'), "__NEXT_ERROR_CODE", {
                value: "E295",
                enumerable: false,
                configurable: true
            });
    }
}
function serverReducer(state, _action) {
    return state;
}
const reducer = ("TURBOPACK compile-time truthy", 1) ? serverReducer : "TURBOPACK unreachable";
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=router-reducer.js.map
}}),
"[project]/node_modules/next/dist/client/components/app-router-instance.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    createMutableActionQueue: null,
    dispatchNavigateAction: null,
    dispatchTraverseAction: null,
    getCurrentAppRouterState: null,
    publicAppRouterInstance: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    createMutableActionQueue: function() {
        return createMutableActionQueue;
    },
    dispatchNavigateAction: function() {
        return dispatchNavigateAction;
    },
    dispatchTraverseAction: function() {
        return dispatchTraverseAction;
    },
    getCurrentAppRouterState: function() {
        return getCurrentAppRouterState;
    },
    publicAppRouterInstance: function() {
        return publicAppRouterInstance;
    }
});
const _routerreducertypes = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/router-reducer-types.js [app-ssr] (ecmascript)");
const _routerreducer = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/router-reducer.js [app-ssr] (ecmascript)");
const _react = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
const _isthenable = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/is-thenable.js [app-ssr] (ecmascript)");
const _segmentcache = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/segment-cache.js [app-ssr] (ecmascript)");
const _useactionqueue = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/use-action-queue.js [app-ssr] (ecmascript)");
const _addbasepath = __turbopack_context__.r("[project]/node_modules/next/dist/client/add-base-path.js [app-ssr] (ecmascript)");
const _approuter = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/app-router.js [app-ssr] (ecmascript)");
const _prefetchreducer = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js [app-ssr] (ecmascript)");
const _links = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/links.js [app-ssr] (ecmascript)");
function runRemainingActions(actionQueue, setState) {
    if (actionQueue.pending !== null) {
        actionQueue.pending = actionQueue.pending.next;
        if (actionQueue.pending !== null) {
            // eslint-disable-next-line @typescript-eslint/no-use-before-define
            runAction({
                actionQueue,
                action: actionQueue.pending,
                setState
            });
        } else {
            // No more actions are pending, check if a refresh is needed
            if (actionQueue.needsRefresh) {
                actionQueue.needsRefresh = false;
                actionQueue.dispatch({
                    type: _routerreducertypes.ACTION_REFRESH,
                    origin: window.location.origin
                }, setState);
            }
        }
    }
}
async function runAction(param) {
    let { actionQueue, action, setState } = param;
    const prevState = actionQueue.state;
    actionQueue.pending = action;
    const payload = action.payload;
    const actionResult = actionQueue.action(prevState, payload);
    function handleResult(nextState) {
        // if we discarded this action, the state should also be discarded
        if (action.discarded) {
            return;
        }
        actionQueue.state = nextState;
        runRemainingActions(actionQueue, setState);
        action.resolve(nextState);
    }
    // if the action is a promise, set up a callback to resolve it
    if ((0, _isthenable.isThenable)(actionResult)) {
        actionResult.then(handleResult, (err)=>{
            runRemainingActions(actionQueue, setState);
            action.reject(err);
        });
    } else {
        handleResult(actionResult);
    }
}
function dispatchAction(actionQueue, payload, setState) {
    let resolvers = {
        resolve: setState,
        reject: ()=>{}
    };
    // most of the action types are async with the exception of restore
    // it's important that restore is handled quickly since it's fired on the popstate event
    // and we don't want to add any delay on a back/forward nav
    // this only creates a promise for the async actions
    if (payload.type !== _routerreducertypes.ACTION_RESTORE) {
        // Create the promise and assign the resolvers to the object.
        const deferredPromise = new Promise((resolve, reject)=>{
            resolvers = {
                resolve,
                reject
            };
        });
        (0, _react.startTransition)(()=>{
            // we immediately notify React of the pending promise -- the resolver is attached to the action node
            // and will be called when the associated action promise resolves
            setState(deferredPromise);
        });
    }
    const newAction = {
        payload,
        next: null,
        resolve: resolvers.resolve,
        reject: resolvers.reject
    };
    // Check if the queue is empty
    if (actionQueue.pending === null) {
        // The queue is empty, so add the action and start it immediately
        // Mark this action as the last in the queue
        actionQueue.last = newAction;
        runAction({
            actionQueue,
            action: newAction,
            setState
        });
    } else if (payload.type === _routerreducertypes.ACTION_NAVIGATE || payload.type === _routerreducertypes.ACTION_RESTORE) {
        // Navigations (including back/forward) take priority over any pending actions.
        // Mark the pending action as discarded (so the state is never applied) and start the navigation action immediately.
        actionQueue.pending.discarded = true;
        // The rest of the current queue should still execute after this navigation.
        // (Note that it can't contain any earlier navigations, because we always put those into `actionQueue.pending` by calling `runAction`)
        newAction.next = actionQueue.pending.next;
        // if the pending action was a server action, mark the queue as needing a refresh once events are processed
        if (actionQueue.pending.payload.type === _routerreducertypes.ACTION_SERVER_ACTION) {
            actionQueue.needsRefresh = true;
        }
        runAction({
            actionQueue,
            action: newAction,
            setState
        });
    } else {
        // The queue is not empty, so add the action to the end of the queue
        // It will be started by runRemainingActions after the previous action finishes
        if (actionQueue.last !== null) {
            actionQueue.last.next = newAction;
        }
        actionQueue.last = newAction;
    }
}
let globalActionQueue = null;
function createMutableActionQueue(initialState, instrumentationHooks) {
    const actionQueue = {
        state: initialState,
        dispatch: (payload, setState)=>dispatchAction(actionQueue, payload, setState),
        action: async (state, action)=>{
            const result = (0, _routerreducer.reducer)(state, action);
            return result;
        },
        pending: null,
        last: null,
        onRouterTransitionStart: instrumentationHooks !== null && typeof instrumentationHooks.onRouterTransitionStart === 'function' ? instrumentationHooks.onRouterTransitionStart : null
    };
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    return actionQueue;
}
function getCurrentAppRouterState() {
    return globalActionQueue !== null ? globalActionQueue.state : null;
}
function getAppRouterActionQueue() {
    if (globalActionQueue === null) {
        throw Object.defineProperty(new Error('Internal Next.js error: Router action dispatched before initialization.'), "__NEXT_ERROR_CODE", {
            value: "E668",
            enumerable: false,
            configurable: true
        });
    }
    return globalActionQueue;
}
function getProfilingHookForOnNavigationStart() {
    if (globalActionQueue !== null) {
        return globalActionQueue.onRouterTransitionStart;
    }
    return null;
}
function dispatchNavigateAction(href, navigateType, shouldScroll, linkInstanceRef) {
    // TODO: This stuff could just go into the reducer. Leaving as-is for now
    // since we're about to rewrite all the router reducer stuff anyway.
    const url = new URL((0, _addbasepath.addBasePath)(href), location.href);
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    (0, _links.setLinkForCurrentNavigation)(linkInstanceRef);
    const onRouterTransitionStart = getProfilingHookForOnNavigationStart();
    if (onRouterTransitionStart !== null) {
        onRouterTransitionStart(href, navigateType);
    }
    (0, _useactionqueue.dispatchAppRouterAction)({
        type: _routerreducertypes.ACTION_NAVIGATE,
        url,
        isExternalUrl: (0, _approuter.isExternalURL)(url),
        locationSearch: location.search,
        shouldScroll,
        navigateType,
        allowAliasing: true
    });
}
function dispatchTraverseAction(href, tree) {
    const onRouterTransitionStart = getProfilingHookForOnNavigationStart();
    if (onRouterTransitionStart !== null) {
        onRouterTransitionStart(href, 'traverse');
    }
    (0, _useactionqueue.dispatchAppRouterAction)({
        type: _routerreducertypes.ACTION_RESTORE,
        url: new URL(href),
        tree
    });
}
const publicAppRouterInstance = {
    back: ()=>window.history.back(),
    forward: ()=>window.history.forward(),
    prefetch: ("TURBOPACK compile-time falsy", 0) ? // cache. So we don't need to dispatch an action.
    "TURBOPACK unreachable" : (href, options)=>{
        // Use the old prefetch implementation.
        const actionQueue = getAppRouterActionQueue();
        const url = (0, _approuter.createPrefetchURL)(href);
        if (url !== null) {
            var _options_kind;
            // The prefetch reducer doesn't actually update any state or
            // trigger a rerender. It just writes to a mutable cache. So we
            // shouldn't bother calling setState/dispatch; we can just re-run
            // the reducer directly using the current state.
            // TODO: Refactor this away from a "reducer" so it's
            // less confusing.
            (0, _prefetchreducer.prefetchReducer)(actionQueue.state, {
                type: _routerreducertypes.ACTION_PREFETCH,
                url,
                kind: (_options_kind = options == null ? void 0 : options.kind) != null ? _options_kind : _routerreducertypes.PrefetchKind.FULL
            });
        }
    },
    replace: (href, options)=>{
        (0, _react.startTransition)(()=>{
            var _options_scroll;
            dispatchNavigateAction(href, 'replace', (_options_scroll = options == null ? void 0 : options.scroll) != null ? _options_scroll : true, null);
        });
    },
    push: (href, options)=>{
        (0, _react.startTransition)(()=>{
            var _options_scroll;
            dispatchNavigateAction(href, 'push', (_options_scroll = options == null ? void 0 : options.scroll) != null ? _options_scroll : true, null);
        });
    },
    refresh: ()=>{
        (0, _react.startTransition)(()=>{
            (0, _useactionqueue.dispatchAppRouterAction)({
                type: _routerreducertypes.ACTION_REFRESH,
                origin: window.location.origin
            });
        });
    },
    hmrRefresh: ()=>{
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        else {
            (0, _react.startTransition)(()=>{
                (0, _useactionqueue.dispatchAppRouterAction)({
                    type: _routerreducertypes.ACTION_HMR_REFRESH,
                    origin: window.location.origin
                });
            });
        }
    }
};
// Exists for debugging purposes. Don't use in application code.
if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=app-router-instance.js.map
}}),
"[project]/node_modules/next/dist/client/components/links.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    IDLE_LINK_STATUS: null,
    PENDING_LINK_STATUS: null,
    mountFormInstance: null,
    mountLinkInstance: null,
    onLinkVisibilityChanged: null,
    onNavigationIntent: null,
    pingVisibleLinks: null,
    setLinkForCurrentNavigation: null,
    unmountLinkForCurrentNavigation: null,
    unmountPrefetchableInstance: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    IDLE_LINK_STATUS: function() {
        return IDLE_LINK_STATUS;
    },
    PENDING_LINK_STATUS: function() {
        return PENDING_LINK_STATUS;
    },
    mountFormInstance: function() {
        return mountFormInstance;
    },
    mountLinkInstance: function() {
        return mountLinkInstance;
    },
    onLinkVisibilityChanged: function() {
        return onLinkVisibilityChanged;
    },
    onNavigationIntent: function() {
        return onNavigationIntent;
    },
    pingVisibleLinks: function() {
        return pingVisibleLinks;
    },
    setLinkForCurrentNavigation: function() {
        return setLinkForCurrentNavigation;
    },
    unmountLinkForCurrentNavigation: function() {
        return unmountLinkForCurrentNavigation;
    },
    unmountPrefetchableInstance: function() {
        return unmountPrefetchableInstance;
    }
});
const _approuterinstance = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/app-router-instance.js [app-ssr] (ecmascript)");
const _approuter = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/app-router.js [app-ssr] (ecmascript)");
const _routerreducertypes = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/router-reducer-types.js [app-ssr] (ecmascript)");
const _segmentcache = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/segment-cache.js [app-ssr] (ecmascript)");
const _react = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
// Tracks the most recently navigated link instance. When null, indicates
// the current navigation was not initiated by a link click.
let linkForMostRecentNavigation = null;
const PENDING_LINK_STATUS = {
    pending: true
};
const IDLE_LINK_STATUS = {
    pending: false
};
function setLinkForCurrentNavigation(link) {
    (0, _react.startTransition)(()=>{
        linkForMostRecentNavigation == null ? void 0 : linkForMostRecentNavigation.setOptimisticLinkStatus(IDLE_LINK_STATUS);
        link == null ? void 0 : link.setOptimisticLinkStatus(PENDING_LINK_STATUS);
        linkForMostRecentNavigation = link;
    });
}
function unmountLinkForCurrentNavigation(link) {
    if (linkForMostRecentNavigation === link) {
        linkForMostRecentNavigation = null;
    }
}
// Use a WeakMap to associate a Link instance with its DOM element. This is
// used by the IntersectionObserver to track the link's visibility.
const prefetchable = typeof WeakMap === 'function' ? new WeakMap() : new Map();
// A Set of the currently visible links. We re-prefetch visible links after a
// cache invalidation, or when the current URL changes. It's a separate data
// structure from the WeakMap above because only the visible links need to
// be enumerated.
const prefetchableAndVisible = new Set();
// A single IntersectionObserver instance shared by all <Link> components.
const observer = typeof IntersectionObserver === 'function' ? new IntersectionObserver(handleIntersect, {
    rootMargin: '200px'
}) : null;
function observeVisibility(element, instance) {
    const existingInstance = prefetchable.get(element);
    if (existingInstance !== undefined) {
        // This shouldn't happen because each <Link> component should have its own
        // anchor tag instance, but it's defensive coding to avoid a memory leak in
        // case there's a logical error somewhere else.
        unmountPrefetchableInstance(element);
    }
    // Only track prefetchable links that have a valid prefetch URL
    prefetchable.set(element, instance);
    if (observer !== null) {
        observer.observe(element);
    }
}
function coercePrefetchableUrl(href) {
    try {
        return (0, _approuter.createPrefetchURL)(href);
    } catch (e) {
        // createPrefetchURL sometimes throws an error if an invalid URL is
        // provided, though I'm not sure if it's actually necessary.
        // TODO: Consider removing the throw from the inner function, or change it
        // to reportError. Or maybe the error isn't even necessary for automatic
        // prefetches, just navigations.
        const reportErrorFn = typeof reportError === 'function' ? reportError : console.error;
        reportErrorFn("Cannot prefetch '" + href + "' because it cannot be converted to a URL.");
        return null;
    }
}
function mountLinkInstance(element, href, router, kind, prefetchEnabled, setOptimisticLinkStatus) {
    if (prefetchEnabled) {
        const prefetchURL = coercePrefetchableUrl(href);
        if (prefetchURL !== null) {
            const instance = {
                router,
                kind,
                isVisible: false,
                prefetchTask: null,
                prefetchHref: prefetchURL.href,
                setOptimisticLinkStatus
            };
            // We only observe the link's visibility if it's prefetchable. For
            // example, this excludes links to external URLs.
            observeVisibility(element, instance);
            return instance;
        }
    }
    // If the link is not prefetchable, we still create an instance so we can
    // track its optimistic state (i.e. useLinkStatus).
    const instance = {
        router,
        kind,
        isVisible: false,
        prefetchTask: null,
        prefetchHref: null,
        setOptimisticLinkStatus
    };
    return instance;
}
function mountFormInstance(element, href, router, kind) {
    const prefetchURL = coercePrefetchableUrl(href);
    if (prefetchURL === null) {
        // This href is not prefetchable, so we don't track it.
        // TODO: We currently observe/unobserve a form every time its href changes.
        // For Links, this isn't a big deal because the href doesn't usually change,
        // but for forms it's extremely common. We should optimize this.
        return;
    }
    const instance = {
        router,
        kind,
        isVisible: false,
        prefetchTask: null,
        prefetchHref: prefetchURL.href,
        setOptimisticLinkStatus: null
    };
    observeVisibility(element, instance);
}
function unmountPrefetchableInstance(element) {
    const instance = prefetchable.get(element);
    if (instance !== undefined) {
        prefetchable.delete(element);
        prefetchableAndVisible.delete(instance);
        const prefetchTask = instance.prefetchTask;
        if (prefetchTask !== null) {
            (0, _segmentcache.cancelPrefetchTask)(prefetchTask);
        }
    }
    if (observer !== null) {
        observer.unobserve(element);
    }
}
function handleIntersect(entries) {
    for (const entry of entries){
        // Some extremely old browsers or polyfills don't reliably support
        // isIntersecting so we check intersectionRatio instead. (Do we care? Not
        // really. But whatever this is fine.)
        const isVisible = entry.intersectionRatio > 0;
        onLinkVisibilityChanged(entry.target, isVisible);
    }
}
function onLinkVisibilityChanged(element, isVisible) {
    if ("TURBOPACK compile-time truthy", 1) {
        // Prefetching on viewport is disabled in development for performance
        // reasons, because it requires compiling the target page.
        // TODO: Investigate re-enabling this.
        return;
    }
    //TURBOPACK unreachable
    ;
    const instance = undefined;
}
function onNavigationIntent(element, unstable_upgradeToDynamicPrefetch) {
    const instance = prefetchable.get(element);
    if (instance === undefined) {
        return;
    }
    // Prefetch the link on hover/touchstart.
    if (instance !== undefined) {
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        rescheduleLinkPrefetch(instance, _segmentcache.PrefetchPriority.Intent);
    }
}
function rescheduleLinkPrefetch(instance, priority) {
    const existingPrefetchTask = instance.prefetchTask;
    if (!instance.isVisible) {
        // Cancel any in-progress prefetch task. (If it already finished then this
        // is a no-op.)
        if (existingPrefetchTask !== null) {
            (0, _segmentcache.cancelPrefetchTask)(existingPrefetchTask);
        }
        // We don't need to reset the prefetchTask to null upon cancellation; an
        // old task object can be rescheduled with reschedulePrefetchTask. This is a
        // micro-optimization but also makes the code simpler (don't need to
        // worry about whether an old task object is stale).
        return;
    }
    if ("TURBOPACK compile-time truthy", 1) {
        // The old prefetch implementation does not have different priority levels.
        // Just schedule a new prefetch task.
        prefetchWithOldCacheImplementation(instance);
        return;
    }
    //TURBOPACK unreachable
    ;
    const appRouterState = undefined;
}
function pingVisibleLinks(nextUrl, tree) {
    // For each currently visible link, cancel the existing prefetch task (if it
    // exists) and schedule a new one. This is effectively the same as if all the
    // visible links left and then re-entered the viewport.
    //
    // This is called when the Next-Url or the base tree changes, since those
    // may affect the result of a prefetch task. It's also called after a
    // cache invalidation.
    for (const instance of prefetchableAndVisible){
        const task = instance.prefetchTask;
        if (task !== null && !(0, _segmentcache.isPrefetchTaskDirty)(task, nextUrl, tree)) {
            continue;
        }
        // Something changed. Cancel the existing prefetch task and schedule a
        // new one.
        if (task !== null) {
            (0, _segmentcache.cancelPrefetchTask)(task);
        }
        const cacheKey = (0, _segmentcache.createCacheKey)(instance.prefetchHref, nextUrl);
        instance.prefetchTask = (0, _segmentcache.schedulePrefetchTask)(cacheKey, tree, instance.kind === _routerreducertypes.PrefetchKind.FULL, _segmentcache.PrefetchPriority.Default, null);
    }
}
function prefetchWithOldCacheImplementation(instance) {
    // This is the path used when the Segment Cache is not enabled.
    if ("TURBOPACK compile-time truthy", 1) {
        return;
    }
    //TURBOPACK unreachable
    ;
    const doPrefetch = undefined;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=links.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/router/utils/is-local-url.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "isLocalURL", {
    enumerable: true,
    get: function() {
        return isLocalURL;
    }
});
const _utils = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/utils.js [app-ssr] (ecmascript)");
const _hasbasepath = __turbopack_context__.r("[project]/node_modules/next/dist/client/has-base-path.js [app-ssr] (ecmascript)");
function isLocalURL(url) {
    // prevent a hydration mismatch on href for url with anchor refs
    if (!(0, _utils.isAbsoluteUrl)(url)) return true;
    try {
        // absolute urls can be local if they are on the same origin
        const locationOrigin = (0, _utils.getLocationOrigin)();
        const resolved = new URL(url, locationOrigin);
        return resolved.origin === locationOrigin && (0, _hasbasepath.hasBasePath)(resolved.pathname);
    } catch (_) {
        return false;
    }
} //# sourceMappingURL=is-local-url.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/utils/error-once.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "errorOnce", {
    enumerable: true,
    get: function() {
        return errorOnce;
    }
});
let errorOnce = (_)=>{};
if ("TURBOPACK compile-time truthy", 1) {
    const errors = new Set();
    errorOnce = (msg)=>{
        if (!errors.has(msg)) {
            console.error(msg);
        }
        errors.add(msg);
    };
} //# sourceMappingURL=error-once.js.map
}}),
"[project]/node_modules/next/dist/client/app-dir/link.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    default: null,
    useLinkStatus: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    /**
 * A React component that extends the HTML `<a>` element to provide
 * [prefetching](https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)
 * and client-side navigation. This is the primary way to navigate between routes in Next.js.
 *
 * @remarks
 * - Prefetching is only enabled in production.
 *
 * @see https://nextjs.org/docs/app/api-reference/components/link
 */ default: function() {
        return LinkComponent;
    },
    useLinkStatus: function() {
        return useLinkStatus;
    }
});
const _interop_require_wildcard = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [app-ssr] (ecmascript)");
const _jsxruntime = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js [app-ssr] (ecmascript)");
const _react = /*#__PURE__*/ _interop_require_wildcard._(__turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)"));
const _formaturl = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/format-url.js [app-ssr] (ecmascript)");
const _approutercontextsharedruntime = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/contexts/app-router-context.js [app-ssr] (ecmascript)");
const _routerreducertypes = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/router-reducer-types.js [app-ssr] (ecmascript)");
const _usemergedref = __turbopack_context__.r("[project]/node_modules/next/dist/client/use-merged-ref.js [app-ssr] (ecmascript)");
const _utils = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/utils.js [app-ssr] (ecmascript)");
const _addbasepath = __turbopack_context__.r("[project]/node_modules/next/dist/client/add-base-path.js [app-ssr] (ecmascript)");
const _warnonce = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/utils/warn-once.js [app-ssr] (ecmascript)");
const _links = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/links.js [app-ssr] (ecmascript)");
const _islocalurl = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/is-local-url.js [app-ssr] (ecmascript)");
const _approuterinstance = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/app-router-instance.js [app-ssr] (ecmascript)");
const _erroronce = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/utils/error-once.js [app-ssr] (ecmascript)");
function isModifiedEvent(event) {
    const eventTarget = event.currentTarget;
    const target = eventTarget.getAttribute('target');
    return target && target !== '_self' || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey || // triggers resource download
    event.nativeEvent && event.nativeEvent.which === 2;
}
function linkClicked(e, href, as, linkInstanceRef, replace, scroll, onNavigate) {
    const { nodeName } = e.currentTarget;
    // anchors inside an svg have a lowercase nodeName
    const isAnchorNodeName = nodeName.toUpperCase() === 'A';
    if (isAnchorNodeName && isModifiedEvent(e) || e.currentTarget.hasAttribute('download')) {
        // ignore click for browsers default behavior
        return;
    }
    if (!(0, _islocalurl.isLocalURL)(href)) {
        if (replace) {
            // browser default behavior does not replace the history state
            // so we need to do it manually
            e.preventDefault();
            location.replace(href);
        }
        // ignore click for browsers default behavior
        return;
    }
    e.preventDefault();
    if (onNavigate) {
        let isDefaultPrevented = false;
        onNavigate({
            preventDefault: ()=>{
                isDefaultPrevented = true;
            }
        });
        if (isDefaultPrevented) {
            return;
        }
    }
    _react.default.startTransition(()=>{
        (0, _approuterinstance.dispatchNavigateAction)(as || href, replace ? 'replace' : 'push', scroll != null ? scroll : true, linkInstanceRef.current);
    });
}
function formatStringOrUrl(urlObjOrString) {
    if (typeof urlObjOrString === 'string') {
        return urlObjOrString;
    }
    return (0, _formaturl.formatUrl)(urlObjOrString);
}
function LinkComponent(props) {
    const [linkStatus, setOptimisticLinkStatus] = (0, _react.useOptimistic)(_links.IDLE_LINK_STATUS);
    let children;
    const linkInstanceRef = (0, _react.useRef)(null);
    const { href: hrefProp, as: asProp, children: childrenProp, prefetch: prefetchProp = null, passHref, replace, shallow, scroll, onClick, onMouseEnter: onMouseEnterProp, onTouchStart: onTouchStartProp, legacyBehavior = false, onNavigate, ref: forwardedRef, unstable_dynamicOnHover, ...restProps } = props;
    children = childrenProp;
    if (legacyBehavior && (typeof children === 'string' || typeof children === 'number')) {
        children = /*#__PURE__*/ (0, _jsxruntime.jsx)("a", {
            children: children
        });
    }
    const router = _react.default.useContext(_approutercontextsharedruntime.AppRouterContext);
    const prefetchEnabled = prefetchProp !== false;
    /**
   * The possible states for prefetch are:
   * - null: this is the default "auto" mode, where we will prefetch partially if the link is in the viewport
   * - true: we will prefetch if the link is visible and prefetch the full page, not just partially
   * - false: we will not prefetch if in the viewport at all
   * - 'unstable_dynamicOnHover': this starts in "auto" mode, but switches to "full" when the link is hovered
   */ const appPrefetchKind = prefetchProp === null || prefetchProp === 'auto' ? _routerreducertypes.PrefetchKind.AUTO : _routerreducertypes.PrefetchKind.FULL;
    if ("TURBOPACK compile-time truthy", 1) {
        function createPropError(args) {
            return Object.defineProperty(new Error("Failed prop type: The prop `" + args.key + "` expects a " + args.expected + " in `<Link>`, but got `" + args.actual + "` instead." + (("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : '')), "__NEXT_ERROR_CODE", {
                value: "E319",
                enumerable: false,
                configurable: true
            });
        }
        // TypeScript trick for type-guarding:
        const requiredPropsGuard = {
            href: true
        };
        const requiredProps = Object.keys(requiredPropsGuard);
        requiredProps.forEach((key)=>{
            if (key === 'href') {
                if (props[key] == null || typeof props[key] !== 'string' && typeof props[key] !== 'object') {
                    throw createPropError({
                        key,
                        expected: '`string` or `object`',
                        actual: props[key] === null ? 'null' : typeof props[key]
                    });
                }
            } else {
                // TypeScript trick for type-guarding:
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const _ = key;
            }
        });
        // TypeScript trick for type-guarding:
        const optionalPropsGuard = {
            as: true,
            replace: true,
            scroll: true,
            shallow: true,
            passHref: true,
            prefetch: true,
            unstable_dynamicOnHover: true,
            onClick: true,
            onMouseEnter: true,
            onTouchStart: true,
            legacyBehavior: true,
            onNavigate: true
        };
        const optionalProps = Object.keys(optionalPropsGuard);
        optionalProps.forEach((key)=>{
            const valType = typeof props[key];
            if (key === 'as') {
                if (props[key] && valType !== 'string' && valType !== 'object') {
                    throw createPropError({
                        key,
                        expected: '`string` or `object`',
                        actual: valType
                    });
                }
            } else if (key === 'onClick' || key === 'onMouseEnter' || key === 'onTouchStart' || key === 'onNavigate') {
                if (props[key] && valType !== 'function') {
                    throw createPropError({
                        key,
                        expected: '`function`',
                        actual: valType
                    });
                }
            } else if (key === 'replace' || key === 'scroll' || key === 'shallow' || key === 'passHref' || key === 'legacyBehavior' || key === 'unstable_dynamicOnHover') {
                if (props[key] != null && valType !== 'boolean') {
                    throw createPropError({
                        key,
                        expected: '`boolean`',
                        actual: valType
                    });
                }
            } else if (key === 'prefetch') {
                if (props[key] != null && valType !== 'boolean' && props[key] !== 'auto') {
                    throw createPropError({
                        key,
                        expected: '`boolean | "auto"`',
                        actual: valType
                    });
                }
            } else {
                // TypeScript trick for type-guarding:
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const _ = key;
            }
        });
    }
    if ("TURBOPACK compile-time truthy", 1) {
        if (props.locale) {
            (0, _warnonce.warnOnce)('The `locale` prop is not supported in `next/link` while using the `app` router. Read more about app router internalization: https://nextjs.org/docs/app/building-your-application/routing/internationalization');
        }
        if (!asProp) {
            let href;
            if (typeof hrefProp === 'string') {
                href = hrefProp;
            } else if (typeof hrefProp === 'object' && typeof hrefProp.pathname === 'string') {
                href = hrefProp.pathname;
            }
            if (href) {
                const hasDynamicSegment = href.split('/').some((segment)=>segment.startsWith('[') && segment.endsWith(']'));
                if (hasDynamicSegment) {
                    throw Object.defineProperty(new Error("Dynamic href `" + href + "` found in <Link> while using the `/app` router, this is not supported. Read more: https://nextjs.org/docs/messages/app-dir-dynamic-href"), "__NEXT_ERROR_CODE", {
                        value: "E267",
                        enumerable: false,
                        configurable: true
                    });
                }
            }
        }
    }
    const { href, as } = _react.default.useMemo(()=>{
        const resolvedHref = formatStringOrUrl(hrefProp);
        return {
            href: resolvedHref,
            as: asProp ? formatStringOrUrl(asProp) : resolvedHref
        };
    }, [
        hrefProp,
        asProp
    ]);
    // This will return the first child, if multiple are provided it will throw an error
    let child;
    if (legacyBehavior) {
        if ("TURBOPACK compile-time truthy", 1) {
            if (onClick) {
                console.warn('"onClick" was passed to <Link> with `href` of `' + hrefProp + '` but "legacyBehavior" was set. The legacy behavior requires onClick be set on the child of next/link');
            }
            if (onMouseEnterProp) {
                console.warn('"onMouseEnter" was passed to <Link> with `href` of `' + hrefProp + '` but "legacyBehavior" was set. The legacy behavior requires onMouseEnter be set on the child of next/link');
            }
            try {
                child = _react.default.Children.only(children);
            } catch (err) {
                if (!children) {
                    throw Object.defineProperty(new Error("No children were passed to <Link> with `href` of `" + hrefProp + "` but one child is required https://nextjs.org/docs/messages/link-no-children"), "__NEXT_ERROR_CODE", {
                        value: "E320",
                        enumerable: false,
                        configurable: true
                    });
                }
                throw Object.defineProperty(new Error("Multiple children were passed to <Link> with `href` of `" + hrefProp + "` but only one child is supported https://nextjs.org/docs/messages/link-multiple-children" + (("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : '')), "__NEXT_ERROR_CODE", {
                    value: "E266",
                    enumerable: false,
                    configurable: true
                });
            }
        } else //TURBOPACK unreachable
        ;
    } else {
        if ("TURBOPACK compile-time truthy", 1) {
            if ((children == null ? void 0 : children.type) === 'a') {
                throw Object.defineProperty(new Error('Invalid <Link> with <a> child. Please remove <a> or use <Link legacyBehavior>.\nLearn more: https://nextjs.org/docs/messages/invalid-new-link-with-extra-anchor'), "__NEXT_ERROR_CODE", {
                    value: "E209",
                    enumerable: false,
                    configurable: true
                });
            }
        }
    }
    const childRef = legacyBehavior ? child && typeof child === 'object' && child.ref : forwardedRef;
    // Use a callback ref to attach an IntersectionObserver to the anchor tag on
    // mount. In the future we will also use this to keep track of all the
    // currently mounted <Link> instances, e.g. so we can re-prefetch them after
    // a revalidation or refresh.
    const observeLinkVisibilityOnMount = _react.default.useCallback((element)=>{
        if (router !== null) {
            linkInstanceRef.current = (0, _links.mountLinkInstance)(element, href, router, appPrefetchKind, prefetchEnabled, setOptimisticLinkStatus);
        }
        return ()=>{
            if (linkInstanceRef.current) {
                (0, _links.unmountLinkForCurrentNavigation)(linkInstanceRef.current);
                linkInstanceRef.current = null;
            }
            (0, _links.unmountPrefetchableInstance)(element);
        };
    }, [
        prefetchEnabled,
        href,
        router,
        appPrefetchKind,
        setOptimisticLinkStatus
    ]);
    const mergedRef = (0, _usemergedref.useMergedRef)(observeLinkVisibilityOnMount, childRef);
    const childProps = {
        ref: mergedRef,
        onClick (e) {
            if ("TURBOPACK compile-time truthy", 1) {
                if (!e) {
                    throw Object.defineProperty(new Error('Component rendered inside next/link has to pass click event to "onClick" prop.'), "__NEXT_ERROR_CODE", {
                        value: "E312",
                        enumerable: false,
                        configurable: true
                    });
                }
            }
            if (!legacyBehavior && typeof onClick === 'function') {
                onClick(e);
            }
            if (legacyBehavior && child.props && typeof child.props.onClick === 'function') {
                child.props.onClick(e);
            }
            if (!router) {
                return;
            }
            if (e.defaultPrevented) {
                return;
            }
            linkClicked(e, href, as, linkInstanceRef, replace, scroll, onNavigate);
        },
        onMouseEnter (e) {
            if (!legacyBehavior && typeof onMouseEnterProp === 'function') {
                onMouseEnterProp(e);
            }
            if (legacyBehavior && child.props && typeof child.props.onMouseEnter === 'function') {
                child.props.onMouseEnter(e);
            }
            if (!router) {
                return;
            }
            if ("TURBOPACK compile-time truthy", 1) {
                return;
            }
            //TURBOPACK unreachable
            ;
            const upgradeToDynamicPrefetch = undefined;
        },
        onTouchStart: ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : function onTouchStart(e) {
            if (!legacyBehavior && typeof onTouchStartProp === 'function') {
                onTouchStartProp(e);
            }
            if (legacyBehavior && child.props && typeof child.props.onTouchStart === 'function') {
                child.props.onTouchStart(e);
            }
            if (!router) {
                return;
            }
            if (!prefetchEnabled) {
                return;
            }
            const upgradeToDynamicPrefetch = unstable_dynamicOnHover === true;
            (0, _links.onNavigationIntent)(e.currentTarget, upgradeToDynamicPrefetch);
        }
    };
    // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is
    // defined, we specify the current 'href', so that repetition is not needed by the user.
    // If the url is absolute, we can bypass the logic to prepend the basePath.
    if ((0, _utils.isAbsoluteUrl)(as)) {
        childProps.href = as;
    } else if (!legacyBehavior || passHref || child.type === 'a' && !('href' in child.props)) {
        childProps.href = (0, _addbasepath.addBasePath)(as);
    }
    let link;
    if (legacyBehavior) {
        if ("TURBOPACK compile-time truthy", 1) {
            (0, _erroronce.errorOnce)('`legacyBehavior` is deprecated and will be removed in a future ' + 'release. A codemod is available to upgrade your components:\n\n' + 'npx @next/codemod@latest new-link .\n\n' + 'Learn more: https://nextjs.org/docs/app/building-your-application/upgrading/codemods#remove-a-tags-from-link-components');
        }
        link = /*#__PURE__*/ _react.default.cloneElement(child, childProps);
    } else {
        link = /*#__PURE__*/ (0, _jsxruntime.jsx)("a", {
            ...restProps,
            ...childProps,
            children: children
        });
    }
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(LinkStatusContext.Provider, {
        value: linkStatus,
        children: link
    });
}
const LinkStatusContext = /*#__PURE__*/ (0, _react.createContext)(_links.IDLE_LINK_STATUS);
const useLinkStatus = ()=>{
    return (0, _react.useContext)(LinkStatusContext);
};
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=link.js.map
}}),

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFtdLAogICJzZWN0aW9ucyI6IFsKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNywgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yZWR1Y2Vycy9nZXQtc2VnbWVudC12YWx1ZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IFNlZ21lbnQgfSBmcm9tICcuLi8uLi8uLi8uLi9zZXJ2ZXIvYXBwLXJlbmRlci90eXBlcydcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNlZ21lbnRWYWx1ZShzZWdtZW50OiBTZWdtZW50KSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHNlZ21lbnQpID8gc2VnbWVudFsxXSA6IHNlZ21lbnRcbn1cbiJdLCJuYW1lcyI6WyJnZXRTZWdtZW50VmFsdWUiLCJzZWdtZW50IiwiQXJyYXkiLCJpc0FycmF5Il0sIm1hcHBpbmdzIjoiOzs7K0JBRWdCQSxtQkFBQUE7OztlQUFBQTs7O0FBQVQsU0FBU0EsZ0JBQWdCQyxPQUFnQjtJQUM5QyxPQUFPQyxNQUFNQyxPQUFPLENBQUNGLFdBQVdBLE9BQU8sQ0FBQyxFQUFFLEdBQUdBO0FBQy9DIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDMyLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL3NoYXJlZC9saWIvc2VnbWVudC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IFNlZ21lbnQgfSBmcm9tICcuLi8uLi9zZXJ2ZXIvYXBwLXJlbmRlci90eXBlcydcblxuZXhwb3J0IGZ1bmN0aW9uIGlzR3JvdXBTZWdtZW50KHNlZ21lbnQ6IHN0cmluZykge1xuICAvLyBVc2UgYXJyYXlbMF0gZm9yIHBlcmZvcm1hbnQgcHVycG9zZVxuICByZXR1cm4gc2VnbWVudFswXSA9PT0gJygnICYmIHNlZ21lbnQuZW5kc1dpdGgoJyknKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNQYXJhbGxlbFJvdXRlU2VnbWVudChzZWdtZW50OiBzdHJpbmcpIHtcbiAgcmV0dXJuIHNlZ21lbnQuc3RhcnRzV2l0aCgnQCcpICYmIHNlZ21lbnQgIT09ICdAY2hpbGRyZW4nXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRTZWFyY2hQYXJhbXNJZlBhZ2VTZWdtZW50KFxuICBzZWdtZW50OiBTZWdtZW50LFxuICBzZWFyY2hQYXJhbXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IHN0cmluZ1tdIHwgdW5kZWZpbmVkPlxuKSB7XG4gIGNvbnN0IGlzUGFnZVNlZ21lbnQgPSBzZWdtZW50LmluY2x1ZGVzKFBBR0VfU0VHTUVOVF9LRVkpXG5cbiAgaWYgKGlzUGFnZVNlZ21lbnQpIHtcbiAgICBjb25zdCBzdHJpbmdpZmllZFF1ZXJ5ID0gSlNPTi5zdHJpbmdpZnkoc2VhcmNoUGFyYW1zKVxuICAgIHJldHVybiBzdHJpbmdpZmllZFF1ZXJ5ICE9PSAne30nXG4gICAgICA/IFBBR0VfU0VHTUVOVF9LRVkgKyAnPycgKyBzdHJpbmdpZmllZFF1ZXJ5XG4gICAgICA6IFBBR0VfU0VHTUVOVF9LRVlcbiAgfVxuXG4gIHJldHVybiBzZWdtZW50XG59XG5cbmV4cG9ydCBjb25zdCBQQUdFX1NFR01FTlRfS0VZID0gJ19fUEFHRV9fJ1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfU0VHTUVOVF9LRVkgPSAnX19ERUZBVUxUX18nXG4iXSwibmFtZXMiOlsiREVGQVVMVF9TRUdNRU5UX0tFWSIsIlBBR0VfU0VHTUVOVF9LRVkiLCJhZGRTZWFyY2hQYXJhbXNJZlBhZ2VTZWdtZW50IiwiaXNHcm91cFNlZ21lbnQiLCJpc1BhcmFsbGVsUm91dGVTZWdtZW50Iiwic2VnbWVudCIsImVuZHNXaXRoIiwic3RhcnRzV2l0aCIsInNlYXJjaFBhcmFtcyIsImlzUGFnZVNlZ21lbnQiLCJpbmNsdWRlcyIsInN0cmluZ2lmaWVkUXVlcnkiLCJKU09OIiwic3RyaW5naWZ5Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztJQTRCYUEsbUJBQW1CLEVBQUE7ZUFBbkJBOztJQURBQyxnQkFBZ0IsRUFBQTtlQUFoQkE7O0lBaEJHQyw0QkFBNEIsRUFBQTtlQUE1QkE7O0lBVEFDLGNBQWMsRUFBQTtlQUFkQTs7SUFLQUMsc0JBQXNCLEVBQUE7ZUFBdEJBOzs7QUFMVCxTQUFTRCxlQUFlRSxPQUFlO0lBQzVDLHNDQUFzQztJQUN0QyxPQUFPQSxPQUFPLENBQUMsRUFBRSxLQUFLLE9BQU9BLFFBQVFDLFFBQVEsQ0FBQztBQUNoRDtBQUVPLFNBQVNGLHVCQUF1QkMsT0FBZTtJQUNwRCxPQUFPQSxRQUFRRSxVQUFVLENBQUMsUUFBUUYsWUFBWTtBQUNoRDtBQUVPLFNBQVNILDZCQUNkRyxPQUFnQixFQUNoQkcsWUFBMkQ7SUFFM0QsTUFBTUMsZ0JBQWdCSixRQUFRSyxRQUFRLENBQUNUO0lBRXZDLElBQUlRLGVBQWU7UUFDakIsTUFBTUUsbUJBQW1CQyxLQUFLQyxTQUFTLENBQUNMO1FBQ3hDLE9BQU9HLHFCQUFxQixPQUN4QlYsbUJBQW1CLE1BQU1VLG1CQUN6QlY7SUFDTjtJQUVBLE9BQU9JO0FBQ1Q7QUFFTyxNQUFNSixtQkFBbUI7QUFDekIsTUFBTUQsc0JBQXNCIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDg4LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2NsaWVudC9jb21wb25lbnRzL3JlZGlyZWN0LXN0YXR1cy1jb2RlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBlbnVtIFJlZGlyZWN0U3RhdHVzQ29kZSB7XG4gIFNlZU90aGVyID0gMzAzLFxuICBUZW1wb3JhcnlSZWRpcmVjdCA9IDMwNyxcbiAgUGVybWFuZW50UmVkaXJlY3QgPSAzMDgsXG59XG4iXSwibmFtZXMiOlsiUmVkaXJlY3RTdGF0dXNDb2RlIl0sIm1hcHBpbmdzIjoiOzs7K0JBQVlBLHNCQUFBQTs7O2VBQUFBOzs7QUFBTCxJQUFLQSxxQkFBQUEsV0FBQUEsR0FBQUEsU0FBQUEsa0JBQUFBOzs7O1dBQUFBIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDExNiwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvY29tcG9uZW50cy9yZWRpcmVjdC1lcnJvci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBSZWRpcmVjdFN0YXR1c0NvZGUgfSBmcm9tICcuL3JlZGlyZWN0LXN0YXR1cy1jb2RlJ1xuXG5leHBvcnQgY29uc3QgUkVESVJFQ1RfRVJST1JfQ09ERSA9ICdORVhUX1JFRElSRUNUJ1xuXG5leHBvcnQgZW51bSBSZWRpcmVjdFR5cGUge1xuICBwdXNoID0gJ3B1c2gnLFxuICByZXBsYWNlID0gJ3JlcGxhY2UnLFxufVxuXG5leHBvcnQgdHlwZSBSZWRpcmVjdEVycm9yID0gRXJyb3IgJiB7XG4gIGRpZ2VzdDogYCR7dHlwZW9mIFJFRElSRUNUX0VSUk9SX0NPREV9OyR7UmVkaXJlY3RUeXBlfTske3N0cmluZ307JHtSZWRpcmVjdFN0YXR1c0NvZGV9O2Bcbn1cblxuLyoqXG4gKiBDaGVja3MgYW4gZXJyb3IgdG8gZGV0ZXJtaW5lIGlmIGl0J3MgYW4gZXJyb3IgZ2VuZXJhdGVkIGJ5IHRoZVxuICogYHJlZGlyZWN0KHVybClgIGhlbHBlci5cbiAqXG4gKiBAcGFyYW0gZXJyb3IgdGhlIGVycm9yIHRoYXQgbWF5IHJlZmVyZW5jZSBhIHJlZGlyZWN0IGVycm9yXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBlcnJvciBpcyBhIHJlZGlyZWN0IGVycm9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1JlZGlyZWN0RXJyb3IoZXJyb3I6IHVua25vd24pOiBlcnJvciBpcyBSZWRpcmVjdEVycm9yIHtcbiAgaWYgKFxuICAgIHR5cGVvZiBlcnJvciAhPT0gJ29iamVjdCcgfHxcbiAgICBlcnJvciA9PT0gbnVsbCB8fFxuICAgICEoJ2RpZ2VzdCcgaW4gZXJyb3IpIHx8XG4gICAgdHlwZW9mIGVycm9yLmRpZ2VzdCAhPT0gJ3N0cmluZydcbiAgKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBjb25zdCBkaWdlc3QgPSBlcnJvci5kaWdlc3Quc3BsaXQoJzsnKVxuICBjb25zdCBbZXJyb3JDb2RlLCB0eXBlXSA9IGRpZ2VzdFxuICBjb25zdCBkZXN0aW5hdGlvbiA9IGRpZ2VzdC5zbGljZSgyLCAtMikuam9pbignOycpXG4gIGNvbnN0IHN0YXR1cyA9IGRpZ2VzdC5hdCgtMilcblxuICBjb25zdCBzdGF0dXNDb2RlID0gTnVtYmVyKHN0YXR1cylcblxuICByZXR1cm4gKFxuICAgIGVycm9yQ29kZSA9PT0gUkVESVJFQ1RfRVJST1JfQ09ERSAmJlxuICAgICh0eXBlID09PSAncmVwbGFjZScgfHwgdHlwZSA9PT0gJ3B1c2gnKSAmJlxuICAgIHR5cGVvZiBkZXN0aW5hdGlvbiA9PT0gJ3N0cmluZycgJiZcbiAgICAhaXNOYU4oc3RhdHVzQ29kZSkgJiZcbiAgICBzdGF0dXNDb2RlIGluIFJlZGlyZWN0U3RhdHVzQ29kZVxuICApXG59XG4iXSwibmFtZXMiOlsiUkVESVJFQ1RfRVJST1JfQ09ERSIsIlJlZGlyZWN0VHlwZSIsImlzUmVkaXJlY3RFcnJvciIsImVycm9yIiwiZGlnZXN0Iiwic3BsaXQiLCJlcnJvckNvZGUiLCJ0eXBlIiwiZGVzdGluYXRpb24iLCJzbGljZSIsImpvaW4iLCJzdGF0dXMiLCJhdCIsInN0YXR1c0NvZGUiLCJOdW1iZXIiLCJpc05hTiIsIlJlZGlyZWN0U3RhdHVzQ29kZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0lBRWFBLG1CQUFtQixFQUFBO2VBQW5CQTs7SUFFREMsWUFBWSxFQUFBO2VBQVpBOztJQWdCSUMsZUFBZSxFQUFBO2VBQWZBOzs7b0NBcEJtQjtBQUU1QixNQUFNRixzQkFBc0I7QUFFNUIsSUFBS0MsZUFBQUEsV0FBQUEsR0FBQUEsU0FBQUEsWUFBQUE7OztXQUFBQTs7QUFnQkwsU0FBU0MsZ0JBQWdCQyxLQUFjO0lBQzVDLElBQ0UsT0FBT0EsVUFBVSxZQUNqQkEsVUFBVSxRQUNWLENBQUUsQ0FBQSxZQUFZQSxLQUFJLEtBQ2xCLE9BQU9BLE1BQU1DLE1BQU0sS0FBSyxVQUN4QjtRQUNBLE9BQU87SUFDVDtJQUVBLE1BQU1BLFNBQVNELE1BQU1DLE1BQU0sQ0FBQ0MsS0FBSyxDQUFDO0lBQ2xDLE1BQU0sQ0FBQ0MsV0FBV0MsS0FBSyxHQUFHSDtJQUMxQixNQUFNSSxjQUFjSixPQUFPSyxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUdDLElBQUksQ0FBQztJQUM3QyxNQUFNQyxTQUFTUCxPQUFPUSxFQUFFLENBQUMsQ0FBQztJQUUxQixNQUFNQyxhQUFhQyxPQUFPSDtJQUUxQixPQUNFTCxjQUFjTix1QkFDYk8sQ0FBQUEsU0FBUyxhQUFhQSxTQUFTLE1BQUssS0FDckMsT0FBT0MsZ0JBQWdCLFlBQ3ZCLENBQUNPLE1BQU1GLGVBQ1BBLGNBQWNHLG9CQUFBQSxrQkFBa0I7QUFFcEMiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTcyLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2NsaWVudC9jb21wb25lbnRzL3JlZGlyZWN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJlZGlyZWN0U3RhdHVzQ29kZSB9IGZyb20gJy4vcmVkaXJlY3Qtc3RhdHVzLWNvZGUnXG5pbXBvcnQge1xuICBSZWRpcmVjdFR5cGUsXG4gIHR5cGUgUmVkaXJlY3RFcnJvcixcbiAgaXNSZWRpcmVjdEVycm9yLFxuICBSRURJUkVDVF9FUlJPUl9DT0RFLFxufSBmcm9tICcuL3JlZGlyZWN0LWVycm9yJ1xuXG5jb25zdCBhY3Rpb25Bc3luY1N0b3JhZ2UgPVxuICB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJ1xuICAgID8gKFxuICAgICAgICByZXF1aXJlKCcuLi8uLi9zZXJ2ZXIvYXBwLXJlbmRlci9hY3Rpb24tYXN5bmMtc3RvcmFnZS5leHRlcm5hbCcpIGFzIHR5cGVvZiBpbXBvcnQoJy4uLy4uL3NlcnZlci9hcHAtcmVuZGVyL2FjdGlvbi1hc3luYy1zdG9yYWdlLmV4dGVybmFsJylcbiAgICAgICkuYWN0aW9uQXN5bmNTdG9yYWdlXG4gICAgOiB1bmRlZmluZWRcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJlZGlyZWN0RXJyb3IoXG4gIHVybDogc3RyaW5nLFxuICB0eXBlOiBSZWRpcmVjdFR5cGUsXG4gIHN0YXR1c0NvZGU6IFJlZGlyZWN0U3RhdHVzQ29kZSA9IFJlZGlyZWN0U3RhdHVzQ29kZS5UZW1wb3JhcnlSZWRpcmVjdFxuKTogUmVkaXJlY3RFcnJvciB7XG4gIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKFJFRElSRUNUX0VSUk9SX0NPREUpIGFzIFJlZGlyZWN0RXJyb3JcbiAgZXJyb3IuZGlnZXN0ID0gYCR7UkVESVJFQ1RfRVJST1JfQ09ERX07JHt0eXBlfTske3VybH07JHtzdGF0dXNDb2RlfTtgXG4gIHJldHVybiBlcnJvclxufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byByZWRpcmVjdCB0aGUgdXNlciB0byBhbm90aGVyIFVSTC4gSXQgY2FuIGJlIHVzZWQgaW5cbiAqIFtTZXJ2ZXIgQ29tcG9uZW50c10oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2J1aWxkaW5nLXlvdXItYXBwbGljYXRpb24vcmVuZGVyaW5nL3NlcnZlci1jb21wb25lbnRzKSxcbiAqIFtSb3V0ZSBIYW5kbGVyc10oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2J1aWxkaW5nLXlvdXItYXBwbGljYXRpb24vcm91dGluZy9yb3V0ZS1oYW5kbGVycyksIGFuZFxuICogW1NlcnZlciBBY3Rpb25zXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYnVpbGRpbmcteW91ci1hcHBsaWNhdGlvbi9kYXRhLWZldGNoaW5nL3NlcnZlci1hY3Rpb25zLWFuZC1tdXRhdGlvbnMpLlxuICpcbiAqIC0gSW4gYSBTZXJ2ZXIgQ29tcG9uZW50LCB0aGlzIHdpbGwgaW5zZXJ0IGEgbWV0YSB0YWcgdG8gcmVkaXJlY3QgdGhlIHVzZXIgdG8gdGhlIHRhcmdldCBwYWdlLlxuICogLSBJbiBhIFJvdXRlIEhhbmRsZXIgb3IgU2VydmVyIEFjdGlvbiwgaXQgd2lsbCBzZXJ2ZSBhIDMwNy8zMDMgdG8gdGhlIGNhbGxlci5cbiAqIC0gSW4gYSBTZXJ2ZXIgQWN0aW9uLCB0eXBlIGRlZmF1bHRzIHRvICdwdXNoJyBhbmQgJ3JlcGxhY2UnIGVsc2V3aGVyZS5cbiAqXG4gKiBSZWFkIG1vcmU6IFtOZXh0LmpzIERvY3M6IGByZWRpcmVjdGBdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9hcGktcmVmZXJlbmNlL2Z1bmN0aW9ucy9yZWRpcmVjdClcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlZGlyZWN0KFxuICAvKiogVGhlIFVSTCB0byByZWRpcmVjdCB0byAqL1xuICB1cmw6IHN0cmluZyxcbiAgdHlwZT86IFJlZGlyZWN0VHlwZVxuKTogbmV2ZXIge1xuICB0eXBlID8/PSBhY3Rpb25Bc3luY1N0b3JhZ2U/LmdldFN0b3JlKCk/LmlzQWN0aW9uXG4gICAgPyBSZWRpcmVjdFR5cGUucHVzaFxuICAgIDogUmVkaXJlY3RUeXBlLnJlcGxhY2VcblxuICB0aHJvdyBnZXRSZWRpcmVjdEVycm9yKHVybCwgdHlwZSwgUmVkaXJlY3RTdGF0dXNDb2RlLlRlbXBvcmFyeVJlZGlyZWN0KVxufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byByZWRpcmVjdCB0aGUgdXNlciB0byBhbm90aGVyIFVSTC4gSXQgY2FuIGJlIHVzZWQgaW5cbiAqIFtTZXJ2ZXIgQ29tcG9uZW50c10oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2J1aWxkaW5nLXlvdXItYXBwbGljYXRpb24vcmVuZGVyaW5nL3NlcnZlci1jb21wb25lbnRzKSxcbiAqIFtSb3V0ZSBIYW5kbGVyc10oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2J1aWxkaW5nLXlvdXItYXBwbGljYXRpb24vcm91dGluZy9yb3V0ZS1oYW5kbGVycyksIGFuZFxuICogW1NlcnZlciBBY3Rpb25zXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYnVpbGRpbmcteW91ci1hcHBsaWNhdGlvbi9kYXRhLWZldGNoaW5nL3NlcnZlci1hY3Rpb25zLWFuZC1tdXRhdGlvbnMpLlxuICpcbiAqIC0gSW4gYSBTZXJ2ZXIgQ29tcG9uZW50LCB0aGlzIHdpbGwgaW5zZXJ0IGEgbWV0YSB0YWcgdG8gcmVkaXJlY3QgdGhlIHVzZXIgdG8gdGhlIHRhcmdldCBwYWdlLlxuICogLSBJbiBhIFJvdXRlIEhhbmRsZXIgb3IgU2VydmVyIEFjdGlvbiwgaXQgd2lsbCBzZXJ2ZSBhIDMwOC8zMDMgdG8gdGhlIGNhbGxlci5cbiAqXG4gKiBSZWFkIG1vcmU6IFtOZXh0LmpzIERvY3M6IGByZWRpcmVjdGBdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9hcGktcmVmZXJlbmNlL2Z1bmN0aW9ucy9yZWRpcmVjdClcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBlcm1hbmVudFJlZGlyZWN0KFxuICAvKiogVGhlIFVSTCB0byByZWRpcmVjdCB0byAqL1xuICB1cmw6IHN0cmluZyxcbiAgdHlwZTogUmVkaXJlY3RUeXBlID0gUmVkaXJlY3RUeXBlLnJlcGxhY2Vcbik6IG5ldmVyIHtcbiAgdGhyb3cgZ2V0UmVkaXJlY3RFcnJvcih1cmwsIHR5cGUsIFJlZGlyZWN0U3RhdHVzQ29kZS5QZXJtYW5lbnRSZWRpcmVjdClcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBlbmNvZGVkIFVSTCBmcm9tIHRoZSBlcnJvciBpZiBpdCdzIGEgUmVkaXJlY3RFcnJvciwgbnVsbFxuICogb3RoZXJ3aXNlLiBOb3RlIHRoYXQgdGhpcyBkb2VzIG5vdCB2YWxpZGF0ZSB0aGUgVVJMIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSBlcnJvciB0aGUgZXJyb3IgdGhhdCBtYXkgYmUgYSByZWRpcmVjdCBlcnJvclxuICogQHJldHVybiB0aGUgdXJsIGlmIHRoZSBlcnJvciB3YXMgYSByZWRpcmVjdCBlcnJvclxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VVJMRnJvbVJlZGlyZWN0RXJyb3IoZXJyb3I6IFJlZGlyZWN0RXJyb3IpOiBzdHJpbmdcbmV4cG9ydCBmdW5jdGlvbiBnZXRVUkxGcm9tUmVkaXJlY3RFcnJvcihlcnJvcjogdW5rbm93bik6IHN0cmluZyB8IG51bGwge1xuICBpZiAoIWlzUmVkaXJlY3RFcnJvcihlcnJvcikpIHJldHVybiBudWxsXG5cbiAgLy8gU2xpY2VzIG9mZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSBkaWdlc3QgdGhhdCBjb250YWlucyB0aGUgY29kZSBhbmQgdGhlXG4gIC8vIHNlcGFyYXRpbmcgJzsnLlxuICByZXR1cm4gZXJyb3IuZGlnZXN0LnNwbGl0KCc7Jykuc2xpY2UoMiwgLTIpLmpvaW4oJzsnKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmVkaXJlY3RUeXBlRnJvbUVycm9yKGVycm9yOiBSZWRpcmVjdEVycm9yKTogUmVkaXJlY3RUeXBlIHtcbiAgaWYgKCFpc1JlZGlyZWN0RXJyb3IoZXJyb3IpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYSByZWRpcmVjdCBlcnJvcicpXG4gIH1cblxuICByZXR1cm4gZXJyb3IuZGlnZXN0LnNwbGl0KCc7JywgMilbMV0gYXMgUmVkaXJlY3RUeXBlXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSZWRpcmVjdFN0YXR1c0NvZGVGcm9tRXJyb3IoZXJyb3I6IFJlZGlyZWN0RXJyb3IpOiBudW1iZXIge1xuICBpZiAoIWlzUmVkaXJlY3RFcnJvcihlcnJvcikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhIHJlZGlyZWN0IGVycm9yJylcbiAgfVxuXG4gIHJldHVybiBOdW1iZXIoZXJyb3IuZGlnZXN0LnNwbGl0KCc7JykuYXQoLTIpKVxufVxuIl0sIm5hbWVzIjpbImdldFJlZGlyZWN0RXJyb3IiLCJnZXRSZWRpcmVjdFN0YXR1c0NvZGVGcm9tRXJyb3IiLCJnZXRSZWRpcmVjdFR5cGVGcm9tRXJyb3IiLCJnZXRVUkxGcm9tUmVkaXJlY3RFcnJvciIsInBlcm1hbmVudFJlZGlyZWN0IiwicmVkaXJlY3QiLCJhY3Rpb25Bc3luY1N0b3JhZ2UiLCJ3aW5kb3ciLCJyZXF1aXJlIiwidW5kZWZpbmVkIiwidXJsIiwidHlwZSIsInN0YXR1c0NvZGUiLCJSZWRpcmVjdFN0YXR1c0NvZGUiLCJUZW1wb3JhcnlSZWRpcmVjdCIsImVycm9yIiwiRXJyb3IiLCJSRURJUkVDVF9FUlJPUl9DT0RFIiwiZGlnZXN0IiwiZ2V0U3RvcmUiLCJpc0FjdGlvbiIsIlJlZGlyZWN0VHlwZSIsInB1c2giLCJyZXBsYWNlIiwiUGVybWFuZW50UmVkaXJlY3QiLCJpc1JlZGlyZWN0RXJyb3IiLCJzcGxpdCIsInNsaWNlIiwiam9pbiIsIk51bWJlciIsImF0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFlZ0JBLGdCQUFnQixFQUFBO2VBQWhCQTs7SUE2RUFDLDhCQUE4QixFQUFBO2VBQTlCQTs7SUFSQUMsd0JBQXdCLEVBQUE7ZUFBeEJBOztJQVJBQyx1QkFBdUIsRUFBQTtlQUF2QkE7O0lBaEJBQyxpQkFBaUIsRUFBQTtlQUFqQkE7O0lBdkJBQyxRQUFRLEVBQUE7ZUFBUkE7OztvQ0FyQ21COytCQU01QjtBQUVQLE1BQU1DLHFCQUNKLE9BQU9DLFdBQVcscUJBRVpDLFFBQVEsMktBQ1JGLGtCQUFrQixHQUNwQkc7QUFFQyxTQUFTVCxpQkFDZFUsR0FBVyxFQUNYQyxJQUFrQixFQUNsQkMsVUFBcUU7SUFBckVBLElBQUFBLGVBQUFBLEtBQUFBLEdBQUFBLGFBQWlDQyxvQkFBQUEsa0JBQWtCLENBQUNDLGlCQUFpQjtJQUVyRSxNQUFNQyxRQUFRLE9BQUEsY0FBOEIsQ0FBOUIsSUFBSUMsTUFBTUMsZUFBQUEsbUJBQW1CLEdBQTdCLHFCQUFBO2VBQUE7b0JBQUE7c0JBQUE7SUFBNkI7SUFDM0NGLE1BQU1HLE1BQU0sR0FBTUQsZUFBQUEsbUJBQW1CLEdBQUMsTUFBR04sT0FBSyxNQUFHRCxNQUFJLE1BQUdFLGFBQVc7SUFDbkUsT0FBT0c7QUFDVDtBQWNPLFNBQVNWLFNBQ2QsMkJBQTJCLEdBQzNCSyxHQUFXLEVBQ1hDLElBQW1CO1FBRVZMO0lBQVRLLFFBQUFBLE9BQUFBLE9BQUFBLE9BQVNMLENBQUFBLHNCQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxDQUFBQSwrQkFBQUEsbUJBQW9CYSxRQUFRLEVBQUEsS0FBQSxPQUFBLEtBQUEsSUFBNUJiLDZCQUFnQ2MsUUFBUSxJQUM3Q0MsZUFBQUEsWUFBWSxDQUFDQyxJQUFJLEdBQ2pCRCxlQUFBQSxZQUFZLENBQUNFLE9BQU87SUFFeEIsTUFBTXZCLGlCQUFpQlUsS0FBS0MsTUFBTUUsb0JBQUFBLGtCQUFrQixDQUFDQyxpQkFBaUI7QUFDeEU7QUFhTyxTQUFTVixrQkFDZCwyQkFBMkIsR0FDM0JNLEdBQVcsRUFDWEMsSUFBeUM7SUFBekNBLElBQUFBLFNBQUFBLEtBQUFBLEdBQUFBLE9BQXFCVSxlQUFBQSxZQUFZLENBQUNFLE9BQU87SUFFekMsTUFBTXZCLGlCQUFpQlUsS0FBS0MsTUFBTUUsb0JBQUFBLGtCQUFrQixDQUFDVyxpQkFBaUI7QUFDeEU7QUFVTyxTQUFTckIsd0JBQXdCWSxLQUFjO0lBQ3BELElBQUksQ0FBQ1UsQ0FBQUEsR0FBQUEsZUFBQUEsZUFBZSxFQUFDVixRQUFRLE9BQU87SUFFcEMsd0VBQXdFO0lBQ3hFLGtCQUFrQjtJQUNsQixPQUFPQSxNQUFNRyxNQUFNLENBQUNRLEtBQUssQ0FBQyxLQUFLQyxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUdDLElBQUksQ0FBQztBQUNuRDtBQUVPLFNBQVMxQix5QkFBeUJhLEtBQW9CO0lBQzNELElBQUksQ0FBQ1UsQ0FBQUEsR0FBQUEsZUFBQUEsZUFBZSxFQUFDVixRQUFRO1FBQzNCLE1BQU0sT0FBQSxjQUFpQyxDQUFqQyxJQUFJQyxNQUFNLHlCQUFWLHFCQUFBO21CQUFBO3dCQUFBOzBCQUFBO1FBQWdDO0lBQ3hDO0lBRUEsT0FBT0QsTUFBTUcsTUFBTSxDQUFDUSxLQUFLLENBQUMsS0FBSyxFQUFFLENBQUMsRUFBRTtBQUN0QztBQUVPLFNBQVN6QiwrQkFBK0JjLEtBQW9CO0lBQ2pFLElBQUksQ0FBQ1UsQ0FBQUEsR0FBQUEsZUFBQUEsZUFBZSxFQUFDVixRQUFRO1FBQzNCLE1BQU0sT0FBQSxjQUFpQyxDQUFqQyxJQUFJQyxNQUFNLHlCQUFWLHFCQUFBO21CQUFBO3dCQUFBOzBCQUFBO1FBQWdDO0lBQ3hDO0lBRUEsT0FBT2EsT0FBT2QsTUFBTUcsTUFBTSxDQUFDUSxLQUFLLENBQUMsS0FBS0ksRUFBRSxDQUFDLENBQUM7QUFDNUMiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMjcwLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2NsaWVudC9jb21wb25lbnRzL2h0dHAtYWNjZXNzLWZhbGxiYWNrL2h0dHAtYWNjZXNzLWZhbGxiYWNrLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBIVFRQQWNjZXNzRXJyb3JTdGF0dXMgPSB7XG4gIE5PVF9GT1VORDogNDA0LFxuICBGT1JCSURERU46IDQwMyxcbiAgVU5BVVRIT1JJWkVEOiA0MDEsXG59XG5cbmNvbnN0IEFMTE9XRURfQ09ERVMgPSBuZXcgU2V0KE9iamVjdC52YWx1ZXMoSFRUUEFjY2Vzc0Vycm9yU3RhdHVzKSlcblxuZXhwb3J0IGNvbnN0IEhUVFBfRVJST1JfRkFMTEJBQ0tfRVJST1JfQ09ERSA9ICdORVhUX0hUVFBfRVJST1JfRkFMTEJBQ0snXG5cbmV4cG9ydCB0eXBlIEhUVFBBY2Nlc3NGYWxsYmFja0Vycm9yID0gRXJyb3IgJiB7XG4gIGRpZ2VzdDogYCR7dHlwZW9mIEhUVFBfRVJST1JfRkFMTEJBQ0tfRVJST1JfQ09ERX07JHtzdHJpbmd9YFxufVxuXG4vKipcbiAqIENoZWNrcyBhbiBlcnJvciB0byBkZXRlcm1pbmUgaWYgaXQncyBhbiBlcnJvciBnZW5lcmF0ZWQgYnlcbiAqIHRoZSBIVFRQIG5hdmlnYXRpb24gQVBJcyBgbm90Rm91bmQoKWAsIGBmb3JiaWRkZW4oKWAgb3IgYHVuYXV0aG9yaXplZCgpYC5cbiAqXG4gKiBAcGFyYW0gZXJyb3IgdGhlIGVycm9yIHRoYXQgbWF5IHJlZmVyZW5jZSBhIEhUVFAgYWNjZXNzIGVycm9yXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBlcnJvciBpcyBhIEhUVFAgYWNjZXNzIGVycm9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0hUVFBBY2Nlc3NGYWxsYmFja0Vycm9yKFxuICBlcnJvcjogdW5rbm93blxuKTogZXJyb3IgaXMgSFRUUEFjY2Vzc0ZhbGxiYWNrRXJyb3Ige1xuICBpZiAoXG4gICAgdHlwZW9mIGVycm9yICE9PSAnb2JqZWN0JyB8fFxuICAgIGVycm9yID09PSBudWxsIHx8XG4gICAgISgnZGlnZXN0JyBpbiBlcnJvcikgfHxcbiAgICB0eXBlb2YgZXJyb3IuZGlnZXN0ICE9PSAnc3RyaW5nJ1xuICApIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBjb25zdCBbcHJlZml4LCBodHRwU3RhdHVzXSA9IGVycm9yLmRpZ2VzdC5zcGxpdCgnOycpXG5cbiAgcmV0dXJuIChcbiAgICBwcmVmaXggPT09IEhUVFBfRVJST1JfRkFMTEJBQ0tfRVJST1JfQ09ERSAmJlxuICAgIEFMTE9XRURfQ09ERVMuaGFzKE51bWJlcihodHRwU3RhdHVzKSlcbiAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWNjZXNzRmFsbGJhY2tIVFRQU3RhdHVzKFxuICBlcnJvcjogSFRUUEFjY2Vzc0ZhbGxiYWNrRXJyb3Jcbik6IG51bWJlciB7XG4gIGNvbnN0IGh0dHBTdGF0dXMgPSBlcnJvci5kaWdlc3Quc3BsaXQoJzsnKVsxXVxuICByZXR1cm4gTnVtYmVyKGh0dHBTdGF0dXMpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRBY2Nlc3NGYWxsYmFja0Vycm9yVHlwZUJ5U3RhdHVzKFxuICBzdGF0dXM6IG51bWJlclxuKTogJ25vdC1mb3VuZCcgfCAnZm9yYmlkZGVuJyB8ICd1bmF1dGhvcml6ZWQnIHwgdW5kZWZpbmVkIHtcbiAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICBjYXNlIDQwMTpcbiAgICAgIHJldHVybiAndW5hdXRob3JpemVkJ1xuICAgIGNhc2UgNDAzOlxuICAgICAgcmV0dXJuICdmb3JiaWRkZW4nXG4gICAgY2FzZSA0MDQ6XG4gICAgICByZXR1cm4gJ25vdC1mb3VuZCdcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJIVFRQQWNjZXNzRXJyb3JTdGF0dXMiLCJIVFRQX0VSUk9SX0ZBTExCQUNLX0VSUk9SX0NPREUiLCJnZXRBY2Nlc3NGYWxsYmFja0Vycm9yVHlwZUJ5U3RhdHVzIiwiZ2V0QWNjZXNzRmFsbGJhY2tIVFRQU3RhdHVzIiwiaXNIVFRQQWNjZXNzRmFsbGJhY2tFcnJvciIsIk5PVF9GT1VORCIsIkZPUkJJRERFTiIsIlVOQVVUSE9SSVpFRCIsIkFMTE9XRURfQ09ERVMiLCJTZXQiLCJPYmplY3QiLCJ2YWx1ZXMiLCJlcnJvciIsImRpZ2VzdCIsInByZWZpeCIsImh0dHBTdGF0dXMiLCJzcGxpdCIsImhhcyIsIk51bWJlciIsInN0YXR1cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFBYUEscUJBQXFCLEVBQUE7ZUFBckJBOztJQVFBQyw4QkFBOEIsRUFBQTtlQUE5QkE7O0lBdUNHQyxrQ0FBa0MsRUFBQTtlQUFsQ0E7O0lBUEFDLDJCQUEyQixFQUFBO2VBQTNCQTs7SUFuQkFDLHlCQUF5QixFQUFBO2VBQXpCQTs7O0FBckJULE1BQU1KLHdCQUF3QjtJQUNuQ0ssV0FBVztJQUNYQyxXQUFXO0lBQ1hDLGNBQWM7QUFDaEI7QUFFQSxNQUFNQyxnQkFBZ0IsSUFBSUMsSUFBSUMsT0FBT0MsTUFBTSxDQUFDWDtBQUVyQyxNQUFNQyxpQ0FBaUM7QUFhdkMsU0FBU0csMEJBQ2RRLEtBQWM7SUFFZCxJQUNFLE9BQU9BLFVBQVUsWUFDakJBLFVBQVUsUUFDVixDQUFFLENBQUEsWUFBWUEsS0FBSSxLQUNsQixPQUFPQSxNQUFNQyxNQUFNLEtBQUssVUFDeEI7UUFDQSxPQUFPO0lBQ1Q7SUFDQSxNQUFNLENBQUNDLFFBQVFDLFdBQVcsR0FBR0gsTUFBTUMsTUFBTSxDQUFDRyxLQUFLLENBQUM7SUFFaEQsT0FDRUYsV0FBV2Isa0NBQ1hPLGNBQWNTLEdBQUcsQ0FBQ0MsT0FBT0g7QUFFN0I7QUFFTyxTQUFTWiw0QkFDZFMsS0FBOEI7SUFFOUIsTUFBTUcsYUFBYUgsTUFBTUMsTUFBTSxDQUFDRyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7SUFDN0MsT0FBT0UsT0FBT0g7QUFDaEI7QUFFTyxTQUFTYixtQ0FDZGlCLE1BQWM7SUFFZCxPQUFRQTtRQUNOLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1lBQ0gsT0FBTztRQUNUO1lBQ0U7SUFDSjtBQUNGIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDM0NiwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvY29tcG9uZW50cy9ub3QtZm91bmQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgSFRUUF9FUlJPUl9GQUxMQkFDS19FUlJPUl9DT0RFLFxuICB0eXBlIEhUVFBBY2Nlc3NGYWxsYmFja0Vycm9yLFxufSBmcm9tICcuL2h0dHAtYWNjZXNzLWZhbGxiYWNrL2h0dHAtYWNjZXNzLWZhbGxiYWNrJ1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byByZW5kZXIgdGhlIFtub3QtZm91bmQuanMgZmlsZV0oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2FwaS1yZWZlcmVuY2UvZmlsZS1jb252ZW50aW9ucy9ub3QtZm91bmQpXG4gKiB3aXRoaW4gYSByb3V0ZSBzZWdtZW50IGFzIHdlbGwgYXMgaW5qZWN0IGEgdGFnLlxuICpcbiAqIGBub3RGb3VuZCgpYCBjYW4gYmUgdXNlZCBpblxuICogW1NlcnZlciBDb21wb25lbnRzXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYnVpbGRpbmcteW91ci1hcHBsaWNhdGlvbi9yZW5kZXJpbmcvc2VydmVyLWNvbXBvbmVudHMpLFxuICogW1JvdXRlIEhhbmRsZXJzXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYnVpbGRpbmcteW91ci1hcHBsaWNhdGlvbi9yb3V0aW5nL3JvdXRlLWhhbmRsZXJzKSwgYW5kXG4gKiBbU2VydmVyIEFjdGlvbnNdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL2RhdGEtZmV0Y2hpbmcvc2VydmVyLWFjdGlvbnMtYW5kLW11dGF0aW9ucykuXG4gKlxuICogLSBJbiBhIFNlcnZlciBDb21wb25lbnQsIHRoaXMgd2lsbCBpbnNlcnQgYSBgPG1ldGEgbmFtZT1cInJvYm90c1wiIGNvbnRlbnQ9XCJub2luZGV4XCIgLz5gIG1ldGEgdGFnIGFuZCBzZXQgdGhlIHN0YXR1cyBjb2RlIHRvIDQwNC5cbiAqIC0gSW4gYSBSb3V0ZSBIYW5kbGVyIG9yIFNlcnZlciBBY3Rpb24sIGl0IHdpbGwgc2VydmUgYSA0MDQgdG8gdGhlIGNhbGxlci5cbiAqXG4gKiBSZWFkIG1vcmU6IFtOZXh0LmpzIERvY3M6IGBub3RGb3VuZGBdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9hcGktcmVmZXJlbmNlL2Z1bmN0aW9ucy9ub3QtZm91bmQpXG4gKi9cblxuY29uc3QgRElHRVNUID0gYCR7SFRUUF9FUlJPUl9GQUxMQkFDS19FUlJPUl9DT0RFfTs0MDRgXG5cbmV4cG9ydCBmdW5jdGlvbiBub3RGb3VuZCgpOiBuZXZlciB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10aHJvdy1saXRlcmFsXG4gIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKERJR0VTVCkgYXMgSFRUUEFjY2Vzc0ZhbGxiYWNrRXJyb3JcbiAgOyhlcnJvciBhcyBIVFRQQWNjZXNzRmFsbGJhY2tFcnJvcikuZGlnZXN0ID0gRElHRVNUXG5cbiAgdGhyb3cgZXJyb3Jcbn1cbiJdLCJuYW1lcyI6WyJub3RGb3VuZCIsIkRJR0VTVCIsIkhUVFBfRVJST1JfRkFMTEJBQ0tfRVJST1JfQ09ERSIsImVycm9yIiwiRXJyb3IiLCJkaWdlc3QiXSwibWFwcGluZ3MiOiI7OzsrQkFzQmdCQSxZQUFBQTs7O2VBQUFBOzs7b0NBbkJUO0FBRVA7Ozs7Ozs7Ozs7Ozs7Q0FhQyxHQUVELE1BQU1DLFNBQVUsS0FBRUMsb0JBQUFBLDhCQUE4QixHQUFDO0FBRTFDLFNBQVNGO0lBQ2QsNENBQTRDO0lBQzVDLE1BQU1HLFFBQVEsT0FBQSxjQUFpQixDQUFqQixJQUFJQyxNQUFNSCxTQUFWLHFCQUFBO2VBQUE7b0JBQUE7c0JBQUE7SUFBZ0I7SUFDNUJFLE1BQWtDRSxNQUFNLEdBQUdKO0lBRTdDLE1BQU1FO0FBQ1IiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMzkzLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2NsaWVudC9jb21wb25lbnRzL2ZvcmJpZGRlbi50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBIVFRQX0VSUk9SX0ZBTExCQUNLX0VSUk9SX0NPREUsXG4gIHR5cGUgSFRUUEFjY2Vzc0ZhbGxiYWNrRXJyb3IsXG59IGZyb20gJy4vaHR0cC1hY2Nlc3MtZmFsbGJhY2svaHR0cC1hY2Nlc3MtZmFsbGJhY2snXG5cbi8vIFRPRE86IEFkZCBgZm9yYmlkZGVuYCBkb2NzXG4vKipcbiAqIEBleHBlcmltZW50YWxcbiAqIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byByZW5kZXIgdGhlIFtmb3JiaWRkZW4uanMgZmlsZV0oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2FwaS1yZWZlcmVuY2UvZmlsZS1jb252ZW50aW9ucy9mb3JiaWRkZW4pXG4gKiB3aXRoaW4gYSByb3V0ZSBzZWdtZW50IGFzIHdlbGwgYXMgaW5qZWN0IGEgdGFnLlxuICpcbiAqIGBmb3JiaWRkZW4oKWAgY2FuIGJlIHVzZWQgaW5cbiAqIFtTZXJ2ZXIgQ29tcG9uZW50c10oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2J1aWxkaW5nLXlvdXItYXBwbGljYXRpb24vcmVuZGVyaW5nL3NlcnZlci1jb21wb25lbnRzKSxcbiAqIFtSb3V0ZSBIYW5kbGVyc10oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2J1aWxkaW5nLXlvdXItYXBwbGljYXRpb24vcm91dGluZy9yb3V0ZS1oYW5kbGVycyksIGFuZFxuICogW1NlcnZlciBBY3Rpb25zXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYnVpbGRpbmcteW91ci1hcHBsaWNhdGlvbi9kYXRhLWZldGNoaW5nL3NlcnZlci1hY3Rpb25zLWFuZC1tdXRhdGlvbnMpLlxuICpcbiAqIFJlYWQgbW9yZTogW05leHQuanMgRG9jczogYGZvcmJpZGRlbmBdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9hcGktcmVmZXJlbmNlL2Z1bmN0aW9ucy9mb3JiaWRkZW4pXG4gKi9cblxuY29uc3QgRElHRVNUID0gYCR7SFRUUF9FUlJPUl9GQUxMQkFDS19FUlJPUl9DT0RFfTs0MDNgXG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JiaWRkZW4oKTogbmV2ZXIge1xuICBpZiAoIXByb2Nlc3MuZW52Ll9fTkVYVF9FWFBFUklNRU5UQUxfQVVUSF9JTlRFUlJVUFRTKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFxcYGZvcmJpZGRlbigpXFxgIGlzIGV4cGVyaW1lbnRhbCBhbmQgb25seSBhbGxvd2VkIHRvIGJlIGVuYWJsZWQgd2hlbiBcXGBleHBlcmltZW50YWwuYXV0aEludGVycnVwdHNcXGAgaXMgZW5hYmxlZC5gXG4gICAgKVxuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRocm93LWxpdGVyYWxcbiAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoRElHRVNUKSBhcyBIVFRQQWNjZXNzRmFsbGJhY2tFcnJvclxuICA7KGVycm9yIGFzIEhUVFBBY2Nlc3NGYWxsYmFja0Vycm9yKS5kaWdlc3QgPSBESUdFU1RcbiAgdGhyb3cgZXJyb3Jcbn1cbiJdLCJuYW1lcyI6WyJmb3JiaWRkZW4iLCJESUdFU1QiLCJIVFRQX0VSUk9SX0ZBTExCQUNLX0VSUk9SX0NPREUiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX0VYUEVSSU1FTlRBTF9BVVRIX0lOVEVSUlVQVFMiLCJFcnJvciIsImVycm9yIiwiZGlnZXN0Il0sIm1hcHBpbmdzIjoiOzs7K0JBcUJnQkEsYUFBQUE7OztlQUFBQTs7O29DQWxCVDtBQUVQLDZCQUE2QjtBQUM3Qjs7Ozs7Ozs7Ozs7Q0FXQyxHQUVELE1BQU1DLFNBQVUsS0FBRUMsb0JBQUFBLDhCQUE4QixHQUFDO0FBRTFDLFNBQVNGO0lBQ2QsSUFBSSxDQUFDRyxRQUFRQyxHQUFHLENBQUNDLHVCQUFxQyxZQUFGO1FBQ2xELE1BQU0sT0FBQSxjQUVMLENBRkssSUFBSUMsTUFDUCxnSEFERyxxQkFBQTttQkFBQTt3QkFBQTswQkFBQTtRQUVOO0lBQ0Y7SUFFQSw0Q0FBNEM7SUFDNUMsTUFBTUMsUUFBUSxPQUFBLGNBQWlCLENBQWpCLElBQUlELE1BQU1MLFNBQVYscUJBQUE7ZUFBQTtvQkFBQTtzQkFBQTtJQUFnQjtJQUM1Qk0sTUFBa0NDLE1BQU0sR0FBR1A7SUFDN0MsTUFBTU07QUFDUiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA0NDYsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvY2xpZW50L2NvbXBvbmVudHMvdW5hdXRob3JpemVkLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEhUVFBfRVJST1JfRkFMTEJBQ0tfRVJST1JfQ09ERSxcbiAgdHlwZSBIVFRQQWNjZXNzRmFsbGJhY2tFcnJvcixcbn0gZnJvbSAnLi9odHRwLWFjY2Vzcy1mYWxsYmFjay9odHRwLWFjY2Vzcy1mYWxsYmFjaydcblxuLy8gVE9ETzogQWRkIGB1bmF1dGhvcml6ZWRgIGRvY3Ncbi8qKlxuICogQGV4cGVyaW1lbnRhbFxuICogVGhpcyBmdW5jdGlvbiBhbGxvd3MgeW91IHRvIHJlbmRlciB0aGUgW3VuYXV0aG9yaXplZC5qcyBmaWxlXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYXBpLXJlZmVyZW5jZS9maWxlLWNvbnZlbnRpb25zL3VuYXV0aG9yaXplZClcbiAqIHdpdGhpbiBhIHJvdXRlIHNlZ21lbnQgYXMgd2VsbCBhcyBpbmplY3QgYSB0YWcuXG4gKlxuICogYHVuYXV0aG9yaXplZCgpYCBjYW4gYmUgdXNlZCBpblxuICogW1NlcnZlciBDb21wb25lbnRzXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYnVpbGRpbmcteW91ci1hcHBsaWNhdGlvbi9yZW5kZXJpbmcvc2VydmVyLWNvbXBvbmVudHMpLFxuICogW1JvdXRlIEhhbmRsZXJzXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYnVpbGRpbmcteW91ci1hcHBsaWNhdGlvbi9yb3V0aW5nL3JvdXRlLWhhbmRsZXJzKSwgYW5kXG4gKiBbU2VydmVyIEFjdGlvbnNdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL2RhdGEtZmV0Y2hpbmcvc2VydmVyLWFjdGlvbnMtYW5kLW11dGF0aW9ucykuXG4gKlxuICpcbiAqIFJlYWQgbW9yZTogW05leHQuanMgRG9jczogYHVuYXV0aG9yaXplZGBdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9hcGktcmVmZXJlbmNlL2Z1bmN0aW9ucy91bmF1dGhvcml6ZWQpXG4gKi9cblxuY29uc3QgRElHRVNUID0gYCR7SFRUUF9FUlJPUl9GQUxMQkFDS19FUlJPUl9DT0RFfTs0MDFgXG5cbmV4cG9ydCBmdW5jdGlvbiB1bmF1dGhvcml6ZWQoKTogbmV2ZXIge1xuICBpZiAoIXByb2Nlc3MuZW52Ll9fTkVYVF9FWFBFUklNRU5UQUxfQVVUSF9JTlRFUlJVUFRTKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFxcYHVuYXV0aG9yaXplZCgpXFxgIGlzIGV4cGVyaW1lbnRhbCBhbmQgb25seSBhbGxvd2VkIHRvIGJlIHVzZWQgd2hlbiBcXGBleHBlcmltZW50YWwuYXV0aEludGVycnVwdHNcXGAgaXMgZW5hYmxlZC5gXG4gICAgKVxuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRocm93LWxpdGVyYWxcbiAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoRElHRVNUKSBhcyBIVFRQQWNjZXNzRmFsbGJhY2tFcnJvclxuICA7KGVycm9yIGFzIEhUVFBBY2Nlc3NGYWxsYmFja0Vycm9yKS5kaWdlc3QgPSBESUdFU1RcbiAgdGhyb3cgZXJyb3Jcbn1cbiJdLCJuYW1lcyI6WyJ1bmF1dGhvcml6ZWQiLCJESUdFU1QiLCJIVFRQX0VSUk9SX0ZBTExCQUNLX0VSUk9SX0NPREUiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX0VYUEVSSU1FTlRBTF9BVVRIX0lOVEVSUlVQVFMiLCJFcnJvciIsImVycm9yIiwiZGlnZXN0Il0sIm1hcHBpbmdzIjoiOzs7K0JBc0JnQkEsZ0JBQUFBOzs7ZUFBQUE7OztvQ0FuQlQ7QUFFUCxnQ0FBZ0M7QUFDaEM7Ozs7Ozs7Ozs7OztDQVlDLEdBRUQsTUFBTUMsU0FBVSxLQUFFQyxvQkFBQUEsOEJBQThCLEdBQUM7QUFFMUMsU0FBU0Y7SUFDZCxJQUFJLENBQUNHLFFBQVFDLEdBQUcsQ0FBQ0MsdUJBQXFDLFlBQUY7UUFDbEQsTUFBTSxPQUFBLGNBRUwsQ0FGSyxJQUFJQyxNQUNQLGdIQURHLHFCQUFBO21CQUFBO3dCQUFBOzBCQUFBO1FBRU47SUFDRjtJQUVBLDRDQUE0QztJQUM1QyxNQUFNQyxRQUFRLE9BQUEsY0FBaUIsQ0FBakIsSUFBSUQsTUFBTUwsU0FBVixxQkFBQTtlQUFBO29CQUFBO3NCQUFBO0lBQWdCO0lBQzVCTSxNQUFrQ0MsTUFBTSxHQUFHUDtJQUM3QyxNQUFNTTtBQUNSIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDUwMCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9zZXJ2ZXIvZHluYW1pYy1yZW5kZXJpbmctdXRpbHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGlzSGFuZ2luZ1Byb21pc2VSZWplY3Rpb25FcnJvcihcbiAgZXJyOiB1bmtub3duXG4pOiBlcnIgaXMgSGFuZ2luZ1Byb21pc2VSZWplY3Rpb25FcnJvciB7XG4gIGlmICh0eXBlb2YgZXJyICE9PSAnb2JqZWN0JyB8fCBlcnIgPT09IG51bGwgfHwgISgnZGlnZXN0JyBpbiBlcnIpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gZXJyLmRpZ2VzdCA9PT0gSEFOR0lOR19QUk9NSVNFX1JFSkVDVElPTlxufVxuXG5jb25zdCBIQU5HSU5HX1BST01JU0VfUkVKRUNUSU9OID0gJ0hBTkdJTkdfUFJPTUlTRV9SRUpFQ1RJT04nXG5cbmNsYXNzIEhhbmdpbmdQcm9taXNlUmVqZWN0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIHB1YmxpYyByZWFkb25seSBkaWdlc3QgPSBIQU5HSU5HX1BST01JU0VfUkVKRUNUSU9OXG5cbiAgY29uc3RydWN0b3IocHVibGljIHJlYWRvbmx5IGV4cHJlc3Npb246IHN0cmluZykge1xuICAgIHN1cGVyKFxuICAgICAgYER1cmluZyBwcmVyZW5kZXJpbmcsICR7ZXhwcmVzc2lvbn0gcmVqZWN0cyB3aGVuIHRoZSBwcmVyZW5kZXIgaXMgY29tcGxldGUuIFR5cGljYWxseSB0aGVzZSBlcnJvcnMgYXJlIGhhbmRsZWQgYnkgUmVhY3QgYnV0IGlmIHlvdSBtb3ZlICR7ZXhwcmVzc2lvbn0gdG8gYSBkaWZmZXJlbnQgY29udGV4dCBieSB1c2luZyBcXGBzZXRUaW1lb3V0XFxgLCBcXGBhZnRlclxcYCwgb3Igc2ltaWxhciBmdW5jdGlvbnMgeW91IG1heSBvYnNlcnZlIHRoaXMgZXJyb3IgYW5kIHlvdSBzaG91bGQgaGFuZGxlIGl0IGluIHRoYXQgY29udGV4dC5gXG4gICAgKVxuICB9XG59XG5cbnR5cGUgQWJvcnRMaXN0ZW5lcnMgPSBBcnJheTwoZXJyOiB1bmtub3duKSA9PiB2b2lkPlxuY29uc3QgYWJvcnRMaXN0ZW5lcnNCeVNpZ25hbCA9IG5ldyBXZWFrTWFwPEFib3J0U2lnbmFsLCBBYm9ydExpc3RlbmVycz4oKVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gY29uc3RydWN0cyBhIHByb21pc2UgdGhhdCB3aWxsIG5ldmVyIHJlc29sdmUuIFRoaXMgaXMgcHJpbWFyaWx5XG4gKiB1c2VmdWwgZm9yIGR5bmFtaWNJTyB3aGVyZSB3ZSB1c2UgcHJvbWlzZSByZXNvbHV0aW9uIHRpbWluZyB0byBkZXRlcm1pbmUgd2hpY2hcbiAqIHBhcnRzIG9mIGEgcmVuZGVyIGNhbiBiZSBpbmNsdWRlZCBpbiBhIHByZXJlbmRlci5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VIYW5naW5nUHJvbWlzZTxUPihcbiAgc2lnbmFsOiBBYm9ydFNpZ25hbCxcbiAgZXhwcmVzc2lvbjogc3RyaW5nXG4pOiBQcm9taXNlPFQ+IHtcbiAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBIYW5naW5nUHJvbWlzZVJlamVjdGlvbkVycm9yKGV4cHJlc3Npb24pKVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGhhbmdpbmdQcm9taXNlID0gbmV3IFByb21pc2U8VD4oKF8sIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgYm91bmRSZWplY3Rpb24gPSByZWplY3QuYmluZChcbiAgICAgICAgbnVsbCxcbiAgICAgICAgbmV3IEhhbmdpbmdQcm9taXNlUmVqZWN0aW9uRXJyb3IoZXhwcmVzc2lvbilcbiAgICAgIClcbiAgICAgIGxldCBjdXJyZW50TGlzdGVuZXJzID0gYWJvcnRMaXN0ZW5lcnNCeVNpZ25hbC5nZXQoc2lnbmFsKVxuICAgICAgaWYgKGN1cnJlbnRMaXN0ZW5lcnMpIHtcbiAgICAgICAgY3VycmVudExpc3RlbmVycy5wdXNoKGJvdW5kUmVqZWN0aW9uKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gW2JvdW5kUmVqZWN0aW9uXVxuICAgICAgICBhYm9ydExpc3RlbmVyc0J5U2lnbmFsLnNldChzaWduYWwsIGxpc3RlbmVycylcbiAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgJ2Fib3J0JyxcbiAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBsaXN0ZW5lcnNbaV0oKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgeyBvbmNlOiB0cnVlIH1cbiAgICAgICAgKVxuICAgICAgfVxuICAgIH0pXG4gICAgLy8gV2UgYXJlIGZpbmUgaWYgbm8gb25lIGFjdHVhbGx5IGF3YWl0cyB0aGlzIHByb21pc2UuIFdlIHNob3VsZG4ndCBjb25zaWRlciB0aGlzIGFuIHVuaGFuZGxlZCByZWplY3Rpb24gc29cbiAgICAvLyB3ZSBhdHRhY2ggYSBub29wIGNhdGNoIGhhbmRsZXIgaGVyZSB0byBzdXBwcmVzcyB0aGlzIHdhcm5pbmcuIElmIHlvdSBhY3R1YWxseSBhd2FpdCBzb21ld2hlcmUgb3IgY29uc3RydWN0XG4gICAgLy8geW91ciBvd24gcHJvbWlzZSBvdXQgb2YgaXQgeW91J2xsIG5lZWQgdG8gZW5zdXJlIHlvdSBoYW5kbGUgdGhlIGVycm9yIHdoZW4gaXQgcmVqZWN0cy5cbiAgICBoYW5naW5nUHJvbWlzZS5jYXRjaChpZ25vcmVSZWplY3QpXG4gICAgcmV0dXJuIGhhbmdpbmdQcm9taXNlXG4gIH1cbn1cblxuZnVuY3Rpb24gaWdub3JlUmVqZWN0KCkge31cbiJdLCJuYW1lcyI6WyJpc0hhbmdpbmdQcm9taXNlUmVqZWN0aW9uRXJyb3IiLCJtYWtlSGFuZ2luZ1Byb21pc2UiLCJlcnIiLCJkaWdlc3QiLCJIQU5HSU5HX1BST01JU0VfUkVKRUNUSU9OIiwiSGFuZ2luZ1Byb21pc2VSZWplY3Rpb25FcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJleHByZXNzaW9uIiwiYWJvcnRMaXN0ZW5lcnNCeVNpZ25hbCIsIldlYWtNYXAiLCJzaWduYWwiLCJhYm9ydGVkIiwiUHJvbWlzZSIsInJlamVjdCIsImhhbmdpbmdQcm9taXNlIiwiXyIsImJvdW5kUmVqZWN0aW9uIiwiYmluZCIsImN1cnJlbnRMaXN0ZW5lcnMiLCJnZXQiLCJwdXNoIiwibGlzdGVuZXJzIiwic2V0IiwiYWRkRXZlbnRMaXN0ZW5lciIsImkiLCJsZW5ndGgiLCJvbmNlIiwiY2F0Y2giLCJpZ25vcmVSZWplY3QiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0lBQWdCQSw4QkFBOEIsRUFBQTtlQUE5QkE7O0lBZ0NBQyxrQkFBa0IsRUFBQTtlQUFsQkE7OztBQWhDVCxTQUFTRCwrQkFDZEUsR0FBWTtJQUVaLElBQUksT0FBT0EsUUFBUSxZQUFZQSxRQUFRLFFBQVEsQ0FBRSxDQUFBLFlBQVlBLEdBQUUsR0FBSTtRQUNqRSxPQUFPO0lBQ1Q7SUFFQSxPQUFPQSxJQUFJQyxNQUFNLEtBQUtDO0FBQ3hCO0FBRUEsTUFBTUEsNEJBQTRCO0FBRWxDLE1BQU1DLHFDQUFxQ0M7SUFHekNDLFlBQTRCQyxVQUFrQixDQUFFO1FBQzlDLEtBQUssQ0FDSCxDQUFDLHFCQUFxQixFQUFFQSxXQUFXLHFHQUFxRyxFQUFFQSxXQUFXLHFKQUFxSixDQUFDLEdBQUEsSUFBQSxDQUZuUkEsVUFBQUEsR0FBQUEsWUFBQUEsSUFBQUEsQ0FGWkwsTUFBQUEsR0FBU0M7SUFNekI7QUFDRjtBQUdBLE1BQU1LLHlCQUF5QixJQUFJQztBQVM1QixTQUFTVCxtQkFDZFUsTUFBbUIsRUFDbkJILFVBQWtCO0lBRWxCLElBQUlHLE9BQU9DLE9BQU8sRUFBRTtRQUNsQixPQUFPQyxRQUFRQyxNQUFNLENBQUMsSUFBSVQsNkJBQTZCRztJQUN6RCxPQUFPO1FBQ0wsTUFBTU8saUJBQWlCLElBQUlGLFFBQVcsQ0FBQ0csR0FBR0Y7WUFDeEMsTUFBTUcsaUJBQWlCSCxPQUFPSSxJQUFJLENBQ2hDLE1BQ0EsSUFBSWIsNkJBQTZCRztZQUVuQyxJQUFJVyxtQkFBbUJWLHVCQUF1QlcsR0FBRyxDQUFDVDtZQUNsRCxJQUFJUSxrQkFBa0I7Z0JBQ3BCQSxpQkFBaUJFLElBQUksQ0FBQ0o7WUFDeEIsT0FBTztnQkFDTCxNQUFNSyxZQUFZO29CQUFDTDtpQkFBZTtnQkFDbENSLHVCQUF1QmMsR0FBRyxDQUFDWixRQUFRVztnQkFDbkNYLE9BQU9hLGdCQUFnQixDQUNyQixTQUNBO29CQUNFLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJSCxVQUFVSSxNQUFNLEVBQUVELElBQUs7d0JBQ3pDSCxTQUFTLENBQUNHLEVBQUU7b0JBQ2Q7Z0JBQ0YsR0FDQTtvQkFBRUUsTUFBTTtnQkFBSztZQUVqQjtRQUNGO1FBQ0EsMkdBQTJHO1FBQzNHLDZHQUE2RztRQUM3Ryx5RkFBeUY7UUFDekZaLGVBQWVhLEtBQUssQ0FBQ0M7UUFDckIsT0FBT2Q7SUFDVDtBQUNGO0FBRUEsU0FBU2MsZ0JBQWdCIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDU3MSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9zZXJ2ZXIvbGliL3JvdXRlci11dGlscy9pcy1wb3N0cG9uZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBSRUFDVF9QT1NUUE9ORV9UWVBFOiBzeW1ib2wgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3N0cG9uZScpXG5cbmV4cG9ydCBmdW5jdGlvbiBpc1Bvc3Rwb25lKGVycm9yOiBhbnkpOiBib29sZWFuIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmXG4gICAgZXJyb3IgIT09IG51bGwgJiZcbiAgICBlcnJvci4kJHR5cGVvZiA9PT0gUkVBQ1RfUE9TVFBPTkVfVFlQRVxuICApXG59XG4iXSwibmFtZXMiOlsiaXNQb3N0cG9uZSIsIlJFQUNUX1BPU1RQT05FX1RZUEUiLCJTeW1ib2wiLCJmb3IiLCJlcnJvciIsIiQkdHlwZW9mIl0sIm1hcHBpbmdzIjoiOzs7K0JBRWdCQSxjQUFBQTs7O2VBQUFBOzs7QUFGaEIsTUFBTUMsc0JBQThCQyxPQUFPQyxHQUFHLENBQUM7QUFFeEMsU0FBU0gsV0FBV0ksS0FBVTtJQUNuQyxPQUNFLE9BQU9BLFVBQVUsWUFDakJBLFVBQVUsUUFDVkEsTUFBTUMsUUFBUSxLQUFLSjtBQUV2QiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA1OTAsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvc2hhcmVkL2xpYi9sYXp5LWR5bmFtaWMvYmFpbG91dC10by1jc3IudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVGhpcyBoYXMgdG8gYmUgYSBzaGFyZWQgbW9kdWxlIHdoaWNoIGlzIHNoYXJlZCBiZXR3ZWVuIGNsaWVudCBjb21wb25lbnQgZXJyb3IgYm91bmRhcnkgYW5kIGR5bmFtaWMgY29tcG9uZW50XG5jb25zdCBCQUlMT1VUX1RPX0NTUiA9ICdCQUlMT1VUX1RPX0NMSUVOVF9TSURFX1JFTkRFUklORydcblxuLyoqIEFuIGVycm9yIHRoYXQgc2hvdWxkIGJlIHRocm93biB3aGVuIHdlIHdhbnQgdG8gYmFpbCBvdXQgdG8gY2xpZW50LXNpZGUgcmVuZGVyaW5nLiAqL1xuZXhwb3J0IGNsYXNzIEJhaWxvdXRUb0NTUkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBwdWJsaWMgcmVhZG9ubHkgZGlnZXN0ID0gQkFJTE9VVF9UT19DU1JcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgcmVhZG9ubHkgcmVhc29uOiBzdHJpbmcpIHtcbiAgICBzdXBlcihgQmFpbCBvdXQgdG8gY2xpZW50LXNpZGUgcmVuZGVyaW5nOiAke3JlYXNvbn1gKVxuICB9XG59XG5cbi8qKiBDaGVja3MgaWYgYSBwYXNzZWQgYXJndW1lbnQgaXMgYW4gZXJyb3IgdGhhdCBpcyB0aHJvd24gaWYgd2Ugd2FudCB0byBiYWlsIG91dCB0byBjbGllbnQtc2lkZSByZW5kZXJpbmcuICovXG5leHBvcnQgZnVuY3Rpb24gaXNCYWlsb3V0VG9DU1JFcnJvcihlcnI6IHVua25vd24pOiBlcnIgaXMgQmFpbG91dFRvQ1NSRXJyb3Ige1xuICBpZiAodHlwZW9mIGVyciAhPT0gJ29iamVjdCcgfHwgZXJyID09PSBudWxsIHx8ICEoJ2RpZ2VzdCcgaW4gZXJyKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIGVyci5kaWdlc3QgPT09IEJBSUxPVVRfVE9fQ1NSXG59XG4iXSwibmFtZXMiOlsiQmFpbG91dFRvQ1NSRXJyb3IiLCJpc0JhaWxvdXRUb0NTUkVycm9yIiwiQkFJTE9VVF9UT19DU1IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwicmVhc29uIiwiZGlnZXN0IiwiZXJyIl0sIm1hcHBpbmdzIjoiQUFBQSwrR0FBK0c7Ozs7Ozs7Ozs7Ozs7OztJQUlsR0EsaUJBQWlCLEVBQUE7ZUFBakJBOztJQVNHQyxtQkFBbUIsRUFBQTtlQUFuQkE7OztBQVpoQixNQUFNQyxpQkFBaUI7QUFHaEIsTUFBTUYsMEJBQTBCRztJQUdyQ0MsWUFBNEJDLE1BQWMsQ0FBRTtRQUMxQyxLQUFLLENBQUUsd0NBQXFDQSxTQUFBQSxJQUFBQSxDQURsQkEsTUFBQUEsR0FBQUEsUUFBQUEsSUFBQUEsQ0FGWkMsTUFBQUEsR0FBU0o7SUFJekI7QUFDRjtBQUdPLFNBQVNELG9CQUFvQk0sR0FBWTtJQUM5QyxJQUFJLE9BQU9BLFFBQVEsWUFBWUEsUUFBUSxRQUFRLENBQUUsQ0FBQSxZQUFZQSxHQUFFLEdBQUk7UUFDakUsT0FBTztJQUNUO0lBRUEsT0FBT0EsSUFBSUQsTUFBTSxLQUFLSjtBQUN4QiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA2MzAsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvY2xpZW50L2NvbXBvbmVudHMvaXMtbmV4dC1yb3V0ZXItZXJyb3IudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgaXNIVFRQQWNjZXNzRmFsbGJhY2tFcnJvcixcbiAgdHlwZSBIVFRQQWNjZXNzRmFsbGJhY2tFcnJvcixcbn0gZnJvbSAnLi9odHRwLWFjY2Vzcy1mYWxsYmFjay9odHRwLWFjY2Vzcy1mYWxsYmFjaydcbmltcG9ydCB7IGlzUmVkaXJlY3RFcnJvciwgdHlwZSBSZWRpcmVjdEVycm9yIH0gZnJvbSAnLi9yZWRpcmVjdC1lcnJvcidcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGVycm9yIGlzIGEgbmF2aWdhdGlvbiBzaWduYWwgZXJyb3IuIFRoZXNlIGVycm9ycyBhcmVcbiAqIHRocm93biBieSB1c2VyIGNvZGUgdG8gcGVyZm9ybSBuYXZpZ2F0aW9uIG9wZXJhdGlvbnMgYW5kIGludGVycnVwdCB0aGUgUmVhY3RcbiAqIHJlbmRlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTmV4dFJvdXRlckVycm9yKFxuICBlcnJvcjogdW5rbm93blxuKTogZXJyb3IgaXMgUmVkaXJlY3RFcnJvciB8IEhUVFBBY2Nlc3NGYWxsYmFja0Vycm9yIHtcbiAgcmV0dXJuIGlzUmVkaXJlY3RFcnJvcihlcnJvcikgfHwgaXNIVFRQQWNjZXNzRmFsbGJhY2tFcnJvcihlcnJvcilcbn1cbiJdLCJuYW1lcyI6WyJpc05leHRSb3V0ZXJFcnJvciIsImVycm9yIiwiaXNSZWRpcmVjdEVycm9yIiwiaXNIVFRQQWNjZXNzRmFsbGJhY2tFcnJvciJdLCJtYXBwaW5ncyI6Ijs7OytCQVdnQkEscUJBQUFBOzs7ZUFBQUE7OztvQ0FSVDsrQkFDNkM7QUFPN0MsU0FBU0Esa0JBQ2RDLEtBQWM7SUFFZCxPQUFPQyxDQUFBQSxHQUFBQSxlQUFBQSxlQUFlLEVBQUNELFVBQVVFLENBQUFBLEdBQUFBLG9CQUFBQSx5QkFBeUIsRUFBQ0Y7QUFDN0QiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNjU3LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2NsaWVudC9jb21wb25lbnRzL2hvb2tzLXNlcnZlci1jb250ZXh0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IERZTkFNSUNfRVJST1JfQ09ERSA9ICdEWU5BTUlDX1NFUlZFUl9VU0FHRSdcblxuZXhwb3J0IGNsYXNzIER5bmFtaWNTZXJ2ZXJFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgZGlnZXN0OiB0eXBlb2YgRFlOQU1JQ19FUlJPUl9DT0RFID0gRFlOQU1JQ19FUlJPUl9DT0RFXG5cbiAgY29uc3RydWN0b3IocHVibGljIHJlYWRvbmx5IGRlc2NyaXB0aW9uOiBzdHJpbmcpIHtcbiAgICBzdXBlcihgRHluYW1pYyBzZXJ2ZXIgdXNhZ2U6ICR7ZGVzY3JpcHRpb259YClcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNEeW5hbWljU2VydmVyRXJyb3IoZXJyOiB1bmtub3duKTogZXJyIGlzIER5bmFtaWNTZXJ2ZXJFcnJvciB7XG4gIGlmIChcbiAgICB0eXBlb2YgZXJyICE9PSAnb2JqZWN0JyB8fFxuICAgIGVyciA9PT0gbnVsbCB8fFxuICAgICEoJ2RpZ2VzdCcgaW4gZXJyKSB8fFxuICAgIHR5cGVvZiBlcnIuZGlnZXN0ICE9PSAnc3RyaW5nJ1xuICApIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiBlcnIuZGlnZXN0ID09PSBEWU5BTUlDX0VSUk9SX0NPREVcbn1cbiJdLCJuYW1lcyI6WyJEeW5hbWljU2VydmVyRXJyb3IiLCJpc0R5bmFtaWNTZXJ2ZXJFcnJvciIsIkRZTkFNSUNfRVJST1JfQ09ERSIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJkZXNjcmlwdGlvbiIsImRpZ2VzdCIsImVyciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7SUFFYUEsa0JBQWtCLEVBQUE7ZUFBbEJBOztJQVFHQyxvQkFBb0IsRUFBQTtlQUFwQkE7OztBQVZoQixNQUFNQyxxQkFBcUI7QUFFcEIsTUFBTUYsMkJBQTJCRztJQUd0Q0MsWUFBNEJDLFdBQW1CLENBQUU7UUFDL0MsS0FBSyxDQUFFLDJCQUF3QkEsY0FBQUEsSUFBQUEsQ0FETEEsV0FBQUEsR0FBQUEsYUFBQUEsSUFBQUEsQ0FGNUJDLE1BQUFBLEdBQW9DSjtJQUlwQztBQUNGO0FBRU8sU0FBU0QscUJBQXFCTSxHQUFZO0lBQy9DLElBQ0UsT0FBT0EsUUFBUSxZQUNmQSxRQUFRLFFBQ1IsQ0FBRSxDQUFBLFlBQVlBLEdBQUUsS0FDaEIsT0FBT0EsSUFBSUQsTUFBTSxLQUFLLFVBQ3RCO1FBQ0EsT0FBTztJQUNUO0lBRUEsT0FBT0MsSUFBSUQsTUFBTSxLQUFLSjtBQUN4QiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA3MDMsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvY2xpZW50L2NvbXBvbmVudHMvc3RhdGljLWdlbmVyYXRpb24tYmFpbG91dC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBORVhUX1NUQVRJQ19HRU5fQkFJTE9VVCA9ICdORVhUX1NUQVRJQ19HRU5fQkFJTE9VVCdcblxuZXhwb3J0IGNsYXNzIFN0YXRpY0dlbkJhaWxvdXRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgcHVibGljIHJlYWRvbmx5IGNvZGUgPSBORVhUX1NUQVRJQ19HRU5fQkFJTE9VVFxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNTdGF0aWNHZW5CYWlsb3V0RXJyb3IoXG4gIGVycm9yOiB1bmtub3duXG4pOiBlcnJvciBpcyBTdGF0aWNHZW5CYWlsb3V0RXJyb3Ige1xuICBpZiAodHlwZW9mIGVycm9yICE9PSAnb2JqZWN0JyB8fCBlcnJvciA9PT0gbnVsbCB8fCAhKCdjb2RlJyBpbiBlcnJvcikpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiBlcnJvci5jb2RlID09PSBORVhUX1NUQVRJQ19HRU5fQkFJTE9VVFxufVxuIl0sIm5hbWVzIjpbIlN0YXRpY0dlbkJhaWxvdXRFcnJvciIsImlzU3RhdGljR2VuQmFpbG91dEVycm9yIiwiTkVYVF9TVEFUSUNfR0VOX0JBSUxPVVQiLCJFcnJvciIsImNvZGUiLCJlcnJvciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7SUFFYUEscUJBQXFCLEVBQUE7ZUFBckJBOztJQUlHQyx1QkFBdUIsRUFBQTtlQUF2QkE7OztBQU5oQixNQUFNQywwQkFBMEI7QUFFekIsTUFBTUYsOEJBQThCRzs7UUFBcEMsS0FBQSxJQUFBLE9BQUEsSUFBQSxDQUNXQyxJQUFBQSxHQUFPRjs7QUFDekI7QUFFTyxTQUFTRCx3QkFDZEksS0FBYztJQUVkLElBQUksT0FBT0EsVUFBVSxZQUFZQSxVQUFVLFFBQVEsQ0FBRSxDQUFBLFVBQVVBLEtBQUksR0FBSTtRQUNyRSxPQUFPO0lBQ1Q7SUFFQSxPQUFPQSxNQUFNRCxJQUFJLEtBQUtGO0FBQ3hCIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDc0OSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9saWIvbWV0YWRhdGEvbWV0YWRhdGEtY29uc3RhbnRzLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgTUVUQURBVEFfQk9VTkRBUllfTkFNRSA9ICdfX25leHRfbWV0YWRhdGFfYm91bmRhcnlfXydcbmV4cG9ydCBjb25zdCBWSUVXUE9SVF9CT1VOREFSWV9OQU1FID0gJ19fbmV4dF92aWV3cG9ydF9ib3VuZGFyeV9fJ1xuZXhwb3J0IGNvbnN0IE9VVExFVF9CT1VOREFSWV9OQU1FID0gJ19fbmV4dF9vdXRsZXRfYm91bmRhcnlfXydcbiJdLCJuYW1lcyI6WyJNRVRBREFUQV9CT1VOREFSWV9OQU1FIiwiT1VUTEVUX0JPVU5EQVJZX05BTUUiLCJWSUVXUE9SVF9CT1VOREFSWV9OQU1FIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7SUFBYUEsc0JBQXNCLEVBQUE7ZUFBdEJBOztJQUVBQyxvQkFBb0IsRUFBQTtlQUFwQkE7O0lBREFDLHNCQUFzQixFQUFBO2VBQXRCQTs7O0FBRE4sTUFBTUYseUJBQXlCO0FBQy9CLE1BQU1FLHlCQUF5QjtBQUMvQixNQUFNRCx1QkFBdUIiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNzgzLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2xpYi9zY2hlZHVsZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHR5cGUgU2NoZWR1bGVkRm48VCA9IHZvaWQ+ID0gKCkgPT4gVCB8IFByb21pc2VMaWtlPFQ+XG5leHBvcnQgdHlwZSBTY2hlZHVsZXJGbjxUID0gdm9pZD4gPSAoY2I6IFNjaGVkdWxlZEZuPFQ+KSA9PiB2b2lkXG5cbi8qKlxuICogU2NoZWR1bGVzIGEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIHRoZSBuZXh0IHRpY2sgYWZ0ZXIgdGhlIG90aGVyIHByb21pc2VzXG4gKiBoYXZlIGJlZW4gcmVzb2x2ZWQuXG4gKlxuICogQHBhcmFtIGNiIHRoZSBmdW5jdGlvbiB0byBzY2hlZHVsZVxuICovXG5leHBvcnQgY29uc3Qgc2NoZWR1bGVPbk5leHRUaWNrID0gKGNiOiBTY2hlZHVsZWRGbjx2b2lkPikgPT4ge1xuICAvLyBXZSB1c2UgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigpIGhlcmUgc28gdGhhdCB0aGUgb3BlcmF0aW9uIGlzIHNjaGVkdWxlZCBhdFxuICAvLyB0aGUgZW5kIG9mIHRoZSBwcm9taXNlIGpvYiBxdWV1ZSwgd2UgdGhlbiBhZGQgaXQgdG8gdGhlIG5leHQgcHJvY2VzcyB0aWNrXG4gIC8vIHRvIGVuc3VyZSBpdCdzIGV2YWx1YXRlZCBhZnRlcndhcmRzLlxuICAvL1xuICAvLyBUaGlzIHdhcyBpbnNwaXJlZCBieSB0aGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIERhdGFMb2FkZXIgaW50ZXJmYWNlOiBodHRwczovL2dpdGh1Yi5jb20vZ3JhcGhxbC9kYXRhbG9hZGVyL2Jsb2IvZDMzNmJkMTUyODI2NjRlMGJlNGI0YTY1N2NiNzk2ZjA5YmFmYmM2Yi9zcmMvaW5kZXguanMjTDIxMy1MMjU1XG4gIC8vXG4gIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgIGlmIChwcm9jZXNzLmVudi5ORVhUX1JVTlRJTUUgPT09ICdlZGdlJykge1xuICAgICAgc2V0VGltZW91dChjYiwgMClcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjYilcbiAgICB9XG4gIH0pXG59XG5cbi8qKlxuICogU2NoZWR1bGVzIGEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHVzaW5nIGBzZXRJbW1lZGlhdGVgIG9yIGBzZXRUaW1lb3V0YCBpZlxuICogYHNldEltbWVkaWF0ZWAgaXMgbm90IGF2YWlsYWJsZSAobGlrZSBpbiB0aGUgRWRnZSBydW50aW1lKS5cbiAqXG4gKiBAcGFyYW0gY2IgdGhlIGZ1bmN0aW9uIHRvIHNjaGVkdWxlXG4gKi9cbmV4cG9ydCBjb25zdCBzY2hlZHVsZUltbWVkaWF0ZSA9IChjYjogU2NoZWR1bGVkRm48dm9pZD4pOiB2b2lkID0+IHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5FWFRfUlVOVElNRSA9PT0gJ2VkZ2UnKSB7XG4gICAgc2V0VGltZW91dChjYiwgMClcbiAgfSBlbHNlIHtcbiAgICBzZXRJbW1lZGlhdGUoY2IpXG4gIH1cbn1cblxuLyoqXG4gKiByZXR1cm5zIGEgcHJvbWlzZSB0aGFuIHJlc29sdmVzIGluIGEgZnV0dXJlIHRhc2suIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IHRoZSB0YXNrIGl0IHJlc29sdmVzIGluXG4gKiB3aWxsIGJlIHRoZSBuZXh0IHRhc2sgYnV0IGlmIHlvdSBhd2FpdCBpdCB5b3UgY2FuIGF0IGxlYXN0IGJlIHN1cmUgdGhhdCB0aGUgY3VycmVudCB0YXNrIGlzIG92ZXIgYW5kXG4gKiBtb3N0IHVzZWZ1bGx5IHRoYXQgdGhlIGVudGlyZSBtaWNyb3Rhc2sgcXVldWUgb2YgdGhlIGN1cnJlbnQgdGFzayBoYXMgYmVlbiBlbXB0aWVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXRMZWFzdE9uZVRhc2soKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSkgPT4gc2NoZWR1bGVJbW1lZGlhdGUocmVzb2x2ZSkpXG59XG5cbi8qKlxuICogVGhpcyB1dGlsaXR5IGZ1bmN0aW9uIGlzIGV4dHJhY3RlZCB0byBtYWtlIGl0IGVhc2llciB0byBmaW5kIHBsYWNlcyB3aGVyZSB3ZSBhcmUgZG9pbmdcbiAqIHNwZWNpZmljIHRpbWluZyB0cmlja3MgdG8gdHJ5IHRvIHNjaGVkdWxlIHdvcmsgYWZ0ZXIgUmVhY3QgaGFzIHJlbmRlcmVkLiBUaGlzIGlzIGVzcGVjaWFsbHlcbiAqIGltcG9ydGFudCBhdCB0aGUgbW9tZW50IGJlY2F1c2UgTmV4dC5qcyB1c2VzIHRoZSBlZGdlIGJ1aWxkcyBvZiBSZWFjdCB3aGljaCB1c2Ugc2V0VGltZW91dCB0b1xuICogc2NoZWR1bGUgd29yayB3aGVuIHlvdSBtaWdodCBleHBlY3QgdGhhdCBzb21ldGhpbmcgbGlrZSBzZXRJbW1lZGlhdGUgd291bGQgZG8gdGhlIHRyaWNrLlxuICpcbiAqIExvbmcgdGVybSB3ZSBzaG91bGQgc3dpdGNoIHRvIHRoZSBub2RlIHZlcnNpb25zIG9mIFJlYWN0IHJlbmRlcmluZyB3aGVuIHBvc3NpYmxlIGFuZCB0aGVuXG4gKiB1cGRhdGUgdGhpcyB0byB1c2Ugc2V0SW1tZWRpYXRlIHJhdGhlciB0aGFuIHNldFRpbWVvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdhaXRBdExlYXN0T25lUmVhY3RSZW5kZXJUYXNrKCk6IFByb21pc2U8dm9pZD4ge1xuICBpZiAocHJvY2Vzcy5lbnYuTkVYVF9SVU5USU1FID09PSAnZWRnZScpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHIpID0+IHNldFRpbWVvdXQociwgMCkpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyKSA9PiBzZXRJbW1lZGlhdGUocikpXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJhdExlYXN0T25lVGFzayIsInNjaGVkdWxlSW1tZWRpYXRlIiwic2NoZWR1bGVPbk5leHRUaWNrIiwid2FpdEF0TGVhc3RPbmVSZWFjdFJlbmRlclRhc2siLCJjYiIsIlByb21pc2UiLCJyZXNvbHZlIiwidGhlbiIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1JVTlRJTUUiLCJzZXRUaW1lb3V0IiwibmV4dFRpY2siLCJzZXRJbW1lZGlhdGUiLCJyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0lBNENnQkEsY0FBYyxFQUFBO2VBQWRBOztJQWJIQyxpQkFBaUIsRUFBQTtlQUFqQkE7O0lBdEJBQyxrQkFBa0IsRUFBQTtlQUFsQkE7O0lBZ0RHQyw2QkFBNkIsRUFBQTtlQUE3QkE7OztBQWhEVCxNQUFNRCxxQkFBcUIsQ0FBQ0U7SUFDakMsNkVBQTZFO0lBQzdFLDRFQUE0RTtJQUM1RSx1Q0FBdUM7SUFDdkMsRUFBRTtJQUNGLGtMQUFrTDtJQUNsTCxFQUFFO0lBQ0ZDLFFBQVFDLE9BQU8sR0FBR0MsSUFBSSxDQUFDO1FBQ3JCLElBQUlDLFFBQVFDLEdBQUcsQ0FBQ0MsWUFBWSxLQUFLLFFBQVE7O2FBRWxDO1lBQ0xGLFFBQVFJLFFBQVEsQ0FBQ1I7UUFDbkI7SUFDRjtBQUNGO0FBUU8sTUFBTUgsb0JBQW9CLENBQUNHO0lBQ2hDLElBQUlJLFFBQVFDLEdBQUcsQ0FBQ0MsWUFBWSxLQUFLLFFBQVE7O1NBRWxDO1FBQ0xHLGFBQWFUO0lBQ2Y7QUFDRjtBQU9PLFNBQVNKO0lBQ2QsT0FBTyxJQUFJSyxRQUFjLENBQUNDLFVBQVlMLGtCQUFrQks7QUFDMUQ7QUFXTyxTQUFTSDtJQUNkLElBQUlLLFFBQVFDLEdBQUcsQ0FBQ0MsWUFBWSxLQUFLLFFBQVE7O1NBRWxDO1FBQ0wsT0FBTyxJQUFJTCxRQUFRLENBQUNTLElBQU1ELGFBQWFDO0lBQ3pDO0FBQ0YiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogODUwLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL3NlcnZlci9hcHAtcmVuZGVyL2R5bmFtaWMtcmVuZGVyaW5nLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGhlIGZ1bmN0aW9ucyBwcm92aWRlZCBieSB0aGlzIG1vZHVsZSBhcmUgdXNlZCB0byBjb21tdW5pY2F0ZSBjZXJ0YWluIHByb3BlcnRpZXNcbiAqIGFib3V0IHRoZSBjdXJyZW50bHkgcnVubmluZyBjb2RlIHNvIHRoYXQgTmV4dC5qcyBjYW4gbWFrZSBkZWNpc2lvbnMgb24gaG93IHRvIGhhbmRsZVxuICogdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGluIGRpZmZlcmVudCByZW5kZXJpbmcgbW9kZXMgc3VjaCBhcyBwcmUtcmVuZGVyaW5nLCByZXN1bWluZywgYW5kIFNTUi5cbiAqXG4gKiBUb2RheSBOZXh0LmpzIHRyZWF0cyBhbGwgY29kZSBhcyBwb3RlbnRpYWxseSBzdGF0aWMuIENlcnRhaW4gQVBJcyBtYXkgb25seSBtYWtlIHNlbnNlIHdoZW4gZHluYW1pY2FsbHkgcmVuZGVyaW5nLlxuICogVHJhZGl0aW9uYWxseSB0aGlzIG1lYW50IGRlb3B0aW5nIHRoZSBlbnRpcmUgcmVuZGVyIHRvIGR5bmFtaWMgaG93ZXZlciB3aXRoIFBQUiB3ZSBjYW4gbm93IGRlb3B0IHBhcnRzXG4gKiBvZiBhIFJlYWN0IHRyZWUgYXMgZHluYW1pYyB3aGlsZSBzdGlsbCBrZWVwaW5nIG90aGVyIHBhcnRzIHN0YXRpYy4gVGhlcmUgYXJlIHJlYWxseSB0d28gZGlmZmVyZW50IGtpbmRzIG9mXG4gKiBEeW5hbWljIGluZGljYXRpb25zLlxuICpcbiAqIFRoZSBmaXJzdCBpcyBzaW1wbHkgYW4gaW50ZW50aW9uIHRvIGJlIGR5bmFtaWMuIHVuc3RhYmxlX25vU3RvcmUgaXMgYW4gZXhhbXBsZSBvZiB0aGlzIHdoZXJlXG4gKiB0aGUgY3VycmVudGx5IGV4ZWN1dGluZyBjb2RlIHNpbXBseSBkZWNsYXJlcyB0aGF0IHRoZSBjdXJyZW50IHNjb3BlIGlzIGR5bmFtaWMgYnV0IGlmIHlvdSB1c2UgaXRcbiAqIGluc2lkZSB1bnN0YWJsZV9jYWNoZSBpdCBjYW4gc3RpbGwgYmUgY2FjaGVkLiBUaGlzIHR5cGUgb2YgaW5kaWNhdGlvbiBjYW4gYmUgcmVtb3ZlZCBpZiB3ZSBldmVyXG4gKiBtYWtlIHRoZSBkZWZhdWx0IGR5bmFtaWMgdG8gYmVnaW4gd2l0aCBiZWNhdXNlIHRoZSBvbmx5IHdheSB5b3Ugd291bGQgZXZlciBiZSBzdGF0aWMgaXMgaW5zaWRlXG4gKiBhIGNhY2hlIHNjb3BlIHdoaWNoIHRoaXMgaW5kaWNhdGlvbiBkb2VzIG5vdCBhZmZlY3QuXG4gKlxuICogVGhlIHNlY29uZCBpcyBhbiBpbmRpY2F0aW9uIHRoYXQgYSBkeW5hbWljIGRhdGEgc291cmNlIHdhcyByZWFkLiBUaGlzIGlzIGEgc3Ryb25nZXIgZm9ybSBvZiBkeW5hbWljXG4gKiBiZWNhdXNlIGl0IG1lYW5zIHRoYXQgaXQgaXMgaW5hcHByb3ByaWF0ZSB0byBjYWNoZSB0aGlzIGF0IGFsbC4gdXNpbmcgYSBkeW5hbWljIGRhdGEgc291cmNlIGluc2lkZVxuICogdW5zdGFibGVfY2FjaGUgc2hvdWxkIGVycm9yLiBJZiB5b3Ugd2FudCB0byB1c2Ugc29tZSBkeW5hbWljIGRhdGEgaW5zaWRlIHVuc3RhYmxlX2NhY2hlIHlvdSBzaG91bGRcbiAqIHJlYWQgdGhhdCBkYXRhIG91dHNpZGUgdGhlIGNhY2hlIGFuZCBwYXNzIGl0IGluIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSBjYWNoZWQgZnVuY3Rpb24uXG4gKi9cblxuaW1wb3J0IHR5cGUgeyBXb3JrU3RvcmUgfSBmcm9tICcuLi9hcHAtcmVuZGVyL3dvcmstYXN5bmMtc3RvcmFnZS5leHRlcm5hbCdcbmltcG9ydCB0eXBlIHtcbiAgV29ya1VuaXRTdG9yZSxcbiAgUmVxdWVzdFN0b3JlLFxuICBQcmVyZW5kZXJTdG9yZUxlZ2FjeSxcbiAgUHJlcmVuZGVyU3RvcmVNb2Rlcm4sXG59IGZyb20gJy4uL2FwcC1yZW5kZXIvd29yay11bml0LWFzeW5jLXN0b3JhZ2UuZXh0ZXJuYWwnXG5cbi8vIE9uY2UgcG9zdHBvbmUgaXMgaW4gc3RhYmxlIHdlIHNob3VsZCBzd2l0Y2ggdG8gaW1wb3J0aW5nIHRoZSBwb3N0cG9uZSBleHBvcnQgZGlyZWN0bHlcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcblxuaW1wb3J0IHsgRHluYW1pY1NlcnZlckVycm9yIH0gZnJvbSAnLi4vLi4vY2xpZW50L2NvbXBvbmVudHMvaG9va3Mtc2VydmVyLWNvbnRleHQnXG5pbXBvcnQgeyBTdGF0aWNHZW5CYWlsb3V0RXJyb3IgfSBmcm9tICcuLi8uLi9jbGllbnQvY29tcG9uZW50cy9zdGF0aWMtZ2VuZXJhdGlvbi1iYWlsb3V0J1xuaW1wb3J0IHsgd29ya1VuaXRBc3luY1N0b3JhZ2UgfSBmcm9tICcuL3dvcmstdW5pdC1hc3luYy1zdG9yYWdlLmV4dGVybmFsJ1xuaW1wb3J0IHsgd29ya0FzeW5jU3RvcmFnZSB9IGZyb20gJy4uL2FwcC1yZW5kZXIvd29yay1hc3luYy1zdG9yYWdlLmV4dGVybmFsJ1xuaW1wb3J0IHsgbWFrZUhhbmdpbmdQcm9taXNlIH0gZnJvbSAnLi4vZHluYW1pYy1yZW5kZXJpbmctdXRpbHMnXG5pbXBvcnQge1xuICBNRVRBREFUQV9CT1VOREFSWV9OQU1FLFxuICBWSUVXUE9SVF9CT1VOREFSWV9OQU1FLFxuICBPVVRMRVRfQk9VTkRBUllfTkFNRSxcbn0gZnJvbSAnLi4vLi4vbGliL21ldGFkYXRhL21ldGFkYXRhLWNvbnN0YW50cydcbmltcG9ydCB7IHNjaGVkdWxlT25OZXh0VGljayB9IGZyb20gJy4uLy4uL2xpYi9zY2hlZHVsZXInXG5cbmNvbnN0IGhhc1Bvc3Rwb25lID0gdHlwZW9mIFJlYWN0LnVuc3RhYmxlX3Bvc3Rwb25lID09PSAnZnVuY3Rpb24nXG5cbmV4cG9ydCB0eXBlIER5bmFtaWNBY2Nlc3MgPSB7XG4gIC8qKlxuICAgKiBJZiBkZWJ1Z2dpbmcsIHRoaXMgd2lsbCBjb250YWluIHRoZSBzdGFjayB0cmFjZSBvZiB3aGVyZSB0aGUgZHluYW1pYyBhY2Nlc3NcbiAgICogb2NjdXJyZWQuIFRoaXMgaXMgdXNlZCB0byBwcm92aWRlIG1vcmUgaW5mb3JtYXRpb24gdG8gdGhlIHVzZXIgYWJvdXQgd2h5XG4gICAqIHRoZWlyIHBhZ2UgaXMgYmVpbmcgcmVuZGVyZWQgZHluYW1pY2FsbHkuXG4gICAqL1xuICBzdGFjaz86IHN0cmluZ1xuXG4gIC8qKlxuICAgKiBUaGUgZXhwcmVzc2lvbiB0aGF0IHdhcyBhY2Nlc3NlZCBkeW5hbWljYWxseS5cbiAgICovXG4gIGV4cHJlc3Npb246IHN0cmluZ1xufVxuXG4vLyBTdG9yZXMgZHluYW1pYyByZWFzb25zIHVzZWQgZHVyaW5nIGFuIFJTQyByZW5kZXIuXG5leHBvcnQgdHlwZSBEeW5hbWljVHJhY2tpbmdTdGF0ZSA9IHtcbiAgLyoqXG4gICAqIFdoZW4gdHJ1ZSwgc3RhY2sgaW5mb3JtYXRpb24gd2lsbCBhbHNvIGJlIHRyYWNrZWQgZHVyaW5nIGR5bmFtaWMgYWNjZXNzLlxuICAgKi9cbiAgcmVhZG9ubHkgaXNEZWJ1Z0R5bmFtaWNBY2Nlc3NlczogYm9vbGVhbiB8IHVuZGVmaW5lZFxuXG4gIC8qKlxuICAgKiBUaGUgZHluYW1pYyBhY2Nlc3NlcyB0aGF0IG9jY3VycmVkIGR1cmluZyB0aGUgcmVuZGVyLlxuICAgKi9cbiAgcmVhZG9ubHkgZHluYW1pY0FjY2Vzc2VzOiBBcnJheTxEeW5hbWljQWNjZXNzPlxuXG4gIHN5bmNEeW5hbWljRXJyb3JXaXRoU3RhY2s6IG51bGwgfCBFcnJvclxufVxuXG4vLyBTdG9yZXMgZHluYW1pYyByZWFzb25zIHVzZWQgZHVyaW5nIGFuIFNTUiByZW5kZXIuXG5leHBvcnQgdHlwZSBEeW5hbWljVmFsaWRhdGlvblN0YXRlID0ge1xuICBoYXNTdXNwZW5zZUFib3ZlQm9keTogYm9vbGVhblxuICBoYXNEeW5hbWljTWV0YWRhdGE6IGJvb2xlYW5cbiAgaGFzRHluYW1pY1ZpZXdwb3J0OiBib29sZWFuXG4gIGhhc0FsbG93ZWREeW5hbWljOiBib29sZWFuXG4gIGR5bmFtaWNFcnJvcnM6IEFycmF5PEVycm9yPlxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRHluYW1pY1RyYWNraW5nU3RhdGUoXG4gIGlzRGVidWdEeW5hbWljQWNjZXNzZXM6IGJvb2xlYW4gfCB1bmRlZmluZWRcbik6IER5bmFtaWNUcmFja2luZ1N0YXRlIHtcbiAgcmV0dXJuIHtcbiAgICBpc0RlYnVnRHluYW1pY0FjY2Vzc2VzLFxuICAgIGR5bmFtaWNBY2Nlc3NlczogW10sXG4gICAgc3luY0R5bmFtaWNFcnJvcldpdGhTdGFjazogbnVsbCxcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRHluYW1pY1ZhbGlkYXRpb25TdGF0ZSgpOiBEeW5hbWljVmFsaWRhdGlvblN0YXRlIHtcbiAgcmV0dXJuIHtcbiAgICBoYXNTdXNwZW5zZUFib3ZlQm9keTogZmFsc2UsXG4gICAgaGFzRHluYW1pY01ldGFkYXRhOiBmYWxzZSxcbiAgICBoYXNEeW5hbWljVmlld3BvcnQ6IGZhbHNlLFxuICAgIGhhc0FsbG93ZWREeW5hbWljOiBmYWxzZSxcbiAgICBkeW5hbWljRXJyb3JzOiBbXSxcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Rmlyc3REeW5hbWljUmVhc29uKFxuICB0cmFja2luZ1N0YXRlOiBEeW5hbWljVHJhY2tpbmdTdGF0ZVxuKTogdW5kZWZpbmVkIHwgc3RyaW5nIHtcbiAgcmV0dXJuIHRyYWNraW5nU3RhdGUuZHluYW1pY0FjY2Vzc2VzWzBdPy5leHByZXNzaW9uXG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBjb21tdW5pY2F0ZXMgdGhhdCB0aGUgY3VycmVudCBzY29wZSBzaG91bGQgYmUgdHJlYXRlZCBhcyBkeW5hbWljLlxuICpcbiAqIEluIG1vc3QgY2FzZXMgdGhpcyBmdW5jdGlvbiBpcyBhIG5vLW9wIGJ1dCBpZiBjYWxsZWQgZHVyaW5nXG4gKiBhIFBQUiBwcmVyZW5kZXIgaXQgd2lsbCBwb3N0cG9uZSB0aGUgY3VycmVudCBzdWItdHJlZSBhbmQgY2FsbGluZ1xuICogaXQgZHVyaW5nIGEgbm9ybWFsIHByZXJlbmRlciB3aWxsIGNhdXNlIHRoZSBlbnRpcmUgcHJlcmVuZGVyIHRvIGFib3J0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXJrQ3VycmVudFNjb3BlQXNEeW5hbWljKFxuICBzdG9yZTogV29ya1N0b3JlLFxuICB3b3JrVW5pdFN0b3JlOiB1bmRlZmluZWQgfCBFeGNsdWRlPFdvcmtVbml0U3RvcmUsIFByZXJlbmRlclN0b3JlTW9kZXJuPixcbiAgZXhwcmVzc2lvbjogc3RyaW5nXG4pOiB2b2lkIHtcbiAgaWYgKHdvcmtVbml0U3RvcmUpIHtcbiAgICBpZiAoXG4gICAgICB3b3JrVW5pdFN0b3JlLnR5cGUgPT09ICdjYWNoZScgfHxcbiAgICAgIHdvcmtVbml0U3RvcmUudHlwZSA9PT0gJ3Vuc3RhYmxlLWNhY2hlJ1xuICAgICkge1xuICAgICAgLy8gaW5zaWRlIGNhY2hlIHNjb3BlcyBtYXJraW5nIGEgc2NvcGUgYXMgZHluYW1pYyBoYXMgbm8gZWZmZWN0IGJlY2F1c2UgdGhlIG91dGVyIGNhY2hlIHNjb3BlXG4gICAgICAvLyBjcmVhdGVzIGEgY2FjaGUgYm91bmRhcnkuIFRoaXMgaXMgc3VidGx5IGRpZmZlcmVudCBmcm9tIHJlYWRpbmcgYSBkeW5hbWljIGRhdGEgc291cmNlIHdoaWNoIGlzXG4gICAgICAvLyBmb3JiaWRkZW4gaW5zaWRlIGEgY2FjaGUgc2NvcGUuXG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cblxuICAvLyBJZiB3ZSdyZSBmb3JjaW5nIGR5bmFtaWMgcmVuZGVyaW5nIG9yIHdlJ3JlIGZvcmNpbmcgc3RhdGljIHJlbmRlcmluZywgd2VcbiAgLy8gZG9uJ3QgbmVlZCB0byBkbyBhbnl0aGluZyBoZXJlIGJlY2F1c2UgdGhlIGVudGlyZSBwYWdlIGlzIGFscmVhZHkgZHluYW1pY1xuICAvLyBvciBpdCdzIHN0YXRpYyBhbmQgaXQgc2hvdWxkIG5vdCB0aHJvdyBvciBwb3N0cG9uZSBoZXJlLlxuICBpZiAoc3RvcmUuZm9yY2VEeW5hbWljIHx8IHN0b3JlLmZvcmNlU3RhdGljKSByZXR1cm5cblxuICBpZiAoc3RvcmUuZHluYW1pY1Nob3VsZEVycm9yKSB7XG4gICAgdGhyb3cgbmV3IFN0YXRpY0dlbkJhaWxvdXRFcnJvcihcbiAgICAgIGBSb3V0ZSAke3N0b3JlLnJvdXRlfSB3aXRoIFxcYGR5bmFtaWMgPSBcImVycm9yXCJcXGAgY291bGRuJ3QgYmUgcmVuZGVyZWQgc3RhdGljYWxseSBiZWNhdXNlIGl0IHVzZWQgXFxgJHtleHByZXNzaW9ufVxcYC4gU2VlIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYnVpbGRpbmcteW91ci1hcHBsaWNhdGlvbi9yZW5kZXJpbmcvc3RhdGljLWFuZC1keW5hbWljI2R5bmFtaWMtcmVuZGVyaW5nYFxuICAgIClcbiAgfVxuXG4gIGlmICh3b3JrVW5pdFN0b3JlKSB7XG4gICAgaWYgKHdvcmtVbml0U3RvcmUudHlwZSA9PT0gJ3ByZXJlbmRlci1wcHInKSB7XG4gICAgICBwb3N0cG9uZVdpdGhUcmFja2luZyhcbiAgICAgICAgc3RvcmUucm91dGUsXG4gICAgICAgIGV4cHJlc3Npb24sXG4gICAgICAgIHdvcmtVbml0U3RvcmUuZHluYW1pY1RyYWNraW5nXG4gICAgICApXG4gICAgfSBlbHNlIGlmICh3b3JrVW5pdFN0b3JlLnR5cGUgPT09ICdwcmVyZW5kZXItbGVnYWN5Jykge1xuICAgICAgd29ya1VuaXRTdG9yZS5yZXZhbGlkYXRlID0gMFxuXG4gICAgICAvLyBXZSBhcmVuJ3QgcHJlcmVuZGVyaW5nIGJ1dCB3ZSBhcmUgZ2VuZXJhdGluZyBhIHN0YXRpYyBwYWdlLiBXZSBuZWVkIHRvIGJhaWwgb3V0IG9mIHN0YXRpYyBnZW5lcmF0aW9uXG4gICAgICBjb25zdCBlcnIgPSBuZXcgRHluYW1pY1NlcnZlckVycm9yKFxuICAgICAgICBgUm91dGUgJHtzdG9yZS5yb3V0ZX0gY291bGRuJ3QgYmUgcmVuZGVyZWQgc3RhdGljYWxseSBiZWNhdXNlIGl0IHVzZWQgJHtleHByZXNzaW9ufS4gU2VlIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9keW5hbWljLXNlcnZlci1lcnJvcmBcbiAgICAgIClcbiAgICAgIHN0b3JlLmR5bmFtaWNVc2FnZURlc2NyaXB0aW9uID0gZXhwcmVzc2lvblxuICAgICAgc3RvcmUuZHluYW1pY1VzYWdlU3RhY2sgPSBlcnIuc3RhY2tcblxuICAgICAgdGhyb3cgZXJyXG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmXG4gICAgICB3b3JrVW5pdFN0b3JlICYmXG4gICAgICB3b3JrVW5pdFN0b3JlLnR5cGUgPT09ICdyZXF1ZXN0J1xuICAgICkge1xuICAgICAgd29ya1VuaXRTdG9yZS51c2VkRHluYW1pYyA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGNvbW11bmljYXRlcyB0aGF0IHNvbWUgZHluYW1pYyBwYXRoIHBhcmFtZXRlciB3YXMgcmVhZC4gVGhpc1xuICogZGlmZmVycyBmcm9tIHRoZSBtb3JlIGdlbmVyYWwgYHRyYWNrRHluYW1pY0RhdGFBY2Nlc3NlZGAgaW4gdGhhdCBpdCBpcyB3aWxsXG4gKiBub3QgZXJyb3Igd2hlbiBgZHluYW1pYyA9IFwiZXJyb3JcImAgaXMgc2V0LlxuICpcbiAqIEBwYXJhbSBzdG9yZSBUaGUgc3RhdGljIGdlbmVyYXRpb24gc3RvcmVcbiAqIEBwYXJhbSBleHByZXNzaW9uIFRoZSBleHByZXNzaW9uIHRoYXQgd2FzIGFjY2Vzc2VkIGR5bmFtaWNhbGx5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFja0ZhbGxiYWNrUGFyYW1BY2Nlc3NlZChcbiAgc3RvcmU6IFdvcmtTdG9yZSxcbiAgZXhwcmVzc2lvbjogc3RyaW5nXG4pOiB2b2lkIHtcbiAgY29uc3QgcHJlcmVuZGVyU3RvcmUgPSB3b3JrVW5pdEFzeW5jU3RvcmFnZS5nZXRTdG9yZSgpXG4gIGlmICghcHJlcmVuZGVyU3RvcmUgfHwgcHJlcmVuZGVyU3RvcmUudHlwZSAhPT0gJ3ByZXJlbmRlci1wcHInKSByZXR1cm5cblxuICBwb3N0cG9uZVdpdGhUcmFja2luZyhzdG9yZS5yb3V0ZSwgZXhwcmVzc2lvbiwgcHJlcmVuZGVyU3RvcmUuZHluYW1pY1RyYWNraW5nKVxufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbWVhbnQgdG8gYmUgdXNlZCB3aGVuIHByZXJlbmRlcmluZyB3aXRob3V0IGR5bmFtaWNJTyBvciBQUFIuXG4gKiBXaGVuIGNhbGxlZCBkdXJpbmcgYSBidWlsZCBpdCB3aWxsIGNhdXNlIE5leHQuanMgdG8gY29uc2lkZXIgdGhlIHJvdXRlIGFzIGR5bmFtaWMuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0aHJvd1RvSW50ZXJydXB0U3RhdGljR2VuZXJhdGlvbihcbiAgZXhwcmVzc2lvbjogc3RyaW5nLFxuICBzdG9yZTogV29ya1N0b3JlLFxuICBwcmVyZW5kZXJTdG9yZTogUHJlcmVuZGVyU3RvcmVMZWdhY3lcbik6IG5ldmVyIHtcbiAgLy8gV2UgYXJlbid0IHByZXJlbmRlcmluZyBidXQgd2UgYXJlIGdlbmVyYXRpbmcgYSBzdGF0aWMgcGFnZS4gV2UgbmVlZCB0byBiYWlsIG91dCBvZiBzdGF0aWMgZ2VuZXJhdGlvblxuICBjb25zdCBlcnIgPSBuZXcgRHluYW1pY1NlcnZlckVycm9yKFxuICAgIGBSb3V0ZSAke3N0b3JlLnJvdXRlfSBjb3VsZG4ndCBiZSByZW5kZXJlZCBzdGF0aWNhbGx5IGJlY2F1c2UgaXQgdXNlZCBcXGAke2V4cHJlc3Npb259XFxgLiBTZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2R5bmFtaWMtc2VydmVyLWVycm9yYFxuICApXG5cbiAgcHJlcmVuZGVyU3RvcmUucmV2YWxpZGF0ZSA9IDBcblxuICBzdG9yZS5keW5hbWljVXNhZ2VEZXNjcmlwdGlvbiA9IGV4cHJlc3Npb25cbiAgc3RvcmUuZHluYW1pY1VzYWdlU3RhY2sgPSBlcnIuc3RhY2tcblxuICB0aHJvdyBlcnJcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBiZSB1c2VkIHRvIHRyYWNrIHdoZXRoZXIgc29tZXRoaW5nIGR5bmFtaWMgaGFwcGVuZWQgZXZlbiB3aGVuXG4gKiB3ZSBhcmUgaW4gYSBkeW5hbWljIHJlbmRlci4gVGhpcyBpcyB1c2VmdWwgZm9yIERldiB3aGVyZSBhbGwgcmVuZGVycyBhcmUgZHluYW1pYyBidXRcbiAqIHdlIHN0aWxsIHRyYWNrIHdoZXRoZXIgZHluYW1pYyBBUElzIHdlcmUgYWNjZXNzZWQgZm9yIGhlbHBmdWwgbWVzc2FnaW5nXG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFja0R5bmFtaWNEYXRhSW5EeW5hbWljUmVuZGVyKFxuICBfc3RvcmU6IFdvcmtTdG9yZSxcbiAgd29ya1VuaXRTdG9yZTogdm9pZCB8IFdvcmtVbml0U3RvcmVcbikge1xuICBpZiAod29ya1VuaXRTdG9yZSkge1xuICAgIGlmIChcbiAgICAgIHdvcmtVbml0U3RvcmUudHlwZSA9PT0gJ2NhY2hlJyB8fFxuICAgICAgd29ya1VuaXRTdG9yZS50eXBlID09PSAndW5zdGFibGUtY2FjaGUnXG4gICAgKSB7XG4gICAgICAvLyBpbnNpZGUgY2FjaGUgc2NvcGVzIG1hcmtpbmcgYSBzY29wZSBhcyBkeW5hbWljIGhhcyBubyBlZmZlY3QgYmVjYXVzZSB0aGUgb3V0ZXIgY2FjaGUgc2NvcGVcbiAgICAgIC8vIGNyZWF0ZXMgYSBjYWNoZSBib3VuZGFyeS4gVGhpcyBpcyBzdWJ0bHkgZGlmZmVyZW50IGZyb20gcmVhZGluZyBhIGR5bmFtaWMgZGF0YSBzb3VyY2Ugd2hpY2ggaXNcbiAgICAgIC8vIGZvcmJpZGRlbiBpbnNpZGUgYSBjYWNoZSBzY29wZS5cbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyBUT0RPOiBpdCBtYWtlcyBubyBzZW5zZSB0byBoYXZlIHRoZXNlIHdvcmsgdW5pdCBzdG9yZSB0eXBlcyBkdXJpbmcgYSBkZXYgcmVuZGVyLlxuICAgIGlmIChcbiAgICAgIHdvcmtVbml0U3RvcmUudHlwZSA9PT0gJ3ByZXJlbmRlcicgfHxcbiAgICAgIHdvcmtVbml0U3RvcmUudHlwZSA9PT0gJ3ByZXJlbmRlci1jbGllbnQnIHx8XG4gICAgICB3b3JrVW5pdFN0b3JlLnR5cGUgPT09ICdwcmVyZW5kZXItbGVnYWN5J1xuICAgICkge1xuICAgICAgd29ya1VuaXRTdG9yZS5yZXZhbGlkYXRlID0gMFxuICAgIH1cbiAgICBpZiAoXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJlxuICAgICAgd29ya1VuaXRTdG9yZS50eXBlID09PSAncmVxdWVzdCdcbiAgICApIHtcbiAgICAgIHdvcmtVbml0U3RvcmUudXNlZER5bmFtaWMgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFib3J0T25TeW5jaHJvbm91c0R5bmFtaWNEYXRhQWNjZXNzKFxuICByb3V0ZTogc3RyaW5nLFxuICBleHByZXNzaW9uOiBzdHJpbmcsXG4gIHByZXJlbmRlclN0b3JlOiBQcmVyZW5kZXJTdG9yZU1vZGVyblxuKTogdm9pZCB7XG4gIGNvbnN0IHJlYXNvbiA9IGBSb3V0ZSAke3JvdXRlfSBuZWVkcyB0byBiYWlsIG91dCBvZiBwcmVyZW5kZXJpbmcgYXQgdGhpcyBwb2ludCBiZWNhdXNlIGl0IHVzZWQgJHtleHByZXNzaW9ufS5gXG5cbiAgY29uc3QgZXJyb3IgPSBjcmVhdGVQcmVyZW5kZXJJbnRlcnJ1cHRlZEVycm9yKHJlYXNvbilcblxuICBwcmVyZW5kZXJTdG9yZS5jb250cm9sbGVyLmFib3J0KGVycm9yKVxuXG4gIGNvbnN0IGR5bmFtaWNUcmFja2luZyA9IHByZXJlbmRlclN0b3JlLmR5bmFtaWNUcmFja2luZ1xuICBpZiAoZHluYW1pY1RyYWNraW5nKSB7XG4gICAgZHluYW1pY1RyYWNraW5nLmR5bmFtaWNBY2Nlc3Nlcy5wdXNoKHtcbiAgICAgIC8vIFdoZW4gd2UgYXJlbid0IGRlYnVnZ2luZywgd2UgZG9uJ3QgbmVlZCB0byBjcmVhdGUgYW5vdGhlciBlcnJvciBmb3IgdGhlXG4gICAgICAvLyBzdGFjayB0cmFjZS5cbiAgICAgIHN0YWNrOiBkeW5hbWljVHJhY2tpbmcuaXNEZWJ1Z0R5bmFtaWNBY2Nlc3Nlc1xuICAgICAgICA/IG5ldyBFcnJvcigpLnN0YWNrXG4gICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgZXhwcmVzc2lvbixcbiAgICB9KVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhYm9ydE9uU3luY2hyb25vdXNQbGF0Zm9ybUlPQWNjZXNzKFxuICByb3V0ZTogc3RyaW5nLFxuICBleHByZXNzaW9uOiBzdHJpbmcsXG4gIGVycm9yV2l0aFN0YWNrOiBFcnJvcixcbiAgcHJlcmVuZGVyU3RvcmU6IFByZXJlbmRlclN0b3JlTW9kZXJuXG4pOiB2b2lkIHtcbiAgY29uc3QgZHluYW1pY1RyYWNraW5nID0gcHJlcmVuZGVyU3RvcmUuZHluYW1pY1RyYWNraW5nXG4gIGFib3J0T25TeW5jaHJvbm91c0R5bmFtaWNEYXRhQWNjZXNzKHJvdXRlLCBleHByZXNzaW9uLCBwcmVyZW5kZXJTdG9yZSlcbiAgLy8gSXQgaXMgaW1wb3J0YW50IHRoYXQgd2Ugc2V0IHRoaXMgdHJhY2tpbmcgdmFsdWUgYWZ0ZXIgYWJvcnRpbmcuIEFib3J0cyBhcmUgZXhlY3V0ZWRcbiAgLy8gc3luY2hyb25vdXNseSBleGNlcHQgZm9yIHRoZSBjYXNlIHdoZXJlIHlvdSBhYm9ydCBkdXJpbmcgcmVuZGVyIGl0c2VsZi4gQnkgc2V0dGluZyB0aGlzXG4gIC8vIHZhbHVlIGxhdGUgd2UgY2FuIHVzZSBpdCB0byBkZXRlcm1pbmUgaWYgYW55IG9mIHRoZSBhYm9ydGVkIHRhc2tzIGFyZSB0aGUgdGFzayB0aGF0XG4gIC8vIGNhbGxlZCB0aGUgc3luYyBJTyBleHByZXNzaW9uIGluIHRoZSBmaXJzdCBwbGFjZS5cbiAgaWYgKGR5bmFtaWNUcmFja2luZykge1xuICAgIGlmIChkeW5hbWljVHJhY2tpbmcuc3luY0R5bmFtaWNFcnJvcldpdGhTdGFjayA9PT0gbnVsbCkge1xuICAgICAgZHluYW1pY1RyYWNraW5nLnN5bmNEeW5hbWljRXJyb3JXaXRoU3RhY2sgPSBlcnJvcldpdGhTdGFja1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdHJhY2tTeW5jaHJvbm91c1BsYXRmb3JtSU9BY2Nlc3NJbkRldihcbiAgcmVxdWVzdFN0b3JlOiBSZXF1ZXN0U3RvcmVcbik6IHZvaWQge1xuICAvLyBXZSBkb24ndCBhY3R1YWxseSBoYXZlIGEgY29udHJvbGxlciB0byBhYm9ydCBidXQgd2UgZG8gdGhlIHNlbWFudGljIGVxdWl2YWxlbnQgYnlcbiAgLy8gYWR2YW5jaW5nIHRoZSByZXF1ZXN0IHN0b3JlIG91dCBvZiBwcmVyZW5kZXIgbW9kZVxuICByZXF1ZXN0U3RvcmUucHJlcmVuZGVyUGhhc2UgPSBmYWxzZVxufVxuXG4vKipcbiAqIHVzZSB0aGlzIGZ1bmN0aW9uIHdoZW4gcHJlcmVuZGVyaW5nIHdpdGggZHluYW1pY0lPLiBJZiB3ZSBhcmUgZG9pbmcgYVxuICogcHJvc3BlY3RpdmUgcHJlcmVuZGVyIHdlIGRvbid0IGFjdHVhbGx5IGFib3J0IGJlY2F1c2Ugd2Ugd2FudCB0byBkaXNjb3ZlclxuICogYWxsIGNhY2hlcyBmb3IgdGhlIHNoZWxsLiBJZiB0aGlzIGlzIHRoZSBhY3R1YWwgcHJlcmVuZGVyIHdlIGRvIGFib3J0LlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyBhIHByZXJlbmRlclN0b3JlIGJ1dCB0aGUgY2FsbGVyIHNob3VsZCBlbnN1cmUgd2UncmVcbiAqIGFjdHVhbGx5IHJ1bm5pbmcgaW4gZHluYW1pY0lPIG1vZGUuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhYm9ydEFuZFRocm93T25TeW5jaHJvbm91c1JlcXVlc3REYXRhQWNjZXNzKFxuICByb3V0ZTogc3RyaW5nLFxuICBleHByZXNzaW9uOiBzdHJpbmcsXG4gIGVycm9yV2l0aFN0YWNrOiBFcnJvcixcbiAgcHJlcmVuZGVyU3RvcmU6IFByZXJlbmRlclN0b3JlTW9kZXJuXG4pOiBuZXZlciB7XG4gIGNvbnN0IHByZXJlbmRlclNpZ25hbCA9IHByZXJlbmRlclN0b3JlLmNvbnRyb2xsZXIuc2lnbmFsXG4gIGlmIChwcmVyZW5kZXJTaWduYWwuYWJvcnRlZCA9PT0gZmFsc2UpIHtcbiAgICAvLyBUT0RPIGl0IHdvdWxkIGJlIGJldHRlciB0byBtb3ZlIHRoaXMgYWJvcnRlZCBjaGVjayBpbnRvIHRoZSBjYWxsc2l0ZSBzbyB3ZSBjYW4gYXZvaWQgbWFraW5nXG4gICAgLy8gdGhlIGVycm9yIG9iamVjdCB3aGVuIGl0IGlzbid0IHJlbGV2YW50IHRvIHRoZSBhYm9ydGluZyBvZiB0aGUgcHJlcmVuZGVyIGhvd2V2ZXJcbiAgICAvLyBzaW5jZSB3ZSBuZWVkIHRoZSB0aHJvdyBzZW1hbnRpY3MgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHdlIGFib3J0IGl0IGlzIGVhc2llciB0byBsYW5kXG4gICAgLy8gdGhpcyB3YXkuIFNlZSBob3cgdGhpcyB3YXMgaGFuZGxlZCB3aXRoIGBhYm9ydE9uU3luY2hyb25vdXNQbGF0Zm9ybUlPQWNjZXNzYCBmb3IgYSBjbG9zZXJcbiAgICAvLyB0byBpZGVhbCBpbXBsZW1lbnRhdGlvblxuICAgIGFib3J0T25TeW5jaHJvbm91c0R5bmFtaWNEYXRhQWNjZXNzKHJvdXRlLCBleHByZXNzaW9uLCBwcmVyZW5kZXJTdG9yZSlcbiAgICAvLyBJdCBpcyBpbXBvcnRhbnQgdGhhdCB3ZSBzZXQgdGhpcyB0cmFja2luZyB2YWx1ZSBhZnRlciBhYm9ydGluZy4gQWJvcnRzIGFyZSBleGVjdXRlZFxuICAgIC8vIHN5bmNocm9ub3VzbHkgZXhjZXB0IGZvciB0aGUgY2FzZSB3aGVyZSB5b3UgYWJvcnQgZHVyaW5nIHJlbmRlciBpdHNlbGYuIEJ5IHNldHRpbmcgdGhpc1xuICAgIC8vIHZhbHVlIGxhdGUgd2UgY2FuIHVzZSBpdCB0byBkZXRlcm1pbmUgaWYgYW55IG9mIHRoZSBhYm9ydGVkIHRhc2tzIGFyZSB0aGUgdGFzayB0aGF0XG4gICAgLy8gY2FsbGVkIHRoZSBzeW5jIElPIGV4cHJlc3Npb24gaW4gdGhlIGZpcnN0IHBsYWNlLlxuICAgIGNvbnN0IGR5bmFtaWNUcmFja2luZyA9IHByZXJlbmRlclN0b3JlLmR5bmFtaWNUcmFja2luZ1xuICAgIGlmIChkeW5hbWljVHJhY2tpbmcpIHtcbiAgICAgIGlmIChkeW5hbWljVHJhY2tpbmcuc3luY0R5bmFtaWNFcnJvcldpdGhTdGFjayA9PT0gbnVsbCkge1xuICAgICAgICBkeW5hbWljVHJhY2tpbmcuc3luY0R5bmFtaWNFcnJvcldpdGhTdGFjayA9IGVycm9yV2l0aFN0YWNrXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHRocm93IGNyZWF0ZVByZXJlbmRlckludGVycnVwdGVkRXJyb3IoXG4gICAgYFJvdXRlICR7cm91dGV9IG5lZWRzIHRvIGJhaWwgb3V0IG9mIHByZXJlbmRlcmluZyBhdCB0aGlzIHBvaW50IGJlY2F1c2UgaXQgdXNlZCAke2V4cHJlc3Npb259LmBcbiAgKVxufVxuXG4vLyBGb3Igbm93IHRoZXNlIGltcGxlbWVudGF0aW9ucyBhcmUgdGhlIHNhbWUgc28gd2UganVzdCByZWV4cG9ydFxuZXhwb3J0IGNvbnN0IHRyYWNrU3luY2hyb25vdXNSZXF1ZXN0RGF0YUFjY2Vzc0luRGV2ID1cbiAgdHJhY2tTeW5jaHJvbm91c1BsYXRmb3JtSU9BY2Nlc3NJbkRldlxuXG4vKipcbiAqIFRoaXMgY29tcG9uZW50IHdpbGwgY2FsbCBgUmVhY3QucG9zdHBvbmVgIHRoYXQgdGhyb3dzIHRoZSBwb3N0cG9uZWQgZXJyb3IuXG4gKi9cbnR5cGUgUG9zdHBvbmVQcm9wcyA9IHtcbiAgcmVhc29uOiBzdHJpbmdcbiAgcm91dGU6IHN0cmluZ1xufVxuZXhwb3J0IGZ1bmN0aW9uIFBvc3Rwb25lKHsgcmVhc29uLCByb3V0ZSB9OiBQb3N0cG9uZVByb3BzKTogbmV2ZXIge1xuICBjb25zdCBwcmVyZW5kZXJTdG9yZSA9IHdvcmtVbml0QXN5bmNTdG9yYWdlLmdldFN0b3JlKClcbiAgY29uc3QgZHluYW1pY1RyYWNraW5nID1cbiAgICBwcmVyZW5kZXJTdG9yZSAmJiBwcmVyZW5kZXJTdG9yZS50eXBlID09PSAncHJlcmVuZGVyLXBwcidcbiAgICAgID8gcHJlcmVuZGVyU3RvcmUuZHluYW1pY1RyYWNraW5nXG4gICAgICA6IG51bGxcbiAgcG9zdHBvbmVXaXRoVHJhY2tpbmcocm91dGUsIHJlYXNvbiwgZHluYW1pY1RyYWNraW5nKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9zdHBvbmVXaXRoVHJhY2tpbmcoXG4gIHJvdXRlOiBzdHJpbmcsXG4gIGV4cHJlc3Npb246IHN0cmluZyxcbiAgZHluYW1pY1RyYWNraW5nOiBudWxsIHwgRHluYW1pY1RyYWNraW5nU3RhdGVcbik6IG5ldmVyIHtcbiAgYXNzZXJ0UG9zdHBvbmUoKVxuICBpZiAoZHluYW1pY1RyYWNraW5nKSB7XG4gICAgZHluYW1pY1RyYWNraW5nLmR5bmFtaWNBY2Nlc3Nlcy5wdXNoKHtcbiAgICAgIC8vIFdoZW4gd2UgYXJlbid0IGRlYnVnZ2luZywgd2UgZG9uJ3QgbmVlZCB0byBjcmVhdGUgYW5vdGhlciBlcnJvciBmb3IgdGhlXG4gICAgICAvLyBzdGFjayB0cmFjZS5cbiAgICAgIHN0YWNrOiBkeW5hbWljVHJhY2tpbmcuaXNEZWJ1Z0R5bmFtaWNBY2Nlc3Nlc1xuICAgICAgICA/IG5ldyBFcnJvcigpLnN0YWNrXG4gICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgZXhwcmVzc2lvbixcbiAgICB9KVxuICB9XG5cbiAgUmVhY3QudW5zdGFibGVfcG9zdHBvbmUoY3JlYXRlUG9zdHBvbmVSZWFzb24ocm91dGUsIGV4cHJlc3Npb24pKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVQb3N0cG9uZVJlYXNvbihyb3V0ZTogc3RyaW5nLCBleHByZXNzaW9uOiBzdHJpbmcpIHtcbiAgcmV0dXJuIChcbiAgICBgUm91dGUgJHtyb3V0ZX0gbmVlZHMgdG8gYmFpbCBvdXQgb2YgcHJlcmVuZGVyaW5nIGF0IHRoaXMgcG9pbnQgYmVjYXVzZSBpdCB1c2VkICR7ZXhwcmVzc2lvbn0uIGAgK1xuICAgIGBSZWFjdCB0aHJvd3MgdGhpcyBzcGVjaWFsIG9iamVjdCB0byBpbmRpY2F0ZSB3aGVyZS4gSXQgc2hvdWxkIG5vdCBiZSBjYXVnaHQgYnkgYCArXG4gICAgYHlvdXIgb3duIHRyeS9jYXRjaC4gTGVhcm4gbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvcHByLWNhdWdodC1lcnJvcmBcbiAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNEeW5hbWljUG9zdHBvbmUoZXJyOiB1bmtub3duKSB7XG4gIGlmIChcbiAgICB0eXBlb2YgZXJyID09PSAnb2JqZWN0JyAmJlxuICAgIGVyciAhPT0gbnVsbCAmJlxuICAgIHR5cGVvZiAoZXJyIGFzIGFueSkubWVzc2FnZSA9PT0gJ3N0cmluZydcbiAgKSB7XG4gICAgcmV0dXJuIGlzRHluYW1pY1Bvc3Rwb25lUmVhc29uKChlcnIgYXMgYW55KS5tZXNzYWdlKVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBpc0R5bmFtaWNQb3N0cG9uZVJlYXNvbihyZWFzb246IHN0cmluZykge1xuICByZXR1cm4gKFxuICAgIHJlYXNvbi5pbmNsdWRlcyhcbiAgICAgICduZWVkcyB0byBiYWlsIG91dCBvZiBwcmVyZW5kZXJpbmcgYXQgdGhpcyBwb2ludCBiZWNhdXNlIGl0IHVzZWQnXG4gICAgKSAmJlxuICAgIHJlYXNvbi5pbmNsdWRlcyhcbiAgICAgICdMZWFybiBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9wcHItY2F1Z2h0LWVycm9yJ1xuICAgIClcbiAgKVxufVxuXG5pZiAoaXNEeW5hbWljUG9zdHBvbmVSZWFzb24oY3JlYXRlUG9zdHBvbmVSZWFzb24oJyUlJScsICdeXl4nKSkgPT09IGZhbHNlKSB7XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAnSW52YXJpYW50OiBpc0R5bmFtaWNQb3N0cG9uZSBtaXNpZGVudGlmaWVkIGEgcG9zdHBvbmUgcmVhc29uLiBUaGlzIGlzIGEgYnVnIGluIE5leHQuanMnXG4gIClcbn1cblxuY29uc3QgTkVYVF9QUkVSRU5ERVJfSU5URVJSVVBURUQgPSAnTkVYVF9QUkVSRU5ERVJfSU5URVJSVVBURUQnXG5cbmZ1bmN0aW9uIGNyZWF0ZVByZXJlbmRlckludGVycnVwdGVkRXJyb3IobWVzc2FnZTogc3RyaW5nKTogRXJyb3Ige1xuICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKVxuICA7KGVycm9yIGFzIGFueSkuZGlnZXN0ID0gTkVYVF9QUkVSRU5ERVJfSU5URVJSVVBURURcbiAgcmV0dXJuIGVycm9yXG59XG5cbnR5cGUgRGlnZXN0RXJyb3IgPSBFcnJvciAmIHtcbiAgZGlnZXN0OiBzdHJpbmdcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUHJlcmVuZGVySW50ZXJydXB0ZWRFcnJvcihcbiAgZXJyb3I6IHVua25vd25cbik6IGVycm9yIGlzIERpZ2VzdEVycm9yIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmXG4gICAgZXJyb3IgIT09IG51bGwgJiZcbiAgICAoZXJyb3IgYXMgYW55KS5kaWdlc3QgPT09IE5FWFRfUFJFUkVOREVSX0lOVEVSUlVQVEVEICYmXG4gICAgJ25hbWUnIGluIGVycm9yICYmXG4gICAgJ21lc3NhZ2UnIGluIGVycm9yICYmXG4gICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvclxuICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhY2Nlc3NlZER5bmFtaWNEYXRhKFxuICBkeW5hbWljQWNjZXNzZXM6IEFycmF5PER5bmFtaWNBY2Nlc3M+XG4pOiBib29sZWFuIHtcbiAgcmV0dXJuIGR5bmFtaWNBY2Nlc3Nlcy5sZW5ndGggPiAwXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb25zdW1lRHluYW1pY0FjY2VzcyhcbiAgc2VydmVyRHluYW1pYzogRHluYW1pY1RyYWNraW5nU3RhdGUsXG4gIGNsaWVudER5bmFtaWM6IER5bmFtaWNUcmFja2luZ1N0YXRlXG4pOiBEeW5hbWljVHJhY2tpbmdTdGF0ZVsnZHluYW1pY0FjY2Vzc2VzJ10ge1xuICAvLyBXZSBtdXRhdGUgYmVjYXVzZSB3ZSBvbmx5IGNhbGwgdGhpcyBvbmNlIHdlIGFyZSBubyBsb25nZXIgd3JpdGluZ1xuICAvLyB0byB0aGUgZHluYW1pY1RyYWNraW5nU3RhdGUgYW5kIGl0J3MgbW9yZSBlZmZpY2llbnQgdGhhbiBjcmVhdGluZyBhIG5ld1xuICAvLyBhcnJheS5cbiAgc2VydmVyRHluYW1pYy5keW5hbWljQWNjZXNzZXMucHVzaCguLi5jbGllbnREeW5hbWljLmR5bmFtaWNBY2Nlc3NlcylcbiAgcmV0dXJuIHNlcnZlckR5bmFtaWMuZHluYW1pY0FjY2Vzc2VzXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXREeW5hbWljQVBJQWNjZXNzZXMoXG4gIGR5bmFtaWNBY2Nlc3NlczogQXJyYXk8RHluYW1pY0FjY2Vzcz5cbik6IHN0cmluZ1tdIHtcbiAgcmV0dXJuIGR5bmFtaWNBY2Nlc3Nlc1xuICAgIC5maWx0ZXIoXG4gICAgICAoYWNjZXNzKTogYWNjZXNzIGlzIFJlcXVpcmVkPER5bmFtaWNBY2Nlc3M+ID0+XG4gICAgICAgIHR5cGVvZiBhY2Nlc3Muc3RhY2sgPT09ICdzdHJpbmcnICYmIGFjY2Vzcy5zdGFjay5sZW5ndGggPiAwXG4gICAgKVxuICAgIC5tYXAoKHsgZXhwcmVzc2lvbiwgc3RhY2sgfSkgPT4ge1xuICAgICAgc3RhY2sgPSBzdGFja1xuICAgICAgICAuc3BsaXQoJ1xcbicpXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgXCJFcnJvcjogXCIgcHJlZml4IGZyb20gdGhlIGZpcnN0IGxpbmUgb2YgdGhlIHN0YWNrIHRyYWNlIGFzXG4gICAgICAgIC8vIHdlbGwgYXMgdGhlIGZpcnN0IDQgbGluZXMgb2YgdGhlIHN0YWNrIHRyYWNlIHdoaWNoIGlzIHRoZSBkaXN0YW5jZVxuICAgICAgICAvLyBmcm9tIHRoZSB1c2VyIGNvZGUgYW5kIHRoZSBgbmV3IEVycm9yKCkuc3RhY2tgIGNhbGwuXG4gICAgICAgIC5zbGljZSg0KVxuICAgICAgICAuZmlsdGVyKChsaW5lKSA9PiB7XG4gICAgICAgICAgLy8gRXhjbHVkZSBOZXh0LmpzIGludGVybmFscyBmcm9tIHRoZSBzdGFjayB0cmFjZS5cbiAgICAgICAgICBpZiAobGluZS5pbmNsdWRlcygnbm9kZV9tb2R1bGVzL25leHQvJykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEV4Y2x1ZGUgYW5vbnltb3VzIGZ1bmN0aW9ucyBmcm9tIHRoZSBzdGFjayB0cmFjZS5cbiAgICAgICAgICBpZiAobGluZS5pbmNsdWRlcygnICg8YW5vbnltb3VzPiknKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRXhjbHVkZSBOb2RlLmpzIGludGVybmFscyBmcm9tIHRoZSBzdGFjayB0cmFjZS5cbiAgICAgICAgICBpZiAobGluZS5pbmNsdWRlcygnIChub2RlOicpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9KVxuICAgICAgICAuam9pbignXFxuJylcbiAgICAgIHJldHVybiBgRHluYW1pYyBBUEkgVXNhZ2UgRGVidWcgLSAke2V4cHJlc3Npb259OlxcbiR7c3RhY2t9YFxuICAgIH0pXG59XG5cbmZ1bmN0aW9uIGFzc2VydFBvc3Rwb25lKCkge1xuICBpZiAoIWhhc1Bvc3Rwb25lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEludmFyaWFudDogUmVhY3QudW5zdGFibGVfcG9zdHBvbmUgaXMgbm90IGRlZmluZWQuIFRoaXMgc3VnZ2VzdHMgdGhlIHdyb25nIHZlcnNpb24gb2YgUmVhY3Qgd2FzIGxvYWRlZC4gVGhpcyBpcyBhIGJ1ZyBpbiBOZXh0LmpzYFxuICAgIClcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgaXMgYSBiaXQgb2YgYSBoYWNrIHRvIGFsbG93IHVzIHRvIGFib3J0IGEgcmVuZGVyIHVzaW5nIGEgUG9zdHBvbmUgaW5zdGFuY2UgaW5zdGVhZCBvZiBhbiBFcnJvciB3aGljaCBjaGFuZ2VzIFJlYWN0J3NcbiAqIGFib3J0IHNlbWFudGljcyBzbGlnaHRseS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVBvc3Rwb25lZEFib3J0U2lnbmFsKHJlYXNvbjogc3RyaW5nKTogQWJvcnRTaWduYWwge1xuICBhc3NlcnRQb3N0cG9uZSgpXG4gIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKClcbiAgLy8gV2UgZ2V0IG91ciBoYW5kcyBvbiBhIHBvc3Rwb25lIGluc3RhbmNlIGJ5IGNhbGxpbmcgcG9zdHBvbmUgYW5kIGNhdGNoaW5nIHRoZSB0aHJvd1xuICB0cnkge1xuICAgIFJlYWN0LnVuc3RhYmxlX3Bvc3Rwb25lKHJlYXNvbilcbiAgfSBjYXRjaCAoeDogdW5rbm93bikge1xuICAgIGNvbnRyb2xsZXIuYWJvcnQoeClcbiAgfVxuICByZXR1cm4gY29udHJvbGxlci5zaWduYWxcbn1cblxuLyoqXG4gKiBJbiBhIHByZXJlbmRlciwgd2UgbWF5IGVuZCB1cCB3aXRoIGhhbmdpbmcgUHJvbWlzZXMgYXMgaW5wdXRzIGR1ZSB0aGVtXG4gKiBzdGFsbGluZyBvbiBjb25uZWN0aW9uKCkgb3IgYmVjYXVzZSB0aGV5J3JlIGxvYWRpbmcgZHluYW1pYyBkYXRhLiBJbiB0aGF0XG4gKiBjYXNlIHdlIG5lZWQgdG8gYWJvcnQgdGhlIGVuY29kaW5nIG9mIGFyZ3VtZW50cyBzaW5jZSB0aGV5J2xsIG5ldmVyIGNvbXBsZXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSGFuZ2luZ0lucHV0QWJvcnRTaWduYWwoXG4gIHdvcmtVbml0U3RvcmU6IFByZXJlbmRlclN0b3JlTW9kZXJuXG4pOiBBYm9ydFNpZ25hbCB7XG4gIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKClcblxuICBpZiAod29ya1VuaXRTdG9yZS5jYWNoZVNpZ25hbCkge1xuICAgIC8vIElmIHdlIGhhdmUgYSBjYWNoZVNpZ25hbCBpdCBtZWFucyB3ZSdyZSBpbiBhIHByb3NwZWN0aXZlIHJlbmRlci4gSWYgdGhlIGlucHV0XG4gICAgLy8gd2UncmUgd2FpdGluZyBvbiBpcyBjb21pbmcgZnJvbSBhbm90aGVyIGNhY2hlLCB3ZSBkbyB3YW50IHRvIHdhaXQgZm9yIGl0IHNvIHRoYXRcbiAgICAvLyB3ZSBjYW4gcmVzb2x2ZSB0aGlzIGNhY2hlIGVudHJ5IHRvby5cbiAgICB3b3JrVW5pdFN0b3JlLmNhY2hlU2lnbmFsLmlucHV0UmVhZHkoKS50aGVuKCgpID0+IHtcbiAgICAgIGNvbnRyb2xsZXIuYWJvcnQoKVxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgLy8gT3RoZXJ3aXNlIHdlJ3JlIGluIHRoZSBmaW5hbCByZW5kZXIgYW5kIHdlIHNob3VsZCBhbHJlYWR5IGhhdmUgYWxsIG91ciBjYWNoZXNcbiAgICAvLyBmaWxsZWQuIFdlIG1pZ2h0IHN0aWxsIGJlIHdhaXRpbmcgb24gc29tZSBtaWNyb3Rhc2tzIHNvIHdlIHdhaXQgb25lIHRpY2sgYmVmb3JlXG4gICAgLy8gZ2l2aW5nIHVwLiBXaGVuIHdlIGdpdmUgdXAsIHdlIHN0aWxsIHdhbnQgdG8gcmVuZGVyIHRoZSBjb250ZW50IG9mIHRoaXMgY2FjaGVcbiAgICAvLyBhcyBkZWVwbHkgYXMgd2UgY2FuIHNvIHRoYXQgd2UgY2FuIHN1c3BlbmQgYXMgZGVlcGx5IGFzIHBvc3NpYmxlIGluIHRoZSB0cmVlXG4gICAgLy8gb3Igbm90IGF0IGFsbCBpZiB3ZSBkb24ndCBlbmQgdXAgd2FpdGluZyBmb3IgdGhlIGlucHV0LlxuICAgIHNjaGVkdWxlT25OZXh0VGljaygoKSA9PiBjb250cm9sbGVyLmFib3J0KCkpXG4gIH1cblxuICByZXR1cm4gY29udHJvbGxlci5zaWduYWxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFubm90YXRlRHluYW1pY0FjY2VzcyhcbiAgZXhwcmVzc2lvbjogc3RyaW5nLFxuICBwcmVyZW5kZXJTdG9yZTogUHJlcmVuZGVyU3RvcmVNb2Rlcm5cbikge1xuICBjb25zdCBkeW5hbWljVHJhY2tpbmcgPSBwcmVyZW5kZXJTdG9yZS5keW5hbWljVHJhY2tpbmdcbiAgaWYgKGR5bmFtaWNUcmFja2luZykge1xuICAgIGR5bmFtaWNUcmFja2luZy5keW5hbWljQWNjZXNzZXMucHVzaCh7XG4gICAgICBzdGFjazogZHluYW1pY1RyYWNraW5nLmlzRGVidWdEeW5hbWljQWNjZXNzZXNcbiAgICAgICAgPyBuZXcgRXJyb3IoKS5zdGFja1xuICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgIGV4cHJlc3Npb24sXG4gICAgfSlcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlRHluYW1pY1JvdXRlUGFyYW1zKGV4cHJlc3Npb246IHN0cmluZykge1xuICBjb25zdCB3b3JrU3RvcmUgPSB3b3JrQXN5bmNTdG9yYWdlLmdldFN0b3JlKClcblxuICBpZiAoXG4gICAgd29ya1N0b3JlICYmXG4gICAgd29ya1N0b3JlLmlzU3RhdGljR2VuZXJhdGlvbiAmJlxuICAgIHdvcmtTdG9yZS5mYWxsYmFja1JvdXRlUGFyYW1zICYmXG4gICAgd29ya1N0b3JlLmZhbGxiYWNrUm91dGVQYXJhbXMuc2l6ZSA+IDBcbiAgKSB7XG4gICAgLy8gVGhlcmUgYXJlIGZhbGxiYWNrIHJvdXRlIHBhcmFtcywgd2Ugc2hvdWxkIHRyYWNrIHRoZXNlIGFzIGR5bmFtaWNcbiAgICAvLyBhY2Nlc3Nlcy5cbiAgICBjb25zdCB3b3JrVW5pdFN0b3JlID0gd29ya1VuaXRBc3luY1N0b3JhZ2UuZ2V0U3RvcmUoKVxuICAgIGlmICh3b3JrVW5pdFN0b3JlKSB7XG4gICAgICAvLyBXZSdyZSBwcmVyZW5kZXJpbmcgd2l0aCBkeW5hbWljSU8gb3IgUFBSIG9yIGJvdGhcbiAgICAgIGlmICh3b3JrVW5pdFN0b3JlLnR5cGUgPT09ICdwcmVyZW5kZXItY2xpZW50Jykge1xuICAgICAgICAvLyBXZSBhcmUgaW4gYSBwcmVyZW5kZXIgd2l0aCBkeW5hbWljSU8gc2VtYW50aWNzXG4gICAgICAgIC8vIFdlIGFyZSBnb2luZyB0byBoYW5nIGhlcmUgYW5kIG5ldmVyIHJlc29sdmUuIFRoaXMgd2lsbCBjYXVzZSB0aGUgY3VycmVudGx5XG4gICAgICAgIC8vIHJlbmRlcmluZyBjb21wb25lbnQgdG8gZWZmZWN0aXZlbHkgYmUgYSBkeW5hbWljIGhvbGVcbiAgICAgICAgUmVhY3QudXNlKG1ha2VIYW5naW5nUHJvbWlzZSh3b3JrVW5pdFN0b3JlLnJlbmRlclNpZ25hbCwgZXhwcmVzc2lvbikpXG4gICAgICB9IGVsc2UgaWYgKHdvcmtVbml0U3RvcmUudHlwZSA9PT0gJ3ByZXJlbmRlci1wcHInKSB7XG4gICAgICAgIC8vIFdlJ3JlIHByZXJlbmRlcmluZyB3aXRoIFBQUlxuICAgICAgICBwb3N0cG9uZVdpdGhUcmFja2luZyhcbiAgICAgICAgICB3b3JrU3RvcmUucm91dGUsXG4gICAgICAgICAgZXhwcmVzc2lvbixcbiAgICAgICAgICB3b3JrVW5pdFN0b3JlLmR5bmFtaWNUcmFja2luZ1xuICAgICAgICApXG4gICAgICB9IGVsc2UgaWYgKHdvcmtVbml0U3RvcmUudHlwZSA9PT0gJ3ByZXJlbmRlci1sZWdhY3knKSB7XG4gICAgICAgIHRocm93VG9JbnRlcnJ1cHRTdGF0aWNHZW5lcmF0aW9uKGV4cHJlc3Npb24sIHdvcmtTdG9yZSwgd29ya1VuaXRTdG9yZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuY29uc3QgaGFzU3VzcGVuc2VSZWdleCA9IC9cXG5cXHMrYXQgU3VzcGVuc2UgXFwoPGFub255bW91cz5cXCkvXG5jb25zdCBoYXNTdXNwZW5zZUFmdGVyQm9keU9ySHRtbFJlZ2V4ID1cbiAgL1xcblxccythdCAoPzpib2R5fGh0bWwpIFxcKDxhbm9ueW1vdXM+XFwpW1xcc1xcU10qP1xcblxccythdCBTdXNwZW5zZSBcXCg8YW5vbnltb3VzPlxcKS9cbmNvbnN0IGhhc01ldGFkYXRhUmVnZXggPSBuZXcgUmVnRXhwKFxuICBgXFxcXG5cXFxccythdCAke01FVEFEQVRBX0JPVU5EQVJZX05BTUV9W1xcXFxuXFxcXHNdYFxuKVxuY29uc3QgaGFzVmlld3BvcnRSZWdleCA9IG5ldyBSZWdFeHAoXG4gIGBcXFxcblxcXFxzK2F0ICR7VklFV1BPUlRfQk9VTkRBUllfTkFNRX1bXFxcXG5cXFxcc11gXG4pXG5jb25zdCBoYXNPdXRsZXRSZWdleCA9IG5ldyBSZWdFeHAoYFxcXFxuXFxcXHMrYXQgJHtPVVRMRVRfQk9VTkRBUllfTkFNRX1bXFxcXG5cXFxcc11gKVxuXG5leHBvcnQgZnVuY3Rpb24gdHJhY2tBbGxvd2VkRHluYW1pY0FjY2VzcyhcbiAgd29ya1N0b3JlOiBXb3JrU3RvcmUsXG4gIGNvbXBvbmVudFN0YWNrOiBzdHJpbmcsXG4gIGR5bmFtaWNWYWxpZGF0aW9uOiBEeW5hbWljVmFsaWRhdGlvblN0YXRlLFxuICBjbGllbnREeW5hbWljOiBEeW5hbWljVHJhY2tpbmdTdGF0ZVxuKSB7XG4gIGlmIChoYXNPdXRsZXRSZWdleC50ZXN0KGNvbXBvbmVudFN0YWNrKSkge1xuICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gdHJhY2sgdGhhdCB0aGlzIGlzIGR5bmFtaWMuIEl0IGlzIG9ubHkgc28gd2hlbiBzb21ldGhpbmcgZWxzZSBpcyBhbHNvIGR5bmFtaWMuXG4gICAgcmV0dXJuXG4gIH0gZWxzZSBpZiAoaGFzTWV0YWRhdGFSZWdleC50ZXN0KGNvbXBvbmVudFN0YWNrKSkge1xuICAgIGR5bmFtaWNWYWxpZGF0aW9uLmhhc0R5bmFtaWNNZXRhZGF0YSA9IHRydWVcbiAgICByZXR1cm5cbiAgfSBlbHNlIGlmIChoYXNWaWV3cG9ydFJlZ2V4LnRlc3QoY29tcG9uZW50U3RhY2spKSB7XG4gICAgZHluYW1pY1ZhbGlkYXRpb24uaGFzRHluYW1pY1ZpZXdwb3J0ID0gdHJ1ZVxuICAgIHJldHVyblxuICB9IGVsc2UgaWYgKGhhc1N1c3BlbnNlQWZ0ZXJCb2R5T3JIdG1sUmVnZXgudGVzdChjb21wb25lbnRTdGFjaykpIHtcbiAgICAvLyBUaGlzIHByZXJlbmRlciBoYXMgYSBTdXNwZW5zZSBib3VuZGFyeSBhYm92ZSB0aGUgYm9keSB3aGljaFxuICAgIC8vIGVmZmVjdGl2ZWx5IG9wdHMgdGhlIHBhZ2UgaW50byBhbGxvd2luZyAxMDAlIGR5bmFtaWMgcmVuZGVyaW5nXG4gICAgZHluYW1pY1ZhbGlkYXRpb24uaGFzQWxsb3dlZER5bmFtaWMgPSB0cnVlXG4gICAgZHluYW1pY1ZhbGlkYXRpb24uaGFzU3VzcGVuc2VBYm92ZUJvZHkgPSB0cnVlXG4gICAgcmV0dXJuXG4gIH0gZWxzZSBpZiAoaGFzU3VzcGVuc2VSZWdleC50ZXN0KGNvbXBvbmVudFN0YWNrKSkge1xuICAgIC8vIHRoaXMgZXJyb3IgaGFkIGEgU3VzcGVuc2UgYm91bmRhcnkgYWJvdmUgaXQgc28gd2UgZG9uJ3QgbmVlZCB0byByZXBvcnQgaXQgYXMgYSBzb3VyY2VcbiAgICAvLyBvZiBkaXNhbGxvd2VkXG4gICAgZHluYW1pY1ZhbGlkYXRpb24uaGFzQWxsb3dlZER5bmFtaWMgPSB0cnVlXG4gICAgcmV0dXJuXG4gIH0gZWxzZSBpZiAoY2xpZW50RHluYW1pYy5zeW5jRHluYW1pY0Vycm9yV2l0aFN0YWNrKSB7XG4gICAgLy8gVGhpcyB0YXNrIHdhcyB0aGUgdGFzayB0aGF0IGNhbGxlZCB0aGUgc3luYyBlcnJvci5cbiAgICBkeW5hbWljVmFsaWRhdGlvbi5keW5hbWljRXJyb3JzLnB1c2goXG4gICAgICBjbGllbnREeW5hbWljLnN5bmNEeW5hbWljRXJyb3JXaXRoU3RhY2tcbiAgICApXG4gICAgcmV0dXJuXG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGBSb3V0ZSBcIiR7d29ya1N0b3JlLnJvdXRlfVwiOiBBIGNvbXBvbmVudCBhY2Nlc3NlZCBkYXRhLCBoZWFkZXJzLCBwYXJhbXMsIHNlYXJjaFBhcmFtcywgb3IgYSBzaG9ydC1saXZlZCBjYWNoZSB3aXRob3V0IGEgU3VzcGVuc2UgYm91bmRhcnkgbm9yIGEgXCJ1c2UgY2FjaGVcIiBhYm92ZSBpdC4gU2VlIG1vcmUgaW5mbzogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbmV4dC1wcmVyZW5kZXItbWlzc2luZy1zdXNwZW5zZWBcbiAgICBjb25zdCBlcnJvciA9IGNyZWF0ZUVycm9yV2l0aENvbXBvbmVudE9yT3duZXJTdGFjayhtZXNzYWdlLCBjb21wb25lbnRTdGFjaylcbiAgICBkeW5hbWljVmFsaWRhdGlvbi5keW5hbWljRXJyb3JzLnB1c2goZXJyb3IpXG4gICAgcmV0dXJuXG4gIH1cbn1cblxuLyoqXG4gKiBJbiBkZXYgbW9kZSwgd2UgcHJlZmVyIHVzaW5nIHRoZSBvd25lciBzdGFjaywgb3RoZXJ3aXNlIHRoZSBwcm92aWRlZFxuICogY29tcG9uZW50IHN0YWNrIGlzIHVzZWQuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVycm9yV2l0aENvbXBvbmVudE9yT3duZXJTdGFjayhcbiAgbWVzc2FnZTogc3RyaW5nLFxuICBjb21wb25lbnRTdGFjazogc3RyaW5nXG4pIHtcbiAgY29uc3Qgb3duZXJTdGFjayA9XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBSZWFjdC5jYXB0dXJlT3duZXJTdGFja1xuICAgICAgPyBSZWFjdC5jYXB0dXJlT3duZXJTdGFjaygpXG4gICAgICA6IG51bGxcblxuICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKVxuICBlcnJvci5zdGFjayA9IGVycm9yLm5hbWUgKyAnOiAnICsgbWVzc2FnZSArIChvd25lclN0YWNrID8/IGNvbXBvbmVudFN0YWNrKVxuICByZXR1cm4gZXJyb3Jcbn1cblxuZXhwb3J0IGVudW0gUHJlbHVkZVN0YXRlIHtcbiAgRnVsbCA9IDAsXG4gIEVtcHR5ID0gMSxcbiAgRXJyb3JlZCA9IDIsXG59XG5cbmZ1bmN0aW9uIGxvZ0Rpc2FsbG93ZWREeW5hbWljRXJyb3Iod29ya1N0b3JlOiBXb3JrU3RvcmUsIGVycm9yOiBFcnJvcik6IHZvaWQge1xuICBjb25zb2xlLmVycm9yKGVycm9yKVxuXG4gIGlmICghd29ya1N0b3JlLmRldikge1xuICAgIGlmICh3b3JrU3RvcmUuaGFzUmVhZGFibGVFcnJvclN0YWNrcykge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgYFRvIGdldCBhIG1vcmUgZGV0YWlsZWQgc3RhY2sgdHJhY2UgYW5kIHBpbnBvaW50IHRoZSBpc3N1ZSwgc3RhcnQgdGhlIGFwcCBpbiBkZXZlbG9wbWVudCBtb2RlIGJ5IHJ1bm5pbmcgXFxgbmV4dCBkZXZcXGAsIHRoZW4gb3BlbiBcIiR7d29ya1N0b3JlLnJvdXRlfVwiIGluIHlvdXIgYnJvd3NlciB0byBpbnZlc3RpZ2F0ZSB0aGUgZXJyb3IuYFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBUbyBnZXQgYSBtb3JlIGRldGFpbGVkIHN0YWNrIHRyYWNlIGFuZCBwaW5wb2ludCB0aGUgaXNzdWUsIHRyeSBvbmUgb2YgdGhlIGZvbGxvd2luZzpcbiAgLSBTdGFydCB0aGUgYXBwIGluIGRldmVsb3BtZW50IG1vZGUgYnkgcnVubmluZyBcXGBuZXh0IGRldlxcYCwgdGhlbiBvcGVuIFwiJHt3b3JrU3RvcmUucm91dGV9XCIgaW4geW91ciBicm93c2VyIHRvIGludmVzdGlnYXRlIHRoZSBlcnJvci5cbiAgLSBSZXJ1biB0aGUgcHJvZHVjdGlvbiBidWlsZCB3aXRoIFxcYG5leHQgYnVpbGQgLS1kZWJ1Zy1wcmVyZW5kZXJcXGAgdG8gZ2VuZXJhdGUgYmV0dGVyIHN0YWNrIHRyYWNlcy5gKVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdGhyb3dJZkRpc2FsbG93ZWREeW5hbWljKFxuICB3b3JrU3RvcmU6IFdvcmtTdG9yZSxcbiAgcHJlbHVkZTogUHJlbHVkZVN0YXRlLFxuICBkeW5hbWljVmFsaWRhdGlvbjogRHluYW1pY1ZhbGlkYXRpb25TdGF0ZSxcbiAgc2VydmVyRHluYW1pYzogRHluYW1pY1RyYWNraW5nU3RhdGVcbik6IHZvaWQge1xuICBpZiAod29ya1N0b3JlLmludmFsaWREeW5hbWljVXNhZ2VFcnJvcikge1xuICAgIGxvZ0Rpc2FsbG93ZWREeW5hbWljRXJyb3Iod29ya1N0b3JlLCB3b3JrU3RvcmUuaW52YWxpZER5bmFtaWNVc2FnZUVycm9yKVxuICAgIHRocm93IG5ldyBTdGF0aWNHZW5CYWlsb3V0RXJyb3IoKVxuICB9XG5cbiAgaWYgKHByZWx1ZGUgIT09IFByZWx1ZGVTdGF0ZS5GdWxsKSB7XG4gICAgaWYgKGR5bmFtaWNWYWxpZGF0aW9uLmhhc1N1c3BlbnNlQWJvdmVCb2R5KSB7XG4gICAgICAvLyBUaGlzIHJvdXRlIGhhcyBvcHRlZCBpbnRvIGFsbG93aW5nIGZ1bGx5IGR5bmFtaWMgcmVuZGVyaW5nXG4gICAgICAvLyBieSBpbmNsdWRpbmcgYSBTdXNwZW5zZSBib3VuZGFyeSBhYm92ZSB0aGUgYm9keS4gSW4gdGhpcyBjYXNlXG4gICAgICAvLyBhIGxhY2sgb2YgYSBzaGVsbCBpcyBub3QgY29uc2lkZXJlZCBkaXNhbGxvd2VkIHNvIHdlIHNpbXBseSByZXR1cm5cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChzZXJ2ZXJEeW5hbWljLnN5bmNEeW5hbWljRXJyb3JXaXRoU3RhY2spIHtcbiAgICAgIC8vIFRoZXJlIGlzIG5vIHNoZWxsIGFuZCB0aGUgc2VydmVyIGRpZCBzb21ldGhpbmcgc3luYyBkeW5hbWljIGxpa2VseVxuICAgICAgLy8gbGVhZGluZyB0byBhbiBlYXJseSB0ZXJtaW5hdGlvbiBvZiB0aGUgcHJlcmVuZGVyIGJlZm9yZSB0aGUgc2hlbGxcbiAgICAgIC8vIGNvdWxkIGJlIGNvbXBsZXRlZC4gV2UgdGVybWluYXRlIHRoZSBidWlsZC92YWxpZGF0aW5nIHJlbmRlci5cbiAgICAgIGxvZ0Rpc2FsbG93ZWREeW5hbWljRXJyb3IoXG4gICAgICAgIHdvcmtTdG9yZSxcbiAgICAgICAgc2VydmVyRHluYW1pYy5zeW5jRHluYW1pY0Vycm9yV2l0aFN0YWNrXG4gICAgICApXG4gICAgICB0aHJvdyBuZXcgU3RhdGljR2VuQmFpbG91dEVycm9yKClcbiAgICB9XG5cbiAgICAvLyBXZSBkaWRuJ3QgaGF2ZSBhbnkgc3luYyBiYWlsb3V0cyBidXQgdGhlcmUgbWF5IGJlIHVzZXIgY29kZSB3aGljaFxuICAgIC8vIGJsb2NrZWQgdGhlIHJvb3QuIFdlIHdvdWxkIGhhdmUgY2FwdHVyZWQgdGhlc2UgZHVyaW5nIHRoZSBwcmVyZW5kZXJcbiAgICAvLyBhbmQgY2FuIGxvZyB0aGVtIGhlcmUgYW5kIHRoZW4gdGVybWluYXRlIHRoZSBidWlsZC92YWxpZGF0aW5nIHJlbmRlclxuICAgIGNvbnN0IGR5bmFtaWNFcnJvcnMgPSBkeW5hbWljVmFsaWRhdGlvbi5keW5hbWljRXJyb3JzXG4gICAgaWYgKGR5bmFtaWNFcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkeW5hbWljRXJyb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxvZ0Rpc2FsbG93ZWREeW5hbWljRXJyb3Iod29ya1N0b3JlLCBkeW5hbWljRXJyb3JzW2ldKVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgU3RhdGljR2VuQmFpbG91dEVycm9yKClcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBnb3QgdGhpcyBmYXIgdGhlbiB0aGUgb25seSBvdGhlciB0aGluZyB0aGF0IGNvdWxkIGJlIGJsb2NraW5nXG4gICAgLy8gdGhlIHJvb3QgaXMgZHluYW1pYyBWaWV3cG9ydC4gSWYgdGhpcyBpcyBkeW5hbWljIHRoZW5cbiAgICAvLyB5b3UgbmVlZCB0byBvcHQgaW50byB0aGF0IGJ5IGFkZGluZyBhIFN1c3BlbnNlIGJvdW5kYXJ5IGFib3ZlIHRoZSBib2R5XG4gICAgLy8gdG8gaW5kaWNhdGUgeW91ciBhcmUgb2sgd2l0aCBmdWxseSBkeW5hbWljIHJlbmRlcmluZy5cbiAgICBpZiAoZHluYW1pY1ZhbGlkYXRpb24uaGFzRHluYW1pY1ZpZXdwb3J0KSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBgUm91dGUgXCIke3dvcmtTdG9yZS5yb3V0ZX1cIiBoYXMgYSBcXGBnZW5lcmF0ZVZpZXdwb3J0XFxgIHRoYXQgZGVwZW5kcyBvbiBSZXF1ZXN0IGRhdGEgKFxcYGNvb2tpZXMoKVxcYCwgZXRjLi4uKSBvciB1bmNhY2hlZCBleHRlcm5hbCBkYXRhIChcXGBmZXRjaCguLi4pXFxgLCBldGMuLi4pIHdpdGhvdXQgZXhwbGljaXRseSBhbGxvd2luZyBmdWxseSBkeW5hbWljIHJlbmRlcmluZy4gU2VlIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LXByZXJlbmRlci1keW5hbWljLXZpZXdwb3J0YFxuICAgICAgKVxuICAgICAgdGhyb3cgbmV3IFN0YXRpY0dlbkJhaWxvdXRFcnJvcigpXG4gICAgfVxuXG4gICAgaWYgKHByZWx1ZGUgPT09IFByZWx1ZGVTdGF0ZS5FbXB0eSkge1xuICAgICAgLy8gSWYgd2UgZXZlciBnZXQgdGhpcyBmYXIgdGhlbiB3ZSBtZXNzZWQgdXAgdGhlIHRyYWNraW5nIG9mIGludmFsaWQgZHluYW1pYy5cbiAgICAgIC8vIFdlIHN0aWxsIGFkaGVyZSB0byB0aGUgY29uc3RyYWludCB0aGF0IHlvdSBtdXN0IHByb2R1Y2UgYSBzaGVsbCBidXQgaW52aXRlIHRoZVxuICAgICAgLy8gdXNlciB0byByZXBvcnQgdGhpcyBhcyBhIGJ1ZyBpbiBOZXh0LmpzLlxuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgYFJvdXRlIFwiJHt3b3JrU3RvcmUucm91dGV9XCIgZGlkIG5vdCBwcm9kdWNlIGEgc3RhdGljIHNoZWxsIGFuZCBOZXh0LmpzIHdhcyB1bmFibGUgdG8gZGV0ZXJtaW5lIGEgcmVhc29uLiBUaGlzIGlzIGEgYnVnIGluIE5leHQuanMuYFxuICAgICAgKVxuICAgICAgdGhyb3cgbmV3IFN0YXRpY0dlbkJhaWxvdXRFcnJvcigpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChcbiAgICAgIGR5bmFtaWNWYWxpZGF0aW9uLmhhc0FsbG93ZWREeW5hbWljID09PSBmYWxzZSAmJlxuICAgICAgZHluYW1pY1ZhbGlkYXRpb24uaGFzRHluYW1pY01ldGFkYXRhXG4gICAgKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBgUm91dGUgXCIke3dvcmtTdG9yZS5yb3V0ZX1cIiBoYXMgYSBcXGBnZW5lcmF0ZU1ldGFkYXRhXFxgIHRoYXQgZGVwZW5kcyBvbiBSZXF1ZXN0IGRhdGEgKFxcYGNvb2tpZXMoKVxcYCwgZXRjLi4uKSBvciB1bmNhY2hlZCBleHRlcm5hbCBkYXRhIChcXGBmZXRjaCguLi4pXFxgLCBldGMuLi4pIHdoZW4gdGhlIHJlc3Qgb2YgdGhlIHJvdXRlIGRvZXMgbm90LiBTZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL25leHQtcHJlcmVuZGVyLWR5bmFtaWMtbWV0YWRhdGFgXG4gICAgICApXG4gICAgICB0aHJvdyBuZXcgU3RhdGljR2VuQmFpbG91dEVycm9yKClcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJQb3N0cG9uZSIsIlByZWx1ZGVTdGF0ZSIsImFib3J0QW5kVGhyb3dPblN5bmNocm9ub3VzUmVxdWVzdERhdGFBY2Nlc3MiLCJhYm9ydE9uU3luY2hyb25vdXNQbGF0Zm9ybUlPQWNjZXNzIiwiYWNjZXNzZWREeW5hbWljRGF0YSIsImFubm90YXRlRHluYW1pY0FjY2VzcyIsImNvbnN1bWVEeW5hbWljQWNjZXNzIiwiY3JlYXRlRHluYW1pY1RyYWNraW5nU3RhdGUiLCJjcmVhdGVEeW5hbWljVmFsaWRhdGlvblN0YXRlIiwiY3JlYXRlSGFuZ2luZ0lucHV0QWJvcnRTaWduYWwiLCJjcmVhdGVQb3N0cG9uZWRBYm9ydFNpZ25hbCIsImZvcm1hdER5bmFtaWNBUElBY2Nlc3NlcyIsImdldEZpcnN0RHluYW1pY1JlYXNvbiIsImlzRHluYW1pY1Bvc3Rwb25lIiwiaXNQcmVyZW5kZXJJbnRlcnJ1cHRlZEVycm9yIiwibWFya0N1cnJlbnRTY29wZUFzRHluYW1pYyIsInBvc3Rwb25lV2l0aFRyYWNraW5nIiwidGhyb3dJZkRpc2FsbG93ZWREeW5hbWljIiwidGhyb3dUb0ludGVycnVwdFN0YXRpY0dlbmVyYXRpb24iLCJ0cmFja0FsbG93ZWREeW5hbWljQWNjZXNzIiwidHJhY2tEeW5hbWljRGF0YUluRHluYW1pY1JlbmRlciIsInRyYWNrRmFsbGJhY2tQYXJhbUFjY2Vzc2VkIiwidHJhY2tTeW5jaHJvbm91c1BsYXRmb3JtSU9BY2Nlc3NJbkRldiIsInRyYWNrU3luY2hyb25vdXNSZXF1ZXN0RGF0YUFjY2Vzc0luRGV2IiwidXNlRHluYW1pY1JvdXRlUGFyYW1zIiwiaGFzUG9zdHBvbmUiLCJSZWFjdCIsInVuc3RhYmxlX3Bvc3Rwb25lIiwiaXNEZWJ1Z0R5bmFtaWNBY2Nlc3NlcyIsImR5bmFtaWNBY2Nlc3NlcyIsInN5bmNEeW5hbWljRXJyb3JXaXRoU3RhY2siLCJoYXNTdXNwZW5zZUFib3ZlQm9keSIsImhhc0R5bmFtaWNNZXRhZGF0YSIsImhhc0R5bmFtaWNWaWV3cG9ydCIsImhhc0FsbG93ZWREeW5hbWljIiwiZHluYW1pY0Vycm9ycyIsInRyYWNraW5nU3RhdGUiLCJleHByZXNzaW9uIiwic3RvcmUiLCJ3b3JrVW5pdFN0b3JlIiwidHlwZSIsImZvcmNlRHluYW1pYyIsImZvcmNlU3RhdGljIiwiZHluYW1pY1Nob3VsZEVycm9yIiwiU3RhdGljR2VuQmFpbG91dEVycm9yIiwicm91dGUiLCJkeW5hbWljVHJhY2tpbmciLCJyZXZhbGlkYXRlIiwiZXJyIiwiRHluYW1pY1NlcnZlckVycm9yIiwiZHluYW1pY1VzYWdlRGVzY3JpcHRpb24iLCJkeW5hbWljVXNhZ2VTdGFjayIsInN0YWNrIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwidXNlZER5bmFtaWMiLCJwcmVyZW5kZXJTdG9yZSIsIndvcmtVbml0QXN5bmNTdG9yYWdlIiwiZ2V0U3RvcmUiLCJfc3RvcmUiLCJhYm9ydE9uU3luY2hyb25vdXNEeW5hbWljRGF0YUFjY2VzcyIsInJlYXNvbiIsImVycm9yIiwiY3JlYXRlUHJlcmVuZGVySW50ZXJydXB0ZWRFcnJvciIsImNvbnRyb2xsZXIiLCJhYm9ydCIsInB1c2giLCJFcnJvciIsInVuZGVmaW5lZCIsImVycm9yV2l0aFN0YWNrIiwicmVxdWVzdFN0b3JlIiwicHJlcmVuZGVyUGhhc2UiLCJwcmVyZW5kZXJTaWduYWwiLCJzaWduYWwiLCJhYm9ydGVkIiwiYXNzZXJ0UG9zdHBvbmUiLCJjcmVhdGVQb3N0cG9uZVJlYXNvbiIsIm1lc3NhZ2UiLCJpc0R5bmFtaWNQb3N0cG9uZVJlYXNvbiIsImluY2x1ZGVzIiwiTkVYVF9QUkVSRU5ERVJfSU5URVJSVVBURUQiLCJkaWdlc3QiLCJsZW5ndGgiLCJzZXJ2ZXJEeW5hbWljIiwiY2xpZW50RHluYW1pYyIsImZpbHRlciIsImFjY2VzcyIsIm1hcCIsInNwbGl0Iiwic2xpY2UiLCJsaW5lIiwiam9pbiIsIkFib3J0Q29udHJvbGxlciIsIngiLCJjYWNoZVNpZ25hbCIsImlucHV0UmVhZHkiLCJ0aGVuIiwic2NoZWR1bGVPbk5leHRUaWNrIiwid29ya1N0b3JlIiwid29ya0FzeW5jU3RvcmFnZSIsImlzU3RhdGljR2VuZXJhdGlvbiIsImZhbGxiYWNrUm91dGVQYXJhbXMiLCJzaXplIiwidXNlIiwibWFrZUhhbmdpbmdQcm9taXNlIiwicmVuZGVyU2lnbmFsIiwiaGFzU3VzcGVuc2VSZWdleCIsImhhc1N1c3BlbnNlQWZ0ZXJCb2R5T3JIdG1sUmVnZXgiLCJoYXNNZXRhZGF0YVJlZ2V4IiwiUmVnRXhwIiwiTUVUQURBVEFfQk9VTkRBUllfTkFNRSIsImhhc1ZpZXdwb3J0UmVnZXgiLCJWSUVXUE9SVF9CT1VOREFSWV9OQU1FIiwiaGFzT3V0bGV0UmVnZXgiLCJPVVRMRVRfQk9VTkRBUllfTkFNRSIsImNvbXBvbmVudFN0YWNrIiwiZHluYW1pY1ZhbGlkYXRpb24iLCJ0ZXN0IiwiY3JlYXRlRXJyb3JXaXRoQ29tcG9uZW50T3JPd25lclN0YWNrIiwib3duZXJTdGFjayIsImNhcHR1cmVPd25lclN0YWNrIiwibmFtZSIsImxvZ0Rpc2FsbG93ZWREeW5hbWljRXJyb3IiLCJjb25zb2xlIiwiZGV2IiwiaGFzUmVhZGFibGVFcnJvclN0YWNrcyIsInByZWx1ZGUiLCJpbnZhbGlkRHluYW1pY1VzYWdlRXJyb3IiLCJpIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FvQkM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFnVmVBLFFBQVEsRUFBQTtlQUFSQTs7SUEyVEpDLFlBQVksRUFBQTtlQUFaQTs7SUFwV0lDLDJDQUEyQyxFQUFBO2VBQTNDQTs7SUFyQ0FDLGtDQUFrQyxFQUFBO2VBQWxDQTs7SUF3S0FDLG1CQUFtQixFQUFBO2VBQW5CQTs7SUE0R0FDLHFCQUFxQixFQUFBO2VBQXJCQTs7SUF0R0FDLG9CQUFvQixFQUFBO2VBQXBCQTs7SUEvV0FDLDBCQUEwQixFQUFBO2VBQTFCQTs7SUFVQUMsNEJBQTRCLEVBQUE7ZUFBNUJBOztJQW1iQUMsNkJBQTZCLEVBQUE7ZUFBN0JBOztJQWpCQUMsMEJBQTBCLEVBQUE7ZUFBMUJBOztJQWxEQUMsd0JBQXdCLEVBQUE7ZUFBeEJBOztJQXRXQUMscUJBQXFCLEVBQUE7ZUFBckJBOztJQWdTQUMsaUJBQWlCLEVBQUE7ZUFBakJBOztJQXdDQUMsMkJBQTJCLEVBQUE7ZUFBM0JBOztJQTNUQUMseUJBQXlCLEVBQUE7ZUFBekJBOztJQXVQQUMsb0JBQW9CLEVBQUE7ZUFBcEJBOztJQXdVQUMsd0JBQXdCLEVBQUE7ZUFBeEJBOztJQS9lQUMsZ0NBQWdDLEVBQUE7ZUFBaENBOztJQStaQUMseUJBQXlCLEVBQUE7ZUFBekJBOztJQXRZQUMsK0JBQStCLEVBQUE7ZUFBL0JBOztJQXpDQUMsMEJBQTBCLEVBQUE7ZUFBMUJBOztJQW1IQUMscUNBQXFDLEVBQUE7ZUFBckNBOztJ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QU8sRUFBRW9DLFVBQVV0RCxLQUFLLENBQUMsd0dBQXdHLENBQUM7WUFFckksTUFBTSxJQUFJRCx5QkFBQUEscUJBQXFCO1FBQ2pDO0lBQ0YsT0FBTztRQUNMLElBQ0V5RSxrQkFBa0JuRixpQkFBaUIsS0FBSyxTQUN4Q21GLGtCQUFrQnJGLGtCQUFrQixFQUNwQztZQUNBNEYsUUFBUTdELEtBQUssQ0FDWCxDQUFDLE9BQU8sRUFBRW9DLFVBQVV0RCxLQUFLLENBQUMsOFBBQThQLENBQUM7WUFFM1IsTUFBTSxJQUFJRCx5QkFBQUEscUJBQXFCO1FBQ2pDO0lBQ0Y7QUFDRiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxNDIyLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2NsaWVudC9jb21wb25lbnRzL3Vuc3RhYmxlLXJldGhyb3cuc2VydmVyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzSGFuZ2luZ1Byb21pc2VSZWplY3Rpb25FcnJvciB9IGZyb20gJy4uLy4uL3NlcnZlci9keW5hbWljLXJlbmRlcmluZy11dGlscydcbmltcG9ydCB7IGlzUG9zdHBvbmUgfSBmcm9tICcuLi8uLi9zZXJ2ZXIvbGliL3JvdXRlci11dGlscy9pcy1wb3N0cG9uZSdcbmltcG9ydCB7IGlzQmFpbG91dFRvQ1NSRXJyb3IgfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL2xhenktZHluYW1pYy9iYWlsb3V0LXRvLWNzcidcbmltcG9ydCB7IGlzTmV4dFJvdXRlckVycm9yIH0gZnJvbSAnLi9pcy1uZXh0LXJvdXRlci1lcnJvcidcbmltcG9ydCB7IGlzRHluYW1pY1Bvc3Rwb25lIH0gZnJvbSAnLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvZHluYW1pYy1yZW5kZXJpbmcnXG5pbXBvcnQgeyBpc0R5bmFtaWNTZXJ2ZXJFcnJvciB9IGZyb20gJy4vaG9va3Mtc2VydmVyLWNvbnRleHQnXG5cbmV4cG9ydCBmdW5jdGlvbiB1bnN0YWJsZV9yZXRocm93KGVycm9yOiB1bmtub3duKTogdm9pZCB7XG4gIGlmIChcbiAgICBpc05leHRSb3V0ZXJFcnJvcihlcnJvcikgfHxcbiAgICBpc0JhaWxvdXRUb0NTUkVycm9yKGVycm9yKSB8fFxuICAgIGlzRHluYW1pY1NlcnZlckVycm9yKGVycm9yKSB8fFxuICAgIGlzRHluYW1pY1Bvc3Rwb25lKGVycm9yKSB8fFxuICAgIGlzUG9zdHBvbmUoZXJyb3IpIHx8XG4gICAgaXNIYW5naW5nUHJvbWlzZVJlamVjdGlvbkVycm9yKGVycm9yKVxuICApIHtcbiAgICB0aHJvdyBlcnJvclxuICB9XG5cbiAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgJ2NhdXNlJyBpbiBlcnJvcikge1xuICAgIHVuc3RhYmxlX3JldGhyb3coZXJyb3IuY2F1c2UpXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJ1bnN0YWJsZV9yZXRocm93IiwiZXJyb3IiLCJpc05leHRSb3V0ZXJFcnJvciIsImlzQmFpbG91dFRvQ1NSRXJyb3IiLCJpc0R5bmFtaWNTZXJ2ZXJFcnJvciIsImlzRHluYW1pY1Bvc3Rwb25lIiwiaXNQb3N0cG9uZSIsImlzSGFuZ2luZ1Byb21pc2VSZWplY3Rpb25FcnJvciIsIkVycm9yIiwiY2F1c2UiXSwibWFwcGluZ3MiOiI7OzsrQkFPZ0JBLG9CQUFBQTs7O2VBQUFBOzs7dUNBUCtCOzRCQUNwQjs4QkFDUzttQ0FDRjtrQ0FDQTtvQ0FDRztBQUU5QixTQUFTQSxpQkFBaUJDLEtBQWM7SUFDN0MsSUFDRUMsQ0FBQUEsR0FBQUEsbUJBQUFBLGlCQUFpQixFQUFDRCxVQUNsQkUsQ0FBQUEsR0FBQUEsY0FBQUEsbUJBQW1CLEVBQUNGLFVBQ3BCRyxDQUFBQSxHQUFBQSxvQkFBQUEsb0JBQW9CLEVBQUNILFVBQ3JCSSxDQUFBQSxHQUFBQSxrQkFBQUEsaUJBQWlCLEVBQUNKLFVBQ2xCSyxDQUFBQSxHQUFBQSxZQUFBQSxVQUFVLEVBQUNMLFVBQ1hNLENBQUFBLEdBQUFBLHVCQUFBQSw4QkFBOEIsRUFBQ04sUUFDL0I7UUFDQSxNQUFNQTtJQUNSO0lBRUEsSUFBSUEsaUJBQWlCTyxTQUFTLFdBQVdQLE9BQU87UUFDOUNELGlCQUFpQkMsTUFBTVEsS0FBSztJQUM5QjtBQUNGIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDE0NTgsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvY2xpZW50L2NvbXBvbmVudHMvdW5zdGFibGUtcmV0aHJvdy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIHVzZWQgdG8gcmV0aHJvdyBpbnRlcm5hbCBOZXh0LmpzIGVycm9ycyBzbyB0aGF0IHRoZXkgY2FuIGJlIGhhbmRsZWQgYnkgdGhlIGZyYW1ld29yay5cbiAqIFdoZW4gd3JhcHBpbmcgYW4gQVBJIHRoYXQgdXNlcyBlcnJvcnMgdG8gaW50ZXJydXB0IGNvbnRyb2wgZmxvdywgeW91IHNob3VsZCB1c2UgdGhpcyBmdW5jdGlvbiBiZWZvcmUgeW91IGRvIGFueSBlcnJvciBoYW5kbGluZy5cbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCByZXRocm93IHRoZSBlcnJvciBpZiBpdCBpcyBhIE5leHQuanMgZXJyb3Igc28gaXQgY2FuIGJlIGhhbmRsZWQsIG90aGVyd2lzZSBpdCB3aWxsIGRvIG5vdGhpbmcuXG4gKlxuICogUmVhZCBtb3JlOiBbTmV4dC5qcyBEb2NzOiBgdW5zdGFibGVfcmV0aHJvd2BdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9hcGktcmVmZXJlbmNlL2Z1bmN0aW9ucy91bnN0YWJsZV9yZXRocm93KVxuICovXG5leHBvcnQgY29uc3QgdW5zdGFibGVfcmV0aHJvdyA9XG4gIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnXG4gICAgPyAoXG4gICAgICAgIHJlcXVpcmUoJy4vdW5zdGFibGUtcmV0aHJvdy5zZXJ2ZXInKSBhcyB0eXBlb2YgaW1wb3J0KCcuL3Vuc3RhYmxlLXJldGhyb3cuc2VydmVyJylcbiAgICAgICkudW5zdGFibGVfcmV0aHJvd1xuICAgIDogKFxuICAgICAgICByZXF1aXJlKCcuL3Vuc3RhYmxlLXJldGhyb3cuYnJvd3NlcicpIGFzIHR5cGVvZiBpbXBvcnQoJy4vdW5zdGFibGUtcmV0aHJvdy5icm93c2VyJylcbiAgICAgICkudW5zdGFibGVfcmV0aHJvd1xuIl0sIm5hbWVzIjpbInVuc3RhYmxlX3JldGhyb3ciLCJ3aW5kb3ciLCJyZXF1aXJlIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0NBTUM7OzsrQkFDWUEsb0JBQUFBOzs7ZUFBQUE7OztBQUFOLE1BQU1BLG1CQUNYLE9BQU9DLFdBQVcscUJBRVpDLFFBQVEsd0hBQ1JGLGdCQUFnQixHQUVoQkUsUUFBUSw4QkFDUkYsZ0JBQWdCIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDE0ODcsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvY2xpZW50L2NvbXBvbmVudHMvbmF2aWdhdGlvbi5yZWFjdC1zZXJ2ZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBpbnRlcm5hbCAqL1xuY2xhc3MgUmVhZG9ubHlVUkxTZWFyY2hQYXJhbXNFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXG4gICAgICAnTWV0aG9kIHVuYXZhaWxhYmxlIG9uIGBSZWFkb25seVVSTFNlYXJjaFBhcmFtc2AuIFJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2FwaS1yZWZlcmVuY2UvZnVuY3Rpb25zL3VzZS1zZWFyY2gtcGFyYW1zI3VwZGF0aW5nLXNlYXJjaHBhcmFtcydcbiAgICApXG4gIH1cbn1cblxuY2xhc3MgUmVhZG9ubHlVUkxTZWFyY2hQYXJhbXMgZXh0ZW5kcyBVUkxTZWFyY2hQYXJhbXMge1xuICAvKiogQGRlcHJlY2F0ZWQgTWV0aG9kIHVuYXZhaWxhYmxlIG9uIGBSZWFkb25seVVSTFNlYXJjaFBhcmFtc2AuIFJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2FwaS1yZWZlcmVuY2UvZnVuY3Rpb25zL3VzZS1zZWFyY2gtcGFyYW1zI3VwZGF0aW5nLXNlYXJjaHBhcmFtcyAqL1xuICBhcHBlbmQoKSB7XG4gICAgdGhyb3cgbmV3IFJlYWRvbmx5VVJMU2VhcmNoUGFyYW1zRXJyb3IoKVxuICB9XG4gIC8qKiBAZGVwcmVjYXRlZCBNZXRob2QgdW5hdmFpbGFibGUgb24gYFJlYWRvbmx5VVJMU2VhcmNoUGFyYW1zYC4gUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYXBpLXJlZmVyZW5jZS9mdW5jdGlvbnMvdXNlLXNlYXJjaC1wYXJhbXMjdXBkYXRpbmctc2VhcmNocGFyYW1zICovXG4gIGRlbGV0ZSgpIHtcbiAgICB0aHJvdyBuZXcgUmVhZG9ubHlVUkxTZWFyY2hQYXJhbXNFcnJvcigpXG4gIH1cbiAgLyoqIEBkZXByZWNhdGVkIE1ldGhvZCB1bmF2YWlsYWJsZSBvbiBgUmVhZG9ubHlVUkxTZWFyY2hQYXJhbXNgLiBSZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9hcGktcmVmZXJlbmNlL2Z1bmN0aW9ucy91c2Utc2VhcmNoLXBhcmFtcyN1cGRhdGluZy1zZWFyY2hwYXJhbXMgKi9cbiAgc2V0KCkge1xuICAgIHRocm93IG5ldyBSZWFkb25seVVSTFNlYXJjaFBhcmFtc0Vycm9yKClcbiAgfVxuICAvKiogQGRlcHJlY2F0ZWQgTWV0aG9kIHVuYXZhaWxhYmxlIG9uIGBSZWFkb25seVVSTFNlYXJjaFBhcmFtc2AuIFJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2FwaS1yZWZlcmVuY2UvZnVuY3Rpb25zL3VzZS1zZWFyY2gtcGFyYW1zI3VwZGF0aW5nLXNlYXJjaHBhcmFtcyAqL1xuICBzb3J0KCkge1xuICAgIHRocm93IG5ldyBSZWFkb25seVVSTFNlYXJjaFBhcmFtc0Vycm9yKClcbiAgfVxufVxuXG5leHBvcnQgeyByZWRpcmVjdCwgcGVybWFuZW50UmVkaXJlY3QgfSBmcm9tICcuL3JlZGlyZWN0J1xuZXhwb3J0IHsgUmVkaXJlY3RUeXBlIH0gZnJvbSAnLi9yZWRpcmVjdC1lcnJvcidcbmV4cG9ydCB7IG5vdEZvdW5kIH0gZnJvbSAnLi9ub3QtZm91bmQnXG5leHBvcnQgeyBmb3JiaWRkZW4gfSBmcm9tICcuL2ZvcmJpZGRlbidcbmV4cG9ydCB7IHVuYXV0aG9yaXplZCB9IGZyb20gJy4vdW5hdXRob3JpemVkJ1xuZXhwb3J0IHsgdW5zdGFibGVfcmV0aHJvdyB9IGZyb20gJy4vdW5zdGFibGUtcmV0aHJvdydcbmV4cG9ydCB7IFJlYWRvbmx5VVJMU2VhcmNoUGFyYW1zIH1cbiJdLCJuYW1lcyI6WyJSZWFkb25seVVSTFNlYXJjaFBhcmFtcyIsIlJlZGlyZWN0VHlwZSIsImZvcmJpZGRlbiIsIm5vdEZvdW5kIiwicGVybWFuZW50UmVkaXJlY3QiLCJyZWRpcmVjdCIsInVuYXV0aG9yaXplZCIsInVuc3RhYmxlX3JldGhyb3ciLCJSZWFkb25seVVSTFNlYXJjaFBhcmFtc0Vycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIlVSTFNlYXJjaFBhcmFtcyIsImFwcGVuZCIsImRlbGV0ZSIsInNldCIsInNvcnQiXSwibWFwcGluZ3MiOiJBQUFBLGNBQWM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBa0NMQSx1QkFBdUIsRUFBQTtlQUF2QkE7O0lBTEFDLFlBQVksRUFBQTtlQUFaQSxlQUFBQSxZQUFZOztJQUVaQyxTQUFTLEVBQUE7ZUFBVEEsV0FBQUEsU0FBUzs7SUFEVEMsUUFBUSxFQUFBO2VBQVJBLFVBQUFBLFFBQVE7O0lBRkVDLGlCQUFpQixFQUFBO2VBQWpCQSxVQUFBQSxpQkFBaUI7O0lBQTNCQyxRQUFRLEVBQUE7ZUFBUkEsVUFBQUEsUUFBUTs7SUFJUkMsWUFBWSxFQUFBO2VBQVpBLGNBQUFBLFlBQVk7O0lBQ1pDLGdCQUFnQixFQUFBO2VBQWhCQSxpQkFBQUEsZ0JBQWdCOzs7MEJBTG1COytCQUNmOzBCQUNKOzJCQUNDOzhCQUNHO2lDQUNJO0FBaENqQyxNQUFNQyxxQ0FBcUNDO0lBQ3pDQyxhQUFjO1FBQ1osS0FBSyxDQUNIO0lBRUo7QUFDRjtBQUVBLE1BQU1WLGdDQUFnQ1c7SUFDcEMsd0tBQXdLLEdBQ3hLQyxTQUFTO1FBQ1AsTUFBTSxJQUFJSjtJQUNaO0lBQ0Esd0tBQXdLLEdBQ3hLSyxTQUFTO1FBQ1AsTUFBTSxJQUFJTDtJQUNaO0lBQ0Esd0tBQXdLLEdBQ3hLTSxNQUFNO1FBQ0osTUFBTSxJQUFJTjtJQUNaO0lBQ0Esd0tBQXdLLEdBQ3hLTyxPQUFPO1FBQ0wsTUFBTSxJQUFJUDtJQUNaO0FBQ0YiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTU3MCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvY29tcG9uZW50cy9iYWlsb3V0LXRvLWNsaWVudC1yZW5kZXJpbmcudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmFpbG91dFRvQ1NSRXJyb3IgfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL2xhenktZHluYW1pYy9iYWlsb3V0LXRvLWNzcidcbmltcG9ydCB7IHdvcmtBc3luY1N0b3JhZ2UgfSBmcm9tICcuLi8uLi9zZXJ2ZXIvYXBwLXJlbmRlci93b3JrLWFzeW5jLXN0b3JhZ2UuZXh0ZXJuYWwnXG5pbXBvcnQgeyB3b3JrVW5pdEFzeW5jU3RvcmFnZSB9IGZyb20gJy4uLy4uL3NlcnZlci9hcHAtcmVuZGVyL3dvcmstdW5pdC1hc3luYy1zdG9yYWdlLmV4dGVybmFsJ1xuXG5leHBvcnQgZnVuY3Rpb24gYmFpbG91dFRvQ2xpZW50UmVuZGVyaW5nKHJlYXNvbjogc3RyaW5nKTogdm9pZCB8IG5ldmVyIHtcbiAgY29uc3Qgd29ya1N0b3JlID0gd29ya0FzeW5jU3RvcmFnZS5nZXRTdG9yZSgpXG5cbiAgaWYgKHdvcmtTdG9yZT8uZm9yY2VTdGF0aWMpIHJldHVyblxuXG4gIGNvbnN0IHdvcmtVbml0U3RvcmUgPSB3b3JrVW5pdEFzeW5jU3RvcmFnZS5nZXRTdG9yZSgpXG5cbiAgaWYgKHdvcmtVbml0U3RvcmUpIHtcbiAgICBzd2l0Y2ggKHdvcmtVbml0U3RvcmUudHlwZSkge1xuICAgICAgY2FzZSAncHJlcmVuZGVyJzpcbiAgICAgIGNhc2UgJ3ByZXJlbmRlci1jbGllbnQnOlxuICAgICAgY2FzZSAncHJlcmVuZGVyLXBwcic6XG4gICAgICBjYXNlICdwcmVyZW5kZXItbGVnYWN5JzpcbiAgICAgICAgdGhyb3cgbmV3IEJhaWxvdXRUb0NTUkVycm9yKHJlYXNvbilcbiAgICAgIGRlZmF1bHQ6XG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOlsiYmFpbG91dFRvQ2xpZW50UmVuZGVyaW5nIiwicmVhc29uIiwid29ya1N0b3JlIiwid29ya0FzeW5jU3RvcmFnZSIsImdldFN0b3JlIiwiZm9yY2VTdGF0aWMiLCJ3b3JrVW5pdFN0b3JlIiwid29ya1VuaXRBc3luY1N0b3JhZ2UiLCJ0eXBlIiwiQmFpbG91dFRvQ1NSRXJyb3IiXSwibWFwcGluZ3MiOiI7OzsrQkFJZ0JBLDRCQUFBQTs7O2VBQUFBOzs7OEJBSmtCOzBDQUNEOzhDQUNJO0FBRTlCLFNBQVNBLHlCQUF5QkMsTUFBYztJQUNyRCxNQUFNQyxZQUFZQywwQkFBQUEsZ0JBQWdCLENBQUNDLFFBQVE7SUFFM0MsSUFBSUYsYUFBQUEsT0FBQUEsS0FBQUEsSUFBQUEsVUFBV0csV0FBVyxFQUFFO0lBRTVCLE1BQU1DLGdCQUFnQkMsOEJBQUFBLG9CQUFvQixDQUFDSCxRQUFRO0lBRW5ELElBQUlFLGVBQWU7UUFDakIsT0FBUUEsY0FBY0UsSUFBSTtZQUN4QixLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO2dCQUNILE1BQU0sT0FBQSxjQUE2QixDQUE3QixJQUFJQyxjQUFBQSxpQkFBaUIsQ0FBQ1IsU0FBdEIscUJBQUE7MkJBQUE7Z0NBQUE7a0NBQUE7Z0JBQTRCO1lBQ3BDO1FBQ0Y7SUFDRjtBQUNGIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDE2MTQsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvY2xpZW50L2NvbXBvbmVudHMvbmF2aWdhdGlvbi50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IEZsaWdodFJvdXRlclN0YXRlIH0gZnJvbSAnLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvdHlwZXMnXG5pbXBvcnQgdHlwZSB7IFBhcmFtcyB9IGZyb20gJy4uLy4uL3NlcnZlci9yZXF1ZXN0L3BhcmFtcydcblxuaW1wb3J0IHsgdXNlQ29udGV4dCwgdXNlTWVtbyB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHtcbiAgQXBwUm91dGVyQ29udGV4dCxcbiAgTGF5b3V0Um91dGVyQ29udGV4dCxcbiAgdHlwZSBBcHBSb3V0ZXJJbnN0YW5jZSxcbn0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQge1xuICBTZWFyY2hQYXJhbXNDb250ZXh0LFxuICBQYXRobmFtZUNvbnRleHQsXG4gIFBhdGhQYXJhbXNDb250ZXh0LFxufSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL2hvb2tzLWNsaWVudC1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHsgZ2V0U2VnbWVudFZhbHVlIH0gZnJvbSAnLi9yb3V0ZXItcmVkdWNlci9yZWR1Y2Vycy9nZXQtc2VnbWVudC12YWx1ZSdcbmltcG9ydCB7IFBBR0VfU0VHTUVOVF9LRVksIERFRkFVTFRfU0VHTUVOVF9LRVkgfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL3NlZ21lbnQnXG5pbXBvcnQgeyBSZWFkb25seVVSTFNlYXJjaFBhcmFtcyB9IGZyb20gJy4vbmF2aWdhdGlvbi5yZWFjdC1zZXJ2ZXInXG5cbmNvbnN0IHVzZUR5bmFtaWNSb3V0ZVBhcmFtcyA9XG4gIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnXG4gICAgPyAoXG4gICAgICAgIHJlcXVpcmUoJy4uLy4uL3NlcnZlci9hcHAtcmVuZGVyL2R5bmFtaWMtcmVuZGVyaW5nJykgYXMgdHlwZW9mIGltcG9ydCgnLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvZHluYW1pYy1yZW5kZXJpbmcnKVxuICAgICAgKS51c2VEeW5hbWljUm91dGVQYXJhbXNcbiAgICA6IHVuZGVmaW5lZFxuXG4vKipcbiAqIEEgW0NsaWVudCBDb21wb25lbnRdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL3JlbmRlcmluZy9jbGllbnQtY29tcG9uZW50cykgaG9va1xuICogdGhhdCBsZXRzIHlvdSAqcmVhZCogdGhlIGN1cnJlbnQgVVJMJ3Mgc2VhcmNoIHBhcmFtZXRlcnMuXG4gKlxuICogTGVhcm4gbW9yZSBhYm91dCBbYFVSTFNlYXJjaFBhcmFtc2Agb24gTUROXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvVVJMU2VhcmNoUGFyYW1zKVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogXCJ1c2UgY2xpZW50XCJcbiAqIGltcG9ydCB7IHVzZVNlYXJjaFBhcmFtcyB9IGZyb20gJ25leHQvbmF2aWdhdGlvbidcbiAqXG4gKiBleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBQYWdlKCkge1xuICogICBjb25zdCBzZWFyY2hQYXJhbXMgPSB1c2VTZWFyY2hQYXJhbXMoKVxuICogICBzZWFyY2hQYXJhbXMuZ2V0KCdmb28nKSAvLyByZXR1cm5zICdiYXInIHdoZW4gP2Zvbz1iYXJcbiAqICAgLy8gLi4uXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBSZWFkIG1vcmU6IFtOZXh0LmpzIERvY3M6IGB1c2VTZWFyY2hQYXJhbXNgXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYXBpLXJlZmVyZW5jZS9mdW5jdGlvbnMvdXNlLXNlYXJjaC1wYXJhbXMpXG4gKi9cbi8vIENsaWVudCBjb21wb25lbnRzIEFQSVxuZXhwb3J0IGZ1bmN0aW9uIHVzZVNlYXJjaFBhcmFtcygpOiBSZWFkb25seVVSTFNlYXJjaFBhcmFtcyB7XG4gIGNvbnN0IHNlYXJjaFBhcmFtcyA9IHVzZUNvbnRleHQoU2VhcmNoUGFyYW1zQ29udGV4dClcblxuICAvLyBJbiB0aGUgY2FzZSB3aGVyZSB0aGlzIGlzIGBudWxsYCwgdGhlIGNvbXBhdCB0eXBlcyBhZGRlZCBpblxuICAvLyBgbmV4dC1lbnYuZC50c2Agd2lsbCBhZGQgYSBuZXcgb3ZlcmxvYWQgdGhhdCBjaGFuZ2VzIHRoZSByZXR1cm4gdHlwZSB0b1xuICAvLyBpbmNsdWRlIGBudWxsYC5cbiAgY29uc3QgcmVhZG9ubHlTZWFyY2hQYXJhbXMgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoIXNlYXJjaFBhcmFtcykge1xuICAgICAgLy8gV2hlbiB0aGUgcm91dGVyIGlzIG5vdCByZWFkeSBpbiBwYWdlcywgd2Ugd29uJ3QgaGF2ZSB0aGUgc2VhcmNoIHBhcmFtc1xuICAgICAgLy8gYXZhaWxhYmxlLlxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFJlYWRvbmx5VVJMU2VhcmNoUGFyYW1zKHNlYXJjaFBhcmFtcylcbiAgfSwgW3NlYXJjaFBhcmFtc10pIGFzIFJlYWRvbmx5VVJMU2VhcmNoUGFyYW1zXG5cbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gQXN5bmNMb2NhbFN0b3JhZ2Ugc2hvdWxkIG5vdCBiZSBpbmNsdWRlZCBpbiB0aGUgY2xpZW50IGJ1bmRsZS5cbiAgICBjb25zdCB7IGJhaWxvdXRUb0NsaWVudFJlbmRlcmluZyB9ID1cbiAgICAgIHJlcXVpcmUoJy4vYmFpbG91dC10by1jbGllbnQtcmVuZGVyaW5nJykgYXMgdHlwZW9mIGltcG9ydCgnLi9iYWlsb3V0LXRvLWNsaWVudC1yZW5kZXJpbmcnKVxuICAgIC8vIFRPRE8tQVBQOiBoYW5kbGUgZHluYW1pYyA9ICdmb3JjZS1zdGF0aWMnIGhlcmUgYW5kIG9uIHRoZSBjbGllbnRcbiAgICBiYWlsb3V0VG9DbGllbnRSZW5kZXJpbmcoJ3VzZVNlYXJjaFBhcmFtcygpJylcbiAgfVxuXG4gIHJldHVybiByZWFkb25seVNlYXJjaFBhcmFtc1xufVxuXG4vKipcbiAqIEEgW0NsaWVudCBDb21wb25lbnRdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL3JlbmRlcmluZy9jbGllbnQtY29tcG9uZW50cykgaG9va1xuICogdGhhdCBsZXRzIHlvdSByZWFkIHRoZSBjdXJyZW50IFVSTCdzIHBhdGhuYW1lLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogXCJ1c2UgY2xpZW50XCJcbiAqIGltcG9ydCB7IHVzZVBhdGhuYW1lIH0gZnJvbSAnbmV4dC9uYXZpZ2F0aW9uJ1xuICpcbiAqIGV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFBhZ2UoKSB7XG4gKiAgY29uc3QgcGF0aG5hbWUgPSB1c2VQYXRobmFtZSgpIC8vIHJldHVybnMgXCIvZGFzaGJvYXJkXCIgb24gL2Rhc2hib2FyZD9mb289YmFyXG4gKiAgLy8gLi4uXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBSZWFkIG1vcmU6IFtOZXh0LmpzIERvY3M6IGB1c2VQYXRobmFtZWBdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9hcGktcmVmZXJlbmNlL2Z1bmN0aW9ucy91c2UtcGF0aG5hbWUpXG4gKi9cbi8vIENsaWVudCBjb21wb25lbnRzIEFQSVxuZXhwb3J0IGZ1bmN0aW9uIHVzZVBhdGhuYW1lKCk6IHN0cmluZyB7XG4gIHVzZUR5bmFtaWNSb3V0ZVBhcmFtcz8uKCd1c2VQYXRobmFtZSgpJylcblxuICAvLyBJbiB0aGUgY2FzZSB3aGVyZSB0aGlzIGlzIGBudWxsYCwgdGhlIGNvbXBhdCB0eXBlcyBhZGRlZCBpbiBgbmV4dC1lbnYuZC50c2BcbiAgLy8gd2lsbCBhZGQgYSBuZXcgb3ZlcmxvYWQgdGhhdCBjaGFuZ2VzIHRoZSByZXR1cm4gdHlwZSB0byBpbmNsdWRlIGBudWxsYC5cbiAgcmV0dXJuIHVzZUNvbnRleHQoUGF0aG5hbWVDb250ZXh0KSBhcyBzdHJpbmdcbn1cblxuLy8gQ2xpZW50IGNvbXBvbmVudHMgQVBJXG5leHBvcnQge1xuICBTZXJ2ZXJJbnNlcnRlZEhUTUxDb250ZXh0LFxuICB1c2VTZXJ2ZXJJbnNlcnRlZEhUTUwsXG59IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvc2VydmVyLWluc2VydGVkLWh0bWwuc2hhcmVkLXJ1bnRpbWUnXG5cbi8qKlxuICpcbiAqIFRoaXMgaG9vayBhbGxvd3MgeW91IHRvIHByb2dyYW1tYXRpY2FsbHkgY2hhbmdlIHJvdXRlcyBpbnNpZGUgW0NsaWVudCBDb21wb25lbnRdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL3JlbmRlcmluZy9jbGllbnQtY29tcG9uZW50cykuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBcInVzZSBjbGllbnRcIlxuICogaW1wb3J0IHsgdXNlUm91dGVyIH0gZnJvbSAnbmV4dC9uYXZpZ2F0aW9uJ1xuICpcbiAqIGV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFBhZ2UoKSB7XG4gKiAgY29uc3Qgcm91dGVyID0gdXNlUm91dGVyKClcbiAqICAvLyAuLi5cbiAqICByb3V0ZXIucHVzaCgnL2Rhc2hib2FyZCcpIC8vIE5hdmlnYXRlIHRvIC9kYXNoYm9hcmRcbiAqIH1cbiAqIGBgYFxuICpcbiAqIFJlYWQgbW9yZTogW05leHQuanMgRG9jczogYHVzZVJvdXRlcmBdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9hcGktcmVmZXJlbmNlL2Z1bmN0aW9ucy91c2Utcm91dGVyKVxuICovXG4vLyBDbGllbnQgY29tcG9uZW50cyBBUElcbmV4cG9ydCBmdW5jdGlvbiB1c2VSb3V0ZXIoKTogQXBwUm91dGVySW5zdGFuY2Uge1xuICBjb25zdCByb3V0ZXIgPSB1c2VDb250ZXh0KEFwcFJvdXRlckNvbnRleHQpXG4gIGlmIChyb3V0ZXIgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCBleHBlY3RlZCBhcHAgcm91dGVyIHRvIGJlIG1vdW50ZWQnKVxuICB9XG5cbiAgcmV0dXJuIHJvdXRlclxufVxuXG4vKipcbiAqIEEgW0NsaWVudCBDb21wb25lbnRdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL3JlbmRlcmluZy9jbGllbnQtY29tcG9uZW50cykgaG9va1xuICogdGhhdCBsZXRzIHlvdSByZWFkIGEgcm91dGUncyBkeW5hbWljIHBhcmFtcyBmaWxsZWQgaW4gYnkgdGhlIGN1cnJlbnQgVVJMLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogXCJ1c2UgY2xpZW50XCJcbiAqIGltcG9ydCB7IHVzZVBhcmFtcyB9IGZyb20gJ25leHQvbmF2aWdhdGlvbidcbiAqXG4gKiBleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBQYWdlKCkge1xuICogICAvLyBvbiAvZGFzaGJvYXJkL1t0ZWFtXSB3aGVyZSBwYXRobmFtZSBpcyAvZGFzaGJvYXJkL25leHRqc1xuICogICBjb25zdCB7IHRlYW0gfSA9IHVzZVBhcmFtcygpIC8vIHRlYW0gPT09IFwibmV4dGpzXCJcbiAqIH1cbiAqIGBgYFxuICpcbiAqIFJlYWQgbW9yZTogW05leHQuanMgRG9jczogYHVzZVBhcmFtc2BdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9hcGktcmVmZXJlbmNlL2Z1bmN0aW9ucy91c2UtcGFyYW1zKVxuICovXG4vLyBDbGllbnQgY29tcG9uZW50cyBBUElcbmV4cG9ydCBmdW5jdGlvbiB1c2VQYXJhbXM8VCBleHRlbmRzIFBhcmFtcyA9IFBhcmFtcz4oKTogVCB7XG4gIHVzZUR5bmFtaWNSb3V0ZVBhcmFtcz8uKCd1c2VQYXJhbXMoKScpXG5cbiAgcmV0dXJuIHVzZUNvbnRleHQoUGF0aFBhcmFtc0NvbnRleHQpIGFzIFRcbn1cblxuLyoqIEdldCB0aGUgY2Fub25pY2FsIHBhcmFtZXRlcnMgZnJvbSB0aGUgY3VycmVudCBsZXZlbCB0byB0aGUgbGVhZiBub2RlLiAqL1xuLy8gQ2xpZW50IGNvbXBvbmVudHMgQVBJXG5mdW5jdGlvbiBnZXRTZWxlY3RlZExheW91dFNlZ21lbnRQYXRoKFxuICB0cmVlOiBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgcGFyYWxsZWxSb3V0ZUtleTogc3RyaW5nLFxuICBmaXJzdCA9IHRydWUsXG4gIHNlZ21lbnRQYXRoOiBzdHJpbmdbXSA9IFtdXG4pOiBzdHJpbmdbXSB7XG4gIGxldCBub2RlOiBGbGlnaHRSb3V0ZXJTdGF0ZVxuICBpZiAoZmlyc3QpIHtcbiAgICAvLyBVc2UgdGhlIHByb3ZpZGVkIHBhcmFsbGVsIHJvdXRlIGtleSBvbiB0aGUgZmlyc3QgcGFyYWxsZWwgcm91dGVcbiAgICBub2RlID0gdHJlZVsxXVtwYXJhbGxlbFJvdXRlS2V5XVxuICB9IGVsc2Uge1xuICAgIC8vIEFmdGVyIGZpcnN0IHBhcmFsbGVsIHJvdXRlIHByZWZlciBjaGlsZHJlbiwgaWYgdGhlcmUncyBubyBjaGlsZHJlbiBwaWNrIHRoZSBmaXJzdCBwYXJhbGxlbCByb3V0ZS5cbiAgICBjb25zdCBwYXJhbGxlbFJvdXRlcyA9IHRyZWVbMV1cbiAgICBub2RlID0gcGFyYWxsZWxSb3V0ZXMuY2hpbGRyZW4gPz8gT2JqZWN0LnZhbHVlcyhwYXJhbGxlbFJvdXRlcylbMF1cbiAgfVxuXG4gIGlmICghbm9kZSkgcmV0dXJuIHNlZ21lbnRQYXRoXG4gIGNvbnN0IHNlZ21lbnQgPSBub2RlWzBdXG5cbiAgbGV0IHNlZ21lbnRWYWx1ZSA9IGdldFNlZ21lbnRWYWx1ZShzZWdtZW50KVxuXG4gIGlmICghc2VnbWVudFZhbHVlIHx8IHNlZ21lbnRWYWx1ZS5zdGFydHNXaXRoKFBBR0VfU0VHTUVOVF9LRVkpKSB7XG4gICAgcmV0dXJuIHNlZ21lbnRQYXRoXG4gIH1cblxuICBzZWdtZW50UGF0aC5wdXNoKHNlZ21lbnRWYWx1ZSlcblxuICByZXR1cm4gZ2V0U2VsZWN0ZWRMYXlvdXRTZWdtZW50UGF0aChcbiAgICBub2RlLFxuICAgIHBhcmFsbGVsUm91dGVLZXksXG4gICAgZmFsc2UsXG4gICAgc2VnbWVudFBhdGhcbiAgKVxufVxuXG4vKipcbiAqIEEgW0NsaWVudCBDb21wb25lbnRdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL3JlbmRlcmluZy9jbGllbnQtY29tcG9uZW50cykgaG9va1xuICogdGhhdCBsZXRzIHlvdSByZWFkIHRoZSBhY3RpdmUgcm91dGUgc2VnbWVudHMgKipiZWxvdyoqIHRoZSBMYXlvdXQgaXQgaXMgY2FsbGVkIGZyb20uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiAndXNlIGNsaWVudCdcbiAqXG4gKiBpbXBvcnQgeyB1c2VTZWxlY3RlZExheW91dFNlZ21lbnRzIH0gZnJvbSAnbmV4dC9uYXZpZ2F0aW9uJ1xuICpcbiAqIGV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEV4YW1wbGVDbGllbnRDb21wb25lbnQoKSB7XG4gKiAgIGNvbnN0IHNlZ21lbnRzID0gdXNlU2VsZWN0ZWRMYXlvdXRTZWdtZW50cygpXG4gKlxuICogICByZXR1cm4gKFxuICogICAgIDx1bD5cbiAqICAgICAgIHtzZWdtZW50cy5tYXAoKHNlZ21lbnQsIGluZGV4KSA9PiAoXG4gKiAgICAgICAgIDxsaSBrZXk9e2luZGV4fT57c2VnbWVudH08L2xpPlxuICogICAgICAgKSl9XG4gKiAgICAgPC91bD5cbiAqICAgKVxuICogfVxuICogYGBgXG4gKlxuICogUmVhZCBtb3JlOiBbTmV4dC5qcyBEb2NzOiBgdXNlU2VsZWN0ZWRMYXlvdXRTZWdtZW50c2BdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9hcGktcmVmZXJlbmNlL2Z1bmN0aW9ucy91c2Utc2VsZWN0ZWQtbGF5b3V0LXNlZ21lbnRzKVxuICovXG4vLyBDbGllbnQgY29tcG9uZW50cyBBUElcbmV4cG9ydCBmdW5jdGlvbiB1c2VTZWxlY3RlZExheW91dFNlZ21lbnRzKFxuICBwYXJhbGxlbFJvdXRlS2V5OiBzdHJpbmcgPSAnY2hpbGRyZW4nXG4pOiBzdHJpbmdbXSB7XG4gIHVzZUR5bmFtaWNSb3V0ZVBhcmFtcz8uKCd1c2VTZWxlY3RlZExheW91dFNlZ21lbnRzKCknKVxuXG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KExheW91dFJvdXRlckNvbnRleHQpXG4gIC8vIEB0cy1leHBlY3QtZXJyb3IgVGhpcyBvbmx5IGhhcHBlbnMgaW4gYHBhZ2VzYC4gVHlwZSBpcyBvdmVyd3JpdHRlbiBpbiBuYXZpZ2F0aW9uLmQudHNcbiAgaWYgKCFjb250ZXh0KSByZXR1cm4gbnVsbFxuXG4gIHJldHVybiBnZXRTZWxlY3RlZExheW91dFNlZ21lbnRQYXRoKGNvbnRleHQucGFyZW50VHJlZSwgcGFyYWxsZWxSb3V0ZUtleSlcbn1cblxuLyoqXG4gKiBBIFtDbGllbnQgQ29tcG9uZW50XShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYnVpbGRpbmcteW91ci1hcHBsaWNhdGlvbi9yZW5kZXJpbmcvY2xpZW50LWNvbXBvbmVudHMpIGhvb2tcbiAqIHRoYXQgbGV0cyB5b3UgcmVhZCB0aGUgYWN0aXZlIHJvdXRlIHNlZ21lbnQgKipvbmUgbGV2ZWwgYmVsb3cqKiB0aGUgTGF5b3V0IGl0IGlzIGNhbGxlZCBmcm9tLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogJ3VzZSBjbGllbnQnXG4gKiBpbXBvcnQgeyB1c2VTZWxlY3RlZExheW91dFNlZ21lbnQgfSBmcm9tICduZXh0L25hdmlnYXRpb24nXG4gKlxuICogZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRXhhbXBsZUNsaWVudENvbXBvbmVudCgpIHtcbiAqICAgY29uc3Qgc2VnbWVudCA9IHVzZVNlbGVjdGVkTGF5b3V0U2VnbWVudCgpXG4gKlxuICogICByZXR1cm4gPHA+QWN0aXZlIHNlZ21lbnQ6IHtzZWdtZW50fTwvcD5cbiAqIH1cbiAqIGBgYFxuICpcbiAqIFJlYWQgbW9yZTogW05leHQuanMgRG9jczogYHVzZVNlbGVjdGVkTGF5b3V0U2VnbWVudGBdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9hcGktcmVmZXJlbmNlL2Z1bmN0aW9ucy91c2Utc2VsZWN0ZWQtbGF5b3V0LXNlZ21lbnQpXG4gKi9cbi8vIENsaWVudCBjb21wb25lbnRzIEFQSVxuZXhwb3J0IGZ1bmN0aW9uIHVzZVNlbGVjdGVkTGF5b3V0U2VnbWVudChcbiAgcGFyYWxsZWxSb3V0ZUtleTogc3RyaW5nID0gJ2NoaWxkcmVuJ1xuKTogc3RyaW5nIHwgbnVsbCB7XG4gIHVzZUR5bmFtaWNSb3V0ZVBhcmFtcz8uKCd1c2VTZWxlY3RlZExheW91dFNlZ21lbnQoKScpXG5cbiAgY29uc3Qgc2VsZWN0ZWRMYXlvdXRTZWdtZW50cyA9IHVzZVNlbGVjdGVkTGF5b3V0U2VnbWVudHMocGFyYWxsZWxSb3V0ZUtleSlcblxuICBpZiAoIXNlbGVjdGVkTGF5b3V0U2VnbWVudHMgfHwgc2VsZWN0ZWRMYXlvdXRTZWdtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgY29uc3Qgc2VsZWN0ZWRMYXlvdXRTZWdtZW50ID1cbiAgICBwYXJhbGxlbFJvdXRlS2V5ID09PSAnY2hpbGRyZW4nXG4gICAgICA/IHNlbGVjdGVkTGF5b3V0U2VnbWVudHNbMF1cbiAgICAgIDogc2VsZWN0ZWRMYXlvdXRTZWdtZW50c1tzZWxlY3RlZExheW91dFNlZ21lbnRzLmxlbmd0aCAtIDFdXG5cbiAgLy8gaWYgdGhlIGRlZmF1bHQgc2xvdCBpcyBzaG93aW5nLCB3ZSByZXR1cm4gbnVsbCBzaW5jZSBpdCdzIG5vdCB0ZWNobmljYWxseSBcInNlbGVjdGVkXCIgKGl0J3MgYSBmYWxsYmFjaylcbiAgLy8gYW5kIHJldHVybmluZyBhbiBpbnRlcm5hbCB2YWx1ZSBsaWtlIGBfX0RFRkFVTFRfX2Agd291bGQgYmUgY29uZnVzaW5nLlxuICByZXR1cm4gc2VsZWN0ZWRMYXlvdXRTZWdtZW50ID09PSBERUZBVUxUX1NFR01FTlRfS0VZXG4gICAgPyBudWxsXG4gICAgOiBzZWxlY3RlZExheW91dFNlZ21lbnRcbn1cblxuLy8gU2hhcmVkIGNvbXBvbmVudHMgQVBJc1xuZXhwb3J0IHtcbiAgbm90Rm91bmQsXG4gIGZvcmJpZGRlbixcbiAgdW5hdXRob3JpemVkLFxuICByZWRpcmVjdCxcbiAgcGVybWFuZW50UmVkaXJlY3QsXG4gIFJlZGlyZWN0VHlwZSxcbiAgUmVhZG9ubHlVUkxTZWFyY2hQYXJhbXMsXG4gIHVuc3RhYmxlX3JldGhyb3csXG59IGZyb20gJy4vbmF2aWdhdGlvbi5yZWFjdC1zZXJ2ZXInXG4iXSwibmFtZXMiOlsiUmVhZG9ubHlVUkxTZWFyY2hQYXJhbXMiLCJSZWRpcmVjdFR5cGUiLCJTZXJ2ZXJJbnNlcnRlZEhUTUxDb250ZXh0IiwiZm9yYmlkZGVuIiwibm90Rm91bmQiLCJwZXJtYW5lbnRSZWRpcmVjdCIsInJlZGlyZWN0IiwidW5hdXRob3JpemVkIiwidW5zdGFibGVfcmV0aHJvdyIsInVzZVBhcmFtcyIsInVzZVBhdGhuYW1lIiwidXNlUm91dGVyIiwidXNlU2VhcmNoUGFyYW1zIiwidXNlU2VsZWN0ZWRMYXlvdXRTZWdtZW50IiwidXNlU2VsZWN0ZWRMYXlvdXRTZWdtZW50cyIsInVzZVNlcnZlckluc2VydGVkSFRNTCIsInVzZUR5bmFtaWNSb3V0ZVBhcmFtcyIsIndpbmRvdyIsInJlcXVpcmUiLCJ1bmRlZmluZWQiLCJzZWFyY2hQYXJhbXMiLCJ1c2VDb250ZXh0IiwiU2VhcmNoUGFyYW1zQ29udGV4dCIsInJlYWRvbmx5U2VhcmNoUGFyYW1zIiwidXNlTWVtbyIsImJhaWxvdXRUb0NsaWVudFJlbmRlcmluZyIsIlBhdGhuYW1lQ29udGV4dCIsInJvdXRlciIsIkFwcFJvdXRlckNvbnRleHQiLCJFcnJvciIsIlBhdGhQYXJhbXNDb250ZXh0IiwiZ2V0U2VsZWN0ZWRMYXlvdXRTZWdtZW50UGF0aCIsInRyZWUiLCJwYXJhbGxlbFJvdXRlS2V5IiwiZmlyc3QiLCJzZWdtZW50UGF0aCIsIm5vZGUiLCJwYXJhbGxlbFJvdXRlcyIsImNoaWxkcmVuIiwiT2JqZWN0IiwidmFsdWVzIiwic2VnbWVudCIsInNlZ21lbnRWYWx1ZSIsImdldFNlZ21lbnRWYWx1ZSIsInN0YXJ0c1dpdGgiLCJQQUdFX1NFR01FTlRfS0VZIiwicHVzaCIsImNvbnRleHQiLCJMYXlvdXRSb3V0ZXJDb250ZXh0IiwicGFyZW50VHJlZSIsInNlbGVjdGVkTGF5b3V0U2VnbWVudHMiLCJsZW5ndGgiLCJzZWxlY3RlZExheW91dFNlZ21lbnQiLCJERUZBVUxUX1NFR01FTlRfS0VZIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBMFJFQSx1QkFBdUIsRUFBQTtlQUF2QkEsdUJBQUFBLHVCQUF1Qjs7SUFEdkJDLFlBQVksRUFBQTtlQUFaQSx1QkFBQUEsWUFBWTs7SUFwTFpDLHlCQUF5QixFQUFBO2VBQXpCQSxpQ0FBQUEseUJBQXlCOztJQWdMekJDLFNBQVMsRUFBQTtlQUFUQSx1QkFB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b2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9uYXZpZ2F0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0L2NsaWVudC9jb21wb25lbnRzL25hdmlnYXRpb24nKVxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sT0FBTyIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxODA1LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3F1ZXJ5c3RyaW5nLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgUGFyc2VkVXJsUXVlcnkgfSBmcm9tICdxdWVyeXN0cmluZydcblxuZXhwb3J0IGZ1bmN0aW9uIHNlYXJjaFBhcmFtc1RvVXJsUXVlcnkoXG4gIHNlYXJjaFBhcmFtczogVVJMU2VhcmNoUGFyYW1zXG4pOiBQYXJzZWRVcmxRdWVyeSB7XG4gIGNvbnN0IHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeSA9IHt9XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHNlYXJjaFBhcmFtcy5lbnRyaWVzKCkpIHtcbiAgICBjb25zdCBleGlzdGluZyA9IHF1ZXJ5W2tleV1cbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcXVlcnlba2V5XSA9IHZhbHVlXG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGV4aXN0aW5nKSkge1xuICAgICAgZXhpc3RpbmcucHVzaCh2YWx1ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgcXVlcnlba2V5XSA9IFtleGlzdGluZywgdmFsdWVdXG4gICAgfVxuICB9XG4gIHJldHVybiBxdWVyeVxufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlVcmxRdWVyeVBhcmFtKHBhcmFtOiB1bmtub3duKTogc3RyaW5nIHtcbiAgaWYgKHR5cGVvZiBwYXJhbSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGFyYW1cbiAgfVxuXG4gIGlmIChcbiAgICAodHlwZW9mIHBhcmFtID09PSAnbnVtYmVyJyAmJiAhaXNOYU4ocGFyYW0pKSB8fFxuICAgIHR5cGVvZiBwYXJhbSA9PT0gJ2Jvb2xlYW4nXG4gICkge1xuICAgIHJldHVybiBTdHJpbmcocGFyYW0pXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICcnXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVybFF1ZXJ5VG9TZWFyY2hQYXJhbXMocXVlcnk6IFBhcnNlZFVybFF1ZXJ5KTogVVJMU2VhcmNoUGFyYW1zIHtcbiAgY29uc3Qgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpXG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHF1ZXJ5KSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHZhbHVlKSB7XG4gICAgICAgIHNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCBzdHJpbmdpZnlVcmxRdWVyeVBhcmFtKGl0ZW0pKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzZWFyY2hQYXJhbXMuc2V0KGtleSwgc3RyaW5naWZ5VXJsUXVlcnlQYXJhbSh2YWx1ZSkpXG4gICAgfVxuICB9XG4gIHJldHVybiBzZWFyY2hQYXJhbXNcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbihcbiAgdGFyZ2V0OiBVUkxTZWFyY2hQYXJhbXMsXG4gIC4uLnNlYXJjaFBhcmFtc0xpc3Q6IFVSTFNlYXJjaFBhcmFtc1tdXG4pOiBVUkxTZWFyY2hQYXJhbXMge1xuICBmb3IgKGNvbnN0IHNlYXJjaFBhcmFtcyBvZiBzZWFyY2hQYXJhbXNMaXN0KSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2Ygc2VhcmNoUGFyYW1zLmtleXMoKSkge1xuICAgICAgdGFyZ2V0LmRlbGV0ZShrZXkpXG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Ygc2VhcmNoUGFyYW1zLmVudHJpZXMoKSkge1xuICAgICAgdGFyZ2V0LmFwcGVuZChrZXksIHZhbHVlKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXRcbn1cbiJdLCJuYW1lcyI6WyJhc3NpZ24iLCJzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5IiwidXJsUXVlcnlUb1NlYXJjaFBhcmFtcyIsInNlYXJjaFBhcmFtcyIsInF1ZXJ5Iiwia2V5IiwidmFsdWUiLCJlbnRyaWVzIiwiZXhpc3RpbmciLCJBcnJheSIsImlzQXJyYXkiLCJwdXNoIiwic3RyaW5naWZ5VXJsUXVlcnlQYXJhbSIsInBhcmFtIiwiaXNOYU4iLCJTdHJpbmciLCJVUkxTZWFyY2hQYXJhbXMiLCJPYmplY3QiLCJpdGVtIiwiYXBwZW5kIiwic2V0IiwidGFyZ2V0Iiwic2VhcmNoUGFyYW1zTGlzdCIsImtleXMiLCJkZWxldGUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztJQWdEZ0JBLE1BQU0sRUFBQTtlQUFOQTs7SUE5Q0FDLHNCQUFzQixFQUFBO2VBQXRCQTs7SUFnQ0FDLHNCQUFzQixFQUFBO2VBQXRCQTs7O0FBaENULFNBQVNELHVCQUNkRSxZQUE2QjtJQUU3QixNQUFNQyxRQUF3QixDQUFDO0lBQy9CLEtBQUssTUFBTSxDQUFDQyxLQUFLQyxNQUFNLElBQUlILGFBQWFJLE9BQU8sR0FBSTtRQUNqRCxNQUFNQyxXQUFXSixLQUFLLENBQUNDLElBQUk7UUFDM0IsSUFBSSxPQUFPRyxhQUFhLGFBQWE7WUFDbkNKLEtBQUssQ0FBQ0MsSUFBSSxHQUFHQztRQUNmLE9BQU8sSUFBSUcsTUFBTUMsT0FBTyxDQUFDRixXQUFXO1lBQ2xDQSxTQUFTRyxJQUFJLENBQUNMO1FBQ2hCLE9BQU87WUFDTEYsS0FBSyxDQUFDQyxJQUFJLEdBQUc7Z0JBQUNHO2dCQUFVRjthQUFNO1FBQ2hDO0lBQ0Y7SUFDQSxPQUFPRjtBQUNUO0FBRUEsU0FBU1EsdUJBQXVCQyxLQUFjO0lBQzVDLElBQUksT0FBT0EsVUFBVSxVQUFVO1FBQzdCLE9BQU9BO0lBQ1Q7SUFFQSxJQUNHLE9BQU9BLFVBQVUsWUFBWSxDQUFDQyxNQUFNRCxVQUNyQyxPQUFPQSxVQUFVLFdBQ2pCO1FBQ0EsT0FBT0UsT0FBT0Y7SUFDaEIsT0FBTztRQUNMLE9BQU87SUFDVDtBQUNGO0FBRU8sU0FBU1gsdUJBQXVCRSxLQUFxQjtJQUMxRCxNQUFNRCxlQUFlLElBQUlhO0lBQ3pCLEtBQUssTUFBTSxDQUFDWCxLQUFLQyxNQUFNLElBQUlXLE9BQU9WLE9BQU8sQ0FBQ0gsT0FBUTtRQUNoRCxJQUFJSyxNQUFNQyxPQUFPLENBQUNKLFFBQVE7WUFDeEIsS0FBSyxNQUFNWSxRQUFRWixNQUFPO2dCQUN4QkgsYUFBYWdCLE1BQU0sQ0FBQ2QsS0FBS08sdUJBQXVCTTtZQUNsRDtRQUNGLE9BQU87WUFDTGYsYUFBYWlCLEdBQUcsQ0FBQ2YsS0FBS08sdUJBQXVCTjtRQUMvQztJQUNGO0lBQ0EsT0FBT0g7QUFDVDtBQUVPLFNBQVNILE9BQ2RxQixNQUF1QjtJQUN2QixJQUFBLElBQUEsT0FBQSxVQUFBLE1BQUEsRUFBR0MsbUJBQUgsSUFBQSxNQUFBLE9BQUEsSUFBQSxPQUFBLElBQUEsSUFBQSxPQUFBLEdBQUEsT0FBQSxNQUFBLE9BQUE7UUFBR0EsZ0JBQUFBLENBQUgsT0FBQSxFQUFBLEdBQUEsU0FBQSxDQUFBLEtBQXNDOztJQUV0QyxLQUFLLE1BQU1uQixnQkFBZ0JtQixpQkFBa0I7UUFDM0MsS0FBSyxNQUFNakIsT0FBT0YsYUFBYW9CLElBQUksR0FBSTtZQUNyQ0YsT0FBT0csTUFBTSxDQUFDbkI7UUFDaEI7UUFFQSxLQUFLLE1BQU0sQ0FBQ0EsS0FBS0MsTUFBTSxJQUFJSCxhQUFhSSxPQUFPLEdBQUk7WUFDakRjLE9BQU9GLE1BQU0sQ0FBQ2QsS0FBS0M7UUFDckI7SUFDRjtJQUVBLE9BQU9lO0FBQ1QiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTg5MCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9zaGFyZWQvbGliL3JvdXRlci91dGlscy9mb3JtYXQtdXJsLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEZvcm1hdCBmdW5jdGlvbiBtb2RpZmllZCBmcm9tIG5vZGVqc1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB0eXBlIHsgVXJsT2JqZWN0IH0gZnJvbSAndXJsJ1xuaW1wb3J0IHR5cGUgeyBQYXJzZWRVcmxRdWVyeSB9IGZyb20gJ3F1ZXJ5c3RyaW5nJ1xuaW1wb3J0ICogYXMgcXVlcnlzdHJpbmcgZnJvbSAnLi9xdWVyeXN0cmluZydcblxuY29uc3Qgc2xhc2hlZFByb3RvY29scyA9IC9odHRwcz98ZnRwfGdvcGhlcnxmaWxlL1xuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0VXJsKHVybE9iajogVXJsT2JqZWN0KSB7XG4gIGxldCB7IGF1dGgsIGhvc3RuYW1lIH0gPSB1cmxPYmpcbiAgbGV0IHByb3RvY29sID0gdXJsT2JqLnByb3RvY29sIHx8ICcnXG4gIGxldCBwYXRobmFtZSA9IHVybE9iai5wYXRobmFtZSB8fCAnJ1xuICBsZXQgaGFzaCA9IHVybE9iai5oYXNoIHx8ICcnXG4gIGxldCBxdWVyeSA9IHVybE9iai5xdWVyeSB8fCAnJ1xuICBsZXQgaG9zdDogc3RyaW5nIHwgZmFsc2UgPSBmYWxzZVxuXG4gIGF1dGggPSBhdXRoID8gZW5jb2RlVVJJQ29tcG9uZW50KGF1dGgpLnJlcGxhY2UoLyUzQS9pLCAnOicpICsgJ0AnIDogJydcblxuICBpZiAodXJsT2JqLmhvc3QpIHtcbiAgICBob3N0ID0gYXV0aCArIHVybE9iai5ob3N0XG4gIH0gZWxzZSBpZiAoaG9zdG5hbWUpIHtcbiAgICBob3N0ID0gYXV0aCArICh+aG9zdG5hbWUuaW5kZXhPZignOicpID8gYFske2hvc3RuYW1lfV1gIDogaG9zdG5hbWUpXG4gICAgaWYgKHVybE9iai5wb3J0KSB7XG4gICAgICBob3N0ICs9ICc6JyArIHVybE9iai5wb3J0XG4gICAgfVxuICB9XG5cbiAgaWYgKHF1ZXJ5ICYmIHR5cGVvZiBxdWVyeSA9PT0gJ29iamVjdCcpIHtcbiAgICBxdWVyeSA9IFN0cmluZyhxdWVyeXN0cmluZy51cmxRdWVyeVRvU2VhcmNoUGFyYW1zKHF1ZXJ5IGFzIFBhcnNlZFVybFF1ZXJ5KSlcbiAgfVxuXG4gIGxldCBzZWFyY2ggPSB1cmxPYmouc2VhcmNoIHx8IChxdWVyeSAmJiBgPyR7cXVlcnl9YCkgfHwgJydcblxuICBpZiAocHJvdG9jb2wgJiYgIXByb3RvY29sLmVuZHNXaXRoKCc6JykpIHByb3RvY29sICs9ICc6J1xuXG4gIGlmIChcbiAgICB1cmxPYmouc2xhc2hlcyB8fFxuICAgICgoIXByb3RvY29sIHx8IHNsYXNoZWRQcm90b2NvbHMudGVzdChwcm90b2NvbCkpICYmIGhvc3QgIT09IGZhbHNlKVxuICApIHtcbiAgICBob3N0ID0gJy8vJyArIChob3N0IHx8ICcnKVxuICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZVswXSAhPT0gJy8nKSBwYXRobmFtZSA9ICcvJyArIHBhdGhuYW1lXG4gIH0gZWxzZSBpZiAoIWhvc3QpIHtcbiAgICBob3N0ID0gJydcbiAgfVxuXG4gIGlmIChoYXNoICYmIGhhc2hbMF0gIT09ICcjJykgaGFzaCA9ICcjJyArIGhhc2hcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2hbMF0gIT09ICc/Jykgc2VhcmNoID0gJz8nICsgc2VhcmNoXG5cbiAgcGF0aG5hbWUgPSBwYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csIGVuY29kZVVSSUNvbXBvbmVudClcbiAgc2VhcmNoID0gc2VhcmNoLnJlcGxhY2UoJyMnLCAnJTIzJylcblxuICByZXR1cm4gYCR7cHJvdG9jb2x9JHtob3N0fSR7cGF0aG5hbWV9JHtzZWFyY2h9JHtoYXNofWBcbn1cblxuZXhwb3J0IGNvbnN0IHVybE9iamVjdEtleXMgPSBbXG4gICdhdXRoJyxcbiAgJ2hhc2gnLFxuICAnaG9zdCcsXG4gICdob3N0bmFtZScsXG4gICdocmVmJyxcbiAgJ3BhdGgnLFxuICAncGF0aG5hbWUnLFxuICAncG9ydCcsXG4gICdwcm90b2NvbCcsXG4gICdxdWVyeScsXG4gICdzZWFyY2gnLFxuICAnc2xhc2hlcycsXG5dXG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRXaXRoVmFsaWRhdGlvbih1cmw6IFVybE9iamVjdCk6IHN0cmluZyB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgIGlmICh1cmwgIT09IG51bGwgJiYgdHlwZW9mIHVybCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIE9iamVjdC5rZXlzKHVybCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGlmICghdXJsT2JqZWN0S2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgYFVua25vd24ga2V5IHBhc3NlZCB2aWEgdXJsT2JqZWN0IGludG8gdXJsLmZvcm1hdDogJHtrZXl9YFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZm9ybWF0VXJsKHVybClcbn1cbiJdLCJuYW1lcyI6WyJmb3JtYXRVcmwiLCJmb3JtYXRXaXRoVmFsaWRhdGlvbiIsInVybE9iamVjdEtleXMiLCJzbGFzaGVkUHJvdG9jb2xzIiwidXJsT2JqIiwiYXV0aCIsImhvc3RuYW1lIiwicHJvdG9jb2wiLCJwYXRobmFtZSIsImhhc2giLCJxdWVyeSIsImhvc3QiLCJlbmNvZGVVUklDb21wb25lbnQiLCJyZXBsYWNlIiwiaW5kZXhPZiIsInBvcnQiLCJTdHJpbmciLCJxdWVyeXN0cmluZyIsInVybFF1ZXJ5VG9TZWFyY2hQYXJhbXMiLCJzZWFyY2giLCJlbmRzV2l0aCIsInNsYXNoZXMiLCJ0ZXN0IiwidXJsIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJrZXkiLCJpbmNsdWRlcyIsImNvbnNvbGUiLCJ3YXJuIl0sIm1hcHBpbmdzIjoiQUFBQSx1Q0FBdUM7QUFDdkMsc0RBQXNEO0FBQ3RELEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUsZ0VBQWdFO0FBQ2hFLHNFQUFzRTtBQUN0RSxzRUFBc0U7QUFDdEUsNEVBQTRFO0FBQzVFLHFFQUFxRTtBQUNyRSx3QkFBd0I7QUFDeEIsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSx5REFBeUQ7QUFDekQsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSw2REFBNkQ7QUFDN0QsNEVBQTRFO0FBQzVFLDJFQUEyRTtBQUMzRSx3RUFBd0U7QUFDeEUsNEVBQTRFO0FBQzVFLHlDQUF5Qzs7Ozs7Ozs7Ozs7Ozs7OztJQVF6QkEsU0FBUyxFQUFBO2VBQVRBOztJQTZEQUMsb0JBQW9CLEVBQUE7ZUFBcEJBOztJQWZIQyxhQUFhLEVBQUE7ZUFBYkE7Ozs7dUVBbERnQjtBQUU3QixNQUFNQyxtQkFBbUI7QUFFbEIsU0FBU0gsVUFBVUksTUFBaUI7SUFDekMsSUFBSSxFQUFFQyxJQUFJLEVBQUVDLFFBQVEsRUFBRSxHQUFHRjtJQUN6QixJQUFJRyxXQUFXSCxPQUFPRyxRQUFRLElBQUk7SUFDbEMsSUFBSUMsV0FBV0osT0FBT0ksUUFBUSxJQUFJO0lBQ2xDLElBQUlDLE9BQU9MLE9BQU9LLElBQUksSUFBSTtJQUMxQixJQUFJQyxRQUFRTixPQUFPTSxLQUFLLElBQUk7SUFDNUIsSUFBSUMsT0FBdUI7SUFFM0JOLE9BQU9BLE9BQU9PLG1CQUFtQlAsTUFBTVEsT0FBTyxDQUFDLFFBQVEsT0FBTyxNQUFNO0lBRXBFLElBQUlULE9BQU9PLElBQUksRUFBRTtRQUNmQSxPQUFPTixPQUFPRCxPQUFPTyxJQUFJO0lBQzNCLE9BQU8sSUFBSUwsVUFBVTtRQUNuQkssT0FBT04sT0FBUSxDQUFBLENBQUNDLFNBQVNRLE9BQU8sQ0FBQyxPQUFRLE1BQUdSLFdBQVMsTUFBS0EsUUFBTztRQUNqRSxJQUFJRixPQUFPVyxJQUFJLEVBQUU7WUFDZkosUUFBUSxNQUFNUCxPQUFPVyxJQUFJO1FBQzNCO0lBQ0Y7SUFFQSxJQUFJTCxTQUFTLE9BQU9BLFVBQVUsVUFBVTtRQUN0Q0EsUUFBUU0sT0FBT0MsYUFBWUMsc0JBQXNCLENBQUNSO0lBQ3BEO0lBRUEsSUFBSVMsU0FBU2YsT0FBT2UsTUFBTSxJQUFLVCxTQUFVLE1BQUdBLFNBQVk7SUFFeEQsSUFBSUgsWUFBWSxDQUFDQSxTQUFTYSxRQUFRLENBQUMsTUFBTWIsWUFBWTtJQUVyRCxJQUNFSCxPQUFPaUIsT0FBTyxJQUNaLENBQUEsQ0FBQ2QsWUFBWUosaUJBQWlCbUIsSUFBSSxDQUFDZixTQUFRLEtBQU1JLFNBQVMsT0FDNUQ7UUFDQUEsT0FBTyxPQUFRQSxDQUFBQSxRQUFRLEVBQUM7UUFDeEIsSUFBSUgsWUFBWUEsUUFBUSxDQUFDLEVBQUUsS0FBSyxLQUFLQSxXQUFXLE1BQU1BO0lBQ3hELE9BQU8sSUFBSSxDQUFDRyxNQUFNO1FBQ2hCQSxPQUFPO0lBQ1Q7SUFFQSxJQUFJRixRQUFRQSxJQUFJLENBQUMsRUFBRSxLQUFLLEtBQUtBLE9BQU8sTUFBTUE7SUFDMUMsSUFBSVUsVUFBVUEsTUFBTSxDQUFDLEVBQUUsS0FBSyxLQUFLQSxTQUFTLE1BQU1BO0lBRWhEWCxXQUFXQSxTQUFTSyxPQUFPLENBQUMsU0FBU0Q7SUFDckNPLFNBQVNBLE9BQU9OLE9BQU8sQ0FBQyxLQUFLO0lBRTdCLE9BQVEsS0FBRU4sV0FBV0ksT0FBT0gsV0FBV1csU0FBU1Y7QUFDbEQ7QUFFTyxNQUFNUCxnQkFBZ0I7SUFDM0I7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0Q7QUFFTSxTQUFTRCxxQkFBcUJzQixHQUFjO0lBQ2pELElBQUlDLFFBQVFDLEdBQUcsQ0FBQ0MsUUFBUSxLQUFLLFdBQWU7UUFDMUMsSUFBSUgsUUFBUSxRQUFRLE9BQU9BLFFBQVEsVUFBVTtZQUMzQ0ksT0FBT0MsSUFBSSxDQUFDTCxLQUFLTSxPQUFPLENBQUMsQ0FBQ0M7Z0JBQ3hCLElBQUksQ0FBQzVCLGNBQWM2QixRQUFRLENBQUNELE1BQU07b0JBQ2hDRSxRQUFRQyxJQUFJLENBQ1QsdURBQW9ESDtnQkFFekQ7WUFDRjtRQUNGO0lBQ0Y7SUFFQSxPQUFPOUIsVUFBVXVCO0FBQ25CIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDIwMDQsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcm91dGVyLXJlZHVjZXItdHlwZXMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBDYWNoZU5vZGUgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB0eXBlIHtcbiAgRmxpZ2h0Um91dGVyU3RhdGUsXG4gIEZsaWdodFNlZ21lbnRQYXRoLFxufSBmcm9tICcuLi8uLi8uLi9zZXJ2ZXIvYXBwLXJlbmRlci90eXBlcydcbmltcG9ydCB0eXBlIHsgRmV0Y2hTZXJ2ZXJSZXNwb25zZVJlc3VsdCB9IGZyb20gJy4vZmV0Y2gtc2VydmVyLXJlc3BvbnNlJ1xuXG5leHBvcnQgY29uc3QgQUNUSU9OX1JFRlJFU0ggPSAncmVmcmVzaCdcbmV4cG9ydCBjb25zdCBBQ1RJT05fTkFWSUdBVEUgPSAnbmF2aWdhdGUnXG5leHBvcnQgY29uc3QgQUNUSU9OX1JFU1RPUkUgPSAncmVzdG9yZSdcbmV4cG9ydCBjb25zdCBBQ1RJT05fU0VSVkVSX1BBVENIID0gJ3NlcnZlci1wYXRjaCdcbmV4cG9ydCBjb25zdCBBQ1RJT05fUFJFRkVUQ0ggPSAncHJlZmV0Y2gnXG5leHBvcnQgY29uc3QgQUNUSU9OX0hNUl9SRUZSRVNIID0gJ2htci1yZWZyZXNoJ1xuZXhwb3J0IGNvbnN0IEFDVElPTl9TRVJWRVJfQUNUSU9OID0gJ3NlcnZlci1hY3Rpb24nXG5cbmV4cG9ydCB0eXBlIFJvdXRlckNoYW5nZUJ5U2VydmVyUmVzcG9uc2UgPSAoe1xuICBuYXZpZ2F0ZWRBdCxcbiAgcHJldmlvdXNUcmVlLFxuICBzZXJ2ZXJSZXNwb25zZSxcbn06IHtcbiAgbmF2aWdhdGVkQXQ6IG51bWJlclxuICBwcmV2aW91c1RyZWU6IEZsaWdodFJvdXRlclN0YXRlXG4gIHNlcnZlclJlc3BvbnNlOiBGZXRjaFNlcnZlclJlc3BvbnNlUmVzdWx0XG59KSA9PiB2b2lkXG5cbmV4cG9ydCBpbnRlcmZhY2UgTXV0YWJsZSB7XG4gIG1wYU5hdmlnYXRpb24/OiBib29sZWFuXG4gIHBhdGNoZWRUcmVlPzogRmxpZ2h0Um91dGVyU3RhdGVcbiAgY2Fub25pY2FsVXJsPzogc3RyaW5nXG4gIHNjcm9sbGFibGVTZWdtZW50cz86IEZsaWdodFNlZ21lbnRQYXRoW11cbiAgcGVuZGluZ1B1c2g/OiBib29sZWFuXG4gIGNhY2hlPzogQ2FjaGVOb2RlXG4gIHByZWZldGNoQ2FjaGU/OiBBcHBSb3V0ZXJTdGF0ZVsncHJlZmV0Y2hDYWNoZSddXG4gIGhhc2hGcmFnbWVudD86IHN0cmluZ1xuICBzaG91bGRTY3JvbGw/OiBib29sZWFuXG4gIHByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlPzogYm9vbGVhblxuICBvbmx5SGFzaENoYW5nZT86IGJvb2xlYW5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBTZXJ2ZXJBY3Rpb25NdXRhYmxlIGV4dGVuZHMgTXV0YWJsZSB7XG4gIGluRmxpZ2h0U2VydmVyQWN0aW9uPzogUHJvbWlzZTxhbnk+IHwgbnVsbFxufVxuXG4vKipcbiAqIFJlZnJlc2ggdHJpZ2dlcnMgYSByZWZyZXNoIG9mIHRoZSBmdWxsIHBhZ2UgZGF0YS5cbiAqIC0gZmV0Y2hlcyB0aGUgRmxpZ2h0IGRhdGEgYW5kIGZpbGxzIHJzYyBhdCB0aGUgcm9vdCBvZiB0aGUgY2FjaGUuXG4gKiAtIFRoZSByb3V0ZXIgc3RhdGUgaXMgdXBkYXRlZCBhdCB0aGUgcm9vdC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZWZyZXNoQWN0aW9uIHtcbiAgdHlwZTogdHlwZW9mIEFDVElPTl9SRUZSRVNIXG4gIG9yaWdpbjogTG9jYXRpb25bJ29yaWdpbiddXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSG1yUmVmcmVzaEFjdGlvbiB7XG4gIHR5cGU6IHR5cGVvZiBBQ1RJT05fSE1SX1JFRlJFU0hcbiAgb3JpZ2luOiBMb2NhdGlvblsnb3JpZ2luJ11cbn1cblxuZXhwb3J0IHR5cGUgU2VydmVyQWN0aW9uRGlzcGF0Y2hlciA9IChcbiAgYXJnczogT21pdDxcbiAgICBTZXJ2ZXJBY3Rpb25BY3Rpb24sXG4gICAgJ3R5cGUnIHwgJ211dGFibGUnIHwgJ25hdmlnYXRlJyB8ICdjaGFuZ2VCeVNlcnZlclJlc3BvbnNlJyB8ICdjYWNoZSdcbiAgPlxuKSA9PiB2b2lkXG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VydmVyQWN0aW9uQWN0aW9uIHtcbiAgdHlwZTogdHlwZW9mIEFDVElPTl9TRVJWRVJfQUNUSU9OXG4gIGFjdGlvbklkOiBzdHJpbmdcbiAgYWN0aW9uQXJnczogYW55W11cbiAgcmVzb2x2ZTogKHZhbHVlOiBhbnkpID0+IHZvaWRcbiAgcmVqZWN0OiAocmVhc29uPzogYW55KSA9PiB2b2lkXG59XG5cbi8qKlxuICogTmF2aWdhdGUgdHJpZ2dlcnMgYSBuYXZpZ2F0aW9uIHRvIHRoZSBwcm92aWRlZCB1cmwuIEl0IHN1cHBvcnRzIHR3byB0eXBlczogYHB1c2hgIGFuZCBgcmVwbGFjZWAuXG4gKlxuICogYG5hdmlnYXRlVHlwZWA6XG4gKiAtIGBwdXNoYCAtIHB1c2hlcyBhIG5ldyBoaXN0b3J5IGVudHJ5IGluIHRoZSBicm93c2VyIGhpc3RvcnlcbiAqIC0gYHJlcGxhY2VgIC0gcmVwbGFjZXMgdGhlIGN1cnJlbnQgaGlzdG9yeSBlbnRyeSBpbiB0aGUgYnJvd3NlciBoaXN0b3J5XG4gKlxuICogTmF2aWdhdGUgaGFzIG11bHRpcGxlIGNhY2hlIGhldXJpc3RpY3M6XG4gKiAtIHBhZ2Ugd2FzIHByZWZldGNoZWRcbiAqICAtIEFwcGx5IHJvdXRlciBzdGF0ZSB0cmVlIGZyb20gcHJlZmV0Y2hcbiAqICAtIEFwcGx5IEZsaWdodCBkYXRhIGZyb20gcHJlZmV0Y2ggdG8gdGhlIGNhY2hlXG4gKiAgLSBJZiBGbGlnaHQgZGF0YSBpcyBhIHN0cmluZywgaXQncyBhIHJlZGlyZWN0IGFuZCB0aGUgc3RhdGUgaXMgdXBkYXRlZCB0byB0cmlnZ2VyIGEgcmVkaXJlY3RcbiAqICAtIENoZWNrIGlmIGhhcmQgbmF2aWdhdGlvbiBpcyBuZWVkZWRcbiAqICAgIC0gSGFyZCBuYXZpZ2F0aW9uIGhhcHBlbnMgd2hlbiBhIGR5bmFtaWMgcGFyYW1ldGVyIGJlbG93IHRoZSBjb21tb24gbGF5b3V0IGNoYW5nZWRcbiAqICAgIC0gV2hlbiBoYXJkIG5hdmlnYXRpb24gaXMgbmVlZGVkIHRoZSBjYWNoZSBpcyBpbnZhbGlkYXRlZCBiZWxvdyB0aGUgZmxpZ2h0U2VnbWVudFBhdGhcbiAqICAgIC0gVGhlIG1pc3NpbmcgY2FjaGUgbm9kZXMgb2YgdGhlIHBhZ2Ugd2lsbCBiZSBmZXRjaGVkIGluIGxheW91dC1yb3V0ZXIgYW5kIHRyaWdnZXIgdGhlIFNFUlZFUl9QQVRDSCBhY3Rpb25cbiAqICAtIElmIGhhcmQgbmF2aWdhdGlvbiBpcyBub3QgbmVlZGVkXG4gKiAgICAtIFRoZSBjYWNoZSBpcyByZXVzZWRcbiAqICAgIC0gSWYgYW55IGNhY2hlIG5vZGVzIGFyZSBtaXNzaW5nIHRoZXknbGwgYmUgZmV0Y2hlZCBpbiBsYXlvdXQtcm91dGVyIGFuZCB0cmlnZ2VyIHRoZSBTRVJWRVJfUEFUQ0ggYWN0aW9uXG4gKiAtIHBhZ2Ugd2FzIG5vdCBwcmVmZXRjaGVkXG4gKiAgLSBUaGUgbmF2aWdhdGUgd2FzIGNhbGxlZCBmcm9tIGBuZXh0L3JvdXRlcmAgKGByb3V0ZXIucHVzaCgpYCAvIGByb3V0ZXIucmVwbGFjZSgpYCkgLyBgbmV4dC9saW5rYCB3aXRob3V0IHByZWZldGNoZWQgZGF0YSBhdmFpbGFibGUgKGUuZy4gdGhlIHByZWZldGNoIGRpZG4ndCBjb21lIGJhY2sgZnJvbSB0aGUgc2VydmVyIGJlZm9yZSBjbGlja2luZyB0aGUgbGluaylcbiAqICAgIC0gRmxpZ2h0IGRhdGEgaXMgZmV0Y2hlZCBpbiB0aGUgcmVkdWNlciAoc3VzcGVuZHMgdGhlIHJlZHVjZXIpXG4gKiAgICAtIFJvdXRlciBzdGF0ZSB0cmVlIGlzIGNyZWF0ZWQgYmFzZWQgb24gRmxpZ2h0IGRhdGFcbiAqICAgIC0gQ2FjaGUgaXMgZmlsbGVkIGJhc2VkIG9uIHRoZSBGbGlnaHQgZGF0YVxuICpcbiAqIEFib3ZlIHN0ZXBzIGV4cGxhaW4gMyBjYXNlczpcbiAqIC0gYHNvZnRgIC0gUmV1c2VzIHRoZSBleGlzdGluZyBjYWNoZSBhbmQgZmV0Y2hlcyBtaXNzaW5nIG5vZGVzIGluIGxheW91dC1yb3V0ZXIuXG4gKiAtIGBoYXJkYCAtIENyZWF0ZXMgYSBuZXcgY2FjaGUgd2hlcmUgY2FjaGUgbm9kZXMgYXJlIHJlbW92ZWQgYmVsb3cgdGhlIGNvbW1vbiBsYXlvdXQgYW5kIGZldGNoZXMgbWlzc2luZyBub2RlcyBpbiBsYXlvdXQtcm91dGVyLlxuICogLSBgb3B0aW1pc3RpY2AgKGV4cGxpY2l0IG5vIHByZWZldGNoKSAtIENyZWF0ZXMgYSBuZXcgY2FjaGUgYW5kIGtpY2tzIG9mZiB0aGUgZGF0YSBmZXRjaCBpbiB0aGUgcmVkdWNlci4gVGhlIGRhdGEgZmV0Y2ggaXMgYXdhaXRlZCBpbiB0aGUgbGF5b3V0LXJvdXRlci5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBOYXZpZ2F0ZUFjdGlvbiB7XG4gIHR5cGU6IHR5cGVvZiBBQ1RJT05fTkFWSUdBVEVcbiAgdXJsOiBVUkxcbiAgaXNFeHRlcm5hbFVybDogYm9vbGVhblxuICBsb2NhdGlvblNlYXJjaDogTG9jYXRpb25bJ3NlYXJjaCddXG4gIG5hdmlnYXRlVHlwZTogJ3B1c2gnIHwgJ3JlcGxhY2UnXG4gIHNob3VsZFNjcm9sbDogYm9vbGVhblxuICBhbGxvd0FsaWFzaW5nOiBib29sZWFuXG59XG5cbi8qKlxuICogUmVzdG9yZSBhcHBsaWVzIHRoZSBwcm92aWRlZCByb3V0ZXIgc3RhdGUuXG4gKiAtIFVzZWQgZm9yIGBwb3BzdGF0ZWAgKGJhY2svZm9yd2FyZCBuYXZpZ2F0aW9uKSB3aGVyZSBhIGtub3duIHJvdXRlciBzdGF0ZSBoYXMgdG8gYmUgYXBwbGllZC5cbiAqIC0gQWxzbyB1c2VkIHdoZW4gc3luY2luZyB0aGUgcm91dGVyIHN0YXRlIHdpdGggYHB1c2hTdGF0ZWAvYHJlcGxhY2VTdGF0ZWAgY2FsbHMuXG4gKiAtIFJvdXRlciBzdGF0ZSBpcyBhcHBsaWVkIGFzLWlzIGZyb20gdGhlIGhpc3Rvcnkgc3RhdGUsIGlmIGF2YWlsYWJsZS5cbiAqIC0gSWYgdGhlIGhpc3Rvcnkgc3RhdGUgZG9lcyBub3QgY29udGFpbiB0aGUgcm91dGVyIHN0YXRlLCB0aGUgZXhpc3Rpbmcgcm91dGVyIHN0YXRlIGlzIHVzZWQuXG4gKiAtIElmIGFueSBjYWNoZSBub2RlIGlzIG1pc3NpbmcgaXQgd2lsbCBiZSBmZXRjaGVkIGluIGxheW91dC1yb3V0ZXIgZHVyaW5nIHJlbmRlcmluZyBhbmQgdGhlIHNlcnZlci1wYXRjaCBjYXNlLlxuICogLSBJZiBleGlzdGluZyBjYWNoZSBub2RlcyBtYXRjaCB0aGVzZSBhcmUgdXNlZC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZXN0b3JlQWN0aW9uIHtcbiAgdHlwZTogdHlwZW9mIEFDVElPTl9SRVNUT1JFXG4gIHVybDogVVJMXG4gIHRyZWU6IEZsaWdodFJvdXRlclN0YXRlIHwgdW5kZWZpbmVkXG59XG5cbi8qKlxuICogU2VydmVyLXBhdGNoIGFwcGxpZXMgdGhlIHByb3ZpZGVkIEZsaWdodCBkYXRhIHRvIHRoZSBjYWNoZSBhbmQgcm91dGVyIHRyZWUuXG4gKiAtIE9ubHkgdHJpZ2dlcmVkIGluIGxheW91dC1yb3V0ZXIuXG4gKiAtIENyZWF0ZXMgYSBuZXcgY2FjaGUgYW5kIHJvdXRlciBzdGF0ZSB3aXRoIHRoZSBGbGlnaHQgZGF0YSBhcHBsaWVkLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFNlcnZlclBhdGNoQWN0aW9uIHtcbiAgdHlwZTogdHlwZW9mIEFDVElPTl9TRVJWRVJfUEFUQ0hcbiAgbmF2aWdhdGVkQXQ6IG51bWJlclxuICBzZXJ2ZXJSZXNwb25zZTogRmV0Y2hTZXJ2ZXJSZXNwb25zZVJlc3VsdFxuICBwcmV2aW91c1RyZWU6IEZsaWdodFJvdXRlclN0YXRlXG59XG5cbi8qKlxuICogUHJlZmV0Y2hLaW5kIGRlZmluZXMgdGhlIHR5cGUgb2YgcHJlZmV0Y2hpbmcgdGhhdCBzaG91bGQgYmUgZG9uZS5cbiAqIC0gYGF1dG9gIC0gaWYgdGhlIHBhZ2UgaXMgZHluYW1pYywgcHJlZmV0Y2ggdGhlIHBhZ2UgZGF0YSBwYXJ0aWFsbHksIGlmIHN0YXRpYyBwcmVmZXRjaCB0aGUgcGFnZSBkYXRhIGZ1bGx5LlxuICogLSBgZnVsbGAgLSBwcmVmZXRjaCB0aGUgcGFnZSBkYXRhIGZ1bGx5LlxuICogLSBgdGVtcG9yYXJ5YCAtIGEgdGVtcG9yYXJ5IHByZWZldGNoIGVudHJ5IGlzIGFkZGVkIHRvIHRoZSBjYWNoZSwgdGhpcyBpcyB1c2VkIHdoZW4gcHJlZmV0Y2g9e2ZhbHNlfSBpcyB1c2VkIGluIG5leHQvbGluayBvciB3aGVuIHlvdSBwdXNoIGEgcm91dGUgcHJvZ3JhbW1hdGljYWxseS5cbiAqL1xuXG5leHBvcnQgZW51bSBQcmVmZXRjaEtpbmQge1xuICBBVVRPID0gJ2F1dG8nLFxuICBGVUxMID0gJ2Z1bGwnLFxuICBURU1QT1JBUlkgPSAndGVtcG9yYXJ5Jyxcbn1cblxuLyoqXG4gKiBQcmVmZXRjaCBhZGRzIHRoZSBwcm92aWRlZCBGbGlnaHREYXRhIHRvIHRoZSBwcmVmZXRjaCBjYWNoZVxuICogLSBDcmVhdGVzIHRoZSByb3V0ZXIgc3RhdGUgdHJlZSBiYXNlZCBvbiB0aGUgcGF0Y2ggaW4gRmxpZ2h0RGF0YVxuICogLSBBZGRzIHRoZSBGbGlnaHREYXRhIHRvIHRoZSBwcmVmZXRjaCBjYWNoZVxuICogLSBJbiBBQ1RJT05fTkFWSUdBVEUgdGhlIHByZWZldGNoIGNhY2hlIGlzIGNoZWNrZWQgYW5kIHRoZSByb3V0ZXIgc3RhdGUgdHJlZSBhbmQgRmxpZ2h0RGF0YSBhcmUgYXBwbGllZC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQcmVmZXRjaEFjdGlvbiB7XG4gIHR5cGU6IHR5cGVvZiBBQ1RJT05fUFJFRkVUQ0hcbiAgdXJsOiBVUkxcbiAga2luZDogUHJlZmV0Y2hLaW5kXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHVzaFJlZiB7XG4gIC8qKlxuICAgKiBJZiB0aGUgYXBwLXJvdXRlciBzaG91bGQgcHVzaCBhIG5ldyBoaXN0b3J5IGVudHJ5IGluIGFwcC1yb3V0ZXIncyB1c2VFZmZlY3QoKVxuICAgKi9cbiAgcGVuZGluZ1B1c2g6IGJvb2xlYW5cbiAgLyoqXG4gICAqIE11bHRpLXBhZ2UgbmF2aWdhdGlvbiB0aHJvdWdoIGxvY2F0aW9uLmhyZWYuXG4gICAqL1xuICBtcGFOYXZpZ2F0aW9uOiBib29sZWFuXG4gIC8qKlxuICAgKiBTa2lwIGFwcGx5aW5nIHRoZSByb3V0ZXIgc3RhdGUgdG8gdGhlIGJyb3dzZXIgaGlzdG9yeSBzdGF0ZS5cbiAgICovXG4gIHByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlOiBib29sZWFuXG59XG5cbmV4cG9ydCB0eXBlIEZvY3VzQW5kU2Nyb2xsUmVmID0ge1xuICAvKipcbiAgICogSWYgZm9jdXMgYW5kIHNjcm9sbCBzaG91bGQgYmUgc2V0IGluIHRoZSBsYXlvdXQtcm91dGVyJ3MgdXNlRWZmZWN0KClcbiAgICovXG4gIGFwcGx5OiBib29sZWFuXG4gIC8qKlxuICAgKiBUaGUgaGFzaCBmcmFnbWVudCB0aGF0IHNob3VsZCBiZSBzY3JvbGxlZCB0by5cbiAgICovXG4gIGhhc2hGcmFnbWVudDogc3RyaW5nIHwgbnVsbFxuICAvKipcbiAgICogVGhlIHBhdGhzIG9mIHRoZSBzZWdtZW50cyB0aGF0IHNob3VsZCBiZSBmb2N1c2VkLlxuICAgKi9cbiAgc2VnbWVudFBhdGhzOiBGbGlnaHRTZWdtZW50UGF0aFtdXG4gIC8qKlxuICAgKiBJZiBvbmx5IHRoZSBVUkxzIGhhc2ggZnJhZ21lbnQgY2hhbmdlZFxuICAgKi9cbiAgb25seUhhc2hDaGFuZ2U6IGJvb2xlYW5cbn1cblxuZXhwb3J0IHR5cGUgUHJlZmV0Y2hDYWNoZUVudHJ5ID0ge1xuICB0cmVlQXRUaW1lT2ZQcmVmZXRjaDogRmxpZ2h0Um91dGVyU3RhdGVcbiAgZGF0YTogUHJvbWlzZTxGZXRjaFNlcnZlclJlc3BvbnNlUmVzdWx0PlxuICBraW5kOiBQcmVmZXRjaEtpbmRcbiAgcHJlZmV0Y2hUaW1lOiBudW1iZXJcbiAgc3RhbGVUaW1lOiBudW1iZXJcbiAgbGFzdFVzZWRUaW1lOiBudW1iZXIgfCBudWxsXG4gIGtleTogc3RyaW5nXG4gIHN0YXR1czogUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzXG4gIHVybDogVVJMXG59XG5cbmV4cG9ydCBlbnVtIFByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cyB7XG4gIGZyZXNoID0gJ2ZyZXNoJyxcbiAgcmV1c2FibGUgPSAncmV1c2FibGUnLFxuICBleHBpcmVkID0gJ2V4cGlyZWQnLFxuICBzdGFsZSA9ICdzdGFsZScsXG59XG5cbi8qKlxuICogSGFuZGxlcyBrZWVwaW5nIHRoZSBzdGF0ZSBvZiBhcHAtcm91dGVyLlxuICovXG5leHBvcnQgdHlwZSBBcHBSb3V0ZXJTdGF0ZSA9IHtcbiAgLyoqXG4gICAqIFRoZSByb3V0ZXIgc3RhdGUsIHRoaXMgaXMgd3JpdHRlbiBpbnRvIHRoZSBoaXN0b3J5IHN0YXRlIGluIGFwcC1yb3V0ZXIgdXNpbmcgcmVwbGFjZVN0YXRlL3B1c2hTdGF0ZS5cbiAgICogLSBIYXMgdG8gYmUgc2VyaWFsaXphYmxlIGFzIGl0IGlzIHdyaXR0ZW4gaW50byB0aGUgaGlzdG9yeSBzdGF0ZS5cbiAgICogLSBIb2xkcyB3aGljaCBzZWdtZW50cyBhbmQgcGFyYWxsZWwgcm91dGVzIGFyZSBzaG93biBvbiB0aGUgc2NyZWVuLlxuICAgKi9cbiAgdHJlZTogRmxpZ2h0Um91dGVyU3RhdGVcbiAgLyoqXG4gICAqIFRoZSBjYWNoZSBob2xkcyBSZWFjdCBub2RlcyBmb3IgZXZlcnkgc2VnbWVudCB0aGF0IGlzIHNob3duIG9uIHNjcmVlbiBhcyB3ZWxsIGFzIHByZXZpb3VzbHkgc2hvd24gc2VnbWVudHMuXG4gICAqIEl0IGFsc28gaG9sZHMgaW4tcHJvZ3Jlc3MgZGF0YSByZXF1ZXN0cy5cbiAgICogUHJlZmV0Y2hlZCBkYXRhIGlzIHN0b3JlZCBzZXBhcmF0ZWx5IGluIGBwcmVmZXRjaENhY2hlYCwgdGhhdCBpcyBhcHBsaWVkIGR1cmluZyBBQ1RJT05fTkFWSUdBVEUuXG4gICAqL1xuICBjYWNoZTogQ2FjaGVOb2RlXG4gIC8qKlxuICAgKiBDYWNoZSB0aGF0IGhvbGRzIHByZWZldGNoZWQgRmxpZ2h0IHJlc3BvbnNlcyBrZXllZCBieSB1cmwuXG4gICAqL1xuICBwcmVmZXRjaENhY2hlOiBNYXA8c3RyaW5nLCBQcmVmZXRjaENhY2hlRW50cnk+XG4gIC8qKlxuICAgKiBEZWNpZGVzIGlmIHRoZSB1cGRhdGUgc2hvdWxkIGNyZWF0ZSBhIG5ldyBoaXN0b3J5IGVudHJ5IGFuZCBpZiB0aGUgbmF2aWdhdGlvbiBoYXMgdG8gdHJpZ2dlciBhIGJyb3dzZXIgbmF2aWdhdGlvbi5cbiAgICovXG4gIHB1c2hSZWY6IFB1c2hSZWZcbiAgLyoqXG4gICAqIERlY2lkZXMgaWYgdGhlIHVwZGF0ZSBzaG91bGQgYXBwbHkgc2Nyb2xsIGFuZCBmb2N1cyBtYW5hZ2VtZW50LlxuICAgKi9cbiAgZm9jdXNBbmRTY3JvbGxSZWY6IEZvY3VzQW5kU2Nyb2xsUmVmXG4gIC8qKlxuICAgKiBUaGUgY2Fub25pY2FsIHVybCB0aGF0IGlzIHB1c2hlZC9yZXBsYWNlZC5cbiAgICogLSBUaGlzIGlzIHRoZSB1cmwgeW91IHNlZSBpbiB0aGUgYnJvd3Nlci5cbiAgICovXG4gIGNhbm9uaWNhbFVybDogc3RyaW5nXG4gIC8qKlxuICAgKiBUaGUgdW5kZXJseWluZyBcInVybFwiIHJlcHJlc2VudGluZyB0aGUgVUkgc3RhdGUsIHdoaWNoIGlzIHVzZWQgZm9yIGludGVyY2VwdGluZyByb3V0ZXMuXG4gICAqL1xuICBuZXh0VXJsOiBzdHJpbmcgfCBudWxsXG59XG5cbmV4cG9ydCB0eXBlIFJlYWRvbmx5UmVkdWNlclN0YXRlID0gUmVhZG9ubHk8QXBwUm91dGVyU3RhdGU+XG5leHBvcnQgdHlwZSBSZWR1Y2VyU3RhdGUgPSBQcm9taXNlPEFwcFJvdXRlclN0YXRlPiB8IEFwcFJvdXRlclN0YXRlXG5leHBvcnQgdHlwZSBSZWR1Y2VyQWN0aW9ucyA9IFJlYWRvbmx5PFxuICB8IFJlZnJlc2hBY3Rpb25cbiAgfCBOYXZpZ2F0ZUFjdGlvblxuICB8IFJlc3RvcmVBY3Rpb25cbiAgfCBTZXJ2ZXJQYXRjaEFjdGlvblxuICB8IFByZWZldGNoQWN0aW9uXG4gIHwgSG1yUmVmcmVzaEFjdGlvblxuICB8IFNlcnZlckFjdGlvbkFjdGlvblxuPlxuIl0sIm5hbWVzIjpbIkFDVElPTl9ITVJfUkVGUkVTSCIsIkFDVElPTl9OQVZJR0FURSIsIkFDVElPTl9QUkVGRVRDSCIsIkFDVElPTl9SRUZSRVNIIiwiQUNUSU9OX1JFU1RPUkUiLCJBQ1RJT05fU0VSVkVSX0FDVElPTiIsIkFDVElPTl9TRVJWRVJfUEFUQ0giLCJQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMiLCJQcmVmZXRjaEtpbmQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQVlhQSxrQkFBa0IsRUFBQTtlQUFsQkE7O0lBSkFDLGVBQWUsRUFBQTtlQUFmQTs7SUFHQUMsZUFBZSxFQUFBO2VBQWZBOztJQUpBQyxjQUFjLEVBQUE7ZUFBZEE7O0lBRUFDLGNBQWMsRUFBQTtlQUFkQTs7SUFJQUMsb0JBQW9CLEVBQUE7ZUFBcEJBOztJQUhBQyxtQkFBbUIsRUFBQTtlQUFuQkE7O0lBeU1EQyx3QkFBd0IsRUFBQTtlQUF4QkE7O0lBaEVBQyxZQUFZLEVBQUE7ZUFBWkE7OztBQTVJTCxNQUFNTCxpQkFBaUI7QUFDdkIsTUFBTUYsa0JBQWtCO0FBQ3hCLE1BQU1HLGlCQUFpQjtBQUN2QixNQUFNRSxzQkFBc0I7QUFDNUIsTUFBTUosa0JBQWtCO0FBQ3hCLE1BQU1GLHFCQUFxQjtBQUMzQixNQUFNSyx1QkFBdUI7QUFzSTdCLElBQUtHLGVBQUFBLFdBQUFBLEdBQUFBLFNBQUFBLFlBQUFBOzs7O1dBQUFBOztBQWdFTCxJQUFLRCwyQkFBQUEsV0FBQUEsR0FBQUEsU0FBQUEsd0JBQUFBOzs7OztXQUFBQSIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAyMDg2LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2NsaWVudC91c2UtbWVyZ2VkLXJlZi50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlUmVmLCB0eXBlIFJlZiB9IGZyb20gJ3JlYWN0J1xuXG4vLyBUaGlzIGlzIGEgY29tcGF0aWJpbGl0eSBob29rIHRvIHN1cHBvcnQgUmVhY3QgMTggYW5kIDE5IHJlZnMuXG4vLyBJbiAxOSwgYSBjbGVhbnVwIGZ1bmN0aW9uIGZyb20gcmVmcyBtYXkgYmUgcmV0dXJuZWQuXG4vLyBJbiAxOCwgcmV0dXJuaW5nIGEgY2xlYW51cCBmdW5jdGlvbiBjcmVhdGVzIGEgd2FybmluZy5cbi8vIFNpbmNlIHdlIHRha2UgdXNlcnNwYWNlIHJlZnMsIHdlIGRvbid0IGtub3cgYWhlYWQgb2YgdGltZSBpZiBhIGNsZWFudXAgZnVuY3Rpb24gd2lsbCBiZSByZXR1cm5lZC5cbi8vIFRoaXMgaW1wbGVtZW50cyBjbGVhbnVwIGZ1bmN0aW9ucyB3aXRoIHRoZSBvbGQgYmVoYXZpb3IgaW4gMTguXG4vLyBXZSBrbm93IHJlZnMgYXJlIGFsd2F5cyBjYWxsZWQgYWx0ZXJuYXRpbmcgd2l0aCBgbnVsbGAgYW5kIHRoZW4gYFRgLlxuLy8gU28gYSBjYWxsIHdpdGggYG51bGxgIG1lYW5zIHdlIG5lZWQgdG8gY2FsbCB0aGUgcHJldmlvdXMgY2xlYW51cCBmdW5jdGlvbnMuXG5leHBvcnQgZnVuY3Rpb24gdXNlTWVyZ2VkUmVmPFRFbGVtZW50PihcbiAgcmVmQTogUmVmPFRFbGVtZW50PixcbiAgcmVmQjogUmVmPFRFbGVtZW50PlxuKTogUmVmPFRFbGVtZW50PiB7XG4gIGNvbnN0IGNsZWFudXBBID0gdXNlUmVmPCgoKSA9PiB2b2lkKSB8IG51bGw+KG51bGwpXG4gIGNvbnN0IGNsZWFudXBCID0gdXNlUmVmPCgoKSA9PiB2b2lkKSB8IG51bGw+KG51bGwpXG5cbiAgLy8gTk9URTogSW4gdGhlb3J5LCB3ZSBjb3VsZCBza2lwIHRoZSB3cmFwcGluZyBpZiBvbmx5IG9uZSBvZiB0aGUgcmVmcyBpcyBub24tbnVsbC5cbiAgLy8gKHRoaXMgaGFwcGVucyBvZnRlbiBpZiB0aGUgdXNlciBkb2Vzbid0IHBhc3MgYSByZWYgdG8gTGluay9Gb3JtL0ltYWdlKVxuICAvLyBCdXQgdGhpcyBjYW4gY2F1c2UgdXMgdG8gbGVhayBhIGNsZWFudXAtcmVmIGludG8gdXNlciBjb2RlIChlLmcuIHZpYSBgPExpbmsgbGVnYWN5QmVoYXZpb3I+YCksXG4gIC8vIGFuZCB0aGUgdXNlciBtaWdodCBwYXNzIHRoYXQgcmVmIGludG8gcmVmLW1lcmdpbmcgbGlicmFyeSB0aGF0IGRvZXNuJ3Qgc3VwcG9ydCBjbGVhbnVwIHJlZnNcbiAgLy8gKGJlY2F1c2UgaXQgaGFzbid0IGJlZW4gdXBkYXRlZCBmb3IgUmVhY3QgMTkpXG4gIC8vIHdoaWNoIGNhbiB0aGVuIGNhdXNlIHRoaW5ncyB0byBibG93IHVwLCBiZWNhdXNlIGEgY2xlYW51cC1yZXR1cm5pbmcgcmVmIGdldHMgY2FsbGVkIHdpdGggYG51bGxgLlxuICAvLyBTbyBpbiBwcmFjdGljZSwgaXQncyBzYWZlciB0byBiZSBkZWZlbnNpdmUgYW5kIGFsd2F5cyB3cmFwIHRoZSByZWYsIGV2ZW4gb24gUmVhY3QgMTkuXG4gIHJldHVybiB1c2VDYWxsYmFjayhcbiAgICAoY3VycmVudDogVEVsZW1lbnQgfCBudWxsKTogdm9pZCA9PiB7XG4gICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICBjb25zdCBjbGVhbnVwRm5BID0gY2xlYW51cEEuY3VycmVudFxuICAgICAgICBpZiAoY2xlYW51cEZuQSkge1xuICAgICAgICAgIGNsZWFudXBBLmN1cnJlbnQgPSBudWxsXG4gICAgICAgICAgY2xlYW51cEZuQSgpXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2xlYW51cEZuQiA9IGNsZWFudXBCLmN1cnJlbnRcbiAgICAgICAgaWYgKGNsZWFudXBGbkIpIHtcbiAgICAgICAgICBjbGVhbnVwQi5jdXJyZW50ID0gbnVsbFxuICAgICAgICAgIGNsZWFudXBGbkIoKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocmVmQSkge1xuICAgICAgICAgIGNsZWFudXBBLmN1cnJlbnQgPSBhcHBseVJlZihyZWZBLCBjdXJyZW50KVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZWZCKSB7XG4gICAgICAgICAgY2xlYW51cEIuY3VycmVudCA9IGFwcGx5UmVmKHJlZkIsIGN1cnJlbnQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFtyZWZBLCByZWZCXVxuICApXG59XG5cbmZ1bmN0aW9uIGFwcGx5UmVmPFRFbGVtZW50PihcbiAgcmVmQTogTm9uTnVsbGFibGU8UmVmPFRFbGVtZW50Pj4sXG4gIGN1cnJlbnQ6IFRFbGVtZW50XG4pIHtcbiAgaWYgKHR5cGVvZiByZWZBID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc3QgY2xlYW51cCA9IHJlZkEoY3VycmVudClcbiAgICBpZiAodHlwZW9mIGNsZWFudXAgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBjbGVhbnVwXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoKSA9PiByZWZBKG51bGwpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlZkEuY3VycmVudCA9IGN1cnJlbnRcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcmVmQS5jdXJyZW50ID0gbnVsbFxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbInVzZU1lcmdlZFJlZiIsInJlZkEiLCJyZWZCIiwiY2xlYW51cEEiLCJ1c2VSZWYiLCJjbGVhbnVwQiIsInVzZUNhbGxiYWNrIiwiY3VycmVudCIsImNsZWFudXBGbkEiLCJjbGVhbnVwRm5CIiwiYXBwbHlSZWYiLCJjbGVhbnVwIl0sIm1hcHBpbmdzIjoiOzs7K0JBU2dCQSxnQkFBQUE7OztlQUFBQTs7O3VCQVQ4QjtBQVN2QyxTQUFTQSxhQUNkQyxJQUFtQixFQUNuQkMsSUFBbUI7SUFFbkIsTUFBTUMsV0FBV0MsQ0FBQUEsR0FBQUEsT0FBQUEsTUFBTSxFQUFzQjtJQUM3QyxNQUFNQyxXQUFXRCxDQUFBQSxHQUFBQSxPQUFBQSxNQUFNLEVBQXNCO0lBRTdDLG1GQUFtRjtJQUNuRix5RUFBeUU7SUFDekUsaUdBQWlHO0lBQ2pHLDhGQUE4RjtJQUM5RixnREFBZ0Q7SUFDaEQsbUdBQW1HO0lBQ25HLHdGQUF3RjtJQUN4RixPQUFPRSxDQUFBQSxHQUFBQSxPQUFBQSxXQUFXLEVBQ2hCLENBQUNDO1FBQ0MsSUFBSUEsWUFBWSxNQUFNO1lBQ3BCLE1BQU1DLGFBQWFMLFNBQVNJLE9BQU87WUFDbkMsSUFBSUMsWUFBWTtnQkFDZEwsU0FBU0ksT0FBTyxHQUFHO2dCQUNuQkM7WUFDRjtZQUNBLE1BQU1DLGFBQWFKLFNBQVNFLE9BQU87WUFDbkMsSUFBSUUsWUFBWTtnQkFDZEosU0FBU0UsT0FBTyxHQUFHO2dCQUNuQkU7WUFDRjtRQUNGLE9BQU87WUFDTCxJQUFJUixNQUFNO2dCQUNSRSxTQUFTSSxPQUFPLEdBQUdHLFNBQVNULE1BQU1NO1lBQ3BDO1lBQ0EsSUFBSUwsTUFBTTtnQkFDUkcsU0FBU0UsT0FBTyxHQUFHRyxTQUFTUixNQUFNSztZQUNwQztRQUNGO0lBQ0YsR0FDQTtRQUFDTjtRQUFNQztLQUFLO0FBRWhCO0FBRUEsU0FBU1EsU0FDUFQsSUFBZ0MsRUFDaENNLE9BQWlCO0lBRWpCLElBQUksT0FBT04sU0FBUyxZQUFZO1FBQzlCLE1BQU1VLFVBQVVWLEtBQUtNO1FBQ3JCLElBQUksT0FBT0ksWUFBWSxZQUFZO1lBQ2pDLE9BQU9BO1FBQ1QsT0FBTztZQUNMLE9BQU8sSUFBTVYsS0FBSztRQUNwQjtJQUNGLE9BQU87UUFDTEEsS0FBS00sT0FBTyxHQUFHQTtRQUNmLE9BQU87WUFDTE4sS0FBS00sT0FBTyxHQUFHO1FBQ2pCO0lBQ0Y7QUFDRiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAyMTU5LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL3NoYXJlZC9saWIvdXRpbHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBIdG1sUHJvcHMgfSBmcm9tICcuL2h0bWwtY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB0eXBlIHsgQ29tcG9uZW50VHlwZSwgSlNYIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgdHlwZSB7IERvbWFpbkxvY2FsZSB9IGZyb20gJy4uLy4uL3NlcnZlci9jb25maWcnXG5pbXBvcnQgdHlwZSB7IEVudiB9IGZyb20gJ0BuZXh0L2VudidcbmltcG9ydCB0eXBlIHsgSW5jb21pbmdNZXNzYWdlLCBTZXJ2ZXJSZXNwb25zZSB9IGZyb20gJ2h0dHAnXG5pbXBvcnQgdHlwZSB7IE5leHRSb3V0ZXIgfSBmcm9tICcuL3JvdXRlci9yb3V0ZXInXG5pbXBvcnQgdHlwZSB7IFBhcnNlZFVybFF1ZXJ5IH0gZnJvbSAncXVlcnlzdHJpbmcnXG5pbXBvcnQgdHlwZSB7IFByZXZpZXdEYXRhIH0gZnJvbSAnLi4vLi4vdHlwZXMnXG5pbXBvcnQgdHlwZSB7IENPTVBJTEVSX05BTUVTIH0gZnJvbSAnLi9jb25zdGFudHMnXG5pbXBvcnQgdHlwZSBmcyBmcm9tICdmcydcblxuZXhwb3J0IHR5cGUgTmV4dENvbXBvbmVudFR5cGU8XG4gIENvbnRleHQgZXh0ZW5kcyBCYXNlQ29udGV4dCA9IE5leHRQYWdlQ29udGV4dCxcbiAgSW5pdGlhbFByb3BzID0ge30sXG4gIFByb3BzID0ge30sXG4+ID0gQ29tcG9uZW50VHlwZTxQcm9wcz4gJiB7XG4gIC8qKlxuICAgKiBVc2VkIGZvciBpbml0aWFsIHBhZ2UgbG9hZCBkYXRhIHBvcHVsYXRpb24uIERhdGEgcmV0dXJuZWQgZnJvbSBgZ2V0SW5pdGlhbFByb3BzYCBpcyBzZXJpYWxpemVkIHdoZW4gc2VydmVyIHJlbmRlcmVkLlxuICAgKiBNYWtlIHN1cmUgdG8gcmV0dXJuIHBsYWluIGBPYmplY3RgIHdpdGhvdXQgdXNpbmcgYERhdGVgLCBgTWFwYCwgYFNldGAuXG4gICAqIEBwYXJhbSBjb250ZXh0IENvbnRleHQgb2YgYHBhZ2VgXG4gICAqL1xuICBnZXRJbml0aWFsUHJvcHM/KGNvbnRleHQ6IENvbnRleHQpOiBJbml0aWFsUHJvcHMgfCBQcm9taXNlPEluaXRpYWxQcm9wcz5cbn1cblxuZXhwb3J0IHR5cGUgRG9jdW1lbnRUeXBlID0gTmV4dENvbXBvbmVudFR5cGU8XG4gIERvY3VtZW50Q29udGV4dCxcbiAgRG9jdW1lbnRJbml0aWFsUHJvcHMsXG4gIERvY3VtZW50UHJvcHNcbj5cblxuZXhwb3J0IHR5cGUgQXBwVHlwZTxQID0ge30+ID0gTmV4dENvbXBvbmVudFR5cGU8XG4gIEFwcENvbnRleHRUeXBlLFxuICBQLFxuICBBcHBQcm9wc1R5cGU8YW55LCBQPlxuPlxuXG5leHBvcnQgdHlwZSBBcHBUcmVlVHlwZSA9IENvbXBvbmVudFR5cGU8XG4gIEFwcEluaXRpYWxQcm9wcyAmIHsgW25hbWU6IHN0cmluZ106IGFueSB9XG4+XG5cbi8qKlxuICogV2ViIHZpdGFscyBwcm92aWRlZCB0byBfYXBwLnJlcG9ydFdlYlZpdGFscyBieSBDb3JlIFdlYiBWaXRhbHMgcGx1Z2luIGRldmVsb3BlZCBieSBHb29nbGUgQ2hyb21lIHRlYW0uXG4gKiBodHRwczovL25leHRqcy5vcmcvYmxvZy9uZXh0LTktNCNpbnRlZ3JhdGVkLXdlYi12aXRhbHMtcmVwb3J0aW5nXG4gKi9cbmV4cG9ydCBjb25zdCBXRUJfVklUQUxTID0gWydDTFMnLCAnRkNQJywgJ0ZJRCcsICdJTlAnLCAnTENQJywgJ1RURkInXSBhcyBjb25zdFxuZXhwb3J0IHR5cGUgTmV4dFdlYlZpdGFsc01ldHJpYyA9IHtcbiAgaWQ6IHN0cmluZ1xuICBzdGFydFRpbWU6IG51bWJlclxuICB2YWx1ZTogbnVtYmVyXG4gIGF0dHJpYnV0aW9uPzogeyBba2V5OiBzdHJpbmddOiB1bmtub3duIH1cbn0gJiAoXG4gIHwge1xuICAgICAgbGFiZWw6ICd3ZWItdml0YWwnXG4gICAgICBuYW1lOiAodHlwZW9mIFdFQl9WSVRBTFMpW251bWJlcl1cbiAgICB9XG4gIHwge1xuICAgICAgbGFiZWw6ICdjdXN0b20nXG4gICAgICBuYW1lOlxuICAgICAgICB8ICdOZXh0LmpzLWh5ZHJhdGlvbidcbiAgICAgICAgfCAnTmV4dC5qcy1yb3V0ZS1jaGFuZ2UtdG8tcmVuZGVyJ1xuICAgICAgICB8ICdOZXh0LmpzLXJlbmRlcidcbiAgICB9XG4pXG5cbmV4cG9ydCB0eXBlIEVuaGFuY2VyPEM+ID0gKENvbXBvbmVudDogQykgPT4gQ1xuXG5leHBvcnQgdHlwZSBDb21wb25lbnRzRW5oYW5jZXIgPVxuICB8IHtcbiAgICAgIGVuaGFuY2VBcHA/OiBFbmhhbmNlcjxBcHBUeXBlPlxuICAgICAgZW5oYW5jZUNvbXBvbmVudD86IEVuaGFuY2VyPE5leHRDb21wb25lbnRUeXBlPlxuICAgIH1cbiAgfCBFbmhhbmNlcjxOZXh0Q29tcG9uZW50VHlwZT5cblxuZXhwb3J0IHR5cGUgUmVuZGVyUGFnZVJlc3VsdCA9IHtcbiAgaHRtbDogc3RyaW5nXG4gIGhlYWQ/OiBBcnJheTxKU1guRWxlbWVudCB8IG51bGw+XG59XG5cbmV4cG9ydCB0eXBlIFJlbmRlclBhZ2UgPSAoXG4gIG9wdGlvbnM/OiBDb21wb25lbnRzRW5oYW5jZXJcbikgPT4gRG9jdW1lbnRJbml0aWFsUHJvcHMgfCBQcm9taXNlPERvY3VtZW50SW5pdGlhbFByb3BzPlxuXG5leHBvcnQgdHlwZSBCYXNlQ29udGV4dCA9IHtcbiAgcmVzPzogU2VydmVyUmVzcG9uc2VcbiAgW2s6IHN0cmluZ106IGFueVxufVxuXG5leHBvcnQgdHlwZSBORVhUX0RBVEEgPSB7XG4gIHByb3BzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4gIHBhZ2U6IHN0cmluZ1xuICBxdWVyeTogUGFyc2VkVXJsUXVlcnlcbiAgYnVpbGRJZDogc3RyaW5nXG4gIGFzc2V0UHJlZml4Pzogc3RyaW5nXG4gIHJ1bnRpbWVDb25maWc/OiB7IFtrZXk6IHN0cmluZ106IGFueSB9XG4gIG5leHRFeHBvcnQ/OiBib29sZWFuXG4gIGF1dG9FeHBvcnQ/OiBib29sZWFuXG4gIGlzRmFsbGJhY2s/OiBib29sZWFuXG4gIGlzRXhwZXJpbWVudGFsQ29tcGlsZT86IGJvb2xlYW5cbiAgZHluYW1pY0lkcz86IChzdHJpbmcgfCBudW1iZXIpW11cbiAgZXJyPzogRXJyb3IgJiB7XG4gICAgc3RhdHVzQ29kZT86IG51bWJlclxuICAgIHNvdXJjZT86IHR5cGVvZiBDT01QSUxFUl9OQU1FUy5zZXJ2ZXIgfCB0eXBlb2YgQ09NUElMRVJfTkFNRVMuZWRnZVNlcnZlclxuICB9XG4gIGdzcD86IGJvb2xlYW5cbiAgZ3NzcD86IGJvb2xlYW5cbiAgY3VzdG9tU2VydmVyPzogYm9vbGVhblxuICBnaXA/OiBib29sZWFuXG4gIGFwcEdpcD86IGJvb2xlYW5cbiAgbG9jYWxlPzogc3RyaW5nXG4gIGxvY2FsZXM/OiByZWFkb25seSBzdHJpbmdbXVxuICBkZWZhdWx0TG9jYWxlPzogc3RyaW5nXG4gIGRvbWFpbkxvY2FsZXM/OiByZWFkb25seSBEb21haW5Mb2NhbGVbXVxuICBzY3JpcHRMb2FkZXI/OiBhbnlbXVxuICBpc1ByZXZpZXc/OiBib29sZWFuXG4gIG5vdEZvdW5kU3JjUGFnZT86IHN0cmluZ1xufVxuXG4vKipcbiAqIGBOZXh0YCBjb250ZXh0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTmV4dFBhZ2VDb250ZXh0IHtcbiAgLyoqXG4gICAqIEVycm9yIG9iamVjdCBpZiBlbmNvdW50ZXJlZCBkdXJpbmcgcmVuZGVyaW5nXG4gICAqL1xuICBlcnI/OiAoRXJyb3IgJiB7IHN0YXR1c0NvZGU/OiBudW1iZXIgfSkgfCBudWxsXG4gIC8qKlxuICAgKiBgSFRUUGAgcmVxdWVzdCBvYmplY3QuXG4gICAqL1xuICByZXE/OiBJbmNvbWluZ01lc3NhZ2VcbiAgLyoqXG4gICAqIGBIVFRQYCByZXNwb25zZSBvYmplY3QuXG4gICAqL1xuICByZXM/OiBTZXJ2ZXJSZXNwb25zZVxuICAvKipcbiAgICogUGF0aCBzZWN0aW9uIG9mIGBVUkxgLlxuICAgKi9cbiAgcGF0aG5hbWU6IHN0cmluZ1xuICAvKipcbiAgICogUXVlcnkgc3RyaW5nIHNlY3Rpb24gb2YgYFVSTGAgcGFyc2VkIGFzIGFuIG9iamVjdC5cbiAgICovXG4gIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeVxuICAvKipcbiAgICogYFN0cmluZ2Agb2YgdGhlIGFjdHVhbCBwYXRoIGluY2x1ZGluZyBxdWVyeS5cbiAgICovXG4gIGFzUGF0aD86IHN0cmluZ1xuICAvKipcbiAgICogVGhlIGN1cnJlbnRseSBhY3RpdmUgbG9jYWxlXG4gICAqL1xuICBsb2NhbGU/OiBzdHJpbmdcbiAgLyoqXG4gICAqIEFsbCBjb25maWd1cmVkIGxvY2FsZXNcbiAgICovXG4gIGxvY2FsZXM/OiByZWFkb25seSBzdHJpbmdbXVxuICAvKipcbiAgICogVGhlIGNvbmZpZ3VyZWQgZGVmYXVsdCBsb2NhbGVcbiAgICovXG4gIGRlZmF1bHRMb2NhbGU/OiBzdHJpbmdcbiAgLyoqXG4gICAqIGBDb21wb25lbnRgIHRoZSB0cmVlIG9mIHRoZSBBcHAgdG8gdXNlIGlmIG5lZWRpbmcgdG8gcmVuZGVyIHNlcGFyYXRlbHlcbiAgICovXG4gIEFwcFRyZWU6IEFwcFRyZWVUeXBlXG59XG5cbmV4cG9ydCB0eXBlIEFwcENvbnRleHRUeXBlPFJvdXRlciBleHRlbmRzIE5leHRSb3V0ZXIgPSBOZXh0Um91dGVyPiA9IHtcbiAgQ29tcG9uZW50OiBOZXh0Q29tcG9uZW50VHlwZTxOZXh0UGFnZUNvbnRleHQ+XG4gIEFwcFRyZWU6IEFwcFRyZWVUeXBlXG4gIGN0eDogTmV4dFBhZ2VDb250ZXh0XG4gIHJvdXRlcjogUm91dGVyXG59XG5cbmV4cG9ydCB0eXBlIEFwcEluaXRpYWxQcm9wczxQYWdlUHJvcHMgPSBhbnk+ID0ge1xuICBwYWdlUHJvcHM6IFBhZ2VQcm9wc1xufVxuXG5leHBvcnQgdHlwZSBBcHBQcm9wc1R5cGU8XG4gIFJvdXRlciBleHRlbmRzIE5leHRSb3V0ZXIgPSBOZXh0Um91dGVyLFxuICBQYWdlUHJvcHMgPSB7fSxcbj4gPSBBcHBJbml0aWFsUHJvcHM8UGFnZVByb3BzPiAmIHtcbiAgQ29tcG9uZW50OiBOZXh0Q29tcG9uZW50VHlwZTxOZXh0UGFnZUNvbnRleHQsIGFueSwgYW55PlxuICByb3V0ZXI6IFJvdXRlclxuICBfX05fU1NHPzogYm9vbGVhblxuICBfX05fU1NQPzogYm9vbGVhblxufVxuXG5leHBvcnQgdHlwZSBEb2N1bWVudENvbnRleHQgPSBOZXh0UGFnZUNvbnRleHQgJiB7XG4gIHJlbmRlclBhZ2U6IFJlbmRlclBhZ2VcbiAgZGVmYXVsdEdldEluaXRpYWxQcm9wcyhcbiAgICBjdHg6IERvY3VtZW50Q29udGV4dCxcbiAgICBvcHRpb25zPzogeyBub25jZT86IHN0cmluZyB9XG4gICk6IFByb21pc2U8RG9jdW1lbnRJbml0aWFsUHJvcHM+XG59XG5cbmV4cG9ydCB0eXBlIERvY3VtZW50SW5pdGlhbFByb3BzID0gUmVuZGVyUGFnZVJlc3VsdCAmIHtcbiAgc3R5bGVzPzogUmVhY3QuUmVhY3RFbGVtZW50W10gfCBJdGVyYWJsZTxSZWFjdC5SZWFjdE5vZGU+IHwgSlNYLkVsZW1lbnRcbn1cblxuZXhwb3J0IHR5cGUgRG9jdW1lbnRQcm9wcyA9IERvY3VtZW50SW5pdGlhbFByb3BzICYgSHRtbFByb3BzXG5cbi8qKlxuICogTmV4dCBgQVBJYCByb3V0ZSByZXF1ZXN0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTmV4dEFwaVJlcXVlc3QgZXh0ZW5kcyBJbmNvbWluZ01lc3NhZ2Uge1xuICAvKipcbiAgICogT2JqZWN0IG9mIGBxdWVyeWAgdmFsdWVzIGZyb20gdXJsXG4gICAqL1xuICBxdWVyeTogUGFydGlhbDx7XG4gICAgW2tleTogc3RyaW5nXTogc3RyaW5nIHwgc3RyaW5nW11cbiAgfT5cbiAgLyoqXG4gICAqIE9iamVjdCBvZiBgY29va2llc2AgZnJvbSBoZWFkZXJcbiAgICovXG4gIGNvb2tpZXM6IFBhcnRpYWw8e1xuICAgIFtrZXk6IHN0cmluZ106IHN0cmluZ1xuICB9PlxuXG4gIGJvZHk6IGFueVxuXG4gIGVudjogRW52XG5cbiAgZHJhZnRNb2RlPzogYm9vbGVhblxuXG4gIHByZXZpZXc/OiBib29sZWFuXG4gIC8qKlxuICAgKiBQcmV2aWV3IGRhdGEgc2V0IG9uIHRoZSByZXF1ZXN0LCBpZiBhbnlcbiAgICogKi9cbiAgcHJldmlld0RhdGE/OiBQcmV2aWV3RGF0YVxufVxuXG4vKipcbiAqIFNlbmQgYm9keSBvZiByZXNwb25zZVxuICovXG50eXBlIFNlbmQ8VD4gPSAoYm9keTogVCkgPT4gdm9pZFxuXG4vKipcbiAqIE5leHQgYEFQSWAgcm91dGUgcmVzcG9uc2VcbiAqL1xuZXhwb3J0IHR5cGUgTmV4dEFwaVJlc3BvbnNlPERhdGEgPSBhbnk+ID0gU2VydmVyUmVzcG9uc2UgJiB7XG4gIC8qKlxuICAgKiBTZW5kIGRhdGEgYGFueWAgZGF0YSBpbiByZXNwb25zZVxuICAgKi9cbiAgc2VuZDogU2VuZDxEYXRhPlxuICAvKipcbiAgICogU2VuZCBkYXRhIGBqc29uYCBkYXRhIGluIHJlc3BvbnNlXG4gICAqL1xuICBqc29uOiBTZW5kPERhdGE+XG4gIHN0YXR1czogKHN0YXR1c0NvZGU6IG51bWJlcikgPT4gTmV4dEFwaVJlc3BvbnNlPERhdGE+XG4gIHJlZGlyZWN0KHVybDogc3RyaW5nKTogTmV4dEFwaVJlc3BvbnNlPERhdGE+XG4gIHJlZGlyZWN0KHN0YXR1czogbnVtYmVyLCB1cmw6IHN0cmluZyk6IE5leHRBcGlSZXNwb25zZTxEYXRhPlxuXG4gIC8qKlxuICAgKiBTZXQgZHJhZnQgbW9kZVxuICAgKi9cbiAgc2V0RHJhZnRNb2RlOiAob3B0aW9uczogeyBlbmFibGU6IGJvb2xlYW4gfSkgPT4gTmV4dEFwaVJlc3BvbnNlPERhdGE+XG5cbiAgLyoqXG4gICAqIFNldCBwcmV2aWV3IGRhdGEgZm9yIE5leHQuanMnIHByZXJlbmRlciBtb2RlXG4gICAqL1xuICBzZXRQcmV2aWV3RGF0YTogKFxuICAgIGRhdGE6IG9iamVjdCB8IHN0cmluZyxcbiAgICBvcHRpb25zPzoge1xuICAgICAgLyoqXG4gICAgICAgKiBTcGVjaWZpZXMgdGhlIG51bWJlciAoaW4gc2Vjb25kcykgZm9yIHRoZSBwcmV2aWV3IHNlc3Npb24gdG8gbGFzdCBmb3IuXG4gICAgICAgKiBUaGUgZ2l2ZW4gbnVtYmVyIHdpbGwgYmUgY29udmVydGVkIHRvIGFuIGludGVnZXIgYnkgcm91bmRpbmcgZG93bi5cbiAgICAgICAqIEJ5IGRlZmF1bHQsIG5vIG1heGltdW0gYWdlIGlzIHNldCBhbmQgdGhlIHByZXZpZXcgc2Vzc2lvbiBmaW5pc2hlc1xuICAgICAgICogd2hlbiB0aGUgY2xpZW50IHNodXRzIGRvd24gKGJyb3dzZXIgaXMgY2xvc2VkKS5cbiAgICAgICAqL1xuICAgICAgbWF4QWdlPzogbnVtYmVyXG4gICAgICAvKipcbiAgICAgICAqIFNwZWNpZmllcyB0aGUgcGF0aCBmb3IgdGhlIHByZXZpZXcgc2Vzc2lvbiB0byB3b3JrIHVuZGVyLiBCeSBkZWZhdWx0LFxuICAgICAgICogdGhlIHBhdGggaXMgY29uc2lkZXJlZCB0aGUgXCJkZWZhdWx0IHBhdGhcIiwgaS5lLiwgYW55IHBhZ2VzIHVuZGVyIFwiL1wiLlxuICAgICAgICovXG4gICAgICBwYXRoPzogc3RyaW5nXG4gICAgfVxuICApID0+IE5leHRBcGlSZXNwb25zZTxEYXRhPlxuXG4gIC8qKlxuICAgKiBDbGVhciBwcmV2aWV3IGRhdGEgZm9yIE5leHQuanMnIHByZXJlbmRlciBtb2RlXG4gICAqL1xuICBjbGVhclByZXZpZXdEYXRhOiAob3B0aW9ucz86IHsgcGF0aD86IHN0cmluZyB9KSA9PiBOZXh0QXBpUmVzcG9uc2U8RGF0YT5cblxuICAvKipcbiAgICogUmV2YWxpZGF0ZSBhIHNwZWNpZmljIHBhZ2UgYW5kIHJlZ2VuZXJhdGUgaXQgdXNpbmcgT24tRGVtYW5kIEluY3JlbWVudGFsXG4gICAqIFN0YXRpYyBSZWdlbmVyYXRpb24uXG4gICAqIFRoZSBwYXRoIHNob3VsZCBiZSBhbiBhY3R1YWwgcGF0aCwgbm90IGEgcmV3cml0dGVuIHBhdGguIEUuZy4gZm9yXG4gICAqIFwiL2Jsb2cvW3NsdWddXCIgdGhpcyBzaG91bGQgYmUgXCIvYmxvZy9wb3N0LTFcIi5cbiAgICogQGxpbmsgaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2J1aWxkaW5nLXlvdXItYXBwbGljYXRpb24vZGF0YS1mZXRjaGluZy9pbmNyZW1lbnRhbC1zdGF0aWMtcmVnZW5lcmF0aW9uI29uLWRlbWFuZC1yZXZhbGlkYXRpb24td2l0aC1yZXZhbGlkYXRlcGF0aFxuICAgKi9cbiAgcmV2YWxpZGF0ZTogKFxuICAgIHVybFBhdGg6IHN0cmluZyxcbiAgICBvcHRzPzoge1xuICAgICAgdW5zdGFibGVfb25seUdlbmVyYXRlZD86IGJvb2xlYW5cbiAgICB9XG4gICkgPT4gUHJvbWlzZTx2b2lkPlxufVxuXG4vKipcbiAqIE5leHQgYEFQSWAgcm91dGUgaGFuZGxlclxuICovXG5leHBvcnQgdHlwZSBOZXh0QXBpSGFuZGxlcjxUID0gYW55PiA9IChcbiAgcmVxOiBOZXh0QXBpUmVxdWVzdCxcbiAgcmVzOiBOZXh0QXBpUmVzcG9uc2U8VD5cbikgPT4gdW5rbm93biB8IFByb21pc2U8dW5rbm93bj5cblxuLyoqXG4gKiBVdGlsc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZXhlY09uY2U8VCBleHRlbmRzICguLi5hcmdzOiBhbnlbXSkgPT4gUmV0dXJuVHlwZTxUPj4oXG4gIGZuOiBUXG4pOiBUIHtcbiAgbGV0IHVzZWQgPSBmYWxzZVxuICBsZXQgcmVzdWx0OiBSZXR1cm5UeXBlPFQ+XG5cbiAgcmV0dXJuICgoLi4uYXJnczogYW55W10pID0+IHtcbiAgICBpZiAoIXVzZWQpIHtcbiAgICAgIHVzZWQgPSB0cnVlXG4gICAgICByZXN1bHQgPSBmbiguLi5hcmdzKVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH0pIGFzIFRcbn1cblxuLy8gU2NoZW1lOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTMuMVxuLy8gQWJzb2x1dGUgVVJMOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTQuM1xuY29uc3QgQUJTT0xVVEVfVVJMX1JFR0VYID0gL15bYS16QS1aXVthLXpBLVpcXGQrXFwtLl0qPzovXG5leHBvcnQgY29uc3QgaXNBYnNvbHV0ZVVybCA9ICh1cmw6IHN0cmluZykgPT4gQUJTT0xVVEVfVVJMX1JFR0VYLnRlc3QodXJsKVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TG9jYXRpb25PcmlnaW4oKSB7XG4gIGNvbnN0IHsgcHJvdG9jb2wsIGhvc3RuYW1lLCBwb3J0IH0gPSB3aW5kb3cubG9jYXRpb25cbiAgcmV0dXJuIGAke3Byb3RvY29sfS8vJHtob3N0bmFtZX0ke3BvcnQgPyAnOicgKyBwb3J0IDogJyd9YFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VVJMKCkge1xuICBjb25zdCB7IGhyZWYgfSA9IHdpbmRvdy5sb2NhdGlvblxuICBjb25zdCBvcmlnaW4gPSBnZXRMb2NhdGlvbk9yaWdpbigpXG4gIHJldHVybiBocmVmLnN1YnN0cmluZyhvcmlnaW4ubGVuZ3RoKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGlzcGxheU5hbWU8UD4oQ29tcG9uZW50OiBDb21wb25lbnRUeXBlPFA+KSB7XG4gIHJldHVybiB0eXBlb2YgQ29tcG9uZW50ID09PSAnc3RyaW5nJ1xuICAgID8gQ29tcG9uZW50XG4gICAgOiBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ1Vua25vd24nXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1Jlc1NlbnQocmVzOiBTZXJ2ZXJSZXNwb25zZSkge1xuICByZXR1cm4gcmVzLmZpbmlzaGVkIHx8IHJlcy5oZWFkZXJzU2VudFxufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplUmVwZWF0ZWRTbGFzaGVzKHVybDogc3RyaW5nKSB7XG4gIGNvbnN0IHVybFBhcnRzID0gdXJsLnNwbGl0KCc/JylcbiAgY29uc3QgdXJsTm9RdWVyeSA9IHVybFBhcnRzWzBdXG5cbiAgcmV0dXJuIChcbiAgICB1cmxOb1F1ZXJ5XG4gICAgICAvLyBmaXJzdCB3ZSByZXBsYWNlIGFueSBub24tZW5jb2RlZCBiYWNrc2xhc2hlcyB3aXRoIGZvcndhcmRcbiAgICAgIC8vIHRoZW4gbm9ybWFsaXplIHJlcGVhdGVkIGZvcndhcmQgc2xhc2hlc1xuICAgICAgLnJlcGxhY2UoL1xcXFwvZywgJy8nKVxuICAgICAgLnJlcGxhY2UoL1xcL1xcLysvZywgJy8nKSArXG4gICAgKHVybFBhcnRzWzFdID8gYD8ke3VybFBhcnRzLnNsaWNlKDEpLmpvaW4oJz8nKX1gIDogJycpXG4gIClcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxvYWRHZXRJbml0aWFsUHJvcHM8XG4gIEMgZXh0ZW5kcyBCYXNlQ29udGV4dCxcbiAgSVAgPSB7fSxcbiAgUCA9IHt9LFxuPihBcHA6IE5leHRDb21wb25lbnRUeXBlPEMsIElQLCBQPiwgY3R4OiBDKTogUHJvbWlzZTxJUD4ge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChBcHAucHJvdG90eXBlPy5nZXRJbml0aWFsUHJvcHMpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgXCIke2dldERpc3BsYXlOYW1lKFxuICAgICAgICBBcHBcbiAgICAgICl9LmdldEluaXRpYWxQcm9wcygpXCIgaXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBtZXRob2QgLSB2aXNpdCBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9nZXQtaW5pdGlhbC1wcm9wcy1hcy1hbi1pbnN0YW5jZS1tZXRob2QgZm9yIG1vcmUgaW5mb3JtYXRpb24uYFxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpXG4gICAgfVxuICB9XG4gIC8vIHdoZW4gY2FsbGVkIGZyb20gX2FwcCBgY3R4YCBpcyBuZXN0ZWQgaW4gYGN0eGBcbiAgY29uc3QgcmVzID0gY3R4LnJlcyB8fCAoY3R4LmN0eCAmJiBjdHguY3R4LnJlcylcblxuICBpZiAoIUFwcC5nZXRJbml0aWFsUHJvcHMpIHtcbiAgICBpZiAoY3R4LmN0eCAmJiBjdHguQ29tcG9uZW50KSB7XG4gICAgICAvLyBAdHMtaWdub3JlIHBhZ2VQcm9wcyBkZWZhdWx0XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYWdlUHJvcHM6IGF3YWl0IGxvYWRHZXRJbml0aWFsUHJvcHMoY3R4LkNvbXBvbmVudCwgY3R4LmN0eCksXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7fSBhcyBJUFxuICB9XG5cbiAgY29uc3QgcHJvcHMgPSBhd2FpdCBBcHAuZ2V0SW5pdGlhbFByb3BzKGN0eClcblxuICBpZiAocmVzICYmIGlzUmVzU2VudChyZXMpKSB7XG4gICAgcmV0dXJuIHByb3BzXG4gIH1cblxuICBpZiAoIXByb3BzKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGBcIiR7Z2V0RGlzcGxheU5hbWUoXG4gICAgICBBcHBcbiAgICApfS5nZXRJbml0aWFsUHJvcHMoKVwiIHNob3VsZCByZXNvbHZlIHRvIGFuIG9iamVjdC4gQnV0IGZvdW5kIFwiJHtwcm9wc31cIiBpbnN0ZWFkLmBcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSlcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKE9iamVjdC5rZXlzKHByb3BzKS5sZW5ndGggPT09IDAgJiYgIWN0eC5jdHgpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYCR7Z2V0RGlzcGxheU5hbWUoXG4gICAgICAgICAgQXBwXG4gICAgICAgICl9IHJldHVybmVkIGFuIGVtcHR5IG9iamVjdCBmcm9tIFxcYGdldEluaXRpYWxQcm9wc1xcYC4gVGhpcyBkZS1vcHRpbWl6ZXMgYW5kIHByZXZlbnRzIGF1dG9tYXRpYyBzdGF0aWMgb3B0aW1pemF0aW9uLiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9lbXB0eS1vYmplY3QtZ2V0SW5pdGlhbFByb3BzYFxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwcm9wc1xufVxuXG5leHBvcnQgY29uc3QgU1AgPSB0eXBlb2YgcGVyZm9ybWFuY2UgIT09ICd1bmRlZmluZWQnXG5leHBvcnQgY29uc3QgU1QgPVxuICBTUCAmJlxuICAoWydtYXJrJywgJ21lYXN1cmUnLCAnZ2V0RW50cmllc0J5TmFtZSddIGFzIGNvbnN0KS5ldmVyeShcbiAgICAobWV0aG9kKSA9PiB0eXBlb2YgcGVyZm9ybWFuY2VbbWV0aG9kXSA9PT0gJ2Z1bmN0aW9uJ1xuICApXG5cbmV4cG9ydCBjbGFzcyBEZWNvZGVFcnJvciBleHRlbmRzIEVycm9yIHt9XG5leHBvcnQgY2xhc3MgTm9ybWFsaXplRXJyb3IgZXh0ZW5kcyBFcnJvciB7fVxuZXhwb3J0IGNsYXNzIFBhZ2VOb3RGb3VuZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb2RlOiBzdHJpbmdcblxuICBjb25zdHJ1Y3RvcihwYWdlOiBzdHJpbmcpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5jb2RlID0gJ0VOT0VOVCdcbiAgICB0aGlzLm5hbWUgPSAnUGFnZU5vdEZvdW5kRXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gYENhbm5vdCBmaW5kIG1vZHVsZSBmb3IgcGFnZTogJHtwYWdlfWBcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgTWlzc2luZ1N0YXRpY1BhZ2UgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHBhZ2U6IHN0cmluZywgbWVzc2FnZTogc3RyaW5nKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMubWVzc2FnZSA9IGBGYWlsZWQgdG8gbG9hZCBzdGF0aWMgZmlsZSBmb3IgcGFnZTogJHtwYWdlfSAke21lc3NhZ2V9YFxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBNaWRkbGV3YXJlTm90Rm91bmRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29kZTogc3RyaW5nXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLmNvZGUgPSAnRU5PRU5UJ1xuICAgIHRoaXMubWVzc2FnZSA9IGBDYW5ub3QgZmluZCB0aGUgbWlkZGxld2FyZSBtb2R1bGVgXG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBDYWNoZUZzIHtcbiAgZXhpc3RzU3luYzogdHlwZW9mIGZzLmV4aXN0c1N5bmNcbiAgcmVhZEZpbGU6IHR5cGVvZiBmcy5wcm9taXNlcy5yZWFkRmlsZVxuICByZWFkRmlsZVN5bmM6IHR5cGVvZiBmcy5yZWFkRmlsZVN5bmNcbiAgd3JpdGVGaWxlKGY6IHN0cmluZywgZDogYW55KTogUHJvbWlzZTx2b2lkPlxuICBta2RpcihkaXI6IHN0cmluZyk6IFByb21pc2U8dm9pZCB8IHN0cmluZz5cbiAgc3RhdChmOiBzdHJpbmcpOiBQcm9taXNlPHsgbXRpbWU6IERhdGUgfT5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ2lmeUVycm9yKGVycm9yOiBFcnJvcikge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoeyBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLCBzdGFjazogZXJyb3Iuc3RhY2sgfSlcbn1cbiJdLCJuYW1lcyI6WyJEZWNvZGVFcnJvciIsIk1pZGRsZXdhcmVOb3RGb3VuZEVycm9yIiwiTWlzc2luZ1N0YXRpY1BhZ2UiLCJOb3JtYWxpemVFcnJvciIsIlBhZ2VOb3RGb3VuZEVycm9yIiwiU1AiLCJTVCIsIldFQl9WSVRBTFMiLCJleGVjT25jZSIsImdldERpc3BsYXlOYW1lIiwiZ2V0TG9jYXRpb25PcmlnaW4iLCJnZXRVUkwiLCJpc0Fic29sdXRlVXJsIiwiaXNSZXNTZW50IiwibG9hZEdldEluaXRpYWxQcm9wcyIsIm5vcm1hbGl6ZVJlcGVhdGVkU2xhc2hlcyIsInN0cmluZ2lmeUVycm9yIiwiZm4iLCJ1c2VkIiwicmVzdWx0IiwiYXJncyIsIkFCU09MVVRFX1VSTF9SRUdFWCIsInVybCIsInRlc3QiLCJwcm90b2NvbCIsImhvc3RuYW1lIiwicG9ydCIsIndpbmRvdyIsImxvY2F0aW9uIiwiaHJlZiIsIm9yaWdpbiIsInN1YnN0cmluZyIsImxlbmd0aCIsIkNvbXBvbmVudCIsImRpc3BsYXlOYW1lIiwibmFtZSIsInJlcyIsImZpbmlzaGVkIiwiaGVhZGVyc1NlbnQiLCJ1cmxQYXJ0cyIsInNwbGl0IiwidXJsTm9RdWVyeSIsInJlcGxhY2UiLCJzbGljZSIsImpvaW4iLCJBcHAiLCJjdHgiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJwcm90b3R5cGUiLCJnZXRJbml0aWFsUHJvcHMiLCJtZXNzYWdlIiwiRXJyb3IiLCJwYWdlUHJvcHMiLCJwcm9wcyIsIk9iamVjdCIsImtleXMiLCJjb25zb2xlIiwid2FybiIsInBlcmZvcm1hbmNlIiwiZXZlcnkiLCJtZXRob2QiLCJjb25zdHJ1Y3RvciIsInBhZ2UiLCJjb2RlIiwiZXJyb3IiLCJKU09OIiwic3RyaW5naWZ5Iiwic3RhY2siXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBb2FhQSxXQUFXLEVBQUE7ZUFBWEE7O0lBb0JBQyx1QkFBdUIsRUFBQTtlQUF2QkE7O0lBUEFDLGlCQUFpQixFQUFBO2VBQWpCQTs7SUFaQUMsY0FBYyxFQUFBO2VBQWRBOztJQUNBQyxpQkFBaUIsRUFBQTtlQUFqQkE7O0lBVEFDLEVBQUUsRUFBQTtlQUFGQTs7SUFDQUMsRUFBRSxFQUFBO2VBQUZBOztJQWxYQUMsVUFBVSxFQUFBO2VBQVZBOztJQXNRR0MsUUFBUSxFQUFBO2VBQVJBOztJQStCQUMsY0FBYyxFQUFBO2VBQWRBOztJQVhBQyxpQkFBaUIsRUFBQTtlQUFqQkE7O0lBS0FDLE1BQU0sRUFBQTtlQUFOQTs7SUFQSEMsYUFBYSxFQUFBO2VBQWJBOztJQW1CR0MsU0FBUyxFQUFBO2VBQVRBOztJQWtCTUMsbUJBQW1CLEVBQUE7ZUFBbkJBOztJQWROQyx3QkFBd0IsRUFBQTtlQUF4QkE7O0lBK0dBQyxjQUFjLEVBQUE7ZUFBZEE7OztBQTlaVCxNQUFNVCxhQUFhO0lBQUM7SUFB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SCxNQUFNRyxLQUFLO0lBQUM7QUFDckUiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMjM3MywgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9zaGFyZWQvbGliL3JvdXRlci91dGlscy9wYXJzZS1wYXRoLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogR2l2ZW4gYSBwYXRoIHRoaXMgZnVuY3Rpb24gd2lsbCBmaW5kIHRoZSBwYXRobmFtZSwgcXVlcnkgYW5kIGhhc2ggYW5kIHJldHVyblxuICogdGhlbS4gVGhpcyBpcyB1c2VmdWwgdG8gcGFyc2UgZnVsbCBwYXRocyBvbiB0aGUgY2xpZW50IHNpZGUuXG4gKiBAcGFyYW0gcGF0aCBBIHBhdGggdG8gcGFyc2UgZS5nLiAvZm9vL2Jhcj9pZD0xI2hhc2hcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUGF0aChwYXRoOiBzdHJpbmcpIHtcbiAgY29uc3QgaGFzaEluZGV4ID0gcGF0aC5pbmRleE9mKCcjJylcbiAgY29uc3QgcXVlcnlJbmRleCA9IHBhdGguaW5kZXhPZignPycpXG4gIGNvbnN0IGhhc1F1ZXJ5ID0gcXVlcnlJbmRleCA+IC0xICYmIChoYXNoSW5kZXggPCAwIHx8IHF1ZXJ5SW5kZXggPCBoYXNoSW5kZXgpXG5cbiAgaWYgKGhhc1F1ZXJ5IHx8IGhhc2hJbmRleCA+IC0xKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGhuYW1lOiBwYXRoLnN1YnN0cmluZygwLCBoYXNRdWVyeSA/IHF1ZXJ5SW5kZXggOiBoYXNoSW5kZXgpLFxuICAgICAgcXVlcnk6IGhhc1F1ZXJ5XG4gICAgICAgID8gcGF0aC5zdWJzdHJpbmcocXVlcnlJbmRleCwgaGFzaEluZGV4ID4gLTEgPyBoYXNoSW5kZXggOiB1bmRlZmluZWQpXG4gICAgICAgIDogJycsXG4gICAgICBoYXNoOiBoYXNoSW5kZXggPiAtMSA/IHBhdGguc2xpY2UoaGFzaEluZGV4KSA6ICcnLFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7IHBhdGhuYW1lOiBwYXRoLCBxdWVyeTogJycsIGhhc2g6ICcnIH1cbn1cbiJdLCJuYW1lcyI6WyJwYXJzZVBhdGgiLCJwYXRoIiwiaGFzaEluZGV4IiwiaW5kZXhPZiIsInF1ZXJ5SW5kZXgiLCJoYXNRdWVyeSIsInBhdGhuYW1lIiwic3Vic3RyaW5nIiwicXVlcnkiLCJ1bmRlZmluZWQiLCJoYXNoIiwic2xpY2UiXSwibWFwcGluZ3MiOiJBQUFBOzs7O0NBSUM7OzsrQkFDZUEsYUFBQUE7OztlQUFBQTs7O0FBQVQsU0FBU0EsVUFBVUMsSUFBWTtJQUNwQyxNQUFNQyxZQUFZRCxLQUFLRSxPQUFPLENBQUM7SUFDL0IsTUFBTUMsYUFBYUgsS0FBS0UsT0FBTyxDQUFDO0lBQ2hDLE1BQU1FLFdBQVdELGFBQWEsQ0FBQyxLQUFNRixDQUFBQSxZQUFZLEtBQUtFLGFBQWFGLFNBQVE7SUFFM0UsSUFBSUcsWUFBWUgsWUFBWSxDQUFDLEdBQUc7UUFDOUIsT0FBTztZQUNMSSxVQUFVTCxLQUFLTSxTQUFTLENBQUMsR0FBR0YsV0FBV0QsYUFBYUY7WUFDcERNLE9BQU9ILFdBQ0hKLEtBQUtNLFNBQVMsQ0FBQ0gsWUFBWUYsWUFBWSxDQUFDLElBQUlBLFlBQVlPLGFBQ3hEO1lBQ0pDLE1BQU1SLFlBQVksQ0FBQyxJQUFJRCxLQUFLVSxLQUFLLENBQUNULGFBQWE7UUFDakQ7SUFDRjtJQUVBLE9BQU87UUFBRUksVUFBVUw7UUFBTU8sT0FBTztRQUFJRSxNQUFNO0lBQUc7QUFDL0MiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMjQwOSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9zaGFyZWQvbGliL3JvdXRlci91dGlscy9hZGQtcGF0aC1wcmVmaXgudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcGFyc2VQYXRoIH0gZnJvbSAnLi9wYXJzZS1wYXRoJ1xuXG4vKipcbiAqIEFkZHMgdGhlIHByb3ZpZGVkIHByZWZpeCB0byB0aGUgZ2l2ZW4gcGF0aC4gSXQgZmlyc3QgZW5zdXJlcyB0aGF0IHRoZSBwYXRoXG4gKiBpcyBpbmRlZWQgc3RhcnRpbmcgd2l0aCBhIHNsYXNoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkUGF0aFByZWZpeChwYXRoOiBzdHJpbmcsIHByZWZpeD86IHN0cmluZykge1xuICBpZiAoIXBhdGguc3RhcnRzV2l0aCgnLycpIHx8ICFwcmVmaXgpIHtcbiAgICByZXR1cm4gcGF0aFxuICB9XG5cbiAgY29uc3QgeyBwYXRobmFtZSwgcXVlcnksIGhhc2ggfSA9IHBhcnNlUGF0aChwYXRoKVxuICByZXR1cm4gYCR7cHJlZml4fSR7cGF0aG5hbWV9JHtxdWVyeX0ke2hhc2h9YFxufVxuIl0sIm5hbWVzIjpbImFkZFBhdGhQcmVmaXgiLCJwYXRoIiwicHJlZml4Iiwic3RhcnRzV2l0aCIsInBhdGhuYW1lIiwicXVlcnkiLCJoYXNoIiwicGFyc2VQYXRoIl0sIm1hcHBpbmdzIjoiOzs7K0JBTWdCQSxpQkFBQUE7OztlQUFBQTs7OzJCQU5VO0FBTW5CLFNBQVNBLGNBQWNDLElBQVksRUFBRUMsTUFBZTtJQUN6RCxJQUFJLENBQUNELEtBQUtFLFVBQVUsQ0FBQyxRQUFRLENBQUNELFFBQVE7UUFDcEMsT0FBT0Q7SUFDVDtJQUVBLE1BQU0sRUFBRUcsUUFBUSxFQUFFQyxLQUFLLEVBQUVDLElBQUksRUFBRSxHQUFHQyxDQUFBQSxHQUFBQSxXQUFBQSxTQUFTLEVBQUNOO0lBQzVDLE9BQVEsS0FBRUMsU0FBU0UsV0FBV0MsUUFBUUM7QUFDeEMiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMjQzMiwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9zaGFyZWQvbGliL3JvdXRlci91dGlscy9yZW1vdmUtdHJhaWxpbmctc2xhc2gudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBSZW1vdmVzIHRoZSB0cmFpbGluZyBzbGFzaCBmb3IgYSBnaXZlbiByb3V0ZSBvciBwYWdlIHBhdGguIFByZXNlcnZlcyB0aGVcbiAqIHJvb3QgcGFnZS4gRXhhbXBsZXM6XG4gKiAgIC0gYC9mb28vYmFyL2AgLT4gYC9mb28vYmFyYFxuICogICAtIGAvZm9vL2JhcmAgLT4gYC9mb28vYmFyYFxuICogICAtIGAvYCAtPiBgL2BcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVRyYWlsaW5nU2xhc2gocm91dGU6IHN0cmluZykge1xuICByZXR1cm4gcm91dGUucmVwbGFjZSgvXFwvJC8sICcnKSB8fCAnLydcbn1cbiJdLCJuYW1lcyI6WyJyZW1vdmVUcmFpbGluZ1NsYXNoIiwicm91dGUiLCJyZXBsYWNlIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0NBTUM7OzsrQkFDZUEsdUJBQUFBOzs7ZUFBQUE7OztBQUFULFNBQVNBLG9CQUFvQkMsS0FBYTtJQUMvQyxPQUFPQSxNQUFNQyxPQUFPLENBQUMsT0FBTyxPQUFPO0FBQ3JDIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDI0NTYsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvY2xpZW50L25vcm1hbGl6ZS10cmFpbGluZy1zbGFzaC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByZW1vdmVUcmFpbGluZ1NsYXNoIH0gZnJvbSAnLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcmVtb3ZlLXRyYWlsaW5nLXNsYXNoJ1xuaW1wb3J0IHsgcGFyc2VQYXRoIH0gZnJvbSAnLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcGFyc2UtcGF0aCdcblxuLyoqXG4gKiBOb3JtYWxpemVzIHRoZSB0cmFpbGluZyBzbGFzaCBvZiBhIHBhdGggYWNjb3JkaW5nIHRvIHRoZSBgdHJhaWxpbmdTbGFzaGAgb3B0aW9uXG4gKiBpbiBgbmV4dC5jb25maWcuanNgLlxuICovXG5leHBvcnQgY29uc3Qgbm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2ggPSAocGF0aDogc3RyaW5nKSA9PiB7XG4gIGlmICghcGF0aC5zdGFydHNXaXRoKCcvJykgfHwgcHJvY2Vzcy5lbnYuX19ORVhUX01BTlVBTF9UUkFJTElOR19TTEFTSCkge1xuICAgIHJldHVybiBwYXRoXG4gIH1cblxuICBjb25zdCB7IHBhdGhuYW1lLCBxdWVyeSwgaGFzaCB9ID0gcGFyc2VQYXRoKHBhdGgpXG4gIGlmIChwcm9jZXNzLmVudi5fX05FWFRfVFJBSUxJTkdfU0xBU0gpIHtcbiAgICBpZiAoL1xcLlteL10rXFwvPyQvLnRlc3QocGF0aG5hbWUpKSB7XG4gICAgICByZXR1cm4gYCR7cmVtb3ZlVHJhaWxpbmdTbGFzaChwYXRobmFtZSl9JHtxdWVyeX0ke2hhc2h9YFxuICAgIH0gZWxzZSBpZiAocGF0aG5hbWUuZW5kc1dpdGgoJy8nKSkge1xuICAgICAgcmV0dXJuIGAke3BhdGhuYW1lfSR7cXVlcnl9JHtoYXNofWBcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGAke3BhdGhuYW1lfS8ke3F1ZXJ5fSR7aGFzaH1gXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGAke3JlbW92ZVRyYWlsaW5nU2xhc2gocGF0aG5hbWUpfSR7cXVlcnl9JHtoYXNofWBcbn1cbiJdLCJuYW1lcyI6WyJub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCIsInBhdGgiLCJzdGFydHNXaXRoIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9NQU5VQUxfVFJBSUxJTkdfU0xBU0giLCJwYXRobmFtZSIsInF1ZXJ5IiwiaGFzaCIsInBhcnNlUGF0aCIsIl9fTkVYVF9UUkFJTElOR19TTEFTSCIsInRlc3QiLCJyZW1vdmVUcmFpbGluZ1NsYXNoIiwiZW5kc1dpdGgiXSwibWFwcGluZ3MiOiI7OzsrQkFPYUEsOEJBQUFBOzs7ZUFBQUE7OztxQ0FQdUI7MkJBQ1Y7QUFNbkIsTUFBTUEsNkJBQTZCLENBQUNDO0lBQ3pDLElBQUksQ0FBQ0EsS0FBS0MsVUFBVSxDQUFDLFFBQVFDLFFBQVFDLEdBQUcsQ0FBQ0MsNEJBQTRCLEVBQUU7UUFDckUsT0FBT0o7SUFDVDtJQUVBLE1BQU0sRUFBRUssUUFBUSxFQUFFQyxLQUFLLEVBQUVDLElBQUksRUFBRSxHQUFHQyxDQUFBQSxHQUFBQSxXQUFBQSxTQUFTLEVBQUNSO0lBQzVDLElBQUlFLFFBQVFDLEdBQUcsQ0FBQ00scUJBQXFCLEdBQUU7UUFDckMsSUFBSSxjQUFjQyxJQUFJLENBQUNMLFdBQVc7WUFDaEMsT0FBUSxLQUFFTSxDQUFBQSxHQUFBQSxxQkFBQUEsbUJBQW1CLEVBQUNOLFlBQVlDLFFBQVFDO1FBQ3BELE9BQU8sSUFBSUYsU0FBU08sUUFBUSxDQUFDLE1BQU07WUFDakMsT0FBUSxLQUFFUCxXQUFXQyxRQUFRQztRQUMvQixPQUFPO1lBQ0wsT0FBVUYsV0FBUyxNQUFHQyxRQUFRQztRQUNoQztJQUNGOzs7QUFHRiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAyNDk3LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2NsaWVudC9hZGQtYmFzZS1wYXRoLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFkZFBhdGhQcmVmaXggfSBmcm9tICcuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9hZGQtcGF0aC1wcmVmaXgnXG5pbXBvcnQgeyBub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCB9IGZyb20gJy4vbm9ybWFsaXplLXRyYWlsaW5nLXNsYXNoJ1xuXG5jb25zdCBiYXNlUGF0aCA9IChwcm9jZXNzLmVudi5fX05FWFRfUk9VVEVSX0JBU0VQQVRIIGFzIHN0cmluZykgfHwgJydcblxuZXhwb3J0IGZ1bmN0aW9uIGFkZEJhc2VQYXRoKHBhdGg6IHN0cmluZywgcmVxdWlyZWQ/OiBib29sZWFuKTogc3RyaW5nIHtcbiAgcmV0dXJuIG5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoKFxuICAgIHByb2Nlc3MuZW52Ll9fTkVYVF9NQU5VQUxfQ0xJRU5UX0JBU0VfUEFUSCAmJiAhcmVxdWlyZWRcbiAgICAgID8gcGF0aFxuICAgICAgOiBhZGRQYXRoUHJlZml4KHBhdGgsIGJhc2VQYXRoKVxuICApXG59XG4iXSwibmFtZXMiOlsiYWRkQmFzZVBhdGgiLCJiYXNlUGF0aCIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfUk9VVEVSX0JBU0VQQVRIIiwicGF0aCIsInJlcXVpcmVkIiwibm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2giLCJfX05FWFRfTUFOVUFMX0NMSUVOVF9CQVNFX1BBVEgiLCJhZGRQYXRoUHJlZml4Il0sIm1hcHBpbmdzIjoiOzs7K0JBS2dCQSxlQUFBQTs7O2VBQUFBOzs7K0JBTGM7d0NBQ2E7QUFFM0MsTUFBTUMsV0FBWUMsUUFBUUMsR0FBRyxDQUFDQyxzQkFBc0IsTUFBZTtBQUU1RCxTQUFTSixZQUFZSyxJQUFZLEVBQUVDLFFBQWtCO0lBQzFELE9BQU9DLENBQUFBLEdBQUFBLHdCQUFBQSwwQkFBMEIsRUFDL0JMLFFBQVFDLEdBQUcsQ0FBQ0ssMEJBQ1JILElBRHNDLElBQUksQ0FBQ0MsaUJBRTNDRyxDQUFBQSxHQUFBQSxlQUFBQSxhQUFhLEVBQUNKLE1BQU1KO0FBRTVCIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDI1MjUsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvc2hhcmVkL2xpYi91dGlscy93YXJuLW9uY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsibGV0IHdhcm5PbmNlID0gKF86IHN0cmluZykgPT4ge31cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGNvbnN0IHdhcm5pbmdzID0gbmV3IFNldDxzdHJpbmc+KClcbiAgd2Fybk9uY2UgPSAobXNnOiBzdHJpbmcpID0+IHtcbiAgICBpZiAoIXdhcm5pbmdzLmhhcyhtc2cpKSB7XG4gICAgICBjb25zb2xlLndhcm4obXNnKVxuICAgIH1cbiAgICB3YXJuaW5ncy5hZGQobXNnKVxuICB9XG59XG5cbmV4cG9ydCB7IHdhcm5PbmNlIH1cbiJdLCJuYW1lcyI6WyJ3YXJuT25jZSIsIl8iLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJ3YXJuaW5ncyIsIlNldCIsIm1zZyIsImhhcyIsImNvbnNvbGUiLCJ3YXJuIiwiYWRkIl0sIm1hcHBpbmdzIjoiOzs7K0JBV1NBLFlBQUFBOzs7ZUFBQUE7OztBQVhULElBQUlBLFdBQVcsQ0FBQ0MsS0FBZTtBQUMvQixJQUFJQyxRQUFRQyxHQUFHLENBQUNDLFFBQVEsS0FBSyxXQUFjO0lBQ3pDLE1BQU1DLFdBQVcsSUFBSUM7SUFDckJOLFdBQVcsQ0FBQ087UUFDVixJQUFJLENBQUNGLFNBQVNHLEdBQUcsQ0FBQ0QsTUFBTTtZQUN0QkUsUUFBUUMsSUFBSSxDQUFDSDtRQUNmO1FBQ0FGLFNBQVNNLEdBQUcsQ0FBQ0o7SUFDZjtBQUNGIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDI1NTAsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvY2xpZW50L2NvbXBvbmVudHMvYXBwLXJvdXRlci1oZWFkZXJzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBSU0NfSEVBREVSID0gJ1JTQycgYXMgY29uc3RcbmV4cG9ydCBjb25zdCBBQ1RJT05fSEVBREVSID0gJ05leHQtQWN0aW9uJyBhcyBjb25zdFxuLy8gVE9ETzogSW5zdGVhZCBvZiBzZW5kaW5nIHRoZSBmdWxsIHJvdXRlciBzdGF0ZSwgd2Ugb25seSBuZWVkIHRvIHNlbmQgdGhlXG4vLyBzZWdtZW50IHBhdGguIFNhdmVzIGJ5dGVzLiBUaGVuIHdlIGNvdWxkIGFsc28gdXNlIHRoaXMgZmllbGQgZm9yIHNlZ21lbnRcbi8vIHByZWZldGNoZXMsIHdoaWNoIGFsc28gbmVlZCB0byBzcGVjaWZ5IGEgcGFydGljdWxhciBzZWdtZW50LlxuZXhwb3J0IGNvbnN0IE5FWFRfUk9VVEVSX1NUQVRFX1RSRUVfSEVBREVSID0gJ05leHQtUm91dGVyLVN0YXRlLVRyZWUnIGFzIGNvbnN0XG5leHBvcnQgY29uc3QgTkVYVF9ST1VURVJfUFJFRkVUQ0hfSEVBREVSID0gJ05leHQtUm91dGVyLVByZWZldGNoJyBhcyBjb25zdFxuLy8gVGhpcyBjb250YWlucyB0aGUgcGF0aCB0byB0aGUgc2VnbWVudCBiZWluZyBwcmVmZXRjaGVkLlxuLy8gVE9ETzogSWYgd2UgY2hhbmdlIE5leHQtUm91dGVyLVN0YXRlLVRyZWUgdG8gYmUgYSBzZWdtZW50IHBhdGgsIHdlIGNhbiB1c2Vcbi8vIHRoYXQgaW5zdGVhZC4gVGhlbiBOZXh0LVJvdXRlci1QcmVmZXRjaCBhbmQgTmV4dC1Sb3V0ZXItU2VnbWVudC1QcmVmZXRjaCBjYW5cbi8vIGJlIG1lcmdlZCBpbnRvIGEgc2luZ2xlIGVudW0uXG5leHBvcnQgY29uc3QgTkVYVF9ST1VURVJfU0VHTUVOVF9QUkVGRVRDSF9IRUFERVIgPVxuICAnTmV4dC1Sb3V0ZXItU2VnbWVudC1QcmVmZXRjaCcgYXMgY29uc3RcbmV4cG9ydCBjb25zdCBORVhUX0hNUl9SRUZSRVNIX0hFQURFUiA9ICdOZXh0LUhNUi1SZWZyZXNoJyBhcyBjb25zdFxuZXhwb3J0IGNvbnN0IE5FWFRfSE1SX1JFRlJFU0hfSEFTSF9DT09LSUUgPSAnX19uZXh0X2htcl9yZWZyZXNoX2hhc2hfXycgYXMgY29uc3RcbmV4cG9ydCBjb25zdCBORVhUX1VSTCA9ICdOZXh0LVVybCcgYXMgY29uc3RcbmV4cG9ydCBjb25zdCBSU0NfQ09OVEVOVF9UWVBFX0hFQURFUiA9ICd0ZXh0L3gtY29tcG9uZW50JyBhcyBjb25zdFxuXG5leHBvcnQgY29uc3QgRkxJR0hUX0hFQURFUlMgPSBbXG4gIFJTQ19IRUFERVIsXG4gIE5FWFRfUk9VVEVSX1NUQVRFX1RSRUVfSEVBREVSLFxuICBORVhUX1JPVVRFUl9QUkVGRVRDSF9IRUFERVIsXG4gIE5FWFRfSE1SX1JFRlJFU0hfSEVBREVSLFxuICBORVhUX1JPVVRFUl9TRUdNRU5UX1BSRUZFVENIX0hFQURFUixcbl0gYXMgY29uc3RcblxuZXhwb3J0IGNvbnN0IE5FWFRfUlNDX1VOSU9OX1FVRVJZID0gJ19yc2MnIGFzIGNvbnN0XG5cbmV4cG9ydCBjb25zdCBORVhUX1JPVVRFUl9TVEFMRV9USU1FX0hFQURFUiA9ICd4LW5leHRqcy1zdGFsZS10aW1lJyBhcyBjb25zdFxuZXhwb3J0IGNvbnN0IE5FWFRfRElEX1BPU1RQT05FX0hFQURFUiA9ICd4LW5leHRqcy1wb3N0cG9uZWQnIGFzIGNvbnN0XG5leHBvcnQgY29uc3QgTkVYVF9SRVdSSVRURU5fUEFUSF9IRUFERVIgPSAneC1uZXh0anMtcmV3cml0dGVuLXBhdGgnIGFzIGNvbnN0XG5leHBvcnQgY29uc3QgTkVYVF9SRVdSSVRURU5fUVVFUllfSEVBREVSID0gJ3gtbmV4dGpzLXJld3JpdHRlbi1xdWVyeScgYXMgY29uc3RcbmV4cG9ydCBjb25zdCBORVhUX0lTX1BSRVJFTkRFUl9IRUFERVIgPSAneC1uZXh0anMtcHJlcmVuZGVyJyBhcyBjb25zdFxuZXhwb3J0IGNvbnN0IE5FWFRfQUNUSU9OX05PVF9GT1VORF9IRUFERVIgPSAneC1uZXh0anMtYWN0aW9uLW5vdC1mb3VuZCcgYXMgY29uc3RcbiJdLCJuYW1lcyI6WyJBQ1RJT05fSEVBREVSIiwiRkxJR0hUX0hFQURFUlMiLCJORVhUX0FDVElPTl9OT1RfRk9VTkRfSEVBREVSIiwiTkVYVF9ESURfUE9TVFBPTkVfSEVBREVSIiwiTkVYVF9ITVJfUkVGUkVTSF9IQVNIX0NPT0tJRSIsIk5FWFRfSE1SX1JFRlJFU0hfSEVBREVSIiwiTkVYVF9JU19QUkVSRU5ERVJfSEVBREVSIiwiTkVYVF9SRVdSSVRURU5fUEFUSF9IRUFERVIiLCJORVhUX1JFV1JJVFRFTl9RVUVSWV9IRUFERVIiLCJORVhUX1JPVVRFUl9QUkVGRVRDSF9IRUFERVIiLCJORVhUX1JPVVRFUl9TRUdNRU5UX1BSRUZFVENIX0hFQURFUiIsIk5FWFRfUk9VVEVSX1NUQUxFX1RJTUVfSEVBREVSIiwiTkVYVF9ST1VURVJfU1RBVEVfVFJFRV9IRUFERVIiLCJORVhUX1JTQ19VTklPTl9RVUVSWSIsIk5FWFRfVVJMIiwiUlNDX0NPTlRFTlRfVFlQRV9IRUFERVIiLCJSU0NfSEVBREVSIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQUNhQSxhQUFhLEVBQUE7ZUFBYkE7O0lBaUJBQyxjQUFjLEVBQUE7ZUFBZEE7O0lBZUFDLDRCQUE0QixFQUFBO2VBQTVCQTs7SUFKQUMsd0JBQXdCLEVBQUE7ZUFBeEJBOztJQWZBQyw0QkFBNEIsRUFBQTtlQUE1QkE7O0lBREFDLHVCQUF1QixFQUFBO2VBQXZCQTs7SUFtQkFDLHdCQUF3QixFQUFBO2VBQXhCQTs7SUFGQUMsMEJBQTBCLEVBQUE7ZUFBMUJBOztJQUNBQywyQkFBMkIsRUFBQTtlQUEzQkE7O0lBekJBQywyQkFBMkIsRUFBQTtlQUEzQkE7O0lBS0FDLG1DQUFtQyxFQUFBO2VBQW5DQTs7SUFpQkFDLDZCQUE2QixFQUFBO2VBQTdCQTs7SUF2QkFDLDZCQUE2QixFQUFBO2VBQTdCQTs7SUFxQkFDLG9CQUFvQixFQUFBO2VBQXBCQTs7SUFYQUMsUUFBUSxFQUFBO2VBQVJBOztJQUNBQyx1QkFBdUIsRUFBQTtlQUF2QkE7O0lBaEJBQyxVQUFVLEVBQUE7ZUFBVkE7OztBQUFOLE1BQU1BLGFBQWE7QUFDbkIsTUFBTWhCLGdCQUFnQjtBQUl0QixNQUFNWSxnQ0FBZ0M7QUFDdEMsTUFBTUgsOEJBQThCO0FBS3BDLE1BQU1DLHNDQUNYO0FBQ0ssTUFBTUwsMEJBQTBCO0FBQ2hDLE1BQU1ELCtCQUErQjtBQUNyQyxNQUFNVSxXQUFXO0FBQ2pCLE1BQU1DLDBCQUEwQjtBQUVoQyxNQUFNZCxpQkFBaUI7SUFDNUJlO0lBQ0FKO0lBQ0FIO0lBQ0FKO0lBQ0FLO0NBQ0Q7QUFFTSxNQUFNRyx1QkFBdUI7QUFFN0IsTUFBTUYsZ0NBQWdDO0FBQ3RDLE1BQU1SLDJCQUEyQjtBQUNqQyxNQUFNSSw2QkFBNkI7QUFDbkMsTUFBTUMsOEJBQThCO0FBQ3BDLE1BQU1GLDJCQUEyQjtBQUNqQyxNQUFNSiwrQkFBK0IiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMjY2NywgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9zaGFyZWQvbGliL2lzLXRoZW5hYmxlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ2hlY2sgdG8gc2VlIGlmIGEgdmFsdWUgaXMgVGhlbmFibGUuXG4gKlxuICogQHBhcmFtIHByb21pc2UgdGhlIG1heWJlLXRoZW5hYmxlIHZhbHVlXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZSBpcyB0aGVuYWJsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNUaGVuYWJsZTxUID0gdW5rbm93bj4oXG4gIHByb21pc2U6IFByb21pc2U8VD4gfCBUXG4pOiBwcm9taXNlIGlzIFByb21pc2U8VD4ge1xuICByZXR1cm4gKFxuICAgIHByb21pc2UgIT09IG51bGwgJiZcbiAgICB0eXBlb2YgcHJvbWlzZSA9PT0gJ29iamVjdCcgJiZcbiAgICAndGhlbicgaW4gcHJvbWlzZSAmJlxuICAgIHR5cGVvZiBwcm9taXNlLnRoZW4gPT09ICdmdW5jdGlvbidcbiAgKVxufVxuIl0sIm5hbWVzIjpbImlzVGhlbmFibGUiLCJwcm9taXNlIiwidGhlbiJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7O0NBS0M7OzsrQkFDZUEsY0FBQUE7OztlQUFBQTs7O0FBQVQsU0FBU0EsV0FDZEMsT0FBdUI7SUFFdkIsT0FDRUEsWUFBWSxRQUNaLE9BQU9BLFlBQVksWUFDbkIsVUFBVUEsV0FDVixPQUFPQSxRQUFRQyxJQUFJLEtBQUs7QUFFNUIiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMjY5MCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9uZXh0LWRldnRvb2xzL3VzZXJzcGFjZS91c2UtYXBwLWRldi1yZW5kZXJpbmctaW5kaWNhdG9yLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VUcmFuc2l0aW9uIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBkaXNwYXRjaGVyIH0gZnJvbSAnbmV4dC9kaXN0L2NvbXBpbGVkL25leHQtZGV2dG9vbHMnXG5cbmV4cG9ydCBjb25zdCB1c2VBcHBEZXZSZW5kZXJpbmdJbmRpY2F0b3IgPSAoKSA9PiB7XG4gIGNvbnN0IFtpc1BlbmRpbmcsIHN0YXJ0VHJhbnNpdGlvbl0gPSB1c2VUcmFuc2l0aW9uKClcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpc1BlbmRpbmcpIHtcbiAgICAgIGRpc3BhdGNoZXIucmVuZGVyaW5nSW5kaWNhdG9yU2hvdygpXG4gICAgfSBlbHNlIHtcbiAgICAgIGRpc3BhdGNoZXIucmVuZGVyaW5nSW5kaWNhdG9ySGlkZSgpXG4gICAgfVxuICB9LCBbaXNQZW5kaW5nXSlcblxuICByZXR1cm4gc3RhcnRUcmFuc2l0aW9uXG59XG4iXSwibmFtZXMiOlsidXNlQXBwRGV2UmVuZGVyaW5nSW5kaWNhdG9yIiwiaXNQZW5kaW5nIiwic3RhcnRUcmFuc2l0aW9uIiwidXNlVHJhbnNpdGlvbiIsInVzZUVmZmVjdCIsImRpc3BhdGNoZXIiLCJyZW5kZXJpbmdJbmRpY2F0b3JTaG93IiwicmVuZGVyaW5nSW5kaWNhdG9ySGlkZSJdLCJtYXBwaW5ncyI6Ijs7OytCQUthQSwrQkFBQUE7OztlQUFBQTs7O3VCQUg0Qjs4QkFDZDtBQUVwQixNQUFNQSw4QkFBOEI7SUFDekMsTUFBTSxDQUFDQyxXQUFXQyxnQkFBZ0IsR0FBR0MsQ0FBQUEsR0FBQUEsT0FBQUEsYUFBYTtJQUVsREMsQ0FBQUEsR0FBQUEsT0FBQUEsU0FBUyxFQUFDO1FBQ1IsSUFBSUgsV0FBVztZQUNiSSxjQUFBQSxVQUFVLENBQUNDLHNCQUFzQjtRQUNuQyxPQUFPO1lBQ0xELGNBQUFBLFVBQVUsQ0FBQ0Usc0JBQXNCO1FBQ25DO0lBQ0YsR0FBRztRQUFDTjtLQUFVO0lBRWQsT0FBT0M7QUFDVCIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAyNzI3LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2NsaWVudC9jb21wb25lbnRzL3VzZS1hY3Rpb24tcXVldWUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBEaXNwYXRjaCB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IFJlYWN0LCB7IHVzZSB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgaXNUaGVuYWJsZSB9IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvaXMtdGhlbmFibGUnXG5pbXBvcnQgdHlwZSB7IEFwcFJvdXRlckFjdGlvblF1ZXVlIH0gZnJvbSAnLi9hcHAtcm91dGVyLWluc3RhbmNlJ1xuaW1wb3J0IHR5cGUge1xuICBBcHBSb3V0ZXJTdGF0ZSxcbiAgUmVkdWNlckFjdGlvbnMsXG4gIFJlZHVjZXJTdGF0ZSxcbn0gZnJvbSAnLi9yb3V0ZXItcmVkdWNlci9yb3V0ZXItcmVkdWNlci10eXBlcydcblxuLy8gVGhlIGFwcCByb3V0ZXIgc3RhdGUgbGl2ZXMgb3V0c2lkZSBvZiBSZWFjdCwgc28gd2UgY2FuIGltcG9ydCB0aGUgZGlzcGF0Y2hcbi8vIG1ldGhvZCBkaXJlY3RseSB3aGVyZXZlciB3ZSBuZWVkIGl0LCByYXRoZXIgdGhhbiBwYXNzaW5nIGl0IGFyb3VuZCB2aWEgcHJvcHNcbi8vIG9yIGNvbnRleHQuXG5sZXQgZGlzcGF0Y2g6IERpc3BhdGNoPFJlZHVjZXJBY3Rpb25zPiB8IG51bGwgPSBudWxsXG5cbmV4cG9ydCBmdW5jdGlvbiBkaXNwYXRjaEFwcFJvdXRlckFjdGlvbihhY3Rpb246IFJlZHVjZXJBY3Rpb25zKSB7XG4gIGlmIChkaXNwYXRjaCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdJbnRlcm5hbCBOZXh0LmpzIGVycm9yOiBSb3V0ZXIgYWN0aW9uIGRpc3BhdGNoZWQgYmVmb3JlIGluaXRpYWxpemF0aW9uLidcbiAgICApXG4gIH1cbiAgZGlzcGF0Y2goYWN0aW9uKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlQWN0aW9uUXVldWUoXG4gIGFjdGlvblF1ZXVlOiBBcHBSb3V0ZXJBY3Rpb25RdWV1ZVxuKTogQXBwUm91dGVyU3RhdGUge1xuICBjb25zdCBbc3RhdGUsIHNldFN0YXRlXSA9IFJlYWN0LnVzZVN0YXRlPFJlZHVjZXJTdGF0ZT4oYWN0aW9uUXVldWUuc3RhdGUpXG5cbiAgLy8gQmVjYXVzZSBvZiBhIGtub3duIGlzc3VlIHRoYXQgcmVxdWlyZXMgdG8gZGVjb2RlIEZsaWdodCBzdHJlYW1zIGluc2lkZSB0aGVcbiAgLy8gcmVuZGVyIHBoYXNlLCB3ZSBoYXZlIHRvIGJlIGEgYml0IGNsZXZlciBhbmQgYXNzaWduIHRoZSBkaXNwYXRjaCBtZXRob2QgdG9cbiAgLy8gYSBtb2R1bGUtbGV2ZWwgdmFyaWFibGUgdXBvbiBpbml0aWFsaXphdGlvbi4gVGhlIHVzZVN0YXRlIGhvb2sgaW4gdGhpc1xuICAvLyBtb2R1bGUgb25seSBleGlzdHMgdG8gc3luY2hyb25pemUgc3RhdGUgdGhhdCBsaXZlcyBvdXRzaWRlIG9mIFJlYWN0LlxuICAvLyBJZGVhbGx5LCB3aGF0IHdlJ2QgZG8gaW5zdGVhZCBpcyBwYXNzIHRoZSBzdGF0ZSBhcyBhIHByb3AgdG8gcm9vdC5yZW5kZXI7XG4gIC8vIHRoaXMgaXMgY29uY2VwdHVhbGx5IGhvdyB3ZSdyZSBtb2RlbGluZyB0aGUgYXBwIHJvdXRlciBzdGF0ZSwgZGVzcGl0ZSB0aGVcbiAgLy8gd2VpcmQgaW1wbGVtZW50YXRpb24gZGV0YWlscy5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25zdCB7IHVzZUFwcERldlJlbmRlcmluZ0luZGljYXRvciB9ID1cbiAgICAgIHJlcXVpcmUoJy4uLy4uL25leHQtZGV2dG9vbHMvdXNlcnNwYWNlL3VzZS1hcHAtZGV2LXJlbmRlcmluZy1pbmRpY2F0b3InKSBhcyB0eXBlb2YgaW1wb3J0KCcuLi8uLi9uZXh0LWRldnRvb2xzL3VzZXJzcGFjZS91c2UtYXBwLWRldi1yZW5kZXJpbmctaW5kaWNhdG9yJylcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICBjb25zdCBhcHBEZXZSZW5kZXJpbmdJbmRpY2F0b3IgPSB1c2VBcHBEZXZSZW5kZXJpbmdJbmRpY2F0b3IoKVxuXG4gICAgZGlzcGF0Y2ggPSAoYWN0aW9uOiBSZWR1Y2VyQWN0aW9ucykgPT4ge1xuICAgICAgYXBwRGV2UmVuZGVyaW5nSW5kaWNhdG9yKCgpID0+IHtcbiAgICAgICAgYWN0aW9uUXVldWUuZGlzcGF0Y2goYWN0aW9uLCBzZXRTdGF0ZSlcbiAgICAgIH0pXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRpc3BhdGNoID0gKGFjdGlvbjogUmVkdWNlckFjdGlvbnMpID0+XG4gICAgICBhY3Rpb25RdWV1ZS5kaXNwYXRjaChhY3Rpb24sIHNldFN0YXRlKVxuICB9XG5cbiAgcmV0dXJuIGlzVGhlbmFibGUoc3RhdGUpID8gdXNlKHN0YXRlKSA6IHN0YXRlXG59XG4iXSwibmFtZXMiOlsiZGlzcGF0Y2hBcHBSb3V0ZXJBY3Rpb24iLCJ1c2VBY3Rpb25RdWV1ZSIsImRpc3BhdGNoIiwiYWN0aW9uIiwiRXJyb3IiLCJhY3Rpb25RdWV1ZSIsInN0YXRlIiwic2V0U3RhdGUiLCJSZWFjdCIsInVzZVN0YXRlIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwidXNlQXBwRGV2UmVuZGVyaW5nSW5kaWNhdG9yIiwicmVxdWlyZSIsImFwcERldlJlbmRlcmluZ0luZGljYXRvciIsImlzVGhlbmFibGUiLCJ1c2UiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0lBZWdCQSx1QkFBdUIsRUFBQTtlQUF2QkE7O0lBU0FDLGNBQWMsRUFBQTtlQUFkQTs7OztpRUF2Qlc7NEJBQ0E7QUFRM0IsNkVBQTZFO0FBQzdFLCtFQUErRTtBQUMvRSxjQUFjO0FBQ2QsSUFBSUMsV0FBNEM7QUFFekMsU0FBU0Ysd0JBQXdCRyxNQUFzQjtJQUM1RCxJQUFJRCxhQUFhLE1BQU07UUFDckIsTUFBTSxPQUFBLGNBRUwsQ0FGSyxJQUFJRSxNQUNSLDRFQURJLHFCQUFBO21CQUFBO3dCQUFBOzBCQUFBO1FBRU47SUFDRjtJQUNBRixTQUFTQztBQUNYO0FBRU8sU0FBU0YsZUFDZEksV0FBaUM7SUFFakMsTUFBTSxDQUFDQyxPQUFPQyxTQUFTLEdBQUdDLE9BQUFBLE9BQUssQ0FBQ0MsUUFBUSxDQUFlSixZQUFZQyxLQUFLO0lBRXhFLDZFQUE2RTtJQUM3RSw2RUFBNkU7SUFDN0UseUVBQXlFO0lBQ3pFLHVFQUF1RTtJQUN2RSw0RUFBNEU7SUFDNUUsNEVBQTRFO0lBQzVFLGdDQUFnQztJQUNoQyxJQUFJSSxRQUFRQyxHQUFHLENBQUNDLFFBQVEsS0FBSyxXQUFjO1FBQ3pDLE1BQU0sRUFBRUMsMkJBQTJCLEVBQUUsR0FDbkNDLFFBQVE7UUFDVixzREFBc0Q7UUFDdEQsTUFBTUMsMkJBQTJCRjtRQUVqQ1gsV0FBVyxDQUFDQztZQUNWWSx5QkFBeUI7Z0JBQ3ZCVixZQUFZSCxRQUFRLENBQUNDLFFBQVFJO1lBQy9CO1FBQ0Y7SUFDRixPQUFPOztJQUtQLE9BQU9TLENBQUFBLEdBQUFBLFlBQUFBLFVBQVUsRUFBQ1YsU0FBU1csQ0FBQUEsR0FBQUEsT0FBQUEsR0FBRyxFQUFDWCxTQUFTQTtBQUMxQyIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAyODAwLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2NsaWVudC9hcHAtY2FsbC1zZXJ2ZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3RhcnRUcmFuc2l0aW9uIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBBQ1RJT05fU0VSVkVSX0FDVElPTiB9IGZyb20gJy4vY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yb3V0ZXItcmVkdWNlci10eXBlcydcbmltcG9ydCB7IGRpc3BhdGNoQXBwUm91dGVyQWN0aW9uIH0gZnJvbSAnLi9jb21wb25lbnRzL3VzZS1hY3Rpb24tcXVldWUnXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjYWxsU2VydmVyKGFjdGlvbklkOiBzdHJpbmcsIGFjdGlvbkFyZ3M6IGFueVtdKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgIGRpc3BhdGNoQXBwUm91dGVyQWN0aW9uKHtcbiAgICAgICAgdHlwZTogQUNUSU9OX1NFUlZFUl9BQ1RJT04sXG4gICAgICAgIGFjdGlvbklkLFxuICAgICAgICBhY3Rpb25BcmdzLFxuICAgICAgICByZXNvbHZlLFxuICAgICAgICByZWplY3QsXG4gICAgICB9KVxuICAgIH0pXG4gIH0pXG59XG4iXSwibmFtZXMiOlsiY2FsbFNlcnZlciIsImFjdGlvbklkIiwiYWN0aW9uQXJncyIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0Iiwic3RhcnRUcmFuc2l0aW9uIiwiZGlzcGF0Y2hBcHBSb3V0ZXJBY3Rpb24iLCJ0eXBlIiwiQUNUSU9OX1NFUlZFUl9BQ1RJT04iXSwibWFwcGluZ3MiOiI7OzsrQkFJc0JBLGNBQUFBOzs7ZUFBQUE7Ozt1QkFKVTtvQ0FDSztnQ0FDRztBQUVqQyxlQUFlQSxXQUFXQyxRQUFnQixFQUFFQyxVQUFpQjtJQUNsRSxPQUFPLElBQUlDLFFBQVEsQ0FBQ0MsU0FBU0M7UUFDM0JDLENBQUFBLEdBQUFBLE9BQUFBLGVBQWUsRUFBQztZQUNkQyxDQUFBQSxHQUFBQSxnQkFBQUEsdUJBQXVCLEVBQUM7Z0JBQ3RCQyxNQUFNQyxvQkFBQUEsb0JBQW9CO2dCQUMxQlI7Z0JBQ0FDO2dCQUNBRTtnQkFDQUM7WUFDRjtRQUNGO0lBQ0Y7QUFDRiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAyODM4LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2NsaWVudC9hcHAtZmluZC1zb3VyY2UtbWFwLXVybC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBiYXNlUGF0aCA9IHByb2Nlc3MuZW52Ll9fTkVYVF9ST1VURVJfQkFTRVBBVEggfHwgJydcbmNvbnN0IHBhdGhuYW1lID0gYCR7YmFzZVBhdGh9L19fbmV4dGpzX3NvdXJjZS1tYXBgXG5cbmV4cG9ydCBjb25zdCBmaW5kU291cmNlTWFwVVJMID1cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCdcbiAgICA/IGZ1bmN0aW9uIGZpbmRTb3VyY2VNYXBVUkwoZmlsZW5hbWU6IHN0cmluZyk6IHN0cmluZyB8IG51bGwge1xuICAgICAgICBpZiAoZmlsZW5hbWUgPT09ICcnKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBmaWxlbmFtZS5zdGFydHNXaXRoKGRvY3VtZW50LmxvY2F0aW9uLm9yaWdpbikgJiZcbiAgICAgICAgICBmaWxlbmFtZS5pbmNsdWRlcygnL19uZXh0L3N0YXRpYycpXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgYSByZXF1ZXN0IGZvciBhIGNsaWVudCBjaHVuay4gVGhpcyBjYW4gb25seSBoYXBwZW4gd2hlblxuICAgICAgICAgIC8vIHVzaW5nIFR1cmJvcGFjay4gSW4gdGhpcyBjYXNlLCBzaW5jZSB3ZSBjb250cm9sIGhvdyB0aG9zZSBzb3VyY2VcbiAgICAgICAgICAvLyBtYXBzIGFyZSBnZW5lcmF0ZWQsIHdlIGNhbiBzYWZlbHkgYXNzdW1lIHRoYXQgdGhlIHNvdXJjZU1hcHBpbmdVUkxcbiAgICAgICAgICAvLyBpcyByZWxhdGl2ZSB0byB0aGUgZmlsZW5hbWUsIHdpdGggYW4gYWRkZWQgYC5tYXBgIGV4dGVuc2lvbi4gVGhlXG4gICAgICAgICAgLy8gYnJvd3NlciBjYW4ganVzdCByZXF1ZXN0IHRoaXMgZmlsZSwgYW5kIGl0IGdldHMgc2VydmVkIHRocm91Z2ggdGhlXG4gICAgICAgICAgLy8gbm9ybWFsIGRldiBzZXJ2ZXIsIHdpdGhvdXQgdGhlIG5lZWQgdG8gcm91dGUgdGhpcyB0aHJvdWdoXG4gICAgICAgICAgLy8gdGhlIGAvX19uZXh0anNfc291cmNlLW1hcGAgZGV2IG1pZGRsZXdhcmUuXG4gICAgICAgICAgcmV0dXJuIGAke2ZpbGVuYW1lfS5tYXBgXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHBhdGhuYW1lLCBkb2N1bWVudC5sb2NhdGlvbi5vcmlnaW4pXG4gICAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdmaWxlbmFtZScsIGZpbGVuYW1lKVxuXG4gICAgICAgIHJldHVybiB1cmwuaHJlZlxuICAgICAgfVxuICAgIDogdW5kZWZpbmVkXG4iXSwibmFtZXMiOlsiZmluZFNvdXJjZU1hcFVSTCIsImJhc2VQYXRoIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9ST1VURVJfQkFTRVBBVEgiLCJwYXRobmFtZSIsIk5PREVfRU5WIiwiZmlsZW5hbWUiLCJzdGFydHNXaXRoIiwiZG9jdW1lbnQiLCJsb2NhdGlvbiIsIm9yaWdpbiIsImluY2x1ZGVzIiwidXJsIiwiVVJMIiwic2VhcmNoUGFyYW1zIiwic2V0IiwiaHJlZiIsInVuZGVmaW5lZCJdLCJtYXBwaW5ncyI6Ijs7OytCQUdhQSxvQkFBQUE7OztlQUFBQTs7O0FBSGIsTUFBTUMsV0FBV0MsUUFBUUMsR0FBRyxDQUFDQyxzQkFBc0IsTUFBSTtBQUN2RCxNQUFNQyxXQUFZLEtBQUVKLFdBQVM7QUFFdEIsTUFBTUQsbUJBQ1hFLFFBQVFDLEdBQUcsQ0FBQ0csUUFBUSxLQUFLLGNBQ3JCLFNBQVNOLGlCQUFpQk8sUUFBZ0I7SUFDeEMsSUFBSUEsYUFBYSxJQUFJO1FBQ25CLE9BQU87SUFDVDtJQUVBLElBQ0VBLFNBQVNDLFVBQVUsQ0FBQ0MsU0FBU0MsUUFBUSxDQUFDQyxNQUFNLEtBQzVDSixTQUFTSyxRQUFRLENBQUMsa0JBQ2xCO1FBQ0Esa0VBQWtFO1FBQ2xFLG1FQUFtRTtRQUNuRSxxRUFBcUU7UUFDckUsbUVBQW1FO1FBQ25FLHFFQUFxRTtRQUNyRSw0REFBNEQ7UUFDNUQsNkNBQTZDO1FBQzdDLE9BQVEsS0FBRUwsV0FBUztJQUNyQjtJQUVBLE1BQU1NLE1BQU0sSUFBSUMsSUFBSVQsVUFBVUksU0FBU0MsUUFBUSxDQUFDQyxNQUFNO0lBQ3RERSxJQUFJRSxZQUFZLENBQUNDLEdBQUcsQ0FBQyxZQUFZVDtJQUVqQyxPQUFPTSxJQUFJSSxJQUFJO0FBQ2pCLElBQ0FDIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDI4ODAsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvY2xpZW50L2ZsaWdodC1kYXRhLWhlbHBlcnMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUge1xuICBDYWNoZU5vZGVTZWVkRGF0YSxcbiAgRmxpZ2h0RGF0YSxcbiAgRmxpZ2h0RGF0YVBhdGgsXG4gIEZsaWdodFJvdXRlclN0YXRlLFxuICBGbGlnaHRTZWdtZW50UGF0aCxcbiAgU2VnbWVudCxcbn0gZnJvbSAnLi4vc2VydmVyL2FwcC1yZW5kZXIvdHlwZXMnXG5pbXBvcnQgdHlwZSB7IEhlYWREYXRhIH0gZnJvbSAnLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgeyBQQUdFX1NFR01FTlRfS0VZIH0gZnJvbSAnLi4vc2hhcmVkL2xpYi9zZWdtZW50J1xuXG5leHBvcnQgdHlwZSBOb3JtYWxpemVkRmxpZ2h0RGF0YSA9IHtcbiAgLyoqXG4gICAqIFRoZSBmdWxsIGBGbGlnaHRTZWdtZW50UGF0aGAgaW5jbHVzaXZlIG9mIHRoZSBmaW5hbCBgU2VnbWVudGBcbiAgICovXG4gIHNlZ21lbnRQYXRoOiBGbGlnaHRTZWdtZW50UGF0aFxuICAvKipcbiAgICogVGhlIGBGbGlnaHRTZWdtZW50UGF0aGAgZXhjbHVzaXZlIG9mIHRoZSBmaW5hbCBgU2VnbWVudGBcbiAgICovXG4gIHBhdGhUb1NlZ21lbnQ6IEZsaWdodFNlZ21lbnRQYXRoXG4gIHNlZ21lbnQ6IFNlZ21lbnRcbiAgdHJlZTogRmxpZ2h0Um91dGVyU3RhdGVcbiAgc2VlZERhdGE6IENhY2hlTm9kZVNlZWREYXRhIHwgbnVsbFxuICBoZWFkOiBIZWFkRGF0YVxuICBpc0hlYWRQYXJ0aWFsOiBib29sZWFuXG4gIGlzUm9vdFJlbmRlcjogYm9vbGVhblxufVxuXG4vLyBUT0RPOiBXZSBzaG91bGQgb25seSBoYXZlIHRvIGV4cG9ydCBgbm9ybWFsaXplRmxpZ2h0RGF0YWAsIGhvd2V2ZXIgYmVjYXVzZSB0aGUgaW5pdGlhbCBmbGlnaHQgZGF0YVxuLy8gdGhhdCBnZXRzIHBhc3NlZCB0byBgY3JlYXRlSW5pdGlhbFJvdXRlclN0YXRlYCBkb2Vzbid0IGNvbmZvcm0gdG8gdGhlIGBGbGlnaHREYXRhUGF0aGAgdHlwZSAoaXQncyBtaXNzaW5nIHRoZSByb290IHNlZ21lbnQpXG4vLyB3ZSdyZSBjdXJyZW50bHkgZXhwb3J0aW5nIGl0IHNvIHdlIGNhbiB1c2UgaXQgZGlyZWN0bHkuIFRoaXMgc2hvdWxkIGJlIGZpeGVkIGFzIHBhcnQgb2YgdGhlIHVuaWZpY2F0aW9uIG9mXG4vLyB0aGUgZGlmZmVyZW50IHdheXMgd2UgZXhwcmVzcyBgRmxpZ2h0U2VnbWVudFBhdGhgLlxuZXhwb3J0IGZ1bmN0aW9uIGdldEZsaWdodERhdGFQYXJ0c0Zyb21QYXRoKFxuICBmbGlnaHREYXRhUGF0aDogRmxpZ2h0RGF0YVBhdGhcbik6IE5vcm1hbGl6ZWRGbGlnaHREYXRhIHtcbiAgLy8gUGljayB0aGUgbGFzdCA0IGl0ZW1zIGZyb20gdGhlIGBGbGlnaHREYXRhUGF0aGAgdG8gZ2V0IHRoZSBbdHJlZSwgc2VlZERhdGEsIHZpZXdwb3J0LCBpc0hlYWRQYXJ0aWFsXS5cbiAgY29uc3QgZmxpZ2h0RGF0YVBhdGhMZW5ndGggPSA0XG4gIC8vIHRyZWUsIHNlZWREYXRhLCBhbmQgaGVhZCBhcmUgKmFsd2F5cyogdGhlIGxhc3QgdGhyZWUgaXRlbXMgaW4gdGhlIGBGbGlnaHREYXRhUGF0aGAuXG4gIGNvbnN0IFt0cmVlLCBzZWVkRGF0YSwgaGVhZCwgaXNIZWFkUGFydGlhbF0gPVxuICAgIGZsaWdodERhdGFQYXRoLnNsaWNlKC1mbGlnaHREYXRhUGF0aExlbmd0aClcbiAgLy8gVGhlIGBGbGlnaHRTZWdtZW50UGF0aGAgaXMgZXZlcnl0aGluZyBleGNlcHQgdGhlIGxhc3QgdGhyZWUgaXRlbXMuIEZvciBhIHJvb3QgcmVuZGVyLCBpdCB3b24ndCBiZSBwcmVzZW50LlxuICBjb25zdCBzZWdtZW50UGF0aCA9IGZsaWdodERhdGFQYXRoLnNsaWNlKDAsIC1mbGlnaHREYXRhUGF0aExlbmd0aClcblxuICByZXR1cm4ge1xuICAgIC8vIFRPRE86IFVuaWZ5IHRoZXNlIHR3byBzZWdtZW50IHBhdGggaGVscGVycy4gV2UgYXJlIGluY29uc2lzdGVudGx5IHB1c2hpbmcgYW4gZW1wdHkgc2VnbWVudCAoXCJcIilcbiAgICAvLyB0byB0aGUgc3RhcnQgb2YgdGhlIHNlZ21lbnQgcGF0aCBpbiBzb21lIHBsYWNlcyB3aGljaCBtYWtlcyBpdCBoYXJkIHRvIHVzZSBzb2xlbHkgdGhlIHNlZ21lbnQgcGF0aC5cbiAgICAvLyBMb29rIGZvciBcIi8vIFRPRE8tQVBQOiByZW1vdmUgJydcIiBpbiB0aGUgY29kZWJhc2UuXG4gICAgcGF0aFRvU2VnbWVudDogc2VnbWVudFBhdGguc2xpY2UoMCwgLTEpLFxuICAgIHNlZ21lbnRQYXRoLFxuICAgIC8vIGlmIHRoZSBgRmxpZ2h0RGF0YVBhdGhgIGNvcnJlc3BvbmRzIHdpdGggdGhlIHJvb3QsIHRoZXJlJ2xsIGJlIG5vIHNlZ21lbnQgcGF0aCxcbiAgICAvLyBpbiB3aGljaCBjYXNlIHdlIGRlZmF1bHQgdG8gJycuXG4gICAgc2VnbWVudDogc2VnbWVudFBhdGhbc2VnbWVudFBhdGgubGVuZ3RoIC0gMV0gPz8gJycsXG4gICAgdHJlZSxcbiAgICBzZWVkRGF0YSxcbiAgICBoZWFkLFxuICAgIGlzSGVhZFBhcnRpYWwsXG4gICAgaXNSb290UmVuZGVyOiBmbGlnaHREYXRhUGF0aC5sZW5ndGggPT09IGZsaWdodERhdGFQYXRoTGVuZ3RoLFxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXROZXh0RmxpZ2h0U2VnbWVudFBhdGgoXG4gIGZsaWdodFNlZ21lbnRQYXRoOiBGbGlnaHRTZWdtZW50UGF0aFxuKTogRmxpZ2h0U2VnbWVudFBhdGgge1xuICAvLyBTaW5jZSBgRmxpZ2h0U2VnbWVudFBhdGhgIGlzIGEgcmVwZWF0ZWQgdHVwbGUgb2YgYFNlZ21lbnRgIGFuZCBgUGFyYWxsZWxSb3V0ZUtleWAsIHdlIHNsaWNlIG9mZiB0d28gaXRlbXNcbiAgLy8gdG8gZ2V0IHRoZSBuZXh0IHNlZ21lbnQgcGF0aC5cbiAgcmV0dXJuIGZsaWdodFNlZ21lbnRQYXRoLnNsaWNlKDIpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVGbGlnaHREYXRhKFxuICBmbGlnaHREYXRhOiBGbGlnaHREYXRhXG4pOiBOb3JtYWxpemVkRmxpZ2h0RGF0YVtdIHwgc3RyaW5nIHtcbiAgLy8gRmxpZ2h0RGF0YSBjYW4gYmUgYSBzdHJpbmcgd2hlbiB0aGUgc2VydmVyIGRpZG4ndCByZXNwb25kIHdpdGggYSBwcm9wZXIgZmxpZ2h0IHJlc3BvbnNlLFxuICAvLyBvciB3aGVuIGEgcmVkaXJlY3QgaGFwcGVucywgdG8gc2lnbmFsIHRvIHRoZSBjbGllbnQgdGhhdCBpdCBuZWVkcyB0byBwZXJmb3JtIGFuIE1QQSBuYXZpZ2F0aW9uLlxuICBpZiAodHlwZW9mIGZsaWdodERhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZsaWdodERhdGFcbiAgfVxuXG4gIHJldHVybiBmbGlnaHREYXRhLm1hcChnZXRGbGlnaHREYXRhUGFydHNGcm9tUGF0aClcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gcHJlcGFyZSB0aGUgZmxpZ2h0IHJvdXRlciBzdGF0ZSBmb3IgdGhlIHJlcXVlc3QuXG4gKiBJdCByZW1vdmVzIG1hcmtlcnMgdGhhdCBhcmUgbm90IG5lZWRlZCBieSB0aGUgc2VydmVyLCBhbmQgYXJlIHB1cmVseSB1c2VkXG4gKiBmb3Igc3Rhc2hpbmcgc3RhdGUgb24gdGhlIGNsaWVudC5cbiAqIEBwYXJhbSBmbGlnaHRSb3V0ZXJTdGF0ZSAtIFRoZSBmbGlnaHQgcm91dGVyIHN0YXRlIHRvIHByZXBhcmUuXG4gKiBAcGFyYW0gaXNIbXJSZWZyZXNoIC0gV2hldGhlciB0aGlzIGlzIGFuIEhNUiByZWZyZXNoIHJlcXVlc3QuXG4gKiBAcmV0dXJucyBUaGUgcHJlcGFyZWQgZmxpZ2h0IHJvdXRlciBzdGF0ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByZXBhcmVGbGlnaHRSb3V0ZXJTdGF0ZUZvclJlcXVlc3QoXG4gIGZsaWdodFJvdXRlclN0YXRlOiBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgaXNIbXJSZWZyZXNoPzogYm9vbGVhblxuKTogc3RyaW5nIHtcbiAgLy8gSE1SIHJlcXVlc3RzIG5lZWQgdGhlIGNvbXBsZXRlLCB1bm1vZGlmaWVkIHN0YXRlIGZvciBwcm9wZXIgZnVuY3Rpb25hbGl0eVxuICBpZiAoaXNIbXJSZWZyZXNoKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShmbGlnaHRSb3V0ZXJTdGF0ZSkpXG4gIH1cblxuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KFxuICAgIEpTT04uc3RyaW5naWZ5KHN0cmlwQ2xpZW50T25seURhdGFGcm9tRmxpZ2h0Um91dGVyU3RhdGUoZmxpZ2h0Um91dGVyU3RhdGUpKVxuICApXG59XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgc3RyaXBzIGNsaWVudC1vbmx5IGRhdGEgZnJvbSBGbGlnaHRSb3V0ZXJTdGF0ZSB3aGlsZSBwcmVzZXJ2aW5nXG4gKiBzZXJ2ZXItbmVlZGVkIGluZm9ybWF0aW9uIGZvciBwcm9wZXIgcmVuZGVyaW5nIGRlY2lzaW9ucy5cbiAqL1xuZnVuY3Rpb24gc3RyaXBDbGllbnRPbmx5RGF0YUZyb21GbGlnaHRSb3V0ZXJTdGF0ZShcbiAgZmxpZ2h0Um91dGVyU3RhdGU6IEZsaWdodFJvdXRlclN0YXRlXG4pOiBGbGlnaHRSb3V0ZXJTdGF0ZSB7XG4gIGNvbnN0IFtcbiAgICBzZWdtZW50LFxuICAgIHBhcmFsbGVsUm91dGVzLFxuICAgIF91cmwsIC8vIEludGVudGlvbmFsbHkgdW51c2VkIC0gVVJMcyBhcmUgY2xpZW50LW9ubHlcbiAgICByZWZyZXNoTWFya2VyLFxuICAgIGlzUm9vdExheW91dCxcbiAgICBoYXNMb2FkaW5nQm91bmRhcnksXG4gIF0gPSBmbGlnaHRSb3V0ZXJTdGF0ZVxuXG4gIC8vIF9fUEFHRV9fIHNlZ21lbnRzIGFyZSBhbHdheXMgZmV0Y2hlZCBmcm9tIHRoZSBzZXJ2ZXIsIHNvIHRoZXJlJ3NcbiAgLy8gbm8gbmVlZCB0byBzZW5kIHRoZW0gdXBcbiAgY29uc3QgY2xlYW5lZFNlZ21lbnQgPSBzdHJpcFNlYXJjaFBhcmFtc0Zyb21QYWdlU2VnbWVudChzZWdtZW50KVxuXG4gIC8vIFJlY3Vyc2l2ZWx5IHByb2Nlc3MgcGFyYWxsZWwgcm91dGVzXG4gIGNvbnN0IGNsZWFuZWRQYXJhbGxlbFJvdXRlczogeyBba2V5OiBzdHJpbmddOiBGbGlnaHRSb3V0ZXJTdGF0ZSB9ID0ge31cbiAgZm9yIChjb25zdCBba2V5LCBjaGlsZFN0YXRlXSBvZiBPYmplY3QuZW50cmllcyhwYXJhbGxlbFJvdXRlcykpIHtcbiAgICBjbGVhbmVkUGFyYWxsZWxSb3V0ZXNba2V5XSA9XG4gICAgICBzdHJpcENsaWVudE9ubHlEYXRhRnJvbUZsaWdodFJvdXRlclN0YXRlKGNoaWxkU3RhdGUpXG4gIH1cblxuICBjb25zdCByZXN1bHQ6IEZsaWdodFJvdXRlclN0YXRlID0gW1xuICAgIGNsZWFuZWRTZWdtZW50LFxuICAgIGNsZWFuZWRQYXJhbGxlbFJvdXRlcyxcbiAgICBudWxsLCAvLyBVUkxzIG9taXR0ZWQgLSBzZXJ2ZXIgcmVjb25zdHJ1Y3RzIHBhdGhzIGZyb20gc2VnbWVudHNcbiAgICBzaG91bGRQcmVzZXJ2ZVJlZnJlc2hNYXJrZXIocmVmcmVzaE1hcmtlcikgPyByZWZyZXNoTWFya2VyIDogbnVsbCxcbiAgXVxuXG4gIC8vIEFwcGVuZCBvcHRpb25hbCBmaWVsZHMgaWYgcHJlc2VudFxuICBpZiAoaXNSb290TGF5b3V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXN1bHRbNF0gPSBpc1Jvb3RMYXlvdXRcbiAgfVxuICBpZiAoaGFzTG9hZGluZ0JvdW5kYXJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXN1bHRbNV0gPSBoYXNMb2FkaW5nQm91bmRhcnlcbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuLyoqXG4gKiBTdHJpcHMgc2VhcmNoIHBhcmFtZXRlcnMgZnJvbSBfX1BBR0VfXyBzZWdtZW50cyB0byBwcmV2ZW50IHNlbnNpdGl2ZVxuICogY2xpZW50LXNpZGUgZGF0YSBmcm9tIGJlaW5nIHNlbnQgdG8gdGhlIHNlcnZlci5cbiAqL1xuZnVuY3Rpb24gc3RyaXBTZWFyY2hQYXJhbXNGcm9tUGFnZVNlZ21lbnQoc2VnbWVudDogU2VnbWVudCk6IFNlZ21lbnQge1xuICBpZiAoXG4gICAgdHlwZW9mIHNlZ21lbnQgPT09ICdzdHJpbmcnICYmXG4gICAgc2VnbWVudC5zdGFydHNXaXRoKFBBR0VfU0VHTUVOVF9LRVkgKyAnPycpXG4gICkge1xuICAgIHJldHVybiBQQUdFX1NFR01FTlRfS0VZXG4gIH1cbiAgcmV0dXJuIHNlZ21lbnRcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHJlZnJlc2ggbWFya2VyIHNob3VsZCBiZSBzZW50IHRvIHRoZSBzZXJ2ZXJcbiAqIENsaWVudC1vbmx5IG1hcmtlcnMgbGlrZSAncmVmcmVzaCcgYXJlIHN0cmlwcGVkLCB3aGlsZSBzZXJ2ZXItbmVlZGVkIG1hcmtlcnNcbiAqIGxpa2UgJ3JlZmV0Y2gnIGFuZCAnaW5zaWRlLXNoYXJlZC1sYXlvdXQnIGFyZSBwcmVzZXJ2ZWQuXG4gKi9cbmZ1bmN0aW9uIHNob3VsZFByZXNlcnZlUmVmcmVzaE1hcmtlcihcbiAgcmVmcmVzaE1hcmtlcjogRmxpZ2h0Um91dGVyU3RhdGVbM11cbik6IGJvb2xlYW4ge1xuICByZXR1cm4gQm9vbGVhbihyZWZyZXNoTWFya2VyICYmIHJlZnJlc2hNYXJrZXIgIT09ICdyZWZyZXNoJylcbn1cbiJdLCJuYW1lcyI6WyJnZXRGbGlnaHREYXRhUGFydHNGcm9tUGF0aCIsImdldE5leHRGbGlnaHRTZWdtZW50UGF0aCIsIm5vcm1hbGl6ZUZsaWdodERhdGEiLCJwcmVwYXJlRmxpZ2h0Um91dGVyU3RhdGVGb3JSZXF1ZXN0IiwiZmxpZ2h0RGF0YVBhdGgiLCJmbGlnaHREYXRhUGF0aExlbmd0aCIsInRyZWUiLCJzZWVkRGF0YSIsImhlYWQiLCJpc0hlYWRQYXJ0aWFsIiwic2xpY2UiLCJzZWdtZW50UGF0aCIsInBhdGhUb1NlZ21lbnQiLCJzZWdtZW50IiwibGVuZ3RoIiwiaXNSb290UmVuZGVyIiwiZmxpZ2h0U2VnbWVudFBhdGgiLCJmbGlnaHREYXRhIiwibWFwIiwiZmxpZ2h0Um91dGVyU3RhdGUiLCJpc0htclJlZnJlc2giLCJlbmNvZGVVUklDb21wb25lbnQiLCJKU09OIiwic3RyaW5naWZ5Iiwic3RyaXBDbGllbnRPbmx5RGF0YUZyb21GbGlnaHRSb3V0ZXJTdGF0ZSIsInBhcmFsbGVsUm91dGVzIiwiX3VybCIsInJlZnJlc2hNYXJrZXIiLCJpc1Jvb3RMYXlvdXQiLCJoYXNMb2FkaW5nQm91bmRhcnkiLCJjbGVhbmVkU2VnbWVudCIsInN0cmlwU2VhcmNoUGFyYW1zRnJvbVBhZ2VTZWdtZW50IiwiY2xlYW5lZFBhcmFsbGVsUm91dGVzIiwia2V5IiwiY2hpbGRTdGF0ZSIsIk9iamVjdCIsImVudHJpZXMiLCJyZXN1bHQiLCJzaG91bGRQcmVzZXJ2ZVJlZnJlc2hNYXJrZXIiLCJ1bmRlZmluZWQiLCJzdGFydHNXaXRoIiwiUEFHRV9TRUdNRU5UX0tFWSIsIkJvb2xlYW4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7SUFnQ2dCQSwwQkFBMEIsRUFBQTtlQUExQkE7O0lBNEJBQyx3QkFBd0IsRUFBQTtlQUF4QkE7O0lBUUFDLG1CQUFtQixFQUFBO2VBQW5CQTs7SUFvQkFDLGtDQUFrQyxFQUFBO2VBQWxDQTs7O3lCQS9FaUI7QUF1QjFCLFNBQVNILDJCQUNkSSxjQUE4QjtJQUU5Qix3R0FBd0c7SUFDeEcsTUFBTUMsdUJBQXVCO0lBQzdCLHNGQUFzRjtJQUN0RixNQUFNLENBQUNDLE1BQU1DLFVBQVVDLE1BQU1DLGNBQWMsR0FDekNMLGVBQWVNLEtBQUssQ0FBQyxDQUFDTDtJQUN4Qiw2R0FBNkc7SUFDN0csTUFBTU0sY0FBY1AsZUFBZU0sS0FBSyxDQUFDLEdBQUcsQ0FBQ0w7UUFVbENNO0lBUlgsT0FBTztRQUNMLGtHQUFrRztRQUNsRyxzR0FBc0c7UUFDdEcscURBQXFEO1FBQ3JEQyxlQUFlRCxZQUFZRCxLQUFLLENBQUMsR0FBRyxDQUFDO1FBQ3JDQztRQUNBLGtGQUFrRjtRQUNsRixrQ0FBa0M7UUFDbENFLFNBQVNGLENBQUFBLGdCQUFBQSxXQUFXLENBQUNBLFlBQVlHLE1BQU0sR0FBRyxFQUFFLEtBQUEsT0FBbkNILGdCQUF1QztRQUNoREw7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQU0sY0FBY1gsZUFBZVUsTUFBTSxLQUFLVDtJQUMxQztBQUNGO0FBRU8sU0FBU0oseUJBQ2RlLGlCQUFvQztJQUVwQyw0R0FBNEc7SUFDNUcsZ0NBQWdDO0lBQ2hDLE9BQU9BLGtCQUFrQk4sS0FBSyxDQUFDO0FBQ2pDO0FBRU8sU0FBU1Isb0JBQ2RlLFVBQXNCO0lBRXRCLDJGQUEyRjtJQUMzRixrR0FBa0c7SUFDbEcsSUFBSSxPQUFPQSxlQUFlLFVBQVU7UUFDbEMsT0FBT0E7SUFDVDtJQUVBLE9BQU9BLFdBQVdDLEdBQUcsQ0FBQ2xCO0FBQ3hCO0FBVU8sU0FBU0csbUNBQ2RnQixpQkFBb0MsRUFDcENDLFlBQXNCO0lBRXRCLDRFQUE0RTtJQUM1RSxJQUFJQSxjQUFjO1FBQ2hCLE9BQU9DLG1CQUFtQkMsS0FBS0MsU0FBUyxDQUFDSjtJQUMzQztJQUVBLE9BQU9FLG1CQUNMQyxLQUFLQyxTQUFTLENBQUNDLHlDQUF5Q0w7QUFFNUQ7QUFFQTs7O0NBR0MsR0FDRCxTQUFTSyx5Q0FDUEwsaUJBQW9DO0lBRXBDLE1BQU0sQ0FDSk4sU0FDQVksZ0JBQ0FDLE1BQ0FDLGVBQ0FDLGNBQ0FDLG1CQUNELEdBQUdWO0lBRUosbUVBQW1FO0lBQ25FLDBCQUEwQjtJQUMxQixNQUFNVyxpQkFBaUJDLGlDQUFpQ2xCO0lBRXhELHNDQUFzQztJQUN0QyxNQUFNbUIsd0JBQThELENBQUM7SUFDckUsS0FBSyxNQUFNLENBQUNDLEtBQUtDLFdBQVcsSUFBSUMsT0FBT0MsT0FBTyxDQUFDWCxnQkFBaUI7UUFDOURPLHFCQUFxQixDQUFDQyxJQUFJLEdBQ3hCVCx5Q0FBeUNVO0lBQzdDO0lBRUEsTUFBTUcsU0FBNEI7UUFDaENQO1FBQ0FFO1FBQ0E7UUFDQU0sNEJBQTRCWCxpQkFBaUJBLGdCQUFnQjtLQUM5RDtJQUVELG9DQUFvQztJQUNwQyxJQUFJQyxpQkFBaUJXLFdBQVc7UUFDOUJGLE1BQU0sQ0FBQyxFQUFFLEdBQUdUO0lBQ2Q7SUFDQSxJQUFJQyx1QkFBdUJVLFdBQVc7UUFDcENGLE1BQU0sQ0FBQyxFQUFFLEdBQUdSO0lBQ2Q7SUFFQSxPQUFPUTtBQUNUO0FBRUE7OztDQUdDLEdBQ0QsU0FBU04saUNBQWlDbEIsT0FBZ0I7SUFDeEQsSUFDRSxPQUFPQSxZQUFZLFlBQ25CQSxRQUFRMkIsVUFBVSxDQUFDQyxTQUFBQSxnQkFBZ0IsR0FBRyxNQUN0QztRQUNBLE9BQU9BLFNBQUFBLGdCQUFnQjtJQUN6QjtJQUNBLE9BQU81QjtBQUNUO0FBRUE7Ozs7Q0FJQyxHQUNELFNBQVN5Qiw0QkFDUFgsYUFBbUM7SUFFbkMsT0FBT2UsUUFBUWYsaUJBQWlCQSxrQkFBa0I7QUFDcEQiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMzAxMSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvYXBwLWJ1aWxkLWlkLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRoaXMgZ2V0cyBhc3NpZ25lZCBhcyBhIHNpZGUtZWZmZWN0IGR1cmluZyBhcHAgaW5pdGlhbGl6YXRpb24uIEJlY2F1c2UgaXRcbi8vIHJlcHJlc2VudHMgdGhlIGJ1aWxkIHVzZWQgdG8gY3JlYXRlIHRoZSBKUyBidW5kbGUsIGl0IHNob3VsZCBuZXZlciBjaGFuZ2Vcbi8vIGFmdGVyIGJlaW5nIHNldCwgc28gd2Ugc3RvcmUgaXQgaW4gYSBnbG9iYWwgdmFyaWFibGUuXG4vL1xuLy8gV2hlbiBwZXJmb3JtaW5nIFJTQyByZXF1ZXN0cywgaWYgdGhlIGluY29taW5nIGRhdGEgaGFzIGEgZGlmZmVyZW50IGJ1aWxkIElELFxuLy8gd2UgcGVyZm9ybSBhbiBNUEEgbmF2aWdhdGlvbi9yZWZyZXNoIHRvIGxvYWQgdGhlIHVwZGF0ZWQgYnVpbGQgYW5kIGVuc3VyZVxuLy8gdGhhdCB0aGUgY2xpZW50IGFuZCBzZXJ2ZXIgaW4gc3luYy5cblxuLy8gU3RhcnRzIGFzIGFuIGVtcHR5IHN0cmluZy4gSW4gcHJhY3RpY2UsIGJlY2F1c2Ugc2V0QXBwQnVpbGRJZCBpcyBjYWxsZWRcbi8vIGR1cmluZyBpbml0aWFsaXphdGlvbiBiZWZvcmUgaHlkcmF0aW9uIHN0YXJ0cywgdGhpcyB3aWxsIGFsd2F5cyBnZXRcbi8vIHJlYXNzaWduZWQgdG8gdGhlIGFjdHVhbCBidWlsZCBJRCBiZWZvcmUgaXQncyBldmVyIG5lZWRlZCBieSBhIG5hdmlnYXRpb24uXG4vLyBJZiBmb3Igc29tZSByZWFzb25zIGl0IGRpZG4ndCwgZHVlIHRvIGEgYnVnIG9yIHJhY2UgY29uZGl0aW9uLCB0aGVuIG9uXG4vLyBuYXZpZ2F0aW9uIHRoZSBidWlsZCBjb21wYXJpc2lvbiB3b3VsZCBmYWlsIGFuZCB0cmlnZ2VyIGFuIE1QQSBuYXZpZ2F0aW9uLlxubGV0IGdsb2JhbEJ1aWxkSWQ6IHN0cmluZyA9ICcnXG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRBcHBCdWlsZElkKGJ1aWxkSWQ6IHN0cmluZykge1xuICBnbG9iYWxCdWlsZElkID0gYnVpbGRJZFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXBwQnVpbGRJZCgpOiBzdHJpbmcge1xuICByZXR1cm4gZ2xvYmFsQnVpbGRJZFxufVxuIl0sIm5hbWVzIjpbImdldEFwcEJ1aWxkSWQiLCJzZXRBcHBCdWlsZElkIiwiZ2xvYmFsQnVpbGRJZCIsImJ1aWxkSWQiXSwibWFwcGluZ3MiOiJBQUFBLDRFQUE0RTtBQUM1RSw0RUFBNEU7QUFDNUUsd0RBQXdEO0FBQ3hELEVBQUU7QUFDRiwrRUFBK0U7QUFDL0UsNEVBQTRFO0FBQzVFLHNDQUFzQztBQUV0QywwRUFBMEU7QUFDMUUsc0VBQXNFO0FBQ3RFLDZFQUE2RTtBQUM3RSx5RUFBeUU7QUFDekUsNkVBQTZFOzs7Ozs7Ozs7Ozs7Ozs7SUFPN0RBLGFBQWEsRUFBQTtlQUFiQTs7SUFKQUMsYUFBYSxFQUFBO2VBQWJBOzs7QUFGaEIsSUFBSUMsZ0JBQXdCO0FBRXJCLFNBQVNELGNBQWNFLE9BQWU7SUFDM0NELGdCQUFnQkM7QUFDbEI7QUFFTyxTQUFTSDtJQUNkLE9BQU9FO0FBQ1QiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMzA2NCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9zaGFyZWQvbGliL2hhc2gudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gaHR0cDovL3d3dy5jc2UueW9ya3UuY2Evfm96L2hhc2guaHRtbFxuLy8gTW9yZSBzcGVjaWZpY2FsbHksIDMyLWJpdCBoYXNoIHZpYSBkamJ4b3Jcbi8vIChyZWY6IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2VwbGF3bGVzcy81MjgxM2IxZDhhZDlhZjUxMGQ4NT9wZXJtYWxpbmtfY29tbWVudF9pZD0zMzY3NzY1I2dpc3Rjb21tZW50LTMzNjc3NjUpXG4vLyBUaGlzIGlzIGR1ZSB0byBudW1iZXIgdHlwZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIHJ1c3QgZm9yIHR1cmJvcGFjayB0byBqcyBudW1iZXIgdHlwZXMsXG4vLyB3aGVyZSBydXN0IGRvZXMgbm90IGhhdmUgZWFzeSB3YXkgdG8gcmVwcmVlc250IGpzJ3MgNTMtYml0IGZsb2F0IG51bWJlciB0eXBlIGZvciB0aGUgbWF0Y2hpbmdcbi8vIG92ZXJmbG93IGJlaGF2aW9yLiBUaGlzIGlzIG1vcmUgYGNvcnJlY3RgIGluIHRlcm1zIG9mIGhhdmluZyBjYW5vbmljYWwgaGFzaCBhY3Jvc3MgZGlmZmVyZW50IHJ1bnRpbWUgLyBpbXBsZW1lbnRhdGlvblxuLy8gYXMgY2FuIGdhdXJhbnRlZSBkZXRlcm1pbnN0aWMgb3V0cHV0IGZyb20gMzJiaXQgaGFzaC5cbmV4cG9ydCBmdW5jdGlvbiBkamIySGFzaChzdHI6IHN0cmluZykge1xuICBsZXQgaGFzaCA9IDUzODFcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGFyID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoYXNoID0gKChoYXNoIDw8IDUpICsgaGFzaCArIGNoYXIpICYgMHhmZmZmZmZmZlxuICB9XG4gIHJldHVybiBoYXNoID4+PiAwXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoZXhIYXNoKHN0cjogc3RyaW5nKSB7XG4gIHJldHVybiBkamIySGFzaChzdHIpLnRvU3RyaW5nKDM2KS5zbGljZSgwLCA1KVxufVxuIl0sIm5hbWVzIjpbImRqYjJIYXNoIiwiaGV4SGFzaCIsInN0ciIsImhhc2giLCJpIiwibGVuZ3RoIiwiY2hhciIsImNoYXJDb2RlQXQiLCJ0b1N0cmluZyIsInNsaWNlIl0sIm1hcHBpbmdzIjoiQUFBQSx3Q0FBd0M7QUFDeEMsNENBQTRDO0FBQzVDLGlIQUFpSDtBQUNqSCx3RkFBd0Y7QUFDeEYsZ0dBQWdHO0FBQ2hHLHdIQUF3SDtBQUN4SCx3REFBd0Q7Ozs7Ozs7Ozs7Ozs7OztJQUN4Q0EsUUFBUSxFQUFBO2VBQVJBOztJQVNBQyxPQUFPLEVBQUE7ZUFBUEE7OztBQVRULFNBQVNELFNBQVNFLEdBQVc7SUFDbEMsSUFBSUMsT0FBTztJQUNYLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJRixJQUFJRyxNQUFNLEVBQUVELElBQUs7UUFDbkMsTUFBTUUsT0FBT0osSUFBSUssVUFBVSxDQUFDSDtRQUM1QkQsT0FBU0EsQ0FBQUEsUUFBUSxDQUFBLElBQUtBLE9BQU9HLE9BQVE7SUFDdkM7SUFDQSxPQUFPSCxTQUFTO0FBQ2xCO0FBRU8sU0FBU0YsUUFBUUMsR0FBVztJQUNqQyxPQUFPRixTQUFTRSxLQUFLTSxRQUFRLENBQUMsSUFBSUMsS0FBSyxDQUFDLEdBQUc7QUFDN0MiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMzEwOSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9zaGFyZWQvbGliL3JvdXRlci91dGlscy9jYWNoZS1idXN0aW5nLXNlYXJjaC1wYXJhbS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBoZXhIYXNoIH0gZnJvbSAnLi4vLi4vaGFzaCdcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVDYWNoZUJ1c3RpbmdTZWFyY2hQYXJhbShcbiAgcHJlZmV0Y2hIZWFkZXI6IHN0cmluZyB8IHN0cmluZ1tdIHwgdW5kZWZpbmVkLFxuICBzZWdtZW50UHJlZmV0Y2hIZWFkZXI6IHN0cmluZyB8IHN0cmluZ1tdIHwgdW5kZWZpbmVkLFxuICBzdGF0ZVRyZWVIZWFkZXI6IHN0cmluZyB8IHN0cmluZ1tdIHwgdW5kZWZpbmVkLFxuICBuZXh0VXJsSGVhZGVyOiBzdHJpbmcgfCBzdHJpbmdbXSB8IHVuZGVmaW5lZFxuKTogc3RyaW5nIHtcbiAgaWYgKFxuICAgIHByZWZldGNoSGVhZGVyID09PSB1bmRlZmluZWQgJiZcbiAgICBzZWdtZW50UHJlZmV0Y2hIZWFkZXIgPT09IHVuZGVmaW5lZCAmJlxuICAgIHN0YXRlVHJlZUhlYWRlciA9PT0gdW5kZWZpbmVkICYmXG4gICAgbmV4dFVybEhlYWRlciA9PT0gdW5kZWZpbmVkXG4gICkge1xuICAgIHJldHVybiAnJ1xuICB9XG4gIHJldHVybiBoZXhIYXNoKFxuICAgIFtcbiAgICAgIHByZWZldGNoSGVhZGVyIHx8ICcwJyxcbiAgICAgIHNlZ21lbnRQcmVmZXRjaEhlYWRlciB8fCAnMCcsXG4gICAgICBzdGF0ZVRyZWVIZWFkZXIgfHwgJzAnLFxuICAgICAgbmV4dFVybEhlYWRlciB8fCAnMCcsXG4gICAgXS5qb2luKCcsJylcbiAgKVxufVxuIl0sIm5hbWVzIjpbImNvbXB1dGVDYWNoZUJ1c3RpbmdTZWFyY2hQYXJhbSIsInByZWZldGNoSGVhZGVyIiwic2VnbWVudFByZWZldGNoSGVhZGVyIiwic3RhdGVUcmVlSGVhZGVyIiwibmV4dFVybEhlYWRlciIsInVuZGVmaW5lZCIsImhleEhhc2giLCJqb2luIl0sIm1hcHBpbmdzIjoiOzs7K0JBRWdCQSxrQ0FBQUE7OztlQUFBQTs7O3NCQUZRO0FBRWpCLFNBQVNBLCtCQUNkQyxjQUE2QyxFQUM3Q0MscUJBQW9ELEVBQ3BEQyxlQUE4QyxFQUM5Q0MsYUFBNEM7SUFFNUMsSUFDRUgsbUJBQW1CSSxhQUNuQkgsMEJBQTBCRyxhQUMxQkYsb0JBQW9CRSxhQUNwQkQsa0JBQWtCQyxXQUNsQjtRQUNBLE9BQU87SUFDVDtJQUNBLE9BQU9DLENBQUFBLEdBQUFBLE1BQUFBLE9BQU8sRUFDWjtRQUNFTCxrQkFBa0I7UUFDbEJDLHlCQUF5QjtRQUN6QkMsbUJBQW1CO1FBQ25CQyxpQkFBaUI7S0FDbEIsQ0FBQ0csSUFBSSxDQUFDO0FBRVgiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMzEzNiwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9zZXQtY2FjaGUtYnVzdGluZy1zZWFyY2gtcGFyYW0udHMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbmltcG9ydCB7IGNvbXB1dGVDYWNoZUJ1c3RpbmdTZWFyY2hQYXJhbSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2NhY2hlLWJ1c3Rpbmctc2VhcmNoLXBhcmFtJ1xuaW1wb3J0IHtcbiAgTkVYVF9ST1VURVJfUFJFRkVUQ0hfSEVBREVSLFxuICBORVhUX1JPVVRFUl9TRUdNRU5UX1BSRUZFVENIX0hFQURFUixcbiAgTkVYVF9ST1VURVJfU1RBVEVfVFJFRV9IRUFERVIsXG4gIE5FWFRfVVJMLFxuICBORVhUX1JTQ19VTklPTl9RVUVSWSxcbn0gZnJvbSAnLi4vYXBwLXJvdXRlci1oZWFkZXJzJ1xuaW1wb3J0IHR5cGUgeyBSZXF1ZXN0SGVhZGVycyB9IGZyb20gJy4vZmV0Y2gtc2VydmVyLXJlc3BvbnNlJ1xuXG4vKipcbiAqIE11dGF0ZXMgdGhlIHByb3ZpZGVkIFVSTCBieSBhZGRpbmcgYSBjYWNoZS1idXN0aW5nIHNlYXJjaCBwYXJhbWV0ZXIgZm9yIENETnMgdGhhdCBkb24ndFxuICogc3VwcG9ydCBjdXN0b20gaGVhZGVycy4gVGhpcyBoZWxwcyBhdm9pZCBjYWNoaW5nIGNvbmZsaWN0cyBieSBtYWtpbmcgZWFjaCByZXF1ZXN0IHVuaXF1ZS5cbiAqXG4gKiBSYXRoZXIgdGhhbiByZWx5aW5nIG9uIHRoZSBWYXJ5IGhlYWRlciB3aGljaCBzb21lIENETnMgaWdub3JlLCB3ZSBhcHBlbmQgYSBzZWFyY2ggcGFyYW1cbiAqIHRvIGNyZWF0ZSBhIHVuaXF1ZSBVUkwgdGhhdCBmb3JjZXMgYSBmcmVzaCByZXF1ZXN0LlxuICpcbiAqIEV4YW1wbGU6XG4gKiBVUkwgYmVmb3JlOiBodHRwczovL2V4YW1wbGUuY29tL3BhdGg/cXVlcnk9MVxuICogVVJMIGFmdGVyOiBodHRwczovL2V4YW1wbGUuY29tL3BhdGg/cXVlcnk9MSZfcnNjPWFiYzEyM1xuICpcbiAqIE5vdGU6IFRoaXMgZnVuY3Rpb24gbXV0YXRlcyB0aGUgaW5wdXQgVVJMIGRpcmVjdGx5IGFuZCBkb2VzIG5vdCByZXR1cm4gYW55dGhpbmcuXG4gKlxuICogVE9ETzogU2luY2Ugd2UgbmVlZCB0byB1c2UgYSBzZWFyY2ggcGFyYW0gYW55d2F5LCB3ZSBjb3VsZCBzaW1wbGlmeSBieSByZW1vdmluZyB0aGUgY3VzdG9tXG4gKiBoZWFkZXJzIGFwcHJvYWNoIGVudGlyZWx5IGFuZCBqdXN0IHVzZSBzZWFyY2ggcGFyYW1zLlxuICovXG5leHBvcnQgY29uc3Qgc2V0Q2FjaGVCdXN0aW5nU2VhcmNoUGFyYW0gPSAoXG4gIHVybDogVVJMLFxuICBoZWFkZXJzOiBSZXF1ZXN0SGVhZGVyc1xuKTogdm9pZCA9PiB7XG4gIGNvbnN0IHVuaXF1ZUNhY2hlS2V5ID0gY29tcHV0ZUNhY2hlQnVzdGluZ1NlYXJjaFBhcmFtKFxuICAgIGhlYWRlcnNbTkVYVF9ST1VURVJfUFJFRkVUQ0hfSEVBREVSXSxcbiAgICBoZWFkZXJzW05FWFRfUk9VVEVSX1NFR01FTlRfUFJFRkVUQ0hfSEVBREVSXSxcbiAgICBoZWFkZXJzW05FWFRfUk9VVEVSX1NUQVRFX1RSRUVfSEVBREVSXSxcbiAgICBoZWFkZXJzW05FWFRfVVJMXVxuICApXG4gIHNldENhY2hlQnVzdGluZ1NlYXJjaFBhcmFtV2l0aEhhc2godXJsLCB1bmlxdWVDYWNoZUtleSlcbn1cblxuLyoqXG4gKiBTZXRzIGEgY2FjaGUtYnVzdGluZyBzZWFyY2ggcGFyYW1ldGVyIG9uIGEgVVJMIHVzaW5nIGEgcHJvdmlkZWQgaGFzaCB2YWx1ZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHBlcmZvcm1zIHRoZSBzYW1lIGxvZ2ljIGFzIGBzZXRDYWNoZUJ1c3RpbmdTZWFyY2hQYXJhbWAgYnV0IGFjY2VwdHNcbiAqIGEgcHJlLWNvbXB1dGVkIGhhc2ggaW5zdGVhZCBvZiBjb21wdXRpbmcgaXQgZnJvbSBoZWFkZXJzLlxuICpcbiAqIEV4YW1wbGU6XG4gKiBVUkwgYmVmb3JlOiBodHRwczovL2V4YW1wbGUuY29tL3BhdGg/cXVlcnk9MVxuICogaGFzaDogXCJhYmMxMjNcIlxuICogVVJMIGFmdGVyOiBodHRwczovL2V4YW1wbGUuY29tL3BhdGg/cXVlcnk9MSZfcnNjPWFiYzEyM1xuICpcbiAqIElmIHRoZSBoYXNoIGlzIG51bGwsIHdlIHdpbGwgc2V0IGBfcnNjYCBzZWFyY2ggcGFyYW0gd2l0aG91dCBhIHZhbHVlLlxuICogTGlrZSB0aGlzOiBodHRwczovL2V4YW1wbGUuY29tL3BhdGg/cXVlcnk9MSZfcnNjXG4gKlxuICogTm90ZTogVGhpcyBmdW5jdGlvbiBtdXRhdGVzIHRoZSBpbnB1dCBVUkwgZGlyZWN0bHkgYW5kIGRvZXMgbm90IHJldHVybiBhbnl0aGluZy5cbiAqL1xuZXhwb3J0IGNvbnN0IHNldENhY2hlQnVzdGluZ1NlYXJjaFBhcmFtV2l0aEhhc2ggPSAoXG4gIHVybDogVVJMLFxuICBoYXNoOiBzdHJpbmdcbik6IHZvaWQgPT4ge1xuICAvKipcbiAgICogTm90ZSB0aGF0IHdlIGludGVudGlvbmFsbHkgZG8gbm90IHVzZSBgdXJsLnNlYXJjaFBhcmFtcy5zZXRgIGhlcmU6XG4gICAqXG4gICAqIGNvbnN0IHVybCA9IG5ldyBVUkwoJ2h0dHBzOi8vZXhhbXBsZS5jb20vc2VhcmNoP3E9Y3VzdG9tJTIwc3BhY2luZycpO1xuICAgKiB1cmwuc2VhcmNoUGFyYW1zLnNldCgnX3JzYycsICdhYmMxMjMnKTtcbiAgICogY29uc29sZS5sb2codXJsLnRvU3RyaW5nKCkpOyAvLyBPdXRwdXRzOiBodHRwczovL2V4YW1wbGUuY29tL3NlYXJjaD9xPWN1c3RvbStzcGFjaW5nJl9yc2M9YWJjMTIzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBeIDwtLS0gdGhpcyBpcyBjYXVzaW5nIGNvbmZ1c2lvblxuICAgKiBUaGlzIGlzIGluIGZhY3QgaW50ZW5kZWQgYmFzZWQgb24gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNpbnRlcmZhY2UtdXJsc2VhcmNocGFyYW1zLCBidXRcbiAgICogd2Ugd2FudCB0byBwcmVzZXJ2ZSB0aGUgJTIwIGFzICUyMCBpZiB0aGF0J3Mgd2hhdCB0aGUgdXNlciBwYXNzZWQgaW4sIGhlbmNlIHRoZSBjdXN0b21cbiAgICogbG9naWMgYmVsb3cuXG4gICAqL1xuICBjb25zdCBleGlzdGluZ1NlYXJjaCA9IHVybC5zZWFyY2hcbiAgY29uc3QgcmF3UXVlcnkgPSBleGlzdGluZ1NlYXJjaC5zdGFydHNXaXRoKCc/JylcbiAgICA/IGV4aXN0aW5nU2VhcmNoLnNsaWNlKDEpXG4gICAgOiBleGlzdGluZ1NlYXJjaFxuXG4gIC8vIEFsd2F5cyByZW1vdmUgYW55IGV4aXN0aW5nIGNhY2hlIGJ1c3RpbmcgcGFyYW0gYW5kIGFkZCBhIGZyZXNoIG9uZSB0byBlbnN1cmVcbiAgLy8gd2UgaGF2ZSB0aGUgY29ycmVjdCB2YWx1ZSBiYXNlZCBvbiBjdXJyZW50IHJlcXVlc3QgaGVhZGVyc1xuICBjb25zdCBwYWlycyA9IHJhd1F1ZXJ5XG4gICAgLnNwbGl0KCcmJylcbiAgICAuZmlsdGVyKChwYWlyKSA9PiBwYWlyICYmICFwYWlyLnN0YXJ0c1dpdGgoYCR7TkVYVF9SU0NfVU5JT05fUVVFUll9PWApKVxuXG4gIGlmIChoYXNoLmxlbmd0aCA+IDApIHtcbiAgICBwYWlycy5wdXNoKGAke05FWFRfUlNDX1VOSU9OX1FVRVJZfT0ke2hhc2h9YClcbiAgfSBlbHNlIHtcbiAgICBwYWlycy5wdXNoKGAke05FWFRfUlNDX1VOSU9OX1FVRVJZfWApXG4gIH1cbiAgdXJsLnNlYXJjaCA9IHBhaXJzLmxlbmd0aCA/IGA/JHtwYWlycy5qb2luKCcmJyl9YCA6ICcnXG59XG4iXSwibmFtZXMiOlsic2V0Q2FjaGVCdXN0aW5nU2VhcmNoUGFyYW0iLCJzZXRDYWNoZUJ1c3RpbmdTZWFyY2hQYXJhbVdpdGhIYXNoIiwidXJsIiwiaGVhZGVycyIsInVuaXF1ZUNhY2hlS2V5IiwiY29tcHV0ZUNhY2hlQnVzdGluZ1NlYXJjaFBhcmFtIiwiTkVYVF9ST1VURVJfUFJFRkVUQ0hfSEVBREVSIiwiTkVYVF9ST1VURVJfU0VHTUVOVF9QUkVGRVRDSF9IRUFERVIiLCJORVhUX1JPVVRFUl9TVEFURV9UUkVFX0hFQURFUiIsIk5FWFRfVVJMIiwiaGFzaCIsImV4aXN0aW5nU2VhcmNoIiwic2VhcmNoIiwicmF3UXVlcnkiLCJzdGFydHNXaXRoIiwic2xpY2UiLCJwYWlycyIsInNwbGl0IiwiZmlsdGVyIiwicGFpciIsIk5FWFRfUlNDX1VOSU9OX1FVRVJZIiwibGVuZ3RoIiwicHVzaCIsImpvaW4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0lBNEJhQSwwQkFBMEIsRUFBQTtlQUExQkE7O0lBNkJBQyxrQ0FBa0MsRUFBQTtlQUFsQ0E7Ozt5Q0F2RGtDO2tDQU94QztBQW1CQSxNQUFNRCw2QkFBNkIsQ0FDeENFLEtBQ0FDO0lBRUEsTUFBTUMsaUJBQWlCQyxDQUFBQSxHQUFBQSx5QkFBQUEsOEJBQThCLEVBQ25ERixPQUFPLENBQUNHLGtCQUFBQSwyQkFBMkIsQ0FBQyxFQUNwQ0gsT0FBTyxDQUFDSSxrQkFBQUEsbUNBQW1DLENBQUMsRUFDNUNKLE9BQU8sQ0FBQ0ssa0JBQUFBLDZCQUE2QixDQUFDLEVBQ3RDTCxPQUFPLENBQUNNLGtCQUFBQSxRQUFRLENBQUM7SUFFbkJSLG1DQUFtQ0MsS0FBS0U7QUFDMUM7QUFrQk8sTUFBTUgscUNBQXFDLENBQ2hEQyxLQUNBUTtJQUVBOzs7Ozs7Ozs7O0dBVUMsR0FDRCxNQUFNQyxpQkFBaUJULElBQUlVLE1BQU07SUFDakMsTUFBTUMsV0FBV0YsZUFBZUcsVUFBVSxDQUFDLE9BQ3ZDSCxlQUFlSSxLQUFLLENBQUMsS0FDckJKO0lBRUosK0VBQStFO0lBQy9FLDZEQUE2RDtJQUM3RCxNQUFNSyxRQUFRSCxTQUNYSSxLQUFLLENBQUMsS0FDTkMsTUFBTSxDQUFDLENBQUNDLE9BQVNBLFFBQVEsQ0FBQ0EsS0FBS0wsVUFBVSxDQUFFLEtBQUVNLGtCQUFBQSxvQkFBb0IsR0FBQztJQUVyRSxJQUFJVixLQUFLVyxNQUFNLEdBQUcsR0FBRztRQUNuQkwsTUFBTU0sSUFBSSxDQUFJRixrQkFBQUEsb0JBQW9CLEdBQUMsTUFBR1Y7SUFDeEMsT0FBTztRQUNMTSxNQUFNTSxJQUFJLENBQUUsS0FBRUYsa0JBQUFBLG9CQUFvQjtJQUNwQztJQUNBbEIsSUFBSVUsTUFBTSxHQUFHSSxNQUFNSyxNQUFNLEdBQUksTUFBR0wsTUFBTU8sSUFBSSxDQUFDLE9BQVM7QUFDdEQiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMzE5OSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9mZXRjaC1zZXJ2ZXItcmVzcG9uc2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbi8vIFRPRE86IEV4cGxpY2l0bHkgaW1wb3J0IGZyb20gY2xpZW50LmJyb3dzZXJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tZXh0cmFuZW91cy1kZXBlbmRlbmNpZXNcbmltcG9ydCB7IGNyZWF0ZUZyb21SZWFkYWJsZVN0cmVhbSBhcyBjcmVhdGVGcm9tUmVhZGFibGVTdHJlYW1Ccm93c2VyIH0gZnJvbSAncmVhY3Qtc2VydmVyLWRvbS13ZWJwYWNrL2NsaWVudCdcblxuaW1wb3J0IHR5cGUge1xuICBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgTmF2aWdhdGlvbkZsaWdodFJlc3BvbnNlLFxufSBmcm9tICcuLi8uLi8uLi9zZXJ2ZXIvYXBwLXJlbmRlci90eXBlcydcblxuaW1wb3J0IHR5cGUgeyBORVhUX1JPVVRFUl9TRUdNRU5UX1BSRUZFVENIX0hFQURFUiB9IGZyb20gJy4uL2FwcC1yb3V0ZXItaGVhZGVycydcbmltcG9ydCB7XG4gIE5FWFRfUk9VVEVSX1BSRUZFVENIX0hFQURFUixcbiAgTkVYVF9ST1VURVJfU1RBVEVfVFJFRV9IRUFERVIsXG4gIE5FWFRfUlNDX1VOSU9OX1FVRVJZLFxuICBORVhUX1VSTCxcbiAgUlNDX0hFQURFUixcbiAgUlNDX0NPTlRFTlRfVFlQRV9IRUFERVIsXG4gIE5FWFRfSE1SX1JFRlJFU0hfSEVBREVSLFxuICBORVhUX0RJRF9QT1NUUE9ORV9IRUFERVIsXG4gIE5FWFRfUk9VVEVSX1NUQUxFX1RJTUVfSEVBREVSLFxufSBmcm9tICcuLi9hcHAtcm91dGVyLWhlYWRlcnMnXG5pbXBvcnQgeyBjYWxsU2VydmVyIH0gZnJvbSAnLi4vLi4vYXBwLWNhbGwtc2VydmVyJ1xuaW1wb3J0IHsgZmluZFNvdXJjZU1hcFVSTCB9IGZyb20gJy4uLy4uL2FwcC1maW5kLXNvdXJjZS1tYXAtdXJsJ1xuaW1wb3J0IHsgUHJlZmV0Y2hLaW5kIH0gZnJvbSAnLi9yb3V0ZXItcmVkdWNlci10eXBlcydcbmltcG9ydCB7XG4gIG5vcm1hbGl6ZUZsaWdodERhdGEsXG4gIHByZXBhcmVGbGlnaHRSb3V0ZXJTdGF0ZUZvclJlcXVlc3QsXG4gIHR5cGUgTm9ybWFsaXplZEZsaWdodERhdGEsXG59IGZyb20gJy4uLy4uL2ZsaWdodC1kYXRhLWhlbHBlcnMnXG5pbXBvcnQgeyBnZXRBcHBCdWlsZElkIH0gZnJvbSAnLi4vLi4vYXBwLWJ1aWxkLWlkJ1xuaW1wb3J0IHsgc2V0Q2FjaGVCdXN0aW5nU2VhcmNoUGFyYW0gfSBmcm9tICcuL3NldC1jYWNoZS1idXN0aW5nLXNlYXJjaC1wYXJhbSdcblxuY29uc3QgY3JlYXRlRnJvbVJlYWRhYmxlU3RyZWFtID1cbiAgY3JlYXRlRnJvbVJlYWRhYmxlU3RyZWFtQnJvd3NlciBhcyAodHlwZW9mIGltcG9ydCgncmVhY3Qtc2VydmVyLWRvbS13ZWJwYWNrL2NsaWVudC5icm93c2VyJykpWydjcmVhdGVGcm9tUmVhZGFibGVTdHJlYW0nXVxuXG5leHBvcnQgaW50ZXJmYWNlIEZldGNoU2VydmVyUmVzcG9uc2VPcHRpb25zIHtcbiAgcmVhZG9ubHkgZmxpZ2h0Um91dGVyU3RhdGU6IEZsaWdodFJvdXRlclN0YXRlXG4gIHJlYWRvbmx5IG5leHRVcmw6IHN0cmluZyB8IG51bGxcbiAgcmVhZG9ubHkgcHJlZmV0Y2hLaW5kPzogUHJlZmV0Y2hLaW5kXG4gIHJlYWRvbmx5IGlzSG1yUmVmcmVzaD86IGJvb2xlYW5cbn1cblxuZXhwb3J0IHR5cGUgRmV0Y2hTZXJ2ZXJSZXNwb25zZVJlc3VsdCA9IHtcbiAgZmxpZ2h0RGF0YTogTm9ybWFsaXplZEZsaWdodERhdGFbXSB8IHN0cmluZ1xuICBjYW5vbmljYWxVcmw6IFVSTCB8IHVuZGVmaW5lZFxuICBjb3VsZEJlSW50ZXJjZXB0ZWQ6IGJvb2xlYW5cbiAgcHJlcmVuZGVyZWQ6IGJvb2xlYW5cbiAgcG9zdHBvbmVkOiBib29sZWFuXG4gIHN0YWxlVGltZTogbnVtYmVyXG59XG5cbmV4cG9ydCB0eXBlIFJlcXVlc3RIZWFkZXJzID0ge1xuICBbUlNDX0hFQURFUl0/OiAnMSdcbiAgW05FWFRfUk9VVEVSX1NUQVRFX1RSRUVfSEVBREVSXT86IHN0cmluZ1xuICBbTkVYVF9VUkxdPzogc3RyaW5nXG4gIFtORVhUX1JPVVRFUl9QUkVGRVRDSF9IRUFERVJdPzogJzEnXG4gIFtORVhUX1JPVVRFUl9TRUdNRU5UX1BSRUZFVENIX0hFQURFUl0/OiBzdHJpbmdcbiAgJ3gtZGVwbG95bWVudC1pZCc/OiBzdHJpbmdcbiAgW05FWFRfSE1SX1JFRlJFU0hfSEVBREVSXT86ICcxJ1xuICAvLyBBIGhlYWRlciB0aGF0IGlzIG9ubHkgYWRkZWQgaW4gdGVzdCBtb2RlIHRvIGFzc2VydCBvbiBmZXRjaCBwcmlvcml0eVxuICAnTmV4dC1UZXN0LUZldGNoLVByaW9yaXR5Jz86IFJlcXVlc3RJbml0Wydwcmlvcml0eSddXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cmxUb1VybFdpdGhvdXRGbGlnaHRNYXJrZXIodXJsOiBzdHJpbmcpOiBVUkwge1xuICBjb25zdCB1cmxXaXRob3V0RmxpZ2h0UGFyYW1ldGVycyA9IG5ldyBVUkwodXJsLCBsb2NhdGlvbi5vcmlnaW4pXG4gIHVybFdpdGhvdXRGbGlnaHRQYXJhbWV0ZXJzLnNlYXJjaFBhcmFtcy5kZWxldGUoTkVYVF9SU0NfVU5JT05fUVVFUlkpXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKFxuICAgICAgcHJvY2Vzcy5lbnYuX19ORVhUX0NPTkZJR19PVVRQVVQgPT09ICdleHBvcnQnICYmXG4gICAgICB1cmxXaXRob3V0RmxpZ2h0UGFyYW1ldGVycy5wYXRobmFtZS5lbmRzV2l0aCgnLnR4dCcpXG4gICAgKSB7XG4gICAgICBjb25zdCB7IHBhdGhuYW1lIH0gPSB1cmxXaXRob3V0RmxpZ2h0UGFyYW1ldGVyc1xuICAgICAgY29uc3QgbGVuZ3RoID0gcGF0aG5hbWUuZW5kc1dpdGgoJy9pbmRleC50eHQnKSA/IDEwIDogNFxuICAgICAgLy8gU2xpY2Ugb2ZmIGAvaW5kZXgudHh0YCBvciBgLnR4dGAgZnJvbSB0aGUgZW5kIG9mIHRoZSBwYXRobmFtZVxuICAgICAgdXJsV2l0aG91dEZsaWdodFBhcmFtZXRlcnMucGF0aG5hbWUgPSBwYXRobmFtZS5zbGljZSgwLCAtbGVuZ3RoKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdXJsV2l0aG91dEZsaWdodFBhcmFtZXRlcnNcbn1cblxuZnVuY3Rpb24gZG9NcGFOYXZpZ2F0aW9uKHVybDogc3RyaW5nKTogRmV0Y2hTZXJ2ZXJSZXNwb25zZVJlc3VsdCB7XG4gIHJldHVybiB7XG4gICAgZmxpZ2h0RGF0YTogdXJsVG9VcmxXaXRob3V0RmxpZ2h0TWFya2VyKHVybCkudG9TdHJpbmcoKSxcbiAgICBjYW5vbmljYWxVcmw6IHVuZGVmaW5lZCxcbiAgICBjb3VsZEJlSW50ZXJjZXB0ZWQ6IGZhbHNlLFxuICAgIHByZXJlbmRlcmVkOiBmYWxzZSxcbiAgICBwb3N0cG9uZWQ6IGZhbHNlLFxuICAgIHN0YWxlVGltZTogLTEsXG4gIH1cbn1cblxubGV0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgLy8gQWJvcnQgYW55IGluLWZsaWdodCByZXF1ZXN0cyB3aGVuIHRoZSBwYWdlIGlzIHVubG9hZGVkLCBlLmcuIGR1ZSB0b1xuICAvLyByZWxvYWRpbmcgdGhlIHBhZ2Ugb3IgcGVyZm9ybWluZyBoYXJkIG5hdmlnYXRpb25zLiBUaGlzIGFsbG93cyB1cyB0byBpZ25vcmVcbiAgLy8gd2hhdCB3b3VsZCBvdGhlcndpc2UgYmUgYSB0aHJvd24gVHlwZUVycm9yIHdoZW4gdGhlIGJyb3dzZXIgY2FuY2VscyB0aGVcbiAgLy8gcmVxdWVzdHMuXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwYWdlaGlkZScsICgpID0+IHtcbiAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKVxuICB9KVxuXG4gIC8vIFVzZSBhIGZyZXNoIEFib3J0Q29udHJvbGxlciBpbnN0YW5jZSBvbiBwYWdlc2hvdywgZS5nLiB3aGVuIG5hdmlnYXRpbmcgYmFja1xuICAvLyBhbmQgdGhlIEphdmFTY3JpcHQgZXhlY3V0aW9uIGNvbnRleHQgaXMgcmVzdG9yZWQgYnkgdGhlIGJyb3dzZXIuXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwYWdlc2hvdycsICgpID0+IHtcbiAgICBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKClcbiAgfSlcbn1cblxuLyoqXG4gKiBGZXRjaCB0aGUgZmxpZ2h0IGRhdGEgZm9yIHRoZSBwcm92aWRlZCB1cmwuIFRha2VzIGluIHRoZSBjdXJyZW50IHJvdXRlciBzdGF0ZVxuICogdG8gZGVjaWRlIHdoYXQgdG8gcmVuZGVyIHNlcnZlci1zaWRlLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hTZXJ2ZXJSZXNwb25zZShcbiAgdXJsOiBVUkwsXG4gIG9wdGlvbnM6IEZldGNoU2VydmVyUmVzcG9uc2VPcHRpb25zXG4pOiBQcm9taXNlPEZldGNoU2VydmVyUmVzcG9uc2VSZXN1bHQ+IHtcbiAgY29uc3QgeyBmbGlnaHRSb3V0ZXJTdGF0ZSwgbmV4dFVybCwgcHJlZmV0Y2hLaW5kIH0gPSBvcHRpb25zXG5cbiAgY29uc3QgaGVhZGVyczogUmVxdWVzdEhlYWRlcnMgPSB7XG4gICAgLy8gRW5hYmxlIGZsaWdodCByZXNwb25zZVxuICAgIFtSU0NfSEVBREVSXTogJzEnLFxuICAgIC8vIFByb3ZpZGUgdGhlIGN1cnJlbnQgcm91dGVyIHN0YXRlXG4gICAgW05FWFRfUk9VVEVSX1NUQVRFX1RSRUVfSEVBREVSXTogcHJlcGFyZUZsaWdodFJvdXRlclN0YXRlRm9yUmVxdWVzdChcbiAgICAgIGZsaWdodFJvdXRlclN0YXRlLFxuICAgICAgb3B0aW9ucy5pc0htclJlZnJlc2hcbiAgICApLFxuICB9XG5cbiAgLyoqXG4gICAqIFRocmVlIGNhc2VzOlxuICAgKiAtIGBwcmVmZXRjaEtpbmRgIGlzIGB1bmRlZmluZWRgLCBpdCBtZWFucyBpdCdzIGEgbm9ybWFsIG5hdmlnYXRpb24sIHNvIHdlIHdhbnQgdG8gcHJlZmV0Y2ggdGhlIHBhZ2UgZGF0YSBmdWxseVxuICAgKiAtIGBwcmVmZXRjaEtpbmRgIGlzIGBmdWxsYCAtIHdlIHdhbnQgdG8gcHJlZmV0Y2ggdGhlIHdob2xlIHBhZ2Ugc28gc2FtZSBhcyBhYm92ZVxuICAgKiAtIGBwcmVmZXRjaEtpbmRgIGlzIGBhdXRvYCAtIGlmIHRoZSBwYWdlIGlzIGR5bmFtaWMsIHByZWZldGNoIHRoZSBwYWdlIGRhdGEgcGFydGlhbGx5LCBpZiBzdGF0aWMgcHJlZmV0Y2ggdGhlIHBhZ2UgZGF0YSBmdWxseVxuICAgKi9cbiAgaWYgKHByZWZldGNoS2luZCA9PT0gUHJlZmV0Y2hLaW5kLkFVVE8pIHtcbiAgICBoZWFkZXJzW05FWFRfUk9VVEVSX1BSRUZFVENIX0hFQURFUl0gPSAnMSdcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiBvcHRpb25zLmlzSG1yUmVmcmVzaCkge1xuICAgIGhlYWRlcnNbTkVYVF9ITVJfUkVGUkVTSF9IRUFERVJdID0gJzEnXG4gIH1cblxuICBpZiAobmV4dFVybCkge1xuICAgIGhlYWRlcnNbTkVYVF9VUkxdID0gbmV4dFVybFxuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBXaGVuIGNyZWF0aW5nIGEgXCJ0ZW1wb3JhcnlcIiBwcmVmZXRjaCAodGhlIFwib24tZGVtYW5kXCIgcHJlZmV0Y2ggdGhhdCBnZXRzIGNyZWF0ZWQgb24gbmF2aWdhdGlvbiwgaWYgb25lIGRvZXNuJ3QgZXhpc3QpXG4gICAgLy8gd2Ugc2VuZCB0aGUgcmVxdWVzdCB3aXRoIGEgXCJoaWdoXCIgcHJpb3JpdHkgYXMgaXQncyBpbiByZXNwb25zZSB0byBhIHVzZXIgaW50ZXJhY3Rpb24gdGhhdCBjb3VsZCBiZSBibG9ja2luZyBhIHRyYW5zaXRpb24uXG4gICAgLy8gT3RoZXJ3aXNlLCBhbGwgb3RoZXIgcHJlZmV0Y2hlcyBhcmUgc2VudCB3aXRoIGEgXCJsb3dcIiBwcmlvcml0eS5cbiAgICAvLyBXZSB1c2UgXCJhdXRvXCIgZm9yIGluIGFsbCBvdGhlciBjYXNlcyB0byBtYXRjaCB0aGUgZXhpc3RpbmcgZGVmYXVsdCwgYXMgdGhpcyBmdW5jdGlvbiBpcyBzaGFyZWQgb3V0c2lkZSBvZiBwcmVmZXRjaGluZy5cbiAgICBjb25zdCBmZXRjaFByaW9yaXR5ID0gcHJlZmV0Y2hLaW5kXG4gICAgICA/IHByZWZldGNoS2luZCA9PT0gUHJlZmV0Y2hLaW5kLlRFTVBPUkFSWVxuICAgICAgICA/ICdoaWdoJ1xuICAgICAgICA6ICdsb3cnXG4gICAgICA6ICdhdXRvJ1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfQ09ORklHX09VVFBVVCA9PT0gJ2V4cG9ydCcpIHtcbiAgICAgICAgLy8gSW4gXCJvdXRwdXQ6IGV4cG9ydFwiIG1vZGUsIHdlIGNhbid0IHJlbHkgb24gaGVhZGVycyB0byBkaXN0aW5ndWlzaFxuICAgICAgICAvLyBiZXR3ZWVuIEhUTUwgYW5kIFJTQyByZXF1ZXN0cy4gSW5zdGVhZCwgd2UgYXBwZW5kIGFuIGV4dHJhIHByZWZpeFxuICAgICAgICAvLyB0byB0aGUgcmVxdWVzdC5cbiAgICAgICAgdXJsID0gbmV3IFVSTCh1cmwpXG4gICAgICAgIGlmICh1cmwucGF0aG5hbWUuZW5kc1dpdGgoJy8nKSkge1xuICAgICAgICAgIHVybC5wYXRobmFtZSArPSAnaW5kZXgudHh0J1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVybC5wYXRobmFtZSArPSAnLnR4dCdcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGNyZWF0ZUZldGNoKFxuICAgICAgdXJsLFxuICAgICAgaGVhZGVycyxcbiAgICAgIGZldGNoUHJpb3JpdHksXG4gICAgICBhYm9ydENvbnRyb2xsZXIuc2lnbmFsXG4gICAgKVxuXG4gICAgY29uc3QgcmVzcG9uc2VVcmwgPSB1cmxUb1VybFdpdGhvdXRGbGlnaHRNYXJrZXIocmVzLnVybClcbiAgICBjb25zdCBjYW5vbmljYWxVcmwgPSByZXMucmVkaXJlY3RlZCA/IHJlc3BvbnNlVXJsIDogdW5kZWZpbmVkXG5cbiAgICBjb25zdCBjb250ZW50VHlwZSA9IHJlcy5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykgfHwgJydcbiAgICBjb25zdCBpbnRlcmNlcHRpb24gPSAhIXJlcy5oZWFkZXJzLmdldCgndmFyeScpPy5pbmNsdWRlcyhORVhUX1VSTClcbiAgICBjb25zdCBwb3N0cG9uZWQgPSAhIXJlcy5oZWFkZXJzLmdldChORVhUX0RJRF9QT1NUUE9ORV9IRUFERVIpXG4gICAgY29uc3Qgc3RhbGVUaW1lSGVhZGVyU2Vjb25kcyA9IHJlcy5oZWFkZXJzLmdldChcbiAgICAgIE5FWFRfUk9VVEVSX1NUQUxFX1RJTUVfSEVBREVSXG4gICAgKVxuICAgIGNvbnN0IHN0YWxlVGltZSA9XG4gICAgICBzdGFsZVRpbWVIZWFkZXJTZWNvbmRzICE9PSBudWxsXG4gICAgICAgID8gcGFyc2VJbnQoc3RhbGVUaW1lSGVhZGVyU2Vjb25kcywgMTApICogMTAwMFxuICAgICAgICA6IC0xXG4gICAgbGV0IGlzRmxpZ2h0UmVzcG9uc2UgPSBjb250ZW50VHlwZS5zdGFydHNXaXRoKFJTQ19DT05URU5UX1RZUEVfSEVBREVSKVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfQ09ORklHX09VVFBVVCA9PT0gJ2V4cG9ydCcpIHtcbiAgICAgICAgaWYgKCFpc0ZsaWdodFJlc3BvbnNlKSB7XG4gICAgICAgICAgaXNGbGlnaHRSZXNwb25zZSA9IGNvbnRlbnRUeXBlLnN0YXJ0c1dpdGgoJ3RleHQvcGxhaW4nKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgZmV0Y2ggcmV0dXJucyBzb21ldGhpbmcgZGlmZmVyZW50IHRoYW4gZmxpZ2h0IHJlc3BvbnNlIGhhbmRsZSBpdCBsaWtlIGEgbXBhIG5hdmlnYXRpb25cbiAgICAvLyBJZiB0aGUgZmV0Y2ggd2FzIG5vdCAyMDAsIHdlIGFsc28gaGFuZGxlIGl0IGxpa2UgYSBtcGEgbmF2aWdhdGlvblxuICAgIGlmICghaXNGbGlnaHRSZXNwb25zZSB8fCAhcmVzLm9rIHx8ICFyZXMuYm9keSkge1xuICAgICAgLy8gaW4gY2FzZSB0aGUgb3JpZ2luYWwgVVJMIGNhbWUgd2l0aCBhIGhhc2gsIHByZXNlcnZlIGl0IGJlZm9yZSByZWRpcmVjdGluZyB0byB0aGUgbmV3IFVSTFxuICAgICAgaWYgKHVybC5oYXNoKSB7XG4gICAgICAgIHJlc3BvbnNlVXJsLmhhc2ggPSB1cmwuaGFzaFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZG9NcGFOYXZpZ2F0aW9uKHJlc3BvbnNlVXJsLnRvU3RyaW5nKCkpXG4gICAgfVxuXG4gICAgLy8gV2UgbWF5IG5hdmlnYXRlIHRvIGEgcGFnZSB0aGF0IHJlcXVpcmVzIGEgZGlmZmVyZW50IFdlYnBhY2sgcnVudGltZS5cbiAgICAvLyBJbiBwcm9kLCBldmVyeSBwYWdlIHdpbGwgaGF2ZSB0aGUgc2FtZSBXZWJwYWNrIHJ1bnRpbWUuXG4gICAgLy8gSW4gZGV2LCB0aGUgV2VicGFjayBydW50aW1lIGlzIG1pbmltYWwgZm9yIGVhY2ggcGFnZS5cbiAgICAvLyBXZSBuZWVkIHRvIGVuc3VyZSB0aGUgV2VicGFjayBydW50aW1lIGlzIHVwZGF0ZWQgYmVmb3JlIGV4ZWN1dGluZyBjbGllbnQtc2lkZSBKUyBvZiB0aGUgbmV3IHBhZ2UuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIXByb2Nlc3MuZW52LlRVUkJPUEFDSykge1xuICAgICAgYXdhaXQgKFxuICAgICAgICByZXF1aXJlKCcuLi8uLi9kZXYvaG90LXJlbG9hZGVyL2FwcC9ob3QtcmVsb2FkZXItYXBwJykgYXMgdHlwZW9mIGltcG9ydCgnLi4vLi4vZGV2L2hvdC1yZWxvYWRlci9hcHAvaG90LXJlbG9hZGVyLWFwcCcpXG4gICAgICApLndhaXRGb3JXZWJwYWNrUnVudGltZUhvdFVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHRoZSBgZmV0Y2hgIHJlYWRhYmxlIHN0cmVhbSB0aGF0IGNhbiBiZSB1bndyYXBwZWQgYnkgYFJlYWN0LnVzZWAuXG4gICAgY29uc3QgZmxpZ2h0U3RyZWFtID0gcG9zdHBvbmVkXG4gICAgICA/IGNyZWF0ZVVuY2xvc2luZ1ByZWZldGNoU3RyZWFtKHJlcy5ib2R5KVxuICAgICAgOiByZXMuYm9keVxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgKGNyZWF0ZUZyb21OZXh0UmVhZGFibGVTdHJlYW0oXG4gICAgICBmbGlnaHRTdHJlYW1cbiAgICApIGFzIFByb21pc2U8TmF2aWdhdGlvbkZsaWdodFJlc3BvbnNlPilcblxuICAgIGlmIChnZXRBcHBCdWlsZElkKCkgIT09IHJlc3BvbnNlLmIpIHtcbiAgICAgIHJldHVybiBkb01wYU5hdmlnYXRpb24ocmVzLnVybClcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZmxpZ2h0RGF0YTogbm9ybWFsaXplRmxpZ2h0RGF0YShyZXNwb25zZS5mKSxcbiAgICAgIGNhbm9uaWNhbFVybDogY2Fub25pY2FsVXJsLFxuICAgICAgY291bGRCZUludGVyY2VwdGVkOiBpbnRlcmNlcHRpb24sXG4gICAgICBwcmVyZW5kZXJlZDogcmVzcG9uc2UuUyxcbiAgICAgIHBvc3Rwb25lZCxcbiAgICAgIHN0YWxlVGltZSxcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmICghYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBgRmFpbGVkIHRvIGZldGNoIFJTQyBwYXlsb2FkIGZvciAke3VybH0uIEZhbGxpbmcgYmFjayB0byBicm93c2VyIG5hdmlnYXRpb24uYCxcbiAgICAgICAgZXJyXG4gICAgICApXG4gICAgfVxuXG4gICAgLy8gSWYgZmV0Y2ggZmFpbHMgaGFuZGxlIGl0IGxpa2UgYSBtcGEgbmF2aWdhdGlvblxuICAgIC8vIFRPRE8tQVBQOiBBZGQgYSB0ZXN0IGZvciB0aGUgY2FzZSB3aGVyZSBhIENPUlMgcmVxdWVzdCBmYWlscywgZS5nLiBleHRlcm5hbCB1cmwgcmVkaXJlY3QgY29taW5nIGZyb20gdGhlIHJlc3BvbnNlLlxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL25leHQuanMvaXNzdWVzLzQzNjA1I2lzc3VlY29tbWVudC0xNDUxNjE3NTIxIGZvciBhIHJlcHJvZHVjdGlvbi5cbiAgICByZXR1cm4ge1xuICAgICAgZmxpZ2h0RGF0YTogdXJsLnRvU3RyaW5nKCksXG4gICAgICBjYW5vbmljYWxVcmw6IHVuZGVmaW5lZCxcbiAgICAgIGNvdWxkQmVJbnRlcmNlcHRlZDogZmFsc2UsXG4gICAgICBwcmVyZW5kZXJlZDogZmFsc2UsXG4gICAgICBwb3N0cG9uZWQ6IGZhbHNlLFxuICAgICAgc3RhbGVUaW1lOiAtMSxcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhpcyBpcyBhIHN1YnNldCBvZiB0aGUgc3RhbmRhcmQgUmVzcG9uc2UgdHlwZS4gV2UgdXNlIGEgY3VzdG9tIHR5cGUgZm9yXG4vLyB0aGlzIHNvIHdlIGNhbiBsaW1pdCB3aGljaCBkZXRhaWxzIGFib3V0IHRoZSByZXNwb25zZSBsZWFrIGludG8gdGhlIHJlc3Qgb2Zcbi8vIHRoZSBjb2RlYmFzZS4gRm9yIGV4YW1wbGUsIHRoZXJlJ3Mgc29tZSBjdXN0b20gbG9naWMgZm9yIG1hbnVhbGx5IGZvbGxvd2luZ1xuLy8gcmVkaXJlY3RzLCBzbyBcInJlZGlyZWN0ZWRcIiBpbiB0aGlzIHR5cGUgY291bGQgYmUgYSBjb21wb3NpdGUgb2YgbXVsdGlwbGVcbi8vIGJyb3dzZXIgZmV0Y2ggY2FsbHM7IGhvd2V2ZXIsIHRoaXMgZmFjdCBzaG91bGQgbm90IGxlYWsgdG8gdGhlIGNhbGxlci5cbmV4cG9ydCB0eXBlIFJTQ1Jlc3BvbnNlID0ge1xuICBvazogYm9vbGVhblxuICByZWRpcmVjdGVkOiBib29sZWFuXG4gIGhlYWRlcnM6IEhlYWRlcnNcbiAgYm9keTogUmVhZGFibGVTdHJlYW08VWludDhBcnJheT4gfCBudWxsXG4gIHN0YXR1czogbnVtYmVyXG4gIHVybDogc3RyaW5nXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVGZXRjaChcbiAgdXJsOiBVUkwsXG4gIGhlYWRlcnM6IFJlcXVlc3RIZWFkZXJzLFxuICBmZXRjaFByaW9yaXR5OiAnYXV0bycgfCAnaGlnaCcgfCAnbG93JyB8IG51bGwsXG4gIHNpZ25hbD86IEFib3J0U2lnbmFsXG4pOiBQcm9taXNlPFJTQ1Jlc3BvbnNlPiB7XG4gIC8vIFRPRE86IEluIG91dHB1dDogXCJleHBvcnRcIiBtb2RlLCB0aGUgaGVhZGVycyBkbyBub3RoaW5nLiBPbWl0IHRoZW0gKGFuZCB0aGVcbiAgLy8gY2FjaGUgYnVzdGluZyBzZWFyY2ggcGFyYW0pIGZyb20gdGhlIHJlcXVlc3Qgc28gdGhleSdyZVxuICAvLyBtYXhpbWFsbHkgY2FjaGVhYmxlLlxuXG4gIGlmIChwcm9jZXNzLmVudi5fX05FWFRfVEVTVF9NT0RFICYmIGZldGNoUHJpb3JpdHkgIT09IG51bGwpIHtcbiAgICBoZWFkZXJzWydOZXh0LVRlc3QtRmV0Y2gtUHJpb3JpdHknXSA9IGZldGNoUHJpb3JpdHlcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5ORVhUX0RFUExPWU1FTlRfSUQpIHtcbiAgICBoZWFkZXJzWyd4LWRlcGxveW1lbnQtaWQnXSA9IHByb2Nlc3MuZW52Lk5FWFRfREVQTE9ZTUVOVF9JRFxuICB9XG5cbiAgY29uc3QgZmV0Y2hPcHRpb25zOiBSZXF1ZXN0SW5pdCA9IHtcbiAgICAvLyBCYWNrd2FyZHMgY29tcGF0IGZvciBvbGRlciBicm93c2Vycy4gYHNhbWUtb3JpZ2luYCBpcyB0aGUgZGVmYXVsdCBpbiBtb2Rlcm4gYnJvd3NlcnMuXG4gICAgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbicsXG4gICAgaGVhZGVycyxcbiAgICBwcmlvcml0eTogZmV0Y2hQcmlvcml0eSB8fCB1bmRlZmluZWQsXG4gICAgc2lnbmFsLFxuICB9XG4gIC8vIGBmZXRjaFVybGAgaXMgc2xpZ2h0bHkgZGlmZmVyZW50IGZyb20gYHVybGAgYmVjYXVzZSB3ZSBhZGQgYSBjYWNoZS1idXN0aW5nXG4gIC8vIHNlYXJjaCBwYXJhbSB0byBpdC4gVGhpcyBzaG91bGQgbm90IGxlYWsgb3V0c2lkZSBvZiB0aGlzIGZ1bmN0aW9uLCBzbyB3ZVxuICAvLyB0cmFjayB0aGVtIHNlcGFyYXRlbHkuXG4gIGxldCBmZXRjaFVybCA9IG5ldyBVUkwodXJsKVxuICBzZXRDYWNoZUJ1c3RpbmdTZWFyY2hQYXJhbShmZXRjaFVybCwgaGVhZGVycylcbiAgbGV0IGJyb3dzZXJSZXNwb25zZSA9IGF3YWl0IGZldGNoKGZldGNoVXJsLCBmZXRjaE9wdGlvbnMpXG5cbiAgLy8gSWYgdGhlIHNlcnZlciByZXNwb25kcyB3aXRoIGEgcmVkaXJlY3QgKGUuZy4gMzA3KSwgYW5kIHRoZSByZWRpcmVjdGVkXG4gIC8vIGxvY2F0aW9uIGRvZXMgbm90IGNvbnRhaW4gdGhlIGNhY2hlIGJ1c3Rpbmcgc2VhcmNoIHBhcmFtIHNldCBpbiB0aGVcbiAgLy8gb3JpZ2luYWwgcmVxdWVzdCwgdGhlIHJlc3BvbnNlIGlzIGxpa2VseSBpbnZhbGlkIOKAlCB3aGVuIGZvbGxvd2luZyB0aGVcbiAgLy8gcmVkaXJlY3QsIHRoZSBicm93c2VyIGZvcndhcmRzIHRoZSByZXF1ZXN0IGhlYWRlcnMsIGJ1dCBzaW5jZSB0aGUgY2FjaGVcbiAgLy8gYnVzdGluZyBzZWFyY2ggcGFyYW0gaXMgbWlzc2luZywgdGhlIHNlcnZlciB3aWxsIHJlamVjdCB0aGUgcmVxdWVzdCBkdWUgdG9cbiAgLy8gYSBtaXNtYXRjaC5cbiAgLy9cbiAgLy8gSWRlYWxseSwgd2Ugd291bGQgYmUgYWJsZSB0byBpbnRlcmNlcHQgdGhlIHJlZGlyZWN0IHJlc3BvbnNlIGFuZCBwZXJmb3JtIGl0XG4gIC8vIG1hbnVhbGx5LCBpbnN0ZWFkIG9mIGxldHRpbmcgdGhlIGJyb3dzZXIgYXV0b21hdGljYWxseSBmb2xsb3cgaXQsIGJ1dCB0aGlzXG4gIC8vIGlzIG5vdCBhbGxvd2VkIGJ5IHRoZSBmZXRjaCBBUEkuXG4gIC8vXG4gIC8vIFNvIGluc3RlYWQsIHdlIG11c3QgXCJyZXBsYXlcIiB0aGUgcmVkaXJlY3QgYnkgZmV0Y2hpbmcgdGhlIG5ldyBsb2NhdGlvblxuICAvLyBhZ2FpbiwgYnV0IHRoaXMgdGltZSB3ZSdsbCBhcHBlbmQgdGhlIGNhY2hlIGJ1c3Rpbmcgc2VhcmNoIHBhcmFtIHRvIHByZXZlbnRcbiAgLy8gYSBtaXNtYXRjaC5cbiAgLy9cbiAgLy8gVE9ETzogV2UgY2FuIG9wdGltaXplIE5leHQuanMncyBidWlsdC1pbiBtaWRkbGV3YXJlIEFQSXMgYnkgcmV0dXJuaW5nIGFcbiAgLy8gY3VzdG9tIHN0YXR1cyBjb2RlLCB0byBwcmV2ZW50IHRoZSBicm93c2VyIGZyb20gYXV0b21hdGljYWxseSBmb2xsb3dpbmcgaXQuXG4gIC8vXG4gIC8vIFRoaXMgZG9lcyBub3QgYWZmZWN0IFNlcnZlciBBY3Rpb24tYmFzZWQgcmVkaXJlY3RzOyB0aG9zZSBhcmUgZW5jb2RlZFxuICAvLyBkaWZmZXJlbnRseSwgYXMgcGFydCBvZiB0aGUgRmxpZ2h0IGJvZHkuIEl0IG9ubHkgYWZmZWN0cyByZWRpcmVjdHMgdGhhdFxuICAvLyBvY2N1ciBpbiBhIG1pZGRsZXdhcmUgb3IgYSB0aGlyZC1wYXJ0eSBwcm94eS5cblxuICBsZXQgcmVkaXJlY3RlZCA9IGJyb3dzZXJSZXNwb25zZS5yZWRpcmVjdGVkXG4gIGlmIChwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1ZBTElEQVRFX1JTQ19SRVFVRVNUX0hFQURFUlMpIHtcbiAgICAvLyBUaGlzIGlzIHRvIHByZXZlbnQgYSByZWRpcmVjdCBsb29wLiBTYW1lIGxpbWl0IHVzZWQgYnkgQ2hyb21lLlxuICAgIGNvbnN0IE1BWF9SRURJUkVDVFMgPSAyMFxuICAgIGZvciAobGV0IG4gPSAwOyBuIDwgTUFYX1JFRElSRUNUUzsgbisrKSB7XG4gICAgICBpZiAoIWJyb3dzZXJSZXNwb25zZS5yZWRpcmVjdGVkKSB7XG4gICAgICAgIC8vIFRoZSBzZXJ2ZXIgZGlkIG5vdCBwZXJmb3JtIGEgcmVkaXJlY3QuXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBjb25zdCByZXNwb25zZVVybCA9IG5ldyBVUkwoYnJvd3NlclJlc3BvbnNlLnVybCwgZmV0Y2hVcmwpXG4gICAgICBpZiAocmVzcG9uc2VVcmwub3JpZ2luICE9PSBmZXRjaFVybC5vcmlnaW4pIHtcbiAgICAgICAgLy8gVGhlIHNlcnZlciByZWRpcmVjdGVkIHRvIGFuIGV4dGVybmFsIFVSTC4gVGhlIHJlc3Qgb2YgdGhlIGxvZ2ljIGJlbG93XG4gICAgICAgIC8vIGlzIG5vdCByZWxldmFudCwgYmVjYXVzZSBpdCBvbmx5IGFwcGxpZXMgdG8gaW50ZXJuYWwgcmVkaXJlY3RzLlxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgICByZXNwb25zZVVybC5zZWFyY2hQYXJhbXMuZ2V0KE5FWFRfUlNDX1VOSU9OX1FVRVJZKSA9PT1cbiAgICAgICAgZmV0Y2hVcmwuc2VhcmNoUGFyYW1zLmdldChORVhUX1JTQ19VTklPTl9RVUVSWSlcbiAgICAgICkge1xuICAgICAgICAvLyBUaGUgcmVkaXJlY3RlZCBVUkwgYWxyZWFkeSBpbmNsdWRlcyB0aGUgY2FjaGUgYnVzdGluZyBzZWFyY2ggcGFyYW0uXG4gICAgICAgIC8vIFRoaXMgd2FzIHByb2JhYmx5IGludGVudGlvbmFsLiBSZWdhcmRsZXNzLCB0aGVyZSdzIG5vIHJlYXNvbiB0b1xuICAgICAgICAvLyBpc3N1ZSBhbm90aGVyIHJlcXVlc3QgdG8gdGhpcyBVUkwgYmVjYXVzZSBpdCBhbHJlYWR5IGhhcyB0aGUgcGFyYW1cbiAgICAgICAgLy8gdmFsdWUgdGhhdCB3ZSB3b3VsZCBoYXZlIGFkZGVkIGJlbG93LlxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgLy8gVGhlIFJTQyByZXF1ZXN0IHdhcyByZWRpcmVjdGVkLiBBc3N1bWUgdGhlIHJlc3BvbnNlIGlzIGludmFsaWQuXG4gICAgICAvL1xuICAgICAgLy8gQXBwZW5kIHRoZSBjYWNoZSBidXN0aW5nIHNlYXJjaCBwYXJhbSB0byB0aGUgcmVkaXJlY3RlZCBVUkwgYW5kXG4gICAgICAvLyBmZXRjaCBhZ2Fpbi5cbiAgICAgIGZldGNoVXJsID0gbmV3IFVSTChyZXNwb25zZVVybClcbiAgICAgIHNldENhY2hlQnVzdGluZ1NlYXJjaFBhcmFtKGZldGNoVXJsLCBoZWFkZXJzKVxuICAgICAgYnJvd3NlclJlc3BvbnNlID0gYXdhaXQgZmV0Y2goZmV0Y2hVcmwsIGZldGNoT3B0aW9ucylcbiAgICAgIC8vIFdlIGp1c3QgcGVyZm9ybWVkIGEgbWFudWFsIHJlZGlyZWN0LCBzbyB0aGlzIGlzIG5vdyB0cnVlLlxuICAgICAgcmVkaXJlY3RlZCA9IHRydWVcbiAgICB9XG4gIH1cblxuICAvLyBSZW1vdmUgdGhlIGNhY2hlIGJ1c3Rpbmcgc2VhcmNoIHBhcmFtIGZyb20gdGhlIHJlc3BvbnNlIFVSTCwgdG8gcHJldmVudCBpdFxuICAvLyBmcm9tIGxlYWtpbmcgb3V0c2lkZSBvZiB0aGlzIGZ1bmN0aW9uLlxuICBjb25zdCByZXNwb25zZVVybCA9IG5ldyBVUkwoYnJvd3NlclJlc3BvbnNlLnVybCwgZmV0Y2hVcmwpXG4gIHJlc3BvbnNlVXJsLnNlYXJjaFBhcmFtcy5kZWxldGUoTkVYVF9SU0NfVU5JT05fUVVFUlkpXG5cbiAgY29uc3QgcnNjUmVzcG9uc2U6IFJTQ1Jlc3BvbnNlID0ge1xuICAgIHVybDogcmVzcG9uc2VVcmwuaHJlZixcblxuICAgIC8vIFRoaXMgaXMgdHJ1ZSBpZiBhbnkgcmVkaXJlY3RzIG9jY3VycmVkLCBlaXRoZXIgYXV0b21hdGljYWxseSBieSB0aGVcbiAgICAvLyBicm93c2VyLCBvciBtYW51YWxseSBieSB1cy4gU28gaXQncyBkaWZmZXJlbnQgZnJvbVxuICAgIC8vIGBicm93c2VyUmVzcG9uc2UucmVkaXJlY3RlZGAsIHdoaWNoIG9ubHkgdGVsbHMgdXMgd2hldGhlciB0aGUgYnJvd3NlclxuICAgIC8vIGZvbGxvd2VkIGEgcmVkaXJlY3QsIGFuZCBvbmx5IGZvciB0aGUgbGFzdCByZXNwb25zZSBpbiB0aGUgY2hhaW4uXG4gICAgcmVkaXJlY3RlZCxcblxuICAgIC8vIFRoZXNlIGNhbiBiZSBjb3BpZWQgZnJvbSB0aGUgbGFzdCBicm93c2VyIHJlc3BvbnNlIHdlIHJlY2VpdmVkLiBXZVxuICAgIC8vIGludGVudGlvbmFsbHkgb25seSBleHBvc2UgdGhlIHN1YnNldCBvZiBmaWVsZHMgdGhhdCBhcmUgYWN0dWFsbHkgdXNlZFxuICAgIC8vIGVsc2V3aGVyZSBpbiB0aGUgY29kZWJhc2UuXG4gICAgb2s6IGJyb3dzZXJSZXNwb25zZS5vayxcbiAgICBoZWFkZXJzOiBicm93c2VyUmVzcG9uc2UuaGVhZGVycyxcbiAgICBib2R5OiBicm93c2VyUmVzcG9uc2UuYm9keSxcbiAgICBzdGF0dXM6IGJyb3dzZXJSZXNwb25zZS5zdGF0dXMsXG4gIH1cblxuICByZXR1cm4gcnNjUmVzcG9uc2Vcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZyb21OZXh0UmVhZGFibGVTdHJlYW0oXG4gIGZsaWdodFN0cmVhbTogUmVhZGFibGVTdHJlYW08VWludDhBcnJheT5cbik6IFByb21pc2U8dW5rbm93bj4ge1xuICByZXR1cm4gY3JlYXRlRnJvbVJlYWRhYmxlU3RyZWFtKGZsaWdodFN0cmVhbSwge1xuICAgIGNhbGxTZXJ2ZXIsXG4gICAgZmluZFNvdXJjZU1hcFVSTCxcbiAgfSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlVW5jbG9zaW5nUHJlZmV0Y2hTdHJlYW0oXG4gIG9yaWdpbmFsRmxpZ2h0U3RyZWFtOiBSZWFkYWJsZVN0cmVhbTxVaW50OEFycmF5PlxuKTogUmVhZGFibGVTdHJlYW08VWludDhBcnJheT4ge1xuICAvLyBXaGVuIFBQUiBpcyBlbmFibGVkLCBwcmVmZXRjaCBzdHJlYW1zIG1heSBjb250YWluIHJlZmVyZW5jZXMgdGhhdCBuZXZlclxuICAvLyByZXNvbHZlLCBiZWNhdXNlIHRoYXQncyBob3cgd2UgZW5jb2RlIGR5bmFtaWMgZGF0YSBhY2Nlc3MuIEluIHRoZSBkZWNvZGVkXG4gIC8vIG9iamVjdCByZXR1cm5lZCBieSB0aGUgRmxpZ2h0IGNsaWVudCwgdGhlc2UgYXJlIHJlaWZpZWQgaW50byBoYW5naW5nXG4gIC8vIHByb21pc2VzIHRoYXQgc3VzcGVuZCBkdXJpbmcgcmVuZGVyLCB3aGljaCBpcyBlZmZlY3RpdmVseSB3aGF0IHdlIHdhbnQuXG4gIC8vIFRoZSBVSSByZXNvbHZlcyB3aGVuIGl0IHN3aXRjaGVzIHRvIHRoZSBkeW5hbWljIGRhdGEgc3RyZWFtXG4gIC8vICh2aWEgdXNlRGVmZXJyZWRWYWx1ZShkeW5hbWljLCBzdGF0aWMpKS5cbiAgLy9cbiAgLy8gSG93ZXZlciwgdGhlIEZsaWdodCBpbXBsZW1lbnRhdGlvbiBjdXJyZW50bHkgZXJyb3JzIGlmIHRoZSBzZXJ2ZXIgY2xvc2VzXG4gIC8vIHRoZSByZXNwb25zZSBiZWZvcmUgYWxsIHRoZSByZWZlcmVuY2VzIGFyZSByZXNvbHZlZC4gQXMgYSBjaGVhdCB0byB3b3JrXG4gIC8vIGFyb3VuZCB0aGlzLCB3ZSB3cmFwIHRoZSBvcmlnaW5hbCBzdHJlYW0gaW4gYSBuZXcgc3RyZWFtIHRoYXQgbmV2ZXIgY2xvc2VzLFxuICAvLyBhbmQgdGhlcmVmb3JlIGRvZXNuJ3QgZXJyb3IuXG4gIGNvbnN0IHJlYWRlciA9IG9yaWdpbmFsRmxpZ2h0U3RyZWFtLmdldFJlYWRlcigpXG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIGFzeW5jIHB1bGwoY29udHJvbGxlcikge1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKVxuICAgICAgICBpZiAoIWRvbmUpIHtcbiAgICAgICAgICAvLyBQYXNzIHRvIHRoZSB0YXJnZXQgc3RyZWFtIGFuZCBrZWVwIGNvbnN1bWluZyB0aGUgRmxpZ2h0IHJlc3BvbnNlXG4gICAgICAgICAgLy8gZnJvbSB0aGUgc2VydmVyLlxuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh2YWx1ZSlcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBzZXJ2ZXIgc3RyZWFtIGhhcyBjbG9zZWQuIEV4aXQsIGJ1dCBpbnRlbnRpb25hbGx5IGRvIG5vdCBjbG9zZVxuICAgICAgICAvLyB0aGUgdGFyZ2V0IHN0cmVhbS5cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfSxcbiAgfSlcbn1cbiJdLCJuYW1lcyI6WyJjcmVhdGVGZXRjaCIsImNyZWF0ZUZyb21OZXh0UmVhZGFibGVTdHJlYW0iLCJmZXRjaFNlcnZlclJlc3BvbnNlIiwidXJsVG9VcmxXaXRob3V0RmxpZ2h0TWFya2VyIiwiY3JlYXRlRnJvbVJlYWRhYmxlU3RyZWFtIiwiY3JlYXRlRnJvbVJlYWRhYmxlU3RyZWFtQnJvd3NlciIsInVybCIsInVybFdpdGhvdXRGbGlnaHRQYXJhbWV0ZXJzIiwiVVJMIiwibG9jYXRpb24iLCJvcmlnaW4iLCJzZWFyY2hQYXJhbXMiLCJkZWxldGUiLCJORVhUX1JTQ19VTklPTl9RVUVSWSIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsIl9fTkVYVF9DT05GSUdfT1VUUFVUIiwicGF0aG5hbWUiLCJlbmRzV2l0aCIsImxlbmd0aCIsInNsaWNlIiwiZG9NcGFOYXZpZ2F0aW9uIiwiZmxpZ2h0RGF0YSIsInRvU3RyaW5nIiwiY2Fub25pY2FsVXJsIiwidW5kZWZpbmVkIiwiY291bGRCZUludGVyY2VwdGVkIiwicHJlcmVuZGVyZWQiLCJwb3N0cG9uZWQiLCJzdGFsZVRpbWUiLCJhYm9ydENvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwiYWJvcnQiLCJvcHRpb25zIiwiZmxpZ2h0Um91dGVyU3RhdGUiLCJuZXh0VXJsIiwicHJlZmV0Y2hLaW5kIiwiaGVhZGVycyIsIlJTQ19IRUFERVIiLCJORVhUX1JPVVRFUl9TVEFURV9UUkVFX0hFQURFUiIsInByZXBhcmVGbGlnaHRSb3V0ZXJTdGF0ZUZvclJlcXVlc3QiLCJpc0htclJlZnJlc2giLCJQcmVmZXRjaEtpbmQiLCJBVVRPIiwiTkVYVF9ST1VURVJfUFJFRkVUQ0hfSEVBREVSIiwiTkVYVF9ITVJfUkVGUkVTSF9IRUFERVIiLCJORVhUX1VSTCIsInJlcyIsImZldGNoUHJpb3JpdHkiLCJURU1QT1JBUlkiLCJzaWduYWwiLCJyZXNwb25zZVVybCIsInJlZGlyZWN0ZWQiLCJjb250ZW50VHlwZSIsImdldCIsImludGVyY2VwdGlvbiIsImluY2x1ZGVzIiwiTkVYVF9ESURfUE9TVFBPTkVfSEVBREVSIiwic3RhbGVUaW1lSGVhZGVyU2Vjb25kcyIsIk5FWFRfUk9VVEVSX1NUQUxFX1RJTUVfSEVBREVSIiwicGFyc2VJbnQiLCJpc0ZsaWdodFJlc3BvbnNlIiwic3RhcnRzV2l0aCIsIlJTQ19DT05URU5UX1RZUEVfSEVBREVSIiwib2siLCJib2R5IiwiaGFzaCIsIlRVUkJPUEFDSyIsInJlcXVpcmUiLCJ3YWl0Rm9yV2VicGFja1J1bnRpbWVIb3RVcGRhdGUiLCJmbGlnaHRTdHJlYW0iLCJjcmVhdGVVbmNsb3NpbmdQcmVmZXRjaFN0cmVhbSIsInJlc3BvbnNlIiwiZ2V0QXBwQnVpbGRJZCIsImIiLCJub3JtYWxpemVGbGlnaHREYXRhIiwiZiIsIlMiLCJlcnIiLCJhYm9ydGVkIiwiY29uc29sZSIsImVycm9yIiwiX19ORVhUX1RFU1RfTU9ERSIsIk5FWFRfREVQTE9ZTUVOVF9JRCIsImZldGNoT3B0aW9ucyIsImNyZWRlbnRpYWxzIiwicHJpb3JpdHkiLCJmZXRjaFVybCIsInNldENhY2hlQnVzdGluZ1NlYXJjaFBhcmFtIiwiYnJvd3NlclJlc3BvbnNlIiwiZmV0Y2giLCJfX05FWFRfQ0xJRU5UX1ZBTElEQVRFX1JTQ19SRVFVRVNUX0hFQURFUlMiLCJNQVhfUkVESVJFQ1RTIiwibiIsInJzY1Jlc3BvbnNlIiwiaHJlZiIsInN0YXR1cyIsImNhbGxTZXJ2ZXIiLCJmaW5kU291cmNlTWFwVVJMIiwib3JpZ2luYWxGbGlnaHRTdHJlYW0iLCJyZWFkZXIiLCJnZXRSZWFkZXIiLCJSZWFkYWJsZVN0cmVhbSIsInB1bGwiLCJjb250cm9sbGVyIiwiZG9uZSIsInZhbHVlIiwicmVhZCIsImVucXVldWUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7SUF5UnNCQSxXQUFXLEVBQUE7ZUFBWEE7O0lBcUhOQyw0QkFBNEIsRUFBQTtlQUE1QkE7O0lBM1JNQyxtQkFBbUIsRUFBQTtlQUFuQkE7O0lBbEROQywyQkFBMkIsRUFBQTtlQUEzQkE7Ozt3QkE3RDREO2tDQWtCckU7K0JBQ29CO3FDQUNNO29DQUNKO21DQUt0Qjs0QkFDdUI7NENBQ2E7QUFFM0MsTUFBTUMsMkJBQ0pDLFFBQUFBLHdCQUErQjtBQThCMUIsU0FBU0YsNEJBQTRCRyxHQUFXO0lBQ3JELE1BQU1DLDZCQUE2QixJQUFJQyxJQUFJRixLQUFLRyxTQUFTQyxNQUFNO0lBQy9ESCwyQkFBMkJJLFlBQVksQ0FBQ0MsTUFBTSxDQUFDQyxrQkFBQUEsb0JBQW9CO0lBQ25FLElBQUlDLFFBQVFDLEdBQUcsQ0FBQ0MsUUFBUSxLQUFLLGNBQWM7O0lBVzNDLE9BQU9UO0FBQ1Q7QUFFQSxTQUFTZSxn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N0JZLElBQUl5QixnQkFBZ0J6QixFQUFFO1FBQ3RCM0IsU0FBU29ELGdCQUFnQnBELE9BQU87UUFDaEM0QixNQUFNd0IsZ0JBQWdCeEIsSUFBSTtRQUMxQitCLFFBQVFQLGdCQUFnQk8sTUFBTTtJQUNoQztJQUVBLE9BQU9GO0FBQ1Q7QUFFTyxTQUFTaEcsNkJBQ2R3RSxZQUF3QztJQUV4QyxPQUFPckUseUJBQXlCcUUsY0FBYztRQUM1QzJCLFlBQUFBLGVBQUFBLFVBQVU7UUFDVkMsa0JBQUFBLHFCQUFBQSxnQkFBZ0I7SUFDbEI7QUFDRjtBQUVBLFNBQVMzQiw4QkFDUDRCLG9CQUFnRDtJQUVoRCwwRUFBMEU7SUFDMUUsNEVBQTRFO0lBQzVFLHVFQUF1RTtJQUN2RSwwRUFBMEU7SUFDMUUsOERBQThEO0lBQzlELDJDQUEyQztJQUMzQyxFQUFFO0lBQ0YsMkVBQTJFO0lBQzNFLDBFQUEwRTtJQUMxRSw4RUFBOEU7SUFDOUUsK0JBQStCO0lBQy9CLE1BQU1DLFNBQVNELHFCQUFxQkUsU0FBUztJQUM3QyxPQUFPLElBQUlDLGVBQWU7UUFDeEIsTUFBTUMsTUFBS0MsVUFBVTtZQUNuQixNQUFPLEtBQU07Z0JBQ1gsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLEtBQUssRUFBRSxHQUFHLE1BQU1OLE9BQU9PLElBQUk7Z0JBQ3pDLElBQUksQ0FBQ0YsTUFBTTtvQkFDVCxtRUFBbUU7b0JBQ25FLG1CQUFtQjtvQkFDbkJELFdBQVdJLE9BQU8sQ0FBQ0Y7b0JBQ25CO2dCQUNGO2dCQUNBLHFFQUFxRTtnQkFDckUscUJBQXFCO2dCQUNyQjtZQUNGO1FBQ0Y7SUFDRjtBQUNGIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDM0NjAsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvY3JlYXRlLWhyZWYtZnJvbS11cmwudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUhyZWZGcm9tVXJsKFxuICB1cmw6IFBpY2s8VVJMLCAncGF0aG5hbWUnIHwgJ3NlYXJjaCcgfCAnaGFzaCc+LFxuICBpbmNsdWRlSGFzaDogYm9vbGVhbiA9IHRydWVcbik6IHN0cmluZyB7XG4gIHJldHVybiB1cmwucGF0aG5hbWUgKyB1cmwuc2VhcmNoICsgKGluY2x1ZGVIYXNoID8gdXJsLmhhc2ggOiAnJylcbn1cbiJdLCJuYW1lcyI6WyJjcmVhdGVIcmVmRnJvbVVybCIsInVybCIsImluY2x1ZGVIYXNoIiwicGF0aG5hbWUiLCJzZWFyY2giLCJoYXNoIl0sIm1hcHBpbmdzIjoiOzs7K0JBQWdCQSxxQkFBQUE7OztlQUFBQTs7O0FBQVQsU0FBU0Esa0JBQ2RDLEdBQThDLEVBQzlDQyxXQUEyQjtJQUEzQkEsSUFBQUEsZ0JBQUFBLEtBQUFBLEdBQUFBLGNBQXVCO0lBRXZCLE9BQU9ELElBQUlFLFFBQVEsR0FBR0YsSUFBSUcsTUFBTSxHQUFJRixDQUFBQSxjQUFjRCxJQUFJSSxJQUFJLEdBQUcsRUFBQztBQUNoRSIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAzNDg2LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2NyZWF0ZS1yb3V0ZXItY2FjaGUta2V5LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgU2VnbWVudCB9IGZyb20gJy4uLy4uLy4uL3NlcnZlci9hcHAtcmVuZGVyL3R5cGVzJ1xuaW1wb3J0IHsgUEFHRV9TRUdNRU5UX0tFWSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9saWIvc2VnbWVudCdcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJvdXRlckNhY2hlS2V5KFxuICBzZWdtZW50OiBTZWdtZW50LFxuICB3aXRob3V0U2VhcmNoUGFyYW1ldGVyczogYm9vbGVhbiA9IGZhbHNlXG4pIHtcbiAgLy8gaWYgdGhlIHNlZ21lbnQgaXMgYW4gYXJyYXksIGl0IG1lYW5zIGl0J3MgYSBkeW5hbWljIHNlZ21lbnRcbiAgLy8gZm9yIGV4YW1wbGUsIFsnbGFuZycsICdlbicsICdkJ10uIFdlIG5lZWQgdG8gY29udmVydCBpdCB0byBhIHN0cmluZyB0byBzdG9yZSBpdCBhcyBhIGNhY2hlIG5vZGUga2V5LlxuICBpZiAoQXJyYXkuaXNBcnJheShzZWdtZW50KSkge1xuICAgIHJldHVybiBgJHtzZWdtZW50WzBdfXwke3NlZ21lbnRbMV19fCR7c2VnbWVudFsyXX1gXG4gIH1cblxuICAvLyBQYWdlIHNlZ21lbnRzIG1pZ2h0IGhhdmUgc2VhcmNoIHBhcmFtZXRlcnMsIGllIF9fUEFHRV9fP2Zvbz1iYXJcbiAgLy8gV2hlbiBgd2l0aG91dFNlYXJjaFBhcmFtZXRlcnNgIGlzIHRydWUsIHdlIG9ubHkgd2FudCB0byByZXR1cm4gdGhlIHBhZ2Ugc2VnbWVudFxuICBpZiAod2l0aG91dFNlYXJjaFBhcmFtZXRlcnMgJiYgc2VnbWVudC5zdGFydHNXaXRoKFBBR0VfU0VHTUVOVF9LRVkpKSB7XG4gICAgcmV0dXJuIFBBR0VfU0VHTUVOVF9LRVlcbiAgfVxuXG4gIHJldHVybiBzZWdtZW50XG59XG4iXSwibmFtZXMiOlsiY3JlYXRlUm91dGVyQ2FjaGVLZXkiLCJzZWdtZW50Iiwid2l0aG91dFNlYXJjaFBhcmFtZXRlcnMiLCJBcnJheSIsImlzQXJyYXkiLCJzdGFydHNXaXRoIiwiUEFHRV9TRUdNRU5UX0tFWSJdLCJtYXBwaW5ncyI6Ijs7OytCQUdnQkEsd0JBQUFBOzs7ZUFBQUE7Ozt5QkFGaUI7QUFFMUIsU0FBU0EscUJBQ2RDLE9BQWdCLEVBQ2hCQyx1QkFBd0M7SUFBeENBLElBQUFBLDRCQUFBQSxLQUFBQSxHQUFBQSwwQkFBbUM7SUFFbkMsOERBQThEO0lBQzlELHVHQUF1RztJQUN2RyxJQUFJQyxNQUFNQyxPQUFPLENBQUNILFVBQVU7UUFDMUIsT0FBVUEsT0FBTyxDQUFDLEVBQUUsR0FBQyxNQUFHQSxPQUFPLENBQUMsRUFBRSxHQUFDLE1BQUdBLE9BQU8sQ0FBQyxFQUFFO0lBQ2xEO0lBRUEsa0VBQWtFO0lBQ2xFLGtGQUFrRjtJQUNsRixJQUFJQywyQkFBMkJELFFBQVFJLFVBQVUsQ0FBQ0MsU0FBQUEsZ0JBQWdCLEdBQUc7UUFDbkUsT0FBT0EsU0FBQUEsZ0JBQWdCO0lBQ3pCO0lBRUEsT0FBT0w7QUFDVCIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAzNTIzLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2ludmFsaWRhdGUtY2FjaGUtYmVsb3ctZmxpZ2h0LXNlZ21lbnRwYXRoLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgQ2FjaGVOb2RlIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgdHlwZSB7IEZsaWdodFNlZ21lbnRQYXRoIH0gZnJvbSAnLi4vLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvdHlwZXMnXG5pbXBvcnQgeyBjcmVhdGVSb3V0ZXJDYWNoZUtleSB9IGZyb20gJy4vY3JlYXRlLXJvdXRlci1jYWNoZS1rZXknXG5pbXBvcnQgeyBnZXROZXh0RmxpZ2h0U2VnbWVudFBhdGggfSBmcm9tICcuLi8uLi9mbGlnaHQtZGF0YS1oZWxwZXJzJ1xuXG4vKipcbiAqIEZpbGwgY2FjaGUgdXAgdG8gdGhlIGVuZCBvZiB0aGUgZmxpZ2h0U2VnbWVudFBhdGgsIGludmFsaWRhdGluZyBhbnl0aGluZyBiZWxvdyBpdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludmFsaWRhdGVDYWNoZUJlbG93RmxpZ2h0U2VnbWVudFBhdGgoXG4gIG5ld0NhY2hlOiBDYWNoZU5vZGUsXG4gIGV4aXN0aW5nQ2FjaGU6IENhY2hlTm9kZSxcbiAgZmxpZ2h0U2VnbWVudFBhdGg6IEZsaWdodFNlZ21lbnRQYXRoXG4pOiB2b2lkIHtcbiAgY29uc3QgaXNMYXN0RW50cnkgPSBmbGlnaHRTZWdtZW50UGF0aC5sZW5ndGggPD0gMlxuICBjb25zdCBbcGFyYWxsZWxSb3V0ZUtleSwgc2VnbWVudF0gPSBmbGlnaHRTZWdtZW50UGF0aFxuXG4gIGNvbnN0IGNhY2hlS2V5ID0gY3JlYXRlUm91dGVyQ2FjaGVLZXkoc2VnbWVudClcblxuICBjb25zdCBleGlzdGluZ0NoaWxkU2VnbWVudE1hcCA9XG4gICAgZXhpc3RpbmdDYWNoZS5wYXJhbGxlbFJvdXRlcy5nZXQocGFyYWxsZWxSb3V0ZUtleSlcblxuICBpZiAoIWV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwKSB7XG4gICAgLy8gQmFpbG91dCBiZWNhdXNlIHRoZSBleGlzdGluZyBjYWNoZSBkb2VzIG5vdCBoYXZlIHRoZSBwYXRoIHRvIHRoZSBsZWFmIG5vZGVcbiAgICAvLyBXaWxsIHRyaWdnZXIgbGF6eSBmZXRjaCBpbiBsYXlvdXQtcm91dGVyIGJlY2F1c2Ugb2YgbWlzc2luZyBzZWdtZW50XG4gICAgcmV0dXJuXG4gIH1cblxuICBsZXQgY2hpbGRTZWdtZW50TWFwID0gbmV3Q2FjaGUucGFyYWxsZWxSb3V0ZXMuZ2V0KHBhcmFsbGVsUm91dGVLZXkpXG4gIGlmICghY2hpbGRTZWdtZW50TWFwIHx8IGNoaWxkU2VnbWVudE1hcCA9PT0gZXhpc3RpbmdDaGlsZFNlZ21lbnRNYXApIHtcbiAgICBjaGlsZFNlZ21lbnRNYXAgPSBuZXcgTWFwKGV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwKVxuICAgIG5ld0NhY2hlLnBhcmFsbGVsUm91dGVzLnNldChwYXJhbGxlbFJvdXRlS2V5LCBjaGlsZFNlZ21lbnRNYXApXG4gIH1cblxuICAvLyBJbiBjYXNlIG9mIGxhc3QgZW50cnkgZG9uJ3QgY29weSBmdXJ0aGVyIGRvd24uXG4gIGlmIChpc0xhc3RFbnRyeSkge1xuICAgIGNoaWxkU2VnbWVudE1hcC5kZWxldGUoY2FjaGVLZXkpXG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCBleGlzdGluZ0NoaWxkQ2FjaGVOb2RlID0gZXhpc3RpbmdDaGlsZFNlZ21lbnRNYXAuZ2V0KGNhY2hlS2V5KVxuICBsZXQgY2hpbGRDYWNoZU5vZGUgPSBjaGlsZFNlZ21lbnRNYXAuZ2V0KGNhY2hlS2V5KVxuXG4gIGlmICghY2hpbGRDYWNoZU5vZGUgfHwgIWV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUpIHtcbiAgICAvLyBCYWlsb3V0IGJlY2F1c2UgdGhlIGV4aXN0aW5nIGNhY2hlIGRvZXMgbm90IGhhdmUgdGhlIHBhdGggdG8gdGhlIGxlYWYgbm9kZVxuICAgIC8vIFdpbGwgdHJpZ2dlciBsYXp5IGZldGNoIGluIGxheW91dC1yb3V0ZXIgYmVjYXVzZSBvZiBtaXNzaW5nIHNlZ21lbnRcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChjaGlsZENhY2hlTm9kZSA9PT0gZXhpc3RpbmdDaGlsZENhY2hlTm9kZSkge1xuICAgIGNoaWxkQ2FjaGVOb2RlID0ge1xuICAgICAgbGF6eURhdGE6IGNoaWxkQ2FjaGVOb2RlLmxhenlEYXRhLFxuICAgICAgcnNjOiBjaGlsZENhY2hlTm9kZS5yc2MsXG4gICAgICBwcmVmZXRjaFJzYzogY2hpbGRDYWNoZU5vZGUucHJlZmV0Y2hSc2MsXG4gICAgICBoZWFkOiBjaGlsZENhY2hlTm9kZS5oZWFkLFxuICAgICAgcHJlZmV0Y2hIZWFkOiBjaGlsZENhY2hlTm9kZS5wcmVmZXRjaEhlYWQsXG4gICAgICBwYXJhbGxlbFJvdXRlczogbmV3IE1hcChjaGlsZENhY2hlTm9kZS5wYXJhbGxlbFJvdXRlcyksXG4gICAgfSBhcyBDYWNoZU5vZGVcbiAgICBjaGlsZFNlZ21lbnRNYXAuc2V0KGNhY2hlS2V5LCBjaGlsZENhY2hlTm9kZSlcbiAgfVxuXG4gIGludmFsaWRhdGVDYWNoZUJlbG93RmxpZ2h0U2VnbWVudFBhdGgoXG4gICAgY2hpbGRDYWNoZU5vZGUsXG4gICAgZXhpc3RpbmdDaGlsZENhY2hlTm9kZSxcbiAgICBnZXROZXh0RmxpZ2h0U2VnbWVudFBhdGgoZmxpZ2h0U2VnbWVudFBhdGgpXG4gIClcbn1cbiJdLCJuYW1lcyI6WyJpbnZhbGlkYXRlQ2FjaGVCZWxvd0ZsaWdodFNlZ21lbnRQYXRoIiwibmV3Q2FjaGUiLCJleGlzdGluZ0NhY2hlIiwiZmxpZ2h0U2VnbWVudFBhdGgiLCJpc0xhc3RFbnRyeSIsImxlbmd0aCIsInBhcmFsbGVsUm91dGVLZXkiLCJzZWdtZW50IiwiY2FjaGVLZXkiLCJjcmVhdGVSb3V0ZXJDYWNoZUtleSIsImV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwIiwicGFyYWxsZWxSb3V0ZXMiLCJnZXQiLCJjaGlsZFNlZ21lbnRNYXAiLCJNYXAiLCJzZXQiLCJkZWxldGUiLCJleGlzdGluZ0NoaWxkQ2FjaGVOb2RlIiwiY2hpbGRDYWNoZU5vZGUiLCJsYXp5RGF0YSIsInJzYyIsInByZWZldGNoUnNjIiwiaGVhZCIsInByZWZldGNoSGVhZCIsImdldE5leHRGbGlnaHRTZWdtZW50UGF0aCJdLCJtYXBwaW5ncyI6Ijs7OytCQVFnQkEseUNBQUFBOzs7ZUFBQUE7OztzQ0FOcUI7bUNBQ0k7QUFLbEMsU0FBU0Esc0NBQ2RDLFFBQW1CLEVBQ25CQyxhQUF3QixFQUN4QkMsaUJBQW9DO0lBRXBDLE1BQU1DLGNBQWNELGtCQUFrQkUsTUFBTSxJQUFJO0lBQ2hELE1BQU0sQ0FBQ0Msa0JBQWtCQyxRQUFRLEdBQUdKO0lBRXBDLE1BQU1LLFdBQVdDLENBQUFBLEdBQUFBLHNCQUFBQSxvQkFBb0IsRUFBQ0Y7SUFFdEMsTUFBTUcsMEJBQ0pSLGNBQWNTLGNBQWMsQ0FBQ0MsR0FBRyxDQUFDTjtJQUVuQyxJQUFJLENBQUNJLHlCQUF5QjtRQUM1Qiw2RUFBNkU7UUFDN0Usc0VBQXNFO1FBQ3RFO0lBQ0Y7SUFFQSxJQUFJRyxrQkFBa0JaLFNBQVNVLGNBQWMsQ0FBQ0MsR0FBRyxDQUFDTjtJQUNsRCxJQUFJLENBQUNPLG1CQUFtQkEsb0JBQW9CSCx5QkFBeUI7UUFDbkVHLGtCQUFrQixJQUFJQyxJQUFJSjtRQUMxQlQsU0FBU1UsY0FBYyxDQUFDSSxHQUFHLENBQUNULGtCQUFrQk87SUFDaEQ7SUFFQSxpREFBaUQ7SUFDakQsSUFBSVQsYUFBYTtRQUNmUyxnQkFBZ0JHLE1BQU0sQ0FBQ1I7UUFDdkI7SUFDRjtJQUVBLE1BQU1TLHlCQUF5QlAsd0JBQXdCRSxHQUFHLENBQUNKO0lBQzNELElBQUlVLGlCQUFpQkwsZ0JBQWdCRCxHQUFHLENBQUNKO0lBRXpDLElBQUksQ0FBQ1Usa0JBQWtCLENBQUNELHdCQUF3QjtRQUM5Qyw2RUFBNkU7UUFDN0Usc0VBQXNFO1FBQ3RFO0lBQ0Y7SUFFQSxJQUFJQyxtQkFBbUJELHdCQUF3QjtRQUM3Q0MsaUJBQWlCO1lBQ2ZDLFVBQVVELGVBQWVDLFFBQVE7WUFDakNDLEtBQUtGLGVBQWVFLEdBQUc7WUFDdkJDLGFBQWFILGVBQWVHLFdBQVc7WUFDdkNDLE1BQU1KLGVBQWVJLElBQUk7WUFDekJDLGNBQWNMLGVBQWVLLFlBQVk7WUFDekNaLGdCQUFnQixJQUFJRyxJQUFJSSxlQUFlUCxjQUFjO1FBQ3ZEO1FBQ0FFLGdCQUFnQkUsR0FBRyxDQUFDUCxVQUFVVTtJQUNoQztJQUVBbEIsc0NBQ0VrQixnQkFDQUQsd0JBQ0FPLENBQUFBLEdBQUFBLG1CQUFBQSx3QkFBd0IsRUFBQ3JCO0FBRTdCIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDM1ODcsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvY2xpZW50L2NvbXBvbmVudHMvbWF0Y2gtc2VnbWVudHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBTZWdtZW50IH0gZnJvbSAnLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvdHlwZXMnXG5cbmV4cG9ydCBjb25zdCBtYXRjaFNlZ21lbnQgPSAoXG4gIGV4aXN0aW5nU2VnbWVudDogU2VnbWVudCxcbiAgc2VnbWVudDogU2VnbWVudFxuKTogYm9vbGVhbiA9PiB7XG4gIC8vIHNlZ21lbnQgaXMgZWl0aGVyIEFycmF5IG9yIHN0cmluZ1xuICBpZiAodHlwZW9mIGV4aXN0aW5nU2VnbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHNlZ21lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBDb21tb24gY2FzZTogc2VnbWVudCBpcyBqdXN0IGEgc3RyaW5nXG4gICAgICByZXR1cm4gZXhpc3RpbmdTZWdtZW50ID09PSBzZWdtZW50XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKHR5cGVvZiBzZWdtZW50ID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHJldHVybiBleGlzdGluZ1NlZ21lbnRbMF0gPT09IHNlZ21lbnRbMF0gJiYgZXhpc3RpbmdTZWdtZW50WzFdID09PSBzZWdtZW50WzFdXG59XG4iXSwibmFtZXMiOlsibWF0Y2hTZWdtZW50IiwiZXhpc3RpbmdTZWdtZW50Iiwic2VnbWVudCJdLCJtYXBwaW5ncyI6Ijs7OytCQUVhQSxnQkFBQUE7OztlQUFBQTs7O0FBQU4sTUFBTUEsZUFBZSxDQUMxQkMsaUJBQ0FDO0lBRUEsb0NBQW9DO0lBQ3BDLElBQUksT0FBT0Qsb0JBQW9CLFVBQVU7UUFDdkMsSUFBSSxPQUFPQyxZQUFZLFVBQVU7WUFDL0Isd0NBQXdDO1lBQ3hDLE9BQU9ELG9CQUFvQkM7UUFDN0I7UUFDQSxPQUFPO0lBQ1Q7SUFFQSxJQUFJLE9BQU9BLFlBQVksVUFBVTtRQUMvQixPQUFPO0lBQ1Q7SUFDQSxPQUFPRCxlQUFlLENBQUMsRUFBRSxLQUFLQyxPQUFPLENBQUMsRUFBRSxJQUFJRCxlQUFlLENBQUMsRUFBRSxLQUFLQyxPQUFPLENBQUMsRUFBRTtBQUMvRSIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAzNjIzLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2ZpbGwtbGF6eS1pdGVtcy10aWxsLWxlYWYtd2l0aC1oZWFkLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgQ2FjaGVOb2RlIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgdHlwZSB7XG4gIEZsaWdodFJvdXRlclN0YXRlLFxuICBDYWNoZU5vZGVTZWVkRGF0YSxcbn0gZnJvbSAnLi4vLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvdHlwZXMnXG5pbXBvcnQgeyBjcmVhdGVSb3V0ZXJDYWNoZUtleSB9IGZyb20gJy4vY3JlYXRlLXJvdXRlci1jYWNoZS1rZXknXG5pbXBvcnQge1xuICBQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMsXG4gIHR5cGUgUHJlZmV0Y2hDYWNoZUVudHJ5LFxufSBmcm9tICcuL3JvdXRlci1yZWR1Y2VyLXR5cGVzJ1xuXG5leHBvcnQgZnVuY3Rpb24gZmlsbExhenlJdGVtc1RpbGxMZWFmV2l0aEhlYWQoXG4gIG5hdmlnYXRlZEF0OiBudW1iZXIsXG4gIG5ld0NhY2hlOiBDYWNoZU5vZGUsXG4gIGV4aXN0aW5nQ2FjaGU6IENhY2hlTm9kZSB8IHVuZGVmaW5lZCxcbiAgcm91dGVyU3RhdGU6IEZsaWdodFJvdXRlclN0YXRlLFxuICBjYWNoZU5vZGVTZWVkRGF0YTogQ2FjaGVOb2RlU2VlZERhdGEgfCBudWxsLFxuICBoZWFkOiBSZWFjdC5SZWFjdE5vZGUsXG4gIHByZWZldGNoRW50cnk6IFByZWZldGNoQ2FjaGVFbnRyeSB8IHVuZGVmaW5lZFxuKTogdm9pZCB7XG4gIGNvbnN0IGlzTGFzdFNlZ21lbnQgPSBPYmplY3Qua2V5cyhyb3V0ZXJTdGF0ZVsxXSkubGVuZ3RoID09PSAwXG4gIGlmIChpc0xhc3RTZWdtZW50KSB7XG4gICAgbmV3Q2FjaGUuaGVhZCA9IGhlYWRcbiAgICByZXR1cm5cbiAgfVxuICAvLyBSZW1vdmUgc2VnbWVudCB0aGF0IHdlIGdvdCBkYXRhIGZvciBzbyB0aGF0IGl0IGlzIGZpbGxlZCBpbiBkdXJpbmcgcmVuZGVyaW5nIG9mIHJzYy5cbiAgZm9yIChjb25zdCBrZXkgaW4gcm91dGVyU3RhdGVbMV0pIHtcbiAgICBjb25zdCBwYXJhbGxlbFJvdXRlU3RhdGUgPSByb3V0ZXJTdGF0ZVsxXVtrZXldXG4gICAgY29uc3Qgc2VnbWVudEZvclBhcmFsbGVsUm91dGUgPSBwYXJhbGxlbFJvdXRlU3RhdGVbMF1cbiAgICBjb25zdCBjYWNoZUtleSA9IGNyZWF0ZVJvdXRlckNhY2hlS2V5KHNlZ21lbnRGb3JQYXJhbGxlbFJvdXRlKVxuXG4gICAgLy8gVE9ETzogV2Ugc2hvdWxkIHRyYXZlcnNlIHRoZSBjYWNoZU5vZGVTZWVkRGF0YSB0cmVlIGluc3RlYWQgb2YgdGhlIHJvdXRlclxuICAgIC8vIHN0YXRlIHRyZWUuIElkZWFsbHksIHRoZXkgd291bGQgYWx3YXlzIGJlIHRoZSBzYW1lIHNoYXBlLCBidXQgYmVjYXVzZSBvZlxuICAgIC8vIHRoZSBsb2FkaW5nLmpzIHBhdHRlcm4sIGNhY2hlTm9kZVNlZWREYXRhIHNvbWV0aW1lcyBvbmx5IHJlcHJlc2VudHMgYVxuICAgIC8vIHBhcnRpYWwgdHJlZS4gVGhhdCdzIHdoeSB0aGlzIG5vZGUgaXMgc29tZXRpbWVzIG51bGwuIE9uY2UgUFBSIGxhbmRzLFxuICAgIC8vIGxvYWRpbmcuanMgd2lsbCBubyBsb25nZXIgaGF2ZSBzcGVjaWFsIGJlaGF2aW9yIGFuZCB3ZSBjYW4gdHJhdmVyc2UgdGhlXG4gICAgLy8gZGF0YSB0cmVlIGluc3RlYWQuXG4gICAgLy9cbiAgICAvLyBXZSBzaG91bGQgYWxzbyBjb25zaWRlciBtZXJnaW5nIHRoZSByb3V0ZXIgc3RhdGUgdHJlZSBhbmQgdGhlIGRhdGEgdHJlZVxuICAgIC8vIGluIHRoZSByZXNwb25zZSBmb3JtYXQsIHNvIHRoYXQgd2UgZG9uJ3QgaGF2ZSB0byBzZW5kIHRoZSBrZXlzIHR3aWNlLlxuICAgIC8vIFRoZW4gdGhlIGNsaWVudCBjYW4gY29udmVydCB0aGVtIGludG8gc2VwYXJhdGUgcmVwcmVzZW50YXRpb25zLlxuICAgIGNvbnN0IHBhcmFsbGVsU2VlZERhdGEgPVxuICAgICAgY2FjaGVOb2RlU2VlZERhdGEgIT09IG51bGwgJiYgY2FjaGVOb2RlU2VlZERhdGFbMl1ba2V5XSAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gY2FjaGVOb2RlU2VlZERhdGFbMl1ba2V5XVxuICAgICAgICA6IG51bGxcbiAgICBpZiAoZXhpc3RpbmdDYWNoZSkge1xuICAgICAgY29uc3QgZXhpc3RpbmdQYXJhbGxlbFJvdXRlc0NhY2hlTm9kZSA9XG4gICAgICAgIGV4aXN0aW5nQ2FjaGUucGFyYWxsZWxSb3V0ZXMuZ2V0KGtleSlcbiAgICAgIGlmIChleGlzdGluZ1BhcmFsbGVsUm91dGVzQ2FjaGVOb2RlKSB7XG4gICAgICAgIGNvbnN0IGhhc1JldXNhYmxlUHJlZmV0Y2ggPVxuICAgICAgICAgIHByZWZldGNoRW50cnk/LmtpbmQgPT09ICdhdXRvJyAmJlxuICAgICAgICAgIHByZWZldGNoRW50cnkuc3RhdHVzID09PSBQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMucmV1c2FibGVcblxuICAgICAgICBsZXQgcGFyYWxsZWxSb3V0ZUNhY2hlTm9kZSA9IG5ldyBNYXAoZXhpc3RpbmdQYXJhbGxlbFJvdXRlc0NhY2hlTm9kZSlcbiAgICAgICAgY29uc3QgZXhpc3RpbmdDYWNoZU5vZGUgPSBwYXJhbGxlbFJvdXRlQ2FjaGVOb2RlLmdldChjYWNoZUtleSlcbiAgICAgICAgbGV0IG5ld0NhY2hlTm9kZTogQ2FjaGVOb2RlXG4gICAgICAgIGlmIChwYXJhbGxlbFNlZWREYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gTmV3IGRhdGEgd2FzIHNlbnQgZnJvbSB0aGUgc2VydmVyLlxuICAgICAgICAgIGNvbnN0IHNlZWROb2RlID0gcGFyYWxsZWxTZWVkRGF0YVsxXVxuICAgICAgICAgIGNvbnN0IGxvYWRpbmcgPSBwYXJhbGxlbFNlZWREYXRhWzNdXG4gICAgICAgICAgbmV3Q2FjaGVOb2RlID0ge1xuICAgICAgICAgICAgbGF6eURhdGE6IG51bGwsXG4gICAgICAgICAgICByc2M6IHNlZWROb2RlLFxuICAgICAgICAgICAgLy8gVGhpcyBpcyBhIFBQUi1vbmx5IGZpZWxkLiBXaGVuIFBQUiBpcyBlbmFibGVkLCB3ZSBzaG91bGRuJ3QgaGl0XG4gICAgICAgICAgICAvLyB0aGlzIHBhdGggZHVyaW5nIGEgbmF2aWdhdGlvbiwgYnV0IHVudGlsIFBQUiBpcyBmdWxseSBpbXBsZW1lbnRlZFxuICAgICAgICAgICAgLy8geWV0IGl0J3MgcG9zc2libGUgdGhlIGV4aXN0aW5nIG5vZGUgZG9lcyBoYXZlIGEgbm9uLW51bGxcbiAgICAgICAgICAgIC8vIGBwcmVmZXRjaFJzY2AuIEFzIGFuIGluY3JlbWVudGFsIHN0ZXAsIHdlJ2xsIGp1c3QgZGUtb3B0IHRvIHRoZVxuICAgICAgICAgICAgLy8gb2xkIGJlaGF2aW9yIOKAlCBubyBQUFIgdmFsdWUuXG4gICAgICAgICAgICBwcmVmZXRjaFJzYzogbnVsbCxcbiAgICAgICAgICAgIGhlYWQ6IG51bGwsXG4gICAgICAgICAgICBwcmVmZXRjaEhlYWQ6IG51bGwsXG4gICAgICAgICAgICBsb2FkaW5nLFxuICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IG5ldyBNYXAoZXhpc3RpbmdDYWNoZU5vZGU/LnBhcmFsbGVsUm91dGVzKSxcbiAgICAgICAgICAgIG5hdmlnYXRlZEF0LFxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChoYXNSZXVzYWJsZVByZWZldGNoICYmIGV4aXN0aW5nQ2FjaGVOb2RlKSB7XG4gICAgICAgICAgLy8gTm8gbmV3IGRhdGEgd2FzIHNlbnQgZnJvbSB0aGUgc2VydmVyLCBidXQgdGhlIGV4aXN0aW5nIGNhY2hlIG5vZGVcbiAgICAgICAgICAvLyB3YXMgcHJlZmV0Y2hlZCwgc28gd2Ugc2hvdWxkIHJldXNlIHRoYXQuXG4gICAgICAgICAgbmV3Q2FjaGVOb2RlID0ge1xuICAgICAgICAgICAgbGF6eURhdGE6IGV4aXN0aW5nQ2FjaGVOb2RlLmxhenlEYXRhLFxuICAgICAgICAgICAgcnNjOiBleGlzdGluZ0NhY2hlTm9kZS5yc2MsXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgUFBSLW9ubHkgZmllbGQuIFVubGlrZSB0aGUgcHJldmlvdXMgYnJhbmNoLCBzaW5jZSB3ZSdyZVxuICAgICAgICAgICAgLy8ganVzdCBjbG9uaW5nIHRoZSBleGlzdGluZyBjYWNoZSBub2RlLCB3ZSBtaWdodCBhcyB3ZWxsIGtlZXAgdGhlXG4gICAgICAgICAgICAvLyBQUFIgdmFsdWUsIGlmIGl0IGV4aXN0cy5cbiAgICAgICAgICAgIHByZWZldGNoUnNjOiBleGlzdGluZ0NhY2hlTm9kZS5wcmVmZXRjaFJzYyxcbiAgICAgICAgICAgIGhlYWQ6IGV4aXN0aW5nQ2FjaGVOb2RlLmhlYWQsXG4gICAgICAgICAgICBwcmVmZXRjaEhlYWQ6IGV4aXN0aW5nQ2FjaGVOb2RlLnByZWZldGNoSGVhZCxcbiAgICAgICAgICAgIHBhcmFsbGVsUm91dGVzOiBuZXcgTWFwKGV4aXN0aW5nQ2FjaGVOb2RlLnBhcmFsbGVsUm91dGVzKSxcbiAgICAgICAgICAgIGxvYWRpbmc6IGV4aXN0aW5nQ2FjaGVOb2RlLmxvYWRpbmcsXG4gICAgICAgICAgfSBhcyBDYWNoZU5vZGVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBObyBkYXRhIGF2YWlsYWJsZSBmb3IgdGhpcyBub2RlLiBUaGlzIHdpbGwgdHJpZ2dlciBhIGxhenkgZmV0Y2hcbiAgICAgICAgICAvLyBkdXJpbmcgcmVuZGVyLlxuICAgICAgICAgIG5ld0NhY2hlTm9kZSA9IHtcbiAgICAgICAgICAgIGxhenlEYXRhOiBudWxsLFxuICAgICAgICAgICAgcnNjOiBudWxsLFxuICAgICAgICAgICAgcHJlZmV0Y2hSc2M6IG51bGwsXG4gICAgICAgICAgICBoZWFkOiBudWxsLFxuICAgICAgICAgICAgcHJlZmV0Y2hIZWFkOiBudWxsLFxuICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IG5ldyBNYXAoZXhpc3RpbmdDYWNoZU5vZGU/LnBhcmFsbGVsUm91dGVzKSxcbiAgICAgICAgICAgIGxvYWRpbmc6IG51bGwsXG4gICAgICAgICAgICBuYXZpZ2F0ZWRBdCxcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPdmVycmlkZXMgdGhlIGNhY2hlIGtleSB3aXRoIHRoZSBuZXcgY2FjaGUgbm9kZS5cbiAgICAgICAgcGFyYWxsZWxSb3V0ZUNhY2hlTm9kZS5zZXQoY2FjaGVLZXksIG5ld0NhY2hlTm9kZSlcbiAgICAgICAgLy8gVHJhdmVyc2UgZGVlcGVyIHRvIGFwcGx5IHRoZSBoZWFkIC8gZmlsbCBsYXp5IGl0ZW1zIHRpbGwgdGhlIGhlYWQuXG4gICAgICAgIGZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkKFxuICAgICAgICAgIG5hdmlnYXRlZEF0LFxuICAgICAgICAgIG5ld0NhY2hlTm9kZSxcbiAgICAgICAgICBleGlzdGluZ0NhY2hlTm9kZSxcbiAgICAgICAgICBwYXJhbGxlbFJvdXRlU3RhdGUsXG4gICAgICAgICAgcGFyYWxsZWxTZWVkRGF0YSA/IHBhcmFsbGVsU2VlZERhdGEgOiBudWxsLFxuICAgICAgICAgIGhlYWQsXG4gICAgICAgICAgcHJlZmV0Y2hFbnRyeVxuICAgICAgICApXG5cbiAgICAgICAgbmV3Q2FjaGUucGFyYWxsZWxSb3V0ZXMuc2V0KGtleSwgcGFyYWxsZWxSb3V0ZUNhY2hlTm9kZSlcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgbmV3Q2FjaGVOb2RlOiBDYWNoZU5vZGVcbiAgICBpZiAocGFyYWxsZWxTZWVkRGF0YSAhPT0gbnVsbCkge1xuICAgICAgLy8gTmV3IGRhdGEgd2FzIHNlbnQgZnJvbSB0aGUgc2VydmVyLlxuICAgICAgY29uc3Qgc2VlZE5vZGUgPSBwYXJhbGxlbFNlZWREYXRhWzFdXG4gICAgICBjb25zdCBsb2FkaW5nID0gcGFyYWxsZWxTZWVkRGF0YVszXVxuICAgICAgbmV3Q2FjaGVOb2RlID0ge1xuICAgICAgICBsYXp5RGF0YTogbnVsbCxcbiAgICAgICAgcnNjOiBzZWVkTm9kZSxcbiAgICAgICAgcHJlZmV0Y2hSc2M6IG51bGwsXG4gICAgICAgIGhlYWQ6IG51bGwsXG4gICAgICAgIHByZWZldGNoSGVhZDogbnVsbCxcbiAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IG5ldyBNYXAoKSxcbiAgICAgICAgbG9hZGluZyxcbiAgICAgICAgbmF2aWdhdGVkQXQsXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5vIGRhdGEgYXZhaWxhYmxlIGZvciB0aGlzIG5vZGUuIFRoaXMgd2lsbCB0cmlnZ2VyIGEgbGF6eSBmZXRjaFxuICAgICAgLy8gZHVyaW5nIHJlbmRlci5cbiAgICAgIG5ld0NhY2hlTm9kZSA9IHtcbiAgICAgICAgbGF6eURhdGE6IG51bGwsXG4gICAgICAgIHJzYzogbnVsbCxcbiAgICAgICAgcHJlZmV0Y2hSc2M6IG51bGwsXG4gICAgICAgIGhlYWQ6IG51bGwsXG4gICAgICAgIHByZWZldGNoSGVhZDogbnVsbCxcbiAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IG5ldyBNYXAoKSxcbiAgICAgICAgbG9hZGluZzogbnVsbCxcbiAgICAgICAgbmF2aWdhdGVkQXQsXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZXhpc3RpbmdQYXJhbGxlbFJvdXRlcyA9IG5ld0NhY2hlLnBhcmFsbGVsUm91dGVzLmdldChrZXkpXG4gICAgaWYgKGV4aXN0aW5nUGFyYWxsZWxSb3V0ZXMpIHtcbiAgICAgIGV4aXN0aW5nUGFyYWxsZWxSb3V0ZXMuc2V0KGNhY2hlS2V5LCBuZXdDYWNoZU5vZGUpXG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0NhY2hlLnBhcmFsbGVsUm91dGVzLnNldChrZXksIG5ldyBNYXAoW1tjYWNoZUtleSwgbmV3Q2FjaGVOb2RlXV0pKVxuICAgIH1cblxuICAgIGZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkKFxuICAgICAgbmF2aWdhdGVkQXQsXG4gICAgICBuZXdDYWNoZU5vZGUsXG4gICAgICB1bmRlZmluZWQsXG4gICAgICBwYXJhbGxlbFJvdXRlU3RhdGUsXG4gICAgICBwYXJhbGxlbFNlZWREYXRhLFxuICAgICAgaGVhZCxcbiAgICAgIHByZWZldGNoRW50cnlcbiAgICApXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJmaWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZCIsIm5hdmlnYXRlZEF0IiwibmV3Q2FjaGUiLCJleGlzdGluZ0NhY2hlIiwicm91dGVyU3RhdGUiLCJjYWNoZU5vZGVTZWVkRGF0YSIsImhlYWQiLCJwcmVmZXRjaEVudHJ5IiwiaXNMYXN0U2VnbWVudCIsIk9iamVjdCIsImtleXMiLCJsZW5ndGgiLCJrZXkiLCJwYXJhbGxlbFJvdXRlU3RhdGUiLCJzZWdtZW50Rm9yUGFyYWxsZWxSb3V0ZSIsImNhY2hlS2V5IiwiY3JlYXRlUm91dGVyQ2FjaGVLZXkiLCJwYXJhbGxlbFNlZWREYXRhIiwidW5kZWZpbmVkIiwiZXhpc3RpbmdQYXJhbGxlbFJvdXRlc0NhY2hlTm9kZSIsInBhcmFsbGVsUm91dGVzIiwiZ2V0IiwiaGFzUmV1c2FibGVQcmVmZXRjaCIsImtpbmQiLCJzdGF0dXMiLCJQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMiLCJyZXVzYWJsZSIsInBhcmFsbGVsUm91dGVDYWNoZU5vZGUiLCJNYXAiLCJleGlzdGluZ0NhY2hlTm9kZSIsIm5ld0NhY2hlTm9kZSIsInNlZWROb2RlIiwibG9hZGluZyIsImxhenlEYXRhIiwicnNjIiwicHJlZmV0Y2hSc2MiLCJwcmVmZXRjaEhlYWQiLCJzZXQiLCJleGlzdGluZ1BhcmFsbGVsUm91dGVzIl0sIm1hcHBpbmdzIjoiOzs7K0JBV2dCQSxpQ0FBQUE7OztlQUFBQTs7O3NDQU5xQjtvQ0FJOUI7QUFFQSxTQUFTQSw4QkFDZEMsV0FBbUIsRUFDbkJDLFFBQW1CLEVBQ25CQyxhQUFvQyxFQUNwQ0MsV0FBOEIsRUFDOUJDLGlCQUEyQyxFQUMzQ0MsSUFBcUIsRUFDckJDLGFBQTZDO0lBRTdDLE1BQU1DLGdCQUFnQkMsT0FBT0MsSUFBSSxDQUFDTixXQUFXLENBQUMsRUFBRSxFQUFFTyxNQUFNLEtBQUs7SUFDN0QsSUFBSUgsZUFBZTtRQUNqQk4sU0FBU0ksSUFBSSxHQUFHQTtRQUNoQjtJQUNGO0lBQ0EsdUZBQXVGO0lBQ3ZGLElBQUssTUFBTU0sT0FBT1IsV0FBVyxDQUFDLEVBQUUsQ0FBRTtRQUNoQyxNQUFNUyxxQkFBcUJULFdBQVcsQ0FBQyxFQUFFLENBQUNRLElBQUk7UUFDOUMsTUFBTUUsMEJBQTBCRCxrQkFBa0IsQ0FBQyxFQUFFO1FBQ3JELE1BQU1FLFdBQVdDLENBQUFBLEdBQUFBLHNCQUFBQSxvQkFBb0IsRUFBQ0Y7UUFFdEMsNEVBQTRFO1FBQzVFLDJFQUEyRTtRQUMzRSx3RUFBd0U7UUFDeEUsd0VBQXdFO1FBQ3hFLDBFQUEwRTtRQUMxRSxxQkFBcUI7UUFDckIsRUFBRTtRQUNGLDBFQUEwRTtRQUMxRSx3RUFBd0U7UUFDeEUsa0VBQWtFO1FBQ2xFLE1BQU1HLG1CQUNKWixzQkFBc0IsUUFBUUEsaUJBQWlCLENBQUMsRUFBRSxDQUFDTyxJQUFJLEtBQUtNLFlBQ3hEYixpQkFBaUIsQ0FBQyxFQUFFLENBQUNPLElBQUksR0FDekI7UUFDTixJQUFJVCxlQUFlO1lBQ2pCLE1BQU1nQixrQ0FDSmhCLGNBQWNpQixjQUFjLENBQUNDLEdBQUcsQ0FBQ1Q7WUFDbkMsSUFBSU8saUNBQWlDO2dCQUNuQyxNQUFNRyxzQkFDSmYsQ0FBQUEsaUJBQUFBLE9BQUFBLEtBQUFBLElBQUFBLGNBQWVnQixJQUFJLE1BQUssVUFDeEJoQixjQUFjaUIsTUFBTSxLQUFLQyxvQkFBQUEsd0JBQXdCLENBQUNDLFFBQVE7Z0JBRTVELElBQUlDLHlCQUF5QixJQUFJQyxJQUFJVDtnQkFDckMsTUFBTVUsb0JBQW9CRix1QkFBdUJOLEdBQUcsQ0FBQ047Z0JBQ3JELElBQUllO2dCQUNKLElBQUliLHFCQUFxQixNQUFNO29CQUM3QixxQ0FBcUM7b0JBQ3JDLE1BQU1jLFdBQVdkLGdCQUFnQixDQUFDLEVBQUU7b0JBQ3BDLE1BQU1lLFVBQVVmLGdCQUFnQixDQUFDLEVBQUU7b0JBQ25DYSxlQUFlO3dCQUNiRyxVQUFVO3dCQUNWQyxLQUFLSDt3QkFDTCxrRUFBa0U7d0JBQ2xFLG9FQUFvRTt3QkFDcEUsMkRBQTJEO3dCQUMzRCxrRUFBa0U7d0JBQ2xFLCtCQUErQjt3QkFDL0JJLGFBQWE7d0JBQ2I3QixNQUFNO3dCQUNOOEIsY0FBYzt3QkFDZEo7d0JBQ0FaLGdCQUFnQixJQUFJUSxJQUFJQyxxQkFBQUEsT0FBQUEsS0FBQUEsSUFBQUEsa0JBQW1CVCxjQUFjO3dCQUN6RG5CO29CQUNGO2dCQUNGLE9BQU8sSUFBSXFCLHVCQUF1Qk8sbUJBQW1CO29CQUNuRCxvRUFBb0U7b0JBQ3BFLDJDQUEyQztvQkFDM0NDLGVBQWU7d0JBQ2JHLFVBQVVKLGtCQUFrQkksUUFBUTt3QkFDcENDLEtBQUtMLGtCQUFrQkssR0FBRzt3QkFDMUIsb0VBQW9FO3dCQUNwRSxrRUFBa0U7d0JBQ2xFLDJCQUEyQjt3QkFDM0JDLGFBQWFOLGtCQUFrQk0sV0FBVzt3QkFDMUM3QixNQUFNdUIsa0JBQWtCdkIsSUFBSTt3QkFDNUI4QixjQUFjUCxrQkFBa0JPLFlBQVk7d0JBQzVDaEIsZ0JBQWdCLElBQUlRLElBQUlDLGtCQUFrQlQsY0FBYzt3QkFDeERZLFNBQVNILGtCQUFrQkcsT0FBTztvQkFDcEM7Z0JBQ0YsT0FBTztvQkFDTCxrRUFBa0U7b0JBQ2xFLGlCQUFpQjtvQkFDakJGLGVBQWU7d0JBQ2JHLFVBQVU7d0JBQ1ZDLEtBQUs7d0JBQ0xDLGFBQWE7d0JBQ2I3QixNQUFNO3dCQUNOOEIsY0FBYzt3QkFDZGhCLGdCQUFnQixJQUFJUSxJQUFJQyxxQkFBQUEsT0FBQUEsS0FBQUEsSUFBQUEsa0JBQW1CVCxjQUFjO3dCQUN6RFksU0FBUzt3QkFDVC9CO29CQUNGO2dCQUNGO2dCQUVBLG1EQUFtRDtnQkFDbkQwQix1QkFBdUJVLEdBQUcsQ0FBQ3RCLFVBQVVlO2dCQUNyQyxxRUFBcUU7Z0JBQ3JFOUIsOEJBQ0VDLGFBQ0E2QixjQUNBRCxtQkFDQWhCLG9CQUNBSSxtQkFBbUJBLG1CQUFtQixNQUN0Q1gsTUFDQUM7Z0JBR0ZMLFNBQVNrQixjQUFjLENBQUNpQixHQUFHLENBQUN6QixLQUFLZTtnQkFDakM7WUFDRjtRQUNGO1FBRUEsSUFBSUc7UUFDSixJQUFJYixxQkFBcUIsTUFBTTtZQUM3QixxQ0FBcUM7WUFDckMsTUFBTWMsV0FBV2QsZ0JBQWdCLENBQUMsRUFBRTtZQUNwQyxNQUFNZSxVQUFVZixnQkFBZ0IsQ0FBQyxFQUFFO1lBQ25DYSxlQUFlO2dCQUNiRyxVQUFVO2dCQUNWQyxLQUFLSDtnQkFDTEksYUFBYTtnQkFDYjdCLE1BQU07Z0JBQ044QixjQUFjO2dCQUNkaEIsZ0JBQWdCLElBQUlRO2dCQUNwQkk7Z0JBQ0EvQjtZQUNGO1FBQ0YsT0FBTztZQUNMLGtFQUFrRTtZQUNsRSxpQkFBaUI7WUFDakI2QixlQUFlO2dCQUNiRyxVQUFVO2dCQUNWQyxLQUFLO2dCQUNMQyxhQUFhO2dCQUNiN0IsTUFBTTtnQkFDTjhCLGNBQWM7Z0JBQ2RoQixnQkFBZ0IsSUFBSVE7Z0JBQ3BCSSxTQUFTO2dCQUNUL0I7WUFDRjtRQUNGO1FBRUEsTUFBTXFDLHlCQUF5QnBDLFNBQVNrQixjQUFjLENBQUNDLEdBQUcsQ0FBQ1Q7UUFDM0QsSUFBSTBCLHdCQUF3QjtZQUMxQkEsdUJBQXVCRCxHQUFHLENBQUN0QixVQUFVZTtRQUN2QyxPQUFPO1lBQ0w1QixTQUFTa0IsY0FBYyxDQUFDaUIsR0FBRyxDQUFDekIsS0FBSyxJQUFJZ0IsSUFBSTtnQkFBQztvQkFBQ2I7b0JBQVVlO2lCQUFhO2FBQUM7UUFDckU7UUFFQTlCLDhCQUNFQyxhQUNBNkIsY0FDQVosV0FDQUwsb0JBQ0FJLGtCQUNBWCxNQUNBQztJQUVKO0FBQ0YiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMzc3NSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9pbnZhbGlkYXRlLWNhY2hlLWJ5LXJvdXRlci1zdGF0ZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IENhY2hlTm9kZSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHR5cGUgeyBGbGlnaHRSb3V0ZXJTdGF0ZSB9IGZyb20gJy4uLy4uLy4uL3NlcnZlci9hcHAtcmVuZGVyL3R5cGVzJ1xuaW1wb3J0IHsgY3JlYXRlUm91dGVyQ2FjaGVLZXkgfSBmcm9tICcuL2NyZWF0ZS1yb3V0ZXItY2FjaGUta2V5J1xuXG4vKipcbiAqIEludmFsaWRhdGUgY2FjaGUgb25lIGxldmVsIGRvd24gZnJvbSB0aGUgcm91dGVyIHN0YXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW52YWxpZGF0ZUNhY2hlQnlSb3V0ZXJTdGF0ZShcbiAgbmV3Q2FjaGU6IENhY2hlTm9kZSxcbiAgZXhpc3RpbmdDYWNoZTogQ2FjaGVOb2RlLFxuICByb3V0ZXJTdGF0ZTogRmxpZ2h0Um91dGVyU3RhdGVcbik6IHZvaWQge1xuICAvLyBSZW1vdmUgc2VnbWVudCB0aGF0IHdlIGdvdCBkYXRhIGZvciBzbyB0aGF0IGl0IGlzIGZpbGxlZCBpbiBkdXJpbmcgcmVuZGVyaW5nIG9mIHJzYy5cbiAgZm9yIChjb25zdCBrZXkgaW4gcm91dGVyU3RhdGVbMV0pIHtcbiAgICBjb25zdCBzZWdtZW50Rm9yUGFyYWxsZWxSb3V0ZSA9IHJvdXRlclN0YXRlWzFdW2tleV1bMF1cbiAgICBjb25zdCBjYWNoZUtleSA9IGNyZWF0ZVJvdXRlckNhY2hlS2V5KHNlZ21lbnRGb3JQYXJhbGxlbFJvdXRlKVxuICAgIGNvbnN0IGV4aXN0aW5nUGFyYWxsZWxSb3V0ZXNDYWNoZU5vZGUgPVxuICAgICAgZXhpc3RpbmdDYWNoZS5wYXJhbGxlbFJvdXRlcy5nZXQoa2V5KVxuICAgIGlmIChleGlzdGluZ1BhcmFsbGVsUm91dGVzQ2FjaGVOb2RlKSB7XG4gICAgICBsZXQgcGFyYWxsZWxSb3V0ZUNhY2hlTm9kZSA9IG5ldyBNYXAoZXhpc3RpbmdQYXJhbGxlbFJvdXRlc0NhY2hlTm9kZSlcbiAgICAgIHBhcmFsbGVsUm91dGVDYWNoZU5vZGUuZGVsZXRlKGNhY2hlS2V5KVxuICAgICAgbmV3Q2FjaGUucGFyYWxsZWxSb3V0ZXMuc2V0KGtleSwgcGFyYWxsZWxSb3V0ZUNhY2hlTm9kZSlcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJpbnZhbGlkYXRlQ2FjaGVCeVJvdXRlclN0YXRlIiwibmV3Q2FjaGUiLCJleGlzdGluZ0NhY2hlIiwicm91dGVyU3RhdGUiLCJrZXkiLCJzZWdtZW50Rm9yUGFyYWxsZWxSb3V0ZSIsImNhY2hlS2V5IiwiY3JlYXRlUm91dGVyQ2FjaGVLZXkiLCJleGlzdGluZ1BhcmFsbGVsUm91dGVzQ2FjaGVOb2RlIiwicGFyYWxsZWxSb3V0ZXMiLCJnZXQiLCJwYXJhbGxlbFJvdXRlQ2FjaGVOb2RlIiwiTWFwIiwiZGVsZXRlIiwic2V0Il0sIm1hcHBpbmdzIjoiOzs7K0JBT2dCQSxnQ0FBQUE7OztlQUFBQTs7O3NDQUxxQjtBQUs5QixTQUFTQSw2QkFDZEMsUUFBbUIsRUFDbkJDLGFBQXdCLEVBQ3hCQyxXQUE4QjtJQUU5Qix1RkFBdUY7SUFDdkYsSUFBSyxNQUFNQyxPQUFPRCxXQUFXLENBQUMsRUFBRSxDQUFFO1FBQ2hDLE1BQU1FLDBCQUEwQkYsV0FBVyxDQUFDLEVBQUUsQ0FBQ0MsSUFBSSxDQUFDLEVBQUU7UUFDdEQsTUFBTUUsV0FBV0MsQ0FBQUEsR0FBQUEsc0JBQUFBLG9CQUFvQixFQUFDRjtRQUN0QyxNQUFNRyxrQ0FDSk4sY0FBY08sY0FBYyxDQUFDQyxHQUFHLENBQUNOO1FBQ25DLElBQUlJLGlDQUFpQztZQUNuQyxJQUFJRyx5QkFBeUIsSUFBSUMsSUFBSUo7WUFDckNHLHVCQUF1QkUsTUFBTSxDQUFDUDtZQUM5QkwsU0FBU1EsY0FBYyxDQUFDSyxHQUFHLENBQUNWLEtBQUtPO1FBQ25DO0lBQ0Y7QUFDRiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAzODExLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2ZpbGwtY2FjaGUtd2l0aC1uZXctc3VidHJlZS1kYXRhLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgQ2FjaGVOb2RlIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgdHlwZSB7IFNlZ21lbnQgfSBmcm9tICcuLi8uLi8uLi9zZXJ2ZXIvYXBwLXJlbmRlci90eXBlcydcbmltcG9ydCB7IGludmFsaWRhdGVDYWNoZUJ5Um91dGVyU3RhdGUgfSBmcm9tICcuL2ludmFsaWRhdGUtY2FjaGUtYnktcm91dGVyLXN0YXRlJ1xuaW1wb3J0IHsgZmlsbExhenlJdGVtc1RpbGxMZWFmV2l0aEhlYWQgfSBmcm9tICcuL2ZpbGwtbGF6eS1pdGVtcy10aWxsLWxlYWYtd2l0aC1oZWFkJ1xuaW1wb3J0IHsgY3JlYXRlUm91dGVyQ2FjaGVLZXkgfSBmcm9tICcuL2NyZWF0ZS1yb3V0ZXItY2FjaGUta2V5J1xuaW1wb3J0IHR5cGUgeyBQcmVmZXRjaENhY2hlRW50cnkgfSBmcm9tICcuL3JvdXRlci1yZWR1Y2VyLXR5cGVzJ1xuaW1wb3J0IHsgUEFHRV9TRUdNRU5UX0tFWSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9saWIvc2VnbWVudCdcbmltcG9ydCB0eXBlIHsgTm9ybWFsaXplZEZsaWdodERhdGEgfSBmcm9tICcuLi8uLi9mbGlnaHQtZGF0YS1oZWxwZXJzJ1xuXG4vKipcbiAqIENvbW1vbiBsb2dpYyBmb3IgZmlsbGluZyBjYWNoZSB3aXRoIG5ldyBzdWIgdHJlZSBkYXRhLlxuICovXG5mdW5jdGlvbiBmaWxsQ2FjaGVIZWxwZXIoXG4gIG5hdmlnYXRlZEF0OiBudW1iZXIsXG4gIG5ld0NhY2hlOiBDYWNoZU5vZGUsXG4gIGV4aXN0aW5nQ2FjaGU6IENhY2hlTm9kZSxcbiAgZmxpZ2h0RGF0YTogTm9ybWFsaXplZEZsaWdodERhdGEsXG4gIHByZWZldGNoRW50cnk6IFByZWZldGNoQ2FjaGVFbnRyeSB8IHVuZGVmaW5lZCxcbiAgZmlsbExhenlJdGVtczogYm9vbGVhblxuKTogdm9pZCB7XG4gIGNvbnN0IHtcbiAgICBzZWdtZW50UGF0aCxcbiAgICBzZWVkRGF0YTogY2FjaGVOb2RlU2VlZERhdGEsXG4gICAgdHJlZTogdHJlZVBhdGNoLFxuICAgIGhlYWQsXG4gIH0gPSBmbGlnaHREYXRhXG4gIGxldCBuZXdDYWNoZU5vZGUgPSBuZXdDYWNoZVxuICBsZXQgZXhpc3RpbmdDYWNoZU5vZGUgPSBleGlzdGluZ0NhY2hlXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50UGF0aC5sZW5ndGg7IGkgKz0gMikge1xuICAgIGNvbnN0IHBhcmFsbGVsUm91dGVLZXk6IHN0cmluZyA9IHNlZ21lbnRQYXRoW2ldXG4gICAgY29uc3Qgc2VnbWVudDogU2VnbWVudCA9IHNlZ21lbnRQYXRoW2kgKyAxXVxuXG4gICAgLy8gc2VnbWVudFBhdGggaXMgYSByZXBlYXRpbmcgdHVwbGUgb2YgcGFyYWxsZWxSb3V0ZUtleSBhbmQgc2VnbWVudFxuICAgIC8vIHdlIGtub3cgd2UndmUgaGl0IHRoZSBsYXN0IGVudHJ5IHdlJ3ZlIHJlYWNoZWQgb3VyIGZpbmFsIHBhaXJcbiAgICBjb25zdCBpc0xhc3RFbnRyeSA9IGkgPT09IHNlZ21lbnRQYXRoLmxlbmd0aCAtIDJcbiAgICBjb25zdCBjYWNoZUtleSA9IGNyZWF0ZVJvdXRlckNhY2hlS2V5KHNlZ21lbnQpXG5cbiAgICBjb25zdCBleGlzdGluZ0NoaWxkU2VnbWVudE1hcCA9XG4gICAgICBleGlzdGluZ0NhY2hlTm9kZS5wYXJhbGxlbFJvdXRlcy5nZXQocGFyYWxsZWxSb3V0ZUtleSlcblxuICAgIGlmICghZXhpc3RpbmdDaGlsZFNlZ21lbnRNYXApIHtcbiAgICAgIC8vIEJhaWxvdXQgYmVjYXVzZSB0aGUgZXhpc3RpbmcgY2FjaGUgZG9lcyBub3QgaGF2ZSB0aGUgcGF0aCB0byB0aGUgbGVhZiBub2RlXG4gICAgICAvLyBXaWxsIHRyaWdnZXIgbGF6eSBmZXRjaCBpbiBsYXlvdXQtcm91dGVyIGJlY2F1c2Ugb2YgbWlzc2luZyBzZWdtZW50XG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGxldCBjaGlsZFNlZ21lbnRNYXAgPSBuZXdDYWNoZU5vZGUucGFyYWxsZWxSb3V0ZXMuZ2V0KHBhcmFsbGVsUm91dGVLZXkpXG4gICAgaWYgKCFjaGlsZFNlZ21lbnRNYXAgfHwgY2hpbGRTZWdtZW50TWFwID09PSBleGlzdGluZ0NoaWxkU2VnbWVudE1hcCkge1xuICAgICAgY2hpbGRTZWdtZW50TWFwID0gbmV3IE1hcChleGlzdGluZ0NoaWxkU2VnbWVudE1hcClcbiAgICAgIG5ld0NhY2hlTm9kZS5wYXJhbGxlbFJvdXRlcy5zZXQocGFyYWxsZWxSb3V0ZUtleSwgY2hpbGRTZWdtZW50TWFwKVxuICAgIH1cblxuICAgIGNvbnN0IGV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUgPSBleGlzdGluZ0NoaWxkU2VnbWVudE1hcC5nZXQoY2FjaGVLZXkpXG4gICAgbGV0IGNoaWxkQ2FjaGVOb2RlID0gY2hpbGRTZWdtZW50TWFwLmdldChjYWNoZUtleSlcblxuICAgIGlmIChpc0xhc3RFbnRyeSkge1xuICAgICAgaWYgKFxuICAgICAgICBjYWNoZU5vZGVTZWVkRGF0YSAmJlxuICAgICAgICAoIWNoaWxkQ2FjaGVOb2RlIHx8XG4gICAgICAgICAgIWNoaWxkQ2FjaGVOb2RlLmxhenlEYXRhIHx8XG4gICAgICAgICAgY2hpbGRDYWNoZU5vZGUgPT09IGV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUpXG4gICAgICApIHtcbiAgICAgICAgY29uc3QgaW5jb21pbmdTZWdtZW50ID0gY2FjaGVOb2RlU2VlZERhdGFbMF1cbiAgICAgICAgY29uc3QgcnNjID0gY2FjaGVOb2RlU2VlZERhdGFbMV1cbiAgICAgICAgY29uc3QgbG9hZGluZyA9IGNhY2hlTm9kZVNlZWREYXRhWzNdXG5cbiAgICAgICAgY2hpbGRDYWNoZU5vZGUgPSB7XG4gICAgICAgICAgbGF6eURhdGE6IG51bGwsXG4gICAgICAgICAgLy8gV2hlbiBgZmlsbExhenlJdGVtc2AgaXMgZmFsc2UsIHdlIG9ubHkgd2FudCB0byBmaWxsIHRoZSBSU0MgZGF0YSBmb3IgdGhlIGxheW91dCxcbiAgICAgICAgICAvLyBub3QgdGhlIHBhZ2Ugc2VnbWVudC5cbiAgICAgICAgICByc2M6XG4gICAgICAgICAgICBmaWxsTGF6eUl0ZW1zIHx8IGluY29taW5nU2VnbWVudCAhPT0gUEFHRV9TRUdNRU5UX0tFWSA/IHJzYyA6IG51bGwsXG4gICAgICAgICAgcHJlZmV0Y2hSc2M6IG51bGwsXG4gICAgICAgICAgaGVhZDogbnVsbCxcbiAgICAgICAgICBwcmVmZXRjaEhlYWQ6IG51bGwsXG4gICAgICAgICAgbG9hZGluZyxcbiAgICAgICAgICBwYXJhbGxlbFJvdXRlczpcbiAgICAgICAgICAgIGZpbGxMYXp5SXRlbXMgJiYgZXhpc3RpbmdDaGlsZENhY2hlTm9kZVxuICAgICAgICAgICAgICA/IG5ldyBNYXAoZXhpc3RpbmdDaGlsZENhY2hlTm9kZS5wYXJhbGxlbFJvdXRlcylcbiAgICAgICAgICAgICAgOiBuZXcgTWFwKCksXG4gICAgICAgICAgbmF2aWdhdGVkQXQsXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXhpc3RpbmdDaGlsZENhY2hlTm9kZSAmJiBmaWxsTGF6eUl0ZW1zKSB7XG4gICAgICAgICAgaW52YWxpZGF0ZUNhY2hlQnlSb3V0ZXJTdGF0ZShcbiAgICAgICAgICAgIGNoaWxkQ2FjaGVOb2RlLFxuICAgICAgICAgICAgZXhpc3RpbmdDaGlsZENhY2hlTm9kZSxcbiAgICAgICAgICAgIHRyZWVQYXRjaFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlsbExhenlJdGVtcykge1xuICAgICAgICAgIGZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkKFxuICAgICAgICAgICAgbmF2aWdhdGVkQXQsXG4gICAgICAgICAgICBjaGlsZENhY2hlTm9kZSxcbiAgICAgICAgICAgIGV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUsXG4gICAgICAgICAgICB0cmVlUGF0Y2gsXG4gICAgICAgICAgICBjYWNoZU5vZGVTZWVkRGF0YSxcbiAgICAgICAgICAgIGhlYWQsXG4gICAgICAgICAgICBwcmVmZXRjaEVudHJ5XG4gICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGRTZWdtZW50TWFwLnNldChjYWNoZUtleSwgY2hpbGRDYWNoZU5vZGUpXG4gICAgICB9XG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGlmICghY2hpbGRDYWNoZU5vZGUgfHwgIWV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUpIHtcbiAgICAgIC8vIEJhaWxvdXQgYmVjYXVzZSB0aGUgZXhpc3RpbmcgY2FjaGUgZG9lcyBub3QgaGF2ZSB0aGUgcGF0aCB0byB0aGUgbGVhZiBub2RlXG4gICAgICAvLyBXaWxsIHRyaWdnZXIgbGF6eSBmZXRjaCBpbiBsYXlvdXQtcm91dGVyIGJlY2F1c2Ugb2YgbWlzc2luZyBzZWdtZW50XG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGlmIChjaGlsZENhY2hlTm9kZSA9PT0gZXhpc3RpbmdDaGlsZENhY2hlTm9kZSkge1xuICAgICAgY2hpbGRDYWNoZU5vZGUgPSB7XG4gICAgICAgIGxhenlEYXRhOiBjaGlsZENhY2hlTm9kZS5sYXp5RGF0YSxcbiAgICAgICAgcnNjOiBjaGlsZENhY2hlTm9kZS5yc2MsXG4gICAgICAgIHByZWZldGNoUnNjOiBjaGlsZENhY2hlTm9kZS5wcmVmZXRjaFJzYyxcbiAgICAgICAgaGVhZDogY2hpbGRDYWNoZU5vZGUuaGVhZCxcbiAgICAgICAgcHJlZmV0Y2hIZWFkOiBjaGlsZENhY2hlTm9kZS5wcmVmZXRjaEhlYWQsXG4gICAgICAgIHBhcmFsbGVsUm91dGVzOiBuZXcgTWFwKGNoaWxkQ2FjaGVOb2RlLnBhcmFsbGVsUm91dGVzKSxcbiAgICAgICAgbG9hZGluZzogY2hpbGRDYWNoZU5vZGUubG9hZGluZyxcbiAgICAgIH0gYXMgQ2FjaGVOb2RlXG4gICAgICBjaGlsZFNlZ21lbnRNYXAuc2V0KGNhY2hlS2V5LCBjaGlsZENhY2hlTm9kZSlcbiAgICB9XG5cbiAgICAvLyBNb3ZlIGRlZXBlciBpbnRvIHRoZSBjYWNoZSBub2Rlc1xuICAgIG5ld0NhY2hlTm9kZSA9IGNoaWxkQ2FjaGVOb2RlXG4gICAgZXhpc3RpbmdDYWNoZU5vZGUgPSBleGlzdGluZ0NoaWxkQ2FjaGVOb2RlXG4gIH1cbn1cblxuLyoqXG4gKiBGaWxsIGNhY2hlIHdpdGggcnNjIGJhc2VkIG9uIGZsaWdodERhdGFQYXRoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaWxsQ2FjaGVXaXRoTmV3U3ViVHJlZURhdGEoXG4gIG5hdmlnYXRlZEF0OiBudW1iZXIsXG4gIG5ld0NhY2hlOiBDYWNoZU5vZGUsXG4gIGV4aXN0aW5nQ2FjaGU6IENhY2hlTm9kZSxcbiAgZmxpZ2h0RGF0YTogTm9ybWFsaXplZEZsaWdodERhdGEsXG4gIHByZWZldGNoRW50cnk/OiBQcmVmZXRjaENhY2hlRW50cnlcbik6IHZvaWQge1xuICBmaWxsQ2FjaGVIZWxwZXIoXG4gICAgbmF2aWdhdGVkQXQsXG4gICAgbmV3Q2FjaGUsXG4gICAgZXhpc3RpbmdDYWNoZSxcbiAgICBmbGlnaHREYXRhLFxuICAgIHByZWZldGNoRW50cnksXG4gICAgdHJ1ZVxuICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaWxsQ2FjaGVXaXRoTmV3U3ViVHJlZURhdGFCdXRPbmx5TG9hZGluZyhcbiAgbmF2aWdhdGVkQXQ6IG51bWJlcixcbiAgbmV3Q2FjaGU6IENhY2hlTm9kZSxcbiAgZXhpc3RpbmdDYWNoZTogQ2FjaGVOb2RlLFxuICBmbGlnaHREYXRhOiBOb3JtYWxpemVkRmxpZ2h0RGF0YSxcbiAgcHJlZmV0Y2hFbnRyeT86IFByZWZldGNoQ2FjaGVFbnRyeVxuKTogdm9pZCB7XG4gIGZpbGxDYWNoZUhlbHBlcihcbiAgICBuYXZpZ2F0ZWRBdCxcbiAgICBuZXdDYWNoZSxcbiAgICBleGlzdGluZ0NhY2hlLFxuICAgIGZsaWdodERhdGEsXG4gICAgcHJlZmV0Y2hFbnRyeSxcbiAgICBmYWxzZVxuICApXG59XG4iXSwibmFtZXMiOlsiZmlsbENhY2hlV2l0aE5ld1N1YlRyZWVEYXRhIiwiZmlsbENhY2hlV2l0aE5ld1N1YlRyZWVEYXRhQnV0T25seUxvYWRpbmciLCJmaWxsQ2FjaGVIZWxwZXIiLCJuYXZpZ2F0ZWRBdCIsIm5ld0NhY2hlIiwiZXhpc3RpbmdDYWNoZSIsImZsaWdodERhdGEiLCJwcmVmZXRjaEVudHJ5IiwiZmlsbExhenlJdGVtcyIsInNlZ21lbnRQYXRoIiwic2VlZERhdGEiLCJjYWNoZU5vZGVTZWVkRGF0YSIsInRyZWUiLCJ0cmVlUGF0Y2giLCJoZWFkIiwibmV3Q2FjaGVOb2RlIiwiZXhpc3RpbmdDYWNoZU5vZGUiLCJpIiwibGVuZ3RoIiwicGFyYWxsZWxSb3V0ZUtleSIsInNlZ21lbnQiLCJpc0xhc3RFbnRyeSIsImNhY2hlS2V5IiwiY3JlYXRlUm91dGVyQ2FjaGVLZXkiLCJleGlzdGluZ0NoaWxkU2VnbWVudE1hcCIsInBhcmFsbGVsUm91dGVzIiwiZ2V0IiwiY2hpbGRTZWdtZW50TWFwIiwiTWFwIiwic2V0IiwiZXhpc3RpbmdDaGlsZENhY2hlTm9kZSIsImNoaWxkQ2FjaGVOb2RlIiwibGF6eURhdGEiLCJpbmNvbWluZ1NlZ21lbnQiLCJyc2MiLCJsb2FkaW5nIiwiUEFHRV9TRUdNRU5UX0tFWSIsInByZWZldGNoUnNjIiwicHJlZmV0Y2hIZWFkIiwiaW52YWxpZGF0ZUNhY2hlQnlSb3V0ZXJTdGF0ZSIsImZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztJQXdJZ0JBLDJCQUEyQixFQUFBO2VBQTNCQTs7SUFpQkFDLHlDQUF5QyxFQUFBO2VBQXpDQTs7OzhDQXZKNkI7K0NBQ0M7c0NBQ1Q7eUJBRUo7QUFHakM7O0NBRUMsR0FDRCxTQUFTQyxnQkFDUEMsV0FBbUIsRUFDbkJDLFFBQW1CLEVBQ25CQyxhQUF3QixFQUN4QkMsVUFBZ0MsRUFDaENDLGFBQTZDLEVBQzdDQyxhQUFzQjtJQUV0QixNQUFNLEVBQ0pDLFdBQVcsRUFDWEMsVUFBVUMsaUJBQWlCLEVBQzNCQyxNQUFNQyxTQUFTLEVBQ2ZDLElBQUksRUFDTCxHQUFHUjtJQUNKLElBQUlTLGVBQWVYO0lBQ25CLElBQUlZLG9CQUFvQlg7SUFFeEIsSUFBSyxJQUFJWSxJQUFJLEdBQUdBLElBQUlSLFlBQVlTLE1BQU0sRUFBRUQsS0FBSyxFQUFHO1FB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QyxVQUNBQyxlQUNBQyxZQUNBQyxlQUNBO0FBRUoiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMzkyNiwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9hcHBseS1mbGlnaHQtZGF0YS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IENhY2hlTm9kZSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHsgZmlsbExhenlJdGVtc1RpbGxMZWFmV2l0aEhlYWQgfSBmcm9tICcuL2ZpbGwtbGF6eS1pdGVtcy10aWxsLWxlYWYtd2l0aC1oZWFkJ1xuaW1wb3J0IHsgZmlsbENhY2hlV2l0aE5ld1N1YlRyZWVEYXRhIH0gZnJvbSAnLi9maWxsLWNhY2hlLXdpdGgtbmV3LXN1YnRyZWUtZGF0YSdcbmltcG9ydCB0eXBlIHsgUHJlZmV0Y2hDYWNoZUVudHJ5IH0gZnJvbSAnLi9yb3V0ZXItcmVkdWNlci10eXBlcydcbmltcG9ydCB0eXBlIHsgTm9ybWFsaXplZEZsaWdodERhdGEgfSBmcm9tICcuLi8uLi9mbGlnaHQtZGF0YS1oZWxwZXJzJ1xuXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlGbGlnaHREYXRhKFxuICBuYXZpZ2F0ZWRBdDogbnVtYmVyLFxuICBleGlzdGluZ0NhY2hlOiBDYWNoZU5vZGUsXG4gIGNhY2hlOiBDYWNoZU5vZGUsXG4gIGZsaWdodERhdGE6IE5vcm1hbGl6ZWRGbGlnaHREYXRhLFxuICBwcmVmZXRjaEVudHJ5PzogUHJlZmV0Y2hDYWNoZUVudHJ5XG4pOiBib29sZWFuIHtcbiAgLy8gVGhlIG9uZSBiZWZvcmUgbGFzdCBpdGVtIGlzIHRoZSByb3V0ZXIgc3RhdGUgdHJlZSBwYXRjaFxuICBjb25zdCB7IHRyZWU6IHRyZWVQYXRjaCwgc2VlZERhdGEsIGhlYWQsIGlzUm9vdFJlbmRlciB9ID0gZmxpZ2h0RGF0YVxuXG4gIC8vIEhhbmRsZXMgY2FzZSB3aGVyZSBwcmVmZXRjaCBvbmx5IHJldHVybnMgdGhlIHJvdXRlciB0cmVlIHBhdGNoIHdpdGhvdXQgcmVuZGVyZWQgY29tcG9uZW50cy5cbiAgaWYgKHNlZWREYXRhID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBpZiAoaXNSb290UmVuZGVyKSB7XG4gICAgY29uc3QgcnNjID0gc2VlZERhdGFbMV1cbiAgICBjb25zdCBsb2FkaW5nID0gc2VlZERhdGFbM11cbiAgICBjYWNoZS5sb2FkaW5nID0gbG9hZGluZ1xuICAgIGNhY2hlLnJzYyA9IHJzY1xuICAgIC8vIFRoaXMgaXMgYSBQUFItb25seSBmaWVsZC4gV2hlbiBQUFIgaXMgZW5hYmxlZCwgd2Ugc2hvdWxkbid0IGhpdFxuICAgIC8vIHRoaXMgcGF0aCBkdXJpbmcgYSBuYXZpZ2F0aW9uLCBidXQgdW50aWwgUFBSIGlzIGZ1bGx5IGltcGxlbWVudGVkXG4gICAgLy8geWV0IGl0J3MgcG9zc2libGUgdGhlIGV4aXN0aW5nIG5vZGUgZG9lcyBoYXZlIGEgbm9uLW51bGxcbiAgICAvLyBgcHJlZmV0Y2hSc2NgLiBBcyBhbiBpbmNyZW1lbnRhbCBzdGVwLCB3ZSdsbCBqdXN0IGRlLW9wdCB0byB0aGVcbiAgICAvLyBvbGQgYmVoYXZpb3Ig4oCUIG5vIFBQUiB2YWx1ZS5cbiAgICBjYWNoZS5wcmVmZXRjaFJzYyA9IG51bGxcbiAgICBmaWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZChcbiAgICAgIG5hdmlnYXRlZEF0LFxuICAgICAgY2FjaGUsXG4gICAgICBleGlzdGluZ0NhY2hlLFxuICAgICAgdHJlZVBhdGNoLFxuICAgICAgc2VlZERhdGEsXG4gICAgICBoZWFkLFxuICAgICAgcHJlZmV0Y2hFbnRyeVxuICAgIClcbiAgfSBlbHNlIHtcbiAgICAvLyBDb3B5IHJzYyBmb3IgdGhlIHJvb3Qgbm9kZSBvZiB0aGUgY2FjaGUuXG4gICAgY2FjaGUucnNjID0gZXhpc3RpbmdDYWNoZS5yc2NcbiAgICAvLyBUaGlzIGlzIGEgUFBSLW9ubHkgZmllbGQuIFVubGlrZSB0aGUgcHJldmlvdXMgYnJhbmNoLCBzaW5jZSB3ZSdyZVxuICAgIC8vIGp1c3QgY2xvbmluZyB0aGUgZXhpc3RpbmcgY2FjaGUgbm9kZSwgd2UgbWlnaHQgYXMgd2VsbCBrZWVwIHRoZVxuICAgIC8vIFBQUiB2YWx1ZSwgaWYgaXQgZXhpc3RzLlxuICAgIGNhY2hlLnByZWZldGNoUnNjID0gZXhpc3RpbmdDYWNoZS5wcmVmZXRjaFJzY1xuICAgIGNhY2hlLnBhcmFsbGVsUm91dGVzID0gbmV3IE1hcChleGlzdGluZ0NhY2hlLnBhcmFsbGVsUm91dGVzKVxuICAgIGNhY2hlLmxvYWRpbmcgPSBleGlzdGluZ0NhY2hlLmxvYWRpbmdcbiAgICAvLyBDcmVhdGUgYSBjb3B5IG9mIHRoZSBleGlzdGluZyBjYWNoZSB3aXRoIHRoZSByc2MgYXBwbGllZC5cbiAgICBmaWxsQ2FjaGVXaXRoTmV3U3ViVHJlZURhdGEoXG4gICAgICBuYXZpZ2F0ZWRBdCxcbiAgICAgIGNhY2hlLFxuICAgICAgZXhpc3RpbmdDYWNoZSxcbiAgICAgIGZsaWdodERhdGEsXG4gICAgICBwcmVmZXRjaEVudHJ5XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cbiJdLCJuYW1lcyI6WyJhcHBseUZsaWdodERhdGEiLCJuYXZpZ2F0ZWRBdCIsImV4aXN0aW5nQ2FjaGUiLCJjYWNoZSIsImZsaWdodERhdGEiLCJwcmVmZXRjaEVudHJ5IiwidHJlZSIsInRyZWVQYXRjaCIsInNlZWREYXRhIiwiaGVhZCIsImlzUm9vdFJlbmRlciIsInJzYyIsImxvYWRpbmciLCJwcmVmZXRjaFJzYyIsImZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkIiwicGFyYWxsZWxSb3V0ZXMiLCJNYXAiLCJmaWxsQ2FjaGVXaXRoTmV3U3ViVHJlZURhdGEiXSwibWFwcGluZ3MiOiI7OzsrQkFNZ0JBLG1CQUFBQTs7O2VBQUFBOzs7K0NBTDhCOzZDQUNGO0FBSXJDLFNBQVNBLGdCQUNkQyxXQUFtQixFQUNuQkMsYUFBd0IsRUFDeEJDLEtBQWdCLEVBQ2hCQyxVQUFnQyxFQUNoQ0MsYUFBa0M7SUFFbEMsMERBQTBEO0lBQzFELE1BQU0sRUFBRUMsTUFBTUMsU0FBUyxFQUFFQyxRQUFRLEVBQUVDLElBQUksRUFBRUMsWUFBWSxFQUFFLEdBQUdOO0lBRTFELDhGQUE4RjtJQUM5RixJQUFJSSxhQUFhLE1BQU07UUFDckIsT0FBTztJQUNUO0lBRUEsSUFBSUUsY0FBYztRQUNoQixNQUFNQyxNQUFNSCxRQUFRLENBQUMsRUFBRTtRQUN2QixNQUFNSSxVQUFVSixRQUFRLENBQUMsRUFBRTtRQUMzQkwsTUFBTVMsT0FBTyxHQUFHQTtRQUNoQlQsTUFBTVEsR0FBRyxHQUFHQTtRQUNaLGtFQUFrRTtRQUNsRSxvRUFBb0U7UUFDcEUsMkRBQTJEO1FBQzNELGtFQUFrRTtRQUNsRSwrQkFBK0I7UUFDL0JSLE1BQU1VLFdBQVcsR0FBRztRQUNwQkMsQ0FBQUEsR0FBQUEsK0JBQUFBLDZCQUE2QixFQUMzQmIsYUFDQUUsT0FDQUQsZUFDQUssV0FDQUMsVUFDQUMsTUFDQUo7SUFFSixPQUFPO1FBQ0wsMkNBQTJDO1FBQzNDRixNQUFNUSxHQUFHLEdBQUdULGNBQWNTLEdBQUc7UUFDN0Isb0VBQW9FO1FBQ3BFLGtFQUFrRTtRQUNsRSwyQkFBMkI7UUFDM0JSLE1BQU1VLFdBQVcsR0FBR1gsY0FBY1csV0FBVztRQUM3Q1YsTUFBTVksY0FBYyxHQUFHLElBQUlDLElBQUlkLGNBQWNhLGNBQWM7UUFDM0RaLE1BQU1TLE9BQU8sR0FBR1YsY0FBY1UsT0FBTztRQUNyQyw0REFBNEQ7UUFDNURLLENBQUFBLEdBQUFBLDZCQUFBQSwyQkFBMkIsRUFDekJoQixhQUNBRSxPQUNBRCxlQUNBRSxZQUNBQztJQUVKO0lBRUEsT0FBTztBQUNUIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDM5ODMsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVmZXRjaC1pbmFjdGl2ZS1wYXJhbGxlbC1zZWdtZW50cy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IEZsaWdodFJvdXRlclN0YXRlIH0gZnJvbSAnLi4vLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvdHlwZXMnXG5pbXBvcnQgdHlwZSB7IENhY2hlTm9kZSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHR5cGUgeyBBcHBSb3V0ZXJTdGF0ZSB9IGZyb20gJy4vcm91dGVyLXJlZHVjZXItdHlwZXMnXG5pbXBvcnQgeyBhcHBseUZsaWdodERhdGEgfSBmcm9tICcuL2FwcGx5LWZsaWdodC1kYXRhJ1xuaW1wb3J0IHsgZmV0Y2hTZXJ2ZXJSZXNwb25zZSB9IGZyb20gJy4vZmV0Y2gtc2VydmVyLXJlc3BvbnNlJ1xuaW1wb3J0IHsgUEFHRV9TRUdNRU5UX0tFWSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9saWIvc2VnbWVudCdcblxuaW50ZXJmYWNlIFJlZnJlc2hJbmFjdGl2ZVBhcmFsbGVsU2VnbWVudHMge1xuICBuYXZpZ2F0ZWRBdDogbnVtYmVyXG4gIHN0YXRlOiBBcHBSb3V0ZXJTdGF0ZVxuICB1cGRhdGVkVHJlZTogRmxpZ2h0Um91dGVyU3RhdGVcbiAgdXBkYXRlZENhY2hlOiBDYWNoZU5vZGVcbiAgaW5jbHVkZU5leHRVcmw6IGJvb2xlYW5cbiAgY2Fub25pY2FsVXJsOiBzdHJpbmdcbn1cblxuLyoqXG4gKiBSZWZyZXNoZXMgaW5hY3RpdmUgc2VnbWVudHMgdGhhdCBhcmUgc3RpbGwgaW4gdGhlIGN1cnJlbnQgRmxpZ2h0Um91dGVyU3RhdGUuXG4gKiBBIHNlZ21lbnQgaXMgY29uc2lkZXJlZCBcImluYWN0aXZlXCIgd2hlbiB0aGUgc2VydmVyIHJlc3BvbnNlIGluZGljYXRlcyBpdCBkaWRuJ3QgbWF0Y2ggdG8gYSBwYWdlIGNvbXBvbmVudC5cbiAqIFRoaXMgaGFwcGVucyBkdXJpbmcgYSBzb2Z0LW5hdmlnYXRpb24sIHdoZXJlIHRoZSBzZXJ2ZXIgd2lsbCB3YW50IHRvIHBhdGNoIGluIHRoZSBzZWdtZW50XG4gKiB3aXRoIHRoZSBcImRlZmF1bHRcIiBjb21wb25lbnQsIGJ1dCB3ZSBleHBsaWNpdGx5IGlnbm9yZSB0aGUgc2VydmVyIGluIHRoaXMgY2FzZVxuICogYW5kIGtlZXAgdGhlIGV4aXN0aW5nIHN0YXRlIGZvciB0aGF0IHNlZ21lbnQuIE5ldyBkYXRhIGZvciBpbmFjdGl2ZSBzZWdtZW50cyBhcmUgaW5oZXJlbnRseVxuICogbm90IHBhcnQgb2YgdGhlIHNlcnZlciByZXNwb25zZSB3aGVuIHdlIHBhdGNoIHRoZSB0cmVlLCBiZWNhdXNlIHRoZXkgd2VyZSBhc3NvY2lhdGVkIHdpdGggYSByZXNwb25zZVxuICogZnJvbSBhbiBlYXJsaWVyIG5hdmlnYXRpb24vcmVxdWVzdC4gRm9yIGVhY2ggc2VnbWVudCwgb25jZSBpdCBiZWNvbWVzIFwiYWN0aXZlXCIsIHdlIGVuY29kZSB0aGUgVVJMIHRoYXQgcHJvdmlkZWRcbiAqIHRoZSBkYXRhIGZvciBpdC4gVGhpcyBmdW5jdGlvbiB0cmF2ZXJzZXMgcGFyYWxsZWwgcm91dGVzIGxvb2tpbmcgZm9yIHRoZXNlIG1hcmtlcnMgc28gdGhhdCBpdCBjYW4gcmUtZmV0Y2hcbiAqIGFuZCBwYXRjaCB0aGUgbmV3IGRhdGEgaW50byB0aGUgdHJlZS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlZnJlc2hJbmFjdGl2ZVBhcmFsbGVsU2VnbWVudHMoXG4gIG9wdGlvbnM6IFJlZnJlc2hJbmFjdGl2ZVBhcmFsbGVsU2VnbWVudHNcbikge1xuICBjb25zdCBmZXRjaGVkU2VnbWVudHMgPSBuZXcgU2V0PHN0cmluZz4oKVxuICBhd2FpdCByZWZyZXNoSW5hY3RpdmVQYXJhbGxlbFNlZ21lbnRzSW1wbCh7XG4gICAgLi4ub3B0aW9ucyxcbiAgICByb290VHJlZTogb3B0aW9ucy51cGRhdGVkVHJlZSxcbiAgICBmZXRjaGVkU2VnbWVudHMsXG4gIH0pXG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlZnJlc2hJbmFjdGl2ZVBhcmFsbGVsU2VnbWVudHNJbXBsKHtcbiAgbmF2aWdhdGVkQXQsXG4gIHN0YXRlLFxuICB1cGRhdGVkVHJlZSxcbiAgdXBkYXRlZENhY2hlLFxuICBpbmNsdWRlTmV4dFVybCxcbiAgZmV0Y2hlZFNlZ21lbnRzLFxuICByb290VHJlZSA9IHVwZGF0ZWRUcmVlLFxuICBjYW5vbmljYWxVcmwsXG59OiBSZWZyZXNoSW5hY3RpdmVQYXJhbGxlbFNlZ21lbnRzICYge1xuICBmZXRjaGVkU2VnbWVudHM6IFNldDxzdHJpbmc+XG4gIHJvb3RUcmVlOiBGbGlnaHRSb3V0ZXJTdGF0ZVxufSkge1xuICBjb25zdCBbLCBwYXJhbGxlbFJvdXRlcywgcmVmZXRjaFBhdGgsIHJlZmV0Y2hNYXJrZXJdID0gdXBkYXRlZFRyZWVcbiAgY29uc3QgZmV0Y2hQcm9taXNlcyA9IFtdXG5cbiAgaWYgKFxuICAgIHJlZmV0Y2hQYXRoICYmXG4gICAgcmVmZXRjaFBhdGggIT09IGNhbm9uaWNhbFVybCAmJlxuICAgIHJlZmV0Y2hNYXJrZXIgPT09ICdyZWZyZXNoJyAmJlxuICAgIC8vIGl0J3MgcG9zc2libGUgZm9yIHRoZSB0cmVlIHRvIGNvbnRhaW4gbXVsdGlwbGUgc2VnbWVudHMgdGhhdCBjb250YWluIGRhdGEgYXQgdGhlIHNhbWUgVVJMXG4gICAgLy8gd2Uga2VlcCB0cmFjayBvZiB0aGVtIHNvIHdlIGNhbiBkZWR1cGUgdGhlIHJlcXVlc3RzXG4gICAgIWZldGNoZWRTZWdtZW50cy5oYXMocmVmZXRjaFBhdGgpXG4gICkge1xuICAgIGZldGNoZWRTZWdtZW50cy5hZGQocmVmZXRjaFBhdGgpIC8vIE1hcmsgdGhpcyBVUkwgYXMgZmV0Y2hlZFxuXG4gICAgLy8gRWFnZXJseSBraWNrIG9mZiB0aGUgZmV0Y2ggZm9yIHRoZSByZWZldGNoIHBhdGggJiB0aGUgcGFyYWxsZWwgcm91dGVzLiBUaGlzIHNob3VsZCBiZSBmaW5lIHRvIGRvIGFzIHRoZXkgZWFjaCBvcGVyYXRlXG4gICAgLy8gaW5kZXBlbmRlbnRseSBvbiB0aGVpciBvd24gY2FjaGUgbm9kZXMsIGFuZCBgYXBwbHlGbGlnaHREYXRhYCB3aWxsIGNvcHkgYW55dGhpbmcgaXQgZG9lc24ndCBjYXJlIGFib3V0IGZyb20gdGhlIGV4aXN0aW5nIGNhY2hlLlxuICAgIGNvbnN0IGZldGNoUHJvbWlzZSA9IGZldGNoU2VydmVyUmVzcG9uc2UoXG4gICAgICBuZXcgVVJMKHJlZmV0Y2hQYXRoLCBsb2NhdGlvbi5vcmlnaW4pLFxuICAgICAge1xuICAgICAgICAvLyByZWZldGNoIGZyb20gdGhlIHJvb3Qgb2YgdGhlIHVwZGF0ZWQgdHJlZSwgb3RoZXJ3aXNlIGl0IHdpbGwgYmUgc2NvcGVkIHRvIHRoZSBjdXJyZW50IHNlZ21lbnRcbiAgICAgICAgLy8gYW5kIG1pZ2h0IG5vdCBjb250YWluIHRoZSBkYXRhIHdlIG5lZWQgdG8gcGF0Y2ggaW4gaW50ZXJjZXB0aW9uIHJvdXRlIGRhdGEgKHN1Y2ggYXMgZHluYW1pYyBwYXJhbXMgZnJvbSBhIHByZXZpb3VzIHNlZ21lbnQpXG4gICAgICAgIGZsaWdodFJvdXRlclN0YXRlOiBbcm9vdFRyZWVbMF0sIHJvb3RUcmVlWzFdLCByb290VHJlZVsyXSwgJ3JlZmV0Y2gnXSxcbiAgICAgICAgbmV4dFVybDogaW5jbHVkZU5leHRVcmwgPyBzdGF0ZS5uZXh0VXJsIDogbnVsbCxcbiAgICAgIH1cbiAgICApLnRoZW4oKHsgZmxpZ2h0RGF0YSB9KSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGZsaWdodERhdGEgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGZvciAoY29uc3QgZmxpZ2h0RGF0YVBhdGggb2YgZmxpZ2h0RGF0YSkge1xuICAgICAgICAgIC8vIHdlIG9ubHkgcGFzcyB0aGUgbmV3IGNhY2hlIGFzIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGFmdGVyIGNsZWFyaW5nIHRoZSByb3V0ZXIgY2FjaGVcbiAgICAgICAgICAvLyBhbmQgZmlsbGluZyBpbiB0aGUgbmV3IHBhZ2UgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIuIE1lYW5pbmcgdGhlIGV4aXN0aW5nIGNhY2hlIGlzIGFjdHVhbGx5IHRoZSBjYWNoZSB0aGF0J3NcbiAgICAgICAgICAvLyBqdXN0IGJlZW4gY3JlYXRlZCAmIGhhcyBiZWVuIHdyaXR0ZW4gdG8sIGJ1dCBoYXNuJ3QgYmVlbiBcImNvbW1pdHRlZFwiIHlldC5cbiAgICAgICAgICBhcHBseUZsaWdodERhdGEoXG4gICAgICAgICAgICBuYXZpZ2F0ZWRBdCxcbiAgICAgICAgICAgIHVwZGF0ZWRDYWNoZSxcbiAgICAgICAgICAgIHVwZGF0ZWRDYWNoZSxcbiAgICAgICAgICAgIGZsaWdodERhdGFQYXRoXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXaGVuIGZsaWdodERhdGEgaXMgYSBzdHJpbmcsIGl0IHN1Z2dlc3RzIHRoYXQgdGhlIHNlcnZlciByZXNwb25zZSBzaG91bGQgaGF2ZSB0cmlnZ2VyZWQgYW4gTVBBIG5hdmlnYXRpb25cbiAgICAgICAgLy8gSSdtIG5vdCAxMDAlIHN1cmUgb2YgdGhpcyBkZWNpc2lvbiwgYnV0IGl0IHNlZW1zIHVubGlrZWx5IHRoYXQgd2UnZCB3YW50IHRvIGludHJvZHVjZSBhIHJlZGlyZWN0IHNpZGUgZWZmZWN0XG4gICAgICAgIC8vIHdoZW4gcmVmcmVzaGluZyBvbi1zY3JlZW4gZGF0YSwgc28gaGFuZGxpbmcgdGhpcyBoYXMgYmVlbiBvbW1pdHRlZC5cbiAgICAgIH1cbiAgICB9KVxuXG4gICAgZmV0Y2hQcm9taXNlcy5wdXNoKGZldGNoUHJvbWlzZSlcbiAgfVxuXG4gIGZvciAoY29uc3Qga2V5IGluIHBhcmFsbGVsUm91dGVzKSB7XG4gICAgY29uc3QgcGFyYWxsZWxGZXRjaFByb21pc2UgPSByZWZyZXNoSW5hY3RpdmVQYXJhbGxlbFNlZ21lbnRzSW1wbCh7XG4gICAgICBuYXZpZ2F0ZWRBdCxcbiAgICAgIHN0YXRlLFxuICAgICAgdXBkYXRlZFRyZWU6IHBhcmFsbGVsUm91dGVzW2tleV0sXG4gICAgICB1cGRhdGVkQ2FjaGUsXG4gICAgICBpbmNsdWRlTmV4dFVybCxcbiAgICAgIGZldGNoZWRTZWdtZW50cyxcbiAgICAgIHJvb3RUcmVlLFxuICAgICAgY2Fub25pY2FsVXJsLFxuICAgIH0pXG5cbiAgICBmZXRjaFByb21pc2VzLnB1c2gocGFyYWxsZWxGZXRjaFByb21pc2UpXG4gIH1cblxuICBhd2FpdCBQcm9taXNlLmFsbChmZXRjaFByb21pc2VzKVxufVxuXG4vKipcbiAqIFdhbGtzIHRoZSBjdXJyZW50IHBhcmFsbGVsIHNlZ21lbnRzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBcImFjdGl2ZVwiLlxuICogQW4gYWN0aXZlIHBhcmFsbGVsIHJvdXRlIHdpbGwgaGF2ZSBhIGBfX1BBR0VfX2Agc2VnbWVudCBpbiB0aGUgRmxpZ2h0Um91dGVyU3RhdGUuXG4gKiBBcyBvcHBvc2VkIHRvIGEgYF9fREVGQVVMVF9fYCBzZWdtZW50LCB3aGljaCBtZWFucyB0aGVyZSB3YXMgbm8gbWF0Y2ggZm9yIHRoYXQgcGFyYWxsZWwgcm91dGUuXG4gKiBXZSBhZGQgYSBzcGVjaWFsIG1hcmtlciBoZXJlIHNvIHRoYXQgd2Uga25vdyBob3cgdG8gcmVmcmVzaCBpdHMgZGF0YSB3aGVuIHRoZSByb3V0ZXIgaXMgcmV2YWxpZGF0ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRSZWZyZXNoTWFya2VyVG9BY3RpdmVQYXJhbGxlbFNlZ21lbnRzKFxuICB0cmVlOiBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgcGF0aDogc3RyaW5nXG4pIHtcbiAgY29uc3QgW3NlZ21lbnQsIHBhcmFsbGVsUm91dGVzLCAsIHJlZmV0Y2hNYXJrZXJdID0gdHJlZVxuICAvLyBhIHBhZ2Ugc2VnbWVudCBtaWdodCBhbHNvIGNvbnRhaW4gY29uY2F0ZW5hdGVkIHNlYXJjaCBwYXJhbXMsIHNvIHdlIGRvIGEgcGFydGlhbCBtYXRjaCBvbiB0aGUga2V5XG4gIGlmIChzZWdtZW50LmluY2x1ZGVzKFBBR0VfU0VHTUVOVF9LRVkpICYmIHJlZmV0Y2hNYXJrZXIgIT09ICdyZWZyZXNoJykge1xuICAgIHRyZWVbMl0gPSBwYXRoXG4gICAgdHJlZVszXSA9ICdyZWZyZXNoJ1xuICB9XG5cbiAgZm9yIChjb25zdCBrZXkgaW4gcGFyYWxsZWxSb3V0ZXMpIHtcbiAgICBhZGRSZWZyZXNoTWFya2VyVG9BY3RpdmVQYXJhbGxlbFNlZ21lbnRzKHBhcmFsbGVsUm91dGVzW2tleV0sIHBhdGgpXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJhZGRSZWZyZXNoTWFya2VyVG9BY3RpdmVQYXJhbGxlbFNlZ21lbnRzIiwicmVmcmVzaEluYWN0aXZlUGFyYWxsZWxTZWdtZW50cyIsIm9wdGlvbnMiLCJmZXRjaGVkU2VnbWVudHMiLCJTZXQiLCJyZWZyZXNoSW5hY3RpdmVQYXJhbGxlbFNlZ21lbnRzSW1wbCIsInJvb3RUcmVlIiwidXBkYXRlZFRyZWUiLCJuYXZpZ2F0ZWRBdCIsInN0YXRlIiwidXBkYXRlZENhY2hlIiwiaW5jbHVkZU5leHRVcmwiLCJjYW5vbmljYWxVcmwiLCJwYXJhbGxlbFJvdXRlcyIsInJlZmV0Y2hQYXRoIiwicmVmZXRjaE1hcmtlciIsImZldGNoUHJvbWlzZXMiLCJoYXMiLCJhZGQiLCJmZXRjaFByb21pc2UiLCJmZXRjaFNlcnZlclJlc3BvbnNlIiwiVVJMIiwibG9jYXRpb24iLCJvcmlnaW4iLCJmbGlnaHRSb3V0ZXJTdGF0ZSIsIm5leHRVcmwiLCJ0aGVuIiwiZmxpZ2h0RGF0YSIsImZsaWdodERhdGFQYXRoIiwiYXBwbHlGbGlnaHREYXRhIiwicHVzaCIsImtleSIsInBhcmFsbGVsRmV0Y2hQcm9taXNlIiwiUHJvbWlzZSIsImFsbCIsInRyZWUiLCJwYXRoIiwic2VnbWVudCIsImluY2x1ZGVzIiwiUEFHRV9TRUdNRU5UX0tFWSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7SUF5SGdCQSx3Q0FBd0MsRUFBQTtlQUF4Q0E7O0lBOUZNQywrQkFBK0IsRUFBQTtlQUEvQkE7OztpQ0F4QlU7cUNBQ0k7eUJBQ0g7QUFzQjFCLGVBQWVBLGdDQUNwQkMsT0FBd0M7SUFFeEMsTUFBTUMsa0JBQWtCLElBQUlDO0lBQzVCLE1BQU1DLG9DQUFvQztRQUN4QyxHQUFHSCxPQUFPO1FBQ1ZJLFVBQVVKLFFBQVFLLFdBQVc7UUFDN0JKO0lBQ0Y7QUFDRjtBQUVBLGVBQWVFLG9DQUFvQyxLQVlsRDtJQVprRCxJQUFBLEVBQ2pERyxXQUFXLEVBQ1hDLEtBQUssRUFDTEYsV0FBVyxFQUNYRyxZQUFZLEVBQ1pDLGNBQWMsRUFDZFIsZUFBZSxFQUNmRyxXQUFXQyxXQUFXLEVBQ3RCSyxZQUFZLEVBSWIsR0Faa0Q7SUFhakQsTUFBTSxHQUFHQyxnQkFBZ0JDLGFBQWFDLGNBQWMsR0FBR1I7SUFDdkQsTUFBTVMsZ0JBQWdCLEVBQUU7SUFFeEIsSUFDRUYsZUFDQUEsZ0JBQWdCRixnQkFDaEJHLGtCQUFrQixhQUNsQiw0RkFBNEY7SUFDNUYsc0RBQXNEO0lBQ3RELENBQUNaLGdCQUFnQmMsR0FBRyxDQUFDSCxjQUNyQjtRQUNBWCxnQkFBZ0JlLEdBQUcsQ0FBQ0osYUFBYSwyQkFBMkI7O1FBRTVELHdIQUF3SDtRQUN4SCxrSUFBa0k7UUFDbEksTUFBTUssZUFBZUMsQ0FBQUEsR0FBQUEscUJBQUFBLG1CQUFtQixFQUN0QyxJQUFJQyxJQUFJUCxhQUFhUSxTQUFTQyxNQUFNLEdBQ3BDO1lBQ0UsZ0dBQWdHO1lBQ2hHLDhIQUE4SDtZQUM5SEMsbUJBQW1CO2dCQUFDbEIsUUFBUSxDQUFDLEVBQUU7Z0JBQUVBLFFBQVEsQ0FBQyxFQUFFO2dCQUFFQSxRQUFRLENBQUMsRUFBRTtnQkFBRTthQUFVO1lBQ3JFbUIsU0FBU2QsaUJBQWlCRixNQUFNZ0IsT0FBTyxHQUFHO1FBQzVDLEdBQ0FDLElBQUksQ0FBQyxDQUFBO2dCQUFDLEVBQUVDLFVBQVUsRUFBRSxHQUFBO1lBQ3BCLElBQUksT0FBT0EsZUFBZSxVQUFVO2dCQUNsQyxLQUFLLE1BQU1DLGtCQUFrQkQsV0FBWTtvQkFDdkMsd0ZBQXdGO29CQUN4Riw0R0FBNEc7b0JBQzVHLDRFQUE0RTtvQkFDNUVFLENBQUFBLEdBQUFBLGlCQUFBQSxlQUFlLEVBQ2JyQixhQUNBRSxjQUNBQSxjQUNBa0I7Z0JBRUo7WUFDRixPQUFPO1lBQ0wsNEdBQTRHO1lBQzVHLCtHQUErRztZQUMvRyxzRUFBc0U7WUFDeEU7UUFDRjtRQUVBWixjQUFjYyxJQUFJLENBQUNYO0lBQ3JCO0lBRUEsSUFBSyxNQUFNWSxPQUFPbEIsZUFBZ0I7UUFDaEMsTUFBTW1CLHVCQUF1QjNCLG9DQUFvQztZQUMvREc7WUFDQUM7WUFDQUYsYUFBYU0sY0FBYyxDQUFDa0IsSUFBSTtZQUNoQ3JCO1lBQ0FDO1lBQ0FSO1lBQ0FHO1lBQ0FNO1FBQ0Y7UUFFQUksY0FBY2MsSUFBSSxDQUFDRTtJQUNyQjtJQUVBLE1BQU1DLFFBQVFDLEdBQUcsQ0FBQ2xCO0FBQ3BCO0FBUU8sU0FBU2hCLHlDQUNkbUMsSUFBdUIsRUFDdkJDLElBQVk7SUFFWixNQUFNLENBQUNDLFNBQVN4QixrQkFBa0JFLGNBQWMsR0FBR29CO0lBQ25ELG9HQUFvRztJQUNwRyxJQUFJRSxRQUFRQyxRQUFRLENBQUNDLFNBQUFBLGdCQUFnQixLQUFLeEIsa0JBQWtCLFdBQVc7UUFDckVvQixJQUFJLENBQUMsRUFBRSxHQUFHQztRQUNWRCxJQUFJLENBQUMsRUFBRSxHQUFHO0lBQ1o7SUFFQSxJQUFLLE1BQU1KLE9BQU9sQixlQUFnQjtRQUNoQ2IseUNBQXlDYSxjQUFjLENBQUNrQixJQUFJLEVBQUVLO0lBQ2hFO0FBQ0YiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNDA5MiwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9hcHBseS1yb3V0ZXItc3RhdGUtcGF0Y2gtdG8tdHJlZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7XG4gIEZsaWdodFJvdXRlclN0YXRlLFxuICBGbGlnaHRTZWdtZW50UGF0aCxcbn0gZnJvbSAnLi4vLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvdHlwZXMnXG5pbXBvcnQgeyBERUZBVUxUX1NFR01FTlRfS0VZIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2xpYi9zZWdtZW50J1xuaW1wb3J0IHsgZ2V0TmV4dEZsaWdodFNlZ21lbnRQYXRoIH0gZnJvbSAnLi4vLi4vZmxpZ2h0LWRhdGEtaGVscGVycydcbmltcG9ydCB7IG1hdGNoU2VnbWVudCB9IGZyb20gJy4uL21hdGNoLXNlZ21lbnRzJ1xuaW1wb3J0IHsgYWRkUmVmcmVzaE1hcmtlclRvQWN0aXZlUGFyYWxsZWxTZWdtZW50cyB9IGZyb20gJy4vcmVmZXRjaC1pbmFjdGl2ZS1wYXJhbGxlbC1zZWdtZW50cydcblxuLyoqXG4gKiBEZWVwIG1lcmdlIG9mIHRoZSB0d28gcm91dGVyIHN0YXRlcy4gUGFyYWxsZWwgcm91dGUga2V5cyBhcmUgcHJlc2VydmVkIGlmIHRoZSBwYXRjaCBkb2Vzbid0IGhhdmUgdGhlbS5cbiAqL1xuZnVuY3Rpb24gYXBwbHlQYXRjaChcbiAgaW5pdGlhbFRyZWU6IEZsaWdodFJvdXRlclN0YXRlLFxuICBwYXRjaFRyZWU6IEZsaWdodFJvdXRlclN0YXRlXG4pOiBGbGlnaHRSb3V0ZXJTdGF0ZSB7XG4gIGNvbnN0IFtpbml0aWFsU2VnbWVudCwgaW5pdGlhbFBhcmFsbGVsUm91dGVzXSA9IGluaXRpYWxUcmVlXG4gIGNvbnN0IFtwYXRjaFNlZ21lbnQsIHBhdGNoUGFyYWxsZWxSb3V0ZXNdID0gcGF0Y2hUcmVlXG5cbiAgLy8gaWYgdGhlIGFwcGxpZWQgcGF0Y2ggc2VnbWVudCBpcyBfX0RFRkFVTFRfXyB0aGVuIGl0IGNhbiBiZSBpZ25vcmVkIGluIGZhdm9yIG9mIHRoZSBpbml0aWFsIHRyZWVcbiAgLy8gdGhpcyBpcyBiZWNhdXNlIHRoZSBfX0RFRkFVTFRfXyBzZWdtZW50IGlzIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBvbiBuYXZpZ2F0aW9uXG4gIGlmIChcbiAgICBwYXRjaFNlZ21lbnQgPT09IERFRkFVTFRfU0VHTUVOVF9LRVkgJiZcbiAgICBpbml0aWFsU2VnbWVudCAhPT0gREVGQVVMVF9TRUdNRU5UX0tFWVxuICApIHtcbiAgICByZXR1cm4gaW5pdGlhbFRyZWVcbiAgfVxuXG4gIGlmIChtYXRjaFNlZ21lbnQoaW5pdGlhbFNlZ21lbnQsIHBhdGNoU2VnbWVudCkpIHtcbiAgICBjb25zdCBuZXdQYXJhbGxlbFJvdXRlczogRmxpZ2h0Um91dGVyU3RhdGVbMV0gPSB7fVxuICAgIGZvciAoY29uc3Qga2V5IGluIGluaXRpYWxQYXJhbGxlbFJvdXRlcykge1xuICAgICAgY29uc3QgaXNJblBhdGNoVHJlZVBhcmFsbGVsUm91dGVzID1cbiAgICAgICAgdHlwZW9mIHBhdGNoUGFyYWxsZWxSb3V0ZXNba2V5XSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgIGlmIChpc0luUGF0Y2hUcmVlUGFyYWxsZWxSb3V0ZXMpIHtcbiAgICAgICAgbmV3UGFyYWxsZWxSb3V0ZXNba2V5XSA9IGFwcGx5UGF0Y2goXG4gICAgICAgICAgaW5pdGlhbFBhcmFsbGVsUm91dGVzW2tleV0sXG4gICAgICAgICAgcGF0Y2hQYXJhbGxlbFJvdXRlc1trZXldXG4gICAgICAgIClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld1BhcmFsbGVsUm91dGVzW2tleV0gPSBpbml0aWFsUGFyYWxsZWxSb3V0ZXNba2V5XVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoY29uc3Qga2V5IGluIHBhdGNoUGFyYWxsZWxSb3V0ZXMpIHtcbiAgICAgIGlmIChuZXdQYXJhbGxlbFJvdXRlc1trZXldKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIG5ld1BhcmFsbGVsUm91dGVzW2tleV0gPSBwYXRjaFBhcmFsbGVsUm91dGVzW2tleV1cbiAgICB9XG5cbiAgICBjb25zdCB0cmVlOiBGbGlnaHRSb3V0ZXJTdGF0ZSA9IFtpbml0aWFsU2VnbWVudCwgbmV3UGFyYWxsZWxSb3V0ZXNdXG5cbiAgICAvLyBDb3B5IG92ZXIgdGhlIGV4aXN0aW5nIHRyZWVcbiAgICBpZiAoaW5pdGlhbFRyZWVbMl0pIHtcbiAgICAgIHRyZWVbMl0gPSBpbml0aWFsVHJlZVsyXVxuICAgIH1cblxuICAgIGlmIChpbml0aWFsVHJlZVszXSkge1xuICAgICAgdHJlZVszXSA9IGluaXRpYWxUcmVlWzNdXG4gICAgfVxuXG4gICAgaWYgKGluaXRpYWxUcmVlWzRdKSB7XG4gICAgICB0cmVlWzRdID0gaW5pdGlhbFRyZWVbNF1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJlZVxuICB9XG5cbiAgcmV0dXJuIHBhdGNoVHJlZVxufVxuXG4vKipcbiAqIEFwcGx5IHRoZSByb3V0ZXIgc3RhdGUgZnJvbSB0aGUgRmxpZ2h0IHJlc3BvbnNlLCBidXQgc2tpcCBwYXRjaGluZyBkZWZhdWx0IHNlZ21lbnRzLlxuICogVXNlZnVsIGZvciBwYXRjaGluZyB0aGUgcm91dGVyIGNhY2hlIHdoZW4gbmF2aWdhdGluZywgd2hlcmUgd2UgcGVyc2lzdCB0aGUgZXhpc3RpbmcgZGVmYXVsdCBzZWdtZW50IGlmIHRoZXJlIGlzbid0IGEgbmV3IG9uZS5cbiAqIENyZWF0ZXMgYSBuZXcgcm91dGVyIHN0YXRlIHRyZWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUoXG4gIGZsaWdodFNlZ21lbnRQYXRoOiBGbGlnaHRTZWdtZW50UGF0aCxcbiAgZmxpZ2h0Um91dGVyU3RhdGU6IEZsaWdodFJvdXRlclN0YXRlLFxuICB0cmVlUGF0Y2g6IEZsaWdodFJvdXRlclN0YXRlLFxuICBwYXRoOiBzdHJpbmdcbik6IEZsaWdodFJvdXRlclN0YXRlIHwgbnVsbCB7XG4gIGNvbnN0IFtzZWdtZW50LCBwYXJhbGxlbFJvdXRlcywgdXJsLCByZWZldGNoLCBpc1Jvb3RMYXlvdXRdID1cbiAgICBmbGlnaHRSb3V0ZXJTdGF0ZVxuXG4gIC8vIFJvb3QgcmVmcmVzaFxuICBpZiAoZmxpZ2h0U2VnbWVudFBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgY29uc3QgdHJlZTogRmxpZ2h0Um91dGVyU3RhdGUgPSBhcHBseVBhdGNoKGZsaWdodFJvdXRlclN0YXRlLCB0cmVlUGF0Y2gpXG5cbiAgICBhZGRSZWZyZXNoTWFya2VyVG9BY3RpdmVQYXJhbGxlbFNlZ21lbnRzKHRyZWUsIHBhdGgpXG5cbiAgICByZXR1cm4gdHJlZVxuICB9XG5cbiAgY29uc3QgW2N1cnJlbnRTZWdtZW50LCBwYXJhbGxlbFJvdXRlS2V5XSA9IGZsaWdodFNlZ21lbnRQYXRoXG5cbiAgLy8gVHJlZSBwYXRoIHJldHVybmVkIGZyb20gdGhlIHNlcnZlciBzaG91bGQgYWx3YXlzIG1hdGNoIHVwIHdpdGggdGhlIGN1cnJlbnQgdHJlZSBpbiB0aGUgYnJvd3NlclxuICBpZiAoIW1hdGNoU2VnbWVudChjdXJyZW50U2VnbWVudCwgc2VnbWVudCkpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgY29uc3QgbGFzdFNlZ21lbnQgPSBmbGlnaHRTZWdtZW50UGF0aC5sZW5ndGggPT09IDJcblxuICBsZXQgcGFyYWxsZWxSb3V0ZVBhdGNoXG4gIGlmIChsYXN0U2VnbWVudCkge1xuICAgIHBhcmFsbGVsUm91dGVQYXRjaCA9IGFwcGx5UGF0Y2gocGFyYWxsZWxSb3V0ZXNbcGFyYWxsZWxSb3V0ZUtleV0sIHRyZWVQYXRjaClcbiAgfSBlbHNlIHtcbiAgICBwYXJhbGxlbFJvdXRlUGF0Y2ggPSBhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUoXG4gICAgICBnZXROZXh0RmxpZ2h0U2VnbWVudFBhdGgoZmxpZ2h0U2VnbWVudFBhdGgpLFxuICAgICAgcGFyYWxsZWxSb3V0ZXNbcGFyYWxsZWxSb3V0ZUtleV0sXG4gICAgICB0cmVlUGF0Y2gsXG4gICAgICBwYXRoXG4gICAgKVxuXG4gICAgaWYgKHBhcmFsbGVsUm91dGVQYXRjaCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cblxuICBjb25zdCB0cmVlOiBGbGlnaHRSb3V0ZXJTdGF0ZSA9IFtcbiAgICBmbGlnaHRTZWdtZW50UGF0aFswXSxcbiAgICB7XG4gICAgICAuLi5wYXJhbGxlbFJvdXRlcyxcbiAgICAgIFtwYXJhbGxlbFJvdXRlS2V5XTogcGFyYWxsZWxSb3V0ZVBhdGNoLFxuICAgIH0sXG4gICAgdXJsLFxuICAgIHJlZmV0Y2gsXG4gIF1cblxuICAvLyBDdXJyZW50IHNlZ21lbnQgaXMgdGhlIHJvb3QgbGF5b3V0XG4gIGlmIChpc1Jvb3RMYXlvdXQpIHtcbiAgICB0cmVlWzRdID0gdHJ1ZVxuICB9XG5cbiAgYWRkUmVmcmVzaE1hcmtlclRvQWN0aXZlUGFyYWxsZWxTZWdtZW50cyh0cmVlLCBwYXRoKVxuXG4gIHJldHVybiB0cmVlXG59XG4iXSwibmFtZXMiOlsiYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlIiwiYXBwbHlQYXRjaCIsImluaXRpYWxUcmVlIiwicGF0Y2hUcmVlIiwiaW5pdGlhbFNlZ21lbnQiLCJpbml0aWFsUGFyYWxsZWxSb3V0ZXMiLCJwYXRjaFNlZ21lbnQiLCJwYXRjaFBhcmFsbGVsUm91dGVzIiwiREVGQVVMVF9TRUdNRU5UX0tFWSIsIm1hdGNoU2VnbWVudCIsIm5ld1BhcmFsbGVsUm91dGVzIiwia2V5IiwiaXNJblBhdGNoVHJlZVBhcmFsbGVsUm91dGVzIiwidHJlZSIsImZsaWdodFNlZ21lbnRQYXRoIiwiZmxpZ2h0Um91dGVyU3RhdGUiLCJ0cmVlUGF0Y2giLCJwYXRoIiwic2VnbWVudCIsInBhcmFsbGVsUm91dGVzIiwidXJsIiwicmVmZXRjaCIsImlzUm9vdExheW91dCIsImxlbmd0aCIsImFkZFJlZnJlc2hNYXJrZXJUb0FjdGl2ZVBhcmFsbGVsU2VnbWVudHMiLCJjdXJyZW50U2VnbWVudCIsInBhcmFsbGVsUm91dGVLZXkiLCJsYXN0U2VnbWVudCIsInBhcmFsbGVsUm91dGVQYXRjaCIsImdldE5leHRGbGlnaHRTZWdtZW50UGF0aCJdLCJtYXBwaW5ncyI6Ijs7OytCQTZFZ0JBLCtCQUFBQTs7O2VBQUFBOzs7eUJBekVvQjttQ0FDSzsrQkFDWjtpREFDNEI7QUFFekQ7O0NBRUMsR0FDRCxTQUFTQyxXQUNQQyxXQUE4QixFQUM5QkMsU0FBNEI7SUFFNUIsTUFBTSxDQUFDQyxnQkFBZ0JDLHNCQUFzQixHQUFHSDtJQUNoRCxNQUFNLENBQUNJLGNBQWNDLG9CQUFvQixHQUFHSjtJQUU1QyxrR0FBa0c7SUFDbEcsaUZBQWlGO0lBQ2pGLElBQ0VHLGlCQUFpQkUsU0FBQUEsbUJBQW1CLElBQ3BDSixtQkFBbUJJLFNBQUFBLG1CQUFtQixFQUN0QztRQUNBLE9BQU9OO0lBQ1Q7SUFFQSxJQUFJTyxDQUFBQSxHQUFBQSxlQUFBQSxZQUFZLEVBQUNMLGdCQUFnQkUsZUFBZTtRQUM5QyxNQUFNSSxvQkFBMEMsQ0FBQztRQUNqRCxJQUFLLE1BQU1DLE9BQU9OLHNCQUF1QjtZQUN2QyxNQUFNTyw4QkFDSixPQUFPTCxtQkFBbUIsQ0FBQ0ksSUFBSSxLQUFLO1lBQ3RDLElBQUlDLDZCQUE2QjtnQkFDL0JGLGlCQUFpQixDQUFDQyxJQUFJLEdBQUdWLFdBQ3ZCSSxxQkFBcUIsQ0FBQ00sSUFBSSxFQUMxQkosbUJBQW1CLENBQUNJLElBQUk7WUFFNUIsT0FBTztnQkFDTEQsaUJBQWlCLENBQUNDLElBQUksR0FBR04scUJBQXFCLENBQUNNLElBQUk7WUFDckQ7UUFDRjtRQUVBLElBQUssTUFBTUEsT0FBT0osb0JBQXFCO1lBQ3JDLElBQUlHLGlCQUFpQixDQUFDQyxJQUFJLEVBQUU7Z0JBQzFCO1lBQ0Y7WUFFQUQsaUJBQWlCLENBQUNDLElBQUksR0FBR0osbUJBQW1CLENBQUNJLElBQUk7UUFDbkQ7UUFFQSxNQUFNRSxPQUEwQjtZQUFDVDtZQUFnQk07U0FBa0I7UUFFbkUsOEJBQThCO1FBQzlCLElBQUlSLFdBQVcsQ0FBQyxFQUFFLEVBQUU7WUFDbEJXLElBQUksQ0FBQyxFQUFFLEdBQUdYLFdBQVcsQ0FBQyxFQUFFO1FBQzFCO1FBRUEsSUFBSUEsV0FBVyxDQUFDLEVBQUUsRUFBRTtZQUNsQlcsSUFBSSxDQUFDLEVBQUUsR0FBR1gsV0FBVyxDQUFDLEVBQUU7UUFDMUI7UUFFQSxJQUFJQSxXQUFXLENBQUMsRUFBRSxFQUFFO1lBQ2xCVyxJQUFJLENBQUMsRUFBRSxHQUFHWCxXQUFXLENBQUMsRUFBRTtRQUMxQjtRQUVBLE9BQU9XO0lBQ1Q7SUFFQSxPQUFPVjtBQUNUO0FBT08sU0FBU0gsNEJBQ2RjLGlCQUFvQyxFQUNwQ0MsaUJBQW9DLEVBQ3BDQyxTQUE0QixFQUM1QkMsSUFBWTtJQUVaLE1BQU0sQ0FBQ0MsU0FBU0MsZ0JBQWdCQyxLQUFLQyxTQUFTQyxhQUFhLEdBQ3pEUDtJQUVGLGVBQWU7SUFDZixJQUFJRCxrQkFBa0JTLE1BQU0sS0FBSyxHQUFHO1FBQ2xDLE1BQU1WLE9BQTBCWixXQUFXYyxtQkFBbUJDO1FBRTlEUSxDQUFBQSxHQUFBQSxpQ0FBQUEsd0NBQXdDLEVBQUNYLE1BQU1JO1FBRS9DLE9BQU9KO0lBQ1Q7SUFFQSxNQUFNLENBQUNZLGdCQUFnQkMsaUJBQWlCLEdBQUdaO0lBRTNDLGlHQUFpRztJQUNqRyxJQUFJLENBQUNMLENBQUFBLEdBQUFBLGVBQUFBLFlBQVksRUFBQ2dCLGdCQUFnQlAsVUFBVTtRQUMxQyxPQUFPO0lBQ1Q7SUFFQSxNQUFNUyxjQUFjYixrQkFBa0JTLE1BQU0sS0FBSztJQUVqRCxJQUFJSztJQUNKLElBQUlELGFBQWE7UUFDZkMscUJBQXFCM0IsV0FBV2tCLGNBQWMsQ0FBQ08saUJBQWlCLEVBQUVWO0lBQ3BFLE9BQU87UUFDTFkscUJBQXFCNUIsNEJBQ25CNkIsQ0FBQUEsR0FBQUEsbUJBQUFBLHdCQUF3QixFQUFDZixvQkFDekJLLGNBQWMsQ0FBQ08saUJBQWlCLEVBQ2hDVixXQUNBQztRQUdGLElBQUlXLHVCQUF1QixNQUFNO1lBQy9CLE9BQU87UUFDVDtJQUNGO0lBRUEsTUFBTWYsT0FBMEI7UUFDOUJDLGlCQUFpQixDQUFDLEVBQUU7UUFDcEI7WUFDRSxHQUFHSyxjQUFjO1lBQ2pCLENBQUNPLGlCQUFpQixFQUFFRTtRQUN0QjtRQUNBUjtRQUNBQztLQUNEO0lBRUQscUNBQXFDO0lBQ3JDLElBQUlDLGNBQWM7UUFDaEJULElBQUksQ0FBQyxFQUFFLEdBQUc7SUFDWjtJQUVBVyxDQUFBQSxHQUFBQSxpQ0FBQUEsd0NBQXdDLEVBQUNYLE1BQU1JO0lBRS9DLE9BQU9KO0FBQ1QiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNDIwMSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9zaG91bGQtaGFyZC1uYXZpZ2F0ZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7XG4gIEZsaWdodFJvdXRlclN0YXRlLFxuICBGbGlnaHREYXRhUGF0aCxcbiAgU2VnbWVudCxcbn0gZnJvbSAnLi4vLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvdHlwZXMnXG5pbXBvcnQgeyBnZXROZXh0RmxpZ2h0U2VnbWVudFBhdGggfSBmcm9tICcuLi8uLi9mbGlnaHQtZGF0YS1oZWxwZXJzJ1xuaW1wb3J0IHsgbWF0Y2hTZWdtZW50IH0gZnJvbSAnLi4vbWF0Y2gtc2VnbWVudHMnXG5cbi8vIFRPRE8tQVBQOiBmbGlnaHRTZWdtZW50UGF0aCB3aWxsIGJlIGVtcHR5IGluIGNhc2Ugb2Ygc3RhdGljIHJlc3BvbnNlLCBuZWVkcyB0byBiZSBoYW5kbGVkLlxuZXhwb3J0IGZ1bmN0aW9uIHNob3VsZEhhcmROYXZpZ2F0ZShcbiAgZmxpZ2h0U2VnbWVudFBhdGg6IEZsaWdodERhdGFQYXRoLFxuICBmbGlnaHRSb3V0ZXJTdGF0ZTogRmxpZ2h0Um91dGVyU3RhdGVcbik6IGJvb2xlYW4ge1xuICBjb25zdCBbc2VnbWVudCwgcGFyYWxsZWxSb3V0ZXNdID0gZmxpZ2h0Um91dGVyU3RhdGVcbiAgLy8gVE9ETy1BUFA6IENoZWNrIGlmIGBhc2AgY2FuIGJlIHJlcGxhY2VkLlxuICBjb25zdCBbY3VycmVudFNlZ21lbnQsIHBhcmFsbGVsUm91dGVLZXldID0gZmxpZ2h0U2VnbWVudFBhdGggYXMgW1xuICAgIFNlZ21lbnQsXG4gICAgc3RyaW5nLFxuICBdXG5cbiAgLy8gQ2hlY2sgaWYgY3VycmVudCBzZWdtZW50IG1hdGNoZXMgdGhlIGV4aXN0aW5nIHNlZ21lbnQuXG4gIGlmICghbWF0Y2hTZWdtZW50KGN1cnJlbnRTZWdtZW50LCBzZWdtZW50KSkge1xuICAgIC8vIElmIGR5bmFtaWMgcGFyYW1ldGVyIGluIHRyZWUgZG9lc24ndCBtYXRjaCB1cCB3aXRoIHNlZ21lbnQgcGF0aCBhIGhhcmQgbmF2aWdhdGlvbiBpcyB0cmlnZ2VyZWQuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudFNlZ21lbnQpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8vIElmIHRoZSBleGlzdGluZyBzZWdtZW50IGRpZCBub3QgbWF0Y2ggc29mdCBuYXZpZ2F0aW9uIGlzIHRyaWdnZXJlZC5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBjb25zdCBsYXN0U2VnbWVudCA9IGZsaWdodFNlZ21lbnRQYXRoLmxlbmd0aCA8PSAyXG5cbiAgaWYgKGxhc3RTZWdtZW50KSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gc2hvdWxkSGFyZE5hdmlnYXRlKFxuICAgIGdldE5leHRGbGlnaHRTZWdtZW50UGF0aChmbGlnaHRTZWdtZW50UGF0aCksXG4gICAgcGFyYWxsZWxSb3V0ZXNbcGFyYWxsZWxSb3V0ZUtleV1cbiAgKVxufVxuIl0sIm5hbWVzIjpbInNob3VsZEhhcmROYXZpZ2F0ZSIsImZsaWdodFNlZ21lbnRQYXRoIiwiZmxpZ2h0Um91dGVyU3RhdGUiLCJzZWdtZW50IiwicGFyYWxsZWxSb3V0ZXMiLCJjdXJyZW50U2VnbWVudCIsInBhcmFsbGVsUm91dGVLZXkiLCJtYXRjaFNlZ21lbnQiLCJBcnJheSIsImlzQXJyYXkiLCJsYXN0U2VnbWVudCIsImxlbmd0aCIsImdldE5leHRGbGlnaHRTZWdtZW50UGF0aCJdLCJtYXBwaW5ncyI6Ijs7OytCQVNnQkEsc0JBQUFBOzs7ZUFBQUE7OzttQ0FKeUI7K0JBQ1o7QUFHdEIsU0FBU0EsbUJBQ2RDLGlCQUFpQyxFQUNqQ0MsaUJBQW9DO0lBRXBDLE1BQU0sQ0FBQ0MsU0FBU0MsZUFBZSxHQUFHRjtJQUNsQywyQ0FBMkM7SUFDM0MsTUFBTSxDQUFDRyxnQkFBZ0JDLGlCQUFpQixHQUFHTDtJQUszQyx5REFBeUQ7SUFDekQsSUFBSSxDQUFDTSxDQUFBQSxHQUFBQSxlQUFBQSxZQUFZLEVBQUNGLGdCQUFnQkYsVUFBVTtRQUMxQyxrR0FBa0c7UUFDbEcsSUFBSUssTUFBTUMsT0FBTyxDQUFDSixpQkFBaUI7WUFDakMsT0FBTztRQUNUO1FBRUEsc0VBQXNFO1FBQ3RFLE9BQU87SUFDVDtJQUNBLE1BQU1LLGNBQWNULGtCQUFrQlUsTUFBTSxJQUFJO0lBRWhELElBQUlELGFBQWE7UUFDZixPQUFPO0lBQ1Q7SUFFQSxPQUFPVixtQkFDTFksQ0FBQUEsR0FBQUEsbUJBQUFBLHdCQUF3QixFQUFDWCxvQkFDekJHLGNBQWMsQ0FBQ0UsaUJBQWlCO0FBRXBDIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDQyNDQsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvaXMtbmF2aWdhdGluZy10by1uZXctcm9vdC1sYXlvdXQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBGbGlnaHRSb3V0ZXJTdGF0ZSB9IGZyb20gJy4uLy4uLy4uL3NlcnZlci9hcHAtcmVuZGVyL3R5cGVzJ1xuXG5leHBvcnQgZnVuY3Rpb24gaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0KFxuICBjdXJyZW50VHJlZTogRmxpZ2h0Um91dGVyU3RhdGUsXG4gIG5leHRUcmVlOiBGbGlnaHRSb3V0ZXJTdGF0ZVxuKTogYm9vbGVhbiB7XG4gIC8vIENvbXBhcmUgc2VnbWVudHNcbiAgY29uc3QgY3VycmVudFRyZWVTZWdtZW50ID0gY3VycmVudFRyZWVbMF1cbiAgY29uc3QgbmV4dFRyZWVTZWdtZW50ID0gbmV4dFRyZWVbMF1cblxuICAvLyBJZiBhbnkgc2VnbWVudCBpcyBkaWZmZXJlbnQgYmVmb3JlIHdlIGZpbmQgdGhlIHJvb3QgbGF5b3V0LCB0aGUgcm9vdCBsYXlvdXQgaGFzIGNoYW5nZWQuXG4gIC8vIEUuZy4gL3NhbWUvKGdyb3VwMSkvbGF5b3V0LmpzIC0+IC9zYW1lLyhncm91cDIpL2xheW91dC5qc1xuICAvLyBGaXJzdCBzZWdtZW50IGlzICdzYW1lJyBmb3IgYm90aCwga2VlcCBsb29raW5nLiAoZ3JvdXAxKSBjaGFuZ2VkIHRvIChncm91cDIpIGJlZm9yZSB0aGUgcm9vdCBsYXlvdXQgd2FzIGZvdW5kLCBpdCBtdXN0IGhhdmUgY2hhbmdlZC5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudFRyZWVTZWdtZW50KSAmJiBBcnJheS5pc0FycmF5KG5leHRUcmVlU2VnbWVudCkpIHtcbiAgICAvLyBDb21wYXJlIGR5bmFtaWMgcGFyYW0gbmFtZSBhbmQgdHlwZSBidXQgaWdub3JlIHRoZSB2YWx1ZSwgZGlmZmVyZW50IHZhbHVlcyB3b3VsZCBub3QgYWZmZWN0IHRoZSBjdXJyZW50IHJvb3QgbGF5b3V0XG4gICAgLy8gL1tuYW1lXSAtIC9zbHVnMSBhbmQgL3NsdWcyLCBib3RoIHZhbHVlcyAoc2x1ZzEgJiBzbHVnMikgc3RpbGwgaGFzIHRoZSBzYW1lIGxheW91dCAvW25hbWVdL2xheW91dC5qc1xuICAgIGlmIChcbiAgICAgIGN1cnJlbnRUcmVlU2VnbWVudFswXSAhPT0gbmV4dFRyZWVTZWdtZW50WzBdIHx8XG4gICAgICBjdXJyZW50VHJlZVNlZ21lbnRbMl0gIT09IG5leHRUcmVlU2VnbWVudFsyXVxuICAgICkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH0gZWxzZSBpZiAoY3VycmVudFRyZWVTZWdtZW50ICE9PSBuZXh0VHJlZVNlZ21lbnQpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gQ3VycmVudCB0cmVlIHJvb3QgbGF5b3V0IGZvdW5kXG4gIGlmIChjdXJyZW50VHJlZVs0XSkge1xuICAgIC8vIElmIHRoZSBuZXh0IHRyZWUgZG9lc24ndCBoYXZlIHRoZSByb290IGxheW91dCBmbGFnLCBpdCBtdXN0IGhhdmUgY2hhbmdlZC5cbiAgICByZXR1cm4gIW5leHRUcmVlWzRdXG4gIH1cbiAgLy8gQ3VycmVudCB0cmVlIGRpZG4ndCBoYXZlIGl0cyByb290IGxheW91dCBoZXJlLCBtdXN0IGhhdmUgY2hhbmdlZC5cbiAgaWYgKG5leHRUcmVlWzRdKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICAvLyBXZSBjYW4ndCBhc3N1bWUgaXQncyBgcGFyYWxsZWxSb3V0ZXMuY2hpbGRyZW5gIGhlcmUgaW4gY2FzZSB0aGUgcm9vdCBsYXlvdXQgaXMgYGFwcC9Ac29tZXRoaW5nL2xheW91dC5qc2BcbiAgLy8gQnV0IGl0J3Mgbm90IHBvc3NpYmxlIHRvIGJlIG1vcmUgdGhhbiBvbmUgcGFyYWxsZWxSb3V0ZXMgYmVmb3JlIHRoZSByb290IGxheW91dCBpcyBmb3VuZFxuICAvLyBUT0RPLUFQUDogY2hhbmdlIHRvIHRyYXZlcnNlIGFsbCBwYXJhbGxlbCByb3V0ZXNcbiAgY29uc3QgY3VycmVudFRyZWVDaGlsZCA9IE9iamVjdC52YWx1ZXMoY3VycmVudFRyZWVbMV0pWzBdXG4gIGNvbnN0IG5leHRUcmVlQ2hpbGQgPSBPYmplY3QudmFsdWVzKG5leHRUcmVlWzFdKVswXVxuICBpZiAoIWN1cnJlbnRUcmVlQ2hpbGQgfHwgIW5leHRUcmVlQ2hpbGQpIHJldHVybiB0cnVlXG4gIHJldHVybiBpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQoY3VycmVudFRyZWVDaGlsZCwgbmV4dFRyZWVDaGlsZClcbn1cbiJdLCJuYW1lcyI6WyJpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQiLCJjdXJyZW50VHJlZSIsIm5leHRUcmVlIiwiY3VycmVudFRyZWVTZWdtZW50IiwibmV4dFRyZWVTZWdtZW50IiwiQXJyYXkiLCJpc0FycmF5IiwiY3VycmVudFRyZWVDaGlsZCIsIk9iamVjdCIsInZhbHVlcyIsIm5leHRUcmVlQ2hpbGQiXSwibWFwcGluZ3MiOiI7OzsrQkFFZ0JBLCtCQUFBQTs7O2VBQUFBOzs7QUFBVCxTQUFTQSw0QkFDZEMsV0FBOEIsRUFDOUJDLFFBQTJCO0lBRTNCLG1CQUFtQjtJQUNuQixNQUFNQyxxQkFBcUJGLFdBQVcsQ0FBQyxFQUFFO0lBQ3pDLE1BQU1HLGtCQUFrQkYsUUFBUSxDQUFDLEVBQUU7SUFFbkMsMkZBQTJGO0lBQzNGLDREQUE0RDtJQUM1RCx1SUFBdUk7SUFDdkksSUFBSUcsTUFBTUMsT0FBTyxDQUFDSCx1QkFBdUJFLE1BQU1DLE9BQU8sQ0FBQ0Ysa0JBQWtCO1FBQ3ZFLHNIQUFzSDtRQUN0SCx1R0FBdUc7UUFDdkcsSUFDRUQsa0JBQWtCLENBQUMsRUFBRSxLQUFLQyxlQUFlLENBQUMsRUFBRSxJQUM1Q0Qsa0JBQWtCLENBQUMsRUFBRSxLQUFLQyxlQUFlLENBQUMsRUFBRSxFQUM1QztZQUNBLE9BQU87UUFDVDtJQUNGLE9BQU8sSUFBSUQsdUJBQXVCQyxpQkFBaUI7UUFDakQsT0FBTztJQUNUO0lBRUEsaUNBQWlDO0lBQ2pDLElBQUlILFdBQVcsQ0FBQyxFQUFFLEVBQUU7UUFDbEIsNEVBQTRFO1FBQzVFLE9BQU8sQ0FBQ0MsUUFBUSxDQUFDLEVBQUU7SUFDckI7SUFDQSxvRUFBb0U7SUFDcEUsSUFBSUEsUUFBUSxDQUFDLEVBQUUsRUFBRTtRQUNmLE9BQU87SUFDVDtJQUNBLDRHQUE0RztJQUM1RywyRkFBMkY7SUFDM0YsbURBQW1EO0lBQ25ELE1BQU1LLG1CQUFtQkMsT0FBT0MsTUFBTSxDQUFDUixXQUFXLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRTtJQUN6RCxNQUFNUyxnQkFBZ0JGLE9BQU9DLE1BQU0sQ0FBQ1AsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUU7SUFDbkQsSUFBSSxDQUFDSyxvQkFBb0IsQ0FBQ0csZUFBZSxPQUFPO0lBQ2hELE9BQU9WLDRCQUE0Qk8sa0JBQWtCRztBQUN2RCIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA0Mjk5LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL3NoYXJlZC9saWIvcGFnZS1wYXRoL2Vuc3VyZS1sZWFkaW5nLXNsYXNoLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRm9yIGEgZ2l2ZW4gcGFnZSBwYXRoLCB0aGlzIGZ1bmN0aW9uIGVuc3VyZXMgdGhhdCB0aGVyZSBpcyBhIGxlYWRpbmcgc2xhc2guXG4gKiBJZiB0aGVyZSBpcyBub3QgYSBsZWFkaW5nIHNsYXNoLCBvbmUgaXMgYWRkZWQsIG90aGVyd2lzZSBpdCBpcyBub29wLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5zdXJlTGVhZGluZ1NsYXNoKHBhdGg6IHN0cmluZykge1xuICByZXR1cm4gcGF0aC5zdGFydHNXaXRoKCcvJykgPyBwYXRoIDogYC8ke3BhdGh9YFxufVxuIl0sIm5hbWVzIjpbImVuc3VyZUxlYWRpbmdTbGFzaCIsInBhdGgiLCJzdGFydHNXaXRoIl0sIm1hcHBpbmdzIjoiQUFBQTs7O0NBR0M7OzsrQkFDZUEsc0JBQUFBOzs7ZUFBQUE7OztBQUFULFNBQVNBLG1CQUFtQkMsSUFBWTtJQUM3QyxPQUFPQSxLQUFLQyxVQUFVLENBQUMsT0FBT0QsT0FBUSxNQUFHQTtBQUMzQyIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA0MzIwLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2FwcC1wYXRocy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBlbnN1cmVMZWFkaW5nU2xhc2ggfSBmcm9tICcuLi8uLi9wYWdlLXBhdGgvZW5zdXJlLWxlYWRpbmctc2xhc2gnXG5pbXBvcnQgeyBpc0dyb3VwU2VnbWVudCB9IGZyb20gJy4uLy4uL3NlZ21lbnQnXG5cbi8qKlxuICogTm9ybWFsaXplcyBhbiBhcHAgcm91dGUgc28gaXQgcmVwcmVzZW50cyB0aGUgYWN0dWFsIHJlcXVlc3QgcGF0aC4gRXNzZW50aWFsbHlcbiAqIHBlcmZvcm1pbmcgdGhlIGZvbGxvd2luZyB0cmFuc2Zvcm1hdGlvbnM6XG4gKlxuICogLSBgLyhkYXNoYm9hcmQpL3VzZXIvW2lkXS9wYWdlYCB0byBgL3VzZXIvW2lkXWBcbiAqIC0gYC8oZGFzaGJvYXJkKS9hY2NvdW50L3BhZ2VgIHRvIGAvYWNjb3VudGBcbiAqIC0gYC91c2VyL1tpZF0vcGFnZWAgdG8gYC91c2VyL1tpZF1gXG4gKiAtIGAvYWNjb3VudC9wYWdlYCB0byBgL2FjY291bnRgXG4gKiAtIGAvcGFnZWAgdG8gYC9gXG4gKiAtIGAvKGRhc2hib2FyZCkvdXNlci9baWRdL3JvdXRlYCB0byBgL3VzZXIvW2lkXWBcbiAqIC0gYC8oZGFzaGJvYXJkKS9hY2NvdW50L3JvdXRlYCB0byBgL2FjY291bnRgXG4gKiAtIGAvdXNlci9baWRdL3JvdXRlYCB0byBgL3VzZXIvW2lkXWBcbiAqIC0gYC9hY2NvdW50L3JvdXRlYCB0byBgL2FjY291bnRgXG4gKiAtIGAvcm91dGVgIHRvIGAvYFxuICogLSBgL2AgdG8gYC9gXG4gKlxuICogQHBhcmFtIHJvdXRlIHRoZSBhcHAgcm91dGUgdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB0aGUgbm9ybWFsaXplZCBwYXRobmFtZVxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplQXBwUGF0aChyb3V0ZTogc3RyaW5nKSB7XG4gIHJldHVybiBlbnN1cmVMZWFkaW5nU2xhc2goXG4gICAgcm91dGUuc3BsaXQoJy8nKS5yZWR1Y2UoKHBhdGhuYW1lLCBzZWdtZW50LCBpbmRleCwgc2VnbWVudHMpID0+IHtcbiAgICAgIC8vIEVtcHR5IHNlZ21lbnRzIGFyZSBpZ25vcmVkLlxuICAgICAgaWYgKCFzZWdtZW50KSB7XG4gICAgICAgIHJldHVybiBwYXRobmFtZVxuICAgICAgfVxuXG4gICAgICAvLyBHcm91cHMgYXJlIGlnbm9yZWQuXG4gICAgICBpZiAoaXNHcm91cFNlZ21lbnQoc2VnbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIHBhdGhuYW1lXG4gICAgICB9XG5cbiAgICAgIC8vIFBhcmFsbGVsIHNlZ21lbnRzIGFyZSBpZ25vcmVkLlxuICAgICAgaWYgKHNlZ21lbnRbMF0gPT09ICdAJykge1xuICAgICAgICByZXR1cm4gcGF0aG5hbWVcbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGxhc3Qgc2VnbWVudCAoaWYgaXQncyBhIGxlYWYpIHNob3VsZCBiZSBpZ25vcmVkLlxuICAgICAgaWYgKFxuICAgICAgICAoc2VnbWVudCA9PT0gJ3BhZ2UnIHx8IHNlZ21lbnQgPT09ICdyb3V0ZScpICYmXG4gICAgICAgIGluZGV4ID09PSBzZWdtZW50cy5sZW5ndGggLSAxXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHBhdGhuYW1lXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBgJHtwYXRobmFtZX0vJHtzZWdtZW50fWBcbiAgICB9LCAnJylcbiAgKVxufVxuXG4vKipcbiAqIFN0cmlwcyB0aGUgYC5yc2NgIGV4dGVuc2lvbiBpZiBpdCdzIGluIHRoZSBwYXRobmFtZS5cbiAqIFNpbmNlIHRoaXMgZnVuY3Rpb24gaXMgdXNlZCBvbiBmdWxsIHVybHMgaXQgY2hlY2tzIGA/YCBmb3Igc2VhcmNoUGFyYW1zIGhhbmRsaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplUnNjVVJMKHVybDogc3RyaW5nKSB7XG4gIHJldHVybiB1cmwucmVwbGFjZShcbiAgICAvXFwucnNjKCR8XFw/KS8sXG4gICAgLy8gJDEgZW5zdXJlcyBgP2AgaXMgcHJlc2VydmVkXG4gICAgJyQxJ1xuICApXG59XG4iXSwibmFtZXMiOlsibm9ybWFsaXplQXBwUGF0aCIsIm5vcm1hbGl6ZVJzY1VSTCIsInJvdXRlIiwiZW5zdXJlTGVhZGluZ1NsYXNoIiwic3BsaXQiLCJyZWR1Y2UiLCJwYXRobmFtZSIsInNlZ21lbnQiLCJpbmRleCIsInNlZ21lbnRzIiwiaXNHcm91cFNlZ21lbnQiLCJsZW5ndGgiLCJ1cmwiLCJyZXBsYWNlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztJQXNCZ0JBLGdCQUFnQixFQUFBO2VBQWhCQTs7SUFtQ0FDLGVBQWUsRUFBQTtlQUFmQTs7O29DQXpEbUI7eUJBQ0o7QUFxQnhCLFNBQVNELGlCQUFpQkUsS0FBYTtJQUM1QyxPQUFPQyxDQUFBQSxHQUFBQSxvQkFBQUEsa0JBQWtCLEVBQ3ZCRCxNQUFNRSxLQUFLLENBQUMsS0FBS0MsTUFBTSxDQUFDLENBQUNDLFVBQVVDLFNBQVNDLE9BQU9DO1FBQ2pELDhCQUE4QjtRQUM5QixJQUFJLENBQUNGLFNBQVM7WUFDWixPQUFPRDtRQUNUO1FBRUEsc0JBQXNCO1FBQ3RCLElBQUlJLENBQUFBLEdBQUFBLFNBQUFBLGNBQWMsRUFBQ0gsVUFBVTtZQUMzQixPQUFPRDtRQUNUO1FBRUEsaUNBQWlDO1FBQ2pDLElBQUlDLE9BQU8sQ0FBQyxFQUFFLEtBQUssS0FBSztZQUN0QixPQUFPRDtRQUNUO1FBRUEsdURBQXVEO1FBQ3ZELElBQ0dDLENBQUFBLFlBQVksVUFBVUEsWUFBWSxPQUFNLEtBQ3pDQyxVQUFVQyxTQUFTRSxNQUFNLEdBQUcsR0FDNUI7WUFDQSxPQUFPTDtRQUNUO1FBRUEsT0FBVUEsV0FBUyxNQUFHQztJQUN4QixHQUFHO0FBRVA7QUFNTyxTQUFTTixnQkFBZ0JXLEdBQVc7SUFDekMsT0FBT0EsSUFBSUMsT0FBTyxDQUNoQixlQUNBLEFBQ0EsOEJBRDhCO0FBR2xDIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDQzNzMsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaW50ZXJjZXB0aW9uLXJvdXRlcy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBub3JtYWxpemVBcHBQYXRoIH0gZnJvbSAnLi9hcHAtcGF0aHMnXG5cbi8vIG9yZGVyIG1hdHRlcnMgaGVyZSwgdGhlIGZpcnN0IG1hdGNoIHdpbGwgYmUgdXNlZFxuZXhwb3J0IGNvbnN0IElOVEVSQ0VQVElPTl9ST1VURV9NQVJLRVJTID0gW1xuICAnKC4uKSguLiknLFxuICAnKC4pJyxcbiAgJyguLiknLFxuICAnKC4uLiknLFxuXSBhcyBjb25zdFxuXG5leHBvcnQgZnVuY3Rpb24gaXNJbnRlcmNlcHRpb25Sb3V0ZUFwcFBhdGgocGF0aDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIC8vIFRPRE8tQVBQOiBhZGQgbW9yZSBzZXJpb3VzIHZhbGlkYXRpb25cbiAgcmV0dXJuIChcbiAgICBwYXRoXG4gICAgICAuc3BsaXQoJy8nKVxuICAgICAgLmZpbmQoKHNlZ21lbnQpID0+XG4gICAgICAgIElOVEVSQ0VQVElPTl9ST1VURV9NQVJLRVJTLmZpbmQoKG0pID0+IHNlZ21lbnQuc3RhcnRzV2l0aChtKSlcbiAgICAgICkgIT09IHVuZGVmaW5lZFxuICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0SW50ZXJjZXB0aW9uUm91dGVJbmZvcm1hdGlvbihwYXRoOiBzdHJpbmcpIHtcbiAgbGV0IGludGVyY2VwdGluZ1JvdXRlOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgbWFya2VyOiAodHlwZW9mIElOVEVSQ0VQVElPTl9ST1VURV9NQVJLRVJTKVtudW1iZXJdIHwgdW5kZWZpbmVkLFxuICAgIGludGVyY2VwdGVkUm91dGU6IHN0cmluZyB8IHVuZGVmaW5lZFxuXG4gIGZvciAoY29uc3Qgc2VnbWVudCBvZiBwYXRoLnNwbGl0KCcvJykpIHtcbiAgICBtYXJrZXIgPSBJTlRFUkNFUFRJT05fUk9VVEVfTUFSS0VSUy5maW5kKChtKSA9PiBzZWdtZW50LnN0YXJ0c1dpdGgobSkpXG4gICAgaWYgKG1hcmtlcikge1xuICAgICAgO1tpbnRlcmNlcHRpbmdSb3V0ZSwgaW50ZXJjZXB0ZWRSb3V0ZV0gPSBwYXRoLnNwbGl0KG1hcmtlciwgMilcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKCFpbnRlcmNlcHRpbmdSb3V0ZSB8fCAhbWFya2VyIHx8ICFpbnRlcmNlcHRlZFJvdXRlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEludmFsaWQgaW50ZXJjZXB0aW9uIHJvdXRlOiAke3BhdGh9LiBNdXN0IGJlIGluIHRoZSBmb3JtYXQgLzxpbnRlcmNlcHRpbmcgcm91dGU+LyguLnwuLi58Li4pKC4uKS88aW50ZXJjZXB0ZWQgcm91dGU+YFxuICAgIClcbiAgfVxuXG4gIGludGVyY2VwdGluZ1JvdXRlID0gbm9ybWFsaXplQXBwUGF0aChpbnRlcmNlcHRpbmdSb3V0ZSkgLy8gbm9ybWFsaXplIHRoZSBwYXRoLCBlLmcuIC8oYmxvZykvZmVlZCAtPiAvZmVlZFxuXG4gIHN3aXRjaCAobWFya2VyKSB7XG4gICAgY2FzZSAnKC4pJzpcbiAgICAgIC8vICguKSBpbmRpY2F0ZXMgdGhhdCB3ZSBzaG91bGQgbWF0Y2ggd2l0aCBzaWJsaW5nIHJvdXRlcywgc28gd2UganVzdCBuZWVkIHRvIGFwcGVuZCB0aGUgaW50ZXJjZXB0ZWQgcm91dGUgdG8gdGhlIGludGVyY2VwdGluZyByb3V0ZVxuICAgICAgaWYgKGludGVyY2VwdGluZ1JvdXRlID09PSAnLycpIHtcbiAgICAgICAgaW50ZXJjZXB0ZWRSb3V0ZSA9IGAvJHtpbnRlcmNlcHRlZFJvdXRlfWBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludGVyY2VwdGVkUm91dGUgPSBpbnRlcmNlcHRpbmdSb3V0ZSArICcvJyArIGludGVyY2VwdGVkUm91dGVcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnKC4uKSc6XG4gICAgICAvLyAoLi4pIGluZGljYXRlcyB0aGF0IHdlIHNob3VsZCBtYXRjaCBhdCBvbmUgbGV2ZWwgdXAsIHNvIHdlIG5lZWQgdG8gcmVtb3ZlIHRoZSBsYXN0IHNlZ21lbnQgb2YgdGhlIGludGVyY2VwdGluZyByb3V0ZVxuICAgICAgaWYgKGludGVyY2VwdGluZ1JvdXRlID09PSAnLycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBJbnZhbGlkIGludGVyY2VwdGlvbiByb3V0ZTogJHtwYXRofS4gQ2Fubm90IHVzZSAoLi4pIG1hcmtlciBhdCB0aGUgcm9vdCBsZXZlbCwgdXNlICguKSBpbnN0ZWFkLmBcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgaW50ZXJjZXB0ZWRSb3V0ZSA9IGludGVyY2VwdGluZ1JvdXRlXG4gICAgICAgIC5zcGxpdCgnLycpXG4gICAgICAgIC5zbGljZSgwLCAtMSlcbiAgICAgICAgLmNvbmNhdChpbnRlcmNlcHRlZFJvdXRlKVxuICAgICAgICAuam9pbignLycpXG4gICAgICBicmVha1xuICAgIGNhc2UgJyguLi4pJzpcbiAgICAgIC8vICguLi4pIHdpbGwgbWF0Y2ggdGhlIHJvdXRlIHNlZ21lbnQgaW4gdGhlIHJvb3QgZGlyZWN0b3J5LCBzbyB3ZSBuZWVkIHRvIHVzZSB0aGUgcm9vdCBkaXJlY3RvcnkgdG8gcHJlcGVuZCB0aGUgaW50ZXJjZXB0ZWQgcm91dGVcbiAgICAgIGludGVyY2VwdGVkUm91dGUgPSAnLycgKyBpbnRlcmNlcHRlZFJvdXRlXG4gICAgICBicmVha1xuICAgIGNhc2UgJyguLikoLi4pJzpcbiAgICAgIC8vICguLikoLi4pIGluZGljYXRlcyB0aGF0IHdlIHNob3VsZCBtYXRjaCBhdCB0d28gbGV2ZWxzIHVwLCBzbyB3ZSBuZWVkIHRvIHJlbW92ZSB0aGUgbGFzdCB0d28gc2VnbWVudHMgb2YgdGhlIGludGVyY2VwdGluZyByb3V0ZVxuXG4gICAgICBjb25zdCBzcGxpdEludGVyY2VwdGluZ1JvdXRlID0gaW50ZXJjZXB0aW5nUm91dGUuc3BsaXQoJy8nKVxuICAgICAgaWYgKHNwbGl0SW50ZXJjZXB0aW5nUm91dGUubGVuZ3RoIDw9IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBJbnZhbGlkIGludGVyY2VwdGlvbiByb3V0ZTogJHtwYXRofS4gQ2Fubm90IHVzZSAoLi4pKC4uKSBtYXJrZXIgYXQgdGhlIHJvb3QgbGV2ZWwgb3Igb25lIGxldmVsIHVwLmBcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICBpbnRlcmNlcHRlZFJvdXRlID0gc3BsaXRJbnRlcmNlcHRpbmdSb3V0ZVxuICAgICAgICAuc2xpY2UoMCwgLTIpXG4gICAgICAgIC5jb25jYXQoaW50ZXJjZXB0ZWRSb3V0ZSlcbiAgICAgICAgLmpvaW4oJy8nKVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhcmlhbnQ6IHVuZXhwZWN0ZWQgbWFya2VyJylcbiAgfVxuXG4gIHJldHVybiB7IGludGVyY2VwdGluZ1JvdXRlLCBpbnRlcmNlcHRlZFJvdXRlIH1cbn1cbiJdLCJuYW1lcyI6WyJJTlRFUkNFUFRJT05fUk9VVEVfTUFSS0VSUyIsImV4dHJhY3RJbnRlcmNlcHRpb25Sb3V0ZUluZm9ybWF0aW9uIiwiaXNJbnRlcmNlcHRpb25Sb3V0ZUFwcFBhdGgiLCJwYXRoIiwic3BsaXQiLCJmaW5kIiwic2VnbWVudCIsIm0iLCJzdGFydHNXaXRoIiwidW5kZWZpbmVkIiwiaW50ZXJjZXB0aW5nUm91dGUiLCJtYXJrZXIiLCJpbnRlcmNlcHRlZFJvdXRlIiwiRXJyb3IiLCJub3JtYWxpemVBcHBQYXRoIiwic2xpY2UiLCJjb25jYXQiLCJqb2luIiwic3BsaXRJbnRlcmNlcHRpbmdSb3V0ZSIsImxlbmd0aCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0lBR2FBLDBCQUEwQixFQUFBO2VBQTFCQTs7SUFrQkdDLG1DQUFtQyxFQUFBO2VBQW5DQTs7SUFYQUMsMEJBQTBCLEVBQUE7ZUFBMUJBOzs7MEJBVmlCO0FBRzFCLE1BQU1GLDZCQUE2QjtJQUN4QztJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBRU0sU0FBU0UsMkJBQTJCQyxJQUFZO0lBQ3JELHdDQUF3QztJQUN4QyxPQUNFQSxLQUNHQyxLQUFLLENBQUMsS0FDTkMsSUFBSSxDQUFDLENBQUNDLFVBQ0xOLDJCQUEyQkssSUFBSSxDQUFDLENBQUNFLElBQU1ELFFBQVFFLFVBQVUsQ0FBQ0QsU0FDdERFO0FBRVo7QUFFTyxTQUFTUixvQ0FBb0NFLElBQVk7SUFDOUQsSUFBSU8sbUJBQ0ZDLFFBQ0FDO0lBRUYsS0FBSyxNQUFNTixXQUFXSCxLQUFLQyxLQUFLLENBQUMsS0FBTTtRQUNyQ08sU0FBU1gsMkJBQTJCSyxJQUFJLENBQUMsQ0FBQ0UsSUFBTUQsUUFBUUUsVUFBVSxDQUFDRDtRQUNuRSxJQUFJSSxRQUFROztZQUNULENBQUNELG1CQUFtQkUsaUJBQWlCLEdBQUdULEtBQUtDLEtBQUssQ0FBQ08sUUFBUTtZQUM1RDtRQUNGO0lBQ0Y7SUFFQSxJQUFJLENBQUNELHFCQUFxQixDQUFDQyxVQUFVLENBQUNDLGtCQUFrQjtRQUN0RCxNQUFNLE9BQUEsY0FFTCxDQUZLLElBQUlDLE1BQ1AsaUNBQThCVixPQUFLLHNGQURoQyxxQkFBQTttQkFBQTt3QkFBQTswQkFBQTtRQUVOO0lBQ0Y7SUFFQU8sb0JBQW9CSSxDQUFBQSxHQUFBQSxVQUFBQSxnQkFBZ0IsRUFBQ0osbUJBQW1CLGlEQUFpRDs7SUFFekcsT0FBUUM7UUFDTixLQUFLO1lBQ0gsb0lBQW9JO1lBQ3BJLElBQUlELHNCQUFzQixLQUFLO2dCQUM3QkUsbUJBQW9CLE1BQUdBO1lBQ3pCLE9BQU87Z0JBQ0xBLG1CQUFtQkYsb0JBQW9CLE1BQU1FO1lBQy9DO1lBQ0E7UUFDRixLQUFLO1lBQ0gsdUhBQXVIO1lBQ3ZILElBQUlGLHNCQUFzQixLQUFLO2dCQUM3QixNQUFNLE9BQUEsY0FFTCxDQUZLLElBQUlHLE1BQ1AsaUNBQThCVixPQUFLLGlFQURoQyxxQkFBQTsyQkFBQTtnQ0FBQTtrQ0FBQTtnQkFFTjtZQUNGO1lBQ0FTLG1CQUFtQkYsa0JBQ2hCTixLQUFLLENBQUMsS0FDTlcsS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUNWQyxNQUFNLENBQUNKLGtCQUNQSyxJQUFJLENBQUM7WUFDUjtRQUNGLEtBQUs7WUFDSCxrSUFBa0k7WUFDbElMLG1CQUFtQixNQUFNQTtZQUN6QjtRQUNGLEtBQUs7WUFDSCxpSUFBaUk7WUFFakksTUFBTU0seUJBQXlCUixrQkFBa0JOLEtBQUssQ0FBQztZQUN2RCxJQUFJYyx1QkFBdUJDLE1BQU0sSUFBSSxHQUFHO2dCQUN0QyxNQUFNLE9BQUEsY0FFTCxDQUZLLElBQUlOLE1BQ1AsaUNBQThCVixPQUFLLG9FQURoQyxxQkFBQTsyQkFBQTtnQ0FBQTtrQ0FBQTtnQkFFTjtZQUNGO1lBRUFTLG1CQUFtQk0sdUJBQ2hCSCxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQ1ZDLE1BQU0sQ0FBQ0osa0JBQ1BLLElBQUksQ0FBQztZQUNSO1FBQ0Y7WUFDRSxNQUFNLE9BQUEsY0FBeUMsQ0FBekMsSUFBSUosTUFBTSxpQ0FBVixxQkFBQTt1QkFBQTs0QkFBQTs4QkFBQTtZQUF3QztJQUNsRDtJQUVBLE9BQU87UUFBRUg7UUFBbUJFO0lBQWlCO0FBQy9DIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDQ0ODIsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvY29tcHV0ZS1jaGFuZ2VkLXBhdGgudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUge1xuICBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgU2VnbWVudCxcbn0gZnJvbSAnLi4vLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvdHlwZXMnXG5pbXBvcnQgeyBJTlRFUkNFUFRJT05fUk9VVEVfTUFSS0VSUyB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2ludGVyY2VwdGlvbi1yb3V0ZXMnXG5pbXBvcnQgdHlwZSB7IFBhcmFtcyB9IGZyb20gJy4uLy4uLy4uL3NlcnZlci9yZXF1ZXN0L3BhcmFtcydcbmltcG9ydCB7XG4gIGlzR3JvdXBTZWdtZW50LFxuICBERUZBVUxUX1NFR01FTlRfS0VZLFxuICBQQUdFX1NFR01FTlRfS0VZLFxufSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvbGliL3NlZ21lbnQnXG5pbXBvcnQgeyBtYXRjaFNlZ21lbnQgfSBmcm9tICcuLi9tYXRjaC1zZWdtZW50cydcblxuY29uc3QgcmVtb3ZlTGVhZGluZ1NsYXNoID0gKHNlZ21lbnQ6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gIHJldHVybiBzZWdtZW50WzBdID09PSAnLycgPyBzZWdtZW50LnNsaWNlKDEpIDogc2VnbWVudFxufVxuXG5jb25zdCBzZWdtZW50VG9QYXRobmFtZSA9IChzZWdtZW50OiBTZWdtZW50KTogc3RyaW5nID0+IHtcbiAgaWYgKHR5cGVvZiBzZWdtZW50ID09PSAnc3RyaW5nJykge1xuICAgIC8vICdjaGlsZHJlbicgaXMgbm90IGEgdmFsaWQgcGF0aCAtLSBpdCdzIHRlY2huaWNhbGx5IGEgcGFyYWxsZWwgcm91dGUgdGhhdCBjb3JyZXNwb25kcyB3aXRoIHRoZSBjdXJyZW50IHNlZ21lbnQncyBwYWdlXG4gICAgLy8gaWYgd2UgZG9uJ3Qgc2tpcCBpdCwgdGhlbiB0aGUgY29tcHV0ZWQgcGF0aG5hbWUgbWlnaHQgYmUgc29tZXRoaW5nIGxpa2UgYC9jaGlsZHJlbmAgd2hpY2ggZG9lc24ndCBtYWtlIHNlbnNlLlxuICAgIGlmIChzZWdtZW50ID09PSAnY2hpbGRyZW4nKSByZXR1cm4gJydcblxuICAgIHJldHVybiBzZWdtZW50XG4gIH1cblxuICByZXR1cm4gc2VnbWVudFsxXVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVTZWdtZW50cyhzZWdtZW50czogc3RyaW5nW10pOiBzdHJpbmcge1xuICByZXR1cm4gKFxuICAgIHNlZ21lbnRzLnJlZHVjZSgoYWNjLCBzZWdtZW50KSA9PiB7XG4gICAgICBzZWdtZW50ID0gcmVtb3ZlTGVhZGluZ1NsYXNoKHNlZ21lbnQpXG4gICAgICBpZiAoc2VnbWVudCA9PT0gJycgfHwgaXNHcm91cFNlZ21lbnQoc2VnbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIGFjY1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYCR7YWNjfS8ke3NlZ21lbnR9YFxuICAgIH0sICcnKSB8fCAnLydcbiAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdFBhdGhGcm9tRmxpZ2h0Um91dGVyU3RhdGUoXG4gIGZsaWdodFJvdXRlclN0YXRlOiBGbGlnaHRSb3V0ZXJTdGF0ZVxuKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgY29uc3Qgc2VnbWVudCA9IEFycmF5LmlzQXJyYXkoZmxpZ2h0Um91dGVyU3RhdGVbMF0pXG4gICAgPyBmbGlnaHRSb3V0ZXJTdGF0ZVswXVsxXVxuICAgIDogZmxpZ2h0Um91dGVyU3RhdGVbMF1cblxuICBpZiAoXG4gICAgc2VnbWVudCA9PT0gREVGQVVMVF9TRUdNRU5UX0tFWSB8fFxuICAgIElOVEVSQ0VQVElPTl9ST1VURV9NQVJLRVJTLnNvbWUoKG0pID0+IHNlZ21lbnQuc3RhcnRzV2l0aChtKSlcbiAgKVxuICAgIHJldHVybiB1bmRlZmluZWRcblxuICBpZiAoc2VnbWVudC5zdGFydHNXaXRoKFBBR0VfU0VHTUVOVF9LRVkpKSByZXR1cm4gJydcblxuICBjb25zdCBzZWdtZW50cyA9IFtzZWdtZW50VG9QYXRobmFtZShzZWdtZW50KV1cbiAgY29uc3QgcGFyYWxsZWxSb3V0ZXMgPSBmbGlnaHRSb3V0ZXJTdGF0ZVsxXSA/PyB7fVxuXG4gIGNvbnN0IGNoaWxkcmVuUGF0aCA9IHBhcmFsbGVsUm91dGVzLmNoaWxkcmVuXG4gICAgPyBleHRyYWN0UGF0aEZyb21GbGlnaHRSb3V0ZXJTdGF0ZShwYXJhbGxlbFJvdXRlcy5jaGlsZHJlbilcbiAgICA6IHVuZGVmaW5lZFxuXG4gIGlmIChjaGlsZHJlblBhdGggIT09IHVuZGVmaW5lZCkge1xuICAgIHNlZ21lbnRzLnB1c2goY2hpbGRyZW5QYXRoKVxuICB9IGVsc2Uge1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHBhcmFsbGVsUm91dGVzKSkge1xuICAgICAgaWYgKGtleSA9PT0gJ2NoaWxkcmVuJykgY29udGludWVcblxuICAgICAgY29uc3QgY2hpbGRQYXRoID0gZXh0cmFjdFBhdGhGcm9tRmxpZ2h0Um91dGVyU3RhdGUodmFsdWUpXG5cbiAgICAgIGlmIChjaGlsZFBhdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZWdtZW50cy5wdXNoKGNoaWxkUGF0aClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbm9ybWFsaXplU2VnbWVudHMoc2VnbWVudHMpXG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVDaGFuZ2VkUGF0aEltcGwoXG4gIHRyZWVBOiBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgdHJlZUI6IEZsaWdodFJvdXRlclN0YXRlXG4pOiBzdHJpbmcgfCBudWxsIHtcbiAgY29uc3QgW3NlZ21lbnRBLCBwYXJhbGxlbFJvdXRlc0FdID0gdHJlZUFcbiAgY29uc3QgW3NlZ21lbnRCLCBwYXJhbGxlbFJvdXRlc0JdID0gdHJlZUJcblxuICBjb25zdCBub3JtYWxpemVkU2VnbWVudEEgPSBzZWdtZW50VG9QYXRobmFtZShzZWdtZW50QSlcbiAgY29uc3Qgbm9ybWFsaXplZFNlZ21lbnRCID0gc2VnbWVudFRvUGF0aG5hbWUoc2VnbWVudEIpXG5cbiAgaWYgKFxuICAgIElOVEVSQ0VQVElPTl9ST1VURV9NQVJLRVJTLnNvbWUoXG4gICAgICAobSkgPT5cbiAgICAgICAgbm9ybWFsaXplZFNlZ21lbnRBLnN0YXJ0c1dpdGgobSkgfHwgbm9ybWFsaXplZFNlZ21lbnRCLnN0YXJ0c1dpdGgobSlcbiAgICApXG4gICkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFtYXRjaFNlZ21lbnQoc2VnbWVudEEsIHNlZ21lbnRCKSkge1xuICAgIC8vIG9uY2Ugd2UgZmluZCB3aGVyZSB0aGUgdHJlZSBjaGFuZ2VkLCB3ZSBjb21wdXRlIHRoZSByZXN0IG9mIHRoZSBwYXRoIGJ5IHRyYXZlcnNpbmcgdGhlIHRyZWVcbiAgICByZXR1cm4gZXh0cmFjdFBhdGhGcm9tRmxpZ2h0Um91dGVyU3RhdGUodHJlZUIpID8/ICcnXG4gIH1cblxuICBmb3IgKGNvbnN0IHBhcmFsbGVsUm91dGVyS2V5IGluIHBhcmFsbGVsUm91dGVzQSkge1xuICAgIGlmIChwYXJhbGxlbFJvdXRlc0JbcGFyYWxsZWxSb3V0ZXJLZXldKSB7XG4gICAgICBjb25zdCBjaGFuZ2VkUGF0aCA9IGNvbXB1dGVDaGFuZ2VkUGF0aEltcGwoXG4gICAgICAgIHBhcmFsbGVsUm91dGVzQVtwYXJhbGxlbFJvdXRlcktleV0sXG4gICAgICAgIHBhcmFsbGVsUm91dGVzQltwYXJhbGxlbFJvdXRlcktleV1cbiAgICAgIClcbiAgICAgIGlmIChjaGFuZ2VkUGF0aCAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gYCR7c2VnbWVudFRvUGF0aG5hbWUoc2VnbWVudEIpfS8ke2NoYW5nZWRQYXRofWBcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUNoYW5nZWRQYXRoKFxuICB0cmVlQTogRmxpZ2h0Um91dGVyU3RhdGUsXG4gIHRyZWVCOiBGbGlnaHRSb3V0ZXJTdGF0ZVxuKTogc3RyaW5nIHwgbnVsbCB7XG4gIGNvbnN0IGNoYW5nZWRQYXRoID0gY29tcHV0ZUNoYW5nZWRQYXRoSW1wbCh0cmVlQSwgdHJlZUIpXG5cbiAgaWYgKGNoYW5nZWRQYXRoID09IG51bGwgfHwgY2hhbmdlZFBhdGggPT09ICcvJykge1xuICAgIHJldHVybiBjaGFuZ2VkUGF0aFxuICB9XG5cbiAgLy8gbGlnaHR3ZWlnaHQgbm9ybWFsaXphdGlvbiB0byByZW1vdmUgcm91dGUgZ3JvdXBzXG4gIHJldHVybiBub3JtYWxpemVTZWdtZW50cyhjaGFuZ2VkUGF0aC5zcGxpdCgnLycpKVxufVxuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IGV4dHJhY3RzIGR5bmFtaWMgcGFyYW1ldGVycyBmcm9tIEZsaWdodFJvdXRlclN0YXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2VsZWN0ZWRQYXJhbXMoXG4gIGN1cnJlbnRUcmVlOiBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgcGFyYW1zOiBQYXJhbXMgPSB7fVxuKTogUGFyYW1zIHtcbiAgY29uc3QgcGFyYWxsZWxSb3V0ZXMgPSBjdXJyZW50VHJlZVsxXVxuXG4gIGZvciAoY29uc3QgcGFyYWxsZWxSb3V0ZSBvZiBPYmplY3QudmFsdWVzKHBhcmFsbGVsUm91dGVzKSkge1xuICAgIGNvbnN0IHNlZ21lbnQgPSBwYXJhbGxlbFJvdXRlWzBdXG4gICAgY29uc3QgaXNEeW5hbWljUGFyYW1ldGVyID0gQXJyYXkuaXNBcnJheShzZWdtZW50KVxuICAgIGNvbnN0IHNlZ21lbnRWYWx1ZSA9IGlzRHluYW1pY1BhcmFtZXRlciA/IHNlZ21lbnRbMV0gOiBzZWdtZW50XG4gICAgaWYgKCFzZWdtZW50VmFsdWUgfHwgc2VnbWVudFZhbHVlLnN0YXJ0c1dpdGgoUEFHRV9TRUdNRU5UX0tFWSkpIGNvbnRpbnVlXG5cbiAgICAvLyBFbnN1cmUgY2F0Y2hBbGwgYW5kIG9wdGlvbmFsIGNhdGNoYWxsIGFyZSB0dXJuZWQgaW50byBhbiBhcnJheVxuICAgIGNvbnN0IGlzQ2F0Y2hBbGwgPVxuICAgICAgaXNEeW5hbWljUGFyYW1ldGVyICYmIChzZWdtZW50WzJdID09PSAnYycgfHwgc2VnbWVudFsyXSA9PT0gJ29jJylcblxuICAgIGlmIChpc0NhdGNoQWxsKSB7XG4gICAgICBwYXJhbXNbc2VnbWVudFswXV0gPSBzZWdtZW50WzFdLnNwbGl0KCcvJylcbiAgICB9IGVsc2UgaWYgKGlzRHluYW1pY1BhcmFtZXRlcikge1xuICAgICAgcGFyYW1zW3NlZ21lbnRbMF1dID0gc2VnbWVudFsxXVxuICAgIH1cblxuICAgIHBhcmFtcyA9IGdldFNlbGVjdGVkUGFyYW1zKHBhcmFsbGVsUm91dGUsIHBhcmFtcylcbiAgfVxuXG4gIHJldHVybiBwYXJhbXNcbn1cbiJdLCJuYW1lcyI6WyJjb21wdXRlQ2hhbmdlZFBhdGgiLCJleHRyYWN0UGF0aEZyb21GbGlnaHRSb3V0ZXJTdGF0ZSIsImdldFNlbGVjdGVkUGFyYW1zIiwicmVtb3ZlTGVhZGluZ1NsYXNoIiwic2VnbWVudCIsInNsaWNlIiwic2VnbWVudFRvUGF0aG5hbWUiLCJub3JtYWxpemVTZWdtZW50cyIsInNlZ21lbnRzIiwicmVkdWNlIiwiYWNjIiwiaXNHcm91cFNlZ21lbnQiLCJmbGlnaHRSb3V0ZXJTdGF0ZSIsIkFycmF5IiwiaXNBcnJheSIsIkRFRkFVTFRfU0VHTUVOVF9LRVkiLCJJTlRFUkNFUFRJT05fUk9VVEVfTUFSS0VSUyIsInNvbWUiLCJtIiwic3RhcnRzV2l0aCIsInVuZGVmaW5lZCIsIlBBR0VfU0VHTUVOVF9LRVkiLCJwYXJhbGxlbFJvdXRlcyIsImNoaWxkcmVuUGF0aCIsImNoaWxkcmVuIiwicHVzaCIsImtleSIsInZhbHVlIiwiT2JqZWN0IiwiZW50cmllcyIsImNoaWxkUGF0aCIsImNvbXB1dGVDaGFuZ2VkUGF0aEltcGwiLCJ0cmVlQSIsInRyZWVCIiwic2VnbWVudEEiLCJwYXJhbGxlbFJvdXRlc0EiLCJzZWdtZW50QiIsInBhcmFsbGVsUm91dGVzQiIsIm5vcm1hbGl6ZWRTZWdtZW50QSIsIm5vcm1hbGl6ZWRTZWdtZW50QiIsIm1hdGNoU2VnbWVudCIsInBhcmFsbGVsUm91dGVyS2V5IiwiY2hhbmdlZFBhdGgiLCJzcGxpdCIsImN1cnJlbnRUcmVlIiwicGFyYW1zIiwicGFyYWxsZWxSb3V0ZSIsInZhbHVlcyIsImlzRHluYW1pY1BhcmFtZXRlciIsInNlZ21lbnRWYWx1ZSIsImlzQ2F0Y2hBbGwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztJQXdIZ0JBLGtCQUFrQixFQUFBO2VBQWxCQTs7SUE5RUFDLGdDQUFnQyxFQUFBO2VBQWhDQTs7SUErRkFDLGlCQUFpQixFQUFBO2VBQWpCQTs7O29DQXJJMkI7eUJBTXBDOytCQUNzQjtBQUU3QixNQUFNQyxxQkFBcUIsQ0FBQ0M7SUFDMUIsT0FBT0EsT0FBTyxDQUFDLEVBQUUsS0FBSyxNQUFNQSxRQUFRQyxLQUFLLENBQUMsS0FBS0Q7QUFDakQ7QUFFQSxNQUFNRSxvQkFBb0IsQ0FBQ0Y7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LE9BQU9DO0lBRWxELElBQUlTLGVBQWUsUUFBUUEsZ0JBQWdCLEtBQUs7UUFDOUMsT0FBT0E7SUFDVDtJQUVBLG1EQUFtRDtJQUNuRCxPQUFPbkMsa0JBQWtCbUMsWUFBWUMsS0FBSyxDQUFDO0FBQzdDO0FBS08sU0FBU3pDLGtCQUNkMEMsV0FBOEIsRUFDOUJDLE1BQW1CO0lBQW5CQSxJQUFBQSxXQUFBQSxLQUFBQSxHQUFBQSxTQUFpQixDQUFDO0lBRWxCLE1BQU12QixpQkFBaUJzQixXQUFXLENBQUMsRUFBRTtJQUVyQyxLQUFLLE1BQU1FLGlCQUFpQmxCLE9BQU9tQixNQUFNLENBQUN6QixnQkFBaUI7UUFDekQsTUFBTWxCLFVBQVUwQyxhQUFhLENBQUMsRUFBRTtRQUNoQyxNQUFNRSxxQkFBcUJuQyxNQUFNQyxPQUFPLENBQUNWO1FBQ3pDLE1BQU02QyxlQUFlRCxxQkFBcUI1QyxPQUFPLENBQUMsRUFBRSxHQUFHQTtRQUN2RCxJQUFJLENBQUM2QyxnQkFBZ0JBLGFBQWE5QixVQUFVLENBQUNFLFNBQUFBLGdCQUFnQixHQUFHO1FBRWhFLGlFQUFpRTtRQUNqRSxNQUFNNkIsYUFDSkYsc0JBQXVCNUMsQ0FBQUEsT0FBTyxDQUFDLEVBQUUsS0FBSyxPQUFPQSxPQUFPLENBQUMsRUFBRSxLQUFLLElBQUc7UUFFakUsSUFBSThDLFlBQVk7WUFDZEwsTUFBTSxDQUFDekMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxHQUFHQSxPQUFPLENBQUMsRUFBRSxDQUFDdUMsS0FBSyxDQUFDO1FBQ3hDLE9BQU8sSUFBSUssb0JBQW9CO1lBQzdCSCxNQUFNLENBQUN6QyxPQUFPLENBQUMsRUFBRSxDQUFDLEdBQUdBLE9BQU8sQ0FBQyxFQUFFO1FBQ2pDO1FBRUF5QyxTQUFTM0Msa0JBQWtCNEMsZUFBZUQ7SUFDNUM7SUFFQSxPQUFPQTtBQUNUIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDQ2MTcsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvaGFuZGxlLW11dGFibGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY29tcHV0ZUNoYW5nZWRQYXRoIH0gZnJvbSAnLi9jb21wdXRlLWNoYW5nZWQtcGF0aCdcbmltcG9ydCB0eXBlIHtcbiAgTXV0YWJsZSxcbiAgUmVhZG9ubHlSZWR1Y2VyU3RhdGUsXG4gIFJlZHVjZXJTdGF0ZSxcbn0gZnJvbSAnLi9yb3V0ZXItcmVkdWNlci10eXBlcydcblxuZnVuY3Rpb24gaXNOb3RVbmRlZmluZWQ8VD4odmFsdWU6IFQpOiB2YWx1ZSBpcyBFeGNsdWRlPFQsIHVuZGVmaW5lZD4ge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJ1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFuZGxlTXV0YWJsZShcbiAgc3RhdGU6IFJlYWRvbmx5UmVkdWNlclN0YXRlLFxuICBtdXRhYmxlOiBNdXRhYmxlXG4pOiBSZWR1Y2VyU3RhdGUge1xuICAvLyBzaG91bGRTY3JvbGwgaXMgdHJ1ZSBieSBkZWZhdWx0LCBjYW4gb3ZlcnJpZGUgdG8gZmFsc2UuXG4gIGNvbnN0IHNob3VsZFNjcm9sbCA9IG11dGFibGUuc2hvdWxkU2Nyb2xsID8/IHRydWVcblxuICBsZXQgbmV4dFVybCA9IHN0YXRlLm5leHRVcmxcblxuICBpZiAoaXNOb3RVbmRlZmluZWQobXV0YWJsZS5wYXRjaGVkVHJlZSkpIHtcbiAgICAvLyBJZiB3ZSByZWNlaXZlZCBhIHBhdGNoZWQgdHJlZSwgd2UgbmVlZCB0byBjb21wdXRlIHRoZSBjaGFuZ2VkIHBhdGguXG4gICAgY29uc3QgY2hhbmdlZFBhdGggPSBjb21wdXRlQ2hhbmdlZFBhdGgoc3RhdGUudHJlZSwgbXV0YWJsZS5wYXRjaGVkVHJlZSlcbiAgICBpZiAoY2hhbmdlZFBhdGgpIHtcbiAgICAgIC8vIElmIHRoZSB0cmVlIGNoYW5nZWQsIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBuZXh0VXJsXG4gICAgICBuZXh0VXJsID0gY2hhbmdlZFBhdGhcbiAgICB9IGVsc2UgaWYgKCFuZXh0VXJsKSB7XG4gICAgICAvLyBpZiB0aGUgdHJlZSBlbmRzIHVwIGJlaW5nIHRoZSBzYW1lIChpZSwgbm8gY2hhbmdlZCBwYXRoKSwgYW5kIHdlIGRvbid0IGhhdmUgYSBuZXh0VXJsLCB0aGVuIHdlIHNob3VsZCB1c2UgdGhlIGNhbm9uaWNhbFVybFxuICAgICAgbmV4dFVybCA9IHN0YXRlLmNhbm9uaWNhbFVybFxuICAgIH1cbiAgICAvLyBvdGhlcndpc2UgdGhpcyB3aWxsIGJlIGEgbm8tb3AgYW5kIGNvbnRpbnVlIHRvIHVzZSB0aGUgZXhpc3RpbmcgbmV4dFVybFxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAvLyBTZXQgaHJlZi5cbiAgICBjYW5vbmljYWxVcmw6IGlzTm90VW5kZWZpbmVkKG11dGFibGUuY2Fub25pY2FsVXJsKVxuICAgICAgPyBtdXRhYmxlLmNhbm9uaWNhbFVybCA9PT0gc3RhdGUuY2Fub25pY2FsVXJsXG4gICAgICAgID8gc3RhdGUuY2Fub25pY2FsVXJsXG4gICAgICAgIDogbXV0YWJsZS5jYW5vbmljYWxVcmxcbiAgICAgIDogc3RhdGUuY2Fub25pY2FsVXJsLFxuICAgIHB1c2hSZWY6IHtcbiAgICAgIHBlbmRpbmdQdXNoOiBpc05vdFVuZGVmaW5lZChtdXRhYmxlLnBlbmRpbmdQdXNoKVxuICAgICAgICA/IG11dGFibGUucGVuZGluZ1B1c2hcbiAgICAgICAgOiBzdGF0ZS5wdXNoUmVmLnBlbmRpbmdQdXNoLFxuICAgICAgbXBhTmF2aWdhdGlvbjogaXNOb3RVbmRlZmluZWQobXV0YWJsZS5tcGFOYXZpZ2F0aW9uKVxuICAgICAgICA/IG11dGFibGUubXBhTmF2aWdhdGlvblxuICAgICAgICA6IHN0YXRlLnB1c2hSZWYubXBhTmF2aWdhdGlvbixcbiAgICAgIHByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlOiBpc05vdFVuZGVmaW5lZChcbiAgICAgICAgbXV0YWJsZS5wcmVzZXJ2ZUN1c3RvbUhpc3RvcnlTdGF0ZVxuICAgICAgKVxuICAgICAgICA/IG11dGFibGUucHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGVcbiAgICAgICAgOiBzdGF0ZS5wdXNoUmVmLnByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlLFxuICAgIH0sXG4gICAgLy8gQWxsIG5hdmlnYXRpb24gcmVxdWlyZXMgc2Nyb2xsIGFuZCBmb2N1cyBtYW5hZ2VtZW50IHRvIHRyaWdnZXIuXG4gICAgZm9jdXNBbmRTY3JvbGxSZWY6IHtcbiAgICAgIGFwcGx5OiBzaG91bGRTY3JvbGxcbiAgICAgICAgPyBpc05vdFVuZGVmaW5lZChtdXRhYmxlPy5zY3JvbGxhYmxlU2VnbWVudHMpXG4gICAgICAgICAgPyB0cnVlXG4gICAgICAgICAgOiBzdGF0ZS5mb2N1c0FuZFNjcm9sbFJlZi5hcHBseVxuICAgICAgICA6IC8vIElmIHNob3VsZFNjcm9sbCBpcyBmYWxzZSB0aGVuIHdlIHNob3VsZCBub3QgYXBwbHkgc2Nyb2xsIGFuZCBmb2N1cyBtYW5hZ2VtZW50LlxuICAgICAgICAgIGZhbHNlLFxuICAgICAgb25seUhhc2hDaGFuZ2U6IG11dGFibGUub25seUhhc2hDaGFuZ2UgfHwgZmFsc2UsXG4gICAgICBoYXNoRnJhZ21lbnQ6IHNob3VsZFNjcm9sbFxuICAgICAgICA/IC8vIEVtcHR5IGhhc2ggc2hvdWxkIHRyaWdnZXIgZGVmYXVsdCBiZWhhdmlvciBvZiBzY3JvbGxpbmcgbGF5b3V0IGludG8gdmlldy5cbiAgICAgICAgICAvLyAjdG9wIGlzIGhhbmRsZWQgaW4gbGF5b3V0LXJvdXRlci5cbiAgICAgICAgICBtdXRhYmxlLmhhc2hGcmFnbWVudCAmJiBtdXRhYmxlLmhhc2hGcmFnbWVudCAhPT0gJydcbiAgICAgICAgICA/IC8vIFJlbW92ZSBsZWFkaW5nICMgYW5kIGRlY29kZSBoYXNoIHRvIG1ha2Ugbm9uLWxhdGluIGhhc2hlcyB3b3JrLlxuICAgICAgICAgICAgZGVjb2RlVVJJQ29tcG9uZW50KG11dGFibGUuaGFzaEZyYWdtZW50LnNsaWNlKDEpKVxuICAgICAgICAgIDogc3RhdGUuZm9jdXNBbmRTY3JvbGxSZWYuaGFzaEZyYWdtZW50XG4gICAgICAgIDogLy8gSWYgc2hvdWxkU2Nyb2xsIGlzIGZhbHNlIHRoZW4gd2Ugc2hvdWxkIG5vdCBhcHBseSBzY3JvbGwgYW5kIGZvY3VzIG1hbmFnZW1lbnQuXG4gICAgICAgICAgbnVsbCxcbiAgICAgIHNlZ21lbnRQYXRoczogc2hvdWxkU2Nyb2xsXG4gICAgICAgID8gbXV0YWJsZT8uc2Nyb2xsYWJsZVNlZ21lbnRzID8/IHN0YXRlLmZvY3VzQW5kU2Nyb2xsUmVmLnNlZ21lbnRQYXRoc1xuICAgICAgICA6IC8vIElmIHNob3VsZFNjcm9sbCBpcyBmYWxzZSB0aGVuIHdlIHNob3VsZCBub3QgYXBwbHkgc2Nyb2xsIGFuZCBmb2N1cyBtYW5hZ2VtZW50LlxuICAgICAgICAgIFtdLFxuICAgIH0sXG4gICAgLy8gQXBwbHkgY2FjaGUuXG4gICAgY2FjaGU6IG11dGFibGUuY2FjaGUgPyBtdXRhYmxlLmNhY2hlIDogc3RhdGUuY2FjaGUsXG4gICAgcHJlZmV0Y2hDYWNoZTogbXV0YWJsZS5wcmVmZXRjaENhY2hlXG4gICAgICA/IG11dGFibGUucHJlZmV0Y2hDYWNoZVxuICAgICAgOiBzdGF0ZS5wcmVmZXRjaENhY2hlLFxuICAgIC8vIEFwcGx5IHBhdGNoZWQgcm91dGVyIHN0YXRlLlxuICAgIHRyZWU6IGlzTm90VW5kZWZpbmVkKG11dGFibGUucGF0Y2hlZFRyZWUpXG4gICAgICA/IG11dGFibGUucGF0Y2hlZFRyZWVcbiAgICAgIDogc3RhdGUudHJlZSxcbiAgICBuZXh0VXJsLFxuICB9XG59XG4iXSwibmFtZXMiOlsiaGFuZGxlTXV0YWJsZSIsImlzTm90VW5kZWZpbmVkIiwidmFsdWUiLCJzdGF0ZSIsIm11dGFibGUiLCJzaG91bGRTY3JvbGwiLCJuZXh0VXJsIiwicGF0Y2hlZFRyZWUiLCJjaGFuZ2VkUGF0aCIsImNvbXB1dGVDaGFuZ2VkUGF0aCIsInRyZWUiLCJjYW5vbmljYWxVcmwiLCJwdXNoUmVmIiwicGVuZGluZ1B1c2giLCJtcGFOYXZpZ2F0aW9uIiwicHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGUiLCJmb2N1c0FuZFNjcm9sbFJlZiIsImFwcGx5Iiwic2Nyb2xsYWJsZVNlZ21lbnRzIiwib25seUhhc2hDaGFuZ2UiLCJoYXNoRnJhZ21lbnQiLCJkZWNvZGVVUklDb21wb25lbnQiLCJzbGljZSIsInNlZ21lbnRQYXRocyIsImNhY2hlIiwicHJlZmV0Y2hDYWNoZSJdLCJtYXBwaW5ncyI6Ijs7OytCQVdnQkEsaUJBQUFBOzs7ZUFBQUE7OztvQ0FYbUI7QUFPbkMsU0FBU0MsZUFBa0JDLEtBQVE7SUFDakMsT0FBTyxPQUFPQSxVQUFVO0FBQzFCO0FBRU8sU0FBU0YsY0FDZEcsS0FBMkIsRUFDM0JDLE9BQWdCO1FBR0tBO0lBRHJCLDBEQUEwRDtJQUMxRCxNQUFNQyxlQUFlRCxDQUFBQSx3QkFBQUEsUUFBUUMsWUFBWSxLQUFBLE9BQXBCRCx3QkFBd0I7SUFFN0MsSUFBSUUsVUFBVUgsTUFBTUcsT0FBTztJQUUzQixJQUFJTCxlQUFlRyxRQUFRRyxXQUFXLEdBQUc7UUFDdkMsc0VBQXNFO1FBQ3RFLE1BQU1DLGNBQWNDLENBQUFBLEdBQUFBLG9CQUFBQSxrQkFBa0IsRUFBQ04sTUFBTU8sSUFBSSxFQUFFTixRQUFRRyxXQUFXO1FBQ3RFLElBQUlDLGFBQWE7WUFDZixxREFBcUQ7WUFDckRGLFVBQVVFO1FBQ1osT0FBTyxJQUFJLENBQUNGLFNBQVM7WUFDbkIsNkhBQTZIO1lBQzdIQSxVQUFVSCxNQUFNUSxZQUFZO1FBQzlCO0lBQ0EsMEVBQTBFO0lBQzVFO1FBeUNRUDtJQXZDUixPQUFPO1FBQ0wsWUFBWTtRQUNaTyxjQUFjVixlQUFlRyxRQUFRTyxZQUFZLElBQzdDUCxRQUFRTyxZQUFZLEtBQUtSLE1BQU1RLFlBQVksR0FDekNSLE1BQU1RLFlBQVksR0FDbEJQLFFBQVFPLFlBQVksR0FDdEJSLE1BQU1RLFlBQVk7UUFDdEJDLFNBQVM7WUFDUEMsYUFBYVosZUFBZUcsUUFBUVMsV0FBVyxJQUMzQ1QsUUFBUVMsV0FBVyxHQUNuQlYsTUFBTVMsT0FBTyxDQUFDQyxXQUFXO1lBQzdCQyxlQUFlYixlQUFlRyxRQUFRVSxhQUFhLElBQy9DVixRQUFRVSxhQUFhLEdBQ3JCWCxNQUFNUyxPQUFPLENBQUNFLGFBQWE7WUFDL0JDLDRCQUE0QmQsZUFDMUJHLFFBQVFXLDBCQUEwQixJQUVoQ1gsUUFBUVcsMEJBQTBCLEdBQ2xDWixNQUFNUyxPQUFPLENBQUNHLDBCQUEwQjtRQUM5QztRQUNBLGtFQUFrRTtRQUNsRUMsbUJBQW1CO1lBQ2pCQyxPQUFPWixlQUNISixlQUFlRyxXQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxRQUFTYyxrQkFBa0IsSUFDeEMsT0FDQWYsTUFBTWEsaUJBQWlCLENBQUNDLEtBQUssR0FFL0I7WUFDSkUsZ0JBQWdCZixRQUFRZSxjQUFjLElBQUk7WUFDMUNDLGNBQWNmLGVBR1ZELEFBREEsUUFDUWdCLFlBQVksSUFBSWhCLFFBQVFnQixJQURJLFFBQ1EsS0FBSyxLQUUvQ0MsbUJBQW1CakIsUUFBUWdCLFlBQVksQ0FBQ0UsS0FBSyxDQUFDLE1BQzlDbkIsTUFBTWEsaUJBQWlCLENBQUNJLFlBQVksR0FFdEM7WUFDSkcsY0FBY2xCLGVBQ1ZELENBQUFBLDhCQUFBQSxXQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxRQUFTYyxrQkFBa0IsS0FBQSxPQUEzQmQsOEJBQStCRCxNQUFNYSxpQkFBaUIsQ0FBQ08sWUFBWSxHQUVuRSxFQUFFO1FBQ1I7UUFDQSxlQUFlO1FBQ2ZDLE9BQU9wQixRQUFRb0IsS0FBSyxHQUFHcEIsUUFBUW9CLEtBQUssR0FBR3JCLE1BQU1xQixLQUFLO1FBQ2xEQyxlQUFlckIsUUFBUXFCLGFBQWEsR0FDaENyQixRQUFRcUIsYUFBYSxHQUNyQnRCLE1BQU1zQixhQUFhO1FBQ3ZCLDhCQUE4QjtRQUM5QmYsTUFBTVQsZUFBZUcsUUFBUUcsV0FBVyxJQUNwQ0gsUUFBUUcsV0FBVyxHQUNuQkosTUFBTU8sSUFBSTtRQUNkSjtJQUNGO0FBQ0YiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNDY4NCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvY29tcG9uZW50cy9wcm9taXNlLXF1ZXVlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgVGhpcyBpcyBhIHNpbXBsZSBwcm9taXNlIHF1ZXVlIHRoYXQgYWxsb3dzIHlvdSB0byBsaW1pdCB0aGUgbnVtYmVyIG9mIGNvbmN1cnJlbnQgcHJvbWlzZXNcbiAgICB0aGF0IGFyZSBydW5uaW5nIGF0IGFueSBnaXZlbiB0aW1lLiBJdCdzIHVzZWQgdG8gbGltaXQgdGhlIG51bWJlciBvZiBjb25jdXJyZW50XG4gICAgcHJlZmV0Y2ggcmVxdWVzdHMgdGhhdCBhcmUgYmVpbmcgbWFkZSB0byB0aGUgc2VydmVyIGJ1dCBjb3VsZCBiZSB1c2VkIGZvciBvdGhlclxuICAgIHRoaW5ncyBhcyB3ZWxsLlxuKi9cbmV4cG9ydCBjbGFzcyBQcm9taXNlUXVldWUge1xuICAjbWF4Q29uY3VycmVuY3k6IG51bWJlclxuICAjcnVubmluZ0NvdW50OiBudW1iZXJcbiAgI3F1ZXVlOiBBcnJheTx7XG4gICAgcHJvbWlzZUZuOiBQcm9taXNlPGFueT5cbiAgICB0YXNrOiAoKSA9PiB2b2lkXG4gIH0+XG5cbiAgY29uc3RydWN0b3IobWF4Q29uY3VycmVuY3kgPSA1KSB7XG4gICAgdGhpcy4jbWF4Q29uY3VycmVuY3kgPSBtYXhDb25jdXJyZW5jeVxuICAgIHRoaXMuI3J1bm5pbmdDb3VudCA9IDBcbiAgICB0aGlzLiNxdWV1ZSA9IFtdXG4gIH1cblxuICBlbnF1ZXVlPFQ+KHByb21pc2VGbjogKCkgPT4gUHJvbWlzZTxUPik6IFByb21pc2U8VD4ge1xuICAgIGxldCB0YXNrUmVzb2x2ZTogKHZhbHVlOiBUIHwgUHJvbWlzZUxpa2U8VD4pID0+IHZvaWRcbiAgICBsZXQgdGFza1JlamVjdDogKHJlYXNvbj86IGFueSkgPT4gdm9pZFxuXG4gICAgY29uc3QgdGFza1Byb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0YXNrUmVzb2x2ZSA9IHJlc29sdmVcbiAgICAgIHRhc2tSZWplY3QgPSByZWplY3RcbiAgICB9KSBhcyBQcm9taXNlPFQ+XG5cbiAgICBjb25zdCB0YXNrID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy4jcnVubmluZ0NvdW50KytcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvbWlzZUZuKClcbiAgICAgICAgdGFza1Jlc29sdmUocmVzdWx0KVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGFza1JlamVjdChlcnJvcilcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXMuI3J1bm5pbmdDb3VudC0tXG4gICAgICAgIHRoaXMuI3Byb2Nlc3NOZXh0KClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBlbnF1ZXVlUmVzdWx0ID0geyBwcm9taXNlRm46IHRhc2tQcm9taXNlLCB0YXNrIH1cbiAgICAvLyB3b25kZXIgaWYgd2Ugc2hvdWxkIHRha2UgYSBMSUZPIGFwcHJvYWNoIGhlcmVcbiAgICB0aGlzLiNxdWV1ZS5wdXNoKGVucXVldWVSZXN1bHQpXG4gICAgdGhpcy4jcHJvY2Vzc05leHQoKVxuXG4gICAgcmV0dXJuIHRhc2tQcm9taXNlXG4gIH1cblxuICBidW1wKHByb21pc2VGbjogUHJvbWlzZTxhbnk+KSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLiNxdWV1ZS5maW5kSW5kZXgoKGl0ZW0pID0+IGl0ZW0ucHJvbWlzZUZuID09PSBwcm9taXNlRm4pXG5cbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgY29uc3QgYnVtcGVkSXRlbSA9IHRoaXMuI3F1ZXVlLnNwbGljZShpbmRleCwgMSlbMF1cbiAgICAgIHRoaXMuI3F1ZXVlLnVuc2hpZnQoYnVtcGVkSXRlbSlcbiAgICAgIHRoaXMuI3Byb2Nlc3NOZXh0KHRydWUpXG4gICAgfVxuICB9XG5cbiAgI3Byb2Nlc3NOZXh0KGZvcmNlZCA9IGZhbHNlKSB7XG4gICAgaWYgKFxuICAgICAgKHRoaXMuI3J1bm5pbmdDb3VudCA8IHRoaXMuI21heENvbmN1cnJlbmN5IHx8IGZvcmNlZCkgJiZcbiAgICAgIHRoaXMuI3F1ZXVlLmxlbmd0aCA+IDBcbiAgICApIHtcbiAgICAgIHRoaXMuI3F1ZXVlLnNoaWZ0KCk/LnRhc2soKVxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbIlByb21pc2VRdWV1ZSIsImVucXVldWUiLCJwcm9taXNlRm4iLCJ0YXNrUmVzb2x2ZSIsInRhc2tSZWplY3QiLCJ0YXNrUHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwidGFzayIsInJlc3VsdCIsImVycm9yIiwiZW5xdWV1ZVJlc3VsdCIsInB1c2giLCJidW1wIiwiaW5kZXgiLCJmaW5kSW5kZXgiLCJpdGVtIiwiYnVtcGVkSXRlbSIsInNwbGljZSIsInVuc2hpZnQiLCJjb25zdHJ1Y3RvciIsIm1heENvbmN1cnJlbmN5IiwiZm9yY2VkIiwibGVuZ3RoIiwic2hpZnQiXSwibWFwcGluZ3MiOiJBQUFBOzs7OztBQUtBOzs7K0JBQ2FBLGdCQUFBQTs7O2VBQUFBOzs7OztJQUNYLGtCQUFBLFdBQUEsR0FBQSwrQkFBQSxDQUFBLENBQUEsb0JBQ0EsZ0JBQUEsV0FBQSxHQUFBLCtCQUFBLENBQUEsQ0FBQSxrQkFDQSxTQUFBLFdBQUEsR0FBQSwrQkFBQSxDQUFBLENBQUEsV0FtREEsZUFBQSxXQUFBLEdBQUEsK0JBQUEsQ0FBQSxDQUFBO0FBdERLLE1BQU1BO0lBY1hDLFFBQVdDLFNBQTJCLEVBQWM7UUFDbEQsSUFBSUM7UUFDSixJQUFJQztRQUVKLE1BQU1DLGNBQWMsSUFBSUMsUUFBUSxDQUFDQyxTQUFTQztZQUN4Q0wsY0FBY0k7WUFDZEgsYUFBYUk7UUFDZjtRQUVBLE1BQU1DLE9BQU87WUFDWCxJQUFJO2dCQUNGLGdDQUFBLENBQUEsQ0FBQSxJQUFJLEVBQUMsY0FBQSxDQUFBLGNBQUE7Z0JBQ0wsTUFBTUMsU0FBUyxNQUFNUjtnQkFDckJDLFlBQVlPO1lBQ2QsRUFBRSxPQUFPQyxPQUFPO2dCQUNkUCxXQUFXTztZQUNiLFNBQVU7Z0JBQ1IsZ0NBQUEsQ0FBQSxDQUFBLElBQUksRUFBQyxjQUFBLENBQUEsY0FBQTtnQkFDTCxnQ0FBQSxDQUFBLENBQUEsSUFBSSxFQUFDLGFBQUEsQ0FBQSxhQUFBO1lBQ1A7UUFDRjtRQUVBLE1BQU1DLGdCQUFnQjtZQUFFVixXQUFXRztZQUFhSTtRQUFLO1FBQ3JELGdEQUFnRDtRQUNoRCxnQ0FBQSxDQUFBLENBQUEsSUFBSSxFQUFDLE9BQUEsQ0FBQSxPQUFBLENBQU9JLElBQUksQ0FBQ0Q7UUFDakIsZ0NBQUEsQ0FBQSxDQUFBLElBQUksRUFBQyxhQUFBLENBQUEsYUFBQTtRQUVMLE9BQU9QO0lBQ1Q7SUFFQVMsS0FBS1osU0FBdUIsRUFBRTtRQUM1QixNQUFNYSxRQUFRLGdDQUFBLENBQUEsQ0FBQSxJQUFJLEVBQUMsT0FBQSxDQUFBLE9BQUEsQ0FBT0MsU0FBUyxDQUFDLENBQUNDLE9BQVNBLEtBQUtmLFNBQVMsS0FBS0E7UUFFakUsSUFBSWEsUUFBUSxDQUFDLEdBQUc7WUFDZCxNQUFNRyxhQUFhLGdDQUFBLENBQUEsQ0FBQSxJQUFJLEVBQUMsT0FBQSxDQUFBLE9BQUEsQ0FBT0MsTUFBTSxDQUFDSixPQUFPLEVBQUUsQ0FBQyxFQUFFO1lBQ2xELGdDQUFBLENBQUEsQ0FBQSxJQUFJLEVBQUMsT0FBQSxDQUFBLE9BQUEsQ0FBT0ssT0FBTyxDQUFDRjtZQUNwQixnQ0FBQSxDQUFBLENBQUEsSUFBSSxFQUFDLGFBQUEsQ0FBQSxhQUFBLENBQWE7UUFDcEI7SUFDRjtJQTVDQUcsWUFBWUMsaUJBQWlCLENBQUMsQ0FBRTtRQThDaEMsT0FBQSxjQUFBLENBQUEsSUFBQSxFQUFBLGNBQUE7bUJBQUE7O1FBckRBLE9BQUEsY0FBQSxDQUFBLElBQUEsRUFBQSxpQkFBQTs7bUJBQUEsS0FBQTs7UUFDQSxPQUFBLGNBQUEsQ0FBQSxJQUFBLEVBQUEsZUFBQTs7bUJBQUEsS0FBQTs7UUFDQSxPQUFBLGNBQUEsQ0FBQSxJQUFBLEVBQUEsUUFBQTs7bUJBQUEsS0FBQTs7UUFNRSxnQ0FBQSxDQUFBLENBQUEsSUFBSSxFQUFDLGdCQUFBLENBQUEsZ0JBQUEsR0FBa0JBO1FBQ3ZCLGdDQUFBLENBQUEsQ0FBQSxJQUFJLEVBQUMsY0FBQSxDQUFBLGNBQUEsR0FBZ0I7UUFDckIsZ0NBQUEsQ0FBQSxDQUFBLElBQUksRUFBQyxPQUFBLENBQUEsT0FBQSxHQUFTLEVBQUU7SUFDbEI7QUFrREY7QUFSRSxTQUFBLFlBQWFDLE1BQWM7SUFBZEEsSUFBQUEsV0FBQUEsS0FBQUEsR0FBQUEsU0FBUztJQUNwQixJQUNHLENBQUEsZ0NBQUEsQ0FBQSxDQUFBLElBQUksRUFBQyxjQUFBLENBQUEsY0FBQSxHQUFnQixnQ0FBQSxDQUFBLENBQUEsSUFBSSxFQUFDLGdCQUFBLENBQUEsZ0JBQUEsSUFBbUJBLE1BQUssS0FDbkQsZ0NBQUEsQ0FBQSxDQUFBLElBQUksRUFBQyxPQUFBLENBQUEsT0FBQSxDQUFPQyxNQUFNLEdBQUcsR0FDckI7WUFDQTtTQUFBLCtDQUFBLGdDQUFBLENBQUEsQ0FBQSxJQUFJLEVBQUMsT0FBQSxDQUFBLE9BQUEsQ0FBT0MsS0FBSyxFQUFBLEtBQUEsT0FBQSxLQUFBLElBQWpCLDZDQUFxQmhCLElBQUk7SUFDM0I7QUFDRiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA0Nzc5LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3ByZWZldGNoLWNhY2hlLXV0aWxzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIGZldGNoU2VydmVyUmVzcG9uc2UsXG4gIHR5cGUgRmV0Y2hTZXJ2ZXJSZXNwb25zZVJlc3VsdCxcbn0gZnJvbSAnLi9mZXRjaC1zZXJ2ZXItcmVzcG9uc2UnXG5pbXBvcnQge1xuICBQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMsXG4gIHR5cGUgUHJlZmV0Y2hDYWNoZUVudHJ5LFxuICBQcmVmZXRjaEtpbmQsXG4gIHR5cGUgUmVhZG9ubHlSZWR1Y2VyU3RhdGUsXG59IGZyb20gJy4vcm91dGVyLXJlZHVjZXItdHlwZXMnXG5pbXBvcnQgeyBwcmVmZXRjaFF1ZXVlIH0gZnJvbSAnLi9yZWR1Y2Vycy9wcmVmZXRjaC1yZWR1Y2VyJ1xuXG5jb25zdCBJTlRFUkNFUFRJT05fQ0FDSEVfS0VZX01BUktFUiA9ICclJ1xuXG5leHBvcnQgdHlwZSBBbGlhc2VkUHJlZmV0Y2hDYWNoZUVudHJ5ID0gUHJlZmV0Y2hDYWNoZUVudHJ5ICYge1xuICAvKiogVGhpcyBpcyBhIHNwZWNpYWwgcHJvcGVydHkgdGhhdCBpbmRpY2F0ZXMgYSBwcmVmZXRjaCBlbnRyeSBhc3NvY2lhdGVkIHdpdGggYSBkaWZmZXJlbnQgVVJMXG4gICAqIHdhcyByZXR1cm5lZCByYXRoZXIgdGhhbiB0aGUgcmVxdWVzdGVkIFVSTC4gVGhpcyBzaWduYWxzIHRvIHRoZSByb3V0ZXIgdGhhdCBpdCBzaG91bGQgb25seVxuICAgKiBhcHBseSB0aGUgcGFydCB0aGF0IGRvZXNuJ3QgZGVwZW5kIG9uIHNlYXJjaFBhcmFtcyAoc3BlY2lmaWNhbGx5IHRoZSBsb2FkaW5nIHN0YXRlKS5cbiAgICovXG4gIGFsaWFzZWQ/OiBib29sZWFuXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNhY2hlIGtleSBmb3IgdGhlIHJvdXRlciBwcmVmZXRjaCBjYWNoZVxuICpcbiAqIEBwYXJhbSB1cmwgLSBUaGUgVVJMIGJlaW5nIG5hdmlnYXRlZCB0b1xuICogQHBhcmFtIG5leHRVcmwgLSBhbiBpbnRlcm5hbCBVUkwsIHByaW1hcmlseSB1c2VkIGZvciBoYW5kbGluZyByZXdyaXRlcy4gRGVmYXVsdHMgdG8gJy8nLlxuICogQHJldHVybiBUaGUgZ2VuZXJhdGVkIHByZWZldGNoIGNhY2hlIGtleS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUHJlZmV0Y2hDYWNoZUtleUltcGwoXG4gIHVybDogVVJMLFxuICBpbmNsdWRlU2VhcmNoUGFyYW1zOiBib29sZWFuLFxuICBwcmVmaXg/OiBzdHJpbmcgfCBudWxsXG4pIHtcbiAgLy8gSW5pdGlhbGx5IHdlIG9ubHkgdXNlIHRoZSBwYXRobmFtZSBhcyB0aGUgY2FjaGUga2V5LiBXZSBkb24ndCB3YW50IHRvIGluY2x1ZGVcbiAgLy8gc2VhcmNoIHBhcmFtcyBzbyB0aGF0IG11bHRpcGxlIFVSTHMgd2l0aCB0aGUgc2FtZSBzZWFyY2ggcGFyYW1ldGVyIGNhbiByZS11c2VcbiAgLy8gbG9hZGluZyBzdGF0ZXMuXG4gIGxldCBwYXRobmFtZUZyb21VcmwgPSB1cmwucGF0aG5hbWVcblxuICAvLyBSU0MgcmVzcG9uc2VzIGNhbiBkaWZmZXIgYmFzZWQgb24gc2VhcmNoIHBhcmFtcywgc3BlY2lmaWNhbGx5IGluIHRoZSBjYXNlIHdoZXJlIHdlIGFyZW4ndFxuICAvLyByZXR1cm5pbmcgYSBwYXJ0aWFsIHJlc3BvbnNlIChpZSB3aXRoIGBQcmVmZXRjaEtpbmQuQVVUT2ApLlxuICAvLyBJbiB0aGUgYXV0byBjYXNlLCBzaW5jZSBsb2FkaW5nLmpzICYgbGF5b3V0LmpzIHdvbid0IGhhdmUgYWNjZXNzIHRvIHNlYXJjaCBwYXJhbXMsXG4gIC8vIHdlIGNhbiBzYWZlbHkgcmUtdXNlIHRoYXQgY2FjaGUgZW50cnkuIEJ1dCBmb3IgZnVsbCBwcmVmZXRjaGVzLCB3ZSBzaG91bGQgbm90XG4gIC8vIHJlLXVzZSB0aGUgY2FjaGUgZW50cnkgYXMgdGhlIHJlc3BvbnNlIG1heSBkaWZmZXIuXG4gIGlmIChpbmNsdWRlU2VhcmNoUGFyYW1zKSB7XG4gICAgLy8gaWYgd2UgaGF2ZSBhIGZ1bGwgcHJlZmV0Y2gsIHdlIGNhbiBpbmNsdWRlIHRoZSBzZWFyY2ggcGFyYW0gaW4gdGhlIGtleSxcbiAgICAvLyBhcyB3ZSdsbCBiZSBnZXR0aW5nIGJhY2sgYSBmdWxsIHJlc3BvbnNlLiBUaGUgc2VydmVyIG1pZ2h0IGhhdmUgcmVhZCB0aGUgc2VhcmNoXG4gICAgLy8gcGFyYW1zIHdoZW4gZ2VuZXJhdGluZyB0aGUgZnVsbCByZXNwb25zZS5cbiAgICBwYXRobmFtZUZyb21VcmwgKz0gdXJsLnNlYXJjaFxuICB9XG5cbiAgaWYgKHByZWZpeCkge1xuICAgIHJldHVybiBgJHtwcmVmaXh9JHtJTlRFUkNFUFRJT05fQ0FDSEVfS0VZX01BUktFUn0ke3BhdGhuYW1lRnJvbVVybH1gXG4gIH1cblxuICByZXR1cm4gcGF0aG5hbWVGcm9tVXJsXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVByZWZldGNoQ2FjaGVLZXkoXG4gIHVybDogVVJMLFxuICBraW5kOiBQcmVmZXRjaEtpbmQgfCB1bmRlZmluZWQsXG4gIG5leHRVcmw/OiBzdHJpbmcgfCBudWxsXG4pIHtcbiAgcmV0dXJuIGNyZWF0ZVByZWZldGNoQ2FjaGVLZXlJbXBsKHVybCwga2luZCA9PT0gUHJlZmV0Y2hLaW5kLkZVTEwsIG5leHRVcmwpXG59XG5cbmZ1bmN0aW9uIGdldEV4aXN0aW5nQ2FjaGVFbnRyeShcbiAgdXJsOiBVUkwsXG4gIGtpbmQ6IFByZWZldGNoS2luZCA9IFByZWZldGNoS2luZC5URU1QT1JBUlksXG4gIG5leHRVcmw6IHN0cmluZyB8IG51bGwsXG4gIHByZWZldGNoQ2FjaGU6IE1hcDxzdHJpbmcsIFByZWZldGNoQ2FjaGVFbnRyeT4sXG4gIGFsbG93QWxpYXNpbmc6IGJvb2xlYW5cbik6IEFsaWFzZWRQcmVmZXRjaENhY2hlRW50cnkgfCB1bmRlZmluZWQge1xuICAvLyBXZSBmaXJzdCBjaGVjayBpZiB0aGVyZSdzIGEgbW9yZSBzcGVjaWZpYyBpbnRlcmNlcHRpb24gcm91dGUgcHJlZmV0Y2ggZW50cnlcbiAgLy8gVGhpcyBpcyBiZWNhdXNlIHdoZW4gd2UgZGV0ZWN0IGEgcHJlZmV0Y2ggdGhhdCBjb3JyZXNwb25kcyB3aXRoIGFuIGludGVyY2VwdGlvbiByb3V0ZSwgd2UgcHJlZml4IGl0IHdpdGggbmV4dFVybCAoc2VlIGBjcmVhdGVQcmVmZXRjaENhY2hlS2V5YClcbiAgLy8gdG8gYXZvaWQgY29uZmxpY3RzIHdpdGggb3RoZXIgcGFnZXMgdGhhdCBtYXkgaGF2ZSB0aGUgc2FtZSBVUkwgYnV0IHJlbmRlciBkaWZmZXJlbnQgdGhpbmdzIGRlcGVuZGluZyBvbiB0aGUgYE5leHQtVVJMYCBoZWFkZXIuXG4gIGZvciAoY29uc3QgbWF5YmVOZXh0VXJsIG9mIFtuZXh0VXJsLCBudWxsXSkge1xuICAgIGNvbnN0IGNhY2hlS2V5V2l0aFBhcmFtcyA9IGNyZWF0ZVByZWZldGNoQ2FjaGVLZXlJbXBsKFxuICAgICAgdXJsLFxuICAgICAgdHJ1ZSxcbiAgICAgIG1heWJlTmV4dFVybFxuICAgIClcbiAgICBjb25zdCBjYWNoZUtleVdpdGhvdXRQYXJhbXMgPSBjcmVhdGVQcmVmZXRjaENhY2hlS2V5SW1wbChcbiAgICAgIHVybCxcbiAgICAgIGZhbHNlLFxuICAgICAgbWF5YmVOZXh0VXJsXG4gICAgKVxuXG4gICAgLy8gRmlyc3QsIHdlIGNoZWNrIGlmIHdlIGhhdmUgYSBjYWNoZSBlbnRyeSB0aGF0IGV4YWN0bHkgbWF0Y2hlcyB0aGUgVVJMXG4gICAgY29uc3QgY2FjaGVLZXlUb1VzZSA9IHVybC5zZWFyY2hcbiAgICAgID8gY2FjaGVLZXlXaXRoUGFyYW1zXG4gICAgICA6IGNhY2hlS2V5V2l0aG91dFBhcmFtc1xuXG4gICAgY29uc3QgZXhpc3RpbmdFbnRyeSA9IHByZWZldGNoQ2FjaGUuZ2V0KGNhY2hlS2V5VG9Vc2UpXG4gICAgaWYgKGV4aXN0aW5nRW50cnkgJiYgYWxsb3dBbGlhc2luZykge1xuICAgICAgLy8gV2Uga25vdyB3ZSdyZSByZXR1cm5pbmcgYW4gYWxpYXNlZCBlbnRyeSB3aGVuIHRoZSBwYXRobmFtZSBtYXRjaGVzIGJ1dCB0aGUgc2VhcmNoIHBhcmFtcyBkb24ndCxcbiAgICAgIGNvbnN0IGlzQWxpYXNlZCA9XG4gICAgICAgIGV4aXN0aW5nRW50cnkudXJsLnBhdGhuYW1lID09PSB1cmwucGF0aG5hbWUgJiZcbiAgICAgICAgZXhpc3RpbmdFbnRyeS51cmwuc2VhcmNoICE9PSB1cmwuc2VhcmNoXG5cbiAgICAgIGlmIChpc0FsaWFzZWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5leGlzdGluZ0VudHJ5LFxuICAgICAgICAgIGFsaWFzZWQ6IHRydWUsXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGV4aXN0aW5nRW50cnlcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgcmVxdWVzdCBjb250YWlucyBzZWFyY2ggcGFyYW1zLCBhbmQgd2UncmUgbm90IGRvaW5nIGEgZnVsbCBwcmVmZXRjaCwgd2UgY2FuIHJldHVybiB0aGVcbiAgICAvLyBwYXJhbS1sZXNzIGVudHJ5IGlmIGl0IGV4aXN0cy5cbiAgICAvLyBUaGlzIGlzIHRlY2huaWNhbGx5IGNvdmVyZWQgYnkgdGhlIGNoZWNrIGF0IHRoZSBib3R0b20gb2YgdGhpcyBmdW5jdGlvbiwgd2hpY2ggaXRlcmF0ZXMgb3ZlciBjYWNoZSBlbnRyaWVzLFxuICAgIC8vIGJ1dCBsZXRzIHVzIGFycml2ZSB0aGVyZSBxdWlja2VyIGluIHRoZSBwYXJhbS1mdWxsIGNhc2UuXG4gICAgY29uc3QgZW50cnlXaXRob3V0UGFyYW1zID0gcHJlZmV0Y2hDYWNoZS5nZXQoY2FjaGVLZXlXaXRob3V0UGFyYW1zKVxuICAgIGlmIChcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAnZGV2ZWxvcG1lbnQnICYmXG4gICAgICBhbGxvd0FsaWFzaW5nICYmXG4gICAgICB1cmwuc2VhcmNoICYmXG4gICAgICBraW5kICE9PSBQcmVmZXRjaEtpbmQuRlVMTCAmJlxuICAgICAgZW50cnlXaXRob3V0UGFyYW1zICYmXG4gICAgICAvLyBXZSBzaG91bGRuJ3QgcmV0dXJuIHRoZSBhbGlhc2VkIGVudHJ5IGlmIGl0IHdhcyByZWxvY2F0ZWQgdG8gYSBuZXcgY2FjaGUga2V5LlxuICAgICAgLy8gU2luY2UgaXQncyByZXdyaXR0ZW4sIGl0IGNvdWxkIHJlc3BvbmQgd2l0aCBhIGNvbXBsZXRlbHkgZGlmZmVyZW50IGxvYWRpbmcgc3RhdGUuXG4gICAgICAhZW50cnlXaXRob3V0UGFyYW1zLmtleS5pbmNsdWRlcyhJTlRFUkNFUFRJT05fQ0FDSEVfS0VZX01BUktFUilcbiAgICApIHtcbiAgICAgIHJldHVybiB7IC4uLmVudHJ5V2l0aG91dFBhcmFtcywgYWxpYXNlZDogdHJ1ZSB9XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgd2UndmUgZ290dGVuIHRvIHRoaXMgcG9pbnQsIHdlIGRpZG4ndCBmaW5kIGEgc3BlY2lmaWMgY2FjaGUgZW50cnkgdGhhdCBtYXRjaGVkXG4gIC8vIHRoZSByZXF1ZXN0IFVSTC5cbiAgLy8gV2UgYXR0ZW1wdCBhIHBhcnRpYWwgbWF0Y2ggYnkgY2hlY2tpbmcgaWYgdGhlcmUncyBhIGNhY2hlIGVudHJ5IHdpdGggdGhlIHNhbWUgcGF0aG5hbWUuXG4gIC8vIFJlZ2FyZGxlc3Mgb2Ygd2hhdCB3ZSBmaW5kLCBzaW5jZSBpdCBkb2Vzbid0IGNvcnJlc3BvbmQgd2l0aCB0aGUgcmVxdWVzdGVkIFVSTCwgd2UnbGwgbWFyayBpdCBcImFsaWFzZWRcIi5cbiAgLy8gVGhpcyB3aWxsIHNpZ25hbCB0byB0aGUgcm91dGVyIHRoYXQgaXQgc2hvdWxkIG9ubHkgYXBwbHkgdGhlIGxvYWRpbmcgc3RhdGUgb24gdGhlIHByZWZldGNoZWQgZGF0YS5cbiAgaWYgKFxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAnZGV2ZWxvcG1lbnQnICYmXG4gICAga2luZCAhPT0gUHJlZmV0Y2hLaW5kLkZVTEwgJiZcbiAgICBhbGxvd0FsaWFzaW5nXG4gICkge1xuICAgIGZvciAoY29uc3QgY2FjaGVFbnRyeSBvZiBwcmVmZXRjaENhY2hlLnZhbHVlcygpKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGNhY2hlRW50cnkudXJsLnBhdGhuYW1lID09PSB1cmwucGF0aG5hbWUgJiZcbiAgICAgICAgLy8gV2Ugc2hvdWxkbid0IHJldHVybiB0aGUgYWxpYXNlZCBlbnRyeSBpZiBpdCB3YXMgcmVsb2NhdGVkIHRvIGEgbmV3IGNhY2hlIGtleS5cbiAgICAgICAgLy8gU2luY2UgaXQncyByZXdyaXR0ZW4sIGl0IGNvdWxkIHJlc3BvbmQgd2l0aCBhIGNvbXBsZXRlbHkgZGlmZmVyZW50IGxvYWRpbmcgc3RhdGUuXG4gICAgICAgICFjYWNoZUVudHJ5LmtleS5pbmNsdWRlcyhJTlRFUkNFUFRJT05fQ0FDSEVfS0VZX01BUktFUilcbiAgICAgICkge1xuICAgICAgICByZXR1cm4geyAuLi5jYWNoZUVudHJ5LCBhbGlhc2VkOiB0cnVlIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkXG59XG5cbi8qKlxuICogUmV0dXJucyBhIHByZWZldGNoIGNhY2hlIGVudHJ5IGlmIG9uZSBleGlzdHMuIE90aGVyd2lzZSBjcmVhdGVzIGEgbmV3IG9uZSBhbmQgZW5xdWV1ZXMgYSBmZXRjaCByZXF1ZXN0XG4gKiB0byByZXRyaWV2ZSB0aGUgcHJlZmV0Y2ggZGF0YSBmcm9tIHRoZSBzZXJ2ZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRPckNyZWF0ZVByZWZldGNoQ2FjaGVFbnRyeSh7XG4gIHVybCxcbiAgbmV4dFVybCxcbiAgdHJlZSxcbiAgcHJlZmV0Y2hDYWNoZSxcbiAga2luZCxcbiAgYWxsb3dBbGlhc2luZyA9IHRydWUsXG59OiBQaWNrPFJlYWRvbmx5UmVkdWNlclN0YXRlLCAnbmV4dFVybCcgfCAncHJlZmV0Y2hDYWNoZScgfCAndHJlZSc+ICYge1xuICB1cmw6IFVSTFxuICBraW5kPzogUHJlZmV0Y2hLaW5kXG4gIGFsbG93QWxpYXNpbmc6IGJvb2xlYW5cbn0pOiBBbGlhc2VkUHJlZmV0Y2hDYWNoZUVudHJ5IHtcbiAgY29uc3QgZXhpc3RpbmdDYWNoZUVudHJ5ID0gZ2V0RXhpc3RpbmdDYWNoZUVudHJ5KFxuICAgIHVybCxcbiAgICBraW5kLFxuICAgIG5leHRVcmwsXG4gICAgcHJlZmV0Y2hDYWNoZSxcbiAgICBhbGxvd0FsaWFzaW5nXG4gIClcblxuICBpZiAoZXhpc3RpbmdDYWNoZUVudHJ5KSB7XG4gICAgLy8gR3JhYiB0aGUgbGF0ZXN0IHN0YXR1cyBvZiB0aGUgY2FjaGUgZW50cnkgYW5kIHVwZGF0ZSBpdFxuICAgIGV4aXN0aW5nQ2FjaGVFbnRyeS5zdGF0dXMgPSBnZXRQcmVmZXRjaEVudHJ5Q2FjaGVTdGF0dXMoZXhpc3RpbmdDYWNoZUVudHJ5KVxuXG4gICAgLy8gd2hlbiBga2luZGAgaXMgcHJvdmlkZWQsIGFuIGV4cGxpY2l0IHByZWZldGNoIHdhcyByZXF1ZXN0ZWQuXG4gICAgLy8gaWYgdGhlIHJlcXVlc3RlZCBwcmVmZXRjaCBpcyBcImZ1bGxcIiBhbmQgdGhlIGN1cnJlbnQgY2FjaGUgZW50cnkgd2Fzbid0LCB3ZSB3YW50IHRvIHJlLXByZWZldGNoIHdpdGggdGhlIG5ldyBpbnRlbnRcbiAgICBjb25zdCBzd2l0Y2hlZFRvRnVsbFByZWZldGNoID1cbiAgICAgIGV4aXN0aW5nQ2FjaGVFbnRyeS5raW5kICE9PSBQcmVmZXRjaEtpbmQuRlVMTCAmJlxuICAgICAga2luZCA9PT0gUHJlZmV0Y2hLaW5kLkZVTExcblxuICAgIGlmIChzd2l0Y2hlZFRvRnVsbFByZWZldGNoKSB7XG4gICAgICAvLyBJZiB3ZSBzd2l0Y2hlZCB0byBhIGZ1bGwgcHJlZmV0Y2gsIHZhbGlkYXRlIHRoYXQgdGhlIGV4aXN0aW5nIGNhY2hlIGVudHJ5IGNvbnRhaW5lZCBwYXJ0aWFsIGRhdGEuXG4gICAgICAvLyBJdCdzIHBvc3NpYmxlIHRoYXQgdGhlIGNhY2hlIGVudHJ5IHdhcyBzZWVkZWQgd2l0aCBmdWxsIGRhdGEgYnV0IGhhcyBhIGNhY2hlIHR5cGUgb2YgXCJhdXRvXCIgKGllIHdoZW4gY2FjaGUgZW50cmllc1xuICAgICAgLy8gYXJlIHNlZWRlZCBidXQgd2l0aG91dCBhIHByZWZldGNoIGludGVudClcbiAgICAgIGV4aXN0aW5nQ2FjaGVFbnRyeS5kYXRhLnRoZW4oKHByZWZldGNoUmVzcG9uc2UpID0+IHtcbiAgICAgICAgY29uc3QgaXNGdWxsUHJlZmV0Y2ggPVxuICAgICAgICAgIEFycmF5LmlzQXJyYXkocHJlZmV0Y2hSZXNwb25zZS5mbGlnaHREYXRhKSAmJlxuICAgICAgICAgIHByZWZldGNoUmVzcG9uc2UuZmxpZ2h0RGF0YS5zb21lKChmbGlnaHREYXRhKSA9PiB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBzdGFydGVkIHJlbmRlcmluZyBmcm9tIHRoZSByb290IGFuZCB3ZSByZXR1cm5lZCBSU0MgZGF0YSAoc2VlZERhdGEpLCB3ZSBhbHJlYWR5IGhhZCBhIGZ1bGwgcHJlZmV0Y2guXG4gICAgICAgICAgICByZXR1cm4gZmxpZ2h0RGF0YS5pc1Jvb3RSZW5kZXIgJiYgZmxpZ2h0RGF0YS5zZWVkRGF0YSAhPT0gbnVsbFxuICAgICAgICAgIH0pXG5cbiAgICAgICAgaWYgKCFpc0Z1bGxQcmVmZXRjaCkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVMYXp5UHJlZmV0Y2hFbnRyeSh7XG4gICAgICAgICAgICB0cmVlLFxuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgbmV4dFVybCxcbiAgICAgICAgICAgIHByZWZldGNoQ2FjaGUsXG4gICAgICAgICAgICAvLyBJZiB3ZSBkaWRuJ3QgZ2V0IGFuIGV4cGxpY2l0IHByZWZldGNoIGtpbmQsIHdlIHdhbnQgdG8gc2V0IGEgdGVtcG9yYXJ5IGtpbmRcbiAgICAgICAgICAgIC8vIHJhdGhlciB0aGFuIGFzc3VtaW5nIHRoZSBzYW1lIGludGVudCBhcyB0aGUgcHJldmlvdXMgZW50cnksIHRvIGJlIGNvbnNpc3RlbnQgd2l0aCBob3cgd2VcbiAgICAgICAgICAgIC8vIGxhemlseSBjcmVhdGUgcHJlZmV0Y2ggZW50cmllcyB3aGVuIGludGVudCBpcyBsZWZ0IHVuc3BlY2lmaWVkLlxuICAgICAgICAgICAga2luZDoga2luZCA/PyBQcmVmZXRjaEtpbmQuVEVNUE9SQVJZLFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGV4aXN0aW5nIGNhY2hlIGVudHJ5IHdhcyBtYXJrZWQgYXMgdGVtcG9yYXJ5LCBpdCBtZWFucyBpdCB3YXMgbGF6aWx5IGNyZWF0ZWQgd2hlbiBhdHRlbXB0aW5nIHRvIGdldCBhbiBlbnRyeSxcbiAgICAvLyB3aGVyZSB3ZSBkaWRuJ3QgaGF2ZSB0aGUgcHJlZmV0Y2ggaW50ZW50LiBOb3cgdGhhdCB3ZSBoYXZlIHRoZSBpbnRlbnQgKGluIGBraW5kYCksIHdlIHdhbnQgdG8gdXBkYXRlIHRoZSBlbnRyeSB0byB0aGUgbW9yZSBhY2N1cmF0ZSBraW5kLlxuICAgIGlmIChraW5kICYmIGV4aXN0aW5nQ2FjaGVFbnRyeS5raW5kID09PSBQcmVmZXRjaEtpbmQuVEVNUE9SQVJZKSB7XG4gICAgICBleGlzdGluZ0NhY2hlRW50cnkua2luZCA9IGtpbmRcbiAgICB9XG5cbiAgICAvLyBXZSd2ZSBkZXRlcm1pbmVkIHRoYXQgdGhlIGV4aXN0aW5nIGVudHJ5IHdlIGZvdW5kIGlzIHN0aWxsIHZhbGlkLCBzbyB3ZSByZXR1cm4gaXQuXG4gICAgcmV0dXJuIGV4aXN0aW5nQ2FjaGVFbnRyeVxuICB9XG5cbiAgLy8gSWYgd2UgZGlkbid0IHJldHVybiBhbiBlbnRyeSwgY3JlYXRlIGEgbmV3IG9uZS5cbiAgcmV0dXJuIGNyZWF0ZUxhenlQcmVmZXRjaEVudHJ5KHtcbiAgICB0cmVlLFxuICAgIHVybCxcbiAgICBuZXh0VXJsLFxuICAgIHByZWZldGNoQ2FjaGUsXG4gICAga2luZDoga2luZCB8fCBQcmVmZXRjaEtpbmQuVEVNUE9SQVJZLFxuICB9KVxufVxuXG4vKlxuICogVXNlZCB0byB0YWtlIGFuIGV4aXN0aW5nIGNhY2hlIGVudHJ5IGFuZCBwcmVmaXggaXQgd2l0aCB0aGUgbmV4dFVybCwgaWYgaXQgZXhpc3RzLlxuICogVGhpcyBlbnN1cmVzIHRoYXQgd2UgZG9uJ3QgaGF2ZSBjb25mbGljdGluZyBjYWNoZSBlbnRyaWVzIGZvciB0aGUgc2FtZSBVUkwgKGFzIGlzIHRoZSBjYXNlIHdpdGggcm91dGUgaW50ZXJjZXB0aW9uKS5cbiAqL1xuZnVuY3Rpb24gcHJlZml4RXhpc3RpbmdQcmVmZXRjaENhY2hlRW50cnkoe1xuICB1cmwsXG4gIG5leHRVcmwsXG4gIHByZWZldGNoQ2FjaGUsXG4gIGV4aXN0aW5nQ2FjaGVLZXksXG59OiBQaWNrPFJlYWRvbmx5UmVkdWNlclN0YXRlLCAnbmV4dFVybCcgfCAncHJlZmV0Y2hDYWNoZSc+ICYge1xuICB1cmw6IFVSTFxuICBleGlzdGluZ0NhY2hlS2V5OiBzdHJpbmdcbn0pIHtcbiAgY29uc3QgZXhpc3RpbmdDYWNoZUVudHJ5ID0gcHJlZmV0Y2hDYWNoZS5nZXQoZXhpc3RpbmdDYWNoZUtleSlcbiAgaWYgKCFleGlzdGluZ0NhY2hlRW50cnkpIHtcbiAgICAvLyBuby1vcCAtLSB0aGVyZSB3YXNuJ3QgYW4gZW50cnkgdG8gbW92ZVxuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3QgbmV3Q2FjaGVLZXkgPSBjcmVhdGVQcmVmZXRjaENhY2hlS2V5KFxuICAgIHVybCxcbiAgICBleGlzdGluZ0NhY2hlRW50cnkua2luZCxcbiAgICBuZXh0VXJsXG4gIClcbiAgcHJlZmV0Y2hDYWNoZS5zZXQobmV3Q2FjaGVLZXksIHsgLi4uZXhpc3RpbmdDYWNoZUVudHJ5LCBrZXk6IG5ld0NhY2hlS2V5IH0pXG4gIHByZWZldGNoQ2FjaGUuZGVsZXRlKGV4aXN0aW5nQ2FjaGVLZXkpXG5cbiAgcmV0dXJuIG5ld0NhY2hlS2V5XG59XG5cbi8qKlxuICogVXNlIHRvIHNlZWQgdGhlIHByZWZldGNoIGNhY2hlIHdpdGggZGF0YSB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gZmV0Y2hlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNlZWRlZFByZWZldGNoQ2FjaGVFbnRyeSh7XG4gIG5leHRVcmwsXG4gIHRyZWUsXG4gIHByZWZldGNoQ2FjaGUsXG4gIHVybCxcbiAgZGF0YSxcbiAga2luZCxcbn06IFBpY2s8UmVhZG9ubHlSZWR1Y2VyU3RhdGUsICduZXh0VXJsJyB8ICd0cmVlJyB8ICdwcmVmZXRjaENhY2hlJz4gJiB7XG4gIHVybDogVVJMXG4gIGRhdGE6IEZldGNoU2VydmVyUmVzcG9uc2VSZXN1bHRcbiAga2luZDogUHJlZmV0Y2hLaW5kXG59KSB7XG4gIC8vIFRoZSBpbml0aWFsIGNhY2hlIGVudHJ5IHRlY2huaWNhbGx5IGluY2x1ZGVzIGZ1bGwgZGF0YSwgYnV0IGl0IGlzbid0IGV4cGxpY2l0bHkgcHJlZmV0Y2hlZCAtLSB3ZSBqdXN0IHNlZWQgdGhlXG4gIC8vIHByZWZldGNoIGNhY2hlIHNvIHRoYXQgd2UgY2FuIHNraXAgYW4gZXh0cmEgcHJlZmV0Y2ggcmVxdWVzdCBsYXRlciwgc2luY2Ugd2UgYWxyZWFkeSBoYXZlIHRoZSBkYXRhLlxuICAvLyBpZiB0aGUgcHJlZmV0Y2ggY29ycmVzcG9uZHMgd2l0aCBhbiBpbnRlcmNlcHRpb24gcm91dGUsIHdlIHVzZSB0aGUgbmV4dFVybCB0byBwcmVmaXggdGhlIGNhY2hlIGtleVxuICBjb25zdCBwcmVmZXRjaENhY2hlS2V5ID0gZGF0YS5jb3VsZEJlSW50ZXJjZXB0ZWRcbiAgICA/IGNyZWF0ZVByZWZldGNoQ2FjaGVLZXkodXJsLCBraW5kLCBuZXh0VXJsKVxuICAgIDogY3JlYXRlUHJlZmV0Y2hDYWNoZUtleSh1cmwsIGtpbmQpXG5cbiAgY29uc3QgcHJlZmV0Y2hFbnRyeSA9IHtcbiAgICB0cmVlQXRUaW1lT2ZQcmVmZXRjaDogdHJlZSxcbiAgICBkYXRhOiBQcm9taXNlLnJlc29sdmUoZGF0YSksXG4gICAga2luZCxcbiAgICBwcmVmZXRjaFRpbWU6IERhdGUubm93KCksXG4gICAgbGFzdFVzZWRUaW1lOiBEYXRlLm5vdygpLFxuICAgIHN0YWxlVGltZTogZGF0YS5zdGFsZVRpbWUsXG4gICAga2V5OiBwcmVmZXRjaENhY2hlS2V5LFxuICAgIHN0YXR1czogUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzLmZyZXNoLFxuICAgIHVybCxcbiAgfSBzYXRpc2ZpZXMgUHJlZmV0Y2hDYWNoZUVudHJ5XG5cbiAgcHJlZmV0Y2hDYWNoZS5zZXQocHJlZmV0Y2hDYWNoZUtleSwgcHJlZmV0Y2hFbnRyeSlcblxuICByZXR1cm4gcHJlZmV0Y2hFbnRyeVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBwcmVmZXRjaCBlbnRyeSBlbnRyeSBhbmQgZW5xdWV1ZXMgYSBmZXRjaCByZXF1ZXN0IHRvIHJldHJpZXZlIHRoZSBkYXRhLlxuICovXG5mdW5jdGlvbiBjcmVhdGVMYXp5UHJlZmV0Y2hFbnRyeSh7XG4gIHVybCxcbiAga2luZCxcbiAgdHJlZSxcbiAgbmV4dFVybCxcbiAgcHJlZmV0Y2hDYWNoZSxcbn06IFBpY2s8UmVhZG9ubHlSZWR1Y2VyU3RhdGUsICduZXh0VXJsJyB8ICd0cmVlJyB8ICdwcmVmZXRjaENhY2hlJz4gJiB7XG4gIHVybDogVVJMXG4gIGtpbmQ6IFByZWZldGNoS2luZFxufSk6IFByZWZldGNoQ2FjaGVFbnRyeSB7XG4gIGNvbnN0IHByZWZldGNoQ2FjaGVLZXkgPSBjcmVhdGVQcmVmZXRjaENhY2hlS2V5KHVybCwga2luZClcblxuICAvLyBpbml0aWF0ZXMgdGhlIGZldGNoIHJlcXVlc3QgZm9yIHRoZSBwcmVmZXRjaCBhbmQgYXR0YWNoZXMgYSBsaXN0ZW5lclxuICAvLyB0byB0aGUgcHJvbWlzZSB0byB1cGRhdGUgdGhlIHByZWZldGNoIGNhY2hlIGVudHJ5IHdoZW4gdGhlIHByb21pc2UgcmVzb2x2ZXMgKGlmIG5lY2Vzc2FyeSlcbiAgY29uc3QgZGF0YSA9IHByZWZldGNoUXVldWUuZW5xdWV1ZSgoKSA9PlxuICAgIGZldGNoU2VydmVyUmVzcG9uc2UodXJsLCB7XG4gICAgICBmbGlnaHRSb3V0ZXJTdGF0ZTogdHJlZSxcbiAgICAgIG5leHRVcmwsXG4gICAgICBwcmVmZXRjaEtpbmQ6IGtpbmQsXG4gICAgfSkudGhlbigocHJlZmV0Y2hSZXNwb25zZSkgPT4ge1xuICAgICAgLy8gVE9ETzogYGZldGNoU2VydmVyUmVzcG9uc2VgIHNob3VsZCBiZSBtb3JlIHRpZ2hseSBjb3VwbGVkIHRvIHRoZXNlIHByZWZldGNoIGNhY2hlIG9wZXJhdGlvbnNcbiAgICAgIC8vIHRvIGF2b2lkIGRyaWZ0IGJldHdlZW4gdGhpcyBjYWNoZSBrZXkgcHJlZml4aW5nIGxvZ2ljXG4gICAgICAvLyAod2hpY2ggaXMgY3VycmVudGx5IGRpcmVjdGx5IGluZmx1ZW5jZWQgYnkgdGhlIHNlcnZlciByZXNwb25zZSlcbiAgICAgIGxldCBuZXdDYWNoZUtleVxuXG4gICAgICBpZiAocHJlZmV0Y2hSZXNwb25zZS5jb3VsZEJlSW50ZXJjZXB0ZWQpIHtcbiAgICAgICAgLy8gRGV0ZXJtaW5lIGlmIHdlIG5lZWQgdG8gcHJlZml4IHRoZSBjYWNoZSBrZXkgd2l0aCB0aGUgbmV4dFVybFxuICAgICAgICBuZXdDYWNoZUtleSA9IHByZWZpeEV4aXN0aW5nUHJlZmV0Y2hDYWNoZUVudHJ5KHtcbiAgICAgICAgICB1cmwsXG4gICAgICAgICAgZXhpc3RpbmdDYWNoZUtleTogcHJlZmV0Y2hDYWNoZUtleSxcbiAgICAgICAgICBuZXh0VXJsLFxuICAgICAgICAgIHByZWZldGNoQ2FjaGUsXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSBwcmVmZXRjaCB3YXMgYSBjYWNoZSBoaXQsIHdlIHdhbnQgdG8gdXBkYXRlIHRoZSBleGlzdGluZyBjYWNoZSBlbnRyeSB0byByZWZsZWN0IHRoYXQgaXQgd2FzIGEgZnVsbCBwcmVmZXRjaC5cbiAgICAgIC8vIFRoaXMgaXMgYmVjYXVzZSB3ZSBrbm93IHRoYXQgYSBzdGF0aWMgcmVzcG9uc2Ugd2lsbCBjb250YWluIHRoZSBmdWxsIFJTQyBwYXlsb2FkLCBhbmQgY2FuIGJlIHVwZGF0ZWQgdG8gcmVzcGVjdCB0aGUgYHN0YXRpY2BcbiAgICAgIC8vIHN0YWxlVGltZS5cbiAgICAgIGlmIChwcmVmZXRjaFJlc3BvbnNlLnByZXJlbmRlcmVkKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nQ2FjaGVFbnRyeSA9IHByZWZldGNoQ2FjaGUuZ2V0KFxuICAgICAgICAgIC8vIGlmIHdlIHByZWZpeGVkIHRoZSBjYWNoZSBrZXkgZHVlIHRvIHJvdXRlIGludGVyY2VwdGlvbiwgd2Ugd2FudCB0byB1c2UgdGhlIG5ldyBrZXkuIE90aGVyd2lzZSB3ZSB1c2UgdGhlIG9yaWdpbmFsIGtleVxuICAgICAgICAgIG5ld0NhY2hlS2V5ID8/IHByZWZldGNoQ2FjaGVLZXlcbiAgICAgICAgKVxuICAgICAgICBpZiAoZXhpc3RpbmdDYWNoZUVudHJ5KSB7XG4gICAgICAgICAgZXhpc3RpbmdDYWNoZUVudHJ5LmtpbmQgPSBQcmVmZXRjaEtpbmQuRlVMTFxuICAgICAgICAgIGlmIChwcmVmZXRjaFJlc3BvbnNlLnN0YWxlVGltZSAhPT0gLTEpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIHN0YWxlIHRpbWUgdGhhdCB3YXMgY29sbGVjdGVkIGJ5IHRoZSBzZXJ2ZXIgZHVyaW5nXG4gICAgICAgICAgICAvLyBzdGF0aWMgZ2VuZXJhdGlvbi4gVXNlIHRoaXMgaW4gcGxhY2Ugb2YgdGhlIGRlZmF1bHQgc3RhbGUgdGltZS5cbiAgICAgICAgICAgIGV4aXN0aW5nQ2FjaGVFbnRyeS5zdGFsZVRpbWUgPSBwcmVmZXRjaFJlc3BvbnNlLnN0YWxlVGltZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJlZmV0Y2hSZXNwb25zZVxuICAgIH0pXG4gIClcblxuICBjb25zdCBwcmVmZXRjaEVudHJ5ID0ge1xuICAgIHRyZWVBdFRpbWVPZlByZWZldGNoOiB0cmVlLFxuICAgIGRhdGEsXG4gICAga2luZCxcbiAgICBwcmVmZXRjaFRpbWU6IERhdGUubm93KCksXG4gICAgbGFzdFVzZWRUaW1lOiBudWxsLFxuICAgIHN0YWxlVGltZTogLTEsXG4gICAga2V5OiBwcmVmZXRjaENhY2hlS2V5LFxuICAgIHN0YXR1czogUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzLmZyZXNoLFxuICAgIHVybCxcbiAgfVxuXG4gIHByZWZldGNoQ2FjaGUuc2V0KHByZWZldGNoQ2FjaGVLZXksIHByZWZldGNoRW50cnkpXG5cbiAgcmV0dXJuIHByZWZldGNoRW50cnlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBydW5lUHJlZmV0Y2hDYWNoZShcbiAgcHJlZmV0Y2hDYWNoZTogUmVhZG9ubHlSZWR1Y2VyU3RhdGVbJ3ByZWZldGNoQ2FjaGUnXVxuKSB7XG4gIGZvciAoY29uc3QgW2hyZWYsIHByZWZldGNoQ2FjaGVFbnRyeV0gb2YgcHJlZmV0Y2hDYWNoZSkge1xuICAgIGlmIChcbiAgICAgIGdldFByZWZldGNoRW50cnlDYWNoZVN0YXR1cyhwcmVmZXRjaENhY2hlRW50cnkpID09PVxuICAgICAgUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzLmV4cGlyZWRcbiAgICApIHtcbiAgICAgIHByZWZldGNoQ2FjaGUuZGVsZXRlKGhyZWYpXG4gICAgfVxuICB9XG59XG5cbi8vIFRoZXNlIHZhbHVlcyBhcmUgc2V0IGJ5IGBkZWZpbmUtZW52LXBsdWdpbmAgKGJhc2VkIG9uIGBuZXh0Q29uZmlnLmV4cGVyaW1lbnRhbC5zdGFsZVRpbWVzYClcbi8vIGFuZCBkZWZhdWx0IHRvIDUgbWludXRlcyAoc3RhdGljKSAvIDAgc2Vjb25kcyAoZHluYW1pYylcbmV4cG9ydCBjb25zdCBEWU5BTUlDX1NUQUxFVElNRV9NUyA9XG4gIE51bWJlcihwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1JPVVRFUl9EWU5BTUlDX1NUQUxFVElNRSkgKiAxMDAwXG5cbmV4cG9ydCBjb25zdCBTVEFUSUNfU1RBTEVUSU1FX01TID1cbiAgTnVtYmVyKHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfUk9VVEVSX1NUQVRJQ19TVEFMRVRJTUUpICogMTAwMFxuXG5mdW5jdGlvbiBnZXRQcmVmZXRjaEVudHJ5Q2FjaGVTdGF0dXMoe1xuICBraW5kLFxuICBwcmVmZXRjaFRpbWUsXG4gIGxhc3RVc2VkVGltZSxcbiAgc3RhbGVUaW1lLFxufTogUHJlZmV0Y2hDYWNoZUVudHJ5KTogUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzIHtcbiAgaWYgKHN0YWxlVGltZSAhPT0gLTEpIHtcbiAgICAvLyBgc3RhbGVUaW1lYCBpcyB0aGUgdmFsdWUgc2VudCBieSB0aGUgc2VydmVyIGR1cmluZyBzdGF0aWMgZ2VuZXJhdGlvbi5cbiAgICAvLyBXaGVuIHRoaXMgaXMgYXZhaWxhYmxlLCBpdCB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgYW55IG9mIHRoZSBoZXVyaXN0aWNzXG4gICAgLy8gdGhhdCBmb2xsb3cuXG4gICAgLy9cbiAgICAvLyBUT0RPOiBXaGVuIFBQUiBpcyBlbmFibGVkLCB0aGUgc2VydmVyIHdpbGwgKmFsd2F5cyogcmV0dXJuIGEgc3RhbGUgdGltZVxuICAgIC8vIHdoZW4gcHJlZmV0Y2hpbmcuIFdlIHNob3VsZCBuZXZlciB1c2UgYSBwcmVmZXRjaCBlbnRyeSB0aGF0IGhhc24ndCB5ZXRcbiAgICAvLyByZWNlaXZlZCBkYXRhIGZyb20gdGhlIHNlcnZlci4gU28gdGhlIG9ubHkgdHdvIGNhc2VzIHNob3VsZCBiZSAxKSB3ZSB1c2VcbiAgICAvLyB0aGUgc2VydmVyLWdlbmVyYXRlZCBzdGFsZSB0aW1lIDIpIHRoZSB1bnJlc29sdmVkIGVudHJ5IGlzIGRpc2NhcmRlZC5cbiAgICByZXR1cm4gRGF0ZS5ub3coKSA8IHByZWZldGNoVGltZSArIHN0YWxlVGltZVxuICAgICAgPyBQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMuZnJlc2hcbiAgICAgIDogUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzLnN0YWxlXG4gIH1cblxuICAvLyBXZSB3aWxsIHJlLXVzZSB0aGUgY2FjaGUgZW50cnkgZGF0YSBmb3IgdXAgdG8gdGhlIGBkeW5hbWljYCBzdGFsZXRpbWUgd2luZG93LlxuICBpZiAoRGF0ZS5ub3coKSA8IChsYXN0VXNlZFRpbWUgPz8gcHJlZmV0Y2hUaW1lKSArIERZTkFNSUNfU1RBTEVUSU1FX01TKSB7XG4gICAgcmV0dXJuIGxhc3RVc2VkVGltZVxuICAgICAgPyBQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMucmV1c2FibGVcbiAgICAgIDogUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzLmZyZXNoXG4gIH1cblxuICAvLyBGb3IgXCJhdXRvXCIgcHJlZmV0Y2hpbmcsIHdlJ2xsIHJlLXVzZSBvbmx5IHRoZSBsb2FkaW5nIGJvdW5kYXJ5IGZvciB1cCB0byBgc3RhdGljYCBzdGFsZXRpbWUgd2luZG93LlxuICAvLyBBIHN0YWxlIGVudHJ5IHdpbGwgb25seSByZS11c2UgdGhlIGBsb2FkaW5nYCBib3VuZGFyeSwgbm90IHRoZSBmdWxsIGRhdGEuXG4gIC8vIFRoaXMgd2lsbCB0cmlnZ2VyIGEgXCJsYXp5IGZldGNoXCIgZm9yIHRoZSBmdWxsIGRhdGEuXG4gIGlmIChraW5kID09PSBQcmVmZXRjaEtpbmQuQVVUTykge1xuICAgIGlmIChEYXRlLm5vdygpIDwgcHJlZmV0Y2hUaW1lICsgU1RBVElDX1NUQUxFVElNRV9NUykge1xuICAgICAgcmV0dXJuIFByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cy5zdGFsZVxuICAgIH1cbiAgfVxuXG4gIC8vIGZvciBcImZ1bGxcIiBwcmVmZXRjaGluZywgd2UnbGwgcmUtdXNlIHRoZSBjYWNoZSBlbnRyeSBkYXRhIGZvciB1cCB0byBgc3RhdGljYCBzdGFsZXRpbWUgd2luZG93LlxuICBpZiAoa2luZCA9PT0gUHJlZmV0Y2hLaW5kLkZVTEwpIHtcbiAgICBpZiAoRGF0ZS5ub3coKSA8IHByZWZldGNoVGltZSArIFNUQVRJQ19TVEFMRVRJTUVfTVMpIHtcbiAgICAgIHJldHVybiBQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMucmV1c2FibGVcbiAgICB9XG4gIH1cblxuICByZXR1cm4gUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzLmV4cGlyZWRcbn1cbiJdLCJuYW1lcyI6WyJEWU5BTUlDX1NUQUxFVElNRV9NUyIsIlNUQVRJQ19TVEFMRVRJTUVfTVMiLCJjcmVhdGVTZWVkZWRQcmVmZXRjaENhY2hlRW50cnkiLCJnZXRPckNyZWF0ZVByZWZldGNoQ2FjaGVFbnRyeSIsInBydW5lUHJlZmV0Y2hDYWNoZSIsIklOVEVSQ0VQVElPTl9DQUNIRV9LRVlfTUFSS0VSIiwiY3JlYXRlUHJlZmV0Y2hDYWNoZUtleUltcGwiLCJ1cmwiLCJpbmNsdWRlU2VhcmNoUGFyYW1zIiwicHJlZml4IiwicGF0aG5hbWVGcm9tVXJsIiwicGF0aG5hbWUiLCJzZWFyY2giLCJjcmVhdGVQcmVmZXRjaENhY2hlS2V5Iiwia2luZCIsIm5leHRVcmwiLCJQcmVmZXRjaEtpbmQiLCJGVUxMIiwiZ2V0RXhpc3RpbmdDYWNoZUVudHJ5IiwicHJlZmV0Y2hDYWNoZSIsImFsbG93QWxpYXNpbmciLCJURU1QT1JBUlkiLCJtYXliZU5leHRVcmwiLCJjYWNoZUtleVdpdGhQYXJhbXMiLCJjYWNoZUtleVdpdGhvdXRQYXJhbXMiLCJjYWNoZUtleVRvVXNlIiwiZXhpc3RpbmdFbnRyeSIsImdldCIsImlzQWxpYXNlZCIsImFsaWFzZWQiLCJlbnRyeVdpdGhvdXRQYXJhbXMiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJrZXkiLCJpbmNsdWRlcyIsImNhY2hlRW50cnkiLCJ2YWx1ZXMiLCJ1bmRlZmluZWQiLCJ0cmVlIiwiZXhpc3RpbmdDYWNoZUVudHJ5Iiwic3RhdHVzIiwiZ2V0UHJlZmV0Y2hFbnRyeUNhY2hlU3RhdHVzIiwic3dpdGNoZWRUb0Z1bGxQcmVmZXRjaCIsImRhdGEiLCJ0aGVuIiwicHJlZmV0Y2hSZXNwb25zZSIsImlzRnVsbFByZWZldGNoIiwiQXJyYXkiLCJpc0FycmF5IiwiZmxpZ2h0RGF0YSIsInNvbWUiLCJpc1Jvb3RSZW5kZXIiLCJzZWVkRGF0YSIsImNyZWF0ZUxhenlQcmVmZXRjaEVudHJ5IiwicHJlZml4RXhpc3RpbmdQcmVmZXRjaENhY2hlRW50cnkiLCJleGlzdGluZ0NhY2hlS2V5IiwibmV3Q2FjaGVLZXkiLCJzZXQiLCJkZWxldGUiLCJwcmVmZXRjaENhY2hlS2V5IiwiY291bGRCZUludGVyY2VwdGVkIiwicHJlZmV0Y2hFbnRyeSIsInRyZWVBdFRpbWVPZlByZWZldGNoIiwiUHJvbWlzZSIsInJlc29sdmUiLCJwcmVmZXRjaFRpbWUiLCJEYXRlIiwibm93IiwibGFzdFVzZWRUaW1lIiwic3RhbGVUaW1lIiwiUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzIiwiZnJlc2giLCJwcmVmZXRjaFF1ZXVlIiwiZW5xdWV1ZSIsImZldGNoU2VydmVyUmVzcG9uc2UiLCJmbGlnaHRSb3V0ZXJTdGF0ZSIsInByZWZldGNoS2luZCIsInByZXJlbmRlcmVkIiwiaHJlZiIsInByZWZldGNoQ2FjaGVFbnRyeSIsImV4cGlyZWQiLCJOdW1iZXIiLCJfX05FWFRfQ0xJRU5UX1JPVVRFUl9EWU5BTUlDX1NUQUxFVElNRSIsIl9fTkVYVF9DTElFTlRfUk9VVEVSX1NUQVRJQ19TVEFMRVRJTUUiLCJzdGFsZSIsInJldXNhYmxlIiwiQVVUTyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7SUE0WWFBLG9CQUFvQixFQUFBO2VBQXBCQTs7SUFHQUMsbUJBQW1CLEVBQUE7ZUFBbkJBOztJQW5JR0MsOEJBQThCLEVBQUE7ZUFBOUJBOztJQTlHQUMsNkJBQTZCLEVBQUE7ZUFBN0JBOztJQStOQUMsa0JBQWtCLEVBQUE7ZUFBbEJBOzs7cUNBMVhUO29DQU1BO2lDQUN1QjtBQUU5QixNQUFNQyxnQ0FBZ0M7QUFVdEM7Ozs7OztDQU1DLEdBQ0QsU0FBU0MsMkJBQ1BDLEdBQVEsRUFDUkMsbUJBQTRCLEVBQzVCQyxNQUFzQjtJQUV0QixnRkFBZ0Y7SUFDaEYsZ0ZBQWdGO0lBQ2hG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bkQsT0FBT3NFLG9CQUFBQSx3QkFBd0IsQ0FBQ2MsS0FBSztRQUN2QztJQUNGO0lBRUEsaUdBQWlHO0lBQ2pHLElBQUl2RSxTQUFTRSxvQkFBQUEsWUFBWSxDQUFDQyxJQUFJLEVBQUU7UUFDOUIsSUFBSWtELEtBQUtDLEdBQUcsS0FBS0YsZUFBZWpFLHFCQUFxQjtZQUNuRCxPQUFPc0Usb0JBQUFBLHdCQUF3QixDQUFDZSxRQUFRO1FBQzFDO0lBQ0Y7SUFFQSxPQUFPZixvQkFBQUEsd0JBQXdCLENBQUNVLE9BQU87QUFDekMiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNTA4NywgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yZWR1Y2Vycy9wcmVmZXRjaC1yZWR1Y2VyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHtcbiAgUHJlZmV0Y2hBY3Rpb24sXG4gIFJlZHVjZXJTdGF0ZSxcbiAgUmVhZG9ubHlSZWR1Y2VyU3RhdGUsXG59IGZyb20gJy4uL3JvdXRlci1yZWR1Y2VyLXR5cGVzJ1xuaW1wb3J0IHsgUHJvbWlzZVF1ZXVlIH0gZnJvbSAnLi4vLi4vcHJvbWlzZS1xdWV1ZSdcbmltcG9ydCB7XG4gIGdldE9yQ3JlYXRlUHJlZmV0Y2hDYWNoZUVudHJ5LFxuICBwcnVuZVByZWZldGNoQ2FjaGUsXG59IGZyb20gJy4uL3ByZWZldGNoLWNhY2hlLXV0aWxzJ1xuZXhwb3J0IGNvbnN0IHByZWZldGNoUXVldWUgPSBuZXcgUHJvbWlzZVF1ZXVlKDUpXG5cbmV4cG9ydCBjb25zdCBwcmVmZXRjaFJlZHVjZXIgPSBwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1NFR01FTlRfQ0FDSEVcbiAgPyBpZGVudGl0eVJlZHVjZXJXaGVuU2VnbWVudENhY2hlSXNFbmFibGVkXG4gIDogcHJlZmV0Y2hSZWR1Y2VySW1wbFxuXG5mdW5jdGlvbiBpZGVudGl0eVJlZHVjZXJXaGVuU2VnbWVudENhY2hlSXNFbmFibGVkPFQ+KHN0YXRlOiBUKTogVCB7XG4gIC8vIFVubGlrZSB0aGUgb2xkIGltcGxlbWVudGF0aW9uLCB0aGUgU2VnbWVudCBDYWNoZSBkb2Vzbid0IHN0b3JlIGl0cyBkYXRhIGluXG4gIC8vIHRoZSByb3V0ZXIgcmVkdWNlciBzdGF0ZS5cbiAgLy9cbiAgLy8gVGhpcyBzaG91bGRuJ3QgYmUgcmVhY2hhYmxlIGJlY2F1c2Ugd2Ugd3JhcCB0aGUgcHJlZmV0Y2ggQVBJIGluIGEgY2hlY2ssXG4gIC8vIHRvbywgd2hpY2ggcHJldmVudHMgdGhlIGFjdGlvbiBmcm9tIGJlaW5nIGRpc3BhdGNoZWQuIEJ1dCBpdCdzIGhlcmUgZm9yXG4gIC8vIGNsYXJpdHkgKyBjb2RlIGVsaW1pbmF0aW9uLlxuICByZXR1cm4gc3RhdGVcbn1cblxuZnVuY3Rpb24gcHJlZmV0Y2hSZWR1Y2VySW1wbChcbiAgc3RhdGU6IFJlYWRvbmx5UmVkdWNlclN0YXRlLFxuICBhY3Rpb246IFByZWZldGNoQWN0aW9uXG4pOiBSZWR1Y2VyU3RhdGUge1xuICAvLyBsZXQncyBwcnVuZSB0aGUgcHJlZmV0Y2ggY2FjaGUgYmVmb3JlIHdlIGRvIGFueXRoaW5nIGVsc2VcbiAgcHJ1bmVQcmVmZXRjaENhY2hlKHN0YXRlLnByZWZldGNoQ2FjaGUpXG5cbiAgY29uc3QgeyB1cmwgfSA9IGFjdGlvblxuXG4gIGdldE9yQ3JlYXRlUHJlZmV0Y2hDYWNoZUVudHJ5KHtcbiAgICB1cmwsXG4gICAgbmV4dFVybDogc3RhdGUubmV4dFVybCxcbiAgICBwcmVmZXRjaENhY2hlOiBzdGF0ZS5wcmVmZXRjaENhY2hlLFxuICAgIGtpbmQ6IGFjdGlvbi5raW5kLFxuICAgIHRyZWU6IHN0YXRlLnRyZWUsXG4gICAgYWxsb3dBbGlhc2luZzogdHJ1ZSxcbiAgfSlcblxuICByZXR1cm4gc3RhdGVcbn1cbiJdLCJuYW1lcyI6WyJwcmVmZXRjaFF1ZXVlIiwicHJlZmV0Y2hSZWR1Y2VyIiwiUHJvbWlzZVF1ZXVlIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9DTElFTlRfU0VHTUVOVF9DQUNIRSIsImlkZW50aXR5UmVkdWNlcldoZW5TZWdtZW50Q2FjaGVJc0VuYWJsZWQiLCJwcmVmZXRjaFJlZHVjZXJJbXBsIiwic3RhdGUiLCJhY3Rpb24iLCJwcnVuZVByZWZldGNoQ2FjaGUiLCJwcmVmZXRjaENhY2hlIiwidXJsIiwiZ2V0T3JDcmVhdGVQcmVmZXRjaENhY2hlRW50cnkiLCJuZXh0VXJsIiwia2luZCIsInRyZWUiLCJhbGxvd0FsaWFzaW5nIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztJQVVhQSxhQUFhLEVBQUE7ZUFBYkE7O0lBRUFDLGVBQWUsRUFBQTtlQUFmQTs7OzhCQVBnQjtvQ0FJdEI7QUFDQSxNQUFNRCxnQkFBZ0IsSUFBSUUsY0FBQUEsWUFBWSxDQUFDO0FBRXZDLE1BQU1ELGtCQUFrQkUsUUFBUUMsR0FBRyxDQUFDQywwQkFDdkNDLENBRGtFLHlCQUVsRUM7QUFFSixTQUFTRCx5Q0FBNENFLEtBQVE7SUFDM0QsNkVBQTZFO0lBQzdFLDRCQUE0QjtJQUM1QixFQUFFO0lBQ0YsMkVBQTJFO0lBQzNFLDBFQUEwRTtJQUMxRSw4QkFBOEI7SUFDOUIsT0FBT0E7QUFDVDtBQUVBLFNBQVNELG9CQUNQQyxLQUEyQixFQUMzQkMsTUFBc0I7SUFFdEIsNERBQTREO0lBQzVEQyxDQUFBQSxHQUFBQSxvQkFBQUEsa0JBQWtCLEVBQUNGLE1BQU1HLGFBQWE7SUFFdEMsTUFBTSxFQUFFQyxHQUFHLEVBQUUsR0FBR0g7SUFFaEJJLENBQUFBLEdBQUFBLG9CQUFBQSw2QkFBNkIsRUFBQztRQUM1QkQ7UUFDQUUsU0FBU04sTUFBTU0sT0FBTztRQUN0QkgsZUFBZUgsTUFBTUcsYUFBYTtRQUNsQ0ksTUFBTU4sT0FBT00sSUFBSTtRQUNqQkMsTUFBTVIsTUFBTVEsSUFBSTtRQUNoQkMsZUFBZTtJQUNqQjtJQUVBLE9BQU9UO0FBQ1QiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNTE0OCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvY29tcG9uZW50cy9uYXZpZ2F0aW9uLXVudHJhY2tlZC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VDb250ZXh0IH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBQYXRobmFtZUNvbnRleHQgfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL2hvb2tzLWNsaWVudC1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuXG4vKipcbiAqIFRoaXMgY2hlY2tzIHRvIHNlZSBpZiB0aGUgY3VycmVudCByZW5kZXIgaGFzIGFueSB1bmtub3duIHJvdXRlIHBhcmFtZXRlcnMuXG4gKiBJdCdzIHVzZWQgdG8gdHJpZ2dlciBhIGRpZmZlcmVudCByZW5kZXIgcGF0aCBpbiB0aGUgZXJyb3IgYm91bmRhcnkuXG4gKlxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGVyZSBhcmUgYW55IHVua25vd24gcm91dGUgcGFyYW1ldGVycywgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmZ1bmN0aW9uIGhhc0ZhbGxiYWNrUm91dGVQYXJhbXMoKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIC8vIEFzeW5jTG9jYWxTdG9yYWdlIHNob3VsZCBub3QgYmUgaW5jbHVkZWQgaW4gdGhlIGNsaWVudCBidW5kbGUuXG4gICAgY29uc3QgeyB3b3JrQXN5bmNTdG9yYWdlIH0gPVxuICAgICAgcmVxdWlyZSgnLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvd29yay1hc3luYy1zdG9yYWdlLmV4dGVybmFsJykgYXMgdHlwZW9mIGltcG9ydCgnLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvd29yay1hc3luYy1zdG9yYWdlLmV4dGVybmFsJylcblxuICAgIGNvbnN0IHdvcmtTdG9yZSA9IHdvcmtBc3luY1N0b3JhZ2UuZ2V0U3RvcmUoKVxuICAgIGlmICghd29ya1N0b3JlKSByZXR1cm4gZmFsc2VcblxuICAgIGNvbnN0IHsgZmFsbGJhY2tSb3V0ZVBhcmFtcyB9ID0gd29ya1N0b3JlXG4gICAgaWYgKCFmYWxsYmFja1JvdXRlUGFyYW1zIHx8IGZhbGxiYWNrUm91dGVQYXJhbXMuc2l6ZSA9PT0gMCkgcmV0dXJuIGZhbHNlXG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qKlxuICogVGhpcyByZXR1cm5zIGEgYG51bGxgIHZhbHVlIGlmIHRoZXJlIGFyZSBhbnkgdW5rbm93biByb3V0ZSBwYXJhbWV0ZXJzLCBhbmRcbiAqIG90aGVyd2lzZSByZXR1cm5zIHRoZSBwYXRobmFtZSBmcm9tIHRoZSBjb250ZXh0LiBUaGlzIGlzIGFuIGFsdGVybmF0aXZlIHRvXG4gKiBgdXNlUGF0aG5hbWVgIHRoYXQgaXMgdXNlZCBpbiB0aGUgZXJyb3IgYm91bmRhcnkgdG8gYXZvaWQgcmVuZGVyaW5nIHRoZVxuICogZXJyb3IgYm91bmRhcnkgd2hlbiB0aGVyZSBhcmUgdW5rbm93biByb3V0ZSBwYXJhbWV0ZXJzLiBUaGlzIGRvZXNuJ3QgdGhyb3dcbiAqIHdoZW4gYWNjZXNzZWQgd2l0aCB1bmtub3duIHJvdXRlIHBhcmFtZXRlcnMuXG4gKlxuICogQHJldHVybnNcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVVudHJhY2tlZFBhdGhuYW1lKCk6IHN0cmluZyB8IG51bGwge1xuICAvLyBJZiB0aGVyZSBhcmUgYW55IHVua25vd24gcm91dGUgcGFyYW1ldGVycyB3ZSB3b3VsZCB0eXBpY2FsbHkgdGhyb3dcbiAgLy8gYW4gZXJyb3IsIGJ1dCB0aGlzIGludGVybmFsIG1ldGhvZCBhbGxvd3MgdXMgdG8gcmV0dXJuIGEgbnVsbCB2YWx1ZSBpbnN0ZWFkXG4gIC8vIGZvciBjb21wb25lbnRzIHRoYXQgZG8gbm90IHByb3BhZ2F0ZSB0aGUgcGF0aG5hbWUgdG8gdGhlIHN0YXRpYyBzaGVsbCAobGlrZVxuICAvLyB0aGUgZXJyb3IgYm91bmRhcnkpLlxuICBpZiAoaGFzRmFsbGJhY2tSb3V0ZVBhcmFtcygpKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8vIFRoaXMgc2hvdWxkbid0IGNhdXNlIGFueSBpc3N1ZXMgcmVsYXRlZCB0byBjb25kaXRpb25hbCByZW5kZXJpbmcgYmVjYXVzZVxuICAvLyB0aGUgZW52aXJvbm1lbnQgd2lsbCBiZSBjb25zaXN0ZW50IGZvciB0aGUgcmVuZGVyLlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgcmV0dXJuIHVzZUNvbnRleHQoUGF0aG5hbWVDb250ZXh0KVxufVxuIl0sIm5hbWVzIjpbInVzZVVudHJhY2tlZFBhdGhuYW1lIiwiaGFzRmFsbGJhY2tSb3V0ZVBhcmFtcyIsIndpbmRvdyIsIndvcmtBc3luY1N0b3JhZ2UiLCJyZXF1aXJlIiwid29ya1N0b3JlIiwiZ2V0U3RvcmUiLCJmYWxsYmFja1JvdXRlUGFyYW1zIiwic2l6ZSIsInVzZUNvbnRleHQiLCJQYXRobmFtZUNvbnRleHQiXSwibWFwcGluZ3MiOiI7OzsrQkFzQ2dCQSx3QkFBQUE7OztlQUFBQTs7O3VCQXRDVztpREFDSztBQUVoQzs7Ozs7Q0FLQyxHQUNELFNBQVNDO0lBQ1AsSUFBSSxPQUFPQyxXQUFXLGtCQUFhO1FBQ2pDLGlFQUFpRTtRQUNqRSxNQUFNLEVBQUVDLGdCQUFnQixFQUFFLEdBQ3hCQyxRQUFRO1FBRVYsTUFBTUMsWUFBWUYsaUJBQWlCRyxRQUFRO1FBQzNDLElBQUksQ0FBQ0QsV0FBVyxPQUFPO1FBRXZCLE1BQU0sRUFBRUUsbUJBQW1CLEVBQUUsR0FBR0Y7UUFDaEMsSUFBSSxDQUFDRSx1QkFBdUJBLG9CQUFvQkMsSUFBSSxLQUFLLEdBQUcsT0FBTztRQUVuRSxPQUFPO0lBQ1Q7OztBQUdGO0FBYU8sU0FBU1I7SUFDZCxxRUFBcUU7SUFDckUsOEVBQThFO0lBQzlFLDhFQUE4RTtJQUM5RSx1QkFBdUI7SUFDdkIsSUFBSUMsMEJBQTBCO1FBQzVCLE9BQU87SUFDVDtJQUVBLDJFQUEyRTtJQUMzRSxxREFBcUQ7SUFDckQsc0RBQXNEO0lBQ3RELE9BQU9RLENBQUFBLEdBQUFBLE9BQUFBLFVBQVUsRUFBQ0MsaUNBQUFBLGVBQWU7QUFDbkMiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNTIwMywgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvY29tcG9uZW50cy9uYXYtZmFpbHVyZS1oYW5kbGVyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgY3JlYXRlSHJlZkZyb21VcmwgfSBmcm9tICcuL3JvdXRlci1yZWR1Y2VyL2NyZWF0ZS1ocmVmLWZyb20tdXJsJ1xuXG5leHBvcnQgZnVuY3Rpb24gaGFuZGxlSGFyZE5hdkVycm9yKGVycm9yOiB1bmtub3duKTogYm9vbGVhbiB7XG4gIGlmIChcbiAgICBlcnJvciAmJlxuICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgd2luZG93Lm5leHQuX19wZW5kaW5nVXJsICYmXG4gICAgY3JlYXRlSHJlZkZyb21VcmwobmV3IFVSTCh3aW5kb3cubG9jYXRpb24uaHJlZikpICE9PVxuICAgICAgY3JlYXRlSHJlZkZyb21Vcmwod2luZG93Lm5leHQuX19wZW5kaW5nVXJsKVxuICApIHtcbiAgICBjb25zb2xlLmVycm9yKFxuICAgICAgYEVycm9yIG9jY3VycmVkIGR1cmluZyBuYXZpZ2F0aW9uLCBmYWxsaW5nIGJhY2sgdG8gaGFyZCBuYXZpZ2F0aW9uYCxcbiAgICAgIGVycm9yXG4gICAgKVxuICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gd2luZG93Lm5leHQuX19wZW5kaW5nVXJsLnRvU3RyaW5nKClcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlTmF2RmFpbHVyZUhhbmRsZXIoKSB7XG4gIGlmIChwcm9jZXNzLmVudi5fX05FWFRfQVBQX05BVl9GQUlMX0hBTkRMSU5HKSB7XG4gICAgLy8gdGhpcyBpZiBpcyBvbmx5IGZvciBEQ0Ugb2YgdGhlIGZlYXR1cmUgZmxhZyBub3QgY29uZGl0aW9uYWxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgY29uc3QgdW5jYXVnaHRFeGNlcHRpb25IYW5kbGVyID0gKFxuICAgICAgICBldnQ6IEVycm9yRXZlbnQgfCBQcm9taXNlUmVqZWN0aW9uRXZlbnRcbiAgICAgICkgPT4ge1xuICAgICAgICBjb25zdCBlcnJvciA9ICdyZWFzb24nIGluIGV2dCA/IGV2dC5yZWFzb24gOiBldnQuZXJyb3JcbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uL3JlamVjdGlvbiBkdXJpbmdcbiAgICAgICAgLy8gYSBuYXZpZ2F0aW9uIHdlIGZhbGwgYmFjayB0byBhIGhhcmQgbmF2aWdhdGlvbiB0b1xuICAgICAgICAvLyBhdHRlbXB0IHJlY292ZXJpbmcgdG8gYSBnb29kIHN0YXRlXG4gICAgICAgIGhhbmRsZUhhcmROYXZFcnJvcihlcnJvcilcbiAgICAgIH1cbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd1bmhhbmRsZWRyZWplY3Rpb24nLCB1bmNhdWdodEV4Y2VwdGlvbkhhbmRsZXIpXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCB1bmNhdWdodEV4Y2VwdGlvbkhhbmRsZXIpXG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCB1bmNhdWdodEV4Y2VwdGlvbkhhbmRsZXIpXG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICAgICd1bmhhbmRsZWRyZWplY3Rpb24nLFxuICAgICAgICAgIHVuY2F1Z2h0RXhjZXB0aW9uSGFuZGxlclxuICAgICAgICApXG4gICAgICB9XG4gICAgfSwgW10pXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJoYW5kbGVIYXJkTmF2RXJyb3IiLCJ1c2VOYXZGYWlsdXJlSGFuZGxlciIsImVycm9yIiwid2luZG93IiwibmV4dCIsIl9fcGVuZGluZ1VybCIsImNyZWF0ZUhyZWZGcm9tVXJsIiwiVVJMIiwibG9jYXRpb24iLCJocmVmIiwiY29uc29sZSIsInRvU3RyaW5nIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9BUFBfTkFWX0ZBSUxfSEFORExJTkciLCJ1c2VFZmZlY3QiLCJ1bmNhdWdodEV4Y2VwdGlvbkhhbmRsZXIiLCJldnQiLCJyZWFzb24iLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7SUFHZ0JBLGtCQUFrQixFQUFBO2VBQWxCQTs7SUFrQkFDLG9CQUFvQixFQUFBO2VBQXBCQTs7O3VCQXJCVTttQ0FDUTtBQUUzQixTQUFTRCxtQkFBbUJFLEtBQWM7SUFDL0MsSUFDRUEsU0FDQSxPQUFPQyxTQUFXLGVBQ2xCQSxPQUFPQyxJQUFJLENBQUNDLFlBQVksSUFDeEJDLENBQUFBLEdBQUFBLG1CQUFBQSxpQkFBaUIsRUFBQyxJQUFJQyxJQUFJSixPQUFPSyxRQUFRLENBQUNDLElBQUksT0FDNUNILENBQUFBLEdBQUFBLG1CQUFBQSxpQkFBaUIsRUFBQ0gsT0FBT0MsSUFBSSxDQUFDQyxZQUFZLEdBQzVDOztJQVFGLE9BQU87QUFDVDtBQUVPLFNBQVNKO0lBQ2QsSUFBSVcsUUFBUUMsR0FBRyxDQUFDQyw0QkFBNEIsRUFBRTs7QUF3QmhEIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDUyNDgsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvY2xpZW50L2NvbXBvbmVudHMvaGFuZGxlLWlzci1lcnJvci50c3giXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3Qgd29ya0FzeW5jU3RvcmFnZSA9XG4gIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnXG4gICAgPyAoXG4gICAgICAgIHJlcXVpcmUoJy4uLy4uL3NlcnZlci9hcHAtcmVuZGVyL3dvcmstYXN5bmMtc3RvcmFnZS5leHRlcm5hbCcpIGFzIHR5cGVvZiBpbXBvcnQoJy4uLy4uL3NlcnZlci9hcHAtcmVuZGVyL3dvcmstYXN5bmMtc3RvcmFnZS5leHRlcm5hbCcpXG4gICAgICApLndvcmtBc3luY1N0b3JhZ2VcbiAgICA6IHVuZGVmaW5lZFxuXG4vLyBpZiB3ZSBhcmUgcmV2YWxpZGF0aW5nIHdlIHdhbnQgdG8gcmUtdGhyb3cgdGhlIGVycm9yIHNvIHRoZVxuLy8gZnVuY3Rpb24gY3Jhc2hlcyBzbyB3ZSBjYW4gbWFpbnRhaW4gb3VyIHByZXZpb3VzIGNhY2hlXG4vLyBpbnN0ZWFkIG9mIGNhY2hpbmcgdGhlIGVycm9yIHBhZ2VcbmV4cG9ydCBmdW5jdGlvbiBIYW5kbGVJU1JFcnJvcih7IGVycm9yIH06IHsgZXJyb3I6IGFueSB9KSB7XG4gIGlmICh3b3JrQXN5bmNTdG9yYWdlKSB7XG4gICAgY29uc3Qgc3RvcmUgPSB3b3JrQXN5bmNTdG9yYWdlLmdldFN0b3JlKClcbiAgICBpZiAoc3RvcmU/LmlzUmV2YWxpZGF0ZSB8fCBzdG9yZT8uaXNTdGF0aWNHZW5lcmF0aW9uKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycm9yKVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuIl0sIm5hbWVzIjpbIkhhbmRsZUlTUkVycm9yIiwid29ya0FzeW5jU3RvcmFnZSIsIndpbmRvdyIsInJlcXVpcmUiLCJ1bmRlZmluZWQiLCJlcnJvciIsInN0b3JlIiwiZ2V0U3RvcmUiLCJpc1JldmFsaWRhdGUiLCJpc1N0YXRpY0dlbmVyYXRpb24iLCJjb25zb2xlIl0sIm1hcHBpbmdzIjoiOzs7K0JBVWdCQSxrQkFBQUE7OztlQUFBQTs7O0FBVmhCLE1BQU1DLG1CQUNKLE9BQU9DLFdBQVcscUJBRVpDLFFBQVEsdUtBQ1JGLGdCQUFnQixHQUNsQkc7QUFLQyxTQUFTSixlQUFlLEtBQXlCO0lBQXpCLElBQUEsRUFBRUssS0FBSyxFQUFrQixHQUF6QjtJQUM3QixJQUFJSixrQkFBa0I7UUFDcEIsTUFBTUssUUFBUUwsaUJBQWlCTSxRQUFRO1FBQ3ZDLElBQUlELENBQUFBLFNBQUFBLE9BQUFBLEtBQUFBLElBQUFBLE1BQU9FLFlBQVksS0FBQSxDQUFJRixTQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxNQUFPRyxrQkFBa0IsR0FBRTtZQUNwREMsUUFBUUwsS0FBSyxDQUFDQTtZQUNkLE1BQU1BO1FBQ1I7SUFDRjtJQUVBLE9BQU87QUFDVCIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA1MjgyLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2NsaWVudC9jb21wb25lbnRzL2Vycm9yLWJvdW5kYXJ5LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuaW1wb3J0IFJlYWN0LCB7IHR5cGUgSlNYIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyB1c2VVbnRyYWNrZWRQYXRobmFtZSB9IGZyb20gJy4vbmF2aWdhdGlvbi11bnRyYWNrZWQnXG5pbXBvcnQgeyBpc05leHRSb3V0ZXJFcnJvciB9IGZyb20gJy4vaXMtbmV4dC1yb3V0ZXItZXJyb3InXG5pbXBvcnQgeyBoYW5kbGVIYXJkTmF2RXJyb3IgfSBmcm9tICcuL25hdi1mYWlsdXJlLWhhbmRsZXInXG5pbXBvcnQgeyBIYW5kbGVJU1JFcnJvciB9IGZyb20gJy4vaGFuZGxlLWlzci1lcnJvcidcblxuZXhwb3J0IHR5cGUgRXJyb3JDb21wb25lbnQgPSBSZWFjdC5Db21wb25lbnRUeXBlPHtcbiAgZXJyb3I6IEVycm9yXG4gIC8vIGdsb2JhbC1lcnJvciwgdGhlcmUncyBubyBgcmVzZXRgIGZ1bmN0aW9uO1xuICAvLyByZWd1bGFyIGVycm9yIGJvdW5kYXJ5LCB0aGVyZSdzIGEgYHJlc2V0YCBmdW5jdGlvbi5cbiAgcmVzZXQ/OiAoKSA9PiB2b2lkXG59PlxuXG5leHBvcnQgaW50ZXJmYWNlIEVycm9yQm91bmRhcnlQcm9wcyB7XG4gIGNoaWxkcmVuPzogUmVhY3QuUmVhY3ROb2RlXG4gIGVycm9yQ29tcG9uZW50OiBFcnJvckNvbXBvbmVudCB8IHVuZGVmaW5lZFxuICBlcnJvclN0eWxlcz86IFJlYWN0LlJlYWN0Tm9kZSB8IHVuZGVmaW5lZFxuICBlcnJvclNjcmlwdHM/OiBSZWFjdC5SZWFjdE5vZGUgfCB1bmRlZmluZWRcbn1cblxuaW50ZXJmYWNlIEVycm9yQm91bmRhcnlIYW5kbGVyUHJvcHMgZXh0ZW5kcyBFcnJvckJvdW5kYXJ5UHJvcHMge1xuICBwYXRobmFtZTogc3RyaW5nIHwgbnVsbFxuICBlcnJvckNvbXBvbmVudDogRXJyb3JDb21wb25lbnRcbn1cblxuaW50ZXJmYWNlIEVycm9yQm91bmRhcnlIYW5kbGVyU3RhdGUge1xuICBlcnJvcjogRXJyb3IgfCBudWxsXG4gIHByZXZpb3VzUGF0aG5hbWU6IHN0cmluZyB8IG51bGxcbn1cblxuZXhwb3J0IGNsYXNzIEVycm9yQm91bmRhcnlIYW5kbGVyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFxuICBFcnJvckJvdW5kYXJ5SGFuZGxlclByb3BzLFxuICBFcnJvckJvdW5kYXJ5SGFuZGxlclN0YXRlXG4+IHtcbiAgY29uc3RydWN0b3IocHJvcHM6IEVycm9yQm91bmRhcnlIYW5kbGVyUHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcylcbiAgICB0aGlzLnN0YXRlID0geyBlcnJvcjogbnVsbCwgcHJldmlvdXNQYXRobmFtZTogdGhpcy5wcm9wcy5wYXRobmFtZSB9XG4gIH1cblxuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yOiBFcnJvcikge1xuICAgIGlmIChpc05leHRSb3V0ZXJFcnJvcihlcnJvcikpIHtcbiAgICAgIC8vIFJlLXRocm93IGlmIGFuIGV4cGVjdGVkIGludGVybmFsIE5leHQuanMgcm91dGVyIGVycm9yIG9jY3Vyc1xuICAgICAgLy8gdGhpcyBtZWFucyBpdCBzaG91bGQgYmUgaGFuZGxlZCBieSBhIGRpZmZlcmVudCBib3VuZGFyeSAoc3VjaCBhcyBhIE5vdEZvdW5kIGJvdW5kYXJ5IGluIGEgcGFyZW50IHNlZ21lbnQpXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cblxuICAgIHJldHVybiB7IGVycm9yIH1cbiAgfVxuXG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoXG4gICAgcHJvcHM6IEVycm9yQm91bmRhcnlIYW5kbGVyUHJvcHMsXG4gICAgc3RhdGU6IEVycm9yQm91bmRhcnlIYW5kbGVyU3RhdGVcbiAgKTogRXJyb3JCb3VuZGFyeUhhbmRsZXJTdGF0ZSB8IG51bGwge1xuICAgIGNvbnN0IHsgZXJyb3IgfSA9IHN0YXRlXG5cbiAgICAvLyBpZiB3ZSBlbmNvdW50ZXIgYW4gZXJyb3Igd2hpbGVcbiAgICAvLyBhIG5hdmlnYXRpb24gaXMgcGVuZGluZyB3ZSBzaG91bGRuJ3QgcmVuZGVyXG4gICAgLy8gdGhlIGVycm9yIGJvdW5kYXJ5IGFuZCBpbnN0ZWFkIHNob3VsZCBmYWxsYmFja1xuICAgIC8vIHRvIGEgaGFyZCBuYXZpZ2F0aW9uIHRvIGF0dGVtcHQgcmVjb3ZlcmluZ1xuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfQVBQX05BVl9GQUlMX0hBTkRMSU5HKSB7XG4gICAgICBpZiAoZXJyb3IgJiYgaGFuZGxlSGFyZE5hdkVycm9yKGVycm9yKSkge1xuICAgICAgICAvLyBjbGVhciBlcnJvciBzbyB3ZSBkb24ndCByZW5kZXIgYW55dGhpbmdcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICBwcmV2aW91c1BhdGhuYW1lOiBwcm9wcy5wYXRobmFtZSxcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgcmVzZXQgb2YgdGhlIGVycm9yIGJvdW5kYXJ5IHdoZW4gYSBuYXZpZ2F0aW9uIGhhcHBlbnMuXG4gICAgICogRW5zdXJlcyB0aGUgZXJyb3IgYm91bmRhcnkgZG9lcyBub3Qgc3RheSBlbmFibGVkIHdoZW4gbmF2aWdhdGluZyB0byBhIG5ldyBwYWdlLlxuICAgICAqIEFwcHJvYWNoIG9mIHNldFN0YXRlIGluIHJlbmRlciBpcyBzYWZlIGFzIGl0IGNoZWNrcyB0aGUgcHJldmlvdXMgcGF0aG5hbWUgYW5kIHRoZW4gb3ZlcnJpZGVzXG4gICAgICogaXQgYXMgb3V0bGluZWQgaW4gaHR0cHM6Ly9yZWFjdC5kZXYvcmVmZXJlbmNlL3JlYWN0L3VzZVN0YXRlI3N0b3JpbmctaW5mb3JtYXRpb24tZnJvbS1wcmV2aW91cy1yZW5kZXJzXG4gICAgICovXG4gICAgaWYgKHByb3BzLnBhdGhuYW1lICE9PSBzdGF0ZS5wcmV2aW91c1BhdGhuYW1lICYmIHN0YXRlLmVycm9yKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgcHJldmlvdXNQYXRobmFtZTogcHJvcHMucGF0aG5hbWUsXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBlcnJvcjogc3RhdGUuZXJyb3IsXG4gICAgICBwcmV2aW91c1BhdGhuYW1lOiBwcm9wcy5wYXRobmFtZSxcbiAgICB9XG4gIH1cblxuICByZXNldCA9ICgpID0+IHtcbiAgICB0aGlzLnNldFN0YXRlKHsgZXJyb3I6IG51bGwgfSlcbiAgfVxuXG4gIC8vIEV4cGxpY2l0IHR5cGUgaXMgbmVlZGVkIHRvIGF2b2lkIHRoZSBnZW5lcmF0ZWQgYC5kLnRzYCBoYXZpbmcgYSB3aWRlIHJldHVybiB0eXBlIHRoYXQgY291bGQgYmUgc3BlY2lmaWMgdG8gdGhlIGBAdHlwZXMvcmVhY3RgIHZlcnNpb24uXG4gIHJlbmRlcigpOiBSZWFjdC5SZWFjdE5vZGUge1xuICAgIGlmICh0aGlzLnN0YXRlLmVycm9yKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICA8PlxuICAgICAgICAgIDxIYW5kbGVJU1JFcnJvciBlcnJvcj17dGhpcy5zdGF0ZS5lcnJvcn0gLz5cbiAgICAgICAgICB7dGhpcy5wcm9wcy5lcnJvclN0eWxlc31cbiAgICAgICAgICB7dGhpcy5wcm9wcy5lcnJvclNjcmlwdHN9XG4gICAgICAgICAgPHRoaXMucHJvcHMuZXJyb3JDb21wb25lbnRcbiAgICAgICAgICAgIGVycm9yPXt0aGlzLnN0YXRlLmVycm9yfVxuICAgICAgICAgICAgcmVzZXQ9e3RoaXMucmVzZXR9XG4gICAgICAgICAgLz5cbiAgICAgICAgPC8+XG4gICAgICApXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW5cbiAgfVxufVxuXG4vKipcbiAqIEhhbmRsZXMgZXJyb3JzIHRocm91Z2ggYGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcmAuXG4gKiBSZW5kZXJzIHRoZSBwcm92aWRlZCBlcnJvciBjb21wb25lbnQgYW5kIHByb3ZpZGVzIGEgd2F5IHRvIGByZXNldGAgdGhlIGVycm9yIGJvdW5kYXJ5IHN0YXRlLlxuICovXG5cbi8qKlxuICogUmVuZGVycyBlcnJvciBib3VuZGFyeSB3aXRoIHRoZSBwcm92aWRlZCBcImVycm9yQ29tcG9uZW50XCIgcHJvcGVydHkgYXMgdGhlIGZhbGxiYWNrLlxuICogSWYgbm8gXCJlcnJvckNvbXBvbmVudFwiIHByb3BlcnR5IGlzIHByb3ZpZGVkIGl0IHJlbmRlcnMgdGhlIGNoaWxkcmVuIHdpdGhvdXQgYW4gZXJyb3IgYm91bmRhcnkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBFcnJvckJvdW5kYXJ5KHtcbiAgZXJyb3JDb21wb25lbnQsXG4gIGVycm9yU3R5bGVzLFxuICBlcnJvclNjcmlwdHMsXG4gIGNoaWxkcmVuLFxufTogRXJyb3JCb3VuZGFyeVByb3BzICYge1xuICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlXG59KTogSlNYLkVsZW1lbnQge1xuICAvLyBXaGVuIHdlJ3JlIHJlbmRlcmluZyB0aGUgbWlzc2luZyBwYXJhbXMgc2hlbGwsIHRoaXMgd2lsbCByZXR1cm4gbnVsbC4gVGhpc1xuICAvLyBpcyBiZWNhdXNlIHdlIHdvbid0IGJlIHJlbmRlcmluZyBhbnkgbm90IGZvdW5kIGJvdW5kYXJpZXMgb3IgZXJyb3JcbiAgLy8gYm91bmRhcmllcyBmb3IgdGhlIG1pc3NpbmcgcGFyYW1zIHNoZWxsLiBXaGVuIHRoaXMgcnVucyBvbiB0aGUgY2xpZW50XG4gIC8vICh3aGVyZSB0aGVzZSBlcnJvcnMgY2FuIG9jY3VyKSwgd2Ugd2lsbCBnZXQgdGhlIGNvcnJlY3QgcGF0aG5hbWUuXG4gIGNvbnN0IHBhdGhuYW1lID0gdXNlVW50cmFja2VkUGF0aG5hbWUoKVxuICBpZiAoZXJyb3JDb21wb25lbnQpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPEVycm9yQm91bmRhcnlIYW5kbGVyXG4gICAgICAgIHBhdGhuYW1lPXtwYXRobmFtZX1cbiAgICAgICAgZXJyb3JDb21wb25lbnQ9e2Vycm9yQ29tcG9uZW50fVxuICAgICAgICBlcnJvclN0eWxlcz17ZXJyb3JTdHlsZXN9XG4gICAgICAgIGVycm9yU2NyaXB0cz17ZXJyb3JTY3JpcHRzfVxuICAgICAgPlxuICAgICAgICB7Y2hpbGRyZW59XG4gICAgICA8L0Vycm9yQm91bmRhcnlIYW5kbGVyPlxuICAgIClcbiAgfVxuXG4gIHJldHVybiA8PntjaGlsZHJlbn08Lz5cbn1cbiJdLCJuYW1lcyI6WyJFcnJvckJvdW5kYXJ5IiwiRXJyb3JCb3VuZGFyeUhhbmRsZXIiLCJSZWFjdCIsIkNvbXBvbmVudCIsImdldERlcml2ZWRTdGF0ZUZyb21FcnJvciIsImVycm9yIiwiaXNOZXh0Um91dGVyRXJyb3IiLCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJwcm9wcyIsInN0YXRlIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9BUFBfTkFWX0ZBSUxfSEFORExJTkciLCJoYW5kbGVIYXJkTmF2RXJyb3IiLCJwcmV2aW91c1BhdGhuYW1lIiwicGF0aG5hbWUiLCJyZW5kZXIiLCJIYW5kbGVJU1JFcnJvciIsImVycm9yU3R5bGVzIiwiZXJyb3JTY3JpcHRzIiwidGhpcyIsImVycm9yQ29tcG9uZW50IiwicmVzZXQiLCJjaGlsZHJlbiIsImNvbnN0cnVjdG9yIiwic2V0U3RhdGUiLCJ1c2VVbnRyYWNrZWRQYXRobmFtZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7SUEwSGdCQSxhQUFhLEVBQUE7ZUFBYkE7O0lBMUZIQyxvQkFBb0IsRUFBQTtlQUFwQkE7Ozs7O2dFQTlCbUI7cUNBQ0s7bUNBQ0g7bUNBQ0M7Z0NBQ0o7QUEwQnhCLE1BQU1BLDZCQUE2QkMsT0FBQUEsT0FBSyxDQUFDQyxTQUFTO0lBU3ZELE9BQU9DLHlCQUF5QkMsS0FBWSxFQUFFO1FBQzVDLElBQUlDLENBQUFBLEdBQUFBLG1CQUFBQSxpQkFBaUIsRUFBQ0QsUUFBUTtZQUM1QiwrREFBK0Q7WUFDL0QsNEdBQTRHO1lBQzVHLE1BQU1BO1FBQ1I7UUFFQSxPQUFPO1lBQUVBO1FBQU07SUFDakI7SUFFQSxPQUFPRSx5QkFDTEMsS0FBZ0MsRUFDaENDLEtBQWdDLEVBQ0U7UUFDbEMsTUFBTSxFQUFFSixLQUFLLEVBQUUsR0FBR0k7UUFFbEIsaUNBQWlDO1FBQ2pDLDhDQUE4QztRQUM5QyxpREFBaUQ7UUFDakQsNkNBQTZDO1FBQzdDLElBQUlDLFFBQVFDLEdBQUcsQ0FBQ0MsNEJBQTRCLEVBQUU7O1FBVTlDOzs7OztLQUtDLEdBQ0QsSUFBSUosTUFBTU8sUUFBUSxLQUFLTixNQUFNSyxnQkFBZ0IsSUFBSUwsTUFBTUosS0FBSyxFQUFFO1lBQzVELE9BQU87Z0JBQ0xBLE9BQU87Z0JBQ1BTLGtCQUFrQk4sTUFBTU8sUUFBUTtZQUNsQztRQUNGO1FBQ0EsT0FBTztZQUNMVixPQUFPSSxNQUFNSixLQUFLO1lBQ2xCUyxrQkFBa0JOLE1BQU1PLFFBQVE7UUFDbEM7SUFDRjtJQU1BLHlJQUF5STtJQUN6SUMsU0FBMEI7UUFDeEIsSUFBSSxJQUFJLENBQUNQLEtBQUssQ0FBQ0osS0FBSyxFQUFFO1lBQ3BCLE9BQUEsV0FBQSxHQUNFLENBQUEsR0FBQSxZQUFBLElBQUEsRUFBQSxZQUFBLFFBQUEsRUFBQTs7a0NBQ0UsQ0FBQSxHQUFBLFlBQUEsR0FBQSxFQUFDWSxnQkFBQUEsY0FBYyxFQUFBO3dCQUFDWixPQUFPLElBQUksQ0FBQ0ksS0FBSyxDQUFDSixLQUFLOztvQkFDdEMsSUFBSSxDQUFDRyxLQUFLLENBQUNVLFdBQVc7b0JBQ3RCLElBQUksQ0FBQ1YsS0FBSyxDQUFDVyxZQUFZO2tDQUN4QixDQUFBLEdBQUEsWUFBQSxHQUFBLEVBQUNDLElBQUksQ0FBQ1osS0FBSyxDQUFDYSxjQUFjLEVBQUE7d0JBQ3hCaEIsT0FBTyxJQUFJLENBQUNJLEtBQUssQ0FBQ0osS0FBSzt3QkFDdkJpQixPQUFPLElBQUksQ0FBQ0EsS0FBSzs7OztRQUl6QjtRQUVBLE9BQU8sSUFBSSxDQUFDZCxLQUFLLENBQUNlLFFBQVE7SUFDNUI7SUExRUFDLFlBQVloQixLQUFnQyxDQUFFO1FBQzVDLEtBQUssQ0FBQ0EsUUFBQUEsSUFBQUEsQ0FvRFJjLEtBQUFBLEdBQVE7WUFDTixJQUFJLENBQUNHLFFBQVEsQ0FBQztnQkFBRXBCLE9BQU87WUFBSztRQUM5QjtRQXJERSxJQUFJLENBQUNJLEtBQUssR0FBRztZQUFFSixPQUFPO1lBQU1TLGtCQUFrQixJQUFJLENBQUNOLEtBQUssQ0FBQ08sUUFBUTtRQUFDO0lBQ3BFO0FBd0VGO0FBV08sU0FBU2YsY0FBYyxLQU83QjtJQVA2QixJQUFBLEVBQzVCcUIsY0FBYyxFQUNkSCxXQUFXLEVBQ1hDLFlBQVksRUFDWkksUUFBUSxFQUdULEdBUDZCO0lBUTVCLDZFQUE2RTtJQUM3RSxxRUFBcUU7SUFDckUsd0VBQXdFO0lBQ3hFLG9FQUFvRTtJQUNwRSxNQUFNUixXQUFXVyxDQUFBQSxHQUFBQSxxQkFBQUEsb0JBQW9CO0lBQ3JDLElBQUlMLGdCQUFnQjtRQUNsQixPQUFBLFdBQUEsR0FDRSxDQUFBLEdBQUEsWUFBQSxHQUFBLEVBQUNwQixzQkFBQUE7WUFDQ2MsVUFBVUE7WUFDVk0sZ0JBQWdCQTtZQUNoQkgsYUFBYUE7WUFDYkMsY0FBY0E7c0JBRWJJOztJQUdQO0lBRUEsT0FBQSxXQUFBLEdBQU8sQ0FBQSxHQUFBLFlBQUEsR0FBQSxFQUFBLFlBQUEsUUFBQSxFQUFBO2tCQUFHQTs7QUFDWiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA1NDA5LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2NsaWVudC9jb21wb25lbnRzL2J1aWx0aW4vZ2xvYmFsLWVycm9yLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuaW1wb3J0IHsgSGFuZGxlSVNSRXJyb3IgfSBmcm9tICcuLi9oYW5kbGUtaXNyLWVycm9yJ1xuXG5jb25zdCBzdHlsZXMgPSB7XG4gIGVycm9yOiB7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9tb2Rlcm4tbm9ybWFsaXplL2Jsb2IvbWFpbi9tb2Rlcm4tbm9ybWFsaXplLmNzcyNMMzgtTDUyXG4gICAgZm9udEZhbWlseTpcbiAgICAgICdzeXN0ZW0tdWksXCJTZWdvZSBVSVwiLFJvYm90byxIZWx2ZXRpY2EsQXJpYWwsc2Fucy1zZXJpZixcIkFwcGxlIENvbG9yIEVtb2ppXCIsXCJTZWdvZSBVSSBFbW9qaVwiJyxcbiAgICBoZWlnaHQ6ICcxMDB2aCcsXG4gICAgdGV4dEFsaWduOiAnY2VudGVyJyxcbiAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgZmxleERpcmVjdGlvbjogJ2NvbHVtbicsXG4gICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAganVzdGlmeUNvbnRlbnQ6ICdjZW50ZXInLFxuICB9LFxuICB0ZXh0OiB7XG4gICAgZm9udFNpemU6ICcxNHB4JyxcbiAgICBmb250V2VpZ2h0OiA0MDAsXG4gICAgbGluZUhlaWdodDogJzI4cHgnLFxuICAgIG1hcmdpbjogJzAgOHB4JyxcbiAgfSxcbn0gYXMgY29uc3RcblxuZXhwb3J0IHR5cGUgR2xvYmFsRXJyb3JDb21wb25lbnQgPSBSZWFjdC5Db21wb25lbnRUeXBlPHtcbiAgZXJyb3I6IGFueVxufT5cbmZ1bmN0aW9uIERlZmF1bHRHbG9iYWxFcnJvcih7IGVycm9yIH06IHsgZXJyb3I6IGFueSB9KSB7XG4gIGNvbnN0IGRpZ2VzdDogc3RyaW5nIHwgdW5kZWZpbmVkID0gZXJyb3I/LmRpZ2VzdFxuICByZXR1cm4gKFxuICAgIDxodG1sIGlkPVwiX19uZXh0X2Vycm9yX19cIj5cbiAgICAgIDxoZWFkPjwvaGVhZD5cbiAgICAgIDxib2R5PlxuICAgICAgICA8SGFuZGxlSVNSRXJyb3IgZXJyb3I9e2Vycm9yfSAvPlxuICAgICAgICA8ZGl2IHN0eWxlPXtzdHlsZXMuZXJyb3J9PlxuICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICA8aDIgc3R5bGU9e3N0eWxlcy50ZXh0fT5cbiAgICAgICAgICAgICAgQXBwbGljYXRpb24gZXJyb3I6IGEge2RpZ2VzdCA/ICdzZXJ2ZXInIDogJ2NsaWVudCd9LXNpZGUgZXhjZXB0aW9uXG4gICAgICAgICAgICAgIGhhcyBvY2N1cnJlZCB3aGlsZSBsb2FkaW5nIHt3aW5kb3cubG9jYXRpb24uaG9zdG5hbWV9IChzZWUgdGhleycgJ31cbiAgICAgICAgICAgICAge2RpZ2VzdCA/ICdzZXJ2ZXIgbG9ncycgOiAnYnJvd3NlciBjb25zb2xlJ30gZm9yIG1vcmVcbiAgICAgICAgICAgICAgaW5mb3JtYXRpb24pLlxuICAgICAgICAgICAgPC9oMj5cbiAgICAgICAgICAgIHtkaWdlc3QgPyA8cCBzdHlsZT17c3R5bGVzLnRleHR9PntgRGlnZXN0OiAke2RpZ2VzdH1gfTwvcD4gOiBudWxsfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvYm9keT5cbiAgICA8L2h0bWw+XG4gIClcbn1cblxuLy8gRXhwb3J0ZWQgc28gdGhhdCB0aGUgaW1wb3J0IHNpZ25hdHVyZSBpbiB0aGUgbG9hZGVycyBjYW4gYmUgaWRlbnRpY2FsIHRvIHVzZXJcbi8vIHN1cHBsaWVkIGN1c3RvbSBnbG9iYWwgZXJyb3Igc2lnbmF0dXJlcy5cbmV4cG9ydCBkZWZhdWx0IERlZmF1bHRHbG9iYWxFcnJvclxuIl0sIm5hbWVzIjpbInN0eWxlcyIsImVycm9yIiwiZm9udEZhbWlseSIsImhlaWdodCIsInRleHRBbGlnbiIsImRpc3BsYXkiLCJmbGV4RGlyZWN0aW9uIiwiYWxpZ25JdGVtcyIsImp1c3RpZnlDb250ZW50IiwidGV4dCIsImZvbnRTaXplIiwiZm9udFdlaWdodCIsImxpbmVIZWlnaHQiLCJtYXJnaW4iLCJEZWZhdWx0R2xvYmFsRXJyb3IiLCJkaWdlc3QiLCJodG1sIiwiaWQiLCJoZWFkIiwiYm9keSIsIkhhbmRsZUlTUkVycm9yIiwiZGl2Iiwic3R5bGUiLCJoMiIsIndpbmRvdyIsImxvY2F0aW9uIiwiaG9zdG5hbWUiLCJwIl0sIm1hcHBpbmdzIjoiOzs7K0JBbURBLEFBREEsMkNBQzJDLHFDQURxQztBQUVoRixXQUFBOzs7ZUFBQTs7OztnQ0FsRCtCO0FBRS9CLE1BQU1BLFNBQVM7SUFDYkMsT0FBTztRQUNMLDBGQUEwRjtRQUMxRkMsWUFDRTtRQUNGQyxRQUFRO1FBQ1JDLFdBQVc7UUFDWEMsU0FBUztRQUNUQyxlQUFlO1FBQ2ZDLFlBQVk7UUFDWkMsZ0JBQWdCO0lBQ2xCO0lBQ0FDLE1BQU07UUFDSkMsVUFBVTtRQUNWQyxZQUFZO1FBQ1pDLFlBQVk7UUFDWkMsUUFBUTtJQUNWO0FBQ0Y7QUFLQSxTQUFTQyxtQkFBbUIsS0FBeUI7SUFBekIsSUFBQSxFQUFFYixLQUFLLEVBQWtCLEdBQXpCO0lBQzFCLE1BQU1jLFNBQTZCZCxTQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxNQUFPYyxNQUFNO0lBQ2hELE9BQUEsV0FBQSxHQUNFLENBQUEsR0FBQSxZQUFBLElBQUEsRUFBQ0MsUUFBQUE7UUFBS0MsSUFBRzs7MEJBQ1AsQ0FBQSxHQUFBLFlBQUEsR0FBQSxFQUFDQyxRQUFBQSxDQUFBQTswQkFDRCxDQUFBLEdBQUEsWUFBQSxJQUFBLEVBQUNDLFFBQUFBOztrQ0FDQyxDQUFBLEdBQUEsWUFBQSxHQUFBLEVBQUNDLGdCQUFBQSxjQUFjLEVBQUE7d0JBQUNuQixPQUFPQTs7a0NBQ3ZCLENBQUEsR0FBQSxZQUFBLEdBQUEsRUFBQ29CLE9BQUFBO3dCQUFJQyxPQUFPdEIsT0FBT0MsS0FBSztrQ0FDdEIsV0FBQSxHQUFBLENBQUEsR0FBQSxZQUFBLElBQUEsRUFBQ29CLE9BQUFBOzs4Q0FDQyxDQUFBLEdBQUEsWUFBQSxJQUFBLEVBQUNFLE1BQUFBO29DQUFHRCxPQUFPdEIsT0FBT1MsSUFBSTs7d0NBQUU7d0NBQ0FNLFNBQVMsV0FBVzt3Q0FBUzt3Q0FDdkJTLE9BQU9DLFFBQVEsQ0FBQ0MsUUFBUTt3Q0FBQzt3Q0FBVTt3Q0FDOURYLFNBQVMsZ0JBQWdCO3dDQUFrQjs7O2dDQUc3Q0EsU0FBQUEsV0FBQUEsR0FBUyxDQUFBLEdBQUEsWUFBQSxHQUFBLEVBQUNZLEtBQUFBO29DQUFFTCxPQUFPdEIsT0FBT1MsSUFBSTs4Q0FBSSxhQUFVTTtxQ0FBZ0I7Ozs7Ozs7O0FBTXpFO01BSUEsV0FBZUQiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNTQ5NCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9zaGFyZWQvbGliL3JvdXRlci91dGlscy9odG1sLWJvdHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVGhpcyByZWdleCBjb250YWlucyB0aGUgYm90cyB0aGF0IHdlIG5lZWQgdG8gZG8gYSBibG9ja2luZyByZW5kZXIgZm9yIGFuZCBjYW4ndCBzYWZlbHkgc3RyZWFtIHRoZSByZXNwb25zZVxuLy8gZHVlIHRvIGhvdyB0aGV5IHBhcnNlIHRoZSBET00uIEZvciBleGFtcGxlLCB0aGV5IG1pZ2h0IGV4cGxpY2l0bHkgY2hlY2sgZm9yIG1ldGFkYXRhIGluIHRoZSBgaGVhZGAgdGFnLCBzbyB3ZSBjYW4ndCBzdHJlYW0gbWV0YWRhdGEgdGFncyBhZnRlciB0aGUgYGhlYWRgIHdhcyBzZW50LlxuZXhwb3J0IGNvbnN0IEhUTUxfTElNSVRFRF9CT1RfVUFfUkUgPVxuICAvTWVkaWFwYXJ0bmVycy1Hb29nbGV8Q2hyb21lLUxpZ2h0aG91c2V8U2x1cnB8RHVja0R1Y2tCb3R8YmFpZHVzcGlkZXJ8eWFuZGV4fHNvZ291fGJpdGx5Ym90fHR1bWJscnx2a1NoYXJlfHF1b3JhIGxpbmsgcHJldmlld3xyZWRkaXRib3R8aWFfYXJjaGl2ZXJ8QmluZ2JvdHxCaW5nUHJldmlld3xhcHBsZWJvdHxmYWNlYm9va2V4dGVybmFsaGl0fGZhY2Vib29rY2F0YWxvZ3xUd2l0dGVyYm90fExpbmtlZEluQm90fFNsYWNrYm90fERpc2NvcmRib3R8V2hhdHNBcHB8U2t5cGVVcmlQcmV2aWV3fFlldGkvaVxuIl0sIm5hbWVzIjpbIkhUTUxfTElNSVRFRF9CT1RfVUFfUkUiXSwibWFwcGluZ3MiOiJBQUFBLDZHQUE2RztBQUM3RyxzS0FBc0s7Ozs7K0JBQ3pKQSwwQkFBQUE7OztlQUFBQTs7O0FBQU4sTUFBTUEseUJBQ1giLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNTUxMiwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9zaGFyZWQvbGliL3JvdXRlci91dGlscy9pcy1ib3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSFRNTF9MSU1JVEVEX0JPVF9VQV9SRSB9IGZyb20gJy4vaHRtbC1ib3RzJ1xuXG4vLyBCb3QgY3Jhd2xlciB0aGF0IHdpbGwgc3BpbiB1cCBhIGhlYWRsZXNzIGJyb3dzZXIgYW5kIGV4ZWN1dGUgSlMuXG4vLyBCeSBkZWZhdWx0LCBvbmx5IGdvb2dsZWJvdHMgYXJlIGNvbnNpZGVyZWQgYXMgRE9NIGJvdHMuIEJsb3cgaXMgd2hlcmUgdGhlIHJlZ2V4IGlzIGNvbXB1dGVkIGZyb206XG4vLyB4LXJlZjogaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vc2VhcmNoL2RvY3MvY3Jhd2xpbmctaW5kZXhpbmcvZ29vZ2xlLWNvbW1vbi1jcmF3bGVyc1xuY29uc3QgSEVBRExFU1NfQlJPV1NFUl9CT1RfVUFfUkUgPSAvZ29vZ2xlL2lcblxuZXhwb3J0IGNvbnN0IEhUTUxfTElNSVRFRF9CT1RfVUFfUkVfU1RSSU5HID0gSFRNTF9MSU1JVEVEX0JPVF9VQV9SRS5zb3VyY2VcblxuZXhwb3J0IHsgSFRNTF9MSU1JVEVEX0JPVF9VQV9SRSB9XG5cbmZ1bmN0aW9uIGlzRG9tQm90VUEodXNlckFnZW50OiBzdHJpbmcpIHtcbiAgcmV0dXJuIEhFQURMRVNTX0JST1dTRVJfQk9UX1VBX1JFLnRlc3QodXNlckFnZW50KVxufVxuXG5mdW5jdGlvbiBpc0h0bWxMaW1pdGVkQm90VUEodXNlckFnZW50OiBzdHJpbmcpIHtcbiAgcmV0dXJuIEhUTUxfTElNSVRFRF9CT1RfVUFfUkUudGVzdCh1c2VyQWdlbnQpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0JvdCh1c2VyQWdlbnQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gaXNEb21Cb3RVQSh1c2VyQWdlbnQpIHx8IGlzSHRtbExpbWl0ZWRCb3RVQSh1c2VyQWdlbnQpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRCb3RUeXBlKHVzZXJBZ2VudDogc3RyaW5nKTogJ2RvbScgfCAnaHRtbCcgfCB1bmRlZmluZWQge1xuICBpZiAoaXNEb21Cb3RVQSh1c2VyQWdlbnQpKSB7XG4gICAgcmV0dXJuICdkb20nXG4gIH1cbiAgaWYgKGlzSHRtbExpbWl0ZWRCb3RVQSh1c2VyQWdlbnQpKSB7XG4gICAgcmV0dXJuICdodG1sJ1xuICB9XG4gIHJldHVybiB1bmRlZmluZWRcbn1cbiJdLCJuYW1lcyI6WyJIVE1MX0xJTUlURURfQk9UX1VBX1JFIiwiSFRNTF9MSU1JVEVEX0JPVF9VQV9SRV9TVFJJTkciLCJnZXRCb3RUeXBlIiwiaXNCb3QiLCJIRUFETEVTU19CUk9XU0VSX0JPVF9VQV9SRSIsInNvdXJjZSIsImlzRG9tQm90VUEiLCJ1c2VyQWdlbnQiLCJ0ZXN0IiwiaXNIdG1sTGltaXRlZEJvdFVBIiwidW5kZWZpbmVkIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0lBU1NBLHNCQUFzQixFQUFBO2VBQXRCQSxVQUFBQSxzQkFBc0I7O0lBRmxCQyw2QkFBNkIsRUFBQTtlQUE3QkE7O0lBZ0JHQyxVQUFVLEVBQUE7ZUFBVkE7O0lBSkFDLEtBQUssRUFBQTtlQUFMQTs7OzBCQW5CdUI7QUFFdkMsbUVBQW1FO0FBQ25FLG9HQUFvRztBQUNwRyw0RkFBNEY7QUFDNUYsTUFBTUMsNkJBQTZCO0FBRTVCLE1BQU1ILGdDQUFnQ0QsVUFBQUEsc0JBQXNCLENBQUNLLE1BQU07QUFJMUUsU0FBU0MsV0FBV0MsU0FBaUI7SUFDbkMsT0FBT0gsMkJBQTJCSSxJQUFJLENBQUNEO0FBQ3pDO0FBRUEsU0FBU0UsbUJBQW1CRixTQUFpQjtJQUMzQyxPQUFPUCxVQUFBQSxzQkFBc0IsQ0FBQ1EsSUFBSSxDQUFDRDtBQUNyQztBQUVPLFNBQVNKLE1BQU1JLFNBQWlCO0lBQ3JDLE9BQU9ELFdBQVdDLGNBQWNFLG1CQUFtQkY7QUFDckQ7QUFFTyxTQUFTTCxXQUFXSyxTQUFpQjtJQUMxQyxJQUFJRCxXQUFXQyxZQUFZO1FBQ3pCLE9BQU87SUFDVDtJQUNBLElBQUlFLG1CQUFtQkYsWUFBWTtRQUNqQyxPQUFPO0lBQ1Q7SUFDQSxPQUFPRztBQUNUIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDU1NzEsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvY2xpZW50L2NvbXBvbmVudHMvYXBwLXJvdXRlci1hbm5vdW5jZXIudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgY3JlYXRlUG9ydGFsIH0gZnJvbSAncmVhY3QtZG9tJ1xuaW1wb3J0IHR5cGUgeyBGbGlnaHRSb3V0ZXJTdGF0ZSB9IGZyb20gJy4uLy4uL3NlcnZlci9hcHAtcmVuZGVyL3R5cGVzJ1xuXG5jb25zdCBBTk5PVU5DRVJfVFlQRSA9ICduZXh0LXJvdXRlLWFubm91bmNlcidcbmNvbnN0IEFOTk9VTkNFUl9JRCA9ICdfX25leHQtcm91dGUtYW5ub3VuY2VyX18nXG5cbmZ1bmN0aW9uIGdldEFubm91bmNlck5vZGUoKSB7XG4gIGNvbnN0IGV4aXN0aW5nQW5ub3VuY2VyID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoQU5OT1VOQ0VSX1RZUEUpWzBdXG4gIGlmIChleGlzdGluZ0Fubm91bmNlcj8uc2hhZG93Um9vdD8uY2hpbGROb2Rlc1swXSkge1xuICAgIHJldHVybiBleGlzdGluZ0Fubm91bmNlci5zaGFkb3dSb290LmNoaWxkTm9kZXNbMF0gYXMgSFRNTEVsZW1lbnRcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KEFOTk9VTkNFUl9UWVBFKVxuICAgIGNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gJ3Bvc2l0aW9uOmFic29sdXRlJ1xuICAgIGNvbnN0IGFubm91bmNlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgYW5ub3VuY2VyLmFyaWFMaXZlID0gJ2Fzc2VydGl2ZSdcbiAgICBhbm5vdW5jZXIuaWQgPSBBTk5PVU5DRVJfSURcbiAgICBhbm5vdW5jZXIucm9sZSA9ICdhbGVydCdcbiAgICBhbm5vdW5jZXIuc3R5bGUuY3NzVGV4dCA9XG4gICAgICAncG9zaXRpb246YWJzb2x1dGU7Ym9yZGVyOjA7aGVpZ2h0OjFweDttYXJnaW46LTFweDtwYWRkaW5nOjA7d2lkdGg6MXB4O2NsaXA6cmVjdCgwIDAgMCAwKTtvdmVyZmxvdzpoaWRkZW47d2hpdGUtc3BhY2U6bm93cmFwO3dvcmQtd3JhcDpub3JtYWwnXG5cbiAgICAvLyBVc2Ugc2hhZG93IERPTSBoZXJlIHRvIGF2b2lkIGFueSBwb3RlbnRpYWwgQ1NTIGJsZWVkXG4gICAgY29uc3Qgc2hhZG93ID0gY29udGFpbmVyLmF0dGFjaFNoYWRvdyh7IG1vZGU6ICdvcGVuJyB9KVxuICAgIHNoYWRvdy5hcHBlbmRDaGlsZChhbm5vdW5jZXIpXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjb250YWluZXIpXG4gICAgcmV0dXJuIGFubm91bmNlclxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBBcHBSb3V0ZXJBbm5vdW5jZXIoeyB0cmVlIH06IHsgdHJlZTogRmxpZ2h0Um91dGVyU3RhdGUgfSkge1xuICBjb25zdCBbcG9ydGFsTm9kZSwgc2V0UG9ydGFsTm9kZV0gPSB1c2VTdGF0ZTxIVE1MRWxlbWVudCB8IG51bGw+KG51bGwpXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBhbm5vdW5jZXIgPSBnZXRBbm5vdW5jZXJOb2RlKClcbiAgICBzZXRQb3J0YWxOb2RlKGFubm91bmNlcilcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoQU5OT1VOQ0VSX1RZUEUpWzBdXG4gICAgICBpZiAoY29udGFpbmVyPy5pc0Nvbm5lY3RlZCkge1xuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGNvbnRhaW5lcilcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtdKVxuXG4gIGNvbnN0IFtyb3V0ZUFubm91bmNlbWVudCwgc2V0Um91dGVBbm5vdW5jZW1lbnRdID0gdXNlU3RhdGUoJycpXG4gIGNvbnN0IHByZXZpb3VzVGl0bGUgPSB1c2VSZWY8c3RyaW5nIHwgdW5kZWZpbmVkPih1bmRlZmluZWQpXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBsZXQgY3VycmVudFRpdGxlID0gJydcbiAgICBpZiAoZG9jdW1lbnQudGl0bGUpIHtcbiAgICAgIGN1cnJlbnRUaXRsZSA9IGRvY3VtZW50LnRpdGxlXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHBhZ2VIZWFkZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdoMScpXG4gICAgICBpZiAocGFnZUhlYWRlcikge1xuICAgICAgICBjdXJyZW50VGl0bGUgPSBwYWdlSGVhZGVyLmlubmVyVGV4dCB8fCBwYWdlSGVhZGVyLnRleHRDb250ZW50IHx8ICcnXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gT25seSBhbm5vdW5jZSB0aGUgdGl0bGUgY2hhbmdlLCBidXQgbm90IGZvciB0aGUgZmlyc3QgbG9hZCBiZWNhdXNlIHNjcmVlblxuICAgIC8vIHJlYWRlcnMgZG8gdGhhdCBhdXRvbWF0aWNhbGx5LlxuICAgIGlmIChcbiAgICAgIHByZXZpb3VzVGl0bGUuY3VycmVudCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICBwcmV2aW91c1RpdGxlLmN1cnJlbnQgIT09IGN1cnJlbnRUaXRsZVxuICAgICkge1xuICAgICAgc2V0Um91dGVBbm5vdW5jZW1lbnQoY3VycmVudFRpdGxlKVxuICAgIH1cbiAgICBwcmV2aW91c1RpdGxlLmN1cnJlbnQgPSBjdXJyZW50VGl0bGVcbiAgfSwgW3RyZWVdKVxuXG4gIHJldHVybiBwb3J0YWxOb2RlID8gY3JlYXRlUG9ydGFsKHJvdXRlQW5ub3VuY2VtZW50LCBwb3J0YWxOb2RlKSA6IG51bGxcbn1cbiJdLCJuYW1lcyI6WyJBcHBSb3V0ZXJBbm5vdW5jZXIiLCJBTk5PVU5DRVJfVFlQRSIsIkFOTk9VTkNFUl9JRCIsImdldEFubm91bmNlck5vZGUiLCJleGlzdGluZ0Fubm91bmNlciIsImRvY3VtZW50IiwiZ2V0RWxlbWVudHNCeU5hbWUiLCJzaGFkb3dSb290IiwiY2hpbGROb2RlcyIsImNvbnRhaW5lciIsImNyZWF0ZUVsZW1lbnQiLCJzdHlsZSIsImNzc1RleHQiLCJhbm5vdW5jZXIiLCJhcmlhTGl2ZSIsImlkIiwicm9sZSIsInNoYWRvdyIsImF0dGFjaFNoYWRvdyIsIm1vZGUiLCJhcHBlbmRDaGlsZCIsImJvZHkiLCJ0cmVlIiwicG9ydGFsTm9kZSIsInNldFBvcnRhbE5vZGUiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwiaXNDb25uZWN0ZWQiLCJyZW1vdmVDaGlsZCIsInJvdXRlQW5ub3VuY2VtZW50Iiwic2V0Um91dGVBbm5vdW5jZW1lbnQiLCJwcmV2aW91c1RpdGxlIiwidXNlUmVmIiwidW5kZWZpbmVkIiwiY3VycmVudFRpdGxlIiwidGl0bGUiLCJwYWdlSGVhZGVyIiwicXVlcnlTZWxlY3RvciIsImlubmVyVGV4dCIsInRleHRDb250ZW50IiwiY3VycmVudCIsImNyZWF0ZVBvcnRhbCJdLCJtYXBwaW5ncyI6Ijs7OytCQTZCZ0JBLHNCQUFBQTs7O2VBQUFBOzs7dUJBN0I0QjswQkFDZjtBQUc3QixNQUFNQyxpQkFBaUI7QUFDdkIsTUFBTUMsZUFBZTtBQUVyQixTQUFTQztRQUVIQztJQURKLE1BQU1BLG9CQUFvQkMsU0FBU0MsaUJBQWlCLENBQUNMLGVBQWUsQ0FBQyxFQUFFO0lBQ3ZFLElBQUlHLHFCQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxDQUFBQSxnQ0FBQUEsa0JBQW1CRyxVQUFVLEtBQUEsT0FBQSxLQUFBLElBQTdCSCw4QkFBK0JJLFVBQVUsQ0FBQyxFQUFFLEVBQUU7UUFDaEQsT0FBT0osa0JBQWtCRyxVQUFVLENBQUNDLFVBQVUsQ0FBQyxFQUFFO0lBQ25ELE9BQU87UUFDTCxNQUFNQyxZQUFZSixTQUFTSyxhQUFhLENBQUNUO1FBQ3pDUSxVQUFVRSxLQUFLLENBQUNDLE9BQU8sR0FBRztRQUMxQixNQUFNQyxZQUFZUixTQUFTSyxhQUFhLENBQUM7UUFDekNHLFVBQVVDLFFBQVEsR0FBRztRQUNyQkQsVUFBVUUsRUFBRSxHQUFHYjtRQUNmVyxVQUFVRyxJQUFJLEdBQUc7UUFDakJILFVBQVVGLEtBQUssQ0FBQ0MsT0FBTyxHQUNyQjtRQUVGLHVEQUF1RDtRQUN2RCxNQUFNSyxTQUFTUixVQUFVUyxZQUFZLENBQUM7WUFBRUMsTUFBTTtRQUFPO1FBQ3JERixPQUFPRyxXQUFXLENBQUNQO1FBQ25CUixTQUFTZ0IsSUFBSSxDQUFDRCxXQUFXLENBQUNYO1FBQzFCLE9BQU9JO0lBQ1Q7QUFDRjtBQUVPLFNBQVNiLG1CQUFtQixLQUFxQztJQUFyQyxJQUFBLEVBQUVzQixJQUFJLEVBQStCLEdBQXJDO0lBQ2pDLE1BQU0sQ0FBQ0MsWUFBWUMsY0FBYyxHQUFHQyxDQUFBQSxHQUFBQSxPQUFBQSxRQUFRLEVBQXFCO0lBRWpFQyxDQUFBQSxHQUFBQSxPQUFBQSxTQUFTLEVBQUM7UUFDUixNQUFNYixZQUFZVjtRQUNsQnFCLGNBQWNYO1FBQ2QsT0FBTztZQUNMLE1BQU1KLFlBQVlKLFNBQVNzQixvQkFBb0IsQ0FBQzFCLGVBQWUsQ0FBQyxFQUFFO1lBQ2xFLElBQUlRLGFBQUFBLE9BQUFBLEtBQUFBLElBQUFBLFVBQVdtQixXQUFXLEVBQUU7Z0JBQzFCdkIsU0FBU2dCLElBQUksQ0FBQ1EsV0FBVyxDQUFDcEI7WUFDNUI7UUFDRjtJQUNGLEdBQUcsRUFBRTtJQUVMLE1BQU0sQ0FBQ3FCLG1CQUFtQkMscUJBQXFCLEdBQUdOLENBQUFBLEdBQUFBLE9BQUFBLFFBQVEsRUFBQztJQUMzRCxNQUFNTyxnQkFBZ0JDLENBQUFBLEdBQUFBLE9BQUFBLE1BQU0sRUFBcUJDO0lBRWpEUixDQUFBQSxHQUFBQSxPQUFBQSxTQUFTLEVBQUM7UUFDUixJQUFJUyxlQUFlO1FBQ25CLElBQUk5QixTQUFTK0IsS0FBSyxFQUFFO1lBQ2xCRCxlQUFlOUIsU0FBUytCLEtBQUs7UUFDL0IsT0FBTztZQUNMLE1BQU1DLGFBQWFoQyxTQUFTaUMsYUFBYSxDQUFDO1lBQzFDLElBQUlELFlBQVk7Z0JBQ2RGLGVBQWVFLFdBQVdFLFNBQVMsSUFBSUYsV0FBV0csV0FBVyxJQUFJO1lBQ25FO1FBQ0Y7UUFFQSw0RUFBNEU7UUFDNUUsaUNBQWlDO1FBQ2pDLElBQ0VSLGNBQWNTLE9BQU8sS0FBS1AsYUFDMUJGLGNBQWNTLE9BQU8sS0FBS04sY0FDMUI7WUFDQUoscUJBQXFCSTtRQUN2QjtRQUNBSCxjQUFjUyxPQUFPLEdBQUdOO0lBQzFCLEdBQUc7UUFBQ2I7S0FBSztJQUVULE9BQU9DLGFBQUFBLFdBQUFBLEdBQWFtQixDQUFBQSxHQUFBQSxVQUFBQSxZQUFZLEVBQUNaLG1CQUFtQlAsY0FBYztBQUNwRSIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA1NjU1LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2NsaWVudC9jb21wb25lbnRzL3JlZGlyZWN0LWJvdW5kYXJ5LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcbmltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB0eXBlIHsgQXBwUm91dGVySW5zdGFuY2UgfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB7IHVzZVJvdXRlciB9IGZyb20gJy4vbmF2aWdhdGlvbidcbmltcG9ydCB7IGdldFJlZGlyZWN0VHlwZUZyb21FcnJvciwgZ2V0VVJMRnJvbVJlZGlyZWN0RXJyb3IgfSBmcm9tICcuL3JlZGlyZWN0J1xuaW1wb3J0IHsgUmVkaXJlY3RUeXBlLCBpc1JlZGlyZWN0RXJyb3IgfSBmcm9tICcuL3JlZGlyZWN0LWVycm9yJ1xuXG5pbnRlcmZhY2UgUmVkaXJlY3RCb3VuZGFyeVByb3BzIHtcbiAgcm91dGVyOiBBcHBSb3V0ZXJJbnN0YW5jZVxuICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlXG59XG5cbmZ1bmN0aW9uIEhhbmRsZVJlZGlyZWN0KHtcbiAgcmVkaXJlY3QsXG4gIHJlc2V0LFxuICByZWRpcmVjdFR5cGUsXG59OiB7XG4gIHJlZGlyZWN0OiBzdHJpbmdcbiAgcmVkaXJlY3RUeXBlOiBSZWRpcmVjdFR5cGVcbiAgcmVzZXQ6ICgpID0+IHZvaWRcbn0pIHtcbiAgY29uc3Qgcm91dGVyID0gdXNlUm91dGVyKClcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIFJlYWN0LnN0YXJ0VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICBpZiAocmVkaXJlY3RUeXBlID09PSBSZWRpcmVjdFR5cGUucHVzaCkge1xuICAgICAgICByb3V0ZXIucHVzaChyZWRpcmVjdCwge30pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb3V0ZXIucmVwbGFjZShyZWRpcmVjdCwge30pXG4gICAgICB9XG4gICAgICByZXNldCgpXG4gICAgfSlcbiAgfSwgW3JlZGlyZWN0LCByZWRpcmVjdFR5cGUsIHJlc2V0LCByb3V0ZXJdKVxuXG4gIHJldHVybiBudWxsXG59XG5cbmV4cG9ydCBjbGFzcyBSZWRpcmVjdEVycm9yQm91bmRhcnkgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8XG4gIFJlZGlyZWN0Qm91bmRhcnlQcm9wcyxcbiAgeyByZWRpcmVjdDogc3RyaW5nIHwgbnVsbDsgcmVkaXJlY3RUeXBlOiBSZWRpcmVjdFR5cGUgfCBudWxsIH1cbj4ge1xuICBjb25zdHJ1Y3Rvcihwcm9wczogUmVkaXJlY3RCb3VuZGFyeVByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpXG4gICAgdGhpcy5zdGF0ZSA9IHsgcmVkaXJlY3Q6IG51bGwsIHJlZGlyZWN0VHlwZTogbnVsbCB9XG4gIH1cblxuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yOiBhbnkpIHtcbiAgICBpZiAoaXNSZWRpcmVjdEVycm9yKGVycm9yKSkge1xuICAgICAgY29uc3QgdXJsID0gZ2V0VVJMRnJvbVJlZGlyZWN0RXJyb3IoZXJyb3IpXG4gICAgICBjb25zdCByZWRpcmVjdFR5cGUgPSBnZXRSZWRpcmVjdFR5cGVGcm9tRXJyb3IoZXJyb3IpXG4gICAgICByZXR1cm4geyByZWRpcmVjdDogdXJsLCByZWRpcmVjdFR5cGUgfVxuICAgIH1cbiAgICAvLyBSZS10aHJvdyBpZiBlcnJvciBpcyBub3QgZm9yIHJlZGlyZWN0XG4gICAgdGhyb3cgZXJyb3JcbiAgfVxuXG4gIC8vIEV4cGxpY2l0IHR5cGUgaXMgbmVlZGVkIHRvIGF2b2lkIHRoZSBnZW5lcmF0ZWQgYC5kLnRzYCBoYXZpbmcgYSB3aWRlIHJldHVybiB0eXBlIHRoYXQgY291bGQgYmUgc3BlY2lmaWMgdG8gdGhlIGBAdHlwZXMvcmVhY3RgIHZlcnNpb24uXG4gIHJlbmRlcigpOiBSZWFjdC5SZWFjdE5vZGUge1xuICAgIGNvbnN0IHsgcmVkaXJlY3QsIHJlZGlyZWN0VHlwZSB9ID0gdGhpcy5zdGF0ZVxuICAgIGlmIChyZWRpcmVjdCAhPT0gbnVsbCAmJiByZWRpcmVjdFR5cGUgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxIYW5kbGVSZWRpcmVjdFxuICAgICAgICAgIHJlZGlyZWN0PXtyZWRpcmVjdH1cbiAgICAgICAgICByZWRpcmVjdFR5cGU9e3JlZGlyZWN0VHlwZX1cbiAgICAgICAgICByZXNldD17KCkgPT4gdGhpcy5zZXRTdGF0ZSh7IHJlZGlyZWN0OiBudWxsIH0pfVxuICAgICAgICAvPlxuICAgICAgKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJlZGlyZWN0Qm91bmRhcnkoeyBjaGlsZHJlbiB9OiB7IGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGUgfSkge1xuICBjb25zdCByb3V0ZXIgPSB1c2VSb3V0ZXIoKVxuICByZXR1cm4gKFxuICAgIDxSZWRpcmVjdEVycm9yQm91bmRhcnkgcm91dGVyPXtyb3V0ZXJ9PntjaGlsZHJlbn08L1JlZGlyZWN0RXJyb3JCb3VuZGFyeT5cbiAgKVxufVxuIl0sIm5hbWVzIjpbIlJlZGlyZWN0Qm91bmRhcnkiLCJSZWRpcmVjdEVycm9yQm91bmRhcnkiLCJIYW5kbGVSZWRpcmVjdCIsInJlZGlyZWN0IiwicmVzZXQiLCJyZWRpcmVjdFR5cGUiLCJyb3V0ZXIiLCJ1c2VSb3V0ZXIiLCJ1c2VFZmZlY3QiLCJSZWFjdCIsInN0YXJ0VHJhbnNpdGlvbiIsIlJlZGlyZWN0VHlwZSIsInB1c2giLCJyZXBsYWNlIiwiQ29tcG9uZW50IiwiZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIiwiZXJyb3IiLCJpc1JlZGlyZWN0RXJyb3IiLCJ1cmwiLCJnZXRVUkxGcm9tUmVkaXJlY3RFcnJvciIsImdldFJlZGlyZWN0VHlwZUZyb21FcnJvciIsInJlbmRlciIsInN0YXRlIiwic2V0U3RhdGUiLCJwcm9wcyIsImNoaWxkcmVuIiwiY29uc3RydWN0b3IiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0lBeUVnQkEsZ0JBQWdCLEVBQUE7ZUFBaEJBOztJQXBDSEMscUJBQXFCLEVBQUE7ZUFBckJBOzs7OztpRUFwQ29COzRCQUVQOzBCQUN3QzsrQkFDcEI7QUFPOUMsU0FBU0MsZUFBZSxLQVF2QjtJQVJ1QixJQUFBLEVBQ3RCQyxRQUFRLEVBQ1JDLEtBQUssRUFDTEMsWUFBWSxFQUtiLEdBUnVCO0lBU3RCLE1BQU1DLFNBQVNDLENBQUFBLEdBQUFBLFlBQUFBLFNBQVM7SUFFeEJDLENBQUFBLEdBQUFBLE9BQUFBLFNBQVMsRUFBQztRQUNSQyxPQUFBQSxPQUFLLENBQUNDLGVBQWUsQ0FBQztZQUNwQixJQUFJTCxpQkFBaUJNLGVBQUFBLFlBQVksQ0FBQ0MsSUFBSSxFQUFFO2dCQUN0Q04sT0FBT00sSUFBSSxDQUFDVCxVQUFVLENBQUM7WUFDekIsT0FBTztnQkFDTEcsT0FBT08sT0FBTyxDQUFDVixVQUFVLENBQUM7WUFDNUI7WUFDQUM7UUFDRjtJQUNGLEdBQUc7UUFBQ0Q7UUFBVUU7UUFBY0Q7UUFBT0U7S0FBTztJQUUxQyxPQUFPO0FBQ1Q7QUFFTyxNQUFNTCw4QkFBOEJRLE9BQUFBLE9BQUssQ0FBQ0ssU0FBUztJQVN4RCxPQUFPQyx5QkFBeUJDLEtBQVUsRUFBRTtRQUMxQyxJQUFJQyxDQUFBQSxHQUFBQSxlQUFBQSxlQUFlLEVBQUNELFFBQVE7WUFDMUIsTUFBTUUsTUFBTUMsQ0FBQUEsR0FBQUEsVUFBQUEsdUJBQXVCLEVBQUNIO1lBQ3BDLE1BQU1YLGVBQWVlLENBQUFBLEdBQUFBLFVBQUFBLHdCQUF3QixFQUFDSjtZQUM5QyxPQUFPO2dCQUFFYixVQUFVZTtnQkFBS2I7WUFBYTtRQUN2QztRQUNBLHdDQUF3QztRQUN4QyxNQUFNVztJQUNSO0lBRUEseUlBQXlJO0lBQ3pJSyxTQUEwQjtRQUN4QixNQUFNLEVBQUVsQixRQUFRLEVBQUVFLFlBQVksRUFBRSxHQUFHLElBQUksQ0FBQ2lCLEtBQUs7UUFDN0MsSUFBSW5CLGFBQWEsUUFBUUUsaUJBQWlCLE1BQU07WUFDOUMsT0FBQSxXQUFBLEdBQ0UsQ0FBQSxHQUFBLFlBQUEsR0FBQSxFQUFDSCxnQkFBQUE7Z0JBQ0NDLFVBQVVBO2dCQUNWRSxjQUFjQTtnQkFDZEQsT0FBTyxJQUFNLElBQUksQ0FBQ21CLFFBQVEsQ0FBQzt3QkFBRXBCLFVBQVU7b0JBQUs7O1FBR2xEO1FBRUEsT0FBTyxJQUFJLENBQUNxQixLQUFLLENBQUNDLFFBQVE7SUFDNUI7SUE3QkFDLFlBQVlGLEtBQTRCLENBQUU7UUFDeEMsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ0YsS0FBSyxHQUFHO1lBQUVuQixVQUFVO1lBQU1FLGNBQWM7UUFBSztJQUNwRDtBQTJCRjtBQUVPLFNBQVNMLGlCQUFpQixLQUEyQztJQUEzQyxJQUFBLEVBQUV5QixRQUFRLEVBQWlDLEdBQTNDO0lBQy9CLE1BQU1uQixTQUFTQyxDQUFBQSxHQUFBQSxZQUFBQSxTQUFTO0lBQ3hCLE9BQUEsV0FBQSxHQUNFLENBQUEsR0FBQSxZQUFBLEdBQUEsRUFBQ04sdUJBQUFBO1FBQXNCSyxRQUFRQTtrQkFBU21COztBQUU1QyIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA1NzU4LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL2ZpbmQtaGVhZC1pbi1jYWNoZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IEZsaWdodFJvdXRlclN0YXRlIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvdHlwZXMnXG5pbXBvcnQgdHlwZSB7IENhY2hlTm9kZSB9IGZyb20gJy4uLy4uLy4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHsgREVGQVVMVF9TRUdNRU5UX0tFWSB9IGZyb20gJy4uLy4uLy4uLy4uL3NoYXJlZC9saWIvc2VnbWVudCdcbmltcG9ydCB7IGNyZWF0ZVJvdXRlckNhY2hlS2V5IH0gZnJvbSAnLi4vY3JlYXRlLXJvdXRlci1jYWNoZS1rZXknXG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kSGVhZEluQ2FjaGUoXG4gIGNhY2hlOiBDYWNoZU5vZGUsXG4gIHBhcmFsbGVsUm91dGVzOiBGbGlnaHRSb3V0ZXJTdGF0ZVsxXVxuKTogW0NhY2hlTm9kZSwgc3RyaW5nXSB8IG51bGwge1xuICByZXR1cm4gZmluZEhlYWRJbkNhY2hlSW1wbChjYWNoZSwgcGFyYWxsZWxSb3V0ZXMsICcnKVxufVxuXG5mdW5jdGlvbiBmaW5kSGVhZEluQ2FjaGVJbXBsKFxuICBjYWNoZTogQ2FjaGVOb2RlLFxuICBwYXJhbGxlbFJvdXRlczogRmxpZ2h0Um91dGVyU3RhdGVbMV0sXG4gIGtleVByZWZpeDogc3RyaW5nXG4pOiBbQ2FjaGVOb2RlLCBzdHJpbmddIHwgbnVsbCB7XG4gIGNvbnN0IGlzTGFzdEl0ZW0gPSBPYmplY3Qua2V5cyhwYXJhbGxlbFJvdXRlcykubGVuZ3RoID09PSAwXG4gIGlmIChpc0xhc3RJdGVtKSB7XG4gICAgLy8gUmV0dXJucyB0aGUgZW50aXJlIENhY2hlIE5vZGUgb2YgdGhlIHNlZ21lbnQgd2hvc2UgaGVhZCB3ZSB3aWxsIHJlbmRlci5cbiAgICByZXR1cm4gW2NhY2hlLCBrZXlQcmVmaXhdXG4gIH1cblxuICAvLyBGaXJzdCB0cnkgdGhlICdjaGlsZHJlbicgcGFyYWxsZWwgcm91dGUgaWYgaXQgZXhpc3RzXG4gIC8vIHdoZW4gc3RhcnRpbmcgZnJvbSB0aGUgXCJyb290XCIsIHRoaXMgY29ycmVzcG9uZHMgd2l0aCB0aGUgbWFpbiBwYWdlIGNvbXBvbmVudFxuICBjb25zdCBwYXJhbGxlbFJvdXRlc0tleXMgPSBPYmplY3Qua2V5cyhwYXJhbGxlbFJvdXRlcykuZmlsdGVyKFxuICAgIChrZXkpID0+IGtleSAhPT0gJ2NoaWxkcmVuJ1xuICApXG5cbiAgLy8gaWYgd2UgYXJlIGF0IHRoZSByb290LCB3ZSBuZWVkIHRvIGNoZWNrIHRoZSBjaGlsZHJlbiBzbG90IGZpcnN0XG4gIGlmICgnY2hpbGRyZW4nIGluIHBhcmFsbGVsUm91dGVzKSB7XG4gICAgcGFyYWxsZWxSb3V0ZXNLZXlzLnVuc2hpZnQoJ2NoaWxkcmVuJylcbiAgfVxuXG4gIGZvciAoY29uc3Qga2V5IG9mIHBhcmFsbGVsUm91dGVzS2V5cykge1xuICAgIGNvbnN0IFtzZWdtZW50LCBjaGlsZFBhcmFsbGVsUm91dGVzXSA9IHBhcmFsbGVsUm91dGVzW2tleV1cbiAgICAvLyBJZiB0aGUgcGFyYWxsZWwgaXMgbm90IG1hdGNoZWQgYW5kIHVzaW5nIHRoZSBkZWZhdWx0IHNlZ21lbnQsXG4gICAgLy8gc2tpcCBzZWFyY2hpbmcgdGhlIGhlYWQgZnJvbSBpdC5cbiAgICBpZiAoc2VnbWVudCA9PT0gREVGQVVMVF9TRUdNRU5UX0tFWSkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgY29uc3QgY2hpbGRTZWdtZW50TWFwID0gY2FjaGUucGFyYWxsZWxSb3V0ZXMuZ2V0KGtleSlcbiAgICBpZiAoIWNoaWxkU2VnbWVudE1hcCkge1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBjb25zdCBjYWNoZUtleSA9IGNyZWF0ZVJvdXRlckNhY2hlS2V5KHNlZ21lbnQpXG5cbiAgICBjb25zdCBjYWNoZU5vZGUgPSBjaGlsZFNlZ21lbnRNYXAuZ2V0KGNhY2hlS2V5KVxuICAgIGlmICghY2FjaGVOb2RlKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGNvbnN0IGl0ZW0gPSBmaW5kSGVhZEluQ2FjaGVJbXBsKFxuICAgICAgY2FjaGVOb2RlLFxuICAgICAgY2hpbGRQYXJhbGxlbFJvdXRlcyxcbiAgICAgIGtleVByZWZpeCArICcvJyArIGNhY2hlS2V5XG4gICAgKVxuICAgIGlmIChpdGVtKSB7XG4gICAgICByZXR1cm4gaXRlbVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG4iXSwibmFtZXMiOlsiZmluZEhlYWRJbkNhY2hlIiwiY2FjaGUiLCJwYXJhbGxlbFJvdXRlcyIsImZpbmRIZWFkSW5DYWNoZUltcGwiLCJrZXlQcmVmaXgiLCJpc0xhc3RJdGVtIiwiT2JqZWN0Iiwia2V5cyIsImxlbmd0aCIsInBhcmFsbGVsUm91dGVzS2V5cyIsImZpbHRlciIsImtleSIsInVuc2hpZnQiLCJzZWdtZW50IiwiY2hpbGRQYXJhbGxlbFJvdXRlcyIsIkRFRkFVTFRfU0VHTUVOVF9LRVkiLCJjaGlsZFNlZ21lbnRNYXAiLCJnZXQiLCJjYWNoZUtleSIsImNyZWF0ZVJvdXRlckNhY2hlS2V5IiwiY2FjaGVOb2RlIiwiaXRlbSJdLCJtYXBwaW5ncyI6Ijs7OytCQUtnQkEsbUJBQUFBOzs7ZUFBQUE7Ozt5QkFIb0I7c0NBQ0M7QUFFOUIsU0FBU0EsZ0JBQ2RDLEtBQWdCLEVBQ2hCQyxjQUFvQztJQUVwQyxPQUFPQyxvQkFBb0JGLE9BQU9DLGdCQUFnQjtBQUNwRDtBQUVBLFNBQVNDLG9CQUNQRixLQUFnQixFQUNoQkMsY0FBb0MsRUFDcENFLFNBQWlCO0lBRWpCLE1BQU1DLGFBQWFDLE9BQU9DLElBQUksQ0FBQ0wsZ0JBQWdCTSxNQUFNLEtBQUs7SUFDMUQsSUFBSUgsWUFBWTtRQUNkLDBFQUEwRTtRQUMxRSxPQUFPO1lBQUNKO1lBQU9HO1NBQVU7SUFDM0I7SUFFQSx1REFBdUQ7SUFDdkQsK0VBQStFO0lBQy9FLE1BQU1LLHFCQUFxQkgsT0FBT0MsSUFBSSxDQUFDTCxnQkFBZ0JRLE1BQU0sQ0FDM0QsQ0FBQ0MsTUFBUUEsUUFBUTtJQUduQixrRUFBa0U7SUFDbEUsSUFBSSxjQUFjVCxnQkFBZ0I7UUFDaENPLG1CQUFtQkcsT0FBTyxDQUFDO0lBQzdCO0lBRUEsS0FBSyxNQUFNRCxPQUFPRixtQkFBb0I7UUFDcEMsTUFBTSxDQUFDSSxTQUFTQyxvQkFBb0IsR0FBR1osY0FBYyxDQUFDUyxJQUFJO1FBQzFELGdFQUFnRTtRQUNoRSxtQ0FBbUM7UUFDbkMsSUFBSUUsWUFBWUUsU0FBQUEsbUJBQW1CLEVBQUU7WUFDbkM7UUFDRjtRQUNBLE1BQU1DLGtCQUFrQmYsTUFBTUMsY0FBYyxDQUFDZSxHQUFHLENBQUNOO1FBQ2pELElBQUksQ0FBQ0ssaUJBQWlCO1lBQ3BCO1FBQ0Y7UUFFQSxNQUFNRSxXQUFXQyxDQUFBQSxHQUFBQSxzQkFBQUEsb0JBQW9CLEVBQUNOO1FBRXRDLE1BQU1PLFlBQVlKLGdCQUFnQkMsR0FBRyxDQUFDQztRQUN0QyxJQUFJLENBQUNFLFdBQVc7WUFDZDtRQUNGO1FBRUEsTUFBTUMsT0FBT2xCLG9CQUNYaUIsV0FDQU4scUJBQ0FWLFlBQVksTUFBTWM7UUFFcEIsSUFBSUcsTUFBTTtZQUNSLE9BQU9BO1FBQ1Q7SUFDRjtJQUVBLE9BQU87QUFDVCIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA1ODI0LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2NsaWVudC9jb21wb25lbnRzL3VucmVzb2x2ZWQtdGhlbmFibGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDcmVhdGUgYSBcIlRoZW5hYmxlXCIgdGhhdCBkb2VzIG5vdCByZXNvbHZlLiBUaGlzIGlzIHVzZWQgdG8gc3VzcGVuZCBpbmRlZmluaXRlbHkgd2hlbiBkYXRhIGlzIG5vdCBhdmFpbGFibGUgeWV0LlxuICovXG5leHBvcnQgY29uc3QgdW5yZXNvbHZlZFRoZW5hYmxlID0ge1xuICB0aGVuOiAoKSA9PiB7fSxcbn0gYXMgUHJvbWlzZUxpa2U8dm9pZD5cbiJdLCJuYW1lcyI6WyJ1bnJlc29sdmVkVGhlbmFibGUiLCJ0aGVuIl0sIm1hcHBpbmdzIjoiQUFBQTs7Q0FFQzs7OytCQUNZQSxzQkFBQUE7OztlQUFBQTs7O0FBQU4sTUFBTUEscUJBQXFCO0lBQ2hDQyxNQUFNLEtBQU87QUFDZiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA1ODUxLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3BhdGgtaGFzLXByZWZpeC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwYXJzZVBhdGggfSBmcm9tICcuL3BhcnNlLXBhdGgnXG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgZ2l2ZW4gcGF0aCBzdGFydHMgd2l0aCBhIGdpdmVuIHByZWZpeC4gSXQgZW5zdXJlcyBpdCBtYXRjaGVzXG4gKiBleGFjdGx5IHdpdGhvdXQgY29udGFpbmluZyBleHRyYSBjaGFycy4gZS5nLiBwcmVmaXggL2RvY3Mgc2hvdWxkIHJlcGxhY2VcbiAqIGZvciAvZG9jcywgL2RvY3MvLCAvZG9jcy9hIGJ1dCBub3QgL2RvY3Nzc1xuICogQHBhcmFtIHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcGFyYW0gcHJlZml4IFRoZSBwcmVmaXggdG8gY2hlY2sgYWdhaW5zdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhdGhIYXNQcmVmaXgocGF0aDogc3RyaW5nLCBwcmVmaXg6IHN0cmluZykge1xuICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBjb25zdCB7IHBhdGhuYW1lIH0gPSBwYXJzZVBhdGgocGF0aClcbiAgcmV0dXJuIHBhdGhuYW1lID09PSBwcmVmaXggfHwgcGF0aG5hbWUuc3RhcnRzV2l0aChwcmVmaXggKyAnLycpXG59XG4iXSwibmFtZXMiOlsicGF0aEhhc1ByZWZpeCIsInBhdGgiLCJwcmVmaXgiLCJwYXRobmFtZSIsInBhcnNlUGF0aCIsInN0YXJ0c1dpdGgiXSwibWFwcGluZ3MiOiI7OzsrQkFTZ0JBLGlCQUFBQTs7O2VBQUFBOzs7MkJBVFU7QUFTbkIsU0FBU0EsY0FBY0MsSUFBWSxFQUFFQyxNQUFjO0lBQ3hELElBQUksT0FBT0QsU0FBUyxVQUFVO1FBQzVCLE9BQU87SUFDVDtJQUVBLE1BQU0sRUFBRUUsUUFBUSxFQUFFLEdBQUdDLENBQUFBLEdBQUFBLFdBQUFBLFNBQVMsRUFBQ0g7SUFDL0IsT0FBT0UsYUFBYUQsVUFBVUMsU0FBU0UsVUFBVSxDQUFDSCxTQUFTO0FBQzdEIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDU4NzQsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvY2xpZW50L2hhcy1iYXNlLXBhdGgudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcGF0aEhhc1ByZWZpeCB9IGZyb20gJy4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3BhdGgtaGFzLXByZWZpeCdcblxuY29uc3QgYmFzZVBhdGggPSAocHJvY2Vzcy5lbnYuX19ORVhUX1JPVVRFUl9CQVNFUEFUSCBhcyBzdHJpbmcpIHx8ICcnXG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNCYXNlUGF0aChwYXRoOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIHBhdGhIYXNQcmVmaXgocGF0aCwgYmFzZVBhdGgpXG59XG4iXSwibmFtZXMiOlsiaGFzQmFzZVBhdGgiLCJiYXNlUGF0aCIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfUk9VVEVSX0JBU0VQQVRIIiwicGF0aCIsInBhdGhIYXNQcmVmaXgiXSwibWFwcGluZ3MiOiI7OzsrQkFJZ0JBLGVBQUFBOzs7ZUFBQUE7OzsrQkFKYztBQUU5QixNQUFNQyxXQUFZQyxRQUFRQyxHQUFHLENBQUNDLHNCQUFzQixNQUFlO0FBRTVELFNBQVNKLFlBQVlLLElBQVk7SUFDdEMsT0FBT0MsQ0FBQUEsR0FBQUEsZUFBQUEsYUFBYSxFQUFDRCxNQUFNSjtBQUM3QiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA1OTAxLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2NsaWVudC9yZW1vdmUtYmFzZS1wYXRoLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGhhc0Jhc2VQYXRoIH0gZnJvbSAnLi9oYXMtYmFzZS1wYXRoJ1xuXG5jb25zdCBiYXNlUGF0aCA9IChwcm9jZXNzLmVudi5fX05FWFRfUk9VVEVSX0JBU0VQQVRIIGFzIHN0cmluZykgfHwgJydcblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUJhc2VQYXRoKHBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gIGlmIChwcm9jZXNzLmVudi5fX05FWFRfTUFOVUFMX0NMSUVOVF9CQVNFX1BBVEgpIHtcbiAgICBpZiAoIWhhc0Jhc2VQYXRoKHBhdGgpKSB7XG4gICAgICByZXR1cm4gcGF0aFxuICAgIH1cbiAgfVxuXG4gIC8vIENhbid0IHRyaW0gdGhlIGJhc2VQYXRoIGlmIGl0IGhhcyB6ZXJvIGxlbmd0aCFcbiAgaWYgKGJhc2VQYXRoLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHBhdGhcblxuICBwYXRoID0gcGF0aC5zbGljZShiYXNlUGF0aC5sZW5ndGgpXG4gIGlmICghcGF0aC5zdGFydHNXaXRoKCcvJykpIHBhdGggPSBgLyR7cGF0aH1gXG4gIHJldHVybiBwYXRoXG59XG4iXSwibmFtZXMiOlsicmVtb3ZlQmFzZVBhdGgiLCJiYXNlUGF0aCIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfUk9VVEVSX0JBU0VQQVRIIiwicGF0aCIsIl9fTkVYVF9NQU5VQUxfQ0xJRU5UX0JBU0VfUEFUSCIsImhhc0Jhc2VQYXRoIiwibGVuZ3RoIiwic2xpY2UiLCJzdGFydHNXaXRoIl0sIm1hcHBpbmdzIjoiOzs7K0JBSWdCQSxrQkFBQUE7OztlQUFBQTs7OzZCQUpZO0FBRTVCLE1BQU1DLFdBQVlDLFFBQVFDLEdBQUcsQ0FBQ0Msc0JBQXNCLE1BQWU7QUFFNUQsU0FBU0osZUFBZUssSUFBWTtJQUN6QyxJQUFJSCxRQUFRQyxHQUFHLENBQUNHLDhCQUE4QixFQUFFOztJQU1oRCxpREFBaUQ7SUFDakQsSUFBSUwsU0FBU08sTUFBTSxLQUFLLEdBQUcsT0FBT0g7SUFFbENBLE9BQU9BLEtBQUtJLEtBQUssQ0FBQ1IsU0FBU08sTUFBTTtJQUNqQyxJQUFJLENBQUNILEtBQUtLLFVBQVUsQ0FBQyxNQUFNTCxPQUFRLE1BQUdBO0lBQ3RDLE9BQU9BO0FBQ1QiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNTkzNCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvY29tcG9uZW50cy9lcnJvcnMvZ3JhY2VmdWwtZGVncmFkZS1ib3VuZGFyeS50c3giXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbmltcG9ydCB7IENvbXBvbmVudCwgY3JlYXRlUmVmLCB0eXBlIFJlYWN0Tm9kZSB9IGZyb20gJ3JlYWN0J1xuXG5pbnRlcmZhY2UgRXJyb3JCb3VuZGFyeVByb3BzIHtcbiAgY2hpbGRyZW46IFJlYWN0Tm9kZVxufVxuXG5pbnRlcmZhY2UgRXJyb3JCb3VuZGFyeVN0YXRlIHtcbiAgaGFzRXJyb3I6IGJvb2xlYW5cbn1cblxuZnVuY3Rpb24gZ2V0RG9tTm9kZUF0dHJpYnV0ZXMobm9kZTogSFRNTEVsZW1lbnQpOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHtcbiAgY29uc3QgcmVzdWx0OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge31cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBhdHRyID0gbm9kZS5hdHRyaWJ1dGVzW2ldXG4gICAgcmVzdWx0W2F0dHIubmFtZV0gPSBhdHRyLnZhbHVlXG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5leHBvcnQgY2xhc3MgR3JhY2VmdWxEZWdyYWRlQm91bmRhcnkgZXh0ZW5kcyBDb21wb25lbnQ8XG4gIEVycm9yQm91bmRhcnlQcm9wcyxcbiAgRXJyb3JCb3VuZGFyeVN0YXRlXG4+IHtcbiAgcHJpdmF0ZSByb290SHRtbDogc3RyaW5nXG4gIHByaXZhdGUgaHRtbEF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cbiAgcHJpdmF0ZSBodG1sUmVmOiBSZWFjdC5SZWZPYmplY3Q8SFRNTEh0bWxFbGVtZW50IHwgbnVsbD5cblxuICBjb25zdHJ1Y3Rvcihwcm9wczogRXJyb3JCb3VuZGFyeVByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpXG4gICAgdGhpcy5zdGF0ZSA9IHsgaGFzRXJyb3I6IGZhbHNlIH1cbiAgICB0aGlzLnJvb3RIdG1sID0gJydcbiAgICB0aGlzLmh0bWxBdHRyaWJ1dGVzID0ge31cbiAgICB0aGlzLmh0bWxSZWYgPSBjcmVhdGVSZWY8SFRNTEh0bWxFbGVtZW50PigpXG4gIH1cblxuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKF86IHVua25vd24pOiBFcnJvckJvdW5kYXJ5U3RhdGUge1xuICAgIHJldHVybiB7IGhhc0Vycm9yOiB0cnVlIH1cbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGNvbnN0IGh0bWxOb2RlID0gdGhpcy5odG1sUmVmLmN1cnJlbnRcbiAgICBpZiAodGhpcy5zdGF0ZS5oYXNFcnJvciAmJiBodG1sTm9kZSkge1xuICAgICAgLy8gUmVhcHBseSB0aGUgY2FjaGVkIEhUTUwgYXR0cmlidXRlcyB0byB0aGUgcm9vdCBlbGVtZW50XG4gICAgICBPYmplY3QuZW50cmllcyh0aGlzLmh0bWxBdHRyaWJ1dGVzKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgaHRtbE5vZGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGhhc0Vycm9yIH0gPSB0aGlzLnN0YXRlXG4gICAgLy8gQ2FjaGUgdGhlIHJvb3QgSFRNTCBjb250ZW50IG9uIHRoZSBmaXJzdCByZW5kZXJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgIXRoaXMucm9vdEh0bWwpIHtcbiAgICAgIHRoaXMucm9vdEh0bWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuaW5uZXJIVE1MXG4gICAgICB0aGlzLmh0bWxBdHRyaWJ1dGVzID0gZ2V0RG9tTm9kZUF0dHJpYnV0ZXMoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KVxuICAgIH1cblxuICAgIGlmIChoYXNFcnJvcikge1xuICAgICAgLy8gUmVuZGVyIHRoZSBjdXJyZW50IEhUTUwgY29udGVudCB3aXRob3V0IGh5ZHJhdGlvblxuICAgICAgcmV0dXJuIChcbiAgICAgICAgPGh0bWxcbiAgICAgICAgICByZWY9e3RoaXMuaHRtbFJlZn1cbiAgICAgICAgICBzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmdcbiAgICAgICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTD17e1xuICAgICAgICAgICAgX19odG1sOiB0aGlzLnJvb3RIdG1sLFxuICAgICAgICAgIH19XG4gICAgICAgIC8+XG4gICAgICApXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW5cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBHcmFjZWZ1bERlZ3JhZGVCb3VuZGFyeVxuIl0sIm5hbWVzIjpbIkdyYWNlZnVsRGVncmFkZUJvdW5kYXJ5IiwiZ2V0RG9tTm9kZUF0dHJpYnV0ZXMiLCJub2RlIiwicmVzdWx0IiwiaSIsImF0dHJpYnV0ZXMiLCJsZW5ndGgiLCJhdHRyIiwibmFtZSIsInZhbHVlIiwiQ29tcG9uZW50IiwiZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIiwiXyIsImhhc0Vycm9yIiwiY29tcG9uZW50RGlkTW91bnQiLCJodG1sTm9kZSIsImh0bWxSZWYiLCJjdXJyZW50Iiwic3RhdGUiLCJPYmplY3QiLCJlbnRyaWVzIiwiaHRtbEF0dHJpYnV0ZXMiLCJmb3JFYWNoIiwia2V5Iiwic2V0QXR0cmlidXRlIiwicmVuZGVyIiwid2luZG93Iiwicm9vdEh0bWwiLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsImlubmVySFRNTCIsImh0bWwiLCJyZWYiLCJzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmciLCJkYW5nZXJvdXNseVNldElubmVySFRNTCIsIl9faHRtbCIsInByb3BzIiwiY2hpbGRyZW4iLCJjb25zdHJ1Y3RvciIsImNyZWF0ZVJlZiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7SUFxQmFBLHVCQUF1QixFQUFBO2VBQXZCQTs7SUF1RGIsT0FBc0MsRUFBQTtlQUF0Qzs7Ozt1QkExRXFEO0FBVXJELFNBQVNDLHFCQUFxQkMsSUFBaUI7SUFDN0MsTUFBTUMsU0FBaUMsQ0FBQztJQUN4QyxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUYsS0FBS0csVUFBVSxDQUFDQyxNQUFNLEVBQUVGLElBQUs7UUFDL0MsTUFBTUcsT0FBT0wsS0FBS0csVUFBVSxDQUFDRCxFQUFFO1FBQy9CRCxNQUFNLENBQUNJLEtBQUtDLElBQUksQ0FBQyxHQUFHRCxLQUFLRSxLQUFLO0lBQ2hDO0lBQ0EsT0FBT047QUFDVDtBQUVPLE1BQU1ILGdDQUFnQ1UsT0FBQUEsU0FBUztJQWdCcEQsT0FBT0MseUJBQXlCQyxDQUFVLEVBQXNCO1FBQzlELE9BQU87WUFBRUMsVUFBVTtRQUFLO0lBQzFCO0lBRUFDLG9CQUFvQjtRQUNsQixNQUFNQyxXQUFXLElBQUksQ0FBQ0MsT0FBTyxDQUFDQyxPQUFPO1FBQ3JDLElBQUksSUFBSSxDQUFDQyxLQUFLLENBQUNMLFFBQVEsSUFBSUUsVUFBVTtZQUNuQyx5REFBeUQ7WUFDekRJLE9BQU9DLE9BQU8sQ0FBQyxJQUFJLENBQUNDLGNBQWMsRUFBRUMsT0FBTyxDQUFDLENBQUE7b0JBQUMsQ0FBQ0MsS0FBS2QsTUFBTSxHQUFBO2dCQUN2RE0sU0FBU1MsWUFBWSxDQUFDRCxLQUFLZDtZQUM3QjtRQUNGO0lBQ0Y7SUFFQWdCLFNBQVM7UUFDUCxNQUFNLEVBQUVaLFFBQVEsRUFBRSxHQUFHLElBQUksQ0FBQ0ssS0FBSztRQUMvQixrREFBa0Q7UUFDbEQsSUFBSSxPQUFPUSxTQUFXLGVBQWUsQ0FBQyxJQUFJLENBQUNDLFFBQVEsRUFBRTs7UUFLckQsSUFBSWQsVUFBVTtZQUNaLG9EQUFvRDtZQUNwRCxPQUFBLFdBQUEsR0FDRSxDQUFBLEdBQUEsWUFBQSxHQUFBLEVBQUNrQixRQUFBQTtnQkFDQ0MsS0FBSyxJQUFJLENBQUNoQixPQUFPO2dCQUNqQmlCLHdCQUF3QixFQUFBO2dCQUN4QkMseUJBQXlCO29CQUN2QkMsUUFBUSxJQUFJLENBQUNSLFFBQVE7Z0JBQ3ZCOztRQUdOO1FBRUEsT0FBTyxJQUFJLENBQUNTLEtBQUssQ0FBQ0MsUUFBUTtJQUM1QjtJQTVDQUMsWUFBWUYsS0FBeUIsQ0FBRTtRQUNyQyxLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDbEIsS0FBSyxHQUFHO1lBQUVMLFVBQVU7UUFBTTtRQUMvQixJQUFJLENBQUNjLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNOLGNBQWMsR0FBRyxDQUFDO1FBQ3ZCLElBQUksQ0FBQ0wsT0FBTyxHQUFBLFdBQUEsR0FBR3VCLENBQUFBLEdBQUFBLE9BQUFBLFNBQVM7SUFDMUI7QUF1Q0Y7TUFFQSxXQUFldkMiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNjAyMSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvc3RyaXAtYW5zaS9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIoKCk9PntcInVzZSBzdHJpY3RcIjt2YXIgZT17NTExOmU9PntlLmV4cG9ydHM9KHtvbmx5Rmlyc3Q6ZT1mYWxzZX09e30pPT57Y29uc3Qgcj1bXCJbXFxcXHUwMDFCXFxcXHUwMDlCXVtbXFxcXF0oKSM7P10qKD86KD86KD86KD86O1stYS16QS1aXFxcXGRcXFxcLyMmLjo9PyVAfl9dKykqfFthLXpBLVpcXFxcZF0rKD86O1stYS16QS1aXFxcXGRcXFxcLyMmLjo9PyVAfl9dKikqKT9cXFxcdTAwMDcpXCIsXCIoPzooPzpcXFxcZHsxLDR9KD86O1xcXFxkezAsNH0pKik/W1xcXFxkQS1QUi1UWmNmLW50cXJ5PT48fl0pKVwiXS5qb2luKFwifFwiKTtyZXR1cm4gbmV3IFJlZ0V4cChyLGU/dW5kZWZpbmVkOlwiZ1wiKX19LDUzMjooZSxyLF8pPT57Y29uc3QgdD1fKDUxMSk7ZS5leHBvcnRzPWU9PnR5cGVvZiBlPT09XCJzdHJpbmdcIj9lLnJlcGxhY2UodCgpLFwiXCIpOmV9fTt2YXIgcj17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKF8pe3ZhciB0PXJbX107aWYodCE9PXVuZGVmaW5lZCl7cmV0dXJuIHQuZXhwb3J0c312YXIgYT1yW19dPXtleHBvcnRzOnt9fTt2YXIgbj10cnVlO3RyeXtlW19dKGEsYS5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO249ZmFsc2V9ZmluYWxseXtpZihuKWRlbGV0ZSByW19dfXJldHVybiBhLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciBfPV9fbmNjd3Bja19yZXF1aXJlX18oNTMyKTttb2R1bGUuZXhwb3J0cz1ffSkoKTsiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsQ0FBQztJQUFLO0lBQWEsSUFBSSxJQUFFO1FBQUMsS0FBSSxDQUFBO1lBQUksRUFBRSxPQUFPLEdBQUMsQ0FBQyxFQUFDLFdBQVUsSUFBRSxLQUFLLEVBQUMsR0FBQyxDQUFDLENBQUM7Z0JBQUksTUFBTSxJQUFFO29CQUFDO29CQUErSDtpQkFBMkQsQ0FBQyxJQUFJLENBQUM7Z0JBQUssT0FBTyxJQUFJLE9BQU8sR0FBRSxJQUFFLFlBQVU7WUFBSTtRQUFDO1FBQUUsS0FBSSxDQUFDLEdBQUUsR0FBRTtZQUFLLE1BQU0sSUFBRSxFQUFFO1lBQUssRUFBRSxPQUFPLEdBQUMsQ0FBQSxJQUFHLE9BQU8sTUFBSSxXQUFTLEVBQUUsT0FBTyxDQUFDLEtBQUksTUFBSTtRQUFDO0lBQUM7SUFBRSxJQUFJLElBQUUsQ0FBQztJQUFFLFNBQVMsb0JBQW9CLENBQUM7UUFBRSxJQUFJLElBQUUsQ0FBQyxDQUFDLEVBQUU7UUFBQyxJQUFHLE1BQUksV0FBVTtZQUFDLE9BQU8sRUFBRSxPQUFPO1FBQUE7UUFBQyxJQUFJLElBQUUsQ0FBQyxDQUFDLEVBQUUsR0FBQztZQUFDLFNBQVEsQ0FBQztRQUFDO1FBQUUsSUFBSSxJQUFFO1FBQUssSUFBRztZQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRSxFQUFFLE9BQU8sRUFBQztZQUFxQixJQUFFO1FBQUssU0FBUTtZQUFDLElBQUcsR0FBRSxPQUFPLENBQUMsQ0FBQyxFQUFFO1FBQUE7UUFBQyxPQUFPLEVBQUUsT0FBTztJQUFBO0lBQUMsSUFBRyxPQUFPLHdCQUFzQixhQUFZLG9CQUFvQixFQUFFLEdBQUMsdUZBQVU7SUFBSSxJQUFJLElBQUUsb0JBQW9CO0lBQUssT0FBTyxPQUFPLEdBQUM7QUFBQyxDQUFDIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDYwNjYsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvc2hhcmVkL2xpYi9mb3JtYXQtd2VicGFjay1tZXNzYWdlcy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbk1JVCBMaWNlbnNlXG5cbkNvcHlyaWdodCAoYykgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuU09GVFdBUkUuXG4qL1xuaW1wb3J0IHN0cmlwQW5zaSBmcm9tICduZXh0L2Rpc3QvY29tcGlsZWQvc3RyaXAtYW5zaSdcbi8vIFRoaXMgZmlsZSBpcyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svY3JlYXRlLXJlYWN0LWFwcC9ibG9iLzdiMWEzMmJlNmVjOWY5OWE2YzlhM2M2NjgxM2YzYWMwOWM0NzM2YjkvcGFja2FnZXMvcmVhY3QtZGV2LXV0aWxzL2Zvcm1hdFdlYnBhY2tNZXNzYWdlcy5qc1xuLy8gSXQncyBiZWVuIGVkaXRlZCB0byByZW1vdmUgY2hhbGsgYW5kIENSQS1zcGVjaWZpYyBsb2dpY1xuXG5jb25zdCBmcmllbmRseVN5bnRheEVycm9yTGFiZWwgPSAnU3ludGF4IGVycm9yOidcblxuY29uc3QgV0VCUEFDS19CUkVBS0lOR19DSEFOR0VfUE9MWUZJTExTID1cbiAgJ1xcblxcbkJSRUFLSU5HIENIQU5HRTogd2VicGFjayA8IDUgdXNlZCB0byBpbmNsdWRlIHBvbHlmaWxscyBmb3Igbm9kZS5qcyBjb3JlIG1vZHVsZXMgYnkgZGVmYXVsdC4nXG5cbmZ1bmN0aW9uIGlzTGlrZWx5QVN5bnRheEVycm9yKG1lc3NhZ2U6IHN0cmluZykge1xuICByZXR1cm4gc3RyaXBBbnNpKG1lc3NhZ2UpLmluY2x1ZGVzKGZyaWVuZGx5U3ludGF4RXJyb3JMYWJlbClcbn1cblxubGV0IGhhZE1pc3NpbmdTYXNzRXJyb3IgPSBmYWxzZVxuXG4vLyBDbGVhbnMgdXAgd2VicGFjayBlcnJvciBtZXNzYWdlcy5cbmZ1bmN0aW9uIGZvcm1hdE1lc3NhZ2UoXG4gIG1lc3NhZ2U6IGFueSxcbiAgdmVyYm9zZT86IGJvb2xlYW4sXG4gIGltcG9ydFRyYWNlTm90ZT86IGJvb2xlYW5cbikge1xuICAvLyBUT0RPOiBSZXBsYWNlIHRoaXMgb25jZSB3ZWJwYWNrIDUgaXMgc3RhYmxlXG4gIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ29iamVjdCcgJiYgbWVzc2FnZS5tZXNzYWdlKSB7XG4gICAgY29uc3QgZmlsdGVyZWRNb2R1bGVUcmFjZSA9XG4gICAgICBtZXNzYWdlLm1vZHVsZVRyYWNlICYmXG4gICAgICBtZXNzYWdlLm1vZHVsZVRyYWNlLmZpbHRlcihcbiAgICAgICAgKHRyYWNlOiBhbnkpID0+XG4gICAgICAgICAgIS9uZXh0LShtaWRkbGV3YXJlfGNsaWVudC1wYWdlc3xyb3V0ZXxlZGdlLWZ1bmN0aW9uKS1sb2FkZXJcXC5qcy8udGVzdChcbiAgICAgICAgICAgIHRyYWNlLm9yaWdpbk5hbWVcbiAgICAgICAgICApXG4gICAgICApXG5cbiAgICBsZXQgYm9keSA9IG1lc3NhZ2UubWVzc2FnZVxuICAgIGNvbnN0IGJyZWFraW5nQ2hhbmdlSW5kZXggPSBib2R5LmluZGV4T2YoV0VCUEFDS19CUkVBS0lOR19DSEFOR0VfUE9MWUZJTExTKVxuICAgIGlmIChicmVha2luZ0NoYW5nZUluZGV4ID49IDApIHtcbiAgICAgIGJvZHkgPSBib2R5LnNsaWNlKDAsIGJyZWFraW5nQ2hhbmdlSW5kZXgpXG4gICAgfVxuXG4gICAgbWVzc2FnZSA9XG4gICAgICAobWVzc2FnZS5tb2R1bGVOYW1lID8gc3RyaXBBbnNpKG1lc3NhZ2UubW9kdWxlTmFtZSkgKyAnXFxuJyA6ICcnKSArXG4gICAgICAobWVzc2FnZS5maWxlID8gc3RyaXBBbnNpKG1lc3NhZ2UuZmlsZSkgKyAnXFxuJyA6ICcnKSArXG4gICAgICBib2R5ICtcbiAgICAgIChtZXNzYWdlLmRldGFpbHMgJiYgdmVyYm9zZSA/ICdcXG4nICsgbWVzc2FnZS5kZXRhaWxzIDogJycpICtcbiAgICAgIChmaWx0ZXJlZE1vZHVsZVRyYWNlICYmIGZpbHRlcmVkTW9kdWxlVHJhY2UubGVuZ3RoXG4gICAgICAgID8gKGltcG9ydFRyYWNlTm90ZSB8fCAnXFxuXFxuSW1wb3J0IHRyYWNlIGZvciByZXF1ZXN0ZWQgbW9kdWxlOicpICtcbiAgICAgICAgICBmaWx0ZXJlZE1vZHVsZVRyYWNlXG4gICAgICAgICAgICAubWFwKCh0cmFjZTogYW55KSA9PiBgXFxuJHt0cmFjZS5tb2R1bGVOYW1lfWApXG4gICAgICAgICAgICAuam9pbignJylcbiAgICAgICAgOiAnJykgK1xuICAgICAgKG1lc3NhZ2Uuc3RhY2sgJiYgdmVyYm9zZSA/ICdcXG4nICsgbWVzc2FnZS5zdGFjayA6ICcnKVxuICB9XG4gIGxldCBsaW5lcyA9IG1lc3NhZ2Uuc3BsaXQoJ1xcbicpXG5cbiAgLy8gU3RyaXAgV2VicGFjay1hZGRlZCBoZWFkZXJzIG9mZiBlcnJvcnMvd2FybmluZ3NcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2svd2VicGFjay9ibG9iL21hc3Rlci9saWIvTW9kdWxlRXJyb3IuanNcbiAgbGluZXMgPSBsaW5lcy5maWx0ZXIoKGxpbmU6IHN0cmluZykgPT4gIS9Nb2R1bGUgW0EteiBdK1xcKGZyb20vLnRlc3QobGluZSkpXG5cbiAgLy8gVHJhbnNmb3JtIHBhcnNpbmcgZXJyb3IgaW50byBzeW50YXggZXJyb3JcbiAgLy8gVE9ETzogbW92ZSB0aGlzIHRvIG91ciBFU0xpbnQgZm9ybWF0dGVyP1xuICBsaW5lcyA9IGxpbmVzLm1hcCgobGluZTogc3RyaW5nKSA9PiB7XG4gICAgY29uc3QgcGFyc2luZ0Vycm9yID0gL0xpbmUgKFxcZCspOig/OihcXGQrKTopP1xccypQYXJzaW5nIGVycm9yOiAoLispJC8uZXhlYyhcbiAgICAgIGxpbmVcbiAgICApXG4gICAgaWYgKCFwYXJzaW5nRXJyb3IpIHtcbiAgICAgIHJldHVybiBsaW5lXG4gICAgfVxuICAgIGNvbnN0IFssIGVycm9yTGluZSwgZXJyb3JDb2x1bW4sIGVycm9yTWVzc2FnZV0gPSBwYXJzaW5nRXJyb3JcbiAgICByZXR1cm4gYCR7ZnJpZW5kbHlTeW50YXhFcnJvckxhYmVsfSAke2Vycm9yTWVzc2FnZX0gKCR7ZXJyb3JMaW5lfToke2Vycm9yQ29sdW1ufSlgXG4gIH0pXG5cbiAgbWVzc2FnZSA9IGxpbmVzLmpvaW4oJ1xcbicpXG4gIC8vIFNtb29zaCBzeW50YXggZXJyb3JzIChjb21tb25seSBmb3VuZCBpbiBDU1MpXG4gIG1lc3NhZ2UgPSBtZXNzYWdlLnJlcGxhY2UoXG4gICAgL1N5bnRheEVycm9yXFxzK1xcKChcXGQrKTooXFxkKylcXClcXHMqKC4rPylcXG4vZyxcbiAgICBgJHtmcmllbmRseVN5bnRheEVycm9yTGFiZWx9ICQzICgkMTokMilcXG5gXG4gIClcbiAgLy8gQ2xlYW4gdXAgZXhwb3J0IGVycm9yc1xuICBtZXNzYWdlID0gbWVzc2FnZS5yZXBsYWNlKFxuICAgIC9eLipleHBvcnQgJyguKz8pJyB3YXMgbm90IGZvdW5kIGluICcoLis/KScuKiQvZ20sXG4gICAgYEF0dGVtcHRlZCBpbXBvcnQgZXJyb3I6ICckMScgaXMgbm90IGV4cG9ydGVkIGZyb20gJyQyJy5gXG4gIClcbiAgbWVzc2FnZSA9IG1lc3NhZ2UucmVwbGFjZShcbiAgICAvXi4qZXhwb3J0ICdkZWZhdWx0JyBcXChpbXBvcnRlZCBhcyAnKC4rPyknXFwpIHdhcyBub3QgZm91bmQgaW4gJyguKz8pJy4qJC9nbSxcbiAgICBgQXR0ZW1wdGVkIGltcG9ydCBlcnJvcjogJyQyJyBkb2VzIG5vdCBjb250YWluIGEgZGVmYXVsdCBleHBvcnQgKGltcG9ydGVkIGFzICckMScpLmBcbiAgKVxuICBtZXNzYWdlID0gbWVzc2FnZS5yZXBsYWNlKFxuICAgIC9eLipleHBvcnQgJyguKz8pJyBcXChpbXBvcnRlZCBhcyAnKC4rPyknXFwpIHdhcyBub3QgZm91bmQgaW4gJyguKz8pJy4qJC9nbSxcbiAgICBgQXR0ZW1wdGVkIGltcG9ydCBlcnJvcjogJyQxJyBpcyBub3QgZXhwb3J0ZWQgZnJvbSAnJDMnIChpbXBvcnRlZCBhcyAnJDInKS5gXG4gIClcbiAgbGluZXMgPSBtZXNzYWdlLnNwbGl0KCdcXG4nKVxuXG4gIC8vIFJlbW92ZSBsZWFkaW5nIG5ld2xpbmVcbiAgaWYgKGxpbmVzLmxlbmd0aCA+IDIgJiYgbGluZXNbMV0udHJpbSgpID09PSAnJykge1xuICAgIGxpbmVzLnNwbGljZSgxLCAxKVxuICB9XG5cbiAgLy8gQ2xlYW5zIHVwIHZlcmJvc2UgXCJtb2R1bGUgbm90IGZvdW5kXCIgbWVzc2FnZXMgZm9yIGZpbGVzIGFuZCBwYWNrYWdlcy5cbiAgaWYgKGxpbmVzWzFdICYmIGxpbmVzWzFdLnN0YXJ0c1dpdGgoJ01vZHVsZSBub3QgZm91bmQ6ICcpKSB7XG4gICAgbGluZXMgPSBbXG4gICAgICBsaW5lc1swXSxcbiAgICAgIGxpbmVzWzFdXG4gICAgICAgIC5yZXBsYWNlKCdFcnJvcjogJywgJycpXG4gICAgICAgIC5yZXBsYWNlKCdNb2R1bGUgbm90IGZvdW5kOiBDYW5ub3QgZmluZCBmaWxlOicsICdDYW5ub3QgZmluZCBmaWxlOicpLFxuICAgICAgLi4ubGluZXMuc2xpY2UoMiksXG4gICAgXVxuICB9XG5cbiAgLy8gQWRkIGhlbHBmdWwgbWVzc2FnZSBmb3IgdXNlcnMgdHJ5aW5nIHRvIHVzZSBTYXNzIGZvciB0aGUgZmlyc3QgdGltZVxuICBpZiAobGluZXNbMV0gJiYgbGluZXNbMV0ubWF0Y2goL0Nhbm5vdCBmaW5kIG1vZHVsZS4rc2Fzcy8pKSB7XG4gICAgLy8gLi9maWxlLm1vZHVsZS5zY3NzICg8PGxvYWRlciBpbmZvPj4pID0+IC4vZmlsZS5tb2R1bGUuc2Nzc1xuICAgIGNvbnN0IGZpcnN0TGluZSA9IGxpbmVzWzBdLnNwbGl0KCchJylcbiAgICBsaW5lc1swXSA9IGZpcnN0TGluZVtmaXJzdExpbmUubGVuZ3RoIC0gMV1cblxuICAgIGxpbmVzWzFdID1cbiAgICAgIFwiVG8gdXNlIE5leHQuanMnIGJ1aWx0LWluIFNhc3Mgc3VwcG9ydCwgeW91IGZpcnN0IG5lZWQgdG8gaW5zdGFsbCBgc2Fzc2AuXFxuXCJcbiAgICBsaW5lc1sxXSArPSAnUnVuIGBucG0gaSBzYXNzYCBvciBgeWFybiBhZGQgc2Fzc2AgaW5zaWRlIHlvdXIgd29ya3NwYWNlLlxcbidcbiAgICBsaW5lc1sxXSArPSAnXFxuTGVhcm4gbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvaW5zdGFsbC1zYXNzJ1xuXG4gICAgLy8gZGlzcG9zZSBvZiB1bmhlbHBmdWwgc3RhY2sgdHJhY2VcbiAgICBsaW5lcyA9IGxpbmVzLnNsaWNlKDAsIDIpXG4gICAgaGFkTWlzc2luZ1Nhc3NFcnJvciA9IHRydWVcbiAgfSBlbHNlIGlmIChcbiAgICBoYWRNaXNzaW5nU2Fzc0Vycm9yICYmXG4gICAgbWVzc2FnZS5tYXRjaCgvKHNhc3MtbG9hZGVyfHJlc29sdmUtdXJsLWxvYWRlcjogQ1NTIGVycm9yKS8pXG4gICkge1xuICAgIC8vIGRpc3Bvc2Ugb2YgdW5oZWxwZnVsIHN0YWNrIHRyYWNlIGZvbGxvd2luZyBtaXNzaW5nIHNhc3MgbW9kdWxlXG4gICAgbGluZXMgPSBbXVxuICB9XG5cbiAgaWYgKCF2ZXJib3NlKSB7XG4gICAgbWVzc2FnZSA9IGxpbmVzLmpvaW4oJ1xcbicpXG4gICAgLy8gSW50ZXJuYWwgc3RhY2tzIGFyZSBnZW5lcmFsbHkgdXNlbGVzcyBzbyB3ZSBzdHJpcCB0aGVtLi4uIHdpdGggdGhlXG4gICAgLy8gZXhjZXB0aW9uIG9mIHN0YWNrcyBjb250YWluaW5nIGB3ZWJwYWNrOmAgYmVjYXVzZSB0aGV5J3JlIG5vcm1hbGx5XG4gICAgLy8gZnJvbSB1c2VyIGNvZGUgZ2VuZXJhdGVkIGJ5IFdlYnBhY2suIEZvciBtb3JlIGluZm9ybWF0aW9uIHNlZVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9jcmVhdGUtcmVhY3QtYXBwL3B1bGwvMTA1MFxuICAgIG1lc3NhZ2UgPSBtZXNzYWdlLnJlcGxhY2UoXG4gICAgICAvXlxccyphdFxccygoPyF3ZWJwYWNrOikuKSo6XFxkKzpcXGQrW1xccyldKihcXG58JCkvZ20sXG4gICAgICAnJ1xuICAgICkgLy8gYXQgLi4uIC4uLjp4OnlcbiAgICBtZXNzYWdlID0gbWVzc2FnZS5yZXBsYWNlKC9eXFxzKmF0XFxzPGFub255bW91cz4oXFxufCQpL2dtLCAnJykgLy8gYXQgPGFub255bW91cz5cblxuICAgIG1lc3NhZ2UgPSBtZXNzYWdlLnJlcGxhY2UoXG4gICAgICAvRmlsZSB3YXMgcHJvY2Vzc2VkIHdpdGggdGhlc2UgbG9hZGVyczpcXG4oLitbXFxcXC9dKG5leHRbXFxcXC9dZGlzdFtcXFxcL10uK3xAbmV4dFtcXFxcL11yZWFjdC1yZWZyZXNoLXV0aWxzW1xcXFwvXWxvYWRlcilcXC5qc1xcbikqWW91IG1heSBuZWVkIGFuIGFkZGl0aW9uYWwgbG9hZGVyIHRvIGhhbmRsZSB0aGUgcmVzdWx0IG9mIHRoZXNlIGxvYWRlcnMuXFxuL2csXG4gICAgICAnJ1xuICAgIClcblxuICAgIGxpbmVzID0gbWVzc2FnZS5zcGxpdCgnXFxuJylcbiAgfVxuXG4gIC8vIFJlbW92ZSBkdXBsaWNhdGVkIG5ld2xpbmVzXG4gIGxpbmVzID0gKGxpbmVzIGFzIHN0cmluZ1tdKS5maWx0ZXIoXG4gICAgKGxpbmUsIGluZGV4LCBhcnIpID0+XG4gICAgICBpbmRleCA9PT0gMCB8fCBsaW5lLnRyaW0oKSAhPT0gJycgfHwgbGluZS50cmltKCkgIT09IGFycltpbmRleCAtIDFdLnRyaW0oKVxuICApXG5cbiAgLy8gUmVhc3NlbWJsZSB0aGUgbWVzc2FnZVxuICBtZXNzYWdlID0gbGluZXMuam9pbignXFxuJylcbiAgcmV0dXJuIG1lc3NhZ2UudHJpbSgpXG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZvcm1hdFdlYnBhY2tNZXNzYWdlcyhqc29uOiBhbnksIHZlcmJvc2U/OiBib29sZWFuKSB7XG4gIGNvbnN0IGZvcm1hdHRlZEVycm9ycyA9IGpzb24uZXJyb3JzLm1hcCgobWVzc2FnZTogYW55KSA9PiB7XG4gICAgY29uc3QgaXNVbmtub3duTmV4dEZvbnRFcnJvciA9IG1lc3NhZ2UubWVzc2FnZS5pbmNsdWRlcyhcbiAgICAgICdBbiBlcnJvciBvY2N1cnJlZCBpbiBgbmV4dC9mb250YC4nXG4gICAgKVxuICAgIHJldHVybiBmb3JtYXRNZXNzYWdlKG1lc3NhZ2UsIGlzVW5rbm93bk5leHRGb250RXJyb3IgfHwgdmVyYm9zZSlcbiAgfSlcbiAgY29uc3QgZm9ybWF0dGVkV2FybmluZ3MgPSBqc29uLndhcm5pbmdzLm1hcCgobWVzc2FnZTogYW55KSA9PiB7XG4gICAgcmV0dXJuIGZvcm1hdE1lc3NhZ2UobWVzc2FnZSwgdmVyYm9zZSlcbiAgfSlcblxuICAvLyBSZW9yZGVyIGVycm9ycyB0byBwdXQgdGhlIG1vc3QgcmVsZXZhbnQgb25lcyBmaXJzdC5cbiAgbGV0IHJlYWN0U2VydmVyQ29tcG9uZW50c0Vycm9yID0gLTFcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGZvcm1hdHRlZEVycm9ycy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGVycm9yID0gZm9ybWF0dGVkRXJyb3JzW2ldXG4gICAgaWYgKGVycm9yLmluY2x1ZGVzKCdSZWFjdFNlcnZlckNvbXBvbmVudHNFcnJvcicpKSB7XG4gICAgICByZWFjdFNlcnZlckNvbXBvbmVudHNFcnJvciA9IGlcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgLy8gTW92ZSB0aGUgcmVhY3RTZXJ2ZXJDb21wb25lbnRzRXJyb3IgdG8gdGhlIHRvcCBpZiBpdCBleGlzdHNcbiAgaWYgKHJlYWN0U2VydmVyQ29tcG9uZW50c0Vycm9yICE9PSAtMSkge1xuICAgIGNvbnN0IGVycm9yID0gZm9ybWF0dGVkRXJyb3JzLnNwbGljZShyZWFjdFNlcnZlckNvbXBvbmVudHNFcnJvciwgMSlcbiAgICBmb3JtYXR0ZWRFcnJvcnMudW5zaGlmdChlcnJvclswXSlcbiAgfVxuXG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAuLi5qc29uLFxuICAgIGVycm9yczogZm9ybWF0dGVkRXJyb3JzLFxuICAgIHdhcm5pbmdzOiBmb3JtYXR0ZWRXYXJuaW5ncyxcbiAgfVxuICBpZiAoIXZlcmJvc2UgJiYgcmVzdWx0LmVycm9ycy5zb21lKGlzTGlrZWx5QVN5bnRheEVycm9yKSkge1xuICAgIC8vIElmIHRoZXJlIGFyZSBhbnkgc3ludGF4IGVycm9ycywgc2hvdyBqdXN0IHRoZW0uXG4gICAgcmVzdWx0LmVycm9ycyA9IHJlc3VsdC5lcnJvcnMuZmlsdGVyKGlzTGlrZWx5QVN5bnRheEVycm9yKVxuICAgIHJlc3VsdC53YXJuaW5ncyA9IFtdXG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuIl0sIm5hbWVzIjpbImZvcm1hdFdlYnBhY2tNZXNzYWdlcyIsImZyaWVuZGx5U3ludGF4RXJyb3JMYWJlbCIsIldFQlBBQ0tfQlJFQUtJTkdfQ0hBTkdFX1BPTFlGSUxMUyIsImlzTGlrZWx5QVN5bnRheEVycm9yIiwibWVzc2FnZSIsInN0cmlwQW5zaSIsImluY2x1ZGVzIiwiaGFkTWlzc2luZ1Nhc3NFcnJvciIsImZvcm1hdE1lc3NhZ2UiLCJ2ZXJib3NlIiwiaW1wb3J0VHJhY2VOb3RlIiwiZmlsdGVyZWRNb2R1bGVUcmFjZSIsIm1vZHVsZVRyYWNlIiwiZmlsdGVyIiwidHJhY2UiLCJ0ZXN0Iiwib3JpZ2luTmFtZSIsImJvZHkiLCJicmVha2luZ0NoYW5nZUluZGV4IiwiaW5kZXhPZiIsInNsaWNlIiwibW9kdWxlTmFtZSIsImZpbGUiLCJkZXRhaWxzIiwibGVuZ3RoIiwibWFwIiwiam9pbiIsInN0YWNrIiwibGluZXMiLCJzcGxpdCIsImxpbmUiLCJwYXJzaW5nRXJyb3IiLCJleGVjIiwiZXJyb3JMaW5lIiwiZXJyb3JDb2x1bW4iLCJlcnJvck1lc3NhZ2UiLCJyZXBsYWNlIiwidHJpbSIsInNwbGljZSIsInN0YXJ0c1dpdGgiLCJtYXRjaCIsImZpcnN0TGluZSIsImluZGV4IiwiYXJyIiwianNvbiIsImZvcm1hdHRlZEVycm9ycyIsImVycm9ycyIsImlzVW5rbm93bk5leHRGb250RXJyb3IiLCJmb3JtYXR0ZWRXYXJuaW5ncyIsIndhcm5pbmdzIiwicmVhY3RTZXJ2ZXJDb21wb25lbnRzRXJyb3IiLCJpIiwiZXJyb3IiLCJ1bnNoaWZ0IiwicmVzdWx0Iiwic29tZSJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQkE7OzsrQkFpS0EsV0FBQTs7O2VBQXdCQTs7OztvRUFoS0Y7QUFDdEIscUtBQXFLO0FBQ3JLLDBEQUEwRDtBQUUxRCxNQUFNQywyQkFBMkI7QUFFakMsTUFBTUMsb0NBQ0o7QUFFRixTQUFTQyxxQkFBcUJDLE9BQWU7SUFDM0MsT0FBT0MsQ0FBQUEsR0FBQUEsV0FBQUEsT0FBUyxFQUFDRCxTQUFTRSxRQUFRLENBQUNMO0FBQ3JDO0FBRUEsSUFBSU0sc0JBQXNCO0FBRTFCLG9DQUFvQztBQUNwQyxTQUFTQyxjQUNQSixPQUFZLEVBQ1pLLE9BQWlCLEVBQ2pCQyxlQUF5QjtJQUV6Qiw4Q0FBOEM7SUFDOUMsSUFBSSxPQUFPTixZQUFZLFlBQVlBLFFBQVFBLE9BQU8sRUFBRTtRQUNsRCxN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QUFPLENBQUNFLFFBQVEsQ0FDckQ7UUFFRixPQUFPRSxjQUFjSixTQUFTMkMsMEJBQTBCdEM7SUFDMUQ7SUFDQSxNQUFNdUMsb0JBQW9CSixLQUFLSyxRQUFRLENBQUN4QixHQUFHLENBQUMsQ0FBQ3JCO1FBQzNDLE9BQU9JLGNBQWNKLFNBQVNLO0lBQ2hDO0lBRUEsc0RBQXNEO0lBQ3RELElBQUl5Qyw2QkFBNkIsQ0FBQztJQUVsQyxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSU4sZ0JBQWdCckIsTUFBTSxFQUFFMkIsSUFBSztRQUMvQyxNQUFNQyxRQUFRUCxlQUFlLENBQUNNLEVBQUU7UUFDaEMsSUFBSUMsTUFBTTlDLFFBQVEsQ0FBQywrQkFBK0I7WUFDaEQ0Qyw2QkFBNkJDO1lBQzdCO1FBQ0Y7SUFDRjtJQUVBLDhEQUE4RDtJQUM5RCxJQUFJRCwrQkFBK0IsQ0FBQyxHQUFHO1FBQ3JDLE1BQU1FLFFBQVFQLGdCQUFnQlAsTUFBTSxDQUFDWSw0QkFBNEI7UUFDakVMLGdCQUFnQlEsT0FBTyxDQUFDRCxLQUFLLENBQUMsRUFBRTtJQUNsQztJQUVBLE1BQU1FLFNBQVM7UUFDYixHQUFHVixJQUFJO1FBQ1BFLFFBQVFEO1FBQ1JJLFVBQVVEO0lBQ1o7SUFDQSxJQUFJLENBQUN2QyxXQUFXNkMsT0FBT1IsTUFBTSxDQUFDUyxJQUFJLENBQUNwRCx1QkFBdUI7UUFDeEQsa0RBQWtEO1FBQ2xEbUQsT0FBT1IsTUFBTSxHQUFHUSxPQUFPUixNQUFNLENBQUNqQyxNQUFNLENBQUNWO1FBQ3JDbUQsT0FBT0wsUUFBUSxHQUFHLEVBQUU7SUFDdEI7SUFDQSxPQUFPSztBQUNUIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDYyMjcsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvY2xpZW50L2Rldi9ob3QtcmVsb2FkZXIvc2hhcmVkLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgSE1SX0FDVElPTl9UWVBFUyB9IGZyb20gJy4uLy4uLy4uL3NlcnZlci9kZXYvaG90LXJlbG9hZGVyLXR5cGVzJ1xuXG5leHBvcnQgY29uc3QgUkVBQ1RfUkVGUkVTSF9GVUxMX1JFTE9BRCA9XG4gICdbRmFzdCBSZWZyZXNoXSBwZXJmb3JtaW5nIGZ1bGwgcmVsb2FkXFxuXFxuJyArXG4gIFwiRmFzdCBSZWZyZXNoIHdpbGwgcGVyZm9ybSBhIGZ1bGwgcmVsb2FkIHdoZW4geW91IGVkaXQgYSBmaWxlIHRoYXQncyBpbXBvcnRlZCBieSBtb2R1bGVzIG91dHNpZGUgb2YgdGhlIFJlYWN0IHJlbmRlcmluZyB0cmVlLlxcblwiICtcbiAgJ1lvdSBtaWdodCBoYXZlIGEgZmlsZSB3aGljaCBleHBvcnRzIGEgUmVhY3QgY29tcG9uZW50IGJ1dCBhbHNvIGV4cG9ydHMgYSB2YWx1ZSB0aGF0IGlzIGltcG9ydGVkIGJ5IGEgbm9uLVJlYWN0IGNvbXBvbmVudCBmaWxlLlxcbicgK1xuICAnQ29uc2lkZXIgbWlncmF0aW5nIHRoZSBub24tUmVhY3QgY29tcG9uZW50IGV4cG9ydCB0byBhIHNlcGFyYXRlIGZpbGUgYW5kIGltcG9ydGluZyBpdCBpbnRvIGJvdGggZmlsZXMuXFxuXFxuJyArXG4gICdJdCBpcyBhbHNvIHBvc3NpYmxlIHRoZSBwYXJlbnQgY29tcG9uZW50IG9mIHRoZSBjb21wb25lbnQgeW91IGVkaXRlZCBpcyBhIGNsYXNzIGNvbXBvbmVudCwgd2hpY2ggZGlzYWJsZXMgRmFzdCBSZWZyZXNoLlxcbicgK1xuICAnRmFzdCBSZWZyZXNoIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBwYXJlbnQgZnVuY3Rpb24gY29tcG9uZW50IGluIHlvdXIgUmVhY3QgdHJlZS4nXG5cbmV4cG9ydCBjb25zdCBSRUFDVF9SRUZSRVNIX0ZVTExfUkVMT0FEX0ZST01fRVJST1IgPVxuICAnW0Zhc3QgUmVmcmVzaF0gcGVyZm9ybWluZyBmdWxsIHJlbG9hZCBiZWNhdXNlIHlvdXIgYXBwbGljYXRpb24gaGFkIGFuIHVucmVjb3ZlcmFibGUgZXJyb3InXG5cbmV4cG9ydCBmdW5jdGlvbiByZXBvcnRJbnZhbGlkSG1yTWVzc2FnZShcbiAgbWVzc2FnZTogSE1SX0FDVElPTl9UWVBFUyB8IE1lc3NhZ2VFdmVudDx1bmtub3duPixcbiAgZXJyOiB1bmtub3duXG4pIHtcbiAgY29uc29sZS53YXJuKFxuICAgICdbSE1SXSBJbnZhbGlkIG1lc3NhZ2U6ICcgK1xuICAgICAgSlNPTi5zdHJpbmdpZnkobWVzc2FnZSkgK1xuICAgICAgJ1xcbicgK1xuICAgICAgKChlcnIgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnI/LnN0YWNrKSB8fCAnJylcbiAgKVxufVxuIl0sIm5hbWVzIjpbIlJFQUNUX1JFRlJFU0hfRlVMTF9SRUxPQUQiLCJSRUFDVF9SRUZSRVNIX0ZVTExfUkVMT0FEX0ZST01fRVJST1IiLCJyZXBvcnRJbnZhbGlkSG1yTWVzc2FnZSIsIm1lc3NhZ2UiLCJlcnIiLCJjb25zb2xlIiwid2FybiIsIkpTT04iLCJzdHJpbmdpZnkiLCJFcnJvciIsInN0YWNrIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7SUFFYUEseUJBQXlCLEVBQUE7ZUFBekJBOztJQVFBQyxvQ0FBb0MsRUFBQTtlQUFwQ0E7O0lBR0dDLHVCQUF1QixFQUFBO2VBQXZCQTs7O0FBWFQsTUFBTUYsNEJBQ1gsOENBQ0EsbUlBQ0EscUlBQ0EsK0dBQ0EsOEhBQ0E7QUFFSyxNQUFNQyx1Q0FDWDtBQUVLLFNBQVNDLHdCQUNkQyxPQUFpRCxFQUNqREMsR0FBWTtJQUVaQyxRQUFRQyxJQUFJLENBQ1YsNEJBQ0VDLEtBQUtDLFNBQVMsQ0FBQ0wsV0FDZixPQUNDLENBQUNDLGVBQWVLLFNBQUFBLENBQVNMLE9BQUFBLE9BQUFBLEtBQUFBLElBQUFBLElBQUtNLEtBQUssS0FBSyxFQUFDO0FBRWhEIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDYyNzAsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvc2hhcmVkL2xpYi9pcy1wbGFpbi1vYmplY3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGdldE9iamVjdENsYXNzTGFiZWwodmFsdWU6IGFueSk6IHN0cmluZyB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlOiBhbnkpOiBib29sZWFuIHtcbiAgaWYgKGdldE9iamVjdENsYXNzTGFiZWwodmFsdWUpICE9PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgY29uc3QgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKVxuXG4gIC8qKlxuICAgKiB0aGlzIHVzZWQgdG8gYmUgcHJldmlvdXNseTpcbiAgICpcbiAgICogYHJldHVybiBwcm90b3R5cGUgPT09IG51bGwgfHwgcHJvdG90eXBlID09PSBPYmplY3QucHJvdG90eXBlYFxuICAgKlxuICAgKiBidXQgRWRnZSBSdW50aW1lIGV4cG9zZSBPYmplY3QgZnJvbSB2bSwgYmVpbmcgdGhhdCBraW5kIG9mIHR5cGUtY2hlY2tpbmcgd3JvbmdseSBmYWlsLlxuICAgKlxuICAgKiBJdCB3YXMgY2hhbmdlZCB0byB0aGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBzaW5jZSBpdCdzIHJlc2lsaWVudCB0byBzZXJpYWxpemF0aW9uLlxuICAgKi9cbiAgcmV0dXJuIHByb3RvdHlwZSA9PT0gbnVsbCB8fCBwcm90b3R5cGUuaGFzT3duUHJvcGVydHkoJ2lzUHJvdG90eXBlT2YnKVxufVxuIl0sIm5hbWVzIjpbImdldE9iamVjdENsYXNzTGFiZWwiLCJpc1BsYWluT2JqZWN0IiwidmFsdWUiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJnZXRQcm90b3R5cGVPZiIsImhhc093blByb3BlcnR5Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztJQUFnQkEsbUJBQW1CLEVBQUE7ZUFBbkJBOztJQUlBQyxhQUFhLEVBQUE7ZUFBYkE7OztBQUpULFNBQVNELG9CQUFvQkUsS0FBVTtJQUM1QyxPQUFPQyxPQUFPQyxTQUFTLENBQUNDLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDSjtBQUN4QztBQUVPLFNBQVNELGNBQWNDLEtBQVU7SUFDdEMsSUFBSUYsb0JBQW9CRSxXQUFXLG1CQUFtQjtRQUNwRCxPQUFPO0lBQ1Q7SUFFQSxNQUFNRSxZQUFZRCxPQUFPSSxjQUFjLENBQUNMO0lBRXhDOzs7Ozs7OztHQVFDLEdBQ0QsT0FBT0UsY0FBYyxRQUFRQSxVQUFVSSxjQUFjLENBQUM7QUFDeEQiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNjMxNSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9saWIvaXMtZXJyb3IudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNQbGFpbk9iamVjdCB9IGZyb20gJy4uL3NoYXJlZC9saWIvaXMtcGxhaW4tb2JqZWN0J1xuXG4vLyBXZSBhbGxvdyBzb21lIGFkZGl0aW9uYWwgYXR0YWNoZWQgcHJvcGVydGllcyBmb3IgTmV4dC5qcyBlcnJvcnNcbmV4cG9ydCBpbnRlcmZhY2UgTmV4dEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICB0eXBlPzogc3RyaW5nXG4gIHBhZ2U/OiBzdHJpbmdcbiAgY29kZT86IHN0cmluZyB8IG51bWJlclxuICBjYW5jZWxsZWQ/OiBib29sZWFuXG4gIGRpZ2VzdD86IG51bWJlclxufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIE5leHRFcnJvci5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gcHJpbnQgYSBtb3JlIGRldGFpbGVkIGVycm9yIG1lc3NhZ2Ugd2l0aCBwcm9wZXJ0aWVzIGxpa2UgYGNvZGVgICYgYGRpZ2VzdGAuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzRXJyb3IoZXJyOiB1bmtub3duKTogZXJyIGlzIE5leHRFcnJvciB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIGVyciA9PT0gJ29iamVjdCcgJiYgZXJyICE9PSBudWxsICYmICduYW1lJyBpbiBlcnIgJiYgJ21lc3NhZ2UnIGluIGVyclxuICApXG59XG5cbmZ1bmN0aW9uIHNhZmVTdHJpbmdpZnkob2JqOiBhbnkpIHtcbiAgY29uc3Qgc2VlbiA9IG5ldyBXZWFrU2V0KClcblxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqLCAoX2tleSwgdmFsdWUpID0+IHtcbiAgICAvLyBJZiB2YWx1ZSBpcyBhbiBvYmplY3QgYW5kIGFscmVhZHkgc2VlbiwgcmVwbGFjZSB3aXRoIFwiW0NpcmN1bGFyXVwiXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgIGlmIChzZWVuLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJ1xuICAgICAgfVxuICAgICAgc2Vlbi5hZGQodmFsdWUpXG4gICAgfVxuICAgIHJldHVybiB2YWx1ZVxuICB9KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHJvcGVyRXJyb3IoZXJyOiB1bmtub3duKTogRXJyb3Ige1xuICBpZiAoaXNFcnJvcihlcnIpKSB7XG4gICAgcmV0dXJuIGVyclxuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgLy8gcHJvdmlkZSBiZXR0ZXIgZXJyb3IgZm9yIGNhc2Ugd2hlcmUgYHRocm93IHVuZGVmaW5lZGBcbiAgICAvLyBpcyBjYWxsZWQgaW4gZGV2ZWxvcG1lbnRcbiAgICBpZiAodHlwZW9mIGVyciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gICAgICAgICdBbiB1bmRlZmluZWQgZXJyb3Igd2FzIHRocm93biwgJyArXG4gICAgICAgICAgJ3NlZSBoZXJlIGZvciBtb3JlIGluZm86IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL3RocmV3LXVuZGVmaW5lZCdcbiAgICAgIClcbiAgICB9XG5cbiAgICBpZiAoZXJyID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgICAgICAnQSBudWxsIGVycm9yIHdhcyB0aHJvd24sICcgK1xuICAgICAgICAgICdzZWUgaGVyZSBmb3IgbW9yZSBpbmZvOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy90aHJldy11bmRlZmluZWQnXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBFcnJvcihpc1BsYWluT2JqZWN0KGVycikgPyBzYWZlU3RyaW5naWZ5KGVycikgOiBlcnIgKyAnJylcbn1cbiJdLCJuYW1lcyI6WyJpc0Vycm9yIiwiZ2V0UHJvcGVyRXJyb3IiLCJlcnIiLCJzYWZlU3RyaW5naWZ5Iiwib2JqIiwic2VlbiIsIldlYWtTZXQiLCJKU09OIiwic3RyaW5naWZ5IiwiX2tleSIsInZhbHVlIiwiaGFzIiwiYWRkIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiRXJyb3IiLCJpc1BsYWluT2JqZWN0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztJQVdBOzs7Q0FHQyxHQUNELE9BSUMsRUFBQTtlQUp1QkE7O0lBcUJSQyxjQUFjLEVBQUE7ZUFBZEE7OzsrQkFwQ2M7QUFlZixTQUFTRCxRQUFRRSxHQUFZO0lBQzFDLE9BQ0UsT0FBT0EsUUFBUSxZQUFZQSxRQUFRLFFBQVEsVUFBVUEsT0FBTyxhQUFhQTtBQUU3RTtBQUVBLFNBQVNDLGNBQWNDLEdBQVE7SUFDN0IsTUFBTUMsT0FBTyxJQUFJQztJQUVqQixPQUFPQyxLQUFLQyxTQUFTLENBQUNKLEtBQUssQ0FBQ0ssTUFBTUM7UUFDaEMsb0VBQW9FO1FBQ3BFLElBQUksT0FBT0EsVUFBVSxZQUFZQSxVQUFVLE1BQU07WUFDL0MsSUFBSUwsS0FBS00sR0FBRyxDQUFDRCxRQUFRO2dCQUNuQixPQUFPO1lBQ1Q7WUFDQUwsS0FBS08sR0FBRyxDQUFDRjtRQUNYO1FBQ0EsT0FBT0E7SUFDVDtBQUNGO0FBRU8sU0FBU1QsZUFBZUMsR0FBWTtJQUN6QyxJQUFJRixRQUFRRSxNQUFNO1FBQ2hCLE9BQU9BO0lBQ1Q7SUFFQSxJQUFJVyxRQUFRQyxHQUFHLENBQUNDLFFBQVEsS0FBSyxXQUFlO1FBQzFDLHdEQUF3RDtRQUN4RCwyQkFBMkI7UUFDM0IsSUFBSSxPQUFPYixRQUFRLGFBQWE7WUFDOUIsT0FBTyxPQUFBLGNBR04sQ0FITSxJQUFJYyxNQUNULG9DQUNFLDZFQUZHLHFCQUFBO3VCQUFBOzRCQUFBOzhCQUFBO1lBR1A7UUFDRjtRQUVBLElBQUlkLFFBQVEsTUFBTTtZQUNoQixPQUFPLE9BQUEsY0FHTixDQUhNLElBQUljLE1BQ1QsOEJBQ0UsNkVBRkcscUJBQUE7dUJBQUE7NEJBQUE7OEJBQUE7WUFHUDtRQUNGO0lBQ0Y7SUFFQSxPQUFPLE9BQUEsY0FBNkQsQ0FBN0QsSUFBSUEsTUFBTUMsQ0FBQUEsR0FBQUEsZUFBQUEsYUFBYSxFQUFDZixPQUFPQyxjQUFjRCxPQUFPQSxNQUFNLEtBQTFELHFCQUFBO2VBQUE7b0JBQUE7c0JBQUE7SUFBNEQ7QUFDckUiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNjM5MCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvbGliL2NvbnNvbGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGlzRXJyb3IgZnJvbSAnLi4vLi4vbGliL2lzLWVycm9yJ1xuXG5mdW5jdGlvbiBmb3JtYXRPYmplY3QoYXJnOiB1bmtub3duLCBkZXB0aDogbnVtYmVyKSB7XG4gIHN3aXRjaCAodHlwZW9mIGFyZykge1xuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBpZiAoYXJnID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnbnVsbCdcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSAnWydcbiAgICAgICAgaWYgKGRlcHRoIDwgMSkge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJnLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0ICE9PSAnWycpIHtcbiAgICAgICAgICAgICAgcmVzdWx0ICs9ICcsJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhcmcsIGkpKSB7XG4gICAgICAgICAgICAgIHJlc3VsdCArPSBmb3JtYXRPYmplY3QoYXJnW2ldLCBkZXB0aCArIDEpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdCArPSBhcmcubGVuZ3RoID4gMCA/ICcuLi4nIDogJydcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gJ10nXG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgIH0gZWxzZSBpZiAoYXJnIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGFyZyArICcnXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoYXJnKVxuICAgICAgICBsZXQgcmVzdWx0ID0gJ3snXG4gICAgICAgIGlmIChkZXB0aCA8IDEpIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV1cbiAgICAgICAgICAgIGNvbnN0IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGFyZywgJ2tleScpXG4gICAgICAgICAgICBpZiAoZGVzYyAmJiAhZGVzYy5nZXQgJiYgIWRlc2Muc2V0KSB7XG4gICAgICAgICAgICAgIGNvbnN0IGpzb25LZXkgPSBKU09OLnN0cmluZ2lmeShrZXkpXG4gICAgICAgICAgICAgIGlmIChqc29uS2V5ICE9PSAnXCInICsga2V5ICsgJ1wiJykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBqc29uS2V5ICsgJzogJ1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBrZXkgKyAnOiAnXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0ICs9IGZvcm1hdE9iamVjdChkZXNjLnZhbHVlLCBkZXB0aCArIDEpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdCArPSBrZXlzLmxlbmd0aCA+IDAgPyAnLi4uJyA6ICcnXG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9ICd9J1xuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICB9XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmcpXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBTdHJpbmcoYXJnKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRDb25zb2xlQXJncyhhcmdzOiB1bmtub3duW10pOiBzdHJpbmcge1xuICBsZXQgbWVzc2FnZTogc3RyaW5nXG4gIGxldCBpZHg6IG51bWJlclxuICBpZiAodHlwZW9mIGFyZ3NbMF0gPT09ICdzdHJpbmcnKSB7XG4gICAgbWVzc2FnZSA9IGFyZ3NbMF1cbiAgICBpZHggPSAxXG4gIH0gZWxzZSB7XG4gICAgbWVzc2FnZSA9ICcnXG4gICAgaWR4ID0gMFxuICB9XG4gIGxldCByZXN1bHQgPSAnJ1xuICBsZXQgc3RhcnRRdW90ZSA9IGZhbHNlXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWVzc2FnZS5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGNoYXIgPSBtZXNzYWdlW2ldXG4gICAgaWYgKGNoYXIgIT09ICclJyB8fCBpID09PSBtZXNzYWdlLmxlbmd0aCAtIDEgfHwgaWR4ID49IGFyZ3MubGVuZ3RoKSB7XG4gICAgICByZXN1bHQgKz0gY2hhclxuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBjb25zdCBjb2RlID0gbWVzc2FnZVsrK2ldXG4gICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICBjYXNlICdjJzoge1xuICAgICAgICAvLyBUT0RPOiBXZSBzaG91bGQgY29sb3JpemUgd2l0aCBIVE1MIGluc3RlYWQgb2YgdHVybmluZyBpbnRvIGEgc3RyaW5nLlxuICAgICAgICAvLyBJZ25vcmUgZm9yIG5vdy5cbiAgICAgICAgcmVzdWx0ID0gc3RhcnRRdW90ZSA/IGAke3Jlc3VsdH1dYCA6IGBbJHtyZXN1bHR9YFxuICAgICAgICBzdGFydFF1b3RlID0gIXN0YXJ0UXVvdGVcbiAgICAgICAgaWR4KytcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ08nOlxuICAgICAgY2FzZSAnbyc6IHtcbiAgICAgICAgcmVzdWx0ICs9IGZvcm1hdE9iamVjdChhcmdzW2lkeCsrXSwgMClcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ2QnOlxuICAgICAgY2FzZSAnaSc6IHtcbiAgICAgICAgcmVzdWx0ICs9IHBhcnNlSW50KGFyZ3NbaWR4KytdIGFzIGFueSwgMTApXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBjYXNlICdmJzoge1xuICAgICAgICByZXN1bHQgKz0gcGFyc2VGbG9hdChhcmdzW2lkeCsrXSBhcyBhbnkpXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBjYXNlICdzJzoge1xuICAgICAgICByZXN1bHQgKz0gU3RyaW5nKGFyZ3NbaWR4KytdKVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmVzdWx0ICs9ICclJyArIGNvZGVcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgaWR4IDwgYXJncy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgcmVzdWx0ICs9IChpZHggPiAwID8gJyAnIDogJycpICsgZm9ybWF0T2JqZWN0KGFyZ3NbaWR4XSwgMClcbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQ29uc29sZUFyZ3MoYXJnczogdW5rbm93bltdKToge1xuICBlbnZpcm9ubWVudE5hbWU6IHN0cmluZyB8IG51bGxcbiAgZXJyb3I6IEVycm9yIHwgbnVsbFxufSB7XG4gIC8vIFNlZVxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi82NWE1NmQwZTk5MjYxNDgxYzcyMTMzNGEzZWM0NTYxZDE3MzU5NGNkL3BhY2thZ2VzL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9mbGlnaHQvcmVuZGVyZXIuanMjTDg4LUw5M1xuICAvL1xuICAvLyBMb2dzIHJlcGxheWVkIGZyb20gdGhlIHNlcnZlciBsb29rIGxpa2UgdGhpczpcbiAgLy8gW1xuICAvLyAgIFwiJWMlcyVjICVvXFxuXFxuJXNcXG5cXG4lc1xcblwiLFxuICAvLyAgIFwiYmFja2dyb3VuZDogI2U2ZTZlNjsgLi4uXCIsXG4gIC8vICAgXCIgU2VydmVyIFwiLCAvLyBjYW4gYWxzbyBiZSBlLmcuIFwiIFByZXJlbmRlciBcIlxuICAvLyAgIFwiXCIsXG4gIC8vICAgRXJyb3IsXG4gIC8vICAgXCJUaGUgYWJvdmUgZXJyb3Igb2NjdXJyZWQgaW4gdGhlIDxQYWdlPiBjb21wb25lbnQuXCIsXG4gIC8vICAgLi4uXG4gIC8vIF1cbiAgaWYgKFxuICAgIGFyZ3MubGVuZ3RoID4gMyAmJlxuICAgIHR5cGVvZiBhcmdzWzBdID09PSAnc3RyaW5nJyAmJlxuICAgIGFyZ3NbMF0uc3RhcnRzV2l0aCgnJWMlcyVjICcpICYmXG4gICAgdHlwZW9mIGFyZ3NbMV0gPT09ICdzdHJpbmcnICYmXG4gICAgdHlwZW9mIGFyZ3NbMl0gPT09ICdzdHJpbmcnICYmXG4gICAgdHlwZW9mIGFyZ3NbM10gPT09ICdzdHJpbmcnXG4gICkge1xuICAgIGNvbnN0IGVudmlyb25tZW50TmFtZSA9IGFyZ3NbMl1cbiAgICBjb25zdCBtYXliZUVycm9yID0gYXJnc1s0XVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGVudmlyb25tZW50TmFtZTogZW52aXJvbm1lbnROYW1lLnRyaW0oKSxcbiAgICAgIGVycm9yOiBpc0Vycm9yKG1heWJlRXJyb3IpID8gbWF5YmVFcnJvciA6IG51bGwsXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBlbnZpcm9ubWVudE5hbWU6IG51bGwsXG4gICAgZXJyb3I6IG51bGwsXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJmb3JtYXRDb25zb2xlQXJncyIsInBhcnNlQ29uc29sZUFyZ3MiLCJmb3JtYXRPYmplY3QiLCJhcmciLCJkZXB0aCIsIkFycmF5IiwiaXNBcnJheSIsInJlc3VsdCIsImkiLCJsZW5ndGgiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJFcnJvciIsImtleXMiLCJrZXkiLCJkZXNjIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0Iiwic2V0IiwianNvbktleSIsIkpTT04iLCJzdHJpbmdpZnkiLCJ2YWx1ZSIsIlN0cmluZyIsImFyZ3MiLCJtZXNzYWdlIiwiaWR4Iiwic3RhcnRRdW90ZSIsImNoYXIiLCJjb2RlIiwicGFyc2VJbnQiLCJwYXJzZUZsb2F0Iiwic3RhcnRzV2l0aCIsImVudmlyb25tZW50TmFtZSIsIm1heWJlRXJyb3IiLCJ0cmltIiwiZXJyb3IiLCJpc0Vycm9yIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztJQXVEZ0JBLGlCQUFpQixFQUFBO2VBQWpCQTs7SUEyREFDLGdCQUFnQixFQUFBO2VBQWhCQTs7OztrRUFsSEk7QUFFcEIsU0FBU0MsYUFBYUMsR0FBWSxFQUFFQyxLQUFhO0lBQy9DLE9BQVEsT0FBT0Q7UUFDYixLQUFLO1lBQ0gsSUFBSUEsUUFBUSxNQUFNO2dCQUNoQixPQUFPO1lBQ1QsT0FBTyxJQUFJRSxNQUFNQyxPQUFPLENBQUNILE1BQU07Z0JBQzdCLElBQUlJLFNBQVM7Z0JBQ2IsSUFBSUgsUUFBUSxHQUFHO29CQUNiLElBQUssSUFBSUksSUFBSSxHQUFHQSxJQUFJTCxJQUFJTSxNQUFNLEVBQUVELElBQUs7d0JBQ25DLElBQUlELFdBQVcsS0FBSzs0QkFDbEJBLFVBQVU7d0JBQ1o7d0JBQ0EsSUFBSUcsT0FBT0MsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ1YsS0FBS0ssSUFBSTs0QkFDaERELFVBQVVMLGFBQWFDLEdBQUcsQ0FBQ0ssRUFBRSxFQUFFSixRQUFRO3dCQUN6QztvQkFDRjtnQkFDRixPQUFPO29CQUNMRyxVQUFVSixJQUFJTSxNQUFNLEdBQUcsSUFBSSxRQUFRO2dCQUNyQztnQkFDQUYsVUFBVTtnQkFDVixPQUFPQTtZQUNULE9BQU8sSUFBSUosZUFBZVcsT0FBTztnQkFDL0IsT0FBT1gsTUFBTTtZQUNmLE9BQU87Z0JBQ0wsTUFBTVksT0FBT0wsT0FBT0ssSUFBSSxDQUFDWjtnQkFDekIsSUFBSUksU0FBUztnQkFDYixJQUFJSCxRQUFRLEdBQUc7b0JBQ2IsSUFBSyxJQUFJSSxJQUFJLEdBQUdBLElBQUlPLEtBQUtOLE1BQU0sRUFBRUQsSUFBSzt3QkFDcEMsTUFBTVEsTUFBTUQsSUFBSSxDQUFDUCxFQUFFO3dCQUNuQixN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T0FBT0EsSUFBSSxDQUFDLEVBQUUsS0FBSyxZQUNuQixPQUFPQSxJQUFJLENBQUMsRUFBRSxLQUFLLFVBQ25CO1FBQ0EsTUFBTVMsa0JBQWtCVCxJQUFJLENBQUMsRUFBRTtRQUMvQixNQUFNVSxhQUFhVixJQUFJLENBQUMsRUFBRTtRQUUxQixPQUFPO1lBQ0xTLGlCQUFpQkEsZ0JBQWdCRSxJQUFJO1lBQ3JDQyxPQUFPQyxDQUFBQSxHQUFBQSxTQUFBQSxPQUFPLEVBQUNILGNBQWNBLGFBQWE7UUFDNUM7SUFDRjtJQUVBLE9BQU87UUFDTEQsaUJBQWlCO1FBQ2pCRyxPQUFPO0lBQ1Q7QUFDRiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA2NTY1LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL25leHQtZGV2dG9vbHMvc2hhcmVkL2NvbnNvbGUtZXJyb3IudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVG8gZGlzdGluZ3Vpc2ggZnJvbSBSZWFjdCBlcnJvci5kaWdlc3QsIHdlIHVzZSBhIGRpZmZlcmVudCBzeW1ib2wgaGVyZSB0byBkZXRlcm1pbmUgaWYgdGhlIGVycm9yIGlzIGZyb20gY29uc29sZS5lcnJvciBvciB1bmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb24uXG5jb25zdCBkaWdlc3RTeW0gPSBTeW1ib2wuZm9yKCduZXh0LmNvbnNvbGUuZXJyb3IuZGlnZXN0JylcblxuLy8gUmVwcmVzZW50IG5vbiBFcnJvciBzaGFwZSB1bmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb25zIG9yIGNvbnNvbGUuZXJyb3IgZXJyb3JzLlxuLy8gVGhvc2UgZXJyb3JzIHdpbGwgYmUgY2FwdHVyZWQgYW5kIGRpc3BsYXllZCBpbiBFcnJvciBPdmVybGF5LlxuZXhwb3J0IHR5cGUgQ29uc29sZUVycm9yID0gRXJyb3IgJiB7XG4gIFtkaWdlc3RTeW1dOiAnTkVYVF9DT05TT0xFX0VSUk9SJ1xuICBlbnZpcm9ubWVudE5hbWU6IHN0cmluZ1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29uc29sZUVycm9yKFxuICBtZXNzYWdlOiBzdHJpbmcgfCBFcnJvcixcbiAgZW52aXJvbm1lbnROYW1lPzogc3RyaW5nIHwgbnVsbFxuKTogQ29uc29sZUVycm9yIHtcbiAgY29uc3QgZXJyb3IgPSAoXG4gICAgdHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnID8gbmV3IEVycm9yKG1lc3NhZ2UpIDogbWVzc2FnZVxuICApIGFzIENvbnNvbGVFcnJvclxuICBlcnJvcltkaWdlc3RTeW1dID0gJ05FWFRfQ09OU09MRV9FUlJPUidcblxuICBpZiAoZW52aXJvbm1lbnROYW1lICYmICFlcnJvci5lbnZpcm9ubWVudE5hbWUpIHtcbiAgICBlcnJvci5lbnZpcm9ubWVudE5hbWUgPSBlbnZpcm9ubWVudE5hbWVcbiAgfVxuXG4gIHJldHVybiBlcnJvclxufVxuXG5leHBvcnQgY29uc3QgaXNDb25zb2xlRXJyb3IgPSAoZXJyb3I6IGFueSk6IGVycm9yIGlzIENvbnNvbGVFcnJvciA9PiB7XG4gIHJldHVybiBlcnJvciAmJiBlcnJvcltkaWdlc3RTeW1dID09PSAnTkVYVF9DT05TT0xFX0VSUk9SJ1xufVxuIl0sIm5hbWVzIjpbImNyZWF0ZUNvbnNvbGVFcnJvciIsImlzQ29uc29sZUVycm9yIiwiZGlnZXN0U3ltIiwiU3ltYm9sIiwiZm9yIiwibWVzc2FnZSIsImVudmlyb25tZW50TmFtZSIsImVycm9yIiwiRXJyb3IiXSwibWFwcGluZ3MiOiJBQUFBLHlKQUF5Sjs7Ozs7Ozs7Ozs7Ozs7O0lBVXpJQSxrQkFBa0IsRUFBQTtlQUFsQkE7O0lBZ0JIQyxjQUFjLEVBQUE7ZUFBZEE7OztBQXpCYixNQUFNQyxZQUFZQyxPQUFPQyxHQUFHLENBQUM7QUFTdEIsU0FBU0osbUJBQ2RLLE9BQXVCLEVBQ3ZCQyxlQUErQjtJQUUvQixNQUFNQyxRQUNKLE9BQU9GLFlBQVksV0FBVyxPQUFBLGNBQWtCLENBQWxCLElBQUlHLE1BQU1ILFVBQVYscUJBQUE7ZUFBQTtvQkFBQTtzQkFBQTtJQUFpQixLQUFJQTtJQUVyREUsS0FBSyxDQUFDTCxVQUFVLEdBQUc7SUFFbkIsSUFBSUksbUJBQW1CLENBQUNDLE1BQU1ELGVBQWUsRUFBRTtRQUM3Q0MsTUFBTUQsZUFBZSxHQUFHQTtJQUMxQjtJQUVBLE9BQU9DO0FBQ1Q7QUFFTyxNQUFNTixpQkFBaUIsQ0FBQ007SUFDN0IsT0FBT0EsU0FBU0EsS0FBSyxDQUFDTCxVQUFVLEtBQUs7QUFDdkMiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNjYxNiwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9uZXh0LWRldnRvb2xzL3VzZXJzcGFjZS9hcHAvZXJyb3JzL3N0aXRjaGVkLWVycm9yLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCBpc0Vycm9yIGZyb20gJy4uLy4uLy4uLy4uL2xpYi9pcy1lcnJvcidcblxuY29uc3Qgb3duZXJTdGFja3MgPSBuZXcgV2Vha01hcDxFcnJvciwgc3RyaW5nIHwgbnVsbD4oKVxuY29uc3QgY29tcG9uZW50U3RhY2tzID0gbmV3IFdlYWtNYXA8RXJyb3IsIHN0cmluZz4oKVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29tcG9uZW50U3RhY2soZXJyb3I6IEVycm9yKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgcmV0dXJuIGNvbXBvbmVudFN0YWNrcy5nZXQoZXJyb3IpXG59XG5leHBvcnQgZnVuY3Rpb24gc2V0Q29tcG9uZW50U3RhY2soZXJyb3I6IEVycm9yLCBzdGFjazogc3RyaW5nKSB7XG4gIGNvbXBvbmVudFN0YWNrcy5zZXQoZXJyb3IsIHN0YWNrKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0T3duZXJTdGFjayhlcnJvcjogRXJyb3IpOiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkIHtcbiAgcmV0dXJuIG93bmVyU3RhY2tzLmdldChlcnJvcilcbn1cbmV4cG9ydCBmdW5jdGlvbiBzZXRPd25lclN0YWNrKGVycm9yOiBFcnJvciwgc3RhY2s6IHN0cmluZyB8IG51bGwpIHtcbiAgb3duZXJTdGFja3Muc2V0KGVycm9yLCBzdGFjaylcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvZXJjZUVycm9yKHZhbHVlOiB1bmtub3duKTogRXJyb3Ige1xuICByZXR1cm4gaXNFcnJvcih2YWx1ZSkgPyB2YWx1ZSA6IG5ldyBFcnJvcignJyArIHZhbHVlKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0T3duZXJTdGFja0lmQXZhaWxhYmxlKGVycm9yOiBFcnJvcik6IHZvaWQge1xuICAvLyBSZWFjdCAxOCBhbmQgcHJvZCBkb2VzIG5vdCBoYXZlIGBjYXB0dXJlT3duZXJTdGFja2BcbiAgaWYgKCdjYXB0dXJlT3duZXJTdGFjaycgaW4gUmVhY3QpIHtcbiAgICBzZXRPd25lclN0YWNrKGVycm9yLCBSZWFjdC5jYXB0dXJlT3duZXJTdGFjaygpKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWNvcmF0ZURldkVycm9yKFxuICB0aHJvd25WYWx1ZTogdW5rbm93bixcbiAgZXJyb3JJbmZvOiBSZWFjdC5FcnJvckluZm9cbikge1xuICBjb25zdCBlcnJvciA9IGNvZXJjZUVycm9yKHRocm93blZhbHVlKVxuICBzZXRPd25lclN0YWNrSWZBdmFpbGFibGUoZXJyb3IpXG4gIC8vIFRPRE86IGNoYW5nZSB0byBwYXNzaW5nIGRvd24gZXJyb3JJbmZvIGxhdGVyXG4gIC8vIEluIGRldmVsb3BtZW50IG1vZGUsIHBhc3MgYWxvbmcgdGhlIGNvbXBvbmVudCBzdGFjayB0byB0aGUgZXJyb3JcbiAgaWYgKGVycm9ySW5mby5jb21wb25lbnRTdGFjaykge1xuICAgIHNldENvbXBvbmVudFN0YWNrKGVycm9yLCBlcnJvckluZm8uY29tcG9uZW50U3RhY2spXG4gIH1cbiAgcmV0dXJuIGVycm9yXG59XG4iXSwibmFtZXMiOlsiY29lcmNlRXJyb3IiLCJkZWNvcmF0ZURldkVycm9yIiwiZ2V0Q29tcG9uZW50U3RhY2siLCJnZXRPd25lclN0YWNrIiwic2V0Q29tcG9uZW50U3RhY2siLCJzZXRPd25lclN0YWNrIiwic2V0T3duZXJTdGFja0lmQXZhaWxhYmxlIiwib3duZXJTdGFja3MiLCJXZWFrTWFwIiwiY29tcG9uZW50U3RhY2tzIiwiZXJyb3IiLCJnZXQiLCJzdGFjayIsInNldCIsInZhbHVlIiwiaXNFcnJvciIsIkVycm9yIiwiUmVhY3QiLCJjYXB0dXJlT3duZXJTdGFjayIsInRocm93blZhbHVlIiwiZXJyb3JJbmZvIiwiY29tcG9uZW50U3RhY2siXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFvQmdCQSxXQUFXLEVBQUE7ZUFBWEE7O0lBV0FDLGdCQUFnQixFQUFBO2VBQWhCQTs7SUF6QkFDLGlCQUFpQixFQUFBO2VBQWpCQTs7SUFPQUMsYUFBYSxFQUFBO2VBQWJBOztJQUpBQyxpQkFBaUIsRUFBQTtlQUFqQkE7O0lBT0FDLGFBQWEsRUFBQTtlQUFiQTs7SUFRQUMsd0JBQXdCLEVBQUE7ZUFBeEJBOzs7O2dFQXhCRTtrRUFDRTtBQUVwQixNQUFNQyxjQUFjLElBQUlDO0FBQ3hCLE1BQU1DLGtCQUFrQixJQUFJRDtBQUVyQixTQUFTTixrQkFBa0JRLEtBQVk7SUFDNUMsT0FBT0QsZ0JBQWdCRSxHQUFHLENBQUNEO0FBQzdCO0FBQ08sU0FBU04sa0JBQWtCTSxLQUFZLEVBQUVFLEtBQWE7SUFDM0RILGdCQUFnQkksR0FBRyxDQUFDSCxPQUFPRTtBQUM3QjtBQUVPLFNBQVNULGNBQWNPLEtBQVk7SUFDeEMsT0FBT0gsWUFBWUksR0FBRyxDQUFDRDtBQUN6QjtBQUNPLFNBQVNMLGNBQWNLLEtBQVksRUFBRUUsS0FBb0I7SUFDOURMLFlBQVlNLEdBQUcsQ0FBQ0gsT0FBT0U7QUFDekI7QUFFTyxTQUFTWixZQUFZYyxLQUFjO0lBQ3hDLE9BQU9DLENBQUFBLEdBQUFBLFNBQUFBLE9BQU8sRUFBQ0QsU0FBU0EsUUFBUSxPQUFBLGNBQXFCLENBQXJCLElBQUlFLE1BQU0sS0FBS0YsUUFBZixxQkFBQTtlQUFBO29CQUFBO3NCQUFBO0lBQW9CO0FBQ3REO0FBRU8sU0FBU1IseUJBQXlCSSxLQUFZO0lBQ25ELHNEQUFzRDtJQUN0RCxJQUFJLHVCQUF1Qk8sT0FBQUEsT0FBSyxFQUFFO1FBQ2hDWixjQUFjSyxPQUFPTyxPQUFBQSxPQUFLLENBQUNDLGlCQUFpQjtJQUM5QztBQUNGO0FBRU8sU0FBU2pCLGlCQUNka0IsV0FBb0IsRUFDcEJDLFNBQTBCO0lBRTFCLE1BQU1WLFFBQVFWLFlBQVltQjtJQUMxQmIseUJBQXlCSTtJQUN6QiwrQ0FBK0M7SUFDL0MsbUVBQW1FO0lBQ25FLElBQUlVLFVBQVVDLGNBQWMsRUFBRTtRQUM1QmpCLGtCQUFrQk0sT0FBT1UsVUFBVUMsY0FBYztJQUNuRDtJQUNBLE9BQU9YO0FBQ1QiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNjcwOSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvc2FmZS1zdGFibGUtc3RyaW5naWZ5L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe1widXNlIHN0cmljdFwiO3ZhciBlPXs4Nzk6ZnVuY3Rpb24oZSx0KXtjb25zdHtoYXNPd25Qcm9wZXJ0eTpufT1PYmplY3QucHJvdG90eXBlO2NvbnN0IHI9Y29uZmlndXJlKCk7ci5jb25maWd1cmU9Y29uZmlndXJlO3Iuc3RyaW5naWZ5PXI7ci5kZWZhdWx0PXI7dC5zdHJpbmdpZnk9cjt0LmNvbmZpZ3VyZT1jb25maWd1cmU7ZS5leHBvcnRzPXI7Y29uc3QgaT0vW1xcdTAwMDAtXFx1MDAxZlxcdTAwMjJcXHUwMDVjXFx1ZDgwMC1cXHVkZmZmXS87ZnVuY3Rpb24gc3RyRXNjYXBlKGUpe2lmKGUubGVuZ3RoPDVlMyYmIWkudGVzdChlKSl7cmV0dXJuYFwiJHtlfVwiYH1yZXR1cm4gSlNPTi5zdHJpbmdpZnkoZSl9ZnVuY3Rpb24gc29ydChlLHQpe2lmKGUubGVuZ3RoPjIwMHx8dCl7cmV0dXJuIGUuc29ydCh0KX1mb3IobGV0IHQ9MTt0PGUubGVuZ3RoO3QrKyl7Y29uc3Qgbj1lW3RdO2xldCByPXQ7d2hpbGUociE9PTAmJmVbci0xXT5uKXtlW3JdPWVbci0xXTtyLS19ZVtyXT1ufXJldHVybiBlfWNvbnN0IGY9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPYmplY3QuZ2V0UHJvdG90eXBlT2YoT2JqZWN0LmdldFByb3RvdHlwZU9mKG5ldyBJbnQ4QXJyYXkpKSxTeW1ib2wudG9TdHJpbmdUYWcpLmdldDtmdW5jdGlvbiBpc1R5cGVkQXJyYXlXaXRoRW50cmllcyhlKXtyZXR1cm4gZi5jYWxsKGUpIT09dW5kZWZpbmVkJiZlLmxlbmd0aCE9PTB9ZnVuY3Rpb24gc3RyaW5naWZ5VHlwZWRBcnJheShlLHQsbil7aWYoZS5sZW5ndGg8bil7bj1lLmxlbmd0aH1jb25zdCByPXQ9PT1cIixcIj9cIlwiOlwiIFwiO2xldCBpPWBcIjBcIjoke3J9JHtlWzBdfWA7Zm9yKGxldCBmPTE7ZjxuO2YrKyl7aSs9YCR7dH1cIiR7Zn1cIjoke3J9JHtlW2ZdfWB9cmV0dXJuIGl9ZnVuY3Rpb24gZ2V0Q2lyY3VsYXJWYWx1ZU9wdGlvbihlKXtpZihuLmNhbGwoZSxcImNpcmN1bGFyVmFsdWVcIikpe2NvbnN0IHQ9ZS5jaXJjdWxhclZhbHVlO2lmKHR5cGVvZiB0PT09XCJzdHJpbmdcIil7cmV0dXJuYFwiJHt0fVwiYH1pZih0PT1udWxsKXtyZXR1cm4gdH1pZih0PT09RXJyb3J8fHQ9PT1UeXBlRXJyb3Ipe3JldHVybnt0b1N0cmluZygpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJDb252ZXJ0aW5nIGNpcmN1bGFyIHN0cnVjdHVyZSB0byBKU09OXCIpfX19dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwiY2lyY3VsYXJWYWx1ZVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcgb3IgdGhlIHZhbHVlIG51bGwgb3IgdW5kZWZpbmVkJyl9cmV0dXJuJ1wiW0NpcmN1bGFyXVwiJ31mdW5jdGlvbiBnZXREZXRlcm1pbmlzdGljT3B0aW9uKGUpe2xldCB0O2lmKG4uY2FsbChlLFwiZGV0ZXJtaW5pc3RpY1wiKSl7dD1lLmRldGVybWluaXN0aWM7aWYodHlwZW9mIHQhPT1cImJvb2xlYW5cIiYmdHlwZW9mIHQhPT1cImZ1bmN0aW9uXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImRldGVybWluaXN0aWNcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgYm9vbGVhbiBvciBjb21wYXJhdG9yIGZ1bmN0aW9uJyl9fXJldHVybiB0PT09dW5kZWZpbmVkP3RydWU6dH1mdW5jdGlvbiBnZXRCb29sZWFuT3B0aW9uKGUsdCl7bGV0IHI7aWYobi5jYWxsKGUsdCkpe3I9ZVt0XTtpZih0eXBlb2YgciE9PVwiYm9vbGVhblwiKXt0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCIke3R9XCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIGJvb2xlYW5gKX19cmV0dXJuIHI9PT11bmRlZmluZWQ/dHJ1ZTpyfWZ1bmN0aW9uIGdldFBvc2l0aXZlSW50ZWdlck9wdGlvbihlLHQpe2xldCByO2lmKG4uY2FsbChlLHQpKXtyPWVbdF07aWYodHlwZW9mIHIhPT1cIm51bWJlclwiKXt0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCIke3R9XCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlcmApfWlmKCFOdW1iZXIuaXNJbnRlZ2VyKHIpKXt0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCIke3R9XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBpbnRlZ2VyYCl9aWYocjwxKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVGhlIFwiJHt0fVwiIGFyZ3VtZW50IG11c3QgYmUgPj0gMWApfX1yZXR1cm4gcj09PXVuZGVmaW5lZD9JbmZpbml0eTpyfWZ1bmN0aW9uIGdldEl0ZW1Db3VudChlKXtpZihlPT09MSl7cmV0dXJuXCIxIGl0ZW1cIn1yZXR1cm5gJHtlfSBpdGVtc2B9ZnVuY3Rpb24gZ2V0VW5pcXVlUmVwbGFjZXJTZXQoZSl7Y29uc3QgdD1uZXcgU2V0O2Zvcihjb25zdCBuIG9mIGUpe2lmKHR5cGVvZiBuPT09XCJzdHJpbmdcInx8dHlwZW9mIG49PT1cIm51bWJlclwiKXt0LmFkZChTdHJpbmcobikpfX1yZXR1cm4gdH1mdW5jdGlvbiBnZXRTdHJpY3RPcHRpb24oZSl7aWYobi5jYWxsKGUsXCJzdHJpY3RcIikpe2NvbnN0IHQ9ZS5zdHJpY3Q7aWYodHlwZW9mIHQhPT1cImJvb2xlYW5cIil7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwic3RyaWN0XCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIGJvb2xlYW4nKX1pZih0KXtyZXR1cm4gZT0+e2xldCB0PWBPYmplY3QgY2FuIG5vdCBzYWZlbHkgYmUgc3RyaW5naWZpZWQuIFJlY2VpdmVkIHR5cGUgJHt0eXBlb2YgZX1gO2lmKHR5cGVvZiBlIT09XCJmdW5jdGlvblwiKXQrPWAgKCR7ZS50b1N0cmluZygpfSlgO3Rocm93IG5ldyBFcnJvcih0KX19fX1mdW5jdGlvbiBjb25maWd1cmUoZSl7ZT17Li4uZX07Y29uc3QgdD1nZXRTdHJpY3RPcHRpb24oZSk7aWYodCl7aWYoZS5iaWdpbnQ9PT11bmRlZmluZWQpe2UuYmlnaW50PWZhbHNlfWlmKCEoXCJjaXJjdWxhclZhbHVlXCJpbiBlKSl7ZS5jaXJjdWxhclZhbHVlPUVycm9yfX1jb25zdCBuPWdldENpcmN1bGFyVmFsdWVPcHRpb24oZSk7Y29uc3Qgcj1nZXRCb29sZWFuT3B0aW9uKGUsXCJiaWdpbnRcIik7Y29uc3QgaT1nZXREZXRlcm1pbmlzdGljT3B0aW9uKGUpO2NvbnN0IGY9dHlwZW9mIGk9PT1cImZ1bmN0aW9uXCI/aTp1bmRlZmluZWQ7Y29uc3QgdT1nZXRQb3NpdGl2ZUludGVnZXJPcHRpb24oZSxcIm1heGltdW1EZXB0aFwiKTtjb25zdCBvPWdldFBvc2l0aXZlSW50ZWdlck9wdGlvbihlLFwibWF4aW11bUJyZWFkdGhcIik7ZnVuY3Rpb24gc3RyaW5naWZ5Rm5SZXBsYWNlcihlLHMsbCxjLGEsZyl7bGV0IHA9c1tlXTtpZih0eXBlb2YgcD09PVwib2JqZWN0XCImJnAhPT1udWxsJiZ0eXBlb2YgcC50b0pTT049PT1cImZ1bmN0aW9uXCIpe3A9cC50b0pTT04oZSl9cD1jLmNhbGwocyxlLHApO3N3aXRjaCh0eXBlb2YgcCl7Y2FzZVwic3RyaW5nXCI6cmV0dXJuIHN0ckVzY2FwZShwKTtjYXNlXCJvYmplY3RcIjp7aWYocD09PW51bGwpe3JldHVyblwibnVsbFwifWlmKGwuaW5kZXhPZihwKSE9PS0xKXtyZXR1cm4gbn1sZXQgZT1cIlwiO2xldCB0PVwiLFwiO2NvbnN0IHI9ZztpZihBcnJheS5pc0FycmF5KHApKXtpZihwLmxlbmd0aD09PTApe3JldHVyblwiW11cIn1pZih1PGwubGVuZ3RoKzEpe3JldHVybidcIltBcnJheV1cIid9bC5wdXNoKHApO2lmKGEhPT1cIlwiKXtnKz1hO2UrPWBcXG4ke2d9YDt0PWAsXFxuJHtnfWB9Y29uc3Qgbj1NYXRoLm1pbihwLmxlbmd0aCxvKTtsZXQgaT0wO2Zvcig7aTxuLTE7aSsrKXtjb25zdCBuPXN0cmluZ2lmeUZuUmVwbGFjZXIoU3RyaW5nKGkpLHAsbCxjLGEsZyk7ZSs9biE9PXVuZGVmaW5lZD9uOlwibnVsbFwiO2UrPXR9Y29uc3QgZj1zdHJpbmdpZnlGblJlcGxhY2VyKFN0cmluZyhpKSxwLGwsYyxhLGcpO2UrPWYhPT11bmRlZmluZWQ/ZjpcIm51bGxcIjtpZihwLmxlbmd0aC0xPm8pe2NvbnN0IG49cC5sZW5ndGgtby0xO2UrPWAke3R9XCIuLi4gJHtnZXRJdGVtQ291bnQobil9IG5vdCBzdHJpbmdpZmllZFwiYH1pZihhIT09XCJcIil7ZSs9YFxcbiR7cn1gfWwucG9wKCk7cmV0dXJuYFske2V9XWB9bGV0IHM9T2JqZWN0LmtleXMocCk7Y29uc3QgeT1zLmxlbmd0aDtpZih5PT09MCl7cmV0dXJuXCJ7fVwifWlmKHU8bC5sZW5ndGgrMSl7cmV0dXJuJ1wiW09iamVjdF1cIid9bGV0IGQ9XCJcIjtsZXQgaD1cIlwiO2lmKGEhPT1cIlwiKXtnKz1hO3Q9YCxcXG4ke2d9YDtkPVwiIFwifWNvbnN0ICQ9TWF0aC5taW4oeSxvKTtpZihpJiYhaXNUeXBlZEFycmF5V2l0aEVudHJpZXMocCkpe3M9c29ydChzLGYpfWwucHVzaChwKTtmb3IobGV0IG49MDtuPCQ7bisrKXtjb25zdCByPXNbbl07Y29uc3QgaT1zdHJpbmdpZnlGblJlcGxhY2VyKHIscCxsLGMsYSxnKTtpZihpIT09dW5kZWZpbmVkKXtlKz1gJHtofSR7c3RyRXNjYXBlKHIpfToke2R9JHtpfWA7aD10fX1pZih5Pm8pe2NvbnN0IG49eS1vO2UrPWAke2h9XCIuLi5cIjoke2R9XCIke2dldEl0ZW1Db3VudChuKX0gbm90IHN0cmluZ2lmaWVkXCJgO2g9dH1pZihhIT09XCJcIiYmaC5sZW5ndGg+MSl7ZT1gXFxuJHtnfSR7ZX1cXG4ke3J9YH1sLnBvcCgpO3JldHVybmB7JHtlfX1gfWNhc2VcIm51bWJlclwiOnJldHVybiBpc0Zpbml0ZShwKT9TdHJpbmcocCk6dD90KHApOlwibnVsbFwiO2Nhc2VcImJvb2xlYW5cIjpyZXR1cm4gcD09PXRydWU/XCJ0cnVlXCI6XCJmYWxzZVwiO2Nhc2VcInVuZGVmaW5lZFwiOnJldHVybiB1bmRlZmluZWQ7Y2FzZVwiYmlnaW50XCI6aWYocil7cmV0dXJuIFN0cmluZyhwKX1kZWZhdWx0OnJldHVybiB0P3QocCk6dW5kZWZpbmVkfX1mdW5jdGlvbiBzdHJpbmdpZnlBcnJheVJlcGxhY2VyKGUsaSxmLHMsbCxjKXtpZih0eXBlb2YgaT09PVwib2JqZWN0XCImJmkhPT1udWxsJiZ0eXBlb2YgaS50b0pTT049PT1cImZ1bmN0aW9uXCIpe2k9aS50b0pTT04oZSl9c3dpdGNoKHR5cGVvZiBpKXtjYXNlXCJzdHJpbmdcIjpyZXR1cm4gc3RyRXNjYXBlKGkpO2Nhc2VcIm9iamVjdFwiOntpZihpPT09bnVsbCl7cmV0dXJuXCJudWxsXCJ9aWYoZi5pbmRleE9mKGkpIT09LTEpe3JldHVybiBufWNvbnN0IGU9YztsZXQgdD1cIlwiO2xldCByPVwiLFwiO2lmKEFycmF5LmlzQXJyYXkoaSkpe2lmKGkubGVuZ3RoPT09MCl7cmV0dXJuXCJbXVwifWlmKHU8Zi5sZW5ndGgrMSl7cmV0dXJuJ1wiW0FycmF5XVwiJ31mLnB1c2goaSk7aWYobCE9PVwiXCIpe2MrPWw7dCs9YFxcbiR7Y31gO3I9YCxcXG4ke2N9YH1jb25zdCBuPU1hdGgubWluKGkubGVuZ3RoLG8pO2xldCBhPTA7Zm9yKDthPG4tMTthKyspe2NvbnN0IGU9c3RyaW5naWZ5QXJyYXlSZXBsYWNlcihTdHJpbmcoYSksaVthXSxmLHMsbCxjKTt0Kz1lIT09dW5kZWZpbmVkP2U6XCJudWxsXCI7dCs9cn1jb25zdCBnPXN0cmluZ2lmeUFycmF5UmVwbGFjZXIoU3RyaW5nKGEpLGlbYV0sZixzLGwsYyk7dCs9ZyE9PXVuZGVmaW5lZD9nOlwibnVsbFwiO2lmKGkubGVuZ3RoLTE+byl7Y29uc3QgZT1pLmxlbmd0aC1vLTE7dCs9YCR7cn1cIi4uLiAke2dldEl0ZW1Db3VudChlKX0gbm90IHN0cmluZ2lmaWVkXCJgfWlmKGwhPT1cIlwiKXt0Kz1gXFxuJHtlfWB9Zi5wb3AoKTtyZXR1cm5gWyR7dH1dYH1mLnB1c2goaSk7bGV0IGE9XCJcIjtpZihsIT09XCJcIil7Yys9bDtyPWAsXFxuJHtjfWA7YT1cIiBcIn1sZXQgZz1cIlwiO2Zvcihjb25zdCBlIG9mIHMpe2NvbnN0IG49c3RyaW5naWZ5QXJyYXlSZXBsYWNlcihlLGlbZV0sZixzLGwsYyk7aWYobiE9PXVuZGVmaW5lZCl7dCs9YCR7Z30ke3N0ckVzY2FwZShlKX06JHthfSR7bn1gO2c9cn19aWYobCE9PVwiXCImJmcubGVuZ3RoPjEpe3Q9YFxcbiR7Y30ke3R9XFxuJHtlfWB9Zi5wb3AoKTtyZXR1cm5geyR7dH19YH1jYXNlXCJudW1iZXJcIjpyZXR1cm4gaXNGaW5pdGUoaSk/U3RyaW5nKGkpOnQ/dChpKTpcIm51bGxcIjtjYXNlXCJib29sZWFuXCI6cmV0dXJuIGk9PT10cnVlP1widHJ1ZVwiOlwiZmFsc2VcIjtjYXNlXCJ1bmRlZmluZWRcIjpyZXR1cm4gdW5kZWZpbmVkO2Nhc2VcImJpZ2ludFwiOmlmKHIpe3JldHVybiBTdHJpbmcoaSl9ZGVmYXVsdDpyZXR1cm4gdD90KGkpOnVuZGVmaW5lZH19ZnVuY3Rpb24gc3RyaW5naWZ5SW5kZW50KGUscyxsLGMsYSl7c3dpdGNoKHR5cGVvZiBzKXtjYXNlXCJzdHJpbmdcIjpyZXR1cm4gc3RyRXNjYXBlKHMpO2Nhc2VcIm9iamVjdFwiOntpZihzPT09bnVsbCl7cmV0dXJuXCJudWxsXCJ9aWYodHlwZW9mIHMudG9KU09OPT09XCJmdW5jdGlvblwiKXtzPXMudG9KU09OKGUpO2lmKHR5cGVvZiBzIT09XCJvYmplY3RcIil7cmV0dXJuIHN0cmluZ2lmeUluZGVudChlLHMsbCxjLGEpfWlmKHM9PT1udWxsKXtyZXR1cm5cIm51bGxcIn19aWYobC5pbmRleE9mKHMpIT09LTEpe3JldHVybiBufWNvbnN0IHQ9YTtpZihBcnJheS5pc0FycmF5KHMpKXtpZihzLmxlbmd0aD09PTApe3JldHVyblwiW11cIn1pZih1PGwubGVuZ3RoKzEpe3JldHVybidcIltBcnJheV1cIid9bC5wdXNoKHMpO2ErPWM7bGV0IGU9YFxcbiR7YX1gO2NvbnN0IG49YCxcXG4ke2F9YDtjb25zdCByPU1hdGgubWluKHMubGVuZ3RoLG8pO2xldCBpPTA7Zm9yKDtpPHItMTtpKyspe2NvbnN0IHQ9c3RyaW5naWZ5SW5kZW50KFN0cmluZyhpKSxzW2ldLGwsYyxhKTtlKz10IT09dW5kZWZpbmVkP3Q6XCJudWxsXCI7ZSs9bn1jb25zdCBmPXN0cmluZ2lmeUluZGVudChTdHJpbmcoaSksc1tpXSxsLGMsYSk7ZSs9ZiE9PXVuZGVmaW5lZD9mOlwibnVsbFwiO2lmKHMubGVuZ3RoLTE+byl7Y29uc3QgdD1zLmxlbmd0aC1vLTE7ZSs9YCR7bn1cIi4uLiAke2dldEl0ZW1Db3VudCh0KX0gbm90IHN0cmluZ2lmaWVkXCJgfWUrPWBcXG4ke3R9YDtsLnBvcCgpO3JldHVybmBbJHtlfV1gfWxldCByPU9iamVjdC5rZXlzKHMpO2NvbnN0IGc9ci5sZW5ndGg7aWYoZz09PTApe3JldHVyblwie31cIn1pZih1PGwubGVuZ3RoKzEpe3JldHVybidcIltPYmplY3RdXCInfWErPWM7Y29uc3QgcD1gLFxcbiR7YX1gO2xldCB5PVwiXCI7bGV0IGQ9XCJcIjtsZXQgaD1NYXRoLm1pbihnLG8pO2lmKGlzVHlwZWRBcnJheVdpdGhFbnRyaWVzKHMpKXt5Kz1zdHJpbmdpZnlUeXBlZEFycmF5KHMscCxvKTtyPXIuc2xpY2Uocy5sZW5ndGgpO2gtPXMubGVuZ3RoO2Q9cH1pZihpKXtyPXNvcnQocixmKX1sLnB1c2gocyk7Zm9yKGxldCBlPTA7ZTxoO2UrKyl7Y29uc3QgdD1yW2VdO2NvbnN0IG49c3RyaW5naWZ5SW5kZW50KHQsc1t0XSxsLGMsYSk7aWYobiE9PXVuZGVmaW5lZCl7eSs9YCR7ZH0ke3N0ckVzY2FwZSh0KX06ICR7bn1gO2Q9cH19aWYoZz5vKXtjb25zdCBlPWctbzt5Kz1gJHtkfVwiLi4uXCI6IFwiJHtnZXRJdGVtQ291bnQoZSl9IG5vdCBzdHJpbmdpZmllZFwiYDtkPXB9aWYoZCE9PVwiXCIpe3k9YFxcbiR7YX0ke3l9XFxuJHt0fWB9bC5wb3AoKTtyZXR1cm5geyR7eX19YH1jYXNlXCJudW1iZXJcIjpyZXR1cm4gaXNGaW5pdGUocyk/U3RyaW5nKHMpOnQ/dChzKTpcIm51bGxcIjtjYXNlXCJib29sZWFuXCI6cmV0dXJuIHM9PT10cnVlP1widHJ1ZVwiOlwiZmFsc2VcIjtjYXNlXCJ1bmRlZmluZWRcIjpyZXR1cm4gdW5kZWZpbmVkO2Nhc2VcImJpZ2ludFwiOmlmKHIpe3JldHVybiBTdHJpbmcocyl9ZGVmYXVsdDpyZXR1cm4gdD90KHMpOnVuZGVmaW5lZH19ZnVuY3Rpb24gc3RyaW5naWZ5U2ltcGxlKGUscyxsKXtzd2l0Y2godHlwZW9mIHMpe2Nhc2VcInN0cmluZ1wiOnJldHVybiBzdHJFc2NhcGUocyk7Y2FzZVwib2JqZWN0XCI6e2lmKHM9PT1udWxsKXtyZXR1cm5cIm51bGxcIn1pZih0eXBlb2Ygcy50b0pTT049PT1cImZ1bmN0aW9uXCIpe3M9cy50b0pTT04oZSk7aWYodHlwZW9mIHMhPT1cIm9iamVjdFwiKXtyZXR1cm4gc3RyaW5naWZ5U2ltcGxlKGUscyxsKX1pZihzPT09bnVsbCl7cmV0dXJuXCJudWxsXCJ9fWlmKGwuaW5kZXhPZihzKSE9PS0xKXtyZXR1cm4gbn1sZXQgdD1cIlwiO2NvbnN0IHI9cy5sZW5ndGghPT11bmRlZmluZWQ7aWYociYmQXJyYXkuaXNBcnJheShzKSl7aWYocy5sZW5ndGg9PT0wKXtyZXR1cm5cIltdXCJ9aWYodTxsLmxlbmd0aCsxKXtyZXR1cm4nXCJbQXJyYXldXCInfWwucHVzaChzKTtjb25zdCBlPU1hdGgubWluKHMubGVuZ3RoLG8pO2xldCBuPTA7Zm9yKDtuPGUtMTtuKyspe2NvbnN0IGU9c3RyaW5naWZ5U2ltcGxlKFN0cmluZyhuKSxzW25dLGwpO3QrPWUhPT11bmRlZmluZWQ/ZTpcIm51bGxcIjt0Kz1cIixcIn1jb25zdCByPXN0cmluZ2lmeVNpbXBsZShTdHJpbmcobiksc1tuXSxsKTt0Kz1yIT09dW5kZWZpbmVkP3I6XCJudWxsXCI7aWYocy5sZW5ndGgtMT5vKXtjb25zdCBlPXMubGVuZ3RoLW8tMTt0Kz1gLFwiLi4uICR7Z2V0SXRlbUNvdW50KGUpfSBub3Qgc3RyaW5naWZpZWRcImB9bC5wb3AoKTtyZXR1cm5gWyR7dH1dYH1sZXQgYz1PYmplY3Qua2V5cyhzKTtjb25zdCBhPWMubGVuZ3RoO2lmKGE9PT0wKXtyZXR1cm5cInt9XCJ9aWYodTxsLmxlbmd0aCsxKXtyZXR1cm4nXCJbT2JqZWN0XVwiJ31sZXQgZz1cIlwiO2xldCBwPU1hdGgubWluKGEsbyk7aWYociYmaXNUeXBlZEFycmF5V2l0aEVudHJpZXMocykpe3QrPXN0cmluZ2lmeVR5cGVkQXJyYXkocyxcIixcIixvKTtjPWMuc2xpY2Uocy5sZW5ndGgpO3AtPXMubGVuZ3RoO2c9XCIsXCJ9aWYoaSl7Yz1zb3J0KGMsZil9bC5wdXNoKHMpO2ZvcihsZXQgZT0wO2U8cDtlKyspe2NvbnN0IG49Y1tlXTtjb25zdCByPXN0cmluZ2lmeVNpbXBsZShuLHNbbl0sbCk7aWYociE9PXVuZGVmaW5lZCl7dCs9YCR7Z30ke3N0ckVzY2FwZShuKX06JHtyfWA7Zz1cIixcIn19aWYoYT5vKXtjb25zdCBlPWEtbzt0Kz1gJHtnfVwiLi4uXCI6XCIke2dldEl0ZW1Db3VudChlKX0gbm90IHN0cmluZ2lmaWVkXCJgfWwucG9wKCk7cmV0dXJuYHske3R9fWB9Y2FzZVwibnVtYmVyXCI6cmV0dXJuIGlzRmluaXRlKHMpP1N0cmluZyhzKTp0P3Qocyk6XCJudWxsXCI7Y2FzZVwiYm9vbGVhblwiOnJldHVybiBzPT09dHJ1ZT9cInRydWVcIjpcImZhbHNlXCI7Y2FzZVwidW5kZWZpbmVkXCI6cmV0dXJuIHVuZGVmaW5lZDtjYXNlXCJiaWdpbnRcIjppZihyKXtyZXR1cm4gU3RyaW5nKHMpfWRlZmF1bHQ6cmV0dXJuIHQ/dChzKTp1bmRlZmluZWR9fWZ1bmN0aW9uIHN0cmluZ2lmeShlLHQsbil7aWYoYXJndW1lbnRzLmxlbmd0aD4xKXtsZXQgcj1cIlwiO2lmKHR5cGVvZiBuPT09XCJudW1iZXJcIil7cj1cIiBcIi5yZXBlYXQoTWF0aC5taW4obiwxMCkpfWVsc2UgaWYodHlwZW9mIG49PT1cInN0cmluZ1wiKXtyPW4uc2xpY2UoMCwxMCl9aWYodCE9bnVsbCl7aWYodHlwZW9mIHQ9PT1cImZ1bmN0aW9uXCIpe3JldHVybiBzdHJpbmdpZnlGblJlcGxhY2VyKFwiXCIse1wiXCI6ZX0sW10sdCxyLFwiXCIpfWlmKEFycmF5LmlzQXJyYXkodCkpe3JldHVybiBzdHJpbmdpZnlBcnJheVJlcGxhY2VyKFwiXCIsZSxbXSxnZXRVbmlxdWVSZXBsYWNlclNldCh0KSxyLFwiXCIpfX1pZihyLmxlbmd0aCE9PTApe3JldHVybiBzdHJpbmdpZnlJbmRlbnQoXCJcIixlLFtdLHIsXCJcIil9fXJldHVybiBzdHJpbmdpZnlTaW1wbGUoXCJcIixlLFtdKX1yZXR1cm4gc3RyaW5naWZ5fX19O3ZhciB0PXt9O2Z1bmN0aW9uIF9fbmNjd3Bja19yZXF1aXJlX18obil7dmFyIHI9dFtuXTtpZihyIT09dW5kZWZpbmVkKXtyZXR1cm4gci5leHBvcnRzfXZhciBpPXRbbl09e2V4cG9ydHM6e319O3ZhciBmPXRydWU7dHJ5e2Vbbl0oaSxpLmV4cG9ydHMsX19uY2N3cGNrX3JlcXVpcmVfXyk7Zj1mYWxzZX1maW5hbGx5e2lmKGYpZGVsZXRlIHRbbl19cmV0dXJuIGkuZXhwb3J0c31pZih0eXBlb2YgX19uY2N3cGNrX3JlcXVpcmVfXyE9PVwidW5kZWZpbmVkXCIpX19uY2N3cGNrX3JlcXVpcmVfXy5hYj1fX2Rpcm5hbWUrXCIvXCI7dmFyIG49X19uY2N3cGNrX3JlcXVpcmVfXyg4NzkpO21vZHVsZS5leHBvcnRzPW59KSgpOyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxDQUFDO0lBQVc7SUFBYSxJQUFJLElBQUU7UUFBQyxLQUFJLFNBQVMsQ0FBQyxFQUFDLENBQUM7WUFBRSxNQUFLLEVBQUMsZ0JBQWUsQ0FBQyxFQUFDLEdBQUMsT0FBTyxTQUFTO1lBQUMsTUFBTSxJQUFFO1lBQVksRUFBRSxTQUFTLEdBQUM7WUFBVSxFQUFFLFNBQVMsR0FBQztZQUFFLEVBQUUsT0FBTyxHQUFDO1lBQUUsRUFBRSxTQUFTLEdBQUM7WUFBRSxFQUFFLFNBQVMsR0FBQztZQUFVLEVBQUUsT0FBTyxHQUFDO1lBQUUsTUFBTSxJQUFFO1lBQTJDLFNBQVMsVUFBVSxDQUFDO2dCQUFFLElB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LCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDczMTEsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvc2hhcmVkL2xpYi9lcnJvci1zb3VyY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3Qgc3ltYm9sRXJyb3IgPSBTeW1ib2wuZm9yKCdOZXh0anNFcnJvcicpXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRFcnJvclNvdXJjZShlcnJvcjogRXJyb3IpOiAnc2VydmVyJyB8ICdlZGdlLXNlcnZlcicgfCBudWxsIHtcbiAgcmV0dXJuIChlcnJvciBhcyBhbnkpW3N5bWJvbEVycm9yXSB8fCBudWxsXG59XG5cbmV4cG9ydCB0eXBlIEVycm9yU291cmNlVHlwZSA9ICdlZGdlLXNlcnZlcicgfCAnc2VydmVyJ1xuXG5leHBvcnQgZnVuY3Rpb24gZGVjb3JhdGVTZXJ2ZXJFcnJvcihlcnJvcjogRXJyb3IsIHR5cGU6IEVycm9yU291cmNlVHlwZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyb3IsIHN5bWJvbEVycm9yLCB7XG4gICAgd3JpdGFibGU6IGZhbHNlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgdmFsdWU6IHR5cGUsXG4gIH0pXG59XG4iXSwibmFtZXMiOlsiZGVjb3JhdGVTZXJ2ZXJFcnJvciIsImdldEVycm9yU291cmNlIiwic3ltYm9sRXJyb3IiLCJTeW1ib2wiLCJmb3IiLCJlcnJvciIsInR5cGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsIndyaXRhYmxlIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsInZhbHVlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztJQVFnQkEsbUJBQW1CLEVBQUE7ZUFBbkJBOztJQU5BQyxjQUFjLEVBQUE7ZUFBZEE7OztBQUZoQixNQUFNQyxjQUFjQyxPQUFPQyxHQUFHLENBQUM7QUFFeEIsU0FBU0gsZUFBZUksS0FBWTtJQUN6QyxPQUFRQSxLQUFhLENBQUNILFlBQVksSUFBSTtBQUN4QztBQUlPLFNBQVNGLG9CQUFvQkssS0FBWSxFQUFFQyxJQUFxQjtJQUNyRUMsT0FBT0MsY0FBYyxDQUFDSCxPQUFPSCxhQUFhO1FBQ3hDTyxVQUFVO1FBQ1ZDLFlBQVk7UUFDWkMsY0FBYztRQUNkQyxPQUFPTjtJQUNUO0FBQ0YiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNzM1MCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9uZXh0LWRldnRvb2xzL3VzZXJzcGFjZS9hcHAvdGVybWluYWwtbG9nZ2luZy1jb25maWcudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGdldFRlcm1pbmFsTG9nZ2luZ0NvbmZpZygpOlxuICB8IGZhbHNlXG4gIHwgYm9vbGVhblxuICB8IHtcbiAgICAgIGRlcHRoTGltaXQ/OiBudW1iZXJcbiAgICAgIGVkZ2VMaW1pdD86IG51bWJlclxuICAgICAgc2hvd1NvdXJjZUxvY2F0aW9uPzogYm9vbGVhblxuICAgIH0ge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKFxuICAgICAgcHJvY2Vzcy5lbnYuX19ORVhUX0JST1dTRVJfREVCVUdfSU5GT19JTl9URVJNSU5BTCB8fCAnZmFsc2UnXG4gICAgKVxuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SXNUZXJtaW5hbExvZ2dpbmdFbmFibGVkKCk6IGJvb2xlYW4ge1xuICBjb25zdCBjb25maWcgPSBnZXRUZXJtaW5hbExvZ2dpbmdDb25maWcoKVxuICByZXR1cm4gQm9vbGVhbihjb25maWcpXG59XG4iXSwibmFtZXMiOlsiZ2V0SXNUZXJtaW5hbExvZ2dpbmdFbmFibGVkIiwiZ2V0VGVybWluYWxMb2dnaW5nQ29uZmlnIiwiSlNPTiIsInBhcnNlIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9CUk9XU0VSX0RFQlVHX0lORk9fSU5fVEVSTUlOQUwiLCJjb25maWciLCJCb29sZWFuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztJQWlCZ0JBLDJCQUEyQixFQUFBO2VBQTNCQTs7SUFqQkFDLHdCQUF3QixFQUFBO2VBQXhCQTs7O0FBQVQsU0FBU0E7SUFRZCxJQUFJO1FBQ0YsT0FBT0MsS0FBS0MsS0FBSyxDQUNmQyxRQUFRQyxHQUFHLENBQUNDLGlDQUF5QyxJQUFKO0lBRXJELEVBQUUsT0FBQSxHQUFNO1FBQ04sT0FBTztJQUNUO0FBQ0Y7QUFFTyxTQUFTTjtJQUNkLE1BQU1PLFNBQVNOO0lBQ2YsT0FBT08sUUFBUUQ7QUFDakIiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNzM5NSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9uZXh0LWRldnRvb2xzL3NoYXJlZC9mb3J3YXJkLWxvZ3Mtc2hhcmVkLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB0eXBlIExvZ01ldGhvZCA9XG4gIHwgJ2xvZydcbiAgfCAnaW5mbydcbiAgfCAnZGVidWcnXG4gIHwgJ3RhYmxlJ1xuICB8ICdlcnJvcidcbiAgfCAnYXNzZXJ0J1xuICB8ICdkaXInXG4gIHwgJ2RpcnhtbCdcbiAgfCAnZ3JvdXAnXG4gIHwgJ2dyb3VwQ29sbGFwc2VkJ1xuICB8ICdncm91cEVuZCdcbiAgfCAndHJhY2UnXG4gIHwgJ3dhcm4nXG5cbmV4cG9ydCB0eXBlIENvbnNvbGVFbnRyeTxUPiA9IHtcbiAga2luZDogJ2NvbnNvbGUnXG4gIG1ldGhvZDogTG9nTWV0aG9kXG4gIGNvbnNvbGVNZXRob2RTdGFjazogc3RyaW5nIHwgbnVsbFxuICBhcmdzOiBBcnJheTxcbiAgICB8IHtcbiAgICAgICAga2luZDogJ2FyZydcbiAgICAgICAgZGF0YTogVFxuICAgICAgfVxuICAgIHwge1xuICAgICAgICBraW5kOiAnZm9ybWF0dGVkLWVycm9yLWFyZydcbiAgICAgICAgcHJlZml4OiBzdHJpbmdcbiAgICAgICAgc3RhY2s6IHN0cmluZ1xuICAgICAgfVxuICA+XG59XG5cbmV4cG9ydCB0eXBlIENvbnNvbGVFcnJvckVudHJ5PFQ+ID0ge1xuICBraW5kOiAnYW55LWxvZ2dlZC1lcnJvcidcbiAgbWV0aG9kOiAnZXJyb3InXG4gIGNvbnNvbGVFcnJvclN0YWNrOiBzdHJpbmdcbiAgYXJnczogQXJyYXk8XG4gICAgfCB7XG4gICAgICAgIGtpbmQ6ICdhcmcnXG4gICAgICAgIGRhdGE6IFRcbiAgICAgICAgaXNSZWplY3Rpb25NZXNzYWdlPzogYm9vbGVhblxuICAgICAgfVxuICAgIHwge1xuICAgICAgICBraW5kOiAnZm9ybWF0dGVkLWVycm9yLWFyZydcbiAgICAgICAgcHJlZml4OiBzdHJpbmdcbiAgICAgICAgc3RhY2s6IHN0cmluZyB8IG51bGxcbiAgICAgIH1cbiAgPlxufVxuXG5leHBvcnQgdHlwZSBGb3JtYXR0ZWRFcnJvckVudHJ5ID0ge1xuICBraW5kOiAnZm9ybWF0dGVkLWVycm9yJ1xuICBwcmVmaXg6IHN0cmluZ1xuICBzdGFjazogc3RyaW5nXG4gIG1ldGhvZDogJ2Vycm9yJ1xufVxuXG5leHBvcnQgdHlwZSBDbGllbnRMb2dFbnRyeSA9XG4gIHwgQ29uc29sZUVudHJ5PHVua25vd24+XG4gIHwgQ29uc29sZUVycm9yRW50cnk8dW5rbm93bj5cbiAgfCBGb3JtYXR0ZWRFcnJvckVudHJ5XG5leHBvcnQgdHlwZSBTZXJ2ZXJMb2dFbnRyeSA9XG4gIHwgQ29uc29sZUVudHJ5PHN0cmluZz5cbiAgfCBDb25zb2xlRXJyb3JFbnRyeTxzdHJpbmc+XG4gIHwgRm9ybWF0dGVkRXJyb3JFbnRyeVxuXG5leHBvcnQgY29uc3QgVU5ERUZJTkVEX01BUktFUiA9ICdfX25leHRfdGFnZ2VkX3VuZGVmaW5lZCdcblxuLy8gQmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvMjhkYzA3NzZiZTJlMTM3MGZlMjE3NTQ5ZDMyYWVlMjUxOWYwY2YwNS9wYWNrYWdlcy9yZWFjdC1zZXJ2ZXIvc3JjL1JlYWN0RmxpZ2h0U2VydmVyLmpzI0wyNDhcbmV4cG9ydCBmdW5jdGlvbiBwYXRjaENvbnNvbGVNZXRob2Q8VCBleHRlbmRzIGtleW9mIENvbnNvbGU+KFxuICBtZXRob2ROYW1lOiBULFxuICB3cmFwcGVyOiAoXG4gICAgbWV0aG9kTmFtZTogVCxcbiAgICAuLi5hcmdzOiBDb25zb2xlW1RdIGV4dGVuZHMgKC4uLmFyZ3M6IGluZmVyIFApID0+IGFueSA/IFAgOiBuZXZlcltdXG4gICkgPT4gdm9pZFxuKTogKCkgPT4gdm9pZCB7XG4gIGNvbnN0IGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbnNvbGUsIG1ldGhvZE5hbWUpXG4gIGlmIChcbiAgICBkZXNjcmlwdG9yICYmXG4gICAgKGRlc2NyaXB0b3IuY29uZmlndXJhYmxlIHx8IGRlc2NyaXB0b3Iud3JpdGFibGUpICYmXG4gICAgdHlwZW9mIGRlc2NyaXB0b3IudmFsdWUgPT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgY29uc3Qgb3JpZ2luYWxNZXRob2QgPSBkZXNjcmlwdG9yLnZhbHVlIGFzIENvbnNvbGVbVF0gZXh0ZW5kcyAoXG4gICAgICAuLi5hcmdzOiBhbnlbXVxuICAgICkgPT4gYW55XG4gICAgICA/IENvbnNvbGVbVF1cbiAgICAgIDogbmV2ZXJcbiAgICBjb25zdCBvcmlnaW5hbE5hbWUgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9yaWdpbmFsTWV0aG9kLCAnbmFtZScpXG4gICAgY29uc3Qgd3JhcHBlck1ldGhvZCA9IGZ1bmN0aW9uIChcbiAgICAgIHRoaXM6IHR5cGVvZiBjb25zb2xlLFxuICAgICAgLi4uYXJnczogQ29uc29sZVtUXSBleHRlbmRzICguLi5hcmdzOiBpbmZlciBQKSA9PiBhbnkgPyBQIDogbmV2ZXJbXVxuICAgICkge1xuICAgICAgd3JhcHBlcihtZXRob2ROYW1lLCAuLi5hcmdzKVxuXG4gICAgICBvcmlnaW5hbE1ldGhvZC5hcHBseSh0aGlzLCBhcmdzKVxuICAgIH1cbiAgICBpZiAob3JpZ2luYWxOYW1lKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod3JhcHBlck1ldGhvZCwgJ25hbWUnLCBvcmlnaW5hbE5hbWUpXG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb25zb2xlLCBtZXRob2ROYW1lLCB7XG4gICAgICB2YWx1ZTogd3JhcHBlck1ldGhvZCxcbiAgICB9KVxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb25zb2xlLCBtZXRob2ROYW1lLCB7XG4gICAgICAgIHZhbHVlOiBvcmlnaW5hbE1ldGhvZCxcbiAgICAgICAgd3JpdGFibGU6IGRlc2NyaXB0b3Iud3JpdGFibGUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZGVzY3JpcHRvci5jb25maWd1cmFibGUsXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAoKSA9PiB7fVxufVxuIl0sIm5hbWVzIjpbIlVOREVGSU5FRF9NQVJLRVIiLCJwYXRjaENvbnNvbGVNZXRob2QiLCJtZXRob2ROYW1lIiwid3JhcHBlciIsImRlc2NyaXB0b3IiLCJPYmplY3QiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJjb25zb2xlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJ2YWx1ZSIsIm9yaWdpbmFsTWV0aG9kIiwib3JpZ2luYWxOYW1lIiwid3JhcHBlck1ldGhvZCIsImFyZ3MiLCJhcHBseSIsImRlZmluZVByb3BlcnR5Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztJQWtFYUEsZ0JBQWdCLEVBQUE7ZUFBaEJBOztJQUdHQyxrQkFBa0IsRUFBQTtlQUFsQkE7OztBQUhULE1BQU1ELG1CQUFtQjtBQUd6QixTQUFTQyxtQkFDZEMsVUFBYSxFQUNiQyxPQUdTO0lBRVQsTUFBTUMsYUFBYUMsT0FBT0Msd0JBQXdCLENBQUNDLFNBQVNMO0lBQzVELElBQ0VFLGNBQ0NBLENBQUFBLFdBQVdJLFlBQVksSUFBSUosV0FBV0ssUUFBTyxLQUM5QyxPQUFPTCxXQUFXTSxLQUFLLEtBQUssWUFDNUI7UUFDQSxNQUFNQyxpQkFBaUJQLFdBQVdNLEtBQUs7UUFLdkMsTUFBTUUsZUFBZVAsT0FBT0Msd0JBQXdCLENBQUNLLGdCQUFnQjtRQUNyRSxNQUFNRSxnQkFBZ0I7WUFFcEIsSUFBQSxJQUFBLE9BQUEsVUFBQSxNQUFBLEVBQUdDLE9BQUgsSUFBQSxNQUFBLE9BQUEsT0FBQSxHQUFBLE9BQUEsTUFBQSxPQUFBO2dCQUFHQSxJQUFBQSxDQUFILEtBQUEsR0FBQSxTQUFBLENBQUEsS0FBbUU7O1lBRW5FWCxRQUFRRCxlQUFlWTtZQUV2QkgsZUFBZUksS0FBSyxDQUFDLElBQUksRUFBRUQ7UUFDN0I7UUFDQSxJQUFJRixjQUFjO1lBQ2hCUCxPQUFPVyxjQUFjLENBQUNILGVBQWUsUUFBUUQ7UUFDL0M7UUFDQVAsT0FBT1csY0FBYyxDQUFDVCxTQUFTTCxZQUFZO1lBQ3pDUSxPQUFPRztRQUNUO1FBRUEsT0FBTztZQUNMUixPQUFPVyxjQUFjLENBQUNULFNBQVNMLFlBQVk7Z0JBQ3pDUSxPQUFPQztnQkFDUEYsVUFBVUwsV0FBV0ssUUFBUTtnQkFDN0JELGNBQWNKLFdBQVdJLFlBQVk7WUFDdkM7UUFDRjtJQUNGO0lBRUEsT0FBTyxLQUFPO0FBQ2hCIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDc0NTgsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvbmV4dC1kZXZ0b29scy91c2Vyc3BhY2UvYXBwL2ZvcndhcmQtbG9ncy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICduZXh0L2Rpc3QvY29tcGlsZWQvc2FmZS1zdGFibGUtc3RyaW5naWZ5J1xuaW1wb3J0IHtcbiAgZ2V0T3duZXJTdGFjayxcbiAgc2V0T3duZXJTdGFja0lmQXZhaWxhYmxlLFxufSBmcm9tICcuL2Vycm9ycy9zdGl0Y2hlZC1lcnJvcidcbmltcG9ydCB7IGdldEVycm9yU291cmNlIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2xpYi9lcnJvci1zb3VyY2UnXG5pbXBvcnQge1xuICBnZXRUZXJtaW5hbExvZ2dpbmdDb25maWcsXG4gIGdldElzVGVybWluYWxMb2dnaW5nRW5hYmxlZCxcbn0gZnJvbSAnLi90ZXJtaW5hbC1sb2dnaW5nLWNvbmZpZydcbmltcG9ydCB7XG4gIHR5cGUgQ29uc29sZUVudHJ5LFxuICB0eXBlIENvbnNvbGVFcnJvckVudHJ5LFxuICB0eXBlIEZvcm1hdHRlZEVycm9yRW50cnksXG4gIHR5cGUgQ2xpZW50TG9nRW50cnksXG4gIHR5cGUgTG9nTWV0aG9kLFxuICBwYXRjaENvbnNvbGVNZXRob2QsXG4gIFVOREVGSU5FRF9NQVJLRVIsXG59IGZyb20gJy4uLy4uL3NoYXJlZC9mb3J3YXJkLWxvZ3Mtc2hhcmVkJ1xuXG5jb25zdCB0ZXJtaW5hbExvZ2dpbmdDb25maWcgPSBnZXRUZXJtaW5hbExvZ2dpbmdDb25maWcoKVxuZXhwb3J0IGNvbnN0IFBST01JU0VfTUFSS0VSID0gJ1Byb21pc2Uge30nXG5leHBvcnQgY29uc3QgVU5BVkFJTEFCTEVfTUFSS0VSID0gJ1tVbmFibGUgdG8gdmlld10nXG5cbmNvbnN0IG1heGltdW1EZXB0aCA9XG4gIHR5cGVvZiB0ZXJtaW5hbExvZ2dpbmdDb25maWcgPT09ICdvYmplY3QnICYmIHRlcm1pbmFsTG9nZ2luZ0NvbmZpZy5kZXB0aExpbWl0XG4gICAgPyB0ZXJtaW5hbExvZ2dpbmdDb25maWcuZGVwdGhMaW1pdFxuICAgIDogNVxuY29uc3QgbWF4aW11bUJyZWFkdGggPVxuICB0eXBlb2YgdGVybWluYWxMb2dnaW5nQ29uZmlnID09PSAnb2JqZWN0JyAmJiB0ZXJtaW5hbExvZ2dpbmdDb25maWcuZWRnZUxpbWl0XG4gICAgPyB0ZXJtaW5hbExvZ2dpbmdDb25maWcuZWRnZUxpbWl0XG4gICAgOiAxMDBcblxuY29uc3Qgc3RyaW5naWZ5ID0gY29uZmlndXJlKHtcbiAgbWF4aW11bURlcHRoLFxuICBtYXhpbXVtQnJlYWR0aCxcbn0pXG5cbmV4cG9ydCBjb25zdCBpc1Rlcm1pbmFsTG9nZ2luZ0VuYWJsZWQgPSBnZXRJc1Rlcm1pbmFsTG9nZ2luZ0VuYWJsZWQoKVxuXG5jb25zdCBtZXRob2RzOiBBcnJheTxMb2dNZXRob2Q+ID0gW1xuICAnbG9nJyxcbiAgJ2luZm8nLFxuICAnd2FybicsXG4gICdkZWJ1ZycsXG4gICd0YWJsZScsXG4gICdhc3NlcnQnLFxuICAnZGlyJyxcbiAgJ2RpcnhtbCcsXG4gICdncm91cCcsXG4gICdncm91cENvbGxhcHNlZCcsXG4gICdncm91cEVuZCcsXG4gICd0cmFjZScsXG5dXG4vKipcbiAqIGFsbG93cyB1cyB0bzpcbiAqIC0gcmV2aXZlIHRoZSB1bmRlZmluZWQgbG9nIGluIHRoZSBzZXJ2ZXIgYXMgaXQgd291bGQgbG9vayBpbiB0aGUgYnJvd3NlclxuICogLSBub3QgcmVhZC9hdHRlbXB0IHRvIHNlcmlhbGl6ZSBwcm9taXNlcyAobmV4dCB3aWxsIGNvbnNvbGUgZXJyb3IgaWYgeW91IGRvIHRoYXQsIGFuZCB3aWxsIGNhdXNlIHRoaXMgcHJvZ3JhbSB0byBpbmZpbml0ZWx5IHJlY3Vyc2UpXG4gKiAtIGlmIHdlIHJlYWQgYSBwcm94eSB0aGF0IHRocm93cyAobm8gd2F5IHRvIGRldGVjdCBpZiBzb21ldGhpbmcgaXMgYSBwcm94eSksIGV4cGxhaW4gdG8gdGhlIHVzZXIgd2UgY2FuJ3QgcmVhZCB0aGlzIGRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByZUxvZ1NlcmlhbGl6YXRpb25DbG9uZTxUPihcbiAgdmFsdWU6IFQsXG4gIHNlZW4gPSBuZXcgV2Vha01hcCgpXG4pOiBhbnkge1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIFVOREVGSU5FRF9NQVJLRVJcbiAgaWYgKHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHJldHVybiB2YWx1ZVxuICBpZiAoc2Vlbi5oYXModmFsdWUgYXMgb2JqZWN0KSkgcmV0dXJuIHNlZW4uZ2V0KHZhbHVlIGFzIG9iamVjdClcblxuICB0cnkge1xuICAgIE9iamVjdC5rZXlzKHZhbHVlIGFzIG9iamVjdClcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIFVOQVZBSUxBQkxFX01BUktFUlxuICB9XG5cbiAgdHJ5IHtcbiAgICBpZiAodHlwZW9mICh2YWx1ZSBhcyBhbnkpLnRoZW4gPT09ICdmdW5jdGlvbicpIHJldHVybiBQUk9NSVNFX01BUktFUlxuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gVU5BVkFJTEFCTEVfTUFSS0VSXG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBjb25zdCBvdXQ6IGFueVtdID0gW11cbiAgICBzZWVuLnNldCh2YWx1ZSwgb3V0KVxuICAgIGZvciAoY29uc3QgaXRlbSBvZiB2YWx1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgb3V0LnB1c2gocHJlTG9nU2VyaWFsaXphdGlvbkNsb25lKGl0ZW0sIHNlZW4pKVxuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIG91dC5wdXNoKFVOQVZBSUxBQkxFX01BUktFUilcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dFxuICB9XG5cbiAgY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpXG4gIGlmIChwcm90byA9PT0gT2JqZWN0LnByb3RvdHlwZSB8fCBwcm90byA9PT0gbnVsbCkge1xuICAgIGNvbnN0IG91dDogUmVjb3JkPHN0cmluZywgdW5rbm93bj4gPSB7fVxuICAgIHNlZW4uc2V0KHZhbHVlIGFzIG9iamVjdCwgb3V0KVxuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHZhbHVlIGFzIG9iamVjdCkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG91dFtrZXldID0gcHJlTG9nU2VyaWFsaXphdGlvbkNsb25lKCh2YWx1ZSBhcyBhbnkpW2tleV0sIHNlZW4pXG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgb3V0W2tleV0gPSBVTkFWQUlMQUJMRV9NQVJLRVJcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dFxuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSlcbn1cblxuLy8gb25seSBzYWZlIGlmIHBhc3NlZCBzYWZlQ2xvbmUgZGF0YVxuZXhwb3J0IGNvbnN0IGxvZ1N0cmluZ2lmeSA9IChkYXRhOiB1bmtub3duKTogc3RyaW5nID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXN1bHQgPSBzdHJpbmdpZnkoZGF0YSlcbiAgICByZXR1cm4gcmVzdWx0ID8/IGBcIiR7VU5BVkFJTEFCTEVfTUFSS0VSfVwiYFxuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gYFwiJHtVTkFWQUlMQUJMRV9NQVJLRVJ9XCJgXG4gIH1cbn1cblxuY29uc3QgYWZ0ZXJUaGlzRnJhbWUgPSAoY2I6ICgpID0+IHZvaWQpID0+IHtcbiAgbGV0IHRpbWVvdXQ6IFJldHVyblR5cGU8dHlwZW9mIHNldFRpbWVvdXQ+IHwgdW5kZWZpbmVkXG5cbiAgY29uc3QgcmFmSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGNiKClcbiAgICB9KVxuICB9KVxuXG4gIHJldHVybiAoKSA9PiB7XG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmSWQpXG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpXG4gIH1cbn1cblxubGV0IGlzUGF0Y2hlZCA9IGZhbHNlXG5cbmNvbnN0IHNlcmlhbGl6ZUVudHJpZXMgPSAoZW50cmllczogQXJyYXk8Q2xpZW50TG9nRW50cnk+KSA9PlxuICBlbnRyaWVzLm1hcCgoY2xpZW50RW50cnkpID0+IHtcbiAgICBzd2l0Y2ggKGNsaWVudEVudHJ5LmtpbmQpIHtcbiAgICAgIGNhc2UgJ2FueS1sb2dnZWQtZXJyb3InOlxuICAgICAgY2FzZSAnY29uc29sZSc6IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5jbGllbnRFbnRyeSxcbiAgICAgICAgICBhcmdzOiBjbGllbnRFbnRyeS5hcmdzLm1hcChzdHJpbmdpZnlVc2VyQXJnKSxcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2FzZSAnZm9ybWF0dGVkLWVycm9yJzoge1xuICAgICAgICByZXR1cm4gY2xpZW50RW50cnlcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgcmV0dXJuIG51bGwhXG4gICAgICB9XG4gICAgfVxuICB9KVxuXG5leHBvcnQgY29uc3QgbG9nUXVldWU6IHtcbiAgZW50cmllczogQXJyYXk8Q2xpZW50TG9nRW50cnk+XG4gIG9uU29ja2V0UmVhZHk6IChzb2NrZXQ6IFdlYlNvY2tldCkgPT4gdm9pZFxuICBmbHVzaFNjaGVkdWxlZDogYm9vbGVhblxuICBzb2NrZXQ6IFdlYlNvY2tldCB8IG51bGxcbiAgY2FuY2VsRmx1c2g6ICgoKSA9PiB2b2lkKSB8IG51bGxcbiAgc291cmNlVHlwZT86ICdzZXJ2ZXInIHwgJ2VkZ2Utc2VydmVyJ1xuICByb3V0ZXI6ICdhcHAnIHwgJ3BhZ2VzJyB8IG51bGxcbiAgc2NoZWR1bGVMb2dTZW5kOiAoZW50cnk6IENsaWVudExvZ0VudHJ5KSA9PiB2b2lkXG59ID0ge1xuICBlbnRyaWVzOiBbXSxcbiAgZmx1c2hTY2hlZHVsZWQ6IGZhbHNlLFxuICBjYW5jZWxGbHVzaDogbnVsbCxcbiAgc29ja2V0OiBudWxsLFxuICBzb3VyY2VUeXBlOiB1bmRlZmluZWQsXG4gIHJvdXRlcjogbnVsbCxcbiAgc2NoZWR1bGVMb2dTZW5kOiAoZW50cnk6IENsaWVudExvZ0VudHJ5KSA9PiB7XG4gICAgbG9nUXVldWUuZW50cmllcy5wdXNoKGVudHJ5KVxuICAgIGlmIChsb2dRdWV1ZS5mbHVzaFNjaGVkdWxlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIHNhZmUgdG8gZGVyZWYgYW5kIHVzZSBpbiBzZXRUaW1lb3V0IGNsb3N1cmUgc2luY2Ugd2UgY2FuY2VsIG9uIG5ldyBzb2NrZXRcbiAgICBjb25zdCBzb2NrZXQgPSBsb2dRdWV1ZS5zb2NrZXRcbiAgICBpZiAoIXNvY2tldCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gd2UgcHJvYmFibHkgZG9udCBuZWVkIHRoaXNcbiAgICBsb2dRdWV1ZS5mbHVzaFNjaGVkdWxlZCA9IHRydWVcblxuICAgIC8vIG5vbiBibG9ja2luZyBsb2cgZmx1c2gsIHJ1bnMgYXQgbW9zdCBvbmNlIHBlciBmcmFtZVxuICAgIGxvZ1F1ZXVlLmNhbmNlbEZsdXNoID0gYWZ0ZXJUaGlzRnJhbWUoKCkgPT4ge1xuICAgICAgbG9nUXVldWUuZmx1c2hTY2hlZHVsZWQgPSBmYWxzZVxuXG4gICAgICAvLyBqdXN0IGluY2FzZVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBldmVudDogJ2Jyb3dzZXItbG9ncycsXG4gICAgICAgICAgZW50cmllczogc2VyaWFsaXplRW50cmllcyhsb2dRdWV1ZS5lbnRyaWVzKSxcbiAgICAgICAgICByb3V0ZXI6IGxvZ1F1ZXVlLnJvdXRlcixcbiAgICAgICAgICAvLyBuZWVkZWQgZm9yIHNvdXJjZSBtYXBwaW5nLCB3ZSBqdXN0IGFzc2lnbiB0aGUgc291cmNlVHlwZSBmcm9tIHRoZSBsYXN0IGVycm9yIGZvciB0aGUgd2hvbGUgYmF0Y2hcbiAgICAgICAgICBzb3VyY2VUeXBlOiBsb2dRdWV1ZS5zb3VyY2VUeXBlLFxuICAgICAgICB9KVxuXG4gICAgICAgIHNvY2tldC5zZW5kKHBheWxvYWQpXG4gICAgICAgIGxvZ1F1ZXVlLmVudHJpZXMgPSBbXVxuICAgICAgICBsb2dRdWV1ZS5zb3VyY2VUeXBlID0gdW5kZWZpbmVkXG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgLy8gZXJyb3IgKG1ha2Ugc3VyZSB1IGRvbid0IGluZmluaXRlIGxvb3ApXG4gICAgICAgIC8qIG5vb3AgKi9cbiAgICAgIH1cbiAgICB9KVxuICB9LFxuICBvblNvY2tldFJlYWR5OiAoc29ja2V0OiBXZWJTb2NrZXQpID0+IHtcbiAgICBpZiAoc29ja2V0LnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgICAvLyBpbnZhcmlhbnRcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIGluY2FzZSBhbiBleGlzdGluZyB0aW1lb3V0IHdhcyBnb2luZyB0byBydW4gd2l0aCBhIHN0YWxlIHNvY2tldFxuICAgIGxvZ1F1ZXVlLmNhbmNlbEZsdXNoPy4oKVxuICAgIGxvZ1F1ZXVlLnNvY2tldCA9IHNvY2tldFxuICAgIHRyeSB7XG4gICAgICBjb25zdCBwYXlsb2FkID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBldmVudDogJ2Jyb3dzZXItbG9ncycsXG4gICAgICAgIGVudHJpZXM6IHNlcmlhbGl6ZUVudHJpZXMobG9nUXVldWUuZW50cmllcyksXG4gICAgICAgIHJvdXRlcjogbG9nUXVldWUucm91dGVyLFxuICAgICAgICBzb3VyY2VUeXBlOiBsb2dRdWV1ZS5zb3VyY2VUeXBlLFxuICAgICAgfSlcblxuICAgICAgc29ja2V0LnNlbmQocGF5bG9hZClcbiAgICAgIGxvZ1F1ZXVlLmVudHJpZXMgPSBbXVxuICAgICAgbG9nUXVldWUuc291cmNlVHlwZSA9IHVuZGVmaW5lZFxuICAgIH0gY2F0Y2gge1xuICAgICAgLyoqIG5vb3AganVzdCBpbmNhc2UgKi9cbiAgICB9XG4gIH0sXG59XG5cbmNvbnN0IHN0cmluZ2lmeVVzZXJBcmcgPSAoXG4gIGFyZzpcbiAgICB8IHtcbiAgICAgICAga2luZDogJ2FyZydcbiAgICAgICAgZGF0YTogdW5rbm93blxuICAgICAgfVxuICAgIHwge1xuICAgICAgICBraW5kOiAnZm9ybWF0dGVkLWVycm9yLWFyZydcbiAgICAgIH1cbikgPT4ge1xuICBpZiAoYXJnLmtpbmQgIT09ICdhcmcnKSB7XG4gICAgcmV0dXJuIGFyZ1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4uYXJnLFxuICAgIGRhdGE6IGxvZ1N0cmluZ2lmeShhcmcuZGF0YSksXG4gIH1cbn1cblxuY29uc3QgY3JlYXRlRXJyb3JBcmcgPSAoZXJyb3I6IEVycm9yKSA9PiB7XG4gIGNvbnN0IHN0YWNrID0gc3RhY2tXaXRoT3duZXJzKGVycm9yKVxuICByZXR1cm4ge1xuICAgIGtpbmQ6ICdmb3JtYXR0ZWQtZXJyb3ItYXJnJyBhcyBjb25zdCxcbiAgICBwcmVmaXg6IGVycm9yLm1lc3NhZ2UgPyBgJHtlcnJvci5uYW1lfTogJHtlcnJvci5tZXNzYWdlfWAgOiBgJHtlcnJvci5uYW1lfWAsXG4gICAgc3RhY2ssXG4gIH1cbn1cblxuY29uc3QgY3JlYXRlTG9nRW50cnkgPSAobGV2ZWw6IExvZ01ldGhvZCwgYXJnczogYW55W10pID0+IHtcbiAgLy8gZG8gbm90IGFic3RyYWN0IHRoaXMsIGl0IGltcGxpY2l0bHkgcmVsaWVzIG9uIHdoaWNoIGZ1bmN0aW9ucyBjYWxsIGl0LiBmb3JjaW5nIHRoZSBpbmxpbmVkIGltcGxlbWVudGF0aW9uIG1ha2VzIHlvdSB0aGluayBhYm91dCBjYWxsZXJzXG4gIC8vIGVycm9yIGNhcHR1cmUgc3RhY2sgdHJhY2UgbWF5YmVcbiAgY29uc3Qgc3RhY2sgPSBzdGFja1dpdGhPd25lcnMobmV3IEVycm9yKCkpXG4gIGNvbnN0IHN0YWNrTGluZXMgPSBzdGFjaz8uc3BsaXQoJ1xcbicpXG4gIGNvbnN0IGNsZWFuU3RhY2sgPSBzdGFja0xpbmVzPy5zbGljZSgzKS5qb2luKCdcXG4nKSAvLyB0aGlzIGlzIHByb2JhYmx5IGlnbm9yZWQgYW55d2F5c1xuICBjb25zdCBlbnRyeTogQ29uc29sZUVudHJ5PHVua25vd24+ID0ge1xuICAgIGtpbmQ6ICdjb25zb2xlJyxcbiAgICBjb25zb2xlTWV0aG9kU3RhY2s6IGNsZWFuU3RhY2sgPz8gbnVsbCwgLy8gZGVwZW5kaW5nIG9uIGJyb3dzZXIgd2UgbWlnaHQgbm90IGhhdmUgc3RhY2tcbiAgICBtZXRob2Q6IGxldmVsLFxuICAgIGFyZ3M6IGFyZ3MubWFwKChhcmcpID0+IHtcbiAgICAgIGlmIChhcmcgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICByZXR1cm4gY3JlYXRlRXJyb3JBcmcoYXJnKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2luZDogJ2FyZycsXG4gICAgICAgIGRhdGE6IHByZUxvZ1NlcmlhbGl6YXRpb25DbG9uZShhcmcpLFxuICAgICAgfVxuICAgIH0pLFxuICB9XG5cbiAgbG9nUXVldWUuc2NoZWR1bGVMb2dTZW5kKGVudHJ5KVxufVxuXG5leHBvcnQgY29uc3QgZm9yd2FyZEVycm9yTG9nID0gKGFyZ3M6IGFueVtdKSA9PiB7XG4gIGNvbnN0IGVycm9yT2JqZWN0cyA9IGFyZ3MuZmlsdGVyKChhcmcpID0+IGFyZyBpbnN0YW5jZW9mIEVycm9yKVxuICBjb25zdCBmaXJzdCA9IGVycm9yT2JqZWN0cy5hdCgwKVxuICBpZiAoZmlyc3QpIHtcbiAgICBjb25zdCBzb3VyY2UgPSBnZXRFcnJvclNvdXJjZShmaXJzdClcbiAgICBpZiAoc291cmNlKSB7XG4gICAgICBsb2dRdWV1ZS5zb3VyY2VUeXBlID0gc291cmNlXG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBicm93c2VyIHNob3dzIHN0YWNrIHJlZ2FyZGxlc3Mgb2YgdHlwZSBvZiBkYXRhIHBhc3NlZCB0byBjb25zb2xlLmVycm9yLCBzbyB3ZSBzaG91bGQgZG8gdGhlIHNhbWVcbiAgICpcbiAgICogZG8gbm90IGFic3RyYWN0IHRoaXMsIGl0IGltcGxpY2l0bHkgcmVsaWVzIG9uIHdoaWNoIGZ1bmN0aW9ucyBjYWxsIGl0LiBmb3JjaW5nIHRoZSBpbmxpbmVkIGltcGxlbWVudGF0aW9uIG1ha2VzIHlvdSB0aGluayBhYm91dCBjYWxsZXJzXG4gICAqL1xuICBjb25zdCBzdGFjayA9IHN0YWNrV2l0aE93bmVycyhuZXcgRXJyb3IoKSlcbiAgY29uc3Qgc3RhY2tMaW5lcyA9IHN0YWNrPy5zcGxpdCgnXFxuJylcbiAgY29uc3QgY2xlYW5TdGFjayA9IHN0YWNrTGluZXM/LnNsaWNlKDMpLmpvaW4oJ1xcbicpXG5cbiAgY29uc3QgZW50cnk6IENvbnNvbGVFcnJvckVudHJ5PHVua25vd24+ID0ge1xuICAgIGtpbmQ6ICdhbnktbG9nZ2VkLWVycm9yJyxcbiAgICBtZXRob2Q6ICdlcnJvcicsXG4gICAgY29uc29sZUVycm9yU3RhY2s6IGNsZWFuU3RhY2sgPz8gJycsXG4gICAgYXJnczogYXJncy5tYXAoKGFyZykgPT4ge1xuICAgICAgaWYgKGFyZyBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVFcnJvckFyZyhhcmcpXG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBraW5kOiAnYXJnJyxcbiAgICAgICAgZGF0YTogcHJlTG9nU2VyaWFsaXphdGlvbkNsb25lKGFyZyksXG4gICAgICB9XG4gICAgfSksXG4gIH1cblxuICBsb2dRdWV1ZS5zY2hlZHVsZUxvZ1NlbmQoZW50cnkpXG59XG5cbmNvbnN0IGNyZWF0ZVVuY2F1Z2h0RXJyb3JFbnRyeSA9IChcbiAgZXJyb3JOYW1lOiBzdHJpbmcsXG4gIGVycm9yTWVzc2FnZTogc3RyaW5nLFxuICBmdWxsU3RhY2s6IHN0cmluZ1xuKSA9PiB7XG4gIGNvbnN0IGVudHJ5OiBGb3JtYXR0ZWRFcnJvckVudHJ5ID0ge1xuICAgIGtpbmQ6ICdmb3JtYXR0ZWQtZXJyb3InLFxuICAgIHByZWZpeDogYFVuY2F1Z2h0ICR7ZXJyb3JOYW1lfTogJHtlcnJvck1lc3NhZ2V9YCxcbiAgICBzdGFjazogZnVsbFN0YWNrLFxuICAgIG1ldGhvZDogJ2Vycm9yJyxcbiAgfVxuXG4gIGxvZ1F1ZXVlLnNjaGVkdWxlTG9nU2VuZChlbnRyeSlcbn1cblxuY29uc3Qgc3RhY2tXaXRoT3duZXJzID0gKGVycm9yOiBFcnJvcikgPT4ge1xuICBsZXQgb3duZXJTdGFjayA9ICcnXG4gIHNldE93bmVyU3RhY2tJZkF2YWlsYWJsZShlcnJvcilcbiAgb3duZXJTdGFjayA9IGdldE93bmVyU3RhY2soZXJyb3IpIHx8ICcnXG4gIGNvbnN0IHN0YWNrID0gKGVycm9yLnN0YWNrIHx8ICcnKSArIG93bmVyU3RhY2tcbiAgcmV0dXJuIHN0YWNrXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2dVbmhhbmRsZWRSZWplY3Rpb24ocmVhc29uOiB1bmtub3duKSB7XG4gIGlmIChyZWFzb24gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIGNyZWF0ZVVuaGFuZGxlZFJlamVjdGlvbkVycm9yRW50cnkocmVhc29uLCBzdGFja1dpdGhPd25lcnMocmVhc29uKSlcbiAgICByZXR1cm5cbiAgfVxuICBjcmVhdGVVbmhhbmRsZWRSZWplY3Rpb25Ob25FcnJvckVudHJ5KHJlYXNvbilcbn1cblxuY29uc3QgY3JlYXRlVW5oYW5kbGVkUmVqZWN0aW9uRXJyb3JFbnRyeSA9IChcbiAgZXJyb3I6IEVycm9yLFxuICBmdWxsU3RhY2s6IHN0cmluZ1xuKSA9PiB7XG4gIGNvbnN0IHNvdXJjZSA9IGdldEVycm9yU291cmNlKGVycm9yKVxuICBpZiAoc291cmNlKSB7XG4gICAgbG9nUXVldWUuc291cmNlVHlwZSA9IHNvdXJjZVxuICB9XG5cbiAgY29uc3QgZW50cnk6IENsaWVudExvZ0VudHJ5ID0ge1xuICAgIGtpbmQ6ICdmb3JtYXR0ZWQtZXJyb3InLFxuICAgIHByZWZpeDogYOKoryB1bmhhbmRsZWRSZWplY3Rpb246ICR7ZXJyb3IubmFtZX06ICR7ZXJyb3IubWVzc2FnZX1gLFxuICAgIHN0YWNrOiBmdWxsU3RhY2ssXG4gICAgbWV0aG9kOiAnZXJyb3InLFxuICB9XG5cbiAgbG9nUXVldWUuc2NoZWR1bGVMb2dTZW5kKGVudHJ5KVxufVxuXG5jb25zdCBjcmVhdGVVbmhhbmRsZWRSZWplY3Rpb25Ob25FcnJvckVudHJ5ID0gKHJlYXNvbjogdW5rbm93bikgPT4ge1xuICBjb25zdCBlbnRyeTogQ2xpZW50TG9nRW50cnkgPSB7XG4gICAga2luZDogJ2FueS1sb2dnZWQtZXJyb3InLFxuICAgIC8vIHdlIGNhbid0IGFjY2VzcyB0aGUgc3RhY2sgc2luY2UgdGhlIGV2ZW50IGlzIGRpc3BhdGNoZWQgYXN5bmMgYW5kIGNyZWF0aW5nIGFuIGlubGluZSBlcnJvciB3b3VsZCBiZSBtZWFuaW5nbGVzc1xuICAgIGNvbnNvbGVFcnJvclN0YWNrOiAnJyxcbiAgICBtZXRob2Q6ICdlcnJvcicsXG4gICAgYXJnczogW1xuICAgICAge1xuICAgICAgICBraW5kOiAnYXJnJyxcbiAgICAgICAgZGF0YTogYOKoryB1bmhhbmRsZWRSZWplY3Rpb246YCxcbiAgICAgICAgaXNSZWplY3Rpb25NZXNzYWdlOiB0cnVlLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAga2luZDogJ2FyZycsXG4gICAgICAgIGRhdGE6IHByZUxvZ1NlcmlhbGl6YXRpb25DbG9uZShyZWFzb24pLFxuICAgICAgfSxcbiAgICBdLFxuICB9XG5cbiAgbG9nUXVldWUuc2NoZWR1bGVMb2dTZW5kKGVudHJ5KVxufVxuXG5jb25zdCBpc0hNUiA9IChhcmdzOiBhbnlbXSkgPT4ge1xuICBjb25zdCBmaXJzdEFyZyA9IGFyZ3NbMF1cbiAgaWYgKHR5cGVvZiBmaXJzdEFyZyAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBpZiAoZmlyc3RBcmcuc3RhcnRzV2l0aCgnW0Zhc3QgUmVmcmVzaF0nKSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpZiAoZmlyc3RBcmcuc3RhcnRzV2l0aCgnW0hNUl0nKSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn1cblxuY29uc3QgaXNJZ25vcmVkTG9nID0gKGFyZ3M6IGFueVtdKSA9PiB7XG4gIGlmIChhcmdzLmxlbmd0aCA8IDMpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGNvbnN0IFtmb3JtYXQsIHN0eWxlcywgbGFiZWxdID0gYXJnc1xuXG4gIGlmIChcbiAgICB0eXBlb2YgZm9ybWF0ICE9PSAnc3RyaW5nJyB8fFxuICAgIHR5cGVvZiBzdHlsZXMgIT09ICdzdHJpbmcnIHx8XG4gICAgdHlwZW9mIGxhYmVsICE9PSAnc3RyaW5nJ1xuICApIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIGtpbmRhIGhhY2t5LCB3ZSBzaG91bGQgZGVmaW5lIGEgY29tbW9uIGZvcm1hdCBmb3IgdGhlc2Ugc3RyaW5ncyBzbyB3ZSBjYW4gc2FmZWx5IGlnbm9yZVxuICByZXR1cm4gZm9ybWF0LnN0YXJ0c1dpdGgoJyVjJXMlYycpICYmIHN0eWxlcy5pbmNsdWRlcygnYmFja2dyb3VuZDonKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9yd2FyZFVuaGFuZGxlZEVycm9yKGVycm9yOiBFcnJvcikge1xuICBjcmVhdGVVbmNhdWdodEVycm9yRW50cnkoZXJyb3IubmFtZSwgZXJyb3IubWVzc2FnZSwgc3RhY2tXaXRoT3duZXJzKGVycm9yKSlcbn1cblxuLy8gVE9ETzogdGhpcyByb3V0ZXIgY2hlY2sgaXMgYnJpdHRsZSwgd2UgbmVlZCB0byB1cGRhdGUgYmFzZWQgb24gdGhlIGN1cnJlbnQgcm91dGVyIHRoZSB1c2VyIGlzIHVzaW5nXG5leHBvcnQgY29uc3QgaW5pdGlhbGl6ZURlYnVnTG9nRm9yd2FyZGluZyA9IChyb3V0ZXI6ICdhcHAnIHwgJ3BhZ2VzJyk6IHZvaWQgPT4ge1xuICAvLyBwcm9iYWJseSBkb24ndCBuZWVkIHRoaXNcbiAgaWYgKGlzUGF0Y2hlZCkge1xuICAgIHJldHVyblxuICB9XG4gIC8vIFRPRE8ocm9iKTogd2h5IGRvZXMgdGhpcyBicmVhayByZW5kZXJpbmcgb24gc2VydmVyLCBpbXBvcnRhbnQgdG8ga25vdyBpbmNhc2UgdGhlIHNhbWUgYnVnIGFwcGVhcnMgaW4gYnJvd3NlclxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGJldHRlciB0byBiZSBzYWZlIHRoYW4gc29ycnlcbiAgdHJ5IHtcbiAgICBtZXRob2RzLmZvckVhY2goKG1ldGhvZCkgPT5cbiAgICAgIHBhdGNoQ29uc29sZU1ldGhvZChtZXRob2QsIChfLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgIGlmIChpc0hNUihhcmdzKSkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGlmIChpc0lnbm9yZWRMb2coYXJncykpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBjcmVhdGVMb2dFbnRyeShtZXRob2QsIGFyZ3MpXG4gICAgICB9KVxuICAgIClcbiAgfSBjYXRjaCB7fVxuICBsb2dRdWV1ZS5yb3V0ZXIgPSByb3V0ZXJcbiAgaXNQYXRjaGVkID0gdHJ1ZVxufVxuIl0sIm5hbWVzIjpbIlBST01JU0VfTUFSS0VSIiwiVU5BVkFJTEFCTEVfTUFSS0VSIiwiZm9yd2FyZEVycm9yTG9nIiwiZm9yd2FyZFVuaGFuZGxlZEVycm9yIiwiaW5pdGlhbGl6ZURlYnVnTG9nRm9yd2FyZGluZyIsImlzVGVybWluYWxMb2dnaW5nRW5hYmxlZCIsImxvZ1F1ZXVlIiwibG9nU3RyaW5naWZ5IiwibG9nVW5oYW5kbGVkUmVqZWN0aW9uIiwicHJlTG9nU2VyaWFsaXphdGlvbkNsb25lIiwidGVybWluYWxMb2dnaW5nQ29uZmlnIiwiZ2V0VGVybWluYWxMb2dnaW5nQ29uZmlnIiwibWF4aW11bURlcHRoIiwiZGVwdGhMaW1pdCIsIm1heGltdW1CcmVhZHRoIiwiZWRnZUxpbWl0Iiwic3RyaW5naWZ5IiwiY29uZmlndXJlIiwiZ2V0SXNUZXJtaW5hbExvZ2dpbmdFbmFibGVkIiwibWV0aG9kcyIsInZhbHVlIiwic2VlbiIsIldlYWtNYXAiLCJ1bmRlZmluZWQiLCJVTkRFRklORURfTUFSS0VSIiwiaGFzIiwiZ2V0IiwiT2JqZWN0Iiwia2V5cyIsInRoZW4iLCJBcnJheSIsImlzQXJyYXkiLCJvdXQiLCJzZXQiLCJpdGVtIiwicHVzaCIsInByb3RvIiwiZ2V0UHJvdG90eXBlT2YiLCJwcm90b3R5cGUiLCJrZXkiLCJ0b1N0cmluZyIsImNhbGwiLCJkYXRhIiwicmVzdWx0IiwiYWZ0ZXJUaGlzRnJhbWUiLCJjYiIsInRpbWVvdXQiLCJyYWZJZCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInNldFRpbWVvdXQiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImNsZWFyVGltZW91dCIsImlzUGF0Y2hlZCIsInNlcmlhbGl6ZUVudHJpZXMiLCJlbnRyaWVzIiwibWFwIiwiY2xpZW50RW50cnkiLCJraW5kIiwiYXJncyIsInN0cmluZ2lmeVVzZXJBcmciLCJmbHVzaFNjaGVkdWxlZCIsImNhbmNlbEZsdXNoIiwic29ja2V0Iiwic291cmNlVHlwZSIsInJvdXRlciIsInNjaGVkdWxlTG9nU2VuZCIsImVudHJ5IiwicGF5bG9hZCIsIkpTT04iLCJldmVudCIsInNlbmQiLCJvblNvY2tldFJlYWR5IiwicmVhZHlTdGF0ZSIsIldlYlNvY2tldCIsIk9QRU4iLCJhcmciLCJjcmVhdGVFcnJvckFyZyIsImVycm9yIiwic3RhY2siLCJzdGFja1dpdGhPd25lcnMiLCJwcmVmaXgiLCJtZXNzYWdlIiwibmFtZSIsImNyZWF0ZUxvZ0VudHJ5IiwibGV2ZWwiLCJFcnJvciIsInN0YWNrTGluZXMiLCJzcGxpdCIsImNsZWFuU3RhY2siLCJzbGljZSIsImpvaW4iLCJjb25zb2xlTWV0aG9kU3RhY2siLCJtZXRob2QiLCJlcnJvck9iamVjdHMiLCJmaWx0ZXIiLCJmaXJzdCIsImF0Iiwic291cmNlIiwiZ2V0RXJyb3JTb3VyY2UiLCJjb25zb2xlRXJyb3JTdGFjayIsImNyZWF0ZVVuY2F1Z2h0RXJyb3JFbnRyeSIsImVycm9yTmFtZSIsImVycm9yTWVzc2FnZSIsImZ1bGxTdGFjayIsIm93bmVyU3RhY2siLCJzZXRPd25lclN0YWNrSWZBdmFpbGFibGUiLCJnZXRPd25lclN0YWNrIiwicmVhc29uIiwiY3JlYXRlVW5oYW5kbGVkUmVqZWN0aW9uRXJyb3JFbnRyeSIsImNyZWF0ZVVuaGFuZGxlZFJlamVjdGlvbk5vbkVycm9yRW50cnkiLCJpc1JlamVjdGlvbk1lc3NhZ2UiLCJpc0hNUiIsImZpcnN0QXJnIiwic3RhcnRzV2l0aCIsImlzSWdub3JlZExvZyIsImxlbmd0aCIsImZvcm1hdCIsInN0eWxlcyIsImxhYmVsIiwiaW5jbHVkZXMiLCJ3aW5kb3ciLCJmb3JFYWNoIiwicGF0Y2hDb25zb2xlTWV0aG9kIiwiXyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQXFCYUEsY0FBYyxFQUFBO2VBQWRBOztJQUNBQyxrQkFBa0IsRUFBQTtlQUFsQkE7O0lBeVFBQyxlQUFlLEVBQUE7ZUFBZkE7O0lBK0lHQyxxQkFBcUIsRUFBQTtlQUFyQkE7O0lBS0hDLDRCQUE0QixFQUFBO2VBQTVCQTs7SUE3WUFDLHdCQUF3QixFQUFBO2VBQXhCQTs7SUFzSEFDLFFBQVEsRUFBQTtlQUFSQTs7SUE3Q0FDLFlBQVksRUFBQTtlQUFaQTs7SUEyT0dDLHFCQUFxQixFQUFBO2VBQXJCQTs7SUE5UkFDLHdCQUF3QixFQUFBO2VBQXhCQTs7O3FDQTVEVTsrQkFJbkI7NkJBQ3dCO3VDQUl4QjttQ0FTQTtBQUVQLE1BQU1DLHdCQUF3QkMsQ0FBQUEsR0FBQUEsdUJBQUFBLHdCQUF3QjtBQUMvQyxNQUFNWCxpQkFBaUI7QUFDdkIsTUFB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ICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNzg2NCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9uZXh0LWRldnRvb2xzL3VzZXJzcGFjZS9hcHAvZXJyb3JzL3VzZS1lcnJvci1oYW5kbGVyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgaXNOZXh0Um91dGVyRXJyb3IgfSBmcm9tICcuLi8uLi8uLi8uLi9jbGllbnQvY29tcG9uZW50cy9pcy1uZXh0LXJvdXRlci1lcnJvcidcbmltcG9ydCB7XG4gIGZvcm1hdENvbnNvbGVBcmdzLFxuICBwYXJzZUNvbnNvbGVBcmdzLFxufSBmcm9tICcuLi8uLi8uLi8uLi9jbGllbnQvbGliL2NvbnNvbGUnXG5pbXBvcnQgaXNFcnJvciBmcm9tICcuLi8uLi8uLi8uLi9saWIvaXMtZXJyb3InXG5pbXBvcnQgeyBjcmVhdGVDb25zb2xlRXJyb3IgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc29sZS1lcnJvcidcbmltcG9ydCB7IGNvZXJjZUVycm9yLCBzZXRPd25lclN0YWNrSWZBdmFpbGFibGUgfSBmcm9tICcuL3N0aXRjaGVkLWVycm9yJ1xuaW1wb3J0IHtcbiAgZm9yd2FyZFVuaGFuZGxlZEVycm9yLFxuICBpc1Rlcm1pbmFsTG9nZ2luZ0VuYWJsZWQsXG4gIGxvZ1VuaGFuZGxlZFJlamVjdGlvbixcbn0gZnJvbSAnLi4vZm9yd2FyZC1sb2dzJ1xuXG5jb25zdCBxdWV1ZU1pY3JvVGFzayA9XG4gIGdsb2JhbFRoaXMucXVldWVNaWNyb3Rhc2sgfHwgKChjYjogKCkgPT4gdm9pZCkgPT4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihjYikpXG5cbmV4cG9ydCB0eXBlIEVycm9ySGFuZGxlciA9IChlcnJvcjogRXJyb3IpID0+IHZvaWRcblxuY29uc3QgZXJyb3JRdWV1ZTogQXJyYXk8RXJyb3I+ID0gW11cbmNvbnN0IGVycm9ySGFuZGxlcnM6IEFycmF5PEVycm9ySGFuZGxlcj4gPSBbXVxuY29uc3QgcmVqZWN0aW9uUXVldWU6IEFycmF5PEVycm9yPiA9IFtdXG5jb25zdCByZWplY3Rpb25IYW5kbGVyczogQXJyYXk8RXJyb3JIYW5kbGVyPiA9IFtdXG5cbmV4cG9ydCBmdW5jdGlvbiBoYW5kbGVDb25zb2xlRXJyb3IoXG4gIG9yaWdpbkVycm9yOiB1bmtub3duLFxuICBjb25zb2xlRXJyb3JBcmdzOiBhbnlbXVxuKSB7XG4gIGxldCBlcnJvcjogRXJyb3JcbiAgY29uc3QgeyBlbnZpcm9ubWVudE5hbWUgfSA9IHBhcnNlQ29uc29sZUFyZ3MoY29uc29sZUVycm9yQXJncylcbiAgaWYgKGlzRXJyb3Iob3JpZ2luRXJyb3IpKSB7XG4gICAgZXJyb3IgPSBjcmVhdGVDb25zb2xlRXJyb3Iob3JpZ2luRXJyb3IsIGVudmlyb25tZW50TmFtZSlcbiAgfSBlbHNlIHtcbiAgICBlcnJvciA9IGNyZWF0ZUNvbnNvbGVFcnJvcihcbiAgICAgIGZvcm1hdENvbnNvbGVBcmdzKGNvbnNvbGVFcnJvckFyZ3MpLFxuICAgICAgZW52aXJvbm1lbnROYW1lXG4gICAgKVxuICB9XG4gIHNldE93bmVyU3RhY2tJZkF2YWlsYWJsZShlcnJvcilcblxuICBlcnJvclF1ZXVlLnB1c2goZXJyb3IpXG4gIGZvciAoY29uc3QgaGFuZGxlciBvZiBlcnJvckhhbmRsZXJzKSB7XG4gICAgLy8gRGVsYXllZCB0aGUgZXJyb3IgYmVpbmcgcGFzc2VkIHRvIFJlYWN0IERldiBPdmVybGF5LFxuICAgIC8vIGF2b2lkIHRoZSBzdGF0ZSBiZWluZyBzeW5jaHJvbm91c2x5IHVwZGF0ZWQgaW4gdGhlIGNvbXBvbmVudC5cbiAgICBxdWV1ZU1pY3JvVGFzaygoKSA9PiB7XG4gICAgICBoYW5kbGVyKGVycm9yKVxuICAgIH0pXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhbmRsZUNsaWVudEVycm9yKGVycm9yOiBFcnJvcikge1xuICBlcnJvclF1ZXVlLnB1c2goZXJyb3IpXG4gIGZvciAoY29uc3QgaGFuZGxlciBvZiBlcnJvckhhbmRsZXJzKSB7XG4gICAgLy8gRGVsYXllZCB0aGUgZXJyb3IgYmVpbmcgcGFzc2VkIHRvIFJlYWN0IERldiBPdmVybGF5LFxuICAgIC8vIGF2b2lkIHRoZSBzdGF0ZSBiZWluZyBzeW5jaHJvbm91c2x5IHVwZGF0ZWQgaW4gdGhlIGNvbXBvbmVudC5cbiAgICBxdWV1ZU1pY3JvVGFzaygoKSA9PiB7XG4gICAgICBoYW5kbGVyKGVycm9yKVxuICAgIH0pXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUVycm9ySGFuZGxlcihcbiAgaGFuZGxlT25VbmhhbmRsZWRFcnJvcjogRXJyb3JIYW5kbGVyLFxuICBoYW5kbGVPblVuaGFuZGxlZFJlamVjdGlvbjogRXJyb3JIYW5kbGVyXG4pIHtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBIYW5kbGUgcXVldWVkIGVycm9ycy5cbiAgICBlcnJvclF1ZXVlLmZvckVhY2goaGFuZGxlT25VbmhhbmRsZWRFcnJvcilcbiAgICByZWplY3Rpb25RdWV1ZS5mb3JFYWNoKGhhbmRsZU9uVW5oYW5kbGVkUmVqZWN0aW9uKVxuXG4gICAgLy8gTGlzdGVuIHRvIG5ldyBlcnJvcnMuXG4gICAgZXJyb3JIYW5kbGVycy5wdXNoKGhhbmRsZU9uVW5oYW5kbGVkRXJyb3IpXG4gICAgcmVqZWN0aW9uSGFuZGxlcnMucHVzaChoYW5kbGVPblVuaGFuZGxlZFJlamVjdGlvbilcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAvLyBSZW1vdmUgbGlzdGVuZXJzLlxuICAgICAgZXJyb3JIYW5kbGVycy5zcGxpY2UoZXJyb3JIYW5kbGVycy5pbmRleE9mKGhhbmRsZU9uVW5oYW5kbGVkRXJyb3IpLCAxKVxuICAgICAgcmVqZWN0aW9uSGFuZGxlcnMuc3BsaWNlKFxuICAgICAgICByZWplY3Rpb25IYW5kbGVycy5pbmRleE9mKGhhbmRsZU9uVW5oYW5kbGVkUmVqZWN0aW9uKSxcbiAgICAgICAgMVxuICAgICAgKVxuXG4gICAgICAvLyBSZXNldCBlcnJvciBxdWV1ZXMuXG4gICAgICBlcnJvclF1ZXVlLnNwbGljZSgwLCBlcnJvclF1ZXVlLmxlbmd0aClcbiAgICAgIHJlamVjdGlvblF1ZXVlLnNwbGljZSgwLCByZWplY3Rpb25RdWV1ZS5sZW5ndGgpXG4gICAgfVxuICB9LCBbaGFuZGxlT25VbmhhbmRsZWRFcnJvciwgaGFuZGxlT25VbmhhbmRsZWRSZWplY3Rpb25dKVxufVxuXG5mdW5jdGlvbiBvblVuaGFuZGxlZEVycm9yKGV2ZW50OiBXaW5kb3dFdmVudE1hcFsnZXJyb3InXSk6IHZvaWQgfCBib29sZWFuIHtcbiAgY29uc3QgdGhyb3duVmFsdWU6IHVua25vd24gPSBldmVudC5lcnJvclxuICBpZiAoaXNOZXh0Um91dGVyRXJyb3IodGhyb3duVmFsdWUpKSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIC8vIFdoZW4gdGhlcmUncyBhbiBlcnJvciBwcm9wZXJ0eSBwcmVzZW50LCB3ZSBsb2cgdGhlIGVycm9yIHRvIGVycm9yIG92ZXJsYXkuXG4gIC8vIE90aGVyd2lzZSB3ZSBkb24ndCBkbyBhbnl0aGluZyBhcyBpdCdzIG5vdCBsb2dnaW5nIGluIHRoZSBjb25zb2xlIGVpdGhlci5cbiAgaWYgKHRocm93blZhbHVlKSB7XG4gICAgY29uc3QgZXJyb3IgPSBjb2VyY2VFcnJvcih0aHJvd25WYWx1ZSlcbiAgICBzZXRPd25lclN0YWNrSWZBdmFpbGFibGUoZXJyb3IpXG4gICAgaGFuZGxlQ2xpZW50RXJyb3IoZXJyb3IpXG4gICAgaWYgKGlzVGVybWluYWxMb2dnaW5nRW5hYmxlZCkge1xuICAgICAgZm9yd2FyZFVuaGFuZGxlZEVycm9yKGVycm9yKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBvblVuaGFuZGxlZFJlamVjdGlvbihldjogV2luZG93RXZlbnRNYXBbJ3VuaGFuZGxlZHJlamVjdGlvbiddKTogdm9pZCB7XG4gIGNvbnN0IHJlYXNvbjogdW5rbm93biA9IGV2Py5yZWFzb25cbiAgaWYgKGlzTmV4dFJvdXRlckVycm9yKHJlYXNvbikpIHtcbiAgICBldi5wcmV2ZW50RGVmYXVsdCgpXG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCBlcnJvciA9IGNvZXJjZUVycm9yKHJlYXNvbilcbiAgc2V0T3duZXJTdGFja0lmQXZhaWxhYmxlKGVycm9yKVxuXG4gIHJlamVjdGlvblF1ZXVlLnB1c2goZXJyb3IpXG4gIGZvciAoY29uc3QgaGFuZGxlciBvZiByZWplY3Rpb25IYW5kbGVycykge1xuICAgIGhhbmRsZXIoZXJyb3IpXG4gIH1cblxuICBpZiAoaXNUZXJtaW5hbExvZ2dpbmdFbmFibGVkKSB7XG4gICAgbG9nVW5oYW5kbGVkUmVqZWN0aW9uKHJlYXNvbilcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFuZGxlR2xvYmFsRXJyb3JzKCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0cnkge1xuICAgICAgLy8gSW5jcmVhc2UgdGhlIG51bWJlciBvZiBzdGFjayBmcmFtZXMgb24gdGhlIGNsaWVudFxuICAgICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gNTBcbiAgICB9IGNhdGNoIHt9XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvblVuaGFuZGxlZEVycm9yKVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd1bmhhbmRsZWRyZWplY3Rpb24nLCBvblVuaGFuZGxlZFJlamVjdGlvbilcbiAgfVxufVxuIl0sIm5hbWVzIjpbImhhbmRsZUNsaWVudEVycm9yIiwiaGFuZGxlQ29uc29sZUVycm9yIiwiaGFuZGxlR2xvYmFsRXJyb3JzIiwidXNlRXJyb3JIYW5kbGVyIiwicXVldWVNaWNyb1Rhc2siLCJnbG9iYWxUaGlzIiwicXVldWVNaWNyb3Rhc2siLCJjYiIsIlByb21pc2UiLCJyZXNvbHZlIiwidGhlbiIsImVycm9yUXVldWUiLCJlcnJvckhhbmRsZXJzIiwicmVqZWN0aW9uUXVldWUiLCJyZWplY3Rpb25IYW5kbGVycyIsIm9yaWdpbkVycm9yIiwiY29uc29sZUVycm9yQXJncyIsImVycm9yIiwiZW52aXJvbm1lbnROYW1lIiwicGFyc2VDb25zb2xlQXJncyIsImlzRXJyb3IiLCJjcmVhdGVDb25zb2xlRXJyb3IiLCJmb3JtYXRDb25zb2xlQXJncyIsInNldE93bmVyU3RhY2tJZkF2YWlsYWJsZSIsInB1c2giLCJoYW5kbGVyIiwiaGFuZGxlT25VbmhhbmRsZWRFcnJvciIsImhhbmRsZU9uVW5oYW5kbGVkUmVqZWN0aW9uIiwidXNlRWZmZWN0IiwiZm9yRWFjaCIsInNwbGljZSIsImluZGV4T2YiLCJsZW5ndGgiLCJvblVuaGFuZGxlZEVycm9yIiwiZXZlbnQiLCJ0aHJvd25WYWx1ZSIsImlzTmV4dFJvdXRlckVycm9yIiwicHJldmVudERlZmF1bHQiLCJjb2VyY2VFcnJvciIsImlzVGVybWluYWxMb2dnaW5nRW5hYmxlZCIsImZvcndhcmRVbmhhbmRsZWRFcnJvciIsIm9uVW5oYW5kbGVkUmVqZWN0aW9uIiwiZXYiLCJyZWFzb24iLCJsb2dVbmhhbmRsZWRSZWplY3Rpb24iLCJ3aW5kb3ciLCJFcnJvciIsInN0YWNrVHJhY2VMaW1pdCIsImFkZEV2ZW50TGlzdGVuZXIiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7SUFtRGdCQSxpQkFBaUIsRUFBQTtlQUFqQkE7O0lBMUJBQyxrQkFBa0IsRUFBQTtlQUFsQkE7O0lBdUdBQyxrQkFBa0IsRUFBQTtlQUFsQkE7O0lBbEVBQyxlQUFlLEVBQUE7ZUFBZkE7Ozs7dUJBOURVO21DQUNRO3lCQUkzQjtrRUFDYTs4QkFDZTsrQkFDbUI7NkJBSy9DO0FBRVAsTUFBTUMsaUJBQ0pDLFdBQVdDLGNBQWMsSUFBSyxDQUFBLENBQUNDLEtBQW1CQyxRQUFRQyxPQUFPLEdBQUdDLElBQUksQ0FB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QUV6QkosZUFBZVcsSUFBSSxDQUFDUDtJQUNwQixLQUFLLE1BQU1RLFdBQVdYLGtCQUFtQjtRQUN2Q1csUUFBUVI7SUFDVjtJQUVBLElBQUlzQixhQUFBQSx3QkFBd0IsRUFBRTtRQUM1QkssQ0FBQUEsR0FBQUEsYUFBQUEscUJBQXFCLEVBQUNEO0lBQ3hCO0FBQ0Y7QUFFTyxTQUFTekM7SUFDZCxJQUFJLE9BQU8yQyxXQUFXLGFBQWE7O0FBU3JDIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDgwMDUsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvc2hhcmVkL2xpYi9lcnJvcnMvY29uc3RhbnRzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBNSVNTSU5HX1JPT1RfVEFHU19FUlJPUiA9ICdORVhUX01JU1NJTkdfUk9PVF9UQUdTJ1xuIl0sIm5hbWVzIjpbIk1JU1NJTkdfUk9PVF9UQUdTX0VSUk9SIl0sIm1hcHBpbmdzIjoiOzs7K0JBQWFBLDJCQUFBQTs7O2VBQUFBOzs7QUFBTixNQUFNQSwwQkFBMEIiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogODAyOCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9uZXh0LWRldnRvb2xzL3VzZXJzcGFjZS9hcHAvZXJyb3JzL3JlcGxheS1zc3Itb25seS1lcnJvcnMudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgaGFuZGxlQ2xpZW50RXJyb3IgfSBmcm9tICcuL3VzZS1lcnJvci1oYW5kbGVyJ1xuaW1wb3J0IHsgaXNOZXh0Um91dGVyRXJyb3IgfSBmcm9tICcuLi8uLi8uLi8uLi9jbGllbnQvY29tcG9uZW50cy9pcy1uZXh0LXJvdXRlci1lcnJvcidcbmltcG9ydCB7IE1JU1NJTkdfUk9PVF9UQUdTX0VSUk9SIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL2xpYi9lcnJvcnMvY29uc3RhbnRzJ1xuXG5mdW5jdGlvbiByZWFkU3NyRXJyb3IoKTogKEVycm9yICYgeyBkaWdlc3Q/OiBzdHJpbmcgfSkgfCBudWxsIHtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgY29uc3Qgc3NyRXJyb3JUZW1wbGF0ZVRhZyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXG4gICAgJ3RlbXBsYXRlW2RhdGEtbmV4dC1lcnJvci1tZXNzYWdlXSdcbiAgKVxuICBpZiAoc3NyRXJyb3JUZW1wbGF0ZVRhZykge1xuICAgIGNvbnN0IG1lc3NhZ2U6IHN0cmluZyA9IHNzckVycm9yVGVtcGxhdGVUYWcuZ2V0QXR0cmlidXRlKFxuICAgICAgJ2RhdGEtbmV4dC1lcnJvci1tZXNzYWdlJ1xuICAgICkhXG4gICAgY29uc3Qgc3RhY2sgPSBzc3JFcnJvclRlbXBsYXRlVGFnLmdldEF0dHJpYnV0ZSgnZGF0YS1uZXh0LWVycm9yLXN0YWNrJylcbiAgICBjb25zdCBkaWdlc3QgPSBzc3JFcnJvclRlbXBsYXRlVGFnLmdldEF0dHJpYnV0ZSgnZGF0YS1uZXh0LWVycm9yLWRpZ2VzdCcpXG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSlcbiAgICBpZiAoZGlnZXN0KSB7XG4gICAgICA7KGVycm9yIGFzIGFueSkuZGlnZXN0ID0gZGlnZXN0XG4gICAgfVxuICAgIC8vIFNraXAgTmV4dC5qcyBTU1InZCBpbnRlcm5hbCBlcnJvcnMgdGhhdCB3aGljaCB3aWxsIGJlIGhhbmRsZWQgYnkgdGhlIGVycm9yIGJvdW5kYXJpZXMuXG4gICAgaWYgKGlzTmV4dFJvdXRlckVycm9yKGVycm9yKSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgZXJyb3Iuc3RhY2sgPSBzdGFjayB8fCAnJ1xuICAgIHJldHVybiBlcnJvclxuICB9XG5cbiAgcmV0dXJuIG51bGxcbn1cblxuLyoqXG4gKiBOZWVkcyB0byBiZSBpbiB0aGUgc2FtZSBlcnJvciBib3VuZGFyeSBhcyB0aGUgc2hlbGwuXG4gKiBJZiBpdCBjb21taXRzLCB3ZSBrbm93IHdlIHJlY292ZXJlZCBmcm9tIGFuIFNTUiBlcnJvci5cbiAqIElmIGl0IGRvZXNuJ3QgY29tbWl0LCB3ZSBlcnJvcmVkIGFnYWluIGFuZCBSZWFjdCB3aWxsIHRha2UgY2FyZSBvZiBlcnJvciByZXBvcnRpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBSZXBsYXlTc3JPbmx5RXJyb3JzKHtcbiAgb25CbG9ja2luZ0Vycm9yLFxufToge1xuICBvbkJsb2NraW5nRXJyb3I6ICgpID0+IHZvaWRcbn0pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBOZWVkIHRvIHJlYWQgZHVyaW5nIHJlbmRlci4gVGhlIGF0dHJpYnV0ZXMgd2lsbCBiZSBnb25lIGFmdGVyIGNvbW1pdC5cbiAgICBjb25zdCBzc3JFcnJvciA9IHJlYWRTc3JFcnJvcigpXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIGlmIChzc3JFcnJvciAhPT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPKHZlaWwpOiBJbmNsdWRlIG9yaWdpbmFsIE93bmVyIFN0YWNrIChORFgtOTA1KVxuICAgICAgICAvLyBUT0RPKHZlaWwpOiBNYXJrIGFzIHJlY292ZXJhYmxlIGVycm9yXG4gICAgICAgIC8vIFRPRE8odmVpbCk6IGNvbnNvbGUuZXJyb3JcbiAgICAgICAgaGFuZGxlQ2xpZW50RXJyb3Ioc3NyRXJyb3IpXG5cbiAgICAgICAgLy8gSWYgaXQncyBtaXNzaW5nIHJvb3QgdGFncywgd2UgY2FuJ3QgcmVjb3ZlciwgbWFrZSBpdCBibG9ja2luZy5cbiAgICAgICAgaWYgKHNzckVycm9yLmRpZ2VzdCA9PT0gTUlTU0lOR19ST09UX1RBR1NfRVJST1IpIHtcbiAgICAgICAgICBvbkJsb2NraW5nRXJyb3IoKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgW3NzckVycm9yLCBvbkJsb2NraW5nRXJyb3JdKVxuICB9XG5cbiAgcmV0dXJuIG51bGxcbn1cbiJdLCJuYW1lcyI6WyJSZXBsYXlTc3JPbmx5RXJyb3JzIiwicmVhZFNzckVycm9yIiwiZG9jdW1lbnQiLCJzc3JFcnJvclRlbXBsYXRlVGFnIiwicXVlcnlTZWxlY3RvciIsIm1lc3NhZ2UiLCJnZXRBdHRyaWJ1dGUiLCJzdGFjayIsImRpZ2VzdCIsImVycm9yIiwiRXJyb3IiLCJpc05leHRSb3V0ZXJFcnJvciIsIm9uQmxvY2tpbmdFcnJvciIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsInNzckVycm9yIiwidXNlRWZmZWN0IiwiaGFuZGxlQ2xpZW50RXJyb3IiLCJNSVNTSU5HX1JPT1RfVEFHU19FUlJPUiJdLCJtYXBwaW5ncyI6Ijs7OytCQXVDZ0JBLHVCQUFBQTs7O2VBQUFBOzs7dUJBdkNVO2lDQUNRO21DQUNBOzJCQUNNO0FBRXhDLFNBQVNDO0lBQ1AsSUFBSSxPQUFPQyxhQUFhLGFBQWE7UUFDbkMsT0FBTztJQUNUO0lBRUEsTUFBTUMsc0JBQXNCRCxTQUFTRSxhQUFhLENBQ2hEO0lBRUYsSUFBSUQscUJBQXFCO1FBQ3ZCLE1BQU1FLFVBQWtCRixvQkFBb0JHLFlBQVksQ0FDdEQ7UUFFRixNQUFNQyxRQUFRSixvQkFBb0JHLFlBQVksQ0FBQztRQUMvQyxNQUFNRSxTQUFTTCxvQkFBb0JHLFlBQVksQ0FBQztRQUNoRCxNQUFNRyxRQUFRLE9BQUEsY0FBa0IsQ0FBbEIsSUFBSUMsTUFBTUwsVUFBVixxQkFBQTttQkFBQTt3QkFBQTswQkFBQTtRQUFpQjtRQUMvQixJQUFJRyxRQUFROztZQUNSQyxNQUFjRCxNQUFNLEdBQUdBO1FBQzNCO1FBQ0EseUZBQXlGO1FBQ3pGLElBQUlHLENBQUFBLEdBQUFBLG1CQUFBQSxpQkFBaUIsRUFBQ0YsUUFBUTtZQUM1QixPQUFPO1FBQ1Q7UUFDQUEsTUFBTUYsS0FBSyxHQUFHQSxTQUFTO1FBQ3ZCLE9BQU9FO0lBQ1Q7SUFFQSxPQUFPO0FBQ1Q7QUFPTyxTQUFTVCxvQkFBb0IsS0FJbkM7SUFKbUMsSUFBQSxFQUNsQ1ksZUFBZSxFQUdoQixHQUptQztJQUtsQyxJQUFJQyxRQUFRQyxHQUFHLENBQUNDLFFBQVEsS0FBSyxXQUFjO1FBQ3pDLHdFQUF3RTtRQUN4RSxNQUFNQyxXQUFXZjtRQUNqQixzREFBc0Q7UUFDdERnQixDQUFBQSxHQUFBQSxPQUFBQSxTQUFTLEVBQUM7WUFDUixJQUFJRCxhQUFhLE1BQU07Z0JBQ3JCLHFEQUFxRDtnQkFDckQsd0NBQXdDO2dCQUN4Qyw0QkFBNEI7Z0JBQzVCRSxDQUFBQSxHQUFBQSxpQkFBQUEsaUJBQWlCLEVBQUNGO2dCQUVsQixpRUFBaUU7Z0JBQ2pFLElBQUlBLFNBQVNSLE1BQU0sS0FBS1csV0FBQUEsdUJBQXVCLEVBQUU7b0JBQy9DUDtnQkFDRjtZQUNGO1FBQ0YsR0FBRztZQUFDSTtZQUFVSjtTQUFnQjtJQUNoQztJQUVBLE9BQU87QUFDVCIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA4MTA1LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2NsaWVudC9kZXYvcnVudGltZS1lcnJvci1oYW5kbGVyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBSdW50aW1lRXJyb3JIYW5kbGVyID0ge1xuICBoYWRSdW50aW1lRXJyb3I6IGZhbHNlLFxufVxuIl0sIm5hbWVzIjpbIlJ1bnRpbWVFcnJvckhhbmRsZXIiLCJoYWRSdW50aW1lRXJyb3IiXSwibWFwcGluZ3MiOiI7OzsrQkFBYUEsdUJBQUFBOzs7ZUFBQUE7OztBQUFOLE1BQU1BLHNCQUFzQjtJQUNqQ0MsaUJBQWlCO0FBQ25CIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDgxMzAsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvbmV4dC1kZXZ0b29scy91c2Vyc3BhY2UvYXBwL3NlZ21lbnQtZXhwbG9yZXItbm9kZS50c3giXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbmltcG9ydCB0eXBlIHsgUmVhY3ROb2RlIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQge1xuICB1c2VTdGF0ZSxcbiAgY3JlYXRlQ29udGV4dCxcbiAgdXNlQ29udGV4dCxcbiAgdXNlLFxuICB1c2VNZW1vLFxuICB1c2VDYWxsYmFjayxcbn0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IGRpc3BhdGNoZXIgfSBmcm9tICduZXh0L2Rpc3QvY29tcGlsZWQvbmV4dC1kZXZ0b29scydcbmltcG9ydCB7IG5vdEZvdW5kIH0gZnJvbSAnLi4vLi4vLi4vY2xpZW50L2NvbXBvbmVudHMvbm90LWZvdW5kJ1xuXG5leHBvcnQgY29uc3QgU0VHTUVOVF9FWFBMT1JFUl9TSU1VTEFURURfRVJST1JfTUVTU0FHRSA9XG4gICdORVhUX0RFVlRPT0xTX1NJTVVMQVRFRF9FUlJPUidcblxuZXhwb3J0IHR5cGUgU2VnbWVudE5vZGVTdGF0ZSA9IHtcbiAgdHlwZTogc3RyaW5nXG4gIHBhZ2VQYXRoOiBzdHJpbmdcbiAgYm91bmRhcnlUeXBlOiBzdHJpbmcgfCBudWxsXG4gIHNldEJvdW5kYXJ5VHlwZTogKHR5cGU6ICdlcnJvcicgfCAnbm90LWZvdW5kJyB8ICdsb2FkaW5nJyB8IG51bGwpID0+IHZvaWRcbn1cblxuZnVuY3Rpb24gU2VnbWVudFRyaWVOb2RlKHtcbiAgdHlwZSxcbiAgcGFnZVBhdGgsXG59OiB7XG4gIHR5cGU6IHN0cmluZ1xuICBwYWdlUGF0aDogc3RyaW5nXG59KTogUmVhY3QuUmVhY3ROb2RlIHtcbiAgY29uc3QgeyBib3VuZGFyeVR5cGUsIHNldEJvdW5kYXJ5VHlwZSB9ID0gdXNlU2VnbWVudFN0YXRlKClcbiAgY29uc3Qgbm9kZVN0YXRlOiBTZWdtZW50Tm9kZVN0YXRlID0gdXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGUsXG4gICAgICBwYWdlUGF0aCxcbiAgICAgIGJvdW5kYXJ5VHlwZSxcbiAgICAgIHNldEJvdW5kYXJ5VHlwZSxcbiAgICB9XG4gIH0sIFt0eXBlLCBwYWdlUGF0aCwgYm91bmRhcnlUeXBlLCBzZXRCb3VuZGFyeVR5cGVdKVxuXG4gIC8vIFVzZSBgdXNlTGF5b3V0RWZmZWN0YCB0byBlbnN1cmUgdGhlIHN0YXRlIGlzIHVwZGF0ZWQgZHVyaW5nIHN1c3BlbnNlLlxuICAvLyBgdXNlRWZmZWN0YCB3b24ndCB3b3JrIGFzIHRoZSBzdGF0ZSBpcyBwcmVzZXJ2ZWQgZHVyaW5nIHN1c3BlbnNlLlxuICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGRpc3BhdGNoZXIuc2VnbWVudEV4cGxvcmVyTm9kZUFkZChub2RlU3RhdGUpXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGRpc3BhdGNoZXIuc2VnbWVudEV4cGxvcmVyTm9kZVJlbW92ZShub2RlU3RhdGUpXG4gICAgfVxuICB9LCBbbm9kZVN0YXRlXSlcblxuICByZXR1cm4gbnVsbFxufVxuXG5mdW5jdGlvbiBOb3RGb3VuZFNlZ21lbnROb2RlKCk6IFJlYWN0LlJlYWN0Tm9kZSB7XG4gIG5vdEZvdW5kKClcbn1cblxuZnVuY3Rpb24gRXJyb3JTZWdtZW50Tm9kZSgpOiBSZWFjdC5SZWFjdE5vZGUge1xuICB0aHJvdyBuZXcgRXJyb3IoU0VHTUVOVF9FWFBMT1JFUl9TSU1VTEFURURfRVJST1JfTUVTU0FHRSlcbn1cblxuY29uc3QgZm9yZXZlciA9IG5ldyBQcm9taXNlKCgpID0+IHt9KVxuZnVuY3Rpb24gTG9hZGluZ1NlZ21lbnROb2RlKCk6IFJlYWN0LlJlYWN0Tm9kZSB7XG4gIHVzZShmb3JldmVyKVxuICByZXR1cm4gbnVsbFxufVxuXG5leHBvcnQgZnVuY3Rpb24gU2VnbWVudFZpZXdTdGF0ZU5vZGUoeyBwYWdlIH06IHsgcGFnZTogc3RyaW5nIH0pIHtcbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBkaXNwYXRjaGVyLnNlZ21lbnRFeHBsb3JlclVwZGF0ZVJvdXRlU3RhdGUocGFnZSlcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZGlzcGF0Y2hlci5zZWdtZW50RXhwbG9yZXJVcGRhdGVSb3V0ZVN0YXRlKCcnKVxuICAgIH1cbiAgfSwgW3BhZ2VdKVxuICByZXR1cm4gbnVsbFxufVxuXG5leHBvcnQgZnVuY3Rpb24gU2VnbWVudEJvdW5kYXJ5VHJpZ2dlck5vZGUoKSB7XG4gIGNvbnN0IHsgYm91bmRhcnlUeXBlIH0gPSB1c2VTZWdtZW50U3RhdGUoKVxuICBsZXQgc2VnbWVudE5vZGU6IFJlYWN0LlJlYWN0Tm9kZSA9IG51bGxcbiAgaWYgKGJvdW5kYXJ5VHlwZSA9PT0gJ2xvYWRpbmcnKSB7XG4gICAgc2VnbWVudE5vZGUgPSA8TG9hZGluZ1NlZ21lbnROb2RlIC8+XG4gIH0gZWxzZSBpZiAoYm91bmRhcnlUeXBlID09PSAnbm90LWZvdW5kJykge1xuICAgIHNlZ21lbnROb2RlID0gPE5vdEZvdW5kU2VnbWVudE5vZGUgLz5cbiAgfSBlbHNlIGlmIChib3VuZGFyeVR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBzZWdtZW50Tm9kZSA9IDxFcnJvclNlZ21lbnROb2RlIC8+XG4gIH1cbiAgcmV0dXJuIHNlZ21lbnROb2RlXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBTZWdtZW50Vmlld05vZGUoe1xuICB0eXBlLFxuICBwYWdlUGF0aCxcbiAgY2hpbGRyZW4sXG59OiB7XG4gIHR5cGU6IHN0cmluZ1xuICBwYWdlUGF0aDogc3RyaW5nXG4gIGNoaWxkcmVuPzogUmVhY3ROb2RlXG59KTogUmVhY3QuUmVhY3ROb2RlIHtcbiAgY29uc3Qgc2VnbWVudE5vZGUgPSAoXG4gICAgPFNlZ21lbnRUcmllTm9kZSBrZXk9e3R5cGV9IHR5cGU9e3R5cGV9IHBhZ2VQYXRoPXtwYWdlUGF0aH0gLz5cbiAgKVxuXG4gIHJldHVybiAoXG4gICAgPD5cbiAgICAgIHtzZWdtZW50Tm9kZX1cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8Lz5cbiAgKVxufVxuXG5jb25zdCBTZWdtZW50U3RhdGVDb250ZXh0ID0gY3JlYXRlQ29udGV4dDx7XG4gIGJvdW5kYXJ5VHlwZTogJ25vdC1mb3VuZCcgfCAnZXJyb3InIHwgJ2xvYWRpbmcnIHwgbnVsbFxuICBzZXRCb3VuZGFyeVR5cGU6ICh0eXBlOiAnbm90LWZvdW5kJyB8ICdlcnJvcicgfCAnbG9hZGluZycgfCBudWxsKSA9PiB2b2lkXG59Pih7XG4gIGJvdW5kYXJ5VHlwZTogbnVsbCxcbiAgc2V0Qm91bmRhcnlUeXBlOiAoKSA9PiB7fSxcbn0pXG5cbmV4cG9ydCBmdW5jdGlvbiBTZWdtZW50U3RhdGVQcm92aWRlcih7IGNoaWxkcmVuIH06IHsgY2hpbGRyZW46IFJlYWN0Tm9kZSB9KSB7XG4gIGNvbnN0IFtib3VuZGFyeVR5cGUsIHNldEJvdW5kYXJ5VHlwZV0gPSB1c2VTdGF0ZTxcbiAgICAnbm90LWZvdW5kJyB8ICdlcnJvcicgfCAnbG9hZGluZycgfCBudWxsXG4gID4obnVsbClcblxuICBjb25zdCBbZXJyb3JCb3VuZGFyeUtleSwgc2V0RXJyb3JCb3VuZGFyeUtleV0gPSB1c2VTdGF0ZSgwKVxuICBjb25zdCByZWxvYWRCb3VuZGFyeSA9IHVzZUNhbGxiYWNrKFxuICAgICgpID0+IHNldEVycm9yQm91bmRhcnlLZXkoKHByZXYpID0+IHByZXYgKyAxKSxcbiAgICBbXVxuICApXG5cbiAgY29uc3Qgc2V0Qm91bmRhcnlUeXBlQW5kUmVsb2FkID0gdXNlQ2FsbGJhY2soXG4gICAgKHR5cGU6ICdub3QtZm91bmQnIHwgJ2Vycm9yJyB8ICdsb2FkaW5nJyB8IG51bGwpID0+IHtcbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHJlbG9hZEJvdW5kYXJ5KClcbiAgICAgIH1cbiAgICAgIHNldEJvdW5kYXJ5VHlwZSh0eXBlKVxuICAgIH0sXG4gICAgW3JlbG9hZEJvdW5kYXJ5XVxuICApXG5cbiAgcmV0dXJuIChcbiAgICA8U2VnbWVudFN0YXRlQ29udGV4dC5Qcm92aWRlclxuICAgICAga2V5PXtlcnJvckJvdW5kYXJ5S2V5fVxuICAgICAgdmFsdWU9e3tcbiAgICAgICAgYm91bmRhcnlUeXBlLFxuICAgICAgICBzZXRCb3VuZGFyeVR5cGU6IHNldEJvdW5kYXJ5VHlwZUFuZFJlbG9hZCxcbiAgICAgIH19XG4gICAgPlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvU2VnbWVudFN0YXRlQ29udGV4dC5Qcm92aWRlcj5cbiAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlU2VnbWVudFN0YXRlKCkge1xuICByZXR1cm4gdXNlQ29udGV4dChTZWdtZW50U3RhdGVDb250ZXh0KVxufVxuIl0sIm5hbWVzIjpbIlNFR01FTlRfRVhQTE9SRVJfU0lNVUxBVEVEX0VSUk9SX01FU1NBR0UiLCJTZWdtZW50Qm91bmRhcnlUcmlnZ2VyTm9kZSIsIlNlZ21lbnRTdGF0ZVByb3ZpZGVyIiwiU2VnbWVudFZpZXdOb2RlIiwiU2VnbWVudFZpZXdTdGF0ZU5vZGUiLCJ1c2VTZWdtZW50U3RhdGUiLCJTZWdtZW50VHJpZU5vZGUiLCJ0eXBlIiwicGFnZVBhdGgiLCJib3VuZGFyeVR5cGUiLCJzZXRCb3VuZGFyeVR5cGUiLCJub2RlU3RhdGUiLCJ1c2VNZW1vIiwidXNlTGF5b3V0RWZmZWN0IiwiZGlzcGF0Y2hlciIsInNlZ21lbnRFeHBsb3Jlck5vZGVBZGQiLCJzZWdtZW50RXhwbG9yZXJOb2RlUmVtb3ZlIiwiTm90Rm91bmRTZWdtZW50Tm9kZSIsIm5vdEZvdW5kIiwiRXJyb3JTZWdtZW50Tm9kZSIsIkVycm9yIiwiZm9yZXZlciIsIlByb21pc2UiLCJMb2FkaW5nU2VnbWVudE5vZGUiLCJ1c2UiLCJwYWdlIiwic2VnbWVudEV4cGxvcmVyVXBkYXRlUm91dGVTdGF0ZSIsInNlZ21lbnROb2RlIiwiY2hpbGRyZW4iLCJTZWdtZW50U3RhdGVDb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsInVzZVN0YXRlIiwiZXJyb3JCb3VuZGFyeUtleSIsInNldEVycm9yQm91bmRhcnlLZXkiLCJyZWxvYWRCb3VuZGFyeSIsInVzZUNhbGxiYWNrIiwicHJldiIsInNldEJvdW5kYXJ5VHlwZUFuZFJlbG9hZCIsIlByb3ZpZGVyIiwidmFsdWUiLCJ1c2VDb250ZXh0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFlYUEsd0NBQXdDLEVBQUE7ZUFBeENBOztJQStER0MsMEJBQTBCLEVBQUE7ZUFBMUJBOztJQTBDQUMsb0JBQW9CLEVBQUE7ZUFBcEJBOztJQTdCQUMsZUFBZSxFQUFBO2VBQWZBOztJQXZCQUMsb0JBQW9CLEVBQUE7ZUFBcEJBOztJQXNGQUMsZUFBZSxFQUFBO2VBQWZBOzs7O3VCQWhKVDs4QkFFb0I7MEJBQ0Y7QUFFbEIsTUFBTUwsMkNBQ1g7QUFTRixTQUFTTSxnQkFBZ0IsS0FNeEI7SUFOd0IsSUFBQSxFQUN2QkMsSUFBSSxFQUNKQyxRQUFRLEVBSVQsR0FOd0I7SUFPdkIsTUFBTSxFQUFFQyxZQUFZLEVBQUVDLGVBQWUsRUFBRSxHQUFHTDtJQUMxQyxNQUFNTSxZQUE4QkMsQ0FBQUEsR0FBQUEsT0FBQUEsT0FB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QjJCO1FBQ0Y7UUFDQXhCLGdCQUFnQkg7SUFDbEIsR0FDQTtRQUFDMkI7S0FBZTtJQUdsQixPQUFBLFdBQUEsR0FDRSxDQUFBLEdBQUEsWUFBQSxHQUFBLEVBQUNMLG9CQUFvQlMsUUFBUSxFQUFBO1FBRTNCQyxPQUFPO1lBQ0w5QjtZQUNBQyxpQkFBaUIyQjtRQUNuQjtrQkFFQ1Q7T0FOSUk7QUFTWDtBQUVPLFNBQVMzQjtJQUNkLE9BQU9tQyxDQUFBQSxHQUFBQSxPQUFBQSxVQUFVLEVBQUNYO0FBQ3BCIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDgyOTMsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvbmV4dC1kZXZ0b29scy91c2Vyc3BhY2UvYXBwL2FwcC1kZXYtb3ZlcmxheS1lcnJvci1ib3VuZGFyeS50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUHVyZUNvbXBvbmVudCB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgZGlzcGF0Y2hlciB9IGZyb20gJ25leHQvZGlzdC9jb21waWxlZC9uZXh0LWRldnRvb2xzJ1xuaW1wb3J0IHsgUnVudGltZUVycm9ySGFuZGxlciB9IGZyb20gJy4uLy4uLy4uL2NsaWVudC9kZXYvcnVudGltZS1lcnJvci1oYW5kbGVyJ1xuaW1wb3J0IHsgRXJyb3JCb3VuZGFyeSB9IGZyb20gJy4uLy4uLy4uL2NsaWVudC9jb21wb25lbnRzL2Vycm9yLWJvdW5kYXJ5J1xuaW1wb3J0IERlZmF1bHRHbG9iYWxFcnJvciBmcm9tICcuLi8uLi8uLi9jbGllbnQvY29tcG9uZW50cy9idWlsdGluL2dsb2JhbC1lcnJvcidcbmltcG9ydCB0eXBlIHsgR2xvYmFsRXJyb3JTdGF0ZSB9IGZyb20gJy4uLy4uLy4uL2NsaWVudC9jb21wb25lbnRzL2FwcC1yb3V0ZXItaW5zdGFuY2UnXG5pbXBvcnQgeyBTRUdNRU5UX0VYUExPUkVSX1NJTVVMQVRFRF9FUlJPUl9NRVNTQUdFIH0gZnJvbSAnLi9zZWdtZW50LWV4cGxvcmVyLW5vZGUnXG5cbnR5cGUgQXBwRGV2T3ZlcmxheUVycm9yQm91bmRhcnlQcm9wcyA9IHtcbiAgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZVxuICBnbG9iYWxFcnJvcjogR2xvYmFsRXJyb3JTdGF0ZVxufVxuXG50eXBlIEFwcERldk92ZXJsYXlFcnJvckJvdW5kYXJ5U3RhdGUgPSB7XG4gIHJlYWN0RXJyb3I6IHVua25vd25cbn1cblxuZnVuY3Rpb24gRXJyb3JlZEh0bWwoe1xuICBnbG9iYWxFcnJvcjogW0dsb2JhbEVycm9yLCBnbG9iYWxFcnJvclN0eWxlc10sXG4gIGVycm9yLFxufToge1xuICBnbG9iYWxFcnJvcjogR2xvYmFsRXJyb3JTdGF0ZVxuICBlcnJvcjogdW5rbm93blxufSkge1xuICBpZiAoIWVycm9yKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxodG1sPlxuICAgICAgICA8aGVhZCAvPlxuICAgICAgICA8Ym9keSAvPlxuICAgICAgPC9odG1sPlxuICAgIClcbiAgfVxuICByZXR1cm4gKFxuICAgIDxFcnJvckJvdW5kYXJ5IGVycm9yQ29tcG9uZW50PXtEZWZhdWx0R2xvYmFsRXJyb3J9PlxuICAgICAge2dsb2JhbEVycm9yU3R5bGVzfVxuICAgICAgPEdsb2JhbEVycm9yIGVycm9yPXtlcnJvcn0gLz5cbiAgICA8L0Vycm9yQm91bmRhcnk+XG4gIClcbn1cblxuZXhwb3J0IGNsYXNzIEFwcERldk92ZXJsYXlFcnJvckJvdW5kYXJ5IGV4dGVuZHMgUHVyZUNvbXBvbmVudDxcbiAgQXBwRGV2T3ZlcmxheUVycm9yQm91bmRhcnlQcm9wcyxcbiAgQXBwRGV2T3ZlcmxheUVycm9yQm91bmRhcnlTdGF0ZVxuPiB7XG4gIHN0YXRlID0geyByZWFjdEVycm9yOiBudWxsIH1cblxuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yOiBFcnJvcikge1xuICAgIFJ1bnRpbWVFcnJvckhhbmRsZXIuaGFkUnVudGltZUVycm9yID0gdHJ1ZVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHJlYWN0RXJyb3I6IGVycm9yLFxuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudERpZENhdGNoKGVycjogRXJyb3IpIHtcbiAgICBpZiAoXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJlxuICAgICAgZXJyLm1lc3NhZ2UgPT09IFNFR01FTlRfRVhQTE9SRVJfU0lNVUxBVEVEX0VSUk9SX01FU1NBR0VcbiAgICApIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBkaXNwYXRjaGVyLm9wZW5FcnJvck92ZXJsYXkoKVxuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgY2hpbGRyZW4sIGdsb2JhbEVycm9yIH0gPSB0aGlzLnByb3BzXG4gICAgY29uc3QgeyByZWFjdEVycm9yIH0gPSB0aGlzLnN0YXRlXG5cbiAgICBjb25zdCBmYWxsYmFjayA9IChcbiAgICAgIDxFcnJvcmVkSHRtbCBnbG9iYWxFcnJvcj17Z2xvYmFsRXJyb3J9IGVycm9yPXtyZWFjdEVycm9yfSAvPlxuICAgIClcblxuICAgIHJldHVybiByZWFjdEVycm9yICE9PSBudWxsID8gZmFsbGJhY2sgOiBjaGlsZHJlblxuICB9XG59XG4iXSwibmFtZXMiOlsiQXBwRGV2T3ZlcmxheUVycm9yQm91bmRhcnkiLCJFcnJvcmVkSHRtbCIsImdsb2JhbEVycm9yIiwiR2xvYmFsRXJyb3IiLCJnbG9iYWxFcnJvclN0eWxlcyIsImVycm9yIiwiaHRtbCIsImhlYWQiLCJib2R5IiwiRXJyb3JCb3VuZGFyeSIsImVycm9yQ29tcG9uZW50IiwiRGVmYXVsdEdsb2JhbEVycm9yIiwiUHVyZUNvbXBvbmVudCIsImdldERlcml2ZWRTdGF0ZUZyb21FcnJvciIsIlJ1bnRpbWVFcnJvckhhbmRsZXIiLCJoYWRSdW50aW1lRXJyb3IiLCJyZWFjdEVycm9yIiwiY29tcG9uZW50RGlkQ2F0Y2giLCJlcnIiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJtZXNzYWdlIiwiU0VHTUVOVF9FWFBMT1JFUl9TSU1VTEFURURfRVJST1JfTUVTU0FHRSIsImRpc3BhdGNoZXIiLCJvcGVuRXJyb3JPdmVybGF5IiwicmVuZGVyIiwiY2hpbGRyZW4iLCJwcm9wcyIsInN0YXRlIiwiZmFsbGJhY2siXSwibWFwcGluZ3MiOiI7OzsrQkF3Q2FBLDhCQUFBQTs7O2VBQUFBOzs7Ozt1QkF4Q2lCOzhCQUNIO3FDQUNTOytCQUNOO3NFQUNDO3FDQUUwQjtBQVd6RCxTQUFTQyxZQUFZLEtBTXBCO0lBTm9CLElBQUEsRUFDbkJDLGFBQWEsQ0FBQ0MsYUFBYUMsa0JBQWtCLEVBQzdDQyxLQUFLLEVBSU4sR0FOb0I7SUFPbkIsSUFBSSxDQUFDQSxPQUFPO1FBQ1YsT0FBQSxXQUFBLEdBQ0UsQ0FBQSxHQUFBLFlBQUEsSUFBQSxFQUFDQyxRQUFBQTs7OEJBQ0MsQ0FBQSxHQUFBLFlBQUEsR0FBQSxFQUFDQyxRQUFBQSxDQUFBQTs4QkFDRCxDQUFBLEdBQUEsWUFBQSxHQUFBLEVBQUNDLFFBQUFBLENBQUFBOzs7SUFHUDtJQUNBLE9BQUEsV0FBQSxHQUNFLENBQUEsR0FBQSxZQUFBLElBQUEsRUFBQ0MsZUFBQUEsYUFBYSxFQUFBO1FBQUNDLGdCQUFnQkMsYUFBQUEsT0FBa0I7O1lBQzlDUDswQkFDRCxDQUFBLEdBQUEsWUFBQSxHQUFBLEVBQUNELGFBQUFBO2dCQUFZRSxPQUFPQTs7OztBQUcxQjtBQUVPLE1BQU1MLG1DQUFtQ1ksT0FBQUEsYUFBYTtJQU0zRCxPQUFPQyx5QkFBeUJSLEtBQVksRUFBRTtRQUM1Q1MscUJBQUFBLG1CQUFtQixDQUFDQyxlQUFlLEdBQUc7UUFFdEMsT0FBTztZQUNMQyxZQUFZWDtRQUNkO0lBQ0Y7SUFFQVksa0JBQWtCQyxHQUFVLEVBQUU7UUFDNUIsSUFDRUMsUUFBUUMsR0FBRyxDQUFDQyxRQUFRLGdDQUFLLGlCQUN6QkgsSUFBSUksT0FBTyxLQUFLQyxxQkFBQUEsd0NBQXdDLEVBQ3hEO1lBQ0E7UUFDRjtRQUNBQyxjQUFBQSxVQUFVLENBQUNDLGdCQUFnQjtJQUM3QjtJQUVBQyxTQUFTO1FBQ1AsTUFBTSxFQUFFQyxRQUFRLEVBQUV6QixXQUFXLEVBQUUsR0FBRyxJQUFJLENBQUMwQixLQUFLO1FBQzVDLE1BQU0sRUFBRVosVUFBVSxFQUFFLEdBQUcsSUFBSSxDQUFDYSxLQUFLO1FBRWpDLE1BQU1DLFdBQUFBLFdBQUFBLEdBQ0osQ0FBQSxHQUFBLFlBQUEsR0FBQSxFQUFDN0IsYUFBQUE7WUFBWUMsYUFBYUE7WUFBYUcsT0FBT1c7O1FBR2hELE9BQU9BLGVBQWUsT0FBT2MsV0FBV0g7SUFDMUM7O1FBakNLLEtBQUEsSUFBQSxPQUFBLElBQUEsQ0FJTEUsS0FBQUEsR0FBUTtZQUFFYixZQUFZO1FBQUs7O0FBOEI3QiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA4MzcxLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL3NoYXJlZC9saWIvbm9ybWFsaXplZC1hc3NldC1wcmVmaXgudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZWRBc3NldFByZWZpeChhc3NldFByZWZpeDogc3RyaW5nIHwgdW5kZWZpbmVkKTogc3RyaW5nIHtcbiAgLy8gcmVtb3ZlIGFsbCBsZWFkaW5nIHNsYXNoZXMgYW5kIHRyYWlsaW5nIHNsYXNoZXNcbiAgY29uc3QgZXNjYXBlZEFzc2V0UHJlZml4ID0gYXNzZXRQcmVmaXg/LnJlcGxhY2UoL15cXC8rfFxcLyskL2csICcnKSB8fCBmYWxzZVxuXG4gIC8vIGlmIGFuIGFzc2V0UHJlZml4IHdhcyAnLycsIHdlIHJldHVybiBlbXB0eSBzdHJpbmdcbiAgLy8gYmVjYXVzZSBpdCBjb3VsZCBiZSBhbiB1bm5lY2Vzc2FyeSB0cmFpbGluZyBzbGFzaFxuICBpZiAoIWVzY2FwZWRBc3NldFByZWZpeCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKFVSTC5jYW5QYXJzZShlc2NhcGVkQXNzZXRQcmVmaXgpKSB7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChlc2NhcGVkQXNzZXRQcmVmaXgpLnRvU3RyaW5nKClcbiAgICByZXR1cm4gdXJsLmVuZHNXaXRoKCcvJykgPyB1cmwuc2xpY2UoMCwgLTEpIDogdXJsXG4gIH1cblxuICAvLyBhc3N1bWluZyBhc3NldFByZWZpeCBoZXJlIGlzIGEgcGF0aG5hbWUtc3R5bGUsXG4gIC8vIHJlc3RvcmUgdGhlIGxlYWRpbmcgc2xhc2hcbiAgcmV0dXJuIGAvJHtlc2NhcGVkQXNzZXRQcmVmaXh9YFxufVxuIl0sIm5hbWVzIjpbIm5vcm1hbGl6ZWRBc3NldFByZWZpeCIsImFzc2V0UHJlZml4IiwiZXNjYXBlZEFzc2V0UHJlZml4IiwicmVwbGFjZSIsIlVSTCIsImNhblBhcnNlIiwidXJsIiwidG9TdHJpbmciLCJlbmRzV2l0aCIsInNsaWNlIl0sIm1hcHBpbmdzIjoiOzs7K0JBQWdCQSx5QkFBQUE7OztlQUFBQTs7O0FBQVQsU0FBU0Esc0JBQXNCQyxXQUErQjtJQUNuRSxrREFBa0Q7SUFDbEQsTUFBTUMscUJBQXFCRCxDQUFBQSxlQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxZQUFhRSxPQUFPLENBQUMsY0FBYyxHQUFBLEtBQU87SUFFckUsb0RBQW9EO0lBQ3BELG9EQUFvRDtJQUNwRCxJQUFJLENBQUNELG9CQUFvQjtRQUN2QixPQUFPO0lBQ1Q7SUFFQSxJQUFJRSxJQUFJQyxRQUFRLENBQUNILHFCQUFxQjtRQUNwQyxNQUFNSSxNQUFNLElBQUlGLElBQUlGLG9CQUFvQkssUUFBUTtRQUNoRCxPQUFPRCxJQUFJRSxRQUFRLENBQUMsT0FBT0YsSUFBSUcsS0FBSyxDQUFDLEdBQUcsQ0FBQyxLQUFLSDtJQUNoRDtJQUVBLGlEQUFpRDtJQUNqRCw0QkFBNEI7SUFDNUIsT0FBUSxNQUFHSjtBQUNiIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDg0MDIsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvY2xpZW50L2Rldi9ob3QtcmVsb2FkZXIvZ2V0LXNvY2tldC11cmwudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbm9ybWFsaXplZEFzc2V0UHJlZml4IH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2xpYi9ub3JtYWxpemVkLWFzc2V0LXByZWZpeCdcblxuZnVuY3Rpb24gZ2V0U29ja2V0UHJvdG9jb2woYXNzZXRQcmVmaXg6IHN0cmluZyk6IHN0cmluZyB7XG4gIGxldCBwcm90b2NvbCA9IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbFxuXG4gIHRyeSB7XG4gICAgLy8gYXNzZXRQcmVmaXggaXMgYSB1cmxcbiAgICBwcm90b2NvbCA9IG5ldyBVUkwoYXNzZXRQcmVmaXgpLnByb3RvY29sXG4gIH0gY2F0Y2gge31cblxuICByZXR1cm4gcHJvdG9jb2wgPT09ICdodHRwOicgPyAnd3M6JyA6ICd3c3M6J1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U29ja2V0VXJsKGFzc2V0UHJlZml4OiBzdHJpbmcgfCB1bmRlZmluZWQpOiBzdHJpbmcge1xuICBjb25zdCBwcmVmaXggPSBub3JtYWxpemVkQXNzZXRQcmVmaXgoYXNzZXRQcmVmaXgpXG4gIGNvbnN0IHByb3RvY29sID0gZ2V0U29ja2V0UHJvdG9jb2woYXNzZXRQcmVmaXggfHwgJycpXG5cbiAgaWYgKFVSTC5jYW5QYXJzZShwcmVmaXgpKSB7XG4gICAgLy8gc2luY2Ugbm9ybWFsaXplZCBhc3NldCBwcmVmaXggaXMgZW5zdXJlZCB0byBiZSBhIFVSTCBmb3JtYXQsXG4gICAgLy8gd2UgY2FuIHNhZmVseSByZXBsYWNlIHRoZSBwcm90b2NvbFxuICAgIHJldHVybiBwcmVmaXgucmVwbGFjZSgvXmh0dHAvLCAnd3MnKVxuICB9XG5cbiAgY29uc3QgeyBob3N0bmFtZSwgcG9ydCB9ID0gd2luZG93LmxvY2F0aW9uXG4gIHJldHVybiBgJHtwcm90b2NvbH0vLyR7aG9zdG5hbWV9JHtwb3J0ID8gYDoke3BvcnR9YCA6ICcnfSR7cHJlZml4fWBcbn1cbiJdLCJuYW1lcyI6WyJnZXRTb2NrZXRVcmwiLCJnZXRTb2NrZXRQcm90b2NvbCIsImFzc2V0UHJlZml4IiwicHJvdG9jb2wiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsIlVSTCIsInByZWZpeCIsIm5vcm1hbGl6ZWRBc3NldFByZWZpeCIsImNhblBhcnNlIiwicmVwbGFjZSIsImhvc3RuYW1lIiwicG9ydCJdLCJtYXBwaW5ncyI6Ijs7OytCQWFnQkEsZ0JBQUFBOzs7ZUFBQUE7Ozt1Q0Fic0I7QUFFdEMsU0FBU0Msa0JBQWtCQyxXQUFtQjtJQUM1QyxJQUFJQyxXQUFXQyxPQUFPQyxRQUFRLENBQUNGLFFBQVE7SUFFdkMsSUFBSTtRQUNGLHVCQUF1QjtRQUN2QkEsV0FBVyxJQUFJRyxJQUFJSixhQUFhQyxRQUFRO0lBQzFDLEVBQUUsT0FBQSxHQUFNLENBQUM7SUFFVCxPQUFPQSxhQUFhLFVBQVUsUUFBUTtBQUN4QztBQUVPLFNBQVNILGFBQWFFLFdBQStCO0lBQzFELE1BQU1LLFNBQVNDLENBQUFBLEdBQUFBLHVCQUFBQSxxQkFBcUIsRUFBQ047SUFDckMsTUFBTUMsV0FBV0Ysa0JBQWtCQyxlQUFlO0lBRWxELElBQUlJLElBQUlHLFFBQVEsQ0FBQ0YsU0FBUztRQUN4QiwrREFBK0Q7UUFDL0QscUNBQXFDO1FBQ3JDLE9BQU9BLE9BQU9HLE9BQU8sQ0FBQyxTQUFTO0lBQ2pDO0lBRUEsTUFBTSxFQUFFQyxRQUFRLEVBQUVDLElBQUksRUFBRSxHQUFHUixPQUFPQyxRQUFRO0lBQzFDLE9BQVVGLFdBQVMsT0FBSVEsV0FBV0MsQ0FBQUEsT0FBUSxNQUFHQSxPQUFTLEVBQUMsSUFBSUw7QUFDN0QiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogODQ0NCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvZGV2L2hvdC1yZWxvYWRlci9hcHAvdXNlLXdlYnNvY2tldC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlQ29udGV4dCwgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IEdsb2JhbExheW91dFJvdXRlckNvbnRleHQgfSBmcm9tICcuLi8uLi8uLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB7IGdldFNvY2tldFVybCB9IGZyb20gJy4uL2dldC1zb2NrZXQtdXJsJ1xuaW1wb3J0IHR5cGUgeyBUdXJib3BhY2tNc2dUb0Jyb3dzZXIgfSBmcm9tICcuLi8uLi8uLi8uLi9zZXJ2ZXIvZGV2L2hvdC1yZWxvYWRlci10eXBlcydcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVdlYnNvY2tldChhc3NldFByZWZpeDogc3RyaW5nKSB7XG4gIGNvbnN0IHdlYlNvY2tldFJlZiA9IHVzZVJlZjxXZWJTb2NrZXQ+KHVuZGVmaW5lZClcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh3ZWJTb2NrZXRSZWYuY3VycmVudCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgdXJsID0gZ2V0U29ja2V0VXJsKGFzc2V0UHJlZml4KVxuXG4gICAgd2ViU29ja2V0UmVmLmN1cnJlbnQgPSBuZXcgd2luZG93LldlYlNvY2tldChgJHt1cmx9L19uZXh0L3dlYnBhY2staG1yYClcbiAgfSwgW2Fzc2V0UHJlZml4XSlcblxuICByZXR1cm4gd2ViU29ja2V0UmVmXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VTZW5kTWVzc2FnZSh3ZWJTb2NrZXRSZWY6IFJldHVyblR5cGU8dHlwZW9mIHVzZVdlYnNvY2tldD4pIHtcbiAgY29uc3Qgc2VuZE1lc3NhZ2UgPSB1c2VDYWxsYmFjayhcbiAgICAoZGF0YTogc3RyaW5nKSA9PiB7XG4gICAgICBjb25zdCBzb2NrZXQgPSB3ZWJTb2NrZXRSZWYuY3VycmVudFxuICAgICAgaWYgKCFzb2NrZXQgfHwgc29ja2V0LnJlYWR5U3RhdGUgIT09IHNvY2tldC5PUEVOKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgcmV0dXJuIHNvY2tldC5zZW5kKGRhdGEpXG4gICAgfSxcbiAgICBbd2ViU29ja2V0UmVmXVxuICApXG4gIHJldHVybiBzZW5kTWVzc2FnZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlVHVyYm9wYWNrKFxuICBzZW5kTWVzc2FnZTogUmV0dXJuVHlwZTx0eXBlb2YgdXNlU2VuZE1lc3NhZ2U+LFxuICBvblVwZGF0ZUVycm9yOiAoZXJyOiB1bmtub3duKSA9PiB2b2lkXG4pIHtcbiAgY29uc3QgdHVyYm9wYWNrU3RhdGUgPSB1c2VSZWY8e1xuICAgIGluaXQ6IGJvb2xlYW5cbiAgICBxdWV1ZTogQXJyYXk8VHVyYm9wYWNrTXNnVG9Ccm93c2VyPiB8IHVuZGVmaW5lZFxuICAgIGNhbGxiYWNrOiAoKG1zZzogVHVyYm9wYWNrTXNnVG9Ccm93c2VyKSA9PiB2b2lkKSB8IHVuZGVmaW5lZFxuICB9Pih7XG4gICAgaW5pdDogZmFsc2UsXG4gICAgLy8gVW50aWwgdGhlIGR5bmFtaWMgaW1wb3J0IHJlc29sdmVzLCBxdWV1ZSBhbnkgdHVyYm9wYWNrIG1lc3NhZ2VzIHdoaWNoIHdpbGwgYmUgcmVwbGF5ZWQuXG4gICAgcXVldWU6IFtdLFxuICAgIGNhbGxiYWNrOiB1bmRlZmluZWQsXG4gIH0pXG5cbiAgY29uc3QgcHJvY2Vzc1R1cmJvcGFja01lc3NhZ2UgPSB1c2VDYWxsYmFjaygobXNnOiBUdXJib3BhY2tNc2dUb0Jyb3dzZXIpID0+IHtcbiAgICBjb25zdCB7IGNhbGxiYWNrLCBxdWV1ZSB9ID0gdHVyYm9wYWNrU3RhdGUuY3VycmVudFxuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2sobXNnKVxuICAgIH0gZWxzZSB7XG4gICAgICBxdWV1ZSEucHVzaChtc2cpXG4gICAgfVxuICB9LCBbXSlcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHsgY3VycmVudDogaW5pdEN1cnJlbnQgfSA9IHR1cmJvcGFja1N0YXRlXG4gICAgLy8gVE9ETyhXRUItMTU4OSk6IG9ubHkgaW5zdGFsbCBpZiBgcHJvY2Vzcy50dXJib3BhY2tgIHNldC5cbiAgICBpZiAoaW5pdEN1cnJlbnQuaW5pdCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGluaXRDdXJyZW50LmluaXQgPSB0cnVlXG5cbiAgICBpbXBvcnQoXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHJlcXVpcmVzIFwibW9kdWxlUmVzb2x1dGlvblwiOiBcIm5vZGUxNlwiIGluIHRzY29uZmlnLmpzb24gYW5kIG5vdCAudHMgZXh0ZW5zaW9uXG4gICAgICAnQHZlcmNlbC90dXJib3BhY2stZWNtYXNjcmlwdC1ydW50aW1lL2Jyb3dzZXIvZGV2L2htci1jbGllbnQvaG1yLWNsaWVudC50cydcbiAgICApLnRoZW4oKHsgY29ubmVjdCB9KSA9PiB7XG4gICAgICBjb25zdCB7IGN1cnJlbnQgfSA9IHR1cmJvcGFja1N0YXRlXG4gICAgICBjb25uZWN0KHtcbiAgICAgICAgYWRkTWVzc2FnZUxpc3RlbmVyKGNiOiAobXNnOiBUdXJib3BhY2tNc2dUb0Jyb3dzZXIpID0+IHZvaWQpIHtcbiAgICAgICAgICBjdXJyZW50LmNhbGxiYWNrID0gY2JcblxuICAgICAgICAgIC8vIFJlcGxheSBhbGwgVHVyYm9wYWNrIG1lc3NhZ2VzIGJlZm9yZSB3ZSB3ZXJlIGFibGUgdG8gZXN0YWJsaXNoIHRoZSBITVIgY2xpZW50LlxuICAgICAgICAgIGZvciAoY29uc3QgbXNnIG9mIGN1cnJlbnQucXVldWUhKSB7XG4gICAgICAgICAgICBjYihtc2cpXG4gICAgICAgICAgfVxuICAgICAgICAgIGN1cnJlbnQucXVldWUgPSB1bmRlZmluZWRcbiAgICAgICAgfSxcbiAgICAgICAgc2VuZE1lc3NhZ2UsXG4gICAgICAgIG9uVXBkYXRlRXJyb3IsXG4gICAgICB9KVxuICAgIH0pXG4gIH0sIFtzZW5kTWVzc2FnZSwgb25VcGRhdGVFcnJvcl0pXG5cbiAgcmV0dXJuIHByb2Nlc3NUdXJib3BhY2tNZXNzYWdlXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VXZWJzb2NrZXRQaW5nKFxuICB3ZWJzb2NrZXRSZWY6IFJldHVyblR5cGU8dHlwZW9mIHVzZVdlYnNvY2tldD5cbikge1xuICBjb25zdCBzZW5kTWVzc2FnZSA9IHVzZVNlbmRNZXNzYWdlKHdlYnNvY2tldFJlZilcbiAgY29uc3QgeyB0cmVlIH0gPSB1c2VDb250ZXh0KEdsb2JhbExheW91dFJvdXRlckNvbnRleHQpXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBOZXZlciBzZW5kIHBpbmdzIHdoZW4gdXNpbmcgVHVyYm9wYWNrIGFzIGl0J3Mgbm90IHVzZWQuXG4gICAgLy8gUGluZ3Mgd2VyZSBvcmlnaW5hbGx5IHVzZWQgdG8ga2VlcCB0cmFjayBvZiBhY3RpdmUgcm91dGVzIGluIG9uLWRlbWFuZC1lbnRyaWVzIHdpdGggd2VicGFjay5cbiAgICBpZiAocHJvY2Vzcy5lbnYuVFVSQk9QQUNLKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBUYWtlbiBmcm9tIG9uLWRlbWFuZC1lbnRyaWVzLWNsaWVudC5qc1xuICAgIGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgc2VuZE1lc3NhZ2UoXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBldmVudDogJ3BpbmcnLFxuICAgICAgICAgIHRyZWUsXG4gICAgICAgICAgYXBwRGlyUm91dGU6IHRydWUsXG4gICAgICAgIH0pXG4gICAgICApXG4gICAgfSwgMjUwMClcbiAgICByZXR1cm4gKCkgPT4gY2xlYXJJbnRlcnZhbChpbnRlcnZhbClcbiAgfSwgW3RyZWUsIHNlbmRNZXNzYWdlXSlcbn1cbiJdLCJuYW1lcyI6WyJ1c2VTZW5kTWVzc2FnZSIsInVzZVR1cmJvcGFjayIsInVzZVdlYnNvY2tldCIsInVzZVdlYnNvY2tldFBpbmciLCJhc3NldFByZWZpeCIsIndlYlNvY2tldFJlZiIsInVzZVJlZiIsInVuZGVmaW5lZCIsInVzZUVmZmVjdCIsImN1cnJlbnQiLCJ1cmwiLCJnZXRTb2NrZXRVcmwiLCJ3aW5kb3ciLCJXZWJTb2NrZXQiLCJzZW5kTWVzc2FnZSIsInVzZUNhbGxiYWNrIiwiZGF0YSIsInNvY2tldCIsInJlYWR5U3RhdGUiLCJPUEVOIiwic2VuZCIsIm9uVXBkYXRlRXJyb3IiLCJ0dXJib3BhY2tTdGF0ZSIsImluaXQiLCJxdWV1ZSIsImNhbGxiYWNrIiwicHJvY2Vzc1R1cmJvcGFja01lc3NhZ2UiLCJtc2ciLCJwdXNoIiwiaW5pdEN1cnJlbnQiLCJ0aGVuIiwiY29ubmVjdCIsImFkZE1lc3NhZ2VMaXN0ZW5lciIsImNiIiwid2Vic29ja2V0UmVmIiwidHJlZSIsInVzZUNvbnRleHQiLCJHbG9iYWxMYXlvdXRSb3V0ZXJDb250ZXh0IiwicHJvY2VzcyIsImVudiIsIlRVUkJPUEFDSyIsImludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJKU09OIiwic3RyaW5naWZ5IiwiZXZlbnQiLCJhcHBEaXJSb3V0ZSIsImNsZWFySW50ZXJ2YWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7SUFxQmdCQSxjQUFjLEVBQUE7ZUFBZEE7O0lBY0FDLFlBQVksRUFBQTtlQUFaQTs7SUE5QkFDLFlBQVksRUFBQTtlQUFaQTs7SUFzRkFDLGdCQUFnQixFQUFBO2VBQWhCQTs7O3VCQTNGMkM7K0NBQ2pCOzhCQUNiO0FBR3RCLFNBQVNELGFBQWFFLFdBQW1CO0lBQzlDLE1BQU1DLGVBQWVDLENBQUFBLEdBQUFBLE9BQUFBLE1BQU0sRUFBWUM7SUFFdkNDLENBQUFBLEdBQUFBLE9BQUFBLFNBQVMsRUFBQztRQUNSLElBQUlILGFBQWFJLE9BQU8sRUFBRTtZQUN4QjtRQUNGO1FBRUEsTUFBTUMsTUFBTUMsQ0FBQUEsR0FBQUEsY0FBQUEsWUFBWSxFQUFDUDtRQUV6QkMsYUFBYUksT0FBTyxHQUFHLElBQUlHLE9BQU9DLFNBQVMsQ0FBRSxLQUFFSCxNQUFJO0lBQ3JELEdBQUc7UUFBQ047S0FBWTtJQUVoQixPQUFPQztBQUNUO0FBRU8sU0FBU0wsZUFBZUssWUFBNkM7SUFDMUUsTUFBTVMsY0FBY0MsQ0FBQUEsR0FBQUEsT0FBQUEsV0FBVyxFQUM3QixDQUFDQztRQUNDLE1BQU1DLFNBQVNaLGFBQWFJLE9BQU87UUFDbkMsSUFBSSxDQUFDUSxVQUFVQSxPQUFPQyxVQUFVLEtBQUtELE9BQU9FLElBQUksRUFBRTtZQUNoRDtRQUNGO1FBQ0EsT0FBT0YsT0FBT0csSUFBSSxDQUFDSjtJQUNyQixHQUNBO1FBQUNYO0tBQWE7SUFFaEIsT0FBT1M7QUFDVDtBQUVPLFNBQVNiLGFBQ2RhLFdBQThDLEVBQzlDTyxhQUFxQztJQUVyQyxNQUFNQyxpQkFBaUJoQixDQUFBQSxHQUFBQSxPQUFBQSxNQUFNLEVBSTFCO1FBQ0RpQixNQUFNO1FBQ04sMEZBQTBGO1FBQzFGQyxPQUFPLEVBQUU7UUFDVEMsVUFBVWxCO0lBQ1o7SUFFQSxNQUFNbUIsMEJBQTBCWCxDQUFBQSxHQUFBQSxPQUFBQSxXQUFXLEVBQUMsQ0FBQ1k7UUFDM0MsTUFBTSxFQUFFRixRQUFRLEVBQUVELEtBQUssRUFBRSxHQUFHRixlQUFlYixPQUFPO1FBQ2xELElBQUlnQixVQUFVO1lBQ1pBLFNBQVNFO1FBQ1gsT0FBTztZQUNMSCxNQUFPSSxJQUFJLENBQUNEO1FBQ2Q7SUFDRixHQUFHLEVBQUU7SUFFTG5CLENBQUFBLEdBQUFBLE9BQUFBLFNBQVMsRUFBQztRQUNSLE1BQU0sRUFBRUMsU0FBU29CLFdBQVcsRUFBRSxHQUFHUDtRQUNqQywyREFBMkQ7UUFDM0QsSUFBSU8sWUFBWU4sSUFBSSxFQUFFO1lBQ3BCO1FBQ0Y7UUFDQU0sWUFBWU4sSUFBSSxHQUFHO1FBRW5CLE1BQU0sQ0FDSixnR0FBZ0csbUNBRWhHTyxJQUFJLENBQUMsQ0FBQTtnQkFBQyxFQUFFQyxPQUFPLEVBQUUsR0FBQTtZQUNqQixNQUFNLEVBQUV0QixPQUFPLEVBQUUsR0FBR2E7WUFDcEJTLFFBQVE7Z0JBQ05DLG9CQUFtQkMsRUFBd0M7b0JBQ3pEeEIsUUFBUWdCLFFBQVEsR0FBR1E7b0JBRW5CLGlGQUFpRjtvQkFDakYsS0FBSyxNQUFNTixPQUFPbEIsUUFBUWUsS0FBSyxDQUFHO3dCQUNoQ1MsR0FBR047b0JBQ0w7b0JBQ0FsQixRQUFRZSxLQUFLLEdBQUdqQjtnQkFDbEI7Z0JBQ0FPO2dCQUNBTztZQUNGO1FBQ0Y7SUFDRixHQUFHO1FBQUNQO1FBQWFPO0tBQWM7SUFFL0IsT0FBT0s7QUFDVDtBQUVPLFNBQVN2QixpQkFDZCtCLFlBQTZDO0lBRTdDLE1BQU1wQixjQUFjZCxlQUFla0M7SUFDbkMsTUFBTSxFQUFFQyxJQUFJLEVBQUUsR0FBR0MsQ0FBQUEsR0FBQUEsT0FBQUEsVUFBVSxFQUFDQywrQkFBQUEseUJBQXlCO0lBRXJEN0IsQ0FBQUEsR0FBQUEsT0FBQUEsU0FBUyxFQUFDO1FBQ1IsMERBQTBEO1FBQzFELCtGQUErRjtRQUMvRixJQUFJOEIsUUFBUUMsR0FBRyxDQUFDQyxTQUFTLGVBQUU7WUFDekI7UUFDRjs7O1FBRUEseUNBQXlDO1FBQ3pDLE1BQU1DLFdBQVdDLFlBQVk7SUFVL0IsR0FBRztRQUFDUDtRQUFNckI7S0FBWTtBQUN4QiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA4NTc2LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL3NlcnZlci9kZXYvaG90LXJlbG9hZGVyLXR5cGVzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgSW5jb21pbmdNZXNzYWdlLCBTZXJ2ZXJSZXNwb25zZSB9IGZyb20gJ2h0dHAnXG5pbXBvcnQgdHlwZSB7IFVybE9iamVjdCB9IGZyb20gJ3VybCdcbmltcG9ydCB0eXBlIHsgRHVwbGV4IH0gZnJvbSAnc3RyZWFtJ1xuaW1wb3J0IHR5cGUgeyB3ZWJwYWNrIH0gZnJvbSAnbmV4dC9kaXN0L2NvbXBpbGVkL3dlYnBhY2svd2VicGFjaydcbmltcG9ydCB0eXBlIGdldEJhc2VXZWJwYWNrQ29uZmlnIGZyb20gJy4uLy4uL2J1aWxkL3dlYnBhY2stY29uZmlnJ1xuaW1wb3J0IHR5cGUgeyBSb3V0ZURlZmluaXRpb24gfSBmcm9tICcuLi9yb3V0ZS1kZWZpbml0aW9ucy9yb3V0ZS1kZWZpbml0aW9uJ1xuaW1wb3J0IHR5cGUgeyBQcm9qZWN0LCBVcGRhdGUgYXMgVHVyYm9wYWNrVXBkYXRlIH0gZnJvbSAnLi4vLi4vYnVpbGQvc3djL3R5cGVzJ1xuaW1wb3J0IHR5cGUgeyBWZXJzaW9uSW5mbyB9IGZyb20gJy4vcGFyc2UtdmVyc2lvbi1pbmZvJ1xuaW1wb3J0IHR5cGUgeyBEZWJ1Z0luZm8gfSBmcm9tICcuLi8uLi9uZXh0LWRldnRvb2xzL3NoYXJlZC90eXBlcydcbmltcG9ydCB0eXBlIHsgRGV2SW5kaWNhdG9yU2VydmVyU3RhdGUgfSBmcm9tICcuL2Rldi1pbmRpY2F0b3Itc2VydmVyLXN0YXRlJ1xuXG5leHBvcnQgY29uc3QgZW51bSBITVJfQUNUSU9OU19TRU5UX1RPX0JST1dTRVIge1xuICBBRERFRF9QQUdFID0gJ2FkZGVkUGFnZScsXG4gIFJFTU9WRURfUEFHRSA9ICdyZW1vdmVkUGFnZScsXG4gIFJFTE9BRF9QQUdFID0gJ3JlbG9hZFBhZ2UnLFxuICBTRVJWRVJfQ09NUE9ORU5UX0NIQU5HRVMgPSAnc2VydmVyQ29tcG9uZW50Q2hhbmdlcycsXG4gIE1JRERMRVdBUkVfQ0hBTkdFUyA9ICdtaWRkbGV3YXJlQ2hhbmdlcycsXG4gIENMSUVOVF9DSEFOR0VTID0gJ2NsaWVudENoYW5nZXMnLFxuICBTRVJWRVJfT05MWV9DSEFOR0VTID0gJ3NlcnZlck9ubHlDaGFuZ2VzJyxcbiAgU1lOQyA9ICdzeW5jJyxcbiAgQlVJTFQgPSAnYnVpbHQnLFxuICBCVUlMRElORyA9ICdidWlsZGluZycsXG4gIERFVl9QQUdFU19NQU5JRkVTVF9VUERBVEUgPSAnZGV2UGFnZXNNYW5pZmVzdFVwZGF0ZScsXG4gIFRVUkJPUEFDS19NRVNTQUdFID0gJ3R1cmJvcGFjay1tZXNzYWdlJyxcbiAgU0VSVkVSX0VSUk9SID0gJ3NlcnZlckVycm9yJyxcbiAgVFVSQk9QQUNLX0NPTk5FQ1RFRCA9ICd0dXJib3BhY2stY29ubmVjdGVkJyxcbiAgSVNSX01BTklGRVNUID0gJ2lzck1hbmlmZXN0JyxcbiAgREVWX0lORElDQVRPUiA9ICdkZXZJbmRpY2F0b3InLFxufVxuXG5pbnRlcmZhY2UgU2VydmVyRXJyb3JBY3Rpb24ge1xuICBhY3Rpb246IEhNUl9BQ1RJT05TX1NFTlRfVE9fQlJPV1NFUi5TRVJWRVJfRVJST1JcbiAgZXJyb3JKU09OOiBzdHJpbmdcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUdXJib3BhY2tNZXNzYWdlQWN0aW9uIHtcbiAgYWN0aW9uOiBITVJfQUNUSU9OU19TRU5UX1RPX0JST1dTRVIuVFVSQk9QQUNLX01FU1NBR0VcbiAgZGF0YTogVHVyYm9wYWNrVXBkYXRlIHwgVHVyYm9wYWNrVXBkYXRlW11cbn1cblxuaW50ZXJmYWNlIEJ1aWxkaW5nQWN0aW9uIHtcbiAgYWN0aW9uOiBITVJfQUNUSU9OU19TRU5UX1RPX0JST1dTRVIuQlVJTERJTkdcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb21waWxhdGlvbkVycm9yIHtcbiAgbW9kdWxlTmFtZT86IHN0cmluZ1xuICBtZXNzYWdlOiBzdHJpbmdcbiAgZGV0YWlscz86IHN0cmluZ1xuICBtb2R1bGVUcmFjZT86IEFycmF5PHsgbW9kdWxlTmFtZT86IHN0cmluZyB9PlxuICBzdGFjaz86IHN0cmluZ1xufVxuZXhwb3J0IGludGVyZmFjZSBTeW5jQWN0aW9uIHtcbiAgYWN0aW9uOiBITVJfQUNUSU9OU19TRU5UX1RPX0JST1dTRVIuU1lOQ1xuICBoYXNoOiBzdHJpbmdcbiAgZXJyb3JzOiBSZWFkb25seUFycmF5PENvbXBpbGF0aW9uRXJyb3I+XG4gIHdhcm5pbmdzOiBSZWFkb25seUFycmF5PENvbXBpbGF0aW9uRXJyb3I+XG4gIHZlcnNpb25JbmZvOiBWZXJzaW9uSW5mb1xuICB1cGRhdGVkTW9kdWxlcz86IFJlYWRvbmx5QXJyYXk8c3RyaW5nPlxuICBkZWJ1Zz86IERlYnVnSW5mb1xuICBkZXZJbmRpY2F0b3I6IERldkluZGljYXRvclNlcnZlclN0YXRlXG59XG5pbnRlcmZhY2UgQnVpbHRBY3Rpb24ge1xuICBhY3Rpb246IEhNUl9BQ1RJT05TX1NFTlRfVE9fQlJPV1NFUi5CVUlMVFxuICBoYXNoOiBzdHJpbmdcbiAgZXJyb3JzOiBSZWFkb25seUFycmF5PENvbXBpbGF0aW9uRXJyb3I+XG4gIHdhcm5pbmdzOiBSZWFkb25seUFycmF5PENvbXBpbGF0aW9uRXJyb3I+XG4gIHVwZGF0ZWRNb2R1bGVzPzogUmVhZG9ubHlBcnJheTxzdHJpbmc+XG59XG5cbmludGVyZmFjZSBBZGRlZFBhZ2VBY3Rpb24ge1xuICBhY3Rpb246IEhNUl9BQ1RJT05TX1NFTlRfVE9fQlJPV1NFUi5BRERFRF9QQUdFXG4gIGRhdGE6IFtwYWdlOiBzdHJpbmcgfCBudWxsXVxufVxuXG5pbnRlcmZhY2UgUmVtb3ZlZFBhZ2VBY3Rpb24ge1xuICBhY3Rpb246IEhNUl9BQ1RJT05TX1NFTlRfVE9fQlJPV1NFUi5SRU1PVkVEX1BBR0VcbiAgZGF0YTogW3BhZ2U6IHN0cmluZyB8IG51bGxdXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVsb2FkUGFnZUFjdGlvbiB7XG4gIGFjdGlvbjogSE1SX0FDVElPTlNfU0VOVF9UT19CUk9XU0VSLlJFTE9BRF9QQUdFXG4gIGRhdGE6IHN0cmluZ1xufVxuXG5pbnRlcmZhY2UgU2VydmVyQ29tcG9uZW50Q2hhbmdlc0FjdGlvbiB7XG4gIGFjdGlvbjogSE1SX0FDVElPTlNfU0VOVF9UT19CUk9XU0VSLlNFUlZFUl9DT01QT05FTlRfQ0hBTkdFU1xuICBoYXNoOiBzdHJpbmdcbn1cblxuaW50ZXJmYWNlIE1pZGRsZXdhcmVDaGFuZ2VzQWN0aW9uIHtcbiAgZXZlbnQ6IEhNUl9BQ1RJT05TX1NFTlRfVE9fQlJPV1NFUi5NSURETEVXQVJFX0NIQU5HRVNcbn1cblxuaW50ZXJmYWNlIENsaWVudENoYW5nZXNBY3Rpb24ge1xuICBldmVudDogSE1SX0FDVElPTlNfU0VOVF9UT19CUk9XU0VSLkNMSUVOVF9DSEFOR0VTXG59XG5cbmludGVyZmFjZSBTZXJ2ZXJPbmx5Q2hhbmdlc0FjdGlvbiB7XG4gIGV2ZW50OiBITVJfQUNUSU9OU19TRU5UX1RPX0JST1dTRVIuU0VSVkVSX09OTFlfQ0hBTkdFU1xuICBwYWdlczogUmVhZG9ubHlBcnJheTxzdHJpbmc+XG59XG5cbmludGVyZmFjZSBEZXZQYWdlc01hbmlmZXN0VXBkYXRlQWN0aW9uIHtcbiAgYWN0aW9uOiBITVJfQUNUSU9OU19TRU5UX1RPX0JST1dTRVIuREVWX1BBR0VTX01BTklGRVNUX1VQREFURVxuICBkYXRhOiBbXG4gICAge1xuICAgICAgZGV2UGFnZXNNYW5pZmVzdDogdHJ1ZVxuICAgIH0sXG4gIF1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBUdXJib3BhY2tDb25uZWN0ZWRBY3Rpb24ge1xuICBhY3Rpb246IEhNUl9BQ1RJT05TX1NFTlRfVE9fQlJPV1NFUi5UVVJCT1BBQ0tfQ09OTkVDVEVEXG4gIGRhdGE6IHsgc2Vzc2lvbklkOiBudW1iZXIgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFwcElzck1hbmlmZXN0QWN0aW9uIHtcbiAgYWN0aW9uOiBITVJfQUNUSU9OU19TRU5UX1RPX0JST1dTRVIuSVNSX01BTklGRVNUXG4gIGRhdGE6IFJlY29yZDxzdHJpbmcsIGJvb2xlYW4+XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGV2SW5kaWNhdG9yQWN0aW9uIHtcbiAgYWN0aW9uOiBITVJfQUNUSU9OU19TRU5UX1RPX0JST1dTRVIuREVWX0lORElDQVRPUlxuICBkZXZJbmRpY2F0b3I6IERldkluZGljYXRvclNlcnZlclN0YXRlXG59XG5cbmV4cG9ydCB0eXBlIEhNUl9BQ1RJT05fVFlQRVMgPVxuICB8IFR1cmJvcGFja01lc3NhZ2VBY3Rpb25cbiAgfCBUdXJib3BhY2tDb25uZWN0ZWRBY3Rpb25cbiAgfCBCdWlsZGluZ0FjdGlvblxuICB8IFN5bmNBY3Rpb25cbiAgfCBCdWlsdEFjdGlvblxuICB8IEFkZGVkUGFnZUFjdGlvblxuICB8IFJlbW92ZWRQYWdlQWN0aW9uXG4gIHwgUmVsb2FkUGFnZUFjdGlvblxuICB8IFNlcnZlckNvbXBvbmVudENoYW5nZXNBY3Rpb25cbiAgfCBDbGllbnRDaGFuZ2VzQWN0aW9uXG4gIHwgTWlkZGxld2FyZUNoYW5nZXNBY3Rpb25cbiAgfCBTZXJ2ZXJPbmx5Q2hhbmdlc0FjdGlvblxuICB8IERldlBhZ2VzTWFuaWZlc3RVcGRhdGVBY3Rpb25cbiAgfCBTZXJ2ZXJFcnJvckFjdGlvblxuICB8IEFwcElzck1hbmlmZXN0QWN0aW9uXG4gIHwgRGV2SW5kaWNhdG9yQWN0aW9uXG5cbmV4cG9ydCB0eXBlIFR1cmJvcGFja01zZ1RvQnJvd3NlciA9XG4gIHwgeyB0eXBlOiBITVJfQUNUSU9OU19TRU5UX1RPX0JST1dTRVIuVFVSQk9QQUNLX01FU1NBR0U7IGRhdGE6IGFueSB9XG4gIHwge1xuICAgICAgdHlwZTogSE1SX0FDVElPTlNfU0VOVF9UT19CUk9XU0VSLlRVUkJPUEFDS19DT05ORUNURURcbiAgICAgIGRhdGE6IHsgc2Vzc2lvbklkOiBudW1iZXIgfVxuICAgIH1cblxuZXhwb3J0IGludGVyZmFjZSBOZXh0SnNIb3RSZWxvYWRlckludGVyZmFjZSB7XG4gIHR1cmJvcGFja1Byb2plY3Q/OiBQcm9qZWN0XG4gIGFjdGl2ZVdlYnBhY2tDb25maWdzPzogQXJyYXk8QXdhaXRlZDxSZXR1cm5UeXBlPHR5cGVvZiBnZXRCYXNlV2VicGFja0NvbmZpZz4+PlxuICBzZXJ2ZXJTdGF0czogd2VicGFjay5TdGF0cyB8IG51bGxcbiAgZWRnZVNlcnZlclN0YXRzOiB3ZWJwYWNrLlN0YXRzIHwgbnVsbFxuICBydW4oXG4gICAgcmVxOiBJbmNvbWluZ01lc3NhZ2UsXG4gICAgcmVzOiBTZXJ2ZXJSZXNwb25zZSxcbiAgICBwYXJzZWRVcmw6IFVybE9iamVjdFxuICApOiBQcm9taXNlPHsgZmluaXNoZWQ/OiB0cnVlIH0+XG5cbiAgc2V0SG1yU2VydmVyRXJyb3IoZXJyb3I6IEVycm9yIHwgbnVsbCk6IHZvaWRcbiAgY2xlYXJIbXJTZXJ2ZXJFcnJvcigpOiB2b2lkXG4gIHN0YXJ0KCk6IFByb21pc2U8dm9pZD5cbiAgc2VuZChhY3Rpb246IEhNUl9BQ1RJT05fVFlQRVMpOiB2b2lkXG4gIGdldENvbXBpbGF0aW9uRXJyb3JzKHBhZ2U6IHN0cmluZyk6IFByb21pc2U8YW55W10+XG4gIG9uSE1SKFxuICAgIHJlcTogSW5jb21pbmdNZXNzYWdlLFxuICAgIF9zb2NrZXQ6IER1cGxleCxcbiAgICBoZWFkOiBCdWZmZXIsXG4gICAgb25VcGdyYWRlOiAoY2xpZW50OiB7IHNlbmQoZGF0YTogc3RyaW5nKTogdm9pZCB9KSA9PiB2b2lkXG4gICk6IHZvaWRcbiAgaW52YWxpZGF0ZSh7XG4gICAgcmVsb2FkQWZ0ZXJJbnZhbGlkYXRpb24sXG4gIH06IHtcbiAgICByZWxvYWRBZnRlckludmFsaWRhdGlvbjogYm9vbGVhblxuICB9KTogUHJvbWlzZTx2b2lkPiB8IHZvaWRcbiAgYnVpbGRGYWxsYmFja0Vycm9yKCk6IFByb21pc2U8dm9pZD5cbiAgZW5zdXJlUGFnZSh7XG4gICAgcGFnZSxcbiAgICBjbGllbnRPbmx5LFxuICAgIGFwcFBhdGhzLFxuICAgIGRlZmluaXRpb24sXG4gICAgaXNBcHAsXG4gICAgdXJsLFxuICB9OiB7XG4gICAgcGFnZTogc3RyaW5nXG4gICAgY2xpZW50T25seTogYm9vbGVhblxuICAgIGFwcFBhdGhzPzogUmVhZG9ubHlBcnJheTxzdHJpbmc+IHwgbnVsbFxuICAgIGlzQXBwPzogYm9vbGVhblxuICAgIGRlZmluaXRpb246IFJvdXRlRGVmaW5pdGlvbiB8IHVuZGVmaW5lZFxuICAgIHVybD86IHN0cmluZ1xuICB9KTogUHJvbWlzZTx2b2lkPlxuICBjbG9zZSgpOiB2b2lkXG59XG4iXSwibmFtZXMiOlsiSE1SX0FDVElPTlNfU0VOVF9UT19CUk9XU0VSIl0sIm1hcHBpbmdzIjoiOzs7K0JBV2tCQSwrQkFBQUE7OztlQUFBQTs7O0FBQVgsSUFBV0EsOEJBQUFBLFdBQUFBLEdBQUFBLFNBQUFBLDJCQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7V0FBQUEiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogODYxMCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvZGV2L3JlcG9ydC1obXItbGF0ZW5jeS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJkZWNsYXJlIGdsb2JhbCB7XG4gIGludGVyZmFjZSBXaW5kb3cge1xuICAgIF9fTkVYVF9ITVJfTEFURU5DWV9DQjogKChsYXRlbmN5TXM6IG51bWJlcikgPT4gdm9pZCkgfCB1bmRlZmluZWRcbiAgfVxufVxuXG4vKipcbiAqIExvZ3MgaW5mb3JtYXRpb24gYWJvdXQgYSBjb21wbGV0ZWQgSE1SIHRvIHRoZSBjb25zb2xlLCB0aGUgc2VydmVyICh2aWEgYVxuICogYGNsaWVudC1obXItbGF0ZW5jeWAgZXZlbnQpLCBhbmQgdG8gYHNlbGYuX19ORVhUX0hNUl9MQVRFTkNZX0NCYCAoYSBkZWJ1Z2dpbmdcbiAqIGhvb2spLlxuICpcbiAqIEBwYXJhbSBoYXNVcGRhdGUgU2V0IHRoaXMgdG8gYGZhbHNlYCB0byBhdm9pZCByZXBvcnRpbmcgdGhlIEhNUiBldmVudCB2aWEgYVxuICogICBgY2xpZW50LWhtci1sYXRlbmN5YCBldmVudCBvciB0byBgc2VsZi5fX05FWFRfSE1SX0xBVEVOQ1lfQ0JgLiBVc2VkIGJ5XG4gKiAgIHR1cmJvcGFjayB3aGVuIHdlIG11c3QgcmVwb3J0IGEgbWVzc2FnZSB0byB0aGUgYnJvd3NlciBjb25zb2xlIChiZWNhdXNlIHdlXG4gKiAgIGFscmVhZHkgbG9nZ2VkIGEgXCJyZWJ1aWxkaW5nXCIgbWVzc2FnZSksIGJ1dCBpdCdzIG5vdCBhIHJlYWwgSE1SLCBzbyB3ZVxuICogICBkb24ndCB3YW50IHRvIGltcGFjdCBvdXIgdGVsZW1ldHJ5LlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZXBvcnRIbXJMYXRlbmN5KFxuICBzZW5kTWVzc2FnZTogKG1lc3NhZ2U6IHN0cmluZykgPT4gdm9pZCxcbiAgdXBkYXRlZE1vZHVsZXM6IFJlYWRvbmx5QXJyYXk8c3RyaW5nIHwgbnVtYmVyPixcbiAgc3RhcnRNc1NpbmNlRXBvY2g6IG51bWJlcixcbiAgZW5kTXNTaW5jZUVwb2NoOiBudW1iZXIsXG4gIGhhc1VwZGF0ZTogYm9vbGVhbiA9IHRydWVcbikge1xuICBjb25zdCBsYXRlbmN5TXMgPSBlbmRNc1NpbmNlRXBvY2ggLSBzdGFydE1zU2luY2VFcG9jaFxuICBjb25zb2xlLmxvZyhgW0Zhc3QgUmVmcmVzaF0gZG9uZSBpbiAke2xhdGVuY3lNc31tc2ApXG4gIGlmICghaGFzVXBkYXRlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgc2VuZE1lc3NhZ2UoXG4gICAgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgZXZlbnQ6ICdjbGllbnQtaG1yLWxhdGVuY3knLFxuICAgICAgaWQ6IHdpbmRvdy5fX25leHREZXZDbGllbnRJZCxcbiAgICAgIHN0YXJ0VGltZTogc3RhcnRNc1NpbmNlRXBvY2gsXG4gICAgICBlbmRUaW1lOiBlbmRNc1NpbmNlRXBvY2gsXG4gICAgICBwYWdlOiB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICB1cGRhdGVkTW9kdWxlcyxcbiAgICAgIC8vIFdoZXRoZXIgdGhlIHBhZ2UgKHRhYikgd2FzIGhpZGRlbiBhdCB0aGUgdGltZSB0aGUgZXZlbnQgb2NjdXJyZWQuXG4gICAgICAvLyBUaGlzIGNhbiBpbXBhY3QgdGhlIGFjY3VyYWN5IG9mIHRoZSBldmVudCdzIHRpbWluZy5cbiAgICAgIGlzUGFnZUhpZGRlbjogZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSAnaGlkZGVuJyxcbiAgICB9KVxuICApXG4gIGlmIChzZWxmLl9fTkVYVF9ITVJfTEFURU5DWV9DQikge1xuICAgIHNlbGYuX19ORVhUX0hNUl9MQVRFTkNZX0NCKGxhdGVuY3lNcylcbiAgfVxufVxuIl0sIm5hbWVzIjpbInJlcG9ydEhtckxhdGVuY3kiLCJzZW5kTWVzc2FnZSIsInVwZGF0ZWRNb2R1bGVzIiwic3RhcnRNc1NpbmNlRXBvY2giLCJlbmRNc1NpbmNlRXBvY2giLCJoYXNVcGRhdGUiLCJsYXRlbmN5TXMiLCJjb25zb2xlIiwibG9nIiwiSlNPTiIsInN0cmluZ2lmeSIsImV2ZW50IiwiaWQiLCJ3aW5kb3ciLCJfX25leHREZXZDbGllbnRJZCIsInN0YXJ0VGltZSIsImVuZFRpbWUiLCJwYWdlIiwibG9jYXRpb24iLCJwYXRobmFtZSIsImlzUGFnZUhpZGRlbiIsImRvY3VtZW50IiwidmlzaWJpbGl0eVN0YXRlIiwic2VsZiIsIl9fTkVYVF9ITVJfTEFURU5DWV9DQiJdLCJtYXBwaW5ncyI6Ijs7OytCQU1BOzs7Ozs7Ozs7O0NBVUMsR0FDRCxXQUFBOzs7ZUFBd0JBOzs7QUFBVCxTQUFTQSxpQkFDdEJDLFdBQXNDLEVBQ3RDQyxjQUE4QyxFQUM5Q0MsaUJBQXlCLEVBQ3pCQyxlQUF1QixFQUN2QkMsU0FBeUI7SUFBekJBLElBQUFBLGNBQUFBLEtBQUFBLEdBQUFBLFlBQXFCO0lBRXJCLE1BQU1DLFlBQVlGLGtCQUFrQkQ7SUFDcENJLFFBQVFDLEdBQUcsQ0FBRSw0QkFBeUJGLFlBQVU7SUFDaEQsSUFBSSxDQUFDRCxXQUFXO1FBQ2Q7SUFDRjtJQUNBSixZQUNFUSxLQUFLQyxTQUFTLENBQUM7UUFDYkMsT0FBTztRQUNQQyxJQUFJQyxPQUFPQyxpQkFBaUI7UUFDNUJDLFdBQVdaO1FBQ1hhLFNBQVNaO1FBQ1RhLE1BQU1KLE9BQU9LLFFBQVEsQ0FBQ0MsUUFBUTtRQUM5QmpCO1FBQ0Esb0VBQW9FO1FBQ3BFLHNEQUFzRDtRQUN0RGtCLGNBQWNDLFNBQVNDLGVBQWUsS0FBSztJQUM3QztJQUVGLElBQUlDLEtBQUtDLHFCQUFxQixFQUFFO1FBQzlCRCxLQUFLQyxxQkFBcUIsQ0FBQ2xCO0lBQzdCO0FBQ0YiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogODY2NCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvZGV2L2hvdC1yZWxvYWRlci90dXJib3BhY2staG90LXJlbG9hZGVyLWNvbW1vbi50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IFR1cmJvcGFja01lc3NhZ2VBY3Rpb24gfSBmcm9tICcuLi8uLi8uLi9zZXJ2ZXIvZGV2L2hvdC1yZWxvYWRlci10eXBlcydcbmltcG9ydCB0eXBlIHsgVXBkYXRlIGFzIFR1cmJvcGFja1VwZGF0ZSB9IGZyb20gJy4uLy4uLy4uL2J1aWxkL3N3Yy90eXBlcydcblxuZGVjbGFyZSBnbG9iYWwge1xuICBpbnRlcmZhY2UgV2luZG93IHtcbiAgICBfX05FWFRfSE1SX1RVUkJPUEFDS19SRVBPUlRfTk9JU1lfTk9PUF9FVkVOVFM6IGJvb2xlYW4gfCB1bmRlZmluZWRcbiAgfVxufVxuXG4vLyBIb3cgbG9uZyB0byB3YWl0IGJlZm9yZSByZXBvcnRpbmcgdGhlIEhNUiBzdGFydCwgdXNlZCB0byBzdXBwcmVzcyBpcnJlbGV2YW50XG4vLyBgQlVJTERJTkdgIGV2ZW50cy4gRG9lcyBub3QgaW1wYWN0IHJlcG9ydGVkIGxhdGVuY3kuXG5jb25zdCBUVVJCT1BBQ0tfSE1SX1NUQVJUX0RFTEFZX01TID0gMTAwXG5cbmludGVyZmFjZSBIbXJVcGRhdGUge1xuICBoYXNVcGRhdGVzOiBib29sZWFuXG4gIHVwZGF0ZWRNb2R1bGVzOiBTZXQ8c3RyaW5nPlxuICBzdGFydE1zU2luY2VFcG9jaDogbnVtYmVyXG4gIGVuZE1zU2luY2VFcG9jaDogbnVtYmVyXG59XG5cbmV4cG9ydCBjbGFzcyBUdXJib3BhY2tIbXIge1xuICAjdXBkYXRlZE1vZHVsZXM6IFNldDxzdHJpbmc+XG4gICNzdGFydE1zU2luY2VFcG9jaDogbnVtYmVyIHwgdW5kZWZpbmVkXG4gICNsYXN0VXBkYXRlTXNTaW5jZUVwb2NoOiBudW1iZXIgfCB1bmRlZmluZWRcbiAgI2RlZmVycmVkUmVwb3J0SG1yU3RhcnRJZDogUmV0dXJuVHlwZTx0eXBlb2Ygc2V0VGltZW91dD4gfCB1bmRlZmluZWRcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLiN1cGRhdGVkTW9kdWxlcyA9IG5ldyBTZXQoKVxuICB9XG5cbiAgLy8gSEFDSzogVHVyYm9wYWNrIHRlbmRzIHRvIGdlbmVyYXRlIGEgbG90IG9mIGlycmVsZXZhbnQgXCJCVUlMRElOR1wiIGFjdGlvbnMsXG4gIC8vIGFzIGl0IHJlcG9ydHMgKmFueSogY29tcGlsYXRpb24sIGluY2x1ZGluZyBmdWxseSBuby1vcC9jYWNoZWQgY29tcGlsYXRpb25zXG4gIC8vIGFuZCB0aG9zZSB1bnJlbGF0ZWQgdG8gSE1SLiBGaXhpbmcgdGhpcyB3b3VsZCByZXF1aXJlIHNpZ25pZmljYW50XG4gIC8vIGFyY2hpdGVjdHVyYWwgY2hhbmdlcy5cbiAgLy9cbiAgLy8gV29yayBhcm91bmQgdGhpcyBieSBkZWZlcnJpbmcgYW55IFwicmVidWlsZGluZ1wiIG1lc3NhZ2UgYnkgMTAwbXMuIElmIHdlIGdldFxuICAvLyBhIEJVSUxUIGV2ZW50IHdpdGhpbiB0aGF0IHRocmVzaG9sZCBhbmQgbm90aGluZyBoYXMgY2hhbmdlZCwganVzdCBzdXBwcmVzc1xuICAvLyB0aGUgbWVzc2FnZSBlbnRpcmVseS5cbiAgI3J1bkRlZmVycmVkUmVwb3J0SG1yU3RhcnQoKSB7XG4gICAgaWYgKHRoaXMuI2RlZmVycmVkUmVwb3J0SG1yU3RhcnRJZCAhPSBudWxsKSB7XG4gICAgICBjb25zb2xlLmxvZygnW0Zhc3QgUmVmcmVzaF0gcmVidWlsZGluZycpXG4gICAgICB0aGlzLiNjYW5jZWxEZWZlcnJlZFJlcG9ydEhtclN0YXJ0KClcbiAgICB9XG4gIH1cblxuICAjY2FuY2VsRGVmZXJyZWRSZXBvcnRIbXJTdGFydCgpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy4jZGVmZXJyZWRSZXBvcnRIbXJTdGFydElkKVxuICAgIHRoaXMuI2RlZmVycmVkUmVwb3J0SG1yU3RhcnRJZCA9IHVuZGVmaW5lZFxuICB9XG5cbiAgb25CdWlsZGluZygpIHtcbiAgICB0aGlzLiNsYXN0VXBkYXRlTXNTaW5jZUVwb2NoID0gdW5kZWZpbmVkXG4gICAgdGhpcy4jY2FuY2VsRGVmZXJyZWRSZXBvcnRIbXJTdGFydCgpXG4gICAgdGhpcy4jc3RhcnRNc1NpbmNlRXBvY2ggPSBEYXRlLm5vdygpXG5cbiAgICAvLyByZXBvcnQgdGhlIEhNUiBzdGFydCBhZnRlciBhIHNob3J0IGRlbGF5XG4gICAgdGhpcy4jZGVmZXJyZWRSZXBvcnRIbXJTdGFydElkID0gc2V0VGltZW91dChcbiAgICAgICgpID0+IHRoaXMuI3J1bkRlZmVycmVkUmVwb3J0SG1yU3RhcnQoKSxcbiAgICAgIC8vIGRlYnVnZ2luZyBmZWF0dXJlOiBkb24ndCBkZWZlci9zdXBwcmVzcyBub2lzeSBuby1vcCBITVIgdXBkYXRlIG1lc3NhZ2VzXG4gICAgICBzZWxmLl9fTkVYVF9ITVJfVFVSQk9QQUNLX1JFUE9SVF9OT0lTWV9OT09QX0VWRU5UU1xuICAgICAgICA/IDBcbiAgICAgICAgOiBUVVJCT1BBQ0tfSE1SX1NUQVJUX0RFTEFZX01TXG4gICAgKVxuICB9XG5cbiAgLyoqIEhlbHBlciBmb3Igb3RoZXIgYG9uRXZlbnRgIG1ldGhvZHMuICovXG4gICNvblVwZGF0ZSgpIHtcbiAgICB0aGlzLiNydW5EZWZlcnJlZFJlcG9ydEhtclN0YXJ0KClcbiAgICB0aGlzLiNsYXN0VXBkYXRlTXNTaW5jZUVwb2NoID0gRGF0ZS5ub3coKVxuICB9XG5cbiAgb25UdXJib3BhY2tNZXNzYWdlKG1zZzogVHVyYm9wYWNrTWVzc2FnZUFjdGlvbikge1xuICAgIHRoaXMuI29uVXBkYXRlKClcbiAgICBjb25zdCB1cGRhdGVkTW9kdWxlcyA9IGV4dHJhY3RNb2R1bGVzRnJvbVR1cmJvcGFja01lc3NhZ2UobXNnLmRhdGEpXG4gICAgZm9yIChjb25zdCBtb2R1bGUgb2YgdXBkYXRlZE1vZHVsZXMpIHtcbiAgICAgIHRoaXMuI3VwZGF0ZWRNb2R1bGVzLmFkZChtb2R1bGUpXG4gICAgfVxuICB9XG5cbiAgb25TZXJ2ZXJDb21wb25lbnRDaGFuZ2VzKCkge1xuICAgIHRoaXMuI29uVXBkYXRlKClcbiAgfVxuXG4gIG9uUmVsb2FkUGFnZSgpIHtcbiAgICB0aGlzLiNvblVwZGF0ZSgpXG4gIH1cblxuICBvblBhZ2VBZGRSZW1vdmUoKSB7XG4gICAgdGhpcy4jb25VcGRhdGUoKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIGBudWxsYCBpZiB0aGUgY2FsbGVyIHNob3VsZCBpZ25vcmUgdGhlIHVwZGF0ZSBlbnRpcmVseS4gUmV0dXJucyBhblxuICAgKiAgIG9iamVjdCB3aXRoIGBoYXNVcGRhdGVzOiBmYWxzZWAgaWYgdGhlIGNhbGxlciBzaG91bGQgcmVwb3J0IHRoZSBlbmQgb2ZcbiAgICogICB0aGUgSE1SIGluIHRoZSBicm93c2VyIGNvbnNvbGUsIGJ1dCB0aGUgSE1SIHdhcyBhIG5vLW9wLlxuICAgKi9cbiAgb25CdWlsdCgpOiBIbXJVcGRhdGUgfCBudWxsIHtcbiAgICAvLyBDaGVjayB0aGF0IHdlIGdvdCAqYW55KiBgVHVyYm9wYWNrTWVzc2FnZUFjdGlvbmAsIGV2ZW4gaWZcbiAgICAvLyBgdXBkYXRlZE1vZHVsZXNgIGlzIGVtcHR5IChub3QgZXZlcnl0aGluZyBnZXRzIHJlY29yZGVkIHRoZXJlKS5cbiAgICAvL1xuICAgIC8vIFRoZXJlJ3MgYWxzbyBhIGNhc2Ugd2hlcmUgYG9uQnVpbHRgIGdldHMgY2FsbGVkIGJlZm9yZSBgb25CdWlsZGluZ2AsXG4gICAgLy8gd2hpY2ggY2FuIGhhcHBlbiBkdXJpbmcgaW5pdGlhbCBwYWdlIGxvYWQuIElnbm9yZSB0aGF0IHRvbyFcbiAgICBjb25zdCBoYXNVcGRhdGVzID1cbiAgICAgIHRoaXMuI2xhc3RVcGRhdGVNc1NpbmNlRXBvY2ggIT0gbnVsbCAmJiB0aGlzLiNzdGFydE1zU2luY2VFcG9jaCAhPSBudWxsXG4gICAgaWYgKCFoYXNVcGRhdGVzICYmIHRoaXMuI2RlZmVycmVkUmVwb3J0SG1yU3RhcnRJZCAhPSBudWxsKSB7XG4gICAgICAvLyBzdXBwcmVzcyB0aGUgdXBkYXRlIGVudGlyZWx5XG4gICAgICB0aGlzLiNjYW5jZWxEZWZlcnJlZFJlcG9ydEhtclN0YXJ0KClcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIHRoaXMuI3J1bkRlZmVycmVkUmVwb3J0SG1yU3RhcnQoKVxuXG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgaGFzVXBkYXRlcyxcbiAgICAgIHVwZGF0ZWRNb2R1bGVzOiB0aGlzLiN1cGRhdGVkTW9kdWxlcyxcbiAgICAgIHN0YXJ0TXNTaW5jZUVwb2NoOiB0aGlzLiNzdGFydE1zU2luY2VFcG9jaCEsXG4gICAgICBlbmRNc1NpbmNlRXBvY2g6IHRoaXMuI2xhc3RVcGRhdGVNc1NpbmNlRXBvY2ggPz8gRGF0ZS5ub3coKSxcbiAgICB9XG4gICAgdGhpcy4jdXBkYXRlZE1vZHVsZXMgPSBuZXcgU2V0KClcbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdE1vZHVsZXNGcm9tVHVyYm9wYWNrTWVzc2FnZShcbiAgZGF0YTogVHVyYm9wYWNrVXBkYXRlIHwgVHVyYm9wYWNrVXBkYXRlW11cbik6IFNldDxzdHJpbmc+IHtcbiAgY29uc3QgdXBkYXRlZE1vZHVsZXM6IFNldDxzdHJpbmc+ID0gbmV3IFNldCgpXG5cbiAgY29uc3QgdXBkYXRlcyA9IEFycmF5LmlzQXJyYXkoZGF0YSkgPyBkYXRhIDogW2RhdGFdXG4gIGZvciAoY29uc3QgdXBkYXRlIG9mIHVwZGF0ZXMpIHtcbiAgICAvLyBUT0RPIHRoaXMgd29uJ3QgY2FwdHVyZSBjaGFuZ2VzIHRvIENTUyBzaW5jZSB0aGV5IGRvbid0IHJlc3VsdCBpbiBhIFwibWVyZ2VkXCIgdXBkYXRlXG4gICAgaWYgKFxuICAgICAgdXBkYXRlLnR5cGUgIT09ICdwYXJ0aWFsJyB8fFxuICAgICAgdXBkYXRlLmluc3RydWN0aW9uLnR5cGUgIT09ICdDaHVua0xpc3RVcGRhdGUnIHx8XG4gICAgICB1cGRhdGUuaW5zdHJ1Y3Rpb24ubWVyZ2VkID09PSB1bmRlZmluZWRcbiAgICApIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBtZXJnZWRVcGRhdGUgb2YgdXBkYXRlLmluc3RydWN0aW9uLm1lcmdlZCkge1xuICAgICAgZm9yIChjb25zdCBuYW1lIG9mIE9iamVjdC5rZXlzKG1lcmdlZFVwZGF0ZS5lbnRyaWVzKSkge1xuICAgICAgICBjb25zdCByZXMgPSAvKC4qKVxccytcXFsuKi8uZXhlYyhuYW1lKVxuICAgICAgICBpZiAocmVzID09PSBudWxsKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICdbVHVyYm9wYWNrIEhNUl0gRXhwZWN0ZWQgbW9kdWxlIHRvIG1hdGNoIHBhdHRlcm46ICcgKyBuYW1lXG4gICAgICAgICAgKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICB1cGRhdGVkTW9kdWxlcy5hZGQocmVzWzFdKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1cGRhdGVkTW9kdWxlc1xufVxuIl0sIm5hbWVzIjpbIlR1cmJvcGFja0htciIsIlRVUkJPUEFDS19ITVJfU1RBUlRfREVMQVlfTVMiLCJvbkJ1aWxkaW5nIiwidW5kZWZpbmVkIiwiRGF0ZSIsIm5vdyIsInNldFRpbWVvdXQiLCJzZWxmIiwiX19ORVhUX0hNUl9UVVJCT1BBQ0tfUkVQT1JUX05PSVNZX05PT1BfRVZFTlRTIiwib25UdXJib3BhY2tNZXNzYWdlIiwibXNnIiwidXBkYXRlZE1vZHVsZXMiLCJleHRyYWN0TW9kdWxlc0Zyb21UdXJib3BhY2tNZXNzYWdlIiwiZGF0YSIsIm1vZHVsZSIsImFkZCIsIm9uU2VydmVyQ29tcG9uZW50Q2hhbmdlcyIsIm9uUmVsb2FkUGFnZSIsIm9uUGFnZUFkZFJlbW92ZSIsIm9uQnVpbHQiLCJoYXNVcGRhdGVzIiwicmVzdWx0Iiwic3RhcnRNc1NpbmNlRXBvY2giLCJlbmRNc1NpbmNlRXBvY2giLCJTZXQiLCJjb25zdHJ1Y3RvciIsImNvbnNvbGUiLCJsb2ciLCJjbGVhclRpbWVvdXQiLCJ1cGRhdGVzIiwiQXJyYXkiLCJpc0FycmF5IiwidXBkYXRlIiwidHlwZSIsImluc3RydWN0aW9uIiwibWVyZ2VkIiwibWVyZ2VkVXBkYXRlIiwibmFtZSIsIk9iamVjdCIsImtleXMiLCJlbnRyaWVzIiwicmVzIiwiZXhlYyIsImVycm9yIl0sIm1hcHBpbmdzIjoiOzs7K0JBb0JhQSxnQkFBQUE7OztlQUFBQTs7Ozs7QUFYYiwrRUFBK0U7QUFDL0UsdURBQXVEO0FBQ3ZELE1BQU1DLCtCQUErQjtJQVVuQyxrQkFBQSxXQUFBLEdBQUEsK0JBQUEsQ0FBQSxDQUFBLG9CQUNBLHFCQUFBLFdBQUEsR0FBQSwrQkFBQSxDQUFB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SyxVQUFVQyxNQUFNQyxPQUFPLENBQUNsQixRQUFRQSxPQUFPO1FBQUNBO0tBQUs7SUFDbkQsS0FBSyxNQUFNbUIsVUFBVUgsUUFBUztRQUM1QixzRkFBc0Y7UUFDdEYsSUFDRUcsT0FBT0MsSUFBSSxLQUFLLGFBQ2hCRCxPQUFPRSxXQUFXLENBQUNELElBQUksS0FBSyxxQkFDNUJELE9BQU9FLFdBQVcsQ0FBQ0MsTUFBTSxLQUFLaEMsV0FDOUI7WUFDQTtRQUNGO1FBRUEsS0FBSyxNQUFNaUMsZ0JBQWdCSixPQUFPRSxXQUFXLENBQUNDLE1BQU0sQ0FBRTtZQUNwRCxLQUFLLE1BQU1FLFFBQVFDLE9BQU9DLElBQUksQ0FBQ0gsYUFBYUksT0FBTyxFQUFHO2dCQUNwRCxNQUFNQyxNQUFNLGNBQWNDLElBQUksQ0FBQ0w7Z0JBQy9CLElBQUlJLFFBQVEsTUFBTTtvQkFDaEJmLFFBQVFpQixLQUFLLENBQ1gsdURBQXVETjtvQkFFekQ7Z0JBQ0Y7Z0JBRUExQixlQUFlSSxHQUFHLENBQUMwQixHQUFHLENBQUMsRUFBRTtZQUMzQjtRQUNGO0lBQ0Y7SUFFQSxPQUFPOUI7QUFDVCIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA4ODE2LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL25leHQtZGV2dG9vbHMvdXNlcnNwYWNlL2FwcC9lcnJvcnMvdXNlLWZvcndhcmQtY29uc29sZS1sb2cudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBpc1Rlcm1pbmFsTG9nZ2luZ0VuYWJsZWQsIGxvZ1F1ZXVlIH0gZnJvbSAnLi4vZm9yd2FyZC1sb2dzJ1xuaW1wb3J0IHR5cGUgeyB1c2VXZWJzb2NrZXQgfSBmcm9tICcuLi8uLi8uLi8uLi9jbGllbnQvZGV2L2hvdC1yZWxvYWRlci9hcHAvdXNlLXdlYnNvY2tldCdcblxuZXhwb3J0IGNvbnN0IHVzZUZvcndhcmRDb25zb2xlTG9nID0gKFxuICBzb2NrZXRSZWY6IFJldHVyblR5cGU8dHlwZW9mIHVzZVdlYnNvY2tldD5cbikgPT4ge1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghaXNUZXJtaW5hbExvZ2dpbmdFbmFibGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY29uc3Qgc29ja2V0ID0gc29ja2V0UmVmLmN1cnJlbnRcbiAgICBpZiAoIXNvY2tldCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3Qgb25PcGVuID0gKCkgPT4ge1xuICAgICAgbG9nUXVldWUub25Tb2NrZXRSZWFkeShzb2NrZXQpXG4gICAgfVxuICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdvcGVuJywgb25PcGVuKVxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKCdvcGVuJywgb25PcGVuKVxuICAgIH1cbiAgfSwgW3NvY2tldFJlZl0pXG59XG4iXSwibmFtZXMiOlsidXNlRm9yd2FyZENvbnNvbGVMb2ciLCJzb2NrZXRSZWYiLCJ1c2VFZmZlY3QiLCJpc1Rlcm1pbmFsTG9nZ2luZ0VuYWJsZWQiLCJzb2NrZXQiLCJjdXJyZW50Iiwib25PcGVuIiwibG9nUXVldWUiLCJvblNvY2tldFJlYWR5IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiXSwibWFwcGluZ3MiOiI7OzsrQkFJYUEsd0JBQUFBOzs7ZUFBQUE7Ozt1QkFKYTs2QkFDeUI7QUFHNUMsTUFBTUEsdUJBQXVCLENBQ2xDQztJQUVBQyxDQUFBQSxHQUFBQSxPQUFBQSxTQUFTLEVBQUM7UUFDUixJQUFJLENBQUNDLGFBQUFBLHdCQUF3QixFQUFFO1lBQzdCO1FBQ0Y7UUFDQSxNQUFNQyxTQUFTSCxVQUFVSSxPQUFPO1FBQ2hDLElBQUksQ0FBQ0QsUUFBUTtZQUNYO1FBQ0Y7UUFFQSxNQUFNRSxTQUFTO1lBQ2JDLGFBQUFBLFFBQVEsQ0FBQ0MsYUFBYSxDQUFDSjtRQUN6QjtRQUNBQSxPQUFPSyxnQkFBZ0IsQ0FBQyxRQUFRSDtRQUVoQyxPQUFPO1lBQ0xGLE9BQU9NLG1CQUFtQixDQUFDLFFBQVFKO1FBQ3JDO0lBQ0YsR0FBRztRQUFDTDtLQUFVO0FBQ2hCIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDg4NjAsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvY2xpZW50L2Rldi9ob3QtcmVsb2FkZXIvYXBwL2hvdC1yZWxvYWRlci1hcHAudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vLyA8cmVmZXJlbmNlIHR5cGVzPVwid2VicGFjay9tb2R1bGUuZC50c1wiIC8+XG5cbmltcG9ydCB0eXBlIHsgUmVhY3ROb2RlIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHN0YXJ0VHJhbnNpdGlvbiwgdXNlUmVmIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgc3RyaXBBbnNpIGZyb20gJ25leHQvZGlzdC9jb21waWxlZC9zdHJpcC1hbnNpJ1xuaW1wb3J0IGZvcm1hdFdlYnBhY2tNZXNzYWdlcyBmcm9tICcuLi8uLi8uLi8uLi9zaGFyZWQvbGliL2Zvcm1hdC13ZWJwYWNrLW1lc3NhZ2VzJ1xuaW1wb3J0IHsgdXNlUm91dGVyIH0gZnJvbSAnLi4vLi4vLi4vY29tcG9uZW50cy9uYXZpZ2F0aW9uJ1xuaW1wb3J0IHtcbiAgUkVBQ1RfUkVGUkVTSF9GVUxMX1JFTE9BRCxcbiAgUkVBQ1RfUkVGUkVTSF9GVUxMX1JFTE9BRF9GUk9NX0VSUk9SLFxuICByZXBvcnRJbnZhbGlkSG1yTWVzc2FnZSxcbn0gZnJvbSAnLi4vc2hhcmVkJ1xuaW1wb3J0IHsgZGlzcGF0Y2hlciB9IGZyb20gJ25leHQvZGlzdC9jb21waWxlZC9uZXh0LWRldnRvb2xzJ1xuaW1wb3J0IHsgUmVwbGF5U3NyT25seUVycm9ycyB9IGZyb20gJy4uLy4uLy4uLy4uL25leHQtZGV2dG9vbHMvdXNlcnNwYWNlL2FwcC9lcnJvcnMvcmVwbGF5LXNzci1vbmx5LWVycm9ycydcbmltcG9ydCB7IEFwcERldk92ZXJsYXlFcnJvckJvdW5kYXJ5IH0gZnJvbSAnLi4vLi4vLi4vLi4vbmV4dC1kZXZ0b29scy91c2Vyc3BhY2UvYXBwL2FwcC1kZXYtb3ZlcmxheS1lcnJvci1ib3VuZGFyeSdcbmltcG9ydCB7IHVzZUVycm9ySGFuZGxlciB9IGZyb20gJy4uLy4uLy4uLy4uL25leHQtZGV2dG9vbHMvdXNlcnNwYWNlL2FwcC9lcnJvcnMvdXNlLWVycm9yLWhhbmRsZXInXG5pbXBvcnQgeyBSdW50aW1lRXJyb3JIYW5kbGVyIH0gZnJvbSAnLi4vLi4vcnVudGltZS1lcnJvci1oYW5kbGVyJ1xuaW1wb3J0IHtcbiAgdXNlU2VuZE1lc3NhZ2UsXG4gIHVzZVR1cmJvcGFjayxcbiAgdXNlV2Vic29ja2V0LFxuICB1c2VXZWJzb2NrZXRQaW5nLFxufSBmcm9tICcuL3VzZS13ZWJzb2NrZXQnXG5pbXBvcnQgeyBITVJfQUNUSU9OU19TRU5UX1RPX0JST1dTRVIgfSBmcm9tICcuLi8uLi8uLi8uLi9zZXJ2ZXIvZGV2L2hvdC1yZWxvYWRlci10eXBlcydcbmltcG9ydCB0eXBlIHtcbiAgSE1SX0FDVElPTl9UWVBFUyxcbiAgVHVyYm9wYWNrTXNnVG9Ccm93c2VyLFxufSBmcm9tICcuLi8uLi8uLi8uLi9zZXJ2ZXIvZGV2L2hvdC1yZWxvYWRlci10eXBlcydcbmltcG9ydCB7IHVzZVVudHJhY2tlZFBhdGhuYW1lIH0gZnJvbSAnLi4vLi4vLi4vY29tcG9uZW50cy9uYXZpZ2F0aW9uLXVudHJhY2tlZCdcbmltcG9ydCByZXBvcnRIbXJMYXRlbmN5IGZyb20gJy4uLy4uL3JlcG9ydC1obXItbGF0ZW5jeSdcbmltcG9ydCB7IFR1cmJvcGFja0htciB9IGZyb20gJy4uL3R1cmJvcGFjay1ob3QtcmVsb2FkZXItY29tbW9uJ1xuaW1wb3J0IHsgTkVYVF9ITVJfUkVGUkVTSF9IQVNIX0NPT0tJRSB9IGZyb20gJy4uLy4uLy4uL2NvbXBvbmVudHMvYXBwLXJvdXRlci1oZWFkZXJzJ1xuaW1wb3J0IHR5cGUgeyBHbG9iYWxFcnJvclN0YXRlIH0gZnJvbSAnLi4vLi4vLi4vY29tcG9uZW50cy9hcHAtcm91dGVyLWluc3RhbmNlJ1xuaW1wb3J0IHsgdXNlRm9yd2FyZENvbnNvbGVMb2cgfSBmcm9tICcuLi8uLi8uLi8uLi9uZXh0LWRldnRvb2xzL3VzZXJzcGFjZS9hcHAvZXJyb3JzL3VzZS1mb3J3YXJkLWNvbnNvbGUtbG9nJ1xuXG5sZXQgbW9zdFJlY2VudENvbXBpbGF0aW9uSGFzaDogYW55ID0gbnVsbFxubGV0IF9fbmV4dERldkNsaWVudElkID0gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogMTAwICsgRGF0ZS5ub3coKSlcbmxldCByZWxvYWRpbmcgPSBmYWxzZVxubGV0IHdlYnBhY2tTdGFydE1zU2luY2VFcG9jaDogbnVtYmVyIHwgbnVsbCA9IG51bGxcbmNvbnN0IHR1cmJvcGFja0htcjogVHVyYm9wYWNrSG1yIHwgbnVsbCA9IHByb2Nlc3MuZW52LlRVUkJPUEFDS1xuICA/IG5ldyBUdXJib3BhY2tIbXIoKVxuICA6IG51bGxcblxubGV0IHBlbmRpbmdIb3RVcGRhdGVXZWJwYWNrID0gUHJvbWlzZS5yZXNvbHZlKClcbmxldCByZXNvbHZlUGVuZGluZ0hvdFVwZGF0ZVdlYnBhY2s6ICgpID0+IHZvaWQgPSAoKSA9PiB7fVxuZnVuY3Rpb24gc2V0UGVuZGluZ0hvdFVwZGF0ZVdlYnBhY2soKSB7XG4gIHBlbmRpbmdIb3RVcGRhdGVXZWJwYWNrID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICByZXNvbHZlUGVuZGluZ0hvdFVwZGF0ZVdlYnBhY2sgPSAoKSA9PiB7XG4gICAgICByZXNvbHZlKClcbiAgICB9XG4gIH0pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3YWl0Rm9yV2VicGFja1J1bnRpbWVIb3RVcGRhdGUoKSB7XG4gIHJldHVybiBwZW5kaW5nSG90VXBkYXRlV2VicGFja1xufVxuXG4vLyBUaGVyZSBpcyBhIG5ld2VyIHZlcnNpb24gb2YgdGhlIGNvZGUgYXZhaWxhYmxlLlxuZnVuY3Rpb24gaGFuZGxlQXZhaWxhYmxlSGFzaChoYXNoOiBzdHJpbmcpIHtcbiAgLy8gVXBkYXRlIGxhc3Qga25vd24gY29tcGlsYXRpb24gaGFzaC5cbiAgbW9zdFJlY2VudENvbXBpbGF0aW9uSGFzaCA9IGhhc2hcbn1cblxuLyoqXG4gKiBJcyB0aGVyZSBhIG5ld2VyIHZlcnNpb24gb2YgdGhpcyBjb2RlIGF2YWlsYWJsZT9cbiAqIEZvciB3ZWJwYWNrOiBDaGVjayBpZiB0aGUgaGFzaCBjaGFuZ2VkIGNvbXBhcmVkIHRvIF9fd2VicGFja19oYXNoX19cbiAqIEZvciBUdXJib3BhY2s6IEFsd2F5cyB0cnVlIGJlY2F1c2UgaXQgZG9lc24ndCBoYXZlIF9fd2VicGFja19oYXNoX19cbiAqL1xuZnVuY3Rpb24gaXNVcGRhdGVBdmFpbGFibGUoKSB7XG4gIGlmIChwcm9jZXNzLmVudi5UVVJCT1BBQ0spIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyogZ2xvYmFscyBfX3dlYnBhY2tfaGFzaF9fICovXG4gIC8vIF9fd2VicGFja19oYXNoX18gaXMgdGhlIGhhc2ggb2YgdGhlIGN1cnJlbnQgY29tcGlsYXRpb24uXG4gIC8vIEl0J3MgYSBnbG9iYWwgdmFyaWFibGUgaW5qZWN0ZWQgYnkgV2VicGFjay5cbiAgcmV0dXJuIG1vc3RSZWNlbnRDb21waWxhdGlvbkhhc2ggIT09IF9fd2VicGFja19oYXNoX19cbn1cblxuLy8gV2VicGFjayBkaXNhbGxvd3MgdXBkYXRlcyBpbiBvdGhlciBzdGF0ZXMuXG5mdW5jdGlvbiBjYW5BcHBseVVwZGF0ZXMoKSB7XG4gIHJldHVybiBtb2R1bGUuaG90LnN0YXR1cygpID09PSAnaWRsZSdcbn1cbmZ1bmN0aW9uIGFmdGVyQXBwbHlVcGRhdGVzKGZuOiBhbnkpIHtcbiAgaWYgKGNhbkFwcGx5VXBkYXRlcygpKSB7XG4gICAgZm4oKVxuICB9IGVsc2Uge1xuICAgIGZ1bmN0aW9uIGhhbmRsZXIoc3RhdHVzOiBhbnkpIHtcbiAgICAgIGlmIChzdGF0dXMgPT09ICdpZGxlJykge1xuICAgICAgICBtb2R1bGUuaG90LnJlbW92ZVN0YXR1c0hhbmRsZXIoaGFuZGxlcilcbiAgICAgICAgZm4oKVxuICAgICAgfVxuICAgIH1cbiAgICBtb2R1bGUuaG90LmFkZFN0YXR1c0hhbmRsZXIoaGFuZGxlcilcbiAgfVxufVxuXG5mdW5jdGlvbiBwZXJmb3JtRnVsbFJlbG9hZChlcnI6IGFueSwgc2VuZE1lc3NhZ2U6IGFueSkge1xuICBjb25zdCBzdGFja1RyYWNlID1cbiAgICBlcnIgJiZcbiAgICAoKGVyci5zdGFjayAmJiBlcnIuc3RhY2suc3BsaXQoJ1xcbicpLnNsaWNlKDAsIDUpLmpvaW4oJ1xcbicpKSB8fFxuICAgICAgZXJyLm1lc3NhZ2UgfHxcbiAgICAgIGVyciArICcnKVxuXG4gIHNlbmRNZXNzYWdlKFxuICAgIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIGV2ZW50OiAnY2xpZW50LWZ1bGwtcmVsb2FkJyxcbiAgICAgIHN0YWNrVHJhY2UsXG4gICAgICBoYWRSdW50aW1lRXJyb3I6ICEhUnVudGltZUVycm9ySGFuZGxlci5oYWRSdW50aW1lRXJyb3IsXG4gICAgICBkZXBlbmRlbmN5Q2hhaW46IGVyciA/IGVyci5kZXBlbmRlbmN5Q2hhaW4gOiB1bmRlZmluZWQsXG4gICAgfSlcbiAgKVxuXG4gIGlmIChyZWxvYWRpbmcpIHJldHVyblxuICByZWxvYWRpbmcgPSB0cnVlXG4gIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKVxufVxuXG4vLyBBdHRlbXB0IHRvIHVwZGF0ZSBjb2RlIG9uIHRoZSBmbHksIGZhbGwgYmFjayB0byBhIGhhcmQgcmVsb2FkLlxuZnVuY3Rpb24gdHJ5QXBwbHlVcGRhdGVzV2VicGFjayhzZW5kTWVzc2FnZTogKG1lc3NhZ2U6IHN0cmluZykgPT4gdm9pZCkge1xuICBpZiAoIWlzVXBkYXRlQXZhaWxhYmxlKCkgfHwgIWNhbkFwcGx5VXBkYXRlcygpKSB7XG4gICAgcmVzb2x2ZVBlbmRpbmdIb3RVcGRhdGVXZWJwYWNrKClcbiAgICBkaXNwYXRjaGVyLm9uQnVpbGRPaygpXG4gICAgcmVwb3J0SG1yTGF0ZW5jeShzZW5kTWVzc2FnZSwgW10sIHdlYnBhY2tTdGFydE1zU2luY2VFcG9jaCEsIERhdGUubm93KCkpXG4gICAgcmV0dXJuXG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVBcHBseVVwZGF0ZXMoXG4gICAgZXJyOiBhbnksXG4gICAgdXBkYXRlZE1vZHVsZXM6IChzdHJpbmcgfCBudW1iZXIpW10gfCBudWxsXG4gICkge1xuICAgIGlmIChlcnIgfHwgUnVudGltZUVycm9ySGFuZGxlci5oYWRSdW50aW1lRXJyb3IgfHwgdXBkYXRlZE1vZHVsZXMgPT0gbnVsbCkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBjb25zb2xlLndhcm4oUkVBQ1RfUkVGUkVTSF9GVUxMX1JFTE9BRClcbiAgICAgIH0gZWxzZSBpZiAoUnVudGltZUVycm9ySGFuZGxlci5oYWRSdW50aW1lRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFJFQUNUX1JFRlJFU0hfRlVMTF9SRUxPQURfRlJPTV9FUlJPUilcbiAgICAgIH1cbiAgICAgIHBlcmZvcm1GdWxsUmVsb2FkKGVyciwgc2VuZE1lc3NhZ2UpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBkaXNwYXRjaGVyLm9uQnVpbGRPaygpXG5cbiAgICBpZiAoaXNVcGRhdGVBdmFpbGFibGUoKSkge1xuICAgICAgLy8gV2hpbGUgd2Ugd2VyZSB1cGRhdGluZywgdGhlcmUgd2FzIGEgbmV3IHVwZGF0ZSEgRG8gaXQgYWdhaW4uXG4gICAgICB0cnlBcHBseVVwZGF0ZXNXZWJwYWNrKHNlbmRNZXNzYWdlKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgZGlzcGF0Y2hlci5vblJlZnJlc2goKVxuICAgIHJlc29sdmVQZW5kaW5nSG90VXBkYXRlV2VicGFjaygpXG4gICAgcmVwb3J0SG1yTGF0ZW5jeShcbiAgICAgIHNlbmRNZXNzYWdlLFxuICAgICAgdXBkYXRlZE1vZHVsZXMsXG4gICAgICB3ZWJwYWNrU3RhcnRNc1NpbmNlRXBvY2ghLFxuICAgICAgRGF0ZS5ub3coKVxuICAgIClcblxuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfVEVTVF9NT0RFKSB7XG4gICAgICBhZnRlckFwcGx5VXBkYXRlcygoKSA9PiB7XG4gICAgICAgIGlmIChzZWxmLl9fTkVYVF9ITVJfQ0IpIHtcbiAgICAgICAgICBzZWxmLl9fTkVYVF9ITVJfQ0IoKVxuICAgICAgICAgIHNlbGYuX19ORVhUX0hNUl9DQiA9IG51bGxcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICAvLyBodHRwczovL3dlYnBhY2suanMub3JnL2FwaS9ob3QtbW9kdWxlLXJlcGxhY2VtZW50LyNjaGVja1xuICBtb2R1bGUuaG90XG4gICAgLmNoZWNrKC8qIGF1dG9BcHBseSAqLyBmYWxzZSlcbiAgICAudGhlbigodXBkYXRlZE1vZHVsZXM6IChzdHJpbmcgfCBudW1iZXIpW10gfCBudWxsKSA9PiB7XG4gICAgICBpZiAodXBkYXRlZE1vZHVsZXMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuXG4gICAgICAvLyBXZSBzaG91bGQgYWx3YXlzIGhhbmRsZSBhbiB1cGRhdGUsIGV2ZW4gaWYgdXBkYXRlZE1vZHVsZXMgaXMgZW1wdHkgKGJ1dFxuICAgICAgLy8gbm9uLW51bGwpIGZvciBhbnkgcmVhc29uLiBUaGF0J3Mgd2hhdCB3ZWJwYWNrIHdvdWxkIG5vcm1hbGx5IGRvOlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2svd2VicGFjay9ibG9iLzNhYTZiNmJjM2E2NC9saWIvaG1yL0hvdE1vZHVsZVJlcGxhY2VtZW50LnJ1bnRpbWUuanMjTDI5Ni1MMjk4XG4gICAgICBkaXNwYXRjaGVyLm9uQmVmb3JlUmVmcmVzaCgpXG4gICAgICAvLyBodHRwczovL3dlYnBhY2suanMub3JnL2FwaS9ob3QtbW9kdWxlLXJlcGxhY2VtZW50LyNhcHBseVxuICAgICAgcmV0dXJuIG1vZHVsZS5ob3QuYXBwbHkoKVxuICAgIH0pXG4gICAgLnRoZW4oXG4gICAgICAodXBkYXRlZE1vZHVsZXM6IChzdHJpbmcgfCBudW1iZXIpW10gfCBudWxsKSA9PiB7XG4gICAgICAgIGhhbmRsZUFwcGx5VXBkYXRlcyhudWxsLCB1cGRhdGVkTW9kdWxlcylcbiAgICAgIH0sXG4gICAgICAoZXJyOiBhbnkpID0+IHtcbiAgICAgICAgaGFuZGxlQXBwbHlVcGRhdGVzKGVyciwgbnVsbClcbiAgICAgIH1cbiAgICApXG59XG5cbi8qKiBIYW5kbGVzIG1lc3NhZ2VzIGZyb20gdGhlIHNlcnZlciBmb3IgdGhlIEFwcCBSb3V0ZXIuICovXG5mdW5jdGlvbiBwcm9jZXNzTWVzc2FnZShcbiAgb2JqOiBITVJfQUNUSU9OX1RZUEVTLFxuICBzZW5kTWVzc2FnZTogKG1lc3NhZ2U6IHN0cmluZykgPT4gdm9pZCxcbiAgcHJvY2Vzc1R1cmJvcGFja01lc3NhZ2U6IChtc2c6IFR1cmJvcGFja01zZ1RvQnJvd3NlcikgPT4gdm9pZCxcbiAgcm91dGVyOiBSZXR1cm5UeXBlPHR5cGVvZiB1c2VSb3V0ZXI+LFxuICBhcHBJc3JNYW5pZmVzdFJlZjogUmV0dXJuVHlwZTx0eXBlb2YgdXNlUmVmPixcbiAgcGF0aG5hbWVSZWY6IFJldHVyblR5cGU8dHlwZW9mIHVzZVJlZj5cbikge1xuICBpZiAoISgnYWN0aW9uJyBpbiBvYmopKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVFcnJvcnMoZXJyb3JzOiBSZWFkb25seUFycmF5PHVua25vd24+KSB7XG4gICAgLy8gXCJNYXNzYWdlXCIgd2VicGFjayBtZXNzYWdlcy5cbiAgICBjb25zdCBmb3JtYXR0ZWQgPSBmb3JtYXRXZWJwYWNrTWVzc2FnZXMoe1xuICAgICAgZXJyb3JzOiBlcnJvcnMsXG4gICAgICB3YXJuaW5nczogW10sXG4gICAgfSlcblxuICAgIC8vIE9ubHkgc2hvdyB0aGUgZmlyc3QgZXJyb3IuXG4gICAgZGlzcGF0Y2hlci5vbkJ1aWxkRXJyb3IoZm9ybWF0dGVkLmVycm9yc1swXSlcblxuICAgIC8vIEFsc28gbG9nIHRoZW0gdG8gdGhlIGNvbnNvbGUuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmb3JtYXR0ZWQuZXJyb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zb2xlLmVycm9yKHN0cmlwQW5zaShmb3JtYXR0ZWQuZXJyb3JzW2ldKSlcbiAgICB9XG5cbiAgICAvLyBEbyBub3QgYXR0ZW1wdCB0byByZWxvYWQgbm93LlxuICAgIC8vIFdlIHdpbGwgcmVsb2FkIG9uIG5leHQgc3VjY2VzcyBpbnN0ZWFkLlxuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfVEVTVF9NT0RFKSB7XG4gICAgICBpZiAoc2VsZi5fX05FWFRfSE1SX0NCKSB7XG4gICAgICAgIHNlbGYuX19ORVhUX0hNUl9DQihmb3JtYXR0ZWQuZXJyb3JzWzBdKVxuICAgICAgICBzZWxmLl9fTkVYVF9ITVJfQ0IgPSBudWxsXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlSG90VXBkYXRlKCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5UVVJCT1BBQ0spIHtcbiAgICAgIGNvbnN0IGhtclVwZGF0ZSA9IHR1cmJvcGFja0htciEub25CdWlsdCgpXG4gICAgICBpZiAoaG1yVXBkYXRlICE9IG51bGwpIHtcbiAgICAgICAgcmVwb3J0SG1yTGF0ZW5jeShcbiAgICAgICAgICBzZW5kTWVzc2FnZSxcbiAgICAgICAgICBbLi4uaG1yVXBkYXRlLnVwZGF0ZWRNb2R1bGVzXSxcbiAgICAgICAgICBobXJVcGRhdGUuc3RhcnRNc1NpbmNlRXBvY2gsXG4gICAgICAgICAgaG1yVXBkYXRlLmVuZE1zU2luY2VFcG9jaCxcbiAgICAgICAgICAvLyBzdXBwcmVzcyB0aGUgYGNsaWVudC1obXItbGF0ZW5jeWAgZXZlbnQgaWYgdGhlIHVwZGF0ZSB3YXMgYSBuby1vcDpcbiAgICAgICAgICBobXJVcGRhdGUuaGFzVXBkYXRlc1xuICAgICAgICApXG4gICAgICB9XG4gICAgICBkaXNwYXRjaGVyLm9uQnVpbGRPaygpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeUFwcGx5VXBkYXRlc1dlYnBhY2soc2VuZE1lc3NhZ2UpXG4gICAgfVxuICB9XG5cbiAgc3dpdGNoIChvYmouYWN0aW9uKSB7XG4gICAgY2FzZSBITVJfQUNUSU9OU19TRU5UX1RPX0JST1dTRVIuSVNSX01BTklGRVNUOiB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0RFVl9JTkRJQ0FUT1IpIHtcbiAgICAgICAgaWYgKGFwcElzck1hbmlmZXN0UmVmKSB7XG4gICAgICAgICAgYXBwSXNyTWFuaWZlc3RSZWYuY3VycmVudCA9IG9iai5kYXRhXG5cbiAgICAgICAgICAvLyBoYW5kbGUgaW5pdGlhbCBzdGF0dXMgb24gcmVjZWl2aW5nIG1hbmlmZXN0XG4gICAgICAgICAgLy8gbmF2aWdhdGlvbiBpcyBoYW5kbGVkIGluIHVzZUVmZmVjdCBmb3IgcGF0aG5hbWUgY2hhbmdlc1xuICAgICAgICAgIC8vIGFzIHdlJ2xsIHJlY2VpdmUgdGhlIHVwZGF0ZWQgbWFuaWZlc3QgYmVmb3JlIHVzZVBhdGhuYW1lXG4gICAgICAgICAgLy8gdHJpZ2dlcnMgZm9yIG5ldyB2YWx1ZVxuICAgICAgICAgIGlmICgocGF0aG5hbWVSZWYuY3VycmVudCBhcyBzdHJpbmcpIGluIG9iai5kYXRhKSB7XG4gICAgICAgICAgICBkaXNwYXRjaGVyLm9uU3RhdGljSW5kaWNhdG9yKHRydWUpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpc3BhdGNoZXIub25TdGF0aWNJbmRpY2F0b3IoZmFsc2UpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVha1xuICAgIH1cbiAgICBjYXNlIEhNUl9BQ1RJT05TX1NFTlRfVE9fQlJPV1NFUi5CVUlMRElORzoge1xuICAgICAgZGlzcGF0Y2hlci5idWlsZGluZ0luZGljYXRvclNob3coKVxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuVFVSQk9QQUNLKSB7XG4gICAgICAgIHR1cmJvcGFja0htciEub25CdWlsZGluZygpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3ZWJwYWNrU3RhcnRNc1NpbmNlRXBvY2ggPSBEYXRlLm5vdygpXG4gICAgICAgIHNldFBlbmRpbmdIb3RVcGRhdGVXZWJwYWNrKClcbiAgICAgICAgY29uc29sZS5sb2coJ1tGYXN0IFJlZnJlc2hdIHJlYnVpbGRpbmcnKVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gICAgY2FzZSBITVJfQUNUSU9OU19TRU5UX1RPX0JST1dTRVIuQlVJTFQ6XG4gICAgY2FzZSBITVJfQUNUSU9OU19TRU5UX1RPX0JST1dTRVIuU1lOQzoge1xuICAgICAgZGlzcGF0Y2hlci5idWlsZGluZ0luZGljYXRvckhpZGUoKVxuXG4gICAgICBpZiAob2JqLmhhc2gpIHtcbiAgICAgICAgaGFuZGxlQXZhaWxhYmxlSGFzaChvYmouaGFzaClcbiAgICAgIH1cblxuICAgICAgY29uc3QgeyBlcnJvcnMsIHdhcm5pbmdzIH0gPSBvYmpcblxuICAgICAgLy8gSXMgdW5kZWZpbmVkIHdoZW4gaXQncyBhICdidWlsdCcgZXZlbnRcbiAgICAgIGlmICgndmVyc2lvbkluZm8nIGluIG9iaikgZGlzcGF0Y2hlci5vblZlcnNpb25JbmZvKG9iai52ZXJzaW9uSW5mbylcbiAgICAgIGlmICgnZGVidWcnIGluIG9iaiAmJiBvYmouZGVidWcpIGRpc3BhdGNoZXIub25EZWJ1Z0luZm8ob2JqLmRlYnVnKVxuICAgICAgaWYgKCdkZXZJbmRpY2F0b3InIGluIG9iaikgZGlzcGF0Y2hlci5vbkRldkluZGljYXRvcihvYmouZGV2SW5kaWNhdG9yKVxuXG4gICAgICBjb25zdCBoYXNFcnJvcnMgPSBCb29sZWFuKGVycm9ycyAmJiBlcnJvcnMubGVuZ3RoKVxuICAgICAgLy8gQ29tcGlsYXRpb24gd2l0aCBlcnJvcnMgKGUuZy4gc3ludGF4IGVycm9yIG9yIG1pc3NpbmcgbW9kdWxlcykuXG4gICAgICBpZiAoaGFzRXJyb3JzKSB7XG4gICAgICAgIHNlbmRNZXNzYWdlKFxuICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIGV2ZW50OiAnY2xpZW50LWVycm9yJyxcbiAgICAgICAgICAgIGVycm9yQ291bnQ6IGVycm9ycy5sZW5ndGgsXG4gICAgICAgICAgICBjbGllbnRJZDogX19uZXh0RGV2Q2xpZW50SWQsXG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuXG4gICAgICAgIGhhbmRsZUVycm9ycyhlcnJvcnMpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBjb25zdCBoYXNXYXJuaW5ncyA9IEJvb2xlYW4od2FybmluZ3MgJiYgd2FybmluZ3MubGVuZ3RoKVxuICAgICAgaWYgKGhhc1dhcm5pbmdzKSB7XG4gICAgICAgIHNlbmRNZXNzYWdlKFxuICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIGV2ZW50OiAnY2xpZW50LXdhcm5pbmcnLFxuICAgICAgICAgICAgd2FybmluZ0NvdW50OiB3YXJuaW5ncy5sZW5ndGgsXG4gICAgICAgICAgICBjbGllbnRJZDogX19uZXh0RGV2Q2xpZW50SWQsXG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuXG4gICAgICAgIC8vIFByaW50IHdhcm5pbmdzIHRvIHRoZSBjb25zb2xlLlxuICAgICAgICBjb25zdCBmb3JtYXR0ZWRNZXNzYWdlcyA9IGZvcm1hdFdlYnBhY2tNZXNzYWdlcyh7XG4gICAgICAgICAgd2FybmluZ3M6IHdhcm5pbmdzLFxuICAgICAgICAgIGVycm9yczogW10sXG4gICAgICAgIH0pXG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmb3JtYXR0ZWRNZXNzYWdlcy53YXJuaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChpID09PSA1KSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICdUaGVyZSB3ZXJlIG1vcmUgd2FybmluZ3MgaW4gb3RoZXIgZmlsZXMuXFxuJyArXG4gICAgICAgICAgICAgICAgJ1lvdSBjYW4gZmluZCBhIGNvbXBsZXRlIGxvZyBpbiB0aGUgdGVybWluYWwuJ1xuICAgICAgICAgICAgKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc29sZS53YXJuKHN0cmlwQW5zaShmb3JtYXR0ZWRNZXNzYWdlcy53YXJuaW5nc1tpXSkpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBObyBlYXJseSByZXR1cm4gaGVyZSBhcyB3ZSBuZWVkIHRvIGFwcGx5IG1vZHVsZXMgaW4gdGhlIHNhbWUgd2F5IGJldHdlZW4gd2FybmluZ3Mgb25seSBhbmQgY29tcGlsZXMgd2l0aG91dCB3YXJuaW5nc1xuICAgICAgfVxuXG4gICAgICBzZW5kTWVzc2FnZShcbiAgICAgICAgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGV2ZW50OiAnY2xpZW50LXN1Y2Nlc3MnLFxuICAgICAgICAgIGNsaWVudElkOiBfX25leHREZXZDbGllbnRJZCxcbiAgICAgICAgfSlcbiAgICAgIClcblxuICAgICAgaWYgKG9iai5hY3Rpb24gPT09IEhNUl9BQ1RJT05TX1NFTlRfVE9fQlJPV1NFUi5CVUlMVCkge1xuICAgICAgICBoYW5kbGVIb3RVcGRhdGUoKVxuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNhc2UgSE1SX0FDVElPTlNfU0VOVF9UT19CUk9XU0VSLlRVUkJPUEFDS19DT05ORUNURUQ6IHtcbiAgICAgIHByb2Nlc3NUdXJib3BhY2tNZXNzYWdlKHtcbiAgICAgICAgdHlwZTogSE1SX0FDVElPTlNfU0VOVF9UT19CUk9XU0VSLlRVUkJPUEFDS19DT05ORUNURUQsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBzZXNzaW9uSWQ6IG9iai5kYXRhLnNlc3Npb25JZCxcbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgICBicmVha1xuICAgIH1cbiAgICBjYXNlIEhNUl9BQ1RJT05TX1NFTlRfVE9fQlJPV1NFUi5UVVJCT1BBQ0tfTUVTU0FHRToge1xuICAgICAgdHVyYm9wYWNrSG1yIS5vblR1cmJvcGFja01lc3NhZ2Uob2JqKVxuICAgICAgZGlzcGF0Y2hlci5vbkJlZm9yZVJlZnJlc2goKVxuICAgICAgcHJvY2Vzc1R1cmJvcGFja01lc3NhZ2Uoe1xuICAgICAgICB0eXBlOiBITVJfQUNUSU9OU19TRU5UX1RPX0JST1dTRVIuVFVSQk9QQUNLX01FU1NBR0UsXG4gICAgICAgIGRhdGE6IG9iai5kYXRhLFxuICAgICAgfSlcbiAgICAgIGlmIChSdW50aW1lRXJyb3JIYW5kbGVyLmhhZFJ1bnRpbWVFcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oUkVBQ1RfUkVGUkVTSF9GVUxMX1JFTE9BRF9GUk9NX0VSUk9SKVxuICAgICAgICBwZXJmb3JtRnVsbFJlbG9hZChudWxsLCBzZW5kTWVzc2FnZSlcbiAgICAgIH1cbiAgICAgIGRpc3BhdGNoZXIub25SZWZyZXNoKClcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIC8vIFRPRE8tQVBQOiBtYWtlIHNlcnZlciBjb21wb25lbnQgY2hhbmdlIG1vcmUgZ3JhbnVsYXJcbiAgICBjYXNlIEhNUl9BQ1RJT05TX1NFTlRfVE9fQlJPV1NFUi5TRVJWRVJfQ09NUE9ORU5UX0NIQU5HRVM6IHtcbiAgICAgIHR1cmJvcGFja0htcj8ub25TZXJ2ZXJDb21wb25lbnRDaGFuZ2VzKClcbiAgICAgIHNlbmRNZXNzYWdlKFxuICAgICAgICBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgZXZlbnQ6ICdzZXJ2ZXItY29tcG9uZW50LXJlbG9hZC1wYWdlJyxcbiAgICAgICAgICBjbGllbnRJZDogX19uZXh0RGV2Q2xpZW50SWQsXG4gICAgICAgICAgaGFzaDogb2JqLmhhc2gsXG4gICAgICAgIH0pXG4gICAgICApXG5cbiAgICAgIC8vIFN0b3JlIHRoZSBsYXRlc3QgaGFzaCBpbiBhIHNlc3Npb24gY29va2llIHNvIHRoYXQgaXQncyBzZW50IGJhY2sgdG8gdGhlXG4gICAgICAvLyBzZXJ2ZXIgd2l0aCBhbnkgc3Vic2VxdWVudCByZXF1ZXN0cy5cbiAgICAgIGRvY3VtZW50LmNvb2tpZSA9IGAke05FWFRfSE1SX1JFRlJFU0hfSEFTSF9DT09LSUV9PSR7b2JqLmhhc2h9YFxuXG4gICAgICBpZiAoUnVudGltZUVycm9ySGFuZGxlci5oYWRSdW50aW1lRXJyb3IpIHtcbiAgICAgICAgaWYgKHJlbG9hZGluZykgcmV0dXJuXG4gICAgICAgIHJlbG9hZGluZyA9IHRydWVcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKVxuICAgICAgfVxuXG4gICAgICBzdGFydFRyYW5zaXRpb24oKCkgPT4ge1xuICAgICAgICByb3V0ZXIuaG1yUmVmcmVzaCgpXG4gICAgICAgIGRpc3BhdGNoZXIub25SZWZyZXNoKClcbiAgICAgIH0pXG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfVEVTVF9NT0RFKSB7XG4gICAgICAgIGlmIChzZWxmLl9fTkVYVF9ITVJfQ0IpIHtcbiAgICAgICAgICBzZWxmLl9fTkVYVF9ITVJfQ0IoKVxuICAgICAgICAgIHNlbGYuX19ORVhUX0hNUl9DQiA9IG51bGxcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY2FzZSBITVJfQUNUSU9OU19TRU5UX1RPX0JST1dTRVIuUkVMT0FEX1BBR0U6IHtcbiAgICAgIHR1cmJvcGFja0htcj8ub25SZWxvYWRQYWdlKClcbiAgICAgIHNlbmRNZXNzYWdlKFxuICAgICAgICBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgZXZlbnQ6ICdjbGllbnQtcmVsb2FkLXBhZ2UnLFxuICAgICAgICAgIGNsaWVudElkOiBfX25leHREZXZDbGllbnRJZCxcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICAgIGlmIChyZWxvYWRpbmcpIHJldHVyblxuICAgICAgcmVsb2FkaW5nID0gdHJ1ZVxuICAgICAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKVxuICAgIH1cbiAgICBjYXNlIEhNUl9BQ1RJT05TX1NFTlRfVE9fQlJPV1NFUi5BRERFRF9QQUdFOlxuICAgIGNhc2UgSE1SX0FDVElPTlNfU0VOVF9UT19CUk9XU0VSLlJFTU9WRURfUEFHRToge1xuICAgICAgdHVyYm9wYWNrSG1yPy5vblBhZ2VBZGRSZW1vdmUoKVxuICAgICAgLy8gVE9ETy1BUFA6IHBvdGVudGlhbGx5IG9ubHkgcmVmcmVzaCBpZiB0aGUgY3VycmVudGx5IHZpZXdlZCBwYWdlIHdhcyBhZGRlZC9yZW1vdmVkLlxuICAgICAgcmV0dXJuIHJvdXRlci5obXJSZWZyZXNoKClcbiAgICB9XG4gICAgY2FzZSBITVJfQUNUSU9OU19TRU5UX1RPX0JST1dTRVIuU0VSVkVSX0VSUk9SOiB7XG4gICAgICBjb25zdCB7IGVycm9ySlNPTiB9ID0gb2JqXG4gICAgICBpZiAoZXJyb3JKU09OKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZSwgc3RhY2sgfSA9IEpTT04ucGFyc2UoZXJyb3JKU09OKVxuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKVxuICAgICAgICBlcnJvci5zdGFjayA9IHN0YWNrXG4gICAgICAgIGhhbmRsZUVycm9ycyhbZXJyb3JdKVxuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNhc2UgSE1SX0FDVElPTlNfU0VOVF9UT19CUk9XU0VSLkRFVl9QQUdFU19NQU5JRkVTVF9VUERBVEU6IHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEhvdFJlbG9hZCh7XG4gIGFzc2V0UHJlZml4LFxuICBjaGlsZHJlbixcbiAgZ2xvYmFsRXJyb3IsXG59OiB7XG4gIGFzc2V0UHJlZml4OiBzdHJpbmdcbiAgY2hpbGRyZW46IFJlYWN0Tm9kZVxuICBnbG9iYWxFcnJvcjogR2xvYmFsRXJyb3JTdGF0ZVxufSkge1xuICB1c2VFcnJvckhhbmRsZXIoZGlzcGF0Y2hlci5vblVuaGFuZGxlZEVycm9yLCBkaXNwYXRjaGVyLm9uVW5oYW5kbGVkUmVqZWN0aW9uKVxuXG4gIGNvbnN0IHdlYlNvY2tldFJlZiA9IHVzZVdlYnNvY2tldChhc3NldFByZWZpeClcblxuICB1c2VXZWJzb2NrZXRQaW5nKHdlYlNvY2tldFJlZilcbiAgY29uc3Qgc2VuZE1lc3NhZ2UgPSB1c2VTZW5kTWVzc2FnZSh3ZWJTb2NrZXRSZWYpXG4gIHVzZUZvcndhcmRDb25zb2xlTG9nKHdlYlNvY2tldFJlZilcbiAgY29uc3QgcHJvY2Vzc1R1cmJvcGFja01lc3NhZ2UgPSB1c2VUdXJib3BhY2soc2VuZE1lc3NhZ2UsIChlcnIpID0+XG4gICAgcGVyZm9ybUZ1bGxSZWxvYWQoZXJyLCBzZW5kTWVzc2FnZSlcbiAgKVxuXG4gIGNvbnN0IHJvdXRlciA9IHVzZVJvdXRlcigpXG5cbiAgLy8gV2UgZG9uJ3Qgd2FudCBhY2Nlc3Mgb2YgdGhlIHBhdGhuYW1lIGZvciB0aGUgZGV2IHRvb2xzIHRvIHRyaWdnZXIgYSBkeW5hbWljXG4gIC8vIGFjY2VzcyAoYXMgdGhlIGRldiBvdmVybGF5IHdpbGwgbmV2ZXIgYmUgcHJlc2VudCBpbiBwcm9kdWN0aW9uKS5cbiAgY29uc3QgcGF0aG5hbWUgPSB1c2VVbnRyYWNrZWRQYXRobmFtZSgpXG4gIGNvbnN0IGFwcElzck1hbmlmZXN0UmVmID0gdXNlUmVmPFJlY29yZDxzdHJpbmcsIGZhbHNlIHwgbnVtYmVyPj4oe30pXG4gIGNvbnN0IHBhdGhuYW1lUmVmID0gdXNlUmVmKHBhdGhuYW1lKVxuXG4gIGlmIChwcm9jZXNzLmVudi5fX05FWFRfREVWX0lORElDQVRPUikge1xuICAgIC8vIHRoaXMgY29uZGl0aW9uYWwgaXMgb25seSBmb3IgZGVhZC1jb2RlIGVsaW1pbmF0aW9uIHdoaWNoXG4gICAgLy8gaXNuJ3QgYSBydW50aW1lIGNvbmRpdGlvbmFsIG9ubHkgYnVpbGQtdGltZSBzbyBpZ25vcmUgaG9va3MgcnVsZVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBwYXRobmFtZVJlZi5jdXJyZW50ID0gcGF0aG5hbWVcblxuICAgICAgY29uc3QgYXBwSXNyTWFuaWZlc3QgPSBhcHBJc3JNYW5pZmVzdFJlZi5jdXJyZW50XG5cbiAgICAgIGlmIChhcHBJc3JNYW5pZmVzdCkge1xuICAgICAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWUgaW4gYXBwSXNyTWFuaWZlc3QpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGlzcGF0Y2hlci5vblN0YXRpY0luZGljYXRvcih0cnVlKVxuICAgICAgICAgIH0gY2F0Y2ggKHJlYXNvbikge1xuICAgICAgICAgICAgbGV0IG1lc3NhZ2UgPSAnJ1xuXG4gICAgICAgICAgICBpZiAocmVhc29uIGluc3RhbmNlb2YgRE9NRXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgIC8vIE1vc3QgbGlrZWx5IGEgU2VjdXJpdHlFcnJvciwgYmVjYXVzZSBvZiBhbiB1bmF2YWlsYWJsZSBsb2NhbFN0b3JhZ2VcbiAgICAgICAgICAgICAgbWVzc2FnZSA9IHJlYXNvbi5zdGFjayA/PyByZWFzb24ubWVzc2FnZVxuICAgICAgICAgICAgfSBlbHNlIGlmIChyZWFzb24gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICBtZXNzYWdlID0gJ0Vycm9yOiAnICsgcmVhc29uLm1lc3NhZ2UgKyAnXFxuJyArIChyZWFzb24uc3RhY2sgPz8gJycpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtZXNzYWdlID0gJ1VuZXhwZWN0ZWQgRXhjZXB0aW9uOiAnICsgcmVhc29uXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnNvbGUud2FybignW0hNUl0gJyArIG1lc3NhZ2UpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRpc3BhdGNoZXIub25TdGF0aWNJbmRpY2F0b3IoZmFsc2UpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBbcGF0aG5hbWVdKVxuICB9XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCB3ZWJzb2NrZXQgPSB3ZWJTb2NrZXRSZWYuY3VycmVudFxuICAgIGlmICghd2Vic29ja2V0KSByZXR1cm5cblxuICAgIGNvbnN0IGhhbmRsZXIgPSAoZXZlbnQ6IE1lc3NhZ2VFdmVudDxhbnk+KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBvYmogPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpXG4gICAgICAgIHByb2Nlc3NNZXNzYWdlKFxuICAgICAgICAgIG9iaixcbiAgICAgICAgICBzZW5kTWVzc2FnZSxcbiAgICAgICAgICBwcm9jZXNzVHVyYm9wYWNrTWVzc2FnZSxcbiAgICAgICAgICByb3V0ZXIsXG4gICAgICAgICAgYXBwSXNyTWFuaWZlc3RSZWYsXG4gICAgICAgICAgcGF0aG5hbWVSZWZcbiAgICAgICAgKVxuICAgICAgfSBjYXRjaCAoZXJyOiB1bmtub3duKSB7XG4gICAgICAgIHJlcG9ydEludmFsaWRIbXJNZXNzYWdlKGV2ZW50LCBlcnIpXG4gICAgICB9XG4gICAgfVxuXG4gICAgd2Vic29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBoYW5kbGVyKVxuICAgIHJldHVybiAoKSA9PiB3ZWJzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGhhbmRsZXIpXG4gIH0sIFtcbiAgICBzZW5kTWVzc2FnZSxcbiAgICByb3V0ZXIsXG4gICAgd2ViU29ja2V0UmVmLFxuICAgIHByb2Nlc3NUdXJib3BhY2tNZXNzYWdlLFxuICAgIGFwcElzck1hbmlmZXN0UmVmLFxuICBdKVxuICByZXR1cm4gKFxuICAgIDxBcHBEZXZPdmVybGF5RXJyb3JCb3VuZGFyeSBnbG9iYWxFcnJvcj17Z2xvYmFsRXJyb3J9PlxuICAgICAgPFJlcGxheVNzck9ubHlFcnJvcnMgb25CbG9ja2luZ0Vycm9yPXtkaXNwYXRjaGVyLm9wZW5FcnJvck92ZXJsYXl9IC8+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9BcHBEZXZPdmVybGF5RXJyb3JCb3VuZGFyeT5cbiAgKVxufVxuIl0sIm5hbWVzIjpbIkhvdFJlbG9hZCIsIndhaXRGb3JXZWJwYWNrUnVudGltZUhvdFVwZGF0ZSIsIm1vc3RSZWNlbnRDb21waWxhdGlvbkhhc2giLCJfX25leHREZXZDbGllbnRJZCIsIk1hdGgiLCJyb3VuZCIsInJhbmRvbSIsIkRhdGUiLCJub3ciLCJyZWxvYWRpbmciLCJ3ZWJwYWNrU3RhcnRNc1NpbmNlRXBvY2giLCJ0dXJib3BhY2tIbXIiLCJwcm9jZXNzIiwiZW52IiwiVFVSQk9QQUNLIiwiVHVyYm9wYWNrSG1yIiwicGVuZGluZ0hvdFVwZGF0ZVdlYnBhY2siLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlc29sdmVQZW5kaW5nSG90VXBkYXRlV2VicGFjayIsInNldFBlbmRpbmdIb3RVcGRhdGVXZWJwYWNrIiwiaGFuZGxlQXZhaWxhYmxlSGFzaCIsImhhc2giLCJpc1VwZGF0ZUF2YWlsYWJsZSIsIl9fd2VicGFja19oYXNoX18iLCJjYW5BcHBseVVwZGF0ZXMiLCJtb2R1bGUiLCJob3QiLCJzdGF0dXMiLCJhZnRlckFwcGx5VXBkYXRlcyIsImZuIiwiaGFuZGxlciIsInJlbW92ZVN0YXR1c0hhbmRsZXIiLCJhZGRTdGF0dXNIYW5kbGVyIiwicGVyZm9ybUZ1bGxSZWxvYWQiLCJlcnIiLCJzZW5kTWVzc2FnZSIsInN0YWNrVHJhY2UiLCJzdGFjayIsInNwbGl0Iiwic2xpY2UiLCJqb2luIiwibWVzc2FnZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJldmVudCIsImhhZFJ1bnRpbWVFcnJvciIsIlJ1bnRpbWVFcnJvckhhbmRsZXIiLCJkZXBlbmRlbmN5Q2hhaW4iLCJ1bmRlZmluZWQiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsInJlbG9hZCIsInRyeUFwcGx5VXBkYXRlc1dlYnBhY2siLCJkaXNwYXRjaGVyIiwib25CdWlsZE9rIiwicmVwb3J0SG1yTGF0ZW5jeSIsImhhbmRsZUFwcGx5VXBkYXRlcyIsInVwZGF0ZWRNb2R1bGVzIiwiY29uc29sZSIsIndhcm4iLCJSRUFDVF9SRUZSRVNIX0ZVTExfUkVMT0FEIiwiUkVBQ1RfUkVGUkVTSF9GVUxMX1JFTE9BRF9GUk9NX0VSUk9SIiwib25SZWZyZXNoIiwiX19ORVhUX1RFU1RfTU9ERSIsInNlbGYiLCJfX05FWFRfSE1SX0NCIiwiY2hlY2siLCJ0aGVuIiwib25CZWZvcmVSZWZyZXNoIiwiYXBwbHkiLCJwcm9jZXNzTWVzc2FnZSIsIm9iaiIsInByb2Nlc3NUdXJib3BhY2tNZXNzYWdlIiwicm91dGVyIiwiYXBwSXNyTWFuaWZlc3RSZWYiLCJwYXRobmFtZVJlZiIsImhhbmRsZUVycm9ycyIsImVycm9ycyIsImZvcm1hdHRlZCIsImZvcm1hdFdlYnBhY2tNZXNzYWdlcyIsIndhcm5pbmdzIiwib25CdWlsZEVycm9yIiwiaSIsImxlbmd0aCIsImVycm9yIiwic3RyaXBBbnNpIiwiaGFuZGxlSG90VXBkYXRlIiwiaG1yVXBkYXRlIiwib25CdWlsdCIsInN0YXJ0TXNTaW5jZUVwb2NoIiwiZW5kTXNTaW5jZUVwb2NoIiwiaGFzVXBkYXRlcyIsImFjdGlvbiIsIkhNUl9BQ1RJT05TX1NFTlRfVE9fQlJPV1NFUiIsIklTUl9NQU5JRkVTVCIsIl9fTkVYVF9ERVZfSU5ESUNBVE9SIiwiY3VycmVudCIsImRhdGEiLCJvblN0YXRpY0luZGljYXRvciIsIkJVSUxESU5HIiwiYnVpbGRpbmdJbmRpY2F0b3JTaG93Iiwib25CdWlsZGluZyIsImxvZyIsIkJVSUxUIiwiU1lOQyIsImJ1aWxkaW5nSW5kaWNhdG9ySGlkZSIsIm9uVmVyc2lvbkluZm8iLCJ2ZXJzaW9uSW5mbyIsImRlYnVnIiwib25EZWJ1Z0luZm8iLCJvbkRldkluZGljYXRvciIsImRldkluZGljYXRvciIsImhhc0Vycm9ycyIsIkJvb2xlYW4iLCJlcnJvckNvdW50IiwiY2xpZW50SWQiLCJoYXNXYXJuaW5ncyIsIndhcm5pbmdDb3VudCIsImZvcm1hdHRlZE1lc3NhZ2VzIiwiVFVSQk9QQUNLX0NPTk5FQ1RFRCIsInR5cGUiLCJzZXNzaW9uSWQiLCJUVVJCT1BBQ0tfTUVTU0FHRSIsIm9uVHVyYm9wYWNrTWVzc2FnZSIsIlNFUlZFUl9DT01QT05FTlRfQ0hBTkdFUyIsIm9uU2VydmVyQ29tcG9uZW50Q2hhbmdlcyIsImRvY3VtZW50IiwiY29va2llIiwiTkVYVF9ITVJfUkVGUkVTSF9IQVNIX0NPT0tJRSIsInN0YXJ0VHJhbnNpdGlvbiIsImhtclJlZnJlc2giLCJSRUxPQURfUEFHRSIsIm9uUmVsb2FkUGFnZSIsIkFEREVEX1BBR0UiLCJSRU1PVkVEX1BBR0UiLCJvblBhZ2VBZGRSZW1vdmUiLCJTRVJWRVJfRVJST1IiLCJlcnJvckpTT04iLCJwYXJzZSIsIkVycm9yIiwiREVWX1BBR0VTX01BTklGRVNUX1VQREFURSIsImFzc2V0UHJlZml4IiwiY2hpbGRyZW4iLCJnbG9iYWxFcnJvciIsInVzZUVycm9ySGFuZGxlciIsIm9uVW5oYW5kbGVkRXJyb3IiLCJvblVuaGFuZGxlZFJlamVjdGlvbiIsIndlYlNvY2tldFJlZiIsInVzZVdlYnNvY2tldCIsInVzZVdlYnNvY2tldFBpbmciLCJ1c2VTZW5kTWVzc2FnZSIsInVzZUZvcndhcmRDb25zb2xlTG9nIiwidXNlVHVyYm9wYWNrIiwidXNlUm91dGVyIiwicGF0aG5hbWUiLCJ1c2VVbnRyYWNrZWRQYXRobmFtZSIsInVzZVJlZiIsInVzZUVmZmVjdCIsImFwcElzck1hbmlmZXN0IiwicmVhc29uIiwiRE9NRXhjZXB0aW9uIiwid2Vic29ja2V0IiwicmVwb3J0SW52YWxpZEhtck1lc3NhZ2UiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIkFwcERldk92ZXJsYXlFcnJvckJvdW5kYXJ5IiwiUmVwbGF5U3NyT25seUVycm9ycyIsIm9uQmxvY2tpbmdFcnJvciIsIm9wZW5FcnJvck92ZXJsYXkiXSwibWFwcGluZ3MiOiJBQUFBLDZDQUE2Qzs7Ozs7Ozs7Ozs7Ozs7O0lBK2I3QyxPQWlHQyxFQUFBO2VBakd1QkE7O0lBMVlSQyw4QkFBOEIsRUFBQTtlQUE5QkE7Ozs7O3VCQWxEbUM7b0VBQzdCO2dGQUNZOzRCQUNSO3dCQUtuQjs4QkFDb0I7cUNBQ1M7NENBQ087aUNBQ1g7cUNBQ0k7OEJBTTdCO2tDQUNxQztxQ0FLUDsyRUFDUjs0Q0FDQTtrQ0FDZ0I7c0NBRVI7QUFFckMsSUFBSUMsNEJBQWlDO0FBQ3JDLElBQUlDLG9CQUFvQkMsS0FBS0MsS0FBSyxDQUFDRCxLQUFLRSxNQUFNLEtBQUssTUFBTUMsS0FBS0MsR0FBRztBQUNqRSxJQUFJQyxZQUFZO0FBQ2hCLElBQUlDLDJCQUEwQztBQUM5QyxNQUFNQyxlQUFvQ0MsUUFBUUMsR0FBRyxDQUFDQyxTQUFTLGtCQUMzRCxJQUFJQyw0QkFBQUEsWUFBWSxLQUNoQjtBQUVKLElBQUlDLDBCQUEwQkMsUUFBUUMsT0FBTztBQUM3QyxJQUFJQyxpQ0FBNkMsS0FBTztBQUN4RCxTQUFTQztJQUNQSiwwQkFBMEIsSUFBSUMsUUFBUSxDQUFDQztRQUNyQ0MsaUNBQWlDO1lBQy9CRDtRQUNGO0lBQ0Y7QUFDRjtBQUVPLFNBQVNqQjtJQUNkLE9BQU9lO0FBQ1Q7QUFFQSxrREFBa0Q7QUFDbEQsU0FBU0ssb0JBQW9CQyxJQUFZO0lBQ3ZDLHNDQUFzQztJQUN0Q3BCLDRCQUE0Qm9CO0FBQzlCO0FBRUE7Ozs7Q0FJQyxHQUNELFNBQVNDO0lBQ1AsSUFBSVgsUUFBUUMsR0FBRyxDQUFDQyxTQUFTLGVBQUU7UUFDekIsT0FBTztJQUNUOzs7QUFNRjtBQUVBLDZDQUE2QztBQUM3QyxTQUFTVztJ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O1FBQ0FzQztRQUNBMEU7UUFDQTNFO1FBQ0FFO0tBQ0Q7SUFDRCxPQUFBLFdBQUEsR0FDRSxDQUFBLEdBQUEsWUFBQSxJQUFBLEVBQUMyRiw0QkFBQUEsMEJBQTBCLEVBQUE7UUFBQ3RCLGFBQWFBOzswQkFDdkMsQ0FBQSxHQUFBLFlBQUEsR0FBQSxFQUFDdUIscUJBQUFBLG1CQUFtQixFQUFBO2dCQUFDQyxpQkFBaUJsSCxjQUFBQSxVQUFVLENBQUNtSCxnQkFBZ0I7O1lBQ2hFMUI7OztBQUdQIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDkzMDcsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvY2xpZW50L2NvbXBvbmVudHMvYXBwLXJvdXRlci50c3giXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbmltcG9ydCBSZWFjdCwge1xuICB1c2VFZmZlY3QsXG4gIHVzZU1lbW8sXG4gIHN0YXJ0VHJhbnNpdGlvbixcbiAgdXNlSW5zZXJ0aW9uRWZmZWN0LFxuICB1c2VEZWZlcnJlZFZhbHVlLFxufSBmcm9tICdyZWFjdCdcbmltcG9ydCB7XG4gIEFwcFJvdXRlckNvbnRleHQsXG4gIExheW91dFJvdXRlckNvbnRleHQsXG4gIEdsb2JhbExheW91dFJvdXRlckNvbnRleHQsXG59IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHR5cGUgeyBDYWNoZU5vZGUgfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB7IEFDVElPTl9SRVNUT1JFIH0gZnJvbSAnLi9yb3V0ZXItcmVkdWNlci9yb3V0ZXItcmVkdWNlci10eXBlcydcbmltcG9ydCB0eXBlIHsgQXBwUm91dGVyU3RhdGUgfSBmcm9tICcuL3JvdXRlci1yZWR1Y2VyL3JvdXRlci1yZWR1Y2VyLXR5cGVzJ1xuaW1wb3J0IHsgY3JlYXRlSHJlZkZyb21VcmwgfSBmcm9tICcuL3JvdXRlci1yZWR1Y2VyL2NyZWF0ZS1ocmVmLWZyb20tdXJsJ1xuaW1wb3J0IHtcbiAgU2VhcmNoUGFyYW1zQ29udGV4dCxcbiAgUGF0aG5hbWVDb250ZXh0LFxuICBQYXRoUGFyYW1zQ29udGV4dCxcbn0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi9ob29rcy1jbGllbnQtY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB7IGRpc3BhdGNoQXBwUm91dGVyQWN0aW9uLCB1c2VBY3Rpb25RdWV1ZSB9IGZyb20gJy4vdXNlLWFjdGlvbi1xdWV1ZSdcbmltcG9ydCB7IEVycm9yQm91bmRhcnkgfSBmcm9tICcuL2Vycm9yLWJvdW5kYXJ5J1xuaW1wb3J0IERlZmF1bHRHbG9iYWxFcnJvciBmcm9tICcuL2J1aWx0aW4vZ2xvYmFsLWVycm9yJ1xuaW1wb3J0IHsgaXNCb3QgfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9pcy1ib3QnXG5pbXBvcnQgeyBhZGRCYXNlUGF0aCB9IGZyb20gJy4uL2FkZC1iYXNlLXBhdGgnXG5pbXBvcnQgeyBBcHBSb3V0ZXJBbm5vdW5jZXIgfSBmcm9tICcuL2FwcC1yb3V0ZXItYW5ub3VuY2VyJ1xuaW1wb3J0IHsgUmVkaXJlY3RCb3VuZGFyeSB9IGZyb20gJy4vcmVkaXJlY3QtYm91bmRhcnknXG5pbXBvcnQgeyBmaW5kSGVhZEluQ2FjaGUgfSBmcm9tICcuL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL2ZpbmQtaGVhZC1pbi1jYWNoZSdcbmltcG9ydCB7IHVucmVzb2x2ZWRUaGVuYWJsZSB9IGZyb20gJy4vdW5yZXNvbHZlZC10aGVuYWJsZSdcbmltcG9ydCB7IHJlbW92ZUJhc2VQYXRoIH0gZnJvbSAnLi4vcmVtb3ZlLWJhc2UtcGF0aCdcbmltcG9ydCB7IGhhc0Jhc2VQYXRoIH0gZnJvbSAnLi4vaGFzLWJhc2UtcGF0aCdcbmltcG9ydCB7IGdldFNlbGVjdGVkUGFyYW1zIH0gZnJvbSAnLi9yb3V0ZXItcmVkdWNlci9jb21wdXRlLWNoYW5nZWQtcGF0aCdcbmltcG9ydCB0eXBlIHsgRmxpZ2h0Um91dGVyU3RhdGUgfSBmcm9tICcuLi8uLi9zZXJ2ZXIvYXBwLXJlbmRlci90eXBlcydcbmltcG9ydCB7IHVzZU5hdkZhaWx1cmVIYW5kbGVyIH0gZnJvbSAnLi9uYXYtZmFpbHVyZS1oYW5kbGVyJ1xuaW1wb3J0IHtcbiAgZGlzcGF0Y2hUcmF2ZXJzZUFjdGlvbixcbiAgcHVibGljQXBwUm91dGVySW5zdGFuY2UsXG4gIHR5cGUgQXBwUm91dGVyQWN0aW9uUXVldWUsXG4gIHR5cGUgR2xvYmFsRXJyb3JTdGF0ZSxcbn0gZnJvbSAnLi9hcHAtcm91dGVyLWluc3RhbmNlJ1xuaW1wb3J0IHsgZ2V0UmVkaXJlY3RUeXBlRnJvbUVycm9yLCBnZXRVUkxGcm9tUmVkaXJlY3RFcnJvciB9IGZyb20gJy4vcmVkaXJlY3QnXG5pbXBvcnQgeyBpc1JlZGlyZWN0RXJyb3IsIFJlZGlyZWN0VHlwZSB9IGZyb20gJy4vcmVkaXJlY3QtZXJyb3InXG5pbXBvcnQgeyBwaW5nVmlzaWJsZUxpbmtzIH0gZnJvbSAnLi9saW5rcydcbmltcG9ydCBHcmFjZWZ1bERlZ3JhZGVCb3VuZGFyeSBmcm9tICcuL2Vycm9ycy9ncmFjZWZ1bC1kZWdyYWRlLWJvdW5kYXJ5J1xuXG5jb25zdCBnbG9iYWxNdXRhYmxlOiB7XG4gIHBlbmRpbmdNcGFQYXRoPzogc3RyaW5nXG59ID0ge31cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRXh0ZXJuYWxVUkwodXJsOiBVUkwpIHtcbiAgcmV0dXJuIHVybC5vcmlnaW4gIT09IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW5cbn1cblxuLyoqXG4gKiBHaXZlbiBhIGxpbmsgaHJlZiwgY29uc3RydWN0cyB0aGUgVVJMIHRoYXQgc2hvdWxkIGJlIHByZWZldGNoZWQuIFJldHVybnMgbnVsbFxuICogaW4gY2FzZXMgd2hlcmUgcHJlZmV0Y2hpbmcgc2hvdWxkIGJlIGRpc2FibGVkLCBsaWtlIGV4dGVybmFsIFVSTHMsIG9yXG4gKiBkdXJpbmcgZGV2ZWxvcG1lbnQuXG4gKiBAcGFyYW0gaHJlZiBUaGUgaHJlZiBwYXNzZWQgdG8gPExpbms+LCByb3V0ZXIucHJlZmV0Y2goKSwgb3Igc2ltaWxhclxuICogQHJldHVybnMgQSBVUkwgb2JqZWN0IHRvIHByZWZldGNoLCBvciBudWxsIGlmIHByZWZldGNoaW5nIHNob3VsZCBiZSBkaXNhYmxlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUHJlZmV0Y2hVUkwoaHJlZjogc3RyaW5nKTogVVJMIHwgbnVsbCB7XG4gIC8vIERvbid0IHByZWZldGNoIGZvciBib3RzIGFzIHRoZXkgZG9uJ3QgbmF2aWdhdGUuXG4gIGlmIChpc0JvdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgbGV0IHVybDogVVJMXG4gIHRyeSB7XG4gICAgdXJsID0gbmV3IFVSTChhZGRCYXNlUGF0aChocmVmKSwgd2luZG93LmxvY2F0aW9uLmhyZWYpXG4gIH0gY2F0Y2ggKF8pIHtcbiAgICAvLyBUT0RPOiBEb2VzIHRoaXMgbmVlZCB0byB0aHJvdyBvciBjYW4gd2UganVzdCBjb25zb2xlLmVycm9yIGluc3RlYWQ/IERvZXNcbiAgICAvLyBhbnlvbmUgcmVseSBvbiB0aGlzIHRocm93aW5nPyAoU2VlbXMgdW5saWtlbHkuKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBDYW5ub3QgcHJlZmV0Y2ggJyR7aHJlZn0nIGJlY2F1c2UgaXQgY2Fubm90IGJlIGNvbnZlcnRlZCB0byBhIFVSTC5gXG4gICAgKVxuICB9XG5cbiAgLy8gRG9uJ3QgcHJlZmV0Y2ggZHVyaW5nIGRldmVsb3BtZW50IChpbXByb3ZlcyBjb21waWxhdGlvbiBwZXJmb3JtYW5jZSlcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8vIEV4dGVybmFsIHVybHMgY2FuJ3QgYmUgcHJlZmV0Y2hlZCBpbiB0aGUgc2FtZSB3YXkuXG4gIGlmIChpc0V4dGVybmFsVVJMKHVybCkpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgcmV0dXJuIHVybFxufVxuXG5mdW5jdGlvbiBIaXN0b3J5VXBkYXRlcih7XG4gIGFwcFJvdXRlclN0YXRlLFxufToge1xuICBhcHBSb3V0ZXJTdGF0ZTogQXBwUm91dGVyU3RhdGVcbn0pIHtcbiAgdXNlSW5zZXJ0aW9uRWZmZWN0KCgpID0+IHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0FQUF9OQVZfRkFJTF9IQU5ETElORykge1xuICAgICAgLy8gY2xlYXIgcGVuZGluZyBVUkwgYXMgbmF2aWdhdGlvbiBpcyBubyBsb25nZXJcbiAgICAgIC8vIGluIGZsaWdodFxuICAgICAgd2luZG93Lm5leHQuX19wZW5kaW5nVXJsID0gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgY29uc3QgeyB0cmVlLCBwdXNoUmVmLCBjYW5vbmljYWxVcmwgfSA9IGFwcFJvdXRlclN0YXRlXG4gICAgY29uc3QgaGlzdG9yeVN0YXRlID0ge1xuICAgICAgLi4uKHB1c2hSZWYucHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGUgPyB3aW5kb3cuaGlzdG9yeS5zdGF0ZSA6IHt9KSxcbiAgICAgIC8vIElkZW50aWZpZXIgaXMgc2hvcnRlbmVkIGludGVudGlvbmFsbHkuXG4gICAgICAvLyBfX05BIGlzIHVzZWQgdG8gaWRlbnRpZnkgaWYgdGhlIGhpc3RvcnkgZW50cnkgY2FuIGJlIGhhbmRsZWQgYnkgdGhlIGFwcC1yb3V0ZXIuXG4gICAgICAvLyBfX04gaXMgdXNlZCB0byBpZGVudGlmeSBpZiB0aGUgaGlzdG9yeSBlbnRyeSBjYW4gYmUgaGFuZGxlZCBieSB0aGUgb2xkIHJvdXRlci5cbiAgICAgIF9fTkE6IHRydWUsXG4gICAgICBfX1BSSVZBVEVfTkVYVEpTX0lOVEVSTkFMU19UUkVFOiB0cmVlLFxuICAgIH1cbiAgICBpZiAoXG4gICAgICBwdXNoUmVmLnBlbmRpbmdQdXNoICYmXG4gICAgICAvLyBTa2lwIHB1c2hpbmcgYW4gYWRkaXRpb25hbCBoaXN0b3J5IGVudHJ5IGlmIHRoZSBjYW5vbmljYWxVcmwgaXMgdGhlIHNhbWUgYXMgdGhlIGN1cnJlbnQgdXJsLlxuICAgICAgLy8gVGhpcyBtaXJyb3JzIHRoZSBicm93c2VyIGJlaGF2aW9yIGZvciBub3JtYWwgbmF2aWdhdGlvbi5cbiAgICAgIGNyZWF0ZUhyZWZGcm9tVXJsKG5ldyBVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpKSAhPT0gY2Fub25pY2FsVXJsXG4gICAgKSB7XG4gICAgICAvLyBUaGlzIGludGVudGlvbmFsbHkgbXV0YXRlcyBSZWFjdCBzdGF0ZSwgcHVzaFJlZiBpcyBvdmVyd3JpdHRlbiB0byBlbnN1cmUgYWRkaXRpb25hbCBwdXNoL3JlcGxhY2UgY2FsbHMgZG8gbm90IHRyaWdnZXIgYW4gYWRkaXRpb25hbCBoaXN0b3J5IGVudHJ5LlxuICAgICAgcHVzaFJlZi5wZW5kaW5nUHVzaCA9IGZhbHNlXG4gICAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoaGlzdG9yeVN0YXRlLCAnJywgY2Fub25pY2FsVXJsKVxuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoaGlzdG9yeVN0YXRlLCAnJywgY2Fub25pY2FsVXJsKVxuICAgIH1cbiAgfSwgW2FwcFJvdXRlclN0YXRlXSlcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIFRoZSBOZXh0LVVybCBhbmQgdGhlIGJhc2UgdHJlZSBtYXkgYWZmZWN0IHRoZSByZXN1bHQgb2YgYSBwcmVmZXRjaFxuICAgIC8vIHRhc2suIFJlLXByZWZldGNoIGFsbCB2aXNpYmxlIGxpbmtzIHdpdGggdGhlIHVwZGF0ZWQgdmFsdWVzLiBJbiBtb3N0XG4gICAgLy8gY2FzZXMsIHRoaXMgd2lsbCBub3QgcmVzdWx0IGluIGFueSBuZXcgbmV0d29yayByZXF1ZXN0cywgb25seSBpZlxuICAgIC8vIHRoZSBwcmVmZXRjaCByZXN1bHQgYWN0dWFsbHkgdmFyaWVzIG9uIG9uZSBvZiB0aGVzZSBpbnB1dHMuXG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfU0VHTUVOVF9DQUNIRSkge1xuICAgICAgcGluZ1Zpc2libGVMaW5rcyhhcHBSb3V0ZXJTdGF0ZS5uZXh0VXJsLCBhcHBSb3V0ZXJTdGF0ZS50cmVlKVxuICAgIH1cbiAgfSwgW2FwcFJvdXRlclN0YXRlLm5leHRVcmwsIGFwcFJvdXRlclN0YXRlLnRyZWVdKVxuXG4gIHJldHVybiBudWxsXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFbXB0eUNhY2hlTm9kZSgpOiBDYWNoZU5vZGUge1xuICByZXR1cm4ge1xuICAgIGxhenlEYXRhOiBudWxsLFxuICAgIHJzYzogbnVsbCxcbiAgICBwcmVmZXRjaFJzYzogbnVsbCxcbiAgICBoZWFkOiBudWxsLFxuICAgIHByZWZldGNoSGVhZDogbnVsbCxcbiAgICBwYXJhbGxlbFJvdXRlczogbmV3IE1hcCgpLFxuICAgIGxvYWRpbmc6IG51bGwsXG4gICAgbmF2aWdhdGVkQXQ6IC0xLFxuICB9XG59XG5cbmZ1bmN0aW9uIGNvcHlOZXh0SnNJbnRlcm5hbEhpc3RvcnlTdGF0ZShkYXRhOiBhbnkpIHtcbiAgaWYgKGRhdGEgPT0gbnVsbCkgZGF0YSA9IHt9XG4gIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IHdpbmRvdy5oaXN0b3J5LnN0YXRlXG4gIGNvbnN0IF9fTkEgPSBjdXJyZW50U3RhdGU/Ll9fTkFcbiAgaWYgKF9fTkEpIHtcbiAgICBkYXRhLl9fTkEgPSBfX05BXG4gIH1cbiAgY29uc3QgX19QUklWQVRFX05FWFRKU19JTlRFUk5BTFNfVFJFRSA9XG4gICAgY3VycmVudFN0YXRlPy5fX1BSSVZBVEVfTkVYVEpTX0lOVEVSTkFMU19UUkVFXG4gIGlmIChfX1BSSVZBVEVfTkVYVEpTX0lOVEVSTkFMU19UUkVFKSB7XG4gICAgZGF0YS5fX1BSSVZBVEVfTkVYVEpTX0lOVEVSTkFMU19UUkVFID0gX19QUklWQVRFX05FWFRKU19JTlRFUk5BTFNfVFJFRVxuICB9XG5cbiAgcmV0dXJuIGRhdGFcbn1cblxuZnVuY3Rpb24gSGVhZCh7XG4gIGhlYWRDYWNoZU5vZGUsXG59OiB7XG4gIGhlYWRDYWNoZU5vZGU6IENhY2hlTm9kZSB8IG51bGxcbn0pOiBSZWFjdC5SZWFjdE5vZGUge1xuICAvLyBJZiB0aGlzIHNlZ21lbnQgaGFzIGEgYHByZWZldGNoSGVhZGAsIGl0J3MgdGhlIHN0YXRpY2FsbHkgcHJlZmV0Y2hlZCBkYXRhLlxuICAvLyBXZSBzaG91bGQgdXNlIHRoYXQgb24gaW5pdGlhbCByZW5kZXIgaW5zdGVhZCBvZiBgaGVhZGAuIFRoZW4gd2UnbGwgc3dpdGNoXG4gIC8vIHRvIGBoZWFkYCB3aGVuIHRoZSBkeW5hbWljIHJlc3BvbnNlIHN0cmVhbXMgaW4uXG4gIGNvbnN0IGhlYWQgPSBoZWFkQ2FjaGVOb2RlICE9PSBudWxsID8gaGVhZENhY2hlTm9kZS5oZWFkIDogbnVsbFxuICBjb25zdCBwcmVmZXRjaEhlYWQgPVxuICAgIGhlYWRDYWNoZU5vZGUgIT09IG51bGwgPyBoZWFkQ2FjaGVOb2RlLnByZWZldGNoSGVhZCA6IG51bGxcblxuICAvLyBJZiBubyBwcmVmZXRjaCBkYXRhIGlzIGF2YWlsYWJsZSwgdGhlbiB3ZSBnbyBzdHJhaWdodCB0byByZW5kZXJpbmcgYGhlYWRgLlxuICBjb25zdCByZXNvbHZlZFByZWZldGNoUnNjID0gcHJlZmV0Y2hIZWFkICE9PSBudWxsID8gcHJlZmV0Y2hIZWFkIDogaGVhZFxuXG4gIC8vIFdlIHVzZSBgdXNlRGVmZXJyZWRWYWx1ZWAgdG8gaGFuZGxlIHN3aXRjaGluZyBiZXR3ZWVuIHRoZSBwcmVmZXRjaGVkIGFuZFxuICAvLyBmaW5hbCB2YWx1ZXMuIFRoZSBzZWNvbmQgYXJndW1lbnQgaXMgcmV0dXJuZWQgb24gaW5pdGlhbCByZW5kZXIsIHRoZW4gaXRcbiAgLy8gcmUtcmVuZGVycyB3aXRoIHRoZSBmaXJzdCBhcmd1bWVudC5cbiAgcmV0dXJuIHVzZURlZmVycmVkVmFsdWUoaGVhZCwgcmVzb2x2ZWRQcmVmZXRjaFJzYylcbn1cblxuLyoqXG4gKiBUaGUgZ2xvYmFsIHJvdXRlciB0aGF0IHdyYXBzIHRoZSBhcHBsaWNhdGlvbiBjb21wb25lbnRzLlxuICovXG5mdW5jdGlvbiBSb3V0ZXIoe1xuICBhY3Rpb25RdWV1ZSxcbiAgYXNzZXRQcmVmaXgsXG4gIGdsb2JhbEVycm9yLFxuICBncmFjZWZ1bGx5RGVncmFkZSxcbn06IHtcbiAgYWN0aW9uUXVldWU6IEFwcFJvdXRlckFjdGlvblF1ZXVlXG4gIGFzc2V0UHJlZml4OiBzdHJpbmdcbiAgZ2xvYmFsRXJyb3I6IEdsb2JhbEVycm9yU3RhdGVcbiAgZ3JhY2VmdWxseURlZ3JhZGU6IGJvb2xlYW5cbn0pIHtcbiAgY29uc3Qgc3RhdGUgPSB1c2VBY3Rpb25RdWV1ZShhY3Rpb25RdWV1ZSlcbiAgY29uc3QgeyBjYW5vbmljYWxVcmwgfSA9IHN0YXRlXG4gIC8vIEFkZCBtZW1vaXplZCBwYXRobmFtZS9xdWVyeSBmb3IgdXNlU2VhcmNoUGFyYW1zIGFuZCB1c2VQYXRobmFtZS5cbiAgY29uc3QgeyBzZWFyY2hQYXJhbXMsIHBhdGhuYW1lIH0gPSB1c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKFxuICAgICAgY2Fub25pY2FsVXJsLFxuICAgICAgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyAnaHR0cDovL24nIDogd2luZG93LmxvY2F0aW9uLmhyZWZcbiAgICApXG5cbiAgICByZXR1cm4ge1xuICAgICAgLy8gVGhpcyBpcyB0dXJuZWQgaW50byBhIHJlYWRvbmx5IGNsYXNzIGluIGB1c2VTZWFyY2hQYXJhbXNgXG4gICAgICBzZWFyY2hQYXJhbXM6IHVybC5zZWFyY2hQYXJhbXMsXG4gICAgICBwYXRobmFtZTogaGFzQmFzZVBhdGgodXJsLnBhdGhuYW1lKVxuICAgICAgICA/IHJlbW92ZUJhc2VQYXRoKHVybC5wYXRobmFtZSlcbiAgICAgICAgOiB1cmwucGF0aG5hbWUsXG4gICAgfVxuICB9LCBbY2Fub25pY2FsVXJsXSlcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgIGNvbnN0IHsgY2FjaGUsIHByZWZldGNoQ2FjaGUsIHRyZWUgfSA9IHN0YXRlXG5cbiAgICAvLyBUaGlzIGhvb2sgaXMgaW4gYSBjb25kaXRpb25hbCBidXQgdGhhdCBpcyBvayBiZWNhdXNlIGBwcm9jZXNzLmVudi5OT0RFX0VOVmAgbmV2ZXIgY2hhbmdlc1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAvLyBBZGQgYHdpbmRvdy5uZGAgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlcy5cbiAgICAgIC8vIFRoaXMgaXMgbm90IG1lYW50IGZvciB1c2UgaW4gYXBwbGljYXRpb25zIGFzIGNvbmN1cnJlbnQgcmVuZGVyaW5nIHdpbGwgYWZmZWN0IHRoZSBjYWNoZS90cmVlL3JvdXRlci5cbiAgICAgIC8vIEB0cy1pZ25vcmUgdGhpcyBpcyBmb3IgZGVidWdnaW5nXG4gICAgICB3aW5kb3cubmQgPSB7XG4gICAgICAgIHJvdXRlcjogcHVibGljQXBwUm91dGVySW5zdGFuY2UsXG4gICAgICAgIGNhY2hlLFxuICAgICAgICBwcmVmZXRjaENhY2hlLFxuICAgICAgICB0cmVlLFxuICAgICAgfVxuICAgIH0sIFtjYWNoZSwgcHJlZmV0Y2hDYWNoZSwgdHJlZV0pXG4gIH1cblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIElmIHRoZSBhcHAgaXMgcmVzdG9yZWQgZnJvbSBiZmNhY2hlLCBpdCdzIHBvc3NpYmxlIHRoYXRcbiAgICAvLyBwdXNoUmVmLm1wYU5hdmlnYXRpb24gaXMgdHJ1ZSwgd2hpY2ggd291bGQgbWVhbiB0aGF0IGFueSByZS1yZW5kZXIgb2YgdGhpcyBjb21wb25lbnRcbiAgICAvLyB3b3VsZCB0cmlnZ2VyIHRoZSBtcGEgbmF2aWdhdGlvbiBsb2dpYyBhZ2FpbiBmcm9tIHRoZSBsaW5lcyBiZWxvdy5cbiAgICAvLyBUaGlzIHdpbGwgcmVzdG9yZSB0aGUgcm91dGVyIHRvIHRoZSBpbml0aWFsIHN0YXRlIGluIHRoZSBldmVudCB0aGF0IHRoZSBhcHAgaXMgcmVzdG9yZWQgZnJvbSBiZmNhY2hlLlxuICAgIGZ1bmN0aW9uIGhhbmRsZVBhZ2VTaG93KGV2ZW50OiBQYWdlVHJhbnNpdGlvbkV2ZW50KSB7XG4gICAgICBpZiAoXG4gICAgICAgICFldmVudC5wZXJzaXN0ZWQgfHxcbiAgICAgICAgIXdpbmRvdy5oaXN0b3J5LnN0YXRlPy5fX1BSSVZBVEVfTkVYVEpTX0lOVEVSTkFMU19UUkVFXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIENsZWFyIHRoZSBwZW5kaW5nTXBhUGF0aCB2YWx1ZSBzbyB0aGF0IGEgc3Vic2VxdWVudCBNUEEgbmF2aWdhdGlvbiB0byB0aGUgc2FtZSBVUkwgY2FuIGJlIHRyaWdnZXJlZC5cbiAgICAgIC8vIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgaWYgdGhlIGJyb3dzZXIgcmVzdG9yZWQgZnJvbSBiZmNhY2hlLCB0aGUgcGVuZGluZ01wYVBhdGggd291bGQgc3RpbGwgYmUgc2V0IHRvIHRoZSB2YWx1ZVxuICAgICAgLy8gb2YgdGhlIGxhc3QgTVBBIG5hdmlnYXRpb24uXG4gICAgICBnbG9iYWxNdXRhYmxlLnBlbmRpbmdNcGFQYXRoID0gdW5kZWZpbmVkXG5cbiAgICAgIGRpc3BhdGNoQXBwUm91dGVyQWN0aW9uKHtcbiAgICAgICAgdHlwZTogQUNUSU9OX1JFU1RPUkUsXG4gICAgICAgIHVybDogbmV3IFVSTCh3aW5kb3cubG9jYXRpb24uaHJlZiksXG4gICAgICAgIHRyZWU6IHdpbmRvdy5oaXN0b3J5LnN0YXRlLl9fUFJJVkFURV9ORVhUSlNfSU5URVJOQUxTX1RSRUUsXG4gICAgICB9KVxuICAgIH1cblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwYWdlc2hvdycsIGhhbmRsZVBhZ2VTaG93KVxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwYWdlc2hvdycsIGhhbmRsZVBhZ2VTaG93KVxuICAgIH1cbiAgfSwgW10pXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBFbnN1cmUgdGhhdCBhbnkgcmVkaXJlY3QgZXJyb3JzIHRoYXQgYnViYmxlIHVwIG91dHNpZGUgb2YgdGhlIFJlZGlyZWN0Qm91bmRhcnlcbiAgICAvLyBhcmUgY2F1Z2h0IGFuZCBoYW5kbGVkIGJ5IHRoZSByb3V0ZXIuXG4gICAgZnVuY3Rpb24gaGFuZGxlVW5oYW5kbGVkUmVkaXJlY3QoXG4gICAgICBldmVudDogRXJyb3JFdmVudCB8IFByb21pc2VSZWplY3Rpb25FdmVudFxuICAgICkge1xuICAgICAgY29uc3QgZXJyb3IgPSAncmVhc29uJyBpbiBldmVudCA/IGV2ZW50LnJlYXNvbiA6IGV2ZW50LmVycm9yXG4gICAgICBpZiAoaXNSZWRpcmVjdEVycm9yKGVycm9yKSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgIGNvbnN0IHVybCA9IGdldFVSTEZyb21SZWRpcmVjdEVycm9yKGVycm9yKVxuICAgICAgICBjb25zdCByZWRpcmVjdFR5cGUgPSBnZXRSZWRpcmVjdFR5cGVGcm9tRXJyb3IoZXJyb3IpXG4gICAgICAgIC8vIFRPRE86IFRoaXMgc2hvdWxkIGFjY2VzcyB0aGUgcm91dGVyIG1ldGhvZHMgZGlyZWN0bHksIHJhdGhlciB0aGFuXG4gICAgICAgIC8vIGdvIHRocm91Z2ggdGhlIHB1YmxpYyBpbnRlcmZhY2UuXG4gICAgICAgIGlmIChyZWRpcmVjdFR5cGUgPT09IFJlZGlyZWN0VHlwZS5wdXNoKSB7XG4gICAgICAgICAgcHVibGljQXBwUm91dGVySW5zdGFuY2UucHVzaCh1cmwsIHt9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHB1YmxpY0FwcFJvdXRlckluc3RhbmNlLnJlcGxhY2UodXJsLCB7fSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBoYW5kbGVVbmhhbmRsZWRSZWRpcmVjdClcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndW5oYW5kbGVkcmVqZWN0aW9uJywgaGFuZGxlVW5oYW5kbGVkUmVkaXJlY3QpXG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgaGFuZGxlVW5oYW5kbGVkUmVkaXJlY3QpXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndW5oYW5kbGVkcmVqZWN0aW9uJywgaGFuZGxlVW5oYW5kbGVkUmVkaXJlY3QpXG4gICAgfVxuICB9LCBbXSlcblxuICAvLyBXaGVuIG1wYU5hdmlnYXRpb24gZmxhZyBpcyBzZXQgZG8gYSBoYXJkIG5hdmlnYXRpb24gdG8gdGhlIG5ldyB1cmwuXG4gIC8vIEluZmluaXRlbHkgc3VzcGVuZCBiZWNhdXNlIHdlIGRvbid0IGFjdHVhbGx5IHdhbnQgdG8gcmVyZW5kZXIgYW55IGNoaWxkXG4gIC8vIGNvbXBvbmVudHMgd2l0aCB0aGUgbmV3IFVSTCBhbmQgYW55IGVudGFuZ2xlZCBzdGF0ZSB1cGRhdGVzIHNob3VsZG4ndFxuICAvLyBjb21taXQgZWl0aGVyIChlZzogdXNlVHJhbnNpdGlvbiBpc1BlbmRpbmcgc2hvdWxkIHN0YXkgdHJ1ZSB1bnRpbCB0aGUgcGFnZVxuICAvLyB1bmxvYWRzKS5cbiAgLy9cbiAgLy8gVGhpcyBpcyBhIHNpZGUgZWZmZWN0IGluIHJlbmRlci4gRG9uJ3QgdHJ5IHRoaXMgYXQgaG9tZSwga2lkcy4gSXQnc1xuICAvLyBwcm9iYWJseSBzYWZlIGJlY2F1c2Ugd2Uga25vdyB0aGlzIGlzIGEgc2luZ2xldG9uIGNvbXBvbmVudCBhbmQgaXQncyBuZXZlclxuICAvLyBpbiA8T2Zmc2NyZWVuPi4gQXQgbGVhc3QgSSBob3BlIHNvLiAoSXQgd2lsbCBydW4gdHdpY2UgaW4gZGV2IHN0cmljdCBtb2RlLFxuICAvLyBidXQgdGhhdCdzLi4uIGZpbmU/KVxuICBjb25zdCB7IHB1c2hSZWYgfSA9IHN0YXRlXG4gIGlmIChwdXNoUmVmLm1wYU5hdmlnYXRpb24pIHtcbiAgICAvLyBpZiB0aGVyZSdzIGEgcmUtcmVuZGVyLCB3ZSBkb24ndCB3YW50IHRvIHRyaWdnZXIgYW5vdGhlciByZWRpcmVjdCBpZiBvbmUgaXMgYWxyZWFkeSBpbiBmbGlnaHQgdG8gdGhlIHNhbWUgVVJMXG4gICAgaWYgKGdsb2JhbE11dGFibGUucGVuZGluZ01wYVBhdGggIT09IGNhbm9uaWNhbFVybCkge1xuICAgICAgY29uc3QgbG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb25cbiAgICAgIGlmIChwdXNoUmVmLnBlbmRpbmdQdXNoKSB7XG4gICAgICAgIGxvY2F0aW9uLmFzc2lnbihjYW5vbmljYWxVcmwpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2NhdGlvbi5yZXBsYWNlKGNhbm9uaWNhbFVybClcbiAgICAgIH1cblxuICAgICAgZ2xvYmFsTXV0YWJsZS5wZW5kaW5nTXBhUGF0aCA9IGNhbm9uaWNhbFVybFxuICAgIH1cbiAgICAvLyBUT0RPLUFQUDogU2hvdWxkIHdlIGxpc3RlbiB0byBuYXZpZ2F0ZWVycm9yIGhlcmUgdG8gY2F0Y2ggZmFpbGVkXG4gICAgLy8gbmF2aWdhdGlvbnMgc29tZWhvdz8gQW5kIHNob3VsZCB3ZSBjYWxsIHdpbmRvdy5zdG9wKCkgaWYgYSBTUEEgbmF2aWdhdGlvblxuICAgIC8vIHNob3VsZCBpbnRlcnJ1cHQgYW4gTVBBIG9uZT9cbiAgICAvLyBOT1RFOiBUaGlzIGlzIGludGVudGlvbmFsbHkgdXNpbmcgYHRocm93YCBpbnN0ZWFkIG9mIGB1c2VgIGJlY2F1c2Ugd2UncmVcbiAgICAvLyBpbnNpZGUgYW4gZXh0ZXJuYWxseSBtdXRhYmxlIGNvbmRpdGlvbiAocHVzaFJlZi5tcGFOYXZpZ2F0aW9uKSwgd2hpY2hcbiAgICAvLyB2aW9sYXRlcyB0aGUgcnVsZXMgb2YgaG9va3MuXG4gICAgdGhyb3cgdW5yZXNvbHZlZFRoZW5hYmxlXG4gIH1cblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IG9yaWdpbmFsUHVzaFN0YXRlID0gd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlLmJpbmQod2luZG93Lmhpc3RvcnkpXG4gICAgY29uc3Qgb3JpZ2luYWxSZXBsYWNlU3RhdGUgPSB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUuYmluZChcbiAgICAgIHdpbmRvdy5oaXN0b3J5XG4gICAgKVxuXG4gICAgLy8gRW5zdXJlIHRoZSBjYW5vbmljYWwgVVJMIGluIHRoZSBOZXh0LmpzIFJvdXRlciBpcyB1cGRhdGVkIHdoZW4gdGhlIFVSTCBpcyBjaGFuZ2VkIHNvIHRoYXQgYHVzZVBhdGhuYW1lYCBhbmQgYHVzZVNlYXJjaFBhcmFtc2AgaG9sZCB0aGUgcHVzaGVkIHZhbHVlcy5cbiAgICBjb25zdCBhcHBseVVybEZyb21IaXN0b3J5UHVzaFJlcGxhY2UgPSAoXG4gICAgICB1cmw6IHN0cmluZyB8IFVSTCB8IG51bGwgfCB1bmRlZmluZWRcbiAgICApID0+IHtcbiAgICAgIGNvbnN0IGhyZWYgPSB3aW5kb3cubG9jYXRpb24uaHJlZlxuICAgICAgY29uc3QgdHJlZTogRmxpZ2h0Um91dGVyU3RhdGUgfCB1bmRlZmluZWQgPVxuICAgICAgICB3aW5kb3cuaGlzdG9yeS5zdGF0ZT8uX19QUklWQVRFX05FWFRKU19JTlRFUk5BTFNfVFJFRVxuXG4gICAgICBzdGFydFRyYW5zaXRpb24oKCkgPT4ge1xuICAgICAgICBkaXNwYXRjaEFwcFJvdXRlckFjdGlvbih7XG4gICAgICAgICAgdHlwZTogQUNUSU9OX1JFU1RPUkUsXG4gICAgICAgICAgdXJsOiBuZXcgVVJMKHVybCA/PyBocmVmLCBocmVmKSxcbiAgICAgICAgICB0cmVlLFxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXRjaCBwdXNoU3RhdGUgdG8gZW5zdXJlIGV4dGVybmFsIGNoYW5nZXMgdG8gdGhlIGhpc3RvcnkgYXJlIHJlZmxlY3RlZCBpbiB0aGUgTmV4dC5qcyBSb3V0ZXIuXG4gICAgICogRW5zdXJlcyBOZXh0LmpzIGludGVybmFsIGhpc3Rvcnkgc3RhdGUgaXMgY29waWVkIHRvIHRoZSBuZXcgaGlzdG9yeSBlbnRyeS5cbiAgICAgKiBFbnN1cmVzIHVzZVBhdGhuYW1lIGFuZCB1c2VTZWFyY2hQYXJhbXMgaG9sZCB0aGUgbmV3bHkgcHJvdmlkZWQgdXJsLlxuICAgICAqL1xuICAgIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSA9IGZ1bmN0aW9uIHB1c2hTdGF0ZShcbiAgICAgIGRhdGE6IGFueSxcbiAgICAgIF91bnVzZWQ6IHN0cmluZyxcbiAgICAgIHVybD86IHN0cmluZyB8IFVSTCB8IG51bGxcbiAgICApOiB2b2lkIHtcbiAgICAgIC8vIEF2b2lkIGEgbG9vcCB3aGVuIE5leHQuanMgaW50ZXJuYWxzIHRyaWdnZXIgcHVzaFN0YXRlL3JlcGxhY2VTdGF0ZVxuICAgICAgaWYgKGRhdGE/Ll9fTkEgfHwgZGF0YT8uX04pIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsUHVzaFN0YXRlKGRhdGEsIF91bnVzZWQsIHVybClcbiAgICAgIH1cblxuICAgICAgZGF0YSA9IGNvcHlOZXh0SnNJbnRlcm5hbEhpc3RvcnlTdGF0ZShkYXRhKVxuXG4gICAgICBpZiAodXJsKSB7XG4gICAgICAgIGFwcGx5VXJsRnJvbUhpc3RvcnlQdXNoUmVwbGFjZSh1cmwpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvcmlnaW5hbFB1c2hTdGF0ZShkYXRhLCBfdW51c2VkLCB1cmwpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGF0Y2ggcmVwbGFjZVN0YXRlIHRvIGVuc3VyZSBleHRlcm5hbCBjaGFuZ2VzIHRvIHRoZSBoaXN0b3J5IGFyZSByZWZsZWN0ZWQgaW4gdGhlIE5leHQuanMgUm91dGVyLlxuICAgICAqIEVuc3VyZXMgTmV4dC5qcyBpbnRlcm5hbCBoaXN0b3J5IHN0YXRlIGlzIGNvcGllZCB0byB0aGUgbmV3IGhpc3RvcnkgZW50cnkuXG4gICAgICogRW5zdXJlcyB1c2VQYXRobmFtZSBhbmQgdXNlU2VhcmNoUGFyYW1zIGhvbGQgdGhlIG5ld2x5IHByb3ZpZGVkIHVybC5cbiAgICAgKi9cbiAgICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUgPSBmdW5jdGlvbiByZXBsYWNlU3RhdGUoXG4gICAgICBkYXRhOiBhbnksXG4gICAgICBfdW51c2VkOiBzdHJpbmcsXG4gICAgICB1cmw/OiBzdHJpbmcgfCBVUkwgfCBudWxsXG4gICAgKTogdm9pZCB7XG4gICAgICAvLyBBdm9pZCBhIGxvb3Agd2hlbiBOZXh0LmpzIGludGVybmFscyB0cmlnZ2VyIHB1c2hTdGF0ZS9yZXBsYWNlU3RhdGVcbiAgICAgIGlmIChkYXRhPy5fX05BIHx8IGRhdGE/Ll9OKSB7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbFJlcGxhY2VTdGF0ZShkYXRhLCBfdW51c2VkLCB1cmwpXG4gICAgICB9XG4gICAgICBkYXRhID0gY29weU5leHRKc0ludGVybmFsSGlzdG9yeVN0YXRlKGRhdGEpXG5cbiAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgYXBwbHlVcmxGcm9tSGlzdG9yeVB1c2hSZXBsYWNlKHVybClcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcmlnaW5hbFJlcGxhY2VTdGF0ZShkYXRhLCBfdW51c2VkLCB1cmwpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIHBvcHN0YXRlIGV2ZW50LCB0aGlzIGlzIHVzZWQgdG8gaGFuZGxlIGJhY2svZm9yd2FyZCBpbiB0aGUgYnJvd3Nlci5cbiAgICAgKiBCeSBkZWZhdWx0IGRpc3BhdGNoZXMgQUNUSU9OX1JFU1RPUkUsIGhvd2V2ZXIgaWYgdGhlIGhpc3RvcnkgZW50cnkgd2FzIG5vdCBwdXNoZWQvcmVwbGFjZWQgYnkgYXBwLXJvdXRlciBpdCB3aWxsIHJlbG9hZCB0aGUgcGFnZS5cbiAgICAgKiBUaGF0IGNhc2UgY2FuIGhhcHBlbiB3aGVuIHRoZSBvbGQgcm91dGVyIGluamVjdGVkIHRoZSBoaXN0b3J5IGVudHJ5LlxuICAgICAqL1xuICAgIGNvbnN0IG9uUG9wU3RhdGUgPSAoZXZlbnQ6IFBvcFN0YXRlRXZlbnQpID0+IHtcbiAgICAgIGlmICghZXZlbnQuc3RhdGUpIHtcbiAgICAgICAgLy8gVE9ETy1BUFA6IHRoaXMgY2FzZSBvbmx5IGhhcHBlbnMgd2hlbiBwdXNoU3RhdGUvcmVwbGFjZVN0YXRlIHdhcyBjYWxsZWQgb3V0c2lkZSBvZiBOZXh0LmpzLiBJdCBzaG91bGQgcHJvYmFibHkgcmVsb2FkIHRoZSBwYWdlIGluIHRoaXMgY2FzZS5cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIFRoaXMgY2FzZSBoYXBwZW5zIHdoZW4gdGhlIGhpc3RvcnkgZW50cnkgd2FzIHB1c2hlZCBieSB0aGUgYHBhZ2VzYCByb3V0ZXIuXG4gICAgICBpZiAoIWV2ZW50LnN0YXRlLl9fTkEpIHtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyBUT0RPLUFQUDogSWRlYWxseSB0aGUgYmFjayBidXR0b24gc2hvdWxkIG5vdCB1c2Ugc3RhcnRUcmFuc2l0aW9uIGFzIGl0IHNob3VsZCBhcHBseSB0aGUgdXBkYXRlcyBzeW5jaHJvbm91c2x5XG4gICAgICAvLyBXaXRob3V0IHN0YXJ0VHJhbnNpdGlvbiB3b3JrcyBpZiB0aGUgY2FjaGUgaXMgdGhlcmUgZm9yIHRoaXMgcGF0aFxuICAgICAgc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgICAgZGlzcGF0Y2hUcmF2ZXJzZUFjdGlvbihcbiAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZixcbiAgICAgICAgICBldmVudC5zdGF0ZS5fX1BSSVZBVEVfTkVYVEpTX0lOVEVSTkFMU19UUkVFXG4gICAgICAgIClcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gUmVnaXN0ZXIgcG9wc3RhdGUgZXZlbnQgdG8gY2FsbCBvblBvcHN0YXRlLlxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIG9uUG9wU3RhdGUpXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSA9IG9yaWdpbmFsUHVzaFN0YXRlXG4gICAgICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUgPSBvcmlnaW5hbFJlcGxhY2VTdGF0ZVxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgb25Qb3BTdGF0ZSlcbiAgICB9XG4gIH0sIFtdKVxuXG4gIGNvbnN0IHsgY2FjaGUsIHRyZWUsIG5leHRVcmwsIGZvY3VzQW5kU2Nyb2xsUmVmIH0gPSBzdGF0ZVxuXG4gIGNvbnN0IG1hdGNoaW5nSGVhZCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiBmaW5kSGVhZEluQ2FjaGUoY2FjaGUsIHRyZWVbMV0pXG4gIH0sIFtjYWNoZSwgdHJlZV0pXG5cbiAgLy8gQWRkIG1lbW9pemVkIHBhdGhQYXJhbXMgZm9yIHVzZVBhcmFtcy5cbiAgY29uc3QgcGF0aFBhcmFtcyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiBnZXRTZWxlY3RlZFBhcmFtcyh0cmVlKVxuICB9LCBbdHJlZV0pXG5cbiAgY29uc3QgbGF5b3V0Um91dGVyQ29udGV4dCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBwYXJlbnRUcmVlOiB0cmVlLFxuICAgICAgcGFyZW50Q2FjaGVOb2RlOiBjYWNoZSxcbiAgICAgIHBhcmVudFNlZ21lbnRQYXRoOiBudWxsLFxuICAgICAgLy8gUm9vdCBub2RlIGFsd2F5cyBoYXMgYHVybGBcbiAgICAgIC8vIFByb3ZpZGVkIGluIEFwcFRyZWVDb250ZXh0IHRvIGVuc3VyZSBpdCBjYW4gYmUgb3ZlcndyaXR0ZW4gaW4gbGF5b3V0LXJvdXRlclxuICAgICAgdXJsOiBjYW5vbmljYWxVcmwsXG4gICAgfVxuICB9LCBbdHJlZSwgY2FjaGUsIGNhbm9uaWNhbFVybF0pXG5cbiAgY29uc3QgZ2xvYmFsTGF5b3V0Um91dGVyQ29udGV4dCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICB0cmVlLFxuICAgICAgZm9jdXNBbmRTY3JvbGxSZWYsXG4gICAgICBuZXh0VXJsLFxuICAgIH1cbiAgfSwgW3RyZWUsIGZvY3VzQW5kU2Nyb2xsUmVmLCBuZXh0VXJsXSlcblxuICBsZXQgaGVhZFxuICBpZiAobWF0Y2hpbmdIZWFkICE9PSBudWxsKSB7XG4gICAgLy8gVGhlIGhlYWQgaXMgd3JhcHBlZCBpbiBhbiBleHRyYSBjb21wb25lbnQgc28gd2UgY2FuIHVzZVxuICAgIC8vIGB1c2VEZWZlcnJlZFZhbHVlYCB0byBzd2FwIGJldHdlZW4gdGhlIHByZWZldGNoZWQgYW5kIGZpbmFsIHZlcnNpb25zIG9mXG4gICAgLy8gdGhlIGhlYWQuIChUaGlzIGlzIHdoYXQgTGF5b3V0Um91dGVyIGRvZXMgZm9yIHNlZ21lbnQgZGF0YSwgdG9vLilcbiAgICAvL1xuICAgIC8vIFRoZSBga2V5YCBpcyB1c2VkIHRvIHJlbW91bnQgdGhlIGNvbXBvbmVudCB3aGVuZXZlciB0aGUgaGVhZCBtb3ZlcyB0b1xuICAgIC8vIGEgZGlmZmVyZW50IHNlZ21lbnQuXG4gICAgY29uc3QgW2hlYWRDYWNoZU5vZGUsIGhlYWRLZXldID0gbWF0Y2hpbmdIZWFkXG4gICAgaGVhZCA9IDxIZWFkIGtleT17aGVhZEtleX0gaGVhZENhY2hlTm9kZT17aGVhZENhY2hlTm9kZX0gLz5cbiAgfSBlbHNlIHtcbiAgICBoZWFkID0gbnVsbFxuICB9XG5cbiAgbGV0IGNvbnRlbnQgPSAoXG4gICAgPFJlZGlyZWN0Qm91bmRhcnk+XG4gICAgICB7aGVhZH1cbiAgICAgIHtjYWNoZS5yc2N9XG4gICAgICA8QXBwUm91dGVyQW5ub3VuY2VyIHRyZWU9e3RyZWV9IC8+XG4gICAgPC9SZWRpcmVjdEJvdW5kYXJ5PlxuICApXG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBJbiBkZXZlbG9wbWVudCwgd2UgYXBwbHkgZmV3IGVycm9yIGJvdW5kYXJpZXMgYW5kIGhvdC1yZWxvYWRlcjpcbiAgICAvLyAtIERldlJvb3RIVFRQQWNjZXNzRmFsbGJhY2tCb3VuZGFyeTogYXZvaWQgdXNpbmcgbmF2aWdhdGlvbiBBUEkgbGlrZSBub3RGb3VuZCgpIGluIHJvb3QgbGF5b3V0XG4gICAgLy8gLSBIb3RSZWxvYWRlcjpcbiAgICAvLyAgLSBob3QtcmVsb2FkIHRoZSBhcHAgd2hlbiB0aGUgY29kZSBjaGFuZ2VzXG4gICAgLy8gIC0gcmVuZGVyIGRldiBvdmVybGF5XG4gICAgLy8gIC0gY2F0Y2ggcnVudGltZSBlcnJvcnMgYW5kIGRpc3BsYXkgZ2xvYmFsLWVycm9yIHdoZW4gbmVjZXNzYXJ5XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zdCB7IERldlJvb3RIVFRQQWNjZXNzRmFsbGJhY2tCb3VuZGFyeSB9ID1cbiAgICAgICAgcmVxdWlyZSgnLi9kZXYtcm9vdC1odHRwLWFjY2Vzcy1mYWxsYmFjay1ib3VuZGFyeScpIGFzIHR5cGVvZiBpbXBvcnQoJy4vZGV2LXJvb3QtaHR0cC1hY2Nlc3MtZmFsbGJhY2stYm91bmRhcnknKVxuICAgICAgY29udGVudCA9IChcbiAgICAgICAgPERldlJvb3RIVFRQQWNjZXNzRmFsbGJhY2tCb3VuZGFyeT5cbiAgICAgICAgICB7Y29udGVudH1cbiAgICAgICAgPC9EZXZSb290SFRUUEFjY2Vzc0ZhbGxiYWNrQm91bmRhcnk+XG4gICAgICApXG4gICAgfVxuICAgIGNvbnN0IEhvdFJlbG9hZGVyOiB0eXBlb2YgaW1wb3J0KCcuLi9kZXYvaG90LXJlbG9hZGVyL2FwcC9ob3QtcmVsb2FkZXItYXBwJykuZGVmYXVsdCA9XG4gICAgICAoXG4gICAgICAgIHJlcXVpcmUoJy4uL2Rldi9ob3QtcmVsb2FkZXIvYXBwL2hvdC1yZWxvYWRlci1hcHAnKSBhcyB0eXBlb2YgaW1wb3J0KCcuLi9kZXYvaG90LXJlbG9hZGVyL2FwcC9ob3QtcmVsb2FkZXItYXBwJylcbiAgICAgICkuZGVmYXVsdFxuXG4gICAgY29udGVudCA9IChcbiAgICAgIDxIb3RSZWxvYWRlciBhc3NldFByZWZpeD17YXNzZXRQcmVmaXh9IGdsb2JhbEVycm9yPXtnbG9iYWxFcnJvcn0+XG4gICAgICAgIHtjb250ZW50fVxuICAgICAgPC9Ib3RSZWxvYWRlcj5cbiAgICApXG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgZ3JhY2VmdWxseSBkZWdyYWRpbmcgaXMgYXBwbGllZCBpbiBwcm9kdWN0aW9uLFxuICAgIC8vIGxlYXZlIHRoZSBhcHAgYXMgaXQgaXMgcmF0aGVyIHRoYW4gY2F1Z2h0IGJ5IEdsb2JhbEVycm9yIGJvdW5kYXJ5LlxuICAgIGlmIChncmFjZWZ1bGx5RGVncmFkZSkge1xuICAgICAgY29udGVudCA9IDxHcmFjZWZ1bERlZ3JhZGVCb3VuZGFyeT57Y29udGVudH08L0dyYWNlZnVsRGVncmFkZUJvdW5kYXJ5PlxuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZW50ID0gKFxuICAgICAgICA8RXJyb3JCb3VuZGFyeVxuICAgICAgICAgIGVycm9yQ29tcG9uZW50PXtnbG9iYWxFcnJvclswXX1cbiAgICAgICAgICBlcnJvclN0eWxlcz17Z2xvYmFsRXJyb3JbMV19XG4gICAgICAgID5cbiAgICAgICAgICB7Y29udGVudH1cbiAgICAgICAgPC9FcnJvckJvdW5kYXJ5PlxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPD5cbiAgICAgIDxIaXN0b3J5VXBkYXRlciBhcHBSb3V0ZXJTdGF0ZT17c3RhdGV9IC8+XG4gICAgICA8UnVudGltZVN0eWxlcyAvPlxuICAgICAgPFBhdGhQYXJhbXNDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtwYXRoUGFyYW1zfT5cbiAgICAgICAgPFBhdGhuYW1lQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17cGF0aG5hbWV9PlxuICAgICAgICAgIDxTZWFyY2hQYXJhbXNDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtzZWFyY2hQYXJhbXN9PlxuICAgICAgICAgICAgPEdsb2JhbExheW91dFJvdXRlckNvbnRleHQuUHJvdmlkZXJcbiAgICAgICAgICAgICAgdmFsdWU9e2dsb2JhbExheW91dFJvdXRlckNvbnRleHR9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIHsvKiBUT0RPOiBXZSBzaG91bGQgYmUgYWJsZSB0byByZW1vdmUgdGhpcyBjb250ZXh0LiB1c2VSb3V0ZXJcbiAgICAgICAgICAgICAgICAgIHNob3VsZCBpbXBvcnQgZnJvbSBhcHAtcm91dGVyLWluc3RhbmNlIGluc3RlYWQuIEl0J3Mgb25seVxuICAgICAgICAgICAgICAgICAgbmVjZXNzYXJ5IGJlY2F1c2UgdXNlUm91dGVyIGlzIHNoYXJlZCBiZXR3ZWVuIFBhZ2VzIGFuZFxuICAgICAgICAgICAgICAgICAgQXBwIFJvdXRlci4gV2Ugc2hvdWxkIGZvcmsgdGhhdCBtb2R1bGUsIHRoZW4gcmVtb3ZlIHRoaXNcbiAgICAgICAgICAgICAgICAgIGNvbnRleHQgcHJvdmlkZXIuICovfVxuICAgICAgICAgICAgICA8QXBwUm91dGVyQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17cHVibGljQXBwUm91dGVySW5zdGFuY2V9PlxuICAgICAgICAgICAgICAgIDxMYXlvdXRSb3V0ZXJDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtsYXlvdXRSb3V0ZXJDb250ZXh0fT5cbiAgICAgICAgICAgICAgICAgIHtjb250ZW50fVxuICAgICAgICAgICAgICAgIDwvTGF5b3V0Um91dGVyQ29udGV4dC5Qcm92aWRlcj5cbiAgICAgICAgICAgICAgPC9BcHBSb3V0ZXJDb250ZXh0LlByb3ZpZGVyPlxuICAgICAgICAgICAgPC9HbG9iYWxMYXlvdXRSb3V0ZXJDb250ZXh0LlByb3ZpZGVyPlxuICAgICAgICAgIDwvU2VhcmNoUGFyYW1zQ29udGV4dC5Qcm92aWRlcj5cbiAgICAgICAgPC9QYXRobmFtZUNvbnRleHQuUHJvdmlkZXI+XG4gICAgICA8L1BhdGhQYXJhbXNDb250ZXh0LlByb3ZpZGVyPlxuICAgIDwvPlxuICApXG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEFwcFJvdXRlcih7XG4gIGFjdGlvblF1ZXVlLFxuICBnbG9iYWxFcnJvclN0YXRlLFxuICBhc3NldFByZWZpeCxcbiAgZ3JhY2VmdWxseURlZ3JhZGUsXG59OiB7XG4gIGFjdGlvblF1ZXVlOiBBcHBSb3V0ZXJBY3Rpb25RdWV1ZVxuICBnbG9iYWxFcnJvclN0YXRlOiBHbG9iYWxFcnJvclN0YXRlXG4gIGFzc2V0UHJlZml4OiBzdHJpbmdcbiAgZ3JhY2VmdWxseURlZ3JhZGU6IGJvb2xlYW5cbn0pIHtcbiAgdXNlTmF2RmFpbHVyZUhhbmRsZXIoKVxuXG4gIGNvbnN0IHJvdXRlciA9IChcbiAgICA8Um91dGVyXG4gICAgICBhY3Rpb25RdWV1ZT17YWN0aW9uUXVldWV9XG4gICAgICBhc3NldFByZWZpeD17YXNzZXRQcmVmaXh9XG4gICAgICBnbG9iYWxFcnJvcj17Z2xvYmFsRXJyb3JTdGF0ZX1cbiAgICAgIGdyYWNlZnVsbHlEZWdyYWRlPXtncmFjZWZ1bGx5RGVncmFkZX1cbiAgICAvPlxuICApXG5cbiAgaWYgKGdyYWNlZnVsbHlEZWdyYWRlKSB7XG4gICAgcmV0dXJuIHJvdXRlclxuICB9IGVsc2Uge1xuICAgIHJldHVybiAoXG4gICAgICA8RXJyb3JCb3VuZGFyeVxuICAgICAgICAvLyBBdCB0aGUgdmVyeSB0b3AgbGV2ZWwsIHVzZSB0aGUgZGVmYXVsdCBHbG9iYWxFcnJvciBjb21wb25lbnQgYXMgdGhlIGZpbmFsIGZhbGxiYWNrLlxuICAgICAgICAvLyBXaGVuIHRoZSBhcHAgcm91dGVyIGl0c2VsZiBmYWlscywgd2hpY2ggbWVhbnMgdGhlIGZyYW1ld29yayBpdHNlbGYgZmFpbHMsIHdlIHNob3cgdGhlIGRlZmF1bHQgZXJyb3IuXG4gICAgICAgIGVycm9yQ29tcG9uZW50PXtEZWZhdWx0R2xvYmFsRXJyb3J9XG4gICAgICA+XG4gICAgICAgIHtyb3V0ZXJ9XG4gICAgICA8L0Vycm9yQm91bmRhcnk+XG4gICAgKVxuICB9XG59XG5cbmNvbnN0IHJ1bnRpbWVTdHlsZXMgPSBuZXcgU2V0PHN0cmluZz4oKVxubGV0IHJ1bnRpbWVTdHlsZUNoYW5nZWQgPSBuZXcgU2V0PCgpID0+IHZvaWQ+KClcblxuZ2xvYmFsVGhpcy5fTl9FX1NUWUxFX0xPQUQgPSBmdW5jdGlvbiAoaHJlZjogc3RyaW5nKSB7XG4gIGxldCBsZW4gPSBydW50aW1lU3R5bGVzLnNpemVcbiAgcnVudGltZVN0eWxlcy5hZGQoaHJlZilcbiAgaWYgKHJ1bnRpbWVTdHlsZXMuc2l6ZSAhPT0gbGVuKSB7XG4gICAgcnVudGltZVN0eWxlQ2hhbmdlZC5mb3JFYWNoKChjYikgPT4gY2IoKSlcbiAgfVxuICAvLyBUT0RPIGZpZ3VyZSBvdXQgaG93IHRvIGdldCBhIHByb21pc2UgaGVyZVxuICAvLyBCdXQgbWF5YmUgaXQncyBub3QgbmVjZXNzYXJ5IGFzIHJlYWN0IHdvdWxkIGJsb2NrIHJlbmRlcmluZyB1bnRpbCBpdCdzIGxvYWRlZFxuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbn1cblxuZnVuY3Rpb24gUnVudGltZVN0eWxlcygpIHtcbiAgY29uc3QgWywgZm9yY2VVcGRhdGVdID0gUmVhY3QudXNlU3RhdGUoMClcbiAgY29uc3QgcmVuZGVyZWRTdHlsZXNTaXplID0gcnVudGltZVN0eWxlcy5zaXplXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgY2hhbmdlZCA9ICgpID0+IGZvcmNlVXBkYXRlKChjKSA9PiBjICsgMSlcbiAgICBydW50aW1lU3R5bGVDaGFuZ2VkLmFkZChjaGFuZ2VkKVxuICAgIGlmIChyZW5kZXJlZFN0eWxlc1NpemUgIT09IHJ1bnRpbWVTdHlsZXMuc2l6ZSkge1xuICAgICAgY2hhbmdlZCgpXG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBydW50aW1lU3R5bGVDaGFuZ2VkLmRlbGV0ZShjaGFuZ2VkKVxuICAgIH1cbiAgfSwgW3JlbmRlcmVkU3R5bGVzU2l6ZSwgZm9yY2VVcGRhdGVdKVxuXG4gIGNvbnN0IGRwbElkID0gcHJvY2Vzcy5lbnYuTkVYVF9ERVBMT1lNRU5UX0lEXG4gICAgPyBgP2RwbD0ke3Byb2Nlc3MuZW52Lk5FWFRfREVQTE9ZTUVOVF9JRH1gXG4gICAgOiAnJ1xuICByZXR1cm4gWy4uLnJ1bnRpbWVTdHlsZXNdLm1hcCgoaHJlZiwgaSkgPT4gKFxuICAgIDxsaW5rXG4gICAgICBrZXk9e2l9XG4gICAgICByZWw9XCJzdHlsZXNoZWV0XCJcbiAgICAgIGhyZWY9e2Ake2hyZWZ9JHtkcGxJZH1gfVxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgcHJlY2VkZW5jZT1cIm5leHRcIlxuICAgICAgLy8gVE9ETyBmaWd1cmUgb3V0IGNyb3NzT3JpZ2luIGFuZCBub25jZVxuICAgICAgLy8gY3Jvc3NPcmlnaW49e1RPRE99XG4gICAgICAvLyBub25jZT17VE9ET31cbiAgICAvPlxuICApKVxufVxuIl0sIm5hbWVzIjpbImNyZWF0ZUVtcHR5Q2FjaGVOb2RlIiwiY3JlYXRlUHJlZmV0Y2hVUkwiLCJBcHBSb3V0ZXIiLCJpc0V4dGVybmFsVVJMIiwiZ2xvYmFsTXV0YWJsZSIsInVybCIsIm9yaWdpbiIsIndpbmRvdyIsImxvY2F0aW9uIiwiaHJlZiIsImlzQm90IiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiVVJMIiwiYWRkQmFzZVBhdGgiLCJfIiwiRXJyb3IiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJIaXN0b3J5VXBkYXRlciIsImFwcFJvdXRlclN0YXRlIiwidXNlSW5zZXJ0aW9uRWZmZWN0IiwiX19ORVhUX0FQUF9OQVZfRkFJTF9IQU5ETElORyIsIm5leHQiLCJfX3BlbmRpbmdVcmwiLCJ1bmRlZmluZWQiLCJ0cmVlIiwicHVzaFJlZiIsImNhbm9uaWNhbFVybCIsImhpc3RvcnlTdGF0ZSIsInByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlIiwiaGlzdG9yeSIsInN0YXRlIiwiX19OQSIsIl9fUFJJVkFURV9ORVhUSlNfSU5URVJOQUxTX1RSRUUiLCJwZW5kaW5nUHVzaCIsImNyZWF0ZUhyZWZGcm9tVXJsIiwicHVzaFN0YXRlIiwicmVwbGFjZVN0YXRlIiwidXNlRWZmZWN0IiwiX19ORVhUX0NMSUVOVF9TRUdNRU5UX0NBQ0hFIiwicGluZ1Zpc2libGVMaW5rcyIsIm5leHRVcmwiLCJsYXp5RGF0YSIsInJzYyIsInByZWZldGNoUnNjIiwiaGVhZCIsInByZWZldGNoSGVhZCIsInBhcmFsbGVsUm91dGVzIiwiTWFwIiwibG9hZGluZyIsIm5hdmlnYXRlZEF0IiwiY29weU5leHRKc0ludGVybmFsSGlzdG9yeVN0YXRlIiwiZGF0YSIsImN1cnJlbnRTdGF0ZSIsIkhlYWQiLCJoZWFkQ2FjaGVOb2RlIiwicmVzb2x2ZWRQcmVmZXRjaFJzYyIsInVzZURlZmVycmVkVmFsdWUiLCJSb3V0ZXIiLCJhY3Rpb25RdWV1ZSIsImFzc2V0UHJlZml4IiwiZ2xvYmFsRXJyb3IiLCJncmFjZWZ1bGx5RGVncmFkZSIsInVzZUFjdGlvblF1ZXVlIiwic2VhcmNoUGFyYW1zIiwicGF0aG5hbWUiLCJ1c2VNZW1vIiwiaGFzQmFzZVBhdGgiLCJyZW1vdmVCYXNlUGF0aCIsImNhY2hlIiwicHJlZmV0Y2hDYWNoZSIsIm5kIiwicm91dGVyIiwicHVibGljQXBwUm91dGVySW5zdGFuY2UiLCJoYW5kbGVQYWdlU2hvdyIsImV2ZW50IiwicGVyc2lzdGVkIiwicGVuZGluZ01wYVBhdGgiLCJkaXNwYXRjaEFwcFJvdXRlckFjdGlvbiIsInR5cGUiLCJBQ1RJT05fUkVTVE9SRSIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiaGFuZGxlVW5oYW5kbGVkUmVkaXJlY3QiLCJlcnJvciIsInJlYXNvbiIsImlzUmVkaXJlY3RFcnJvciIsInByZXZlbnREZWZhdWx0IiwiZ2V0VVJMRnJvbVJlZGlyZWN0RXJyb3IiLCJyZWRpcmVjdFR5cGUiLCJnZXRSZWRpcmVjdFR5cGVGcm9tRXJyb3IiLCJSZWRpcmVjdFR5cGUiLCJwdXNoIiwicmVwbGFjZSIsIm1wYU5hdmlnYXRpb24iLCJhc3NpZ24iLCJ1bnJlc29sdmVkVGhlbmFibGUiLCJvcmlnaW5hbFB1c2hTdGF0ZSIsImJpbmQiLCJvcmlnaW5hbFJlcGxhY2VTdGF0ZSIsImFwcGx5VXJsRnJvbUhpc3RvcnlQdXNoUmVwbGFjZSIsInN0YXJ0VHJhbnNpdGlvbiIsIl91bnVzZWQiLCJfTiIsIm9uUG9wU3RhdGUiLCJyZWxvYWQiLCJkaXNwYXRjaFRyYXZlcnNlQWN0aW9uIiwiZm9jdXNBbmRTY3JvbGxSZWYiLCJtYXRjaGluZ0hlYWQiLCJmaW5kSGVhZEluQ2FjaGUiLCJwYXRoUGFyYW1zIiwiZ2V0U2VsZWN0ZWRQYXJhbXMiLCJsYXlvdXRSb3V0ZXJDb250ZXh0IiwicGFyZW50VHJlZSIsInBhcmVudENhY2hlTm9kZSIsInBhcmVudFNlZ21lbnRQYXRoIiwiZ2xvYmFsTGF5b3V0Um91dGVyQ29udGV4dCIsImhlYWRLZXkiLCJjb250ZW50IiwiUmVkaXJlY3RCb3VuZGFyeSIsIkFwcFJvdXRlckFubm91bmNlciIsIkRldlJvb3RIVFRQQWNjZXNzRmFsbGJhY2tCb3VuZGFyeSIsInJlcXVpcmUiLCJIb3RSZWxvYWRlciIsImRlZmF1bHQiLCJHcmFjZWZ1bERlZ3JhZGVCb3VuZGFyeSIsIkVycm9yQm91bmRhcnkiLCJlcnJvckNvbXBvbmVudCIsImVycm9yU3R5bGVzIiwiUnVudGltZVN0eWxlcyIsIlBhdGhQYXJhbXNDb250ZXh0IiwiUHJvdmlkZXIiLCJ2YWx1ZSIsIlBhdGhuYW1lQ29udGV4dCIsIlNlYXJjaFBhcmFtc0NvbnRleHQiLCJHbG9iYWxMYXlvdXRSb3V0ZXJDb250ZXh0IiwiQXBwUm91dGVyQ29udGV4dCIsIkxheW91dFJvdXRlckNvbnRleHQiLCJnbG9iYWxFcnJvclN0YXRlIiwidXNlTmF2RmFpbHVyZUhhbmRsZXIiLCJEZWZhdWx0R2xvYmFsRXJyb3IiLCJydW50aW1lU3R5bGVzIiwiU2V0IiwicnVudGltZVN0eWxlQ2hhbmdlZCIsImdsb2JhbFRoaXMiLCJfTl9FX1NUWUxFX0xPQUQiLCJsZW4iLCJzaXplIiwiYWRkIiwiZm9yRWFjaCIsImNiIiwiUHJvbWlzZSIsInJlc29sdmUiLCJmb3JjZVVwZGF0ZSIsIlJlYWN0IiwidXNlU3RhdGUiLCJyZW5kZXJlZFN0eWxlc1NpemUiLCJjaGFuZ2VkIiwiYyIsImRlbGV0ZSIsImRwbElkIiwiTkVYVF9ERVBMT1lNRU5UX0lEIiwibWFwIiwiaSIsImxpbmsiLCJyZWwiLCJwcmVjZWRlbmNlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0lBNklnQkEsb0JBQW9CLEVBQUE7ZUFBcEJBOztJQTlFQUMsaUJBQWlCLEVBQUE7ZUFBakJBOztJQW9maEIsT0FtQ0MsRUFBQTtlQW5DdUJDOztJQS9mUkMsYUFBYSxFQUFBO2VBQWJBOzs7Ozs7aUVBNUNUOytDQUtBO29DQUV3QjttQ0FFRztpREFLM0I7Z0NBQ2lEOytCQUMxQjtzRUFDQzt1QkFDVDs2QkFDTTtvQ0FDTztrQ0FDRjtpQ0FDRDtvQ0FDRztnQ0FDSjs2QkFDSDtvQ0FDTTttQ0FFRzttQ0FNOUI7MEJBQzJEOytCQUNwQjt1QkFDYjtrRkFDRztBQUVwQyxNQUFNQyxnQkFFRixDQUFDO0FBRUUsU0FBU0QsY0FBY0UsR0FBUTtJQUNwQyxPQUFPQSxJQUFJQyxNQUFNLEtBQUtDLE9BQU9DLFFBQVEsQ0FBQ0YsTUFBTTtBQUM5QztBQVNPLFNBQVNMLGtCQUFrQlEsSUFBWTtJQUM1QyxrREFBa0Q7SUFDbEQsSUFBSUMsQ0FBQUEsR0FBQUEsT0FBQUEsS0FBSyxFQUFDSCxPQUFPSSxTQUFTLENBQUND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Y29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3Bwci1uYXZpZ2F0aW9ucy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7XG4gIENhY2hlTm9kZVNlZWREYXRhLFxuICBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgRmxpZ2h0U2VnbWVudFBhdGgsXG4gIFNlZ21lbnQsXG59IGZyb20gJy4uLy4uLy4uL3NlcnZlci9hcHAtcmVuZGVyL3R5cGVzJ1xuaW1wb3J0IHR5cGUge1xuICBDYWNoZU5vZGUsXG4gIENoaWxkU2VnbWVudE1hcCxcbiAgSGVhZERhdGEsXG4gIExvYWRpbmdNb2R1bGVEYXRhLFxuICBSZWFkeUNhY2hlTm9kZSxcbn0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgeyBERUZBVUxUX1NFR01FTlRfS0VZIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2xpYi9zZWdtZW50J1xuaW1wb3J0IHsgbWF0Y2hTZWdtZW50IH0gZnJvbSAnLi4vbWF0Y2gtc2VnbWVudHMnXG5pbXBvcnQgeyBjcmVhdGVSb3V0ZXJDYWNoZUtleSB9IGZyb20gJy4vY3JlYXRlLXJvdXRlci1jYWNoZS1rZXknXG5pbXBvcnQgdHlwZSB7IEZldGNoU2VydmVyUmVzcG9uc2VSZXN1bHQgfSBmcm9tICcuL2ZldGNoLXNlcnZlci1yZXNwb25zZSdcbmltcG9ydCB7IGlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dCB9IGZyb20gJy4vaXMtbmF2aWdhdGluZy10by1uZXctcm9vdC1sYXlvdXQnXG5pbXBvcnQgeyBEWU5BTUlDX1NUQUxFVElNRV9NUyB9IGZyb20gJy4vcHJlZmV0Y2gtY2FjaGUtdXRpbHMnXG5cbi8vIFRoaXMgaXMgeWV0IGFub3RoZXIgdHJlZSB0eXBlIHRoYXQgaXMgdXNlZCB0byB0cmFjayBwZW5kaW5nIHByb21pc2VzIHRoYXRcbi8vIG5lZWQgdG8gYmUgZnVsZmlsbGVkIG9uY2UgdGhlIGR5bmFtaWMgZGF0YSBpcyByZWNlaXZlZC4gVGhlIHRlcm1pbmFsIG5vZGVzIG9mXG4vLyB0aGlzIHRyZWUgcmVwcmVzZW50IHRoZSBuZXcgQ2FjaGUgTm9kZSB0cmVlcyB0aGF0IHdlcmUgY3JlYXRlZCBkdXJpbmcgdGhpc1xuLy8gcmVxdWVzdC4gV2UgY2FuJ3QgdXNlIHRoZSBDYWNoZSBOb2RlIHRyZWUgb3IgUm91dGUgU3RhdGUgdHJlZSBkaXJlY3RseVxuLy8gYmVjYXVzZSB0aG9zZSBpbmNsdWRlIHJldXNlZCBub2RlcywgdG9vLiBUaGlzIHRyZWUgaXMgZGlzY2FyZGVkIGFzIHNvb24gYXNcbi8vIHRoZSBuYXZpZ2F0aW9uIHJlc3BvbnNlIGlzIHJlY2VpdmVkLlxudHlwZSBTUEFOYXZpZ2F0aW9uVGFzayA9IHtcbiAgLy8gVGhlIHJvdXRlciBzdGF0ZSB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZSB0cmVlIHRoYXQgdGhpcyBUYXNrIHJlcHJlc2VudHMuXG4gIHJvdXRlOiBGbGlnaHRSb3V0ZXJTdGF0ZVxuICAvLyBUaGUgQ2FjaGVOb2RlIHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlIHRyZWUgdGhhdCB0aGlzIFRhc2sgcmVwcmVzZW50cy4gSWZcbiAgLy8gYGNoaWxkcmVuYCBpcyBudWxsIChpLmUuIGlmIHRoaXMgaXMgYSB0ZXJtaW5hbCB0YXNrIG5vZGUpLCB0aGVuIGBub2RlYFxuICAvLyByZXByZXNlbnRzIGEgYnJhbmQgbmV3IENhY2hlIE5vZGUgdHJlZSwgd2hpY2ggd2F5IG9yIG1heSBub3QgbmVlZCB0byBiZVxuICAvLyBmaWxsZWQgd2l0aCBkeW5hbWljIGRhdGEgZnJvbSB0aGUgc2VydmVyLlxuICBub2RlOiBDYWNoZU5vZGUgfCBudWxsXG4gIC8vIFRoZSB0cmVlIHNlbnQgdG8gdGhlIHNlcnZlciBkdXJpbmcgdGhlIGR5bmFtaWMgcmVxdWVzdC4gVGhpcyBpcyB0aGVcbiAgLy8gc2FtZSBhcyBgcm91dGVgLCBleGNlcHQgd2l0aCB0aGUgYHJlZmV0Y2hgIG1hcmtlciBzZXQgb24gZHluYW1pYyBzZWdtZW50cy5cbiAgLy8gSWYgYWxsIHRoZSBzZWdtZW50cyBhcmUgc3RhdGljLCB0aGVuIHRoaXMgd2lsbCBiZSBudWxsLCBhbmQgbm8gc2VydmVyXG4gIC8vIHJlcXVlc3QgaXMgcmVxdWlyZWQuXG4gIGR5bmFtaWNSZXF1ZXN0VHJlZTogRmxpZ2h0Um91dGVyU3RhdGUgfCBudWxsXG4gIGNoaWxkcmVuOiBNYXA8c3RyaW5nLCBTUEFOYXZpZ2F0aW9uVGFzaz4gfCBudWxsXG59XG5cbi8vIEEgc3BlY2lhbCB0eXBlIHVzZWQgdG8gYmFpbCBvdXQgYW5kIHRyaWdnZXIgYSBmdWxsLXBhZ2UgbmF2aWdhdGlvbi5cbnR5cGUgTVBBTmF2aWdhdGlvblRhc2sgPSB7XG4gIC8vIE1QQSB0YXNrcyBhcmUgZGlzdGluZ3Vpc2VkIGZyb20gU1BBIHRhc2tzIGJ5IGhhdmluZyBhIG51bGwgYHJvdXRlYC5cbiAgcm91dGU6IG51bGxcbiAgbm9kZTogbnVsbFxuICBkeW5hbWljUmVxdWVzdFRyZWU6IG51bGxcbiAgY2hpbGRyZW46IG51bGxcbn1cblxuY29uc3QgTVBBX05BVklHQVRJT05fVEFTSzogTVBBTmF2aWdhdGlvblRhc2sgPSB7XG4gIHJvdXRlOiBudWxsLFxuICBub2RlOiBudWxsLFxuICBkeW5hbWljUmVxdWVzdFRyZWU6IG51bGwsXG4gIGNoaWxkcmVuOiBudWxsLFxufVxuXG5leHBvcnQgdHlwZSBUYXNrID0gU1BBTmF2aWdhdGlvblRhc2sgfCBNUEFOYXZpZ2F0aW9uVGFza1xuXG4vLyBDcmVhdGVzIGEgbmV3IENhY2hlIE5vZGUgdHJlZSAoaS5lLiBjb3B5LW9uLXdyaXRlKSB0aGF0IHJlcHJlc2VudHMgdGhlXG4vLyBvcHRpbWlzdGljIHJlc3VsdCBvZiBhIG5hdmlnYXRpb24sIHVzaW5nIGJvdGggdGhlIGN1cnJlbnQgQ2FjaGUgTm9kZSB0cmVlIGFuZFxuLy8gZGF0YSB0aGF0IHdhcyBwcmVmZXRjaGVkIHByaW9yIHRvIG5hdmlnYXRpb24uXG4vL1xuLy8gQXQgdGhlIG1vbWVudCB3ZSBjYWxsIHRoaXMgZnVuY3Rpb24sIHdlIGhhdmVuJ3QgeWV0IHJlY2VpdmVkIHRoZSBuYXZpZ2F0aW9uXG4vLyByZXNwb25zZSBmcm9tIHRoZSBzZXJ2ZXIuIEl0IGNvdWxkIHNlbmQgYmFjayBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnRcbi8vIGZyb20gdGhlIHRyZWUgdGhhdCB3YXMgcHJlZmV0Y2hlZCDigJQgZHVlIHRvIHJld3JpdGVzLCBkZWZhdWx0IHJvdXRlcywgcGFyYWxsZWxcbi8vIHJvdXRlcywgZXRjLlxuLy9cbi8vIEJ1dCBpbiBtb3N0IGNhc2VzLCBpdCB3aWxsIHJldHVybiB0aGUgc2FtZSB0cmVlIHRoYXQgd2UgcHJlZmV0Y2hlZCwganVzdCB3aXRoXG4vLyB0aGUgZHluYW1pYyBob2xlcyBmaWxsZWQgaW4uIFNvIHdlIG9wdGltaXN0aWNhbGx5IGFzc3VtZSB0aGlzIHdpbGwgaGFwcGVuLFxuLy8gYW5kIGFjY2VwdCB0aGF0IHRoZSByZWFsIHJlc3VsdCBjb3VsZCBiZSBhcmJpdHJhcmlseSBkaWZmZXJlbnQuXG4vL1xuLy8gV2UnbGwgcmV1c2UgYW55dGhpbmcgdGhhdCB3YXMgYWxyZWFkeSBpbiB0aGUgcHJldmlvdXMgdHJlZSwgc2luY2UgdGhhdCdzIHdoYXRcbi8vIHRoZSBzZXJ2ZXIgZG9lcy5cbi8vXG4vLyBOZXcgc2VnbWVudHMgKG9uZXMgdGhhdCBkb24ndCBhcHBlYXIgaW4gdGhlIG9sZCB0cmVlKSBhcmUgYXNzaWduZWQgYW5cbi8vIHVucmVzb2x2ZWQgcHJvbWlzZS4gVGhlIGRhdGEgZm9yIHRoZXNlIHByb21pc2VzIHdpbGwgYmUgZnVsZmlsbGVkIGxhdGVyLCB3aGVuXG4vLyB0aGUgbmF2aWdhdGlvbiByZXNwb25zZSBpcyByZWNlaXZlZC5cbi8vXG4vLyBUaGUgdHJlZSBjYW4gYmUgcmVuZGVyZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgaXQgaXMgY3JlYXRlZCAodGhhdCdzIHdoeSB0aGlzIGlzXG4vLyBhIHN5bmNocm9ub3VzIGZ1bmN0aW9uKS4gQW55IG5ldyB0cmVlcyB0aGF0IGRvIG5vdCBoYXZlIHByZWZldGNoIGRhdGEgd2lsbFxuLy8gc3VzcGVuZCBkdXJpbmcgcmVuZGVyaW5nLCB1bnRpbCB0aGUgZHluYW1pYyBkYXRhIHN0cmVhbXMgaW4uXG4vL1xuLy8gUmV0dXJucyBhIFRhc2sgb2JqZWN0LCB3aGljaCBjb250YWlucyBib3RoIHRoZSB1cGRhdGVkIENhY2hlIE5vZGUgYW5kIGEgcGF0aFxuLy8gdG8gdGhlIHBlbmRpbmcgc3VidHJlZXMgdGhhdCBuZWVkIHRvIGJlIHJlc29sdmVkIGJ5IHRoZSBuYXZpZ2F0aW9uIHJlc3BvbnNlLlxuLy9cbi8vIEEgcmV0dXJuIHZhbHVlIG9mIGBudWxsYCBtZWFucyB0aGVyZSB3ZXJlIG5vIGNoYW5nZXMsIGFuZCB0aGUgcHJldmlvdXMgdHJlZVxuLy8gY2FuIGJlIHJldXNlZCB3aXRob3V0IGluaXRpYXRpbmcgYSBzZXJ2ZXIgcmVxdWVzdC5cbmV4cG9ydCBmdW5jdGlvbiBzdGFydFBQUk5hdmlnYXRpb24oXG4gIG5hdmlnYXRlZEF0OiBudW1iZXIsXG4gIG9sZENhY2hlTm9kZTogQ2FjaGVOb2RlLFxuICBvbGRSb3V0ZXJTdGF0ZTogRmxpZ2h0Um91dGVyU3RhdGUsXG4gIG5ld1JvdXRlclN0YXRlOiBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgcHJlZmV0Y2hEYXRhOiBDYWNoZU5vZGVTZWVkRGF0YSB8IG51bGwsXG4gIHByZWZldGNoSGVhZDogSGVhZERhdGEgfCBudWxsLFxuICBpc1ByZWZldGNoSGVhZFBhcnRpYWw6IGJvb2xlYW4sXG4gIGlzU2FtZVBhZ2VOYXZpZ2F0aW9uOiBib29sZWFuLFxuICBzY3JvbGxhYmxlU2VnbWVudHNSZXN1bHQ6IEFycmF5PEZsaWdodFNlZ21lbnRQYXRoPlxuKTogVGFzayB8IG51bGwge1xuICBjb25zdCBzZWdtZW50UGF0aDogQXJyYXk8RmxpZ2h0U2VnbWVudFBhdGg+ID0gW11cbiAgcmV0dXJuIHVwZGF0ZUNhY2hlTm9kZU9uTmF2aWdhdGlvbihcbiAgICBuYXZpZ2F0ZWRBdCxcbiAgICBvbGRDYWNoZU5vZGUsXG4gICAgb2xkUm91dGVyU3RhdGUsXG4gICAgbmV3Um91dGVyU3RhdGUsXG4gICAgZmFsc2UsXG4gICAgcHJlZmV0Y2hEYXRhLFxuICAgIHByZWZldGNoSGVhZCxcbiAgICBpc1ByZWZldGNoSGVhZFBhcnRpYWwsXG4gICAgaXNTYW1lUGFnZU5hdmlnYXRpb24sXG4gICAgc2VnbWVudFBhdGgsXG4gICAgc2Nyb2xsYWJsZVNlZ21lbnRzUmVzdWx0XG4gIClcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ2FjaGVOb2RlT25OYXZpZ2F0aW9uKFxuICBuYXZpZ2F0ZWRBdDogbnVtYmVyLFxuICBvbGRDYWNoZU5vZGU6IENhY2hlTm9kZSxcbiAgb2xkUm91dGVyU3RhdGU6IEZsaWdodFJvdXRlclN0YXRlLFxuICBuZXdSb3V0ZXJTdGF0ZTogRmxpZ2h0Um91dGVyU3RhdGUsXG4gIGRpZEZpbmRSb290TGF5b3V0OiBib29sZWFuLFxuICBwcmVmZXRjaERhdGE6IENhY2hlTm9kZVNlZWREYXRhIHwgbnVsbCxcbiAgcHJlZmV0Y2hIZWFkOiBIZWFkRGF0YSB8IG51bGwsXG4gIGlzUHJlZmV0Y2hIZWFkUGFydGlhbDogYm9vbGVhbixcbiAgaXNTYW1lUGFnZU5hdmlnYXRpb246IGJvb2xlYW4sXG4gIHNlZ21lbnRQYXRoOiBGbGlnaHRTZWdtZW50UGF0aCxcbiAgc2Nyb2xsYWJsZVNlZ21lbnRzUmVzdWx0OiBBcnJheTxGbGlnaHRTZWdtZW50UGF0aD5cbik6IFRhc2sgfCBudWxsIHtcbiAgLy8gRGlmZiB0aGUgb2xkIGFuZCBuZXcgdHJlZXMgdG8gcmV1c2UgdGhlIHNoYXJlZCBsYXlvdXRzLlxuICBjb25zdCBvbGRSb3V0ZXJTdGF0ZUNoaWxkcmVuID0gb2xkUm91dGVyU3RhdGVbMV1cbiAgY29uc3QgbmV3Um91dGVyU3RhdGVDaGlsZHJlbiA9IG5ld1JvdXRlclN0YXRlWzFdXG4gIGNvbnN0IHByZWZldGNoRGF0YUNoaWxkcmVuID0gcHJlZmV0Y2hEYXRhICE9PSBudWxsID8gcHJlZmV0Y2hEYXRhWzJdIDogbnVsbFxuXG4gIGlmICghZGlkRmluZFJvb3RMYXlvdXQpIHtcbiAgICAvLyBXZSdyZSBjdXJyZW50bHkgdHJhdmVyc2luZyB0aGUgcGFydCBvZiB0aGUgdHJlZSB0aGF0IHdhcyBhbHNvIHBhcnQgb2ZcbiAgICAvLyB0aGUgcHJldmlvdXMgcm91dGUuIElmIHdlIGRpc2NvdmVyIGEgcm9vdCBsYXlvdXQsIHRoZW4gd2UgZG9uJ3QgbmVlZCB0b1xuICAgIC8vIHRyaWdnZXIgYW4gTVBBIG5hdmlnYXRpb24uIFNlZSBiZWdpblJlbmRlcmluZ05ld1JvdXRlVHJlZSBmb3IgY29udGV4dC5cbiAgICBjb25zdCBpc1Jvb3RMYXlvdXQgPSBuZXdSb3V0ZXJTdGF0ZVs0XSA9PT0gdHJ1ZVxuICAgIGlmIChpc1Jvb3RMYXlvdXQpIHtcbiAgICAgIC8vIEZvdW5kIGEgbWF0Y2hpbmcgcm9vdCBsYXlvdXQuXG4gICAgICBkaWRGaW5kUm9vdExheW91dCA9IHRydWVcbiAgICB9XG4gIH1cblxuICBjb25zdCBvbGRQYXJhbGxlbFJvdXRlcyA9IG9sZENhY2hlTm9kZS5wYXJhbGxlbFJvdXRlc1xuXG4gIC8vIENsb25lIHRoZSBjdXJyZW50IHNldCBvZiBzZWdtZW50IGNoaWxkcmVuLCBldmVuIGlmIHRoZXkgYXJlbid0IGFjdGl2ZSBpblxuICAvLyB0aGUgbmV3IHRyZWUuXG4gIC8vIFRPRE86IFdlIGN1cnJlbnRseSByZXRhaW4gYWxsIHRoZSBpbmFjdGl2ZSBzZWdtZW50cyBpbmRlZmluaXRlbHksIHVudGlsXG4gIC8vIHRoZXJlJ3MgYW4gZXhwbGljaXQgcmVmcmVzaCwgb3IgYSBwYXJlbnQgbGF5b3V0IGlzIGxhemlseSByZWZyZXNoZWQuIFdlXG4gIC8vIHJlbHkgb24gdGhpcyBmb3IgcG9wc3RhdGUgbmF2aWdhdGlvbnMsIHdoaWNoIHVwZGF0ZSB0aGUgUm91dGVyIFN0YXRlIFRyZWVcbiAgLy8gYnV0IGRvIG5vdCBlYWdlcmx5IHBlcmZvcm0gYSBkYXRhIGZldGNoLCBiZWNhdXNlIHRoZXkgZXhwZWN0IHRoZSBzZWdtZW50XG4gIC8vIGRhdGEgdG8gYWxyZWFkeSBiZSBpbiB0aGUgQ2FjaGUgTm9kZSB0cmVlLiBGb3IgaGlnaGx5IHN0YXRpYyBzaXRlcyB0aGF0XG4gIC8vIGFyZSBtb3N0bHkgcmVhZC1vbmx5LCB0aGlzIG1heSBoYXBwZW4gb25seSByYXJlbHksIGNhdXNpbmcgbWVtb3J5IHRvXG4gIC8vIGxlYWsuIFdlIHNob3VsZCBmaWd1cmUgb3V0IGEgYmV0dGVyIG1vZGVsIGZvciB0aGUgbGlmZXRpbWUgb2YgaW5hY3RpdmVcbiAgLy8gc2VnbWVudHMsIHNvIHdlIGNhbiBtYWludGFpbiBpbnN0YW50IGJhY2svZm9yd2FyZCBuYXZpZ2F0aW9ucyB3aXRob3V0XG4gIC8vIGxlYWtpbmcgbWVtb3J5IGluZGVmaW5pdGVseS5cbiAgY29uc3QgcHJlZmV0Y2hQYXJhbGxlbFJvdXRlcyA9IG5ldyBNYXAob2xkUGFyYWxsZWxSb3V0ZXMpXG5cbiAgLy8gQXMgd2UgZGlmZiB0aGUgdHJlZXMsIHdlIG1heSBzb21ldGltZXMgbW9kaWZ5IChjb3B5LW9uLXdyaXRlLCBub3QgbXV0YXRlKVxuICAvLyB0aGUgUm91dGUgVHJlZSB0aGF0IHdhcyByZXR1cm5lZCBieSB0aGUgc2VydmVyIOKAlCBmb3IgZXhhbXBsZSwgaW4gdGhlIGNhc2VcbiAgLy8gb2YgZGVmYXVsdCBwYXJhbGxlbCByb3V0ZXMsIHdlIHByZXNlcnZlIHRoZSBjdXJyZW50bHkgYWN0aXZlIHNlZ21lbnQuIFRvXG4gIC8vIGF2b2lkIG11dGF0aW5nIHRoZSBvcmlnaW5hbCB0cmVlLCB3ZSBjbG9uZSB0aGUgcm91dGVyIHN0YXRlIGNoaWxkcmVuIGFsb25nXG4gIC8vIHRoZSByZXR1cm4gcGF0aC5cbiAgbGV0IHBhdGNoZWRSb3V0ZXJTdGF0ZUNoaWxkcmVuOiB7XG4gICAgW3BhcmFsbGVsUm91dGVLZXk6IHN0cmluZ106IEZsaWdodFJvdXRlclN0YXRlXG4gIH0gPSB7fVxuICBsZXQgdGFza0NoaWxkcmVuID0gbnVsbFxuXG4gIC8vIE1vc3QgbmF2aWdhdGlvbnMgcmVxdWlyZSBhIHJlcXVlc3QgdG8gZmV0Y2ggYWRkaXRpb25hbCBkYXRhIGZyb20gdGhlXG4gIC8vIHNlcnZlciwgZWl0aGVyIGJlY2F1c2UgdGhlIGRhdGEgd2FzIG5vdCBhbHJlYWR5IHByZWZldGNoZWQsIG9yIGJlY2F1c2UgdGhlXG4gIC8vIHRhcmdldCByb3V0ZSBjb250YWlucyBkeW5hbWljIGRhdGEgdGhhdCBjYW5ub3QgYmUgcHJlZmV0Y2hlZC5cbiAgLy9cbiAgLy8gSG93ZXZlciwgaWYgdGhlIHRhcmdldCByb3V0ZSBpcyBmdWxseSBzdGF0aWMsIGFuZCBpdCdzIGFscmVhZHkgY29tcGxldGVseVxuICAvLyBsb2FkZWQgaW50byB0aGUgc2VnbWVudCBjYWNoZSwgdGhlbiB3ZSBjYW4gc2tpcCB0aGUgc2VydmVyIHJlcXVlc3QuXG4gIC8vXG4gIC8vIFRoaXMgc3RhcnRzIG9mZiBhcyBgZmFsc2VgLCBhbmQgaXMgc2V0IHRvIGB0cnVlYCBpZiBhbnkgb2YgdGhlIGNoaWxkXG4gIC8vIHJvdXRlcyByZXF1aXJlcyBhIGR5bmFtaWMgcmVxdWVzdC5cbiAgbGV0IG5lZWRzRHluYW1pY1JlcXVlc3QgPSBmYWxzZVxuICAvLyBBcyB3ZSB0cmF2ZXJzZSB0aGUgY2hpbGRyZW4sIHdlJ2xsIGNvbnN0cnVjdCBhIEZsaWdodFJvdXRlclN0YXRlIHRoYXQgY2FuXG4gIC8vIGJlIHNlbnQgdG8gdGhlIHNlcnZlciB0byByZXF1ZXN0IHRoZSBkeW5hbWljIGRhdGEuIElmIGl0IHR1cm5zIG91dCB0aGF0XG4gIC8vIG5vdGhpbmcgaW4gdGhlIHN1YnRyZWUgaXMgZHluYW1pYyAoaS5lLiBuZWVkc0R5bmFtaWNSZXF1ZXN0IGlzIGZhbHNlIGF0IHRoZVxuICAvLyBlbmQpLCB0aGVuIHRoaXMgd2lsbCBiZSBkaXNjYXJkZWQuXG4gIC8vIFRPRE86IFdlIGNhbiBwcm9iYWJseSBvcHRpbWl6ZSB0aGUgZm9ybWF0IG9mIHRoaXMgZGF0YSBzdHJ1Y3R1cmUgdG8gb25seVxuICAvLyBpbmNsdWRlIHBhdGhzIHRoYXQgYXJlIGR5bmFtaWMuIEluc3RlYWQgb2YgcmV1c2luZyB0aGVcbiAgLy8gRmxpZ2h0Um91dGVyU3RhdGUgdHlwZS5cbiAgbGV0IGR5bmFtaWNSZXF1ZXN0VHJlZUNoaWxkcmVuOiB7XG4gICAgW3BhcmFsbGVsUm91dGVLZXk6IHN0cmluZ106IEZsaWdodFJvdXRlclN0YXRlXG4gIH0gPSB7fVxuXG4gIGZvciAobGV0IHBhcmFsbGVsUm91dGVLZXkgaW4gbmV3Um91dGVyU3RhdGVDaGlsZHJlbikge1xuICAgIGNvbnN0IG5ld1JvdXRlclN0YXRlQ2hpbGQ6IEZsaWdodFJvdXRlclN0YXRlID1cbiAgICAgIG5ld1JvdXRlclN0YXRlQ2hpbGRyZW5bcGFyYWxsZWxSb3V0ZUtleV1cbiAgICBjb25zdCBvbGRSb3V0ZXJTdGF0ZUNoaWxkOiBGbGlnaHRSb3V0ZXJTdGF0ZSB8IHZvaWQgPVxuICAgICAgb2xkUm91dGVyU3RhdGVDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XVxuICAgIGNvbnN0IG9sZFNlZ21lbnRNYXBDaGlsZCA9IG9sZFBhcmFsbGVsUm91dGVzLmdldChwYXJhbGxlbFJvdXRlS2V5KVxuICAgIGNvbnN0IHByZWZldGNoRGF0YUNoaWxkOiBDYWNoZU5vZGVTZWVkRGF0YSB8IHZvaWQgfCBudWxsID1cbiAgICAgIHByZWZldGNoRGF0YUNoaWxkcmVuICE9PSBudWxsXG4gICAgICAgID8gcHJlZmV0Y2hEYXRhQ2hpbGRyZW5bcGFyYWxsZWxSb3V0ZUtleV1cbiAgICAgICAgOiBudWxsXG5cbiAgICBjb25zdCBuZXdTZWdtZW50Q2hpbGQgPSBuZXdSb3V0ZXJTdGF0ZUNoaWxkWzBdXG4gICAgY29uc3QgbmV3U2VnbWVudFBhdGhDaGlsZCA9IHNlZ21lbnRQYXRoLmNvbmNhdChbXG4gICAgICBwYXJhbGxlbFJvdXRlS2V5LFxuICAgICAgbmV3U2VnbWVudENoaWxkLFxuICAgIF0pXG4gICAgY29uc3QgbmV3U2VnbWVudEtleUNoaWxkID0gY3JlYXRlUm91dGVyQ2FjaGVLZXkobmV3U2VnbWVudENoaWxkKVxuXG4gICAgY29uc3Qgb2xkU2VnbWVudENoaWxkID1cbiAgICAgIG9sZFJvdXRlclN0YXRlQ2hpbGQgIT09IHVuZGVmaW5lZCA/IG9sZFJvdXRlclN0YXRlQ2hpbGRbMF0gOiB1bmRlZmluZWRcblxuICAgIGNvbnN0IG9sZENhY2hlTm9kZUNoaWxkID1cbiAgICAgIG9sZFNlZ21lbnRNYXBDaGlsZCAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gb2xkU2VnbWVudE1hcENoaWxkLmdldChuZXdTZWdtZW50S2V5Q2hpbGQpXG4gICAgICAgIDogdW5kZWZpbmVkXG5cbiAgICBsZXQgdGFza0NoaWxkOiBUYXNrIHwgbnVsbFxuICAgIGlmIChuZXdTZWdtZW50Q2hpbGQgPT09IERFRkFVTFRfU0VHTUVOVF9LRVkpIHtcbiAgICAgIC8vIFRoaXMgaXMgYW5vdGhlciBraW5kIG9mIGxlYWYgc2VnbWVudCDigJQgYSBkZWZhdWx0IHJvdXRlLlxuICAgICAgLy9cbiAgICAgIC8vIERlZmF1bHQgcm91dGVzIGhhdmUgc3BlY2lhbCBiZWhhdmlvci4gV2hlbiB0aGVyZSdzIG5vIG1hdGNoaW5nIHNlZ21lbnRcbiAgICAgIC8vIGZvciBhIHBhcmFsbGVsIHJvdXRlLCBOZXh0LmpzIHByZXNlcnZlcyB0aGUgY3VycmVudGx5IGFjdGl2ZSBzZWdtZW50XG4gICAgICAvLyBkdXJpbmcgYSBjbGllbnQgbmF2aWdhdGlvbiDigJQgYnV0IG5vdCBmb3IgaW5pdGlhbCByZW5kZXIuIFRoZSBzZXJ2ZXJcbiAgICAgIC8vIGxlYXZlcyBpdCB0byB0aGUgY2xpZW50IHRvIGFjY291bnQgZm9yIHRoaXMuIFNvIHdlIG5lZWQgdG8gaGFuZGxlXG4gICAgICAvLyBpdCBoZXJlLlxuICAgICAgaWYgKG9sZFJvdXRlclN0YXRlQ2hpbGQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBSZXVzZSB0aGUgZXhpc3RpbmcgUm91dGVyIFN0YXRlIGZvciB0aGlzIHNlZ21lbnQuIFdlIHNwYXduIGEgXCJ0YXNrXCJcbiAgICAgICAgLy8ganVzdCB0byBrZWVwIHRyYWNrIG9mIHRoZSB1cGRhdGVkIHJvdXRlciBzdGF0ZTsgdW5saWtlIG1vc3QsIGl0J3NcbiAgICAgICAgLy8gYWxyZWFkeSBmdWxmaWxsZWQgYW5kIHdvbid0IGJlIGFmZmVjdGVkIGJ5IHRoZSBkeW5hbWljIHJlc3BvbnNlLlxuICAgICAgICB0YXNrQ2hpbGQgPSBzcGF3blJldXNlZFRhc2sob2xkUm91dGVyU3RhdGVDaGlsZClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoZXJlJ3Mgbm8gY3VycmVudGx5IGFjdGl2ZSBzZWdtZW50LiBTd2l0Y2ggdG8gdGhlIFwiY3JlYXRlXCIgcGF0aC5cbiAgICAgICAgdGFza0NoaWxkID0gYmVnaW5SZW5kZXJpbmdOZXdSb3V0ZVRyZWUoXG4gICAgICAgICAgbmF2aWdhdGVkQXQsXG4gICAgICAgICAgb2xkUm91dGVyU3RhdGVDaGlsZCxcbiAgICAgICAgICBuZXdSb3V0ZXJTdGF0ZUNoaWxkLFxuICAgICAgICAgIG9sZENhY2hlTm9kZUNoaWxkLFxuICAgICAgICAgIGRpZEZpbmRSb290TGF5b3V0LFxuICAgICAgICAgIHByZWZldGNoRGF0YUNoaWxkICE9PSB1bmRlZmluZWQgPyBwcmVmZXRjaERhdGFDaGlsZCA6IG51bGwsXG4gICAgICAgICAgcHJlZmV0Y2hIZWFkLFxuICAgICAgICAgIGlzUHJlZmV0Y2hIZWFkUGFydGlhbCxcbiAgICAgICAgICBuZXdTZWdtZW50UGF0aENoaWxkLFxuICAgICAgICAgIHNjcm9sbGFibGVTZWdtZW50c1Jlc3VsdFxuICAgICAgICApXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIGlzU2FtZVBhZ2VOYXZpZ2F0aW9uICYmXG4gICAgICAvLyBDaGVjayBpZiB0aGlzIGlzIGEgcGFnZSBzZWdtZW50LlxuICAgICAgLy8gVE9ETzogV2UncmUgbm90IGNvbnNpc3RlbnQgYWJvdXQgaG93IHdlIGRvIHRoaXMgY2hlY2suIFNvbWUgcGxhY2VzXG4gICAgICAvLyBjaGVjayBpZiB0aGUgc2VnbWVudCBzdGFydHMgd2l0aCBQQUdFX1NFR01FTlRfS0VZLCBidXQgbW9zdCBzZWVtIHRvXG4gICAgICAvLyBjaGVjayBpZiB0aGVyZSBhbnkgYW55IGNoaWxkcmVuLCB3aGljaCBpcyB3aHkgSSdtIGRvaW5nIGl0IGhlcmUuIFdlXG4gICAgICAvLyBzaG91bGQgcHJvYmFibHkgZW5jb2RlIGFuIGVtcHR5IGNoaWxkcmVuIHNldCBhcyBgbnVsbGAgdGhvdWdoLiBFaXRoZXJcbiAgICAgIC8vIHdheSwgd2Ugc2hvdWxkIHVwZGF0ZSBhbGwgdGhlIGNoZWNrcyB0byBiZSBjb25zaXN0ZW50LlxuICAgICAgT2JqZWN0LmtleXMobmV3Um91dGVyU3RhdGVDaGlsZFsxXSkubGVuZ3RoID09PSAwXG4gICAgKSB7XG4gICAgICAvLyBXZSBzcGVjaWFsIGNhc2UgbmF2aWdhdGlvbnMgdG8gdGhlIGV4YWN0IHNhbWUgVVJMIGFzIHRoZSBjdXJyZW50XG4gICAgICAvLyBsb2NhdGlvbi4gSXQncyBhIGNvbW1vbiBVSSBwYXR0ZXJuIGZvciBhcHBzIHRvIHJlZnJlc2ggd2hlbiB5b3UgY2xpY2sgYVxuICAgICAgLy8gbGluayB0byB0aGUgY3VycmVudCBwYWdlLiBTbyB3aGVuIHRoaXMgaGFwcGVucywgd2UgcmVmcmVzaCB0aGUgZHluYW1pY1xuICAgICAgLy8gZGF0YSBpbiB0aGUgcGFnZSBzZWdtZW50cy5cbiAgICAgIC8vXG4gICAgICAvLyBOb3RlIHRoYXQgdGhpcyBkb2VzIG5vdCBhcHBseSBpZiB0aGUgYW55IHBhcnQgb2YgdGhlIGhhc2ggb3Igc2VhcmNoXG4gICAgICAvLyBxdWVyeSBoYXMgY2hhbmdlZC4gVGhpcyBtaWdodCBmZWVsIGEgYml0IHdlaXJkIGJ1dCBpdCBtYWtlcyBtb3JlIHNlbnNlXG4gICAgICAvLyB3aGVuIHlvdSBjb25zaWRlciB0aGF0IHRoZSB3YXkgdG8gdHJpZ2dlciB0aGlzIGJlaGF2aW9yIGlzIHRvIGNsaWNrXG4gICAgICAvLyB0aGUgc2FtZSBsaW5rIG11bHRpcGxlIHRpbWVzLlxuICAgICAgLy9cbiAgICAgIC8vIFRPRE86IFdlIHNob3VsZCBwcm9iYWJseSByZWZyZXNoIHRoZSAqZW50aXJlKiByb3V0ZSB3aGVuIHRoaXMgY2FzZVxuICAgICAgLy8gb2NjdXJzLCBub3QganVzdCB0aGUgcGFnZSBzZWdtZW50cy4gRXNzZW50aWFsbHkgdHJlYXRpbmcgaXQgdGhlIHNhbWUgYXNcbiAgICAgIC8vIGEgcmVmcmVzaCgpIHRyaWdnZXJlZCBieSBhbiBhY3Rpb24sIHdoaWNoIGlzIHRoZSBtb3JlIGV4cGxpY2l0IHdheSBvZlxuICAgICAgLy8gbW9kZWxpbmcgdGhlIFVJIHBhdHRlcm4gZGVzY3JpYmVkIGFib3ZlLlxuICAgICAgLy9cbiAgICAgIC8vIEFsc28gbm90ZSB0aGF0IHRoaXMgb25seSByZWZyZXNoZXMgdGhlIGR5bmFtaWMgZGF0YSwgbm90IHN0YXRpYy9cbiAgICAgIC8vIGNhY2hlZCBkYXRhLiBJZiB0aGUgcGFnZSBzZWdtZW50IGlzIGZ1bGx5IHN0YXRpYyBhbmQgcHJlZmV0Y2hlZCwgdGhlXG4gICAgICAvLyByZXF1ZXN0IGlzIHNraXBwZWQuIChUaGlzIGlzIGFsc28gaG93IHJlZnJlc2goKSB3b3Jrcy4pXG4gICAgICB0YXNrQ2hpbGQgPSBiZWdpblJlbmRlcmluZ05ld1JvdXRlVHJlZShcbiAgICAgICAgbmF2aWdhdGVkQXQsXG4gICAgICAgIG9sZFJvdXRlclN0YXRlQ2hpbGQsXG4gICAgICAgIG5ld1JvdXRlclN0YXRlQ2hpbGQsXG4gICAgICAgIG9sZENhY2hlTm9kZUNoaWxkLFxuICAgICAgICBkaWRGaW5kUm9vdExheW91dCxcbiAgICAgICAgcHJlZmV0Y2hEYXRhQ2hpbGQgIT09IHVuZGVmaW5lZCA/IHByZWZldGNoRGF0YUNoaWxkIDogbnVsbCxcbiAgICAgICAgcHJlZmV0Y2hIZWFkLFxuICAgICAgICBpc1ByZWZldGNoSGVhZFBhcnRpYWwsXG4gICAgICAgIG5ld1NlZ21lbnRQYXRoQ2hpbGQsXG4gICAgICAgIHNjcm9sbGFibGVTZWdtZW50c1Jlc3VsdFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBvbGRSb3V0ZXJTdGF0ZUNoaWxkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIG9sZFNlZ21lbnRDaGlsZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICBtYXRjaFNlZ21lbnQobmV3U2VnbWVudENoaWxkLCBvbGRTZWdtZW50Q2hpbGQpXG4gICAgKSB7XG4gICAgICBpZiAoXG4gICAgICAgIG9sZENhY2hlTm9kZUNoaWxkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgb2xkUm91dGVyU3RhdGVDaGlsZCAhPT0gdW5kZWZpbmVkXG4gICAgICApIHtcbiAgICAgICAgLy8gVGhpcyBzZWdtZW50IGV4aXN0cyBpbiBib3RoIHRoZSBvbGQgYW5kIG5ldyB0cmVlcy4gUmVjdXJzaXZlbHkgdXBkYXRlXG4gICAgICAgIC8vIHRoZSBjaGlsZHJlbi5cbiAgICAgICAgdGFza0NoaWxkID0gdXBkYXRlQ2FjaGVOb2RlT25OYXZpZ2F0aW9uKFxuICAgICAgICAgIG5hdmlnYXRlZEF0LFxuICAgICAgICAgIG9sZENhY2hlTm9kZUNoaWxkLFxuICAgICAgICAgIG9sZFJvdXRlclN0YXRlQ2hpbGQsXG4gICAgICAgICAgbmV3Um91dGVyU3RhdGVDaGlsZCxcbiAgICAgICAgICBkaWRGaW5kUm9vdExheW91dCxcbiAgICAgICAgICBwcmVmZXRjaERhdGFDaGlsZCxcbiAgICAgICAgICBwcmVmZXRjaEhlYWQsXG4gICAgICAgICAgaXNQcmVmZXRjaEhlYWRQYXJ0aWFsLFxuICAgICAgICAgIGlzU2FtZVBhZ2VOYXZpZ2F0aW9uLFxuICAgICAgICAgIG5ld1NlZ21lbnRQYXRoQ2hpbGQsXG4gICAgICAgICAgc2Nyb2xsYWJsZVNlZ21lbnRzUmVzdWx0XG4gICAgICAgIClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoZXJlJ3Mgbm8gZXhpc3RpbmcgQ2FjaGUgTm9kZSBmb3IgdGhpcyBzZWdtZW50LiBTd2l0Y2ggdG8gdGhlXG4gICAgICAgIC8vIFwiY3JlYXRlXCIgcGF0aC5cbiAgICAgICAgdGFza0NoaWxkID0gYmVnaW5SZW5kZXJpbmdOZXdSb3V0ZVRyZWUoXG4gICAgICAgICAgbmF2aWdhdGVkQXQsXG4gICAgICAgICAgb2xkUm91dGVyU3RhdGVDaGlsZCxcbiAgICAgICAgICBuZXdSb3V0ZXJTdGF0ZUNoaWxkLFxuICAgICAgICAgIG9sZENhY2hlTm9kZUNoaWxkLFxuICAgICAgICAgIGRpZEZpbmRSb290TGF5b3V0LFxuICAgICAgICAgIHByZWZldGNoRGF0YUNoaWxkICE9PSB1bmRlZmluZWQgPyBwcmVmZXRjaERhdGFDaGlsZCA6IG51bGwsXG4gICAgICAgICAgcHJlZmV0Y2hIZWFkLFxuICAgICAgICAgIGlzUHJlZmV0Y2hIZWFkUGFydGlhbCxcbiAgICAgICAgICBuZXdTZWdtZW50UGF0aENoaWxkLFxuICAgICAgICAgIHNjcm9sbGFibGVTZWdtZW50c1Jlc3VsdFxuICAgICAgICApXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMgYSBuZXcgdHJlZS4gU3dpdGNoIHRvIHRoZSBcImNyZWF0ZVwiIHBhdGguXG4gICAgICB0YXNrQ2hpbGQgPSBiZWdpblJlbmRlcmluZ05ld1JvdXRlVHJlZShcbiAgICAgICAgbmF2aWdhdGVkQXQsXG4gICAgICAgIG9sZFJvdXRlclN0YXRlQ2hpbGQsXG4gICAgICAgIG5ld1JvdXRlclN0YXRlQ2hpbGQsXG4gICAgICAgIG9sZENhY2hlTm9kZUNoaWxkLFxuICAgICAgICBkaWRGaW5kUm9vdExheW91dCxcbiAgICAgICAgcHJlZmV0Y2hEYXRhQ2hpbGQgIT09IHVuZGVmaW5lZCA/IHByZWZldGNoRGF0YUNoaWxkIDogbnVsbCxcbiAgICAgICAgcHJlZmV0Y2hIZWFkLFxuICAgICAgICBpc1ByZWZldGNoSGVhZFBhcnRpYWwsXG4gICAgICAgIG5ld1NlZ21lbnRQYXRoQ2hpbGQsXG4gICAgICAgIHNjcm9sbGFibGVTZWdtZW50c1Jlc3VsdFxuICAgICAgKVxuICAgIH1cblxuICAgIGlmICh0YXNrQ2hpbGQgIT09IG51bGwpIHtcbiAgICAgIC8vIFJlY3Vyc2l2ZWx5IHByb3BhZ2F0ZSB1cCB0aGUgY2hpbGQgdGFza3MuXG5cbiAgICAgIGlmICh0YXNrQ2hpbGQucm91dGUgPT09IG51bGwpIHtcbiAgICAgICAgLy8gT25lIG9mIHRoZSBjaGlsZCB0YXNrcyBkaXNjb3ZlcmVkIGEgY2hhbmdlIHRvIHRoZSByb290IGxheW91dC5cbiAgICAgICAgLy8gSW1tZWRpYXRlbHkgdW53aW5kIGZyb20gdGhpcyByZWN1cnNpdmUgdHJhdmVyc2FsLlxuICAgICAgICByZXR1cm4gTVBBX05BVklHQVRJT05fVEFTS1xuICAgICAgfVxuXG4gICAgICBpZiAodGFza0NoaWxkcmVuID09PSBudWxsKSB7XG4gICAgICAgIHRhc2tDaGlsZHJlbiA9IG5ldyBNYXAoKVxuICAgICAgfVxuICAgICAgdGFza0NoaWxkcmVuLnNldChwYXJhbGxlbFJvdXRlS2V5LCB0YXNrQ2hpbGQpXG4gICAgICBjb25zdCBuZXdDYWNoZU5vZGVDaGlsZCA9IHRhc2tDaGlsZC5ub2RlXG4gICAgICBpZiAobmV3Q2FjaGVOb2RlQ2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgbmV3U2VnbWVudE1hcENoaWxkOiBDaGlsZFNlZ21lbnRNYXAgPSBuZXcgTWFwKG9sZFNlZ21lbnRNYXBDaGlsZClcbiAgICAgICAgbmV3U2VnbWVudE1hcENoaWxkLnNldChuZXdTZWdtZW50S2V5Q2hpbGQsIG5ld0NhY2hlTm9kZUNoaWxkKVxuICAgICAgICBwcmVmZXRjaFBhcmFsbGVsUm91dGVzLnNldChwYXJhbGxlbFJvdXRlS2V5LCBuZXdTZWdtZW50TWFwQ2hpbGQpXG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjaGlsZCB0cmVlJ3Mgcm91dGUgc3RhdGUgbWF5IGJlIGRpZmZlcmVudCBmcm9tIHRoZSBwcmVmZXRjaGVkXG4gICAgICAvLyByb3V0ZSBzZW50IGJ5IHRoZSBzZXJ2ZXIuIFdlIG5lZWQgdG8gY2xvbmUgaXQgYXMgd2UgdHJhdmVyc2UgYmFjayB1cFxuICAgICAgLy8gdGhlIHRyZWUuXG4gICAgICBjb25zdCB0YXNrQ2hpbGRSb3V0ZSA9IHRhc2tDaGlsZC5yb3V0ZVxuICAgICAgcGF0Y2hlZFJvdXRlclN0YXRlQ2hpbGRyZW5bcGFyYWxsZWxSb3V0ZUtleV0gPSB0YXNrQ2hpbGRSb3V0ZVxuXG4gICAgICBjb25zdCBkeW5hbWljUmVxdWVzdFRyZWVDaGlsZCA9IHRhc2tDaGlsZC5keW5hbWljUmVxdWVzdFRyZWVcbiAgICAgIGlmIChkeW5hbWljUmVxdWVzdFRyZWVDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBTb21ldGhpbmcgaW4gdGhlIGNoaWxkIHRyZWUgaXMgZHluYW1pYy5cbiAgICAgICAgbmVlZHNEeW5hbWljUmVxdWVzdCA9IHRydWVcbiAgICAgICAgZHluYW1pY1JlcXVlc3RUcmVlQ2hpbGRyZW5bcGFyYWxsZWxSb3V0ZUtleV0gPSBkeW5hbWljUmVxdWVzdFRyZWVDaGlsZFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZHluYW1pY1JlcXVlc3RUcmVlQ2hpbGRyZW5bcGFyYWxsZWxSb3V0ZUtleV0gPSB0YXNrQ2hpbGRSb3V0ZVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgY2hpbGQgZGlkbid0IGNoYW5nZS4gV2UgY2FuIHVzZSB0aGUgcHJlZmV0Y2hlZCByb3V0ZXIgc3RhdGUuXG4gICAgICBwYXRjaGVkUm91dGVyU3RhdGVDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XSA9IG5ld1JvdXRlclN0YXRlQ2hpbGRcbiAgICAgIGR5bmFtaWNSZXF1ZXN0VHJlZUNoaWxkcmVuW3BhcmFsbGVsUm91dGVLZXldID0gbmV3Um91dGVyU3RhdGVDaGlsZFxuICAgIH1cbiAgfVxuXG4gIGlmICh0YXNrQ2hpbGRyZW4gPT09IG51bGwpIHtcbiAgICAvLyBObyBuZXcgdGFza3Mgd2VyZSBzcGF3bmVkLlxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBjb25zdCBuZXdDYWNoZU5vZGU6IFJlYWR5Q2FjaGVOb2RlID0ge1xuICAgIGxhenlEYXRhOiBudWxsLFxuICAgIHJzYzogb2xkQ2FjaGVOb2RlLnJzYyxcbiAgICAvLyBXZSBpbnRlbnRpb25hbGx5IGFyZW4ndCB1cGRhdGluZyB0aGUgcHJlZmV0Y2hSc2MgZmllbGQsIHNpbmNlIHRoaXMgbm9kZVxuICAgIC8vIGlzIGFscmVhZHkgcGFydCBvZiB0aGUgY3VycmVudCB0cmVlLCBiZWNhdXNlIGl0IHdvdWxkIGJlIHdlaXJkIGZvclxuICAgIC8vIHByZWZldGNoIGRhdGEgdG8gYmUgbmV3ZXIgdGhhbiB0aGUgZmluYWwgZGF0YS4gSXQgcHJvYmFibHkgd29uJ3QgZXZlciBiZVxuICAgIC8vIG9ic2VydmFibGUgYW55d2F5LCBidXQgaXQgY291bGQgaGFwcGVuIGlmIHRoZSBzZWdtZW50IGlzIHVubW91bnRlZCB0aGVuXG4gICAgLy8gbW91bnRlZCBhZ2FpbiwgYmVjYXVzZSBMYXlvdXRSb3V0ZXIgd2lsbCBtb21lbnRhcmlseSBzd2l0Y2ggdG8gcmVuZGVyaW5nXG4gICAgLy8gcHJlZmV0Y2hSc2MsIHZpYSB1c2VEZWZlcnJlZFZhbHVlLlxuICAgIHByZWZldGNoUnNjOiBvbGRDYWNoZU5vZGUucHJlZmV0Y2hSc2MsXG4gICAgaGVhZDogb2xkQ2FjaGVOb2RlLmhlYWQsXG4gICAgcHJlZmV0Y2hIZWFkOiBvbGRDYWNoZU5vZGUucHJlZmV0Y2hIZWFkLFxuICAgIGxvYWRpbmc6IG9sZENhY2hlTm9kZS5sb2FkaW5nLFxuXG4gICAgLy8gRXZlcnl0aGluZyBpcyBjbG9uZWQgZXhjZXB0IGZvciB0aGUgY2hpbGRyZW4sIHdoaWNoIHdlIGNvbXB1dGVkIGFib3ZlLlxuICAgIHBhcmFsbGVsUm91dGVzOiBwcmVmZXRjaFBhcmFsbGVsUm91dGVzLFxuXG4gICAgbmF2aWdhdGVkQXQsXG4gIH1cblxuICByZXR1cm4ge1xuICAgIC8vIFJldHVybiBhIGNsb25lZCBjb3B5IG9mIHRoZSByb3V0ZXIgc3RhdGUgd2l0aCB1cGRhdGVkIGNoaWxkcmVuLlxuICAgIHJvdXRlOiBwYXRjaFJvdXRlclN0YXRlV2l0aE5ld0NoaWxkcmVuKFxuICAgICAgbmV3Um91dGVyU3RhdGUsXG4gICAgICBwYXRjaGVkUm91dGVyU3RhdGVDaGlsZHJlblxuICAgICksXG4gICAgbm9kZTogbmV3Q2FjaGVOb2RlLFxuICAgIGR5bmFtaWNSZXF1ZXN0VHJlZTogbmVlZHNEeW5hbWljUmVxdWVzdFxuICAgICAgPyBwYXRjaFJvdXRlclN0YXRlV2l0aE5ld0NoaWxkcmVuKFxuICAgICAgICAgIG5ld1JvdXRlclN0YXRlLFxuICAgICAgICAgIGR5bmFtaWNSZXF1ZXN0VHJlZUNoaWxkcmVuXG4gICAgICAgIClcbiAgICAgIDogbnVsbCxcbiAgICBjaGlsZHJlbjogdGFza0NoaWxkcmVuLFxuICB9XG59XG5cbmZ1bmN0aW9uIGJlZ2luUmVuZGVyaW5nTmV3Um91dGVUcmVlKFxuICBuYXZpZ2F0ZWRBdDogbnVtYmVyLFxuICBvbGRSb3V0ZXJTdGF0ZTogRmxpZ2h0Um91dGVyU3RhdGUgfCB2b2lkLFxuICBuZXdSb3V0ZXJTdGF0ZTogRmxpZ2h0Um91dGVyU3RhdGUsXG4gIGV4aXN0aW5nQ2FjaGVOb2RlOiBDYWNoZU5vZGUgfCB2b2lkLFxuICBkaWRGaW5kUm9vdExheW91dDogYm9vbGVhbixcbiAgcHJlZmV0Y2hEYXRhOiBDYWNoZU5vZGVTZWVkRGF0YSB8IG51bGwsXG4gIHBvc3NpYmx5UGFydGlhbFByZWZldGNoSGVhZDogSGVhZERhdGEgfCBudWxsLFxuICBpc1ByZWZldGNoSGVhZFBhcnRpYWw6IGJvb2xlYW4sXG4gIHNlZ21lbnRQYXRoOiBGbGlnaHRTZWdtZW50UGF0aCxcbiAgc2Nyb2xsYWJsZVNlZ21lbnRzUmVzdWx0OiBBcnJheTxGbGlnaHRTZWdtZW50UGF0aD5cbik6IFRhc2sge1xuICBpZiAoIWRpZEZpbmRSb290TGF5b3V0KSB7XG4gICAgLy8gVGhlIHJvdXRlIHRyZWUgY2hhbmdlZCBiZWZvcmUgd2UgcmVhY2hlZCBhIGxheW91dC4gKFRoZSBoaWdoZXN0LWxldmVsXG4gICAgLy8gbGF5b3V0IGluIGEgcm91dGUgdHJlZSBpcyByZWZlcnJlZCB0byBhcyB0aGUgXCJyb290XCIgbGF5b3V0LikgVGhpcyBjb3VsZFxuICAgIC8vIG1lYW4gdGhhdCB3ZSdyZSBuYXZpZ2F0aW5nIGJldHdlZW4gdHdvIGRpZmZlcmVudCByb290IGxheW91dHMuIFdoZW4gdGhpc1xuICAgIC8vIGhhcHBlbnMsIHdlIHBlcmZvcm0gYSBmdWxsLXBhZ2UgKE1QQS1zdHlsZSkgbmF2aWdhdGlvbi5cbiAgICAvL1xuICAgIC8vIEhvd2V2ZXIsIHRoZSBhbGdvcml0aG0gZm9yIGRlY2lkaW5nIHdoZXJlIHRvIHN0YXJ0IHJlbmRlcmluZyBhIHJvdXRlXG4gICAgLy8gKGkuZS4gdGhlIG9uZSBwZXJmb3JtZWQgaW4gb3JkZXIgdG8gcmVhY2ggdGhpcyBmdW5jdGlvbikgaXMgc3RyaWN0ZXJcbiAgICAvLyB0aGFuIHRoZSBvbmUgdXNlZCB0byBkZXRlY3QgYSBjaGFuZ2UgaW4gdGhlIHJvb3QgbGF5b3V0LiBTbyBqdXN0IGJlY2F1c2VcbiAgICAvLyB3ZSdyZSByZS1yZW5kZXJpbmcgYSBzZWdtZW50IG91dHNpZGUgb2YgdGhlIHJvb3QgbGF5b3V0IGRvZXMgbm90IG1lYW4gd2VcbiAgICAvLyBzaG91bGQgdHJpZ2dlciBhIGZ1bGwtcGFnZSBuYXZpZ2F0aW9uLlxuICAgIC8vXG4gICAgLy8gU3BlY2lmaWNhbGx5LCB3ZSBoYW5kbGUgZHluYW1pYyBwYXJhbWV0ZXJzIGRpZmZlcmVudGx5OiB0d28gc2VnbWVudHMgYXJlXG4gICAgLy8gY29uc2lkZXJlZCB0aGUgc2FtZSBldmVuIGlmIHRoZWlyIHBhcmFtZXRlciB2YWx1ZXMgYXJlIGRpZmZlcmVudC5cbiAgICAvL1xuICAgIC8vIFJlZmVyIHRvIGlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dCBmb3IgZGV0YWlscy5cbiAgICAvL1xuICAgIC8vIE5vdGUgdGhhdCB3ZSBvbmx5IGhhdmUgdG8gcGVyZm9ybSB0aGlzIGV4dHJhIHRyYXZlcnNhbCBpZiB3ZSBkaWRuJ3RcbiAgICAvLyBhbHJlYWR5IGRpc2NvdmVyIGEgcm9vdCBsYXlvdXQgaW4gdGhlIHBhcnQgb2YgdGhlIHRyZWUgdGhhdCBpcyB1bmNoYW5nZWQuXG4gICAgLy8gSW4gdGhlIGNvbW1vbiBjYXNlLCB0aGlzIGJyYW5jaCBpcyBza2lwcGVkIGNvbXBsZXRlbHkuXG4gICAgaWYgKFxuICAgICAgb2xkUm91dGVyU3RhdGUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0KG9sZFJvdXRlclN0YXRlLCBuZXdSb3V0ZXJTdGF0ZSlcbiAgICApIHtcbiAgICAgIC8vIFRoZSByb290IGxheW91dCBjaGFuZ2VkLiBQZXJmb3JtIGEgZnVsbC1wYWdlIG5hdmlnYXRpb24uXG4gICAgICByZXR1cm4gTVBBX05BVklHQVRJT05fVEFTS1xuICAgIH1cbiAgfVxuICByZXR1cm4gY3JlYXRlQ2FjaGVOb2RlT25OYXZpZ2F0aW9uKFxuICAgIG5hdmlnYXRlZEF0LFxuICAgIG5ld1JvdXRlclN0YXRlLFxuICAgIGV4aXN0aW5nQ2FjaGVOb2RlLFxuICAgIHByZWZldGNoRGF0YSxcbiAgICBwb3NzaWJseVBhcnRpYWxQcmVmZXRjaEhlYWQsXG4gICAgaXNQcmVmZXRjaEhlYWRQYXJ0aWFsLFxuICAgIHNlZ21lbnRQYXRoLFxuICAgIHNjcm9sbGFibGVTZWdtZW50c1Jlc3VsdFxuICApXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlTm9kZU9uTmF2aWdhdGlvbihcbiAgbmF2aWdhdGVkQXQ6IG51bWJlcixcbiAgcm91dGVyU3RhdGU6IEZsaWdodFJvdXRlclN0YXRlLFxuICBleGlzdGluZ0NhY2hlTm9kZTogQ2FjaGVOb2RlIHwgdm9pZCxcbiAgcHJlZmV0Y2hEYXRhOiBDYWNoZU5vZGVTZWVkRGF0YSB8IG51bGwsXG4gIHBvc3NpYmx5UGFydGlhbFByZWZldGNoSGVhZDogSGVhZERhdGEgfCBudWxsLFxuICBpc1ByZWZldGNoSGVhZFBhcnRpYWw6IGJvb2xlYW4sXG4gIHNlZ21lbnRQYXRoOiBGbGlnaHRTZWdtZW50UGF0aCxcbiAgc2Nyb2xsYWJsZVNlZ21lbnRzUmVzdWx0OiBBcnJheTxGbGlnaHRTZWdtZW50UGF0aD5cbik6IFNQQU5hdmlnYXRpb25UYXNrIHtcbiAgLy8gU2FtZSB0cmF2ZXJzYWwgYXMgdXBkYXRlQ2FjaGVOb2RlTmF2aWdhdGlvbiwgYnV0IHdlIHN3aXRjaCB0byB0aGlzIHBhdGhcbiAgLy8gb25jZSB3ZSByZWFjaCB0aGUgcGFydCBvZiB0aGUgdHJlZSB0aGF0IHdhcyBub3QgaW4gdGhlIHByZXZpb3VzIHJvdXRlLiBXZVxuICAvLyBkb24ndCBuZWVkIHRvIGRpZmYgYWdhaW5zdCB0aGUgb2xkIHRyZWUsIHdlIGp1c3QgbmVlZCB0byBjcmVhdGUgYSBuZXcgb25lLlxuXG4gIC8vIFRoZSBoZWFkIGlzIGFzc2lnbmVkIHRvIGV2ZXJ5IGxlYWYgc2VnbWVudCBkZWxpdmVyZWQgYnkgdGhlIHNlcnZlci4gQmFzZWRcbiAgLy8gb24gY29ycmVzcG9uZGluZyBsb2dpYyBpbiBmaWxsLWxhenktaXRlbXMtdGlsbC1sZWFmLXdpdGgtaGVhZC50c1xuICBjb25zdCByb3V0ZXJTdGF0ZUNoaWxkcmVuID0gcm91dGVyU3RhdGVbMV1cbiAgY29uc3QgaXNMZWFmU2VnbWVudCA9IE9iamVjdC5rZXlzKHJvdXRlclN0YXRlQ2hpbGRyZW4pLmxlbmd0aCA9PT0gMFxuXG4gIC8vIEV2ZW4gd2UncmUgcmVuZGVyaW5nIGluc2lkZSB0aGUgXCJuZXdcIiBwYXJ0IG9mIHRoZSB0YXJnZXQgdHJlZSwgd2UgbWF5IGhhdmVcbiAgLy8gYSBsb2NhbGx5IGNhY2hlZCBzZWdtZW50IHRoYXQgd2UgY2FuIHJldXNlLiBUaGlzIG1heSBjb21lIGZyb20gZWl0aGVyIDEpXG4gIC8vIHRoZSBDYWNoZU5vZGUgdHJlZSwgd2hpY2ggbGl2ZXMgaW4gUmVhY3Qgc3RhdGUgYW5kIGlzIHBvcHVsYXRlZCBieSBwcmV2aW91c1xuICAvLyBuYXZpZ2F0aW9uczsgb3IgMikgdGhlIHByZWZldGNoIGNhY2hlLCB3aGljaCBpcyBhIHNlcGFyYXRlIGNhY2hlIHRoYXQgaXNcbiAgLy8gcG9wdWxhdGVkIGJ5IHByZWZldGNoZXMuXG4gIGxldCByc2M6IFJlYWN0LlJlYWN0Tm9kZVxuICBsZXQgbG9hZGluZzogTG9hZGluZ01vZHVsZURhdGEgfCBQcm9taXNlPExvYWRpbmdNb2R1bGVEYXRhPlxuICBsZXQgaGVhZDogSGVhZERhdGEgfCBudWxsXG4gIGxldCBjYWNoZU5vZGVOYXZpZ2F0ZWRBdDogbnVtYmVyXG4gIGlmIChcbiAgICBleGlzdGluZ0NhY2hlTm9kZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgLy8gRFlOQU1JQ19TVEFMRVRJTUVfTVMgZGVmYXVsdHMgdG8gMCwgYnV0IGl0IGNhbiBiZSBpbmNyZWFzZWQgdXNpbmdcbiAgICAvLyB0aGUgZXhwZXJpbWVudGFsLnN0YWxlVGltZXMuZHluYW1pYyBjb25maWcuIFdoZW4gc2V0LCB3ZSdsbCBhdm9pZFxuICAgIC8vIHJlZmV0Y2hpbmcgZHluYW1pYyBkYXRhIGlmIGl0IHdhcyBmZXRjaGVkIHdpdGhpbiB0aGUgZ2l2ZW4gdGhyZXNob2xkLlxuICAgIGV4aXN0aW5nQ2FjaGVOb2RlLm5hdmlnYXRlZEF0ICsgRFlOQU1JQ19TVEFMRVRJTUVfTVMgPiBuYXZpZ2F0ZWRBdFxuICApIHtcbiAgICAvLyBXZSBoYXZlIGFuIGV4aXN0aW5nIENhY2hlTm9kZSBmb3IgdGhpcyBzZWdtZW50LCBhbmQgaXQncyBub3Qgc3RhbGUuIFdlXG4gICAgLy8gc2hvdWxkIHJldXNlIGl0IHJhdGhlciB0aGFuIHJlcXVlc3QgYSBuZXcgb25lLlxuICAgIHJzYyA9IGV4aXN0aW5nQ2FjaGVOb2RlLnJzY1xuICAgIGxvYWRpbmcgPSBleGlzdGluZ0NhY2hlTm9kZS5sb2FkaW5nXG4gICAgaGVhZCA9IGV4aXN0aW5nQ2FjaGVOb2RlLmhlYWRcblxuICAgIC8vIERvbid0IHVwZGF0ZSB0aGUgbmF2aWdhdGVkQXQgdGltZXN0YW1wLCBzaW5jZSB3ZSdyZSByZXVzaW5nIHN0YWxlIGRhdGEuXG4gICAgY2FjaGVOb2RlTmF2aWdhdGVkQXQgPSBleGlzdGluZ0NhY2hlTm9kZS5uYXZpZ2F0ZWRBdFxuICB9IGVsc2UgaWYgKHByZWZldGNoRGF0YSAhPT0gbnVsbCkge1xuICAgIC8vIFRoZXJlJ3Mgbm8gZXhpc3RpbmcgQ2FjaGVOb2RlIGZvciB0aGlzIHNlZ21lbnQsIGJ1dCB3ZSBkbyBoYXZlIHByZWZldGNoXG4gICAgLy8gZGF0YS4gSWYgdGhlIHByZWZldGNoIGRhdGEgaXMgZnVsbHkgc3RhdGljIChpLmUuIGRvZXMgbm90IGNvbnRhaW4gYW55XG4gICAgLy8gZHluYW1pYyBob2xlcyksIHdlIGRvbid0IG5lZWQgdG8gcmVxdWVzdCBpdCBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgcnNjID0gcHJlZmV0Y2hEYXRhWzFdXG4gICAgbG9hZGluZyA9IHByZWZldGNoRGF0YVszXVxuICAgIGhlYWQgPSBpc0xlYWZTZWdtZW50ID8gcG9zc2libHlQYXJ0aWFsUHJlZmV0Y2hIZWFkIDogbnVsbFxuICAgIC8vIEV2ZW4gdGhvdWdoIHdlJ3JlIGFjY2Vzc2luZyB0aGUgZGF0YSBmcm9tIHRoZSBwcmVmZXRjaCBjYWNoZSwgdGhpcyBpc1xuICAgIC8vIGNvbmNlcHR1YWxseSBhIG5ldyBzZWdtZW50LCBub3QgYSByZXVzZWQgb25lLiBTbyB3ZSBzaG91bGQgdXBkYXRlIHRoZVxuICAgIC8vIG5hdmlnYXRlZEF0IHRpbWVzdGFtcC5cbiAgICBjYWNoZU5vZGVOYXZpZ2F0ZWRBdCA9IG5hdmlnYXRlZEF0XG4gICAgY29uc3QgaXNQcmVmZXRjaFJzY1BhcnRpYWwgPSBwcmVmZXRjaERhdGFbNF1cbiAgICBpZiAoXG4gICAgICAvLyBDaGVjayBpZiB0aGUgc2VnbWVudCBkYXRhIGlzIHBhcnRpYWxcbiAgICAgIGlzUHJlZmV0Y2hSc2NQYXJ0aWFsIHx8XG4gICAgICAvLyBDaGVjayBpZiB0aGUgaGVhZCBpcyBwYXJ0aWFsIChvbmx5IHJlbGV2YW50IGlmIHRoaXMgaXMgYSBsZWFmIHNlZ21lbnQpXG4gICAgICAoaXNQcmVmZXRjaEhlYWRQYXJ0aWFsICYmIGlzTGVhZlNlZ21lbnQpXG4gICAgKSB7XG4gICAgICAvLyBXZSBvbmx5IGhhdmUgcGFydGlhbCBkYXRhIGZyb20gdGhpcyBzZWdtZW50LiBMaWtlIG1pc3Npbmcgc2VnbWVudHMsIHdlXG4gICAgICAvLyBtdXN0IHJlcXVlc3QgdGhlIGZ1bGwgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgICByZXR1cm4gc3Bhd25QZW5kaW5nVGFzayhcbiAgICAgICAgbmF2aWdhdGVkQXQsXG4gICAgICAgIHJvdXRlclN0YXRlLFxuICAgICAgICBwcmVmZXRjaERhdGEsXG4gICAgICAgIHBvc3NpYmx5UGFydGlhbFByZWZldGNoSGVhZCxcbiAgICAgICAgaXNQcmVmZXRjaEhlYWRQYXJ0aWFsLFxuICAgICAgICBzZWdtZW50UGF0aCxcbiAgICAgICAgc2Nyb2xsYWJsZVNlZ21lbnRzUmVzdWx0XG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSBwcmVmZXRjaCBkYXRhIGlzIGZ1bGx5IHN0YXRpYywgc28gd2UgY2FuIG9taXQgaXQgZnJvbSB0aGVcbiAgICAgIC8vIG5hdmlnYXRpb24gcmVxdWVzdC5cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhlcmUncyBubyBwcmVmZXRjaCBmb3IgdGhpcyBzZWdtZW50LiBFdmVyeXRoaW5nIGZyb20gdGhpcyBwb2ludCB3aWxsIGJlXG4gICAgLy8gcmVxdWVzdGVkIGZyb20gdGhlIHNlcnZlciwgZXZlbiBpZiB0aGVyZSBhcmUgc3RhdGljIGNoaWxkcmVuIGJlbG93IGl0LlxuICAgIC8vIENyZWF0ZSBhIHRlcm1pbmFsIHRhc2sgbm9kZSB0aGF0IHdpbGwgbGF0ZXIgYmUgZnVsZmlsbGVkIGJ5XG4gICAgLy8gc2VydmVyIHJlc3BvbnNlLlxuICAgIHJldHVybiBzcGF3blBlbmRpbmdUYXNrKFxuICAgICAgbmF2aWdhdGVkQXQsXG4gICAgICByb3V0ZXJTdGF0ZSxcbiAgICAgIG51bGwsXG4gICAgICBwb3NzaWJseVBhcnRpYWxQcmVmZXRjaEhlYWQsXG4gICAgICBpc1ByZWZldGNoSGVhZFBhcnRpYWwsXG4gICAgICBzZWdtZW50UGF0aCxcbiAgICAgIHNjcm9sbGFibGVTZWdtZW50c1Jlc3VsdFxuICAgIClcbiAgfVxuXG4gIC8vIFdlIGFscmVhZHkgaGF2ZSBhIGZ1bGwgc2VnbWVudCB3ZSBjYW4gcmVuZGVyLCBzbyB3ZSBkb24ndCBuZWVkIHRvIHJlcXVlc3QgYVxuICAvLyBuZXcgb25lIGZyb20gdGhlIHNlcnZlci4gS2VlcCB0cmF2ZXJzaW5nIGRvd24gdGhlIHRyZWUgdW50aWwgd2UgcmVhY2hcbiAgLy8gc29tZXRoaW5nIHRoYXQgcmVxdWlyZXMgYSBkeW5hbWljIHJlcXVlc3QuXG4gIGNvbnN0IHByZWZldGNoRGF0YUNoaWxkcmVuID0gcHJlZmV0Y2hEYXRhICE9PSBudWxsID8gcHJlZmV0Y2hEYXRhWzJdIDogbnVsbFxuICBjb25zdCB0YXNrQ2hpbGRyZW4gPSBuZXcgTWFwKClcbiAgY29uc3QgZXhpc3RpbmdDYWNoZU5vZGVDaGlsZHJlbiA9XG4gICAgZXhpc3RpbmdDYWNoZU5vZGUgIT09IHVuZGVmaW5lZCA/IGV4aXN0aW5nQ2FjaGVOb2RlLnBhcmFsbGVsUm91dGVzIDogbnVsbFxuICBjb25zdCBjYWNoZU5vZGVDaGlsZHJlbiA9IG5ldyBNYXAoZXhpc3RpbmdDYWNoZU5vZGVDaGlsZHJlbilcbiAgbGV0IGR5bmFtaWNSZXF1ZXN0VHJlZUNoaWxkcmVuOiB7XG4gICAgW3BhcmFsbGVsUm91dGVLZXk6IHN0cmluZ106IEZsaWdodFJvdXRlclN0YXRlXG4gIH0gPSB7fVxuICBsZXQgbmVlZHNEeW5hbWljUmVxdWVzdCA9IGZhbHNlXG4gIGlmIChpc0xlYWZTZWdtZW50KSB7XG4gICAgLy8gVGhlIHNlZ21lbnQgcGF0aCBvZiBldmVyeSBsZWFmIHNlZ21lbnQgKGkuZS4gcGFnZSkgaXMgY29sbGVjdGVkIGludG9cbiAgICAvLyBhIHJlc3VsdCBhcnJheS4gVGhpcyBpcyB1c2VkIGJ5IHRoZSBMYXlvdXRSb3V0ZXIgdG8gc2Nyb2xsIHRvIGVuc3VyZSB0aGF0XG4gICAgLy8gbmV3IHBhZ2VzIGFyZSB2aXNpYmxlIGFmdGVyIGEgbmF2aWdhdGlvbi5cbiAgICAvLyBUT0RPOiBXZSBzaG91bGQgdXNlIGEgc3RyaW5nIHRvIHJlcHJlc2VudCB0aGUgc2VnbWVudCBwYXRoIGluc3RlYWQgb2ZcbiAgICAvLyBhbiBhcnJheS4gV2UgYWxyZWFkeSB1c2UgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gZm9yIHRoZSBwYXRoIHdoZW5cbiAgICAvLyBhY2Nlc3NpbmcgdGhlIFNlZ21lbnQgQ2FjaGUsIHNvIHdlIGNhbiB1c2UgdGhlIHNhbWUgb25lLlxuICAgIHNjcm9sbGFibGVTZWdtZW50c1Jlc3VsdC5wdXNoKHNlZ21lbnRQYXRoKVxuICB9IGVsc2Uge1xuICAgIGZvciAobGV0IHBhcmFsbGVsUm91dGVLZXkgaW4gcm91dGVyU3RhdGVDaGlsZHJlbikge1xuICAgICAgY29uc3Qgcm91dGVyU3RhdGVDaGlsZDogRmxpZ2h0Um91dGVyU3RhdGUgPVxuICAgICAgICByb3V0ZXJTdGF0ZUNoaWxkcmVuW3BhcmFsbGVsUm91dGVLZXldXG4gICAgICBjb25zdCBwcmVmZXRjaERhdGFDaGlsZDogQ2FjaGVOb2RlU2VlZERhdGEgfCB2b2lkIHwgbnVsbCA9XG4gICAgICAgIHByZWZldGNoRGF0YUNoaWxkcmVuICE9PSBudWxsXG4gICAgICAgICAgPyBwcmVmZXRjaERhdGFDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XVxuICAgICAgICAgIDogbnVsbFxuICAgICAgY29uc3QgZXhpc3RpbmdTZWdtZW50TWFwQ2hpbGQgPVxuICAgICAgICBleGlzdGluZ0NhY2hlTm9kZUNoaWxkcmVuICE9PSBudWxsXG4gICAgICAgICAgPyBleGlzdGluZ0NhY2hlTm9kZUNoaWxkcmVuLmdldChwYXJhbGxlbFJvdXRlS2V5KVxuICAgICAgICAgIDogdW5kZWZpbmVkXG4gICAgICBjb25zdCBzZWdtZW50Q2hpbGQgPSByb3V0ZXJTdGF0ZUNoaWxkWzBdXG4gICAgICBjb25zdCBzZWdtZW50UGF0aENoaWxkID0gc2VnbWVudFBhdGguY29uY2F0KFtcbiAgICAgICAgcGFyYWxsZWxSb3V0ZUtleSxcbiAgICAgICAgc2VnbWVudENoaWxkLFxuICAgICAgXSlcbiAgICAgIGNvbnN0IHNlZ21lbnRLZXlDaGlsZCA9IGNyZWF0ZVJvdXRlckNhY2hlS2V5KHNlZ21lbnRDaGlsZClcblxuICAgICAgY29uc3QgZXhpc3RpbmdDYWNoZU5vZGVDaGlsZCA9XG4gICAgICAgIGV4aXN0aW5nU2VnbWVudE1hcENoaWxkICE9PSB1bmRlZmluZWRcbiAgICAgICAgICA/IGV4aXN0aW5nU2VnbWVudE1hcENoaWxkLmdldChzZWdtZW50S2V5Q2hpbGQpXG4gICAgICAgICAgOiB1bmRlZmluZWRcblxuICAgICAgY29uc3QgdGFza0NoaWxkID0gY3JlYXRlQ2FjaGVOb2RlT25OYXZpZ2F0aW9uKFxuICAgICAgICBuYXZpZ2F0ZWRBdCxcbiAgICAgICAgcm91dGVyU3RhdGVDaGlsZCxcbiAgICAgICAgZXhpc3RpbmdDYWNoZU5vZGVDaGlsZCxcbiAgICAgICAgcHJlZmV0Y2hEYXRhQ2hpbGQsXG4gICAgICAgIHBvc3NpYmx5UGFydGlhbFByZWZldGNoSGVhZCxcbiAgICAgICAgaXNQcmVmZXRjaEhlYWRQYXJ0aWFsLFxuICAgICAgICBzZWdtZW50UGF0aENoaWxkLFxuICAgICAgICBzY3JvbGxhYmxlU2VnbWVudHNSZXN1bHRcbiAgICAgIClcbiAgICAgIHRhc2tDaGlsZHJlbi5zZXQocGFyYWxsZWxSb3V0ZUtleSwgdGFza0NoaWxkKVxuICAgICAgY29uc3QgZHluYW1pY1JlcXVlc3RUcmVlQ2hpbGQgPSB0YXNrQ2hpbGQuZHluYW1pY1JlcXVlc3RUcmVlXG4gICAgICBpZiAoZHluYW1pY1JlcXVlc3RUcmVlQ2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgLy8gU29tZXRoaW5nIGluIHRoZSBjaGlsZCB0cmVlIGlzIGR5bmFtaWMuXG4gICAgICAgIG5lZWRzRHluYW1pY1JlcXVlc3QgPSB0cnVlXG4gICAgICAgIGR5bmFtaWNSZXF1ZXN0VHJlZUNoaWxkcmVuW3BhcmFsbGVsUm91dGVLZXldID0gZHluYW1pY1JlcXVlc3RUcmVlQ2hpbGRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGR5bmFtaWNSZXF1ZXN0VHJlZUNoaWxkcmVuW3BhcmFsbGVsUm91dGVLZXldID0gcm91dGVyU3RhdGVDaGlsZFxuICAgICAgfVxuICAgICAgY29uc3QgbmV3Q2FjaGVOb2RlQ2hpbGQgPSB0YXNrQ2hpbGQubm9kZVxuICAgICAgaWYgKG5ld0NhY2hlTm9kZUNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IG5ld1NlZ21lbnRNYXBDaGlsZDogQ2hpbGRTZWdtZW50TWFwID0gbmV3IE1hcCgpXG4gICAgICAgIG5ld1NlZ21lbnRNYXBDaGlsZC5zZXQoc2VnbWVudEtleUNoaWxkLCBuZXdDYWNoZU5vZGVDaGlsZClcbiAgICAgICAgY2FjaGVOb2RlQ2hpbGRyZW4uc2V0KHBhcmFsbGVsUm91dGVLZXksIG5ld1NlZ21lbnRNYXBDaGlsZClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIC8vIFNpbmNlIHdlJ3JlIGluc2lkZSBhIG5ldyByb3V0ZSB0cmVlLCB1bmxpa2UgdGhlXG4gICAgLy8gYHVwZGF0ZUNhY2hlTm9kZU9uTmF2aWdhdGlvbmAgcGF0aCwgdGhlIHJvdXRlciBzdGF0ZSBvbiB0aGUgY2hpbGRyZW5cbiAgICAvLyB0YXNrcyBpcyBhbHdheXMgdGhlIHNhbWUgYXMgdGhlIHJvdXRlciBzdGF0ZSB3ZSBwYXNzIGluLiBTbyB3ZSBkb24ndCBuZWVkXG4gICAgLy8gdG8gY2xvbmUvbW9kaWZ5IGl0LlxuICAgIHJvdXRlOiByb3V0ZXJTdGF0ZSxcbiAgICBub2RlOiB7XG4gICAgICBsYXp5RGF0YTogbnVsbCxcbiAgICAgIC8vIFNpbmNlIHRoaXMgc2VnbWVudCBpcyBhbHJlYWR5IGZ1bGwsIHdlIGRvbid0IG5lZWQgdG8gdXNlIHRoZVxuICAgICAgLy8gYHByZWZldGNoUnNjYCBmaWVsZC5cbiAgICAgIHJzYyxcbiAgICAgIHByZWZldGNoUnNjOiBudWxsLFxuICAgICAgaGVhZCxcbiAgICAgIHByZWZldGNoSGVhZDogbnVsbCxcbiAgICAgIGxvYWRpbmcsXG4gICAgICBwYXJhbGxlbFJvdXRlczogY2FjaGVOb2RlQ2hpbGRyZW4sXG4gICAgICBuYXZpZ2F0ZWRBdDogY2FjaGVOb2RlTmF2aWdhdGVkQXQsXG4gICAgfSxcbiAgICBkeW5hbWljUmVxdWVzdFRyZWU6IG5lZWRzRHluYW1pY1JlcXVlc3RcbiAgICAgID8gcGF0Y2hSb3V0ZXJTdGF0ZVdpdGhOZXdDaGlsZHJlbihyb3V0ZXJTdGF0ZSwgZHluYW1pY1JlcXVlc3RUcmVlQ2hpbGRyZW4pXG4gICAgICA6IG51bGwsXG4gICAgY2hpbGRyZW46IHRhc2tDaGlsZHJlbixcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXRjaFJvdXRlclN0YXRlV2l0aE5ld0NoaWxkcmVuKFxuICBiYXNlUm91dGVyU3RhdGU6IEZsaWdodFJvdXRlclN0YXRlLFxuICBuZXdDaGlsZHJlbjogeyBbcGFyYWxsZWxSb3V0ZUtleTogc3RyaW5nXTogRmxpZ2h0Um91dGVyU3RhdGUgfVxuKTogRmxpZ2h0Um91dGVyU3RhdGUge1xuICBjb25zdCBjbG9uZTogRmxpZ2h0Um91dGVyU3RhdGUgPSBbYmFzZVJvdXRlclN0YXRlWzBdLCBuZXdDaGlsZHJlbl1cbiAgLy8gQmFzZWQgb24gZXF1aXZhbGVudCBsb2dpYyBpbiBhcHBseS1yb3V0ZXItc3RhdGUtcGF0Y2gtdG8tdHJlZSwgYnV0IHNob3VsZFxuICAvLyBjb25maXJtIHdoZXRoZXIgd2UgbmVlZCB0byBjb3B5IGFsbCBvZiB0aGVzZSBmaWVsZHMuIE5vdCBzdXJlIHRoZSBzZXJ2ZXJcbiAgLy8gZXZlciBzZW5kcywgZS5nLiB0aGUgcmVmZXRjaCBtYXJrZXIuXG4gIGlmICgyIGluIGJhc2VSb3V0ZXJTdGF0ZSkge1xuICAgIGNsb25lWzJdID0gYmFzZVJvdXRlclN0YXRlWzJdXG4gIH1cbiAgaWYgKDMgaW4gYmFzZVJvdXRlclN0YXRlKSB7XG4gICAgY2xvbmVbM10gPSBiYXNlUm91dGVyU3RhdGVbM11cbiAgfVxuICBpZiAoNCBpbiBiYXNlUm91dGVyU3RhdGUpIHtcbiAgICBjbG9uZVs0XSA9IGJhc2VSb3V0ZXJTdGF0ZVs0XVxuICB9XG4gIHJldHVybiBjbG9uZVxufVxuXG5mdW5jdGlvbiBzcGF3blBlbmRpbmdUYXNrKFxuICBuYXZpZ2F0ZWRBdDogbnVtYmVyLFxuICByb3V0ZXJTdGF0ZTogRmxpZ2h0Um91dGVyU3RhdGUsXG4gIHByZWZldGNoRGF0YTogQ2FjaGVOb2RlU2VlZERhdGEgfCBudWxsLFxuICBwcmVmZXRjaEhlYWQ6IEhlYWREYXRhIHwgbnVsbCxcbiAgaXNQcmVmZXRjaEhlYWRQYXJ0aWFsOiBib29sZWFuLFxuICBzZWdtZW50UGF0aDogRmxpZ2h0U2VnbWVudFBhdGgsXG4gIHNjcm9sbGFibGVTZWdtZW50c1Jlc3VsdDogQXJyYXk8RmxpZ2h0U2VnbWVudFBhdGg+XG4pOiBTUEFOYXZpZ2F0aW9uVGFzayB7XG4gIC8vIENyZWF0ZSBhIHRhc2sgdGhhdCB3aWxsIGxhdGVyIGJlIGZ1bGZpbGxlZCBieSBkYXRhIGZyb20gdGhlIHNlcnZlci5cblxuICAvLyBDbG9uZSB0aGUgcHJlZmV0Y2hlZCByb3V0ZSB0cmVlIGFuZCB0aGUgYHJlZmV0Y2hgIG1hcmtlciB0byBpdC4gV2UnbGwgc2VuZFxuICAvLyB0aGlzIHRvIHRoZSBzZXJ2ZXIgc28gaXQga25vd3Mgd2hlcmUgdG8gc3RhcnQgcmVuZGVyaW5nLlxuICBjb25zdCBkeW5hbWljUmVxdWVzdFRyZWUgPSBwYXRjaFJvdXRlclN0YXRlV2l0aE5ld0NoaWxkcmVuKFxuICAgIHJvdXRlclN0YXRlLFxuICAgIHJvdXRlclN0YXRlWzFdXG4gIClcbiAgZHluYW1pY1JlcXVlc3RUcmVlWzNdID0gJ3JlZmV0Y2gnXG5cbiAgY29uc3QgbmV3VGFzazogVGFzayA9IHtcbiAgICByb3V0ZTogcm91dGVyU3RhdGUsXG5cbiAgICAvLyBDb3JyZXNwb25kcyB0byB0aGUgcGFydCBvZiB0aGUgcm91dGUgdGhhdCB3aWxsIGJlIHJlbmRlcmVkIG9uIHRoZSBzZXJ2ZXIuXG4gICAgbm9kZTogY3JlYXRlUGVuZGluZ0NhY2hlTm9kZShcbiAgICAgIG5hdmlnYXRlZEF0LFxuICAgICAgcm91dGVyU3RhdGUsXG4gICAgICBwcmVmZXRjaERhdGEsXG4gICAgICBwcmVmZXRjaEhlYWQsXG4gICAgICBpc1ByZWZldGNoSGVhZFBhcnRpYWwsXG4gICAgICBzZWdtZW50UGF0aCxcbiAgICAgIHNjcm9sbGFibGVTZWdtZW50c1Jlc3VsdFxuICAgICksXG4gICAgLy8gQmVjYXVzZSB0aGlzIGlzIG5vbi1udWxsLCBhbmQgaXQgZ2V0cyBwcm9wYWdhdGVkIHVwIHRocm91Z2ggdGhlIHBhcmVudFxuICAgIC8vIHRhc2tzLCB0aGUgcm9vdCB0YXNrIHdpbGwga25vdyB0aGF0IGl0IG5lZWRzIHRvIHBlcmZvcm0gYSBzZXJ2ZXIgcmVxdWVzdC5cbiAgICBkeW5hbWljUmVxdWVzdFRyZWUsXG4gICAgY2hpbGRyZW46IG51bGwsXG4gIH1cbiAgcmV0dXJuIG5ld1Rhc2tcbn1cblxuZnVuY3Rpb24gc3Bhd25SZXVzZWRUYXNrKHJldXNlZFJvdXRlclN0YXRlOiBGbGlnaHRSb3V0ZXJTdGF0ZSk6IFRhc2sge1xuICAvLyBDcmVhdGUgYSB0YXNrIHRoYXQgcmV1c2VzIGFuIGV4aXN0aW5nIHNlZ21lbnQsIGUuZy4gd2hlbiByZXVzaW5nXG4gIC8vIHRoZSBjdXJyZW50IGFjdGl2ZSBzZWdtZW50IGluIHBsYWNlIG9mIGEgZGVmYXVsdCByb3V0ZS5cbiAgcmV0dXJuIHtcbiAgICByb3V0ZTogcmV1c2VkUm91dGVyU3RhdGUsXG4gICAgbm9kZTogbnVsbCxcbiAgICBkeW5hbWljUmVxdWVzdFRyZWU6IG51bGwsXG4gICAgY2hpbGRyZW46IG51bGwsXG4gIH1cbn1cblxuLy8gV3JpdGVzIGEgZHluYW1pYyBzZXJ2ZXIgcmVzcG9uc2UgaW50byB0aGUgdHJlZSBjcmVhdGVkIGJ5XG4vLyB1cGRhdGVDYWNoZU5vZGVPbk5hdmlnYXRpb24uIEFsbCBwZW5kaW5nIHByb21pc2VzIHRoYXQgd2VyZSBzcGF3bmVkIGJ5IHRoZVxuLy8gbmF2aWdhdGlvbiB3aWxsIGJlIHJlc29sdmVkLCBlaXRoZXIgd2l0aCBkeW5hbWljIGRhdGEgZnJvbSB0aGUgc2VydmVyLCBvclxuLy8gYG51bGxgIHRvIGluZGljYXRlIHRoYXQgdGhlIGRhdGEgaXMgbWlzc2luZy5cbi8vXG4vLyBBIGBudWxsYCB2YWx1ZSB3aWxsIHRyaWdnZXIgYSBsYXp5IGZldGNoIGR1cmluZyByZW5kZXIsIHdoaWNoIHdpbGwgdGhlbiBwYXRjaFxuLy8gdXAgdGhlIHRyZWUgdXNpbmcgdGhlIHNhbWUgbWVjaGFuaXNtIGFzIHRoZSBub24tUFBSIGltcGxlbWVudGF0aW9uXG4vLyAoc2VydmVyUGF0Y2hSZWR1Y2VyKS5cbi8vXG4vLyBVc3VhbGx5LCB0aGUgc2VydmVyIHdpbGwgcmVzcG9uZCB3aXRoIGV4YWN0bHkgdGhlIHN1YnNldCBvZiBkYXRhIHRoYXQgd2UncmVcbi8vIHdhaXRpbmcgZm9yIOKAlCBldmVyeXRoaW5nIGJlbG93IHRoZSBuZWFyZXN0IHNoYXJlZCBsYXlvdXQuIEJ1dCB0ZWNobmljYWxseSxcbi8vIHRoZSBzZXJ2ZXIgY2FuIHJldHVybiBhbnl0aGluZyBpdCB3YW50cy5cbi8vXG4vLyBUaGlzIGRvZXMgX25vdF8gY3JlYXRlIGEgbmV3IHRyZWU7IGl0IG1vZGlmaWVzIHRoZSBleGlzdGluZyBvbmUgaW4gcGxhY2UuXG4vLyBXaGljaCBtZWFucyBpdCBtdXN0IGZvbGxvdyB0aGUgU3VzcGVuc2UgcnVsZXMgb2YgY2FjaGUgc2FmZXR5LlxuZXhwb3J0IGZ1bmN0aW9uIGxpc3RlbkZvckR5bmFtaWNSZXF1ZXN0KFxuICB0YXNrOiBTUEFOYXZpZ2F0aW9uVGFzayxcbiAgcmVzcG9uc2VQcm9taXNlOiBQcm9taXNlPEZldGNoU2VydmVyUmVzcG9uc2VSZXN1bHQ+XG4pIHtcbiAgcmVzcG9uc2VQcm9taXNlLnRoZW4oXG4gICAgKHsgZmxpZ2h0RGF0YSB9OiBGZXRjaFNlcnZlclJlc3BvbnNlUmVzdWx0KSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGZsaWdodERhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIEhhcHBlbnMgd2hlbiBuYXZpZ2F0aW5nIHRvIHBhZ2UgaW4gYHBhZ2VzYCBmcm9tIGBhcHBgLiBXZSBzaG91bGRuJ3RcbiAgICAgICAgLy8gZ2V0IGhlcmUgYmVjYXVzZSBzaG91bGQgaGF2ZSBhbHJlYWR5IGhhbmRsZWQgdGhpcyBkdXJpbmdcbiAgICAgICAgLy8gdGhlIHByZWZldGNoLlxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3Qgbm9ybWFsaXplZEZsaWdodERhdGEgb2YgZmxpZ2h0RGF0YSkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgc2VnbWVudFBhdGgsXG4gICAgICAgICAgdHJlZTogc2VydmVyUm91dGVyU3RhdGUsXG4gICAgICAgICAgc2VlZERhdGE6IGR5bmFtaWNEYXRhLFxuICAgICAgICAgIGhlYWQ6IGR5bmFtaWNIZWFkLFxuICAgICAgICB9ID0gbm9ybWFsaXplZEZsaWdodERhdGFcblxuICAgICAgICBpZiAoIWR5bmFtaWNEYXRhKSB7XG4gICAgICAgICAgLy8gVGhpcyBzaG91bGRuJ3QgaGFwcGVuLiBQUFIgc2hvdWxkIGFsd2F5cyBzZW5kIGJhY2sgYSByZXNwb25zZS5cbiAgICAgICAgICAvLyBIb3dldmVyLCBgRmxpZ2h0RGF0YVBhdGhgIGlzIGEgc2hhcmVkIHR5cGUgYW5kIHRoZSBwcmUtUFBSIGhhbmRsaW5nIG9mXG4gICAgICAgICAgLy8gdGhpcyBtaWdodCByZXR1cm4gbnVsbC5cbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgd3JpdGVEeW5hbWljRGF0YUludG9QZW5kaW5nVGFzayhcbiAgICAgICAgICB0YXNrLFxuICAgICAgICAgIHNlZ21lbnRQYXRoLFxuICAgICAgICAgIHNlcnZlclJvdXRlclN0YXRlLFxuICAgICAgICAgIGR5bmFtaWNEYXRhLFxuICAgICAgICAgIGR5bmFtaWNIZWFkXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgLy8gTm93IHRoYXQgd2UndmUgZXhoYXVzdGVkIGFsbCB0aGUgZGF0YSB3ZSByZWNlaXZlZCBmcm9tIHRoZSBzZXJ2ZXIsIGlmXG4gICAgICAvLyB0aGVyZSBhcmUgYW55IHJlbWFpbmluZyBwZW5kaW5nIHRhc2tzIGluIHRoZSB0cmVlLCBhYm9ydCB0aGVtIG5vdy5cbiAgICAgIC8vIElmIHRoZXJlJ3MgYW55IG1pc3NpbmcgZGF0YSwgaXQgd2lsbCB0cmlnZ2VyIGEgbGF6eSBmZXRjaC5cbiAgICAgIGFib3J0VGFzayh0YXNrLCBudWxsKVxuICAgIH0sXG4gICAgKGVycm9yOiBhbnkpID0+IHtcbiAgICAgIC8vIFRoaXMgd2lsbCB0cmlnZ2VyIGFuIGVycm9yIGR1cmluZyByZW5kZXJcbiAgICAgIGFib3J0VGFzayh0YXNrLCBlcnJvcilcbiAgICB9XG4gIClcbn1cblxuZnVuY3Rpb24gd3JpdGVEeW5hbWljRGF0YUludG9QZW5kaW5nVGFzayhcbiAgcm9vdFRhc2s6IFNQQU5hdmlnYXRpb25UYXNrLFxuICBzZWdtZW50UGF0aDogRmxpZ2h0U2VnbWVudFBhdGgsXG4gIHNlcnZlclJvdXRlclN0YXRlOiBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgZHluYW1pY0RhdGE6IENhY2hlTm9kZVNlZWREYXRhLFxuICBkeW5hbWljSGVhZDogSGVhZERhdGFcbikge1xuICAvLyBUaGUgZGF0YSBzZW50IGJ5IHRoZSBzZXJ2ZXIgcmVwcmVzZW50cyBvbmx5IGEgc3VidHJlZSBvZiB0aGUgYXBwLiBXZSBuZWVkXG4gIC8vIHRvIGZpbmQgdGhlIHBhcnQgb2YgdGhlIHRhc2sgdHJlZSB0aGF0IG1hdGNoZXMgdGhlIHNlcnZlciByZXNwb25zZSwgYW5kXG4gIC8vIGZ1bGZpbGwgaXQgdXNpbmcgdGhlIGR5bmFtaWMgZGF0YS5cbiAgLy9cbiAgLy8gc2VnbWVudFBhdGggcmVwcmVzZW50cyB0aGUgcGFyZW50IHBhdGggb2Ygc3VidHJlZS4gSXQncyBhIHJlcGVhdGluZyBwYXR0ZXJuXG4gIC8vIG9mIHBhcmFsbGVsIHJvdXRlIGtleSBhbmQgc2VnbWVudDpcbiAgLy9cbiAgLy8gICBbc3RyaW5nLCBTZWdtZW50LCBzdHJpbmcsIFNlZ21lbnQsIHN0cmluZywgU2VnbWVudCwgLi4uXVxuICAvL1xuICAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIHBhdGggYW5kIGZpbmlzaCBhbnkgdGFza3MgdGhhdCBtYXRjaCB0aGlzIHBheWxvYWQuXG4gIGxldCB0YXNrID0gcm9vdFRhc2tcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50UGF0aC5sZW5ndGg7IGkgKz0gMikge1xuICAgIGNvbnN0IHBhcmFsbGVsUm91dGVLZXk6IHN0cmluZyA9IHNlZ21lbnRQYXRoW2ldXG4gICAgY29uc3Qgc2VnbWVudDogU2VnbWVudCA9IHNlZ21lbnRQYXRoW2kgKyAxXVxuICAgIGNvbnN0IHRhc2tDaGlsZHJlbiA9IHRhc2suY2hpbGRyZW5cbiAgICBpZiAodGFza0NoaWxkcmVuICE9PSBudWxsKSB7XG4gICAgICBjb25zdCB0YXNrQ2hpbGQgPSB0YXNrQ2hpbGRyZW4uZ2V0KHBhcmFsbGVsUm91dGVLZXkpXG4gICAgICBpZiAodGFza0NoaWxkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgdGFza1NlZ21lbnQgPSB0YXNrQ2hpbGQucm91dGVbMF1cbiAgICAgICAgaWYgKG1hdGNoU2VnbWVudChzZWdtZW50LCB0YXNrU2VnbWVudCkpIHtcbiAgICAgICAgICAvLyBGb3VuZCBhIG1hdGNoIGZvciB0aGlzIHRhc2suIEtlZXAgdHJhdmVyc2luZyBkb3duIHRoZSB0YXNrIHRyZWUuXG4gICAgICAgICAgdGFzayA9IHRhc2tDaGlsZFxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gV2UgZGlkbid0IGZpbmQgYSBjaGlsZCB0YXNrIHRoYXQgbWF0Y2hlcyB0aGUgc2VydmVyIGRhdGEuIEV4aXQuIFdlIHdvbid0XG4gICAgLy8gYWJvcnQgdGhlIHRhc2ssIHRob3VnaCwgYmVjYXVzZSBhIGRpZmZlcmVudCBGbGlnaHREYXRhUGF0aCBtYXkgYmUgYWJsZSB0b1xuICAgIC8vIGZ1bGZpbGwgaXQgKHNlZSBsb29wIGluIGxpc3RlbkZvckR5bmFtaWNSZXF1ZXN0KS4gV2Ugb25seSBhYm9ydCB0YXNrc1xuICAgIC8vIG9uY2Ugd2UndmUgcnVuIG91dCBvZiBkYXRhLlxuICAgIHJldHVyblxuICB9XG5cbiAgZmluaXNoVGFza1VzaW5nRHluYW1pY0RhdGFQYXlsb2FkKFxuICAgIHRhc2ssXG4gICAgc2VydmVyUm91dGVyU3RhdGUsXG4gICAgZHluYW1pY0RhdGEsXG4gICAgZHluYW1pY0hlYWRcbiAgKVxufVxuXG5mdW5jdGlvbiBmaW5pc2hUYXNrVXNpbmdEeW5hbWljRGF0YVBheWxvYWQoXG4gIHRhc2s6IFNQQU5hdmlnYXRpb25UYXNrLFxuICBzZXJ2ZXJSb3V0ZXJTdGF0ZTogRmxpZ2h0Um91dGVyU3RhdGUsXG4gIGR5bmFtaWNEYXRhOiBDYWNoZU5vZGVTZWVkRGF0YSxcbiAgZHluYW1pY0hlYWQ6IEhlYWREYXRhXG4pIHtcbiAgaWYgKHRhc2suZHluYW1pY1JlcXVlc3RUcmVlID09PSBudWxsKSB7XG4gICAgLy8gRXZlcnl0aGluZyBpbiB0aGlzIHN1YnRyZWUgaXMgYWxyZWFkeSBjb21wbGV0ZS4gQmFpbCBvdXQuXG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBkeW5hbWljRGF0YSBtYXkgcmVwcmVzZW50IGEgbGFyZ2VyIHN1YnRyZWUgdGhhbiB0aGUgdGFzay4gQmVmb3JlIHdlIGNhblxuICAvLyBmaW5pc2ggdGhlIHRhc2ssIHdlIG5lZWQgdG8gbGluZSB0aGVtIHVwLlxuICBjb25zdCB0YXNrQ2hpbGRyZW4gPSB0YXNrLmNoaWxkcmVuXG4gIGNvbnN0IHRhc2tOb2RlID0gdGFzay5ub2RlXG4gIGlmICh0YXNrQ2hpbGRyZW4gPT09IG51bGwpIHtcbiAgICAvLyBXZSd2ZSByZWFjaGVkIHRoZSBsZWFmIG5vZGUgb2YgdGhlIHBlbmRpbmcgdGFzay4gVGhlIHNlcnZlciBkYXRhIHRyZWVcbiAgICAvLyBsaW5lcyB1cCB0aGUgcGVuZGluZyBDYWNoZSBOb2RlIHRyZWUuIFdlIGNhbiBub3cgc3dpdGNoIHRvIHRoZVxuICAgIC8vIG5vcm1hbCBhbGdvcml0aG0uXG4gICAgaWYgKHRhc2tOb2RlICE9PSBudWxsKSB7XG4gICAgICBmaW5pc2hQZW5kaW5nQ2FjaGVOb2RlKFxuICAgICAgICB0YXNrTm9kZSxcbiAgICAgICAgdGFzay5yb3V0ZSxcbiAgICAgICAgc2VydmVyUm91dGVyU3RhdGUsXG4gICAgICAgIGR5bmFtaWNEYXRhLFxuICAgICAgICBkeW5hbWljSGVhZFxuICAgICAgKVxuICAgICAgLy8gU2V0IHRoaXMgdG8gbnVsbCB0byBpbmRpY2F0ZSB0aGF0IHRoaXMgdGFzayBpcyBub3cgY29tcGxldGUuXG4gICAgICB0YXNrLmR5bmFtaWNSZXF1ZXN0VHJlZSA9IG51bGxcbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cbiAgLy8gVGhlIHNlcnZlciByZXR1cm5lZCBtb3JlIGRhdGEgdGhhbiB3ZSBuZWVkIHRvIGZpbmlzaCB0aGUgdGFzay4gU2tpcCBvdmVyXG4gIC8vIHRoZSBleHRyYSBzZWdtZW50cyB1bnRpbCB3ZSByZWFjaCB0aGUgbGVhZiB0YXNrIG5vZGUuXG4gIGNvbnN0IHNlcnZlckNoaWxkcmVuID0gc2VydmVyUm91dGVyU3RhdGVbMV1cbiAgY29uc3QgZHluYW1pY0RhdGFDaGlsZHJlbiA9IGR5bmFtaWNEYXRhWzJdXG5cbiAgZm9yIChjb25zdCBwYXJhbGxlbFJvdXRlS2V5IGluIHNlcnZlclJvdXRlclN0YXRlKSB7XG4gICAgY29uc3Qgc2VydmVyUm91dGVyU3RhdGVDaGlsZDogRmxpZ2h0Um91dGVyU3RhdGUgPVxuICAgICAgc2VydmVyQ2hpbGRyZW5bcGFyYWxsZWxSb3V0ZUtleV1cbiAgICBjb25zdCBkeW5hbWljRGF0YUNoaWxkOiBDYWNoZU5vZGVTZWVkRGF0YSB8IG51bGwgfCB2b2lkID1cbiAgICAgIGR5bmFtaWNEYXRhQ2hpbGRyZW5bcGFyYWxsZWxSb3V0ZUtleV1cblxuICAgIGNvbnN0IHRhc2tDaGlsZCA9IHRhc2tDaGlsZHJlbi5nZXQocGFyYWxsZWxSb3V0ZUtleSlcbiAgICBpZiAodGFza0NoaWxkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IHRhc2tTZWdtZW50ID0gdGFza0NoaWxkLnJvdXRlWzBdXG4gICAgICBpZiAoXG4gICAgICAgIG1hdGNoU2VnbWVudChzZXJ2ZXJSb3V0ZXJTdGF0ZUNoaWxkWzBdLCB0YXNrU2VnbWVudCkgJiZcbiAgICAgICAgZHluYW1pY0RhdGFDaGlsZCAhPT0gbnVsbCAmJlxuICAgICAgICBkeW5hbWljRGF0YUNoaWxkICE9PSB1bmRlZmluZWRcbiAgICAgICkge1xuICAgICAgICAvLyBGb3VuZCBhIG1hdGNoIGZvciB0aGlzIHRhc2suIEtlZXAgdHJhdmVyc2luZyBkb3duIHRoZSB0YXNrIHRyZWUuXG4gICAgICAgIHJldHVybiBmaW5pc2hUYXNrVXNpbmdEeW5hbWljRGF0YVBheWxvYWQoXG4gICAgICAgICAgdGFza0NoaWxkLFxuICAgICAgICAgIHNlcnZlclJvdXRlclN0YXRlQ2hpbGQsXG4gICAgICAgICAgZHluYW1pY0RhdGFDaGlsZCxcbiAgICAgICAgICBkeW5hbWljSGVhZFxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuICAgIC8vIFdlIGRpZG4ndCBmaW5kIGEgY2hpbGQgdGFzayB0aGF0IG1hdGNoZXMgdGhlIHNlcnZlciBkYXRhLiBXZSB3b24ndCBhYm9ydFxuICAgIC8vIHRoZSB0YXNrLCB0aG91Z2gsIGJlY2F1c2UgYSBkaWZmZXJlbnQgRmxpZ2h0RGF0YVBhdGggbWF5IGJlIGFibGUgdG9cbiAgICAvLyBmdWxmaWxsIGl0IChzZWUgbG9vcCBpbiBsaXN0ZW5Gb3JEeW5hbWljUmVxdWVzdCkuIFdlIG9ubHkgYWJvcnQgdGFza3NcbiAgICAvLyBvbmNlIHdlJ3ZlIHJ1biBvdXQgb2YgZGF0YS5cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVQZW5kaW5nQ2FjaGVOb2RlKFxuICBuYXZpZ2F0ZWRBdDogbnVtYmVyLFxuICByb3V0ZXJTdGF0ZTogRmxpZ2h0Um91dGVyU3RhdGUsXG4gIHByZWZldGNoRGF0YTogQ2FjaGVOb2RlU2VlZERhdGEgfCBudWxsLFxuICBwcmVmZXRjaEhlYWQ6IEhlYWREYXRhIHwgbnVsbCxcbiAgaXNQcmVmZXRjaEhlYWRQYXJ0aWFsOiBib29sZWFuLFxuICBzZWdtZW50UGF0aDogRmxpZ2h0U2VnbWVudFBhdGgsXG4gIHNjcm9sbGFibGVTZWdtZW50c1Jlc3VsdDogQXJyYXk8RmxpZ2h0U2VnbWVudFBhdGg+XG4pOiBSZWFkeUNhY2hlTm9kZSB7XG4gIGNvbnN0IHJvdXRlclN0YXRlQ2hpbGRyZW4gPSByb3V0ZXJTdGF0ZVsxXVxuICBjb25zdCBwcmVmZXRjaERhdGFDaGlsZHJlbiA9IHByZWZldGNoRGF0YSAhPT0gbnVsbCA/IHByZWZldGNoRGF0YVsyXSA6IG51bGxcblxuICBjb25zdCBwYXJhbGxlbFJvdXRlcyA9IG5ldyBNYXAoKVxuICBmb3IgKGxldCBwYXJhbGxlbFJvdXRlS2V5IGluIHJvdXRlclN0YXRlQ2hpbGRyZW4pIHtcbiAgICBjb25zdCByb3V0ZXJTdGF0ZUNoaWxkOiBGbGlnaHRSb3V0ZXJTdGF0ZSA9XG4gICAgICByb3V0ZXJTdGF0ZUNoaWxkcmVuW3BhcmFsbGVsUm91dGVLZXldXG4gICAgY29uc3QgcHJlZmV0Y2hEYXRhQ2hpbGQ6IENhY2hlTm9kZVNlZWREYXRhIHwgbnVsbCB8IHZvaWQgPVxuICAgICAgcHJlZmV0Y2hEYXRhQ2hpbGRyZW4gIT09IG51bGxcbiAgICAgICAgPyBwcmVmZXRjaERhdGFDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XVxuICAgICAgICA6IG51bGxcblxuICAgIGNvbnN0IHNlZ21lbnRDaGlsZCA9IHJvdXRlclN0YXRlQ2hpbGRbMF1cbiAgICBjb25zdCBzZWdtZW50UGF0aENoaWxkID0gc2VnbWVudFBhdGguY29uY2F0KFtcbiAgICAgIHBhcmFsbGVsUm91dGVLZXksXG4gICAgICBzZWdtZW50Q2hpbGQsXG4gICAgXSlcbiAgICBjb25zdCBzZWdtZW50S2V5Q2hpbGQgPSBjcmVhdGVSb3V0ZXJDYWNoZUtleShzZWdtZW50Q2hpbGQpXG5cbiAgICBjb25zdCBuZXdDYWNoZU5vZGVDaGlsZCA9IGNyZWF0ZVBlbmRpbmdDYWNoZU5vZGUoXG4gICAgICBuYXZpZ2F0ZWRBdCxcbiAgICAgIHJvdXRlclN0YXRlQ2hpbGQsXG4gICAgICBwcmVmZXRjaERhdGFDaGlsZCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IHByZWZldGNoRGF0YUNoaWxkLFxuICAgICAgcHJlZmV0Y2hIZWFkLFxuICAgICAgaXNQcmVmZXRjaEhlYWRQYXJ0aWFsLFxuICAgICAgc2VnbWVudFBhdGhDaGlsZCxcbiAgICAgIHNjcm9sbGFibGVTZWdtZW50c1Jlc3VsdFxuICAgIClcblxuICAgIGNvbnN0IG5ld1NlZ21lbnRNYXBDaGlsZDogQ2hpbGRTZWdtZW50TWFwID0gbmV3IE1hcCgpXG4gICAgbmV3U2VnbWVudE1hcENoaWxkLnNldChzZWdtZW50S2V5Q2hpbGQsIG5ld0NhY2hlTm9kZUNoaWxkKVxuICAgIHBhcmFsbGVsUm91dGVzLnNldChwYXJhbGxlbFJvdXRlS2V5LCBuZXdTZWdtZW50TWFwQ2hpbGQpXG4gIH1cblxuICAvLyBUaGUgaGVhZCBpcyBhc3NpZ25lZCB0byBldmVyeSBsZWFmIHNlZ21lbnQgZGVsaXZlcmVkIGJ5IHRoZSBzZXJ2ZXIuIEJhc2VkXG4gIC8vIG9uIGNvcnJlc3BvbmRpbmcgbG9naWMgaW4gZmlsbC1sYXp5LWl0ZW1zLXRpbGwtbGVhZi13aXRoLWhlYWQudHNcbiAgY29uc3QgaXNMZWFmU2VnbWVudCA9IHBhcmFsbGVsUm91dGVzLnNpemUgPT09IDBcblxuICBpZiAoaXNMZWFmU2VnbWVudCkge1xuICAgIC8vIFRoZSBzZWdtZW50IHBhdGggb2YgZXZlcnkgbGVhZiBzZWdtZW50IChpLmUuIHBhZ2UpIGlzIGNvbGxlY3RlZCBpbnRvXG4gICAgLy8gYSByZXN1bHQgYXJyYXkuIFRoaXMgaXMgdXNlZCBieSB0aGUgTGF5b3V0Um91dGVyIHRvIHNjcm9sbCB0byBlbnN1cmUgdGhhdFxuICAgIC8vIG5ldyBwYWdlcyBhcmUgdmlzaWJsZSBhZnRlciBhIG5hdmlnYXRpb24uXG4gICAgLy8gVE9ETzogV2Ugc2hvdWxkIHVzZSBhIHN0cmluZyB0byByZXByZXNlbnQgdGhlIHNlZ21lbnQgcGF0aCBpbnN0ZWFkIG9mXG4gICAgLy8gYW4gYXJyYXkuIFdlIGFscmVhZHkgdXNlIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIGZvciB0aGUgcGF0aCB3aGVuXG4gICAgLy8gYWNjZXNzaW5nIHRoZSBTZWdtZW50IENhY2hlLCBzbyB3ZSBjYW4gdXNlIHRoZSBzYW1lIG9uZS5cbiAgICBzY3JvbGxhYmxlU2VnbWVudHNSZXN1bHQucHVzaChzZWdtZW50UGF0aClcbiAgfVxuXG4gIGNvbnN0IG1heWJlUHJlZmV0Y2hSc2MgPSBwcmVmZXRjaERhdGEgIT09IG51bGwgPyBwcmVmZXRjaERhdGFbMV0gOiBudWxsXG4gIGNvbnN0IG1heWJlUHJlZmV0Y2hMb2FkaW5nID0gcHJlZmV0Y2hEYXRhICE9PSBudWxsID8gcHJlZmV0Y2hEYXRhWzNdIDogbnVsbFxuICByZXR1cm4ge1xuICAgIGxhenlEYXRhOiBudWxsLFxuICAgIHBhcmFsbGVsUm91dGVzOiBwYXJhbGxlbFJvdXRlcyxcblxuICAgIHByZWZldGNoUnNjOiBtYXliZVByZWZldGNoUnNjICE9PSB1bmRlZmluZWQgPyBtYXliZVByZWZldGNoUnNjIDogbnVsbCxcbiAgICBwcmVmZXRjaEhlYWQ6IGlzTGVhZlNlZ21lbnQgPyBwcmVmZXRjaEhlYWQgOiBbbnVsbCwgbnVsbF0sXG5cbiAgICAvLyBUT0RPOiBUZWNobmljYWxseSwgYSBsb2FkaW5nIGJvdW5kYXJ5IGNvdWxkIGNvbnRhaW4gZHluYW1pYyBkYXRhLiBXZSBtdXN0XG4gICAgLy8gaGF2ZSBzZXBhcmF0ZSBgbG9hZGluZ2AgYW5kIGBwcmVmZXRjaExvYWRpbmdgIGZpZWxkcyB0byBoYW5kbGUgdGhpcywgbGlrZVxuICAgIC8vIHdlIGRvIGZvciB0aGUgc2VnbWVudCBkYXRhIGFuZCBoZWFkLlxuICAgIGxvYWRpbmc6IG1heWJlUHJlZmV0Y2hMb2FkaW5nICE9PSB1bmRlZmluZWQgPyBtYXliZVByZWZldGNoTG9hZGluZyA6IG51bGwsXG5cbiAgICAvLyBDcmVhdGUgYSBkZWZlcnJlZCBwcm9taXNlLiBUaGlzIHdpbGwgYmUgZnVsZmlsbGVkIG9uY2UgdGhlIGR5bmFtaWNcbiAgICAvLyByZXNwb25zZSBpcyByZWNlaXZlZCBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgcnNjOiBjcmVhdGVEZWZlcnJlZFJzYygpIGFzIFJlYWN0LlJlYWN0Tm9kZSxcbiAgICBoZWFkOiBpc0xlYWZTZWdtZW50ID8gKGNyZWF0ZURlZmVycmVkUnNjKCkgYXMgUmVhY3QuUmVhY3ROb2RlKSA6IG51bGwsXG5cbiAgICBuYXZpZ2F0ZWRBdCxcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5pc2hQZW5kaW5nQ2FjaGVOb2RlKFxuICBjYWNoZU5vZGU6IENhY2hlTm9kZSxcbiAgdGFza1N0YXRlOiBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgc2VydmVyU3RhdGU6IEZsaWdodFJvdXRlclN0YXRlLFxuICBkeW5hbWljRGF0YTogQ2FjaGVOb2RlU2VlZERhdGEsXG4gIGR5bmFtaWNIZWFkOiBIZWFkRGF0YVxuKTogdm9pZCB7XG4gIC8vIFdyaXRlcyBhIGR5bmFtaWMgcmVzcG9uc2UgaW50byBhbiBleGlzdGluZyBDYWNoZSBOb2RlIHRyZWUuIFRoaXMgZG9lcyBfbm90X1xuICAvLyBjcmVhdGUgYSBuZXcgdHJlZSwgaXQgdXBkYXRlcyB0aGUgZXhpc3RpbmcgdHJlZSBpbi1wbGFjZS4gU28gaXQgbXVzdCBmb2xsb3dcbiAgLy8gdGhlIFN1c3BlbnNlIHJ1bGVzIG9mIGNhY2hlIHNhZmV0eSDigJQgaXQgY2FuIHJlc29sdmUgcGVuZGluZyBwcm9taXNlcywgYnV0XG4gIC8vIGl0IGNhbm5vdCBvdmVyd3JpdGUgZXhpc3RpbmcgZGF0YS4gSXQgY2FuIGFkZCBzZWdtZW50cyB0byB0aGUgdHJlZSAoYmVjYXVzZVxuICAvLyBhIG1pc3Npbmcgc2VnbWVudCB3aWxsIGNhdXNlIHRoZSBsYXlvdXQgcm91dGVyIHRvIHN1c3BlbmQpLlxuICAvLyBidXQgaXQgY2Fubm90IGRlbGV0ZSB0aGVtLlxuICAvL1xuICAvLyBXZSBtdXN0IHJlc29sdmUgZXZlcnkgcHJvbWlzZSBpbiB0aGUgdHJlZSwgb3IgZWxzZSBpdCB3aWxsIHN1c3BlbmRcbiAgLy8gaW5kZWZpbml0ZWx5LiBJZiB3ZSBkaWQgbm90IHJlY2VpdmUgZGF0YSBmb3IgYSBzZWdtZW50LCB3ZSB3aWxsIHJlc29sdmUgaXRzXG4gIC8vIGRhdGEgcHJvbWlzZSB0byBgbnVsbGAgdG8gdHJpZ2dlciBhIGxhenkgZmV0Y2ggZHVyaW5nIHJlbmRlci5cbiAgY29uc3QgdGFza1N0YXRlQ2hpbGRyZW4gPSB0YXNrU3RhdGVbMV1cbiAgY29uc3Qgc2VydmVyU3RhdGVDaGlsZHJlbiA9IHNlcnZlclN0YXRlWzFdXG4gIGNvbnN0IGRhdGFDaGlsZHJlbiA9IGR5bmFtaWNEYXRhWzJdXG5cbiAgLy8gVGhlIHJvdXRlciBzdGF0ZSB0aGF0IHdlIHRyYXZlcnNlIHRoZSB0cmVlIHdpdGggKHRhc2tTdGF0ZSkgaXMgdGhlIHNhbWUgb25lXG4gIC8vIHRoYXQgd2UgdXNlZCB0byBjb25zdHJ1Y3QgdGhlIHBlbmRpbmcgQ2FjaGUgTm9kZSB0cmVlLiBUaGF0IHdheSB3ZSdyZSBzdXJlXG4gIC8vIHRvIHJlc29sdmUgYWxsIHRoZSBwZW5kaW5nIHByb21pc2VzLlxuICBjb25zdCBwYXJhbGxlbFJvdXRlcyA9IGNhY2hlTm9kZS5wYXJhbGxlbFJvdXRlc1xuICBmb3IgKGxldCBwYXJhbGxlbFJvdXRlS2V5IGluIHRhc2tTdGF0ZUNoaWxkcmVuKSB7XG4gICAgY29uc3QgdGFza1N0YXRlQ2hpbGQ6IEZsaWdodFJvdXRlclN0YXRlID1cbiAgICAgIHRhc2tTdGF0ZUNoaWxkcmVuW3BhcmFsbGVsUm91dGVLZXldXG4gICAgY29uc3Qgc2VydmVyU3RhdGVDaGlsZDogRmxpZ2h0Um91dGVyU3RhdGUgfCB2b2lkID1cbiAgICAgIHNlcnZlclN0YXRlQ2hpbGRyZW5bcGFyYWxsZWxSb3V0ZUtleV1cbiAgICBjb25zdCBkYXRhQ2hpbGQ6IENhY2hlTm9kZVNlZWREYXRhIHwgbnVsbCB8IHZvaWQgPVxuICAgICAgZGF0YUNoaWxkcmVuW3BhcmFsbGVsUm91dGVLZXldXG5cbiAgICBjb25zdCBzZWdtZW50TWFwQ2hpbGQgPSBwYXJhbGxlbFJvdXRlcy5nZXQocGFyYWxsZWxSb3V0ZUtleSlcbiAgICBjb25zdCB0YXNrU2VnbWVudENoaWxkID0gdGFza1N0YXRlQ2hpbGRbMF1cbiAgICBjb25zdCB0YXNrU2VnbWVudEtleUNoaWxkID0gY3JlYXRlUm91dGVyQ2FjaGVLZXkodGFza1NlZ21lbnRDaGlsZClcblxuICAgIGNvbnN0IGNhY2hlTm9kZUNoaWxkID1cbiAgICAgIHNlZ21lbnRNYXBDaGlsZCAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gc2VnbWVudE1hcENoaWxkLmdldCh0YXNrU2VnbWVudEtleUNoaWxkKVxuICAgICAgICA6IHVuZGVmaW5lZFxuXG4gICAgaWYgKGNhY2hlTm9kZUNoaWxkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChcbiAgICAgICAgc2VydmVyU3RhdGVDaGlsZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIG1hdGNoU2VnbWVudCh0YXNrU2VnbWVudENoaWxkLCBzZXJ2ZXJTdGF0ZUNoaWxkWzBdKVxuICAgICAgKSB7XG4gICAgICAgIGlmIChkYXRhQ2hpbGQgIT09IHVuZGVmaW5lZCAmJiBkYXRhQ2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBoYXBweSBwYXRoLiBSZWN1cnNpdmVseSB1cGRhdGUgYWxsIHRoZSBjaGlsZHJlbi5cbiAgICAgICAgICBmaW5pc2hQZW5kaW5nQ2FjaGVOb2RlKFxuICAgICAgICAgICAgY2FjaGVOb2RlQ2hpbGQsXG4gICAgICAgICAgICB0YXNrU3RhdGVDaGlsZCxcbiAgICAgICAgICAgIHNlcnZlclN0YXRlQ2hpbGQsXG4gICAgICAgICAgICBkYXRhQ2hpbGQsXG4gICAgICAgICAgICBkeW5hbWljSGVhZFxuICAgICAgICAgIClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUaGUgc2VydmVyIG5ldmVyIHJldHVybmVkIGRhdGEgZm9yIHRoaXMgc2VnbWVudC4gVHJpZ2dlciBhIGxhenlcbiAgICAgICAgICAvLyBmZXRjaCBkdXJpbmcgcmVuZGVyLiBUaGlzIHNob3VsZG4ndCBoYXBwZW4gYmVjYXVzZSB0aGUgUm91dGUgVHJlZVxuICAgICAgICAgIC8vIGFuZCB0aGUgU2VlZCBEYXRhIHRyZWUgc2VudCBieSB0aGUgc2VydmVyIHNob3VsZCBhbHdheXMgYmUgdGhlIHNhbWVcbiAgICAgICAgICAvLyBzaGFwZSB3aGVuIHBhcnQgb2YgdGhlIHNhbWUgc2VydmVyIHJlc3BvbnNlLlxuICAgICAgICAgIGFib3J0UGVuZGluZ0NhY2hlTm9kZSh0YXNrU3RhdGVDaGlsZCwgY2FjaGVOb2RlQ2hpbGQsIG51bGwpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoZSBzZXJ2ZXIgbmV2ZXIgcmV0dXJuZWQgZGF0YSBmb3IgdGhpcyBzZWdtZW50LiBUcmlnZ2VyIGEgbGF6eVxuICAgICAgICAvLyBmZXRjaCBkdXJpbmcgcmVuZGVyLlxuICAgICAgICBhYm9ydFBlbmRpbmdDYWNoZU5vZGUodGFza1N0YXRlQ2hpbGQsIGNhY2hlTm9kZUNoaWxkLCBudWxsKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgc2VydmVyIHJlc3BvbnNlIG1hdGNoZXMgd2hhdCB3YXMgZXhwZWN0ZWQgdG8gcmVjZWl2ZSwgYnV0IHRoZXJlJ3NcbiAgICAgIC8vIG5vIG1hdGNoaW5nIENhY2hlIE5vZGUgaW4gdGhlIHRhc2sgdHJlZS4gVGhpcyBpcyBhIGJ1ZyBpbiB0aGVcbiAgICAgIC8vIGltcGxlbWVudGF0aW9uIGJlY2F1c2Ugd2Ugc2hvdWxkIGhhdmUgY3JlYXRlZCBhIG5vZGUgZm9yIGV2ZXJ5XG4gICAgICAvLyBzZWdtZW50IGluIHRoZSB0cmVlIHRoYXQncyBhc3NvY2lhdGVkIHdpdGggdGhpcyB0YXNrLlxuICAgIH1cbiAgfVxuXG4gIC8vIFVzZSB0aGUgZHluYW1pYyBkYXRhIGZyb20gdGhlIHNlcnZlciB0byBmdWxmaWxsIHRoZSBkZWZlcnJlZCBSU0MgcHJvbWlzZVxuICAvLyBvbiB0aGUgQ2FjaGUgTm9kZS5cbiAgY29uc3QgcnNjID0gY2FjaGVOb2RlLnJzY1xuICBjb25zdCBkeW5hbWljU2VnbWVudERhdGEgPSBkeW5hbWljRGF0YVsxXVxuICBpZiAocnNjID09PSBudWxsKSB7XG4gICAgLy8gVGhpcyBpcyBhIGxhenkgY2FjaGUgbm9kZS4gV2UgY2FuIG92ZXJ3cml0ZSBpdC4gVGhpcyBpcyBvbmx5IHNhZmVcbiAgICAvLyBiZWNhdXNlIHdlIGtub3cgdGhhdCB0aGUgTGF5b3V0Um91dGVyIHN1c3BlbmRzIGlmIGByc2NgIGlzIGBudWxsYC5cbiAgICBjYWNoZU5vZGUucnNjID0gZHluYW1pY1NlZ21lbnREYXRhXG4gIH0gZWxzZSBpZiAoaXNEZWZlcnJlZFJzYyhyc2MpKSB7XG4gICAgLy8gVGhpcyBpcyBhIGRlZmVycmVkIFJTQyBwcm9taXNlLiBXZSBjYW4gZnVsZmlsbCBpdCB3aXRoIHRoZSBkYXRhIHdlIGp1c3RcbiAgICAvLyByZWNlaXZlZCBmcm9tIHRoZSBzZXJ2ZXIuIElmIGl0IHdhcyBhbHJlYWR5IHJlc29sdmVkIGJ5IGEgZGlmZmVyZW50XG4gICAgLy8gbmF2aWdhdGlvbiwgdGhlbiB0aGlzIGRvZXMgbm90aGluZyBiZWNhdXNlIHdlIGNhbid0IG92ZXJ3cml0ZSBkYXRhLlxuICAgIHJzYy5yZXNvbHZlKGR5bmFtaWNTZWdtZW50RGF0YSlcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGlzIGlzIG5vdCBhIGRlZmVycmVkIFJTQyBwcm9taXNlLCBub3IgaXMgaXQgZW1wdHksIHNvIGl0IG11c3QgaGF2ZVxuICAgIC8vIGJlZW4gcG9wdWxhdGVkIGJ5IGEgZGlmZmVyZW50IG5hdmlnYXRpb24uIFdlIG11c3Qgbm90IG92ZXJ3cml0ZSBpdC5cbiAgfVxuXG4gIC8vIENoZWNrIGlmIHRoaXMgaXMgYSBsZWFmIHNlZ21lbnQuIElmIHNvLCBpdCB3aWxsIGhhdmUgYSBgaGVhZGAgcHJvcGVydHkgd2l0aFxuICAvLyBhIHBlbmRpbmcgcHJvbWlzZSB0aGF0IG5lZWRzIHRvIGJlIHJlc29sdmVkIHdpdGggdGhlIGR5bmFtaWMgaGVhZCBmcm9tXG4gIC8vIHRoZSBzZXJ2ZXIuXG4gIGNvbnN0IGhlYWQgPSBjYWNoZU5vZGUuaGVhZFxuICBpZiAoaXNEZWZlcnJlZFJzYyhoZWFkKSkge1xuICAgIGhlYWQucmVzb2x2ZShkeW5hbWljSGVhZClcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYWJvcnRUYXNrKHRhc2s6IFNQQU5hdmlnYXRpb25UYXNrLCBlcnJvcjogYW55KTogdm9pZCB7XG4gIGNvbnN0IGNhY2hlTm9kZSA9IHRhc2subm9kZVxuICBpZiAoY2FjaGVOb2RlID09PSBudWxsKSB7XG4gICAgLy8gVGhpcyBpbmRpY2F0ZXMgdGhlIHRhc2sgaXMgYWxyZWFkeSBjb21wbGV0ZS5cbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IHRhc2tDaGlsZHJlbiA9IHRhc2suY2hpbGRyZW5cbiAgaWYgKHRhc2tDaGlsZHJlbiA9PT0gbnVsbCkge1xuICAgIC8vIFJlYWNoZWQgdGhlIGxlYWYgdGFzayBub2RlLiBUaGlzIGlzIHRoZSByb290IG9mIGEgcGVuZGluZyBjYWNoZVxuICAgIC8vIG5vZGUgdHJlZS5cbiAgICBhYm9ydFBlbmRpbmdDYWNoZU5vZGUodGFzay5yb3V0ZSwgY2FjaGVOb2RlLCBlcnJvcilcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGlzIGlzIGFuIGludGVybWVkaWF0ZSB0YXNrIG5vZGUuIEtlZXAgdHJhdmVyc2luZyB1bnRpbCB3ZSByZWFjaCBhXG4gICAgLy8gdGFzayBub2RlIHdpdGggbm8gY2hpbGRyZW4uIFRoYXQgd2lsbCBiZSB0aGUgcm9vdCBvZiB0aGUgY2FjaGUgbm9kZSB0cmVlXG4gICAgLy8gdGhhdCBuZWVkcyB0byBiZSByZXNvbHZlZC5cbiAgICBmb3IgKGNvbnN0IHRhc2tDaGlsZCBvZiB0YXNrQ2hpbGRyZW4udmFsdWVzKCkpIHtcbiAgICAgIGFib3J0VGFzayh0YXNrQ2hpbGQsIGVycm9yKVxuICAgIH1cbiAgfVxuXG4gIC8vIFNldCB0aGlzIHRvIG51bGwgdG8gaW5kaWNhdGUgdGhhdCB0aGlzIHRhc2sgaXMgbm93IGNvbXBsZXRlLlxuICB0YXNrLmR5bmFtaWNSZXF1ZXN0VHJlZSA9IG51bGxcbn1cblxuZnVuY3Rpb24gYWJvcnRQZW5kaW5nQ2FjaGVOb2RlKFxuICByb3V0ZXJTdGF0ZTogRmxpZ2h0Um91dGVyU3RhdGUsXG4gIGNhY2hlTm9kZTogQ2FjaGVOb2RlLFxuICBlcnJvcjogYW55XG4pOiB2b2lkIHtcbiAgLy8gRm9yIGV2ZXJ5IHBlbmRpbmcgc2VnbWVudCBpbiB0aGUgdHJlZSwgcmVzb2x2ZSBpdHMgYHJzY2AgcHJvbWlzZSB0byBgbnVsbGBcbiAgLy8gdG8gdHJpZ2dlciBhIGxhenkgZmV0Y2ggZHVyaW5nIHJlbmRlci5cbiAgLy9cbiAgLy8gT3IsIGlmIGFuIGVycm9yIG9iamVjdCBpcyBwcm92aWRlZCwgaXQgd2lsbCBlcnJvciBpbnN0ZWFkLlxuICBjb25zdCByb3V0ZXJTdGF0ZUNoaWxkcmVuID0gcm91dGVyU3RhdGVbMV1cbiAgY29uc3QgcGFyYWxsZWxSb3V0ZXMgPSBjYWNoZU5vZGUucGFyYWxsZWxSb3V0ZXNcbiAgZm9yIChsZXQgcGFyYWxsZWxSb3V0ZUtleSBpbiByb3V0ZXJTdGF0ZUNoaWxkcmVuKSB7XG4gICAgY29uc3Qgcm91dGVyU3RhdGVDaGlsZDogRmxpZ2h0Um91dGVyU3RhdGUgPVxuICAgICAgcm91dGVyU3RhdGVDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XVxuICAgIGNvbnN0IHNlZ21lbnRNYXBDaGlsZCA9IHBhcmFsbGVsUm91dGVzLmdldChwYXJhbGxlbFJvdXRlS2V5KVxuICAgIGlmIChzZWdtZW50TWFwQ2hpbGQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gVGhpcyBzaG91bGRuJ3QgaGFwcGVuIGJlY2F1c2Ugd2UncmUgdHJhdmVyc2luZyB0aGUgc2FtZSB0cmVlIHRoYXQgd2FzXG4gICAgICAvLyB1c2VkIHRvIGNvbnN0cnVjdCB0aGUgY2FjaGUgbm9kZXMgaW4gdGhlIGZpcnN0IHBsYWNlLlxuICAgICAgY29udGludWVcbiAgICB9XG4gICAgY29uc3Qgc2VnbWVudENoaWxkID0gcm91dGVyU3RhdGVDaGlsZFswXVxuICAgIGNvbnN0IHNlZ21lbnRLZXlDaGlsZCA9IGNyZWF0ZVJvdXRlckNhY2hlS2V5KHNlZ21lbnRDaGlsZClcbiAgICBjb25zdCBjYWNoZU5vZGVDaGlsZCA9IHNlZ21lbnRNYXBDaGlsZC5nZXQoc2VnbWVudEtleUNoaWxkKVxuICAgIGlmIChjYWNoZU5vZGVDaGlsZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBhYm9ydFBlbmRpbmdDYWNoZU5vZGUocm91dGVyU3RhdGVDaGlsZCwgY2FjaGVOb2RlQ2hpbGQsIGVycm9yKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIHNob3VsZG4ndCBoYXBwZW4gYmVjYXVzZSB3ZSdyZSB0cmF2ZXJzaW5nIHRoZSBzYW1lIHRyZWUgdGhhdCB3YXNcbiAgICAgIC8vIHVzZWQgdG8gY29uc3RydWN0IHRoZSBjYWNoZSBub2RlcyBpbiB0aGUgZmlyc3QgcGxhY2UuXG4gICAgfVxuICB9XG4gIGNvbnN0IHJzYyA9IGNhY2hlTm9kZS5yc2NcbiAgaWYgKGlzRGVmZXJyZWRSc2MocnNjKSkge1xuICAgIGlmIChlcnJvciA9PT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyB3aWxsIHRyaWdnZXIgYSBsYXp5IGZldGNoIGR1cmluZyByZW5kZXIuXG4gICAgICByc2MucmVzb2x2ZShudWxsKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIHdpbGwgdHJpZ2dlciBhbiBlcnJvciBkdXJpbmcgcmVuZGVyaW5nLlxuICAgICAgcnNjLnJlamVjdChlcnJvcilcbiAgICB9XG4gIH1cblxuICAvLyBDaGVjayBpZiB0aGlzIGlzIGEgbGVhZiBzZWdtZW50LiBJZiBzbywgaXQgd2lsbCBoYXZlIGEgYGhlYWRgIHByb3BlcnR5IHdpdGhcbiAgLy8gYSBwZW5kaW5nIHByb21pc2UgdGhhdCBuZWVkcyB0byBiZSByZXNvbHZlZC4gSWYgYW4gZXJyb3Igd2FzIHByb3ZpZGVkLCB3ZVxuICAvLyB3aWxsIG5vdCByZXNvbHZlIGl0IHdpdGggYW4gZXJyb3IsIHNpbmNlIHRoaXMgaXMgcmVuZGVyZWQgYXQgdGhlIHJvb3Qgb2ZcbiAgLy8gdGhlIGFwcC4gV2Ugd2FudCB0aGUgc2VnbWVudCB0byBlcnJvciwgbm90IHRoZSBlbnRpcmUgYXBwLlxuICBjb25zdCBoZWFkID0gY2FjaGVOb2RlLmhlYWRcbiAgaWYgKGlzRGVmZXJyZWRSc2MoaGVhZCkpIHtcbiAgICBoZWFkLnJlc29sdmUobnVsbClcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlQ2FjaGVOb2RlT25Qb3BzdGF0ZVJlc3RvcmF0aW9uKFxuICBvbGRDYWNoZU5vZGU6IENhY2hlTm9kZSxcbiAgcm91dGVyU3RhdGU6IEZsaWdodFJvdXRlclN0YXRlXG4pOiBSZWFkeUNhY2hlTm9kZSB7XG4gIC8vIEEgcG9wc3RhdGUgbmF2aWdhdGlvbiByZWFkcyBkYXRhIGZyb20gdGhlIGxvY2FsIGNhY2hlLiBJdCBkb2VzIG5vdCBpc3N1ZVxuICAvLyBuZXcgbmV0d29yayByZXF1ZXN0cyAodW5sZXNzIHRoZSBjYWNoZSBlbnRyaWVzIGhhdmUgYmVlbiBldmljdGVkKS4gU28sIHdlXG4gIC8vIHVwZGF0ZSB0aGUgY2FjaGUgdG8gZHJvcCB0aGUgcHJlZmV0Y2ggZGF0YSBmb3IgYW55IHNlZ21lbnQgd2hvc2UgZHluYW1pY1xuICAvLyBkYXRhIHdhcyBhbHJlYWR5IHJlY2VpdmVkLiBUaGlzIHByZXZlbnRzIGFuIHVubmVjZXNzYXJ5IGZsYXNoIGJhY2sgdG8gUFBSXG4gIC8vIHN0YXRlIGR1cmluZyBhIGJhY2svZm9yd2FyZCBuYXZpZ2F0aW9uLlxuICAvL1xuICAvLyBUaGlzIGZ1bmN0aW9uIGNsb25lcyB0aGUgZW50aXJlIGNhY2hlIG5vZGUgdHJlZSBhbmQgc2V0cyB0aGUgYHByZWZldGNoUnNjYFxuICAvLyBmaWVsZCB0byBgbnVsbGAgdG8gcHJldmVudCBpdCBmcm9tIGJlaW5nIHJlbmRlcmVkLiBXZSBjYW4ndCBtdXRhdGUgdGhlIG5vZGVcbiAgLy8gaW4gcGxhY2UgYmVjYXVzZSB0aGlzIGlzIGEgY29uY3VycmVudCBkYXRhIHN0cnVjdHVyZS5cblxuICBjb25zdCByb3V0ZXJTdGF0ZUNoaWxkcmVuID0gcm91dGVyU3RhdGVbMV1cbiAgY29uc3Qgb2xkUGFyYWxsZWxSb3V0ZXMgPSBvbGRDYWNoZU5vZGUucGFyYWxsZWxSb3V0ZXNcbiAgY29uc3QgbmV3UGFyYWxsZWxSb3V0ZXMgPSBuZXcgTWFwKG9sZFBhcmFsbGVsUm91dGVzKVxuICBmb3IgKGxldCBwYXJhbGxlbFJvdXRlS2V5IGluIHJvdXRlclN0YXRlQ2hpbGRyZW4pIHtcbiAgICBjb25zdCByb3V0ZXJTdGF0ZUNoaWxkOiBGbGlnaHRSb3V0ZXJTdGF0ZSA9XG4gICAgICByb3V0ZXJTdGF0ZUNoaWxkcmVuW3BhcmFsbGVsUm91dGVLZXldXG4gICAgY29uc3Qgc2VnbWVudENoaWxkID0gcm91dGVyU3RhdGVDaGlsZFswXVxuICAgIGNvbnN0IHNlZ21lbnRLZXlDaGlsZCA9IGNyZWF0ZVJvdXRlckNhY2hlS2V5KHNlZ21lbnRDaGlsZClcbiAgICBjb25zdCBvbGRTZWdtZW50TWFwQ2hpbGQgPSBvbGRQYXJhbGxlbFJvdXRlcy5nZXQocGFyYWxsZWxSb3V0ZUtleSlcbiAgICBpZiAob2xkU2VnbWVudE1hcENoaWxkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IG9sZENhY2hlTm9kZUNoaWxkID0gb2xkU2VnbWVudE1hcENoaWxkLmdldChzZWdtZW50S2V5Q2hpbGQpXG4gICAgICBpZiAob2xkQ2FjaGVOb2RlQ2hpbGQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBuZXdDYWNoZU5vZGVDaGlsZCA9IHVwZGF0ZUNhY2hlTm9kZU9uUG9wc3RhdGVSZXN0b3JhdGlvbihcbiAgICAgICAgICBvbGRDYWNoZU5vZGVDaGlsZCxcbiAgICAgICAgICByb3V0ZXJTdGF0ZUNoaWxkXG4gICAgICAgIClcbiAgICAgICAgY29uc3QgbmV3U2VnbWVudE1hcENoaWxkID0gbmV3IE1hcChvbGRTZWdtZW50TWFwQ2hpbGQpXG4gICAgICAgIG5ld1NlZ21lbnRNYXBDaGlsZC5zZXQoc2VnbWVudEtleUNoaWxkLCBuZXdDYWNoZU5vZGVDaGlsZClcbiAgICAgICAgbmV3UGFyYWxsZWxSb3V0ZXMuc2V0KHBhcmFsbGVsUm91dGVLZXksIG5ld1NlZ21lbnRNYXBDaGlsZClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBPbmx5IHNob3cgcHJlZmV0Y2hlZCBkYXRhIGlmIHRoZSBkeW5hbWljIGRhdGEgaXMgc3RpbGwgcGVuZGluZy5cbiAgLy9cbiAgLy8gVGVobmljYWxseSwgd2hhdCB3ZSdyZSBhY3R1YWxseSBjaGVja2luZyBpcyB3aGV0aGVyIHRoZSBkeW5hbWljIG5ldHdvcmtcbiAgLy8gcmVzcG9uc2Ugd2FzIHJlY2VpdmVkLiBCdXQgc2luY2UgaXQncyBhIHN0cmVhbWluZyByZXNwb25zZSwgdGhpcyBkb2VzIG5vdFxuICAvLyBtZWFuIHRoYXQgYWxsIHRoZSBkeW5hbWljIGRhdGEgaGFzIGZ1bGx5IHN0cmVhbWVkIGluLiBJdCBqdXN0IG1lYW5zIHRoYXRcbiAgLy8gX3NvbWVfIG9mIHRoZSBkeW5hbWljIGRhdGEgd2FzIHJlY2VpdmVkLiBCdXQgYXMgYSBoZXVyaXN0aWMsIHdlIGFzc3VtZSB0aGF0XG4gIC8vIHRoZSByZXN0IGR5bmFtaWMgZGF0YSB3aWxsIHN0cmVhbSBpbiBxdWlja2x5LCBzbyBpdCdzIHN0aWxsIGJldHRlciB0byBza2lwXG4gIC8vIHRoZSBwcmVmZXRjaCBzdGF0ZS5cbiAgY29uc3QgcnNjID0gb2xkQ2FjaGVOb2RlLnJzY1xuICBjb25zdCBzaG91bGRVc2VQcmVmZXRjaCA9IGlzRGVmZXJyZWRSc2MocnNjKSAmJiByc2Muc3RhdHVzID09PSAncGVuZGluZydcblxuICByZXR1cm4ge1xuICAgIGxhenlEYXRhOiBudWxsLFxuICAgIHJzYyxcbiAgICBoZWFkOiBvbGRDYWNoZU5vZGUuaGVhZCxcblxuICAgIHByZWZldGNoSGVhZDogc2hvdWxkVXNlUHJlZmV0Y2ggPyBvbGRDYWNoZU5vZGUucHJlZmV0Y2hIZWFkIDogW251bGwsIG51bGxdLFxuICAgIHByZWZldGNoUnNjOiBzaG91bGRVc2VQcmVmZXRjaCA/IG9sZENhY2hlTm9kZS5wcmVmZXRjaFJzYyA6IG51bGwsXG4gICAgbG9hZGluZzogb2xkQ2FjaGVOb2RlLmxvYWRpbmcsXG5cbiAgICAvLyBUaGVzZSBhcmUgdGhlIGNsb25lZCBjaGlsZHJlbiB3ZSBjb21wdXRlZCBhYm92ZVxuICAgIHBhcmFsbGVsUm91dGVzOiBuZXdQYXJhbGxlbFJvdXRlcyxcblxuICAgIG5hdmlnYXRlZEF0OiBvbGRDYWNoZU5vZGUubmF2aWdhdGVkQXQsXG4gIH1cbn1cblxuY29uc3QgREVGRVJSRUQgPSBTeW1ib2woKVxuXG50eXBlIFBlbmRpbmdEZWZlcnJlZFJzYyA9IFByb21pc2U8UmVhY3QuUmVhY3ROb2RlPiAmIHtcbiAgc3RhdHVzOiAncGVuZGluZydcbiAgcmVzb2x2ZTogKHZhbHVlOiBSZWFjdC5SZWFjdE5vZGUpID0+IHZvaWRcbiAgcmVqZWN0OiAoZXJyb3I6IGFueSkgPT4gdm9pZFxuICB0YWc6IFN5bWJvbFxufVxuXG50eXBlIEZ1bGZpbGxlZERlZmVycmVkUnNjID0gUHJvbWlzZTxSZWFjdC5SZWFjdE5vZGU+ICYge1xuICBzdGF0dXM6ICdmdWxmaWxsZWQnXG4gIHZhbHVlOiBSZWFjdC5SZWFjdE5vZGVcbiAgcmVzb2x2ZTogKHZhbHVlOiBSZWFjdC5SZWFjdE5vZGUpID0+IHZvaWRcbiAgcmVqZWN0OiAoZXJyb3I6IGFueSkgPT4gdm9pZFxuICB0YWc6IFN5bWJvbFxufVxuXG50eXBlIFJlamVjdGVkRGVmZXJyZWRSc2MgPSBQcm9taXNlPFJlYWN0LlJlYWN0Tm9kZT4gJiB7XG4gIHN0YXR1czogJ3JlamVjdGVkJ1xuICByZWFzb246IGFueVxuICByZXNvbHZlOiAodmFsdWU6IFJlYWN0LlJlYWN0Tm9kZSkgPT4gdm9pZFxuICByZWplY3Q6IChlcnJvcjogYW55KSA9PiB2b2lkXG4gIHRhZzogU3ltYm9sXG59XG5cbnR5cGUgRGVmZXJyZWRSc2MgPVxuICB8IFBlbmRpbmdEZWZlcnJlZFJzY1xuICB8IEZ1bGZpbGxlZERlZmVycmVkUnNjXG4gIHwgUmVqZWN0ZWREZWZlcnJlZFJzY1xuXG4vLyBUaGlzIHR5cGUgZXhpc3RzIHRvIGRpc3Rpbmd1aXNoIGEgRGVmZXJyZWRSc2MgZnJvbSBhIEZsaWdodCBwcm9taXNlLiBJdCdzIGFcbi8vIGNvbXByb21pc2UgdG8gYXZvaWQgYWRkaW5nIGFuIGV4dHJhIGZpZWxkIG9uIGV2ZXJ5IENhY2hlIE5vZGUsIHdoaWNoIHdvdWxkIGJlXG4vLyBhd2t3YXJkIGJlY2F1c2UgdGhlIHByZS1QUFIgcGFydHMgb2YgY29kZWJhc2Ugd291bGQgbmVlZCB0byBhY2NvdW50IGZvciBpdCxcbi8vIHRvby4gV2UgY2FuIHJlbW92ZSBpdCBvbmNlIHR5cGUgQ2FjaGUgTm9kZSB0eXBlIGlzIG1vcmUgc2V0dGxlZC5cbmZ1bmN0aW9uIGlzRGVmZXJyZWRSc2ModmFsdWU6IGFueSk6IHZhbHVlIGlzIERlZmVycmVkUnNjIHtcbiAgcmV0dXJuIHZhbHVlICYmIHZhbHVlLnRhZyA9PT0gREVGRVJSRURcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGVmZXJyZWRSc2MoKTogUGVuZGluZ0RlZmVycmVkUnNjIHtcbiAgbGV0IHJlc29sdmU6IGFueVxuICBsZXQgcmVqZWN0OiBhbnlcbiAgY29uc3QgcGVuZGluZ1JzYyA9IG5ldyBQcm9taXNlPFJlYWN0LlJlYWN0Tm9kZT4oKHJlcywgcmVqKSA9PiB7XG4gICAgcmVzb2x2ZSA9IHJlc1xuICAgIHJlamVjdCA9IHJlalxuICB9KSBhcyBQZW5kaW5nRGVmZXJyZWRSc2NcbiAgcGVuZGluZ1JzYy5zdGF0dXMgPSAncGVuZGluZydcbiAgcGVuZGluZ1JzYy5yZXNvbHZlID0gKHZhbHVlOiBSZWFjdC5SZWFjdE5vZGUpID0+IHtcbiAgICBpZiAocGVuZGluZ1JzYy5zdGF0dXMgPT09ICdwZW5kaW5nJykge1xuICAgICAgY29uc3QgZnVsZmlsbGVkUnNjOiBGdWxmaWxsZWREZWZlcnJlZFJzYyA9IHBlbmRpbmdSc2MgYXMgYW55XG4gICAgICBmdWxmaWxsZWRSc2Muc3RhdHVzID0gJ2Z1bGZpbGxlZCdcbiAgICAgIGZ1bGZpbGxlZFJzYy52YWx1ZSA9IHZhbHVlXG4gICAgICByZXNvbHZlKHZhbHVlKVxuICAgIH1cbiAgfVxuICBwZW5kaW5nUnNjLnJlamVjdCA9IChlcnJvcjogYW55KSA9PiB7XG4gICAgaWYgKHBlbmRpbmdSc2Muc3RhdHVzID09PSAncGVuZGluZycpIHtcbiAgICAgIGNvbnN0IHJlamVjdGVkUnNjOiBSZWplY3RlZERlZmVycmVkUnNjID0gcGVuZGluZ1JzYyBhcyBhbnlcbiAgICAgIHJlamVjdGVkUnNjLnN0YXR1cyA9ICdyZWplY3RlZCdcbiAgICAgIHJlamVjdGVkUnNjLnJlYXNvbiA9IGVycm9yXG4gICAgICByZWplY3QoZXJyb3IpXG4gICAgfVxuICB9XG4gIHBlbmRpbmdSc2MudGFnID0gREVGRVJSRURcbiAgcmV0dXJuIHBlbmRpbmdSc2Ncbn1cbiJdLCJuYW1lcyI6WyJhYm9ydFRhc2siLCJsaXN0ZW5Gb3JEeW5hbWljUmVxdWVzdCIsInN0YXJ0UFBSTmF2aWdhdGlvbiIsInVwZGF0ZUNhY2hlTm9kZU9uUG9wc3RhdGVSZXN0b3JhdGlvbiIsIk1QQV9OQVZJR0FUSU9OX1RBU0siLCJyb3V0ZSIsIm5vZGUiLCJkeW5hbWljUmVxdWVzdFRyZWUiLCJjaGlsZHJlbiIsIm5hdmlnYXRlZEF0Iiwib2xkQ2FjaGVOb2RlIiwib2xkUm91dGVyU3RhdGUiLCJuZXdSb3V0ZXJTdGF0ZSIsInByZWZldGNoRGF0YSIsInByZWZldGNoSGVhZCIsImlzUHJlZmV0Y2hIZWFkUGFydGlhbCIsImlzU2FtZVBhZ2VOYXZpZ2F0aW9uIiwic2Nyb2xsYWJsZVNlZ21lbnRzUmVzdWx0Iiwic2VnbWVudFBhdGgiLCJ1cGRhdGVDYWNoZU5vZGVPbk5hdmlnYXRpb24iLCJkaWRGaW5kUm9vdExheW91dCIsIm9sZFJvdXRlclN0YXRlQ2hpbGRyZW4iLCJuZXdSb3V0ZXJTdGF0ZUNoaWxkcmVuIiwicHJlZmV0Y2hEYXRhQ2hpbGRyZW4iLCJpc1Jvb3RMYXlvdXQiLCJvbGRQYXJhbGxlbFJvdXRlcyIsInBhcmFsbGVsUm91dGVzIiwicHJlZmV0Y2hQYXJhbGxlbFJvdXRlcyIsIk1hcCIsInBhdGNoZWRSb3V0ZXJTdGF0ZUNoaWxkcmVuIiwidGFza0NoaWxkcmVuIiwibmVlZHNEeW5hbWljUmVxdWVzdCIsImR5bmFtaWNSZXF1ZXN0VHJlZUNoaWxkcmVuIiwicGFyYWxsZWxSb3V0ZUtleSIsIm5ld1JvdXRlclN0YXRlQ2hpbGQiLCJvbGRSb3V0ZXJTdGF0ZUNoaWxkIiwib2xkU2VnbWVudE1hcENoaWxkIiwiZ2V0IiwicHJlZmV0Y2hEYXRhQ2hpbGQiLCJuZXdTZWdtZW50Q2hpbGQiLCJuZXdTZWdtZW50UGF0aENoaWxkIiwiY29uY2F0IiwibmV3U2VnbWVudEtleUNoaWxkIiwiY3JlYXRlUm91dGVyQ2FjaGVLZXkiLCJvbGRTZWdtZW50Q2hpbGQiLCJ1bmRlZmluZWQiLCJvbGRDYWNoZU5vZGVDaGlsZCIsInRhc2tDaGlsZCIsIkRFRkFVTFRfU0VHTUVOVF9LRVkiLCJzcGF3blJldXNlZFRhc2siLCJiZWdpblJlbmRlcmluZ05ld1JvdXRlVHJlZSIsIk9iamVjdCIsImtleXMiLCJsZW5ndGgiLCJtYXRjaFNlZ21lbnQiLCJzZXQiLCJuZXdDYWNoZU5vZGVDaGlsZCIsIm5ld1NlZ21lbnRNYXBDaGlsZCIsInRhc2tDaGlsZFJvdXRlIiwiZHluYW1pY1JlcXVlc3RUcmVlQ2hpbGQiLCJuZXdDYWNoZU5vZGUiLCJsYXp5RGF0YSIsInJzYyIsInByZWZldGNoUnNjIiwiaGVhZCIsImxvYWRpbmciLCJwYXRjaFJvdXRlclN0YXRlV2l0aE5ld0NoaWxkcmVuIiwiZXhpc3RpbmdDYWNoZU5vZGUiLCJwb3NzaWJseVBhcnRpYWxQcmVmZXRjaEhlYWQiLCJpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQiLCJjcmVhdGVDYWNoZU5vZGVPbk5hdmlnYXRpb24iLCJyb3V0ZXJTdGF0ZSIsInJvdXRlclN0YXRlQ2hpbGRyZW4iLCJpc0xlYWZTZWdtZW50IiwiY2FjaGVOb2RlTmF2aWdhdGVkQXQiLCJEWU5BTUlDX1NUQUxFVElNRV9NUyIsImlzUHJlZmV0Y2hSc2NQYXJ0aWFsIiwic3Bhd25QZW5kaW5nVGFzayIsImV4aXN0aW5nQ2FjaGVOb2RlQ2hpbGRyZW4iLCJjYWNoZU5vZGVDaGlsZHJlbiIsInB1c2giLCJyb3V0ZXJTdGF0ZUNoaWxkIiwiZXhpc3RpbmdTZWdtZW50TWFwQ2hpbGQiLCJzZWdtZW50Q2hpbGQiLCJzZWdtZW50UGF0aENoaWxkIiwic2VnbWVudEtleUNoaWxkIiwiZXhpc3RpbmdDYWNoZU5vZGVDaGlsZCIsImJhc2VSb3V0ZXJTdGF0ZSIsIm5ld0NoaWxkcmVuIiwiY2xvbmUiLCJuZXdUYXNrIiwiY3JlYXRlUGVuZGluZ0NhY2hlTm9kZSIsInJldXNlZFJvdXRlclN0YXRlIiwidGFzayIsInJlc3BvbnNlUHJvbWlzZSIsInRoZW4iLCJmbGlnaHREYXRhIiwibm9ybWFsaXplZEZsaWdodERhdGEiLCJ0cmVlIiwic2VydmVyUm91dGVyU3RhdGUiLCJzZWVkRGF0YSIsImR5bmFtaWNEYXRhIiwiZHluYW1pY0hlYWQiLCJ3cml0ZUR5bmFtaWNEYXRhSW50b1BlbmRpbmdUYXNrIiwiZXJyb3IiLCJyb290VGFzayIsImkiLCJzZWdtZW50IiwidGFza1NlZ21lbnQiLCJmaW5pc2hUYXNrVXNpbmdEeW5hbWljRGF0YVBheWxvYWQiLCJ0YXNrTm9kZSIsImZpbmlzaFBlbmRpbmdDYWNoZU5vZGUiLCJzZXJ2ZXJDaGlsZHJlbiIsImR5bmFtaWNEYXRhQ2hpbGRyZW4iLCJzZXJ2ZXJSb3V0ZXJTdGF0ZUNoaWxkIiwiZHluYW1pY0RhdGFDaGlsZCIsInNpemUiLCJtYXliZVByZWZldGNoUnNjIiwibWF5YmVQcmVmZXRjaExvYWRpbmciLCJjcmVhdGVEZWZlcnJlZFJzYyIsImNhY2hlTm9kZSIsInRhc2tTdGF0ZSIsInNlcnZlclN0YXRlIiwidGFza1N0YXRlQ2hpbGRyZW4iLCJzZXJ2ZXJTdGF0ZUNoaWxkcmVuIiwiZGF0YUNoaWxkcmVuIiwidGFza1N0YXRlQ2hpbGQiLCJzZXJ2ZXJTdGF0ZUNoaWxkIiwiZGF0YUNoaWxkIiwic2VnbWVudE1hcENoaWxkIiwidGFza1NlZ21lbnRDaGlsZCIsInRhc2tTZWdtZW50S2V5Q2hpbGQiLCJjYWNoZU5vZGVDaGlsZCIsImFib3J0UGVuZGluZ0NhY2hlTm9kZSIsImR5bmFtaWNTZWdtZW50RGF0YSIsImlzRGVmZXJyZWRSc2MiLCJyZXNvbHZlIiwidmFsdWVzIiwicmVqZWN0IiwibmV3UGFyYWxsZWxSb3V0ZXMiLCJzaG91bGRVc2VQcmVmZXRjaCIsInN0YXR1cyIsIkRFRkVSUkVEIiwiU3ltYm9sIiwidmFsdWUiLCJ0YWciLCJwZW5kaW5nUnNjIiwiUHJvbWlzZSIsInJlcyIsInJlaiIsImZ1bGZpbGxlZFJzYyIsInJlamVjdGVkUnNjIiwicmVhc29uIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0lBMGtDZ0JBLFNBQVMsRUFBQTtlQUFUQTs7SUExVkFDLHVCQUF1QixFQUFBO2VBQXZCQTs7SUF2cEJBQyxrQkFBa0IsRUFBQTtlQUFsQkE7O0lBNmpDQUMsb0NBQW9DLEVBQUE7ZUFBcENBOzs7eUJBem9Db0I7K0JBQ1A7c0NBQ1E7NkNBRU87b0NBQ1A7QUFpQ3JDLE1BQU1DLHNCQUF5QztJQUM3Q0MsT0FBTztJQUNQQyxNQUFNO0lBQ05DLG9CQUFvQjtJQUNwQkMsVUFBVTtBQUNaO0FBaUNPLFNBQVNOLG1CQUNkTyxXQUFtQixFQUNuQkMsWUFBdUIsRUFDdkJDLGNBQWlDLEVBQ2pDQyxjQUFpQyxFQUNqQ0MsWUFBc0MsRUFDdENDLFlBQTZCLEVBQzdCQyxxQkFBOEIsRUFDOUJDLG9CQUE2QixFQUM3QkMsd0JBQWtEO0lBRWxELE1BQU1DLGNBQXdDLEVBQUU7SUFDaEQsT0FBT0MsNEJBQ0xWLGFBQ0FDLGNBQ0FDLGdCQUNBQyxnQkFDQSxPQUNBQyxjQUNBQyxjQUNBQyx1QkFDQUMsc0JBQ0FFLGFBQ0FEO0FBRUo7QUFFQSxTQUFTRSw0QkFDUFYsV0FBbUIsRUFDbkJDLFlBQXVCLEVBQ3ZCQyxjQUFpQyxFQUNqQ0MsY0FBaUMsRUFDakNRLGlCQUEwQixFQUMxQlAsWUFBc0MsRUFDdENDLFlBQTZCLEVBQzdCQyxxQkFBOEIsRUFDOUJDLG9CQUE2QixFQUM3QkUsV0FBOEIsRUFDOUJELHdCQUFrRDtJQUVsRCwwREFBMEQ7SUFDMUQsTUFBTUkseUJBQXlCVixjQUFjLENBQUMsRUFBRTtJQUNoRCxNQUFNVyx5QkFBeUJWLGNBQWMsQ0FBQyxFQUFFO0lBQ2hELE1BQU1XLHVCQUF1QlYsaUJBQWlCLE9BQU9BLFlBQVksQ0FBQyxFQUFFLEdBQUc7SUFFdkUsSUFBSSxDQUFDTyxtQkFBbUI7UUFDdEIsd0VBQXdFO1FBQ3hFLDBFQUEwRTtRQUMxRSx5RUFBeUU7UUFDekUsTUFBTUksZUFBZVosY0FBYyxDQUFDLEVBQUUsS0FBSztRQUMzQyxJQUFJWSxjQUFjO1lBQ2hCLGdDQUFnQztZQUNoQ0osb0JBQW9CO1FBQ3RCO0lBQ0Y7SUFFQSxNQUFNSyxvQkFBb0JmLGFBQWFnQixjQUFjO0lBRXJELDJFQUEyRTtJQUMzRSxnQkFBZ0I7SUFDaEIsMEVBQTBFO0lBQzFFLDBFQUEwRTtJQUMxRSw0RUFBNEU7SUFDNUUsMkVBQTJFO0lBQzNFLDBFQUEwRTtJQUMxRSx1RUFBdUU7SUFDdkUseUVBQXlFO0lBQ3pFLHdFQUF3RTtJQUN4RSwrQkFBK0I7SUFDL0IsTUFBTUMseUJBQXlCLElBQUlDLElBQUlIO0lBRXZDLDRFQUE0RTtJQUM1RSw0RUFBNEU7SUFDNUUsMkVBQTJFO0lBQzNFLDZFQUE2RTtJQUM3RSxtQkFBbUI7SUFDbkIsSUFBSUksNkJBRUEsQ0FBQztJQUNMLElBQUlDLGVBQWU7SUFFbkIsdUVBQXVFO0lBQ3ZFLDZFQUE2RTtJQUM3RSxnRUFBZ0U7SUFDaEUsRUFBRTtJQUNGLDRFQUE0RTtJQUM1RSxzRUFBc0U7SUFDdEUsRUFBRTtJQUNGLHVFQUF1RTtJQUN2RSxxQ0FBcUM7SUFDckMsSUFBSUMsc0JBQXNCO0lBQzFCLDRFQUE0RTtJQUM1RSwwRUFBMEU7SUFDMUUsOEVBQThFO0lBQzlFLHFDQUFxQztJQUNyQywyRUFBMkU7SUFDM0UseURBQXlEO0lBQ3pELDBCQUEwQjtJQUMxQixJQUFJQyw2QkFFQSxDQUFDO0lBRUwsSUFBSyxJQUFJQyxvQkFBb0JYLHVCQUF3QjtRQUNuRCxNQUFNWSxzQkFDSlosc0JBQXNCLENBQUNXLGlCQUFpQjtRQUMxQyxNQUFNRSxzQkFDSmQsc0JBQXNCLENBQUNZLGlCQUFpQjtRQUMxQyxNQUFNRyxxQkFBcUJYLGtCQUFrQlksR0FBRyxDQUFDSjtRQUNqRCxNQUFNSyxvQkFDSmYseUJBQXlCLE9BQ3JCQSxvQkFBb0IsQ0FBQ1UsaUJBQWlCLEdBQ3RDO1FBRU4sTUFBTU0sa0JBQWtCTCxtQkFBbUIsQ0FBQyxFQUFFO1FBQzlDLE1BQU1NLHNCQUFzQnRCLFlBQVl1QixNQUFNLENBQUM7WUFDN0NSO1lBQ0FNO1NBQ0Q7UUFDRCxNQUFNRyxxQkFBcUJDLENBQUFBLEdBQUFBLHNCQUFBQSxvQkFBb0IsRUFBQ0o7UUFFaEQsTUFBTUssa0JBQ0pULHdCQUF3QlUsWUFBWVYsbUJBQW1CLENBQUMsRUFBRSxHQUFHVTtRQUUvRCxNQUFNQyxvQkFDSlYsdUJBQXVCUyxZQUNuQlQsbUJBQW1CQyxHQUFHLENBQUNLLHNCQUN2Qkc7UUFFTixJQUFJRTtRQUNKLElBQUlSLG9CQUFvQlMsU0FBQUEsbUJBQW1CLEVBQUU7WUFDM0MsMERBQTBEO1lBQzFELEVBQUU7WUFDRix5RUFBeUU7WUFDekUsdUVBQXVFO1lBQ3ZFLHNFQUFzRTtZQUN0RSxvRUFBb0U7WUFDcEUsV0FBVztZQUNYLElBQUliLHdCQUF3QlUsV0FBVztnQkFDckMsc0VBQXNFO2dCQUN0RSxvRUFBb0U7Z0JBQ3BFLG1FQUFtRTtnQkFDbkVFLFlBQVlFLGdCQUFnQmQ7WUFDOUIsT0FBTztnQkFDTCxvRUFBb0U7Z0JBQ3BFWSxZQUFZRywyQkFDVnpDLGFBQ0EwQixxQkFDQUQscUJBQ0FZLG1CQUNBMUIsbUJBQ0FrQixzQkFBc0JPLFlBQVlQLG9CQUFvQixNQUN0RHhCLGNBQ0FDLHVCQUNBeUIscUJBQ0F2QjtZQUVKO1FBQ0YsT0FBTyxJQUNMRCx3QkFDQSxtQ0FBbUM7UUFDbkMscUVBQXFFO1FBQ3JFLHNFQUFzRTtRQUN0RSxzRUFBc0U7UUFDdEUsd0VBQXdFO1FBQ3hFLHlEQUF5RDtRQUN6RG1DLE9BQU9DLElBQUksQ0FBQ2xCLG1CQUFtQixDQUFDLEVBQUUsRUFBRW1CLE1BQU0sS0FBSyxHQUMvQztZQUNBLG1FQUFtRTtZQUNuRSwwRUFBMEU7WUFDMUUseUVBQXlFO1lBQ3pFLDZCQUE2QjtZQUM3QixFQUFFO1lBQ0Ysc0VBQXNFO1lBQ3RFLHlFQUF5RTtZQUN6RSxzRUFBc0U7WUFDdEUsZ0NBQWdDO1lBQ2hDLEVBQUU7WUFDRixxRUFBcUU7WUFDckUsMEVBQTBFO1lBQzFFLHdFQUF3RTtZQUN4RSwyQ0FBMkM7WUFDM0MsRUFBRTtZQUNGLG1FQUFtRTtZQUNuRSx1RUFBdUU7WUFDdkUsMERBQTBEO1lBQzFETixZQUFZRywyQkFDVnpDLGFBQ0EwQixxQkFDQUQscUJBQ0FZLG1CQUNBMUIsbUJBQ0FrQixzQkFBc0JPLFlBQVlQLG9CQUFvQixNQUN0RHhCLGNBQ0FDLHVCQUNBeUIscUJBQ0F2QjtRQUVKLE9BQU8sSUFDTGtCLHdCQUF3QlUsYUFDeEJELG9CQUFvQkMsYUFDcEJTLENBQUFBLEdBQUFBLGVBQUFBLFlBQVksRUFBQ2YsaUJBQWlCSyxrQkFDOUI7WUFDQSxJQUNFRSxzQkFBc0JELGFBQ3RCVix3QkFBd0JVLFdBQ3hCO2dCQUNBLHdFQUF3RTtnQkFDeEUsZ0JBQWdCO2dCQUNoQkUsWUFBWTVCLDRCQUNWVixhQUNBcUMsbUJBQ0FYLHFCQUNBRCxxQkFDQWQsbUJBQ0FrQixtQkFDQXhCLGNBQ0FDLHVCQUNBQyxzQkFDQXdCLHFCQUNBdkI7WUFFSixPQUFPO2dCQUNMLGlFQUFpRTtnQkFDakUsaUJBQWlCO2dCQUNqQjhCLFlBQVlHLDJCQUNWekMsYUFDQTBCLHFCQUNBRCxxQkFDQVksbUJBQ0ExQixtQkFDQWtCLHNCQUFzQk8sWUFBWVAsb0JBQW9CLE1BQ3REeEIsY0FDQUMsdUJBQ0F5QixxQkFDQXZCO1lBRUo7UUFDRixPQUFPO1lBQ0wsbURBQW1EO1lBQ25EOEIsWUFBWUcsMkJBQ1Z6QyxhQUNBMEIscUJBQ0FELHFCQUNBWSxtQkFDQTFCLG1CQUNBa0Isc0JBQXNCTyxZQUFZUCxvQkFBb0IsTUFDdER4QixjQUNBQyx1QkFDQXlCLHFCQUNBdkI7UUFFSjtRQUVBLElBQUk4QixjQUFjLE1BQU07WUFDdEIsNENBQTRDO1lBRTVDLElBQUlBLFVBQVUxQyxLQUFLLEtBQUssTUFBTTtnQkFDNUIsaUVBQWlFO2dCQUNqRSxvREFBb0Q7Z0JBQ3BELE9BQU9EO1lBQ1Q7WUFFQSxJQUFJMEIsaUJBQWlCLE1BQU07Z0JBQ3pCQSxlQUFlLElBQUlGO1lBQ3JCO1lBQ0FFLGFBQWF5QixHQUFHLENBQUN0QixrQkFBa0JjO1lBQ25DLE1BQU1TLG9CQUFvQlQsVUFBVXpDLElBQUk7WUFDeEMsSUFBSWtELHNCQUFzQixNQUFNO2dCQUM5QixNQUFNQyxxQkFBc0MsSUFBSTdCLElBQUlRO2dCQUNwRHFCLG1CQUFtQkYsR0FBRyxDQUFDYixvQkFBb0JjO2dCQUMzQzdCLHVCQUF1QjRCLEdBQUcsQ0FBQ3RCLGtCQUFrQndCO1lBQy9DO1lBRUEsb0VBQW9FO1lBQ3BFLHVFQUF1RTtZQUN2RSxZQUFZO1lBQ1osTUFBTUMsaUJBQWlCWCxVQUFVMUMsS0FBSztZQUN0Q3dCLDBCQUEwQixDQUFDSSxpQkFBaUIsR0FBR3lCO1lBRS9DLE1BQU1DLDBCQUEwQlosVUFBVXhDLGtCQUFrQjtZQUM1RCxJQUFJb0QsNEJBQTRCLE1BQU07Z0JBQ3BDLDBDQUEwQztnQkFDMUM1QixzQkFBc0I7Z0JBQ3RCQywwQkFBMEIsQ0FBQ0MsaUJBQWlCLEdBQUcwQjtZQUNqRCxPQUFPO2dCQUNMM0IsMEJBQTBCLENBQUNDLGlCQUFpQixHQUFHeUI7WUFDakQ7UUFDRixPQUFPO1lBQ0wsbUVBQW1FO1lBQ25FN0IsMEJBQTBCLENBQUNJLGlCQUFpQixHQUFHQztZQUMvQ0YsMEJBQTBCLENBQUNDLGlCQUFpQixHQUFHQztRQUNqRDtJQUNGO0lBRUEsSUFBSUosaUJBQWlCLE1BQU07UUFDekIsNkJBQTZCO1FBQzdCLE9BQU87SUFDVDtJQUVBLE1BQU04QixlQUErQjtRQUNuQ0MsVUFBVTtRQUNWQyxLQUFLcEQsYUFBYW9ELEdBQUc7UUFDckIsMEVBQTBFO1FBQzFFLHFFQUFxRTtRQUNyRSwyRUFBMkU7UUFDM0UsMEVBQTBFO1FBQzFFLDJFQUEyRTtRQUMzRSxxQ0FBcUM7UUFDckNDLGFBQWFyRCxhQUFhcUQsV0FBVztRQUNyQ0MsTUFBTXRELGFBQWFzRCxJQUFJO1FBQ3ZCbEQsY0FBY0osYUFBYUksWUFBWTtRQUN2Q21ELFNBQVN2RCxhQUFhdUQsT0FBTztRQUU3Qix5RUFBeUU7UUFDekV2QyxnQkFBZ0JDO1FBRWhCbEI7SUFDRjtJQUVBLE9BQU87UUFDTCxrRUFBa0U7UUFDbEVKLE9BQU82RCxnQ0FDTHRELGdCQUNBaUI7UUFFRnZCLE1BQU1zRDtRQUNOckQsb0JBQW9Cd0Isc0JBQ2hCbUMsZ0NBQ0V0RCxnQkFDQW9CLDhCQUVGO1FBQ0p4QixVQUFVc0I7SUFDWjtBQUNGO0FBRUEsU0FBU29CLDJCQUNQekMsV0FBbUIsRUFDbkJFLGNBQXdDLEVBQ3hDQyxjQUFpQyxFQUNqQ3VELGlCQUFtQyxFQUNuQy9DLGlCQUEwQixFQUMxQlAsWUFBc0MsRUFDdEN1RCwyQkFBNEMsRUFDNUNyRCxxQkFBOEIsRUFDOUJHLFdBQThCLEVBQzlCRCx3QkFBa0Q7SUFFbEQsSUFBSSxDQUFDRyxtQkFBbUI7UUFDdEIsd0VBQXdFO1FBQ3hFLDBFQUEwRTtRQUMxRSwyRUFBMkU7UUFDM0UsMERBQTBEO1FBQzFELEVBQUU7UUFDRix1RUFBdUU7UUFDdkUsdUVBQXVFO1FBQ3ZFLDJFQUEyRTtRQUMzRSwyRUFBMkU7UUFDM0UseUNBQXlDO1FBQ3pDLEVBQUU7UUFDRiwyRUFBMkU7UUFDM0Usb0VBQW9FO1FBQ3BFLEVBQUU7UUFDRixvREFBb0Q7UUFDcEQsRUFBRTtRQUNGLHNFQUFzRTtRQUN0RSw0RUFBNEU7UUFDNUUseURBQXlEO1FBQ3pELElBQ0VULG1CQUFtQmtDLGFBQ25Cd0IsQ0FBQUEsR0FBQUEsNkJBQUFBLDJCQUEyQixFQUFDMUQsZ0JBQWdCQyxpQkFDNUM7WUFDQSwyREFBMkQ7WUFDM0QsT0FBT1I7UUFDVDtJQUNGO0lBQ0EsT0FBT2tFLDRCQUNMN0QsYUFDQUcsZ0JBQ0F1RCxtQkFDQXRELGNBQ0F1RCw2QkFDQXJELHVCQUNBRyxhQUNBRDtBQUVKO0FBRUEsU0FBU3FELDRCQUNQN0QsV0FBbUIsRUFDbkI4RCxXQUE4QixFQUM5QkosaUJBQW1DLEVBQ25DdEQsWUFBc0MsRUFDdEN1RCwyQkFBNEMsRUFDNUNyRCxxQkFBOEIsRUFDOUJHLFdBQThCLEVBQzlCRCx3QkFBa0Q7SUFFbEQsMEVBQTBFO0lBQzFFLDRFQUE0RTtJQUM1RSw2RUFBNkU7SUFFN0UsNEVBQTRFO0lBQzVFLG1FQUFtRTtJQUNuRSxNQUFNdUQsc0JBQXNCRCxXQUFXLENBQUMsRUFBRTtJQUMxQyxNQUFNRSxnQkFBZ0J0QixPQUFPQyxJQUFJLENBQUNvQixxQkFBcUJuQixNQUFNLEtBQUs7SUFFbEUsNkVBQTZFO0lBQzdFLDJFQUEyRTtJQUMzRSw4RUFBOEU7SUFDOUUsMkVBQTJFO0lBQzNFLDJCQUEyQjtJQUMzQixJQUFJUztJQUNKLElBQUlHO0lBQ0osSUFBSUQ7SUFDSixJQUFJVTtJQUNKLElBQ0VQLHNCQUFzQnRCLGFBQ3RCLG9FQUFvRTtJQUNwRSxvRUFBb0U7SUFDcEUsd0VBQXdFO0lBQ3hFc0Isa0JBQWtCMUQsV0FBVyxHQUFHa0Usb0JBQUFBLG9CQUFvQixHQUFHbEUsYUFDdkQ7UUFDQSx5RUFBeUU7UUFDekUsaURBQWlEO1FBQ2pEcUQsTUFBTUssa0JBQWtCTCxHQUFHO1FBQzNCRyxVQUFVRSxrQkFBa0JGLE9BQU87UUFDbkNELE9BQU9HLGtCQUFrQkgsSUFBSTtRQUU3QiwwRUFBMEU7UUFDMUVVLHVCQUF1QlAsa0JBQWtCMUQsV0FBVztJQUN0RCxPQUFPLElBQUlJLGlCQUFpQixNQUFNO1FBQ2hDLDBFQUEwRTtRQUMxRSx3RUFBd0U7UUFDeEUsK0RBQStEO1FBQy9EaUQsTUFBTWpELFlBQVksQ0FBQyxFQUFFO1FBQ3JCb0QsVUFBVXBELFlBQVksQ0FBQyxFQUFFO1FBQ3pCbUQsT0FBT1MsZ0JBQWdCTCw4QkFBOEI7UUFDckQsd0VBQXdFO1FBQ3hFLHdFQUF3RTtRQUN4RSx5QkFBeUI7UUFDekJNLHVCQUF1QmpFO1FBQ3ZCLE1BQU1tRSx1QkFBdUIvRCxZQUFZLENBQUMsRUFBRTtRQUM1QyxJQUNFLEFBQ0ErRCx3QkFDQSxlQUZ1QywwREFFa0M7UUFDeEU3RCx5QkFBeUIwRCxlQUMxQjtZQUNBLHlFQUF5RTtZQUN6RSw4Q0FBOEM7WUFDOUMsT0FBT0ksaUJBQ0xwRSxhQUNBOEQsYUFDQTFELGNBQ0F1RCw2QkFDQXJELHVCQUNBRyxhQUNBRDtRQUVKLE9BQU87UUFDTCxnRUFBZ0U7UUFDaEUsc0JBQXNCO1FBQ3hCO0lBQ0YsT0FBTztRQUNMLDJFQUEyRTtRQUMzRSx5RUFBeUU7UUFDekUsOERBQThEO1FBQzlELG1CQUFtQjtRQUNuQixPQUFPNEQsaUJBQ0xwRSxhQUNBOEQsYUFDQSxNQUNBSCw2QkFDQXJELHVCQUNBRyxhQUNBRDtJQUVKO0lBRUEsOEVBQThFO0lBQzlFLHdFQUF3RTtJQUN4RSw2Q0FBNkM7SUFDN0MsTUFBTU0sdUJBQXVCVixpQkFBaUIsT0FBT0EsWUFBWSxDQUFDLEVBQUUsR0FBRztJQUN2RSxNQUFNaUIsZUFBZSxJQUFJRjtJQUN6QixNQUFNa0QsNEJBQ0pYLHNCQUFzQnRCLFlBQVlzQixrQkFBa0J6QyxjQUFjLEdBQUc7SUFDdkUsTUFBTXFELG9CQUFvQixJQUFJbkQsSUFBSWtEO0lBQ2xDLElBQUk5Qyw2QkFFQSxDQUFDO0lBQ0wsSUFBSUQsc0JBQXNCO0lBQzFCLElBQUkwQyxlQUFlO1FBQ2pCLHVFQUF1RTtRQUN2RSw0RUFBNEU7UUFDNUUsNENBQTRDO1FBQzVDLHdFQUF3RTtRQUN4RSxxRUFBcUU7UUFDckUsMkRBQTJEO1FBQzNEeEQseUJBQXlCK0QsSUFBSSxDQUFDOUQ7SUFDaEMsT0FBTztRQUNMLElBQUssSUFBSWUsb0JBQW9CdUMsb0JBQXFCO1lBQ2hELE1BQU1TLG1CQUNKVCxtQkFBbUIsQ0FBQ3ZDLGlCQUFpQjtZQUN2QyxNQUFNSyxvQkFDSmYseUJBQXlCLE9BQ3JCQSxvQkFBb0IsQ0FBQ1UsaUJBQWlCLEdBQ3RDO1lBQ04sTUFBTWlELDBCQUNKSiw4QkFBOEIsT0FDMUJBLDBCQUEwQnpDLEdBQUcsQ0FBQ0osb0JBQzlCWTtZQUNOLE1BQU1zQyxlQUFlRixnQkFBZ0IsQ0FBQyxFQUFFO1lBQ3hDLE1BQU1HLG1CQUFtQmxFLFlBQVl1QixNQUFNLENBQUM7Z0JBQzFDUjtnQkFDQWtEO2FBQ0Q7WUFDRCxNQUFNRSxrQkFBa0IxQyxDQUFBQSxHQUFBQSxzQkFBQUEsb0JBQW9CLEVBQUN3QztZQUU3QyxNQUFNRyx5QkFDSkosNEJBQTRCckMsWUFDeEJxQyx3QkFBd0I3QyxHQUFHLENBQUNnRCxtQkFDNUJ4QztZQUVOLE1BQU1FLFlBQVl1Qiw0QkFDaEI3RCxhQUNBd0Usa0JBQ0FLLHdCQUNBaEQsbUJBQ0E4Qiw2QkFDQXJELHVCQUNBcUUsa0JBQ0FuRTtZQUVGYSxhQUFheUIsR0FBRyxDQUFDdEIsa0JBQWtCYztZQUNuQyxNQUFNWSwwQkFBMEJaLFVBQVV4QyxrQkFBa0I7WUFDNUQsSUFBSW9ELDRCQUE0QixNQUFNO2dCQUNwQywwQ0FBMEM7Z0JBQzFDNUIsc0JBQXNCO2dCQUN0QkMsMEJBQTBCLENBQUNDLGlCQUFpQixHQUFHMEI7WUFDakQsT0FBTztnQkFDTDNCLDBCQUEwQixDQUFDQyxpQkFBaUIsR0FBR2dEO1lBQ2pEO1lBQ0EsTUFBTXpCLG9CQUFvQlQsVUFBVXpDLElBQUk7WUFDeEMsSUFBSWtELHNCQUFzQixNQUFNO2dCQUM5QixNQUFNQyxxQkFBc0MsSUFBSTdCO2dCQUNoRDZCLG1CQUFtQkYsR0FBRyxDQUFDOEIsaUJBQWlCN0I7Z0JBQ3hDdUIsa0JBQWtCeEIsR0FBRyxDQUFDdEIsa0JBQWtCd0I7WUFDMUM7UUFDRjtJQUNGO0lBRUEsT0FBTztRQUNMLGtEQUFrRDtRQUNsRCx1RUFBdUU7UUFDdkUsNEVBQTRFO1FBQzVFLHNCQUFzQjtRQUN0QnBELE9BQU9rRTtRQUNQakUsTUFBTTtZQUNKdUQsVUFBVTtZQUNWLCtEQUErRDtZQUMvRCx1QkFBdUI7WUFDdkJDO1lBQ0FDLGFBQWE7WUFDYkM7WUFDQWxELGNBQWM7WUFDZG1EO1lBQ0F2QyxnQkFBZ0JxRDtZQUNoQnRFLGFBQWFpRTtRQUNmO1FBQ0FuRSxvQkFBb0J3QixzQkFDaEJtQyxnQ0FBZ0NLLGFBQWF2Qyw4QkFDN0M7UUFDSnhCLFVBQVVzQjtJQUNaO0FBQ0Y7QUFFQSxTQUFTb0MsZ0NBQ1BxQixlQUFrQyxFQUNsQ0MsV0FBOEQ7SUFFOUQsTUFBTUMsUUFBMkI7UUFBQ0YsZUFBZSxDQUFDLEVBQUU7UUFBRUM7S0FBWTtJQUNsRSw0RUFBNEU7SUFDNUUsMkVBQTJFO0lBQzNFLHVDQUF1QztJQUN2QyxJQUFJLEtBQUtELGlCQUFpQjtRQUN4QkUsS0FBSyxDQUFDLEVBQUUsR0FBR0YsZUFBZSxDQUFDLEVBQUU7SUFDL0I7SUFDQSxJQUFJLEtBQUtBLGlCQUFpQjtRQUN4QkUsS0FBSyxDQUFDLEVBQUUsR0FBR0YsZUFBZSxDQUFDLEVBQUU7SUFDL0I7SUFDQSxJQUFJLEtBQUtBLGlCQUFpQjtRQUN4QkUsS0FBSyxDQUFDLEVBQUUsR0FBR0YsZUFBZSxDQUFDLEVBQUU7SUFDL0I7SUFDQSxPQUFPRTtBQUNUO0FBRUEsU0FBU1osaUJBQ1BwRSxXQUFtQixFQUNuQjhELFdBQThCLEVBQzlCMUQsWUFBc0MsRUFDdENDLFlBQTZCLEVBQzdCQyxxQkFBOEIsRUFDOUJHLFdBQThCLEVBQzlCRCx3QkFBa0Q7SUFFbEQsc0VBQXNFO0lBRXRFLDZFQUE2RTtJQUM3RSwyREFBMkQ7SUFDM0QsTUFBTVYscUJBQXFCMkQsZ0NBQ3pCSyxhQUNBQSxXQUFXLENBQUMsRUFBRTtJQUVoQmhFLGtCQUFrQixDQUFDLEVBQUUsR0FBRztJQUV4QixNQUFNbUYsVUFBZ0I7UUFDcEJyRixPQUFPa0U7UUFFUCw0RUFBNEU7UUFDNUVqRSxNQUFNcUYsdUJBQ0psRixhQUNBOEQsYUFDQTFELGNBQ0FDLGNBQ0FDLHVCQUNBRyxhQUNBRDtRQUVGLHlFQUF5RTtRQUN6RSw0RUFBNEU7UUFDNUVWO1FBQ0FDLFVBQVU7SUFDWjtJQUNBLE9BQU9rRjtBQUNUO0FBRUEsU0FBU3pDLGdCQUFnQjJDLGlCQUFvQztJQUMzRCxtRUFBbUU7SUFDbkUsMERBQTBEO0lBQzFELE9BQU87UUFDTHZGLE9BQU91RjtRQUNQdEYsTUFBTTtRQUNOQyxvQkFBb0I7UUFDcEJDLFVBQVU7SUFDWjtBQUNGO0FBaUJPLFNBQVNQLHdCQUNkNEYsSUFBdUIsRUFDdkJDLGVBQW1EO0lBRW5EQSxnQkFBZ0JDLElBQUksQ0FDbEIsQ0FBQTtZQUFDLEVBQUVDLFVBQVUsRUFBNkIsR0FBQTtRQUN4QyxJQUFJLE9BQU9BLGVBQWUsVUFBVTtZQUNsQyxzRUFBc0U7WUFDdEUsMkRBQTJEO1lBQzNELGdCQUFnQjtZQUNoQjtRQUNGO1FBQ0EsS0FBSyxNQUFNQyx3QkFBd0JELFdBQVk7WUFDN0MsTUFBTSxFQUNKOUUsV0FBVyxFQUNYZ0YsTUFBTUMsaUJBQWlCLEVBQ3ZCQyxVQUFVQyxXQUFXLEVBQ3JCckMsTUFBTXNDLFdBQVcsRUFDbEIsR0FBR0w7WUFFSixJQUFJLENBQUNJLGFBQWE7Z0JBSWhCO1lBQ0Y7WUFFQUUsZ0NBQ0VWLE1BQ0EzRSxhQUNBaUYsbUJBQ0FFLGFBQ0FDO1FBRUo7UUFFQSx3RUFBd0U7UUFDeEUscUVBQXFFO1FBQ3JFLDZEQUE2RDtRQUM3RHRHLFVBQVU2RixNQUFNO0lBQ2xCLEdBQ0EsQ0FBQ1c7UUFDQywyQ0FBMkM7UUFDM0N4RyxVQUFVNkYsTUFBTVc7SUFDbEI7QUFFSjtBQUVBLFNBQVNELGdDQUNQRSxRQUEyQixFQUMzQnZGLFdBQThCLEVBQzlCaUYsaUJBQW9DLEVBQ3BDRSxXQUE4QixFQUM5QkMsV0FBcUI7SUFFckIsNEVBQTRFO0lBQzVFLDBFQUEwRTtJQUMxRSxxQ0FBcUM7SUFDckMsRUFBRTtJQUNGLDhFQUE4RTtJQUM5RSxxQ0FBcUM7SUFDckMsRUFBRTtJQUNGLDZEQUE2RDtJQUM3RCxFQUFFO0lBQ0YseUVBQXlFO0lBQ3pFLElBQUlULE9BQU9ZO0lBQ1gsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUl4RixZQUFZbUMsTUFBTSxFQUFFcUQsS0FBSyxFQUFHO1FBQzlDLE1BQU16RSxtQkFBMkJmLFdBQVcsQ0FBQ3dGLEVBQUU7UUFDL0MsTUFBTUMsVUFBbUJ6RixXQUFXLENBQUN3RixJQUFJLEVBQUU7UUFDM0MsTUFBTTVFLGVBQWUrRCxLQUFLckYsUUFBUTtRQUNsQyxJQUFJc0IsaUJBQWlCLE1BQU07WUFDekIsTUFBTWlCLFlBQVlqQixhQUFhTyxHQUFHLENBQUNKO1lBQ25DLElBQUljLGNBQWNGLFdBQVc7Z0JBQzNCLE1BQU0rRCxjQUFjN0QsVUFBVTFDLEtBQUssQ0FBQyxFQUFFO2dCQUN0QyxJQUFJaUQsQ0FBQUEsR0FBQUEsZUFBQUEsWUFBWSxFQUFDcUQsU0FBU0MsY0FBYztvQkFDdEMsbUVBQW1FO29CQUNuRWYsT0FBTzlDO29CQUNQO2dCQUNGO1lBQ0Y7UUFDRjtRQUNBLDJFQUEyRTtRQUMzRSw0RUFBNEU7UUFDNUUsd0VBQXdFO1FBQ3hFLDhCQUE4QjtRQUM5QjtJQUNGO0lBRUE4RCxrQ0FDRWhCLE1BQ0FNLG1CQUNBRSxhQUNBQztBQUVKO0FBRUEsU0FBU08sa0NBQ1BoQixJQUF1QixFQUN2Qk0saUJBQW9DLEVBQ3BDRSxXQUE4QixFQUM5QkMsV0FBcUI7SUFFckIsSUFBSVQsS0FBS3RGLGtCQUFrQixLQUFLLE1BQU07UUFDcEMsNERBQTREO1FBQzVEO0lBQ0Y7SUFFQSwwRUFBMEU7SUFDMUUsNENBQTRDO0lBQzVDLE1BQU11QixlQUFlK0QsS0FBS3JGLFFBQVE7SUFDbEMsTUFBTXNHLFdBQVdqQixLQUFLdkYsSUFBSTtJQUMxQixJQUFJd0IsaUJBQWlCLE1BQU07UUFDekIsd0VBQXdFO1FBQ3hFLGlFQUFpRTtRQUNqRSxvQkFBb0I7UUFDcEIsSUFBSWdGLGFBQWEsTUFBTTtZQUNyQkMsdUJBQ0VELFVBQ0FqQixLQUFLeEYsS0FBSyxFQUNWOEYsbUJBQ0FFLGFBQ0FDO1lBRUYsK0RBQStEO1lBQy9EVCxLQUFLdEYsa0JBQWtCLEdBQUc7UUFDNUI7UUFDQTtJQUNGO0lBQ0EsMkVBQTJFO0lBQzNFLHdEQUF3RDtJQUN4RCxNQUFNeUcsaUJBQWlCYixpQkFBaUIsQ0FBQyxFQUFFO0lBQzNDLE1BQU1jLHNCQUFzQlosV0FBVyxDQUFDLEVBQUU7SUFFMUMsSUFBSyxNQUFNcEUsb0JBQW9Ca0Usa0JBQW1CO1FBQ2hELE1BQU1lLHlCQUNKRixjQUFjLENBQUMvRSxpQkFBaUI7UUFDbEMsTUFBTWtGLG1CQUNKRixtQkFBbUIsQ0FBQ2hGLGlCQUFpQjtRQUV2QyxNQUFNYyxZQUFZakIsYUFBYU8sR0FBRyxDQUFDSjtRQUNuQyxJQUFJYyxjQUFjRixXQUFXO1lBQzNCLE1BQU0rRCxjQUFjN0QsVUFBVTFDLEtBQUssQ0FBQyxFQUFFO1lBQ3RDLElBQ0VpRCxDQUFBQSxHQUFBQSxlQUFBQSxZQUFZLEVBQUM0RCxzQkFBc0IsQ0FBQyxFQUFFLEVBQUVOLGdCQUN4Q08scUJBQXFCLFFBQ3JCQSxxQkFBcUJ0RSxXQUNyQjtnQkFDQSxtRUFBbUU7Z0JBQ25FLE9BQU9nRSxrQ0FDTDlELFdBQ0FtRSx3QkFDQUMsa0JBQ0FiO1lBRUo7UUFDRjtJQUNBLDJFQUEyRTtJQUMzRSxzRUFBc0U7SUFDdEUsd0VBQXdFO0lBQ3hFLDhCQUE4QjtJQUNoQztBQUNGO0FBRUEsU0FBU1gsdUJBQ1BsRixXQUFtQixFQUNuQjhELFdBQThCLEVBQzlCMUQsWUFBc0MsRUFDdENDLFlBQTZCLEVBQzdCQyxxQkFBOEIsRUFDOUJHLFdBQThCLEVBQzlCRCx3QkFBa0Q7SUFFbEQsTUFBTXVELHNCQUFzQkQsV0FBVyxDQUFDLEVBQUU7SUFDMUMsTUFBTWhELHVCQUF1QlYsaUJBQWlCLE9BQU9BLFlBQVksQ0FBQyxFQUFFLEdBQUc7SUFFdkUsTUFBTWEsaUJBQWlCLElBQUlFO0lBQzNCLElBQUssSUFBSUssb0JBQW9CdUMsb0JBQXFCO1FBQ2hELE1BQU1TLG1CQUNKVCxtQkFBbUIsQ0FBQ3ZDLGlCQUFpQjtRQUN2QyxNQUFNSyxvQkFDSmYseUJBQXlCLE9BQ3JCQSxvQkFBb0IsQ0FBQ1UsaUJBQWlCLEdBQ3RDO1FBRU4sTUFBTWtELGVBQWVGLGdCQUFnQixDQUFDLEVBQUU7UUFDeEMsTUFBTUcsbUJBQW1CbEUsWUFBWXVCLE1BQU0sQ0FBQztZQUMxQ1I7WUFDQWtEO1NBQ0Q7UUFDRCxNQUFNRSxrQkFBa0IxQyxDQUFBQSxHQUFBQSxzQkFBQUEsb0JBQW9CLEVBQUN3QztRQUU3QyxNQUFNM0Isb0JBQW9CbUMsdUJBQ3hCbEYsYUFDQXdFLGtCQUNBM0Msc0JBQXNCTyxZQUFZLE9BQU9QLG1CQUN6Q3hCLGNBQ0FDLHVCQUNBcUUsa0JBQ0FuRTtRQUdGLE1BQU13QyxxQkFBc0MsSUFBSTdCO1FBQ2hENkIsbUJBQW1CRixHQUFHLENBQUM4QixpQkFBaUI3QjtRQUN4QzlCLGVBQWU2QixHQUFHLENBQUN0QixrQkFBa0J3QjtJQUN2QztJQUVBLDRFQUE0RTtJQUM1RSxtRUFBbUU7SUFDbkUsTUFBTWdCLGdCQUFnQi9DLGVBQWUwRixJQUFJLEtBQUs7SUFFOUMsSUFBSTNDLGVBQWU7UUFDakIsdUVBQXVFO1FBQ3ZFLDRFQUE0RTtRQUM1RSw0Q0FBNEM7UUFDNUMsd0VBQXdFO1FBQ3hFLHFFQUFxRTtRQUNyRSwyREFBMkQ7UUFDM0R4RCx5QkFBeUIrRCxJQUFJLENBQUM5RDtJQUNoQztJQUVBLE1BQU1tRyxtQkFBbUJ4RyxpQkFBaUIsT0FBT0EsWUFBWSxDQUFDLEVBQUUsR0FBRztJQUNuRSxNQUFNeUcsdUJBQXVCekcsaUJBQWlCLE9BQU9BLFlBQVksQ0FBQyxFQUFFLEdBQUc7SUFDdkUsT0FBTztRQUNMZ0QsVUFBVTtRQUNWbkMsZ0JBQWdCQTtRQUVoQnFDLGFBQWFzRCxxQkFBcUJ4RSxZQUFZd0UsbUJBQW1CO1FBQ2pFdkcsY0FBYzJELGdCQUFnQjNELGVBQWU7WUFBQztZQUFNO1NBQUs7UUFFekQsNEVBQTRFO1FBQzVFLDRFQUE0RTtRQUM1RSx1Q0FBdUM7UUFDdkNtRCxTQUFTcUQseUJBQXlCekUsWUFBWXlFLHVCQUF1QjtRQUVyRSxxRUFBcUU7UUFDckUsd0NBQXdDO1FBQ3hDeEQsS0FBS3lEO1FBQ0x2RCxNQUFNUyxnQkFBaUI4QyxzQkFBMEM7UUFFakU5RztJQUNGO0FBQ0Y7QUFFQSxTQUFTc0csdUJBQ1BTLFNBQW9CLEVBQ3BCQyxTQUE0QixFQUM1QkMsV0FBOEIsRUFDOUJyQixXQUE4QixFQUM5QkMsV0FBcUI7SUFFckIsOEVBQThFO0lBQzlFLDhFQUE4RTtJQUM5RSw0RUFBNEU7SUFDNUUsOEVBQThFO0lBQzlFLDhEQUE4RDtJQUM5RCw2QkFBNkI7SUFDN0IsRUFBRTtJQUNGLHFFQUFxRTtJQUNyRSw4RUFBOEU7SUFDOUUsZ0VBQWdFO0lBQ2hFLE1BQU1xQixvQkFBb0JGLFNBQVMsQ0FBQyxFQUFFO0lBQ3RDLE1BQU1HLHNCQUFzQkYsV0FBVyxDQUFDLEVBQUU7SUFDMUMsTUFBTUcsZUFBZXhCLFdBQVcsQ0FBQyxFQUFFO0lBRW5DLDhFQUE4RTtJQUM5RSw2RUFBNkU7SUFDN0UsdUNBQXVDO0lBQ3ZDLE1BQU0zRSxpQkFBaUI4RixVQUFVOUYsY0FBYztJQUMvQyxJQUFLLElBQUlPLG9CQUFvQjBGLGtCQUFtQjtRQUM5QyxNQUFNRyxpQkFDSkgsaUJBQWlCLENBQUMxRixpQkFBaUI7UUFDckMsTUFBTThGLG1CQUNKSCxtQkFBbUIsQ0FBQzNGLGlCQUFpQjtRQUN2QyxNQUFNK0YsWUFDSkgsWUFBWSxDQUFDNUYsaUJBQWlCO1FBRWhDLE1BQU1nRyxrQkFBa0J2RyxlQUFlVyxHQUFHLENBQUNKO1FBQzNDLE1BQU1pRyxtQkFBbUJKLGNBQWMsQ0FBQyxFQUFFO1FBQzFDLE1BQU1LLHNCQUFzQnhGLENBQUFBLEdBQUFBLHNCQUFBQSxvQkFBb0IsRUFBQ3VGO1FBRWpELE1BQU1FLGlCQUNKSCxvQkFBb0JwRixZQUNoQm9GLGdCQUFnQjVGLEdBQUcsQ0FBQzhGLHVCQUNwQnRGO1FBRU4sSUFBSXVGLG1CQUFtQnZGLFdBQVc7WUFDaEMsSUFDRWtGLHFCQUFxQmxGLGFBQ3JCUyxDQUFBQSxHQUFBQSxlQUFBQSxZQUFZLEVBQUM0RSxrQkFBa0JILGdCQUFnQixDQUFDLEVBQUUsR0FDbEQ7Z0JBQ0EsSUFBSUMsY0FBY25GLGFBQWFtRixjQUFjLE1BQU07b0JBQ2pELCtEQUErRDtvQkFDL0RqQix1QkFDRXFCLGdCQUNBTixnQkFDQUMsa0JBQ0FDLFdBQ0ExQjtnQkFFSixPQUFPO29CQUNMLGtFQUFrRTtvQkFDbEUsb0VBQW9FO29CQUNwRSxzRUFBc0U7b0JBQ3RFLCtDQUErQztvQkFDL0MrQixzQkFBc0JQLGdCQUFnQk0sZ0JBQWdCO2dCQUN4RDtZQUNGLE9BQU87Z0JBQ0wsa0VBQWtFO2dCQUNsRSx1QkFBdUI7Z0JBQ3ZCQyxzQkFBc0JQLGdCQUFnQk0sZ0JBQWdCO1lBQ3hEO1FBQ0YsT0FBTztRQUNMLHdFQUF3RTtRQUN4RSxnRUFBZ0U7UUFDaEUsaUVBQWlFO1FBQ2pFLHdEQUF3RDtRQUMxRDtJQUNGO0lBRUEsMkVBQTJFO0lBQzNFLHFCQUFxQjtJQUNyQixNQUFNdEUsTUFBTTBELFVBQVUxRCxHQUFHO0lBQ3pCLE1BQU13RSxxQkFBcUJqQyxXQUFXLENBQUMsRUFBRTtJQUN6QyxJQUFJdkMsUUFBUSxNQUFNO1FBQ2hCLG9FQUFvRTtRQUNwRSxxRUFBcUU7UUFDckUwRCxVQUFVMUQsR0FBRyxHQUFHd0U7SUFDbEIsT0FBTyxJQUFJQyxjQUFjekUsTUFBTTtRQUM3QiwwRUFBMEU7UUFDMUUsc0VBQXNFO1FBQ3RFLHNFQUFzRTtRQUN0RUEsSUFBSTBFLE9BQU8sQ0FBQ0Y7SUFDZCxPQUFPO0lBQ0wsdUVBQXVFO0lBQ3ZFLHNFQUFzRTtJQUN4RTtJQUVBLDhFQUE4RTtJQUM5RSx5RUFBeUU7SUFDekUsY0FBYztJQUNkLE1BQU10RSxPQUFPd0QsVUFBVXhELElBQUk7SUFDM0IsSUFBSXVFLGNBQWN2RSxPQUFPO1FBQ3ZCQSxLQUFLd0UsT0FBTyxDQUFDbEM7SUFDZjtBQUNGO0FBRU8sU0FBU3RHLFVBQVU2RixJQUF1QixFQUFFVyxLQUFVO0lBQzNELE1BQU1nQixZQUFZM0IsS0FBS3ZGLElBQUk7SUFDM0IsSUFBSWtILGNBQWMsTUFBTTtRQUN0QiwrQ0FBK0M7UUFDL0M7SUFDRjtJQUVBLE1BQU0xRixlQUFlK0QsS0FBS3JGLFFBQVE7SUFDbEMsSUFBSXNCLGlCQUFpQixNQUFNO1FBQ3pCLGtFQUFrRTtRQUNsRSxhQUFhO1FBQ2J1RyxzQkFBc0J4QyxLQUFLeEYsS0FBSyxFQUFFbUgsV0FBV2hCO0lBQy9DLE9BQU87UUFDTCxzRUFBc0U7UUFDdEUsMkVBQTJFO1FBQzNFLDZCQUE2QjtRQUM3QixLQUFLLE1BQU16RCxhQUFhakIsYUFBYTJHLE1BQU0sR0FBSTtZQUM3Q3pJLFVBQVUrQyxXQUFXeUQ7UUFDdkI7SUFDRjtJQUVBLCtEQUErRDtJQUMvRFgsS0FBS3RGLGtCQUFrQixHQUFHO0FBQzVCO0FBRUEsU0FBUzhILHNCQUNQOUQsV0FBOEIsRUFDOUJpRCxTQUFvQixFQUNwQmhCLEtBQVU7SUFFViw2RUFBNkU7SUFDN0UseUNBQXlDO0lBQ3pDLEVBQUU7SUFDRiw2REFBNkQ7SUFDN0QsTUFBTWhDLHNCQUFzQkQsV0FBVyxDQUFDLEVBQUU7SUFDMUMsTUFBTTdDLGlCQUFpQjhGLFVBQVU5RixjQUFjO0lBQy9DLElBQUssSUFBSU8sb0JBQW9CdUMsb0JBQXFCO1FBQ2hELE1BQU1TLG1CQUNKVCxtQkFBbUIsQ0FBQ3ZDLGlCQUFpQjtRQUN2QyxNQUFNZ0csa0JBQWtCdkcsZUFBZVcsR0FBRyxDQUFDSjtRQUMzQyxJQUFJZ0csb0JBQW9CcEYsV0FBVztZQUdqQztRQUNGO1FBQ0EsTUFBTXNDLGVBQWVGLGdCQUFnQixDQUFDLEVBQUU7UUFDeEMsTUFBTUksa0JBQWtCMUMsQ0FBQUEsR0FBQUEsc0JBQUFBLG9CQUFvQixFQUFDd0M7UUFDN0MsTUFBTWlELGlCQUFpQkgsZ0JBQWdCNUYsR0FBRyxDQUFDZ0Q7UUFDM0MsSUFBSStDLG1CQUFtQnZGLFdBQVc7WUFDaEN3RixzQkFBc0JwRCxrQkFBa0JtRCxnQkFBZ0I1QjtRQUMxRCxPQUFPO1FBQ0wsd0VBQXdFO1FBQ3hFLHdEQUF3RDtRQUMxRDtJQUNGO0lBQ0EsTUFBTTFDLE1BQU0wRCxVQUFVMUQsR0FBRztJQUN6QixJQUFJeUUsY0FBY3pFLE1BQU07UUFDdEIsSUFBSTBDLFVBQVUsTUFBTTtZQUNsQixnREFBZ0Q7WUFDaEQxQyxJQUFJMEUsT0FBTyxDQUFDO1FBQ2QsT0FBTztZQUNMLCtDQUErQztZQUMvQzFFLElBQUk0RSxNQUFNLENBQUNsQztRQUNiO0lBQ0Y7SUFFQSw4RUFBOEU7SUFDOUUsNEVBQTRFO0lBQzVFLDJFQUEyRTtJQUMzRSw2REFBNkQ7SUFDN0QsTUFBTXhDLE9BQU93RCxVQUFVeEQsSUFBSTtJQUMzQixJQUFJdUUsY0FBY3ZFLE9BQU87UUFDdkJBLEtBQUt3RSxPQUFPLENBQUM7SUFDZjtBQUNGO0FBRU8sU0FBU3JJLHFDQUNkTyxZQUF1QixFQUN2QjZELFdBQThCO0lBRTlCLDJFQUEyRTtJQUMzRSw0RUFBNEU7SUFDNUUsMkVBQTJFO0lBQzNFLDRFQUE0RTtJQUM1RSwwQ0FBMEM7SUFDMUMsRUFBRTtJQUNGLDZFQUE2RTtJQUM3RSw4RUFBOEU7SUFDOUUsd0RBQXdEO0lBRXhELE1BQU1DLHNCQUFzQkQsV0FBVyxDQUFDLEVBQUU7SUFDMUMsTUFBTTlDLG9CQUFvQmYsYUFBYWdCLGNBQWM7SUFDckQsTUFBTWlILG9CQUFvQixJQUFJL0csSUFBSUg7SUFDbEMsSUFBSyxJQUFJUSxvQkFBb0J1QyxvQkFBcUI7UUFDaEQsTUFBTVMsbUJBQ0pULG1CQUFtQixDQUFDdkMsaUJBQWlCO1FBQ3ZDLE1BQU1rRCxlQUFlRixnQkFBZ0IsQ0FBQyxFQUFFO1FBQ3hDLE1BQU1JLGtCQUFrQjFDLENBQUFBLEdBQUFBLHNCQUFBQSxvQkFBb0IsRUFBQ3dDO1FBQzdDLE1BQU0vQyxxQkFBcUJYLGtCQUFrQlksR0FBRyxDQUFDSjtRQUNqRCxJQUFJRyx1QkFBdUJTLFdBQVc7WUFDcEMsTUFBTUMsb0JBQW9CVixtQkFBbUJDLEdBQUcsQ0FBQ2dEO1lBQ2pELElBQUl2QyxzQkFBc0JELFdBQVc7Z0JBQ25DLE1BQU1XLG9CQUFvQnJELHFDQUN4QjJDLG1CQUNBbUM7Z0JBRUYsTUFBTXhCLHFCQUFxQixJQUFJN0IsSUFBSVE7Z0JBQ25DcUIsbUJBQW1CRixHQUFHLENBQUM4QixpQkFBaUI3QjtnQkFDeENtRixrQkFBa0JwRixHQUFHLENBQUN0QixrQkFBa0J3QjtZQUMxQztRQUNGO0lBQ0Y7SUFFQSxrRUFBa0U7SUFDbEUsRUFBRTtJQUNGLDBFQUEwRTtJQUMxRSw0RUFBNEU7SUFDNUUsMkVBQTJFO0lBQzNFLDhFQUE4RTtJQUM5RSw2RUFBNkU7SUFDN0Usc0JBQXNCO0lBQ3RCLE1BQU1LLE1BQU1wRCxhQUFhb0QsR0FBRztJQUM1QixNQUFNOEUsb0JBQW9CTCxjQUFjekUsUUFBUUEsSUFBSStFLE1BQU0sS0FBSztJQUUvRCxPQUFPO1FBQ0xoRixVQUFVO1FBQ1ZDO1FBQ0FFLE1BQU10RCxhQUFhc0QsSUFBSTtRQUV2QmxELGNBQWM4SCxvQkFBb0JsSSxhQUFhSSxZQUFZLEdBQUc7WUFBQztZQUFNO1NBQUs7UUFDMUVpRCxhQUFhNkUsb0JBQW9CbEksYUFBYXFELFdBQVcsR0FBRztRQUM1REUsU0FBU3ZELGFBQWF1RCxPQUFPO1FBRTdCLGtEQUFrRDtRQUNsRHZDLGdCQUFnQmlIO1FBRWhCbEksYUFBYUMsYUFBYUQsV0FBVztJQUN2QztBQUNGO0FBRUEsTUFBTXFJLFdBQVdDO0FBOEJqQiw4RUFBOEU7QUFDOUUsZ0ZBQWdGO0FBQ2hGLDhFQUE4RTtBQUM5RSxtRUFBbUU7QUFDbkUsU0FBU1IsY0FBY1MsS0FBVTtJQUMvQixPQUFPQSxTQUFTQSxNQUFNQyxHQUFHLEtBQUtIO0FBQ2hDO0FBRUEsU0FBU3ZCO0lBQ1AsSUFBSWlCO0lBQ0osSUFBSUU7SUFDSixNQUFNUSxhQUFhLElBQUlDLFFBQXlCLENBQUNDLEtBQUtDO1FBQ3BEYixVQUFVWTtRQUNWVixTQUFTVztJQUNYO0lBQ0FILFdBQVdMLE1BQU0sR0FBRztJQUNwQkssV0FBV1YsT0FBTyxHQUFHLENBQUNRO1FBQ3BCLElBQUlFLFdBQVdMLE1BQU0sS0FBSyxXQUFXO1lBQ25DLE1BQU1TLGVBQXFDSjtZQUMzQ0ksYUFBYVQsTUFBTSxHQUFHO1lBQ3RCUyxhQUFhTixLQUFLLEdBQUdBO1lBQ3JCUixRQUFRUTtRQUNWO0lBQ0Y7SUFDQUUsV0FBV1IsTUFBTSxHQUFHLENBQUNsQztRQUNuQixJQUFJMEMsV0FBV0wsTUFBTSxLQUFLLFdBQVc7WUFDbkMsTUFBTVUsY0FBbUNMO1lBQ3pDSyxZQUFZVixNQUFNLEdBQUc7WUFDckJVLFlBQVlDLE1BQU0sR0FBR2hEO1lBQ3JCa0MsT0FBT2xDO1FBQ1Q7SUFDRjtJQUNBMEMsV0FBV0QsR0FBRyxHQUFHSDtJQUNqQixPQUFPSTtBQUNUIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDEwNjYyLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2NsZWFyLWNhY2hlLW5vZGUtZGF0YS1mb3Itc2VnbWVudC1wYXRoLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgRmxpZ2h0U2VnbWVudFBhdGggfSBmcm9tICcuLi8uLi8uLi9zZXJ2ZXIvYXBwLXJlbmRlci90eXBlcydcbmltcG9ydCB0eXBlIHsgQ2FjaGVOb2RlIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgeyBnZXROZXh0RmxpZ2h0U2VnbWVudFBhdGggfSBmcm9tICcuLi8uLi9mbGlnaHQtZGF0YS1oZWxwZXJzJ1xuaW1wb3J0IHsgY3JlYXRlUm91dGVyQ2FjaGVLZXkgfSBmcm9tICcuL2NyZWF0ZS1yb3V0ZXItY2FjaGUta2V5J1xuXG4vKipcbiAqIFRoaXMgd2lsbCBjbGVhciB0aGUgQ2FjaGVOb2RlIGRhdGEgZm9yIGEgcGFydGljdWxhciBzZWdtZW50IHBhdGguIFRoaXMgd2lsbCBjYXVzZSBhIGxhenktZmV0Y2ggaW4gbGF5b3V0IHJvdXRlciB0byBmaWxsIGluIG5ldyBkYXRhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJDYWNoZU5vZGVEYXRhRm9yU2VnbWVudFBhdGgoXG4gIG5ld0NhY2hlOiBDYWNoZU5vZGUsXG4gIGV4aXN0aW5nQ2FjaGU6IENhY2hlTm9kZSxcbiAgZmxpZ2h0U2VnbWVudFBhdGg6IEZsaWdodFNlZ21lbnRQYXRoXG4pOiB2b2lkIHtcbiAgY29uc3QgaXNMYXN0RW50cnkgPSBmbGlnaHRTZWdtZW50UGF0aC5sZW5ndGggPD0gMlxuXG4gIGNvbnN0IFtwYXJhbGxlbFJvdXRlS2V5LCBzZWdtZW50XSA9IGZsaWdodFNlZ21lbnRQYXRoXG4gIGNvbnN0IGNhY2hlS2V5ID0gY3JlYXRlUm91dGVyQ2FjaGVLZXkoc2VnbWVudClcblxuICBjb25zdCBleGlzdGluZ0NoaWxkU2VnbWVudE1hcCA9XG4gICAgZXhpc3RpbmdDYWNoZS5wYXJhbGxlbFJvdXRlcy5nZXQocGFyYWxsZWxSb3V0ZUtleSlcblxuICBsZXQgY2hpbGRTZWdtZW50TWFwID0gbmV3Q2FjaGUucGFyYWxsZWxSb3V0ZXMuZ2V0KHBhcmFsbGVsUm91dGVLZXkpXG5cbiAgaWYgKCFjaGlsZFNlZ21lbnRNYXAgfHwgY2hpbGRTZWdtZW50TWFwID09PSBleGlzdGluZ0NoaWxkU2VnbWVudE1hcCkge1xuICAgIGNoaWxkU2VnbWVudE1hcCA9IG5ldyBNYXAoZXhpc3RpbmdDaGlsZFNlZ21lbnRNYXApXG4gICAgbmV3Q2FjaGUucGFyYWxsZWxSb3V0ZXMuc2V0KHBhcmFsbGVsUm91dGVLZXksIGNoaWxkU2VnbWVudE1hcClcbiAgfVxuXG4gIGNvbnN0IGV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUgPSBleGlzdGluZ0NoaWxkU2VnbWVudE1hcD8uZ2V0KGNhY2hlS2V5KVxuICBsZXQgY2hpbGRDYWNoZU5vZGUgPSBjaGlsZFNlZ21lbnRNYXAuZ2V0KGNhY2hlS2V5KVxuXG4gIC8vIEluIGNhc2Ugb2YgbGFzdCBzZWdtZW50IHN0YXJ0IG9mZiB0aGUgZmV0Y2ggYXQgdGhpcyBsZXZlbCBhbmQgZG9uJ3QgY29weSBmdXJ0aGVyIGRvd24uXG4gIGlmIChpc0xhc3RFbnRyeSkge1xuICAgIGlmIChcbiAgICAgICFjaGlsZENhY2hlTm9kZSB8fFxuICAgICAgIWNoaWxkQ2FjaGVOb2RlLmxhenlEYXRhIHx8XG4gICAgICBjaGlsZENhY2hlTm9kZSA9PT0gZXhpc3RpbmdDaGlsZENhY2hlTm9kZVxuICAgICkge1xuICAgICAgY2hpbGRTZWdtZW50TWFwLnNldChjYWNoZUtleSwge1xuICAgICAgICBsYXp5RGF0YTogbnVsbCxcbiAgICAgICAgcnNjOiBudWxsLFxuICAgICAgICBwcmVmZXRjaFJzYzogbnVsbCxcbiAgICAgICAgaGVhZDogbnVsbCxcbiAgICAgICAgcHJlZmV0Y2hIZWFkOiBudWxsLFxuICAgICAgICBwYXJhbGxlbFJvdXRlczogbmV3IE1hcCgpLFxuICAgICAgICBsb2FkaW5nOiBudWxsLFxuICAgICAgICBuYXZpZ2F0ZWRBdDogLTEsXG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmICghY2hpbGRDYWNoZU5vZGUgfHwgIWV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUpIHtcbiAgICAvLyBTdGFydCBmZXRjaCBpbiB0aGUgcGxhY2Ugd2hlcmUgdGhlIGV4aXN0aW5nIGNhY2hlIGRvZXNuJ3QgaGF2ZSB0aGUgZGF0YSB5ZXQuXG4gICAgaWYgKCFjaGlsZENhY2hlTm9kZSkge1xuICAgICAgY2hpbGRTZWdtZW50TWFwLnNldChjYWNoZUtleSwge1xuICAgICAgICBsYXp5RGF0YTogbnVsbCxcbiAgICAgICAgcnNjOiBudWxsLFxuICAgICAgICBwcmVmZXRjaFJzYzogbnVsbCxcbiAgICAgICAgaGVhZDogbnVsbCxcbiAgICAgICAgcHJlZmV0Y2hIZWFkOiBudWxsLFxuICAgICAgICBwYXJhbGxlbFJvdXRlczogbmV3IE1hcCgpLFxuICAgICAgICBsb2FkaW5nOiBudWxsLFxuICAgICAgICBuYXZpZ2F0ZWRBdDogLTEsXG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChjaGlsZENhY2hlTm9kZSA9PT0gZXhpc3RpbmdDaGlsZENhY2hlTm9kZSkge1xuICAgIGNoaWxkQ2FjaGVOb2RlID0ge1xuICAgICAgbGF6eURhdGE6IGNoaWxkQ2FjaGVOb2RlLmxhenlEYXRhLFxuICAgICAgcnNjOiBjaGlsZENhY2hlTm9kZS5yc2MsXG4gICAgICBwcmVmZXRjaFJzYzogY2hpbGRDYWNoZU5vZGUucHJlZmV0Y2hSc2MsXG4gICAgICBoZWFkOiBjaGlsZENhY2hlTm9kZS5oZWFkLFxuICAgICAgcHJlZmV0Y2hIZWFkOiBjaGlsZENhY2hlTm9kZS5wcmVmZXRjaEhlYWQsXG4gICAgICBwYXJhbGxlbFJvdXRlczogbmV3IE1hcChjaGlsZENhY2hlTm9kZS5wYXJhbGxlbFJvdXRlcyksXG4gICAgICBsb2FkaW5nOiBjaGlsZENhY2hlTm9kZS5sb2FkaW5nLFxuICAgIH0gYXMgQ2FjaGVOb2RlXG4gICAgY2hpbGRTZWdtZW50TWFwLnNldChjYWNoZUtleSwgY2hpbGRDYWNoZU5vZGUpXG4gIH1cblxuICByZXR1cm4gY2xlYXJDYWNoZU5vZGVEYXRhRm9yU2VnbWVudFBhdGgoXG4gICAgY2hpbGRDYWNoZU5vZGUsXG4gICAgZXhpc3RpbmdDaGlsZENhY2hlTm9kZSxcbiAgICBnZXROZXh0RmxpZ2h0U2VnbWVudFBhdGgoZmxpZ2h0U2VnbWVudFBhdGgpXG4gIClcbn1cbiJdLCJuYW1lcyI6WyJjbGVhckNhY2hlTm9kZURhdGFGb3JTZWdtZW50UGF0aCIsIm5ld0NhY2hlIiwiZXhpc3RpbmdDYWNoZSIsImZsaWdodFNlZ21lbnRQYXRoIiwiaXNMYXN0RW50cnkiLCJsZW5ndGgiLCJwYXJhbGxlbFJvdXRlS2V5Iiwic2VnbWVudCIsImNhY2hlS2V5IiwiY3JlYXRlUm91dGVyQ2FjaGVLZXkiLCJleGlzdGluZ0NoaWxkU2VnbWVudE1hcCIsInBhcmFsbGVsUm91dGVzIiwiZ2V0IiwiY2hpbGRTZWdtZW50TWFwIiwiTWFwIiwic2V0IiwiZXhpc3RpbmdDaGlsZENhY2hlTm9kZSIsImNoaWxkQ2FjaGVOb2RlIiwibGF6eURhdGEiLCJyc2MiLCJwcmVmZXRjaFJzYyIsImhlYWQiLCJwcmVmZXRjaEhlYWQiLCJsb2FkaW5nIiwibmF2aWdhdGVkQXQiLCJnZXROZXh0RmxpZ2h0U2VnbWVudFBhdGgiXSwibWFwcGluZ3MiOiI7OzsrQkFRZ0JBLG9DQUFBQTs7O2VBQUFBOzs7bUNBTnlCO3NDQUNKO0FBSzlCLFNBQVNBLGlDQUNkQyxRQUFtQixFQUNuQkMsYUFBd0IsRUFDeEJDLGlCQUFvQztJQUVwQyxNQUFNQyxjQUFjRCxrQkFBa0JFLE1BQU0sSUFBSTtJQUVoRCxNQUFNLENBQUNDLGtCQUFrQkMsUUFBUSxHQUFHSjtJQUNwQyxNQUFNSyxXQUFXQyxDQUFBQSxHQUFBQSxzQkFBQUEsb0JBQW9CLEVBQUNGO0lBRXRDLE1BQU1HLDBCQUNKUixjQUFjUyxjQUFjLENBQUNDLEdBQUcsQ0FBQ047SUFFbkMsSUFBSU8sa0JBQWtCWixTQUFTVSxjQUFjLENBQUNDLEdBQUcsQ0FBQ047SUFFbEQsSUFBSSxDQUFDTyxtQkFBbUJBLG9CQUFvQkgseUJBQXlCO1FBQ25FRyxrQkFBa0IsSUFBSUMsSUFBSUo7UUFDMUJULFNBQVNVLGNBQWMsQ0FBQ0ksR0FBRyxDQUFDVCxrQkFBa0JPO0lBQ2hEO0lBRUEsTUFBTUcseUJBQXlCTiwyQkFBQUEsT0FBQUEsS0FBQUEsSUFBQUEsd0JBQXlCRSxHQUFHLENBQUNKO0lBQzVELElBQUlTLGlCQUFpQkosZ0JBQWdCRCxHQUFHLENBQUNKO0lBRXpDLHlGQUF5RjtJQUN6RixJQUFJSixhQUFhO1FBQ2YsSUFDRSxDQUFDYSxrQkFDRCxDQUFDQSxlQUFlQyxRQUFRLElBQ3hCRCxtQkFBbUJELHdCQUNuQjtZQUNBSCxnQkFBZ0JFLEdBQUcsQ0FBQ1AsVUFBVTtnQkFDNUJVLFVBQVU7Z0JBQ1ZDLEtBQUs7Z0JBQ0xDLGFBQWE7Z0JBQ2JDLE1BQU07Z0JBQ05DLGNBQWM7Z0JBQ2RYLGdCQUFnQixJQUFJRztnQkFDcEJTLFNBQVM7Z0JBQ1RDLGFBQWEsQ0FBQztZQUNoQjtRQUNGO1FBQ0E7SUFDRjtJQUVBLElBQUksQ0FBQ1Asa0JBQWtCLENBQUNELHdCQUF3QjtRQUM5QywrRUFBK0U7UUFDL0UsSUFBSSxDQUFDQyxnQkFBZ0I7WUFDbkJKLGdCQUFnQkUsR0FBRyxDQUFDUCxVQUFVO2dCQUM1QlUsVUFBVTtnQkFDVkMsS0FBSztnQkFDTEMsYUFBYTtnQkFDYkMsTUFBTTtnQkFDTkMsY0FBYztnQkFDZFgsZ0JBQWdCLElBQUlHO2dCQUNwQlMsU0FBUztnQkFDVEMsYUFBYSxDQUFDO1lBQ2hCO1FBQ0Y7UUFDQTtJQUNGO0lBRUEsSUFBSVAsbUJBQW1CRCx3QkFBd0I7UUFDN0NDLGlCQUFpQjtZQUNmQyxVQUFVRCxlQUFlQyxRQUFRO1lBQ2pDQyxLQUFLRixlQUFlRSxHQUFHO1lBQ3ZCQyxhQUFhSCxlQUFlRyxXQUFXO1lBQ3ZDQyxNQUFNSixlQUFlSSxJQUFJO1lBQ3pCQyxjQUFjTCxlQUFlSyxZQUFZO1lBQ3pDWCxnQkFBZ0IsSUFBSUcsSUFBSUcsZUFBZU4sY0FBYztZQUNyRFksU0FBU04sZUFBZU0sT0FBTztRQUNqQztRQUNBVixnQkFBZ0JFLEdBQUcsQ0FBQ1AsVUFBVVM7SUFDaEM7SUFFQSxPQUFPakIsaUNBQ0xpQixnQkFDQUQsd0JBQ0FTLENBQUFBLEdBQUFBLG1CQUFBQSx3QkFBd0IsRUFBQ3RCO0FBRTdCIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDEwNzQ0LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2FsaWFzZWQtcHJlZmV0Y2gtbmF2aWdhdGlvbnMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUge1xuICBDYWNoZU5vZGVTZWVkRGF0YSxcbiAgRmxpZ2h0Um91dGVyU3RhdGUsXG59IGZyb20gJy4uLy4uLy4uL3NlcnZlci9hcHAtcmVuZGVyL3R5cGVzJ1xuaW1wb3J0IHR5cGUgeyBDYWNoZU5vZGUgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB7XG4gIGFkZFNlYXJjaFBhcmFtc0lmUGFnZVNlZ21lbnQsXG4gIFBBR0VfU0VHTUVOVF9LRVksXG59IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9saWIvc2VnbWVudCdcbmltcG9ydCB0eXBlIHsgTm9ybWFsaXplZEZsaWdodERhdGEgfSBmcm9tICcuLi8uLi9mbGlnaHQtZGF0YS1oZWxwZXJzJ1xuaW1wb3J0IHsgY3JlYXRlRW1wdHlDYWNoZU5vZGUgfSBmcm9tICcuLi9hcHAtcm91dGVyJ1xuaW1wb3J0IHsgYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlIH0gZnJvbSAnLi9hcHBseS1yb3V0ZXItc3RhdGUtcGF0Y2gtdG8tdHJlZSdcbmltcG9ydCB7IGNyZWF0ZUhyZWZGcm9tVXJsIH0gZnJvbSAnLi9jcmVhdGUtaHJlZi1mcm9tLXVybCdcbmltcG9ydCB7IGNyZWF0ZVJvdXRlckNhY2hlS2V5IH0gZnJvbSAnLi9jcmVhdGUtcm91dGVyLWNhY2hlLWtleSdcbmltcG9ydCB7IGZpbGxDYWNoZVdpdGhOZXdTdWJUcmVlRGF0YUJ1dE9ubHlMb2FkaW5nIH0gZnJvbSAnLi9maWxsLWNhY2hlLXdpdGgtbmV3LXN1YnRyZWUtZGF0YSdcbmltcG9ydCB7IGhhbmRsZU11dGFibGUgfSBmcm9tICcuL2hhbmRsZS1tdXRhYmxlJ1xuaW1wb3J0IHR5cGUgeyBNdXRhYmxlLCBSZWFkb25seVJlZHVjZXJTdGF0ZSB9IGZyb20gJy4vcm91dGVyLXJlZHVjZXItdHlwZXMnXG5cbi8qKlxuICogVGhpcyBpcyBhIHN0b3AtZ2FwIHVudGlsIHBlci1zZWdtZW50IGNhY2hpbmcgaXMgaW1wbGVtZW50ZWQuIEl0IGxldmVyYWdlcyB0aGUgYGFsaWFzZWRgIGZsYWcgdGhhdCBpcyBhZGRlZFxuICogdG8gcHJlZmV0Y2ggZW50cmllcyB3aGVuIGl0J3MgZGV0ZXJtaW5lZCB0aGF0IHRoZSBsb2FkaW5nIHN0YXRlIGZyb20gdGhhdCBlbnRyeSBzaG91bGQgYmUgdXNlZCBmb3IgdGhpcyBuYXZpZ2F0aW9uLlxuICogVGhpcyBmdW5jdGlvbiB0YWtlcyB0aGUgYWxpYXNlZCBlbnRyeSBhbmQgb25seSBhcHBsaWVzIHRoZSBsb2FkaW5nIHN0YXRlIHRvIHRoZSB1cGRhdGVkIGNhY2hlIG5vZGUuXG4gKiBXZSBzaG91bGQgcmVtb3ZlIHRoaXMgb25jZSBwZXItc2VnbWVudCBmZXRjaGluZyBpcyBpbXBsZW1lbnRlZCBhcyBpZGVhbGx5IHRoZSBwcmVmZXRjaCBjYWNoZSB3aWxsIGNvbnRhaW4gYVxuICogbW9yZSBncmFudWxhciBzZWdtZW50IG1hcCBhbmQgc28gdGhlIHJvdXRlciB3aWxsIGJlIGFibGUgdG8gc2ltcGx5IHJlLXVzZSB0aGUgbG9hZGluZyBzZWdtZW50IGZvciB0aGUgbmV3IG5hdmlnYXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYW5kbGVBbGlhc2VkUHJlZmV0Y2hFbnRyeShcbiAgbmF2aWdhdGVkQXQ6IG51bWJlcixcbiAgc3RhdGU6IFJlYWRvbmx5UmVkdWNlclN0YXRlLFxuICBmbGlnaHREYXRhOiBzdHJpbmcgfCBOb3JtYWxpemVkRmxpZ2h0RGF0YVtdLFxuICB1cmw6IFVSTCxcbiAgbXV0YWJsZTogTXV0YWJsZVxuKSB7XG4gIGxldCBjdXJyZW50VHJlZSA9IHN0YXRlLnRyZWVcbiAgbGV0IGN1cnJlbnRDYWNoZSA9IHN0YXRlLmNhY2hlXG4gIGNvbnN0IGhyZWYgPSBjcmVhdGVIcmVmRnJvbVVybCh1cmwpXG4gIGxldCBhcHBsaWVkXG5cbiAgaWYgKHR5cGVvZiBmbGlnaHREYXRhID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgZm9yIChjb25zdCBub3JtYWxpemVkRmxpZ2h0RGF0YSBvZiBmbGlnaHREYXRhKSB7XG4gICAgLy8gSWYgdGhlIHNlZ21lbnQgZG9lc24ndCBoYXZlIGEgbG9hZGluZyBjb21wb25lbnQsIHdlIGRvbid0IG5lZWQgdG8gZG8gYW55dGhpbmcuXG4gICAgaWYgKCFoYXNMb2FkaW5nQ29tcG9uZW50SW5TZWVkRGF0YShub3JtYWxpemVkRmxpZ2h0RGF0YS5zZWVkRGF0YSkpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgbGV0IHRyZWVQYXRjaCA9IG5vcm1hbGl6ZWRGbGlnaHREYXRhLnRyZWVcbiAgICAvLyBTZWdtZW50cyBhcmUga2V5ZWQgYnkgc2VhcmNoUGFyYW1zIChlLmcuIF9fUEFHRV9fP3tcImZvb1wiOlwiYmFyXCJ9KS4gV2UgbWlnaHQgcmV0dXJuIGEgbGVzcyBzcGVjaWZpYywgcGFyYW0tbGVzcyBlbnRyeSxcbiAgICAvLyBzbyB3ZSBlbnN1cmUgdGhhdCB0aGUgZmluYWwgdHJlZSBjb250YWlucyB0aGUgY29ycmVjdCBzZWFyY2hQYXJhbXMgKHJlZmxlY3RlZCBpbiB0aGUgVVJMKSBhcmUgcHJvdmlkZWQgaW4gdGhlIHVwZGF0ZWQgRmxpZ2h0Um91dGVyU3RhdGUgdHJlZS5cbiAgICAvLyBXZSBvbmx5IGRvIHRoaXMgb24gdGhlIGZpcnN0IHJlYWQsIGFzIG90aGVyd2lzZSB3ZSdkIGJlIG92ZXJ3cml0aW5nIHRoZSBzZWFyY2hQYXJhbXMgdGhhdCBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gc2V0XG4gICAgdHJlZVBhdGNoID0gYWRkU2VhcmNoUGFyYW1zVG9QYWdlU2VnbWVudHMoXG4gICAgICB0cmVlUGF0Y2gsXG4gICAgICBPYmplY3QuZnJvbUVudHJpZXModXJsLnNlYXJjaFBhcmFtcylcbiAgICApXG5cbiAgICBjb25zdCB7IHNlZWREYXRhLCBpc1Jvb3RSZW5kZXIsIHBhdGhUb1NlZ21lbnQgfSA9IG5vcm1hbGl6ZWRGbGlnaHREYXRhXG4gICAgLy8gVE9ETy1BUFA6IHJlbW92ZSAnJ1xuICAgIGNvbnN0IGZsaWdodFNlZ21lbnRQYXRoV2l0aExlYWRpbmdFbXB0eSA9IFsnJywgLi4ucGF0aFRvU2VnbWVudF1cblxuICAgIC8vIFNlZ21lbnRzIGFyZSBrZXllZCBieSBzZWFyY2hQYXJhbXMgKGUuZy4gX19QQUdFX18/e1wiZm9vXCI6XCJiYXJcIn0pLiBXZSBtaWdodCByZXR1cm4gYSBsZXNzIHNwZWNpZmljLCBwYXJhbS1sZXNzIGVudHJ5LFxuICAgIC8vIHNvIHdlIGVuc3VyZSB0aGF0IHRoZSBmaW5hbCB0cmVlIGNvbnRhaW5zIHRoZSBjb3JyZWN0IHNlYXJjaFBhcmFtcyAocmVmbGVjdGVkIGluIHRoZSBVUkwpIGFyZSBwcm92aWRlZCBpbiB0aGUgdXBkYXRlZCBGbGlnaHRSb3V0ZXJTdGF0ZSB0cmVlLlxuICAgIC8vIFdlIG9ubHkgZG8gdGhpcyBvbiB0aGUgZmlyc3QgcmVhZCwgYXMgb3RoZXJ3aXNlIHdlJ2QgYmUgb3ZlcndyaXRpbmcgdGhlIHNlYXJjaFBhcmFtcyB0aGF0IG1heSBoYXZlIGFscmVhZHkgYmVlbiBzZXRcbiAgICB0cmVlUGF0Y2ggPSBhZGRTZWFyY2hQYXJhbXNUb1BhZ2VTZWdtZW50cyhcbiAgICAgIHRyZWVQYXRjaCxcbiAgICAgIE9iamVjdC5mcm9tRW50cmllcyh1cmwuc2VhcmNoUGFyYW1zKVxuICAgIClcblxuICAgIGxldCBuZXdUcmVlID0gYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlKFxuICAgICAgZmxpZ2h0U2VnbWVudFBhdGhXaXRoTGVhZGluZ0VtcHR5LFxuICAgICAgY3VycmVudFRyZWUsXG4gICAgICB0cmVlUGF0Y2gsXG4gICAgICBocmVmXG4gICAgKVxuXG4gICAgY29uc3QgbmV3Q2FjaGUgPSBjcmVhdGVFbXB0eUNhY2hlTm9kZSgpXG5cbiAgICAvLyBUaGUgcHJlZmV0Y2ggY2FjaGUgZW50cnkgd2FzIGFsaWFzZWQgLS0gdGhpcyBzaWduYWxzIHRoYXQgd2Ugb25seSBmaWxsIGluIHRoZSBjYWNoZSB3aXRoIHRoZVxuICAgIC8vIGxvYWRpbmcgc3RhdGUgYW5kIG5vdCB0aGUgYWN0dWFsIHBhcmFsbGVsIHJvdXRlIHNlZWQgZGF0YS5cbiAgICBpZiAoaXNSb290UmVuZGVyICYmIHNlZWREYXRhKSB7XG4gICAgICAvLyBGaWxsIGluIHRoZSBjYWNoZSB3aXRoIHRoZSBuZXcgbG9hZGluZyAvIHJzYyBkYXRhXG4gICAgICBjb25zdCByc2MgPSBzZWVkRGF0YVsxXVxuICAgICAgY29uc3QgbG9hZGluZyA9IHNlZWREYXRhWzNdXG4gICAgICBuZXdDYWNoZS5sb2FkaW5nID0gbG9hZGluZ1xuICAgICAgbmV3Q2FjaGUucnNjID0gcnNjXG5cbiAgICAgIC8vIENvbnN0cnVjdCBhIG5ldyB0cmVlIGFuZCBhcHBseSB0aGUgYWxpYXNlZCBsb2FkaW5nIHN0YXRlIGZvciBlYWNoIHBhcmFsbGVsIHJvdXRlXG4gICAgICBmaWxsTmV3VHJlZVdpdGhPbmx5TG9hZGluZ1NlZ21lbnRzKFxuICAgICAgICBuYXZpZ2F0ZWRBdCxcbiAgICAgICAgbmV3Q2FjaGUsXG4gICAgICAgIGN1cnJlbnRDYWNoZSxcbiAgICAgICAgdHJlZVBhdGNoLFxuICAgICAgICBzZWVkRGF0YVxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDb3B5IHJzYyBmb3IgdGhlIHJvb3Qgbm9kZSBvZiB0aGUgY2FjaGUuXG4gICAgICBuZXdDYWNoZS5yc2MgPSBjdXJyZW50Q2FjaGUucnNjXG4gICAgICBuZXdDYWNoZS5wcmVmZXRjaFJzYyA9IGN1cnJlbnRDYWNoZS5wcmVmZXRjaFJzY1xuICAgICAgbmV3Q2FjaGUubG9hZGluZyA9IGN1cnJlbnRDYWNoZS5sb2FkaW5nXG4gICAgICBuZXdDYWNoZS5wYXJhbGxlbFJvdXRlcyA9IG5ldyBNYXAoY3VycmVudENhY2hlLnBhcmFsbGVsUm91dGVzKVxuXG4gICAgICAvLyBjb3B5IHRoZSBsb2FkaW5nIHN0YXRlIG9ubHkgaW50byB0aGUgbGVhZiBub2RlICh0aGUgcGFydCB0aGF0IGNoYW5nZWQpXG4gICAgICBmaWxsQ2FjaGVXaXRoTmV3U3ViVHJlZURhdGFCdXRPbmx5TG9hZGluZyhcbiAgICAgICAgbmF2aWdhdGVkQXQsXG4gICAgICAgIG5ld0NhY2hlLFxuICAgICAgICBjdXJyZW50Q2FjaGUsXG4gICAgICAgIG5vcm1hbGl6ZWRGbGlnaHREYXRhXG4gICAgICApXG4gICAgfVxuXG4gICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbiB1cGRhdGVkIHRyZWUsIHRoZXJlJ3Mgbm8gcmVhc29uIHRvIHVwZGF0ZSB0aGUgY2FjaGUsIGFzIHRoZSB0cmVlXG4gICAgLy8gZGljdGF0ZXMgd2hhdCBjYWNoZSBub2RlcyB0byByZW5kZXIuXG4gICAgaWYgKG5ld1RyZWUpIHtcbiAgICAgIGN1cnJlbnRUcmVlID0gbmV3VHJlZVxuICAgICAgY3VycmVudENhY2hlID0gbmV3Q2FjaGVcbiAgICAgIGFwcGxpZWQgPSB0cnVlXG4gICAgfVxuICB9XG5cbiAgaWYgKCFhcHBsaWVkKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBtdXRhYmxlLnBhdGNoZWRUcmVlID0gY3VycmVudFRyZWVcbiAgbXV0YWJsZS5jYWNoZSA9IGN1cnJlbnRDYWNoZVxuICBtdXRhYmxlLmNhbm9uaWNhbFVybCA9IGhyZWZcbiAgbXV0YWJsZS5oYXNoRnJhZ21lbnQgPSB1cmwuaGFzaFxuXG4gIHJldHVybiBoYW5kbGVNdXRhYmxlKHN0YXRlLCBtdXRhYmxlKVxufVxuXG5mdW5jdGlvbiBoYXNMb2FkaW5nQ29tcG9uZW50SW5TZWVkRGF0YShzZWVkRGF0YTogQ2FjaGVOb2RlU2VlZERhdGEgfCBudWxsKSB7XG4gIGlmICghc2VlZERhdGEpIHJldHVybiBmYWxzZVxuXG4gIGNvbnN0IHBhcmFsbGVsUm91dGVzID0gc2VlZERhdGFbMl1cbiAgY29uc3QgbG9hZGluZyA9IHNlZWREYXRhWzNdXG5cbiAgaWYgKGxvYWRpbmcpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgZm9yIChjb25zdCBrZXkgaW4gcGFyYWxsZWxSb3V0ZXMpIHtcbiAgICBpZiAoaGFzTG9hZGluZ0NvbXBvbmVudEluU2VlZERhdGEocGFyYWxsZWxSb3V0ZXNba2V5XSkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGZpbGxOZXdUcmVlV2l0aE9ubHlMb2FkaW5nU2VnbWVudHMoXG4gIG5hdmlnYXRlZEF0OiBudW1iZXIsXG4gIG5ld0NhY2hlOiBDYWNoZU5vZGUsXG4gIGV4aXN0aW5nQ2FjaGU6IENhY2hlTm9kZSxcbiAgcm91dGVyU3RhdGU6IEZsaWdodFJvdXRlclN0YXRlLFxuICBjYWNoZU5vZGVTZWVkRGF0YTogQ2FjaGVOb2RlU2VlZERhdGEgfCBudWxsXG4pIHtcbiAgY29uc3QgaXNMYXN0U2VnbWVudCA9IE9iamVjdC5rZXlzKHJvdXRlclN0YXRlWzFdKS5sZW5ndGggPT09IDBcbiAgaWYgKGlzTGFzdFNlZ21lbnQpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGZvciAoY29uc3Qga2V5IGluIHJvdXRlclN0YXRlWzFdKSB7XG4gICAgY29uc3QgcGFyYWxsZWxSb3V0ZVN0YXRlID0gcm91dGVyU3RhdGVbMV1ba2V5XVxuICAgIGNvbnN0IHNlZ21lbnRGb3JQYXJhbGxlbFJvdXRlID0gcGFyYWxsZWxSb3V0ZVN0YXRlWzBdXG4gICAgY29uc3QgY2FjaGVLZXkgPSBjcmVhdGVSb3V0ZXJDYWNoZUtleShzZWdtZW50Rm9yUGFyYWxsZWxSb3V0ZSlcblxuICAgIGNvbnN0IHBhcmFsbGVsU2VlZERhdGEgPVxuICAgICAgY2FjaGVOb2RlU2VlZERhdGEgIT09IG51bGwgJiYgY2FjaGVOb2RlU2VlZERhdGFbMl1ba2V5XSAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gY2FjaGVOb2RlU2VlZERhdGFbMl1ba2V5XVxuICAgICAgICA6IG51bGxcblxuICAgIGxldCBuZXdDYWNoZU5vZGU6IENhY2hlTm9kZVxuICAgIGlmIChwYXJhbGxlbFNlZWREYXRhICE9PSBudWxsKSB7XG4gICAgICAvLyBOZXcgZGF0YSB3YXMgc2VudCBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgICBjb25zdCByc2MgPSBwYXJhbGxlbFNlZWREYXRhWzFdXG4gICAgICBjb25zdCBsb2FkaW5nID0gcGFyYWxsZWxTZWVkRGF0YVszXVxuICAgICAgbmV3Q2FjaGVOb2RlID0ge1xuICAgICAgICBsYXp5RGF0YTogbnVsbCxcbiAgICAgICAgLy8gY29weSB0aGUgbGF5b3V0IGJ1dCBudWxsIHRoZSBwYWdlIHNlZ21lbnQgYXMgdGhhdCdzIG5vdCBtZWFudCB0byBiZSB1c2VkXG4gICAgICAgIHJzYzogc2VnbWVudEZvclBhcmFsbGVsUm91dGUuaW5jbHVkZXMoUEFHRV9TRUdNRU5UX0tFWSkgPyBudWxsIDogcnNjLFxuICAgICAgICBwcmVmZXRjaFJzYzogbnVsbCxcbiAgICAgICAgaGVhZDogbnVsbCxcbiAgICAgICAgcHJlZmV0Y2hIZWFkOiBudWxsLFxuICAgICAgICBwYXJhbGxlbFJvdXRlczogbmV3IE1hcCgpLFxuICAgICAgICBsb2FkaW5nLFxuICAgICAgICBuYXZpZ2F0ZWRBdCxcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm8gZGF0YSBhdmFpbGFibGUgZm9yIHRoaXMgbm9kZS4gVGhpcyB3aWxsIHRyaWdnZXIgYSBsYXp5IGZldGNoXG4gICAgICAvLyBkdXJpbmcgcmVuZGVyLlxuICAgICAgbmV3Q2FjaGVOb2RlID0ge1xuICAgICAgICBsYXp5RGF0YTogbnVsbCxcbiAgICAgICAgcnNjOiBudWxsLFxuICAgICAgICBwcmVmZXRjaFJzYzogbnVsbCxcbiAgICAgICAgaGVhZDogbnVsbCxcbiAgICAgICAgcHJlZmV0Y2hIZWFkOiBudWxsLFxuICAgICAgICBwYXJhbGxlbFJvdXRlczogbmV3IE1hcCgpLFxuICAgICAgICBsb2FkaW5nOiBudWxsLFxuICAgICAgICBuYXZpZ2F0ZWRBdDogLTEsXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZXhpc3RpbmdQYXJhbGxlbFJvdXRlcyA9IG5ld0NhY2hlLnBhcmFsbGVsUm91dGVzLmdldChrZXkpXG4gICAgaWYgKGV4aXN0aW5nUGFyYWxsZWxSb3V0ZXMpIHtcbiAgICAgIGV4aXN0aW5nUGFyYWxsZWxSb3V0ZXMuc2V0KGNhY2hlS2V5LCBuZXdDYWNoZU5vZGUpXG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0NhY2hlLnBhcmFsbGVsUm91dGVzLnNldChrZXksIG5ldyBNYXAoW1tjYWNoZUtleSwgbmV3Q2FjaGVOb2RlXV0pKVxuICAgIH1cblxuICAgIGZpbGxOZXdUcmVlV2l0aE9ubHlMb2FkaW5nU2VnbWVudHMoXG4gICAgICBuYXZpZ2F0ZWRBdCxcbiAgICAgIG5ld0NhY2hlTm9kZSxcbiAgICAgIGV4aXN0aW5nQ2FjaGUsXG4gICAgICBwYXJhbGxlbFJvdXRlU3RhdGUsXG4gICAgICBwYXJhbGxlbFNlZWREYXRhXG4gICAgKVxuICB9XG59XG5cbi8qKlxuICogQWRkIHNlYXJjaCBwYXJhbXMgdG8gdGhlIHBhZ2Ugc2VnbWVudHMgaW4gdGhlIGZsaWdodCByb3V0ZXIgc3RhdGVcbiAqIFBhZ2Ugc2VnbWVudHMgdGhhdCBhcmUgYXNzb2NpYXRlZCB3aXRoIHNlYXJjaCBwYXJhbXMgaGF2ZSBhIHBhZ2Ugc2VnbWVudCBrZXlcbiAqIGZvbGxvd2VkIGJ5IGEgcXVlcnkgc3RyaW5nLiBUaGlzIGZ1bmN0aW9uIHdpbGwgYWRkIHRob3NlIHBhcmFtcyB0byB0aGUgcGFnZSBzZWdtZW50LlxuICogVGhpcyBpcyB1c2VmdWwgaWYgd2UgcmV0dXJuIGFuIGFsaWFzZWQgcHJlZmV0Y2ggZW50cnkgKGllLCB3b24ndCBoYXZlIHNlYXJjaCBwYXJhbXMpXG4gKiBidXQgdGhlIGNhbm9uaWNhbCByb3V0ZXIgVVJMIGhhcyBzZWFyY2ggcGFyYW1zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkU2VhcmNoUGFyYW1zVG9QYWdlU2VnbWVudHMoXG4gIGZsaWdodFJvdXRlclN0YXRlOiBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgc2VhcmNoUGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBzdHJpbmdbXSB8IHVuZGVmaW5lZD5cbik6IEZsaWdodFJvdXRlclN0YXRlIHtcbiAgY29uc3QgW3NlZ21lbnQsIHBhcmFsbGVsUm91dGVzLCAuLi5yZXN0XSA9IGZsaWdodFJvdXRlclN0YXRlXG5cbiAgLy8gSWYgaXQncyBhIHBhZ2Ugc2VnbWVudCwgbW9kaWZ5IHRoZSBzZWdtZW50IGJ5IGFkZGluZyBzZWFyY2ggcGFyYW1zXG4gIGlmIChzZWdtZW50LmluY2x1ZGVzKFBBR0VfU0VHTUVOVF9LRVkpKSB7XG4gICAgY29uc3QgbmV3U2VnbWVudCA9IGFkZFNlYXJjaFBhcmFtc0lmUGFnZVNlZ21lbnQoc2VnbWVudCwgc2VhcmNoUGFyYW1zKVxuICAgIHJldHVybiBbbmV3U2VnbWVudCwgcGFyYWxsZWxSb3V0ZXMsIC4uLnJlc3RdXG4gIH1cblxuICAvLyBPdGhlcndpc2UsIHJlY3Vyc2UgdGhyb3VnaCB0aGUgcGFyYWxsZWwgcm91dGVzIGFuZCByZXR1cm4gYSBuZXcgdHJlZVxuICBjb25zdCB1cGRhdGVkUGFyYWxsZWxSb3V0ZXM6IHsgW2tleTogc3RyaW5nXTogRmxpZ2h0Um91dGVyU3RhdGUgfSA9IHt9XG5cbiAgZm9yIChjb25zdCBba2V5LCBwYXJhbGxlbFJvdXRlXSBvZiBPYmplY3QuZW50cmllcyhwYXJhbGxlbFJvdXRlcykpIHtcbiAgICB1cGRhdGVkUGFyYWxsZWxSb3V0ZXNba2V5XSA9IGFkZFNlYXJjaFBhcmFtc1RvUGFnZVNlZ21lbnRzKFxuICAgICAgcGFyYWxsZWxSb3V0ZSxcbiAgICAgIHNlYXJjaFBhcmFtc1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBbc2VnbWVudCwgdXBkYXRlZFBhcmFsbGVsUm91dGVzLCAuLi5yZXN0XVxufVxuIl0sIm5hbWVzIjpbImFkZFNlYXJjaFBhcmFtc1RvUGFnZVNlZ21lbnRzIiwiaGFuZGxlQWxpYXNlZFByZWZldGNoRW50cnkiLCJuYXZpZ2F0ZWRBdCIsInN0YXRlIiwiZmxpZ2h0RGF0YSIsInVybCIsIm11dGFibGUiLCJjdXJyZW50VHJlZSIsInRyZWUiLCJjdXJyZW50Q2FjaGUiLCJjYWNoZSIsImhyZWYiLCJjcmVhdGVIcmVmRnJvbVVybCIsImFwcGxpZWQiLCJub3JtYWxpemVkRmxpZ2h0RGF0YSIsImhhc0xvYWRpbmdDb21wb25lbnRJblNlZWREYXRhIiwic2VlZERhdGEiLCJ0cmVlUGF0Y2giLCJPYmplY3QiLCJmcm9tRW50cmllcyIsInNlYXJjaFBhcmFtcyIsImlzUm9vdFJlbmRlciIsInBhdGhUb1NlZ21lbnQiLCJmbGlnaHRTZWdtZW50UGF0aFdpdGhMZWFkaW5nRW1wdHkiLCJuZXdUcmVlIiwiYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlIiwibmV3Q2FjaGUiLCJjcmVhdGVFbXB0eUNhY2hlTm9kZSIsInJzYyIsImxvYWRpbmciLCJmaWxsTmV3VHJlZVdpdGhPbmx5TG9hZGluZ1NlZ21lbnRzIiwicHJlZmV0Y2hSc2MiLCJwYXJhbGxlbFJvdXRlcyIsIk1hcCIsImZpbGxDYWNoZVdpdGhOZXdTdWJUcmVlRGF0YUJ1dE9ubHlMb2FkaW5nIiwicGF0Y2hlZFRyZWUiLCJjYW5vbmljYWxVcmwiLCJoYXNoRnJhZ21lbnQiLCJoYXNoIiwiaGFuZGxlTXV0YWJsZSIsImtleSIsImV4aXN0aW5nQ2FjaGUiLCJyb3V0ZXJTdGF0ZSIsImNhY2hlTm9kZVNlZWREYXRhIiwiaXNMYXN0U2VnbWVudCIsImtleXMiLCJsZW5ndGgiLCJwYXJhbGxlbFJvdXRlU3RhdGUiLCJzZWdtZW50Rm9yUGFyYWxsZWxSb3V0ZSIsImNhY2hlS2V5IiwiY3JlYXRlUm91dGVyQ2FjaGVLZXkiLCJwYXJhbGxlbFNlZWREYXRhIiwidW5kZWZpbmVkIiwibmV3Q2FjaGVOb2RlIiwibGF6eURhdGEiLCJpbmNsdWRlcyIsIlBBR0VfU0VHTUVOVF9LRVkiLCJoZWFkIiwicHJlZmV0Y2hIZWFkIiwiZXhpc3RpbmdQYXJhbGxlbFJvdXRlcyIsImdldCIsInNldCIsImZsaWdodFJvdXRlclN0YXRlIiwic2VnbWVudCIsInJlc3QiLCJuZXdTZWdtZW50IiwiYWRkU2VhcmNoUGFyYW1zSWZQYWdlU2VnbWVudCIsInVwZGF0ZWRQYXJhbGxlbFJvdXRlcyIsInBhcmFsbGVsUm91dGUiLCJlbnRyaWVzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztJQW1PZ0JBLDZCQUE2QixFQUFBO2VBQTdCQTs7SUExTUFDLDBCQUEwQixFQUFBO2VBQTFCQTs7O3lCQWpCVDsyQkFFOEI7NkNBQ087bUNBQ1Y7c0NBQ0c7NkNBQ3FCOytCQUM1QjtBQVV2QixTQUFTQSwyQkFDZEMsV0FBbUIsRUFDbkJDLEtBQTJCLEVBQzNCQyxVQUEyQyxFQUMzQ0MsR0FBUSxFQUNSQyxPQUFnQjtJQUVoQixJQUFJQyxjQUFjSixNQUFNSyxJQUFJO0lBQzVCLElBQUlDLGVBQWVOLE1BQU1PLEtBQUs7SUFDOUIsTUFBTUMsT0FBT0MsQ0FBQUEsR0FBQUEsbUJBQUFB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TSxjQUFjLENBQUM2QixHQUFHLENBQUNyQixLQUFLLElBQUlQLElBQUk7Z0JBQUM7b0JBQUNnQjtvQkFBVUk7aUJBQWE7YUFBQztRQUNyRTtRQUVBdkIsbUNBQ0U1QixhQUNBbUQsY0FDQVosZUFDQU0sb0JBQ0FJO0lBRUo7QUFDRjtBQVNPLFNBQVNuRCw4QkFDZDhELGlCQUFvQyxFQUNwQzFDLFlBQTJEO0lBRTNELE1BQU0sQ0FBQzJDLFNBQVMvQixnQkFBZ0IsR0FBR2dDLEtBQUssR0FBR0Y7SUFFM0MscUVBQXFFO0lBQ3JFLElBQUlDLFFBQVFSLFFBQVEsQ0FBQ0MsU0FBQUEsZ0JBQWdCLEdBQUc7UUFDdEMsTUFBTVMsYUFBYUMsQ0FBQUEsR0FBQUEsU0FBQUEsNEJBQTRCLEVBQUNILFNBQVMzQztRQUN6RCxPQUFPO1lBQUM2QztZQUFZakM7ZUFBbUJnQztTQUFLO0lBQzlDO0lBRUEsdUVBQXVFO0lBQ3ZFLE1BQU1HLHdCQUE4RCxDQUFDO0lBRXJFLEtBQUssTUFBTSxDQUFDM0IsS0FBSzRCLGNBQWMsSUFBSWxELE9BQU9tRCxPQUFPLENBQUNyQyxnQkFBaUI7UUFDakVtQyxxQkFBcUIsQ0FBQzNCLElBQUksR0FBR3hDLDhCQUMzQm9FLGVBQ0FoRDtJQUVKO0lBRUEsT0FBTztRQUFDMkM7UUFBU0k7V0FBMEJIO0tBQUs7QUFDbEQiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTA5NDEsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvY2xpZW50L2NvbXBvbmVudHMvc2VnbWVudC1jYWNoZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEVudHJ5IHBvaW50IHRvIHRoZSBTZWdtZW50IENhY2hlIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIEFsbCBjb2RlIHJlbGF0ZWQgdG8gdGhlIFNlZ21lbnQgQ2FjaGUgbGl2ZXMgYHNlZ21lbnQtY2FjaGUtaW1wbGAgZGlyZWN0b3J5LlxuICogQ2FsbGVycyBhY2Nlc3MgaXQgdGhyb3VnaCB0aGlzIGluZGlyZWN0aW9uLlxuICpcbiAqIFRoaXMgaXMgdG8gZW5zdXJlIHRoZSBjb2RlIGlzIGRlYWQgY29kZSBlbGltaW5hdGVkIGZyb20gdGhlIGJ1bmRsZSBpZiB0aGVcbiAqIGZsYWcgaXMgZGlzYWJsZWQuXG4gKlxuICogVE9ETzogVGhpcyBpcyBzdXBlciB0ZWRpb3VzLiBTaW5jZSBleHBlcmltZW50YWwgZmxhZ3MgYXJlIGFuIGVzc2VudGlhbCBwYXJ0XG4gKiBvZiBvdXIgd29ya2Zsb3csIHdlIHNob3VsZCBlc3RhYmxpc2ggYSBiZXR0ZXIgcGF0dGVybiBmb3IgZGVhZCBjb2RlXG4gKiBlbGltaW5hdGlvbi4gSWRlYWxseSBpdCB3b3VsZCBiZSBkb25lIGF0IHRoZSBidW5kbGVyIGxldmVsLCBsaWtlIGhvdyBSZWFjdCdzXG4gKiBidWlsZCBwcm9jZXNzIHdvcmtzLiBJbiB0aGUgUmVhY3QgcmVwbywgeW91IGRvbid0IGV2ZW4gbmVlZCB0byBhZGQgYW55IGV4dHJhXG4gKiBjb25maWd1cmF0aW9uIHBlciBleHBlcmltZW50IOKAlCBpZiB0aGUgY29kZSBpcyBub3QgcmVhY2hhYmxlLCBpdCBnZXRzIHN0cmlwcGVkXG4gKiBmcm9tIHRoZSBidWlsZCBhdXRvbWF0aWNhbGx5IGJ5IFJvbGx1cC4gT3IsIHNob3J0ZXIgdGVybSwgd2UgY291bGQgc3R1YiBvdXRcbiAqIGV4cGVyaW1lbnRhbCBtb2R1bGVzIGF0IGJ1aWxkIHRpbWUgYnkgdXBkYXRpbmcgdGhlIGJ1aWxkIGNvbmZpZywgaS5lLiBhIG1vcmVcbiAqIGF1dG9tYXRlZCB2ZXJzaW9uIG9mIHdoYXQgSSdtIGRvaW5nIG1hbnVhbGx5IGluIHRoaXMgZmlsZS5cbiAqL1xuXG5leHBvcnQgdHlwZSB7IE5hdmlnYXRpb25SZXN1bHQgfSBmcm9tICcuL3NlZ21lbnQtY2FjaGUtaW1wbC9uYXZpZ2F0aW9uJ1xuZXhwb3J0IHR5cGUgeyBQcmVmZXRjaFRhc2sgfSBmcm9tICcuL3NlZ21lbnQtY2FjaGUtaW1wbC9zY2hlZHVsZXInXG5cbmNvbnN0IG5vdEVuYWJsZWQ6IGFueSA9ICgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICdTZWdtZW50IENhY2hlIGV4cGVyaW1lbnQgaXMgbm90IGVuYWJsZWQuIFRoaXMgaXMgYSBidWcgaW4gTmV4dC5qcy4nXG4gIClcbn1cblxuZXhwb3J0IGNvbnN0IHByZWZldGNoOiB0eXBlb2YgaW1wb3J0KCcuL3NlZ21lbnQtY2FjaGUtaW1wbC9wcmVmZXRjaCcpLnByZWZldGNoID1cbiAgcHJvY2Vzcy5lbnYuX19ORVhUX0NMSUVOVF9TRUdNRU5UX0NBQ0hFXG4gICAgPyBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIHJlcXVpcmUoJy4vc2VnbWVudC1jYWNoZS1pbXBsL3ByZWZldGNoJykgYXMgdHlwZW9mIGltcG9ydCgnLi9zZWdtZW50LWNhY2hlLWltcGwvcHJlZmV0Y2gnKVxuICAgICAgICApLnByZWZldGNoKC4uLmFyZ3MpXG4gICAgICB9XG4gICAgOiBub3RFbmFibGVkXG5cbmV4cG9ydCBjb25zdCBuYXZpZ2F0ZTogdHlwZW9mIGltcG9ydCgnLi9zZWdtZW50LWNhY2hlLWltcGwvbmF2aWdhdGlvbicpLm5hdmlnYXRlID1cbiAgcHJvY2Vzcy5lbnYuX19ORVhUX0NMSUVOVF9TRUdNRU5UX0NBQ0hFXG4gICAgPyBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIHJlcXVpcmUoJy4vc2VnbWVudC1jYWNoZS1pbXBsL25hdmlnYXRpb24nKSBhcyB0eXBlb2YgaW1wb3J0KCcuL3NlZ21lbnQtY2FjaGUtaW1wbC9uYXZpZ2F0aW9uJylcbiAgICAgICAgKS5uYXZpZ2F0ZSguLi5hcmdzKVxuICAgICAgfVxuICAgIDogbm90RW5hYmxlZFxuXG5leHBvcnQgY29uc3QgcmV2YWxpZGF0ZUVudGlyZUNhY2hlOiB0eXBlb2YgaW1wb3J0KCcuL3NlZ21lbnQtY2FjaGUtaW1wbC9jYWNoZScpLnJldmFsaWRhdGVFbnRpcmVDYWNoZSA9XG4gIHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfU0VHTUVOVF9DQUNIRVxuICAgID8gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICByZXF1aXJlKCcuL3NlZ21lbnQtY2FjaGUtaW1wbC9jYWNoZScpIGFzIHR5cGVvZiBpbXBvcnQoJy4vc2VnbWVudC1jYWNoZS1pbXBsL2NhY2hlJylcbiAgICAgICAgKS5yZXZhbGlkYXRlRW50aXJlQ2FjaGUoLi4uYXJncylcbiAgICAgIH1cbiAgICA6IG5vdEVuYWJsZWRcblxuZXhwb3J0IGNvbnN0IGdldEN1cnJlbnRDYWNoZVZlcnNpb246IHR5cGVvZiBpbXBvcnQoJy4vc2VnbWVudC1jYWNoZS1pbXBsL2NhY2hlJykuZ2V0Q3VycmVudENhY2hlVmVyc2lvbiA9XG4gIHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfU0VHTUVOVF9DQUNIRVxuICAgID8gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICByZXF1aXJlKCcuL3NlZ21lbnQtY2FjaGUtaW1wbC9jYWNoZScpIGFzIHR5cGVvZiBpbXBvcnQoJy4vc2VnbWVudC1jYWNoZS1pbXBsL2NhY2hlJylcbiAgICAgICAgKS5nZXRDdXJyZW50Q2FjaGVWZXJzaW9uKC4uLmFyZ3MpXG4gICAgICB9XG4gICAgOiBub3RFbmFibGVkXG5cbmV4cG9ydCBjb25zdCBzY2hlZHVsZVByZWZldGNoVGFzazogdHlwZW9mIGltcG9ydCgnLi9zZWdtZW50LWNhY2hlLWltcGwvc2NoZWR1bGVyJykuc2NoZWR1bGVQcmVmZXRjaFRhc2sgPVxuICBwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1NFR01FTlRfQ0FDSEVcbiAgICA/IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgcmVxdWlyZSgnLi9zZWdtZW50LWNhY2hlLWltcGwvc2NoZWR1bGVyJykgYXMgdHlwZW9mIGltcG9ydCgnLi9zZWdtZW50LWNhY2hlLWltcGwvc2NoZWR1bGVyJylcbiAgICAgICAgKS5zY2hlZHVsZVByZWZldGNoVGFzayguLi5hcmdzKVxuICAgICAgfVxuICAgIDogbm90RW5hYmxlZFxuXG5leHBvcnQgY29uc3QgY2FuY2VsUHJlZmV0Y2hUYXNrOiB0eXBlb2YgaW1wb3J0KCcuL3NlZ21lbnQtY2FjaGUtaW1wbC9zY2hlZHVsZXInKS5jYW5jZWxQcmVmZXRjaFRhc2sgPVxuICBwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1NFR01FTlRfQ0FDSEVcbiAgICA/IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgcmVxdWlyZSgnLi9zZWdtZW50LWNhY2hlLWltcGwvc2NoZWR1bGVyJykgYXMgdHlwZW9mIGltcG9ydCgnLi9zZWdtZW50LWNhY2hlLWltcGwvc2NoZWR1bGVyJylcbiAgICAgICAgKS5jYW5jZWxQcmVmZXRjaFRhc2soLi4uYXJncylcbiAgICAgIH1cbiAgICA6IG5vdEVuYWJsZWRcblxuZXhwb3J0IGNvbnN0IHJlc2NoZWR1bGVQcmVmZXRjaFRhc2s6IHR5cGVvZiBpbXBvcnQoJy4vc2VnbWVudC1jYWNoZS1pbXBsL3NjaGVkdWxlcicpLnJlc2NoZWR1bGVQcmVmZXRjaFRhc2sgPVxuICBwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1NFR01FTlRfQ0FDSEVcbiAgICA/IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgcmVxdWlyZSgnLi9zZWdtZW50LWNhY2hlLWltcGwvc2NoZWR1bGVyJykgYXMgdHlwZW9mIGltcG9ydCgnLi9zZWdtZW50LWNhY2hlLWltcGwvc2NoZWR1bGVyJylcbiAgICAgICAgKS5yZXNjaGVkdWxlUHJlZmV0Y2hUYXNrKC4uLmFyZ3MpXG4gICAgICB9XG4gICAgOiBub3RFbmFibGVkXG5cbmV4cG9ydCBjb25zdCBpc1ByZWZldGNoVGFza0RpcnR5OiB0eXBlb2YgaW1wb3J0KCcuL3NlZ21lbnQtY2FjaGUtaW1wbC9zY2hlZHVsZXInKS5pc1ByZWZldGNoVGFza0RpcnR5ID1cbiAgcHJvY2Vzcy5lbnYuX19ORVhUX0NMSUVOVF9TRUdNRU5UX0NBQ0hFXG4gICAgPyBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIHJlcXVpcmUoJy4vc2VnbWVudC1jYWNoZS1pbXBsL3NjaGVkdWxlcicpIGFzIHR5cGVvZiBpbXBvcnQoJy4vc2VnbWVudC1jYWNoZS1pbXBsL3NjaGVkdWxlcicpXG4gICAgICAgICkuaXNQcmVmZXRjaFRhc2tEaXJ0eSguLi5hcmdzKVxuICAgICAgfVxuICAgIDogbm90RW5hYmxlZFxuXG5leHBvcnQgY29uc3QgY3JlYXRlQ2FjaGVLZXk6IHR5cGVvZiBpbXBvcnQoJy4vc2VnbWVudC1jYWNoZS1pbXBsL2NhY2hlLWtleScpLmNyZWF0ZUNhY2hlS2V5ID1cbiAgcHJvY2Vzcy5lbnYuX19ORVhUX0NMSUVOVF9TRUdNRU5UX0NBQ0hFXG4gICAgPyBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIHJlcXVpcmUoJy4vc2VnbWVudC1jYWNoZS1pbXBsL2NhY2hlLWtleScpIGFzIHR5cGVvZiBpbXBvcnQoJy4vc2VnbWVudC1jYWNoZS1pbXBsL2NhY2hlLWtleScpXG4gICAgICAgICkuY3JlYXRlQ2FjaGVLZXkoLi4uYXJncylcbiAgICAgIH1cbiAgICA6IG5vdEVuYWJsZWRcblxuLyoqXG4gKiBCZWxvdyBhcmUgcHVibGljIGNvbnN0YW50cy4gVGhleSdyZSBzbWFsbCBlbm91Z2ggdGhhdCB3ZSBkb24ndCBuZWVkIHRvXG4gKiBEQ0UgdGhlbS5cbiAqL1xuXG5leHBvcnQgY29uc3QgZW51bSBOYXZpZ2F0aW9uUmVzdWx0VGFnIHtcbiAgTVBBLFxuICBTdWNjZXNzLFxuICBOb09wLFxuICBBc3luYyxcbn1cblxuLyoqXG4gKiBUaGUgcHJpb3JpdHkgb2YgdGhlIHByZWZldGNoIHRhc2suIEhpZ2hlciBudW1iZXJzIGFyZSBoaWdoZXIgcHJpb3JpdHkuXG4gKi9cbmV4cG9ydCBjb25zdCBlbnVtIFByZWZldGNoUHJpb3JpdHkge1xuICAvKipcbiAgICogQXNzaWduZWQgdG8gdGhlIG1vc3QgcmVjZW50bHkgaG92ZXJlZC90b3VjaGVkIGxpbmsuIFNwZWNpYWwgbmV0d29ya1xuICAgKiBiYW5kd2lkdGggaXMgcmVzZXJ2ZWQgZm9yIHRoaXMgdGFzayBvbmx5LiBUaGVyZSdzIG9ubHkgZXZlciBvbmUgSW50ZW50LVxuICAgKiBwcmlvcml0eSB0YXNrIGF0IGEgdGltZTsgd2hlbiBhIG5ldyBJbnRlbnQgdGFzayBpcyBzY2hlZHVsZWQsIHRoZSBwcmV2aW91c1xuICAgKiBvbmUgaXMgYnVtcGVkIGRvd24gdG8gRGVmYXVsdC5cbiAgICovXG4gIEludGVudCA9IDIsXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBwcmlvcml0eSBmb3IgcHJlZmV0Y2ggdGFza3MuXG4gICAqL1xuICBEZWZhdWx0ID0gMSxcbiAgLyoqXG4gICAqIEFzc2lnbmVkIHRvIHRhc2tzIHdoZW4gdGhleSBzcGF3biBub24tYmxvY2tpbmcgYmFja2dyb3VuZCB3b3JrLCBsaWtlXG4gICAqIHJldmFsaWRhdGluZyBhIHBhcnRpYWxseSBjYWNoZWQgZW50cnkgdG8gc2VlIGlmIG1vcmUgZGF0YSBpcyBhdmFpbGFibGUuXG4gICAqL1xuICBCYWNrZ3JvdW5kID0gMCxcbn1cbiJdLCJuYW1lcyI6WyJOYXZpZ2F0aW9uUmVzdWx0VGFnIiwiUHJlZmV0Y2hQcmlvcml0eSIsImNhbmNlbFByZWZldGNoVGFzayIsImNyZWF0ZUNhY2hlS2V5IiwiZ2V0Q3VycmVudENhY2hlVmVyc2lvbiIsImlzUHJlZmV0Y2hUYXNrRGlydHkiLCJuYXZpZ2F0ZSIsInByZWZldGNoIiwicmVzY2hlZHVsZVByZWZldGNoVGFzayIsInJldmFsaWRhdGVFbnRpcmVDYWNoZSIsInNjaGVkdWxlUHJlZmV0Y2hUYXNrIiwibm90RW5hYmxlZCIsIkVycm9yIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9DTElFTlRfU0VHTUVOVF9DQUNIRSIsImFyZ3MiLCJyZXF1aXJlIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FpQkM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBaUdpQkEsbUJBQW1CLEVBQUE7ZUFBbkJBOztJQVVBQyxnQkFBZ0IsRUFBQTtlQUFoQkE7O0lBbkRMQyxrQkFBa0IsRUFBQTtlQUFsQkE7O0lBMkJBQyxjQUFjLEVBQUE7ZUFBZEE7O0lBN0NBQyxzQkFBc0IsRUFBQTtlQUF0QkE7O0lBb0NBQyxtQkFBbUIsRUFBQTtlQUFuQkE7O0lBdERBQyxRQUFRLEVBQUE7ZUFBUkE7O0lBVEFDLFFBQVEsRUFBQTtlQUFSQTs7SUFzREFDLHNCQUFzQixFQUFBO2VBQXRCQTs7SUFwQ0FDLHFCQUFxQixFQUFBO2VBQXJCQTs7SUFrQkFDLG9CQUFvQixFQUFBO2VBQXBCQTs7O0FBMUNiLE1BQU1DLGFBQWtCO0lBQ3RCLE1BQU0sT0FBQSxjQUVMLENBRkssSUFBSUMsTUFDUix1RUFESSxxQkFBQTtlQUFBO29CQUFBO3NCQUFBO0lBRU47QUFDRjtBQUVPLE1BQU1MLFdBQ1hNLFFBQVFDLEdBQUcsQ0FBQ0MsMEJBQ1IsQ0FEbUMseUJBTW5DSjtBQUVDLE1BQU1MLFdBQ1hPLFFBQVFDLEdBQUcsQ0FBQ0MsMEJBQ1IsQ0FEbUMseUJBTW5DSjtBQUVDLE1BQU1GLHdCQUNYSSxRQUFRQyxHQUFHLENBQUNDLDBCQUNSLENBRG1DLHlCQU1uQ0o7QUFFQyxNQUFNUCx5QkFDWFMsUUFBUUMsR0FBRyxDQUFDQywwQkFDUixDQURtQyx5QkFNbkNKO0FBRUMsTUFBTUQsdUJBQ1hHLFFBQVFDLEdBQUcsQ0FBQ0MsMEJBQ1IsQ0FEbUMseUJBTW5DSjtBQUVDLE1BQU1ULHFCQUNYVyxRQUFRQyxHQUFHLENBQUNDLDBCQUNSLENBRG1DLHlCQU1uQ0o7QUFFQyxNQUFNSCx5QkFDWEssUUFBUUMsR0FBRyxDQUFDQywwQkFDUixDQURtQyx5QkFNbkNKO0FBRUMsTUFBTU4sc0JBQ1hRLFFBQVFDLEdBQUcsQ0FBQ0MsMEJBQ1IsQ0FEbUMseUJBTW5DSjtBQUVDLE1BQU1SLGlCQUNYVSxRQUFRQyxHQUFHLENBQUNDLDBCQUNSLENBRG1DLHlCQU1uQ0o7QUFPQyxJQUFXWCxzQkFBQUEsV0FBQUEsR0FBQUEsU0FBQUEsbUJBQUFBOzs7OztXQUFBQTs7QUFVWCxJQUFXQyxtQkFBQUEsV0FBQUEsR0FBQUEsU0FBQUEsZ0JBQUFBO0lBQ2hCOzs7OztHQUtDLEdBQUEsZ0JBQUEsQ0FBQSxnQkFBQSxDQUFBLFNBQUEsR0FBQSxFQUFBLEdBQUE7SUFFRDs7R0FFQyxHQUFBLGdCQUFBLENBQUEsZ0JBQUEsQ0FBQSxVQUFBLEdBQUEsRUFBQSxHQUFBO0lBRUQ7OztHQUdDLEdBQUEsZ0JBQUEsQ0FBQSxnQkFBQSxDQUFBLGFBQUEsR0FBQSxFQUFBLEdBQUE7V0FmZUEiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTEwNjcsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvbmF2aWdhdGUtcmVkdWNlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IENhY2hlTm9kZSB9IGZyb20gJy4uLy4uLy4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHR5cGUge1xuICBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgRmxpZ2h0U2VnbWVudFBhdGgsXG59IGZyb20gJy4uLy4uLy4uLy4uL3NlcnZlci9hcHAtcmVuZGVyL3R5cGVzJ1xuaW1wb3J0IHsgZmV0Y2hTZXJ2ZXJSZXNwb25zZSB9IGZyb20gJy4uL2ZldGNoLXNlcnZlci1yZXNwb25zZSdcbmltcG9ydCB7IGNyZWF0ZUhyZWZGcm9tVXJsIH0gZnJvbSAnLi4vY3JlYXRlLWhyZWYtZnJvbS11cmwnXG5pbXBvcnQgeyBpbnZhbGlkYXRlQ2FjaGVCZWxvd0ZsaWdodFNlZ21lbnRQYXRoIH0gZnJvbSAnLi4vaW52YWxpZGF0ZS1jYWNoZS1iZWxvdy1mbGlnaHQtc2VnbWVudHBhdGgnXG5pbXBvcnQgeyBhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUgfSBmcm9tICcuLi9hcHBseS1yb3V0ZXItc3RhdGUtcGF0Y2gtdG8tdHJlZSdcbmltcG9ydCB7IHNob3VsZEhhcmROYXZpZ2F0ZSB9IGZyb20gJy4uL3Nob3VsZC1oYXJkLW5hdmlnYXRlJ1xuaW1wb3J0IHsgaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0IH0gZnJvbSAnLi4vaXMtbmF2aWdhdGluZy10by1uZXctcm9vdC1sYXlvdXQnXG5pbXBvcnQge1xuICBQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMsXG4gIHR5cGUgTXV0YWJsZSxcbiAgdHlwZSBOYXZpZ2F0ZUFjdGlvbixcbiAgdHlwZSBSZWFkb25seVJlZHVjZXJTdGF0ZSxcbiAgdHlwZSBSZWR1Y2VyU3RhdGUsXG59IGZyb20gJy4uL3JvdXRlci1yZWR1Y2VyLXR5cGVzJ1xuaW1wb3J0IHsgaGFuZGxlTXV0YWJsZSB9IGZyb20gJy4uL2hhbmRsZS1tdXRhYmxlJ1xuaW1wb3J0IHsgYXBwbHlGbGlnaHREYXRhIH0gZnJvbSAnLi4vYXBwbHktZmxpZ2h0LWRhdGEnXG5pbXBvcnQgeyBwcmVmZXRjaFF1ZXVlIH0gZnJvbSAnLi9wcmVmZXRjaC1yZWR1Y2VyJ1xuaW1wb3J0IHsgY3JlYXRlRW1wdHlDYWNoZU5vZGUgfSBmcm9tICcuLi8uLi9hcHAtcm91dGVyJ1xuaW1wb3J0IHsgREVGQVVMVF9TRUdNRU5UX0tFWSB9IGZyb20gJy4uLy4uLy4uLy4uL3NoYXJlZC9saWIvc2VnbWVudCdcbmltcG9ydCB7IGxpc3RlbkZvckR5bmFtaWNSZXF1ZXN0LCBzdGFydFBQUk5hdmlnYXRpb24gfSBmcm9tICcuLi9wcHItbmF2aWdhdGlvbnMnXG5pbXBvcnQge1xuICBnZXRPckNyZWF0ZVByZWZldGNoQ2FjaGVFbnRyeSxcbiAgcHJ1bmVQcmVmZXRjaENhY2hlLFxufSBmcm9tICcuLi9wcmVmZXRjaC1jYWNoZS11dGlscydcbmltcG9ydCB7IGNsZWFyQ2FjaGVOb2RlRGF0YUZvclNlZ21lbnRQYXRoIH0gZnJvbSAnLi4vY2xlYXItY2FjaGUtbm9kZS1kYXRhLWZvci1zZWdtZW50LXBhdGgnXG5pbXBvcnQgeyBoYW5kbGVBbGlhc2VkUHJlZmV0Y2hFbnRyeSB9IGZyb20gJy4uL2FsaWFzZWQtcHJlZmV0Y2gtbmF2aWdhdGlvbnMnXG5pbXBvcnQge1xuICBuYXZpZ2F0ZSBhcyBuYXZpZ2F0ZVVzaW5nU2VnbWVudENhY2hlLFxuICBOYXZpZ2F0aW9uUmVzdWx0VGFnLFxuICB0eXBlIE5hdmlnYXRpb25SZXN1bHQsXG59IGZyb20gJy4uLy4uL3NlZ21lbnQtY2FjaGUnXG5cbmV4cG9ydCBmdW5jdGlvbiBoYW5kbGVFeHRlcm5hbFVybChcbiAgc3RhdGU6IFJlYWRvbmx5UmVkdWNlclN0YXRlLFxuICBtdXRhYmxlOiBNdXRhYmxlLFxuICB1cmw6IHN0cmluZyxcbiAgcGVuZGluZ1B1c2g6IGJvb2xlYW5cbikge1xuICBtdXRhYmxlLm1wYU5hdmlnYXRpb24gPSB0cnVlXG4gIG11dGFibGUuY2Fub25pY2FsVXJsID0gdXJsXG4gIG11dGFibGUucGVuZGluZ1B1c2ggPSBwZW5kaW5nUHVzaFxuICBtdXRhYmxlLnNjcm9sbGFibGVTZWdtZW50cyA9IHVuZGVmaW5lZFxuXG4gIHJldHVybiBoYW5kbGVNdXRhYmxlKHN0YXRlLCBtdXRhYmxlKVxufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVNlZ21lbnRzRnJvbVBhdGNoKFxuICBmbGlnaHRSb3V0ZXJQYXRjaDogRmxpZ2h0Um91dGVyU3RhdGVcbik6IEZsaWdodFNlZ21lbnRQYXRoW10ge1xuICBjb25zdCBzZWdtZW50czogRmxpZ2h0U2VnbWVudFBhdGhbXSA9IFtdXG4gIGNvbnN0IFtzZWdtZW50LCBwYXJhbGxlbFJvdXRlc10gPSBmbGlnaHRSb3V0ZXJQYXRjaFxuXG4gIGlmIChPYmplY3Qua2V5cyhwYXJhbGxlbFJvdXRlcykubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtbc2VnbWVudF1dXG4gIH1cblxuICBmb3IgKGNvbnN0IFtwYXJhbGxlbFJvdXRlS2V5LCBwYXJhbGxlbFJvdXRlXSBvZiBPYmplY3QuZW50cmllcyhcbiAgICBwYXJhbGxlbFJvdXRlc1xuICApKSB7XG4gICAgZm9yIChjb25zdCBjaGlsZFNlZ21lbnQgb2YgZ2VuZXJhdGVTZWdtZW50c0Zyb21QYXRjaChwYXJhbGxlbFJvdXRlKSkge1xuICAgICAgLy8gSWYgdGhlIHNlZ21lbnQgaXMgZW1wdHksIGl0IG1lYW5zIHdlIGFyZSBhdCB0aGUgcm9vdCBvZiB0aGUgdHJlZVxuICAgICAgaWYgKHNlZ21lbnQgPT09ICcnKSB7XG4gICAgICAgIHNlZ21lbnRzLnB1c2goW3BhcmFsbGVsUm91dGVLZXksIC4uLmNoaWxkU2VnbWVudF0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWdtZW50cy5wdXNoKFtzZWdtZW50LCBwYXJhbGxlbFJvdXRlS2V5LCAuLi5jaGlsZFNlZ21lbnRdKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzZWdtZW50c1xufVxuXG5mdW5jdGlvbiB0cmlnZ2VyTGF6eUZldGNoRm9yTGVhZlNlZ21lbnRzKFxuICBuZXdDYWNoZTogQ2FjaGVOb2RlLFxuICBjdXJyZW50Q2FjaGU6IENhY2hlTm9kZSxcbiAgZmxpZ2h0U2VnbWVudFBhdGg6IEZsaWdodFNlZ21lbnRQYXRoLFxuICB0cmVlUGF0Y2g6IEZsaWdodFJvdXRlclN0YXRlXG4pIHtcbiAgbGV0IGFwcGxpZWRQYXRjaCA9IGZhbHNlXG5cbiAgbmV3Q2FjaGUucnNjID0gY3VycmVudENhY2hlLnJzY1xuICBuZXdDYWNoZS5wcmVmZXRjaFJzYyA9IGN1cnJlbnRDYWNoZS5wcmVmZXRjaFJzY1xuICBuZXdDYWNoZS5sb2FkaW5nID0gY3VycmVudENhY2hlLmxvYWRpbmdcbiAgbmV3Q2FjaGUucGFyYWxsZWxSb3V0ZXMgPSBuZXcgTWFwKGN1cnJlbnRDYWNoZS5wYXJhbGxlbFJvdXRlcylcblxuICBjb25zdCBzZWdtZW50UGF0aHNUb0ZpbGwgPSBnZW5lcmF0ZVNlZ21lbnRzRnJvbVBhdGNoKHRyZWVQYXRjaCkubWFwKFxuICAgIChzZWdtZW50KSA9PiBbLi4uZmxpZ2h0U2VnbWVudFBhdGgsIC4uLnNlZ21lbnRdXG4gIClcblxuICBmb3IgKGNvbnN0IHNlZ21lbnRQYXRocyBvZiBzZWdtZW50UGF0aHNUb0ZpbGwpIHtcbiAgICBjbGVhckNhY2hlTm9kZURhdGFGb3JTZWdtZW50UGF0aChuZXdDYWNoZSwgY3VycmVudENhY2hlLCBzZWdtZW50UGF0aHMpXG5cbiAgICBhcHBsaWVkUGF0Y2ggPSB0cnVlXG4gIH1cblxuICByZXR1cm4gYXBwbGllZFBhdGNoXG59XG5cbmZ1bmN0aW9uIGhhbmRsZU5hdmlnYXRpb25SZXN1bHQoXG4gIHVybDogVVJMLFxuICBzdGF0ZTogUmVhZG9ubHlSZWR1Y2VyU3RhdGUsXG4gIG11dGFibGU6IE11dGFibGUsXG4gIHBlbmRpbmdQdXNoOiBib29sZWFuLFxuICByZXN1bHQ6IE5hdmlnYXRpb25SZXN1bHRcbik6IFJlZHVjZXJTdGF0ZSB7XG4gIHN3aXRjaCAocmVzdWx0LnRhZykge1xuICAgIGNhc2UgTmF2aWdhdGlvblJlc3VsdFRhZy5NUEE6IHtcbiAgICAgIC8vIFBlcmZvcm0gYW4gTVBBIG5hdmlnYXRpb24uXG4gICAgICBjb25zdCBuZXdVcmwgPSByZXN1bHQuZGF0YVxuICAgICAgcmV0dXJuIGhhbmRsZUV4dGVybmFsVXJsKHN0YXRlLCBtdXRhYmxlLCBuZXdVcmwsIHBlbmRpbmdQdXNoKVxuICAgIH1cbiAgICBjYXNlIE5hdmlnYXRpb25SZXN1bHRUYWcuTm9PcDoge1xuICAgICAgLy8gVGhlIHNlcnZlciByZXNwb25kZWQgd2l0aCBubyBjaGFuZ2UgdG8gdGhlIGN1cnJlbnQgcGFnZS4gSG93ZXZlciwgaWZcbiAgICAgIC8vIHRoZSBVUkwgY2hhbmdlZCwgd2Ugc3RpbGwgbmVlZCB0byB1cGRhdGUgdGhhdC5cbiAgICAgIGNvbnN0IG5ld0Nhbm9uaWNhbFVybCA9IHJlc3VsdC5kYXRhLmNhbm9uaWNhbFVybFxuICAgICAgbXV0YWJsZS5jYW5vbmljYWxVcmwgPSBuZXdDYW5vbmljYWxVcmxcblxuICAgICAgLy8gQ2hlY2sgaWYgdGhlIG9ubHkgdGhpbmcgdGhhdCBjaGFuZ2VkIHdhcyB0aGUgaGFzaCBmcmFnbWVudC5cbiAgICAgIGNvbnN0IG9sZFVybCA9IG5ldyBVUkwoc3RhdGUuY2Fub25pY2FsVXJsLCB1cmwpXG4gICAgICBjb25zdCBvbmx5SGFzaENoYW5nZSA9XG4gICAgICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gY29tcGFyZSB0aGUgb3JpZ2lucywgYmVjYXVzZSBjbGllbnQtZHJpdmVuXG4gICAgICAgIC8vIG5hdmlnYXRpb25zIGFyZSBhbHdheXMgc2FtZS1vcmlnaW4uXG4gICAgICAgIHVybC5wYXRobmFtZSA9PT0gb2xkVXJsLnBhdGhuYW1lICYmXG4gICAgICAgIHVybC5zZWFyY2ggPT09IG9sZFVybC5zZWFyY2ggJiZcbiAgICAgICAgdXJsLmhhc2ggIT09IG9sZFVybC5oYXNoXG4gICAgICBpZiAob25seUhhc2hDaGFuZ2UpIHtcbiAgICAgICAgLy8gVGhlIG9ubHkgdXBkYXRlZCBwYXJ0IG9mIHRoZSBVUkwgaXMgdGhlIGhhc2guXG4gICAgICAgIG11dGFibGUub25seUhhc2hDaGFuZ2UgPSB0cnVlXG4gICAgICAgIG11dGFibGUuc2hvdWxkU2Nyb2xsID0gcmVzdWx0LmRhdGEuc2hvdWxkU2Nyb2xsXG4gICAgICAgIG11dGFibGUuaGFzaEZyYWdtZW50ID0gdXJsLmhhc2hcbiAgICAgICAgLy8gU2V0dGluZyB0aGlzIHRvIGFuIGVtcHR5IGFycmF5IHRyaWdnZXJzIGEgc2Nyb2xsIGZvciBhbGwgbmV3IGFuZFxuICAgICAgICAvLyB1cGRhdGVkIHNlZ21lbnRzLiBTZWUgYFNjcm9sbEFuZEZvY3VzSGFuZGxlcmAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgbXV0YWJsZS5zY3JvbGxhYmxlU2VnbWVudHMgPSBbXVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGFuZGxlTXV0YWJsZShzdGF0ZSwgbXV0YWJsZSlcbiAgICB9XG4gICAgY2FzZSBOYXZpZ2F0aW9uUmVzdWx0VGFnLlN1Y2Nlc3M6IHtcbiAgICAgIC8vIFJlY2VpdmVkIGEgbmV3IHJlc3VsdC5cbiAgICAgIG11dGFibGUuY2FjaGUgPSByZXN1bHQuZGF0YS5jYWNoZU5vZGVcbiAgICAgIG11dGFibGUucGF0Y2hlZFRyZWUgPSByZXN1bHQuZGF0YS5mbGlnaHRSb3V0ZXJTdGF0ZVxuICAgICAgbXV0YWJsZS5jYW5vbmljYWxVcmwgPSByZXN1bHQuZGF0YS5jYW5vbmljYWxVcmxcbiAgICAgIG11dGFibGUuc2Nyb2xsYWJsZVNlZ21lbnRzID0gcmVzdWx0LmRhdGEuc2Nyb2xsYWJsZVNlZ21lbnRzXG4gICAgICBtdXRhYmxlLnNob3VsZFNjcm9sbCA9IHJlc3VsdC5kYXRhLnNob3VsZFNjcm9sbFxuICAgICAgbXV0YWJsZS5oYXNoRnJhZ21lbnQgPSByZXN1bHQuZGF0YS5oYXNoXG4gICAgICByZXR1cm4gaGFuZGxlTXV0YWJsZShzdGF0ZSwgbXV0YWJsZSlcbiAgICB9XG4gICAgY2FzZSBOYXZpZ2F0aW9uUmVzdWx0VGFnLkFzeW5jOiB7XG4gICAgICByZXR1cm4gcmVzdWx0LmRhdGEudGhlbihcbiAgICAgICAgKGFzeW5jUmVzdWx0KSA9PlxuICAgICAgICAgIGhhbmRsZU5hdmlnYXRpb25SZXN1bHQodXJsLCBzdGF0ZSwgbXV0YWJsZSwgcGVuZGluZ1B1c2gsIGFzeW5jUmVzdWx0KSxcbiAgICAgICAgLy8gSWYgdGhlIG5hdmlnYXRpb24gZmFpbGVkLCByZXR1cm4gdGhlIGN1cnJlbnQgc3RhdGUuXG4gICAgICAgIC8vIFRPRE86IFRoaXMgbWF0Y2hlcyB0aGUgY3VycmVudCBiZWhhdmlvciBidXQgd2UgbmVlZCB0byBkbyBzb21ldGhpbmdcbiAgICAgICAgLy8gYmV0dGVyIGhlcmUgaWYgdGhlIG5ldHdvcmsgZmFpbHMuXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICByZXR1cm4gc3RhdGVcbiAgICAgICAgfVxuICAgICAgKVxuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICByZXN1bHQgc2F0aXNmaWVzIG5ldmVyXG4gICAgICByZXR1cm4gc3RhdGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5hdmlnYXRlUmVkdWNlcihcbiAgc3RhdGU6IFJlYWRvbmx5UmVkdWNlclN0YXRlLFxuICBhY3Rpb246IE5hdmlnYXRlQWN0aW9uXG4pOiBSZWR1Y2VyU3RhdGUge1xuICBjb25zdCB7IHVybCwgaXNFeHRlcm5hbFVybCwgbmF2aWdhdGVUeXBlLCBzaG91bGRTY3JvbGwsIGFsbG93QWxpYXNpbmcgfSA9XG4gICAgYWN0aW9uXG4gIGNvbnN0IG11dGFibGU6IE11dGFibGUgPSB7fVxuICBjb25zdCB7IGhhc2ggfSA9IHVybFxuICBjb25zdCBocmVmID0gY3JlYXRlSHJlZkZyb21VcmwodXJsKVxuICBjb25zdCBwZW5kaW5nUHVzaCA9IG5hdmlnYXRlVHlwZSA9PT0gJ3B1c2gnXG4gIC8vIHdlIHdhbnQgdG8gcHJ1bmUgdGhlIHByZWZldGNoIGNhY2hlIG9uIGV2ZXJ5IG5hdmlnYXRpb24gdG8gYXZvaWQgaXQgZ3Jvd2luZyB0b28gbGFyZ2VcbiAgcHJ1bmVQcmVmZXRjaENhY2hlKHN0YXRlLnByZWZldGNoQ2FjaGUpXG5cbiAgbXV0YWJsZS5wcmVzZXJ2ZUN1c3RvbUhpc3RvcnlTdGF0ZSA9IGZhbHNlXG4gIG11dGFibGUucGVuZGluZ1B1c2ggPSBwZW5kaW5nUHVzaFxuXG4gIGlmIChpc0V4dGVybmFsVXJsKSB7XG4gICAgcmV0dXJuIGhhbmRsZUV4dGVybmFsVXJsKHN0YXRlLCBtdXRhYmxlLCB1cmwudG9TdHJpbmcoKSwgcGVuZGluZ1B1c2gpXG4gIH1cblxuICAvLyBIYW5kbGVzIGNhc2Ugd2hlcmUgYDxtZXRhIGh0dHAtZXF1aXY9XCJyZWZyZXNoXCI+YCB0YWcgaXMgcHJlc2VudCxcbiAgLy8gd2hpY2ggd2lsbCB0cmlnZ2VyIGFuIE1QQSBuYXZpZ2F0aW9uLlxuICBpZiAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ19fbmV4dC1wYWdlLXJlZGlyZWN0JykpIHtcbiAgICByZXR1cm4gaGFuZGxlRXh0ZXJuYWxVcmwoc3RhdGUsIG11dGFibGUsIGhyZWYsIHBlbmRpbmdQdXNoKVxuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfU0VHTUVOVF9DQUNIRSkge1xuICAgIC8vIChWZXJ5IEVhcmx5IEV4cGVyaW1lbnRhbCBGZWF0dXJlKSBTZWdtZW50IENhY2hlXG4gICAgLy9cbiAgICAvLyBCeXBhc3MgdGhlIG5vcm1hbCBwcmVmZXRjaCBjYWNoZSBhbmQgdXNlIHRoZSBuZXcgcGVyLXNlZ21lbnQgY2FjaGVcbiAgICAvLyBpbXBsZW1lbnRhdGlvbiBpbnN0ZWFkLiBUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGlmIFBQUiBpcyBlbmFibGVkLCB0b28uXG4gICAgLy9cbiAgICAvLyBUZW1wb3JhcnkgZ2x1ZSBjb2RlIGJldHdlZW4gdGhlIHJvdXRlciByZWR1Y2VyIGFuZCB0aGUgbmV3IG5hdmlnYXRpb25cbiAgICAvLyBpbXBsZW1lbnRhdGlvbi4gRXZlbnR1YWxseSB3ZSdsbCByZXdyaXRlIHRoZSByb3V0ZXIgcmVkdWNlciB0byBhXG4gICAgLy8gc3RhdGUgbWFjaGluZS5cbiAgICBjb25zdCByZXN1bHQgPSBuYXZpZ2F0ZVVzaW5nU2VnbWVudENhY2hlKFxuICAgICAgdXJsLFxuICAgICAgc3RhdGUuY2FjaGUsXG4gICAgICBzdGF0ZS50cmVlLFxuICAgICAgc3RhdGUubmV4dFVybCxcbiAgICAgIHNob3VsZFNjcm9sbFxuICAgIClcbiAgICByZXR1cm4gaGFuZGxlTmF2aWdhdGlvblJlc3VsdCh1cmwsIHN0YXRlLCBtdXRhYmxlLCBwZW5kaW5nUHVzaCwgcmVzdWx0KVxuICB9XG5cbiAgY29uc3QgcHJlZmV0Y2hWYWx1ZXMgPSBnZXRPckNyZWF0ZVByZWZldGNoQ2FjaGVFbnRyeSh7XG4gICAgdXJsLFxuICAgIG5leHRVcmw6IHN0YXRlLm5leHRVcmwsXG4gICAgdHJlZTogc3RhdGUudHJlZSxcbiAgICBwcmVmZXRjaENhY2hlOiBzdGF0ZS5wcmVmZXRjaENhY2hlLFxuICAgIGFsbG93QWxpYXNpbmcsXG4gIH0pXG4gIGNvbnN0IHsgdHJlZUF0VGltZU9mUHJlZmV0Y2gsIGRhdGEgfSA9IHByZWZldGNoVmFsdWVzXG5cbiAgcHJlZmV0Y2hRdWV1ZS5idW1wKGRhdGEpXG5cbiAgcmV0dXJuIGRhdGEudGhlbihcbiAgICAoeyBmbGlnaHREYXRhLCBjYW5vbmljYWxVcmw6IGNhbm9uaWNhbFVybE92ZXJyaWRlLCBwb3N0cG9uZWQgfSkgPT4ge1xuICAgICAgY29uc3QgbmF2aWdhdGVkQXQgPSBEYXRlLm5vdygpXG5cbiAgICAgIGxldCBpc0ZpcnN0UmVhZCA9IGZhbHNlXG4gICAgICAvLyB3ZSBvbmx5IHdhbnQgdG8gbWFyayB0aGlzIG9uY2VcbiAgICAgIGlmICghcHJlZmV0Y2hWYWx1ZXMubGFzdFVzZWRUaW1lKSB7XG4gICAgICAgIC8vIGltcG9ydGFudDogd2Ugc2hvdWxkIG9ubHkgbWFyayB0aGUgY2FjaGUgbm9kZSBhcyBkaXJ0eSBhZnRlciB3ZSB1bnN1c3BlbmQgZnJvbSB0aGUgY2FsbCBhYm92ZVxuICAgICAgICBwcmVmZXRjaFZhbHVlcy5sYXN0VXNlZFRpbWUgPSBuYXZpZ2F0ZWRBdFxuICAgICAgICBpc0ZpcnN0UmVhZCA9IHRydWVcbiAgICAgIH1cblxuICAgICAgaWYgKHByZWZldGNoVmFsdWVzLmFsaWFzZWQpIHtcbiAgICAgICAgLy8gV2hlbiBhbGlhcyBpcyBlbmFibGVkLCBzZWFyY2ggcGFyYW0gbWF5IG5vdCBiZSBpbmNsdWRlZCBpbiB0aGUgY2Fub25pY2FsVXJsLlxuICAgICAgICAvLyBCdXQgd2Ugd2FudCB0byBzZXQgdXJsIHRvIGNhbm9uaWNhbFVybCBzbyB0aGF0IHdlIHVzZSByZWRpcmVjdGVkIHBhdGggZm9yIGZldGNoaW5nIGR5bmFtaWMgZGF0YS5cbiAgICAgICAgY29uc3QgdXJsV2l0aENhbm9uaWNhbFBhdGhuYW1lID0gbmV3IFVSTCh1cmwuaHJlZilcbiAgICAgICAgaWYgKGNhbm9uaWNhbFVybE92ZXJyaWRlKSB7XG4gICAgICAgICAgdXJsV2l0aENhbm9uaWNhbFBhdGhuYW1lLnBhdGhuYW1lID0gY2Fub25pY2FsVXJsT3ZlcnJpZGUucGF0aG5hbWVcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGhhbmRsZUFsaWFzZWRQcmVmZXRjaEVudHJ5KFxuICAgICAgICAgIG5hdmlnYXRlZEF0LFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIGZsaWdodERhdGEsXG4gICAgICAgICAgdXJsV2l0aENhbm9uaWNhbFBhdGhuYW1lLFxuICAgICAgICAgIG11dGFibGVcbiAgICAgICAgKVxuXG4gICAgICAgIC8vIFdlIGRpZG4ndCByZXR1cm4gbmV3IHJvdXRlciBzdGF0ZSBiZWNhdXNlIHdlIGRpZG4ndCBhcHBseSB0aGUgYWxpYXNlZCBlbnRyeSBmb3Igc29tZSByZWFzb24uXG4gICAgICAgIC8vIFdlJ2xsIHJlLWludm9rZSB0aGUgbmF2aWdhdGlvbiBoYW5kbGVyIGJ1dCBlbnN1cmUgdGhhdCB3ZSBkb24ndCBhdHRlbXB0IHRvIHVzZSB0aGUgYWxpYXNlZCBlbnRyeS4gVGhpc1xuICAgICAgICAvLyB3aWxsIGNyZWF0ZSBhbiBvbi1kZW1hbmQgcHJlZmV0Y2ggZW50cnkuXG4gICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIG5hdmlnYXRlUmVkdWNlcihzdGF0ZSwgeyAuLi5hY3Rpb24sIGFsbG93QWxpYXNpbmc6IGZhbHNlIH0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICB9XG5cbiAgICAgIC8vIEhhbmRsZSBjYXNlIHdoZW4gbmF2aWdhdGluZyB0byBwYWdlIGluIGBwYWdlc2AgZnJvbSBgYXBwYFxuICAgICAgaWYgKHR5cGVvZiBmbGlnaHREYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gaGFuZGxlRXh0ZXJuYWxVcmwoc3RhdGUsIG11dGFibGUsIGZsaWdodERhdGEsIHBlbmRpbmdQdXNoKVxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cGRhdGVkQ2Fub25pY2FsVXJsID0gY2Fub25pY2FsVXJsT3ZlcnJpZGVcbiAgICAgICAgPyBjcmVhdGVIcmVmRnJvbVVybChjYW5vbmljYWxVcmxPdmVycmlkZSlcbiAgICAgICAgOiBocmVmXG5cbiAgICAgIGNvbnN0IG9ubHlIYXNoQ2hhbmdlID1cbiAgICAgICAgISFoYXNoICYmXG4gICAgICAgIHN0YXRlLmNhbm9uaWNhbFVybC5zcGxpdCgnIycsIDEpWzBdID09PVxuICAgICAgICAgIHVwZGF0ZWRDYW5vbmljYWxVcmwuc3BsaXQoJyMnLCAxKVswXVxuXG4gICAgICAvLyBJZiBvbmx5IHRoZSBoYXNoIGhhcyBjaGFuZ2VkLCB0aGUgc2VydmVyIGhhc24ndCBzZW50IHVzIGFueSBuZXcgZGF0YS4gV2UgY2FuIGp1c3QgdXBkYXRlXG4gICAgICAvLyB0aGUgbXV0YWJsZSBwcm9wZXJ0aWVzIHJlc3BvbnNpYmxlIGZvciBVUkwgYW5kIHNjcm9sbCBoYW5kbGluZyBhbmQgcmV0dXJuIGVhcmx5LlxuICAgICAgaWYgKG9ubHlIYXNoQ2hhbmdlKSB7XG4gICAgICAgIG11dGFibGUub25seUhhc2hDaGFuZ2UgPSB0cnVlXG4gICAgICAgIG11dGFibGUuY2Fub25pY2FsVXJsID0gdXBkYXRlZENhbm9uaWNhbFVybFxuICAgICAgICBtdXRhYmxlLnNob3VsZFNjcm9sbCA9IHNob3VsZFNjcm9sbFxuICAgICAgICBtdXRhYmxlLmhhc2hGcmFnbWVudCA9IGhhc2hcbiAgICAgICAgbXV0YWJsZS5zY3JvbGxhYmxlU2VnbWVudHMgPSBbXVxuICAgICAgICByZXR1cm4gaGFuZGxlTXV0YWJsZShzdGF0ZSwgbXV0YWJsZSlcbiAgICAgIH1cblxuICAgICAgbGV0IGN1cnJlbnRUcmVlID0gc3RhdGUudHJlZVxuICAgICAgbGV0IGN1cnJlbnRDYWNoZSA9IHN0YXRlLmNhY2hlXG4gICAgICBsZXQgc2Nyb2xsYWJsZVNlZ21lbnRzOiBGbGlnaHRTZWdtZW50UGF0aFtdID0gW11cbiAgICAgIGZvciAoY29uc3Qgbm9ybWFsaXplZEZsaWdodERhdGEgb2YgZmxpZ2h0RGF0YSkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcGF0aFRvU2VnbWVudDogZmxpZ2h0U2VnbWVudFBhdGgsXG4gICAgICAgICAgc2VlZERhdGEsXG4gICAgICAgICAgaGVhZCxcbiAgICAgICAgICBpc0hlYWRQYXJ0aWFsLFxuICAgICAgICAgIGlzUm9vdFJlbmRlcixcbiAgICAgICAgfSA9IG5vcm1hbGl6ZWRGbGlnaHREYXRhXG4gICAgICAgIGxldCB0cmVlUGF0Y2ggPSBub3JtYWxpemVkRmxpZ2h0RGF0YS50cmVlXG5cbiAgICAgICAgLy8gVE9ETy1BUFA6IHJlbW92ZSAnJ1xuICAgICAgICBjb25zdCBmbGlnaHRTZWdtZW50UGF0aFdpdGhMZWFkaW5nRW1wdHkgPSBbJycsIC4uLmZsaWdodFNlZ21lbnRQYXRoXVxuXG4gICAgICAgIC8vIENyZWF0ZSBuZXcgdHJlZSBiYXNlZCBvbiB0aGUgZmxpZ2h0U2VnbWVudFBhdGggYW5kIHJvdXRlciBzdGF0ZSBwYXRjaFxuICAgICAgICBsZXQgbmV3VHJlZSA9IGFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZShcbiAgICAgICAgICAvLyBUT0RPLUFQUDogcmVtb3ZlICcnXG4gICAgICAgICAgZmxpZ2h0U2VnbWVudFBhdGhXaXRoTGVhZGluZ0VtcHR5LFxuICAgICAgICAgIGN1cnJlbnRUcmVlLFxuICAgICAgICAgIHRyZWVQYXRjaCxcbiAgICAgICAgICBocmVmXG4gICAgICAgIClcblxuICAgICAgICAvLyBJZiB0aGUgdHJlZSBwYXRjaCBjYW4ndCBiZSBhcHBsaWVkIHRvIHRoZSBjdXJyZW50IHRyZWUgdGhlbiB3ZSB1c2UgdGhlIHRyZWUgYXQgdGltZSBvZiBwcmVmZXRjaFxuICAgICAgICAvLyBUT0RPLUFQUDogVGhpcyBzaG91bGQgaW5zdGVhZCBmaWxsIGluIHRoZSBtaXNzaW5nIHBpZWNlcyBpbiBgY3VycmVudFRyZWVgIHdpdGggdGhlIGRhdGEgZnJvbSBgdHJlZUF0VGltZU9mUHJlZmV0Y2hgLCB0aGVuIGFwcGx5IHRoZSBwYXRjaC5cbiAgICAgICAgaWYgKG5ld1RyZWUgPT09IG51bGwpIHtcbiAgICAgICAgICBuZXdUcmVlID0gYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlKFxuICAgICAgICAgICAgLy8gVE9ETy1BUFA6IHJlbW92ZSAnJ1xuICAgICAgICAgICAgZmxpZ2h0U2VnbWVudFBhdGhXaXRoTGVhZGluZ0VtcHR5LFxuICAgICAgICAgICAgdHJlZUF0VGltZU9mUHJlZmV0Y2gsXG4gICAgICAgICAgICB0cmVlUGF0Y2gsXG4gICAgICAgICAgICBocmVmXG4gICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5ld1RyZWUgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGp1c3QgYSBwYXJhbm9pZCBjaGVjay4gV2hlbiBhIHJvdXRlIGlzIFBQUmVkLCB0aGUgc2VydmVyXG4gICAgICAgICAgICAvLyB3aWxsIHNlbmQgYmFjayBhIHN0YXRpYyByZXNwb25zZSB0aGF0J3MgcmVuZGVyZWQgZnJvbVxuICAgICAgICAgICAgLy8gdGhlIHJvb3QuIElmIGZvciBzb21lIHJlYXNvbiBpdCBkb2Vzbid0LCB3ZSBmYWxsIGJhY2sgdG8gdGhlXG4gICAgICAgICAgICAvLyBub24tUFBSIGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgICAgLy8gVE9ETzogV2Ugc2hvdWxkIGdldCByaWQgb2YgdGhlIGVsc2UgYnJhbmNoIGFuZCBkbyBhbGwgbmF2aWdhdGlvbnNcbiAgICAgICAgICAgIC8vIHZpYSBzdGFydFBQUk5hdmlnYXRpb24uIFRoZSBjdXJyZW50IHN0cnVjdHVyZSBpcyBqdXN0XG4gICAgICAgICAgICAvLyBhbiBpbmNyZW1lbnRhbCBzdGVwLlxuICAgICAgICAgICAgc2VlZERhdGEgJiZcbiAgICAgICAgICAgIGlzUm9vdFJlbmRlciAmJlxuICAgICAgICAgICAgcG9zdHBvbmVkXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zdCB0YXNrID0gc3RhcnRQUFJOYXZpZ2F0aW9uKFxuICAgICAgICAgICAgICBuYXZpZ2F0ZWRBdCxcbiAgICAgICAgICAgICAgY3VycmVudENhY2hlLFxuICAgICAgICAgICAgICBjdXJyZW50VHJlZSxcbiAgICAgICAgICAgICAgdHJlZVBhdGNoLFxuICAgICAgICAgICAgICBzZWVkRGF0YSxcbiAgICAgICAgICAgICAgaGVhZCxcbiAgICAgICAgICAgICAgaXNIZWFkUGFydGlhbCxcbiAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgIHNjcm9sbGFibGVTZWdtZW50c1xuICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICBpZiAodGFzayAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBpZiAodGFzay5yb3V0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIERldGVjdGVkIGEgY2hhbmdlIHRvIHRoZSByb290IGxheW91dC4gUGVyZm9ybSBhbiBmdWxsLVxuICAgICAgICAgICAgICAgIC8vIHBhZ2UgbmF2aWdhdGlvbi5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlRXh0ZXJuYWxVcmwoc3RhdGUsIG11dGFibGUsIGhyZWYsIHBlbmRpbmdQdXNoKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIFVzZSB0aGUgdHJlZSBjb21wdXRlZCBieSBzdGFydFBQUk5hdmlnYXRpb24gaW5zdGVhZFxuICAgICAgICAgICAgICAvLyBvZiB0aGUgb25lIGNvbXB1dGVkIGJ5IGFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZS5cbiAgICAgICAgICAgICAgLy8gVE9ETzogV2Ugc2hvdWxkIHJlbW92ZSBhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWVcbiAgICAgICAgICAgICAgLy8gZnJvbSB0aGUgUFBSIHBhdGggZW50aXJlbHkuXG4gICAgICAgICAgICAgIGNvbnN0IHBhdGNoZWRSb3V0ZXJTdGF0ZTogRmxpZ2h0Um91dGVyU3RhdGUgPSB0YXNrLnJvdXRlXG4gICAgICAgICAgICAgIG5ld1RyZWUgPSBwYXRjaGVkUm91dGVyU3RhdGVcblxuICAgICAgICAgICAgICBjb25zdCBuZXdDYWNoZSA9IHRhc2subm9kZVxuICAgICAgICAgICAgICBpZiAobmV3Q2FjaGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSd2ZSBjcmVhdGVkIGEgbmV3IENhY2hlIE5vZGUgdHJlZSB0aGF0IGNvbnRhaW5zIGEgcHJlZmV0Y2hlZFxuICAgICAgICAgICAgICAgIC8vIHZlcnNpb24gb2YgdGhlIG5leHQgcGFnZS4gVGhpcyBjYW4gYmUgcmVuZGVyZWQgaW5zdGFudGx5LlxuICAgICAgICAgICAgICAgIG11dGFibGUuY2FjaGUgPSBuZXdDYWNoZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IGR5bmFtaWNSZXF1ZXN0VHJlZSA9IHRhc2suZHluYW1pY1JlcXVlc3RUcmVlXG4gICAgICAgICAgICAgIGlmIChkeW5hbWljUmVxdWVzdFRyZWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgcHJlZmV0Y2hlZCB0cmVlIGhhcyBkeW5hbWljIGhvbGVzIGluIGl0LiBXZSBpbml0aWF0ZSBhXG4gICAgICAgICAgICAgICAgLy8gZHluYW1pYyByZXF1ZXN0IHRvIGZpbGwgdGhlbSBpbi5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIERvIG5vdCBibG9jayBvbiB0aGUgcmVzdWx0LiBXZSdsbCBpbW1lZGlhdGVseSByZW5kZXIgdGhlIENhY2hlXG4gICAgICAgICAgICAgICAgLy8gTm9kZSB0cmVlIGFuZCBzdXNwZW5kIG9uIHRoZSBkeW5hbWljIHBhcnRzLiBXaGVuIHRoZSByZXF1ZXN0XG4gICAgICAgICAgICAgICAgLy8gY29tZXMgaW4sIHdlJ2xsIGZpbGwgaW4gbWlzc2luZyBkYXRhIGFuZCBwaW5nIFJlYWN0IHRvXG4gICAgICAgICAgICAgICAgLy8gcmUtcmVuZGVyLiBVbmxpa2UgdGhlIGxhenkgZmV0Y2hpbmcgbW9kZWwgaW4gdGhlIG5vbi1QUFJcbiAgICAgICAgICAgICAgICAvLyBpbXBsZW1lbnRhdGlvbiwgdGhpcyBpcyBtb2RlbGVkIGFzIGEgc2luZ2xlIFJlYWN0IHVwZGF0ZSArXG4gICAgICAgICAgICAgICAgLy8gc3RyZWFtaW5nLCByYXRoZXIgdGhhbiBtdWx0aXBsZSB0b3AtbGV2ZWwgdXBkYXRlcy4gKEhvd2V2ZXIsXG4gICAgICAgICAgICAgICAgLy8gZXZlbiBpbiB0aGUgbmV3IG1vZGVsLCB3ZSdsbCBzdGlsbCBuZWVkIHRvIHNvbWV0aW1lcyB1cGRhdGUgdGhlXG4gICAgICAgICAgICAgICAgLy8gcm9vdCBtdWx0aXBsZSB0aW1lcyBwZXIgbmF2aWdhdGlvbiwgbGlrZSBpZiB0aGUgc2VydmVyIHNlbmRzIHVzXG4gICAgICAgICAgICAgICAgLy8gYSBkaWZmZXJlbnQgcmVzcG9uc2UgdGhhbiB3ZSBleHBlY3RlZC4gRm9yIG5vdywgd2UgcmV2ZXJ0IGJhY2tcbiAgICAgICAgICAgICAgICAvLyB0byB0aGUgbGF6eSBmZXRjaGluZyBtZWNoYW5pc20gaW4gdGhhdCBjYXNlLilcbiAgICAgICAgICAgICAgICBjb25zdCBkeW5hbWljUmVxdWVzdCA9IGZldGNoU2VydmVyUmVzcG9uc2UoXG4gICAgICAgICAgICAgICAgICBuZXcgVVJMKHVwZGF0ZWRDYW5vbmljYWxVcmwsIHVybC5vcmlnaW4pLFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBmbGlnaHRSb3V0ZXJTdGF0ZTogZHluYW1pY1JlcXVlc3RUcmVlLFxuICAgICAgICAgICAgICAgICAgICBuZXh0VXJsOiBzdGF0ZS5uZXh0VXJsLFxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIClcblxuICAgICAgICAgICAgICAgIGxpc3RlbkZvckR5bmFtaWNSZXF1ZXN0KHRhc2ssIGR5bmFtaWNSZXF1ZXN0KVxuICAgICAgICAgICAgICAgIC8vIFdlIHN0b3JlIHRoZSBkeW5hbWljIHJlcXVlc3Qgb24gdGhlIGBsYXp5RGF0YWAgcHJvcGVydHkgb2YgdGhlIENhY2hlTm9kZVxuICAgICAgICAgICAgICAgIC8vIGJlY2F1c2Ugd2UncmUgbm90IGdvaW5nIHRvIGF3YWl0IHRoZSBkeW5hbWljIHJlcXVlc3QgaGVyZS4gU2luY2Ugd2UncmUgbm90IGJsb2NraW5nXG4gICAgICAgICAgICAgICAgLy8gb24gdGhlIGR5bmFtaWMgcmVxdWVzdCwgYGxheW91dC1yb3V0ZXJgIHdpbGxcbiAgICAgICAgICAgICAgICAvLyB0YXNrLm5vZGUubGF6eURhdGEgPSBkeW5hbWljUmVxdWVzdFxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBwcmVmZXRjaGVkIHRyZWUgZG9lcyBub3QgY29udGFpbiBkeW5hbWljIGhvbGVzIOKAlCBpdCdzXG4gICAgICAgICAgICAgICAgLy8gZnVsbHkgc3RhdGljLiBXZSBjYW4gc2tpcCB0aGUgZHluYW1pYyByZXF1ZXN0LlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBOb3RoaW5nIGNoYW5nZWQsIHNvIHJldXNlIHRoZSBvbGQgY2FjaGUuXG4gICAgICAgICAgICAgIC8vIFRPRE86IFdoYXQgaWYgdGhlIGhlYWQgY2hhbmdlZCBidXQgbm90IGFueSBvZiB0aGUgc2VnbWVudCBkYXRhP1xuICAgICAgICAgICAgICAvLyBJcyB0aGF0IHBvc3NpYmxlPyBJZiBzbywgd2Ugc2hvdWxkIGNsb25lIHRoZSB3aG9sZSB0cmVlIGFuZFxuICAgICAgICAgICAgICAvLyB1cGRhdGUgdGhlIGhlYWQuXG4gICAgICAgICAgICAgIG5ld1RyZWUgPSB0cmVlUGF0Y2hcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVGhlIHN0YXRpYyByZXNwb25zZSBkb2VzIG5vdCBpbmNsdWRlIGFueSBkeW5hbWljIGhvbGVzLCBzb1xuICAgICAgICAgICAgLy8gdGhlcmUncyBubyBuZWVkIHRvIGRvIGEgc2Vjb25kIHJlcXVlc3QuXG4gICAgICAgICAgICAvLyBUT0RPOiBBcyBhbiBpbmNyZW1lbnRhbCBzdGVwIHRoaXMganVzdCByZXZlcnRzIGJhY2sgdG8gdGhlXG4gICAgICAgICAgICAvLyBub24tUFBSIGltcGxlbWVudGF0aW9uLiBXZSBjYW4gc2ltcGxpZnkgdGhpcyBicmFuY2ggZnVydGhlcixcbiAgICAgICAgICAgIC8vIGdpdmVuIHRoYXQgUFBSIHByZWZldGNoZXMgYXJlIGFsd2F5cyBzdGF0aWMgYW5kIHJldHVybiB0aGUgd2hvbGVcbiAgICAgICAgICAgIC8vIHRyZWUuIE9yIGluIHRoZSBtZWFudGltZSB3ZSBjb3VsZCBmYWN0b3IgaXQgb3V0IGludG8gYVxuICAgICAgICAgICAgLy8gc2VwYXJhdGUgZnVuY3Rpb24uXG5cbiAgICAgICAgICAgIGlmIChpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQoY3VycmVudFRyZWUsIG5ld1RyZWUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGVFeHRlcm5hbFVybChzdGF0ZSwgbXV0YWJsZSwgaHJlZiwgcGVuZGluZ1B1c2gpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGNhY2hlOiBDYWNoZU5vZGUgPSBjcmVhdGVFbXB0eUNhY2hlTm9kZSgpXG4gICAgICAgICAgICBsZXQgYXBwbGllZCA9IGZhbHNlXG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgcHJlZmV0Y2hWYWx1ZXMuc3RhdHVzID09PSBQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMuc3RhbGUgJiZcbiAgICAgICAgICAgICAgIWlzRmlyc3RSZWFkXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgLy8gV2hlbiB3ZSBoYXZlIGEgc3RhbGUgcHJlZmV0Y2ggZW50cnksIHdlIG9ubHkgd2FudCB0byByZS11c2UgdGhlIGxvYWRpbmcgc3RhdGUgb2YgdGhlIHJvdXRlIHdlJ3JlIG5hdmlnYXRpbmcgdG8sIHRvIHN1cHBvcnQgaW5zdGFudCBsb2FkaW5nIG5hdmlnYXRpb25zXG4gICAgICAgICAgICAgIC8vIHRoaXMgd2lsbCB0cmlnZ2VyIGEgbGF6eSBmZXRjaCBmb3IgdGhlIGFjdHVhbCBwYWdlIGRhdGEgYnkgbnVsbGluZyB0aGUgYHJzY2AgYW5kIGBwcmVmZXRjaFJzY2AgdmFsdWVzIGZvciBwYWdlIGRhdGEsXG4gICAgICAgICAgICAgIC8vIHdoaWxlIGNvcHlpbmcgb3ZlciB0aGUgYGxvYWRpbmdgIGZvciB0aGUgc2VnbWVudCB0aGF0IGNvbnRhaW5zIHRoZSBwYWdlIGRhdGEuXG4gICAgICAgICAgICAgIC8vIFdlIG9ubHkgZG8gdGhpcyBvbiBzdWJzZXF1ZW50IHJlYWRzLCBhcyBvdGhlcndpc2UgdGhlcmUnZCBiZSBubyBsb2FkaW5nIGRhdGEgdG8gcmUtdXNlLlxuXG4gICAgICAgICAgICAgIC8vIFdlIHNraXAgdGhpcyBicmFuY2ggaWYgb25seSB0aGUgaGFzaCBmcmFnbWVudCBoYXMgY2hhbmdlZCwgYXMgd2UgZG9uJ3Qgd2FudCB0byB0cmlnZ2VyIGEgbGF6eSBmZXRjaCBpbiB0aGF0IGNhc2VcbiAgICAgICAgICAgICAgYXBwbGllZCA9IHRyaWdnZXJMYXp5RmV0Y2hGb3JMZWFmU2VnbWVudHMoXG4gICAgICAgICAgICAgICAgY2FjaGUsXG4gICAgICAgICAgICAgICAgY3VycmVudENhY2hlLFxuICAgICAgICAgICAgICAgIGZsaWdodFNlZ21lbnRQYXRoLFxuICAgICAgICAgICAgICAgIHRyZWVQYXRjaFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIC8vIHNpbmNlIHdlIHJlLXVzZWQgdGhlIHN0YWxlIGNhY2hlJ3MgbG9hZGluZyBzdGF0ZSAmIHJlZnJlc2hlZCB0aGUgZGF0YSxcbiAgICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSBgbGFzdFVzZWRUaW1lYCBzbyB0aGF0IGl0IGNhbiBjb250aW51ZSB0byBiZSByZS11c2VkIGZvciB0aGUgbmV4dCAzMHNcbiAgICAgICAgICAgICAgcHJlZmV0Y2hWYWx1ZXMubGFzdFVzZWRUaW1lID0gbmF2aWdhdGVkQXRcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFwcGxpZWQgPSBhcHBseUZsaWdodERhdGEoXG4gICAgICAgICAgICAgICAgbmF2aWdhdGVkQXQsXG4gICAgICAgICAgICAgICAgY3VycmVudENhY2hlLFxuICAgICAgICAgICAgICAgIGNhY2hlLFxuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRGbGlnaHREYXRhLFxuICAgICAgICAgICAgICAgIHByZWZldGNoVmFsdWVzXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgaGFyZE5hdmlnYXRlID0gc2hvdWxkSGFyZE5hdmlnYXRlKFxuICAgICAgICAgICAgICAvLyBUT0RPLUFQUDogcmVtb3ZlICcnXG4gICAgICAgICAgICAgIGZsaWdodFNlZ21lbnRQYXRoV2l0aExlYWRpbmdFbXB0eSxcbiAgICAgICAgICAgICAgY3VycmVudFRyZWVcbiAgICAgICAgICAgIClcblxuICAgICAgICAgICAgaWYgKGhhcmROYXZpZ2F0ZSkge1xuICAgICAgICAgICAgICAvLyBDb3B5IHJzYyBmb3IgdGhlIHJvb3Qgbm9kZSBvZiB0aGUgY2FjaGUuXG4gICAgICAgICAgICAgIGNhY2hlLnJzYyA9IGN1cnJlbnRDYWNoZS5yc2NcbiAgICAgICAgICAgICAgY2FjaGUucHJlZmV0Y2hSc2MgPSBjdXJyZW50Q2FjaGUucHJlZmV0Y2hSc2NcblxuICAgICAgICAgICAgICBpbnZhbGlkYXRlQ2FjaGVCZWxvd0ZsaWdodFNlZ21lbnRQYXRoKFxuICAgICAgICAgICAgICAgIGNhY2hlLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRDYWNoZSxcbiAgICAgICAgICAgICAgICBmbGlnaHRTZWdtZW50UGF0aFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIC8vIEVuc3VyZSB0aGUgZXhpc3RpbmcgY2FjaGUgdmFsdWUgaXMgdXNlZCB3aGVuIHRoZSBjYWNoZSB3YXMgbm90IGludmFsaWRhdGVkLlxuICAgICAgICAgICAgICBtdXRhYmxlLmNhY2hlID0gY2FjaGVcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXBwbGllZCkge1xuICAgICAgICAgICAgICBtdXRhYmxlLmNhY2hlID0gY2FjaGVcbiAgICAgICAgICAgICAgLy8gSWYgd2UgYXBwbGllZCB0aGUgY2FjaGUsIHdlIHVwZGF0ZSB0aGUgXCJjdXJyZW50IGNhY2hlXCIgdmFsdWUgc28gYW55IG90aGVyXG4gICAgICAgICAgICAgIC8vIHNlZ21lbnRzIGluIHRoZSBGbGlnaHREYXRhUGF0aCB3aWxsIGJlIGFibGUgdG8gcmVmZXJlbmNlIHRoZSB1cGRhdGVkIGNhY2hlLlxuICAgICAgICAgICAgICBjdXJyZW50Q2FjaGUgPSBjYWNoZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHN1YlNlZ21lbnQgb2YgZ2VuZXJhdGVTZWdtZW50c0Zyb21QYXRjaCh0cmVlUGF0Y2gpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHNjcm9sbGFibGVTZWdtZW50UGF0aCA9IFtcbiAgICAgICAgICAgICAgICAuLi5mbGlnaHRTZWdtZW50UGF0aCxcbiAgICAgICAgICAgICAgICAuLi5zdWJTZWdtZW50LFxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIC8vIEZpbHRlciBvdXQgdGhlIF9fREVGQVVMVF9fIHBhdGhzIGFzIHRoZXkgc2hvdWxkbid0IGJlIHNjcm9sbGVkIHRvIGluIHRoaXMgY2FzZS5cbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHNjcm9sbGFibGVTZWdtZW50UGF0aFtzY3JvbGxhYmxlU2VnbWVudFBhdGgubGVuZ3RoIC0gMV0gIT09XG4gICAgICAgICAgICAgICAgREVGQVVMVF9TRUdNRU5UX0tFWVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBzY3JvbGxhYmxlU2VnbWVudHMucHVzaChzY3JvbGxhYmxlU2VnbWVudFBhdGgpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjdXJyZW50VHJlZSA9IG5ld1RyZWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBtdXRhYmxlLnBhdGNoZWRUcmVlID0gY3VycmVudFRyZWVcbiAgICAgIG11dGFibGUuY2Fub25pY2FsVXJsID0gdXBkYXRlZENhbm9uaWNhbFVybFxuICAgICAgbXV0YWJsZS5zY3JvbGxhYmxlU2VnbWVudHMgPSBzY3JvbGxhYmxlU2VnbWVudHNcbiAgICAgIG11dGFibGUuaGFzaEZyYWdtZW50ID0gaGFzaFxuICAgICAgbXV0YWJsZS5zaG91bGRTY3JvbGwgPSBzaG91bGRTY3JvbGxcblxuICAgICAgcmV0dXJuIGhhbmRsZU11dGFibGUoc3RhdGUsIG11dGFibGUpXG4gICAgfSxcbiAgICAoKSA9PiBzdGF0ZVxuICApXG59XG4iXSwibmFtZXMiOlsiaGFuZGxlRXh0ZXJuYWxVcmwiLCJuYXZpZ2F0ZVJlZHVjZXIiLCJzdGF0ZSIsIm11dGFibGUiLCJ1cmwiLCJwZW5kaW5nUHVzaCIsIm1wYU5hdmlnYXRpb24iLCJjYW5vbmljYWxVcmwiLCJzY3JvbGxhYmxlU2VnbWVudHMiLCJ1bmRlZmluZWQiLCJoYW5kbGVNdXRhYmxlIiwiZ2VuZXJhdGVTZWdtZW50c0Zyb21QYXRjaCIsImZsaWdodFJvdXRlclBhdGNoIiwic2VnbWVudHMiLCJzZWdtZW50IiwicGFyYWxsZWxSb3V0ZXMiLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIiwicGFyYWxsZWxSb3V0ZUtleSIsInBhcmFsbGVsUm91dGUiLCJlbnRyaWVzIiwiY2hpbGRTZWdtZW50IiwicHVzaCIsInRyaWdnZXJMYXp5RmV0Y2hGb3JMZWFmU2VnbWVudHMiLCJuZXdDYWNoZSIsImN1cnJlbnRDYWNoZSIsImZsaWdodFNlZ21lbnRQYXRoIiwidHJlZVBhdGNoIiwiYXBwbGllZFBhdGNoIiwicnNjIiwicHJlZmV0Y2hSc2MiLCJsb2FkaW5nIiwiTWFwIiwic2VnbWVudFBhdGhzVG9GaWxsIiwibWFwIiwic2VnbWVudFBhdGhzIiwiY2xlYXJDYWNoZU5vZGVEYXRhRm9yU2VnbWVudFBhdGgiLCJoYW5kbGVOYXZpZ2F0aW9uUmVzdWx0IiwicmVzdWx0IiwidGFnIiwiTmF2aWdhdGlvblJlc3VsdFRhZyIsIk1QQSIsIm5ld1VybCIsImRhdGEiLCJOb09wIiwibmV3Q2Fub25pY2FsVXJsIiwib2xkVXJsIiwiVVJMIiwib25seUhhc2hDaGFuZ2UiLCJwYXRobmFtZSIsInNlYXJjaCIsImhhc2giLCJzaG91bGRTY3JvbGwiLCJoYXNoRnJhZ21lbnQiLCJTdWNjZXNzIiwiY2FjaGUiLCJjYWNoZU5vZGUiLCJwYXRjaGVkVHJlZSIsImZsaWdodFJvdXRlclN0YXRlIiwiQXN5bmMiLCJ0aGVuIiwiYXN5bmNSZXN1bHQiLCJhY3Rpb24iLCJpc0V4dGVybmFsVXJsIiwibmF2aWdhdGVUeXBlIiwiYWxsb3dBbGlhc2luZyIsImhyZWYiLCJjcmVhdGVIcmVmRnJvbVVybCIsInBydW5lUHJlZmV0Y2hDYWNoZSIsInByZWZldGNoQ2FjaGUiLCJwcmVzZXJ2ZUN1c3RvbUhpc3RvcnlTdGF0ZSIsInRvU3RyaW5nIiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfQ0xJRU5UX1NFR01FTlRfQ0FDSEUiLCJuYXZpZ2F0ZVVzaW5nU2VnbWVudENhY2hlIiwidHJlZSIsIm5leHRVcmwiLCJwcmVmZXRjaFZhbHVlcyIsImdldE9yQ3JlYXRlUHJlZmV0Y2hDYWNoZUVudHJ5IiwidHJlZUF0VGltZU9mUHJlZmV0Y2giLCJwcmVmZXRjaFF1ZXVlIiwiYnVtcCIsImZsaWdodERhdGEiLCJjYW5vbmljYWxVcmxPdmVycmlkZSIsInBvc3Rwb25lZCIsIm5hdmlnYXRlZEF0IiwiRGF0ZSIsIm5vdyIsImlzRmlyc3RSZWFkIiwibGFzdFVzZWRUaW1lIiwiYWxpYXNlZCIsInVybFdpdGhDYW5vbmljYWxQYXRobmFtZSIsImhhbmRsZUFsaWFzZWRQcmVmZXRjaEVudHJ5IiwidXBkYXRlZENhbm9uaWNhbFVybCIsInNwbGl0IiwiY3VycmVudFRyZWUiLCJub3JtYWxpemVkRmxpZ2h0RGF0YSIsInBhdGhUb1NlZ21lbnQiLCJzZWVkRGF0YSIsImhlYWQiLCJpc0hlYWRQYXJ0aWFsIiwiaXNSb290UmVuZGVyIiwiZmxpZ2h0U2VnbWVudFBhdGhXaXRoTGVhZGluZ0VtcHR5IiwibmV3VHJlZSIsImFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZSIsInRhc2siLCJzdGFydFBQUk5hdmlnYXRpb24iLCJyb3V0ZSIsInBhdGNoZWRSb3V0ZXJTdGF0ZSIsIm5vZGUiLCJkeW5hbWljUmVxdWVzdFRyZWUiLCJkeW5hbWljUmVxdWVzdCIsImZldGNoU2VydmVyUmVzcG9uc2UiLCJvcmlnaW4iLCJsaXN0ZW5Gb3JEeW5hbWljUmVxdWVzdCIsImlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dCIsImNyZWF0ZUVtcHR5Q2FjaGVOb2RlIiwiYXBwbGllZCIsInN0YXR1cyIsIlByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cyIsInN0YWxlIiwiYXBwbHlGbGlnaHREYXRhIiwiaGFyZE5hdmlnYXRlIiwic2hvdWxkSGFyZE5hdmlnYXRlIiwiaW52YWxpZGF0ZUNhY2hlQmVsb3dGbGlnaHRTZWdtZW50UGF0aCIsInN1YlNlZ21lbnQiLCJzY3JvbGxhYmxlU2VnbWVudFBhdGgiLCJERUZBVUxUX1NFR01FTlRfS0VZIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztJQW9DZ0JBLGlCQUFpQixFQUFBO2VBQWpCQTs7SUFzSUFDLGVBQWUsRUFBQTtlQUFmQTs7O3FDQXJLb0I7bUNBQ0Y7dURBQ29COzZDQUNWO29DQUNUOzZDQUNTO29DQU9yQzsrQkFDdUI7aUNBQ0U7aUNBQ0Y7MkJBQ087eUJBQ0Q7Z0NBQ3dCO29DQUlyRDtrREFDMEM7NENBQ047OEJBS3BDO0FBRUEsU0FBU0Qsa0JBQ2RFLEtBQTJCLEVBQzNCQyxPQUFnQixFQUNoQkMsR0FBVyxFQUNYQyxXQUFvQjtJQUVwQkYsUUFBUUcsYUFBYSxHQUFHO0lBQ3hCSCxRQUFRSSxZQUFZLEdBQUdIO0lBQ3ZCRCxRQUFRRSxXQUFXLEdBQUdBO0lBQ3RCRixRQUFRSyxrQkFBa0IsR0FBR0M7SUFFN0IsT0FBT0MsQ0FBQUEsR0FBQUEsZUFBQUEsYUFBYSxFQUFDUixPQUFPQztBQUM5QjtBQUVBLFNBQVNRLDBCQUNQQyxpQkFBb0M7SUFFcEMsTUFBTUMsV0FBZ0MsRUFBRTtJQUN4QyxNQUFNLENBQUNDLFNBQVNDLGVBQWUsR0FBR0g7SUFFbEMsSUFBSUksT0FBT0MsSUFBSSxDQUFDRixnQkFBZ0JHLE1BQU0sS0FBSyxHQUFHO1FBQzVDLE9BQU87WUFBQztnQkFBQ0o7YUFBUTtTQUFDO0lBQ3BCO0lBRUEsS0FBSyxNQUFNLENBQUNLLGtCQUFrQkMsY0FBYyxJQUFJSixPQUFPSyxPQUFPLENBQzVETixnQkFDQztRQUNELEtBQUssTUFBTU8sZ0JBQWdCWCwwQkFBMEJTLGVBQWdCO1lBQ25FLG1FQUFtRTtZQUNuRSxJQUFJTixZQUFZLElBQUk7Z0JBQ2xCRCxTQUFTVSxJQUFJLENBQUM7b0JBQUNKO3VCQUFxQkc7aUJBQWE7WUFDbkQsT0FBTztnQkFDTFQsU0FBU1UsSUFBSSxDQUFDO29CQUFDVDtvQkFBU0s7dUJBQXFCRztpQkFBYTtZQUM1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OiAxMTQ0MSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yZWR1Y2Vycy9zZXJ2ZXItcGF0Y2gtcmVkdWNlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVIcmVmRnJvbVVybCB9IGZyb20gJy4uL2NyZWF0ZS1ocmVmLWZyb20tdXJsJ1xuaW1wb3J0IHsgYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlIH0gZnJvbSAnLi4vYXBwbHktcm91dGVyLXN0YXRlLXBhdGNoLXRvLXRyZWUnXG5pbXBvcnQgeyBpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQgfSBmcm9tICcuLi9pcy1uYXZpZ2F0aW5nLXRvLW5ldy1yb290LWxheW91dCdcbmltcG9ydCB0eXBlIHtcbiAgU2VydmVyUGF0Y2hBY3Rpb24sXG4gIFJlZHVjZXJTdGF0ZSxcbiAgUmVhZG9ubHlSZWR1Y2VyU3RhdGUsXG4gIE11dGFibGUsXG59IGZyb20gJy4uL3JvdXRlci1yZWR1Y2VyLXR5cGVzJ1xuaW1wb3J0IHsgaGFuZGxlRXh0ZXJuYWxVcmwgfSBmcm9tICcuL25hdmlnYXRlLXJlZHVjZXInXG5pbXBvcnQgeyBhcHBseUZsaWdodERhdGEgfSBmcm9tICcuLi9hcHBseS1mbGlnaHQtZGF0YSdcbmltcG9ydCB7IGhhbmRsZU11dGFibGUgfSBmcm9tICcuLi9oYW5kbGUtbXV0YWJsZSdcbmltcG9ydCB0eXBlIHsgQ2FjaGVOb2RlIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgeyBjcmVhdGVFbXB0eUNhY2hlTm9kZSB9IGZyb20gJy4uLy4uL2FwcC1yb3V0ZXInXG5cbmV4cG9ydCBmdW5jdGlvbiBzZXJ2ZXJQYXRjaFJlZHVjZXIoXG4gIHN0YXRlOiBSZWFkb25seVJlZHVjZXJTdGF0ZSxcbiAgYWN0aW9uOiBTZXJ2ZXJQYXRjaEFjdGlvblxuKTogUmVkdWNlclN0YXRlIHtcbiAgY29uc3Qge1xuICAgIHNlcnZlclJlc3BvbnNlOiB7IGZsaWdodERhdGEsIGNhbm9uaWNhbFVybDogY2Fub25pY2FsVXJsT3ZlcnJpZGUgfSxcbiAgICBuYXZpZ2F0ZWRBdCxcbiAgfSA9IGFjdGlvblxuXG4gIGNvbnN0IG11dGFibGU6IE11dGFibGUgPSB7fVxuXG4gIG11dGFibGUucHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGUgPSBmYWxzZVxuXG4gIC8vIEhhbmRsZSBjYXNlIHdoZW4gbmF2aWdhdGluZyB0byBwYWdlIGluIGBwYWdlc2AgZnJvbSBgYXBwYFxuICBpZiAodHlwZW9mIGZsaWdodERhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGhhbmRsZUV4dGVybmFsVXJsKFxuICAgICAgc3RhdGUsXG4gICAgICBtdXRhYmxlLFxuICAgICAgZmxpZ2h0RGF0YSxcbiAgICAgIHN0YXRlLnB1c2hSZWYucGVuZGluZ1B1c2hcbiAgICApXG4gIH1cblxuICBsZXQgY3VycmVudFRyZWUgPSBzdGF0ZS50cmVlXG4gIGxldCBjdXJyZW50Q2FjaGUgPSBzdGF0ZS5jYWNoZVxuXG4gIGZvciAoY29uc3Qgbm9ybWFsaXplZEZsaWdodERhdGEgb2YgZmxpZ2h0RGF0YSkge1xuICAgIGNvbnN0IHsgc2VnbWVudFBhdGg6IGZsaWdodFNlZ21lbnRQYXRoLCB0cmVlOiB0cmVlUGF0Y2ggfSA9XG4gICAgICBub3JtYWxpemVkRmxpZ2h0RGF0YVxuXG4gICAgY29uc3QgbmV3VHJlZSA9IGFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZShcbiAgICAgIC8vIFRPRE8tQVBQOiByZW1vdmUgJydcbiAgICAgIFsnJywgLi4uZmxpZ2h0U2VnbWVudFBhdGhdLFxuICAgICAgY3VycmVudFRyZWUsXG4gICAgICB0cmVlUGF0Y2gsXG4gICAgICBzdGF0ZS5jYW5vbmljYWxVcmxcbiAgICApXG5cbiAgICAvLyBgYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlYCByZXR1cm5zIGBudWxsYCB3aGVuIGl0IGRldGVybWluZWQgdGhhdCB0aGUgc2VydmVyIHJlc3BvbnNlIGlzIG5vdCBhcHBsaWNhYmxlIHRvIHRoZSBjdXJyZW50IHRyZWUuXG4gICAgLy8gSW4gb3RoZXIgd29yZHMsIHRoZSBzZXJ2ZXIgcmVzcG9uZGVkIHdpdGggYSB0cmVlIHRoYXQgZG9lc24ndCBtYXRjaCB3aGF0IHRoZSBjbGllbnQgaXMgY3VycmVudGx5IHJlbmRlcmluZy5cbiAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgdGhlIHNlcnZlciBwYXRjaCBhY3Rpb24gdG9vayBsb25nZXIgdG8gcmVzb2x2ZSB0aGFuIGEgc3Vic2VxdWVudCBuYXZpZ2F0aW9uIHdoaWNoIHdvdWxkIGhhdmUgY2hhbmdlZCB0aGUgdHJlZS5cbiAgICAvLyBQcmV2aW91c2x5IHRoaXMgY2FzZSB0cmlnZ2VyZWQgYW4gTVBBIG5hdmlnYXRpb24gYnV0IGl0IHNob3VsZCBiZSBzYWZlIHRvIHNpbXBseSBkaXNjYXJkIHRoZSBzZXJ2ZXIgcmVzcG9uc2UgcmF0aGVyIHRoYW4gZm9yY2luZ1xuICAgIC8vIHRoZSBlbnRpcmUgcGFnZSB0byByZWxvYWQuXG4gICAgaWYgKG5ld1RyZWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBzdGF0ZVxuICAgIH1cblxuICAgIGlmIChpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQoY3VycmVudFRyZWUsIG5ld1RyZWUpKSB7XG4gICAgICByZXR1cm4gaGFuZGxlRXh0ZXJuYWxVcmwoXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBtdXRhYmxlLFxuICAgICAgICBzdGF0ZS5jYW5vbmljYWxVcmwsXG4gICAgICAgIHN0YXRlLnB1c2hSZWYucGVuZGluZ1B1c2hcbiAgICAgIClcbiAgICB9XG5cbiAgICBjb25zdCBjYW5vbmljYWxVcmxPdmVycmlkZUhyZWYgPSBjYW5vbmljYWxVcmxPdmVycmlkZVxuICAgICAgPyBjcmVhdGVIcmVmRnJvbVVybChjYW5vbmljYWxVcmxPdmVycmlkZSlcbiAgICAgIDogdW5kZWZpbmVkXG5cbiAgICBpZiAoY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmKSB7XG4gICAgICBtdXRhYmxlLmNhbm9uaWNhbFVybCA9IGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZlxuICAgIH1cblxuICAgIGNvbnN0IGNhY2hlOiBDYWNoZU5vZGUgPSBjcmVhdGVFbXB0eUNhY2hlTm9kZSgpXG4gICAgYXBwbHlGbGlnaHREYXRhKG5hdmlnYXRlZEF0LCBjdXJyZW50Q2FjaGUsIGNhY2hlLCBub3JtYWxpemVkRmxpZ2h0RGF0YSlcblxuICAgIG11dGFibGUucGF0Y2hlZFRyZWUgPSBuZXdUcmVlXG4gICAgbXV0YWJsZS5jYWNoZSA9IGNhY2hlXG5cbiAgICBjdXJyZW50Q2FjaGUgPSBjYWNoZVxuICAgIGN1cnJlbnRUcmVlID0gbmV3VHJlZVxuICB9XG5cbiAgcmV0dXJuIGhhbmRsZU11dGFibGUoc3RhdGUsIG11dGFibGUpXG59XG4iXSwibmFtZXMiOlsic2VydmVyUGF0Y2hSZWR1Y2VyIiwic3RhdGUiLCJhY3Rpb24iLCJzZXJ2ZXJSZXNwb25zZSIsImZsaWdodERhdGEiLCJjYW5vbmljYWxVcmwiLCJjYW5vbmljYWxVcmxPdmVycmlkZSIsIm5hdmlnYXRlZEF0IiwibXV0YWJsZSIsInByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlIiwiaGFuZGxlRXh0ZXJuYWxVcmwiLCJwdXNoUmVmIiwicGVuZGluZ1B1c2giLCJjdXJyZW50VHJlZSIsInRyZWUiLCJjdXJyZW50Q2FjaGUiLCJjYWNoZSIsIm5vcm1hbGl6ZWRGbGlnaHREYXRhIiwic2VnbWVudFBhdGgiLCJmbGlnaHRTZWdtZW50UGF0aCIsInRyZWVQYXRjaCIsIm5ld1RyZWUiLCJhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUiLCJpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQiLCJjYW5vbmljYWxVcmxPdmVycmlkZUhyZWYiLCJjcmVhdGVIcmVmRnJvbVVybCIsInVuZGVmaW5lZCIsImNyZWF0ZUVtcHR5Q2FjaGVOb2RlIiwiYXBwbHlGbGlnaHREYXRhIiwicGF0Y2hlZFRyZWUiLCJoYW5kbGVNdXRhYmxlIl0sIm1hcHBpbmdzIjoiOzs7K0JBZWdCQSxzQkFBQUE7OztlQUFBQTs7O21DQWZrQjs2Q0FDVTs2Q0FDQTtpQ0FPVjtpQ0FDRjsrQkFDRjsyQkFFTztBQUU5QixTQUFTQSxtQkFDZEMsS0FBMkIsRUFDM0JDLE1BQXlCO0lBRXpCLE1BQU0sRUFDSkMsZ0JBQWdCLEVBQUVDLFVBQVUsRUFBRUMsY0FBY0Msb0JBQW9CLEVBQUUsRUFDbEVDLFdBQVcsRUFDWixHQUFHTDtJQUVKLE1BQU1NLFVBQW1CLENBQUM7SUFFMUJBLFFBQVFDLDBCQUEwQixHQUFHO0lBRXJDLDREQUE0RDtJQUM1RCxJQUFJLE9BQU9MLGVBQWUsVUFBVTtRQUNsQyxPQUFPTSxDQUFBQSxHQUFBQSxpQkFBQUEsaUJBQWlCLEVBQ3RCVCxPQUNBTyxTQUNBSixZQUNBSCxNQUFNVSxPQUFPLENBQUNDLFdBQVc7SUFFN0I7SUFFQSxJQUFJQyxjQUFjWixNQUFNYSxJQUFJO0lBQzVCLElBQUlDLGVBQWVkLE1BQU1lLEtBQUs7SUFFOUIsS0FBSyxNQUFNQyx3QkFBd0JiLFdBQVk7UUFDN0MsTUFBTSxFQUFFYyxhQUFhQyxpQkFBaUIsRUFBRUwsTUFBTU0sU0FBUyxFQUFFLEdBQ3ZESDtRQUVGLE1BQU1JLFVBQVVDLENBQUFBLEdBQUFBLDZCQUFBQSwyQkFBMkIsRUFDekMsQUFDQSxzQkFEc0I7WUFDckI7ZUFBT0g7U0FBa0IsRUFDMUJOLGFBQ0FPLFdBQ0FuQixNQUFNSSxZQUFZO1FBR3BCLGtJQUFrSTtRQUNsSSw4R0FBOEc7UUFDOUcsb0lBQW9JO1FBQ3BJLG1JQUFtSTtRQUNuSSw2QkFBNkI7UUFDN0IsSUFBSWdCLFlBQVksTUFBTTtZQUNwQixPQUFPcEI7UUFDVDtRQUVBLElBQUlzQixDQUFBQSxHQUFBQSw2QkFBQUEsMkJBQTJCLEVBQUNWLGFBQWFRLFVBQVU7WUFDckQsT0FBT1gsQ0FBQUEsR0FBQUEsaUJBQUFBLGlCQUFpQixFQUN0QlQsT0FDQU8sU0FDQVAsTUFBTUksWUFBWSxFQUNsQkosTUFBTVUsT0FBTyxDQUFDQyxXQUFXO1FBRTdCO1FBRUEsTUFBTVksMkJBQTJCbEIsdUJBQzdCbUIsQ0FBQUEsR0FBQUEsbUJBQUFBLGlCQUFpQixFQUFDbkIsd0JBQ2xCb0I7UUFFSixJQUFJRiwwQkFBMEI7WUFDNUJoQixRQUFRSCxZQUFZLEdBQUdtQjtRQUN6QjtRQUVBLE1BQU1SLFFBQW1CVyxDQUFBQSxHQUFBQSxXQUFBQSxvQkFBb0I7UUFDN0NDLENBQUFBLEdBQUFBLGlCQUFBQSxlQUFlLEVBQUNyQixhQUFhUSxjQUFjQyxPQUFPQztRQUVsRFQsUUFBUXFCLFdBQVcsR0FBR1I7UUFDdEJiLFFBQVFRLEtBQUssR0FBR0E7UUFFaEJELGVBQWVDO1FBQ2ZILGNBQWNRO0lBQ2hCO0lBRUEsT0FBT1MsQ0FBQUEsR0FBQUEsZUFBQUEsYUFBYSxFQUFDN0IsT0FBT087QUFDOUIiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTE1MTAsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvcmVzdG9yZS1yZWR1Y2VyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUhyZWZGcm9tVXJsIH0gZnJvbSAnLi4vY3JlYXRlLWhyZWYtZnJvbS11cmwnXG5pbXBvcnQgdHlwZSB7XG4gIFJlYWRvbmx5UmVkdWNlclN0YXRlLFxuICBSZWR1Y2VyU3RhdGUsXG4gIFJlc3RvcmVBY3Rpb24sXG59IGZyb20gJy4uL3JvdXRlci1yZWR1Y2VyLXR5cGVzJ1xuaW1wb3J0IHsgZXh0cmFjdFBhdGhGcm9tRmxpZ2h0Um91dGVyU3RhdGUgfSBmcm9tICcuLi9jb21wdXRlLWNoYW5nZWQtcGF0aCdcbmltcG9ydCB7IHVwZGF0ZUNhY2hlTm9kZU9uUG9wc3RhdGVSZXN0b3JhdGlvbiB9IGZyb20gJy4uL3Bwci1uYXZpZ2F0aW9ucydcblxuZXhwb3J0IGZ1bmN0aW9uIHJlc3RvcmVSZWR1Y2VyKFxuICBzdGF0ZTogUmVhZG9ubHlSZWR1Y2VyU3RhdGUsXG4gIGFjdGlvbjogUmVzdG9yZUFjdGlvblxuKTogUmVkdWNlclN0YXRlIHtcbiAgY29uc3QgeyB1cmwsIHRyZWUgfSA9IGFjdGlvblxuICBjb25zdCBocmVmID0gY3JlYXRlSHJlZkZyb21VcmwodXJsKVxuICAvLyBUaGlzIGFjdGlvbiBpcyB1c2VkIHRvIHJlc3RvcmUgdGhlIHJvdXRlciBzdGF0ZSBmcm9tIHRoZSBoaXN0b3J5IHN0YXRlLlxuICAvLyBIb3dldmVyLCBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIGhpc3Rvcnkgc3RhdGUgbm8gbG9uZ2VyIGNvbnRhaW5zIHRoZSBgRmxpZ2h0Um91dGVyU3RhdGVgLlxuICAvLyBXZSB3aWxsIGNvcHkgb3ZlciB0aGUgaW50ZXJuYWwgc3RhdGUgb24gcHVzaFN0YXRlL3JlcGxhY2VTdGF0ZSBldmVudHMsIGJ1dCBpZiBhIGhpc3RvcnkgZW50cnlcbiAgLy8gb2NjdXJyZWQgYmVmb3JlIGh5ZHJhdGlvbiwgb3IgaWYgdGhlIHVzZXIgbmF2aWdhdGVkIHRvIGEgaGFzaCB1c2luZyBhIHJlZ3VsYXIgYW5jaG9yIGxpbmssXG4gIC8vIHRoZSBoaXN0b3J5IHN0YXRlIHdpbGwgbm90IGNvbnRhaW4gdGhlIGBGbGlnaHRSb3V0ZXJTdGF0ZWAuXG4gIC8vIEluIHRoaXMgY2FzZSwgd2UnbGwgY29udGludWUgdG8gdXNlIHRoZSBleGlzdGluZyB0cmVlIHNvIHRoZSByb3V0ZXIgZG9lc24ndCBnZXQgaW50byBhbiBpbnZhbGlkIHN0YXRlLlxuICBjb25zdCB0cmVlVG9SZXN0b3JlID0gdHJlZSB8fCBzdGF0ZS50cmVlXG5cbiAgY29uc3Qgb2xkQ2FjaGUgPSBzdGF0ZS5jYWNoZVxuICBjb25zdCBuZXdDYWNoZSA9IHByb2Nlc3MuZW52Ll9fTkVYVF9QUFJcbiAgICA/IC8vIFdoZW4gUFBSIGlzIGVuYWJsZWQsIHdlIHVwZGF0ZSB0aGUgY2FjaGUgdG8gZHJvcCB0aGUgcHJlZmV0Y2hcbiAgICAgIC8vIGRhdGEgZm9yIGFueSBzZWdtZW50IHdob3NlIGR5bmFtaWMgZGF0YSB3YXMgYWxyZWFkeSByZWNlaXZlZC4gVGhpc1xuICAgICAgLy8gcHJldmVudHMgYW4gdW5uZWNlc3NhcnkgZmxhc2ggYmFjayB0byBQUFIgc3RhdGUgZHVyaW5nIGFcbiAgICAgIC8vIGJhY2svZm9yd2FyZCBuYXZpZ2F0aW9uLlxuICAgICAgdXBkYXRlQ2FjaGVOb2RlT25Qb3BzdGF0ZVJlc3RvcmF0aW9uKG9sZENhY2hlLCB0cmVlVG9SZXN0b3JlKVxuICAgIDogb2xkQ2FjaGVcblxuICByZXR1cm4ge1xuICAgIC8vIFNldCBjYW5vbmljYWwgdXJsXG4gICAgY2Fub25pY2FsVXJsOiBocmVmLFxuICAgIHB1c2hSZWY6IHtcbiAgICAgIHBlbmRpbmdQdXNoOiBmYWxzZSxcbiAgICAgIG1wYU5hdmlnYXRpb246IGZhbHNlLFxuICAgICAgLy8gRW5zdXJlcyB0aGF0IHRoZSBjdXN0b20gaGlzdG9yeSBzdGF0ZSB0aGF0IHdhcyBzZXQgaXMgcHJlc2VydmVkIHdoZW4gYXBwbHlpbmcgdGhpcyB1cGRhdGUuXG4gICAgICBwcmVzZXJ2ZUN1c3RvbUhpc3RvcnlTdGF0ZTogdHJ1ZSxcbiAgICB9LFxuICAgIGZvY3VzQW5kU2Nyb2xsUmVmOiBzdGF0ZS5mb2N1c0FuZFNjcm9sbFJlZixcbiAgICBjYWNoZTogbmV3Q2FjaGUsXG4gICAgcHJlZmV0Y2hDYWNoZTogc3RhdGUucHJlZmV0Y2hDYWNoZSxcbiAgICAvLyBSZXN0b3JlIHByb3ZpZGVkIHRyZWVcbiAgICB0cmVlOiB0cmVlVG9SZXN0b3JlLFxuICAgIG5leHRVcmw6IGV4dHJhY3RQYXRoRnJvbUZsaWdodFJvdXRlclN0YXRlKHRyZWVUb1Jlc3RvcmUpID8/IHVybC5wYXRobmFtZSxcbiAgfVxufVxuIl0sIm5hbWVzIjpbInJlc3RvcmVSZWR1Y2VyIiwic3RhdGUiLCJhY3Rpb24iLCJ1cmwiLCJ0cmVlIiwiaHJlZiIsImNyZWF0ZUhyZWZGcm9tVXJsIiwidHJlZVRvUmVzdG9yZSIsIm9sZENhY2hlIiwiY2FjaGUiLCJuZXdDYWNoZSIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfUFBSIiwidXBkYXRlQ2FjaGVOb2RlT25Qb3BzdGF0ZVJlc3RvcmF0aW9uIiwiZXh0cmFjdFBhdGhGcm9tRmxpZ2h0Um91dGVyU3RhdGUiLCJjYW5vbmljYWxVcmwiLCJwdXNoUmVmIiwicGVuZGluZ1B1c2giLCJtcGFOYXZpZ2F0aW9uIiwicHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGUiLCJmb2N1c0FuZFNjcm9sbFJlZiIsInByZWZldGNoQ2FjaGUiLCJuZXh0VXJsIiwicGF0aG5hbWUiXSwibWFwcGluZ3MiOiI7OzsrQkFTZ0JBLGtCQUFBQTs7O2VBQUFBOzs7bUNBVGtCO29DQU1lO2dDQUNJO0FBRTlDLFNBQVNBLGVBQ2RDLEtBQTJCLEVBQzNCQyxNQUFxQjtJQUVyQixNQUFNLEVBQUVDLEdBQUcsRUFBRUMsSUFBSSxFQUFFLEdBQUdGO0lBQ3RCLE1BQU1HLE9BQU9DLENBQUFBLEdBQUFBLG1CQUFBQSxpQkFBaUIsRUFBQ0g7SUFDL0IsMEVBQTBFO0lBQzFFLDRGQUE0RjtJQUM1RixnR0FBZ0c7SUFDaEcsNkZBQTZGO0lBQzdGLDhEQUE4RDtJQUM5RCx5R0FBeUc7SUFDekcsTUFBTUksZ0JBQWdCSCxRQUFRSCxNQUFNRyxJQUFJO0lBRXhDLE1BQU1JLFdBQVdQLE1BQU1RLEtBQUs7SUFDNUIsTUFBTUMsV0FBV0MsUUFBUUMsR0FBRyxDQUFDQyxVQUFVLEdBRW5DLGFBQ0Esd0RBRHFFLEdBQ1Y7SUFDM0QsMkJBQTJCO0lBQzNCQyxJQUFBQSxzQkFDQU4sOEJBRG9DLEVBQUNBLFVBQVVEO1FBaUJ4Q1E7SUFkWCxPQUFPO1FBQ0wsb0JBQW9CO1FBQ3BCQyxjQUFjWDtRQUNkWSxTQUFTO1lBQ1BDLGFBQWE7WUFDYkMsZUFBZTtZQUNmLDZGQUE2RjtZQUM3RkMsNEJBQTRCO1FBQzlCO1FBQ0FDLG1CQUFtQnBCLE1BQU1vQixpQkFBaUI7UUFDMUNaLE9BQU9DO1FBQ1BZLGVBQWVyQixNQUFNcUIsYUFBYTtRQUNsQyx3QkFBd0I7UUFDeEJsQixNQUFNRztRQUNOZ0IsU0FBU1IsQ0FBQUEsb0NBQUFBLENBQUFBLEdBQUFBLG9CQUFBQSxnQ0FBZ0MsRUFBQ1IsY0FBQUEsS0FBQUEsT0FBakNRLG9DQUFtRFosSUFBSXFCLFFBQVE7SUFDMUU7QUFDRiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxMTU2NywgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9oYW5kbGUtc2VnbWVudC1taXNtYXRjaC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IEZsaWdodFJvdXRlclN0YXRlIH0gZnJvbSAnLi4vLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvdHlwZXMnXG5pbXBvcnQgeyBoYW5kbGVFeHRlcm5hbFVybCB9IGZyb20gJy4vcmVkdWNlcnMvbmF2aWdhdGUtcmVkdWNlcidcbmltcG9ydCB0eXBlIHtcbiAgUmVhZG9ubHlSZWR1Y2VyU3RhdGUsXG4gIFJlZHVjZXJBY3Rpb25zLFxufSBmcm9tICcuL3JvdXRlci1yZWR1Y2VyLXR5cGVzJ1xuXG4vKipcbiAqIEhhbmRsZXMgdGhlIGNhc2Ugd2hlcmUgdGhlIGNsaWVudCByb3V0ZXIgYXR0ZW1wdGVkIHRvIHBhdGNoIHRoZSB0cmVlIGJ1dCwgZHVlIHRvIGEgbWlzbWF0Y2gsIHRoZSBwYXRjaCBmYWlsZWQuXG4gKiBUaGlzIHdpbGwgcGVyZm9ybSBhbiBNUEEgbmF2aWdhdGlvbiB0byByZXR1cm4gdGhlIHJvdXRlciB0byBhIHZhbGlkIHN0YXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFuZGxlU2VnbWVudE1pc21hdGNoKFxuICBzdGF0ZTogUmVhZG9ubHlSZWR1Y2VyU3RhdGUsXG4gIGFjdGlvbjogUmVkdWNlckFjdGlvbnMsXG4gIHRyZWVQYXRjaDogRmxpZ2h0Um91dGVyU3RhdGVcbikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICAnUGVyZm9ybWluZyBoYXJkIG5hdmlnYXRpb24gYmVjYXVzZSB5b3VyIGFwcGxpY2F0aW9uIGV4cGVyaWVuY2VkIGFuIHVucmVjb3ZlcmFibGUgZXJyb3IuIElmIHRoaXMga2VlcHMgb2NjdXJyaW5nLCBwbGVhc2UgZmlsZSBhIE5leHQuanMgaXNzdWUuXFxuXFxuJyArXG4gICAgICAgICdSZWFzb246IFNlZ21lbnQgbWlzbWF0Y2hcXG4nICtcbiAgICAgICAgYExhc3QgQWN0aW9uOiAke2FjdGlvbi50eXBlfVxcblxcbmAgK1xuICAgICAgICBgQ3VycmVudCBUcmVlOiAke0pTT04uc3RyaW5naWZ5KHN0YXRlLnRyZWUpfVxcblxcbmAgK1xuICAgICAgICBgVHJlZSBQYXRjaCBQYXlsb2FkOiAke0pTT04uc3RyaW5naWZ5KHRyZWVQYXRjaCl9YFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBoYW5kbGVFeHRlcm5hbFVybChzdGF0ZSwge30sIHN0YXRlLmNhbm9uaWNhbFVybCwgdHJ1ZSlcbn1cbiJdLCJuYW1lcyI6WyJoYW5kbGVTZWdtZW50TWlzbWF0Y2giLCJzdGF0ZSIsImFjdGlvbiIsInRyZWVQYXRjaCIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImNvbnNvbGUiLCJ3YXJuIiwidHlwZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJ0cmVlIiwiaGFuZGxlRXh0ZXJuYWxVcmwiLCJjYW5vbmljYWxVcmwiXSwibWFwcGluZ3MiOiI7OzsrQkFXZ0JBLHlCQUFBQTs7O2VBQUFBOzs7aUNBVmtCO0FBVTNCLFNBQVNBLHNCQUNkQyxLQUEyQixFQUMzQkMsTUFBc0IsRUFDdEJDLFNBQTRCO0lBRTVCLElBQUlDLFFBQVFDLEdBQUcsQ0FBQ0MsUUFBUSxLQUFLLFdBQWU7UUFDMUNDLFFBQVFDLElBQUksQ0FDVixzSkFDRSwrQkFDQSxDQUFDLGtCQUFlTixPQUFPTyxJQUFJLEdBQUMsTUFBSSxJQUNoQyxDQUFDLG1CQUFnQkMsS0FBS0MsU0FBUyxDQUFDVixNQUFNVyxJQUFJLElBQUUsTUFBSSxJQUNoRCxDQUFDLHlCQUFzQkYsS0FBS0MsU0FBUyxDQUFDUixVQUFXO0lBRXZEO0lBRUEsT0FBT1UsQ0FBQUEsR0FBQUEsaUJBQUFBLGlCQUFpQixFQUFDWixPQUFPLENBQUMsR0FBR0EsTUFBTWEsWUFBWSxFQUFFO0FBQzFEIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDExNTk2LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL2hhcy1pbnRlcmNlcHRpb24tcm91dGUtaW4tY3VycmVudC10cmVlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgRmxpZ2h0Um91dGVyU3RhdGUgfSBmcm9tICcuLi8uLi8uLi8uLi9zZXJ2ZXIvYXBwLXJlbmRlci90eXBlcydcbmltcG9ydCB7IGlzSW50ZXJjZXB0aW9uUm91dGVBcHBQYXRoIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaW50ZXJjZXB0aW9uLXJvdXRlcydcblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0ludGVyY2VwdGlvblJvdXRlSW5DdXJyZW50VHJlZShbXG4gIHNlZ21lbnQsXG4gIHBhcmFsbGVsUm91dGVzLFxuXTogRmxpZ2h0Um91dGVyU3RhdGUpOiBib29sZWFuIHtcbiAgLy8gSWYgd2UgaGF2ZSBhIGR5bmFtaWMgc2VnbWVudCwgaXQncyBtYXJrZWQgYXMgYW4gaW50ZXJjZXB0aW9uIHJvdXRlIGJ5IHRoZSBwcmVzZW5jZSBvZiB0aGUgYGlgIHN1ZmZpeC5cbiAgaWYgKEFycmF5LmlzQXJyYXkoc2VnbWVudCkgJiYgKHNlZ21lbnRbMl0gPT09ICdkaScgfHwgc2VnbWVudFsyXSA9PT0gJ2NpJykpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gSWYgc2VnbWVudCBpcyBub3QgYW4gYXJyYXksIGFwcGx5IHRoZSBleGlzdGluZyBzdHJpbmctYmFzZWQgY2hlY2tcbiAgaWYgKHR5cGVvZiBzZWdtZW50ID09PSAnc3RyaW5nJyAmJiBpc0ludGVyY2VwdGlvblJvdXRlQXBwUGF0aChzZWdtZW50KSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvLyBJdGVyYXRlIHRocm91Z2ggcGFyYWxsZWxSb3V0ZXMgaWYgdGhleSBleGlzdFxuICBpZiAocGFyYWxsZWxSb3V0ZXMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbGxlbFJvdXRlcykge1xuICAgICAgaWYgKGhhc0ludGVyY2VwdGlvblJvdXRlSW5DdXJyZW50VHJlZShwYXJhbGxlbFJvdXRlc1trZXldKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuIl0sIm5hbWVzIjpbImhhc0ludGVyY2VwdGlvblJvdXRlSW5DdXJyZW50VHJlZSIsInNlZ21lbnQiLCJwYXJhbGxlbFJvdXRlcyIsIkFycmF5IiwiaXNBcnJheSIsImlzSW50ZXJjZXB0aW9uUm91dGVBcHBQYXRoIiwia2V5Il0sIm1hcHBpbmdzIjoiOzs7K0JBR2dCQSxxQ0FBQUE7OztlQUFBQTs7O29DQUYyQjtBQUVwQyxTQUFTQSxrQ0FBa0MsS0FHOUI7SUFIOEIsSUFBQSxDQUNoREMsU0FDQUMsZUFDa0IsR0FIOEI7SUFJaEQsd0dBQXdHO0lBQ3hHLElBQUlDLE1BQU1DLE9BQU8sQ0FBQ0gsWUFBYUEsQ0FBQUEsT0FBTyxDQUFDLEVBQUUsS0FBSyxRQUFRQSxPQUFPLENBQUMsRUFBRSxLQUFLLElBQUcsR0FBSTtRQUMxRSxPQUFPO0lBQ1Q7SUFFQSxvRUFBb0U7SUFDcEUsSUFBSSxPQUFPQSxZQUFZLFlBQVlJLENBQUFBLEdBQUFBLG9CQUFBQSwwQkFBMEIsRUFBQ0osVUFBVTtRQUN0RSxPQUFPO0lBQ1Q7SUFFQSwrQ0FBK0M7SUFDL0MsSUFBSUMsZ0JBQWdCO1FBQ2xCLElBQUssTUFBTUksT0FBT0osZUFBZ0I7WUFDaEMsSUFBSUYsa0NBQWtDRSxjQUFjLENBQUNJLElBQUksR0FBRztnQkFDMUQsT0FBTztZQUNUO1FBQ0Y7SUFDRjtJQUVBLE9BQU87QUFDVCIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxMTYzOSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yZWR1Y2Vycy9yZWZyZXNoLXJlZHVjZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZmV0Y2hTZXJ2ZXJSZXNwb25zZSB9IGZyb20gJy4uL2ZldGNoLXNlcnZlci1yZXNwb25zZSdcbmltcG9ydCB7IGNyZWF0ZUhyZWZGcm9tVXJsIH0gZnJvbSAnLi4vY3JlYXRlLWhyZWYtZnJvbS11cmwnXG5pbXBvcnQgeyBhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUgfSBmcm9tICcuLi9hcHBseS1yb3V0ZXItc3RhdGUtcGF0Y2gtdG8tdHJlZSdcbmltcG9ydCB7IGlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dCB9IGZyb20gJy4uL2lzLW5hdmlnYXRpbmctdG8tbmV3LXJvb3QtbGF5b3V0J1xuaW1wb3J0IHR5cGUge1xuICBNdXRhYmxlLFxuICBSZWFkb25seVJlZHVjZXJTdGF0ZSxcbiAgUmVkdWNlclN0YXRlLFxuICBSZWZyZXNoQWN0aW9uLFxufSBmcm9tICcuLi9yb3V0ZXItcmVkdWNlci10eXBlcydcbmltcG9ydCB7IGhhbmRsZUV4dGVybmFsVXJsIH0gZnJvbSAnLi9uYXZpZ2F0ZS1yZWR1Y2VyJ1xuaW1wb3J0IHsgaGFuZGxlTXV0YWJsZSB9IGZyb20gJy4uL2hhbmRsZS1tdXRhYmxlJ1xuaW1wb3J0IHR5cGUgeyBDYWNoZU5vZGUgfSBmcm9tICcuLi8uLi8uLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB7IGZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkIH0gZnJvbSAnLi4vZmlsbC1sYXp5LWl0ZW1zLXRpbGwtbGVhZi13aXRoLWhlYWQnXG5pbXBvcnQgeyBjcmVhdGVFbXB0eUNhY2hlTm9kZSB9IGZyb20gJy4uLy4uL2FwcC1yb3V0ZXInXG5pbXBvcnQgeyBoYW5kbGVTZWdtZW50TWlzbWF0Y2ggfSBmcm9tICcuLi9oYW5kbGUtc2VnbWVudC1taXNtYXRjaCdcbmltcG9ydCB7IGhhc0ludGVyY2VwdGlvblJvdXRlSW5DdXJyZW50VHJlZSB9IGZyb20gJy4vaGFzLWludGVyY2VwdGlvbi1yb3V0ZS1pbi1jdXJyZW50LXRyZWUnXG5pbXBvcnQgeyByZWZyZXNoSW5hY3RpdmVQYXJhbGxlbFNlZ21lbnRzIH0gZnJvbSAnLi4vcmVmZXRjaC1pbmFjdGl2ZS1wYXJhbGxlbC1zZWdtZW50cydcbmltcG9ydCB7IHJldmFsaWRhdGVFbnRpcmVDYWNoZSB9IGZyb20gJy4uLy4uL3NlZ21lbnQtY2FjaGUnXG5cbmV4cG9ydCBmdW5jdGlvbiByZWZyZXNoUmVkdWNlcihcbiAgc3RhdGU6IFJlYWRvbmx5UmVkdWNlclN0YXRlLFxuICBhY3Rpb246IFJlZnJlc2hBY3Rpb25cbik6IFJlZHVjZXJTdGF0ZSB7XG4gIGNvbnN0IHsgb3JpZ2luIH0gPSBhY3Rpb25cbiAgY29uc3QgbXV0YWJsZTogTXV0YWJsZSA9IHt9XG4gIGNvbnN0IGhyZWYgPSBzdGF0ZS5jYW5vbmljYWxVcmxcblxuICBsZXQgY3VycmVudFRyZWUgPSBzdGF0ZS50cmVlXG5cbiAgbXV0YWJsZS5wcmVzZXJ2ZUN1c3RvbUhpc3RvcnlTdGF0ZSA9IGZhbHNlXG5cbiAgY29uc3QgY2FjaGU6IENhY2hlTm9kZSA9IGNyZWF0ZUVtcHR5Q2FjaGVOb2RlKClcblxuICAvLyBJZiB0aGUgY3VycmVudCB0cmVlIHdhcyBpbnRlcmNlcHRlZCwgdGhlIG5leHRVcmwgc2hvdWxkIGJlIGluY2x1ZGVkIGluIHRoZSByZXF1ZXN0LlxuICAvLyBUaGlzIGlzIHRvIGVuc3VyZSB0aGF0IHRoZSByZWZyZXNoIHJlcXVlc3QgZG9lc24ndCBnZXQgaW50ZXJjZXB0ZWQsIGFjY2lkZW50YWxseSB0cmlnZ2VyaW5nIHRoZSBpbnRlcmNlcHRpb24gcm91dGUuXG4gIGNvbnN0IGluY2x1ZGVOZXh0VXJsID0gaGFzSW50ZXJjZXB0aW9uUm91dGVJbkN1cnJlbnRUcmVlKHN0YXRlLnRyZWUpXG5cbiAgLy8gVE9ETy1BUFA6IHZlcmlmeSB0aGF0IGBocmVmYCBpcyBub3QgYW4gZXh0ZXJuYWwgdXJsLlxuICAvLyBGZXRjaCBkYXRhIGZyb20gdGhlIHJvb3Qgb2YgdGhlIHRyZWUuXG4gIGNhY2hlLmxhenlEYXRhID0gZmV0Y2hTZXJ2ZXJSZXNwb25zZShuZXcgVVJMKGhyZWYsIG9yaWdpbiksIHtcbiAgICBmbGlnaHRSb3V0ZXJTdGF0ZTogW1xuICAgICAgY3VycmVudFRyZWVbMF0sXG4gICAgICBjdXJyZW50VHJlZVsxXSxcbiAgICAgIGN1cnJlbnRUcmVlWzJdLFxuICAgICAgJ3JlZmV0Y2gnLFxuICAgIF0sXG4gICAgbmV4dFVybDogaW5jbHVkZU5leHRVcmwgPyBzdGF0ZS5uZXh0VXJsIDogbnVsbCxcbiAgfSlcblxuICBjb25zdCBuYXZpZ2F0ZWRBdCA9IERhdGUubm93KClcbiAgcmV0dXJuIGNhY2hlLmxhenlEYXRhLnRoZW4oXG4gICAgYXN5bmMgKHsgZmxpZ2h0RGF0YSwgY2Fub25pY2FsVXJsOiBjYW5vbmljYWxVcmxPdmVycmlkZSB9KSA9PiB7XG4gICAgICAvLyBIYW5kbGUgY2FzZSB3aGVuIG5hdmlnYXRpbmcgdG8gcGFnZSBpbiBgcGFnZXNgIGZyb20gYGFwcGBcbiAgICAgIGlmICh0eXBlb2YgZmxpZ2h0RGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZUV4dGVybmFsVXJsKFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIG11dGFibGUsXG4gICAgICAgICAgZmxpZ2h0RGF0YSxcbiAgICAgICAgICBzdGF0ZS5wdXNoUmVmLnBlbmRpbmdQdXNoXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIGNhY2hlLmxhenlEYXRhIGFzIGl0IGhhcyBiZWVuIHJlc29sdmVkIGF0IHRoaXMgcG9pbnQuXG4gICAgICBjYWNoZS5sYXp5RGF0YSA9IG51bGxcblxuICAgICAgZm9yIChjb25zdCBub3JtYWxpemVkRmxpZ2h0RGF0YSBvZiBmbGlnaHREYXRhKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICB0cmVlOiB0cmVlUGF0Y2gsXG4gICAgICAgICAgc2VlZERhdGE6IGNhY2hlTm9kZVNlZWREYXRhLFxuICAgICAgICAgIGhlYWQsXG4gICAgICAgICAgaXNSb290UmVuZGVyLFxuICAgICAgICB9ID0gbm9ybWFsaXplZEZsaWdodERhdGFcblxuICAgICAgICBpZiAoIWlzUm9vdFJlbmRlcikge1xuICAgICAgICAgIC8vIFRPRE8tQVBQOiBoYW5kbGUgdGhpcyBjYXNlIGJldHRlclxuICAgICAgICAgIGNvbnNvbGUubG9nKCdSRUZSRVNIIEZBSUxFRCcpXG4gICAgICAgICAgcmV0dXJuIHN0YXRlXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBuZXdUcmVlID0gYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlKFxuICAgICAgICAgIC8vIFRPRE8tQVBQOiByZW1vdmUgJydcbiAgICAgICAgICBbJyddLFxuICAgICAgICAgIGN1cnJlbnRUcmVlLFxuICAgICAgICAgIHRyZWVQYXRjaCxcbiAgICAgICAgICBzdGF0ZS5jYW5vbmljYWxVcmxcbiAgICAgICAgKVxuXG4gICAgICAgIGlmIChuZXdUcmVlID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZVNlZ21lbnRNaXNtYXRjaChzdGF0ZSwgYWN0aW9uLCB0cmVlUGF0Y2gpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0KGN1cnJlbnRUcmVlLCBuZXdUcmVlKSkge1xuICAgICAgICAgIHJldHVybiBoYW5kbGVFeHRlcm5hbFVybChcbiAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgbXV0YWJsZSxcbiAgICAgICAgICAgIGhyZWYsXG4gICAgICAgICAgICBzdGF0ZS5wdXNoUmVmLnBlbmRpbmdQdXNoXG4gICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmID0gY2Fub25pY2FsVXJsT3ZlcnJpZGVcbiAgICAgICAgICA/IGNyZWF0ZUhyZWZGcm9tVXJsKGNhbm9uaWNhbFVybE92ZXJyaWRlKVxuICAgICAgICAgIDogdW5kZWZpbmVkXG5cbiAgICAgICAgaWYgKGNhbm9uaWNhbFVybE92ZXJyaWRlKSB7XG4gICAgICAgICAgbXV0YWJsZS5jYW5vbmljYWxVcmwgPSBjYW5vbmljYWxVcmxPdmVycmlkZUhyZWZcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhhbmRsZXMgY2FzZSB3aGVyZSBwcmVmZXRjaCBvbmx5IHJldHVybnMgdGhlIHJvdXRlciB0cmVlIHBhdGNoIHdpdGhvdXQgcmVuZGVyZWQgY29tcG9uZW50cy5cbiAgICAgICAgaWYgKGNhY2hlTm9kZVNlZWREYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgcnNjID0gY2FjaGVOb2RlU2VlZERhdGFbMV1cbiAgICAgICAgICBjb25zdCBsb2FkaW5nID0gY2FjaGVOb2RlU2VlZERhdGFbM11cbiAgICAgICAgICBjYWNoZS5yc2MgPSByc2NcbiAgICAgICAgICBjYWNoZS5wcmVmZXRjaFJzYyA9IG51bGxcbiAgICAgICAgICBjYWNoZS5sb2FkaW5nID0gbG9hZGluZ1xuICAgICAgICAgIGZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkKFxuICAgICAgICAgICAgbmF2aWdhdGVkQXQsXG4gICAgICAgICAgICBjYWNoZSxcbiAgICAgICAgICAgIC8vIEV4aXN0aW5nIGNhY2hlIGlzIG5vdCBwYXNzZWQgaW4gYXMgYHJvdXRlci5yZWZyZXNoKClgIGhhcyB0byBpbnZhbGlkYXRlIHRoZSBlbnRpcmUgY2FjaGUuXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICB0cmVlUGF0Y2gsXG4gICAgICAgICAgICBjYWNoZU5vZGVTZWVkRGF0YSxcbiAgICAgICAgICAgIGhlYWQsXG4gICAgICAgICAgICB1bmRlZmluZWRcbiAgICAgICAgICApXG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfU0VHTUVOVF9DQUNIRSkge1xuICAgICAgICAgICAgcmV2YWxpZGF0ZUVudGlyZUNhY2hlKHN0YXRlLm5leHRVcmwsIG5ld1RyZWUpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG11dGFibGUucHJlZmV0Y2hDYWNoZSA9IG5ldyBNYXAoKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGF3YWl0IHJlZnJlc2hJbmFjdGl2ZVBhcmFsbGVsU2VnbWVudHMoe1xuICAgICAgICAgIG5hdmlnYXRlZEF0LFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIHVwZGF0ZWRUcmVlOiBuZXdUcmVlLFxuICAgICAgICAgIHVwZGF0ZWRDYWNoZTogY2FjaGUsXG4gICAgICAgICAgaW5jbHVkZU5leHRVcmwsXG4gICAgICAgICAgY2Fub25pY2FsVXJsOiBtdXRhYmxlLmNhbm9uaWNhbFVybCB8fCBzdGF0ZS5jYW5vbmljYWxVcmwsXG4gICAgICAgIH0pXG5cbiAgICAgICAgbXV0YWJsZS5jYWNoZSA9IGNhY2hlXG4gICAgICAgIG11dGFibGUucGF0Y2hlZFRyZWUgPSBuZXdUcmVlXG5cbiAgICAgICAgY3VycmVudFRyZWUgPSBuZXdUcmVlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYW5kbGVNdXRhYmxlKHN0YXRlLCBtdXRhYmxlKVxuICAgIH0sXG4gICAgKCkgPT4gc3RhdGVcbiAgKVxufVxuIl0sIm5hbWVzIjpbInJlZnJlc2hSZWR1Y2VyIiwic3RhdGUiLCJhY3Rpb24iLCJvcmlnaW4iLCJtdXRhYmxlIiwiaHJlZiIsImNhbm9uaWNhbFVybCIsImN1cnJlbnRUcmVlIiwidHJlZSIsInByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlIiwiY2FjaGUiLCJjcmVhdGVFbXB0eUNhY2hlTm9kZSIsImluY2x1ZGVOZXh0VXJsIiwiaGFzSW50ZXJjZXB0aW9uUm91dGVJbkN1cnJlbnRUcmVlIiwibGF6eURhdGEiLCJmZXRjaFNlcnZlclJlc3BvbnNlIiwiVVJMIiwiZmxpZ2h0Um91dGVyU3RhdGUiLCJuZXh0VXJsIiwibmF2aWdhdGVkQXQiLCJEYXRlIiwibm93IiwidGhlbiIsImZsaWdodERhdGEiLCJjYW5vbmljYWxVcmxPdmVycmlkZSIsImhhbmRsZUV4dGVybmFsVXJsIiwicHVzaFJlZiIsInBlbmRpbmdQdXNoIiwibm9ybWFsaXplZEZsaWdodERhdGEiLCJ0cmVlUGF0Y2giLCJzZWVkRGF0YSIsImNhY2hlTm9kZVNlZWREYXRhIiwiaGVhZCIsImlzUm9vdFJlbmRlciIsImNvbnNvbGUiLCJsb2ciLCJuZXdUcmVlIiwiYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlIiwiaGFuZGxlU2VnbWVudE1pc21hdGNoIiwiaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0IiwiY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmIiwiY3JlYXRlSHJlZkZyb21VcmwiLCJ1bmRlZmluZWQiLCJyc2MiLCJsb2FkaW5nIiwicHJlZmV0Y2hSc2MiLCJmaWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZCIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfQ0xJRU5UX1NFR01FTlRfQ0FDSEUiLCJyZXZhbGlkYXRlRW50aXJlQ2FjaGUiLCJwcmVmZXRjaENhY2hlIiwiTWFwIiwicmVmcmVzaEluYWN0aXZlUGFyYWxsZWxTZWdtZW50cyIsInVwZGF0ZWRUcmVlIiwidXBkYXRlZENhY2hlIiwicGF0Y2hlZFRyZWUiLCJoYW5kbGVNdXRhYmxlIl0sIm1hcHBpbmdzIjoiOzs7K0JBb0JnQkEsa0JBQUFBOzs7ZUFBQUE7OztxQ0FwQm9CO21DQUNGOzZDQUNVOzZDQUNBO2lDQU9WOytCQUNKOytDQUVnQjsyQkFDVDt1Q0FDQzttREFDWTtpREFDRjs4QkFDVjtBQUUvQixTQUFTQSxlQUNkQyxLQUEyQixFQUMzQkMsTUFBcUI7SUFFckIsTUFBTSxFQUFFQyxNQUFNLEVBQUUsR0FBR0Q7SUFDbkIsTUFBTUUsVUFBbUIsQ0FBQztJQUMxQixNQUFNQyxPQUFPSixNQUFNSyxZQUFZO0lBRS9CLElBQUlDLGNBQWNOLE1BQU1PLElBQUk7SUFFNUJKLFFBQVFLLDBCQUEwQixHQUFHO0lBRXJDLE1BQU1DLFFBQW1CQyxDQUFBQSxHQUFBQSxXQUFBQSxvQkFBb0I7SUFFN0Msc0ZBQXNGO0lBQ3RGLHNIQUFzSDtJQUN0SCxNQUFNQyxpQkFBaUJDLENBQUFBLEdBQUFBLG1DQUFBQSxpQ0FBaUMsRUFBQ1osTUFBTU8sSUFBSTtJQUVuRSx1REFBdUQ7SUFDdkQsd0NBQXdDO0lBQ3hDRSxNQUFNSSxRQUFRLEdBQUdDLENBQUFBLEdBQUFBLHFCQUFBQSxt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fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTE3NTIsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvaG1yLXJlZnJlc2gtcmVkdWNlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBmZXRjaFNlcnZlclJlc3BvbnNlIH0gZnJvbSAnLi4vZmV0Y2gtc2VydmVyLXJlc3BvbnNlJ1xuaW1wb3J0IHsgY3JlYXRlSHJlZkZyb21VcmwgfSBmcm9tICcuLi9jcmVhdGUtaHJlZi1mcm9tLXVybCdcbmltcG9ydCB7IGFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZSB9IGZyb20gJy4uL2FwcGx5LXJvdXRlci1zdGF0ZS1wYXRjaC10by10cmVlJ1xuaW1wb3J0IHsgaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0IH0gZnJvbSAnLi4vaXMtbmF2aWdhdGluZy10by1uZXctcm9vdC1sYXlvdXQnXG5pbXBvcnQgdHlwZSB7XG4gIFJlYWRvbmx5UmVkdWNlclN0YXRlLFxuICBSZWR1Y2VyU3RhdGUsXG4gIEhtclJlZnJlc2hBY3Rpb24sXG4gIE11dGFibGUsXG59IGZyb20gJy4uL3JvdXRlci1yZWR1Y2VyLXR5cGVzJ1xuaW1wb3J0IHsgaGFuZGxlRXh0ZXJuYWxVcmwgfSBmcm9tICcuL25hdmlnYXRlLXJlZHVjZXInXG5pbXBvcnQgeyBoYW5kbGVNdXRhYmxlIH0gZnJvbSAnLi4vaGFuZGxlLW11dGFibGUnXG5pbXBvcnQgeyBhcHBseUZsaWdodERhdGEgfSBmcm9tICcuLi9hcHBseS1mbGlnaHQtZGF0YSdcbmltcG9ydCB0eXBlIHsgQ2FjaGVOb2RlIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgeyBjcmVhdGVFbXB0eUNhY2hlTm9kZSB9IGZyb20gJy4uLy4uL2FwcC1yb3V0ZXInXG5pbXBvcnQgeyBoYW5kbGVTZWdtZW50TWlzbWF0Y2ggfSBmcm9tICcuLi9oYW5kbGUtc2VnbWVudC1taXNtYXRjaCdcbmltcG9ydCB7IGhhc0ludGVyY2VwdGlvblJvdXRlSW5DdXJyZW50VHJlZSB9IGZyb20gJy4vaGFzLWludGVyY2VwdGlvbi1yb3V0ZS1pbi1jdXJyZW50LXRyZWUnXG5cbi8vIEEgdmVyc2lvbiBvZiByZWZyZXNoIHJlZHVjZXIgdGhhdCBrZWVwcyB0aGUgY2FjaGUgYXJvdW5kIGluc3RlYWQgb2Ygd2lwaW5nIGFsbCBvZiBpdC5cbmZ1bmN0aW9uIGhtclJlZnJlc2hSZWR1Y2VySW1wbChcbiAgc3RhdGU6IFJlYWRvbmx5UmVkdWNlclN0YXRlLFxuICBhY3Rpb246IEhtclJlZnJlc2hBY3Rpb25cbik6IFJlZHVjZXJTdGF0ZSB7XG4gIGNvbnN0IHsgb3JpZ2luIH0gPSBhY3Rpb25cbiAgY29uc3QgbXV0YWJsZTogTXV0YWJsZSA9IHt9XG4gIGNvbnN0IGhyZWYgPSBzdGF0ZS5jYW5vbmljYWxVcmxcblxuICBtdXRhYmxlLnByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlID0gZmFsc2VcblxuICBjb25zdCBjYWNoZTogQ2FjaGVOb2RlID0gY3JlYXRlRW1wdHlDYWNoZU5vZGUoKVxuICAvLyBJZiB0aGUgY3VycmVudCB0cmVlIHdhcyBpbnRlcmNlcHRlZCwgdGhlIG5leHRVcmwgc2hvdWxkIGJlIGluY2x1ZGVkIGluIHRoZSByZXF1ZXN0LlxuICAvLyBUaGlzIGlzIHRvIGVuc3VyZSB0aGF0IHRoZSByZWZyZXNoIHJlcXVlc3QgZG9lc24ndCBnZXQgaW50ZXJjZXB0ZWQsIGFjY2lkZW50YWxseSB0cmlnZ2VyaW5nIHRoZSBpbnRlcmNlcHRpb24gcm91dGUuXG4gIGNvbnN0IGluY2x1ZGVOZXh0VXJsID0gaGFzSW50ZXJjZXB0aW9uUm91dGVJbkN1cnJlbnRUcmVlKHN0YXRlLnRyZWUpXG5cbiAgLy8gVE9ETy1BUFA6IHZlcmlmeSB0aGF0IGBocmVmYCBpcyBub3QgYW4gZXh0ZXJuYWwgdXJsLlxuICAvLyBGZXRjaCBkYXRhIGZyb20gdGhlIHJvb3Qgb2YgdGhlIHRyZWUuXG4gIGNvbnN0IG5hdmlnYXRlZEF0ID0gRGF0ZS5ub3coKVxuICBjYWNoZS5sYXp5RGF0YSA9IGZldGNoU2VydmVyUmVzcG9uc2UobmV3IFVSTChocmVmLCBvcmlnaW4pLCB7XG4gICAgZmxpZ2h0Um91dGVyU3RhdGU6IFtzdGF0ZS50cmVlWzBdLCBzdGF0ZS50cmVlWzFdLCBzdGF0ZS50cmVlWzJdLCAncmVmZXRjaCddLFxuICAgIG5leHRVcmw6IGluY2x1ZGVOZXh0VXJsID8gc3RhdGUubmV4dFVybCA6IG51bGwsXG4gICAgaXNIbXJSZWZyZXNoOiB0cnVlLFxuICB9KVxuXG4gIHJldHVybiBjYWNoZS5sYXp5RGF0YS50aGVuKFxuICAgICh7IGZsaWdodERhdGEsIGNhbm9uaWNhbFVybDogY2Fub25pY2FsVXJsT3ZlcnJpZGUgfSkgPT4ge1xuICAgICAgLy8gSGFuZGxlIGNhc2Ugd2hlbiBuYXZpZ2F0aW5nIHRvIHBhZ2UgaW4gYHBhZ2VzYCBmcm9tIGBhcHBgXG4gICAgICBpZiAodHlwZW9mIGZsaWdodERhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVFeHRlcm5hbFVybChcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICBtdXRhYmxlLFxuICAgICAgICAgIGZsaWdodERhdGEsXG4gICAgICAgICAgc3RhdGUucHVzaFJlZi5wZW5kaW5nUHVzaFxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSBjYWNoZS5sYXp5RGF0YSBhcyBpdCBoYXMgYmVlbiByZXNvbHZlZCBhdCB0aGlzIHBvaW50LlxuICAgICAgY2FjaGUubGF6eURhdGEgPSBudWxsXG5cbiAgICAgIGxldCBjdXJyZW50VHJlZSA9IHN0YXRlLnRyZWVcbiAgICAgIGxldCBjdXJyZW50Q2FjaGUgPSBzdGF0ZS5jYWNoZVxuXG4gICAgICBmb3IgKGNvbnN0IG5vcm1hbGl6ZWRGbGlnaHREYXRhIG9mIGZsaWdodERhdGEpIHtcbiAgICAgICAgY29uc3QgeyB0cmVlOiB0cmVlUGF0Y2gsIGlzUm9vdFJlbmRlciB9ID0gbm9ybWFsaXplZEZsaWdodERhdGFcbiAgICAgICAgaWYgKCFpc1Jvb3RSZW5kZXIpIHtcbiAgICAgICAgICAvLyBUT0RPLUFQUDogaGFuZGxlIHRoaXMgY2FzZSBiZXR0ZXJcbiAgICAgICAgICBjb25zb2xlLmxvZygnUkVGUkVTSCBGQUlMRUQnKVxuICAgICAgICAgIHJldHVybiBzdGF0ZVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbmV3VHJlZSA9IGFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZShcbiAgICAgICAgICAvLyBUT0RPLUFQUDogcmVtb3ZlICcnXG4gICAgICAgICAgWycnXSxcbiAgICAgICAgICBjdXJyZW50VHJlZSxcbiAgICAgICAgICB0cmVlUGF0Y2gsXG4gICAgICAgICAgc3RhdGUuY2Fub25pY2FsVXJsXG4gICAgICAgIClcblxuICAgICAgICBpZiAobmV3VHJlZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBoYW5kbGVTZWdtZW50TWlzbWF0Y2goc3RhdGUsIGFjdGlvbiwgdHJlZVBhdGNoKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dChjdXJyZW50VHJlZSwgbmV3VHJlZSkpIHtcbiAgICAgICAgICByZXR1cm4gaGFuZGxlRXh0ZXJuYWxVcmwoXG4gICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgIG11dGFibGUsXG4gICAgICAgICAgICBocmVmLFxuICAgICAgICAgICAgc3RhdGUucHVzaFJlZi5wZW5kaW5nUHVzaFxuICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZiA9IGNhbm9uaWNhbFVybE92ZXJyaWRlXG4gICAgICAgICAgPyBjcmVhdGVIcmVmRnJvbVVybChjYW5vbmljYWxVcmxPdmVycmlkZSlcbiAgICAgICAgICA6IHVuZGVmaW5lZFxuXG4gICAgICAgIGlmIChjYW5vbmljYWxVcmxPdmVycmlkZSkge1xuICAgICAgICAgIG11dGFibGUuY2Fub25pY2FsVXJsID0gY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBwbGllZCA9IGFwcGx5RmxpZ2h0RGF0YShcbiAgICAgICAgICBuYXZpZ2F0ZWRBdCxcbiAgICAgICAgICBjdXJyZW50Q2FjaGUsXG4gICAgICAgICAgY2FjaGUsXG4gICAgICAgICAgbm9ybWFsaXplZEZsaWdodERhdGFcbiAgICAgICAgKVxuXG4gICAgICAgIGlmIChhcHBsaWVkKSB7XG4gICAgICAgICAgbXV0YWJsZS5jYWNoZSA9IGNhY2hlXG4gICAgICAgICAgY3VycmVudENhY2hlID0gY2FjaGVcbiAgICAgICAgfVxuXG4gICAgICAgIG11dGFibGUucGF0Y2hlZFRyZWUgPSBuZXdUcmVlXG4gICAgICAgIG11dGFibGUuY2Fub25pY2FsVXJsID0gaHJlZlxuXG4gICAgICAgIGN1cnJlbnRUcmVlID0gbmV3VHJlZVxuICAgICAgfVxuICAgICAgcmV0dXJuIGhhbmRsZU11dGFibGUoc3RhdGUsIG11dGFibGUpXG4gICAgfSxcbiAgICAoKSA9PiBzdGF0ZVxuICApXG59XG5cbmZ1bmN0aW9uIGhtclJlZnJlc2hSZWR1Y2VyTm9vcChcbiAgc3RhdGU6IFJlYWRvbmx5UmVkdWNlclN0YXRlLFxuICBfYWN0aW9uOiBIbXJSZWZyZXNoQWN0aW9uXG4pOiBSZWR1Y2VyU3RhdGUge1xuICByZXR1cm4gc3RhdGVcbn1cblxuZXhwb3J0IGNvbnN0IGhtclJlZnJlc2hSZWR1Y2VyID1cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJ1xuICAgID8gaG1yUmVmcmVzaFJlZHVjZXJOb29wXG4gICAgOiBobXJSZWZyZXNoUmVkdWNlckltcGxcbiJdLCJuYW1lcyI6WyJobXJSZWZyZXNoUmVkdWNlciIsImhtclJlZnJlc2hSZWR1Y2VySW1wbCIsInN0YXRlIiwiYWN0aW9uIiwib3JpZ2luIiwibXV0YWJsZSIsImhyZWYiLCJjYW5vbmljYWxVcmwiLCJwcmVzZXJ2ZUN1c3RvbUhpc3RvcnlTdGF0ZSIsImNhY2hlIiwiY3JlYXRlRW1wdHlDYWNoZU5vZGUiLCJpbmNsdWRlTmV4dFVybCIsImhhc0ludGVyY2VwdGlvblJvdXRlSW5DdXJyZW50VHJlZSIsInRyZWUiLCJuYXZpZ2F0ZWRBdCIsIkRhdGUiLCJub3ciLCJsYXp5RGF0YSIsImZldGNoU2VydmVyUmVzcG9uc2UiLCJVUkwiLCJmbGlnaHRSb3V0ZXJTdGF0ZSIsIm5leHRVcmwiLCJpc0htclJlZnJlc2giLCJ0aGVuIiwiZmxpZ2h0RGF0YSIsImNhbm9uaWNhbFVybE92ZXJyaWRlIiwiaGFuZGxlRXh0ZXJuYWxVcmwiLCJwdXNoUmVmIiwicGVuZGluZ1B1c2giLCJjdXJyZW50VHJlZSIsImN1cnJlbnRDYWNoZSIsIm5vcm1hbGl6ZWRGbGlnaHREYXRhIiwidHJlZVBhdGNoIiwiaXNSb290UmVuZGVyIiwiY29uc29sZSIsImxvZyIsIm5ld1RyZWUiLCJhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUiLCJoYW5kbGVTZWdtZW50TWlzbWF0Y2giLCJpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQiLCJjYW5vbmljYWxVcmxPdmVycmlkZUhyZWYiLCJjcmVhdGVIcmVmRnJvbVVybCIsInVuZGVmaW5lZCIsImFwcGxpZWQiLCJhcHBseUZsaWdodERhdGEiLCJwYXRjaGVkVHJlZSIsImhhbmRsZU11dGFibGUiLCJobXJSZWZyZXNoUmVkdWNlck5vb3AiLCJfYWN0aW9uIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIl0sIm1hcHBpbmdzIjoiOzs7K0JBK0hhQSxxQkFBQUE7OztlQUFBQTs7O3FDQS9IdUI7bUNBQ0Y7NkNBQ1U7NkNBQ0E7aUNBT1Y7K0JBQ0o7aUNBQ0U7MkJBRUs7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QixHQUNBLElBQU1IO0FBRVY7QUFFQSxTQUFTNkMsc0JBQ1A3QyxLQUEyQixFQUMzQjhDLE9BQXlCO0lBRXpCLE9BQU85QztBQUNUO0FBRU8sTUFBTUYsb0JBQ1hpRCxRQUFRQyxHQUFHLENBQUNDLFFBQVEsS0FBSyxhQUNyQkosMEJBQ0E5QyIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxMTg1MywgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvYXNzaWduLWxvY2F0aW9uLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFkZEJhc2VQYXRoIH0gZnJvbSAnLi9hZGQtYmFzZS1wYXRoJ1xuXG4vKipcbiAqIEZ1bmN0aW9uIHRvIGNvcnJlY3RseSBhc3NpZ24gbG9jYXRpb24gdG8gVVJMXG4gKlxuICogVGhlIG1ldGhvZCB3aWxsIGFkZCBiYXNlUGF0aCwgYW5kIHdpbGwgYWxzbyBjb3JyZWN0bHkgYWRkIGxvY2F0aW9uIChpbmNsdWRpbmcgaWYgaXQgaXMgYSByZWxhdGl2ZSBwYXRoKVxuICogQHBhcmFtIGxvY2F0aW9uIExvY2F0aW9uIHRoYXQgc2hvdWxkIGJlIGFkZGVkIHRvIHRoZSB1cmxcbiAqIEBwYXJhbSB1cmwgQmFzZSBVUkwgdG8gd2hpY2ggdGhlIGxvY2F0aW9uIHNob3VsZCBiZSBhc3NpZ25lZFxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduTG9jYXRpb24obG9jYXRpb246IHN0cmluZywgdXJsOiBVUkwpOiBVUkwge1xuICBpZiAobG9jYXRpb24uc3RhcnRzV2l0aCgnLicpKSB7XG4gICAgY29uc3QgdXJsQmFzZSA9IHVybC5vcmlnaW4gKyB1cmwucGF0aG5hbWVcbiAgICByZXR1cm4gbmV3IFVSTChcbiAgICAgIC8vIEluIG9yZGVyIGZvciBhIHJlbGF0aXZlIHBhdGggdG8gYmUgYWRkZWQgdG8gdGhlIGN1cnJlbnQgdXJsIGNvcnJlY3RseSwgdGhlIGN1cnJlbnQgdXJsIG11c3QgZW5kIHdpdGggYSBzbGFzaFxuICAgICAgLy8gbmV3IFVSTCgnLi9yZWxhdGl2ZScsICdodHRwczovL2V4YW1wbGUuY29tL3N1YmRpcicpLmhyZWYgLT4gJ2h0dHBzOi8vZXhhbXBsZS5jb20vcmVsYXRpdmUnXG4gICAgICAvLyBuZXcgVVJMKCcuL3JlbGF0aXZlJywgJ2h0dHBzOi8vZXhhbXBsZS5jb20vc3ViZGlyLycpLmhyZWYgLT4gJ2h0dHBzOi8vZXhhbXBsZS5jb20vc3ViZGlyL3JlbGF0aXZlJ1xuICAgICAgKHVybEJhc2UuZW5kc1dpdGgoJy8nKSA/IHVybEJhc2UgOiB1cmxCYXNlICsgJy8nKSArIGxvY2F0aW9uXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIG5ldyBVUkwoYWRkQmFzZVBhdGgobG9jYXRpb24pLCB1cmwuaHJlZilcbn1cbiJdLCJuYW1lcyI6WyJhc3NpZ25Mb2NhdGlvbiIsImxvY2F0aW9uIiwidXJsIiwic3RhcnRzV2l0aCIsInVybEJhc2UiLCJvcmlnaW4iLCJwYXRobmFtZSIsIlVSTCIsImVuZHNXaXRoIiwiYWRkQmFzZVBhdGgiLCJocmVmIl0sIm1hcHBpbmdzIjoiOzs7K0JBU2dCQSxrQkFBQUE7OztlQUFBQTs7OzZCQVRZO0FBU3JCLFNBQVNBLGVBQWVDLFFBQWdCLEVBQUVDLEdBQVE7SUFDdkQsSUFBSUQsU0FBU0UsVUFBVSxDQUFDLE1BQU07UUFDNUIsTUFBTUMsVUFBVUYsSUFBSUcsTUFBTSxHQUFHSCxJQUFJSSxRQUFRO1FBQ3pDLE9BQU8sSUFBSUMsSUFDVCxBQUdBLEFBRkEsNkZBQTZGLGtCQURrQjtRQUUvRyxxR0FBcUc7UUFDcEdILENBQUFBLFFBQVFJLFFBQVEsQ0FBQyxPQUFPSixVQUFVQSxVQUFVLEdBQUUsSUFBS0g7SUFFeEQ7SUFFQSxPQUFPLElBQUlNLElBQUlFLENBQUFBLEdBQUFBLGFBQUFBLFdBQVcsRUFBQ1IsV0FBV0MsSUFBSVEsSUFBSTtBQUNoRCIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxMTg4NSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9zaGFyZWQvbGliL3NlcnZlci1yZWZlcmVuY2UtaW5mby50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgaW50ZXJmYWNlIFNlcnZlclJlZmVyZW5jZUluZm8ge1xuICB0eXBlOiAnc2VydmVyLWFjdGlvbicgfCAndXNlLWNhY2hlJ1xuICB1c2VkQXJnczogW2Jvb2xlYW4sIGJvb2xlYW4sIGJvb2xlYW4sIGJvb2xlYW4sIGJvb2xlYW4sIGJvb2xlYW5dXG4gIGhhc1Jlc3RBcmdzOiBib29sZWFuXG59XG5cbi8qKlxuICogRXh0cmFjdHMgaW5mbyBhYm91dCB0aGUgc2VydmVyIHJlZmVyZW5jZSBmb3IgdGhlIGdpdmVuIHNlcnZlciByZWZlcmVuY2UgSUQgYnlcbiAqIHBhcnNpbmcgdGhlIGZpcnN0IGJ5dGUgb2YgdGhlIGhleC1lbmNvZGVkIElELlxuICpcbiAqIGBgYFxuICogQml0IHBvc2l0aW9uczogWzddICAgICAgWzZdIFs1XSBbNF0gWzNdIFsyXSBbMV0gIFswXVxuICogQml0czogICAgICAgICAgdHlwZUJpdCAgYXJnTWFzayAgICAgICAgICAgICAgICAgIHJlc3RBcmdzXG4gKiBgYGBcbiAqXG4gKiBJZiB0aGUgYHR5cGVCaXRgIGlzIGAxYCB0aGUgc2VydmVyIHJlZmVyZW5jZSByZXByZXNlbnRzIGEgYFwidXNlIGNhY2hlXCJgXG4gKiBmdW5jdGlvbiwgb3RoZXJ3aXNlIGEgc2VydmVyIGFjdGlvbi5cbiAqXG4gKiBUaGUgYGFyZ01hc2tgIGVuY29kZXMgd2hldGhlciB0aGUgZnVuY3Rpb24gdXNlcyB0aGUgYXJndW1lbnQgYXQgdGhlXG4gKiByZXNwZWN0aXZlIHBvc2l0aW9uLlxuICpcbiAqIFRoZSBgcmVzdEFyZ3NgIGJpdCBpbmRpY2F0ZXMgd2hldGhlciB0aGUgZnVuY3Rpb24gdXNlcyBhIHJlc3QgcGFyYW1ldGVyLiBJdCdzXG4gKiBhbHNvIHNldCB0byAxIGlmIHRoZSBmdW5jdGlvbiBoYXMgbW9yZSB0aGFuIDYgYXJncy5cbiAqXG4gKiBAcGFyYW0gaWQgaGV4LWVuY29kZWQgc2VydmVyIHJlZmVyZW5jZSBJRFxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdEluZm9Gcm9tU2VydmVyUmVmZXJlbmNlSWQoXG4gIGlkOiBzdHJpbmdcbik6IFNlcnZlclJlZmVyZW5jZUluZm8ge1xuICBjb25zdCBpbmZvQnl0ZSA9IHBhcnNlSW50KGlkLnNsaWNlKDAsIDIpLCAxNilcbiAgY29uc3QgdHlwZUJpdCA9IChpbmZvQnl0ZSA+PiA3KSAmIDB4MVxuICBjb25zdCBhcmdNYXNrID0gKGluZm9CeXRlID4+IDEpICYgMHgzZlxuICBjb25zdCByZXN0QXJncyA9IGluZm9CeXRlICYgMHgxXG4gIGNvbnN0IHVzZWRBcmdzID0gQXJyYXkoNilcblxuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgNjsgaW5kZXgrKykge1xuICAgIGNvbnN0IGJpdFBvc2l0aW9uID0gNSAtIGluZGV4XG4gICAgY29uc3QgYml0ID0gKGFyZ01hc2sgPj4gYml0UG9zaXRpb24pICYgMHgxXG4gICAgdXNlZEFyZ3NbaW5kZXhdID0gYml0ID09PSAxXG4gIH1cblxuICByZXR1cm4ge1xuICAgIHR5cGU6IHR5cGVCaXQgPT09IDEgPyAndXNlLWNhY2hlJyA6ICdzZXJ2ZXItYWN0aW9uJyxcbiAgICB1c2VkQXJnczogdXNlZEFyZ3MgYXMgW1xuICAgICAgYm9vbGVhbixcbiAgICAgIGJvb2xlYW4sXG4gICAgICBib29sZWFuLFxuICAgICAgYm9vbGVhbixcbiAgICAgIGJvb2xlYW4sXG4gICAgICBib29sZWFuLFxuICAgIF0sXG4gICAgaGFzUmVzdEFyZ3M6IHJlc3RBcmdzID09PSAxLFxuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHNwYXJzZSBhcnJheSBjb250YWluaW5nIG9ubHkgdGhlIHVzZWQgYXJndW1lbnRzIGJhc2VkIG9uIHRoZVxuICogcHJvdmlkZWQgYWN0aW9uIGluZm8uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvbWl0VW51c2VkQXJncyhcbiAgYXJnczogdW5rbm93bltdLFxuICBpbmZvOiBTZXJ2ZXJSZWZlcmVuY2VJbmZvXG4pOiB1bmtub3duW10ge1xuICBjb25zdCBmaWx0ZXJlZEFyZ3MgPSBuZXcgQXJyYXkoYXJncy5sZW5ndGgpXG5cbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGFyZ3MubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgaWYgKFxuICAgICAgKGluZGV4IDwgNiAmJiBpbmZvLnVzZWRBcmdzW2luZGV4XSkgfHxcbiAgICAgIC8vIFRoaXMgYXNzdW1lcyB0aGF0IHRoZSBzZXJ2ZXIgcmVmZXJlbmNlIGluZm8gYnl0ZSBoYXMgdGhlIHJlc3RBcmdzIGJpdFxuICAgICAgLy8gc2V0IHRvIDEgaWYgdGhlcmUgYXJlIG1vcmUgdGhhbiA2IGFyZ3MuXG4gICAgICAoaW5kZXggPj0gNiAmJiBpbmZvLmhhc1Jlc3RBcmdzKVxuICAgICkge1xuICAgICAgZmlsdGVyZWRBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZpbHRlcmVkQXJnc1xufVxuIl0sIm5hbWVzIjpbImV4dHJhY3RJbmZvRnJvbVNlcnZlclJlZmVyZW5jZUlkIiwib21pdFVudXNlZEFyZ3MiLCJpZCIsImluZm9CeXRlIiwicGFyc2VJbnQiLCJzbGljZSIsInR5cGVCaXQiLCJhcmdNYXNrIiwicmVzdEFyZ3MiLCJ1c2VkQXJncyIsIkFycmF5IiwiaW5kZXgiLCJiaXRQb3NpdGlvbiIsImJpdCIsInR5cGUiLCJoYXNSZXN0QXJncyIsImFyZ3MiLCJpbmZvIiwiZmlsdGVyZWRBcmdzIiwibGVuZ3RoIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztJQTBCZ0JBLGdDQUFnQyxFQUFBO2VBQWhDQTs7SUFpQ0FDLGNBQWMsRUFBQTtlQUFkQTs7O0FBakNULFNBQVNELGlDQUNkRSxFQUFVO0lBRVYsTUFBTUMsV0FBV0MsU0FBU0YsR0FBR0csS0FBSyxDQUFDLEdBQUcsSUFBSTtJQUMxQyxNQUFNQyxVQUFXSCxZQUFZLElBQUs7SUFDbEMsTUFBTUksVUFBV0osWUFBWSxJQUFLO0lBQ2xDLE1BQU1LLFdBQVdMLFdBQVc7SUFDNUIsTUFBTU0sV0FBV0MsTUFBTTtJQUV2QixJQUFLLElBQUlDLFFBQVEsR0FBR0EsUUFBUSxHQUFHQSxRQUFTO1FBQ3RDLE1BQU1DLGNBQWMsSUFBSUQ7UUFDeEIsTUFBTUUsTUFBT04sV0FBV0ssY0FBZTtRQUN2Q0gsUUFBUSxDQUFDRSxNQUFNLEdBQUdFLFFBQVE7SUFDNUI7SUFFQSxPQUFPO1FBQ0xDLE1BQU1SLFlBQVksSUFBSSxjQUFjO1FBQ3BDRyxVQUFVQTtRQVFWTSxhQUFhUCxhQUFhO0lBQzVCO0FBQ0Y7QUFNTyxTQUFTUCxlQUNkZSxJQUFlLEVBQ2ZDLElBQXlCO0lBRXpCLE1BQU1DLGVBQWUsSUFBSVIsTUFBTU0sS0FBS0csTUFBTTtJQUUxQyxJQUFLLElBQUlSLFFBQVEsR0FBR0EsUUFBUUssS0FBS0csTUFBTSxFQUFFUixRQUFTO1FBQ2hELElBQ0dBLFFBQVEsS0FBS00sS0FBS1IsUUFBUSxDQUFDRSxNQUFNLElBQ2xDLHdFQUF3RTtRQUN4RSwwQ0FBMEM7UUFDekNBLFNBQVMsS0FBS00sS0FBS0YsV0FBVyxFQUMvQjtZQUNBRyxZQUFZLENBQUNQLE1BQU0sR0FBR0ssSUFBSSxDQUFDTCxNQUFNO1FBQ25DO0lBQ0Y7SUFFQSxPQUFPTztBQUNUIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDExOTQwLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL3NlcnZlci1hY3Rpb24tcmVkdWNlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7XG4gIEFjdGlvbkZsaWdodFJlc3BvbnNlLFxuICBBY3Rpb25SZXN1bHQsXG59IGZyb20gJy4uLy4uLy4uLy4uL3NlcnZlci9hcHAtcmVuZGVyL3R5cGVzJ1xuaW1wb3J0IHsgY2FsbFNlcnZlciB9IGZyb20gJy4uLy4uLy4uL2FwcC1jYWxsLXNlcnZlcidcbmltcG9ydCB7IGZpbmRTb3VyY2VNYXBVUkwgfSBmcm9tICcuLi8uLi8uLi9hcHAtZmluZC1zb3VyY2UtbWFwLXVybCdcbmltcG9ydCB7XG4gIEFDVElPTl9IRUFERVIsXG4gIE5FWFRfQUNUSU9OX05PVF9GT1VORF9IRUFERVIsXG4gIE5FWFRfSVNfUFJFUkVOREVSX0hFQURFUixcbiAgTkVYVF9ST1VURVJfU1RBVEVfVFJFRV9IRUFERVIsXG4gIE5FWFRfVVJMLFxuICBSU0NfQ09OVEVOVF9UWVBFX0hFQURFUixcbn0gZnJvbSAnLi4vLi4vYXBwLXJvdXRlci1oZWFkZXJzJ1xuXG4vLyBUT0RPOiBFeHBsaWNpdGx5IGltcG9ydCBmcm9tIGNsaWVudC5icm93c2VyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzXG5pbXBvcnQge1xuICBjcmVhdGVGcm9tRmV0Y2ggYXMgY3JlYXRlRnJvbUZldGNoQnJvd3NlcixcbiAgY3JlYXRlVGVtcG9yYXJ5UmVmZXJlbmNlU2V0LFxuICBlbmNvZGVSZXBseSxcbn0gZnJvbSAncmVhY3Qtc2VydmVyLWRvbS13ZWJwYWNrL2NsaWVudCdcblxuaW1wb3J0IHtcbiAgUHJlZmV0Y2hLaW5kLFxuICB0eXBlIFJlYWRvbmx5UmVkdWNlclN0YXRlLFxuICB0eXBlIFJlZHVjZXJTdGF0ZSxcbiAgdHlwZSBTZXJ2ZXJBY3Rpb25BY3Rpb24sXG4gIHR5cGUgU2VydmVyQWN0aW9uTXV0YWJsZSxcbn0gZnJvbSAnLi4vcm91dGVyLXJlZHVjZXItdHlwZXMnXG5pbXBvcnQgeyBhc3NpZ25Mb2NhdGlvbiB9IGZyb20gJy4uLy4uLy4uL2Fzc2lnbi1sb2NhdGlvbidcbmltcG9ydCB7IGNyZWF0ZUhyZWZGcm9tVXJsIH0gZnJvbSAnLi4vY3JlYXRlLWhyZWYtZnJvbS11cmwnXG5pbXBvcnQgeyBoYW5kbGVFeHRlcm5hbFVybCB9IGZyb20gJy4vbmF2aWdhdGUtcmVkdWNlcidcbmltcG9ydCB7IGFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZSB9IGZyb20gJy4uL2FwcGx5LXJvdXRlci1zdGF0ZS1wYXRjaC10by10cmVlJ1xuaW1wb3J0IHsgaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0IH0gZnJvbSAnLi4vaXMtbmF2aWdhdGluZy10by1uZXctcm9vdC1sYXlvdXQnXG5pbXBvcnQgdHlwZSB7IENhY2hlTm9kZSB9IGZyb20gJy4uLy4uLy4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHsgaGFuZGxlTXV0YWJsZSB9IGZyb20gJy4uL2hhbmRsZS1tdXRhYmxlJ1xuaW1wb3J0IHsgZmlsbExhenlJdGVtc1RpbGxMZWFmV2l0aEhlYWQgfSBmcm9tICcuLi9maWxsLWxhenktaXRlbXMtdGlsbC1sZWFmLXdpdGgtaGVhZCdcbmltcG9ydCB7IGNyZWF0ZUVtcHR5Q2FjaGVOb2RlIH0gZnJvbSAnLi4vLi4vYXBwLXJvdXRlcidcbmltcG9ydCB7IGhhc0ludGVyY2VwdGlvblJvdXRlSW5DdXJyZW50VHJlZSB9IGZyb20gJy4vaGFzLWludGVyY2VwdGlvbi1yb3V0ZS1pbi1jdXJyZW50LXRyZWUnXG5pbXBvcnQgeyBoYW5kbGVTZWdtZW50TWlzbWF0Y2ggfSBmcm9tICcuLi9oYW5kbGUtc2VnbWVudC1taXNtYXRjaCdcbmltcG9ydCB7IHJlZnJlc2hJbmFjdGl2ZVBhcmFsbGVsU2VnbWVudHMgfSBmcm9tICcuLi9yZWZldGNoLWluYWN0aXZlLXBhcmFsbGVsLXNlZ21lbnRzJ1xuaW1wb3J0IHtcbiAgbm9ybWFsaXplRmxpZ2h0RGF0YSxcbiAgcHJlcGFyZUZsaWdodFJvdXRlclN0YXRlRm9yUmVxdWVzdCxcbiAgdHlwZSBOb3JtYWxpemVkRmxpZ2h0RGF0YSxcbn0gZnJvbSAnLi4vLi4vLi4vZmxpZ2h0LWRhdGEtaGVscGVycydcbmltcG9ydCB7IGdldFJlZGlyZWN0RXJyb3IgfSBmcm9tICcuLi8uLi9yZWRpcmVjdCdcbmltcG9ydCB7IFJlZGlyZWN0VHlwZSB9IGZyb20gJy4uLy4uL3JlZGlyZWN0LWVycm9yJ1xuaW1wb3J0IHsgY3JlYXRlU2VlZGVkUHJlZmV0Y2hDYWNoZUVudHJ5IH0gZnJvbSAnLi4vcHJlZmV0Y2gtY2FjaGUtdXRpbHMnXG5pbXBvcnQgeyByZW1vdmVCYXNlUGF0aCB9IGZyb20gJy4uLy4uLy4uL3JlbW92ZS1iYXNlLXBhdGgnXG5pbXBvcnQgeyBoYXNCYXNlUGF0aCB9IGZyb20gJy4uLy4uLy4uL2hhcy1iYXNlLXBhdGgnXG5pbXBvcnQge1xuICBleHRyYWN0SW5mb0Zyb21TZXJ2ZXJSZWZlcmVuY2VJZCxcbiAgb21pdFVudXNlZEFyZ3MsXG59IGZyb20gJy4uLy4uLy4uLy4uL3NoYXJlZC9saWIvc2VydmVyLXJlZmVyZW5jZS1pbmZvJ1xuaW1wb3J0IHsgcmV2YWxpZGF0ZUVudGlyZUNhY2hlIH0gZnJvbSAnLi4vLi4vc2VnbWVudC1jYWNoZSdcblxuY29uc3QgY3JlYXRlRnJvbUZldGNoID1cbiAgY3JlYXRlRnJvbUZldGNoQnJvd3NlciBhcyAodHlwZW9mIGltcG9ydCgncmVhY3Qtc2VydmVyLWRvbS13ZWJwYWNrL2NsaWVudC5icm93c2VyJykpWydjcmVhdGVGcm9tRmV0Y2gnXVxuXG50eXBlIEZldGNoU2VydmVyQWN0aW9uUmVzdWx0ID0ge1xuICByZWRpcmVjdExvY2F0aW9uOiBVUkwgfCB1bmRlZmluZWRcbiAgcmVkaXJlY3RUeXBlOiBSZWRpcmVjdFR5cGUgfCB1bmRlZmluZWRcbiAgYWN0aW9uUmVzdWx0OiBBY3Rpb25SZXN1bHQgfCB1bmRlZmluZWRcbiAgYWN0aW9uRmxpZ2h0RGF0YTogTm9ybWFsaXplZEZsaWdodERhdGFbXSB8IHN0cmluZyB8IHVuZGVmaW5lZFxuICBpc1ByZXJlbmRlcjogYm9vbGVhblxuICByZXZhbGlkYXRlZFBhcnRzOiB7XG4gICAgdGFnOiBib29sZWFuXG4gICAgY29va2llOiBib29sZWFuXG4gICAgcGF0aHM6IHN0cmluZ1tdXG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hTZXJ2ZXJBY3Rpb24oXG4gIHN0YXRlOiBSZWFkb25seVJlZHVjZXJTdGF0ZSxcbiAgbmV4dFVybDogUmVhZG9ubHlSZWR1Y2VyU3RhdGVbJ25leHRVcmwnXSxcbiAgeyBhY3Rpb25JZCwgYWN0aW9uQXJncyB9OiBTZXJ2ZXJBY3Rpb25BY3Rpb25cbik6IFByb21pc2U8RmV0Y2hTZXJ2ZXJBY3Rpb25SZXN1bHQ+IHtcbiAgY29uc3QgdGVtcG9yYXJ5UmVmZXJlbmNlcyA9IGNyZWF0ZVRlbXBvcmFyeVJlZmVyZW5jZVNldCgpXG4gIGNvbnN0IGluZm8gPSBleHRyYWN0SW5mb0Zyb21TZXJ2ZXJSZWZlcmVuY2VJZChhY3Rpb25JZClcblxuICAvLyBUT0RPOiBDdXJyZW50bHksIHdlJ3JlIG9ubHkgb21pdHRpbmcgdW51c2VkIGFyZ3MgZm9yIHRoZSBleHBlcmltZW50YWwgXCJ1c2VcbiAgLy8gY2FjaGVcIiBmdW5jdGlvbnMuIE9uY2UgdGhlIHNlcnZlciByZWZlcmVuY2UgaW5mbyBieXRlIGZlYXR1cmUgaXMgc3RhYmxlLCB3ZVxuICAvLyBzaG91bGQgYXBwbHkgdGhpcyB0byBzZXJ2ZXIgYWN0aW9ucyBhcyB3ZWxsLlxuICBjb25zdCB1c2VkQXJncyA9XG4gICAgaW5mby50eXBlID09PSAndXNlLWNhY2hlJyA/IG9taXRVbnVzZWRBcmdzKGFjdGlvbkFyZ3MsIGluZm8pIDogYWN0aW9uQXJnc1xuXG4gIGNvbnN0IGJvZHkgPSBhd2FpdCBlbmNvZGVSZXBseSh1c2VkQXJncywgeyB0ZW1wb3JhcnlSZWZlcmVuY2VzIH0pXG5cbiAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goc3RhdGUuY2Fub25pY2FsVXJsLCB7XG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgaGVhZGVyczoge1xuICAgICAgQWNjZXB0OiBSU0NfQ09OVEVOVF9UWVBFX0hFQURFUixcbiAgICAgIFtBQ1RJT05fSEVBREVSXTogYWN0aW9uSWQsXG4gICAgICBbTkVYVF9ST1VURVJfU1RBVEVfVFJFRV9IRUFERVJdOiBwcmVwYXJlRmxpZ2h0Um91dGVyU3RhdGVGb3JSZXF1ZXN0KFxuICAgICAgICBzdGF0ZS50cmVlXG4gICAgICApLFxuICAgICAgLi4uKHByb2Nlc3MuZW52Lk5FWFRfREVQTE9ZTUVOVF9JRFxuICAgICAgICA/IHtcbiAgICAgICAgICAgICd4LWRlcGxveW1lbnQtaWQnOiBwcm9jZXNzLmVudi5ORVhUX0RFUExPWU1FTlRfSUQsXG4gICAgICAgICAgfVxuICAgICAgICA6IHt9KSxcbiAgICAgIC4uLihuZXh0VXJsXG4gICAgICAgID8ge1xuICAgICAgICAgICAgW05FWFRfVVJMXTogbmV4dFVybCxcbiAgICAgICAgICB9XG4gICAgICAgIDoge30pLFxuICAgIH0sXG4gICAgYm9keSxcbiAgfSlcblxuICAvLyBIYW5kbGUgc2VydmVyIGFjdGlvbnMgdGhhdCB0aGUgc2VydmVyIGRpZG4ndCByZWNvZ25pemUuXG4gIGNvbnN0IHVucmVjb2duaXplZEFjdGlvbkhlYWRlciA9IHJlcy5oZWFkZXJzLmdldChORVhUX0FDVElPTl9OT1RfRk9VTkRfSEVBREVSKVxuICBpZiAodW5yZWNvZ25pemVkQWN0aW9uSGVhZGVyID09PSAnMScpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgU2VydmVyIEFjdGlvbiBcIiR7YWN0aW9uSWR9XCIgd2FzIG5vdCBmb3VuZCBvbiB0aGUgc2VydmVyLiBcXG5SZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2ZhaWxlZC10by1maW5kLXNlcnZlci1hY3Rpb25gXG4gICAgKVxuICB9XG5cbiAgY29uc3QgcmVkaXJlY3RIZWFkZXIgPSByZXMuaGVhZGVycy5nZXQoJ3gtYWN0aW9uLXJlZGlyZWN0JylcbiAgY29uc3QgW2xvY2F0aW9uLCBfcmVkaXJlY3RUeXBlXSA9IHJlZGlyZWN0SGVhZGVyPy5zcGxpdCgnOycpIHx8IFtdXG4gIGxldCByZWRpcmVjdFR5cGU6IFJlZGlyZWN0VHlwZSB8IHVuZGVmaW5lZFxuICBzd2l0Y2ggKF9yZWRpcmVjdFR5cGUpIHtcbiAgICBjYXNlICdwdXNoJzpcbiAgICAgIHJlZGlyZWN0VHlwZSA9IFJlZGlyZWN0VHlwZS5wdXNoXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3JlcGxhY2UnOlxuICAgICAgcmVkaXJlY3RUeXBlID0gUmVkaXJlY3RUeXBlLnJlcGxhY2VcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHJlZGlyZWN0VHlwZSA9IHVuZGVmaW5lZFxuICB9XG5cbiAgY29uc3QgaXNQcmVyZW5kZXIgPSAhIXJlcy5oZWFkZXJzLmdldChORVhUX0lTX1BSRVJFTkRFUl9IRUFERVIpXG4gIGxldCByZXZhbGlkYXRlZFBhcnRzOiBGZXRjaFNlcnZlckFjdGlvblJlc3VsdFsncmV2YWxpZGF0ZWRQYXJ0cyddXG4gIHRyeSB7XG4gICAgY29uc3QgcmV2YWxpZGF0ZWRIZWFkZXIgPSBKU09OLnBhcnNlKFxuICAgICAgcmVzLmhlYWRlcnMuZ2V0KCd4LWFjdGlvbi1yZXZhbGlkYXRlZCcpIHx8ICdbW10sMCwwXSdcbiAgICApXG4gICAgcmV2YWxpZGF0ZWRQYXJ0cyA9IHtcbiAgICAgIHBhdGhzOiByZXZhbGlkYXRlZEhlYWRlclswXSB8fCBbXSxcbiAgICAgIHRhZzogISFyZXZhbGlkYXRlZEhlYWRlclsxXSxcbiAgICAgIGNvb2tpZTogcmV2YWxpZGF0ZWRIZWFkZXJbMl0sXG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV2YWxpZGF0ZWRQYXJ0cyA9IE5PX1JFVkFMSURBVEVEX1BBUlRTXG4gIH1cblxuICBjb25zdCByZWRpcmVjdExvY2F0aW9uID0gbG9jYXRpb25cbiAgICA/IGFzc2lnbkxvY2F0aW9uKFxuICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgbmV3IFVSTChzdGF0ZS5jYW5vbmljYWxVcmwsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKVxuICAgICAgKVxuICAgIDogdW5kZWZpbmVkXG5cbiAgY29uc3QgY29udGVudFR5cGUgPSByZXMuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpXG4gIGNvbnN0IGlzUnNjUmVzcG9uc2UgPSAhIShcbiAgICBjb250ZW50VHlwZSAmJiBjb250ZW50VHlwZS5zdGFydHNXaXRoKFJTQ19DT05URU5UX1RZUEVfSEVBREVSKVxuICApXG5cbiAgLy8gSGFuZGxlIGludmFsaWQgc2VydmVyIGFjdGlvbiByZXNwb25zZXMuXG4gIC8vIEEgdmFsaWQgcmVzcG9uc2UgbXVzdCBoYXZlIGBjb250ZW50LXR5cGU6IHRleHQveC1jb21wb25lbnRgLCB1bmxlc3MgaXQncyBhbiBleHRlcm5hbCByZWRpcmVjdC5cbiAgLy8gKGV4dGVybmFsIHJlZGlyZWN0cyBoYXZlIGFuICd4LWFjdGlvbi1yZWRpcmVjdCcgaGVhZGVyLCBidXQgdGhlIGJvZHkgaXMgYW4gZW1wdHkgJ3RleHQvcGxhaW4nKVxuICBpZiAoIWlzUnNjUmVzcG9uc2UgJiYgIXJlZGlyZWN0TG9jYXRpb24pIHtcbiAgICAvLyBUaGUgc2VydmVyIGNhbiByZXNwb25kIHdpdGggYSB0ZXh0L3BsYWluIGVycm9yIG1lc3NhZ2UsIGJ1dCB3ZSdsbCBmYWxsYmFjayB0byBzb21ldGhpbmcgZ2VuZXJpY1xuICAgIC8vIGlmIHRoZXJlIGlzbid0IG9uZS5cbiAgICBjb25zdCBtZXNzYWdlID1cbiAgICAgIHJlcy5zdGF0dXMgPj0gNDAwICYmIGNvbnRlbnRUeXBlID09PSAndGV4dC9wbGFpbidcbiAgICAgICAgPyBhd2FpdCByZXMudGV4dCgpXG4gICAgICAgIDogJ0FuIHVuZXhwZWN0ZWQgcmVzcG9uc2Ugd2FzIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlci4nXG5cbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSlcbiAgfVxuXG4gIGxldCBhY3Rpb25SZXN1bHQ6IEZldGNoU2VydmVyQWN0aW9uUmVzdWx0WydhY3Rpb25SZXN1bHQnXVxuICBsZXQgYWN0aW9uRmxpZ2h0RGF0YTogRmV0Y2hTZXJ2ZXJBY3Rpb25SZXN1bHRbJ2FjdGlvbkZsaWdodERhdGEnXVxuICBpZiAoaXNSc2NSZXNwb25zZSkge1xuICAgIGNvbnN0IHJlc3BvbnNlOiBBY3Rpb25GbGlnaHRSZXNwb25zZSA9IGF3YWl0IGNyZWF0ZUZyb21GZXRjaChcbiAgICAgIFByb21pc2UucmVzb2x2ZShyZXMpLFxuICAgICAgeyBjYWxsU2VydmVyLCBmaW5kU291cmNlTWFwVVJMLCB0ZW1wb3JhcnlSZWZlcmVuY2VzIH1cbiAgICApXG4gICAgLy8gQW4gaW50ZXJuYWwgcmVkaXJlY3QgY2FuIHNlbmQgYW4gUlNDIHJlc3BvbnNlLCBidXQgZG9lcyBub3QgaGF2ZSBhIHVzZWZ1bCBgYWN0aW9uUmVzdWx0YC5cbiAgICBhY3Rpb25SZXN1bHQgPSByZWRpcmVjdExvY2F0aW9uID8gdW5kZWZpbmVkIDogcmVzcG9uc2UuYVxuICAgIGFjdGlvbkZsaWdodERhdGEgPSBub3JtYWxpemVGbGlnaHREYXRhKHJlc3BvbnNlLmYpXG4gIH0gZWxzZSB7XG4gICAgLy8gQW4gZXh0ZXJuYWwgcmVkaXJlY3QgZG9lc24ndCBjb250YWluIFJTQyBkYXRhLlxuICAgIGFjdGlvblJlc3VsdCA9IHVuZGVmaW5lZFxuICAgIGFjdGlvbkZsaWdodERhdGEgPSB1bmRlZmluZWRcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYWN0aW9uUmVzdWx0LFxuICAgIGFjdGlvbkZsaWdodERhdGEsXG4gICAgcmVkaXJlY3RMb2NhdGlvbixcbiAgICByZWRpcmVjdFR5cGUsXG4gICAgcmV2YWxpZGF0ZWRQYXJ0cyxcbiAgICBpc1ByZXJlbmRlcixcbiAgfVxufVxuXG5jb25zdCBOT19SRVZBTElEQVRFRF9QQVJUUyA9IHtcbiAgcGF0aHM6IFtdLFxuICB0YWc6IGZhbHNlLFxuICBjb29raWU6IGZhbHNlLFxufVxuXG4vKlxuICogVGhpcyByZWR1Y2VyIGlzIHJlc3BvbnNpYmxlIGZvciBjYWxsaW5nIHRoZSBzZXJ2ZXIgYWN0aW9uIGFuZCBwcm9jZXNzaW5nIGFueSBzaWRlLWVmZmVjdHMgZnJvbSB0aGUgc2VydmVyIGFjdGlvbi5cbiAqIEl0IGRvZXMgbm90IG11dGF0ZSB0aGUgc3RhdGUgYnkgaXRzZWxmIGJ1dCByYXRoZXIgZGVsZWdhdGVzIHRvIG90aGVyIHJlZHVjZXJzIHRvIGRvIHRoZSBhY3R1YWwgbXV0YXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXJ2ZXJBY3Rpb25SZWR1Y2VyKFxuICBzdGF0ZTogUmVhZG9ubHlSZWR1Y2VyU3RhdGUsXG4gIGFjdGlvbjogU2VydmVyQWN0aW9uQWN0aW9uXG4pOiBSZWR1Y2VyU3RhdGUge1xuICBjb25zdCB7IHJlc29sdmUsIHJlamVjdCB9ID0gYWN0aW9uXG4gIGNvbnN0IG11dGFibGU6IFNlcnZlckFjdGlvbk11dGFibGUgPSB7fVxuXG4gIGxldCBjdXJyZW50VHJlZSA9IHN0YXRlLnRyZWVcblxuICBtdXRhYmxlLnByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlID0gZmFsc2VcblxuICAvLyBvbmx5IHBhc3MgYWxvbmcgdGhlIGBuZXh0VXJsYCBwYXJhbSAodXNlZCBmb3IgaW50ZXJjZXB0aW9uIHJvdXRlcykgaWYgdGhlIGN1cnJlbnQgcm91dGUgd2FzIGludGVyY2VwdGVkLlxuICAvLyBJZiB0aGUgcm91dGUgaGFzIGJlZW4gaW50ZXJjZXB0ZWQsIHRoZSBhY3Rpb24gc2hvdWxkIGJlIGFzIHdlbGwuXG4gIC8vIE90aGVyd2lzZSB0aGUgc2VydmVyIGFjdGlvbiBtaWdodCBiZSBpbnRlcmNlcHRlZCB3aXRoIHRoZSB3cm9uZyBhY3Rpb24gaWRcbiAgLy8gKGllLCBvbmUgdGhhdCBjb3JyZXNwb25kcyB3aXRoIHRoZSBpbnRlcmNlcHRlZCByb3V0ZSlcbiAgY29uc3QgbmV4dFVybCA9XG4gICAgc3RhdGUubmV4dFVybCAmJiBoYXNJbnRlcmNlcHRpb25Sb3V0ZUluQ3VycmVudFRyZWUoc3RhdGUudHJlZSlcbiAgICAgID8gc3RhdGUubmV4dFVybFxuICAgICAgOiBudWxsXG5cbiAgY29uc3QgbmF2aWdhdGVkQXQgPSBEYXRlLm5vdygpXG5cbiAgcmV0dXJuIGZldGNoU2VydmVyQWN0aW9uKHN0YXRlLCBuZXh0VXJsLCBhY3Rpb24pLnRoZW4oXG4gICAgYXN5bmMgKHtcbiAgICAgIGFjdGlvblJlc3VsdCxcbiAgICAgIGFjdGlvbkZsaWdodERhdGE6IGZsaWdodERhdGEsXG4gICAgICByZWRpcmVjdExvY2F0aW9uLFxuICAgICAgcmVkaXJlY3RUeXBlLFxuICAgICAgaXNQcmVyZW5kZXIsXG4gICAgICByZXZhbGlkYXRlZFBhcnRzLFxuICAgIH0pID0+IHtcbiAgICAgIGxldCByZWRpcmVjdEhyZWY6IHN0cmluZyB8IHVuZGVmaW5lZFxuXG4gICAgICAvLyBob25vciB0aGUgcmVkaXJlY3QgdHlwZSBpbnN0ZWFkIG9mIGRlZmF1bHRpbmcgdG8gcHVzaCBpbiBjYXNlIG9mIHNlcnZlciBhY3Rpb25zLlxuICAgICAgaWYgKHJlZGlyZWN0TG9jYXRpb24pIHtcbiAgICAgICAgaWYgKHJlZGlyZWN0VHlwZSA9PT0gUmVkaXJlY3RUeXBlLnJlcGxhY2UpIHtcbiAgICAgICAgICBzdGF0ZS5wdXNoUmVmLnBlbmRpbmdQdXNoID0gZmFsc2VcbiAgICAgICAgICBtdXRhYmxlLnBlbmRpbmdQdXNoID0gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZS5wdXNoUmVmLnBlbmRpbmdQdXNoID0gdHJ1ZVxuICAgICAgICAgIG11dGFibGUucGVuZGluZ1B1c2ggPSB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICByZWRpcmVjdEhyZWYgPSBjcmVhdGVIcmVmRnJvbVVybChyZWRpcmVjdExvY2F0aW9uLCBmYWxzZSlcbiAgICAgICAgbXV0YWJsZS5jYW5vbmljYWxVcmwgPSByZWRpcmVjdEhyZWZcbiAgICAgIH1cblxuICAgICAgaWYgKCFmbGlnaHREYXRhKSB7XG4gICAgICAgIHJlc29sdmUoYWN0aW9uUmVzdWx0KVxuXG4gICAgICAgIC8vIElmIHRoZXJlIGlzIGEgcmVkaXJlY3QgYnV0IG5vIGZsaWdodCBkYXRhIHdlIG5lZWQgdG8gZG8gYSBtcGFOYXZpZ2F0aW9uLlxuICAgICAgICBpZiAocmVkaXJlY3RMb2NhdGlvbikge1xuICAgICAgICAgIHJldHVybiBoYW5kbGVFeHRlcm5hbFVybChcbiAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgbXV0YWJsZSxcbiAgICAgICAgICAgIHJlZGlyZWN0TG9jYXRpb24uaHJlZixcbiAgICAgICAgICAgIHN0YXRlLnB1c2hSZWYucGVuZGluZ1B1c2hcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXRlXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgZmxpZ2h0RGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gSGFuZGxlIGNhc2Ugd2hlbiBuYXZpZ2F0aW5nIHRvIHBhZ2UgaW4gYHBhZ2VzYCBmcm9tIGBhcHBgXG4gICAgICAgIHJlc29sdmUoYWN0aW9uUmVzdWx0KVxuXG4gICAgICAgIHJldHVybiBoYW5kbGVFeHRlcm5hbFVybChcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICBtdXRhYmxlLFxuICAgICAgICAgIGZsaWdodERhdGEsXG4gICAgICAgICAgc3RhdGUucHVzaFJlZi5wZW5kaW5nUHVzaFxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGFjdGlvblJldmFsaWRhdGVkID1cbiAgICAgICAgcmV2YWxpZGF0ZWRQYXJ0cy5wYXRocy5sZW5ndGggPiAwIHx8XG4gICAgICAgIHJldmFsaWRhdGVkUGFydHMudGFnIHx8XG4gICAgICAgIHJldmFsaWRhdGVkUGFydHMuY29va2llXG5cbiAgICAgIGZvciAoY29uc3Qgbm9ybWFsaXplZEZsaWdodERhdGEgb2YgZmxpZ2h0RGF0YSkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgdHJlZTogdHJlZVBhdGNoLFxuICAgICAgICAgIHNlZWREYXRhOiBjYWNoZU5vZGVTZWVkRGF0YSxcbiAgICAgICAgICBoZWFkLFxuICAgICAgICAgIGlzUm9vdFJlbmRlcixcbiAgICAgICAgfSA9IG5vcm1hbGl6ZWRGbGlnaHREYXRhXG5cbiAgICAgICAgaWYgKCFpc1Jvb3RSZW5kZXIpIHtcbiAgICAgICAgICAvLyBUT0RPLUFQUDogaGFuZGxlIHRoaXMgY2FzZSBiZXR0ZXJcbiAgICAgICAgICBjb25zb2xlLmxvZygnU0VSVkVSIEFDVElPTiBBUFBMWSBGQUlMRUQnKVxuICAgICAgICAgIHJlc29sdmUoYWN0aW9uUmVzdWx0KVxuXG4gICAgICAgICAgcmV0dXJuIHN0YXRlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBHaXZlbiB0aGUgcGF0aCBjYW4gb25seSBoYXZlIHR3byBpdGVtcyB0aGUgaXRlbXMgYXJlIG9ubHkgdGhlIHJvdXRlciBzdGF0ZSBhbmQgcnNjIGZvciB0aGUgcm9vdC5cbiAgICAgICAgY29uc3QgbmV3VHJlZSA9IGFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZShcbiAgICAgICAgICAvLyBUT0RPLUFQUDogcmVtb3ZlICcnXG4gICAgICAgICAgWycnXSxcbiAgICAgICAgICBjdXJyZW50VHJlZSxcbiAgICAgICAgICB0cmVlUGF0Y2gsXG4gICAgICAgICAgcmVkaXJlY3RIcmVmID8gcmVkaXJlY3RIcmVmIDogc3RhdGUuY2Fub25pY2FsVXJsXG4gICAgICAgIClcblxuICAgICAgICBpZiAobmV3VHJlZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHJlc29sdmUoYWN0aW9uUmVzdWx0KVxuXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZVNlZ21lbnRNaXNtYXRjaChzdGF0ZSwgYWN0aW9uLCB0cmVlUGF0Y2gpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0KGN1cnJlbnRUcmVlLCBuZXdUcmVlKSkge1xuICAgICAgICAgIHJlc29sdmUoYWN0aW9uUmVzdWx0KVxuXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZUV4dGVybmFsVXJsKFxuICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICBtdXRhYmxlLFxuICAgICAgICAgICAgcmVkaXJlY3RIcmVmIHx8IHN0YXRlLmNhbm9uaWNhbFVybCxcbiAgICAgICAgICAgIHN0YXRlLnB1c2hSZWYucGVuZGluZ1B1c2hcbiAgICAgICAgICApXG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgc2VydmVyIHNlbnQgYmFjayBSU0MgZGF0YSBmb3IgdGhlIHNlcnZlciBhY3Rpb24sIHNvIHdlIG5lZWQgdG8gYXBwbHkgaXQgdG8gdGhlIGNhY2hlLlxuICAgICAgICBpZiAoY2FjaGVOb2RlU2VlZERhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICBjb25zdCByc2MgPSBjYWNoZU5vZGVTZWVkRGF0YVsxXVxuICAgICAgICAgIGNvbnN0IGNhY2hlOiBDYWNoZU5vZGUgPSBjcmVhdGVFbXB0eUNhY2hlTm9kZSgpXG4gICAgICAgICAgY2FjaGUucnNjID0gcnNjXG4gICAgICAgICAgY2FjaGUucHJlZmV0Y2hSc2MgPSBudWxsXG4gICAgICAgICAgY2FjaGUubG9hZGluZyA9IGNhY2hlTm9kZVNlZWREYXRhWzNdXG4gICAgICAgICAgZmlsbExhenlJdGVtc1RpbGxMZWFmV2l0aEhlYWQoXG4gICAgICAgICAgICBuYXZpZ2F0ZWRBdCxcbiAgICAgICAgICAgIGNhY2hlLFxuICAgICAgICAgICAgLy8gRXhpc3RpbmcgY2FjaGUgaXMgbm90IHBhc3NlZCBpbiBhcyBzZXJ2ZXIgYWN0aW9ucyBoYXZlIHRvIGludmFsaWRhdGUgdGhlIGVudGlyZSBjYWNoZS5cbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHRyZWVQYXRjaCxcbiAgICAgICAgICAgIGNhY2hlTm9kZVNlZWREYXRhLFxuICAgICAgICAgICAgaGVhZCxcbiAgICAgICAgICAgIHVuZGVmaW5lZFxuICAgICAgICAgIClcblxuICAgICAgICAgIG11dGFibGUuY2FjaGUgPSBjYWNoZVxuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1NFR01FTlRfQ0FDSEUpIHtcbiAgICAgICAgICAgIHJldmFsaWRhdGVFbnRpcmVDYWNoZShzdGF0ZS5uZXh0VXJsLCBuZXdUcmVlKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtdXRhYmxlLnByZWZldGNoQ2FjaGUgPSBuZXcgTWFwKClcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGFjdGlvblJldmFsaWRhdGVkKSB7XG4gICAgICAgICAgICBhd2FpdCByZWZyZXNoSW5hY3RpdmVQYXJhbGxlbFNlZ21lbnRzKHtcbiAgICAgICAgICAgICAgbmF2aWdhdGVkQXQsXG4gICAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgICB1cGRhdGVkVHJlZTogbmV3VHJlZSxcbiAgICAgICAgICAgICAgdXBkYXRlZENhY2hlOiBjYWNoZSxcbiAgICAgICAgICAgICAgaW5jbHVkZU5leHRVcmw6IEJvb2xlYW4obmV4dFVybCksXG4gICAgICAgICAgICAgIGNhbm9uaWNhbFVybDogbXV0YWJsZS5jYW5vbmljYWxVcmwgfHwgc3RhdGUuY2Fub25pY2FsVXJsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBtdXRhYmxlLnBhdGNoZWRUcmVlID0gbmV3VHJlZVxuICAgICAgICBjdXJyZW50VHJlZSA9IG5ld1RyZWVcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZGlyZWN0TG9jYXRpb24gJiYgcmVkaXJlY3RIcmVmKSB7XG4gICAgICAgIGlmICghcHJvY2Vzcy5lbnYuX19ORVhUX0NMSUVOVF9TRUdNRU5UX0NBQ0hFICYmICFhY3Rpb25SZXZhbGlkYXRlZCkge1xuICAgICAgICAgIC8vIEJlY2F1c2UgdGhlIFJlZGlyZWN0Qm91bmRhcnkgd2lsbCB0cmlnZ2VyIGEgbmF2aWdhdGlvbiwgd2UgbmVlZCB0byBzZWVkIHRoZSBwcmVmZXRjaCBjYWNoZVxuICAgICAgICAgIC8vIHdpdGggdGhlIEZsaWdodERhdGEgdGhhdCB3ZSBnb3QgZnJvbSB0aGUgc2VydmVyIGFjdGlvbiBmb3IgdGhlIHRhcmdldCBwYWdlLCBzbyB0aGF0IGl0J3NcbiAgICAgICAgICAvLyBhdmFpbGFibGUgd2hlbiB0aGUgcGFnZSBpcyBuYXZpZ2F0ZWQgdG8gYW5kIGRvZXNuJ3QgbmVlZCB0byBiZSByZS1mZXRjaGVkLlxuICAgICAgICAgIC8vIFdlIG9ubHkgZG8gdGhpcyBpZiB0aGUgc2VydmVyIGFjdGlvbiBkaWRuJ3QgcmV2YWxpZGF0ZSBhbnkgZGF0YSwgYXMgaW4gdGhhdCBjYXNlIHRoZVxuICAgICAgICAgIC8vIGNsaWVudCBjYWNoZSB3aWxsIGJlIGNsZWFyZWQgYW5kIHRoZSBkYXRhIHdpbGwgYmUgcmUtZmV0Y2hlZCBhbnl3YXkuXG4gICAgICAgICAgLy8gTk9URTogV2UgZG9uJ3QgZG8gdGhpcyBpbiB0aGUgU2VnbWVudCBDYWNoZSBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICAvLyBEeW5hbWljIGRhdGEgc2hvdWxkIG5ldmVyIGJlIHBsYWNlZCBpbnRvIHRoZSBjYWNoZSwgdW5sZXNzIGl0J3NcbiAgICAgICAgICAvLyBcImNvbnZlcnRlZFwiIHRvIHN0YXRpYyBkYXRhIHVzaW5nIDxMaW5rIHByZWZldGNoPXt0cnVlfT4uIFdoYXQgd2VcbiAgICAgICAgICAvLyBkbyBpbnN0ZWFkIGlzIHJlLXByZWZldGNoIGxpbmtzIGFuZCBmb3JtcyB3aGVuZXZlciB0aGUgY2FjaGUgaXNcbiAgICAgICAgICAvLyBpbnZhbGlkYXRlZC5cbiAgICAgICAgICBjcmVhdGVTZWVkZWRQcmVmZXRjaENhY2hlRW50cnkoe1xuICAgICAgICAgICAgdXJsOiByZWRpcmVjdExvY2F0aW9uLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBmbGlnaHREYXRhLFxuICAgICAgICAgICAgICBjYW5vbmljYWxVcmw6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgY291bGRCZUludGVyY2VwdGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgcHJlcmVuZGVyZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICBwb3N0cG9uZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAvLyBUT0RPOiBXZSBzaG91bGQgYmUgYWJsZSB0byBzZXQgdGhpcyBpZiB0aGUgc2VydmVyIGFjdGlvblxuICAgICAgICAgICAgICAvLyByZXR1cm5lZCBhIGZ1bGx5IHN0YXRpYyByZXNwb25zZS5cbiAgICAgICAgICAgICAgc3RhbGVUaW1lOiAtMSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cmVlOiBzdGF0ZS50cmVlLFxuICAgICAgICAgICAgcHJlZmV0Y2hDYWNoZTogc3RhdGUucHJlZmV0Y2hDYWNoZSxcbiAgICAgICAgICAgIG5leHRVcmw6IHN0YXRlLm5leHRVcmwsXG4gICAgICAgICAgICBraW5kOiBpc1ByZXJlbmRlciA/IFByZWZldGNoS2luZC5GVUxMIDogUHJlZmV0Y2hLaW5kLkFVVE8sXG4gICAgICAgICAgfSlcbiAgICAgICAgICBtdXRhYmxlLnByZWZldGNoQ2FjaGUgPSBzdGF0ZS5wcmVmZXRjaENhY2hlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgYWN0aW9uIHRyaWdnZXJlZCBhIHJlZGlyZWN0LCB0aGUgYWN0aW9uIHByb21pc2Ugd2lsbCBiZSByZWplY3RlZCB3aXRoXG4gICAgICAgIC8vIGEgcmVkaXJlY3Qgc28gdGhhdCBpdCdzIGhhbmRsZWQgYnkgUmVkaXJlY3RCb3VuZGFyeSBhcyB3ZSB3b24ndCBoYXZlIGEgdmFsaWRcbiAgICAgICAgLy8gYWN0aW9uIHJlc3VsdCB0byByZXNvbHZlIHRoZSBwcm9taXNlIHdpdGguIFRoaXMgd2lsbCBlZmZlY3RpdmVseSByZXNldCB0aGUgc3RhdGUgb2ZcbiAgICAgICAgLy8gdGhlIGNvbXBvbmVudCB0aGF0IGNhbGxlZCB0aGUgYWN0aW9uIGFzIHRoZSBlcnJvciBib3VuZGFyeSB3aWxsIHJlbW91bnQgdGhlIHRyZWUuXG4gICAgICAgIC8vIFRoZSBzdGF0dXMgY29kZSBkb2Vzbid0IG1hdHRlciBoZXJlIGFzIHRoZSBhY3Rpb24gaGFuZGxlciB3aWxsIGhhdmUgYWxyZWFkeSBzZW50XG4gICAgICAgIC8vIGEgcmVzcG9uc2Ugd2l0aCB0aGUgY29ycmVjdCBzdGF0dXMgY29kZS5cbiAgICAgICAgcmVqZWN0KFxuICAgICAgICAgIGdldFJlZGlyZWN0RXJyb3IoXG4gICAgICAgICAgICBoYXNCYXNlUGF0aChyZWRpcmVjdEhyZWYpXG4gICAgICAgICAgICAgID8gcmVtb3ZlQmFzZVBhdGgocmVkaXJlY3RIcmVmKVxuICAgICAgICAgICAgICA6IHJlZGlyZWN0SHJlZixcbiAgICAgICAgICAgIHJlZGlyZWN0VHlwZSB8fCBSZWRpcmVjdFR5cGUucHVzaFxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZShhY3Rpb25SZXN1bHQpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYW5kbGVNdXRhYmxlKHN0YXRlLCBtdXRhYmxlKVxuICAgIH0sXG4gICAgKGU6IGFueSkgPT4ge1xuICAgICAgLy8gV2hlbiB0aGUgc2VydmVyIGFjdGlvbiBpcyByZWplY3RlZCB3ZSBkb24ndCB1cGRhdGUgdGhlIHN0YXRlIGFuZCBpbnN0ZWFkIGNhbGwgdGhlIHJlamVjdCBoYW5kbGVyIG9mIHRoZSBwcm9taXNlLlxuICAgICAgcmVqZWN0KGUpXG5cbiAgICAgIHJldHVybiBzdGF0ZVxuICAgIH1cbiAgKVxufVxuIl0sIm5hbWVzIjpbInNlcnZlckFjdGlvblJlZHVjZXIiLCJjcmVhdGVGcm9tRmV0Y2giLCJjcmVhdGVGcm9tRmV0Y2hCcm93c2VyIiwiZmV0Y2hTZXJ2ZXJBY3Rpb24iLCJzdGF0ZSIsIm5leHRVcmwiLCJhY3Rpb25JZCIsImFjdGlvbkFyZ3MiLCJ0ZW1wb3JhcnlSZWZlcmVuY2VzIiwiY3JlYXRlVGVtcG9yYXJ5UmVmZXJlbmNlU2V0IiwiaW5mbyIsImV4dHJhY3RJbmZvRnJvbVNlcnZlclJlZmVyZW5jZUlkIiwidXNlZEFyZ3MiLCJ0eXBlIiwib21pdFVudXNlZEFyZ3MiLCJib2R5IiwiZW5jb2RlUmVwbHkiLCJyZXMiLCJmZXRjaCIsImNhbm9uaWNhbFVybCIsIm1ldGhvZCIsImhlYWRlcnMiLCJBY2NlcHQiLCJSU0NfQ09OVEVOVF9UWVBFX0hFQURFUiIsIkFDVElPTl9IRUFERVIiLCJORVhUX1JPVVRFUl9TVEFURV9UUkVFX0hFQURFUiIsInByZXBhcmVGbGlnaHRSb3V0ZXJTdGF0ZUZvclJlcXVlc3QiLCJ0cmVlIiwicHJvY2VzcyIsImVudiIsIk5FWFRfREVQTE9ZTUVOVF9JRCIsIk5FWFRfVVJMIiwidW5yZWNvZ25pemVkQWN0aW9uSGVhZGVyIiwiZ2V0IiwiTkVYVF9BQ1RJT05fTk9UX0ZPVU5EX0hFQURFUiIsIkVycm9yIiwicmVkaXJlY3RIZWFkZXIiLCJsb2NhdGlvbiIsIl9yZWRpcmVjdFR5cGUiLCJzcGxpdCIsInJlZGlyZWN0VHlwZSIsIlJlZGlyZWN0VHlwZSIsInB1c2giLCJyZXBsYWNlIiwidW5kZWZpbmVkIiwiaXNQcmVyZW5kZXIiLCJORVhUX0lTX1BSRVJFTkRFUl9IRUFERVIiLCJyZXZhbGlkYXRlZFBhcnRzIiwicmV2YWxpZGF0ZWRIZWFkZXIiLCJKU09OIiwicGFyc2UiLCJwYXRocyIsInRhZyIsImNvb2tpZSIsImUiLCJOT19SRVZBTElEQVRFRF9QQVJUUyIsInJlZGlyZWN0TG9jYXRpb24iLCJhc3NpZ25Mb2NhdGlvbiIsIlVSTCIsIndpbmRvdyIsImhyZWYiLCJjb250ZW50VHlwZSIsImlzUnNjUmVzcG9uc2UiLCJzdGFydHNXaXRoIiwibWVzc2FnZSIsInN0YXR1cyIsInRleHQiLCJhY3Rpb25SZXN1bHQiLCJhY3Rpb25GbGlnaHREYXRhIiwicmVzcG9uc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsImNhbGxTZXJ2ZXIiLCJmaW5kU291cmNlTWFwVVJMIiwiYSIsIm5vcm1hbGl6ZUZsaWdodERhdGEiLCJmIiwiYWN0aW9uIiwicmVqZWN0IiwibXV0YWJsZSIsImN1cnJlbnRUcmVlIiwicHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGUiLCJoYXNJbnRlcmNlcHRpb25Sb3V0ZUluQ3VycmVudFRyZWUiLCJuYXZpZ2F0ZWRBdCIsIkRhdGUiLCJub3ciLCJ0aGVuIiwiZmxpZ2h0RGF0YSIsInJlZGlyZWN0SHJlZiIsInB1c2hSZWYiLCJwZW5kaW5nUHVzaCIsImNyZWF0ZUhyZWZGcm9tVXJsIiwiaGFuZGxlRXh0ZXJuYWxVcmwiLCJhY3Rpb25SZXZhbGlkYXRlZCIsImxlbmd0aCIsIm5vcm1hbGl6ZWRGbGlnaHREYXRhIiwidHJlZVBhdGNoIiwic2VlZERhdGEiLCJjYWNoZU5vZGVTZWVkRGF0YSIsImhlYWQiLCJpc1Jvb3RSZW5kZXIiLCJjb25zb2xlIiwibG9nIiwibmV3VHJlZSIsImFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZSIsImhhbmRsZVNlZ21lbnRNaXNtYXRjaCIsImlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dCIsInJzYyIsImNhY2hlIiwiY3JlYXRlRW1wdHlDYWNoZU5vZGUiLCJwcmVmZXRjaFJzYyIsImxvYWRpbmciLCJmaWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZCIsIl9fTkVYVF9DTElFTlRfU0VHTUVOVF9DQUNIRSIsInJldmFsaWRhdGVFbnRpcmVDYWNoZSIsInByZWZldGNoQ2FjaGUiLCJNYXAiLCJyZWZyZXNoSW5hY3RpdmVQYXJhbGxlbFNlZ21lbnRzIiwidXBkYXRlZFRyZWUiLCJ1cGRhdGVkQ2FjaGUiLCJpbmNsdWRlTmV4dFVybCIsIkJvb2xlYW4iLCJwYXRjaGVkVHJlZSIsImNyZWF0ZVNlZWRlZFByZWZldGNoQ2FjaGVFbnRyeSIsInVybCIsImRhdGEiLCJjb3VsZEJlSW50ZXJjZXB0ZWQiLCJwcmVyZW5kZXJlZCIsInBvc3Rwb25lZCIsInN0YWxlVGltZSIsImtpbmQiLCJQcmVmZXRjaEtpbmQiLCJGVUxMIiwiQVVUTyIsImdldFJlZGlyZWN0RXJyb3IiLCJoYXNCYXNlUGF0aCIsInJlbW92ZUJhc2VQYXRoIiwiaGFuZGxlTXV0YWJsZSJdLCJtYXBwaW5ncyI6Ijs7OytCQW1OZ0JBLHVCQUFBQTs7O2VBQUFBOzs7K0JBL01XO3FDQUNNO2tDQVExQjt3QkFRQTtvQ0FRQTtnQ0FDd0I7bUNBQ0c7aUNBQ0E7NkNBQ1U7NkNBQ0E7K0JBRWQ7K0NBQ2dCOzJCQUNUO21EQUNhO3VDQUNaO2lEQUNVO21DQUt6QzswQkFDMEI7K0JBQ0o7b0NBQ2tCO2dDQUNoQjs2QkFDSDtxQ0FJckI7OEJBQytCO0FBRXRDLE1BQU1DLGtCQUNKQyxRQUFBQSxlQUFzQjtBQWV4QixlQUFlQyxrQkFDYkMsS0FBMkIsRUFDM0JDLE9BQXdDLEVBQ3hDLEtBQTRDO0lBQTVDLElBQUEsRUFBRUMsUUFBUSxFQUFFQyxVQUFVLEVBQXNCLEdBQTVDO0lBRUEsTUFBTUMsc0JBQXNCQyxDQUFBQSxHQUFBQSxRQUFBQSwyQkFBMkI7SUFDdkQsTUFBTUMsT0FBT0MsQ0FBQUEsR0FBQUEscUJBQUFBLGdDQUFnQyxFQUFDTDtJQUU5Qyw2RUFBNkU7SUFDN0UsOEVBQThFO0lBQzlFLCtDQUErQztJQUMvQyxNQUFNTSxXQUNKRixLQUFLRyxJQUFJLEtBQUssY0FBY0MsQ0FBQUEsR0FBQUEscUJBQUFBLGNBQWMsRUFBQ1AsWUFBWUcsUUFBUUg7SUFFakUsTUFBTVEsT0FBTyxNQUFNQyxDQUFBQSxHQUFBQSxRQUFBQSxXQUFXLEVBQUNKLFVBQVU7UUFBRUo7SUFBb0I7SUFFL0QsTUFBTVMsTUFBTSxNQUFNQyxNQUFNZCxNQUFNZSxZQUFZLEVBQUU7UUFDMUNDLFFBQVE7UUFDUkMsU0FBUztZQUNQQyxRQUFRQyxrQkFBQUEsdUJBQXVCO1lBQy9C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ZkEsY0FDSmhELGdCQUFnQkMsZUFBQUEsWUFBWSxDQUFDQyxJQUFJO1FBR3ZDLE9BQU87WUFDTDZCLFFBQVFKO1FBQ1Y7UUFFQSxPQUFPc0UsQ0FBQUEsR0FBQUEsZUFBQUEsYUFBYSxFQUFDckksT0FBTzJFO0lBQzlCLEdBQ0EsQ0FBQ3pCO1FBQ0MsbUhBQW1IO1FBQ25Id0IsT0FBT3hCO1FBRVAsT0FBT2xEO0lBQ1Q7QUFFSiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxMjIyNywgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yb3V0ZXItcmVkdWNlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBBQ1RJT05fTkFWSUdBVEUsXG4gIEFDVElPTl9TRVJWRVJfUEFUQ0gsXG4gIEFDVElPTl9SRVNUT1JFLFxuICBBQ1RJT05fUkVGUkVTSCxcbiAgQUNUSU9OX1BSRUZFVENILFxuICBBQ1RJT05fSE1SX1JFRlJFU0gsXG4gIEFDVElPTl9TRVJWRVJfQUNUSU9OLFxufSBmcm9tICcuL3JvdXRlci1yZWR1Y2VyLXR5cGVzJ1xuaW1wb3J0IHR5cGUge1xuICBSZWR1Y2VyQWN0aW9ucyxcbiAgUmVkdWNlclN0YXRlLFxuICBSZWFkb25seVJlZHVjZXJTdGF0ZSxcbn0gZnJvbSAnLi9yb3V0ZXItcmVkdWNlci10eXBlcydcbmltcG9ydCB7IG5hdmlnYXRlUmVkdWNlciB9IGZyb20gJy4vcmVkdWNlcnMvbmF2aWdhdGUtcmVkdWNlcidcbmltcG9ydCB7IHNlcnZlclBhdGNoUmVkdWNlciB9IGZyb20gJy4vcmVkdWNlcnMvc2VydmVyLXBhdGNoLXJlZHVjZXInXG5pbXBvcnQgeyByZXN0b3JlUmVkdWNlciB9IGZyb20gJy4vcmVkdWNlcnMvcmVzdG9yZS1yZWR1Y2VyJ1xuaW1wb3J0IHsgcmVmcmVzaFJlZHVjZXIgfSBmcm9tICcuL3JlZHVjZXJzL3JlZnJlc2gtcmVkdWNlcidcbmltcG9ydCB7IHByZWZldGNoUmVkdWNlciB9IGZyb20gJy4vcmVkdWNlcnMvcHJlZmV0Y2gtcmVkdWNlcidcbmltcG9ydCB7IGhtclJlZnJlc2hSZWR1Y2VyIH0gZnJvbSAnLi9yZWR1Y2Vycy9obXItcmVmcmVzaC1yZWR1Y2VyJ1xuaW1wb3J0IHsgc2VydmVyQWN0aW9uUmVkdWNlciB9IGZyb20gJy4vcmVkdWNlcnMvc2VydmVyLWFjdGlvbi1yZWR1Y2VyJ1xuXG4vKipcbiAqIFJlZHVjZXIgdGhhdCBoYW5kbGVzIHRoZSBhcHAtcm91dGVyIHN0YXRlIHVwZGF0ZXMuXG4gKi9cbmZ1bmN0aW9uIGNsaWVudFJlZHVjZXIoXG4gIHN0YXRlOiBSZWFkb25seVJlZHVjZXJTdGF0ZSxcbiAgYWN0aW9uOiBSZWR1Y2VyQWN0aW9uc1xuKTogUmVkdWNlclN0YXRlIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgQUNUSU9OX05BVklHQVRFOiB7XG4gICAgICByZXR1cm4gbmF2aWdhdGVSZWR1Y2VyKHN0YXRlLCBhY3Rpb24pXG4gICAgfVxuICAgIGNhc2UgQUNUSU9OX1NFUlZFUl9QQVRDSDoge1xuICAgICAgcmV0dXJuIHNlcnZlclBhdGNoUmVkdWNlcihzdGF0ZSwgYWN0aW9uKVxuICAgIH1cbiAgICBjYXNlIEFDVElPTl9SRVNUT1JFOiB7XG4gICAgICByZXR1cm4gcmVzdG9yZVJlZHVjZXIoc3RhdGUsIGFjdGlvbilcbiAgICB9XG4gICAgY2FzZSBBQ1RJT05fUkVGUkVTSDoge1xuICAgICAgcmV0dXJuIHJlZnJlc2hSZWR1Y2VyKHN0YXRlLCBhY3Rpb24pXG4gICAgfVxuICAgIGNhc2UgQUNUSU9OX0hNUl9SRUZSRVNIOiB7XG4gICAgICByZXR1cm4gaG1yUmVmcmVzaFJlZHVjZXIoc3RhdGUsIGFjdGlvbilcbiAgICB9XG4gICAgY2FzZSBBQ1RJT05fUFJFRkVUQ0g6IHtcbiAgICAgIHJldHVybiBwcmVmZXRjaFJlZHVjZXIoc3RhdGUsIGFjdGlvbilcbiAgICB9XG4gICAgY2FzZSBBQ1RJT05fU0VSVkVSX0FDVElPTjoge1xuICAgICAgcmV0dXJuIHNlcnZlckFjdGlvblJlZHVjZXIoc3RhdGUsIGFjdGlvbilcbiAgICB9XG4gICAgLy8gVGhpcyBjYXNlIHNob3VsZCBuZXZlciBiZSBoaXQgYXMgZGlzcGF0Y2ggaXMgc3Ryb25nbHkgdHlwZWQuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBhY3Rpb24nKVxuICB9XG59XG5cbmZ1bmN0aW9uIHNlcnZlclJlZHVjZXIoXG4gIHN0YXRlOiBSZWFkb25seVJlZHVjZXJTdGF0ZSxcbiAgX2FjdGlvbjogUmVkdWNlckFjdGlvbnNcbik6IFJlZHVjZXJTdGF0ZSB7XG4gIHJldHVybiBzdGF0ZVxufVxuXG4vLyB3ZSBkb24ndCBydW4gdGhlIGNsaWVudCByZWR1Y2VyIG9uIHRoZSBzZXJ2ZXIsIHNvIHdlIHVzZSBhIG5vb3AgZnVuY3Rpb24gZm9yIGJldHRlciB0cmVlIHNoYWtpbmdcbmV4cG9ydCBjb25zdCByZWR1Y2VyID1cbiAgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBzZXJ2ZXJSZWR1Y2VyIDogY2xpZW50UmVkdWNlclxuIl0sIm5hbWVzIjpbInJlZHVjZXIiLCJjbGllbnRSZWR1Y2VyIiwic3RhdGUiLCJhY3Rpb24iLCJ0eXBlIiwiQUNUSU9OX05BVklHQVRFIiwibmF2aWdhdGVSZWR1Y2VyIiwiQUNUSU9OX1NFUlZFUl9QQVRDSCIsInNlcnZlclBhdGNoUmVkdWNlciIsIkFDVElPTl9SRVNUT1JFIiwicmVzdG9yZVJlZHVjZXIiLCJBQ1RJT05fUkVGUkVTSCIsInJlZnJlc2hSZWR1Y2VyIiwiQUNUSU9OX0hNUl9SRUZSRVNIIiwiaG1yUmVmcmVzaFJlZHVjZXIiLCJBQ1RJT05fUFJFRkVUQ0giLCJwcmVmZXRjaFJlZHVjZXIiLCJBQ1RJT05fU0VSVkVSX0FDVElPTiIsInNlcnZlckFjdGlvblJlZHVjZXIiLCJFcnJvciIsInNlcnZlclJlZHVjZXIiLCJfYWN0aW9uIiwid2luZG93Il0sIm1hcHBpbmdzIjoiOzs7K0JBaUVhQSxXQUFBQTs7O2VBQUFBOzs7b0NBekROO2lDQU15QjtvQ0FDRztnQ0FDSjtnQ0FDQTtpQ0FDQzttQ0FDRTtxQ0FDRTtBQUVwQzs7Q0FFQyxHQUNELFNBQVNDLGNBQ1BDLEtBQTJCLEVBQzNCQyxNQUFzQjtJQUV0QixPQUFRQSxPQUFPQyxJQUFJO1FBQ2pCLEtBQUtDLG9CQUFBQSxlQUFlO1lBQUU7Z0JBQ3BCLE9BQU9DLENBQUFBLEdBQUFBLGlCQUFBQSxlQUFlLEVBQUNKLE9BQU9DO1lBQ2hDO1FBQ0EsS0FBS0ksb0JBQUFBLG1CQUFtQjtZQUFFO2dCQUN4QixPQUFPQyxDQUFBQSxHQUFBQSxvQkFBQUEsa0JBQWtCLEVBQUNOLE9BQU9DO1lBQ25DO1FBQ0EsS0FBS00sb0JBQUFBLGNBQWM7WUFBRTtnQkFDbkIsT0FBT0MsQ0FBQUEsR0FBQUEsZ0JBQUFBLGNBQWMsRUFBQ1IsT0FBT0M7WUFDL0I7UUFDQSxLQUFLUSxvQkFBQUEsY0FBYztZQUFFO2dCQUNuQixPQUFPQyxDQUFBQSxHQUFBQSxnQkFBQUEsY0FBYyxFQUFDVixPQUFPQztZQUMvQjtRQUNBLEtBQUtVLG9CQUFBQSxrQkFBa0I7WUFBRTtnQkFDdkIsT0FBT0MsQ0FBQUEsR0FBQUEsbUJBQUFBLGlCQUFpQixFQUFDWixPQUFPQztZQUNsQztRQUNBLEtBQUtZLG9CQUFBQSxlQUFlO1lBQUU7Z0JBQ3BCLE9BQU9DLENBQUFBLEdBQUFBLGlCQUFBQSxlQUFlLEVBQUNkLE9BQU9DO1lBQ2hDO1FBQ0EsS0FBS2Msb0JBQUFBLG9CQUFvQjtZQUFFO2dCQUN6QixPQUFPQyxDQUFBQSxHQUFBQSxxQkFBQUEsbUJBQW1CLEVBQUNoQixPQUFPQztZQUNwQztRQUNBLCtEQUErRDtRQUMvRDtZQUNFLE1BQU0sT0FBQSxjQUEyQixDQUEzQixJQUFJZ0IsTUFBTSxtQkFBVixxQkFBQTt1QkFBQTs0QkFBQTs4QkFBQTtZQUEwQjtJQUNwQztBQUNGO0FBRUEsU0FBU0MsY0FDUGxCLEtBQTJCLEVBQzNCbUIsT0FBdUI7SUFFdkIsT0FBT25CO0FBQ1Q7QUFHTyxNQUFNRixVQUNYLE9BQU9zQixXQUFXLHFCQUFjRixnQkFBZ0JuQiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxMjMwMiwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvY29tcG9uZW50cy9hcHAtcm91dGVyLWluc3RhbmNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIHR5cGUgQXBwUm91dGVyU3RhdGUsXG4gIHR5cGUgUmVkdWNlckFjdGlvbnMsXG4gIHR5cGUgUmVkdWNlclN0YXRlLFxuICBBQ1RJT05fUkVGUkVTSCxcbiAgQUNUSU9OX1NFUlZFUl9BQ1RJT04sXG4gIEFDVElPTl9OQVZJR0FURSxcbiAgQUNUSU9OX1JFU1RPUkUsXG4gIHR5cGUgTmF2aWdhdGVBY3Rpb24sXG4gIEFDVElPTl9ITVJfUkVGUkVTSCxcbiAgUHJlZmV0Y2hLaW5kLFxuICBBQ1RJT05fUFJFRkVUQ0gsXG59IGZyb20gJy4vcm91dGVyLXJlZHVjZXIvcm91dGVyLXJlZHVjZXItdHlwZXMnXG5pbXBvcnQgeyByZWR1Y2VyIH0gZnJvbSAnLi9yb3V0ZXItcmVkdWNlci9yb3V0ZXItcmVkdWNlcidcbmltcG9ydCB7IHN0YXJ0VHJhbnNpdGlvbiB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgaXNUaGVuYWJsZSB9IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvaXMtdGhlbmFibGUnXG5pbXBvcnQgeyBwcmVmZXRjaCBhcyBwcmVmZXRjaFdpdGhTZWdtZW50Q2FjaGUgfSBmcm9tICcuL3NlZ21lbnQtY2FjaGUnXG5pbXBvcnQgeyBkaXNwYXRjaEFwcFJvdXRlckFjdGlvbiB9IGZyb20gJy4vdXNlLWFjdGlvbi1xdWV1ZSdcbmltcG9ydCB7IGFkZEJhc2VQYXRoIH0gZnJvbSAnLi4vYWRkLWJhc2UtcGF0aCdcbmltcG9ydCB7IGNyZWF0ZVByZWZldGNoVVJMLCBpc0V4dGVybmFsVVJMIH0gZnJvbSAnLi9hcHAtcm91dGVyJ1xuaW1wb3J0IHsgcHJlZmV0Y2hSZWR1Y2VyIH0gZnJvbSAnLi9yb3V0ZXItcmVkdWNlci9yZWR1Y2Vycy9wcmVmZXRjaC1yZWR1Y2VyJ1xuaW1wb3J0IHR5cGUge1xuICBBcHBSb3V0ZXJJbnN0YW5jZSxcbiAgTmF2aWdhdGVPcHRpb25zLFxuICBQcmVmZXRjaE9wdGlvbnMsXG59IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHsgc2V0TGlua0ZvckN1cnJlbnROYXZpZ2F0aW9uLCB0eXBlIExpbmtJbnN0YW5jZSB9IGZyb20gJy4vbGlua3MnXG5pbXBvcnQgdHlwZSB7IEZsaWdodFJvdXRlclN0YXRlIH0gZnJvbSAnLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvdHlwZXMnXG5pbXBvcnQgdHlwZSB7IENsaWVudEluc3RydW1lbnRhdGlvbkhvb2tzIH0gZnJvbSAnLi4vYXBwLWluZGV4J1xuaW1wb3J0IHR5cGUgeyBHbG9iYWxFcnJvckNvbXBvbmVudCB9IGZyb20gJy4vYnVpbHRpbi9nbG9iYWwtZXJyb3InXG5cbmV4cG9ydCB0eXBlIERpc3BhdGNoU3RhdGVQcm9taXNlID0gUmVhY3QuRGlzcGF0Y2g8UmVkdWNlclN0YXRlPlxuXG5leHBvcnQgdHlwZSBBcHBSb3V0ZXJBY3Rpb25RdWV1ZSA9IHtcbiAgc3RhdGU6IEFwcFJvdXRlclN0YXRlXG4gIGRpc3BhdGNoOiAocGF5bG9hZDogUmVkdWNlckFjdGlvbnMsIHNldFN0YXRlOiBEaXNwYXRjaFN0YXRlUHJvbWlzZSkgPT4gdm9pZFxuICBhY3Rpb246IChzdGF0ZTogQXBwUm91dGVyU3RhdGUsIGFjdGlvbjogUmVkdWNlckFjdGlvbnMpID0+IFJlZHVjZXJTdGF0ZVxuXG4gIG9uUm91dGVyVHJhbnNpdGlvblN0YXJ0OlxuICAgIHwgKCh1cmw6IHN0cmluZywgdHlwZTogJ3B1c2gnIHwgJ3JlcGxhY2UnIHwgJ3RyYXZlcnNlJykgPT4gdm9pZClcbiAgICB8IG51bGxcblxuICBwZW5kaW5nOiBBY3Rpb25RdWV1ZU5vZGUgfCBudWxsXG4gIG5lZWRzUmVmcmVzaD86IGJvb2xlYW5cbiAgbGFzdDogQWN0aW9uUXVldWVOb2RlIHwgbnVsbFxufVxuXG5leHBvcnQgdHlwZSBHbG9iYWxFcnJvclN0YXRlID0gW1xuICBHbG9iYWxFcnJvcjogR2xvYmFsRXJyb3JDb21wb25lbnQsXG4gIHN0eWxlczogUmVhY3QuUmVhY3ROb2RlLFxuXVxuXG5leHBvcnQgdHlwZSBBY3Rpb25RdWV1ZU5vZGUgPSB7XG4gIHBheWxvYWQ6IFJlZHVjZXJBY3Rpb25zXG4gIG5leHQ6IEFjdGlvblF1ZXVlTm9kZSB8IG51bGxcbiAgcmVzb2x2ZTogKHZhbHVlOiBSZWR1Y2VyU3RhdGUpID0+IHZvaWRcbiAgcmVqZWN0OiAoZXJyOiBFcnJvcikgPT4gdm9pZFxuICBkaXNjYXJkZWQ/OiBib29sZWFuXG59XG5cbmZ1bmN0aW9uIHJ1blJlbWFpbmluZ0FjdGlvbnMoXG4gIGFjdGlvblF1ZXVlOiBBcHBSb3V0ZXJBY3Rpb25RdWV1ZSxcbiAgc2V0U3RhdGU6IERpc3BhdGNoU3RhdGVQcm9taXNlXG4pIHtcbiAgaWYgKGFjdGlvblF1ZXVlLnBlbmRpbmcgIT09IG51bGwpIHtcbiAgICBhY3Rpb25RdWV1ZS5wZW5kaW5nID0gYWN0aW9uUXVldWUucGVuZGluZy5uZXh0XG4gICAgaWYgKGFjdGlvblF1ZXVlLnBlbmRpbmcgIT09IG51bGwpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgIHJ1bkFjdGlvbih7XG4gICAgICAgIGFjdGlvblF1ZXVlLFxuICAgICAgICBhY3Rpb246IGFjdGlvblF1ZXVlLnBlbmRpbmcsXG4gICAgICAgIHNldFN0YXRlLFxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm8gbW9yZSBhY3Rpb25zIGFyZSBwZW5kaW5nLCBjaGVjayBpZiBhIHJlZnJlc2ggaXMgbmVlZGVkXG4gICAgICBpZiAoYWN0aW9uUXVldWUubmVlZHNSZWZyZXNoKSB7XG4gICAgICAgIGFjdGlvblF1ZXVlLm5lZWRzUmVmcmVzaCA9IGZhbHNlXG4gICAgICAgIGFjdGlvblF1ZXVlLmRpc3BhdGNoKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6IEFDVElPTl9SRUZSRVNILFxuICAgICAgICAgICAgb3JpZ2luOiB3aW5kb3cubG9jYXRpb24ub3JpZ2luLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0U3RhdGVcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBydW5BY3Rpb24oe1xuICBhY3Rpb25RdWV1ZSxcbiAgYWN0aW9uLFxuICBzZXRTdGF0ZSxcbn06IHtcbiAgYWN0aW9uUXVldWU6IEFwcFJvdXRlckFjdGlvblF1ZXVlXG4gIGFjdGlvbjogQWN0aW9uUXVldWVOb2RlXG4gIHNldFN0YXRlOiBEaXNwYXRjaFN0YXRlUHJvbWlzZVxufSkge1xuICBjb25zdCBwcmV2U3RhdGUgPSBhY3Rpb25RdWV1ZS5zdGF0ZVxuXG4gIGFjdGlvblF1ZXVlLnBlbmRpbmcgPSBhY3Rpb25cblxuICBjb25zdCBwYXlsb2FkID0gYWN0aW9uLnBheWxvYWRcbiAgY29uc3QgYWN0aW9uUmVzdWx0ID0gYWN0aW9uUXVldWUuYWN0aW9uKHByZXZTdGF0ZSwgcGF5bG9hZClcblxuICBmdW5jdGlvbiBoYW5kbGVSZXN1bHQobmV4dFN0YXRlOiBBcHBSb3V0ZXJTdGF0ZSkge1xuICAgIC8vIGlmIHdlIGRpc2NhcmRlZCB0aGlzIGFjdGlvbiwgdGhlIHN0YXRlIHNob3VsZCBhbHNvIGJlIGRpc2NhcmRlZFxuICAgIGlmIChhY3Rpb24uZGlzY2FyZGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBhY3Rpb25RdWV1ZS5zdGF0ZSA9IG5leHRTdGF0ZVxuXG4gICAgcnVuUmVtYWluaW5nQWN0aW9ucyhhY3Rpb25RdWV1ZSwgc2V0U3RhdGUpXG4gICAgYWN0aW9uLnJlc29sdmUobmV4dFN0YXRlKVxuICB9XG5cbiAgLy8gaWYgdGhlIGFjdGlvbiBpcyBhIHByb21pc2UsIHNldCB1cCBhIGNhbGxiYWNrIHRvIHJlc29sdmUgaXRcbiAgaWYgKGlzVGhlbmFibGUoYWN0aW9uUmVzdWx0KSkge1xuICAgIGFjdGlvblJlc3VsdC50aGVuKGhhbmRsZVJlc3VsdCwgKGVycikgPT4ge1xuICAgICAgcnVuUmVtYWluaW5nQWN0aW9ucyhhY3Rpb25RdWV1ZSwgc2V0U3RhdGUpXG4gICAgICBhY3Rpb24ucmVqZWN0KGVycilcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIGhhbmRsZVJlc3VsdChhY3Rpb25SZXN1bHQpXG4gIH1cbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hBY3Rpb24oXG4gIGFjdGlvblF1ZXVlOiBBcHBSb3V0ZXJBY3Rpb25RdWV1ZSxcbiAgcGF5bG9hZDogUmVkdWNlckFjdGlvbnMsXG4gIHNldFN0YXRlOiBEaXNwYXRjaFN0YXRlUHJvbWlzZVxuKSB7XG4gIGxldCByZXNvbHZlcnM6IHtcbiAgICByZXNvbHZlOiAodmFsdWU6IFJlZHVjZXJTdGF0ZSkgPT4gdm9pZFxuICAgIHJlamVjdDogKHJlYXNvbjogYW55KSA9PiB2b2lkXG4gIH0gPSB7IHJlc29sdmU6IHNldFN0YXRlLCByZWplY3Q6ICgpID0+IHt9IH1cblxuICAvLyBtb3N0IG9mIHRoZSBhY3Rpb24gdHlwZXMgYXJlIGFzeW5jIHdpdGggdGhlIGV4Y2VwdGlvbiBvZiByZXN0b3JlXG4gIC8vIGl0J3MgaW1wb3J0YW50IHRoYXQgcmVzdG9yZSBpcyBoYW5kbGVkIHF1aWNrbHkgc2luY2UgaXQncyBmaXJlZCBvbiB0aGUgcG9wc3RhdGUgZXZlbnRcbiAgLy8gYW5kIHdlIGRvbid0IHdhbnQgdG8gYWRkIGFueSBkZWxheSBvbiBhIGJhY2svZm9yd2FyZCBuYXZcbiAgLy8gdGhpcyBvbmx5IGNyZWF0ZXMgYSBwcm9taXNlIGZvciB0aGUgYXN5bmMgYWN0aW9uc1xuICBpZiAocGF5bG9hZC50eXBlICE9PSBBQ1RJT05fUkVTVE9SRSkge1xuICAgIC8vIENyZWF0ZSB0aGUgcHJvbWlzZSBhbmQgYXNzaWduIHRoZSByZXNvbHZlcnMgdG8gdGhlIG9iamVjdC5cbiAgICBjb25zdCBkZWZlcnJlZFByb21pc2UgPSBuZXcgUHJvbWlzZTxBcHBSb3V0ZXJTdGF0ZT4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgcmVzb2x2ZXJzID0geyByZXNvbHZlLCByZWplY3QgfVxuICAgIH0pXG5cbiAgICBzdGFydFRyYW5zaXRpb24oKCkgPT4ge1xuICAgICAgLy8gd2UgaW1tZWRpYXRlbHkgbm90aWZ5IFJlYWN0IG9mIHRoZSBwZW5kaW5nIHByb21pc2UgLS0gdGhlIHJlc29sdmVyIGlzIGF0dGFjaGVkIHRvIHRoZSBhY3Rpb24gbm9kZVxuICAgICAgLy8gYW5kIHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIGFzc29jaWF0ZWQgYWN0aW9uIHByb21pc2UgcmVzb2x2ZXNcbiAgICAgIHNldFN0YXRlKGRlZmVycmVkUHJvbWlzZSlcbiAgICB9KVxuICB9XG5cbiAgY29uc3QgbmV3QWN0aW9uOiBBY3Rpb25RdWV1ZU5vZGUgPSB7XG4gICAgcGF5bG9hZCxcbiAgICBuZXh0OiBudWxsLFxuICAgIHJlc29sdmU6IHJlc29sdmVycy5yZXNvbHZlLFxuICAgIHJlamVjdDogcmVzb2x2ZXJzLnJlamVjdCxcbiAgfVxuXG4gIC8vIENoZWNrIGlmIHRoZSBxdWV1ZSBpcyBlbXB0eVxuICBpZiAoYWN0aW9uUXVldWUucGVuZGluZyA9PT0gbnVsbCkge1xuICAgIC8vIFRoZSBxdWV1ZSBpcyBlbXB0eSwgc28gYWRkIHRoZSBhY3Rpb24gYW5kIHN0YXJ0IGl0IGltbWVkaWF0ZWx5XG4gICAgLy8gTWFyayB0aGlzIGFjdGlvbiBhcyB0aGUgbGFzdCBpbiB0aGUgcXVldWVcbiAgICBhY3Rpb25RdWV1ZS5sYXN0ID0gbmV3QWN0aW9uXG5cbiAgICBydW5BY3Rpb24oe1xuICAgICAgYWN0aW9uUXVldWUsXG4gICAgICBhY3Rpb246IG5ld0FjdGlvbixcbiAgICAgIHNldFN0YXRlLFxuICAgIH0pXG4gIH0gZWxzZSBpZiAoXG4gICAgcGF5bG9hZC50eXBlID09PSBBQ1RJT05fTkFWSUdBVEUgfHxcbiAgICBwYXlsb2FkLnR5cGUgPT09IEFDVElPTl9SRVNUT1JFXG4gICkge1xuICAgIC8vIE5hdmlnYXRpb25zIChpbmNsdWRpbmcgYmFjay9mb3J3YXJkKSB0YWtlIHByaW9yaXR5IG92ZXIgYW55IHBlbmRpbmcgYWN0aW9ucy5cbiAgICAvLyBNYXJrIHRoZSBwZW5kaW5nIGFjdGlvbiBhcyBkaXNjYXJkZWQgKHNvIHRoZSBzdGF0ZSBpcyBuZXZlciBhcHBsaWVkKSBhbmQgc3RhcnQgdGhlIG5hdmlnYXRpb24gYWN0aW9uIGltbWVkaWF0ZWx5LlxuICAgIGFjdGlvblF1ZXVlLnBlbmRpbmcuZGlzY2FyZGVkID0gdHJ1ZVxuXG4gICAgLy8gVGhlIHJlc3Qgb2YgdGhlIGN1cnJlbnQgcXVldWUgc2hvdWxkIHN0aWxsIGV4ZWN1dGUgYWZ0ZXIgdGhpcyBuYXZpZ2F0aW9uLlxuICAgIC8vIChOb3RlIHRoYXQgaXQgY2FuJ3QgY29udGFpbiBhbnkgZWFybGllciBuYXZpZ2F0aW9ucywgYmVjYXVzZSB3ZSBhbHdheXMgcHV0IHRob3NlIGludG8gYGFjdGlvblF1ZXVlLnBlbmRpbmdgIGJ5IGNhbGxpbmcgYHJ1bkFjdGlvbmApXG4gICAgbmV3QWN0aW9uLm5leHQgPSBhY3Rpb25RdWV1ZS5wZW5kaW5nLm5leHRcblxuICAgIC8vIGlmIHRoZSBwZW5kaW5nIGFjdGlvbiB3YXMgYSBzZXJ2ZXIgYWN0aW9uLCBtYXJrIHRoZSBxdWV1ZSBhcyBuZWVkaW5nIGEgcmVmcmVzaCBvbmNlIGV2ZW50cyBhcmUgcHJvY2Vzc2VkXG4gICAgaWYgKGFjdGlvblF1ZXVlLnBlbmRpbmcucGF5bG9hZC50eXBlID09PSBBQ1RJT05fU0VSVkVSX0FDVElPTikge1xuICAgICAgYWN0aW9uUXVldWUubmVlZHNSZWZyZXNoID0gdHJ1ZVxuICAgIH1cblxuICAgIHJ1bkFjdGlvbih7XG4gICAgICBhY3Rpb25RdWV1ZSxcbiAgICAgIGFjdGlvbjogbmV3QWN0aW9uLFxuICAgICAgc2V0U3RhdGUsXG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGUgcXVldWUgaXMgbm90IGVtcHR5LCBzbyBhZGQgdGhlIGFjdGlvbiB0byB0aGUgZW5kIG9mIHRoZSBxdWV1ZVxuICAgIC8vIEl0IHdpbGwgYmUgc3RhcnRlZCBieSBydW5SZW1haW5pbmdBY3Rpb25zIGFmdGVyIHRoZSBwcmV2aW91cyBhY3Rpb24gZmluaXNoZXNcbiAgICBpZiAoYWN0aW9uUXVldWUubGFzdCAhPT0gbnVsbCkge1xuICAgICAgYWN0aW9uUXVldWUubGFzdC5uZXh0ID0gbmV3QWN0aW9uXG4gICAgfVxuICAgIGFjdGlvblF1ZXVlLmxhc3QgPSBuZXdBY3Rpb25cbiAgfVxufVxuXG5sZXQgZ2xvYmFsQWN0aW9uUXVldWU6IEFwcFJvdXRlckFjdGlvblF1ZXVlIHwgbnVsbCA9IG51bGxcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU11dGFibGVBY3Rpb25RdWV1ZShcbiAgaW5pdGlhbFN0YXRlOiBBcHBSb3V0ZXJTdGF0ZSxcbiAgaW5zdHJ1bWVudGF0aW9uSG9va3M6IENsaWVudEluc3RydW1lbnRhdGlvbkhvb2tzIHwgbnVsbFxuKTogQXBwUm91dGVyQWN0aW9uUXVldWUge1xuICBjb25zdCBhY3Rpb25RdWV1ZTogQXBwUm91dGVyQWN0aW9uUXVldWUgPSB7XG4gICAgc3RhdGU6IGluaXRpYWxTdGF0ZSxcbiAgICBkaXNwYXRjaDogKHBheWxvYWQ6IFJlZHVjZXJBY3Rpb25zLCBzZXRTdGF0ZTogRGlzcGF0Y2hTdGF0ZVByb21pc2UpID0+XG4gICAgICBkaXNwYXRjaEFjdGlvbihhY3Rpb25RdWV1ZSwgcGF5bG9hZCwgc2V0U3RhdGUpLFxuICAgIGFjdGlvbjogYXN5bmMgKHN0YXRlOiBBcHBSb3V0ZXJTdGF0ZSwgYWN0aW9uOiBSZWR1Y2VyQWN0aW9ucykgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gcmVkdWNlcihzdGF0ZSwgYWN0aW9uKVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH0sXG4gICAgcGVuZGluZzogbnVsbCxcbiAgICBsYXN0OiBudWxsLFxuICAgIG9uUm91dGVyVHJhbnNpdGlvblN0YXJ0OlxuICAgICAgaW5zdHJ1bWVudGF0aW9uSG9va3MgIT09IG51bGwgJiZcbiAgICAgIHR5cGVvZiBpbnN0cnVtZW50YXRpb25Ib29rcy5vblJvdXRlclRyYW5zaXRpb25TdGFydCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IC8vIFRoaXMgcHJvZmlsaW5nIGhvb2sgd2lsbCBiZSBjYWxsZWQgYXQgdGhlIHN0YXJ0IG9mIGV2ZXJ5IG5hdmlnYXRpb24uXG4gICAgICAgICAgaW5zdHJ1bWVudGF0aW9uSG9va3Mub25Sb3V0ZXJUcmFuc2l0aW9uU3RhcnRcbiAgICAgICAgOiBudWxsLFxuICB9XG5cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gVGhlIGFjdGlvbiBxdWV1ZSBpcyBsYXppbHkgY3JlYXRlZCBvbiBoeWRyYXRpb24sIGJ1dCBhZnRlciB0aGF0IHBvaW50XG4gICAgLy8gaXQgZG9lc24ndCBjaGFuZ2UuIFNvIHdlIGNhbiBzdG9yZSBpdCBpbiBhIGdsb2JhbCByYXRoZXIgdGhhbiBwYXNzXG4gICAgLy8gaXQgYXJvdW5kIGV2ZXJ5d2hlcmUgdmlhIHByb3BzL2NvbnRleHQuXG4gICAgaWYgKGdsb2JhbEFjdGlvblF1ZXVlICE9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJbnRlcm5hbCBOZXh0LmpzIEVycm9yOiBjcmVhdGVNdXRhYmxlQWN0aW9uUXVldWUgd2FzIGNhbGxlZCBtb3JlICcgK1xuICAgICAgICAgICd0aGFuIG9uY2UnXG4gICAgICApXG4gICAgfVxuICAgIGdsb2JhbEFjdGlvblF1ZXVlID0gYWN0aW9uUXVldWVcbiAgfVxuXG4gIHJldHVybiBhY3Rpb25RdWV1ZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3VycmVudEFwcFJvdXRlclN0YXRlKCk6IEFwcFJvdXRlclN0YXRlIHwgbnVsbCB7XG4gIHJldHVybiBnbG9iYWxBY3Rpb25RdWV1ZSAhPT0gbnVsbCA/IGdsb2JhbEFjdGlvblF1ZXVlLnN0YXRlIDogbnVsbFxufVxuXG5mdW5jdGlvbiBnZXRBcHBSb3V0ZXJBY3Rpb25RdWV1ZSgpOiBBcHBSb3V0ZXJBY3Rpb25RdWV1ZSB7XG4gIGlmIChnbG9iYWxBY3Rpb25RdWV1ZSA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdJbnRlcm5hbCBOZXh0LmpzIGVycm9yOiBSb3V0ZXIgYWN0aW9uIGRpc3BhdGNoZWQgYmVmb3JlIGluaXRpYWxpemF0aW9uLidcbiAgICApXG4gIH1cbiAgcmV0dXJuIGdsb2JhbEFjdGlvblF1ZXVlXG59XG5cbmZ1bmN0aW9uIGdldFByb2ZpbGluZ0hvb2tGb3JPbk5hdmlnYXRpb25TdGFydCgpIHtcbiAgaWYgKGdsb2JhbEFjdGlvblF1ZXVlICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIGdsb2JhbEFjdGlvblF1ZXVlLm9uUm91dGVyVHJhbnNpdGlvblN0YXJ0XG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpc3BhdGNoTmF2aWdhdGVBY3Rpb24oXG4gIGhyZWY6IHN0cmluZyxcbiAgbmF2aWdhdGVUeXBlOiBOYXZpZ2F0ZUFjdGlvblsnbmF2aWdhdGVUeXBlJ10sXG4gIHNob3VsZFNjcm9sbDogYm9vbGVhbixcbiAgbGlua0luc3RhbmNlUmVmOiBMaW5rSW5zdGFuY2UgfCBudWxsXG4pOiB2b2lkIHtcbiAgLy8gVE9ETzogVGhpcyBzdHVmZiBjb3VsZCBqdXN0IGdvIGludG8gdGhlIHJlZHVjZXIuIExlYXZpbmcgYXMtaXMgZm9yIG5vd1xuICAvLyBzaW5jZSB3ZSdyZSBhYm91dCB0byByZXdyaXRlIGFsbCB0aGUgcm91dGVyIHJlZHVjZXIgc3R1ZmYgYW55d2F5LlxuICBjb25zdCB1cmwgPSBuZXcgVVJMKGFkZEJhc2VQYXRoKGhyZWYpLCBsb2NhdGlvbi5ocmVmKVxuICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0FQUF9OQVZfRkFJTF9IQU5ETElORykge1xuICAgIHdpbmRvdy5uZXh0Ll9fcGVuZGluZ1VybCA9IHVybFxuICB9XG5cbiAgc2V0TGlua0ZvckN1cnJlbnROYXZpZ2F0aW9uKGxpbmtJbnN0YW5jZVJlZilcblxuICBjb25zdCBvblJvdXRlclRyYW5zaXRpb25TdGFydCA9IGdldFByb2ZpbGluZ0hvb2tGb3JPbk5hdmlnYXRpb25TdGFydCgpXG4gIGlmIChvblJvdXRlclRyYW5zaXRpb25TdGFydCAhPT0gbnVsbCkge1xuICAgIG9uUm91dGVyVHJhbnNpdGlvblN0YXJ0KGhyZWYsIG5hdmlnYXRlVHlwZSlcbiAgfVxuXG4gIGRpc3BhdGNoQXBwUm91dGVyQWN0aW9uKHtcbiAgICB0eXBlOiBBQ1RJT05fTkFWSUdBVEUsXG4gICAgdXJsLFxuICAgIGlzRXh0ZXJuYWxVcmw6IGlzRXh0ZXJuYWxVUkwodXJsKSxcbiAgICBsb2NhdGlvblNlYXJjaDogbG9jYXRpb24uc2VhcmNoLFxuICAgIHNob3VsZFNjcm9sbCxcbiAgICBuYXZpZ2F0ZVR5cGUsXG4gICAgYWxsb3dBbGlhc2luZzogdHJ1ZSxcbiAgfSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpc3BhdGNoVHJhdmVyc2VBY3Rpb24oXG4gIGhyZWY6IHN0cmluZyxcbiAgdHJlZTogRmxpZ2h0Um91dGVyU3RhdGUgfCB1bmRlZmluZWRcbikge1xuICBjb25zdCBvblJvdXRlclRyYW5zaXRpb25TdGFydCA9IGdldFByb2ZpbGluZ0hvb2tGb3JPbk5hdmlnYXRpb25TdGFydCgpXG4gIGlmIChvblJvdXRlclRyYW5zaXRpb25TdGFydCAhPT0gbnVsbCkge1xuICAgIG9uUm91dGVyVHJhbnNpdGlvblN0YXJ0KGhyZWYsICd0cmF2ZXJzZScpXG4gIH1cbiAgZGlzcGF0Y2hBcHBSb3V0ZXJBY3Rpb24oe1xuICAgIHR5cGU6IEFDVElPTl9SRVNUT1JFLFxuICAgIHVybDogbmV3IFVSTChocmVmKSxcbiAgICB0cmVlLFxuICB9KVxufVxuXG4vKipcbiAqIFRoZSBhcHAgcm91dGVyIHRoYXQgaXMgZXhwb3NlZCB0aHJvdWdoIGB1c2VSb3V0ZXJgLiBUaGVzZSBhcmUgcHVibGljIEFQSVxuICogbWV0aG9kcy4gSW50ZXJuYWwgTmV4dC5qcyBjb2RlIHNob3VsZCBjYWxsIHRoZSBsb3dlciBsZXZlbCBtZXRob2RzIGRpcmVjdGx5XG4gKiAoYWx0aG91Z2ggdGhlcmUncyBsb3RzIG9mIGV4aXN0aW5nIGNvZGUgdGhhdCBkb2Vzbid0IGRvIHRoYXQpLlxuICovXG5leHBvcnQgY29uc3QgcHVibGljQXBwUm91dGVySW5zdGFuY2U6IEFwcFJvdXRlckluc3RhbmNlID0ge1xuICBiYWNrOiAoKSA9PiB3aW5kb3cuaGlzdG9yeS5iYWNrKCksXG4gIGZvcndhcmQ6ICgpID0+IHdpbmRvdy5oaXN0b3J5LmZvcndhcmQoKSxcbiAgcHJlZmV0Y2g6IHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfU0VHTUVOVF9DQUNIRVxuICAgID8gLy8gVW5saWtlIHRoZSBvbGQgaW1wbGVtZW50YXRpb24sIHRoZSBTZWdtZW50IENhY2hlIGRvZXNuJ3Qgc3RvcmUgaXRzXG4gICAgICAvLyBkYXRhIGluIHRoZSByb3V0ZXIgcmVkdWNlciBzdGF0ZTsgaXQgd3JpdGVzIGludG8gYSBnbG9iYWwgbXV0YWJsZVxuICAgICAgLy8gY2FjaGUuIFNvIHdlIGRvbid0IG5lZWQgdG8gZGlzcGF0Y2ggYW4gYWN0aW9uLlxuICAgICAgKGhyZWY6IHN0cmluZywgb3B0aW9ucz86IFByZWZldGNoT3B0aW9ucykgPT4ge1xuICAgICAgICBjb25zdCBhY3Rpb25RdWV1ZSA9IGdldEFwcFJvdXRlckFjdGlvblF1ZXVlKClcbiAgICAgICAgcHJlZmV0Y2hXaXRoU2VnbWVudENhY2hlKFxuICAgICAgICAgIGhyZWYsXG4gICAgICAgICAgYWN0aW9uUXVldWUuc3RhdGUubmV4dFVybCxcbiAgICAgICAgICBhY3Rpb25RdWV1ZS5zdGF0ZS50cmVlLFxuICAgICAgICAgIG9wdGlvbnM/LmtpbmQgPT09IFByZWZldGNoS2luZC5GVUxMLFxuICAgICAgICAgIG9wdGlvbnM/Lm9uSW52YWxpZGF0ZSA/PyBudWxsXG4gICAgICAgIClcbiAgICAgIH1cbiAgICA6IChocmVmOiBzdHJpbmcsIG9wdGlvbnM/OiBQcmVmZXRjaE9wdGlvbnMpID0+IHtcbiAgICAgICAgLy8gVXNlIHRoZSBvbGQgcHJlZmV0Y2ggaW1wbGVtZW50YXRpb24uXG4gICAgICAgIGNvbnN0IGFjdGlvblF1ZXVlID0gZ2V0QXBwUm91dGVyQWN0aW9uUXVldWUoKVxuICAgICAgICBjb25zdCB1cmwgPSBjcmVhdGVQcmVmZXRjaFVSTChocmVmKVxuICAgICAgICBpZiAodXJsICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gVGhlIHByZWZldGNoIHJlZHVjZXIgZG9lc24ndCBhY3R1YWxseSB1cGRhdGUgYW55IHN0YXRlIG9yXG4gICAgICAgICAgLy8gdHJpZ2dlciBhIHJlcmVuZGVyLiBJdCBqdXN0IHdyaXRlcyB0byBhIG11dGFibGUgY2FjaGUuIFNvIHdlXG4gICAgICAgICAgLy8gc2hvdWxkbid0IGJvdGhlciBjYWxsaW5nIHNldFN0YXRlL2Rpc3BhdGNoOyB3ZSBjYW4ganVzdCByZS1ydW5cbiAgICAgICAgICAvLyB0aGUgcmVkdWNlciBkaXJlY3RseSB1c2luZyB0aGUgY3VycmVudCBzdGF0ZS5cbiAgICAgICAgICAvLyBUT0RPOiBSZWZhY3RvciB0aGlzIGF3YXkgZnJvbSBhIFwicmVkdWNlclwiIHNvIGl0J3NcbiAgICAgICAgICAvLyBsZXNzIGNvbmZ1c2luZy5cbiAgICAgICAgICBwcmVmZXRjaFJlZHVjZXIoYWN0aW9uUXVldWUuc3RhdGUsIHtcbiAgICAgICAgICAgIHR5cGU6IEFDVElPTl9QUkVGRVRDSCxcbiAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgIGtpbmQ6IG9wdGlvbnM/LmtpbmQgPz8gUHJlZmV0Y2hLaW5kLkZVTEwsXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSxcbiAgcmVwbGFjZTogKGhyZWY6IHN0cmluZywgb3B0aW9ucz86IE5hdmlnYXRlT3B0aW9ucykgPT4ge1xuICAgIHN0YXJ0VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICBkaXNwYXRjaE5hdmlnYXRlQWN0aW9uKGhyZWYsICdyZXBsYWNlJywgb3B0aW9ucz8uc2Nyb2xsID8/IHRydWUsIG51bGwpXG4gICAgfSlcbiAgfSxcbiAgcHVzaDogKGhyZWY6IHN0cmluZywgb3B0aW9ucz86IE5hdmlnYXRlT3B0aW9ucykgPT4ge1xuICAgIHN0YXJ0VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICBkaXNwYXRjaE5hdmlnYXRlQWN0aW9uKGhyZWYsICdwdXNoJywgb3B0aW9ucz8uc2Nyb2xsID8/IHRydWUsIG51bGwpXG4gICAgfSlcbiAgfSxcbiAgcmVmcmVzaDogKCkgPT4ge1xuICAgIHN0YXJ0VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICBkaXNwYXRjaEFwcFJvdXRlckFjdGlvbih7XG4gICAgICAgIHR5cGU6IEFDVElPTl9SRUZSRVNILFxuICAgICAgICBvcmlnaW46IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4sXG4gICAgICB9KVxuICAgIH0pXG4gIH0sXG4gIGhtclJlZnJlc2g6ICgpID0+IHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ2htclJlZnJlc2ggY2FuIG9ubHkgYmUgdXNlZCBpbiBkZXZlbG9wbWVudCBtb2RlLiBQbGVhc2UgdXNlIHJlZnJlc2ggaW5zdGVhZC4nXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICAgIGRpc3BhdGNoQXBwUm91dGVyQWN0aW9uKHtcbiAgICAgICAgICB0eXBlOiBBQ1RJT05fSE1SX1JFRlJFU0gsXG4gICAgICAgICAgb3JpZ2luOiB3aW5kb3cubG9jYXRpb24ub3JpZ2luLFxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9XG4gIH0sXG59XG5cbi8vIEV4aXN0cyBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLiBEb24ndCB1c2UgaW4gYXBwbGljYXRpb24gY29kZS5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubmV4dCkge1xuICB3aW5kb3cubmV4dC5yb3V0ZXIgPSBwdWJsaWNBcHBSb3V0ZXJJbnN0YW5jZVxufVxuIl0sIm5hbWVzIjpbImNyZWF0ZU11dGFibGVBY3Rpb25RdWV1ZSIsImRpc3BhdGNoTmF2aWdhdGVBY3Rpb24iLCJkaXNwYXRjaFRyYXZlcnNlQWN0aW9uIiwiZ2V0Q3VycmVudEFwcFJvdXRlclN0YXRlIiwicHVibGljQXBwUm91dGVySW5zdGFuY2UiLCJydW5SZW1haW5pbmdBY3Rpb25zIiwiYWN0aW9uUXVldWUiLCJzZXRTdGF0ZSIsInBlbmRpbmciLCJuZXh0IiwicnVuQWN0aW9uIiwiYWN0aW9uIiwibmVlZHNSZWZyZXNoIiwiZGlzcGF0Y2giLCJ0eXBlIiwiQUNUSU9OX1JFRlJFU0giLCJvcmlnaW4iLCJ3aW5kb3ciLCJsb2NhdGlvbiIsInByZXZTdGF0ZSIsInN0YXRlIiwicGF5bG9hZCIsImFjdGlvblJlc3VsdCIsImhhbmRsZVJlc3VsdCIsIm5leHRTdGF0ZSIsImRpc2NhcmRlZCIsInJlc29sdmUiLCJpc1RoZW5hYmxlIiwidGhlbiIsImVyciIsInJlamVjdCIsImRpc3BhdGNoQWN0aW9uIiwicmVzb2x2ZXJzIiwiQUNUSU9OX1JFU1RPUkUiLCJkZWZlcnJlZFByb21pc2UiLCJQcm9taXNlIiwic3RhcnRUcmFuc2l0aW9uIiwibmV3QWN0aW9uIiwibGFzdCIsIkFDVElPTl9OQVZJR0FURSIsIkFDVElPTl9TRVJWRVJfQUNUSU9OIiwiZ2xvYmFsQWN0aW9uUXVldWUiLCJpbml0aWFsU3RhdGUiLCJpbnN0cnVtZW50YXRpb25Ib29rcyIsInJlc3VsdCIsInJlZHVjZXIiLCJvblJvdXRlclRyYW5zaXRpb25TdGFydCIsIkVycm9yIiwiZ2V0QXBwUm91dGVyQWN0aW9uUXVldWUiLCJnZXRQcm9maWxpbmdIb29rRm9yT25OYXZpZ2F0aW9uU3RhcnQiLCJocmVmIiwibmF2aWdhdGVUeXBlIiwic2hvdWxkU2Nyb2xsIiwibGlua0luc3RhbmNlUmVmIiwidXJsIiwiVVJMIiwiYWRkQmFzZVBhdGgiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX0FQUF9OQVZfRkFJTF9IQU5ETElORyIsIl9fcGVuZGluZ1VybCIsInNldExpbmtGb3JDdXJyZW50TmF2aWdhdGlvbiIsImRpc3BhdGNoQXBwUm91dGVyQWN0aW9uIiwiaXNFeHRlcm5hbFVybCIsImlzRXh0ZXJuYWxVUkwiLCJsb2NhdGlvblNlYXJjaCIsInNlYXJjaCIsImFsbG93QWxpYXNpbmciLCJ0cmVlIiwiYmFjayIsImhpc3RvcnkiLCJmb3J3YXJkIiwicHJlZmV0Y2giLCJfX05FWFRfQ0xJRU5UX1NFR01FTlRfQ0FDSEUiLCJvcHRpb25zIiwicHJlZmV0Y2hXaXRoU2VnbWVudENhY2hlIiwibmV4dFVybCIsImtpbmQiLCJQcmVmZXRjaEtpbmQiLCJGVUxMIiwib25JbnZhbGlkYXRlIiwiY3JlYXRlUHJlZmV0Y2hVUkwiLCJwcmVmZXRjaFJlZHVjZXIiLCJBQ1RJT05fUFJFRkVUQ0giLCJyZXBsYWNlIiwic2Nyb2xsIiwicHVzaCIsInJlZnJlc2giLCJobXJSZWZyZXNoIiwiTk9ERV9FTlYiLCJBQ1RJT05fSE1SX1JFRlJFU0giLCJyb3V0ZXIiXSwibWFwcGluZ3MiOiI7Ozs7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QUEsR0FBQUEsT0FBQUEsZUFBZSxFQUFDO2dCQUN1QnNDO1lBQXJDekUsdUJBQXVCaUQsTUFBTSxRQUFRd0IsQ0FBQUEsa0JBQUFBLFdBQUFBLE9BQUFBLEtBQUFBLElBQUFBLFFBQVNXLE1BQU0sS0FBQSxPQUFmWCxrQkFBbUIsTUFBTTtRQUNoRTtJQUNGO0lBQ0FhLFNBQVM7UUFDUG5ELENBQUFBLEdBQUFBLE9BQUFBLGVBQWUsRUFBQztZQUNkMEIsQ0FBQUEsR0FBQUEsZ0JBQUFBLHVCQUF1QixFQUFDO2dCQUN0QmhELE1BQU1DLG9CQUFBQSxjQUFjO2dCQUNwQkMsUUFBUUMsT0FBT0MsUUFBUSxDQUFDRixNQUFNO1lBQ2hDO1FBQ0Y7SUFDRjtJQUNBd0UsWUFBWTtRQUNWLElBQUkvQixRQUFRQyxHQUFHLENBQUMrQixRQUFRLEtBQUssZUFBZTs7YUFJckM7WUFDTHJELENBQUFBLEdBQUFBLE9BQUFBLGVBQWUsRUFBQztnQkFDZDBCLENBQUFBLEdBQUFBLGdCQUFBQSx1QkFBdUIsRUFBQztvQkFDdEJoRCxNQUFNNEUsb0JBQUFBLGtCQUFrQjtvQkFDeEIxRSxRQUFRQyxPQUFPQyxRQUFRLENBQUNGLE1BQU07Z0JBQ2hDO1lBQ0Y7UUFDRjtJQUNGO0FBQ0Y7QUFFQSxnRUFBZ0U7QUFDaEUsSUFBSSxPQUFPQyxXQUFXLGVBQWVBLE9BQU9SLElBQUksRUFBRSIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxMjU5NiwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvY29tcG9uZW50cy9saW5rcy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IEZsaWdodFJvdXRlclN0YXRlIH0gZnJvbSAnLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvdHlwZXMnXG5pbXBvcnQgdHlwZSB7IEFwcFJvdXRlckluc3RhbmNlIH0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgeyBnZXRDdXJyZW50QXBwUm91dGVyU3RhdGUgfSBmcm9tICcuL2FwcC1yb3V0ZXItaW5zdGFuY2UnXG5pbXBvcnQgeyBjcmVhdGVQcmVmZXRjaFVSTCB9IGZyb20gJy4vYXBwLXJvdXRlcidcbmltcG9ydCB7IFByZWZldGNoS2luZCB9IGZyb20gJy4vcm91dGVyLXJlZHVjZXIvcm91dGVyLXJlZHVjZXItdHlwZXMnXG5pbXBvcnQgeyBpc1ByZWZldGNoVGFza0RpcnR5IH0gZnJvbSAnLi9zZWdtZW50LWNhY2hlJ1xuaW1wb3J0IHsgY3JlYXRlQ2FjaGVLZXkgfSBmcm9tICcuL3NlZ21lbnQtY2FjaGUnXG5pbXBvcnQge1xuICB0eXBlIFByZWZldGNoVGFzayxcbiAgUHJlZmV0Y2hQcmlvcml0eSxcbiAgc2NoZWR1bGVQcmVmZXRjaFRhc2sgYXMgc2NoZWR1bGVTZWdtZW50UHJlZmV0Y2hUYXNrLFxuICBjYW5jZWxQcmVmZXRjaFRhc2ssXG4gIHJlc2NoZWR1bGVQcmVmZXRjaFRhc2ssXG59IGZyb20gJy4vc2VnbWVudC1jYWNoZSdcbmltcG9ydCB7IHN0YXJ0VHJhbnNpdGlvbiB9IGZyb20gJ3JlYWN0J1xuXG50eXBlIExpbmtFbGVtZW50ID0gSFRNTEFuY2hvckVsZW1lbnQgfCBTVkdBRWxlbWVudFxuXG50eXBlIEVsZW1lbnQgPSBMaW5rRWxlbWVudCB8IEhUTUxGb3JtRWxlbWVudFxuXG4vLyBQcm9wZXJ0aWVzIHRoYXQgYXJlIHNoYXJlZCBiZXR3ZWVuIExpbmsgYW5kIEZvcm0gaW5zdGFuY2VzLiBXZSB1c2UgdGhlIHNhbWVcbi8vIHNoYXBlIGZvciBib3RoIHRvIHByZXZlbnQgYSBwb2x5bW9ycGhpYyBkZS1vcHQgaW4gdGhlIFZNLlxudHlwZSBMaW5rT3JGb3JtSW5zdGFuY2VTaGFyZWQgPSB7XG4gIHJvdXRlcjogQXBwUm91dGVySW5zdGFuY2VcbiAga2luZDogUHJlZmV0Y2hLaW5kLkFVVE8gfCBQcmVmZXRjaEtpbmQuRlVMTFxuXG4gIGlzVmlzaWJsZTogYm9vbGVhblxuXG4gIC8vIFRoZSBtb3N0IHJlY2VudGx5IGluaXRpYXRlZCBwcmVmZXRjaCB0YXNrLiBJdCBtYXkgb3IgbWF5IG5vdCBoYXZlXG4gIC8vIGFscmVhZHkgY29tcGxldGVkLiBUaGUgc2FtZSBwcmVmZXRjaCB0YXNrIG9iamVjdCBjYW4gYmUgcmV1c2VkIGFjcm9zc1xuICAvLyBtdWx0aXBsZSBwcmVmZXRjaGVzIG9mIHRoZSBzYW1lIGxpbmsuXG4gIHByZWZldGNoVGFzazogUHJlZmV0Y2hUYXNrIHwgbnVsbFxufVxuXG5leHBvcnQgdHlwZSBGb3JtSW5zdGFuY2UgPSBMaW5rT3JGb3JtSW5zdGFuY2VTaGFyZWQgJiB7XG4gIHByZWZldGNoSHJlZjogc3RyaW5nXG4gIHNldE9wdGltaXN0aWNMaW5rU3RhdHVzOiBudWxsXG59XG5cbnR5cGUgUHJlZmV0Y2hhYmxlTGlua0luc3RhbmNlID0gTGlua09yRm9ybUluc3RhbmNlU2hhcmVkICYge1xuICBwcmVmZXRjaEhyZWY6IHN0cmluZ1xuICBzZXRPcHRpbWlzdGljTGlua1N0YXR1czogKHN0YXR1czogeyBwZW5kaW5nOiBib29sZWFuIH0pID0+IHZvaWRcbn1cblxudHlwZSBOb25QcmVmZXRjaGFibGVMaW5rSW5zdGFuY2UgPSBMaW5rT3JGb3JtSW5zdGFuY2VTaGFyZWQgJiB7XG4gIHByZWZldGNoSHJlZjogbnVsbFxuICBzZXRPcHRpbWlzdGljTGlua1N0YXR1czogKHN0YXR1czogeyBwZW5kaW5nOiBib29sZWFuIH0pID0+IHZvaWRcbn1cblxudHlwZSBQcmVmZXRjaGFibGVJbnN0YW5jZSA9IFByZWZldGNoYWJsZUxpbmtJbnN0YW5jZSB8IEZvcm1JbnN0YW5jZVxuXG5leHBvcnQgdHlwZSBMaW5rSW5zdGFuY2UgPVxuICB8IFByZWZldGNoYWJsZUxpbmtJbnN0YW5jZVxuICB8IE5vblByZWZldGNoYWJsZUxpbmtJbnN0YW5jZVxuXG4vLyBUcmFja3MgdGhlIG1vc3QgcmVjZW50bHkgbmF2aWdhdGVkIGxpbmsgaW5zdGFuY2UuIFdoZW4gbnVsbCwgaW5kaWNhdGVzXG4vLyB0aGUgY3VycmVudCBuYXZpZ2F0aW9uIHdhcyBub3QgaW5pdGlhdGVkIGJ5IGEgbGluayBjbGljay5cbmxldCBsaW5rRm9yTW9zdFJlY2VudE5hdmlnYXRpb246IExpbmtJbnN0YW5jZSB8IG51bGwgPSBudWxsXG5cbi8vIFN0YXR1cyBvYmplY3QgaW5kaWNhdGluZyBsaW5rIGlzIHBlbmRpbmdcbmV4cG9ydCBjb25zdCBQRU5ESU5HX0xJTktfU1RBVFVTID0geyBwZW5kaW5nOiB0cnVlIH1cblxuLy8gU3RhdHVzIG9iamVjdCBpbmRpY2F0aW5nIGxpbmsgaXMgaWRsZVxuZXhwb3J0IGNvbnN0IElETEVfTElOS19TVEFUVVMgPSB7IHBlbmRpbmc6IGZhbHNlIH1cblxuLy8gVXBkYXRlcyB0aGUgbG9hZGluZyBzdGF0ZSB3aGVuIG5hdmlnYXRpbmcgYmV0d2VlbiBsaW5rc1xuLy8gLSBSZXNldHMgdGhlIHByZXZpb3VzIGxpbmsncyBsb2FkaW5nIHN0YXRlXG4vLyAtIFNldHMgdGhlIG5ldyBsaW5rJ3MgbG9hZGluZyBzdGF0ZVxuLy8gLSBVcGRhdGVzIHRyYWNraW5nIG9mIGN1cnJlbnQgbmF2aWdhdGlvblxuZXhwb3J0IGZ1bmN0aW9uIHNldExpbmtGb3JDdXJyZW50TmF2aWdhdGlvbihsaW5rOiBMaW5rSW5zdGFuY2UgfCBudWxsKSB7XG4gIHN0YXJ0VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgbGlua0Zvck1vc3RSZWNlbnROYXZpZ2F0aW9uPy5zZXRPcHRpbWlzdGljTGlua1N0YXR1cyhJRExFX0xJTktfU1RBVFVTKVxuICAgIGxpbms/LnNldE9wdGltaXN0aWNMaW5rU3RhdHVzKFBFTkRJTkdfTElOS19TVEFUVVMpXG4gICAgbGlua0Zvck1vc3RSZWNlbnROYXZpZ2F0aW9uID0gbGlua1xuICB9KVxufVxuXG4vLyBVbm1vdW50cyB0aGUgY3VycmVudCBsaW5rIGluc3RhbmNlIGZyb20gbmF2aWdhdGlvbiB0cmFja2luZ1xuZXhwb3J0IGZ1bmN0aW9uIHVubW91bnRMaW5rRm9yQ3VycmVudE5hdmlnYXRpb24obGluazogTGlua0luc3RhbmNlKSB7XG4gIGlmIChsaW5rRm9yTW9zdFJlY2VudE5hdmlnYXRpb24gPT09IGxpbmspIHtcbiAgICBsaW5rRm9yTW9zdFJlY2VudE5hdmlnYXRpb24gPSBudWxsXG4gIH1cbn1cblxuLy8gVXNlIGEgV2Vha01hcCB0byBhc3NvY2lhdGUgYSBMaW5rIGluc3RhbmNlIHdpdGggaXRzIERPTSBlbGVtZW50LiBUaGlzIGlzXG4vLyB1c2VkIGJ5IHRoZSBJbnRlcnNlY3Rpb25PYnNlcnZlciB0byB0cmFjayB0aGUgbGluaydzIHZpc2liaWxpdHkuXG5jb25zdCBwcmVmZXRjaGFibGU6XG4gIHwgV2Vha01hcDxFbGVtZW50LCBQcmVmZXRjaGFibGVJbnN0YW5jZT5cbiAgfCBNYXA8RWxlbWVudCwgUHJlZmV0Y2hhYmxlSW5zdGFuY2U+ID1cbiAgdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBuZXcgV2Vha01hcCgpIDogbmV3IE1hcCgpXG5cbi8vIEEgU2V0IG9mIHRoZSBjdXJyZW50bHkgdmlzaWJsZSBsaW5rcy4gV2UgcmUtcHJlZmV0Y2ggdmlzaWJsZSBsaW5rcyBhZnRlciBhXG4vLyBjYWNoZSBpbnZhbGlkYXRpb24sIG9yIHdoZW4gdGhlIGN1cnJlbnQgVVJMIGNoYW5nZXMuIEl0J3MgYSBzZXBhcmF0ZSBkYXRhXG4vLyBzdHJ1Y3R1cmUgZnJvbSB0aGUgV2Vha01hcCBhYm92ZSBiZWNhdXNlIG9ubHkgdGhlIHZpc2libGUgbGlua3MgbmVlZCB0b1xuLy8gYmUgZW51bWVyYXRlZC5cbmNvbnN0IHByZWZldGNoYWJsZUFuZFZpc2libGU6IFNldDxQcmVmZXRjaGFibGVJbnN0YW5jZT4gPSBuZXcgU2V0KClcblxuLy8gQSBzaW5nbGUgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgaW5zdGFuY2Ugc2hhcmVkIGJ5IGFsbCA8TGluaz4gY29tcG9uZW50cy5cbmNvbnN0IG9ic2VydmVyOiBJbnRlcnNlY3Rpb25PYnNlcnZlciB8IG51bGwgPVxuICB0eXBlb2YgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPT09ICdmdW5jdGlvbidcbiAgICA/IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihoYW5kbGVJbnRlcnNlY3QsIHtcbiAgICAgICAgcm9vdE1hcmdpbjogJzIwMHB4JyxcbiAgICAgIH0pXG4gICAgOiBudWxsXG5cbmZ1bmN0aW9uIG9ic2VydmVWaXNpYmlsaXR5KGVsZW1lbnQ6IEVsZW1lbnQsIGluc3RhbmNlOiBQcmVmZXRjaGFibGVJbnN0YW5jZSkge1xuICBjb25zdCBleGlzdGluZ0luc3RhbmNlID0gcHJlZmV0Y2hhYmxlLmdldChlbGVtZW50KVxuICBpZiAoZXhpc3RpbmdJbnN0YW5jZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gVGhpcyBzaG91bGRuJ3QgaGFwcGVuIGJlY2F1c2UgZWFjaCA8TGluaz4gY29tcG9uZW50IHNob3VsZCBoYXZlIGl0cyBvd25cbiAgICAvLyBhbmNob3IgdGFnIGluc3RhbmNlLCBidXQgaXQncyBkZWZlbnNpdmUgY29kaW5nIHRvIGF2b2lkIGEgbWVtb3J5IGxlYWsgaW5cbiAgICAvLyBjYXNlIHRoZXJlJ3MgYSBsb2dpY2FsIGVycm9yIHNvbWV3aGVyZSBlbHNlLlxuICAgIHVubW91bnRQcmVmZXRjaGFibGVJbnN0YW5jZShlbGVtZW50KVxuICB9XG4gIC8vIE9ubHkgdHJhY2sgcHJlZmV0Y2hhYmxlIGxpbmtzIHRoYXQgaGF2ZSBhIHZhbGlkIHByZWZldGNoIFVSTFxuICBwcmVmZXRjaGFibGUuc2V0KGVsZW1lbnQsIGluc3RhbmNlKVxuICBpZiAob2JzZXJ2ZXIgIT09IG51bGwpIHtcbiAgICBvYnNlcnZlci5vYnNlcnZlKGVsZW1lbnQpXG4gIH1cbn1cblxuZnVuY3Rpb24gY29lcmNlUHJlZmV0Y2hhYmxlVXJsKGhyZWY6IHN0cmluZyk6IFVSTCB8IG51bGwge1xuICB0cnkge1xuICAgIHJldHVybiBjcmVhdGVQcmVmZXRjaFVSTChocmVmKVxuICB9IGNhdGNoIHtcbiAgICAvLyBjcmVhdGVQcmVmZXRjaFVSTCBzb21ldGltZXMgdGhyb3dzIGFuIGVycm9yIGlmIGFuIGludmFsaWQgVVJMIGlzXG4gICAgLy8gcHJvdmlkZWQsIHRob3VnaCBJJ20gbm90IHN1cmUgaWYgaXQncyBhY3R1YWxseSBuZWNlc3NhcnkuXG4gICAgLy8gVE9ETzogQ29uc2lkZXIgcmVtb3ZpbmcgdGhlIHRocm93IGZyb20gdGhlIGlubmVyIGZ1bmN0aW9uLCBvciBjaGFuZ2UgaXRcbiAgICAvLyB0byByZXBvcnRFcnJvci4gT3IgbWF5YmUgdGhlIGVycm9yIGlzbid0IGV2ZW4gbmVjZXNzYXJ5IGZvciBhdXRvbWF0aWNcbiAgICAvLyBwcmVmZXRjaGVzLCBqdXN0IG5hdmlnYXRpb25zLlxuICAgIGNvbnN0IHJlcG9ydEVycm9yRm4gPVxuICAgICAgdHlwZW9mIHJlcG9ydEVycm9yID09PSAnZnVuY3Rpb24nID8gcmVwb3J0RXJyb3IgOiBjb25zb2xlLmVycm9yXG4gICAgcmVwb3J0RXJyb3JGbihcbiAgICAgIGBDYW5ub3QgcHJlZmV0Y2ggJyR7aHJlZn0nIGJlY2F1c2UgaXQgY2Fubm90IGJlIGNvbnZlcnRlZCB0byBhIFVSTC5gXG4gICAgKVxuICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1vdW50TGlua0luc3RhbmNlKFxuICBlbGVtZW50OiBMaW5rRWxlbWVudCxcbiAgaHJlZjogc3RyaW5nLFxuICByb3V0ZXI6IEFwcFJvdXRlckluc3RhbmNlLFxuICBraW5kOiBQcmVmZXRjaEtpbmQuQVVUTyB8IFByZWZldGNoS2luZC5GVUxMLFxuICBwcmVmZXRjaEVuYWJsZWQ6IGJvb2xlYW4sXG4gIHNldE9wdGltaXN0aWNMaW5rU3RhdHVzOiAoc3RhdHVzOiB7IHBlbmRpbmc6IGJvb2xlYW4gfSkgPT4gdm9pZFxuKTogTGlua0luc3RhbmNlIHtcbiAgaWYgKHByZWZldGNoRW5hYmxlZCkge1xuICAgIGNvbnN0IHByZWZldGNoVVJMID0gY29lcmNlUHJlZmV0Y2hhYmxlVXJsKGhyZWYpXG4gICAgaWYgKHByZWZldGNoVVJMICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBpbnN0YW5jZTogUHJlZmV0Y2hhYmxlTGlua0luc3RhbmNlID0ge1xuICAgICAgICByb3V0ZXIsXG4gICAgICAgIGtpbmQsXG4gICAgICAgIGlzVmlzaWJsZTogZmFsc2UsXG4gICAgICAgIHByZWZldGNoVGFzazogbnVsbCxcbiAgICAgICAgcHJlZmV0Y2hIcmVmOiBwcmVmZXRjaFVSTC5ocmVmLFxuICAgICAgICBzZXRPcHRpbWlzdGljTGlua1N0YXR1cyxcbiAgICAgIH1cbiAgICAgIC8vIFdlIG9ubHkgb2JzZXJ2ZSB0aGUgbGluaydzIHZpc2liaWxpdHkgaWYgaXQncyBwcmVmZXRjaGFibGUuIEZvclxuICAgICAgLy8gZXhhbXBsZSwgdGhpcyBleGNsdWRlcyBsaW5rcyB0byBleHRlcm5hbCBVUkxzLlxuICAgICAgb2JzZXJ2ZVZpc2liaWxpdHkoZWxlbWVudCwgaW5zdGFuY2UpXG4gICAgICByZXR1cm4gaW5zdGFuY2VcbiAgICB9XG4gIH1cbiAgLy8gSWYgdGhlIGxpbmsgaXMgbm90IHByZWZldGNoYWJsZSwgd2Ugc3RpbGwgY3JlYXRlIGFuIGluc3RhbmNlIHNvIHdlIGNhblxuICAvLyB0cmFjayBpdHMgb3B0aW1pc3RpYyBzdGF0ZSAoaS5lLiB1c2VMaW5rU3RhdHVzKS5cbiAgY29uc3QgaW5zdGFuY2U6IE5vblByZWZldGNoYWJsZUxpbmtJbnN0YW5jZSA9IHtcbiAgICByb3V0ZXIsXG4gICAga2luZCxcbiAgICBpc1Zpc2libGU6IGZhbHNlLFxuICAgIHByZWZldGNoVGFzazogbnVsbCxcbiAgICBwcmVmZXRjaEhyZWY6IG51bGwsXG4gICAgc2V0T3B0aW1pc3RpY0xpbmtTdGF0dXMsXG4gIH1cbiAgcmV0dXJuIGluc3RhbmNlXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtb3VudEZvcm1JbnN0YW5jZShcbiAgZWxlbWVudDogSFRNTEZvcm1FbGVtZW50LFxuICBocmVmOiBzdHJpbmcsXG4gIHJvdXRlcjogQXBwUm91dGVySW5zdGFuY2UsXG4gIGtpbmQ6IFByZWZldGNoS2luZC5BVVRPIHwgUHJlZmV0Y2hLaW5kLkZVTExcbik6IHZvaWQge1xuICBjb25zdCBwcmVmZXRjaFVSTCA9IGNvZXJjZVByZWZldGNoYWJsZVVybChocmVmKVxuICBpZiAocHJlZmV0Y2hVUkwgPT09IG51bGwpIHtcbiAgICAvLyBUaGlzIGhyZWYgaXMgbm90IHByZWZldGNoYWJsZSwgc28gd2UgZG9uJ3QgdHJhY2sgaXQuXG4gICAgLy8gVE9ETzogV2UgY3VycmVudGx5IG9ic2VydmUvdW5vYnNlcnZlIGEgZm9ybSBldmVyeSB0aW1lIGl0cyBocmVmIGNoYW5nZXMuXG4gICAgLy8gRm9yIExpbmtzLCB0aGlzIGlzbid0IGEgYmlnIGRlYWwgYmVjYXVzZSB0aGUgaHJlZiBkb2Vzbid0IHVzdWFsbHkgY2hhbmdlLFxuICAgIC8vIGJ1dCBmb3IgZm9ybXMgaXQncyBleHRyZW1lbHkgY29tbW9uLiBXZSBzaG91bGQgb3B0aW1pemUgdGhpcy5cbiAgICByZXR1cm5cbiAgfVxuICBjb25zdCBpbnN0YW5jZTogRm9ybUluc3RhbmNlID0ge1xuICAgIHJvdXRlcixcbiAgICBraW5kLFxuICAgIGlzVmlzaWJsZTogZmFsc2UsXG4gICAgcHJlZmV0Y2hUYXNrOiBudWxsLFxuICAgIHByZWZldGNoSHJlZjogcHJlZmV0Y2hVUkwuaHJlZixcbiAgICBzZXRPcHRpbWlzdGljTGlua1N0YXR1czogbnVsbCxcbiAgfVxuICBvYnNlcnZlVmlzaWJpbGl0eShlbGVtZW50LCBpbnN0YW5jZSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVubW91bnRQcmVmZXRjaGFibGVJbnN0YW5jZShlbGVtZW50OiBFbGVtZW50KSB7XG4gIGNvbnN0IGluc3RhbmNlID0gcHJlZmV0Y2hhYmxlLmdldChlbGVtZW50KVxuICBpZiAoaW5zdGFuY2UgIT09IHVuZGVmaW5lZCkge1xuICAgIHByZWZldGNoYWJsZS5kZWxldGUoZWxlbWVudClcbiAgICBwcmVmZXRjaGFibGVBbmRWaXNpYmxlLmRlbGV0ZShpbnN0YW5jZSlcbiAgICBjb25zdCBwcmVmZXRjaFRhc2sgPSBpbnN0YW5jZS5wcmVmZXRjaFRhc2tcbiAgICBpZiAocHJlZmV0Y2hUYXNrICE9PSBudWxsKSB7XG4gICAgICBjYW5jZWxQcmVmZXRjaFRhc2socHJlZmV0Y2hUYXNrKVxuICAgIH1cbiAgfVxuICBpZiAob2JzZXJ2ZXIgIT09IG51bGwpIHtcbiAgICBvYnNlcnZlci51bm9ic2VydmUoZWxlbWVudClcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVJbnRlcnNlY3QoZW50cmllczogQXJyYXk8SW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyeT4pIHtcbiAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgLy8gU29tZSBleHRyZW1lbHkgb2xkIGJyb3dzZXJzIG9yIHBvbHlmaWxscyBkb24ndCByZWxpYWJseSBzdXBwb3J0XG4gICAgLy8gaXNJbnRlcnNlY3Rpbmcgc28gd2UgY2hlY2sgaW50ZXJzZWN0aW9uUmF0aW8gaW5zdGVhZC4gKERvIHdlIGNhcmU/IE5vdFxuICAgIC8vIHJlYWxseS4gQnV0IHdoYXRldmVyIHRoaXMgaXMgZmluZS4pXG4gICAgY29uc3QgaXNWaXNpYmxlID0gZW50cnkuaW50ZXJzZWN0aW9uUmF0aW8gPiAwXG4gICAgb25MaW5rVmlzaWJpbGl0eUNoYW5nZWQoZW50cnkudGFyZ2V0IGFzIEhUTUxBbmNob3JFbGVtZW50LCBpc1Zpc2libGUpXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9uTGlua1Zpc2liaWxpdHlDaGFuZ2VkKGVsZW1lbnQ6IEVsZW1lbnQsIGlzVmlzaWJsZTogYm9vbGVhbikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIFByZWZldGNoaW5nIG9uIHZpZXdwb3J0IGlzIGRpc2FibGVkIGluIGRldmVsb3BtZW50IGZvciBwZXJmb3JtYW5jZVxuICAgIC8vIHJlYXNvbnMsIGJlY2F1c2UgaXQgcmVxdWlyZXMgY29tcGlsaW5nIHRoZSB0YXJnZXQgcGFnZS5cbiAgICAvLyBUT0RPOiBJbnZlc3RpZ2F0ZSByZS1lbmFibGluZyB0aGlzLlxuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3QgaW5zdGFuY2UgPSBwcmVmZXRjaGFibGUuZ2V0KGVsZW1lbnQpXG4gIGlmIChpbnN0YW5jZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBpbnN0YW5jZS5pc1Zpc2libGUgPSBpc1Zpc2libGVcbiAgaWYgKGlzVmlzaWJsZSkge1xuICAgIHByZWZldGNoYWJsZUFuZFZpc2libGUuYWRkKGluc3RhbmNlKVxuICB9IGVsc2Uge1xuICAgIHByZWZldGNoYWJsZUFuZFZpc2libGUuZGVsZXRlKGluc3RhbmNlKVxuICB9XG4gIHJlc2NoZWR1bGVMaW5rUHJlZmV0Y2goaW5zdGFuY2UsIFByZWZldGNoUHJpb3JpdHkuRGVmYXVsdClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9uTmF2aWdhdGlvbkludGVudChcbiAgZWxlbWVudDogSFRNTEFuY2hvckVsZW1lbnQgfCBTVkdBRWxlbWVudCxcbiAgdW5zdGFibGVfdXBncmFkZVRvRHluYW1pY1ByZWZldGNoOiBib29sZWFuXG4pIHtcbiAgY29uc3QgaW5zdGFuY2UgPSBwcmVmZXRjaGFibGUuZ2V0KGVsZW1lbnQpXG4gIGlmIChpbnN0YW5jZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgLy8gUHJlZmV0Y2ggdGhlIGxpbmsgb24gaG92ZXIvdG91Y2hzdGFydC5cbiAgaWYgKGluc3RhbmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoXG4gICAgICBwcm9jZXNzLmVudi5fX05FWFRfRFlOQU1JQ19PTl9IT1ZFUiAmJlxuICAgICAgdW5zdGFibGVfdXBncmFkZVRvRHluYW1pY1ByZWZldGNoXG4gICAgKSB7XG4gICAgICAvLyBTd2l0Y2ggdG8gYSBmdWxsLCBkeW5hbWljIHByZWZldGNoXG4gICAgICBpbnN0YW5jZS5raW5kID0gUHJlZmV0Y2hLaW5kLkZVTExcbiAgICB9XG4gICAgcmVzY2hlZHVsZUxpbmtQcmVmZXRjaChpbnN0YW5jZSwgUHJlZmV0Y2hQcmlvcml0eS5JbnRlbnQpXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzY2hlZHVsZUxpbmtQcmVmZXRjaChcbiAgaW5zdGFuY2U6IFByZWZldGNoYWJsZUluc3RhbmNlLFxuICBwcmlvcml0eTogUHJlZmV0Y2hQcmlvcml0eS5EZWZhdWx0IHwgUHJlZmV0Y2hQcmlvcml0eS5JbnRlbnRcbikge1xuICBjb25zdCBleGlzdGluZ1ByZWZldGNoVGFzayA9IGluc3RhbmNlLnByZWZldGNoVGFza1xuXG4gIGlmICghaW5zdGFuY2UuaXNWaXNpYmxlKSB7XG4gICAgLy8gQ2FuY2VsIGFueSBpbi1wcm9ncmVzcyBwcmVmZXRjaCB0YXNrLiAoSWYgaXQgYWxyZWFkeSBmaW5pc2hlZCB0aGVuIHRoaXNcbiAgICAvLyBpcyBhIG5vLW9wLilcbiAgICBpZiAoZXhpc3RpbmdQcmVmZXRjaFRhc2sgIT09IG51bGwpIHtcbiAgICAgIGNhbmNlbFByZWZldGNoVGFzayhleGlzdGluZ1ByZWZldGNoVGFzaylcbiAgICB9XG4gICAgLy8gV2UgZG9uJ3QgbmVlZCB0byByZXNldCB0aGUgcHJlZmV0Y2hUYXNrIHRvIG51bGwgdXBvbiBjYW5jZWxsYXRpb247IGFuXG4gICAgLy8gb2xkIHRhc2sgb2JqZWN0IGNhbiBiZSByZXNjaGVkdWxlZCB3aXRoIHJlc2NoZWR1bGVQcmVmZXRjaFRhc2suIFRoaXMgaXMgYVxuICAgIC8vIG1pY3JvLW9wdGltaXphdGlvbiBidXQgYWxzbyBtYWtlcyB0aGUgY29kZSBzaW1wbGVyIChkb24ndCBuZWVkIHRvXG4gICAgLy8gd29ycnkgYWJvdXQgd2hldGhlciBhbiBvbGQgdGFzayBvYmplY3QgaXMgc3RhbGUpLlxuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKCFwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1NFR01FTlRfQ0FDSEUpIHtcbiAgICAvLyBUaGUgb2xkIHByZWZldGNoIGltcGxlbWVudGF0aW9uIGRvZXMgbm90IGhhdmUgZGlmZmVyZW50IHByaW9yaXR5IGxldmVscy5cbiAgICAvLyBKdXN0IHNjaGVkdWxlIGEgbmV3IHByZWZldGNoIHRhc2suXG4gICAgcHJlZmV0Y2hXaXRoT2xkQ2FjaGVJbXBsZW1lbnRhdGlvbihpbnN0YW5jZSlcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IGFwcFJvdXRlclN0YXRlID0gZ2V0Q3VycmVudEFwcFJvdXRlclN0YXRlKClcbiAgaWYgKGFwcFJvdXRlclN0YXRlICE9PSBudWxsKSB7XG4gICAgY29uc3QgdHJlZUF0VGltZU9mUHJlZmV0Y2ggPSBhcHBSb3V0ZXJTdGF0ZS50cmVlXG4gICAgaWYgKGV4aXN0aW5nUHJlZmV0Y2hUYXNrID09PSBudWxsKSB7XG4gICAgICAvLyBJbml0aWF0ZSBhIHByZWZldGNoIHRhc2suXG4gICAgICBjb25zdCBuZXh0VXJsID0gYXBwUm91dGVyU3RhdGUubmV4dFVybFxuICAgICAgY29uc3QgY2FjaGVLZXkgPSBjcmVhdGVDYWNoZUtleShpbnN0YW5jZS5wcmVmZXRjaEhyZWYsIG5leHRVcmwpXG4gICAgICBpbnN0YW5jZS5wcmVmZXRjaFRhc2sgPSBzY2hlZHVsZVNlZ21lbnRQcmVmZXRjaFRhc2soXG4gICAgICAgIGNhY2hlS2V5LFxuICAgICAgICB0cmVlQXRUaW1lT2ZQcmVmZXRjaCxcbiAgICAgICAgaW5zdGFuY2Uua2luZCA9PT0gUHJlZmV0Y2hLaW5kLkZVTEwsXG4gICAgICAgIHByaW9yaXR5LFxuICAgICAgICBudWxsXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdlIGFscmVhZHkgaGF2ZSBhbiBvbGQgdGFzayBvYmplY3QgdGhhdCB3ZSBjYW4gcmVzY2hlZHVsZS4gVGhpcyBpc1xuICAgICAgLy8gZWZmZWN0aXZlbHkgdGhlIHNhbWUgYXMgY2FuY2VsaW5nIHRoZSBvbGQgdGFzayBhbmQgY3JlYXRpbmcgYSBuZXcgb25lLlxuICAgICAgcmVzY2hlZHVsZVByZWZldGNoVGFzayhcbiAgICAgICAgZXhpc3RpbmdQcmVmZXRjaFRhc2ssXG4gICAgICAgIHRyZWVBdFRpbWVPZlByZWZldGNoLFxuICAgICAgICBpbnN0YW5jZS5raW5kID09PSBQcmVmZXRjaEtpbmQuRlVMTCxcbiAgICAgICAgcHJpb3JpdHlcbiAgICAgIClcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBpbmdWaXNpYmxlTGlua3MoXG4gIG5leHRVcmw6IHN0cmluZyB8IG51bGwsXG4gIHRyZWU6IEZsaWdodFJvdXRlclN0YXRlXG4pIHtcbiAgLy8gRm9yIGVhY2ggY3VycmVudGx5IHZpc2libGUgbGluaywgY2FuY2VsIHRoZSBleGlzdGluZyBwcmVmZXRjaCB0YXNrIChpZiBpdFxuICAvLyBleGlzdHMpIGFuZCBzY2hlZHVsZSBhIG5ldyBvbmUuIFRoaXMgaXMgZWZmZWN0aXZlbHkgdGhlIHNhbWUgYXMgaWYgYWxsIHRoZVxuICAvLyB2aXNpYmxlIGxpbmtzIGxlZnQgYW5kIHRoZW4gcmUtZW50ZXJlZCB0aGUgdmlld3BvcnQuXG4gIC8vXG4gIC8vIFRoaXMgaXMgY2FsbGVkIHdoZW4gdGhlIE5leHQtVXJsIG9yIHRoZSBiYXNlIHRyZWUgY2hhbmdlcywgc2luY2UgdGhvc2VcbiAgLy8gbWF5IGFmZmVjdCB0aGUgcmVzdWx0IG9mIGEgcHJlZmV0Y2ggdGFzay4gSXQncyBhbHNvIGNhbGxlZCBhZnRlciBhXG4gIC8vIGNhY2hlIGludmFsaWRhdGlvbi5cbiAgZm9yIChjb25zdCBpbnN0YW5jZSBvZiBwcmVmZXRjaGFibGVBbmRWaXNpYmxlKSB7XG4gICAgY29uc3QgdGFzayA9IGluc3RhbmNlLnByZWZldGNoVGFza1xuICAgIGlmICh0YXNrICE9PSBudWxsICYmICFpc1ByZWZldGNoVGFza0RpcnR5KHRhc2ssIG5leHRVcmwsIHRyZWUpKSB7XG4gICAgICAvLyBUaGUgY2FjaGUgaGFzIG5vdCBiZWVuIGludmFsaWRhdGVkLCBhbmQgbm9uZSBvZiB0aGUgaW5wdXRzIGhhdmVcbiAgICAgIC8vIGNoYW5nZWQuIEJhaWwgb3V0LlxuICAgICAgY29udGludWVcbiAgICB9XG4gICAgLy8gU29tZXRoaW5nIGNoYW5nZWQuIENhbmNlbCB0aGUgZXhpc3RpbmcgcHJlZmV0Y2ggdGFzayBhbmQgc2NoZWR1bGUgYVxuICAgIC8vIG5ldyBvbmUuXG4gICAgaWYgKHRhc2sgIT09IG51bGwpIHtcbiAgICAgIGNhbmNlbFByZWZldGNoVGFzayh0YXNrKVxuICAgIH1cbiAgICBjb25zdCBjYWNoZUtleSA9IGNyZWF0ZUNhY2hlS2V5KGluc3RhbmNlLnByZWZldGNoSHJlZiwgbmV4dFVybClcbiAgICBpbnN0YW5jZS5wcmVmZXRjaFRhc2sgPSBzY2hlZHVsZVNlZ21lbnRQcmVmZXRjaFRhc2soXG4gICAgICBjYWNoZUtleSxcbiAgICAgIHRyZWUsXG4gICAgICBpbnN0YW5jZS5raW5kID09PSBQcmVmZXRjaEtpbmQuRlVMTCxcbiAgICAgIFByZWZldGNoUHJpb3JpdHkuRGVmYXVsdCxcbiAgICAgIG51bGxcbiAgICApXG4gIH1cbn1cblxuZnVuY3Rpb24gcHJlZmV0Y2hXaXRoT2xkQ2FjaGVJbXBsZW1lbnRhdGlvbihpbnN0YW5jZTogUHJlZmV0Y2hhYmxlSW5zdGFuY2UpIHtcbiAgLy8gVGhpcyBpcyB0aGUgcGF0aCB1c2VkIHdoZW4gdGhlIFNlZ21lbnQgQ2FjaGUgaXMgbm90IGVuYWJsZWQuXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3QgZG9QcmVmZXRjaCA9IGFzeW5jICgpID0+IHtcbiAgICAvLyBub3RlIHRoYXQgYGFwcFJvdXRlci5wcmVmZXRjaCgpYCBpcyBjdXJyZW50bHkgc3luYyxcbiAgICAvLyBzbyB3ZSBoYXZlIHRvIHdyYXAgdGhpcyBjYWxsIGluIGFuIGFzeW5jIGZ1bmN0aW9uIHRvIGJlIGFibGUgdG8gY2F0Y2goKSBlcnJvcnMgYmVsb3cuXG4gICAgcmV0dXJuIGluc3RhbmNlLnJvdXRlci5wcmVmZXRjaChpbnN0YW5jZS5wcmVmZXRjaEhyZWYsIHtcbiAgICAgIGtpbmQ6IGluc3RhbmNlLmtpbmQsXG4gICAgfSlcbiAgfVxuXG4gIC8vIFByZWZldGNoIHRoZSBwYWdlIGlmIGFza2VkIChvbmx5IGluIHRoZSBjbGllbnQpXG4gIC8vIFdlIG5lZWQgdG8gaGFuZGxlIGEgcHJlZmV0Y2ggZXJyb3IgaGVyZSBzaW5jZSB3ZSBtYXkgYmVcbiAgLy8gbG9hZGluZyB3aXRoIHByaW9yaXR5IHdoaWNoIGNhbiByZWplY3QgYnV0IHdlIGRvbid0XG4gIC8vIHdhbnQgdG8gZm9yY2UgbmF2aWdhdGlvbiBzaW5jZSB0aGlzIGlzIG9ubHkgYSBwcmVmZXRjaFxuICBkb1ByZWZldGNoKCkuY2F0Y2goKGVycikgPT4ge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyByZXRocm93IHRvIHNob3cgaW52YWxpZCBVUkwgZXJyb3JzXG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gIH0pXG59XG4iXSwibmFtZXMiOlsiSURMRV9MSU5LX1NUQVRVUyIsIlBFTkRJTkdfTElOS19TVEFUVVMiLCJtb3VudEZvcm1JbnN0YW5jZSIsIm1vdW50TGlua0luc3RhbmNlIiwib25MaW5rVmlzaWJpbGl0eUNoYW5nZWQiLCJvbk5hdmlnYXRpb25JbnRlbnQiLCJwaW5nVmlzaWJsZUxpbmtzIiwic2V0TGlua0ZvckN1cnJlbnROYXZpZ2F0aW9uIiwidW5tb3VudExpbmtGb3JDdXJyZW50TmF2aWdhdGlvbiIsInVubW91bnRQcmVmZXRjaGFibGVJbnN0YW5jZSIsImxpbmtGb3JNb3N0UmVjZW50TmF2aWdhdGlvbiIsInBlbmRpbmciLCJsaW5rIiwic3RhcnRUcmFuc2l0aW9uIiwic2V0T3B0aW1pc3RpY0xpbmtTdGF0dXMiLCJwcmVmZXRjaGFibGUiLCJXZWFrTWFwIiwiTWFwIiwicHJlZmV0Y2hhYmxlQW5kVmlzaWJsZSIsIlNldCIsIm9ic2VydmVyIiwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJoYW5kbGVJbnRlcnNlY3QiLCJyb290TWFyZ2luIiwib2JzZXJ2ZVZpc2liaWxpdHkiLCJlbGVtZW50IiwiaW5zdGFuY2UiLCJleGlzdGluZ0luc3RhbmNlIiwiZ2V0IiwidW5kZWZpbmVkIiwic2V0Iiwib2JzZXJ2ZSIsImNvZXJjZVByZWZldGNoYWJsZVVybCIsImhyZWYiLCJjcmVhdGVQcmVmZXRjaFVSTCIsInJlcG9ydEVycm9yRm4iLCJyZXBvcnRFcnJvciIsImNvbnNvbGUiLCJlcnJvciIsInJvdXRlciIsImtpbmQiLCJwcmVmZXRjaEVuYWJsZWQiLCJwcmVmZXRjaFVSTCIsImlzVmlzaWJsZSIsInByZWZldGNoVGFzayIsInByZWZldGNoSHJlZiIsImRlbGV0ZSIsImNhbmNlbFByZWZldGNoVGFzayIsInVub2JzZXJ2ZSIsImVudHJpZXMiLCJlbnRyeSIsImludGVyc2VjdGlvblJhdGlvIiwidGFyZ2V0IiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiYWRkIiwicmVzY2hlZHVsZUxpbmtQcmVmZXRjaCIsIlByZWZldGNoUHJpb3JpdHkiLCJEZWZhdWx0IiwidW5zdGFibGVfdXBncmFkZVRvRHluYW1pY1ByZWZldGNoIiwiX19ORVhUX0RZTkFNSUNfT05fSE9WRVIiLCJQcmVmZXRjaEtpbmQiLCJGVUxMIiwiSW50ZW50IiwicHJpb3JpdHkiLCJleGlzdGluZ1ByZWZldGNoVGFzayIsIl9fTkVYVF9DTElFTlRfU0VHTUVOVF9DQUNIRSIsInByZWZldGNoV2l0aE9sZENhY2hlSW1wbGVtZW50YXRpb24iLCJhcHBSb3V0ZXJTdGF0ZSIsImdldEN1cnJlbnRBcHBSb3V0ZXJTdGF0ZSIsInRyZWVBdFRpbWVPZlByZWZldGNoIiwidHJlZSIsIm5leHRVcmwiLCJjYWNoZUtleSIsImNyZWF0ZUNhY2hlS2V5Iiwic2NoZWR1bGVTZWdtZW50UHJlZmV0Y2hUYXNrIiwicmVzY2hlZHVsZVByZWZldGNoVGFzayIsInRhc2siLCJpc1ByZWZldGNoVGFza0RpcnR5Iiwid2luZG93IiwiZG9QcmVmZXRjaCIsInByZWZldGNoIiwiY2F0Y2giLCJlcnIiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUErRGFBLGdCQUFnQixFQUFBO2VBQWhCQTs7SUFIQUMsbUJBQW1CLEVBQUE7ZUFBbkJBOztJQW9IR0MsaUJBQWlCLEVBQUE7ZUFBakJBOztJQXRDQUMsaUJBQWlCLEVBQUE7ZUFBakJBOztJQXdGQUMsdUJBQXVCLEVBQUE7ZUFBdkJBOztJQXNCQUMsa0JBQWtCLEVBQUE7ZUFBbEJBOztJQTBFQUMsZ0JBQWdCLEVBQUE7ZUFBaEJBOztJQTdQQUMsMkJBQTJCLEVBQUE7ZUFBM0JBOztJQVNBQywrQkFBK0IsRUFBQTtlQUEvQkE7O0lBMkhBQywyQkFBMkIsRUFBQTtlQUEzQkE7OzttQ0F2TXlCOzJCQUNQO29DQUNMOzhCQUNPO3VCQVNKO0FBeUNoQyx5RUFBeUU7QUFDekUsNERBQTREO0FBQzVELElBQUlDLDhCQUFtRDtBQUdoRCxNQUFNVCxzQkFBc0I7SUFBRVUsU0FBUztBQUFLO0FBRzVDLE1BQU1YLG1CQUFtQjtJQUFFVyxTQUFTO0FBQU07QUFNMUMsU0FBU0osNEJBQTRCSyxJQUF5QjtJQUNuRUMsQ0FBQUEsR0FBQUEsT0FBQUEsZUFBZSxFQUFDO1FBQ2RILCtCQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSw0QkFBNkJJLHVCQUF1QixDQUFDZDtRQUNyRFksUUFBQUEsT0FBQUEsS0FBQUEsSUFBQUEsS0FBTUUsdUJBQXVCLENBQUNiO1FBQzlCUyw4QkFBOEJFO0lBQ2hDO0FBQ0Y7QUFHTyxTQUFTSixnQ0FBZ0NJLElBQWtCO0lBQ2hFLElBQUlGLGdDQUFnQ0UsTUFBTTtRQUN4Q0YsOEJBQThCO0lBQ2hDO0FBQ0Y7QUFFQSwyRUFBMkU7QUFDM0UsbUVBQW1FO0FBQ25FLE1BQU1LLGVBR0osT0FBT0MsWUFBWSxhQUFhLElBQUlB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MUM7UUFDbkM7SUFDRjs7O0lBRUEsTUFBTTJDLGlCQUFpQkMsSUFBQUEsMkNBQXdCO0FBeUJqRDtBQUVPLFNBQVNoRSxpQkFDZG1FLE9BQXNCLEVBQ3RCRCxJQUF1QjtJQUV2Qiw0RUFBNEU7SUFDNUUsNkVBQTZFO0lBQzdFLHVEQUF1RDtJQUN2RCxFQUFFO0lBQ0YseUVBQXlFO0lBQ3pFLHFFQUFxRTtJQUNyRSxzQkFBc0I7SUFDdEIsS0FBSyxNQUFNOUMsWUFBWVIsdUJBQXdCO1FBQzdDLE1BQU00RCxPQUFPcEQsU0FBU2tCLFlBQVk7UUFDbEMsSUFBSWtDLFNBQVMsUUFBUSxDQUFDQyxDQUFBQSxHQUFBQSxjQUFBQSxtQkFBbUIsRUFBQ0QsTUFBTUwsU0FBU0QsT0FBTztZQUc5RDtRQUNGO1FBQ0Esc0VBQXNFO1FBQ3RFLFdBQVc7UUFDWCxJQUFJTSxTQUFTLE1BQU07WUFDakIvQixDQUFBQSxHQUFBQSxjQUFBQSxrQkFBa0IsRUFBQytCO1FBQ3JCO1FBQ0EsTUFBTUosV0FBV0MsQ0FBQUEsR0FBQUEsY0FBQUEsY0FBYyxFQUFDakQsU0FBU21CLFlBQVksRUFBRTRCO1FBQ3ZEL0MsU0FBU2tCLFlBQVksR0FBR2dDLENBQUFBLEdBQUFBLGNBQUFBLG9CQUEyQixFQUNqREYsVUFDQUYsTUFDQTlDLFNBQVNjLElBQUksS0FBS3NCLG9CQUFBQSxZQUFZLENBQUNDLElBQUksRUFDbkNMLGNBQUFBLGdCQUFnQixDQUFDQyxPQUFPLEVBQ3hCO0lBRUo7QUFDRjtBQUVBLFNBQVNTLG1DQUFtQzFDLFFBQThCO0lBQ3hFLCtEQUErRDtJQUMvRCxJQUFJLE9BQU9zRCxXQUFXLGtCQUFhO1FBQ2pDO0lBQ0Y7OztJQUVBLE1BQU1DLGFBQWE7QUFrQnJCIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDEyODc4LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2lzLWxvY2FsLXVybC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc0Fic29sdXRlVXJsLCBnZXRMb2NhdGlvbk9yaWdpbiB9IGZyb20gJy4uLy4uL3V0aWxzJ1xuaW1wb3J0IHsgaGFzQmFzZVBhdGggfSBmcm9tICcuLi8uLi8uLi8uLi9jbGllbnQvaGFzLWJhc2UtcGF0aCdcblxuLyoqXG4gKiBEZXRlY3RzIHdoZXRoZXIgYSBnaXZlbiB1cmwgaXMgcm91dGFibGUgYnkgdGhlIE5leHQuanMgcm91dGVyIChicm93c2VyIG9ubHkpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNMb2NhbFVSTCh1cmw6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAvLyBwcmV2ZW50IGEgaHlkcmF0aW9uIG1pc21hdGNoIG9uIGhyZWYgZm9yIHVybCB3aXRoIGFuY2hvciByZWZzXG4gIGlmICghaXNBYnNvbHV0ZVVybCh1cmwpKSByZXR1cm4gdHJ1ZVxuICB0cnkge1xuICAgIC8vIGFic29sdXRlIHVybHMgY2FuIGJlIGxvY2FsIGlmIHRoZXkgYXJlIG9uIHRoZSBzYW1lIG9yaWdpblxuICAgIGNvbnN0IGxvY2F0aW9uT3JpZ2luID0gZ2V0TG9jYXRpb25PcmlnaW4oKVxuICAgIGNvbnN0IHJlc29sdmVkID0gbmV3IFVSTCh1cmwsIGxvY2F0aW9uT3JpZ2luKVxuICAgIHJldHVybiByZXNvbHZlZC5vcmlnaW4gPT09IGxvY2F0aW9uT3JpZ2luICYmIGhhc0Jhc2VQYXRoKHJlc29sdmVkLnBhdGhuYW1lKVxuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJpc0xvY2FsVVJMIiwidXJsIiwiaXNBYnNvbHV0ZVVybCIsImxvY2F0aW9uT3JpZ2luIiwiZ2V0TG9jYXRpb25PcmlnaW4iLCJyZXNvbHZlZCIsIlVSTCIsIm9yaWdpbiIsImhhc0Jhc2VQYXRoIiwicGF0aG5hbWUiLCJfIl0sIm1hcHBpbmdzIjoiOzs7K0JBTWdCQSxjQUFBQTs7O2VBQUFBOzs7dUJBTmlDOzZCQUNyQjtBQUtyQixTQUFTQSxXQUFXQyxHQUFXO0lBQ3BDLGdFQUFnRTtJQUNoRSxJQUFJLENBQUNDLENBQUFBLEdBQUFBLE9BQUFBLGFBQWEsRUFBQ0QsTUFBTSxPQUFPO0lBQ2hDLElBQUk7UUFDRiw0REFBNEQ7UUFDNUQsTUFBTUUsaUJBQWlCQyxDQUFBQSxHQUFBQSxPQUFBQSxpQkFBaUI7UUFDeEMsTUFBTUMsV0FBVyxJQUFJQyxJQUFJTCxLQUFLRTtRQUM5QixPQUFPRSxTQUFTRSxNQUFNLEtBQUtKLGtCQUFrQkssQ0FBQUEsR0FBQUEsYUFBQUEsV0FBVyxFQUFDSCxTQUFTSSxRQUFRO0lBQzVFLEVBQUUsT0FBT0MsR0FBRztRQUNWLE9BQU87SUFDVDtBQUNGIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDEyOTA3LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL3NoYXJlZC9saWIvdXRpbHMvZXJyb3Itb25jZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJsZXQgZXJyb3JPbmNlID0gKF86IHN0cmluZykgPT4ge31cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGNvbnN0IGVycm9ycyA9IG5ldyBTZXQ8c3RyaW5nPigpXG4gIGVycm9yT25jZSA9IChtc2c6IHN0cmluZykgPT4ge1xuICAgIGlmICghZXJyb3JzLmhhcyhtc2cpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1zZylcbiAgICB9XG4gICAgZXJyb3JzLmFkZChtc2cpXG4gIH1cbn1cblxuZXhwb3J0IHsgZXJyb3JPbmNlIH1cbiJdLCJuYW1lcyI6WyJlcnJvck9uY2UiLCJfIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiZXJyb3JzIiwiU2V0IiwibXNnIiwiaGFzIiwiY29uc29sZSIsImVycm9yIiwiYWRkIl0sIm1hcHBpbmdzIjoiOzs7K0JBV1NBLGFBQUFBOzs7ZUFBQUE7OztBQVhULElBQUlBLFlBQVksQ0FBQ0MsS0FBZTtBQUNoQyxJQUFJQyxRQUFRQyxHQUFHLENBQUNDLFFBQVEsS0FBSyxXQUFjO0lBQ3pDLE1BQU1DLFNBQVMsSUFBSUM7SUFDbkJOLFlBQVksQ0FBQ087UUFDWCxJQUFJLENBQUNGLE9BQU9HLEdBQUcsQ0FBQ0QsTUFBTTtZQUNwQkUsUUFBUUMsS0FBSyxDQUFDSDtRQUNoQjtRQUNBRixPQUFPTSxHQUFHLENBQUNKO0lBQ2I7QUFDRiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxMjkzMiwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvYXBwLWRpci9saW5rLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuaW1wb3J0IFJlYWN0LCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZU9wdGltaXN0aWMsIHVzZVJlZiB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHR5cGUgeyBVcmxPYmplY3QgfSBmcm9tICd1cmwnXG5pbXBvcnQgeyBmb3JtYXRVcmwgfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9mb3JtYXQtdXJsJ1xuaW1wb3J0IHsgQXBwUm91dGVyQ29udGV4dCB9IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHsgUHJlZmV0Y2hLaW5kIH0gZnJvbSAnLi4vY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yb3V0ZXItcmVkdWNlci10eXBlcydcbmltcG9ydCB7IHVzZU1lcmdlZFJlZiB9IGZyb20gJy4uL3VzZS1tZXJnZWQtcmVmJ1xuaW1wb3J0IHsgaXNBYnNvbHV0ZVVybCB9IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvdXRpbHMnXG5pbXBvcnQgeyBhZGRCYXNlUGF0aCB9IGZyb20gJy4uL2FkZC1iYXNlLXBhdGgnXG5pbXBvcnQgeyB3YXJuT25jZSB9IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvdXRpbHMvd2Fybi1vbmNlJ1xuaW1wb3J0IHR5cGUgeyBQRU5ESU5HX0xJTktfU1RBVFVTIH0gZnJvbSAnLi4vY29tcG9uZW50cy9saW5rcydcbmltcG9ydCB7XG4gIElETEVfTElOS19TVEFUVVMsXG4gIG1vdW50TGlua0luc3RhbmNlLFxuICBvbk5hdmlnYXRpb25JbnRlbnQsXG4gIHVubW91bnRMaW5rRm9yQ3VycmVudE5hdmlnYXRpb24sXG4gIHVubW91bnRQcmVmZXRjaGFibGVJbnN0YW5jZSxcbiAgdHlwZSBMaW5rSW5zdGFuY2UsXG59IGZyb20gJy4uL2NvbXBvbmVudHMvbGlua3MnXG5pbXBvcnQgeyBpc0xvY2FsVVJMIH0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtbG9jYWwtdXJsJ1xuaW1wb3J0IHsgZGlzcGF0Y2hOYXZpZ2F0ZUFjdGlvbiB9IGZyb20gJy4uL2NvbXBvbmVudHMvYXBwLXJvdXRlci1pbnN0YW5jZSdcbmltcG9ydCB7IGVycm9yT25jZSB9IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvdXRpbHMvZXJyb3Itb25jZSdcblxudHlwZSBVcmwgPSBzdHJpbmcgfCBVcmxPYmplY3RcbnR5cGUgUmVxdWlyZWRLZXlzPFQ+ID0ge1xuICBbSyBpbiBrZXlvZiBUXS0/OiB7fSBleHRlbmRzIFBpY2s8VCwgSz4gPyBuZXZlciA6IEtcbn1ba2V5b2YgVF1cbnR5cGUgT3B0aW9uYWxLZXlzPFQ+ID0ge1xuICBbSyBpbiBrZXlvZiBUXS0/OiB7fSBleHRlbmRzIFBpY2s8VCwgSz4gPyBLIDogbmV2ZXJcbn1ba2V5b2YgVF1cblxudHlwZSBPbk5hdmlnYXRlRXZlbnRIYW5kbGVyID0gKGV2ZW50OiB7IHByZXZlbnREZWZhdWx0OiAoKSA9PiB2b2lkIH0pID0+IHZvaWRcblxudHlwZSBJbnRlcm5hbExpbmtQcm9wcyA9IHtcbiAgLyoqXG4gICAqICoqUmVxdWlyZWQqKi4gVGhlIHBhdGggb3IgVVJMIHRvIG5hdmlnYXRlIHRvLiBJdCBjYW4gYWxzbyBiZSBhbiBvYmplY3QgKHNpbWlsYXIgdG8gYFVSTGApLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c3hcbiAgICogLy8gTmF2aWdhdGUgdG8gL2Rhc2hib2FyZDpcbiAgICogPExpbmsgaHJlZj1cIi9kYXNoYm9hcmRcIj5EYXNoYm9hcmQ8L0xpbms+XG4gICAqXG4gICAqIC8vIE5hdmlnYXRlIHRvIC9hYm91dD9uYW1lPXRlc3Q6XG4gICAqIDxMaW5rIGhyZWY9e3sgcGF0aG5hbWU6ICcvYWJvdXQnLCBxdWVyeTogeyBuYW1lOiAndGVzdCcgfSB9fT5cbiAgICogICBBYm91dFxuICAgKiA8L0xpbms+XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiAtIEZvciBleHRlcm5hbCBVUkxzLCB1c2UgYSBmdWxseSBxdWFsaWZpZWQgVVJMIHN1Y2ggYXMgYGh0dHBzOi8vLi4uYC5cbiAgICogLSBJbiB0aGUgQXBwIFJvdXRlciwgZHluYW1pYyByb3V0ZXMgbXVzdCBub3QgaW5jbHVkZSBicmFja2V0ZWQgc2VnbWVudHMgaW4gYGhyZWZgLlxuICAgKi9cbiAgaHJlZjogVXJsXG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHYxMC4wLjA6IGBocmVmYCBwcm9wcyBwb2ludGluZyB0byBhIGR5bmFtaWMgcm91dGUgYXJlXG4gICAqIGF1dG9tYXRpY2FsbHkgcmVzb2x2ZWQgYW5kIG5vIGxvbmdlciByZXF1aXJlIHRoZSBgYXNgIHByb3AuXG4gICAqL1xuICBhcz86IFVybFxuXG4gIC8qKlxuICAgKiBSZXBsYWNlIHRoZSBjdXJyZW50IGBoaXN0b3J5YCBzdGF0ZSBpbnN0ZWFkIG9mIGFkZGluZyBhIG5ldyBVUkwgaW50byB0aGUgc3RhY2suXG4gICAqXG4gICAqIEBkZWZhdWx0VmFsdWUgYGZhbHNlYFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c3hcbiAgICogPExpbmsgaHJlZj1cIi9hYm91dFwiIHJlcGxhY2U+XG4gICAqICAgQWJvdXQgKHJlcGxhY2VzIHRoZSBoaXN0b3J5IHN0YXRlKVxuICAgKiA8L0xpbms+XG4gICAqIGBgYFxuICAgKi9cbiAgcmVwbGFjZT86IGJvb2xlYW5cblxuICAvKipcbiAgICogV2hldGhlciB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBzY3JvbGwgYmVoYXZpb3IuIElmIGB0cnVlYCwgTmV4dC5qcyBhdHRlbXB0cyB0byBtYWludGFpblxuICAgKiB0aGUgc2Nyb2xsIHBvc2l0aW9uIGlmIHRoZSBuZXdseSBuYXZpZ2F0ZWQgcGFnZSBpcyBzdGlsbCB2aXNpYmxlLiBJZiBub3QsIGl0IHNjcm9sbHMgdG8gdGhlIHRvcC5cbiAgICpcbiAgICogSWYgYGZhbHNlYCwgTmV4dC5qcyB3aWxsIG5vdCBtb2RpZnkgdGhlIHNjcm9sbCBiZWhhdmlvciBhdCBhbGwuXG4gICAqXG4gICAqIEBkZWZhdWx0VmFsdWUgYHRydWVgXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzeFxuICAgKiA8TGluayBocmVmPVwiL2Rhc2hib2FyZFwiIHNjcm9sbD17ZmFsc2V9PlxuICAgKiAgIE5vIGF1dG8gc2Nyb2xsXG4gICAqIDwvTGluaz5cbiAgICogYGBgXG4gICAqL1xuICBzY3JvbGw/OiBib29sZWFuXG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgcGF0aCBvZiB0aGUgY3VycmVudCBwYWdlIHdpdGhvdXQgcmVydW5uaW5nIGRhdGEgZmV0Y2hpbmcgbWV0aG9kc1xuICAgKiBsaWtlIGBnZXRTdGF0aWNQcm9wc2AsIGBnZXRTZXJ2ZXJTaWRlUHJvcHNgLCBvciBgZ2V0SW5pdGlhbFByb3BzYC5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogYHNoYWxsb3dgIG9ubHkgYXBwbGllcyB0byB0aGUgUGFnZXMgUm91dGVyLiBGb3IgdGhlIEFwcCBSb3V0ZXIsIHNlZSB0aGVcbiAgICogW2ZvbGxvd2luZyBkb2N1bWVudGF0aW9uXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYnVpbGRpbmcteW91ci1hcHBsaWNhdGlvbi9yb3V0aW5nL2xpbmtpbmctYW5kLW5hdmlnYXRpbmcjdXNpbmctdGhlLW5hdGl2ZS1oaXN0b3J5LWFwaSkuXG4gICAqXG4gICAqIEBkZWZhdWx0VmFsdWUgYGZhbHNlYFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c3hcbiAgICogPExpbmsgaHJlZj1cIi9ibG9nXCIgc2hhbGxvdz5cbiAgICogICBTaGFsbG93IG5hdmlnYXRpb25cbiAgICogPC9MaW5rPlxuICAgKiBgYGBcbiAgICovXG4gIHNoYWxsb3c/OiBib29sZWFuXG5cbiAgLyoqXG4gICAqIEZvcmNlcyBgTGlua2AgdG8gcGFzcyBpdHMgYGhyZWZgIHRvIHRoZSBjaGlsZCBjb21wb25lbnQuIFVzZWZ1bCBpZiB0aGUgY2hpbGQgaXMgYSBjdXN0b21cbiAgICogY29tcG9uZW50IHRoYXQgd3JhcHMgYW4gYDxhPmAgdGFnLCBvciBpZiB5b3UncmUgdXNpbmcgY2VydGFpbiBzdHlsaW5nIGxpYnJhcmllcy5cbiAgICpcbiAgICogQGRlZmF1bHRWYWx1ZSBgZmFsc2VgXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzeFxuICAgKiA8TGluayBocmVmPVwiL2Rhc2hib2FyZFwiIHBhc3NIcmVmPlxuICAgKiAgIDxNeVN0eWxlZEFuY2hvcj5EYXNoYm9hcmQ8L015U3R5bGVkQW5jaG9yPlxuICAgKiA8L0xpbms+XG4gICAqIGBgYFxuICAgKi9cbiAgcGFzc0hyZWY/OiBib29sZWFuXG5cbiAgLyoqXG4gICAqIFByZWZldGNoIHRoZSBwYWdlIGluIHRoZSBiYWNrZ3JvdW5kLlxuICAgKiBBbnkgYDxMaW5rIC8+YCB0aGF0IGlzIGluIHRoZSB2aWV3cG9ydCAoaW5pdGlhbGx5IG9yIHRocm91Z2ggc2Nyb2xsKSB3aWxsIGJlIHByZWZldGNoZWQuXG4gICAqIFByZWZldGNoIGNhbiBiZSBkaXNhYmxlZCBieSBwYXNzaW5nIGBwcmVmZXRjaD17ZmFsc2V9YC5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogUHJlZmV0Y2hpbmcgaXMgb25seSBlbmFibGVkIGluIHByb2R1Y3Rpb24uXG4gICAqXG4gICAqIC0gSW4gdGhlICoqQXBwIFJvdXRlcioqOlxuICAgKiAgIC0gYFwiYXV0b1wiYCwgYG51bGxgLCBgdW5kZWZpbmVkYCAoZGVmYXVsdCk6IFByZWZldGNoIGJlaGF2aW9yIGRlcGVuZHMgb24gc3RhdGljIHZzIGR5bmFtaWMgcm91dGVzOlxuICAgKiAgICAgLSBTdGF0aWMgcm91dGVzOiBmdWxseSBwcmVmZXRjaGVkXG4gICAqICAgICAtIER5bmFtaWMgcm91dGVzOiBwYXJ0aWFsIHByZWZldGNoIHRvIHRoZSBuZWFyZXN0IHNlZ21lbnQgd2l0aCBhIGBsb2FkaW5nLmpzYFxuICAgKiAgIC0gYHRydWVgOiBBbHdheXMgcHJlZmV0Y2ggdGhlIGZ1bGwgcm91dGUgYW5kIGRhdGEuXG4gICAqICAgLSBgZmFsc2VgOiBEaXNhYmxlIHByZWZldGNoaW5nIG9uIGJvdGggdmlld3BvcnQgYW5kIGhvdmVyLlxuICAgKiAtIEluIHRoZSAqKlBhZ2VzIFJvdXRlcioqOlxuICAgKiAgIC0gYHRydWVgIChkZWZhdWx0KTogUHJlZmV0Y2hlcyB0aGUgcm91dGUgYW5kIGRhdGEgaW4gdGhlIGJhY2tncm91bmQgb24gdmlld3BvcnQgb3IgaG92ZXIuXG4gICAqICAgLSBgZmFsc2VgOiBQcmVmZXRjaCBvbmx5IG9uIGhvdmVyLCBub3Qgb24gdmlld3BvcnQuXG4gICAqXG4gICAqIEBkZWZhdWx0VmFsdWUgYHRydWVgIChQYWdlcyBSb3V0ZXIpIG9yIGBudWxsYCAoQXBwIFJvdXRlcilcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHN4XG4gICAqIDxMaW5rIGhyZWY9XCIvZGFzaGJvYXJkXCIgcHJlZmV0Y2g9e2ZhbHNlfT5cbiAgICogICBEYXNoYm9hcmRcbiAgICogPC9MaW5rPlxuICAgKiBgYGBcbiAgICovXG4gIHByZWZldGNoPzogYm9vbGVhbiB8ICdhdXRvJyB8IG51bGxcblxuICAvKipcbiAgICogKHVuc3RhYmxlKSBTd2l0Y2ggdG8gYSBkeW5hbWljIHByZWZldGNoIG9uIGhvdmVyLiBFZmZlY3RpdmVseSB0aGUgc2FtZSBhc1xuICAgKiB1cGRhdGluZyB0aGUgcHJlZmV0Y2ggcHJvcCB0byBgdHJ1ZWAgaW4gYSBtb3VzZSBldmVudC5cbiAgICovXG4gIHVuc3RhYmxlX2R5bmFtaWNPbkhvdmVyPzogYm9vbGVhblxuXG4gIC8qKlxuICAgKiBUaGUgYWN0aXZlIGxvY2FsZSBpcyBhdXRvbWF0aWNhbGx5IHByZXBlbmRlZCBpbiB0aGUgUGFnZXMgUm91dGVyLiBgbG9jYWxlYCBhbGxvd3MgZm9yIHByb3ZpZGluZ1xuICAgKiBhIGRpZmZlcmVudCBsb2NhbGUsIG9yIGNhbiBiZSBzZXQgdG8gYGZhbHNlYCB0byBvcHQgb3V0IG9mIGF1dG9tYXRpYyBsb2NhbGUgYmVoYXZpb3IuXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIE5vdGU6IGxvY2FsZSBvbmx5IGFwcGxpZXMgaW4gdGhlIFBhZ2VzIFJvdXRlciBhbmQgaXMgaWdub3JlZCBpbiB0aGUgQXBwIFJvdXRlci5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHN4XG4gICAqIC8vIFVzZSB0aGUgJ2ZyJyBsb2NhbGU6XG4gICAqIDxMaW5rIGhyZWY9XCIvYWJvdXRcIiBsb2NhbGU9XCJmclwiPlxuICAgKiAgIEFib3V0IChGcmVuY2gpXG4gICAqIDwvTGluaz5cbiAgICpcbiAgICogLy8gRGlzYWJsZSBsb2NhbGUgcHJlZml4OlxuICAgKiA8TGluayBocmVmPVwiL2Fib3V0XCIgbG9jYWxlPXtmYWxzZX0+XG4gICAqICAgQWJvdXQgKG5vIGxvY2FsZSBwcmVmaXgpXG4gICAqIDwvTGluaz5cbiAgICogYGBgXG4gICAqL1xuICBsb2NhbGU/OiBzdHJpbmcgfCBmYWxzZVxuXG4gIC8qKlxuICAgKiBFbmFibGUgbGVnYWN5IGxpbmsgYmVoYXZpb3IsIHJlcXVpcmluZyBhbiBgPGE+YCB0YWcgdG8gd3JhcCB0aGUgY2hpbGQgY29udGVudFxuICAgKiBpZiB0aGUgY2hpbGQgaXMgYSBzdHJpbmcgb3IgbnVtYmVyLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBUaGlzIHdpbGwgYmUgcmVtb3ZlZCBpbiB2MTZcbiAgICogQGRlZmF1bHRWYWx1ZSBgZmFsc2VgXG4gICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3ZlcmNlbC9uZXh0LmpzL2NvbW1pdC80ODllNjVlZDk4NTQ0ZTY5YjBhZmQ3ZTBjZmMzZjlmNmMyYjgwM2I3XG4gICAqL1xuICBsZWdhY3lCZWhhdmlvcj86IGJvb2xlYW5cblxuICAvKipcbiAgICogT3B0aW9uYWwgZXZlbnQgaGFuZGxlciBmb3Igd2hlbiB0aGUgbW91c2UgcG9pbnRlciBpcyBtb3ZlZCBvbnRvIHRoZSBgPExpbms+YC5cbiAgICovXG4gIG9uTW91c2VFbnRlcj86IFJlYWN0Lk1vdXNlRXZlbnRIYW5kbGVyPEhUTUxBbmNob3JFbGVtZW50PlxuXG4gIC8qKlxuICAgKiBPcHRpb25hbCBldmVudCBoYW5kbGVyIGZvciB3aGVuIHRoZSBgPExpbms+YCBpcyB0b3VjaGVkLlxuICAgKi9cbiAgb25Ub3VjaFN0YXJ0PzogUmVhY3QuVG91Y2hFdmVudEhhbmRsZXI8SFRNTEFuY2hvckVsZW1lbnQ+XG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsIGV2ZW50IGhhbmRsZXIgZm9yIHdoZW4gdGhlIGA8TGluaz5gIGlzIGNsaWNrZWQuXG4gICAqL1xuICBvbkNsaWNrPzogUmVhY3QuTW91c2VFdmVudEhhbmRsZXI8SFRNTEFuY2hvckVsZW1lbnQ+XG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsIGV2ZW50IGhhbmRsZXIgZm9yIHdoZW4gdGhlIGA8TGluaz5gIGlzIG5hdmlnYXRlZC5cbiAgICovXG4gIG9uTmF2aWdhdGU/OiBPbk5hdmlnYXRlRXZlbnRIYW5kbGVyXG59XG5cbi8vIFRPRE8tQVBQOiBJbmNsdWRlIHRoZSBmdWxsIHNldCBvZiBBbmNob3IgcHJvcHNcbi8vIGFkZGluZyB0aGlzIHRvIHRoZSBwdWJsaWNseSBleHBvcnRlZCB0eXBlIGN1cnJlbnRseSBicmVha3MgZXhpc3RpbmcgYXBwc1xuXG4vLyBgUm91dGVJbmZlclR5cGVgIGlzIGEgc3R1YiBoZXJlIHRvIGF2b2lkIGJyZWFraW5nIGB0eXBlZFJvdXRlc2Agd2hlbiB0aGUgdHlwZVxuLy8gaXNuJ3QgZ2VuZXJhdGVkIHlldC4gSXQgd2lsbCBiZSByZXBsYWNlZCB3aGVuIHRoZSB3ZWJwYWNrIHBsdWdpbiBydW5zLlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuZXhwb3J0IHR5cGUgTGlua1Byb3BzPFJvdXRlSW5mZXJUeXBlID0gYW55PiA9IEludGVybmFsTGlua1Byb3BzXG50eXBlIExpbmtQcm9wc1JlcXVpcmVkID0gUmVxdWlyZWRLZXlzPExpbmtQcm9wcz5cbnR5cGUgTGlua1Byb3BzT3B0aW9uYWwgPSBPcHRpb25hbEtleXM8T21pdDxJbnRlcm5hbExpbmtQcm9wcywgJ2xvY2FsZSc+PlxuXG5mdW5jdGlvbiBpc01vZGlmaWVkRXZlbnQoZXZlbnQ6IFJlYWN0Lk1vdXNlRXZlbnQpOiBib29sZWFuIHtcbiAgY29uc3QgZXZlbnRUYXJnZXQgPSBldmVudC5jdXJyZW50VGFyZ2V0IGFzIEhUTUxBbmNob3JFbGVtZW50IHwgU1ZHQUVsZW1lbnRcbiAgY29uc3QgdGFyZ2V0ID0gZXZlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKCd0YXJnZXQnKVxuICByZXR1cm4gKFxuICAgICh0YXJnZXQgJiYgdGFyZ2V0ICE9PSAnX3NlbGYnKSB8fFxuICAgIGV2ZW50Lm1ldGFLZXkgfHxcbiAgICBldmVudC5jdHJsS2V5IHx8XG4gICAgZXZlbnQuc2hpZnRLZXkgfHxcbiAgICBldmVudC5hbHRLZXkgfHwgLy8gdHJpZ2dlcnMgcmVzb3VyY2UgZG93bmxvYWRcbiAgICAoZXZlbnQubmF0aXZlRXZlbnQgJiYgZXZlbnQubmF0aXZlRXZlbnQud2hpY2ggPT09IDIpXG4gIClcbn1cblxuZnVuY3Rpb24gbGlua0NsaWNrZWQoXG4gIGU6IFJlYWN0Lk1vdXNlRXZlbnQsXG4gIGhyZWY6IHN0cmluZyxcbiAgYXM6IHN0cmluZyxcbiAgbGlua0luc3RhbmNlUmVmOiBSZWFjdC5SZWZPYmplY3Q8TGlua0luc3RhbmNlIHwgbnVsbD4sXG4gIHJlcGxhY2U/OiBib29sZWFuLFxuICBzY3JvbGw/OiBib29sZWFuLFxuICBvbk5hdmlnYXRlPzogT25OYXZpZ2F0ZUV2ZW50SGFuZGxlclxuKTogdm9pZCB7XG4gIGNvbnN0IHsgbm9kZU5hbWUgfSA9IGUuY3VycmVudFRhcmdldFxuXG4gIC8vIGFuY2hvcnMgaW5zaWRlIGFuIHN2ZyBoYXZlIGEgbG93ZXJjYXNlIG5vZGVOYW1lXG4gIGNvbnN0IGlzQW5jaG9yTm9kZU5hbWUgPSBub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09PSAnQSdcblxuICBpZiAoXG4gICAgKGlzQW5jaG9yTm9kZU5hbWUgJiYgaXNNb2RpZmllZEV2ZW50KGUpKSB8fFxuICAgIGUuY3VycmVudFRhcmdldC5oYXNBdHRyaWJ1dGUoJ2Rvd25sb2FkJylcbiAgKSB7XG4gICAgLy8gaWdub3JlIGNsaWNrIGZvciBicm93c2Vy4oCZcyBkZWZhdWx0IGJlaGF2aW9yXG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAoIWlzTG9jYWxVUkwoaHJlZikpIHtcbiAgICBpZiAocmVwbGFjZSkge1xuICAgICAgLy8gYnJvd3NlciBkZWZhdWx0IGJlaGF2aW9yIGRvZXMgbm90IHJlcGxhY2UgdGhlIGhpc3Rvcnkgc3RhdGVcbiAgICAgIC8vIHNvIHdlIG5lZWQgdG8gZG8gaXQgbWFudWFsbHlcbiAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgbG9jYXRpb24ucmVwbGFjZShocmVmKVxuICAgIH1cblxuICAgIC8vIGlnbm9yZSBjbGljayBmb3IgYnJvd3NlcuKAmXMgZGVmYXVsdCBiZWhhdmlvclxuICAgIHJldHVyblxuICB9XG5cbiAgZS5wcmV2ZW50RGVmYXVsdCgpXG5cbiAgaWYgKG9uTmF2aWdhdGUpIHtcbiAgICBsZXQgaXNEZWZhdWx0UHJldmVudGVkID0gZmFsc2VcblxuICAgIG9uTmF2aWdhdGUoe1xuICAgICAgcHJldmVudERlZmF1bHQ6ICgpID0+IHtcbiAgICAgICAgaXNEZWZhdWx0UHJldmVudGVkID0gdHJ1ZVxuICAgICAgfSxcbiAgICB9KVxuXG4gICAgaWYgKGlzRGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG5cbiAgUmVhY3Quc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICBkaXNwYXRjaE5hdmlnYXRlQWN0aW9uKFxuICAgICAgYXMgfHwgaHJlZixcbiAgICAgIHJlcGxhY2UgPyAncmVwbGFjZScgOiAncHVzaCcsXG4gICAgICBzY3JvbGwgPz8gdHJ1ZSxcbiAgICAgIGxpbmtJbnN0YW5jZVJlZi5jdXJyZW50XG4gICAgKVxuICB9KVxufVxuXG5mdW5jdGlvbiBmb3JtYXRTdHJpbmdPclVybCh1cmxPYmpPclN0cmluZzogVXJsT2JqZWN0IHwgc3RyaW5nKTogc3RyaW5nIHtcbiAgaWYgKHR5cGVvZiB1cmxPYmpPclN0cmluZyA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdXJsT2JqT3JTdHJpbmdcbiAgfVxuXG4gIHJldHVybiBmb3JtYXRVcmwodXJsT2JqT3JTdHJpbmcpXG59XG5cbi8qKlxuICogQSBSZWFjdCBjb21wb25lbnQgdGhhdCBleHRlbmRzIHRoZSBIVE1MIGA8YT5gIGVsZW1lbnQgdG8gcHJvdmlkZVxuICogW3ByZWZldGNoaW5nXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYnVpbGRpbmcteW91ci1hcHBsaWNhdGlvbi9yb3V0aW5nL2xpbmtpbmctYW5kLW5hdmlnYXRpbmcjMi1wcmVmZXRjaGluZylcbiAqIGFuZCBjbGllbnQtc2lkZSBuYXZpZ2F0aW9uLiBUaGlzIGlzIHRoZSBwcmltYXJ5IHdheSB0byBuYXZpZ2F0ZSBiZXR3ZWVuIHJvdXRlcyBpbiBOZXh0LmpzLlxuICpcbiAqIEByZW1hcmtzXG4gKiAtIFByZWZldGNoaW5nIGlzIG9ubHkgZW5hYmxlZCBpbiBwcm9kdWN0aW9uLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2FwaS1yZWZlcmVuY2UvY29tcG9uZW50cy9saW5rXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIExpbmtDb21wb25lbnQoXG4gIHByb3BzOiBMaW5rUHJvcHMgJiB7XG4gICAgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZVxuICAgIHJlZjogUmVhY3QuUmVmPEhUTUxBbmNob3JFbGVtZW50PlxuICB9XG4pIHtcbiAgY29uc3QgW2xpbmtTdGF0dXMsIHNldE9wdGltaXN0aWNMaW5rU3RhdHVzXSA9IHVzZU9wdGltaXN0aWMoSURMRV9MSU5LX1NUQVRVUylcblxuICBsZXQgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZVxuXG4gIGNvbnN0IGxpbmtJbnN0YW5jZVJlZiA9IHVzZVJlZjxMaW5rSW5zdGFuY2UgfCBudWxsPihudWxsKVxuXG4gIGNvbnN0IHtcbiAgICBocmVmOiBocmVmUHJvcCxcbiAgICBhczogYXNQcm9wLFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlblByb3AsXG4gICAgcHJlZmV0Y2g6IHByZWZldGNoUHJvcCA9IG51bGwsXG4gICAgcGFzc0hyZWYsXG4gICAgcmVwbGFjZSxcbiAgICBzaGFsbG93LFxuICAgIHNjcm9sbCxcbiAgICBvbkNsaWNrLFxuICAgIG9uTW91c2VFbnRlcjogb25Nb3VzZUVudGVyUHJvcCxcbiAgICBvblRvdWNoU3RhcnQ6IG9uVG91Y2hTdGFydFByb3AsXG4gICAgbGVnYWN5QmVoYXZpb3IgPSBmYWxzZSxcbiAgICBvbk5hdmlnYXRlLFxuICAgIHJlZjogZm9yd2FyZGVkUmVmLFxuICAgIHVuc3RhYmxlX2R5bmFtaWNPbkhvdmVyLFxuICAgIC4uLnJlc3RQcm9wc1xuICB9ID0gcHJvcHNcblxuICBjaGlsZHJlbiA9IGNoaWxkcmVuUHJvcFxuXG4gIGlmIChcbiAgICBsZWdhY3lCZWhhdmlvciAmJlxuICAgICh0eXBlb2YgY2hpbGRyZW4gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBjaGlsZHJlbiA9PT0gJ251bWJlcicpXG4gICkge1xuICAgIGNoaWxkcmVuID0gPGE+e2NoaWxkcmVufTwvYT5cbiAgfVxuXG4gIGNvbnN0IHJvdXRlciA9IFJlYWN0LnVzZUNvbnRleHQoQXBwUm91dGVyQ29udGV4dClcblxuICBjb25zdCBwcmVmZXRjaEVuYWJsZWQgPSBwcmVmZXRjaFByb3AgIT09IGZhbHNlXG4gIC8qKlxuICAgKiBUaGUgcG9zc2libGUgc3RhdGVzIGZvciBwcmVmZXRjaCBhcmU6XG4gICAqIC0gbnVsbDogdGhpcyBpcyB0aGUgZGVmYXVsdCBcImF1dG9cIiBtb2RlLCB3aGVyZSB3ZSB3aWxsIHByZWZldGNoIHBhcnRpYWxseSBpZiB0aGUgbGluayBpcyBpbiB0aGUgdmlld3BvcnRcbiAgICogLSB0cnVlOiB3ZSB3aWxsIHByZWZldGNoIGlmIHRoZSBsaW5rIGlzIHZpc2libGUgYW5kIHByZWZldGNoIHRoZSBmdWxsIHBhZ2UsIG5vdCBqdXN0IHBhcnRpYWxseVxuICAgKiAtIGZhbHNlOiB3ZSB3aWxsIG5vdCBwcmVmZXRjaCBpZiBpbiB0aGUgdmlld3BvcnQgYXQgYWxsXG4gICAqIC0gJ3Vuc3RhYmxlX2R5bmFtaWNPbkhvdmVyJzogdGhpcyBzdGFydHMgaW4gXCJhdXRvXCIgbW9kZSwgYnV0IHN3aXRjaGVzIHRvIFwiZnVsbFwiIHdoZW4gdGhlIGxpbmsgaXMgaG92ZXJlZFxuICAgKi9cbiAgY29uc3QgYXBwUHJlZmV0Y2hLaW5kID1cbiAgICBwcmVmZXRjaFByb3AgPT09IG51bGwgfHwgcHJlZmV0Y2hQcm9wID09PSAnYXV0bydcbiAgICAgID8gUHJlZmV0Y2hLaW5kLkFVVE9cbiAgICAgIDogUHJlZmV0Y2hLaW5kLkZVTExcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVByb3BFcnJvcihhcmdzOiB7XG4gICAgICBrZXk6IHN0cmluZ1xuICAgICAgZXhwZWN0ZWQ6IHN0cmluZ1xuICAgICAgYWN0dWFsOiBzdHJpbmdcbiAgICB9KSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgICAgICBgRmFpbGVkIHByb3AgdHlwZTogVGhlIHByb3AgXFxgJHthcmdzLmtleX1cXGAgZXhwZWN0cyBhICR7YXJncy5leHBlY3RlZH0gaW4gXFxgPExpbms+XFxgLCBidXQgZ290IFxcYCR7YXJncy5hY3R1YWx9XFxgIGluc3RlYWQuYCArXG4gICAgICAgICAgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICA/IFwiXFxuT3BlbiB5b3VyIGJyb3dzZXIncyBjb25zb2xlIHRvIHZpZXcgdGhlIENvbXBvbmVudCBzdGFjayB0cmFjZS5cIlxuICAgICAgICAgICAgOiAnJylcbiAgICAgIClcbiAgICB9XG5cbiAgICAvLyBUeXBlU2NyaXB0IHRyaWNrIGZvciB0eXBlLWd1YXJkaW5nOlxuICAgIGNvbnN0IHJlcXVpcmVkUHJvcHNHdWFyZDogUmVjb3JkPExpbmtQcm9wc1JlcXVpcmVkLCB0cnVlPiA9IHtcbiAgICAgIGhyZWY6IHRydWUsXG4gICAgfSBhcyBjb25zdFxuICAgIGNvbnN0IHJlcXVpcmVkUHJvcHM6IExpbmtQcm9wc1JlcXVpcmVkW10gPSBPYmplY3Qua2V5cyhcbiAgICAgIHJlcXVpcmVkUHJvcHNHdWFyZFxuICAgICkgYXMgTGlua1Byb3BzUmVxdWlyZWRbXVxuICAgIHJlcXVpcmVkUHJvcHMuZm9yRWFjaCgoa2V5OiBMaW5rUHJvcHNSZXF1aXJlZCkgPT4ge1xuICAgICAgaWYgKGtleSA9PT0gJ2hyZWYnKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBwcm9wc1trZXldID09IG51bGwgfHxcbiAgICAgICAgICAodHlwZW9mIHByb3BzW2tleV0gIT09ICdzdHJpbmcnICYmIHR5cGVvZiBwcm9wc1trZXldICE9PSAnb2JqZWN0JylcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhyb3cgY3JlYXRlUHJvcEVycm9yKHtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIGV4cGVjdGVkOiAnYHN0cmluZ2Agb3IgYG9iamVjdGAnLFxuICAgICAgICAgICAgYWN0dWFsOiBwcm9wc1trZXldID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIHByb3BzW2tleV0sXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVHlwZVNjcmlwdCB0cmljayBmb3IgdHlwZS1ndWFyZGluZzpcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgICBjb25zdCBfOiBuZXZlciA9IGtleVxuICAgICAgfVxuICAgIH0pXG5cbiAgICAvLyBUeXBlU2NyaXB0IHRyaWNrIGZvciB0eXBlLWd1YXJkaW5nOlxuICAgIGNvbnN0IG9wdGlvbmFsUHJvcHNHdWFyZDogUmVjb3JkPExpbmtQcm9wc09wdGlvbmFsLCB0cnVlPiA9IHtcbiAgICAgIGFzOiB0cnVlLFxuICAgICAgcmVwbGFjZTogdHJ1ZSxcbiAgICAgIHNjcm9sbDogdHJ1ZSxcbiAgICAgIHNoYWxsb3c6IHRydWUsXG4gICAgICBwYXNzSHJlZjogdHJ1ZSxcbiAgICAgIHByZWZldGNoOiB0cnVlLFxuICAgICAgdW5zdGFibGVfZHluYW1pY09uSG92ZXI6IHRydWUsXG4gICAgICBvbkNsaWNrOiB0cnVlLFxuICAgICAgb25Nb3VzZUVudGVyOiB0cnVlLFxuICAgICAgb25Ub3VjaFN0YXJ0OiB0cnVlLFxuICAgICAgbGVnYWN5QmVoYXZpb3I6IHRydWUsXG4gICAgICBvbk5hdmlnYXRlOiB0cnVlLFxuICAgIH0gYXMgY29uc3RcbiAgICBjb25zdCBvcHRpb25hbFByb3BzOiBMaW5rUHJvcHNPcHRpb25hbFtdID0gT2JqZWN0LmtleXMoXG4gICAgICBvcHRpb25hbFByb3BzR3VhcmRcbiAgICApIGFzIExpbmtQcm9wc09wdGlvbmFsW11cbiAgICBvcHRpb25hbFByb3BzLmZvckVhY2goKGtleTogTGlua1Byb3BzT3B0aW9uYWwpID0+IHtcbiAgICAgIGNvbnN0IHZhbFR5cGUgPSB0eXBlb2YgcHJvcHNba2V5XVxuXG4gICAgICBpZiAoa2V5ID09PSAnYXMnKSB7XG4gICAgICAgIGlmIChwcm9wc1trZXldICYmIHZhbFR5cGUgIT09ICdzdHJpbmcnICYmIHZhbFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgdGhyb3cgY3JlYXRlUHJvcEVycm9yKHtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIGV4cGVjdGVkOiAnYHN0cmluZ2Agb3IgYG9iamVjdGAnLFxuICAgICAgICAgICAgYWN0dWFsOiB2YWxUeXBlLFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGtleSA9PT0gJ29uQ2xpY2snIHx8XG4gICAgICAgIGtleSA9PT0gJ29uTW91c2VFbnRlcicgfHxcbiAgICAgICAga2V5ID09PSAnb25Ub3VjaFN0YXJ0JyB8fFxuICAgICAgICBrZXkgPT09ICdvbk5hdmlnYXRlJ1xuICAgICAgKSB7XG4gICAgICAgIGlmIChwcm9wc1trZXldICYmIHZhbFR5cGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aHJvdyBjcmVhdGVQcm9wRXJyb3Ioe1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgZXhwZWN0ZWQ6ICdgZnVuY3Rpb25gJyxcbiAgICAgICAgICAgIGFjdHVhbDogdmFsVHlwZSxcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBrZXkgPT09ICdyZXBsYWNlJyB8fFxuICAgICAgICBrZXkgPT09ICdzY3JvbGwnIHx8XG4gICAgICAgIGtleSA9PT0gJ3NoYWxsb3cnIHx8XG4gICAgICAgIGtleSA9PT0gJ3Bhc3NIcmVmJyB8fFxuICAgICAgICBrZXkgPT09ICdsZWdhY3lCZWhhdmlvcicgfHxcbiAgICAgICAga2V5ID09PSAndW5zdGFibGVfZHluYW1pY09uSG92ZXInXG4gICAgICApIHtcbiAgICAgICAgaWYgKHByb3BzW2tleV0gIT0gbnVsbCAmJiB2YWxUeXBlICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICB0aHJvdyBjcmVhdGVQcm9wRXJyb3Ioe1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgZXhwZWN0ZWQ6ICdgYm9vbGVhbmAnLFxuICAgICAgICAgICAgYWN0dWFsOiB2YWxUeXBlLFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAncHJlZmV0Y2gnKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBwcm9wc1trZXldICE9IG51bGwgJiZcbiAgICAgICAgICB2YWxUeXBlICE9PSAnYm9vbGVhbicgJiZcbiAgICAgICAgICBwcm9wc1trZXldICE9PSAnYXV0bydcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhyb3cgY3JlYXRlUHJvcEVycm9yKHtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIGV4cGVjdGVkOiAnYGJvb2xlYW4gfCBcImF1dG9cImAnLFxuICAgICAgICAgICAgYWN0dWFsOiB2YWxUeXBlLFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFR5cGVTY3JpcHQgdHJpY2sgZm9yIHR5cGUtZ3VhcmRpbmc6XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgICAgY29uc3QgXzogbmV2ZXIgPSBrZXlcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAocHJvcHMubG9jYWxlKSB7XG4gICAgICB3YXJuT25jZShcbiAgICAgICAgJ1RoZSBgbG9jYWxlYCBwcm9wIGlzIG5vdCBzdXBwb3J0ZWQgaW4gYG5leHQvbGlua2Agd2hpbGUgdXNpbmcgdGhlIGBhcHBgIHJvdXRlci4gUmVhZCBtb3JlIGFib3V0IGFwcCByb3V0ZXIgaW50ZXJuYWxpemF0aW9uOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYnVpbGRpbmcteW91ci1hcHBsaWNhdGlvbi9yb3V0aW5nL2ludGVybmF0aW9uYWxpemF0aW9uJ1xuICAgICAgKVxuICAgIH1cbiAgICBpZiAoIWFzUHJvcCkge1xuICAgICAgbGV0IGhyZWY6IHN0cmluZyB8IHVuZGVmaW5lZFxuICAgICAgaWYgKHR5cGVvZiBocmVmUHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaHJlZiA9IGhyZWZQcm9wXG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICB0eXBlb2YgaHJlZlByb3AgPT09ICdvYmplY3QnICYmXG4gICAgICAgIHR5cGVvZiBocmVmUHJvcC5wYXRobmFtZSA9PT0gJ3N0cmluZydcbiAgICAgICkge1xuICAgICAgICBocmVmID0gaHJlZlByb3AucGF0aG5hbWVcbiAgICAgIH1cblxuICAgICAgaWYgKGhyZWYpIHtcbiAgICAgICAgY29uc3QgaGFzRHluYW1pY1NlZ21lbnQgPSBocmVmXG4gICAgICAgICAgLnNwbGl0KCcvJylcbiAgICAgICAgICAuc29tZSgoc2VnbWVudCkgPT4gc2VnbWVudC5zdGFydHNXaXRoKCdbJykgJiYgc2VnbWVudC5lbmRzV2l0aCgnXScpKVxuXG4gICAgICAgIGlmIChoYXNEeW5hbWljU2VnbWVudCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBEeW5hbWljIGhyZWYgXFxgJHtocmVmfVxcYCBmb3VuZCBpbiA8TGluaz4gd2hpbGUgdXNpbmcgdGhlIFxcYC9hcHBcXGAgcm91dGVyLCB0aGlzIGlzIG5vdCBzdXBwb3J0ZWQuIFJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvYXBwLWRpci1keW5hbWljLWhyZWZgXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29uc3QgeyBocmVmLCBhcyB9ID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgcmVzb2x2ZWRIcmVmID0gZm9ybWF0U3RyaW5nT3JVcmwoaHJlZlByb3ApXG4gICAgcmV0dXJuIHtcbiAgICAgIGhyZWY6IHJlc29sdmVkSHJlZixcbiAgICAgIGFzOiBhc1Byb3AgPyBmb3JtYXRTdHJpbmdPclVybChhc1Byb3ApIDogcmVzb2x2ZWRIcmVmLFxuICAgIH1cbiAgfSwgW2hyZWZQcm9wLCBhc1Byb3BdKVxuXG4gIC8vIFRoaXMgd2lsbCByZXR1cm4gdGhlIGZpcnN0IGNoaWxkLCBpZiBtdWx0aXBsZSBhcmUgcHJvdmlkZWQgaXQgd2lsbCB0aHJvdyBhbiBlcnJvclxuICBsZXQgY2hpbGQ6IGFueVxuICBpZiAobGVnYWN5QmVoYXZpb3IpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgIGlmIChvbkNsaWNrKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBgXCJvbkNsaWNrXCIgd2FzIHBhc3NlZCB0byA8TGluaz4gd2l0aCBcXGBocmVmXFxgIG9mIFxcYCR7aHJlZlByb3B9XFxgIGJ1dCBcImxlZ2FjeUJlaGF2aW9yXCIgd2FzIHNldC4gVGhlIGxlZ2FjeSBiZWhhdmlvciByZXF1aXJlcyBvbkNsaWNrIGJlIHNldCBvbiB0aGUgY2hpbGQgb2YgbmV4dC9saW5rYFxuICAgICAgICApXG4gICAgICB9XG4gICAgICBpZiAob25Nb3VzZUVudGVyUHJvcCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgYFwib25Nb3VzZUVudGVyXCIgd2FzIHBhc3NlZCB0byA8TGluaz4gd2l0aCBcXGBocmVmXFxgIG9mIFxcYCR7aHJlZlByb3B9XFxgIGJ1dCBcImxlZ2FjeUJlaGF2aW9yXCIgd2FzIHNldC4gVGhlIGxlZ2FjeSBiZWhhdmlvciByZXF1aXJlcyBvbk1vdXNlRW50ZXIgYmUgc2V0IG9uIHRoZSBjaGlsZCBvZiBuZXh0L2xpbmtgXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGNoaWxkID0gUmVhY3QuQ2hpbGRyZW4ub25seShjaGlsZHJlbilcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYE5vIGNoaWxkcmVuIHdlcmUgcGFzc2VkIHRvIDxMaW5rPiB3aXRoIFxcYGhyZWZcXGAgb2YgXFxgJHtocmVmUHJvcH1cXGAgYnV0IG9uZSBjaGlsZCBpcyByZXF1aXJlZCBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9saW5rLW5vLWNoaWxkcmVuYFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYE11bHRpcGxlIGNoaWxkcmVuIHdlcmUgcGFzc2VkIHRvIDxMaW5rPiB3aXRoIFxcYGhyZWZcXGAgb2YgXFxgJHtocmVmUHJvcH1cXGAgYnV0IG9ubHkgb25lIGNoaWxkIGlzIHN1cHBvcnRlZCBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9saW5rLW11bHRpcGxlLWNoaWxkcmVuYCArXG4gICAgICAgICAgICAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgPyBcIiBcXG5PcGVuIHlvdXIgYnJvd3NlcidzIGNvbnNvbGUgdG8gdmlldyB0aGUgQ29tcG9uZW50IHN0YWNrIHRyYWNlLlwiXG4gICAgICAgICAgICAgIDogJycpXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY2hpbGQgPSBSZWFjdC5DaGlsZHJlbi5vbmx5KGNoaWxkcmVuKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgIGlmICgoY2hpbGRyZW4gYXMgYW55KT8udHlwZSA9PT0gJ2EnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnSW52YWxpZCA8TGluaz4gd2l0aCA8YT4gY2hpbGQuIFBsZWFzZSByZW1vdmUgPGE+IG9yIHVzZSA8TGluayBsZWdhY3lCZWhhdmlvcj4uXFxuTGVhcm4gbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvaW52YWxpZC1uZXctbGluay13aXRoLWV4dHJhLWFuY2hvcidcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGNoaWxkUmVmOiBhbnkgPSBsZWdhY3lCZWhhdmlvclxuICAgID8gY2hpbGQgJiYgdHlwZW9mIGNoaWxkID09PSAnb2JqZWN0JyAmJiBjaGlsZC5yZWZcbiAgICA6IGZvcndhcmRlZFJlZlxuXG4gIC8vIFVzZSBhIGNhbGxiYWNrIHJlZiB0byBhdHRhY2ggYW4gSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgdG8gdGhlIGFuY2hvciB0YWcgb25cbiAgLy8gbW91bnQuIEluIHRoZSBmdXR1cmUgd2Ugd2lsbCBhbHNvIHVzZSB0aGlzIHRvIGtlZXAgdHJhY2sgb2YgYWxsIHRoZVxuICAvLyBjdXJyZW50bHkgbW91bnRlZCA8TGluaz4gaW5zdGFuY2VzLCBlLmcuIHNvIHdlIGNhbiByZS1wcmVmZXRjaCB0aGVtIGFmdGVyXG4gIC8vIGEgcmV2YWxpZGF0aW9uIG9yIHJlZnJlc2guXG4gIGNvbnN0IG9ic2VydmVMaW5rVmlzaWJpbGl0eU9uTW91bnQgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAoZWxlbWVudDogSFRNTEFuY2hvckVsZW1lbnQgfCBTVkdBRWxlbWVudCkgPT4ge1xuICAgICAgaWYgKHJvdXRlciAhPT0gbnVsbCkge1xuICAgICAgICBsaW5rSW5zdGFuY2VSZWYuY3VycmVudCA9IG1vdW50TGlua0luc3RhbmNlKFxuICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgaHJlZixcbiAgICAgICAgICByb3V0ZXIsXG4gICAgICAgICAgYXBwUHJlZmV0Y2hLaW5kLFxuICAgICAgICAgIHByZWZldGNoRW5hYmxlZCxcbiAgICAgICAgICBzZXRPcHRpbWlzdGljTGlua1N0YXR1c1xuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmIChsaW5rSW5zdGFuY2VSZWYuY3VycmVudCkge1xuICAgICAgICAgIHVubW91bnRMaW5rRm9yQ3VycmVudE5hdmlnYXRpb24obGlua0luc3RhbmNlUmVmLmN1cnJlbnQpXG4gICAgICAgICAgbGlua0luc3RhbmNlUmVmLmN1cnJlbnQgPSBudWxsXG4gICAgICAgIH1cbiAgICAgICAgdW5tb3VudFByZWZldGNoYWJsZUluc3RhbmNlKGVsZW1lbnQpXG4gICAgICB9XG4gICAgfSxcbiAgICBbcHJlZmV0Y2hFbmFibGVkLCBocmVmLCByb3V0ZXIsIGFwcFByZWZldGNoS2luZCwgc2V0T3B0aW1pc3RpY0xpbmtTdGF0dXNdXG4gIClcblxuICBjb25zdCBtZXJnZWRSZWYgPSB1c2VNZXJnZWRSZWYob2JzZXJ2ZUxpbmtWaXNpYmlsaXR5T25Nb3VudCwgY2hpbGRSZWYpXG5cbiAgY29uc3QgY2hpbGRQcm9wczoge1xuICAgIG9uVG91Y2hTdGFydD86IFJlYWN0LlRvdWNoRXZlbnRIYW5kbGVyPEhUTUxBbmNob3JFbGVtZW50PlxuICAgIG9uTW91c2VFbnRlcjogUmVhY3QuTW91c2VFdmVudEhhbmRsZXI8SFRNTEFuY2hvckVsZW1lbnQ+XG4gICAgb25DbGljazogUmVhY3QuTW91c2VFdmVudEhhbmRsZXI8SFRNTEFuY2hvckVsZW1lbnQ+XG4gICAgaHJlZj86IHN0cmluZ1xuICAgIHJlZj86IGFueVxuICB9ID0ge1xuICAgIHJlZjogbWVyZ2VkUmVmLFxuICAgIG9uQ2xpY2soZSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKCFlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYENvbXBvbmVudCByZW5kZXJlZCBpbnNpZGUgbmV4dC9saW5rIGhhcyB0byBwYXNzIGNsaWNrIGV2ZW50IHRvIFwib25DbGlja1wiIHByb3AuYFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWxlZ2FjeUJlaGF2aW9yICYmIHR5cGVvZiBvbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9uQ2xpY2soZSlcbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgICBsZWdhY3lCZWhhdmlvciAmJlxuICAgICAgICBjaGlsZC5wcm9wcyAmJlxuICAgICAgICB0eXBlb2YgY2hpbGQucHJvcHMub25DbGljayA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgKSB7XG4gICAgICAgIGNoaWxkLnByb3BzLm9uQ2xpY2soZSlcbiAgICAgIH1cblxuICAgICAgaWYgKCFyb3V0ZXIpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGlmIChlLmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGxpbmtDbGlja2VkKGUsIGhyZWYsIGFzLCBsaW5rSW5zdGFuY2VSZWYsIHJlcGxhY2UsIHNjcm9sbCwgb25OYXZpZ2F0ZSlcbiAgICB9LFxuICAgIG9uTW91c2VFbnRlcihlKSB7XG4gICAgICBpZiAoIWxlZ2FjeUJlaGF2aW9yICYmIHR5cGVvZiBvbk1vdXNlRW50ZXJQcm9wID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9uTW91c2VFbnRlclByb3AoZSlcbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgICBsZWdhY3lCZWhhdmlvciAmJlxuICAgICAgICBjaGlsZC5wcm9wcyAmJlxuICAgICAgICB0eXBlb2YgY2hpbGQucHJvcHMub25Nb3VzZUVudGVyID09PSAnZnVuY3Rpb24nXG4gICAgICApIHtcbiAgICAgICAgY2hpbGQucHJvcHMub25Nb3VzZUVudGVyKGUpXG4gICAgICB9XG5cbiAgICAgIGlmICghcm91dGVyKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAoIXByZWZldGNoRW5hYmxlZCB8fCBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgY29uc3QgdXBncmFkZVRvRHluYW1pY1ByZWZldGNoID0gdW5zdGFibGVfZHluYW1pY09uSG92ZXIgPT09IHRydWVcbiAgICAgIG9uTmF2aWdhdGlvbkludGVudChcbiAgICAgICAgZS5jdXJyZW50VGFyZ2V0IGFzIEhUTUxBbmNob3JFbGVtZW50IHwgU1ZHQUVsZW1lbnQsXG4gICAgICAgIHVwZ3JhZGVUb0R5bmFtaWNQcmVmZXRjaFxuICAgICAgKVxuICAgIH0sXG4gICAgb25Ub3VjaFN0YXJ0OiBwcm9jZXNzLmVudi5fX05FWFRfTElOS19OT19UT1VDSF9TVEFSVFxuICAgICAgPyB1bmRlZmluZWRcbiAgICAgIDogZnVuY3Rpb24gb25Ub3VjaFN0YXJ0KGUpIHtcbiAgICAgICAgICBpZiAoIWxlZ2FjeUJlaGF2aW9yICYmIHR5cGVvZiBvblRvdWNoU3RhcnRQcm9wID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBvblRvdWNoU3RhcnRQcm9wKGUpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgbGVnYWN5QmVoYXZpb3IgJiZcbiAgICAgICAgICAgIGNoaWxkLnByb3BzICYmXG4gICAgICAgICAgICB0eXBlb2YgY2hpbGQucHJvcHMub25Ub3VjaFN0YXJ0ID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBjaGlsZC5wcm9wcy5vblRvdWNoU3RhcnQoZSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIXJvdXRlcikge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFwcmVmZXRjaEVuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHVwZ3JhZGVUb0R5bmFtaWNQcmVmZXRjaCA9IHVuc3RhYmxlX2R5bmFtaWNPbkhvdmVyID09PSB0cnVlXG4gICAgICAgICAgb25OYXZpZ2F0aW9uSW50ZW50KFxuICAgICAgICAgICAgZS5jdXJyZW50VGFyZ2V0IGFzIEhUTUxBbmNob3JFbGVtZW50IHwgU1ZHQUVsZW1lbnQsXG4gICAgICAgICAgICB1cGdyYWRlVG9EeW5hbWljUHJlZmV0Y2hcbiAgICAgICAgICApXG4gICAgICAgIH0sXG4gIH1cblxuICAvLyBJZiBjaGlsZCBpcyBhbiA8YT4gdGFnIGFuZCBkb2Vzbid0IGhhdmUgYSBocmVmIGF0dHJpYnV0ZSwgb3IgaWYgdGhlICdwYXNzSHJlZicgcHJvcGVydHkgaXNcbiAgLy8gZGVmaW5lZCwgd2Ugc3BlY2lmeSB0aGUgY3VycmVudCAnaHJlZicsIHNvIHRoYXQgcmVwZXRpdGlvbiBpcyBub3QgbmVlZGVkIGJ5IHRoZSB1c2VyLlxuICAvLyBJZiB0aGUgdXJsIGlzIGFic29sdXRlLCB3ZSBjYW4gYnlwYXNzIHRoZSBsb2dpYyB0byBwcmVwZW5kIHRoZSBiYXNlUGF0aC5cbiAgaWYgKGlzQWJzb2x1dGVVcmwoYXMpKSB7XG4gICAgY2hpbGRQcm9wcy5ocmVmID0gYXNcbiAgfSBlbHNlIGlmIChcbiAgICAhbGVnYWN5QmVoYXZpb3IgfHxcbiAgICBwYXNzSHJlZiB8fFxuICAgIChjaGlsZC50eXBlID09PSAnYScgJiYgISgnaHJlZicgaW4gY2hpbGQucHJvcHMpKVxuICApIHtcbiAgICBjaGlsZFByb3BzLmhyZWYgPSBhZGRCYXNlUGF0aChhcylcbiAgfVxuXG4gIGxldCBsaW5rOiBSZWFjdC5SZWFjdE5vZGVcblxuICBpZiAobGVnYWN5QmVoYXZpb3IpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgIGVycm9yT25jZShcbiAgICAgICAgJ2BsZWdhY3lCZWhhdmlvcmAgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlICcgK1xuICAgICAgICAgICdyZWxlYXNlLiBBIGNvZGVtb2QgaXMgYXZhaWxhYmxlIHRvIHVwZ3JhZGUgeW91ciBjb21wb25lbnRzOlxcblxcbicgK1xuICAgICAgICAgICducHggQG5leHQvY29kZW1vZEBsYXRlc3QgbmV3LWxpbmsgLlxcblxcbicgK1xuICAgICAgICAgICdMZWFybiBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYnVpbGRpbmcteW91ci1hcHBsaWNhdGlvbi91cGdyYWRpbmcvY29kZW1vZHMjcmVtb3ZlLWEtdGFncy1mcm9tLWxpbmstY29tcG9uZW50cydcbiAgICAgIClcbiAgICB9XG4gICAgbGluayA9IFJlYWN0LmNsb25lRWxlbWVudChjaGlsZCwgY2hpbGRQcm9wcylcbiAgfSBlbHNlIHtcbiAgICBsaW5rID0gKFxuICAgICAgPGEgey4uLnJlc3RQcm9wc30gey4uLmNoaWxkUHJvcHN9PlxuICAgICAgICB7Y2hpbGRyZW59XG4gICAgICA8L2E+XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8TGlua1N0YXR1c0NvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2xpbmtTdGF0dXN9PlxuICAgICAge2xpbmt9XG4gICAgPC9MaW5rU3RhdHVzQ29udGV4dC5Qcm92aWRlcj5cbiAgKVxufVxuXG5jb25zdCBMaW5rU3RhdHVzQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8XG4gIHR5cGVvZiBQRU5ESU5HX0xJTktfU1RBVFVTIHwgdHlwZW9mIElETEVfTElOS19TVEFUVVNcbj4oSURMRV9MSU5LX1NUQVRVUylcblxuZXhwb3J0IGNvbnN0IHVzZUxpbmtTdGF0dXMgPSAoKSA9PiB7XG4gIHJldHVybiB1c2VDb250ZXh0KExpbmtTdGF0dXNDb250ZXh0KVxufVxuIl0sIm5hbWVzIjpbIkxpbmtDb21wb25lbnQiLCJ1c2VMaW5rU3RhdHVzIiwiaXNNb2RpZmllZEV2ZW50IiwiZXZlbnQiLCJldmVudFRhcmdldCIsImN1cnJlbnRUYXJnZXQiLCJ0YXJnZXQiLCJnZXRBdHRyaWJ1dGUiLCJtZXRhS2V5IiwiY3RybEtleSIsInNoaWZ0S2V5IiwiYWx0S2V5IiwibmF0aXZlRXZlbnQiLCJ3aGljaCIsImxpbmtDbGlja2VkIiwiZSIsImhyZWYiLCJhcyIsImxpbmtJbnN0YW5jZVJlZiIsInJlcGxhY2UiLCJzY3JvbGwiLCJvbk5hdmlnYXRlIiwibm9kZU5hbWUiLCJpc0FuY2hvck5vZGVOYW1lIiwidG9VcHBlckNhc2UiLCJoYXNBdHRyaWJ1dGUiLCJpc0xvY2FsVVJMIiwicHJldmVudERlZmF1bHQiLCJsb2NhdGlvbiIsImlzRGVmYXVsdFByZXZlbnRlZCIsIlJlYWN0Iiwic3RhcnRUcmFuc2l0aW9uIiwiZGlzcGF0Y2hOYXZpZ2F0ZUFjdGlvbiIsImN1cnJlbnQiLCJmb3JtYXRTdHJpbmdPclVybCIsInVybE9iak9yU3RyaW5nIiwiZm9ybWF0VXJsIiwicHJvcHMiLCJsaW5rU3RhdHVzIiwic2V0T3B0aW1pc3RpY0xpbmtTdGF0dXMiLCJ1c2VPcHRpbWlzdGljIiwiSURMRV9MSU5LX1NUQVRVUyIsImNoaWxkcmVuIiwidXNlUmVmIiwiaHJlZlByb3AiLCJhc1Byb3AiLCJjaGlsZHJlblByb3AiLCJwcmVmZXRjaCIsInByZWZldGNoUHJvcCIsInBhc3NIcmVmIiwic2hhbGxvdyIsIm9uQ2xpY2siLCJvbk1vdXNlRW50ZXIiLCJvbk1vdXNlRW50ZXJQcm9wIiwib25Ub3VjaFN0YXJ0Iiwib25Ub3VjaFN0YXJ0UHJvcCIsImxlZ2FjeUJlaGF2aW9yIiwicmVmIiwiZm9yd2FyZGVkUmVmIiwidW5zdGFibGVfZHluYW1pY09uSG92ZXIiLCJyZXN0UHJvcHMiLCJhIiwicm91dGVyIiwidXNlQ29udGV4dCIsIkFwcFJvdXRlckNvbnRleHQiLCJwcmVmZXRjaEVuYWJsZWQiLCJhcHBQcmVmZXRjaEtpbmQiLCJQcmVmZXRjaEtpbmQiLCJBVVRPIiwiRlVMTCIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImNyZWF0ZVByb3BFcnJvciIsImFyZ3MiLCJFcnJvciIsImtleSIsImV4cGVjdGVkIiwiYWN0dWFsIiwid2luZG93IiwicmVxdWlyZWRQcm9wc0d1YXJkIiwicmVxdWlyZWRQcm9wcyIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwiXyIsIm9wdGlvbmFsUHJvcHNHdWFyZCIsIm9wdGlvbmFsUHJvcHMiLCJ2YWxUeXBlIiwibG9jYWxlIiwid2Fybk9uY2UiLCJwYXRobmFtZSIsImhhc0R5bmFtaWNTZWdtZW50Iiwic3BsaXQiLCJzb21lIiwic2VnbWVudCIsInN0YXJ0c1dpdGgiLCJlbmRzV2l0aCIsInVzZU1lbW8iLCJyZXNvbHZlZEhyZWYiLCJjaGlsZCIsImNvbnNvbGUiLCJ3YXJuIiwiQ2hpbGRyZW4iLCJvbmx5IiwiZXJyIiwidHlwZSIsImNoaWxkUmVmIiwib2JzZXJ2ZUxpbmtWaXNpYmlsaXR5T25Nb3VudCIsInVzZUNhbGxiYWNrIiwiZWxlbWVudCIsIm1vdW50TGlua0luc3RhbmNlIiwidW5tb3VudExpbmtGb3JDdXJyZW50TmF2aWdhdGlvbiIsInVubW91bnRQcmVmZXRjaGFibGVJbnN0YW5jZSIsIm1lcmdlZFJlZiIsInVzZU1lcmdlZFJlZiIsImNoaWxkUHJvcHMiLCJkZWZhdWx0UHJldmVudGVkIiwidXBncmFkZVRvRHluYW1pY1ByZWZldGNoIiwib25OYXZpZ2F0aW9uSW50ZW50IiwiX19ORVhUX0xJTktfTk9fVE9VQ0hfU1RBUlQiLCJ1bmRlZmluZWQiLCJpc0Fic29sdXRlVXJsIiwiYWRkQmFzZVBhdGgiLCJsaW5rIiwiZXJyb3JPbmNlIiwiY2xvbmVFbGVtZW50IiwiTGlua1N0YXR1c0NvbnRleHQiLCJQcm92aWRlciIsInZhbHVlIiwiY3JlYXRlQ29udGV4dCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7SUFpVEE7Ozs7Ozs7OztDQVNDLEdBQ0QsT0FzYUMsRUFBQTtlQXRhdUJBOztJQTRhWEMsYUFBYSxFQUFBO2VBQWJBOzs7OztpRUFydUIyRDsyQkFFOUM7K0NBQ087b0NBQ0o7OEJBQ0E7dUJBQ0M7NkJBQ0Y7MEJBQ0g7dUJBU2xCOzRCQUNvQjttQ0FDWTsyQkFDYjtBQTBNMUIsU0FBU0MsZ0JBQWdCQyxLQUF1QjtJQUM5QyxNQUFNQyxjQUFjRCxNQUFNRSxhQUFhO0lBQ3ZDLE1BQU1DLFNBQVNGLFlBQVlHLFlBQVksQ0FBQztJQUN4QyxPQUNHRCxVQUFVQSxXQUFXLFdBQ3RCSCxNQUFNSyxPQUFPLElBQ2JMLE1BQU1NLE9BQU8sSUFDYk4sTUFBTU8sUUFBUSxJQUNkUCxNQUFNUSxNQUFNLElBQUksNkJBQTZCO0lBQzVDUixNQUFNUyxXQUFXLElBQUlULE1BQU1TLFdBQVcsQ0FBQ0MsS0FBSyxLQUFLO0FBRXREO0FBRUEsU0FBU0MsWUFDUEMsQ0FBbUIsRUFDbkJDLElBQVksRUFDWkMsRUFBVSxFQUNWQyxlQUFxRCxFQUNyREMsT0FBaUIsRUFDakJDLE1BQWdCLEVBQ2hCQyxVQUFtQztJQUVuQyxNQUFNLEVBQUVDLFFBQVEsRUFBRSxHQUFHUCxFQUFFVixhQUFhO0lBRXBDLGtEQUFrRDtJQUNsRCxNQUFNa0IsbUJBQW1CRCxTQUFTRSxXQUFXLE9BQU87SUFFcEQsSUFDR0Qsb0JBQW9CckIsZ0JBQWdCYSxNQUNyQ0EsRUFBRVYsYUFBYSxDQUFDb0IsWUFBWSxDQUFDLGFBQzdCO1FBQ0EsOENBQThDO1FBQzlDO0lBQ0Y7SUFFQSxJQUFJLENBQUNDLENBQUFBLEdBQUFBLFlBQUFBLFVBQVUsRUFBQ1YsT0FBTztRQUNyQixJQUFJRyxTQUFTO1lBQ1gsOERBQThE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