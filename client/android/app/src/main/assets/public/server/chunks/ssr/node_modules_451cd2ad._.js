module.exports = {

"[project]/node_modules/next/dist/esm/server/route-modules/pages/module.compiled.js [ssr] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
else {
    if ("TURBOPACK compile-time truthy", 1) {
        if ("TURBOPACK compile-time truthy", 1) {
            module.exports = __turbopack_context__.r("[externals]/next/dist/compiled/next-server/pages-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/pages-turbo.runtime.dev.js, cjs)");
        } else //TURBOPACK unreachable
        ;
    } else //TURBOPACK unreachable
    ;
} //# sourceMappingURL=module.compiled.js.map
}}),
"[project]/node_modules/next/dist/esm/server/route-kind.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "RouteKind": ()=>RouteKind
});
var RouteKind = /*#__PURE__*/ function(RouteKind) {
    /**
   * `PAGES` represents all the React pages that are under `pages/`.
   */ RouteKind["PAGES"] = "PAGES";
    /**
   * `PAGES_API` represents all the API routes under `pages/api/`.
   */ RouteKind["PAGES_API"] = "PAGES_API";
    /**
   * `APP_PAGE` represents all the React pages that are under `app/` with the
   * filename of `page.{j,t}s{,x}`.
   */ RouteKind["APP_PAGE"] = "APP_PAGE";
    /**
   * `APP_ROUTE` represents all the API routes and metadata routes that are under `app/` with the
   * filename of `route.{j,t}s{,x}`.
   */ RouteKind["APP_ROUTE"] = "APP_ROUTE";
    /**
   * `IMAGE` represents all the images that are generated by `next/image`.
   */ RouteKind["IMAGE"] = "IMAGE";
    return RouteKind;
}({}); //# sourceMappingURL=route-kind.js.map
}),
"[project]/node_modules/next/dist/esm/server/lib/trace/constants.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * Contains predefined constants for the trace span name in next/server.
 *
 * Currently, next/server/tracer is internal implementation only for tracking
 * next.js's implementation only with known span names defined here.
 **/ // eslint typescript has a bug with TS enums
/* eslint-disable no-shadow */ __turbopack_context__.s({
    "AppRenderSpan": ()=>AppRenderSpan,
    "AppRouteRouteHandlersSpan": ()=>AppRouteRouteHandlersSpan,
    "BaseServerSpan": ()=>BaseServerSpan,
    "LoadComponentsSpan": ()=>LoadComponentsSpan,
    "LogSpanAllowList": ()=>LogSpanAllowList,
    "MiddlewareSpan": ()=>MiddlewareSpan,
    "NextNodeServerSpan": ()=>NextNodeServerSpan,
    "NextServerSpan": ()=>NextServerSpan,
    "NextVanillaSpanAllowlist": ()=>NextVanillaSpanAllowlist,
    "NodeSpan": ()=>NodeSpan,
    "RenderSpan": ()=>RenderSpan,
    "ResolveMetadataSpan": ()=>ResolveMetadataSpan,
    "RouterSpan": ()=>RouterSpan,
    "StartServerSpan": ()=>StartServerSpan
});
var BaseServerSpan = /*#__PURE__*/ function(BaseServerSpan) {
    BaseServerSpan["handleRequest"] = "BaseServer.handleRequest";
    BaseServerSpan["run"] = "BaseServer.run";
    BaseServerSpan["pipe"] = "BaseServer.pipe";
    BaseServerSpan["getStaticHTML"] = "BaseServer.getStaticHTML";
    BaseServerSpan["render"] = "BaseServer.render";
    BaseServerSpan["renderToResponseWithComponents"] = "BaseServer.renderToResponseWithComponents";
    BaseServerSpan["renderToResponse"] = "BaseServer.renderToResponse";
    BaseServerSpan["renderToHTML"] = "BaseServer.renderToHTML";
    BaseServerSpan["renderError"] = "BaseServer.renderError";
    BaseServerSpan["renderErrorToResponse"] = "BaseServer.renderErrorToResponse";
    BaseServerSpan["renderErrorToHTML"] = "BaseServer.renderErrorToHTML";
    BaseServerSpan["render404"] = "BaseServer.render404";
    return BaseServerSpan;
}(BaseServerSpan || {});
var LoadComponentsSpan = /*#__PURE__*/ function(LoadComponentsSpan) {
    LoadComponentsSpan["loadDefaultErrorComponents"] = "LoadComponents.loadDefaultErrorComponents";
    LoadComponentsSpan["loadComponents"] = "LoadComponents.loadComponents";
    return LoadComponentsSpan;
}(LoadComponentsSpan || {});
var NextServerSpan = /*#__PURE__*/ function(NextServerSpan) {
    NextServerSpan["getRequestHandler"] = "NextServer.getRequestHandler";
    NextServerSpan["getServer"] = "NextServer.getServer";
    NextServerSpan["getServerRequestHandler"] = "NextServer.getServerRequestHandler";
    NextServerSpan["createServer"] = "createServer.createServer";
    return NextServerSpan;
}(NextServerSpan || {});
var NextNodeServerSpan = /*#__PURE__*/ function(NextNodeServerSpan) {
    NextNodeServerSpan["compression"] = "NextNodeServer.compression";
    NextNodeServerSpan["getBuildId"] = "NextNodeServer.getBuildId";
    NextNodeServerSpan["createComponentTree"] = "NextNodeServer.createComponentTree";
    NextNodeServerSpan["clientComponentLoading"] = "NextNodeServer.clientComponentLoading";
    NextNodeServerSpan["getLayoutOrPageModule"] = "NextNodeServer.getLayoutOrPageModule";
    NextNodeServerSpan["generateStaticRoutes"] = "NextNodeServer.generateStaticRoutes";
    NextNodeServerSpan["generateFsStaticRoutes"] = "NextNodeServer.generateFsStaticRoutes";
    NextNodeServerSpan["generatePublicRoutes"] = "NextNodeServer.generatePublicRoutes";
    NextNodeServerSpan["generateImageRoutes"] = "NextNodeServer.generateImageRoutes.route";
    NextNodeServerSpan["sendRenderResult"] = "NextNodeServer.sendRenderResult";
    NextNodeServerSpan["proxyRequest"] = "NextNodeServer.proxyRequest";
    NextNodeServerSpan["runApi"] = "NextNodeServer.runApi";
    NextNodeServerSpan["render"] = "NextNodeServer.render";
    NextNodeServerSpan["renderHTML"] = "NextNodeServer.renderHTML";
    NextNodeServerSpan["imageOptimizer"] = "NextNodeServer.imageOptimizer";
    NextNodeServerSpan["getPagePath"] = "NextNodeServer.getPagePath";
    NextNodeServerSpan["getRoutesManifest"] = "NextNodeServer.getRoutesManifest";
    NextNodeServerSpan["findPageComponents"] = "NextNodeServer.findPageComponents";
    NextNodeServerSpan["getFontManifest"] = "NextNodeServer.getFontManifest";
    NextNodeServerSpan["getServerComponentManifest"] = "NextNodeServer.getServerComponentManifest";
    NextNodeServerSpan["getRequestHandler"] = "NextNodeServer.getRequestHandler";
    NextNodeServerSpan["renderToHTML"] = "NextNodeServer.renderToHTML";
    NextNodeServerSpan["renderError"] = "NextNodeServer.renderError";
    NextNodeServerSpan["renderErrorToHTML"] = "NextNodeServer.renderErrorToHTML";
    NextNodeServerSpan["render404"] = "NextNodeServer.render404";
    NextNodeServerSpan["startResponse"] = "NextNodeServer.startResponse";
    // nested inner span, does not require parent scope name
    NextNodeServerSpan["route"] = "route";
    NextNodeServerSpan["onProxyReq"] = "onProxyReq";
    NextNodeServerSpan["apiResolver"] = "apiResolver";
    NextNodeServerSpan["internalFetch"] = "internalFetch";
    return NextNodeServerSpan;
}(NextNodeServerSpan || {});
var StartServerSpan = /*#__PURE__*/ function(StartServerSpan) {
    StartServerSpan["startServer"] = "startServer.startServer";
    return StartServerSpan;
}(StartServerSpan || {});
var RenderSpan = /*#__PURE__*/ function(RenderSpan) {
    RenderSpan["getServerSideProps"] = "Render.getServerSideProps";
    RenderSpan["getStaticProps"] = "Render.getStaticProps";
    RenderSpan["renderToString"] = "Render.renderToString";
    RenderSpan["renderDocument"] = "Render.renderDocument";
    RenderSpan["createBodyResult"] = "Render.createBodyResult";
    return RenderSpan;
}(RenderSpan || {});
var AppRenderSpan = /*#__PURE__*/ function(AppRenderSpan) {
    AppRenderSpan["renderToString"] = "AppRender.renderToString";
    AppRenderSpan["renderToReadableStream"] = "AppRender.renderToReadableStream";
    AppRenderSpan["getBodyResult"] = "AppRender.getBodyResult";
    AppRenderSpan["fetch"] = "AppRender.fetch";
    return AppRenderSpan;
}(AppRenderSpan || {});
var RouterSpan = /*#__PURE__*/ function(RouterSpan) {
    RouterSpan["executeRoute"] = "Router.executeRoute";
    return RouterSpan;
}(RouterSpan || {});
var NodeSpan = /*#__PURE__*/ function(NodeSpan) {
    NodeSpan["runHandler"] = "Node.runHandler";
    return NodeSpan;
}(NodeSpan || {});
var AppRouteRouteHandlersSpan = /*#__PURE__*/ function(AppRouteRouteHandlersSpan) {
    AppRouteRouteHandlersSpan["runHandler"] = "AppRouteRouteHandlers.runHandler";
    return AppRouteRouteHandlersSpan;
}(AppRouteRouteHandlersSpan || {});
var ResolveMetadataSpan = /*#__PURE__*/ function(ResolveMetadataSpan) {
    ResolveMetadataSpan["generateMetadata"] = "ResolveMetadata.generateMetadata";
    ResolveMetadataSpan["generateViewport"] = "ResolveMetadata.generateViewport";
    return ResolveMetadataSpan;
}(ResolveMetadataSpan || {});
var MiddlewareSpan = /*#__PURE__*/ function(MiddlewareSpan) {
    MiddlewareSpan["execute"] = "Middleware.execute";
    return MiddlewareSpan;
}(MiddlewareSpan || {});
const NextVanillaSpanAllowlist = [
    "Middleware.execute",
    "BaseServer.handleRequest",
    "Render.getServerSideProps",
    "Render.getStaticProps",
    "AppRender.fetch",
    "AppRender.getBodyResult",
    "Render.renderDocument",
    "Node.runHandler",
    "AppRouteRouteHandlers.runHandler",
    "ResolveMetadata.generateMetadata",
    "ResolveMetadata.generateViewport",
    "NextNodeServer.createComponentTree",
    "NextNodeServer.findPageComponents",
    "NextNodeServer.getLayoutOrPageModule",
    "NextNodeServer.startResponse",
    "NextNodeServer.clientComponentLoading"
];
const LogSpanAllowList = [
    "NextNodeServer.findPageComponents",
    "NextNodeServer.createComponentTree",
    "NextNodeServer.clientComponentLoading"
];
;
 //# sourceMappingURL=constants.js.map
}),
"[project]/node_modules/next/dist/esm/shared/lib/is-thenable.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * Check to see if a value is Thenable.
 *
 * @param promise the maybe-thenable value
 * @returns true if the value is thenable
 */ __turbopack_context__.s({
    "isThenable": ()=>isThenable
});
function isThenable(promise) {
    return promise !== null && typeof promise === 'object' && 'then' in promise && typeof promise.then === 'function';
} //# sourceMappingURL=is-thenable.js.map
}),
"[project]/node_modules/next/dist/esm/server/lib/trace/tracer.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "BubbledError": ()=>BubbledError,
    "SpanKind": ()=>SpanKind,
    "SpanStatusCode": ()=>SpanStatusCode,
    "getTracer": ()=>getTracer,
    "isBubbledError": ()=>isBubbledError
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$constants$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/lib/trace/constants.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$is$2d$thenable$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/is-thenable.js [ssr] (ecmascript)");
;
;
let api;
// we want to allow users to use their own version of @opentelemetry/api if they
// want to, so we try to require it first, and if it fails we fall back to the
// version that is bundled with Next.js
// this is because @opentelemetry/api has to be synced with the version of
// @opentelemetry/tracing that is used, and we don't want to force users to use
// the version that is bundled with Next.js.
// the API is ~stable, so this should be fine
if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
else {
    try {
        api = __turbopack_context__.r("[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)");
    } catch (err) {
        api = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/@opentelemetry/api/index.js [ssr] (ecmascript)");
    }
}
const { context, propagation, trace, SpanStatusCode, SpanKind, ROOT_CONTEXT } = api;
class BubbledError extends Error {
    constructor(bubble, result){
        super(), this.bubble = bubble, this.result = result;
    }
}
function isBubbledError(error) {
    if (typeof error !== 'object' || error === null) return false;
    return error instanceof BubbledError;
}
const closeSpanWithError = (span, error)=>{
    if (isBubbledError(error) && error.bubble) {
        span.setAttribute('next.bubble', true);
    } else {
        if (error) {
            span.recordException(error);
        }
        span.setStatus({
            code: SpanStatusCode.ERROR,
            message: error == null ? void 0 : error.message
        });
    }
    span.end();
};
/** we use this map to propagate attributes from nested spans to the top span */ const rootSpanAttributesStore = new Map();
const rootSpanIdKey = api.createContextKey('next.rootSpanId');
let lastSpanId = 0;
const getSpanId = ()=>lastSpanId++;
const clientTraceDataSetter = {
    set (carrier, key, value) {
        carrier.push({
            key,
            value
        });
    }
};
class NextTracerImpl {
    /**
   * Returns an instance to the trace with configured name.
   * Since wrap / trace can be defined in any place prior to actual trace subscriber initialization,
   * This should be lazily evaluated.
   */ getTracerInstance() {
        return trace.getTracer('next.js', '0.0.1');
    }
    getContext() {
        return context;
    }
    getTracePropagationData() {
        const activeContext = context.active();
        const entries = [];
        propagation.inject(activeContext, entries, clientTraceDataSetter);
        return entries;
    }
    getActiveScopeSpan() {
        return trace.getSpan(context == null ? void 0 : context.active());
    }
    withPropagatedContext(carrier, fn, getter) {
        const activeContext = context.active();
        if (trace.getSpanContext(activeContext)) {
            // Active span is already set, too late to propagate.
            return fn();
        }
        const remoteContext = propagation.extract(activeContext, carrier, getter);
        return context.with(remoteContext, fn);
    }
    trace(...args) {
        var _trace_getSpanContext;
        const [type, fnOrOptions, fnOrEmpty] = args;
        // coerce options form overload
        const { fn, options } = typeof fnOrOptions === 'function' ? {
            fn: fnOrOptions,
            options: {}
        } : {
            fn: fnOrEmpty,
            options: {
                ...fnOrOptions
            }
        };
        const spanName = options.spanName ?? type;
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$constants$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["NextVanillaSpanAllowlist"].includes(type) && process.env.NEXT_OTEL_VERBOSE !== '1' || options.hideSpan) {
            return fn();
        }
        // Trying to get active scoped span to assign parent. If option specifies parent span manually, will try to use it.
        let spanContext = this.getSpanContext((options == null ? void 0 : options.parentSpan) ?? this.getActiveScopeSpan());
        let isRootSpan = false;
        if (!spanContext) {
            spanContext = (context == null ? void 0 : context.active()) ?? ROOT_CONTEXT;
            isRootSpan = true;
        } else if ((_trace_getSpanContext = trace.getSpanContext(spanContext)) == null ? void 0 : _trace_getSpanContext.isRemote) {
            isRootSpan = true;
        }
        const spanId = getSpanId();
        options.attributes = {
            'next.span_name': spanName,
            'next.span_type': type,
            ...options.attributes
        };
        return context.with(spanContext.setValue(rootSpanIdKey, spanId), ()=>this.getTracerInstance().startActiveSpan(spanName, options, (span)=>{
                const startTime = 'performance' in globalThis && 'measure' in performance ? globalThis.performance.now() : undefined;
                const onCleanup = ()=>{
                    rootSpanAttributesStore.delete(spanId);
                    if (startTime && process.env.NEXT_OTEL_PERFORMANCE_PREFIX && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$constants$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["LogSpanAllowList"].includes(type || '')) {
                        performance.measure(`${process.env.NEXT_OTEL_PERFORMANCE_PREFIX}:next-${(type.split('.').pop() || '').replace(/[A-Z]/g, (match)=>'-' + match.toLowerCase())}`, {
                            start: startTime,
                            end: performance.now()
                        });
                    }
                };
                if (isRootSpan) {
                    rootSpanAttributesStore.set(spanId, new Map(Object.entries(options.attributes ?? {})));
                }
                try {
                    if (fn.length > 1) {
                        return fn(span, (err)=>closeSpanWithError(span, err));
                    }
                    const result = fn(span);
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$is$2d$thenable$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["isThenable"])(result)) {
                        // If there's error make sure it throws
                        return result.then((res)=>{
                            span.end();
                            // Need to pass down the promise result,
                            // it could be react stream response with error { error, stream }
                            return res;
                        }).catch((err)=>{
                            closeSpanWithError(span, err);
                            throw err;
                        }).finally(onCleanup);
                    } else {
                        span.end();
                        onCleanup();
                    }
                    return result;
                } catch (err) {
                    closeSpanWithError(span, err);
                    onCleanup();
                    throw err;
                }
            }));
    }
    wrap(...args) {
        const tracer = this;
        const [name, options, fn] = args.length === 3 ? args : [
            args[0],
            {},
            args[1]
        ];
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$constants$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["NextVanillaSpanAllowlist"].includes(name) && process.env.NEXT_OTEL_VERBOSE !== '1') {
            return fn;
        }
        return function() {
            let optionsObj = options;
            if (typeof optionsObj === 'function' && typeof fn === 'function') {
                optionsObj = optionsObj.apply(this, arguments);
            }
            const lastArgId = arguments.length - 1;
            const cb = arguments[lastArgId];
            if (typeof cb === 'function') {
                const scopeBoundCb = tracer.getContext().bind(context.active(), cb);
                return tracer.trace(name, optionsObj, (_span, done)=>{
                    arguments[lastArgId] = function(err) {
                        done == null ? void 0 : done(err);
                        return scopeBoundCb.apply(this, arguments);
                    };
                    return fn.apply(this, arguments);
                });
            } else {
                return tracer.trace(name, optionsObj, ()=>fn.apply(this, arguments));
            }
        };
    }
    startSpan(...args) {
        const [type, options] = args;
        const spanContext = this.getSpanContext((options == null ? void 0 : options.parentSpan) ?? this.getActiveScopeSpan());
        return this.getTracerInstance().startSpan(type, options, spanContext);
    }
    getSpanContext(parentSpan) {
        const spanContext = parentSpan ? trace.setSpan(context.active(), parentSpan) : undefined;
        return spanContext;
    }
    getRootSpanAttributes() {
        const spanId = context.active().getValue(rootSpanIdKey);
        return rootSpanAttributesStore.get(spanId);
    }
    setRootSpanAttribute(key, value) {
        const spanId = context.active().getValue(rootSpanIdKey);
        const attributes = rootSpanAttributesStore.get(spanId);
        if (attributes) {
            attributes.set(key, value);
        }
    }
}
const getTracer = (()=>{
    const tracer = new NextTracerImpl();
    return ()=>tracer;
})();
;
 //# sourceMappingURL=tracer.js.map
}),
"[project]/node_modules/next/dist/esm/shared/lib/router/utils/querystring.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "assign": ()=>assign,
    "searchParamsToUrlQuery": ()=>searchParamsToUrlQuery,
    "urlQueryToSearchParams": ()=>urlQueryToSearchParams
});
function searchParamsToUrlQuery(searchParams) {
    const query = {};
    for (const [key, value] of searchParams.entries()){
        const existing = query[key];
        if (typeof existing === 'undefined') {
            query[key] = value;
        } else if (Array.isArray(existing)) {
            existing.push(value);
        } else {
            query[key] = [
                existing,
                value
            ];
        }
    }
    return query;
}
function stringifyUrlQueryParam(param) {
    if (typeof param === 'string') {
        return param;
    }
    if (typeof param === 'number' && !isNaN(param) || typeof param === 'boolean') {
        return String(param);
    } else {
        return '';
    }
}
function urlQueryToSearchParams(query) {
    const searchParams = new URLSearchParams();
    for (const [key, value] of Object.entries(query)){
        if (Array.isArray(value)) {
            for (const item of value){
                searchParams.append(key, stringifyUrlQueryParam(item));
            }
        } else {
            searchParams.set(key, stringifyUrlQueryParam(value));
        }
    }
    return searchParams;
}
function assign(target) {
    for(var _len = arguments.length, searchParamsList = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
        searchParamsList[_key - 1] = arguments[_key];
    }
    for (const searchParams of searchParamsList){
        for (const key of searchParams.keys()){
            target.delete(key);
        }
        for (const [key, value] of searchParams.entries()){
            target.append(key, value);
        }
    }
    return target;
} //# sourceMappingURL=querystring.js.map
}),
"[project]/node_modules/next/dist/esm/shared/lib/router/utils/format-url.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// Format function modified from nodejs
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
__turbopack_context__.s({
    "formatUrl": ()=>formatUrl,
    "formatWithValidation": ()=>formatWithValidation,
    "urlObjectKeys": ()=>urlObjectKeys
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$querystring$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/router/utils/querystring.js [ssr] (ecmascript)");
;
const slashedProtocols = /https?|ftp|gopher|file/;
function formatUrl(urlObj) {
    let { auth, hostname } = urlObj;
    let protocol = urlObj.protocol || '';
    let pathname = urlObj.pathname || '';
    let hash = urlObj.hash || '';
    let query = urlObj.query || '';
    let host = false;
    auth = auth ? encodeURIComponent(auth).replace(/%3A/i, ':') + '@' : '';
    if (urlObj.host) {
        host = auth + urlObj.host;
    } else if (hostname) {
        host = auth + (~hostname.indexOf(':') ? "[" + hostname + "]" : hostname);
        if (urlObj.port) {
            host += ':' + urlObj.port;
        }
    }
    if (query && typeof query === 'object') {
        query = String(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$querystring$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["urlQueryToSearchParams"](query));
    }
    let search = urlObj.search || query && "?" + query || '';
    if (protocol && !protocol.endsWith(':')) protocol += ':';
    if (urlObj.slashes || (!protocol || slashedProtocols.test(protocol)) && host !== false) {
        host = '//' + (host || '');
        if (pathname && pathname[0] !== '/') pathname = '/' + pathname;
    } else if (!host) {
        host = '';
    }
    if (hash && hash[0] !== '#') hash = '#' + hash;
    if (search && search[0] !== '?') search = '?' + search;
    pathname = pathname.replace(/[?#]/g, encodeURIComponent);
    search = search.replace('#', '%23');
    return "" + protocol + host + pathname + search + hash;
}
const urlObjectKeys = [
    'auth',
    'hash',
    'host',
    'hostname',
    'href',
    'path',
    'pathname',
    'port',
    'protocol',
    'query',
    'search',
    'slashes'
];
function formatWithValidation(url) {
    if ("TURBOPACK compile-time truthy", 1) {
        if (url !== null && typeof url === 'object') {
            Object.keys(url).forEach((key)=>{
                if (!urlObjectKeys.includes(key)) {
                    console.warn("Unknown key passed via urlObject into url.format: " + key);
                }
            });
        }
    }
    return formatUrl(url);
} //# sourceMappingURL=format-url.js.map
}),
"[project]/node_modules/next/dist/esm/server/request-meta.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/* eslint-disable no-redeclare */ // FIXME: (wyattjoh) this is a temporary solution to allow us to pass data between bundled modules
__turbopack_context__.s({
    "NEXT_REQUEST_META": ()=>NEXT_REQUEST_META,
    "addRequestMeta": ()=>addRequestMeta,
    "getRequestMeta": ()=>getRequestMeta,
    "removeRequestMeta": ()=>removeRequestMeta,
    "setRequestMeta": ()=>setRequestMeta
});
const NEXT_REQUEST_META = Symbol.for('NextInternalRequestMeta');
function getRequestMeta(req, key) {
    const meta = req[NEXT_REQUEST_META] || {};
    return typeof key === 'string' ? meta[key] : meta;
}
function setRequestMeta(req, meta) {
    req[NEXT_REQUEST_META] = meta;
    return meta;
}
function addRequestMeta(request, key, value) {
    const meta = getRequestMeta(request);
    meta[key] = value;
    return setRequestMeta(request, meta);
}
function removeRequestMeta(request, key) {
    const meta = getRequestMeta(request);
    delete meta[key];
    return setRequestMeta(request, meta);
} //# sourceMappingURL=request-meta.js.map
}),
"[project]/node_modules/next/dist/esm/server/app-render/interop-default.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * Interop between "export default" and "module.exports".
 */ __turbopack_context__.s({
    "interopDefault": ()=>interopDefault
});
function interopDefault(mod) {
    return mod.default || mod;
} //# sourceMappingURL=interop-default.js.map
}),
"[project]/node_modules/next/dist/esm/server/instrumentation/utils.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "getRevalidateReason": ()=>getRevalidateReason
});
function getRevalidateReason(params) {
    if (params.isOnDemandRevalidate) {
        return 'on-demand';
    }
    if (params.isRevalidate) {
        return 'stale';
    }
    return undefined;
} //# sourceMappingURL=utils.js.map
}),
"[project]/node_modules/next/dist/esm/shared/lib/page-path/normalize-data-path.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * strip _next/data/<build-id>/ prefix and .json suffix
 */ __turbopack_context__.s({
    "normalizeDataPath": ()=>normalizeDataPath
});
function normalizeDataPath(pathname) {
    pathname = pathname.replace(/\/_next\/data\/[^/]{1,}/, '').replace(/\.json$/, '');
    if (pathname === '/index') {
        return '/';
    }
    return pathname;
} //# sourceMappingURL=normalize-data-path.js.map
}),
"[project]/node_modules/next/dist/esm/lib/detached-promise.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * A `Promise.withResolvers` implementation that exposes the `resolve` and
 * `reject` functions on a `Promise`.
 *
 * @see https://tc39.es/proposal-promise-with-resolvers/
 */ __turbopack_context__.s({
    "DetachedPromise": ()=>DetachedPromise
});
class DetachedPromise {
    constructor(){
        let resolve;
        let reject;
        // Create the promise and assign the resolvers to the object.
        this.promise = new Promise((res, rej)=>{
            resolve = res;
            reject = rej;
        });
        // We know that resolvers is defined because the Promise constructor runs
        // synchronously.
        this.resolve = resolve;
        this.reject = reject;
    }
} //# sourceMappingURL=detached-promise.js.map
}),
"[project]/node_modules/next/dist/esm/lib/batcher.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "Batcher": ()=>Batcher
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$detached$2d$promise$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/detached-promise.js [ssr] (ecmascript)");
;
class Batcher {
    constructor(cacheKeyFn, /**
     * A function that will be called to schedule the wrapped function to be
     * executed. This defaults to a function that will execute the function
     * immediately.
     */ schedulerFn = (fn)=>fn()){
        this.cacheKeyFn = cacheKeyFn;
        this.schedulerFn = schedulerFn;
        this.pending = new Map();
    }
    static create(options) {
        return new Batcher(options == null ? void 0 : options.cacheKeyFn, options == null ? void 0 : options.schedulerFn);
    }
    /**
   * Wraps a function in a promise that will be resolved or rejected only once
   * for a given key. This will allow multiple calls to the function to be
   * made, but only one will be executed at a time. The result of the first
   * call will be returned to all callers.
   *
   * @param key the key to use for the cache
   * @param fn the function to wrap
   * @returns a promise that resolves to the result of the function
   */ async batch(key, fn) {
        const cacheKey = this.cacheKeyFn ? await this.cacheKeyFn(key) : key;
        if (cacheKey === null) {
            return fn(cacheKey, Promise.resolve);
        }
        const pending = this.pending.get(cacheKey);
        if (pending) return pending;
        const { promise, resolve, reject } = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$detached$2d$promise$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["DetachedPromise"]();
        this.pending.set(cacheKey, promise);
        this.schedulerFn(async ()=>{
            try {
                const result = await fn(cacheKey, resolve);
                // Resolving a promise multiple times is a no-op, so we can safely
                // resolve all pending promises with the same result.
                resolve(result);
            } catch (err) {
                reject(err);
            } finally{
                this.pending.delete(cacheKey);
            }
        });
        return promise;
    }
} //# sourceMappingURL=batcher.js.map
}),
"[project]/node_modules/next/dist/esm/lib/scheduler.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * Schedules a function to be called on the next tick after the other promises
 * have been resolved.
 *
 * @param cb the function to schedule
 */ __turbopack_context__.s({
    "atLeastOneTask": ()=>atLeastOneTask,
    "scheduleImmediate": ()=>scheduleImmediate,
    "scheduleOnNextTick": ()=>scheduleOnNextTick,
    "waitAtLeastOneReactRenderTask": ()=>waitAtLeastOneReactRenderTask
});
const scheduleOnNextTick = (cb)=>{
    // We use Promise.resolve().then() here so that the operation is scheduled at
    // the end of the promise job queue, we then add it to the next process tick
    // to ensure it's evaluated afterwards.
    //
    // This was inspired by the implementation of the DataLoader interface: https://github.com/graphql/dataloader/blob/d336bd15282664e0be4b4a657cb796f09bafbc6b/src/index.js#L213-L255
    //
    Promise.resolve().then(()=>{
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        else {
            process.nextTick(cb);
        }
    });
};
const scheduleImmediate = (cb)=>{
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    else {
        setImmediate(cb);
    }
};
function atLeastOneTask() {
    return new Promise((resolve)=>scheduleImmediate(resolve));
}
function waitAtLeastOneReactRenderTask() {
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    else {
        return new Promise((r)=>setImmediate(r));
    }
} //# sourceMappingURL=scheduler.js.map
}),
"[project]/node_modules/next/dist/esm/server/response-cache/types.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "CachedRouteKind": ()=>CachedRouteKind,
    "IncrementalCacheKind": ()=>IncrementalCacheKind
});
var CachedRouteKind = /*#__PURE__*/ function(CachedRouteKind) {
    CachedRouteKind["APP_PAGE"] = "APP_PAGE";
    CachedRouteKind["APP_ROUTE"] = "APP_ROUTE";
    CachedRouteKind["PAGES"] = "PAGES";
    CachedRouteKind["FETCH"] = "FETCH";
    CachedRouteKind["REDIRECT"] = "REDIRECT";
    CachedRouteKind["IMAGE"] = "IMAGE";
    return CachedRouteKind;
}({});
var IncrementalCacheKind = /*#__PURE__*/ function(IncrementalCacheKind) {
    IncrementalCacheKind["APP_PAGE"] = "APP_PAGE";
    IncrementalCacheKind["APP_ROUTE"] = "APP_ROUTE";
    IncrementalCacheKind["PAGES"] = "PAGES";
    IncrementalCacheKind["FETCH"] = "FETCH";
    IncrementalCacheKind["IMAGE"] = "IMAGE";
    return IncrementalCacheKind;
}({}); //# sourceMappingURL=types.js.map
}),
"[project]/node_modules/next/dist/esm/server/stream-utils/encoded-tags.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "ENCODED_TAGS": ()=>ENCODED_TAGS
});
const ENCODED_TAGS = {
    // opening tags do not have the closing `>` since they can contain other attributes such as `<body className=''>`
    OPENING: {
        // <html
        HTML: new Uint8Array([
            60,
            104,
            116,
            109,
            108
        ]),
        // <body
        BODY: new Uint8Array([
            60,
            98,
            111,
            100,
            121
        ])
    },
    CLOSED: {
        // </head>
        HEAD: new Uint8Array([
            60,
            47,
            104,
            101,
            97,
            100,
            62
        ]),
        // </body>
        BODY: new Uint8Array([
            60,
            47,
            98,
            111,
            100,
            121,
            62
        ]),
        // </html>
        HTML: new Uint8Array([
            60,
            47,
            104,
            116,
            109,
            108,
            62
        ]),
        // </body></html>
        BODY_AND_HTML: new Uint8Array([
            60,
            47,
            98,
            111,
            100,
            121,
            62,
            60,
            47,
            104,
            116,
            109,
            108,
            62
        ])
    },
    META: {
        // Only the match the prefix cause the suffix can be different wether it's xml compatible or not ">" or "/>"
        // <meta name="«nxt-icon»"
        // This is a special mark that will be replaced by the icon insertion script tag.
        ICON_MARK: new Uint8Array([
            60,
            109,
            101,
            116,
            97,
            32,
            110,
            97,
            109,
            101,
            61,
            34,
            194,
            171,
            110,
            120,
            116,
            45,
            105,
            99,
            111,
            110,
            194,
            187,
            34
        ])
    }
}; //# sourceMappingURL=encoded-tags.js.map
}),
"[project]/node_modules/next/dist/esm/server/stream-utils/uint8array-helpers.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * Find the starting index of Uint8Array `b` within Uint8Array `a`.
 */ __turbopack_context__.s({
    "indexOfUint8Array": ()=>indexOfUint8Array,
    "isEquivalentUint8Arrays": ()=>isEquivalentUint8Arrays,
    "removeFromUint8Array": ()=>removeFromUint8Array
});
function indexOfUint8Array(a, b) {
    if (b.length === 0) return 0;
    if (a.length === 0 || b.length > a.length) return -1;
    // start iterating through `a`
    for(let i = 0; i <= a.length - b.length; i++){
        let completeMatch = true;
        // from index `i`, iterate through `b` and check for mismatch
        for(let j = 0; j < b.length; j++){
            // if the values do not match, then this isn't a complete match, exit `b` iteration early and iterate to next index of `a`.
            if (a[i + j] !== b[j]) {
                completeMatch = false;
                break;
            }
        }
        if (completeMatch) {
            return i;
        }
    }
    return -1;
}
function isEquivalentUint8Arrays(a, b) {
    if (a.length !== b.length) return false;
    for(let i = 0; i < a.length; i++){
        if (a[i] !== b[i]) return false;
    }
    return true;
}
function removeFromUint8Array(a, b) {
    const tagIndex = indexOfUint8Array(a, b);
    if (tagIndex === 0) return a.subarray(b.length);
    if (tagIndex > -1) {
        const removed = new Uint8Array(a.length - b.length);
        removed.set(a.slice(0, tagIndex));
        removed.set(a.slice(tagIndex + b.length), tagIndex);
        return removed;
    } else {
        return a;
    }
} //# sourceMappingURL=uint8array-helpers.js.map
}),
"[project]/node_modules/next/dist/esm/shared/lib/errors/constants.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "MISSING_ROOT_TAGS_ERROR": ()=>MISSING_ROOT_TAGS_ERROR
});
const MISSING_ROOT_TAGS_ERROR = 'NEXT_MISSING_ROOT_TAGS'; //# sourceMappingURL=constants.js.map
}),
"[project]/node_modules/next/dist/esm/shared/lib/segment-cache/output-export-prefetch-encoding.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// In output: export mode, the build id is added to the start of the HTML
// document, directly after the doctype declaration. During a prefetch, the
// client performs a range request to get the build id, so it can check whether
// the target page belongs to the same build.
//
// The first 64 bytes of the document are requested. The exact number isn't
// too important; it must be larger than the build id + doctype + closing and
// ending comment markers, but it doesn't need to match the end of the
// comment exactly.
//
// Build ids are 21 bytes long in the default implementation, though this
// can be overridden in the Next.js config. For the purposes of this check,
// it's OK to only match the start of the id, so we'll truncate it if exceeds
// a certain length.
__turbopack_context__.s({
    "DOC_PREFETCH_RANGE_HEADER_VALUE": ()=>DOC_PREFETCH_RANGE_HEADER_VALUE,
    "doesExportedHtmlMatchBuildId": ()=>doesExportedHtmlMatchBuildId,
    "insertBuildIdComment": ()=>insertBuildIdComment
});
const DOCTYPE_PREFIX = '<!DOCTYPE html>' // 15 bytes
;
const MAX_BUILD_ID_LENGTH = 24;
const DOC_PREFETCH_RANGE_HEADER_VALUE = 'bytes=0-63';
function escapeBuildId(buildId) {
    // If the build id is longer than the given limit, it's OK for our purposes
    // to only match the beginning.
    const truncated = buildId.slice(0, MAX_BUILD_ID_LENGTH);
    // Replace hyphens with underscores so it doesn't break the HTML comment.
    // (Unlikely, but if this did happen it would break the whole document.)
    return truncated.replace(/-/g, '_');
}
function insertBuildIdComment(originalHtml, buildId) {
    if (buildId.includes('-->') || // React always inserts a doctype at the start of the document. Skip if it
    // isn't present. Shouldn't happen; suggests an issue elsewhere.
    !originalHtml.startsWith(DOCTYPE_PREFIX)) {
        // Return the original HTML unchanged. This means the document will not
        // be prefetched.
        // TODO: The build id comment is currently only used during prefetches, but
        // if we eventually use this mechanism for regular navigations, we may need
        // to error during build if we fail to insert it for some reason.
        return originalHtml;
    }
    // The comment must be inserted after the doctype.
    return originalHtml.replace(DOCTYPE_PREFIX, DOCTYPE_PREFIX + '<!--' + escapeBuildId(buildId) + '-->');
}
function doesExportedHtmlMatchBuildId(partialHtmlDocument, buildId) {
    // Check whether the document starts with the expected buildId.
    return partialHtmlDocument.startsWith(DOCTYPE_PREFIX + '<!--' + escapeBuildId(buildId) + '-->');
} //# sourceMappingURL=output-export-prefetch-encoding.js.map
}),
"[project]/node_modules/next/dist/esm/server/stream-utils/node-web-streams-helper.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "chainStreams": ()=>chainStreams,
    "continueDynamicHTMLResume": ()=>continueDynamicHTMLResume,
    "continueDynamicPrerender": ()=>continueDynamicPrerender,
    "continueFizzStream": ()=>continueFizzStream,
    "continueStaticPrerender": ()=>continueStaticPrerender,
    "createBufferedTransformStream": ()=>createBufferedTransformStream,
    "createDocumentClosingStream": ()=>createDocumentClosingStream,
    "createRootLayoutValidatorStream": ()=>createRootLayoutValidatorStream,
    "renderToInitialFizzStream": ()=>renderToInitialFizzStream,
    "streamFromBuffer": ()=>streamFromBuffer,
    "streamFromString": ()=>streamFromString,
    "streamToBuffer": ()=>streamToBuffer,
    "streamToString": ()=>streamToString
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$tracer$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/lib/trace/tracer.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$constants$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/lib/trace/constants.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$detached$2d$promise$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/detached-promise.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$scheduler$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/scheduler.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$encoded$2d$tags$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/stream-utils/encoded-tags.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$uint8array$2d$helpers$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/stream-utils/uint8array-helpers.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$errors$2f$constants$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/errors/constants.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$segment$2d$cache$2f$output$2d$export$2d$prefetch$2d$encoding$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/segment-cache/output-export-prefetch-encoding.js [ssr] (ecmascript)");
;
;
;
;
;
;
;
;
function voidCatch() {
// this catcher is designed to be used with pipeTo where we expect the underlying
// pipe implementation to forward errors but we don't want the pipeTo promise to reject
// and be unhandled
}
// We can share the same encoder instance everywhere
// Notably we cannot do the same for TextDecoder because it is stateful
// when handling streaming data
const encoder = new TextEncoder();
function chainStreams(...streams) {
    // We could encode this invariant in the arguments but current uses of this function pass
    // use spread so it would be missed by
    if (streams.length === 0) {
        throw Object.defineProperty(new Error('Invariant: chainStreams requires at least one stream'), "__NEXT_ERROR_CODE", {
            value: "E437",
            enumerable: false,
            configurable: true
        });
    }
    // If we only have 1 stream we fast path it by returning just this stream
    if (streams.length === 1) {
        return streams[0];
    }
    const { readable, writable } = new TransformStream();
    // We always initiate pipeTo immediately. We know we have at least 2 streams
    // so we need to avoid closing the writable when this one finishes.
    let promise = streams[0].pipeTo(writable, {
        preventClose: true
    });
    let i = 1;
    for(; i < streams.length - 1; i++){
        const nextStream = streams[i];
        promise = promise.then(()=>nextStream.pipeTo(writable, {
                preventClose: true
            }));
    }
    // We can omit the length check because we halted before the last stream and there
    // is at least two streams so the lastStream here will always be defined
    const lastStream = streams[i];
    promise = promise.then(()=>lastStream.pipeTo(writable));
    // Catch any errors from the streams and ignore them, they will be handled
    // by whatever is consuming the readable stream.
    promise.catch(voidCatch);
    return readable;
}
function streamFromString(str) {
    return new ReadableStream({
        start (controller) {
            controller.enqueue(encoder.encode(str));
            controller.close();
        }
    });
}
function streamFromBuffer(chunk) {
    return new ReadableStream({
        start (controller) {
            controller.enqueue(chunk);
            controller.close();
        }
    });
}
async function streamToBuffer(stream) {
    const reader = stream.getReader();
    const chunks = [];
    while(true){
        const { done, value } = await reader.read();
        if (done) {
            break;
        }
        chunks.push(value);
    }
    return Buffer.concat(chunks);
}
async function streamToString(stream, signal) {
    const decoder = new TextDecoder('utf-8', {
        fatal: true
    });
    let string = '';
    for await (const chunk of stream){
        if (signal == null ? void 0 : signal.aborted) {
            return string;
        }
        string += decoder.decode(chunk, {
            stream: true
        });
    }
    string += decoder.decode();
    return string;
}
function createBufferedTransformStream() {
    let bufferedChunks = [];
    let bufferByteLength = 0;
    let pending;
    const flush = (controller)=>{
        // If we already have a pending flush, then return early.
        if (pending) return;
        const detached = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$detached$2d$promise$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["DetachedPromise"]();
        pending = detached;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$scheduler$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["scheduleImmediate"])(()=>{
            try {
                const chunk = new Uint8Array(bufferByteLength);
                let copiedBytes = 0;
                for(let i = 0; i < bufferedChunks.length; i++){
                    const bufferedChunk = bufferedChunks[i];
                    chunk.set(bufferedChunk, copiedBytes);
                    copiedBytes += bufferedChunk.byteLength;
                }
                // We just wrote all the buffered chunks so we need to reset the bufferedChunks array
                // and our bufferByteLength to prepare for the next round of buffered chunks
                bufferedChunks.length = 0;
                bufferByteLength = 0;
                controller.enqueue(chunk);
            } catch  {
            // If an error occurs while enqueuing it can't be due to this
            // transformers fault. It's likely due to the controller being
            // errored due to the stream being cancelled.
            } finally{
                pending = undefined;
                detached.resolve();
            }
        });
    };
    return new TransformStream({
        transform (chunk, controller) {
            // Combine the previous buffer with the new chunk.
            bufferedChunks.push(chunk);
            bufferByteLength += chunk.byteLength;
            // Flush the buffer to the controller.
            flush(controller);
        },
        flush () {
            if (!pending) return;
            return pending.promise;
        }
    });
}
function createPrefetchCommentStream(isBuildTimePrerendering, buildId) {
    // Insert an extra comment at the beginning of the HTML document. This must
    // come after the DOCTYPE, which is inserted by React.
    //
    // The first chunk sent by React will contain the doctype. After that, we can
    // pass through the rest of the chunks as-is.
    let didTransformFirstChunk = false;
    return new TransformStream({
        transform (chunk, controller) {
            if (isBuildTimePrerendering && !didTransformFirstChunk) {
                didTransformFirstChunk = true;
                const decoder = new TextDecoder('utf-8', {
                    fatal: true
                });
                const chunkStr = decoder.decode(chunk, {
                    stream: true
                });
                const updatedChunkStr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$segment$2d$cache$2f$output$2d$export$2d$prefetch$2d$encoding$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["insertBuildIdComment"])(chunkStr, buildId);
                controller.enqueue(encoder.encode(updatedChunkStr));
                return;
            }
            controller.enqueue(chunk);
        }
    });
}
function renderToInitialFizzStream({ ReactDOMServer, element, streamOptions }) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$tracer$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["getTracer"])().trace(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$constants$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["AppRenderSpan"].renderToReadableStream, async ()=>ReactDOMServer.renderToReadableStream(element, streamOptions));
}
function createMetadataTransformStream(insert) {
    let chunkIndex = -1;
    let isMarkRemoved = false;
    return new TransformStream({
        async transform (chunk, controller) {
            let iconMarkIndex = -1;
            let closedHeadIndex = -1;
            chunkIndex++;
            if (isMarkRemoved) {
                controller.enqueue(chunk);
                return;
            }
            let iconMarkLength = 0;
            // Only search for the closed head tag once
            if (iconMarkIndex === -1) {
                iconMarkIndex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$uint8array$2d$helpers$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["indexOfUint8Array"])(chunk, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$encoded$2d$tags$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["ENCODED_TAGS"].META.ICON_MARK);
                if (iconMarkIndex === -1) {
                    controller.enqueue(chunk);
                    return;
                } else {
                    // When we found the `<meta name="«nxt-icon»"` tag prefix, we will remove it from the chunk.
                    // Its close tag could either be `/>` or `>`, checking the next char to ensure we cover both cases.
                    iconMarkLength = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$encoded$2d$tags$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["ENCODED_TAGS"].META.ICON_MARK.length;
                    // Check if next char is /, this is for xml mode.
                    if (chunk[iconMarkIndex + iconMarkLength] === 47) {
                        iconMarkLength += 2;
                    } else {
                        // The last char is `>`
                        iconMarkLength++;
                    }
                }
            }
            // Check if icon mark is inside <head> tag in the first chunk.
            if (chunkIndex === 0) {
                closedHeadIndex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$uint8array$2d$helpers$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["indexOfUint8Array"])(chunk, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$encoded$2d$tags$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["ENCODED_TAGS"].CLOSED.HEAD);
                if (iconMarkIndex !== -1) {
                    // The mark icon is located in the 1st chunk before the head tag.
                    // We do not need to insert the script tag in this case because it's in the head.
                    // Just remove the icon mark from the chunk.
                    if (iconMarkIndex < closedHeadIndex) {
                        const replaced = new Uint8Array(chunk.length - iconMarkLength);
                        // Remove the icon mark from the chunk.
                        replaced.set(chunk.subarray(0, iconMarkIndex));
                        replaced.set(chunk.subarray(iconMarkIndex + iconMarkLength), iconMarkIndex);
                        chunk = replaced;
                    } else {
                        // The icon mark is after the head tag, replace and insert the script tag at that position.
                        const insertion = await insert();
                        const encodedInsertion = encoder.encode(insertion);
                        const insertionLength = encodedInsertion.length;
                        const replaced = new Uint8Array(chunk.length - iconMarkLength + insertionLength);
                        replaced.set(chunk.subarray(0, iconMarkIndex));
                        replaced.set(encodedInsertion, iconMarkIndex);
                        replaced.set(chunk.subarray(iconMarkIndex + iconMarkLength), iconMarkIndex + insertionLength);
                        chunk = replaced;
                    }
                    isMarkRemoved = true;
                }
            // If there's no icon mark located, it will be handled later when if present in the following chunks.
            } else {
                // When it's appeared in the following chunks, we'll need to
                // remove the mark and then insert the script tag at that position.
                const insertion = await insert();
                const encodedInsertion = encoder.encode(insertion);
                const insertionLength = encodedInsertion.length;
                // Replace the icon mark with the hoist script or empty string.
                const replaced = new Uint8Array(chunk.length - iconMarkLength + insertionLength);
                // Set the first part of the chunk, before the icon mark.
                replaced.set(chunk.subarray(0, iconMarkIndex));
                // Set the insertion after the icon mark.
                replaced.set(encodedInsertion, iconMarkIndex);
                // Set the rest of the chunk after the icon mark.
                replaced.set(chunk.subarray(iconMarkIndex + iconMarkLength), iconMarkIndex + insertionLength);
                chunk = replaced;
                isMarkRemoved = true;
            }
            controller.enqueue(chunk);
        }
    });
}
function createHeadInsertionTransformStream(insert) {
    let inserted = false;
    // We need to track if this transform saw any bytes because if it didn't
    // we won't want to insert any server HTML at all
    let hasBytes = false;
    return new TransformStream({
        async transform (chunk, controller) {
            hasBytes = true;
            const insertion = await insert();
            if (inserted) {
                if (insertion) {
                    const encodedInsertion = encoder.encode(insertion);
                    controller.enqueue(encodedInsertion);
                }
                controller.enqueue(chunk);
            } else {
                // TODO (@Ethan-Arrowood): Replace the generic `indexOfUint8Array` method with something finely tuned for the subset of things actually being checked for.
                const index = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$uint8array$2d$helpers$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["indexOfUint8Array"])(chunk, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$encoded$2d$tags$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["ENCODED_TAGS"].CLOSED.HEAD);
                // In fully static rendering or non PPR rendering cases:
                // `/head>` will always be found in the chunk in first chunk rendering.
                if (index !== -1) {
                    if (insertion) {
                        const encodedInsertion = encoder.encode(insertion);
                        // Get the total count of the bytes in the chunk and the insertion
                        // e.g.
                        // chunk = <head><meta charset="utf-8"></head>
                        // insertion = <script>...</script>
                        // output = <head><meta charset="utf-8"> [ <script>...</script> ] </head>
                        const insertedHeadContent = new Uint8Array(chunk.length + encodedInsertion.length);
                        // Append the first part of the chunk, before the head tag
                        insertedHeadContent.set(chunk.slice(0, index));
                        // Append the server inserted content
                        insertedHeadContent.set(encodedInsertion, index);
                        // Append the rest of the chunk
                        insertedHeadContent.set(chunk.slice(index), index + encodedInsertion.length);
                        controller.enqueue(insertedHeadContent);
                    } else {
                        controller.enqueue(chunk);
                    }
                    inserted = true;
                } else {
                    // This will happens in PPR rendering during next start, when the page is partially rendered.
                    // When the page resumes, the head tag will be found in the middle of the chunk.
                    // Where we just need to append the insertion and chunk to the current stream.
                    // e.g.
                    // PPR-static: <head>...</head><body> [ resume content ] </body>
                    // PPR-resume: [ insertion ] [ rest content ]
                    if (insertion) {
                        controller.enqueue(encoder.encode(insertion));
                    }
                    controller.enqueue(chunk);
                    inserted = true;
                }
            }
        },
        async flush (controller) {
            // Check before closing if there's anything remaining to insert.
            if (hasBytes) {
                const insertion = await insert();
                if (insertion) {
                    controller.enqueue(encoder.encode(insertion));
                }
            }
        }
    });
}
// Suffix after main body content - scripts before </body>,
// but wait for the major chunks to be enqueued.
function createDeferredSuffixStream(suffix) {
    let flushed = false;
    let pending;
    const flush = (controller)=>{
        const detached = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$detached$2d$promise$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["DetachedPromise"]();
        pending = detached;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$scheduler$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["scheduleImmediate"])(()=>{
            try {
                controller.enqueue(encoder.encode(suffix));
            } catch  {
            // If an error occurs while enqueuing it can't be due to this
            // transformers fault. It's likely due to the controller being
            // errored due to the stream being cancelled.
            } finally{
                pending = undefined;
                detached.resolve();
            }
        });
    };
    return new TransformStream({
        transform (chunk, controller) {
            controller.enqueue(chunk);
            // If we've already flushed, we're done.
            if (flushed) return;
            // Schedule the flush to happen.
            flushed = true;
            flush(controller);
        },
        flush (controller) {
            if (pending) return pending.promise;
            if (flushed) return;
            // Flush now.
            controller.enqueue(encoder.encode(suffix));
        }
    });
}
// Merge two streams into one. Ensure the final transform stream is closed
// when both are finished.
function createMergedTransformStream(stream) {
    let pull = null;
    let donePulling = false;
    async function startPulling(controller) {
        if (pull) {
            return;
        }
        const reader = stream.getReader();
        // NOTE: streaming flush
        // We are buffering here for the inlined data stream because the
        // "shell" stream might be chunkenized again by the underlying stream
        // implementation, e.g. with a specific high-water mark. To ensure it's
        // the safe timing to pipe the data stream, this extra tick is
        // necessary.
        // We don't start reading until we've left the current Task to ensure
        // that it's inserted after flushing the shell. Note that this implementation
        // might get stale if impl details of Fizz change in the future.
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$scheduler$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["atLeastOneTask"])();
        try {
            while(true){
                const { done, value } = await reader.read();
                if (done) {
                    donePulling = true;
                    return;
                }
                controller.enqueue(value);
            }
        } catch (err) {
            controller.error(err);
        }
    }
    return new TransformStream({
        transform (chunk, controller) {
            controller.enqueue(chunk);
            // Start the streaming if it hasn't already been started yet.
            if (!pull) {
                pull = startPulling(controller);
            }
        },
        flush (controller) {
            if (donePulling) {
                return;
            }
            return pull || startPulling(controller);
        }
    });
}
const CLOSE_TAG = '</body></html>';
/**
 * This transform stream moves the suffix to the end of the stream, so results
 * like `</body></html><script>...</script>` will be transformed to
 * `<script>...</script></body></html>`.
 */ function createMoveSuffixStream() {
    let foundSuffix = false;
    return new TransformStream({
        transform (chunk, controller) {
            if (foundSuffix) {
                return controller.enqueue(chunk);
            }
            const index = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$uint8array$2d$helpers$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["indexOfUint8Array"])(chunk, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$encoded$2d$tags$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["ENCODED_TAGS"].CLOSED.BODY_AND_HTML);
            if (index > -1) {
                foundSuffix = true;
                // If the whole chunk is the suffix, then don't write anything, it will
                // be written in the flush.
                if (chunk.length === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$encoded$2d$tags$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["ENCODED_TAGS"].CLOSED.BODY_AND_HTML.length) {
                    return;
                }
                // Write out the part before the suffix.
                const before = chunk.slice(0, index);
                controller.enqueue(before);
                // In the case where the suffix is in the middle of the chunk, we need
                // to split the chunk into two parts.
                if (chunk.length > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$encoded$2d$tags$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["ENCODED_TAGS"].CLOSED.BODY_AND_HTML.length + index) {
                    // Write out the part after the suffix.
                    const after = chunk.slice(index + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$encoded$2d$tags$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["ENCODED_TAGS"].CLOSED.BODY_AND_HTML.length);
                    controller.enqueue(after);
                }
            } else {
                controller.enqueue(chunk);
            }
        },
        flush (controller) {
            // Even if we didn't find the suffix, the HTML is not valid if we don't
            // add it, so insert it at the end.
            controller.enqueue(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$encoded$2d$tags$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["ENCODED_TAGS"].CLOSED.BODY_AND_HTML);
        }
    });
}
function createStripDocumentClosingTagsTransform() {
    return new TransformStream({
        transform (chunk, controller) {
            // We rely on the assumption that chunks will never break across a code unit.
            // This is reasonable because we currently concat all of React's output from a single
            // flush into one chunk before streaming it forward which means the chunk will represent
            // a single coherent utf-8 string. This is not safe to use if we change our streaming to no
            // longer do this large buffered chunk
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$uint8array$2d$helpers$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["isEquivalentUint8Arrays"])(chunk, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$encoded$2d$tags$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["ENCODED_TAGS"].CLOSED.BODY_AND_HTML) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$uint8array$2d$helpers$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["isEquivalentUint8Arrays"])(chunk, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$encoded$2d$tags$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["ENCODED_TAGS"].CLOSED.BODY) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$uint8array$2d$helpers$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["isEquivalentUint8Arrays"])(chunk, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$encoded$2d$tags$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["ENCODED_TAGS"].CLOSED.HTML)) {
                // the entire chunk is the closing tags; return without enqueueing anything.
                return;
            }
            // We assume these tags will go at together at the end of the document and that
            // they won't appear anywhere else in the document. This is not really a safe assumption
            // but until we revamp our streaming infra this is a performant way to string the tags
            chunk = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$uint8array$2d$helpers$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["removeFromUint8Array"])(chunk, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$encoded$2d$tags$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["ENCODED_TAGS"].CLOSED.BODY);
            chunk = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$uint8array$2d$helpers$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["removeFromUint8Array"])(chunk, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$encoded$2d$tags$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["ENCODED_TAGS"].CLOSED.HTML);
            controller.enqueue(chunk);
        }
    });
}
function createRootLayoutValidatorStream() {
    let foundHtml = false;
    let foundBody = false;
    return new TransformStream({
        async transform (chunk, controller) {
            // Peek into the streamed chunk to see if the tags are present.
            if (!foundHtml && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$uint8array$2d$helpers$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["indexOfUint8Array"])(chunk, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$encoded$2d$tags$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["ENCODED_TAGS"].OPENING.HTML) > -1) {
                foundHtml = true;
            }
            if (!foundBody && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$uint8array$2d$helpers$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["indexOfUint8Array"])(chunk, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$encoded$2d$tags$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["ENCODED_TAGS"].OPENING.BODY) > -1) {
                foundBody = true;
            }
            controller.enqueue(chunk);
        },
        flush (controller) {
            const missingTags = [];
            if (!foundHtml) missingTags.push('html');
            if (!foundBody) missingTags.push('body');
            if (!missingTags.length) return;
            controller.enqueue(encoder.encode(`<html id="__next_error__">
            <template
              data-next-error-message="Missing ${missingTags.map((c)=>`<${c}>`).join(missingTags.length > 1 ? ' and ' : '')} tags in the root layout.\nRead more at https://nextjs.org/docs/messages/missing-root-layout-tags""
              data-next-error-digest="${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$errors$2f$constants$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["MISSING_ROOT_TAGS_ERROR"]}"
              data-next-error-stack=""
            ></template>
          `));
        }
    });
}
function chainTransformers(readable, transformers) {
    let stream = readable;
    for (const transformer of transformers){
        if (!transformer) continue;
        stream = stream.pipeThrough(transformer);
    }
    return stream;
}
async function continueFizzStream(renderStream, { suffix, inlinedDataStream, isStaticGeneration, isBuildTimePrerendering, buildId, getServerInsertedHTML, getServerInsertedMetadata, validateRootLayout }) {
    // Suffix itself might contain close tags at the end, so we need to split it.
    const suffixUnclosed = suffix ? suffix.split(CLOSE_TAG, 1)[0] : null;
    // If we're generating static HTML and there's an `allReady` promise on the
    // stream, we need to wait for it to resolve before continuing.
    if (isStaticGeneration && 'allReady' in renderStream) {
        await renderStream.allReady;
    }
    return chainTransformers(renderStream, [
        // Buffer everything to avoid flushing too frequently
        createBufferedTransformStream(),
        // Add build id comment to start of the HTML document (in export mode)
        createPrefetchCommentStream(isBuildTimePrerendering, buildId),
        // Transform metadata
        createMetadataTransformStream(getServerInsertedMetadata),
        // Insert suffix content
        suffixUnclosed != null && suffixUnclosed.length > 0 ? createDeferredSuffixStream(suffixUnclosed) : null,
        // Insert the inlined data (Flight data, form state, etc.) stream into the HTML
        inlinedDataStream ? createMergedTransformStream(inlinedDataStream) : null,
        // Validate the root layout for missing html or body tags
        validateRootLayout ? createRootLayoutValidatorStream() : null,
        // Close tags should always be deferred to the end
        createMoveSuffixStream(),
        // Special head insertions
        // TODO-APP: Insert server side html to end of head in app layout rendering, to avoid
        // hydration errors. Remove this once it's ready to be handled by react itself.
        createHeadInsertionTransformStream(getServerInsertedHTML)
    ]);
}
async function continueDynamicPrerender(prerenderStream, { getServerInsertedHTML, getServerInsertedMetadata }) {
    return prerenderStream // Buffer everything to avoid flushing too frequently
    .pipeThrough(createBufferedTransformStream()).pipeThrough(createStripDocumentClosingTagsTransform()) // Insert generated tags to head
    .pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML)) // Transform metadata
    .pipeThrough(createMetadataTransformStream(getServerInsertedMetadata));
}
async function continueStaticPrerender(prerenderStream, { inlinedDataStream, getServerInsertedHTML, getServerInsertedMetadata, isBuildTimePrerendering, buildId }) {
    return prerenderStream // Buffer everything to avoid flushing too frequently
    .pipeThrough(createBufferedTransformStream()) // Add build id comment to start of the HTML document (in export mode)
    .pipeThrough(createPrefetchCommentStream(isBuildTimePrerendering, buildId)) // Insert generated tags to head
    .pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML)) // Transform metadata
    .pipeThrough(createMetadataTransformStream(getServerInsertedMetadata)) // Insert the inlined data (Flight data, form state, etc.) stream into the HTML
    .pipeThrough(createMergedTransformStream(inlinedDataStream)) // Close tags should always be deferred to the end
    .pipeThrough(createMoveSuffixStream());
}
async function continueDynamicHTMLResume(renderStream, { inlinedDataStream, getServerInsertedHTML, getServerInsertedMetadata }) {
    return renderStream // Buffer everything to avoid flushing too frequently
    .pipeThrough(createBufferedTransformStream()) // Insert generated tags to head
    .pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML)) // Transform metadata
    .pipeThrough(createMetadataTransformStream(getServerInsertedMetadata)) // Insert the inlined data (Flight data, form state, etc.) stream into the HTML
    .pipeThrough(createMergedTransformStream(inlinedDataStream)) // Close tags should always be deferred to the end
    .pipeThrough(createMoveSuffixStream());
}
function createDocumentClosingStream() {
    return streamFromString(CLOSE_TAG);
} //# sourceMappingURL=node-web-streams-helper.js.map
}),
"[project]/node_modules/next/dist/esm/lib/constants.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "ACTION_SUFFIX": ()=>ACTION_SUFFIX,
    "APP_DIR_ALIAS": ()=>APP_DIR_ALIAS,
    "CACHE_ONE_YEAR": ()=>CACHE_ONE_YEAR,
    "DOT_NEXT_ALIAS": ()=>DOT_NEXT_ALIAS,
    "ESLINT_DEFAULT_DIRS": ()=>ESLINT_DEFAULT_DIRS,
    "GSP_NO_RETURNED_VALUE": ()=>GSP_NO_RETURNED_VALUE,
    "GSSP_COMPONENT_MEMBER_ERROR": ()=>GSSP_COMPONENT_MEMBER_ERROR,
    "GSSP_NO_RETURNED_VALUE": ()=>GSSP_NO_RETURNED_VALUE,
    "INFINITE_CACHE": ()=>INFINITE_CACHE,
    "INSTRUMENTATION_HOOK_FILENAME": ()=>INSTRUMENTATION_HOOK_FILENAME,
    "MATCHED_PATH_HEADER": ()=>MATCHED_PATH_HEADER,
    "MIDDLEWARE_FILENAME": ()=>MIDDLEWARE_FILENAME,
    "MIDDLEWARE_LOCATION_REGEXP": ()=>MIDDLEWARE_LOCATION_REGEXP,
    "NEXT_BODY_SUFFIX": ()=>NEXT_BODY_SUFFIX,
    "NEXT_CACHE_IMPLICIT_TAG_ID": ()=>NEXT_CACHE_IMPLICIT_TAG_ID,
    "NEXT_CACHE_REVALIDATED_TAGS_HEADER": ()=>NEXT_CACHE_REVALIDATED_TAGS_HEADER,
    "NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER": ()=>NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER,
    "NEXT_CACHE_SOFT_TAG_MAX_LENGTH": ()=>NEXT_CACHE_SOFT_TAG_MAX_LENGTH,
    "NEXT_CACHE_TAGS_HEADER": ()=>NEXT_CACHE_TAGS_HEADER,
    "NEXT_CACHE_TAG_MAX_ITEMS": ()=>NEXT_CACHE_TAG_MAX_ITEMS,
    "NEXT_CACHE_TAG_MAX_LENGTH": ()=>NEXT_CACHE_TAG_MAX_LENGTH,
    "NEXT_DATA_SUFFIX": ()=>NEXT_DATA_SUFFIX,
    "NEXT_INTERCEPTION_MARKER_PREFIX": ()=>NEXT_INTERCEPTION_MARKER_PREFIX,
    "NEXT_META_SUFFIX": ()=>NEXT_META_SUFFIX,
    "NEXT_QUERY_PARAM_PREFIX": ()=>NEXT_QUERY_PARAM_PREFIX,
    "NEXT_RESUME_HEADER": ()=>NEXT_RESUME_HEADER,
    "NON_STANDARD_NODE_ENV": ()=>NON_STANDARD_NODE_ENV,
    "PAGES_DIR_ALIAS": ()=>PAGES_DIR_ALIAS,
    "PRERENDER_REVALIDATE_HEADER": ()=>PRERENDER_REVALIDATE_HEADER,
    "PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER": ()=>PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER,
    "PUBLIC_DIR_MIDDLEWARE_CONFLICT": ()=>PUBLIC_DIR_MIDDLEWARE_CONFLICT,
    "ROOT_DIR_ALIAS": ()=>ROOT_DIR_ALIAS,
    "RSC_ACTION_CLIENT_WRAPPER_ALIAS": ()=>RSC_ACTION_CLIENT_WRAPPER_ALIAS,
    "RSC_ACTION_ENCRYPTION_ALIAS": ()=>RSC_ACTION_ENCRYPTION_ALIAS,
    "RSC_ACTION_PROXY_ALIAS": ()=>RSC_ACTION_PROXY_ALIAS,
    "RSC_ACTION_VALIDATE_ALIAS": ()=>RSC_ACTION_VALIDATE_ALIAS,
    "RSC_CACHE_WRAPPER_ALIAS": ()=>RSC_CACHE_WRAPPER_ALIAS,
    "RSC_DYNAMIC_IMPORT_WRAPPER_ALIAS": ()=>RSC_DYNAMIC_IMPORT_WRAPPER_ALIAS,
    "RSC_MOD_REF_PROXY_ALIAS": ()=>RSC_MOD_REF_PROXY_ALIAS,
    "RSC_PREFETCH_SUFFIX": ()=>RSC_PREFETCH_SUFFIX,
    "RSC_SEGMENTS_DIR_SUFFIX": ()=>RSC_SEGMENTS_DIR_SUFFIX,
    "RSC_SEGMENT_SUFFIX": ()=>RSC_SEGMENT_SUFFIX,
    "RSC_SUFFIX": ()=>RSC_SUFFIX,
    "SERVER_PROPS_EXPORT_ERROR": ()=>SERVER_PROPS_EXPORT_ERROR,
    "SERVER_PROPS_GET_INIT_PROPS_CONFLICT": ()=>SERVER_PROPS_GET_INIT_PROPS_CONFLICT,
    "SERVER_PROPS_SSG_CONFLICT": ()=>SERVER_PROPS_SSG_CONFLICT,
    "SERVER_RUNTIME": ()=>SERVER_RUNTIME,
    "SSG_FALLBACK_EXPORT_ERROR": ()=>SSG_FALLBACK_EXPORT_ERROR,
    "SSG_GET_INITIAL_PROPS_CONFLICT": ()=>SSG_GET_INITIAL_PROPS_CONFLICT,
    "STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR": ()=>STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR,
    "UNSTABLE_REVALIDATE_RENAME_ERROR": ()=>UNSTABLE_REVALIDATE_RENAME_ERROR,
    "WEBPACK_LAYERS": ()=>WEBPACK_LAYERS,
    "WEBPACK_RESOURCE_QUERIES": ()=>WEBPACK_RESOURCE_QUERIES
});
const NEXT_QUERY_PARAM_PREFIX = 'nxtP';
const NEXT_INTERCEPTION_MARKER_PREFIX = 'nxtI';
const MATCHED_PATH_HEADER = 'x-matched-path';
const PRERENDER_REVALIDATE_HEADER = 'x-prerender-revalidate';
const PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER = 'x-prerender-revalidate-if-generated';
const RSC_PREFETCH_SUFFIX = '.prefetch.rsc';
const RSC_SEGMENTS_DIR_SUFFIX = '.segments';
const RSC_SEGMENT_SUFFIX = '.segment.rsc';
const RSC_SUFFIX = '.rsc';
const ACTION_SUFFIX = '.action';
const NEXT_DATA_SUFFIX = '.json';
const NEXT_META_SUFFIX = '.meta';
const NEXT_BODY_SUFFIX = '.body';
const NEXT_CACHE_TAGS_HEADER = 'x-next-cache-tags';
const NEXT_CACHE_REVALIDATED_TAGS_HEADER = 'x-next-revalidated-tags';
const NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER = 'x-next-revalidate-tag-token';
const NEXT_RESUME_HEADER = 'next-resume';
const NEXT_CACHE_TAG_MAX_ITEMS = 128;
const NEXT_CACHE_TAG_MAX_LENGTH = 256;
const NEXT_CACHE_SOFT_TAG_MAX_LENGTH = 1024;
const NEXT_CACHE_IMPLICIT_TAG_ID = '_N_T_';
const CACHE_ONE_YEAR = 31536000;
const INFINITE_CACHE = 0xfffffffe;
const MIDDLEWARE_FILENAME = 'middleware';
const MIDDLEWARE_LOCATION_REGEXP = `(?:src/)?${MIDDLEWARE_FILENAME}`;
const INSTRUMENTATION_HOOK_FILENAME = 'instrumentation';
const PAGES_DIR_ALIAS = 'private-next-pages';
const DOT_NEXT_ALIAS = 'private-dot-next';
const ROOT_DIR_ALIAS = 'private-next-root-dir';
const APP_DIR_ALIAS = 'private-next-app-dir';
const RSC_MOD_REF_PROXY_ALIAS = 'private-next-rsc-mod-ref-proxy';
const RSC_ACTION_VALIDATE_ALIAS = 'private-next-rsc-action-validate';
const RSC_ACTION_PROXY_ALIAS = 'private-next-rsc-server-reference';
const RSC_CACHE_WRAPPER_ALIAS = 'private-next-rsc-cache-wrapper';
const RSC_DYNAMIC_IMPORT_WRAPPER_ALIAS = 'private-next-rsc-track-dynamic-import';
const RSC_ACTION_ENCRYPTION_ALIAS = 'private-next-rsc-action-encryption';
const RSC_ACTION_CLIENT_WRAPPER_ALIAS = 'private-next-rsc-action-client-wrapper';
const PUBLIC_DIR_MIDDLEWARE_CONFLICT = `You can not have a '_next' folder inside of your public folder. This conflicts with the internal '/_next' route. https://nextjs.org/docs/messages/public-next-folder-conflict`;
const SSG_GET_INITIAL_PROPS_CONFLICT = `You can not use getInitialProps with getStaticProps. To use SSG, please remove your getInitialProps`;
const SERVER_PROPS_GET_INIT_PROPS_CONFLICT = `You can not use getInitialProps with getServerSideProps. Please remove getInitialProps.`;
const SERVER_PROPS_SSG_CONFLICT = `You can not use getStaticProps or getStaticPaths with getServerSideProps. To use SSG, please remove getServerSideProps`;
const STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR = `can not have getInitialProps/getServerSideProps, https://nextjs.org/docs/messages/404-get-initial-props`;
const SERVER_PROPS_EXPORT_ERROR = `pages with \`getServerSideProps\` can not be exported. See more info here: https://nextjs.org/docs/messages/gssp-export`;
const GSP_NO_RETURNED_VALUE = 'Your `getStaticProps` function did not return an object. Did you forget to add a `return`?';
const GSSP_NO_RETURNED_VALUE = 'Your `getServerSideProps` function did not return an object. Did you forget to add a `return`?';
const UNSTABLE_REVALIDATE_RENAME_ERROR = 'The `unstable_revalidate` property is available for general use.\n' + 'Please use `revalidate` instead.';
const GSSP_COMPONENT_MEMBER_ERROR = `can not be attached to a page's component and must be exported from the page. See more info here: https://nextjs.org/docs/messages/gssp-component-member`;
const NON_STANDARD_NODE_ENV = `You are using a non-standard "NODE_ENV" value in your environment. This creates inconsistencies in the project and is strongly advised against. Read more: https://nextjs.org/docs/messages/non-standard-node-env`;
const SSG_FALLBACK_EXPORT_ERROR = `Pages with \`fallback\` enabled in \`getStaticPaths\` can not be exported. See more info here: https://nextjs.org/docs/messages/ssg-fallback-true-export`;
const ESLINT_DEFAULT_DIRS = [
    'app',
    'pages',
    'components',
    'lib',
    'src'
];
const SERVER_RUNTIME = {
    edge: 'edge',
    experimentalEdge: 'experimental-edge',
    nodejs: 'nodejs'
};
/**
 * The names of the webpack layers. These layers are the primitives for the
 * webpack chunks.
 */ const WEBPACK_LAYERS_NAMES = {
    /**
   * The layer for the shared code between the client and server bundles.
   */ shared: 'shared',
    /**
   * The layer for server-only runtime and picking up `react-server` export conditions.
   * Including app router RSC pages and app router custom routes and metadata routes.
   */ reactServerComponents: 'rsc',
    /**
   * Server Side Rendering layer for app (ssr).
   */ serverSideRendering: 'ssr',
    /**
   * The browser client bundle layer for actions.
   */ actionBrowser: 'action-browser',
    /**
   * The Node.js bundle layer for the API routes.
   */ apiNode: 'api-node',
    /**
   * The Edge Lite bundle layer for the API routes.
   */ apiEdge: 'api-edge',
    /**
   * The layer for the middleware code.
   */ middleware: 'middleware',
    /**
   * The layer for the instrumentation hooks.
   */ instrument: 'instrument',
    /**
   * The layer for assets on the edge.
   */ edgeAsset: 'edge-asset',
    /**
   * The browser client bundle layer for App directory.
   */ appPagesBrowser: 'app-pages-browser',
    /**
   * The browser client bundle layer for Pages directory.
   */ pagesDirBrowser: 'pages-dir-browser',
    /**
   * The Edge Lite bundle layer for Pages directory.
   */ pagesDirEdge: 'pages-dir-edge',
    /**
   * The Node.js bundle layer for Pages directory.
   */ pagesDirNode: 'pages-dir-node'
};
const WEBPACK_LAYERS = {
    ...WEBPACK_LAYERS_NAMES,
    GROUP: {
        builtinReact: [
            WEBPACK_LAYERS_NAMES.reactServerComponents,
            WEBPACK_LAYERS_NAMES.actionBrowser
        ],
        serverOnly: [
            WEBPACK_LAYERS_NAMES.reactServerComponents,
            WEBPACK_LAYERS_NAMES.actionBrowser,
            WEBPACK_LAYERS_NAMES.instrument,
            WEBPACK_LAYERS_NAMES.middleware
        ],
        neutralTarget: [
            // pages api
            WEBPACK_LAYERS_NAMES.apiNode,
            WEBPACK_LAYERS_NAMES.apiEdge
        ],
        clientOnly: [
            WEBPACK_LAYERS_NAMES.serverSideRendering,
            WEBPACK_LAYERS_NAMES.appPagesBrowser
        ],
        bundled: [
            WEBPACK_LAYERS_NAMES.reactServerComponents,
            WEBPACK_LAYERS_NAMES.actionBrowser,
            WEBPACK_LAYERS_NAMES.serverSideRendering,
            WEBPACK_LAYERS_NAMES.appPagesBrowser,
            WEBPACK_LAYERS_NAMES.shared,
            WEBPACK_LAYERS_NAMES.instrument,
            WEBPACK_LAYERS_NAMES.middleware
        ],
        appPages: [
            // app router pages and layouts
            WEBPACK_LAYERS_NAMES.reactServerComponents,
            WEBPACK_LAYERS_NAMES.serverSideRendering,
            WEBPACK_LAYERS_NAMES.appPagesBrowser,
            WEBPACK_LAYERS_NAMES.actionBrowser
        ]
    }
};
const WEBPACK_RESOURCE_QUERIES = {
    edgeSSREntry: '__next_edge_ssr_entry__',
    metadata: '__next_metadata__',
    metadataRoute: '__next_metadata_route__',
    metadataImageMeta: '__next_metadata_image_meta__'
};
;
 //# sourceMappingURL=constants.js.map
}),
"[project]/node_modules/next/dist/esm/server/web/utils.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "fromNodeOutgoingHttpHeaders": ()=>fromNodeOutgoingHttpHeaders,
    "normalizeNextQueryParam": ()=>normalizeNextQueryParam,
    "splitCookiesString": ()=>splitCookiesString,
    "toNodeOutgoingHttpHeaders": ()=>toNodeOutgoingHttpHeaders,
    "validateURL": ()=>validateURL
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$constants$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/constants.js [ssr] (ecmascript)");
;
function fromNodeOutgoingHttpHeaders(nodeHeaders) {
    const headers = new Headers();
    for (let [key, value] of Object.entries(nodeHeaders)){
        const values = Array.isArray(value) ? value : [
            value
        ];
        for (let v of values){
            if (typeof v === 'undefined') continue;
            if (typeof v === 'number') {
                v = v.toString();
            }
            headers.append(key, v);
        }
    }
    return headers;
}
function splitCookiesString(cookiesString) {
    var cookiesStrings = [];
    var pos = 0;
    var start;
    var ch;
    var lastComma;
    var nextStart;
    var cookiesSeparatorFound;
    function skipWhitespace() {
        while(pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))){
            pos += 1;
        }
        return pos < cookiesString.length;
    }
    function notSpecialChar() {
        ch = cookiesString.charAt(pos);
        return ch !== '=' && ch !== ';' && ch !== ',';
    }
    while(pos < cookiesString.length){
        start = pos;
        cookiesSeparatorFound = false;
        while(skipWhitespace()){
            ch = cookiesString.charAt(pos);
            if (ch === ',') {
                // ',' is a cookie separator if we have later first '=', not ';' or ','
                lastComma = pos;
                pos += 1;
                skipWhitespace();
                nextStart = pos;
                while(pos < cookiesString.length && notSpecialChar()){
                    pos += 1;
                }
                // currently special character
                if (pos < cookiesString.length && cookiesString.charAt(pos) === '=') {
                    // we found cookies separator
                    cookiesSeparatorFound = true;
                    // pos is inside the next cookie, so back up and return it.
                    pos = nextStart;
                    cookiesStrings.push(cookiesString.substring(start, lastComma));
                    start = pos;
                } else {
                    // in param ',' or param separator ';',
                    // we continue from that comma
                    pos = lastComma + 1;
                }
            } else {
                pos += 1;
            }
        }
        if (!cookiesSeparatorFound || pos >= cookiesString.length) {
            cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
        }
    }
    return cookiesStrings;
}
function toNodeOutgoingHttpHeaders(headers) {
    const nodeHeaders = {};
    const cookies = [];
    if (headers) {
        for (const [key, value] of headers.entries()){
            if (key.toLowerCase() === 'set-cookie') {
                // We may have gotten a comma joined string of cookies, or multiple
                // set-cookie headers. We need to merge them into one header array
                // to represent all the cookies.
                cookies.push(...splitCookiesString(value));
                nodeHeaders[key] = cookies.length === 1 ? cookies[0] : cookies;
            } else {
                nodeHeaders[key] = value;
            }
        }
    }
    return nodeHeaders;
}
function validateURL(url) {
    try {
        return String(new URL(String(url)));
    } catch (error) {
        throw Object.defineProperty(new Error(`URL is malformed "${String(url)}". Please use only absolute URLs - https://nextjs.org/docs/messages/middleware-relative-urls`, {
            cause: error
        }), "__NEXT_ERROR_CODE", {
            value: "E61",
            enumerable: false,
            configurable: true
        });
    }
}
function normalizeNextQueryParam(key) {
    const prefixes = [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$constants$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["NEXT_QUERY_PARAM_PREFIX"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$constants$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["NEXT_INTERCEPTION_MARKER_PREFIX"]
    ];
    for (const prefix of prefixes){
        if (key !== prefix && key.startsWith(prefix)) {
            return key.substring(prefix.length);
        }
    }
    return null;
} //# sourceMappingURL=utils.js.map
}),
"[project]/node_modules/next/dist/esm/shared/lib/i18n/detect-domain-locale.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "detectDomainLocale": ()=>detectDomainLocale
});
function detectDomainLocale(domainItems, hostname, detectedLocale) {
    if (!domainItems) return;
    if (detectedLocale) {
        detectedLocale = detectedLocale.toLowerCase();
    }
    for (const item of domainItems){
        var _item_domain, _item_locales;
        // remove port if present
        const domainHostname = (_item_domain = item.domain) == null ? void 0 : _item_domain.split(':', 1)[0].toLowerCase();
        if (hostname === domainHostname || detectedLocale === item.defaultLocale.toLowerCase() || ((_item_locales = item.locales) == null ? void 0 : _item_locales.some((locale)=>locale.toLowerCase() === detectedLocale))) {
            return item;
        }
    }
} //# sourceMappingURL=detect-domain-locale.js.map
}),
"[project]/node_modules/next/dist/esm/shared/lib/router/utils/remove-trailing-slash.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * Removes the trailing slash for a given route or page path. Preserves the
 * root page. Examples:
 *   - `/foo/bar/` -> `/foo/bar`
 *   - `/foo/bar` -> `/foo/bar`
 *   - `/` -> `/`
 */ __turbopack_context__.s({
    "removeTrailingSlash": ()=>removeTrailingSlash
});
function removeTrailingSlash(route) {
    return route.replace(/\/$/, '') || '/';
} //# sourceMappingURL=remove-trailing-slash.js.map
}),
"[project]/node_modules/next/dist/esm/shared/lib/router/utils/parse-path.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * Given a path this function will find the pathname, query and hash and return
 * them. This is useful to parse full paths on the client side.
 * @param path A path to parse e.g. /foo/bar?id=1#hash
 */ __turbopack_context__.s({
    "parsePath": ()=>parsePath
});
function parsePath(path) {
    const hashIndex = path.indexOf('#');
    const queryIndex = path.indexOf('?');
    const hasQuery = queryIndex > -1 && (hashIndex < 0 || queryIndex < hashIndex);
    if (hasQuery || hashIndex > -1) {
        return {
            pathname: path.substring(0, hasQuery ? queryIndex : hashIndex),
            query: hasQuery ? path.substring(queryIndex, hashIndex > -1 ? hashIndex : undefined) : '',
            hash: hashIndex > -1 ? path.slice(hashIndex) : ''
        };
    }
    return {
        pathname: path,
        query: '',
        hash: ''
    };
} //# sourceMappingURL=parse-path.js.map
}),
"[project]/node_modules/next/dist/esm/shared/lib/router/utils/add-path-prefix.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "addPathPrefix": ()=>addPathPrefix
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$parse$2d$path$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/router/utils/parse-path.js [ssr] (ecmascript)");
;
function addPathPrefix(path, prefix) {
    if (!path.startsWith('/') || !prefix) {
        return path;
    }
    const { pathname, query, hash } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$parse$2d$path$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["parsePath"])(path);
    return "" + prefix + pathname + query + hash;
} //# sourceMappingURL=add-path-prefix.js.map
}),
"[project]/node_modules/next/dist/esm/shared/lib/router/utils/add-path-suffix.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "addPathSuffix": ()=>addPathSuffix
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$parse$2d$path$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/router/utils/parse-path.js [ssr] (ecmascript)");
;
function addPathSuffix(path, suffix) {
    if (!path.startsWith('/') || !suffix) {
        return path;
    }
    const { pathname, query, hash } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$parse$2d$path$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["parsePath"])(path);
    return "" + pathname + suffix + query + hash;
} //# sourceMappingURL=add-path-suffix.js.map
}),
"[project]/node_modules/next/dist/esm/shared/lib/router/utils/path-has-prefix.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "pathHasPrefix": ()=>pathHasPrefix
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$parse$2d$path$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/router/utils/parse-path.js [ssr] (ecmascript)");
;
function pathHasPrefix(path, prefix) {
    if (typeof path !== 'string') {
        return false;
    }
    const { pathname } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$parse$2d$path$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["parsePath"])(path);
    return pathname === prefix || pathname.startsWith(prefix + '/');
} //# sourceMappingURL=path-has-prefix.js.map
}),
"[project]/node_modules/next/dist/esm/shared/lib/router/utils/add-locale.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "addLocale": ()=>addLocale
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$add$2d$path$2d$prefix$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/router/utils/add-path-prefix.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$path$2d$has$2d$prefix$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/router/utils/path-has-prefix.js [ssr] (ecmascript)");
;
;
function addLocale(path, locale, defaultLocale, ignorePrefix) {
    // If no locale was given or the locale is the default locale, we don't need
    // to prefix the path.
    if (!locale || locale === defaultLocale) return path;
    const lower = path.toLowerCase();
    // If the path is an API path or the path already has the locale prefix, we
    // don't need to prefix the path.
    if (!ignorePrefix) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$path$2d$has$2d$prefix$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["pathHasPrefix"])(lower, '/api')) return path;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$path$2d$has$2d$prefix$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["pathHasPrefix"])(lower, "/" + locale.toLowerCase())) return path;
    }
    // Add the locale prefix to the path.
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$add$2d$path$2d$prefix$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["addPathPrefix"])(path, "/" + locale);
} //# sourceMappingURL=add-locale.js.map
}),
"[project]/node_modules/next/dist/esm/shared/lib/router/utils/format-next-pathname-info.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "formatNextPathnameInfo": ()=>formatNextPathnameInfo
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$remove$2d$trailing$2d$slash$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/router/utils/remove-trailing-slash.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$add$2d$path$2d$prefix$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/router/utils/add-path-prefix.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$add$2d$path$2d$suffix$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/router/utils/add-path-suffix.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$add$2d$locale$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/router/utils/add-locale.js [ssr] (ecmascript)");
;
;
;
;
function formatNextPathnameInfo(info) {
    let pathname = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$add$2d$locale$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["addLocale"])(info.pathname, info.locale, info.buildId ? undefined : info.defaultLocale, info.ignorePrefix);
    if (info.buildId || !info.trailingSlash) {
        pathname = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$remove$2d$trailing$2d$slash$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["removeTrailingSlash"])(pathname);
    }
    if (info.buildId) {
        pathname = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$add$2d$path$2d$suffix$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["addPathSuffix"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$add$2d$path$2d$prefix$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["addPathPrefix"])(pathname, "/_next/data/" + info.buildId), info.pathname === '/' ? 'index.json' : '.json');
    }
    pathname = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$add$2d$path$2d$prefix$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["addPathPrefix"])(pathname, info.basePath);
    return !info.buildId && info.trailingSlash ? !pathname.endsWith('/') ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$add$2d$path$2d$suffix$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["addPathSuffix"])(pathname, '/') : pathname : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$remove$2d$trailing$2d$slash$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["removeTrailingSlash"])(pathname);
} //# sourceMappingURL=format-next-pathname-info.js.map
}),
"[project]/node_modules/next/dist/esm/shared/lib/get-hostname.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * Takes an object with a hostname property (like a parsed URL) and some
 * headers that may contain Host and returns the preferred hostname.
 * @param parsed An object containing a hostname property.
 * @param headers A dictionary with headers containing a `host`.
 */ __turbopack_context__.s({
    "getHostname": ()=>getHostname
});
function getHostname(parsed, headers) {
    // Get the hostname from the headers if it exists, otherwise use the parsed
    // hostname.
    let hostname;
    if ((headers == null ? void 0 : headers.host) && !Array.isArray(headers.host)) {
        hostname = headers.host.toString().split(':', 1)[0];
    } else if (parsed.hostname) {
        hostname = parsed.hostname;
    } else return;
    return hostname.toLowerCase();
} //# sourceMappingURL=get-hostname.js.map
}),
"[project]/node_modules/next/dist/esm/shared/lib/i18n/normalize-locale-path.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * A cache of lowercased locales for each list of locales. This is stored as a
 * WeakMap so if the locales are garbage collected, the cache entry will be
 * removed as well.
 */ __turbopack_context__.s({
    "normalizeLocalePath": ()=>normalizeLocalePath
});
const cache = new WeakMap();
function normalizeLocalePath(pathname, locales) {
    // If locales is undefined, return the pathname as is.
    if (!locales) return {
        pathname
    };
    // Get the cached lowercased locales or create a new cache entry.
    let lowercasedLocales = cache.get(locales);
    if (!lowercasedLocales) {
        lowercasedLocales = locales.map((locale)=>locale.toLowerCase());
        cache.set(locales, lowercasedLocales);
    }
    let detectedLocale;
    // The first segment will be empty, because it has a leading `/`. If
    // there is no further segment, there is no locale (or it's the default).
    const segments = pathname.split('/', 2);
    // If there's no second segment (ie, the pathname is just `/`), there's no
    // locale.
    if (!segments[1]) return {
        pathname
    };
    // The second segment will contain the locale part if any.
    const segment = segments[1].toLowerCase();
    // See if the segment matches one of the locales. If it doesn't, there is
    // no locale (or it's the default).
    const index = lowercasedLocales.indexOf(segment);
    if (index < 0) return {
        pathname
    };
    // Return the case-sensitive locale.
    detectedLocale = locales[index];
    // Remove the `/${locale}` part of the pathname.
    pathname = pathname.slice(detectedLocale.length + 1) || '/';
    return {
        pathname,
        detectedLocale
    };
} //# sourceMappingURL=normalize-locale-path.js.map
}),
"[project]/node_modules/next/dist/esm/shared/lib/router/utils/remove-path-prefix.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "removePathPrefix": ()=>removePathPrefix
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$path$2d$has$2d$prefix$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/router/utils/path-has-prefix.js [ssr] (ecmascript)");
;
function removePathPrefix(path, prefix) {
    // If the path doesn't start with the prefix we can return it as is. This
    // protects us from situations where the prefix is a substring of the path
    // prefix such as:
    //
    // For prefix: /blog
    //
    //   /blog -> true
    //   /blog/ -> true
    //   /blog/1 -> true
    //   /blogging -> false
    //   /blogging/ -> false
    //   /blogging/1 -> false
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$path$2d$has$2d$prefix$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["pathHasPrefix"])(path, prefix)) {
        return path;
    }
    // Remove the prefix from the path via slicing.
    const withoutPrefix = path.slice(prefix.length);
    // If the path without the prefix starts with a `/` we can return it as is.
    if (withoutPrefix.startsWith('/')) {
        return withoutPrefix;
    }
    // If the path without the prefix doesn't start with a `/` we need to add it
    // back to the path to make sure it's a valid path.
    return "/" + withoutPrefix;
} //# sourceMappingURL=remove-path-prefix.js.map
}),
"[project]/node_modules/next/dist/esm/shared/lib/router/utils/get-next-pathname-info.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "getNextPathnameInfo": ()=>getNextPathnameInfo
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$i18n$2f$normalize$2d$locale$2d$path$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/i18n/normalize-locale-path.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$remove$2d$path$2d$prefix$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/router/utils/remove-path-prefix.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$path$2d$has$2d$prefix$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/router/utils/path-has-prefix.js [ssr] (ecmascript)");
;
;
;
function getNextPathnameInfo(pathname, options) {
    var _options_nextConfig;
    const { basePath, i18n, trailingSlash } = (_options_nextConfig = options.nextConfig) != null ? _options_nextConfig : {};
    const info = {
        pathname,
        trailingSlash: pathname !== '/' ? pathname.endsWith('/') : trailingSlash
    };
    if (basePath && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$path$2d$has$2d$prefix$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["pathHasPrefix"])(info.pathname, basePath)) {
        info.pathname = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$remove$2d$path$2d$prefix$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["removePathPrefix"])(info.pathname, basePath);
        info.basePath = basePath;
    }
    let pathnameNoDataPrefix = info.pathname;
    if (info.pathname.startsWith('/_next/data/') && info.pathname.endsWith('.json')) {
        const paths = info.pathname.replace(/^\/_next\/data\//, '').replace(/\.json$/, '').split('/');
        const buildId = paths[0];
        info.buildId = buildId;
        pathnameNoDataPrefix = paths[1] !== 'index' ? "/" + paths.slice(1).join('/') : '/';
        // update pathname with normalized if enabled although
        // we use normalized to populate locale info still
        if (options.parseData === true) {
            info.pathname = pathnameNoDataPrefix;
        }
    }
    // If provided, use the locale route normalizer to detect the locale instead
    // of the function below.
    if (i18n) {
        let result = options.i18nProvider ? options.i18nProvider.analyze(info.pathname) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$i18n$2f$normalize$2d$locale$2d$path$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["normalizeLocalePath"])(info.pathname, i18n.locales);
        info.locale = result.detectedLocale;
        var _result_pathname;
        info.pathname = (_result_pathname = result.pathname) != null ? _result_pathname : info.pathname;
        if (!result.detectedLocale && info.buildId) {
            result = options.i18nProvider ? options.i18nProvider.analyze(pathnameNoDataPrefix) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$i18n$2f$normalize$2d$locale$2d$path$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["normalizeLocalePath"])(pathnameNoDataPrefix, i18n.locales);
            if (result.detectedLocale) {
                info.locale = result.detectedLocale;
            }
        }
    }
    return info;
} //# sourceMappingURL=get-next-pathname-info.js.map
}),
"[project]/node_modules/next/dist/esm/server/web/next-url.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "NextURL": ()=>NextURL
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$i18n$2f$detect$2d$domain$2d$locale$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/i18n/detect-domain-locale.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$format$2d$next$2d$pathname$2d$info$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/router/utils/format-next-pathname-info.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$get$2d$hostname$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/get-hostname.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$get$2d$next$2d$pathname$2d$info$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/router/utils/get-next-pathname-info.js [ssr] (ecmascript)");
;
;
;
;
const REGEX_LOCALHOST_HOSTNAME = /(?!^https?:\/\/)(127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}|\[::1\]|localhost)/;
function parseURL(url, base) {
    return new URL(String(url).replace(REGEX_LOCALHOST_HOSTNAME, 'localhost'), base && String(base).replace(REGEX_LOCALHOST_HOSTNAME, 'localhost'));
}
const Internal = Symbol('NextURLInternal');
class NextURL {
    constructor(input, baseOrOpts, opts){
        let base;
        let options;
        if (typeof baseOrOpts === 'object' && 'pathname' in baseOrOpts || typeof baseOrOpts === 'string') {
            base = baseOrOpts;
            options = opts || {};
        } else {
            options = opts || baseOrOpts || {};
        }
        this[Internal] = {
            url: parseURL(input, base ?? options.base),
            options: options,
            basePath: ''
        };
        this.analyze();
    }
    analyze() {
        var _this_Internal_options_nextConfig_i18n, _this_Internal_options_nextConfig, _this_Internal_domainLocale, _this_Internal_options_nextConfig_i18n1, _this_Internal_options_nextConfig1;
        const info = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$get$2d$next$2d$pathname$2d$info$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["getNextPathnameInfo"])(this[Internal].url.pathname, {
            nextConfig: this[Internal].options.nextConfig,
            parseData: !("TURBOPACK compile-time value", void 0),
            i18nProvider: this[Internal].options.i18nProvider
        });
        const hostname = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$get$2d$hostname$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["getHostname"])(this[Internal].url, this[Internal].options.headers);
        this[Internal].domainLocale = this[Internal].options.i18nProvider ? this[Internal].options.i18nProvider.detectDomainLocale(hostname) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$i18n$2f$detect$2d$domain$2d$locale$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["detectDomainLocale"])((_this_Internal_options_nextConfig = this[Internal].options.nextConfig) == null ? void 0 : (_this_Internal_options_nextConfig_i18n = _this_Internal_options_nextConfig.i18n) == null ? void 0 : _this_Internal_options_nextConfig_i18n.domains, hostname);
        const defaultLocale = ((_this_Internal_domainLocale = this[Internal].domainLocale) == null ? void 0 : _this_Internal_domainLocale.defaultLocale) || ((_this_Internal_options_nextConfig1 = this[Internal].options.nextConfig) == null ? void 0 : (_this_Internal_options_nextConfig_i18n1 = _this_Internal_options_nextConfig1.i18n) == null ? void 0 : _this_Internal_options_nextConfig_i18n1.defaultLocale);
        this[Internal].url.pathname = info.pathname;
        this[Internal].defaultLocale = defaultLocale;
        this[Internal].basePath = info.basePath ?? '';
        this[Internal].buildId = info.buildId;
        this[Internal].locale = info.locale ?? defaultLocale;
        this[Internal].trailingSlash = info.trailingSlash;
    }
    formatPathname() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$format$2d$next$2d$pathname$2d$info$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["formatNextPathnameInfo"])({
            basePath: this[Internal].basePath,
            buildId: this[Internal].buildId,
            defaultLocale: !this[Internal].options.forceLocale ? this[Internal].defaultLocale : undefined,
            locale: this[Internal].locale,
            pathname: this[Internal].url.pathname,
            trailingSlash: this[Internal].trailingSlash
        });
    }
    formatSearch() {
        return this[Internal].url.search;
    }
    get buildId() {
        return this[Internal].buildId;
    }
    set buildId(buildId) {
        this[Internal].buildId = buildId;
    }
    get locale() {
        return this[Internal].locale ?? '';
    }
    set locale(locale) {
        var _this_Internal_options_nextConfig_i18n, _this_Internal_options_nextConfig;
        if (!this[Internal].locale || !((_this_Internal_options_nextConfig = this[Internal].options.nextConfig) == null ? void 0 : (_this_Internal_options_nextConfig_i18n = _this_Internal_options_nextConfig.i18n) == null ? void 0 : _this_Internal_options_nextConfig_i18n.locales.includes(locale))) {
            throw Object.defineProperty(new TypeError(`The NextURL configuration includes no locale "${locale}"`), "__NEXT_ERROR_CODE", {
                value: "E597",
                enumerable: false,
                configurable: true
            });
        }
        this[Internal].locale = locale;
    }
    get defaultLocale() {
        return this[Internal].defaultLocale;
    }
    get domainLocale() {
        return this[Internal].domainLocale;
    }
    get searchParams() {
        return this[Internal].url.searchParams;
    }
    get host() {
        return this[Internal].url.host;
    }
    set host(value) {
        this[Internal].url.host = value;
    }
    get hostname() {
        return this[Internal].url.hostname;
    }
    set hostname(value) {
        this[Internal].url.hostname = value;
    }
    get port() {
        return this[Internal].url.port;
    }
    set port(value) {
        this[Internal].url.port = value;
    }
    get protocol() {
        return this[Internal].url.protocol;
    }
    set protocol(value) {
        this[Internal].url.protocol = value;
    }
    get href() {
        const pathname = this.formatPathname();
        const search = this.formatSearch();
        return `${this.protocol}//${this.host}${pathname}${search}${this.hash}`;
    }
    set href(url) {
        this[Internal].url = parseURL(url);
        this.analyze();
    }
    get origin() {
        return this[Internal].url.origin;
    }
    get pathname() {
        return this[Internal].url.pathname;
    }
    set pathname(value) {
        this[Internal].url.pathname = value;
    }
    get hash() {
        return this[Internal].url.hash;
    }
    set hash(value) {
        this[Internal].url.hash = value;
    }
    get search() {
        return this[Internal].url.search;
    }
    set search(value) {
        this[Internal].url.search = value;
    }
    get password() {
        return this[Internal].url.password;
    }
    set password(value) {
        this[Internal].url.password = value;
    }
    get username() {
        return this[Internal].url.username;
    }
    set username(value) {
        this[Internal].url.username = value;
    }
    get basePath() {
        return this[Internal].basePath;
    }
    set basePath(value) {
        this[Internal].basePath = value.startsWith('/') ? value : `/${value}`;
    }
    toString() {
        return this.href;
    }
    toJSON() {
        return this.href;
    }
    [Symbol.for('edge-runtime.inspect.custom')]() {
        return {
            href: this.href,
            origin: this.origin,
            protocol: this.protocol,
            username: this.username,
            password: this.password,
            host: this.host,
            hostname: this.hostname,
            port: this.port,
            pathname: this.pathname,
            search: this.search,
            searchParams: this.searchParams,
            hash: this.hash
        };
    }
    clone() {
        return new NextURL(String(this), this[Internal].options);
    }
} //# sourceMappingURL=next-url.js.map
}),
"[project]/node_modules/next/dist/esm/server/web/error.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "PageSignatureError": ()=>PageSignatureError,
    "RemovedPageError": ()=>RemovedPageError,
    "RemovedUAError": ()=>RemovedUAError
});
class PageSignatureError extends Error {
    constructor({ page }){
        super(`The middleware "${page}" accepts an async API directly with the form:
  
  export function middleware(request, event) {
    return NextResponse.redirect('/new-location')
  }
  
  Read more: https://nextjs.org/docs/messages/middleware-new-signature
  `);
    }
}
class RemovedPageError extends Error {
    constructor(){
        super(`The request.page has been deprecated in favour of \`URLPattern\`.
  Read more: https://nextjs.org/docs/messages/middleware-request-page
  `);
    }
}
class RemovedUAError extends Error {
    constructor(){
        super(`The request.ua has been removed in favour of \`userAgent\` function.
  Read more: https://nextjs.org/docs/messages/middleware-parse-user-agent
  `);
    }
} //# sourceMappingURL=error.js.map
}),
"[project]/node_modules/next/dist/compiled/@edge-runtime/cookies/index.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
// src/index.ts
var src_exports = {};
__export(src_exports, {
    RequestCookies: ()=>RequestCookies,
    ResponseCookies: ()=>ResponseCookies,
    parseCookie: ()=>parseCookie,
    parseSetCookie: ()=>parseSetCookie,
    stringifyCookie: ()=>stringifyCookie
});
module.exports = __toCommonJS(src_exports);
// src/serialize.ts
function stringifyCookie(c) {
    var _a;
    const attrs = [
        "path" in c && c.path && `Path=${c.path}`,
        "expires" in c && (c.expires || c.expires === 0) && `Expires=${(typeof c.expires === "number" ? new Date(c.expires) : c.expires).toUTCString()}`,
        "maxAge" in c && typeof c.maxAge === "number" && `Max-Age=${c.maxAge}`,
        "domain" in c && c.domain && `Domain=${c.domain}`,
        "secure" in c && c.secure && "Secure",
        "httpOnly" in c && c.httpOnly && "HttpOnly",
        "sameSite" in c && c.sameSite && `SameSite=${c.sameSite}`,
        "partitioned" in c && c.partitioned && "Partitioned",
        "priority" in c && c.priority && `Priority=${c.priority}`
    ].filter(Boolean);
    const stringified = `${c.name}=${encodeURIComponent((_a = c.value) != null ? _a : "")}`;
    return attrs.length === 0 ? stringified : `${stringified}; ${attrs.join("; ")}`;
}
function parseCookie(cookie) {
    const map = /* @__PURE__ */ new Map();
    for (const pair of cookie.split(/; */)){
        if (!pair) continue;
        const splitAt = pair.indexOf("=");
        if (splitAt === -1) {
            map.set(pair, "true");
            continue;
        }
        const [key, value] = [
            pair.slice(0, splitAt),
            pair.slice(splitAt + 1)
        ];
        try {
            map.set(key, decodeURIComponent(value != null ? value : "true"));
        } catch  {}
    }
    return map;
}
function parseSetCookie(setCookie) {
    if (!setCookie) {
        return void 0;
    }
    const [[name, value], ...attributes] = parseCookie(setCookie);
    const { domain, expires, httponly, maxage, path, samesite, secure, partitioned, priority } = Object.fromEntries(attributes.map(([key, value2])=>[
            key.toLowerCase().replace(/-/g, ""),
            value2
        ]));
    const cookie = {
        name,
        value: decodeURIComponent(value),
        domain,
        ...expires && {
            expires: new Date(expires)
        },
        ...httponly && {
            httpOnly: true
        },
        ...typeof maxage === "string" && {
            maxAge: Number(maxage)
        },
        path,
        ...samesite && {
            sameSite: parseSameSite(samesite)
        },
        ...secure && {
            secure: true
        },
        ...priority && {
            priority: parsePriority(priority)
        },
        ...partitioned && {
            partitioned: true
        }
    };
    return compact(cookie);
}
function compact(t) {
    const newT = {};
    for(const key in t){
        if (t[key]) {
            newT[key] = t[key];
        }
    }
    return newT;
}
var SAME_SITE = [
    "strict",
    "lax",
    "none"
];
function parseSameSite(string) {
    string = string.toLowerCase();
    return SAME_SITE.includes(string) ? string : void 0;
}
var PRIORITY = [
    "low",
    "medium",
    "high"
];
function parsePriority(string) {
    string = string.toLowerCase();
    return PRIORITY.includes(string) ? string : void 0;
}
function splitCookiesString(cookiesString) {
    if (!cookiesString) return [];
    var cookiesStrings = [];
    var pos = 0;
    var start;
    var ch;
    var lastComma;
    var nextStart;
    var cookiesSeparatorFound;
    function skipWhitespace() {
        while(pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))){
            pos += 1;
        }
        return pos < cookiesString.length;
    }
    function notSpecialChar() {
        ch = cookiesString.charAt(pos);
        return ch !== "=" && ch !== ";" && ch !== ",";
    }
    while(pos < cookiesString.length){
        start = pos;
        cookiesSeparatorFound = false;
        while(skipWhitespace()){
            ch = cookiesString.charAt(pos);
            if (ch === ",") {
                lastComma = pos;
                pos += 1;
                skipWhitespace();
                nextStart = pos;
                while(pos < cookiesString.length && notSpecialChar()){
                    pos += 1;
                }
                if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
                    cookiesSeparatorFound = true;
                    pos = nextStart;
                    cookiesStrings.push(cookiesString.substring(start, lastComma));
                    start = pos;
                } else {
                    pos = lastComma + 1;
                }
            } else {
                pos += 1;
            }
        }
        if (!cookiesSeparatorFound || pos >= cookiesString.length) {
            cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
        }
    }
    return cookiesStrings;
}
// src/request-cookies.ts
var RequestCookies = class {
    constructor(requestHeaders){
        /** @internal */ this._parsed = /* @__PURE__ */ new Map();
        this._headers = requestHeaders;
        const header = requestHeaders.get("cookie");
        if (header) {
            const parsed = parseCookie(header);
            for (const [name, value] of parsed){
                this._parsed.set(name, {
                    name,
                    value
                });
            }
        }
    }
    [Symbol.iterator]() {
        return this._parsed[Symbol.iterator]();
    }
    /**
   * The amount of cookies received from the client
   */ get size() {
        return this._parsed.size;
    }
    get(...args) {
        const name = typeof args[0] === "string" ? args[0] : args[0].name;
        return this._parsed.get(name);
    }
    getAll(...args) {
        var _a;
        const all = Array.from(this._parsed);
        if (!args.length) {
            return all.map(([_, value])=>value);
        }
        const name = typeof args[0] === "string" ? args[0] : (_a = args[0]) == null ? void 0 : _a.name;
        return all.filter(([n])=>n === name).map(([_, value])=>value);
    }
    has(name) {
        return this._parsed.has(name);
    }
    set(...args) {
        const [name, value] = args.length === 1 ? [
            args[0].name,
            args[0].value
        ] : args;
        const map = this._parsed;
        map.set(name, {
            name,
            value
        });
        this._headers.set("cookie", Array.from(map).map(([_, value2])=>stringifyCookie(value2)).join("; "));
        return this;
    }
    /**
   * Delete the cookies matching the passed name or names in the request.
   */ delete(names) {
        const map = this._parsed;
        const result = !Array.isArray(names) ? map.delete(names) : names.map((name)=>map.delete(name));
        this._headers.set("cookie", Array.from(map).map(([_, value])=>stringifyCookie(value)).join("; "));
        return result;
    }
    /**
   * Delete all the cookies in the cookies in the request.
   */ clear() {
        this.delete(Array.from(this._parsed.keys()));
        return this;
    }
    /**
   * Format the cookies in the request as a string for logging
   */ [Symbol.for("edge-runtime.inspect.custom")]() {
        return `RequestCookies ${JSON.stringify(Object.fromEntries(this._parsed))}`;
    }
    toString() {
        return [
            ...this._parsed.values()
        ].map((v)=>`${v.name}=${encodeURIComponent(v.value)}`).join("; ");
    }
};
// src/response-cookies.ts
var ResponseCookies = class {
    constructor(responseHeaders){
        /** @internal */ this._parsed = /* @__PURE__ */ new Map();
        var _a, _b, _c;
        this._headers = responseHeaders;
        const setCookie = (_c = (_b = (_a = responseHeaders.getSetCookie) == null ? void 0 : _a.call(responseHeaders)) != null ? _b : responseHeaders.get("set-cookie")) != null ? _c : [];
        const cookieStrings = Array.isArray(setCookie) ? setCookie : splitCookiesString(setCookie);
        for (const cookieString of cookieStrings){
            const parsed = parseSetCookie(cookieString);
            if (parsed) this._parsed.set(parsed.name, parsed);
        }
    }
    /**
   * {@link https://wicg.github.io/cookie-store/#CookieStore-get CookieStore#get} without the Promise.
   */ get(...args) {
        const key = typeof args[0] === "string" ? args[0] : args[0].name;
        return this._parsed.get(key);
    }
    /**
   * {@link https://wicg.github.io/cookie-store/#CookieStore-getAll CookieStore#getAll} without the Promise.
   */ getAll(...args) {
        var _a;
        const all = Array.from(this._parsed.values());
        if (!args.length) {
            return all;
        }
        const key = typeof args[0] === "string" ? args[0] : (_a = args[0]) == null ? void 0 : _a.name;
        return all.filter((c)=>c.name === key);
    }
    has(name) {
        return this._parsed.has(name);
    }
    /**
   * {@link https://wicg.github.io/cookie-store/#CookieStore-set CookieStore#set} without the Promise.
   */ set(...args) {
        const [name, value, cookie] = args.length === 1 ? [
            args[0].name,
            args[0].value,
            args[0]
        ] : args;
        const map = this._parsed;
        map.set(name, normalizeCookie({
            name,
            value,
            ...cookie
        }));
        replace(map, this._headers);
        return this;
    }
    /**
   * {@link https://wicg.github.io/cookie-store/#CookieStore-delete CookieStore#delete} without the Promise.
   */ delete(...args) {
        const [name, options] = typeof args[0] === "string" ? [
            args[0]
        ] : [
            args[0].name,
            args[0]
        ];
        return this.set({
            ...options,
            name,
            value: "",
            expires: /* @__PURE__ */ new Date(0)
        });
    }
    [Symbol.for("edge-runtime.inspect.custom")]() {
        return `ResponseCookies ${JSON.stringify(Object.fromEntries(this._parsed))}`;
    }
    toString() {
        return [
            ...this._parsed.values()
        ].map(stringifyCookie).join("; ");
    }
};
function replace(bag, headers) {
    headers.delete("set-cookie");
    for (const [, value] of bag){
        const serialized = stringifyCookie(value);
        headers.append("set-cookie", serialized);
    }
}
function normalizeCookie(cookie = {
    name: "",
    value: ""
}) {
    if (typeof cookie.expires === "number") {
        cookie.expires = new Date(cookie.expires);
    }
    if (cookie.maxAge) {
        cookie.expires = new Date(Date.now() + cookie.maxAge * 1e3);
    }
    if (cookie.path === null || cookie.path === void 0) {
        cookie.path = "/";
    }
    return cookie;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    RequestCookies,
    ResponseCookies,
    parseCookie,
    parseSetCookie,
    stringifyCookie
});
}}),
"[project]/node_modules/next/dist/esm/server/web/spec-extension/cookies.js [ssr] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f40$edge$2d$runtime$2f$cookies$2f$index$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/@edge-runtime/cookies/index.js [ssr] (ecmascript)"); //# sourceMappingURL=cookies.js.map
;
}),
"[project]/node_modules/next/dist/esm/server/web/spec-extension/cookies.js [ssr] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f40$edge$2d$runtime$2f$cookies$2f$index$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/@edge-runtime/cookies/index.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$spec$2d$extension$2f$cookies$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/web/spec-extension/cookies.js [ssr] (ecmascript) <locals>");
}),
"[project]/node_modules/next/dist/esm/server/web/spec-extension/request.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "INTERNALS": ()=>INTERNALS,
    "NextRequest": ()=>NextRequest
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$next$2d$url$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/web/next-url.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$utils$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/web/utils.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$error$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/web/error.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$spec$2d$extension$2f$cookies$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/web/spec-extension/cookies.js [ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f40$edge$2d$runtime$2f$cookies$2f$index$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/@edge-runtime/cookies/index.js [ssr] (ecmascript)");
;
;
;
;
const INTERNALS = Symbol('internal request');
class NextRequest extends Request {
    constructor(input, init = {}){
        const url = typeof input !== 'string' && 'url' in input ? input.url : String(input);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$utils$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["validateURL"])(url);
        // node Request instance requires duplex option when a body
        // is present or it errors, we don't handle this for
        // Request being passed in since it would have already
        // errored if this wasn't configured
        if ("TURBOPACK compile-time truthy", 1) {
            if (init.body && init.duplex !== 'half') {
                init.duplex = 'half';
            }
        }
        if (input instanceof Request) super(input, init);
        else super(url, init);
        const nextUrl = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$next$2d$url$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["NextURL"](url, {
            headers: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$utils$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["toNodeOutgoingHttpHeaders"])(this.headers),
            nextConfig: init.nextConfig
        });
        this[INTERNALS] = {
            cookies: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f40$edge$2d$runtime$2f$cookies$2f$index$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["RequestCookies"](this.headers),
            nextUrl,
            url: ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : nextUrl.toString()
        };
    }
    [Symbol.for('edge-runtime.inspect.custom')]() {
        return {
            cookies: this.cookies,
            nextUrl: this.nextUrl,
            url: this.url,
            // rest of props come from Request
            bodyUsed: this.bodyUsed,
            cache: this.cache,
            credentials: this.credentials,
            destination: this.destination,
            headers: Object.fromEntries(this.headers),
            integrity: this.integrity,
            keepalive: this.keepalive,
            method: this.method,
            mode: this.mode,
            redirect: this.redirect,
            referrer: this.referrer,
            referrerPolicy: this.referrerPolicy,
            signal: this.signal
        };
    }
    get cookies() {
        return this[INTERNALS].cookies;
    }
    get nextUrl() {
        return this[INTERNALS].nextUrl;
    }
    /**
   * @deprecated
   * `page` has been deprecated in favour of `URLPattern`.
   * Read more: https://nextjs.org/docs/messages/middleware-request-page
   */ get page() {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$error$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["RemovedPageError"]();
    }
    /**
   * @deprecated
   * `ua` has been removed in favour of \`userAgent\` function.
   * Read more: https://nextjs.org/docs/messages/middleware-parse-user-agent
   */ get ua() {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$error$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["RemovedUAError"]();
    }
    get url() {
        return this[INTERNALS].url;
    }
} //# sourceMappingURL=request.js.map
}),
"[project]/node_modules/next/dist/esm/server/base-http/helpers.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * This file provides some helpers that should be used in conjunction with
 * explicit environment checks. When combined with the environment checks, it
 * will ensure that the correct typings are used as well as enable code
 * elimination.
 */ /**
 * Type guard to determine if a request is a WebNextRequest. This does not
 * actually check the type of the request, but rather the runtime environment.
 * It's expected that when the runtime environment is the edge runtime, that any
 * base request is a WebNextRequest.
 */ __turbopack_context__.s({
    "isNodeNextRequest": ()=>isNodeNextRequest,
    "isNodeNextResponse": ()=>isNodeNextResponse,
    "isWebNextRequest": ()=>isWebNextRequest,
    "isWebNextResponse": ()=>isWebNextResponse
});
const isWebNextRequest = (req)=>("TURBOPACK compile-time value", "nodejs") === 'edge';
const isWebNextResponse = (res)=>("TURBOPACK compile-time value", "nodejs") === 'edge';
const isNodeNextRequest = (req)=>("TURBOPACK compile-time value", "nodejs") !== 'edge';
const isNodeNextResponse = (res)=>("TURBOPACK compile-time value", "nodejs") !== 'edge'; //# sourceMappingURL=helpers.js.map
}),
"[project]/node_modules/next/dist/esm/server/web/spec-extension/adapters/next-request.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "NextRequestAdapter": ()=>NextRequestAdapter,
    "ResponseAborted": ()=>ResponseAborted,
    "ResponseAbortedName": ()=>ResponseAbortedName,
    "createAbortController": ()=>createAbortController,
    "signalFromNodeResponse": ()=>signalFromNodeResponse
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2d$meta$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/request-meta.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$utils$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/web/utils.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$spec$2d$extension$2f$request$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/web/spec-extension/request.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$base$2d$http$2f$helpers$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/base-http/helpers.js [ssr] (ecmascript)");
;
;
;
;
const ResponseAbortedName = 'ResponseAborted';
class ResponseAborted extends Error {
    constructor(...args){
        super(...args), this.name = ResponseAbortedName;
    }
}
function createAbortController(response) {
    const controller = new AbortController();
    // If `finish` fires first, then `res.end()` has been called and the close is
    // just us finishing the stream on our side. If `close` fires first, then we
    // know the client disconnected before we finished.
    response.once('close', ()=>{
        if (response.writableFinished) return;
        controller.abort(new ResponseAborted());
    });
    return controller;
}
function signalFromNodeResponse(response) {
    const { errored, destroyed } = response;
    if (errored || destroyed) {
        return AbortSignal.abort(errored ?? new ResponseAborted());
    }
    const { signal } = createAbortController(response);
    return signal;
}
class NextRequestAdapter {
    static fromBaseNextRequest(request, signal) {
        if (// environment variable check provides dead code elimination.
        ("TURBOPACK compile-time value", "nodejs") === 'edge' && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$base$2d$http$2f$helpers$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["isWebNextRequest"])(request)) //TURBOPACK unreachable
        ;
        else if (// environment variable check provides dead code elimination.
        ("TURBOPACK compile-time value", "nodejs") !== 'edge' && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$base$2d$http$2f$helpers$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["isNodeNextRequest"])(request)) {
            return NextRequestAdapter.fromNodeNextRequest(request, signal);
        } else {
            throw Object.defineProperty(new Error('Invariant: Unsupported NextRequest type'), "__NEXT_ERROR_CODE", {
                value: "E345",
                enumerable: false,
                configurable: true
            });
        }
    }
    static fromNodeNextRequest(request, signal) {
        // HEAD and GET requests can not have a body.
        let body = null;
        if (request.method !== 'GET' && request.method !== 'HEAD' && request.body) {
            // @ts-expect-error - this is handled by undici, when streams/web land use it instead
            body = request.body;
        }
        let url;
        if (request.url.startsWith('http')) {
            url = new URL(request.url);
        } else {
            // Grab the full URL from the request metadata.
            const base = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2d$meta$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["getRequestMeta"])(request, 'initURL');
            if (!base || !base.startsWith('http')) {
                // Because the URL construction relies on the fact that the URL provided
                // is absolute, we need to provide a base URL. We can't use the request
                // URL because it's relative, so we use a dummy URL instead.
                url = new URL(request.url, 'http://n');
            } else {
                url = new URL(request.url, base);
            }
        }
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$spec$2d$extension$2f$request$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["NextRequest"](url, {
            method: request.method,
            headers: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$utils$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["fromNodeOutgoingHttpHeaders"])(request.headers),
            duplex: 'half',
            signal,
            // geo
            // ip
            // nextConfig
            // body can not be passed if request was aborted
            // or we get a Request body was disturbed error
            ...signal.aborted ? {} : {
                body
            }
        });
    }
    static fromWebNextRequest(request) {
        // HEAD and GET requests can not have a body.
        let body = null;
        if (request.method !== 'GET' && request.method !== 'HEAD') {
            body = request.body;
        }
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$spec$2d$extension$2f$request$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["NextRequest"](request.url, {
            method: request.method,
            headers: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$utils$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["fromNodeOutgoingHttpHeaders"])(request.headers),
            duplex: 'half',
            signal: request.request.signal,
            // geo
            // ip
            // nextConfig
            // body can not be passed if request was aborted
            // or we get a Request body was disturbed error
            ...request.request.signal.aborted ? {} : {
                body
            }
        });
    }
} //# sourceMappingURL=next-request.js.map
}),
"[project]/node_modules/next/dist/esm/server/client-component-renderer-logger.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// Combined load times for loading client components
__turbopack_context__.s({
    "getClientComponentLoaderMetrics": ()=>getClientComponentLoaderMetrics,
    "wrapClientComponentLoader": ()=>wrapClientComponentLoader
});
let clientComponentLoadStart = 0;
let clientComponentLoadTimes = 0;
let clientComponentLoadCount = 0;
function wrapClientComponentLoader(ComponentMod) {
    if (!('performance' in globalThis)) {
        return ComponentMod.__next_app__;
    }
    return {
        require: (...args)=>{
            const startTime = performance.now();
            if (clientComponentLoadStart === 0) {
                clientComponentLoadStart = startTime;
            }
            try {
                clientComponentLoadCount += 1;
                return ComponentMod.__next_app__.require(...args);
            } finally{
                clientComponentLoadTimes += performance.now() - startTime;
            }
        },
        loadChunk: (...args)=>{
            const startTime = performance.now();
            const result = ComponentMod.__next_app__.loadChunk(...args);
            // Avoid wrapping `loadChunk`'s result in an extra promise in case something like React depends on its identity.
            // We only need to know when it's settled.
            result.finally(()=>{
                clientComponentLoadTimes += performance.now() - startTime;
            });
            return result;
        }
    };
}
function getClientComponentLoaderMetrics(options = {}) {
    const metrics = clientComponentLoadStart === 0 ? undefined : {
        clientComponentLoadStart,
        clientComponentLoadTimes,
        clientComponentLoadCount
    };
    if (options.reset) {
        clientComponentLoadStart = 0;
        clientComponentLoadTimes = 0;
        clientComponentLoadCount = 0;
    }
    return metrics;
} //# sourceMappingURL=client-component-renderer-logger.js.map
}),
"[project]/node_modules/next/dist/esm/server/pipe-readable.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "isAbortError": ()=>isAbortError,
    "pipeToNodeResponse": ()=>pipeToNodeResponse
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$spec$2d$extension$2f$adapters$2f$next$2d$request$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/web/spec-extension/adapters/next-request.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$detached$2d$promise$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/detached-promise.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$tracer$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/lib/trace/tracer.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$constants$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/lib/trace/constants.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$client$2d$component$2d$renderer$2d$logger$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/client-component-renderer-logger.js [ssr] (ecmascript)");
;
;
;
;
;
function isAbortError(e) {
    return (e == null ? void 0 : e.name) === 'AbortError' || (e == null ? void 0 : e.name) === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$spec$2d$extension$2f$adapters$2f$next$2d$request$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["ResponseAbortedName"];
}
function createWriterFromResponse(res, waitUntilForEnd) {
    let started = false;
    // Create a promise that will resolve once the response has drained. See
    // https://nodejs.org/api/stream.html#stream_event_drain
    let drained = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$detached$2d$promise$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["DetachedPromise"]();
    function onDrain() {
        drained.resolve();
    }
    res.on('drain', onDrain);
    // If the finish event fires, it means we shouldn't block and wait for the
    // drain event.
    res.once('close', ()=>{
        res.off('drain', onDrain);
        drained.resolve();
    });
    // Create a promise that will resolve once the response has finished. See
    // https://nodejs.org/api/http.html#event-finish_1
    const finished = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$detached$2d$promise$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["DetachedPromise"]();
    res.once('finish', ()=>{
        finished.resolve();
    });
    // Create a writable stream that will write to the response.
    return new WritableStream({
        write: async (chunk)=>{
            // You'd think we'd want to use `start` instead of placing this in `write`
            // but this ensures that we don't actually flush the headers until we've
            // started writing chunks.
            if (!started) {
                started = true;
                if ('performance' in globalThis && process.env.NEXT_OTEL_PERFORMANCE_PREFIX) {
                    const metrics = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$client$2d$component$2d$renderer$2d$logger$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["getClientComponentLoaderMetrics"])();
                    if (metrics) {
                        performance.measure(`${process.env.NEXT_OTEL_PERFORMANCE_PREFIX}:next-client-component-loading`, {
                            start: metrics.clientComponentLoadStart,
                            end: metrics.clientComponentLoadStart + metrics.clientComponentLoadTimes
                        });
                    }
                }
                res.flushHeaders();
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$tracer$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["getTracer"])().trace(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$constants$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["NextNodeServerSpan"].startResponse, {
                    spanName: 'start response'
                }, ()=>undefined);
            }
            try {
                const ok = res.write(chunk);
                // Added by the `compression` middleware, this is a function that will
                // flush the partially-compressed response to the client.
                if ('flush' in res && typeof res.flush === 'function') {
                    res.flush();
                }
                // If the write returns false, it means there's some backpressure, so
                // wait until it's streamed before continuing.
                if (!ok) {
                    await drained.promise;
                    // Reset the drained promise so that we can wait for the next drain event.
                    drained = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$detached$2d$promise$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["DetachedPromise"]();
                }
            } catch (err) {
                res.end();
                throw Object.defineProperty(new Error('failed to write chunk to response', {
                    cause: err
                }), "__NEXT_ERROR_CODE", {
                    value: "E321",
                    enumerable: false,
                    configurable: true
                });
            }
        },
        abort: (err)=>{
            if (res.writableFinished) return;
            res.destroy(err);
        },
        close: async ()=>{
            // if a waitUntil promise was passed, wait for it to resolve before
            // ending the response.
            if (waitUntilForEnd) {
                await waitUntilForEnd;
            }
            if (res.writableFinished) return;
            res.end();
            return finished.promise;
        }
    });
}
async function pipeToNodeResponse(readable, res, waitUntilForEnd) {
    try {
        // If the response has already errored, then just return now.
        const { errored, destroyed } = res;
        if (errored || destroyed) return;
        // Create a new AbortController so that we can abort the readable if the
        // client disconnects.
        const controller = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$spec$2d$extension$2f$adapters$2f$next$2d$request$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["createAbortController"])(res);
        const writer = createWriterFromResponse(res, waitUntilForEnd);
        await readable.pipeTo(writer, {
            signal: controller.signal
        });
    } catch (err) {
        // If this isn't related to an abort error, re-throw it.
        if (isAbortError(err)) return;
        throw Object.defineProperty(new Error('failed to pipe response', {
            cause: err
        }), "__NEXT_ERROR_CODE", {
            value: "E180",
            enumerable: false,
            configurable: true
        });
    }
} //# sourceMappingURL=pipe-readable.js.map
}),
"[project]/node_modules/next/dist/esm/server/render-result.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>RenderResult
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$node$2d$web$2d$streams$2d$helper$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/stream-utils/node-web-streams-helper.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$pipe$2d$readable$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/pipe-readable.js [ssr] (ecmascript)");
;
;
class RenderResult {
    /**
   * Creates a new RenderResult instance from a static response.
   *
   * @param value the static response value
   * @returns a new RenderResult instance
   */ static fromStatic(value) {
        return new RenderResult(value, {
            metadata: {}
        });
    }
    constructor(response, { contentType, waitUntil, metadata }){
        this.response = response;
        this.contentType = contentType;
        this.metadata = metadata;
        this.waitUntil = waitUntil;
    }
    assignMetadata(metadata) {
        Object.assign(this.metadata, metadata);
    }
    /**
   * Returns true if the response is null. It can be null if the response was
   * not found or was already sent.
   */ get isNull() {
        return this.response === null;
    }
    /**
   * Returns false if the response is a string. It can be a string if the page
   * was prerendered. If it's not, then it was generated dynamically.
   */ get isDynamic() {
        return typeof this.response !== 'string';
    }
    toUnchunkedBuffer(stream = false) {
        if (this.response === null) {
            throw Object.defineProperty(new Error('Invariant: null responses cannot be unchunked'), "__NEXT_ERROR_CODE", {
                value: "E274",
                enumerable: false,
                configurable: true
            });
        }
        if (typeof this.response !== 'string') {
            if (!stream) {
                throw Object.defineProperty(new Error('Invariant: dynamic responses cannot be unchunked. This is a bug in Next.js'), "__NEXT_ERROR_CODE", {
                    value: "E81",
                    enumerable: false,
                    configurable: true
                });
            }
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$node$2d$web$2d$streams$2d$helper$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["streamToBuffer"])(this.readable);
        }
        return Buffer.from(this.response);
    }
    toUnchunkedString(stream = false) {
        if (this.response === null) {
            throw Object.defineProperty(new Error('Invariant: null responses cannot be unchunked'), "__NEXT_ERROR_CODE", {
                value: "E274",
                enumerable: false,
                configurable: true
            });
        }
        if (typeof this.response !== 'string') {
            if (!stream) {
                throw Object.defineProperty(new Error('Invariant: dynamic responses cannot be unchunked. This is a bug in Next.js'), "__NEXT_ERROR_CODE", {
                    value: "E81",
                    enumerable: false,
                    configurable: true
                });
            }
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$node$2d$web$2d$streams$2d$helper$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["streamToString"])(this.readable);
        }
        return this.response;
    }
    /**
   * Returns the response if it is a stream, or throws an error if it is a
   * string.
   */ get readable() {
        if (this.response === null) {
            throw Object.defineProperty(new Error('Invariant: null responses cannot be streamed'), "__NEXT_ERROR_CODE", {
                value: "E14",
                enumerable: false,
                configurable: true
            });
        }
        if (typeof this.response === 'string') {
            throw Object.defineProperty(new Error('Invariant: static responses cannot be streamed'), "__NEXT_ERROR_CODE", {
                value: "E151",
                enumerable: false,
                configurable: true
            });
        }
        if (Buffer.isBuffer(this.response)) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$node$2d$web$2d$streams$2d$helper$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["streamFromBuffer"])(this.response);
        }
        // If the response is an array of streams, then chain them together.
        if (Array.isArray(this.response)) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$node$2d$web$2d$streams$2d$helper$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["chainStreams"])(...this.response);
        }
        return this.response;
    }
    /**
   * Chains a new stream to the response. This will convert the response to an
   * array of streams if it is not already one and will add the new stream to
   * the end. When this response is piped, all of the streams will be piped
   * one after the other.
   *
   * @param readable The new stream to chain
   */ chain(readable) {
        if (this.response === null) {
            throw Object.defineProperty(new Error('Invariant: response is null. This is a bug in Next.js'), "__NEXT_ERROR_CODE", {
                value: "E258",
                enumerable: false,
                configurable: true
            });
        }
        // If the response is not an array of streams already, make it one.
        let responses;
        if (typeof this.response === 'string') {
            responses = [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$node$2d$web$2d$streams$2d$helper$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["streamFromString"])(this.response)
            ];
        } else if (Array.isArray(this.response)) {
            responses = this.response;
        } else if (Buffer.isBuffer(this.response)) {
            responses = [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$node$2d$web$2d$streams$2d$helper$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["streamFromBuffer"])(this.response)
            ];
        } else {
            responses = [
                this.response
            ];
        }
        // Add the new stream to the array.
        responses.push(readable);
        // Update the response.
        this.response = responses;
    }
    /**
   * Pipes the response to a writable stream. This will close/cancel the
   * writable stream if an error is encountered. If this doesn't throw, then
   * the writable stream will be closed or aborted.
   *
   * @param writable Writable stream to pipe the response to
   */ async pipeTo(writable) {
        try {
            await this.readable.pipeTo(writable, {
                // We want to close the writable stream ourselves so that we can wait
                // for the waitUntil promise to resolve before closing it. If an error
                // is encountered, we'll abort the writable stream if we swallowed the
                // error.
                preventClose: true
            });
            // If there is a waitUntil promise, wait for it to resolve before
            // closing the writable stream.
            if (this.waitUntil) await this.waitUntil;
            // Close the writable stream.
            await writable.close();
        } catch (err) {
            // If this is an abort error, we should abort the writable stream (as we
            // took ownership of it when we started piping). We don't need to re-throw
            // because we handled the error.
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$pipe$2d$readable$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["isAbortError"])(err)) {
                // Abort the writable stream if an error is encountered.
                await writable.abort(err);
                return;
            }
            // We're not aborting the writer here as when this method throws it's not
            // clear as to how so the caller should assume it's their responsibility
            // to clean up the writer.
            throw err;
        }
    }
    /**
   * Pipes the response to a node response. This will close/cancel the node
   * response if an error is encountered.
   *
   * @param res
   */ async pipeToNodeResponse(res) {
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$pipe$2d$readable$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["pipeToNodeResponse"])(this.readable, res, this.waitUntil);
    }
} //# sourceMappingURL=render-result.js.map
}),
"[project]/node_modules/next/dist/esm/server/response-cache/utils.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "fromResponseCacheEntry": ()=>fromResponseCacheEntry,
    "routeKindToIncrementalCacheKind": ()=>routeKindToIncrementalCacheKind,
    "toResponseCacheEntry": ()=>toResponseCacheEntry
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$types$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/response-cache/types.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$render$2d$result$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/render-result.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$route$2d$kind$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/route-kind.js [ssr] (ecmascript)");
;
;
;
async function fromResponseCacheEntry(cacheEntry) {
    var _cacheEntry_value, _cacheEntry_value1;
    return {
        ...cacheEntry,
        value: ((_cacheEntry_value = cacheEntry.value) == null ? void 0 : _cacheEntry_value.kind) === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$types$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["CachedRouteKind"].PAGES ? {
            kind: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$types$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["CachedRouteKind"].PAGES,
            html: await cacheEntry.value.html.toUnchunkedString(true),
            pageData: cacheEntry.value.pageData,
            headers: cacheEntry.value.headers,
            status: cacheEntry.value.status
        } : ((_cacheEntry_value1 = cacheEntry.value) == null ? void 0 : _cacheEntry_value1.kind) === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$types$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["CachedRouteKind"].APP_PAGE ? {
            kind: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$types$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["CachedRouteKind"].APP_PAGE,
            html: await cacheEntry.value.html.toUnchunkedString(true),
            postponed: cacheEntry.value.postponed,
            rscData: cacheEntry.value.rscData,
            headers: cacheEntry.value.headers,
            status: cacheEntry.value.status,
            segmentData: cacheEntry.value.segmentData
        } : cacheEntry.value
    };
}
async function toResponseCacheEntry(response) {
    var _response_value, _response_value1;
    if (!response) return null;
    return {
        isMiss: response.isMiss,
        isStale: response.isStale,
        cacheControl: response.cacheControl,
        value: ((_response_value = response.value) == null ? void 0 : _response_value.kind) === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$types$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["CachedRouteKind"].PAGES ? {
            kind: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$types$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["CachedRouteKind"].PAGES,
            html: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$render$2d$result$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["default"].fromStatic(response.value.html),
            pageData: response.value.pageData,
            headers: response.value.headers,
            status: response.value.status
        } : ((_response_value1 = response.value) == null ? void 0 : _response_value1.kind) === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$types$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["CachedRouteKind"].APP_PAGE ? {
            kind: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$types$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["CachedRouteKind"].APP_PAGE,
            html: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$render$2d$result$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["default"].fromStatic(response.value.html),
            rscData: response.value.rscData,
            headers: response.value.headers,
            status: response.value.status,
            postponed: response.value.postponed,
            segmentData: response.value.segmentData
        } : response.value
    };
}
function routeKindToIncrementalCacheKind(routeKind) {
    switch(routeKind){
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$route$2d$kind$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["RouteKind"].PAGES:
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$types$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["IncrementalCacheKind"].PAGES;
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$route$2d$kind$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["RouteKind"].APP_PAGE:
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$types$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["IncrementalCacheKind"].APP_PAGE;
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$route$2d$kind$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["RouteKind"].IMAGE:
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$types$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["IncrementalCacheKind"].IMAGE;
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$route$2d$kind$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["RouteKind"].APP_ROUTE:
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$types$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["IncrementalCacheKind"].APP_ROUTE;
        default:
            throw Object.defineProperty(new Error(`Unexpected route kind ${routeKind}`), "__NEXT_ERROR_CODE", {
                value: "E64",
                enumerable: false,
                configurable: true
            });
    }
} //# sourceMappingURL=utils.js.map
}),
"[project]/node_modules/next/dist/esm/server/response-cache/index.js [ssr] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>ResponseCache
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$batcher$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/batcher.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$scheduler$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/scheduler.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$utils$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/response-cache/utils.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$types$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/response-cache/types.js [ssr] (ecmascript)");
;
;
;
;
class ResponseCache {
    constructor(minimal_mode){
        this.batcher = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$batcher$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["Batcher"].create({
            // Ensure on-demand revalidate doesn't block normal requests, it should be
            // safe to run an on-demand revalidate for the same key as a normal request.
            cacheKeyFn: ({ key, isOnDemandRevalidate })=>`${key}-${isOnDemandRevalidate ? '1' : '0'}`,
            // We wait to do any async work until after we've added our promise to
            // `pendingResponses` to ensure that any any other calls will reuse the
            // same promise until we've fully finished our work.
            schedulerFn: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$scheduler$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["scheduleOnNextTick"]
        });
        this.minimal_mode = minimal_mode;
    }
    async get(key, responseGenerator, context) {
        // If there is no key for the cache, we can't possibly look this up in the
        // cache so just return the result of the response generator.
        if (!key) {
            return responseGenerator({
                hasResolved: false,
                previousCacheEntry: null
            });
        }
        const { incrementalCache, isOnDemandRevalidate = false, isFallback = false, isRoutePPREnabled = false, waitUntil } = context;
        const response = await this.batcher.batch({
            key,
            isOnDemandRevalidate
        }, (cacheKey, resolve)=>{
            const prom = (async ()=>{
                var _this_previousCacheItem;
                // We keep the previous cache entry around to leverage when the
                // incremental cache is disabled in minimal mode.
                if (this.minimal_mode && ((_this_previousCacheItem = this.previousCacheItem) == null ? void 0 : _this_previousCacheItem.key) === cacheKey && this.previousCacheItem.expiresAt > Date.now()) {
                    return this.previousCacheItem.entry;
                }
                // Coerce the kindHint into a given kind for the incremental cache.
                const kind = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$utils$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["routeKindToIncrementalCacheKind"])(context.routeKind);
                let resolved = false;
                let cachedResponse = null;
                try {
                    cachedResponse = !this.minimal_mode ? await incrementalCache.get(key, {
                        kind,
                        isRoutePPREnabled: context.isRoutePPREnabled,
                        isFallback
                    }) : null;
                    if (cachedResponse && !isOnDemandRevalidate) {
                        resolve(cachedResponse);
                        resolved = true;
                        if (!cachedResponse.isStale || context.isPrefetch) {
                            // The cached value is still valid, so we don't need
                            // to update it yet.
                            return null;
                        }
                    }
                    const cacheEntry = await responseGenerator({
                        hasResolved: resolved,
                        previousCacheEntry: cachedResponse,
                        isRevalidating: true
                    });
                    // If the cache entry couldn't be generated, we don't want to cache
                    // the result.
                    if (!cacheEntry) {
                        // Unset the previous cache item if it was set.
                        if (this.minimal_mode) this.previousCacheItem = undefined;
                        return null;
                    }
                    const resolveValue = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$utils$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["fromResponseCacheEntry"])({
                        ...cacheEntry,
                        isMiss: !cachedResponse
                    });
                    if (!resolveValue) {
                        // Unset the previous cache item if it was set.
                        if (this.minimal_mode) this.previousCacheItem = undefined;
                        return null;
                    }
                    // For on-demand revalidate wait to resolve until cache is set.
                    // Otherwise resolve now.
                    if (!isOnDemandRevalidate && !resolved) {
                        resolve(resolveValue);
                        resolved = true;
                    }
                    // We want to persist the result only if it has a cache control value
                    // defined.
                    if (resolveValue.cacheControl) {
                        if (this.minimal_mode) {
                            this.previousCacheItem = {
                                key: cacheKey,
                                entry: resolveValue,
                                expiresAt: Date.now() + 1000
                            };
                        } else {
                            await incrementalCache.set(key, resolveValue.value, {
                                cacheControl: resolveValue.cacheControl,
                                isRoutePPREnabled,
                                isFallback
                            });
                        }
                    }
                    return resolveValue;
                } catch (err) {
                    // When a path is erroring we automatically re-set the existing cache
                    // with new revalidate and expire times to prevent non-stop retrying.
                    if (cachedResponse == null ? void 0 : cachedResponse.cacheControl) {
                        const newRevalidate = Math.min(Math.max(cachedResponse.cacheControl.revalidate || 3, 3), 30);
                        const newExpire = cachedResponse.cacheControl.expire === undefined ? undefined : Math.max(newRevalidate + 3, cachedResponse.cacheControl.expire);
                        await incrementalCache.set(key, cachedResponse.value, {
                            cacheControl: {
                                revalidate: newRevalidate,
                                expire: newExpire
                            },
                            isRoutePPREnabled,
                            isFallback
                        });
                    }
                    // While revalidating in the background we can't reject as we already
                    // resolved the cache entry so log the error here.
                    if (resolved) {
                        console.error(err);
                        return null;
                    }
                    // We haven't resolved yet, so let's throw to indicate an error.
                    throw err;
                }
            })();
            // we need to ensure background revalidates are
            // passed to waitUntil
            if (waitUntil) {
                waitUntil(prom);
            }
            return prom;
        });
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$utils$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["toResponseCacheEntry"])(response);
    }
} //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/next/dist/esm/server/response-cache/index.js [ssr] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$batcher$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/batcher.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$scheduler$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/scheduler.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$utils$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/response-cache/utils.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$types$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/response-cache/types.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$index$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/response-cache/index.js [ssr] (ecmascript) <locals>");
}),
"[project]/node_modules/next/dist/esm/build/templates/helpers.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * Hoists a name from a module or promised module.
 *
 * @param module the module to hoist the name from
 * @param name the name to hoist
 * @returns the value on the module (or promised module)
 */ __turbopack_context__.s({
    "hoist": ()=>hoist
});
function hoist(module, name) {
    // If the name is available in the module, return it.
    if (name in module) {
        return module[name];
    }
    // If a property called `then` exists, assume it's a promise and
    // return a promise that resolves to the name.
    if ('then' in module && typeof module.then === 'function') {
        return module.then((mod)=>hoist(mod, name));
    }
    // If we're trying to hoise the default export, and the module is a function,
    // return the module itself.
    if (typeof module === 'function' && name === 'default') {
        return module;
    }
    // Otherwise, return undefined.
    return undefined;
} //# sourceMappingURL=helpers.js.map
}),
"[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) return obj;
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") return {
        default: obj
    };
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) Object.defineProperty(newObj, key, desc);
            else newObj[key] = obj[key];
        }
    }
    newObj.default = obj;
    if (cache) cache.set(obj, newObj);
    return newObj;
}
exports._ = _interop_require_wildcard;
}}),
"[project]/node_modules/next/dist/shared/lib/side-effect.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return SideEffect;
    }
});
const _react = __turbopack_context__.r("[externals]/react [external] (react, cjs)");
const isServer = "undefined" === 'undefined';
const useClientOnlyLayoutEffect = ("TURBOPACK compile-time truthy", 1) ? ()=>{} : "TURBOPACK unreachable";
const useClientOnlyEffect = ("TURBOPACK compile-time truthy", 1) ? ()=>{} : "TURBOPACK unreachable";
function SideEffect(props) {
    const { headManager, reduceComponentsToState } = props;
    function emitChange() {
        if (headManager && headManager.mountedInstances) {
            const headElements = _react.Children.toArray(Array.from(headManager.mountedInstances).filter(Boolean));
            headManager.updateHead(reduceComponentsToState(headElements, props));
        }
    }
    if ("TURBOPACK compile-time truthy", 1) {
        var _headManager_mountedInstances;
        headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.add(props.children);
        emitChange();
    }
    useClientOnlyLayoutEffect(()=>{
        var _headManager_mountedInstances;
        headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.add(props.children);
        return ()=>{
            var _headManager_mountedInstances;
            headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.delete(props.children);
        };
    });
    // We need to call `updateHead` method whenever the `SideEffect` is trigger in all
    // life-cycles: mount, update, unmount. However, if there are multiple `SideEffect`s
    // being rendered, we only trigger the method from the last one.
    // This is ensured by keeping the last unflushed `updateHead` in the `_pendingUpdate`
    // singleton in the layout effect pass, and actually trigger it in the effect pass.
    useClientOnlyLayoutEffect(()=>{
        if (headManager) {
            headManager._pendingUpdate = emitChange;
        }
        return ()=>{
            if (headManager) {
                headManager._pendingUpdate = emitChange;
            }
        };
    });
    useClientOnlyEffect(()=>{
        if (headManager && headManager._pendingUpdate) {
            headManager._pendingUpdate();
            headManager._pendingUpdate = null;
        }
        return ()=>{
            if (headManager && headManager._pendingUpdate) {
                headManager._pendingUpdate();
                headManager._pendingUpdate = null;
            }
        };
    });
    return null;
} //# sourceMappingURL=side-effect.js.map
}}),
"[project]/node_modules/next/dist/server/route-modules/pages/vendored/contexts/amp-context.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/pages/module.compiled.js [ssr] (ecmascript)").vendored['contexts'].AmpContext; //# sourceMappingURL=amp-context.js.map
}}),
"[project]/node_modules/next/dist/server/route-modules/pages/vendored/contexts/head-manager-context.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/pages/module.compiled.js [ssr] (ecmascript)").vendored['contexts'].HeadManagerContext; //# sourceMappingURL=head-manager-context.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/amp-mode.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "isInAmpMode", {
    enumerable: true,
    get: function() {
        return isInAmpMode;
    }
});
function isInAmpMode(param) {
    let { ampFirst = false, hybrid = false, hasQuery = false } = param === void 0 ? {} : param;
    return ampFirst || hybrid && hasQuery;
} //# sourceMappingURL=amp-mode.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/utils/warn-once.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "warnOnce", {
    enumerable: true,
    get: function() {
        return warnOnce;
    }
});
let warnOnce = (_)=>{};
if ("TURBOPACK compile-time truthy", 1) {
    const warnings = new Set();
    warnOnce = (msg)=>{
        if (!warnings.has(msg)) {
            console.warn(msg);
        }
        warnings.add(msg);
    };
} //# sourceMappingURL=warn-once.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/head.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    default: null,
    defaultHead: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    default: function() {
        return _default;
    },
    defaultHead: function() {
        return defaultHead;
    }
});
const _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [ssr] (ecmascript)");
const _interop_require_wildcard = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [ssr] (ecmascript)");
const _jsxruntime = __turbopack_context__.r("[externals]/react/jsx-runtime [external] (react/jsx-runtime, cjs)");
const _react = /*#__PURE__*/ _interop_require_wildcard._(__turbopack_context__.r("[externals]/react [external] (react, cjs)"));
const _sideeffect = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/side-effect.js [ssr] (ecmascript)"));
const _ampcontextsharedruntime = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/pages/vendored/contexts/amp-context.js [ssr] (ecmascript)");
const _headmanagercontextsharedruntime = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/pages/vendored/contexts/head-manager-context.js [ssr] (ecmascript)");
const _ampmode = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/amp-mode.js [ssr] (ecmascript)");
const _warnonce = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/utils/warn-once.js [ssr] (ecmascript)");
function defaultHead(inAmpMode) {
    if (inAmpMode === void 0) inAmpMode = false;
    const head = [
        /*#__PURE__*/ (0, _jsxruntime.jsx)("meta", {
            charSet: "utf-8"
        }, "charset")
    ];
    if (!inAmpMode) {
        head.push(/*#__PURE__*/ (0, _jsxruntime.jsx)("meta", {
            name: "viewport",
            content: "width=device-width"
        }, "viewport"));
    }
    return head;
}
function onlyReactElement(list, child) {
    // React children can be "string" or "number" in this case we ignore them for backwards compat
    if (typeof child === 'string' || typeof child === 'number') {
        return list;
    }
    // Adds support for React.Fragment
    if (child.type === _react.default.Fragment) {
        return list.concat(_react.default.Children.toArray(child.props.children).reduce((fragmentList, fragmentChild)=>{
            if (typeof fragmentChild === 'string' || typeof fragmentChild === 'number') {
                return fragmentList;
            }
            return fragmentList.concat(fragmentChild);
        }, []));
    }
    return list.concat(child);
}
const METATYPES = [
    'name',
    'httpEquiv',
    'charSet',
    'itemProp'
];
/*
 returns a function for filtering head child elements
 which shouldn't be duplicated, like <title/>
 Also adds support for deduplicated `key` properties
*/ function unique() {
    const keys = new Set();
    const tags = new Set();
    const metaTypes = new Set();
    const metaCategories = {};
    return (h)=>{
        let isUnique = true;
        let hasKey = false;
        if (h.key && typeof h.key !== 'number' && h.key.indexOf('$') > 0) {
            hasKey = true;
            const key = h.key.slice(h.key.indexOf('$') + 1);
            if (keys.has(key)) {
                isUnique = false;
            } else {
                keys.add(key);
            }
        }
        // eslint-disable-next-line default-case
        switch(h.type){
            case 'title':
            case 'base':
                if (tags.has(h.type)) {
                    isUnique = false;
                } else {
                    tags.add(h.type);
                }
                break;
            case 'meta':
                for(let i = 0, len = METATYPES.length; i < len; i++){
                    const metatype = METATYPES[i];
                    if (!h.props.hasOwnProperty(metatype)) continue;
                    if (metatype === 'charSet') {
                        if (metaTypes.has(metatype)) {
                            isUnique = false;
                        } else {
                            metaTypes.add(metatype);
                        }
                    } else {
                        const category = h.props[metatype];
                        const categories = metaCategories[metatype] || new Set();
                        if ((metatype !== 'name' || !hasKey) && categories.has(category)) {
                            isUnique = false;
                        } else {
                            categories.add(category);
                            metaCategories[metatype] = categories;
                        }
                    }
                }
                break;
        }
        return isUnique;
    };
}
/**
 *
 * @param headChildrenElements List of children of <Head>
 */ function reduceComponents(headChildrenElements, props) {
    const { inAmpMode } = props;
    return headChildrenElements.reduce(onlyReactElement, []).reverse().concat(defaultHead(inAmpMode).reverse()).filter(unique()).reverse().map((c, i)=>{
        const key = c.key || i;
        if ("TURBOPACK compile-time truthy", 1) {
            // omit JSON-LD structured data snippets from the warning
            if (c.type === 'script' && c.props['type'] !== 'application/ld+json') {
                const srcMessage = c.props['src'] ? '<script> tag with src="' + c.props['src'] + '"' : "inline <script>";
                (0, _warnonce.warnOnce)("Do not add <script> tags using next/head (see " + srcMessage + "). Use next/script instead. \nSee more info here: https://nextjs.org/docs/messages/no-script-tags-in-head-component");
            } else if (c.type === 'link' && c.props['rel'] === 'stylesheet') {
                (0, _warnonce.warnOnce)('Do not add stylesheets using next/head (see <link rel="stylesheet"> tag with href="' + c.props['href'] + '"). Use Document instead. \nSee more info here: https://nextjs.org/docs/messages/no-stylesheets-in-head-component');
            }
        }
        return /*#__PURE__*/ _react.default.cloneElement(c, {
            key
        });
    });
}
/**
 * This component injects elements to `<head>` of your page.
 * To avoid duplicated `tags` in `<head>` you can use the `key` property, which will make sure every tag is only rendered once.
 */ function Head(param) {
    let { children } = param;
    const ampState = (0, _react.useContext)(_ampcontextsharedruntime.AmpStateContext);
    const headManager = (0, _react.useContext)(_headmanagercontextsharedruntime.HeadManagerContext);
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_sideeffect.default, {
        reduceComponentsToState: reduceComponents,
        headManager: headManager,
        inAmpMode: (0, _ampmode.isInAmpMode)(ampState),
        children: children
    });
}
const _default = Head;
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=head.js.map
}}),
"[project]/node_modules/next/dist/server/request-meta.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/* eslint-disable no-redeclare */ Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    NEXT_REQUEST_META: null,
    addRequestMeta: null,
    getRequestMeta: null,
    removeRequestMeta: null,
    setRequestMeta: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    NEXT_REQUEST_META: function() {
        return NEXT_REQUEST_META;
    },
    addRequestMeta: function() {
        return addRequestMeta;
    },
    getRequestMeta: function() {
        return getRequestMeta;
    },
    removeRequestMeta: function() {
        return removeRequestMeta;
    },
    setRequestMeta: function() {
        return setRequestMeta;
    }
});
const NEXT_REQUEST_META = Symbol.for('NextInternalRequestMeta');
function getRequestMeta(req, key) {
    const meta = req[NEXT_REQUEST_META] || {};
    return typeof key === 'string' ? meta[key] : meta;
}
function setRequestMeta(req, meta) {
    req[NEXT_REQUEST_META] = meta;
    return meta;
}
function addRequestMeta(request, key, value) {
    const meta = getRequestMeta(request);
    meta[key] = value;
    return setRequestMeta(request, meta);
}
function removeRequestMeta(request, key) {
    const meta = getRequestMeta(request);
    delete meta[key];
    return setRequestMeta(request, meta);
} //# sourceMappingURL=request-meta.js.map
}}),
"[project]/node_modules/next/dist/pages/_error.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return Error;
    }
});
const _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [ssr] (ecmascript)");
const _jsxruntime = __turbopack_context__.r("[externals]/react/jsx-runtime [external] (react/jsx-runtime, cjs)");
const _react = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[externals]/react [external] (react, cjs)"));
const _head = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/head.js [ssr] (ecmascript)"));
const statusCodes = {
    400: 'Bad Request',
    404: 'This page could not be found',
    405: 'Method Not Allowed',
    500: 'Internal Server Error'
};
function _getInitialProps(param) {
    let { req, res, err } = param;
    const statusCode = res && res.statusCode ? res.statusCode : err ? err.statusCode : 404;
    let hostname;
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    else if (req) {
        const { getRequestMeta } = __turbopack_context__.r("[project]/node_modules/next/dist/server/request-meta.js [ssr] (ecmascript)");
        const initUrl = getRequestMeta(req, 'initURL');
        if (initUrl) {
            const url = new URL(initUrl);
            hostname = url.hostname;
        }
    }
    return {
        statusCode,
        hostname
    };
}
const styles = {
    error: {
        // https://github.com/sindresorhus/modern-normalize/blob/main/modern-normalize.css#L38-L52
        fontFamily: 'system-ui,"Segoe UI",Roboto,Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji"',
        height: '100vh',
        textAlign: 'center',
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        justifyContent: 'center'
    },
    desc: {
        lineHeight: '48px'
    },
    h1: {
        display: 'inline-block',
        margin: '0 20px 0 0',
        paddingRight: 23,
        fontSize: 24,
        fontWeight: 500,
        verticalAlign: 'top'
    },
    h2: {
        fontSize: 14,
        fontWeight: 400,
        lineHeight: '28px'
    },
    wrap: {
        display: 'inline-block'
    }
};
class Error extends _react.default.Component {
    render() {
        const { statusCode, withDarkMode = true } = this.props;
        const title = this.props.title || statusCodes[statusCode] || 'An unexpected error has occurred';
        return /*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {
            style: styles.error,
            children: [
                /*#__PURE__*/ (0, _jsxruntime.jsx)(_head.default, {
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("title", {
                        children: statusCode ? statusCode + ": " + title : 'Application error: a client-side exception has occurred'
                    })
                }),
                /*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {
                    style: styles.desc,
                    children: [
                        /*#__PURE__*/ (0, _jsxruntime.jsx)("style", {
                            dangerouslySetInnerHTML: {
                                /* CSS minified from
                body { margin: 0; color: #000; background: #fff; }
                .next-error-h1 {
                  border-right: 1px solid rgba(0, 0, 0, .3);
                }

                ${
                  withDarkMode
                    ? `@media (prefers-color-scheme: dark) {
                  body { color: #fff; background: #000; }
                  .next-error-h1 {
                    border-right: 1px solid rgba(255, 255, 255, .3);
                  }
                }`
                    : ''
                }
               */ __html: "body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}" + (withDarkMode ? '@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}' : '')
                            }
                        }),
                        statusCode ? /*#__PURE__*/ (0, _jsxruntime.jsx)("h1", {
                            className: "next-error-h1",
                            style: styles.h1,
                            children: statusCode
                        }) : null,
                        /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                            style: styles.wrap,
                            children: /*#__PURE__*/ (0, _jsxruntime.jsxs)("h2", {
                                style: styles.h2,
                                children: [
                                    this.props.title || statusCode ? title : /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
                                        children: [
                                            "Application error: a client-side exception has occurred",
                                            ' ',
                                            Boolean(this.props.hostname) && /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
                                                children: [
                                                    "while loading ",
                                                    this.props.hostname
                                                ]
                                            }),
                                            ' ',
                                            "(see the browser console for more information)"
                                        ]
                                    }),
                                    "."
                                ]
                            })
                        })
                    ]
                })
            ]
        });
    }
}
Error.displayName = 'ErrorPage';
Error.getInitialProps = _getInitialProps;
Error.origGetInitialProps = _getInitialProps;
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=_error.js.map
}}),
"[project]/node_modules/next/error.js [ssr] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/pages/_error.js [ssr] (ecmascript)");
}}),
"[project]/node_modules/next/dist/esm/server/lib/cache-control.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "getCacheControlHeader": ()=>getCacheControlHeader
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$constants$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/constants.js [ssr] (ecmascript)");
;
function getCacheControlHeader({ revalidate, expire }) {
    const swrHeader = typeof revalidate === 'number' && expire !== undefined && revalidate < expire ? `, stale-while-revalidate=${expire - revalidate}` : '';
    if (revalidate === 0) {
        return 'private, no-cache, no-store, max-age=0, must-revalidate';
    } else if (typeof revalidate === 'number') {
        return `s-maxage=${revalidate}${swrHeader}`;
    }
    return `s-maxage=${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$constants$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["CACHE_ONE_YEAR"]}${swrHeader}`;
} //# sourceMappingURL=cache-control.js.map
}),
"[project]/node_modules/next/dist/esm/shared/lib/utils.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * Web vitals provided to _app.reportWebVitals by Core Web Vitals plugin developed by Google Chrome team.
 * https://nextjs.org/blog/next-9-4#integrated-web-vitals-reporting
 */ __turbopack_context__.s({
    "DecodeError": ()=>DecodeError,
    "MiddlewareNotFoundError": ()=>MiddlewareNotFoundError,
    "MissingStaticPage": ()=>MissingStaticPage,
    "NormalizeError": ()=>NormalizeError,
    "PageNotFoundError": ()=>PageNotFoundError,
    "SP": ()=>SP,
    "ST": ()=>ST,
    "WEB_VITALS": ()=>WEB_VITALS,
    "execOnce": ()=>execOnce,
    "getDisplayName": ()=>getDisplayName,
    "getLocationOrigin": ()=>getLocationOrigin,
    "getURL": ()=>getURL,
    "isAbsoluteUrl": ()=>isAbsoluteUrl,
    "isResSent": ()=>isResSent,
    "loadGetInitialProps": ()=>loadGetInitialProps,
    "normalizeRepeatedSlashes": ()=>normalizeRepeatedSlashes,
    "stringifyError": ()=>stringifyError
});
const WEB_VITALS = [
    'CLS',
    'FCP',
    'FID',
    'INP',
    'LCP',
    'TTFB'
];
function execOnce(fn) {
    let used = false;
    let result;
    return function() {
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        if (!used) {
            used = true;
            result = fn(...args);
        }
        return result;
    };
}
// Scheme: https://tools.ietf.org/html/rfc3986#section-3.1
// Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3
const ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\d+\-.]*?:/;
const isAbsoluteUrl = (url)=>ABSOLUTE_URL_REGEX.test(url);
function getLocationOrigin() {
    const { protocol, hostname, port } = window.location;
    return protocol + "//" + hostname + (port ? ':' + port : '');
}
function getURL() {
    const { href } = window.location;
    const origin = getLocationOrigin();
    return href.substring(origin.length);
}
function getDisplayName(Component) {
    return typeof Component === 'string' ? Component : Component.displayName || Component.name || 'Unknown';
}
function isResSent(res) {
    return res.finished || res.headersSent;
}
function normalizeRepeatedSlashes(url) {
    const urlParts = url.split('?');
    const urlNoQuery = urlParts[0];
    return urlNoQuery // first we replace any non-encoded backslashes with forward
    // then normalize repeated forward slashes
    .replace(/\\/g, '/').replace(/\/\/+/g, '/') + (urlParts[1] ? "?" + urlParts.slice(1).join('?') : '');
}
async function loadGetInitialProps(App, ctx) {
    if ("TURBOPACK compile-time truthy", 1) {
        var _App_prototype;
        if ((_App_prototype = App.prototype) == null ? void 0 : _App_prototype.getInitialProps) {
            const message = '"' + getDisplayName(App) + '.getInitialProps()" is defined as an instance method - visit https://nextjs.org/docs/messages/get-initial-props-as-an-instance-method for more information.';
            throw Object.defineProperty(new Error(message), "__NEXT_ERROR_CODE", {
                value: "E394",
                enumerable: false,
                configurable: true
            });
        }
    }
    // when called from _app `ctx` is nested in `ctx`
    const res = ctx.res || ctx.ctx && ctx.ctx.res;
    if (!App.getInitialProps) {
        if (ctx.ctx && ctx.Component) {
            // @ts-ignore pageProps default
            return {
                pageProps: await loadGetInitialProps(ctx.Component, ctx.ctx)
            };
        }
        return {};
    }
    const props = await App.getInitialProps(ctx);
    if (res && isResSent(res)) {
        return props;
    }
    if (!props) {
        const message = '"' + getDisplayName(App) + '.getInitialProps()" should resolve to an object. But found "' + props + '" instead.';
        throw Object.defineProperty(new Error(message), "__NEXT_ERROR_CODE", {
            value: "E394",
            enumerable: false,
            configurable: true
        });
    }
    if ("TURBOPACK compile-time truthy", 1) {
        if (Object.keys(props).length === 0 && !ctx.ctx) {
            console.warn("" + getDisplayName(App) + " returned an empty object from `getInitialProps`. This de-optimizes and prevents automatic static optimization. https://nextjs.org/docs/messages/empty-object-getInitialProps");
        }
    }
    return props;
}
const SP = typeof performance !== 'undefined';
const ST = SP && [
    'mark',
    'measure',
    'getEntriesByName'
].every((method)=>typeof performance[method] === 'function');
class DecodeError extends Error {
}
class NormalizeError extends Error {
}
class PageNotFoundError extends Error {
    constructor(page){
        super();
        this.code = 'ENOENT';
        this.name = 'PageNotFoundError';
        this.message = "Cannot find module for page: " + page;
    }
}
class MissingStaticPage extends Error {
    constructor(page, message){
        super();
        this.message = "Failed to load static file for page: " + page + " " + message;
    }
}
class MiddlewareNotFoundError extends Error {
    constructor(){
        super();
        this.code = 'ENOENT';
        this.message = "Cannot find the middleware module";
    }
}
function stringifyError(error) {
    return JSON.stringify({
        message: error.message,
        stack: error.stack
    });
} //# sourceMappingURL=utils.js.map
}),
"[project]/node_modules/next/dist/esm/client/components/redirect-status-code.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "RedirectStatusCode": ()=>RedirectStatusCode
});
var RedirectStatusCode = /*#__PURE__*/ function(RedirectStatusCode) {
    RedirectStatusCode[RedirectStatusCode["SeeOther"] = 303] = "SeeOther";
    RedirectStatusCode[RedirectStatusCode["TemporaryRedirect"] = 307] = "TemporaryRedirect";
    RedirectStatusCode[RedirectStatusCode["PermanentRedirect"] = 308] = "PermanentRedirect";
    return RedirectStatusCode;
}({}); //# sourceMappingURL=redirect-status-code.js.map
}),
"[project]/node_modules/next/dist/esm/lib/redirect-status.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "allowedStatusCodes": ()=>allowedStatusCodes,
    "getRedirectStatus": ()=>getRedirectStatus,
    "modifyRouteRegex": ()=>modifyRouteRegex
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$redirect$2d$status$2d$code$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/client/components/redirect-status-code.js [ssr] (ecmascript)");
;
const allowedStatusCodes = new Set([
    301,
    302,
    303,
    307,
    308
]);
function getRedirectStatus(route) {
    return route.statusCode || (route.permanent ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$redirect$2d$status$2d$code$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["RedirectStatusCode"].PermanentRedirect : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$redirect$2d$status$2d$code$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["RedirectStatusCode"].TemporaryRedirect);
}
function modifyRouteRegex(regex, restrictedPaths) {
    if (restrictedPaths) {
        regex = regex.replace(/\^/, `^(?!${restrictedPaths.map((path)=>path.replace(/\//g, '\\/')).join('|')})`);
    }
    regex = regex.replace(/\$$/, '(?:\\/)?$');
    return regex;
} //# sourceMappingURL=redirect-status.js.map
}),
"[project]/node_modules/next/dist/esm/server/lib/etag.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * FNV-1a Hash implementation
 * @author Travis Webb (tjwebb) <me@traviswebb.com>
 *
 * Ported from https://github.com/tjwebb/fnv-plus/blob/master/index.js
 *
 * Simplified, optimized and add modified for 52 bit, which provides a larger hash space
 * and still making use of Javascript's 53-bit integer space.
 */ __turbopack_context__.s({
    "fnv1a52": ()=>fnv1a52,
    "generateETag": ()=>generateETag
});
const fnv1a52 = (str)=>{
    const len = str.length;
    let i = 0, t0 = 0, v0 = 0x2325, t1 = 0, v1 = 0x8422, t2 = 0, v2 = 0x9ce4, t3 = 0, v3 = 0xcbf2;
    while(i < len){
        v0 ^= str.charCodeAt(i++);
        t0 = v0 * 435;
        t1 = v1 * 435;
        t2 = v2 * 435;
        t3 = v3 * 435;
        t2 += v0 << 8;
        t3 += v1 << 8;
        t1 += t0 >>> 16;
        v0 = t0 & 65535;
        t2 += t1 >>> 16;
        v1 = t1 & 65535;
        v3 = t3 + (t2 >>> 16) & 65535;
        v2 = t2 & 65535;
    }
    return (v3 & 15) * 281474976710656 + v2 * 4294967296 + v1 * 65536 + (v0 ^ v3 >> 4);
};
const generateETag = (payload, weak = false)=>{
    const prefix = weak ? 'W/"' : '"';
    return prefix + fnv1a52(payload).toString(36) + payload.length.toString(36) + '"';
}; //# sourceMappingURL=etag.js.map
}),
"[project]/node_modules/next/dist/compiled/fresh/index.js [ssr] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
(()=>{
    "use strict";
    var e = {
        695: (e)=>{
            /*!
 * fresh
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2016-2017 Douglas Christopher Wilson
 * MIT Licensed
 */ var r = /(?:^|,)\s*?no-cache\s*?(?:,|$)/;
            e.exports = fresh;
            function fresh(e, a) {
                var t = e["if-modified-since"];
                var s = e["if-none-match"];
                if (!t && !s) {
                    return false;
                }
                var i = e["cache-control"];
                if (i && r.test(i)) {
                    return false;
                }
                if (s && s !== "*") {
                    var f = a["etag"];
                    if (!f) {
                        return false;
                    }
                    var n = true;
                    var u = parseTokenList(s);
                    for(var _ = 0; _ < u.length; _++){
                        var o = u[_];
                        if (o === f || o === "W/" + f || "W/" + o === f) {
                            n = false;
                            break;
                        }
                    }
                    if (n) {
                        return false;
                    }
                }
                if (t) {
                    var p = a["last-modified"];
                    var v = !p || !(parseHttpDate(p) <= parseHttpDate(t));
                    if (v) {
                        return false;
                    }
                }
                return true;
            }
            function parseHttpDate(e) {
                var r = e && Date.parse(e);
                return typeof r === "number" ? r : NaN;
            }
            function parseTokenList(e) {
                var r = 0;
                var a = [];
                var t = 0;
                for(var s = 0, i = e.length; s < i; s++){
                    switch(e.charCodeAt(s)){
                        case 32:
                            if (t === r) {
                                t = r = s + 1;
                            }
                            break;
                        case 44:
                            a.push(e.substring(t, r));
                            t = r = s + 1;
                            break;
                        default:
                            r = s + 1;
                            break;
                    }
                }
                a.push(e.substring(t, r));
                return a;
            }
        }
    };
    var r = {};
    function __nccwpck_require__(a) {
        var t = r[a];
        if (t !== undefined) {
            return t.exports;
        }
        var s = r[a] = {
            exports: {}
        };
        var i = true;
        try {
            e[a](s, s.exports, __nccwpck_require__);
            i = false;
        } finally{
            if (i) delete r[a];
        }
        return s.exports;
    }
    if (typeof __nccwpck_require__ !== "undefined") __nccwpck_require__.ab = ("TURBOPACK compile-time value", "/ROOT/node_modules/next/dist/compiled/fresh") + "/";
    var a = __nccwpck_require__(695);
    module.exports = a;
})();
}}),
"[project]/node_modules/next/dist/esm/client/components/app-router-headers.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "ACTION_HEADER": ()=>ACTION_HEADER,
    "FLIGHT_HEADERS": ()=>FLIGHT_HEADERS,
    "NEXT_ACTION_NOT_FOUND_HEADER": ()=>NEXT_ACTION_NOT_FOUND_HEADER,
    "NEXT_DID_POSTPONE_HEADER": ()=>NEXT_DID_POSTPONE_HEADER,
    "NEXT_HMR_REFRESH_HASH_COOKIE": ()=>NEXT_HMR_REFRESH_HASH_COOKIE,
    "NEXT_HMR_REFRESH_HEADER": ()=>NEXT_HMR_REFRESH_HEADER,
    "NEXT_IS_PRERENDER_HEADER": ()=>NEXT_IS_PRERENDER_HEADER,
    "NEXT_REWRITTEN_PATH_HEADER": ()=>NEXT_REWRITTEN_PATH_HEADER,
    "NEXT_REWRITTEN_QUERY_HEADER": ()=>NEXT_REWRITTEN_QUERY_HEADER,
    "NEXT_ROUTER_PREFETCH_HEADER": ()=>NEXT_ROUTER_PREFETCH_HEADER,
    "NEXT_ROUTER_SEGMENT_PREFETCH_HEADER": ()=>NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,
    "NEXT_ROUTER_STALE_TIME_HEADER": ()=>NEXT_ROUTER_STALE_TIME_HEADER,
    "NEXT_ROUTER_STATE_TREE_HEADER": ()=>NEXT_ROUTER_STATE_TREE_HEADER,
    "NEXT_RSC_UNION_QUERY": ()=>NEXT_RSC_UNION_QUERY,
    "NEXT_URL": ()=>NEXT_URL,
    "RSC_CONTENT_TYPE_HEADER": ()=>RSC_CONTENT_TYPE_HEADER,
    "RSC_HEADER": ()=>RSC_HEADER
});
const RSC_HEADER = 'RSC';
const ACTION_HEADER = 'Next-Action';
const NEXT_ROUTER_STATE_TREE_HEADER = 'Next-Router-State-Tree';
const NEXT_ROUTER_PREFETCH_HEADER = 'Next-Router-Prefetch';
const NEXT_ROUTER_SEGMENT_PREFETCH_HEADER = 'Next-Router-Segment-Prefetch';
const NEXT_HMR_REFRESH_HEADER = 'Next-HMR-Refresh';
const NEXT_HMR_REFRESH_HASH_COOKIE = '__next_hmr_refresh_hash__';
const NEXT_URL = 'Next-Url';
const RSC_CONTENT_TYPE_HEADER = 'text/x-component';
const FLIGHT_HEADERS = [
    RSC_HEADER,
    NEXT_ROUTER_STATE_TREE_HEADER,
    NEXT_ROUTER_PREFETCH_HEADER,
    NEXT_HMR_REFRESH_HEADER,
    NEXT_ROUTER_SEGMENT_PREFETCH_HEADER
];
const NEXT_RSC_UNION_QUERY = '_rsc';
const NEXT_ROUTER_STALE_TIME_HEADER = 'x-nextjs-stale-time';
const NEXT_DID_POSTPONE_HEADER = 'x-nextjs-postponed';
const NEXT_REWRITTEN_PATH_HEADER = 'x-nextjs-rewritten-path';
const NEXT_REWRITTEN_QUERY_HEADER = 'x-nextjs-rewritten-query';
const NEXT_IS_PRERENDER_HEADER = 'x-nextjs-prerender';
const NEXT_ACTION_NOT_FOUND_HEADER = 'x-nextjs-action-not-found'; //# sourceMappingURL=app-router-headers.js.map
}),
"[project]/node_modules/next/dist/esm/server/send-payload.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "sendEtagResponse": ()=>sendEtagResponse,
    "sendRenderResult": ()=>sendRenderResult
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$utils$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/utils.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$etag$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/lib/etag.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$fresh$2f$index$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/fresh/index.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$cache$2d$control$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/lib/cache-control.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$app$2d$router$2d$headers$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/client/components/app-router-headers.js [ssr] (ecmascript)");
;
;
;
;
;
function sendEtagResponse(req, res, etag) {
    if (etag) {
        /**
     * The server generating a 304 response MUST generate any of the
     * following header fields that would have been sent in a 200 (OK)
     * response to the same request: Cache-Control, Content-Location, Date,
     * ETag, Expires, and Vary. https://tools.ietf.org/html/rfc7232#section-4.1
     */ res.setHeader('ETag', etag);
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$fresh$2f$index$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["default"])(req.headers, {
        etag
    })) {
        res.statusCode = 304;
        res.end();
        return true;
    }
    return false;
}
async function sendRenderResult({ req, res, result, type, generateEtags, poweredByHeader, cacheControl }) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$utils$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["isResSent"])(res)) {
        return;
    }
    if (poweredByHeader && type === 'html') {
        res.setHeader('X-Powered-By', 'Next.js');
    }
    // If cache control is already set on the response we don't
    // override it to allow users to customize it via next.config
    if (cacheControl && !res.getHeader('Cache-Control')) {
        res.setHeader('Cache-Control', (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$cache$2d$control$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["getCacheControlHeader"])(cacheControl));
    }
    const payload = result.isDynamic ? null : result.toUnchunkedString();
    if (generateEtags && payload !== null) {
        const etag = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$etag$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["generateETag"])(payload);
        if (sendEtagResponse(req, res, etag)) {
            return;
        }
    }
    if (!res.getHeader('Content-Type')) {
        res.setHeader('Content-Type', result.contentType ? result.contentType : type === 'rsc' ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$app$2d$router$2d$headers$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["RSC_CONTENT_TYPE_HEADER"] : type === 'json' ? 'application/json' : 'text/html; charset=utf-8');
    }
    if (payload) {
        res.setHeader('Content-Length', Buffer.byteLength(payload));
    }
    if (req.method === 'HEAD') {
        res.end(null);
        return;
    }
    if (payload !== null) {
        res.end(payload);
        return;
    }
    // Pipe the render result to the response after we get a writer for it.
    await result.pipeToNodeResponse(res);
} //# sourceMappingURL=send-payload.js.map
}),
"[project]/node_modules/next/dist/esm/shared/lib/router/utils/html-bots.js [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// This regex contains the bots that we need to do a blocking render for and can't safely stream the response
// due to how they parse the DOM. For example, they might explicitly check for metadata in the `head` tag, so we can't stream metadata tags after the `head` was sent.
__turbopack_context__.s({
    "HTML_LIMITED_BOT_UA_RE": ()=>HTML_LIMITED_BOT_UA_RE
});
const HTML_LIMITED_BOT_UA_RE = /Mediapartners-Google|Chrome-Lighthouse|Slurp|DuckDuckBot|baiduspider|yandex|sogou|bitlybot|tumblr|vkShare|quora link preview|redditbot|ia_archiver|Bingbot|BingPreview|applebot|facebookexternalhit|facebookcatalog|Twitterbot|LinkedInBot|Slackbot|Discordbot|WhatsApp|SkypeUriPreview|Yeti/i; //# sourceMappingURL=html-bots.js.map
}),
"[project]/node_modules/next/dist/esm/shared/lib/router/utils/is-bot.js [ssr] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "HTML_LIMITED_BOT_UA_RE_STRING": ()=>HTML_LIMITED_BOT_UA_RE_STRING,
    "getBotType": ()=>getBotType,
    "isBot": ()=>isBot
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$html$2d$bots$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/router/utils/html-bots.js [ssr] (ecmascript)");
;
// Bot crawler that will spin up a headless browser and execute JS.
// By default, only googlebots are considered as DOM bots. Blow is where the regex is computed from:
// x-ref: https://developers.google.com/search/docs/crawling-indexing/google-common-crawlers
const HEADLESS_BROWSER_BOT_UA_RE = /google/i;
const HTML_LIMITED_BOT_UA_RE_STRING = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$html$2d$bots$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["HTML_LIMITED_BOT_UA_RE"].source;
;
function isDomBotUA(userAgent) {
    return HEADLESS_BROWSER_BOT_UA_RE.test(userAgent);
}
function isHtmlLimitedBotUA(userAgent) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$html$2d$bots$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["HTML_LIMITED_BOT_UA_RE"].test(userAgent);
}
function isBot(userAgent) {
    return isDomBotUA(userAgent) || isHtmlLimitedBotUA(userAgent);
}
function getBotType(userAgent) {
    if (isDomBotUA(userAgent)) {
        return 'dom';
    }
    if (isHtmlLimitedBotUA(userAgent)) {
        return 'html';
    }
    return undefined;
} //# sourceMappingURL=is-bot.js.map
}),
"[project]/node_modules/next/dist/esm/shared/lib/router/utils/is-bot.js [ssr] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$html$2d$bots$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/router/utils/html-bots.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$is$2d$bot$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/router/utils/is-bot.js [ssr] (ecmascript) <locals>");
}),
"[project]/node_modules/next/dist/esm/build/templates/pages.js { INNER_PAGE => \"[project]/node_modules/next/error.js [ssr] (ecmascript)\", INNER_DOCUMENT => \"[project]/node_modules/next/document.js [ssr] (ecmascript)\", INNER_APP => \"[project]/node_modules/next/app.js [ssr] (ecmascript)\" } [ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "config": ()=>config,
    "default": ()=>__TURBOPACK__default__export__,
    "getServerSideProps": ()=>getServerSideProps,
    "getStaticPaths": ()=>getStaticPaths,
    "getStaticProps": ()=>getStaticProps,
    "handler": ()=>handler,
    "reportWebVitals": ()=>reportWebVitals,
    "routeModule": ()=>routeModule,
    "unstable_getServerProps": ()=>unstable_getServerProps,
    "unstable_getServerSideProps": ()=>unstable_getServerSideProps,
    "unstable_getStaticParams": ()=>unstable_getStaticParams,
    "unstable_getStaticPaths": ()=>unstable_getStaticPaths,
    "unstable_getStaticProps": ()=>unstable_getStaticProps
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$route$2d$modules$2f$pages$2f$module$2e$compiled$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/route-modules/pages/module.compiled.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$route$2d$kind$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/route-kind.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$constants$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/lib/trace/constants.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$tracer$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/lib/trace/tracer.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$format$2d$url$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/router/utils/format-url.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2d$meta$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/request-meta.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$interop$2d$default$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/app-render/interop-default.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$instrumentation$2f$utils$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/instrumentation/utils.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$page$2d$path$2f$normalize$2d$data$2d$path$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/page-path/normalize-data-path.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$index$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/response-cache/index.js [ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$types$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/response-cache/types.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$build$2f$templates$2f$helpers$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/build/templates/helpers.js [ssr] (ecmascript)");
// Import the app and document modules.
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$document$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/document.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$app$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/app.js [ssr] (ecmascript)");
// Import the userland code.
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$error$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/error.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$cache$2d$control$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/lib/cache-control.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$utils$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/utils.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$redirect$2d$status$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/redirect-status.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$constants$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/constants.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$send$2d$payload$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/send-payload.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$render$2d$result$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/render-result.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$utils$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/response-cache/utils.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$next$2f$dist$2f$shared$2f$lib$2f$no$2d$fallback$2d$error$2e$external$2e$js__$5b$external$5d$__$28$next$2f$dist$2f$shared$2f$lib$2f$no$2d$fallback$2d$error$2e$external$2e$js$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$redirect$2d$status$2d$code$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/client/components/redirect-status-code.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$is$2d$bot$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/router/utils/is-bot.js [ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$is$2d$bot$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/router/utils/is-bot.js [ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$add$2d$path$2d$prefix$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/router/utils/add-path-prefix.js [ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$remove$2d$trailing$2d$slash$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/router/utils/remove-trailing-slash.js [ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
const __TURBOPACK__default__export__ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$build$2f$templates$2f$helpers$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["hoist"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$error$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__, 'default');
const getStaticProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$build$2f$templates$2f$helpers$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["hoist"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$error$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__, 'getStaticProps');
const getStaticPaths = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$build$2f$templates$2f$helpers$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["hoist"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$error$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__, 'getStaticPaths');
const getServerSideProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$build$2f$templates$2f$helpers$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["hoist"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$error$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__, 'getServerSideProps');
const config = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$build$2f$templates$2f$helpers$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["hoist"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$error$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__, 'config');
const reportWebVitals = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$build$2f$templates$2f$helpers$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["hoist"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$error$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__, 'reportWebVitals');
const unstable_getStaticProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$build$2f$templates$2f$helpers$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["hoist"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$error$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__, 'unstable_getStaticProps');
const unstable_getStaticPaths = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$build$2f$templates$2f$helpers$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["hoist"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$error$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__, 'unstable_getStaticPaths');
const unstable_getStaticParams = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$build$2f$templates$2f$helpers$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["hoist"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$error$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__, 'unstable_getStaticParams');
const unstable_getServerProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$build$2f$templates$2f$helpers$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["hoist"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$error$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__, 'unstable_getServerProps');
const unstable_getServerSideProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$build$2f$templates$2f$helpers$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["hoist"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$error$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__, 'unstable_getServerSideProps');
const routeModule = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$route$2d$modules$2f$pages$2f$module$2e$compiled$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["PagesRouteModule"]({
    definition: {
        kind: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$route$2d$kind$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["RouteKind"].PAGES,
        page: "/_error",
        pathname: "/_error",
        // The following aren't used in production.
        bundlePath: '',
        filename: ''
    },
    distDir: ("TURBOPACK compile-time value", ".next") || '',
    projectDir: ("TURBOPACK compile-time value", "") || '',
    components: {
        // default export might not exist when optimized for data only
        App: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$app$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["default"],
        Document: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$document$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["default"]
    },
    userland: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$error$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__
});
async function handler(req, res, ctx) {
    var _serverFilesManifest_config_experimental, _serverFilesManifest_config;
    let srcPage = "/_error";
    // turbopack doesn't normalize `/index` in the page name
    // so we need to to process dynamic routes properly
    // TODO: fix turbopack providing differing value from webpack
    if ("TURBOPACK compile-time truthy", 1) {
        srcPage = srcPage.replace(/\/index$/, '') || '/';
    } else if (srcPage === '/index') {
        // we always normalize /index specifically
        srcPage = '/';
    }
    const multiZoneDraftMode = ("TURBOPACK compile-time value", "false");
    const prepareResult = await routeModule.prepare(req, res, {
        srcPage,
        multiZoneDraftMode
    });
    if (!prepareResult) {
        res.statusCode = 400;
        res.end('Bad Request');
        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());
        return;
    }
    const { buildId, query, params, parsedUrl, originalQuery, originalPathname, buildManifest, nextFontManifest, serverFilesManifest, reactLoadableManifest, prerenderManifest, isDraftMode, isOnDemandRevalidate, revalidateOnlyGenerated, locale, locales, defaultLocale, routerServerContext, nextConfig, resolvedPathname } = prepareResult;
    const isExperimentalCompile = serverFilesManifest == null ? void 0 : (_serverFilesManifest_config = serverFilesManifest.config) == null ? void 0 : (_serverFilesManifest_config_experimental = _serverFilesManifest_config.experimental) == null ? void 0 : _serverFilesManifest_config_experimental.isExperimentalCompile;
    const hasServerProps = Boolean(getServerSideProps);
    const hasStaticProps = Boolean(getStaticProps);
    const hasStaticPaths = Boolean(getStaticPaths);
    const hasGetInitialProps = Boolean((__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$error$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__.default || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$error$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__).getInitialProps);
    const isAmp = query.amp && config.amp;
    let cacheKey = null;
    let isIsrFallback = false;
    let isNextDataRequest = prepareResult.isNextDataRequest && (hasStaticProps || hasServerProps);
    const is404Page = srcPage === '/404';
    const is500Page = srcPage === '/500';
    const isErrorPage = srcPage === '/_error';
    if (!routeModule.isDev && !isDraftMode && hasStaticProps) {
        cacheKey = `${locale ? `/${locale}` : ''}${(srcPage === '/' || resolvedPathname === '/') && locale ? '' : resolvedPathname}${isAmp ? '.amp' : ''}`;
        if (is404Page || is500Page || isErrorPage) {
            cacheKey = `${locale ? `/${locale}` : ''}${srcPage}${isAmp ? '.amp' : ''}`;
        }
        // ensure /index and / is normalized to one key
        cacheKey = cacheKey === '/index' ? '/' : cacheKey;
    }
    if (hasStaticPaths && !isDraftMode) {
        const decodedPathname = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$remove$2d$trailing$2d$slash$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["removeTrailingSlash"])(locale ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$add$2d$path$2d$prefix$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["addPathPrefix"])(resolvedPathname, `/${locale}`) : resolvedPathname);
        const isPrerendered = Boolean(prerenderManifest.routes[decodedPathname]) || prerenderManifest.notFoundRoutes.includes(decodedPathname);
        const prerenderInfo = prerenderManifest.dynamicRoutes[srcPage];
        if (prerenderInfo) {
            if (prerenderInfo.fallback === false && !isPrerendered) {
                throw new __TURBOPACK__imported__module__$5b$externals$5d2f$next$2f$dist$2f$shared$2f$lib$2f$no$2d$fallback$2d$error$2e$external$2e$js__$5b$external$5d$__$28$next$2f$dist$2f$shared$2f$lib$2f$no$2d$fallback$2d$error$2e$external$2e$js$2c$__cjs$29$__["NoFallbackError"]();
            }
            if (typeof prerenderInfo.fallback === 'string' && !isPrerendered && !isNextDataRequest) {
                isIsrFallback = true;
            }
        }
    }
    // When serving a bot request, we want to serve a blocking render and not
    // the prerendered page. This ensures that the correct content is served
    // to the bot in the head.
    if (isIsrFallback && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$is$2d$bot$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isBot"])(req.headers['user-agent'] || '') || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2d$meta$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["getRequestMeta"])(req, 'minimalMode')) {
        isIsrFallback = false;
    }
    const tracer = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$tracer$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["getTracer"])();
    const activeSpan = tracer.getActiveScopeSpan();
    try {
        const method = req.method || 'GET';
        const resolvedUrl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$format$2d$url$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["formatUrl"])({
            pathname: nextConfig.trailingSlash ? parsedUrl.pathname : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$remove$2d$trailing$2d$slash$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["removeTrailingSlash"])(parsedUrl.pathname || '/'),
            // make sure to only add query values from original URL
            query: hasStaticProps ? {} : originalQuery
        });
        const publicRuntimeConfig = (routerServerContext == null ? void 0 : routerServerContext.publicRuntimeConfig) || nextConfig.publicRuntimeConfig;
        const handleResponse = async (span)=>{
            const responseGenerator = async ({ previousCacheEntry })=>{
                var _previousCacheEntry_value;
                const doRender = async ()=>{
                    try {
                        var _nextConfig_i18n, _nextConfig_experimental_amp, _nextConfig_experimental_amp1;
                        return await routeModule.render(req, res, {
                            query: hasStaticProps && !isExperimentalCompile ? {
                                ...params,
                                ...isAmp ? {
                                    amp: query.amp
                                } : {}
                            } : {
                                ...query,
                                ...params
                            },
                            params,
                            page: srcPage,
                            renderContext: {
                                isDraftMode,
                                isFallback: isIsrFallback,
                                developmentNotFoundSourcePage: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2d$meta$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["getRequestMeta"])(req, 'developmentNotFoundSourcePage')
                            },
                            sharedContext: {
                                buildId,
                                customServer: Boolean(routerServerContext == null ? void 0 : routerServerContext.isCustomServer) || undefined,
                                deploymentId: ("TURBOPACK compile-time value", false)
                            },
                            renderOpts: {
                                params,
                                routeModule,
                                page: srcPage,
                                pageConfig: config || {},
                                Component: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$interop$2d$default$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["interopDefault"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$error$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__),
                                ComponentMod: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$error$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__,
                                getStaticProps,
                                getStaticPaths,
                                getServerSideProps,
                                supportsDynamicResponse: !hasStaticProps,
                                buildManifest,
                                nextFontManifest,
                                reactLoadableManifest,
                                assetPrefix: nextConfig.assetPrefix,
                                strictNextHead: nextConfig.experimental.strictNextHead ?? true,
                                previewProps: prerenderManifest.preview,
                                images: nextConfig.images,
                                nextConfigOutput: nextConfig.output,
                                optimizeCss: Boolean(nextConfig.experimental.optimizeCss),
                                nextScriptWorkers: Boolean(nextConfig.experimental.nextScriptWorkers),
                                domainLocales: (_nextConfig_i18n = nextConfig.i18n) == null ? void 0 : _nextConfig_i18n.domains,
                                crossOrigin: nextConfig.crossOrigin,
                                multiZoneDraftMode,
                                basePath: nextConfig.basePath,
                                canonicalBase: nextConfig.amp.canonicalBase || '',
                                ampOptimizerConfig: (_nextConfig_experimental_amp = nextConfig.experimental.amp) == null ? void 0 : _nextConfig_experimental_amp.optimizer,
                                disableOptimizedLoading: nextConfig.experimental.disableOptimizedLoading,
                                largePageDataBytes: nextConfig.experimental.largePageDataBytes,
                                // Only the `publicRuntimeConfig` key is exposed to the client side
                                // It'll be rendered as part of __NEXT_DATA__ on the client side
                                runtimeConfig: Object.keys(publicRuntimeConfig).length > 0 ? publicRuntimeConfig : undefined,
                                isExperimentalCompile,
                                experimental: {
                                    clientTraceMetadata: nextConfig.experimental.clientTraceMetadata || []
                                },
                                locale,
                                locales,
                                defaultLocale,
                                setIsrStatus: routerServerContext == null ? void 0 : routerServerContext.setIsrStatus,
                                isNextDataRequest: isNextDataRequest && (hasServerProps || hasStaticProps),
                                resolvedUrl,
                                // For getServerSideProps and getInitialProps we need to ensure we use the original URL
                                // and not the resolved URL to prevent a hydration mismatch on
                                // asPath
                                resolvedAsPath: hasServerProps || hasGetInitialProps ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$format$2d$url$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["formatUrl"])({
                                    // we use the original URL pathname less the _next/data prefix if
                                    // present
                                    pathname: isNextDataRequest ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$page$2d$path$2f$normalize$2d$data$2d$path$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["normalizeDataPath"])(originalPathname) : originalPathname,
                                    query: originalQuery
                                }) : resolvedUrl,
                                isOnDemandRevalidate,
                                ErrorDebug: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2d$meta$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["getRequestMeta"])(req, 'PagesErrorDebug'),
                                err: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2d$meta$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["getRequestMeta"])(req, 'invokeError'),
                                dev: routeModule.isDev,
                                // needed for experimental.optimizeCss feature
                                distDir: `${routeModule.projectDir}/${routeModule.distDir}`,
                                ampSkipValidation: (_nextConfig_experimental_amp1 = nextConfig.experimental.amp) == null ? void 0 : _nextConfig_experimental_amp1.skipValidation,
                                ampValidator: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2d$meta$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["getRequestMeta"])(req, 'ampValidator')
                            }
                        }).then((renderResult)=>{
                            const { metadata } = renderResult;
                            let cacheControl = metadata.cacheControl;
                            if ('isNotFound' in metadata && metadata.isNotFound) {
                                return {
                                    value: null,
                                    cacheControl
                                };
                            }
                            // Handle `isRedirect`.
                            if (metadata.isRedirect) {
                                return {
                                    value: {
                                        kind: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$types$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["CachedRouteKind"].REDIRECT,
                                        props: metadata.pageData ?? metadata.flightData
                                    },
                                    cacheControl
                                };
                            }
                            return {
                                value: {
                                    kind: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$types$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["CachedRouteKind"].PAGES,
                                    html: renderResult,
                                    pageData: renderResult.metadata.pageData,
                                    headers: renderResult.metadata.headers,
                                    status: renderResult.metadata.statusCode
                                },
                                cacheControl
                            };
                        }).finally(()=>{
                            if (!span) return;
                            span.setAttributes({
                                'http.status_code': res.statusCode,
                                'next.rsc': false
                            });
                            const rootSpanAttributes = tracer.getRootSpanAttributes();
                            // We were unable to get attributes, probably OTEL is not enabled
                            if (!rootSpanAttributes) {
                                return;
                            }
                            if (rootSpanAttributes.get('next.span_type') !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$constants$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["BaseServerSpan"].handleRequest) {
                                console.warn(`Unexpected root span type '${rootSpanAttributes.get('next.span_type')}'. Please report this Next.js issue https://github.com/vercel/next.js`);
                                return;
                            }
                            const route = rootSpanAttributes.get('next.route');
                            if (route) {
                                const name = `${method} ${route}`;
                                span.setAttributes({
                                    'next.route': route,
                                    'http.route': route,
                                    'next.span_name': name
                                });
                                span.updateName(name);
                            } else {
                                span.updateName(`${method} ${req.url}`);
                            }
                        });
                    } catch (err) {
                        // if this is a background revalidate we need to report
                        // the request error here as it won't be bubbled
                        if (previousCacheEntry == null ? void 0 : previousCacheEntry.isStale) {
                            await routeModule.onRequestError(req, err, {
                                routerKind: 'Pages Router',
                                routePath: srcPage,
                                routeType: 'render',
                                revalidateReason: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$instrumentation$2f$utils$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["getRevalidateReason"])({
                                    isRevalidate: hasStaticProps,
                                    isOnDemandRevalidate
                                })
                            }, routerServerContext);
                        }
                        throw err;
                    }
                };
                // if we've already generated this page we no longer
                // serve the fallback
                if (previousCacheEntry) {
                    isIsrFallback = false;
                }
                if (isIsrFallback) {
                    const fallbackResponse = await routeModule.getResponseCache(req).get(routeModule.isDev ? null : locale ? `/${locale}${srcPage}` : srcPage, async ({ previousCacheEntry: previousFallbackCacheEntry = null })=>{
                        if (!routeModule.isDev) {
                            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$utils$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["toResponseCacheEntry"])(previousFallbackCacheEntry);
                        }
                        return doRender();
                    }, {
                        routeKind: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$route$2d$kind$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["RouteKind"].PAGES,
                        isFallback: true,
                        isRoutePPREnabled: false,
                        isOnDemandRevalidate: false,
                        incrementalCache: await routeModule.getIncrementalCache(req, nextConfig, prerenderManifest),
                        waitUntil: ctx.waitUntil
                    });
                    if (fallbackResponse) {
                        // Remove the cache control from the response to prevent it from being
                        // used in the surrounding cache.
                        delete fallbackResponse.cacheControl;
                        fallbackResponse.isMiss = true;
                        return fallbackResponse;
                    }
                }
                if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2d$meta$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["getRequestMeta"])(req, 'minimalMode') && isOnDemandRevalidate && revalidateOnlyGenerated && !previousCacheEntry) {
                    res.statusCode = 404;
                    // on-demand revalidate always sets this header
                    res.setHeader('x-nextjs-cache', 'REVALIDATED');
                    res.end('This page could not be found');
                    return null;
                }
                if (isIsrFallback && (previousCacheEntry == null ? void 0 : (_previousCacheEntry_value = previousCacheEntry.value) == null ? void 0 : _previousCacheEntry_value.kind) === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$types$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["CachedRouteKind"].PAGES) {
                    return {
                        value: {
                            kind: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$types$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["CachedRouteKind"].PAGES,
                            html: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$render$2d$result$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["default"](Buffer.from(previousCacheEntry.value.html), {
                                contentType: 'text/html;utf-8',
                                metadata: {
                                    statusCode: previousCacheEntry.value.status,
                                    headers: previousCacheEntry.value.headers
                                }
                            }),
                            pageData: {},
                            status: previousCacheEntry.value.status,
                            headers: previousCacheEntry.value.headers
                        },
                        cacheControl: {
                            revalidate: 0,
                            expire: undefined
                        }
                    };
                }
                return doRender();
            };
            const result = await routeModule.handleResponse({
                cacheKey,
                req,
                nextConfig,
                routeKind: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$route$2d$kind$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["RouteKind"].PAGES,
                isOnDemandRevalidate,
                revalidateOnlyGenerated,
                waitUntil: ctx.waitUntil,
                responseGenerator: responseGenerator,
                prerenderManifest
            });
            // if we got a cache hit this wasn't an ISR fallback
            // but it wasn't generated during build so isn't in the
            // prerender-manifest
            if (isIsrFallback && !(result == null ? void 0 : result.isMiss)) {
                isIsrFallback = false;
            }
            // response is finished is no cache entry
            if (!result) {
                return;
            }
            if (hasStaticProps && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2d$meta$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["getRequestMeta"])(req, 'minimalMode')) {
                res.setHeader('x-nextjs-cache', isOnDemandRevalidate ? 'REVALIDATED' : result.isMiss ? 'MISS' : result.isStale ? 'STALE' : 'HIT');
            }
            let cacheControl;
            if (!hasStaticProps || isIsrFallback) {
                if (!res.getHeader('Cache-Control')) {
                    cacheControl = {
                        revalidate: 0,
                        expire: undefined
                    };
                }
            } else if (is404Page) {
                const notFoundRevalidate = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2d$meta$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["getRequestMeta"])(req, 'notFoundRevalidate');
                cacheControl = {
                    revalidate: typeof notFoundRevalidate === 'undefined' ? 0 : notFoundRevalidate,
                    expire: undefined
                };
            } else if (is500Page) {
                cacheControl = {
                    revalidate: 0,
                    expire: undefined
                };
            } else if (result.cacheControl) {
                // If the cache entry has a cache control with a revalidate value that's
                // a number, use it.
                if (typeof result.cacheControl.revalidate === 'number') {
                    var _result_cacheControl;
                    if (result.cacheControl.revalidate < 1) {
                        throw Object.defineProperty(new Error(`Invalid revalidate configuration provided: ${result.cacheControl.revalidate} < 1`), "__NEXT_ERROR_CODE", {
                            value: "E22",
                            enumerable: false,
                            configurable: true
                        });
                    }
                    cacheControl = {
                        revalidate: result.cacheControl.revalidate,
                        expire: ((_result_cacheControl = result.cacheControl) == null ? void 0 : _result_cacheControl.expire) ?? nextConfig.expireTime
                    };
                } else {
                    // revalidate: false
                    cacheControl = {
                        revalidate: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$constants$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["CACHE_ONE_YEAR"],
                        expire: undefined
                    };
                }
            }
            // If cache control is already set on the response we don't
            // override it to allow users to customize it via next.config
            if (cacheControl && !res.getHeader('Cache-Control')) {
                res.setHeader('Cache-Control', (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$cache$2d$control$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["getCacheControlHeader"])(cacheControl));
            }
            // notFound: true case
            if (!result.value) {
                var _result_cacheControl1;
                // add revalidate metadata before rendering 404 page
                // so that we can use this as source of truth for the
                // cache-control header instead of what the 404 page returns
                // for the revalidate value
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2d$meta$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["addRequestMeta"])(req, 'notFoundRevalidate', (_result_cacheControl1 = result.cacheControl) == null ? void 0 : _result_cacheControl1.revalidate);
                res.statusCode = 404;
                if (isNextDataRequest) {
                    res.end('{"notFound":true}');
                    return;
                }
                // TODO: should route-module itself handle rendering the 404
                if (routerServerContext == null ? void 0 : routerServerContext.render404) {
                    await routerServerContext.render404(req, res, parsedUrl, false);
                } else {
                    res.end('This page could not be found');
                }
                return;
            }
            if (result.value.kind === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$types$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["CachedRouteKind"].REDIRECT) {
                if (isNextDataRequest) {
                    res.setHeader('content-type', 'application/json');
                    res.end(JSON.stringify(result.value.props));
                    return;
                } else {
                    const handleRedirect = (pageData)=>{
                        const redirect = {
                            destination: pageData.pageProps.__N_REDIRECT,
                            statusCode: pageData.pageProps.__N_REDIRECT_STATUS,
                            basePath: pageData.pageProps.__N_REDIRECT_BASE_PATH
                        };
                        const statusCode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$redirect$2d$status$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["getRedirectStatus"])(redirect);
                        const { basePath } = nextConfig;
                        if (basePath && redirect.basePath !== false && redirect.destination.startsWith('/')) {
                            redirect.destination = `${basePath}${redirect.destination}`;
                        }
                        if (redirect.destination.startsWith('/')) {
                            redirect.destination = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$utils$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["normalizeRepeatedSlashes"])(redirect.destination);
                        }
                        res.statusCode = statusCode;
                        res.setHeader('Location', redirect.destination);
                        if (statusCode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$redirect$2d$status$2d$code$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["RedirectStatusCode"].PermanentRedirect) {
                            res.setHeader('Refresh', `0;url=${redirect.destination}`);
                        }
                        res.end(redirect.destination);
                    };
                    await handleRedirect(result.value.props);
                    return null;
                }
            }
            if (result.value.kind !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$types$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["CachedRouteKind"].PAGES) {
                throw Object.defineProperty(new Error(`Invariant: received non-pages cache entry in pages handler`), "__NEXT_ERROR_CODE", {
                    value: "E695",
                    enumerable: false,
                    configurable: true
                });
            }
            // In dev, we should not cache pages for any reason.
            if (routeModule.isDev) {
                res.setHeader('Cache-Control', 'no-store, must-revalidate');
            }
            // Draft mode should never be cached
            if (isDraftMode) {
                res.setHeader('Cache-Control', 'private, no-cache, no-store, max-age=0, must-revalidate');
            }
            // when invoking _error before pages/500 we don't actually
            // send the _error response
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2d$meta$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["getRequestMeta"])(req, 'customErrorRender') || isErrorPage && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2d$meta$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["getRequestMeta"])(req, 'minimalMode') && res.statusCode === 500) {
                return null;
            }
            await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$send$2d$payload$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["sendRenderResult"])({
                req,
                res,
                // If we are rendering the error page it's not a data request
                // anymore
                result: isNextDataRequest && !isErrorPage && !is500Page ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$render$2d$result$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["default"](Buffer.from(JSON.stringify(result.value.pageData)), {
                    contentType: 'application/json',
                    metadata: result.value.html.metadata
                }) : result.value.html,
                generateEtags: nextConfig.generateEtags,
                poweredByHeader: nextConfig.poweredByHeader,
                cacheControl: routeModule.isDev ? undefined : cacheControl,
                type: isNextDataRequest ? 'json' : 'html'
            });
        };
        // TODO: activeSpan code path is for when wrapped by
        // next-server can be removed when this is no longer used
        if (activeSpan) {
            await handleResponse();
        } else {
            await tracer.withPropagatedContext(req.headers, ()=>tracer.trace(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$constants$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["BaseServerSpan"].handleRequest, {
                    spanName: `${method} ${req.url}`,
                    kind: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$tracer$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["SpanKind"].SERVER,
                    attributes: {
                        'http.method': method,
                        'http.target': req.url
                    }
                }, handleResponse));
        }
    } catch (err) {
        await routeModule.onRequestError(req, err, {
            routerKind: 'Pages Router',
            routePath: srcPage,
            routeType: 'render',
            revalidateReason: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$instrumentation$2f$utils$2e$js__$5b$ssr$5d$__$28$ecmascript$29$__["getRevalidateReason"])({
                isRevalidate: hasStaticProps,
                isOnDemandRevalidate
            })
        }, routerServerContext);
        // rethrow so that we can handle serving error page
        throw err;
    }
} //# sourceMappingURL=pages.js.map
}),

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFtdLAogICJzZWN0aW9ucyI6IFsKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNiwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL3NlcnZlci9yb3V0ZS1tb2R1bGVzL3BhZ2VzL21vZHVsZS5jb21waWxlZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpZiAocHJvY2Vzcy5lbnYuTkVYVF9SVU5USU1FID09PSAnZWRnZScpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCduZXh0L2Rpc3Qvc2VydmVyL3JvdXRlLW1vZHVsZXMvcGFnZXMvbW9kdWxlLmpzJylcbn0gZWxzZSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgIGlmIChwcm9jZXNzLmVudi5UVVJCT1BBQ0spIHtcbiAgICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnbmV4dC9kaXN0L2NvbXBpbGVkL25leHQtc2VydmVyL3BhZ2VzLXR1cmJvLnJ1bnRpbWUuZGV2LmpzJylcbiAgICB9IGVsc2Uge1xuICAgICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCduZXh0L2Rpc3QvY29tcGlsZWQvbmV4dC1zZXJ2ZXIvcGFnZXMucnVudGltZS5kZXYuanMnKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuVFVSQk9QQUNLKSB7XG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ25leHQvZGlzdC9jb21waWxlZC9uZXh0LXNlcnZlci9wYWdlcy10dXJiby5ydW50aW1lLnByb2QuanMnKVxuICAgIH0gZWxzZSB7XG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ25leHQvZGlzdC9jb21waWxlZC9uZXh0LXNlcnZlci9wYWdlcy5ydW50aW1lLnByb2QuanMnKVxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJlbnYiLCJORVhUX1JVTlRJTUUiLCJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSIsIk5PREVfRU5WIiwiVFVSQk9QQUNLIl0sIm1hcHBpbmdzIjoiQUFBQSxJQUFJQSxRQUFRQyxHQUFHLENBQUNDLFlBQVksS0FBSyxRQUFROztLQUVsQztJQUNMLElBQUlGLFFBQVFDLEdBQUcsQ0FBQ0ssUUFBUSxLQUFLLFdBQWU7UUFDMUMsSUFBSU4sUUFBUUMsR0FBRyxDQUFDTSxTQUFTLGVBQUU7WUFDekJKLE9BQU9DLE9BQU8sR0FBR0MsUUFBUTtRQUMzQixPQUFPOztJQUdULE9BQU87O0FBT1QiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMjEsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NyYy9zZXJ2ZXIvcm91dGUta2luZC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgZW51bSBSb3V0ZUtpbmQge1xuICAvKipcbiAgICogYFBBR0VTYCByZXByZXNlbnRzIGFsbCB0aGUgUmVhY3QgcGFnZXMgdGhhdCBhcmUgdW5kZXIgYHBhZ2VzL2AuXG4gICAqL1xuICBQQUdFUyA9ICdQQUdFUycsXG4gIC8qKlxuICAgKiBgUEFHRVNfQVBJYCByZXByZXNlbnRzIGFsbCB0aGUgQVBJIHJvdXRlcyB1bmRlciBgcGFnZXMvYXBpL2AuXG4gICAqL1xuICBQQUdFU19BUEkgPSAnUEFHRVNfQVBJJyxcbiAgLyoqXG4gICAqIGBBUFBfUEFHRWAgcmVwcmVzZW50cyBhbGwgdGhlIFJlYWN0IHBhZ2VzIHRoYXQgYXJlIHVuZGVyIGBhcHAvYCB3aXRoIHRoZVxuICAgKiBmaWxlbmFtZSBvZiBgcGFnZS57aix0fXN7LHh9YC5cbiAgICovXG4gIEFQUF9QQUdFID0gJ0FQUF9QQUdFJyxcbiAgLyoqXG4gICAqIGBBUFBfUk9VVEVgIHJlcHJlc2VudHMgYWxsIHRoZSBBUEkgcm91dGVzIGFuZCBtZXRhZGF0YSByb3V0ZXMgdGhhdCBhcmUgdW5kZXIgYGFwcC9gIHdpdGggdGhlXG4gICAqIGZpbGVuYW1lIG9mIGByb3V0ZS57aix0fXN7LHh9YC5cbiAgICovXG4gIEFQUF9ST1VURSA9ICdBUFBfUk9VVEUnLFxuXG4gIC8qKlxuICAgKiBgSU1BR0VgIHJlcHJlc2VudHMgYWxsIHRoZSBpbWFnZXMgdGhhdCBhcmUgZ2VuZXJhdGVkIGJ5IGBuZXh0L2ltYWdlYC5cbiAgICovXG4gIElNQUdFID0gJ0lNQUdFJyxcbn1cbiJdLCJuYW1lcyI6WyJSb3V0ZUtpbmQiXSwibWFwcGluZ3MiOiI7OztBQUFPLElBQVdBLFlBQUFBLFdBQUFBLEdBQUFBLFNBQUFBLFNBQUFBO0lBQ2hCOztHQUVDLEdBQUEsU0FBQSxDQUFBLFFBQUEsR0FBQTtJQUVEOztHQUVDLEdBQUEsU0FBQSxDQUFBLFlBQUEsR0FBQTtJQUVEOzs7R0FHQyxHQUFBLFNBQUEsQ0FBQSxXQUFBLEdBQUE7SUFFRDs7O0dBR0MsR0FBQSxTQUFBLENBQUEsWUFBQSxHQUFBO0lBR0Q7O0dBRUMsR0FBQSxTQUFBLENBQUEsUUFBQSxHQUFBO1dBdEJlQTtNQXdCakIiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNDgsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NyYy9zZXJ2ZXIvbGliL3RyYWNlL2NvbnN0YW50cy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvbnRhaW5zIHByZWRlZmluZWQgY29uc3RhbnRzIGZvciB0aGUgdHJhY2Ugc3BhbiBuYW1lIGluIG5leHQvc2VydmVyLlxuICpcbiAqIEN1cnJlbnRseSwgbmV4dC9zZXJ2ZXIvdHJhY2VyIGlzIGludGVybmFsIGltcGxlbWVudGF0aW9uIG9ubHkgZm9yIHRyYWNraW5nXG4gKiBuZXh0LmpzJ3MgaW1wbGVtZW50YXRpb24gb25seSB3aXRoIGtub3duIHNwYW4gbmFtZXMgZGVmaW5lZCBoZXJlLlxuICoqL1xuXG4vLyBlc2xpbnQgdHlwZXNjcmlwdCBoYXMgYSBidWcgd2l0aCBUUyBlbnVtc1xuLyogZXNsaW50LWRpc2FibGUgbm8tc2hhZG93ICovXG5cbmVudW0gQmFzZVNlcnZlclNwYW4ge1xuICBoYW5kbGVSZXF1ZXN0ID0gJ0Jhc2VTZXJ2ZXIuaGFuZGxlUmVxdWVzdCcsXG4gIHJ1biA9ICdCYXNlU2VydmVyLnJ1bicsXG4gIHBpcGUgPSAnQmFzZVNlcnZlci5waXBlJyxcbiAgZ2V0U3RhdGljSFRNTCA9ICdCYXNlU2VydmVyLmdldFN0YXRpY0hUTUwnLFxuICByZW5kZXIgPSAnQmFzZVNlcnZlci5yZW5kZXInLFxuICByZW5kZXJUb1Jlc3BvbnNlV2l0aENvbXBvbmVudHMgPSAnQmFzZVNlcnZlci5yZW5kZXJUb1Jlc3BvbnNlV2l0aENvbXBvbmVudHMnLFxuICByZW5kZXJUb1Jlc3BvbnNlID0gJ0Jhc2VTZXJ2ZXIucmVuZGVyVG9SZXNwb25zZScsXG4gIHJlbmRlclRvSFRNTCA9ICdCYXNlU2VydmVyLnJlbmRlclRvSFRNTCcsXG4gIHJlbmRlckVycm9yID0gJ0Jhc2VTZXJ2ZXIucmVuZGVyRXJyb3InLFxuICByZW5kZXJFcnJvclRvUmVzcG9uc2UgPSAnQmFzZVNlcnZlci5yZW5kZXJFcnJvclRvUmVzcG9uc2UnLFxuICByZW5kZXJFcnJvclRvSFRNTCA9ICdCYXNlU2VydmVyLnJlbmRlckVycm9yVG9IVE1MJyxcbiAgcmVuZGVyNDA0ID0gJ0Jhc2VTZXJ2ZXIucmVuZGVyNDA0Jyxcbn1cblxuZW51bSBMb2FkQ29tcG9uZW50c1NwYW4ge1xuICBsb2FkRGVmYXVsdEVycm9yQ29tcG9uZW50cyA9ICdMb2FkQ29tcG9uZW50cy5sb2FkRGVmYXVsdEVycm9yQ29tcG9uZW50cycsXG4gIGxvYWRDb21wb25lbnRzID0gJ0xvYWRDb21wb25lbnRzLmxvYWRDb21wb25lbnRzJyxcbn1cblxuZW51bSBOZXh0U2VydmVyU3BhbiB7XG4gIGdldFJlcXVlc3RIYW5kbGVyID0gJ05leHRTZXJ2ZXIuZ2V0UmVxdWVzdEhhbmRsZXInLFxuICBnZXRTZXJ2ZXIgPSAnTmV4dFNlcnZlci5nZXRTZXJ2ZXInLFxuICBnZXRTZXJ2ZXJSZXF1ZXN0SGFuZGxlciA9ICdOZXh0U2VydmVyLmdldFNlcnZlclJlcXVlc3RIYW5kbGVyJyxcbiAgY3JlYXRlU2VydmVyID0gJ2NyZWF0ZVNlcnZlci5jcmVhdGVTZXJ2ZXInLFxufVxuXG5lbnVtIE5leHROb2RlU2VydmVyU3BhbiB7XG4gIGNvbXByZXNzaW9uID0gJ05leHROb2RlU2VydmVyLmNvbXByZXNzaW9uJyxcbiAgZ2V0QnVpbGRJZCA9ICdOZXh0Tm9kZVNlcnZlci5nZXRCdWlsZElkJyxcbiAgY3JlYXRlQ29tcG9uZW50VHJlZSA9ICdOZXh0Tm9kZVNlcnZlci5jcmVhdGVDb21wb25lbnRUcmVlJyxcbiAgY2xpZW50Q29tcG9uZW50TG9hZGluZyA9ICdOZXh0Tm9kZVNlcnZlci5jbGllbnRDb21wb25lbnRMb2FkaW5nJyxcbiAgZ2V0TGF5b3V0T3JQYWdlTW9kdWxlID0gJ05leHROb2RlU2VydmVyLmdldExheW91dE9yUGFnZU1vZHVsZScsXG4gIGdlbmVyYXRlU3RhdGljUm91dGVzID0gJ05leHROb2RlU2VydmVyLmdlbmVyYXRlU3RhdGljUm91dGVzJyxcbiAgZ2VuZXJhdGVGc1N0YXRpY1JvdXRlcyA9ICdOZXh0Tm9kZVNlcnZlci5nZW5lcmF0ZUZzU3RhdGljUm91dGVzJyxcbiAgZ2VuZXJhdGVQdWJsaWNSb3V0ZXMgPSAnTmV4dE5vZGVTZXJ2ZXIuZ2VuZXJhdGVQdWJsaWNSb3V0ZXMnLFxuICBnZW5lcmF0ZUltYWdlUm91dGVzID0gJ05leHROb2RlU2VydmVyLmdlbmVyYXRlSW1hZ2VSb3V0ZXMucm91dGUnLFxuICBzZW5kUmVuZGVyUmVzdWx0ID0gJ05leHROb2RlU2VydmVyLnNlbmRSZW5kZXJSZXN1bHQnLFxuICBwcm94eVJlcXVlc3QgPSAnTmV4dE5vZGVTZXJ2ZXIucHJveHlSZXF1ZXN0JyxcbiAgcnVuQXBpID0gJ05leHROb2RlU2VydmVyLnJ1bkFwaScsXG4gIHJlbmRlciA9ICdOZXh0Tm9kZVNlcnZlci5yZW5kZXInLFxuICByZW5kZXJIVE1MID0gJ05leHROb2RlU2VydmVyLnJlbmRlckhUTUwnLFxuICBpbWFnZU9wdGltaXplciA9ICdOZXh0Tm9kZVNlcnZlci5pbWFnZU9wdGltaXplcicsXG4gIGdldFBhZ2VQYXRoID0gJ05leHROb2RlU2VydmVyLmdldFBhZ2VQYXRoJyxcbiAgZ2V0Um91dGVzTWFuaWZlc3QgPSAnTmV4dE5vZGVTZXJ2ZXIuZ2V0Um91dGVzTWFuaWZlc3QnLFxuICBmaW5kUGFnZUNvbXBvbmVudHMgPSAnTmV4dE5vZGVTZXJ2ZXIuZmluZFBhZ2VDb21wb25lbnRzJyxcbiAgZ2V0Rm9udE1hbmlmZXN0ID0gJ05leHROb2RlU2VydmVyLmdldEZvbnRNYW5pZmVzdCcsXG4gIGdldFNlcnZlckNvbXBvbmVudE1hbmlmZXN0ID0gJ05leHROb2RlU2VydmVyLmdldFNlcnZlckNvbXBvbmVudE1hbmlmZXN0JyxcbiAgZ2V0UmVxdWVzdEhhbmRsZXIgPSAnTmV4dE5vZGVTZXJ2ZXIuZ2V0UmVxdWVzdEhhbmRsZXInLFxuICByZW5kZXJUb0hUTUwgPSAnTmV4dE5vZGVTZXJ2ZXIucmVuZGVyVG9IVE1MJyxcbiAgcmVuZGVyRXJyb3IgPSAnTmV4dE5vZGVTZXJ2ZXIucmVuZGVyRXJyb3InLFxuICByZW5kZXJFcnJvclRvSFRNTCA9ICdOZXh0Tm9kZVNlcnZlci5yZW5kZXJFcnJvclRvSFRNTCcsXG4gIHJlbmRlcjQwNCA9ICdOZXh0Tm9kZVNlcnZlci5yZW5kZXI0MDQnLFxuICBzdGFydFJlc3BvbnNlID0gJ05leHROb2RlU2VydmVyLnN0YXJ0UmVzcG9uc2UnLFxuXG4gIC8vIG5lc3RlZCBpbm5lciBzcGFuLCBkb2VzIG5vdCByZXF1aXJlIHBhcmVudCBzY29wZSBuYW1lXG4gIHJvdXRlID0gJ3JvdXRlJyxcbiAgb25Qcm94eVJlcSA9ICdvblByb3h5UmVxJyxcbiAgYXBpUmVzb2x2ZXIgPSAnYXBpUmVzb2x2ZXInLFxuICBpbnRlcm5hbEZldGNoID0gJ2ludGVybmFsRmV0Y2gnLFxufVxuXG5lbnVtIFN0YXJ0U2VydmVyU3BhbiB7XG4gIHN0YXJ0U2VydmVyID0gJ3N0YXJ0U2VydmVyLnN0YXJ0U2VydmVyJyxcbn1cblxuZW51bSBSZW5kZXJTcGFuIHtcbiAgZ2V0U2VydmVyU2lkZVByb3BzID0gJ1JlbmRlci5nZXRTZXJ2ZXJTaWRlUHJvcHMnLFxuICBnZXRTdGF0aWNQcm9wcyA9ICdSZW5kZXIuZ2V0U3RhdGljUHJvcHMnLFxuICByZW5kZXJUb1N0cmluZyA9ICdSZW5kZXIucmVuZGVyVG9TdHJpbmcnLFxuICByZW5kZXJEb2N1bWVudCA9ICdSZW5kZXIucmVuZGVyRG9jdW1lbnQnLFxuICBjcmVhdGVCb2R5UmVzdWx0ID0gJ1JlbmRlci5jcmVhdGVCb2R5UmVzdWx0Jyxcbn1cblxuZW51bSBBcHBSZW5kZXJTcGFuIHtcbiAgcmVuZGVyVG9TdHJpbmcgPSAnQXBwUmVuZGVyLnJlbmRlclRvU3RyaW5nJyxcbiAgcmVuZGVyVG9SZWFkYWJsZVN0cmVhbSA9ICdBcHBSZW5kZXIucmVuZGVyVG9SZWFkYWJsZVN0cmVhbScsXG4gIGdldEJvZHlSZXN1bHQgPSAnQXBwUmVuZGVyLmdldEJvZHlSZXN1bHQnLFxuICBmZXRjaCA9ICdBcHBSZW5kZXIuZmV0Y2gnLFxufVxuXG5lbnVtIFJvdXRlclNwYW4ge1xuICBleGVjdXRlUm91dGUgPSAnUm91dGVyLmV4ZWN1dGVSb3V0ZScsXG59XG5cbmVudW0gTm9kZVNwYW4ge1xuICBydW5IYW5kbGVyID0gJ05vZGUucnVuSGFuZGxlcicsXG59XG5cbmVudW0gQXBwUm91dGVSb3V0ZUhhbmRsZXJzU3BhbiB7XG4gIHJ1bkhhbmRsZXIgPSAnQXBwUm91dGVSb3V0ZUhhbmRsZXJzLnJ1bkhhbmRsZXInLFxufVxuXG5lbnVtIFJlc29sdmVNZXRhZGF0YVNwYW4ge1xuICBnZW5lcmF0ZU1ldGFkYXRhID0gJ1Jlc29sdmVNZXRhZGF0YS5nZW5lcmF0ZU1ldGFkYXRhJyxcbiAgZ2VuZXJhdGVWaWV3cG9ydCA9ICdSZXNvbHZlTWV0YWRhdGEuZ2VuZXJhdGVWaWV3cG9ydCcsXG59XG5cbmVudW0gTWlkZGxld2FyZVNwYW4ge1xuICBleGVjdXRlID0gJ01pZGRsZXdhcmUuZXhlY3V0ZScsXG59XG5cbnR5cGUgU3BhblR5cGVzID1cbiAgfCBgJHtCYXNlU2VydmVyU3Bhbn1gXG4gIHwgYCR7TG9hZENvbXBvbmVudHNTcGFufWBcbiAgfCBgJHtOZXh0U2VydmVyU3Bhbn1gXG4gIHwgYCR7U3RhcnRTZXJ2ZXJTcGFufWBcbiAgfCBgJHtOZXh0Tm9kZVNlcnZlclNwYW59YFxuICB8IGAke1JlbmRlclNwYW59YFxuICB8IGAke1JvdXRlclNwYW59YFxuICB8IGAke0FwcFJlbmRlclNwYW59YFxuICB8IGAke05vZGVTcGFufWBcbiAgfCBgJHtBcHBSb3V0ZVJvdXRlSGFuZGxlcnNTcGFufWBcbiAgfCBgJHtSZXNvbHZlTWV0YWRhdGFTcGFufWBcbiAgfCBgJHtNaWRkbGV3YXJlU3Bhbn1gXG5cbi8vIFRoaXMgbGlzdCBpcyB1c2VkIHRvIGZpbHRlciBvdXQgc3BhbnMgdGhhdCBhcmUgbm90IHJlbGV2YW50IHRvIHRoZSB1c2VyXG5leHBvcnQgY29uc3QgTmV4dFZhbmlsbGFTcGFuQWxsb3dsaXN0ID0gW1xuICBNaWRkbGV3YXJlU3Bhbi5leGVjdXRlLFxuICBCYXNlU2VydmVyU3Bhbi5oYW5kbGVSZXF1ZXN0LFxuICBSZW5kZXJTcGFuLmdldFNlcnZlclNpZGVQcm9wcyxcbiAgUmVuZGVyU3Bhbi5nZXRTdGF0aWNQcm9wcyxcbiAgQXBwUmVuZGVyU3Bhbi5mZXRjaCxcbiAgQXBwUmVuZGVyU3Bhbi5nZXRCb2R5UmVzdWx0LFxuICBSZW5kZXJTcGFuLnJlbmRlckRvY3VtZW50LFxuICBOb2RlU3Bhbi5ydW5IYW5kbGVyLFxuICBBcHBSb3V0ZVJvdXRlSGFuZGxlcnNTcGFuLnJ1bkhhbmRsZXIsXG4gIFJlc29sdmVNZXRhZGF0YVNwYW4uZ2VuZXJhdGVNZXRhZGF0YSxcbiAgUmVzb2x2ZU1ldGFkYXRhU3Bhbi5nZW5lcmF0ZVZpZXdwb3J0LFxuICBOZXh0Tm9kZVNlcnZlclNwYW4uY3JlYXRlQ29tcG9uZW50VHJlZSxcbiAgTmV4dE5vZGVTZXJ2ZXJTcGFuLmZpbmRQYWdlQ29tcG9uZW50cyxcbiAgTmV4dE5vZGVTZXJ2ZXJTcGFuLmdldExheW91dE9yUGFnZU1vZHVsZSxcbiAgTmV4dE5vZGVTZXJ2ZXJTcGFuLnN0YXJ0UmVzcG9uc2UsXG4gIE5leHROb2RlU2VydmVyU3Bhbi5jbGllbnRDb21wb25lbnRMb2FkaW5nLFxuXVxuXG4vLyBUaGVzZSBTcGFucyBhcmUgYWxsb3dlZCB0byBiZSBhbHdheXMgbG9nZ2VkXG4vLyB3aGVuIHRoZSBvdGVsIGxvZyBwcmVmaXggZW52IGlzIHNldFxuZXhwb3J0IGNvbnN0IExvZ1NwYW5BbGxvd0xpc3QgPSBbXG4gIE5leHROb2RlU2VydmVyU3Bhbi5maW5kUGFnZUNvbXBvbmVudHMsXG4gIE5leHROb2RlU2VydmVyU3Bhbi5jcmVhdGVDb21wb25lbnRUcmVlLFxuICBOZXh0Tm9kZVNlcnZlclNwYW4uY2xpZW50Q29tcG9uZW50TG9hZGluZyxcbl1cblxuZXhwb3J0IHtcbiAgQmFzZVNlcnZlclNwYW4sXG4gIExvYWRDb21wb25lbnRzU3BhbixcbiAgTmV4dFNlcnZlclNwYW4sXG4gIE5leHROb2RlU2VydmVyU3BhbixcbiAgU3RhcnRTZXJ2ZXJTcGFuLFxuICBSZW5kZXJTcGFuLFxuICBSb3V0ZXJTcGFuLFxuICBBcHBSZW5kZXJTcGFuLFxuICBOb2RlU3BhbixcbiAgQXBwUm91dGVSb3V0ZUhhbmRsZXJzU3BhbixcbiAgUmVzb2x2ZU1ldGFkYXRhU3BhbixcbiAgTWlkZGxld2FyZVNwYW4sXG59XG5cbmV4cG9ydCB0eXBlIHsgU3BhblR5cGVzIH1cbiJdLCJuYW1lcyI6WyJCYXNlU2VydmVyU3BhbiIsIkxvYWRDb21wb25lbnRzU3BhbiIsIk5leHRTZXJ2ZXJTcGFuIiwiTmV4dE5vZGVTZXJ2ZXJTcGFuIiwiU3RhcnRTZXJ2ZXJTcGFuIiwiUmVuZGVyU3BhbiIsIkFwcFJlbmRlclNwYW4iLCJSb3V0ZXJTcGFuIiwiTm9kZVNwYW4iLCJBcHBSb3V0ZVJvdXRlSGFuZGxlcnNTcGFuIiwiUmVzb2x2ZU1ldGFkYXRhU3BhbiIsIk1pZGRsZXdhcmVTcGFuIiwiTmV4dFZhbmlsbGFTcGFuQWxsb3dsaXN0IiwiTG9nU3BhbkFsbG93TGlzdCJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7O0VBS0UsR0FFRiw0Q0FBNEM7QUFDNUMsNEJBQTRCOzs7Ozs7Ozs7Ozs7Ozs7O0FBRTVCLElBQUtBLGlCQUFBQSxXQUFBQSxHQUFBQSxTQUFBQSxjQUFBQTs7Ozs7Ozs7Ozs7OztXQUFBQTtFQUFBQSxrQkFBQUEsQ0FBQUE7QUFlTCxJQUFLQyxxQkFBQUEsV0FBQUEsR0FBQUEsU0FBQUEsa0JBQUFBOzs7V0FBQUE7RUFBQUEsc0JBQUFBLENBQUFBO0FBS0wsSUFBS0MsaUJBQUFBLFdBQUFBLEdBQUFBLFNBQUFBLGNBQUFBOzs7OztXQUFBQTtFQUFBQSxrQkFBQUEsQ0FBQUE7QUFPTCxJQUFLQyxxQkFBQUEsV0FBQUEsR0FBQUEsU0FBQUEsa0JBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUE0Qkgsd0RBQXdEOzs7OztXQTVCckRBO0VBQUFBLHNCQUFBQSxDQUFBQTtBQW1DTCxJQUFLQyxrQkFBQUEsV0FBQUEsR0FBQUEsU0FBQUEsZUFBQUE7O1dBQUFBO0VBQUFBLG1CQUFBQSxDQUFBQTtBQUlMLElBQUtDLGFBQUFBLFdBQUFBLEdBQUFBLFNBQUFBLFVBQUFBOzs7Ozs7V0FBQUE7RUFBQUEsY0FBQUEsQ0FBQUE7QUFRTCxJQUFLQyxnQkFBQUEsV0FBQUEsR0FBQUEsU0FBQUEsYUFBQUE7Ozs7O1dBQUFBO0VBQUFBLGlCQUFBQSxDQUFBQTtBQU9MLElBQUtDLGFBQUFBLFdBQUFBLEdBQUFBLFNBQUFBLFVBQUFBOztXQUFBQTtFQUFBQSxjQUFBQSxDQUFBQTtBQUlMLElBQUtDLFdBQUFBLFdBQUFBLEdBQUFBLFNBQUFBLFFBQUFBOztXQUFBQTtFQUFBQSxZQUFBQSxDQUFBQTtBQUlMLElBQUtDLDRCQUFBQSxXQUFBQSxHQUFBQSxTQUFBQSx5QkFBQUE7O1dBQUFBO0VBQUFBLDZCQUFBQSxDQUFBQTtBQUlMLElBQUtDLHNCQUFBQSxXQUFBQSxHQUFBQSxTQUFBQSxtQkFBQUE7OztXQUFBQTtFQUFBQSx1QkFBQUEsQ0FBQUE7QUFLTCxJQUFLQyxpQkFBQUEsV0FBQUEsR0FBQUEsU0FBQUEsY0FBQUE7O1dBQUFBO0VBQUFBLGtCQUFBQSxDQUFBQTtBQW1CRSxNQUFNQywyQkFBMkI7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBaUJ2QyxDQUFBO0FBSU0sTUFBTUMsbUJBQW1COzs7O0NBSS9CLENBQUEiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMjAwLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zcmMvc2hhcmVkL2xpYi9pcy10aGVuYWJsZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENoZWNrIHRvIHNlZSBpZiBhIHZhbHVlIGlzIFRoZW5hYmxlLlxuICpcbiAqIEBwYXJhbSBwcm9taXNlIHRoZSBtYXliZS10aGVuYWJsZSB2YWx1ZVxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgdmFsdWUgaXMgdGhlbmFibGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVGhlbmFibGU8VCA9IHVua25vd24+KFxuICBwcm9taXNlOiBQcm9taXNlPFQ+IHwgVFxuKTogcHJvbWlzZSBpcyBQcm9taXNlPFQ+IHtcbiAgcmV0dXJuIChcbiAgICBwcm9taXNlICE9PSBudWxsICYmXG4gICAgdHlwZW9mIHByb21pc2UgPT09ICdvYmplY3QnICYmXG4gICAgJ3RoZW4nIGluIHByb21pc2UgJiZcbiAgICB0eXBlb2YgcHJvbWlzZS50aGVuID09PSAnZnVuY3Rpb24nXG4gIClcbn1cbiJdLCJuYW1lcyI6WyJpc1RoZW5hYmxlIiwicHJvbWlzZSIsInRoZW4iXSwibWFwcGluZ3MiOiJBQUFBOzs7OztDQUtDLEdBQ0Q7OztBQUFPLFNBQVNBLFdBQ2RDLE9BQXVCO0lBRXZCLE9BQ0VBLFlBQVksUUFDWixPQUFPQSxZQUFZLFlBQ25CLFVBQVVBLFdBQ1YsT0FBT0EsUUFBUUMsSUFBSSxLQUFLO0FBRTVCIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDIxNSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL3NlcnZlci9saWIvdHJhY2UvdHJhY2VyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgRmV0Y2hFdmVudFJlc3VsdCB9IGZyb20gJy4uLy4uL3dlYi90eXBlcydcbmltcG9ydCB0eXBlIHsgVGV4dE1hcFNldHRlciB9IGZyb20gJ0BvcGVudGVsZW1ldHJ5L2FwaSdcbmltcG9ydCB0eXBlIHsgU3BhblR5cGVzIH0gZnJvbSAnLi9jb25zdGFudHMnXG5pbXBvcnQgeyBMb2dTcGFuQWxsb3dMaXN0LCBOZXh0VmFuaWxsYVNwYW5BbGxvd2xpc3QgfSBmcm9tICcuL2NvbnN0YW50cydcblxuaW1wb3J0IHR5cGUge1xuICBDb250ZXh0QVBJLFxuICBTcGFuLFxuICBTcGFuT3B0aW9ucyxcbiAgVHJhY2VyLFxuICBBdHRyaWJ1dGVWYWx1ZSxcbiAgVGV4dE1hcEdldHRlcixcbn0gZnJvbSAnbmV4dC9kaXN0L2NvbXBpbGVkL0BvcGVudGVsZW1ldHJ5L2FwaSdcbmltcG9ydCB7IGlzVGhlbmFibGUgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvbGliL2lzLXRoZW5hYmxlJ1xuXG5sZXQgYXBpOiB0eXBlb2YgaW1wb3J0KCduZXh0L2Rpc3QvY29tcGlsZWQvQG9wZW50ZWxlbWV0cnkvYXBpJylcblxuLy8gd2Ugd2FudCB0byBhbGxvdyB1c2VycyB0byB1c2UgdGhlaXIgb3duIHZlcnNpb24gb2YgQG9wZW50ZWxlbWV0cnkvYXBpIGlmIHRoZXlcbi8vIHdhbnQgdG8sIHNvIHdlIHRyeSB0byByZXF1aXJlIGl0IGZpcnN0LCBhbmQgaWYgaXQgZmFpbHMgd2UgZmFsbCBiYWNrIHRvIHRoZVxuLy8gdmVyc2lvbiB0aGF0IGlzIGJ1bmRsZWQgd2l0aCBOZXh0LmpzXG4vLyB0aGlzIGlzIGJlY2F1c2UgQG9wZW50ZWxlbWV0cnkvYXBpIGhhcyB0byBiZSBzeW5jZWQgd2l0aCB0aGUgdmVyc2lvbiBvZlxuLy8gQG9wZW50ZWxlbWV0cnkvdHJhY2luZyB0aGF0IGlzIHVzZWQsIGFuZCB3ZSBkb24ndCB3YW50IHRvIGZvcmNlIHVzZXJzIHRvIHVzZVxuLy8gdGhlIHZlcnNpb24gdGhhdCBpcyBidW5kbGVkIHdpdGggTmV4dC5qcy5cbi8vIHRoZSBBUEkgaXMgfnN0YWJsZSwgc28gdGhpcyBzaG91bGQgYmUgZmluZVxuaWYgKHByb2Nlc3MuZW52Lk5FWFRfUlVOVElNRSA9PT0gJ2VkZ2UnKSB7XG4gIGFwaSA9IHJlcXVpcmUoJ0BvcGVudGVsZW1ldHJ5L2FwaScpIGFzIHR5cGVvZiBpbXBvcnQoJ0BvcGVudGVsZW1ldHJ5L2FwaScpXG59IGVsc2Uge1xuICB0cnkge1xuICAgIGFwaSA9IHJlcXVpcmUoJ0BvcGVudGVsZW1ldHJ5L2FwaScpIGFzIHR5cGVvZiBpbXBvcnQoJ0BvcGVudGVsZW1ldHJ5L2FwaScpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGFwaSA9XG4gICAgICByZXF1aXJlKCduZXh0L2Rpc3QvY29tcGlsZWQvQG9wZW50ZWxlbWV0cnkvYXBpJykgYXMgdHlwZW9mIGltcG9ydCgnbmV4dC9kaXN0L2NvbXBpbGVkL0BvcGVudGVsZW1ldHJ5L2FwaScpXG4gIH1cbn1cblxuY29uc3QgeyBjb250ZXh0LCBwcm9wYWdhdGlvbiwgdHJhY2UsIFNwYW5TdGF0dXNDb2RlLCBTcGFuS2luZCwgUk9PVF9DT05URVhUIH0gPVxuICBhcGlcblxuZXhwb3J0IGNsYXNzIEJ1YmJsZWRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIHJlYWRvbmx5IGJ1YmJsZT86IGJvb2xlYW4sXG4gICAgcHVibGljIHJlYWRvbmx5IHJlc3VsdD86IEZldGNoRXZlbnRSZXN1bHRcbiAgKSB7XG4gICAgc3VwZXIoKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0J1YmJsZWRFcnJvcihlcnJvcjogdW5rbm93bik6IGVycm9yIGlzIEJ1YmJsZWRFcnJvciB7XG4gIGlmICh0eXBlb2YgZXJyb3IgIT09ICdvYmplY3QnIHx8IGVycm9yID09PSBudWxsKSByZXR1cm4gZmFsc2VcbiAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgQnViYmxlZEVycm9yXG59XG5cbmNvbnN0IGNsb3NlU3BhbldpdGhFcnJvciA9IChzcGFuOiBTcGFuLCBlcnJvcj86IEVycm9yKSA9PiB7XG4gIGlmIChpc0J1YmJsZWRFcnJvcihlcnJvcikgJiYgZXJyb3IuYnViYmxlKSB7XG4gICAgc3Bhbi5zZXRBdHRyaWJ1dGUoJ25leHQuYnViYmxlJywgdHJ1ZSlcbiAgfSBlbHNlIHtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHNwYW4ucmVjb3JkRXhjZXB0aW9uKGVycm9yKVxuICAgIH1cbiAgICBzcGFuLnNldFN0YXR1cyh7IGNvZGU6IFNwYW5TdGF0dXNDb2RlLkVSUk9SLCBtZXNzYWdlOiBlcnJvcj8ubWVzc2FnZSB9KVxuICB9XG4gIHNwYW4uZW5kKClcbn1cblxudHlwZSBUcmFjZXJTcGFuT3B0aW9ucyA9IE9taXQ8U3Bhbk9wdGlvbnMsICdhdHRyaWJ1dGVzJz4gJiB7XG4gIHBhcmVudFNwYW4/OiBTcGFuXG4gIHNwYW5OYW1lPzogc3RyaW5nXG4gIGF0dHJpYnV0ZXM/OiBQYXJ0aWFsPFJlY29yZDxBdHRyaWJ1dGVOYW1lcywgQXR0cmlidXRlVmFsdWUgfCB1bmRlZmluZWQ+PlxuICBoaWRlU3Bhbj86IGJvb2xlYW5cbn1cblxuaW50ZXJmYWNlIE5leHRUcmFjZXIge1xuICBnZXRDb250ZXh0KCk6IENvbnRleHRBUElcblxuICAvKipcbiAgICogSW5zdHJ1bWVudHMgYSBmdW5jdGlvbiBieSBhdXRvbWF0aWNhbGx5IGNyZWF0aW5nIGEgc3BhbiBhY3RpdmF0ZWQgb24gaXRzXG4gICAqIHNjb3BlLlxuICAgKlxuICAgKiBUaGUgc3BhbiB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgZmluaXNoZWQgd2hlbiBvbmUgb2YgdGhlc2UgY29uZGl0aW9ucyBpc1xuICAgKiBtZXQ6XG4gICAqXG4gICAqICogVGhlIGZ1bmN0aW9uIHJldHVybnMgYSBwcm9taXNlLCBpbiB3aGljaCBjYXNlIHRoZSBzcGFuIHdpbGwgZmluaXNoIHdoZW5cbiAgICogdGhlIHByb21pc2UgaXMgcmVzb2x2ZWQgb3IgcmVqZWN0ZWQuXG4gICAqICogVGhlIGZ1bmN0aW9uIHRha2VzIGEgY2FsbGJhY2sgYXMgaXRzIHNlY29uZCBwYXJhbWV0ZXIsIGluIHdoaWNoIGNhc2UgdGhlXG4gICAqIHNwYW4gd2lsbCBmaW5pc2ggd2hlbiB0aGF0IGNhbGxiYWNrIGlzIGNhbGxlZC5cbiAgICogKiBUaGUgZnVuY3Rpb24gZG9lc24ndCBhY2NlcHQgYSBjYWxsYmFjayBhbmQgZG9lc24ndCByZXR1cm4gYSBwcm9taXNlLCBpblxuICAgKiB3aGljaCBjYXNlIHRoZSBzcGFuIHdpbGwgZmluaXNoIGF0IHRoZSBlbmQgb2YgdGhlIGZ1bmN0aW9uIGV4ZWN1dGlvbi5cbiAgICpcbiAgICovXG4gIHRyYWNlPFQ+KFxuICAgIHR5cGU6IFNwYW5UeXBlcyxcbiAgICBmbjogKHNwYW4/OiBTcGFuLCBkb25lPzogKGVycm9yPzogRXJyb3IpID0+IGFueSkgPT4gUHJvbWlzZTxUPlxuICApOiBQcm9taXNlPFQ+XG4gIHRyYWNlPFQ+KFxuICAgIHR5cGU6IFNwYW5UeXBlcyxcbiAgICBmbjogKHNwYW4/OiBTcGFuLCBkb25lPzogKGVycm9yPzogRXJyb3IpID0+IGFueSkgPT4gVFxuICApOiBUXG4gIHRyYWNlPFQ+KFxuICAgIHR5cGU6IFNwYW5UeXBlcyxcbiAgICBvcHRpb25zOiBUcmFjZXJTcGFuT3B0aW9ucyxcbiAgICBmbjogKHNwYW4/OiBTcGFuLCBkb25lPzogKGVycm9yPzogRXJyb3IpID0+IGFueSkgPT4gUHJvbWlzZTxUPlxuICApOiBQcm9taXNlPFQ+XG4gIHRyYWNlPFQ+KFxuICAgIHR5cGU6IFNwYW5UeXBlcyxcbiAgICBvcHRpb25zOiBUcmFjZXJTcGFuT3B0aW9ucyxcbiAgICBmbjogKHNwYW4/OiBTcGFuLCBkb25lPzogKGVycm9yPzogRXJyb3IpID0+IGFueSkgPT4gVFxuICApOiBUXG5cbiAgLyoqXG4gICAqIFdyYXAgYSBmdW5jdGlvbiB0byBhdXRvbWF0aWNhbGx5IGNyZWF0ZSBhIHNwYW4gYWN0aXZhdGVkIG9uIGl0c1xuICAgKiBzY29wZSB3aGVuIGl0J3MgY2FsbGVkLlxuICAgKlxuICAgKiBUaGUgc3BhbiB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgZmluaXNoZWQgd2hlbiBvbmUgb2YgdGhlc2UgY29uZGl0aW9ucyBpc1xuICAgKiBtZXQ6XG4gICAqXG4gICAqICogVGhlIGZ1bmN0aW9uIHJldHVybnMgYSBwcm9taXNlLCBpbiB3aGljaCBjYXNlIHRoZSBzcGFuIHdpbGwgZmluaXNoIHdoZW5cbiAgICogdGhlIHByb21pc2UgaXMgcmVzb2x2ZWQgb3IgcmVqZWN0ZWQuXG4gICAqICogVGhlIGZ1bmN0aW9uIHRha2VzIGEgY2FsbGJhY2sgYXMgaXRzIGxhc3QgcGFyYW1ldGVyLCBpbiB3aGljaCBjYXNlIHRoZVxuICAgKiBzcGFuIHdpbGwgZmluaXNoIHdoZW4gdGhhdCBjYWxsYmFjayBpcyBjYWxsZWQuXG4gICAqICogVGhlIGZ1bmN0aW9uIGRvZXNuJ3QgYWNjZXB0IGEgY2FsbGJhY2sgYW5kIGRvZXNuJ3QgcmV0dXJuIGEgcHJvbWlzZSwgaW5cbiAgICogd2hpY2ggY2FzZSB0aGUgc3BhbiB3aWxsIGZpbmlzaCBhdCB0aGUgZW5kIG9mIHRoZSBmdW5jdGlvbiBleGVjdXRpb24uXG4gICAqL1xuICB3cmFwPFQgPSAoLi4uYXJnczogQXJyYXk8YW55PikgPT4gYW55Pih0eXBlOiBTcGFuVHlwZXMsIGZuOiBUKTogVFxuICB3cmFwPFQgPSAoLi4uYXJnczogQXJyYXk8YW55PikgPT4gYW55PihcbiAgICB0eXBlOiBTcGFuVHlwZXMsXG4gICAgb3B0aW9uczogVHJhY2VyU3Bhbk9wdGlvbnMsXG4gICAgZm46IFRcbiAgKTogVFxuICB3cmFwPFQgPSAoLi4uYXJnczogQXJyYXk8YW55PikgPT4gYW55PihcbiAgICB0eXBlOiBTcGFuVHlwZXMsXG4gICAgb3B0aW9uczogKC4uLmFyZ3M6IGFueVtdKSA9PiBUcmFjZXJTcGFuT3B0aW9ucyxcbiAgICBmbjogVFxuICApOiBUXG5cbiAgLyoqXG4gICAqIFN0YXJ0cyBhbmQgcmV0dXJucyBhIG5ldyBTcGFuIHJlcHJlc2VudGluZyBhIGxvZ2ljYWwgdW5pdCBvZiB3b3JrLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBkbyBOT1QgbW9kaWZ5IHRoZSBjdXJyZW50IENvbnRleHQgYnkgZGVmYXVsdC4gSW4gcmVzdWx0LCBhbnkgaW5uZXIgc3BhbiB3aWxsIG5vdFxuICAgKiBhdXRvbWF0aWNhbGx5IHNldCBpdHMgcGFyZW50IGNvbnRleHQgdG8gdGhlIHNwYW4gY3JlYXRlZCBieSB0aGlzIG1ldGhvZCB1bmxlc3MgbWFudWFsbHkgYWN0aXZhdGVcbiAgICogY29udGV4dCB2aWEgYHRyYWNlci5nZXRDb250ZXh0KCkud2l0aGAuIGB0cmFjZWAsIG9yIGB3cmFwYCBpcyBnZW5lcmFsbHkgcmVjb21tZW5kZWQgYXMgaXQgZ3JhY2VmdWxseVxuICAgKiBoYW5kbGVzIGNvbnRleHQgYWN0aXZhdGlvbi4gKHJlZjogaHR0cHM6Ly9naXRodWIuY29tL29wZW4tdGVsZW1ldHJ5L29wZW50ZWxlbWV0cnktanMvaXNzdWVzLzE5MjMpXG4gICAqL1xuICBzdGFydFNwYW4odHlwZTogU3BhblR5cGVzKTogU3BhblxuICBzdGFydFNwYW4odHlwZTogU3BhblR5cGVzLCBvcHRpb25zOiBUcmFjZXJTcGFuT3B0aW9ucyk6IFNwYW5cblxuICAvKipcbiAgICogUmV0dXJucyBjdXJyZW50bHkgYWN0aXZhdGVkIHNwYW4gaWYgY3VycmVudCBjb250ZXh0IGlzIGluIHRoZSBzY29wZSBvZiB0aGUgc3Bhbi5cbiAgICogUmV0dXJucyB1bmRlZmluZWQgb3RoZXJ3aXNlLlxuICAgKi9cbiAgZ2V0QWN0aXZlU2NvcGVTcGFuKCk6IFNwYW4gfCB1bmRlZmluZWRcblxuICAvKipcbiAgICogUmV0dXJucyB0cmFjZSBwcm9wYWdhdGlvbiBkYXRhIGZvciB0aGUgY3VycmVudGx5IGFjdGl2ZSBjb250ZXh0LiBUaGUgZm9ybWF0IGlzIGVxdWFsIHRvIGRhdGEgcHJvdmlkZWRcbiAgICogdGhyb3VnaCB0aGUgT3BlblRlbGVtZXRyeSBwcm9wYWdhdG9yIEFQSS5cbiAgICovXG4gIGdldFRyYWNlUHJvcGFnYXRpb25EYXRhKCk6IENsaWVudFRyYWNlRGF0YUVudHJ5W11cbn1cblxudHlwZSBOZXh0QXR0cmlidXRlTmFtZXMgPVxuICB8ICduZXh0LnJvdXRlJ1xuICB8ICduZXh0LnBhZ2UnXG4gIHwgJ25leHQucnNjJ1xuICB8ICduZXh0LnNlZ21lbnQnXG4gIHwgJ25leHQuc3Bhbl9uYW1lJ1xuICB8ICduZXh0LnNwYW5fdHlwZSdcbiAgfCAnbmV4dC5jbGllbnRDb21wb25lbnRMb2FkQ291bnQnXG50eXBlIE9URUxBdHRyaWJ1dGVOYW1lcyA9IGBodHRwLiR7c3RyaW5nfWAgfCBgbmV0LiR7c3RyaW5nfWBcbnR5cGUgQXR0cmlidXRlTmFtZXMgPSBOZXh0QXR0cmlidXRlTmFtZXMgfCBPVEVMQXR0cmlidXRlTmFtZXNcblxuLyoqIHdlIHVzZSB0aGlzIG1hcCB0byBwcm9wYWdhdGUgYXR0cmlidXRlcyBmcm9tIG5lc3RlZCBzcGFucyB0byB0aGUgdG9wIHNwYW4gKi9cbmNvbnN0IHJvb3RTcGFuQXR0cmlidXRlc1N0b3JlID0gbmV3IE1hcDxcbiAgbnVtYmVyLFxuICBNYXA8QXR0cmlidXRlTmFtZXMsIEF0dHJpYnV0ZVZhbHVlIHwgdW5kZWZpbmVkPlxuPigpXG5jb25zdCByb290U3BhbklkS2V5ID0gYXBpLmNyZWF0ZUNvbnRleHRLZXkoJ25leHQucm9vdFNwYW5JZCcpXG5sZXQgbGFzdFNwYW5JZCA9IDBcbmNvbnN0IGdldFNwYW5JZCA9ICgpID0+IGxhc3RTcGFuSWQrK1xuXG5leHBvcnQgaW50ZXJmYWNlIENsaWVudFRyYWNlRGF0YUVudHJ5IHtcbiAga2V5OiBzdHJpbmdcbiAgdmFsdWU6IHN0cmluZ1xufVxuXG5jb25zdCBjbGllbnRUcmFjZURhdGFTZXR0ZXI6IFRleHRNYXBTZXR0ZXI8Q2xpZW50VHJhY2VEYXRhRW50cnlbXT4gPSB7XG4gIHNldChjYXJyaWVyLCBrZXksIHZhbHVlKSB7XG4gICAgY2Fycmllci5wdXNoKHtcbiAgICAgIGtleSxcbiAgICAgIHZhbHVlLFxuICAgIH0pXG4gIH0sXG59XG5cbmNsYXNzIE5leHRUcmFjZXJJbXBsIGltcGxlbWVudHMgTmV4dFRyYWNlciB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGluc3RhbmNlIHRvIHRoZSB0cmFjZSB3aXRoIGNvbmZpZ3VyZWQgbmFtZS5cbiAgICogU2luY2Ugd3JhcCAvIHRyYWNlIGNhbiBiZSBkZWZpbmVkIGluIGFueSBwbGFjZSBwcmlvciB0byBhY3R1YWwgdHJhY2Ugc3Vic2NyaWJlciBpbml0aWFsaXphdGlvbixcbiAgICogVGhpcyBzaG91bGQgYmUgbGF6aWx5IGV2YWx1YXRlZC5cbiAgICovXG4gIHByaXZhdGUgZ2V0VHJhY2VySW5zdGFuY2UoKTogVHJhY2VyIHtcbiAgICByZXR1cm4gdHJhY2UuZ2V0VHJhY2VyKCduZXh0LmpzJywgJzAuMC4xJylcbiAgfVxuXG4gIHB1YmxpYyBnZXRDb250ZXh0KCk6IENvbnRleHRBUEkge1xuICAgIHJldHVybiBjb250ZXh0XG4gIH1cblxuICBwdWJsaWMgZ2V0VHJhY2VQcm9wYWdhdGlvbkRhdGEoKTogQ2xpZW50VHJhY2VEYXRhRW50cnlbXSB7XG4gICAgY29uc3QgYWN0aXZlQ29udGV4dCA9IGNvbnRleHQuYWN0aXZlKClcbiAgICBjb25zdCBlbnRyaWVzOiBDbGllbnRUcmFjZURhdGFFbnRyeVtdID0gW11cbiAgICBwcm9wYWdhdGlvbi5pbmplY3QoYWN0aXZlQ29udGV4dCwgZW50cmllcywgY2xpZW50VHJhY2VEYXRhU2V0dGVyKVxuICAgIHJldHVybiBlbnRyaWVzXG4gIH1cblxuICBwdWJsaWMgZ2V0QWN0aXZlU2NvcGVTcGFuKCk6IFNwYW4gfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0cmFjZS5nZXRTcGFuKGNvbnRleHQ/LmFjdGl2ZSgpKVxuICB9XG5cbiAgcHVibGljIHdpdGhQcm9wYWdhdGVkQ29udGV4dDxULCBDPihcbiAgICBjYXJyaWVyOiBDLFxuICAgIGZuOiAoKSA9PiBULFxuICAgIGdldHRlcj86IFRleHRNYXBHZXR0ZXI8Qz5cbiAgKTogVCB7XG4gICAgY29uc3QgYWN0aXZlQ29udGV4dCA9IGNvbnRleHQuYWN0aXZlKClcbiAgICBpZiAodHJhY2UuZ2V0U3BhbkNvbnRleHQoYWN0aXZlQ29udGV4dCkpIHtcbiAgICAgIC8vIEFjdGl2ZSBzcGFuIGlzIGFscmVhZHkgc2V0LCB0b28gbGF0ZSB0byBwcm9wYWdhdGUuXG4gICAgICByZXR1cm4gZm4oKVxuICAgIH1cbiAgICBjb25zdCByZW1vdGVDb250ZXh0ID0gcHJvcGFnYXRpb24uZXh0cmFjdChhY3RpdmVDb250ZXh0LCBjYXJyaWVyLCBnZXR0ZXIpXG4gICAgcmV0dXJuIGNvbnRleHQud2l0aChyZW1vdGVDb250ZXh0LCBmbilcbiAgfVxuXG4gIC8vIFRyYWNlLCB3cmFwIGltcGxlbWVudGF0aW9uIGlzIGluc3BpcmVkIGJ5IGRhdGFkb2cgdHJhY2UgaW1wbGVtZW50YXRpb25cbiAgLy8gKGh0dHBzOi8vZGF0YWRvZ2hxLmRldi9kZC10cmFjZS1qcy9pbnRlcmZhY2VzL3RyYWNlci5odG1sI3RyYWNlKS5cbiAgcHVibGljIHRyYWNlPFQ+KFxuICAgIHR5cGU6IFNwYW5UeXBlcyxcbiAgICBmbjogKHNwYW4/OiBTcGFuLCBkb25lPzogKGVycm9yPzogRXJyb3IpID0+IGFueSkgPT4gUHJvbWlzZTxUPlxuICApOiBQcm9taXNlPFQ+XG4gIHB1YmxpYyB0cmFjZTxUPihcbiAgICB0eXBlOiBTcGFuVHlwZXMsXG4gICAgZm46IChzcGFuPzogU3BhbiwgZG9uZT86IChlcnJvcj86IEVycm9yKSA9PiBhbnkpID0+IFRcbiAgKTogVFxuICBwdWJsaWMgdHJhY2U8VD4oXG4gICAgdHlwZTogU3BhblR5cGVzLFxuICAgIG9wdGlvbnM6IFRyYWNlclNwYW5PcHRpb25zLFxuICAgIGZuOiAoc3Bhbj86IFNwYW4sIGRvbmU/OiAoZXJyb3I/OiBFcnJvcikgPT4gYW55KSA9PiBQcm9taXNlPFQ+XG4gICk6IFByb21pc2U8VD5cbiAgcHVibGljIHRyYWNlPFQ+KFxuICAgIHR5cGU6IFNwYW5UeXBlcyxcbiAgICBvcHRpb25zOiBUcmFjZXJTcGFuT3B0aW9ucyxcbiAgICBmbjogKHNwYW4/OiBTcGFuLCBkb25lPzogKGVycm9yPzogRXJyb3IpID0+IGFueSkgPT4gVFxuICApOiBUXG4gIHB1YmxpYyB0cmFjZTxUPiguLi5hcmdzOiBBcnJheTxhbnk+KSB7XG4gICAgY29uc3QgW3R5cGUsIGZuT3JPcHRpb25zLCBmbk9yRW1wdHldID0gYXJnc1xuXG4gICAgLy8gY29lcmNlIG9wdGlvbnMgZm9ybSBvdmVybG9hZFxuICAgIGNvbnN0IHtcbiAgICAgIGZuLFxuICAgICAgb3B0aW9ucyxcbiAgICB9OiB7XG4gICAgICBmbjogKHNwYW4/OiBTcGFuLCBkb25lPzogKGVycm9yPzogRXJyb3IpID0+IGFueSkgPT4gVCB8IFByb21pc2U8VD5cbiAgICAgIG9wdGlvbnM6IFRyYWNlclNwYW5PcHRpb25zXG4gICAgfSA9XG4gICAgICB0eXBlb2YgZm5Pck9wdGlvbnMgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyB7XG4gICAgICAgICAgICBmbjogZm5Pck9wdGlvbnMsXG4gICAgICAgICAgICBvcHRpb25zOiB7fSxcbiAgICAgICAgICB9XG4gICAgICAgIDoge1xuICAgICAgICAgICAgZm46IGZuT3JFbXB0eSxcbiAgICAgICAgICAgIG9wdGlvbnM6IHsgLi4uZm5Pck9wdGlvbnMgfSxcbiAgICAgICAgICB9XG5cbiAgICBjb25zdCBzcGFuTmFtZSA9IG9wdGlvbnMuc3Bhbk5hbWUgPz8gdHlwZVxuXG4gICAgaWYgKFxuICAgICAgKCFOZXh0VmFuaWxsYVNwYW5BbGxvd2xpc3QuaW5jbHVkZXModHlwZSkgJiZcbiAgICAgICAgcHJvY2Vzcy5lbnYuTkVYVF9PVEVMX1ZFUkJPU0UgIT09ICcxJykgfHxcbiAgICAgIG9wdGlvbnMuaGlkZVNwYW5cbiAgICApIHtcbiAgICAgIHJldHVybiBmbigpXG4gICAgfVxuXG4gICAgLy8gVHJ5aW5nIHRvIGdldCBhY3RpdmUgc2NvcGVkIHNwYW4gdG8gYXNzaWduIHBhcmVudC4gSWYgb3B0aW9uIHNwZWNpZmllcyBwYXJlbnQgc3BhbiBtYW51YWxseSwgd2lsbCB0cnkgdG8gdXNlIGl0LlxuICAgIGxldCBzcGFuQ29udGV4dCA9IHRoaXMuZ2V0U3BhbkNvbnRleHQoXG4gICAgICBvcHRpb25zPy5wYXJlbnRTcGFuID8/IHRoaXMuZ2V0QWN0aXZlU2NvcGVTcGFuKClcbiAgICApXG4gICAgbGV0IGlzUm9vdFNwYW4gPSBmYWxzZVxuXG4gICAgaWYgKCFzcGFuQ29udGV4dCkge1xuICAgICAgc3BhbkNvbnRleHQgPSBjb250ZXh0Py5hY3RpdmUoKSA/PyBST09UX0NPTlRFWFRcbiAgICAgIGlzUm9vdFNwYW4gPSB0cnVlXG4gICAgfSBlbHNlIGlmICh0cmFjZS5nZXRTcGFuQ29udGV4dChzcGFuQ29udGV4dCk/LmlzUmVtb3RlKSB7XG4gICAgICBpc1Jvb3RTcGFuID0gdHJ1ZVxuICAgIH1cblxuICAgIGNvbnN0IHNwYW5JZCA9IGdldFNwYW5JZCgpXG5cbiAgICBvcHRpb25zLmF0dHJpYnV0ZXMgPSB7XG4gICAgICAnbmV4dC5zcGFuX25hbWUnOiBzcGFuTmFtZSxcbiAgICAgICduZXh0LnNwYW5fdHlwZSc6IHR5cGUsXG4gICAgICAuLi5vcHRpb25zLmF0dHJpYnV0ZXMsXG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnRleHQud2l0aChzcGFuQ29udGV4dC5zZXRWYWx1ZShyb290U3BhbklkS2V5LCBzcGFuSWQpLCAoKSA9PlxuICAgICAgdGhpcy5nZXRUcmFjZXJJbnN0YW5jZSgpLnN0YXJ0QWN0aXZlU3BhbihcbiAgICAgICAgc3Bhbk5hbWUsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIChzcGFuOiBTcGFuKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3RhcnRUaW1lID1cbiAgICAgICAgICAgICdwZXJmb3JtYW5jZScgaW4gZ2xvYmFsVGhpcyAmJiAnbWVhc3VyZScgaW4gcGVyZm9ybWFuY2VcbiAgICAgICAgICAgICAgPyBnbG9iYWxUaGlzLnBlcmZvcm1hbmNlLm5vdygpXG4gICAgICAgICAgICAgIDogdW5kZWZpbmVkXG5cbiAgICAgICAgICBjb25zdCBvbkNsZWFudXAgPSAoKSA9PiB7XG4gICAgICAgICAgICByb290U3BhbkF0dHJpYnV0ZXNTdG9yZS5kZWxldGUoc3BhbklkKVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBzdGFydFRpbWUgJiZcbiAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTkVYVF9PVEVMX1BFUkZPUk1BTkNFX1BSRUZJWCAmJlxuICAgICAgICAgICAgICBMb2dTcGFuQWxsb3dMaXN0LmluY2x1ZGVzKHR5cGUgfHwgKCcnIGFzIGFueSkpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgcGVyZm9ybWFuY2UubWVhc3VyZShcbiAgICAgICAgICAgICAgICBgJHtwcm9jZXNzLmVudi5ORVhUX09URUxfUEVSRk9STUFOQ0VfUFJFRklYfTpuZXh0LSR7KFxuICAgICAgICAgICAgICAgICAgdHlwZS5zcGxpdCgnLicpLnBvcCgpIHx8ICcnXG4gICAgICAgICAgICAgICAgKS5yZXBsYWNlKFxuICAgICAgICAgICAgICAgICAgL1tBLVpdL2csXG4gICAgICAgICAgICAgICAgICAobWF0Y2g6IHN0cmluZykgPT4gJy0nICsgbWF0Y2gudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgICAgICl9YCxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgICAgZW5kOiBwZXJmb3JtYW5jZS5ub3coKSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNSb290U3Bhbikge1xuICAgICAgICAgICAgcm9vdFNwYW5BdHRyaWJ1dGVzU3RvcmUuc2V0KFxuICAgICAgICAgICAgICBzcGFuSWQsXG4gICAgICAgICAgICAgIG5ldyBNYXAoXG4gICAgICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMob3B0aW9ucy5hdHRyaWJ1dGVzID8/IHt9KSBhcyBbXG4gICAgICAgICAgICAgICAgICBBdHRyaWJ1dGVOYW1lcyxcbiAgICAgICAgICAgICAgICAgIEF0dHJpYnV0ZVZhbHVlIHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIF1bXVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoZm4ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICByZXR1cm4gZm4oc3BhbiwgKGVycikgPT4gY2xvc2VTcGFuV2l0aEVycm9yKHNwYW4sIGVycikpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGZuKHNwYW4pXG4gICAgICAgICAgICBpZiAoaXNUaGVuYWJsZShyZXN1bHQpKSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoZXJlJ3MgZXJyb3IgbWFrZSBzdXJlIGl0IHRocm93c1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICAgICAgICAgICAgLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgc3Bhbi5lbmQoKVxuICAgICAgICAgICAgICAgICAgLy8gTmVlZCB0byBwYXNzIGRvd24gdGhlIHByb21pc2UgcmVzdWx0LFxuICAgICAgICAgICAgICAgICAgLy8gaXQgY291bGQgYmUgcmVhY3Qgc3RyZWFtIHJlc3BvbnNlIHdpdGggZXJyb3IgeyBlcnJvciwgc3RyZWFtIH1cbiAgICAgICAgICAgICAgICAgIHJldHVybiByZXNcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICBjbG9zZVNwYW5XaXRoRXJyb3Ioc3BhbiwgZXJyKVxuICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuZmluYWxseShvbkNsZWFudXApXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzcGFuLmVuZCgpXG4gICAgICAgICAgICAgIG9uQ2xlYW51cCgpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgICAgICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgICAgICAgICAgY2xvc2VTcGFuV2l0aEVycm9yKHNwYW4sIGVycilcbiAgICAgICAgICAgIG9uQ2xlYW51cCgpXG4gICAgICAgICAgICB0aHJvdyBlcnJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIClcbiAgICApXG4gIH1cblxuICBwdWJsaWMgd3JhcDxUID0gKC4uLmFyZ3M6IEFycmF5PGFueT4pID0+IGFueT4odHlwZTogU3BhblR5cGVzLCBmbjogVCk6IFRcbiAgcHVibGljIHdyYXA8VCA9ICguLi5hcmdzOiBBcnJheTxhbnk+KSA9PiBhbnk+KFxuICAgIHR5cGU6IFNwYW5UeXBlcyxcbiAgICBvcHRpb25zOiBUcmFjZXJTcGFuT3B0aW9ucyxcbiAgICBmbjogVFxuICApOiBUXG4gIHB1YmxpYyB3cmFwPFQgPSAoLi4uYXJnczogQXJyYXk8YW55PikgPT4gYW55PihcbiAgICB0eXBlOiBTcGFuVHlwZXMsXG4gICAgb3B0aW9uczogKC4uLmFyZ3M6IGFueVtdKSA9PiBUcmFjZXJTcGFuT3B0aW9ucyxcbiAgICBmbjogVFxuICApOiBUXG4gIHB1YmxpYyB3cmFwKC4uLmFyZ3M6IEFycmF5PGFueT4pIHtcbiAgICBjb25zdCB0cmFjZXIgPSB0aGlzXG4gICAgY29uc3QgW25hbWUsIG9wdGlvbnMsIGZuXSA9XG4gICAgICBhcmdzLmxlbmd0aCA9PT0gMyA/IGFyZ3MgOiBbYXJnc1swXSwge30sIGFyZ3NbMV1dXG5cbiAgICBpZiAoXG4gICAgICAhTmV4dFZhbmlsbGFTcGFuQWxsb3dsaXN0LmluY2x1ZGVzKG5hbWUpICYmXG4gICAgICBwcm9jZXNzLmVudi5ORVhUX09URUxfVkVSQk9TRSAhPT0gJzEnXG4gICAgKSB7XG4gICAgICByZXR1cm4gZm5cbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKHRoaXM6IGFueSkge1xuICAgICAgbGV0IG9wdGlvbnNPYmogPSBvcHRpb25zXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnNPYmogPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9wdGlvbnNPYmogPSBvcHRpb25zT2JqLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH1cblxuICAgICAgY29uc3QgbGFzdEFyZ0lkID0gYXJndW1lbnRzLmxlbmd0aCAtIDFcbiAgICAgIGNvbnN0IGNiID0gYXJndW1lbnRzW2xhc3RBcmdJZF1cblxuICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb25zdCBzY29wZUJvdW5kQ2IgPSB0cmFjZXIuZ2V0Q29udGV4dCgpLmJpbmQoY29udGV4dC5hY3RpdmUoKSwgY2IpXG4gICAgICAgIHJldHVybiB0cmFjZXIudHJhY2UobmFtZSwgb3B0aW9uc09iaiwgKF9zcGFuLCBkb25lKSA9PiB7XG4gICAgICAgICAgYXJndW1lbnRzW2xhc3RBcmdJZF0gPSBmdW5jdGlvbiAoZXJyOiBhbnkpIHtcbiAgICAgICAgICAgIGRvbmU/LihlcnIpXG4gICAgICAgICAgICByZXR1cm4gc2NvcGVCb3VuZENiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRyYWNlci50cmFjZShuYW1lLCBvcHRpb25zT2JqLCAoKSA9PiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzdGFydFNwYW4odHlwZTogU3BhblR5cGVzKTogU3BhblxuICBwdWJsaWMgc3RhcnRTcGFuKHR5cGU6IFNwYW5UeXBlcywgb3B0aW9uczogVHJhY2VyU3Bhbk9wdGlvbnMpOiBTcGFuXG4gIHB1YmxpYyBzdGFydFNwYW4oLi4uYXJnczogQXJyYXk8YW55Pik6IFNwYW4ge1xuICAgIGNvbnN0IFt0eXBlLCBvcHRpb25zXTogW3N0cmluZywgVHJhY2VyU3Bhbk9wdGlvbnMgfCB1bmRlZmluZWRdID0gYXJncyBhcyBhbnlcblxuICAgIGNvbnN0IHNwYW5Db250ZXh0ID0gdGhpcy5nZXRTcGFuQ29udGV4dChcbiAgICAgIG9wdGlvbnM/LnBhcmVudFNwYW4gPz8gdGhpcy5nZXRBY3RpdmVTY29wZVNwYW4oKVxuICAgIClcbiAgICByZXR1cm4gdGhpcy5nZXRUcmFjZXJJbnN0YW5jZSgpLnN0YXJ0U3Bhbih0eXBlLCBvcHRpb25zLCBzcGFuQ29udGV4dClcbiAgfVxuXG4gIHByaXZhdGUgZ2V0U3BhbkNvbnRleHQocGFyZW50U3Bhbj86IFNwYW4pIHtcbiAgICBjb25zdCBzcGFuQ29udGV4dCA9IHBhcmVudFNwYW5cbiAgICAgID8gdHJhY2Uuc2V0U3Bhbihjb250ZXh0LmFjdGl2ZSgpLCBwYXJlbnRTcGFuKVxuICAgICAgOiB1bmRlZmluZWRcblxuICAgIHJldHVybiBzcGFuQ29udGV4dFxuICB9XG5cbiAgcHVibGljIGdldFJvb3RTcGFuQXR0cmlidXRlcygpIHtcbiAgICBjb25zdCBzcGFuSWQgPSBjb250ZXh0LmFjdGl2ZSgpLmdldFZhbHVlKHJvb3RTcGFuSWRLZXkpIGFzIG51bWJlclxuICAgIHJldHVybiByb290U3BhbkF0dHJpYnV0ZXNTdG9yZS5nZXQoc3BhbklkKVxuICB9XG5cbiAgcHVibGljIHNldFJvb3RTcGFuQXR0cmlidXRlKGtleTogQXR0cmlidXRlTmFtZXMsIHZhbHVlOiBBdHRyaWJ1dGVWYWx1ZSkge1xuICAgIGNvbnN0IHNwYW5JZCA9IGNvbnRleHQuYWN0aXZlKCkuZ2V0VmFsdWUocm9vdFNwYW5JZEtleSkgYXMgbnVtYmVyXG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHJvb3RTcGFuQXR0cmlidXRlc1N0b3JlLmdldChzcGFuSWQpXG4gICAgaWYgKGF0dHJpYnV0ZXMpIHtcbiAgICAgIGF0dHJpYnV0ZXMuc2V0KGtleSwgdmFsdWUpXG4gICAgfVxuICB9XG59XG5cbmNvbnN0IGdldFRyYWNlciA9ICgoKSA9PiB7XG4gIGNvbnN0IHRyYWNlciA9IG5ldyBOZXh0VHJhY2VySW1wbCgpXG5cbiAgcmV0dXJuICgpID0+IHRyYWNlclxufSkoKVxuXG5leHBvcnQgeyBnZXRUcmFjZXIsIFNwYW5TdGF0dXNDb2RlLCBTcGFuS2luZCB9XG5leHBvcnQgdHlwZSB7IE5leHRUcmFjZXIsIFNwYW4sIFNwYW5PcHRpb25zLCBDb250ZXh0QVBJLCBUcmFjZXJTcGFuT3B0aW9ucyB9XG4iXSwibmFtZXMiOlsiTG9nU3BhbkFsbG93TGlzdCIsIk5leHRWYW5pbGxhU3BhbkFsbG93bGlzdCIsImlzVGhlbmFibGUiLCJhcGkiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9SVU5USU1FIiwicmVxdWlyZSIsImVyciIsImNvbnRleHQiLCJwcm9wYWdhdGlvbiIsInRyYWNlIiwiU3BhblN0YXR1c0NvZGUiLCJTcGFuS2luZCIsIlJPT1RfQ09OVEVYVCIsIkJ1YmJsZWRFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJidWJibGUiLCJyZXN1bHQiLCJpc0J1YmJsZWRFcnJvciIsImVycm9yIiwiY2xvc2VTcGFuV2l0aEVycm9yIiwic3BhbiIsInNldEF0dHJpYnV0ZSIsInJlY29yZEV4Y2VwdGlvbiIsInNldFN0YXR1cyIsImNvZGUiLCJFUlJPUiIsIm1lc3NhZ2UiLCJlbmQiLCJyb290U3BhbkF0dHJpYnV0ZXNTdG9yZSIsIk1hcCIsInJvb3RTcGFuSWRLZXkiLCJjcmVhdGVDb250ZXh0S2V5IiwibGFzdFNwYW5JZCIsImdldFNwYW5JZCIsImNsaWVudFRyYWNlRGF0YVNldHRlciIsInNldCIsImNhcnJpZXIiLCJrZXkiLCJ2YWx1ZSIsInB1c2giLCJOZXh0VHJhY2VySW1wbCIsImdldFRyYWNlckluc3RhbmNlIiwiZ2V0VHJhY2VyIiwiZ2V0Q29udGV4dCIsImdldFRyYWNlUHJvcGFnYXRpb25EYXRhIiwiYWN0aXZlQ29udGV4dCIsImFjdGl2ZSIsImVudHJpZXMiLCJpbmplY3QiLCJnZXRBY3RpdmVTY29wZVNwYW4iLCJnZXRTcGFuIiwid2l0aFByb3BhZ2F0ZWRDb250ZXh0IiwiZm4iLCJnZXR0ZXIiLCJnZXRTcGFuQ29udGV4dCIsInJlbW90ZUNvbnRleHQiLCJleHRyYWN0Iiwid2l0aCIsImFyZ3MiLCJ0eXBlIiwiZm5Pck9wdGlvbnMiLCJmbk9yRW1wdHkiLCJvcHRpb25zIiwic3Bhbk5hbWUiLCJpbmNsdWRlcyIsIk5FWFRfT1RFTF9WRVJCT1NFIiwiaGlkZVNwYW4iLCJzcGFuQ29udGV4dCIsInBhcmVudFNwYW4iLCJpc1Jvb3RTcGFuIiwiaXNSZW1vdGUiLCJzcGFuSWQiLCJhdHRyaWJ1dGVzIiwic2V0VmFsdWUiLCJzdGFydEFjdGl2ZVNwYW4iLCJzdGFydFRpbWUiLCJnbG9iYWxUaGlzIiwicGVyZm9ybWFuY2UiLCJub3ciLCJ1bmRlZmluZWQiLCJvbkNsZWFudXAiLCJkZWxldGUiLCJORVhUX09URUxfUEVSRk9STUFOQ0VfUFJFRklYIiwibWVhc3VyZSIsInNwbGl0IiwicG9wIiwicmVwbGFjZSIsIm1hdGNoIiwidG9Mb3dlckNhc2UiLCJzdGFydCIsIk9iamVjdCIsImxlbmd0aCIsInRoZW4iLCJyZXMiLCJjYXRjaCIsImZpbmFsbHkiLCJ3cmFwIiwidHJhY2VyIiwibmFtZSIsIm9wdGlvbnNPYmoiLCJhcHBseSIsImFyZ3VtZW50cyIsImxhc3RBcmdJZCIsImNiIiwic2NvcGVCb3VuZENiIiwiYmluZCIsIl9zcGFuIiwiZG9uZSIsInN0YXJ0U3BhbiIsInNldFNwYW4iLCJnZXRSb290U3BhbkF0dHJpYnV0ZXMiLCJnZXRWYWx1ZSIsImdldCIsInNldFJvb3RTcGFuQXR0cmlidXRlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBR0EsU0FBU0EsZ0JBQWdCLEVBQUVDLHdCQUF3QixRQUFRLGNBQWE7QUFVeEUsU0FBU0MsVUFBVSxRQUFRLGtDQUFpQzs7O0FBRTVELElBQUlDO0FBRUosZ0ZBQWdGO0FBQ2hGLDhFQUE4RTtBQUM5RSx1Q0FBdUM7QUFDdkMsMEVBQTBFO0FBQzFFLCtFQUErRTtBQUMvRSw0Q0FBNEM7QUFDNUMsNkNBQTZDO0FBQzdDLElBQUlDLFFBQVFDLEdBQUcsQ0FBQ0MsWUFBWSxLQUFLLFFBQVE7O0tBRWxDO0lBQ0wsSUFBSTtRQUNGSCxNQUFNSSxRQUFRO0lBQ2hCLEVBQUUsT0FBT0MsS0FBSztRQUNaTCxNQUNFSSxRQUFRO0lBQ1o7QUFDRjtBQUVBLE1BQU0sRUFBRUUsT0FBTyxFQUFFQyxXQUFXLEVBQUVDLEtBQUssRUFBRUMsY0FBYyxFQUFFQyxRQUFRLEVBQUVDLFlBQVksRUFBRSxHQUMzRVg7QUFFSyxNQUFNWSxxQkFBcUJDO0lBQ2hDQyxZQUNrQkMsTUFBZ0IsRUFDaEJDLE1BQXlCLENBQ3pDO1FBQ0EsS0FBSyxJQUFBLElBQUEsQ0FIV0QsTUFBQUEsR0FBQUEsUUFBQUEsSUFBQUEsQ0FDQUMsTUFBQUEsR0FBQUE7SUFHbEI7QUFDRjtBQUVPLFNBQVNDLGVBQWVDLEtBQWM7SUFDM0MsSUFBSSxPQUFPQSxVQUFVLFlBQVlBLFVBQVUsTUFBTSxPQUFPO0lBQ3hELE9BQU9BLGlCQUFpQk47QUFDMUI7QUFFQSxNQUFNTyxxQkFBcUIsQ0FBQ0MsTUFBWUY7SUFDdEMsSUFBSUQsZUFBZUMsVUFBVUEsTUFBTUgsTUFBTSxFQUFFO1FBQ3pDSyxLQUFLQyxZQUFZLENBQUMsZUFBZTtJQUNuQyxPQUFPO1FBQ0wsSUFBSUgsT0FBTztZQUNURSxLQUFLRSxlQUFlLENBQUNKO1FBQ3ZCO1FBQ0FFLEtBQUtHLFNBQVMsQ0FBQztZQUFFQyxNQUFNZixlQUFlZ0IsS0FBSztZQUFFQyxPQUFPLEVBQUVSLFNBQUFBLE9BQUFBLEtBQUFBLElBQUFBLE1BQU9RLE9BQU87UUFBQztJQUN2RTtJQUNBTixLQUFLTyxHQUFHO0FBQ1Y7QUEyR0EsOEVBQThFLEdBQzlFLE1BQU1DLDBCQUEwQixJQUFJQztBQUlwQyxNQUFNQyxnQkFBZ0I5QixJQUFJK0IsZ0JBQWdCLENBQUM7QUFDM0MsSUFBSUMsYUFBYTtBQUNqQixNQUFNQyxZQUFZLElBQU1EO0FBT3hCLE1BQU1FLHdCQUErRDtJQUNuRUMsS0FBSUMsT0FBTyxFQUFFQyxHQUFHLEVBQUVDLEtBQUs7UUFDckJGLFFBQVFHLElBQUksQ0FBQztZQUNYRjtZQUNBQztRQUNGO0lBQ0Y7QUFDRjtBQUVBLE1BQU1FO0lBQ0o7Ozs7R0FJQyxHQUNPQyxvQkFBNEI7UUFDbEMsT0FBT2pDLE1BQU1rQyxTQUFTLENBQUMsV0FBVztJQUNwQztJQUVPQyxhQUF5QjtRQUM5QixPQUFPckM7SUFDVDtJQUVPc0MsMEJBQWtEO1FBQ3ZELE1BQU1DLGdCQUFnQnZDLFFBQVF3QyxNQUFNO1FBQ3BDLE1BQU1DLFVBQWtDLEVBQUU7UUFDMUN4QyxZQUFZeUMsTUFBTSxDQUFDSCxlQUFlRSxTQUFTYjtRQUMzQyxPQUFPYTtJQUNUO0lBRU9FLHFCQUF1QztRQUM1QyxPQUFPekMsTUFBTTBDLE9BQU8sQ0FBQzVDLFdBQUFBLE9BQUFBLEtBQUFBLElBQUFBLFFBQVN3QyxNQUFNO0lBQ3RDO0lBRU9LLHNCQUNMZixPQUFVLEVBQ1ZnQixFQUFXLEVBQ1hDLE1BQXlCLEVBQ3RCO1FBQ0gsTUFBTVIsZ0JBQWdCdkMsUUFBUXdDLE1BQU07UUFDcEMsSUFBSXRDLE1BQU04QyxjQUFjLENBQUNULGdCQUFnQjtZQUN2QyxxREFBcUQ7WUFDckQsT0FBT087UUFDVDtRQUNBLE1BQU1HLGdCQUFnQmhELFlBQVlpRCxPQUFPLENBQUNYLGVBQWVULFNBQVNpQjtRQUNsRSxPQUFPL0MsUUFBUW1ELElBQUksQ0FBQ0YsZUFBZUg7SUFDckM7SUFzQk81QyxNQUFTLEdBQUdrRCxJQUFnQixFQUFFO1lBd0N4QmxEO1FBdkNYLE1BQU0sQ0FBQ21ELE1BQU1DLGFBQWFDLFVBQVUsR0FBR0g7UUFFdkMsK0JBQStCO1FBQy9CLE1BQU0sRUFDSk4sRUFBRSxFQUNGVSxPQUFPLEVBQ1IsR0FJQyxPQUFPRixnQkFBZ0IsYUFDbkI7WUFDRVIsSUFBSVE7WUFDSkUsU0FBUyxDQUFDO1FBQ1osSUFDQTtZQUNFVixJQUFJUztZQUNKQyxTQUFTO2dCQUFFLEdBQUdGLFdBQVc7WUFBQztRQUM1QjtRQUVOLE1BQU1HLFdBQVdELFFBQVFDLFFBQVEsSUFBSUo7UUFFckMsSUFDRyxxS0FBQzdELDJCQUFBQSxDQUF5QmtFLFFBQVEsQ0FBQ0wsU0FDbEMxRCxRQUFRQyxHQUFHLENBQUMrRCxpQkFBaUIsS0FBSyxPQUNwQ0gsUUFBUUksUUFBUSxFQUNoQjtZQUNBLE9BQU9kO1FBQ1Q7UUFFQSxtSEFBbUg7UUFDbkgsSUFBSWUsY0FBYyxJQUFJLENBQUNiLGNBQWMsQ0FDbkNRLENBQUFBLFdBQUFBLE9BQUFBLEtBQUFBLElBQUFBLFFBQVNNLFVBQVUsS0FBSSxJQUFJLENBQUNuQixrQkFBa0I7UUFFaEQsSUFBSW9CLGFBQWE7UUFFakIsSUFBSSxDQUFDRixhQUFhO1lBQ2hCQSxjQUFjN0QsQ0FBQUEsV0FBQUEsT0FBQUEsS0FBQUEsSUFBQUEsUUFBU3dDLE1BQU0sRUFBQSxLQUFNbkM7WUFDbkMwRCxhQUFhO1FBQ2YsT0FBTyxJQUFBLENBQUk3RCx3QkFBQUEsTUFBTThDLGNBQWMsQ0FBQ2EsWUFBQUEsS0FBQUEsT0FBQUEsS0FBQUEsSUFBckIzRCxzQkFBbUM4RCxRQUFRLEVBQUU7WUFDdERELGFBQWE7UUFDZjtRQUVBLE1BQU1FLFNBQVN0QztRQUVmNkIsUUFBUVUsVUFBVSxHQUFHO1lBQ25CLGtCQUFrQlQ7WUFDbEIsa0JBQWtCSjtZQUNsQixHQUFHRyxRQUFRVSxVQUFVO1FBQ3ZCO1FBRUEsT0FBT2xFLFFBQVFtRCxJQUFJLENBQUNVLFlBQVlNLFFBQVEsQ0FBQzNDLGVBQWV5QyxTQUFTLElBQy9ELElBQUksQ0FBQzlCLGlCQUFpQixHQUFHaUMsZUFBZSxDQUN0Q1gsVUFDQUQsU0FDQSxDQUFDMUM7Z0JBQ0MsTUFBTXVELFlBQ0osaUJBQWlCQyxjQUFjLGFBQWFDLGNBQ3hDRCxXQUFXQyxXQUFXLENBQUNDLEdBQUcsS0FDMUJDO2dCQUVOLE1BQU1DLFlBQVk7b0JBQ2hCcEQsd0JBQXdCcUQsTUFBTSxDQUFDVjtvQkFDL0IsSUFDRUksYUFDQTFFLFFBQVFDLEdBQUcsQ0FBQ2dGLDRCQUE0QixJQUN4Q3JGLHVMQUFBQSxDQUFpQm1FLFFBQVEsQ0FBQ0wsUUFBUyxLQUNuQzt3QkFDQWtCLFlBQVlNLE9BQU8sQ0FDakIsR0FBR2xGLFFBQVFDLEdBQUcsQ0FBQ2dGLDRCQUE0QixDQUFDLE1BQU0sRUFDaER2QixDQUFBQSxLQUFLeUIsS0FBSyxDQUFDLEtBQUtDLEdBQUcsTUFBTSxFQUFDLEVBQzFCQyxPQUFPLENBQ1AsVUFDQSxDQUFDQyxRQUFrQixNQUFNQSxNQUFNQyxXQUFXLEtBQ3pDLEVBQ0g7NEJBQ0VDLE9BQU9kOzRCQUNQaEQsS0FBS2tELFlBQVlDLEdBQUc7d0JBQ3RCO29CQUVKO2dCQUNGO2dCQUVBLElBQUlULFlBQVk7b0JBQ2R6Qyx3QkFBd0JPLEdBQUcsQ0FDekJvQyxRQUNBLElBQUkxQyxJQUNGNkQsT0FBTzNDLE9BQU8sQ0FBQ2UsUUFBUVUsVUFBVSxJQUFJLENBQUM7Z0JBTTVDO2dCQUNBLElBQUk7b0JBQ0YsSUFBSXBCLEdBQUd1QyxNQUFNLEdBQUcsR0FBRzt3QkFDakIsT0FBT3ZDLEdBQUdoQyxNQUFNLENBQUNmLE1BQVFjLG1CQUFtQkMsTUFBTWY7b0JBQ3BEO29CQUVBLE1BQU1XLFNBQVNvQyxHQUFHaEM7b0JBQ2xCLHdLQUFJckIsYUFBQUEsRUFBV2lCLFNBQVM7d0JBQ3RCLHVDQUF1Qzt3QkFDdkMsT0FBT0EsT0FDSjRFLElBQUksQ0FBQyxDQUFDQzs0QkFDTHpFLEtBQUtPLEdBQUc7NEJBQ1Isd0NBQXdDOzRCQUN4QyxpRUFBaUU7NEJBQ2pFLE9BQU9rRTt3QkFDVCxHQUNDQyxLQUFLLENBQUMsQ0FBQ3pGOzRCQUNOYyxtQkFBbUJDLE1BQU1mOzRCQUN6QixNQUFNQTt3QkFDUixHQUNDMEYsT0FBTyxDQUFDZjtvQkFDYixPQUFPO3dCQUNMNUQsS0FBS08sR0FBRzt3QkFDUnFEO29CQUNGO29CQUVBLE9BQU9oRTtnQkFDVCxFQUFFLE9BQU9YLEtBQVU7b0JBQ2pCYyxtQkFBbUJDLE1BQU1mO29CQUN6QjJFO29CQUNBLE1BQU0zRTtnQkFDUjtZQUNGO0lBR047SUFhTzJGLEtBQUssR0FBR3RDLElBQWdCLEVBQUU7UUFDL0IsTUFBTXVDLFNBQVMsSUFBSTtRQUNuQixNQUFNLENBQUNDLE1BQU1wQyxTQUFTVixHQUFHLEdBQ3ZCTSxLQUFLaUMsTUFBTSxLQUFLLElBQUlqQyxPQUFPO1lBQUNBLElBQUksQ0FBQyxFQUFFO1lBQUUsQ0FBQztZQUFHQSxJQUFJLENBQUMsRUFBRTtTQUFDO1FBRW5ELElBQ0UscUtBQUM1RCwyQkFBQUEsQ0FBeUJrRSxRQUFRLENBQUNrQyxTQUNuQ2pHLFFBQVFDLEdBQUcsQ0FBQytELGlCQUFpQixLQUFLLEtBQ2xDO1lBQ0EsT0FBT2I7UUFDVDtRQUVBLE9BQU87WUFDTCxJQUFJK0MsYUFBYXJDO1lBQ2pCLElBQUksT0FBT3FDLGVBQWUsY0FBYyxPQUFPL0MsT0FBTyxZQUFZO2dCQUNoRStDLGFBQWFBLFdBQVdDLEtBQUssQ0FBQyxJQUFJLEVBQUVDO1lBQ3RDO1lBRUEsTUFBTUMsWUFBWUQsVUFBVVYsTUFBTSxHQUFHO1lBQ3JDLE1BQU1ZLEtBQUtGLFNBQVMsQ0FBQ0MsVUFBVTtZQUUvQixJQUFJLE9BQU9DLE9BQU8sWUFBWTtnQkFDNUIsTUFBTUMsZUFBZVAsT0FBT3RELFVBQVUsR0FBRzhELElBQUksQ0FBQ25HLFFBQVF3QyxNQUFNLElBQUl5RDtnQkFDaEUsT0FBT04sT0FBT3pGLEtBQUssQ0FBQzBGLE1BQU1DLFlBQVksQ0FBQ08sT0FBT0M7b0JBQzVDTixTQUFTLENBQUNDLFVBQVUsR0FBRyxTQUFVakcsR0FBUTt3QkFDdkNzRyxRQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxLQUFPdEc7d0JBQ1AsT0FBT21HLGFBQWFKLEtBQUssQ0FBQyxJQUFJLEVBQUVDO29CQUNsQztvQkFFQSxPQUFPakQsR0FBR2dELEtBQUssQ0FBQyxJQUFJLEVBQUVDO2dCQUN4QjtZQUNGLE9BQU87Z0JBQ0wsT0FBT0osT0FBT3pGLEtBQUssQ0FBQzBGLE1BQU1DLFlBQVksSUFBTS9DLEdBQUdnRCxLQUFLLENBQUMsSUFBSSxFQUFFQztZQUM3RDtRQUNGO0lBQ0Y7SUFJT08sVUFBVSxHQUFHbEQsSUFBZ0IsRUFBUTtRQUMxQyxNQUFNLENBQUNDLE1BQU1HLFFBQVEsR0FBNENKO1FBRWpFLE1BQU1TLGNBQWMsSUFBSSxDQUFDYixjQUFjLENBQ3JDUSxDQUFBQSxXQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxRQUFTTSxVQUFVLEtBQUksSUFBSSxDQUFDbkIsa0JBQWtCO1FBRWhELE9BQU8sSUFBSSxDQUFDUixpQkFBaUIsR0FBR21FLFNBQVMsQ0FBQ2pELE1BQU1HLFNBQVNLO0lBQzNEO0lBRVFiLGVBQWVjLFVBQWlCLEVBQUU7UUFDeEMsTUFBTUQsY0FBY0MsYUFDaEI1RCxNQUFNcUcsT0FBTyxDQUFDdkcsUUFBUXdDLE1BQU0sSUFBSXNCLGNBQ2hDVztRQUVKLE9BQU9aO0lBQ1Q7SUFFTzJDLHdCQUF3QjtRQUM3QixNQUFNdkMsU0FBU2pFLFFBQVF3QyxNQUFNLEdBQUdpRSxRQUFRLENBQUNqRjtRQUN6QyxPQUFPRix3QkFBd0JvRixHQUFHLENBQUN6QztJQUNyQztJQUVPMEMscUJBQXFCNUUsR0FBbUIsRUFBRUMsS0FBcUIsRUFBRTtRQUN0RSxNQUFNaUMsU0FBU2pFLFFBQVF3QyxNQUFNLEdBQUdpRSxRQUFRLENBQUNqRjtRQUN6QyxNQUFNMEMsYUFBYTVDLHdCQUF3Qm9GLEdBQUcsQ0FBQ3pDO1FBQy9DLElBQUlDLFlBQVk7WUFDZEEsV0FBV3JDLEdBQUcsQ0FBQ0UsS0FBS0M7UUFDdEI7SUFDRjtBQUNGO0FBRUEsTUFBTUksWUFBYSxDQUFBO0lBQ2pCLE1BQU11RCxTQUFTLElBQUl6RDtJQUVuQixPQUFPLElBQU15RDtBQUNmLENBQUEiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNDQ0LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zcmMvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcXVlcnlzdHJpbmcudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBQYXJzZWRVcmxRdWVyeSB9IGZyb20gJ3F1ZXJ5c3RyaW5nJ1xuXG5leHBvcnQgZnVuY3Rpb24gc2VhcmNoUGFyYW1zVG9VcmxRdWVyeShcbiAgc2VhcmNoUGFyYW1zOiBVUkxTZWFyY2hQYXJhbXNcbik6IFBhcnNlZFVybFF1ZXJ5IHtcbiAgY29uc3QgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5ID0ge31cbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Ygc2VhcmNoUGFyYW1zLmVudHJpZXMoKSkge1xuICAgIGNvbnN0IGV4aXN0aW5nID0gcXVlcnlba2V5XVxuICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBxdWVyeVtrZXldID0gdmFsdWVcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZXhpc3RpbmcpKSB7XG4gICAgICBleGlzdGluZy5wdXNoKHZhbHVlKVxuICAgIH0gZWxzZSB7XG4gICAgICBxdWVyeVtrZXldID0gW2V4aXN0aW5nLCB2YWx1ZV1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHF1ZXJ5XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeVVybFF1ZXJ5UGFyYW0ocGFyYW06IHVua25vd24pOiBzdHJpbmcge1xuICBpZiAodHlwZW9mIHBhcmFtID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBwYXJhbVxuICB9XG5cbiAgaWYgKFxuICAgICh0eXBlb2YgcGFyYW0gPT09ICdudW1iZXInICYmICFpc05hTihwYXJhbSkpIHx8XG4gICAgdHlwZW9mIHBhcmFtID09PSAnYm9vbGVhbidcbiAgKSB7XG4gICAgcmV0dXJuIFN0cmluZyhwYXJhbSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gJydcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXJsUXVlcnlUb1NlYXJjaFBhcmFtcyhxdWVyeTogUGFyc2VkVXJsUXVlcnkpOiBVUkxTZWFyY2hQYXJhbXMge1xuICBjb25zdCBzZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKClcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocXVlcnkpKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdmFsdWUpIHtcbiAgICAgICAgc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHN0cmluZ2lmeVVybFF1ZXJ5UGFyYW0oaXRlbSkpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlYXJjaFBhcmFtcy5zZXQoa2V5LCBzdHJpbmdpZnlVcmxRdWVyeVBhcmFtKHZhbHVlKSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNlYXJjaFBhcmFtc1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduKFxuICB0YXJnZXQ6IFVSTFNlYXJjaFBhcmFtcyxcbiAgLi4uc2VhcmNoUGFyYW1zTGlzdDogVVJMU2VhcmNoUGFyYW1zW11cbik6IFVSTFNlYXJjaFBhcmFtcyB7XG4gIGZvciAoY29uc3Qgc2VhcmNoUGFyYW1zIG9mIHNlYXJjaFBhcmFtc0xpc3QpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBzZWFyY2hQYXJhbXMua2V5cygpKSB7XG4gICAgICB0YXJnZXQuZGVsZXRlKGtleSlcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBzZWFyY2hQYXJhbXMuZW50cmllcygpKSB7XG4gICAgICB0YXJnZXQuYXBwZW5kKGtleSwgdmFsdWUpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldFxufVxuIl0sIm5hbWVzIjpbInNlYXJjaFBhcmFtc1RvVXJsUXVlcnkiLCJzZWFyY2hQYXJhbXMiLCJxdWVyeSIsImtleSIsInZhbHVlIiwiZW50cmllcyIsImV4aXN0aW5nIiwiQXJyYXkiLCJpc0FycmF5IiwicHVzaCIsInN0cmluZ2lmeVVybFF1ZXJ5UGFyYW0iLCJwYXJhbSIsImlzTmFOIiwiU3RyaW5nIiwidXJsUXVlcnlUb1NlYXJjaFBhcmFtcyIsIlVSTFNlYXJjaFBhcmFtcyIsIk9iamVjdCIsIml0ZW0iLCJhcHBlbmQiLCJzZXQiLCJhc3NpZ24iLCJ0YXJnZXQiLCJzZWFyY2hQYXJhbXNMaXN0Iiwia2V5cyIsImRlbGV0ZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFFTyxTQUFTQSx1QkFDZEMsWUFBNkI7SUFFN0IsTUFBTUMsUUFBd0IsQ0FBQztJQUMvQixLQUFLLE1BQU0sQ0FBQ0MsS0FBS0MsTUFBTSxJQUFJSCxhQUFhSSxPQUFPLEdBQUk7UUFDakQsTUFBTUMsV0FBV0osS0FBSyxDQUFDQyxJQUFJO1FBQzNCLElBQUksT0FBT0csYUFBYSxhQUFhO1lBQ25DSixLQUFLLENBQUNDLElBQUksR0FBR0M7UUFDZixPQUFPLElBQUlHLE1BQU1DLE9BQU8sQ0FBQ0YsV0FBVztZQUNsQ0EsU0FBU0csSUFBSSxDQUFDTDtRQUNoQixPQUFPO1lBQ0xGLEtBQUssQ0FBQ0MsSUFBSSxHQUFHO2dCQUFDRztnQkFBVUY7YUFBTTtRQUNoQztJQUNGO0lBQ0EsT0FBT0Y7QUFDVDtBQUVBLFNBQVNRLHVCQUF1QkMsS0FBYztJQUM1QyxJQUFJLE9BQU9BLFVBQVUsVUFBVTtRQUM3QixPQUFPQTtJQUNUO0lBRUEsSUFDRyxPQUFPQSxVQUFVLFlBQVksQ0FBQ0MsTUFBTUQsVUFDckMsT0FBT0EsVUFBVSxXQUNqQjtRQUNBLE9BQU9FLE9BQU9GO0lBQ2hCLE9BQU87UUFDTCxPQUFPO0lBQ1Q7QUFDRjtBQUVPLFNBQVNHLHVCQUF1QlosS0FBcUI7SUFDMUQsTUFBTUQsZUFBZSxJQUFJYztJQUN6QixLQUFLLE1BQU0sQ0FBQ1osS0FBS0MsTUFBTSxJQUFJWSxPQUFPWCxPQUFPLENBQUNILE9BQVE7UUFDaEQsSUFBSUssTUFBTUMsT0FBTyxDQUFDSixRQUFRO1lBQ3hCLEtBQUssTUFBTWEsUUFBUWIsTUFBTztnQkFDeEJILGFBQWFpQixNQUFNLENBQUNmLEtBQUtPLHVCQUF1Qk87WUFDbEQ7UUFDRixPQUFPO1lBQ0xoQixhQUFha0IsR0FBRyxDQUFDaEIsS0FBS08sdUJBQXVCTjtRQUMvQztJQUNGO0lBQ0EsT0FBT0g7QUFDVDtBQUVPLFNBQVNtQixPQUNkQyxNQUF1QjtJQUN2QixJQUFBLElBQUEsT0FBQSxVQUFBLE1BQUEsRUFBR0MsbUJBQUgsSUFBQSxNQUFBLE9BQUEsSUFBQSxPQUFBLElBQUEsSUFBQSxPQUFBLEdBQUEsT0FBQSxNQUFBLE9BQUE7UUFBR0EsZ0JBQUFBLENBQUgsT0FBQSxFQUFBLEdBQUEsU0FBQSxDQUFBLEtBQXNDOztJQUV0QyxLQUFLLE1BQU1yQixnQkFBZ0JxQixpQkFBa0I7UUFDM0MsS0FBSyxNQUFNbkIsT0FBT0YsYUFBYXNCLElBQUksR0FBSTtZQUNyQ0YsT0FBT0csTUFBTSxDQUFDckI7UUFDaEI7UUFFQSxLQUFLLE1BQU0sQ0FBQ0EsS0FBS0MsTUFBTSxJQUFJSCxhQUFhSSxPQUFPLEdBQUk7WUFDakRnQixPQUFPSCxNQUFNLENBQUNmLEtBQUtDO1FBQ3JCO0lBQ0Y7SUFFQSxPQUFPaUI7QUFDVCIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA1MDcsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NyYy9zaGFyZWQvbGliL3JvdXRlci91dGlscy9mb3JtYXQtdXJsLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEZvcm1hdCBmdW5jdGlvbiBtb2RpZmllZCBmcm9tIG5vZGVqc1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB0eXBlIHsgVXJsT2JqZWN0IH0gZnJvbSAndXJsJ1xuaW1wb3J0IHR5cGUgeyBQYXJzZWRVcmxRdWVyeSB9IGZyb20gJ3F1ZXJ5c3RyaW5nJ1xuaW1wb3J0ICogYXMgcXVlcnlzdHJpbmcgZnJvbSAnLi9xdWVyeXN0cmluZydcblxuY29uc3Qgc2xhc2hlZFByb3RvY29scyA9IC9odHRwcz98ZnRwfGdvcGhlcnxmaWxlL1xuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0VXJsKHVybE9iajogVXJsT2JqZWN0KSB7XG4gIGxldCB7IGF1dGgsIGhvc3RuYW1lIH0gPSB1cmxPYmpcbiAgbGV0IHByb3RvY29sID0gdXJsT2JqLnByb3RvY29sIHx8ICcnXG4gIGxldCBwYXRobmFtZSA9IHVybE9iai5wYXRobmFtZSB8fCAnJ1xuICBsZXQgaGFzaCA9IHVybE9iai5oYXNoIHx8ICcnXG4gIGxldCBxdWVyeSA9IHVybE9iai5xdWVyeSB8fCAnJ1xuICBsZXQgaG9zdDogc3RyaW5nIHwgZmFsc2UgPSBmYWxzZVxuXG4gIGF1dGggPSBhdXRoID8gZW5jb2RlVVJJQ29tcG9uZW50KGF1dGgpLnJlcGxhY2UoLyUzQS9pLCAnOicpICsgJ0AnIDogJydcblxuICBpZiAodXJsT2JqLmhvc3QpIHtcbiAgICBob3N0ID0gYXV0aCArIHVybE9iai5ob3N0XG4gIH0gZWxzZSBpZiAoaG9zdG5hbWUpIHtcbiAgICBob3N0ID0gYXV0aCArICh+aG9zdG5hbWUuaW5kZXhPZignOicpID8gYFske2hvc3RuYW1lfV1gIDogaG9zdG5hbWUpXG4gICAgaWYgKHVybE9iai5wb3J0KSB7XG4gICAgICBob3N0ICs9ICc6JyArIHVybE9iai5wb3J0XG4gICAgfVxuICB9XG5cbiAgaWYgKHF1ZXJ5ICYmIHR5cGVvZiBxdWVyeSA9PT0gJ29iamVjdCcpIHtcbiAgICBxdWVyeSA9IFN0cmluZyhxdWVyeXN0cmluZy51cmxRdWVyeVRvU2VhcmNoUGFyYW1zKHF1ZXJ5IGFzIFBhcnNlZFVybFF1ZXJ5KSlcbiAgfVxuXG4gIGxldCBzZWFyY2ggPSB1cmxPYmouc2VhcmNoIHx8IChxdWVyeSAmJiBgPyR7cXVlcnl9YCkgfHwgJydcblxuICBpZiAocHJvdG9jb2wgJiYgIXByb3RvY29sLmVuZHNXaXRoKCc6JykpIHByb3RvY29sICs9ICc6J1xuXG4gIGlmIChcbiAgICB1cmxPYmouc2xhc2hlcyB8fFxuICAgICgoIXByb3RvY29sIHx8IHNsYXNoZWRQcm90b2NvbHMudGVzdChwcm90b2NvbCkpICYmIGhvc3QgIT09IGZhbHNlKVxuICApIHtcbiAgICBob3N0ID0gJy8vJyArIChob3N0IHx8ICcnKVxuICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZVswXSAhPT0gJy8nKSBwYXRobmFtZSA9ICcvJyArIHBhdGhuYW1lXG4gIH0gZWxzZSBpZiAoIWhvc3QpIHtcbiAgICBob3N0ID0gJydcbiAgfVxuXG4gIGlmIChoYXNoICYmIGhhc2hbMF0gIT09ICcjJykgaGFzaCA9ICcjJyArIGhhc2hcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2hbMF0gIT09ICc/Jykgc2VhcmNoID0gJz8nICsgc2VhcmNoXG5cbiAgcGF0aG5hbWUgPSBwYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csIGVuY29kZVVSSUNvbXBvbmVudClcbiAgc2VhcmNoID0gc2VhcmNoLnJlcGxhY2UoJyMnLCAnJTIzJylcblxuICByZXR1cm4gYCR7cHJvdG9jb2x9JHtob3N0fSR7cGF0aG5hbWV9JHtzZWFyY2h9JHtoYXNofWBcbn1cblxuZXhwb3J0IGNvbnN0IHVybE9iamVjdEtleXMgPSBbXG4gICdhdXRoJyxcbiAgJ2hhc2gnLFxuICAnaG9zdCcsXG4gICdob3N0bmFtZScsXG4gICdocmVmJyxcbiAgJ3BhdGgnLFxuICAncGF0aG5hbWUnLFxuICAncG9ydCcsXG4gICdwcm90b2NvbCcsXG4gICdxdWVyeScsXG4gICdzZWFyY2gnLFxuICAnc2xhc2hlcycsXG5dXG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRXaXRoVmFsaWRhdGlvbih1cmw6IFVybE9iamVjdCk6IHN0cmluZyB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgIGlmICh1cmwgIT09IG51bGwgJiYgdHlwZW9mIHVybCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIE9iamVjdC5rZXlzKHVybCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGlmICghdXJsT2JqZWN0S2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgYFVua25vd24ga2V5IHBhc3NlZCB2aWEgdXJsT2JqZWN0IGludG8gdXJsLmZvcm1hdDogJHtrZXl9YFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZm9ybWF0VXJsKHVybClcbn1cbiJdLCJuYW1lcyI6WyJxdWVyeXN0cmluZyIsInNsYXNoZWRQcm90b2NvbHMiLCJmb3JtYXRVcmwiLCJ1cmxPYmoiLCJhdXRoIiwiaG9zdG5hbWUiLCJwcm90b2NvbCIsInBhdGhuYW1lIiwiaGFzaCIsInF1ZXJ5IiwiaG9zdCIsImVuY29kZVVSSUNvbXBvbmVudCIsInJlcGxhY2UiLCJpbmRleE9mIiwicG9ydCIsIlN0cmluZyIsInVybFF1ZXJ5VG9TZWFyY2hQYXJhbXMiLCJzZWFyY2giLCJlbmRzV2l0aCIsInNsYXNoZXMiLCJ0ZXN0IiwidXJsT2JqZWN0S2V5cyIsImZvcm1hdFdpdGhWYWxpZGF0aW9uIiwidXJsIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJrZXkiLCJpbmNsdWRlcyIsImNvbnNvbGUiLCJ3YXJuIl0sIm1hcHBpbmdzIjoiQUFBQSx1Q0FBdUM7QUFDdkMsc0RBQXNEO0FBQ3RELEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUsZ0VBQWdFO0FBQ2hFLHNFQUFzRTtBQUN0RSxzRUFBc0U7QUFDdEUsNEVBQTRFO0FBQzVFLHFFQUFxRTtBQUNyRSx3QkFBd0I7QUFDeEIsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSx5REFBeUQ7QUFDekQsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSw2REFBNkQ7QUFDN0QsNEVBQTRFO0FBQzVFLDJFQUEyRTtBQUMzRSx3RUFBd0U7QUFDeEUsNEVBQTRFO0FBQzVFLHlDQUF5Qzs7Ozs7O0FBSXpDLFlBQVlBLGlCQUFpQixnQkFBZTs7QUFFNUMsTUFBTUMsbUJBQW1CO0FBRWxCLFNBQVNDLFVBQVVDLE1BQWlCO0lBQ3pDLElBQUksRUFBRUMsSUFBSSxFQUFFQyxRQUFRLEVBQUUsR0FBR0Y7SUFDekIsSUFBSUcsV0FBV0gsT0FBT0csUUFBUSxJQUFJO0lBQ2xDLElBQUlDLFdBQVdKLE9BQU9JLFFBQVEsSUFBSTtJQUNsQyxJQUFJQyxPQUFPTCxPQUFPSyxJQUFJLElBQUk7SUFDMUIsSUFBSUMsUUFBUU4sT0FBT00sS0FBSyxJQUFJO0lBQzVCLElBQUlDLE9BQXVCO0lBRTNCTixPQUFPQSxPQUFPTyxtQkFBbUJQLE1BQU1RLE9BQU8sQ0FBQyxRQUFRLE9BQU8sTUFBTTtJQUVwRSxJQUFJVCxPQUFPTyxJQUFJLEVBQUU7UUFDZkEsT0FBT04sT0FBT0QsT0FBT08sSUFBSTtJQUMzQixPQUFPLElBQUlMLFVBQVU7UUFDbkJLLE9BQU9OLE9BQVEsQ0FBQSxDQUFDQyxTQUFTUSxPQUFPLENBQUMsT0FBUSxNQUFHUixXQUFTLE1BQUtBLFFBQU87UUFDakUsSUFBSUYsT0FBT1csSUFBSSxFQUFFO1lBQ2ZKLFFBQVEsTUFBTVAsT0FBT1csSUFBSTtRQUMzQjtJQUNGO0lBRUEsSUFBSUwsU0FBUyxPQUFPQSxVQUFVLFVBQVU7UUFDdENBLFFBQVFNLHVMQUFPZixZQUFZZ0IsYUFBc0IsQ0FBQ1A7SUFDcEQ7SUFFQSxJQUFJUSxTQUFTZCxPQUFPYyxNQUFNLElBQUtSLFNBQVUsTUFBR0EsU0FBWTtJQUV4RCxJQUFJSCxZQUFZLENBQUNBLFNBQVNZLFFBQVEsQ0FBQyxNQUFNWixZQUFZO0lBRXJELElBQ0VILE9BQU9nQixPQUFPLElBQ1osQ0FBQSxDQUFDYixZQUFZTCxpQkFBaUJtQixJQUFJLENBQUNkLFNBQVEsS0FBTUksU0FBUyxPQUM1RDtRQUNBQSxPQUFPLE9BQVFBLENBQUFBLFFBQVEsRUFBQztRQUN4QixJQUFJSCxZQUFZQSxRQUFRLENBQUMsRUFBRSxLQUFLLEtBQUtBLFdBQVcsTUFBTUE7SUFDeEQsT0FBTyxJQUFJLENBQUNHLE1BQU07UUFDaEJBLE9BQU87SUFDVDtJQUVBLElBQUlGLFFBQVFBLElBQUksQ0FBQyxFQUFFLEtBQUssS0FBS0EsT0FBTyxNQUFNQTtJQUMxQyxJQUFJUyxVQUFVQSxNQUFNLENBQUMsRUFBRSxLQUFLLEtBQUtBLFNBQVMsTUFBTUE7SUFFaERWLFdBQVdBLFNBQVNLLE9BQU8sQ0FBQyxTQUFTRDtJQUNyQ00sU0FBU0EsT0FBT0wsT0FBTyxDQUFDLEtBQUs7SUFFN0IsT0FBUSxLQUFFTixXQUFXSSxPQUFPSCxXQUFXVSxTQUFTVDtBQUNsRDtBQUVPLE1BQU1hLGdCQUFnQjtJQUMzQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDRCxDQUFBO0FBRU0sU0FBU0MscUJBQXFCQyxHQUFjO0lBQ2pELElBQUlDLFFBQVFDLEdBQUcsQ0FBQ0MsUUFBUSxLQUFLLFdBQWU7UUFDMUMsSUFBSUgsUUFBUSxRQUFRLE9BQU9BLFFBQVEsVUFBVTtZQUMzQ0ksT0FBT0MsSUFBSSxDQUFDTCxLQUFLTSxPQUFPLENBQUMsQ0FBQ0M7Z0JBQ3hCLElBQUksQ0FBQ1QsY0FBY1UsUUFBUSxDQUFDRCxNQUFNO29CQUNoQ0UsUUFBUUMsSUFBSSxDQUNULHVEQUFvREg7Z0JBRXpEO1lBQ0Y7UUFDRjtJQUNGO0lBRUEsT0FBTzVCLFVBQVVxQjtBQUNuQiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA1OTksICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NyYy9zZXJ2ZXIvcmVxdWVzdC1tZXRhLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIG5vLXJlZGVjbGFyZSAqL1xuaW1wb3J0IHR5cGUgeyBJbmNvbWluZ01lc3NhZ2UgfSBmcm9tICdodHRwJ1xuaW1wb3J0IHR5cGUgeyBQYXJzZWRVcmxRdWVyeSB9IGZyb20gJ3F1ZXJ5c3RyaW5nJ1xuaW1wb3J0IHR5cGUgeyBVcmxXaXRoUGFyc2VkUXVlcnkgfSBmcm9tICd1cmwnXG5pbXBvcnQgdHlwZSB7IEJhc2VOZXh0UmVxdWVzdCB9IGZyb20gJy4vYmFzZS1odHRwJ1xuaW1wb3J0IHR5cGUgeyBDbG9uZWFibGVCb2R5IH0gZnJvbSAnLi9ib2R5LXN0cmVhbXMnXG5pbXBvcnQgdHlwZSB7IFJvdXRlTWF0Y2ggfSBmcm9tICcuL3JvdXRlLW1hdGNoZXMvcm91dGUtbWF0Y2gnXG5pbXBvcnQgdHlwZSB7IE5FWFRfUlNDX1VOSU9OX1FVRVJZIH0gZnJvbSAnLi4vY2xpZW50L2NvbXBvbmVudHMvYXBwLXJvdXRlci1oZWFkZXJzJ1xuaW1wb3J0IHR5cGUgeyBTZXJ2ZXJDb21wb25lbnRzSG1yQ2FjaGUgfSBmcm9tICcuL3Jlc3BvbnNlLWNhY2hlJ1xuaW1wb3J0IHR5cGUgeyBQYWdlc0Rldk92ZXJsYXlCcmlkZ2VUeXBlIH0gZnJvbSAnLi4vbmV4dC1kZXZ0b29scy91c2Vyc3BhY2UvcGFnZXMvcGFnZXMtZGV2LW92ZXJsYXktc2V0dXAnXG5cbi8vIEZJWE1FOiAod3lhdHRqb2gpIHRoaXMgaXMgYSB0ZW1wb3Jhcnkgc29sdXRpb24gdG8gYWxsb3cgdXMgdG8gcGFzcyBkYXRhIGJldHdlZW4gYnVuZGxlZCBtb2R1bGVzXG5leHBvcnQgY29uc3QgTkVYVF9SRVFVRVNUX01FVEEgPSBTeW1ib2wuZm9yKCdOZXh0SW50ZXJuYWxSZXF1ZXN0TWV0YScpXG5cbmV4cG9ydCB0eXBlIE5leHRJbmNvbWluZ01lc3NhZ2UgPSAoQmFzZU5leHRSZXF1ZXN0IHwgSW5jb21pbmdNZXNzYWdlKSAmIHtcbiAgW05FWFRfUkVRVUVTVF9NRVRBXT86IFJlcXVlc3RNZXRhXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVxdWVzdE1ldGEge1xuICAvKipcbiAgICogVGhlIHF1ZXJ5IHRoYXQgd2FzIHVzZWQgdG8gbWFrZSB0aGUgcmVxdWVzdC5cbiAgICovXG4gIGluaXRRdWVyeT86IFBhcnNlZFVybFF1ZXJ5XG5cbiAgLyoqXG4gICAqIFRoZSBVUkwgdGhhdCB3YXMgdXNlZCB0byBtYWtlIHRoZSByZXF1ZXN0LlxuICAgKi9cbiAgaW5pdFVSTD86IHN0cmluZ1xuXG4gIC8qKlxuICAgKiBUaGUgcHJvdG9jb2wgdGhhdCB3YXMgdXNlZCB0byBtYWtlIHRoZSByZXF1ZXN0LlxuICAgKi9cbiAgaW5pdFByb3RvY29sPzogc3RyaW5nXG5cbiAgLyoqXG4gICAqIFRoZSBib2R5IHRoYXQgd2FzIHJlYWQgZnJvbSB0aGUgcmVxdWVzdC4gVGhpcyBpcyB1c2VkIHRvIGFsbG93IHRoZSBib2R5IHRvXG4gICAqIGJlIHJlYWQgbXVsdGlwbGUgdGltZXMuXG4gICAqL1xuICBjbG9uYWJsZUJvZHk/OiBDbG9uZWFibGVCb2R5XG5cbiAgLyoqXG4gICAqIFRydWUgd2hlbiB0aGUgcmVxdWVzdCBtYXRjaGVkIGEgbG9jYWxlIGRvbWFpbiB0aGF0IHdhcyBjb25maWd1cmVkIGluIHRoZVxuICAgKiBuZXh0LmNvbmZpZy5qcyBmaWxlLlxuICAgKi9cbiAgaXNMb2NhbGVEb21haW4/OiBib29sZWFuXG5cbiAgLyoqXG4gICAqIFRydWUgd2hlbiB0aGUgcmVxdWVzdCBoYWQgbG9jYWxlIGluZm9ybWF0aW9uIHN0cmlwcGVkIGZyb20gdGhlIHBhdGhuYW1lXG4gICAqIHBhcnQgb2YgdGhlIFVSTC5cbiAgICovXG4gIGRpZFN0cmlwTG9jYWxlPzogYm9vbGVhblxuXG4gIC8qKlxuICAgKiBJZiB0aGUgcmVxdWVzdCBoYWQgaXQncyBVUkwgcmV3cml0dGVuLCB0aGlzIGlzIHRoZSBVUkwgaXQgd2FzIHJld3JpdHRlbiB0by5cbiAgICovXG4gIHJld3JvdGVVUkw/OiBzdHJpbmdcblxuICAvKipcbiAgICogVGhlIGNvb2tpZXMgdGhhdCB3ZXJlIGFkZGVkIGJ5IG1pZGRsZXdhcmUgYW5kIHdlcmUgYWRkZWQgdG8gdGhlIHJlc3BvbnNlLlxuICAgKi9cbiAgbWlkZGxld2FyZUNvb2tpZT86IHN0cmluZ1tdXG5cbiAgLyoqXG4gICAqIFRoZSBtYXRjaCBvbiB0aGUgcmVxdWVzdCBmb3IgYSBnaXZlbiByb3V0ZS5cbiAgICovXG4gIG1hdGNoPzogUm91dGVNYXRjaFxuXG4gIC8qKlxuICAgKiBUaGUgaW5jcmVtZW50YWwgY2FjaGUgdG8gdXNlIGZvciB0aGUgcmVxdWVzdC5cbiAgICovXG4gIGluY3JlbWVudGFsQ2FjaGU/OiBhbnlcblxuICAvKipcbiAgICogVGhlIHNlcnZlciBjb21wb25lbnRzIEhNUiBjYWNoZSwgb25seSBmb3IgZGV2LlxuICAgKi9cbiAgc2VydmVyQ29tcG9uZW50c0htckNhY2hlPzogU2VydmVyQ29tcG9uZW50c0htckNhY2hlXG5cbiAgLyoqXG4gICAqIEVxdWFscyB0aGUgc2VnbWVudCBwYXRoIHRoYXQgd2FzIHVzZWQgZm9yIHRoZSBwcmVmZXRjaCBSU0MgcmVxdWVzdC5cbiAgICovXG4gIHNlZ21lbnRQcmVmZXRjaFJTQ1JlcXVlc3Q/OiBzdHJpbmdcblxuICAvKipcbiAgICogVHJ1ZSB3aGVuIHRoZSByZXF1ZXN0IGlzIGZvciB0aGUgcHJlZmV0Y2ggZmxpZ2h0IGRhdGEuXG4gICAqL1xuICBpc1ByZWZldGNoUlNDUmVxdWVzdD86IHRydWVcblxuICAvKipcbiAgICogVHJ1ZSB3aGVuIHRoZSByZXF1ZXN0IGlzIGZvciB0aGUgZmxpZ2h0IGRhdGEuXG4gICAqL1xuICBpc1JTQ1JlcXVlc3Q/OiB0cnVlXG5cbiAgLyoqXG4gICAqIEEgc2VhcmNoIHBhcmFtIHNldCBieSB0aGUgTmV4dC5qcyBjbGllbnQgd2hlbiBwZXJmb3JtaW5nIFJTQyByZXF1ZXN0cy5cbiAgICogQmVjYXVzZSBzb21lIENETnMgZG8gbm90IHZhcnkgdGhlaXIgY2FjaGUgZW50cmllcyBvbiBvdXIgY3VzdG9tIGhlYWRlcnMsXG4gICAqIHRoaXMgc2VhcmNoIHBhcmFtIHJlcHJlc2VudHMgYSBoYXNoIG9mIHRoZSBoZWFkZXIgdmFsdWVzLiBGb3IgYW55IGNhY2hlZFxuICAgKiBSU0MgcmVxdWVzdCwgd2Ugc2hvdWxkIHZlcmlmeSB0aGF0IHRoZSBoYXNoIG1hdGNoZXMgYmVmb3JlIHJlc3BvbmRpbmcuXG4gICAqIE90aGVyd2lzZSB0aGlzIGNhbiBsZWFkIHRvIGNhY2hlIHBvaXNvbmluZy5cbiAgICogVE9ETzogQ29uc2lkZXIgbm90IHVzaW5nIGN1c3RvbSByZXF1ZXN0IGhlYWRlcnMgYXQgYWxsLCBhbmQgaW5zdGVhZCBlbmNvZGVcbiAgICogZXZlcnl0aGluZyBpbnRvIHRoZSBzZWFyY2ggcGFyYW0uXG4gICAqL1xuICBjYWNoZUJ1c3RpbmdTZWFyY2hQYXJhbT86IHN0cmluZ1xuXG4gIC8qKlxuICAgKiBUcnVlIHdoZW4gdGhlIHJlcXVlc3QgaXMgZm9yIHRoZSBgL19uZXh0L2RhdGFgIHJvdXRlIHVzaW5nIHRoZSBwYWdlc1xuICAgKiByb3V0ZXIuXG4gICAqL1xuICBpc05leHREYXRhUmVxPzogdHJ1ZVxuXG4gIC8qKlxuICAgKiBQb3N0cG9uZWQgc3RhdGUgdG8gdXNlIGZvciByZXN1bXB0aW9uLiBJZiBwcmVzZW50IGl0J3MgYXNzdW1lZCB0aGF0IHRoZVxuICAgKiByZXF1ZXN0IGlzIGZvciBhIHBhZ2UgdGhhdCBoYXMgcG9zdHBvbmVkICh0aGVyZSBhcmUgbm8gZ3VhcmFudGVlcyB0aGF0IHRoZVxuICAgKiBwYWdlIGFjdHVhbGx5IGhhcyBwb3N0cG9uZWQgdGhvdWdoIGFzIGl0IHdvdWxkIGluY3VyIGFuIGFkZGl0aW9uYWwgY2FjaGVcbiAgICogbG9va3VwKS5cbiAgICovXG4gIHBvc3Rwb25lZD86IHN0cmluZ1xuXG4gIC8qKlxuICAgKiBJZiBwcm92aWRlZCwgdGhpcyB3aWxsIGJlIGNhbGxlZCB3aGVuIGEgcmVzcG9uc2UgY2FjaGUgZW50cnkgd2FzIGdlbmVyYXRlZFxuICAgKiBvciBsb29rZWQgdXAgaW4gdGhlIGNhY2hlLlxuICAgKi9cbiAgb25DYWNoZUVudHJ5PzogKFxuICAgIGNhY2hlRW50cnk6IGFueSxcbiAgICByZXF1ZXN0TWV0YTogYW55XG4gICkgPT4gUHJvbWlzZTxib29sZWFuIHwgdm9pZD4gfCBib29sZWFuIHwgdm9pZFxuXG4gIC8qKlxuICAgKiBUaGUgcHJldmlvdXMgcmV2YWxpZGF0ZSBiZWZvcmUgcmVuZGVyaW5nIDQwNCBwYWdlIGZvciBub3RGb3VuZDogdHJ1ZVxuICAgKi9cbiAgbm90Rm91bmRSZXZhbGlkYXRlPzogbnVtYmVyIHwgZmFsc2VcblxuICAvKipcbiAgICogSW4gZGV2ZWxvcG1lbnQsIHRoZSBvcmlnaW5hbCBzb3VyY2UgcGFnZSB0aGF0IHJldHVybmVkIGEgNDA0LlxuICAgKi9cbiAgZGV2ZWxvcG1lbnROb3RGb3VuZFNvdXJjZVBhZ2U/OiBzdHJpbmdcblxuICAvKipcbiAgICogVGhlIHBhdGggd2Ugcm91dGVkIHRvIGFuZCBzaG91bGQgYmUgaW52b2tlZFxuICAgKi9cbiAgaW52b2tlUGF0aD86IHN0cmluZ1xuXG4gIC8qKlxuICAgKiBUaGUgc3BlY2lmaWMgcGFnZSBvdXRwdXQgd2Ugc2hvdWxkIGJlIG1hdGNoaW5nXG4gICAqL1xuICBpbnZva2VPdXRwdXQ/OiBzdHJpbmdcblxuICAvKipcbiAgICogVGhlIHN0YXR1cyB3ZSBhcmUgaW52b2tpbmcgdGhlIHJlcXVlc3Qgd2l0aCBmcm9tIHJvdXRpbmdcbiAgICovXG4gIGludm9rZVN0YXR1cz86IG51bWJlclxuXG4gIC8qKlxuICAgKiBUaGUgcm91dGluZyBlcnJvciB3ZSBhcmUgaW52b2tpbmcgd2l0aFxuICAgKi9cbiAgaW52b2tlRXJyb3I/OiBFcnJvclxuXG4gIC8qKlxuICAgKiBUaGUgcXVlcnkgcGFyc2VkIGZvciB0aGUgaW52b2NhdGlvblxuICAgKi9cbiAgaW52b2tlUXVlcnk/OiBSZWNvcmQ8c3RyaW5nLCB1bmRlZmluZWQgfCBzdHJpbmcgfCBzdHJpbmdbXT5cblxuICAvKipcbiAgICogV2hldGhlciB0aGUgcmVxdWVzdCBpcyBhIG1pZGRsZXdhcmUgaW52b2NhdGlvblxuICAgKi9cbiAgbWlkZGxld2FyZUludm9rZT86IGJvb2xlYW5cblxuICAvKipcbiAgICogV2hldGhlciB0aGUgcmVxdWVzdCBzaG91bGQgcmVuZGVyIHRoZSBmYWxsYmFjayBzaGVsbCBvciBub3QuXG4gICAqL1xuICByZW5kZXJGYWxsYmFja1NoZWxsPzogYm9vbGVhblxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSByZXF1ZXN0IGlzIGZvciB0aGUgY3VzdG9tIGVycm9yIHBhZ2UuXG4gICAqL1xuICBjdXN0b21FcnJvclJlbmRlcj86IHRydWVcblxuICAvKipcbiAgICogV2hldGhlciB0byBidWJibGUgdXAgdGhlIE5vRmFsbGJhY2tFcnJvciB0byB0aGUgY2FsbGVyIHdoZW4gYSA0MDQgaXNcbiAgICogcmV0dXJuZWQuXG4gICAqL1xuICBidWJibGVOb0ZhbGxiYWNrPzogdHJ1ZVxuXG4gIC8qKlxuICAgKiBUcnVlIHdoZW4gdGhlIHJlcXVlc3QgaGFkIGxvY2FsZSBpbmZvcm1hdGlvbiBpbmZlcnJlZCBmcm9tIHRoZSBkZWZhdWx0XG4gICAqIGxvY2FsZS5cbiAgICovXG4gIGxvY2FsZUluZmVycmVkRnJvbURlZmF1bHQ/OiB0cnVlXG5cbiAgLyoqXG4gICAqIFRoZSBsb2NhbGUgdGhhdCB3YXMgaW5mZXJyZWQgb3IgZXhwbGljaXRseSBzZXQgZm9yIHRoZSByZXF1ZXN0LlxuICAgKi9cbiAgbG9jYWxlPzogc3RyaW5nXG5cbiAgLyoqXG4gICAqIFRoZSBkZWZhdWx0IGxvY2FsZSB0aGF0IHdhcyBpbmZlcnJlZCBvciBleHBsaWNpdGx5IHNldCBmb3IgdGhlIHJlcXVlc3QuXG4gICAqL1xuICBkZWZhdWx0TG9jYWxlPzogc3RyaW5nXG5cbiAgLyoqXG4gICAqIFRoZSBwcm9qZWN0IGRpciB0aGUgc2VydmVyIGlzIHJ1bm5pbmcgaW5cbiAgICovXG4gIHByb2plY3REaXI/OiBzdHJpbmdcblxuICAvKipcbiAgICogVGhlIGRpc3QgZGlyZWN0b3J5IHRoZSBzZXJ2ZXIgaXMgY3VycmVudGx5IHVzaW5nXG4gICAqL1xuICBkaXN0RGlyPzogc3RyaW5nXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgd2UgYXJlIGdlbmVyYXRpbmcgdGhlIGZhbGxiYWNrIHZlcnNpb24gb2YgdGhlIHBhZ2UgaW4gZGV2IG1vZGVcbiAgICovXG4gIGlzSXNyRmFsbGJhY2s/OiBib29sZWFuXG5cbiAgLyoqXG4gICAqIFRoZSBxdWVyeSBhZnRlciByZXNvbHZpbmcgcm91dGVzXG4gICAqL1xuICBxdWVyeT86IFBhcnNlZFVybFF1ZXJ5XG5cbiAgLyoqXG4gICAqIFRoZSBwYXJhbXMgYWZ0ZXIgcmVzb2x2aW5nIHJvdXRlc1xuICAgKi9cbiAgcGFyYW1zPzogUGFyc2VkVXJsUXVlcnlcblxuICAvKipcbiAgICogVGhlIEFNUCB2YWxpZGF0b3IgdG8gdXNlIGluIGRldmVsb3BtZW50XG4gICAqL1xuICBhbXBWYWxpZGF0b3I/OiAoaHRtbDogc3RyaW5nLCBwYXRobmFtZTogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+XG5cbiAgLyoqXG4gICAqIEVycm9yT3ZlcmxheSBjb21wb25lbnQgdG8gdXNlIGluIGRldmVsb3BtZW50IGZvciBwYWdlcyByb3V0ZXJcbiAgICovXG4gIFBhZ2VzRXJyb3JEZWJ1Zz86IFBhZ2VzRGV2T3ZlcmxheUJyaWRnZVR5cGVcblxuICAvKipcbiAgICogV2hldGhlciBzZXJ2ZXIgaXMgaW4gbWluaW1hbCBtb2RlICh0aGlzIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBtb3JlXG4gICAqIHNwZWNpZmljIGZsYWdzIGluIGZ1dHVyZSlcbiAgICovXG4gIG1pbmltYWxNb2RlPzogYm9vbGVhblxufVxuXG4vKipcbiAqIEdldHMgdGhlIHJlcXVlc3QgbWV0YWRhdGEuIElmIG5vIGtleSBpcyBwcm92aWRlZCwgdGhlIGVudGlyZSBtZXRhZGF0YSBvYmplY3RcbiAqIGlzIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSByZXEgdGhlIHJlcXVlc3QgdG8gZ2V0IHRoZSBtZXRhZGF0YSBmcm9tXG4gKiBAcGFyYW0ga2V5IHRoZSBrZXkgdG8gZ2V0IGZyb20gdGhlIG1ldGFkYXRhIChvcHRpb25hbClcbiAqIEByZXR1cm5zIHRoZSB2YWx1ZSBmb3IgdGhlIGtleSBvciB0aGUgZW50aXJlIG1ldGFkYXRhIG9iamVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmVxdWVzdE1ldGEoXG4gIHJlcTogTmV4dEluY29taW5nTWVzc2FnZSxcbiAga2V5PzogdW5kZWZpbmVkXG4pOiBSZXF1ZXN0TWV0YVxuZXhwb3J0IGZ1bmN0aW9uIGdldFJlcXVlc3RNZXRhPEsgZXh0ZW5kcyBrZXlvZiBSZXF1ZXN0TWV0YT4oXG4gIHJlcTogTmV4dEluY29taW5nTWVzc2FnZSxcbiAga2V5OiBLXG4pOiBSZXF1ZXN0TWV0YVtLXVxuZXhwb3J0IGZ1bmN0aW9uIGdldFJlcXVlc3RNZXRhPEsgZXh0ZW5kcyBrZXlvZiBSZXF1ZXN0TWV0YT4oXG4gIHJlcTogTmV4dEluY29taW5nTWVzc2FnZSxcbiAga2V5PzogS1xuKTogUmVxdWVzdE1ldGEgfCBSZXF1ZXN0TWV0YVtLXSB7XG4gIGNvbnN0IG1ldGEgPSByZXFbTkVYVF9SRVFVRVNUX01FVEFdIHx8IHt9XG4gIHJldHVybiB0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyA/IG1ldGFba2V5XSA6IG1ldGFcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSByZXF1ZXN0IG1ldGFkYXRhLlxuICpcbiAqIEBwYXJhbSByZXEgdGhlIHJlcXVlc3QgdG8gc2V0IHRoZSBtZXRhZGF0YSBvblxuICogQHBhcmFtIG1ldGEgdGhlIG1ldGFkYXRhIHRvIHNldFxuICogQHJldHVybnMgdGhlIG11dGF0ZWQgcmVxdWVzdCBtZXRhZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0UmVxdWVzdE1ldGEocmVxOiBOZXh0SW5jb21pbmdNZXNzYWdlLCBtZXRhOiBSZXF1ZXN0TWV0YSkge1xuICByZXFbTkVYVF9SRVFVRVNUX01FVEFdID0gbWV0YVxuICByZXR1cm4gbWV0YVxufVxuXG4vKipcbiAqIEFkZHMgYSB2YWx1ZSB0byB0aGUgcmVxdWVzdCBtZXRhZGF0YS5cbiAqXG4gKiBAcGFyYW0gcmVxdWVzdCB0aGUgcmVxdWVzdCB0byBtdXRhdGVcbiAqIEBwYXJhbSBrZXkgdGhlIGtleSB0byBzZXRcbiAqIEBwYXJhbSB2YWx1ZSB0aGUgdmFsdWUgdG8gc2V0XG4gKiBAcmV0dXJucyB0aGUgbXV0YXRlZCByZXF1ZXN0IG1ldGFkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRSZXF1ZXN0TWV0YTxLIGV4dGVuZHMga2V5b2YgUmVxdWVzdE1ldGE+KFxuICByZXF1ZXN0OiBOZXh0SW5jb21pbmdNZXNzYWdlLFxuICBrZXk6IEssXG4gIHZhbHVlOiBSZXF1ZXN0TWV0YVtLXVxuKSB7XG4gIGNvbnN0IG1ldGEgPSBnZXRSZXF1ZXN0TWV0YShyZXF1ZXN0KVxuICBtZXRhW2tleV0gPSB2YWx1ZVxuICByZXR1cm4gc2V0UmVxdWVzdE1ldGEocmVxdWVzdCwgbWV0YSlcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGEga2V5IGZyb20gdGhlIHJlcXVlc3QgbWV0YWRhdGEuXG4gKlxuICogQHBhcmFtIHJlcXVlc3QgdGhlIHJlcXVlc3QgdG8gbXV0YXRlXG4gKiBAcGFyYW0ga2V5IHRoZSBrZXkgdG8gcmVtb3ZlXG4gKiBAcmV0dXJucyB0aGUgbXV0YXRlZCByZXF1ZXN0IG1ldGFkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVSZXF1ZXN0TWV0YTxLIGV4dGVuZHMga2V5b2YgUmVxdWVzdE1ldGE+KFxuICByZXF1ZXN0OiBOZXh0SW5jb21pbmdNZXNzYWdlLFxuICBrZXk6IEtcbikge1xuICBjb25zdCBtZXRhID0gZ2V0UmVxdWVzdE1ldGEocmVxdWVzdClcbiAgZGVsZXRlIG1ldGFba2V5XVxuICByZXR1cm4gc2V0UmVxdWVzdE1ldGEocmVxdWVzdCwgbWV0YSlcbn1cblxudHlwZSBOZXh0UXVlcnlNZXRhZGF0YSA9IHtcbiAgLyoqXG4gICAqIFRoZSBgX3JzY2AgcXVlcnkgcGFyYW1ldGVyIHVzZWQgZm9yIGNhY2hlIGJ1c3RpbmcgdG8gZW5zdXJlIHRoYXQgdGhlIFJTQ1xuICAgKiByZXF1ZXN0cyBkbyBub3QgZ2V0IGNhY2hlZCBieSB0aGUgYnJvd3NlciBleHBsaWNpdGx5LlxuICAgKi9cbiAgW05FWFRfUlNDX1VOSU9OX1FVRVJZXT86IHN0cmluZ1xufVxuXG5leHBvcnQgdHlwZSBOZXh0UGFyc2VkVXJsUXVlcnkgPSBQYXJzZWRVcmxRdWVyeSAmXG4gIE5leHRRdWVyeU1ldGFkYXRhICYge1xuICAgIGFtcD86ICcxJ1xuICB9XG5cbmV4cG9ydCBpbnRlcmZhY2UgTmV4dFVybFdpdGhQYXJzZWRRdWVyeSBleHRlbmRzIFVybFdpdGhQYXJzZWRRdWVyeSB7XG4gIHF1ZXJ5OiBOZXh0UGFyc2VkVXJsUXVlcnlcbn1cbiJdLCJuYW1lcyI6WyJORVhUX1JFUVVFU1RfTUVUQSIsIlN5bWJvbCIsImZvciIsImdldFJlcXVlc3RNZXRhIiwicmVxIiwia2V5IiwibWV0YSIsInNldFJlcXVlc3RNZXRhIiwiYWRkUmVxdWVzdE1ldGEiLCJyZXF1ZXN0IiwidmFsdWUiLCJyZW1vdmVSZXF1ZXN0TWV0YSJdLCJtYXBwaW5ncyI6IkFBQUEsK0JBQStCLEdBVy9CLGtHQUFrRzs7Ozs7Ozs7QUFDM0YsTUFBTUEsb0JBQW9CQyxPQUFPQyxHQUFHLENBQUMsMkJBQTBCO0FBb1AvRCxTQUFTQyxlQUNkQyxHQUF3QixFQUN4QkMsR0FBTztJQUVQLE1BQU1DLE9BQU9GLEdBQUcsQ0FBQ0osa0JBQWtCLElBQUksQ0FBQztJQUN4QyxPQUFPLE9BQU9LLFFBQVEsV0FBV0MsSUFBSSxDQUFDRCxJQUFJLEdBQUdDO0FBQy9DO0FBU08sU0FBU0MsZUFBZUgsR0FBd0IsRUFBRUUsSUFBaUI7SUFDeEVGLEdBQUcsQ0FBQ0osa0JBQWtCLEdBQUdNO0lBQ3pCLE9BQU9BO0FBQ1Q7QUFVTyxTQUFTRSxlQUNkQyxPQUE0QixFQUM1QkosR0FBTSxFQUNOSyxLQUFxQjtJQUVyQixNQUFNSixPQUFPSCxlQUFlTTtJQUM1QkgsSUFBSSxDQUFDRCxJQUFJLEdBQUdLO0lBQ1osT0FBT0gsZUFBZUUsU0FBU0g7QUFDakM7QUFTTyxTQUFTSyxrQkFDZEYsT0FBNEIsRUFDNUJKLEdBQU07SUFFTixNQUFNQyxPQUFPSCxlQUFlTTtJQUM1QixPQUFPSCxJQUFJLENBQUNELElBQUk7SUFDaEIsT0FBT0UsZUFBZUUsU0FBU0g7QUFDakMiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNjMwLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zcmMvc2VydmVyL2FwcC1yZW5kZXIvaW50ZXJvcC1kZWZhdWx0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSW50ZXJvcCBiZXR3ZWVuIFwiZXhwb3J0IGRlZmF1bHRcIiBhbmQgXCJtb2R1bGUuZXhwb3J0c1wiLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJvcERlZmF1bHQobW9kOiBhbnkpIHtcbiAgcmV0dXJuIG1vZC5kZWZhdWx0IHx8IG1vZFxufVxuIl0sIm5hbWVzIjpbImludGVyb3BEZWZhdWx0IiwibW9kIiwiZGVmYXVsdCJdLCJtYXBwaW5ncyI6IkFBQUE7O0NBRUMsR0FDRDs7O0FBQU8sU0FBU0EsZUFBZUMsR0FBUTtJQUNyQyxPQUFPQSxJQUFJQyxPQUFPLElBQUlEO0FBQ3hCIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDY0MiwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL3NlcnZlci9pbnN0cnVtZW50YXRpb24vdXRpbHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGdldFJldmFsaWRhdGVSZWFzb24ocGFyYW1zOiB7XG4gIGlzT25EZW1hbmRSZXZhbGlkYXRlPzogYm9vbGVhblxuICBpc1JldmFsaWRhdGU/OiBib29sZWFuXG59KTogJ29uLWRlbWFuZCcgfCAnc3RhbGUnIHwgdW5kZWZpbmVkIHtcbiAgaWYgKHBhcmFtcy5pc09uRGVtYW5kUmV2YWxpZGF0ZSkge1xuICAgIHJldHVybiAnb24tZGVtYW5kJ1xuICB9XG4gIGlmIChwYXJhbXMuaXNSZXZhbGlkYXRlKSB7XG4gICAgcmV0dXJuICdzdGFsZSdcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkXG59XG4iXSwibmFtZXMiOlsiZ2V0UmV2YWxpZGF0ZVJlYXNvbiIsInBhcmFtcyIsImlzT25EZW1hbmRSZXZhbGlkYXRlIiwiaXNSZXZhbGlkYXRlIiwidW5kZWZpbmVkIl0sIm1hcHBpbmdzIjoiOzs7QUFBTyxTQUFTQSxvQkFBb0JDLE1BR25DO0lBQ0MsSUFBSUEsT0FBT0Msb0JBQW9CLEVBQUU7UUFDL0IsT0FBTztJQUNUO0lBQ0EsSUFBSUQsT0FBT0UsWUFBWSxFQUFFO1FBQ3ZCLE9BQU87SUFDVDtJQUNBLE9BQU9DO0FBQ1QiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNjU4LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zcmMvc2hhcmVkL2xpYi9wYWdlLXBhdGgvbm9ybWFsaXplLWRhdGEtcGF0aC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIHN0cmlwIF9uZXh0L2RhdGEvPGJ1aWxkLWlkPi8gcHJlZml4IGFuZCAuanNvbiBzdWZmaXhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZURhdGFQYXRoKHBhdGhuYW1lOiBzdHJpbmcpIHtcbiAgcGF0aG5hbWUgPSBwYXRobmFtZVxuICAgIC5yZXBsYWNlKC9cXC9fbmV4dFxcL2RhdGFcXC9bXi9dezEsfS8sICcnKVxuICAgIC5yZXBsYWNlKC9cXC5qc29uJC8sICcnKVxuXG4gIGlmIChwYXRobmFtZSA9PT0gJy9pbmRleCcpIHtcbiAgICByZXR1cm4gJy8nXG4gIH1cbiAgcmV0dXJuIHBhdGhuYW1lXG59XG4iXSwibmFtZXMiOlsibm9ybWFsaXplRGF0YVBhdGgiLCJwYXRobmFtZSIsInJlcGxhY2UiXSwibWFwcGluZ3MiOiJBQUFBOztDQUVDLEdBQ0Q7OztBQUFPLFNBQVNBLGtCQUFrQkMsUUFBZ0I7SUFDaERBLFdBQVdBLFNBQ1JDLE9BQU8sQ0FBQywyQkFBMkIsSUFDbkNBLE9BQU8sQ0FBQyxXQUFXO0lBRXRCLElBQUlELGFBQWEsVUFBVTtRQUN6QixPQUFPO0lBQ1Q7SUFDQSxPQUFPQTtBQUNUIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDY3NCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL2xpYi9kZXRhY2hlZC1wcm9taXNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQSBgUHJvbWlzZS53aXRoUmVzb2x2ZXJzYCBpbXBsZW1lbnRhdGlvbiB0aGF0IGV4cG9zZXMgdGhlIGByZXNvbHZlYCBhbmRcbiAqIGByZWplY3RgIGZ1bmN0aW9ucyBvbiBhIGBQcm9taXNlYC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vdGMzOS5lcy9wcm9wb3NhbC1wcm9taXNlLXdpdGgtcmVzb2x2ZXJzL1xuICovXG5leHBvcnQgY2xhc3MgRGV0YWNoZWRQcm9taXNlPFQgPSBhbnk+IHtcbiAgcHVibGljIHJlYWRvbmx5IHJlc29sdmU6ICh2YWx1ZTogVCB8IFByb21pc2VMaWtlPFQ+KSA9PiB2b2lkXG4gIHB1YmxpYyByZWFkb25seSByZWplY3Q6IChyZWFzb246IGFueSkgPT4gdm9pZFxuICBwdWJsaWMgcmVhZG9ubHkgcHJvbWlzZTogUHJvbWlzZTxUPlxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGxldCByZXNvbHZlOiAodmFsdWU6IFQgfCBQcm9taXNlTGlrZTxUPikgPT4gdm9pZFxuICAgIGxldCByZWplY3Q6IChyZWFzb246IGFueSkgPT4gdm9pZFxuXG4gICAgLy8gQ3JlYXRlIHRoZSBwcm9taXNlIGFuZCBhc3NpZ24gdGhlIHJlc29sdmVycyB0byB0aGUgb2JqZWN0LlxuICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlPFQ+KChyZXMsIHJlaikgPT4ge1xuICAgICAgcmVzb2x2ZSA9IHJlc1xuICAgICAgcmVqZWN0ID0gcmVqXG4gICAgfSlcblxuICAgIC8vIFdlIGtub3cgdGhhdCByZXNvbHZlcnMgaXMgZGVmaW5lZCBiZWNhdXNlIHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHJ1bnNcbiAgICAvLyBzeW5jaHJvbm91c2x5LlxuICAgIHRoaXMucmVzb2x2ZSA9IHJlc29sdmUhXG4gICAgdGhpcy5yZWplY3QgPSByZWplY3QhXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJEZXRhY2hlZFByb21pc2UiLCJjb25zdHJ1Y3RvciIsInJlc29sdmUiLCJyZWplY3QiLCJwcm9taXNlIiwiUHJvbWlzZSIsInJlcyIsInJlaiJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7O0NBS0MsR0FDRDs7O0FBQU8sTUFBTUE7SUFLWEMsYUFBYztRQUNaLElBQUlDO1FBQ0osSUFBSUM7UUFFSiw2REFBNkQ7UUFDN0QsSUFBSSxDQUFDQyxPQUFPLEdBQUcsSUFBSUMsUUFBVyxDQUFDQyxLQUFLQztZQUNsQ0wsVUFBVUk7WUFDVkgsU0FBU0k7UUFDWDtRQUVBLHlFQUF5RTtRQUN6RSxpQkFBaUI7UUFDakIsSUFBSSxDQUFDTCxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDQyxNQUFNLEdBQUdBO0lBQ2hCO0FBQ0YiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNzAxLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zcmMvbGliL2JhdGNoZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBTY2hlZHVsZXJGbiB9IGZyb20gJy4vc2NoZWR1bGVyJ1xuXG5pbXBvcnQgeyBEZXRhY2hlZFByb21pc2UgfSBmcm9tICcuL2RldGFjaGVkLXByb21pc2UnXG5cbnR5cGUgQ2FjaGVLZXlGbjxLLCBDIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyIHwgbnVsbD4gPSAoXG4gIGtleTogS1xuKSA9PiBQcm9taXNlTGlrZTxDPiB8IENcblxudHlwZSBCYXRjaGVyT3B0aW9uczxLLCBDIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyIHwgbnVsbD4gPSB7XG4gIGNhY2hlS2V5Rm4/OiBDYWNoZUtleUZuPEssIEM+XG4gIHNjaGVkdWxlckZuPzogU2NoZWR1bGVyRm48dm9pZD5cbn1cblxudHlwZSBXb3JrRm48ViwgQz4gPSAoXG4gIGtleTogQyxcbiAgcmVzb2x2ZTogKHZhbHVlOiBWIHwgUHJvbWlzZUxpa2U8Vj4pID0+IHZvaWRcbikgPT4gUHJvbWlzZTxWPlxuXG4vKipcbiAqIEEgd3JhcHBlciBmb3IgYSBmdW5jdGlvbiB0aGF0IHdpbGwgb25seSBhbGxvdyBvbmUgY2FsbCB0byB0aGUgZnVuY3Rpb24gdG9cbiAqIGV4ZWN1dGUgYXQgYSB0aW1lLlxuICovXG5leHBvcnQgY2xhc3MgQmF0Y2hlcjxLLCBWLCBDIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyIHwgbnVsbD4ge1xuICBwcml2YXRlIHJlYWRvbmx5IHBlbmRpbmcgPSBuZXcgTWFwPEMsIFByb21pc2U8Vj4+KClcblxuICBwcm90ZWN0ZWQgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBjYWNoZUtleUZuPzogQ2FjaGVLZXlGbjxLLCBDPixcbiAgICAvKipcbiAgICAgKiBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgdG8gc2NoZWR1bGUgdGhlIHdyYXBwZWQgZnVuY3Rpb24gdG8gYmVcbiAgICAgKiBleGVjdXRlZC4gVGhpcyBkZWZhdWx0cyB0byBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBleGVjdXRlIHRoZSBmdW5jdGlvblxuICAgICAqIGltbWVkaWF0ZWx5LlxuICAgICAqL1xuICAgIHByaXZhdGUgcmVhZG9ubHkgc2NoZWR1bGVyRm46IFNjaGVkdWxlckZuPHZvaWQ+ID0gKGZuKSA9PiBmbigpXG4gICkge31cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBQZW5kaW5nV3JhcHBlci4gSWYgdGhlIGtleSBleHRlbmRzIGEgc3RyaW5nIG9yXG4gICAqIG51bWJlciwgdGhlIGtleSB3aWxsIGJlIHVzZWQgYXMgdGhlIGNhY2hlIGtleS4gSWYgdGhlIGtleSBpcyBhbiBvYmplY3QsIGFcbiAgICogY2FjaGUga2V5IGZ1bmN0aW9uIG11c3QgYmUgcHJvdmlkZWQuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGNyZWF0ZTxLIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyIHwgbnVsbCwgVj4oXG4gICAgb3B0aW9ucz86IEJhdGNoZXJPcHRpb25zPEssIEs+XG4gICk6IEJhdGNoZXI8SywgViwgSz5cbiAgcHVibGljIHN0YXRpYyBjcmVhdGU8SywgViwgQyBleHRlbmRzIHN0cmluZyB8IG51bWJlciB8IG51bGw+KFxuICAgIG9wdGlvbnM6IEJhdGNoZXJPcHRpb25zPEssIEM+ICZcbiAgICAgIFJlcXVpcmVkPFBpY2s8QmF0Y2hlck9wdGlvbnM8SywgQz4sICdjYWNoZUtleUZuJz4+XG4gICk6IEJhdGNoZXI8SywgViwgQz5cbiAgcHVibGljIHN0YXRpYyBjcmVhdGU8SywgViwgQyBleHRlbmRzIHN0cmluZyB8IG51bWJlciB8IG51bGw+KFxuICAgIG9wdGlvbnM/OiBCYXRjaGVyT3B0aW9uczxLLCBDPlxuICApOiBCYXRjaGVyPEssIFYsIEM+IHtcbiAgICByZXR1cm4gbmV3IEJhdGNoZXI8SywgViwgQz4ob3B0aW9ucz8uY2FjaGVLZXlGbiwgb3B0aW9ucz8uc2NoZWR1bGVyRm4pXG4gIH1cblxuICAvKipcbiAgICogV3JhcHMgYSBmdW5jdGlvbiBpbiBhIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkIG9yIHJlamVjdGVkIG9ubHkgb25jZVxuICAgKiBmb3IgYSBnaXZlbiBrZXkuIFRoaXMgd2lsbCBhbGxvdyBtdWx0aXBsZSBjYWxscyB0byB0aGUgZnVuY3Rpb24gdG8gYmVcbiAgICogbWFkZSwgYnV0IG9ubHkgb25lIHdpbGwgYmUgZXhlY3V0ZWQgYXQgYSB0aW1lLiBUaGUgcmVzdWx0IG9mIHRoZSBmaXJzdFxuICAgKiBjYWxsIHdpbGwgYmUgcmV0dXJuZWQgdG8gYWxsIGNhbGxlcnMuXG4gICAqXG4gICAqIEBwYXJhbSBrZXkgdGhlIGtleSB0byB1c2UgZm9yIHRoZSBjYWNoZVxuICAgKiBAcGFyYW0gZm4gdGhlIGZ1bmN0aW9uIHRvIHdyYXBcbiAgICogQHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHJlc3VsdCBvZiB0aGUgZnVuY3Rpb25cbiAgICovXG4gIHB1YmxpYyBhc3luYyBiYXRjaChrZXk6IEssIGZuOiBXb3JrRm48ViwgQz4pOiBQcm9taXNlPFY+IHtcbiAgICBjb25zdCBjYWNoZUtleSA9ICh0aGlzLmNhY2hlS2V5Rm4gPyBhd2FpdCB0aGlzLmNhY2hlS2V5Rm4oa2V5KSA6IGtleSkgYXMgQ1xuICAgIGlmIChjYWNoZUtleSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZuKGNhY2hlS2V5LCBQcm9taXNlLnJlc29sdmUpXG4gICAgfVxuXG4gICAgY29uc3QgcGVuZGluZyA9IHRoaXMucGVuZGluZy5nZXQoY2FjaGVLZXkpXG4gICAgaWYgKHBlbmRpbmcpIHJldHVybiBwZW5kaW5nXG5cbiAgICBjb25zdCB7IHByb21pc2UsIHJlc29sdmUsIHJlamVjdCB9ID0gbmV3IERldGFjaGVkUHJvbWlzZTxWPigpXG4gICAgdGhpcy5wZW5kaW5nLnNldChjYWNoZUtleSwgcHJvbWlzZSlcblxuICAgIHRoaXMuc2NoZWR1bGVyRm4oYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZm4oY2FjaGVLZXksIHJlc29sdmUpXG5cbiAgICAgICAgLy8gUmVzb2x2aW5nIGEgcHJvbWlzZSBtdWx0aXBsZSB0aW1lcyBpcyBhIG5vLW9wLCBzbyB3ZSBjYW4gc2FmZWx5XG4gICAgICAgIC8vIHJlc29sdmUgYWxsIHBlbmRpbmcgcHJvbWlzZXMgd2l0aCB0aGUgc2FtZSByZXN1bHQuXG4gICAgICAgIHJlc29sdmUocmVzdWx0KVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpXG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzLnBlbmRpbmcuZGVsZXRlKGNhY2hlS2V5KVxuICAgICAgfVxuICAgIH0pXG5cbiAgICByZXR1cm4gcHJvbWlzZVxuICB9XG59XG4iXSwibmFtZXMiOlsiRGV0YWNoZWRQcm9taXNlIiwiQmF0Y2hlciIsImNhY2hlS2V5Rm4iLCJzY2hlZHVsZXJGbiIsImZuIiwicGVuZGluZyIsIk1hcCIsImNyZWF0ZSIsIm9wdGlvbnMiLCJiYXRjaCIsImtleSIsImNhY2hlS2V5IiwiUHJvbWlzZSIsInJlc29sdmUiLCJnZXQiLCJwcm9taXNlIiwicmVqZWN0Iiwic2V0IiwicmVzdWx0IiwiZXJyIiwiZGVsZXRlIl0sIm1hcHBpbmdzIjoiOzs7QUFFQSxTQUFTQSxlQUFlLFFBQVEscUJBQW9COztBQW9CN0MsTUFBTUM7SUFHWCxZQUNtQkMsVUFBNkIsRUFDOUM7Ozs7S0FJQyxHQUNnQkMsY0FBaUMsQ0FBQ0MsS0FBT0EsSUFBSSxDQUM5RDthQVBpQkYsVUFBQUEsR0FBQUE7YUFNQUMsV0FBQUEsR0FBQUE7YUFURkUsT0FBQUEsR0FBVSxJQUFJQztJQVU1QjtJQWNILE9BQWNDLE9BQ1pDLE9BQThCLEVBQ1o7UUFDbEIsT0FBTyxJQUFJUCxRQUFpQk8sV0FBQUEsT0FBQUEsS0FBQUEsSUFBQUEsUUFBU04sVUFBVSxFQUFFTSxXQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxRQUFTTCxXQUFXO0lBQ3ZFO0lBRUE7Ozs7Ozs7OztHQVNDLEdBQ0QsTUFBYU0sTUFBTUMsR0FBTSxFQUFFTixFQUFnQixFQUFjO1FBQ3ZELE1BQU1PLFdBQVksSUFBSSxDQUFDVCxVQUFVLEdBQUcsTUFBTSxJQUFJLENBQUNBLFVBQVUsQ0FBQ1EsT0FBT0E7UUFDakUsSUFBSUMsYUFBYSxNQUFNO1lBQ3JCLE9BQU9QLEdBQUdPLFVBQVVDLFFBQVFDLE9BQU87UUFDckM7UUFFQSxNQUFNUixVQUFVLElBQUksQ0FBQ0EsT0FBTyxDQUFDUyxHQUFHLENBQUNIO1FBQ2pDLElBQUlOLFNBQVMsT0FBT0E7UUFFcEIsTUFBTSxFQUFFVSxPQUFPLEVBQUVGLE9BQU8sRUFBRUcsTUFBTSxFQUFFLEdBQUcsK0pBQUloQixrQkFBQUE7UUFDekMsSUFBSSxDQUFDSyxPQUFPLENBQUNZLEdBQUcsQ0FBQ04sVUFBVUk7UUFFM0IsSUFBSSxDQUFDWixXQUFXLENBQUM7WUFDZixJQUFJO2dCQUNGLE1BQU1lLFNBQVMsTUFBTWQsR0FBR08sVUFBVUU7Z0JBRWxDLGtFQUFrRTtnQkFDbEUscURBQXFEO2dCQUNyREEsUUFBUUs7WUFDVixFQUFFLE9BQU9DLEtBQUs7Z0JBQ1pILE9BQU9HO1lBQ1QsU0FBVTtnQkFDUixJQUFJLENBQUNkLE9BQU8sQ0FBQ2UsTUFBTSxDQUFDVDtZQUN0QjtRQUNGO1FBRUEsT0FBT0k7SUFDVDtBQUNGIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDc1NiwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL2xpYi9zY2hlZHVsZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHR5cGUgU2NoZWR1bGVkRm48VCA9IHZvaWQ+ID0gKCkgPT4gVCB8IFByb21pc2VMaWtlPFQ+XG5leHBvcnQgdHlwZSBTY2hlZHVsZXJGbjxUID0gdm9pZD4gPSAoY2I6IFNjaGVkdWxlZEZuPFQ+KSA9PiB2b2lkXG5cbi8qKlxuICogU2NoZWR1bGVzIGEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIHRoZSBuZXh0IHRpY2sgYWZ0ZXIgdGhlIG90aGVyIHByb21pc2VzXG4gKiBoYXZlIGJlZW4gcmVzb2x2ZWQuXG4gKlxuICogQHBhcmFtIGNiIHRoZSBmdW5jdGlvbiB0byBzY2hlZHVsZVxuICovXG5leHBvcnQgY29uc3Qgc2NoZWR1bGVPbk5leHRUaWNrID0gKGNiOiBTY2hlZHVsZWRGbjx2b2lkPikgPT4ge1xuICAvLyBXZSB1c2UgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigpIGhlcmUgc28gdGhhdCB0aGUgb3BlcmF0aW9uIGlzIHNjaGVkdWxlZCBhdFxuICAvLyB0aGUgZW5kIG9mIHRoZSBwcm9taXNlIGpvYiBxdWV1ZSwgd2UgdGhlbiBhZGQgaXQgdG8gdGhlIG5leHQgcHJvY2VzcyB0aWNrXG4gIC8vIHRvIGVuc3VyZSBpdCdzIGV2YWx1YXRlZCBhZnRlcndhcmRzLlxuICAvL1xuICAvLyBUaGlzIHdhcyBpbnNwaXJlZCBieSB0aGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIERhdGFMb2FkZXIgaW50ZXJmYWNlOiBodHRwczovL2dpdGh1Yi5jb20vZ3JhcGhxbC9kYXRhbG9hZGVyL2Jsb2IvZDMzNmJkMTUyODI2NjRlMGJlNGI0YTY1N2NiNzk2ZjA5YmFmYmM2Yi9zcmMvaW5kZXguanMjTDIxMy1MMjU1XG4gIC8vXG4gIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgIGlmIChwcm9jZXNzLmVudi5ORVhUX1JVTlRJTUUgPT09ICdlZGdlJykge1xuICAgICAgc2V0VGltZW91dChjYiwgMClcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjYilcbiAgICB9XG4gIH0pXG59XG5cbi8qKlxuICogU2NoZWR1bGVzIGEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHVzaW5nIGBzZXRJbW1lZGlhdGVgIG9yIGBzZXRUaW1lb3V0YCBpZlxuICogYHNldEltbWVkaWF0ZWAgaXMgbm90IGF2YWlsYWJsZSAobGlrZSBpbiB0aGUgRWRnZSBydW50aW1lKS5cbiAqXG4gKiBAcGFyYW0gY2IgdGhlIGZ1bmN0aW9uIHRvIHNjaGVkdWxlXG4gKi9cbmV4cG9ydCBjb25zdCBzY2hlZHVsZUltbWVkaWF0ZSA9IChjYjogU2NoZWR1bGVkRm48dm9pZD4pOiB2b2lkID0+IHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5FWFRfUlVOVElNRSA9PT0gJ2VkZ2UnKSB7XG4gICAgc2V0VGltZW91dChjYiwgMClcbiAgfSBlbHNlIHtcbiAgICBzZXRJbW1lZGlhdGUoY2IpXG4gIH1cbn1cblxuLyoqXG4gKiByZXR1cm5zIGEgcHJvbWlzZSB0aGFuIHJlc29sdmVzIGluIGEgZnV0dXJlIHRhc2suIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IHRoZSB0YXNrIGl0IHJlc29sdmVzIGluXG4gKiB3aWxsIGJlIHRoZSBuZXh0IHRhc2sgYnV0IGlmIHlvdSBhd2FpdCBpdCB5b3UgY2FuIGF0IGxlYXN0IGJlIHN1cmUgdGhhdCB0aGUgY3VycmVudCB0YXNrIGlzIG92ZXIgYW5kXG4gKiBtb3N0IHVzZWZ1bGx5IHRoYXQgdGhlIGVudGlyZSBtaWNyb3Rhc2sgcXVldWUgb2YgdGhlIGN1cnJlbnQgdGFzayBoYXMgYmVlbiBlbXB0aWVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXRMZWFzdE9uZVRhc2soKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSkgPT4gc2NoZWR1bGVJbW1lZGlhdGUocmVzb2x2ZSkpXG59XG5cbi8qKlxuICogVGhpcyB1dGlsaXR5IGZ1bmN0aW9uIGlzIGV4dHJhY3RlZCB0byBtYWtlIGl0IGVhc2llciB0byBmaW5kIHBsYWNlcyB3aGVyZSB3ZSBhcmUgZG9pbmdcbiAqIHNwZWNpZmljIHRpbWluZyB0cmlja3MgdG8gdHJ5IHRvIHNjaGVkdWxlIHdvcmsgYWZ0ZXIgUmVhY3QgaGFzIHJlbmRlcmVkLiBUaGlzIGlzIGVzcGVjaWFsbHlcbiAqIGltcG9ydGFudCBhdCB0aGUgbW9tZW50IGJlY2F1c2UgTmV4dC5qcyB1c2VzIHRoZSBlZGdlIGJ1aWxkcyBvZiBSZWFjdCB3aGljaCB1c2Ugc2V0VGltZW91dCB0b1xuICogc2NoZWR1bGUgd29yayB3aGVuIHlvdSBtaWdodCBleHBlY3QgdGhhdCBzb21ldGhpbmcgbGlrZSBzZXRJbW1lZGlhdGUgd291bGQgZG8gdGhlIHRyaWNrLlxuICpcbiAqIExvbmcgdGVybSB3ZSBzaG91bGQgc3dpdGNoIHRvIHRoZSBub2RlIHZlcnNpb25zIG9mIFJlYWN0IHJlbmRlcmluZyB3aGVuIHBvc3NpYmxlIGFuZCB0aGVuXG4gKiB1cGRhdGUgdGhpcyB0byB1c2Ugc2V0SW1tZWRpYXRlIHJhdGhlciB0aGFuIHNldFRpbWVvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdhaXRBdExlYXN0T25lUmVhY3RSZW5kZXJUYXNrKCk6IFByb21pc2U8dm9pZD4ge1xuICBpZiAocHJvY2Vzcy5lbnYuTkVYVF9SVU5USU1FID09PSAnZWRnZScpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHIpID0+IHNldFRpbWVvdXQociwgMCkpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyKSA9PiBzZXRJbW1lZGlhdGUocikpXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJzY2hlZHVsZU9uTmV4dFRpY2siLCJjYiIsIlByb21pc2UiLCJyZXNvbHZlIiwidGhlbiIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1JVTlRJTUUiLCJzZXRUaW1lb3V0IiwibmV4dFRpY2siLCJzY2hlZHVsZUltbWVkaWF0ZSIsInNldEltbWVkaWF0ZSIsImF0TGVhc3RPbmVUYXNrIiwid2FpdEF0TGVhc3RPbmVSZWFjdFJlbmRlclRhc2siLCJyIl0sIm1hcHBpbmdzIjoiQUFHQTs7Ozs7Q0FLQyxHQUNEOzs7Ozs7QUFBTyxNQUFNQSxxQkFBcUIsQ0FBQ0M7SUFDakMsNkVBQTZFO0lBQzdFLDRFQUE0RTtJQUM1RSx1Q0FBdUM7SUFDdkMsRUFBRTtJQUNGLGtMQUFrTDtJQUNsTCxFQUFFO0lBQ0ZDLFFBQVFDLE9BQU8sR0FBR0MsSUFBSSxDQUFDO1FBQ3JCLElBQUlDLFFBQVFDLEdBQUcsQ0FBQ0MsWUFBWSxLQUFLLFFBQVE7O2FBRWxDO1lBQ0xGLFFBQVFJLFFBQVEsQ0FBQ1I7UUFDbkI7SUFDRjtBQUNGLEVBQUM7QUFRTSxNQUFNUyxvQkFBb0IsQ0FBQ1Q7SUFDaEMsSUFBSUksUUFBUUMsR0FBRyxDQUFDQyxZQUFZLEtBQUssUUFBUTs7U0FFbEM7UUFDTEksYUFBYVY7SUFDZjtBQUNGLEVBQUM7QUFPTSxTQUFTVztJQUNkLE9BQU8sSUFBSVYsUUFBYyxDQUFDQyxVQUFZTyxrQkFBa0JQO0FBQzFEO0FBV08sU0FBU1U7SUFDZCxJQUFJUixRQUFRQyxHQUFHLENBQUNDLFlBQVksS0FBSyxRQUFROztTQUVsQztRQUNMLE9BQU8sSUFBSUwsUUFBUSxDQUFDWSxJQUFNSCxhQUFhRztJQUN6QztBQUNGIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDgwMywgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL3NlcnZlci9yZXNwb25zZS1jYWNoZS90eXBlcy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IE91dGdvaW5nSHR0cEhlYWRlcnMgfSBmcm9tICdodHRwJ1xuaW1wb3J0IHR5cGUgUmVuZGVyUmVzdWx0IGZyb20gJy4uL3JlbmRlci1yZXN1bHQnXG5pbXBvcnQgdHlwZSB7IENhY2hlQ29udHJvbCwgUmV2YWxpZGF0ZSB9IGZyb20gJy4uL2xpYi9jYWNoZS1jb250cm9sJ1xuaW1wb3J0IHR5cGUgeyBSb3V0ZUtpbmQgfSBmcm9tICcuLi9yb3V0ZS1raW5kJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFJlc3BvbnNlQ2FjaGVCYXNlIHtcbiAgZ2V0KFxuICAgIGtleTogc3RyaW5nIHwgbnVsbCxcbiAgICByZXNwb25zZUdlbmVyYXRvcjogUmVzcG9uc2VHZW5lcmF0b3IsXG4gICAgY29udGV4dDoge1xuICAgICAgaXNPbkRlbWFuZFJldmFsaWRhdGU/OiBib29sZWFuXG4gICAgICBpc1ByZWZldGNoPzogYm9vbGVhblxuICAgICAgaW5jcmVtZW50YWxDYWNoZTogSW5jcmVtZW50YWxDYWNoZVxuICAgICAgLyoqXG4gICAgICAgKiBUaGlzIGlzIGEgaGludCB0byB0aGUgY2FjaGUgdG8gaGVscCBpdCBkZXRlcm1pbmUgd2hhdCBraW5kIG9mIHJvdXRlXG4gICAgICAgKiB0aGlzIGlzIHNvIGl0IGtub3dzIHdoZXJlIHRvIGxvb2sgdXAgdGhlIGNhY2hlIGVudHJ5IGZyb20uIElmIG5vdFxuICAgICAgICogcHJvdmlkZWQgaXQgd2lsbCB0ZXN0IHRoZSBmaWxlc3lzdGVtIHRvIGNoZWNrLlxuICAgICAgICovXG4gICAgICByb3V0ZUtpbmQ6IFJvdXRlS2luZFxuXG4gICAgICAvKipcbiAgICAgICAqIFRydWUgaWYgdGhpcyBpcyBhIGZhbGxiYWNrIHJlcXVlc3QuXG4gICAgICAgKi9cbiAgICAgIGlzRmFsbGJhY2s/OiBib29sZWFuXG5cbiAgICAgIC8qKlxuICAgICAgICogVHJ1ZSBpZiB0aGUgcm91dGUgaXMgZW5hYmxlZCBmb3IgUFBSLlxuICAgICAgICovXG4gICAgICBpc1JvdXRlUFBSRW5hYmxlZD86IGJvb2xlYW5cbiAgICB9XG4gICk6IFByb21pc2U8UmVzcG9uc2VDYWNoZUVudHJ5IHwgbnVsbD5cbn1cblxuLy8gVGhlIHNlcnZlciBjb21wb25lbnRzIEhNUiBjYWNoZSBtaWdodCBzdG9yZSBvdGhlciBkYXRhIGFzIHdlbGwgaW4gdGhlIGZ1dHVyZSxcbi8vIGF0IHdoaWNoIHBvaW50IHRoaXMgc2hvdWxkIGJlIHJlZmFjdG9yZWQgdG8gYSBkaXNjcmltaW5hdGVkIHVuaW9uIHR5cGUuXG5leHBvcnQgaW50ZXJmYWNlIFNlcnZlckNvbXBvbmVudHNIbXJDYWNoZSB7XG4gIGdldChrZXk6IHN0cmluZyk6IENhY2hlZEZldGNoRGF0YSB8IHVuZGVmaW5lZFxuICBzZXQoa2V5OiBzdHJpbmcsIGRhdGE6IENhY2hlZEZldGNoRGF0YSk6IHZvaWRcbn1cblxuZXhwb3J0IHR5cGUgQ2FjaGVkRmV0Y2hEYXRhID0ge1xuICBoZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG4gIGJvZHk6IHN0cmluZ1xuICB1cmw6IHN0cmluZ1xuICBzdGF0dXM/OiBudW1iZXJcbn1cblxuZXhwb3J0IGNvbnN0IGVudW0gQ2FjaGVkUm91dGVLaW5kIHtcbiAgQVBQX1BBR0UgPSAnQVBQX1BBR0UnLFxuICBBUFBfUk9VVEUgPSAnQVBQX1JPVVRFJyxcbiAgUEFHRVMgPSAnUEFHRVMnLFxuICBGRVRDSCA9ICdGRVRDSCcsXG4gIFJFRElSRUNUID0gJ1JFRElSRUNUJyxcbiAgSU1BR0UgPSAnSU1BR0UnLFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIENhY2hlZEZldGNoVmFsdWUge1xuICBraW5kOiBDYWNoZWRSb3V0ZUtpbmQuRkVUQ0hcbiAgZGF0YTogQ2FjaGVkRmV0Y2hEYXRhXG4gIC8vIHRhZ3MgYXJlIG9ubHkgcHJlc2VudCB3aXRoIGZpbGUtc3lzdGVtLWNhY2hlXG4gIC8vIGZldGNoIGNhY2hlIHN0b3JlcyB0YWdzIG91dHNpZGUgb2YgY2FjaGUgZW50cnlcbiAgdGFncz86IHN0cmluZ1tdXG4gIHJldmFsaWRhdGU6IG51bWJlclxufVxuXG5leHBvcnQgaW50ZXJmYWNlIENhY2hlZFJlZGlyZWN0VmFsdWUge1xuICBraW5kOiBDYWNoZWRSb3V0ZUtpbmQuUkVESVJFQ1RcbiAgcHJvcHM6IE9iamVjdFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIENhY2hlZEFwcFBhZ2VWYWx1ZSB7XG4gIGtpbmQ6IENhY2hlZFJvdXRlS2luZC5BUFBfUEFHRVxuICAvLyB0aGlzIG5lZWRzIHRvIGJlIGEgUmVuZGVyUmVzdWx0IHNvIHNpbmNlIHJlbmRlclJlc3BvbnNlXG4gIC8vIGV4cGVjdHMgdGhhdCB0eXBlIGluc3RlYWQgb2YgYSBzdHJpbmdcbiAgaHRtbDogUmVuZGVyUmVzdWx0XG4gIHJzY0RhdGE6IEJ1ZmZlciB8IHVuZGVmaW5lZFxuICBzdGF0dXM6IG51bWJlciB8IHVuZGVmaW5lZFxuICBwb3N0cG9uZWQ6IHN0cmluZyB8IHVuZGVmaW5lZFxuICBoZWFkZXJzOiBPdXRnb2luZ0h0dHBIZWFkZXJzIHwgdW5kZWZpbmVkXG4gIHNlZ21lbnREYXRhOiBNYXA8c3RyaW5nLCBCdWZmZXI+IHwgdW5kZWZpbmVkXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2FjaGVkUGFnZVZhbHVlIHtcbiAga2luZDogQ2FjaGVkUm91dGVLaW5kLlBBR0VTXG4gIC8vIHRoaXMgbmVlZHMgdG8gYmUgYSBSZW5kZXJSZXN1bHQgc28gc2luY2UgcmVuZGVyUmVzcG9uc2VcbiAgLy8gZXhwZWN0cyB0aGF0IHR5cGUgaW5zdGVhZCBvZiBhIHN0cmluZ1xuICBodG1sOiBSZW5kZXJSZXN1bHRcbiAgcGFnZURhdGE6IE9iamVjdFxuICBzdGF0dXM6IG51bWJlciB8IHVuZGVmaW5lZFxuICBoZWFkZXJzOiBPdXRnb2luZ0h0dHBIZWFkZXJzIHwgdW5kZWZpbmVkXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2FjaGVkUm91dGVWYWx1ZSB7XG4gIGtpbmQ6IENhY2hlZFJvdXRlS2luZC5BUFBfUk9VVEVcbiAgLy8gdGhpcyBuZWVkcyB0byBiZSBhIFJlbmRlclJlc3VsdCBzbyBzaW5jZSByZW5kZXJSZXNwb25zZVxuICAvLyBleHBlY3RzIHRoYXQgdHlwZSBpbnN0ZWFkIG9mIGEgc3RyaW5nXG4gIGJvZHk6IEJ1ZmZlclxuICBzdGF0dXM6IG51bWJlclxuICBoZWFkZXJzOiBPdXRnb2luZ0h0dHBIZWFkZXJzXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2FjaGVkSW1hZ2VWYWx1ZSB7XG4gIGtpbmQ6IENhY2hlZFJvdXRlS2luZC5JTUFHRVxuICBldGFnOiBzdHJpbmdcbiAgdXBzdHJlYW1FdGFnOiBzdHJpbmdcbiAgYnVmZmVyOiBCdWZmZXJcbiAgZXh0ZW5zaW9uOiBzdHJpbmdcbiAgaXNNaXNzPzogYm9vbGVhblxuICBpc1N0YWxlPzogYm9vbGVhblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEluY3JlbWVudGFsQ2FjaGVkQXBwUGFnZVZhbHVlIHtcbiAga2luZDogQ2FjaGVkUm91dGVLaW5kLkFQUF9QQUdFXG4gIC8vIHRoaXMgbmVlZHMgdG8gYmUgYSBzdHJpbmcgc2luY2UgdGhlIGNhY2hlIGV4cGVjdHMgdG8gc3RvcmVcbiAgLy8gdGhlIHN0cmluZyB2YWx1ZVxuICBodG1sOiBzdHJpbmdcbiAgcnNjRGF0YTogQnVmZmVyIHwgdW5kZWZpbmVkXG4gIGhlYWRlcnM6IE91dGdvaW5nSHR0cEhlYWRlcnMgfCB1bmRlZmluZWRcbiAgcG9zdHBvbmVkOiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgc3RhdHVzOiBudW1iZXIgfCB1bmRlZmluZWRcbiAgc2VnbWVudERhdGE6IE1hcDxzdHJpbmcsIEJ1ZmZlcj4gfCB1bmRlZmluZWRcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbmNyZW1lbnRhbENhY2hlZFBhZ2VWYWx1ZSB7XG4gIGtpbmQ6IENhY2hlZFJvdXRlS2luZC5QQUdFU1xuICAvLyB0aGlzIG5lZWRzIHRvIGJlIGEgc3RyaW5nIHNpbmNlIHRoZSBjYWNoZSBleHBlY3RzIHRvIHN0b3JlXG4gIC8vIHRoZSBzdHJpbmcgdmFsdWVcbiAgaHRtbDogc3RyaW5nXG4gIHBhZ2VEYXRhOiBPYmplY3RcbiAgaGVhZGVyczogT3V0Z29pbmdIdHRwSGVhZGVycyB8IHVuZGVmaW5lZFxuICBzdGF0dXM6IG51bWJlciB8IHVuZGVmaW5lZFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEluY3JlbWVudGFsUmVzcG9uc2VDYWNoZUVudHJ5IHtcbiAgY2FjaGVDb250cm9sPzogQ2FjaGVDb250cm9sXG4gIC8qKlxuICAgKiB0aW1lc3RhbXAgaW4gbWlsbGlzZWNvbmRzIHRvIHJldmFsaWRhdGUgYWZ0ZXJcbiAgICovXG4gIHJldmFsaWRhdGVBZnRlcj86IFJldmFsaWRhdGVcbiAgLyoqXG4gICAqIGAtMWAgaGVyZSBkaWN0YXRlcyBhIGJsb2NraW5nIHJldmFsaWRhdGUgc2hvdWxkIGJlIHVzZWRcbiAgICovXG4gIGlzU3RhbGU/OiBib29sZWFuIHwgLTFcbiAgaXNNaXNzPzogYm9vbGVhblxuICB2YWx1ZTogRXhjbHVkZTxJbmNyZW1lbnRhbENhY2hlVmFsdWUsIENhY2hlZEZldGNoVmFsdWU+IHwgbnVsbFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEluY3JlbWVudGFsRmV0Y2hDYWNoZUVudHJ5IHtcbiAgLyoqXG4gICAqIGAtMWAgaGVyZSBkaWN0YXRlcyBhIGJsb2NraW5nIHJldmFsaWRhdGUgc2hvdWxkIGJlIHVzZWRcbiAgICovXG4gIGlzU3RhbGU/OiBib29sZWFuIHwgLTFcbiAgdmFsdWU6IENhY2hlZEZldGNoVmFsdWVcbn1cblxuZXhwb3J0IHR5cGUgSW5jcmVtZW50YWxDYWNoZUVudHJ5ID1cbiAgfCBJbmNyZW1lbnRhbFJlc3BvbnNlQ2FjaGVFbnRyeVxuICB8IEluY3JlbWVudGFsRmV0Y2hDYWNoZUVudHJ5XG5cbmV4cG9ydCB0eXBlIEluY3JlbWVudGFsQ2FjaGVWYWx1ZSA9XG4gIHwgQ2FjaGVkUmVkaXJlY3RWYWx1ZVxuICB8IEluY3JlbWVudGFsQ2FjaGVkUGFnZVZhbHVlXG4gIHwgSW5jcmVtZW50YWxDYWNoZWRBcHBQYWdlVmFsdWVcbiAgfCBDYWNoZWRJbWFnZVZhbHVlXG4gIHwgQ2FjaGVkRmV0Y2hWYWx1ZVxuICB8IENhY2hlZFJvdXRlVmFsdWVcblxuZXhwb3J0IHR5cGUgUmVzcG9uc2VDYWNoZVZhbHVlID1cbiAgfCBDYWNoZWRSZWRpcmVjdFZhbHVlXG4gIHwgQ2FjaGVkUGFnZVZhbHVlXG4gIHwgQ2FjaGVkQXBwUGFnZVZhbHVlXG4gIHwgQ2FjaGVkSW1hZ2VWYWx1ZVxuICB8IENhY2hlZFJvdXRlVmFsdWVcblxuZXhwb3J0IHR5cGUgUmVzcG9uc2VDYWNoZUVudHJ5ID0ge1xuICBjYWNoZUNvbnRyb2w/OiBDYWNoZUNvbnRyb2xcbiAgdmFsdWU6IFJlc3BvbnNlQ2FjaGVWYWx1ZSB8IG51bGxcbiAgaXNTdGFsZT86IGJvb2xlYW4gfCAtMVxuICBpc01pc3M/OiBib29sZWFuXG59XG5cbi8qKlxuICogQHBhcmFtIGhhc1Jlc29sdmVkIHdoZXRoZXIgdGhlIHJlc3BvbnNlR2VuZXJhdG9yIGhhcyByZXNvbHZlZCBpdCdzIHByb21pc2VcbiAqIEBwYXJhbSBwcmV2aW91c0NhY2hlRW50cnkgdGhlIHByZXZpb3VzIGNhY2hlIGVudHJ5IGlmIGl0IGV4aXN0cyBvciB0aGUgY3VycmVudFxuICovXG5leHBvcnQgdHlwZSBSZXNwb25zZUdlbmVyYXRvciA9IChzdGF0ZToge1xuICBoYXNSZXNvbHZlZDogYm9vbGVhblxuICBwcmV2aW91c0NhY2hlRW50cnk/OiBJbmNyZW1lbnRhbFJlc3BvbnNlQ2FjaGVFbnRyeSB8IG51bGxcbiAgaXNSZXZhbGlkYXRpbmc/OiBib29sZWFuXG4gIHNwYW4/OiBhbnlcbn0pID0+IFByb21pc2U8UmVzcG9uc2VDYWNoZUVudHJ5IHwgbnVsbD5cblxuZXhwb3J0IGNvbnN0IGVudW0gSW5jcmVtZW50YWxDYWNoZUtpbmQge1xuICBBUFBfUEFHRSA9ICdBUFBfUEFHRScsXG4gIEFQUF9ST1VURSA9ICdBUFBfUk9VVEUnLFxuICBQQUdFUyA9ICdQQUdFUycsXG4gIEZFVENIID0gJ0ZFVENIJyxcbiAgSU1BR0UgPSAnSU1BR0UnLFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdldEluY3JlbWVudGFsRmV0Y2hDYWNoZUNvbnRleHQge1xuICBraW5kOiBJbmNyZW1lbnRhbENhY2hlS2luZC5GRVRDSFxuICByZXZhbGlkYXRlPzogUmV2YWxpZGF0ZVxuICBmZXRjaFVybD86IHN0cmluZ1xuICBmZXRjaElkeD86IG51bWJlclxuICB0YWdzPzogc3RyaW5nW11cbiAgc29mdFRhZ3M/OiBzdHJpbmdbXVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdldEluY3JlbWVudGFsUmVzcG9uc2VDYWNoZUNvbnRleHQge1xuICBraW5kOiBFeGNsdWRlPEluY3JlbWVudGFsQ2FjaGVLaW5kLCBJbmNyZW1lbnRhbENhY2hlS2luZC5GRVRDSD5cblxuICAvKipcbiAgICogVHJ1ZSBpZiB0aGUgcm91dGUgaXMgZW5hYmxlZCBmb3IgUFBSLlxuICAgKi9cbiAgaXNSb3V0ZVBQUkVuYWJsZWQ/OiBib29sZWFuXG5cbiAgLyoqXG4gICAqIFRydWUgaWYgdGhpcyBpcyBhIGZhbGxiYWNrIHJlcXVlc3QuXG4gICAqL1xuICBpc0ZhbGxiYWNrOiBib29sZWFuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2V0SW5jcmVtZW50YWxGZXRjaENhY2hlQ29udGV4dCB7XG4gIGZldGNoQ2FjaGU6IHRydWVcbiAgZmV0Y2hVcmw/OiBzdHJpbmdcbiAgZmV0Y2hJZHg/OiBudW1iZXJcbiAgdGFncz86IHN0cmluZ1tdXG4gIGlzSW1wbGljaXRCdWlsZFRpbWVDYWNoZT86IGJvb2xlYW5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBTZXRJbmNyZW1lbnRhbFJlc3BvbnNlQ2FjaGVDb250ZXh0IHtcbiAgZmV0Y2hDYWNoZT86IGZhbHNlXG4gIGNhY2hlQ29udHJvbD86IENhY2hlQ29udHJvbFxuXG4gIC8qKlxuICAgKiBUcnVlIGlmIHRoZSByb3V0ZSBpcyBlbmFibGVkIGZvciBQUFIuXG4gICAqL1xuICBpc1JvdXRlUFBSRW5hYmxlZD86IGJvb2xlYW5cblxuICAvKipcbiAgICogVHJ1ZSBpZiB0aGlzIGlzIGEgZmFsbGJhY2sgcmVxdWVzdC5cbiAgICovXG4gIGlzRmFsbGJhY2s/OiBib29sZWFuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW5jcmVtZW50YWxSZXNwb25zZUNhY2hlIHtcbiAgZ2V0KFxuICAgIGNhY2hlS2V5OiBzdHJpbmcsXG4gICAgY3R4OiBHZXRJbmNyZW1lbnRhbFJlc3BvbnNlQ2FjaGVDb250ZXh0XG4gICk6IFByb21pc2U8SW5jcmVtZW50YWxSZXNwb25zZUNhY2hlRW50cnkgfCBudWxsPlxuICBzZXQoXG4gICAga2V5OiBzdHJpbmcsXG4gICAgZGF0YTogRXhjbHVkZTxJbmNyZW1lbnRhbENhY2hlVmFsdWUsIENhY2hlZEZldGNoVmFsdWU+IHwgbnVsbCxcbiAgICBjdHg6IFNldEluY3JlbWVudGFsUmVzcG9uc2VDYWNoZUNvbnRleHRcbiAgKTogUHJvbWlzZTx2b2lkPlxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEluY3JlbWVudGFsQ2FjaGUgZXh0ZW5kcyBJbmNyZW1lbnRhbFJlc3BvbnNlQ2FjaGUge1xuICBnZXQoXG4gICAgY2FjaGVLZXk6IHN0cmluZyxcbiAgICBjdHg6IEdldEluY3JlbWVudGFsRmV0Y2hDYWNoZUNvbnRleHRcbiAgKTogUHJvbWlzZTxJbmNyZW1lbnRhbEZldGNoQ2FjaGVFbnRyeSB8IG51bGw+XG4gIGdldChcbiAgICBjYWNoZUtleTogc3RyaW5nLFxuICAgIGN0eDogR2V0SW5jcmVtZW50YWxSZXNwb25zZUNhY2hlQ29udGV4dFxuICApOiBQcm9taXNlPEluY3JlbWVudGFsUmVzcG9uc2VDYWNoZUVudHJ5IHwgbnVsbD5cbiAgc2V0KFxuICAgIGtleTogc3RyaW5nLFxuICAgIGRhdGE6IENhY2hlZEZldGNoVmFsdWUgfCBudWxsLFxuICAgIGN0eDogU2V0SW5jcmVtZW50YWxGZXRjaENhY2hlQ29udGV4dFxuICApOiBQcm9taXNlPHZvaWQ+XG4gIHNldChcbiAgICBrZXk6IHN0cmluZyxcbiAgICBkYXRhOiBFeGNsdWRlPEluY3JlbWVudGFsQ2FjaGVWYWx1ZSwgQ2FjaGVkRmV0Y2hWYWx1ZT4gfCBudWxsLFxuICAgIGN0eDogU2V0SW5jcmVtZW50YWxSZXNwb25zZUNhY2hlQ29udGV4dFxuICApOiBQcm9taXNlPHZvaWQ+XG59XG4iXSwibmFtZXMiOlsiQ2FjaGVkUm91dGVLaW5kIiwiSW5jcmVtZW50YWxDYWNoZUtpbmQiXSwibWFwcGluZ3MiOiI7Ozs7QUErQ08sSUFBV0Esa0JBQUFBLFdBQUFBLEdBQUFBLFNBQUFBLGVBQUFBOzs7Ozs7O1dBQUFBO01BT2pCO0FBMElNLElBQVdDLHVCQUFBQSxXQUFBQSxHQUFBQSxTQUFBQSxvQkFBQUE7Ozs7OztXQUFBQTtNQU1qQiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA4MjgsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NyYy9zZXJ2ZXIvc3RyZWFtLXV0aWxzL2VuY29kZWQtdGFncy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgRU5DT0RFRF9UQUdTID0ge1xuICAvLyBvcGVuaW5nIHRhZ3MgZG8gbm90IGhhdmUgdGhlIGNsb3NpbmcgYD5gIHNpbmNlIHRoZXkgY2FuIGNvbnRhaW4gb3RoZXIgYXR0cmlidXRlcyBzdWNoIGFzIGA8Ym9keSBjbGFzc05hbWU9Jyc+YFxuICBPUEVOSU5HOiB7XG4gICAgLy8gPGh0bWxcbiAgICBIVE1MOiBuZXcgVWludDhBcnJheShbNjAsIDEwNCwgMTE2LCAxMDksIDEwOF0pLFxuICAgIC8vIDxib2R5XG4gICAgQk9EWTogbmV3IFVpbnQ4QXJyYXkoWzYwLCA5OCwgMTExLCAxMDAsIDEyMV0pLFxuICB9LFxuICBDTE9TRUQ6IHtcbiAgICAvLyA8L2hlYWQ+XG4gICAgSEVBRDogbmV3IFVpbnQ4QXJyYXkoWzYwLCA0NywgMTA0LCAxMDEsIDk3LCAxMDAsIDYyXSksXG4gICAgLy8gPC9ib2R5PlxuICAgIEJPRFk6IG5ldyBVaW50OEFycmF5KFs2MCwgNDcsIDk4LCAxMTEsIDEwMCwgMTIxLCA2Ml0pLFxuICAgIC8vIDwvaHRtbD5cbiAgICBIVE1MOiBuZXcgVWludDhBcnJheShbNjAsIDQ3LCAxMDQsIDExNiwgMTA5LCAxMDgsIDYyXSksXG4gICAgLy8gPC9ib2R5PjwvaHRtbD5cbiAgICBCT0RZX0FORF9IVE1MOiBuZXcgVWludDhBcnJheShbXG4gICAgICA2MCwgNDcsIDk4LCAxMTEsIDEwMCwgMTIxLCA2MiwgNjAsIDQ3LCAxMDQsIDExNiwgMTA5LCAxMDgsIDYyLFxuICAgIF0pLFxuICB9LFxuICBNRVRBOiB7XG4gICAgLy8gT25seSB0aGUgbWF0Y2ggdGhlIHByZWZpeCBjYXVzZSB0aGUgc3VmZml4IGNhbiBiZSBkaWZmZXJlbnQgd2V0aGVyIGl0J3MgeG1sIGNvbXBhdGlibGUgb3Igbm90IFwiPlwiIG9yIFwiLz5cIlxuICAgIC8vIDxtZXRhIG5hbWU9XCLCq254dC1pY29uwrtcIlxuICAgIC8vIFRoaXMgaXMgYSBzcGVjaWFsIG1hcmsgdGhhdCB3aWxsIGJlIHJlcGxhY2VkIGJ5IHRoZSBpY29uIGluc2VydGlvbiBzY3JpcHQgdGFnLlxuICAgIElDT05fTUFSSzogbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgNjAsIDEwOSwgMTAxLCAxMTYsIDk3LCAzMiwgMTEwLCA5NywgMTA5LCAxMDEsIDYxLCAzNCwgMTk0LCAxNzEsIDExMCwgMTIwLFxuICAgICAgMTE2LCA0NSwgMTA1LCA5OSwgMTExLCAxMTAsIDE5NCwgMTg3LCAzNCxcbiAgICBdKSxcbiAgfSxcbn0gYXMgY29uc3RcbiJdLCJuYW1lcyI6WyJFTkNPREVEX1RBR1MiLCJPUEVOSU5HIiwiSFRNTCIsIlVpbnQ4QXJyYXkiLCJCT0RZIiwiQ0xPU0VEIiwiSEVBRCIsIkJPRFlfQU5EX0hUTUwiLCJNRVRBIiwiSUNPTl9NQVJLIl0sIm1hcHBpbmdzIjoiOzs7QUFBTyxNQUFNQSxlQUFlO0lBQzFCLGlIQUFpSDtJQUNqSEMsU0FBUztRQUNQLFFBQVE7UUFDUkMsTUFBTSxJQUFJQyxXQUFXO1lBQUM7WUFBSTtZQUFLO1lBQUs7WUFBSztTQUFJO1FBQzdDLFFBQVE7UUFDUkMsTUFBTSxJQUFJRCxXQUFXO1lBQUM7WUFBSTtZQUFJO1lBQUs7WUFBSztTQUFJO0lBQzlDO0lBQ0FFLFFBQVE7UUFDTixVQUFVO1FBQ1ZDLE1BQU0sSUFBSUgsV0FBVztZQUFDO1lBQUk7WUFBSTtZQUFLO1lBQUs7WUFBSTtZQUFLO1NBQUc7UUFDcEQsVUFBVTtRQUNWQyxNQUFNLElBQUlELFdBQVc7WUFBQztZQUFJO1lBQUk7WUFBSTtZQUFLO1lBQUs7WUFBSztTQUFHO1FBQ3BELFVBQVU7UUFDVkQsTUFBTSxJQUFJQyxXQUFXO1lBQUM7WUFBSTtZQUFJO1lBQUs7WUFBSztZQUFLO1lBQUs7U0FBRztRQUNyRCxpQkFBaUI7UUFDakJJLGVBQWUsSUFBSUosV0FBVztZQUM1QjtZQUFJO1lBQUk7WUFBSTtZQUFLO1lBQUs7WUFBSztZQUFJO1lBQUk7WUFBSTtZQUFLO1lBQUs7WUFBSztZQUFLO1NBQzVEO0lBQ0g7SUFDQUssTUFBTTtRQUNKLDRHQUE0RztRQUM1RywwQkFBMEI7UUFDMUIsaUZBQWlGO1FBQ2pGQyxXQUFXLElBQUlOLFdBQVc7WUFDeEI7WUFBSTtZQUFLO1lBQUs7WUFBSztZQUFJO1lBQUk7WUFBSztZQUFJO1lBQUs7WUFBSztZQUFJO1lBQUk7WUFBSztZQUFLO1lBQUs7WUFDckU7WUFBSztZQUFJO1lBQUs7WUFBSTtZQUFLO1lBQUs7WUFBSztZQUFLO1NBQ3ZDO0lBQ0g7QUFDRixFQUFVIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDkzNywgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL3NlcnZlci9zdHJlYW0tdXRpbHMvdWludDhhcnJheS1oZWxwZXJzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRmluZCB0aGUgc3RhcnRpbmcgaW5kZXggb2YgVWludDhBcnJheSBgYmAgd2l0aGluIFVpbnQ4QXJyYXkgYGFgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5kZXhPZlVpbnQ4QXJyYXkoYTogVWludDhBcnJheSwgYjogVWludDhBcnJheSkge1xuICBpZiAoYi5sZW5ndGggPT09IDApIHJldHVybiAwXG4gIGlmIChhLmxlbmd0aCA9PT0gMCB8fCBiLmxlbmd0aCA+IGEubGVuZ3RoKSByZXR1cm4gLTFcblxuICAvLyBzdGFydCBpdGVyYXRpbmcgdGhyb3VnaCBgYWBcbiAgZm9yIChsZXQgaSA9IDA7IGkgPD0gYS5sZW5ndGggLSBiLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IGNvbXBsZXRlTWF0Y2ggPSB0cnVlXG4gICAgLy8gZnJvbSBpbmRleCBgaWAsIGl0ZXJhdGUgdGhyb3VnaCBgYmAgYW5kIGNoZWNrIGZvciBtaXNtYXRjaFxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgYi5sZW5ndGg7IGorKykge1xuICAgICAgLy8gaWYgdGhlIHZhbHVlcyBkbyBub3QgbWF0Y2gsIHRoZW4gdGhpcyBpc24ndCBhIGNvbXBsZXRlIG1hdGNoLCBleGl0IGBiYCBpdGVyYXRpb24gZWFybHkgYW5kIGl0ZXJhdGUgdG8gbmV4dCBpbmRleCBvZiBgYWAuXG4gICAgICBpZiAoYVtpICsgal0gIT09IGJbal0pIHtcbiAgICAgICAgY29tcGxldGVNYXRjaCA9IGZhbHNlXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvbXBsZXRlTWF0Y2gpIHtcbiAgICAgIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIFVpbnQ4QXJyYXlzIGFyZSBzdHJpY3RseSBlcXVpdmFsZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNFcXVpdmFsZW50VWludDhBcnJheXMoYTogVWludDhBcnJheSwgYjogVWludDhBcnJheSkge1xuICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2VcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG4vKipcbiAqIFJlbW92ZSBVaW50OEFycmF5IGBiYCBmcm9tIFVpbnQ4QXJyYXkgYGFgLlxuICpcbiAqIElmIGBiYCBpcyBub3QgaW4gYGFgLCBgYWAgaXMgcmV0dXJuZWQgdW5jaGFuZ2VkLlxuICpcbiAqIE90aGVyd2lzZSwgdGhlIGZ1bmN0aW9uIHJldHVybnMgYSBuZXcgVWludDhBcnJheSBpbnN0YW5jZSB3aXRoIHNpemUgYGEubGVuZ3RoIC0gYi5sZW5ndGhgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVGcm9tVWludDhBcnJheShhOiBVaW50OEFycmF5LCBiOiBVaW50OEFycmF5KSB7XG4gIGNvbnN0IHRhZ0luZGV4ID0gaW5kZXhPZlVpbnQ4QXJyYXkoYSwgYilcbiAgaWYgKHRhZ0luZGV4ID09PSAwKSByZXR1cm4gYS5zdWJhcnJheShiLmxlbmd0aClcbiAgaWYgKHRhZ0luZGV4ID4gLTEpIHtcbiAgICBjb25zdCByZW1vdmVkID0gbmV3IFVpbnQ4QXJyYXkoYS5sZW5ndGggLSBiLmxlbmd0aClcbiAgICByZW1vdmVkLnNldChhLnNsaWNlKDAsIHRhZ0luZGV4KSlcbiAgICByZW1vdmVkLnNldChhLnNsaWNlKHRhZ0luZGV4ICsgYi5sZW5ndGgpLCB0YWdJbmRleClcbiAgICByZXR1cm4gcmVtb3ZlZFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBhXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJpbmRleE9mVWludDhBcnJheSIsImEiLCJiIiwibGVuZ3RoIiwiaSIsImNvbXBsZXRlTWF0Y2giLCJqIiwiaXNFcXVpdmFsZW50VWludDhBcnJheXMiLCJyZW1vdmVGcm9tVWludDhBcnJheSIsInRhZ0luZGV4Iiwic3ViYXJyYXkiLCJyZW1vdmVkIiwiVWludDhBcnJheSIsInNldCIsInNsaWNlIl0sIm1hcHBpbmdzIjoiQUFBQTs7Q0FFQyxHQUNEOzs7OztBQUFPLFNBQVNBLGtCQUFrQkMsQ0FBYSxFQUFFQyxDQUFhO0lBQzVELElBQUlBLEVBQUVDLE1BQU0sS0FBSyxHQUFHLE9BQU87SUFDM0IsSUFBSUYsRUFBRUUsTUFBTSxLQUFLLEtBQUtELEVBQUVDLE1BQU0sR0FBR0YsRUFBRUUsTUFBTSxFQUFFLE9BQU8sQ0FBQztJQUVuRCw4QkFBOEI7SUFDOUIsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLEtBQUtILEVBQUVFLE1BQU0sR0FBR0QsRUFBRUMsTUFBTSxFQUFFQyxJQUFLO1FBQzdDLElBQUlDLGdCQUFnQjtRQUNwQiw2REFBNkQ7UUFDN0QsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlKLEVBQUVDLE1BQU0sRUFBRUcsSUFBSztZQUNqQywySEFBMkg7WUFDM0gsSUFBSUwsQ0FBQyxDQUFDRyxJQUFJRSxFQUFFLEtBQUtKLENBQUMsQ0FBQ0ksRUFBRSxFQUFFO2dCQUNyQkQsZ0JBQWdCO2dCQUNoQjtZQUNGO1FBQ0Y7UUFFQSxJQUFJQSxlQUFlO1lBQ2pCLE9BQU9EO1FBQ1Q7SUFDRjtJQUVBLE9BQU8sQ0FBQztBQUNWO0FBS08sU0FBU0csd0JBQXdCTixDQUFhLEVBQUVDLENBQWE7SUFDbEUsSUFBSUQsRUFBRUUsTUFBTSxLQUFLRCxFQUFFQyxNQUFNLEVBQUUsT0FBTztJQUVsQyxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUgsRUFBRUUsTUFBTSxFQUFFQyxJQUFLO1FBQ2pDLElBQUlILENBQUMsQ0FBQ0csRUFBRSxLQUFLRixDQUFDLENBQUNFLEVBQUUsRUFBRSxPQUFPO0lBQzVCO0lBRUEsT0FBTztBQUNUO0FBU08sU0FBU0kscUJBQXFCUCxDQUFhLEVBQUVDLENBQWE7SUFDL0QsTUFBTU8sV0FBV1Qsa0JBQWtCQyxHQUFHQztJQUN0QyxJQUFJTyxhQUFhLEdBQUcsT0FBT1IsRUFBRVMsUUFBUSxDQUFDUixFQUFFQyxNQUFNO0lBQzlDLElBQUlNLFdBQVcsQ0FBQyxHQUFHO1FBQ2pCLE1BQU1FLFVBQVUsSUFBSUMsV0FBV1gsRUFBRUUsTUFBTSxHQUFHRCxFQUFFQyxNQUFNO1FBQ2xEUSxRQUFRRSxHQUFHLENBQUNaLEVBQUVhLEtBQUssQ0FBQyxHQUFHTDtRQUN2QkUsUUFBUUUsR0FBRyxDQUFDWixFQUFFYSxLQUFLLENBQUNMLFdBQVdQLEVBQUVDLE1BQU0sR0FBR007UUFDMUMsT0FBT0U7SUFDVCxPQUFPO1FBQ0wsT0FBT1Y7SUFDVDtBQUNGIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDk4NywgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL3NoYXJlZC9saWIvZXJyb3JzL2NvbnN0YW50cy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgTUlTU0lOR19ST09UX1RBR1NfRVJST1IgPSAnTkVYVF9NSVNTSU5HX1JPT1RfVEFHUydcbiJdLCJuYW1lcyI6WyJNSVNTSU5HX1JPT1RfVEFHU19FUlJPUiJdLCJtYXBwaW5ncyI6Ijs7O0FBQU8sTUFBTUEsMEJBQTBCLHlCQUF3QiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA5OTUsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NyYy9zaGFyZWQvbGliL3NlZ21lbnQtY2FjaGUvb3V0cHV0LWV4cG9ydC1wcmVmZXRjaC1lbmNvZGluZy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbiBvdXRwdXQ6IGV4cG9ydCBtb2RlLCB0aGUgYnVpbGQgaWQgaXMgYWRkZWQgdG8gdGhlIHN0YXJ0IG9mIHRoZSBIVE1MXG4vLyBkb2N1bWVudCwgZGlyZWN0bHkgYWZ0ZXIgdGhlIGRvY3R5cGUgZGVjbGFyYXRpb24uIER1cmluZyBhIHByZWZldGNoLCB0aGVcbi8vIGNsaWVudCBwZXJmb3JtcyBhIHJhbmdlIHJlcXVlc3QgdG8gZ2V0IHRoZSBidWlsZCBpZCwgc28gaXQgY2FuIGNoZWNrIHdoZXRoZXJcbi8vIHRoZSB0YXJnZXQgcGFnZSBiZWxvbmdzIHRvIHRoZSBzYW1lIGJ1aWxkLlxuLy9cbi8vIFRoZSBmaXJzdCA2NCBieXRlcyBvZiB0aGUgZG9jdW1lbnQgYXJlIHJlcXVlc3RlZC4gVGhlIGV4YWN0IG51bWJlciBpc24ndFxuLy8gdG9vIGltcG9ydGFudDsgaXQgbXVzdCBiZSBsYXJnZXIgdGhhbiB0aGUgYnVpbGQgaWQgKyBkb2N0eXBlICsgY2xvc2luZyBhbmRcbi8vIGVuZGluZyBjb21tZW50IG1hcmtlcnMsIGJ1dCBpdCBkb2Vzbid0IG5lZWQgdG8gbWF0Y2ggdGhlIGVuZCBvZiB0aGVcbi8vIGNvbW1lbnQgZXhhY3RseS5cbi8vXG4vLyBCdWlsZCBpZHMgYXJlIDIxIGJ5dGVzIGxvbmcgaW4gdGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24sIHRob3VnaCB0aGlzXG4vLyBjYW4gYmUgb3ZlcnJpZGRlbiBpbiB0aGUgTmV4dC5qcyBjb25maWcuIEZvciB0aGUgcHVycG9zZXMgb2YgdGhpcyBjaGVjayxcbi8vIGl0J3MgT0sgdG8gb25seSBtYXRjaCB0aGUgc3RhcnQgb2YgdGhlIGlkLCBzbyB3ZSdsbCB0cnVuY2F0ZSBpdCBpZiBleGNlZWRzXG4vLyBhIGNlcnRhaW4gbGVuZ3RoLlxuXG5jb25zdCBET0NUWVBFX1BSRUZJWCA9ICc8IURPQ1RZUEUgaHRtbD4nIC8vIDE1IGJ5dGVzXG5jb25zdCBNQVhfQlVJTERfSURfTEVOR1RIID0gMjRcblxuLy8gUmVxdWVzdCB0aGUgZmlyc3QgNjQgYnl0ZXMuIFRoZSBSYW5nZSBoZWFkZXIgaXMgaW5jbHVzaXZlIG9mIHRoZSBlbmQgdmFsdWUuXG5leHBvcnQgY29uc3QgRE9DX1BSRUZFVENIX1JBTkdFX0hFQURFUl9WQUxVRSA9ICdieXRlcz0wLTYzJ1xuXG5mdW5jdGlvbiBlc2NhcGVCdWlsZElkKGJ1aWxkSWQ6IHN0cmluZykge1xuICAvLyBJZiB0aGUgYnVpbGQgaWQgaXMgbG9uZ2VyIHRoYW4gdGhlIGdpdmVuIGxpbWl0LCBpdCdzIE9LIGZvciBvdXIgcHVycG9zZXNcbiAgLy8gdG8gb25seSBtYXRjaCB0aGUgYmVnaW5uaW5nLlxuICBjb25zdCB0cnVuY2F0ZWQgPSBidWlsZElkLnNsaWNlKDAsIE1BWF9CVUlMRF9JRF9MRU5HVEgpXG4gIC8vIFJlcGxhY2UgaHlwaGVucyB3aXRoIHVuZGVyc2NvcmVzIHNvIGl0IGRvZXNuJ3QgYnJlYWsgdGhlIEhUTUwgY29tbWVudC5cbiAgLy8gKFVubGlrZWx5LCBidXQgaWYgdGhpcyBkaWQgaGFwcGVuIGl0IHdvdWxkIGJyZWFrIHRoZSB3aG9sZSBkb2N1bWVudC4pXG4gIHJldHVybiB0cnVuY2F0ZWQucmVwbGFjZSgvLS9nLCAnXycpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbnNlcnRCdWlsZElkQ29tbWVudChvcmlnaW5hbEh0bWw6IHN0cmluZywgYnVpbGRJZDogc3RyaW5nKSB7XG4gIGlmIChcbiAgICAvLyBTa2lwIGlmIHRoZSBidWlsZCBpZCBjb250YWlucyBhIGNsb3NpbmcgY29tbWVudCBtYXJrZXIuXG4gICAgYnVpbGRJZC5pbmNsdWRlcygnLS0+JykgfHxcbiAgICAvLyBSZWFjdCBhbHdheXMgaW5zZXJ0cyBhIGRvY3R5cGUgYXQgdGhlIHN0YXJ0IG9mIHRoZSBkb2N1bWVudC4gU2tpcCBpZiBpdFxuICAgIC8vIGlzbid0IHByZXNlbnQuIFNob3VsZG4ndCBoYXBwZW47IHN1Z2dlc3RzIGFuIGlzc3VlIGVsc2V3aGVyZS5cbiAgICAhb3JpZ2luYWxIdG1sLnN0YXJ0c1dpdGgoRE9DVFlQRV9QUkVGSVgpXG4gICkge1xuICAgIC8vIFJldHVybiB0aGUgb3JpZ2luYWwgSFRNTCB1bmNoYW5nZWQuIFRoaXMgbWVhbnMgdGhlIGRvY3VtZW50IHdpbGwgbm90XG4gICAgLy8gYmUgcHJlZmV0Y2hlZC5cbiAgICAvLyBUT0RPOiBUaGUgYnVpbGQgaWQgY29tbWVudCBpcyBjdXJyZW50bHkgb25seSB1c2VkIGR1cmluZyBwcmVmZXRjaGVzLCBidXRcbiAgICAvLyBpZiB3ZSBldmVudHVhbGx5IHVzZSB0aGlzIG1lY2hhbmlzbSBmb3IgcmVndWxhciBuYXZpZ2F0aW9ucywgd2UgbWF5IG5lZWRcbiAgICAvLyB0byBlcnJvciBkdXJpbmcgYnVpbGQgaWYgd2UgZmFpbCB0byBpbnNlcnQgaXQgZm9yIHNvbWUgcmVhc29uLlxuICAgIHJldHVybiBvcmlnaW5hbEh0bWxcbiAgfVxuICAvLyBUaGUgY29tbWVudCBtdXN0IGJlIGluc2VydGVkIGFmdGVyIHRoZSBkb2N0eXBlLlxuICByZXR1cm4gb3JpZ2luYWxIdG1sLnJlcGxhY2UoXG4gICAgRE9DVFlQRV9QUkVGSVgsXG4gICAgRE9DVFlQRV9QUkVGSVggKyAnPCEtLScgKyBlc2NhcGVCdWlsZElkKGJ1aWxkSWQpICsgJy0tPidcbiAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZG9lc0V4cG9ydGVkSHRtbE1hdGNoQnVpbGRJZChcbiAgcGFydGlhbEh0bWxEb2N1bWVudDogc3RyaW5nLFxuICBidWlsZElkOiBzdHJpbmdcbikge1xuICAvLyBDaGVjayB3aGV0aGVyIHRoZSBkb2N1bWVudCBzdGFydHMgd2l0aCB0aGUgZXhwZWN0ZWQgYnVpbGRJZC5cbiAgcmV0dXJuIHBhcnRpYWxIdG1sRG9jdW1lbnQuc3RhcnRzV2l0aChcbiAgICBET0NUWVBFX1BSRUZJWCArICc8IS0tJyArIGVzY2FwZUJ1aWxkSWQoYnVpbGRJZCkgKyAnLS0+J1xuICApXG59XG4iXSwibmFtZXMiOlsiRE9DVFlQRV9QUkVGSVgiLCJNQVhfQlVJTERfSURfTEVOR1RIIiwiRE9DX1BSRUZFVENIX1JBTkdFX0hFQURFUl9WQUxVRSIsImVzY2FwZUJ1aWxkSWQiLCJidWlsZElkIiwidHJ1bmNhdGVkIiwic2xpY2UiLCJyZXBsYWNlIiwiaW5zZXJ0QnVpbGRJZENvbW1lbnQiLCJvcmlnaW5hbEh0bWwiLCJpbmNsdWRlcyIsInN0YXJ0c1dpdGgiLCJkb2VzRXhwb3J0ZWRIdG1sTWF0Y2hCdWlsZElkIiwicGFydGlhbEh0bWxEb2N1bWVudCJdLCJtYXBwaW5ncyI6IkFBQUEseUVBQXlFO0FBQ3pFLDJFQUEyRTtBQUMzRSwrRUFBK0U7QUFDL0UsNkNBQTZDO0FBQzdDLEVBQUU7QUFDRiwyRUFBMkU7QUFDM0UsNkVBQTZFO0FBQzdFLHNFQUFzRTtBQUN0RSxtQkFBbUI7QUFDbkIsRUFBRTtBQUNGLHlFQUF5RTtBQUN6RSwyRUFBMkU7QUFDM0UsNkVBQTZFO0FBQzdFLG9CQUFvQjs7Ozs7O0FBRXBCLE1BQU1BLGlCQUFpQixrQkFBa0IsV0FBVzs7QUFDcEQsTUFBTUMsc0JBQXNCO0FBR3JCLE1BQU1DLGtDQUFrQyxhQUFZO0FBRTNELFNBQVNDLGNBQWNDLE9BQWU7SUFDcEMsMkVBQTJFO0lBQzNFLCtCQUErQjtJQUMvQixNQUFNQyxZQUFZRCxRQUFRRSxLQUFLLENBQUMsR0FBR0w7SUFDbkMseUVBQXlFO0lBQ3pFLHdFQUF3RTtJQUN4RSxPQUFPSSxVQUFVRSxPQUFPLENBQUMsTUFBTTtBQUNqQztBQUVPLFNBQVNDLHFCQUFxQkMsWUFBb0IsRUFBRUwsT0FBZTtJQUN4RSxJQUVFQSxBQURBLFFBQ1FNLFFBQVEsQ0FBQyxVQUNqQiwrQkFGMEQsMkNBRWdCO0lBQzFFLGdFQUFnRTtJQUNoRSxDQUFDRCxhQUFhRSxVQUFVLENBQUNYLGlCQUN6QjtRQUNBLHVFQUF1RTtRQUN2RSxpQkFBaUI7UUFDakIsMkVBQTJFO1FBQzNFLDJFQUEyRTtRQUMzRSxpRUFBaUU7UUFDakUsT0FBT1M7SUFDVDtJQUNBLGtEQUFrRDtJQUNsRCxPQUFPQSxhQUFhRixPQUFPLENBQ3pCUCxnQkFDQUEsaUJBQWlCLFNBQVNHLGNBQWNDLFdBQVc7QUFFdkQ7QUFFTyxTQUFTUSw2QkFDZEMsbUJBQTJCLEVBQzNCVCxPQUFlO0lBRWYsK0RBQStEO0lBQy9ELE9BQU9TLG9CQUFvQkYsVUFBVSxDQUNuQ1gsaUJBQWlCLFNBQVNHLGNBQWNDLFdBQVc7QUFFdkQiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTA0OCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL3NlcnZlci9zdHJlYW0tdXRpbHMvbm9kZS13ZWItc3RyZWFtcy1oZWxwZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0VHJhY2VyIH0gZnJvbSAnLi4vbGliL3RyYWNlL3RyYWNlcidcbmltcG9ydCB7IEFwcFJlbmRlclNwYW4gfSBmcm9tICcuLi9saWIvdHJhY2UvY29uc3RhbnRzJ1xuaW1wb3J0IHsgRGV0YWNoZWRQcm9taXNlIH0gZnJvbSAnLi4vLi4vbGliL2RldGFjaGVkLXByb21pc2UnXG5pbXBvcnQgeyBzY2hlZHVsZUltbWVkaWF0ZSwgYXRMZWFzdE9uZVRhc2sgfSBmcm9tICcuLi8uLi9saWIvc2NoZWR1bGVyJ1xuaW1wb3J0IHsgRU5DT0RFRF9UQUdTIH0gZnJvbSAnLi9lbmNvZGVkLXRhZ3MnXG5pbXBvcnQge1xuICBpbmRleE9mVWludDhBcnJheSxcbiAgaXNFcXVpdmFsZW50VWludDhBcnJheXMsXG4gIHJlbW92ZUZyb21VaW50OEFycmF5LFxufSBmcm9tICcuL3VpbnQ4YXJyYXktaGVscGVycydcbmltcG9ydCB7IE1JU1NJTkdfUk9PVF9UQUdTX0VSUk9SIH0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi9lcnJvcnMvY29uc3RhbnRzJ1xuaW1wb3J0IHsgaW5zZXJ0QnVpbGRJZENvbW1lbnQgfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL3NlZ21lbnQtY2FjaGUvb3V0cHV0LWV4cG9ydC1wcmVmZXRjaC1lbmNvZGluZydcblxuZnVuY3Rpb24gdm9pZENhdGNoKCkge1xuICAvLyB0aGlzIGNhdGNoZXIgaXMgZGVzaWduZWQgdG8gYmUgdXNlZCB3aXRoIHBpcGVUbyB3aGVyZSB3ZSBleHBlY3QgdGhlIHVuZGVybHlpbmdcbiAgLy8gcGlwZSBpbXBsZW1lbnRhdGlvbiB0byBmb3J3YXJkIGVycm9ycyBidXQgd2UgZG9uJ3Qgd2FudCB0aGUgcGlwZVRvIHByb21pc2UgdG8gcmVqZWN0XG4gIC8vIGFuZCBiZSB1bmhhbmRsZWRcbn1cblxuZXhwb3J0IHR5cGUgUmVhY3RSZWFkYWJsZVN0cmVhbSA9IFJlYWRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+ICYge1xuICBhbGxSZWFkeT86IFByb21pc2U8dm9pZD4gfCB1bmRlZmluZWRcbn1cblxuLy8gV2UgY2FuIHNoYXJlIHRoZSBzYW1lIGVuY29kZXIgaW5zdGFuY2UgZXZlcnl3aGVyZVxuLy8gTm90YWJseSB3ZSBjYW5ub3QgZG8gdGhlIHNhbWUgZm9yIFRleHREZWNvZGVyIGJlY2F1c2UgaXQgaXMgc3RhdGVmdWxcbi8vIHdoZW4gaGFuZGxpbmcgc3RyZWFtaW5nIGRhdGFcbmNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKVxuXG5leHBvcnQgZnVuY3Rpb24gY2hhaW5TdHJlYW1zPFQ+KFxuICAuLi5zdHJlYW1zOiBSZWFkYWJsZVN0cmVhbTxUPltdXG4pOiBSZWFkYWJsZVN0cmVhbTxUPiB7XG4gIC8vIFdlIGNvdWxkIGVuY29kZSB0aGlzIGludmFyaWFudCBpbiB0aGUgYXJndW1lbnRzIGJ1dCBjdXJyZW50IHVzZXMgb2YgdGhpcyBmdW5jdGlvbiBwYXNzXG4gIC8vIHVzZSBzcHJlYWQgc28gaXQgd291bGQgYmUgbWlzc2VkIGJ5XG4gIGlmIChzdHJlYW1zLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YXJpYW50OiBjaGFpblN0cmVhbXMgcmVxdWlyZXMgYXQgbGVhc3Qgb25lIHN0cmVhbScpXG4gIH1cblxuICAvLyBJZiB3ZSBvbmx5IGhhdmUgMSBzdHJlYW0gd2UgZmFzdCBwYXRoIGl0IGJ5IHJldHVybmluZyBqdXN0IHRoaXMgc3RyZWFtXG4gIGlmIChzdHJlYW1zLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBzdHJlYW1zWzBdXG4gIH1cblxuICBjb25zdCB7IHJlYWRhYmxlLCB3cml0YWJsZSB9ID0gbmV3IFRyYW5zZm9ybVN0cmVhbSgpXG5cbiAgLy8gV2UgYWx3YXlzIGluaXRpYXRlIHBpcGVUbyBpbW1lZGlhdGVseS4gV2Uga25vdyB3ZSBoYXZlIGF0IGxlYXN0IDIgc3RyZWFtc1xuICAvLyBzbyB3ZSBuZWVkIHRvIGF2b2lkIGNsb3NpbmcgdGhlIHdyaXRhYmxlIHdoZW4gdGhpcyBvbmUgZmluaXNoZXMuXG4gIGxldCBwcm9taXNlID0gc3RyZWFtc1swXS5waXBlVG8od3JpdGFibGUsIHsgcHJldmVudENsb3NlOiB0cnVlIH0pXG5cbiAgbGV0IGkgPSAxXG4gIGZvciAoOyBpIDwgc3RyZWFtcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICBjb25zdCBuZXh0U3RyZWFtID0gc3RyZWFtc1tpXVxuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oKCkgPT5cbiAgICAgIG5leHRTdHJlYW0ucGlwZVRvKHdyaXRhYmxlLCB7IHByZXZlbnRDbG9zZTogdHJ1ZSB9KVxuICAgIClcbiAgfVxuXG4gIC8vIFdlIGNhbiBvbWl0IHRoZSBsZW5ndGggY2hlY2sgYmVjYXVzZSB3ZSBoYWx0ZWQgYmVmb3JlIHRoZSBsYXN0IHN0cmVhbSBhbmQgdGhlcmVcbiAgLy8gaXMgYXQgbGVhc3QgdHdvIHN0cmVhbXMgc28gdGhlIGxhc3RTdHJlYW0gaGVyZSB3aWxsIGFsd2F5cyBiZSBkZWZpbmVkXG4gIGNvbnN0IGxhc3RTdHJlYW0gPSBzdHJlYW1zW2ldXG4gIHByb21pc2UgPSBwcm9taXNlLnRoZW4oKCkgPT4gbGFzdFN0cmVhbS5waXBlVG8od3JpdGFibGUpKVxuXG4gIC8vIENhdGNoIGFueSBlcnJvcnMgZnJvbSB0aGUgc3RyZWFtcyBhbmQgaWdub3JlIHRoZW0sIHRoZXkgd2lsbCBiZSBoYW5kbGVkXG4gIC8vIGJ5IHdoYXRldmVyIGlzIGNvbnN1bWluZyB0aGUgcmVhZGFibGUgc3RyZWFtLlxuICBwcm9taXNlLmNhdGNoKHZvaWRDYXRjaClcblxuICByZXR1cm4gcmVhZGFibGVcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0cmVhbUZyb21TdHJpbmcoc3RyOiBzdHJpbmcpOiBSZWFkYWJsZVN0cmVhbTxVaW50OEFycmF5PiB7XG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShlbmNvZGVyLmVuY29kZShzdHIpKVxuICAgICAgY29udHJvbGxlci5jbG9zZSgpXG4gICAgfSxcbiAgfSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0cmVhbUZyb21CdWZmZXIoY2h1bms6IEJ1ZmZlcik6IFJlYWRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+IHtcbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKVxuICAgICAgY29udHJvbGxlci5jbG9zZSgpXG4gICAgfSxcbiAgfSlcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHN0cmVhbVRvQnVmZmVyKFxuICBzdHJlYW06IFJlYWRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+XG4pOiBQcm9taXNlPEJ1ZmZlcj4ge1xuICBjb25zdCByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKClcbiAgY29uc3QgY2h1bmtzOiBVaW50OEFycmF5W10gPSBbXVxuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKVxuICAgIGlmIChkb25lKSB7XG4gICAgICBicmVha1xuICAgIH1cblxuICAgIGNodW5rcy5wdXNoKHZhbHVlKVxuICB9XG5cbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoY2h1bmtzKVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc3RyZWFtVG9TdHJpbmcoXG4gIHN0cmVhbTogUmVhZGFibGVTdHJlYW08VWludDhBcnJheT4sXG4gIHNpZ25hbD86IEFib3J0U2lnbmFsXG4pOiBQcm9taXNlPHN0cmluZz4ge1xuICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCd1dGYtOCcsIHsgZmF0YWw6IHRydWUgfSlcbiAgbGV0IHN0cmluZyA9ICcnXG5cbiAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBzdHJlYW0pIHtcbiAgICBpZiAoc2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICByZXR1cm4gc3RyaW5nXG4gICAgfVxuXG4gICAgc3RyaW5nICs9IGRlY29kZXIuZGVjb2RlKGNodW5rLCB7IHN0cmVhbTogdHJ1ZSB9KVxuICB9XG5cbiAgc3RyaW5nICs9IGRlY29kZXIuZGVjb2RlKClcblxuICByZXR1cm4gc3RyaW5nXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVCdWZmZXJlZFRyYW5zZm9ybVN0cmVhbSgpOiBUcmFuc2Zvcm1TdHJlYW08XG4gIFVpbnQ4QXJyYXksXG4gIFVpbnQ4QXJyYXlcbj4ge1xuICBsZXQgYnVmZmVyZWRDaHVua3M6IEFycmF5PFVpbnQ4QXJyYXk+ID0gW11cbiAgbGV0IGJ1ZmZlckJ5dGVMZW5ndGg6IG51bWJlciA9IDBcbiAgbGV0IHBlbmRpbmc6IERldGFjaGVkUHJvbWlzZTx2b2lkPiB8IHVuZGVmaW5lZFxuXG4gIGNvbnN0IGZsdXNoID0gKGNvbnRyb2xsZXI6IFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyKSA9PiB7XG4gICAgLy8gSWYgd2UgYWxyZWFkeSBoYXZlIGEgcGVuZGluZyBmbHVzaCwgdGhlbiByZXR1cm4gZWFybHkuXG4gICAgaWYgKHBlbmRpbmcpIHJldHVyblxuXG4gICAgY29uc3QgZGV0YWNoZWQgPSBuZXcgRGV0YWNoZWRQcm9taXNlPHZvaWQ+KClcbiAgICBwZW5kaW5nID0gZGV0YWNoZWRcblxuICAgIHNjaGVkdWxlSW1tZWRpYXRlKCgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNodW5rID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyQnl0ZUxlbmd0aClcbiAgICAgICAgbGV0IGNvcGllZEJ5dGVzID0gMFxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVyZWRDaHVua3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBidWZmZXJlZENodW5rID0gYnVmZmVyZWRDaHVua3NbaV1cbiAgICAgICAgICBjaHVuay5zZXQoYnVmZmVyZWRDaHVuaywgY29waWVkQnl0ZXMpXG4gICAgICAgICAgY29waWVkQnl0ZXMgKz0gYnVmZmVyZWRDaHVuay5ieXRlTGVuZ3RoXG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UganVzdCB3cm90ZSBhbGwgdGhlIGJ1ZmZlcmVkIGNodW5rcyBzbyB3ZSBuZWVkIHRvIHJlc2V0IHRoZSBidWZmZXJlZENodW5rcyBhcnJheVxuICAgICAgICAvLyBhbmQgb3VyIGJ1ZmZlckJ5dGVMZW5ndGggdG8gcHJlcGFyZSBmb3IgdGhlIG5leHQgcm91bmQgb2YgYnVmZmVyZWQgY2h1bmtzXG4gICAgICAgIGJ1ZmZlcmVkQ2h1bmtzLmxlbmd0aCA9IDBcbiAgICAgICAgYnVmZmVyQnl0ZUxlbmd0aCA9IDBcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKVxuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIC8vIElmIGFuIGVycm9yIG9jY3VycyB3aGlsZSBlbnF1ZXVpbmcgaXQgY2FuJ3QgYmUgZHVlIHRvIHRoaXNcbiAgICAgICAgLy8gdHJhbnNmb3JtZXJzIGZhdWx0LiBJdCdzIGxpa2VseSBkdWUgdG8gdGhlIGNvbnRyb2xsZXIgYmVpbmdcbiAgICAgICAgLy8gZXJyb3JlZCBkdWUgdG8gdGhlIHN0cmVhbSBiZWluZyBjYW5jZWxsZWQuXG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBwZW5kaW5nID0gdW5kZWZpbmVkXG4gICAgICAgIGRldGFjaGVkLnJlc29sdmUoKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAvLyBDb21iaW5lIHRoZSBwcmV2aW91cyBidWZmZXIgd2l0aCB0aGUgbmV3IGNodW5rLlxuICAgICAgYnVmZmVyZWRDaHVua3MucHVzaChjaHVuaylcbiAgICAgIGJ1ZmZlckJ5dGVMZW5ndGggKz0gY2h1bmsuYnl0ZUxlbmd0aFxuXG4gICAgICAvLyBGbHVzaCB0aGUgYnVmZmVyIHRvIHRoZSBjb250cm9sbGVyLlxuICAgICAgZmx1c2goY29udHJvbGxlcilcbiAgICB9LFxuICAgIGZsdXNoKCkge1xuICAgICAgaWYgKCFwZW5kaW5nKSByZXR1cm5cblxuICAgICAgcmV0dXJuIHBlbmRpbmcucHJvbWlzZVxuICAgIH0sXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVByZWZldGNoQ29tbWVudFN0cmVhbShcbiAgaXNCdWlsZFRpbWVQcmVyZW5kZXJpbmc6IGJvb2xlYW4sXG4gIGJ1aWxkSWQ6IHN0cmluZ1xuKTogVHJhbnNmb3JtU3RyZWFtPFVpbnQ4QXJyYXksIFVpbnQ4QXJyYXk+IHtcbiAgLy8gSW5zZXJ0IGFuIGV4dHJhIGNvbW1lbnQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgSFRNTCBkb2N1bWVudC4gVGhpcyBtdXN0XG4gIC8vIGNvbWUgYWZ0ZXIgdGhlIERPQ1RZUEUsIHdoaWNoIGlzIGluc2VydGVkIGJ5IFJlYWN0LlxuICAvL1xuICAvLyBUaGUgZmlyc3QgY2h1bmsgc2VudCBieSBSZWFjdCB3aWxsIGNvbnRhaW4gdGhlIGRvY3R5cGUuIEFmdGVyIHRoYXQsIHdlIGNhblxuICAvLyBwYXNzIHRocm91Z2ggdGhlIHJlc3Qgb2YgdGhlIGNodW5rcyBhcy1pcy5cbiAgbGV0IGRpZFRyYW5zZm9ybUZpcnN0Q2h1bmsgPSBmYWxzZVxuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICBpZiAoaXNCdWlsZFRpbWVQcmVyZW5kZXJpbmcgJiYgIWRpZFRyYW5zZm9ybUZpcnN0Q2h1bmspIHtcbiAgICAgICAgZGlkVHJhbnNmb3JtRmlyc3RDaHVuayA9IHRydWVcbiAgICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigndXRmLTgnLCB7IGZhdGFsOiB0cnVlIH0pXG4gICAgICAgIGNvbnN0IGNodW5rU3RyID0gZGVjb2Rlci5kZWNvZGUoY2h1bmssIHtcbiAgICAgICAgICBzdHJlYW06IHRydWUsXG4gICAgICAgIH0pXG4gICAgICAgIGNvbnN0IHVwZGF0ZWRDaHVua1N0ciA9IGluc2VydEJ1aWxkSWRDb21tZW50KGNodW5rU3RyLCBidWlsZElkKVxuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoZW5jb2Rlci5lbmNvZGUodXBkYXRlZENodW5rU3RyKSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspXG4gICAgfSxcbiAgfSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlclRvSW5pdGlhbEZpenpTdHJlYW0oe1xuICBSZWFjdERPTVNlcnZlcixcbiAgZWxlbWVudCxcbiAgc3RyZWFtT3B0aW9ucyxcbn06IHtcbiAgUmVhY3RET01TZXJ2ZXI6IHtcbiAgICByZW5kZXJUb1JlYWRhYmxlU3RyZWFtOiB0eXBlb2YgaW1wb3J0KCdyZWFjdC1kb20vc2VydmVyJykucmVuZGVyVG9SZWFkYWJsZVN0cmVhbVxuICB9XG4gIGVsZW1lbnQ6IFJlYWN0LlJlYWN0RWxlbWVudFxuICBzdHJlYW1PcHRpb25zPzogUGFyYW1ldGVyczx0eXBlb2YgUmVhY3RET01TZXJ2ZXIucmVuZGVyVG9SZWFkYWJsZVN0cmVhbT5bMV1cbn0pOiBQcm9taXNlPFJlYWN0UmVhZGFibGVTdHJlYW0+IHtcbiAgcmV0dXJuIGdldFRyYWNlcigpLnRyYWNlKEFwcFJlbmRlclNwYW4ucmVuZGVyVG9SZWFkYWJsZVN0cmVhbSwgYXN5bmMgKCkgPT5cbiAgICBSZWFjdERPTVNlcnZlci5yZW5kZXJUb1JlYWRhYmxlU3RyZWFtKGVsZW1lbnQsIHN0cmVhbU9wdGlvbnMpXG4gIClcbn1cblxuZnVuY3Rpb24gY3JlYXRlTWV0YWRhdGFUcmFuc2Zvcm1TdHJlYW0oXG4gIGluc2VydDogKCkgPT4gUHJvbWlzZTxzdHJpbmc+IHwgc3RyaW5nXG4pOiBUcmFuc2Zvcm1TdHJlYW08VWludDhBcnJheSwgVWludDhBcnJheT4ge1xuICBsZXQgY2h1bmtJbmRleCA9IC0xXG4gIGxldCBpc01hcmtSZW1vdmVkID0gZmFsc2VcblxuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgYXN5bmMgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICBsZXQgaWNvbk1hcmtJbmRleCA9IC0xXG4gICAgICBsZXQgY2xvc2VkSGVhZEluZGV4ID0gLTFcbiAgICAgIGNodW5rSW5kZXgrK1xuXG4gICAgICBpZiAoaXNNYXJrUmVtb3ZlZCkge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgbGV0IGljb25NYXJrTGVuZ3RoID0gMFxuICAgICAgLy8gT25seSBzZWFyY2ggZm9yIHRoZSBjbG9zZWQgaGVhZCB0YWcgb25jZVxuICAgICAgaWYgKGljb25NYXJrSW5kZXggPT09IC0xKSB7XG4gICAgICAgIGljb25NYXJrSW5kZXggPSBpbmRleE9mVWludDhBcnJheShjaHVuaywgRU5DT0RFRF9UQUdTLk1FVEEuSUNPTl9NQVJLKVxuICAgICAgICBpZiAoaWNvbk1hcmtJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gV2hlbiB3ZSBmb3VuZCB0aGUgYDxtZXRhIG5hbWU9XCLCq254dC1pY29uwrtcImAgdGFnIHByZWZpeCwgd2Ugd2lsbCByZW1vdmUgaXQgZnJvbSB0aGUgY2h1bmsuXG4gICAgICAgICAgLy8gSXRzIGNsb3NlIHRhZyBjb3VsZCBlaXRoZXIgYmUgYC8+YCBvciBgPmAsIGNoZWNraW5nIHRoZSBuZXh0IGNoYXIgdG8gZW5zdXJlIHdlIGNvdmVyIGJvdGggY2FzZXMuXG4gICAgICAgICAgaWNvbk1hcmtMZW5ndGggPSBFTkNPREVEX1RBR1MuTUVUQS5JQ09OX01BUksubGVuZ3RoXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgbmV4dCBjaGFyIGlzIC8sIHRoaXMgaXMgZm9yIHhtbCBtb2RlLlxuICAgICAgICAgIGlmIChjaHVua1tpY29uTWFya0luZGV4ICsgaWNvbk1hcmtMZW5ndGhdID09PSA0Nykge1xuICAgICAgICAgICAgaWNvbk1hcmtMZW5ndGggKz0gMlxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGUgbGFzdCBjaGFyIGlzIGA+YFxuICAgICAgICAgICAgaWNvbk1hcmtMZW5ndGgrK1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBpZiBpY29uIG1hcmsgaXMgaW5zaWRlIDxoZWFkPiB0YWcgaW4gdGhlIGZpcnN0IGNodW5rLlxuICAgICAgaWYgKGNodW5rSW5kZXggPT09IDApIHtcbiAgICAgICAgY2xvc2VkSGVhZEluZGV4ID0gaW5kZXhPZlVpbnQ4QXJyYXkoY2h1bmssIEVOQ09ERURfVEFHUy5DTE9TRUQuSEVBRClcbiAgICAgICAgaWYgKGljb25NYXJrSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgLy8gVGhlIG1hcmsgaWNvbiBpcyBsb2NhdGVkIGluIHRoZSAxc3QgY2h1bmsgYmVmb3JlIHRoZSBoZWFkIHRhZy5cbiAgICAgICAgICAvLyBXZSBkbyBub3QgbmVlZCB0byBpbnNlcnQgdGhlIHNjcmlwdCB0YWcgaW4gdGhpcyBjYXNlIGJlY2F1c2UgaXQncyBpbiB0aGUgaGVhZC5cbiAgICAgICAgICAvLyBKdXN0IHJlbW92ZSB0aGUgaWNvbiBtYXJrIGZyb20gdGhlIGNodW5rLlxuICAgICAgICAgIGlmIChpY29uTWFya0luZGV4IDwgY2xvc2VkSGVhZEluZGV4KSB7XG4gICAgICAgICAgICBjb25zdCByZXBsYWNlZCA9IG5ldyBVaW50OEFycmF5KGNodW5rLmxlbmd0aCAtIGljb25NYXJrTGVuZ3RoKVxuXG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGljb24gbWFyayBmcm9tIHRoZSBjaHVuay5cbiAgICAgICAgICAgIHJlcGxhY2VkLnNldChjaHVuay5zdWJhcnJheSgwLCBpY29uTWFya0luZGV4KSlcbiAgICAgICAgICAgIHJlcGxhY2VkLnNldChcbiAgICAgICAgICAgICAgY2h1bmsuc3ViYXJyYXkoaWNvbk1hcmtJbmRleCArIGljb25NYXJrTGVuZ3RoKSxcbiAgICAgICAgICAgICAgaWNvbk1hcmtJbmRleFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgY2h1bmsgPSByZXBsYWNlZFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGUgaWNvbiBtYXJrIGlzIGFmdGVyIHRoZSBoZWFkIHRhZywgcmVwbGFjZSBhbmQgaW5zZXJ0IHRoZSBzY3JpcHQgdGFnIGF0IHRoYXQgcG9zaXRpb24uXG4gICAgICAgICAgICBjb25zdCBpbnNlcnRpb24gPSBhd2FpdCBpbnNlcnQoKVxuICAgICAgICAgICAgY29uc3QgZW5jb2RlZEluc2VydGlvbiA9IGVuY29kZXIuZW5jb2RlKGluc2VydGlvbilcbiAgICAgICAgICAgIGNvbnN0IGluc2VydGlvbkxlbmd0aCA9IGVuY29kZWRJbnNlcnRpb24ubGVuZ3RoXG4gICAgICAgICAgICBjb25zdCByZXBsYWNlZCA9IG5ldyBVaW50OEFycmF5KFxuICAgICAgICAgICAgICBjaHVuay5sZW5ndGggLSBpY29uTWFya0xlbmd0aCArIGluc2VydGlvbkxlbmd0aFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgcmVwbGFjZWQuc2V0KGNodW5rLnN1YmFycmF5KDAsIGljb25NYXJrSW5kZXgpKVxuICAgICAgICAgICAgcmVwbGFjZWQuc2V0KGVuY29kZWRJbnNlcnRpb24sIGljb25NYXJrSW5kZXgpXG4gICAgICAgICAgICByZXBsYWNlZC5zZXQoXG4gICAgICAgICAgICAgIGNodW5rLnN1YmFycmF5KGljb25NYXJrSW5kZXggKyBpY29uTWFya0xlbmd0aCksXG4gICAgICAgICAgICAgIGljb25NYXJrSW5kZXggKyBpbnNlcnRpb25MZW5ndGhcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIGNodW5rID0gcmVwbGFjZWRcbiAgICAgICAgICB9XG4gICAgICAgICAgaXNNYXJrUmVtb3ZlZCA9IHRydWVcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIGljb24gbWFyayBsb2NhdGVkLCBpdCB3aWxsIGJlIGhhbmRsZWQgbGF0ZXIgd2hlbiBpZiBwcmVzZW50IGluIHRoZSBmb2xsb3dpbmcgY2h1bmtzLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV2hlbiBpdCdzIGFwcGVhcmVkIGluIHRoZSBmb2xsb3dpbmcgY2h1bmtzLCB3ZSdsbCBuZWVkIHRvXG4gICAgICAgIC8vIHJlbW92ZSB0aGUgbWFyayBhbmQgdGhlbiBpbnNlcnQgdGhlIHNjcmlwdCB0YWcgYXQgdGhhdCBwb3NpdGlvbi5cbiAgICAgICAgY29uc3QgaW5zZXJ0aW9uID0gYXdhaXQgaW5zZXJ0KClcbiAgICAgICAgY29uc3QgZW5jb2RlZEluc2VydGlvbiA9IGVuY29kZXIuZW5jb2RlKGluc2VydGlvbilcbiAgICAgICAgY29uc3QgaW5zZXJ0aW9uTGVuZ3RoID0gZW5jb2RlZEluc2VydGlvbi5sZW5ndGhcbiAgICAgICAgLy8gUmVwbGFjZSB0aGUgaWNvbiBtYXJrIHdpdGggdGhlIGhvaXN0IHNjcmlwdCBvciBlbXB0eSBzdHJpbmcuXG4gICAgICAgIGNvbnN0IHJlcGxhY2VkID0gbmV3IFVpbnQ4QXJyYXkoXG4gICAgICAgICAgY2h1bmsubGVuZ3RoIC0gaWNvbk1hcmtMZW5ndGggKyBpbnNlcnRpb25MZW5ndGhcbiAgICAgICAgKVxuICAgICAgICAvLyBTZXQgdGhlIGZpcnN0IHBhcnQgb2YgdGhlIGNodW5rLCBiZWZvcmUgdGhlIGljb24gbWFyay5cbiAgICAgICAgcmVwbGFjZWQuc2V0KGNodW5rLnN1YmFycmF5KDAsIGljb25NYXJrSW5kZXgpKVxuICAgICAgICAvLyBTZXQgdGhlIGluc2VydGlvbiBhZnRlciB0aGUgaWNvbiBtYXJrLlxuICAgICAgICByZXBsYWNlZC5zZXQoZW5jb2RlZEluc2VydGlvbiwgaWNvbk1hcmtJbmRleClcblxuICAgICAgICAvLyBTZXQgdGhlIHJlc3Qgb2YgdGhlIGNodW5rIGFmdGVyIHRoZSBpY29uIG1hcmsuXG4gICAgICAgIHJlcGxhY2VkLnNldChcbiAgICAgICAgICBjaHVuay5zdWJhcnJheShpY29uTWFya0luZGV4ICsgaWNvbk1hcmtMZW5ndGgpLFxuICAgICAgICAgIGljb25NYXJrSW5kZXggKyBpbnNlcnRpb25MZW5ndGhcbiAgICAgICAgKVxuICAgICAgICBjaHVuayA9IHJlcGxhY2VkXG4gICAgICAgIGlzTWFya1JlbW92ZWQgPSB0cnVlXG4gICAgICB9XG4gICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspXG4gICAgfSxcbiAgfSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlSGVhZEluc2VydGlvblRyYW5zZm9ybVN0cmVhbShcbiAgaW5zZXJ0OiAoKSA9PiBQcm9taXNlPHN0cmluZz5cbik6IFRyYW5zZm9ybVN0cmVhbTxVaW50OEFycmF5LCBVaW50OEFycmF5PiB7XG4gIGxldCBpbnNlcnRlZCA9IGZhbHNlXG5cbiAgLy8gV2UgbmVlZCB0byB0cmFjayBpZiB0aGlzIHRyYW5zZm9ybSBzYXcgYW55IGJ5dGVzIGJlY2F1c2UgaWYgaXQgZGlkbid0XG4gIC8vIHdlIHdvbid0IHdhbnQgdG8gaW5zZXJ0IGFueSBzZXJ2ZXIgSFRNTCBhdCBhbGxcbiAgbGV0IGhhc0J5dGVzID0gZmFsc2VcblxuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgYXN5bmMgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICBoYXNCeXRlcyA9IHRydWVcblxuICAgICAgY29uc3QgaW5zZXJ0aW9uID0gYXdhaXQgaW5zZXJ0KClcbiAgICAgIGlmIChpbnNlcnRlZCkge1xuICAgICAgICBpZiAoaW5zZXJ0aW9uKSB7XG4gICAgICAgICAgY29uc3QgZW5jb2RlZEluc2VydGlvbiA9IGVuY29kZXIuZW5jb2RlKGluc2VydGlvbilcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoZW5jb2RlZEluc2VydGlvbilcbiAgICAgICAgfVxuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPIChARXRoYW4tQXJyb3dvb2QpOiBSZXBsYWNlIHRoZSBnZW5lcmljIGBpbmRleE9mVWludDhBcnJheWAgbWV0aG9kIHdpdGggc29tZXRoaW5nIGZpbmVseSB0dW5lZCBmb3IgdGhlIHN1YnNldCBvZiB0aGluZ3MgYWN0dWFsbHkgYmVpbmcgY2hlY2tlZCBmb3IuXG4gICAgICAgIGNvbnN0IGluZGV4ID0gaW5kZXhPZlVpbnQ4QXJyYXkoY2h1bmssIEVOQ09ERURfVEFHUy5DTE9TRUQuSEVBRClcbiAgICAgICAgLy8gSW4gZnVsbHkgc3RhdGljIHJlbmRlcmluZyBvciBub24gUFBSIHJlbmRlcmluZyBjYXNlczpcbiAgICAgICAgLy8gYC9oZWFkPmAgd2lsbCBhbHdheXMgYmUgZm91bmQgaW4gdGhlIGNodW5rIGluIGZpcnN0IGNodW5rIHJlbmRlcmluZy5cbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgIGlmIChpbnNlcnRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZWRJbnNlcnRpb24gPSBlbmNvZGVyLmVuY29kZShpbnNlcnRpb24pXG4gICAgICAgICAgICAvLyBHZXQgdGhlIHRvdGFsIGNvdW50IG9mIHRoZSBieXRlcyBpbiB0aGUgY2h1bmsgYW5kIHRoZSBpbnNlcnRpb25cbiAgICAgICAgICAgIC8vIGUuZy5cbiAgICAgICAgICAgIC8vIGNodW5rID0gPGhlYWQ+PG1ldGEgY2hhcnNldD1cInV0Zi04XCI+PC9oZWFkPlxuICAgICAgICAgICAgLy8gaW5zZXJ0aW9uID0gPHNjcmlwdD4uLi48L3NjcmlwdD5cbiAgICAgICAgICAgIC8vIG91dHB1dCA9IDxoZWFkPjxtZXRhIGNoYXJzZXQ9XCJ1dGYtOFwiPiBbIDxzY3JpcHQ+Li4uPC9zY3JpcHQ+IF0gPC9oZWFkPlxuICAgICAgICAgICAgY29uc3QgaW5zZXJ0ZWRIZWFkQ29udGVudCA9IG5ldyBVaW50OEFycmF5KFxuICAgICAgICAgICAgICBjaHVuay5sZW5ndGggKyBlbmNvZGVkSW5zZXJ0aW9uLmxlbmd0aFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLy8gQXBwZW5kIHRoZSBmaXJzdCBwYXJ0IG9mIHRoZSBjaHVuaywgYmVmb3JlIHRoZSBoZWFkIHRhZ1xuICAgICAgICAgICAgaW5zZXJ0ZWRIZWFkQ29udGVudC5zZXQoY2h1bmsuc2xpY2UoMCwgaW5kZXgpKVxuICAgICAgICAgICAgLy8gQXBwZW5kIHRoZSBzZXJ2ZXIgaW5zZXJ0ZWQgY29udGVudFxuICAgICAgICAgICAgaW5zZXJ0ZWRIZWFkQ29udGVudC5zZXQoZW5jb2RlZEluc2VydGlvbiwgaW5kZXgpXG4gICAgICAgICAgICAvLyBBcHBlbmQgdGhlIHJlc3Qgb2YgdGhlIGNodW5rXG4gICAgICAgICAgICBpbnNlcnRlZEhlYWRDb250ZW50LnNldChcbiAgICAgICAgICAgICAgY2h1bmsuc2xpY2UoaW5kZXgpLFxuICAgICAgICAgICAgICBpbmRleCArIGVuY29kZWRJbnNlcnRpb24ubGVuZ3RoXG4gICAgICAgICAgICApXG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoaW5zZXJ0ZWRIZWFkQ29udGVudClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpbnNlcnRlZCA9IHRydWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUaGlzIHdpbGwgaGFwcGVucyBpbiBQUFIgcmVuZGVyaW5nIGR1cmluZyBuZXh0IHN0YXJ0LCB3aGVuIHRoZSBwYWdlIGlzIHBhcnRpYWxseSByZW5kZXJlZC5cbiAgICAgICAgICAvLyBXaGVuIHRoZSBwYWdlIHJlc3VtZXMsIHRoZSBoZWFkIHRhZyB3aWxsIGJlIGZvdW5kIGluIHRoZSBtaWRkbGUgb2YgdGhlIGNodW5rLlxuICAgICAgICAgIC8vIFdoZXJlIHdlIGp1c3QgbmVlZCB0byBhcHBlbmQgdGhlIGluc2VydGlvbiBhbmQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgc3RyZWFtLlxuICAgICAgICAgIC8vIGUuZy5cbiAgICAgICAgICAvLyBQUFItc3RhdGljOiA8aGVhZD4uLi48L2hlYWQ+PGJvZHk+IFsgcmVzdW1lIGNvbnRlbnQgXSA8L2JvZHk+XG4gICAgICAgICAgLy8gUFBSLXJlc3VtZTogWyBpbnNlcnRpb24gXSBbIHJlc3QgY29udGVudCBdXG4gICAgICAgICAgaWYgKGluc2VydGlvbikge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGVuY29kZXIuZW5jb2RlKGluc2VydGlvbikpXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuaylcbiAgICAgICAgICBpbnNlcnRlZCA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgYXN5bmMgZmx1c2goY29udHJvbGxlcikge1xuICAgICAgLy8gQ2hlY2sgYmVmb3JlIGNsb3NpbmcgaWYgdGhlcmUncyBhbnl0aGluZyByZW1haW5pbmcgdG8gaW5zZXJ0LlxuICAgICAgaWYgKGhhc0J5dGVzKSB7XG4gICAgICAgIGNvbnN0IGluc2VydGlvbiA9IGF3YWl0IGluc2VydCgpXG4gICAgICAgIGlmIChpbnNlcnRpb24pIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoZW5jb2Rlci5lbmNvZGUoaW5zZXJ0aW9uKSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gIH0pXG59XG5cbi8vIFN1ZmZpeCBhZnRlciBtYWluIGJvZHkgY29udGVudCAtIHNjcmlwdHMgYmVmb3JlIDwvYm9keT4sXG4vLyBidXQgd2FpdCBmb3IgdGhlIG1ham9yIGNodW5rcyB0byBiZSBlbnF1ZXVlZC5cbmZ1bmN0aW9uIGNyZWF0ZURlZmVycmVkU3VmZml4U3RyZWFtKFxuICBzdWZmaXg6IHN0cmluZ1xuKTogVHJhbnNmb3JtU3RyZWFtPFVpbnQ4QXJyYXksIFVpbnQ4QXJyYXk+IHtcbiAgbGV0IGZsdXNoZWQgPSBmYWxzZVxuICBsZXQgcGVuZGluZzogRGV0YWNoZWRQcm9taXNlPHZvaWQ+IHwgdW5kZWZpbmVkXG5cbiAgY29uc3QgZmx1c2ggPSAoY29udHJvbGxlcjogVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIpID0+IHtcbiAgICBjb25zdCBkZXRhY2hlZCA9IG5ldyBEZXRhY2hlZFByb21pc2U8dm9pZD4oKVxuICAgIHBlbmRpbmcgPSBkZXRhY2hlZFxuXG4gICAgc2NoZWR1bGVJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGVuY29kZXIuZW5jb2RlKHN1ZmZpeCkpXG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgLy8gSWYgYW4gZXJyb3Igb2NjdXJzIHdoaWxlIGVucXVldWluZyBpdCBjYW4ndCBiZSBkdWUgdG8gdGhpc1xuICAgICAgICAvLyB0cmFuc2Zvcm1lcnMgZmF1bHQuIEl0J3MgbGlrZWx5IGR1ZSB0byB0aGUgY29udHJvbGxlciBiZWluZ1xuICAgICAgICAvLyBlcnJvcmVkIGR1ZSB0byB0aGUgc3RyZWFtIGJlaW5nIGNhbmNlbGxlZC5cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHBlbmRpbmcgPSB1bmRlZmluZWRcbiAgICAgICAgZGV0YWNoZWQucmVzb2x2ZSgpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuaylcblxuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBmbHVzaGVkLCB3ZSdyZSBkb25lLlxuICAgICAgaWYgKGZsdXNoZWQpIHJldHVyblxuXG4gICAgICAvLyBTY2hlZHVsZSB0aGUgZmx1c2ggdG8gaGFwcGVuLlxuICAgICAgZmx1c2hlZCA9IHRydWVcbiAgICAgIGZsdXNoKGNvbnRyb2xsZXIpXG4gICAgfSxcbiAgICBmbHVzaChjb250cm9sbGVyKSB7XG4gICAgICBpZiAocGVuZGluZykgcmV0dXJuIHBlbmRpbmcucHJvbWlzZVxuICAgICAgaWYgKGZsdXNoZWQpIHJldHVyblxuXG4gICAgICAvLyBGbHVzaCBub3cuXG4gICAgICBjb250cm9sbGVyLmVucXVldWUoZW5jb2Rlci5lbmNvZGUoc3VmZml4KSlcbiAgICB9LFxuICB9KVxufVxuXG4vLyBNZXJnZSB0d28gc3RyZWFtcyBpbnRvIG9uZS4gRW5zdXJlIHRoZSBmaW5hbCB0cmFuc2Zvcm0gc3RyZWFtIGlzIGNsb3NlZFxuLy8gd2hlbiBib3RoIGFyZSBmaW5pc2hlZC5cbmZ1bmN0aW9uIGNyZWF0ZU1lcmdlZFRyYW5zZm9ybVN0cmVhbShcbiAgc3RyZWFtOiBSZWFkYWJsZVN0cmVhbTxVaW50OEFycmF5PlxuKTogVHJhbnNmb3JtU3RyZWFtPFVpbnQ4QXJyYXksIFVpbnQ4QXJyYXk+IHtcbiAgbGV0IHB1bGw6IFByb21pc2U8dm9pZD4gfCBudWxsID0gbnVsbFxuICBsZXQgZG9uZVB1bGxpbmcgPSBmYWxzZVxuXG4gIGFzeW5jIGZ1bmN0aW9uIHN0YXJ0UHVsbGluZyhjb250cm9sbGVyOiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcikge1xuICAgIGlmIChwdWxsKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKClcblxuICAgIC8vIE5PVEU6IHN0cmVhbWluZyBmbHVzaFxuICAgIC8vIFdlIGFyZSBidWZmZXJpbmcgaGVyZSBmb3IgdGhlIGlubGluZWQgZGF0YSBzdHJlYW0gYmVjYXVzZSB0aGVcbiAgICAvLyBcInNoZWxsXCIgc3RyZWFtIG1pZ2h0IGJlIGNodW5rZW5pemVkIGFnYWluIGJ5IHRoZSB1bmRlcmx5aW5nIHN0cmVhbVxuICAgIC8vIGltcGxlbWVudGF0aW9uLCBlLmcuIHdpdGggYSBzcGVjaWZpYyBoaWdoLXdhdGVyIG1hcmsuIFRvIGVuc3VyZSBpdCdzXG4gICAgLy8gdGhlIHNhZmUgdGltaW5nIHRvIHBpcGUgdGhlIGRhdGEgc3RyZWFtLCB0aGlzIGV4dHJhIHRpY2sgaXNcbiAgICAvLyBuZWNlc3NhcnkuXG5cbiAgICAvLyBXZSBkb24ndCBzdGFydCByZWFkaW5nIHVudGlsIHdlJ3ZlIGxlZnQgdGhlIGN1cnJlbnQgVGFzayB0byBlbnN1cmVcbiAgICAvLyB0aGF0IGl0J3MgaW5zZXJ0ZWQgYWZ0ZXIgZmx1c2hpbmcgdGhlIHNoZWxsLiBOb3RlIHRoYXQgdGhpcyBpbXBsZW1lbnRhdGlvblxuICAgIC8vIG1pZ2h0IGdldCBzdGFsZSBpZiBpbXBsIGRldGFpbHMgb2YgRml6eiBjaGFuZ2UgaW4gdGhlIGZ1dHVyZS5cbiAgICBhd2FpdCBhdExlYXN0T25lVGFzaygpXG5cbiAgICB0cnkge1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKVxuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgIGRvbmVQdWxsaW5nID0gdHJ1ZVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHZhbHVlKVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29udHJvbGxlci5lcnJvcihlcnIpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKVxuXG4gICAgICAvLyBTdGFydCB0aGUgc3RyZWFtaW5nIGlmIGl0IGhhc24ndCBhbHJlYWR5IGJlZW4gc3RhcnRlZCB5ZXQuXG4gICAgICBpZiAoIXB1bGwpIHtcbiAgICAgICAgcHVsbCA9IHN0YXJ0UHVsbGluZyhjb250cm9sbGVyKVxuICAgICAgfVxuICAgIH0sXG4gICAgZmx1c2goY29udHJvbGxlcikge1xuICAgICAgaWYgKGRvbmVQdWxsaW5nKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgcmV0dXJuIHB1bGwgfHwgc3RhcnRQdWxsaW5nKGNvbnRyb2xsZXIpXG4gICAgfSxcbiAgfSlcbn1cblxuY29uc3QgQ0xPU0VfVEFHID0gJzwvYm9keT48L2h0bWw+J1xuXG4vKipcbiAqIFRoaXMgdHJhbnNmb3JtIHN0cmVhbSBtb3ZlcyB0aGUgc3VmZml4IHRvIHRoZSBlbmQgb2YgdGhlIHN0cmVhbSwgc28gcmVzdWx0c1xuICogbGlrZSBgPC9ib2R5PjwvaHRtbD48c2NyaXB0Pi4uLjwvc2NyaXB0PmAgd2lsbCBiZSB0cmFuc2Zvcm1lZCB0b1xuICogYDxzY3JpcHQ+Li4uPC9zY3JpcHQ+PC9ib2R5PjwvaHRtbD5gLlxuICovXG5mdW5jdGlvbiBjcmVhdGVNb3ZlU3VmZml4U3RyZWFtKCk6IFRyYW5zZm9ybVN0cmVhbTxVaW50OEFycmF5LCBVaW50OEFycmF5PiB7XG4gIGxldCBmb3VuZFN1ZmZpeCA9IGZhbHNlXG5cbiAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgaWYgKGZvdW5kU3VmZml4KSB7XG4gICAgICAgIHJldHVybiBjb250cm9sbGVyLmVucXVldWUoY2h1bmspXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGluZGV4ID0gaW5kZXhPZlVpbnQ4QXJyYXkoY2h1bmssIEVOQ09ERURfVEFHUy5DTE9TRUQuQk9EWV9BTkRfSFRNTClcbiAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgIGZvdW5kU3VmZml4ID0gdHJ1ZVxuXG4gICAgICAgIC8vIElmIHRoZSB3aG9sZSBjaHVuayBpcyB0aGUgc3VmZml4LCB0aGVuIGRvbid0IHdyaXRlIGFueXRoaW5nLCBpdCB3aWxsXG4gICAgICAgIC8vIGJlIHdyaXR0ZW4gaW4gdGhlIGZsdXNoLlxuICAgICAgICBpZiAoY2h1bmsubGVuZ3RoID09PSBFTkNPREVEX1RBR1MuQ0xPU0VELkJPRFlfQU5EX0hUTUwubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBXcml0ZSBvdXQgdGhlIHBhcnQgYmVmb3JlIHRoZSBzdWZmaXguXG4gICAgICAgIGNvbnN0IGJlZm9yZSA9IGNodW5rLnNsaWNlKDAsIGluZGV4KVxuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoYmVmb3JlKVxuXG4gICAgICAgIC8vIEluIHRoZSBjYXNlIHdoZXJlIHRoZSBzdWZmaXggaXMgaW4gdGhlIG1pZGRsZSBvZiB0aGUgY2h1bmssIHdlIG5lZWRcbiAgICAgICAgLy8gdG8gc3BsaXQgdGhlIGNodW5rIGludG8gdHdvIHBhcnRzLlxuICAgICAgICBpZiAoY2h1bmsubGVuZ3RoID4gRU5DT0RFRF9UQUdTLkNMT1NFRC5CT0RZX0FORF9IVE1MLmxlbmd0aCArIGluZGV4KSB7XG4gICAgICAgICAgLy8gV3JpdGUgb3V0IHRoZSBwYXJ0IGFmdGVyIHRoZSBzdWZmaXguXG4gICAgICAgICAgY29uc3QgYWZ0ZXIgPSBjaHVuay5zbGljZShcbiAgICAgICAgICAgIGluZGV4ICsgRU5DT0RFRF9UQUdTLkNMT1NFRC5CT0RZX0FORF9IVE1MLmxlbmd0aFxuICAgICAgICAgIClcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoYWZ0ZXIpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuaylcbiAgICAgIH1cbiAgICB9LFxuICAgIGZsdXNoKGNvbnRyb2xsZXIpIHtcbiAgICAgIC8vIEV2ZW4gaWYgd2UgZGlkbid0IGZpbmQgdGhlIHN1ZmZpeCwgdGhlIEhUTUwgaXMgbm90IHZhbGlkIGlmIHdlIGRvbid0XG4gICAgICAvLyBhZGQgaXQsIHNvIGluc2VydCBpdCBhdCB0aGUgZW5kLlxuICAgICAgY29udHJvbGxlci5lbnF1ZXVlKEVOQ09ERURfVEFHUy5DTE9TRUQuQk9EWV9BTkRfSFRNTClcbiAgICB9LFxuICB9KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHJpcERvY3VtZW50Q2xvc2luZ1RhZ3NUcmFuc2Zvcm0oKTogVHJhbnNmb3JtU3RyZWFtPFxuICBVaW50OEFycmF5LFxuICBVaW50OEFycmF5XG4+IHtcbiAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgLy8gV2UgcmVseSBvbiB0aGUgYXNzdW1wdGlvbiB0aGF0IGNodW5rcyB3aWxsIG5ldmVyIGJyZWFrIGFjcm9zcyBhIGNvZGUgdW5pdC5cbiAgICAgIC8vIFRoaXMgaXMgcmVhc29uYWJsZSBiZWNhdXNlIHdlIGN1cnJlbnRseSBjb25jYXQgYWxsIG9mIFJlYWN0J3Mgb3V0cHV0IGZyb20gYSBzaW5nbGVcbiAgICAgIC8vIGZsdXNoIGludG8gb25lIGNodW5rIGJlZm9yZSBzdHJlYW1pbmcgaXQgZm9yd2FyZCB3aGljaCBtZWFucyB0aGUgY2h1bmsgd2lsbCByZXByZXNlbnRcbiAgICAgIC8vIGEgc2luZ2xlIGNvaGVyZW50IHV0Zi04IHN0cmluZy4gVGhpcyBpcyBub3Qgc2FmZSB0byB1c2UgaWYgd2UgY2hhbmdlIG91ciBzdHJlYW1pbmcgdG8gbm9cbiAgICAgIC8vIGxvbmdlciBkbyB0aGlzIGxhcmdlIGJ1ZmZlcmVkIGNodW5rXG4gICAgICBpZiAoXG4gICAgICAgIGlzRXF1aXZhbGVudFVpbnQ4QXJyYXlzKGNodW5rLCBFTkNPREVEX1RBR1MuQ0xPU0VELkJPRFlfQU5EX0hUTUwpIHx8XG4gICAgICAgIGlzRXF1aXZhbGVudFVpbnQ4QXJyYXlzKGNodW5rLCBFTkNPREVEX1RBR1MuQ0xPU0VELkJPRFkpIHx8XG4gICAgICAgIGlzRXF1aXZhbGVudFVpbnQ4QXJyYXlzKGNodW5rLCBFTkNPREVEX1RBR1MuQ0xPU0VELkhUTUwpXG4gICAgICApIHtcbiAgICAgICAgLy8gdGhlIGVudGlyZSBjaHVuayBpcyB0aGUgY2xvc2luZyB0YWdzOyByZXR1cm4gd2l0aG91dCBlbnF1ZXVlaW5nIGFueXRoaW5nLlxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gV2UgYXNzdW1lIHRoZXNlIHRhZ3Mgd2lsbCBnbyBhdCB0b2dldGhlciBhdCB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudCBhbmQgdGhhdFxuICAgICAgLy8gdGhleSB3b24ndCBhcHBlYXIgYW55d2hlcmUgZWxzZSBpbiB0aGUgZG9jdW1lbnQuIFRoaXMgaXMgbm90IHJlYWxseSBhIHNhZmUgYXNzdW1wdGlvblxuICAgICAgLy8gYnV0IHVudGlsIHdlIHJldmFtcCBvdXIgc3RyZWFtaW5nIGluZnJhIHRoaXMgaXMgYSBwZXJmb3JtYW50IHdheSB0byBzdHJpbmcgdGhlIHRhZ3NcbiAgICAgIGNodW5rID0gcmVtb3ZlRnJvbVVpbnQ4QXJyYXkoY2h1bmssIEVOQ09ERURfVEFHUy5DTE9TRUQuQk9EWSlcbiAgICAgIGNodW5rID0gcmVtb3ZlRnJvbVVpbnQ4QXJyYXkoY2h1bmssIEVOQ09ERURfVEFHUy5DTE9TRUQuSFRNTClcblxuICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKVxuICAgIH0sXG4gIH0pXG59XG5cbi8qXG4gKiBDaGVja3MgaWYgdGhlIHJvb3QgbGF5b3V0IGlzIG1pc3NpbmcgdGhlIGh0bWwgb3IgYm9keSB0YWdzXG4gKiBhbmQgaWYgc28sIGl0IHdpbGwgaW5qZWN0IGEgc2NyaXB0IHRhZyB0byB0aHJvdyBhbiBlcnJvciBpbiB0aGUgYnJvd3Nlciwgc2hvd2luZyB0aGUgdXNlclxuICogdGhlIGVycm9yIG1lc3NhZ2UgaW4gdGhlIGVycm9yIG92ZXJsYXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSb290TGF5b3V0VmFsaWRhdG9yU3RyZWFtKCk6IFRyYW5zZm9ybVN0cmVhbTxcbiAgVWludDhBcnJheSxcbiAgVWludDhBcnJheVxuPiB7XG4gIGxldCBmb3VuZEh0bWwgPSBmYWxzZVxuICBsZXQgZm91bmRCb2R5ID0gZmFsc2VcbiAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgIGFzeW5jIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgLy8gUGVlayBpbnRvIHRoZSBzdHJlYW1lZCBjaHVuayB0byBzZWUgaWYgdGhlIHRhZ3MgYXJlIHByZXNlbnQuXG4gICAgICBpZiAoXG4gICAgICAgICFmb3VuZEh0bWwgJiZcbiAgICAgICAgaW5kZXhPZlVpbnQ4QXJyYXkoY2h1bmssIEVOQ09ERURfVEFHUy5PUEVOSU5HLkhUTUwpID4gLTFcbiAgICAgICkge1xuICAgICAgICBmb3VuZEh0bWwgPSB0cnVlXG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgIWZvdW5kQm9keSAmJlxuICAgICAgICBpbmRleE9mVWludDhBcnJheShjaHVuaywgRU5DT0RFRF9UQUdTLk9QRU5JTkcuQk9EWSkgPiAtMVxuICAgICAgKSB7XG4gICAgICAgIGZvdW5kQm9keSA9IHRydWVcbiAgICAgIH1cblxuICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKVxuICAgIH0sXG4gICAgZmx1c2goY29udHJvbGxlcikge1xuICAgICAgY29uc3QgbWlzc2luZ1RhZ3M6ICgnaHRtbCcgfCAnYm9keScpW10gPSBbXVxuICAgICAgaWYgKCFmb3VuZEh0bWwpIG1pc3NpbmdUYWdzLnB1c2goJ2h0bWwnKVxuICAgICAgaWYgKCFmb3VuZEJvZHkpIG1pc3NpbmdUYWdzLnB1c2goJ2JvZHknKVxuXG4gICAgICBpZiAoIW1pc3NpbmdUYWdzLmxlbmd0aCkgcmV0dXJuXG5cbiAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgZW5jb2Rlci5lbmNvZGUoXG4gICAgICAgICAgYDxodG1sIGlkPVwiX19uZXh0X2Vycm9yX19cIj5cbiAgICAgICAgICAgIDx0ZW1wbGF0ZVxuICAgICAgICAgICAgICBkYXRhLW5leHQtZXJyb3ItbWVzc2FnZT1cIk1pc3NpbmcgJHttaXNzaW5nVGFnc1xuICAgICAgICAgICAgICAgIC5tYXAoKGMpID0+IGA8JHtjfT5gKVxuICAgICAgICAgICAgICAgIC5qb2luKFxuICAgICAgICAgICAgICAgICAgbWlzc2luZ1RhZ3MubGVuZ3RoID4gMSA/ICcgYW5kICcgOiAnJ1xuICAgICAgICAgICAgICAgICl9IHRhZ3MgaW4gdGhlIHJvb3QgbGF5b3V0LlxcblJlYWQgbW9yZSBhdCBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9taXNzaW5nLXJvb3QtbGF5b3V0LXRhZ3NcIlwiXG4gICAgICAgICAgICAgIGRhdGEtbmV4dC1lcnJvci1kaWdlc3Q9XCIke01JU1NJTkdfUk9PVF9UQUdTX0VSUk9SfVwiXG4gICAgICAgICAgICAgIGRhdGEtbmV4dC1lcnJvci1zdGFjaz1cIlwiXG4gICAgICAgICAgICA+PC90ZW1wbGF0ZT5cbiAgICAgICAgICBgXG4gICAgICAgIClcbiAgICAgIClcbiAgICB9LFxuICB9KVxufVxuXG5mdW5jdGlvbiBjaGFpblRyYW5zZm9ybWVyczxUPihcbiAgcmVhZGFibGU6IFJlYWRhYmxlU3RyZWFtPFQ+LFxuICB0cmFuc2Zvcm1lcnM6IFJlYWRvbmx5QXJyYXk8VHJhbnNmb3JtU3RyZWFtPFQsIFQ+IHwgbnVsbD5cbik6IFJlYWRhYmxlU3RyZWFtPFQ+IHtcbiAgbGV0IHN0cmVhbSA9IHJlYWRhYmxlXG4gIGZvciAoY29uc3QgdHJhbnNmb3JtZXIgb2YgdHJhbnNmb3JtZXJzKSB7XG4gICAgaWYgKCF0cmFuc2Zvcm1lcikgY29udGludWVcblxuICAgIHN0cmVhbSA9IHN0cmVhbS5waXBlVGhyb3VnaCh0cmFuc2Zvcm1lcilcbiAgfVxuICByZXR1cm4gc3RyZWFtXG59XG5cbmV4cG9ydCB0eXBlIENvbnRpbnVlU3RyZWFtT3B0aW9ucyA9IHtcbiAgaW5saW5lZERhdGFTdHJlYW06IFJlYWRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+IHwgdW5kZWZpbmVkXG4gIGlzU3RhdGljR2VuZXJhdGlvbjogYm9vbGVhblxuICBpc0J1aWxkVGltZVByZXJlbmRlcmluZzogYm9vbGVhblxuICBidWlsZElkOiBzdHJpbmdcbiAgZ2V0U2VydmVySW5zZXJ0ZWRIVE1MOiAoKSA9PiBQcm9taXNlPHN0cmluZz5cbiAgZ2V0U2VydmVySW5zZXJ0ZWRNZXRhZGF0YTogKCkgPT4gUHJvbWlzZTxzdHJpbmc+XG4gIHZhbGlkYXRlUm9vdExheW91dD86IGJvb2xlYW5cbiAgLyoqXG4gICAqIFN1ZmZpeCB0byBpbmplY3QgYWZ0ZXIgdGhlIGJ1ZmZlcmVkIGRhdGEsIGJ1dCBiZWZvcmUgdGhlIGNsb3NlIHRhZ3MuXG4gICAqL1xuICBzdWZmaXg/OiBzdHJpbmcgfCB1bmRlZmluZWRcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNvbnRpbnVlRml6elN0cmVhbShcbiAgcmVuZGVyU3RyZWFtOiBSZWFjdFJlYWRhYmxlU3RyZWFtLFxuICB7XG4gICAgc3VmZml4LFxuICAgIGlubGluZWREYXRhU3RyZWFtLFxuICAgIGlzU3RhdGljR2VuZXJhdGlvbixcbiAgICBpc0J1aWxkVGltZVByZXJlbmRlcmluZyxcbiAgICBidWlsZElkLFxuICAgIGdldFNlcnZlckluc2VydGVkSFRNTCxcbiAgICBnZXRTZXJ2ZXJJbnNlcnRlZE1ldGFkYXRhLFxuICAgIHZhbGlkYXRlUm9vdExheW91dCxcbiAgfTogQ29udGludWVTdHJlYW1PcHRpb25zXG4pOiBQcm9taXNlPFJlYWRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+PiB7XG4gIC8vIFN1ZmZpeCBpdHNlbGYgbWlnaHQgY29udGFpbiBjbG9zZSB0YWdzIGF0IHRoZSBlbmQsIHNvIHdlIG5lZWQgdG8gc3BsaXQgaXQuXG4gIGNvbnN0IHN1ZmZpeFVuY2xvc2VkID0gc3VmZml4ID8gc3VmZml4LnNwbGl0KENMT1NFX1RBRywgMSlbMF0gOiBudWxsXG5cbiAgLy8gSWYgd2UncmUgZ2VuZXJhdGluZyBzdGF0aWMgSFRNTCBhbmQgdGhlcmUncyBhbiBgYWxsUmVhZHlgIHByb21pc2Ugb24gdGhlXG4gIC8vIHN0cmVhbSwgd2UgbmVlZCB0byB3YWl0IGZvciBpdCB0byByZXNvbHZlIGJlZm9yZSBjb250aW51aW5nLlxuICBpZiAoaXNTdGF0aWNHZW5lcmF0aW9uICYmICdhbGxSZWFkeScgaW4gcmVuZGVyU3RyZWFtKSB7XG4gICAgYXdhaXQgcmVuZGVyU3RyZWFtLmFsbFJlYWR5XG4gIH1cblxuICByZXR1cm4gY2hhaW5UcmFuc2Zvcm1lcnMocmVuZGVyU3RyZWFtLCBbXG4gICAgLy8gQnVmZmVyIGV2ZXJ5dGhpbmcgdG8gYXZvaWQgZmx1c2hpbmcgdG9vIGZyZXF1ZW50bHlcbiAgICBjcmVhdGVCdWZmZXJlZFRyYW5zZm9ybVN0cmVhbSgpLFxuXG4gICAgLy8gQWRkIGJ1aWxkIGlkIGNvbW1lbnQgdG8gc3RhcnQgb2YgdGhlIEhUTUwgZG9jdW1lbnQgKGluIGV4cG9ydCBtb2RlKVxuICAgIGNyZWF0ZVByZWZldGNoQ29tbWVudFN0cmVhbShpc0J1aWxkVGltZVByZXJlbmRlcmluZywgYnVpbGRJZCksXG5cbiAgICAvLyBUcmFuc2Zvcm0gbWV0YWRhdGFcbiAgICBjcmVhdGVNZXRhZGF0YVRyYW5zZm9ybVN0cmVhbShnZXRTZXJ2ZXJJbnNlcnRlZE1ldGFkYXRhKSxcblxuICAgIC8vIEluc2VydCBzdWZmaXggY29udGVudFxuICAgIHN1ZmZpeFVuY2xvc2VkICE9IG51bGwgJiYgc3VmZml4VW5jbG9zZWQubGVuZ3RoID4gMFxuICAgICAgPyBjcmVhdGVEZWZlcnJlZFN1ZmZpeFN0cmVhbShzdWZmaXhVbmNsb3NlZClcbiAgICAgIDogbnVsbCxcblxuICAgIC8vIEluc2VydCB0aGUgaW5saW5lZCBkYXRhIChGbGlnaHQgZGF0YSwgZm9ybSBzdGF0ZSwgZXRjLikgc3RyZWFtIGludG8gdGhlIEhUTUxcbiAgICBpbmxpbmVkRGF0YVN0cmVhbSA/IGNyZWF0ZU1lcmdlZFRyYW5zZm9ybVN0cmVhbShpbmxpbmVkRGF0YVN0cmVhbSkgOiBudWxsLFxuXG4gICAgLy8gVmFsaWRhdGUgdGhlIHJvb3QgbGF5b3V0IGZvciBtaXNzaW5nIGh0bWwgb3IgYm9keSB0YWdzXG4gICAgdmFsaWRhdGVSb290TGF5b3V0ID8gY3JlYXRlUm9vdExheW91dFZhbGlkYXRvclN0cmVhbSgpIDogbnVsbCxcblxuICAgIC8vIENsb3NlIHRhZ3Mgc2hvdWxkIGFsd2F5cyBiZSBkZWZlcnJlZCB0byB0aGUgZW5kXG4gICAgY3JlYXRlTW92ZVN1ZmZpeFN0cmVhbSgpLFxuXG4gICAgLy8gU3BlY2lhbCBoZWFkIGluc2VydGlvbnNcbiAgICAvLyBUT0RPLUFQUDogSW5zZXJ0IHNlcnZlciBzaWRlIGh0bWwgdG8gZW5kIG9mIGhlYWQgaW4gYXBwIGxheW91dCByZW5kZXJpbmcsIHRvIGF2b2lkXG4gICAgLy8gaHlkcmF0aW9uIGVycm9ycy4gUmVtb3ZlIHRoaXMgb25jZSBpdCdzIHJlYWR5IHRvIGJlIGhhbmRsZWQgYnkgcmVhY3QgaXRzZWxmLlxuICAgIGNyZWF0ZUhlYWRJbnNlcnRpb25UcmFuc2Zvcm1TdHJlYW0oZ2V0U2VydmVySW5zZXJ0ZWRIVE1MKSxcbiAgXSlcbn1cblxudHlwZSBDb250aW51ZUR5bmFtaWNQcmVyZW5kZXJPcHRpb25zID0ge1xuICBnZXRTZXJ2ZXJJbnNlcnRlZEhUTUw6ICgpID0+IFByb21pc2U8c3RyaW5nPlxuICBnZXRTZXJ2ZXJJbnNlcnRlZE1ldGFkYXRhOiAoKSA9PiBQcm9taXNlPHN0cmluZz5cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNvbnRpbnVlRHluYW1pY1ByZXJlbmRlcihcbiAgcHJlcmVuZGVyU3RyZWFtOiBSZWFkYWJsZVN0cmVhbTxVaW50OEFycmF5PixcbiAge1xuICAgIGdldFNlcnZlckluc2VydGVkSFRNTCxcbiAgICBnZXRTZXJ2ZXJJbnNlcnRlZE1ldGFkYXRhLFxuICB9OiBDb250aW51ZUR5bmFtaWNQcmVyZW5kZXJPcHRpb25zXG4pIHtcbiAgcmV0dXJuIChcbiAgICBwcmVyZW5kZXJTdHJlYW1cbiAgICAgIC8vIEJ1ZmZlciBldmVyeXRoaW5nIHRvIGF2b2lkIGZsdXNoaW5nIHRvbyBmcmVxdWVudGx5XG4gICAgICAucGlwZVRocm91Z2goY3JlYXRlQnVmZmVyZWRUcmFuc2Zvcm1TdHJlYW0oKSlcbiAgICAgIC5waXBlVGhyb3VnaChjcmVhdGVTdHJpcERvY3VtZW50Q2xvc2luZ1RhZ3NUcmFuc2Zvcm0oKSlcbiAgICAgIC8vIEluc2VydCBnZW5lcmF0ZWQgdGFncyB0byBoZWFkXG4gICAgICAucGlwZVRocm91Z2goY3JlYXRlSGVhZEluc2VydGlvblRyYW5zZm9ybVN0cmVhbShnZXRTZXJ2ZXJJbnNlcnRlZEhUTUwpKVxuICAgICAgLy8gVHJhbnNmb3JtIG1ldGFkYXRhXG4gICAgICAucGlwZVRocm91Z2goY3JlYXRlTWV0YWRhdGFUcmFuc2Zvcm1TdHJlYW0oZ2V0U2VydmVySW5zZXJ0ZWRNZXRhZGF0YSkpXG4gIClcbn1cblxudHlwZSBDb250aW51ZVN0YXRpY1ByZXJlbmRlck9wdGlvbnMgPSB7XG4gIGlubGluZWREYXRhU3RyZWFtOiBSZWFkYWJsZVN0cmVhbTxVaW50OEFycmF5PlxuICBnZXRTZXJ2ZXJJbnNlcnRlZEhUTUw6ICgpID0+IFByb21pc2U8c3RyaW5nPlxuICBnZXRTZXJ2ZXJJbnNlcnRlZE1ldGFkYXRhOiAoKSA9PiBQcm9taXNlPHN0cmluZz5cbiAgaXNCdWlsZFRpbWVQcmVyZW5kZXJpbmc6IGJvb2xlYW5cbiAgYnVpbGRJZDogc3RyaW5nXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb250aW51ZVN0YXRpY1ByZXJlbmRlcihcbiAgcHJlcmVuZGVyU3RyZWFtOiBSZWFkYWJsZVN0cmVhbTxVaW50OEFycmF5PixcbiAge1xuICAgIGlubGluZWREYXRhU3RyZWFtLFxuICAgIGdldFNlcnZlckluc2VydGVkSFRNTCxcbiAgICBnZXRTZXJ2ZXJJbnNlcnRlZE1ldGFkYXRhLFxuICAgIGlzQnVpbGRUaW1lUHJlcmVuZGVyaW5nLFxuICAgIGJ1aWxkSWQsXG4gIH06IENvbnRpbnVlU3RhdGljUHJlcmVuZGVyT3B0aW9uc1xuKSB7XG4gIHJldHVybiAoXG4gICAgcHJlcmVuZGVyU3RyZWFtXG4gICAgICAvLyBCdWZmZXIgZXZlcnl0aGluZyB0byBhdm9pZCBmbHVzaGluZyB0b28gZnJlcXVlbnRseVxuICAgICAgLnBpcGVUaHJvdWdoKGNyZWF0ZUJ1ZmZlcmVkVHJhbnNmb3JtU3RyZWFtKCkpXG4gICAgICAvLyBBZGQgYnVpbGQgaWQgY29tbWVudCB0byBzdGFydCBvZiB0aGUgSFRNTCBkb2N1bWVudCAoaW4gZXhwb3J0IG1vZGUpXG4gICAgICAucGlwZVRocm91Z2goXG4gICAgICAgIGNyZWF0ZVByZWZldGNoQ29tbWVudFN0cmVhbShpc0J1aWxkVGltZVByZXJlbmRlcmluZywgYnVpbGRJZClcbiAgICAgIClcbiAgICAgIC8vIEluc2VydCBnZW5lcmF0ZWQgdGFncyB0byBoZWFkXG4gICAgICAucGlwZVRocm91Z2goY3JlYXRlSGVhZEluc2VydGlvblRyYW5zZm9ybVN0cmVhbShnZXRTZXJ2ZXJJbnNlcnRlZEhUTUwpKVxuICAgICAgLy8gVHJhbnNmb3JtIG1ldGFkYXRhXG4gICAgICAucGlwZVRocm91Z2goY3JlYXRlTWV0YWRhdGFUcmFuc2Zvcm1TdHJlYW0oZ2V0U2VydmVySW5zZXJ0ZWRNZXRhZGF0YSkpXG4gICAgICAvLyBJbnNlcnQgdGhlIGlubGluZWQgZGF0YSAoRmxpZ2h0IGRhdGEsIGZvcm0gc3RhdGUsIGV0Yy4pIHN0cmVhbSBpbnRvIHRoZSBIVE1MXG4gICAgICAucGlwZVRocm91Z2goY3JlYXRlTWVyZ2VkVHJhbnNmb3JtU3RyZWFtKGlubGluZWREYXRhU3RyZWFtKSlcbiAgICAgIC8vIENsb3NlIHRhZ3Mgc2hvdWxkIGFsd2F5cyBiZSBkZWZlcnJlZCB0byB0aGUgZW5kXG4gICAgICAucGlwZVRocm91Z2goY3JlYXRlTW92ZVN1ZmZpeFN0cmVhbSgpKVxuICApXG59XG5cbnR5cGUgQ29udGludWVSZXN1bWVPcHRpb25zID0ge1xuICBpbmxpbmVkRGF0YVN0cmVhbTogUmVhZGFibGVTdHJlYW08VWludDhBcnJheT5cbiAgZ2V0U2VydmVySW5zZXJ0ZWRIVE1MOiAoKSA9PiBQcm9taXNlPHN0cmluZz5cbiAgZ2V0U2VydmVySW5zZXJ0ZWRNZXRhZGF0YTogKCkgPT4gUHJvbWlzZTxzdHJpbmc+XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb250aW51ZUR5bmFtaWNIVE1MUmVzdW1lKFxuICByZW5kZXJTdHJlYW06IFJlYWRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+LFxuICB7XG4gICAgaW5saW5lZERhdGFTdHJlYW0sXG4gICAgZ2V0U2VydmVySW5zZXJ0ZWRIVE1MLFxuICAgIGdldFNlcnZlckluc2VydGVkTWV0YWRhdGEsXG4gIH06IENvbnRpbnVlUmVzdW1lT3B0aW9uc1xuKSB7XG4gIHJldHVybiAoXG4gICAgcmVuZGVyU3RyZWFtXG4gICAgICAvLyBCdWZmZXIgZXZlcnl0aGluZyB0byBhdm9pZCBmbHVzaGluZyB0b28gZnJlcXVlbnRseVxuICAgICAgLnBpcGVUaHJvdWdoKGNyZWF0ZUJ1ZmZlcmVkVHJhbnNmb3JtU3RyZWFtKCkpXG4gICAgICAvLyBJbnNlcnQgZ2VuZXJhdGVkIHRhZ3MgdG8gaGVhZFxuICAgICAgLnBpcGVUaHJvdWdoKGNyZWF0ZUhlYWRJbnNlcnRpb25UcmFuc2Zvcm1TdHJlYW0oZ2V0U2VydmVySW5zZXJ0ZWRIVE1MKSlcbiAgICAgIC8vIFRyYW5zZm9ybSBtZXRhZGF0YVxuICAgICAgLnBpcGVUaHJvdWdoKGNyZWF0ZU1ldGFkYXRhVHJhbnNmb3JtU3RyZWFtKGdldFNlcnZlckluc2VydGVkTWV0YWRhdGEpKVxuICAgICAgLy8gSW5zZXJ0IHRoZSBpbmxpbmVkIGRhdGEgKEZsaWdodCBkYXRhLCBmb3JtIHN0YXRlLCBldGMuKSBzdHJlYW0gaW50byB0aGUgSFRNTFxuICAgICAgLnBpcGVUaHJvdWdoKGNyZWF0ZU1lcmdlZFRyYW5zZm9ybVN0cmVhbShpbmxpbmVkRGF0YVN0cmVhbSkpXG4gICAgICAvLyBDbG9zZSB0YWdzIHNob3VsZCBhbHdheXMgYmUgZGVmZXJyZWQgdG8gdGhlIGVuZFxuICAgICAgLnBpcGVUaHJvdWdoKGNyZWF0ZU1vdmVTdWZmaXhTdHJlYW0oKSlcbiAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRG9jdW1lbnRDbG9zaW5nU3RyZWFtKCk6IFJlYWRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+IHtcbiAgcmV0dXJuIHN0cmVhbUZyb21TdHJpbmcoQ0xPU0VfVEFHKVxufVxuIl0sIm5hbWVzIjpbImdldFRyYWNlciIsIkFwcFJlbmRlclNwYW4iLCJEZXRhY2hlZFByb21pc2UiLCJzY2hlZHVsZUltbWVkaWF0ZSIsImF0TGVhc3RPbmVUYXNrIiwiRU5DT0RFRF9UQUdTIiwiaW5kZXhPZlVpbnQ4QXJyYXkiLCJpc0VxdWl2YWxlbnRVaW50OEFycmF5cyIsInJlbW92ZUZyb21VaW50OEFycmF5IiwiTUlTU0lOR19ST09UX1RBR1NfRVJST1IiLCJpbnNlcnRCdWlsZElkQ29tbWVudCIsInZvaWRDYXRjaCIsImVuY29kZXIiLCJUZXh0RW5jb2RlciIsImNoYWluU3RyZWFtcyIsInN0cmVhbXMiLCJsZW5ndGgiLCJFcnJvciIsInJlYWRhYmxlIiwid3JpdGFibGUiLCJUcmFuc2Zvcm1TdHJlYW0iLCJwcm9taXNlIiwicGlwZVRvIiwicHJldmVudENsb3NlIiwiaSIsIm5leHRTdHJlYW0iLCJ0aGVuIiwibGFzdFN0cmVhbSIsImNhdGNoIiwic3RyZWFtRnJvbVN0cmluZyIsInN0ciIsIlJlYWRhYmxlU3RyZWFtIiwic3RhcnQiLCJjb250cm9sbGVyIiwiZW5xdWV1ZSIsImVuY29kZSIsImNsb3NlIiwic3RyZWFtRnJvbUJ1ZmZlciIsImNodW5rIiwic3RyZWFtVG9CdWZmZXIiLCJzdHJlYW0iLCJyZWFkZXIiLCJnZXRSZWFkZXIiLCJjaHVua3MiLCJkb25lIiwidmFsdWUiLCJyZWFkIiwicHVzaCIsIkJ1ZmZlciIsImNvbmNhdCIsInN0cmVhbVRvU3RyaW5nIiwic2lnbmFsIiwiZGVjb2RlciIsIlRleHREZWNvZGVyIiwiZmF0YWwiLCJzdHJpbmciLCJhYm9ydGVkIiwiZGVjb2RlIiwiY3JlYXRlQnVmZmVyZWRUcmFuc2Zvcm1TdHJlYW0iLCJidWZmZXJlZENodW5rcyIsImJ1ZmZlckJ5dGVMZW5ndGgiLCJwZW5kaW5nIiwiZmx1c2giLCJkZXRhY2hlZCIsIlVpbnQ4QXJyYXkiLCJjb3BpZWRCeXRlcyIsImJ1ZmZlcmVkQ2h1bmsiLCJzZXQiLCJieXRlTGVuZ3RoIiwidW5kZWZpbmVkIiwicmVzb2x2ZSIsInRyYW5zZm9ybSIsImNyZWF0ZVByZWZldGNoQ29tbWVudFN0cmVhbSIsImlzQnVpbGRUaW1lUHJlcmVuZGVyaW5nIiwiYnVpbGRJZCIsImRpZFRyYW5zZm9ybUZpcnN0Q2h1bmsiLCJjaHVua1N0ciIsInVwZGF0ZWRDaHVua1N0ciIsInJlbmRlclRvSW5pdGlhbEZpenpTdHJlYW0iLCJSZWFjdERPTVNlcnZlciIsImVsZW1lbnQiLCJzdHJlYW1PcHRpb25zIiwidHJhY2UiLCJyZW5kZXJUb1JlYWRhYmxlU3RyZWFtIiwiY3JlYXRlTWV0YWRhdGFUcmFuc2Zvcm1TdHJlYW0iLCJpbnNlcnQiLCJjaHVua0luZGV4IiwiaXNNYXJrUmVtb3ZlZCIsImljb25NYXJrSW5kZXgiLCJjbG9zZWRIZWFkSW5kZXgiLCJpY29uTWFya0xlbmd0aCIsIk1FVEEiLCJJQ09OX01BUksiLCJDTE9TRUQiLCJIRUFEIiwicmVwbGFjZWQiLCJzdWJhcnJheSIsImluc2VydGlvbiIsImVuY29kZWRJbnNlcnRpb24iLCJpbnNlcnRpb25MZW5ndGgiLCJjcmVhdGVIZWFkSW5zZXJ0aW9uVHJhbnNmb3JtU3RyZWFtIiwiaW5zZXJ0ZWQiLCJoYXNCeXRlcyIsImluZGV4IiwiaW5zZXJ0ZWRIZWFkQ29udGVudCIsInNsaWNlIiwiY3JlYXRlRGVmZXJyZWRTdWZmaXhTdHJlYW0iLCJzdWZmaXgiLCJmbHVzaGVkIiwiY3JlYXRlTWVyZ2VkVHJhbnNmb3JtU3RyZWFtIiwicHVsbCIsImRvbmVQdWxsaW5nIiwic3RhcnRQdWxsaW5nIiwiZXJyIiwiZXJyb3IiLCJDTE9TRV9UQUciLCJjcmVhdGVNb3ZlU3VmZml4U3RyZWFtIiwiZm91bmRTdWZmaXgiLCJCT0RZX0FORF9IVE1MIiwiYmVmb3JlIiwiYWZ0ZXIiLCJjcmVhdGVTdHJpcERvY3VtZW50Q2xvc2luZ1RhZ3NUcmFuc2Zvcm0iLCJCT0RZIiwiSFRNTCIsImNyZWF0ZVJvb3RMYXlvdXRWYWxpZGF0b3JTdHJlYW0iLCJmb3VuZEh0bWwiLCJmb3VuZEJvZHkiLCJPUEVOSU5HIiwibWlzc2luZ1RhZ3MiLCJtYXAiLCJjIiwiam9pbiIsImNoYWluVHJhbnNmb3JtZXJzIiwidHJhbnNmb3JtZXJzIiwidHJhbnNmb3JtZXIiLCJwaXBlVGhyb3VnaCIsImNvbnRpbnVlRml6elN0cmVhbSIsInJlbmRlclN0cmVhbSIsImlubGluZWREYXRhU3RyZWFtIiwiaXNTdGF0aWNHZW5lcmF0aW9uIiwiZ2V0U2VydmVySW5zZXJ0ZWRIVE1MIiwiZ2V0U2VydmVySW5zZXJ0ZWRNZXRhZGF0YSIsInZhbGlkYXRlUm9vdExheW91dCIsInN1ZmZpeFVuY2xvc2VkIiwic3BsaXQiLCJhbGxSZWFkeSIsImNvbnRpbnVlRHluYW1pY1ByZXJlbmRlciIsInByZXJlbmRlclN0cmVhbSIsImNvbnRpbnVlU3RhdGljUHJlcmVuZGVyIiwiY29udGludWVEeW5hbWljSFRNTFJlc3VtZSIsImNyZWF0ZURvY3VtZW50Q2xvc2luZ1N0cmVhbSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsU0FBU0EsU0FBUyxRQUFRLHNCQUFxQjtBQUMvQyxTQUFTQyxhQUFhLFFBQVEseUJBQXdCO0FBQ3RELFNBQVNDLGVBQWUsUUFBUSw2QkFBNEI7QUFDNUQsU0FBU0MsaUJBQWlCLEVBQUVDLGNBQWMsUUFBUSxzQkFBcUI7QUFDdkUsU0FBU0MsWUFBWSxRQUFRLGlCQUFnQjtBQUM3QyxTQUNFQyxpQkFBaUIsRUFDakJDLHVCQUF1QixFQUN2QkMsb0JBQW9CLFFBQ2YsdUJBQXNCO0FBQzdCLFNBQVNDLHVCQUF1QixRQUFRLG9DQUFtQztBQUMzRSxTQUFTQyxvQkFBb0IsUUFBUSxpRUFBZ0U7Ozs7Ozs7OztBQUVyRyxTQUFTQztBQUNQLGlGQUFpRjtBQUNqRix1RkFBdUY7QUFDdkYsbUJBQW1CO0FBQ3JCO0FBTUEsb0RBQW9EO0FBQ3BELHVFQUF1RTtBQUN2RSwrQkFBK0I7QUFDL0IsTUFBTUMsVUFBVSxJQUFJQztBQUViLFNBQVNDLGFBQ2QsR0FBR0MsT0FBNEI7SUFFL0IseUZBQXlGO0lBQ3pGLHNDQUFzQztJQUN0QyxJQUFJQSxRQUFRQyxNQUFNLEtBQUssR0FBRztRQUN4QixNQUFNLE9BQUEsY0FBaUUsQ0FBakUsSUFBSUMsTUFBTSx5REFBVixxQkFB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LGVBQWVPLHdCQUNwQkQsZUFBMkMsRUFDM0MsRUFDRVQsaUJBQWlCLEVBQ2pCRSxxQkFBcUIsRUFDckJDLHlCQUF5QixFQUN6QnBFLHVCQUF1QixFQUN2QkMsT0FBTyxFQUN3QjtJQUVqQyxPQUNFeUUsZ0JBQ0UscURBQXFEO0tBQ3BEWixXQUFXLENBQUM3RSxpQ0FDYixzRUFBc0U7S0FDckU2RSxXQUFXLENBQ1YvRCw0QkFBNEJDLHlCQUF5QkMsVUFFdkQsZ0NBQWdDO0tBQy9CNkQsV0FBVyxDQUFDbkMsbUNBQW1Dd0Msd0JBQ2hELHFCQUFxQjtLQUNwQkwsV0FBVyxDQUFDbkQsOEJBQThCeUQsNEJBQzNDLCtFQUErRTtLQUM5RU4sV0FBVyxDQUFDMUIsNEJBQTRCNkIsb0JBQ3pDLGtEQUFrRDtLQUNqREgsV0FBVyxDQUFDbkI7QUFFbkI7QUFRTyxlQUFlaUMsMEJBQ3BCWixZQUF3QyxFQUN4QyxFQUNFQyxpQkFBaUIsRUFDakJFLHFCQUFxQixFQUNyQkMseUJBQXlCLEVBQ0g7SUFFeEIsT0FDRUosYUFDRSxxREFBcUQ7S0FDcERGLFdBQVcsQ0FBQzdFLGlDQUNiLGdDQUFnQztLQUMvQjZFLFdBQVcsQ0FBQ25DLG1DQUFtQ3dDLHdCQUNoRCxxQkFBcUI7S0FDcEJMLFdBQVcsQ0FBQ25ELDhCQUE4QnlELDRCQUMzQywrRUFBK0U7S0FDOUVOLFdBQVcsQ0FBQzFCLDRCQUE0QjZCLG9CQUN6QyxrREFBa0Q7S0FDakRILFdBQVcsQ0FBQ25CO0FBRW5CO0FBRU8sU0FBU2tDO0lBQ2QsT0FBT3pILGlCQUFpQnNGO0FBQzFCIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDE2MzQsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NyYy9saWIvY29uc3RhbnRzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgU2VydmVyUnVudGltZSB9IGZyb20gJy4uL3R5cGVzJ1xuXG5leHBvcnQgY29uc3QgTkVYVF9RVUVSWV9QQVJBTV9QUkVGSVggPSAnbnh0UCdcbmV4cG9ydCBjb25zdCBORVhUX0lOVEVSQ0VQVElPTl9NQVJLRVJfUFJFRklYID0gJ254dEknXG5cbmV4cG9ydCBjb25zdCBNQVRDSEVEX1BBVEhfSEVBREVSID0gJ3gtbWF0Y2hlZC1wYXRoJ1xuZXhwb3J0IGNvbnN0IFBSRVJFTkRFUl9SRVZBTElEQVRFX0hFQURFUiA9ICd4LXByZXJlbmRlci1yZXZhbGlkYXRlJ1xuZXhwb3J0IGNvbnN0IFBSRVJFTkRFUl9SRVZBTElEQVRFX09OTFlfR0VORVJBVEVEX0hFQURFUiA9XG4gICd4LXByZXJlbmRlci1yZXZhbGlkYXRlLWlmLWdlbmVyYXRlZCdcblxuZXhwb3J0IGNvbnN0IFJTQ19QUkVGRVRDSF9TVUZGSVggPSAnLnByZWZldGNoLnJzYydcbmV4cG9ydCBjb25zdCBSU0NfU0VHTUVOVFNfRElSX1NVRkZJWCA9ICcuc2VnbWVudHMnXG5leHBvcnQgY29uc3QgUlNDX1NFR01FTlRfU1VGRklYID0gJy5zZWdtZW50LnJzYydcbmV4cG9ydCBjb25zdCBSU0NfU1VGRklYID0gJy5yc2MnXG5leHBvcnQgY29uc3QgQUNUSU9OX1NVRkZJWCA9ICcuYWN0aW9uJ1xuZXhwb3J0IGNvbnN0IE5FWFRfREFUQV9TVUZGSVggPSAnLmpzb24nXG5leHBvcnQgY29uc3QgTkVYVF9NRVRBX1NVRkZJWCA9ICcubWV0YSdcbmV4cG9ydCBjb25zdCBORVhUX0JPRFlfU1VGRklYID0gJy5ib2R5J1xuXG5leHBvcnQgY29uc3QgTkVYVF9DQUNIRV9UQUdTX0hFQURFUiA9ICd4LW5leHQtY2FjaGUtdGFncydcbmV4cG9ydCBjb25zdCBORVhUX0NBQ0hFX1JFVkFMSURBVEVEX1RBR1NfSEVBREVSID0gJ3gtbmV4dC1yZXZhbGlkYXRlZC10YWdzJ1xuZXhwb3J0IGNvbnN0IE5FWFRfQ0FDSEVfUkVWQUxJREFURV9UQUdfVE9LRU5fSEVBREVSID1cbiAgJ3gtbmV4dC1yZXZhbGlkYXRlLXRhZy10b2tlbidcblxuZXhwb3J0IGNvbnN0IE5FWFRfUkVTVU1FX0hFQURFUiA9ICduZXh0LXJlc3VtZSdcblxuLy8gaWYgdGhlc2UgY2hhbmdlIG1ha2Ugc3VyZSB3ZSB1cGRhdGUgdGhlIHJlbGF0ZWRcbi8vIGRvY3VtZW50YXRpb24gYXMgd2VsbFxuZXhwb3J0IGNvbnN0IE5FWFRfQ0FDSEVfVEFHX01BWF9JVEVNUyA9IDEyOFxuZXhwb3J0IGNvbnN0IE5FWFRfQ0FDSEVfVEFHX01BWF9MRU5HVEggPSAyNTZcbmV4cG9ydCBjb25zdCBORVhUX0NBQ0hFX1NPRlRfVEFHX01BWF9MRU5HVEggPSAxMDI0XG5leHBvcnQgY29uc3QgTkVYVF9DQUNIRV9JTVBMSUNJVF9UQUdfSUQgPSAnX05fVF8nXG5cbi8vIGluIHNlY29uZHNcbmV4cG9ydCBjb25zdCBDQUNIRV9PTkVfWUVBUiA9IDMxNTM2MDAwXG5cbi8vIGluIHNlY29uZHMsIHJlcHJlc2VudHMgcmV2YWxpZGF0ZT1mYWxzZS4gSS5lLiBuZXZlciByZXZhbGlhdGUuXG4vLyBXZSB1c2UgdGhpcyB2YWx1ZSBzaW5jZSBpdCBjYW4gYmUgcmVwcmVzZW50ZWQgYXMgYSBWOCBTTUkgZm9yIG9wdGltYWwgcGVyZm9ybWFuY2UuXG4vLyBJdCBjYW4gYWxzbyBiZSBzZXJpYWxpemVkIGFzIEpTT04gaWYgaXQgZXZlciBsZWFrcyBhY2NpZGVudGFsbHkgYXMgYW4gYWN0dWFsIHZhbHVlLlxuZXhwb3J0IGNvbnN0IElORklOSVRFX0NBQ0hFID0gMHhmZmZmZmZmZVxuXG4vLyBQYXR0ZXJucyB0byBkZXRlY3QgbWlkZGxld2FyZSBmaWxlc1xuZXhwb3J0IGNvbnN0IE1JRERMRVdBUkVfRklMRU5BTUUgPSAnbWlkZGxld2FyZSdcbmV4cG9ydCBjb25zdCBNSURETEVXQVJFX0xPQ0FUSU9OX1JFR0VYUCA9IGAoPzpzcmMvKT8ke01JRERMRVdBUkVfRklMRU5BTUV9YFxuXG4vLyBQYXR0ZXJuIHRvIGRldGVjdCBpbnN0cnVtZW50YXRpb24gaG9va3MgZmlsZVxuZXhwb3J0IGNvbnN0IElOU1RSVU1FTlRBVElPTl9IT09LX0ZJTEVOQU1FID0gJ2luc3RydW1lbnRhdGlvbidcblxuLy8gQmVjYXVzZSBvbiBXaW5kb3dzIGFic29sdXRlIHBhdGhzIGluIHRoZSBnZW5lcmF0ZWQgY29kZSBjYW4gYnJlYWsgYmVjYXVzZSBvZiBudW1iZXJzLCBlZyAxIGluIHRoZSBwYXRoLFxuLy8gd2UgaGF2ZSB0byB1c2UgYSBwcml2YXRlIGFsaWFzXG5leHBvcnQgY29uc3QgUEFHRVNfRElSX0FMSUFTID0gJ3ByaXZhdGUtbmV4dC1wYWdlcydcbmV4cG9ydCBjb25zdCBET1RfTkVYVF9BTElBUyA9ICdwcml2YXRlLWRvdC1uZXh0J1xuZXhwb3J0IGNvbnN0IFJPT1RfRElSX0FMSUFTID0gJ3ByaXZhdGUtbmV4dC1yb290LWRpcidcbmV4cG9ydCBjb25zdCBBUFBfRElSX0FMSUFTID0gJ3ByaXZhdGUtbmV4dC1hcHAtZGlyJ1xuZXhwb3J0IGNvbnN0IFJTQ19NT0RfUkVGX1BST1hZX0FMSUFTID0gJ3ByaXZhdGUtbmV4dC1yc2MtbW9kLXJlZi1wcm94eSdcbmV4cG9ydCBjb25zdCBSU0NfQUNUSU9OX1ZBTElEQVRFX0FMSUFTID0gJ3ByaXZhdGUtbmV4dC1yc2MtYWN0aW9uLXZhbGlkYXRlJ1xuZXhwb3J0IGNvbnN0IFJTQ19BQ1RJT05fUFJPWFlfQUxJQVMgPSAncHJpdmF0ZS1uZXh0LXJzYy1zZXJ2ZXItcmVmZXJlbmNlJ1xuZXhwb3J0IGNvbnN0IFJTQ19DQUNIRV9XUkFQUEVSX0FMSUFTID0gJ3ByaXZhdGUtbmV4dC1yc2MtY2FjaGUtd3JhcHBlcidcbmV4cG9ydCBjb25zdCBSU0NfRFlOQU1JQ19JTVBPUlRfV1JBUFBFUl9BTElBUyA9XG4gICdwcml2YXRlLW5leHQtcnNjLXRyYWNrLWR5bmFtaWMtaW1wb3J0J1xuZXhwb3J0IGNvbnN0IFJTQ19BQ1RJT05fRU5DUllQVElPTl9BTElBUyA9ICdwcml2YXRlLW5leHQtcnNjLWFjdGlvbi1lbmNyeXB0aW9uJ1xuZXhwb3J0IGNvbnN0IFJTQ19BQ1RJT05fQ0xJRU5UX1dSQVBQRVJfQUxJQVMgPVxuICAncHJpdmF0ZS1uZXh0LXJzYy1hY3Rpb24tY2xpZW50LXdyYXBwZXInXG5cbmV4cG9ydCBjb25zdCBQVUJMSUNfRElSX01JRERMRVdBUkVfQ09ORkxJQ1QgPSBgWW91IGNhbiBub3QgaGF2ZSBhICdfbmV4dCcgZm9sZGVyIGluc2lkZSBvZiB5b3VyIHB1YmxpYyBmb2xkZXIuIFRoaXMgY29uZmxpY3RzIHdpdGggdGhlIGludGVybmFsICcvX25leHQnIHJvdXRlLiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9wdWJsaWMtbmV4dC1mb2xkZXItY29uZmxpY3RgXG5cbmV4cG9ydCBjb25zdCBTU0dfR0VUX0lOSVRJQUxfUFJPUFNfQ09ORkxJQ1QgPSBgWW91IGNhbiBub3QgdXNlIGdldEluaXRpYWxQcm9wcyB3aXRoIGdldFN0YXRpY1Byb3BzLiBUbyB1c2UgU1NHLCBwbGVhc2UgcmVtb3ZlIHlvdXIgZ2V0SW5pdGlhbFByb3BzYFxuXG5leHBvcnQgY29uc3QgU0VSVkVSX1BST1BTX0dFVF9JTklUX1BST1BTX0NPTkZMSUNUID0gYFlvdSBjYW4gbm90IHVzZSBnZXRJbml0aWFsUHJvcHMgd2l0aCBnZXRTZXJ2ZXJTaWRlUHJvcHMuIFBsZWFzZSByZW1vdmUgZ2V0SW5pdGlhbFByb3BzLmBcblxuZXhwb3J0IGNvbnN0IFNFUlZFUl9QUk9QU19TU0dfQ09ORkxJQ1QgPSBgWW91IGNhbiBub3QgdXNlIGdldFN0YXRpY1Byb3BzIG9yIGdldFN0YXRpY1BhdGhzIHdpdGggZ2V0U2VydmVyU2lkZVByb3BzLiBUbyB1c2UgU1NHLCBwbGVhc2UgcmVtb3ZlIGdldFNlcnZlclNpZGVQcm9wc2BcblxuZXhwb3J0IGNvbnN0IFNUQVRJQ19TVEFUVVNfUEFHRV9HRVRfSU5JVElBTF9QUk9QU19FUlJPUiA9IGBjYW4gbm90IGhhdmUgZ2V0SW5pdGlhbFByb3BzL2dldFNlcnZlclNpZGVQcm9wcywgaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvNDA0LWdldC1pbml0aWFsLXByb3BzYFxuXG5leHBvcnQgY29uc3QgU0VSVkVSX1BST1BTX0VYUE9SVF9FUlJPUiA9IGBwYWdlcyB3aXRoIFxcYGdldFNlcnZlclNpZGVQcm9wc1xcYCBjYW4gbm90IGJlIGV4cG9ydGVkLiBTZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2dzc3AtZXhwb3J0YFxuXG5leHBvcnQgY29uc3QgR1NQX05PX1JFVFVSTkVEX1ZBTFVFID1cbiAgJ1lvdXIgYGdldFN0YXRpY1Byb3BzYCBmdW5jdGlvbiBkaWQgbm90IHJldHVybiBhbiBvYmplY3QuIERpZCB5b3UgZm9yZ2V0IHRvIGFkZCBhIGByZXR1cm5gPydcbmV4cG9ydCBjb25zdCBHU1NQX05PX1JFVFVSTkVEX1ZBTFVFID1cbiAgJ1lvdXIgYGdldFNlcnZlclNpZGVQcm9wc2AgZnVuY3Rpb24gZGlkIG5vdCByZXR1cm4gYW4gb2JqZWN0LiBEaWQgeW91IGZvcmdldCB0byBhZGQgYSBgcmV0dXJuYD8nXG5cbmV4cG9ydCBjb25zdCBVTlNUQUJMRV9SRVZBTElEQVRFX1JFTkFNRV9FUlJPUiA9XG4gICdUaGUgYHVuc3RhYmxlX3JldmFsaWRhdGVgIHByb3BlcnR5IGlzIGF2YWlsYWJsZSBmb3IgZ2VuZXJhbCB1c2UuXFxuJyArXG4gICdQbGVhc2UgdXNlIGByZXZhbGlkYXRlYCBpbnN0ZWFkLidcblxuZXhwb3J0IGNvbnN0IEdTU1BfQ09NUE9ORU5UX01FTUJFUl9FUlJPUiA9IGBjYW4gbm90IGJlIGF0dGFjaGVkIHRvIGEgcGFnZSdzIGNvbXBvbmVudCBhbmQgbXVzdCBiZSBleHBvcnRlZCBmcm9tIHRoZSBwYWdlLiBTZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2dzc3AtY29tcG9uZW50LW1lbWJlcmBcblxuZXhwb3J0IGNvbnN0IE5PTl9TVEFOREFSRF9OT0RFX0VOViA9IGBZb3UgYXJlIHVzaW5nIGEgbm9uLXN0YW5kYXJkIFwiTk9ERV9FTlZcIiB2YWx1ZSBpbiB5b3VyIGVudmlyb25tZW50LiBUaGlzIGNyZWF0ZXMgaW5jb25zaXN0ZW5jaWVzIGluIHRoZSBwcm9qZWN0IGFuZCBpcyBzdHJvbmdseSBhZHZpc2VkIGFnYWluc3QuIFJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbm9uLXN0YW5kYXJkLW5vZGUtZW52YFxuXG5leHBvcnQgY29uc3QgU1NHX0ZBTExCQUNLX0VYUE9SVF9FUlJPUiA9IGBQYWdlcyB3aXRoIFxcYGZhbGxiYWNrXFxgIGVuYWJsZWQgaW4gXFxgZ2V0U3RhdGljUGF0aHNcXGAgY2FuIG5vdCBiZSBleHBvcnRlZC4gU2VlIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9zc2ctZmFsbGJhY2stdHJ1ZS1leHBvcnRgXG5cbmV4cG9ydCBjb25zdCBFU0xJTlRfREVGQVVMVF9ESVJTID0gWydhcHAnLCAncGFnZXMnLCAnY29tcG9uZW50cycsICdsaWInLCAnc3JjJ11cblxuZXhwb3J0IGNvbnN0IFNFUlZFUl9SVU5USU1FOiBSZWNvcmQ8c3RyaW5nLCBTZXJ2ZXJSdW50aW1lPiA9IHtcbiAgZWRnZTogJ2VkZ2UnLFxuICBleHBlcmltZW50YWxFZGdlOiAnZXhwZXJpbWVudGFsLWVkZ2UnLFxuICBub2RlanM6ICdub2RlanMnLFxufVxuXG4vKipcbiAqIFRoZSBuYW1lcyBvZiB0aGUgd2VicGFjayBsYXllcnMuIFRoZXNlIGxheWVycyBhcmUgdGhlIHByaW1pdGl2ZXMgZm9yIHRoZVxuICogd2VicGFjayBjaHVua3MuXG4gKi9cbmNvbnN0IFdFQlBBQ0tfTEFZRVJTX05BTUVTID0ge1xuICAvKipcbiAgICogVGhlIGxheWVyIGZvciB0aGUgc2hhcmVkIGNvZGUgYmV0d2VlbiB0aGUgY2xpZW50IGFuZCBzZXJ2ZXIgYnVuZGxlcy5cbiAgICovXG4gIHNoYXJlZDogJ3NoYXJlZCcsXG4gIC8qKlxuICAgKiBUaGUgbGF5ZXIgZm9yIHNlcnZlci1vbmx5IHJ1bnRpbWUgYW5kIHBpY2tpbmcgdXAgYHJlYWN0LXNlcnZlcmAgZXhwb3J0IGNvbmRpdGlvbnMuXG4gICAqIEluY2x1ZGluZyBhcHAgcm91dGVyIFJTQyBwYWdlcyBhbmQgYXBwIHJvdXRlciBjdXN0b20gcm91dGVzIGFuZCBtZXRhZGF0YSByb3V0ZXMuXG4gICAqL1xuICByZWFjdFNlcnZlckNvbXBvbmVudHM6ICdyc2MnLFxuICAvKipcbiAgICogU2VydmVyIFNpZGUgUmVuZGVyaW5nIGxheWVyIGZvciBhcHAgKHNzcikuXG4gICAqL1xuICBzZXJ2ZXJTaWRlUmVuZGVyaW5nOiAnc3NyJyxcbiAgLyoqXG4gICAqIFRoZSBicm93c2VyIGNsaWVudCBidW5kbGUgbGF5ZXIgZm9yIGFjdGlvbnMuXG4gICAqL1xuICBhY3Rpb25Ccm93c2VyOiAnYWN0aW9uLWJyb3dzZXInLFxuICAvKipcbiAgICogVGhlIE5vZGUuanMgYnVuZGxlIGxheWVyIGZvciB0aGUgQVBJIHJvdXRlcy5cbiAgICovXG4gIGFwaU5vZGU6ICdhcGktbm9kZScsXG4gIC8qKlxuICAgKiBUaGUgRWRnZSBMaXRlIGJ1bmRsZSBsYXllciBmb3IgdGhlIEFQSSByb3V0ZXMuXG4gICAqL1xuICBhcGlFZGdlOiAnYXBpLWVkZ2UnLFxuICAvKipcbiAgICogVGhlIGxheWVyIGZvciB0aGUgbWlkZGxld2FyZSBjb2RlLlxuICAgKi9cbiAgbWlkZGxld2FyZTogJ21pZGRsZXdhcmUnLFxuICAvKipcbiAgICogVGhlIGxheWVyIGZvciB0aGUgaW5zdHJ1bWVudGF0aW9uIGhvb2tzLlxuICAgKi9cbiAgaW5zdHJ1bWVudDogJ2luc3RydW1lbnQnLFxuICAvKipcbiAgICogVGhlIGxheWVyIGZvciBhc3NldHMgb24gdGhlIGVkZ2UuXG4gICAqL1xuICBlZGdlQXNzZXQ6ICdlZGdlLWFzc2V0JyxcbiAgLyoqXG4gICAqIFRoZSBicm93c2VyIGNsaWVudCBidW5kbGUgbGF5ZXIgZm9yIEFwcCBkaXJlY3RvcnkuXG4gICAqL1xuICBhcHBQYWdlc0Jyb3dzZXI6ICdhcHAtcGFnZXMtYnJvd3NlcicsXG4gIC8qKlxuICAgKiBUaGUgYnJvd3NlciBjbGllbnQgYnVuZGxlIGxheWVyIGZvciBQYWdlcyBkaXJlY3RvcnkuXG4gICAqL1xuICBwYWdlc0RpckJyb3dzZXI6ICdwYWdlcy1kaXItYnJvd3NlcicsXG4gIC8qKlxuICAgKiBUaGUgRWRnZSBMaXRlIGJ1bmRsZSBsYXllciBmb3IgUGFnZXMgZGlyZWN0b3J5LlxuICAgKi9cbiAgcGFnZXNEaXJFZGdlOiAncGFnZXMtZGlyLWVkZ2UnLFxuICAvKipcbiAgICogVGhlIE5vZGUuanMgYnVuZGxlIGxheWVyIGZvciBQYWdlcyBkaXJlY3RvcnkuXG4gICAqL1xuICBwYWdlc0Rpck5vZGU6ICdwYWdlcy1kaXItbm9kZScsXG59IGFzIGNvbnN0XG5cbmV4cG9ydCB0eXBlIFdlYnBhY2tMYXllck5hbWUgPVxuICAodHlwZW9mIFdFQlBBQ0tfTEFZRVJTX05BTUVTKVtrZXlvZiB0eXBlb2YgV0VCUEFDS19MQVlFUlNfTkFNRVNdXG5cbmNvbnN0IFdFQlBBQ0tfTEFZRVJTID0ge1xuICAuLi5XRUJQQUNLX0xBWUVSU19OQU1FUyxcbiAgR1JPVVA6IHtcbiAgICBidWlsdGluUmVhY3Q6IFtcbiAgICAgIFdFQlBBQ0tfTEFZRVJTX05BTUVTLnJlYWN0U2VydmVyQ29tcG9uZW50cyxcbiAgICAgIFdFQlBBQ0tfTEFZRVJTX05BTUVTLmFjdGlvbkJyb3dzZXIsXG4gICAgXSxcbiAgICBzZXJ2ZXJPbmx5OiBbXG4gICAgICBXRUJQQUNLX0xBWUVSU19OQU1FUy5yZWFjdFNlcnZlckNvbXBvbmVudHMsXG4gICAgICBXRUJQQUNLX0xBWUVSU19OQU1FUy5hY3Rpb25Ccm93c2VyLFxuICAgICAgV0VCUEFDS19MQVlFUlNfTkFNRVMuaW5zdHJ1bWVudCxcbiAgICAgIFdFQlBBQ0tfTEFZRVJTX05BTUVTLm1pZGRsZXdhcmUsXG4gICAgXSxcbiAgICBuZXV0cmFsVGFyZ2V0OiBbXG4gICAgICAvLyBwYWdlcyBhcGlcbiAgICAgIFdFQlBBQ0tfTEFZRVJTX05BTUVTLmFwaU5vZGUsXG4gICAgICBXRUJQQUNLX0xBWUVSU19OQU1FUy5hcGlFZGdlLFxuICAgIF0sXG4gICAgY2xpZW50T25seTogW1xuICAgICAgV0VCUEFDS19MQVlFUlNfTkFNRVMuc2VydmVyU2lkZVJlbmRlcmluZyxcbiAgICAgIFdFQlBBQ0tfTEFZRVJTX05BTUVTLmFwcFBhZ2VzQnJvd3NlcixcbiAgICBdLFxuICAgIGJ1bmRsZWQ6IFtcbiAgICAgIFdFQlBBQ0tfTEFZRVJTX05BTUVTLnJlYWN0U2VydmVyQ29tcG9uZW50cyxcbiAgICAgIFdFQlBBQ0tfTEFZRVJTX05BTUVTLmFjdGlvbkJyb3dzZXIsXG4gICAgICBXRUJQQUNLX0xBWUVSU19OQU1FUy5zZXJ2ZXJTaWRlUmVuZGVyaW5nLFxuICAgICAgV0VCUEFDS19MQVlFUlNfTkFNRVMuYXBwUGFnZXNCcm93c2VyLFxuICAgICAgV0VCUEFDS19MQVlFUlNfTkFNRVMuc2hhcmVkLFxuICAgICAgV0VCUEFDS19MQVlFUlNfTkFNRVMuaW5zdHJ1bWVudCxcbiAgICAgIFdFQlBBQ0tfTEFZRVJTX05BTUVTLm1pZGRsZXdhcmUsXG4gICAgXSxcbiAgICBhcHBQYWdlczogW1xuICAgICAgLy8gYXBwIHJvdXRlciBwYWdlcyBhbmQgbGF5b3V0c1xuICAgICAgV0VCUEFDS19MQVlFUlNfTkFNRVMucmVhY3RTZXJ2ZXJDb21wb25lbnRzLFxuICAgICAgV0VCUEFDS19MQVlFUlNfTkFNRVMuc2VydmVyU2lkZVJlbmRlcmluZyxcbiAgICAgIFdFQlBBQ0tfTEFZRVJTX05BTUVTLmFwcFBhZ2VzQnJvd3NlcixcbiAgICAgIFdFQlBBQ0tfTEFZRVJTX05BTUVTLmFjdGlvbkJyb3dzZXIsXG4gICAgXSxcbiAgfSxcbn1cblxuY29uc3QgV0VCUEFDS19SRVNPVVJDRV9RVUVSSUVTID0ge1xuICBlZGdlU1NSRW50cnk6ICdfX25leHRfZWRnZV9zc3JfZW50cnlfXycsXG4gIG1ldGFkYXRhOiAnX19uZXh0X21ldGFkYXRhX18nLFxuICBtZXRhZGF0YVJvdXRlOiAnX19uZXh0X21ldGFkYXRhX3JvdXRlX18nLFxuICBtZXRhZGF0YUltYWdlTWV0YTogJ19fbmV4dF9tZXRhZGF0YV9pbWFnZV9tZXRhX18nLFxufVxuXG5leHBvcnQgeyBXRUJQQUNLX0xBWUVSUywgV0VCUEFDS19SRVNPVVJDRV9RVUVSSUVTIH1cbiJdLCJuYW1lcyI6WyJORVhUX1FVRVJZX1BBUkFNX1BSRUZJWCIsIk5FWFRfSU5URVJDRVBUSU9OX01BUktFUl9QUkVGSVgiLCJNQVRDSEVEX1BBVEhfSEVBREVSIiwiUFJFUkVOREVSX1JFVkFMSURBVEVfSEVBREVSIiwiUFJFUkVOREVSX1JFVkFMSURBVEVfT05MWV9HRU5FUkFURURfSEVBREVSIiwiUlNDX1BSRUZFVENIX1NVRkZJWCIsIlJTQ19TRUdNRU5UU19ESVJfU1VGRklYIiwiUlNDX1NFR01FTlRfU1VGRklYIiwiUlNDX1NVRkZJWCIsIkFDVElPTl9TVUZGSVgiLCJORVhUX0RBVEFfU1VGRklYIiwiTkVYVF9NRVRBX1NVRkZJWCIsIk5FWFRfQk9EWV9TVUZGSVgiLCJORVhUX0NBQ0hFX1RBR1NfSEVBREVSIiwiTkVYVF9DQUNIRV9SRVZBTElEQVRFRF9UQUdTX0hFQURFUiIsIk5FWFRfQ0FDSEVfUkVWQUxJREFURV9UQUdfVE9LRU5fSEVBREVSIiwiTkVYVF9SRVNVTUVfSEVBREVSIiwiTkVYVF9DQUNIRV9UQUdfTUFYX0lURU1TIiwiTkVYVF9DQUNIRV9UQUdfTUFYX0xFTkdUSCIsIk5FWFRfQ0FDSEVfU09GVF9UQUdfTUFYX0xFTkdUSCIsIk5FWFRfQ0FDSEVfSU1QTElDSVRfVEFHX0lEIiwiQ0FDSEVfT05FX1lFQVIiLCJJTkZJTklURV9DQUNIRSIsIk1JRERMRVdBUkVfRklMRU5BTUUiLCJNSURETEVXQVJFX0xPQ0FUSU9OX1JFR0VYUCIsIklOU1RSVU1FTlRBVElPTl9IT09LX0ZJTEVOQU1FIiwiUEFHRVNfRElSX0FMSUFTIiwiRE9UX05FWFRfQUxJQVMiLCJST09UX0RJUl9BTElBUyIsIkFQUF9ESVJfQUxJQVMiLCJSU0NfTU9EX1JFRl9QUk9YWV9BTElBUyIsIlJTQ19BQ1RJT05fVkFMSURBVEVfQUxJQVMiLCJSU0NfQUNUSU9OX1BST1hZX0FMSUFTIiwiUlNDX0NBQ0hFX1dSQVBQRVJfQUxJQVMiLCJSU0NfRFlOQU1JQ19JTVBPUlRfV1JBUFBFUl9BTElBUyIsIlJTQ19BQ1RJT05fRU5DUllQVElPTl9BTElBUyIsIlJTQ19BQ1RJT05fQ0xJRU5UX1dSQVBQRVJfQUxJQVMiLCJQVUJMSUNfRElSX01JRERMRVdBUkVfQ09ORkxJQ1QiLCJTU0dfR0VUX0lOSVRJQUxfUFJPUFNfQ09ORkxJQ1QiLCJTRVJWRVJfUFJPUFNfR0VUX0lOSVRfUFJPUFNfQ09ORkxJQ1QiLCJTRVJWRVJfUFJPUFNfU1NHX0NPTkZMSUNUIiwiU1RBVElDX1NUQVRVU19QQUdFX0dFVF9JTklUSUFMX1BST1BTX0VSUk9SIiwiU0VSVkVSX1BST1BTX0VYUE9SVF9FUlJPUiIsIkdTUF9OT19SRVRVUk5FRF9WQUxVRSIsIkdTU1BfTk9fUkVUVVJORURfVkFMVUUiLCJVTlNUQUJMRV9SRVZBTElEQVRFX1JFTkFNRV9FUlJPUiIsIkdTU1BfQ09NUE9ORU5UX01FTUJFUl9FUlJPUiIsIk5PTl9TVEFOREFSRF9OT0RFX0VOViIsIlNTR19GQUxMQkFDS19FWFBPUlRfRVJST1IiLCJFU0xJTlRfREVGQVVMVF9ESVJTIiwiU0VSVkVSX1JVTlRJTUUiLCJlZGdlIiwiZXhwZXJpbWVudGFsRWRnZSIsIm5vZGVqcyIsIldFQlBBQ0tfTEFZRVJTX05BTUVTIiwic2hhcmVkIiwicmVhY3RTZXJ2ZXJDb21wb25lbnRzIiwic2VydmVyU2lkZVJlbmRlcmluZyIsImFjdGlvbkJyb3dzZXIiLCJhcGlOb2RlIiwiYXBpRWRnZSIsIm1pZGRsZXdhcmUiLCJpbnN0cnVtZW50IiwiZWRnZUFzc2V0IiwiYXBwUGFnZXNCcm93c2VyIiwicGFnZXNEaXJCcm93c2VyIiwicGFnZXNEaXJFZGdlIiwicGFnZXNEaXJOb2RlIiwiV0VCUEFDS19MQVlFUlMiLCJHUk9VUCIsImJ1aWx0aW5SZWFjdCIsInNlcnZlck9ubHkiLCJuZXV0cmFsVGFyZ2V0IiwiY2xpZW50T25seSIsImJ1bmRsZWQiLCJhcHBQYWdlcyIsIldFQlBBQ0tfUkVTT1VSQ0VfUVVFUklFUyIsImVkZ2VTU1JFbnRyeSIsIm1ldGFkYXRhIiwibWV0YWRhdGFSb3V0ZSIsIm1ldGFkYXRhSW1hZ2VNZXRhIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRU8sTUFBTUEsMEJBQTBCLE9BQU07QUFDdEMsTUFBTUMsa0NBQWtDLE9BQU07QUFFOUMsTUFBTUMsc0JBQXNCLGlCQUFnQjtBQUM1QyxNQUFNQyw4QkFBOEIseUJBQXdCO0FBQzVELE1BQU1DLDZDQUNYLHNDQUFxQztBQUVoQyxNQUFNQyxzQkFBc0IsZ0JBQWU7QUFDM0MsTUFBTUMsMEJBQTBCLFlBQVc7QUFDM0MsTUFBTUMscUJBQXFCLGVBQWM7QUFDekMsTUFBTUMsYUFBYSxPQUFNO0FBQ3pCLE1BQU1DLGdCQUFnQixVQUFTO0FBQy9CLE1BQU1DLG1CQUFtQixRQUFPO0FBQ2hDLE1BQU1DLG1CQUFtQixRQUFPO0FBQ2hDLE1BQU1DLG1CQUFtQixRQUFPO0FBRWhDLE1BQU1DLHlCQUF5QixvQkFBbUI7QUFDbEQsTUFBTUMscUNBQXFDLDBCQUF5QjtBQUNwRSxNQUFNQyx5Q0FDWCw4QkFBNkI7QUFFeEIsTUFBTUMscUJBQXFCLGNBQWE7QUFJeEMsTUFBTUMsMkJBQTJCLElBQUc7QUFDcEMsTUFBTUMsNEJBQTRCLElBQUc7QUFDckMsTUFBTUMsaUNBQWlDLEtBQUk7QUFDM0MsTUFBTUMsNkJBQTZCLFFBQU87QUFHMUMsTUFBTUMsaUJBQWlCLFNBQVE7QUFLL0IsTUFBTUMsaUJBQWlCLFdBQVU7QUFHakMsTUFBTUMsc0JBQXNCLGFBQVk7QUFD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WUFDMUNGLHFCQUFxQkcsbUJBQW1CO1lBQ3hDSCxxQkFBcUJVLGVBQWU7WUFDcENWLHFCQUFxQkksYUFBYTtTQUNuQztJQUNIO0FBQ0Y7QUFFQSxNQUFNa0IsMkJBQTJCO0lBQy9CQyxjQUFjO0lBQ2RDLFVBQVU7SUFDVkMsZUFBZTtJQUNmQyxtQkFBbUI7QUFDckIiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTg0NywgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL3NlcnZlci93ZWIvdXRpbHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBPdXRnb2luZ0h0dHBIZWFkZXJzIH0gZnJvbSAnaHR0cCdcbmltcG9ydCB7XG4gIE5FWFRfSU5URVJDRVBUSU9OX01BUktFUl9QUkVGSVgsXG4gIE5FWFRfUVVFUllfUEFSQU1fUFJFRklYLFxufSBmcm9tICcuLi8uLi9saWIvY29uc3RhbnRzJ1xuXG4vKipcbiAqIENvbnZlcnRzIGEgTm9kZS5qcyBJbmNvbWluZ0h0dHBIZWFkZXJzIG9iamVjdCB0byBhIEhlYWRlcnMgb2JqZWN0LiBBbnlcbiAqIGhlYWRlcnMgd2l0aCBtdWx0aXBsZSB2YWx1ZXMgd2lsbCBiZSBqb2luZWQgd2l0aCBhIGNvbW1hIGFuZCBzcGFjZS4gQW55XG4gKiBoZWFkZXJzIHRoYXQgaGF2ZSBhbiB1bmRlZmluZWQgdmFsdWUgd2lsbCBiZSBpZ25vcmVkIGFuZCBvdGhlcnMgd2lsbCBiZVxuICogY29lcmNlZCB0byBzdHJpbmdzLlxuICpcbiAqIEBwYXJhbSBub2RlSGVhZGVycyB0aGUgaGVhZGVycyBvYmplY3QgdG8gY29udmVydFxuICogQHJldHVybnMgdGhlIGNvbnZlcnRlZCBoZWFkZXJzIG9iamVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbU5vZGVPdXRnb2luZ0h0dHBIZWFkZXJzKFxuICBub2RlSGVhZGVyczogT3V0Z29pbmdIdHRwSGVhZGVyc1xuKTogSGVhZGVycyB7XG4gIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycygpXG4gIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhub2RlSGVhZGVycykpIHtcbiAgICBjb25zdCB2YWx1ZXMgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXVxuICAgIGZvciAobGV0IHYgb2YgdmFsdWVzKSB7XG4gICAgICBpZiAodHlwZW9mIHYgPT09ICd1bmRlZmluZWQnKSBjb250aW51ZVxuICAgICAgaWYgKHR5cGVvZiB2ID09PSAnbnVtYmVyJykge1xuICAgICAgICB2ID0gdi50b1N0cmluZygpXG4gICAgICB9XG5cbiAgICAgIGhlYWRlcnMuYXBwZW5kKGtleSwgdilcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGhlYWRlcnNcbn1cblxuLypcbiAgU2V0LUNvb2tpZSBoZWFkZXIgZmllbGQtdmFsdWVzIGFyZSBzb21ldGltZXMgY29tbWEgam9pbmVkIGluIG9uZSBzdHJpbmcuIFRoaXMgc3BsaXRzIHRoZW0gd2l0aG91dCBjaG9raW5nIG9uIGNvbW1hc1xuICB0aGF0IGFyZSB3aXRoaW4gYSBzaW5nbGUgc2V0LWNvb2tpZSBmaWVsZC12YWx1ZSwgc3VjaCBhcyBpbiB0aGUgRXhwaXJlcyBwb3J0aW9uLlxuICBUaGlzIGlzIHVuY29tbW9uLCBidXQgZXhwbGljaXRseSBhbGxvd2VkIC0gc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMyNjE2I3NlY3Rpb24tNC4yXG4gIE5vZGUuanMgZG9lcyB0aGlzIGZvciBldmVyeSBoZWFkZXIgKmV4Y2VwdCogc2V0LWNvb2tpZSAtIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi9kNWUzNjNiNzdlYmFmMWNhZjY3Y2Q3NTI4MjI0YjY1MWM4NjgxNWMxL2xpYi9faHR0cF9pbmNvbWluZy5qcyNMMTI4XG4gIFJlYWN0IE5hdGl2ZSdzIGZldGNoIGRvZXMgdGhpcyBmb3IgKmV2ZXJ5KiBoZWFkZXIsIGluY2x1ZGluZyBzZXQtY29va2llLlxuICBcbiAgQmFzZWQgb246IGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvajJvYmpjL2NvbW1pdC8xNjgyMGZkYmM4Zjc2Y2EwYzMzNDcyODEwY2UwY2IwM2QyMGVmZTI1XG4gIENyZWRpdHMgdG86IGh0dHBzOi8vZ2l0aHViLmNvbS90b21iYWxsIGZvciBvcmlnaW5hbCBhbmQgaHR0cHM6Ly9naXRodWIuY29tL2NocnVzYXJ0IGZvciBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uXG4qL1xuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0Q29va2llc1N0cmluZyhjb29raWVzU3RyaW5nOiBzdHJpbmcpIHtcbiAgdmFyIGNvb2tpZXNTdHJpbmdzID0gW11cbiAgdmFyIHBvcyA9IDBcbiAgdmFyIHN0YXJ0XG4gIHZhciBjaFxuICB2YXIgbGFzdENvbW1hXG4gIHZhciBuZXh0U3RhcnRcbiAgdmFyIGNvb2tpZXNTZXBhcmF0b3JGb3VuZFxuXG4gIGZ1bmN0aW9uIHNraXBXaGl0ZXNwYWNlKCkge1xuICAgIHdoaWxlIChwb3MgPCBjb29raWVzU3RyaW5nLmxlbmd0aCAmJiAvXFxzLy50ZXN0KGNvb2tpZXNTdHJpbmcuY2hhckF0KHBvcykpKSB7XG4gICAgICBwb3MgKz0gMVxuICAgIH1cbiAgICByZXR1cm4gcG9zIDwgY29va2llc1N0cmluZy5sZW5ndGhcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vdFNwZWNpYWxDaGFyKCkge1xuICAgIGNoID0gY29va2llc1N0cmluZy5jaGFyQXQocG9zKVxuXG4gICAgcmV0dXJuIGNoICE9PSAnPScgJiYgY2ggIT09ICc7JyAmJiBjaCAhPT0gJywnXG4gIH1cblxuICB3aGlsZSAocG9zIDwgY29va2llc1N0cmluZy5sZW5ndGgpIHtcbiAgICBzdGFydCA9IHBvc1xuICAgIGNvb2tpZXNTZXBhcmF0b3JGb3VuZCA9IGZhbHNlXG5cbiAgICB3aGlsZSAoc2tpcFdoaXRlc3BhY2UoKSkge1xuICAgICAgY2ggPSBjb29raWVzU3RyaW5nLmNoYXJBdChwb3MpXG4gICAgICBpZiAoY2ggPT09ICcsJykge1xuICAgICAgICAvLyAnLCcgaXMgYSBjb29raWUgc2VwYXJhdG9yIGlmIHdlIGhhdmUgbGF0ZXIgZmlyc3QgJz0nLCBub3QgJzsnIG9yICcsJ1xuICAgICAgICBsYXN0Q29tbWEgPSBwb3NcbiAgICAgICAgcG9zICs9IDFcblxuICAgICAgICBza2lwV2hpdGVzcGFjZSgpXG4gICAgICAgIG5leHRTdGFydCA9IHBvc1xuXG4gICAgICAgIHdoaWxlIChwb3MgPCBjb29raWVzU3RyaW5nLmxlbmd0aCAmJiBub3RTcGVjaWFsQ2hhcigpKSB7XG4gICAgICAgICAgcG9zICs9IDFcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGN1cnJlbnRseSBzcGVjaWFsIGNoYXJhY3RlclxuICAgICAgICBpZiAocG9zIDwgY29va2llc1N0cmluZy5sZW5ndGggJiYgY29va2llc1N0cmluZy5jaGFyQXQocG9zKSA9PT0gJz0nKSB7XG4gICAgICAgICAgLy8gd2UgZm91bmQgY29va2llcyBzZXBhcmF0b3JcbiAgICAgICAgICBjb29raWVzU2VwYXJhdG9yRm91bmQgPSB0cnVlXG4gICAgICAgICAgLy8gcG9zIGlzIGluc2lkZSB0aGUgbmV4dCBjb29raWUsIHNvIGJhY2sgdXAgYW5kIHJldHVybiBpdC5cbiAgICAgICAgICBwb3MgPSBuZXh0U3RhcnRcbiAgICAgICAgICBjb29raWVzU3RyaW5ncy5wdXNoKGNvb2tpZXNTdHJpbmcuc3Vic3RyaW5nKHN0YXJ0LCBsYXN0Q29tbWEpKVxuICAgICAgICAgIHN0YXJ0ID0gcG9zXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaW4gcGFyYW0gJywnIG9yIHBhcmFtIHNlcGFyYXRvciAnOycsXG4gICAgICAgICAgLy8gd2UgY29udGludWUgZnJvbSB0aGF0IGNvbW1hXG4gICAgICAgICAgcG9zID0gbGFzdENvbW1hICsgMVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb3MgKz0gMVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghY29va2llc1NlcGFyYXRvckZvdW5kIHx8IHBvcyA+PSBjb29raWVzU3RyaW5nLmxlbmd0aCkge1xuICAgICAgY29va2llc1N0cmluZ3MucHVzaChjb29raWVzU3RyaW5nLnN1YnN0cmluZyhzdGFydCwgY29va2llc1N0cmluZy5sZW5ndGgpKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb29raWVzU3RyaW5nc1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgSGVhZGVycyBvYmplY3QgdG8gYSBOb2RlLmpzIE91dGdvaW5nSHR0cEhlYWRlcnMgb2JqZWN0LiBUaGlzIGlzXG4gKiByZXF1aXJlZCB0byBzdXBwb3J0IHRoZSBzZXQtY29va2llIGhlYWRlciwgd2hpY2ggbWF5IGhhdmUgbXVsdGlwbGUgdmFsdWVzLlxuICpcbiAqIEBwYXJhbSBoZWFkZXJzIHRoZSBoZWFkZXJzIG9iamVjdCB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyB0aGUgY29udmVydGVkIGhlYWRlcnMgb2JqZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b05vZGVPdXRnb2luZ0h0dHBIZWFkZXJzKFxuICBoZWFkZXJzOiBIZWFkZXJzXG4pOiBPdXRnb2luZ0h0dHBIZWFkZXJzIHtcbiAgY29uc3Qgbm9kZUhlYWRlcnM6IE91dGdvaW5nSHR0cEhlYWRlcnMgPSB7fVxuICBjb25zdCBjb29raWVzOiBzdHJpbmdbXSA9IFtdXG4gIGlmIChoZWFkZXJzKSB7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgaGVhZGVycy5lbnRyaWVzKCkpIHtcbiAgICAgIGlmIChrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ3NldC1jb29raWUnKSB7XG4gICAgICAgIC8vIFdlIG1heSBoYXZlIGdvdHRlbiBhIGNvbW1hIGpvaW5lZCBzdHJpbmcgb2YgY29va2llcywgb3IgbXVsdGlwbGVcbiAgICAgICAgLy8gc2V0LWNvb2tpZSBoZWFkZXJzLiBXZSBuZWVkIHRvIG1lcmdlIHRoZW0gaW50byBvbmUgaGVhZGVyIGFycmF5XG4gICAgICAgIC8vIHRvIHJlcHJlc2VudCBhbGwgdGhlIGNvb2tpZXMuXG4gICAgICAgIGNvb2tpZXMucHVzaCguLi5zcGxpdENvb2tpZXNTdHJpbmcodmFsdWUpKVxuICAgICAgICBub2RlSGVhZGVyc1trZXldID0gY29va2llcy5sZW5ndGggPT09IDEgPyBjb29raWVzWzBdIDogY29va2llc1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZUhlYWRlcnNba2V5XSA9IHZhbHVlXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBub2RlSGVhZGVyc1xufVxuXG4vKipcbiAqIFZhbGlkYXRlIHRoZSBjb3JyZWN0bmVzcyBvZiBhIHVzZXItcHJvdmlkZWQgVVJMLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVVUkwodXJsOiBzdHJpbmcgfCBVUkwpOiBzdHJpbmcge1xuICB0cnkge1xuICAgIHJldHVybiBTdHJpbmcobmV3IFVSTChTdHJpbmcodXJsKSkpXG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgVVJMIGlzIG1hbGZvcm1lZCBcIiR7U3RyaW5nKFxuICAgICAgICB1cmxcbiAgICAgICl9XCIuIFBsZWFzZSB1c2Ugb25seSBhYnNvbHV0ZSBVUkxzIC0gaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbWlkZGxld2FyZS1yZWxhdGl2ZS11cmxzYCxcbiAgICAgIHsgY2F1c2U6IGVycm9yIH1cbiAgICApXG4gIH1cbn1cblxuLyoqXG4gKiBOb3JtYWxpemVzIGBueHRQYCBhbmQgYG54dElgIHF1ZXJ5IHBhcmFtIHZhbHVlcyB0byByZW1vdmUgdGhlIHByZWZpeC5cbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgbXV0YXRlIHRoZSBpbnB1dCBrZXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVOZXh0UXVlcnlQYXJhbShrZXk6IHN0cmluZyk6IG51bGwgfCBzdHJpbmcge1xuICBjb25zdCBwcmVmaXhlcyA9IFtORVhUX1FVRVJZX1BBUkFNX1BSRUZJWCwgTkVYVF9JTlRFUkNFUFRJT05fTUFSS0VSX1BSRUZJWF1cbiAgZm9yIChjb25zdCBwcmVmaXggb2YgcHJlZml4ZXMpIHtcbiAgICBpZiAoa2V5ICE9PSBwcmVmaXggJiYga2V5LnN0YXJ0c1dpdGgocHJlZml4KSkge1xuICAgICAgcmV0dXJuIGtleS5zdWJzdHJpbmcocHJlZml4Lmxlbmd0aClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cbiJdLCJuYW1lcyI6WyJORVhUX0lOVEVSQ0VQVElPTl9NQVJLRVJfUFJFRklYIiwiTkVYVF9RVUVSWV9QQVJBTV9QUkVGSVgiLCJmcm9tTm9kZU91dGdvaW5nSHR0cEhlYWRlcnMiLCJub2RlSGVhZGVycyIsImhlYWRlcnMiLCJIZWFkZXJzIiwia2V5IiwidmFsdWUiLCJPYmplY3QiLCJlbnRyaWVzIiwidmFsdWVzIiwiQXJyYXkiLCJpc0FycmF5IiwidiIsInRvU3RyaW5nIiwiYXBwZW5kIiwic3BsaXRDb29raWVzU3RyaW5nIiwiY29va2llc1N0cmluZyIsImNvb2tpZXNTdHJpbmdzIiwicG9zIiwic3RhcnQiLCJjaCIsImxhc3RDb21tYSIsIm5leHRTdGFydCIsImNvb2tpZXNTZXBhcmF0b3JGb3VuZCIsInNraXBXaGl0ZXNwYWNlIiwibGVuZ3RoIiwidGVzdCIsImNoYXJBdCIsIm5vdFNwZWNpYWxDaGFyIiwicHVzaCIsInN1YnN0cmluZyIsInRvTm9kZU91dGdvaW5nSHR0cEhlYWRlcnMiLCJjb29raWVzIiwidG9Mb3dlckNhc2UiLCJ2YWxpZGF0ZVVSTCIsInVybCIsIlN0cmluZyIsIlVSTCIsImVycm9yIiwiRXJyb3IiLCJjYXVzZSIsIm5vcm1hbGl6ZU5leHRRdWVyeVBhcmFtIiwicHJlZml4ZXMiLCJwcmVmaXgiLCJzdGFydHNXaXRo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Q0EsT0FBT0o7QUFDVDtBQUtPLFNBQVNnQyxZQUFZQyxHQUFpQjtJQUMzQyxJQUFJO1FBQ0YsT0FBT0MsT0FBTyxJQUFJQyxJQUFJRCxPQUFPRDtJQUMvQixFQUFFLE9BQU9HLE9BQVk7UUFDbkIsTUFBTSxPQUFBLGNBS0wsQ0FMSyxJQUFJQyxNQUNSLENBQUMsa0JBQWtCLEVBQUVILE9BQ25CRCxLQUNBLDRGQUE0RixDQUFDLEVBQy9GO1lBQUVLLE9BQU9GO1FBQU0sSUFKWCxxQkFBQTttQkFBQTt3QkFBQTswQkFBQTtRQUtOO0lBQ0Y7QUFDRjtBQU1PLFNBQVNHLHdCQUF3QnBDLEdBQVc7SUFDakQsTUFBTXFDLFdBQVc7eUpBQUMxQywwQkFBQUE7eUpBQXlCRCxrQ0FBQUE7S0FBZ0M7SUFDM0UsS0FBSyxNQUFNNEMsVUFBVUQsU0FBVTtRQUM3QixJQUFJckMsUUFBUXNDLFVBQVV0QyxJQUFJdUMsVUFBVSxDQUFDRCxTQUFTO1lBQzVDLE9BQU90QyxJQUFJeUIsU0FBUyxDQUFDYSxPQUFPbEIsTUFBTTtRQUNwQztJQUNGO0lBQ0EsT0FBTztBQUNUIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDE5NzQsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NyYy9zaGFyZWQvbGliL2kxOG4vZGV0ZWN0LWRvbWFpbi1sb2NhbGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBEb21haW5Mb2NhbGUgfSBmcm9tICcuLi8uLi8uLi9zZXJ2ZXIvY29uZmlnLXNoYXJlZCdcblxuZXhwb3J0IGZ1bmN0aW9uIGRldGVjdERvbWFpbkxvY2FsZShcbiAgZG9tYWluSXRlbXM/OiByZWFkb25seSBEb21haW5Mb2NhbGVbXSxcbiAgaG9zdG5hbWU/OiBzdHJpbmcsXG4gIGRldGVjdGVkTG9jYWxlPzogc3RyaW5nXG4pIHtcbiAgaWYgKCFkb21haW5JdGVtcykgcmV0dXJuXG5cbiAgaWYgKGRldGVjdGVkTG9jYWxlKSB7XG4gICAgZGV0ZWN0ZWRMb2NhbGUgPSBkZXRlY3RlZExvY2FsZS50b0xvd2VyQ2FzZSgpXG4gIH1cblxuICBmb3IgKGNvbnN0IGl0ZW0gb2YgZG9tYWluSXRlbXMpIHtcbiAgICAvLyByZW1vdmUgcG9ydCBpZiBwcmVzZW50XG4gICAgY29uc3QgZG9tYWluSG9zdG5hbWUgPSBpdGVtLmRvbWFpbj8uc3BsaXQoJzonLCAxKVswXS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKFxuICAgICAgaG9zdG5hbWUgPT09IGRvbWFpbkhvc3RuYW1lIHx8XG4gICAgICBkZXRlY3RlZExvY2FsZSA9PT0gaXRlbS5kZWZhdWx0TG9jYWxlLnRvTG93ZXJDYXNlKCkgfHxcbiAgICAgIGl0ZW0ubG9jYWxlcz8uc29tZSgobG9jYWxlKSA9PiBsb2NhbGUudG9Mb3dlckNhc2UoKSA9PT0gZGV0ZWN0ZWRMb2NhbGUpXG4gICAgKSB7XG4gICAgICByZXR1cm4gaXRlbVxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbImRldGVjdERvbWFpbkxvY2FsZSIsImRvbWFpbkl0ZW1zIiwiaG9zdG5hbWUiLCJkZXRlY3RlZExvY2FsZSIsInRvTG93ZXJDYXNlIiwiaXRlbSIsImRvbWFpbkhvc3RuYW1lIiwiZG9tYWluIiwic3BsaXQiLCJkZWZhdWx0TG9jYWxlIiwibG9jYWxlcyIsInNvbWUiLCJsb2NhbGUiXSwibWFwcGluZ3MiOiI7OztBQUVPLFNBQVNBLG1CQUNkQyxXQUFxQyxFQUNyQ0MsUUFBaUIsRUFDakJDLGNBQXVCO0lBRXZCLElBQUksQ0FBQ0YsYUFBYTtJQUVsQixJQUFJRSxnQkFBZ0I7UUFDbEJBLGlCQUFpQkEsZUFBZUMsV0FBVztJQUM3QztJQUVBLEtBQUssTUFBTUMsUUFBUUosWUFBYTtZQUVQSSxjQUlyQkE7UUFMRix5QkFBeUI7UUFDekIsTUFBTUMsaUJBQUFBLENBQWlCRCxlQUFBQSxLQUFLRSxNQUFNLEtBQUEsT0FBQSxLQUFBLElBQVhGLGFBQWFHLEtBQUssQ0FBQyxLQUFLLEVBQUUsQ0FBQyxFQUFFLENBQUNKLFdBQVc7UUFDaEUsSUFDRUYsYUFBYUksa0JBQ2JILG1CQUFtQkUsS0FBS0ksYUFBYSxDQUFDTCxXQUFXLE1BQUEsQ0FBQSxDQUNqREMsZ0JBQUFBLEtBQUtLLE9BQU8sS0FBQSxPQUFBLEtBQUEsSUFBWkwsY0FBY00sSUFBSSxDQUFDLENBQUNDLFNBQVdBLE9BQU9SLFdBQVcsT0FBT0QsZUFBQUEsR0FDeEQ7WUFDQSxPQUFPRTtRQUNUO0lBQ0Y7QUFDRiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxOTk1LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zcmMvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcmVtb3ZlLXRyYWlsaW5nLXNsYXNoLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUmVtb3ZlcyB0aGUgdHJhaWxpbmcgc2xhc2ggZm9yIGEgZ2l2ZW4gcm91dGUgb3IgcGFnZSBwYXRoLiBQcmVzZXJ2ZXMgdGhlXG4gKiByb290IHBhZ2UuIEV4YW1wbGVzOlxuICogICAtIGAvZm9vL2Jhci9gIC0+IGAvZm9vL2JhcmBcbiAqICAgLSBgL2Zvby9iYXJgIC0+IGAvZm9vL2JhcmBcbiAqICAgLSBgL2AgLT4gYC9gXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVUcmFpbGluZ1NsYXNoKHJvdXRlOiBzdHJpbmcpIHtcbiAgcmV0dXJuIHJvdXRlLnJlcGxhY2UoL1xcLyQvLCAnJykgfHwgJy8nXG59XG4iXSwibmFtZXMiOlsicmVtb3ZlVHJhaWxpbmdTbGFzaCIsInJvdXRlIiwicmVwbGFjZSJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztDQU1DLEdBQ0Q7OztBQUFPLFNBQVNBLG9CQUFvQkMsS0FBYTtJQUMvQyxPQUFPQSxNQUFNQyxPQUFPLENBQUMsT0FBTyxPQUFPO0FBQ3JDIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDIwMTEsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NyYy9zaGFyZWQvbGliL3JvdXRlci91dGlscy9wYXJzZS1wYXRoLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogR2l2ZW4gYSBwYXRoIHRoaXMgZnVuY3Rpb24gd2lsbCBmaW5kIHRoZSBwYXRobmFtZSwgcXVlcnkgYW5kIGhhc2ggYW5kIHJldHVyblxuICogdGhlbS4gVGhpcyBpcyB1c2VmdWwgdG8gcGFyc2UgZnVsbCBwYXRocyBvbiB0aGUgY2xpZW50IHNpZGUuXG4gKiBAcGFyYW0gcGF0aCBBIHBhdGggdG8gcGFyc2UgZS5nLiAvZm9vL2Jhcj9pZD0xI2hhc2hcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUGF0aChwYXRoOiBzdHJpbmcpIHtcbiAgY29uc3QgaGFzaEluZGV4ID0gcGF0aC5pbmRleE9mKCcjJylcbiAgY29uc3QgcXVlcnlJbmRleCA9IHBhdGguaW5kZXhPZignPycpXG4gIGNvbnN0IGhhc1F1ZXJ5ID0gcXVlcnlJbmRleCA+IC0xICYmIChoYXNoSW5kZXggPCAwIHx8IHF1ZXJ5SW5kZXggPCBoYXNoSW5kZXgpXG5cbiAgaWYgKGhhc1F1ZXJ5IHx8IGhhc2hJbmRleCA+IC0xKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGhuYW1lOiBwYXRoLnN1YnN0cmluZygwLCBoYXNRdWVyeSA/IHF1ZXJ5SW5kZXggOiBoYXNoSW5kZXgpLFxuICAgICAgcXVlcnk6IGhhc1F1ZXJ5XG4gICAgICAgID8gcGF0aC5zdWJzdHJpbmcocXVlcnlJbmRleCwgaGFzaEluZGV4ID4gLTEgPyBoYXNoSW5kZXggOiB1bmRlZmluZWQpXG4gICAgICAgIDogJycsXG4gICAgICBoYXNoOiBoYXNoSW5kZXggPiAtMSA/IHBhdGguc2xpY2UoaGFzaEluZGV4KSA6ICcnLFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7IHBhdGhuYW1lOiBwYXRoLCBxdWVyeTogJycsIGhhc2g6ICcnIH1cbn1cbiJdLCJuYW1lcyI6WyJwYXJzZVBhdGgiLCJwYXRoIiwiaGFzaEluZGV4IiwiaW5kZXhPZiIsInF1ZXJ5SW5kZXgiLCJoYXNRdWVyeSIsInBhdGhuYW1lIiwic3Vic3RyaW5nIiwicXVlcnkiLCJ1bmRlZmluZWQiLCJoYXNoIiwic2xpY2UiXSwibWFwcGluZ3MiOiJBQUFBOzs7O0NBSUMsR0FDRDs7O0FBQU8sU0FBU0EsVUFBVUMsSUFBWTtJQUNwQyxNQUFNQyxZQUFZRCxLQUFLRSxPQUFPLENBQUM7SUFDL0IsTUFBTUMsYUFBYUgsS0FBS0UsT0FBTyxDQUFDO0lBQ2hDLE1BQU1FLFdBQVdELGFBQWEsQ0FBQyxLQUFNRixDQUFBQSxZQUFZLEtBQUtFLGFBQWFGLFNBQVE7SUFFM0UsSUFBSUcsWUFBWUgsWUFBWSxDQUFDLEdBQUc7UUFDOUIsT0FBTztZQUNMSSxVQUFVTCxLQUFLTSxTQUFTLENBQUMsR0FBR0YsV0FBV0QsYUFBYUY7WUFDcERNLE9BQU9ILFdBQ0hKLEtBQUtNLFNBQVMsQ0FBQ0gsWUFBWUYsWUFBWSxDQUFDLElBQUlBLFlBQVlPLGFBQ3hEO1lBQ0pDLE1BQU1SLFlBQVksQ0FBQyxJQUFJRCxLQUFLVSxLQUFLLENBQUNULGFBQWE7UUFDakQ7SUFDRjtJQUVBLE9BQU87UUFBRUksVUFBVUw7UUFBTU8sT0FBTztRQUFJRSxNQUFNO0lBQUc7QUFDL0MiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMjAzOSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2FkZC1wYXRoLXByZWZpeC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwYXJzZVBhdGggfSBmcm9tICcuL3BhcnNlLXBhdGgnXG5cbi8qKlxuICogQWRkcyB0aGUgcHJvdmlkZWQgcHJlZml4IHRvIHRoZSBnaXZlbiBwYXRoLiBJdCBmaXJzdCBlbnN1cmVzIHRoYXQgdGhlIHBhdGhcbiAqIGlzIGluZGVlZCBzdGFydGluZyB3aXRoIGEgc2xhc2guXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRQYXRoUHJlZml4KHBhdGg6IHN0cmluZywgcHJlZml4Pzogc3RyaW5nKSB7XG4gIGlmICghcGF0aC5zdGFydHNXaXRoKCcvJykgfHwgIXByZWZpeCkge1xuICAgIHJldHVybiBwYXRoXG4gIH1cblxuICBjb25zdCB7IHBhdGhuYW1lLCBxdWVyeSwgaGFzaCB9ID0gcGFyc2VQYXRoKHBhdGgpXG4gIHJldHVybiBgJHtwcmVmaXh9JHtwYXRobmFtZX0ke3F1ZXJ5fSR7aGFzaH1gXG59XG4iXSwibmFtZXMiOlsicGFyc2VQYXRoIiwiYWRkUGF0aFByZWZpeCIsInBhdGgiLCJwcmVmaXgiLCJzdGFydHNXaXRoIiwicGF0aG5hbWUiLCJxdWVyeSIsImhhc2giXSwibWFwcGluZ3MiOiI7OztBQUFBLFNBQVNBLFNBQVMsUUFBUSxlQUFjOztBQU1qQyxTQUFTQyxjQUFjQyxJQUFZLEVBQUVDLE1BQWU7SUFDekQsSUFBSSxDQUFDRCxLQUFLRSxVQUFVLENBQUMsUUFBUSxDQUFDRCxRQUFRO1FBQ3BDLE9BQU9EO0lBQ1Q7SUFFQSxNQUFNLEVBQUVHLFFBQVEsRUFBRUMsS0FBSyxFQUFFQyxJQUFJLEVBQUUseUxBQUdQLFlBQUFBLEVBQVVFO0lBQzVDLE9BQVEsS0FBRUMsU0FBU0UsV0FBV0MsUUFBUUM7QUFDeEMiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMjA1NSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2FkZC1wYXRoLXN1ZmZpeC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwYXJzZVBhdGggfSBmcm9tICcuL3BhcnNlLXBhdGgnXG5cbi8qKlxuICogU2ltaWxhcmx5IHRvIGBhZGRQYXRoUHJlZml4YCwgdGhpcyBmdW5jdGlvbiBhZGRzIGEgc3VmZml4IGF0IHRoZSBlbmQgb24gdGhlXG4gKiBwcm92aWRlZCBwYXRoLiBJdCBhbHNvIHdvcmtzIG9ubHkgZm9yIHBhdGhzIGVuc3VyaW5nIHRoZSBhcmd1bWVudCBzdGFydHNcbiAqIHdpdGggYSBzbGFzaC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZFBhdGhTdWZmaXgocGF0aDogc3RyaW5nLCBzdWZmaXg/OiBzdHJpbmcpIHtcbiAgaWYgKCFwYXRoLnN0YXJ0c1dpdGgoJy8nKSB8fCAhc3VmZml4KSB7XG4gICAgcmV0dXJuIHBhdGhcbiAgfVxuXG4gIGNvbnN0IHsgcGF0aG5hbWUsIHF1ZXJ5LCBoYXNoIH0gPSBwYXJzZVBhdGgocGF0aClcbiAgcmV0dXJuIGAke3BhdGhuYW1lfSR7c3VmZml4fSR7cXVlcnl9JHtoYXNofWBcbn1cbiJdLCJuYW1lcyI6WyJwYXJzZVBhdGgiLCJhZGRQYXRoU3VmZml4IiwicGF0aCIsInN1ZmZpeCIsInN0YXJ0c1dpdGgiLCJwYXRobmFtZSIsInF1ZXJ5IiwiaGFzaCJdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsU0FBU0EsU0FBUyxRQUFRLGVBQWM7O0FBT2pDLFNBQVNDLGNBQWNDLElBQVksRUFBRUMsTUFBZTtJQUN6RCxJQUFJLENBQUNELEtBQUtFLFVBQVUsQ0FBQyxRQUFRLENBQUNELFFBQVE7UUFDcEMsT0FBT0Q7SUFDVDtJQUVBLE1BQU0sRUFBRUcsUUFBUSxFQUFFQyxLQUFLLEVBQUVDLElBQUksRUFBRSx5TEFBR1AsWUFBQUEsRUFBVUU7SUFDNUMsT0FBUSxLQUFFRyxXQUFXRixTQUFTRyxRQUFRQztBQUN4QyIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAyMDcxLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zcmMvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcGF0aC1oYXMtcHJlZml4LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHBhcnNlUGF0aCB9IGZyb20gJy4vcGFyc2UtcGF0aCdcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBnaXZlbiBwYXRoIHN0YXJ0cyB3aXRoIGEgZ2l2ZW4gcHJlZml4LiBJdCBlbnN1cmVzIGl0IG1hdGNoZXNcbiAqIGV4YWN0bHkgd2l0aG91dCBjb250YWluaW5nIGV4dHJhIGNoYXJzLiBlLmcuIHByZWZpeCAvZG9jcyBzaG91bGQgcmVwbGFjZVxuICogZm9yIC9kb2NzLCAvZG9jcy8sIC9kb2NzL2EgYnV0IG5vdCAvZG9jc3NzXG4gKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEBwYXJhbSBwcmVmaXggVGhlIHByZWZpeCB0byBjaGVjayBhZ2FpbnN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGF0aEhhc1ByZWZpeChwYXRoOiBzdHJpbmcsIHByZWZpeDogc3RyaW5nKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGNvbnN0IHsgcGF0aG5hbWUgfSA9IHBhcnNlUGF0aChwYXRoKVxuICByZXR1cm4gcGF0aG5hbWUgPT09IHByZWZpeCB8fCBwYXRobmFtZS5zdGFydHNXaXRoKHByZWZpeCArICcvJylcbn1cbiJdLCJuYW1lcyI6WyJwYXJzZVBhdGgiLCJwYXRoSGFzUHJlZml4IiwicGF0aCIsInByZWZpeCIsInBhdGhuYW1lIiwic3RhcnRzV2l0aCJdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsU0FBU0EsU0FBUyxRQUFRLGVBQWM7O0FBU2pDLFNBQVNDLGNBQWNDLElBQVksRUFBRUMsTUFBYztJQUN4RCxJQUFJLE9BQU9ELFNBQVMsVUFBVTtRQUM1QixPQUFPO0lBQ1Q7SUFFQSxNQUFNLEVBQUVFLFFBQVEsRUFBRSx5TEFBR0osWUFBQUEsRUFBVUU7SUFDL0IsT0FBT0UsYUFBYUQsVUFBVUMsU0FBU0MsVUFBVSxDQUFDRixTQUFTO0FBQzdEIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDIwODcsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NyYy9zaGFyZWQvbGliL3JvdXRlci91dGlscy9hZGQtbG9jYWxlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFkZFBhdGhQcmVmaXggfSBmcm9tICcuL2FkZC1wYXRoLXByZWZpeCdcbmltcG9ydCB7IHBhdGhIYXNQcmVmaXggfSBmcm9tICcuL3BhdGgtaGFzLXByZWZpeCdcblxuLyoqXG4gKiBGb3IgYSBnaXZlbiBwYXRoIGFuZCBhIGxvY2FsZSwgaWYgdGhlIGxvY2FsZSBpcyBnaXZlbiwgaXQgd2lsbCBwcmVmaXggdGhlXG4gKiBsb2NhbGUuIFRoZSBwYXRoIHNob3VsZG4ndCBiZSBhbiBBUEkgcGF0aC4gSWYgYSBkZWZhdWx0IGxvY2FsZSBpcyBnaXZlbiB0aGVcbiAqIHByZWZpeCB3aWxsIGJlIG9taXR0ZWQgaWYgdGhlIGxvY2FsZSBpcyBhbHJlYWR5IHRoZSBkZWZhdWx0IGxvY2FsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZExvY2FsZShcbiAgcGF0aDogc3RyaW5nLFxuICBsb2NhbGU/OiBzdHJpbmcgfCBmYWxzZSxcbiAgZGVmYXVsdExvY2FsZT86IHN0cmluZyxcbiAgaWdub3JlUHJlZml4PzogYm9vbGVhblxuKSB7XG4gIC8vIElmIG5vIGxvY2FsZSB3YXMgZ2l2ZW4gb3IgdGhlIGxvY2FsZSBpcyB0aGUgZGVmYXVsdCBsb2NhbGUsIHdlIGRvbid0IG5lZWRcbiAgLy8gdG8gcHJlZml4IHRoZSBwYXRoLlxuICBpZiAoIWxvY2FsZSB8fCBsb2NhbGUgPT09IGRlZmF1bHRMb2NhbGUpIHJldHVybiBwYXRoXG5cbiAgY29uc3QgbG93ZXIgPSBwYXRoLnRvTG93ZXJDYXNlKClcblxuICAvLyBJZiB0aGUgcGF0aCBpcyBhbiBBUEkgcGF0aCBvciB0aGUgcGF0aCBhbHJlYWR5IGhhcyB0aGUgbG9jYWxlIHByZWZpeCwgd2VcbiAgLy8gZG9uJ3QgbmVlZCB0byBwcmVmaXggdGhlIHBhdGguXG4gIGlmICghaWdub3JlUHJlZml4KSB7XG4gICAgaWYgKHBhdGhIYXNQcmVmaXgobG93ZXIsICcvYXBpJykpIHJldHVybiBwYXRoXG4gICAgaWYgKHBhdGhIYXNQcmVmaXgobG93ZXIsIGAvJHtsb2NhbGUudG9Mb3dlckNhc2UoKX1gKSkgcmV0dXJuIHBhdGhcbiAgfVxuXG4gIC8vIEFkZCB0aGUgbG9jYWxlIHByZWZpeCB0byB0aGUgcGF0aC5cbiAgcmV0dXJuIGFkZFBhdGhQcmVmaXgocGF0aCwgYC8ke2xvY2FsZX1gKVxufVxuIl0sIm5hbWVzIjpbImFkZFBhdGhQcmVmaXgiLCJwYXRoSGFzUHJlZml4IiwiYWRkTG9jYWxlIiwicGF0aCIsImxvY2FsZSIsImRlZmF1bHRMb2NhbGUiLCJpZ25vcmVQcmVmaXgiLCJsb3dlciIsInRvTG93ZXJDYXNlIl0sIm1hcHBpbmdzIjoiOzs7QUFBQSxTQUFTQSxhQUFhLFFBQVEsb0JBQW1CO0FBQ2pELFNBQVNDLGFBQWEsUUFBUSxvQkFBbUI7OztBQU8xQyxTQUFTQyxVQUNkQyxJQUFZLEVBQ1pDLE1BQXVCLEVBQ3ZCQyxhQUFzQixFQUN0QkMsWUFBc0I7SUFFdEIsNEVBQTRFO0lBQzVFLHNCQUFzQjtJQUN0QixJQUFJLENBQUNGLFVBQVVBLFdBQVdDLGVBQWUsT0FBT0Y7SUFFaEQsTUFBTUksUUFBUUosS0FBS0ssV0FBVztJQUU5QiwyRUFBMkU7SUFDM0UsaUNBQWlDO0lBQ2pDLElBQUksQ0FBQ0YsY0FBYztRQUNqQixrTUFBSUwsZ0JBQUFBLEVBQWNNLE9BQU8sU0FBUyxPQUFPSjtRQUN6QyxrTUFBSUYsZ0JBQUFBLEVBQWNNLE9BQVEsTUFBR0gsT0FBT0ksV0FBVyxLQUFPLE9BQU9MO0lBQy9EO0lBRUEscUNBQXFDO0lBQ3JDLHFNQUFPSCxnQkFBQUEsRUFBY0csTUFBTyxNQUFHQztBQUNqQyIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAyMTEyLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zcmMvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvZm9ybWF0LW5leHQtcGF0aG5hbWUtaW5mby50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IE5leHRQYXRobmFtZUluZm8gfSBmcm9tICcuL2dldC1uZXh0LXBhdGhuYW1lLWluZm8nXG5pbXBvcnQgeyByZW1vdmVUcmFpbGluZ1NsYXNoIH0gZnJvbSAnLi9yZW1vdmUtdHJhaWxpbmctc2xhc2gnXG5pbXBvcnQgeyBhZGRQYXRoUHJlZml4IH0gZnJvbSAnLi9hZGQtcGF0aC1wcmVmaXgnXG5pbXBvcnQgeyBhZGRQYXRoU3VmZml4IH0gZnJvbSAnLi9hZGQtcGF0aC1zdWZmaXgnXG5pbXBvcnQgeyBhZGRMb2NhbGUgfSBmcm9tICcuL2FkZC1sb2NhbGUnXG5cbmludGVyZmFjZSBFeHRlbmRlZEluZm8gZXh0ZW5kcyBOZXh0UGF0aG5hbWVJbmZvIHtcbiAgZGVmYXVsdExvY2FsZT86IHN0cmluZ1xuICBpZ25vcmVQcmVmaXg/OiBib29sZWFuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXROZXh0UGF0aG5hbWVJbmZvKGluZm86IEV4dGVuZGVkSW5mbykge1xuICBsZXQgcGF0aG5hbWUgPSBhZGRMb2NhbGUoXG4gICAgaW5mby5wYXRobmFtZSxcbiAgICBpbmZvLmxvY2FsZSxcbiAgICBpbmZvLmJ1aWxkSWQgPyB1bmRlZmluZWQgOiBpbmZvLmRlZmF1bHRMb2NhbGUsXG4gICAgaW5mby5pZ25vcmVQcmVmaXhcbiAgKVxuXG4gIGlmIChpbmZvLmJ1aWxkSWQgfHwgIWluZm8udHJhaWxpbmdTbGFzaCkge1xuICAgIHBhdGhuYW1lID0gcmVtb3ZlVHJhaWxpbmdTbGFzaChwYXRobmFtZSlcbiAgfVxuXG4gIGlmIChpbmZvLmJ1aWxkSWQpIHtcbiAgICBwYXRobmFtZSA9IGFkZFBhdGhTdWZmaXgoXG4gICAgICBhZGRQYXRoUHJlZml4KHBhdGhuYW1lLCBgL19uZXh0L2RhdGEvJHtpbmZvLmJ1aWxkSWR9YCksXG4gICAgICBpbmZvLnBhdGhuYW1lID09PSAnLycgPyAnaW5kZXguanNvbicgOiAnLmpzb24nXG4gICAgKVxuICB9XG5cbiAgcGF0aG5hbWUgPSBhZGRQYXRoUHJlZml4KHBhdGhuYW1lLCBpbmZvLmJhc2VQYXRoKVxuICByZXR1cm4gIWluZm8uYnVpbGRJZCAmJiBpbmZvLnRyYWlsaW5nU2xhc2hcbiAgICA/ICFwYXRobmFtZS5lbmRzV2l0aCgnLycpXG4gICAgICA/IGFkZFBhdGhTdWZmaXgocGF0aG5hbWUsICcvJylcbiAgICAgIDogcGF0aG5hbWVcbiAgICA6IHJlbW92ZVRyYWlsaW5nU2xhc2gocGF0aG5hbWUpXG59XG4iXSwibmFtZXMiOlsicmVtb3ZlVHJhaWxpbmdTbGFzaCIsImFkZFBhdGhQcmVmaXgiLCJhZGRQYXRoU3VmZml4IiwiYWRkTG9jYWxlIiwiZm9ybWF0TmV4dFBhdGhuYW1lSW5mbyIsImluZm8iLCJwYXRobmFtZSIsImxvY2FsZSIsImJ1aWxkSWQiLCJ1bmRlZmluZWQiLCJkZWZhdWx0TG9jYWxlIiwiaWdub3JlUHJlZml4IiwidHJhaWxpbmdTbGFzaCIsImJhc2VQYXRoIiwiZW5kc1dpdGgiXSwibWFwcGluZ3MiOiI7OztBQUNBLFNBQVNBLG1CQUFtQixRQUFRLDBCQUF5QjtBQUM3RCxTQUFTQyxhQUFhLFFBQVEsb0JBQW1CO0FBQ2pELFNBQVNDLGFBQWEsUUFBUSxvQkFBbUI7QUFDakQsU0FBU0MsU0FBUyxRQUFRLGVBQWM7Ozs7O0FBT2pDLFNBQVNDLHVCQUF1QkMsSUFBa0I7SUFDdkQsSUFBSUMsaU1BQVdILFlBQUFBLEVBQ2JFLEtBQUtDLFFBQVEsRUFDYkQsS0FBS0UsTUFBTSxFQUNYRixLQUFLRyxPQUFPLEdBQUdDLFlBQVlKLEtBQUtLLGFBQWEsRUFDN0NMLEtBQUtNLFlBQVk7SUFHbkIsSUFBSU4sS0FBS0csT0FBTyxJQUFJLENBQUNILEtBQUtPLGFBQWEsRUFBRTtRQUN2Q04sK01BQVdOLHNCQUFBQSxFQUFvQk07SUFDakM7SUFFQSxJQUFJRCxLQUFLRyxPQUFPLEVBQUU7UUFDaEJGLHlNQUFXSixnQkFBQUEsZ01BQ1RELGdCQUFBQSxFQUFjSyxVQUFXLGlCQUFjRCxLQUFLRyxPQUFPLEdBQ25ESCxLQUFLQyxRQUFRLEtBQUssTUFBTSxlQUFlO0lBRTNDO0lBRUFBLHlNQUFXTCxnQkFBQUEsRUFBY0ssVUFBVUQsS0FBS1EsUUFBUTtJQUNoRCxPQUFPLENBQUNSLEtBQUtHLE9BQU8sSUFBSUgsS0FBS08sYUFBYSxHQUN0QyxDQUFDTixTQUFTUSxRQUFRLENBQUMscU1BQ2pCWixnQkFBQUEsRUFBY0ksVUFBVSxPQUN4QkEsK01BQ0ZOLHNCQUFBQSxFQUFvQk07QUFDMUIiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMjEzOCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL3NoYXJlZC9saWIvZ2V0LWhvc3RuYW1lLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgT3V0Z29pbmdIdHRwSGVhZGVycyB9IGZyb20gJ2h0dHAnXG5cbi8qKlxuICogVGFrZXMgYW4gb2JqZWN0IHdpdGggYSBob3N0bmFtZSBwcm9wZXJ0eSAobGlrZSBhIHBhcnNlZCBVUkwpIGFuZCBzb21lXG4gKiBoZWFkZXJzIHRoYXQgbWF5IGNvbnRhaW4gSG9zdCBhbmQgcmV0dXJucyB0aGUgcHJlZmVycmVkIGhvc3RuYW1lLlxuICogQHBhcmFtIHBhcnNlZCBBbiBvYmplY3QgY29udGFpbmluZyBhIGhvc3RuYW1lIHByb3BlcnR5LlxuICogQHBhcmFtIGhlYWRlcnMgQSBkaWN0aW9uYXJ5IHdpdGggaGVhZGVycyBjb250YWluaW5nIGEgYGhvc3RgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SG9zdG5hbWUoXG4gIHBhcnNlZDogeyBob3N0bmFtZT86IHN0cmluZyB8IG51bGwgfSxcbiAgaGVhZGVycz86IE91dGdvaW5nSHR0cEhlYWRlcnNcbik6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gIC8vIEdldCB0aGUgaG9zdG5hbWUgZnJvbSB0aGUgaGVhZGVycyBpZiBpdCBleGlzdHMsIG90aGVyd2lzZSB1c2UgdGhlIHBhcnNlZFxuICAvLyBob3N0bmFtZS5cbiAgbGV0IGhvc3RuYW1lOiBzdHJpbmdcbiAgaWYgKGhlYWRlcnM/Lmhvc3QgJiYgIUFycmF5LmlzQXJyYXkoaGVhZGVycy5ob3N0KSkge1xuICAgIGhvc3RuYW1lID0gaGVhZGVycy5ob3N0LnRvU3RyaW5nKCkuc3BsaXQoJzonLCAxKVswXVxuICB9IGVsc2UgaWYgKHBhcnNlZC5ob3N0bmFtZSkge1xuICAgIGhvc3RuYW1lID0gcGFyc2VkLmhvc3RuYW1lXG4gIH0gZWxzZSByZXR1cm5cblxuICByZXR1cm4gaG9zdG5hbWUudG9Mb3dlckNhc2UoKVxufVxuIl0sIm5hbWVzIjpbImdldEhvc3RuYW1lIiwicGFyc2VkIiwiaGVhZGVycyIsImhvc3RuYW1lIiwiaG9zdCIsIkFycmF5IiwiaXNBcnJheSIsInRvU3RyaW5nIiwic3BsaXQiLCJ0b0xvd2VyQ2FzZSJdLCJtYXBwaW5ncyI6IkFBRUE7Ozs7O0NBS0MsR0FDRDs7O0FBQU8sU0FBU0EsWUFDZEMsTUFBb0MsRUFDcENDLE9BQTZCO0lBRTdCLDJFQUEyRTtJQUMzRSxZQUFZO0lBQ1osSUFBSUM7SUFDSixJQUFJRCxDQUFBQSxXQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxRQUFTRSxJQUFJLEtBQUksQ0FBQ0MsTUFBTUMsT0FBTyxDQUFDSixRQUFRRSxJQUFJLEdBQUc7UUFDakRELFdBQVdELFFBQVFFLElBQUksQ0FBQ0csUUFBUSxHQUFHQyxLQUFLLENBQUMsS0FBSyxFQUFFLENBQUMsRUFBRTtJQUNyRCxPQUFPLElBQUlQLE9BQU9FLFFBQVEsRUFBRTtRQUMxQkEsV0FBV0YsT0FBT0UsUUFBUTtJQUM1QixPQUFPO0lBRVAsT0FBT0EsU0FBU00sV0FBVztBQUM3QiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAyMTYxLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zcmMvc2hhcmVkL2xpYi9pMThuL25vcm1hbGl6ZS1sb2NhbGUtcGF0aC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgaW50ZXJmYWNlIFBhdGhMb2NhbGUge1xuICBkZXRlY3RlZExvY2FsZT86IHN0cmluZ1xuICBwYXRobmFtZTogc3RyaW5nXG59XG5cbi8qKlxuICogQSBjYWNoZSBvZiBsb3dlcmNhc2VkIGxvY2FsZXMgZm9yIGVhY2ggbGlzdCBvZiBsb2NhbGVzLiBUaGlzIGlzIHN0b3JlZCBhcyBhXG4gKiBXZWFrTWFwIHNvIGlmIHRoZSBsb2NhbGVzIGFyZSBnYXJiYWdlIGNvbGxlY3RlZCwgdGhlIGNhY2hlIGVudHJ5IHdpbGwgYmVcbiAqIHJlbW92ZWQgYXMgd2VsbC5cbiAqL1xuY29uc3QgY2FjaGUgPSBuZXcgV2Vha01hcDxyZWFkb25seSBzdHJpbmdbXSwgcmVhZG9ubHkgc3RyaW5nW10+KClcblxuLyoqXG4gKiBGb3IgYSBwYXRobmFtZSB0aGF0IG1heSBpbmNsdWRlIGEgbG9jYWxlIGZyb20gYSBsaXN0IG9mIGxvY2FsZXMsIGl0XG4gKiByZW1vdmVzIHRoZSBsb2NhbGUgZnJvbSB0aGUgcGF0aG5hbWUgcmV0dXJuaW5nIGl0IGFsb25nc2lkZSB3aXRoIHRoZVxuICogZGV0ZWN0ZWQgbG9jYWxlLlxuICpcbiAqIEBwYXJhbSBwYXRobmFtZSBBIHBhdGhuYW1lIHRoYXQgbWF5IGluY2x1ZGUgYSBsb2NhbGUuXG4gKiBAcGFyYW0gbG9jYWxlcyBBIGxpc3Qgb2YgbG9jYWxlcy5cbiAqIEByZXR1cm5zIFRoZSBkZXRlY3RlZCBsb2NhbGUgYW5kIHBhdGhuYW1lIHdpdGhvdXQgbG9jYWxlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVMb2NhbGVQYXRoKFxuICBwYXRobmFtZTogc3RyaW5nLFxuICBsb2NhbGVzPzogcmVhZG9ubHkgc3RyaW5nW11cbik6IFBhdGhMb2NhbGUge1xuICAvLyBJZiBsb2NhbGVzIGlzIHVuZGVmaW5lZCwgcmV0dXJuIHRoZSBwYXRobmFtZSBhcyBpcy5cbiAgaWYgKCFsb2NhbGVzKSByZXR1cm4geyBwYXRobmFtZSB9XG5cbiAgLy8gR2V0IHRoZSBjYWNoZWQgbG93ZXJjYXNlZCBsb2NhbGVzIG9yIGNyZWF0ZSBhIG5ldyBjYWNoZSBlbnRyeS5cbiAgbGV0IGxvd2VyY2FzZWRMb2NhbGVzID0gY2FjaGUuZ2V0KGxvY2FsZXMpXG4gIGlmICghbG93ZXJjYXNlZExvY2FsZXMpIHtcbiAgICBsb3dlcmNhc2VkTG9jYWxlcyA9IGxvY2FsZXMubWFwKChsb2NhbGUpID0+IGxvY2FsZS50b0xvd2VyQ2FzZSgpKVxuICAgIGNhY2hlLnNldChsb2NhbGVzLCBsb3dlcmNhc2VkTG9jYWxlcylcbiAgfVxuXG4gIGxldCBkZXRlY3RlZExvY2FsZTogc3RyaW5nIHwgdW5kZWZpbmVkXG5cbiAgLy8gVGhlIGZpcnN0IHNlZ21lbnQgd2lsbCBiZSBlbXB0eSwgYmVjYXVzZSBpdCBoYXMgYSBsZWFkaW5nIGAvYC4gSWZcbiAgLy8gdGhlcmUgaXMgbm8gZnVydGhlciBzZWdtZW50LCB0aGVyZSBpcyBubyBsb2NhbGUgKG9yIGl0J3MgdGhlIGRlZmF1bHQpLlxuICBjb25zdCBzZWdtZW50cyA9IHBhdGhuYW1lLnNwbGl0KCcvJywgMilcblxuICAvLyBJZiB0aGVyZSdzIG5vIHNlY29uZCBzZWdtZW50IChpZSwgdGhlIHBhdGhuYW1lIGlzIGp1c3QgYC9gKSwgdGhlcmUncyBub1xuICAvLyBsb2NhbGUuXG4gIGlmICghc2VnbWVudHNbMV0pIHJldHVybiB7IHBhdGhuYW1lIH1cblxuICAvLyBUaGUgc2Vjb25kIHNlZ21lbnQgd2lsbCBjb250YWluIHRoZSBsb2NhbGUgcGFydCBpZiBhbnkuXG4gIGNvbnN0IHNlZ21lbnQgPSBzZWdtZW50c1sxXS50b0xvd2VyQ2FzZSgpXG5cbiAgLy8gU2VlIGlmIHRoZSBzZWdtZW50IG1hdGNoZXMgb25lIG9mIHRoZSBsb2NhbGVzLiBJZiBpdCBkb2Vzbid0LCB0aGVyZSBpc1xuICAvLyBubyBsb2NhbGUgKG9yIGl0J3MgdGhlIGRlZmF1bHQpLlxuICBjb25zdCBpbmRleCA9IGxvd2VyY2FzZWRMb2NhbGVzLmluZGV4T2Yoc2VnbWVudClcbiAgaWYgKGluZGV4IDwgMCkgcmV0dXJuIHsgcGF0aG5hbWUgfVxuXG4gIC8vIFJldHVybiB0aGUgY2FzZS1zZW5zaXRpdmUgbG9jYWxlLlxuICBkZXRlY3RlZExvY2FsZSA9IGxvY2FsZXNbaW5kZXhdXG5cbiAgLy8gUmVtb3ZlIHRoZSBgLyR7bG9jYWxlfWAgcGFydCBvZiB0aGUgcGF0aG5hbWUuXG4gIHBhdGhuYW1lID0gcGF0aG5hbWUuc2xpY2UoZGV0ZWN0ZWRMb2NhbGUubGVuZ3RoICsgMSkgfHwgJy8nXG5cbiAgcmV0dXJuIHsgcGF0aG5hbWUsIGRldGVjdGVkTG9jYWxlIH1cbn1cbiJdLCJuYW1lcyI6WyJjYWNoZSIsIldlYWtNYXAiLCJub3JtYWxpemVMb2NhbGVQYXRoIiwicGF0aG5hbWUiLCJsb2NhbGVzIiwibG93ZXJjYXNlZExvY2FsZXMiLCJnZXQiLCJtYXAiLCJsb2NhbGUiLCJ0b0xvd2VyQ2FzZSIsInNldCIsImRldGVjdGVkTG9jYWxlIiwic2VnbWVudHMiLCJzcGxpdCIsInNlZ21lbnQiLCJpbmRleCIsImluZGV4T2YiLCJzbGljZSIsImxlbmd0aCJdLCJtYXBwaW5ncyI6IkFBS0E7Ozs7Q0FJQzs7O0FBQ0QsTUFBTUEsUUFBUSxJQUFJQztBQVdYLFNBQVNDLG9CQUNkQyxRQUFnQixFQUNoQkMsT0FBMkI7SUFFM0Isc0RBQXNEO0lBQ3RELElBQUksQ0FBQ0EsU0FBUyxPQUFPO1FBQUVEO0lBQVM7SUFFaEMsaUVBQWlFO0lBQ2pFLElBQUlFLG9CQUFvQkwsTUFBTU0sR0FBRyxDQUFDRjtJQUNsQyxJQUFJLENBQUNDLG1CQUFtQjtRQUN0QkEsb0JBQW9CRCxRQUFRRyxHQUFHLENBQUMsQ0FBQ0MsU0FBV0EsT0FBT0MsV0FBVztRQUM5RFQsTUFBTVUsR0FBRyxDQUFDTixTQUFTQztJQUNyQjtJQUVBLElBQUlNO0lBRUosb0VBQW9FO0lBQ3BFLHlFQUF5RTtJQUN6RSxNQUFNQyxXQUFXVCxTQUFTVSxLQUFLLENBQUMsS0FBSztJQUVyQywwRUFBMEU7SUFDMUUsVUFBVTtJQUNWLElBQUksQ0FBQ0QsUUFBUSxDQUFDLEVBQUUsRUFBRSxPQUFPO1FBQUVUO0lBQVM7SUFFcEMsMERBQTBEO0lBQzFELE1BQU1XLFVBQVVGLFFBQVEsQ0FBQyxFQUFFLENBQUNILFdBQVc7SUFFdkMseUVBQXlFO0lBQ3pFLG1DQUFtQztJQUNuQyxNQUFNTSxRQUFRVixrQkFBa0JXLE9BQU8sQ0FBQ0Y7SUFDeEMsSUFBSUMsUUFBUSxHQUFHLE9BQU87UUFBRVo7SUFBUztJQUVqQyxvQ0FBb0M7SUFDcENRLGlCQUFpQlAsT0FBTyxDQUFDVyxNQUFNO0lBRS9CLGdEQUFnRDtJQUNoRFosV0FBV0EsU0FBU2MsS0FBSyxDQUFDTixlQUFlTyxNQUFNLEdBQUcsTUFBTTtJQUV4RCxPQUFPO1FBQUVmO1FBQVVRO0lBQWU7QUFDcEMiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMjIxMCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3JlbW92ZS1wYXRoLXByZWZpeC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwYXRoSGFzUHJlZml4IH0gZnJvbSAnLi9wYXRoLWhhcy1wcmVmaXgnXG5cbi8qKlxuICogR2l2ZW4gYSBwYXRoIGFuZCBhIHByZWZpeCBpdCB3aWxsIHJlbW92ZSB0aGUgcHJlZml4IHdoZW4gaXQgZXhpc3RzIGluIHRoZVxuICogZ2l2ZW4gcGF0aC4gSXQgZW5zdXJlcyBpdCBtYXRjaGVzIGV4YWN0bHkgd2l0aG91dCBjb250YWluaW5nIGV4dHJhIGNoYXJzXG4gKiBhbmQgaWYgdGhlIHByZWZpeCBpcyBub3QgdGhlcmUgaXQgd2lsbCBiZSBub29wLlxuICpcbiAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIHRvIHJlbW92ZSB0aGUgcHJlZml4IGZyb20uXG4gKiBAcGFyYW0gcHJlZml4IFRoZSBwcmVmaXggdG8gYmUgcmVtb3ZlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVBhdGhQcmVmaXgocGF0aDogc3RyaW5nLCBwcmVmaXg6IHN0cmluZyk6IHN0cmluZyB7XG4gIC8vIElmIHRoZSBwYXRoIGRvZXNuJ3Qgc3RhcnQgd2l0aCB0aGUgcHJlZml4IHdlIGNhbiByZXR1cm4gaXQgYXMgaXMuIFRoaXNcbiAgLy8gcHJvdGVjdHMgdXMgZnJvbSBzaXR1YXRpb25zIHdoZXJlIHRoZSBwcmVmaXggaXMgYSBzdWJzdHJpbmcgb2YgdGhlIHBhdGhcbiAgLy8gcHJlZml4IHN1Y2ggYXM6XG4gIC8vXG4gIC8vIEZvciBwcmVmaXg6IC9ibG9nXG4gIC8vXG4gIC8vICAgL2Jsb2cgLT4gdHJ1ZVxuICAvLyAgIC9ibG9nLyAtPiB0cnVlXG4gIC8vICAgL2Jsb2cvMSAtPiB0cnVlXG4gIC8vICAgL2Jsb2dnaW5nIC0+IGZhbHNlXG4gIC8vICAgL2Jsb2dnaW5nLyAtPiBmYWxzZVxuICAvLyAgIC9ibG9nZ2luZy8xIC0+IGZhbHNlXG4gIGlmICghcGF0aEhhc1ByZWZpeChwYXRoLCBwcmVmaXgpKSB7XG4gICAgcmV0dXJuIHBhdGhcbiAgfVxuXG4gIC8vIFJlbW92ZSB0aGUgcHJlZml4IGZyb20gdGhlIHBhdGggdmlhIHNsaWNpbmcuXG4gIGNvbnN0IHdpdGhvdXRQcmVmaXggPSBwYXRoLnNsaWNlKHByZWZpeC5sZW5ndGgpXG5cbiAgLy8gSWYgdGhlIHBhdGggd2l0aG91dCB0aGUgcHJlZml4IHN0YXJ0cyB3aXRoIGEgYC9gIHdlIGNhbiByZXR1cm4gaXQgYXMgaXMuXG4gIGlmICh3aXRob3V0UHJlZml4LnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgIHJldHVybiB3aXRob3V0UHJlZml4XG4gIH1cblxuICAvLyBJZiB0aGUgcGF0aCB3aXRob3V0IHRoZSBwcmVmaXggZG9lc24ndCBzdGFydCB3aXRoIGEgYC9gIHdlIG5lZWQgdG8gYWRkIGl0XG4gIC8vIGJhY2sgdG8gdGhlIHBhdGggdG8gbWFrZSBzdXJlIGl0J3MgYSB2YWxpZCBwYXRoLlxuICByZXR1cm4gYC8ke3dpdGhvdXRQcmVmaXh9YFxufVxuIl0sIm5hbWVzIjpbInBhdGhIYXNQcmVmaXgiLCJyZW1vdmVQYXRoUHJlZml4IiwicGF0aCIsInByZWZpeCIsIndpdGhvdXRQcmVmaXgiLCJzbGljZSIsImxlbmd0aCIsInN0YXJ0c1dpdGgiXSwibWFwcGluZ3MiOiI7OztBQUFBLFNBQVNBLGFBQWEsUUFBUSxvQkFBbUI7O0FBVTFDLFNBQVNDLGlCQUFpQkMsSUFBWSxFQUFFQyxNQUFjO0lBQzNELHlFQUF5RTtJQUN6RSwwRUFBMEU7SUFDMUUsa0JBQWtCO0lBQ2xCLEVBQUU7SUFDRixvQkFBb0I7SUFDcEIsRUFBRTtJQUNGLGtCQUFrQjtJQUNsQixtQkFBbUI7SUFDbkIsb0JBQW9CO0lBQ3BCLHVCQUF1QjtJQUN2Qix3QkFBd0I7SUFDeEIseUJBQXlCO0lBQ3pCLElBQUksK0xBQUNILGdCQUFBQSxFQUFjRSxNQUFNQyxTQUFTO1FBQ2hDLE9BQU9EO0lBQ1Q7SUFFQSwrQ0FBK0M7SUFDL0MsTUFBTUUsZ0JBQWdCRixLQUFLRyxLQUFLLENBQUNGLE9BQU9HLE1BQU07SUFFOUMsMkVBQTJFO0lBQzNFLElBQUlGLGNBQWNHLFVBQVUsQ0FBQyxNQUFNO1FBQ2pDLE9BQU9IO0lBQ1Q7SUFFQSw0RUFBNEU7SUFDNUUsbURBQW1EO0lBQ25ELE9BQVEsTUFBR0E7QUFDYiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAyMjQ1LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zcmMvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvZ2V0LW5leHQtcGF0aG5hbWUtaW5mby50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBub3JtYWxpemVMb2NhbGVQYXRoIH0gZnJvbSAnLi4vLi4vaTE4bi9ub3JtYWxpemUtbG9jYWxlLXBhdGgnXG5pbXBvcnQgeyByZW1vdmVQYXRoUHJlZml4IH0gZnJvbSAnLi9yZW1vdmUtcGF0aC1wcmVmaXgnXG5pbXBvcnQgeyBwYXRoSGFzUHJlZml4IH0gZnJvbSAnLi9wYXRoLWhhcy1wcmVmaXgnXG5pbXBvcnQgdHlwZSB7IEkxOE5Qcm92aWRlciB9IGZyb20gJy4uLy4uLy4uLy4uL3NlcnZlci9saWIvaTE4bi1wcm92aWRlcidcblxuZXhwb3J0IGludGVyZmFjZSBOZXh0UGF0aG5hbWVJbmZvIHtcbiAgLyoqXG4gICAqIFRoZSBiYXNlIHBhdGggaW4gY2FzZSB0aGUgcGF0aG5hbWUgaW5jbHVkZWQgaXQuXG4gICAqL1xuICBiYXNlUGF0aD86IHN0cmluZ1xuICAvKipcbiAgICogVGhlIGJ1aWxkSWQgZm9yIHdoZW4gdGhlIHBhcnNlZCBVUkwgaXMgYSBkYXRhIFVSTC4gUGFyc2luZyBpdCBjYW4gYmVcbiAgICogZGlzYWJsZWQgd2l0aCB0aGUgYHBhcnNlRGF0YWAgb3B0aW9uLlxuICAgKi9cbiAgYnVpbGRJZD86IHN0cmluZ1xuICAvKipcbiAgICogSWYgdGhlcmUgd2FzIGEgbG9jYWxlIGluIHRoZSBwYXRobmFtZSwgdGhpcyB3aWxsIGhvbGQgaXRzIHZhbHVlLlxuICAgKi9cbiAgbG9jYWxlPzogc3RyaW5nXG4gIC8qKlxuICAgKiBUaGUgcHJvY2Vzc2VkIHBhdGhuYW1lIHdpdGhvdXQgYSBiYXNlIHBhdGgsIGxvY2FsZSwgb3IgZGF0YSBVUkwgZWxlbWVudHNcbiAgICogd2hlbiBwYXJzaW5nIGl0IGlzIGVuYWJsZWQuXG4gICAqL1xuICBwYXRobmFtZTogc3RyaW5nXG4gIC8qKlxuICAgKiBBIGJvb2xlYW4gdGVsbGluZyBpZiB0aGUgcGF0aG5hbWUgaGFkIGEgdHJhaWxpbmdTbGFzaC4gVGhpcyBjYW4gYmUgb25seVxuICAgKiB0cnVlIGlmIHRyYWlsaW5nU2xhc2ggaXMgZW5hYmxlZC5cbiAgICovXG4gIHRyYWlsaW5nU2xhc2g/OiBib29sZWFuXG59XG5cbmludGVyZmFjZSBPcHRpb25zIHtcbiAgLyoqXG4gICAqIFdoZW4gcGFzc2VkIHRvIHRydWUsIHRoaXMgZnVuY3Rpb24gd2lsbCBhbHNvIHBhcnNlIE5leHRqcyBkYXRhIFVSTHMuXG4gICAqL1xuICBwYXJzZURhdGE/OiBib29sZWFuXG4gIC8qKlxuICAgKiBBIHBhcnRpYWwgb2YgdGhlIE5leHQuanMgY29uZmlndXJhdGlvbiB0byBwYXJzZSB0aGUgVVJMLlxuICAgKi9cbiAgbmV4dENvbmZpZz86IHtcbiAgICBiYXNlUGF0aD86IHN0cmluZ1xuICAgIGkxOG4/OiB7IGxvY2FsZXM/OiByZWFkb25seSBzdHJpbmdbXSB9IHwgbnVsbFxuICAgIHRyYWlsaW5nU2xhc2g/OiBib29sZWFuXG4gIH1cblxuICAvKipcbiAgICogSWYgcHJvdmlkZWQsIHRoaXMgbm9ybWFsaXplciB3aWxsIGJlIHVzZWQgdG8gZGV0ZWN0IHRoZSBsb2NhbGUgaW5zdGVhZCBvZlxuICAgKiB0aGUgZGVmYXVsdCBsb2NhbGUgZGV0ZWN0aW9uLlxuICAgKi9cbiAgaTE4blByb3ZpZGVyPzogSTE4TlByb3ZpZGVyXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXROZXh0UGF0aG5hbWVJbmZvKFxuICBwYXRobmFtZTogc3RyaW5nLFxuICBvcHRpb25zOiBPcHRpb25zXG4pOiBOZXh0UGF0aG5hbWVJbmZvIHtcbiAgY29uc3QgeyBiYXNlUGF0aCwgaTE4biwgdHJhaWxpbmdTbGFzaCB9ID0gb3B0aW9ucy5uZXh0Q29uZmlnID8/IHt9XG4gIGNvbnN0IGluZm86IE5leHRQYXRobmFtZUluZm8gPSB7XG4gICAgcGF0aG5hbWUsXG4gICAgdHJhaWxpbmdTbGFzaDogcGF0aG5hbWUgIT09ICcvJyA/IHBhdGhuYW1lLmVuZHNXaXRoKCcvJykgOiB0cmFpbGluZ1NsYXNoLFxuICB9XG5cbiAgaWYgKGJhc2VQYXRoICYmIHBhdGhIYXNQcmVmaXgoaW5mby5wYXRobmFtZSwgYmFzZVBhdGgpKSB7XG4gICAgaW5mby5wYXRobmFtZSA9IHJlbW92ZVBhdGhQcmVmaXgoaW5mby5wYXRobmFtZSwgYmFzZVBhdGgpXG4gICAgaW5mby5iYXNlUGF0aCA9IGJhc2VQYXRoXG4gIH1cbiAgbGV0IHBhdGhuYW1lTm9EYXRhUHJlZml4ID0gaW5mby5wYXRobmFtZVxuXG4gIGlmIChcbiAgICBpbmZvLnBhdGhuYW1lLnN0YXJ0c1dpdGgoJy9fbmV4dC9kYXRhLycpICYmXG4gICAgaW5mby5wYXRobmFtZS5lbmRzV2l0aCgnLmpzb24nKVxuICApIHtcbiAgICBjb25zdCBwYXRocyA9IGluZm8ucGF0aG5hbWVcbiAgICAgIC5yZXBsYWNlKC9eXFwvX25leHRcXC9kYXRhXFwvLywgJycpXG4gICAgICAucmVwbGFjZSgvXFwuanNvbiQvLCAnJylcbiAgICAgIC5zcGxpdCgnLycpXG5cbiAgICBjb25zdCBidWlsZElkID0gcGF0aHNbMF1cbiAgICBpbmZvLmJ1aWxkSWQgPSBidWlsZElkXG4gICAgcGF0aG5hbWVOb0RhdGFQcmVmaXggPVxuICAgICAgcGF0aHNbMV0gIT09ICdpbmRleCcgPyBgLyR7cGF0aHMuc2xpY2UoMSkuam9pbignLycpfWAgOiAnLydcblxuICAgIC8vIHVwZGF0ZSBwYXRobmFtZSB3aXRoIG5vcm1hbGl6ZWQgaWYgZW5hYmxlZCBhbHRob3VnaFxuICAgIC8vIHdlIHVzZSBub3JtYWxpemVkIHRvIHBvcHVsYXRlIGxvY2FsZSBpbmZvIHN0aWxsXG4gICAgaWYgKG9wdGlvbnMucGFyc2VEYXRhID09PSB0cnVlKSB7XG4gICAgICBpbmZvLnBhdGhuYW1lID0gcGF0aG5hbWVOb0RhdGFQcmVmaXhcbiAgICB9XG4gIH1cblxuICAvLyBJZiBwcm92aWRlZCwgdXNlIHRoZSBsb2NhbGUgcm91dGUgbm9ybWFsaXplciB0byBkZXRlY3QgdGhlIGxvY2FsZSBpbnN0ZWFkXG4gIC8vIG9mIHRoZSBmdW5jdGlvbiBiZWxvdy5cbiAgaWYgKGkxOG4pIHtcbiAgICBsZXQgcmVzdWx0ID0gb3B0aW9ucy5pMThuUHJvdmlkZXJcbiAgICAgID8gb3B0aW9ucy5pMThuUHJvdmlkZXIuYW5hbHl6ZShpbmZvLnBhdGhuYW1lKVxuICAgICAgOiBub3JtYWxpemVMb2NhbGVQYXRoKGluZm8ucGF0aG5hbWUsIGkxOG4ubG9jYWxlcylcblxuICAgIGluZm8ubG9jYWxlID0gcmVzdWx0LmRldGVjdGVkTG9jYWxlXG4gICAgaW5mby5wYXRobmFtZSA9IHJlc3VsdC5wYXRobmFtZSA/PyBpbmZvLnBhdGhuYW1lXG5cbiAgICBpZiAoIXJlc3VsdC5kZXRlY3RlZExvY2FsZSAmJiBpbmZvLmJ1aWxkSWQpIHtcbiAgICAgIHJlc3VsdCA9IG9wdGlvbnMuaTE4blByb3ZpZGVyXG4gICAgICAgID8gb3B0aW9ucy5pMThuUHJvdmlkZXIuYW5hbHl6ZShwYXRobmFtZU5vRGF0YVByZWZpeClcbiAgICAgICAgOiBub3JtYWxpemVMb2NhbGVQYXRoKHBhdGhuYW1lTm9EYXRhUHJlZml4LCBpMThuLmxvY2FsZXMpXG5cbiAgICAgIGlmIChyZXN1bHQuZGV0ZWN0ZWRMb2NhbGUpIHtcbiAgICAgICAgaW5mby5sb2NhbGUgPSByZXN1bHQuZGV0ZWN0ZWRMb2NhbGVcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGluZm9cbn1cbiJdLCJuYW1lcyI6WyJub3JtYWxpemVMb2NhbGVQYXRoIiwicmVtb3ZlUGF0aFByZWZpeCIsInBhdGhIYXNQcmVmaXgiLCJnZXROZXh0UGF0aG5hbWVJbmZvIiwicGF0aG5hbWUiLCJvcHRpb25zIiwiYmFzZVBhdGgiLCJpMThuIiwidHJhaWxpbmdTbGFzaCIsIm5leHRDb25maWciLCJpbmZvIiwiZW5kc1dpdGgiLCJwYXRobmFtZU5vRGF0YVByZWZpeCIsInN0YXJ0c1dpdGgiLCJwYXRocyIsInJlcGxhY2UiLCJzcGxpdCIsImJ1aWxkSWQiLCJzbGljZSIsImpvaW4iLCJwYXJzZURhdGEiLCJyZXN1bHQiLCJpMThuUHJvdmlkZXIiLCJhbmFseXplIiwibG9jYWxlcyIsImxvY2FsZSIsImRldGVjdGVkTG9jYWxlIl0sIm1hcHBpbmdzIjoiOzs7QUFBQSxTQUFTQSxtQkFBbUIsUUFBUSxtQ0FBa0M7QUFDdEUsU0FBU0MsZ0JBQWdCLFFBQVEsdUJBQXNCO0FBQ3ZELFNBQVNDLGFBQWEsUUFBUSxvQkFBbUI7Ozs7QUFrRDFDLFNBQVNDLG9CQUNkQyxRQUFnQixFQUNoQkMsT0FBZ0I7UUFFMEJBO0lBQTFDLE1BQU0sRUFBRUMsUUFBUSxFQUFFQyxJQUFJLEVBQUVDLGFBQWEsRUFBRSxHQUFHSCxDQUFBQSxzQkFBQUEsUUFBUUksVUFBVSxLQUFBLE9BQWxCSixzQkFBc0IsQ0FBQztJQUNqRSxNQUFNSyxPQUF5QjtRQUM3Qk47UUFDQUksZUFBZUosYUFBYSxNQUFNQSxTQUFTTyxRQUFRLENBQUMsT0FBT0g7SUFDN0Q7SUFFQSxJQUFJRixZQUFZSiw4TUFBQUEsRUFBY1EsS0FBS04sUUFBUSxFQUFFRSxXQUFXO1FBQ3RESSxLQUFLTixRQUFRLEdBQUdILG9OQUFBQSxFQUFpQlMsS0FBS04sUUFBUSxFQUFFRTtRQUNoREksS0FBS0osUUFBUSxHQUFHQTtJQUNsQjtJQUNBLElBQUlNLHVCQUF1QkYsS0FBS04sUUFBUTtJQUV4QyxJQUNFTSxLQUFLTixRQUFRLENBQUNTLFVBQVUsQ0FBQyxtQkFDekJILEtBQUtOLFFBQVEsQ0FBQ08sUUFBUSxDQUFDLFVBQ3ZCO1FBQ0EsTUFBTUcsUUFBUUosS0FBS04sUUFBUSxDQUN4QlcsT0FBTyxDQUFDLG9CQUFvQixJQUM1QkEsT0FBTyxDQUFDLFdBQVcsSUFDbkJDLEtBQUssQ0FBQztRQUVULE1BQU1DLFVBQVVILEtBQUssQ0FBQyxFQUFFO1FBQ3hCSixLQUFLTyxPQUFPLEdBQUdBO1FBQ2ZMLHVCQUNFRSxLQUFLLENBQUMsRUFBRSxLQUFLLFVBQVcsTUFBR0EsTUFBTUksS0FBSyxDQUFDLEdBQUdDLElBQUksQ0FBQyxPQUFTO1FBRTFELHNEQUFzRDtRQUN0RCxrREFBa0Q7UUFDbEQsSUFBSWQsUUFBUWUsU0FBUyxLQUFLLE1BQU07WUFDOUJWLEtBQUtOLFFBQVEsR0FBR1E7UUFDbEI7SUFDRjtJQUVBLDRFQUE0RTtJQUM1RSx5QkFBeUI7SUFDekIsSUFBSUwsTUFBTTtRQUNSLElBQUljLFNBQVNoQixRQUFRaUIsWUFBWSxHQUM3QmpCLFFBQVFpQixZQUFZLENBQUNDLE9BQU8sQ0FBQ2IsS0FBS04sUUFBUSw2TEFDMUNKLHNCQUFBQSxFQUFvQlUsS0FBS04sUUFBUSxFQUFFRyxLQUFLaUIsT0FBTztRQUVuRGQsS0FBS2UsTUFBTSxHQUFHSixPQUFPSyxjQUFjO1lBQ25CTDtRQUFoQlgsS0FBS04sUUFBUSxHQUFHaUIsQ0FBQUEsbUJBQUFBLE9BQU9qQixRQUFRLEtBQUEsT0FBZmlCLG1CQUFtQlgsS0FBS04sUUFBUTtRQUVoRCxJQUFJLENBQUNpQixPQUFPSyxjQUFjLElBQUloQixLQUFLTyxPQUFPLEVBQUU7WUFDMUNJLFNBQVNoQixRQUFRaUIsWUFBWSxHQUN6QmpCLFFBQVFpQixZQUFZLENBQUNDLE9BQU8sQ0FBQ1gsaU5BQzdCWixzQkFBQUEsRUFBb0JZLHNCQUFzQkwsS0FBS2lCLE9BQU87WUFFMUQsSUFBSUgsT0FBT0ssY0FBYyxFQUFFO2dCQUN6QmhCLEtBQUtlLE1BQU0sR0FBR0osT0FBT0ssY0FBYztZQUNyQztRQUNGO0lBQ0Y7SUFDQSxPQUFPaEI7QUFDVCIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAyMjk3LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zcmMvc2VydmVyL3dlYi9uZXh0LXVybC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IE91dGdvaW5nSHR0cEhlYWRlcnMgfSBmcm9tICdodHRwJ1xuaW1wb3J0IHR5cGUgeyBEb21haW5Mb2NhbGUsIEkxOE5Db25maWcgfSBmcm9tICcuLi9jb25maWctc2hhcmVkJ1xuaW1wb3J0IHR5cGUgeyBJMThOUHJvdmlkZXIgfSBmcm9tICcuLi9saWIvaTE4bi1wcm92aWRlcidcblxuaW1wb3J0IHsgZGV0ZWN0RG9tYWluTG9jYWxlIH0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi9pMThuL2RldGVjdC1kb21haW4tbG9jYWxlJ1xuaW1wb3J0IHsgZm9ybWF0TmV4dFBhdGhuYW1lSW5mbyB9IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2Zvcm1hdC1uZXh0LXBhdGhuYW1lLWluZm8nXG5pbXBvcnQgeyBnZXRIb3N0bmFtZSB9IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvZ2V0LWhvc3RuYW1lJ1xuaW1wb3J0IHsgZ2V0TmV4dFBhdGhuYW1lSW5mbyB9IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2dldC1uZXh0LXBhdGhuYW1lLWluZm8nXG5cbmludGVyZmFjZSBPcHRpb25zIHtcbiAgYmFzZT86IHN0cmluZyB8IFVSTFxuICBoZWFkZXJzPzogT3V0Z29pbmdIdHRwSGVhZGVyc1xuICBmb3JjZUxvY2FsZT86IGJvb2xlYW5cbiAgbmV4dENvbmZpZz86IHtcbiAgICBiYXNlUGF0aD86IHN0cmluZ1xuICAgIGkxOG4/OiBJMThOQ29uZmlnIHwgbnVsbFxuICAgIHRyYWlsaW5nU2xhc2g/OiBib29sZWFuXG4gIH1cbiAgaTE4blByb3ZpZGVyPzogSTE4TlByb3ZpZGVyXG59XG5cbmNvbnN0IFJFR0VYX0xPQ0FMSE9TVF9IT1NUTkFNRSA9XG4gIC8oPyFeaHR0cHM/OlxcL1xcLykoMTI3KD86XFwuKD86MjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/KSl7M318XFxbOjoxXFxdfGxvY2FsaG9zdCkvXG5cbmZ1bmN0aW9uIHBhcnNlVVJMKHVybDogc3RyaW5nIHwgVVJMLCBiYXNlPzogc3RyaW5nIHwgVVJMKSB7XG4gIHJldHVybiBuZXcgVVJMKFxuICAgIFN0cmluZyh1cmwpLnJlcGxhY2UoUkVHRVhfTE9DQUxIT1NUX0hPU1ROQU1FLCAnbG9jYWxob3N0JyksXG4gICAgYmFzZSAmJiBTdHJpbmcoYmFzZSkucmVwbGFjZShSRUdFWF9MT0NBTEhPU1RfSE9TVE5BTUUsICdsb2NhbGhvc3QnKVxuICApXG59XG5cbmNvbnN0IEludGVybmFsID0gU3ltYm9sKCdOZXh0VVJMSW50ZXJuYWwnKVxuXG5leHBvcnQgY2xhc3MgTmV4dFVSTCB7XG4gIHByaXZhdGUgW0ludGVybmFsXToge1xuICAgIGJhc2VQYXRoOiBzdHJpbmdcbiAgICBidWlsZElkPzogc3RyaW5nXG4gICAgZmxpZ2h0U2VhcmNoUGFyYW1ldGVycz86IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cbiAgICBkZWZhdWx0TG9jYWxlPzogc3RyaW5nXG4gICAgZG9tYWluTG9jYWxlPzogRG9tYWluTG9jYWxlXG4gICAgbG9jYWxlPzogc3RyaW5nXG4gICAgb3B0aW9uczogT3B0aW9uc1xuICAgIHRyYWlsaW5nU2xhc2g/OiBib29sZWFuXG4gICAgdXJsOiBVUkxcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGlucHV0OiBzdHJpbmcgfCBVUkwsIGJhc2U/OiBzdHJpbmcgfCBVUkwsIG9wdHM/OiBPcHRpb25zKVxuICBjb25zdHJ1Y3RvcihpbnB1dDogc3RyaW5nIHwgVVJMLCBvcHRzPzogT3B0aW9ucylcbiAgY29uc3RydWN0b3IoXG4gICAgaW5wdXQ6IHN0cmluZyB8IFVSTCxcbiAgICBiYXNlT3JPcHRzPzogc3RyaW5nIHwgVVJMIHwgT3B0aW9ucyxcbiAgICBvcHRzPzogT3B0aW9uc1xuICApIHtcbiAgICBsZXQgYmFzZTogdW5kZWZpbmVkIHwgc3RyaW5nIHwgVVJMXG4gICAgbGV0IG9wdGlvbnM6IE9wdGlvbnNcblxuICAgIGlmIChcbiAgICAgICh0eXBlb2YgYmFzZU9yT3B0cyA9PT0gJ29iamVjdCcgJiYgJ3BhdGhuYW1lJyBpbiBiYXNlT3JPcHRzKSB8fFxuICAgICAgdHlwZW9mIGJhc2VPck9wdHMgPT09ICdzdHJpbmcnXG4gICAgKSB7XG4gICAgICBiYXNlID0gYmFzZU9yT3B0c1xuICAgICAgb3B0aW9ucyA9IG9wdHMgfHwge31cbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucyA9IG9wdHMgfHwgYmFzZU9yT3B0cyB8fCB7fVxuICAgIH1cblxuICAgIHRoaXNbSW50ZXJuYWxdID0ge1xuICAgICAgdXJsOiBwYXJzZVVSTChpbnB1dCwgYmFzZSA/PyBvcHRpb25zLmJhc2UpLFxuICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgIGJhc2VQYXRoOiAnJyxcbiAgICB9XG5cbiAgICB0aGlzLmFuYWx5emUoKVxuICB9XG5cbiAgcHJpdmF0ZSBhbmFseXplKCkge1xuICAgIGNvbnN0IGluZm8gPSBnZXROZXh0UGF0aG5hbWVJbmZvKHRoaXNbSW50ZXJuYWxdLnVybC5wYXRobmFtZSwge1xuICAgICAgbmV4dENvbmZpZzogdGhpc1tJbnRlcm5hbF0ub3B0aW9ucy5uZXh0Q29uZmlnLFxuICAgICAgcGFyc2VEYXRhOiAhcHJvY2Vzcy5lbnYuX19ORVhUX05PX01JRERMRVdBUkVfVVJMX05PUk1BTElaRSxcbiAgICAgIGkxOG5Qcm92aWRlcjogdGhpc1tJbnRlcm5hbF0ub3B0aW9ucy5pMThuUHJvdmlkZXIsXG4gICAgfSlcblxuICAgIGNvbnN0IGhvc3RuYW1lID0gZ2V0SG9zdG5hbWUoXG4gICAgICB0aGlzW0ludGVybmFsXS51cmwsXG4gICAgICB0aGlzW0ludGVybmFsXS5vcHRpb25zLmhlYWRlcnNcbiAgICApXG4gICAgdGhpc1tJbnRlcm5hbF0uZG9tYWluTG9jYWxlID0gdGhpc1tJbnRlcm5hbF0ub3B0aW9ucy5pMThuUHJvdmlkZXJcbiAgICAgID8gdGhpc1tJbnRlcm5hbF0ub3B0aW9ucy5pMThuUHJvdmlkZXIuZGV0ZWN0RG9tYWluTG9jYWxlKGhvc3RuYW1lKVxuICAgICAgOiBkZXRlY3REb21haW5Mb2NhbGUoXG4gICAgICAgICAgdGhpc1tJbnRlcm5hbF0ub3B0aW9ucy5uZXh0Q29uZmlnPy5pMThuPy5kb21haW5zLFxuICAgICAgICAgIGhvc3RuYW1lXG4gICAgICAgIClcblxuICAgIGNvbnN0IGRlZmF1bHRMb2NhbGUgPVxuICAgICAgdGhpc1tJbnRlcm5hbF0uZG9tYWluTG9jYWxlPy5kZWZhdWx0TG9jYWxlIHx8XG4gICAgICB0aGlzW0ludGVybmFsXS5vcHRpb25zLm5leHRDb25maWc/LmkxOG4/LmRlZmF1bHRMb2NhbGVcblxuICAgIHRoaXNbSW50ZXJuYWxdLnVybC5wYXRobmFtZSA9IGluZm8ucGF0aG5hbWVcbiAgICB0aGlzW0ludGVybmFsXS5kZWZhdWx0TG9jYWxlID0gZGVmYXVsdExvY2FsZVxuICAgIHRoaXNbSW50ZXJuYWxdLmJhc2VQYXRoID0gaW5mby5iYXNlUGF0aCA/PyAnJ1xuICAgIHRoaXNbSW50ZXJuYWxdLmJ1aWxkSWQgPSBpbmZvLmJ1aWxkSWRcbiAgICB0aGlzW0ludGVybmFsXS5sb2NhbGUgPSBpbmZvLmxvY2FsZSA/PyBkZWZhdWx0TG9jYWxlXG4gICAgdGhpc1tJbnRlcm5hbF0udHJhaWxpbmdTbGFzaCA9IGluZm8udHJhaWxpbmdTbGFzaFxuICB9XG5cbiAgcHJpdmF0ZSBmb3JtYXRQYXRobmFtZSgpIHtcbiAgICByZXR1cm4gZm9ybWF0TmV4dFBhdGhuYW1lSW5mbyh7XG4gICAgICBiYXNlUGF0aDogdGhpc1tJbnRlcm5hbF0uYmFzZVBhdGgsXG4gICAgICBidWlsZElkOiB0aGlzW0ludGVybmFsXS5idWlsZElkLFxuICAgICAgZGVmYXVsdExvY2FsZTogIXRoaXNbSW50ZXJuYWxdLm9wdGlvbnMuZm9yY2VMb2NhbGVcbiAgICAgICAgPyB0aGlzW0ludGVybmFsXS5kZWZhdWx0TG9jYWxlXG4gICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgbG9jYWxlOiB0aGlzW0ludGVybmFsXS5sb2NhbGUsXG4gICAgICBwYXRobmFtZTogdGhpc1tJbnRlcm5hbF0udXJsLnBhdGhuYW1lLFxuICAgICAgdHJhaWxpbmdTbGFzaDogdGhpc1tJbnRlcm5hbF0udHJhaWxpbmdTbGFzaCxcbiAgICB9KVxuICB9XG5cbiAgcHJpdmF0ZSBmb3JtYXRTZWFyY2goKSB7XG4gICAgcmV0dXJuIHRoaXNbSW50ZXJuYWxdLnVybC5zZWFyY2hcbiAgfVxuXG4gIHB1YmxpYyBnZXQgYnVpbGRJZCgpIHtcbiAgICByZXR1cm4gdGhpc1tJbnRlcm5hbF0uYnVpbGRJZFxuICB9XG5cbiAgcHVibGljIHNldCBidWlsZElkKGJ1aWxkSWQ6IHN0cmluZyB8IHVuZGVmaW5lZCkge1xuICAgIHRoaXNbSW50ZXJuYWxdLmJ1aWxkSWQgPSBidWlsZElkXG4gIH1cblxuICBwdWJsaWMgZ2V0IGxvY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpc1tJbnRlcm5hbF0ubG9jYWxlID8/ICcnXG4gIH1cblxuICBwdWJsaWMgc2V0IGxvY2FsZShsb2NhbGU6IHN0cmluZykge1xuICAgIGlmIChcbiAgICAgICF0aGlzW0ludGVybmFsXS5sb2NhbGUgfHxcbiAgICAgICF0aGlzW0ludGVybmFsXS5vcHRpb25zLm5leHRDb25maWc/LmkxOG4/LmxvY2FsZXMuaW5jbHVkZXMobG9jYWxlKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgYFRoZSBOZXh0VVJMIGNvbmZpZ3VyYXRpb24gaW5jbHVkZXMgbm8gbG9jYWxlIFwiJHtsb2NhbGV9XCJgXG4gICAgICApXG4gICAgfVxuXG4gICAgdGhpc1tJbnRlcm5hbF0ubG9jYWxlID0gbG9jYWxlXG4gIH1cblxuICBnZXQgZGVmYXVsdExvY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpc1tJbnRlcm5hbF0uZGVmYXVsdExvY2FsZVxuICB9XG5cbiAgZ2V0IGRvbWFpbkxvY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpc1tJbnRlcm5hbF0uZG9tYWluTG9jYWxlXG4gIH1cblxuICBnZXQgc2VhcmNoUGFyYW1zKCkge1xuICAgIHJldHVybiB0aGlzW0ludGVybmFsXS51cmwuc2VhcmNoUGFyYW1zXG4gIH1cblxuICBnZXQgaG9zdCgpIHtcbiAgICByZXR1cm4gdGhpc1tJbnRlcm5hbF0udXJsLmhvc3RcbiAgfVxuXG4gIHNldCBob3N0KHZhbHVlOiBzdHJpbmcpIHtcbiAgICB0aGlzW0ludGVybmFsXS51cmwuaG9zdCA9IHZhbHVlXG4gIH1cblxuICBnZXQgaG9zdG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXNbSW50ZXJuYWxdLnVybC5ob3N0bmFtZVxuICB9XG5cbiAgc2V0IGhvc3RuYW1lKHZhbHVlOiBzdHJpbmcpIHtcbiAgICB0aGlzW0ludGVybmFsXS51cmwuaG9zdG5hbWUgPSB2YWx1ZVxuICB9XG5cbiAgZ2V0IHBvcnQoKSB7XG4gICAgcmV0dXJuIHRoaXNbSW50ZXJuYWxdLnVybC5wb3J0XG4gIH1cblxuICBzZXQgcG9ydCh2YWx1ZTogc3RyaW5nKSB7XG4gICAgdGhpc1tJbnRlcm5hbF0udXJsLnBvcnQgPSB2YWx1ZVxuICB9XG5cbiAgZ2V0IHByb3RvY29sKCkge1xuICAgIHJldHVybiB0aGlzW0ludGVybmFsXS51cmwucHJvdG9jb2xcbiAgfVxuXG4gIHNldCBwcm90b2NvbCh2YWx1ZTogc3RyaW5nKSB7XG4gICAgdGhpc1tJbnRlcm5hbF0udXJsLnByb3RvY29sID0gdmFsdWVcbiAgfVxuXG4gIGdldCBocmVmKCkge1xuICAgIGNvbnN0IHBhdGhuYW1lID0gdGhpcy5mb3JtYXRQYXRobmFtZSgpXG4gICAgY29uc3Qgc2VhcmNoID0gdGhpcy5mb3JtYXRTZWFyY2goKVxuICAgIHJldHVybiBgJHt0aGlzLnByb3RvY29sfS8vJHt0aGlzLmhvc3R9JHtwYXRobmFtZX0ke3NlYXJjaH0ke3RoaXMuaGFzaH1gXG4gIH1cblxuICBzZXQgaHJlZih1cmw6IHN0cmluZykge1xuICAgIHRoaXNbSW50ZXJuYWxdLnVybCA9IHBhcnNlVVJMKHVybClcbiAgICB0aGlzLmFuYWx5emUoKVxuICB9XG5cbiAgZ2V0IG9yaWdpbigpIHtcbiAgICByZXR1cm4gdGhpc1tJbnRlcm5hbF0udXJsLm9yaWdpblxuICB9XG5cbiAgZ2V0IHBhdGhuYW1lKCkge1xuICAgIHJldHVybiB0aGlzW0ludGVybmFsXS51cmwucGF0aG5hbWVcbiAgfVxuXG4gIHNldCBwYXRobmFtZSh2YWx1ZTogc3RyaW5nKSB7XG4gICAgdGhpc1tJbnRlcm5hbF0udXJsLnBhdGhuYW1lID0gdmFsdWVcbiAgfVxuXG4gIGdldCBoYXNoKCkge1xuICAgIHJldHVybiB0aGlzW0ludGVybmFsXS51cmwuaGFzaFxuICB9XG5cbiAgc2V0IGhhc2godmFsdWU6IHN0cmluZykge1xuICAgIHRoaXNbSW50ZXJuYWxdLnVybC5oYXNoID0gdmFsdWVcbiAgfVxuXG4gIGdldCBzZWFyY2goKSB7XG4gICAgcmV0dXJuIHRoaXNbSW50ZXJuYWxdLnVybC5zZWFyY2hcbiAgfVxuXG4gIHNldCBzZWFyY2godmFsdWU6IHN0cmluZykge1xuICAgIHRoaXNbSW50ZXJuYWxdLnVybC5zZWFyY2ggPSB2YWx1ZVxuICB9XG5cbiAgZ2V0IHBhc3N3b3JkKCkge1xuICAgIHJldHVybiB0aGlzW0ludGVybmFsXS51cmwucGFzc3dvcmRcbiAgfVxuXG4gIHNldCBwYXNzd29yZCh2YWx1ZTogc3RyaW5nKSB7XG4gICAgdGhpc1tJbnRlcm5hbF0udXJsLnBhc3N3b3JkID0gdmFsdWVcbiAgfVxuXG4gIGdldCB1c2VybmFtZSgpIHtcbiAgICByZXR1cm4gdGhpc1tJbnRlcm5hbF0udXJsLnVzZXJuYW1lXG4gIH1cblxuICBzZXQgdXNlcm5hbWUodmFsdWU6IHN0cmluZykge1xuICAgIHRoaXNbSW50ZXJuYWxdLnVybC51c2VybmFtZSA9IHZhbHVlXG4gIH1cblxuICBnZXQgYmFzZVBhdGgoKSB7XG4gICAgcmV0dXJuIHRoaXNbSW50ZXJuYWxdLmJhc2VQYXRoXG4gIH1cblxuICBzZXQgYmFzZVBhdGgodmFsdWU6IHN0cmluZykge1xuICAgIHRoaXNbSW50ZXJuYWxdLmJhc2VQYXRoID0gdmFsdWUuc3RhcnRzV2l0aCgnLycpID8gdmFsdWUgOiBgLyR7dmFsdWV9YFxuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuaHJlZlxuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLmhyZWZcbiAgfVxuXG4gIFtTeW1ib2wuZm9yKCdlZGdlLXJ1bnRpbWUuaW5zcGVjdC5jdXN0b20nKV0oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhyZWY6IHRoaXMuaHJlZixcbiAgICAgIG9yaWdpbjogdGhpcy5vcmlnaW4sXG4gICAgICBwcm90b2NvbDogdGhpcy5wcm90b2NvbCxcbiAgICAgIHVzZXJuYW1lOiB0aGlzLnVzZXJuYW1lLFxuICAgICAgcGFzc3dvcmQ6IHRoaXMucGFzc3dvcmQsXG4gICAgICBob3N0OiB0aGlzLmhvc3QsXG4gICAgICBob3N0bmFtZTogdGhpcy5ob3N0bmFtZSxcbiAgICAgIHBvcnQ6IHRoaXMucG9ydCxcbiAgICAgIHBhdGhuYW1lOiB0aGlzLnBhdGhuYW1lLFxuICAgICAgc2VhcmNoOiB0aGlzLnNlYXJjaCxcbiAgICAgIHNlYXJjaFBhcmFtczogdGhpcy5zZWFyY2hQYXJhbXMsXG4gICAgICBoYXNoOiB0aGlzLmhhc2gsXG4gICAgfVxuICB9XG5cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBOZXh0VVJMKFN0cmluZyh0aGlzKSwgdGhpc1tJbnRlcm5hbF0ub3B0aW9ucylcbiAgfVxufVxuIl0sIm5hbWVzIjpbImRldGVjdERvbWFpbkxvY2FsZSIsImZvcm1hdE5leHRQYXRobmFtZUluZm8iLCJnZXRIb3N0bmFtZSIsImdldE5leHRQYXRobmFtZUluZm8iLCJSRUdFWF9MT0NBTEhPU1RfSE9TVE5BTUUiLCJwYXJzZVVSTCIsInVybCIsImJhc2UiLCJVUkwiLCJTdHJpbmciLCJyZXBsYWNlIiwiSW50ZXJuYWwiLCJTeW1ib2wiLCJOZXh0VVJMIiwiY29uc3RydWN0b3IiLCJpbnB1dCIsImJhc2VPck9wdHMiLCJvcHRzIiwib3B0aW9ucyIsImJhc2VQYXRoIiwiYW5hbHl6ZSIsImluZm8iLCJwYXRobmFtZSIsIm5leHRDb25maWciLCJwYXJzZURhdGEiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX05PX01JRERMRVdBUkVfVVJMX05PUk1BTElaRSIsImkxOG5Qcm92aWRlciIsImhvc3RuYW1lIiwiaGVhZGVycyIsImRvbWFpbkxvY2FsZSIsImkxOG4iLCJkb21haW5zIiwiZGVmYXVsdExvY2FsZSIsImJ1aWxkSWQiLCJsb2NhbGUiLCJ0cmFpbGluZ1NsYXNoIiwiZm9ybWF0UGF0aG5hbWUiLCJmb3JjZUxvY2FsZSIsInVuZGVmaW5lZCIsImZvcm1hdFNlYXJjaCIsInNlYXJjaCIsImxvY2FsZXMiLCJpbmNsdWRlcyIsIlR5cGVFcnJvciIsInNlYXJjaFBhcmFtcyIsImhvc3QiLCJ2YWx1ZSIsInBvcnQiLCJwcm90b2NvbCIsImhyZWYiLCJoYXNoIiwib3JpZ2luIiwicGFzc3dvcmQiLCJ1c2VybmFtZSIsInN0YXJ0c1dpdGgiLCJ0b1N0cmluZyIsInRvSlNPTiIsImZvciIsImNsb25lIl0sIm1hcHBpbmdzIjoiOzs7QUFJQSxTQUFTQSxrQkFBa0IsUUFBUSw2Q0FBNEM7QUFDL0UsU0FBU0Msc0JBQXNCLFFBQVEsMERBQXlEO0FBQ2hHLFNBQVNDLFdBQVcsUUFBUSxnQ0FBK0I7QUFDM0QsU0FBU0MsbUJBQW1CLFFBQVEsdURBQXNEOzs7OztBQWMxRixNQUFNQywyQkFDSjtBQUVGLFNBQVNDLFNBQVNDLEdBQWlCLEVBQUVDLElBQW1CO0lBQ3RELE9BQU8sSUFBSUMsSUFDVEMsT0FBT0gsS0FBS0ksT0FBTyxDQUFDTiwwQkFBMEIsY0FDOUNHLFFBQVFFLE9BQU9GLE1BQU1HLE9BQU8sQ0FBQ04sMEJBQTBCO0FBRTNEO0FBRUEsTUFBTU8sV0FBV0MsT0FBTztBQUVqQixNQUFNQztJQWVYQyxZQUNFQyxLQUFtQixFQUNuQkMsVUFBbUMsRUFDbkNDLElBQWMsQ0FDZDtRQUNBLElBQUlWO1FBQ0osSUFBSVc7UUFFSixJQUNHLE9BQU9GLGVBQWUsWUFBWSxjQUFjQSxjQUNqRCxPQUFPQSxlQUFlLFVBQ3RCO1lBQ0FULE9BQU9TO1lBQ1BFLFVBQVVELFFBQVEsQ0FBQztRQUNyQixPQUFPO1lBQ0xDLFVBQVVELFFBQVFELGNBQWMsQ0FBQztRQUNuQztRQUVBLElBQUksQ0FBQ0wsU0FBUyxHQUFHO1lBQ2ZMLEtBQUtELFNBQVNVLE9BQU9SLFFBQVFXLFFBQVFYLElBQUk7WUFDekNXLFNBQVNBO1lBQ1RDLFVBQVU7UUFDWjtRQUVBLElBQUksQ0FBQ0MsT0FBTztJQUNkO0lBRVFBLFVBQVU7WUFjVix3Q0FBQSxtQ0FLSiw2QkFDQSx5Q0FBQTtRQW5CRixNQUFNQywrTUFBT2xCLHNCQUFBQSxFQUFvQixJQUFJLENBQUNRLFNBQVMsQ0FBQ0wsR0FBRyxDQUFDZ0IsUUFBUSxFQUFFO1lBQzVEQyxZQUFZLElBQUksQ0FBQ1osU0FBUyxDQUFDTyxPQUFPLENBQUNLLFVBQVU7WUFDN0NDLFdBQVcsQ0FBQ0MsUUFBUUMsR0FBRyxDQUFDQyxrQ0FBa0M7WUFDMURDLGNBQWMsSUFBSSxDQUFDakIsU0FBUyxDQUFDTyxPQUFPLENBQUNVLFlBQVk7UUFDbkQ7UUFFQSxNQUFNQyxXQUFXM0IsbUxBQUFBLEVBQ2YsSUFBSSxDQUFDUyxTQUFTLENBQUNMLEdBQUcsRUFDbEIsSUFBSSxDQUFDSyxTQUFTLENBQUNPLE9BQU8sQ0FBQ1ksT0FBTztRQUVoQyxJQUFJLENBQUNuQixTQUFTLENBQUNvQixZQUFZLEdBQUcsSUFBSSxDQUFDcEIsU0FBUyxDQUFDTyxPQUFPLENBQUNVLFlBQVksR0FDN0QsSUFBSSxDQUFDakIsU0FBUyxDQUFDTyxPQUFPLENBQUNVLFlBQVksQ0FBQzVCLGtCQUFrQixDQUFDNkIsb01BQ3ZEN0IscUJBQUFBLEVBQUFBLENBQ0Usb0NBQUEsSUFBSSxDQUFDVyxTQUFTLENBQUNPLE9BQU8sQ0FBQ0ssVUFBVSxLQUFBLE9BQUEsS0FBQSxJQUFBLENBQWpDLHlDQUFBLGtDQUFtQ1MsSUFBSSxLQUFBLE9BQUEsS0FBQSxJQUF2Qyx1Q0FBeUNDLE9BQU8sRUFDaERKO1FBR04sTUFBTUssZ0JBQ0osQ0FBQSxDQUFBLDhCQUFBLElBQUksQ0FBQ3ZCLFNBQVMsQ0FBQ29CLFlBQVksS0FBQSxPQUFBLEtBQUEsSUFBM0IsNEJBQTZCRyxhQUFhLEtBQUEsQ0FBQSxDQUMxQyxxQ0FBQSxJQUFJLENBQUN2QixTQUFTLENBQUNPLE9BQU8sQ0FBQ0ssVUFBVSxLQUFBLE9BQUEsS0FBQSxJQUFBLENBQWpDLDBDQUFBLG1DQUFtQ1MsSUFBSSxLQUFBLE9BQUEsS0FBQSxJQUF2Qyx3Q0FBeUNFLGFBQWE7UUFFeEQsSUFBSSxDQUFDdkIsU0FBUyxDQUFDTCxHQUFHLENBQUNnQixRQUFRLEdBQUdELEtBQUtDLFFBQVE7UUFDM0MsSUFBSSxDQUFDWCxTQUFTLENBQUN1QixhQUFhLEdBQUdBO1FBQy9CLElBQUksQ0FBQ3ZCLFNBQVMsQ0FBQ1EsUUFBUSxHQUFHRSxLQUFLRixRQUFRLElBQUk7UUFDM0MsSUFBSSxDQUFDUixTQUFTLENBQUN3QixPQUFPLEdBQUdkLEtBQUtjLE9BQU87UUFDckMsSUFBSSxDQUFDeEIsU0FBUyxDQUFDeUIsTUFBTSxHQUFHZixLQUFLZSxNQUFNLElBQUlGO1FBQ3ZDLElBQUksQ0FBQ3ZCLFNBQVMsQ0FBQzBCLGFBQWEsR0FBR2hCLEtBQUtnQixhQUFhO0lBQ25EO0lBRVFDLGlCQUFpQjtRQUN2QixrTkFBT3JDLHlCQUFBQSxFQUF1QjtZQUM1QmtCLFVBQVUsSUFBSSxDQUFDUixTQUFTLENBQUNRLFFBQVE7WUFDakNnQixTQUFTLElBQUksQ0FBQ3hCLFNBQVMsQ0FBQ3dCLE9BQU87WUFDL0JELGVBQWUsQ0FBQyxJQUFJLENBQUN2QixTQUFTLENBQUNPLE9BQU8sQ0FBQ3FCLFdBQVcsR0FDOUMsSUFBSSxDQUFDNUIsU0FBUyxDQUFDdUIsYUFBYSxHQUM1Qk07WUFDSkosUUFBUSxJQUFJLENBQUN6QixTQUFTLENBQUN5QixNQUFNO1lBQzdCZCxVQUFVLElBQUksQ0FBQ1gsU0FBUyxDQUFDTCxHQUFHLENBQUNnQixRQUFRO1lBQ3JDZSxlQUFlLElBQUksQ0FBQzFCLFNBQVMsQ0FBQzBCLGFBQWE7UUFDN0M7SUFDRjtJQUVRSSxlQUFlO1FBQ3JCLE9BQU8sSUFBSSxDQUFDOUIsU0FBUyxDQUFDTCxHQUFHLENBQUNvQyxNQUFNO0lBQ2xDO0lBRUEsSUFBV1AsVUFBVTtRQUNuQixPQUFPLElBQUksQ0FBQ3hCLFNBQVMsQ0FBQ3dCLE9BQU87SUFDL0I7SUFFQSxJQUFXQSxRQUFRQSxPQUEyQixFQUFFO1FBQzlDLElBQUksQ0FBQ3hCLFNBQVMsQ0FBQ3dCLE9BQU8sR0FBR0E7SUFDM0I7SUFFQSxJQUFXQyxTQUFTO1FBQ2xCLE9BQU8sSUFBSSxDQUFDekIsU0FBUyxDQUFDeUIsTUFBTSxJQUFJO0lBQ2xDO0lBRUEsSUFBV0EsT0FBT0EsTUFBYyxFQUFFO1lBRzdCLHdDQUFBO1FBRkgsSUFDRSxDQUFDLElBQUksQ0FBQ3pCLFNBQVMsQ0FBQ3lCLE1BQU0sSUFDdEIsQ0FBQSxDQUFBLENBQUMsb0NBQUEsSUFBSSxDQUFDekIsU0FBUyxDQUFDTyxPQUFPLENBQUNLLFVBQVUsS0FBQSxPQUFBLEtBQUEsSUFBQSxDQUFqQyx5Q0FBQSxrQ0FBbUNTLElBQUksS0FBQSxPQUFBLEtBQUEsSUFBdkMsdUNBQXlDVyxPQUFPLENBQUNDLFFBQVEsQ0FBQ1IsT0FBQUEsR0FDM0Q7WUFDQSxNQUFNLE9BQUEsY0FFTCxDQUZLLElBQUlTLFVBQ1IsQ0FBQyw4Q0FBOEMsRUFBRVQsT0FBTyxDQUFDLENBQUMsR0FEdEQscUJBQUE7dUJBQUE7NEJBQUE7OEJBQUE7WUFFTjtRQUNGO1FBRUEsSUFBSSxDQUFDekIsU0FBUyxDQUFDeUIsTUFBTSxHQUFHQTtJQUMxQjtJQUVBLElBQUlGLGdCQUFnQjtRQUNsQixPQUFPLElBQUksQ0FBQ3ZCLFNBQVMsQ0FBQ3VCLGFBQWE7SUFDckM7SUFFQSxJQUFJSCxlQUFlO1FBQ2pCLE9BQU8sSUFBSSxDQUFDcEIsU0FBUyxDQUFDb0IsWUFBWTtJQUNwQztJQUVBLElBQUllLGVBQWU7UUFDakIsT0FBTyxJQUFJLENBQUNuQyxTQUFTLENBQUNMLEdBQUcsQ0FBQ3dDLFlBQVk7SUFDeEM7SUFFQSxJQUFJQyxPQUFPO1FBQ1QsT0FBTyxJQUFJLENBQUNwQyxTQUFTLENBQUNMLEdBQUcsQ0FBQ3lDLElBQUk7SUFDaEM7SUFFQSxJQUFJQSxLQUFLQyxLQUFhLEVBQUU7UUFDdEIsSUFBSSxDQUFDckMsU0FBUyxDQUFDTCxHQUFHLENBQUN5QyxJQUFJLEdBQUdDO0lBQzVCO0lBRUEsSUFBSW5CLFdBQVc7UUFDYixPQUFPLElBQUksQ0FBQ2xCLFNBQVMsQ0FBQ0wsR0FBRyxDQUFDdUIsUUFBUTtJQUNwQztJQUVBLElBQUlBLFNBQVNtQixLQUFhLEVBQUU7UUFDMUIsSUFBSSxDQUFDckMsU0FBUyxDQUFDTCxHQUFHLENBQUN1QixRQUFRLEdBQUdtQjtJQUNoQztJQUVBLElBQUlDLE9BQU87UUFDVCxPQUFPLElBQUksQ0FBQ3RDLFNBQVMsQ0FBQ0wsR0FBRyxDQUFDMkMsSUFBSTtJQUNoQztJQUVBLElBQUlBLEtBQUtELEtBQWEsRUFBRTtRQUN0QixJQUFJLENBQUNyQyxTQUFTLENBQUNMLEdBQUcsQ0FBQzJDLElBQUksR0FBR0Q7SUFDNUI7SUFFQSxJQUFJRSxXQUFXO1FBQ2IsT0FBTyxJQUFJLENBQUN2QyxTQUFTLENBQUNMLEdBQUcsQ0FBQzRDLFFBQVE7SUFDcEM7SUFFQSxJQUFJQSxTQUFTRixLQUFhLEVBQUU7UUFDMUIsSUFBSSxDQUFDckMsU0FBUyxDQUFDTCxHQUFHLENBQUM0QyxRQUFRLEdBQUdGO0lBQ2hDO0lBRUEsSUFBSUcsT0FBTztRQUNULE1BQU03QixXQUFXLElBQUksQ0FBQ2dCLGNBQWM7UUFDcEMsTUFBTUksU0FBUyxJQUFJLENBQUNELFlBQVk7UUFDaEMsT0FBTyxHQUFHLElBQUksQ0FBQ1MsUUFBUSxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUNILElBQUksR0FBR3pCLFdBQVdvQixTQUFTLElBQUksQ0FBQ1UsSUFBSSxFQUFFO0lBQ3pFO0lBRUEsSUFBSUQsS0FBSzdDLEdBQVcsRUFBRTtRQUNwQixJQUFJLENBQUNLLFNBQVMsQ0FBQ0wsR0FBRyxHQUFHRCxTQUFTQztRQUM5QixJQUFJLENBQUNjLE9BQU87SUFDZDtJQUVBLElBQUlpQyxTQUFTO1FBQ1gsT0FBTyxJQUFJLENBQUMxQyxTQUFTLENBQUNMLEdBQUcsQ0FBQytDLE1BQU07SUFDbEM7SUFFQSxJQUFJL0IsV0FBVztRQUNiLE9BQU8sSUFBSSxDQUFDWCxTQUFTLENBQUNMLEdBQUcsQ0FBQ2dCLFFBQVE7SUFDcEM7SUFFQSxJQUFJQSxTQUFTMEIsS0FBYSxFQUFFO1FBQzFCLElBQUksQ0FBQ3JDLFNBQVMsQ0FBQ0wsR0FBRyxDQUFDZ0IsUUFBUSxHQUFHMEI7SUFDaEM7SUFFQSxJQUFJSSxPQUFPO1FBQ1QsT0FBTyxJQUFJLENBQUN6QyxTQUFTLENBQUNMLEdBQUcsQ0FBQzhDLElBQUk7SUFDaEM7SUFFQSxJQUFJQSxLQUFLSixLQUFhLEVBQUU7UUFDdEIsSUFBSSxDQUFDckMsU0FBUyxDQUFDTCxHQUFHLENBQUM4QyxJQUFJLEdBQUdKO0lBQzVCO0lBRUEsSUFBSU4sU0FBUztRQUNYLE9BQU8sSUFBSSxDQUFDL0IsU0FBUyxDQUFDTCxHQUFHLENBQUNvQyxNQUFNO0lBQ2xDO0lBRUEsSUFBSUEsT0FBT00sS0FBYSxFQUFFO1FBQ3hCLElBQUksQ0FBQ3JDLFNBQVMsQ0FBQ0wsR0FBRyxDQUFDb0MsTUFBTSxHQUFHTTtJQUM5QjtJQUVBLElBQUlNLFdBQVc7UUFDYixPQUFPLElBQUksQ0FBQzNDLFNBQVMsQ0FBQ0wsR0FBRyxDQUFDZ0QsUUFBUTtJQUNwQztJQUVBLElBQUlBLFNBQVNOLEtBQWEsRUFBRTtRQUMxQixJQUFJLENBQUNyQyxTQUFTLENBQUNMLEdBQUcsQ0FBQ2dELFFBQVEsR0FBR047SUFDaEM7SUFFQSxJQUFJTyxXQUFXO1FBQ2IsT0FBTyxJQUFJLENBQUM1QyxTQUFTLENBQUNMLEdBQUcsQ0FBQ2lELFFBQVE7SUFDcEM7SUFFQSxJQUFJQSxTQUFTUCxLQUFhLEVBQUU7UUFDMUIsSUFBSSxDQUFDckMsU0FBUyxDQUFDTCxHQUFHLENBQUNpRCxRQUFRLEdBQUdQO0lBQ2hDO0lBRUEsSUFBSTdCLFdBQVc7UUFDYixPQUFPLElBQUksQ0FBQ1IsU0FBUyxDQUFDUSxRQUFRO0lBQ2hDO0lBRUEsSUFBSUEsU0FBUzZCLEtBQWEsRUFBRTtRQUMxQixJQUFJLENBQUNyQyxTQUFTLENBQUNRLFFBQVEsR0FBRzZCLE1BQU1RLFVBQVUsQ0FBQyxPQUFPUixRQUFRLENBQUMsQ0FBQyxFQUFFQSxPQUFPO0lBQ3ZFO0lBRUFTLFdBQVc7UUFDVCxPQUFPLElBQUksQ0FBQ04sSUFBSTtJQUNsQjtJQUVBTyxTQUFTO1FBQ1AsT0FBTyxJQUFJLENBQUNQLElBQUk7SUFDbEI7SUFFQSxDQUFDdkMsT0FBTytDLEdBQUcsQ0FBQywrQkFBK0IsR0FBRztRQUM1QyxPQUFPO1lBQ0xSLE1BQU0sSUFBSSxDQUFDQSxJQUFJO1lBQ2ZFLFFBQVEsSUFBSSxDQUFDQSxNQUFNO1lBQ25CSCxVQUFVLElBQUksQ0FBQ0EsUUFBUTtZQUN2QkssVUFBVSxJQUFJLENBQUNBLFFBQVE7WUFDdkJELFVBQVUsSUFBSSxDQUFDQSxRQUFRO1lBQ3ZCUCxNQUFNLElBQUksQ0FBQ0EsSUFBSTtZQUNmbEIsVUFBVSxJQUFJLENBQUNBLFFBQVE7WUFDdkJvQixNQUFNLElBQUksQ0FBQ0EsSUFBSTtZQUNmM0IsVUFBVSxJQUFJLENBQUNBLFFBQVE7WUFDdkJvQixRQUFRLElBQUksQ0FBQ0EsTUFBTTtZQUNuQkksY0FBYyxJQUFJLENBQUNBLFlBQVk7WUFDL0JNLE1BQU0sSUFBSSxDQUFDQSxJQUFJO1FBQ2pCO0lBQ0Y7SUFFQVEsUUFBUTtRQUNOLE9BQU8sSUFBSS9DLFFBQVFKLE9BQU8sSUFBSSxHQUFHLElBQUksQ0FBQ0UsU0FBUyxDQUFDTyxPQUFPO0lBQ3pEO0FBQ0YiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMjQ5MSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL3NlcnZlci93ZWIvZXJyb3IudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNsYXNzIFBhZ2VTaWduYXR1cmVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoeyBwYWdlIH06IHsgcGFnZTogc3RyaW5nIH0pIHtcbiAgICBzdXBlcihgVGhlIG1pZGRsZXdhcmUgXCIke3BhZ2V9XCIgYWNjZXB0cyBhbiBhc3luYyBBUEkgZGlyZWN0bHkgd2l0aCB0aGUgZm9ybTpcbiAgXG4gIGV4cG9ydCBmdW5jdGlvbiBtaWRkbGV3YXJlKHJlcXVlc3QsIGV2ZW50KSB7XG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5yZWRpcmVjdCgnL25ldy1sb2NhdGlvbicpXG4gIH1cbiAgXG4gIFJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbWlkZGxld2FyZS1uZXctc2lnbmF0dXJlXG4gIGApXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFJlbW92ZWRQYWdlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKGBUaGUgcmVxdWVzdC5wYWdlIGhhcyBiZWVuIGRlcHJlY2F0ZWQgaW4gZmF2b3VyIG9mIFxcYFVSTFBhdHRlcm5cXGAuXG4gIFJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbWlkZGxld2FyZS1yZXF1ZXN0LXBhZ2VcbiAgYClcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgUmVtb3ZlZFVBRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKGBUaGUgcmVxdWVzdC51YSBoYXMgYmVlbiByZW1vdmVkIGluIGZhdm91ciBvZiBcXGB1c2VyQWdlbnRcXGAgZnVuY3Rpb24uXG4gIFJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbWlkZGxld2FyZS1wYXJzZS11c2VyLWFnZW50XG4gIGApXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJQYWdlU2lnbmF0dXJlRXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwicGFnZSIsIlJlbW92ZWRQYWdlRXJyb3IiLCJSZW1vdmVkVUFFcnJvciJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTyxNQUFNQSwyQkFBMkJDO0lBQ3RDQyxZQUFZLEVBQUVDLElBQUksRUFBb0IsQ0FBRTtRQUN0QyxLQUFLLENBQUMsQ0FBQyxnQkFBZ0IsRUFBRUEsS0FBSzs7Ozs7OztFQU9oQyxDQUFDO0lBQ0Q7QUFDRjtBQUVPLE1BQU1DLHlCQUF5Qkg7SUFDcENDLGFBQWM7UUFDWixLQUFLLENBQUMsQ0FBQzs7RUFFVCxDQUFDO0lBQ0Q7QUFDRjtBQUVPLE1BQU1HLHVCQUF1Qko7SUFDbENDLGFBQWM7UUFDWixLQUFLLENBQUMsQ0FBQzs7RUFFVCxDQUFDO0lBQ0Q7QUFDRiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAyNTI4LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC8lNDBlZGdlLXJ1bnRpbWUvY29va2llcy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG5cbi8vIHNyYy9pbmRleC50c1xudmFyIHNyY19leHBvcnRzID0ge307XG5fX2V4cG9ydChzcmNfZXhwb3J0cywge1xuICBSZXF1ZXN0Q29va2llczogKCkgPT4gUmVxdWVzdENvb2tpZXMsXG4gIFJlc3BvbnNlQ29va2llczogKCkgPT4gUmVzcG9uc2VDb29raWVzLFxuICBwYXJzZUNvb2tpZTogKCkgPT4gcGFyc2VDb29raWUsXG4gIHBhcnNlU2V0Q29va2llOiAoKSA9PiBwYXJzZVNldENvb2tpZSxcbiAgc3RyaW5naWZ5Q29va2llOiAoKSA9PiBzdHJpbmdpZnlDb29raWVcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlMoc3JjX2V4cG9ydHMpO1xuXG4vLyBzcmMvc2VyaWFsaXplLnRzXG5mdW5jdGlvbiBzdHJpbmdpZnlDb29raWUoYykge1xuICB2YXIgX2E7XG4gIGNvbnN0IGF0dHJzID0gW1xuICAgIFwicGF0aFwiIGluIGMgJiYgYy5wYXRoICYmIGBQYXRoPSR7Yy5wYXRofWAsXG4gICAgXCJleHBpcmVzXCIgaW4gYyAmJiAoYy5leHBpcmVzIHx8IGMuZXhwaXJlcyA9PT0gMCkgJiYgYEV4cGlyZXM9JHsodHlwZW9mIGMuZXhwaXJlcyA9PT0gXCJudW1iZXJcIiA/IG5ldyBEYXRlKGMuZXhwaXJlcykgOiBjLmV4cGlyZXMpLnRvVVRDU3RyaW5nKCl9YCxcbiAgICBcIm1heEFnZVwiIGluIGMgJiYgdHlwZW9mIGMubWF4QWdlID09PSBcIm51bWJlclwiICYmIGBNYXgtQWdlPSR7Yy5tYXhBZ2V9YCxcbiAgICBcImRvbWFpblwiIGluIGMgJiYgYy5kb21haW4gJiYgYERvbWFpbj0ke2MuZG9tYWlufWAsXG4gICAgXCJzZWN1cmVcIiBpbiBjICYmIGMuc2VjdXJlICYmIFwiU2VjdXJlXCIsXG4gICAgXCJodHRwT25seVwiIGluIGMgJiYgYy5odHRwT25seSAmJiBcIkh0dHBPbmx5XCIsXG4gICAgXCJzYW1lU2l0ZVwiIGluIGMgJiYgYy5zYW1lU2l0ZSAmJiBgU2FtZVNpdGU9JHtjLnNhbWVTaXRlfWAsXG4gICAgXCJwYXJ0aXRpb25lZFwiIGluIGMgJiYgYy5wYXJ0aXRpb25lZCAmJiBcIlBhcnRpdGlvbmVkXCIsXG4gICAgXCJwcmlvcml0eVwiIGluIGMgJiYgYy5wcmlvcml0eSAmJiBgUHJpb3JpdHk9JHtjLnByaW9yaXR5fWBcbiAgXS5maWx0ZXIoQm9vbGVhbik7XG4gIGNvbnN0IHN0cmluZ2lmaWVkID0gYCR7Yy5uYW1lfT0ke2VuY29kZVVSSUNvbXBvbmVudCgoX2EgPSBjLnZhbHVlKSAhPSBudWxsID8gX2EgOiBcIlwiKX1gO1xuICByZXR1cm4gYXR0cnMubGVuZ3RoID09PSAwID8gc3RyaW5naWZpZWQgOiBgJHtzdHJpbmdpZmllZH07ICR7YXR0cnMuam9pbihcIjsgXCIpfWA7XG59XG5mdW5jdGlvbiBwYXJzZUNvb2tpZShjb29raWUpIHtcbiAgY29uc3QgbWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgZm9yIChjb25zdCBwYWlyIG9mIGNvb2tpZS5zcGxpdCgvOyAqLykpIHtcbiAgICBpZiAoIXBhaXIpXG4gICAgICBjb250aW51ZTtcbiAgICBjb25zdCBzcGxpdEF0ID0gcGFpci5pbmRleE9mKFwiPVwiKTtcbiAgICBpZiAoc3BsaXRBdCA9PT0gLTEpIHtcbiAgICAgIG1hcC5zZXQocGFpciwgXCJ0cnVlXCIpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IFtwYWlyLnNsaWNlKDAsIHNwbGl0QXQpLCBwYWlyLnNsaWNlKHNwbGl0QXQgKyAxKV07XG4gICAgdHJ5IHtcbiAgICAgIG1hcC5zZXQoa2V5LCBkZWNvZGVVUklDb21wb25lbnQodmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogXCJ0cnVlXCIpKTtcbiAgICB9IGNhdGNoIHtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1hcDtcbn1cbmZ1bmN0aW9uIHBhcnNlU2V0Q29va2llKHNldENvb2tpZSkge1xuICBpZiAoIXNldENvb2tpZSkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgY29uc3QgW1tuYW1lLCB2YWx1ZV0sIC4uLmF0dHJpYnV0ZXNdID0gcGFyc2VDb29raWUoc2V0Q29va2llKTtcbiAgY29uc3Qge1xuICAgIGRvbWFpbixcbiAgICBleHBpcmVzLFxuICAgIGh0dHBvbmx5LFxuICAgIG1heGFnZSxcbiAgICBwYXRoLFxuICAgIHNhbWVzaXRlLFxuICAgIHNlY3VyZSxcbiAgICBwYXJ0aXRpb25lZCxcbiAgICBwcmlvcml0eVxuICB9ID0gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIGF0dHJpYnV0ZXMubWFwKChba2V5LCB2YWx1ZTJdKSA9PiBbXG4gICAgICBrZXkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC8tL2csIFwiXCIpLFxuICAgICAgdmFsdWUyXG4gICAgXSlcbiAgKTtcbiAgY29uc3QgY29va2llID0ge1xuICAgIG5hbWUsXG4gICAgdmFsdWU6IGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSksXG4gICAgZG9tYWluLFxuICAgIC4uLmV4cGlyZXMgJiYgeyBleHBpcmVzOiBuZXcgRGF0ZShleHBpcmVzKSB9LFxuICAgIC4uLmh0dHBvbmx5ICYmIHsgaHR0cE9ubHk6IHRydWUgfSxcbiAgICAuLi50eXBlb2YgbWF4YWdlID09PSBcInN0cmluZ1wiICYmIHsgbWF4QWdlOiBOdW1iZXIobWF4YWdlKSB9LFxuICAgIHBhdGgsXG4gICAgLi4uc2FtZXNpdGUgJiYgeyBzYW1lU2l0ZTogcGFyc2VTYW1lU2l0ZShzYW1lc2l0ZSkgfSxcbiAgICAuLi5zZWN1cmUgJiYgeyBzZWN1cmU6IHRydWUgfSxcbiAgICAuLi5wcmlvcml0eSAmJiB7IHByaW9yaXR5OiBwYXJzZVByaW9yaXR5KHByaW9yaXR5KSB9LFxuICAgIC4uLnBhcnRpdGlvbmVkICYmIHsgcGFydGl0aW9uZWQ6IHRydWUgfVxuICB9O1xuICByZXR1cm4gY29tcGFjdChjb29raWUpO1xufVxuZnVuY3Rpb24gY29tcGFjdCh0KSB7XG4gIGNvbnN0IG5ld1QgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gdCkge1xuICAgIGlmICh0W2tleV0pIHtcbiAgICAgIG5ld1Rba2V5XSA9IHRba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ld1Q7XG59XG52YXIgU0FNRV9TSVRFID0gW1wic3RyaWN0XCIsIFwibGF4XCIsIFwibm9uZVwiXTtcbmZ1bmN0aW9uIHBhcnNlU2FtZVNpdGUoc3RyaW5nKSB7XG4gIHN0cmluZyA9IHN0cmluZy50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gU0FNRV9TSVRFLmluY2x1ZGVzKHN0cmluZykgPyBzdHJpbmcgOiB2b2lkIDA7XG59XG52YXIgUFJJT1JJVFkgPSBbXCJsb3dcIiwgXCJtZWRpdW1cIiwgXCJoaWdoXCJdO1xuZnVuY3Rpb24gcGFyc2VQcmlvcml0eShzdHJpbmcpIHtcbiAgc3RyaW5nID0gc3RyaW5nLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiBQUklPUklUWS5pbmNsdWRlcyhzdHJpbmcpID8gc3RyaW5nIDogdm9pZCAwO1xufVxuZnVuY3Rpb24gc3BsaXRDb29raWVzU3RyaW5nKGNvb2tpZXNTdHJpbmcpIHtcbiAgaWYgKCFjb29raWVzU3RyaW5nKVxuICAgIHJldHVybiBbXTtcbiAgdmFyIGNvb2tpZXNTdHJpbmdzID0gW107XG4gIHZhciBwb3MgPSAwO1xuICB2YXIgc3RhcnQ7XG4gIHZhciBjaDtcbiAgdmFyIGxhc3RDb21tYTtcbiAgdmFyIG5leHRTdGFydDtcbiAgdmFyIGNvb2tpZXNTZXBhcmF0b3JGb3VuZDtcbiAgZnVuY3Rpb24gc2tpcFdoaXRlc3BhY2UoKSB7XG4gICAgd2hpbGUgKHBvcyA8IGNvb2tpZXNTdHJpbmcubGVuZ3RoICYmIC9cXHMvLnRlc3QoY29va2llc1N0cmluZy5jaGFyQXQocG9zKSkpIHtcbiAgICAgIHBvcyArPSAxO1xuICAgIH1cbiAgICByZXR1cm4gcG9zIDwgY29va2llc1N0cmluZy5sZW5ndGg7XG4gIH1cbiAgZnVuY3Rpb24gbm90U3BlY2lhbENoYXIoKSB7XG4gICAgY2ggPSBjb29raWVzU3RyaW5nLmNoYXJBdChwb3MpO1xuICAgIHJldHVybiBjaCAhPT0gXCI9XCIgJiYgY2ggIT09IFwiO1wiICYmIGNoICE9PSBcIixcIjtcbiAgfVxuICB3aGlsZSAocG9zIDwgY29va2llc1N0cmluZy5sZW5ndGgpIHtcbiAgICBzdGFydCA9IHBvcztcbiAgICBjb29raWVzU2VwYXJhdG9yRm91bmQgPSBmYWxzZTtcbiAgICB3aGlsZSAoc2tpcFdoaXRlc3BhY2UoKSkge1xuICAgICAgY2ggPSBjb29raWVzU3RyaW5nLmNoYXJBdChwb3MpO1xuICAgICAgaWYgKGNoID09PSBcIixcIikge1xuICAgICAgICBsYXN0Q29tbWEgPSBwb3M7XG4gICAgICAgIHBvcyArPSAxO1xuICAgICAgICBza2lwV2hpdGVzcGFjZSgpO1xuICAgICAgICBuZXh0U3RhcnQgPSBwb3M7XG4gICAgICAgIHdoaWxlIChwb3MgPCBjb29raWVzU3RyaW5nLmxlbmd0aCAmJiBub3RTcGVjaWFsQ2hhcigpKSB7XG4gICAgICAgICAgcG9zICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcyA8IGNvb2tpZXNTdHJpbmcubGVuZ3RoICYmIGNvb2tpZXNTdHJpbmcuY2hhckF0KHBvcykgPT09IFwiPVwiKSB7XG4gICAgICAgICAgY29va2llc1NlcGFyYXRvckZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICBwb3MgPSBuZXh0U3RhcnQ7XG4gICAgICAgICAgY29va2llc1N0cmluZ3MucHVzaChjb29raWVzU3RyaW5nLnN1YnN0cmluZyhzdGFydCwgbGFzdENvbW1hKSk7XG4gICAgICAgICAgc3RhcnQgPSBwb3M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcG9zID0gbGFzdENvbW1hICsgMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9zICs9IDE7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghY29va2llc1NlcGFyYXRvckZvdW5kIHx8IHBvcyA+PSBjb29raWVzU3RyaW5nLmxlbmd0aCkge1xuICAgICAgY29va2llc1N0cmluZ3MucHVzaChjb29raWVzU3RyaW5nLnN1YnN0cmluZyhzdGFydCwgY29va2llc1N0cmluZy5sZW5ndGgpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvb2tpZXNTdHJpbmdzO1xufVxuXG4vLyBzcmMvcmVxdWVzdC1jb29raWVzLnRzXG52YXIgUmVxdWVzdENvb2tpZXMgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHJlcXVlc3RIZWFkZXJzKSB7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3BhcnNlZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5faGVhZGVycyA9IHJlcXVlc3RIZWFkZXJzO1xuICAgIGNvbnN0IGhlYWRlciA9IHJlcXVlc3RIZWFkZXJzLmdldChcImNvb2tpZVwiKTtcbiAgICBpZiAoaGVhZGVyKSB7XG4gICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZUNvb2tpZShoZWFkZXIpO1xuICAgICAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIHBhcnNlZCkge1xuICAgICAgICB0aGlzLl9wYXJzZWQuc2V0KG5hbWUsIHsgbmFtZSwgdmFsdWUgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiB0aGlzLl9wYXJzZWRbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYW1vdW50IG9mIGNvb2tpZXMgcmVjZWl2ZWQgZnJvbSB0aGUgY2xpZW50XG4gICAqL1xuICBnZXQgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFyc2VkLnNpemU7XG4gIH1cbiAgZ2V0KC4uLmFyZ3MpIHtcbiAgICBjb25zdCBuYW1lID0gdHlwZW9mIGFyZ3NbMF0gPT09IFwic3RyaW5nXCIgPyBhcmdzWzBdIDogYXJnc1swXS5uYW1lO1xuICAgIHJldHVybiB0aGlzLl9wYXJzZWQuZ2V0KG5hbWUpO1xuICB9XG4gIGdldEFsbCguLi5hcmdzKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGFsbCA9IEFycmF5LmZyb20odGhpcy5fcGFyc2VkKTtcbiAgICBpZiAoIWFyZ3MubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gYWxsLm1hcCgoW18sIHZhbHVlXSkgPT4gdmFsdWUpO1xuICAgIH1cbiAgICBjb25zdCBuYW1lID0gdHlwZW9mIGFyZ3NbMF0gPT09IFwic3RyaW5nXCIgPyBhcmdzWzBdIDogKF9hID0gYXJnc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLm5hbWU7XG4gICAgcmV0dXJuIGFsbC5maWx0ZXIoKFtuXSkgPT4gbiA9PT0gbmFtZSkubWFwKChbXywgdmFsdWVdKSA9PiB2YWx1ZSk7XG4gIH1cbiAgaGFzKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFyc2VkLmhhcyhuYW1lKTtcbiAgfVxuICBzZXQoLi4uYXJncykge1xuICAgIGNvbnN0IFtuYW1lLCB2YWx1ZV0gPSBhcmdzLmxlbmd0aCA9PT0gMSA/IFthcmdzWzBdLm5hbWUsIGFyZ3NbMF0udmFsdWVdIDogYXJncztcbiAgICBjb25zdCBtYXAgPSB0aGlzLl9wYXJzZWQ7XG4gICAgbWFwLnNldChuYW1lLCB7IG5hbWUsIHZhbHVlIH0pO1xuICAgIHRoaXMuX2hlYWRlcnMuc2V0KFxuICAgICAgXCJjb29raWVcIixcbiAgICAgIEFycmF5LmZyb20obWFwKS5tYXAoKFtfLCB2YWx1ZTJdKSA9PiBzdHJpbmdpZnlDb29raWUodmFsdWUyKSkuam9pbihcIjsgXCIpXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogRGVsZXRlIHRoZSBjb29raWVzIG1hdGNoaW5nIHRoZSBwYXNzZWQgbmFtZSBvciBuYW1lcyBpbiB0aGUgcmVxdWVzdC5cbiAgICovXG4gIGRlbGV0ZShuYW1lcykge1xuICAgIGNvbnN0IG1hcCA9IHRoaXMuX3BhcnNlZDtcbiAgICBjb25zdCByZXN1bHQgPSAhQXJyYXkuaXNBcnJheShuYW1lcykgPyBtYXAuZGVsZXRlKG5hbWVzKSA6IG5hbWVzLm1hcCgobmFtZSkgPT4gbWFwLmRlbGV0ZShuYW1lKSk7XG4gICAgdGhpcy5faGVhZGVycy5zZXQoXG4gICAgICBcImNvb2tpZVwiLFxuICAgICAgQXJyYXkuZnJvbShtYXApLm1hcCgoW18sIHZhbHVlXSkgPT4gc3RyaW5naWZ5Q29va2llKHZhbHVlKSkuam9pbihcIjsgXCIpXG4gICAgKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGUgYWxsIHRoZSBjb29raWVzIGluIHRoZSBjb29raWVzIGluIHRoZSByZXF1ZXN0LlxuICAgKi9cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5kZWxldGUoQXJyYXkuZnJvbSh0aGlzLl9wYXJzZWQua2V5cygpKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEZvcm1hdCB0aGUgY29va2llcyBpbiB0aGUgcmVxdWVzdCBhcyBhIHN0cmluZyBmb3IgbG9nZ2luZ1xuICAgKi9cbiAgW1N5bWJvbC5mb3IoXCJlZGdlLXJ1bnRpbWUuaW5zcGVjdC5jdXN0b21cIildKCkge1xuICAgIHJldHVybiBgUmVxdWVzdENvb2tpZXMgJHtKU09OLnN0cmluZ2lmeShPYmplY3QuZnJvbUVudHJpZXModGhpcy5fcGFyc2VkKSl9YDtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gWy4uLnRoaXMuX3BhcnNlZC52YWx1ZXMoKV0ubWFwKCh2KSA9PiBgJHt2Lm5hbWV9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KHYudmFsdWUpfWApLmpvaW4oXCI7IFwiKTtcbiAgfVxufTtcblxuLy8gc3JjL3Jlc3BvbnNlLWNvb2tpZXMudHNcbnZhciBSZXNwb25zZUNvb2tpZXMgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHJlc3BvbnNlSGVhZGVycykge1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9wYXJzZWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIHRoaXMuX2hlYWRlcnMgPSByZXNwb25zZUhlYWRlcnM7XG4gICAgY29uc3Qgc2V0Q29va2llID0gKF9jID0gKF9iID0gKF9hID0gcmVzcG9uc2VIZWFkZXJzLmdldFNldENvb2tpZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwocmVzcG9uc2VIZWFkZXJzKSkgIT0gbnVsbCA/IF9iIDogcmVzcG9uc2VIZWFkZXJzLmdldChcInNldC1jb29raWVcIikpICE9IG51bGwgPyBfYyA6IFtdO1xuICAgIGNvbnN0IGNvb2tpZVN0cmluZ3MgPSBBcnJheS5pc0FycmF5KHNldENvb2tpZSkgPyBzZXRDb29raWUgOiBzcGxpdENvb2tpZXNTdHJpbmcoc2V0Q29va2llKTtcbiAgICBmb3IgKGNvbnN0IGNvb2tpZVN0cmluZyBvZiBjb29raWVTdHJpbmdzKSB7XG4gICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZVNldENvb2tpZShjb29raWVTdHJpbmcpO1xuICAgICAgaWYgKHBhcnNlZClcbiAgICAgICAgdGhpcy5fcGFyc2VkLnNldChwYXJzZWQubmFtZSwgcGFyc2VkKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIHtAbGluayBodHRwczovL3dpY2cuZ2l0aHViLmlvL2Nvb2tpZS1zdG9yZS8jQ29va2llU3RvcmUtZ2V0IENvb2tpZVN0b3JlI2dldH0gd2l0aG91dCB0aGUgUHJvbWlzZS5cbiAgICovXG4gIGdldCguLi5hcmdzKSB7XG4gICAgY29uc3Qga2V5ID0gdHlwZW9mIGFyZ3NbMF0gPT09IFwic3RyaW5nXCIgPyBhcmdzWzBdIDogYXJnc1swXS5uYW1lO1xuICAgIHJldHVybiB0aGlzLl9wYXJzZWQuZ2V0KGtleSk7XG4gIH1cbiAgLyoqXG4gICAqIHtAbGluayBodHRwczovL3dpY2cuZ2l0aHViLmlvL2Nvb2tpZS1zdG9yZS8jQ29va2llU3RvcmUtZ2V0QWxsIENvb2tpZVN0b3JlI2dldEFsbH0gd2l0aG91dCB0aGUgUHJvbWlzZS5cbiAgICovXG4gIGdldEFsbCguLi5hcmdzKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGFsbCA9IEFycmF5LmZyb20odGhpcy5fcGFyc2VkLnZhbHVlcygpKTtcbiAgICBpZiAoIWFyZ3MubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gYWxsO1xuICAgIH1cbiAgICBjb25zdCBrZXkgPSB0eXBlb2YgYXJnc1swXSA9PT0gXCJzdHJpbmdcIiA/IGFyZ3NbMF0gOiAoX2EgPSBhcmdzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2EubmFtZTtcbiAgICByZXR1cm4gYWxsLmZpbHRlcigoYykgPT4gYy5uYW1lID09PSBrZXkpO1xuICB9XG4gIGhhcyhuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcnNlZC5oYXMobmFtZSk7XG4gIH1cbiAgLyoqXG4gICAqIHtAbGluayBodHRwczovL3dpY2cuZ2l0aHViLmlvL2Nvb2tpZS1zdG9yZS8jQ29va2llU3RvcmUtc2V0IENvb2tpZVN0b3JlI3NldH0gd2l0aG91dCB0aGUgUHJvbWlzZS5cbiAgICovXG4gIHNldCguLi5hcmdzKSB7XG4gICAgY29uc3QgW25hbWUsIHZhbHVlLCBjb29raWVdID0gYXJncy5sZW5ndGggPT09IDEgPyBbYXJnc1swXS5uYW1lLCBhcmdzWzBdLnZhbHVlLCBhcmdzWzBdXSA6IGFyZ3M7XG4gICAgY29uc3QgbWFwID0gdGhpcy5fcGFyc2VkO1xuICAgIG1hcC5zZXQobmFtZSwgbm9ybWFsaXplQ29va2llKHsgbmFtZSwgdmFsdWUsIC4uLmNvb2tpZSB9KSk7XG4gICAgcmVwbGFjZShtYXAsIHRoaXMuX2hlYWRlcnMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiB7QGxpbmsgaHR0cHM6Ly93aWNnLmdpdGh1Yi5pby9jb29raWUtc3RvcmUvI0Nvb2tpZVN0b3JlLWRlbGV0ZSBDb29raWVTdG9yZSNkZWxldGV9IHdpdGhvdXQgdGhlIFByb21pc2UuXG4gICAqL1xuICBkZWxldGUoLi4uYXJncykge1xuICAgIGNvbnN0IFtuYW1lLCBvcHRpb25zXSA9IHR5cGVvZiBhcmdzWzBdID09PSBcInN0cmluZ1wiID8gW2FyZ3NbMF1dIDogW2FyZ3NbMF0ubmFtZSwgYXJnc1swXV07XG4gICAgcmV0dXJuIHRoaXMuc2V0KHsgLi4ub3B0aW9ucywgbmFtZSwgdmFsdWU6IFwiXCIsIGV4cGlyZXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgwKSB9KTtcbiAgfVxuICBbU3ltYm9sLmZvcihcImVkZ2UtcnVudGltZS5pbnNwZWN0LmN1c3RvbVwiKV0oKSB7XG4gICAgcmV0dXJuIGBSZXNwb25zZUNvb2tpZXMgJHtKU09OLnN0cmluZ2lmeShPYmplY3QuZnJvbUVudHJpZXModGhpcy5fcGFyc2VkKSl9YDtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gWy4uLnRoaXMuX3BhcnNlZC52YWx1ZXMoKV0ubWFwKHN0cmluZ2lmeUNvb2tpZSkuam9pbihcIjsgXCIpO1xuICB9XG59O1xuZnVuY3Rpb24gcmVwbGFjZShiYWcsIGhlYWRlcnMpIHtcbiAgaGVhZGVycy5kZWxldGUoXCJzZXQtY29va2llXCIpO1xuICBmb3IgKGNvbnN0IFssIHZhbHVlXSBvZiBiYWcpIHtcbiAgICBjb25zdCBzZXJpYWxpemVkID0gc3RyaW5naWZ5Q29va2llKHZhbHVlKTtcbiAgICBoZWFkZXJzLmFwcGVuZChcInNldC1jb29raWVcIiwgc2VyaWFsaXplZCk7XG4gIH1cbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvb2tpZShjb29raWUgPSB7IG5hbWU6IFwiXCIsIHZhbHVlOiBcIlwiIH0pIHtcbiAgaWYgKHR5cGVvZiBjb29raWUuZXhwaXJlcyA9PT0gXCJudW1iZXJcIikge1xuICAgIGNvb2tpZS5leHBpcmVzID0gbmV3IERhdGUoY29va2llLmV4cGlyZXMpO1xuICB9XG4gIGlmIChjb29raWUubWF4QWdlKSB7XG4gICAgY29va2llLmV4cGlyZXMgPSBuZXcgRGF0ZShEYXRlLm5vdygpICsgY29va2llLm1heEFnZSAqIDFlMyk7XG4gIH1cbiAgaWYgKGNvb2tpZS5wYXRoID09PSBudWxsIHx8IGNvb2tpZS5wYXRoID09PSB2b2lkIDApIHtcbiAgICBjb29raWUucGF0aCA9IFwiL1wiO1xuICB9XG4gIHJldHVybiBjb29raWU7XG59XG4vLyBBbm5vdGF0ZSB0aGUgQ29tbW9uSlMgZXhwb3J0IG5hbWVzIGZvciBFU00gaW1wb3J0IGluIG5vZGU6XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgUmVxdWVzdENvb2tpZXMsXG4gIFJlc3BvbnNlQ29va2llcyxcbiAgcGFyc2VDb29raWUsXG4gIHBhcnNlU2V0Q29va2llLFxuICBzdHJpbmdpZnlDb29raWVcbn0pO1xuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUNBLElBQUksWUFBWSxPQUFPLGNBQWM7QUFDckMsSUFBSSxtQkFBbUIsT0FBTyx3QkFBd0I7QUFDdEQsSUFBSSxvQkFBb0IsT0FBTyxtQkFBbUI7QUFDbEQsSUFBSSxlQUFlLE9B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LE9BQU87SUFDMUM7SUFDQSxJQUFJLE9BQU8sTUFBTSxFQUFFO1FBQ2pCLE9BQU8sT0FBTyxHQUFHLElBQUksS0FBSyxLQUFLLEdBQUcsS0FBSyxPQUFPLE1BQU0sR0FBRztJQUN6RDtJQUNBLElBQUksT0FBTyxJQUFJLEtBQUssUUFBUSxPQUFPLElBQUksS0FBSyxLQUFLLEdBQUc7UUFDbEQsT0FBTyxJQUFJLEdBQUc7SUFDaEI7SUFDQSxPQUFPO0FBQ1Q7QUFDQSw2REFBNkQ7QUFDN0QsS0FBSyxDQUFDLE9BQU8sT0FBTyxHQUFHO0lBQ3JCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7QUFDRixDQUFDIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDI4OTgsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NyYy9zZXJ2ZXIvd2ViL3NwZWMtZXh0ZW5zaW9uL2Nvb2tpZXMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHtcbiAgUmVxdWVzdENvb2tpZXMsXG4gIFJlc3BvbnNlQ29va2llcyxcbiAgc3RyaW5naWZ5Q29va2llLFxufSBmcm9tICduZXh0L2Rpc3QvY29tcGlsZWQvQGVkZ2UtcnVudGltZS9jb29raWVzJ1xuIl0sIm5hbWVzIjpbIlJlcXVlc3RDb29raWVzIiwiUmVzcG9uc2VDb29raWVzIiwic3RyaW5naWZ5Q29va2llIl0sIm1hcHBpbmdzIjoiO0FBQUEsU0FDRUEsY0FBYyxFQUNkQyxlQUFlLEVBQ2ZDLGVBQWUsUUFDViwyQ0FBMEMiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMjkxMiwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL3NlcnZlci93ZWIvc3BlYy1leHRlbnNpb24vcmVxdWVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IEkxOE5Db25maWcgfSBmcm9tICcuLi8uLi9jb25maWctc2hhcmVkJ1xuaW1wb3J0IHsgTmV4dFVSTCB9IGZyb20gJy4uL25leHQtdXJsJ1xuaW1wb3J0IHsgdG9Ob2RlT3V0Z29pbmdIdHRwSGVhZGVycywgdmFsaWRhdGVVUkwgfSBmcm9tICcuLi91dGlscydcbmltcG9ydCB7IFJlbW92ZWRVQUVycm9yLCBSZW1vdmVkUGFnZUVycm9yIH0gZnJvbSAnLi4vZXJyb3InXG5pbXBvcnQgeyBSZXF1ZXN0Q29va2llcyB9IGZyb20gJy4vY29va2llcydcblxuZXhwb3J0IGNvbnN0IElOVEVSTkFMUyA9IFN5bWJvbCgnaW50ZXJuYWwgcmVxdWVzdCcpXG5cbi8qKlxuICogVGhpcyBjbGFzcyBleHRlbmRzIHRoZSBbV2ViIGBSZXF1ZXN0YCBBUEldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9SZXF1ZXN0KSB3aXRoIGFkZGl0aW9uYWwgY29udmVuaWVuY2UgbWV0aG9kcy5cbiAqXG4gKiBSZWFkIG1vcmU6IFtOZXh0LmpzIERvY3M6IGBOZXh0UmVxdWVzdGBdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9hcGktcmVmZXJlbmNlL2Z1bmN0aW9ucy9uZXh0LXJlcXVlc3QpXG4gKi9cbmV4cG9ydCBjbGFzcyBOZXh0UmVxdWVzdCBleHRlbmRzIFJlcXVlc3Qge1xuICBbSU5URVJOQUxTXToge1xuICAgIGNvb2tpZXM6IFJlcXVlc3RDb29raWVzXG4gICAgdXJsOiBzdHJpbmdcbiAgICBuZXh0VXJsOiBOZXh0VVJMXG4gIH1cblxuICBjb25zdHJ1Y3RvcihpbnB1dDogVVJMIHwgUmVxdWVzdEluZm8sIGluaXQ6IFJlcXVlc3RJbml0ID0ge30pIHtcbiAgICBjb25zdCB1cmwgPVxuICAgICAgdHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJyAmJiAndXJsJyBpbiBpbnB1dCA/IGlucHV0LnVybCA6IFN0cmluZyhpbnB1dClcblxuICAgIHZhbGlkYXRlVVJMKHVybClcblxuICAgIC8vIG5vZGUgUmVxdWVzdCBpbnN0YW5jZSByZXF1aXJlcyBkdXBsZXggb3B0aW9uIHdoZW4gYSBib2R5XG4gICAgLy8gaXMgcHJlc2VudCBvciBpdCBlcnJvcnMsIHdlIGRvbid0IGhhbmRsZSB0aGlzIGZvclxuICAgIC8vIFJlcXVlc3QgYmVpbmcgcGFzc2VkIGluIHNpbmNlIGl0IHdvdWxkIGhhdmUgYWxyZWFkeVxuICAgIC8vIGVycm9yZWQgaWYgdGhpcyB3YXNuJ3QgY29uZmlndXJlZFxuICAgIGlmIChwcm9jZXNzLmVudi5ORVhUX1JVTlRJTUUgIT09ICdlZGdlJykge1xuICAgICAgaWYgKGluaXQuYm9keSAmJiBpbml0LmR1cGxleCAhPT0gJ2hhbGYnKSB7XG4gICAgICAgIGluaXQuZHVwbGV4ID0gJ2hhbGYnXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlucHV0IGluc3RhbmNlb2YgUmVxdWVzdCkgc3VwZXIoaW5wdXQsIGluaXQpXG4gICAgZWxzZSBzdXBlcih1cmwsIGluaXQpXG5cbiAgICBjb25zdCBuZXh0VXJsID0gbmV3IE5leHRVUkwodXJsLCB7XG4gICAgICBoZWFkZXJzOiB0b05vZGVPdXRnb2luZ0h0dHBIZWFkZXJzKHRoaXMuaGVhZGVycyksXG4gICAgICBuZXh0Q29uZmlnOiBpbml0Lm5leHRDb25maWcsXG4gICAgfSlcbiAgICB0aGlzW0lOVEVSTkFMU10gPSB7XG4gICAgICBjb29raWVzOiBuZXcgUmVxdWVzdENvb2tpZXModGhpcy5oZWFkZXJzKSxcbiAgICAgIG5leHRVcmwsXG4gICAgICB1cmw6IHByb2Nlc3MuZW52Ll9fTkVYVF9OT19NSURETEVXQVJFX1VSTF9OT1JNQUxJWkVcbiAgICAgICAgPyB1cmxcbiAgICAgICAgOiBuZXh0VXJsLnRvU3RyaW5nKCksXG4gICAgfVxuICB9XG5cbiAgW1N5bWJvbC5mb3IoJ2VkZ2UtcnVudGltZS5pbnNwZWN0LmN1c3RvbScpXSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29va2llczogdGhpcy5jb29raWVzLFxuICAgICAgbmV4dFVybDogdGhpcy5uZXh0VXJsLFxuICAgICAgdXJsOiB0aGlzLnVybCxcbiAgICAgIC8vIHJlc3Qgb2YgcHJvcHMgY29tZSBmcm9tIFJlcXVlc3RcbiAgICAgIGJvZHlVc2VkOiB0aGlzLmJvZHlVc2VkLFxuICAgICAgY2FjaGU6IHRoaXMuY2FjaGUsXG4gICAgICBjcmVkZW50aWFsczogdGhpcy5jcmVkZW50aWFscyxcbiAgICAgIGRlc3RpbmF0aW9uOiB0aGlzLmRlc3RpbmF0aW9uLFxuICAgICAgaGVhZGVyczogT2JqZWN0LmZyb21FbnRyaWVzKHRoaXMuaGVhZGVycyksXG4gICAgICBpbnRlZ3JpdHk6IHRoaXMuaW50ZWdyaXR5LFxuICAgICAga2VlcGFsaXZlOiB0aGlzLmtlZXBhbGl2ZSxcbiAgICAgIG1ldGhvZDogdGhpcy5tZXRob2QsXG4gICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICByZWRpcmVjdDogdGhpcy5yZWRpcmVjdCxcbiAgICAgIHJlZmVycmVyOiB0aGlzLnJlZmVycmVyLFxuICAgICAgcmVmZXJyZXJQb2xpY3k6IHRoaXMucmVmZXJyZXJQb2xpY3ksXG4gICAgICBzaWduYWw6IHRoaXMuc2lnbmFsLFxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBnZXQgY29va2llcygpIHtcbiAgICByZXR1cm4gdGhpc1tJTlRFUk5BTFNdLmNvb2tpZXNcbiAgfVxuXG4gIHB1YmxpYyBnZXQgbmV4dFVybCgpIHtcbiAgICByZXR1cm4gdGhpc1tJTlRFUk5BTFNdLm5leHRVcmxcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBgcGFnZWAgaGFzIGJlZW4gZGVwcmVjYXRlZCBpbiBmYXZvdXIgb2YgYFVSTFBhdHRlcm5gLlxuICAgKiBSZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL21pZGRsZXdhcmUtcmVxdWVzdC1wYWdlXG4gICAqL1xuICBwdWJsaWMgZ2V0IHBhZ2UoKSB7XG4gICAgdGhyb3cgbmV3IFJlbW92ZWRQYWdlRXJyb3IoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIGB1YWAgaGFzIGJlZW4gcmVtb3ZlZCBpbiBmYXZvdXIgb2YgXFxgdXNlckFnZW50XFxgIGZ1bmN0aW9uLlxuICAgKiBSZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL21pZGRsZXdhcmUtcGFyc2UtdXNlci1hZ2VudFxuICAgKi9cbiAgcHVibGljIGdldCB1YSgpIHtcbiAgICB0aHJvdyBuZXcgUmVtb3ZlZFVBRXJyb3IoKVxuICB9XG5cbiAgcHVibGljIGdldCB1cmwoKSB7XG4gICAgcmV0dXJuIHRoaXNbSU5URVJOQUxTXS51cmxcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlcXVlc3RJbml0IGV4dGVuZHMgZ2xvYmFsVGhpcy5SZXF1ZXN0SW5pdCB7XG4gIG5leHRDb25maWc/OiB7XG4gICAgYmFzZVBhdGg/OiBzdHJpbmdcbiAgICBpMThuPzogSTE4TkNvbmZpZyB8IG51bGxcbiAgICB0cmFpbGluZ1NsYXNoPzogYm9vbGVhblxuICB9XG4gIHNpZ25hbD86IEFib3J0U2lnbmFsXG4gIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2hhdHdnL2ZldGNoL3B1bGwvMTQ1N1xuICBkdXBsZXg/OiAnaGFsZidcbn1cbiJdLCJuYW1lcyI6WyJOZXh0VVJMIiwidG9Ob2RlT3V0Z29pbmdIdHRwSGVhZGVycyIsInZhbGlkYXRlVVJMIiwiUmVtb3ZlZFVBRXJyb3IiLCJSZW1vdmVkUGFnZUVycm9yIiwiUmVxdWVzdENvb2tpZXMiLCJJTlRFUk5BTFMiLCJTeW1ib2wiLCJOZXh0UmVxdWVzdCIsIlJlcXVlc3QiLCJjb25zdHJ1Y3RvciIsImlucHV0IiwiaW5pdCIsInVybCIsIlN0cmluZyIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1JVTlRJTUUiLCJib2R5IiwiZHVwbGV4IiwibmV4dFVybCIsImhlYWRlcnMiLCJuZXh0Q29uZmlnIiwiY29va2llcyIsIl9fTkVYVF9OT19NSURETEVXQVJFX1VSTF9OT1JNQUxJWkUiLCJ0b1N0cmluZyIsImZvciIsImJvZHlVc2VkIiwiY2FjaGUiLCJjcmVkZW50aWFscyIsImRlc3RpbmF0aW9uIiwiT2JqZWN0IiwiZnJvbUVudHJpZXMiLCJpbnRlZ3JpdHkiLCJrZWVwYWxpdmUiLCJtZXRob2QiLCJtb2RlIiwicmVkaXJlY3QiLCJyZWZlcnJlciIsInJlZmVycmVyUG9saWN5Iiwic2lnbmFsIiwicGFnZSIsInVhIl0sIm1hcHBpbmdzIjoiOzs7O0FBQ0EsU0FBU0EsT0FBTyxRQUFRLGNBQWE7QUFDckMsU0FBU0MseUJBQXlCLEVBQUVDLFdBQVcsUUFBUSxXQUFVO0FBQ2pFLFNBQVNDLGNBQWMsRUFBRUMsZ0JBQWdCLFFBQVEsV0FBVTtBQUMzRCxTQUFTQyxjQUFjLFFBQVEsWUFBVzs7Ozs7O0FBRW5DLE1BQU1DLFlBQVlDLE9BQU8sb0JBQW1CO0FBTzVDLE1BQU1DLG9CQUFvQkM7SUFPL0JDLFlBQVlDLEtBQXdCLEVBQUVDLE9BQW9CLENBQUMsQ0FBQyxDQUFFO1FBQzVELE1BQU1DLE1BQ0osT0FBT0YsVUFBVSxZQUFZLFNBQVNBLFFBQVFBLE1BQU1FLEdBQUcsR0FBR0MsT0FBT0g7bUtBRW5FVCxjQUFBQSxFQUFZVztRQUVaLDJEQUEyRDtRQUMzRCxvREFBb0Q7UUFDcEQsc0RBQXNEO1FBQ3RELG9DQUFvQztRQUNwQyxJQUFJRSxRQUFRQyxHQUFHLENBQUNDLFlBQVksS0FBSyxPQUFRO1lBQ3ZDLElBQUlMLEtBQUtNLElBQUksSUFBSU4sS0FBS08sTUFBTSxLQUFLLFFBQVE7Z0JBQ3ZDUCxLQUFLTyxNQUFNLEdBQUc7WUFDaEI7UUFDRjtRQUVBLElBQUlSLGlCQUFpQkYsU0FBUyxLQUFLLENBQUNFLE9BQU9DO2FBQ3RDLEtBQUssQ0FBQ0MsS0FBS0Q7UUFFaEIsTUFBTVEsVUFBVSxpS0FBSXBCLFVBQUFBLENBQVFhLEtBQUs7WUFDL0JRLFNBQVNwQix1TEFBQUEsRUFBMEIsSUFBSSxDQUFDb0IsT0FBTztZQUMvQ0MsWUFBWVYsS0FBS1UsVUFBVTtRQUM3QjtRQUNBLElBQUksQ0FBQ2hCLFVBQVUsR0FBRztZQUNoQmlCLFNBQVMsK0tBQUlsQixpQkFBQUEsQ0FBZSxJQUFJLENBQUNnQixPQUFPO1lBQ3hDRDtZQUNBUCxLQUFLRSxRQUFRQyxHQUFHLENBQUNRLDBCQUNiWCxRQUQrQyxrQkFFL0NPLFFBQVFLLFFBQVE7UUFDdEI7SUFDRjtJQUVBLENBQUNsQixPQUFPbUIsR0FBRyxDQUFDLCtCQUErQixHQUFHO1FBQzVDLE9BQU87WUFDTEgsU0FBUyxJQUFJLENBQUNBLE9BQU87WUFDckJILFNBQVMsSUFBSSxDQUFDQSxPQUFPO1lBQ3JCUCxLQUFLLElBQUksQ0FBQ0EsR0FBRztZQUNiLGtDQUFrQztZQUNsQ2MsVUFBVSxJQUFJLENBQUNBLFFBQVE7WUFDdkJDLE9BQU8sSUFBSSxDQUFDQSxLQUFLO1lBQ2pCQyxhQUFhLElBQUksQ0FBQ0EsV0FBVztZQUM3QkMsYUFBYSxJQUFJLENBQUNBLFdBQVc7WUFDN0JULFNBQVNVLE9BQU9DLFdBQVcsQ0FBQyxJQUFJLENBQUNYLE9BQU87WUFDeENZLFdBQVcsSUFBSSxDQUFDQSxTQUFTO1lBQ3pCQyxXQUFXLElBQUksQ0FBQ0EsU0FBUztZQUN6QkMsUUFBUSxJQUFJLENBQUNBLE1BQU07WUFDbkJDLE1BQU0sSUFBSSxDQUFDQSxJQUFJO1lBQ2ZDLFVBQVUsSUFBSSxDQUFDQSxRQUFRO1lBQ3ZCQyxVQUFVLElBQUksQ0FBQ0EsUUFBUTtZQUN2QkMsZ0JBQWdCLElBQUksQ0FBQ0EsY0FBYztZQUNuQ0MsUUFBUSxJQUFJLENBQUNBLE1BQU07UUFDckI7SUFDRjtJQUVBLElBQVdqQixVQUFVO1FBQ25CLE9BQU8sSUFBSSxDQUFDakIsVUFBVSxDQUFDaUIsT0FBTztJQUNoQztJQUVBLElBQVdILFVBQVU7UUFDbkIsT0FBTyxJQUFJLENBQUNkLFVBQVUsQ0FBQ2MsT0FBTztJQUNoQztJQUVBOzs7O0dBSUMsR0FDRCxJQUFXcUIsT0FBTztRQUNoQixNQUFNLDJKQUFJckMsbUJBQUFBO0lBQ1o7SUFFQTs7OztHQUlDLEdBQ0QsSUFBV3NDLEtBQUs7UUFDZCxNQUFNLDJKQUFJdkMsaUJBQUFBO0lBQ1o7SUFFQSxJQUFXVSxNQUFNO1FBQ2YsT0FBTyxJQUFJLENBQUNQLFVBQVUsQ0FBQ08sR0FBRztJQUM1QjtBQUNGIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDMwMDAsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NyYy9zZXJ2ZXIvYmFzZS1odHRwL2hlbHBlcnMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBCYXNlTmV4dFJlcXVlc3QsIEJhc2VOZXh0UmVzcG9uc2UgfSBmcm9tICcuLydcbmltcG9ydCB0eXBlIHsgTm9kZU5leHRSZXF1ZXN0LCBOb2RlTmV4dFJlc3BvbnNlIH0gZnJvbSAnLi9ub2RlJ1xuaW1wb3J0IHR5cGUgeyBXZWJOZXh0UmVxdWVzdCwgV2ViTmV4dFJlc3BvbnNlIH0gZnJvbSAnLi93ZWInXG5cbi8qKlxuICogVGhpcyBmaWxlIHByb3ZpZGVzIHNvbWUgaGVscGVycyB0aGF0IHNob3VsZCBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGhcbiAqIGV4cGxpY2l0IGVudmlyb25tZW50IGNoZWNrcy4gV2hlbiBjb21iaW5lZCB3aXRoIHRoZSBlbnZpcm9ubWVudCBjaGVja3MsIGl0XG4gKiB3aWxsIGVuc3VyZSB0aGF0IHRoZSBjb3JyZWN0IHR5cGluZ3MgYXJlIHVzZWQgYXMgd2VsbCBhcyBlbmFibGUgY29kZVxuICogZWxpbWluYXRpb24uXG4gKi9cblxuLyoqXG4gKiBUeXBlIGd1YXJkIHRvIGRldGVybWluZSBpZiBhIHJlcXVlc3QgaXMgYSBXZWJOZXh0UmVxdWVzdC4gVGhpcyBkb2VzIG5vdFxuICogYWN0dWFsbHkgY2hlY2sgdGhlIHR5cGUgb2YgdGhlIHJlcXVlc3QsIGJ1dCByYXRoZXIgdGhlIHJ1bnRpbWUgZW52aXJvbm1lbnQuXG4gKiBJdCdzIGV4cGVjdGVkIHRoYXQgd2hlbiB0aGUgcnVudGltZSBlbnZpcm9ubWVudCBpcyB0aGUgZWRnZSBydW50aW1lLCB0aGF0IGFueVxuICogYmFzZSByZXF1ZXN0IGlzIGEgV2ViTmV4dFJlcXVlc3QuXG4gKi9cbmV4cG9ydCBjb25zdCBpc1dlYk5leHRSZXF1ZXN0ID0gKHJlcTogQmFzZU5leHRSZXF1ZXN0KTogcmVxIGlzIFdlYk5leHRSZXF1ZXN0ID0+XG4gIHByb2Nlc3MuZW52Lk5FWFRfUlVOVElNRSA9PT0gJ2VkZ2UnXG5cbi8qKlxuICogVHlwZSBndWFyZCB0byBkZXRlcm1pbmUgaWYgYSByZXNwb25zZSBpcyBhIFdlYk5leHRSZXNwb25zZS4gVGhpcyBkb2VzIG5vdFxuICogYWN0dWFsbHkgY2hlY2sgdGhlIHR5cGUgb2YgdGhlIHJlc3BvbnNlLCBidXQgcmF0aGVyIHRoZSBydW50aW1lIGVudmlyb25tZW50LlxuICogSXQncyBleHBlY3RlZCB0aGF0IHdoZW4gdGhlIHJ1bnRpbWUgZW52aXJvbm1lbnQgaXMgdGhlIGVkZ2UgcnVudGltZSwgdGhhdCBhbnlcbiAqIGJhc2UgcmVzcG9uc2UgaXMgYSBXZWJOZXh0UmVzcG9uc2UuXG4gKi9cbmV4cG9ydCBjb25zdCBpc1dlYk5leHRSZXNwb25zZSA9IChcbiAgcmVzOiBCYXNlTmV4dFJlc3BvbnNlXG4pOiByZXMgaXMgV2ViTmV4dFJlc3BvbnNlID0+IHByb2Nlc3MuZW52Lk5FWFRfUlVOVElNRSA9PT0gJ2VkZ2UnXG5cbi8qKlxuICogVHlwZSBndWFyZCB0byBkZXRlcm1pbmUgaWYgYSByZXF1ZXN0IGlzIGEgTm9kZU5leHRSZXF1ZXN0LiBUaGlzIGRvZXMgbm90XG4gKiBhY3R1YWxseSBjaGVjayB0aGUgdHlwZSBvZiB0aGUgcmVxdWVzdCwgYnV0IHJhdGhlciB0aGUgcnVudGltZSBlbnZpcm9ubWVudC5cbiAqIEl0J3MgZXhwZWN0ZWQgdGhhdCB3aGVuIHRoZSBydW50aW1lIGVudmlyb25tZW50IGlzIHRoZSBub2RlIHJ1bnRpbWUsIHRoYXQgYW55XG4gKiBiYXNlIHJlcXVlc3QgaXMgYSBOb2RlTmV4dFJlcXVlc3QuXG4gKi9cbmV4cG9ydCBjb25zdCBpc05vZGVOZXh0UmVxdWVzdCA9IChcbiAgcmVxOiBCYXNlTmV4dFJlcXVlc3Rcbik6IHJlcSBpcyBOb2RlTmV4dFJlcXVlc3QgPT4gcHJvY2Vzcy5lbnYuTkVYVF9SVU5USU1FICE9PSAnZWRnZSdcblxuLyoqXG4gKiBUeXBlIGd1YXJkIHRvIGRldGVybWluZSBpZiBhIHJlc3BvbnNlIGlzIGEgTm9kZU5leHRSZXNwb25zZS4gVGhpcyBkb2VzIG5vdFxuICogYWN0dWFsbHkgY2hlY2sgdGhlIHR5cGUgb2YgdGhlIHJlc3BvbnNlLCBidXQgcmF0aGVyIHRoZSBydW50aW1lIGVudmlyb25tZW50LlxuICogSXQncyBleHBlY3RlZCB0aGF0IHdoZW4gdGhlIHJ1bnRpbWUgZW52aXJvbm1lbnQgaXMgdGhlIG5vZGUgcnVudGltZSwgdGhhdCBhbnlcbiAqIGJhc2UgcmVzcG9uc2UgaXMgYSBOb2RlTmV4dFJlc3BvbnNlLlxuICovXG5leHBvcnQgY29uc3QgaXNOb2RlTmV4dFJlc3BvbnNlID0gKFxuICByZXM6IEJhc2VOZXh0UmVzcG9uc2Vcbik6IHJlcyBpcyBOb2RlTmV4dFJlc3BvbnNlID0+IHByb2Nlc3MuZW52Lk5FWFRfUlVOVElNRSAhPT0gJ2VkZ2UnXG4iXSwibmFtZXMiOlsiaXNXZWJOZXh0UmVxdWVzdCIsInJlcSIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1JVTlRJTUUiLCJpc1dlYk5leHRSZXNwb25zZSIsInJlcyIsImlzTm9kZU5leHRSZXF1ZXN0IiwiaXNOb2RlTmV4dFJlc3BvbnNlIl0sIm1hcHBpbmdzIjoiQUFJQTs7Ozs7Q0FLQyxHQUVEOzs7OztDQUtDLEdBQ0Q7Ozs7OztBQUFPLE1BQU1BLG1CQUFtQixDQUFDQyxNQUMvQkMsUUFBUUMsR0FBRyxDQUFDQyxZQUFZLHVCQUFLLE9BQU07QUFROUIsTUFBTUMsb0JBQW9CLENBQy9CQyxNQUMyQkosUUFBUUMsR0FBRyxDQUFDQyxZQUFZLHVCQUFLLE9BQU07QUFRekQsTUFBTUcsb0JBQW9CLENBQy9CTixNQUMyQkMsUUFBUUMsR0FBRyxDQUFDQyxZQUFZLHVCQUFLLE9BQU07QUFRekQsTUFBTUkscUJBQXFCLENBQ2hDRixNQUM0QkosUUFBUUMsR0FBRyxDQUFDQyxZQUFZLHVCQUFLLE9BQU0iLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMzAyNCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL3NlcnZlci93ZWIvc3BlYy1leHRlbnNpb24vYWRhcHRlcnMvbmV4dC1yZXF1ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgQmFzZU5leHRSZXF1ZXN0IH0gZnJvbSAnLi4vLi4vLi4vYmFzZS1odHRwJ1xuaW1wb3J0IHR5cGUgeyBOb2RlTmV4dFJlcXVlc3QgfSBmcm9tICcuLi8uLi8uLi9iYXNlLWh0dHAvbm9kZSdcbmltcG9ydCB0eXBlIHsgV2ViTmV4dFJlcXVlc3QgfSBmcm9tICcuLi8uLi8uLi9iYXNlLWh0dHAvd2ViJ1xuaW1wb3J0IHR5cGUgeyBXcml0YWJsZSB9IGZyb20gJ25vZGU6c3RyZWFtJ1xuXG5pbXBvcnQgeyBnZXRSZXF1ZXN0TWV0YSB9IGZyb20gJy4uLy4uLy4uL3JlcXVlc3QtbWV0YSdcbmltcG9ydCB7IGZyb21Ob2RlT3V0Z29pbmdIdHRwSGVhZGVycyB9IGZyb20gJy4uLy4uL3V0aWxzJ1xuaW1wb3J0IHsgTmV4dFJlcXVlc3QgfSBmcm9tICcuLi9yZXF1ZXN0J1xuaW1wb3J0IHsgaXNOb2RlTmV4dFJlcXVlc3QsIGlzV2ViTmV4dFJlcXVlc3QgfSBmcm9tICcuLi8uLi8uLi9iYXNlLWh0dHAvaGVscGVycydcblxuZXhwb3J0IGNvbnN0IFJlc3BvbnNlQWJvcnRlZE5hbWUgPSAnUmVzcG9uc2VBYm9ydGVkJ1xuZXhwb3J0IGNsYXNzIFJlc3BvbnNlQWJvcnRlZCBleHRlbmRzIEVycm9yIHtcbiAgcHVibGljIHJlYWRvbmx5IG5hbWUgPSBSZXNwb25zZUFib3J0ZWROYW1lXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBBYm9ydENvbnRyb2xsZXIgdGllZCB0byB0aGUgY2xvc2luZyBvZiBhIFNlcnZlclJlc3BvbnNlIChvciBvdGhlclxuICogYXBwcm9wcmlhdGUgV3JpdGFibGUpLlxuICpcbiAqIElmIHRoZSBgY2xvc2VgIGV2ZW50IGlzIGZpcmVkIGJlZm9yZSB0aGUgYGZpbmlzaGAgZXZlbnQsIHRoZW4gd2UnbGwgc2VuZCB0aGVcbiAqIGBhYm9ydGAgc2lnbmFsLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQWJvcnRDb250cm9sbGVyKHJlc3BvbnNlOiBXcml0YWJsZSk6IEFib3J0Q29udHJvbGxlciB7XG4gIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKClcblxuICAvLyBJZiBgZmluaXNoYCBmaXJlcyBmaXJzdCwgdGhlbiBgcmVzLmVuZCgpYCBoYXMgYmVlbiBjYWxsZWQgYW5kIHRoZSBjbG9zZSBpc1xuICAvLyBqdXN0IHVzIGZpbmlzaGluZyB0aGUgc3RyZWFtIG9uIG91ciBzaWRlLiBJZiBgY2xvc2VgIGZpcmVzIGZpcnN0LCB0aGVuIHdlXG4gIC8vIGtub3cgdGhlIGNsaWVudCBkaXNjb25uZWN0ZWQgYmVmb3JlIHdlIGZpbmlzaGVkLlxuICByZXNwb25zZS5vbmNlKCdjbG9zZScsICgpID0+IHtcbiAgICBpZiAocmVzcG9uc2Uud3JpdGFibGVGaW5pc2hlZCkgcmV0dXJuXG5cbiAgICBjb250cm9sbGVyLmFib3J0KG5ldyBSZXNwb25zZUFib3J0ZWQoKSlcbiAgfSlcblxuICByZXR1cm4gY29udHJvbGxlclxufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gQWJvcnRTaWduYWwgdGllZCB0byB0aGUgY2xvc2luZyBvZiBhIFNlcnZlclJlc3BvbnNlIChvciBvdGhlclxuICogYXBwcm9wcmlhdGUgV3JpdGFibGUpLlxuICpcbiAqIFRoaXMgY2Fubm90IGJlIGRvbmUgd2l0aCB0aGUgcmVxdWVzdCAoSW5jb21pbmdNZXNzYWdlIG9yIFJlYWRhYmxlKSBiZWNhdXNlXG4gKiB0aGUgYGFib3J0YCBldmVudCB3aWxsIG5vdCBmaXJlIGlmIHRvIGRhdGEgaGFzIGJlZW4gZnVsbHkgcmVhZCAoYmVjYXVzZSB0aGF0XG4gKiB3aWxsIFwiY2xvc2VcIiB0aGUgcmVhZGFibGUgc3RyZWFtIGFuZCBub3RoaW5nIGZpcmVzIGFmdGVyIHRoYXQpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2lnbmFsRnJvbU5vZGVSZXNwb25zZShyZXNwb25zZTogV3JpdGFibGUpOiBBYm9ydFNpZ25hbCB7XG4gIGNvbnN0IHsgZXJyb3JlZCwgZGVzdHJveWVkIH0gPSByZXNwb25zZVxuICBpZiAoZXJyb3JlZCB8fCBkZXN0cm95ZWQpIHtcbiAgICByZXR1cm4gQWJvcnRTaWduYWwuYWJvcnQoZXJyb3JlZCA/PyBuZXcgUmVzcG9uc2VBYm9ydGVkKCkpXG4gIH1cblxuICBjb25zdCB7IHNpZ25hbCB9ID0gY3JlYXRlQWJvcnRDb250cm9sbGVyKHJlc3BvbnNlKVxuICByZXR1cm4gc2lnbmFsXG59XG5cbmV4cG9ydCBjbGFzcyBOZXh0UmVxdWVzdEFkYXB0ZXIge1xuICBwdWJsaWMgc3RhdGljIGZyb21CYXNlTmV4dFJlcXVlc3QoXG4gICAgcmVxdWVzdDogQmFzZU5leHRSZXF1ZXN0LFxuICAgIHNpZ25hbDogQWJvcnRTaWduYWxcbiAgKTogTmV4dFJlcXVlc3Qge1xuICAgIGlmIChcbiAgICAgIC8vIFRoZSB0eXBlIGNoZWNrIGhlcmUgZW5zdXJlcyB0aGF0IGByZXFgIGlzIGNvcnJlY3RseSB0eXBlZCwgYW5kIHRoZVxuICAgICAgLy8gZW52aXJvbm1lbnQgdmFyaWFibGUgY2hlY2sgcHJvdmlkZXMgZGVhZCBjb2RlIGVsaW1pbmF0aW9uLlxuICAgICAgcHJvY2Vzcy5lbnYuTkVYVF9SVU5USU1FID09PSAnZWRnZScgJiZcbiAgICAgIGlzV2ViTmV4dFJlcXVlc3QocmVxdWVzdClcbiAgICApIHtcbiAgICAgIHJldHVybiBOZXh0UmVxdWVzdEFkYXB0ZXIuZnJvbVdlYk5leHRSZXF1ZXN0KHJlcXVlc3QpXG4gICAgfSBlbHNlIGlmIChcbiAgICAgIC8vIFRoZSB0eXBlIGNoZWNrIGhlcmUgZW5zdXJlcyB0aGF0IGByZXFgIGlzIGNvcnJlY3RseSB0eXBlZCwgYW5kIHRoZVxuICAgICAgLy8gZW52aXJvbm1lbnQgdmFyaWFibGUgY2hlY2sgcHJvdmlkZXMgZGVhZCBjb2RlIGVsaW1pbmF0aW9uLlxuICAgICAgcHJvY2Vzcy5lbnYuTkVYVF9SVU5USU1FICE9PSAnZWRnZScgJiZcbiAgICAgIGlzTm9kZU5leHRSZXF1ZXN0KHJlcXVlc3QpXG4gICAgKSB7XG4gICAgICByZXR1cm4gTmV4dFJlcXVlc3RBZGFwdGVyLmZyb21Ob2RlTmV4dFJlcXVlc3QocmVxdWVzdCwgc2lnbmFsKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFyaWFudDogVW5zdXBwb3J0ZWQgTmV4dFJlcXVlc3QgdHlwZScpXG4gICAgfVxuICB9XG5cbiAgcHVibGljIHN0YXRpYyBmcm9tTm9kZU5leHRSZXF1ZXN0KFxuICAgIHJlcXVlc3Q6IE5vZGVOZXh0UmVxdWVzdCxcbiAgICBzaWduYWw6IEFib3J0U2lnbmFsXG4gICk6IE5leHRSZXF1ZXN0IHtcbiAgICAvLyBIRUFEIGFuZCBHRVQgcmVxdWVzdHMgY2FuIG5vdCBoYXZlIGEgYm9keS5cbiAgICBsZXQgYm9keTogQm9keUluaXQgfCBudWxsID0gbnVsbFxuICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCAhPT0gJ0dFVCcgJiYgcmVxdWVzdC5tZXRob2QgIT09ICdIRUFEJyAmJiByZXF1ZXN0LmJvZHkpIHtcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSB0aGlzIGlzIGhhbmRsZWQgYnkgdW5kaWNpLCB3aGVuIHN0cmVhbXMvd2ViIGxhbmQgdXNlIGl0IGluc3RlYWRcbiAgICAgIGJvZHkgPSByZXF1ZXN0LmJvZHlcbiAgICB9XG5cbiAgICBsZXQgdXJsOiBVUkxcbiAgICBpZiAocmVxdWVzdC51cmwuc3RhcnRzV2l0aCgnaHR0cCcpKSB7XG4gICAgICB1cmwgPSBuZXcgVVJMKHJlcXVlc3QudXJsKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBHcmFiIHRoZSBmdWxsIFVSTCBmcm9tIHRoZSByZXF1ZXN0IG1ldGFkYXRhLlxuICAgICAgY29uc3QgYmFzZSA9IGdldFJlcXVlc3RNZXRhKHJlcXVlc3QsICdpbml0VVJMJylcbiAgICAgIGlmICghYmFzZSB8fCAhYmFzZS5zdGFydHNXaXRoKCdodHRwJykpIHtcbiAgICAgICAgLy8gQmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdGlvbiByZWxpZXMgb24gdGhlIGZhY3QgdGhhdCB0aGUgVVJMIHByb3ZpZGVkXG4gICAgICAgIC8vIGlzIGFic29sdXRlLCB3ZSBuZWVkIHRvIHByb3ZpZGUgYSBiYXNlIFVSTC4gV2UgY2FuJ3QgdXNlIHRoZSByZXF1ZXN0XG4gICAgICAgIC8vIFVSTCBiZWNhdXNlIGl0J3MgcmVsYXRpdmUsIHNvIHdlIHVzZSBhIGR1bW15IFVSTCBpbnN0ZWFkLlxuICAgICAgICB1cmwgPSBuZXcgVVJMKHJlcXVlc3QudXJsLCAnaHR0cDovL24nKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCwgYmFzZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IE5leHRSZXF1ZXN0KHVybCwge1xuICAgICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgIGhlYWRlcnM6IGZyb21Ob2RlT3V0Z29pbmdIdHRwSGVhZGVycyhyZXF1ZXN0LmhlYWRlcnMpLFxuICAgICAgZHVwbGV4OiAnaGFsZicsXG4gICAgICBzaWduYWwsXG4gICAgICAvLyBnZW9cbiAgICAgIC8vIGlwXG4gICAgICAvLyBuZXh0Q29uZmlnXG5cbiAgICAgIC8vIGJvZHkgY2FuIG5vdCBiZSBwYXNzZWQgaWYgcmVxdWVzdCB3YXMgYWJvcnRlZFxuICAgICAgLy8gb3Igd2UgZ2V0IGEgUmVxdWVzdCBib2R5IHdhcyBkaXN0dXJiZWQgZXJyb3JcbiAgICAgIC4uLihzaWduYWwuYWJvcnRlZFxuICAgICAgICA/IHt9XG4gICAgICAgIDoge1xuICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICB9KSxcbiAgICB9KVxuICB9XG5cbiAgcHVibGljIHN0YXRpYyBmcm9tV2ViTmV4dFJlcXVlc3QocmVxdWVzdDogV2ViTmV4dFJlcXVlc3QpOiBOZXh0UmVxdWVzdCB7XG4gICAgLy8gSEVBRCBhbmQgR0VUIHJlcXVlc3RzIGNhbiBub3QgaGF2ZSBhIGJvZHkuXG4gICAgbGV0IGJvZHk6IFJlYWRhYmxlU3RyZWFtIHwgbnVsbCA9IG51bGxcbiAgICBpZiAocmVxdWVzdC5tZXRob2QgIT09ICdHRVQnICYmIHJlcXVlc3QubWV0aG9kICE9PSAnSEVBRCcpIHtcbiAgICAgIGJvZHkgPSByZXF1ZXN0LmJvZHlcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IE5leHRSZXF1ZXN0KHJlcXVlc3QudXJsLCB7XG4gICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgICAgaGVhZGVyczogZnJvbU5vZGVPdXRnb2luZ0h0dHBIZWFkZXJzKHJlcXVlc3QuaGVhZGVycyksXG4gICAgICBkdXBsZXg6ICdoYWxmJyxcbiAgICAgIHNpZ25hbDogcmVxdWVzdC5yZXF1ZXN0LnNpZ25hbCxcbiAgICAgIC8vIGdlb1xuICAgICAgLy8gaXBcbiAgICAgIC8vIG5leHRDb25maWdcblxuICAgICAgLy8gYm9keSBjYW4gbm90IGJlIHBhc3NlZCBpZiByZXF1ZXN0IHdhcyBhYm9ydGVkXG4gICAgICAvLyBvciB3ZSBnZXQgYSBSZXF1ZXN0IGJvZHkgd2FzIGRpc3R1cmJlZCBlcnJvclxuICAgICAgLi4uKHJlcXVlc3QucmVxdWVzdC5zaWduYWwuYWJvcnRlZFxuICAgICAgICA/IHt9XG4gICAgICAgIDoge1xuICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICB9KSxcbiAgICB9KVxuICB9XG59XG4iXSwibmFtZXMiOlsiZ2V0UmVxdWVzdE1ldGEiLCJmcm9tTm9kZU91dGdvaW5nSHR0cEhlYWRlcnMiLCJOZXh0UmVxdWVzdCIsImlzTm9kZU5leHRSZXF1ZXN0IiwiaXNXZWJOZXh0UmVxdWVzdCIsIlJlc3BvbnNlQWJvcnRlZE5hbWUiLCJSZXNwb25zZUFib3J0ZWQiLCJFcnJvciIsIm5hbWUiLCJjcmVhdGVBYm9ydENvbnRyb2xsZXIiLCJyZXNwb25zZSIsImNvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJvbmNlIiwid3JpdGFibGVGaW5pc2hlZCIsImFib3J0Iiwic2lnbmFsRnJvbU5vZGVSZXNwb25zZSIsImVycm9yZWQiLCJkZXN0cm95ZWQiLCJBYm9ydFNpZ25hbCIsInNpZ25hbCIsIk5leHRSZXF1ZXN0QWRhcHRlciIsImZyb21CYXNlTmV4dFJlcXVlc3QiLCJyZXF1ZXN0IiwicHJvY2VzcyIsImVudiIsIk5FWFRfUlVOVElNRSIsImZyb21XZWJOZXh0UmVxdWVzdCIsImZyb21Ob2RlTmV4dFJlcXVlc3QiLCJib2R5IiwibWV0aG9kIiwidXJsIiwic3RhcnRzV2l0aCIsIlVSTCIsImJhc2UiLCJoZWFkZXJzIiwiZHVwbGV4IiwiYWJvcnRlZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUtBLFNBQVNBLGNBQWMsUUFBUSx3QkFBdUI7QUFDdEQsU0FBU0MsMkJBQTJCLFFBQVEsY0FBYTtB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U1AsUUFBUU8sTUFBTSxLQUFLLFFBQVE7WUFDekRELE9BQU9OLFFBQVFNLElBQUk7UUFDckI7UUFFQSxPQUFPLGtMQUFJM0IsY0FBQUEsQ0FBWXFCLFFBQVFRLEdBQUcsRUFBRTtZQUNsQ0QsUUFBUVAsUUFBUU8sTUFBTTtZQUN0Qkssb0tBQVNsQyw4QkFBQUEsRUFBNEJzQixRQUFRWSxPQUFPO1lBQ3BEQyxRQUFRO1lBQ1JoQixRQUFRRyxRQUFRQSxPQUFPLENBQUNILE1BQU07WUFDOUIsTUFBTTtZQUNOLEtBQUs7WUFDTCxhQUFhO1lBRWIsZ0RBQWdEO1lBQ2hELCtDQUErQztZQUMvQyxHQUFJRyxRQUFRQSxPQUFPLENBQUNILE1BQU0sQ0FBQ2lCLE9BQU8sR0FDOUIsQ0FBQyxJQUNEO2dCQUNFUjtZQUNGLENBQUM7UUFDUDtJQUNGO0FBQ0YiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMzE0MywgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL3NlcnZlci9jbGllbnQtY29tcG9uZW50LXJlbmRlcmVyLWxvZ2dlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IEFwcFBhZ2VNb2R1bGUgfSBmcm9tICcuL3JvdXRlLW1vZHVsZXMvYXBwLXBhZ2UvbW9kdWxlJ1xuXG4vLyBDb21iaW5lZCBsb2FkIHRpbWVzIGZvciBsb2FkaW5nIGNsaWVudCBjb21wb25lbnRzXG5sZXQgY2xpZW50Q29tcG9uZW50TG9hZFN0YXJ0ID0gMFxubGV0IGNsaWVudENvbXBvbmVudExvYWRUaW1lcyA9IDBcbmxldCBjbGllbnRDb21wb25lbnRMb2FkQ291bnQgPSAwXG5cbmV4cG9ydCBmdW5jdGlvbiB3cmFwQ2xpZW50Q29tcG9uZW50TG9hZGVyKFxuICBDb21wb25lbnRNb2Q6IEFwcFBhZ2VNb2R1bGVcbik6IEFwcFBhZ2VNb2R1bGVbJ19fbmV4dF9hcHBfXyddIHtcbiAgaWYgKCEoJ3BlcmZvcm1hbmNlJyBpbiBnbG9iYWxUaGlzKSkge1xuICAgIHJldHVybiBDb21wb25lbnRNb2QuX19uZXh0X2FwcF9fXG4gIH1cblxuICByZXR1cm4ge1xuICAgIHJlcXVpcmU6ICguLi5hcmdzKSA9PiB7XG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKVxuXG4gICAgICBpZiAoY2xpZW50Q29tcG9uZW50TG9hZFN0YXJ0ID09PSAwKSB7XG4gICAgICAgIGNsaWVudENvbXBvbmVudExvYWRTdGFydCA9IHN0YXJ0VGltZVxuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICBjbGllbnRDb21wb25lbnRMb2FkQ291bnQgKz0gMVxuICAgICAgICByZXR1cm4gQ29tcG9uZW50TW9kLl9fbmV4dF9hcHBfXy5yZXF1aXJlKC4uLmFyZ3MpXG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBjbGllbnRDb21wb25lbnRMb2FkVGltZXMgKz0gcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydFRpbWVcbiAgICAgIH1cbiAgICB9LFxuICAgIGxvYWRDaHVuazogKC4uLmFyZ3MpID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgICBjb25zdCByZXN1bHQgPSBDb21wb25lbnRNb2QuX19uZXh0X2FwcF9fLmxvYWRDaHVuayguLi5hcmdzKVxuICAgICAgLy8gQXZvaWQgd3JhcHBpbmcgYGxvYWRDaHVua2AncyByZXN1bHQgaW4gYW4gZXh0cmEgcHJvbWlzZSBpbiBjYXNlIHNvbWV0aGluZyBsaWtlIFJlYWN0IGRlcGVuZHMgb24gaXRzIGlkZW50aXR5LlxuICAgICAgLy8gV2Ugb25seSBuZWVkIHRvIGtub3cgd2hlbiBpdCdzIHNldHRsZWQuXG4gICAgICByZXN1bHQuZmluYWxseSgoKSA9PiB7XG4gICAgICAgIGNsaWVudENvbXBvbmVudExvYWRUaW1lcyArPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZVxuICAgICAgfSlcbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9LFxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDbGllbnRDb21wb25lbnRMb2FkZXJNZXRyaWNzKFxuICBvcHRpb25zOiB7IHJlc2V0PzogYm9vbGVhbiB9ID0ge31cbikge1xuICBjb25zdCBtZXRyaWNzID1cbiAgICBjbGllbnRDb21wb25lbnRMb2FkU3RhcnQgPT09IDBcbiAgICAgID8gdW5kZWZpbmVkXG4gICAgICA6IHtcbiAgICAgICAgICBjbGllbnRDb21wb25lbnRMb2FkU3RhcnQsXG4gICAgICAgICAgY2xpZW50Q29tcG9uZW50TG9hZFRpbWVzLFxuICAgICAgICAgIGNsaWVudENvbXBvbmVudExvYWRDb3VudCxcbiAgICAgICAgfVxuXG4gIGlmIChvcHRpb25zLnJlc2V0KSB7XG4gICAgY2xpZW50Q29tcG9uZW50TG9hZFN0YXJ0ID0gMFxuICAgIGNsaWVudENvbXBvbmVudExvYWRUaW1lcyA9IDBcbiAgICBjbGllbnRDb21wb25lbnRMb2FkQ291bnQgPSAwXG4gIH1cblxuICByZXR1cm4gbWV0cmljc1xufVxuIl0sIm5hbWVzIjpbImNsaWVudENvbXBvbmVudExvYWRTdGFydCIsImNsaWVudENvbXBvbmVudExvYWRUaW1lcyIsImNsaWVudENvbXBvbmVudExvYWRDb3VudCIsIndyYXBDbGllbnRDb21wb25lbnRMb2FkZXIiLCJDb21wb25lbnRNb2QiLCJnbG9iYWxUaGlzIiwiX19uZXh0X2FwcF9fIiwicmVxdWlyZSIsImFyZ3MiLCJzdGFydFRpbWUiLCJwZXJmb3JtYW5jZSIsIm5vdyIsImxvYWRDaHVuayIsInJlc3VsdCIsImZpbmFsbHkiLCJnZXRDbGllbnRDb21wb25lbnRMb2FkZXJNZXRyaWNzIiwib3B0aW9ucyIsIm1ldHJpY3MiLCJ1bmRlZmluZWQiLCJyZXNldCJdLCJtYXBwaW5ncyI6IkFBRUEsb0RBQW9EOzs7OztBQUNwRCxJQUFJQSwyQkFBMkI7QUFDL0IsSUFBSUMsMkJBQTJCO0FBQy9CLElBQUlDLDJCQUEyQjtBQUV4QixTQUFTQywwQkFDZEMsWUFBMkI7SUFFM0IsSUFBSSxDQUFFLENBQUEsaUJBQWlCQyxVQUFTLEdBQUk7UUFDbEMsT0FBT0QsYUFBYUUsWUFBWTtJQUNsQztJQUVBLE9BQU87UUFDTEMsU0FBUyxDQUFDLEdBQUdDO1lBQ1gsTUFBTUMsWUFBWUMsWUFBWUMsR0FBRztZQUVqQyxJQUFJWCw2QkFBNkIsR0FBRztnQkFDbENBLDJCQUEyQlM7WUFDN0I7WUFFQSxJQUFJO2dCQUNGUCw0QkFBNEI7Z0JBQzVCLE9BQU9FLGFBQWFFLFlBQVksQ0FBQ0MsT0FBTyxJQUFJQztZQUM5QyxTQUFVO2dCQUNSUCw0QkFBNEJTLFlBQVlDLEdBQUcsS0FBS0Y7WUFDbEQ7UUFDRjtRQUNBRyxXQUFXLENBQUMsR0FBR0o7WUFDYixNQUFNQyxZQUFZQyxZQUFZQyxHQUFHO1lBQ2pDLE1BQU1FLFNBQVNULGFBQWFFLFlBQVksQ0FBQ00sU0FBUyxJQUFJSjtZQUN0RCxnSEFBZ0g7WUFDaEgsMENBQTBDO1lBQzFDSyxPQUFPQyxPQUFPLENBQUM7Z0JBQ2JiLDRCQUE0QlMsWUFBWUMsR0FBRyxLQUFLRjtZQUNsRDtZQUNBLE9BQU9JO1FBQ1Q7SUFDRjtBQUNGO0FBRU8sU0FBU0UsZ0NBQ2RDLFVBQStCLENBQUMsQ0FBQztJQUVqQyxNQUFNQyxVQUNKakIsNkJBQTZCLElBQ3pCa0IsWUFDQTtRQUNFbEI7UUFDQUM7UUFDQUM7SUFDRjtJQUVOLElBQUljLFFBQVFHLEtBQUssRUFBRTtRQUNqQm5CLDJCQUEyQjtRQUMzQkMsMkJBQTJCO1FBQzNCQywyQkFBMkI7SUFDN0I7SUFFQSxPQUFPZTtBQUNUIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDMxOTcsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NyYy9zZXJ2ZXIvcGlwZS1yZWFkYWJsZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IFNlcnZlclJlc3BvbnNlIH0gZnJvbSAnbm9kZTpodHRwJ1xuXG5pbXBvcnQge1xuICBSZXNwb25zZUFib3J0ZWROYW1lLFxuICBjcmVhdGVBYm9ydENvbnRyb2xsZXIsXG59IGZyb20gJy4vd2ViL3NwZWMtZXh0ZW5zaW9uL2FkYXB0ZXJzL25leHQtcmVxdWVzdCdcbmltcG9ydCB7IERldGFjaGVkUHJvbWlzZSB9IGZyb20gJy4uL2xpYi9kZXRhY2hlZC1wcm9taXNlJ1xuaW1wb3J0IHsgZ2V0VHJhY2VyIH0gZnJvbSAnLi9saWIvdHJhY2UvdHJhY2VyJ1xuaW1wb3J0IHsgTmV4dE5vZGVTZXJ2ZXJTcGFuIH0gZnJvbSAnLi9saWIvdHJhY2UvY29uc3RhbnRzJ1xuaW1wb3J0IHsgZ2V0Q2xpZW50Q29tcG9uZW50TG9hZGVyTWV0cmljcyB9IGZyb20gJy4vY2xpZW50LWNvbXBvbmVudC1yZW5kZXJlci1sb2dnZXInXG5cbmV4cG9ydCBmdW5jdGlvbiBpc0Fib3J0RXJyb3IoZTogYW55KTogZSBpcyBFcnJvciAmIHsgbmFtZTogJ0Fib3J0RXJyb3InIH0ge1xuICByZXR1cm4gZT8ubmFtZSA9PT0gJ0Fib3J0RXJyb3InIHx8IGU/Lm5hbWUgPT09IFJlc3BvbnNlQWJvcnRlZE5hbWVcbn1cblxuZnVuY3Rpb24gY3JlYXRlV3JpdGVyRnJvbVJlc3BvbnNlKFxuICByZXM6IFNlcnZlclJlc3BvbnNlLFxuICB3YWl0VW50aWxGb3JFbmQ/OiBQcm9taXNlPHVua25vd24+XG4pOiBXcml0YWJsZVN0cmVhbTxVaW50OEFycmF5PiB7XG4gIGxldCBzdGFydGVkID0gZmFsc2VcblxuICAvLyBDcmVhdGUgYSBwcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIG9uY2UgdGhlIHJlc3BvbnNlIGhhcyBkcmFpbmVkLiBTZWVcbiAgLy8gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9zdHJlYW0uaHRtbCNzdHJlYW1fZXZlbnRfZHJhaW5cbiAgbGV0IGRyYWluZWQgPSBuZXcgRGV0YWNoZWRQcm9taXNlPHZvaWQ+KClcbiAgZnVuY3Rpb24gb25EcmFpbigpIHtcbiAgICBkcmFpbmVkLnJlc29sdmUoKVxuICB9XG4gIHJlcy5vbignZHJhaW4nLCBvbkRyYWluKVxuXG4gIC8vIElmIHRoZSBmaW5pc2ggZXZlbnQgZmlyZXMsIGl0IG1lYW5zIHdlIHNob3VsZG4ndCBibG9jayBhbmQgd2FpdCBmb3IgdGhlXG4gIC8vIGRyYWluIGV2ZW50LlxuICByZXMub25jZSgnY2xvc2UnLCAoKSA9PiB7XG4gICAgcmVzLm9mZignZHJhaW4nLCBvbkRyYWluKVxuICAgIGRyYWluZWQucmVzb2x2ZSgpXG4gIH0pXG5cbiAgLy8gQ3JlYXRlIGEgcHJvbWlzZSB0aGF0IHdpbGwgcmVzb2x2ZSBvbmNlIHRoZSByZXNwb25zZSBoYXMgZmluaXNoZWQuIFNlZVxuICAvLyBodHRwczovL25vZGVqcy5vcmcvYXBpL2h0dHAuaHRtbCNldmVudC1maW5pc2hfMVxuICBjb25zdCBmaW5pc2hlZCA9IG5ldyBEZXRhY2hlZFByb21pc2U8dm9pZD4oKVxuICByZXMub25jZSgnZmluaXNoJywgKCkgPT4ge1xuICAgIGZpbmlzaGVkLnJlc29sdmUoKVxuICB9KVxuXG4gIC8vIENyZWF0ZSBhIHdyaXRhYmxlIHN0cmVhbSB0aGF0IHdpbGwgd3JpdGUgdG8gdGhlIHJlc3BvbnNlLlxuICByZXR1cm4gbmV3IFdyaXRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+KHtcbiAgICB3cml0ZTogYXN5bmMgKGNodW5rKSA9PiB7XG4gICAgICAvLyBZb3UnZCB0aGluayB3ZSdkIHdhbnQgdG8gdXNlIGBzdGFydGAgaW5zdGVhZCBvZiBwbGFjaW5nIHRoaXMgaW4gYHdyaXRlYFxuICAgICAgLy8gYnV0IHRoaXMgZW5zdXJlcyB0aGF0IHdlIGRvbid0IGFjdHVhbGx5IGZsdXNoIHRoZSBoZWFkZXJzIHVudGlsIHdlJ3ZlXG4gICAgICAvLyBzdGFydGVkIHdyaXRpbmcgY2h1bmtzLlxuICAgICAgaWYgKCFzdGFydGVkKSB7XG4gICAgICAgIHN0YXJ0ZWQgPSB0cnVlXG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICdwZXJmb3JtYW5jZScgaW4gZ2xvYmFsVGhpcyAmJlxuICAgICAgICAgIHByb2Nlc3MuZW52Lk5FWFRfT1RFTF9QRVJGT1JNQU5DRV9QUkVGSVhcbiAgICAgICAgKSB7XG4gICAgICAgICAgY29uc3QgbWV0cmljcyA9IGdldENsaWVudENvbXBvbmVudExvYWRlck1ldHJpY3MoKVxuICAgICAgICAgIGlmIChtZXRyaWNzKSB7XG4gICAgICAgICAgICBwZXJmb3JtYW5jZS5tZWFzdXJlKFxuICAgICAgICAgICAgICBgJHtwcm9jZXNzLmVudi5ORVhUX09URUxfUEVSRk9STUFOQ0VfUFJFRklYfTpuZXh0LWNsaWVudC1jb21wb25lbnQtbG9hZGluZ2AsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdGFydDogbWV0cmljcy5jbGllbnRDb21wb25lbnRMb2FkU3RhcnQsXG4gICAgICAgICAgICAgICAgZW5kOlxuICAgICAgICAgICAgICAgICAgbWV0cmljcy5jbGllbnRDb21wb25lbnRMb2FkU3RhcnQgK1xuICAgICAgICAgICAgICAgICAgbWV0cmljcy5jbGllbnRDb21wb25lbnRMb2FkVGltZXMsXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXMuZmx1c2hIZWFkZXJzKClcbiAgICAgICAgZ2V0VHJhY2VyKCkudHJhY2UoXG4gICAgICAgICAgTmV4dE5vZGVTZXJ2ZXJTcGFuLnN0YXJ0UmVzcG9uc2UsXG4gICAgICAgICAge1xuICAgICAgICAgICAgc3Bhbk5hbWU6ICdzdGFydCByZXNwb25zZScsXG4gICAgICAgICAgfSxcbiAgICAgICAgICAoKSA9PiB1bmRlZmluZWRcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBvayA9IHJlcy53cml0ZShjaHVuaylcblxuICAgICAgICAvLyBBZGRlZCBieSB0aGUgYGNvbXByZXNzaW9uYCBtaWRkbGV3YXJlLCB0aGlzIGlzIGEgZnVuY3Rpb24gdGhhdCB3aWxsXG4gICAgICAgIC8vIGZsdXNoIHRoZSBwYXJ0aWFsbHktY29tcHJlc3NlZCByZXNwb25zZSB0byB0aGUgY2xpZW50LlxuICAgICAgICBpZiAoJ2ZsdXNoJyBpbiByZXMgJiYgdHlwZW9mIHJlcy5mbHVzaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJlcy5mbHVzaCgpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgd3JpdGUgcmV0dXJucyBmYWxzZSwgaXQgbWVhbnMgdGhlcmUncyBzb21lIGJhY2twcmVzc3VyZSwgc29cbiAgICAgICAgLy8gd2FpdCB1bnRpbCBpdCdzIHN0cmVhbWVkIGJlZm9yZSBjb250aW51aW5nLlxuICAgICAgICBpZiAoIW9rKSB7XG4gICAgICAgICAgYXdhaXQgZHJhaW5lZC5wcm9taXNlXG5cbiAgICAgICAgICAvLyBSZXNldCB0aGUgZHJhaW5lZCBwcm9taXNlIHNvIHRoYXQgd2UgY2FuIHdhaXQgZm9yIHRoZSBuZXh0IGRyYWluIGV2ZW50LlxuICAgICAgICAgIGRyYWluZWQgPSBuZXcgRGV0YWNoZWRQcm9taXNlPHZvaWQ+KClcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJlcy5lbmQoKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZhaWxlZCB0byB3cml0ZSBjaHVuayB0byByZXNwb25zZScsIHsgY2F1c2U6IGVyciB9KVxuICAgICAgfVxuICAgIH0sXG4gICAgYWJvcnQ6IChlcnIpID0+IHtcbiAgICAgIGlmIChyZXMud3JpdGFibGVGaW5pc2hlZCkgcmV0dXJuXG5cbiAgICAgIHJlcy5kZXN0cm95KGVycilcbiAgICB9LFxuICAgIGNsb3NlOiBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBpZiBhIHdhaXRVbnRpbCBwcm9taXNlIHdhcyBwYXNzZWQsIHdhaXQgZm9yIGl0IHRvIHJlc29sdmUgYmVmb3JlXG4gICAgICAvLyBlbmRpbmcgdGhlIHJlc3BvbnNlLlxuICAgICAgaWYgKHdhaXRVbnRpbEZvckVuZCkge1xuICAgICAgICBhd2FpdCB3YWl0VW50aWxGb3JFbmRcbiAgICAgIH1cblxuICAgICAgaWYgKHJlcy53cml0YWJsZUZpbmlzaGVkKSByZXR1cm5cblxuICAgICAgcmVzLmVuZCgpXG4gICAgICByZXR1cm4gZmluaXNoZWQucHJvbWlzZVxuICAgIH0sXG4gIH0pXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwaXBlVG9Ob2RlUmVzcG9uc2UoXG4gIHJlYWRhYmxlOiBSZWFkYWJsZVN0cmVhbTxVaW50OEFycmF5PixcbiAgcmVzOiBTZXJ2ZXJSZXNwb25zZSxcbiAgd2FpdFVudGlsRm9yRW5kPzogUHJvbWlzZTx1bmtub3duPlxuKSB7XG4gIHRyeSB7XG4gICAgLy8gSWYgdGhlIHJlc3BvbnNlIGhhcyBhbHJlYWR5IGVycm9yZWQsIHRoZW4ganVzdCByZXR1cm4gbm93LlxuICAgIGNvbnN0IHsgZXJyb3JlZCwgZGVzdHJveWVkIH0gPSByZXNcbiAgICBpZiAoZXJyb3JlZCB8fCBkZXN0cm95ZWQpIHJldHVyblxuXG4gICAgLy8gQ3JlYXRlIGEgbmV3IEFib3J0Q29udHJvbGxlciBzbyB0aGF0IHdlIGNhbiBhYm9ydCB0aGUgcmVhZGFibGUgaWYgdGhlXG4gICAgLy8gY2xpZW50IGRpc2Nvbm5lY3RzLlxuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBjcmVhdGVBYm9ydENvbnRyb2xsZXIocmVzKVxuXG4gICAgY29uc3Qgd3JpdGVyID0gY3JlYXRlV3JpdGVyRnJvbVJlc3BvbnNlKHJlcywgd2FpdFVudGlsRm9yRW5kKVxuXG4gICAgYXdhaXQgcmVhZGFibGUucGlwZVRvKHdyaXRlciwgeyBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsIH0pXG4gIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgLy8gSWYgdGhpcyBpc24ndCByZWxhdGVkIHRvIGFuIGFib3J0IGVycm9yLCByZS10aHJvdyBpdC5cbiAgICBpZiAoaXNBYm9ydEVycm9yKGVycikpIHJldHVyblxuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdmYWlsZWQgdG8gcGlwZSByZXNwb25zZScsIHsgY2F1c2U6IGVyciB9KVxuICB9XG59XG4iXSwibmFtZXMiOlsiUmVzcG9uc2VBYm9ydGVkTmFtZSIsImNyZWF0ZUFib3J0Q29udHJvbGxlciIsIkRldGFjaGVkUHJvbWlzZSIsImdldFRyYWNlciIsIk5leHROb2RlU2VydmVyU3BhbiIsImdldENsaWVudENvbXBvbmVudExvYWRlck1ldHJpY3MiLCJpc0Fib3J0RXJyb3IiLCJlIiwibmFtZSIsImNyZWF0ZVdyaXRlckZyb21SZXNwb25zZSIsInJlcyIsIndhaXRVbnRpbEZvckVuZCIsInN0YXJ0ZWQiLCJkcmFpbmVkIiwib25EcmFpbiIsInJlc29sdmUiLCJvbiIsIm9uY2UiLCJvZmYiLCJmaW5pc2hlZCIsIldyaXRhYmxlU3RyZWFtIiwid3JpdGUiLCJjaHVuayIsImdsb2JhbFRoaXMiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9PVEVMX1BFUkZPUk1BTkNFX1BSRUZJWCIsIm1ldHJpY3MiLCJwZXJmb3JtYW5jZSIsIm1lYXN1cmUiLCJzdGFydCIsImNsaWVudENvbXBvbmVudExvYWRTdGFydCIsImVuZCIsImNsaWVudENvbXBvbmVudExvYWRUaW1lcyIsImZsdXNoSGVhZGVycyIsInRyYWNlIiwic3RhcnRSZXNwb25zZSIsInNwYW5OYW1lIiwidW5kZWZpbmVkIiwib2siLCJmbHVzaCIsInByb21pc2UiLCJlcnIiLCJFcnJvciIsImNhdXNlIiwiYWJvcnQiLCJ3cml0YWJsZUZpbmlzaGVkIiwiZGVzdHJveSIsImNsb3NlIiwicGlwZVRvTm9kZVJlc3BvbnNlIiwicmVhZGFibGUiLCJlcnJvcmVkIiwiZGVzdHJveWVkIiwi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bUVBQW1FO1lBQ25FLHVCQUF1QjtZQUN2QixJQUFJckMsaUJBQWlCO2dCQUNuQixNQUFNQTtZQUNSO1lBRUEsSUFBSUQsSUFBSW9DLGdCQUFnQixFQUFFO1lBRTFCcEMsSUFBSXNCLEdBQUc7WUFDUCxPQUFPYixTQUFTc0IsT0FBTztRQUN6QjtJQUNGO0FBQ0Y7QUFFTyxlQUFlUSxtQkFDcEJDLFFBQW9DLEVBQ3BDeEMsR0FBbUIsRUFDbkJDLGVBQWtDO0lBRWxDLElBQUk7UUFDRiw2REFBNkQ7UUFDN0QsTUFBTSxFQUFFd0MsT0FBTyxFQUFFQyxTQUFTLEVBQUUsR0FBRzFDO1FBQy9CLElBQUl5QyxXQUFXQyxXQUFXO1FBRTFCLHdFQUF3RTtRQUN4RSxzQkFBc0I7UUFDdEIsTUFBTUMsYUFBYXBELDhOQUFBQSxFQUFzQlM7UUFFekMsTUFBTTRDLFNBQVM3Qyx5QkFBeUJDLEtBQUtDO1FBRTdDLE1BQU11QyxTQUFTSyxNQUFNLENBQUNELFFBQVE7WUFBRUUsUUFBUUgsV0FBV0csTUFBTTtRQUFDO0lBQzVELEVBQUUsT0FBT2QsS0FBVTtRQUNqQix3REFBd0Q7UUFDeEQsSUFBSXBDLGFBQWFvQyxNQUFNO1FBRXZCLE1BQU0sT0FBQSxjQUFvRCxDQUFwRCxJQUFJQyxNQUFNLDJCQUEyQjtZQUFFQyxPQUFPRjtRQUFJLElBQWxELHFCQUFBO21CQUFBO3dCQUFBOzBCQUFBO1FBQW1EO0lBQzNEO0FBQ0YiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMzMyNiwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL3NlcnZlci9yZW5kZXItcmVzdWx0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgT3V0Z29pbmdIdHRwSGVhZGVycywgU2VydmVyUmVzcG9uc2UgfSBmcm9tICdodHRwJ1xuaW1wb3J0IHR5cGUgeyBDYWNoZUNvbnRyb2wgfSBmcm9tICcuL2xpYi9jYWNoZS1jb250cm9sJ1xuaW1wb3J0IHR5cGUgeyBGZXRjaE1ldHJpY3MgfSBmcm9tICcuL2Jhc2UtaHR0cCdcblxuaW1wb3J0IHtcbiAgY2hhaW5TdHJlYW1zLFxuICBzdHJlYW1Gcm9tQnVmZmVyLFxuICBzdHJlYW1Gcm9tU3RyaW5nLFxuICBzdHJlYW1Ub0J1ZmZlcixcbiAgc3RyZWFtVG9TdHJpbmcsXG59IGZyb20gJy4vc3RyZWFtLXV0aWxzL25vZGUtd2ViLXN0cmVhbXMtaGVscGVyJ1xuaW1wb3J0IHsgaXNBYm9ydEVycm9yLCBwaXBlVG9Ob2RlUmVzcG9uc2UgfSBmcm9tICcuL3BpcGUtcmVhZGFibGUnXG5pbXBvcnQgdHlwZSB7IFJlbmRlclJlc3VtZURhdGFDYWNoZSB9IGZyb20gJy4vcmVzdW1lLWRhdGEtY2FjaGUvcmVzdW1lLWRhdGEtY2FjaGUnXG5cbnR5cGUgQ29udGVudFR5cGVPcHRpb24gPSBzdHJpbmcgfCB1bmRlZmluZWRcblxuZXhwb3J0IHR5cGUgQXBwUGFnZVJlbmRlclJlc3VsdE1ldGFkYXRhID0ge1xuICBmbGlnaHREYXRhPzogQnVmZmVyXG4gIGNhY2hlQ29udHJvbD86IENhY2hlQ29udHJvbFxuICBzdGF0aWNCYWlsb3V0SW5mbz86IHtcbiAgICBzdGFjaz86IHN0cmluZ1xuICAgIGRlc2NyaXB0aW9uPzogc3RyaW5nXG4gIH1cblxuICAvKipcbiAgICogVGhlIHBvc3Rwb25lZCBzdGF0ZSBpZiB0aGUgcmVuZGVyIGhhZCBwb3N0cG9uZWQgYW5kIG5lZWRzIHRvIGJlIHJlc3VtZWQuXG4gICAqL1xuICBwb3N0cG9uZWQ/OiBzdHJpbmdcblxuICAvKipcbiAgICogVGhlIGhlYWRlcnMgdG8gc2V0IG9uIHRoZSByZXNwb25zZSB0aGF0IHdlcmUgYWRkZWQgYnkgdGhlIHJlbmRlci5cbiAgICovXG4gIGhlYWRlcnM/OiBPdXRnb2luZ0h0dHBIZWFkZXJzXG4gIHN0YXR1c0NvZGU/OiBudW1iZXJcbiAgZmV0Y2hUYWdzPzogc3RyaW5nXG4gIGZldGNoTWV0cmljcz86IEZldGNoTWV0cmljc1xuXG4gIHNlZ21lbnREYXRhPzogTWFwPHN0cmluZywgQnVmZmVyPlxuXG4gIC8qKlxuICAgKiBJbiBkZXZlbG9wbWVudCwgdGhlIHJlc3VtZSBkYXRhIGNhY2hlIGlzIHdhcm1lZCB1cCBiZWZvcmUgdGhlIHJlbmRlci4gVGhpc1xuICAgKiBpcyBhdHRhY2hlZCB0byB0aGUgbWV0YWRhdGEgc28gdGhhdCBpdCBjYW4gYmUgdXNlZCBkdXJpbmcgdGhlIHJlbmRlci4gV2hlblxuICAgKiBwcmVyZW5kZXJpbmcsIHRoZSBmaWxsZWQgcmVzdW1lIGRhdGEgY2FjaGUgaXMgYWxzbyBhdHRhY2hlZCB0byB0aGUgbWV0YWRhdGFcbiAgICogc28gdGhhdCBpdCBjYW4gYmUgdXNlZCB3aGVuIHByZXJlbmRlcmluZyBtYXRjaGluZyBmYWxsYmFjayBzaGVsbHMuXG4gICAqL1xuICByZW5kZXJSZXN1bWVEYXRhQ2FjaGU/OiBSZW5kZXJSZXN1bWVEYXRhQ2FjaGVcbn1cblxuZXhwb3J0IHR5cGUgUGFnZXNSZW5kZXJSZXN1bHRNZXRhZGF0YSA9IHtcbiAgcGFnZURhdGE/OiBhbnlcbiAgY2FjaGVDb250cm9sPzogQ2FjaGVDb250cm9sXG4gIGFzc2V0UXVlcnlTdHJpbmc/OiBzdHJpbmdcbiAgaXNOb3RGb3VuZD86IGJvb2xlYW5cbiAgaXNSZWRpcmVjdD86IGJvb2xlYW5cbn1cblxuZXhwb3J0IHR5cGUgU3RhdGljUmVuZGVyUmVzdWx0TWV0YWRhdGEgPSB7fVxuXG5leHBvcnQgdHlwZSBSZW5kZXJSZXN1bHRNZXRhZGF0YSA9IEFwcFBhZ2VSZW5kZXJSZXN1bHRNZXRhZGF0YSAmXG4gIFBhZ2VzUmVuZGVyUmVzdWx0TWV0YWRhdGEgJlxuICBTdGF0aWNSZW5kZXJSZXN1bHRNZXRhZGF0YVxuXG5leHBvcnQgdHlwZSBSZW5kZXJSZXN1bHRSZXNwb25zZSA9XG4gIHwgUmVhZGFibGVTdHJlYW08VWludDhBcnJheT5bXVxuICB8IFJlYWRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+XG4gIHwgc3RyaW5nXG4gIHwgQnVmZmVyXG4gIHwgbnVsbFxuXG5leHBvcnQgdHlwZSBSZW5kZXJSZXN1bHRPcHRpb25zPFxuICBNZXRhZGF0YSBleHRlbmRzIFJlbmRlclJlc3VsdE1ldGFkYXRhID0gUmVuZGVyUmVzdWx0TWV0YWRhdGEsXG4+ID0ge1xuICBjb250ZW50VHlwZT86IENvbnRlbnRUeXBlT3B0aW9uXG4gIHdhaXRVbnRpbD86IFByb21pc2U8dW5rbm93bj5cbiAgbWV0YWRhdGE6IE1ldGFkYXRhXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlbmRlclJlc3VsdDxcbiAgTWV0YWRhdGEgZXh0ZW5kcyBSZW5kZXJSZXN1bHRNZXRhZGF0YSA9IFJlbmRlclJlc3VsdE1ldGFkYXRhLFxuPiB7XG4gIC8qKlxuICAgKiBUaGUgZGV0ZWN0ZWQgY29udGVudCB0eXBlIGZvciB0aGUgcmVzcG9uc2UuIFRoaXMgaXMgdXNlZCB0byBzZXQgdGhlXG4gICAqIGBDb250ZW50LVR5cGVgIGhlYWRlci5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBjb250ZW50VHlwZTogQ29udGVudFR5cGVPcHRpb25cblxuICAvKipcbiAgICogVGhlIG1ldGFkYXRhIGZvciB0aGUgcmVzcG9uc2UuIFRoaXMgaXMgdXNlZCB0byBzZXQgdGhlIHJldmFsaWRhdGlvbiB0aW1lc1xuICAgKiBhbmQgb3RoZXIgbWV0YWRhdGEuXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgbWV0YWRhdGE6IFJlYWRvbmx5PE1ldGFkYXRhPlxuXG4gIC8qKlxuICAgKiBUaGUgcmVzcG9uc2UgaXRzZWxmLiBUaGlzIGNhbiBiZSBhIHN0cmluZywgYSBzdHJlYW0sIG9yIG51bGwuIElmIGl0J3MgYVxuICAgKiBzdHJpbmcsIHRoZW4gaXQncyBhIHN0YXRpYyByZXNwb25zZS4gSWYgaXQncyBhIHN0cmVhbSwgdGhlbiBpdCdzIGFcbiAgICogZHluYW1pYyByZXNwb25zZS4gSWYgaXQncyBudWxsLCB0aGVuIHRoZSByZXNwb25zZSB3YXMgbm90IGZvdW5kIG9yIHdhc1xuICAgKiBhbHJlYWR5IHNlbnQuXG4gICAqL1xuICBwcml2YXRlIHJlc3BvbnNlOiBSZW5kZXJSZXN1bHRSZXNwb25zZVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFJlbmRlclJlc3VsdCBpbnN0YW5jZSBmcm9tIGEgc3RhdGljIHJlc3BvbnNlLlxuICAgKlxuICAgKiBAcGFyYW0gdmFsdWUgdGhlIHN0YXRpYyByZXNwb25zZSB2YWx1ZVxuICAgKiBAcmV0dXJucyBhIG5ldyBSZW5kZXJSZXN1bHQgaW5zdGFuY2VcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZnJvbVN0YXRpYyh2YWx1ZTogc3RyaW5nIHwgQnVmZmVyKSB7XG4gICAgcmV0dXJuIG5ldyBSZW5kZXJSZXN1bHQ8U3RhdGljUmVuZGVyUmVzdWx0TWV0YWRhdGE+KHZhbHVlLCB7IG1ldGFkYXRhOiB7fSB9KVxuICB9XG5cbiAgcHJpdmF0ZSByZWFkb25seSB3YWl0VW50aWw/OiBQcm9taXNlPHVua25vd24+XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcmVzcG9uc2U6IFJlbmRlclJlc3VsdFJlc3BvbnNlLFxuICAgIHsgY29udGVudFR5cGUsIHdhaXRVbnRpbCwgbWV0YWRhdGEgfTogUmVuZGVyUmVzdWx0T3B0aW9uczxNZXRhZGF0YT5cbiAgKSB7XG4gICAgdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlXG4gICAgdGhpcy5jb250ZW50VHlwZSA9IGNvbnRlbnRUeXBlXG4gICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhXG4gICAgdGhpcy53YWl0VW50aWwgPSB3YWl0VW50aWxcbiAgfVxuXG4gIHB1YmxpYyBhc3NpZ25NZXRhZGF0YShtZXRhZGF0YTogTWV0YWRhdGEpIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMubWV0YWRhdGEsIG1ldGFkYXRhKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcmVzcG9uc2UgaXMgbnVsbC4gSXQgY2FuIGJlIG51bGwgaWYgdGhlIHJlc3BvbnNlIHdhc1xuICAgKiBub3QgZm91bmQgb3Igd2FzIGFscmVhZHkgc2VudC5cbiAgICovXG4gIHB1YmxpYyBnZXQgaXNOdWxsKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnJlc3BvbnNlID09PSBudWxsXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBmYWxzZSBpZiB0aGUgcmVzcG9uc2UgaXMgYSBzdHJpbmcuIEl0IGNhbiBiZSBhIHN0cmluZyBpZiB0aGUgcGFnZVxuICAgKiB3YXMgcHJlcmVuZGVyZWQuIElmIGl0J3Mgbm90LCB0aGVuIGl0IHdhcyBnZW5lcmF0ZWQgZHluYW1pY2FsbHkuXG4gICAqL1xuICBwdWJsaWMgZ2V0IGlzRHluYW1pYygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaXMucmVzcG9uc2UgIT09ICdzdHJpbmcnXG4gIH1cblxuICBwdWJsaWMgdG9VbmNodW5rZWRCdWZmZXIoc3RyZWFtPzogZmFsc2UpOiBCdWZmZXJcbiAgcHVibGljIHRvVW5jaHVua2VkQnVmZmVyKHN0cmVhbTogdHJ1ZSk6IFByb21pc2U8QnVmZmVyPlxuICBwdWJsaWMgdG9VbmNodW5rZWRCdWZmZXIoc3RyZWFtID0gZmFsc2UpOiBQcm9taXNlPEJ1ZmZlcj4gfCBCdWZmZXIge1xuICAgIGlmICh0aGlzLnJlc3BvbnNlID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFyaWFudDogbnVsbCByZXNwb25zZXMgY2Fubm90IGJlIHVuY2h1bmtlZCcpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0aGlzLnJlc3BvbnNlICE9PSAnc3RyaW5nJykge1xuICAgICAgaWYgKCFzdHJlYW0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdJbnZhcmlhbnQ6IGR5bmFtaWMgcmVzcG9uc2VzIGNhbm5vdCBiZSB1bmNodW5rZWQuIFRoaXMgaXMgYSBidWcgaW4gTmV4dC5qcydcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RyZWFtVG9CdWZmZXIodGhpcy5yZWFkYWJsZSlcbiAgICB9XG5cbiAgICByZXR1cm4gQnVmZmVyLmZyb20odGhpcy5yZXNwb25zZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByZXNwb25zZSBpZiBpdCBpcyBhIHN0cmluZy4gSWYgdGhlIHBhZ2Ugd2FzIGR5bmFtaWMsIHRoaXMgd2lsbFxuICAgKiByZXR1cm4gYSBwcm9taXNlIGlmIHRoZSBgc3RyZWFtYCBvcHRpb24gaXMgdHJ1ZSwgb3IgaXQgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAgICpcbiAgICogQHBhcmFtIHN0cmVhbSBXaGV0aGVyIG9yIG5vdCB0byByZXR1cm4gYSBwcm9taXNlIGlmIHRoZSByZXNwb25zZSBpcyBkeW5hbWljXG4gICAqIEByZXR1cm5zIFRoZSByZXNwb25zZSBhcyBhIHN0cmluZ1xuICAgKi9cbiAgcHVibGljIHRvVW5jaHVua2VkU3RyaW5nKHN0cmVhbT86IGZhbHNlKTogc3RyaW5nXG4gIHB1YmxpYyB0b1VuY2h1bmtlZFN0cmluZyhzdHJlYW06IHRydWUpOiBQcm9taXNlPHN0cmluZz5cbiAgcHVibGljIHRvVW5jaHVua2VkU3RyaW5nKHN0cmVhbSA9IGZhbHNlKTogUHJvbWlzZTxzdHJpbmc+IHwgc3RyaW5nIHtcbiAgICBpZiAodGhpcy5yZXNwb25zZSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhcmlhbnQ6IG51bGwgcmVzcG9uc2VzIGNhbm5vdCBiZSB1bmNodW5rZWQnKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGhpcy5yZXNwb25zZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGlmICghc3RyZWFtKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnSW52YXJpYW50OiBkeW5hbWljIHJlc3BvbnNlcyBjYW5ub3QgYmUgdW5jaHVua2VkLiBUaGlzIGlzIGEgYnVnIGluIE5leHQuanMnXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0cmVhbVRvU3RyaW5nKHRoaXMucmVhZGFibGUpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucmVzcG9uc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByZXNwb25zZSBpZiBpdCBpcyBhIHN0cmVhbSwgb3IgdGhyb3dzIGFuIGVycm9yIGlmIGl0IGlzIGFcbiAgICogc3RyaW5nLlxuICAgKi9cbiAgcHJpdmF0ZSBnZXQgcmVhZGFibGUoKTogUmVhZGFibGVTdHJlYW08VWludDhBcnJheT4ge1xuICAgIGlmICh0aGlzLnJlc3BvbnNlID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFyaWFudDogbnVsbCByZXNwb25zZXMgY2Fubm90IGJlIHN0cmVhbWVkJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0aGlzLnJlc3BvbnNlID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhcmlhbnQ6IHN0YXRpYyByZXNwb25zZXMgY2Fubm90IGJlIHN0cmVhbWVkJylcbiAgICB9XG5cbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHRoaXMucmVzcG9uc2UpKSB7XG4gICAgICByZXR1cm4gc3RyZWFtRnJvbUJ1ZmZlcih0aGlzLnJlc3BvbnNlKVxuICAgIH1cblxuICAgIC8vIElmIHRoZSByZXNwb25zZSBpcyBhbiBhcnJheSBvZiBzdHJlYW1zLCB0aGVuIGNoYWluIHRoZW0gdG9nZXRoZXIuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5yZXNwb25zZSkpIHtcbiAgICAgIHJldHVybiBjaGFpblN0cmVhbXMoLi4udGhpcy5yZXNwb25zZSlcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5yZXNwb25zZVxuICB9XG5cbiAgLyoqXG4gICAqIENoYWlucyBhIG5ldyBzdHJlYW0gdG8gdGhlIHJlc3BvbnNlLiBUaGlzIHdpbGwgY29udmVydCB0aGUgcmVzcG9uc2UgdG8gYW5cbiAgICogYXJyYXkgb2Ygc3RyZWFtcyBpZiBpdCBpcyBub3QgYWxyZWFkeSBvbmUgYW5kIHdpbGwgYWRkIHRoZSBuZXcgc3RyZWFtIHRvXG4gICAqIHRoZSBlbmQuIFdoZW4gdGhpcyByZXNwb25zZSBpcyBwaXBlZCwgYWxsIG9mIHRoZSBzdHJlYW1zIHdpbGwgYmUgcGlwZWRcbiAgICogb25lIGFmdGVyIHRoZSBvdGhlci5cbiAgICpcbiAgICogQHBhcmFtIHJlYWRhYmxlIFRoZSBuZXcgc3RyZWFtIHRvIGNoYWluXG4gICAqL1xuICBwdWJsaWMgY2hhaW4ocmVhZGFibGU6IFJlYWRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+KSB7XG4gICAgaWYgKHRoaXMucmVzcG9uc2UgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YXJpYW50OiByZXNwb25zZSBpcyBudWxsLiBUaGlzIGlzIGEgYnVnIGluIE5leHQuanMnKVxuICAgIH1cblxuICAgIC8vIElmIHRoZSByZXNwb25zZSBpcyBub3QgYW4gYXJyYXkgb2Ygc3RyZWFtcyBhbHJlYWR5LCBtYWtlIGl0IG9uZS5cbiAgICBsZXQgcmVzcG9uc2VzOiBSZWFkYWJsZVN0cmVhbTxVaW50OEFycmF5PltdXG4gICAgaWYgKHR5cGVvZiB0aGlzLnJlc3BvbnNlID09PSAnc3RyaW5nJykge1xuICAgICAgcmVzcG9uc2VzID0gW3N0cmVhbUZyb21TdHJpbmcodGhpcy5yZXNwb25zZSldXG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHRoaXMucmVzcG9uc2UpKSB7XG4gICAgICByZXNwb25zZXMgPSB0aGlzLnJlc3BvbnNlXG4gICAgfSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIodGhpcy5yZXNwb25zZSkpIHtcbiAgICAgIHJlc3BvbnNlcyA9IFtzdHJlYW1Gcm9tQnVmZmVyKHRoaXMucmVzcG9uc2UpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXNwb25zZXMgPSBbdGhpcy5yZXNwb25zZV1cbiAgICB9XG5cbiAgICAvLyBBZGQgdGhlIG5ldyBzdHJlYW0gdG8gdGhlIGFycmF5LlxuICAgIHJlc3BvbnNlcy5wdXNoKHJlYWRhYmxlKVxuXG4gICAgLy8gVXBkYXRlIHRoZSByZXNwb25zZS5cbiAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2VzXG4gIH1cblxuICAvKipcbiAgICogUGlwZXMgdGhlIHJlc3BvbnNlIHRvIGEgd3JpdGFibGUgc3RyZWFtLiBUaGlzIHdpbGwgY2xvc2UvY2FuY2VsIHRoZVxuICAgKiB3cml0YWJsZSBzdHJlYW0gaWYgYW4gZXJyb3IgaXMgZW5jb3VudGVyZWQuIElmIHRoaXMgZG9lc24ndCB0aHJvdywgdGhlblxuICAgKiB0aGUgd3JpdGFibGUgc3RyZWFtIHdpbGwgYmUgY2xvc2VkIG9yIGFib3J0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB3cml0YWJsZSBXcml0YWJsZSBzdHJlYW0gdG8gcGlwZSB0aGUgcmVzcG9uc2UgdG9cbiAgICovXG4gIHB1YmxpYyBhc3luYyBwaXBlVG8od3JpdGFibGU6IFdyaXRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMucmVhZGFibGUucGlwZVRvKHdyaXRhYmxlLCB7XG4gICAgICAgIC8vIFdlIHdhbnQgdG8gY2xvc2UgdGhlIHdyaXRhYmxlIHN0cmVhbSBvdXJzZWx2ZXMgc28gdGhhdCB3ZSBjYW4gd2FpdFxuICAgICAgICAvLyBmb3IgdGhlIHdhaXRVbnRpbCBwcm9taXNlIHRvIHJlc29sdmUgYmVmb3JlIGNsb3NpbmcgaXQuIElmIGFuIGVycm9yXG4gICAgICAgIC8vIGlzIGVuY291bnRlcmVkLCB3ZSdsbCBhYm9ydCB0aGUgd3JpdGFibGUgc3RyZWFtIGlmIHdlIHN3YWxsb3dlZCB0aGVcbiAgICAgICAgLy8gZXJyb3IuXG4gICAgICAgIHByZXZlbnRDbG9zZTogdHJ1ZSxcbiAgICAgIH0pXG5cbiAgICAgIC8vIElmIHRoZXJlIGlzIGEgd2FpdFVudGlsIHByb21pc2UsIHdhaXQgZm9yIGl0IHRvIHJlc29sdmUgYmVmb3JlXG4gICAgICAvLyBjbG9zaW5nIHRoZSB3cml0YWJsZSBzdHJlYW0uXG4gICAgICBpZiAodGhpcy53YWl0VW50aWwpIGF3YWl0IHRoaXMud2FpdFVudGlsXG5cbiAgICAgIC8vIENsb3NlIHRoZSB3cml0YWJsZSBzdHJlYW0uXG4gICAgICBhd2FpdCB3cml0YWJsZS5jbG9zZSgpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBJZiB0aGlzIGlzIGFuIGFib3J0IGVycm9yLCB3ZSBzaG91bGQgYWJvcnQgdGhlIHdyaXRhYmxlIHN0cmVhbSAoYXMgd2VcbiAgICAgIC8vIHRvb2sgb3duZXJzaGlwIG9mIGl0IHdoZW4gd2Ugc3RhcnRlZCBwaXBpbmcpLiBXZSBkb24ndCBuZWVkIHRvIHJlLXRocm93XG4gICAgICAvLyBiZWNhdXNlIHdlIGhhbmRsZWQgdGhlIGVycm9yLlxuICAgICAgaWYgKGlzQWJvcnRFcnJvcihlcnIpKSB7XG4gICAgICAgIC8vIEFib3J0IHRoZSB3cml0YWJsZSBzdHJlYW0gaWYgYW4gZXJyb3IgaXMgZW5jb3VudGVyZWQuXG4gICAgICAgIGF3YWl0IHdyaXRhYmxlLmFib3J0KGVycilcblxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gV2UncmUgbm90IGFib3J0aW5nIHRoZSB3cml0ZXIgaGVyZSBhcyB3aGVuIHRoaXMgbWV0aG9kIHRocm93cyBpdCdzIG5vdFxuICAgICAgLy8gY2xlYXIgYXMgdG8gaG93IHNvIHRoZSBjYWxsZXIgc2hvdWxkIGFzc3VtZSBpdCdzIHRoZWlyIHJlc3BvbnNpYmlsaXR5XG4gICAgICAvLyB0byBjbGVhbiB1cCB0aGUgd3JpdGVyLlxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBpcGVzIHRoZSByZXNwb25zZSB0byBhIG5vZGUgcmVzcG9uc2UuIFRoaXMgd2lsbCBjbG9zZS9jYW5jZWwgdGhlIG5vZGVcbiAgICogcmVzcG9uc2UgaWYgYW4gZXJyb3IgaXMgZW5jb3VudGVyZWQuXG4gICAqXG4gICAqIEBwYXJhbSByZXNcbiAgICovXG4gIHB1YmxpYyBhc3luYyBwaXBlVG9Ob2RlUmVzcG9uc2UocmVzOiBTZXJ2ZXJSZXNwb25zZSkge1xuICAgIGF3YWl0IHBpcGVUb05vZGVSZXNwb25zZSh0aGlzLnJlYWRhYmxlLCByZXMsIHRoaXMud2FpdFVudGlsKVxuICB9XG59XG4iXSwibmFtZXMiOlsiY2hhaW5TdHJlYW1zIiwic3RyZWFtRnJvbUJ1ZmZlciIsInN0cmVhbUZyb21TdHJpbmciLCJzdHJlYW1Ub0J1ZmZlciIsInN0cmVhbVRvU3RyaW5nIiwiaXNBYm9ydEVycm9yIiwicGlwZVRvTm9kZVJlc3BvbnNlIiwiUmVuZGVyUmVzdWx0IiwiZnJvbVN0YXRpYyIsInZhbHVlIiwibWV0YWRhdGEiLCJjb25zdHJ1Y3RvciIsInJlc3BvbnNlIiwiY29udGVudFR5cGUiLCJ3YWl0VW50aWwiLCJhc3NpZ25NZXRhZGF0YSIsIk9iamVjdCIsImFzc2lnbiIsImlzTnVsbCIsImlzRHluYW1pYyIsInRvVW5jaHVua2VkQnVmZmVyIiwic3RyZWFtIiwiRXJyb3IiLCJyZWFkYWJsZSIsIkJ1ZmZlciIsImZyb20iLCJ0b1VuY2h1bmtlZFN0cmluZyIsImlzQnVmZmVyIiwiQXJyYXkiLCJpc0FycmF5IiwiY2hhaW4iLCJyZXNwb25zZXMiLCJwdXNoIiwicGlwZVRvIiwid3JpdGFibGUiLCJwcmV2ZW50Q2xvc2UiLCJjbG9zZSIsImVyciIsImFib3J0IiwicmVzIl0sIm1hcHBpbmdzIjoiOzs7QUFJQSxTQUNFQSxZQUFZLEVBQ1pDLGdCQUFnQixFQUNoQkMsZ0JBQWdCLEVBQ2hCQyxjQUFjLEVBQ2RDLGNBQWMsUUFDVCx5Q0FBd0M7QUFDL0MsU0FBU0MsWUFBWSxFQUFFQyxrQkFBa0IsUUFBUSxrQkFBaUI7OztBQWtFbkQsTUFBTUM7SUF1Qm5COzs7OztHQUtDLEdBQ0QsT0FBY0MsV0FBV0MsS0FBc0IsRUFBRTtRQUMvQyxPQUFPLElBQUlGLGFBQXlD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QUF3RDtnQkFDeEQsTUFBTUgsU0FBU0ksS0FBSyxDQUFDRDtnQkFFckI7WUFDRjtZQUVBLHlFQUF5RTtZQUN6RSx3RUFBd0U7WUFDeEUsMEJBQTBCO1lBQzFCLE1BQU1BO1FBQ1I7SUFDRjtJQUVBOzs7OztHQUtDLEdBQ0QsTUFBYS9CLG1CQUFtQmlDLEdBQW1CLEVBQUU7UUFDbkQscUtBQU1qQyxxQkFBQUEsRUFBbUIsSUFBSSxDQUFDaUIsUUFBUSxFQUFFZ0IsS0FBSyxJQUFJLENBQUN6QixTQUFTO0lBQzdEO0FBQ0YiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMzUxNywgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL3NlcnZlci9yZXNwb25zZS1jYWNoZS91dGlscy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBDYWNoZWRSb3V0ZUtpbmQsXG4gIEluY3JlbWVudGFsQ2FjaGVLaW5kLFxuICB0eXBlIENhY2hlZEFwcFBhZ2VWYWx1ZSxcbiAgdHlwZSBDYWNoZWRQYWdlVmFsdWUsXG4gIHR5cGUgSW5jcmVtZW50YWxSZXNwb25zZUNhY2hlRW50cnksXG4gIHR5cGUgUmVzcG9uc2VDYWNoZUVudHJ5LFxufSBmcm9tICcuL3R5cGVzJ1xuXG5pbXBvcnQgUmVuZGVyUmVzdWx0IGZyb20gJy4uL3JlbmRlci1yZXN1bHQnXG5pbXBvcnQgeyBSb3V0ZUtpbmQgfSBmcm9tICcuLi9yb3V0ZS1raW5kJ1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZnJvbVJlc3BvbnNlQ2FjaGVFbnRyeShcbiAgY2FjaGVFbnRyeTogUmVzcG9uc2VDYWNoZUVudHJ5XG4pOiBQcm9taXNlPEluY3JlbWVudGFsUmVzcG9uc2VDYWNoZUVudHJ5PiB7XG4gIHJldHVybiB7XG4gICAgLi4uY2FjaGVFbnRyeSxcbiAgICB2YWx1ZTpcbiAgICAgIGNhY2hlRW50cnkudmFsdWU/LmtpbmQgPT09IENhY2hlZFJvdXRlS2luZC5QQUdFU1xuICAgICAgICA/IHtcbiAgICAgICAgICAgIGtpbmQ6IENhY2hlZFJvdXRlS2luZC5QQUdFUyxcbiAgICAgICAgICAgIGh0bWw6IGF3YWl0IGNhY2hlRW50cnkudmFsdWUuaHRtbC50b1VuY2h1bmtlZFN0cmluZyh0cnVlKSxcbiAgICAgICAgICAgIHBhZ2VEYXRhOiBjYWNoZUVudHJ5LnZhbHVlLnBhZ2VEYXRhLFxuICAgICAgICAgICAgaGVhZGVyczogY2FjaGVFbnRyeS52YWx1ZS5oZWFkZXJzLFxuICAgICAgICAgICAgc3RhdHVzOiBjYWNoZUVudHJ5LnZhbHVlLnN0YXR1cyxcbiAgICAgICAgICB9XG4gICAgICAgIDogY2FjaGVFbnRyeS52YWx1ZT8ua2luZCA9PT0gQ2FjaGVkUm91dGVLaW5kLkFQUF9QQUdFXG4gICAgICAgICAgPyB7XG4gICAgICAgICAgICAgIGtpbmQ6IENhY2hlZFJvdXRlS2luZC5BUFBfUEFHRSxcbiAgICAgICAgICAgICAgaHRtbDogYXdhaXQgY2FjaGVFbnRyeS52YWx1ZS5odG1sLnRvVW5jaHVua2VkU3RyaW5nKHRydWUpLFxuICAgICAgICAgICAgICBwb3N0cG9uZWQ6IGNhY2hlRW50cnkudmFsdWUucG9zdHBvbmVkLFxuICAgICAgICAgICAgICByc2NEYXRhOiBjYWNoZUVudHJ5LnZhbHVlLnJzY0RhdGEsXG4gICAgICAgICAgICAgIGhlYWRlcnM6IGNhY2hlRW50cnkudmFsdWUuaGVhZGVycyxcbiAgICAgICAgICAgICAgc3RhdHVzOiBjYWNoZUVudHJ5LnZhbHVlLnN0YXR1cyxcbiAgICAgICAgICAgICAgc2VnbWVudERhdGE6IGNhY2hlRW50cnkudmFsdWUuc2VnbWVudERhdGEsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgOiBjYWNoZUVudHJ5LnZhbHVlLFxuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB0b1Jlc3BvbnNlQ2FjaGVFbnRyeShcbiAgcmVzcG9uc2U6IEluY3JlbWVudGFsUmVzcG9uc2VDYWNoZUVudHJ5IHwgbnVsbFxuKTogUHJvbWlzZTxSZXNwb25zZUNhY2hlRW50cnkgfCBudWxsPiB7XG4gIGlmICghcmVzcG9uc2UpIHJldHVybiBudWxsXG5cbiAgcmV0dXJuIHtcbiAgICBpc01pc3M6IHJlc3BvbnNlLmlzTWlzcyxcbiAgICBpc1N0YWxlOiByZXNwb25zZS5pc1N0YWxlLFxuICAgIGNhY2hlQ29udHJvbDogcmVzcG9uc2UuY2FjaGVDb250cm9sLFxuICAgIHZhbHVlOlxuICAgICAgcmVzcG9uc2UudmFsdWU/LmtpbmQgPT09IENhY2hlZFJvdXRlS2luZC5QQUdFU1xuICAgICAgICA/ICh7XG4gICAgICAgICAgICBraW5kOiBDYWNoZWRSb3V0ZUtpbmQuUEFHRVMsXG4gICAgICAgICAgICBodG1sOiBSZW5kZXJSZXN1bHQuZnJvbVN0YXRpYyhyZXNwb25zZS52YWx1ZS5odG1sKSxcbiAgICAgICAgICAgIHBhZ2VEYXRhOiByZXNwb25zZS52YWx1ZS5wYWdlRGF0YSxcbiAgICAgICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlLnZhbHVlLmhlYWRlcnMsXG4gICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnZhbHVlLnN0YXR1cyxcbiAgICAgICAgICB9IHNhdGlzZmllcyBDYWNoZWRQYWdlVmFsdWUpXG4gICAgICAgIDogcmVzcG9uc2UudmFsdWU/LmtpbmQgPT09IENhY2hlZFJvdXRlS2luZC5BUFBfUEFHRVxuICAgICAgICAgID8gKHtcbiAgICAgICAgICAgICAga2luZDogQ2FjaGVkUm91dGVLaW5kLkFQUF9QQUdFLFxuICAgICAgICAgICAgICBodG1sOiBSZW5kZXJSZXN1bHQuZnJvbVN0YXRpYyhyZXNwb25zZS52YWx1ZS5odG1sKSxcbiAgICAgICAgICAgICAgcnNjRGF0YTogcmVzcG9uc2UudmFsdWUucnNjRGF0YSxcbiAgICAgICAgICAgICAgaGVhZGVyczogcmVzcG9uc2UudmFsdWUuaGVhZGVycyxcbiAgICAgICAgICAgICAgc3RhdHVzOiByZXNwb25zZS52YWx1ZS5zdGF0dXMsXG4gICAgICAgICAgICAgIHBvc3Rwb25lZDogcmVzcG9uc2UudmFsdWUucG9zdHBvbmVkLFxuICAgICAgICAgICAgICBzZWdtZW50RGF0YTogcmVzcG9uc2UudmFsdWUuc2VnbWVudERhdGEsXG4gICAgICAgICAgICB9IHNhdGlzZmllcyBDYWNoZWRBcHBQYWdlVmFsdWUpXG4gICAgICAgICAgOiByZXNwb25zZS52YWx1ZSxcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcm91dGVLaW5kVG9JbmNyZW1lbnRhbENhY2hlS2luZChcbiAgcm91dGVLaW5kOiBSb3V0ZUtpbmRcbik6IEV4Y2x1ZGU8SW5jcmVtZW50YWxDYWNoZUtpbmQsIEluY3JlbWVudGFsQ2FjaGVLaW5kLkZFVENIPiB7XG4gIHN3aXRjaCAocm91dGVLaW5kKSB7XG4gICAgY2FzZSBSb3V0ZUtpbmQuUEFHRVM6XG4gICAgICByZXR1cm4gSW5jcmVtZW50YWxDYWNoZUtpbmQuUEFHRVNcbiAgICBjYXNlIFJvdXRlS2luZC5BUFBfUEFHRTpcbiAgICAgIHJldHVybiBJbmNyZW1lbnRhbENhY2hlS2luZC5BUFBfUEFHRVxuICAgIGNhc2UgUm91dGVLaW5kLklNQUdFOlxuICAgICAgcmV0dXJuIEluY3JlbWVudGFsQ2FjaGVLaW5kLklNQUdFXG4gICAgY2FzZSBSb3V0ZUtpbmQuQVBQX1JPVVRFOlxuICAgICAgcmV0dXJuIEluY3JlbWVudGFsQ2FjaGVLaW5kLkFQUF9ST1VURVxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgcm91dGUga2luZCAke3JvdXRlS2luZH1gKVxuICB9XG59XG4iXSwibmFtZXMiOlsiQ2FjaGVkUm91dGVLaW5kIiwiSW5jcmVtZW50YWxDYWNoZUtpbmQiLCJSZW5kZXJSZXN1bHQiLCJSb3V0ZUtpbmQiLCJmcm9tUmVzcG9uc2VDYWNoZUVudHJ5IiwiY2FjaGVFbnRyeSIsInZhbHVlIiwia2luZCIsIlBBR0VTIiwiaHRtbCIsInRvVW5jaHVua2VkU3RyaW5nIiwicGFnZURhdGEiLCJoZWFkZXJzIiwic3RhdHVzIiwiQVBQX1BBR0UiLCJwb3N0cG9uZWQiLCJyc2NEYXRhIiwic2VnbWVudERhdGEiLCJ0b1Jlc3BvbnNlQ2FjaGVFbnRyeSIsInJlc3BvbnNlIiwiaXNNaXNzIiwiaXNTdGFsZSIsImNhY2hlQ29udHJvbCIsImZyb21TdGF0aWMiLCJyb3V0ZUtpbmRUb0luY3JlbWVudGFsQ2FjaGVLaW5kIiwicm91dGVLaW5kIiwiSU1BR0UiLCJBUFBfUk9VVEUiLCJFcnJvciJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxTQUNFQSxlQUFlLEVBQ2ZDLG9CQUFvQixRQUtmLFVBQVM7QUFFaEIsT0FBT0Msa0JBQWtCLG1CQUFrQjtBQUMzQyxTQUFTQyxTQUFTLFFBQVEsZ0JBQWU7Ozs7QUFFbEMsZUFBZUMsdUJBQ3BCQyxVQUE4QjtRQUsxQkEsbUJBUUlBO0lBWFIsT0FBTztRQUNMLEdBQUdBLFVBQVU7UUFDYkMsT0FDRUQsQ0FBQUEsQ0FBQUEsb0JBQUFBLFdBQVdDLEtBQUssS0FBQSxPQUFBLEtBQUEsSUFBaEJELGtCQUFrQkUsSUFBSSwyS0FBS1Asa0JBQUFBLENBQWdCUSxLQUFLLEdBQzVDO1lBQ0VELDJLQUFNUCxrQkFBQUEsQ0FBZ0JRLEtBQUs7WUFDM0JDLE1BQU0sTUFBTUosV0FBV0MsS0FBSyxDQUFDRyxJQUFJLENBQUNDLGlCQUFpQixDQUFDO1lBQ3BEQyxVQUFVTixXQUFXQyxLQUFLLENBQUNLLFFBQVE7WUFDbkNDLFNBQVNQLFdBQVdDLEtBQUssQ0FBQ00sT0FBTztZQUNqQ0MsUUFBUVIsV0FBV0MsS0FBSyxDQUFDTyxNQUFNO1FBQ2pDLElBQ0FSLENBQUFBLENBQUFBLHFCQUFBQSxXQUFXQyxLQUFLLEtBQUEsT0FBQSxLQUFBLElBQWhCRCxtQkFBa0JFLElBQUksMktBQUtQLGtCQUFBQSxDQUFnQmMsUUFBUSxHQUNqRDtZQUNFUCwyS0FBTVAsa0JBQUFBLENBQWdCYyxRQUFRO1lBQzlCTCxNQUFNLE1BQU1KLFdBQVdDLEtBQUssQ0FBQ0csSUFBSSxDQUFDQyxpQkFBaUIsQ0FBQztZQUNwREssV0FBV1YsV0FBV0MsS0FBSyxDQUFDUyxTQUFTO1lBQ3JDQyxTQUFTWCxXQUFXQyxLQUFLLENBQUNVLE9BQU87WUFDakNKLFNBQVNQLFdBQVdDLEtBQUssQ0FBQ00sT0FBTztZQUNqQ0MsUUFBUVIsV0FBV0MsS0FBSyxDQUFDTyxNQUFNO1lBQy9CSSxhQUFhWixXQUFXQyxLQUFLLENBQUNXLFdBQVc7UUFDM0MsSUFDQVosV0FBV0MsS0FBSztJQUMxQjtBQUNGO0FBRU8sZUFBZVkscUJBQ3BCQyxRQUE4QztRQVMxQ0EsaUJBUUlBO0lBZlIsSUFBSSxDQUFDQSxVQUFVLE9BQU87SUFFdEIsT0FBTztRQUNMQyxRQUFRRCxTQUFTQyxNQUFNO1FBQ3ZCQyxTQUFTRixTQUFTRSxPQUFPO1FBQ3pCQyxjQUFjSCxTQUFTRyxZQUFZO1FBQ25DaEIsT0FDRWEsQ0FBQUEsQ0FBQUEsa0JBQUFBLFNBQVNiLEtBQUssS0FBQSxPQUFBLEtBQUEsSUFBZGEsZ0JBQWdCWixJQUFJLDJLQUFLUCxrQkFBQUEsQ0FBZ0JRLEtBQUssR0FDekM7WUFDQ0QsMktBQU1QLGtCQUFBQSxDQUFnQlEsS0FBSztZQUMzQkMsaUtBQU1QLFVBQUFBLENBQWFxQixVQUFVLENBQUNKLFNBQVNiLEtBQUssQ0FBQ0csSUFBSTtZQUNqREUsVUFBVVEsU0FBU2IsS0FBSyxDQUFDSyxRQUFRO1lBQ2pDQyxTQUFTTyxTQUFTYixLQUFLLENBQUNNLE9BQU87WUFDL0JDLFFBQVFNLFNBQVNiLEtBQUssQ0FBQ08sTUFBTTtRQUMvQixJQUNBTSxDQUFBQSxDQUFBQSxtQkFBQUEsU0FBU2IsS0FBSyxLQUFBLE9BQUEsS0FBQSxJQUFkYSxpQkFBZ0JaLElBQUksMktBQUtQLGtCQUFBQSxDQUFnQmMsUUFBUSxHQUM5QztZQUNDUCwyS0FBTVAsa0JBQUFBLENBQWdCYyxRQUFRO1lBQzlCTCxpS0FBTVAsVUFBQUEsQ0FBYXFCLFVBQVUsQ0FBQ0osU0FBU2IsS0FBSyxDQUFDRyxJQUFJO1lBQ2pETyxTQUFTRyxTQUFTYixLQUFLLENBQUNVLE9BQU87WUFDL0JKLFNBQVNPLFNBQVNiLEtBQUssQ0FBQ00sT0FBTztZQUMvQkMsUUFBUU0sU0FBU2IsS0FBSyxDQUFDTyxNQUFNO1lBQzdCRSxXQUFXSSxTQUFTYixLQUFLLENBQUNTLFNBQVM7WUFDbkNFLGFBQWFFLFNBQVNiLEtBQUssQ0FBQ1csV0FBVztRQUN6QyxJQUNBRSxTQUFTYixLQUFLO0lBQ3hCO0FBQ0Y7QUFFTyxTQUFTa0IsZ0NBQ2RDLFNBQW9CO0lBRXBCLE9BQVFBO1FBQ04sNkpBQUt0QixZQUFBQSxDQUFVSyxLQUFLO1lBQ2xCLDRLQUFPUCx1QkFBQUEsQ0FBcUJPLEtBQUs7UUFDbkMsNkpBQUtMLFlBQUFBLENBQVVXLFFBQVE7WUFDckIsNEtBQU9iLHVCQUFBQSxDQUFxQmEsUUFBUTtRQUN0Qyw2SkFBS1gsWUFBQUEsQ0FBVXVCLEtBQUs7WUFDbEIsNEtBQU96Qix1QkFBQUEsQ0FBcUJ5QixLQUFLO1FBQ25DLDZKQUFLdkIsWUFBQUEsQ0FBVXdCLFNBQVM7WUFDdEIsNEtBQU8xQix1QkFBQUEsQ0FBcUIwQixTQUFTO1FBQ3ZDO1lBQ0UsTUFBTSxPQUFBLGNBQStDLENBQS9DLElBQUlDLE1BQU0sQ0FBQyxzQkFBc0IsRUFBRUgsV0FBVyxHQUE5QyxxQkFBQTt1QkFBQTs0QkFBQTs4QkFBQTtZQUE4QztJQUN4RDtBQUNGIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDM1OTUsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NyYy9zZXJ2ZXIvcmVzcG9uc2UtY2FjaGUvaW5kZXgudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUge1xuICBSZXNwb25zZUNhY2hlRW50cnksXG4gIFJlc3BvbnNlR2VuZXJhdG9yLFxuICBSZXNwb25zZUNhY2hlQmFzZSxcbiAgSW5jcmVtZW50YWxSZXNwb25zZUNhY2hlRW50cnksXG4gIEluY3JlbWVudGFsUmVzcG9uc2VDYWNoZSxcbn0gZnJvbSAnLi90eXBlcydcblxuaW1wb3J0IHsgQmF0Y2hlciB9IGZyb20gJy4uLy4uL2xpYi9iYXRjaGVyJ1xuaW1wb3J0IHsgc2NoZWR1bGVPbk5leHRUaWNrIH0gZnJvbSAnLi4vLi4vbGliL3NjaGVkdWxlcidcbmltcG9ydCB7XG4gIGZyb21SZXNwb25zZUNhY2hlRW50cnksXG4gIHJvdXRlS2luZFRvSW5jcmVtZW50YWxDYWNoZUtpbmQsXG4gIHRvUmVzcG9uc2VDYWNoZUVudHJ5LFxufSBmcm9tICcuL3V0aWxzJ1xuaW1wb3J0IHR5cGUgeyBSb3V0ZUtpbmQgfSBmcm9tICcuLi9yb3V0ZS1raW5kJ1xuXG5leHBvcnQgKiBmcm9tICcuL3R5cGVzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZXNwb25zZUNhY2hlIGltcGxlbWVudHMgUmVzcG9uc2VDYWNoZUJhc2Uge1xuICBwcml2YXRlIHJlYWRvbmx5IGJhdGNoZXIgPSBCYXRjaGVyLmNyZWF0ZTxcbiAgICB7IGtleTogc3RyaW5nOyBpc09uRGVtYW5kUmV2YWxpZGF0ZTogYm9vbGVhbiB9LFxuICAgIEluY3JlbWVudGFsUmVzcG9uc2VDYWNoZUVudHJ5IHwgbnVsbCxcbiAgICBzdHJpbmdcbiAgPih7XG4gICAgLy8gRW5zdXJlIG9uLWRlbWFuZCByZXZhbGlkYXRlIGRvZXNuJ3QgYmxvY2sgbm9ybWFsIHJlcXVlc3RzLCBpdCBzaG91bGQgYmVcbiAgICAvLyBzYWZlIHRvIHJ1biBhbiBvbi1kZW1hbmQgcmV2YWxpZGF0ZSBmb3IgdGhlIHNhbWUga2V5IGFzIGEgbm9ybWFsIHJlcXVlc3QuXG4gICAgY2FjaGVLZXlGbjogKHsga2V5LCBpc09uRGVtYW5kUmV2YWxpZGF0ZSB9KSA9PlxuICAgICAgYCR7a2V5fS0ke2lzT25EZW1hbmRSZXZhbGlkYXRlID8gJzEnIDogJzAnfWAsXG4gICAgLy8gV2Ugd2FpdCB0byBkbyBhbnkgYXN5bmMgd29yayB1bnRpbCBhZnRlciB3ZSd2ZSBhZGRlZCBvdXIgcHJvbWlzZSB0b1xuICAgIC8vIGBwZW5kaW5nUmVzcG9uc2VzYCB0byBlbnN1cmUgdGhhdCBhbnkgYW55IG90aGVyIGNhbGxzIHdpbGwgcmV1c2UgdGhlXG4gICAgLy8gc2FtZSBwcm9taXNlIHVudGlsIHdlJ3ZlIGZ1bGx5IGZpbmlzaGVkIG91ciB3b3JrLlxuICAgIHNjaGVkdWxlckZuOiBzY2hlZHVsZU9uTmV4dFRpY2ssXG4gIH0pXG5cbiAgcHJpdmF0ZSBwcmV2aW91c0NhY2hlSXRlbT86IHtcbiAgICBrZXk6IHN0cmluZ1xuICAgIGVudHJ5OiBJbmNyZW1lbnRhbFJlc3BvbnNlQ2FjaGVFbnRyeSB8IG51bGxcbiAgICBleHBpcmVzQXQ6IG51bWJlclxuICB9XG5cbiAgLy8gd2UgZG9uJ3QgdXNlIG1pbmltYWxfbW9kZSBuYW1lIGhlcmUgYXMgdGhpcy5taW5pbWFsX21vZGUgaXNcbiAgLy8gc3RhdGljYWxseSByZXBsYWNlIGZvciBzZXJ2ZXIgcnVudGltZXMgYnV0IHdlIG5lZWQgaXQgdG9cbiAgLy8gYmUgZHluYW1pYyBoZXJlXG4gIHByaXZhdGUgbWluaW1hbF9tb2RlPzogYm9vbGVhblxuXG4gIGNvbnN0cnVjdG9yKG1pbmltYWxfbW9kZTogYm9vbGVhbikge1xuICAgIHRoaXMubWluaW1hbF9tb2RlID0gbWluaW1hbF9tb2RlXG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZ2V0KFxuICAgIGtleTogc3RyaW5nIHwgbnVsbCxcbiAgICByZXNwb25zZUdlbmVyYXRvcjogUmVzcG9uc2VHZW5lcmF0b3IsXG4gICAgY29udGV4dDoge1xuICAgICAgcm91dGVLaW5kOiBSb3V0ZUtpbmRcbiAgICAgIGlzT25EZW1hbmRSZXZhbGlkYXRlPzogYm9vbGVhblxuICAgICAgaXNQcmVmZXRjaD86IGJvb2xlYW5cbiAgICAgIGluY3JlbWVudGFsQ2FjaGU6IEluY3JlbWVudGFsUmVzcG9uc2VDYWNoZVxuICAgICAgaXNSb3V0ZVBQUkVuYWJsZWQ/OiBib29sZWFuXG4gICAgICBpc0ZhbGxiYWNrPzogYm9vbGVhblxuICAgICAgd2FpdFVudGlsPzogKHByb206IFByb21pc2U8YW55PikgPT4gdm9pZFxuICAgIH1cbiAgKTogUHJvbWlzZTxSZXNwb25zZUNhY2hlRW50cnkgfCBudWxsPiB7XG4gICAgLy8gSWYgdGhlcmUgaXMgbm8ga2V5IGZvciB0aGUgY2FjaGUsIHdlIGNhbid0IHBvc3NpYmx5IGxvb2sgdGhpcyB1cCBpbiB0aGVcbiAgICAvLyBjYWNoZSBzbyBqdXN0IHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSByZXNwb25zZSBnZW5lcmF0b3IuXG4gICAgaWYgKCFrZXkpIHtcbiAgICAgIHJldHVybiByZXNwb25zZUdlbmVyYXRvcih7IGhhc1Jlc29sdmVkOiBmYWxzZSwgcHJldmlvdXNDYWNoZUVudHJ5OiBudWxsIH0pXG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgaW5jcmVtZW50YWxDYWNoZSxcbiAgICAgIGlzT25EZW1hbmRSZXZhbGlkYXRlID0gZmFsc2UsXG4gICAgICBpc0ZhbGxiYWNrID0gZmFsc2UsXG4gICAgICBpc1JvdXRlUFBSRW5hYmxlZCA9IGZhbHNlLFxuICAgICAgd2FpdFVudGlsLFxuICAgIH0gPSBjb250ZXh0XG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYmF0Y2hlci5iYXRjaChcbiAgICAgIHsga2V5LCBpc09uRGVtYW5kUmV2YWxpZGF0ZSB9LFxuICAgICAgKGNhY2hlS2V5LCByZXNvbHZlKSA9PiB7XG4gICAgICAgIGNvbnN0IHByb20gPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIC8vIFdlIGtlZXAgdGhlIHByZXZpb3VzIGNhY2hlIGVudHJ5IGFyb3VuZCB0byBsZXZlcmFnZSB3aGVuIHRoZVxuICAgICAgICAgIC8vIGluY3JlbWVudGFsIGNhY2hlIGlzIGRpc2FibGVkIGluIG1pbmltYWwgbW9kZS5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGlzLm1pbmltYWxfbW9kZSAmJlxuICAgICAgICAgICAgdGhpcy5wcmV2aW91c0NhY2hlSXRlbT8ua2V5ID09PSBjYWNoZUtleSAmJlxuICAgICAgICAgICAgdGhpcy5wcmV2aW91c0NhY2hlSXRlbS5leHBpcmVzQXQgPiBEYXRlLm5vdygpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcmV2aW91c0NhY2hlSXRlbS5lbnRyeVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIENvZXJjZSB0aGUga2luZEhpbnQgaW50byBhIGdpdmVuIGtpbmQgZm9yIHRoZSBpbmNyZW1lbnRhbCBjYWNoZS5cbiAgICAgICAgICBjb25zdCBraW5kID0gcm91dGVLaW5kVG9JbmNyZW1lbnRhbENhY2hlS2luZChjb250ZXh0LnJvdXRlS2luZClcblxuICAgICAgICAgIGxldCByZXNvbHZlZCA9IGZhbHNlXG4gICAgICAgICAgbGV0IGNhY2hlZFJlc3BvbnNlOiBJbmNyZW1lbnRhbFJlc3BvbnNlQ2FjaGVFbnRyeSB8IG51bGwgPSBudWxsXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNhY2hlZFJlc3BvbnNlID0gIXRoaXMubWluaW1hbF9tb2RlXG4gICAgICAgICAgICAgID8gYXdhaXQgaW5jcmVtZW50YWxDYWNoZS5nZXQoa2V5LCB7XG4gICAgICAgICAgICAgICAgICBraW5kLFxuICAgICAgICAgICAgICAgICAgaXNSb3V0ZVBQUkVuYWJsZWQ6IGNvbnRleHQuaXNSb3V0ZVBQUkVuYWJsZWQsXG4gICAgICAgICAgICAgICAgICBpc0ZhbGxiYWNrLFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIDogbnVsbFxuXG4gICAgICAgICAgICBpZiAoY2FjaGVkUmVzcG9uc2UgJiYgIWlzT25EZW1hbmRSZXZhbGlkYXRlKSB7XG4gICAgICAgICAgICAgIHJlc29sdmUoY2FjaGVkUmVzcG9uc2UpXG4gICAgICAgICAgICAgIHJlc29sdmVkID0gdHJ1ZVxuXG4gICAgICAgICAgICAgIGlmICghY2FjaGVkUmVzcG9uc2UuaXNTdGFsZSB8fCBjb250ZXh0LmlzUHJlZmV0Y2gpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgY2FjaGVkIHZhbHVlIGlzIHN0aWxsIHZhbGlkLCBzbyB3ZSBkb24ndCBuZWVkXG4gICAgICAgICAgICAgICAgLy8gdG8gdXBkYXRlIGl0IHlldC5cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGNhY2hlRW50cnkgPSBhd2FpdCByZXNwb25zZUdlbmVyYXRvcih7XG4gICAgICAgICAgICAgIGhhc1Jlc29sdmVkOiByZXNvbHZlZCxcbiAgICAgICAgICAgICAgcHJldmlvdXNDYWNoZUVudHJ5OiBjYWNoZWRSZXNwb25zZSxcbiAgICAgICAgICAgICAgaXNSZXZhbGlkYXRpbmc6IHRydWUsXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAvLyBJZiB0aGUgY2FjaGUgZW50cnkgY291bGRuJ3QgYmUgZ2VuZXJhdGVkLCB3ZSBkb24ndCB3YW50IHRvIGNhY2hlXG4gICAgICAgICAgICAvLyB0aGUgcmVzdWx0LlxuICAgICAgICAgICAgaWYgKCFjYWNoZUVudHJ5KSB7XG4gICAgICAgICAgICAgIC8vIFVuc2V0IHRoZSBwcmV2aW91cyBjYWNoZSBpdGVtIGlmIGl0IHdhcyBzZXQuXG4gICAgICAgICAgICAgIGlmICh0aGlzLm1pbmltYWxfbW9kZSkgdGhpcy5wcmV2aW91c0NhY2hlSXRlbSA9IHVuZGVmaW5lZFxuICAgICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCByZXNvbHZlVmFsdWUgPSBhd2FpdCBmcm9tUmVzcG9uc2VDYWNoZUVudHJ5KHtcbiAgICAgICAgICAgICAgLi4uY2FjaGVFbnRyeSxcbiAgICAgICAgICAgICAgaXNNaXNzOiAhY2FjaGVkUmVzcG9uc2UsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgaWYgKCFyZXNvbHZlVmFsdWUpIHtcbiAgICAgICAgICAgICAgLy8gVW5zZXQgdGhlIHByZXZpb3VzIGNhY2hlIGl0ZW0gaWYgaXQgd2FzIHNldC5cbiAgICAgICAgICAgICAgaWYgKHRoaXMubWluaW1hbF9tb2RlKSB0aGlzLnByZXZpb3VzQ2FjaGVJdGVtID0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZvciBvbi1kZW1hbmQgcmV2YWxpZGF0ZSB3YWl0IHRvIHJlc29sdmUgdW50aWwgY2FjaGUgaXMgc2V0LlxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHJlc29sdmUgbm93LlxuICAgICAgICAgICAgaWYgKCFpc09uRGVtYW5kUmV2YWxpZGF0ZSAmJiAhcmVzb2x2ZWQpIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXNvbHZlVmFsdWUpXG4gICAgICAgICAgICAgIHJlc29sdmVkID0gdHJ1ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBXZSB3YW50IHRvIHBlcnNpc3QgdGhlIHJlc3VsdCBvbmx5IGlmIGl0IGhhcyBhIGNhY2hlIGNvbnRyb2wgdmFsdWVcbiAgICAgICAgICAgIC8vIGRlZmluZWQuXG4gICAgICAgICAgICBpZiAocmVzb2x2ZVZhbHVlLmNhY2hlQ29udHJvbCkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5taW5pbWFsX21vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZpb3VzQ2FjaGVJdGVtID0ge1xuICAgICAgICAgICAgICAgICAga2V5OiBjYWNoZUtleSxcbiAgICAgICAgICAgICAgICAgIGVudHJ5OiByZXNvbHZlVmFsdWUsXG4gICAgICAgICAgICAgICAgICBleHBpcmVzQXQ6IERhdGUubm93KCkgKyAxMDAwLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBpbmNyZW1lbnRhbENhY2hlLnNldChrZXksIHJlc29sdmVWYWx1ZS52YWx1ZSwge1xuICAgICAgICAgICAgICAgICAgY2FjaGVDb250cm9sOiByZXNvbHZlVmFsdWUuY2FjaGVDb250cm9sLFxuICAgICAgICAgICAgICAgICAgaXNSb3V0ZVBQUkVuYWJsZWQsXG4gICAgICAgICAgICAgICAgICBpc0ZhbGxiYWNrLFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVWYWx1ZVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8gV2hlbiBhIHBhdGggaXMgZXJyb3Jpbmcgd2UgYXV0b21hdGljYWxseSByZS1zZXQgdGhlIGV4aXN0aW5nIGNhY2hlXG4gICAgICAgICAgICAvLyB3aXRoIG5ldyByZXZhbGlkYXRlIGFuZCBleHBpcmUgdGltZXMgdG8gcHJldmVudCBub24tc3RvcCByZXRyeWluZy5cbiAgICAgICAgICAgIGlmIChjYWNoZWRSZXNwb25zZT8uY2FjaGVDb250cm9sKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG5ld1JldmFsaWRhdGUgPSBNYXRoLm1pbihcbiAgICAgICAgICAgICAgICBNYXRoLm1heChjYWNoZWRSZXNwb25zZS5jYWNoZUNvbnRyb2wucmV2YWxpZGF0ZSB8fCAzLCAzKSxcbiAgICAgICAgICAgICAgICAzMFxuICAgICAgICAgICAgICApXG5cbiAgICAgICAgICAgICAgY29uc3QgbmV3RXhwaXJlID1cbiAgICAgICAgICAgICAgICBjYWNoZWRSZXNwb25zZS5jYWNoZUNvbnRyb2wuZXhwaXJlID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICA6IE1hdGgubWF4KFxuICAgICAgICAgICAgICAgICAgICAgIG5ld1JldmFsaWRhdGUgKyAzLFxuICAgICAgICAgICAgICAgICAgICAgIGNhY2hlZFJlc3BvbnNlLmNhY2hlQ29udHJvbC5leHBpcmVcbiAgICAgICAgICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICAgIGF3YWl0IGluY3JlbWVudGFsQ2FjaGUuc2V0KGtleSwgY2FjaGVkUmVzcG9uc2UudmFsdWUsIHtcbiAgICAgICAgICAgICAgICBjYWNoZUNvbnRyb2w6IHsgcmV2YWxpZGF0ZTogbmV3UmV2YWxpZGF0ZSwgZXhwaXJlOiBuZXdFeHBpcmUgfSxcbiAgICAgICAgICAgICAgICBpc1JvdXRlUFBSRW5hYmxlZCxcbiAgICAgICAgICAgICAgICBpc0ZhbGxiYWNrLFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBXaGlsZSByZXZhbGlkYXRpbmcgaW4gdGhlIGJhY2tncm91bmQgd2UgY2FuJ3QgcmVqZWN0IGFzIHdlIGFscmVhZHlcbiAgICAgICAgICAgIC8vIHJlc29sdmVkIHRoZSBjYWNoZSBlbnRyeSBzbyBsb2cgdGhlIGVycm9yIGhlcmUuXG4gICAgICAgICAgICBpZiAocmVzb2x2ZWQpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpXG4gICAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFdlIGhhdmVuJ3QgcmVzb2x2ZWQgeWV0LCBzbyBsZXQncyB0aHJvdyB0byBpbmRpY2F0ZSBhbiBlcnJvci5cbiAgICAgICAgICAgIHRocm93IGVyclxuICAgICAgICAgIH1cbiAgICAgICAgfSkoKVxuXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gZW5zdXJlIGJhY2tncm91bmQgcmV2YWxpZGF0ZXMgYXJlXG4gICAgICAgIC8vIHBhc3NlZCB0byB3YWl0VW50aWxcbiAgICAgICAgaWYgKHdhaXRVbnRpbCkge1xuICAgICAgICAgIHdhaXRVbnRpbChwcm9tKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9tXG4gICAgICB9XG4gICAgKVxuXG4gICAgcmV0dXJuIHRvUmVzcG9uc2VDYWNoZUVudHJ5KHJlc3BvbnNlKVxuICB9XG59XG4iXSwibmFtZXMiOlsiQmF0Y2hlciIsInNjaGVkdWxlT25OZXh0VGljayIsImZyb21SZXNwb25zZUNhY2hlRW50cnkiLCJyb3V0ZUtpbmRUb0luY3JlbWVudGFsQ2FjaGVLaW5kIiwidG9SZXNwb25zZUNhY2hlRW50cnkiLCJSZXNwb25zZUNhY2hlIiwiY29uc3RydWN0b3IiLCJtaW5pbWFsX21vZGUiLCJiYXRjaGVyIiwiY3JlYXRlIiwiY2FjaGVLZXlGbiIsImtleSIsImlzT25EZW1hbmRSZXZhbGlkYXRlIiwic2NoZWR1bGVyRm4iLCJnZXQiLCJyZXNwb25zZUdlbmVyYXRvciIsImNvbnRleHQiLCJoYXNSZXNvbHZlZCIsInByZXZpb3VzQ2FjaGVFbnRyeSIsImluY3JlbWVudGFsQ2FjaGUiLCJpc0ZhbGxiYWNrIiwiaXNSb3V0ZVBQUkVuYWJsZWQiLCJ3YWl0VW50aWwiLCJyZXNwb25zZSIsImJhdGNoIiwiY2FjaGVLZXkiLCJyZXNvbHZlIiwicHJvbSIsInByZXZpb3VzQ2FjaGVJdGVtIiwiZXhwaXJlc0F0IiwiRGF0ZSIsIm5vdyIsImVudHJ5Iiwia2luZCIsInJvdXRlS2luZCIsInJlc29sdmVkIiwiY2FjaGVkUmVzcG9uc2UiLCJpc1N0YWxlIiwiaXNQcmVmZXRjaCIsImNhY2hlRW50cnkiLCJpc1JldmFsaWRhdGluZyIsInVuZGVmaW5lZCIsInJlc29sdmVWYWx1ZSIsImlzTWlzcyIsImNhY2hlQ29udHJvbCIsInNldCIsInZhbHVlIiwiZXJyIiwibmV3UmV2YWxpZGF0ZSIsIk1hdGgiLCJtaW4iLCJtYXgiLCJyZXZhbGlkYXRlIiwibmV3RXhwaXJlIiwiZXhwaXJlIiwiY29uc29sZSIsImVycm9yIl0sIm1hcHBpbmdzIjoiOzs7QUFRQSxTQUFTQSxPQUFPLFFBQVEsb0JBQW1CO0FBQzNDLFNBQVNDLGtC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QUNyRSxrREFBa0Q7b0JBQ2xELElBQUllLFVBQVU7d0JBQ1pvQixRQUFRQyxLQUFLLENBQUNUO3dCQUNkLE9BQU87b0JBQ1Q7b0JBRUEsZ0VBQWdFO29CQUNoRSxNQUFNQTtnQkFDUjtZQUNGLENBQUE7WUFFQSwrQ0FBK0M7WUFDL0Msc0JBQXNCO1lBQ3RCLElBQUl6QixXQUFXO2dCQUNiQSxVQUFVSztZQUNaO1lBQ0EsT0FBT0E7UUFDVDtRQUdGLGdMQUFPdkIsdUJBQUFBLEVBQXFCbUI7SUFDOUI7QUFDRiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAzNzUzLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zcmMvYnVpbGQvdGVtcGxhdGVzL2hlbHBlcnMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBIb2lzdHMgYSBuYW1lIGZyb20gYSBtb2R1bGUgb3IgcHJvbWlzZWQgbW9kdWxlLlxuICpcbiAqIEBwYXJhbSBtb2R1bGUgdGhlIG1vZHVsZSB0byBob2lzdCB0aGUgbmFtZSBmcm9tXG4gKiBAcGFyYW0gbmFtZSB0aGUgbmFtZSB0byBob2lzdFxuICogQHJldHVybnMgdGhlIHZhbHVlIG9uIHRoZSBtb2R1bGUgKG9yIHByb21pc2VkIG1vZHVsZSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhvaXN0KG1vZHVsZTogYW55LCBuYW1lOiBzdHJpbmcpIHtcbiAgLy8gSWYgdGhlIG5hbWUgaXMgYXZhaWxhYmxlIGluIHRoZSBtb2R1bGUsIHJldHVybiBpdC5cbiAgaWYgKG5hbWUgaW4gbW9kdWxlKSB7XG4gICAgcmV0dXJuIG1vZHVsZVtuYW1lXVxuICB9XG5cbiAgLy8gSWYgYSBwcm9wZXJ0eSBjYWxsZWQgYHRoZW5gIGV4aXN0cywgYXNzdW1lIGl0J3MgYSBwcm9taXNlIGFuZFxuICAvLyByZXR1cm4gYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIG5hbWUuXG4gIGlmICgndGhlbicgaW4gbW9kdWxlICYmIHR5cGVvZiBtb2R1bGUudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtb2R1bGUudGhlbigobW9kOiBhbnkpID0+IGhvaXN0KG1vZCwgbmFtZSkpXG4gIH1cblxuICAvLyBJZiB3ZSdyZSB0cnlpbmcgdG8gaG9pc2UgdGhlIGRlZmF1bHQgZXhwb3J0LCBhbmQgdGhlIG1vZHVsZSBpcyBhIGZ1bmN0aW9uLFxuICAvLyByZXR1cm4gdGhlIG1vZHVsZSBpdHNlbGYuXG4gIGlmICh0eXBlb2YgbW9kdWxlID09PSAnZnVuY3Rpb24nICYmIG5hbWUgPT09ICdkZWZhdWx0Jykge1xuICAgIHJldHVybiBtb2R1bGVcbiAgfVxuXG4gIC8vIE90aGVyd2lzZSwgcmV0dXJuIHVuZGVmaW5lZC5cbiAgcmV0dXJuIHVuZGVmaW5lZFxufVxuIl0sIm5hbWVzIjpbImhvaXN0IiwibW9kdWxlIiwibmFtZSIsInRoZW4iLCJtb2QiLCJ1bmRlZmluZWQiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Q0FNQyxHQUNEOzs7QUFBTyxTQUFTQSxNQUFNQyxNQUFXLEVBQUVDLElBQVk7SUFDN0MscURBQXFEO0lBQ3JELElBQUlBLFFBQVFELFFBQVE7UUFDbEIsT0FBT0EsTUFBTSxDQUFDQyxLQUFLO0lBQ3JCO0lBRUEsZ0VBQWdFO0lBQ2hFLDhDQUE4QztJQUM5QyxJQUFJLFVBQVVELFVBQVUsT0FBT0EsT0FBT0UsSUFBSSxLQUFLLFlBQVk7UUFDekQsT0FBT0YsT0FBT0UsSUFBSSxDQUFDLENBQUNDLE1BQWFKLE1BQU1JLEtBQUtGO0lBQzlDO0lBRUEsNkVBQTZFO0lBQzdFLDRCQUE0QjtJQUM1QixJQUFJLE9BQU9ELFdBQVcsY0FBY0MsU0FBUyxXQUFXO1FBQ3RELE9BQU9EO0lBQ1Q7SUFFQSwrQkFBK0I7SUFDL0IsT0FBT0k7QUFDVCIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAzNzg2LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzLyU0MHN3Yy9oZWxwZXJzL2Nqcy9faW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKSB7XG4gICAgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsO1xuXG4gICAgdmFyIGNhY2hlQmFiZWxJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTtcbiAgICB2YXIgY2FjaGVOb2RlSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7XG5cbiAgICByZXR1cm4gKF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uKG5vZGVJbnRlcm9wKSB7XG4gICAgICAgIHJldHVybiBub2RlSW50ZXJvcCA/IGNhY2hlTm9kZUludGVyb3AgOiBjYWNoZUJhYmVsSW50ZXJvcDtcbiAgICB9KShub2RlSW50ZXJvcCk7XG59XG5mdW5jdGlvbiBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkKG9iaiwgbm9kZUludGVyb3ApIHtcbiAgICBpZiAoIW5vZGVJbnRlcm9wICYmIG9iaiAmJiBvYmouX19lc01vZHVsZSkgcmV0dXJuIG9iajtcbiAgICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4geyBkZWZhdWx0OiBvYmogfTtcblxuICAgIHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCk7XG5cbiAgICBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHJldHVybiBjYWNoZS5nZXQob2JqKTtcblxuICAgIHZhciBuZXdPYmogPSB7IF9fcHJvdG9fXzogbnVsbCB9O1xuICAgIHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKGtleSAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpO1xuICAgICAgICAgICAgZWxzZSBuZXdPYmpba2V5XSA9IG9ialtrZXldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbmV3T2JqLmRlZmF1bHQgPSBvYmo7XG5cbiAgICBpZiAoY2FjaGUpIGNhY2hlLnNldChvYmosIG5ld09iaik7XG5cbiAgICByZXR1cm4gbmV3T2JqO1xufVxuZXhwb3J0cy5fID0gX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZDtcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFFQSxTQUFTLHlCQUF5QixXQUFXO0lBQ3pDLElBQUksT0FBTyxZQUFZLFlBQVksT0FBTztJQUUxQyxJQUFJLG9CQUFvQixJQUFJO0lBQzVCLElBQUksbUJBQW1CLElBQUk7SUFFM0IsT0FBTyxDQUFDLDJCQUEyQixTQUFTLFdBQVc7UUFDbkQsT0FBTyxjQUFjLG1CQUFtQjtJQUM1QyxDQUFDLEVBQUU7QUFDUDtBQUNBLFNBQVMsMEJBQTBCLEdBQUcsRUFBRSxXQUFXO0lBQy9DLElBQUksQ0FBQyxlQUFlLE9BQU8sSUFBSSxVQUFVLEVBQUUsT0FBTztJQUNsRCxJQUFJLFFBQVEsUUFBUSxPQUFPLFFBQVEsWUFBWSxPQUFPLFFBQVEsWUFBWSxPQUFPO1FBQUUsU0FBUztJQUFJO0lBRWhHLElBQUksUUFBUSx5QkFBeUI7SUFFckMsSUFBSSxTQUFTLE1BQU0sR0FBRyxDQUFDLE1BQU0sT0FBTyxNQUFNLEdBQUcsQ0FBQztJQUU5QyxJQUFJLFNBQVM7UUFBRSxXQUFXO0lBQUs7SUFDL0IsSUFBSSx3QkFBd0IsT0FBTyxjQUFjLElBQUksT0FBTyx3QkFBd0I7SUFFcEYsSUFBSyxJQUFJLE9BQU8sSUFBSztRQUNqQixJQUFJLFFBQVEsYUFBYSxPQUFPLFNBQVMsQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLEtBQUssTUFBTTtZQUNyRSxJQUFJLE9BQU8sd0JBQXdCLE9BQU8sd0JBQXdCLENBQUMsS0FBSyxPQUFPO1lBQy9FLElBQUksUUFBUSxDQUFDLEtBQUssR0FBRyxJQUFJLEtBQUssR0FBRyxHQUFHLE9BQU8sY0FBYyxDQUFDLFFBQVEsS0FBSztpQkFDbEUsTUFBTSxDQUFDLElBQUksR0FBRyxHQUFHLENBQUMsSUFBSTtRQUMvQjtJQUNKO0lBRUEsT0FBTyxPQUFPLEdBQUc7SUFFakIsSUFBSSxPQUFPLE1BQU0sR0FBRyxDQUFDLEtBQUs7SUFFMUIsT0FBTztBQUNYO0FBQ0EsUUFBUSxDQUFDLEdBQUciLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMzgyMywgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9zaGFyZWQvbGliL3NpZGUtZWZmZWN0LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCB7IENoaWxkcmVuLCB1c2VFZmZlY3QsIHVzZUxheW91dEVmZmVjdCwgdHlwZSBKU1ggfSBmcm9tICdyZWFjdCdcblxudHlwZSBTdGF0ZSA9IEpTWC5FbGVtZW50W10gfCB1bmRlZmluZWRcblxuZXhwb3J0IHR5cGUgU2lkZUVmZmVjdFByb3BzID0ge1xuICByZWR1Y2VDb21wb25lbnRzVG9TdGF0ZTogPFQgZXh0ZW5kcyB7fT4oXG4gICAgY29tcG9uZW50czogQXJyYXk8UmVhY3QuUmVhY3RFbGVtZW50PGFueT4+LFxuICAgIHByb3BzOiBUXG4gICkgPT4gU3RhdGVcbiAgaGFuZGxlU3RhdGVDaGFuZ2U/OiAoc3RhdGU6IFN0YXRlKSA9PiB2b2lkXG4gIGhlYWRNYW5hZ2VyOiBhbnlcbiAgaW5BbXBNb2RlPzogYm9vbGVhblxuICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlXG59XG5cbmNvbnN0IGlzU2VydmVyID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCdcbmNvbnN0IHVzZUNsaWVudE9ubHlMYXlvdXRFZmZlY3QgPSBpc1NlcnZlciA/ICgpID0+IHt9IDogdXNlTGF5b3V0RWZmZWN0XG5jb25zdCB1c2VDbGllbnRPbmx5RWZmZWN0ID0gaXNTZXJ2ZXIgPyAoKSA9PiB7fSA6IHVzZUVmZmVjdFxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTaWRlRWZmZWN0KHByb3BzOiBTaWRlRWZmZWN0UHJvcHMpIHtcbiAgY29uc3QgeyBoZWFkTWFuYWdlciwgcmVkdWNlQ29tcG9uZW50c1RvU3RhdGUgfSA9IHByb3BzXG5cbiAgZnVuY3Rpb24gZW1pdENoYW5nZSgpIHtcbiAgICBpZiAoaGVhZE1hbmFnZXIgJiYgaGVhZE1hbmFnZXIubW91bnRlZEluc3RhbmNlcykge1xuICAgICAgY29uc3QgaGVhZEVsZW1lbnRzID0gQ2hpbGRyZW4udG9BcnJheShcbiAgICAgICAgQXJyYXkuZnJvbShoZWFkTWFuYWdlci5tb3VudGVkSW5zdGFuY2VzIGFzIFNldDxSZWFjdC5SZWFjdE5vZGU+KS5maWx0ZXIoXG4gICAgICAgICAgQm9vbGVhblxuICAgICAgICApXG4gICAgICApIGFzIFJlYWN0LlJlYWN0RWxlbWVudFtdXG4gICAgICBoZWFkTWFuYWdlci51cGRhdGVIZWFkKHJlZHVjZUNvbXBvbmVudHNUb1N0YXRlKGhlYWRFbGVtZW50cywgcHJvcHMpKVxuICAgIH1cbiAgfVxuXG4gIGlmIChpc1NlcnZlcikge1xuICAgIGhlYWRNYW5hZ2VyPy5tb3VudGVkSW5zdGFuY2VzPy5hZGQocHJvcHMuY2hpbGRyZW4pXG4gICAgZW1pdENoYW5nZSgpXG4gIH1cblxuICB1c2VDbGllbnRPbmx5TGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBoZWFkTWFuYWdlcj8ubW91bnRlZEluc3RhbmNlcz8uYWRkKHByb3BzLmNoaWxkcmVuKVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBoZWFkTWFuYWdlcj8ubW91bnRlZEluc3RhbmNlcz8uZGVsZXRlKHByb3BzLmNoaWxkcmVuKVxuICAgIH1cbiAgfSlcblxuICAvLyBXZSBuZWVkIHRvIGNhbGwgYHVwZGF0ZUhlYWRgIG1ldGhvZCB3aGVuZXZlciB0aGUgYFNpZGVFZmZlY3RgIGlzIHRyaWdnZXIgaW4gYWxsXG4gIC8vIGxpZmUtY3ljbGVzOiBtb3VudCwgdXBkYXRlLCB1bm1vdW50LiBIb3dldmVyLCBpZiB0aGVyZSBhcmUgbXVsdGlwbGUgYFNpZGVFZmZlY3Rgc1xuICAvLyBiZWluZyByZW5kZXJlZCwgd2Ugb25seSB0cmlnZ2VyIHRoZSBtZXRob2QgZnJvbSB0aGUgbGFzdCBvbmUuXG4gIC8vIFRoaXMgaXMgZW5zdXJlZCBieSBrZWVwaW5nIHRoZSBsYXN0IHVuZmx1c2hlZCBgdXBkYXRlSGVhZGAgaW4gdGhlIGBfcGVuZGluZ1VwZGF0ZWBcbiAgLy8gc2luZ2xldG9uIGluIHRoZSBsYXlvdXQgZWZmZWN0IHBhc3MsIGFuZCBhY3R1YWxseSB0cmlnZ2VyIGl0IGluIHRoZSBlZmZlY3QgcGFzcy5cbiAgdXNlQ2xpZW50T25seUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGhlYWRNYW5hZ2VyKSB7XG4gICAgICBoZWFkTWFuYWdlci5fcGVuZGluZ1VwZGF0ZSA9IGVtaXRDaGFuZ2VcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChoZWFkTWFuYWdlcikge1xuICAgICAgICBoZWFkTWFuYWdlci5fcGVuZGluZ1VwZGF0ZSA9IGVtaXRDaGFuZ2VcbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbiAgdXNlQ2xpZW50T25seUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGhlYWRNYW5hZ2VyICYmIGhlYWRNYW5hZ2VyLl9wZW5kaW5nVXBkYXRlKSB7XG4gICAgICBoZWFkTWFuYWdlci5fcGVuZGluZ1VwZGF0ZSgpXG4gICAgICBoZWFkTWFuYWdlci5fcGVuZGluZ1VwZGF0ZSA9IG51bGxcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChoZWFkTWFuYWdlciAmJiBoZWFkTWFuYWdlci5fcGVuZGluZ1VwZGF0ZSkge1xuICAgICAgICBoZWFkTWFuYWdlci5fcGVuZGluZ1VwZGF0ZSgpXG4gICAgICAgIGhlYWRNYW5hZ2VyLl9wZW5kaW5nVXBkYXRlID0gbnVsbFxuICAgICAgfVxuICAgIH1cbiAgfSlcblxuICByZXR1cm4gbnVsbFxufVxuIl0sIm5hbWVzIjpbIlNpZGVFZmZlY3QiLCJpc1NlcnZlciIsIndpbmRvdyIsInVzZUNsaWVudE9ubHlMYXlvdXRFZmZlY3QiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VDbGllbnRPbmx5RWZmZWN0IiwidXNlRWZmZWN0IiwicHJvcHMiLCJoZWFkTWFuYWdlciIsInJlZHVjZUNvbXBvbmVudHNUb1N0YXRlIiwiZW1pdENoYW5nZSIsIm1vdW50ZWRJbnN0YW5jZXMiLCJoZWFkRWxlbWVudHMiLCJDaGlsZHJlbiIsInRvQXJyYXkiLCJBcnJheSIsImZyb20iLCJmaWx0ZXIiLCJCb29sZWFuIiwidXBkYXRlSGVhZCIsImFkZCIsImNoaWxkcmVuIiwiZGVsZXRlIiwiX3BlbmRpbmdVcGRhdGUiXSwibWFwcGluZ3MiOiI7OzsrQkFvQkEsV0FBQTs7O2VBQXdCQTs7O3VCQW5CdUM7QUFlL0QsTUFBTUMsV0FBVyxPQUFPQyxTQUFXO0FBQ25DLE1BQU1DLDRCQUE0QkYsdUNBQVcsS0FBTyxJQUFJRyxzQkFBZTtBQUN2RSxNQUFNQyxzQkFBc0JKLHVDQUFXLEtBQU8sSUFBSUssZ0JBQVM7QUFFNUMsU0FBU04sV0FBV08sS0FBc0I7SUFDdkQsTUFBTSxFQUFFQyxXQUFXLEVBQUVDLHVCQUF1QixFQUFFLEdBQUdGO0lBRWpELFNBQVNHO1FBQ1AsSUFBSUYsZUFBZUEsWUFBWUcsZ0JBQWdCLEVBQUU7WUFDL0MsTUFBTUMsZUFBZUMsT0FBQUEsUUFBUSxDQUFDQyxPQUFPLENBQ25DQyxNQUFNQyxJQUFJLENBQUNSLFlBQVlHLGdCQUFnQixFQUEwQk0sTUFBTSxDQUNyRUM7WUFHSlYsWUFBWVcsVUFBVSxDQUFDVix3QkFBd0JHLGNBQWNMO1FBQy9EO0lBQ0Y7SUFFQSxJQUFJTixvQ0FBVTtZQUNaTztRQUFBQSxlQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxDQUFBQSxnQ0FBQUEsWUFBYUcsZ0JBQWdCLEtBQUEsT0FBQSxLQUFBLElBQTdCSCw4QkFBK0JZLEdBQUcsQ0FBQ2IsTUFBTWMsUUFBUTtRQUNqRFg7SUFDRjtJQUVBUCwwQkFBMEI7WUFDeEJLO1FBQUFBLGVBQUFBLE9BQUFBLEtBQUFBLElBQUFBLENBQUFBLGdDQUFBQSxZQUFhRyxnQkFBZ0IsS0FBQSxPQUFBLEtBQUEsSUFBN0JILDhCQUErQlksR0FBRyxDQUFDYixNQUFNYyxRQUFRO1FBQ2pELE9BQU87Z0JBQ0xiO1lBQUFBLGVBQUFBLE9BQUFBLEtBQUFBLElBQUFBLENBQUFBLGdDQUFBQSxZQUFhRyxnQkFBZ0IsS0FBQSxPQUFBLEtBQUEsSUFBN0JILDhCQUErQmMsTUFBTSxDQUFDZixNQUFNYyxRQUFRO1FBQ3REO0lBQ0Y7SUFFQSxrRkFBa0Y7SUFDbEYsb0ZBQW9GO0lBQ3BGLGdFQUFnRTtJQUNoRSxxRkFBcUY7SUFDckYsbUZBQW1GO0lBQ25GbEIsMEJBQTBCO1FBQ3hCLElBQUlLLGFBQWE7WUFDZkEsWUFBWWUsY0FBYyxHQUFHYjtRQUMvQjtRQUNBLE9BQU87WUFDTCxJQUFJRixhQUFhO2dCQUNmQSxZQUFZZSxjQUFjLEdBQUdiO1lBQy9CO1FBQ0Y7SUFDRjtJQUVBTCxvQkFBb0I7UUFDbEIsSUFBSUcsZUFBZUEsWUFBWWUsY0FBYyxFQUFFO1lBQzdDZixZQUFZZSxjQUFjO1lBQzFCZixZQUFZZSxjQUFjLEdBQUc7UUFDL0I7UUFDQSxPQUFPO1lBQ0wsSUFBSWYsZUFBZUEsWUFBWWUsY0FBYyxFQUFFO2dCQUM3Q2YsWUFBWWUsY0FBYztnQkFDMUJmLFlBQVllLGNBQWMsR0FBRztZQUMvQjtRQUNGO0lBQ0Y7SUFFQSxPQUFPO0FBQ1QiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMzg5MiwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9zZXJ2ZXIvcm91dGUtbW9kdWxlcy9wYWdlcy92ZW5kb3JlZC9jb250ZXh0cy9hbXAtY29udGV4dC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IChcbiAgcmVxdWlyZSgnLi4vLi4vbW9kdWxlLmNvbXBpbGVkJykgYXMgdHlwZW9mIGltcG9ydCgnLi4vLi4vbW9kdWxlLmNvbXBpbGVkJylcbikudmVuZG9yZWRbJ2NvbnRleHRzJ10uQW1wQ29udGV4dFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIiwidmVuZG9yZWQiLCJBbXBDb250ZXh0Il0sIm1hcHBpbmdzIjoiQUFBQUEsT0FBT0MsT0FBTyxHQUNaQyxRQUFRLHFIQUNSQyxRQUFRLENBQUMsV0FBVyxDQUFDQyxVQUFVIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDM4OTksICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvc2VydmVyL3JvdXRlLW1vZHVsZXMvcGFnZXMvdmVuZG9yZWQvY29udGV4dHMvaGVhZC1tYW5hZ2VyLWNvbnRleHQudHMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSAoXG4gIHJlcXVpcmUoJy4uLy4uL21vZHVsZS5jb21waWxlZCcpIGFzIHR5cGVvZiBpbXBvcnQoJy4uLy4uL21vZHVsZS5jb21waWxlZCcpXG4pLnZlbmRvcmVkWydjb250ZXh0cyddLkhlYWRNYW5hZ2VyQ29udGV4dFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIiwidmVuZG9yZWQiLCJIZWFkTWFuYWdlckNvbnRleHQiXSwibWFwcGluZ3MiOiJBQUFBQSxPQUFPQyxPQUFPLEdBQ1pDLFFBQVEscUhBQ1JDLFFBQVEsQ0FBQyxXQUFXLENBQUNDLGtCQUFrQiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAzOTA2LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL3NoYXJlZC9saWIvYW1wLW1vZGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGlzSW5BbXBNb2RlKHtcbiAgYW1wRmlyc3QgPSBmYWxzZSxcbiAgaHlicmlkID0gZmFsc2UsXG4gIGhhc1F1ZXJ5ID0gZmFsc2UsXG59ID0ge30pOiBib29sZWFuIHtcbiAgcmV0dXJuIGFtcEZpcnN0IHx8IChoeWJyaWQgJiYgaGFzUXVlcnkpXG59XG4iXSwibmFtZXMiOlsiaXNJbkFtcE1vZGUiLCJhbXBGaXJzdCIsImh5YnJpZCIsImhhc1F1ZXJ5Il0sIm1hcHBpbmdzIjoiOzs7K0JBQWdCQSxlQUFBQTs7O2VBQUFBOzs7QUFBVCxTQUFTQSxZQUFZLEtBQUE7SUFBQSxJQUFBLEVBQzFCQyxXQUFXLEtBQUssRUFDaEJDLFNBQVMsS0FBSyxFQUNkQyxXQUFXLEtBQUssRUFDakIsR0FKMkIsVUFBQSxLQUFBLElBSXhCLENBQUMsSUFKdUI7SUFLMUIsT0FBT0YsWUFBYUMsVUFBVUM7QUFDaEMiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMzkyNSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9zaGFyZWQvbGliL3V0aWxzL3dhcm4tb25jZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJsZXQgd2Fybk9uY2UgPSAoXzogc3RyaW5nKSA9PiB7fVxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgY29uc3Qgd2FybmluZ3MgPSBuZXcgU2V0PHN0cmluZz4oKVxuICB3YXJuT25jZSA9IChtc2c6IHN0cmluZykgPT4ge1xuICAgIGlmICghd2FybmluZ3MuaGFzKG1zZykpIHtcbiAgICAgIGNvbnNvbGUud2Fybihtc2cpXG4gICAgfVxuICAgIHdhcm5pbmdzLmFkZChtc2cpXG4gIH1cbn1cblxuZXhwb3J0IHsgd2Fybk9uY2UgfVxuIl0sIm5hbWVzIjpbIndhcm5PbmNlIiwiXyIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsIndhcm5pbmdzIiwiU2V0IiwibXNnIiwiaGFzIiwiY29uc29sZSIsIndhcm4iLCJhZGQiXSwibWFwcGluZ3MiOiI7OzsrQkFXU0EsWUFBQUE7OztlQUFBQTs7O0FBWFQsSUFBSUEsV0FBVyxDQUFDQyxLQUFlO0FBQy9CLElBQUlDLFFBQVFDLEdBQUcsQ0FBQ0MsUUFBUSxLQUFLLFdBQWM7SUFDekMsTUFBTUMsV0FBVyxJQUFJQztJQUNyQk4sV0FBVyxDQUFDTztRQUNWLElBQUksQ0FBQ0YsU0FBU0csR0FBRyxDQUFDRCxNQUFNO1lBQ3RCRSxRQUFRQyxJQUFJLENBQUNIO1FBQ2Y7UUFDQUYsU0FBU00sR0FBRyxDQUFDSjtJQUNmO0FBQ0YiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMzk1MCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9zaGFyZWQvbGliL2hlYWQudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuXG5pbXBvcnQgUmVhY3QsIHsgdXNlQ29udGV4dCwgdHlwZSBKU1ggfSBmcm9tICdyZWFjdCdcbmltcG9ydCBFZmZlY3QgZnJvbSAnLi9zaWRlLWVmZmVjdCdcbmltcG9ydCB7IEFtcFN0YXRlQ29udGV4dCB9IGZyb20gJy4vYW1wLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgeyBIZWFkTWFuYWdlckNvbnRleHQgfSBmcm9tICcuL2hlYWQtbWFuYWdlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHsgaXNJbkFtcE1vZGUgfSBmcm9tICcuL2FtcC1tb2RlJ1xuaW1wb3J0IHsgd2Fybk9uY2UgfSBmcm9tICcuL3V0aWxzL3dhcm4tb25jZSdcblxudHlwZSBXaXRoSW5BbXBNb2RlID0ge1xuICBpbkFtcE1vZGU/OiBib29sZWFuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0SGVhZChpbkFtcE1vZGUgPSBmYWxzZSk6IEpTWC5FbGVtZW50W10ge1xuICBjb25zdCBoZWFkID0gWzxtZXRhIGNoYXJTZXQ9XCJ1dGYtOFwiIGtleT1cImNoYXJzZXRcIiAvPl1cbiAgaWYgKCFpbkFtcE1vZGUpIHtcbiAgICBoZWFkLnB1c2goXG4gICAgICA8bWV0YSBuYW1lPVwidmlld3BvcnRcIiBjb250ZW50PVwid2lkdGg9ZGV2aWNlLXdpZHRoXCIga2V5PVwidmlld3BvcnRcIiAvPlxuICAgIClcbiAgfVxuICByZXR1cm4gaGVhZFxufVxuXG5mdW5jdGlvbiBvbmx5UmVhY3RFbGVtZW50KFxuICBsaXN0OiBBcnJheTxSZWFjdC5SZWFjdEVsZW1lbnQ8YW55Pj4sXG4gIGNoaWxkOiBSZWFjdC5SZWFjdEVsZW1lbnQgfCBudW1iZXIgfCBzdHJpbmdcbik6IEFycmF5PFJlYWN0LlJlYWN0RWxlbWVudDxhbnk+PiB7XG4gIC8vIFJlYWN0IGNoaWxkcmVuIGNhbiBiZSBcInN0cmluZ1wiIG9yIFwibnVtYmVyXCIgaW4gdGhpcyBjYXNlIHdlIGlnbm9yZSB0aGVtIGZvciBiYWNrd2FyZHMgY29tcGF0XG4gIGlmICh0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBjaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gbGlzdFxuICB9XG4gIC8vIEFkZHMgc3VwcG9ydCBmb3IgUmVhY3QuRnJhZ21lbnRcbiAgaWYgKGNoaWxkLnR5cGUgPT09IFJlYWN0LkZyYWdtZW50KSB7XG4gICAgcmV0dXJuIGxpc3QuY29uY2F0KFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBAdHlwZXMvcmVhY3QgZG9lcyBub3QgcmVtb3ZlIGZyYWdtZW50cyBidXQgdGhpcyBjb3VsZCBhbHNvIHJldHVybiBSZWFjdFBvcnRhbFtdXG4gICAgICBSZWFjdC5DaGlsZHJlbi50b0FycmF5KGNoaWxkLnByb3BzLmNoaWxkcmVuKS5yZWR1Y2UoXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgQHR5cGVzL3JlYWN0IGRvZXMgbm90IHJlbW92ZSBmcmFnbWVudHMgYnV0IHRoaXMgY291bGQgYWxzbyByZXR1cm4gUmVhY3RQb3J0YWxbXVxuICAgICAgICAoXG4gICAgICAgICAgZnJhZ21lbnRMaXN0OiBBcnJheTxSZWFjdC5SZWFjdEVsZW1lbnQ8YW55Pj4sXG4gICAgICAgICAgZnJhZ21lbnRDaGlsZDogUmVhY3QuUmVhY3RFbGVtZW50IHwgbnVtYmVyIHwgc3RyaW5nXG4gICAgICAgICk6IEFycmF5PFJlYWN0LlJlYWN0RWxlbWVudDxhbnk+PiA9PiB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgdHlwZW9mIGZyYWdtZW50Q2hpbGQgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgICB0eXBlb2YgZnJhZ21lbnRDaGlsZCA9PT0gJ251bWJlcidcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBmcmFnbWVudExpc3RcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZyYWdtZW50TGlzdC5jb25jYXQoZnJhZ21lbnRDaGlsZClcbiAgICAgICAgfSxcbiAgICAgICAgW11cbiAgICAgIClcbiAgICApXG4gIH1cbiAgcmV0dXJuIGxpc3QuY29uY2F0KGNoaWxkKVxufVxuXG5jb25zdCBNRVRBVFlQRVMgPSBbJ25hbWUnLCAnaHR0cEVxdWl2JywgJ2NoYXJTZXQnLCAnaXRlbVByb3AnXVxuXG4vKlxuIHJldHVybnMgYSBmdW5jdGlvbiBmb3IgZmlsdGVyaW5nIGhlYWQgY2hpbGQgZWxlbWVudHNcbiB3aGljaCBzaG91bGRuJ3QgYmUgZHVwbGljYXRlZCwgbGlrZSA8dGl0bGUvPlxuIEFsc28gYWRkcyBzdXBwb3J0IGZvciBkZWR1cGxpY2F0ZWQgYGtleWAgcHJvcGVydGllc1xuKi9cbmZ1bmN0aW9uIHVuaXF1ZSgpIHtcbiAgY29uc3Qga2V5cyA9IG5ldyBTZXQoKVxuICBjb25zdCB0YWdzID0gbmV3IFNldCgpXG4gIGNvbnN0IG1ldGFUeXBlcyA9IG5ldyBTZXQoKVxuICBjb25zdCBtZXRhQ2F0ZWdvcmllczogeyBbbWV0YXR5cGU6IHN0cmluZ106IFNldDxzdHJpbmc+IH0gPSB7fVxuXG4gIHJldHVybiAoaDogUmVhY3QuUmVhY3RFbGVtZW50PGFueT4pID0+IHtcbiAgICBsZXQgaXNVbmlxdWUgPSB0cnVlXG4gICAgbGV0IGhhc0tleSA9IGZhbHNlXG5cbiAgICBpZiAoaC5rZXkgJiYgdHlwZW9mIGgua2V5ICE9PSAnbnVtYmVyJyAmJiBoLmtleS5pbmRleE9mKCckJykgPiAwKSB7XG4gICAgICBoYXNLZXkgPSB0cnVlXG4gICAgICBjb25zdCBrZXkgPSBoLmtleS5zbGljZShoLmtleS5pbmRleE9mKCckJykgKyAxKVxuICAgICAgaWYgKGtleXMuaGFzKGtleSkpIHtcbiAgICAgICAgaXNVbmlxdWUgPSBmYWxzZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAga2V5cy5hZGQoa2V5KVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZWZhdWx0LWNhc2VcbiAgICBzd2l0Y2ggKGgudHlwZSkge1xuICAgICAgY2FzZSAndGl0bGUnOlxuICAgICAgY2FzZSAnYmFzZSc6XG4gICAgICAgIGlmICh0YWdzLmhhcyhoLnR5cGUpKSB7XG4gICAgICAgICAgaXNVbmlxdWUgPSBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhZ3MuYWRkKGgudHlwZSlcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnbWV0YSc6XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBNRVRBVFlQRVMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBtZXRhdHlwZSA9IE1FVEFUWVBFU1tpXVxuICAgICAgICAgIGlmICghaC5wcm9wcy5oYXNPd25Qcm9wZXJ0eShtZXRhdHlwZSkpIGNvbnRpbnVlXG5cbiAgICAgICAgICBpZiAobWV0YXR5cGUgPT09ICdjaGFyU2V0Jykge1xuICAgICAgICAgICAgaWYgKG1ldGFUeXBlcy5oYXMobWV0YXR5cGUpKSB7XG4gICAgICAgICAgICAgIGlzVW5pcXVlID0gZmFsc2VcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1ldGFUeXBlcy5hZGQobWV0YXR5cGUpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNhdGVnb3J5ID0gaC5wcm9wc1ttZXRhdHlwZV1cbiAgICAgICAgICAgIGNvbnN0IGNhdGVnb3JpZXMgPSBtZXRhQ2F0ZWdvcmllc1ttZXRhdHlwZV0gfHwgbmV3IFNldCgpXG4gICAgICAgICAgICBpZiAoKG1ldGF0eXBlICE9PSAnbmFtZScgfHwgIWhhc0tleSkgJiYgY2F0ZWdvcmllcy5oYXMoY2F0ZWdvcnkpKSB7XG4gICAgICAgICAgICAgIGlzVW5pcXVlID0gZmFsc2VcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNhdGVnb3JpZXMuYWRkKGNhdGVnb3J5KVxuICAgICAgICAgICAgICBtZXRhQ2F0ZWdvcmllc1ttZXRhdHlwZV0gPSBjYXRlZ29yaWVzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgcmV0dXJuIGlzVW5pcXVlXG4gIH1cbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIGhlYWRDaGlsZHJlbkVsZW1lbnRzIExpc3Qgb2YgY2hpbGRyZW4gb2YgPEhlYWQ+XG4gKi9cbmZ1bmN0aW9uIHJlZHVjZUNvbXBvbmVudHM8VCBleHRlbmRzIHt9ICYgV2l0aEluQW1wTW9kZT4oXG4gIGhlYWRDaGlsZHJlbkVsZW1lbnRzOiBBcnJheTxSZWFjdC5SZWFjdEVsZW1lbnQ8YW55Pj4sXG4gIHByb3BzOiBUXG4pIHtcbiAgY29uc3QgeyBpbkFtcE1vZGUgfSA9IHByb3BzXG4gIHJldHVybiBoZWFkQ2hpbGRyZW5FbGVtZW50c1xuICAgIC5yZWR1Y2Uob25seVJlYWN0RWxlbWVudCwgW10pXG4gICAgLnJldmVyc2UoKVxuICAgIC5jb25jYXQoZGVmYXVsdEhlYWQoaW5BbXBNb2RlKS5yZXZlcnNlKCkpXG4gICAgLmZpbHRlcih1bmlxdWUoKSlcbiAgICAucmV2ZXJzZSgpXG4gICAgLm1hcCgoYzogUmVhY3QuUmVhY3RFbGVtZW50PGFueT4sIGk6IG51bWJlcikgPT4ge1xuICAgICAgY29uc3Qga2V5ID0gYy5rZXkgfHwgaVxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgIC8vIG9taXQgSlNPTi1MRCBzdHJ1Y3R1cmVkIGRhdGEgc25pcHBldHMgZnJvbSB0aGUgd2FybmluZ1xuICAgICAgICBpZiAoYy50eXBlID09PSAnc2NyaXB0JyAmJiBjLnByb3BzWyd0eXBlJ10gIT09ICdhcHBsaWNhdGlvbi9sZCtqc29uJykge1xuICAgICAgICAgIGNvbnN0IHNyY01lc3NhZ2UgPSBjLnByb3BzWydzcmMnXVxuICAgICAgICAgICAgPyBgPHNjcmlwdD4gdGFnIHdpdGggc3JjPVwiJHtjLnByb3BzWydzcmMnXX1cImBcbiAgICAgICAgICAgIDogYGlubGluZSA8c2NyaXB0PmBcbiAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgIGBEbyBub3QgYWRkIDxzY3JpcHQ+IHRhZ3MgdXNpbmcgbmV4dC9oZWFkIChzZWUgJHtzcmNNZXNzYWdlfSkuIFVzZSBuZXh0L3NjcmlwdCBpbnN0ZWFkLiBcXG5TZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL25vLXNjcmlwdC10YWdzLWluLWhlYWQtY29tcG9uZW50YFxuICAgICAgICAgIClcbiAgICAgICAgfSBlbHNlIGlmIChjLnR5cGUgPT09ICdsaW5rJyAmJiBjLnByb3BzWydyZWwnXSA9PT0gJ3N0eWxlc2hlZXQnKSB7XG4gICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICBgRG8gbm90IGFkZCBzdHlsZXNoZWV0cyB1c2luZyBuZXh0L2hlYWQgKHNlZSA8bGluayByZWw9XCJzdHlsZXNoZWV0XCI+IHRhZyB3aXRoIGhyZWY9XCIke2MucHJvcHNbJ2hyZWYnXX1cIikuIFVzZSBEb2N1bWVudCBpbnN0ZWFkLiBcXG5TZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL25vLXN0eWxlc2hlZXRzLWluLWhlYWQtY29tcG9uZW50YFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFJlYWN0LmNsb25lRWxlbWVudChjLCB7IGtleSB9KVxuICAgIH0pXG59XG5cbi8qKlxuICogVGhpcyBjb21wb25lbnQgaW5qZWN0cyBlbGVtZW50cyB0byBgPGhlYWQ+YCBvZiB5b3VyIHBhZ2UuXG4gKiBUbyBhdm9pZCBkdXBsaWNhdGVkIGB0YWdzYCBpbiBgPGhlYWQ+YCB5b3UgY2FuIHVzZSB0aGUgYGtleWAgcHJvcGVydHksIHdoaWNoIHdpbGwgbWFrZSBzdXJlIGV2ZXJ5IHRhZyBpcyBvbmx5IHJlbmRlcmVkIG9uY2UuXG4gKi9cbmZ1bmN0aW9uIEhlYWQoeyBjaGlsZHJlbiB9OiB7IGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGUgfSkge1xuICBjb25zdCBhbXBTdGF0ZSA9IHVzZUNvbnRleHQoQW1wU3RhdGVDb250ZXh0KVxuICBjb25zdCBoZWFkTWFuYWdlciA9IHVzZUNvbnRleHQoSGVhZE1hbmFnZXJDb250ZXh0KVxuICByZXR1cm4gKFxuICAgIDxFZmZlY3RcbiAgICAgIHJlZHVjZUNvbXBvbmVudHNUb1N0YXRlPXtyZWR1Y2VDb21wb25lbnRzfVxuICAgICAgaGVhZE1hbmFnZXI9e2hlYWRNYW5hZ2VyfVxuICAgICAgaW5BbXBNb2RlPXtpc0luQW1wTW9kZShhbXBTdGF0ZSl9XG4gICAgPlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvRWZmZWN0PlxuICApXG59XG5cbmV4cG9ydCBkZWZhdWx0IEhlYWRcbiJdLCJuYW1lcyI6WyJkZWZhdWx0SGVhZCIsImluQW1wTW9kZSIsImhlYWQiLCJtZXRhIiwiY2hhclNldCIsInB1c2giLCJuYW1lIiwiY29udGVudCIsIm9ubHlSZWFjdEVsZW1lbnQiLCJsaXN0IiwiY2hpbGQiLCJ0eXBlIiwiUmVhY3QiLCJGcmFnbWVudCIsImNvbmNhdCIsIkNoaWxkcmVuIiwidG9BcnJheSIsInByb3BzIiwiY2hpbGRyZW4iLCJyZWR1Y2UiLCJmcmFnbWVudExpc3QiLCJmcmFnbWVudENoaWxkIiwiTUVUQVRZUEVTIiwidW5pcXVlIiwia2V5cyIsIlNldCIsInRhZ3MiLCJtZXRhVHlwZXMiLCJtZXRhQ2F0ZWdvcmllcyIsImgiLCJpc1VuaXF1ZSIsImhhc0tleSIsImtleSIsImluZGV4T2YiLCJzbGljZSIsImhhcyIsImFkZCIsImkiLCJsZW4iLCJsZW5ndGgiLCJtZXRhdHlwZSIsImhhc093blByb3BlcnR5IiwiY2F0ZWdvcnkiLCJjYXRlZ29yaWVzIiwicmVkdWNlQ29tcG9uZW50cyIsImhlYWRDaGlsZHJlbkVsZW1lbnRzIiwicmV2ZXJzZSIsImZpbHRlciIsIm1hcCIsImMiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJzcmNNZXNzYWdlIiwid2Fybk9uY2UiLCJjbG9uZUVsZW1lbnQiLCJIZWFkIiwiYW1wU3RhdGUiLCJ1c2VDb250ZXh0IiwiQW1wU3RhdGVDb250ZXh0IiwiaGVhZE1hbmFnZXIiLCJIZWFkTWFuYWdlckNvbnRleHQiLCJFZmZlY3QiLCJyZWR1Y2VDb21wb25lbnRzVG9TdGF0ZSIsImlzSW5BbXBNb2RlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztJQWdMQSxPQUFtQixFQUFBO2VBQW5COztJQW5LZ0JBLFdBQVcsRUFBQTtlQUFYQTs7Ozs7O2lFQVg0QjtxRUFDekI7eUNBQ2E7aURBQ0c7eUJBQ1A7MEJBQ0g7QUFNbEIsU0FBU0EsWUFBWUMsU0FBaUI7SUFBakJBLElBQUFBLGNBQUFBLEtBQUFBLEdBQUFBLFlBQVk7SUFDdEMsTUFBTUMsT0FBTztzQkFBQyxDQUFBLEdBQUEsWUFBQSxHQUFBLEVBQUNDLFFBQUFBO1lBQUtDLFNBQVE7V0FBWTtL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V0MsQ0FBQUEsR0FBQUEsT0FBQUEsVUFBVSxFQUFDQyx5QkFBQUEsZUFBZTtJQUMzQyxNQUFNQyxjQUFjRixDQUFBQSxHQUFBQSxPQUFBQSxVQUFVLEVBQUNHLGlDQUFBQSxrQkFBa0I7SUFDakQsT0FBQSxXQUFBLEdBQ0UsQ0FBQSxHQUFBLFlBQUEsR0FBQSxFQUFDQyxZQUFBQSxPQUFNLEVBQUE7UUFDTEMseUJBQXlCbkI7UUFDekJnQixhQUFhQTtRQUNiM0QsV0FBVytELENBQUFBLEdBQUFBLFNBQUFBLFdBQVcsRUFBQ1A7a0JBRXRCdkM7O0FBR1A7TUFFQSxXQUFlc0MiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNDEyMywgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9zZXJ2ZXIvcmVxdWVzdC1tZXRhLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIG5vLXJlZGVjbGFyZSAqL1xuaW1wb3J0IHR5cGUgeyBJbmNvbWluZ01lc3NhZ2UgfSBmcm9tICdodHRwJ1xuaW1wb3J0IHR5cGUgeyBQYXJzZWRVcmxRdWVyeSB9IGZyb20gJ3F1ZXJ5c3RyaW5nJ1xuaW1wb3J0IHR5cGUgeyBVcmxXaXRoUGFyc2VkUXVlcnkgfSBmcm9tICd1cmwnXG5pbXBvcnQgdHlwZSB7IEJhc2VOZXh0UmVxdWVzdCB9IGZyb20gJy4vYmFzZS1odHRwJ1xuaW1wb3J0IHR5cGUgeyBDbG9uZWFibGVCb2R5IH0gZnJvbSAnLi9ib2R5LXN0cmVhbXMnXG5pbXBvcnQgdHlwZSB7IFJvdXRlTWF0Y2ggfSBmcm9tICcuL3JvdXRlLW1hdGNoZXMvcm91dGUtbWF0Y2gnXG5pbXBvcnQgdHlwZSB7IE5FWFRfUlNDX1VOSU9OX1FVRVJZIH0gZnJvbSAnLi4vY2xpZW50L2NvbXBvbmVudHMvYXBwLXJvdXRlci1oZWFkZXJzJ1xuaW1wb3J0IHR5cGUgeyBTZXJ2ZXJDb21wb25lbnRzSG1yQ2FjaGUgfSBmcm9tICcuL3Jlc3BvbnNlLWNhY2hlJ1xuaW1wb3J0IHR5cGUgeyBQYWdlc0Rldk92ZXJsYXlCcmlkZ2VUeXBlIH0gZnJvbSAnLi4vbmV4dC1kZXZ0b29scy91c2Vyc3BhY2UvcGFnZXMvcGFnZXMtZGV2LW92ZXJsYXktc2V0dXAnXG5cbi8vIEZJWE1FOiAod3lhdHRqb2gpIHRoaXMgaXMgYSB0ZW1wb3Jhcnkgc29sdXRpb24gdG8gYWxsb3cgdXMgdG8gcGFzcyBkYXRhIGJldHdlZW4gYnVuZGxlZCBtb2R1bGVzXG5leHBvcnQgY29uc3QgTkVYVF9SRVFVRVNUX01FVEEgPSBTeW1ib2wuZm9yKCdOZXh0SW50ZXJuYWxSZXF1ZXN0TWV0YScpXG5cbmV4cG9ydCB0eXBlIE5leHRJbmNvbWluZ01lc3NhZ2UgPSAoQmFzZU5leHRSZXF1ZXN0IHwgSW5jb21pbmdNZXNzYWdlKSAmIHtcbiAgW05FWFRfUkVRVUVTVF9NRVRBXT86IFJlcXVlc3RNZXRhXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVxdWVzdE1ldGEge1xuICAvKipcbiAgICogVGhlIHF1ZXJ5IHRoYXQgd2FzIHVzZWQgdG8gbWFrZSB0aGUgcmVxdWVzdC5cbiAgICovXG4gIGluaXRRdWVyeT86IFBhcnNlZFVybFF1ZXJ5XG5cbiAgLyoqXG4gICAqIFRoZSBVUkwgdGhhdCB3YXMgdXNlZCB0byBtYWtlIHRoZSByZXF1ZXN0LlxuICAgKi9cbiAgaW5pdFVSTD86IHN0cmluZ1xuXG4gIC8qKlxuICAgKiBUaGUgcHJvdG9jb2wgdGhhdCB3YXMgdXNlZCB0byBtYWtlIHRoZSByZXF1ZXN0LlxuICAgKi9cbiAgaW5pdFByb3RvY29sPzogc3RyaW5nXG5cbiAgLyoqXG4gICAqIFRoZSBib2R5IHRoYXQgd2FzIHJlYWQgZnJvbSB0aGUgcmVxdWVzdC4gVGhpcyBpcyB1c2VkIHRvIGFsbG93IHRoZSBib2R5IHRvXG4gICAqIGJlIHJlYWQgbXVsdGlwbGUgdGltZXMuXG4gICAqL1xuICBjbG9uYWJsZUJvZHk/OiBDbG9uZWFibGVCb2R5XG5cbiAgLyoqXG4gICAqIFRydWUgd2hlbiB0aGUgcmVxdWVzdCBtYXRjaGVkIGEgbG9jYWxlIGRvbWFpbiB0aGF0IHdhcyBjb25maWd1cmVkIGluIHRoZVxuICAgKiBuZXh0LmNvbmZpZy5qcyBmaWxlLlxuICAgKi9cbiAgaXNMb2NhbGVEb21haW4/OiBib29sZWFuXG5cbiAgLyoqXG4gICAqIFRydWUgd2hlbiB0aGUgcmVxdWVzdCBoYWQgbG9jYWxlIGluZm9ybWF0aW9uIHN0cmlwcGVkIGZyb20gdGhlIHBhdGhuYW1lXG4gICAqIHBhcnQgb2YgdGhlIFVSTC5cbiAgICovXG4gIGRpZFN0cmlwTG9jYWxlPzogYm9vbGVhblxuXG4gIC8qKlxuICAgKiBJZiB0aGUgcmVxdWVzdCBoYWQgaXQncyBVUkwgcmV3cml0dGVuLCB0aGlzIGlzIHRoZSBVUkwgaXQgd2FzIHJld3JpdHRlbiB0by5cbiAgICovXG4gIHJld3JvdGVVUkw/OiBzdHJpbmdcblxuICAvKipcbiAgICogVGhlIGNvb2tpZXMgdGhhdCB3ZXJlIGFkZGVkIGJ5IG1pZGRsZXdhcmUgYW5kIHdlcmUgYWRkZWQgdG8gdGhlIHJlc3BvbnNlLlxuICAgKi9cbiAgbWlkZGxld2FyZUNvb2tpZT86IHN0cmluZ1tdXG5cbiAgLyoqXG4gICAqIFRoZSBtYXRjaCBvbiB0aGUgcmVxdWVzdCBmb3IgYSBnaXZlbiByb3V0ZS5cbiAgICovXG4gIG1hdGNoPzogUm91dGVNYXRjaFxuXG4gIC8qKlxuICAgKiBUaGUgaW5jcmVtZW50YWwgY2FjaGUgdG8gdXNlIGZvciB0aGUgcmVxdWVzdC5cbiAgICovXG4gIGluY3JlbWVudGFsQ2FjaGU/OiBhbnlcblxuICAvKipcbiAgICogVGhlIHNlcnZlciBjb21wb25lbnRzIEhNUiBjYWNoZSwgb25seSBmb3IgZGV2LlxuICAgKi9cbiAgc2VydmVyQ29tcG9uZW50c0htckNhY2hlPzogU2VydmVyQ29tcG9uZW50c0htckNhY2hlXG5cbiAgLyoqXG4gICAqIEVxdWFscyB0aGUgc2VnbWVudCBwYXRoIHRoYXQgd2FzIHVzZWQgZm9yIHRoZSBwcmVmZXRjaCBSU0MgcmVxdWVzdC5cbiAgICovXG4gIHNlZ21lbnRQcmVmZXRjaFJTQ1JlcXVlc3Q/OiBzdHJpbmdcblxuICAvKipcbiAgICogVHJ1ZSB3aGVuIHRoZSByZXF1ZXN0IGlzIGZvciB0aGUgcHJlZmV0Y2ggZmxpZ2h0IGRhdGEuXG4gICAqL1xuICBpc1ByZWZldGNoUlNDUmVxdWVzdD86IHRydWVcblxuICAvKipcbiAgICogVHJ1ZSB3aGVuIHRoZSByZXF1ZXN0IGlzIGZvciB0aGUgZmxpZ2h0IGRhdGEuXG4gICAqL1xuICBpc1JTQ1JlcXVlc3Q/OiB0cnVlXG5cbiAgLyoqXG4gICAqIEEgc2VhcmNoIHBhcmFtIHNldCBieSB0aGUgTmV4dC5qcyBjbGllbnQgd2hlbiBwZXJmb3JtaW5nIFJTQyByZXF1ZXN0cy5cbiAgICogQmVjYXVzZSBzb21lIENETnMgZG8gbm90IHZhcnkgdGhlaXIgY2FjaGUgZW50cmllcyBvbiBvdXIgY3VzdG9tIGhlYWRlcnMsXG4gICAqIHRoaXMgc2VhcmNoIHBhcmFtIHJlcHJlc2VudHMgYSBoYXNoIG9mIHRoZSBoZWFkZXIgdmFsdWVzLiBGb3IgYW55IGNhY2hlZFxuICAgKiBSU0MgcmVxdWVzdCwgd2Ugc2hvdWxkIHZlcmlmeSB0aGF0IHRoZSBoYXNoIG1hdGNoZXMgYmVmb3JlIHJlc3BvbmRpbmcuXG4gICAqIE90aGVyd2lzZSB0aGlzIGNhbiBsZWFkIHRvIGNhY2hlIHBvaXNvbmluZy5cbiAgICogVE9ETzogQ29uc2lkZXIgbm90IHVzaW5nIGN1c3RvbSByZXF1ZXN0IGhlYWRlcnMgYXQgYWxsLCBhbmQgaW5zdGVhZCBlbmNvZGVcbiAgICogZXZlcnl0aGluZyBpbnRvIHRoZSBzZWFyY2ggcGFyYW0uXG4gICAqL1xuICBjYWNoZUJ1c3RpbmdTZWFyY2hQYXJhbT86IHN0cmluZ1xuXG4gIC8qKlxuICAgKiBUcnVlIHdoZW4gdGhlIHJlcXVlc3QgaXMgZm9yIHRoZSBgL19uZXh0L2RhdGFgIHJvdXRlIHVzaW5nIHRoZSBwYWdlc1xuICAgKiByb3V0ZXIuXG4gICAqL1xuICBpc05leHREYXRhUmVxPzogdHJ1ZVxuXG4gIC8qKlxuICAgKiBQb3N0cG9uZWQgc3RhdGUgdG8gdXNlIGZvciByZXN1bXB0aW9uLiBJZiBwcmVzZW50IGl0J3MgYXNzdW1lZCB0aGF0IHRoZVxuICAgKiByZXF1ZXN0IGlzIGZvciBhIHBhZ2UgdGhhdCBoYXMgcG9zdHBvbmVkICh0aGVyZSBhcmUgbm8gZ3VhcmFudGVlcyB0aGF0IHRoZVxuICAgKiBwYWdlIGFjdHVhbGx5IGhhcyBwb3N0cG9uZWQgdGhvdWdoIGFzIGl0IHdvdWxkIGluY3VyIGFuIGFkZGl0aW9uYWwgY2FjaGVcbiAgICogbG9va3VwKS5cbiAgICovXG4gIHBvc3Rwb25lZD86IHN0cmluZ1xuXG4gIC8qKlxuICAgKiBJZiBwcm92aWRlZCwgdGhpcyB3aWxsIGJlIGNhbGxlZCB3aGVuIGEgcmVzcG9uc2UgY2FjaGUgZW50cnkgd2FzIGdlbmVyYXRlZFxuICAgKiBvciBsb29rZWQgdXAgaW4gdGhlIGNhY2hlLlxuICAgKi9cbiAgb25DYWNoZUVudHJ5PzogKFxuICAgIGNhY2hlRW50cnk6IGFueSxcbiAgICByZXF1ZXN0TWV0YTogYW55XG4gICkgPT4gUHJvbWlzZTxib29sZWFuIHwgdm9pZD4gfCBib29sZWFuIHwgdm9pZFxuXG4gIC8qKlxuICAgKiBUaGUgcHJldmlvdXMgcmV2YWxpZGF0ZSBiZWZvcmUgcmVuZGVyaW5nIDQwNCBwYWdlIGZvciBub3RGb3VuZDogdHJ1ZVxuICAgKi9cbiAgbm90Rm91bmRSZXZhbGlkYXRlPzogbnVtYmVyIHwgZmFsc2VcblxuICAvKipcbiAgICogSW4gZGV2ZWxvcG1lbnQsIHRoZSBvcmlnaW5hbCBzb3VyY2UgcGFnZSB0aGF0IHJldHVybmVkIGEgNDA0LlxuICAgKi9cbiAgZGV2ZWxvcG1lbnROb3RGb3VuZFNvdXJjZVBhZ2U/OiBzdHJpbmdcblxuICAvKipcbiAgICogVGhlIHBhdGggd2Ugcm91dGVkIHRvIGFuZCBzaG91bGQgYmUgaW52b2tlZFxuICAgKi9cbiAgaW52b2tlUGF0aD86IHN0cmluZ1xuXG4gIC8qKlxuICAgKiBUaGUgc3BlY2lmaWMgcGFnZSBvdXRwdXQgd2Ugc2hvdWxkIGJlIG1hdGNoaW5nXG4gICAqL1xuICBpbnZva2VPdXRwdXQ/OiBzdHJpbmdcblxuICAvKipcbiAgICogVGhlIHN0YXR1cyB3ZSBhcmUgaW52b2tpbmcgdGhlIHJlcXVlc3Qgd2l0aCBmcm9tIHJvdXRpbmdcbiAgICovXG4gIGludm9rZVN0YXR1cz86IG51bWJlclxuXG4gIC8qKlxuICAgKiBUaGUgcm91dGluZyBlcnJvciB3ZSBhcmUgaW52b2tpbmcgd2l0aFxuICAgKi9cbiAgaW52b2tlRXJyb3I/OiBFcnJvclxuXG4gIC8qKlxuICAgKiBUaGUgcXVlcnkgcGFyc2VkIGZvciB0aGUgaW52b2NhdGlvblxuICAgKi9cbiAgaW52b2tlUXVlcnk/OiBSZWNvcmQ8c3RyaW5nLCB1bmRlZmluZWQgfCBzdHJpbmcgfCBzdHJpbmdbXT5cblxuICAvKipcbiAgICogV2hldGhlciB0aGUgcmVxdWVzdCBpcyBhIG1pZGRsZXdhcmUgaW52b2NhdGlvblxuICAgKi9cbiAgbWlkZGxld2FyZUludm9rZT86IGJvb2xlYW5cblxuICAvKipcbiAgICogV2hldGhlciB0aGUgcmVxdWVzdCBzaG91bGQgcmVuZGVyIHRoZSBmYWxsYmFjayBzaGVsbCBvciBub3QuXG4gICAqL1xuICByZW5kZXJGYWxsYmFja1NoZWxsPzogYm9vbGVhblxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSByZXF1ZXN0IGlzIGZvciB0aGUgY3VzdG9tIGVycm9yIHBhZ2UuXG4gICAqL1xuICBjdXN0b21FcnJvclJlbmRlcj86IHRydWVcblxuICAvKipcbiAgICogV2hldGhlciB0byBidWJibGUgdXAgdGhlIE5vRmFsbGJhY2tFcnJvciB0byB0aGUgY2FsbGVyIHdoZW4gYSA0MDQgaXNcbiAgICogcmV0dXJuZWQuXG4gICAqL1xuICBidWJibGVOb0ZhbGxiYWNrPzogdHJ1ZVxuXG4gIC8qKlxuICAgKiBUcnVlIHdoZW4gdGhlIHJlcXVlc3QgaGFkIGxvY2FsZSBpbmZvcm1hdGlvbiBpbmZlcnJlZCBmcm9tIHRoZSBkZWZhdWx0XG4gICAqIGxvY2FsZS5cbiAgICovXG4gIGxvY2FsZUluZmVycmVkRnJvbURlZmF1bHQ/OiB0cnVlXG5cbiAgLyoqXG4gICAqIFRoZSBsb2NhbGUgdGhhdCB3YXMgaW5mZXJyZWQgb3IgZXhwbGljaXRseSBzZXQgZm9yIHRoZSByZXF1ZXN0LlxuICAgKi9cbiAgbG9jYWxlPzogc3RyaW5nXG5cbiAgLyoqXG4gICAqIFRoZSBkZWZhdWx0IGxvY2FsZSB0aGF0IHdhcyBpbmZlcnJlZCBvciBleHBsaWNpdGx5IHNldCBmb3IgdGhlIHJlcXVlc3QuXG4gICAqL1xuICBkZWZhdWx0TG9jYWxlPzogc3RyaW5nXG5cbiAgLyoqXG4gICAqIFRoZSBwcm9qZWN0IGRpciB0aGUgc2VydmVyIGlzIHJ1bm5pbmcgaW5cbiAgICovXG4gIHByb2plY3REaXI/OiBzdHJpbmdcblxuICAvKipcbiAgICogVGhlIGRpc3QgZGlyZWN0b3J5IHRoZSBzZXJ2ZXIgaXMgY3VycmVudGx5IHVzaW5nXG4gICAqL1xuICBkaXN0RGlyPzogc3RyaW5nXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgd2UgYXJlIGdlbmVyYXRpbmcgdGhlIGZhbGxiYWNrIHZlcnNpb24gb2YgdGhlIHBhZ2UgaW4gZGV2IG1vZGVcbiAgICovXG4gIGlzSXNyRmFsbGJhY2s/OiBib29sZWFuXG5cbiAgLyoqXG4gICAqIFRoZSBxdWVyeSBhZnRlciByZXNvbHZpbmcgcm91dGVzXG4gICAqL1xuICBxdWVyeT86IFBhcnNlZFVybFF1ZXJ5XG5cbiAgLyoqXG4gICAqIFRoZSBwYXJhbXMgYWZ0ZXIgcmVzb2x2aW5nIHJvdXRlc1xuICAgKi9cbiAgcGFyYW1zPzogUGFyc2VkVXJsUXVlcnlcblxuICAvKipcbiAgICogVGhlIEFNUCB2YWxpZGF0b3IgdG8gdXNlIGluIGRldmVsb3BtZW50XG4gICAqL1xuICBhbXBWYWxpZGF0b3I/OiAoaHRtbDogc3RyaW5nLCBwYXRobmFtZTogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+XG5cbiAgLyoqXG4gICAqIEVycm9yT3ZlcmxheSBjb21wb25lbnQgdG8gdXNlIGluIGRldmVsb3BtZW50IGZvciBwYWdlcyByb3V0ZXJcbiAgICovXG4gIFBhZ2VzRXJyb3JEZWJ1Zz86IFBhZ2VzRGV2T3ZlcmxheUJyaWRnZVR5cGVcblxuICAvKipcbiAgICogV2hldGhlciBzZXJ2ZXIgaXMgaW4gbWluaW1hbCBtb2RlICh0aGlzIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBtb3JlXG4gICAqIHNwZWNpZmljIGZsYWdzIGluIGZ1dHVyZSlcbiAgICovXG4gIG1pbmltYWxNb2RlPzogYm9vbGVhblxufVxuXG4vKipcbiAqIEdldHMgdGhlIHJlcXVlc3QgbWV0YWRhdGEuIElmIG5vIGtleSBpcyBwcm92aWRlZCwgdGhlIGVudGlyZSBtZXRhZGF0YSBvYmplY3RcbiAqIGlzIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSByZXEgdGhlIHJlcXVlc3QgdG8gZ2V0IHRoZSBtZXRhZGF0YSBmcm9tXG4gKiBAcGFyYW0ga2V5IHRoZSBrZXkgdG8gZ2V0IGZyb20gdGhlIG1ldGFkYXRhIChvcHRpb25hbClcbiAqIEByZXR1cm5zIHRoZSB2YWx1ZSBmb3IgdGhlIGtleSBvciB0aGUgZW50aXJlIG1ldGFkYXRhIG9iamVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmVxdWVzdE1ldGEoXG4gIHJlcTogTmV4dEluY29taW5nTWVzc2FnZSxcbiAga2V5PzogdW5kZWZpbmVkXG4pOiBSZXF1ZXN0TWV0YVxuZXhwb3J0IGZ1bmN0aW9uIGdldFJlcXVlc3RNZXRhPEsgZXh0ZW5kcyBrZXlvZiBSZXF1ZXN0TWV0YT4oXG4gIHJlcTogTmV4dEluY29taW5nTWVzc2FnZSxcbiAga2V5OiBLXG4pOiBSZXF1ZXN0TWV0YVtLXVxuZXhwb3J0IGZ1bmN0aW9uIGdldFJlcXVlc3RNZXRhPEsgZXh0ZW5kcyBrZXlvZiBSZXF1ZXN0TWV0YT4oXG4gIHJlcTogTmV4dEluY29taW5nTWVzc2FnZSxcbiAga2V5PzogS1xuKTogUmVxdWVzdE1ldGEgfCBSZXF1ZXN0TWV0YVtLXSB7XG4gIGNvbnN0IG1ldGEgPSByZXFbTkVYVF9SRVFVRVNUX01FVEFdIHx8IHt9XG4gIHJldHVybiB0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyA/IG1ldGFba2V5XSA6IG1ldGFcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSByZXF1ZXN0IG1ldGFkYXRhLlxuICpcbiAqIEBwYXJhbSByZXEgdGhlIHJlcXVlc3QgdG8gc2V0IHRoZSBtZXRhZGF0YSBvblxuICogQHBhcmFtIG1ldGEgdGhlIG1ldGFkYXRhIHRvIHNldFxuICogQHJldHVybnMgdGhlIG11dGF0ZWQgcmVxdWVzdCBtZXRhZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0UmVxdWVzdE1ldGEocmVxOiBOZXh0SW5jb21pbmdNZXNzYWdlLCBtZXRhOiBSZXF1ZXN0TWV0YSkge1xuICByZXFbTkVYVF9SRVFVRVNUX01FVEFdID0gbWV0YVxuICByZXR1cm4gbWV0YVxufVxuXG4vKipcbiAqIEFkZHMgYSB2YWx1ZSB0byB0aGUgcmVxdWVzdCBtZXRhZGF0YS5cbiAqXG4gKiBAcGFyYW0gcmVxdWVzdCB0aGUgcmVxdWVzdCB0byBtdXRhdGVcbiAqIEBwYXJhbSBrZXkgdGhlIGtleSB0byBzZXRcbiAqIEBwYXJhbSB2YWx1ZSB0aGUgdmFsdWUgdG8gc2V0XG4gKiBAcmV0dXJucyB0aGUgbXV0YXRlZCByZXF1ZXN0IG1ldGFkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRSZXF1ZXN0TWV0YTxLIGV4dGVuZHMga2V5b2YgUmVxdWVzdE1ldGE+KFxuICByZXF1ZXN0OiBOZXh0SW5jb21pbmdNZXNzYWdlLFxuICBrZXk6IEssXG4gIHZhbHVlOiBSZXF1ZXN0TWV0YVtLXVxuKSB7XG4gIGNvbnN0IG1ldGEgPSBnZXRSZXF1ZXN0TWV0YShyZXF1ZXN0KVxuICBtZXRhW2tleV0gPSB2YWx1ZVxuICByZXR1cm4gc2V0UmVxdWVzdE1ldGEocmVxdWVzdCwgbWV0YSlcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGEga2V5IGZyb20gdGhlIHJlcXVlc3QgbWV0YWRhdGEuXG4gKlxuICogQHBhcmFtIHJlcXVlc3QgdGhlIHJlcXVlc3QgdG8gbXV0YXRlXG4gKiBAcGFyYW0ga2V5IHRoZSBrZXkgdG8gcmVtb3ZlXG4gKiBAcmV0dXJucyB0aGUgbXV0YXRlZCByZXF1ZXN0IG1ldGFkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVSZXF1ZXN0TWV0YTxLIGV4dGVuZHMga2V5b2YgUmVxdWVzdE1ldGE+KFxuICByZXF1ZXN0OiBOZXh0SW5jb21pbmdNZXNzYWdlLFxuICBrZXk6IEtcbikge1xuICBjb25zdCBtZXRhID0gZ2V0UmVxdWVzdE1ldGEocmVxdWVzdClcbiAgZGVsZXRlIG1ldGFba2V5XVxuICByZXR1cm4gc2V0UmVxdWVzdE1ldGEocmVxdWVzdCwgbWV0YSlcbn1cblxudHlwZSBOZXh0UXVlcnlNZXRhZGF0YSA9IHtcbiAgLyoqXG4gICAqIFRoZSBgX3JzY2AgcXVlcnkgcGFyYW1ldGVyIHVzZWQgZm9yIGNhY2hlIGJ1c3RpbmcgdG8gZW5zdXJlIHRoYXQgdGhlIFJTQ1xuICAgKiByZXF1ZXN0cyBkbyBub3QgZ2V0IGNhY2hlZCBieSB0aGUgYnJvd3NlciBleHBsaWNpdGx5LlxuICAgKi9cbiAgW05FWFRfUlNDX1VOSU9OX1FVRVJZXT86IHN0cmluZ1xufVxuXG5leHBvcnQgdHlwZSBOZXh0UGFyc2VkVXJsUXVlcnkgPSBQYXJzZWRVcmxRdWVyeSAmXG4gIE5leHRRdWVyeU1ldGFkYXRhICYge1xuICAgIGFtcD86ICcxJ1xuICB9XG5cbmV4cG9ydCBpbnRlcmZhY2UgTmV4dFVybFdpdGhQYXJzZWRRdWVyeSBleHRlbmRzIFVybFdpdGhQYXJzZWRRdWVyeSB7XG4gIHF1ZXJ5OiBOZXh0UGFyc2VkVXJsUXVlcnlcbn1cbiJdLCJuYW1lcyI6WyJORVhUX1JFUVVFU1RfTUVUQSIsImFkZFJlcXVlc3RNZXRhIiwiZ2V0UmVxdWVzdE1ldGEiLCJyZW1vdmVSZXF1ZXN0TWV0YSIsInNldFJlcXVlc3RNZXRhIiwiU3ltYm9sIiwiZm9yIiwicmVxIiwia2V5IiwibWV0YSIsInJlcXVlc3QiLCJ2YWx1ZSJdLCJtYXBwaW5ncyI6IkFBQUEsK0JBQStCOzs7Ozs7Ozs7Ozs7Ozs7OztJQVlsQkEsaUJBQWlCLEVBQUE7ZUFBakJBOztJQWdSR0MsY0FBYyxFQUFBO2VBQWRBOztJQTVCQUMsY0FBYyxFQUFBO2VBQWRBOztJQTZDQUMsaUJBQWlCLEVBQUE7ZUFBakJBOztJQTlCQUMsY0FBYyxFQUFBO2VBQWRBOzs7QUFuUVQsTUFBTUosb0JBQW9CSyxPQUFPQyxHQUFHLENBQUM7QUFvUHJDLFNBQVNKLGVBQ2RLLEdBQXdCLEVBQ3hCQyxHQUFPO0lBRVAsTUFBTUMsT0FBT0YsR0FBRyxDQUFDUCxrQkFBa0IsSUFBSSxDQUFDO0lBQ3hDLE9BQU8sT0FBT1EsUUFBUSxXQUFXQyxJQUFJLENBQUNELElBQUksR0FBR0M7QUFDL0M7QUFTTyxTQUFTTCxlQUFlRyxHQUF3QixFQUFFRSxJQUFpQjtJQUN4RUYsR0FBRyxDQUFDUCxrQkFBa0IsR0FBR1M7SUFDekIsT0FBT0E7QUFDVDtBQVVPLFNBQVNSLGVBQ2RTLE9BQTRCLEVBQzVCRixHQUFNLEVBQ05HLEtBQXFCO0lBRXJCLE1BQU1GLE9BQU9QLGVBQWVRO0lBQzVCRCxJQUFJLENBQUNELElBQUksR0FBR0c7SUFDWixPQUFPUCxlQUFlTSxTQUFTRDtBQUNqQztBQVNPLFNBQVNOLGtCQUNkTyxPQUE0QixFQUM1QkYsR0FBTTtJQUVOLE1BQU1DLE9BQU9QLGVBQWVRO0lBQzVCLE9BQU9ELElBQUksQ0FBQ0QsSUFBSTtJQUNoQixPQUFPSixlQUFlTSxTQUFTRDtBQUNqQyIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA0MTgxLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL3BhZ2VzL19lcnJvci50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IEhlYWQgZnJvbSAnLi4vc2hhcmVkL2xpYi9oZWFkJ1xuaW1wb3J0IHR5cGUgeyBOZXh0UGFnZUNvbnRleHQgfSBmcm9tICcuLi9zaGFyZWQvbGliL3V0aWxzJ1xuXG5jb25zdCBzdGF0dXNDb2RlczogeyBbY29kZTogbnVtYmVyXTogc3RyaW5nIH0gPSB7XG4gIDQwMDogJ0JhZCBSZXF1ZXN0JyxcbiAgNDA0OiAnVGhpcyBwYWdlIGNvdWxkIG5vdCBiZSBmb3VuZCcsXG4gIDQwNTogJ01ldGhvZCBOb3QgQWxsb3dlZCcsXG4gIDUwMDogJ0ludGVybmFsIFNlcnZlciBFcnJvcicsXG59XG5cbmV4cG9ydCB0eXBlIEVycm9yUHJvcHMgPSB7XG4gIHN0YXR1c0NvZGU6IG51bWJlclxuICBob3N0bmFtZT86IHN0cmluZ1xuICB0aXRsZT86IHN0cmluZ1xuICB3aXRoRGFya01vZGU/OiBib29sZWFuXG59XG5cbmZ1bmN0aW9uIF9nZXRJbml0aWFsUHJvcHMoe1xuICByZXEsXG4gIHJlcyxcbiAgZXJyLFxufTogTmV4dFBhZ2VDb250ZXh0KTogUHJvbWlzZTxFcnJvclByb3BzPiB8IEVycm9yUHJvcHMge1xuICBjb25zdCBzdGF0dXNDb2RlID1cbiAgICByZXMgJiYgcmVzLnN0YXR1c0NvZGUgPyByZXMuc3RhdHVzQ29kZSA6IGVyciA/IGVyci5zdGF0dXNDb2RlISA6IDQwNFxuXG4gIGxldCBob3N0bmFtZVxuXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGhvc3RuYW1lID0gd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lXG4gIH0gZWxzZSBpZiAocmVxKSB7XG4gICAgY29uc3QgeyBnZXRSZXF1ZXN0TWV0YSB9ID1cbiAgICAgIHJlcXVpcmUoJy4uL3NlcnZlci9yZXF1ZXN0LW1ldGEnKSBhcyB0eXBlb2YgaW1wb3J0KCcuLi9zZXJ2ZXIvcmVxdWVzdC1tZXRhJylcblxuICAgIGNvbnN0IGluaXRVcmwgPSBnZXRSZXF1ZXN0TWV0YShyZXEsICdpbml0VVJMJylcbiAgICBpZiAoaW5pdFVybCkge1xuICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChpbml0VXJsKVxuICAgICAgaG9zdG5hbWUgPSB1cmwuaG9zdG5hbWVcbiAgICB9XG4gIH1cblxuICByZXR1cm4geyBzdGF0dXNDb2RlLCBob3N0bmFtZSB9XG59XG5cbmNvbnN0IHN0eWxlczogUmVjb3JkPHN0cmluZywgUmVhY3QuQ1NTUHJvcGVydGllcz4gPSB7XG4gIGVycm9yOiB7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9tb2Rlcm4tbm9ybWFsaXplL2Jsb2IvbWFpbi9tb2Rlcm4tbm9ybWFsaXplLmNzcyNMMzgtTDUyXG4gICAgZm9udEZhbWlseTpcbiAgICAgICdzeXN0ZW0tdWksXCJTZWdvZSBVSVwiLFJvYm90byxIZWx2ZXRpY2EsQXJpYWwsc2Fucy1zZXJpZixcIkFwcGxlIENvbG9yIEVtb2ppXCIsXCJTZWdvZSBVSSBFbW9qaVwiJyxcbiAgICBoZWlnaHQ6ICcxMDB2aCcsXG4gICAgdGV4dEFsaWduOiAnY2VudGVyJyxcbiAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgZmxleERpcmVjdGlvbjogJ2NvbHVtbicsXG4gICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAganVzdGlmeUNvbnRlbnQ6ICdjZW50ZXInLFxuICB9LFxuICBkZXNjOiB7XG4gICAgbGluZUhlaWdodDogJzQ4cHgnLFxuICB9LFxuICBoMToge1xuICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgIG1hcmdpbjogJzAgMjBweCAwIDAnLFxuICAgIHBhZGRpbmdSaWdodDogMjMsXG4gICAgZm9udFNpemU6IDI0LFxuICAgIGZvbnRXZWlnaHQ6IDUwMCxcbiAgICB2ZXJ0aWNhbEFsaWduOiAndG9wJyxcbiAgfSxcbiAgaDI6IHtcbiAgICBmb250U2l6ZTogMTQsXG4gICAgZm9udFdlaWdodDogNDAwLFxuICAgIGxpbmVIZWlnaHQ6ICcyOHB4JyxcbiAgfSxcbiAgd3JhcDoge1xuICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICB9LFxufVxuXG4vKipcbiAqIGBFcnJvcmAgY29tcG9uZW50IHVzZWQgZm9yIGhhbmRsaW5nIGVycm9ycy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXJyb3I8UCA9IHt9PiBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxQICYgRXJyb3JQcm9wcz4ge1xuICBzdGF0aWMgZGlzcGxheU5hbWUgPSAnRXJyb3JQYWdlJ1xuXG4gIHN0YXRpYyBnZXRJbml0aWFsUHJvcHMgPSBfZ2V0SW5pdGlhbFByb3BzXG4gIHN0YXRpYyBvcmlnR2V0SW5pdGlhbFByb3BzID0gX2dldEluaXRpYWxQcm9wc1xuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IHN0YXR1c0NvZGUsIHdpdGhEYXJrTW9kZSA9IHRydWUgfSA9IHRoaXMucHJvcHNcbiAgICBjb25zdCB0aXRsZSA9XG4gICAgICB0aGlzLnByb3BzLnRpdGxlIHx8XG4gICAgICBzdGF0dXNDb2Rlc1tzdGF0dXNDb2RlXSB8fFxuICAgICAgJ0FuIHVuZXhwZWN0ZWQgZXJyb3IgaGFzIG9jY3VycmVkJ1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgc3R5bGU9e3N0eWxlcy5lcnJvcn0+XG4gICAgICAgIDxIZWFkPlxuICAgICAgICAgIDx0aXRsZT5cbiAgICAgICAgICAgIHtzdGF0dXNDb2RlXG4gICAgICAgICAgICAgID8gYCR7c3RhdHVzQ29kZX06ICR7dGl0bGV9YFxuICAgICAgICAgICAgICA6ICdBcHBsaWNhdGlvbiBlcnJvcjogYSBjbGllbnQtc2lkZSBleGNlcHRpb24gaGFzIG9jY3VycmVkJ31cbiAgICAgICAgICA8L3RpdGxlPlxuICAgICAgICA8L0hlYWQ+XG4gICAgICAgIDxkaXYgc3R5bGU9e3N0eWxlcy5kZXNjfT5cbiAgICAgICAgICA8c3R5bGVcbiAgICAgICAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MPXt7XG4gICAgICAgICAgICAgIC8qIENTUyBtaW5pZmllZCBmcm9tXG4gICAgICAgICAgICAgICAgYm9keSB7IG1hcmdpbjogMDsgY29sb3I6ICMwMDA7IGJhY2tncm91bmQ6ICNmZmY7IH1cbiAgICAgICAgICAgICAgICAubmV4dC1lcnJvci1oMSB7XG4gICAgICAgICAgICAgICAgICBib3JkZXItcmlnaHQ6IDFweCBzb2xpZCByZ2JhKDAsIDAsIDAsIC4zKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAke1xuICAgICAgICAgICAgICAgICAgd2l0aERhcmtNb2RlXG4gICAgICAgICAgICAgICAgICAgID8gYEBtZWRpYSAocHJlZmVycy1jb2xvci1zY2hlbWU6IGRhcmspIHtcbiAgICAgICAgICAgICAgICAgIGJvZHkgeyBjb2xvcjogI2ZmZjsgYmFja2dyb3VuZDogIzAwMDsgfVxuICAgICAgICAgICAgICAgICAgLm5leHQtZXJyb3ItaDEge1xuICAgICAgICAgICAgICAgICAgICBib3JkZXItcmlnaHQ6IDFweCBzb2xpZCByZ2JhKDI1NSwgMjU1LCAyNTUsIC4zKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9YFxuICAgICAgICAgICAgICAgICAgICA6ICcnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgX19odG1sOiBgYm9keXtjb2xvcjojMDAwO2JhY2tncm91bmQ6I2ZmZjttYXJnaW46MH0ubmV4dC1lcnJvci1oMXtib3JkZXItcmlnaHQ6MXB4IHNvbGlkIHJnYmEoMCwwLDAsLjMpfSR7XG4gICAgICAgICAgICAgICAgd2l0aERhcmtNb2RlXG4gICAgICAgICAgICAgICAgICA/ICdAbWVkaWEgKHByZWZlcnMtY29sb3Itc2NoZW1lOmRhcmspe2JvZHl7Y29sb3I6I2ZmZjtiYWNrZ3JvdW5kOiMwMDB9Lm5leHQtZXJyb3ItaDF7Ym9yZGVyLXJpZ2h0OjFweCBzb2xpZCByZ2JhKDI1NSwyNTUsMjU1LC4zKX19J1xuICAgICAgICAgICAgICAgICAgOiAnJ1xuICAgICAgICAgICAgICB9YCxcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgLz5cblxuICAgICAgICAgIHtzdGF0dXNDb2RlID8gKFxuICAgICAgICAgICAgPGgxIGNsYXNzTmFtZT1cIm5leHQtZXJyb3ItaDFcIiBzdHlsZT17c3R5bGVzLmgxfT5cbiAgICAgICAgICAgICAge3N0YXR1c0NvZGV9XG4gICAgICAgICAgICA8L2gxPlxuICAgICAgICAgICkgOiBudWxsfVxuICAgICAgICAgIDxkaXYgc3R5bGU9e3N0eWxlcy53cmFwfT5cbiAgICAgICAgICAgIDxoMiBzdHlsZT17c3R5bGVzLmgyfT5cbiAgICAgICAgICAgICAge3RoaXMucHJvcHMudGl0bGUgfHwgc3RhdHVzQ29kZSA/IChcbiAgICAgICAgICAgICAgICB0aXRsZVxuICAgICAgICAgICAgICApIDogKFxuICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICBBcHBsaWNhdGlvbiBlcnJvcjogYSBjbGllbnQtc2lkZSBleGNlcHRpb24gaGFzIG9jY3VycmVkeycgJ31cbiAgICAgICAgICAgICAgICAgIHtCb29sZWFuKHRoaXMucHJvcHMuaG9zdG5hbWUpICYmIChcbiAgICAgICAgICAgICAgICAgICAgPD53aGlsZSBsb2FkaW5nIHt0aGlzLnByb3BzLmhvc3RuYW1lfTwvPlxuICAgICAgICAgICAgICAgICAgKX17JyAnfVxuICAgICAgICAgICAgICAgICAgKHNlZSB0aGUgYnJvd3NlciBjb25zb2xlIGZvciBtb3JlIGluZm9ybWF0aW9uKVxuICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAuXG4gICAgICAgICAgICA8L2gyPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIClcbiAgfVxufVxuIl0sIm5hbWVzIjpbIkVycm9yIiwic3RhdHVzQ29kZXMiLCJfZ2V0SW5pdGlhbFByb3BzIiwicmVxIiwicmVzIiwiZXJyIiwic3RhdHVzQ29kZSIsImhvc3RuYW1lIiwid2luZG93IiwibG9jYXRpb24iLCJnZXRSZXF1ZXN0TWV0YSIsInJlcXVpcmUiLCJpbml0VXJsIiwidXJsIiwiVVJMIiwic3R5bGVzIiwiZXJyb3IiLCJmb250RmFtaWx5IiwiaGVpZ2h0IiwidGV4dEFsaWduIiwiZGlzcGxheSIsImZsZXhEaXJlY3Rpb24iLCJhbGlnbkl0ZW1zIiwianVzdGlmeUNvbnRlbnQiLCJkZXNjIiwibGluZUhlaWdodCIsImgxIiwibWFyZ2luIiwicGFkZGluZ1JpZ2h0IiwiZm9udFNpemUiLCJmb250V2VpZ2h0IiwidmVydGljYWxBbGlnbiIsImgyIiwid3JhcCIsIlJlYWN0IiwiQ29tcG9uZW50IiwicmVuZGVyIiwid2l0aERhcmtNb2RlIiwicHJvcHMiLCJ0aXRsZSIsImRpdiIsInN0eWxlIiwiSGVhZCIsImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIiwiX19odG1sIiwiY2xhc3NOYW1lIiwiQm9vbGVhbiIsImRpc3BsYXlOYW1lIiwiZ2V0SW5pdGlhbFByb3BzIiwib3JpZ0dldEluaXRpYWxQcm9wcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7O2VBZ0ZxQkE7Ozs7O2dFQWhGSDsrREFDRDtBQUdqQixNQUFNQyxjQUEwQztJQUM5QyxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0FBQ1A7QUFTQSxTQUFTQyxpQkFBaUIsS0FJUjtJQUpRLElBQUEsRUFDeEJDLEdBQUcsRUFDSEMsR0FBRyxFQUNIQyxHQUFHLEVBQ2EsR0FKUTtJQUt4QixNQUFNQyxhQUNKRixPQUFPQSxJQUFJRSxVQUFVLEdBQUdGLElBQUlFLFVBQVUsR0FBR0QsTUFBTUEsSUFBSUMsVUFBVSxHQUFJO0lB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ZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA0MzM1LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZXJyb3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3QvcGFnZXMvX2Vycm9yJylcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLE9BQU8iLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNDM0MCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL3NlcnZlci9saWIvY2FjaGUtY29udHJvbC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDQUNIRV9PTkVfWUVBUiB9IGZyb20gJy4uLy4uL2xpYi9jb25zdGFudHMnXG5cbi8qKlxuICogVGhlIHJldmFsaWRhdGUgb3B0aW9uIHVzZWQgaW50ZXJuYWxseSBmb3IgcGFnZXMuIEEgdmFsdWUgb2YgYGZhbHNlYCBtZWFuc1xuICogdGhhdCB0aGUgcGFnZSBzaG91bGQgbm90IGJlIHJldmFsaWRhdGVkLiBBIG51bWJlciBtZWFucyB0aGF0IHRoZSBwYWdlXG4gKiBzaG91bGQgYmUgcmV2YWxpZGF0ZWQgYWZ0ZXIgdGhlIGdpdmVuIG51bWJlciBvZiBzZWNvbmRzICh0aGlzIGFsc28gaW5jbHVkZXNcbiAqIGAxYCB3aGljaCBtZWFucyB0byByZXZhbGlkYXRlIGFmdGVyIDEgc2Vjb25kKS4gQSB2YWx1ZSBvZiBgMGAgaXMgbm90IGEgdmFsaWRcbiAqIHZhbHVlIGZvciB0aGlzIG9wdGlvbi5cbiAqL1xuZXhwb3J0IHR5cGUgUmV2YWxpZGF0ZSA9IG51bWJlciB8IGZhbHNlXG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2FjaGVDb250cm9sIHtcbiAgcmV2YWxpZGF0ZTogUmV2YWxpZGF0ZVxuICBleHBpcmU6IG51bWJlciB8IHVuZGVmaW5lZFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2FjaGVDb250cm9sSGVhZGVyKHtcbiAgcmV2YWxpZGF0ZSxcbiAgZXhwaXJlLFxufTogQ2FjaGVDb250cm9sKTogc3RyaW5nIHtcbiAgY29uc3Qgc3dySGVhZGVyID1cbiAgICB0eXBlb2YgcmV2YWxpZGF0ZSA9PT0gJ251bWJlcicgJiZcbiAgICBleHBpcmUgIT09IHVuZGVmaW5lZCAmJlxuICAgIHJldmFsaWRhdGUgPCBleHBpcmVcbiAgICAgID8gYCwgc3RhbGUtd2hpbGUtcmV2YWxpZGF0ZT0ke2V4cGlyZSAtIHJldmFsaWRhdGV9YFxuICAgICAgOiAnJ1xuXG4gIGlmIChyZXZhbGlkYXRlID09PSAwKSB7XG4gICAgcmV0dXJuICdwcml2YXRlLCBuby1jYWNoZSwgbm8tc3RvcmUsIG1heC1hZ2U9MCwgbXVzdC1yZXZhbGlkYXRlJ1xuICB9IGVsc2UgaWYgKHR5cGVvZiByZXZhbGlkYXRlID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBgcy1tYXhhZ2U9JHtyZXZhbGlkYXRlfSR7c3dySGVhZGVyfWBcbiAgfVxuXG4gIHJldHVybiBgcy1tYXhhZ2U9JHtDQUNIRV9PTkVfWUVBUn0ke3N3ckhlYWRlcn1gXG59XG4iXSwibmFtZXMiOlsiQ0FDSEVfT05FX1lFQVIiLCJnZXRDYWNoZUNvbnRyb2xIZWFkZXIiLCJyZXZhbGlkYXRlIiwiZXhwaXJlIiwic3dySGVhZGVyIiwidW5kZWZpbmVkIl0sIm1hcHBpbmdzIjoiOzs7QUFBQSxTQUFTQSxjQUFjLFFBQVEsc0JBQXFCOztBQWdCN0MsU0FBU0Msc0JBQXNCLEVBQ3BDQyxVQUFVLEVBQ1ZDLE1BQU0sRUFDTztJQUNiLE1BQU1DLFlBQ0osT0FBT0YsZUFBZSxZQUN0QkMsV0FBV0UsYUFDWEgsYUFBYUMsU0FDVCxDQUFDLHlCQUF5QixFQUFFQSxTQUFTRCxZQUFZLEdBQ2pEO0lBRU4sSUFBSUEsZUFBZSxHQUFHO1FBQ3BCLE9BQU87SUFDVCxPQUFPLElBQUksT0FBT0EsZUFBZSxVQUFVO1FBQ3pDLE9BQU8sQ0FBQyxTQUFTLEVBQUVBLGFBQWFFLFdBQVc7SUFDN0M7SUFFQSxPQUFPLENBQUMsU0FBUyxtSkFBRUosaUJBQUFBLEdBQWlCSSxXQUFXO0FBQ2pEIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDQzNTgsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NyYy9zaGFyZWQvbGliL3V0aWxzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgSHRtbFByb3BzIH0gZnJvbSAnLi9odG1sLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgdHlwZSB7IENvbXBvbmVudFR5cGUsIEpTWCB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHR5cGUgeyBEb21haW5Mb2NhbGUgfSBmcm9tICcuLi8uLi9zZXJ2ZXIvY29uZmlnJ1xuaW1wb3J0IHR5cGUgeyBFbnYgfSBmcm9tICdAbmV4dC9lbnYnXG5pbXBvcnQgdHlwZSB7IEluY29taW5nTWVzc2FnZSwgU2VydmVyUmVzcG9uc2UgfSBmcm9tICdodHRwJ1xuaW1wb3J0IHR5cGUgeyBOZXh0Um91dGVyIH0gZnJvbSAnLi9yb3V0ZXIvcm91dGVyJ1xuaW1wb3J0IHR5cGUgeyBQYXJzZWRVcmxRdWVyeSB9IGZyb20gJ3F1ZXJ5c3RyaW5nJ1xuaW1wb3J0IHR5cGUgeyBQcmV2aWV3RGF0YSB9IGZyb20gJy4uLy4uL3R5cGVzJ1xuaW1wb3J0IHR5cGUgeyBDT01QSUxFUl9OQU1FUyB9IGZyb20gJy4vY29uc3RhbnRzJ1xuaW1wb3J0IHR5cGUgZnMgZnJvbSAnZnMnXG5cbmV4cG9ydCB0eXBlIE5leHRDb21wb25lbnRUeXBlPFxuICBDb250ZXh0IGV4dGVuZHMgQmFzZUNvbnRleHQgPSBOZXh0UGFnZUNvbnRleHQsXG4gIEluaXRpYWxQcm9wcyA9IHt9LFxuICBQcm9wcyA9IHt9LFxuPiA9IENvbXBvbmVudFR5cGU8UHJvcHM+ICYge1xuICAvKipcbiAgICogVXNlZCBmb3IgaW5pdGlhbCBwYWdlIGxvYWQgZGF0YSBwb3B1bGF0aW9uLiBEYXRhIHJldHVybmVkIGZyb20gYGdldEluaXRpYWxQcm9wc2AgaXMgc2VyaWFsaXplZCB3aGVuIHNlcnZlciByZW5kZXJlZC5cbiAgICogTWFrZSBzdXJlIHRvIHJldHVybiBwbGFpbiBgT2JqZWN0YCB3aXRob3V0IHVzaW5nIGBEYXRlYCwgYE1hcGAsIGBTZXRgLlxuICAgKiBAcGFyYW0gY29udGV4dCBDb250ZXh0IG9mIGBwYWdlYFxuICAgKi9cbiAgZ2V0SW5pdGlhbFByb3BzPyhjb250ZXh0OiBDb250ZXh0KTogSW5pdGlhbFByb3BzIHwgUHJvbWlzZTxJbml0aWFsUHJvcHM+XG59XG5cbmV4cG9ydCB0eXBlIERvY3VtZW50VHlwZSA9IE5leHRDb21wb25lbnRUeXBlPFxuICBEb2N1bWVudENvbnRleHQsXG4gIERvY3VtZW50SW5pdGlhbFByb3BzLFxuICBEb2N1bWVudFByb3BzXG4+XG5cbmV4cG9ydCB0eXBlIEFwcFR5cGU8UCA9IHt9PiA9IE5leHRDb21wb25lbnRUeXBlPFxuICBBcHBDb250ZXh0VHlwZSxcbiAgUCxcbiAgQXBwUHJvcHNUeXBlPGFueSwgUD5cbj5cblxuZXhwb3J0IHR5cGUgQXBwVHJlZVR5cGUgPSBDb21wb25lbnRUeXBlPFxuICBBcHBJbml0aWFsUHJvcHMgJiB7IFtuYW1lOiBzdHJpbmddOiBhbnkgfVxuPlxuXG4vKipcbiAqIFdlYiB2aXRhbHMgcHJvdmlkZWQgdG8gX2FwcC5yZXBvcnRXZWJWaXRhbHMgYnkgQ29yZSBXZWIgVml0YWxzIHBsdWdpbiBkZXZlbG9wZWQgYnkgR29vZ2xlIENocm9tZSB0ZWFtLlxuICogaHR0cHM6Ly9uZXh0anMub3JnL2Jsb2cvbmV4dC05LTQjaW50ZWdyYXRlZC13ZWItdml0YWxzLXJlcG9ydGluZ1xuICovXG5leHBvcnQgY29uc3QgV0VCX1ZJVEFMUyA9IFsnQ0xTJywgJ0ZDUCcsICdGSUQnLCAnSU5QJywgJ0xDUCcsICdUVEZCJ10gYXMgY29uc3RcbmV4cG9ydCB0eXBlIE5leHRXZWJWaXRhbHNNZXRyaWMgPSB7XG4gIGlkOiBzdHJpbmdcbiAgc3RhcnRUaW1lOiBudW1iZXJcbiAgdmFsdWU6IG51bWJlclxuICBhdHRyaWJ1dGlvbj86IHsgW2tleTogc3RyaW5nXTogdW5rbm93biB9XG59ICYgKFxuICB8IHtcbiAgICAgIGxhYmVsOiAnd2ViLXZpdGFsJ1xuICAgICAgbmFtZTogKHR5cGVvZiBXRUJfVklUQUxTKVtudW1iZXJdXG4gICAgfVxuICB8IHtcbiAgICAgIGxhYmVsOiAnY3VzdG9tJ1xuICAgICAgbmFtZTpcbiAgICAgICAgfCAnTmV4dC5qcy1oeWRyYXRpb24nXG4gICAgICAgIHwgJ05leHQuanMtcm91dGUtY2hhbmdlLXRvLXJlbmRlcidcbiAgICAgICAgfCAnTmV4dC5qcy1yZW5kZXInXG4gICAgfVxuKVxuXG5leHBvcnQgdHlwZSBFbmhhbmNlcjxDPiA9IChDb21wb25lbnQ6IEMpID0+IENcblxuZXhwb3J0IHR5cGUgQ29tcG9uZW50c0VuaGFuY2VyID1cbiAgfCB7XG4gICAgICBlbmhhbmNlQXBwPzogRW5oYW5jZXI8QXBwVHlwZT5cbiAgICAgIGVuaGFuY2VDb21wb25lbnQ/OiBFbmhhbmNlcjxOZXh0Q29tcG9uZW50VHlwZT5cbiAgICB9XG4gIHwgRW5oYW5jZXI8TmV4dENvbXBvbmVudFR5cGU+XG5cbmV4cG9ydCB0eXBlIFJlbmRlclBhZ2VSZXN1bHQgPSB7XG4gIGh0bWw6IHN0cmluZ1xuICBoZWFkPzogQXJyYXk8SlNYLkVsZW1lbnQgfCBudWxsPlxufVxuXG5leHBvcnQgdHlwZSBSZW5kZXJQYWdlID0gKFxuICBvcHRpb25zPzogQ29tcG9uZW50c0VuaGFuY2VyXG4pID0+IERvY3VtZW50SW5pdGlhbFByb3BzIHwgUHJvbWlzZTxEb2N1bWVudEluaXRpYWxQcm9wcz5cblxuZXhwb3J0IHR5cGUgQmFzZUNvbnRleHQgPSB7XG4gIHJlcz86IFNlcnZlclJlc3BvbnNlXG4gIFtrOiBzdHJpbmddOiBhbnlcbn1cblxuZXhwb3J0IHR5cGUgTkVYVF9EQVRBID0ge1xuICBwcm9wczogUmVjb3JkPHN0cmluZywgYW55PlxuICBwYWdlOiBzdHJpbmdcbiAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5XG4gIGJ1aWxkSWQ6IHN0cmluZ1xuICBhc3NldFByZWZpeD86IHN0cmluZ1xuICBydW50aW1lQ29uZmlnPzogeyBba2V5OiBzdHJpbmddOiBhbnkgfVxuICBuZXh0RXhwb3J0PzogYm9vbGVhblxuICBhdXRvRXhwb3J0PzogYm9vbGVhblxuICBpc0ZhbGxiYWNrPzogYm9vbGVhblxuICBpc0V4cGVyaW1lbnRhbENvbXBpbGU/OiBib29sZWFuXG4gIGR5bmFtaWNJZHM/OiAoc3RyaW5nIHwgbnVtYmVyKVtdXG4gIGVycj86IEVycm9yICYge1xuICAgIHN0YXR1c0NvZGU/OiBudW1iZXJcbiAgICBzb3VyY2U/OiB0eXBlb2YgQ09NUElMRVJfTkFNRVMuc2VydmVyIHwgdHlwZW9mIENPTVBJTEVSX05BTUVTLmVkZ2VTZXJ2ZXJcbiAgfVxuICBnc3A/OiBib29sZWFuXG4gIGdzc3A/OiBib29sZWFuXG4gIGN1c3RvbVNlcnZlcj86IGJvb2xlYW5cbiAgZ2lwPzogYm9vbGVhblxuICBhcHBHaXA/OiBib29sZWFuXG4gIGxvY2FsZT86IHN0cmluZ1xuICBsb2NhbGVzPzogcmVhZG9ubHkgc3RyaW5nW11cbiAgZGVmYXVsdExvY2FsZT86IHN0cmluZ1xuICBkb21haW5Mb2NhbGVzPzogcmVhZG9ubHkgRG9tYWluTG9jYWxlW11cbiAgc2NyaXB0TG9hZGVyPzogYW55W11cbiAgaXNQcmV2aWV3PzogYm9vbGVhblxuICBub3RGb3VuZFNyY1BhZ2U/OiBzdHJpbmdcbn1cblxuLyoqXG4gKiBgTmV4dGAgY29udGV4dFxuICovXG5leHBvcnQgaW50ZXJmYWNlIE5leHRQYWdlQ29udGV4dCB7XG4gIC8qKlxuICAgKiBFcnJvciBvYmplY3QgaWYgZW5jb3VudGVyZWQgZHVyaW5nIHJlbmRlcmluZ1xuICAgKi9cbiAgZXJyPzogKEVycm9yICYgeyBzdGF0dXNDb2RlPzogbnVtYmVyIH0pIHwgbnVsbFxuICAvKipcbiAgICogYEhUVFBgIHJlcXVlc3Qgb2JqZWN0LlxuICAgKi9cbiAgcmVxPzogSW5jb21pbmdNZXNzYWdlXG4gIC8qKlxuICAgKiBgSFRUUGAgcmVzcG9uc2Ugb2JqZWN0LlxuICAgKi9cbiAgcmVzPzogU2VydmVyUmVzcG9uc2VcbiAgLyoqXG4gICAqIFBhdGggc2VjdGlvbiBvZiBgVVJMYC5cbiAgICovXG4gIHBhdGhuYW1lOiBzdHJpbmdcbiAgLyoqXG4gICAqIFF1ZXJ5IHN0cmluZyBzZWN0aW9uIG9mIGBVUkxgIHBhcnNlZCBhcyBhbiBvYmplY3QuXG4gICAqL1xuICBxdWVyeTogUGFyc2VkVXJsUXVlcnlcbiAgLyoqXG4gICAqIGBTdHJpbmdgIG9mIHRoZSBhY3R1YWwgcGF0aCBpbmNsdWRpbmcgcXVlcnkuXG4gICAqL1xuICBhc1BhdGg/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGxvY2FsZVxuICAgKi9cbiAgbG9jYWxlPzogc3RyaW5nXG4gIC8qKlxuICAgKiBBbGwgY29uZmlndXJlZCBsb2NhbGVzXG4gICAqL1xuICBsb2NhbGVzPzogcmVhZG9ubHkgc3RyaW5nW11cbiAgLyoqXG4gICAqIFRoZSBjb25maWd1cmVkIGRlZmF1bHQgbG9jYWxlXG4gICAqL1xuICBkZWZhdWx0TG9jYWxlPzogc3RyaW5nXG4gIC8qKlxuICAgKiBgQ29tcG9uZW50YCB0aGUgdHJlZSBvZiB0aGUgQXBwIHRvIHVzZSBpZiBuZWVkaW5nIHRvIHJlbmRlciBzZXBhcmF0ZWx5XG4gICAqL1xuICBBcHBUcmVlOiBBcHBUcmVlVHlwZVxufVxuXG5leHBvcnQgdHlwZSBBcHBDb250ZXh0VHlwZTxSb3V0ZXIgZXh0ZW5kcyBOZXh0Um91dGVyID0gTmV4dFJvdXRlcj4gPSB7XG4gIENvbXBvbmVudDogTmV4dENvbXBvbmVudFR5cGU8TmV4dFBhZ2VDb250ZXh0PlxuICBBcHBUcmVlOiBBcHBUcmVlVHlwZVxuICBjdHg6IE5leHRQYWdlQ29udGV4dFxuICByb3V0ZXI6IFJvdXRlclxufVxuXG5leHBvcnQgdHlwZSBBcHBJbml0aWFsUHJvcHM8UGFnZVByb3BzID0gYW55PiA9IHtcbiAgcGFnZVByb3BzOiBQYWdlUHJvcHNcbn1cblxuZXhwb3J0IHR5cGUgQXBwUHJvcHNUeXBlPFxuICBSb3V0ZXIgZXh0ZW5kcyBOZXh0Um91dGVyID0gTmV4dFJvdXRlcixcbiAgUGFnZVByb3BzID0ge30sXG4+ID0gQXBwSW5pdGlhbFByb3BzPFBhZ2VQcm9wcz4gJiB7XG4gIENvbXBvbmVudDogTmV4dENvbXBvbmVudFR5cGU8TmV4dFBhZ2VDb250ZXh0LCBhbnksIGFueT5cbiAgcm91dGVyOiBSb3V0ZXJcbiAgX19OX1NTRz86IGJvb2xlYW5cbiAgX19OX1NTUD86IGJvb2xlYW5cbn1cblxuZXhwb3J0IHR5cGUgRG9jdW1lbnRDb250ZXh0ID0gTmV4dFBhZ2VDb250ZXh0ICYge1xuICByZW5kZXJQYWdlOiBSZW5kZXJQYWdlXG4gIGRlZmF1bHRHZXRJbml0aWFsUHJvcHMoXG4gICAgY3R4OiBEb2N1bWVudENvbnRleHQsXG4gICAgb3B0aW9ucz86IHsgbm9uY2U/OiBzdHJpbmcgfVxuICApOiBQcm9taXNlPERvY3VtZW50SW5pdGlhbFByb3BzPlxufVxuXG5leHBvcnQgdHlwZSBEb2N1bWVudEluaXRpYWxQcm9wcyA9IFJlbmRlclBhZ2VSZXN1bHQgJiB7XG4gIHN0eWxlcz86IFJlYWN0LlJlYWN0RWxlbWVudFtdIHwgSXRlcmFibGU8UmVhY3QuUmVhY3ROb2RlPiB8IEpTWC5FbGVtZW50XG59XG5cbmV4cG9ydCB0eXBlIERvY3VtZW50UHJvcHMgPSBEb2N1bWVudEluaXRpYWxQcm9wcyAmIEh0bWxQcm9wc1xuXG4vKipcbiAqIE5leHQgYEFQSWAgcm91dGUgcmVxdWVzdFxuICovXG5leHBvcnQgaW50ZXJmYWNlIE5leHRBcGlSZXF1ZXN0IGV4dGVuZHMgSW5jb21pbmdNZXNzYWdlIHtcbiAgLyoqXG4gICAqIE9iamVjdCBvZiBgcXVlcnlgIHZhbHVlcyBmcm9tIHVybFxuICAgKi9cbiAgcXVlcnk6IFBhcnRpYWw8e1xuICAgIFtrZXk6IHN0cmluZ106IHN0cmluZyB8IHN0cmluZ1tdXG4gIH0+XG4gIC8qKlxuICAgKiBPYmplY3Qgb2YgYGNvb2tpZXNgIGZyb20gaGVhZGVyXG4gICAqL1xuICBjb29raWVzOiBQYXJ0aWFsPHtcbiAgICBba2V5OiBzdHJpbmddOiBzdHJpbmdcbiAgfT5cblxuICBib2R5OiBhbnlcblxuICBlbnY6IEVudlxuXG4gIGRyYWZ0TW9kZT86IGJvb2xlYW5cblxuICBwcmV2aWV3PzogYm9vbGVhblxuICAvKipcbiAgICogUHJldmlldyBkYXRhIHNldCBvbiB0aGUgcmVxdWVzdCwgaWYgYW55XG4gICAqICovXG4gIHByZXZpZXdEYXRhPzogUHJldmlld0RhdGFcbn1cblxuLyoqXG4gKiBTZW5kIGJvZHkgb2YgcmVzcG9uc2VcbiAqL1xudHlwZSBTZW5kPFQ+ID0gKGJvZHk6IFQpID0+IHZvaWRcblxuLyoqXG4gKiBOZXh0IGBBUElgIHJvdXRlIHJlc3BvbnNlXG4gKi9cbmV4cG9ydCB0eXBlIE5leHRBcGlSZXNwb25zZTxEYXRhID0gYW55PiA9IFNlcnZlclJlc3BvbnNlICYge1xuICAvKipcbiAgICogU2VuZCBkYXRhIGBhbnlgIGRhdGEgaW4gcmVzcG9uc2VcbiAgICovXG4gIHNlbmQ6IFNlbmQ8RGF0YT5cbiAgLyoqXG4gICAqIFNlbmQgZGF0YSBganNvbmAgZGF0YSBpbiByZXNwb25zZVxuICAgKi9cbiAganNvbjogU2VuZDxEYXRhPlxuICBzdGF0dXM6IChzdGF0dXNDb2RlOiBudW1iZXIpID0+IE5leHRBcGlSZXNwb25zZTxEYXRhPlxuICByZWRpcmVjdCh1cmw6IHN0cmluZyk6IE5leHRBcGlSZXNwb25zZTxEYXRhPlxuICByZWRpcmVjdChzdGF0dXM6IG51bWJlciwgdXJsOiBzdHJpbmcpOiBOZXh0QXBpUmVzcG9uc2U8RGF0YT5cblxuICAvKipcbiAgICogU2V0IGRyYWZ0IG1vZGVcbiAgICovXG4gIHNldERyYWZ0TW9kZTogKG9wdGlvbnM6IHsgZW5hYmxlOiBib29sZWFuIH0pID0+IE5leHRBcGlSZXNwb25zZTxEYXRhPlxuXG4gIC8qKlxuICAgKiBTZXQgcHJldmlldyBkYXRhIGZvciBOZXh0LmpzJyBwcmVyZW5kZXIgbW9kZVxuICAgKi9cbiAgc2V0UHJldmlld0RhdGE6IChcbiAgICBkYXRhOiBvYmplY3QgfCBzdHJpbmcsXG4gICAgb3B0aW9ucz86IHtcbiAgICAgIC8qKlxuICAgICAgICogU3BlY2lmaWVzIHRoZSBudW1iZXIgKGluIHNlY29uZHMpIGZvciB0aGUgcHJldmlldyBzZXNzaW9uIHRvIGxhc3QgZm9yLlxuICAgICAgICogVGhlIGdpdmVuIG51bWJlciB3aWxsIGJlIGNvbnZlcnRlZCB0byBhbiBpbnRlZ2VyIGJ5IHJvdW5kaW5nIGRvd24uXG4gICAgICAgKiBCeSBkZWZhdWx0LCBubyBtYXhpbXVtIGFnZSBpcyBzZXQgYW5kIHRoZSBwcmV2aWV3IHNlc3Npb24gZmluaXNoZXNcbiAgICAgICAqIHdoZW4gdGhlIGNsaWVudCBzaHV0cyBkb3duIChicm93c2VyIGlzIGNsb3NlZCkuXG4gICAgICAgKi9cbiAgICAgIG1heEFnZT86IG51bWJlclxuICAgICAgLyoqXG4gICAgICAgKiBTcGVjaWZpZXMgdGhlIHBhdGggZm9yIHRoZSBwcmV2aWV3IHNlc3Npb24gdG8gd29yayB1bmRlci4gQnkgZGVmYXVsdCxcbiAgICAgICAqIHRoZSBwYXRoIGlzIGNvbnNpZGVyZWQgdGhlIFwiZGVmYXVsdCBwYXRoXCIsIGkuZS4sIGFueSBwYWdlcyB1bmRlciBcIi9cIi5cbiAgICAgICAqL1xuICAgICAgcGF0aD86IHN0cmluZ1xuICAgIH1cbiAgKSA9PiBOZXh0QXBpUmVzcG9uc2U8RGF0YT5cblxuICAvKipcbiAgICogQ2xlYXIgcHJldmlldyBkYXRhIGZvciBOZXh0LmpzJyBwcmVyZW5kZXIgbW9kZVxuICAgKi9cbiAgY2xlYXJQcmV2aWV3RGF0YTogKG9wdGlvbnM/OiB7IHBhdGg/OiBzdHJpbmcgfSkgPT4gTmV4dEFwaVJlc3BvbnNlPERhdGE+XG5cbiAgLyoqXG4gICAqIFJldmFsaWRhdGUgYSBzcGVjaWZpYyBwYWdlIGFuZCByZWdlbmVyYXRlIGl0IHVzaW5nIE9uLURlbWFuZCBJbmNyZW1lbnRhbFxuICAgKiBTdGF0aWMgUmVnZW5lcmF0aW9uLlxuICAgKiBUaGUgcGF0aCBzaG91bGQgYmUgYW4gYWN0dWFsIHBhdGgsIG5vdCBhIHJld3JpdHRlbiBwYXRoLiBFLmcuIGZvclxuICAgKiBcIi9ibG9nL1tzbHVnXVwiIHRoaXMgc2hvdWxkIGJlIFwiL2Jsb2cvcG9zdC0xXCIuXG4gICAqIEBsaW5rIGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL2RhdGEtZmV0Y2hpbmcvaW5jcmVtZW50YWwtc3RhdGljLXJlZ2VuZXJhdGlvbiNvbi1kZW1hbmQtcmV2YWxpZGF0aW9uLXdpdGgtcmV2YWxpZGF0ZXBhdGhcbiAgICovXG4gIHJldmFsaWRhdGU6IChcbiAgICB1cmxQYXRoOiBzdHJpbmcsXG4gICAgb3B0cz86IHtcbiAgICAgIHVuc3RhYmxlX29ubHlHZW5lcmF0ZWQ/OiBib29sZWFuXG4gICAgfVxuICApID0+IFByb21pc2U8dm9pZD5cbn1cblxuLyoqXG4gKiBOZXh0IGBBUElgIHJvdXRlIGhhbmRsZXJcbiAqL1xuZXhwb3J0IHR5cGUgTmV4dEFwaUhhbmRsZXI8VCA9IGFueT4gPSAoXG4gIHJlcTogTmV4dEFwaVJlcXVlc3QsXG4gIHJlczogTmV4dEFwaVJlc3BvbnNlPFQ+XG4pID0+IHVua25vd24gfCBQcm9taXNlPHVua25vd24+XG5cbi8qKlxuICogVXRpbHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4ZWNPbmNlPFQgZXh0ZW5kcyAoLi4uYXJnczogYW55W10pID0+IFJldHVyblR5cGU8VD4+KFxuICBmbjogVFxuKTogVCB7XG4gIGxldCB1c2VkID0gZmFsc2VcbiAgbGV0IHJlc3VsdDogUmV0dXJuVHlwZTxUPlxuXG4gIHJldHVybiAoKC4uLmFyZ3M6IGFueVtdKSA9PiB7XG4gICAgaWYgKCF1c2VkKSB7XG4gICAgICB1c2VkID0gdHJ1ZVxuICAgICAgcmVzdWx0ID0gZm4oLi4uYXJncylcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9KSBhcyBUXG59XG5cbi8vIFNjaGVtZTogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODYjc2VjdGlvbi0zLjFcbi8vIEFic29sdXRlIFVSTDogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODYjc2VjdGlvbi00LjNcbmNvbnN0IEFCU09MVVRFX1VSTF9SRUdFWCA9IC9eW2EtekEtWl1bYS16QS1aXFxkK1xcLS5dKj86L1xuZXhwb3J0IGNvbnN0IGlzQWJzb2x1dGVVcmwgPSAodXJsOiBzdHJpbmcpID0+IEFCU09MVVRFX1VSTF9SRUdFWC50ZXN0KHVybClcblxuZXhwb3J0IGZ1bmN0aW9uIGdldExvY2F0aW9uT3JpZ2luKCkge1xuICBjb25zdCB7IHByb3RvY29sLCBob3N0bmFtZSwgcG9ydCB9ID0gd2luZG93LmxvY2F0aW9uXG4gIHJldHVybiBgJHtwcm90b2NvbH0vLyR7aG9zdG5hbWV9JHtwb3J0ID8gJzonICsgcG9ydCA6ICcnfWBcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFVSTCgpIHtcbiAgY29uc3QgeyBocmVmIH0gPSB3aW5kb3cubG9jYXRpb25cbiAgY29uc3Qgb3JpZ2luID0gZ2V0TG9jYXRpb25PcmlnaW4oKVxuICByZXR1cm4gaHJlZi5zdWJzdHJpbmcob3JpZ2luLmxlbmd0aClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldERpc3BsYXlOYW1lPFA+KENvbXBvbmVudDogQ29tcG9uZW50VHlwZTxQPikge1xuICByZXR1cm4gdHlwZW9mIENvbXBvbmVudCA9PT0gJ3N0cmluZydcbiAgICA/IENvbXBvbmVudFxuICAgIDogQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdVbmtub3duJ1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNSZXNTZW50KHJlczogU2VydmVyUmVzcG9uc2UpIHtcbiAgcmV0dXJuIHJlcy5maW5pc2hlZCB8fCByZXMuaGVhZGVyc1NlbnRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZVJlcGVhdGVkU2xhc2hlcyh1cmw6IHN0cmluZykge1xuICBjb25zdCB1cmxQYXJ0cyA9IHVybC5zcGxpdCgnPycpXG4gIGNvbnN0IHVybE5vUXVlcnkgPSB1cmxQYXJ0c1swXVxuXG4gIHJldHVybiAoXG4gICAgdXJsTm9RdWVyeVxuICAgICAgLy8gZmlyc3Qgd2UgcmVwbGFjZSBhbnkgbm9uLWVuY29kZWQgYmFja3NsYXNoZXMgd2l0aCBmb3J3YXJkXG4gICAgICAvLyB0aGVuIG5vcm1hbGl6ZSByZXBlYXRlZCBmb3J3YXJkIHNsYXNoZXNcbiAgICAgIC5yZXBsYWNlKC9cXFxcL2csICcvJylcbiAgICAgIC5yZXBsYWNlKC9cXC9cXC8rL2csICcvJykgK1xuICAgICh1cmxQYXJ0c1sxXSA/IGA/JHt1cmxQYXJ0cy5zbGljZSgxKS5qb2luKCc/Jyl9YCA6ICcnKVxuICApXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsb2FkR2V0SW5pdGlhbFByb3BzPFxuICBDIGV4dGVuZHMgQmFzZUNvbnRleHQsXG4gIElQID0ge30sXG4gIFAgPSB7fSxcbj4oQXBwOiBOZXh0Q29tcG9uZW50VHlwZTxDLCBJUCwgUD4sIGN0eDogQyk6IFByb21pc2U8SVA+IHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoQXBwLnByb3RvdHlwZT8uZ2V0SW5pdGlhbFByb3BzKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gYFwiJHtnZXREaXNwbGF5TmFtZShcbiAgICAgICAgQXBwXG4gICAgICApfS5nZXRJbml0aWFsUHJvcHMoKVwiIGlzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kIC0gdmlzaXQgaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvZ2V0LWluaXRpYWwtcHJvcHMtYXMtYW4taW5zdGFuY2UtbWV0aG9kIGZvciBtb3JlIGluZm9ybWF0aW9uLmBcbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKVxuICAgIH1cbiAgfVxuICAvLyB3aGVuIGNhbGxlZCBmcm9tIF9hcHAgYGN0eGAgaXMgbmVzdGVkIGluIGBjdHhgXG4gIGNvbnN0IHJlcyA9IGN0eC5yZXMgfHwgKGN0eC5jdHggJiYgY3R4LmN0eC5yZXMpXG5cbiAgaWYgKCFBcHAuZ2V0SW5pdGlhbFByb3BzKSB7XG4gICAgaWYgKGN0eC5jdHggJiYgY3R4LkNvbXBvbmVudCkge1xuICAgICAgLy8gQHRzLWlnbm9yZSBwYWdlUHJvcHMgZGVmYXVsdFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGFnZVByb3BzOiBhd2FpdCBsb2FkR2V0SW5pdGlhbFByb3BzKGN0eC5Db21wb25lbnQsIGN0eC5jdHgpLFxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge30gYXMgSVBcbiAgfVxuXG4gIGNvbnN0IHByb3BzID0gYXdhaXQgQXBwLmdldEluaXRpYWxQcm9wcyhjdHgpXG5cbiAgaWYgKHJlcyAmJiBpc1Jlc1NlbnQocmVzKSkge1xuICAgIHJldHVybiBwcm9wc1xuICB9XG5cbiAgaWYgKCFwcm9wcykge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBgXCIke2dldERpc3BsYXlOYW1lKFxuICAgICAgQXBwXG4gICAgKX0uZ2V0SW5pdGlhbFByb3BzKClcIiBzaG91bGQgcmVzb2x2ZSB0byBhbiBvYmplY3QuIEJ1dCBmb3VuZCBcIiR7cHJvcHN9XCIgaW5zdGVhZC5gXG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpXG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChPYmplY3Qua2V5cyhwcm9wcykubGVuZ3RoID09PSAwICYmICFjdHguY3R4KSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGAke2dldERpc3BsYXlOYW1lKFxuICAgICAgICAgIEFwcFxuICAgICAgICApfSByZXR1cm5lZCBhbiBlbXB0eSBvYmplY3QgZnJvbSBcXGBnZXRJbml0aWFsUHJvcHNcXGAuIFRoaXMgZGUtb3B0aW1pemVzIGFuZCBwcmV2ZW50cyBhdXRvbWF0aWMgc3RhdGljIG9wdGltaXphdGlvbi4gaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvZW1wdHktb2JqZWN0LWdldEluaXRpYWxQcm9wc2BcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcHJvcHNcbn1cblxuZXhwb3J0IGNvbnN0IFNQID0gdHlwZW9mIHBlcmZvcm1hbmNlICE9PSAndW5kZWZpbmVkJ1xuZXhwb3J0IGNvbnN0IFNUID1cbiAgU1AgJiZcbiAgKFsnbWFyaycsICdtZWFzdXJlJywgJ2dldEVudHJpZXNCeU5hbWUnXSBhcyBjb25zdCkuZXZlcnkoXG4gICAgKG1ldGhvZCkgPT4gdHlwZW9mIHBlcmZvcm1hbmNlW21ldGhvZF0gPT09ICdmdW5jdGlvbidcbiAgKVxuXG5leHBvcnQgY2xhc3MgRGVjb2RlRXJyb3IgZXh0ZW5kcyBFcnJvciB7fVxuZXhwb3J0IGNsYXNzIE5vcm1hbGl6ZUVycm9yIGV4dGVuZHMgRXJyb3Ige31cbmV4cG9ydCBjbGFzcyBQYWdlTm90Rm91bmRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29kZTogc3RyaW5nXG5cbiAgY29uc3RydWN0b3IocGFnZTogc3RyaW5nKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuY29kZSA9ICdFTk9FTlQnXG4gICAgdGhpcy5uYW1lID0gJ1BhZ2VOb3RGb3VuZEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IGBDYW5ub3QgZmluZCBtb2R1bGUgZm9yIHBhZ2U6ICR7cGFnZX1gXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIE1pc3NpbmdTdGF0aWNQYWdlIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihwYWdlOiBzdHJpbmcsIG1lc3NhZ2U6IHN0cmluZykge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLm1lc3NhZ2UgPSBgRmFpbGVkIHRvIGxvYWQgc3RhdGljIGZpbGUgZm9yIHBhZ2U6ICR7cGFnZX0gJHttZXNzYWdlfWBcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgTWlkZGxld2FyZU5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvZGU6IHN0cmluZ1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5jb2RlID0gJ0VOT0VOVCdcbiAgICB0aGlzLm1lc3NhZ2UgPSBgQ2Fubm90IGZpbmQgdGhlIG1pZGRsZXdhcmUgbW9kdWxlYFxuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2FjaGVGcyB7XG4gIGV4aXN0c1N5bmM6IHR5cGVvZiBmcy5leGlzdHNTeW5jXG4gIHJlYWRGaWxlOiB0eXBlb2YgZnMucHJvbWlzZXMucmVhZEZpbGVcbiAgcmVhZEZpbGVTeW5jOiB0eXBlb2YgZnMucmVhZEZpbGVTeW5jXG4gIHdyaXRlRmlsZShmOiBzdHJpbmcsIGQ6IGFueSk6IFByb21pc2U8dm9pZD5cbiAgbWtkaXIoZGlyOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQgfCBzdHJpbmc+XG4gIHN0YXQoZjogc3RyaW5nKTogUHJvbWlzZTx7IG10aW1lOiBEYXRlIH0+XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdpZnlFcnJvcihlcnJvcjogRXJyb3IpIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHsgbWVzc2FnZTogZXJyb3IubWVzc2FnZSwgc3RhY2s6IGVycm9yLnN0YWNrIH0pXG59XG4iXSwibmFtZXMiOlsiV0VCX1ZJVEFMUyIsImV4ZWNPbmNlIiwiZm4iLCJ1c2VkIiwicmVzdWx0IiwiYXJncyIsIkFCU09MVVRFX1VSTF9SRUdFWCIsImlzQWJzb2x1dGVVcmwiLCJ1cmwiLCJ0ZXN0IiwiZ2V0TG9jYXRpb25PcmlnaW4iLCJwcm90b2NvbCIsImhvc3RuYW1lIiwicG9ydCIsIndpbmRvdyIsImxvY2F0aW9uIiwiZ2V0VVJMIiwiaHJlZiIsIm9yaWdpbiIsInN1YnN0cmluZyIsImxlbmd0aCIsImdldERpc3BsYXlOYW1lIiwiQ29tcG9uZW50IiwiZGlzcGxheU5hbWUiLCJuYW1lIiwiaXNSZXNTZW50IiwicmVzIiwiZmluaXNoZWQiLCJoZWFkZXJzU2VudCIsIm5vcm1hbGl6ZVJlcGVhdGVkU2xhc2hlcyIsInVybFBhcnRzIiwic3BsaXQiLCJ1cmxOb1F1ZXJ5IiwicmVwbGFjZSIsInNsaWNlIiwiam9pbiIsImxvYWRHZXRJbml0aWFsUHJvcHMiLCJBcHAiLCJjdHgiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJwcm90b3R5cGUiLCJnZXRJbml0aWFsUHJvcHMiLCJtZXNzYWdlIiwiRXJyb3IiLCJwYWdlUHJvcHMiLCJwcm9wcyIsIk9iamVjdCIsImtleXMiLCJjb25zb2xlIiwid2FybiIsIlNQIiwicGVyZm9ybWFuY2UiLCJTVCIsImV2ZXJ5IiwibWV0aG9kIiwiRGVjb2RlRXJyb3IiLCJOb3JtYWxpemVFcnJvciIsIlBhZ2VOb3RGb3VuZEVycm9yIiwiY29uc3RydWN0b3IiLCJwYWdlIiwiY29kZSIsIk1pc3NpbmdTdGF0aWNQYWdlIiwiTWlkZGxld2FyZU5vdEZvdW5kRXJyb3IiLCJzdHJpbmdpZnlFcnJvciIsImVycm9yIiwiSlNPTiIsInN0cmluZ2lmeSIsInN0YWNrIl0sIm1hcHBpbmdzIjoiQUF3Q0E7OztDQUdDLEdBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBTyxNQUFNQSxhQUFhO0lBQUM7SUFBTztJQUFPO0lBQU87SUFBTztJ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O0lBQUM7QUFDckUiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNDUxMSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL2NsaWVudC9jb21wb25lbnRzL3JlZGlyZWN0LXN0YXR1cy1jb2RlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBlbnVtIFJlZGlyZWN0U3RhdHVzQ29kZSB7XG4gIFNlZU90aGVyID0gMzAzLFxuICBUZW1wb3JhcnlSZWRpcmVjdCA9IDMwNyxcbiAgUGVybWFuZW50UmVkaXJlY3QgPSAzMDgsXG59XG4iXSwibmFtZXMiOlsiUmVkaXJlY3RTdGF0dXNDb2RlIl0sIm1hcHBpbmdzIjoiOzs7QUFBTyxJQUFLQSxxQkFBQUEsV0FBQUEsR0FBQUEsU0FBQUEsa0JBQUFBOzs7O1dBQUFBO01BSVgiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNDUyNCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL2xpYi9yZWRpcmVjdC1zdGF0dXMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUmVkaXJlY3RTdGF0dXNDb2RlIH0gZnJvbSAnLi4vY2xpZW50L2NvbXBvbmVudHMvcmVkaXJlY3Qtc3RhdHVzLWNvZGUnXG5cbmV4cG9ydCBjb25zdCBhbGxvd2VkU3RhdHVzQ29kZXMgPSBuZXcgU2V0KFszMDEsIDMwMiwgMzAzLCAzMDcsIDMwOF0pXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSZWRpcmVjdFN0YXR1cyhyb3V0ZToge1xuICBzdGF0dXNDb2RlPzogbnVtYmVyXG4gIHBlcm1hbmVudD86IGJvb2xlYW5cbn0pOiBudW1iZXIge1xuICByZXR1cm4gKFxuICAgIHJvdXRlLnN0YXR1c0NvZGUgfHxcbiAgICAocm91dGUucGVybWFuZW50XG4gICAgICA/IFJlZGlyZWN0U3RhdHVzQ29kZS5QZXJtYW5lbnRSZWRpcmVjdFxuICAgICAgOiBSZWRpcmVjdFN0YXR1c0NvZGUuVGVtcG9yYXJ5UmVkaXJlY3QpXG4gIClcbn1cblxuLy8gZm9yIHJlZGlyZWN0cyB3ZSByZXN0cmljdCBtYXRjaGluZyAvX25leHQgYW5kIGZvciBhbGwgcm91dGVzXG4vLyB3ZSBhZGQgYW4gb3B0aW9uYWwgdHJhaWxpbmcgc2xhc2ggYXQgdGhlIGVuZCBmb3IgZWFzaWVyXG4vLyBjb25maWd1cmluZyBiZXR3ZWVuIHRyYWlsaW5nU2xhc2g6IHRydWUvZmFsc2VcbmV4cG9ydCBmdW5jdGlvbiBtb2RpZnlSb3V0ZVJlZ2V4KHJlZ2V4OiBzdHJpbmcsIHJlc3RyaWN0ZWRQYXRocz86IHN0cmluZ1tdKSB7XG4gIGlmIChyZXN0cmljdGVkUGF0aHMpIHtcbiAgICByZWdleCA9IHJlZ2V4LnJlcGxhY2UoXG4gICAgICAvXFxeLyxcbiAgICAgIGBeKD8hJHtyZXN0cmljdGVkUGF0aHNcbiAgICAgICAgLm1hcCgocGF0aCkgPT4gcGF0aC5yZXBsYWNlKC9cXC8vZywgJ1xcXFwvJykpXG4gICAgICAgIC5qb2luKCd8Jyl9KWBcbiAgICApXG4gIH1cbiAgcmVnZXggPSByZWdleC5yZXBsYWNlKC9cXCQkLywgJyg/OlxcXFwvKT8kJylcbiAgcmV0dXJuIHJlZ2V4XG59XG4iXSwibmFtZXMiOlsiUmVkaXJlY3RTdGF0dXNDb2RlIiwiYWxsb3dlZFN0YXR1c0NvZGVzIiwiU2V0IiwiZ2V0UmVkaXJlY3RTdGF0dXMiLCJyb3V0ZSIsInN0YXR1c0NvZGUiLCJwZXJtYW5lbnQiLCJQZXJtYW5lbnRSZWRpcmVjdCIsIlRlbXBvcmFyeVJlZGlyZWN0IiwibW9kaWZ5Um91dGVSZWdleCIsInJlZ2V4IiwicmVzdHJpY3RlZFBhdGhzIiwicmVwbGFjZSIsIm1hcCIsInBhdGgiLCJqb2luIl0sIm1hcHBpbmdzIjoiOzs7OztBQUFBLFNBQVNBLGtCQUFrQixRQUFRLDRDQUEyQzs7QUFFdkUsTUFBTUMscUJBQXFCLElBQUlDLElBQUk7SUFBQztJQUFLO0lBQUs7SUFBSztJQUFLO0NBQUksRUFBQztBQUU3RCxTQUFTQyxrQkFBa0JDLEtBR2pDO0lBQ0MsT0FDRUEsTUFBTUMsVUFBVSxJQUNmRCxDQUFBQSxNQUFNRSxTQUFTLHNMQUNaTixxQkFBQUEsQ0FBbUJPLGlCQUFpQixzTEFDcENQLHFCQUFBQSxDQUFtQlEsaUJBQWdCO0FBRTNDO0FBS08sU0FBU0MsaUJBQWlCQyxLQUFhLEVBQUVDLGVBQTBCO0lBQ3hFLElBQUlBLGlCQUFpQjtRQUNuQkQsUUFBUUEsTUFBTUUsT0FBTyxDQUNuQixNQUNBLENBQUMsSUFBSSxFQUFFRCxnQkFDSkUsR0FBRyxDQUFDLENBQUNDLE9BQVNBLEtBQUtGLE9BQU8sQ0FBQyxPQUFPLFFBQ2xDRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7SUFFbkI7SUFDQUwsUUFBUUEsTUFBTUUsT0FBTyxDQUFDLE9BQU87SUFDN0IsT0FBT0Y7QUFDVCIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA0NTUyLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zcmMvc2VydmVyL2xpYi9ldGFnLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRk5WLTFhIEhhc2ggaW1wbGVtZW50YXRpb25cbiAqIEBhdXRob3IgVHJhdmlzIFdlYmIgKHRqd2ViYikgPG1lQHRyYXZpc3dlYmIuY29tPlxuICpcbiAqIFBvcnRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS90andlYmIvZm52LXBsdXMvYmxvYi9tYXN0ZXIvaW5kZXguanNcbiAqXG4gKiBTaW1wbGlmaWVkLCBvcHRpbWl6ZWQgYW5kIGFkZCBtb2RpZmllZCBmb3IgNTIgYml0LCB3aGljaCBwcm92aWRlcyBhIGxhcmdlciBoYXNoIHNwYWNlXG4gKiBhbmQgc3RpbGwgbWFraW5nIHVzZSBvZiBKYXZhc2NyaXB0J3MgNTMtYml0IGludGVnZXIgc3BhY2UuXG4gKi9cbmV4cG9ydCBjb25zdCBmbnYxYTUyID0gKHN0cjogc3RyaW5nKSA9PiB7XG4gIGNvbnN0IGxlbiA9IHN0ci5sZW5ndGhcbiAgbGV0IGkgPSAwLFxuICAgIHQwID0gMCxcbiAgICB2MCA9IDB4MjMyNSxcbiAgICB0MSA9IDAsXG4gICAgdjEgPSAweDg0MjIsXG4gICAgdDIgPSAwLFxuICAgIHYyID0gMHg5Y2U0LFxuICAgIHQzID0gMCxcbiAgICB2MyA9IDB4Y2JmMlxuXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgdjAgXj0gc3RyLmNoYXJDb2RlQXQoaSsrKVxuICAgIHQwID0gdjAgKiA0MzVcbiAgICB0MSA9IHYxICogNDM1XG4gICAgdDIgPSB2MiAqIDQzNVxuICAgIHQzID0gdjMgKiA0MzVcbiAgICB0MiArPSB2MCA8PCA4XG4gICAgdDMgKz0gdjEgPDwgOFxuICAgIHQxICs9IHQwID4+PiAxNlxuICAgIHYwID0gdDAgJiA2NTUzNVxuICAgIHQyICs9IHQxID4+PiAxNlxuICAgIHYxID0gdDEgJiA2NTUzNVxuICAgIHYzID0gKHQzICsgKHQyID4+PiAxNikpICYgNjU1MzVcbiAgICB2MiA9IHQyICYgNjU1MzVcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgKHYzICYgMTUpICogMjgxNDc0OTc2NzEwNjU2ICtcbiAgICB2MiAqIDQyOTQ5NjcyOTYgK1xuICAgIHYxICogNjU1MzYgK1xuICAgICh2MCBeICh2MyA+PiA0KSlcbiAgKVxufVxuXG5leHBvcnQgY29uc3QgZ2VuZXJhdGVFVGFnID0gKHBheWxvYWQ6IHN0cmluZywgd2VhayA9IGZhbHNlKSA9PiB7XG4gIGNvbnN0IHByZWZpeCA9IHdlYWsgPyAnVy9cIicgOiAnXCInXG4gIHJldHVybiAoXG4gICAgcHJlZml4ICsgZm52MWE1MihwYXlsb2FkKS50b1N0cmluZygzNikgKyBwYXlsb2FkLmxlbmd0aC50b1N0cmluZygzNikgKyAnXCInXG4gIClcbn1cbiJdLCJuYW1lcyI6WyJmbnYxYTUyIiwic3RyIiwibGVuIiwibGVuZ3RoIiwiaSIsInQwIiwidjAiLCJ0MSIsInYxIiwidDIiLCJ2MiIsInQzIiwidjMiLCJjaGFyQ29kZUF0IiwiZ2VuZXJhdGVFVGFnIiwicGF5bG9hZCIsIndlYWsiLCJwcmVmaXgiLCJ0b1N0cmluZyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0NBUUMsR0FDRDs7OztBQUFPLE1BQU1BLFVBQVUsQ0FBQ0M7SUFDdEIsTUFBTUMsTUFBTUQsSUFBSUUsTUFBTTtJQUN0QixJQUFJQyxJQUFJLEdBQ05DLEtBQUssR0FDTEMsS0FBSyxRQUNMQyxLQUFLLEdBQ0xDLEtBQUssUUFDTEMsS0FBSyxHQUNMQyxLQUFLLFFBQ0xDLEtBQUssR0FDTEMsS0FBSztJQUVQLE1BQU9SLElBQUlGLElBQUs7UUFDZEksTUFBTUwsSUFBSVksVUFBVSxDQUFDVDtRQUNyQkMsS0FBS0MsS0FBSztRQUNWQyxLQUFLQyxLQUFLO1FBQ1ZDLEtBQUtDLEtBQUs7UUFDVkMsS0FBS0MsS0FBSztRQUNWSCxNQUFNSCxNQUFNO1FBQ1pLLE1BQU1ILE1BQU07UUFDWkQsTUFBTUYsT0FBTztRQUNiQyxLQUFLRCxLQUFLO1FBQ1ZJLE1BQU1GLE9BQU87UUFDYkMsS0FBS0QsS0FBSztRQUNWSyxLQUFNRCxLQUFNRixDQUFBQSxPQUFPLEVBQUMsSUFBTTtRQUMxQkMsS0FBS0QsS0FBSztJQUNaO0lBRUEsT0FDR0csQ0FBQUEsS0FBSyxFQUFDLElBQUssa0JBQ1pGLEtBQUssYUFDTEYsS0FBSyxRQUNKRixDQUFBQSxLQUFNTSxNQUFNLENBQUM7QUFFbEIsRUFBQztBQUVNLE1BQU1FLGVBQWUsQ0FBQ0MsU0FBaUJDLE9BQU8sS0FBSztJQUN4RCxNQUFNQyxTQUFTRCxPQUFPLFFBQVE7SUFDOUIsT0FDRUMsU0FBU2pCLFFBQVFlLFNBQVNHLFFBQVEsQ0FBQyxNQUFNSCxRQUFRWixNQUFNLENBQUNlLFFBQVEsQ0FBQyxNQUFNO0FBRTNFLEVBQUMiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNDU5MywgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvZnJlc2gvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIGU9ezY5NTplPT57XG4vKiFcbiAqIGZyZXNoXG4gKiBDb3B5cmlnaHQoYykgMjAxMiBUSiBIb2xvd2F5Y2h1a1xuICogQ29weXJpZ2h0KGMpIDIwMTYtMjAxNyBEb3VnbGFzIENocmlzdG9waGVyIFdpbHNvblxuICogTUlUIExpY2Vuc2VkXG4gKi9cbnZhciByPS8oPzpefCwpXFxzKj9uby1jYWNoZVxccyo/KD86LHwkKS87ZS5leHBvcnRzPWZyZXNoO2Z1bmN0aW9uIGZyZXNoKGUsYSl7dmFyIHQ9ZVtcImlmLW1vZGlmaWVkLXNpbmNlXCJdO3ZhciBzPWVbXCJpZi1ub25lLW1hdGNoXCJdO2lmKCF0JiYhcyl7cmV0dXJuIGZhbHNlfXZhciBpPWVbXCJjYWNoZS1jb250cm9sXCJdO2lmKGkmJnIudGVzdChpKSl7cmV0dXJuIGZhbHNlfWlmKHMmJnMhPT1cIipcIil7dmFyIGY9YVtcImV0YWdcIl07aWYoIWYpe3JldHVybiBmYWxzZX12YXIgbj10cnVlO3ZhciB1PXBhcnNlVG9rZW5MaXN0KHMpO2Zvcih2YXIgXz0wO188dS5sZW5ndGg7XysrKXt2YXIgbz11W19dO2lmKG89PT1mfHxvPT09XCJXL1wiK2Z8fFwiVy9cIitvPT09Zil7bj1mYWxzZTticmVha319aWYobil7cmV0dXJuIGZhbHNlfX1pZih0KXt2YXIgcD1hW1wibGFzdC1tb2RpZmllZFwiXTt2YXIgdj0hcHx8IShwYXJzZUh0dHBEYXRlKHApPD1wYXJzZUh0dHBEYXRlKHQpKTtpZih2KXtyZXR1cm4gZmFsc2V9fXJldHVybiB0cnVlfWZ1bmN0aW9uIHBhcnNlSHR0cERhdGUoZSl7dmFyIHI9ZSYmRGF0ZS5wYXJzZShlKTtyZXR1cm4gdHlwZW9mIHI9PT1cIm51bWJlclwiP3I6TmFOfWZ1bmN0aW9uIHBhcnNlVG9rZW5MaXN0KGUpe3ZhciByPTA7dmFyIGE9W107dmFyIHQ9MDtmb3IodmFyIHM9MCxpPWUubGVuZ3RoO3M8aTtzKyspe3N3aXRjaChlLmNoYXJDb2RlQXQocykpe2Nhc2UgMzI6aWYodD09PXIpe3Q9cj1zKzF9YnJlYWs7Y2FzZSA0NDphLnB1c2goZS5zdWJzdHJpbmcodCxyKSk7dD1yPXMrMTticmVhaztkZWZhdWx0OnI9cysxO2JyZWFrfX1hLnB1c2goZS5zdWJzdHJpbmcodCxyKSk7cmV0dXJuIGF9fX07dmFyIHI9e307ZnVuY3Rpb24gX19uY2N3cGNrX3JlcXVpcmVfXyhhKXt2YXIgdD1yW2FdO2lmKHQhPT11bmRlZmluZWQpe3JldHVybiB0LmV4cG9ydHN9dmFyIHM9clthXT17ZXhwb3J0czp7fX07dmFyIGk9dHJ1ZTt0cnl7ZVthXShzLHMuZXhwb3J0cyxfX25jY3dwY2tfcmVxdWlyZV9fKTtpPWZhbHNlfWZpbmFsbHl7aWYoaSlkZWxldGUgclthXX1yZXR1cm4gcy5leHBvcnRzfWlmKHR5cGVvZiBfX25jY3dwY2tfcmVxdWlyZV9fIT09XCJ1bmRlZmluZWRcIilfX25jY3dwY2tfcmVxdWlyZV9fLmFiPV9fZGlybmFtZStcIi9cIjt2YXIgYT1fX25jY3dwY2tfcmVxdWlyZV9fKDY5NSk7bW9kdWxlLmV4cG9ydHM9YX0pKCk7Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLENBQUM7SUFB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Njk2LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zcmMvY2xpZW50L2NvbXBvbmVudHMvYXBwLXJvdXRlci1oZWFkZXJzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBSU0NfSEVBREVSID0gJ1JTQycgYXMgY29uc3RcbmV4cG9ydCBjb25zdCBBQ1RJT05fSEVBREVSID0gJ05leHQtQWN0aW9uJyBhcyBjb25zdFxuLy8gVE9ETzogSW5zdGVhZCBvZiBzZW5kaW5nIHRoZSBmdWxsIHJvdXRlciBzdGF0ZSwgd2Ugb25seSBuZWVkIHRvIHNlbmQgdGhlXG4vLyBzZWdtZW50IHBhdGguIFNhdmVzIGJ5dGVzLiBUaGVuIHdlIGNvdWxkIGFsc28gdXNlIHRoaXMgZmllbGQgZm9yIHNlZ21lbnRcbi8vIHByZWZldGNoZXMsIHdoaWNoIGFsc28gbmVlZCB0byBzcGVjaWZ5IGEgcGFydGljdWxhciBzZWdtZW50LlxuZXhwb3J0IGNvbnN0IE5FWFRfUk9VVEVSX1NUQVRFX1RSRUVfSEVBREVSID0gJ05leHQtUm91dGVyLVN0YXRlLVRyZWUnIGFzIGNvbnN0XG5leHBvcnQgY29uc3QgTkVYVF9ST1VURVJfUFJFRkVUQ0hfSEVBREVSID0gJ05leHQtUm91dGVyLVByZWZldGNoJyBhcyBjb25zdFxuLy8gVGhpcyBjb250YWlucyB0aGUgcGF0aCB0byB0aGUgc2VnbWVudCBiZWluZyBwcmVmZXRjaGVkLlxuLy8gVE9ETzogSWYgd2UgY2hhbmdlIE5leHQtUm91dGVyLVN0YXRlLVRyZWUgdG8gYmUgYSBzZWdtZW50IHBhdGgsIHdlIGNhbiB1c2Vcbi8vIHRoYXQgaW5zdGVhZC4gVGhlbiBOZXh0LVJvdXRlci1QcmVmZXRjaCBhbmQgTmV4dC1Sb3V0ZXItU2VnbWVudC1QcmVmZXRjaCBjYW5cbi8vIGJlIG1lcmdlZCBpbnRvIGEgc2luZ2xlIGVudW0uXG5leHBvcnQgY29uc3QgTkVYVF9ST1VURVJfU0VHTUVOVF9QUkVGRVRDSF9IRUFERVIgPVxuICAnTmV4dC1Sb3V0ZXItU2VnbWVudC1QcmVmZXRjaCcgYXMgY29uc3RcbmV4cG9ydCBjb25zdCBORVhUX0hNUl9SRUZSRVNIX0hFQURFUiA9ICdOZXh0LUhNUi1SZWZyZXNoJyBhcyBjb25zdFxuZXhwb3J0IGNvbnN0IE5FWFRfSE1SX1JFRlJFU0hfSEFTSF9DT09LSUUgPSAnX19uZXh0X2htcl9yZWZyZXNoX2hhc2hfXycgYXMgY29uc3RcbmV4cG9ydCBjb25zdCBORVhUX1VSTCA9ICdOZXh0LVVybCcgYXMgY29uc3RcbmV4cG9ydCBjb25zdCBSU0NfQ09OVEVOVF9UWVBFX0hFQURFUiA9ICd0ZXh0L3gtY29tcG9uZW50JyBhcyBjb25zdFxuXG5leHBvcnQgY29uc3QgRkxJR0hUX0hFQURFUlMgPSBbXG4gIFJTQ19IRUFERVIsXG4gIE5FWFRfUk9VVEVSX1NUQVRFX1RSRUVfSEVBREVSLFxuICBORVhUX1JPVVRFUl9QUkVGRVRDSF9IRUFERVIsXG4gIE5FWFRfSE1SX1JFRlJFU0hfSEVBREVSLFxuICBORVhUX1JPVVRFUl9TRUdNRU5UX1BSRUZFVENIX0hFQURFUixcbl0gYXMgY29uc3RcblxuZXhwb3J0IGNvbnN0IE5FWFRfUlNDX1VOSU9OX1FVRVJZID0gJ19yc2MnIGFzIGNvbnN0XG5cbmV4cG9ydCBjb25zdCBORVhUX1JPVVRFUl9TVEFMRV9USU1FX0hFQURFUiA9ICd4LW5leHRqcy1zdGFsZS10aW1lJyBhcyBjb25zdFxuZXhwb3J0IGNvbnN0IE5FWFRfRElEX1BPU1RQT05FX0hFQURFUiA9ICd4LW5leHRqcy1wb3N0cG9uZWQnIGFzIGNvbnN0XG5leHBvcnQgY29uc3QgTkVYVF9SRVdSSVRURU5fUEFUSF9IRUFERVIgPSAneC1uZXh0anMtcmV3cml0dGVuLXBhdGgnIGFzIGNvbnN0XG5leHBvcnQgY29uc3QgTkVYVF9SRVdSSVRURU5fUVVFUllfSEVBREVSID0gJ3gtbmV4dGpzLXJld3JpdHRlbi1xdWVyeScgYXMgY29uc3RcbmV4cG9ydCBjb25zdCBORVhUX0lTX1BSRVJFTkRFUl9IRUFERVIgPSAneC1uZXh0anMtcHJlcmVuZGVyJyBhcyBjb25zdFxuZXhwb3J0IGNvbnN0IE5FWFRfQUNUSU9OX05PVF9GT1VORF9IRUFERVIgPSAneC1uZXh0anMtYWN0aW9uLW5vdC1mb3VuZCcgYXMgY29uc3RcbiJdLCJuYW1lcyI6WyJSU0NfSEVBREVSIiwiQUNUSU9OX0hFQURFUiIsIk5FWFRfUk9VVEVSX1NUQVRFX1RSRUVfSEVBREVSIiwiTkVYVF9ST1VURVJfUFJFRkVUQ0hfSEVBREVSIiwiTkVYVF9ST1VURVJfU0VHTUVOVF9QUkVGRVRDSF9IRUFERVIiLCJORVhUX0hNUl9SRUZSRVNIX0hFQURFUiIsIk5FWFRfSE1SX1JFRlJFU0hfSEFTSF9DT09LSUUiLCJORVhUX1VSTCIsIlJTQ19DT05URU5UX1RZUEVfSEVBREVSIiwiRkxJR0hUX0hFQURFUlMiLCJORVhUX1JTQ19VTklPTl9RVUVSWSIsIk5FWFRfUk9VVEVSX1NUQUxFX1RJTUVfSEVBREVSIiwiTkVYVF9ESURfUE9TVFBPTkVfSEVBREVSIiwiTkVYVF9SRVdSSVRURU5fUEFUSF9IRUFERVIiLCJORVhUX1JFV1JJVFRFTl9RVUVSWV9IRUFERVIiLCJORVhUX0lTX1BSRVJFTkRFUl9IRUFERVIiLCJORVhUX0FDVElPTl9OT1RfRk9VTkRfSEVBREVSIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQU8sTUFBTUEsYUFBYSxNQUFjO0FBQ2pDLE1BQU1DLGdCQUFnQixjQUFzQjtBQUk1QyxNQUFNQyxnQ0FBZ0MseUJBQWlDO0FBQ3ZFLE1BQU1DLDhCQUE4Qix1QkFBK0I7QUFLbkUsTUFBTUMsc0NBQ1gsK0JBQXVDO0FBQ2xDLE1BQU1DLDBCQUEwQixtQkFBMkI7QUFDM0QsTUFBTUMsK0JBQStCLDRCQUFvQztBQUN6RSxNQUFNQyxXQUFXLFdBQW1CO0FBQ3BDLE1BQU1DLDBCQUEwQixtQkFBMkI7QUFFM0QsTUFBTUMsaUJBQWlCO0lBQzVCVDtJQUNBRTtJQUNBQztJQUNBRTtJQUNBRDtDQUNELENBQVM7QUFFSCxNQUFNTSx1QkFBdUIsT0FBZTtBQUU1QyxNQUFNQyxnQ0FBZ0Msc0JBQThCO0FBQ3BFLE1BQU1DLDJCQUEyQixxQkFBNkI7QUFDOUQsTUFBTUMsNkJBQTZCLDBCQUFrQztBQUNyRSxNQUFNQyw4QkFBOEIsMkJBQW1DO0FBQ3ZFLE1BQU1DLDJCQUEyQixxQkFBNkI7QUFDOUQsTUFBTUMsK0JBQStCLDRCQUFvQyIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA0NzQyLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zcmMvc2VydmVyL3NlbmQtcGF5bG9hZC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IEluY29taW5nTWVzc2FnZSwgU2VydmVyUmVzcG9uc2UgfSBmcm9tICdodHRwJ1xuaW1wb3J0IHR5cGUgUmVuZGVyUmVzdWx0IGZyb20gJy4vcmVuZGVyLXJlc3VsdCdcbmltcG9ydCB0eXBlIHsgQ2FjaGVDb250cm9sIH0gZnJvbSAnLi9saWIvY2FjaGUtY29udHJvbCdcblxuaW1wb3J0IHsgaXNSZXNTZW50IH0gZnJvbSAnLi4vc2hhcmVkL2xpYi91dGlscydcbmltcG9ydCB7IGdlbmVyYXRlRVRhZyB9IGZyb20gJy4vbGliL2V0YWcnXG5pbXBvcnQgZnJlc2ggZnJvbSAnbmV4dC9kaXN0L2NvbXBpbGVkL2ZyZXNoJ1xuaW1wb3J0IHsgZ2V0Q2FjaGVDb250cm9sSGVhZGVyIH0gZnJvbSAnLi9saWIvY2FjaGUtY29udHJvbCdcbmltcG9ydCB7IFJTQ19DT05URU5UX1RZUEVfSEVBREVSIH0gZnJvbSAnLi4vY2xpZW50L2NvbXBvbmVudHMvYXBwLXJvdXRlci1oZWFkZXJzJ1xuXG5leHBvcnQgZnVuY3Rpb24gc2VuZEV0YWdSZXNwb25zZShcbiAgcmVxOiBJbmNvbWluZ01lc3NhZ2UsXG4gIHJlczogU2VydmVyUmVzcG9uc2UsXG4gIGV0YWc6IHN0cmluZyB8IHVuZGVmaW5lZFxuKTogYm9vbGVhbiB7XG4gIGlmIChldGFnKSB7XG4gICAgLyoqXG4gICAgICogVGhlIHNlcnZlciBnZW5lcmF0aW5nIGEgMzA0IHJlc3BvbnNlIE1VU1QgZ2VuZXJhdGUgYW55IG9mIHRoZVxuICAgICAqIGZvbGxvd2luZyBoZWFkZXIgZmllbGRzIHRoYXQgd291bGQgaGF2ZSBiZWVuIHNlbnQgaW4gYSAyMDAgKE9LKVxuICAgICAqIHJlc3BvbnNlIHRvIHRoZSBzYW1lIHJlcXVlc3Q6IENhY2hlLUNvbnRyb2wsIENvbnRlbnQtTG9jYXRpb24sIERhdGUsXG4gICAgICogRVRhZywgRXhwaXJlcywgYW5kIFZhcnkuIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMyI3NlY3Rpb24tNC4xXG4gICAgICovXG4gICAgcmVzLnNldEhlYWRlcignRVRhZycsIGV0YWcpXG4gIH1cblxuICBpZiAoZnJlc2gocmVxLmhlYWRlcnMsIHsgZXRhZyB9KSkge1xuICAgIHJlcy5zdGF0dXNDb2RlID0gMzA0XG4gICAgcmVzLmVuZCgpXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2VuZFJlbmRlclJlc3VsdCh7XG4gIHJlcSxcbiAgcmVzLFxuICByZXN1bHQsXG4gIHR5cGUsXG4gIGdlbmVyYXRlRXRhZ3MsXG4gIHBvd2VyZWRCeUhlYWRlcixcbiAgY2FjaGVDb250cm9sLFxufToge1xuICByZXE6IEluY29taW5nTWVzc2FnZVxuICByZXM6IFNlcnZlclJlc3BvbnNlXG4gIHJlc3VsdDogUmVuZGVyUmVzdWx0XG4gIHR5cGU6ICdodG1sJyB8ICdqc29uJyB8ICdyc2MnXG4gIGdlbmVyYXRlRXRhZ3M6IGJvb2xlYW5cbiAgcG93ZXJlZEJ5SGVhZGVyOiBib29sZWFuXG4gIGNhY2hlQ29udHJvbDogQ2FjaGVDb250cm9sIHwgdW5kZWZpbmVkXG59KTogUHJvbWlzZTx2b2lkPiB7XG4gIGlmIChpc1Jlc1NlbnQocmVzKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKHBvd2VyZWRCeUhlYWRlciAmJiB0eXBlID09PSAnaHRtbCcpIHtcbiAgICByZXMuc2V0SGVhZGVyKCdYLVBvd2VyZWQtQnknLCAnTmV4dC5qcycpXG4gIH1cblxuICAvLyBJZiBjYWNoZSBjb250cm9sIGlzIGFscmVhZHkgc2V0IG9uIHRoZSByZXNwb25zZSB3ZSBkb24ndFxuICAvLyBvdmVycmlkZSBpdCB0byBhbGxvdyB1c2VycyB0byBjdXN0b21pemUgaXQgdmlhIG5leHQuY29uZmlnXG4gIGlmIChjYWNoZUNvbnRyb2wgJiYgIXJlcy5nZXRIZWFkZXIoJ0NhY2hlLUNvbnRyb2wnKSkge1xuICAgIHJlcy5zZXRIZWFkZXIoJ0NhY2hlLUNvbnRyb2wnLCBnZXRDYWNoZUNvbnRyb2xIZWFkZXIoY2FjaGVDb250cm9sKSlcbiAgfVxuXG4gIGNvbnN0IHBheWxvYWQgPSByZXN1bHQuaXNEeW5hbWljID8gbnVsbCA6IHJlc3VsdC50b1VuY2h1bmtlZFN0cmluZygpXG5cbiAgaWYgKGdlbmVyYXRlRXRhZ3MgJiYgcGF5bG9hZCAhPT0gbnVsbCkge1xuICAgIGNvbnN0IGV0YWcgPSBnZW5lcmF0ZUVUYWcocGF5bG9hZClcbiAgICBpZiAoc2VuZEV0YWdSZXNwb25zZShyZXEsIHJlcywgZXRhZykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxuXG4gIGlmICghcmVzLmdldEhlYWRlcignQ29udGVudC1UeXBlJykpIHtcbiAgICByZXMuc2V0SGVhZGVyKFxuICAgICAgJ0NvbnRlbnQtVHlwZScsXG4gICAgICByZXN1bHQuY29udGVudFR5cGVcbiAgICAgICAgPyByZXN1bHQuY29udGVudFR5cGVcbiAgICAgICAgOiB0eXBlID09PSAncnNjJ1xuICAgICAgICAgID8gUlNDX0NPTlRFTlRfVFlQRV9IRUFERVJcbiAgICAgICAgICA6IHR5cGUgPT09ICdqc29uJ1xuICAgICAgICAgICAgPyAnYXBwbGljYXRpb24vanNvbidcbiAgICAgICAgICAgIDogJ3RleHQvaHRtbDsgY2hhcnNldD11dGYtOCdcbiAgICApXG4gIH1cblxuICBpZiAocGF5bG9hZCkge1xuICAgIHJlcy5zZXRIZWFkZXIoJ0NvbnRlbnQtTGVuZ3RoJywgQnVmZmVyLmJ5dGVMZW5ndGgocGF5bG9hZCkpXG4gIH1cblxuICBpZiAocmVxLm1ldGhvZCA9PT0gJ0hFQUQnKSB7XG4gICAgcmVzLmVuZChudWxsKVxuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKHBheWxvYWQgIT09IG51bGwpIHtcbiAgICByZXMuZW5kKHBheWxvYWQpXG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBQaXBlIHRoZSByZW5kZXIgcmVzdWx0IHRvIHRoZSByZXNwb25zZSBhZnRlciB3ZSBnZXQgYSB3cml0ZXIgZm9yIGl0LlxuICBhd2FpdCByZXN1bHQucGlwZVRvTm9kZVJlc3BvbnNlKHJlcylcbn1cbiJdLCJuYW1lcyI6WyJpc1Jlc1NlbnQiLCJnZW5lcmF0ZUVUYWciLCJmcmVzaCIsImdldENhY2hlQ29udHJvbEhlYWRlciIsIlJTQ19DT05URU5UX1RZUEVfSEVBREVSIiwic2VuZEV0YWdSZXNwb25zZSIsInJlcSIsInJlcyIsImV0YWciLCJzZXRIZWFkZXIiLCJoZWFkZXJzIiwic3RhdHVzQ29kZSIsImVuZCIsInNlbmRSZW5kZXJSZXN1bHQiLCJyZXN1bHQiLCJ0eXBlIiwiZ2VuZXJhdGVFdGFncyIsInBvd2VyZWRCeUhlYWRlciIsImNhY2hlQ29udHJvbCIsImdldEhlYWRlciIsInBheWxvYWQiLCJpc0R5bmFtaWMiLCJ0b1VuY2h1bmtlZFN0cmluZyIsImNvbnRlbnRUeXBlIiwiQnVmZmVyIiwiYnl0ZUxlbmd0aCIsIm1ldGhvZCIsInBpcGVUb05vZGVSZXNwb25zZSJdLCJtYXBwaW5ncyI6Ijs7OztBQUlBLFNBQVNBLFNBQVMsUUFBUSxzQkFBcUI7QUFDL0MsU0FBU0MsWUFBWSxRQUFRLGFBQVk7QUFDekMsT0FBT0MsV0FBVywyQkFBMEI7QUFDNUMsU0FBU0MscUJBQXFCLFFBQVEsc0JBQXFCO0FBQzNELFNBQVNDLHVCQUF1QixRQUFRLDBDQUF5Qzs7Ozs7O0FBRTFFLFNBQVNDLGlCQUNkQyxHQUFvQixFQUNwQkMsR0FBbUIsRUFDbkJDLElBQXdCO0lBRXhCLElBQUlBLE1BQU07UUFDUjs7Ozs7S0FLQyxHQUNERCxJQUFJRSxTQUFTLENBQUMsUUFBUUQ7SUFDeEI7SUFFQSw0SkFBSU4sVUFBQUEsRUFBTUksSUFBSUksT0FBTyxFQUFFO1FBQUVGO0lBQUssSUFBSTtRQUNoQ0QsSUFBSUksVUFBVSxHQUFHO1FBQ2pCSixJQUFJSyxHQUFHO1FBQ1AsT0FBTztJQUNUO0lBRUEsT0FBTztBQUNUO0FBRU8sZUFBZUMsaUJBQWlCLEVBQ3JDUCxHQUFHLEVBQ0hDLEdBQUcsRUFDSE8sTUFBTSxFQUNOQyxJQUFJLEVBQ0pDLGFBQWEsRUFDYkMsZUFBZSxFQUNmQyxZQUFZLEVBU2I7SUFDQywrSkFBSWxCLFlBQUFBLEVBQVVPLE1BQU07UUFDbEI7SUFDRjtJQUVBLElBQUlVLG1CQUFtQkYsU0FBUyxRQUFRO1FBQ3RDUixJQUFJRSxTQUFTLENBQUMsZ0JBQWdCO0lBQ2hDO0lBRUEsMkRBQTJEO0lBQzNELDZEQUE2RDtJQUM3RCxJQUFJUyxnQkFBZ0IsQ0FBQ1gsSUFBSVksU0FBUyxDQUFDLGtCQUFrQjtRQUNuRFosSUFBSUUsU0FBUyxDQUFDLHVMQUFpQk4sd0JBQUFBLEVBQXNCZTtJQUN2RDtJQUVBLE1BQU1FLFVBQVVOLE9BQU9PLFNBQVMsR0FBRyxPQUFPUCxPQUFPUSxpQkFBaUI7SUFFbEUsSUFBSU4saUJBQWlCSSxZQUFZLE1BQU07UUFDckMsTUFBTVosaUtBQU9QLGVBQUFBLEVBQWFtQjtRQUMxQixJQUFJZixpQkFBaUJDLEtBQUtDLEtBQUtDLE9BQU87WUFDcEM7UUFDRjtJQUNGO0lBRUEsSUFBSSxDQUFDRCxJQUFJWSxTQUFTLENBQUMsaUJBQWlCO1FBQ2xDWixJQUFJRSxTQUFTLENBQ1gsZ0JBQ0FLLE9BQU9TLFdBQVcsR0FDZFQsT0FBT1MsV0FBVyxHQUNsQlIsU0FBUyx5TEFDUFgsMEJBQUFBLEdBQ0FXLFNBQVMsU0FDUCxxQkFDQTtJQUVaO0lBRUEsSUFBSUssU0FBUztRQUNYYixJQUFJRSxTQUFTLENBQUMsa0JBQWtCZSxPQUFPQyxVQUFVLENBQUNMO0lBQ3BEO0lBRUEsSUFBSWQsSUFBSW9CLE1BQU0sS0FBSyxRQUFRO1FBQ3pCbkIsSUFBSUssR0FBRyxDQUFDO1FBQ1I7SUFDRjtJQUVBLElBQUlRLFlBQVksTUFBTTtRQUNwQmIsSUFBSUssR0FBRyxDQUFDUTtRQUNSO0lBQ0Y7SUFFQSx1RUFBdUU7SUFDdkUsTUFBTU4sT0FBT2Esa0JBQWtCLENBQUNwQjtBQUNsQyIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA0ODE0LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zcmMvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaHRtbC1ib3RzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRoaXMgcmVnZXggY29udGFpbnMgdGhlIGJvdHMgdGhhdCB3ZSBuZWVkIHRvIGRvIGEgYmxvY2tpbmcgcmVuZGVyIGZvciBhbmQgY2FuJ3Qgc2FmZWx5IHN0cmVhbSB0aGUgcmVzcG9uc2Vcbi8vIGR1ZSB0byBob3cgdGhleSBwYXJzZSB0aGUgRE9NLiBGb3IgZXhhbXBsZSwgdGhleSBtaWdodCBleHBsaWNpdGx5IGNoZWNrIGZvciBtZXRhZGF0YSBpbiB0aGUgYGhlYWRgIHRhZywgc28gd2UgY2FuJ3Qgc3RyZWFtIG1ldGFkYXRhIHRhZ3MgYWZ0ZXIgdGhlIGBoZWFkYCB3YXMgc2VudC5cbmV4cG9ydCBjb25zdCBIVE1MX0xJTUlURURfQk9UX1VBX1JFID1cbiAgL01lZGlhcGFydG5lcnMtR29vZ2xlfENocm9tZS1MaWdodGhvdXNlfFNsdXJwfER1Y2tEdWNrQm90fGJhaWR1c3BpZGVyfHlhbmRleHxzb2dvdXxiaXRseWJvdHx0dW1ibHJ8dmtTaGFyZXxxdW9yYSBsaW5rIHByZXZpZXd8cmVkZGl0Ym90fGlhX2FyY2hpdmVyfEJpbmdib3R8QmluZ1ByZXZpZXd8YXBwbGVib3R8ZmFjZWJvb2tleHRlcm5hbGhpdHxmYWNlYm9va2NhdGFsb2d8VHdpdHRlcmJvdHxMaW5rZWRJbkJvdHxTbGFja2JvdHxEaXNjb3JkYm90fFdoYXRzQXBwfFNreXBlVXJpUHJldmlld3xZZXRpL2lcbiJdLCJuYW1lcyI6WyJIVE1MX0xJTUlURURfQk9UX1VBX1JFIl0sIm1hcHBpbmdzIjoiQUFBQSw2R0FBNkc7QUFDN0csc0tBQXNLOzs7O0FBQy9KLE1BQU1BLHlCQUNYLGdTQUErUiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA0ODI0LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zcmMvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtYm90LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEhUTUxfTElNSVRFRF9CT1RfVUFfUkUgfSBmcm9tICcuL2h0bWwtYm90cydcblxuLy8gQm90IGNyYXdsZXIgdGhhdCB3aWxsIHNwaW4gdXAgYSBoZWFkbGVzcyBicm93c2VyIGFuZCBleGVjdXRlIEpTLlxuLy8gQnkgZGVmYXVsdCwgb25seSBnb29nbGVib3RzIGFyZSBjb25zaWRlcmVkIGFzIERPTSBib3RzLiBCbG93IGlzIHdoZXJlIHRoZSByZWdleCBpcyBjb21wdXRlZCBmcm9tOlxuLy8geC1yZWY6IGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3NlYXJjaC9kb2NzL2NyYXdsaW5nLWluZGV4aW5nL2dvb2dsZS1jb21tb24tY3Jhd2xlcnNcbmNvbnN0IEhFQURMRVNTX0JST1dTRVJfQk9UX1VBX1JFID0gL2dvb2dsZS9pXG5cbmV4cG9ydCBjb25zdCBIVE1MX0xJTUlURURfQk9UX1VBX1JFX1NUUklORyA9IEhUTUxfTElNSVRFRF9CT1RfVUFfUkUuc291cmNlXG5cbmV4cG9ydCB7IEhUTUxfTElNSVRFRF9CT1RfVUFfUkUgfVxuXG5mdW5jdGlvbiBpc0RvbUJvdFVBKHVzZXJBZ2VudDogc3RyaW5nKSB7XG4gIHJldHVybiBIRUFETEVTU19CUk9XU0VSX0JPVF9VQV9SRS50ZXN0KHVzZXJBZ2VudClcbn1cblxuZnVuY3Rpb24gaXNIdG1sTGltaXRlZEJvdFVBKHVzZXJBZ2VudDogc3RyaW5nKSB7XG4gIHJldHVybiBIVE1MX0xJTUlURURfQk9UX1VBX1JFLnRlc3QodXNlckFnZW50KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNCb3QodXNlckFnZW50OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIGlzRG9tQm90VUEodXNlckFnZW50KSB8fCBpc0h0bWxMaW1pdGVkQm90VUEodXNlckFnZW50KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Qm90VHlwZSh1c2VyQWdlbnQ6IHN0cmluZyk6ICdkb20nIHwgJ2h0bWwnIHwgdW5kZWZpbmVkIHtcbiAgaWYgKGlzRG9tQm90VUEodXNlckFnZW50KSkge1xuICAgIHJldHVybiAnZG9tJ1xuICB9XG4gIGlmIChpc0h0bWxMaW1pdGVkQm90VUEodXNlckFnZW50KSkge1xuICAgIHJldHVybiAnaHRtbCdcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkXG59XG4iXSwibmFtZXMiOlsiSFRNTF9MSU1JVEVEX0JPVF9VQV9SRSIsIkhFQURMRVNTX0JST1dTRVJfQk9UX1VBX1JFIiwiSFRNTF9MSU1JVEVEX0JPVF9VQV9SRV9TVFJJTkciLCJzb3VyY2UiLCJpc0RvbUJvdFVBIiwidXNlckFnZW50IiwidGVzdCIsImlzSHRtbExpbWl0ZWRCb3RVQSIsImlzQm90IiwiZ2V0Qm90VHlwZSIsInVuZGVmaW5lZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxTQUFTQSxzQkFBc0IsUUFBUSxjQUFhOztBQUVwRCxtRUFBbUU7QUFDbkUsb0dBQW9HO0FBQ3BHLDRGQUE0RjtBQUM1RixNQUFNQyw2QkFBNkI7QUFFNUIsTUFBTUMsaU5BQWdDRix5QkFBQUEsQ0FBdUJHLE1BQU0sQ0FBQTs7QUFJMUUsU0FBU0MsV0FBV0MsU0FBaUI7SUFDbkMsT0FBT0osMkJBQTJCSyxJQUFJLENBQUNEO0FBQ3pDO0FBRUEsU0FBU0UsbUJBQW1CRixTQUFpQjtJQUMzQyx3TEFBT0wseUJBQUFBLENBQXVCTSxJQUFJLENBQUNEO0FBQ3JDO0FBRU8sU0FBU0csTUFBTUgsU0FBaUI7SUFDckMsT0FBT0QsV0FBV0MsY0FBY0UsbUJBQW1CRjtBQUNyRDtBQUVPLFNBQVNJLFdBQVdKLFNBQWlCO0lBQzFDLElBQUlELFdBQVdDLFlBQVk7UUFDekIsT0FBTztJQUNUO0lBQ0EsSUFBSUUsbUJBQW1CRixZQUFZO1FBQ2pDLE9BQU87SUFDVDtJQUNBLE9BQU9LO0FBQ1QiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNDg2NiwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL2J1aWxkL3RlbXBsYXRlcy9wYWdlcy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IEluY29taW5nTWVzc2FnZSwgU2VydmVyUmVzcG9uc2UgfSBmcm9tICdub2RlOmh0dHAnXG5pbXBvcnQgdHlwZSB7IFBhcnNlZFVybFF1ZXJ5IH0gZnJvbSAnbm9kZTpxdWVyeXN0cmluZydcbmltcG9ydCB7IFBhZ2VzUm91dGVNb2R1bGUgfSBmcm9tICcuLi8uLi9zZXJ2ZXIvcm91dGUtbW9kdWxlcy9wYWdlcy9tb2R1bGUuY29tcGlsZWQnXG5pbXBvcnQgeyBSb3V0ZUtpbmQgfSBmcm9tICcuLi8uLi9zZXJ2ZXIvcm91dGUta2luZCdcbmltcG9ydCB7IEJhc2VTZXJ2ZXJTcGFuIH0gZnJvbSAnLi4vLi4vc2VydmVyL2xpYi90cmFjZS9jb25zdGFudHMnXG5pbXBvcnQgeyBnZXRUcmFjZXIsIFNwYW5LaW5kLCB0eXBlIFNwYW4gfSBmcm9tICcuLi8uLi9zZXJ2ZXIvbGliL3RyYWNlL3RyYWNlcidcbmltcG9ydCB7IGZvcm1hdFVybCB9IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2Zvcm1hdC11cmwnXG5pbXBvcnQgeyBhZGRSZXF1ZXN0TWV0YSwgZ2V0UmVxdWVzdE1ldGEgfSBmcm9tICcuLi8uLi9zZXJ2ZXIvcmVxdWVzdC1tZXRhJ1xuaW1wb3J0IHsgaW50ZXJvcERlZmF1bHQgfSBmcm9tICcuLi8uLi9zZXJ2ZXIvYXBwLXJlbmRlci9pbnRlcm9wLWRlZmF1bHQnXG5pbXBvcnQgeyBnZXRSZXZhbGlkYXRlUmVhc29uIH0gZnJvbSAnLi4vLi4vc2VydmVyL2luc3RydW1lbnRhdGlvbi91dGlscydcbmltcG9ydCB7IG5vcm1hbGl6ZURhdGFQYXRoIH0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi9wYWdlLXBhdGgvbm9ybWFsaXplLWRhdGEtcGF0aCdcbmltcG9ydCB7XG4gIENhY2hlZFJvdXRlS2luZCxcbiAgdHlwZSBDYWNoZWRQYWdlVmFsdWUsXG4gIHR5cGUgQ2FjaGVkUmVkaXJlY3RWYWx1ZSxcbiAgdHlwZSBSZXNwb25zZUNhY2hlRW50cnksXG4gIHR5cGUgUmVzcG9uc2VHZW5lcmF0b3IsXG59IGZyb20gJy4uLy4uL3NlcnZlci9yZXNwb25zZS1jYWNoZSdcblxuaW1wb3J0IHsgaG9pc3QgfSBmcm9tICcuL2hlbHBlcnMnXG5cbi8vIEltcG9ydCB0aGUgYXBwIGFuZCBkb2N1bWVudCBtb2R1bGVzLlxuaW1wb3J0ICogYXMgZG9jdW1lbnQgZnJvbSAnVkFSX01PRFVMRV9ET0NVTUVOVCdcbmltcG9ydCAqIGFzIGFwcCBmcm9tICdWQVJfTU9EVUxFX0FQUCdcblxuLy8gSW1wb3J0IHRoZSB1c2VybGFuZCBjb2RlLlxuaW1wb3J0ICogYXMgdXNlcmxhbmQgZnJvbSAnVkFSX1VTRVJMQU5EJ1xuaW1wb3J0IHtcbiAgZ2V0Q2FjaGVDb250cm9sSGVhZGVyLFxuICB0eXBlIENhY2hlQ29udHJvbCxcbn0gZnJvbSAnLi4vLi4vc2VydmVyL2xpYi9jYWNoZS1jb250cm9sJ1xuaW1wb3J0IHsgbm9ybWFsaXplUmVwZWF0ZWRTbGFzaGVzIH0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi91dGlscydcbmltcG9ydCB7IGdldFJlZGlyZWN0U3RhdHVzIH0gZnJvbSAnLi4vLi4vbGliL3JlZGlyZWN0LXN0YXR1cydcbmltcG9ydCB7IENBQ0hFX09ORV9ZRUFSIH0gZnJvbSAnLi4vLi4vbGliL2NvbnN0YW50cydcbmltcG9ydCB7IHNlbmRSZW5kZXJSZXN1bHQgfSBmcm9tICcuLi8uLi9zZXJ2ZXIvc2VuZC1wYXlsb2FkJ1xuaW1wb3J0IFJlbmRlclJlc3VsdCBmcm9tICcuLi8uLi9zZXJ2ZXIvcmVuZGVyLXJlc3VsdCdcbmltcG9ydCB7IHRvUmVzcG9uc2VDYWNoZUVudHJ5IH0gZnJvbSAnLi4vLi4vc2VydmVyL3Jlc3BvbnNlLWNhY2hlL3V0aWxzJ1xuaW1wb3J0IHsgTm9GYWxsYmFja0Vycm9yIH0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi9uby1mYWxsYmFjay1lcnJvci5leHRlcm5hbCdcbmltcG9ydCB7IFJlZGlyZWN0U3RhdHVzQ29kZSB9IGZyb20gJy4uLy4uL2NsaWVudC9jb21wb25lbnRzL3JlZGlyZWN0LXN0YXR1cy1jb2RlJ1xuaW1wb3J0IHsgaXNCb3QgfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9pcy1ib3QnXG5pbXBvcnQgeyBhZGRQYXRoUHJlZml4IH0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvYWRkLXBhdGgtcHJlZml4J1xuaW1wb3J0IHsgcmVtb3ZlVHJhaWxpbmdTbGFzaCB9IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3JlbW92ZS10cmFpbGluZy1zbGFzaCdcblxuLy8gUmUtZXhwb3J0IHRoZSBjb21wb25lbnQgKHNob3VsZCBiZSB0aGUgZGVmYXVsdCBleHBvcnQpLlxuZXhwb3J0IGRlZmF1bHQgaG9pc3QodXNlcmxhbmQsICdkZWZhdWx0JylcblxuLy8gUmUtZXhwb3J0IG1ldGhvZHMuXG5leHBvcnQgY29uc3QgZ2V0U3RhdGljUHJvcHMgPSBob2lzdCh1c2VybGFuZCwgJ2dldFN0YXRpY1Byb3BzJylcbmV4cG9ydCBjb25zdCBnZXRTdGF0aWNQYXRocyA9IGhvaXN0KHVzZXJsYW5kLCAnZ2V0U3RhdGljUGF0aHMnKVxuZXhwb3J0IGNvbnN0IGdldFNlcnZlclNpZGVQcm9wcyA9IGhvaXN0KHVzZXJsYW5kLCAnZ2V0U2VydmVyU2lkZVByb3BzJylcbmV4cG9ydCBjb25zdCBjb25maWcgPSBob2lzdCh1c2VybGFuZCwgJ2NvbmZpZycpXG5leHBvcnQgY29uc3QgcmVwb3J0V2ViVml0YWxzID0gaG9pc3QodXNlcmxhbmQsICdyZXBvcnRXZWJWaXRhbHMnKVxuXG4vLyBSZS1leHBvcnQgbGVnYWN5IG1ldGhvZHMuXG5leHBvcnQgY29uc3QgdW5zdGFibGVfZ2V0U3RhdGljUHJvcHMgPSBob2lzdChcbiAgdXNlcmxhbmQsXG4gICd1bnN0YWJsZV9nZXRTdGF0aWNQcm9wcydcbilcbmV4cG9ydCBjb25zdCB1bnN0YWJsZV9nZXRTdGF0aWNQYXRocyA9IGhvaXN0KFxuICB1c2VybGFuZCxcbiAgJ3Vuc3RhYmxlX2dldFN0YXRpY1BhdGhzJ1xuKVxuZXhwb3J0IGNvbnN0IHVuc3RhYmxlX2dldFN0YXRpY1BhcmFtcyA9IGhvaXN0KFxuICB1c2VybGFuZCxcbiAgJ3Vuc3RhYmxlX2dldFN0YXRpY1BhcmFtcydcbilcbmV4cG9ydCBjb25zdCB1bnN0YWJsZV9nZXRTZXJ2ZXJQcm9wcyA9IGhvaXN0KFxuICB1c2VybGFuZCxcbiAgJ3Vuc3RhYmxlX2dldFNlcnZlclByb3BzJ1xuKVxuZXhwb3J0IGNvbnN0IHVuc3RhYmxlX2dldFNlcnZlclNpZGVQcm9wcyA9IGhvaXN0KFxuICB1c2VybGFuZCxcbiAgJ3Vuc3RhYmxlX2dldFNlcnZlclNpZGVQcm9wcydcbilcblxuLy8gQ3JlYXRlIGFuZCBleHBvcnQgdGhlIHJvdXRlIG1vZHVsZSB0aGF0IHdpbGwgYmUgY29uc3VtZWQuXG5leHBvcnQgY29uc3Qgcm91dGVNb2R1bGUgPSBuZXcgUGFnZXNSb3V0ZU1vZHVsZSh7XG4gIGRlZmluaXRpb246IHtcbiAgICBraW5kOiBSb3V0ZUtpbmQuUEFHRVMsXG4gICAgcGFnZTogJ1ZBUl9ERUZJTklUSU9OX1BBR0UnLFxuICAgIHBhdGhuYW1lOiAnVkFSX0RFRklOSVRJT05fUEFUSE5BTUUnLFxuICAgIC8vIFRoZSBmb2xsb3dpbmcgYXJlbid0IHVzZWQgaW4gcHJvZHVjdGlvbi5cbiAgICBidW5kbGVQYXRoOiAnJyxcbiAgICBmaWxlbmFtZTogJycsXG4gIH0sXG4gIGRpc3REaXI6IHByb2Nlc3MuZW52Ll9fTkVYVF9SRUxBVElWRV9ESVNUX0RJUiB8fCAnJyxcbiAgcHJvamVjdERpcjogcHJvY2Vzcy5lbnYuX19ORVhUX1JFTEFUSVZFX1BST0pFQ1RfRElSIHx8ICcnLFxuICBjb21wb25lbnRzOiB7XG4gICAgLy8gZGVmYXVsdCBleHBvcnQgbWlnaHQgbm90IGV4aXN0IHdoZW4gb3B0aW1pemVkIGZvciBkYXRhIG9ubHlcbiAgICBBcHA6IGFwcC5kZWZhdWx0LFxuICAgIERvY3VtZW50OiBkb2N1bWVudC5kZWZhdWx0LFxuICB9LFxuICB1c2VybGFuZCxcbn0pXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBoYW5kbGVyKFxuICByZXE6IEluY29taW5nTWVzc2FnZSxcbiAgcmVzOiBTZXJ2ZXJSZXNwb25zZSxcbiAgY3R4OiB7XG4gICAgd2FpdFVudGlsOiAocHJvbTogUHJvbWlzZTx2b2lkPikgPT4gdm9pZFxuICB9XG4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgbGV0IHNyY1BhZ2UgPSAnVkFSX0RFRklOSVRJT05fUEFHRSdcblxuICAvLyB0dXJib3BhY2sgZG9lc24ndCBub3JtYWxpemUgYC9pbmRleGAgaW4gdGhlIHBhZ2UgbmFtZVxuICAvLyBzbyB3ZSBuZWVkIHRvIHRvIHByb2Nlc3MgZHluYW1pYyByb3V0ZXMgcHJvcGVybHlcbiAgLy8gVE9ETzogZml4IHR1cmJvcGFjayBwcm92aWRpbmcgZGlmZmVyaW5nIHZhbHVlIGZyb20gd2VicGFja1xuICBpZiAocHJvY2Vzcy5lbnYuVFVSQk9QQUNLKSB7XG4gICAgc3JjUGFnZSA9IHNyY1BhZ2UucmVwbGFjZSgvXFwvaW5kZXgkLywgJycpIHx8ICcvJ1xuICB9IGVsc2UgaWYgKHNyY1BhZ2UgPT09ICcvaW5kZXgnKSB7XG4gICAgLy8gd2UgYWx3YXlzIG5vcm1hbGl6ZSAvaW5kZXggc3BlY2lmaWNhbGx5XG4gICAgc3JjUGFnZSA9ICcvJ1xuICB9XG4gIGNvbnN0IG11bHRpWm9uZURyYWZ0TW9kZSA9IHByb2Nlc3MuZW52XG4gICAgLl9fTkVYVF9NVUxUSV9aT05FX0RSQUZUX01PREUgYXMgYW55IGFzIGJvb2xlYW5cblxuICBjb25zdCBwcmVwYXJlUmVzdWx0ID0gYXdhaXQgcm91dGVNb2R1bGUucHJlcGFyZShyZXEsIHJlcywge1xuICAgIHNyY1BhZ2UsXG4gICAgbXVsdGlab25lRHJhZnRNb2RlLFxuICB9KVxuXG4gIGlmICghcHJlcGFyZVJlc3VsdCkge1xuICAgIHJlcy5zdGF0dXNDb2RlID0gNDAwXG4gICAgcmVzLmVuZCgnQmFkIFJlcXVlc3QnKVxuICAgIGN0eC53YWl0VW50aWw/LihQcm9taXNlLnJlc29sdmUoKSlcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IHtcbiAgICBidWlsZElkLFxuICAgIHF1ZXJ5LFxuICAgIHBhcmFtcyxcbiAgICBwYXJzZWRVcmwsXG4gICAgb3JpZ2luYWxRdWVyeSxcbiAgICBvcmlnaW5hbFBhdGhuYW1lLFxuICAgIGJ1aWxkTWFuaWZlc3QsXG4gICAgbmV4dEZvbnRNYW5pZmVzdCxcbiAgICBzZXJ2ZXJGaWxlc01hbmlmZXN0LFxuICAgIHJlYWN0TG9hZGFibGVNYW5pZmVzdCxcbiAgICBwcmVyZW5kZXJNYW5pZmVzdCxcbiAgICBpc0RyYWZ0TW9kZSxcbiAgICBpc09uRGVtYW5kUmV2YWxpZGF0ZSxcbiAgICByZXZhbGlkYXRlT25seUdlbmVyYXRlZCxcbiAgICBsb2NhbGUsXG4gICAgbG9jYWxlcyxcbiAgICBkZWZhdWx0TG9jYWxlLFxuICAgIHJvdXRlclNlcnZlckNvbnRleHQsXG4gICAgbmV4dENvbmZpZyxcbiAgICByZXNvbHZlZFBhdGhuYW1lLFxuICB9ID0gcHJlcGFyZVJlc3VsdFxuXG4gIGNvbnN0IGlzRXhwZXJpbWVudGFsQ29tcGlsZSA9XG4gICAgc2VydmVyRmlsZXNNYW5pZmVzdD8uY29uZmlnPy5leHBlcmltZW50YWw/LmlzRXhwZXJpbWVudGFsQ29tcGlsZVxuXG4gIGNvbnN0IGhhc1NlcnZlclByb3BzID0gQm9vbGVhbihnZXRTZXJ2ZXJTaWRlUHJvcHMpXG4gIGNvbnN0IGhhc1N0YXRpY1Byb3BzID0gQm9vbGVhbihnZXRTdGF0aWNQcm9wcylcbiAgY29uc3QgaGFzU3RhdGljUGF0aHMgPSBCb29sZWFuKGdldFN0YXRpY1BhdGhzKVxuICBjb25zdCBoYXNHZXRJbml0aWFsUHJvcHMgPSBCb29sZWFuKFxuICAgICh1c2VybGFuZC5kZWZhdWx0IHx8IHVzZXJsYW5kKS5nZXRJbml0aWFsUHJvcHNcbiAgKVxuICBjb25zdCBpc0FtcCA9IHF1ZXJ5LmFtcCAmJiBjb25maWcuYW1wXG4gIGxldCBjYWNoZUtleTogbnVsbCB8IHN0cmluZyA9IG51bGxcbiAgbGV0IGlzSXNyRmFsbGJhY2sgPSBmYWxzZVxuICBsZXQgaXNOZXh0RGF0YVJlcXVlc3QgPVxuICAgIHByZXBhcmVSZXN1bHQuaXNOZXh0RGF0YVJlcXVlc3QgJiYgKGhhc1N0YXRpY1Byb3BzIHx8IGhhc1NlcnZlclByb3BzKVxuXG4gIGNvbnN0IGlzNDA0UGFnZSA9IHNyY1BhZ2UgPT09ICcvNDA0J1xuICBjb25zdCBpczUwMFBhZ2UgPSBzcmNQYWdlID09PSAnLzUwMCdcbiAgY29uc3QgaXNFcnJvclBhZ2UgPSBzcmNQYWdlID09PSAnL19lcnJvcidcblxuICBpZiAoIXJvdXRlTW9kdWxlLmlzRGV2ICYmICFpc0RyYWZ0TW9kZSAmJiBoYXNTdGF0aWNQcm9wcykge1xuICAgIGNhY2hlS2V5ID0gYCR7bG9jYWxlID8gYC8ke2xvY2FsZX1gIDogJyd9JHtcbiAgICAgIChzcmNQYWdlID09PSAnLycgfHwgcmVzb2x2ZWRQYXRobmFtZSA9PT0gJy8nKSAmJiBsb2NhbGVcbiAgICAgICAgPyAnJ1xuICAgICAgICA6IHJlc29sdmVkUGF0aG5hbWVcbiAgICB9JHtpc0FtcCA/ICcuYW1wJyA6ICcnfWBcblxuICAgIGlmIChpczQwNFBhZ2UgfHwgaXM1MDBQYWdlIHx8IGlzRXJyb3JQYWdlKSB7XG4gICAgICBjYWNoZUtleSA9IGAke2xvY2FsZSA/IGAvJHtsb2NhbGV9YCA6ICcnfSR7c3JjUGFnZX0ke2lzQW1wID8gJy5hbXAnIDogJyd9YFxuICAgIH1cblxuICAgIC8vIGVuc3VyZSAvaW5kZXggYW5kIC8gaXMgbm9ybWFsaXplZCB0byBvbmUga2V5XG4gICAgY2FjaGVLZXkgPSBjYWNoZUtleSA9PT0gJy9pbmRleCcgPyAnLycgOiBjYWNoZUtleVxuICB9XG5cbiAgaWYgKGhhc1N0YXRpY1BhdGhzICYmICFpc0RyYWZ0TW9kZSkge1xuICAgIGNvbnN0IGRlY29kZWRQYXRobmFtZSA9IHJlbW92ZVRyYWlsaW5nU2xhc2goXG4gICAgICBsb2NhbGUgPyBhZGRQYXRoUHJlZml4KHJlc29sdmVkUGF0aG5hbWUsIGAvJHtsb2NhbGV9YCkgOiByZXNvbHZlZFBhdGhuYW1lXG4gICAgKVxuICAgIGNvbnN0IGlzUHJlcmVuZGVyZWQgPVxuICAgICAgQm9vbGVhbihwcmVyZW5kZXJNYW5pZmVzdC5yb3V0ZXNbZGVjb2RlZFBhdGhuYW1lXSkgfHxcbiAgICAgIHByZXJlbmRlck1hbmlmZXN0Lm5vdEZvdW5kUm91dGVzLmluY2x1ZGVzKGRlY29kZWRQYXRobmFtZSlcblxuICAgIGNvbnN0IHByZXJlbmRlckluZm8gPSBwcmVyZW5kZXJNYW5pZmVzdC5keW5hbWljUm91dGVzW3NyY1BhZ2VdXG5cbiAgICBpZiAocHJlcmVuZGVySW5mbykge1xuICAgICAgaWYgKHByZXJlbmRlckluZm8uZmFsbGJhY2sgPT09IGZhbHNlICYmICFpc1ByZXJlbmRlcmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBOb0ZhbGxiYWNrRXJyb3IoKVxuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgIHR5cGVvZiBwcmVyZW5kZXJJbmZvLmZhbGxiYWNrID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAhaXNQcmVyZW5kZXJlZCAmJlxuICAgICAgICAhaXNOZXh0RGF0YVJlcXVlc3RcbiAgICAgICkge1xuICAgICAgICBpc0lzckZhbGxiYWNrID0gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFdoZW4gc2VydmluZyBhIGJvdCByZXF1ZXN0LCB3ZSB3YW50IHRvIHNlcnZlIGEgYmxvY2tpbmcgcmVuZGVyIGFuZCBub3RcbiAgLy8gdGhlIHByZXJlbmRlcmVkIHBhZ2UuIFRoaXMgZW5zdXJlcyB0aGF0IHRoZSBjb3JyZWN0IGNvbnRlbnQgaXMgc2VydmVkXG4gIC8vIHRvIHRoZSBib3QgaW4gdGhlIGhlYWQuXG4gIGlmIChcbiAgICAoaXNJc3JGYWxsYmFjayAmJiBpc0JvdChyZXEuaGVhZGVyc1sndXNlci1hZ2VudCddIHx8ICcnKSkgfHxcbiAgICBnZXRSZXF1ZXN0TWV0YShyZXEsICdtaW5pbWFsTW9kZScpXG4gICkge1xuICAgIGlzSXNyRmFsbGJhY2sgPSBmYWxzZVxuICB9XG5cbiAgY29uc3QgdHJhY2VyID0gZ2V0VHJhY2VyKClcbiAgY29uc3QgYWN0aXZlU3BhbiA9IHRyYWNlci5nZXRBY3RpdmVTY29wZVNwYW4oKVxuXG4gIHRyeSB7XG4gICAgY29uc3QgbWV0aG9kID0gcmVxLm1ldGhvZCB8fCAnR0VUJ1xuXG4gICAgY29uc3QgcmVzb2x2ZWRVcmwgPSBmb3JtYXRVcmwoe1xuICAgICAgcGF0aG5hbWU6IG5leHRDb25maWcudHJhaWxpbmdTbGFzaFxuICAgICAgICA/IHBhcnNlZFVybC5wYXRobmFtZVxuICAgICAgICA6IHJlbW92ZVRyYWlsaW5nU2xhc2gocGFyc2VkVXJsLnBhdGhuYW1lIHx8ICcvJyksXG4gICAgICAvLyBtYWtlIHN1cmUgdG8gb25seSBhZGQgcXVlcnkgdmFsdWVzIGZyb20gb3JpZ2luYWwgVVJMXG4gICAgICBxdWVyeTogaGFzU3RhdGljUHJvcHMgPyB7fSA6IG9yaWdpbmFsUXVlcnksXG4gICAgfSlcblxuICAgIGNvbnN0IHB1YmxpY1J1bnRpbWVDb25maWc6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPVxuICAgICAgcm91dGVyU2VydmVyQ29udGV4dD8ucHVibGljUnVudGltZUNvbmZpZyB8fCBuZXh0Q29uZmlnLnB1YmxpY1J1bnRpbWVDb25maWdcblxuICAgIGNvbnN0IGhhbmRsZVJlc3BvbnNlID0gYXN5bmMgKHNwYW4/OiBTcGFuKSA9PiB7XG4gICAgICBjb25zdCByZXNwb25zZUdlbmVyYXRvcjogUmVzcG9uc2VHZW5lcmF0b3IgPSBhc3luYyAoe1xuICAgICAgICBwcmV2aW91c0NhY2hlRW50cnksXG4gICAgICB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGRvUmVuZGVyID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgcm91dGVNb2R1bGVcbiAgICAgICAgICAgICAgLnJlbmRlcihyZXEsIHJlcywge1xuICAgICAgICAgICAgICAgIHF1ZXJ5OlxuICAgICAgICAgICAgICAgICAgaGFzU3RhdGljUHJvcHMgJiYgIWlzRXhwZXJpbWVudGFsQ29tcGlsZVxuICAgICAgICAgICAgICAgICAgICA/ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi4oaXNBbXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbXA6IHF1ZXJ5LmFtcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIDoge30pLFxuICAgICAgICAgICAgICAgICAgICAgIH0gYXMgUGFyc2VkVXJsUXVlcnkpXG4gICAgICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4ucXVlcnksXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgICAgICAgcGFnZTogc3JjUGFnZSxcbiAgICAgICAgICAgICAgICByZW5kZXJDb250ZXh0OiB7XG4gICAgICAgICAgICAgICAgICBpc0RyYWZ0TW9kZSxcbiAgICAgICAgICAgICAgICAgIGlzRmFsbGJhY2s6IGlzSXNyRmFsbGJhY2ssXG4gICAgICAgICAgICAgICAgICBkZXZlbG9wbWVudE5vdEZvdW5kU291cmNlUGFnZTogZ2V0UmVxdWVzdE1ldGEoXG4gICAgICAgICAgICAgICAgICAgIHJlcSxcbiAgICAgICAgICAgICAgICAgICAgJ2RldmVsb3BtZW50Tm90Rm91bmRTb3VyY2VQYWdlJ1xuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNoYXJlZENvbnRleHQ6IHtcbiAgICAgICAgICAgICAgICAgIGJ1aWxkSWQsXG4gICAgICAgICAgICAgICAgICBjdXN0b21TZXJ2ZXI6XG4gICAgICAgICAgICAgICAgICAgIEJvb2xlYW4ocm91dGVyU2VydmVyQ29udGV4dD8uaXNDdXN0b21TZXJ2ZXIpIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgIGRlcGxveW1lbnRJZDogcHJvY2Vzcy5lbnYuTkVYVF9ERVBMT1lNRU5UX0lELFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVuZGVyT3B0czoge1xuICAgICAgICAgICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgICAgICAgICAgcm91dGVNb2R1bGUsXG4gICAgICAgICAgICAgICAgICBwYWdlOiBzcmNQYWdlLFxuICAgICAgICAgICAgICAgICAgcGFnZUNvbmZpZzogY29uZmlnIHx8IHt9LFxuICAgICAgICAgICAgICAgICAgQ29tcG9uZW50OiBpbnRlcm9wRGVmYXVsdCh1c2VybGFuZCksXG4gICAgICAgICAgICAgICAgICBDb21wb25lbnRNb2Q6IHVzZXJsYW5kLFxuICAgICAgICAgICAgICAgICAgZ2V0U3RhdGljUHJvcHMsXG4gICAgICAgICAgICAgICAgICBnZXRTdGF0aWNQYXRocyxcbiAgICAgICAgICAgICAgICAgIGdldFNlcnZlclNpZGVQcm9wcyxcbiAgICAgICAgICAgICAgICAgIHN1cHBvcnRzRHluYW1pY1Jlc3BvbnNlOiAhaGFzU3RhdGljUHJvcHMsXG4gICAgICAgICAgICAgICAgICBidWlsZE1hbmlmZXN0LFxuICAgICAgICAgICAgICAgICAgbmV4dEZvbnRNYW5pZmVzdCxcbiAgICAgICAgICAgICAgICAgIHJlYWN0TG9hZGFibGVNYW5pZmVzdCxcblxuICAgICAgICAgICAgICAgICAgYXNzZXRQcmVmaXg6IG5leHRDb25maWcuYXNzZXRQcmVmaXgsXG4gICAgICAgICAgICAgICAgICBzdHJpY3ROZXh0SGVhZDpcbiAgICAgICAgICAgICAgICAgICAgbmV4dENvbmZpZy5leHBlcmltZW50YWwuc3RyaWN0TmV4dEhlYWQgPz8gdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIHByZXZpZXdQcm9wczogcHJlcmVuZGVyTWFuaWZlc3QucHJldmlldyxcbiAgICAgICAgICAgICAgICAgIGltYWdlczogbmV4dENvbmZpZy5pbWFnZXMgYXMgYW55LFxuICAgICAgICAgICAgICAgICAgbmV4dENvbmZpZ091dHB1dDogbmV4dENvbmZpZy5vdXRwdXQsXG4gICAgICAgICAgICAgICAgICBvcHRpbWl6ZUNzczogQm9vbGVhbihuZXh0Q29uZmlnLmV4cGVyaW1lbnRhbC5vcHRpbWl6ZUNzcyksXG4gICAgICAgICAgICAgICAgICBuZXh0U2NyaXB0V29ya2VyczogQm9vbGVhbihcbiAgICAgICAgICAgICAgICAgICAgbmV4dENvbmZpZy5leHBlcmltZW50YWwubmV4dFNjcmlwdFdvcmtlcnNcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICBkb21haW5Mb2NhbGVzOiBuZXh0Q29uZmlnLmkxOG4/LmRvbWFpbnMsXG4gICAgICAgICAgICAgICAgICBjcm9zc09yaWdpbjogbmV4dENvbmZpZy5jcm9zc09yaWdpbixcblxuICAgICAgICAgICAgICAgICAgbXVsdGlab25lRHJhZnRNb2RlLFxuICAgICAgICAgICAgICAgICAgYmFzZVBhdGg6IG5leHRDb25maWcuYmFzZVBhdGgsXG4gICAgICAgICAgICAgICAgICBjYW5vbmljYWxCYXNlOiBuZXh0Q29uZmlnLmFtcC5jYW5vbmljYWxCYXNlIHx8ICcnLFxuICAgICAgICAgICAgICAgICAgYW1wT3B0aW1pemVyQ29uZmlnOiBuZXh0Q29uZmlnLmV4cGVyaW1lbnRhbC5hbXA/Lm9wdGltaXplcixcbiAgICAgICAgICAgICAgICAgIGRpc2FibGVPcHRpbWl6ZWRMb2FkaW5nOlxuICAgICAgICAgICAgICAgICAgICBuZXh0Q29uZmlnLmV4cGVyaW1lbnRhbC5kaXNhYmxlT3B0aW1pemVkTG9hZGluZyxcbiAgICAgICAgICAgICAgICAgIGxhcmdlUGFnZURhdGFCeXRlczpcbiAgICAgICAgICAgICAgICAgICAgbmV4dENvbmZpZy5leHBlcmltZW50YWwubGFyZ2VQYWdlRGF0YUJ5dGVzLFxuICAgICAgICAgICAgICAgICAgLy8gT25seSB0aGUgYHB1YmxpY1J1bnRpbWVDb25maWdgIGtleSBpcyBleHBvc2VkIHRvIHRoZSBjbGllbnQgc2lkZVxuICAgICAgICAgICAgICAgICAgLy8gSXQnbGwgYmUgcmVuZGVyZWQgYXMgcGFydCBvZiBfX05FWFRfREFUQV9fIG9uIHRoZSBjbGllbnQgc2lkZVxuICAgICAgICAgICAgICAgICAgcnVudGltZUNvbmZpZzpcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMocHVibGljUnVudGltZUNvbmZpZykubGVuZ3RoID4gMFxuICAgICAgICAgICAgICAgICAgICAgID8gcHVibGljUnVudGltZUNvbmZpZ1xuICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuXG4gICAgICAgICAgICAgICAgICBpc0V4cGVyaW1lbnRhbENvbXBpbGUsXG5cbiAgICAgICAgICAgICAgICAgIGV4cGVyaW1lbnRhbDoge1xuICAgICAgICAgICAgICAgICAgICBjbGllbnRUcmFjZU1ldGFkYXRhOlxuICAgICAgICAgICAgICAgICAgICAgIG5leHRDb25maWcuZXhwZXJpbWVudGFsLmNsaWVudFRyYWNlTWV0YWRhdGEgfHxcbiAgICAgICAgICAgICAgICAgICAgICAoW10gYXMgYW55KSxcbiAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgIGxvY2FsZSxcbiAgICAgICAgICAgICAgICAgIGxvY2FsZXMsXG4gICAgICAgICAgICAgICAgICBkZWZhdWx0TG9jYWxlLFxuICAgICAgICAgICAgICAgICAgc2V0SXNyU3RhdHVzOiByb3V0ZXJTZXJ2ZXJDb250ZXh0Py5zZXRJc3JTdGF0dXMsXG5cbiAgICAgICAgICAgICAgICAgIGlzTmV4dERhdGFSZXF1ZXN0OlxuICAgICAgICAgICAgICAgICAgICBpc05leHREYXRhUmVxdWVzdCAmJiAoaGFzU2VydmVyUHJvcHMgfHwgaGFzU3RhdGljUHJvcHMpLFxuXG4gICAgICAgICAgICAgICAgICByZXNvbHZlZFVybCxcbiAgICAgICAgICAgICAgICAgIC8vIEZvciBnZXRTZXJ2ZXJTaWRlUHJvcHMgYW5kIGdldEluaXRpYWxQcm9wcyB3ZSBuZWVkIHRvIGVuc3VyZSB3ZSB1c2UgdGhlIG9yaWdpbmFsIFVSTFxuICAgICAgICAgICAgICAgICAgLy8gYW5kIG5vdCB0aGUgcmVzb2x2ZWQgVVJMIHRvIHByZXZlbnQgYSBoeWRyYXRpb24gbWlzbWF0Y2ggb25cbiAgICAgICAgICAgICAgICAgIC8vIGFzUGF0aFxuICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRBc1BhdGg6XG4gICAgICAgICAgICAgICAgICAgIGhhc1NlcnZlclByb3BzIHx8IGhhc0dldEluaXRpYWxQcm9wc1xuICAgICAgICAgICAgICAgICAgICAgID8gZm9ybWF0VXJsKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgdXNlIHRoZSBvcmlnaW5hbCBVUkwgcGF0aG5hbWUgbGVzcyB0aGUgX25leHQvZGF0YSBwcmVmaXggaWZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJlc2VudFxuICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogaXNOZXh0RGF0YVJlcXVlc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG5vcm1hbGl6ZURhdGFQYXRoKG9yaWdpbmFsUGF0aG5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBvcmlnaW5hbFBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogb3JpZ2luYWxRdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgOiByZXNvbHZlZFVybCxcblxuICAgICAgICAgICAgICAgICAgaXNPbkRlbWFuZFJldmFsaWRhdGUsXG5cbiAgICAgICAgICAgICAgICAgIEVycm9yRGVidWc6IGdldFJlcXVlc3RNZXRhKHJlcSwgJ1BhZ2VzRXJyb3JEZWJ1ZycpLFxuICAgICAgICAgICAgICAgICAgZXJyOiBnZXRSZXF1ZXN0TWV0YShyZXEsICdpbnZva2VFcnJvcicpLFxuICAgICAgICAgICAgICAgICAgZGV2OiByb3V0ZU1vZHVsZS5pc0RldixcblxuICAgICAgICAgICAgICAgICAgLy8gbmVlZGVkIGZvciBleHBlcmltZW50YWwub3B0aW1pemVDc3MgZmVhdHVyZVxuICAgICAgICAgICAgICAgICAgZGlzdERpcjogYCR7cm91dGVNb2R1bGUucHJvamVjdERpcn0vJHtyb3V0ZU1vZHVsZS5kaXN0RGlyfWAsXG5cbiAgICAgICAgICAgICAgICAgIGFtcFNraXBWYWxpZGF0aW9uOlxuICAgICAgICAgICAgICAgICAgICBuZXh0Q29uZmlnLmV4cGVyaW1lbnRhbC5hbXA/LnNraXBWYWxpZGF0aW9uLFxuICAgICAgICAgICAgICAgICAgYW1wVmFsaWRhdG9yOiBnZXRSZXF1ZXN0TWV0YShyZXEsICdhbXBWYWxpZGF0b3InKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAudGhlbigocmVuZGVyUmVzdWx0KTogUmVzcG9uc2VDYWNoZUVudHJ5ID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IG1ldGFkYXRhIH0gPSByZW5kZXJSZXN1bHRcblxuICAgICAgICAgICAgICAgIGxldCBjYWNoZUNvbnRyb2w6IENhY2hlQ29udHJvbCB8IHVuZGVmaW5lZCA9XG4gICAgICAgICAgICAgICAgICBtZXRhZGF0YS5jYWNoZUNvbnRyb2xcblxuICAgICAgICAgICAgICAgIGlmICgnaXNOb3RGb3VuZCcgaW4gbWV0YWRhdGEgJiYgbWV0YWRhdGEuaXNOb3RGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlQ29udHJvbCxcbiAgICAgICAgICAgICAgICAgIH0gc2F0aXNmaWVzIFJlc3BvbnNlQ2FjaGVFbnRyeVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBgaXNSZWRpcmVjdGAuXG4gICAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhLmlzUmVkaXJlY3QpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgICAga2luZDogQ2FjaGVkUm91dGVLaW5kLlJFRElSRUNULFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BzOiBtZXRhZGF0YS5wYWdlRGF0YSA/PyBtZXRhZGF0YS5mbGlnaHREYXRhLFxuICAgICAgICAgICAgICAgICAgICB9IHNhdGlzZmllcyBDYWNoZWRSZWRpcmVjdFZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBjYWNoZUNvbnRyb2wsXG4gICAgICAgICAgICAgICAgICB9IHNhdGlzZmllcyBSZXNwb25zZUNhY2hlRW50cnlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogQ2FjaGVkUm91dGVLaW5kLlBBR0VTLFxuICAgICAgICAgICAgICAgICAgICBodG1sOiByZW5kZXJSZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VEYXRhOiByZW5kZXJSZXN1bHQubWV0YWRhdGEucGFnZURhdGEsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHJlbmRlclJlc3VsdC5tZXRhZGF0YS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHJlbmRlclJlc3VsdC5tZXRhZGF0YS5zdGF0dXNDb2RlLFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIGNhY2hlQ29udHJvbCxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIC5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXNwYW4pIHJldHVyblxuXG4gICAgICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgICdodHRwLnN0YXR1c19jb2RlJzogcmVzLnN0YXR1c0NvZGUsXG4gICAgICAgICAgICAgICAgICAnbmV4dC5yc2MnOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgICAgY29uc3Qgcm9vdFNwYW5BdHRyaWJ1dGVzID0gdHJhY2VyLmdldFJvb3RTcGFuQXR0cmlidXRlcygpXG4gICAgICAgICAgICAgICAgLy8gV2Ugd2VyZSB1bmFibGUgdG8gZ2V0IGF0dHJpYnV0ZXMsIHByb2JhYmx5IE9URUwgaXMgbm90IGVuYWJsZWRcbiAgICAgICAgICAgICAgICBpZiAoIXJvb3RTcGFuQXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgcm9vdFNwYW5BdHRyaWJ1dGVzLmdldCgnbmV4dC5zcGFuX3R5cGUnKSAhPT1cbiAgICAgICAgICAgICAgICAgIEJhc2VTZXJ2ZXJTcGFuLmhhbmRsZVJlcXVlc3RcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICAgICAgYFVuZXhwZWN0ZWQgcm9vdCBzcGFuIHR5cGUgJyR7cm9vdFNwYW5BdHRyaWJ1dGVzLmdldChcbiAgICAgICAgICAgICAgICAgICAgICAnbmV4dC5zcGFuX3R5cGUnXG4gICAgICAgICAgICAgICAgICAgICl9Jy4gUGxlYXNlIHJlcG9ydCB0aGlzIE5leHQuanMgaXNzdWUgaHR0cHM6Ly9naXRodWIuY29tL3ZlcmNlbC9uZXh0LmpzYFxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3Qgcm91dGUgPSByb290U3BhbkF0dHJpYnV0ZXMuZ2V0KCduZXh0LnJvdXRlJylcbiAgICAgICAgICAgICAgICBpZiAocm91dGUpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBgJHttZXRob2R9ICR7cm91dGV9YFxuXG4gICAgICAgICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgICAnbmV4dC5yb3V0ZSc6IHJvdXRlLFxuICAgICAgICAgICAgICAgICAgICAnaHR0cC5yb3V0ZSc6IHJvdXRlLFxuICAgICAgICAgICAgICAgICAgICAnbmV4dC5zcGFuX25hbWUnOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgIHNwYW4udXBkYXRlTmFtZShuYW1lKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzcGFuLnVwZGF0ZU5hbWUoYCR7bWV0aG9kfSAke3JlcS51cmx9YClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSBjYXRjaCAoZXJyOiB1bmtub3duKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGlzIGlzIGEgYmFja2dyb3VuZCByZXZhbGlkYXRlIHdlIG5lZWQgdG8gcmVwb3J0XG4gICAgICAgICAgICAvLyB0aGUgcmVxdWVzdCBlcnJvciBoZXJlIGFzIGl0IHdvbid0IGJlIGJ1YmJsZWRcbiAgICAgICAgICAgIGlmIChwcmV2aW91c0NhY2hlRW50cnk/LmlzU3RhbGUpIHtcbiAgICAgICAgICAgICAgYXdhaXQgcm91dGVNb2R1bGUub25SZXF1ZXN0RXJyb3IoXG4gICAgICAgICAgICAgICAgcmVxLFxuICAgICAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICByb3V0ZXJLaW5kOiAnUGFnZXMgUm91dGVyJyxcbiAgICAgICAgICAgICAgICAgIHJvdXRlUGF0aDogc3JjUGFnZSxcbiAgICAgICAgICAgICAgICAgIHJvdXRlVHlwZTogJ3JlbmRlcicsXG4gICAgICAgICAgICAgICAgICByZXZhbGlkYXRlUmVhc29uOiBnZXRSZXZhbGlkYXRlUmVhc29uKHtcbiAgICAgICAgICAgICAgICAgICAgaXNSZXZhbGlkYXRlOiBoYXNTdGF0aWNQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgaXNPbkRlbWFuZFJldmFsaWRhdGUsXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJvdXRlclNlcnZlckNvbnRleHRcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgd2UndmUgYWxyZWFkeSBnZW5lcmF0ZWQgdGhpcyBwYWdlIHdlIG5vIGxvbmdlclxuICAgICAgICAvLyBzZXJ2ZSB0aGUgZmFsbGJhY2tcbiAgICAgICAgaWYgKHByZXZpb3VzQ2FjaGVFbnRyeSkge1xuICAgICAgICAgIGlzSXNyRmFsbGJhY2sgPSBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzSXNyRmFsbGJhY2spIHtcbiAgICAgICAgICBjb25zdCBmYWxsYmFja1Jlc3BvbnNlID0gYXdhaXQgcm91dGVNb2R1bGUuZ2V0UmVzcG9uc2VDYWNoZShyZXEpLmdldChcbiAgICAgICAgICAgIHJvdXRlTW9kdWxlLmlzRGV2XG4gICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICA6IGxvY2FsZVxuICAgICAgICAgICAgICAgID8gYC8ke2xvY2FsZX0ke3NyY1BhZ2V9YFxuICAgICAgICAgICAgICAgIDogc3JjUGFnZSxcbiAgICAgICAgICAgIGFzeW5jICh7XG4gICAgICAgICAgICAgIHByZXZpb3VzQ2FjaGVFbnRyeTogcHJldmlvdXNGYWxsYmFja0NhY2hlRW50cnkgPSBudWxsLFxuICAgICAgICAgICAgfSkgPT4ge1xuICAgICAgICAgICAgICBpZiAoIXJvdXRlTW9kdWxlLmlzRGV2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvUmVzcG9uc2VDYWNoZUVudHJ5KHByZXZpb3VzRmFsbGJhY2tDYWNoZUVudHJ5KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBkb1JlbmRlcigpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICByb3V0ZUtpbmQ6IFJvdXRlS2luZC5QQUdFUyxcbiAgICAgICAgICAgICAgaXNGYWxsYmFjazogdHJ1ZSxcbiAgICAgICAgICAgICAgaXNSb3V0ZVBQUkVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICBpc09uRGVtYW5kUmV2YWxpZGF0ZTogZmFsc2UsXG4gICAgICAgICAgICAgIGluY3JlbWVudGFsQ2FjaGU6IGF3YWl0IHJvdXRlTW9kdWxlLmdldEluY3JlbWVudGFsQ2FjaGUoXG4gICAgICAgICAgICAgICAgcmVxLFxuICAgICAgICAgICAgICAgIG5leHRDb25maWcsXG4gICAgICAgICAgICAgICAgcHJlcmVuZGVyTWFuaWZlc3RcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgd2FpdFVudGlsOiBjdHgud2FpdFVudGlsLFxuICAgICAgICAgICAgfVxuICAgICAgICAgIClcbiAgICAgICAgICBpZiAoZmFsbGJhY2tSZXNwb25zZSkge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBjYWNoZSBjb250cm9sIGZyb20gdGhlIHJlc3BvbnNlIHRvIHByZXZlbnQgaXQgZnJvbSBiZWluZ1xuICAgICAgICAgICAgLy8gdXNlZCBpbiB0aGUgc3Vycm91bmRpbmcgY2FjaGUuXG4gICAgICAgICAgICBkZWxldGUgZmFsbGJhY2tSZXNwb25zZS5jYWNoZUNvbnRyb2xcbiAgICAgICAgICAgIGZhbGxiYWNrUmVzcG9uc2UuaXNNaXNzID0gdHJ1ZVxuICAgICAgICAgICAgcmV0dXJuIGZhbGxiYWNrUmVzcG9uc2VcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgIWdldFJlcXVlc3RNZXRhKHJlcSwgJ21pbmltYWxNb2RlJykgJiZcbiAgICAgICAgICBpc09uRGVtYW5kUmV2YWxpZGF0ZSAmJlxuICAgICAgICAgIHJldmFsaWRhdGVPbmx5R2VuZXJhdGVkICYmXG4gICAgICAgICAgIXByZXZpb3VzQ2FjaGVFbnRyeVxuICAgICAgICApIHtcbiAgICAgICAgICByZXMuc3RhdHVzQ29kZSA9IDQwNFxuICAgICAgICAgIC8vIG9uLWRlbWFuZCByZXZhbGlkYXRlIGFsd2F5cyBzZXRzIHRoaXMgaGVhZGVyXG4gICAgICAgICAgcmVzLnNldEhlYWRlcigneC1uZXh0anMtY2FjaGUnLCAnUkVWQUxJREFURUQnKVxuICAgICAgICAgIHJlcy5lbmQoJ1RoaXMgcGFnZSBjb3VsZCBub3QgYmUgZm91bmQnKVxuICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgaXNJc3JGYWxsYmFjayAmJlxuICAgICAgICAgIHByZXZpb3VzQ2FjaGVFbnRyeT8udmFsdWU/LmtpbmQgPT09IENhY2hlZFJvdXRlS2luZC5QQUdFU1xuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAga2luZDogQ2FjaGVkUm91dGVLaW5kLlBBR0VTLFxuICAgICAgICAgICAgICBodG1sOiBuZXcgUmVuZGVyUmVzdWx0KFxuICAgICAgICAgICAgICAgIEJ1ZmZlci5mcm9tKHByZXZpb3VzQ2FjaGVFbnRyeS52YWx1ZS5odG1sKSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBjb250ZW50VHlwZTogJ3RleHQvaHRtbDt1dGYtOCcsXG4gICAgICAgICAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXNDb2RlOiBwcmV2aW91c0NhY2hlRW50cnkudmFsdWUuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBwcmV2aW91c0NhY2hlRW50cnkudmFsdWUuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICBwYWdlRGF0YToge30sXG4gICAgICAgICAgICAgIHN0YXR1czogcHJldmlvdXNDYWNoZUVudHJ5LnZhbHVlLnN0YXR1cyxcbiAgICAgICAgICAgICAgaGVhZGVyczogcHJldmlvdXNDYWNoZUVudHJ5LnZhbHVlLmhlYWRlcnMsXG4gICAgICAgICAgICB9IHNhdGlzZmllcyBDYWNoZWRQYWdlVmFsdWUsXG4gICAgICAgICAgICBjYWNoZUNvbnRyb2w6IHsgcmV2YWxpZGF0ZTogMCwgZXhwaXJlOiB1bmRlZmluZWQgfSxcbiAgICAgICAgICB9IHNhdGlzZmllcyBSZXNwb25zZUNhY2hlRW50cnlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG9SZW5kZXIoKVxuICAgICAgfVxuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByb3V0ZU1vZHVsZS5oYW5kbGVSZXNwb25zZSh7XG4gICAgICAgIGNhY2hlS2V5LFxuICAgICAgICByZXEsXG4gICAgICAgIG5leHRDb25maWcsXG4gICAgICAgIHJvdXRlS2luZDogUm91dGVLaW5kLlBBR0VTLFxuICAgICAgICBpc09uRGVtYW5kUmV2YWxpZGF0ZSxcbiAgICAgICAgcmV2YWxpZGF0ZU9ubHlHZW5lcmF0ZWQsXG4gICAgICAgIHdhaXRVbnRpbDogY3R4LndhaXRVbnRpbCxcbiAgICAgICAgcmVzcG9uc2VHZW5lcmF0b3I6IHJlc3BvbnNlR2VuZXJhdG9yLFxuICAgICAgICBwcmVyZW5kZXJNYW5pZmVzdCxcbiAgICAgIH0pXG5cbiAgICAgIC8vIGlmIHdlIGdvdCBhIGNhY2hlIGhpdCB0aGlzIHdhc24ndCBhbiBJU1IgZmFsbGJhY2tcbiAgICAgIC8vIGJ1dCBpdCB3YXNuJ3QgZ2VuZXJhdGVkIGR1cmluZyBidWlsZCBzbyBpc24ndCBpbiB0aGVcbiAgICAgIC8vIHByZXJlbmRlci1tYW5pZmVzdFxuICAgICAgaWYgKGlzSXNyRmFsbGJhY2sgJiYgIXJlc3VsdD8uaXNNaXNzKSB7XG4gICAgICAgIGlzSXNyRmFsbGJhY2sgPSBmYWxzZVxuICAgICAgfVxuXG4gICAgICAvLyByZXNwb25zZSBpcyBmaW5pc2hlZCBpcyBubyBjYWNoZSBlbnRyeVxuICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNTdGF0aWNQcm9wcyAmJiAhZ2V0UmVxdWVzdE1ldGEocmVxLCAnbWluaW1hbE1vZGUnKSkge1xuICAgICAgICByZXMuc2V0SGVhZGVyKFxuICAgICAgICAgICd4LW5leHRqcy1jYWNoZScsXG4gICAgICAgICAgaXNPbkRlbWFuZFJldmFsaWRhdGVcbiAgICAgICAgICAgID8gJ1JFVkFMSURBVEVEJ1xuICAgICAgICAgICAgOiByZXN1bHQuaXNNaXNzXG4gICAgICAgICAgICAgID8gJ01JU1MnXG4gICAgICAgICAgICAgIDogcmVzdWx0LmlzU3RhbGVcbiAgICAgICAgICAgICAgICA/ICdTVEFMRSdcbiAgICAgICAgICAgICAgICA6ICdISVQnXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgbGV0IGNhY2hlQ29udHJvbDogQ2FjaGVDb250cm9sIHwgdW5kZWZpbmVkXG5cbiAgICAgIGlmICghaGFzU3RhdGljUHJvcHMgfHwgaXNJc3JGYWxsYmFjaykge1xuICAgICAgICBpZiAoIXJlcy5nZXRIZWFkZXIoJ0NhY2hlLUNvbnRyb2wnKSkge1xuICAgICAgICAgIGNhY2hlQ29udHJvbCA9IHsgcmV2YWxpZGF0ZTogMCwgZXhwaXJlOiB1bmRlZmluZWQgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzNDA0UGFnZSkge1xuICAgICAgICBjb25zdCBub3RGb3VuZFJldmFsaWRhdGUgPSBnZXRSZXF1ZXN0TWV0YShyZXEsICdub3RGb3VuZFJldmFsaWRhdGUnKVxuXG4gICAgICAgIGNhY2hlQ29udHJvbCA9IHtcbiAgICAgICAgICByZXZhbGlkYXRlOlxuICAgICAgICAgICAgdHlwZW9mIG5vdEZvdW5kUmV2YWxpZGF0ZSA9PT0gJ3VuZGVmaW5lZCcgPyAwIDogbm90Rm91bmRSZXZhbGlkYXRlLFxuICAgICAgICAgIGV4cGlyZTogdW5kZWZpbmVkLFxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzNTAwUGFnZSkge1xuICAgICAgICBjYWNoZUNvbnRyb2wgPSB7IHJldmFsaWRhdGU6IDAsIGV4cGlyZTogdW5kZWZpbmVkIH1cbiAgICAgIH0gZWxzZSBpZiAocmVzdWx0LmNhY2hlQ29udHJvbCkge1xuICAgICAgICAvLyBJZiB0aGUgY2FjaGUgZW50cnkgaGFzIGEgY2FjaGUgY29udHJvbCB3aXRoIGEgcmV2YWxpZGF0ZSB2YWx1ZSB0aGF0J3NcbiAgICAgICAgLy8gYSBudW1iZXIsIHVzZSBpdC5cbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQuY2FjaGVDb250cm9sLnJldmFsaWRhdGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgaWYgKHJlc3VsdC5jYWNoZUNvbnRyb2wucmV2YWxpZGF0ZSA8IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgYEludmFsaWQgcmV2YWxpZGF0ZSBjb25maWd1cmF0aW9uIHByb3ZpZGVkOiAke3Jlc3VsdC5jYWNoZUNvbnRyb2wucmV2YWxpZGF0ZX0gPCAxYFxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgICBjYWNoZUNvbnRyb2wgPSB7XG4gICAgICAgICAgICByZXZhbGlkYXRlOiByZXN1bHQuY2FjaGVDb250cm9sLnJldmFsaWRhdGUsXG4gICAgICAgICAgICBleHBpcmU6IHJlc3VsdC5jYWNoZUNvbnRyb2w/LmV4cGlyZSA/PyBuZXh0Q29uZmlnLmV4cGlyZVRpbWUsXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHJldmFsaWRhdGU6IGZhbHNlXG4gICAgICAgICAgY2FjaGVDb250cm9sID0ge1xuICAgICAgICAgICAgcmV2YWxpZGF0ZTogQ0FDSEVfT05FX1lFQVIsXG4gICAgICAgICAgICBleHBpcmU6IHVuZGVmaW5lZCxcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSWYgY2FjaGUgY29udHJvbCBpcyBhbHJlYWR5IHNldCBvbiB0aGUgcmVzcG9uc2Ugd2UgZG9uJ3RcbiAgICAgIC8vIG92ZXJyaWRlIGl0IHRvIGFsbG93IHVzZXJzIHRvIGN1c3RvbWl6ZSBpdCB2aWEgbmV4dC5jb25maWdcbiAgICAgIGlmIChjYWNoZUNvbnRyb2wgJiYgIXJlcy5nZXRIZWFkZXIoJ0NhY2hlLUNvbnRyb2wnKSkge1xuICAgICAgICByZXMuc2V0SGVhZGVyKCdDYWNoZS1Db250cm9sJywgZ2V0Q2FjaGVDb250cm9sSGVhZGVyKGNhY2hlQ29udHJvbCkpXG4gICAgICB9XG5cbiAgICAgIC8vIG5vdEZvdW5kOiB0cnVlIGNhc2VcbiAgICAgIGlmICghcmVzdWx0LnZhbHVlKSB7XG4gICAgICAgIC8vIGFkZCByZXZhbGlkYXRlIG1ldGFkYXRhIGJlZm9yZSByZW5kZXJpbmcgNDA0IHBhZ2VcbiAgICAgICAgLy8gc28gdGhhdCB3ZSBjYW4gdXNlIHRoaXMgYXMgc291cmNlIG9mIHRydXRoIGZvciB0aGVcbiAgICAgICAgLy8gY2FjaGUtY29udHJvbCBoZWFkZXIgaW5zdGVhZCBvZiB3aGF0IHRoZSA0MDQgcGFnZSByZXR1cm5zXG4gICAgICAgIC8vIGZvciB0aGUgcmV2YWxpZGF0ZSB2YWx1ZVxuICAgICAgICBhZGRSZXF1ZXN0TWV0YShcbiAgICAgICAgICByZXEsXG4gICAgICAgICAgJ25vdEZvdW5kUmV2YWxpZGF0ZScsXG4gICAgICAgICAgcmVzdWx0LmNhY2hlQ29udHJvbD8ucmV2YWxpZGF0ZVxuICAgICAgICApXG5cbiAgICAgICAgcmVzLnN0YXR1c0NvZGUgPSA0MDRcblxuICAgICAgICBpZiAoaXNOZXh0RGF0YVJlcXVlc3QpIHtcbiAgICAgICAgICByZXMuZW5kKCd7XCJub3RGb3VuZFwiOnRydWV9JylcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBzaG91bGQgcm91dGUtbW9kdWxlIGl0c2VsZiBoYW5kbGUgcmVuZGVyaW5nIHRoZSA0MDRcbiAgICAgICAgaWYgKHJvdXRlclNlcnZlckNvbnRleHQ/LnJlbmRlcjQwNCkge1xuICAgICAgICAgIGF3YWl0IHJvdXRlclNlcnZlckNvbnRleHQucmVuZGVyNDA0KHJlcSwgcmVzLCBwYXJzZWRVcmwsIGZhbHNlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlcy5lbmQoJ1RoaXMgcGFnZSBjb3VsZCBub3QgYmUgZm91bmQnKVxuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAocmVzdWx0LnZhbHVlLmtpbmQgPT09IENhY2hlZFJvdXRlS2luZC5SRURJUkVDVCkge1xuICAgICAgICBpZiAoaXNOZXh0RGF0YVJlcXVlc3QpIHtcbiAgICAgICAgICByZXMuc2V0SGVhZGVyKCdjb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24vanNvbicpXG4gICAgICAgICAgcmVzLmVuZChKU09OLnN0cmluZ2lmeShyZXN1bHQudmFsdWUucHJvcHMpKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGhhbmRsZVJlZGlyZWN0ID0gKHBhZ2VEYXRhOiBhbnkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlZGlyZWN0ID0ge1xuICAgICAgICAgICAgICBkZXN0aW5hdGlvbjogcGFnZURhdGEucGFnZVByb3BzLl9fTl9SRURJUkVDVCxcbiAgICAgICAgICAgICAgc3RhdHVzQ29kZTogcGFnZURhdGEucGFnZVByb3BzLl9fTl9SRURJUkVDVF9TVEFUVVMsXG4gICAgICAgICAgICAgIGJhc2VQYXRoOiBwYWdlRGF0YS5wYWdlUHJvcHMuX19OX1JFRElSRUNUX0JBU0VfUEFUSCxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0YXR1c0NvZGUgPSBnZXRSZWRpcmVjdFN0YXR1cyhyZWRpcmVjdClcbiAgICAgICAgICAgIGNvbnN0IHsgYmFzZVBhdGggfSA9IG5leHRDb25maWdcblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBiYXNlUGF0aCAmJlxuICAgICAgICAgICAgICByZWRpcmVjdC5iYXNlUGF0aCAhPT0gZmFsc2UgJiZcbiAgICAgICAgICAgICAgcmVkaXJlY3QuZGVzdGluYXRpb24uc3RhcnRzV2l0aCgnLycpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgcmVkaXJlY3QuZGVzdGluYXRpb24gPSBgJHtiYXNlUGF0aH0ke3JlZGlyZWN0LmRlc3RpbmF0aW9ufWBcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJlZGlyZWN0LmRlc3RpbmF0aW9uLnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgICAgICAgICAgICByZWRpcmVjdC5kZXN0aW5hdGlvbiA9IG5vcm1hbGl6ZVJlcGVhdGVkU2xhc2hlcyhcbiAgICAgICAgICAgICAgICByZWRpcmVjdC5kZXN0aW5hdGlvblxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZVxuICAgICAgICAgICAgcmVzLnNldEhlYWRlcignTG9jYXRpb24nLCByZWRpcmVjdC5kZXN0aW5hdGlvbilcbiAgICAgICAgICAgIGlmIChzdGF0dXNDb2RlID09PSBSZWRpcmVjdFN0YXR1c0NvZGUuUGVybWFuZW50UmVkaXJlY3QpIHtcbiAgICAgICAgICAgICAgcmVzLnNldEhlYWRlcignUmVmcmVzaCcsIGAwO3VybD0ke3JlZGlyZWN0LmRlc3RpbmF0aW9ufWApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXMuZW5kKHJlZGlyZWN0LmRlc3RpbmF0aW9uKVxuICAgICAgICAgIH1cbiAgICAgICAgICBhd2FpdCBoYW5kbGVSZWRpcmVjdChyZXN1bHQudmFsdWUucHJvcHMpXG4gICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocmVzdWx0LnZhbHVlLmtpbmQgIT09IENhY2hlZFJvdXRlS2luZC5QQUdFUykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEludmFyaWFudDogcmVjZWl2ZWQgbm9uLXBhZ2VzIGNhY2hlIGVudHJ5IGluIHBhZ2VzIGhhbmRsZXJgXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgLy8gSW4gZGV2LCB3ZSBzaG91bGQgbm90IGNhY2hlIHBhZ2VzIGZvciBhbnkgcmVhc29uLlxuICAgICAgaWYgKHJvdXRlTW9kdWxlLmlzRGV2KSB7XG4gICAgICAgIHJlcy5zZXRIZWFkZXIoJ0NhY2hlLUNvbnRyb2wnLCAnbm8tc3RvcmUsIG11c3QtcmV2YWxpZGF0ZScpXG4gICAgICB9XG5cbiAgICAgIC8vIERyYWZ0IG1vZGUgc2hvdWxkIG5ldmVyIGJlIGNhY2hlZFxuICAgICAgaWYgKGlzRHJhZnRNb2RlKSB7XG4gICAgICAgIHJlcy5zZXRIZWFkZXIoXG4gICAgICAgICAgJ0NhY2hlLUNvbnRyb2wnLFxuICAgICAgICAgICdwcml2YXRlLCBuby1jYWNoZSwgbm8tc3RvcmUsIG1heC1hZ2U9MCwgbXVzdC1yZXZhbGlkYXRlJ1xuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIC8vIHdoZW4gaW52b2tpbmcgX2Vycm9yIGJlZm9yZSBwYWdlcy81MDAgd2UgZG9uJ3QgYWN0dWFsbHlcbiAgICAgIC8vIHNlbmQgdGhlIF9lcnJvciByZXNwb25zZVxuICAgICAgaWYgKFxuICAgICAgICBnZXRSZXF1ZXN0TWV0YShyZXEsICdjdXN0b21FcnJvclJlbmRlcicpIHx8XG4gICAgICAgIChpc0Vycm9yUGFnZSAmJlxuICAgICAgICAgIGdldFJlcXVlc3RNZXRhKHJlcSwgJ21pbmltYWxNb2RlJykgJiZcbiAgICAgICAgICByZXMuc3RhdHVzQ29kZSA9PT0gNTAwKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG5cbiAgICAgIGF3YWl0IHNlbmRSZW5kZXJSZXN1bHQoe1xuICAgICAgICByZXEsXG4gICAgICAgIHJlcyxcbiAgICAgICAgLy8gSWYgd2UgYXJlIHJlbmRlcmluZyB0aGUgZXJyb3IgcGFnZSBpdCdzIG5vdCBhIGRhdGEgcmVxdWVzdFxuICAgICAgICAvLyBhbnltb3JlXG4gICAgICAgIHJlc3VsdDpcbiAgICAgICAgICBpc05leHREYXRhUmVxdWVzdCAmJiAhaXNFcnJvclBhZ2UgJiYgIWlzNTAwUGFnZVxuICAgICAgICAgICAgPyBuZXcgUmVuZGVyUmVzdWx0KFxuICAgICAgICAgICAgICAgIEJ1ZmZlci5mcm9tKEpTT04uc3RyaW5naWZ5KHJlc3VsdC52YWx1ZS5wYWdlRGF0YSkpLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgICBtZXRhZGF0YTogcmVzdWx0LnZhbHVlLmh0bWwubWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICA6IHJlc3VsdC52YWx1ZS5odG1sLFxuICAgICAgICBnZW5lcmF0ZUV0YWdzOiBuZXh0Q29uZmlnLmdlbmVyYXRlRXRhZ3MsXG4gICAgICAgIHBvd2VyZWRCeUhlYWRlcjogbmV4dENvbmZpZy5wb3dlcmVkQnlIZWFkZXIsXG4gICAgICAgIGNhY2hlQ29udHJvbDogcm91dGVNb2R1bGUuaXNEZXYgPyB1bmRlZmluZWQgOiBjYWNoZUNvbnRyb2wsXG4gICAgICAgIHR5cGU6IGlzTmV4dERhdGFSZXF1ZXN0ID8gJ2pzb24nIDogJ2h0bWwnLFxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBhY3RpdmVTcGFuIGNvZGUgcGF0aCBpcyBmb3Igd2hlbiB3cmFwcGVkIGJ5XG4gICAgLy8gbmV4dC1zZXJ2ZXIgY2FuIGJlIHJlbW92ZWQgd2hlbiB0aGlzIGlzIG5vIGxvbmdlciB1c2VkXG4gICAgaWYgKGFjdGl2ZVNwYW4pIHtcbiAgICAgIGF3YWl0IGhhbmRsZVJlc3BvbnNlKClcbiAgICB9IGVsc2Uge1xuICAgICAgYXdhaXQgdHJhY2VyLndpdGhQcm9wYWdhdGVkQ29udGV4dChyZXEuaGVhZGVycywgKCkgPT5cbiAgICAgICAgdHJhY2VyLnRyYWNlKFxuICAgICAgICAgIEJhc2VTZXJ2ZXJTcGFuLmhhbmRsZVJlcXVlc3QsXG4gICAgICAgICAge1xuICAgICAgICAgICAgc3Bhbk5hbWU6IGAke21ldGhvZH0gJHtyZXEudXJsfWAsXG4gICAgICAgICAgICBraW5kOiBTcGFuS2luZC5TRVJWRVIsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICdodHRwLm1ldGhvZCc6IG1ldGhvZCxcbiAgICAgICAgICAgICAgJ2h0dHAudGFyZ2V0JzogcmVxLnVybCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICBoYW5kbGVSZXNwb25zZVxuICAgICAgICApXG4gICAgICApXG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBhd2FpdCByb3V0ZU1vZHVsZS5vblJlcXVlc3RFcnJvcihcbiAgICAgIHJlcSxcbiAgICAgIGVycixcbiAgICAgIHtcbiAgICAgICAgcm91dGVyS2luZDogJ1BhZ2VzIFJvdXRlcicsXG4gICAgICAgIHJvdXRlUGF0aDogc3JjUGFnZSxcbiAgICAgICAgcm91dGVUeXBlOiAncmVuZGVyJyxcbiAgICAgICAgcmV2YWxpZGF0ZVJlYXNvbjogZ2V0UmV2YWxpZGF0ZVJlYXNvbih7XG4gICAgICAgICAgaXNSZXZhbGlkYXRlOiBoYXNTdGF0aWNQcm9wcyxcbiAgICAgICAgICBpc09uRGVtYW5kUmV2YWxpZGF0ZSxcbiAgICAgICAgfSksXG4gICAgICB9LFxuICAgICAgcm91dGVyU2VydmVyQ29udGV4dFxuICAgIClcblxuICAgIC8vIHJldGhyb3cgc28gdGhhdCB3ZSBjYW4gaGFuZGxlIHNlcnZpbmcgZXJyb3IgcGFnZVxuICAgIHRocm93IGVyclxuICB9XG59XG4iXSwibmFtZXMiOlsiUGFnZXNSb3V0ZU1vZHVsZSIsIlJvdXRlS2luZCIsIkJhc2VTZXJ2ZXJTcGFuIiwiZ2V0VHJhY2VyIiwiU3BhbktpbmQiLCJmb3JtYXRVcmwiLCJhZGRSZXF1ZXN0TWV0YSIsImdldFJlcXVlc3RNZXRhIiwiaW50ZXJvcERlZmF1bHQiLCJnZXRSZXZhbGlkYXRlUmVhc29uIiwibm9ybWFsaXplRGF0YVBhdGgiLCJDYWNoZWRSb3V0ZUtpbmQiLCJob2lzdCIsImRvY3VtZW50IiwiYXBwIiwidXNlcmxhbmQiLCJnZXRDYWNoZUNvbnRyb2xIZWFkZXIiLCJub3JtYWxpemVSZXBlYXRlZFNsYXNoZXMiLCJnZXRSZWRpcmVjdFN0YXR1cyIsIkNBQ0hFX09ORV9ZRUFSIiwic2VuZFJlbmRlclJlc3VsdCIsIlJlbmRlclJlc3VsdCIsInRvUmVzcG9uc2VDYWNoZUVudHJ5IiwiTm9GYWxsYmFja0Vycm9yIiwiUmVkaXJlY3RTdGF0dXNDb2RlIiwiaXNCb3QiLCJhZGRQYXRoUHJlZml4IiwicmVtb3ZlVHJhaWxpbmdTbGFzaCIsImdldFN0YXRpY1Byb3BzIiwiZ2V0U3RhdGljUGF0aHMiLCJnZXRTZXJ2ZXJTaWRlUHJvcHMiLCJjb25maWciLCJyZXBvcnRXZWJWaXRhbHMiLCJ1bnN0YWJsZV9nZXRTdGF0aWNQcm9wcyIsInVuc3RhYmxlX2dldFN0YXRpY1BhdGhzIiwidW5zdGFibGVfZ2V0U3RhdGljUGFyYW1zIiwidW5zdGFibGVfZ2V0U2VydmVyUHJvcHMiLCJ1bnN0YWJsZV9nZXRTZXJ2ZXJTaWRlUHJvcHMiLCJyb3V0ZU1vZHVsZSIsImRlZmluaXRpb24iLCJraW5kIiwiUEFHRVMiLCJwYWdlIiwicGF0aG5hbWUiLCJidW5kbGVQYXRoIiwiZmlsZW5hbWUiLCJkaXN0RGlyIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9SRUxBVElWRV9ESVNUX0RJUiIsInByb2plY3REaXIiLCJfX05FWFRfUkVMQVRJVkVfUFJPSkVDVF9ESVIiLCJjb21wb25lbnRzIiwiQXBwIiwiZGVmYXVsdCIsIkRvY3VtZW50IiwiaGFuZGxlciIsInJlcSIsInJlcyIsImN0eCIsInNlcnZlckZpbGVzTWFuaWZlc3QiLCJzcmNQYWdlIiwiVFVSQk9QQUNLIiwicmVwbGFjZSIsIm11bHRpWm9uZURyYWZ0TW9kZSIsIl9fTkVYVF9NVUxUSV9aT05FX0RSQUZUX01PREUiLCJwcmVwYXJlUmVzdWx0IiwicHJlcGFyZSIsInN0YXR1c0NvZGUiLCJlbmQiLCJ3YWl0VW50aWwiLCJQcm9taXNlIiwicmVzb2x2ZSIsImJ1aWxkSWQiLCJxdWVyeSIsInBhcmFtcyIsInBhcnNlZFVybCIsIm9yaWdpbmFsUXVlcnkiLCJvcmlnaW5hbFBhdGhuYW1lIiwiYnVpbGRNYW5pZmVzdCIsIm5leHRGb250TWFuaWZlc3QiLCJyZWFjdExvYWRhYmxlTWFuaWZlc3QiLCJwcmVyZW5kZXJNYW5pZmVzdCIsImlzRHJhZnRNb2RlIiwiaXNPbkRlbWFuZFJldmFsaWRhdGUiLCJyZXZhbGlkYXRlT25seUdlbmVyYXRlZCIsImxvY2FsZSIsImxvY2FsZXMiLCJkZWZhdWx0TG9jYWxlIiwicm91dGVyU2VydmVyQ29udGV4dCIsIm5leHRDb25maWciLCJyZXNvbHZlZFBhdGhuYW1lIiwiaXNFeHBlcmltZW50YWxDb21waWxlIiwiZXhwZXJpbWVudGFsIiwiaGFzU2VydmVyUHJvcHMiLCJCb29sZWFuIiwiaGFzU3RhdGljUHJvcHMiLCJoYXNTdGF0aWNQYXRocyIsImhhc0dldEluaXRpYWxQcm9wcyIsImdldEluaXRpYWxQcm9wcyIsImlzQW1wIiwiYW1wIiwiY2FjaGVLZXkiLCJpc0lzckZhbGxiYWNrIiwiaXNOZXh0RGF0YVJlcXVlc3QiLCJpczQwNFBhZ2UiLCJpczUwMFBhZ2UiLCJpc0Vycm9yUGFnZSIsImlzRGV2IiwiZGVjb2RlZFBhdGhuYW1lIiwiaXNQcmVyZW5kZXJlZCIsInJvdXRlcyIsIm5vdEZvdW5kUm91dGVzIiwiaW5jbHVkZXMiLCJwcmVyZW5kZXJJbmZvIiwiZHluYW1pY1JvdXRlcyIsImZhbGxiYWNrIiwiaGVhZGVycyIsInRyYWNlciIsImFjdGl2ZVNwYW4iLCJnZXRBY3RpdmVTY29wZVNwYW4iLCJtZXRob2QiLCJyZXNvbHZlZFVybCIsInRyYWlsaW5nU2xhc2giLCJwdWJsaWNSdW50aW1lQ29uZmlnIiwiaGFuZGxlUmVzcG9uc2UiLCJzcGFuIiwicmVzcG9uc2VHZW5lcmF0b3IiLCJwcmV2aW91c0NhY2hlRW50cnkiLCJkb1JlbmRlciIsInJlbmRlciIsInJlbmRlckNvbnRleHQiLCJpc0ZhbGxiYWNrIiwiZGV2ZWxvcG1lbnROb3RGb3VuZFNvdXJjZVBhZ2UiLCJzaGFyZWRDb250ZXh0IiwiY3VzdG9tU2VydmVyIiwiaXNDdXN0b21TZXJ2ZXIiLCJ1bmRlZmluZWQiLCJkZXBsb3ltZW50SWQiLCJORVhUX0RFUExPWU1FTlRfSUQiLCJyZW5kZXJPcHRzIiwicGFnZUNvbmZpZyIsIkNvbXBvbmVudCIsIkNvbXBvbmVudE1vZCIsInN1cHBvcnRzRHluYW1pY1Jlc3BvbnNlIiwiYXNzZXRQcmVmaXgiLCJzdHJpY3ROZXh0SGVhZCIsInByZXZpZXdQcm9wcyIsInByZXZpZXciLCJpbWFnZXMiLCJuZXh0Q29uZmlnT3V0cHV0Iiwib3V0cHV0Iiwib3B0aW1pemVDc3MiLCJuZXh0U2NyaXB0V29ya2VycyIsImRvbWFpbkxvY2FsZXMiLCJpMThuIiwiZG9tYWlucyIsImNyb3NzT3JpZ2luIiwiYmFzZVBhdGgiLCJjYW5vbmljYWxCYXNlIiwiYW1wT3B0aW1pemVyQ29uZmlnIiwib3B0aW1pemVyIiwiZGlzYWJsZU9wdGltaXplZExvYWRpbmciLCJsYXJnZVBhZ2VEYXRhQnl0ZXMiLCJydW50aW1lQ29uZmlnIiwiT2JqZWN0Iiwia2V5cyIsImxlbmd0aCIsImNsaWVudFRyYWNlTWV0YWRhdGEiLCJzZXRJc3JTdGF0dXMiLCJyZXNvbHZlZEFzUGF0aCIsIkVycm9yRGVidWciLCJlcnIiLCJkZXYiLCJhbXBTa2lwVmFsaWRhdGlvbiIsInNraXBWYWxpZGF0aW9uIiwiYW1wVmFsaWRhdG9yIiwidGhlbiIsInJlbmRlclJlc3VsdCIsIm1ldGFkYXRhIiwiY2FjaGVDb250cm9sIiwiaXNOb3RGb3VuZCIsInZhbHVlIiwiaXNSZWRpcmVjdCIsIlJFRElSRUNUIiwicHJvcHMiLCJwYWdlRGF0YSIsImZsaWdodERhdGEiLCJodG1sIiwic3RhdHVzIiwiZmluYWxseSIsInNldEF0dHJpYnV0ZXMiLCJyb290U3BhbkF0dHJpYnV0ZXMiLCJnZXRSb290U3BhbkF0dHJpYnV0ZXMiLCJnZXQiLCJoYW5kbGVSZXF1ZXN0IiwiY29uc29sZSIsIndhcm4iLCJyb3V0ZSIsIm5hbWUiLCJ1cGRhdGVOYW1lIiwidXJsIiwiaXNTdGFsZSIsIm9uUmVxdWVzdEVycm9yIiwicm91dGVyS2luZCIsInJvdXRlUGF0aCIsInJvdXRlVHlwZSIsInJldmFsaWRhdGVSZWFzb24iLCJpc1JldmFsaWRhdGUiLCJmYWxsYmFja1Jlc3BvbnNlIiwiZ2V0UmVzcG9uc2VDYWNoZSIsInByZXZpb3VzRmFsbGJhY2tDYWNoZUVudHJ5Iiwicm91dGVLaW5kIiwiaXNSb3V0ZVBQUkVuYWJsZWQiLCJpbmNyZW1lbnRhbENhY2hlIiwiZ2V0SW5jcmVtZW50YWxDYWNoZSIsImlzTWlzcyIsInNldEhlYWRlciIsIkJ1ZmZlciIsImZyb20iLCJjb250ZW50VHlwZSIsInJldmFsaWRhdGUiLCJleHBpcmUiLCJyZXN1bHQiLCJnZXRIZWFkZXIiLCJub3RGb3VuZFJldmFsaWRhdGUiLCJFcnJvciIsImV4cGlyZVRpbWUiLCJyZW5kZXI0MDQiLCJKU09OIiwic3RyaW5naWZ5IiwiaGFuZGxlUmVkaXJlY3QiLCJyZWRpcmVjdCIsImRlc3RpbmF0aW9uIiwicGFnZVByb3BzIiwiX19OX1JFRElSRUNUIiwiX19OX1JFRElSRUNUX1NUQVRVUyIsIl9fTl9SRURJUkVDVF9CQVNFX1BBVEgiLCJzdGFydHNXaXRoIiwiUGVybWFuZW50UmVkaXJlY3QiLCJnZW5lcmF0ZUV0YWdzIiwicG93ZXJlZEJ5SGVhZGVyIiwidHlwZSIsIndpdGhQcm9wYWdhdGVkQ29udGV4dCIsInRyYWNlIiwic3Bhbk5hbWUiLCJTRVJWRVIiLCJhdHRyaWJ1dGVzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFFQSxTQUFTQSxnQkFBZ0IsUUFBUSxtREFBa0Q7QUFDbkYsU0FBU0MsU0FBUyxRQUFRLDBCQUF5QjtBQUNuRCxTQUFTQyxjQUFjLFFBQVEsbUNBQWtDO0FBQ2pFLFNBQVNDLFNBQVMsRUFBRUMsUUFBUSxRQUFtQixnQ0FBK0I7QUFDOUUsU0FBU0MsU0FBUyxRQUFRLDJDQUEwQztBQUNwRSxTQUFTQyxjQUFjLEVBQUVDLGNBQWMsUUFBUSw0QkFBMkI7QUFDMUUsU0FBU0MsY0FBYyxRQUFRLDBDQUF5QztBQUN4RSxTQUFTQyxtQkFBbUIsUUFBUSxxQ0FBb0M7QUFDeEUsU0FBU0MsaUJBQWlCLFFBQVEsaURBQWdEOztBQUNsRixTQUNFQyxlQUFlLFFBS1YsOEJBQTZCO0FBRXBDLFNBQVNDLEtBQUssUUFBUSxZQUFXO0FBRWpDLHVDQUF1QztBQUN2QyxZQUFZQyxjQUFjLHNCQUFxQjtBQUMvQyxZQUFZQyxTQUFTLGlCQUFnQjtBQUVyQyw0QkFBNEI7QUFDNUIsWUFBWUMsY0FBYyxlQUFjO0FBQ3hDLFNBQ0VDLHFCQUFxQixRQUVoQixpQ0FBZ0M7QUFDdkMsU0FBU0Msd0JBQXdCLFFBQVEseUJBQXdCO0FBQ2pFLFNBQVNDLGlCQUFpQixRQUFRLDRCQUEyQjtBQUM3RCxTQUFTQyxjQUFjLFFBQVEsc0JBQXFCO0FBQ3BELFNBQVNDLGdCQUFnQixRQUFRLDRCQUEyQjtBQUM1RCxPQUFPQyxrQkFBa0IsNkJBQTRCO0FBQ3JELFNBQVNDLG9CQUFvQixRQUFRLG9DQUFtQztBQUN4RSxTQUFTQyxlQUFlLFFBQVEsOENBQTZDO0FBQzdFLFNBQVNDLGtCQUFrQixRQUFRLCtDQUE4Qzs7QUFDakYsU0FBU0MsS0FBSyxRQUFRLHVDQUFzQztBQUM1RCxTQUFTQyxhQUFhLFFBQVEsZ0RBQStDO0FBQzdFLFNBQVNDLG1CQUFtQixRQUFRLHNEQUFxRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzJDQUcxRWYsc0tBQUFBLEVBQU1HLHdIQUFVLFdBQVU7QUFHbEMsTUFBTWEsbUxBQWlCaEIsUUFBQUEsRUFBTUcsd0hBQVUsa0JBQWlCO0FBQ3hELE1BQU1jLG1MQUFpQmpCLFFBQUFBLEVBQU1HLHdIQUFVLGtCQUFpQjtBQUN4RCxNQUFNZSx1TEFBcUJsQixRQUFBQSxFQUFNRyx3SEFBVSxzQkFBcUI7QUFDaEUsTUFBTWdCLDJLQUFTbkIsUUFBQUEsRUFBTUcsd0hBQVUsVUFBUztBQUN4QyxNQUFNaUIsb0xBQWtCcEIsUUFBQUEsRUFBTUcsd0hBQVUsbUJBQWtCO0FBRzFELE1BQU1rQiw0TEFBMEJyQixRQUFBQSxFQUNyQ0csd0hBQ0EsMkJBQ0Q7QUFDTSxNQUFNbUIsOEJBQTBCdEIsc0tBQUFBLEVBQ3JDRyx3SEFDQSwyQkFDRDtBQUNNLE1BQU1vQiw2TEFBMkJ2QixRQUFBQSxFQUN0Q0csd0hBQ0EsNEJBQ0Q7QUFDTSxNQUFNcUIsMkxBQTBCeEIsU0FBQUEsRUFDckNHLHdIQUNBLDJCQUNEO0FBQ00sTUFBTXNCLCtMQUE4QnpCLFNBQUFBLEVBQ3pDRyx3SEFDQSwrQkFDRDtBQUdNLE1BQU11QixjQUFjLDhMQUFJdEMsbUJBQUFBLENBQWlCO0lBQzlDdUMsWUFBWTtRQUNWQyw4SkFBTXZDLFlBQUFBLENBQVV3QyxLQUFLO1FBQ3JCQyxNQUFNO1FBQ05DLFVBQVU7UUFDViwyQ0FBMkM7UUFDM0NDLFlBQVk7UUFDWkMsVUFBVTtJQUNaO0lBQ0FDLFNBQVNDLFFBQVFDLEdBQUcsQ0FBQ0Msd0JBQXdCLFNBQUk7SUFDakRDLFlBQVlILFFBQVFDLEdBQUcsQ0FBQ0csMkJBQTJCLENBQUk7SUFDdkRDLFlBQVk7UUFDViw4REFBOEQ7UUFDOURDLDBIQUFLdkMsSUFBSXdDLE1BQU87UUFDaEJDLG9JQUFVMUMsU0FBU3lDLENBQU87SUFDNUI7Y0FDQXZDO0FBQ0YsR0FBRTtBQUVLLGVBQWV5QyxRQUNwQkMsR0FBb0IsRUFDcEJDLEdBQW1CLEVBQ25CQyxHQUVDO1FBb0RDQywwQ0FBQUE7SUFsREYsSUFBSUMsVUFBVTtJQUVkLHdEQUF3RDtJQUN4RCxtREFBbUQ7SUFDbkQsNkRBQTZEO0lBQzdELElBQUlkLFFBQVFDLEdBQUcsQ0FBQ2MsU0FBUyxlQUFFO1FBQ3pCRCxVQUFVQSxRQUFRRSxPQUFPLENBQUMsWUFBWSxPQUFPO0lBQy9DLE9BQU8sSUFBSUYsWUFBWSxVQUFVO1FBQy9CLDBDQUEwQztRQUMxQ0EsVUFBVTtJQUNaO0lBQ0EsTUFBTUcscUJBQXFCakIsUUFBUUMsR0FBRyxDQUNuQ2lCLDRCQUE0QjtJQUUvQixNQUFNQyxnQkFBZ0IsTUFBTTVCLFlBQVk2QixPQUFPLENBQUNWLEtBQUtDLEtBQUs7UUFDeERHO1FBQ0FHO0lBQ0Y7SUFFQSxJQUFJLENBQUNFLGVBQWU7UUFDbEJSLElBQUlVLFVBQVUsR0FBRztRQUNqQlYsSUFBSVcsR0FBRyxDQUFDO1FBQ1JWLElBQUlXLFNBQVMsSUFBQSxPQUFBLEtBQUEsSUFBYlgsSUFBSVcsU0FBUyxDQUFBLElBQUEsQ0FBYlgsS0FBZ0JZLFFBQVFDLE9BQU87UUFDL0I7SUFDRjtJQUVBLE1BQU0sRUFDSkMsT0FBTyxFQUNQQyxLQUFLLEVBQ0xDLE1BQU0sRUFDTkMsU0FBUyxFQUNUQyxhQUFhLEVBQ2JDLGdCQUFnQixFQUNoQkMsYUFBYSxFQUNiQyxnQkFBZ0IsRUFDaEJwQixtQkFBbUIsRUFDbkJxQixxQkFBcUIsRUFDckJDLGlCQUFpQixFQUNqQkMsV0FBVyxFQUNYQyxvQkFBb0IsRUFDcEJDLHVCQUF1QixFQUN2QkMsTUFBTSxFQUNOQyxPQUFPLEVBQ1BDLGFBQWEsRUFDYkMsbUJBQW1CLEVBQ25CQyxVQUFVLEVBQ1ZDLGdCQUFnQixFQUNqQixHQUFHekI7SUFFSixNQUFNMEIsd0JBQ0poQyx1QkFBQUEsT0FBQUEsS0FBQUEsSUFBQUEsQ0FBQUEsOEJBQUFBLG9CQUFxQjdCLE1BQU0sS0FBQSxPQUFBLEtBQUEsSUFBQSxDQUEzQjZCLDJDQUFBQSw0QkFBNkJpQyxZQUFZLEtBQUEsT0FBQSxLQUFBLElBQXpDakMseUNBQTJDZ0MscUJBQXFCO0lBRWxFLE1BQU1FLGlCQUFpQkMsUUFBUWpFO0lBQy9CLE1BQU1rRSxpQkFBaUJELFFBQVFuRTtJQUMvQixNQUFNcUUsaUJBQWlCRixRQUFRbEU7SUFDL0IsTUFBTXFFLHFCQUFxQkgsUUFDeEJoRixDQUFBQSx1SEFBU3VDLE9BQU8sSUFBSXZDLHNIQUFPLEVBQUdvRixlQUFlO0lBRWhELE1BQU1DLFFBQVExQixNQUFNMkIsR0FBRyxJQUFJdEUsT0FBT3NFLEdBQUc7SUFDckMsSUFBSUMsV0FBMEI7SUFDOUIsSUFBSUMsZ0JBQWdCO0lBQ3BCLElBQUlDLG9CQUNGdEMsY0FBY3NDLGlCQUFpQixJQUFLUixDQUFBQSxrQkFBa0JGLGNBQWE7SUFFckUsTUFBTVcsWUFBWTVDLFlBQVk7SUFDOUIsTUFBTTZDLFlBQVk3QyxZQUFZO0lBQzlCLE1BQU04QyxjQUFjOUMsWUFBWTtJQUVoQyxJQUFJLENBQUN2QixZQUFZc0UsS0FBSyxJQUFJLENBQUN6QixlQUFlYSxnQkFBZ0I7UUFDeERNLFdBQVcsR0FBR2hCLFNBQVMsQ0FBQyxDQUFDLEVBQUVBLFFBQVEsR0FBRyxLQUNuQ3pCLENBQUFBLFlBQVksT0FBTzhCLHFCQUFxQixHQUFFLEtBQU1MLFNBQzdDLEtBQ0FLLG1CQUNIUyxRQUFRLFNBQVMsSUFBSTtRQUV4QixJQUFJSyxhQUFhQyxhQUFhQyxhQUFhO1lBQ3pDTCxXQUFXLEdBQUdoQixTQUFTLENBQUMsQ0FBQyxFQUFFQSxRQUFRLEdBQUcsS0FBS3pCLFVBQVV1QyxRQUFRLFNBQVMsSUFBSTtRQUM1RTtRQUVBLCtDQUErQztRQUMvQ0UsV0FBV0EsYUFBYSxXQUFXLE1BQU1BO0lBQzNDO0lBRUEsSUFBSUwsa0JBQWtCLENBQUNkLGFBQWE7UUFDbEMsTUFBTTBCLHNOQUFrQmxGLHNCQUFBQSxFQUN0QjJELHVNQUFTNUQsZ0JBQUFBLEVBQWNpRSxrQkFBa0IsQ0FBQyxDQUFDLEVBQUVMLFFBQVEsSUFBSUs7UUFFM0QsTUFBTW1CLGdCQUNKZixRQUFRYixrQkFBa0I2QixNQUFNLENBQUNGLGdCQUFnQixLQUNqRDNCLGtCQUFrQjhCLGNBQWMsQ0FBQ0MsUUFBUSxDQUFDSjtRQUU1QyxNQUFNSyxnQkFBZ0JoQyxrQkFBa0JpQyxhQUFhLENBQUN0RCxRQUFRO1FBRTlELElBQUlxRCxlQUFlO1lBQ2pCLElBQUlBLGNBQWNFLFFBQVEsS0FBSyxTQUFTLENBQUNOLGVBQWU7Z0JBQ3RELE1BQU0sa1BBQUl2RixrQkFBQUE7WUFDWjtZQUVBLElBQ0UsT0FBTzJGLGNBQWNFLFFBQVEsS0FBSyxZQUNsQyxDQUFDTixpQkFDRCxDQUFDTixtQkFDRDtnQkFDQUQsZ0JBQWdCO1lBQ2xCO1FBQ0Y7SUFDRjtJQUVBLHlFQUF5RTtJQUN6RSx3RUFBd0U7SUFDeEUsMEJBQTBCO0lBQzFCLElBQ0dBLG1OQUFpQjlFLFFBQUFBLEVBQU1nQyxJQUFJNEQsT0FBTyxDQUFDLGFBQWEsSUFBSSxxS0FDckQ5RyxpQkFBQUEsRUFBZWtELEtBQUssZ0JBQ3BCO1FBQ0E4QyxnQkFBZ0I7SUFDbEI7SUFFQSxNQUFNZSxTQUFTbkgsaUxBQUFBO0lBQ2YsTUFBTW9ILGFBQWFELE9BQU9FLGtCQUFrQjtJQUU1QyxJQUFJO1FBQ0YsTUFBTUMsU0FBU2hFLElBQUlnRSxNQUFNLElBQUk7UUFFN0IsTUFBTUMsb01BQWNySCxZQUFBQSxFQUFVO1lBQzVCc0MsVUFBVStDLFdBQVdpQyxhQUFhLEdBQzlCL0MsVUFBVWpDLFFBQVEsdU1BQ2xCaEIsc0JBQUFBLEVBQW9CaUQsVUFBVWpDLFFBQVEsSUFBSTtZQUM5Qyx1REFBdUQ7WUFDdkQrQixPQUFPc0IsaUJBQWlCLENBQUMsSUFBSW5CO1FBQy9CO1FBRUEsTUFBTStDLHNCQUNKbkMsQ0FBQUEsdUJBQUFBLE9BQUFBLEtBQUFBLElBQUFBLG9CQUFxQm1DLG1CQUFtQixLQUFJbEMsV0FBV2tDLG1CQUFtQjtRQUU1RSxNQUFNQyxpQkFBaUIsT0FBT0M7WUFDNUIsTUFBTUMsb0JBQXVDLE9BQU8sRUFDbERDLGtCQUFrQixFQUNuQjtvQkF3UkdBO2dCQXZSRixNQUFNQyxXQUFXO29CQUNmLElBQUk7NEJBMERtQnZDLGtCQU1LQSw4QkFzRGxCQTt3QkFySFIsT0FBTyxNQUFNcEQsWUFDVjRGLE1BQU0sQ0FBQ3pFLEtBQUtDLEtBQUs7NEJBQ2hCZ0IsT0FDRXNCLGtCQUFrQixDQUFDSix3QkFDZDtnQ0FDQyxHQUFHakIsTUFBTTtnQ0FDVCxHQUFJeUIsUUFDQTtvQ0FDRUMsS0FBSzNCLE1BQU0yQixHQUFHO2dDQUNoQixJQUNBLENBQUMsQ0FBQzs0QkFDUixJQUNBO2dDQUNFLEdBQUczQixLQUFLO2dDQUNSLEdBQUdDLE1BQU07NEJBQ1g7NEJBQ05BOzRCQUNBakMsTUFBTW1COzRCQUNOc0UsZUFBZTtnQ0FDYmhEO2dDQUNBaUQsWUFBWTdCO2dDQUNaOEIsNkxBQStCOUgsaUJBQUFBLEVBQzdCa0QsS0FDQTs0QkFFSjs0QkFDQTZFLGVBQWU7Z0NBQ2I3RDtnQ0FDQThELGNBQ0V4QyxRQUFRTix1QkFBQUEsT0FBQUEsS0FBQUEsSUFBQUEsb0JBQXFCK0MsY0FBYyxLQUFLQztnQ0FDbERDLFlBQUFBLEVBQWMzRixRQUFRQyxHQUFHLENBQUMyRixrQkFBa0I7NEJBQzlDOzRCQUNBQyxZQUFZO2dDQUNWakU7Z0NBQ0FyQztnQ0FDQUksTUFBTW1CO2dDQUNOZ0YsWUFBWTlHLFVBQVUsQ0FBQztnQ0FDdkIrRyw2TEFBV3RJLGlCQUFBQSxFQUFlTztnQ0FDMUJnSSxjQUFjaEk7Z0NBQ2RhO2dDQUNBQztnQ0FDQUM7Z0NBQ0FrSCx5QkFBeUIsQ0FBQ2hEO2dDQUMxQmpCO2dDQUNBQztnQ0FDQUM7Z0NBRUFnRSxhQUFhdkQsV0FBV3VELFdBQVc7Z0NBQ25DQyxnQkFDRXhELFdBQVdHLFlBQVksQ0FBQ3FELGNBQWMsSUFBSTtnQ0FDNUNDLGNBQWNqRSxrQkFBa0JrRSxPQUFPO2dDQUN2Q0MsUUFBUTNELFdBQVcyRCxNQUFNO2dDQUN6QkMsa0JBQWtCNUQsV0FBVzZELE1BQU07Z0NBQ25DQyxhQUFhekQsUUFBUUwsV0FBV0csWUFBWSxDQUFDMkQsV0FBVztnQ0FDeERDLG1CQUFtQjFELFFBQ2pCTCxXQUFXRyxZQUFZLENBQUM0RCxpQkFBaUI7Z0NBRTNDQyxhQUFhLEVBQUEsQ0FBRWhFLG1CQUFBQSxXQUFXaUUsSUFBSSxLQUFBLE9BQUEsS0FBQSxJQUFmakUsaUJBQWlCa0UsT0FBTztnQ0FDdkNDLGFBQWFuRSxXQUFXbUUsV0FBVztnQ0FFbkM3RjtnQ0FDQThGLFVBQVVwRSxXQUFXb0UsUUFBUTtnQ0FDN0JDLGVBQWVyRSxXQUFXVyxHQUFHLENBQUMwRCxhQUFhLElBQUk7Z0NBQy9DQyxrQkFBa0IsRUFBQSxDQUFFdEUsK0JBQUFBLFdBQVdHLFlBQVksQ0FBQ1EsR0FBRyxLQUFBLE9BQUEsS0FBQSxJQUEzQlgsNkJBQTZCdUUsU0FBUztnQ0FDMURDLHlCQUNFeEUsV0FBV0csWUFBWSxDQUFDcUUsdUJBQXVCO2dDQUNqREMsb0JBQ0V6RSxXQUFXRyxZQUFZLENBQUNzRSxrQkFBa0I7Z0NBQzVDLG1FQUFtRTtnQ0FDbkUsZ0VBQWdFO2dDQUNoRUMsZUFDRUMsT0FBT0MsSUFBSSxDQUFDMUMscUJBQXFCMkMsTUFBTSxHQUFHLElBQ3RDM0Msc0JBQ0FhO2dDQUVON0M7Z0NBRUFDLGNBQWM7b0NBQ1oyRSxxQkFDRTlFLFdBQVdHLFlBQVksQ0FBQzJFLG1CQUFtQixJQUMxQyxFQUFFO2dDQUNQO2dDQUVBbEY7Z0NBQ0FDO2dDQUNBQztnQ0FDQWlGLFlBQVksRUFBRWhGLHVCQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxvQkFBcUJnRixZQUFZO2dDQUUvQ2pFLG1CQUNFQSxxQkFBc0JWLENBQUFBLGtCQUFrQkUsY0FBYTtnQ0FFdkQwQjtnQ0FDQSx1RkFBdUY7Z0NBQ3ZGLDhEQUE4RDtnQ0FDOUQsU0FBUztnQ0FDVGdELGdCQUNFNUUsa0JBQWtCSSwyTUFDZDdGLFlBQUFBLEVBQVU7b0NBQ1IsaUVBQWlFO29DQUNqRSxVQUFVO29DQUNWc0MsVUFBVTZELG9CQUNOOUYsbU5BQUFBLEVBQWtCb0Usb0JBQ2xCQTtvQ0FDSkosT0FBT0c7Z0NBQ1QsS0FDQTZDO2dDQUVOdEM7Z0NBRUF1RixZQUFZcEssK0tBQUFBLEVBQWVrRCxLQUFLO2dDQUNoQ21ILG1LQUFLckssaUJBQUFBLEVBQWVrRCxLQUFLO2dDQUN6Qm9ILEtBQUt2SSxZQUFZc0UsS0FBSztnQ0FFdEIsOENBQThDO2dDQUM5QzlELFNBQVMsR0FBR1IsWUFBWVksVUFBVSxDQUFDLENBQUMsRUFBRVosWUFBWVEsT0FBTyxFQUFFO2dDQUUzRGdJLGlCQUFpQixFQUFBLENBQ2ZwRixnQ0FBQUEsV0FBV0csWUFBWSxDQUFDUSxHQUFHLEtBQUEsT0FBQSxLQUFBLElBQTNCWCw4QkFBNkJxRixjQUFjO2dDQUM3Q0MsNEtBQWN6SyxpQkFBQUEsRUFBZWtELEtBQUs7NEJBQ3BDO3dCQUNGLEdBQ0N3SCxJQUFJLENBQUMsQ0FBQ0M7NEJBQ0wsTUFBTSxFQUFFQyxRQUFRLEVBQUUsR0FBR0Q7NEJBRXJCLElBQUlFLGVBQ0ZELFNBQVNDLFlBQVk7NEJBRXZCLElBQUksZ0JBQWdCRCxZQUFZQSxTQUFTRSxVQUFVLEVBQUU7Z0NBQ25ELE9BQU87b0NBQ0xDLE9BQU87b0NBQ1BGO2dDQUNGOzRCQUNGOzRCQUVBLHVCQUF1Qjs0QkFDdkIsSUFBSUQsU0FBU0ksVUFBVSxFQUFFO2dDQUN2QixPQUFPO29DQUNMRCxPQUFPO3dDQUNMOUksMktBQU03QixrQkFBQUEsQ0FBZ0I2SyxRQUFRO3dDQUM5QkMsT0FBT04sU0FBU08sUUFBUSxJQUFJUCxTQUFTUSxVQUFVO29DQUNqRDtvQ0FDQVA7Z0NBQ0Y7NEJBQ0Y7NEJBRUEsT0FBTztnQ0FDTEUsT0FBTztvQ0FDTDlJLDJLQUFNN0Isa0JBQUFBLENBQWdCOEIsS0FBSztvQ0FDM0JtSixNQUFNVjtvQ0FDTlEsVUFBVVIsYUFBYUMsUUFBUSxDQUFDTyxRQUFRO29DQUN4Q3JFLFNBQVM2RCxhQUFhQyxRQUFRLENBQUM5RCxPQUFPO29DQUN0Q3dFLFFBQVFYLGFBQWFDLFFBQVEsQ0FBQy9HLFVBQVU7Z0NBQzFDO2dDQUNBZ0g7NEJBQ0Y7d0JBQ0YsR0FDQ1UsT0FBTyxDQUFDOzRCQUNQLElBQUksQ0FBQ2hFLE1BQU07NEJBRVhBLEtBQUtpRSxhQUFhLENBQUM7Z0NBQ2pCLG9CQUFvQnJJLElBQUlVLFVBQVU7Z0NBQ2xDLFlBQVk7NEJBQ2Q7NEJBRUEsTUFBTTRILHFCQUFxQjFFLE9BQU8yRSxxQkFBcUI7NEJBQ3ZELGlFQUFpRTs0QkFDakUsSUFBSSxDQUFDRCxvQkFBb0I7Z0NBQ3ZCOzRCQUNGOzRCQUVBLElBQ0VBLG1CQUFtQkUsR0FBRyxDQUFDLDBMQUN2QmhNLGlCQUFBQSxDQUFlaU0sYUFBYSxFQUM1QjtnQ0FDQUMsUUFBUUMsSUFBSSxDQUNWLENBQUMsMkJBQTJCLEVBQUVMLG1CQUFtQkUsR0FBRyxDQUNsRCxrQkFDQSxxRUFBcUUsQ0FBQztnQ0FFMUU7NEJBQ0Y7NEJBRUEsTUFBTUksUUFBUU4sbUJBQW1CRSxHQUFHLENBQUM7NEJBQ3JDLElBQUlJLE9BQU87Z0NBQ1QsTUFBTUMsT0FBTyxHQUFHOUUsT0FBTyxDQUFDLEVBQUU2RSxPQUFPO2dDQUVqQ3hFLEtBQUtpRSxhQUFhLENBQUM7b0NBQ2pCLGNBQWNPO29DQUNkLGNBQWNBO29DQUNkLGtCQUFrQkM7Z0NBQ3BCO2dDQUNBekUsS0FBSzBFLFVBQVUsQ0FBQ0Q7NEJBQ2xCLE9BQU87Z0NBQ0x6RSxLQUFLMEUsVUFBVSxDQUFDLEdBQUcvRSxPQUFPLENBQUMsRUFBRWhFLElBQUlnSixHQUFHLEVBQUU7NEJBQ3hDO3dCQUNGO29CQUNKLEVBQUUsT0FBTzdCLEtBQWM7d0JBQ3JCLHVEQUF1RDt3QkFDdkQsZ0RBQWdEO3dCQUNoRCxJQUFJNUMsc0JBQUFBLE9BQUFBLEtBQUFBLElBQUFBLG1CQUFvQjBFLE9BQU8sRUFBRTs0QkFDL0IsTUFBTXBLLFlBQVlxSyxjQUFjLENBQzlCbEosS0FDQW1ILEtBQ0E7Z0NBQ0VnQyxZQUFZO2dDQUNaQyxXQUFXaEo7Z0NBQ1hpSixXQUFXO2dDQUNYQyx5TEFBa0J0TSxzQkFBQUEsRUFBb0I7b0NBQ3BDdU0sY0FBY2hIO29DQUNkWjtnQ0FDRjs0QkFDRixHQUNBSzt3QkFFSjt3QkFDQSxNQUFNbUY7b0JBQ1I7Z0JBQ0Y7Z0JBRUEsb0RBQW9EO2dCQUNwRCxxQkFBcUI7Z0JBQ3JCLElBQUk1QyxvQkFBb0I7b0JBQ3RCekIsZ0JBQWdCO2dCQUNsQjtnQkFFQSxJQUFJQSxlQUFlO29CQUNqQixNQUFNMEcsbUJBQW1CLE1BQU0zSyxZQUFZNEssZ0JBQWdCLENBQUN6SixLQUFLeUksR0FBRyxDQUNsRTVKLFlBQVlzRSxLQUFLLEdBQ2IsT0FDQXRCLFNBQ0UsQ0FBQyxDQUFDLEVBQUVBLFNBQVN6QixTQUFTLEdBQ3RCQSxTQUNOLE9BQU8sRUFDTG1FLG9CQUFvQm1GLDZCQUE2QixJQUFJLEVBQ3REO3dCQUNDLElBQUksQ0FBQzdLLFlBQVlzRSxLQUFLLEVBQUU7NEJBQ3RCLGdMQUFPdEYsdUJBQUFBLEVBQXFCNkw7d0JBQzlCO3dCQUNBLE9BQU9sRjtvQkFDVCxHQUNBO3dCQUNFbUYsbUtBQVduTixZQUFBQSxDQUFVd0MsS0FBSzt3QkFDMUIyRixZQUFZO3dCQUNaaUYsbUJBQW1CO3dCQUNuQmpJLHNCQUFzQjt3QkFDdEJrSSxrQkFBa0IsTUFBTWhMLFlBQVlpTCxtQkFBbUIsQ0FDckQ5SixLQUNBaUMsWUFDQVI7d0JBRUZaLFdBQVdYLElBQUlXLFNBQVM7b0JBQzFCO29CQUVGLElBQUkySSxrQkFBa0I7d0JBQ3BCLHNFQUFzRTt3QkFDdEUsaUNBQWlDO3dCQUNqQyxPQUFPQSxpQkFBaUI3QixZQUFZO3dCQUNwQzZCLGlCQUFpQk8sTUFBTSxHQUFHO3dCQUMxQixPQUFPUDtvQkFDVDtnQkFDRjtnQkFFQSxJQUNFLCtKQUFDMU0saUJBQUFBLEVBQWVrRCxLQUFLLGtCQUNyQjJCLHdCQUNBQywyQkFDQSxDQUFDMkMsb0JBQ0Q7b0JBQ0F0RSxJQUFJVSxVQUFVLEdBQUc7b0JBQ2pCLCtDQUErQztvQkFDL0NWLElBQUkrSixTQUFTLENBQUMsa0JBQWtCO29CQUNoQy9KLElBQUlXLEdBQUcsQ0FBQztvQkFDUixPQUFPO2dCQUNUO2dCQUVBLElBQ0VrQyxpQkFDQXlCLENBQUFBLHNCQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxDQUFBQSw0QkFBQUEsbUJBQW9Cc0QsS0FBSyxLQUFBLE9BQUEsS0FBQSxJQUF6QnRELDBCQUEyQnhGLElBQUksMktBQUs3QixrQkFBQUEsQ0FBZ0I4QixLQUFLLEVBQ3pEO29CQUNBLE9BQU87d0JBQ0w2SSxPQUFPOzRCQUNMOUksMktBQU03QixrQkFBQUEsQ0FBZ0I4QixLQUFLOzRCQUMzQm1KLE1BQU0sK0pBQUl2SyxVQUFBQSxDQUNScU0sT0FBT0MsSUFBSSxDQUFDM0YsbUJBQW1Cc0QsS0FBSyxDQUFDTSxJQUFJLEdBQ3pDO2dDQUNFZ0MsYUFBYTtnQ0FDYnpDLFVBQVU7b0NBQ1IvRyxZQUFZNEQsbUJBQW1Cc0QsS0FBSyxDQUFDTyxNQUFNO29DQUMzQ3hFLFNBQVNXLG1CQUFtQnNELEtBQUssQ0FBQ2pFLE9BQU87Z0NBQzNDOzRCQUNGOzRCQUVGcUUsVUFBVSxDQUFDOzRCQUNYRyxRQUFRN0QsbUJBQW1Cc0QsS0FBSyxDQUFDTyxNQUFNOzRCQUN2Q3hFLFNBQVNXLG1CQUFtQnNELEtBQUssQ0FBQ2pFLE9BQU87d0JBQzNDO3dCQUNBK0QsY0FBYzs0QkFBRXlDLFlBQVk7NEJBQUdDLFFBQVFyRjt3QkFBVTtvQkFDbkQ7Z0JBQ0Y7Z0JBQ0EsT0FBT1I7WUFDVDtZQUVBLE1BQU04RixTQUFTLE1BQU16TCxZQUFZdUYsY0FBYyxDQUFDO2dCQUM5Q3ZCO2dCQUNBN0M7Z0JBQ0FpQztnQkFDQTBILG1LQUFXbk4sWUFBQUEsQ0FBVXdDLEtBQUs7Z0JBQzFCMkM7Z0JBQ0FDO2dCQUNBZixXQUFXWCxJQUFJVyxTQUFTO2dCQUN4QnlELG1CQUFtQkE7Z0JBQ25CN0M7WUFDRjtZQUVBLG9EQUFvRDtZQUNwRCx1REFBdUQ7WUFDdkQscUJBQXFCO1lBQ3JCLElBQUlxQixpQkFBaUIsQ0FBQSxDQUFDd0gsVUFBQUEsT0FBQUEsS0FBQUEsSUFBQUEsT0FBUVAsTUFBTSxHQUFFO2dCQUNwQ2pILGdCQUFnQjtZQUNsQjtZQUVBLHlDQUF5QztZQUN6QyxJQUFJLENBQUN3SCxRQUFRO2dCQUNYO1lBQ0Y7WUFFQSxJQUFJL0gsa0JBQWtCLCtKQUFDekYsaUJBQUFBLEVBQWVrRCxLQUFLLGdCQUFnQjtnQkFDekRDLElBQUkrSixTQUFTLENBQ1gsa0JBQ0FySSx1QkFDSSxnQkFDQTJJLE9BQU9QLE1BQU0sR0FDWCxTQUNBTyxPQUFPckIsT0FBTyxHQUNaLFVBQ0E7WUFFWjtZQUVBLElBQUl0QjtZQUVKLElBQUksQ0FBQ3BGLGtCQUFrQk8sZUFBZTtnQkFDcEMsSUFBSSxDQUFDN0MsSUFBSXNLLFNBQVMsQ0FBQyxrQkFBa0I7b0JBQ25DNUMsZUFBZTt3QkFBRXlDLFlBQVk7d0JBQUdDLFFBQVFyRjtvQkFBVTtnQkFDcEQ7WUFDRixPQUFPLElBQUloQyxXQUFXO2dCQUNwQixNQUFNd0gsbUxBQXFCMU4saUJBQUFBLEVBQWVrRCxLQUFLO2dCQUUvQzJILGVBQWU7b0JBQ2J5QyxZQUNFLE9BQU9JLHVCQUF1QixjQUFjLElBQUlBO29CQUNsREgsUUFBUXJGO2dCQUNWO1lBQ0YsT0FBTyxJQUFJL0IsV0FBVztnQkFDcEIwRSxlQUFlO29CQUFFeUMsWUFBWTtvQkFBR0MsUUFBUXJGO2dCQUFVO1lBQ3BELE9BQU8sSUFBSXNGLE9BQU8zQyxZQUFZLEVBQUU7Z0JBQzlCLHdFQUF3RTtnQkFDeEUsb0JBQW9CO2dCQUNwQixJQUFJLE9BQU8yQyxPQUFPM0MsWUFBWSxDQUFDeUMsVUFBVSxLQUFLLFVBQVU7d0JBUTVDRTtvQkFQVixJQUFJQSxPQUFPM0MsWUFBWSxDQUFDeUMsVUFBVSxHQUFHLEdBQUc7d0JBQ3RDLE1BQU0sT0FBQSxjQUVMLENBRkssSUFBSUssTUFDUixDQUFDLDJDQUEyQyxFQUFFSCxPQUFPM0MsWUFBWSxDQUFDeUMsVUFBVSxDQUFDLElBQUksQ0FBQyxHQUQ5RSxxQkFBQTttQ0FBQTt3Q0FBQTswQ0FBQTt3QkFFTjtvQkFDRjtvQkFDQXpDLGVBQWU7d0JBQ2J5QyxZQUFZRSxPQUFPM0MsWUFBWSxDQUFDeUMsVUFBVTt3QkFDMUNDLFFBQVFDLENBQUFBLENBQUFBLHVCQUFBQSxPQUFPM0MsWUFBWSxLQUFBLE9BQUEsS0FBQSxJQUFuQjJDLHFCQUFxQkQsTUFBTSxLQUFJcEksV0FBV3lJLFVBQVU7b0JBQzlEO2dCQUNGLE9BQU87b0JBQ0wsb0JBQW9CO29CQUNwQi9DLGVBQWU7d0JBQ2J5Qyw2SkFBWTFNLGlCQUFBQTt3QkFDWjJNLFFBQVFyRjtvQkFDVjtnQkFDRjtZQUNGO1lBRUEsMkRBQTJEO1lBQzNELDZEQUE2RDtZQUM3RCxJQUFJMkMsZ0JBQWdCLENBQUMxSCxJQUFJc0ssU0FBUyxDQUFDLGtCQUFrQjtnQkFDbkR0SyxJQUFJK0osU0FBUyxDQUFDLHVMQUFpQnpNLHdCQUFBQSxFQUFzQm9LO1lBQ3ZEO1lBRUEsc0JBQXNCO1lBQ3RCLElBQUksQ0FBQzJDLE9BQU96QyxLQUFLLEVBQUU7b0JBUWZ5QztnQkFQRixvREFBb0Q7Z0JBQ3BELHFEQUFxRDtnQkFDckQsNERBQTREO2dCQUM1RCwyQkFBMkI7OEtBQzNCek4saUJBQUFBLEVBQ0VtRCxLQUNBLHNCQUFBLENBQ0FzSyx3QkFBQUEsT0FBTzNDLFlBQVksS0FBQSxPQUFBLEtBQUEsSUFBbkIyQyxzQkFBcUJGLFVBQVU7Z0JBR2pDbkssSUFBSVUsVUFBVSxHQUFHO2dCQUVqQixJQUFJb0MsbUJBQW1CO29CQUNyQjlDLElBQUlXLEdBQUcsQ0FBQztvQkFDUjtnQkFDRjtnQkFDQSw0REFBNEQ7Z0JBQzVELElBQUlvQix1QkFBQUEsT0FBQUEsS0FBQUEsSUFBQUEsb0JBQXFCMkksU0FBUyxFQUFFO29CQUNsQyxNQUFNM0ksb0JBQW9CMkksU0FBUyxDQUFDM0ssS0FBS0MsS0FBS2tCLFdBQVc7Z0JBQzNELE9BQU87b0JBQ0xsQixJQUFJVyxHQUFHLENBQUM7Z0JBQ1Y7Z0JBQ0E7WUFDRjtZQUVBLElBQUkwSixPQUFPekMsS0FBSyxDQUFDOUksSUFBSSxLQUFLN0IsdUxBQUFBLENBQWdCNkssUUFBUSxFQUFFO2dCQUNsRCxJQUFJaEYsbUJBQW1CO29CQUNyQjlDLElBQUkrSixTQUFTLENBQUMsZ0JBQWdCO29CQUM5Qi9KLElBQUlXLEdBQUcsQ0FBQ2dLLEtBQUtDLFNBQVMsQ0FBQ1AsT0FBT3pDLEtBQUssQ0FBQ0csS0FBSztvQkFDekM7Z0JBQ0YsT0FBTztvQkFDTCxNQUFNOEMsaUJBQWlCLENBQUM3Qzt3QkFDdEIsTUFBTThDLFdBQVc7NEJBQ2ZDLGFBQWEvQyxTQUFTZ0QsU0FBUyxDQUFDQyxZQUFZOzRCQUM1Q3ZLLFlBQVlzSCxTQUFTZ0QsU0FBUyxDQUFDRSxtQkFBbUI7NEJBQ2xEOUUsVUFBVTRCLFNBQVNnRCxTQUFTLENBQUNHLHNCQUFzQjt3QkFDckQ7d0JBQ0EsTUFBTXpLLDJLQUFhbEQsb0JBQUFBLEVBQWtCc047d0JBQ3JDLE1BQU0sRUFBRTFFLFFBQVEsRUFBRSxHQUFHcEU7d0JBRXJCLElBQ0VvRSxZQUNBMEUsU0FBUzFFLFFBQVEsS0FBSyxTQUN0QjBFLFNBQVNDLFdBQVcsQ0FBQ0ssVUFBVSxDQUFDLE1BQ2hDOzRCQUNBTixTQUFTQyxXQUFXLEdBQUcsR0FBRzNFLFdBQVcwRSxTQUFTQyxXQUFXLEVBQUU7d0JBQzdEO3dCQUVBLElBQUlELFNBQVNDLFdBQVcsQ0FBQ0ssVUFBVSxDQUFDLE1BQU07NEJBQ3hDTixTQUFTQyxXQUFXLDhKQUFHeE4sMkJBQUFBLEVBQ3JCdU4sU0FBU0MsV0FBVzt3QkFFeEI7d0JBRUEvSyxJQUFJVSxVQUFVLEdBQUdBO3dCQUNqQlYsSUFBSStKLFNBQVMsQ0FBQyxZQUFZZSxTQUFTQyxXQUFXO3dCQUM5QyxJQUFJckssa01BQWU1QyxxQkFBQUEsQ0FBbUJ1TixpQkFBaUIsRUFBRTs0QkFDdkRyTCxJQUFJK0osU0FBUyxDQUFDLFdBQVcsQ0FBQyxNQUFNLEVBQUVlLFNBQVNDLFdBQVcsRUFBRTt3QkFDMUQ7d0JBQ0EvSyxJQUFJVyxHQUFHLENBQUNtSyxTQUFTQyxXQUFXO29CQUM5QjtvQkFDQSxNQUFNRixlQUFlUixPQUFPekMsS0FBSyxDQUFDRyxLQUFLO29CQUN2QyxPQUFPO2dCQUNUO1lBQ0Y7WUFFQSxJQUFJc0MsT0FBT3pDLEtBQUssQ0FBQzlJLElBQUksMEtBQUs3QixrQkFBQUEsQ0FBZ0I4QixLQUFLLEVBQUU7Z0JBQy9DLE1BQU0sT0FBQSxjQUVMLENBRkssSUFBSXlMLE1BQ1IsQ0FBQywwREFBMEQsQ0FBQyxHQUR4RCxxQkFBQTsyQkFBQTtnQ0FBQTtrQ0FBQTtnQkFFTjtZQUNGO1lBRUEsb0RBQW9EO1lBQ3BELElBQUk1TCxZQUFZc0UsS0FBSyxFQUFFO2dCQUNyQmxELElBQUkrSixTQUFTLENBQUMsaUJBQWlCO1lBQ2pDO1lBRUEsb0NBQW9DO1lBQ3BDLElBQUl0SSxhQUFhO2dCQUNmekIsSUFBSStKLFNBQVMsQ0FDWCxpQkFDQTtZQUVKO1lBRUEsMERBQTBEO1lBQzFELDJCQUEyQjtZQUMzQixLQUNFbE4sOEtBQUFBLEVBQWVrRCxLQUFLLHdCQUNuQmtELDZLQUNDcEcsaUJBQUFBLEVBQWVrRCxLQUFLLGtCQUNwQkMsSUFBSVUsVUFBVSxLQUFLLEtBQ3JCO2dCQUNBLE9BQU87WUFDVDtZQUVBLFVBQU1oRCw2S0FBQUEsRUFBaUI7Z0JBQ3JCcUM7Z0JBQ0FDO2dCQUNBLDZEQUE2RDtnQkFDN0QsVUFBVTtnQkFDVnFLLFFBQ0V2SCxxQkFBcUIsQ0FBQ0csZUFBZSxDQUFDRCxZQUNsQywrSkFBSXJGLFVBQUFBLENBQ0ZxTSxPQUFPQyxJQUFJLENBQUNVLEtBQUtDLFNBQVMsQ0FBQ1AsT0FBT3pDLEtBQUssQ0FBQ0ksUUFBUSxJQUNoRDtvQkFDRWtDLGFBQWE7b0JBQ2J6QyxVQUFVNEMsT0FBT3pDLEtBQUssQ0FBQ00sSUFBSSxDQUFDVCxRQUFRO2dCQUN0QyxLQUVGNEMsT0FBT3pDLEtBQUssQ0FBQ00sSUFBSTtnQkFDdkJvRCxlQUFldEosV0FBV3NKLGFBQWE7Z0JBQ3ZDQyxpQkFBaUJ2SixXQUFXdUosZUFBZTtnQkFDM0M3RCxjQUFjOUksWUFBWXNFLEtBQUssR0FBRzZCLFlBQVkyQztnQkFDOUM4RCxNQUFNMUksb0JBQW9CLFNBQVM7WUFDckM7UUFDRjtRQUVBLG9EQUFvRDtRQUNwRCx5REFBeUQ7UUFDekQsSUFBSWUsWUFBWTtZQUNkLE1BQU1NO1FBQ1IsT0FBTztZQUNMLE1BQU1QLE9BQU82SCxxQkFBcUIsQ0FBQzFMLElBQUk0RCxPQUFPLEVBQUUsSUFDOUNDLE9BQU84SCxLQUFLLHFLQUNWbFAsaUJBQUFBLENBQWVpTSxhQUFhLEVBQzVCO29CQUNFa0QsVUFBVSxHQUFHNUgsT0FBTyxDQUFDLEVBQUVoRSxJQUFJZ0osR0FBRyxFQUFFO29CQUNoQ2pLLHVLQUFNcEMsV0FBQUEsQ0FBU2tQLE1BQU07b0JBQ3JCQyxZQUFZO3dCQUNWLGVBQWU5SDt3QkFDZixlQUFlaEUsSUFBSWdKLEdBQUc7b0JBQ3hCO2dCQUNGLEdBQ0E1RTtRQUdOO0lBQ0YsRUFBRSxPQUFPK0MsS0FBSztRQUNaLE1BQU10SSxZQUFZcUssY0FBYyxDQUM5QmxKLEtBQ0FtSCxLQUNBO1lBQ0VnQyxZQUFZO1lBQ1pDLFdBQVdoSjtZQUNYaUosV0FBVztZQUNYQyx5TEFBa0J0TSxzQkFBQUEsRUFBb0I7Z0JBQ3BDdU0sY0FBY2hIO2dCQUNkWjtZQUNGO1FBQ0YsR0FDQUs7UUFHRixtREFBbUQ7UUFDbkQsTUFBTW1GO0lBQ1I7QUFDRiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19XQp9