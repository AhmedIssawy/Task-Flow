module.exports = {

"[project]/node_modules/next/dist/esm/server/route-kind.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "RouteKind": ()=>RouteKind
});
var RouteKind = /*#__PURE__*/ function(RouteKind) {
    /**
   * `PAGES` represents all the React pages that are under `pages/`.
   */ RouteKind["PAGES"] = "PAGES";
    /**
   * `PAGES_API` represents all the API routes under `pages/api/`.
   */ RouteKind["PAGES_API"] = "PAGES_API";
    /**
   * `APP_PAGE` represents all the React pages that are under `app/` with the
   * filename of `page.{j,t}s{,x}`.
   */ RouteKind["APP_PAGE"] = "APP_PAGE";
    /**
   * `APP_ROUTE` represents all the API routes and metadata routes that are under `app/` with the
   * filename of `route.{j,t}s{,x}`.
   */ RouteKind["APP_ROUTE"] = "APP_ROUTE";
    /**
   * `IMAGE` represents all the images that are generated by `next/image`.
   */ RouteKind["IMAGE"] = "IMAGE";
    return RouteKind;
}({}); //# sourceMappingURL=route-kind.js.map
}),
"[project]/node_modules/next/dist/server/route-modules/app-page/module.compiled.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
else {
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    else {
        if ("TURBOPACK compile-time truthy", 1) {
            if ("TURBOPACK compile-time truthy", 1) {
                module.exports = __turbopack_context__.r("[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)");
            } else //TURBOPACK unreachable
            ;
        } else //TURBOPACK unreachable
        ;
    }
} //# sourceMappingURL=module.compiled.js.map
}}),
"[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-server-dom-turbopack-server.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/module.compiled.js [app-rsc] (ecmascript)").vendored['react-rsc'].ReactServerDOMTurbopackServer; //# sourceMappingURL=react-server-dom-turbopack-server.js.map
}}),
"[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-server-dom-turbopack-static.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/module.compiled.js [app-rsc] (ecmascript)").vendored['react-rsc'].ReactServerDOMTurbopackStatic; //# sourceMappingURL=react-server-dom-turbopack-static.js.map
}}),
"[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/module.compiled.js [app-rsc] (ecmascript)").vendored['react-rsc'].React; //# sourceMappingURL=react.js.map
}}),
"[project]/node_modules/next/dist/esm/client/components/layout-router.js [app-rsc] (client reference proxy) <module evaluation>": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const { createClientModuleProxy } = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-server-dom-turbopack-server.js [app-rsc] (ecmascript)");
__turbopack_context__.n(createClientModuleProxy("[project]/node_modules/next/dist/esm/client/components/layout-router.js <module evaluation>"));
}}),
"[project]/node_modules/next/dist/esm/client/components/layout-router.js [app-rsc] (client reference proxy)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const { createClientModuleProxy } = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-server-dom-turbopack-server.js [app-rsc] (ecmascript)");
__turbopack_context__.n(createClientModuleProxy("[project]/node_modules/next/dist/esm/client/components/layout-router.js"));
}}),
"[project]/node_modules/next/dist/esm/client/components/layout-router.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$layout$2d$router$2e$js__$5b$app$2d$rsc$5d$__$28$client__reference__proxy$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/client/components/layout-router.js [app-rsc] (client reference proxy) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$layout$2d$router$2e$js__$5b$app$2d$rsc$5d$__$28$client__reference__proxy$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/client/components/layout-router.js [app-rsc] (client reference proxy)");
;
__turbopack_context__.n(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$layout$2d$router$2e$js__$5b$app$2d$rsc$5d$__$28$client__reference__proxy$29$__);
}),
"[project]/node_modules/next/dist/esm/client/components/render-from-template-context.js [app-rsc] (client reference proxy) <module evaluation>": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const { createClientModuleProxy } = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-server-dom-turbopack-server.js [app-rsc] (ecmascript)");
__turbopack_context__.n(createClientModuleProxy("[project]/node_modules/next/dist/esm/client/components/render-from-template-context.js <module evaluation>"));
}}),
"[project]/node_modules/next/dist/esm/client/components/render-from-template-context.js [app-rsc] (client reference proxy)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const { createClientModuleProxy } = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-server-dom-turbopack-server.js [app-rsc] (ecmascript)");
__turbopack_context__.n(createClientModuleProxy("[project]/node_modules/next/dist/esm/client/components/render-from-template-context.js"));
}}),
"[project]/node_modules/next/dist/esm/client/components/render-from-template-context.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$render$2d$from$2d$template$2d$context$2e$js__$5b$app$2d$rsc$5d$__$28$client__reference__proxy$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/client/components/render-from-template-context.js [app-rsc] (client reference proxy) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$render$2d$from$2d$template$2d$context$2e$js__$5b$app$2d$rsc$5d$__$28$client__reference__proxy$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/client/components/render-from-template-context.js [app-rsc] (client reference proxy)");
;
__turbopack_context__.n(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$render$2d$from$2d$template$2d$context$2e$js__$5b$app$2d$rsc$5d$__$28$client__reference__proxy$29$__);
}),
"[project]/node_modules/next/dist/esm/client/components/client-page.js [app-rsc] (client reference proxy) <module evaluation>": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const { createClientModuleProxy } = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-server-dom-turbopack-server.js [app-rsc] (ecmascript)");
__turbopack_context__.n(createClientModuleProxy("[project]/node_modules/next/dist/esm/client/components/client-page.js <module evaluation>"));
}}),
"[project]/node_modules/next/dist/esm/client/components/client-page.js [app-rsc] (client reference proxy)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const { createClientModuleProxy } = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-server-dom-turbopack-server.js [app-rsc] (ecmascript)");
__turbopack_context__.n(createClientModuleProxy("[project]/node_modules/next/dist/esm/client/components/client-page.js"));
}}),
"[project]/node_modules/next/dist/esm/client/components/client-page.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$client$2d$page$2e$js__$5b$app$2d$rsc$5d$__$28$client__reference__proxy$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/client/components/client-page.js [app-rsc] (client reference proxy) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$client$2d$page$2e$js__$5b$app$2d$rsc$5d$__$28$client__reference__proxy$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/client/components/client-page.js [app-rsc] (client reference proxy)");
;
__turbopack_context__.n(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$client$2d$page$2e$js__$5b$app$2d$rsc$5d$__$28$client__reference__proxy$29$__);
}),
"[project]/node_modules/next/dist/esm/client/components/client-segment.js [app-rsc] (client reference proxy) <module evaluation>": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const { createClientModuleProxy } = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-server-dom-turbopack-server.js [app-rsc] (ecmascript)");
__turbopack_context__.n(createClientModuleProxy("[project]/node_modules/next/dist/esm/client/components/client-segment.js <module evaluation>"));
}}),
"[project]/node_modules/next/dist/esm/client/components/client-segment.js [app-rsc] (client reference proxy)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const { createClientModuleProxy } = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-server-dom-turbopack-server.js [app-rsc] (ecmascript)");
__turbopack_context__.n(createClientModuleProxy("[project]/node_modules/next/dist/esm/client/components/client-segment.js"));
}}),
"[project]/node_modules/next/dist/esm/client/components/client-segment.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$client$2d$segment$2e$js__$5b$app$2d$rsc$5d$__$28$client__reference__proxy$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/client/components/client-segment.js [app-rsc] (client reference proxy) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$client$2d$segment$2e$js__$5b$app$2d$rsc$5d$__$28$client__reference__proxy$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/client/components/client-segment.js [app-rsc] (client reference proxy)");
;
__turbopack_context__.n(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$client$2d$segment$2e$js__$5b$app$2d$rsc$5d$__$28$client__reference__proxy$29$__);
}),
"[project]/node_modules/next/dist/esm/server/web/spec-extension/adapters/reflect.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "ReflectAdapter": ()=>ReflectAdapter
});
class ReflectAdapter {
    static get(target, prop, receiver) {
        const value = Reflect.get(target, prop, receiver);
        if (typeof value === 'function') {
            return value.bind(target);
        }
        return value;
    }
    static set(target, prop, value, receiver) {
        return Reflect.set(target, prop, value, receiver);
    }
    static has(target, prop) {
        return Reflect.has(target, prop);
    }
    static deleteProperty(target, prop) {
        return Reflect.deleteProperty(target, prop);
    }
} //# sourceMappingURL=reflect.js.map
}),
"[project]/node_modules/next/dist/esm/client/components/hooks-server-context.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "DynamicServerError": ()=>DynamicServerError,
    "isDynamicServerError": ()=>isDynamicServerError
});
const DYNAMIC_ERROR_CODE = 'DYNAMIC_SERVER_USAGE';
class DynamicServerError extends Error {
    constructor(description){
        super("Dynamic server usage: " + description), this.description = description, this.digest = DYNAMIC_ERROR_CODE;
    }
}
function isDynamicServerError(err) {
    if (typeof err !== 'object' || err === null || !('digest' in err) || typeof err.digest !== 'string') {
        return false;
    }
    return err.digest === DYNAMIC_ERROR_CODE;
} //# sourceMappingURL=hooks-server-context.js.map
}),
"[project]/node_modules/next/dist/esm/client/components/static-generation-bailout.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "StaticGenBailoutError": ()=>StaticGenBailoutError,
    "isStaticGenBailoutError": ()=>isStaticGenBailoutError
});
const NEXT_STATIC_GEN_BAILOUT = 'NEXT_STATIC_GEN_BAILOUT';
class StaticGenBailoutError extends Error {
    constructor(...args){
        super(...args), this.code = NEXT_STATIC_GEN_BAILOUT;
    }
}
function isStaticGenBailoutError(error) {
    if (typeof error !== 'object' || error === null || !('code' in error)) {
        return false;
    }
    return error.code === NEXT_STATIC_GEN_BAILOUT;
} //# sourceMappingURL=static-generation-bailout.js.map
}),
"[project]/node_modules/next/dist/esm/server/dynamic-rendering-utils.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "isHangingPromiseRejectionError": ()=>isHangingPromiseRejectionError,
    "makeHangingPromise": ()=>makeHangingPromise
});
function isHangingPromiseRejectionError(err) {
    if (typeof err !== 'object' || err === null || !('digest' in err)) {
        return false;
    }
    return err.digest === HANGING_PROMISE_REJECTION;
}
const HANGING_PROMISE_REJECTION = 'HANGING_PROMISE_REJECTION';
class HangingPromiseRejectionError extends Error {
    constructor(expression){
        super(`During prerendering, ${expression} rejects when the prerender is complete. Typically these errors are handled by React but if you move ${expression} to a different context by using \`setTimeout\`, \`after\`, or similar functions you may observe this error and you should handle it in that context.`), this.expression = expression, this.digest = HANGING_PROMISE_REJECTION;
    }
}
const abortListenersBySignal = new WeakMap();
function makeHangingPromise(signal, expression) {
    if (signal.aborted) {
        return Promise.reject(new HangingPromiseRejectionError(expression));
    } else {
        const hangingPromise = new Promise((_, reject)=>{
            const boundRejection = reject.bind(null, new HangingPromiseRejectionError(expression));
            let currentListeners = abortListenersBySignal.get(signal);
            if (currentListeners) {
                currentListeners.push(boundRejection);
            } else {
                const listeners = [
                    boundRejection
                ];
                abortListenersBySignal.set(signal, listeners);
                signal.addEventListener('abort', ()=>{
                    for(let i = 0; i < listeners.length; i++){
                        listeners[i]();
                    }
                }, {
                    once: true
                });
            }
        });
        // We are fine if no one actually awaits this promise. We shouldn't consider this an unhandled rejection so
        // we attach a noop catch handler here to suppress this warning. If you actually await somewhere or construct
        // your own promise out of it you'll need to ensure you handle the error when it rejects.
        hangingPromise.catch(ignoreReject);
        return hangingPromise;
    }
}
function ignoreReject() {} //# sourceMappingURL=dynamic-rendering-utils.js.map
}),
"[project]/node_modules/next/dist/esm/lib/metadata/metadata-constants.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "METADATA_BOUNDARY_NAME": ()=>METADATA_BOUNDARY_NAME,
    "OUTLET_BOUNDARY_NAME": ()=>OUTLET_BOUNDARY_NAME,
    "VIEWPORT_BOUNDARY_NAME": ()=>VIEWPORT_BOUNDARY_NAME
});
const METADATA_BOUNDARY_NAME = '__next_metadata_boundary__';
const VIEWPORT_BOUNDARY_NAME = '__next_viewport_boundary__';
const OUTLET_BOUNDARY_NAME = '__next_outlet_boundary__'; //# sourceMappingURL=metadata-constants.js.map
}),
"[project]/node_modules/next/dist/esm/lib/scheduler.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * Schedules a function to be called on the next tick after the other promises
 * have been resolved.
 *
 * @param cb the function to schedule
 */ __turbopack_context__.s({
    "atLeastOneTask": ()=>atLeastOneTask,
    "scheduleImmediate": ()=>scheduleImmediate,
    "scheduleOnNextTick": ()=>scheduleOnNextTick,
    "waitAtLeastOneReactRenderTask": ()=>waitAtLeastOneReactRenderTask
});
const scheduleOnNextTick = (cb)=>{
    // We use Promise.resolve().then() here so that the operation is scheduled at
    // the end of the promise job queue, we then add it to the next process tick
    // to ensure it's evaluated afterwards.
    //
    // This was inspired by the implementation of the DataLoader interface: https://github.com/graphql/dataloader/blob/d336bd15282664e0be4b4a657cb796f09bafbc6b/src/index.js#L213-L255
    //
    Promise.resolve().then(()=>{
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        else {
            process.nextTick(cb);
        }
    });
};
const scheduleImmediate = (cb)=>{
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    else {
        setImmediate(cb);
    }
};
function atLeastOneTask() {
    return new Promise((resolve)=>scheduleImmediate(resolve));
}
function waitAtLeastOneReactRenderTask() {
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    else {
        return new Promise((r)=>setImmediate(r));
    }
} //# sourceMappingURL=scheduler.js.map
}),
"[project]/node_modules/next/dist/esm/server/app-render/dynamic-rendering.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * The functions provided by this module are used to communicate certain properties
 * about the currently running code so that Next.js can make decisions on how to handle
 * the current execution in different rendering modes such as pre-rendering, resuming, and SSR.
 *
 * Today Next.js treats all code as potentially static. Certain APIs may only make sense when dynamically rendering.
 * Traditionally this meant deopting the entire render to dynamic however with PPR we can now deopt parts
 * of a React tree as dynamic while still keeping other parts static. There are really two different kinds of
 * Dynamic indications.
 *
 * The first is simply an intention to be dynamic. unstable_noStore is an example of this where
 * the currently executing code simply declares that the current scope is dynamic but if you use it
 * inside unstable_cache it can still be cached. This type of indication can be removed if we ever
 * make the default dynamic to begin with because the only way you would ever be static is inside
 * a cache scope which this indication does not affect.
 *
 * The second is an indication that a dynamic data source was read. This is a stronger form of dynamic
 * because it means that it is inappropriate to cache this at all. using a dynamic data source inside
 * unstable_cache should error. If you want to use some dynamic data inside unstable_cache you should
 * read that data outside the cache and pass it in as an argument to the cached function.
 */ // Once postpone is in stable we should switch to importing the postpone export directly
__turbopack_context__.s({
    "Postpone": ()=>Postpone,
    "PreludeState": ()=>PreludeState,
    "abortAndThrowOnSynchronousRequestDataAccess": ()=>abortAndThrowOnSynchronousRequestDataAccess,
    "abortOnSynchronousPlatformIOAccess": ()=>abortOnSynchronousPlatformIOAccess,
    "accessedDynamicData": ()=>accessedDynamicData,
    "annotateDynamicAccess": ()=>annotateDynamicAccess,
    "consumeDynamicAccess": ()=>consumeDynamicAccess,
    "createDynamicTrackingState": ()=>createDynamicTrackingState,
    "createDynamicValidationState": ()=>createDynamicValidationState,
    "createHangingInputAbortSignal": ()=>createHangingInputAbortSignal,
    "createPostponedAbortSignal": ()=>createPostponedAbortSignal,
    "formatDynamicAPIAccesses": ()=>formatDynamicAPIAccesses,
    "getFirstDynamicReason": ()=>getFirstDynamicReason,
    "isDynamicPostpone": ()=>isDynamicPostpone,
    "isPrerenderInterruptedError": ()=>isPrerenderInterruptedError,
    "markCurrentScopeAsDynamic": ()=>markCurrentScopeAsDynamic,
    "postponeWithTracking": ()=>postponeWithTracking,
    "throwIfDisallowedDynamic": ()=>throwIfDisallowedDynamic,
    "throwToInterruptStaticGeneration": ()=>throwToInterruptStaticGeneration,
    "trackAllowedDynamicAccess": ()=>trackAllowedDynamicAccess,
    "trackDynamicDataInDynamicRender": ()=>trackDynamicDataInDynamicRender,
    "trackFallbackParamAccessed": ()=>trackFallbackParamAccessed,
    "trackSynchronousPlatformIOAccessInDev": ()=>trackSynchronousPlatformIOAccessInDev,
    "trackSynchronousRequestDataAccessInDev": ()=>trackSynchronousRequestDataAccessInDev,
    "useDynamicRouteParams": ()=>useDynamicRouteParams
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$hooks$2d$server$2d$context$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/client/components/hooks-server-context.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$static$2d$generation$2d$bailout$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/client/components/static-generation-bailout.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$unit$2d$async$2d$storage$2e$external$2e$js__$5b$external$5d$__$28$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$unit$2d$async$2d$storage$2e$external$2e$js$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$async$2d$storage$2e$external$2e$js__$5b$external$5d$__$28$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$async$2d$storage$2e$external$2e$js$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$dynamic$2d$rendering$2d$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/dynamic-rendering-utils.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$metadata$2d$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/metadata/metadata-constants.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$scheduler$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/scheduler.js [app-rsc] (ecmascript)");
;
;
;
;
;
;
;
;
const hasPostpone = typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"].unstable_postpone === 'function';
function createDynamicTrackingState(isDebugDynamicAccesses) {
    return {
        isDebugDynamicAccesses,
        dynamicAccesses: [],
        syncDynamicErrorWithStack: null
    };
}
function createDynamicValidationState() {
    return {
        hasSuspenseAboveBody: false,
        hasDynamicMetadata: false,
        hasDynamicViewport: false,
        hasAllowedDynamic: false,
        dynamicErrors: []
    };
}
function getFirstDynamicReason(trackingState) {
    var _trackingState_dynamicAccesses_;
    return (_trackingState_dynamicAccesses_ = trackingState.dynamicAccesses[0]) == null ? void 0 : _trackingState_dynamicAccesses_.expression;
}
function markCurrentScopeAsDynamic(store, workUnitStore, expression) {
    if (workUnitStore) {
        if (workUnitStore.type === 'cache' || workUnitStore.type === 'unstable-cache') {
            // inside cache scopes marking a scope as dynamic has no effect because the outer cache scope
            // creates a cache boundary. This is subtly different from reading a dynamic data source which is
            // forbidden inside a cache scope.
            return;
        }
    }
    // If we're forcing dynamic rendering or we're forcing static rendering, we
    // don't need to do anything here because the entire page is already dynamic
    // or it's static and it should not throw or postpone here.
    if (store.forceDynamic || store.forceStatic) return;
    if (store.dynamicShouldError) {
        throw Object.defineProperty(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$static$2d$generation$2d$bailout$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["StaticGenBailoutError"](`Route ${store.route} with \`dynamic = "error"\` couldn't be rendered statically because it used \`${expression}\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`), "__NEXT_ERROR_CODE", {
            value: "E553",
            enumerable: false,
            configurable: true
        });
    }
    if (workUnitStore) {
        if (workUnitStore.type === 'prerender-ppr') {
            postponeWithTracking(store.route, expression, workUnitStore.dynamicTracking);
        } else if (workUnitStore.type === 'prerender-legacy') {
            workUnitStore.revalidate = 0;
            // We aren't prerendering but we are generating a static page. We need to bail out of static generation
            const err = Object.defineProperty(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$hooks$2d$server$2d$context$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["DynamicServerError"](`Route ${store.route} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`), "__NEXT_ERROR_CODE", {
                value: "E550",
                enumerable: false,
                configurable: true
            });
            store.dynamicUsageDescription = expression;
            store.dynamicUsageStack = err.stack;
            throw err;
        } else if (("TURBOPACK compile-time value", "development") === 'development' && workUnitStore && workUnitStore.type === 'request') {
            workUnitStore.usedDynamic = true;
        }
    }
}
function trackFallbackParamAccessed(store, expression) {
    const prerenderStore = __TURBOPACK__imported__module__$5b$externals$5d2f$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$unit$2d$async$2d$storage$2e$external$2e$js__$5b$external$5d$__$28$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$unit$2d$async$2d$storage$2e$external$2e$js$2c$__cjs$29$__["workUnitAsyncStorage"].getStore();
    if (!prerenderStore || prerenderStore.type !== 'prerender-ppr') return;
    postponeWithTracking(store.route, expression, prerenderStore.dynamicTracking);
}
function throwToInterruptStaticGeneration(expression, store, prerenderStore) {
    // We aren't prerendering but we are generating a static page. We need to bail out of static generation
    const err = Object.defineProperty(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$hooks$2d$server$2d$context$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["DynamicServerError"](`Route ${store.route} couldn't be rendered statically because it used \`${expression}\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`), "__NEXT_ERROR_CODE", {
        value: "E558",
        enumerable: false,
        configurable: true
    });
    prerenderStore.revalidate = 0;
    store.dynamicUsageDescription = expression;
    store.dynamicUsageStack = err.stack;
    throw err;
}
function trackDynamicDataInDynamicRender(_store, workUnitStore) {
    if (workUnitStore) {
        if (workUnitStore.type === 'cache' || workUnitStore.type === 'unstable-cache') {
            // inside cache scopes marking a scope as dynamic has no effect because the outer cache scope
            // creates a cache boundary. This is subtly different from reading a dynamic data source which is
            // forbidden inside a cache scope.
            return;
        }
        // TODO: it makes no sense to have these work unit store types during a dev render.
        if (workUnitStore.type === 'prerender' || workUnitStore.type === 'prerender-client' || workUnitStore.type === 'prerender-legacy') {
            workUnitStore.revalidate = 0;
        }
        if (("TURBOPACK compile-time value", "development") === 'development' && workUnitStore.type === 'request') {
            workUnitStore.usedDynamic = true;
        }
    }
}
function abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore) {
    const reason = `Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`;
    const error = createPrerenderInterruptedError(reason);
    prerenderStore.controller.abort(error);
    const dynamicTracking = prerenderStore.dynamicTracking;
    if (dynamicTracking) {
        dynamicTracking.dynamicAccesses.push({
            // When we aren't debugging, we don't need to create another error for the
            // stack trace.
            stack: dynamicTracking.isDebugDynamicAccesses ? new Error().stack : undefined,
            expression
        });
    }
}
function abortOnSynchronousPlatformIOAccess(route, expression, errorWithStack, prerenderStore) {
    const dynamicTracking = prerenderStore.dynamicTracking;
    abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore);
    // It is important that we set this tracking value after aborting. Aborts are executed
    // synchronously except for the case where you abort during render itself. By setting this
    // value late we can use it to determine if any of the aborted tasks are the task that
    // called the sync IO expression in the first place.
    if (dynamicTracking) {
        if (dynamicTracking.syncDynamicErrorWithStack === null) {
            dynamicTracking.syncDynamicErrorWithStack = errorWithStack;
        }
    }
}
function trackSynchronousPlatformIOAccessInDev(requestStore) {
    // We don't actually have a controller to abort but we do the semantic equivalent by
    // advancing the request store out of prerender mode
    requestStore.prerenderPhase = false;
}
function abortAndThrowOnSynchronousRequestDataAccess(route, expression, errorWithStack, prerenderStore) {
    const prerenderSignal = prerenderStore.controller.signal;
    if (prerenderSignal.aborted === false) {
        // TODO it would be better to move this aborted check into the callsite so we can avoid making
        // the error object when it isn't relevant to the aborting of the prerender however
        // since we need the throw semantics regardless of whether we abort it is easier to land
        // this way. See how this was handled with `abortOnSynchronousPlatformIOAccess` for a closer
        // to ideal implementation
        abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore);
        // It is important that we set this tracking value after aborting. Aborts are executed
        // synchronously except for the case where you abort during render itself. By setting this
        // value late we can use it to determine if any of the aborted tasks are the task that
        // called the sync IO expression in the first place.
        const dynamicTracking = prerenderStore.dynamicTracking;
        if (dynamicTracking) {
            if (dynamicTracking.syncDynamicErrorWithStack === null) {
                dynamicTracking.syncDynamicErrorWithStack = errorWithStack;
            }
        }
    }
    throw createPrerenderInterruptedError(`Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`);
}
const trackSynchronousRequestDataAccessInDev = trackSynchronousPlatformIOAccessInDev;
function Postpone({ reason, route }) {
    const prerenderStore = __TURBOPACK__imported__module__$5b$externals$5d2f$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$unit$2d$async$2d$storage$2e$external$2e$js__$5b$external$5d$__$28$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$unit$2d$async$2d$storage$2e$external$2e$js$2c$__cjs$29$__["workUnitAsyncStorage"].getStore();
    const dynamicTracking = prerenderStore && prerenderStore.type === 'prerender-ppr' ? prerenderStore.dynamicTracking : null;
    postponeWithTracking(route, reason, dynamicTracking);
}
function postponeWithTracking(route, expression, dynamicTracking) {
    assertPostpone();
    if (dynamicTracking) {
        dynamicTracking.dynamicAccesses.push({
            // When we aren't debugging, we don't need to create another error for the
            // stack trace.
            stack: dynamicTracking.isDebugDynamicAccesses ? new Error().stack : undefined,
            expression
        });
    }
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"].unstable_postpone(createPostponeReason(route, expression));
}
function createPostponeReason(route, expression) {
    return `Route ${route} needs to bail out of prerendering at this point because it used ${expression}. ` + `React throws this special object to indicate where. It should not be caught by ` + `your own try/catch. Learn more: https://nextjs.org/docs/messages/ppr-caught-error`;
}
function isDynamicPostpone(err) {
    if (typeof err === 'object' && err !== null && typeof err.message === 'string') {
        return isDynamicPostponeReason(err.message);
    }
    return false;
}
function isDynamicPostponeReason(reason) {
    return reason.includes('needs to bail out of prerendering at this point because it used') && reason.includes('Learn more: https://nextjs.org/docs/messages/ppr-caught-error');
}
if (isDynamicPostponeReason(createPostponeReason('%%%', '^^^')) === false) {
    throw Object.defineProperty(new Error('Invariant: isDynamicPostpone misidentified a postpone reason. This is a bug in Next.js'), "__NEXT_ERROR_CODE", {
        value: "E296",
        enumerable: false,
        configurable: true
    });
}
const NEXT_PRERENDER_INTERRUPTED = 'NEXT_PRERENDER_INTERRUPTED';
function createPrerenderInterruptedError(message) {
    const error = Object.defineProperty(new Error(message), "__NEXT_ERROR_CODE", {
        value: "E394",
        enumerable: false,
        configurable: true
    });
    error.digest = NEXT_PRERENDER_INTERRUPTED;
    return error;
}
function isPrerenderInterruptedError(error) {
    return typeof error === 'object' && error !== null && error.digest === NEXT_PRERENDER_INTERRUPTED && 'name' in error && 'message' in error && error instanceof Error;
}
function accessedDynamicData(dynamicAccesses) {
    return dynamicAccesses.length > 0;
}
function consumeDynamicAccess(serverDynamic, clientDynamic) {
    // We mutate because we only call this once we are no longer writing
    // to the dynamicTrackingState and it's more efficient than creating a new
    // array.
    serverDynamic.dynamicAccesses.push(...clientDynamic.dynamicAccesses);
    return serverDynamic.dynamicAccesses;
}
function formatDynamicAPIAccesses(dynamicAccesses) {
    return dynamicAccesses.filter((access)=>typeof access.stack === 'string' && access.stack.length > 0).map(({ expression, stack })=>{
        stack = stack.split('\n') // Remove the "Error: " prefix from the first line of the stack trace as
        // well as the first 4 lines of the stack trace which is the distance
        // from the user code and the `new Error().stack` call.
        .slice(4).filter((line)=>{
            // Exclude Next.js internals from the stack trace.
            if (line.includes('node_modules/next/')) {
                return false;
            }
            // Exclude anonymous functions from the stack trace.
            if (line.includes(' (<anonymous>)')) {
                return false;
            }
            // Exclude Node.js internals from the stack trace.
            if (line.includes(' (node:')) {
                return false;
            }
            return true;
        }).join('\n');
        return `Dynamic API Usage Debug - ${expression}:\n${stack}`;
    });
}
function assertPostpone() {
    if (!hasPostpone) {
        throw Object.defineProperty(new Error(`Invariant: React.unstable_postpone is not defined. This suggests the wrong version of React was loaded. This is a bug in Next.js`), "__NEXT_ERROR_CODE", {
            value: "E224",
            enumerable: false,
            configurable: true
        });
    }
}
function createPostponedAbortSignal(reason) {
    assertPostpone();
    const controller = new AbortController();
    // We get our hands on a postpone instance by calling postpone and catching the throw
    try {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"].unstable_postpone(reason);
    } catch (x) {
        controller.abort(x);
    }
    return controller.signal;
}
function createHangingInputAbortSignal(workUnitStore) {
    const controller = new AbortController();
    if (workUnitStore.cacheSignal) {
        // If we have a cacheSignal it means we're in a prospective render. If the input
        // we're waiting on is coming from another cache, we do want to wait for it so that
        // we can resolve this cache entry too.
        workUnitStore.cacheSignal.inputReady().then(()=>{
            controller.abort();
        });
    } else {
        // Otherwise we're in the final render and we should already have all our caches
        // filled. We might still be waiting on some microtasks so we wait one tick before
        // giving up. When we give up, we still want to render the content of this cache
        // as deeply as we can so that we can suspend as deeply as possible in the tree
        // or not at all if we don't end up waiting for the input.
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$scheduler$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["scheduleOnNextTick"])(()=>controller.abort());
    }
    return controller.signal;
}
function annotateDynamicAccess(expression, prerenderStore) {
    const dynamicTracking = prerenderStore.dynamicTracking;
    if (dynamicTracking) {
        dynamicTracking.dynamicAccesses.push({
            stack: dynamicTracking.isDebugDynamicAccesses ? new Error().stack : undefined,
            expression
        });
    }
}
function useDynamicRouteParams(expression) {
    const workStore = __TURBOPACK__imported__module__$5b$externals$5d2f$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$async$2d$storage$2e$external$2e$js__$5b$external$5d$__$28$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$async$2d$storage$2e$external$2e$js$2c$__cjs$29$__["workAsyncStorage"].getStore();
    if (workStore && workStore.isStaticGeneration && workStore.fallbackRouteParams && workStore.fallbackRouteParams.size > 0) {
        // There are fallback route params, we should track these as dynamic
        // accesses.
        const workUnitStore = __TURBOPACK__imported__module__$5b$externals$5d2f$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$unit$2d$async$2d$storage$2e$external$2e$js__$5b$external$5d$__$28$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$unit$2d$async$2d$storage$2e$external$2e$js$2c$__cjs$29$__["workUnitAsyncStorage"].getStore();
        if (workUnitStore) {
            // We're prerendering with dynamicIO or PPR or both
            if (workUnitStore.type === 'prerender-client') {
                // We are in a prerender with dynamicIO semantics
                // We are going to hang here and never resolve. This will cause the currently
                // rendering component to effectively be a dynamic hole
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"].use((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$dynamic$2d$rendering$2d$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["makeHangingPromise"])(workUnitStore.renderSignal, expression));
            } else if (workUnitStore.type === 'prerender-ppr') {
                // We're prerendering with PPR
                postponeWithTracking(workStore.route, expression, workUnitStore.dynamicTracking);
            } else if (workUnitStore.type === 'prerender-legacy') {
                throwToInterruptStaticGeneration(expression, workStore, workUnitStore);
            }
        }
    }
}
const hasSuspenseRegex = /\n\s+at Suspense \(<anonymous>\)/;
const hasSuspenseAfterBodyOrHtmlRegex = /\n\s+at (?:body|html) \(<anonymous>\)[\s\S]*?\n\s+at Suspense \(<anonymous>\)/;
const hasMetadataRegex = new RegExp(`\\n\\s+at ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$metadata$2d$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["METADATA_BOUNDARY_NAME"]}[\\n\\s]`);
const hasViewportRegex = new RegExp(`\\n\\s+at ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$metadata$2d$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["VIEWPORT_BOUNDARY_NAME"]}[\\n\\s]`);
const hasOutletRegex = new RegExp(`\\n\\s+at ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$metadata$2d$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["OUTLET_BOUNDARY_NAME"]}[\\n\\s]`);
function trackAllowedDynamicAccess(workStore, componentStack, dynamicValidation, clientDynamic) {
    if (hasOutletRegex.test(componentStack)) {
        // We don't need to track that this is dynamic. It is only so when something else is also dynamic.
        return;
    } else if (hasMetadataRegex.test(componentStack)) {
        dynamicValidation.hasDynamicMetadata = true;
        return;
    } else if (hasViewportRegex.test(componentStack)) {
        dynamicValidation.hasDynamicViewport = true;
        return;
    } else if (hasSuspenseAfterBodyOrHtmlRegex.test(componentStack)) {
        // This prerender has a Suspense boundary above the body which
        // effectively opts the page into allowing 100% dynamic rendering
        dynamicValidation.hasAllowedDynamic = true;
        dynamicValidation.hasSuspenseAboveBody = true;
        return;
    } else if (hasSuspenseRegex.test(componentStack)) {
        // this error had a Suspense boundary above it so we don't need to report it as a source
        // of disallowed
        dynamicValidation.hasAllowedDynamic = true;
        return;
    } else if (clientDynamic.syncDynamicErrorWithStack) {
        // This task was the task that called the sync error.
        dynamicValidation.dynamicErrors.push(clientDynamic.syncDynamicErrorWithStack);
        return;
    } else {
        const message = `Route "${workStore.route}": A component accessed data, headers, params, searchParams, or a short-lived cache without a Suspense boundary nor a "use cache" above it. See more info: https://nextjs.org/docs/messages/next-prerender-missing-suspense`;
        const error = createErrorWithComponentOrOwnerStack(message, componentStack);
        dynamicValidation.dynamicErrors.push(error);
        return;
    }
}
/**
 * In dev mode, we prefer using the owner stack, otherwise the provided
 * component stack is used.
 */ function createErrorWithComponentOrOwnerStack(message, componentStack) {
    const ownerStack = ("TURBOPACK compile-time value", "development") !== 'production' && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"].captureOwnerStack ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"].captureOwnerStack() : null;
    const error = Object.defineProperty(new Error(message), "__NEXT_ERROR_CODE", {
        value: "E394",
        enumerable: false,
        configurable: true
    });
    error.stack = error.name + ': ' + message + (ownerStack ?? componentStack);
    return error;
}
var PreludeState = /*#__PURE__*/ function(PreludeState) {
    PreludeState[PreludeState["Full"] = 0] = "Full";
    PreludeState[PreludeState["Empty"] = 1] = "Empty";
    PreludeState[PreludeState["Errored"] = 2] = "Errored";
    return PreludeState;
}({});
function logDisallowedDynamicError(workStore, error) {
    console.error(error);
    if (!workStore.dev) {
        if (workStore.hasReadableErrorStacks) {
            console.error(`To get a more detailed stack trace and pinpoint the issue, start the app in development mode by running \`next dev\`, then open "${workStore.route}" in your browser to investigate the error.`);
        } else {
            console.error(`To get a more detailed stack trace and pinpoint the issue, try one of the following:
  - Start the app in development mode by running \`next dev\`, then open "${workStore.route}" in your browser to investigate the error.
  - Rerun the production build with \`next build --debug-prerender\` to generate better stack traces.`);
        }
    }
}
function throwIfDisallowedDynamic(workStore, prelude, dynamicValidation, serverDynamic) {
    if (workStore.invalidDynamicUsageError) {
        logDisallowedDynamicError(workStore, workStore.invalidDynamicUsageError);
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$static$2d$generation$2d$bailout$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["StaticGenBailoutError"]();
    }
    if (prelude !== 0) {
        if (dynamicValidation.hasSuspenseAboveBody) {
            // This route has opted into allowing fully dynamic rendering
            // by including a Suspense boundary above the body. In this case
            // a lack of a shell is not considered disallowed so we simply return
            return;
        }
        if (serverDynamic.syncDynamicErrorWithStack) {
            // There is no shell and the server did something sync dynamic likely
            // leading to an early termination of the prerender before the shell
            // could be completed. We terminate the build/validating render.
            logDisallowedDynamicError(workStore, serverDynamic.syncDynamicErrorWithStack);
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$static$2d$generation$2d$bailout$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["StaticGenBailoutError"]();
        }
        // We didn't have any sync bailouts but there may be user code which
        // blocked the root. We would have captured these during the prerender
        // and can log them here and then terminate the build/validating render
        const dynamicErrors = dynamicValidation.dynamicErrors;
        if (dynamicErrors.length > 0) {
            for(let i = 0; i < dynamicErrors.length; i++){
                logDisallowedDynamicError(workStore, dynamicErrors[i]);
            }
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$static$2d$generation$2d$bailout$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["StaticGenBailoutError"]();
        }
        // If we got this far then the only other thing that could be blocking
        // the root is dynamic Viewport. If this is dynamic then
        // you need to opt into that by adding a Suspense boundary above the body
        // to indicate your are ok with fully dynamic rendering.
        if (dynamicValidation.hasDynamicViewport) {
            console.error(`Route "${workStore.route}" has a \`generateViewport\` that depends on Request data (\`cookies()\`, etc...) or uncached external data (\`fetch(...)\`, etc...) without explicitly allowing fully dynamic rendering. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-viewport`);
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$static$2d$generation$2d$bailout$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["StaticGenBailoutError"]();
        }
        if (prelude === 1) {
            // If we ever get this far then we messed up the tracking of invalid dynamic.
            // We still adhere to the constraint that you must produce a shell but invite the
            // user to report this as a bug in Next.js.
            console.error(`Route "${workStore.route}" did not produce a static shell and Next.js was unable to determine a reason. This is a bug in Next.js.`);
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$static$2d$generation$2d$bailout$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["StaticGenBailoutError"]();
        }
    } else {
        if (dynamicValidation.hasAllowedDynamic === false && dynamicValidation.hasDynamicMetadata) {
            console.error(`Route "${workStore.route}" has a \`generateMetadata\` that depends on Request data (\`cookies()\`, etc...) or uncached external data (\`fetch(...)\`, etc...) when the rest of the route does not. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-metadata`);
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$static$2d$generation$2d$bailout$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["StaticGenBailoutError"]();
        }
    }
} //# sourceMappingURL=dynamic-rendering.js.map
}),
"[project]/node_modules/next/dist/esm/shared/lib/invariant-error.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "InvariantError": ()=>InvariantError
});
class InvariantError extends Error {
    constructor(message, options){
        super("Invariant: " + (message.endsWith('.') ? message : message + '.') + " This is a bug in Next.js.", options);
        this.name = 'InvariantError';
    }
} //# sourceMappingURL=invariant-error.js.map
}),
"[project]/node_modules/next/dist/esm/server/create-deduped-by-callsite-server-error-logger.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "createDedupedByCallsiteServerErrorLoggerDev": ()=>createDedupedByCallsiteServerErrorLoggerDev
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-rsc] (ecmascript)");
;
const errorRef = {
    current: null
};
// React.cache is currently only available in canary/experimental React channels.
const cache = typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["cache"] === 'function' ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["cache"] : (fn)=>fn;
// When Dynamic IO is enabled, we record these as errors so that they
// are captured by the dev overlay as it's more critical to fix these
// when enabled.
const logErrorOrWarn = ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : console.warn;
// We don't want to dedupe across requests.
// The developer might've just attempted to fix the warning so we should warn again if it still happens.
const flushCurrentErrorIfNew = cache((key)=>{
    try {
        logErrorOrWarn(errorRef.current);
    } finally{
        errorRef.current = null;
    }
});
function createDedupedByCallsiteServerErrorLoggerDev(getMessage) {
    return function logDedupedError(...args) {
        const message = getMessage(...args);
        if ("TURBOPACK compile-time truthy", 1) {
            var _stack;
            const callStackFrames = (_stack = new Error().stack) == null ? void 0 : _stack.split('\n');
            if (callStackFrames === undefined || callStackFrames.length < 4) {
                logErrorOrWarn(message);
            } else {
                // Error:
                //   logDedupedError
                //   asyncApiBeingAccessedSynchronously
                //   <userland callsite>
                // TODO: This breaks if sourcemaps with ignore lists are enabled.
                const key = callStackFrames[4];
                errorRef.current = message;
                flushCurrentErrorIfNew(key);
            }
        } else //TURBOPACK unreachable
        ;
    };
} //# sourceMappingURL=create-deduped-by-callsite-server-error-logger.js.map
}),
"[project]/node_modules/next/dist/esm/shared/lib/utils/reflect-utils.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// This regex will have fast negatives meaning valid identifiers may not pass
// this test. However this is only used during static generation to provide hints
// about why a page bailed out of some or all prerendering and we can use bracket notation
// for example while `_` is a valid identifier it's ok to print `searchParams['_']`
// even if this would have been fine too `searchParams._`
__turbopack_context__.s({
    "describeHasCheckingStringProperty": ()=>describeHasCheckingStringProperty,
    "describeStringPropertyAccess": ()=>describeStringPropertyAccess,
    "wellKnownProperties": ()=>wellKnownProperties
});
const isDefinitelyAValidIdentifier = /^[A-Za-z_$][A-Za-z0-9_$]*$/;
function describeStringPropertyAccess(target, prop) {
    if (isDefinitelyAValidIdentifier.test(prop)) {
        return "`" + target + "." + prop + "`";
    }
    return "`" + target + "[" + JSON.stringify(prop) + "]`";
}
function describeHasCheckingStringProperty(target, prop) {
    const stringifiedProp = JSON.stringify(prop);
    return "`Reflect.has(" + target + ", " + stringifiedProp + ")`, `" + stringifiedProp + " in " + target + "`, or similar";
}
const wellKnownProperties = new Set([
    'hasOwnProperty',
    'isPrototypeOf',
    'propertyIsEnumerable',
    'toString',
    'valueOf',
    'toLocaleString',
    // Promise prototype
    // fallthrough
    'then',
    'catch',
    'finally',
    // React Promise extension
    // fallthrough
    'status',
    // React introspection
    'displayName',
    '_debugInfo',
    // Common tested properties
    // fallthrough
    'toJSON',
    '$$typeof',
    '__esModule'
]); //# sourceMappingURL=reflect-utils.js.map
}),
"[project]/node_modules/next/dist/esm/server/request/utils.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "isRequestAPICallableInsideAfter": ()=>isRequestAPICallableInsideAfter,
    "throwForSearchParamsAccessInUseCache": ()=>throwForSearchParamsAccessInUseCache,
    "throwWithStaticGenerationBailoutError": ()=>throwWithStaticGenerationBailoutError,
    "throwWithStaticGenerationBailoutErrorWithDynamicError": ()=>throwWithStaticGenerationBailoutErrorWithDynamicError
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$static$2d$generation$2d$bailout$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/client/components/static-generation-bailout.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$next$2f$dist$2f$server$2f$app$2d$render$2f$after$2d$task$2d$async$2d$storage$2e$external$2e$js__$5b$external$5d$__$28$next$2f$dist$2f$server$2f$app$2d$render$2f$after$2d$task$2d$async$2d$storage$2e$external$2e$js$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)");
;
;
function throwWithStaticGenerationBailoutError(route, expression) {
    throw Object.defineProperty(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$static$2d$generation$2d$bailout$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["StaticGenBailoutError"](`Route ${route} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`), "__NEXT_ERROR_CODE", {
        value: "E576",
        enumerable: false,
        configurable: true
    });
}
function throwWithStaticGenerationBailoutErrorWithDynamicError(route, expression) {
    throw Object.defineProperty(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$static$2d$generation$2d$bailout$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["StaticGenBailoutError"](`Route ${route} with \`dynamic = "error"\` couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`), "__NEXT_ERROR_CODE", {
        value: "E543",
        enumerable: false,
        configurable: true
    });
}
function throwForSearchParamsAccessInUseCache(workStore, constructorOpt) {
    const error = Object.defineProperty(new Error(`Route ${workStore.route} used "searchParams" inside "use cache". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use "searchParams" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`), "__NEXT_ERROR_CODE", {
        value: "E634",
        enumerable: false,
        configurable: true
    });
    Error.captureStackTrace(error, constructorOpt);
    workStore.invalidDynamicUsageError ??= error;
    throw error;
}
function isRequestAPICallableInsideAfter() {
    const afterTaskStore = __TURBOPACK__imported__module__$5b$externals$5d2f$next$2f$dist$2f$server$2f$app$2d$render$2f$after$2d$task$2d$async$2d$storage$2e$external$2e$js__$5b$external$5d$__$28$next$2f$dist$2f$server$2f$app$2d$render$2f$after$2d$task$2d$async$2d$storage$2e$external$2e$js$2c$__cjs$29$__["afterTaskAsyncStorage"].getStore();
    return (afterTaskStore == null ? void 0 : afterTaskStore.rootTaskSpawnPhase) === 'action';
} //# sourceMappingURL=utils.js.map
}),
"[project]/node_modules/next/dist/esm/server/request/search-params.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "createPrerenderSearchParamsForClientPage": ()=>createPrerenderSearchParamsForClientPage,
    "createSearchParamsFromClient": ()=>createSearchParamsFromClient,
    "createServerSearchParamsForMetadata": ()=>createServerSearchParamsForMetadata,
    "createServerSearchParamsForServerPage": ()=>createServerSearchParamsForServerPage,
    "makeErroringExoticSearchParamsForUseCache": ()=>makeErroringExoticSearchParamsForUseCache
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$spec$2d$extension$2f$adapters$2f$reflect$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/web/spec-extension/adapters/reflect.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$dynamic$2d$rendering$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/app-render/dynamic-rendering.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$unit$2d$async$2d$storage$2e$external$2e$js__$5b$external$5d$__$28$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$unit$2d$async$2d$storage$2e$external$2e$js$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$invariant$2d$error$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/invariant-error.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$dynamic$2d$rendering$2d$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/dynamic-rendering-utils.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$create$2d$deduped$2d$by$2d$callsite$2d$server$2d$error$2d$logger$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/create-deduped-by-callsite-server-error-logger.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$utils$2f$reflect$2d$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/utils/reflect-utils.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/request/utils.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$scheduler$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/scheduler.js [app-rsc] (ecmascript)");
;
;
;
;
;
;
;
;
;
function createSearchParamsFromClient(underlyingSearchParams, workStore) {
    const workUnitStore = __TURBOPACK__imported__module__$5b$externals$5d2f$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$unit$2d$async$2d$storage$2e$external$2e$js__$5b$external$5d$__$28$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$unit$2d$async$2d$storage$2e$external$2e$js$2c$__cjs$29$__["workUnitAsyncStorage"].getStore();
    if (workUnitStore) {
        switch(workUnitStore.type){
            case 'prerender':
            case 'prerender-client':
            case 'prerender-ppr':
            case 'prerender-legacy':
                return createPrerenderSearchParams(workStore, workUnitStore);
            default:
        }
    }
    return createRenderSearchParams(underlyingSearchParams, workStore);
}
const createServerSearchParamsForMetadata = createServerSearchParamsForServerPage;
function createServerSearchParamsForServerPage(underlyingSearchParams, workStore) {
    const workUnitStore = __TURBOPACK__imported__module__$5b$externals$5d2f$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$unit$2d$async$2d$storage$2e$external$2e$js__$5b$external$5d$__$28$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$unit$2d$async$2d$storage$2e$external$2e$js$2c$__cjs$29$__["workUnitAsyncStorage"].getStore();
    if (workUnitStore) {
        switch(workUnitStore.type){
            case 'prerender':
            case 'prerender-client':
            case 'prerender-ppr':
            case 'prerender-legacy':
                return createPrerenderSearchParams(workStore, workUnitStore);
            default:
        }
    }
    return createRenderSearchParams(underlyingSearchParams, workStore);
}
function createPrerenderSearchParamsForClientPage(workStore) {
    if (workStore.forceStatic) {
        // When using forceStatic we override all other logic and always just return an empty
        // dictionary object.
        return Promise.resolve({});
    }
    const prerenderStore = __TURBOPACK__imported__module__$5b$externals$5d2f$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$unit$2d$async$2d$storage$2e$external$2e$js__$5b$external$5d$__$28$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$unit$2d$async$2d$storage$2e$external$2e$js$2c$__cjs$29$__["workUnitAsyncStorage"].getStore();
    if (prerenderStore && (prerenderStore.type === 'prerender' || prerenderStore.type === 'prerender-client')) {
        // dynamicIO Prerender
        // We're prerendering in a mode that aborts (dynamicIO) and should stall
        // the promise to ensure the RSC side is considered dynamic
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$dynamic$2d$rendering$2d$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["makeHangingPromise"])(prerenderStore.renderSignal, '`searchParams`');
    }
    // We're prerendering in a mode that does not aborts. We resolve the promise without
    // any tracking because we're just transporting a value from server to client where the tracking
    // will be applied.
    return Promise.resolve({});
}
function createPrerenderSearchParams(workStore, prerenderStore) {
    if (workStore.forceStatic) {
        // When using forceStatic we override all other logic and always just return an empty
        // dictionary object.
        return Promise.resolve({});
    }
    switch(prerenderStore.type){
        case 'prerender':
        case 'prerender-client':
            // We are in a dynamicIO (PPR or otherwise) prerender
            return makeHangingSearchParams(prerenderStore);
        default:
            // The remaining cases are prerender-ppr and prerender-legacy
            // We are in a legacy static generation and need to interrupt the prerender
            // when search params are accessed.
            return makeErroringExoticSearchParams(workStore, prerenderStore);
    }
}
function createRenderSearchParams(underlyingSearchParams, workStore) {
    if (workStore.forceStatic) {
        // When using forceStatic we override all other logic and always just return an empty
        // dictionary object.
        return Promise.resolve({});
    } else {
        if (("TURBOPACK compile-time value", "development") === 'development' && !workStore.isPrefetchRequest) {
            if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
            ;
            return makeDynamicallyTrackedExoticSearchParamsWithDevWarnings(underlyingSearchParams, workStore);
        } else {
            if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
            ;
            return makeUntrackedExoticSearchParams(underlyingSearchParams, workStore);
        }
    }
}
const CachedSearchParams = new WeakMap();
const CachedSearchParamsForUseCache = new WeakMap();
function makeHangingSearchParams(prerenderStore) {
    const cachedSearchParams = CachedSearchParams.get(prerenderStore);
    if (cachedSearchParams) {
        return cachedSearchParams;
    }
    const promise = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$dynamic$2d$rendering$2d$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["makeHangingPromise"])(prerenderStore.renderSignal, '`searchParams`');
    const proxiedPromise = new Proxy(promise, {
        get (target, prop, receiver) {
            if (Object.hasOwn(promise, prop)) {
                // The promise has this property directly. we must return it.
                // We know it isn't a dynamic access because it can only be something
                // that was previously written to the promise and thus not an underlying searchParam value
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$spec$2d$extension$2f$adapters$2f$reflect$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ReflectAdapter"].get(target, prop, receiver);
            }
            switch(prop){
                case 'then':
                    {
                        const expression = '`await searchParams`, `searchParams.then`, or similar';
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$dynamic$2d$rendering$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["annotateDynamicAccess"])(expression, prerenderStore);
                        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$spec$2d$extension$2f$adapters$2f$reflect$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ReflectAdapter"].get(target, prop, receiver);
                    }
                case 'status':
                    {
                        const expression = '`use(searchParams)`, `searchParams.status`, or similar';
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$dynamic$2d$rendering$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["annotateDynamicAccess"])(expression, prerenderStore);
                        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$spec$2d$extension$2f$adapters$2f$reflect$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ReflectAdapter"].get(target, prop, receiver);
                    }
                default:
                    {
                        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$spec$2d$extension$2f$adapters$2f$reflect$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ReflectAdapter"].get(target, prop, receiver);
                    }
            }
        }
    });
    CachedSearchParams.set(prerenderStore, proxiedPromise);
    return proxiedPromise;
}
function makeErroringExoticSearchParams(workStore, prerenderStore) {
    const cachedSearchParams = CachedSearchParams.get(workStore);
    if (cachedSearchParams) {
        return cachedSearchParams;
    }
    const underlyingSearchParams = {};
    // For search params we don't construct a ReactPromise because we want to interrupt
    // rendering on any property access that was not set from outside and so we only want
    // to have properties like value and status if React sets them.
    const promise = Promise.resolve(underlyingSearchParams);
    const proxiedPromise = new Proxy(promise, {
        get (target, prop, receiver) {
            if (Object.hasOwn(promise, prop)) {
                // The promise has this property directly. we must return it.
                // We know it isn't a dynamic access because it can only be something
                // that was previously written to the promise and thus not an underlying searchParam value
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$spec$2d$extension$2f$adapters$2f$reflect$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ReflectAdapter"].get(target, prop, receiver);
            }
            switch(prop){
                case 'then':
                    {
                        const expression = '`await searchParams`, `searchParams.then`, or similar';
                        if (workStore.dynamicShouldError) {
                            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["throwWithStaticGenerationBailoutErrorWithDynamicError"])(workStore.route, expression);
                        } else if (prerenderStore.type === 'prerender-ppr') {
                            // PPR Prerender (no dynamicIO)
                            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$dynamic$2d$rendering$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["postponeWithTracking"])(workStore.route, expression, prerenderStore.dynamicTracking);
                        } else {
                            // Legacy Prerender
                            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$dynamic$2d$rendering$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["throwToInterruptStaticGeneration"])(expression, workStore, prerenderStore);
                        }
                        return;
                    }
                case 'status':
                    {
                        const expression = '`use(searchParams)`, `searchParams.status`, or similar';
                        if (workStore.dynamicShouldError) {
                            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["throwWithStaticGenerationBailoutErrorWithDynamicError"])(workStore.route, expression);
                        } else if (prerenderStore.type === 'prerender-ppr') {
                            // PPR Prerender (no dynamicIO)
                            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$dynamic$2d$rendering$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["postponeWithTracking"])(workStore.route, expression, prerenderStore.dynamicTracking);
                        } else {
                            // Legacy Prerender
                            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$dynamic$2d$rendering$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["throwToInterruptStaticGeneration"])(expression, workStore, prerenderStore);
                        }
                        return;
                    }
                default:
                    {
                        if (typeof prop === 'string' && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$utils$2f$reflect$2d$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["wellKnownProperties"].has(prop)) {
                            const expression = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$utils$2f$reflect$2d$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["describeStringPropertyAccess"])('searchParams', prop);
                            if (workStore.dynamicShouldError) {
                                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["throwWithStaticGenerationBailoutErrorWithDynamicError"])(workStore.route, expression);
                            } else if (prerenderStore.type === 'prerender-ppr') {
                                // PPR Prerender (no dynamicIO)
                                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$dynamic$2d$rendering$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["postponeWithTracking"])(workStore.route, expression, prerenderStore.dynamicTracking);
                            } else {
                                // Legacy Prerender
                                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$dynamic$2d$rendering$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["throwToInterruptStaticGeneration"])(expression, workStore, prerenderStore);
                            }
                        }
                        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$spec$2d$extension$2f$adapters$2f$reflect$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ReflectAdapter"].get(target, prop, receiver);
                    }
            }
        },
        has (target, prop) {
            // We don't expect key checking to be used except for testing the existence of
            // searchParams so we make all has tests trigger dynamic. this means that `promise.then`
            // can resolve to the then function on the Promise prototype but 'then' in promise will assume
            // you are testing whether the searchParams has a 'then' property.
            if (typeof prop === 'string') {
                const expression = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$utils$2f$reflect$2d$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["describeHasCheckingStringProperty"])('searchParams', prop);
                if (workStore.dynamicShouldError) {
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["throwWithStaticGenerationBailoutErrorWithDynamicError"])(workStore.route, expression);
                } else if (prerenderStore.type === 'prerender-ppr') {
                    // PPR Prerender (no dynamicIO)
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$dynamic$2d$rendering$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["postponeWithTracking"])(workStore.route, expression, prerenderStore.dynamicTracking);
                } else {
                    // Legacy Prerender
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$dynamic$2d$rendering$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["throwToInterruptStaticGeneration"])(expression, workStore, prerenderStore);
                }
                return false;
            }
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$spec$2d$extension$2f$adapters$2f$reflect$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ReflectAdapter"].has(target, prop);
        },
        ownKeys () {
            const expression = '`{...searchParams}`, `Object.keys(searchParams)`, or similar';
            if (workStore.dynamicShouldError) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["throwWithStaticGenerationBailoutErrorWithDynamicError"])(workStore.route, expression);
            } else if (prerenderStore.type === 'prerender-ppr') {
                // PPR Prerender (no dynamicIO)
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$dynamic$2d$rendering$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["postponeWithTracking"])(workStore.route, expression, prerenderStore.dynamicTracking);
            } else {
                // Legacy Prerender
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$dynamic$2d$rendering$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["throwToInterruptStaticGeneration"])(expression, workStore, prerenderStore);
            }
        }
    });
    CachedSearchParams.set(workStore, proxiedPromise);
    return proxiedPromise;
}
function makeErroringExoticSearchParamsForUseCache(workStore) {
    const cachedSearchParams = CachedSearchParamsForUseCache.get(workStore);
    if (cachedSearchParams) {
        return cachedSearchParams;
    }
    const promise = Promise.resolve({});
    const proxiedPromise = new Proxy(promise, {
        get: function get(target, prop, receiver) {
            if (Object.hasOwn(promise, prop)) {
                // The promise has this property directly. we must return it. We know it
                // isn't a dynamic access because it can only be something that was
                // previously written to the promise and thus not an underlying
                // searchParam value
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$spec$2d$extension$2f$adapters$2f$reflect$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ReflectAdapter"].get(target, prop, receiver);
            }
            if (typeof prop === 'string' && (prop === 'then' || !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$utils$2f$reflect$2d$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["wellKnownProperties"].has(prop))) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["throwForSearchParamsAccessInUseCache"])(workStore, get);
            }
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$spec$2d$extension$2f$adapters$2f$reflect$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ReflectAdapter"].get(target, prop, receiver);
        },
        has: function has(target, prop) {
            // We don't expect key checking to be used except for testing the existence of
            // searchParams so we make all has tests throw an error. this means that `promise.then`
            // can resolve to the then function on the Promise prototype but 'then' in promise will assume
            // you are testing whether the searchParams has a 'then' property.
            if (typeof prop === 'string' && (prop === 'then' || !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$utils$2f$reflect$2d$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["wellKnownProperties"].has(prop))) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["throwForSearchParamsAccessInUseCache"])(workStore, has);
            }
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$spec$2d$extension$2f$adapters$2f$reflect$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ReflectAdapter"].has(target, prop);
        },
        ownKeys: function ownKeys() {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["throwForSearchParamsAccessInUseCache"])(workStore, ownKeys);
        }
    });
    CachedSearchParamsForUseCache.set(workStore, proxiedPromise);
    return proxiedPromise;
}
function makeUntrackedExoticSearchParams(underlyingSearchParams, store) {
    const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams);
    if (cachedSearchParams) {
        return cachedSearchParams;
    }
    // We don't use makeResolvedReactPromise here because searchParams
    // supports copying with spread and we don't want to unnecessarily
    // instrument the promise with spreadable properties of ReactPromise.
    const promise = Promise.resolve(underlyingSearchParams);
    CachedSearchParams.set(underlyingSearchParams, promise);
    Object.keys(underlyingSearchParams).forEach((prop)=>{
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$utils$2f$reflect$2d$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["wellKnownProperties"].has(prop)) {
            Object.defineProperty(promise, prop, {
                get () {
                    const workUnitStore = __TURBOPACK__imported__module__$5b$externals$5d2f$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$unit$2d$async$2d$storage$2e$external$2e$js__$5b$external$5d$__$28$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$unit$2d$async$2d$storage$2e$external$2e$js$2c$__cjs$29$__["workUnitAsyncStorage"].getStore();
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$dynamic$2d$rendering$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["trackDynamicDataInDynamicRender"])(store, workUnitStore);
                    return underlyingSearchParams[prop];
                },
                set (value) {
                    Object.defineProperty(promise, prop, {
                        value,
                        writable: true,
                        enumerable: true
                    });
                },
                enumerable: true,
                configurable: true
            });
        }
    });
    return promise;
}
function makeUntrackedSearchParams(underlyingSearchParams) {
    const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams);
    if (cachedSearchParams) {
        return cachedSearchParams;
    }
    const promise = Promise.resolve(underlyingSearchParams);
    CachedSearchParams.set(underlyingSearchParams, promise);
    return promise;
}
function makeDynamicallyTrackedExoticSearchParamsWithDevWarnings(underlyingSearchParams, store) {
    const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams);
    if (cachedSearchParams) {
        return cachedSearchParams;
    }
    const proxiedProperties = new Set();
    const unproxiedProperties = [];
    // We have an unfortunate sequence of events that requires this initialization logic. We want to instrument the underlying
    // searchParams object to detect if you are accessing values in dev. This is used for warnings and for things like the static prerender
    // indicator. However when we pass this proxy to our Promise.resolve() below the VM checks if the resolved value is a promise by looking
    // at the `.then` property. To our dynamic tracking logic this is indistinguishable from a `then` searchParam and so we would normally trigger
    // dynamic tracking. However we know that this .then is not real dynamic access, it's just how thenables resolve in sequence. So we introduce
    // this initialization concept so we omit the dynamic check until after we've constructed our resolved promise.
    let promiseInitialized = false;
    const proxiedUnderlying = new Proxy(underlyingSearchParams, {
        get (target, prop, receiver) {
            if (typeof prop === 'string' && promiseInitialized) {
                if (store.dynamicShouldError) {
                    const expression = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$utils$2f$reflect$2d$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["describeStringPropertyAccess"])('searchParams', prop);
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["throwWithStaticGenerationBailoutErrorWithDynamicError"])(store.route, expression);
                }
                const workUnitStore = __TURBOPACK__imported__module__$5b$externals$5d2f$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$unit$2d$async$2d$storage$2e$external$2e$js__$5b$external$5d$__$28$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$unit$2d$async$2d$storage$2e$external$2e$js$2c$__cjs$29$__["workUnitAsyncStorage"].getStore();
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$dynamic$2d$rendering$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["trackDynamicDataInDynamicRender"])(store, workUnitStore);
            }
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$spec$2d$extension$2f$adapters$2f$reflect$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ReflectAdapter"].get(target, prop, receiver);
        },
        has (target, prop) {
            if (typeof prop === 'string') {
                if (store.dynamicShouldError) {
                    const expression = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$utils$2f$reflect$2d$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["describeHasCheckingStringProperty"])('searchParams', prop);
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["throwWithStaticGenerationBailoutErrorWithDynamicError"])(store.route, expression);
                }
            }
            return Reflect.has(target, prop);
        },
        ownKeys (target) {
            if (store.dynamicShouldError) {
                const expression = '`{...searchParams}`, `Object.keys(searchParams)`, or similar';
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["throwWithStaticGenerationBailoutErrorWithDynamicError"])(store.route, expression);
            }
            return Reflect.ownKeys(target);
        }
    });
    // We don't use makeResolvedReactPromise here because searchParams
    // supports copying with spread and we don't want to unnecessarily
    // instrument the promise with spreadable properties of ReactPromise.
    const promise = new Promise((resolve)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$scheduler$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["scheduleImmediate"])(()=>resolve(underlyingSearchParams)));
    promise.then(()=>{
        promiseInitialized = true;
    });
    Object.keys(underlyingSearchParams).forEach((prop)=>{
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$utils$2f$reflect$2d$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["wellKnownProperties"].has(prop)) {
            // These properties cannot be shadowed because they need to be the
            // true underlying value for Promises to work correctly at runtime
            unproxiedProperties.push(prop);
        } else {
            proxiedProperties.add(prop);
            Object.defineProperty(promise, prop, {
                get () {
                    return proxiedUnderlying[prop];
                },
                set (newValue) {
                    Object.defineProperty(promise, prop, {
                        value: newValue,
                        writable: true,
                        enumerable: true
                    });
                },
                enumerable: true,
                configurable: true
            });
        }
    });
    const proxiedPromise = new Proxy(promise, {
        get (target, prop, receiver) {
            if (prop === 'then' && store.dynamicShouldError) {
                const expression = '`searchParams.then`';
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["throwWithStaticGenerationBailoutErrorWithDynamicError"])(store.route, expression);
            }
            if (typeof prop === 'string') {
                if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$utils$2f$reflect$2d$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["wellKnownProperties"].has(prop) && (proxiedProperties.has(prop) || // We are accessing a property that doesn't exist on the promise nor
                // the underlying searchParams.
                Reflect.has(target, prop) === false)) {
                    const expression = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$utils$2f$reflect$2d$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["describeStringPropertyAccess"])('searchParams', prop);
                    syncIODev(store.route, expression);
                }
            }
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$spec$2d$extension$2f$adapters$2f$reflect$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ReflectAdapter"].get(target, prop, receiver);
        },
        set (target, prop, value, receiver) {
            if (typeof prop === 'string') {
                proxiedProperties.delete(prop);
            }
            return Reflect.set(target, prop, value, receiver);
        },
        has (target, prop) {
            if (typeof prop === 'string') {
                if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$utils$2f$reflect$2d$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["wellKnownProperties"].has(prop) && (proxiedProperties.has(prop) || // We are accessing a property that doesn't exist on the promise nor
                // the underlying searchParams.
                Reflect.has(target, prop) === false)) {
                    const expression = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$utils$2f$reflect$2d$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["describeHasCheckingStringProperty"])('searchParams', prop);
                    syncIODev(store.route, expression);
                }
            }
            return Reflect.has(target, prop);
        },
        ownKeys (target) {
            const expression = '`Object.keys(searchParams)` or similar';
            syncIODev(store.route, expression, unproxiedProperties);
            return Reflect.ownKeys(target);
        }
    });
    CachedSearchParams.set(underlyingSearchParams, proxiedPromise);
    return proxiedPromise;
}
// Similar to `makeDynamicallyTrackedExoticSearchParamsWithDevWarnings`, but
// just logging the sync access without actually defining the search params on
// the promise.
function makeUntrackedSearchParamsWithDevWarnings(underlyingSearchParams, store) {
    const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams);
    if (cachedSearchParams) {
        return cachedSearchParams;
    }
    const proxiedProperties = new Set();
    const unproxiedProperties = [];
    const promise = Promise.resolve(underlyingSearchParams);
    Object.keys(underlyingSearchParams).forEach((prop)=>{
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$utils$2f$reflect$2d$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["wellKnownProperties"].has(prop)) {
            // These properties cannot be shadowed because they need to be the
            // true underlying value for Promises to work correctly at runtime
            unproxiedProperties.push(prop);
        } else {
            proxiedProperties.add(prop);
        }
    });
    const proxiedPromise = new Proxy(promise, {
        get (target, prop, receiver) {
            if (typeof prop === 'string') {
                if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$utils$2f$reflect$2d$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["wellKnownProperties"].has(prop) && (proxiedProperties.has(prop) || // We are accessing a property that doesn't exist on the promise nor
                // the underlying searchParams.
                Reflect.has(target, prop) === false)) {
                    const expression = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$utils$2f$reflect$2d$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["describeStringPropertyAccess"])('searchParams', prop);
                    warnForSyncAccess(store.route, expression);
                }
            }
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$spec$2d$extension$2f$adapters$2f$reflect$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ReflectAdapter"].get(target, prop, receiver);
        },
        set (target, prop, value, receiver) {
            if (typeof prop === 'string') {
                proxiedProperties.delete(prop);
            }
            return Reflect.set(target, prop, value, receiver);
        },
        has (target, prop) {
            if (typeof prop === 'string') {
                if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$utils$2f$reflect$2d$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["wellKnownProperties"].has(prop) && (proxiedProperties.has(prop) || // We are accessing a property that doesn't exist on the promise nor
                // the underlying searchParams.
                Reflect.has(target, prop) === false)) {
                    const expression = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$utils$2f$reflect$2d$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["describeHasCheckingStringProperty"])('searchParams', prop);
                    warnForSyncAccess(store.route, expression);
                }
            }
            return Reflect.has(target, prop);
        },
        ownKeys (target) {
            const expression = '`Object.keys(searchParams)` or similar';
            warnForIncompleteEnumeration(store.route, expression, unproxiedProperties);
            return Reflect.ownKeys(target);
        }
    });
    CachedSearchParams.set(underlyingSearchParams, proxiedPromise);
    return proxiedPromise;
}
function syncIODev(route, expression, missingProperties) {
    // In all cases we warn normally
    if (missingProperties && missingProperties.length > 0) {
        warnForIncompleteEnumeration(route, expression, missingProperties);
    } else {
        warnForSyncAccess(route, expression);
    }
    const workUnitStore = __TURBOPACK__imported__module__$5b$externals$5d2f$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$unit$2d$async$2d$storage$2e$external$2e$js__$5b$external$5d$__$28$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$unit$2d$async$2d$storage$2e$external$2e$js$2c$__cjs$29$__["workUnitAsyncStorage"].getStore();
    if (workUnitStore && workUnitStore.type === 'request' && workUnitStore.prerenderPhase === true) {
        // When we're rendering dynamically in dev we need to advance out of the
        // Prerender environment when we read Request data synchronously
        const requestStore = workUnitStore;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$dynamic$2d$rendering$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["trackSynchronousRequestDataAccessInDev"])(requestStore);
    }
}
const warnForSyncAccess = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$create$2d$deduped$2d$by$2d$callsite$2d$server$2d$error$2d$logger$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createDedupedByCallsiteServerErrorLoggerDev"])(createSearchAccessError);
const warnForIncompleteEnumeration = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$create$2d$deduped$2d$by$2d$callsite$2d$server$2d$error$2d$logger$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createDedupedByCallsiteServerErrorLoggerDev"])(createIncompleteEnumerationError);
function createSearchAccessError(route, expression) {
    const prefix = route ? `Route "${route}" ` : 'This route ';
    return Object.defineProperty(new Error(`${prefix}used ${expression}. ` + `\`searchParams\` should be awaited before using its properties. ` + `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`), "__NEXT_ERROR_CODE", {
        value: "E249",
        enumerable: false,
        configurable: true
    });
}
function createIncompleteEnumerationError(route, expression, missingProperties) {
    const prefix = route ? `Route "${route}" ` : 'This route ';
    return Object.defineProperty(new Error(`${prefix}used ${expression}. ` + `\`searchParams\` should be awaited before using its properties. ` + `The following properties were not available through enumeration ` + `because they conflict with builtin or well-known property names: ` + `${describeListOfPropertyNames(missingProperties)}. ` + `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`), "__NEXT_ERROR_CODE", {
        value: "E2",
        enumerable: false,
        configurable: true
    });
}
function describeListOfPropertyNames(properties) {
    switch(properties.length){
        case 0:
            throw Object.defineProperty(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$invariant$2d$error$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["InvariantError"]('Expected describeListOfPropertyNames to be called with a non-empty list of strings.'), "__NEXT_ERROR_CODE", {
                value: "E531",
                enumerable: false,
                configurable: true
            });
        case 1:
            return `\`${properties[0]}\``;
        case 2:
            return `\`${properties[0]}\` and \`${properties[1]}\``;
        default:
            {
                let description = '';
                for(let i = 0; i < properties.length - 1; i++){
                    description += `\`${properties[i]}\`, `;
                }
                description += `, and \`${properties[properties.length - 1]}\``;
                return description;
            }
    }
} //# sourceMappingURL=search-params.js.map
}),
"[project]/node_modules/next/dist/esm/server/request/params.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "createParamsFromClient": ()=>createParamsFromClient,
    "createPrerenderParamsForClientSegment": ()=>createPrerenderParamsForClientSegment,
    "createServerParamsForMetadata": ()=>createServerParamsForMetadata,
    "createServerParamsForRoute": ()=>createServerParamsForRoute,
    "createServerParamsForServerSegment": ()=>createServerParamsForServerSegment
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$spec$2d$extension$2f$adapters$2f$reflect$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/web/spec-extension/adapters/reflect.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$dynamic$2d$rendering$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/app-render/dynamic-rendering.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$unit$2d$async$2d$storage$2e$external$2e$js__$5b$external$5d$__$28$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$unit$2d$async$2d$storage$2e$external$2e$js$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$invariant$2d$error$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/invariant-error.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$utils$2f$reflect$2d$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/utils/reflect-utils.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$dynamic$2d$rendering$2d$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/dynamic-rendering-utils.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$create$2d$deduped$2d$by$2d$callsite$2d$server$2d$error$2d$logger$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/create-deduped-by-callsite-server-error-logger.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$scheduler$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/scheduler.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$next$2f$dist$2f$server$2f$app$2d$render$2f$dynamic$2d$access$2d$async$2d$storage$2e$external$2e$js__$5b$external$5d$__$28$next$2f$dist$2f$server$2f$app$2d$render$2f$dynamic$2d$access$2d$async$2d$storage$2e$external$2e$js$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/next/dist/server/app-render/dynamic-access-async-storage.external.js [external] (next/dist/server/app-render/dynamic-access-async-storage.external.js, cjs)");
;
;
;
;
;
;
;
;
;
function createParamsFromClient(underlyingParams, workStore) {
    const workUnitStore = __TURBOPACK__imported__module__$5b$externals$5d2f$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$unit$2d$async$2d$storage$2e$external$2e$js__$5b$external$5d$__$28$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$unit$2d$async$2d$storage$2e$external$2e$js$2c$__cjs$29$__["workUnitAsyncStorage"].getStore();
    if (workUnitStore) {
        switch(workUnitStore.type){
            case 'prerender':
            case 'prerender-client':
            case 'prerender-ppr':
            case 'prerender-legacy':
                return createPrerenderParams(underlyingParams, workStore, workUnitStore);
            default:
        }
    }
    return createRenderParams(underlyingParams, workStore);
}
const createServerParamsForMetadata = createServerParamsForServerSegment;
function createServerParamsForRoute(underlyingParams, workStore) {
    const workUnitStore = __TURBOPACK__imported__module__$5b$externals$5d2f$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$unit$2d$async$2d$storage$2e$external$2e$js__$5b$external$5d$__$28$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$unit$2d$async$2d$storage$2e$external$2e$js$2c$__cjs$29$__["workUnitAsyncStorage"].getStore();
    if (workUnitStore) {
        switch(workUnitStore.type){
            case 'prerender':
            case 'prerender-client':
            case 'prerender-ppr':
            case 'prerender-legacy':
                return createPrerenderParams(underlyingParams, workStore, workUnitStore);
            default:
        }
    }
    return createRenderParams(underlyingParams, workStore);
}
function createServerParamsForServerSegment(underlyingParams, workStore) {
    const workUnitStore = __TURBOPACK__imported__module__$5b$externals$5d2f$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$unit$2d$async$2d$storage$2e$external$2e$js__$5b$external$5d$__$28$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$unit$2d$async$2d$storage$2e$external$2e$js$2c$__cjs$29$__["workUnitAsyncStorage"].getStore();
    if (workUnitStore) {
        switch(workUnitStore.type){
            case 'prerender':
            case 'prerender-client':
            case 'prerender-ppr':
            case 'prerender-legacy':
                return createPrerenderParams(underlyingParams, workStore, workUnitStore);
            default:
        }
    }
    return createRenderParams(underlyingParams, workStore);
}
function createPrerenderParamsForClientSegment(underlyingParams, workStore) {
    const prerenderStore = __TURBOPACK__imported__module__$5b$externals$5d2f$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$unit$2d$async$2d$storage$2e$external$2e$js__$5b$external$5d$__$28$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$unit$2d$async$2d$storage$2e$external$2e$js$2c$__cjs$29$__["workUnitAsyncStorage"].getStore();
    if (prerenderStore && (prerenderStore.type === 'prerender' || prerenderStore.type === 'prerender-client')) {
        const fallbackParams = workStore.fallbackRouteParams;
        if (fallbackParams) {
            for(let key in underlyingParams){
                if (fallbackParams.has(key)) {
                    // This params object has one of more fallback params so we need to consider
                    // the awaiting of this params object "dynamic". Since we are in dynamicIO mode
                    // we encode this as a promise that never resolves
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$dynamic$2d$rendering$2d$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["makeHangingPromise"])(prerenderStore.renderSignal, '`params`');
                }
            }
        }
    }
    // We're prerendering in a mode that does not abort. We resolve the promise without
    // any tracking because we're just transporting a value from server to client where the tracking
    // will be applied.
    return Promise.resolve(underlyingParams);
}
function createPrerenderParams(underlyingParams, workStore, prerenderStore) {
    const fallbackParams = workStore.fallbackRouteParams;
    if (fallbackParams) {
        let hasSomeFallbackParams = false;
        for(const key in underlyingParams){
            if (fallbackParams.has(key)) {
                hasSomeFallbackParams = true;
                break;
            }
        }
        if (hasSomeFallbackParams) {
            // params need to be treated as dynamic because we have at least one fallback param
            switch(prerenderStore.type){
                case 'prerender':
                case 'prerender-client':
                    // We are in a dynamicIO prerender
                    return makeHangingParams(underlyingParams, prerenderStore);
                default:
                    return makeErroringExoticParams(underlyingParams, fallbackParams, workStore, prerenderStore);
            }
        }
    }
    // We don't have any fallback params so we have an entirely static safe params object
    return makeUntrackedExoticParams(underlyingParams);
}
function createRenderParams(underlyingParams, workStore) {
    if (("TURBOPACK compile-time value", "development") === 'development' && !workStore.isPrefetchRequest) {
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        return makeDynamicallyTrackedExoticParamsWithDevWarnings(underlyingParams, workStore);
    } else {
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        return makeUntrackedExoticParams(underlyingParams);
    }
}
const CachedParams = new WeakMap();
const fallbackParamsProxyHandler = {
    get: function get(target, prop, receiver) {
        if (prop === 'then' || prop === 'catch' || prop === 'finally') {
            const originalMethod = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$spec$2d$extension$2f$adapters$2f$reflect$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ReflectAdapter"].get(target, prop, receiver);
            return ({
                [prop]: (...args)=>{
                    const store = __TURBOPACK__imported__module__$5b$externals$5d2f$next$2f$dist$2f$server$2f$app$2d$render$2f$dynamic$2d$access$2d$async$2d$storage$2e$external$2e$js__$5b$external$5d$__$28$next$2f$dist$2f$server$2f$app$2d$render$2f$dynamic$2d$access$2d$async$2d$storage$2e$external$2e$js$2c$__cjs$29$__["dynamicAccessAsyncStorage"].getStore();
                    if (store) {
                        store.abortController.abort(Object.defineProperty(new Error(`Accessed fallback \`params\` during prerendering.`), "__NEXT_ERROR_CODE", {
                            value: "E691",
                            enumerable: false,
                            configurable: true
                        }));
                    }
                    return new Proxy(originalMethod.apply(target, args), fallbackParamsProxyHandler);
                }
            })[prop];
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$spec$2d$extension$2f$adapters$2f$reflect$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ReflectAdapter"].get(target, prop, receiver);
    }
};
function makeHangingParams(underlyingParams, prerenderStore) {
    const cachedParams = CachedParams.get(underlyingParams);
    if (cachedParams) {
        return cachedParams;
    }
    const promise = new Proxy((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$dynamic$2d$rendering$2d$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["makeHangingPromise"])(prerenderStore.renderSignal, '`params`'), fallbackParamsProxyHandler);
    CachedParams.set(underlyingParams, promise);
    return promise;
}
function makeErroringExoticParams(underlyingParams, fallbackParams, workStore, prerenderStore) {
    const cachedParams = CachedParams.get(underlyingParams);
    if (cachedParams) {
        return cachedParams;
    }
    const augmentedUnderlying = {
        ...underlyingParams
    };
    // We don't use makeResolvedReactPromise here because params
    // supports copying with spread and we don't want to unnecessarily
    // instrument the promise with spreadable properties of ReactPromise.
    const promise = Promise.resolve(augmentedUnderlying);
    CachedParams.set(underlyingParams, promise);
    Object.keys(underlyingParams).forEach((prop)=>{
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$utils$2f$reflect$2d$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["wellKnownProperties"].has(prop)) {
        // These properties cannot be shadowed because they need to be the
        // true underlying value for Promises to work correctly at runtime
        } else {
            if (fallbackParams.has(prop)) {
                Object.defineProperty(augmentedUnderlying, prop, {
                    get () {
                        const expression = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$utils$2f$reflect$2d$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["describeStringPropertyAccess"])('params', prop);
                        // In most dynamic APIs we also throw if `dynamic = "error"` however
                        // for params is only dynamic when we're generating a fallback shell
                        // and even when `dynamic = "error"` we still support generating dynamic
                        // fallback shells
                        // TODO remove this comment when dynamicIO is the default since there
                        // will be no `dynamic = "error"`
                        if (prerenderStore.type === 'prerender-ppr') {
                            // PPR Prerender (no dynamicIO)
                            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$dynamic$2d$rendering$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["postponeWithTracking"])(workStore.route, expression, prerenderStore.dynamicTracking);
                        } else {
                            // Legacy Prerender
                            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$dynamic$2d$rendering$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["throwToInterruptStaticGeneration"])(expression, workStore, prerenderStore);
                        }
                    },
                    enumerable: true
                });
                Object.defineProperty(promise, prop, {
                    get () {
                        const expression = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$utils$2f$reflect$2d$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["describeStringPropertyAccess"])('params', prop);
                        // In most dynamic APIs we also throw if `dynamic = "error"` however
                        // for params is only dynamic when we're generating a fallback shell
                        // and even when `dynamic = "error"` we still support generating dynamic
                        // fallback shells
                        // TODO remove this comment when dynamicIO is the default since there
                        // will be no `dynamic = "error"`
                        if (prerenderStore.type === 'prerender-ppr') {
                            // PPR Prerender (no dynamicIO)
                            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$dynamic$2d$rendering$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["postponeWithTracking"])(workStore.route, expression, prerenderStore.dynamicTracking);
                        } else {
                            // Legacy Prerender
                            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$dynamic$2d$rendering$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["throwToInterruptStaticGeneration"])(expression, workStore, prerenderStore);
                        }
                    },
                    set (newValue) {
                        Object.defineProperty(promise, prop, {
                            value: newValue,
                            writable: true,
                            enumerable: true
                        });
                    },
                    enumerable: true,
                    configurable: true
                });
            } else {
                ;
                promise[prop] = underlyingParams[prop];
            }
        }
    });
    return promise;
}
function makeUntrackedExoticParams(underlyingParams) {
    const cachedParams = CachedParams.get(underlyingParams);
    if (cachedParams) {
        return cachedParams;
    }
    // We don't use makeResolvedReactPromise here because params
    // supports copying with spread and we don't want to unnecessarily
    // instrument the promise with spreadable properties of ReactPromise.
    const promise = Promise.resolve(underlyingParams);
    CachedParams.set(underlyingParams, promise);
    Object.keys(underlyingParams).forEach((prop)=>{
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$utils$2f$reflect$2d$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["wellKnownProperties"].has(prop)) {
        // These properties cannot be shadowed because they need to be the
        // true underlying value for Promises to work correctly at runtime
        } else {
            ;
            promise[prop] = underlyingParams[prop];
        }
    });
    return promise;
}
function makeUntrackedParams(underlyingParams) {
    const cachedParams = CachedParams.get(underlyingParams);
    if (cachedParams) {
        return cachedParams;
    }
    const promise = Promise.resolve(underlyingParams);
    CachedParams.set(underlyingParams, promise);
    return promise;
}
function makeDynamicallyTrackedExoticParamsWithDevWarnings(underlyingParams, store) {
    const cachedParams = CachedParams.get(underlyingParams);
    if (cachedParams) {
        return cachedParams;
    }
    // We don't use makeResolvedReactPromise here because params
    // supports copying with spread and we don't want to unnecessarily
    // instrument the promise with spreadable properties of ReactPromise.
    const promise = new Promise((resolve)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$scheduler$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["scheduleImmediate"])(()=>resolve(underlyingParams)));
    const proxiedProperties = new Set();
    const unproxiedProperties = [];
    Object.keys(underlyingParams).forEach((prop)=>{
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$utils$2f$reflect$2d$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["wellKnownProperties"].has(prop)) {
            // These properties cannot be shadowed because they need to be the
            // true underlying value for Promises to work correctly at runtime
            unproxiedProperties.push(prop);
        } else {
            proxiedProperties.add(prop);
            promise[prop] = underlyingParams[prop];
        }
    });
    const proxiedPromise = new Proxy(promise, {
        get (target, prop, receiver) {
            if (typeof prop === 'string') {
                if (proxiedProperties.has(prop)) {
                    const expression = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$utils$2f$reflect$2d$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["describeStringPropertyAccess"])('params', prop);
                    syncIODev(store.route, expression);
                }
            }
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$spec$2d$extension$2f$adapters$2f$reflect$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ReflectAdapter"].get(target, prop, receiver);
        },
        set (target, prop, value, receiver) {
            if (typeof prop === 'string') {
                proxiedProperties.delete(prop);
            }
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$spec$2d$extension$2f$adapters$2f$reflect$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ReflectAdapter"].set(target, prop, value, receiver);
        },
        ownKeys (target) {
            const expression = '`...params` or similar expression';
            syncIODev(store.route, expression, unproxiedProperties);
            return Reflect.ownKeys(target);
        }
    });
    CachedParams.set(underlyingParams, proxiedPromise);
    return proxiedPromise;
}
// Similar to `makeDynamicallyTrackedExoticParamsWithDevWarnings`, but just
// logging the sync access without actually defining the params on the promise.
function makeDynamicallyTrackedParamsWithDevWarnings(underlyingParams, store) {
    const cachedParams = CachedParams.get(underlyingParams);
    if (cachedParams) {
        return cachedParams;
    }
    // We don't use makeResolvedReactPromise here because params
    // supports copying with spread and we don't want to unnecessarily
    // instrument the promise with spreadable properties of ReactPromise.
    const promise = new Promise((resolve)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$scheduler$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["scheduleImmediate"])(()=>resolve(underlyingParams)));
    const proxiedProperties = new Set();
    const unproxiedProperties = [];
    Object.keys(underlyingParams).forEach((prop)=>{
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$utils$2f$reflect$2d$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["wellKnownProperties"].has(prop)) {
            // These properties cannot be shadowed because they need to be the
            // true underlying value for Promises to work correctly at runtime
            unproxiedProperties.push(prop);
        } else {
            proxiedProperties.add(prop);
        }
    });
    const proxiedPromise = new Proxy(promise, {
        get (target, prop, receiver) {
            if (typeof prop === 'string') {
                if (proxiedProperties.has(prop)) {
                    const expression = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$utils$2f$reflect$2d$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["describeStringPropertyAccess"])('params', prop);
                    warnForSyncAccess(store.route, expression);
                }
            }
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$spec$2d$extension$2f$adapters$2f$reflect$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ReflectAdapter"].get(target, prop, receiver);
        },
        set (target, prop, value, receiver) {
            if (typeof prop === 'string') {
                proxiedProperties.delete(prop);
            }
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$spec$2d$extension$2f$adapters$2f$reflect$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ReflectAdapter"].set(target, prop, value, receiver);
        },
        ownKeys (target) {
            const expression = '`...params` or similar expression';
            warnForIncompleteEnumeration(store.route, expression, unproxiedProperties);
            return Reflect.ownKeys(target);
        }
    });
    CachedParams.set(underlyingParams, proxiedPromise);
    return proxiedPromise;
}
function syncIODev(route, expression, missingProperties) {
    const workUnitStore = __TURBOPACK__imported__module__$5b$externals$5d2f$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$unit$2d$async$2d$storage$2e$external$2e$js__$5b$external$5d$__$28$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$unit$2d$async$2d$storage$2e$external$2e$js$2c$__cjs$29$__["workUnitAsyncStorage"].getStore();
    if (workUnitStore && workUnitStore.type === 'request' && workUnitStore.prerenderPhase === true) {
        // When we're rendering dynamically in dev we need to advance out of the
        // Prerender environment when we read Request data synchronously
        const requestStore = workUnitStore;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$dynamic$2d$rendering$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["trackSynchronousRequestDataAccessInDev"])(requestStore);
    }
    // In all cases we warn normally
    if (missingProperties && missingProperties.length > 0) {
        warnForIncompleteEnumeration(route, expression, missingProperties);
    } else {
        warnForSyncAccess(route, expression);
    }
}
const warnForSyncAccess = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$create$2d$deduped$2d$by$2d$callsite$2d$server$2d$error$2d$logger$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createDedupedByCallsiteServerErrorLoggerDev"])(createParamsAccessError);
const warnForIncompleteEnumeration = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$create$2d$deduped$2d$by$2d$callsite$2d$server$2d$error$2d$logger$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createDedupedByCallsiteServerErrorLoggerDev"])(createIncompleteEnumerationError);
function createParamsAccessError(route, expression) {
    const prefix = route ? `Route "${route}" ` : 'This route ';
    return Object.defineProperty(new Error(`${prefix}used ${expression}. ` + `\`params\` should be awaited before using its properties. ` + `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`), "__NEXT_ERROR_CODE", {
        value: "E307",
        enumerable: false,
        configurable: true
    });
}
function createIncompleteEnumerationError(route, expression, missingProperties) {
    const prefix = route ? `Route "${route}" ` : 'This route ';
    return Object.defineProperty(new Error(`${prefix}used ${expression}. ` + `\`params\` should be awaited before using its properties. ` + `The following properties were not available through enumeration ` + `because they conflict with builtin property names: ` + `${describeListOfPropertyNames(missingProperties)}. ` + `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`), "__NEXT_ERROR_CODE", {
        value: "E482",
        enumerable: false,
        configurable: true
    });
}
function describeListOfPropertyNames(properties) {
    switch(properties.length){
        case 0:
            throw Object.defineProperty(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$invariant$2d$error$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["InvariantError"]('Expected describeListOfPropertyNames to be called with a non-empty list of strings.'), "__NEXT_ERROR_CODE", {
                value: "E531",
                enumerable: false,
                configurable: true
            });
        case 1:
            return `\`${properties[0]}\``;
        case 2:
            return `\`${properties[0]}\` and \`${properties[1]}\``;
        default:
            {
                let description = '';
                for(let i = 0; i < properties.length - 1; i++){
                    description += `\`${properties[i]}\`, `;
                }
                description += `, and \`${properties[properties.length - 1]}\``;
                return description;
            }
    }
} //# sourceMappingURL=params.js.map
}),
"[project]/node_modules/next/dist/esm/client/components/http-access-fallback/error-boundary.js [app-rsc] (client reference proxy) <module evaluation>": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const { createClientModuleProxy } = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-server-dom-turbopack-server.js [app-rsc] (ecmascript)");
__turbopack_context__.n(createClientModuleProxy("[project]/node_modules/next/dist/esm/client/components/http-access-fallback/error-boundary.js <module evaluation>"));
}}),
"[project]/node_modules/next/dist/esm/client/components/http-access-fallback/error-boundary.js [app-rsc] (client reference proxy)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const { createClientModuleProxy } = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-server-dom-turbopack-server.js [app-rsc] (ecmascript)");
__turbopack_context__.n(createClientModuleProxy("[project]/node_modules/next/dist/esm/client/components/http-access-fallback/error-boundary.js"));
}}),
"[project]/node_modules/next/dist/esm/client/components/http-access-fallback/error-boundary.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$http$2d$access$2d$fallback$2f$error$2d$boundary$2e$js__$5b$app$2d$rsc$5d$__$28$client__reference__proxy$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/client/components/http-access-fallback/error-boundary.js [app-rsc] (client reference proxy) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$http$2d$access$2d$fallback$2f$error$2d$boundary$2e$js__$5b$app$2d$rsc$5d$__$28$client__reference__proxy$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/client/components/http-access-fallback/error-boundary.js [app-rsc] (client reference proxy)");
;
__turbopack_context__.n(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$http$2d$access$2d$fallback$2f$error$2d$boundary$2e$js__$5b$app$2d$rsc$5d$__$28$client__reference__proxy$29$__);
}),
"[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-jsx-runtime.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/module.compiled.js [app-rsc] (ecmascript)").vendored['react-rsc'].ReactJsxRuntime; //# sourceMappingURL=react-jsx-runtime.js.map
}}),
"[project]/node_modules/next/dist/esm/lib/non-nullable.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "nonNullable": ()=>nonNullable
});
function nonNullable(value) {
    return value !== null && value !== undefined;
} //# sourceMappingURL=non-nullable.js.map
}),
"[project]/node_modules/next/dist/esm/lib/metadata/generate/meta.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "Meta": ()=>Meta,
    "MetaFilter": ()=>MetaFilter,
    "MultiMeta": ()=>MultiMeta
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-jsx-runtime.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$non$2d$nullable$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/non-nullable.js [app-rsc] (ecmascript)");
;
;
;
function Meta({ name, property, content, media }) {
    if (typeof content !== 'undefined' && content !== null && content !== '') {
        return /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["jsx"])("meta", {
            ...name ? {
                name
            } : {
                property
            },
            ...media ? {
                media
            } : undefined,
            content: typeof content === 'string' ? content : content.toString()
        });
    }
    return null;
}
function MetaFilter(items) {
    const acc = [];
    for (const item of items){
        if (Array.isArray(item)) {
            acc.push(...item.filter(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$non$2d$nullable$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["nonNullable"]));
        } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$non$2d$nullable$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["nonNullable"])(item)) {
            acc.push(item);
        }
    }
    return acc;
}
function camelToSnake(camelCaseStr) {
    return camelCaseStr.replace(/([A-Z])/g, function(match) {
        return '_' + match.toLowerCase();
    });
}
const aliasPropPrefixes = new Set([
    'og:image',
    'twitter:image',
    'og:video',
    'og:audio'
]);
function getMetaKey(prefix, key) {
    // Use `twitter:image` and `og:image` instead of `twitter:image:url` and `og:image:url`
    // to be more compatible as it's a more common format.
    // `og:video` & `og:audio` do not have a `:url` suffix alias
    if (aliasPropPrefixes.has(prefix) && key === 'url') {
        return prefix;
    }
    if (prefix.startsWith('og:') || prefix.startsWith('twitter:')) {
        key = camelToSnake(key);
    }
    return prefix + ':' + key;
}
function ExtendMeta({ content, namePrefix, propertyPrefix }) {
    if (!content) return null;
    return MetaFilter(Object.entries(content).map(([k, v])=>{
        return typeof v === 'undefined' ? null : Meta({
            ...propertyPrefix && {
                property: getMetaKey(propertyPrefix, k)
            },
            ...namePrefix && {
                name: getMetaKey(namePrefix, k)
            },
            content: typeof v === 'string' ? v : v == null ? void 0 : v.toString()
        });
    }));
}
function MultiMeta({ propertyPrefix, namePrefix, contents }) {
    if (typeof contents === 'undefined' || contents === null) {
        return null;
    }
    return MetaFilter(contents.map((content)=>{
        if (typeof content === 'string' || typeof content === 'number' || content instanceof URL) {
            return Meta({
                ...propertyPrefix ? {
                    property: propertyPrefix
                } : {
                    name: namePrefix
                },
                content
            });
        } else {
            return ExtendMeta({
                namePrefix,
                propertyPrefix,
                content
            });
        }
    }));
} //# sourceMappingURL=meta.js.map
}),
"[project]/node_modules/next/dist/esm/lib/metadata/constants.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "IconKeys": ()=>IconKeys,
    "ViewportMetaKeys": ()=>ViewportMetaKeys
});
const ViewportMetaKeys = {
    width: 'width',
    height: 'height',
    initialScale: 'initial-scale',
    minimumScale: 'minimum-scale',
    maximumScale: 'maximum-scale',
    viewportFit: 'viewport-fit',
    userScalable: 'user-scalable',
    interactiveWidget: 'interactive-widget'
};
const IconKeys = [
    'icon',
    'shortcut',
    'apple',
    'other'
]; //# sourceMappingURL=constants.js.map
}),
"[project]/node_modules/next/dist/esm/lib/metadata/generate/utils.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "getOrigin": ()=>getOrigin,
    "resolveArray": ()=>resolveArray,
    "resolveAsArrayOrUndefined": ()=>resolveAsArrayOrUndefined
});
function resolveArray(value) {
    if (Array.isArray(value)) {
        return value;
    }
    return [
        value
    ];
}
function resolveAsArrayOrUndefined(value) {
    if (typeof value === 'undefined' || value === null) {
        return undefined;
    }
    return resolveArray(value);
}
function getOrigin(url) {
    let origin = undefined;
    if (typeof url === 'string') {
        try {
            url = new URL(url);
            origin = url.origin;
        } catch  {}
    }
    return origin;
}
;
 //# sourceMappingURL=utils.js.map
}),
"[project]/node_modules/next/dist/esm/lib/metadata/generate/basic.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "AppleWebAppMeta": ()=>AppleWebAppMeta,
    "BasicMeta": ()=>BasicMeta,
    "FacebookMeta": ()=>FacebookMeta,
    "FormatDetectionMeta": ()=>FormatDetectionMeta,
    "ItunesMeta": ()=>ItunesMeta,
    "PinterestMeta": ()=>PinterestMeta,
    "VerificationMeta": ()=>VerificationMeta,
    "ViewportMeta": ()=>ViewportMeta
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-jsx-runtime.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/metadata/generate/meta.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/metadata/constants.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/metadata/generate/utils.js [app-rsc] (ecmascript)");
;
;
;
;
// convert viewport object to string for viewport meta tag
function resolveViewportLayout(viewport) {
    let resolved = null;
    if (viewport && typeof viewport === 'object') {
        resolved = '';
        for(const viewportKey_ in __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ViewportMetaKeys"]){
            const viewportKey = viewportKey_;
            if (viewportKey in viewport) {
                let value = viewport[viewportKey];
                if (typeof value === 'boolean') {
                    value = value ? 'yes' : 'no';
                } else if (!value && viewportKey === 'initialScale') {
                    value = undefined;
                }
                if (value) {
                    if (resolved) resolved += ', ';
                    resolved += `${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ViewportMetaKeys"][viewportKey]}=${value}`;
                }
            }
        }
    }
    return resolved;
}
function ViewportMeta({ viewport }) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["MetaFilter"])([
        /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["jsx"])("meta", {
            charSet: "utf-8"
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
            name: 'viewport',
            content: resolveViewportLayout(viewport)
        }),
        ...viewport.themeColor ? viewport.themeColor.map((themeColor)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
                name: 'theme-color',
                content: themeColor.color,
                media: themeColor.media
            })) : [],
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
            name: 'color-scheme',
            content: viewport.colorScheme
        })
    ]);
}
function BasicMeta({ metadata }) {
    var _metadata_keywords, _metadata_robots, _metadata_robots1;
    const manifestOrigin = metadata.manifest ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getOrigin"])(metadata.manifest) : undefined;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["MetaFilter"])([
        metadata.title !== null && metadata.title.absolute ? /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["jsx"])("title", {
            children: metadata.title.absolute
        }) : null,
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
            name: 'description',
            content: metadata.description
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
            name: 'application-name',
            content: metadata.applicationName
        }),
        ...metadata.authors ? metadata.authors.map((author)=>[
                author.url ? /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["jsx"])("link", {
                    rel: "author",
                    href: author.url.toString()
                }) : null,
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
                    name: 'author',
                    content: author.name
                })
            ]) : [],
        metadata.manifest ? /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["jsx"])("link", {
            rel: "manifest",
            href: metadata.manifest.toString(),
            // If it's same origin, and it's a preview deployment,
            // including credentials for manifest request.
            crossOrigin: !manifestOrigin && process.env.VERCEL_ENV === 'preview' ? 'use-credentials' : undefined
        }) : null,
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
            name: 'generator',
            content: metadata.generator
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
            name: 'keywords',
            content: (_metadata_keywords = metadata.keywords) == null ? void 0 : _metadata_keywords.join(',')
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
            name: 'referrer',
            content: metadata.referrer
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
            name: 'creator',
            content: metadata.creator
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
            name: 'publisher',
            content: metadata.publisher
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
            name: 'robots',
            content: (_metadata_robots = metadata.robots) == null ? void 0 : _metadata_robots.basic
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
            name: 'googlebot',
            content: (_metadata_robots1 = metadata.robots) == null ? void 0 : _metadata_robots1.googleBot
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
            name: 'abstract',
            content: metadata.abstract
        }),
        ...metadata.archives ? metadata.archives.map((archive)=>/*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["jsx"])("link", {
                rel: "archives",
                href: archive
            })) : [],
        ...metadata.assets ? metadata.assets.map((asset)=>/*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["jsx"])("link", {
                rel: "assets",
                href: asset
            })) : [],
        ...metadata.bookmarks ? metadata.bookmarks.map((bookmark)=>/*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["jsx"])("link", {
                rel: "bookmarks",
                href: bookmark
            })) : [],
        ...metadata.pagination ? [
            metadata.pagination.previous ? /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["jsx"])("link", {
                rel: "prev",
                href: metadata.pagination.previous
            }) : null,
            metadata.pagination.next ? /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["jsx"])("link", {
                rel: "next",
                href: metadata.pagination.next
            }) : null
        ] : [],
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
            name: 'category',
            content: metadata.category
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
            name: 'classification',
            content: metadata.classification
        }),
        ...metadata.other ? Object.entries(metadata.other).map(([name, content])=>{
            if (Array.isArray(content)) {
                return content.map((contentItem)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
                        name,
                        content: contentItem
                    }));
            } else {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
                    name,
                    content
                });
            }
        }) : []
    ]);
}
function ItunesMeta({ itunes }) {
    if (!itunes) return null;
    const { appId, appArgument } = itunes;
    let content = `app-id=${appId}`;
    if (appArgument) {
        content += `, app-argument=${appArgument}`;
    }
    return /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["jsx"])("meta", {
        name: "apple-itunes-app",
        content: content
    });
}
function FacebookMeta({ facebook }) {
    if (!facebook) return null;
    const { appId, admins } = facebook;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["MetaFilter"])([
        appId ? /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["jsx"])("meta", {
            property: "fb:app_id",
            content: appId
        }) : null,
        ...admins ? admins.map((admin)=>/*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["jsx"])("meta", {
                property: "fb:admins",
                content: admin
            })) : []
    ]);
}
function PinterestMeta({ pinterest }) {
    if (!pinterest || !pinterest.richPin) return null;
    const { richPin } = pinterest;
    return /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["jsx"])("meta", {
        property: "pinterest-rich-pin",
        content: richPin.toString()
    });
}
const formatDetectionKeys = [
    'telephone',
    'date',
    'address',
    'email',
    'url'
];
function FormatDetectionMeta({ formatDetection }) {
    if (!formatDetection) return null;
    let content = '';
    for (const key of formatDetectionKeys){
        if (key in formatDetection) {
            if (content) content += ', ';
            content += `${key}=no`;
        }
    }
    return /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["jsx"])("meta", {
        name: "format-detection",
        content: content
    });
}
function AppleWebAppMeta({ appleWebApp }) {
    if (!appleWebApp) return null;
    const { capable, title, startupImage, statusBarStyle } = appleWebApp;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["MetaFilter"])([
        capable ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
            name: 'mobile-web-app-capable',
            content: 'yes'
        }) : null,
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
            name: 'apple-mobile-web-app-title',
            content: title
        }),
        startupImage ? startupImage.map((image)=>/*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["jsx"])("link", {
                href: image.url,
                media: image.media,
                rel: "apple-touch-startup-image"
            })) : null,
        statusBarStyle ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
            name: 'apple-mobile-web-app-status-bar-style',
            content: statusBarStyle
        }) : null
    ]);
}
function VerificationMeta({ verification }) {
    if (!verification) return null;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["MetaFilter"])([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["MultiMeta"])({
            namePrefix: 'google-site-verification',
            contents: verification.google
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["MultiMeta"])({
            namePrefix: 'y_key',
            contents: verification.yahoo
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["MultiMeta"])({
            namePrefix: 'yandex-verification',
            contents: verification.yandex
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["MultiMeta"])({
            namePrefix: 'me',
            contents: verification.me
        }),
        ...verification.other ? Object.entries(verification.other).map(([key, value])=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["MultiMeta"])({
                namePrefix: key,
                contents: value
            })) : []
    ]);
} //# sourceMappingURL=basic.js.map
}),
"[project]/node_modules/next/dist/esm/lib/metadata/generate/alternate.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "AlternatesMetadata": ()=>AlternatesMetadata
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-jsx-runtime.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/metadata/generate/meta.js [app-rsc] (ecmascript)");
;
;
;
function AlternateLink({ descriptor, ...props }) {
    if (!descriptor.url) return null;
    return /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["jsx"])("link", {
        ...props,
        ...descriptor.title && {
            title: descriptor.title
        },
        href: descriptor.url.toString()
    });
}
function AlternatesMetadata({ alternates }) {
    if (!alternates) return null;
    const { canonical, languages, media, types } = alternates;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["MetaFilter"])([
        canonical ? AlternateLink({
            rel: 'canonical',
            descriptor: canonical
        }) : null,
        languages ? Object.entries(languages).flatMap(([locale, descriptors])=>descriptors == null ? void 0 : descriptors.map((descriptor)=>AlternateLink({
                    rel: 'alternate',
                    hrefLang: locale,
                    descriptor
                }))) : null,
        media ? Object.entries(media).flatMap(([mediaName, descriptors])=>descriptors == null ? void 0 : descriptors.map((descriptor)=>AlternateLink({
                    rel: 'alternate',
                    media: mediaName,
                    descriptor
                }))) : null,
        types ? Object.entries(types).flatMap(([type, descriptors])=>descriptors == null ? void 0 : descriptors.map((descriptor)=>AlternateLink({
                    rel: 'alternate',
                    type,
                    descriptor
                }))) : null
    ]);
} //# sourceMappingURL=alternate.js.map
}),
"[project]/node_modules/next/dist/esm/lib/metadata/generate/opengraph.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "AppLinksMeta": ()=>AppLinksMeta,
    "OpenGraphMetadata": ()=>OpenGraphMetadata,
    "TwitterMetadata": ()=>TwitterMetadata
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/metadata/generate/meta.js [app-rsc] (ecmascript)");
;
function OpenGraphMetadata({ openGraph }) {
    var _openGraph_title, _openGraph_url, _openGraph_ttl;
    if (!openGraph) {
        return null;
    }
    let typedOpenGraph;
    if ('type' in openGraph) {
        const openGraphType = openGraph.type;
        switch(openGraphType){
            case 'website':
                typedOpenGraph = [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
                        property: 'og:type',
                        content: 'website'
                    })
                ];
                break;
            case 'article':
                var _openGraph_publishedTime, _openGraph_modifiedTime, _openGraph_expirationTime;
                typedOpenGraph = [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
                        property: 'og:type',
                        content: 'article'
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
                        property: 'article:published_time',
                        content: (_openGraph_publishedTime = openGraph.publishedTime) == null ? void 0 : _openGraph_publishedTime.toString()
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
                        property: 'article:modified_time',
                        content: (_openGraph_modifiedTime = openGraph.modifiedTime) == null ? void 0 : _openGraph_modifiedTime.toString()
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
                        property: 'article:expiration_time',
                        content: (_openGraph_expirationTime = openGraph.expirationTime) == null ? void 0 : _openGraph_expirationTime.toString()
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["MultiMeta"])({
                        propertyPrefix: 'article:author',
                        contents: openGraph.authors
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
                        property: 'article:section',
                        content: openGraph.section
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["MultiMeta"])({
                        propertyPrefix: 'article:tag',
                        contents: openGraph.tags
                    })
                ];
                break;
            case 'book':
                typedOpenGraph = [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
                        property: 'og:type',
                        content: 'book'
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
                        property: 'book:isbn',
                        content: openGraph.isbn
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
                        property: 'book:release_date',
                        content: openGraph.releaseDate
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["MultiMeta"])({
                        propertyPrefix: 'book:author',
                        contents: openGraph.authors
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["MultiMeta"])({
                        propertyPrefix: 'book:tag',
                        contents: openGraph.tags
                    })
                ];
                break;
            case 'profile':
                typedOpenGraph = [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
                        property: 'og:type',
                        content: 'profile'
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
                        property: 'profile:first_name',
                        content: openGraph.firstName
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
                        property: 'profile:last_name',
                        content: openGraph.lastName
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
                        property: 'profile:username',
                        content: openGraph.username
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
                        property: 'profile:gender',
                        content: openGraph.gender
                    })
                ];
                break;
            case 'music.song':
                var _openGraph_duration;
                typedOpenGraph = [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
                        property: 'og:type',
                        content: 'music.song'
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
                        property: 'music:duration',
                        content: (_openGraph_duration = openGraph.duration) == null ? void 0 : _openGraph_duration.toString()
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["MultiMeta"])({
                        propertyPrefix: 'music:album',
                        contents: openGraph.albums
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["MultiMeta"])({
                        propertyPrefix: 'music:musician',
                        contents: openGraph.musicians
                    })
                ];
                break;
            case 'music.album':
                typedOpenGraph = [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
                        property: 'og:type',
                        content: 'music.album'
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["MultiMeta"])({
                        propertyPrefix: 'music:song',
                        contents: openGraph.songs
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["MultiMeta"])({
                        propertyPrefix: 'music:musician',
                        contents: openGraph.musicians
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
                        property: 'music:release_date',
                        content: openGraph.releaseDate
                    })
                ];
                break;
            case 'music.playlist':
                typedOpenGraph = [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
                        property: 'og:type',
                        content: 'music.playlist'
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["MultiMeta"])({
                        propertyPrefix: 'music:song',
                        contents: openGraph.songs
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["MultiMeta"])({
                        propertyPrefix: 'music:creator',
                        contents: openGraph.creators
                    })
                ];
                break;
            case 'music.radio_station':
                typedOpenGraph = [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
                        property: 'og:type',
                        content: 'music.radio_station'
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["MultiMeta"])({
                        propertyPrefix: 'music:creator',
                        contents: openGraph.creators
                    })
                ];
                break;
            case 'video.movie':
                typedOpenGraph = [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
                        property: 'og:type',
                        content: 'video.movie'
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["MultiMeta"])({
                        propertyPrefix: 'video:actor',
                        contents: openGraph.actors
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["MultiMeta"])({
                        propertyPrefix: 'video:director',
                        contents: openGraph.directors
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["MultiMeta"])({
                        propertyPrefix: 'video:writer',
                        contents: openGraph.writers
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
                        property: 'video:duration',
                        content: openGraph.duration
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
                        property: 'video:release_date',
                        content: openGraph.releaseDate
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["MultiMeta"])({
                        propertyPrefix: 'video:tag',
                        contents: openGraph.tags
                    })
                ];
                break;
            case 'video.episode':
                typedOpenGraph = [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
                        property: 'og:type',
                        content: 'video.episode'
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["MultiMeta"])({
                        propertyPrefix: 'video:actor',
                        contents: openGraph.actors
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["MultiMeta"])({
                        propertyPrefix: 'video:director',
                        contents: openGraph.directors
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["MultiMeta"])({
                        propertyPrefix: 'video:writer',
                        contents: openGraph.writers
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
                        property: 'video:duration',
                        content: openGraph.duration
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
                        property: 'video:release_date',
                        content: openGraph.releaseDate
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["MultiMeta"])({
                        propertyPrefix: 'video:tag',
                        contents: openGraph.tags
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
                        property: 'video:series',
                        content: openGraph.series
                    })
                ];
                break;
            case 'video.tv_show':
                typedOpenGraph = [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
                        property: 'og:type',
                        content: 'video.tv_show'
                    })
                ];
                break;
            case 'video.other':
                typedOpenGraph = [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
                        property: 'og:type',
                        content: 'video.other'
                    })
                ];
                break;
            default:
                const _exhaustiveCheck = openGraphType;
                throw Object.defineProperty(new Error(`Invalid OpenGraph type: ${_exhaustiveCheck}`), "__NEXT_ERROR_CODE", {
                    value: "E237",
                    enumerable: false,
                    configurable: true
                });
        }
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["MetaFilter"])([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
            property: 'og:determiner',
            content: openGraph.determiner
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
            property: 'og:title',
            content: (_openGraph_title = openGraph.title) == null ? void 0 : _openGraph_title.absolute
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
            property: 'og:description',
            content: openGraph.description
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
            property: 'og:url',
            content: (_openGraph_url = openGraph.url) == null ? void 0 : _openGraph_url.toString()
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
            property: 'og:site_name',
            content: openGraph.siteName
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
            property: 'og:locale',
            content: openGraph.locale
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
            property: 'og:country_name',
            content: openGraph.countryName
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
            property: 'og:ttl',
            content: (_openGraph_ttl = openGraph.ttl) == null ? void 0 : _openGraph_ttl.toString()
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["MultiMeta"])({
            propertyPrefix: 'og:image',
            contents: openGraph.images
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["MultiMeta"])({
            propertyPrefix: 'og:video',
            contents: openGraph.videos
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["MultiMeta"])({
            propertyPrefix: 'og:audio',
            contents: openGraph.audio
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["MultiMeta"])({
            propertyPrefix: 'og:email',
            contents: openGraph.emails
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["MultiMeta"])({
            propertyPrefix: 'og:phone_number',
            contents: openGraph.phoneNumbers
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["MultiMeta"])({
            propertyPrefix: 'og:fax_number',
            contents: openGraph.faxNumbers
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["MultiMeta"])({
            propertyPrefix: 'og:locale:alternate',
            contents: openGraph.alternateLocale
        }),
        ...typedOpenGraph ? typedOpenGraph : []
    ]);
}
function TwitterAppItem({ app, type }) {
    var _app_url_type, _app_url;
    return [
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
            name: `twitter:app:name:${type}`,
            content: app.name
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
            name: `twitter:app:id:${type}`,
            content: app.id[type]
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
            name: `twitter:app:url:${type}`,
            content: (_app_url = app.url) == null ? void 0 : (_app_url_type = _app_url[type]) == null ? void 0 : _app_url_type.toString()
        })
    ];
}
function TwitterMetadata({ twitter }) {
    var _twitter_title;
    if (!twitter) return null;
    const { card } = twitter;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["MetaFilter"])([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
            name: 'twitter:card',
            content: card
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
            name: 'twitter:site',
            content: twitter.site
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
            name: 'twitter:site:id',
            content: twitter.siteId
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
            name: 'twitter:creator',
            content: twitter.creator
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
            name: 'twitter:creator:id',
            content: twitter.creatorId
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
            name: 'twitter:title',
            content: (_twitter_title = twitter.title) == null ? void 0 : _twitter_title.absolute
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
            name: 'twitter:description',
            content: twitter.description
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["MultiMeta"])({
            namePrefix: 'twitter:image',
            contents: twitter.images
        }),
        ...card === 'player' ? twitter.players.flatMap((player)=>[
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
                    name: 'twitter:player',
                    content: player.playerUrl.toString()
                }),
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
                    name: 'twitter:player:stream',
                    content: player.streamUrl.toString()
                }),
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
                    name: 'twitter:player:width',
                    content: player.width
                }),
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Meta"])({
                    name: 'twitter:player:height',
                    content: player.height
                })
            ]) : [],
        ...card === 'app' ? [
            TwitterAppItem({
                app: twitter.app,
                type: 'iphone'
            }),
            TwitterAppItem({
                app: twitter.app,
                type: 'ipad'
            }),
            TwitterAppItem({
                app: twitter.app,
                type: 'googleplay'
            })
        ] : []
    ]);
}
function AppLinksMeta({ appLinks }) {
    if (!appLinks) return null;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["MetaFilter"])([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["MultiMeta"])({
            propertyPrefix: 'al:ios',
            contents: appLinks.ios
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["MultiMeta"])({
            propertyPrefix: 'al:iphone',
            contents: appLinks.iphone
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["MultiMeta"])({
            propertyPrefix: 'al:ipad',
            contents: appLinks.ipad
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["MultiMeta"])({
            propertyPrefix: 'al:android',
            contents: appLinks.android
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["MultiMeta"])({
            propertyPrefix: 'al:windows_phone',
            contents: appLinks.windows_phone
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["MultiMeta"])({
            propertyPrefix: 'al:windows',
            contents: appLinks.windows
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["MultiMeta"])({
            propertyPrefix: 'al:windows_universal',
            contents: appLinks.windows_universal
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["MultiMeta"])({
            propertyPrefix: 'al:web',
            contents: appLinks.web
        })
    ]);
} //# sourceMappingURL=opengraph.js.map
}),
"[project]/node_modules/next/dist/esm/lib/metadata/generate/icon-mark.js [app-rsc] (client reference proxy) <module evaluation>": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const { createClientModuleProxy } = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-server-dom-turbopack-server.js [app-rsc] (ecmascript)");
__turbopack_context__.n(createClientModuleProxy("[project]/node_modules/next/dist/esm/lib/metadata/generate/icon-mark.js <module evaluation>"));
}}),
"[project]/node_modules/next/dist/esm/lib/metadata/generate/icon-mark.js [app-rsc] (client reference proxy)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const { createClientModuleProxy } = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-server-dom-turbopack-server.js [app-rsc] (ecmascript)");
__turbopack_context__.n(createClientModuleProxy("[project]/node_modules/next/dist/esm/lib/metadata/generate/icon-mark.js"));
}}),
"[project]/node_modules/next/dist/esm/lib/metadata/generate/icon-mark.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$icon$2d$mark$2e$js__$5b$app$2d$rsc$5d$__$28$client__reference__proxy$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/metadata/generate/icon-mark.js [app-rsc] (client reference proxy) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$icon$2d$mark$2e$js__$5b$app$2d$rsc$5d$__$28$client__reference__proxy$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/metadata/generate/icon-mark.js [app-rsc] (client reference proxy)");
;
__turbopack_context__.n(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$icon$2d$mark$2e$js__$5b$app$2d$rsc$5d$__$28$client__reference__proxy$29$__);
}),
"[project]/node_modules/next/dist/esm/lib/metadata/generate/icons.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "IconsMetadata": ()=>IconsMetadata
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-jsx-runtime.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$icon$2d$mark$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/metadata/generate/icon-mark.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/metadata/generate/meta.js [app-rsc] (ecmascript)");
;
;
;
function IconDescriptorLink({ icon }) {
    const { url, rel = 'icon', ...props } = icon;
    return /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["jsx"])("link", {
        rel: rel,
        href: url.toString(),
        ...props
    });
}
function IconLink({ rel, icon }) {
    if (typeof icon === 'object' && !(icon instanceof URL)) {
        if (!icon.rel && rel) icon.rel = rel;
        return IconDescriptorLink({
            icon
        });
    } else {
        const href = icon.toString();
        return /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["jsx"])("link", {
            rel: rel,
            href: href
        });
    }
}
function IconsMetadata({ icons }) {
    if (!icons) return null;
    const shortcutList = icons.shortcut;
    const iconList = icons.icon;
    const appleList = icons.apple;
    const otherList = icons.other;
    const hasIcon = Boolean((shortcutList == null ? void 0 : shortcutList.length) || (iconList == null ? void 0 : iconList.length) || (appleList == null ? void 0 : appleList.length) || (otherList == null ? void 0 : otherList.length));
    if (!hasIcon) return null;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["MetaFilter"])([
        shortcutList ? shortcutList.map((icon)=>IconLink({
                rel: 'shortcut icon',
                icon
            })) : null,
        iconList ? iconList.map((icon)=>IconLink({
                rel: 'icon',
                icon
            })) : null,
        appleList ? appleList.map((icon)=>IconLink({
                rel: 'apple-touch-icon',
                icon
            })) : null,
        otherList ? otherList.map((icon)=>IconDescriptorLink({
                icon
            })) : null,
        hasIcon ? /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$icon$2d$mark$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["IconMark"], {}) : null
    ]);
} //# sourceMappingURL=icons.js.map
}),
"[project]/node_modules/next/dist/compiled/server-only/empty.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
}}),
"[project]/node_modules/next/dist/esm/lib/metadata/default-metadata.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "createDefaultMetadata": ()=>createDefaultMetadata,
    "createDefaultViewport": ()=>createDefaultViewport
});
function createDefaultViewport() {
    return {
        // name=viewport
        width: 'device-width',
        initialScale: 1,
        // visual metadata
        themeColor: null,
        colorScheme: null
    };
}
function createDefaultMetadata() {
    return {
        // Deprecated ones
        viewport: null,
        themeColor: null,
        colorScheme: null,
        metadataBase: null,
        // Other values are all null
        title: null,
        description: null,
        applicationName: null,
        authors: null,
        generator: null,
        keywords: null,
        referrer: null,
        creator: null,
        publisher: null,
        robots: null,
        manifest: null,
        alternates: {
            canonical: null,
            languages: null,
            media: null,
            types: null
        },
        icons: null,
        openGraph: null,
        twitter: null,
        verification: {},
        appleWebApp: null,
        formatDetection: null,
        itunes: null,
        facebook: null,
        pinterest: null,
        abstract: null,
        appLinks: null,
        archives: null,
        assets: null,
        bookmarks: null,
        category: null,
        classification: null,
        pagination: {
            previous: null,
            next: null
        },
        other: {}
    };
} //# sourceMappingURL=default-metadata.js.map
}),
"[project]/node_modules/next/dist/esm/shared/lib/isomorphic/path.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
/**
 * This module is for next.js server internal usage of path module.
 * It will use native path module for nodejs runtime.
 * It will use path-browserify polyfill for edge runtime.
 */ let path;
if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
else {
    path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
}
module.exports = path; //# sourceMappingURL=path.js.map
}}),
"[project]/node_modules/next/dist/esm/lib/metadata/resolvers/resolve-url.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "getSocialImageMetadataBaseFallback": ()=>getSocialImageMetadataBaseFallback,
    "isStringOrURL": ()=>isStringOrURL,
    "resolveAbsoluteUrlWithPathname": ()=>resolveAbsoluteUrlWithPathname,
    "resolveRelativeUrl": ()=>resolveRelativeUrl,
    "resolveUrl": ()=>resolveUrl
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$isomorphic$2f$path$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/isomorphic/path.js [app-rsc] (ecmascript)");
;
function isStringOrURL(icon) {
    return typeof icon === 'string' || icon instanceof URL;
}
function createLocalMetadataBase() {
    // Check if experimental HTTPS is enabled
    const isExperimentalHttps = Boolean(process.env.__NEXT_EXPERIMENTAL_HTTPS);
    const protocol = isExperimentalHttps ? 'https' : 'http';
    return new URL(`${protocol}://localhost:${process.env.PORT || 3000}`);
}
function getPreviewDeploymentUrl() {
    const origin = process.env.VERCEL_BRANCH_URL || process.env.VERCEL_URL;
    return origin ? new URL(`https://${origin}`) : undefined;
}
function getProductionDeploymentUrl() {
    const origin = process.env.VERCEL_PROJECT_PRODUCTION_URL;
    return origin ? new URL(`https://${origin}`) : undefined;
}
function getSocialImageMetadataBaseFallback(metadataBase) {
    const defaultMetadataBase = createLocalMetadataBase();
    const previewDeploymentUrl = getPreviewDeploymentUrl();
    const productionDeploymentUrl = getProductionDeploymentUrl();
    let fallbackMetadataBase;
    if ("TURBOPACK compile-time truthy", 1) {
        fallbackMetadataBase = defaultMetadataBase;
    } else //TURBOPACK unreachable
    ;
    return fallbackMetadataBase;
}
function resolveUrl(url, metadataBase) {
    if (url instanceof URL) return url;
    if (!url) return null;
    try {
        // If we can construct a URL instance from url, ignore metadataBase
        const parsedUrl = new URL(url);
        return parsedUrl;
    } catch  {}
    if (!metadataBase) {
        metadataBase = createLocalMetadataBase();
    }
    // Handle relative or absolute paths
    const pathname = metadataBase.pathname || '';
    const joinedPath = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$isomorphic$2f$path$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"].posix.join(pathname, url);
    return new URL(joinedPath, metadataBase);
}
// Resolve with `pathname` if `url` is a relative path.
function resolveRelativeUrl(url, pathname) {
    if (typeof url === 'string' && url.startsWith('./')) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$isomorphic$2f$path$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"].posix.resolve(pathname, url);
    }
    return url;
}
// The regex is matching logic from packages/next/src/lib/load-custom-routes.ts
const FILE_REGEX = /^(?:\/((?!\.well-known(?:\/.*)?)(?:[^/]+\/)*[^/]+\.\w+))(\/?|$)/i;
function isFilePattern(pathname) {
    return FILE_REGEX.test(pathname);
}
// Resolve `pathname` if `url` is a relative path the compose with `metadataBase`.
function resolveAbsoluteUrlWithPathname(url, metadataBase, pathname, { trailingSlash }) {
    // Resolve url with pathname that always starts with `/`
    url = resolveRelativeUrl(url, pathname);
    // Convert string url or URL instance to absolute url string,
    // if there's case needs to be resolved with metadataBase
    let resolvedUrl = '';
    const result = metadataBase ? resolveUrl(url, metadataBase) : url;
    if (typeof result === 'string') {
        resolvedUrl = result;
    } else {
        resolvedUrl = result.pathname === '/' ? result.origin : result.href;
    }
    // Add trailing slash if it's enabled for urls matches the condition
    // - Not external, same origin with metadataBase
    // - Doesn't have query
    if (trailingSlash && !resolvedUrl.endsWith('/')) {
        let isRelative = resolvedUrl.startsWith('/');
        let hasQuery = resolvedUrl.includes('?');
        let isExternal = false;
        let isFileUrl = false;
        if (!isRelative) {
            try {
                const parsedUrl = new URL(resolvedUrl);
                isExternal = metadataBase != null && parsedUrl.origin !== metadataBase.origin;
                isFileUrl = isFilePattern(parsedUrl.pathname);
            } catch  {
                // If it's not a valid URL, treat it as external
                isExternal = true;
            }
            if (!isFileUrl && !isExternal && !hasQuery) return `${resolvedUrl}/`;
        }
    }
    return resolvedUrl;
}
;
 //# sourceMappingURL=resolve-url.js.map
}),
"[project]/node_modules/next/dist/esm/lib/metadata/resolvers/resolve-title.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "resolveTitle": ()=>resolveTitle
});
function resolveTitleTemplate(template, title) {
    return template ? template.replace(/%s/g, title) : title;
}
function resolveTitle(title, stashedTemplate) {
    let resolved;
    const template = typeof title !== 'string' && title && 'template' in title ? title.template : null;
    if (typeof title === 'string') {
        resolved = resolveTitleTemplate(stashedTemplate, title);
    } else if (title) {
        if ('default' in title) {
            resolved = resolveTitleTemplate(stashedTemplate, title.default);
        }
        if ('absolute' in title && title.absolute) {
            resolved = title.absolute;
        }
    }
    if (title && typeof title !== 'string') {
        return {
            template,
            absolute: resolved || ''
        };
    } else {
        return {
            absolute: resolved || title || '',
            template
        };
    }
} //# sourceMappingURL=resolve-title.js.map
}),
"[project]/node_modules/next/dist/esm/client/components/app-router-headers.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "ACTION_HEADER": ()=>ACTION_HEADER,
    "FLIGHT_HEADERS": ()=>FLIGHT_HEADERS,
    "NEXT_ACTION_NOT_FOUND_HEADER": ()=>NEXT_ACTION_NOT_FOUND_HEADER,
    "NEXT_DID_POSTPONE_HEADER": ()=>NEXT_DID_POSTPONE_HEADER,
    "NEXT_HMR_REFRESH_HASH_COOKIE": ()=>NEXT_HMR_REFRESH_HASH_COOKIE,
    "NEXT_HMR_REFRESH_HEADER": ()=>NEXT_HMR_REFRESH_HEADER,
    "NEXT_IS_PRERENDER_HEADER": ()=>NEXT_IS_PRERENDER_HEADER,
    "NEXT_REWRITTEN_PATH_HEADER": ()=>NEXT_REWRITTEN_PATH_HEADER,
    "NEXT_REWRITTEN_QUERY_HEADER": ()=>NEXT_REWRITTEN_QUERY_HEADER,
    "NEXT_ROUTER_PREFETCH_HEADER": ()=>NEXT_ROUTER_PREFETCH_HEADER,
    "NEXT_ROUTER_SEGMENT_PREFETCH_HEADER": ()=>NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,
    "NEXT_ROUTER_STALE_TIME_HEADER": ()=>NEXT_ROUTER_STALE_TIME_HEADER,
    "NEXT_ROUTER_STATE_TREE_HEADER": ()=>NEXT_ROUTER_STATE_TREE_HEADER,
    "NEXT_RSC_UNION_QUERY": ()=>NEXT_RSC_UNION_QUERY,
    "NEXT_URL": ()=>NEXT_URL,
    "RSC_CONTENT_TYPE_HEADER": ()=>RSC_CONTENT_TYPE_HEADER,
    "RSC_HEADER": ()=>RSC_HEADER
});
const RSC_HEADER = 'RSC';
const ACTION_HEADER = 'Next-Action';
const NEXT_ROUTER_STATE_TREE_HEADER = 'Next-Router-State-Tree';
const NEXT_ROUTER_PREFETCH_HEADER = 'Next-Router-Prefetch';
const NEXT_ROUTER_SEGMENT_PREFETCH_HEADER = 'Next-Router-Segment-Prefetch';
const NEXT_HMR_REFRESH_HEADER = 'Next-HMR-Refresh';
const NEXT_HMR_REFRESH_HASH_COOKIE = '__next_hmr_refresh_hash__';
const NEXT_URL = 'Next-Url';
const RSC_CONTENT_TYPE_HEADER = 'text/x-component';
const FLIGHT_HEADERS = [
    RSC_HEADER,
    NEXT_ROUTER_STATE_TREE_HEADER,
    NEXT_ROUTER_PREFETCH_HEADER,
    NEXT_HMR_REFRESH_HEADER,
    NEXT_ROUTER_SEGMENT_PREFETCH_HEADER
];
const NEXT_RSC_UNION_QUERY = '_rsc';
const NEXT_ROUTER_STALE_TIME_HEADER = 'x-nextjs-stale-time';
const NEXT_DID_POSTPONE_HEADER = 'x-nextjs-postponed';
const NEXT_REWRITTEN_PATH_HEADER = 'x-nextjs-rewritten-path';
const NEXT_REWRITTEN_QUERY_HEADER = 'x-nextjs-rewritten-query';
const NEXT_IS_PRERENDER_HEADER = 'x-nextjs-prerender';
const NEXT_ACTION_NOT_FOUND_HEADER = 'x-nextjs-action-not-found'; //# sourceMappingURL=app-router-headers.js.map
}),
"[project]/node_modules/next/dist/esm/lib/url.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "isFullStringUrl": ()=>isFullStringUrl,
    "parseReqUrl": ()=>parseReqUrl,
    "parseUrl": ()=>parseUrl,
    "stripNextRscUnionQuery": ()=>stripNextRscUnionQuery
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$app$2d$router$2d$headers$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/client/components/app-router-headers.js [app-rsc] (ecmascript)");
;
const DUMMY_ORIGIN = 'http://n';
function isFullStringUrl(url) {
    return /https?:\/\//.test(url);
}
function parseUrl(url) {
    let parsed = undefined;
    try {
        parsed = new URL(url, DUMMY_ORIGIN);
    } catch  {}
    return parsed;
}
function parseReqUrl(url) {
    const parsedUrl = parseUrl(url);
    if (!parsedUrl) {
        return;
    }
    const query = {};
    for (const key of parsedUrl.searchParams.keys()){
        const values = parsedUrl.searchParams.getAll(key);
        query[key] = values.length > 1 ? values : values[0];
    }
    const legacyUrl = {
        query,
        hash: parsedUrl.hash,
        search: parsedUrl.search,
        path: parsedUrl.pathname,
        pathname: parsedUrl.pathname,
        href: `${parsedUrl.pathname}${parsedUrl.search}${parsedUrl.hash}`,
        host: '',
        hostname: '',
        auth: '',
        protocol: '',
        slashes: null,
        port: ''
    };
    return legacyUrl;
}
function stripNextRscUnionQuery(relativeUrl) {
    const urlInstance = new URL(relativeUrl, DUMMY_ORIGIN);
    urlInstance.searchParams.delete(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$app$2d$router$2d$headers$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["NEXT_RSC_UNION_QUERY"]);
    return urlInstance.pathname + urlInstance.search;
} //# sourceMappingURL=url.js.map
}),
"[project]/node_modules/next/dist/esm/lib/picocolors.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// ISC License
// Copyright (c) 2021 Alexey Raspopov, Kostiantyn Denysov, Anton Verinov
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
//
// https://github.com/alexeyraspopov/picocolors/blob/b6261487e7b81aaab2440e397a356732cad9e342/picocolors.js#L1
__turbopack_context__.s({
    "bgBlack": ()=>bgBlack,
    "bgBlue": ()=>bgBlue,
    "bgCyan": ()=>bgCyan,
    "bgGreen": ()=>bgGreen,
    "bgMagenta": ()=>bgMagenta,
    "bgRed": ()=>bgRed,
    "bgWhite": ()=>bgWhite,
    "bgYellow": ()=>bgYellow,
    "black": ()=>black,
    "blue": ()=>blue,
    "bold": ()=>bold,
    "cyan": ()=>cyan,
    "dim": ()=>dim,
    "gray": ()=>gray,
    "green": ()=>green,
    "hidden": ()=>hidden,
    "inverse": ()=>inverse,
    "italic": ()=>italic,
    "magenta": ()=>magenta,
    "purple": ()=>purple,
    "red": ()=>red,
    "reset": ()=>reset,
    "strikethrough": ()=>strikethrough,
    "underline": ()=>underline,
    "white": ()=>white,
    "yellow": ()=>yellow
});
var _globalThis;
const { env, stdout } = ((_globalThis = globalThis) == null ? void 0 : _globalThis.process) ?? {};
const enabled = env && !env.NO_COLOR && (env.FORCE_COLOR || (stdout == null ? void 0 : stdout.isTTY) && !env.CI && env.TERM !== 'dumb');
const replaceClose = (str, close, replace, index)=>{
    const start = str.substring(0, index) + replace;
    const end = str.substring(index + close.length);
    const nextIndex = end.indexOf(close);
    return ~nextIndex ? start + replaceClose(end, close, replace, nextIndex) : start + end;
};
const formatter = (open, close, replace = open)=>{
    if (!enabled) return String;
    return (input)=>{
        const string = '' + input;
        const index = string.indexOf(close, open.length);
        return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;
    };
};
const reset = enabled ? (s)=>`\x1b[0m${s}\x1b[0m` : String;
const bold = formatter('\x1b[1m', '\x1b[22m', '\x1b[22m\x1b[1m');
const dim = formatter('\x1b[2m', '\x1b[22m', '\x1b[22m\x1b[2m');
const italic = formatter('\x1b[3m', '\x1b[23m');
const underline = formatter('\x1b[4m', '\x1b[24m');
const inverse = formatter('\x1b[7m', '\x1b[27m');
const hidden = formatter('\x1b[8m', '\x1b[28m');
const strikethrough = formatter('\x1b[9m', '\x1b[29m');
const black = formatter('\x1b[30m', '\x1b[39m');
const red = formatter('\x1b[31m', '\x1b[39m');
const green = formatter('\x1b[32m', '\x1b[39m');
const yellow = formatter('\x1b[33m', '\x1b[39m');
const blue = formatter('\x1b[34m', '\x1b[39m');
const magenta = formatter('\x1b[35m', '\x1b[39m');
const purple = formatter('\x1b[38;2;173;127;168m', '\x1b[39m');
const cyan = formatter('\x1b[36m', '\x1b[39m');
const white = formatter('\x1b[37m', '\x1b[39m');
const gray = formatter('\x1b[90m', '\x1b[39m');
const bgBlack = formatter('\x1b[40m', '\x1b[49m');
const bgRed = formatter('\x1b[41m', '\x1b[49m');
const bgGreen = formatter('\x1b[42m', '\x1b[49m');
const bgYellow = formatter('\x1b[43m', '\x1b[49m');
const bgBlue = formatter('\x1b[44m', '\x1b[49m');
const bgMagenta = formatter('\x1b[45m', '\x1b[49m');
const bgCyan = formatter('\x1b[46m', '\x1b[49m');
const bgWhite = formatter('\x1b[47m', '\x1b[49m'); //# sourceMappingURL=picocolors.js.map
}),
"[project]/node_modules/next/dist/esm/server/lib/lru-cache.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "LRUCache": ()=>LRUCache
});
class LRUCache {
    constructor(maxSize, calculateSize){
        this.cache = new Map();
        this.sizes = new Map();
        this.totalSize = 0;
        this.maxSize = maxSize;
        this.calculateSize = calculateSize || (()=>1);
    }
    set(key, value) {
        if (!key || !value) return;
        const size = this.calculateSize(value);
        if (size > this.maxSize) {
            console.warn('Single item size exceeds maxSize');
            return;
        }
        if (this.cache.has(key)) {
            this.totalSize -= this.sizes.get(key) || 0;
        }
        this.cache.set(key, value);
        this.sizes.set(key, size);
        this.totalSize += size;
        this.touch(key);
    }
    has(key) {
        if (!key) return false;
        this.touch(key);
        return Boolean(this.cache.get(key));
    }
    get(key) {
        if (!key) return;
        const value = this.cache.get(key);
        if (value === undefined) {
            return undefined;
        }
        this.touch(key);
        return value;
    }
    touch(key) {
        const value = this.cache.get(key);
        if (value !== undefined) {
            this.cache.delete(key);
            this.cache.set(key, value);
            this.evictIfNecessary();
        }
    }
    evictIfNecessary() {
        while(this.totalSize > this.maxSize && this.cache.size > 0){
            this.evictLeastRecentlyUsed();
        }
    }
    evictLeastRecentlyUsed() {
        const lruKey = this.cache.keys().next().value;
        if (lruKey !== undefined) {
            const lruSize = this.sizes.get(lruKey) || 0;
            this.totalSize -= lruSize;
            this.cache.delete(lruKey);
            this.sizes.delete(lruKey);
        }
    }
    reset() {
        this.cache.clear();
        this.sizes.clear();
        this.totalSize = 0;
    }
    keys() {
        return [
            ...this.cache.keys()
        ];
    }
    remove(key) {
        if (this.cache.has(key)) {
            this.totalSize -= this.sizes.get(key) || 0;
            this.cache.delete(key);
            this.sizes.delete(key);
        }
    }
    clear() {
        this.cache.clear();
        this.sizes.clear();
        this.totalSize = 0;
    }
    get size() {
        return this.cache.size;
    }
    get currentSize() {
        return this.totalSize;
    }
} //# sourceMappingURL=lru-cache.js.map
}),
"[project]/node_modules/next/dist/esm/build/output/log.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "bootstrap": ()=>bootstrap,
    "error": ()=>error,
    "event": ()=>event,
    "info": ()=>info,
    "prefixes": ()=>prefixes,
    "ready": ()=>ready,
    "trace": ()=>trace,
    "wait": ()=>wait,
    "warn": ()=>warn,
    "warnOnce": ()=>warnOnce
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$picocolors$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/picocolors.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$lru$2d$cache$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/lib/lru-cache.js [app-rsc] (ecmascript)");
;
;
const prefixes = {
    wait: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$picocolors$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["white"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$picocolors$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["bold"])('')),
    error: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$picocolors$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["red"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$picocolors$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["bold"])('')),
    warn: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$picocolors$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["yellow"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$picocolors$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["bold"])('')),
    ready: '',
    info: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$picocolors$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["white"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$picocolors$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["bold"])(' ')),
    event: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$picocolors$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["green"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$picocolors$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["bold"])('')),
    trace: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$picocolors$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["magenta"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$picocolors$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["bold"])(''))
};
const LOGGING_METHOD = {
    log: 'log',
    warn: 'warn',
    error: 'error'
};
function prefixedLog(prefixType, ...message) {
    if ((message[0] === '' || message[0] === undefined) && message.length === 1) {
        message.shift();
    }
    const consoleMethod = prefixType in LOGGING_METHOD ? LOGGING_METHOD[prefixType] : 'log';
    const prefix = prefixes[prefixType];
    // If there's no message, don't print the prefix but a new line
    if (message.length === 0) {
        console[consoleMethod]('');
    } else {
        // Ensure if there's ANSI escape codes it's concatenated into one string.
        // Chrome DevTool can only handle color if it's in one string.
        if (message.length === 1 && typeof message[0] === 'string') {
            console[consoleMethod](' ' + prefix + ' ' + message[0]);
        } else {
            console[consoleMethod](' ' + prefix, ...message);
        }
    }
}
function bootstrap(...message) {
    // logging format: ' <prefix> <message>'
    // e.g. '  Compiled successfully'
    // Add spaces to align with the indent of other logs
    console.log('   ' + message.join(' '));
}
function wait(...message) {
    prefixedLog('wait', ...message);
}
function error(...message) {
    prefixedLog('error', ...message);
}
function warn(...message) {
    prefixedLog('warn', ...message);
}
function ready(...message) {
    prefixedLog('ready', ...message);
}
function info(...message) {
    prefixedLog('info', ...message);
}
function event(...message) {
    prefixedLog('event', ...message);
}
function trace(...message) {
    prefixedLog('trace', ...message);
}
const warnOnceCache = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$lru$2d$cache$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["LRUCache"](10000, (value)=>value.length);
function warnOnce(...message) {
    const key = message.join(' ');
    if (!warnOnceCache.has(key)) {
        warnOnceCache.set(key, key);
        warn(...message);
    }
} //# sourceMappingURL=log.js.map
}),
"[project]/node_modules/next/dist/esm/lib/metadata/resolvers/resolve-opengraph.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "resolveImages": ()=>resolveImages,
    "resolveOpenGraph": ()=>resolveOpenGraph,
    "resolveTwitter": ()=>resolveTwitter
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/metadata/generate/utils.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$resolvers$2f$resolve$2d$url$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/metadata/resolvers/resolve-url.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$resolvers$2f$resolve$2d$title$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/metadata/resolvers/resolve-title.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$url$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/url.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$build$2f$output$2f$log$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/build/output/log.js [app-rsc] (ecmascript)");
;
;
;
;
;
const OgTypeFields = {
    article: [
        'authors',
        'tags'
    ],
    song: [
        'albums',
        'musicians'
    ],
    playlist: [
        'albums',
        'musicians'
    ],
    radio: [
        'creators'
    ],
    video: [
        'actors',
        'directors',
        'writers',
        'tags'
    ],
    basic: [
        'emails',
        'phoneNumbers',
        'faxNumbers',
        'alternateLocale',
        'audio',
        'videos'
    ]
};
function resolveAndValidateImage(item, metadataBase, isStaticMetadataRouteFile) {
    if (!item) return undefined;
    const isItemUrl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$resolvers$2f$resolve$2d$url$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isStringOrURL"])(item);
    const inputUrl = isItemUrl ? item : item.url;
    if (!inputUrl) return undefined;
    // process.env.VERCEL is set to "1" when System Environment Variables are
    // exposed. When exposed, validation is not necessary since we are falling back to
    // process.env.VERCEL_PROJECT_PRODUCTION_URL, process.env.VERCEL_BRANCH_URL, or
    // process.env.VERCEL_URL for the `metadataBase`. process.env.VERCEL is undefined
    // when System Environment Variables are not exposed. When not exposed, we cannot
    // detect in the build environment if the deployment is a Vercel deployment or not.
    //
    // x-ref: https://vercel.com/docs/projects/environment-variables/system-environment-variables#system-environment-variables
    const isUsingVercelSystemEnvironmentVariables = Boolean(process.env.VERCEL);
    const isRelativeUrl = typeof inputUrl === 'string' && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$url$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isFullStringUrl"])(inputUrl);
    // When no explicit metadataBase is specified by the user, we'll override it with the fallback metadata
    // under the following conditions:
    // - The provided URL is relative (ie ./og-image).
    // - The image is statically generated by Next.js (such as the special `opengraph-image` route)
    // In both cases, we want to ensure that across all environments, the ogImage is a fully qualified URL.
    // In the `opengraph-image` case, since the user isn't explicitly passing a relative path, this ensures
    // the ogImage will be properly discovered across different environments without the user needing to
    // have a bunch of `process.env` checks when defining their `metadataBase`.
    if (isRelativeUrl && (!metadataBase || isStaticMetadataRouteFile)) {
        const fallbackMetadataBase = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$resolvers$2f$resolve$2d$url$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getSocialImageMetadataBaseFallback"])(metadataBase);
        // When not using Vercel environment variables for URL injection, we aren't able to determine
        // a fallback value for `metadataBase`. For self-hosted setups, we want to warn
        // about this since the only fallback we'll be able to generate is `localhost`.
        // In development, we'll only warn for relative metadata that isn't part of the static
        // metadata conventions (eg `opengraph-image`), as otherwise it's currently very noisy
        // for common cases. Eventually we should remove this warning all together in favor of
        // devtools.
        const shouldWarn = !isUsingVercelSystemEnvironmentVariables && !metadataBase && (("TURBOPACK compile-time value", "development") === 'production' || !isStaticMetadataRouteFile);
        if (shouldWarn) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$build$2f$output$2f$log$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["warnOnce"])(`metadataBase property in metadata export is not set for resolving social open graph or twitter images, using "${fallbackMetadataBase.origin}". See https://nextjs.org/docs/app/api-reference/functions/generate-metadata#metadatabase`);
        }
        metadataBase = fallbackMetadataBase;
    }
    return isItemUrl ? {
        url: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$resolvers$2f$resolve$2d$url$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["resolveUrl"])(inputUrl, metadataBase)
    } : {
        ...item,
        // Update image descriptor url
        url: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$resolvers$2f$resolve$2d$url$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["resolveUrl"])(inputUrl, metadataBase)
    };
}
function resolveImages(images, metadataBase, isStaticMetadataRouteFile) {
    const resolvedImages = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["resolveAsArrayOrUndefined"])(images);
    if (!resolvedImages) return resolvedImages;
    const nonNullableImages = [];
    for (const item of resolvedImages){
        const resolvedItem = resolveAndValidateImage(item, metadataBase, isStaticMetadataRouteFile);
        if (!resolvedItem) continue;
        nonNullableImages.push(resolvedItem);
    }
    return nonNullableImages;
}
const ogTypeToFields = {
    article: OgTypeFields.article,
    book: OgTypeFields.article,
    'music.song': OgTypeFields.song,
    'music.album': OgTypeFields.song,
    'music.playlist': OgTypeFields.playlist,
    'music.radio_station': OgTypeFields.radio,
    'video.movie': OgTypeFields.video,
    'video.episode': OgTypeFields.video
};
function getFieldsByOgType(ogType) {
    if (!ogType || !(ogType in ogTypeToFields)) return OgTypeFields.basic;
    return ogTypeToFields[ogType].concat(OgTypeFields.basic);
}
const resolveOpenGraph = async (openGraph, metadataBase, pathname, metadataContext, titleTemplate)=>{
    if (!openGraph) return null;
    function resolveProps(target, og) {
        const ogType = og && 'type' in og ? og.type : undefined;
        const keys = getFieldsByOgType(ogType);
        for (const k of keys){
            const key = k;
            if (key in og && key !== 'url') {
                const value = og[key];
                target[key] = value ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["resolveArray"])(value) : null;
            }
        }
        target.images = resolveImages(og.images, metadataBase, metadataContext.isStaticMetadataRouteFile);
    }
    const resolved = {
        ...openGraph,
        title: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$resolvers$2f$resolve$2d$title$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["resolveTitle"])(openGraph.title, titleTemplate)
    };
    resolveProps(resolved, openGraph);
    resolved.url = openGraph.url ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$resolvers$2f$resolve$2d$url$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["resolveAbsoluteUrlWithPathname"])(openGraph.url, metadataBase, await pathname, metadataContext) : null;
    return resolved;
};
const TwitterBasicInfoKeys = [
    'site',
    'siteId',
    'creator',
    'creatorId',
    'description'
];
const resolveTwitter = (twitter, metadataBase, metadataContext, titleTemplate)=>{
    var _resolved_images;
    if (!twitter) return null;
    let card = 'card' in twitter ? twitter.card : undefined;
    const resolved = {
        ...twitter,
        title: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$resolvers$2f$resolve$2d$title$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["resolveTitle"])(twitter.title, titleTemplate)
    };
    for (const infoKey of TwitterBasicInfoKeys){
        resolved[infoKey] = twitter[infoKey] || null;
    }
    resolved.images = resolveImages(twitter.images, metadataBase, metadataContext.isStaticMetadataRouteFile);
    card = card || (((_resolved_images = resolved.images) == null ? void 0 : _resolved_images.length) ? 'summary_large_image' : 'summary');
    resolved.card = card;
    if ('card' in resolved) {
        switch(resolved.card){
            case 'player':
                {
                    resolved.players = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["resolveAsArrayOrUndefined"])(resolved.players) || [];
                    break;
                }
            case 'app':
                {
                    resolved.app = resolved.app || {};
                    break;
                }
            default:
                break;
        }
    }
    return resolved;
}; //# sourceMappingURL=resolve-opengraph.js.map
}),
"[project]/node_modules/next/dist/esm/shared/lib/segment.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "DEFAULT_SEGMENT_KEY": ()=>DEFAULT_SEGMENT_KEY,
    "PAGE_SEGMENT_KEY": ()=>PAGE_SEGMENT_KEY,
    "addSearchParamsIfPageSegment": ()=>addSearchParamsIfPageSegment,
    "isGroupSegment": ()=>isGroupSegment,
    "isParallelRouteSegment": ()=>isParallelRouteSegment
});
function isGroupSegment(segment) {
    // Use array[0] for performant purpose
    return segment[0] === '(' && segment.endsWith(')');
}
function isParallelRouteSegment(segment) {
    return segment.startsWith('@') && segment !== '@children';
}
function addSearchParamsIfPageSegment(segment, searchParams) {
    const isPageSegment = segment.includes(PAGE_SEGMENT_KEY);
    if (isPageSegment) {
        const stringifiedQuery = JSON.stringify(searchParams);
        return stringifiedQuery !== '{}' ? PAGE_SEGMENT_KEY + '?' + stringifiedQuery : PAGE_SEGMENT_KEY;
    }
    return segment;
}
const PAGE_SEGMENT_KEY = '__PAGE__';
const DEFAULT_SEGMENT_KEY = '__DEFAULT__'; //# sourceMappingURL=segment.js.map
}),
"[project]/node_modules/next/dist/esm/server/lib/app-dir-module.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "getComponentTypeModule": ()=>getComponentTypeModule,
    "getLayoutOrPageModule": ()=>getLayoutOrPageModule
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$segment$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/segment.js [app-rsc] (ecmascript)");
;
async function getLayoutOrPageModule(loaderTree) {
    const { layout, page, defaultPage } = loaderTree[2];
    const isLayout = typeof layout !== 'undefined';
    const isPage = typeof page !== 'undefined';
    const isDefaultPage = typeof defaultPage !== 'undefined' && loaderTree[0] === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$segment$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["DEFAULT_SEGMENT_KEY"];
    let mod = undefined;
    let modType = undefined;
    let filePath = undefined;
    if (isLayout) {
        mod = await layout[0]();
        modType = 'layout';
        filePath = layout[1];
    } else if (isPage) {
        mod = await page[0]();
        modType = 'page';
        filePath = page[1];
    } else if (isDefaultPage) {
        mod = await defaultPage[0]();
        modType = 'page';
        filePath = defaultPage[1];
    }
    return {
        mod,
        modType,
        filePath
    };
}
async function getComponentTypeModule(loaderTree, moduleType) {
    const { [moduleType]: module } = loaderTree[2];
    if (typeof module !== 'undefined') {
        return await module[0]();
    }
    return undefined;
} //# sourceMappingURL=app-dir-module.js.map
}),
"[project]/node_modules/next/dist/esm/lib/interop-default.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "interopDefault": ()=>interopDefault
});
function interopDefault(mod) {
    return mod.default || mod;
} //# sourceMappingURL=interop-default.js.map
}),
"[project]/node_modules/next/dist/esm/lib/metadata/resolvers/resolve-basics.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "resolveAlternates": ()=>resolveAlternates,
    "resolveAppLinks": ()=>resolveAppLinks,
    "resolveAppleWebApp": ()=>resolveAppleWebApp,
    "resolveFacebook": ()=>resolveFacebook,
    "resolveItunes": ()=>resolveItunes,
    "resolvePagination": ()=>resolvePagination,
    "resolveRobots": ()=>resolveRobots,
    "resolveThemeColor": ()=>resolveThemeColor,
    "resolveVerification": ()=>resolveVerification
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/metadata/generate/utils.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$resolvers$2f$resolve$2d$url$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/metadata/resolvers/resolve-url.js [app-rsc] (ecmascript)");
;
;
function resolveAlternateUrl(url, metadataBase, pathname, metadataContext) {
    // If alter native url is an URL instance,
    // we treat it as a URL base and resolve with current pathname
    if (url instanceof URL) {
        const newUrl = new URL(pathname, url);
        url.searchParams.forEach((value, key)=>newUrl.searchParams.set(key, value));
        url = newUrl;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$resolvers$2f$resolve$2d$url$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["resolveAbsoluteUrlWithPathname"])(url, metadataBase, pathname, metadataContext);
}
const resolveThemeColor = (themeColor)=>{
    var _resolveAsArrayOrUndefined;
    if (!themeColor) return null;
    const themeColorDescriptors = [];
    (_resolveAsArrayOrUndefined = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["resolveAsArrayOrUndefined"])(themeColor)) == null ? void 0 : _resolveAsArrayOrUndefined.forEach((descriptor)=>{
        if (typeof descriptor === 'string') themeColorDescriptors.push({
            color: descriptor
        });
        else if (typeof descriptor === 'object') themeColorDescriptors.push({
            color: descriptor.color,
            media: descriptor.media
        });
    });
    return themeColorDescriptors;
};
async function resolveUrlValuesOfObject(obj, metadataBase, pathname, metadataContext) {
    if (!obj) return null;
    const result = {};
    for (const [key, value] of Object.entries(obj)){
        if (typeof value === 'string' || value instanceof URL) {
            const pathnameForUrl = await pathname;
            result[key] = [
                {
                    url: resolveAlternateUrl(value, metadataBase, pathnameForUrl, metadataContext)
                }
            ];
        } else if (value && value.length) {
            result[key] = [];
            const pathnameForUrl = await pathname;
            value.forEach((item, index)=>{
                const url = resolveAlternateUrl(item.url, metadataBase, pathnameForUrl, metadataContext);
                result[key][index] = {
                    url,
                    title: item.title
                };
            });
        }
    }
    return result;
}
async function resolveCanonicalUrl(urlOrDescriptor, metadataBase, pathname, metadataContext) {
    if (!urlOrDescriptor) return null;
    const url = typeof urlOrDescriptor === 'string' || urlOrDescriptor instanceof URL ? urlOrDescriptor : urlOrDescriptor.url;
    const pathnameForUrl = await pathname;
    // Return string url because structureClone can't handle URL instance
    return {
        url: resolveAlternateUrl(url, metadataBase, pathnameForUrl, metadataContext)
    };
}
const resolveAlternates = async (alternates, metadataBase, pathname, context)=>{
    if (!alternates) return null;
    const canonical = await resolveCanonicalUrl(alternates.canonical, metadataBase, pathname, context);
    const languages = await resolveUrlValuesOfObject(alternates.languages, metadataBase, pathname, context);
    const media = await resolveUrlValuesOfObject(alternates.media, metadataBase, pathname, context);
    const types = await resolveUrlValuesOfObject(alternates.types, metadataBase, pathname, context);
    const result = {
        canonical,
        languages,
        media,
        types
    };
    return result;
};
const robotsKeys = [
    'noarchive',
    'nosnippet',
    'noimageindex',
    'nocache',
    'notranslate',
    'indexifembedded',
    'nositelinkssearchbox',
    'unavailable_after',
    'max-video-preview',
    'max-image-preview',
    'max-snippet'
];
const resolveRobotsValue = (robots)=>{
    if (!robots) return null;
    if (typeof robots === 'string') return robots;
    const values = [];
    if (robots.index) values.push('index');
    else if (typeof robots.index === 'boolean') values.push('noindex');
    if (robots.follow) values.push('follow');
    else if (typeof robots.follow === 'boolean') values.push('nofollow');
    for (const key of robotsKeys){
        const value = robots[key];
        if (typeof value !== 'undefined' && value !== false) {
            values.push(typeof value === 'boolean' ? key : `${key}:${value}`);
        }
    }
    return values.join(', ');
};
const resolveRobots = (robots)=>{
    if (!robots) return null;
    return {
        basic: resolveRobotsValue(robots),
        googleBot: typeof robots !== 'string' ? resolveRobotsValue(robots.googleBot) : null
    };
};
const VerificationKeys = [
    'google',
    'yahoo',
    'yandex',
    'me',
    'other'
];
const resolveVerification = (verification)=>{
    if (!verification) return null;
    const res = {};
    for (const key of VerificationKeys){
        const value = verification[key];
        if (value) {
            if (key === 'other') {
                res.other = {};
                for(const otherKey in verification.other){
                    const otherValue = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["resolveAsArrayOrUndefined"])(verification.other[otherKey]);
                    if (otherValue) res.other[otherKey] = otherValue;
                }
            } else res[key] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["resolveAsArrayOrUndefined"])(value);
        }
    }
    return res;
};
const resolveAppleWebApp = (appWebApp)=>{
    var _resolveAsArrayOrUndefined;
    if (!appWebApp) return null;
    if (appWebApp === true) {
        return {
            capable: true
        };
    }
    const startupImages = appWebApp.startupImage ? (_resolveAsArrayOrUndefined = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["resolveAsArrayOrUndefined"])(appWebApp.startupImage)) == null ? void 0 : _resolveAsArrayOrUndefined.map((item)=>typeof item === 'string' ? {
            url: item
        } : item) : null;
    return {
        capable: 'capable' in appWebApp ? !!appWebApp.capable : true,
        title: appWebApp.title || null,
        startupImage: startupImages,
        statusBarStyle: appWebApp.statusBarStyle || 'default'
    };
};
const resolveAppLinks = (appLinks)=>{
    if (!appLinks) return null;
    for(const key in appLinks){
        // @ts-ignore // TODO: type infer
        appLinks[key] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["resolveAsArrayOrUndefined"])(appLinks[key]);
    }
    return appLinks;
};
const resolveItunes = async (itunes, metadataBase, pathname, context)=>{
    if (!itunes) return null;
    return {
        appId: itunes.appId,
        appArgument: itunes.appArgument ? resolveAlternateUrl(itunes.appArgument, metadataBase, await pathname, context) : undefined
    };
};
const resolveFacebook = (facebook)=>{
    if (!facebook) return null;
    return {
        appId: facebook.appId,
        admins: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["resolveAsArrayOrUndefined"])(facebook.admins)
    };
};
const resolvePagination = async (pagination, metadataBase, pathname, context)=>{
    return {
        previous: (pagination == null ? void 0 : pagination.previous) ? resolveAlternateUrl(pagination.previous, metadataBase, await pathname, context) : null,
        next: (pagination == null ? void 0 : pagination.next) ? resolveAlternateUrl(pagination.next, metadataBase, await pathname, context) : null
    };
}; //# sourceMappingURL=resolve-basics.js.map
}),
"[project]/node_modules/next/dist/esm/lib/metadata/resolvers/resolve-icons.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "resolveIcon": ()=>resolveIcon,
    "resolveIcons": ()=>resolveIcons
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/metadata/generate/utils.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$resolvers$2f$resolve$2d$url$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/metadata/resolvers/resolve-url.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/metadata/constants.js [app-rsc] (ecmascript)");
;
;
;
function resolveIcon(icon) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$resolvers$2f$resolve$2d$url$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isStringOrURL"])(icon)) return {
        url: icon
    };
    else if (Array.isArray(icon)) return icon;
    return icon;
}
const resolveIcons = (icons)=>{
    if (!icons) {
        return null;
    }
    const resolved = {
        icon: [],
        apple: []
    };
    if (Array.isArray(icons)) {
        resolved.icon = icons.map(resolveIcon).filter(Boolean);
    } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$resolvers$2f$resolve$2d$url$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isStringOrURL"])(icons)) {
        resolved.icon = [
            resolveIcon(icons)
        ];
    } else {
        for (const key of __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["IconKeys"]){
            const values = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["resolveAsArrayOrUndefined"])(icons[key]);
            if (values) resolved[key] = values.map(resolveIcon);
        }
    }
    return resolved;
}; //# sourceMappingURL=resolve-icons.js.map
}),
"[project]/node_modules/next/dist/esm/server/lib/trace/constants.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * Contains predefined constants for the trace span name in next/server.
 *
 * Currently, next/server/tracer is internal implementation only for tracking
 * next.js's implementation only with known span names defined here.
 **/ // eslint typescript has a bug with TS enums
/* eslint-disable no-shadow */ __turbopack_context__.s({
    "AppRenderSpan": ()=>AppRenderSpan,
    "AppRouteRouteHandlersSpan": ()=>AppRouteRouteHandlersSpan,
    "BaseServerSpan": ()=>BaseServerSpan,
    "LoadComponentsSpan": ()=>LoadComponentsSpan,
    "LogSpanAllowList": ()=>LogSpanAllowList,
    "MiddlewareSpan": ()=>MiddlewareSpan,
    "NextNodeServerSpan": ()=>NextNodeServerSpan,
    "NextServerSpan": ()=>NextServerSpan,
    "NextVanillaSpanAllowlist": ()=>NextVanillaSpanAllowlist,
    "NodeSpan": ()=>NodeSpan,
    "RenderSpan": ()=>RenderSpan,
    "ResolveMetadataSpan": ()=>ResolveMetadataSpan,
    "RouterSpan": ()=>RouterSpan,
    "StartServerSpan": ()=>StartServerSpan
});
var BaseServerSpan = /*#__PURE__*/ function(BaseServerSpan) {
    BaseServerSpan["handleRequest"] = "BaseServer.handleRequest";
    BaseServerSpan["run"] = "BaseServer.run";
    BaseServerSpan["pipe"] = "BaseServer.pipe";
    BaseServerSpan["getStaticHTML"] = "BaseServer.getStaticHTML";
    BaseServerSpan["render"] = "BaseServer.render";
    BaseServerSpan["renderToResponseWithComponents"] = "BaseServer.renderToResponseWithComponents";
    BaseServerSpan["renderToResponse"] = "BaseServer.renderToResponse";
    BaseServerSpan["renderToHTML"] = "BaseServer.renderToHTML";
    BaseServerSpan["renderError"] = "BaseServer.renderError";
    BaseServerSpan["renderErrorToResponse"] = "BaseServer.renderErrorToResponse";
    BaseServerSpan["renderErrorToHTML"] = "BaseServer.renderErrorToHTML";
    BaseServerSpan["render404"] = "BaseServer.render404";
    return BaseServerSpan;
}(BaseServerSpan || {});
var LoadComponentsSpan = /*#__PURE__*/ function(LoadComponentsSpan) {
    LoadComponentsSpan["loadDefaultErrorComponents"] = "LoadComponents.loadDefaultErrorComponents";
    LoadComponentsSpan["loadComponents"] = "LoadComponents.loadComponents";
    return LoadComponentsSpan;
}(LoadComponentsSpan || {});
var NextServerSpan = /*#__PURE__*/ function(NextServerSpan) {
    NextServerSpan["getRequestHandler"] = "NextServer.getRequestHandler";
    NextServerSpan["getServer"] = "NextServer.getServer";
    NextServerSpan["getServerRequestHandler"] = "NextServer.getServerRequestHandler";
    NextServerSpan["createServer"] = "createServer.createServer";
    return NextServerSpan;
}(NextServerSpan || {});
var NextNodeServerSpan = /*#__PURE__*/ function(NextNodeServerSpan) {
    NextNodeServerSpan["compression"] = "NextNodeServer.compression";
    NextNodeServerSpan["getBuildId"] = "NextNodeServer.getBuildId";
    NextNodeServerSpan["createComponentTree"] = "NextNodeServer.createComponentTree";
    NextNodeServerSpan["clientComponentLoading"] = "NextNodeServer.clientComponentLoading";
    NextNodeServerSpan["getLayoutOrPageModule"] = "NextNodeServer.getLayoutOrPageModule";
    NextNodeServerSpan["generateStaticRoutes"] = "NextNodeServer.generateStaticRoutes";
    NextNodeServerSpan["generateFsStaticRoutes"] = "NextNodeServer.generateFsStaticRoutes";
    NextNodeServerSpan["generatePublicRoutes"] = "NextNodeServer.generatePublicRoutes";
    NextNodeServerSpan["generateImageRoutes"] = "NextNodeServer.generateImageRoutes.route";
    NextNodeServerSpan["sendRenderResult"] = "NextNodeServer.sendRenderResult";
    NextNodeServerSpan["proxyRequest"] = "NextNodeServer.proxyRequest";
    NextNodeServerSpan["runApi"] = "NextNodeServer.runApi";
    NextNodeServerSpan["render"] = "NextNodeServer.render";
    NextNodeServerSpan["renderHTML"] = "NextNodeServer.renderHTML";
    NextNodeServerSpan["imageOptimizer"] = "NextNodeServer.imageOptimizer";
    NextNodeServerSpan["getPagePath"] = "NextNodeServer.getPagePath";
    NextNodeServerSpan["getRoutesManifest"] = "NextNodeServer.getRoutesManifest";
    NextNodeServerSpan["findPageComponents"] = "NextNodeServer.findPageComponents";
    NextNodeServerSpan["getFontManifest"] = "NextNodeServer.getFontManifest";
    NextNodeServerSpan["getServerComponentManifest"] = "NextNodeServer.getServerComponentManifest";
    NextNodeServerSpan["getRequestHandler"] = "NextNodeServer.getRequestHandler";
    NextNodeServerSpan["renderToHTML"] = "NextNodeServer.renderToHTML";
    NextNodeServerSpan["renderError"] = "NextNodeServer.renderError";
    NextNodeServerSpan["renderErrorToHTML"] = "NextNodeServer.renderErrorToHTML";
    NextNodeServerSpan["render404"] = "NextNodeServer.render404";
    NextNodeServerSpan["startResponse"] = "NextNodeServer.startResponse";
    // nested inner span, does not require parent scope name
    NextNodeServerSpan["route"] = "route";
    NextNodeServerSpan["onProxyReq"] = "onProxyReq";
    NextNodeServerSpan["apiResolver"] = "apiResolver";
    NextNodeServerSpan["internalFetch"] = "internalFetch";
    return NextNodeServerSpan;
}(NextNodeServerSpan || {});
var StartServerSpan = /*#__PURE__*/ function(StartServerSpan) {
    StartServerSpan["startServer"] = "startServer.startServer";
    return StartServerSpan;
}(StartServerSpan || {});
var RenderSpan = /*#__PURE__*/ function(RenderSpan) {
    RenderSpan["getServerSideProps"] = "Render.getServerSideProps";
    RenderSpan["getStaticProps"] = "Render.getStaticProps";
    RenderSpan["renderToString"] = "Render.renderToString";
    RenderSpan["renderDocument"] = "Render.renderDocument";
    RenderSpan["createBodyResult"] = "Render.createBodyResult";
    return RenderSpan;
}(RenderSpan || {});
var AppRenderSpan = /*#__PURE__*/ function(AppRenderSpan) {
    AppRenderSpan["renderToString"] = "AppRender.renderToString";
    AppRenderSpan["renderToReadableStream"] = "AppRender.renderToReadableStream";
    AppRenderSpan["getBodyResult"] = "AppRender.getBodyResult";
    AppRenderSpan["fetch"] = "AppRender.fetch";
    return AppRenderSpan;
}(AppRenderSpan || {});
var RouterSpan = /*#__PURE__*/ function(RouterSpan) {
    RouterSpan["executeRoute"] = "Router.executeRoute";
    return RouterSpan;
}(RouterSpan || {});
var NodeSpan = /*#__PURE__*/ function(NodeSpan) {
    NodeSpan["runHandler"] = "Node.runHandler";
    return NodeSpan;
}(NodeSpan || {});
var AppRouteRouteHandlersSpan = /*#__PURE__*/ function(AppRouteRouteHandlersSpan) {
    AppRouteRouteHandlersSpan["runHandler"] = "AppRouteRouteHandlers.runHandler";
    return AppRouteRouteHandlersSpan;
}(AppRouteRouteHandlersSpan || {});
var ResolveMetadataSpan = /*#__PURE__*/ function(ResolveMetadataSpan) {
    ResolveMetadataSpan["generateMetadata"] = "ResolveMetadata.generateMetadata";
    ResolveMetadataSpan["generateViewport"] = "ResolveMetadata.generateViewport";
    return ResolveMetadataSpan;
}(ResolveMetadataSpan || {});
var MiddlewareSpan = /*#__PURE__*/ function(MiddlewareSpan) {
    MiddlewareSpan["execute"] = "Middleware.execute";
    return MiddlewareSpan;
}(MiddlewareSpan || {});
const NextVanillaSpanAllowlist = [
    "Middleware.execute",
    "BaseServer.handleRequest",
    "Render.getServerSideProps",
    "Render.getStaticProps",
    "AppRender.fetch",
    "AppRender.getBodyResult",
    "Render.renderDocument",
    "Node.runHandler",
    "AppRouteRouteHandlers.runHandler",
    "ResolveMetadata.generateMetadata",
    "ResolveMetadata.generateViewport",
    "NextNodeServer.createComponentTree",
    "NextNodeServer.findPageComponents",
    "NextNodeServer.getLayoutOrPageModule",
    "NextNodeServer.startResponse",
    "NextNodeServer.clientComponentLoading"
];
const LogSpanAllowList = [
    "NextNodeServer.findPageComponents",
    "NextNodeServer.createComponentTree",
    "NextNodeServer.clientComponentLoading"
];
;
 //# sourceMappingURL=constants.js.map
}),
"[project]/node_modules/next/dist/esm/shared/lib/is-thenable.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * Check to see if a value is Thenable.
 *
 * @param promise the maybe-thenable value
 * @returns true if the value is thenable
 */ __turbopack_context__.s({
    "isThenable": ()=>isThenable
});
function isThenable(promise) {
    return promise !== null && typeof promise === 'object' && 'then' in promise && typeof promise.then === 'function';
} //# sourceMappingURL=is-thenable.js.map
}),
"[project]/node_modules/next/dist/compiled/@opentelemetry/api/index.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
(()=>{
    "use strict";
    var e = {
        491: (e, t, r)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.ContextAPI = void 0;
            const n = r(223);
            const a = r(172);
            const o = r(930);
            const i = "context";
            const c = new n.NoopContextManager;
            class ContextAPI {
                constructor(){}
                static getInstance() {
                    if (!this._instance) {
                        this._instance = new ContextAPI;
                    }
                    return this._instance;
                }
                setGlobalContextManager(e) {
                    return (0, a.registerGlobal)(i, e, o.DiagAPI.instance());
                }
                active() {
                    return this._getContextManager().active();
                }
                with(e, t, r, ...n) {
                    return this._getContextManager().with(e, t, r, ...n);
                }
                bind(e, t) {
                    return this._getContextManager().bind(e, t);
                }
                _getContextManager() {
                    return (0, a.getGlobal)(i) || c;
                }
                disable() {
                    this._getContextManager().disable();
                    (0, a.unregisterGlobal)(i, o.DiagAPI.instance());
                }
            }
            t.ContextAPI = ContextAPI;
        },
        930: (e, t, r)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.DiagAPI = void 0;
            const n = r(56);
            const a = r(912);
            const o = r(957);
            const i = r(172);
            const c = "diag";
            class DiagAPI {
                constructor(){
                    function _logProxy(e) {
                        return function(...t) {
                            const r = (0, i.getGlobal)("diag");
                            if (!r) return;
                            return r[e](...t);
                        };
                    }
                    const e = this;
                    const setLogger = (t, r = {
                        logLevel: o.DiagLogLevel.INFO
                    })=>{
                        var n, c, s;
                        if (t === e) {
                            const t = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
                            e.error((n = t.stack) !== null && n !== void 0 ? n : t.message);
                            return false;
                        }
                        if (typeof r === "number") {
                            r = {
                                logLevel: r
                            };
                        }
                        const u = (0, i.getGlobal)("diag");
                        const l = (0, a.createLogLevelDiagLogger)((c = r.logLevel) !== null && c !== void 0 ? c : o.DiagLogLevel.INFO, t);
                        if (u && !r.suppressOverrideMessage) {
                            const e = (s = (new Error).stack) !== null && s !== void 0 ? s : "<failed to generate stacktrace>";
                            u.warn(`Current logger will be overwritten from ${e}`);
                            l.warn(`Current logger will overwrite one already registered from ${e}`);
                        }
                        return (0, i.registerGlobal)("diag", l, e, true);
                    };
                    e.setLogger = setLogger;
                    e.disable = ()=>{
                        (0, i.unregisterGlobal)(c, e);
                    };
                    e.createComponentLogger = (e)=>new n.DiagComponentLogger(e);
                    e.verbose = _logProxy("verbose");
                    e.debug = _logProxy("debug");
                    e.info = _logProxy("info");
                    e.warn = _logProxy("warn");
                    e.error = _logProxy("error");
                }
                static instance() {
                    if (!this._instance) {
                        this._instance = new DiagAPI;
                    }
                    return this._instance;
                }
            }
            t.DiagAPI = DiagAPI;
        },
        653: (e, t, r)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.MetricsAPI = void 0;
            const n = r(660);
            const a = r(172);
            const o = r(930);
            const i = "metrics";
            class MetricsAPI {
                constructor(){}
                static getInstance() {
                    if (!this._instance) {
                        this._instance = new MetricsAPI;
                    }
                    return this._instance;
                }
                setGlobalMeterProvider(e) {
                    return (0, a.registerGlobal)(i, e, o.DiagAPI.instance());
                }
                getMeterProvider() {
                    return (0, a.getGlobal)(i) || n.NOOP_METER_PROVIDER;
                }
                getMeter(e, t, r) {
                    return this.getMeterProvider().getMeter(e, t, r);
                }
                disable() {
                    (0, a.unregisterGlobal)(i, o.DiagAPI.instance());
                }
            }
            t.MetricsAPI = MetricsAPI;
        },
        181: (e, t, r)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.PropagationAPI = void 0;
            const n = r(172);
            const a = r(874);
            const o = r(194);
            const i = r(277);
            const c = r(369);
            const s = r(930);
            const u = "propagation";
            const l = new a.NoopTextMapPropagator;
            class PropagationAPI {
                constructor(){
                    this.createBaggage = c.createBaggage;
                    this.getBaggage = i.getBaggage;
                    this.getActiveBaggage = i.getActiveBaggage;
                    this.setBaggage = i.setBaggage;
                    this.deleteBaggage = i.deleteBaggage;
                }
                static getInstance() {
                    if (!this._instance) {
                        this._instance = new PropagationAPI;
                    }
                    return this._instance;
                }
                setGlobalPropagator(e) {
                    return (0, n.registerGlobal)(u, e, s.DiagAPI.instance());
                }
                inject(e, t, r = o.defaultTextMapSetter) {
                    return this._getGlobalPropagator().inject(e, t, r);
                }
                extract(e, t, r = o.defaultTextMapGetter) {
                    return this._getGlobalPropagator().extract(e, t, r);
                }
                fields() {
                    return this._getGlobalPropagator().fields();
                }
                disable() {
                    (0, n.unregisterGlobal)(u, s.DiagAPI.instance());
                }
                _getGlobalPropagator() {
                    return (0, n.getGlobal)(u) || l;
                }
            }
            t.PropagationAPI = PropagationAPI;
        },
        997: (e, t, r)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.TraceAPI = void 0;
            const n = r(172);
            const a = r(846);
            const o = r(139);
            const i = r(607);
            const c = r(930);
            const s = "trace";
            class TraceAPI {
                constructor(){
                    this._proxyTracerProvider = new a.ProxyTracerProvider;
                    this.wrapSpanContext = o.wrapSpanContext;
                    this.isSpanContextValid = o.isSpanContextValid;
                    this.deleteSpan = i.deleteSpan;
                    this.getSpan = i.getSpan;
                    this.getActiveSpan = i.getActiveSpan;
                    this.getSpanContext = i.getSpanContext;
                    this.setSpan = i.setSpan;
                    this.setSpanContext = i.setSpanContext;
                }
                static getInstance() {
                    if (!this._instance) {
                        this._instance = new TraceAPI;
                    }
                    return this._instance;
                }
                setGlobalTracerProvider(e) {
                    const t = (0, n.registerGlobal)(s, this._proxyTracerProvider, c.DiagAPI.instance());
                    if (t) {
                        this._proxyTracerProvider.setDelegate(e);
                    }
                    return t;
                }
                getTracerProvider() {
                    return (0, n.getGlobal)(s) || this._proxyTracerProvider;
                }
                getTracer(e, t) {
                    return this.getTracerProvider().getTracer(e, t);
                }
                disable() {
                    (0, n.unregisterGlobal)(s, c.DiagAPI.instance());
                    this._proxyTracerProvider = new a.ProxyTracerProvider;
                }
            }
            t.TraceAPI = TraceAPI;
        },
        277: (e, t, r)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.deleteBaggage = t.setBaggage = t.getActiveBaggage = t.getBaggage = void 0;
            const n = r(491);
            const a = r(780);
            const o = (0, a.createContextKey)("OpenTelemetry Baggage Key");
            function getBaggage(e) {
                return e.getValue(o) || undefined;
            }
            t.getBaggage = getBaggage;
            function getActiveBaggage() {
                return getBaggage(n.ContextAPI.getInstance().active());
            }
            t.getActiveBaggage = getActiveBaggage;
            function setBaggage(e, t) {
                return e.setValue(o, t);
            }
            t.setBaggage = setBaggage;
            function deleteBaggage(e) {
                return e.deleteValue(o);
            }
            t.deleteBaggage = deleteBaggage;
        },
        993: (e, t)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.BaggageImpl = void 0;
            class BaggageImpl {
                constructor(e){
                    this._entries = e ? new Map(e) : new Map;
                }
                getEntry(e) {
                    const t = this._entries.get(e);
                    if (!t) {
                        return undefined;
                    }
                    return Object.assign({}, t);
                }
                getAllEntries() {
                    return Array.from(this._entries.entries()).map(([e, t])=>[
                            e,
                            t
                        ]);
                }
                setEntry(e, t) {
                    const r = new BaggageImpl(this._entries);
                    r._entries.set(e, t);
                    return r;
                }
                removeEntry(e) {
                    const t = new BaggageImpl(this._entries);
                    t._entries.delete(e);
                    return t;
                }
                removeEntries(...e) {
                    const t = new BaggageImpl(this._entries);
                    for (const r of e){
                        t._entries.delete(r);
                    }
                    return t;
                }
                clear() {
                    return new BaggageImpl;
                }
            }
            t.BaggageImpl = BaggageImpl;
        },
        830: (e, t)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.baggageEntryMetadataSymbol = void 0;
            t.baggageEntryMetadataSymbol = Symbol("BaggageEntryMetadata");
        },
        369: (e, t, r)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.baggageEntryMetadataFromString = t.createBaggage = void 0;
            const n = r(930);
            const a = r(993);
            const o = r(830);
            const i = n.DiagAPI.instance();
            function createBaggage(e = {}) {
                return new a.BaggageImpl(new Map(Object.entries(e)));
            }
            t.createBaggage = createBaggage;
            function baggageEntryMetadataFromString(e) {
                if (typeof e !== "string") {
                    i.error(`Cannot create baggage metadata from unknown type: ${typeof e}`);
                    e = "";
                }
                return {
                    __TYPE__: o.baggageEntryMetadataSymbol,
                    toString () {
                        return e;
                    }
                };
            }
            t.baggageEntryMetadataFromString = baggageEntryMetadataFromString;
        },
        67: (e, t, r)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.context = void 0;
            const n = r(491);
            t.context = n.ContextAPI.getInstance();
        },
        223: (e, t, r)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.NoopContextManager = void 0;
            const n = r(780);
            class NoopContextManager {
                active() {
                    return n.ROOT_CONTEXT;
                }
                with(e, t, r, ...n) {
                    return t.call(r, ...n);
                }
                bind(e, t) {
                    return t;
                }
                enable() {
                    return this;
                }
                disable() {
                    return this;
                }
            }
            t.NoopContextManager = NoopContextManager;
        },
        780: (e, t)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.ROOT_CONTEXT = t.createContextKey = void 0;
            function createContextKey(e) {
                return Symbol.for(e);
            }
            t.createContextKey = createContextKey;
            class BaseContext {
                constructor(e){
                    const t = this;
                    t._currentContext = e ? new Map(e) : new Map;
                    t.getValue = (e)=>t._currentContext.get(e);
                    t.setValue = (e, r)=>{
                        const n = new BaseContext(t._currentContext);
                        n._currentContext.set(e, r);
                        return n;
                    };
                    t.deleteValue = (e)=>{
                        const r = new BaseContext(t._currentContext);
                        r._currentContext.delete(e);
                        return r;
                    };
                }
            }
            t.ROOT_CONTEXT = new BaseContext;
        },
        506: (e, t, r)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.diag = void 0;
            const n = r(930);
            t.diag = n.DiagAPI.instance();
        },
        56: (e, t, r)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.DiagComponentLogger = void 0;
            const n = r(172);
            class DiagComponentLogger {
                constructor(e){
                    this._namespace = e.namespace || "DiagComponentLogger";
                }
                debug(...e) {
                    return logProxy("debug", this._namespace, e);
                }
                error(...e) {
                    return logProxy("error", this._namespace, e);
                }
                info(...e) {
                    return logProxy("info", this._namespace, e);
                }
                warn(...e) {
                    return logProxy("warn", this._namespace, e);
                }
                verbose(...e) {
                    return logProxy("verbose", this._namespace, e);
                }
            }
            t.DiagComponentLogger = DiagComponentLogger;
            function logProxy(e, t, r) {
                const a = (0, n.getGlobal)("diag");
                if (!a) {
                    return;
                }
                r.unshift(t);
                return a[e](...r);
            }
        },
        972: (e, t)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.DiagConsoleLogger = void 0;
            const r = [
                {
                    n: "error",
                    c: "error"
                },
                {
                    n: "warn",
                    c: "warn"
                },
                {
                    n: "info",
                    c: "info"
                },
                {
                    n: "debug",
                    c: "debug"
                },
                {
                    n: "verbose",
                    c: "trace"
                }
            ];
            class DiagConsoleLogger {
                constructor(){
                    function _consoleFunc(e) {
                        return function(...t) {
                            if (console) {
                                let r = console[e];
                                if (typeof r !== "function") {
                                    r = console.log;
                                }
                                if (typeof r === "function") {
                                    return r.apply(console, t);
                                }
                            }
                        };
                    }
                    for(let e = 0; e < r.length; e++){
                        this[r[e].n] = _consoleFunc(r[e].c);
                    }
                }
            }
            t.DiagConsoleLogger = DiagConsoleLogger;
        },
        912: (e, t, r)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.createLogLevelDiagLogger = void 0;
            const n = r(957);
            function createLogLevelDiagLogger(e, t) {
                if (e < n.DiagLogLevel.NONE) {
                    e = n.DiagLogLevel.NONE;
                } else if (e > n.DiagLogLevel.ALL) {
                    e = n.DiagLogLevel.ALL;
                }
                t = t || {};
                function _filterFunc(r, n) {
                    const a = t[r];
                    if (typeof a === "function" && e >= n) {
                        return a.bind(t);
                    }
                    return function() {};
                }
                return {
                    error: _filterFunc("error", n.DiagLogLevel.ERROR),
                    warn: _filterFunc("warn", n.DiagLogLevel.WARN),
                    info: _filterFunc("info", n.DiagLogLevel.INFO),
                    debug: _filterFunc("debug", n.DiagLogLevel.DEBUG),
                    verbose: _filterFunc("verbose", n.DiagLogLevel.VERBOSE)
                };
            }
            t.createLogLevelDiagLogger = createLogLevelDiagLogger;
        },
        957: (e, t)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.DiagLogLevel = void 0;
            var r;
            (function(e) {
                e[e["NONE"] = 0] = "NONE";
                e[e["ERROR"] = 30] = "ERROR";
                e[e["WARN"] = 50] = "WARN";
                e[e["INFO"] = 60] = "INFO";
                e[e["DEBUG"] = 70] = "DEBUG";
                e[e["VERBOSE"] = 80] = "VERBOSE";
                e[e["ALL"] = 9999] = "ALL";
            })(r = t.DiagLogLevel || (t.DiagLogLevel = {}));
        },
        172: (e, t, r)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.unregisterGlobal = t.getGlobal = t.registerGlobal = void 0;
            const n = r(200);
            const a = r(521);
            const o = r(130);
            const i = a.VERSION.split(".")[0];
            const c = Symbol.for(`opentelemetry.js.api.${i}`);
            const s = n._globalThis;
            function registerGlobal(e, t, r, n = false) {
                var o;
                const i = s[c] = (o = s[c]) !== null && o !== void 0 ? o : {
                    version: a.VERSION
                };
                if (!n && i[e]) {
                    const t = new Error(`@opentelemetry/api: Attempted duplicate registration of API: ${e}`);
                    r.error(t.stack || t.message);
                    return false;
                }
                if (i.version !== a.VERSION) {
                    const t = new Error(`@opentelemetry/api: Registration of version v${i.version} for ${e} does not match previously registered API v${a.VERSION}`);
                    r.error(t.stack || t.message);
                    return false;
                }
                i[e] = t;
                r.debug(`@opentelemetry/api: Registered a global for ${e} v${a.VERSION}.`);
                return true;
            }
            t.registerGlobal = registerGlobal;
            function getGlobal(e) {
                var t, r;
                const n = (t = s[c]) === null || t === void 0 ? void 0 : t.version;
                if (!n || !(0, o.isCompatible)(n)) {
                    return;
                }
                return (r = s[c]) === null || r === void 0 ? void 0 : r[e];
            }
            t.getGlobal = getGlobal;
            function unregisterGlobal(e, t) {
                t.debug(`@opentelemetry/api: Unregistering a global for ${e} v${a.VERSION}.`);
                const r = s[c];
                if (r) {
                    delete r[e];
                }
            }
            t.unregisterGlobal = unregisterGlobal;
        },
        130: (e, t, r)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.isCompatible = t._makeCompatibilityCheck = void 0;
            const n = r(521);
            const a = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
            function _makeCompatibilityCheck(e) {
                const t = new Set([
                    e
                ]);
                const r = new Set;
                const n = e.match(a);
                if (!n) {
                    return ()=>false;
                }
                const o = {
                    major: +n[1],
                    minor: +n[2],
                    patch: +n[3],
                    prerelease: n[4]
                };
                if (o.prerelease != null) {
                    return function isExactmatch(t) {
                        return t === e;
                    };
                }
                function _reject(e) {
                    r.add(e);
                    return false;
                }
                function _accept(e) {
                    t.add(e);
                    return true;
                }
                return function isCompatible(e) {
                    if (t.has(e)) {
                        return true;
                    }
                    if (r.has(e)) {
                        return false;
                    }
                    const n = e.match(a);
                    if (!n) {
                        return _reject(e);
                    }
                    const i = {
                        major: +n[1],
                        minor: +n[2],
                        patch: +n[3],
                        prerelease: n[4]
                    };
                    if (i.prerelease != null) {
                        return _reject(e);
                    }
                    if (o.major !== i.major) {
                        return _reject(e);
                    }
                    if (o.major === 0) {
                        if (o.minor === i.minor && o.patch <= i.patch) {
                            return _accept(e);
                        }
                        return _reject(e);
                    }
                    if (o.minor <= i.minor) {
                        return _accept(e);
                    }
                    return _reject(e);
                };
            }
            t._makeCompatibilityCheck = _makeCompatibilityCheck;
            t.isCompatible = _makeCompatibilityCheck(n.VERSION);
        },
        886: (e, t, r)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.metrics = void 0;
            const n = r(653);
            t.metrics = n.MetricsAPI.getInstance();
        },
        901: (e, t)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.ValueType = void 0;
            var r;
            (function(e) {
                e[e["INT"] = 0] = "INT";
                e[e["DOUBLE"] = 1] = "DOUBLE";
            })(r = t.ValueType || (t.ValueType = {}));
        },
        102: (e, t)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.createNoopMeter = t.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = t.NOOP_OBSERVABLE_GAUGE_METRIC = t.NOOP_OBSERVABLE_COUNTER_METRIC = t.NOOP_UP_DOWN_COUNTER_METRIC = t.NOOP_HISTOGRAM_METRIC = t.NOOP_COUNTER_METRIC = t.NOOP_METER = t.NoopObservableUpDownCounterMetric = t.NoopObservableGaugeMetric = t.NoopObservableCounterMetric = t.NoopObservableMetric = t.NoopHistogramMetric = t.NoopUpDownCounterMetric = t.NoopCounterMetric = t.NoopMetric = t.NoopMeter = void 0;
            class NoopMeter {
                constructor(){}
                createHistogram(e, r) {
                    return t.NOOP_HISTOGRAM_METRIC;
                }
                createCounter(e, r) {
                    return t.NOOP_COUNTER_METRIC;
                }
                createUpDownCounter(e, r) {
                    return t.NOOP_UP_DOWN_COUNTER_METRIC;
                }
                createObservableGauge(e, r) {
                    return t.NOOP_OBSERVABLE_GAUGE_METRIC;
                }
                createObservableCounter(e, r) {
                    return t.NOOP_OBSERVABLE_COUNTER_METRIC;
                }
                createObservableUpDownCounter(e, r) {
                    return t.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
                }
                addBatchObservableCallback(e, t) {}
                removeBatchObservableCallback(e) {}
            }
            t.NoopMeter = NoopMeter;
            class NoopMetric {
            }
            t.NoopMetric = NoopMetric;
            class NoopCounterMetric extends NoopMetric {
                add(e, t) {}
            }
            t.NoopCounterMetric = NoopCounterMetric;
            class NoopUpDownCounterMetric extends NoopMetric {
                add(e, t) {}
            }
            t.NoopUpDownCounterMetric = NoopUpDownCounterMetric;
            class NoopHistogramMetric extends NoopMetric {
                record(e, t) {}
            }
            t.NoopHistogramMetric = NoopHistogramMetric;
            class NoopObservableMetric {
                addCallback(e) {}
                removeCallback(e) {}
            }
            t.NoopObservableMetric = NoopObservableMetric;
            class NoopObservableCounterMetric extends NoopObservableMetric {
            }
            t.NoopObservableCounterMetric = NoopObservableCounterMetric;
            class NoopObservableGaugeMetric extends NoopObservableMetric {
            }
            t.NoopObservableGaugeMetric = NoopObservableGaugeMetric;
            class NoopObservableUpDownCounterMetric extends NoopObservableMetric {
            }
            t.NoopObservableUpDownCounterMetric = NoopObservableUpDownCounterMetric;
            t.NOOP_METER = new NoopMeter;
            t.NOOP_COUNTER_METRIC = new NoopCounterMetric;
            t.NOOP_HISTOGRAM_METRIC = new NoopHistogramMetric;
            t.NOOP_UP_DOWN_COUNTER_METRIC = new NoopUpDownCounterMetric;
            t.NOOP_OBSERVABLE_COUNTER_METRIC = new NoopObservableCounterMetric;
            t.NOOP_OBSERVABLE_GAUGE_METRIC = new NoopObservableGaugeMetric;
            t.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = new NoopObservableUpDownCounterMetric;
            function createNoopMeter() {
                return t.NOOP_METER;
            }
            t.createNoopMeter = createNoopMeter;
        },
        660: (e, t, r)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.NOOP_METER_PROVIDER = t.NoopMeterProvider = void 0;
            const n = r(102);
            class NoopMeterProvider {
                getMeter(e, t, r) {
                    return n.NOOP_METER;
                }
            }
            t.NoopMeterProvider = NoopMeterProvider;
            t.NOOP_METER_PROVIDER = new NoopMeterProvider;
        },
        200: function(e, t, r) {
            var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
                if (n === undefined) n = r;
                Object.defineProperty(e, n, {
                    enumerable: true,
                    get: function() {
                        return t[r];
                    }
                });
            } : function(e, t, r, n) {
                if (n === undefined) n = r;
                e[n] = t[r];
            });
            var a = this && this.__exportStar || function(e, t) {
                for(var r in e)if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            a(r(46), t);
        },
        651: (e, t)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t._globalThis = void 0;
            t._globalThis = typeof globalThis === "object" ? globalThis : ("TURBOPACK ident replacement", globalThis);
        },
        46: function(e, t, r) {
            var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
                if (n === undefined) n = r;
                Object.defineProperty(e, n, {
                    enumerable: true,
                    get: function() {
                        return t[r];
                    }
                });
            } : function(e, t, r, n) {
                if (n === undefined) n = r;
                e[n] = t[r];
            });
            var a = this && this.__exportStar || function(e, t) {
                for(var r in e)if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            a(r(651), t);
        },
        939: (e, t, r)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.propagation = void 0;
            const n = r(181);
            t.propagation = n.PropagationAPI.getInstance();
        },
        874: (e, t)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.NoopTextMapPropagator = void 0;
            class NoopTextMapPropagator {
                inject(e, t) {}
                extract(e, t) {
                    return e;
                }
                fields() {
                    return [];
                }
            }
            t.NoopTextMapPropagator = NoopTextMapPropagator;
        },
        194: (e, t)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.defaultTextMapSetter = t.defaultTextMapGetter = void 0;
            t.defaultTextMapGetter = {
                get (e, t) {
                    if (e == null) {
                        return undefined;
                    }
                    return e[t];
                },
                keys (e) {
                    if (e == null) {
                        return [];
                    }
                    return Object.keys(e);
                }
            };
            t.defaultTextMapSetter = {
                set (e, t, r) {
                    if (e == null) {
                        return;
                    }
                    e[t] = r;
                }
            };
        },
        845: (e, t, r)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.trace = void 0;
            const n = r(997);
            t.trace = n.TraceAPI.getInstance();
        },
        403: (e, t, r)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.NonRecordingSpan = void 0;
            const n = r(476);
            class NonRecordingSpan {
                constructor(e = n.INVALID_SPAN_CONTEXT){
                    this._spanContext = e;
                }
                spanContext() {
                    return this._spanContext;
                }
                setAttribute(e, t) {
                    return this;
                }
                setAttributes(e) {
                    return this;
                }
                addEvent(e, t) {
                    return this;
                }
                setStatus(e) {
                    return this;
                }
                updateName(e) {
                    return this;
                }
                end(e) {}
                isRecording() {
                    return false;
                }
                recordException(e, t) {}
            }
            t.NonRecordingSpan = NonRecordingSpan;
        },
        614: (e, t, r)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.NoopTracer = void 0;
            const n = r(491);
            const a = r(607);
            const o = r(403);
            const i = r(139);
            const c = n.ContextAPI.getInstance();
            class NoopTracer {
                startSpan(e, t, r = c.active()) {
                    const n = Boolean(t === null || t === void 0 ? void 0 : t.root);
                    if (n) {
                        return new o.NonRecordingSpan;
                    }
                    const s = r && (0, a.getSpanContext)(r);
                    if (isSpanContext(s) && (0, i.isSpanContextValid)(s)) {
                        return new o.NonRecordingSpan(s);
                    } else {
                        return new o.NonRecordingSpan;
                    }
                }
                startActiveSpan(e, t, r, n) {
                    let o;
                    let i;
                    let s;
                    if (arguments.length < 2) {
                        return;
                    } else if (arguments.length === 2) {
                        s = t;
                    } else if (arguments.length === 3) {
                        o = t;
                        s = r;
                    } else {
                        o = t;
                        i = r;
                        s = n;
                    }
                    const u = i !== null && i !== void 0 ? i : c.active();
                    const l = this.startSpan(e, o, u);
                    const g = (0, a.setSpan)(u, l);
                    return c.with(g, s, undefined, l);
                }
            }
            t.NoopTracer = NoopTracer;
            function isSpanContext(e) {
                return typeof e === "object" && typeof e["spanId"] === "string" && typeof e["traceId"] === "string" && typeof e["traceFlags"] === "number";
            }
        },
        124: (e, t, r)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.NoopTracerProvider = void 0;
            const n = r(614);
            class NoopTracerProvider {
                getTracer(e, t, r) {
                    return new n.NoopTracer;
                }
            }
            t.NoopTracerProvider = NoopTracerProvider;
        },
        125: (e, t, r)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.ProxyTracer = void 0;
            const n = r(614);
            const a = new n.NoopTracer;
            class ProxyTracer {
                constructor(e, t, r, n){
                    this._provider = e;
                    this.name = t;
                    this.version = r;
                    this.options = n;
                }
                startSpan(e, t, r) {
                    return this._getTracer().startSpan(e, t, r);
                }
                startActiveSpan(e, t, r, n) {
                    const a = this._getTracer();
                    return Reflect.apply(a.startActiveSpan, a, arguments);
                }
                _getTracer() {
                    if (this._delegate) {
                        return this._delegate;
                    }
                    const e = this._provider.getDelegateTracer(this.name, this.version, this.options);
                    if (!e) {
                        return a;
                    }
                    this._delegate = e;
                    return this._delegate;
                }
            }
            t.ProxyTracer = ProxyTracer;
        },
        846: (e, t, r)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.ProxyTracerProvider = void 0;
            const n = r(125);
            const a = r(124);
            const o = new a.NoopTracerProvider;
            class ProxyTracerProvider {
                getTracer(e, t, r) {
                    var a;
                    return (a = this.getDelegateTracer(e, t, r)) !== null && a !== void 0 ? a : new n.ProxyTracer(this, e, t, r);
                }
                getDelegate() {
                    var e;
                    return (e = this._delegate) !== null && e !== void 0 ? e : o;
                }
                setDelegate(e) {
                    this._delegate = e;
                }
                getDelegateTracer(e, t, r) {
                    var n;
                    return (n = this._delegate) === null || n === void 0 ? void 0 : n.getTracer(e, t, r);
                }
            }
            t.ProxyTracerProvider = ProxyTracerProvider;
        },
        996: (e, t)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.SamplingDecision = void 0;
            var r;
            (function(e) {
                e[e["NOT_RECORD"] = 0] = "NOT_RECORD";
                e[e["RECORD"] = 1] = "RECORD";
                e[e["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
            })(r = t.SamplingDecision || (t.SamplingDecision = {}));
        },
        607: (e, t, r)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.getSpanContext = t.setSpanContext = t.deleteSpan = t.setSpan = t.getActiveSpan = t.getSpan = void 0;
            const n = r(780);
            const a = r(403);
            const o = r(491);
            const i = (0, n.createContextKey)("OpenTelemetry Context Key SPAN");
            function getSpan(e) {
                return e.getValue(i) || undefined;
            }
            t.getSpan = getSpan;
            function getActiveSpan() {
                return getSpan(o.ContextAPI.getInstance().active());
            }
            t.getActiveSpan = getActiveSpan;
            function setSpan(e, t) {
                return e.setValue(i, t);
            }
            t.setSpan = setSpan;
            function deleteSpan(e) {
                return e.deleteValue(i);
            }
            t.deleteSpan = deleteSpan;
            function setSpanContext(e, t) {
                return setSpan(e, new a.NonRecordingSpan(t));
            }
            t.setSpanContext = setSpanContext;
            function getSpanContext(e) {
                var t;
                return (t = getSpan(e)) === null || t === void 0 ? void 0 : t.spanContext();
            }
            t.getSpanContext = getSpanContext;
        },
        325: (e, t, r)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.TraceStateImpl = void 0;
            const n = r(564);
            const a = 32;
            const o = 512;
            const i = ",";
            const c = "=";
            class TraceStateImpl {
                constructor(e){
                    this._internalState = new Map;
                    if (e) this._parse(e);
                }
                set(e, t) {
                    const r = this._clone();
                    if (r._internalState.has(e)) {
                        r._internalState.delete(e);
                    }
                    r._internalState.set(e, t);
                    return r;
                }
                unset(e) {
                    const t = this._clone();
                    t._internalState.delete(e);
                    return t;
                }
                get(e) {
                    return this._internalState.get(e);
                }
                serialize() {
                    return this._keys().reduce((e, t)=>{
                        e.push(t + c + this.get(t));
                        return e;
                    }, []).join(i);
                }
                _parse(e) {
                    if (e.length > o) return;
                    this._internalState = e.split(i).reverse().reduce((e, t)=>{
                        const r = t.trim();
                        const a = r.indexOf(c);
                        if (a !== -1) {
                            const o = r.slice(0, a);
                            const i = r.slice(a + 1, t.length);
                            if ((0, n.validateKey)(o) && (0, n.validateValue)(i)) {
                                e.set(o, i);
                            } else {}
                        }
                        return e;
                    }, new Map);
                    if (this._internalState.size > a) {
                        this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, a));
                    }
                }
                _keys() {
                    return Array.from(this._internalState.keys()).reverse();
                }
                _clone() {
                    const e = new TraceStateImpl;
                    e._internalState = new Map(this._internalState);
                    return e;
                }
            }
            t.TraceStateImpl = TraceStateImpl;
        },
        564: (e, t)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.validateValue = t.validateKey = void 0;
            const r = "[_0-9a-z-*/]";
            const n = `[a-z]${r}{0,255}`;
            const a = `[a-z0-9]${r}{0,240}@[a-z]${r}{0,13}`;
            const o = new RegExp(`^(?:${n}|${a})$`);
            const i = /^[ -~]{0,255}[!-~]$/;
            const c = /,|=/;
            function validateKey(e) {
                return o.test(e);
            }
            t.validateKey = validateKey;
            function validateValue(e) {
                return i.test(e) && !c.test(e);
            }
            t.validateValue = validateValue;
        },
        98: (e, t, r)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.createTraceState = void 0;
            const n = r(325);
            function createTraceState(e) {
                return new n.TraceStateImpl(e);
            }
            t.createTraceState = createTraceState;
        },
        476: (e, t, r)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.INVALID_SPAN_CONTEXT = t.INVALID_TRACEID = t.INVALID_SPANID = void 0;
            const n = r(475);
            t.INVALID_SPANID = "0000000000000000";
            t.INVALID_TRACEID = "00000000000000000000000000000000";
            t.INVALID_SPAN_CONTEXT = {
                traceId: t.INVALID_TRACEID,
                spanId: t.INVALID_SPANID,
                traceFlags: n.TraceFlags.NONE
            };
        },
        357: (e, t)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.SpanKind = void 0;
            var r;
            (function(e) {
                e[e["INTERNAL"] = 0] = "INTERNAL";
                e[e["SERVER"] = 1] = "SERVER";
                e[e["CLIENT"] = 2] = "CLIENT";
                e[e["PRODUCER"] = 3] = "PRODUCER";
                e[e["CONSUMER"] = 4] = "CONSUMER";
            })(r = t.SpanKind || (t.SpanKind = {}));
        },
        139: (e, t, r)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.wrapSpanContext = t.isSpanContextValid = t.isValidSpanId = t.isValidTraceId = void 0;
            const n = r(476);
            const a = r(403);
            const o = /^([0-9a-f]{32})$/i;
            const i = /^[0-9a-f]{16}$/i;
            function isValidTraceId(e) {
                return o.test(e) && e !== n.INVALID_TRACEID;
            }
            t.isValidTraceId = isValidTraceId;
            function isValidSpanId(e) {
                return i.test(e) && e !== n.INVALID_SPANID;
            }
            t.isValidSpanId = isValidSpanId;
            function isSpanContextValid(e) {
                return isValidTraceId(e.traceId) && isValidSpanId(e.spanId);
            }
            t.isSpanContextValid = isSpanContextValid;
            function wrapSpanContext(e) {
                return new a.NonRecordingSpan(e);
            }
            t.wrapSpanContext = wrapSpanContext;
        },
        847: (e, t)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.SpanStatusCode = void 0;
            var r;
            (function(e) {
                e[e["UNSET"] = 0] = "UNSET";
                e[e["OK"] = 1] = "OK";
                e[e["ERROR"] = 2] = "ERROR";
            })(r = t.SpanStatusCode || (t.SpanStatusCode = {}));
        },
        475: (e, t)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.TraceFlags = void 0;
            var r;
            (function(e) {
                e[e["NONE"] = 0] = "NONE";
                e[e["SAMPLED"] = 1] = "SAMPLED";
            })(r = t.TraceFlags || (t.TraceFlags = {}));
        },
        521: (e, t)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.VERSION = void 0;
            t.VERSION = "1.6.0";
        }
    };
    var t = {};
    function __nccwpck_require__(r) {
        var n = t[r];
        if (n !== undefined) {
            return n.exports;
        }
        var a = t[r] = {
            exports: {}
        };
        var o = true;
        try {
            e[r].call(a.exports, a, a.exports, __nccwpck_require__);
            o = false;
        } finally{
            if (o) delete t[r];
        }
        return a.exports;
    }
    if (typeof __nccwpck_require__ !== "undefined") __nccwpck_require__.ab = ("TURBOPACK compile-time value", "/ROOT/node_modules/next/dist/compiled/@opentelemetry/api") + "/";
    var r = {};
    (()=>{
        var e = r;
        Object.defineProperty(e, "__esModule", {
            value: true
        });
        e.trace = e.propagation = e.metrics = e.diag = e.context = e.INVALID_SPAN_CONTEXT = e.INVALID_TRACEID = e.INVALID_SPANID = e.isValidSpanId = e.isValidTraceId = e.isSpanContextValid = e.createTraceState = e.TraceFlags = e.SpanStatusCode = e.SpanKind = e.SamplingDecision = e.ProxyTracerProvider = e.ProxyTracer = e.defaultTextMapSetter = e.defaultTextMapGetter = e.ValueType = e.createNoopMeter = e.DiagLogLevel = e.DiagConsoleLogger = e.ROOT_CONTEXT = e.createContextKey = e.baggageEntryMetadataFromString = void 0;
        var t = __nccwpck_require__(369);
        Object.defineProperty(e, "baggageEntryMetadataFromString", {
            enumerable: true,
            get: function() {
                return t.baggageEntryMetadataFromString;
            }
        });
        var n = __nccwpck_require__(780);
        Object.defineProperty(e, "createContextKey", {
            enumerable: true,
            get: function() {
                return n.createContextKey;
            }
        });
        Object.defineProperty(e, "ROOT_CONTEXT", {
            enumerable: true,
            get: function() {
                return n.ROOT_CONTEXT;
            }
        });
        var a = __nccwpck_require__(972);
        Object.defineProperty(e, "DiagConsoleLogger", {
            enumerable: true,
            get: function() {
                return a.DiagConsoleLogger;
            }
        });
        var o = __nccwpck_require__(957);
        Object.defineProperty(e, "DiagLogLevel", {
            enumerable: true,
            get: function() {
                return o.DiagLogLevel;
            }
        });
        var i = __nccwpck_require__(102);
        Object.defineProperty(e, "createNoopMeter", {
            enumerable: true,
            get: function() {
                return i.createNoopMeter;
            }
        });
        var c = __nccwpck_require__(901);
        Object.defineProperty(e, "ValueType", {
            enumerable: true,
            get: function() {
                return c.ValueType;
            }
        });
        var s = __nccwpck_require__(194);
        Object.defineProperty(e, "defaultTextMapGetter", {
            enumerable: true,
            get: function() {
                return s.defaultTextMapGetter;
            }
        });
        Object.defineProperty(e, "defaultTextMapSetter", {
            enumerable: true,
            get: function() {
                return s.defaultTextMapSetter;
            }
        });
        var u = __nccwpck_require__(125);
        Object.defineProperty(e, "ProxyTracer", {
            enumerable: true,
            get: function() {
                return u.ProxyTracer;
            }
        });
        var l = __nccwpck_require__(846);
        Object.defineProperty(e, "ProxyTracerProvider", {
            enumerable: true,
            get: function() {
                return l.ProxyTracerProvider;
            }
        });
        var g = __nccwpck_require__(996);
        Object.defineProperty(e, "SamplingDecision", {
            enumerable: true,
            get: function() {
                return g.SamplingDecision;
            }
        });
        var p = __nccwpck_require__(357);
        Object.defineProperty(e, "SpanKind", {
            enumerable: true,
            get: function() {
                return p.SpanKind;
            }
        });
        var d = __nccwpck_require__(847);
        Object.defineProperty(e, "SpanStatusCode", {
            enumerable: true,
            get: function() {
                return d.SpanStatusCode;
            }
        });
        var _ = __nccwpck_require__(475);
        Object.defineProperty(e, "TraceFlags", {
            enumerable: true,
            get: function() {
                return _.TraceFlags;
            }
        });
        var f = __nccwpck_require__(98);
        Object.defineProperty(e, "createTraceState", {
            enumerable: true,
            get: function() {
                return f.createTraceState;
            }
        });
        var b = __nccwpck_require__(139);
        Object.defineProperty(e, "isSpanContextValid", {
            enumerable: true,
            get: function() {
                return b.isSpanContextValid;
            }
        });
        Object.defineProperty(e, "isValidTraceId", {
            enumerable: true,
            get: function() {
                return b.isValidTraceId;
            }
        });
        Object.defineProperty(e, "isValidSpanId", {
            enumerable: true,
            get: function() {
                return b.isValidSpanId;
            }
        });
        var v = __nccwpck_require__(476);
        Object.defineProperty(e, "INVALID_SPANID", {
            enumerable: true,
            get: function() {
                return v.INVALID_SPANID;
            }
        });
        Object.defineProperty(e, "INVALID_TRACEID", {
            enumerable: true,
            get: function() {
                return v.INVALID_TRACEID;
            }
        });
        Object.defineProperty(e, "INVALID_SPAN_CONTEXT", {
            enumerable: true,
            get: function() {
                return v.INVALID_SPAN_CONTEXT;
            }
        });
        const O = __nccwpck_require__(67);
        Object.defineProperty(e, "context", {
            enumerable: true,
            get: function() {
                return O.context;
            }
        });
        const P = __nccwpck_require__(506);
        Object.defineProperty(e, "diag", {
            enumerable: true,
            get: function() {
                return P.diag;
            }
        });
        const N = __nccwpck_require__(886);
        Object.defineProperty(e, "metrics", {
            enumerable: true,
            get: function() {
                return N.metrics;
            }
        });
        const S = __nccwpck_require__(939);
        Object.defineProperty(e, "propagation", {
            enumerable: true,
            get: function() {
                return S.propagation;
            }
        });
        const C = __nccwpck_require__(845);
        Object.defineProperty(e, "trace", {
            enumerable: true,
            get: function() {
                return C.trace;
            }
        });
        e["default"] = {
            context: O.context,
            diag: P.diag,
            metrics: N.metrics,
            propagation: S.propagation,
            trace: C.trace
        };
    })();
    module.exports = r;
})();
}}),
"[project]/node_modules/next/dist/esm/server/lib/trace/tracer.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "BubbledError": ()=>BubbledError,
    "SpanKind": ()=>SpanKind,
    "SpanStatusCode": ()=>SpanStatusCode,
    "getTracer": ()=>getTracer,
    "isBubbledError": ()=>isBubbledError
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/lib/trace/constants.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$is$2d$thenable$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/is-thenable.js [app-rsc] (ecmascript)");
;
;
let api;
// we want to allow users to use their own version of @opentelemetry/api if they
// want to, so we try to require it first, and if it fails we fall back to the
// version that is bundled with Next.js
// this is because @opentelemetry/api has to be synced with the version of
// @opentelemetry/tracing that is used, and we don't want to force users to use
// the version that is bundled with Next.js.
// the API is ~stable, so this should be fine
if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
else {
    try {
        api = __turbopack_context__.r("[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)");
    } catch (err) {
        api = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/@opentelemetry/api/index.js [app-rsc] (ecmascript)");
    }
}
const { context, propagation, trace, SpanStatusCode, SpanKind, ROOT_CONTEXT } = api;
class BubbledError extends Error {
    constructor(bubble, result){
        super(), this.bubble = bubble, this.result = result;
    }
}
function isBubbledError(error) {
    if (typeof error !== 'object' || error === null) return false;
    return error instanceof BubbledError;
}
const closeSpanWithError = (span, error)=>{
    if (isBubbledError(error) && error.bubble) {
        span.setAttribute('next.bubble', true);
    } else {
        if (error) {
            span.recordException(error);
        }
        span.setStatus({
            code: SpanStatusCode.ERROR,
            message: error == null ? void 0 : error.message
        });
    }
    span.end();
};
/** we use this map to propagate attributes from nested spans to the top span */ const rootSpanAttributesStore = new Map();
const rootSpanIdKey = api.createContextKey('next.rootSpanId');
let lastSpanId = 0;
const getSpanId = ()=>lastSpanId++;
const clientTraceDataSetter = {
    set (carrier, key, value) {
        carrier.push({
            key,
            value
        });
    }
};
class NextTracerImpl {
    /**
   * Returns an instance to the trace with configured name.
   * Since wrap / trace can be defined in any place prior to actual trace subscriber initialization,
   * This should be lazily evaluated.
   */ getTracerInstance() {
        return trace.getTracer('next.js', '0.0.1');
    }
    getContext() {
        return context;
    }
    getTracePropagationData() {
        const activeContext = context.active();
        const entries = [];
        propagation.inject(activeContext, entries, clientTraceDataSetter);
        return entries;
    }
    getActiveScopeSpan() {
        return trace.getSpan(context == null ? void 0 : context.active());
    }
    withPropagatedContext(carrier, fn, getter) {
        const activeContext = context.active();
        if (trace.getSpanContext(activeContext)) {
            // Active span is already set, too late to propagate.
            return fn();
        }
        const remoteContext = propagation.extract(activeContext, carrier, getter);
        return context.with(remoteContext, fn);
    }
    trace(...args) {
        var _trace_getSpanContext;
        const [type, fnOrOptions, fnOrEmpty] = args;
        // coerce options form overload
        const { fn, options } = typeof fnOrOptions === 'function' ? {
            fn: fnOrOptions,
            options: {}
        } : {
            fn: fnOrEmpty,
            options: {
                ...fnOrOptions
            }
        };
        const spanName = options.spanName ?? type;
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["NextVanillaSpanAllowlist"].includes(type) && process.env.NEXT_OTEL_VERBOSE !== '1' || options.hideSpan) {
            return fn();
        }
        // Trying to get active scoped span to assign parent. If option specifies parent span manually, will try to use it.
        let spanContext = this.getSpanContext((options == null ? void 0 : options.parentSpan) ?? this.getActiveScopeSpan());
        let isRootSpan = false;
        if (!spanContext) {
            spanContext = (context == null ? void 0 : context.active()) ?? ROOT_CONTEXT;
            isRootSpan = true;
        } else if ((_trace_getSpanContext = trace.getSpanContext(spanContext)) == null ? void 0 : _trace_getSpanContext.isRemote) {
            isRootSpan = true;
        }
        const spanId = getSpanId();
        options.attributes = {
            'next.span_name': spanName,
            'next.span_type': type,
            ...options.attributes
        };
        return context.with(spanContext.setValue(rootSpanIdKey, spanId), ()=>this.getTracerInstance().startActiveSpan(spanName, options, (span)=>{
                const startTime = 'performance' in globalThis && 'measure' in performance ? globalThis.performance.now() : undefined;
                const onCleanup = ()=>{
                    rootSpanAttributesStore.delete(spanId);
                    if (startTime && process.env.NEXT_OTEL_PERFORMANCE_PREFIX && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["LogSpanAllowList"].includes(type || '')) {
                        performance.measure(`${process.env.NEXT_OTEL_PERFORMANCE_PREFIX}:next-${(type.split('.').pop() || '').replace(/[A-Z]/g, (match)=>'-' + match.toLowerCase())}`, {
                            start: startTime,
                            end: performance.now()
                        });
                    }
                };
                if (isRootSpan) {
                    rootSpanAttributesStore.set(spanId, new Map(Object.entries(options.attributes ?? {})));
                }
                try {
                    if (fn.length > 1) {
                        return fn(span, (err)=>closeSpanWithError(span, err));
                    }
                    const result = fn(span);
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$is$2d$thenable$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isThenable"])(result)) {
                        // If there's error make sure it throws
                        return result.then((res)=>{
                            span.end();
                            // Need to pass down the promise result,
                            // it could be react stream response with error { error, stream }
                            return res;
                        }).catch((err)=>{
                            closeSpanWithError(span, err);
                            throw err;
                        }).finally(onCleanup);
                    } else {
                        span.end();
                        onCleanup();
                    }
                    return result;
                } catch (err) {
                    closeSpanWithError(span, err);
                    onCleanup();
                    throw err;
                }
            }));
    }
    wrap(...args) {
        const tracer = this;
        const [name, options, fn] = args.length === 3 ? args : [
            args[0],
            {},
            args[1]
        ];
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["NextVanillaSpanAllowlist"].includes(name) && process.env.NEXT_OTEL_VERBOSE !== '1') {
            return fn;
        }
        return function() {
            let optionsObj = options;
            if (typeof optionsObj === 'function' && typeof fn === 'function') {
                optionsObj = optionsObj.apply(this, arguments);
            }
            const lastArgId = arguments.length - 1;
            const cb = arguments[lastArgId];
            if (typeof cb === 'function') {
                const scopeBoundCb = tracer.getContext().bind(context.active(), cb);
                return tracer.trace(name, optionsObj, (_span, done)=>{
                    arguments[lastArgId] = function(err) {
                        done == null ? void 0 : done(err);
                        return scopeBoundCb.apply(this, arguments);
                    };
                    return fn.apply(this, arguments);
                });
            } else {
                return tracer.trace(name, optionsObj, ()=>fn.apply(this, arguments));
            }
        };
    }
    startSpan(...args) {
        const [type, options] = args;
        const spanContext = this.getSpanContext((options == null ? void 0 : options.parentSpan) ?? this.getActiveScopeSpan());
        return this.getTracerInstance().startSpan(type, options, spanContext);
    }
    getSpanContext(parentSpan) {
        const spanContext = parentSpan ? trace.setSpan(context.active(), parentSpan) : undefined;
        return spanContext;
    }
    getRootSpanAttributes() {
        const spanId = context.active().getValue(rootSpanIdKey);
        return rootSpanAttributesStore.get(spanId);
    }
    setRootSpanAttribute(key, value) {
        const spanId = context.active().getValue(rootSpanIdKey);
        const attributes = rootSpanAttributesStore.get(spanId);
        if (attributes) {
            attributes.set(key, value);
        }
    }
}
const getTracer = (()=>{
    const tracer = new NextTracerImpl();
    return ()=>tracer;
})();
;
 //# sourceMappingURL=tracer.js.map
}),
"[project]/node_modules/next/dist/esm/shared/lib/deep-freeze.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * Recursively freezes an object and all of its properties. This prevents the
 * object from being modified at runtime. When the JS runtime is running in
 * strict mode, any attempts to modify a frozen object will throw an error.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze
 * @param obj The object to freeze.
 */ __turbopack_context__.s({
    "deepFreeze": ()=>deepFreeze
});
function deepFreeze(obj) {
    // If the object is already frozen, there's no need to freeze it again.
    if (Object.isFrozen(obj)) return obj;
    // An array is an object, but we also want to freeze each element in the array
    // as well.
    if (Array.isArray(obj)) {
        for (const item of obj){
            if (!item || typeof item !== 'object') continue;
            deepFreeze(item);
        }
        return Object.freeze(obj);
    }
    for (const value of Object.values(obj)){
        if (!value || typeof value !== 'object') continue;
        deepFreeze(value);
    }
    return Object.freeze(obj);
} //# sourceMappingURL=deep-freeze.js.map
}),
"[project]/node_modules/next/dist/esm/lib/metadata/clone-metadata.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "cloneMetadata": ()=>cloneMetadata
});
const TYPE_URL = '__METADATA_URL';
function replacer(_key, val) {
    // clone URL as string but recover it as URL
    if (val instanceof URL) {
        return {
            _type: TYPE_URL,
            value: val.href
        };
    }
    return val;
}
function reviver(_key, val) {
    if (typeof val === 'object' && val !== null && val._type === TYPE_URL) {
        return new URL(val.value);
    }
    return val;
}
function cloneMetadata(metadata) {
    const jsonString = JSON.stringify(metadata, replacer);
    return JSON.parse(jsonString, reviver);
} //# sourceMappingURL=clone-metadata.js.map
}),
"[project]/node_modules/next/dist/esm/lib/metadata/resolve-metadata.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// eslint-disable-next-line import/no-extraneous-dependencies
__turbopack_context__.s({
    "accumulateMetadata": ()=>accumulateMetadata,
    "accumulateViewport": ()=>accumulateViewport,
    "resolveMetadata": ()=>resolveMetadata,
    "resolveViewport": ()=>resolveViewport
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$server$2d$only$2f$empty$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/server-only/empty.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$default$2d$metadata$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/metadata/default-metadata.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$resolvers$2f$resolve$2d$opengraph$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/metadata/resolvers/resolve-opengraph.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$resolvers$2f$resolve$2d$title$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/metadata/resolvers/resolve-title.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/metadata/generate/utils.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$app$2d$dir$2d$module$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/lib/app-dir-module.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$interop$2d$default$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/interop-default.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$resolvers$2f$resolve$2d$basics$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/metadata/resolvers/resolve-basics.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$resolvers$2f$resolve$2d$icons$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/metadata/resolvers/resolve-icons.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$tracer$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/lib/trace/tracer.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/lib/trace/constants.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$segment$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/segment.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$build$2f$output$2f$log$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/build/output/log.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2f$params$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/request/params.js [app-rsc] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
function isFavicon(icon) {
    if (!icon) {
        return false;
    }
    // turbopack appends a hash to all images
    return (icon.url === '/favicon.ico' || icon.url.toString().startsWith('/favicon.ico?')) && icon.type === 'image/x-icon';
}
async function mergeStaticMetadata(source, target, staticFilesMetadata, metadataContext, titleTemplates, leafSegmentStaticIcons, pathname) {
    var _source_twitter, _source_openGraph;
    if (!staticFilesMetadata) return target;
    const { icon, apple, openGraph, twitter, manifest } = staticFilesMetadata;
    // Keep updating the static icons in the most leaf node
    if (icon) {
        leafSegmentStaticIcons.icon = icon;
    }
    if (apple) {
        leafSegmentStaticIcons.apple = apple;
    }
    // file based metadata is specified and current level metadata twitter.images is not specified
    if (twitter && !(source == null ? void 0 : (_source_twitter = source.twitter) == null ? void 0 : _source_twitter.hasOwnProperty('images'))) {
        const resolvedTwitter = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$resolvers$2f$resolve$2d$opengraph$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["resolveTwitter"])({
            ...target.twitter,
            images: twitter
        }, target.metadataBase, {
            ...metadataContext,
            isStaticMetadataRouteFile: true
        }, titleTemplates.twitter);
        target.twitter = resolvedTwitter;
    }
    // file based metadata is specified and current level metadata openGraph.images is not specified
    if (openGraph && !(source == null ? void 0 : (_source_openGraph = source.openGraph) == null ? void 0 : _source_openGraph.hasOwnProperty('images'))) {
        const resolvedOpenGraph = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$resolvers$2f$resolve$2d$opengraph$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["resolveOpenGraph"])({
            ...target.openGraph,
            images: openGraph
        }, target.metadataBase, pathname, {
            ...metadataContext,
            isStaticMetadataRouteFile: true
        }, titleTemplates.openGraph);
        target.openGraph = resolvedOpenGraph;
    }
    if (manifest) {
        target.manifest = manifest;
    }
    return target;
}
// Merge the source metadata into the resolved target metadata.
async function mergeMetadata(route, pathname, { source, target, staticFilesMetadata, titleTemplates, metadataContext, buildState, leafSegmentStaticIcons }) {
    // If there's override metadata, prefer it otherwise fallback to the default metadata.
    const metadataBase = typeof (source == null ? void 0 : source.metadataBase) !== 'undefined' ? source.metadataBase : target.metadataBase;
    for(const key_ in source){
        const key = key_;
        switch(key){
            case 'title':
                {
                    target.title = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$resolvers$2f$resolve$2d$title$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["resolveTitle"])(source.title, titleTemplates.title);
                    break;
                }
            case 'alternates':
                {
                    target.alternates = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$resolvers$2f$resolve$2d$basics$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["resolveAlternates"])(source.alternates, metadataBase, pathname, metadataContext);
                    break;
                }
            case 'openGraph':
                {
                    target.openGraph = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$resolvers$2f$resolve$2d$opengraph$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["resolveOpenGraph"])(source.openGraph, metadataBase, pathname, metadataContext, titleTemplates.openGraph);
                    break;
                }
            case 'twitter':
                {
                    target.twitter = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$resolvers$2f$resolve$2d$opengraph$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["resolveTwitter"])(source.twitter, metadataBase, metadataContext, titleTemplates.twitter);
                    break;
                }
            case 'facebook':
                target.facebook = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$resolvers$2f$resolve$2d$basics$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["resolveFacebook"])(source.facebook);
                break;
            case 'verification':
                target.verification = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$resolvers$2f$resolve$2d$basics$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["resolveVerification"])(source.verification);
                break;
            case 'icons':
                {
                    target.icons = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$resolvers$2f$resolve$2d$icons$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["resolveIcons"])(source.icons);
                    break;
                }
            case 'appleWebApp':
                target.appleWebApp = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$resolvers$2f$resolve$2d$basics$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["resolveAppleWebApp"])(source.appleWebApp);
                break;
            case 'appLinks':
                target.appLinks = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$resolvers$2f$resolve$2d$basics$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["resolveAppLinks"])(source.appLinks);
                break;
            case 'robots':
                {
                    target.robots = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$resolvers$2f$resolve$2d$basics$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["resolveRobots"])(source.robots);
                    break;
                }
            case 'archives':
            case 'assets':
            case 'bookmarks':
            case 'keywords':
                {
                    target[key] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["resolveAsArrayOrUndefined"])(source[key]);
                    break;
                }
            case 'authors':
                {
                    target[key] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["resolveAsArrayOrUndefined"])(source.authors);
                    break;
                }
            case 'itunes':
                {
                    target[key] = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$resolvers$2f$resolve$2d$basics$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["resolveItunes"])(source.itunes, metadataBase, pathname, metadataContext);
                    break;
                }
            case 'pagination':
                {
                    target.pagination = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$resolvers$2f$resolve$2d$basics$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["resolvePagination"])(source.pagination, metadataBase, pathname, metadataContext);
                    break;
                }
            // directly assign fields that fallback to null
            case 'applicationName':
            case 'description':
            case 'generator':
            case 'creator':
            case 'publisher':
            case 'category':
            case 'classification':
            case 'referrer':
            case 'formatDetection':
            case 'manifest':
            case 'pinterest':
                // @ts-ignore TODO: support inferring
                target[key] = source[key] || null;
                break;
            case 'other':
                target.other = Object.assign({}, target.other, source.other);
                break;
            case 'metadataBase':
                target.metadataBase = metadataBase;
                break;
            default:
                {
                    if ((key === 'viewport' || key === 'themeColor' || key === 'colorScheme') && source[key] != null) {
                        buildState.warnings.add(`Unsupported metadata ${key} is configured in metadata export in ${route}. Please move it to viewport export instead.\nRead more: https://nextjs.org/docs/app/api-reference/functions/generate-viewport`);
                    }
                    break;
                }
        }
    }
    return mergeStaticMetadata(source, target, staticFilesMetadata, metadataContext, titleTemplates, leafSegmentStaticIcons, pathname);
}
function mergeViewport({ target, source }) {
    if (!source) return;
    for(const key_ in source){
        const key = key_;
        switch(key){
            case 'themeColor':
                {
                    target.themeColor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$resolvers$2f$resolve$2d$basics$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["resolveThemeColor"])(source.themeColor);
                    break;
                }
            case 'colorScheme':
                target.colorScheme = source.colorScheme || null;
                break;
            default:
                // always override the target with the source
                // @ts-ignore viewport properties
                target[key] = source[key];
                break;
        }
    }
}
function getDefinedViewport(mod, props, tracingProps) {
    if (typeof mod.generateViewport === 'function') {
        const { route } = tracingProps;
        return (parent)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$tracer$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getTracer"])().trace(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ResolveMetadataSpan"].generateViewport, {
                spanName: `generateViewport ${route}`,
                attributes: {
                    'next.page': route
                }
            }, ()=>mod.generateViewport(props, parent));
    }
    return mod.viewport || null;
}
function getDefinedMetadata(mod, props, tracingProps) {
    if (typeof mod.generateMetadata === 'function') {
        const { route } = tracingProps;
        return (parent)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$tracer$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getTracer"])().trace(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ResolveMetadataSpan"].generateMetadata, {
                spanName: `generateMetadata ${route}`,
                attributes: {
                    'next.page': route
                }
            }, ()=>mod.generateMetadata(props, parent));
    }
    return mod.metadata || null;
}
async function collectStaticImagesFiles(metadata, props, type) {
    var _this;
    if (!(metadata == null ? void 0 : metadata[type])) return undefined;
    const iconPromises = metadata[type].map(async (imageModule)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$interop$2d$default$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["interopDefault"])(await imageModule(props)));
    return (iconPromises == null ? void 0 : iconPromises.length) > 0 ? (_this = await Promise.all(iconPromises)) == null ? void 0 : _this.flat() : undefined;
}
async function resolveStaticMetadata(modules, props) {
    const { metadata } = modules;
    if (!metadata) return null;
    const [icon, apple, openGraph, twitter] = await Promise.all([
        collectStaticImagesFiles(metadata, props, 'icon'),
        collectStaticImagesFiles(metadata, props, 'apple'),
        collectStaticImagesFiles(metadata, props, 'openGraph'),
        collectStaticImagesFiles(metadata, props, 'twitter')
    ]);
    const staticMetadata = {
        icon,
        apple,
        openGraph,
        twitter,
        manifest: metadata.manifest
    };
    return staticMetadata;
}
// [layout.metadata, static files metadata] -> ... -> [page.metadata, static files metadata]
async function collectMetadata({ tree, metadataItems, errorMetadataItem, props, route, errorConvention }) {
    let mod;
    let modType;
    const hasErrorConventionComponent = Boolean(errorConvention && tree[2][errorConvention]);
    if (errorConvention) {
        mod = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$app$2d$dir$2d$module$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getComponentTypeModule"])(tree, 'layout');
        modType = errorConvention;
    } else {
        const { mod: layoutOrPageMod, modType: layoutOrPageModType } = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$app$2d$dir$2d$module$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getLayoutOrPageModule"])(tree);
        mod = layoutOrPageMod;
        modType = layoutOrPageModType;
    }
    if (modType) {
        route += `/${modType}`;
    }
    const staticFilesMetadata = await resolveStaticMetadata(tree[2], props);
    const metadataExport = mod ? getDefinedMetadata(mod, props, {
        route
    }) : null;
    metadataItems.push([
        metadataExport,
        staticFilesMetadata
    ]);
    if (hasErrorConventionComponent && errorConvention) {
        const errorMod = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$app$2d$dir$2d$module$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getComponentTypeModule"])(tree, errorConvention);
        const errorMetadataExport = errorMod ? getDefinedMetadata(errorMod, props, {
            route
        }) : null;
        errorMetadataItem[0] = errorMetadataExport;
        errorMetadataItem[1] = staticFilesMetadata;
    }
}
// [layout.metadata, static files metadata] -> ... -> [page.metadata, static files metadata]
async function collectViewport({ tree, viewportItems, errorViewportItemRef, props, route, errorConvention }) {
    let mod;
    let modType;
    const hasErrorConventionComponent = Boolean(errorConvention && tree[2][errorConvention]);
    if (errorConvention) {
        mod = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$app$2d$dir$2d$module$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getComponentTypeModule"])(tree, 'layout');
        modType = errorConvention;
    } else {
        const { mod: layoutOrPageMod, modType: layoutOrPageModType } = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$app$2d$dir$2d$module$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getLayoutOrPageModule"])(tree);
        mod = layoutOrPageMod;
        modType = layoutOrPageModType;
    }
    if (modType) {
        route += `/${modType}`;
    }
    const viewportExport = mod ? getDefinedViewport(mod, props, {
        route
    }) : null;
    viewportItems.push(viewportExport);
    if (hasErrorConventionComponent && errorConvention) {
        const errorMod = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$app$2d$dir$2d$module$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getComponentTypeModule"])(tree, errorConvention);
        const errorViewportExport = errorMod ? getDefinedViewport(errorMod, props, {
            route
        }) : null;
        errorViewportItemRef.current = errorViewportExport;
    }
}
const resolveMetadataItems = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["cache"])(async function(tree, searchParams, errorConvention, getDynamicParamFromSegment, workStore) {
    const parentParams = {};
    const metadataItems = [];
    const errorMetadataItem = [
        null,
        null
    ];
    const treePrefix = undefined;
    return resolveMetadataItemsImpl(metadataItems, tree, treePrefix, parentParams, searchParams, errorConvention, errorMetadataItem, getDynamicParamFromSegment, workStore);
});
async function resolveMetadataItemsImpl(metadataItems, tree, /** Provided tree can be nested subtree, this argument says what is the path of such subtree */ treePrefix, parentParams, searchParams, errorConvention, errorMetadataItem, getDynamicParamFromSegment, workStore) {
    const [segment, parallelRoutes, { page }] = tree;
    const currentTreePrefix = treePrefix && treePrefix.length ? [
        ...treePrefix,
        segment
    ] : [
        segment
    ];
    const isPage = typeof page !== 'undefined';
    // Handle dynamic segment params.
    const segmentParam = getDynamicParamFromSegment(segment);
    /**
   * Create object holding the parent params and current params
   */ let currentParams = parentParams;
    if (segmentParam && segmentParam.value !== null) {
        currentParams = {
            ...parentParams,
            [segmentParam.param]: segmentParam.value
        };
    }
    const params = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2f$params$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createServerParamsForMetadata"])(currentParams, workStore);
    let layerProps;
    if (isPage) {
        layerProps = {
            params,
            searchParams
        };
    } else {
        layerProps = {
            params
        };
    }
    await collectMetadata({
        tree,
        metadataItems,
        errorMetadataItem,
        errorConvention,
        props: layerProps,
        route: currentTreePrefix // __PAGE__ shouldn't be shown in a route
        .filter((s)=>s !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$segment$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["PAGE_SEGMENT_KEY"]).join('/')
    });
    for(const key in parallelRoutes){
        const childTree = parallelRoutes[key];
        await resolveMetadataItemsImpl(metadataItems, childTree, currentTreePrefix, currentParams, searchParams, errorConvention, errorMetadataItem, getDynamicParamFromSegment, workStore);
    }
    if (Object.keys(parallelRoutes).length === 0 && errorConvention) {
        // If there are no parallel routes, place error metadata as the last item.
        // e.g. layout -> layout -> not-found
        metadataItems.push(errorMetadataItem);
    }
    return metadataItems;
}
const resolveViewportItems = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["cache"])(async function(tree, searchParams, errorConvention, getDynamicParamFromSegment, workStore) {
    const parentParams = {};
    const viewportItems = [];
    const errorViewportItemRef = {
        current: null
    };
    const treePrefix = undefined;
    return resolveViewportItemsImpl(viewportItems, tree, treePrefix, parentParams, searchParams, errorConvention, errorViewportItemRef, getDynamicParamFromSegment, workStore);
});
async function resolveViewportItemsImpl(viewportItems, tree, /** Provided tree can be nested subtree, this argument says what is the path of such subtree */ treePrefix, parentParams, searchParams, errorConvention, errorViewportItemRef, getDynamicParamFromSegment, workStore) {
    const [segment, parallelRoutes, { page }] = tree;
    const currentTreePrefix = treePrefix && treePrefix.length ? [
        ...treePrefix,
        segment
    ] : [
        segment
    ];
    const isPage = typeof page !== 'undefined';
    // Handle dynamic segment params.
    const segmentParam = getDynamicParamFromSegment(segment);
    /**
   * Create object holding the parent params and current params
   */ let currentParams = parentParams;
    if (segmentParam && segmentParam.value !== null) {
        currentParams = {
            ...parentParams,
            [segmentParam.param]: segmentParam.value
        };
    }
    const params = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2f$params$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createServerParamsForMetadata"])(currentParams, workStore);
    let layerProps;
    if (isPage) {
        layerProps = {
            params,
            searchParams
        };
    } else {
        layerProps = {
            params
        };
    }
    await collectViewport({
        tree,
        viewportItems,
        errorViewportItemRef,
        errorConvention,
        props: layerProps,
        route: currentTreePrefix // __PAGE__ shouldn't be shown in a route
        .filter((s)=>s !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$segment$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["PAGE_SEGMENT_KEY"]).join('/')
    });
    for(const key in parallelRoutes){
        const childTree = parallelRoutes[key];
        await resolveViewportItemsImpl(viewportItems, childTree, currentTreePrefix, currentParams, searchParams, errorConvention, errorViewportItemRef, getDynamicParamFromSegment, workStore);
    }
    if (Object.keys(parallelRoutes).length === 0 && errorConvention) {
        // If there are no parallel routes, place error metadata as the last item.
        // e.g. layout -> layout -> not-found
        viewportItems.push(errorViewportItemRef.current);
    }
    return viewportItems;
}
const isTitleTruthy = (title)=>!!(title == null ? void 0 : title.absolute);
const hasTitle = (metadata)=>isTitleTruthy(metadata == null ? void 0 : metadata.title);
function inheritFromMetadata(target, metadata) {
    if (target) {
        if (!hasTitle(target) && hasTitle(metadata)) {
            target.title = metadata.title;
        }
        if (!target.description && metadata.description) {
            target.description = metadata.description;
        }
    }
}
// eslint-disable-next-line @typescript-eslint/no-unused-vars
const commonOgKeys = [
    'title',
    'description',
    'images'
];
function postProcessMetadata(metadata, favicon, titleTemplates, metadataContext) {
    const { openGraph, twitter } = metadata;
    if (openGraph) {
        // If there's openGraph information but not configured in twitter,
        // inherit them from openGraph metadata.
        let autoFillProps = {};
        const hasTwTitle = hasTitle(twitter);
        const hasTwDescription = twitter == null ? void 0 : twitter.description;
        const hasTwImages = Boolean((twitter == null ? void 0 : twitter.hasOwnProperty('images')) && twitter.images);
        if (!hasTwTitle) {
            if (isTitleTruthy(openGraph.title)) {
                autoFillProps.title = openGraph.title;
            } else if (metadata.title && isTitleTruthy(metadata.title)) {
                autoFillProps.title = metadata.title;
            }
        }
        if (!hasTwDescription) autoFillProps.description = openGraph.description || metadata.description || undefined;
        if (!hasTwImages) autoFillProps.images = openGraph.images;
        if (Object.keys(autoFillProps).length > 0) {
            const partialTwitter = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$resolvers$2f$resolve$2d$opengraph$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["resolveTwitter"])(autoFillProps, metadata.metadataBase, metadataContext, titleTemplates.twitter);
            if (metadata.twitter) {
                metadata.twitter = Object.assign({}, metadata.twitter, {
                    ...!hasTwTitle && {
                        title: partialTwitter == null ? void 0 : partialTwitter.title
                    },
                    ...!hasTwDescription && {
                        description: partialTwitter == null ? void 0 : partialTwitter.description
                    },
                    ...!hasTwImages && {
                        images: partialTwitter == null ? void 0 : partialTwitter.images
                    }
                });
            } else {
                metadata.twitter = partialTwitter;
            }
        }
    }
    // If there's no title and description configured in openGraph or twitter,
    // use the title and description from metadata.
    inheritFromMetadata(openGraph, metadata);
    inheritFromMetadata(twitter, metadata);
    if (favicon) {
        if (!metadata.icons) {
            metadata.icons = {
                icon: [],
                apple: []
            };
        }
        metadata.icons.icon.unshift(favicon);
    }
    return metadata;
}
function prerenderMetadata(metadataItems) {
    // If the index is a function then it is a resolver and the next slot
    // is the corresponding result. If the index is not a function it is the result
    // itself.
    const resolversAndResults = [];
    for(let i = 0; i < metadataItems.length; i++){
        const metadataExport = metadataItems[i][0];
        getResult(resolversAndResults, metadataExport);
    }
    return resolversAndResults;
}
function prerenderViewport(viewportItems) {
    // If the index is a function then it is a resolver and the next slot
    // is the corresponding result. If the index is not a function it is the result
    // itself.
    const resolversAndResults = [];
    for(let i = 0; i < viewportItems.length; i++){
        const viewportExport = viewportItems[i];
        getResult(resolversAndResults, viewportExport);
    }
    return resolversAndResults;
}
function getResult(resolversAndResults, exportForResult) {
    if (typeof exportForResult === 'function') {
        const result = exportForResult(new Promise((resolve)=>resolversAndResults.push(resolve)));
        resolversAndResults.push(result);
        if (result instanceof Promise) {
            // since we eager execute generateMetadata and
            // they can reject at anytime we need to ensure
            // we attach the catch handler right away to
            // prevent unhandled rejections crashing the process
            result.catch((err)=>{
                return {
                    __nextError: err
                };
            });
        }
    } else if (typeof exportForResult === 'object') {
        resolversAndResults.push(exportForResult);
    } else {
        resolversAndResults.push(null);
    }
}
function resolvePendingResult(parentResult, resolveParentResult) {
    // In dev we clone and freeze to prevent relying on mutating resolvedMetadata directly.
    // In prod we just pass resolvedMetadata through without any copying.
    if ("TURBOPACK compile-time truthy", 1) {
        // @ts-expect-error -- DeepReadonly<T> is by definition not assignable to T
        // Instead, we should only accept DeepReadonly<ResolvedType>
        parentResult = __turbopack_context__.r("[project]/node_modules/next/dist/esm/shared/lib/deep-freeze.js [app-rsc] (ecmascript)").deepFreeze(__turbopack_context__.r("[project]/node_modules/next/dist/esm/lib/metadata/clone-metadata.js [app-rsc] (ecmascript)").cloneMetadata(parentResult));
    }
    resolveParentResult(parentResult);
}
async function accumulateMetadata(route, metadataItems, pathname, metadataContext) {
    let resolvedMetadata = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$default$2d$metadata$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createDefaultMetadata"])();
    let titleTemplates = {
        title: null,
        twitter: null,
        openGraph: null
    };
    const buildState = {
        warnings: new Set()
    };
    let favicon;
    // Collect the static icons in the most leaf node,
    // since we don't collect all the static metadata icons in the parent segments.
    const leafSegmentStaticIcons = {
        icon: [],
        apple: []
    };
    const resolversAndResults = prerenderMetadata(metadataItems);
    let resultIndex = 0;
    for(let i = 0; i < metadataItems.length; i++){
        var _staticFilesMetadata_icon;
        const staticFilesMetadata = metadataItems[i][1];
        // Treat favicon as special case, it should be the first icon in the list
        // i <= 1 represents root layout, and if current page is also at root
        if (i <= 1 && isFavicon(staticFilesMetadata == null ? void 0 : (_staticFilesMetadata_icon = staticFilesMetadata.icon) == null ? void 0 : _staticFilesMetadata_icon[0])) {
            var _staticFilesMetadata_icon1;
            const iconMod = staticFilesMetadata == null ? void 0 : (_staticFilesMetadata_icon1 = staticFilesMetadata.icon) == null ? void 0 : _staticFilesMetadata_icon1.shift();
            if (i === 0) favicon = iconMod;
        }
        let pendingMetadata = resolversAndResults[resultIndex++];
        if (typeof pendingMetadata === 'function') {
            // This metadata item had a `generateMetadata` and
            // we need to provide the currently resolved metadata
            // to it before we continue;
            const resolveParentMetadata = pendingMetadata;
            // we know that the next item is a result if this item
            // was a resolver
            pendingMetadata = resolversAndResults[resultIndex++];
            resolvePendingResult(resolvedMetadata, resolveParentMetadata);
        }
        // Otherwise the item was either null or a static export
        let metadata;
        if (isPromiseLike(pendingMetadata)) {
            metadata = await pendingMetadata;
        } else {
            metadata = pendingMetadata;
        }
        resolvedMetadata = await mergeMetadata(route, pathname, {
            target: resolvedMetadata,
            source: metadata,
            metadataContext,
            staticFilesMetadata,
            titleTemplates,
            buildState,
            leafSegmentStaticIcons
        });
        // If the layout is the same layer with page, skip the leaf layout and leaf page
        // The leaf layout and page are the last two items
        if (i < metadataItems.length - 2) {
            var _resolvedMetadata_title, _resolvedMetadata_openGraph, _resolvedMetadata_twitter;
            titleTemplates = {
                title: ((_resolvedMetadata_title = resolvedMetadata.title) == null ? void 0 : _resolvedMetadata_title.template) || null,
                openGraph: ((_resolvedMetadata_openGraph = resolvedMetadata.openGraph) == null ? void 0 : _resolvedMetadata_openGraph.title.template) || null,
                twitter: ((_resolvedMetadata_twitter = resolvedMetadata.twitter) == null ? void 0 : _resolvedMetadata_twitter.title.template) || null
            };
        }
    }
    if (leafSegmentStaticIcons.icon.length > 0 || leafSegmentStaticIcons.apple.length > 0) {
        if (!resolvedMetadata.icons) {
            resolvedMetadata.icons = {
                icon: [],
                apple: []
            };
            if (leafSegmentStaticIcons.icon.length > 0) {
                resolvedMetadata.icons.icon.unshift(...leafSegmentStaticIcons.icon);
            }
            if (leafSegmentStaticIcons.apple.length > 0) {
                resolvedMetadata.icons.apple.unshift(...leafSegmentStaticIcons.apple);
            }
        }
    }
    // Only log warnings if there are any, and only once after the metadata resolving process is finished
    if (buildState.warnings.size > 0) {
        for (const warning of buildState.warnings){
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$build$2f$output$2f$log$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["warn"](warning);
        }
    }
    return postProcessMetadata(resolvedMetadata, favicon, titleTemplates, metadataContext);
}
async function accumulateViewport(viewportItems) {
    const resolvedViewport = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$default$2d$metadata$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createDefaultViewport"])();
    const resolversAndResults = prerenderViewport(viewportItems);
    let i = 0;
    while(i < resolversAndResults.length){
        let pendingViewport = resolversAndResults[i++];
        if (typeof pendingViewport === 'function') {
            // this viewport item had a `generateViewport` and
            // we need to provide the currently resolved viewport
            // to it before we continue;
            const resolveParentViewport = pendingViewport;
            // we know that the next item is a result if this item
            // was a resolver
            pendingViewport = resolversAndResults[i++];
            resolvePendingResult(resolvedViewport, resolveParentViewport);
        }
        // Otherwise the item was either null or a static export
        let viewport;
        if (isPromiseLike(pendingViewport)) {
            viewport = await pendingViewport;
        } else {
            viewport = pendingViewport;
        }
        mergeViewport({
            target: resolvedViewport,
            source: viewport
        });
    }
    return resolvedViewport;
}
async function resolveMetadata(tree, pathname, searchParams, errorConvention, getDynamicParamFromSegment, workStore, metadataContext) {
    const metadataItems = await resolveMetadataItems(tree, searchParams, errorConvention, getDynamicParamFromSegment, workStore);
    return accumulateMetadata(workStore.route, metadataItems, pathname, metadataContext);
}
async function resolveViewport(tree, searchParams, errorConvention, getDynamicParamFromSegment, workStore) {
    const viewportItems = await resolveViewportItems(tree, searchParams, errorConvention, getDynamicParamFromSegment, workStore);
    return accumulateViewport(viewportItems);
}
function isPromiseLike(value) {
    return typeof value === 'object' && value !== null && typeof value.then === 'function';
} //# sourceMappingURL=resolve-metadata.js.map
}),
"[project]/node_modules/next/dist/esm/client/components/http-access-fallback/http-access-fallback.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "HTTPAccessErrorStatus": ()=>HTTPAccessErrorStatus,
    "HTTP_ERROR_FALLBACK_ERROR_CODE": ()=>HTTP_ERROR_FALLBACK_ERROR_CODE,
    "getAccessFallbackErrorTypeByStatus": ()=>getAccessFallbackErrorTypeByStatus,
    "getAccessFallbackHTTPStatus": ()=>getAccessFallbackHTTPStatus,
    "isHTTPAccessFallbackError": ()=>isHTTPAccessFallbackError
});
const HTTPAccessErrorStatus = {
    NOT_FOUND: 404,
    FORBIDDEN: 403,
    UNAUTHORIZED: 401
};
const ALLOWED_CODES = new Set(Object.values(HTTPAccessErrorStatus));
const HTTP_ERROR_FALLBACK_ERROR_CODE = 'NEXT_HTTP_ERROR_FALLBACK';
function isHTTPAccessFallbackError(error) {
    if (typeof error !== 'object' || error === null || !('digest' in error) || typeof error.digest !== 'string') {
        return false;
    }
    const [prefix, httpStatus] = error.digest.split(';');
    return prefix === HTTP_ERROR_FALLBACK_ERROR_CODE && ALLOWED_CODES.has(Number(httpStatus));
}
function getAccessFallbackHTTPStatus(error) {
    const httpStatus = error.digest.split(';')[1];
    return Number(httpStatus);
}
function getAccessFallbackErrorTypeByStatus(status) {
    switch(status){
        case 401:
            return 'unauthorized';
        case 403:
            return 'forbidden';
        case 404:
            return 'not-found';
        default:
            return;
    }
} //# sourceMappingURL=http-access-fallback.js.map
}),
"[project]/node_modules/next/dist/esm/client/components/metadata/async-metadata.js [app-rsc] (client reference proxy) <module evaluation>": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const { createClientModuleProxy } = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-server-dom-turbopack-server.js [app-rsc] (ecmascript)");
__turbopack_context__.n(createClientModuleProxy("[project]/node_modules/next/dist/esm/client/components/metadata/async-metadata.js <module evaluation>"));
}}),
"[project]/node_modules/next/dist/esm/client/components/metadata/async-metadata.js [app-rsc] (client reference proxy)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const { createClientModuleProxy } = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-server-dom-turbopack-server.js [app-rsc] (ecmascript)");
__turbopack_context__.n(createClientModuleProxy("[project]/node_modules/next/dist/esm/client/components/metadata/async-metadata.js"));
}}),
"[project]/node_modules/next/dist/esm/client/components/metadata/async-metadata.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$metadata$2f$async$2d$metadata$2e$js__$5b$app$2d$rsc$5d$__$28$client__reference__proxy$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/client/components/metadata/async-metadata.js [app-rsc] (client reference proxy) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$metadata$2f$async$2d$metadata$2e$js__$5b$app$2d$rsc$5d$__$28$client__reference__proxy$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/client/components/metadata/async-metadata.js [app-rsc] (client reference proxy)");
;
__turbopack_context__.n(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$metadata$2f$async$2d$metadata$2e$js__$5b$app$2d$rsc$5d$__$28$client__reference__proxy$29$__);
}),
"[project]/node_modules/next/dist/esm/server/lib/router-utils/is-postpone.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "isPostpone": ()=>isPostpone
});
const REACT_POSTPONE_TYPE = Symbol.for('react.postpone');
function isPostpone(error) {
    return typeof error === 'object' && error !== null && error.$$typeof === REACT_POSTPONE_TYPE;
} //# sourceMappingURL=is-postpone.js.map
}),
"[project]/node_modules/next/dist/esm/server/request/pathname.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "createServerPathnameForMetadata": ()=>createServerPathnameForMetadata
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$dynamic$2d$rendering$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/app-render/dynamic-rendering.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$unit$2d$async$2d$storage$2e$external$2e$js__$5b$external$5d$__$28$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$unit$2d$async$2d$storage$2e$external$2e$js$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$dynamic$2d$rendering$2d$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/dynamic-rendering-utils.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$invariant$2d$error$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/invariant-error.js [app-rsc] (ecmascript)");
;
;
;
;
function createServerPathnameForMetadata(underlyingPathname, workStore) {
    const workUnitStore = __TURBOPACK__imported__module__$5b$externals$5d2f$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$unit$2d$async$2d$storage$2e$external$2e$js__$5b$external$5d$__$28$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$unit$2d$async$2d$storage$2e$external$2e$js$2c$__cjs$29$__["workUnitAsyncStorage"].getStore();
    if (workUnitStore) {
        switch(workUnitStore.type){
            case 'prerender':
            case 'prerender-client':
            case 'prerender-ppr':
            case 'prerender-legacy':
                {
                    return createPrerenderPathname(underlyingPathname, workStore, workUnitStore);
                }
            default:
        }
    }
    return createRenderPathname(underlyingPathname);
}
function createPrerenderPathname(underlyingPathname, workStore, prerenderStore) {
    const fallbackParams = workStore.fallbackRouteParams;
    if (fallbackParams && fallbackParams.size > 0) {
        switch(prerenderStore.type){
            case 'prerender':
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$dynamic$2d$rendering$2d$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["makeHangingPromise"])(prerenderStore.renderSignal, '`pathname`');
            case 'prerender-client':
                throw Object.defineProperty(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$invariant$2d$error$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["InvariantError"]('createPrerenderPathname was called inside a client component scope.'), "__NEXT_ERROR_CODE", {
                    value: "E694",
                    enumerable: false,
                    configurable: true
                });
            case 'prerender-ppr':
                return makeErroringPathname(workStore, prerenderStore.dynamicTracking);
                //TURBOPACK unreachable
                ;
            default:
                return makeErroringPathname(workStore, null);
        }
    }
    // We don't have any fallback params so we have an entirely static safe params object
    return Promise.resolve(underlyingPathname);
}
function makeErroringPathname(workStore, dynamicTracking) {
    let reject = null;
    const promise = new Promise((_, re)=>{
        reject = re;
    });
    const originalThen = promise.then.bind(promise);
    // We instrument .then so that we can generate a tracking event only if you actually
    // await this promise, not just that it is created.
    promise.then = (onfulfilled, onrejected)=>{
        if (reject) {
            try {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$dynamic$2d$rendering$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["postponeWithTracking"])(workStore.route, 'metadata relative url resolving', dynamicTracking);
            } catch (error) {
                reject(error);
                reject = null;
            }
        }
        return originalThen(onfulfilled, onrejected);
    };
    // We wrap in a noop proxy to trick the runtime into thinking it
    // isn't a native promise (it's not really). This is so that awaiting
    // the promise will call the `then` property triggering the lazy postpone
    return new Proxy(promise, {});
}
function createRenderPathname(underlyingPathname) {
    return Promise.resolve(underlyingPathname);
} //# sourceMappingURL=pathname.js.map
}),
"[project]/node_modules/next/dist/esm/lib/metadata/metadata.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "createMetadataComponents": ()=>createMetadataComponents
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-jsx-runtime.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$basic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/metadata/generate/basic.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$alternate$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/metadata/generate/alternate.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$opengraph$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/metadata/generate/opengraph.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$icons$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/metadata/generate/icons.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$resolve$2d$metadata$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/metadata/resolve-metadata.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/metadata/generate/meta.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$http$2d$access$2d$fallback$2f$http$2d$access$2d$fallback$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/client/components/http-access-fallback/http-access-fallback.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$metadata$2d$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/metadata/metadata-constants.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$metadata$2f$async$2d$metadata$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/client/components/metadata/async-metadata.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$router$2d$utils$2f$is$2d$postpone$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/lib/router-utils/is-postpone.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2f$search$2d$params$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/request/search-params.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2f$pathname$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/request/pathname.js [app-rsc] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
function createMetadataComponents({ tree, pathname, parsedQuery, metadataContext, getDynamicParamFromSegment, appUsingSizeAdjustment, errorType, workStore, MetadataBoundary, ViewportBoundary, serveStreamingMetadata }) {
    const searchParams = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2f$search$2d$params$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createServerSearchParamsForMetadata"])(parsedQuery, workStore);
    const pathnameForMetadata = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2f$pathname$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createServerPathnameForMetadata"])(pathname, workStore);
    function ViewportTree() {
        return /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["jsxs"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Fragment"], {
            children: [
                /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["jsx"])(ViewportBoundary, {
                    children: /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["jsx"])(Viewport, {})
                }),
                appUsingSizeAdjustment ? /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["jsx"])("meta", {
                    name: "next-size-adjust",
                    content: ""
                }) : null
            ]
        });
    }
    function MetadataTree() {
        return /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["jsx"])(MetadataBoundary, {
            children: /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["jsx"])(Metadata, {})
        });
    }
    function viewport() {
        return getResolvedViewport(tree, searchParams, getDynamicParamFromSegment, workStore, errorType);
    }
    async function Viewport() {
        try {
            return await viewport();
        } catch (error) {
            if (!errorType && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$http$2d$access$2d$fallback$2f$http$2d$access$2d$fallback$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isHTTPAccessFallbackError"])(error)) {
                try {
                    return await getNotFoundViewport(tree, searchParams, getDynamicParamFromSegment, workStore);
                } catch  {}
            }
            // We don't actually want to error in this component. We will
            // also error in the MetadataOutlet which causes the error to
            // bubble from the right position in the page to be caught by the
            // appropriate boundaries
            return null;
        }
    }
    Viewport.displayName = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$metadata$2d$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["VIEWPORT_BOUNDARY_NAME"];
    function metadata() {
        return getResolvedMetadata(tree, pathnameForMetadata, searchParams, getDynamicParamFromSegment, metadataContext, workStore, errorType);
    }
    async function resolveFinalMetadata() {
        let result;
        let error = null;
        try {
            result = await metadata();
            return {
                metadata: result,
                error: null,
                digest: undefined
            };
        } catch (metadataErr) {
            error = metadataErr;
            if (!errorType && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$http$2d$access$2d$fallback$2f$http$2d$access$2d$fallback$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isHTTPAccessFallbackError"])(metadataErr)) {
                try {
                    result = await getNotFoundMetadata(tree, pathnameForMetadata, searchParams, getDynamicParamFromSegment, metadataContext, workStore);
                    return {
                        metadata: result,
                        error,
                        digest: error == null ? void 0 : error.digest
                    };
                } catch (notFoundMetadataErr) {
                    error = notFoundMetadataErr;
                    // In PPR rendering we still need to throw the postpone error.
                    // If metadata is postponed, React needs to be aware of the location of error.
                    if (serveStreamingMetadata && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$router$2d$utils$2f$is$2d$postpone$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isPostpone"])(notFoundMetadataErr)) {
                        throw notFoundMetadataErr;
                    }
                }
            }
            // In PPR rendering we still need to throw the postpone error.
            // If metadata is postponed, React needs to be aware of the location of error.
            if (serveStreamingMetadata && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$router$2d$utils$2f$is$2d$postpone$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isPostpone"])(metadataErr)) {
                throw metadataErr;
            }
            // We don't actually want to error in this component. We will
            // also error in the MetadataOutlet which causes the error to
            // bubble from the right position in the page to be caught by the
            // appropriate boundaries
            return {
                metadata: result,
                error,
                digest: error == null ? void 0 : error.digest
            };
        }
    }
    function Metadata() {
        if (!serveStreamingMetadata) {
            return /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["jsx"])(MetadataResolver, {});
        }
        return /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["jsx"])("div", {
            hidden: true,
            children: /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Suspense"], {
                fallback: null,
                children: /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["jsx"])(MetadataResolver, {})
            })
        });
    }
    async function MetadataResolver() {
        const metadataState = await resolveFinalMetadata();
        return metadataState.metadata;
    }
    Metadata.displayName = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$metadata$2d$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["METADATA_BOUNDARY_NAME"];
    async function getMetadataReady() {
        // Only warm up metadata() call when it's blocking metadata,
        // otherwise it will be fully managed by AsyncMetadata component.
        if (!serveStreamingMetadata) {
            await metadata();
        }
        return undefined;
    }
    async function getViewportReady() {
        await viewport();
        return undefined;
    }
    function StreamingMetadataOutletImpl() {
        return /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$metadata$2f$async$2d$metadata$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["AsyncMetadataOutlet"], {
            promise: resolveFinalMetadata()
        });
    }
    const StreamingMetadataOutlet = serveStreamingMetadata ? StreamingMetadataOutletImpl : null;
    return {
        ViewportTree,
        MetadataTree,
        getViewportReady,
        getMetadataReady,
        StreamingMetadataOutlet
    };
}
const getResolvedMetadata = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["cache"])(getResolvedMetadataImpl);
async function getResolvedMetadataImpl(tree, pathname, searchParams, getDynamicParamFromSegment, metadataContext, workStore, errorType) {
    const errorConvention = errorType === 'redirect' ? undefined : errorType;
    return renderMetadata(tree, pathname, searchParams, getDynamicParamFromSegment, metadataContext, workStore, errorConvention);
}
const getNotFoundMetadata = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["cache"])(getNotFoundMetadataImpl);
async function getNotFoundMetadataImpl(tree, pathname, searchParams, getDynamicParamFromSegment, metadataContext, workStore) {
    const notFoundErrorConvention = 'not-found';
    return renderMetadata(tree, pathname, searchParams, getDynamicParamFromSegment, metadataContext, workStore, notFoundErrorConvention);
}
const getResolvedViewport = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["cache"])(getResolvedViewportImpl);
async function getResolvedViewportImpl(tree, searchParams, getDynamicParamFromSegment, workStore, errorType) {
    const errorConvention = errorType === 'redirect' ? undefined : errorType;
    return renderViewport(tree, searchParams, getDynamicParamFromSegment, workStore, errorConvention);
}
const getNotFoundViewport = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["cache"])(getNotFoundViewportImpl);
async function getNotFoundViewportImpl(tree, searchParams, getDynamicParamFromSegment, workStore) {
    const notFoundErrorConvention = 'not-found';
    return renderViewport(tree, searchParams, getDynamicParamFromSegment, workStore, notFoundErrorConvention);
}
async function renderMetadata(tree, pathname, searchParams, getDynamicParamFromSegment, metadataContext, workStore, errorConvention) {
    const resolvedMetadata = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$resolve$2d$metadata$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["resolveMetadata"])(tree, pathname, searchParams, errorConvention, getDynamicParamFromSegment, workStore, metadataContext);
    const elements = createMetadataElements(resolvedMetadata);
    return /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Fragment"], {
        children: elements.map((el, index)=>{
            return /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["cloneElement"])(el, {
                key: index
            });
        })
    });
}
async function renderViewport(tree, searchParams, getDynamicParamFromSegment, workStore, errorConvention) {
    const resolvedViewport = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$resolve$2d$metadata$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["resolveViewport"])(tree, searchParams, errorConvention, getDynamicParamFromSegment, workStore);
    const elements = createViewportElements(resolvedViewport);
    return /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Fragment"], {
        children: elements.map((el, index)=>{
            return /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["cloneElement"])(el, {
                key: index
            });
        })
    });
}
function createMetadataElements(metadata) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["MetaFilter"])([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$basic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["BasicMeta"])({
            metadata
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$alternate$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["AlternatesMetadata"])({
            alternates: metadata.alternates
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$basic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ItunesMeta"])({
            itunes: metadata.itunes
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$basic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["FacebookMeta"])({
            facebook: metadata.facebook
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$basic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["PinterestMeta"])({
            pinterest: metadata.pinterest
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$basic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["FormatDetectionMeta"])({
            formatDetection: metadata.formatDetection
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$basic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["VerificationMeta"])({
            verification: metadata.verification
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$basic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["AppleWebAppMeta"])({
            appleWebApp: metadata.appleWebApp
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$opengraph$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["OpenGraphMetadata"])({
            openGraph: metadata.openGraph
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$opengraph$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["TwitterMetadata"])({
            twitter: metadata.twitter
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$opengraph$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["AppLinksMeta"])({
            appLinks: metadata.appLinks
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$icons$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["IconsMetadata"])({
            icons: metadata.icons
        })
    ]);
}
function createViewportElements(viewport) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["MetaFilter"])([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$generate$2f$basic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ViewportMeta"])({
            viewport: viewport
        })
    ]);
} //# sourceMappingURL=metadata.js.map
}),
"[project]/node_modules/next/dist/esm/client/components/metadata/metadata-boundary.js [app-rsc] (client reference proxy) <module evaluation>": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const { createClientModuleProxy } = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-server-dom-turbopack-server.js [app-rsc] (ecmascript)");
__turbopack_context__.n(createClientModuleProxy("[project]/node_modules/next/dist/esm/client/components/metadata/metadata-boundary.js <module evaluation>"));
}}),
"[project]/node_modules/next/dist/esm/client/components/metadata/metadata-boundary.js [app-rsc] (client reference proxy)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const { createClientModuleProxy } = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-server-dom-turbopack-server.js [app-rsc] (ecmascript)");
__turbopack_context__.n(createClientModuleProxy("[project]/node_modules/next/dist/esm/client/components/metadata/metadata-boundary.js"));
}}),
"[project]/node_modules/next/dist/esm/client/components/metadata/metadata-boundary.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$metadata$2f$metadata$2d$boundary$2e$js__$5b$app$2d$rsc$5d$__$28$client__reference__proxy$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/client/components/metadata/metadata-boundary.js [app-rsc] (client reference proxy) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$metadata$2f$metadata$2d$boundary$2e$js__$5b$app$2d$rsc$5d$__$28$client__reference__proxy$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/client/components/metadata/metadata-boundary.js [app-rsc] (client reference proxy)");
;
__turbopack_context__.n(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$metadata$2f$metadata$2d$boundary$2e$js__$5b$app$2d$rsc$5d$__$28$client__reference__proxy$29$__);
}),
"[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-dom.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/module.compiled.js [app-rsc] (ecmascript)").vendored['react-rsc'].ReactDOM; //# sourceMappingURL=react-dom.js.map
}}),
"[project]/node_modules/next/dist/esm/server/app-render/rsc/preloads.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/*

Files in the rsc directory are meant to be packaged as part of the RSC graph using next-app-loader.

*/ __turbopack_context__.s({
    "preconnect": ()=>preconnect,
    "preloadFont": ()=>preloadFont,
    "preloadStyle": ()=>preloadStyle
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$dom$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-dom.js [app-rsc] (ecmascript)");
;
function preloadStyle(href, crossOrigin, nonce) {
    const opts = {
        as: 'style'
    };
    if (typeof crossOrigin === 'string') {
        opts.crossOrigin = crossOrigin;
    }
    if (typeof nonce === 'string') {
        opts.nonce = nonce;
    }
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$dom$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"].preload(href, opts);
}
function preloadFont(href, type, crossOrigin, nonce) {
    const opts = {
        as: 'font',
        type
    };
    if (typeof crossOrigin === 'string') {
        opts.crossOrigin = crossOrigin;
    }
    if (typeof nonce === 'string') {
        opts.nonce = nonce;
    }
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$dom$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"].preload(href, opts);
}
function preconnect(href, crossOrigin, nonce) {
    const opts = {};
    if (typeof crossOrigin === 'string') {
        opts.crossOrigin = crossOrigin;
    }
    if (typeof nonce === 'string') {
        opts.nonce = nonce;
    }
    ;
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$dom$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"].preconnect(href, opts);
} //# sourceMappingURL=preloads.js.map
}),
"[project]/node_modules/next/dist/esm/server/app-render/rsc/postpone.js [app-rsc] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

/*

Files in the rsc directory are meant to be packaged as part of the RSC graph using next-app-loader.

*/ // When postpone is available in canary React we can switch to importing it directly
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$dynamic$2d$rendering$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/app-render/dynamic-rendering.js [app-rsc] (ecmascript)"); //# sourceMappingURL=postpone.js.map
;
}),
"[project]/node_modules/next/dist/esm/server/app-render/rsc/postpone.js [app-rsc] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$dynamic$2d$rendering$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/app-render/dynamic-rendering.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$rsc$2f$postpone$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/app-render/rsc/postpone.js [app-rsc] (ecmascript) <locals>");
}),
"[project]/node_modules/next/dist/esm/server/app-render/rsc/taint.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/*

Files in the rsc directory are meant to be packaged as part of the RSC graph using next-app-loader.

*/ __turbopack_context__.s({
    "taintObjectReference": ()=>taintObjectReference,
    "taintUniqueValue": ()=>taintUniqueValue
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-rsc] (ecmascript)");
;
function notImplemented() {
    throw Object.defineProperty(new Error('Taint can only be used with the taint flag.'), "__NEXT_ERROR_CODE", {
        value: "E354",
        enumerable: false,
        configurable: true
    });
}
const taintObjectReference = ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : notImplemented;
const taintUniqueValue = ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : notImplemented; //# sourceMappingURL=taint.js.map
}),
"[project]/node_modules/next/dist/compiled/react-server-dom-turbopack/cjs/react-server-dom-turbopack-client.node.development.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/**
 * @license React
 * react-server-dom-turbopack-client.node.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ "production" !== ("TURBOPACK compile-time value", "development") && function() {
    function resolveClientReference(bundlerConfig, metadata) {
        if (bundlerConfig) {
            var moduleExports = bundlerConfig[metadata[0]];
            if (bundlerConfig = moduleExports && moduleExports[metadata[2]]) moduleExports = bundlerConfig.name;
            else {
                bundlerConfig = moduleExports && moduleExports["*"];
                if (!bundlerConfig) throw Error('Could not find the module "' + metadata[0] + '" in the React Server Consumer Manifest. This is probably a bug in the React Server Components bundler.');
                moduleExports = metadata[2];
            }
            return 4 === metadata.length ? [
                bundlerConfig.id,
                bundlerConfig.chunks,
                moduleExports,
                1
            ] : [
                bundlerConfig.id,
                bundlerConfig.chunks,
                moduleExports
            ];
        }
        return metadata;
    }
    function resolveServerReference(bundlerConfig, id) {
        var name = "", resolvedModuleData = bundlerConfig[id];
        if (resolvedModuleData) name = resolvedModuleData.name;
        else {
            var idx = id.lastIndexOf("#");
            -1 !== idx && (name = id.slice(idx + 1), resolvedModuleData = bundlerConfig[id.slice(0, idx)]);
            if (!resolvedModuleData) throw Error('Could not find the module "' + id + '" in the React Server Manifest. This is probably a bug in the React Server Components bundler.');
        }
        return [
            resolvedModuleData.id,
            resolvedModuleData.chunks,
            name
        ];
    }
    function requireAsyncModule(id) {
        var promise = globalThis.__next_require__(id);
        if ("function" !== typeof promise.then || "fulfilled" === promise.status) return null;
        promise.then(function(value) {
            promise.status = "fulfilled";
            promise.value = value;
        }, function(reason) {
            promise.status = "rejected";
            promise.reason = reason;
        });
        return promise;
    }
    function ignoreReject() {}
    function preloadModule(metadata) {
        for(var chunks = metadata[1], promises = [], i = 0; i < chunks.length; i++){
            var chunkFilename = chunks[i], entry = chunkCache.get(chunkFilename);
            if (void 0 === entry) {
                entry = globalThis.__next_chunk_load__(chunkFilename);
                promises.push(entry);
                var resolve = chunkCache.set.bind(chunkCache, chunkFilename, null);
                entry.then(resolve, ignoreReject);
                chunkCache.set(chunkFilename, entry);
            } else null !== entry && promises.push(entry);
        }
        return 4 === metadata.length ? 0 === promises.length ? requireAsyncModule(metadata[0]) : Promise.all(promises).then(function() {
            return requireAsyncModule(metadata[0]);
        }) : 0 < promises.length ? Promise.all(promises) : null;
    }
    function requireModule(metadata) {
        var moduleExports = globalThis.__next_require__(metadata[0]);
        if (4 === metadata.length && "function" === typeof moduleExports.then) if ("fulfilled" === moduleExports.status) moduleExports = moduleExports.value;
        else throw moduleExports.reason;
        return "*" === metadata[2] ? moduleExports : "" === metadata[2] ? moduleExports.__esModule ? moduleExports.default : moduleExports : moduleExports[metadata[2]];
    }
    function prepareDestinationWithChunks(moduleLoading, chunks, nonce$jscomp$0) {
        if (null !== moduleLoading) for(var i = 0; i < chunks.length; i++){
            var nonce = nonce$jscomp$0, JSCompiler_temp_const = ReactDOMSharedInternals.d, JSCompiler_temp_const$jscomp$0 = JSCompiler_temp_const.X, JSCompiler_temp_const$jscomp$1 = moduleLoading.prefix + chunks[i];
            var JSCompiler_inline_result = moduleLoading.crossOrigin;
            JSCompiler_inline_result = "string" === typeof JSCompiler_inline_result ? "use-credentials" === JSCompiler_inline_result ? JSCompiler_inline_result : "" : void 0;
            JSCompiler_temp_const$jscomp$0.call(JSCompiler_temp_const, JSCompiler_temp_const$jscomp$1, {
                crossOrigin: JSCompiler_inline_result,
                nonce: nonce
            });
        }
    }
    function getIteratorFn(maybeIterable) {
        if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
        maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
        return "function" === typeof maybeIterable ? maybeIterable : null;
    }
    function isObjectPrototype(object) {
        if (!object) return !1;
        var ObjectPrototype = Object.prototype;
        if (object === ObjectPrototype) return !0;
        if (getPrototypeOf(object)) return !1;
        object = Object.getOwnPropertyNames(object);
        for(var i = 0; i < object.length; i++)if (!(object[i] in ObjectPrototype)) return !1;
        return !0;
    }
    function isSimpleObject(object) {
        if (!isObjectPrototype(getPrototypeOf(object))) return !1;
        for(var names = Object.getOwnPropertyNames(object), i = 0; i < names.length; i++){
            var descriptor = Object.getOwnPropertyDescriptor(object, names[i]);
            if (!descriptor || !descriptor.enumerable && ("key" !== names[i] && "ref" !== names[i] || "function" !== typeof descriptor.get)) return !1;
        }
        return !0;
    }
    function objectName(object) {
        object = Object.prototype.toString.call(object);
        return object.slice(8, object.length - 1);
    }
    function describeKeyForErrorMessage(key) {
        var encodedKey = JSON.stringify(key);
        return '"' + key + '"' === encodedKey ? key : encodedKey;
    }
    function describeValueForErrorMessage(value) {
        switch(typeof value){
            case "string":
                return JSON.stringify(10 >= value.length ? value : value.slice(0, 10) + "...");
            case "object":
                if (isArrayImpl(value)) return "[...]";
                if (null !== value && value.$$typeof === CLIENT_REFERENCE_TAG) return "client";
                value = objectName(value);
                return "Object" === value ? "{...}" : value;
            case "function":
                return value.$$typeof === CLIENT_REFERENCE_TAG ? "client" : (value = value.displayName || value.name) ? "function " + value : "function";
            default:
                return String(value);
        }
    }
    function describeElementType(type) {
        if ("string" === typeof type) return type;
        switch(type){
            case REACT_SUSPENSE_TYPE:
                return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
        }
        if ("object" === typeof type) switch(type.$$typeof){
            case REACT_FORWARD_REF_TYPE:
                return describeElementType(type.render);
            case REACT_MEMO_TYPE:
                return describeElementType(type.type);
            case REACT_LAZY_TYPE:
                var payload = type._payload;
                type = type._init;
                try {
                    return describeElementType(type(payload));
                } catch (x) {}
        }
        return "";
    }
    function describeObjectForErrorMessage(objectOrArray, expandedName) {
        var objKind = objectName(objectOrArray);
        if ("Object" !== objKind && "Array" !== objKind) return objKind;
        var start = -1, length = 0;
        if (isArrayImpl(objectOrArray)) if (jsxChildrenParents.has(objectOrArray)) {
            var type = jsxChildrenParents.get(objectOrArray);
            objKind = "<" + describeElementType(type) + ">";
            for(var i = 0; i < objectOrArray.length; i++){
                var value = objectOrArray[i];
                value = "string" === typeof value ? value : "object" === typeof value && null !== value ? "{" + describeObjectForErrorMessage(value) + "}" : "{" + describeValueForErrorMessage(value) + "}";
                "" + i === expandedName ? (start = objKind.length, length = value.length, objKind += value) : objKind = 15 > value.length && 40 > objKind.length + value.length ? objKind + value : objKind + "{...}";
            }
            objKind += "</" + describeElementType(type) + ">";
        } else {
            objKind = "[";
            for(type = 0; type < objectOrArray.length; type++)0 < type && (objKind += ", "), i = objectOrArray[type], i = "object" === typeof i && null !== i ? describeObjectForErrorMessage(i) : describeValueForErrorMessage(i), "" + type === expandedName ? (start = objKind.length, length = i.length, objKind += i) : objKind = 10 > i.length && 40 > objKind.length + i.length ? objKind + i : objKind + "...";
            objKind += "]";
        }
        else if (objectOrArray.$$typeof === REACT_ELEMENT_TYPE) objKind = "<" + describeElementType(objectOrArray.type) + "/>";
        else {
            if (objectOrArray.$$typeof === CLIENT_REFERENCE_TAG) return "client";
            if (jsxPropsParents.has(objectOrArray)) {
                objKind = jsxPropsParents.get(objectOrArray);
                objKind = "<" + (describeElementType(objKind) || "...");
                type = Object.keys(objectOrArray);
                for(i = 0; i < type.length; i++){
                    objKind += " ";
                    value = type[i];
                    objKind += describeKeyForErrorMessage(value) + "=";
                    var _value2 = objectOrArray[value];
                    var _substr2 = value === expandedName && "object" === typeof _value2 && null !== _value2 ? describeObjectForErrorMessage(_value2) : describeValueForErrorMessage(_value2);
                    "string" !== typeof _value2 && (_substr2 = "{" + _substr2 + "}");
                    value === expandedName ? (start = objKind.length, length = _substr2.length, objKind += _substr2) : objKind = 10 > _substr2.length && 40 > objKind.length + _substr2.length ? objKind + _substr2 : objKind + "...";
                }
                objKind += ">";
            } else {
                objKind = "{";
                type = Object.keys(objectOrArray);
                for(i = 0; i < type.length; i++)0 < i && (objKind += ", "), value = type[i], objKind += describeKeyForErrorMessage(value) + ": ", _value2 = objectOrArray[value], _value2 = "object" === typeof _value2 && null !== _value2 ? describeObjectForErrorMessage(_value2) : describeValueForErrorMessage(_value2), value === expandedName ? (start = objKind.length, length = _value2.length, objKind += _value2) : objKind = 10 > _value2.length && 40 > objKind.length + _value2.length ? objKind + _value2 : objKind + "...";
                objKind += "}";
            }
        }
        return void 0 === expandedName ? objKind : -1 < start && 0 < length ? (objectOrArray = " ".repeat(start) + "^".repeat(length), "\n  " + objKind + "\n  " + objectOrArray) : "\n  " + objKind;
    }
    function serializeNumber(number) {
        return Number.isFinite(number) ? 0 === number && -Infinity === 1 / number ? "$-0" : number : Infinity === number ? "$Infinity" : -Infinity === number ? "$-Infinity" : "$NaN";
    }
    function processReply(root, formFieldPrefix, temporaryReferences, resolve, reject) {
        function serializeTypedArray(tag, typedArray) {
            typedArray = new Blob([
                new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength)
            ]);
            var blobId = nextPartId++;
            null === formData && (formData = new FormData());
            formData.append(formFieldPrefix + blobId, typedArray);
            return "$" + tag + blobId.toString(16);
        }
        function serializeBinaryReader(reader) {
            function progress(entry) {
                entry.done ? (entry = nextPartId++, data.append(formFieldPrefix + entry, new Blob(buffer)), data.append(formFieldPrefix + streamId, '"$o' + entry.toString(16) + '"'), data.append(formFieldPrefix + streamId, "C"), pendingParts--, 0 === pendingParts && resolve(data)) : (buffer.push(entry.value), reader.read(new Uint8Array(1024)).then(progress, reject));
            }
            null === formData && (formData = new FormData());
            var data = formData;
            pendingParts++;
            var streamId = nextPartId++, buffer = [];
            reader.read(new Uint8Array(1024)).then(progress, reject);
            return "$r" + streamId.toString(16);
        }
        function serializeReader(reader) {
            function progress(entry) {
                if (entry.done) data.append(formFieldPrefix + streamId, "C"), pendingParts--, 0 === pendingParts && resolve(data);
                else try {
                    var partJSON = JSON.stringify(entry.value, resolveToJSON);
                    data.append(formFieldPrefix + streamId, partJSON);
                    reader.read().then(progress, reject);
                } catch (x) {
                    reject(x);
                }
            }
            null === formData && (formData = new FormData());
            var data = formData;
            pendingParts++;
            var streamId = nextPartId++;
            reader.read().then(progress, reject);
            return "$R" + streamId.toString(16);
        }
        function serializeReadableStream(stream) {
            try {
                var binaryReader = stream.getReader({
                    mode: "byob"
                });
            } catch (x) {
                return serializeReader(stream.getReader());
            }
            return serializeBinaryReader(binaryReader);
        }
        function serializeAsyncIterable(iterable, iterator) {
            function progress(entry) {
                if (entry.done) {
                    if (void 0 === entry.value) data.append(formFieldPrefix + streamId, "C");
                    else try {
                        var partJSON = JSON.stringify(entry.value, resolveToJSON);
                        data.append(formFieldPrefix + streamId, "C" + partJSON);
                    } catch (x) {
                        reject(x);
                        return;
                    }
                    pendingParts--;
                    0 === pendingParts && resolve(data);
                } else try {
                    var _partJSON = JSON.stringify(entry.value, resolveToJSON);
                    data.append(formFieldPrefix + streamId, _partJSON);
                    iterator.next().then(progress, reject);
                } catch (x$0) {
                    reject(x$0);
                }
            }
            null === formData && (formData = new FormData());
            var data = formData;
            pendingParts++;
            var streamId = nextPartId++;
            iterable = iterable === iterator;
            iterator.next().then(progress, reject);
            return "$" + (iterable ? "x" : "X") + streamId.toString(16);
        }
        function resolveToJSON(key, value) {
            var originalValue = this[key];
            "object" !== typeof originalValue || originalValue === value || originalValue instanceof Date || ("Object" !== objectName(originalValue) ? console.error("Only plain objects can be passed to Server Functions from the Client. %s objects are not supported.%s", objectName(originalValue), describeObjectForErrorMessage(this, key)) : console.error("Only plain objects can be passed to Server Functions from the Client. Objects with toJSON methods are not supported. Convert it manually to a simple value before passing it to props.%s", describeObjectForErrorMessage(this, key)));
            if (null === value) return null;
            if ("object" === typeof value) {
                switch(value.$$typeof){
                    case REACT_ELEMENT_TYPE:
                        if (void 0 !== temporaryReferences && -1 === key.indexOf(":")) {
                            var parentReference = writtenObjects.get(this);
                            if (void 0 !== parentReference) return temporaryReferences.set(parentReference + ":" + key, value), "$T";
                        }
                        throw Error("React Element cannot be passed to Server Functions from the Client without a temporary reference set. Pass a TemporaryReferenceSet to the options." + describeObjectForErrorMessage(this, key));
                    case REACT_LAZY_TYPE:
                        originalValue = value._payload;
                        var init = value._init;
                        null === formData && (formData = new FormData());
                        pendingParts++;
                        try {
                            parentReference = init(originalValue);
                            var lazyId = nextPartId++, partJSON = serializeModel(parentReference, lazyId);
                            formData.append(formFieldPrefix + lazyId, partJSON);
                            return "$" + lazyId.toString(16);
                        } catch (x) {
                            if ("object" === typeof x && null !== x && "function" === typeof x.then) {
                                pendingParts++;
                                var _lazyId = nextPartId++;
                                parentReference = function() {
                                    try {
                                        var _partJSON2 = serializeModel(value, _lazyId), _data = formData;
                                        _data.append(formFieldPrefix + _lazyId, _partJSON2);
                                        pendingParts--;
                                        0 === pendingParts && resolve(_data);
                                    } catch (reason) {
                                        reject(reason);
                                    }
                                };
                                x.then(parentReference, parentReference);
                                return "$" + _lazyId.toString(16);
                            }
                            reject(x);
                            return null;
                        } finally{
                            pendingParts--;
                        }
                }
                if ("function" === typeof value.then) {
                    null === formData && (formData = new FormData());
                    pendingParts++;
                    var promiseId = nextPartId++;
                    value.then(function(partValue) {
                        try {
                            var _partJSON3 = serializeModel(partValue, promiseId);
                            partValue = formData;
                            partValue.append(formFieldPrefix + promiseId, _partJSON3);
                            pendingParts--;
                            0 === pendingParts && resolve(partValue);
                        } catch (reason) {
                            reject(reason);
                        }
                    }, reject);
                    return "$@" + promiseId.toString(16);
                }
                parentReference = writtenObjects.get(value);
                if (void 0 !== parentReference) if (modelRoot === value) modelRoot = null;
                else return parentReference;
                else -1 === key.indexOf(":") && (parentReference = writtenObjects.get(this), void 0 !== parentReference && (parentReference = parentReference + ":" + key, writtenObjects.set(value, parentReference), void 0 !== temporaryReferences && temporaryReferences.set(parentReference, value)));
                if (isArrayImpl(value)) return value;
                if (value instanceof FormData) {
                    null === formData && (formData = new FormData());
                    var _data3 = formData;
                    key = nextPartId++;
                    var prefix = formFieldPrefix + key + "_";
                    value.forEach(function(originalValue, originalKey) {
                        _data3.append(prefix + originalKey, originalValue);
                    });
                    return "$K" + key.toString(16);
                }
                if (value instanceof Map) return key = nextPartId++, parentReference = serializeModel(Array.from(value), key), null === formData && (formData = new FormData()), formData.append(formFieldPrefix + key, parentReference), "$Q" + key.toString(16);
                if (value instanceof Set) return key = nextPartId++, parentReference = serializeModel(Array.from(value), key), null === formData && (formData = new FormData()), formData.append(formFieldPrefix + key, parentReference), "$W" + key.toString(16);
                if (value instanceof ArrayBuffer) return key = new Blob([
                    value
                ]), parentReference = nextPartId++, null === formData && (formData = new FormData()), formData.append(formFieldPrefix + parentReference, key), "$A" + parentReference.toString(16);
                if (value instanceof Int8Array) return serializeTypedArray("O", value);
                if (value instanceof Uint8Array) return serializeTypedArray("o", value);
                if (value instanceof Uint8ClampedArray) return serializeTypedArray("U", value);
                if (value instanceof Int16Array) return serializeTypedArray("S", value);
                if (value instanceof Uint16Array) return serializeTypedArray("s", value);
                if (value instanceof Int32Array) return serializeTypedArray("L", value);
                if (value instanceof Uint32Array) return serializeTypedArray("l", value);
                if (value instanceof Float32Array) return serializeTypedArray("G", value);
                if (value instanceof Float64Array) return serializeTypedArray("g", value);
                if (value instanceof BigInt64Array) return serializeTypedArray("M", value);
                if (value instanceof BigUint64Array) return serializeTypedArray("m", value);
                if (value instanceof DataView) return serializeTypedArray("V", value);
                if ("function" === typeof Blob && value instanceof Blob) return null === formData && (formData = new FormData()), key = nextPartId++, formData.append(formFieldPrefix + key, value), "$B" + key.toString(16);
                if (parentReference = getIteratorFn(value)) return parentReference = parentReference.call(value), parentReference === value ? (key = nextPartId++, parentReference = serializeModel(Array.from(parentReference), key), null === formData && (formData = new FormData()), formData.append(formFieldPrefix + key, parentReference), "$i" + key.toString(16)) : Array.from(parentReference);
                if ("function" === typeof ReadableStream && value instanceof ReadableStream) return serializeReadableStream(value);
                parentReference = value[ASYNC_ITERATOR];
                if ("function" === typeof parentReference) return serializeAsyncIterable(value, parentReference.call(value));
                parentReference = getPrototypeOf(value);
                if (parentReference !== ObjectPrototype && (null === parentReference || null !== getPrototypeOf(parentReference))) {
                    if (void 0 === temporaryReferences) throw Error("Only plain objects, and a few built-ins, can be passed to Server Functions. Classes or null prototypes are not supported." + describeObjectForErrorMessage(this, key));
                    return "$T";
                }
                value.$$typeof === REACT_CONTEXT_TYPE ? console.error("React Context Providers cannot be passed to Server Functions from the Client.%s", describeObjectForErrorMessage(this, key)) : "Object" !== objectName(value) ? console.error("Only plain objects can be passed to Server Functions from the Client. %s objects are not supported.%s", objectName(value), describeObjectForErrorMessage(this, key)) : isSimpleObject(value) ? Object.getOwnPropertySymbols && (parentReference = Object.getOwnPropertySymbols(value), 0 < parentReference.length && console.error("Only plain objects can be passed to Server Functions from the Client. Objects with symbol properties like %s are not supported.%s", parentReference[0].description, describeObjectForErrorMessage(this, key))) : console.error("Only plain objects can be passed to Server Functions from the Client. Classes or other objects with methods are not supported.%s", describeObjectForErrorMessage(this, key));
                return value;
            }
            if ("string" === typeof value) {
                if ("Z" === value[value.length - 1] && this[key] instanceof Date) return "$D" + value;
                key = "$" === value[0] ? "$" + value : value;
                return key;
            }
            if ("boolean" === typeof value) return value;
            if ("number" === typeof value) return serializeNumber(value);
            if ("undefined" === typeof value) return "$undefined";
            if ("function" === typeof value) {
                parentReference = knownServerReferences.get(value);
                if (void 0 !== parentReference) return key = JSON.stringify({
                    id: parentReference.id,
                    bound: parentReference.bound
                }, resolveToJSON), null === formData && (formData = new FormData()), parentReference = nextPartId++, formData.set(formFieldPrefix + parentReference, key), "$F" + parentReference.toString(16);
                if (void 0 !== temporaryReferences && -1 === key.indexOf(":") && (parentReference = writtenObjects.get(this), void 0 !== parentReference)) return temporaryReferences.set(parentReference + ":" + key, value), "$T";
                throw Error("Client Functions cannot be passed directly to Server Functions. Only Functions passed from the Server can be passed back again.");
            }
            if ("symbol" === typeof value) {
                if (void 0 !== temporaryReferences && -1 === key.indexOf(":") && (parentReference = writtenObjects.get(this), void 0 !== parentReference)) return temporaryReferences.set(parentReference + ":" + key, value), "$T";
                throw Error("Symbols cannot be passed to a Server Function without a temporary reference set. Pass a TemporaryReferenceSet to the options." + describeObjectForErrorMessage(this, key));
            }
            if ("bigint" === typeof value) return "$n" + value.toString(10);
            throw Error("Type " + typeof value + " is not supported as an argument to a Server Function.");
        }
        function serializeModel(model, id) {
            "object" === typeof model && null !== model && (id = "$" + id.toString(16), writtenObjects.set(model, id), void 0 !== temporaryReferences && temporaryReferences.set(id, model));
            modelRoot = model;
            return JSON.stringify(model, resolveToJSON);
        }
        var nextPartId = 1, pendingParts = 0, formData = null, writtenObjects = new WeakMap(), modelRoot = root, json = serializeModel(root, 0);
        null === formData ? resolve(json) : (formData.set(formFieldPrefix + "0", json), 0 === pendingParts && resolve(formData));
        return function() {
            0 < pendingParts && (pendingParts = 0, null === formData ? resolve(json) : resolve(formData));
        };
    }
    function encodeFormData(reference) {
        var resolve, reject, thenable = new Promise(function(res, rej) {
            resolve = res;
            reject = rej;
        });
        processReply(reference, "", void 0, function(body) {
            if ("string" === typeof body) {
                var data = new FormData();
                data.append("0", body);
                body = data;
            }
            thenable.status = "fulfilled";
            thenable.value = body;
            resolve(body);
        }, function(e) {
            thenable.status = "rejected";
            thenable.reason = e;
            reject(e);
        });
        return thenable;
    }
    function defaultEncodeFormAction(identifierPrefix) {
        var referenceClosure = knownServerReferences.get(this);
        if (!referenceClosure) throw Error("Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React.");
        var data = null;
        if (null !== referenceClosure.bound) {
            data = boundCache.get(referenceClosure);
            data || (data = encodeFormData({
                id: referenceClosure.id,
                bound: referenceClosure.bound
            }), boundCache.set(referenceClosure, data));
            if ("rejected" === data.status) throw data.reason;
            if ("fulfilled" !== data.status) throw data;
            referenceClosure = data.value;
            var prefixedData = new FormData();
            referenceClosure.forEach(function(value, key) {
                prefixedData.append("$ACTION_" + identifierPrefix + ":" + key, value);
            });
            data = prefixedData;
            referenceClosure = "$ACTION_REF_" + identifierPrefix;
        } else referenceClosure = "$ACTION_ID_" + referenceClosure.id;
        return {
            name: referenceClosure,
            method: "POST",
            encType: "multipart/form-data",
            data: data
        };
    }
    function isSignatureEqual(referenceId, numberOfBoundArgs) {
        var referenceClosure = knownServerReferences.get(this);
        if (!referenceClosure) throw Error("Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React.");
        if (referenceClosure.id !== referenceId) return !1;
        var boundPromise = referenceClosure.bound;
        if (null === boundPromise) return 0 === numberOfBoundArgs;
        switch(boundPromise.status){
            case "fulfilled":
                return boundPromise.value.length === numberOfBoundArgs;
            case "pending":
                throw boundPromise;
            case "rejected":
                throw boundPromise.reason;
            default:
                throw "string" !== typeof boundPromise.status && (boundPromise.status = "pending", boundPromise.then(function(boundArgs) {
                    boundPromise.status = "fulfilled";
                    boundPromise.value = boundArgs;
                }, function(error) {
                    boundPromise.status = "rejected";
                    boundPromise.reason = error;
                })), boundPromise;
        }
    }
    function createFakeServerFunction(name, filename, sourceMap, line, col, environmentName, innerFunction) {
        name || (name = "<anonymous>");
        var encodedName = JSON.stringify(name);
        1 >= line ? (line = encodedName.length + 7, col = "s=>({" + encodedName + " ".repeat(col < line ? 0 : col - line) + ":(...args) => s(...args)})\n/* This module is a proxy to a Server Action. Turn on Source Maps to see the server source. */") : col = "/* This module is a proxy to a Server Action. Turn on Source Maps to see the server source. */" + "\n".repeat(line - 2) + "server=>({" + encodedName + ":\n" + " ".repeat(1 > col ? 0 : col - 1) + "(...args) => server(...args)})";
        filename.startsWith("/") && (filename = "file://" + filename);
        sourceMap ? (col += "\n//# sourceURL=rsc://React/" + encodeURIComponent(environmentName) + "/" + encodeURI(filename) + "?s" + fakeServerFunctionIdx++, col += "\n//# sourceMappingURL=" + sourceMap) : filename && (col += "\n//# sourceURL=" + filename);
        try {
            return (0, eval)(col)(innerFunction)[name];
        } catch (x) {
            return innerFunction;
        }
    }
    function registerBoundServerReference(reference, id, bound, encodeFormAction) {
        knownServerReferences.has(reference) || (knownServerReferences.set(reference, {
            id: id,
            originalBind: reference.bind,
            bound: bound
        }), Object.defineProperties(reference, {
            $$FORM_ACTION: {
                value: void 0 === encodeFormAction ? defaultEncodeFormAction : function() {
                    var referenceClosure = knownServerReferences.get(this);
                    if (!referenceClosure) throw Error("Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React.");
                    var boundPromise = referenceClosure.bound;
                    null === boundPromise && (boundPromise = Promise.resolve([]));
                    return encodeFormAction(referenceClosure.id, boundPromise);
                }
            },
            $$IS_SIGNATURE_EQUAL: {
                value: isSignatureEqual
            },
            bind: {
                value: bind
            }
        }));
    }
    function bind() {
        var referenceClosure = knownServerReferences.get(this);
        if (!referenceClosure) return FunctionBind.apply(this, arguments);
        var newFn = referenceClosure.originalBind.apply(this, arguments);
        null != arguments[0] && console.error('Cannot bind "this" of a Server Action. Pass null or undefined as the first argument to .bind().');
        var args = ArraySlice.call(arguments, 1), boundPromise = null;
        boundPromise = null !== referenceClosure.bound ? Promise.resolve(referenceClosure.bound).then(function(boundArgs) {
            return boundArgs.concat(args);
        }) : Promise.resolve(args);
        knownServerReferences.set(newFn, {
            id: referenceClosure.id,
            originalBind: newFn.bind,
            bound: boundPromise
        });
        Object.defineProperties(newFn, {
            $$FORM_ACTION: {
                value: this.$$FORM_ACTION
            },
            $$IS_SIGNATURE_EQUAL: {
                value: isSignatureEqual
            },
            bind: {
                value: bind
            }
        });
        return newFn;
    }
    function createBoundServerReference(metaData, callServer, encodeFormAction, findSourceMapURL) {
        function action() {
            var args = Array.prototype.slice.call(arguments);
            return bound ? "fulfilled" === bound.status ? callServer(id, bound.value.concat(args)) : Promise.resolve(bound).then(function(boundArgs) {
                return callServer(id, boundArgs.concat(args));
            }) : callServer(id, args);
        }
        var id = metaData.id, bound = metaData.bound, location = metaData.location;
        if (location) {
            var functionName = metaData.name || "", filename = location[1], line = location[2];
            location = location[3];
            metaData = metaData.env || "Server";
            findSourceMapURL = null == findSourceMapURL ? null : findSourceMapURL(filename, metaData);
            action = createFakeServerFunction(functionName, filename, findSourceMapURL, line, location, metaData, action);
        }
        registerBoundServerReference(action, id, bound, encodeFormAction);
        return action;
    }
    function parseStackLocation(error) {
        error = error.stack;
        error.startsWith("Error: react-stack-top-frame\n") && (error = error.slice(29));
        var endOfFirst = error.indexOf("\n");
        if (-1 !== endOfFirst) {
            var endOfSecond = error.indexOf("\n", endOfFirst + 1);
            endOfFirst = -1 === endOfSecond ? error.slice(endOfFirst + 1) : error.slice(endOfFirst + 1, endOfSecond);
        } else endOfFirst = error;
        error = v8FrameRegExp.exec(endOfFirst);
        if (!error && (error = jscSpiderMonkeyFrameRegExp.exec(endOfFirst), !error)) return null;
        endOfFirst = error[1] || "";
        "<anonymous>" === endOfFirst && (endOfFirst = "");
        endOfSecond = error[2] || error[5] || "";
        "<anonymous>" === endOfSecond && (endOfSecond = "");
        return [
            endOfFirst,
            endOfSecond,
            +(error[3] || error[6]),
            +(error[4] || error[7])
        ];
    }
    function createServerReference$1(id, callServer, encodeFormAction, findSourceMapURL, functionName) {
        function action() {
            var args = Array.prototype.slice.call(arguments);
            return callServer(id, args);
        }
        var location = parseStackLocation(Error("react-stack-top-frame"));
        if (null !== location) {
            var filename = location[1], line = location[2];
            location = location[3];
            findSourceMapURL = null == findSourceMapURL ? null : findSourceMapURL(filename, "Client");
            action = createFakeServerFunction(functionName || "", filename, findSourceMapURL, line, location, "Client", action);
        }
        registerBoundServerReference(action, id, null, encodeFormAction);
        return action;
    }
    function getComponentNameFromType(type) {
        if (null == type) return null;
        if ("function" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        switch(type){
            case REACT_FRAGMENT_TYPE:
                return "Fragment";
            case REACT_PROFILER_TYPE:
                return "Profiler";
            case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
            case REACT_SUSPENSE_TYPE:
                return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
            case REACT_ACTIVITY_TYPE:
                return "Activity";
        }
        if ("object" === typeof type) switch("number" === typeof type.tag && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof){
            case REACT_PORTAL_TYPE:
                return "Portal";
            case REACT_CONTEXT_TYPE:
                return type.displayName || "Context";
            case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
                var innerType = type.render;
                type = type.displayName;
                type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                return type;
            case REACT_MEMO_TYPE:
                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
                innerType = type._payload;
                type = type._init;
                try {
                    return getComponentNameFromType(type(innerType));
                } catch (x) {}
        }
        return null;
    }
    function prepareStackTrace(error, structuredStackTrace) {
        error = (error.name || "Error") + ": " + (error.message || "");
        for(var i = 0; i < structuredStackTrace.length; i++)error += "\n    at " + structuredStackTrace[i].toString();
        return error;
    }
    function ReactPromise(status, value, reason) {
        this.status = status;
        this.value = value;
        this.reason = reason;
        this._debugInfo = null;
    }
    function unwrapWeakResponse(weakResponse) {
        weakResponse = weakResponse.weak.deref();
        if (void 0 === weakResponse) throw Error("We did not expect to receive new data after GC:ing the response.");
        return weakResponse;
    }
    function cleanupDebugChannel(debugChannel) {
        debugChannel("");
    }
    function readChunk(chunk) {
        switch(chunk.status){
            case "resolved_model":
                initializeModelChunk(chunk);
                break;
            case "resolved_module":
                initializeModuleChunk(chunk);
        }
        switch(chunk.status){
            case "fulfilled":
                return chunk.value;
            case "pending":
            case "blocked":
            case "halted":
                throw chunk;
            default:
                throw chunk.reason;
        }
    }
    function getRoot(weakResponse) {
        weakResponse = unwrapWeakResponse(weakResponse);
        return getChunk(weakResponse, 0);
    }
    function createPendingChunk(response) {
        0 === response._pendingChunks++ && (response._weakResponse.response = response, null !== response._pendingInitialRender && (clearTimeout(response._pendingInitialRender), response._pendingInitialRender = null));
        return new ReactPromise("pending", null, null);
    }
    function releasePendingChunk(response, chunk) {
        "pending" === chunk.status && 0 === --response._pendingChunks && (response._weakResponse.response = null, response._pendingInitialRender = setTimeout(flushInitialRenderPerformance.bind(null, response), 100));
    }
    function wakeChunk(listeners, value) {
        for(var i = 0; i < listeners.length; i++){
            var listener = listeners[i];
            "function" === typeof listener ? listener(value) : fulfillReference(listener, value);
        }
    }
    function rejectChunk(listeners, error) {
        for(var i = 0; i < listeners.length; i++){
            var listener = listeners[i];
            "function" === typeof listener ? listener(error) : rejectReference(listener, error);
        }
    }
    function resolveBlockedCycle(resolvedChunk, reference) {
        var referencedChunk = reference.handler.chunk;
        if (null === referencedChunk) return null;
        if (referencedChunk === resolvedChunk) return reference.handler;
        reference = referencedChunk.value;
        if (null !== reference) for(referencedChunk = 0; referencedChunk < reference.length; referencedChunk++){
            var listener = reference[referencedChunk];
            if ("function" !== typeof listener && (listener = resolveBlockedCycle(resolvedChunk, listener), null !== listener)) return listener;
        }
        return null;
    }
    function wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners) {
        switch(chunk.status){
            case "fulfilled":
                wakeChunk(resolveListeners, chunk.value);
                break;
            case "blocked":
                for(var i = 0; i < resolveListeners.length; i++){
                    var listener = resolveListeners[i];
                    if ("function" !== typeof listener) {
                        var cyclicHandler = resolveBlockedCycle(chunk, listener);
                        null !== cyclicHandler && (fulfillReference(listener, cyclicHandler.value), resolveListeners.splice(i, 1), i--, null !== rejectListeners && (listener = rejectListeners.indexOf(listener), -1 !== listener && rejectListeners.splice(listener, 1)));
                    }
                }
            case "pending":
                if (chunk.value) for(i = 0; i < resolveListeners.length; i++)chunk.value.push(resolveListeners[i]);
                else chunk.value = resolveListeners;
                if (chunk.reason) {
                    if (rejectListeners) for(resolveListeners = 0; resolveListeners < rejectListeners.length; resolveListeners++)chunk.reason.push(rejectListeners[resolveListeners]);
                } else chunk.reason = rejectListeners;
                break;
            case "rejected":
                rejectListeners && rejectChunk(rejectListeners, chunk.reason);
        }
    }
    function triggerErrorOnChunk(response, chunk, error) {
        "pending" !== chunk.status && "blocked" !== chunk.status ? chunk.reason.error(error) : (releasePendingChunk(response, chunk), response = chunk.reason, chunk.status = "rejected", chunk.reason = error, null !== response && rejectChunk(response, error));
    }
    function createResolvedIteratorResultChunk(response, value, done) {
        return new ReactPromise("resolved_model", (done ? '{"done":true,"value":' : '{"done":false,"value":') + value + "}", response);
    }
    function resolveIteratorResultChunk(response, chunk, value, done) {
        resolveModelChunk(response, chunk, (done ? '{"done":true,"value":' : '{"done":false,"value":') + value + "}");
    }
    function resolveModelChunk(response, chunk, value) {
        if ("pending" !== chunk.status) chunk.reason.enqueueModel(value);
        else {
            releasePendingChunk(response, chunk);
            var resolveListeners = chunk.value, rejectListeners = chunk.reason;
            chunk.status = "resolved_model";
            chunk.value = value;
            chunk.reason = response;
            null !== resolveListeners && (initializeModelChunk(chunk), wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners));
        }
    }
    function resolveModuleChunk(response, chunk, value) {
        if ("pending" === chunk.status || "blocked" === chunk.status) {
            releasePendingChunk(response, chunk);
            response = chunk.value;
            var rejectListeners = chunk.reason;
            chunk.status = "resolved_module";
            chunk.value = value;
            null !== response && (initializeModuleChunk(chunk), wakeChunkIfInitialized(chunk, response, rejectListeners));
        }
    }
    function initializeModelChunk(chunk) {
        var prevHandler = initializingHandler;
        initializingHandler = null;
        var resolvedModel = chunk.value, response = chunk.reason;
        chunk.status = "blocked";
        chunk.value = null;
        chunk.reason = null;
        try {
            var value = JSON.parse(resolvedModel, response._fromJSON), resolveListeners = chunk.value;
            null !== resolveListeners && (chunk.value = null, chunk.reason = null, wakeChunk(resolveListeners, value));
            if (null !== initializingHandler) {
                if (initializingHandler.errored) throw initializingHandler.value;
                if (0 < initializingHandler.deps) {
                    initializingHandler.value = value;
                    initializingHandler.chunk = chunk;
                    return;
                }
            }
            chunk.status = "fulfilled";
            chunk.value = value;
        } catch (error) {
            chunk.status = "rejected", chunk.reason = error;
        } finally{
            initializingHandler = prevHandler;
        }
    }
    function initializeModuleChunk(chunk) {
        try {
            var value = requireModule(chunk.value);
            chunk.status = "fulfilled";
            chunk.value = value;
        } catch (error) {
            chunk.status = "rejected", chunk.reason = error;
        }
    }
    function reportGlobalError(weakResponse, error) {
        if (void 0 !== weakResponse.weak.deref()) {
            var response = unwrapWeakResponse(weakResponse);
            response._closed = !0;
            response._closedReason = error;
            response._chunks.forEach(function(chunk) {
                "pending" === chunk.status && triggerErrorOnChunk(response, chunk, error);
            });
            weakResponse = response._debugChannel;
            void 0 !== weakResponse && (weakResponse(""), response._debugChannel = void 0);
        }
    }
    function nullRefGetter() {
        return null;
    }
    function getTaskName(type) {
        if (type === REACT_FRAGMENT_TYPE) return "<>";
        if ("function" === typeof type) return '"use client"';
        if ("object" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE) return type._init === readChunk ? '"use client"' : "<...>";
        try {
            var name = getComponentNameFromType(type);
            return name ? "<" + name + ">" : "<...>";
        } catch (x) {
            return "<...>";
        }
    }
    function initializeElement(response, element) {
        var stack = element._debugStack, owner = element._owner;
        null === owner && (element._owner = response._debugRootOwner);
        var env = response._rootEnvironmentName;
        null !== owner && null != owner.env && (env = owner.env);
        var normalizedStackTrace = null;
        null === owner && null != response._debugRootStack ? normalizedStackTrace = response._debugRootStack : null !== stack && (normalizedStackTrace = createFakeJSXCallStackInDEV(response, stack, env));
        element._debugStack = normalizedStackTrace;
        normalizedStackTrace = null;
        supportsCreateTask && null !== stack && (normalizedStackTrace = console.createTask.bind(console, getTaskName(element.type)), stack = buildFakeCallStack(response, stack, env, !1, normalizedStackTrace), env = null === owner ? null : initializeFakeTask(response, owner), null === env ? (env = response._debugRootTask, normalizedStackTrace = null != env ? env.run(stack) : stack()) : normalizedStackTrace = env.run(stack));
        element._debugTask = normalizedStackTrace;
        null !== owner && initializeFakeStack(response, owner);
        Object.freeze(element.props);
    }
    function createLazyChunkWrapper(chunk) {
        var lazyType = {
            $$typeof: REACT_LAZY_TYPE,
            _payload: chunk,
            _init: readChunk
        };
        chunk = chunk._debugInfo || (chunk._debugInfo = []);
        lazyType._debugInfo = chunk;
        return lazyType;
    }
    function getChunk(response, id) {
        var chunks = response._chunks, chunk = chunks.get(id);
        chunk || (chunk = response._closed ? new ReactPromise("rejected", null, response._closedReason) : createPendingChunk(response), chunks.set(id, chunk));
        return chunk;
    }
    function fulfillReference(reference, value) {
        for(var response = reference.response, handler = reference.handler, parentObject = reference.parentObject, key = reference.key, map = reference.map, path = reference.path, i = 1; i < path.length; i++){
            for(; value.$$typeof === REACT_LAZY_TYPE;)if (value = value._payload, value === handler.chunk) value = handler.value;
            else {
                switch(value.status){
                    case "resolved_model":
                        initializeModelChunk(value);
                        break;
                    case "resolved_module":
                        initializeModuleChunk(value);
                }
                switch(value.status){
                    case "fulfilled":
                        value = value.value;
                        continue;
                    case "blocked":
                        var cyclicHandler = resolveBlockedCycle(value, reference);
                        if (null !== cyclicHandler) {
                            value = cyclicHandler.value;
                            continue;
                        }
                    case "pending":
                        path.splice(0, i - 1);
                        null === value.value ? value.value = [
                            reference
                        ] : value.value.push(reference);
                        null === value.reason ? value.reason = [
                            reference
                        ] : value.reason.push(reference);
                        return;
                    case "halted":
                        return;
                    default:
                        rejectReference(reference, value.reason);
                        return;
                }
            }
            value = value[path[i]];
        }
        reference = map(response, value, parentObject, key);
        parentObject[key] = reference;
        "" === key && null === handler.value && (handler.value = reference);
        if (parentObject[0] === REACT_ELEMENT_TYPE && "object" === typeof handler.value && null !== handler.value && handler.value.$$typeof === REACT_ELEMENT_TYPE) switch(parentObject = handler.value, key){
            case "3":
                parentObject.props = reference;
                break;
            case "4":
                parentObject._owner = reference;
                break;
            case "5":
                parentObject._debugStack = reference;
        }
        handler.deps--;
        0 === handler.deps && (key = handler.chunk, null !== key && "blocked" === key.status && (parentObject = key.value, key.status = "fulfilled", key.value = handler.value, null !== parentObject && wakeChunk(parentObject, handler.value)));
    }
    function rejectReference(reference, error) {
        var handler = reference.handler;
        reference = reference.response;
        if (!handler.errored) {
            var blockedValue = handler.value;
            handler.errored = !0;
            handler.value = error;
            handler = handler.chunk;
            if (null !== handler && "blocked" === handler.status) {
                if ("object" === typeof blockedValue && null !== blockedValue && blockedValue.$$typeof === REACT_ELEMENT_TYPE) {
                    var erroredComponent = {
                        name: getComponentNameFromType(blockedValue.type) || "",
                        owner: blockedValue._owner
                    };
                    erroredComponent.debugStack = blockedValue._debugStack;
                    supportsCreateTask && (erroredComponent.debugTask = blockedValue._debugTask);
                    (handler._debugInfo || (handler._debugInfo = [])).push(erroredComponent);
                }
                triggerErrorOnChunk(reference, handler, error);
            }
        }
    }
    function waitForReference(referencedChunk, parentObject, key, response, map, path) {
        if (initializingHandler) {
            var handler = initializingHandler;
            handler.deps++;
        } else handler = initializingHandler = {
            parent: null,
            chunk: null,
            value: null,
            deps: 1,
            errored: !1
        };
        parentObject = {
            response: response,
            handler: handler,
            parentObject: parentObject,
            key: key,
            map: map,
            path: path
        };
        null === referencedChunk.value ? referencedChunk.value = [
            parentObject
        ] : referencedChunk.value.push(parentObject);
        null === referencedChunk.reason ? referencedChunk.reason = [
            parentObject
        ] : referencedChunk.reason.push(parentObject);
        return null;
    }
    function loadServerReference(response, metaData, parentObject, key) {
        if (!response._serverReferenceConfig) return createBoundServerReference(metaData, response._callServer, response._encodeFormAction, response._debugFindSourceMapURL);
        var serverReference = resolveServerReference(response._serverReferenceConfig, metaData.id), promise = preloadModule(serverReference);
        if (promise) metaData.bound && (promise = Promise.all([
            promise,
            metaData.bound
        ]));
        else if (metaData.bound) promise = Promise.resolve(metaData.bound);
        else return promise = requireModule(serverReference), registerBoundServerReference(promise, metaData.id, metaData.bound, response._encodeFormAction), promise;
        if (initializingHandler) {
            var handler = initializingHandler;
            handler.deps++;
        } else handler = initializingHandler = {
            parent: null,
            chunk: null,
            value: null,
            deps: 1,
            errored: !1
        };
        promise.then(function() {
            var resolvedValue = requireModule(serverReference);
            if (metaData.bound) {
                var boundArgs = metaData.bound.value.slice(0);
                boundArgs.unshift(null);
                resolvedValue = resolvedValue.bind.apply(resolvedValue, boundArgs);
            }
            registerBoundServerReference(resolvedValue, metaData.id, metaData.bound, response._encodeFormAction);
            parentObject[key] = resolvedValue;
            "" === key && null === handler.value && (handler.value = resolvedValue);
            if (parentObject[0] === REACT_ELEMENT_TYPE && "object" === typeof handler.value && null !== handler.value && handler.value.$$typeof === REACT_ELEMENT_TYPE) switch(boundArgs = handler.value, key){
                case "3":
                    boundArgs.props = resolvedValue;
                    break;
                case "4":
                    boundArgs._owner = resolvedValue;
            }
            handler.deps--;
            0 === handler.deps && (resolvedValue = handler.chunk, null !== resolvedValue && "blocked" === resolvedValue.status && (boundArgs = resolvedValue.value, resolvedValue.status = "fulfilled", resolvedValue.value = handler.value, null !== boundArgs && wakeChunk(boundArgs, handler.value)));
        }, function(error) {
            if (!handler.errored) {
                var blockedValue = handler.value;
                handler.errored = !0;
                handler.value = error;
                var chunk = handler.chunk;
                if (null !== chunk && "blocked" === chunk.status) {
                    if ("object" === typeof blockedValue && null !== blockedValue && blockedValue.$$typeof === REACT_ELEMENT_TYPE) {
                        var erroredComponent = {
                            name: getComponentNameFromType(blockedValue.type) || "",
                            owner: blockedValue._owner
                        };
                        erroredComponent.debugStack = blockedValue._debugStack;
                        supportsCreateTask && (erroredComponent.debugTask = blockedValue._debugTask);
                        (chunk._debugInfo || (chunk._debugInfo = [])).push(erroredComponent);
                    }
                    triggerErrorOnChunk(response, chunk, error);
                }
            }
        });
        return null;
    }
    function getOutlinedModel(response, reference, parentObject, key, map) {
        reference = reference.split(":");
        var id = parseInt(reference[0], 16);
        id = getChunk(response, id);
        switch(id.status){
            case "resolved_model":
                initializeModelChunk(id);
                break;
            case "resolved_module":
                initializeModuleChunk(id);
        }
        switch(id.status){
            case "fulfilled":
                for(var value = id.value, i = 1; i < reference.length; i++){
                    for(; value.$$typeof === REACT_LAZY_TYPE;){
                        value = value._payload;
                        switch(value.status){
                            case "resolved_model":
                                initializeModelChunk(value);
                                break;
                            case "resolved_module":
                                initializeModuleChunk(value);
                        }
                        switch(value.status){
                            case "fulfilled":
                                value = value.value;
                                break;
                            case "blocked":
                            case "pending":
                                return waitForReference(value, parentObject, key, response, map, reference.slice(i - 1));
                            case "halted":
                                return initializingHandler ? (response = initializingHandler, response.deps++) : initializingHandler = {
                                    parent: null,
                                    chunk: null,
                                    value: null,
                                    deps: 1,
                                    errored: !1
                                }, null;
                            default:
                                return initializingHandler ? (initializingHandler.errored = !0, initializingHandler.value = value.reason) : initializingHandler = {
                                    parent: null,
                                    chunk: null,
                                    value: value.reason,
                                    deps: 0,
                                    errored: !0
                                }, null;
                        }
                    }
                    value = value[reference[i]];
                }
                response = map(response, value, parentObject, key);
                id._debugInfo && ("object" !== typeof response || null === response || !isArrayImpl(response) && "function" !== typeof response[ASYNC_ITERATOR] && response.$$typeof !== REACT_ELEMENT_TYPE || response._debugInfo || Object.defineProperty(response, "_debugInfo", {
                    configurable: !1,
                    enumerable: !1,
                    writable: !0,
                    value: id._debugInfo
                }));
                return response;
            case "pending":
            case "blocked":
                return waitForReference(id, parentObject, key, response, map, reference);
            case "halted":
                return initializingHandler ? (response = initializingHandler, response.deps++) : initializingHandler = {
                    parent: null,
                    chunk: null,
                    value: null,
                    deps: 1,
                    errored: !1
                }, null;
            default:
                return initializingHandler ? (initializingHandler.errored = !0, initializingHandler.value = id.reason) : initializingHandler = {
                    parent: null,
                    chunk: null,
                    value: id.reason,
                    deps: 0,
                    errored: !0
                }, null;
        }
    }
    function createMap(response, model) {
        return new Map(model);
    }
    function createSet(response, model) {
        return new Set(model);
    }
    function createBlob(response, model) {
        return new Blob(model.slice(1), {
            type: model[0]
        });
    }
    function createFormData(response, model) {
        response = new FormData();
        for(var i = 0; i < model.length; i++)response.append(model[i][0], model[i][1]);
        return response;
    }
    function applyConstructor(response, model, parentObject) {
        Object.setPrototypeOf(parentObject, model.prototype);
    }
    function defineLazyGetter(response, chunk, parentObject, key) {
        Object.defineProperty(parentObject, key, {
            get: function() {
                "resolved_model" === chunk.status && initializeModelChunk(chunk);
                switch(chunk.status){
                    case "fulfilled":
                        return chunk.value;
                    case "rejected":
                        throw chunk.reason;
                }
                return "This object has been omitted by React in the console log to avoid sending too much data from the server. Try logging smaller or more specific objects.";
            },
            enumerable: !0,
            configurable: !1
        });
        return null;
    }
    function extractIterator(response, model) {
        return model[Symbol.iterator]();
    }
    function createModel(response, model) {
        return model;
    }
    function parseModelString(response, parentObject, key, value) {
        if ("$" === value[0]) {
            if ("$" === value) return null !== initializingHandler && "0" === key && (initializingHandler = {
                parent: initializingHandler,
                chunk: null,
                value: null,
                deps: 0,
                errored: !1
            }), REACT_ELEMENT_TYPE;
            switch(value[1]){
                case "$":
                    return value.slice(1);
                case "L":
                    return parentObject = parseInt(value.slice(2), 16), response = getChunk(response, parentObject), createLazyChunkWrapper(response);
                case "@":
                    return parentObject = parseInt(value.slice(2), 16), getChunk(response, parentObject);
                case "S":
                    return Symbol.for(value.slice(2));
                case "F":
                    var ref = value.slice(2);
                    return getOutlinedModel(response, ref, parentObject, key, loadServerReference);
                case "T":
                    parentObject = "$" + value.slice(2);
                    response = response._tempRefs;
                    if (null == response) throw Error("Missing a temporary reference set but the RSC response returned a temporary reference. Pass a temporaryReference option with the set that was used with the reply.");
                    return response.get(parentObject);
                case "Q":
                    return ref = value.slice(2), getOutlinedModel(response, ref, parentObject, key, createMap);
                case "W":
                    return ref = value.slice(2), getOutlinedModel(response, ref, parentObject, key, createSet);
                case "B":
                    return ref = value.slice(2), getOutlinedModel(response, ref, parentObject, key, createBlob);
                case "K":
                    return ref = value.slice(2), getOutlinedModel(response, ref, parentObject, key, createFormData);
                case "Z":
                    return ref = value.slice(2), getOutlinedModel(response, ref, parentObject, key, resolveErrorDev);
                case "i":
                    return ref = value.slice(2), getOutlinedModel(response, ref, parentObject, key, extractIterator);
                case "I":
                    return Infinity;
                case "-":
                    return "$-0" === value ? -0 : -Infinity;
                case "N":
                    return NaN;
                case "u":
                    return;
                case "D":
                    return new Date(Date.parse(value.slice(2)));
                case "n":
                    return BigInt(value.slice(2));
                case "P":
                    return ref = value.slice(2), getOutlinedModel(response, ref, parentObject, key, applyConstructor);
                case "E":
                    response = value.slice(2);
                    try {
                        return (0, eval)(response);
                    } catch (x) {
                        if (response.startsWith("(async function")) {
                            if (parentObject = response.indexOf("(", 15), -1 !== parentObject) return response = response.slice(15, parentObject).trim(), (0, eval)("({" + JSON.stringify(response) + ":async function(){}})")[response];
                        } else if (response.startsWith("(function")) {
                            if (parentObject = response.indexOf("(", 9), -1 !== parentObject) return response = response.slice(9, parentObject).trim(), (0, eval)("({" + JSON.stringify(response) + ":function(){}})")[response];
                        } else if (response.startsWith("(class") && (parentObject = response.indexOf("{", 6), -1 !== parentObject)) return response = response.slice(6, parentObject).trim(), (0, eval)("({" + JSON.stringify(response) + ":class{}})")[response];
                        return function() {};
                    }
                case "Y":
                    if (2 < value.length && (ref = response._debugChannel)) {
                        if ("@" === value[2]) return parentObject = value.slice(3), key = parseInt(parentObject, 16), response._chunks.has(key) || ref("P:" + parentObject), getChunk(response, key);
                        value = value.slice(2);
                        var _id2 = parseInt(value, 16);
                        response._chunks.has(_id2) || ref("Q:" + value);
                        ref = getChunk(response, _id2);
                        return "fulfilled" === ref.status ? ref.value : defineLazyGetter(response, ref, parentObject, key);
                    }
                    Object.defineProperty(parentObject, key, {
                        get: function() {
                            return "This object has been omitted by React in the console log to avoid sending too much data from the server. Try logging smaller or more specific objects.";
                        },
                        enumerable: !0,
                        configurable: !1
                    });
                    return null;
                default:
                    return ref = value.slice(1), getOutlinedModel(response, ref, parentObject, key, createModel);
            }
        }
        return value;
    }
    function missingCall() {
        throw Error('Trying to call a function from "use server" but the callServer option was not implemented in your router runtime.');
    }
    function ResponseInstance(bundlerConfig, serverReferenceConfig, moduleLoading, callServer, encodeFormAction, nonce, temporaryReferences, findSourceMapURL, replayConsole, environmentName, debugChannel) {
        var chunks = new Map();
        this._bundlerConfig = bundlerConfig;
        this._serverReferenceConfig = serverReferenceConfig;
        this._moduleLoading = moduleLoading;
        this._callServer = void 0 !== callServer ? callServer : missingCall;
        this._encodeFormAction = encodeFormAction;
        this._nonce = nonce;
        this._chunks = chunks;
        this._stringDecoder = new util.TextDecoder();
        this._fromJSON = null;
        this._closed = !1;
        this._closedReason = null;
        this._tempRefs = temporaryReferences;
        this._pendingChunks = 0;
        this._weakResponse = {
            weak: new WeakRef(this),
            response: this
        };
        this._debugRootOwner = bundlerConfig = void 0 === ReactSharedInteralsServer || null === ReactSharedInteralsServer.A ? null : ReactSharedInteralsServer.A.getOwner();
        this._debugRootStack = null !== bundlerConfig ? Error("react-stack-top-frame") : null;
        environmentName = void 0 === environmentName ? "Server" : environmentName;
        supportsCreateTask && (this._debugRootTask = console.createTask('"use ' + environmentName.toLowerCase() + '"'));
        this._debugFindSourceMapURL = findSourceMapURL;
        this._debugChannel = debugChannel;
        this._replayConsole = replayConsole;
        this._rootEnvironmentName = environmentName;
        debugChannel && (null === debugChannelRegistry ? (debugChannel(""), this._debugChannel = void 0) : debugChannelRegistry.register(this, debugChannel));
        this._fromJSON = createFromJSONCallback(this);
    }
    function createStreamState() {
        return {
            _rowState: 0,
            _rowID: 0,
            _rowTag: 0,
            _rowLength: 0,
            _buffer: []
        };
    }
    function resolveDebugHalt(response, id) {
        var chunks = response._chunks, chunk = chunks.get(id);
        chunk || chunks.set(id, chunk = createPendingChunk(response));
        if ("pending" === chunk.status || "blocked" === chunk.status) releasePendingChunk(response, chunk), response = chunk, response.status = "halted", response.value = null, response.reason = null;
    }
    function resolveModel(response, id, model) {
        var chunks = response._chunks, chunk = chunks.get(id);
        chunk ? resolveModelChunk(response, chunk, model) : chunks.set(id, new ReactPromise("resolved_model", model, response));
    }
    function resolveText(response, id, text) {
        var chunks = response._chunks, chunk = chunks.get(id);
        chunk && "pending" !== chunk.status ? chunk.reason.enqueueValue(text) : (chunk && releasePendingChunk(response, chunk), chunks.set(id, new ReactPromise("fulfilled", text, null)));
    }
    function resolveBuffer(response, id, buffer) {
        var chunks = response._chunks, chunk = chunks.get(id);
        chunk && "pending" !== chunk.status ? chunk.reason.enqueueValue(buffer) : (chunk && releasePendingChunk(response, chunk), chunks.set(id, new ReactPromise("fulfilled", buffer, null)));
    }
    function resolveModule(response, id, model) {
        var chunks = response._chunks, chunk = chunks.get(id);
        model = JSON.parse(model, response._fromJSON);
        var clientReference = resolveClientReference(response._bundlerConfig, model);
        prepareDestinationWithChunks(response._moduleLoading, model[1], response._nonce);
        if (model = preloadModule(clientReference)) {
            if (chunk) {
                releasePendingChunk(response, chunk);
                var blockedChunk = chunk;
                blockedChunk.status = "blocked";
            } else blockedChunk = new ReactPromise("blocked", null, null), chunks.set(id, blockedChunk);
            model.then(function() {
                return resolveModuleChunk(response, blockedChunk, clientReference);
            }, function(error) {
                return triggerErrorOnChunk(response, blockedChunk, error);
            });
        } else chunk ? resolveModuleChunk(response, chunk, clientReference) : chunks.set(id, new ReactPromise("resolved_module", clientReference, null));
    }
    function resolveStream(response, id, stream, controller) {
        var chunks = response._chunks, chunk = chunks.get(id);
        chunk ? "pending" === chunk.status && (releasePendingChunk(response, chunk), response = chunk.value, chunk.status = "fulfilled", chunk.value = stream, chunk.reason = controller, null !== response && wakeChunk(response, chunk.value)) : chunks.set(id, new ReactPromise("fulfilled", stream, controller));
    }
    function startReadableStream(response, id, type) {
        var controller = null;
        type = new ReadableStream({
            type: type,
            start: function(c) {
                controller = c;
            }
        });
        var previousBlockedChunk = null;
        resolveStream(response, id, type, {
            enqueueValue: function(value) {
                null === previousBlockedChunk ? controller.enqueue(value) : previousBlockedChunk.then(function() {
                    controller.enqueue(value);
                });
            },
            enqueueModel: function(json) {
                if (null === previousBlockedChunk) {
                    var chunk = new ReactPromise("resolved_model", json, response);
                    initializeModelChunk(chunk);
                    "fulfilled" === chunk.status ? controller.enqueue(chunk.value) : (chunk.then(function(v) {
                        return controller.enqueue(v);
                    }, function(e) {
                        return controller.error(e);
                    }), previousBlockedChunk = chunk);
                } else {
                    chunk = previousBlockedChunk;
                    var _chunk3 = createPendingChunk(response);
                    _chunk3.then(function(v) {
                        return controller.enqueue(v);
                    }, function(e) {
                        return controller.error(e);
                    });
                    previousBlockedChunk = _chunk3;
                    chunk.then(function() {
                        previousBlockedChunk === _chunk3 && (previousBlockedChunk = null);
                        resolveModelChunk(response, _chunk3, json);
                    });
                }
            },
            close: function() {
                if (null === previousBlockedChunk) controller.close();
                else {
                    var blockedChunk = previousBlockedChunk;
                    previousBlockedChunk = null;
                    blockedChunk.then(function() {
                        return controller.close();
                    });
                }
            },
            error: function(error) {
                if (null === previousBlockedChunk) controller.error(error);
                else {
                    var blockedChunk = previousBlockedChunk;
                    previousBlockedChunk = null;
                    blockedChunk.then(function() {
                        return controller.error(error);
                    });
                }
            }
        });
    }
    function asyncIterator() {
        return this;
    }
    function createIterator(next) {
        next = {
            next: next
        };
        next[ASYNC_ITERATOR] = asyncIterator;
        return next;
    }
    function startAsyncIterable(response, id, iterator) {
        var buffer = [], closed = !1, nextWriteIndex = 0, iterable = {};
        iterable[ASYNC_ITERATOR] = function() {
            var nextReadIndex = 0;
            return createIterator(function(arg) {
                if (void 0 !== arg) throw Error("Values cannot be passed to next() of AsyncIterables passed to Client Components.");
                if (nextReadIndex === buffer.length) {
                    if (closed) return new ReactPromise("fulfilled", {
                        done: !0,
                        value: void 0
                    }, null);
                    buffer[nextReadIndex] = createPendingChunk(response);
                }
                return buffer[nextReadIndex++];
            });
        };
        resolveStream(response, id, iterator ? iterable[ASYNC_ITERATOR]() : iterable, {
            enqueueValue: function(value) {
                if (nextWriteIndex === buffer.length) buffer[nextWriteIndex] = new ReactPromise("fulfilled", {
                    done: !1,
                    value: value
                }, null);
                else {
                    var chunk = buffer[nextWriteIndex], resolveListeners = chunk.value, rejectListeners = chunk.reason;
                    chunk.status = "fulfilled";
                    chunk.value = {
                        done: !1,
                        value: value
                    };
                    null !== resolveListeners && wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners);
                }
                nextWriteIndex++;
            },
            enqueueModel: function(value) {
                nextWriteIndex === buffer.length ? buffer[nextWriteIndex] = createResolvedIteratorResultChunk(response, value, !1) : resolveIteratorResultChunk(response, buffer[nextWriteIndex], value, !1);
                nextWriteIndex++;
            },
            close: function(value) {
                closed = !0;
                nextWriteIndex === buffer.length ? buffer[nextWriteIndex] = createResolvedIteratorResultChunk(response, value, !0) : resolveIteratorResultChunk(response, buffer[nextWriteIndex], value, !0);
                for(nextWriteIndex++; nextWriteIndex < buffer.length;)resolveIteratorResultChunk(response, buffer[nextWriteIndex++], '"$undefined"', !0);
            },
            error: function(error) {
                closed = !0;
                for(nextWriteIndex === buffer.length && (buffer[nextWriteIndex] = createPendingChunk(response)); nextWriteIndex < buffer.length;)triggerErrorOnChunk(response, buffer[nextWriteIndex++], error);
            }
        });
    }
    function stopStream(response, id, row) {
        (response = response._chunks.get(id)) && "fulfilled" === response.status && response.reason.close("" === row ? '"$undefined"' : row);
    }
    function resolveErrorDev(response, errorInfo) {
        var name = errorInfo.name, env = errorInfo.env;
        errorInfo = buildFakeCallStack(response, errorInfo.stack, env, !1, Error.bind(null, errorInfo.message || "An error occurred in the Server Components render but no message was provided"));
        response = getRootTask(response, env);
        response = null != response ? response.run(errorInfo) : errorInfo();
        response.name = name;
        response.environmentName = env;
        return response;
    }
    function resolveHint(response, code, model) {
        response = JSON.parse(model, response._fromJSON);
        model = ReactDOMSharedInternals.d;
        switch(code){
            case "D":
                model.D(response);
                break;
            case "C":
                "string" === typeof response ? model.C(response) : model.C(response[0], response[1]);
                break;
            case "L":
                code = response[0];
                var as = response[1];
                3 === response.length ? model.L(code, as, response[2]) : model.L(code, as);
                break;
            case "m":
                "string" === typeof response ? model.m(response) : model.m(response[0], response[1]);
                break;
            case "X":
                "string" === typeof response ? model.X(response) : model.X(response[0], response[1]);
                break;
            case "S":
                "string" === typeof response ? model.S(response) : model.S(response[0], 0 === response[1] ? void 0 : response[1], 3 === response.length ? response[2] : void 0);
                break;
            case "M":
                "string" === typeof response ? model.M(response) : model.M(response[0], response[1]);
        }
    }
    function createFakeFunction(name, filename, sourceMap, line, col, enclosingLine, enclosingCol, environmentName) {
        name || (name = "<anonymous>");
        var encodedName = JSON.stringify(name);
        1 > enclosingLine ? enclosingLine = 0 : enclosingLine--;
        1 > enclosingCol ? enclosingCol = 0 : enclosingCol--;
        1 > line ? line = 0 : line--;
        1 > col ? col = 0 : col--;
        if (line < enclosingLine || line === enclosingLine && col < enclosingCol) enclosingCol = enclosingLine = 0;
        1 > line ? (line = encodedName.length + 3, enclosingCol -= line, 0 > enclosingCol && (enclosingCol = 0), col = col - enclosingCol - line - 3, 0 > col && (col = 0), encodedName = "({" + encodedName + ":" + " ".repeat(enclosingCol) + "_=>" + " ".repeat(col) + "_()})") : 1 > enclosingLine ? (enclosingCol -= encodedName.length + 3, 0 > enclosingCol && (enclosingCol = 0), encodedName = "({" + encodedName + ":" + " ".repeat(enclosingCol) + "_=>" + "\n".repeat(line - enclosingLine) + " ".repeat(col) + "_()})") : enclosingLine === line ? (col = col - enclosingCol - 3, 0 > col && (col = 0), encodedName = "\n".repeat(enclosingLine - 1) + "({" + encodedName + ":\n" + " ".repeat(enclosingCol) + "_=>" + " ".repeat(col) + "_()})") : encodedName = "\n".repeat(enclosingLine - 1) + "({" + encodedName + ":\n" + " ".repeat(enclosingCol) + "_=>" + "\n".repeat(line - enclosingLine) + " ".repeat(col) + "_()})";
        encodedName = 1 > enclosingLine ? encodedName + "\n/* This module was rendered by a Server Component. Turn on Source Maps to see the server source. */" : "/* This module was rendered by a Server Component. Turn on Source Maps to see the server source. */" + encodedName;
        filename.startsWith("/") && (filename = "file://" + filename);
        sourceMap ? (encodedName += "\n//# sourceURL=rsc://React/" + encodeURIComponent(environmentName) + "/" + encodeURI(filename) + "?" + fakeFunctionIdx++, encodedName += "\n//# sourceMappingURL=" + sourceMap) : encodedName = filename ? encodedName + ("\n//# sourceURL=" + encodeURI(filename)) : encodedName + "\n//# sourceURL=<anonymous>";
        try {
            var fn = (0, eval)(encodedName)[name];
        } catch (x) {
            fn = function(_) {
                return _();
            };
        }
        return fn;
    }
    function buildFakeCallStack(response, stack, environmentName, useEnclosingLine, innerCall) {
        for(var i = 0; i < stack.length; i++){
            var frame = stack[i], frameKey = frame.join("-") + "-" + environmentName + (useEnclosingLine ? "-e" : "-n"), fn = fakeFunctionCache.get(frameKey);
            if (void 0 === fn) {
                fn = frame[0];
                var filename = frame[1], line = frame[2], col = frame[3], enclosingLine = frame[4];
                frame = frame[5];
                var findSourceMapURL = response._debugFindSourceMapURL;
                findSourceMapURL = findSourceMapURL ? findSourceMapURL(filename, environmentName) : null;
                fn = createFakeFunction(fn, filename, findSourceMapURL, line, col, useEnclosingLine ? line : enclosingLine, useEnclosingLine ? col : frame, environmentName);
                fakeFunctionCache.set(frameKey, fn);
            }
            innerCall = fn.bind(null, innerCall);
        }
        return innerCall;
    }
    function getRootTask(response, childEnvironmentName) {
        var rootTask = response._debugRootTask;
        return rootTask ? response._rootEnvironmentName !== childEnvironmentName ? (response = console.createTask.bind(console, '"use ' + childEnvironmentName.toLowerCase() + '"'), rootTask.run(response)) : rootTask : null;
    }
    function initializeFakeTask(response, debugInfo) {
        if (!supportsCreateTask || null == debugInfo.stack) return null;
        var cachedEntry = debugInfo.debugTask;
        if (void 0 !== cachedEntry) return cachedEntry;
        var useEnclosingLine = void 0 === debugInfo.key, stack = debugInfo.stack, env = null == debugInfo.env ? response._rootEnvironmentName : debugInfo.env;
        cachedEntry = null == debugInfo.owner || null == debugInfo.owner.env ? response._rootEnvironmentName : debugInfo.owner.env;
        var ownerTask = null == debugInfo.owner ? null : initializeFakeTask(response, debugInfo.owner);
        env = env !== cachedEntry ? '"use ' + env.toLowerCase() + '"' : void 0 !== debugInfo.key ? "<" + (debugInfo.name || "...") + ">" : void 0 !== debugInfo.name ? debugInfo.name || "unknown" : "await " + (debugInfo.awaited.name || "unknown");
        env = console.createTask.bind(console, env);
        useEnclosingLine = buildFakeCallStack(response, stack, cachedEntry, useEnclosingLine, env);
        null === ownerTask ? (response = getRootTask(response, cachedEntry), response = null != response ? response.run(useEnclosingLine) : useEnclosingLine()) : response = ownerTask.run(useEnclosingLine);
        return debugInfo.debugTask = response;
    }
    function fakeJSXCallSite() {
        return Error("react-stack-top-frame");
    }
    function initializeFakeStack(response, debugInfo) {
        if (void 0 === debugInfo.debugStack) {
            null != debugInfo.stack && (debugInfo.debugStack = createFakeJSXCallStackInDEV(response, debugInfo.stack, null == debugInfo.env ? "" : debugInfo.env));
            var owner = debugInfo.owner;
            null != owner && (initializeFakeStack(response, owner), void 0 === owner.debugLocation && null != debugInfo.debugStack && (owner.debugLocation = debugInfo.debugStack));
        }
    }
    function resolveDebugInfo(response, id, debugInfo) {
        void 0 !== debugInfo.stack && initializeFakeTask(response, debugInfo);
        null == debugInfo.owner && null != response._debugRootOwner ? (debugInfo.owner = response._debugRootOwner, debugInfo.stack = null, debugInfo.debugStack = response._debugRootStack, debugInfo.debugTask = response._debugRootTask) : void 0 !== debugInfo.stack && initializeFakeStack(response, debugInfo);
        response = getChunk(response, id);
        (response._debugInfo || (response._debugInfo = [])).push(debugInfo);
    }
    function getCurrentStackInDEV() {
        var owner = currentOwnerInDEV;
        if (null === owner) return "";
        try {
            var info = "";
            if (owner.owner || "string" !== typeof owner.name) {
                for(; owner;){
                    var ownerStack = owner.debugStack;
                    if (null != ownerStack) {
                        if (owner = owner.owner) {
                            var JSCompiler_temp_const = info;
                            var error = ownerStack, prevPrepareStackTrace = Error.prepareStackTrace;
                            Error.prepareStackTrace = prepareStackTrace;
                            var stack = error.stack;
                            Error.prepareStackTrace = prevPrepareStackTrace;
                            stack.startsWith("Error: react-stack-top-frame\n") && (stack = stack.slice(29));
                            var idx = stack.indexOf("\n");
                            -1 !== idx && (stack = stack.slice(idx + 1));
                            idx = stack.indexOf("react_stack_bottom_frame");
                            -1 !== idx && (idx = stack.lastIndexOf("\n", idx));
                            var JSCompiler_inline_result = -1 !== idx ? stack = stack.slice(0, idx) : "";
                            info = JSCompiler_temp_const + ("\n" + JSCompiler_inline_result);
                        }
                    } else break;
                }
                var JSCompiler_inline_result$jscomp$0 = info;
            } else {
                JSCompiler_temp_const = owner.name;
                if (void 0 === prefix) try {
                    throw Error();
                } catch (x) {
                    prefix = (error = x.stack.trim().match(/\n( *(at )?)/)) && error[1] || "", suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
                }
                JSCompiler_inline_result$jscomp$0 = "\n" + prefix + JSCompiler_temp_const + suffix;
            }
        } catch (x) {
            JSCompiler_inline_result$jscomp$0 = "\nError generating stack: " + x.message + "\n" + x.stack;
        }
        return JSCompiler_inline_result$jscomp$0;
    }
    function resolveConsoleEntry(response, value) {
        if (response._replayConsole) {
            var payload = JSON.parse(value, response._fromJSON);
            value = payload[0];
            var stackTrace = payload[1], owner = payload[2], env = payload[3];
            payload = payload.slice(4);
            replayConsoleWithCallStackInDEV(response, value, stackTrace, owner, env, payload);
        }
    }
    function mergeBuffer(buffer, lastChunk) {
        for(var l = buffer.length, byteLength = lastChunk.length, i = 0; i < l; i++)byteLength += buffer[i].byteLength;
        byteLength = new Uint8Array(byteLength);
        for(var _i3 = i = 0; _i3 < l; _i3++){
            var chunk = buffer[_i3];
            byteLength.set(chunk, i);
            i += chunk.byteLength;
        }
        byteLength.set(lastChunk, i);
        return byteLength;
    }
    function resolveTypedArray(response, id, buffer, lastChunk, constructor, bytesPerElement) {
        buffer = 0 === buffer.length && 0 === lastChunk.byteOffset % bytesPerElement ? lastChunk : mergeBuffer(buffer, lastChunk);
        constructor = new constructor(buffer.buffer, buffer.byteOffset, buffer.byteLength / bytesPerElement);
        resolveBuffer(response, id, constructor);
    }
    function flushInitialRenderPerformance() {}
    function processFullBinaryRow(response, id, tag, buffer, chunk) {
        switch(tag){
            case 65:
                resolveBuffer(response, id, mergeBuffer(buffer, chunk).buffer);
                return;
            case 79:
                resolveTypedArray(response, id, buffer, chunk, Int8Array, 1);
                return;
            case 111:
                resolveBuffer(response, id, 0 === buffer.length ? chunk : mergeBuffer(buffer, chunk));
                return;
            case 85:
                resolveTypedArray(response, id, buffer, chunk, Uint8ClampedArray, 1);
                return;
            case 83:
                resolveTypedArray(response, id, buffer, chunk, Int16Array, 2);
                return;
            case 115:
                resolveTypedArray(response, id, buffer, chunk, Uint16Array, 2);
                return;
            case 76:
                resolveTypedArray(response, id, buffer, chunk, Int32Array, 4);
                return;
            case 108:
                resolveTypedArray(response, id, buffer, chunk, Uint32Array, 4);
                return;
            case 71:
                resolveTypedArray(response, id, buffer, chunk, Float32Array, 4);
                return;
            case 103:
                resolveTypedArray(response, id, buffer, chunk, Float64Array, 8);
                return;
            case 77:
                resolveTypedArray(response, id, buffer, chunk, BigInt64Array, 8);
                return;
            case 109:
                resolveTypedArray(response, id, buffer, chunk, BigUint64Array, 8);
                return;
            case 86:
                resolveTypedArray(response, id, buffer, chunk, DataView, 1);
                return;
        }
        for(var stringDecoder = response._stringDecoder, row = "", i = 0; i < buffer.length; i++)row += stringDecoder.decode(buffer[i], decoderOptions);
        row += stringDecoder.decode(chunk);
        processFullStringRow(response, id, tag, row);
    }
    function processFullStringRow(response, id, tag, row) {
        switch(tag){
            case 73:
                resolveModule(response, id, row);
                break;
            case 72:
                resolveHint(response, row[0], row.slice(1));
                break;
            case 69:
                row = JSON.parse(row);
                tag = resolveErrorDev(response, row);
                tag.digest = row.digest;
                row = response._chunks;
                var chunk = row.get(id);
                chunk ? triggerErrorOnChunk(response, chunk, tag) : row.set(id, new ReactPromise("rejected", null, tag));
                break;
            case 84:
                resolveText(response, id, row);
                break;
            case 78:
            case 68:
                tag = new ReactPromise("resolved_model", row, response);
                initializeModelChunk(tag);
                "fulfilled" === tag.status ? resolveDebugInfo(response, id, tag.value) : tag.then(function(v) {
                    return resolveDebugInfo(response, id, v);
                }, function() {});
                break;
            case 74:
            case 87:
                resolveConsoleEntry(response, row);
                break;
            case 82:
                startReadableStream(response, id, void 0);
                break;
            case 114:
                startReadableStream(response, id, "bytes");
                break;
            case 88:
                startAsyncIterable(response, id, !1);
                break;
            case 120:
                startAsyncIterable(response, id, !0);
                break;
            case 67:
                stopStream(response, id, row);
                break;
            default:
                "" === row ? resolveDebugHalt(response, id) : resolveModel(response, id, row);
        }
    }
    function processBinaryChunk(weakResponse, streamState, chunk) {
        if (void 0 !== weakResponse.weak.deref()) {
            var response = unwrapWeakResponse(weakResponse), i = 0, rowState = streamState._rowState;
            weakResponse = streamState._rowID;
            for(var rowTag = streamState._rowTag, rowLength = streamState._rowLength, buffer = streamState._buffer, chunkLength = chunk.length; i < chunkLength;){
                var lastIdx = -1;
                switch(rowState){
                    case 0:
                        lastIdx = chunk[i++];
                        58 === lastIdx ? rowState = 1 : weakResponse = weakResponse << 4 | (96 < lastIdx ? lastIdx - 87 : lastIdx - 48);
                        continue;
                    case 1:
                        rowState = chunk[i];
                        84 === rowState || 65 === rowState || 79 === rowState || 111 === rowState || 85 === rowState || 83 === rowState || 115 === rowState || 76 === rowState || 108 === rowState || 71 === rowState || 103 === rowState || 77 === rowState || 109 === rowState || 86 === rowState ? (rowTag = rowState, rowState = 2, i++) : 64 < rowState && 91 > rowState || 35 === rowState || 114 === rowState || 120 === rowState ? (rowTag = rowState, rowState = 3, i++) : (rowTag = 0, rowState = 3);
                        continue;
                    case 2:
                        lastIdx = chunk[i++];
                        44 === lastIdx ? rowState = 4 : rowLength = rowLength << 4 | (96 < lastIdx ? lastIdx - 87 : lastIdx - 48);
                        continue;
                    case 3:
                        lastIdx = chunk.indexOf(10, i);
                        break;
                    case 4:
                        lastIdx = i + rowLength, lastIdx > chunk.length && (lastIdx = -1);
                }
                var offset = chunk.byteOffset + i;
                if (-1 < lastIdx) rowLength = new Uint8Array(chunk.buffer, offset, lastIdx - i), processFullBinaryRow(response, weakResponse, rowTag, buffer, rowLength), i = lastIdx, 3 === rowState && i++, rowLength = weakResponse = rowTag = rowState = 0, buffer.length = 0;
                else {
                    chunk = new Uint8Array(chunk.buffer, offset, chunk.byteLength - i);
                    buffer.push(chunk);
                    rowLength -= chunk.byteLength;
                    break;
                }
            }
            streamState._rowState = rowState;
            streamState._rowID = weakResponse;
            streamState._rowTag = rowTag;
            streamState._rowLength = rowLength;
        }
    }
    function createFromJSONCallback(response) {
        return function(key, value) {
            if ("string" === typeof value) return parseModelString(response, this, key, value);
            if ("object" === typeof value && null !== value) {
                if (value[0] === REACT_ELEMENT_TYPE) b: {
                    var owner = value[4];
                    key = value[5];
                    var validated = value[6];
                    value = {
                        $$typeof: REACT_ELEMENT_TYPE,
                        type: value[1],
                        key: value[2],
                        props: value[3],
                        _owner: void 0 === owner ? null : owner
                    };
                    Object.defineProperty(value, "ref", {
                        enumerable: !1,
                        get: nullRefGetter
                    });
                    value._store = {};
                    Object.defineProperty(value._store, "validated", {
                        configurable: !1,
                        enumerable: !1,
                        writable: !0,
                        value: validated
                    });
                    Object.defineProperty(value, "_debugInfo", {
                        configurable: !1,
                        enumerable: !1,
                        writable: !0,
                        value: null
                    });
                    Object.defineProperty(value, "_debugStack", {
                        configurable: !1,
                        enumerable: !1,
                        writable: !0,
                        value: void 0 === key ? null : key
                    });
                    Object.defineProperty(value, "_debugTask", {
                        configurable: !1,
                        enumerable: !1,
                        writable: !0,
                        value: null
                    });
                    if (null !== initializingHandler) {
                        validated = initializingHandler;
                        initializingHandler = validated.parent;
                        if (validated.errored) {
                            key = new ReactPromise("rejected", null, validated.value);
                            initializeElement(response, value);
                            validated = {
                                name: getComponentNameFromType(value.type) || "",
                                owner: value._owner
                            };
                            validated.debugStack = value._debugStack;
                            supportsCreateTask && (validated.debugTask = value._debugTask);
                            key._debugInfo = [
                                validated
                            ];
                            value = createLazyChunkWrapper(key);
                            break b;
                        }
                        if (0 < validated.deps) {
                            key = new ReactPromise("blocked", null, null);
                            validated.value = value;
                            validated.chunk = key;
                            value = initializeElement.bind(null, response, value);
                            key.then(value, value);
                            value = createLazyChunkWrapper(key);
                            break b;
                        }
                    }
                    initializeElement(response, value);
                }
                return value;
            }
            return value;
        };
    }
    function close(weakResponse) {
        reportGlobalError(weakResponse, Error("Connection closed."));
    }
    function noServerCall$1() {
        throw Error("Server Functions cannot be called during initial render. This would create a fetch waterfall. Try to use a Server Component to pass data to Client Components instead.");
    }
    function createResponseFromOptions(options) {
        return new ResponseInstance(options.serverConsumerManifest.moduleMap, options.serverConsumerManifest.serverModuleMap, options.serverConsumerManifest.moduleLoading, noServerCall$1, options.encodeFormAction, "string" === typeof options.nonce ? options.nonce : void 0, options && options.temporaryReferences ? options.temporaryReferences : void 0, options && options.findSourceMapURL ? options.findSourceMapURL : void 0, options ? !0 === options.replayConsoleLogs : !1, options && options.environmentName ? options.environmentName : void 0, void 0)._weakResponse;
    }
    function startReadingFromStream(response, stream) {
        function progress(_ref) {
            var value = _ref.value;
            if (_ref.done) close(response);
            else return processBinaryChunk(response, streamState, value), reader.read().then(progress).catch(error);
        }
        function error(e) {
            reportGlobalError(response, e);
        }
        var streamState = createStreamState(), reader = stream.getReader();
        reader.read().then(progress).catch(error);
    }
    function noServerCall() {
        throw Error("Server Functions cannot be called during initial render. This would create a fetch waterfall. Try to use a Server Component to pass data to Client Components instead.");
    }
    var util = __turbopack_context__.r("[externals]/util [external] (util, cjs)"), ReactDOM = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-dom.js [app-rsc] (ecmascript)"), React = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-rsc] (ecmascript)"), decoderOptions = {
        stream: !0
    }, bind$1 = Function.prototype.bind, chunkCache = new Map(), ReactDOMSharedInternals = ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, ASYNC_ITERATOR = Symbol.asyncIterator, isArrayImpl = Array.isArray, getPrototypeOf = Object.getPrototypeOf, jsxPropsParents = new WeakMap(), jsxChildrenParents = new WeakMap(), CLIENT_REFERENCE_TAG = Symbol.for("react.client.reference"), ObjectPrototype = Object.prototype, knownServerReferences = new WeakMap(), boundCache = new WeakMap(), fakeServerFunctionIdx = 0, FunctionBind = Function.prototype.bind, ArraySlice = Array.prototype.slice, v8FrameRegExp = /^ {3} at (?:(.+) \((.+):(\d+):(\d+)\)|(?:async )?(.+):(\d+):(\d+))$/, jscSpiderMonkeyFrameRegExp = /(?:(.*)@)?(.*):(\d+):(\d+)/, REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), prefix, suffix;
    new ("function" === typeof WeakMap ? WeakMap : Map)();
    var ReactSharedInteralsServer = React.__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE || ReactSharedInteralsServer;
    ReactPromise.prototype = Object.create(Promise.prototype);
    ReactPromise.prototype.then = function(resolve, reject) {
        switch(this.status){
            case "resolved_model":
                initializeModelChunk(this);
                break;
            case "resolved_module":
                initializeModuleChunk(this);
        }
        switch(this.status){
            case "fulfilled":
                "function" === typeof resolve && resolve(this.value);
                break;
            case "pending":
            case "blocked":
                "function" === typeof resolve && (null === this.value && (this.value = []), this.value.push(resolve));
                "function" === typeof reject && (null === this.reason && (this.reason = []), this.reason.push(reject));
                break;
            case "halted":
                break;
            default:
                "function" === typeof reject && reject(this.reason);
        }
    };
    var debugChannelRegistry = "function" === typeof FinalizationRegistry ? new FinalizationRegistry(cleanupDebugChannel) : null, initializingHandler = null, supportsCreateTask = !!console.createTask, fakeFunctionCache = new Map(), fakeFunctionIdx = 0, createFakeJSXCallStack = {
        react_stack_bottom_frame: function(response, stack, environmentName) {
            return buildFakeCallStack(response, stack, environmentName, !1, fakeJSXCallSite)();
        }
    }, createFakeJSXCallStackInDEV = createFakeJSXCallStack.react_stack_bottom_frame.bind(createFakeJSXCallStack), currentOwnerInDEV = null, replayConsoleWithCallStack = {
        react_stack_bottom_frame: function(response, methodName, stackTrace, owner, env, args) {
            var prevStack = ReactSharedInternals.getCurrentStack;
            ReactSharedInternals.getCurrentStack = getCurrentStackInDEV;
            currentOwnerInDEV = null === owner ? response._debugRootOwner : owner;
            try {
                a: {
                    var offset = 0;
                    switch(methodName){
                        case "dir":
                        case "dirxml":
                        case "groupEnd":
                        case "table":
                            var JSCompiler_inline_result = bind$1.apply(console[methodName], [
                                console
                            ].concat(args));
                            break a;
                        case "assert":
                            offset = 1;
                    }
                    var newArgs = args.slice(0);
                    "string" === typeof newArgs[offset] ? newArgs.splice(offset, 1, "\u001b[0m\u001b[7m%c%s\u001b[0m%c " + newArgs[offset], "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px", " " + env + " ", "") : newArgs.splice(offset, 0, "\u001b[0m\u001b[7m%c%s\u001b[0m%c ", "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px", " " + env + " ", "");
                    newArgs.unshift(console);
                    JSCompiler_inline_result = bind$1.apply(console[methodName], newArgs);
                }
                var callStack = buildFakeCallStack(response, stackTrace, env, !1, JSCompiler_inline_result);
                if (null != owner) {
                    var task = initializeFakeTask(response, owner);
                    initializeFakeStack(response, owner);
                    if (null !== task) {
                        task.run(callStack);
                        return;
                    }
                }
                var rootTask = getRootTask(response, env);
                null != rootTask ? rootTask.run(callStack) : callStack();
            } finally{
                currentOwnerInDEV = null, ReactSharedInternals.getCurrentStack = prevStack;
            }
        }
    }, replayConsoleWithCallStackInDEV = replayConsoleWithCallStack.react_stack_bottom_frame.bind(replayConsoleWithCallStack);
    exports.createFromFetch = function(promiseForResponse, options) {
        var response = createResponseFromOptions(options);
        promiseForResponse.then(function(r) {
            startReadingFromStream(response, r.body);
        }, function(e) {
            reportGlobalError(response, e);
        });
        return getRoot(response);
    };
    exports.createFromNodeStream = function(stream, serverConsumerManifest, options) {
        var response$jscomp$0 = new ResponseInstance(serverConsumerManifest.moduleMap, serverConsumerManifest.serverModuleMap, serverConsumerManifest.moduleLoading, noServerCall, options ? options.encodeFormAction : void 0, options && "string" === typeof options.nonce ? options.nonce : void 0, void 0, options && options.findSourceMapURL ? options.findSourceMapURL : void 0, options ? !0 === options.replayConsoleLogs : !1, options && options.environmentName ? options.environmentName : void 0, void 0)._weakResponse, streamState = createStreamState();
        stream.on("data", function(chunk) {
            if ("string" === typeof chunk) {
                if (void 0 !== response$jscomp$0.weak.deref()) {
                    for(var response = unwrapWeakResponse(response$jscomp$0), i = 0, rowState = streamState._rowState, rowID = streamState._rowID, rowTag = streamState._rowTag, rowLength = streamState._rowLength, buffer = streamState._buffer, chunkLength = chunk.length; i < chunkLength;){
                        var lastIdx = -1;
                        switch(rowState){
                            case 0:
                                lastIdx = chunk.charCodeAt(i++);
                                58 === lastIdx ? rowState = 1 : rowID = rowID << 4 | (96 < lastIdx ? lastIdx - 87 : lastIdx - 48);
                                continue;
                            case 1:
                                rowState = chunk.charCodeAt(i);
                                84 === rowState || 65 === rowState || 79 === rowState || 111 === rowState || 85 === rowState || 83 === rowState || 115 === rowState || 76 === rowState || 108 === rowState || 71 === rowState || 103 === rowState || 77 === rowState || 109 === rowState || 86 === rowState ? (rowTag = rowState, rowState = 2, i++) : 64 < rowState && 91 > rowState || 114 === rowState || 120 === rowState ? (rowTag = rowState, rowState = 3, i++) : (rowTag = 0, rowState = 3);
                                continue;
                            case 2:
                                lastIdx = chunk.charCodeAt(i++);
                                44 === lastIdx ? rowState = 4 : rowLength = rowLength << 4 | (96 < lastIdx ? lastIdx - 87 : lastIdx - 48);
                                continue;
                            case 3:
                                lastIdx = chunk.indexOf("\n", i);
                                break;
                            case 4:
                                if (84 !== rowTag) throw Error("Binary RSC chunks cannot be encoded as strings. This is a bug in the wiring of the React streams.");
                                if (rowLength < chunk.length || chunk.length > 3 * rowLength) throw Error("String chunks need to be passed in their original shape. Not split into smaller string chunks. This is a bug in the wiring of the React streams.");
                                lastIdx = chunk.length;
                        }
                        if (-1 < lastIdx) {
                            if (0 < buffer.length) throw Error("String chunks need to be passed in their original shape. Not split into smaller string chunks. This is a bug in the wiring of the React streams.");
                            i = chunk.slice(i, lastIdx);
                            processFullStringRow(response, rowID, rowTag, i);
                            i = lastIdx;
                            3 === rowState && i++;
                            rowLength = rowID = rowTag = rowState = 0;
                            buffer.length = 0;
                        } else if (chunk.length !== i) throw Error("String chunks need to be passed in their original shape. Not split into smaller string chunks. This is a bug in the wiring of the React streams.");
                    }
                    streamState._rowState = rowState;
                    streamState._rowID = rowID;
                    streamState._rowTag = rowTag;
                    streamState._rowLength = rowLength;
                }
            } else processBinaryChunk(response$jscomp$0, streamState, chunk);
        });
        stream.on("error", function(error) {
            reportGlobalError(response$jscomp$0, error);
        });
        stream.on("end", function() {
            return close(response$jscomp$0);
        });
        return getRoot(response$jscomp$0);
    };
    exports.createFromReadableStream = function(stream, options) {
        options = createResponseFromOptions(options);
        startReadingFromStream(options, stream);
        return getRoot(options);
    };
    exports.createServerReference = function(id) {
        return createServerReference$1(id, noServerCall$1);
    };
    exports.createTemporaryReferenceSet = function() {
        return new Map();
    };
    exports.encodeReply = function(value, options) {
        return new Promise(function(resolve, reject) {
            var abort = processReply(value, "", options && options.temporaryReferences ? options.temporaryReferences : void 0, resolve, reject);
            if (options && options.signal) {
                var signal = options.signal;
                if (signal.aborted) abort(signal.reason);
                else {
                    var listener = function() {
                        abort(signal.reason);
                        signal.removeEventListener("abort", listener);
                    };
                    signal.addEventListener("abort", listener);
                }
            }
        });
    };
    exports.registerServerReference = function(reference, id, encodeFormAction) {
        registerBoundServerReference(reference, id, null, encodeFormAction);
        return reference;
    };
}();
}}),
"[project]/node_modules/next/dist/compiled/react-server-dom-turbopack/client.node.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
else {
    module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react-server-dom-turbopack/cjs/react-server-dom-turbopack-client.node.development.js [app-rsc] (ecmascript)");
}
}}),
"[project]/node_modules/next/dist/esm/lib/detached-promise.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * A `Promise.withResolvers` implementation that exposes the `resolve` and
 * `reject` functions on a `Promise`.
 *
 * @see https://tc39.es/proposal-promise-with-resolvers/
 */ __turbopack_context__.s({
    "DetachedPromise": ()=>DetachedPromise
});
class DetachedPromise {
    constructor(){
        let resolve;
        let reject;
        // Create the promise and assign the resolvers to the object.
        this.promise = new Promise((res, rej)=>{
            resolve = res;
            reject = rej;
        });
        // We know that resolvers is defined because the Promise constructor runs
        // synchronously.
        this.resolve = resolve;
        this.reject = reject;
    }
} //# sourceMappingURL=detached-promise.js.map
}),
"[project]/node_modules/next/dist/esm/server/stream-utils/encoded-tags.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "ENCODED_TAGS": ()=>ENCODED_TAGS
});
const ENCODED_TAGS = {
    // opening tags do not have the closing `>` since they can contain other attributes such as `<body className=''>`
    OPENING: {
        // <html
        HTML: new Uint8Array([
            60,
            104,
            116,
            109,
            108
        ]),
        // <body
        BODY: new Uint8Array([
            60,
            98,
            111,
            100,
            121
        ])
    },
    CLOSED: {
        // </head>
        HEAD: new Uint8Array([
            60,
            47,
            104,
            101,
            97,
            100,
            62
        ]),
        // </body>
        BODY: new Uint8Array([
            60,
            47,
            98,
            111,
            100,
            121,
            62
        ]),
        // </html>
        HTML: new Uint8Array([
            60,
            47,
            104,
            116,
            109,
            108,
            62
        ]),
        // </body></html>
        BODY_AND_HTML: new Uint8Array([
            60,
            47,
            98,
            111,
            100,
            121,
            62,
            60,
            47,
            104,
            116,
            109,
            108,
            62
        ])
    },
    META: {
        // Only the match the prefix cause the suffix can be different wether it's xml compatible or not ">" or "/>"
        // <meta name="nxt-icon"
        // This is a special mark that will be replaced by the icon insertion script tag.
        ICON_MARK: new Uint8Array([
            60,
            109,
            101,
            116,
            97,
            32,
            110,
            97,
            109,
            101,
            61,
            34,
            194,
            171,
            110,
            120,
            116,
            45,
            105,
            99,
            111,
            110,
            194,
            187,
            34
        ])
    }
}; //# sourceMappingURL=encoded-tags.js.map
}),
"[project]/node_modules/next/dist/esm/server/stream-utils/uint8array-helpers.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * Find the starting index of Uint8Array `b` within Uint8Array `a`.
 */ __turbopack_context__.s({
    "indexOfUint8Array": ()=>indexOfUint8Array,
    "isEquivalentUint8Arrays": ()=>isEquivalentUint8Arrays,
    "removeFromUint8Array": ()=>removeFromUint8Array
});
function indexOfUint8Array(a, b) {
    if (b.length === 0) return 0;
    if (a.length === 0 || b.length > a.length) return -1;
    // start iterating through `a`
    for(let i = 0; i <= a.length - b.length; i++){
        let completeMatch = true;
        // from index `i`, iterate through `b` and check for mismatch
        for(let j = 0; j < b.length; j++){
            // if the values do not match, then this isn't a complete match, exit `b` iteration early and iterate to next index of `a`.
            if (a[i + j] !== b[j]) {
                completeMatch = false;
                break;
            }
        }
        if (completeMatch) {
            return i;
        }
    }
    return -1;
}
function isEquivalentUint8Arrays(a, b) {
    if (a.length !== b.length) return false;
    for(let i = 0; i < a.length; i++){
        if (a[i] !== b[i]) return false;
    }
    return true;
}
function removeFromUint8Array(a, b) {
    const tagIndex = indexOfUint8Array(a, b);
    if (tagIndex === 0) return a.subarray(b.length);
    if (tagIndex > -1) {
        const removed = new Uint8Array(a.length - b.length);
        removed.set(a.slice(0, tagIndex));
        removed.set(a.slice(tagIndex + b.length), tagIndex);
        return removed;
    } else {
        return a;
    }
} //# sourceMappingURL=uint8array-helpers.js.map
}),
"[project]/node_modules/next/dist/esm/shared/lib/errors/constants.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "MISSING_ROOT_TAGS_ERROR": ()=>MISSING_ROOT_TAGS_ERROR
});
const MISSING_ROOT_TAGS_ERROR = 'NEXT_MISSING_ROOT_TAGS'; //# sourceMappingURL=constants.js.map
}),
"[project]/node_modules/next/dist/esm/shared/lib/segment-cache/output-export-prefetch-encoding.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// In output: export mode, the build id is added to the start of the HTML
// document, directly after the doctype declaration. During a prefetch, the
// client performs a range request to get the build id, so it can check whether
// the target page belongs to the same build.
//
// The first 64 bytes of the document are requested. The exact number isn't
// too important; it must be larger than the build id + doctype + closing and
// ending comment markers, but it doesn't need to match the end of the
// comment exactly.
//
// Build ids are 21 bytes long in the default implementation, though this
// can be overridden in the Next.js config. For the purposes of this check,
// it's OK to only match the start of the id, so we'll truncate it if exceeds
// a certain length.
__turbopack_context__.s({
    "DOC_PREFETCH_RANGE_HEADER_VALUE": ()=>DOC_PREFETCH_RANGE_HEADER_VALUE,
    "doesExportedHtmlMatchBuildId": ()=>doesExportedHtmlMatchBuildId,
    "insertBuildIdComment": ()=>insertBuildIdComment
});
const DOCTYPE_PREFIX = '<!DOCTYPE html>' // 15 bytes
;
const MAX_BUILD_ID_LENGTH = 24;
const DOC_PREFETCH_RANGE_HEADER_VALUE = 'bytes=0-63';
function escapeBuildId(buildId) {
    // If the build id is longer than the given limit, it's OK for our purposes
    // to only match the beginning.
    const truncated = buildId.slice(0, MAX_BUILD_ID_LENGTH);
    // Replace hyphens with underscores so it doesn't break the HTML comment.
    // (Unlikely, but if this did happen it would break the whole document.)
    return truncated.replace(/-/g, '_');
}
function insertBuildIdComment(originalHtml, buildId) {
    if (buildId.includes('-->') || // React always inserts a doctype at the start of the document. Skip if it
    // isn't present. Shouldn't happen; suggests an issue elsewhere.
    !originalHtml.startsWith(DOCTYPE_PREFIX)) {
        // Return the original HTML unchanged. This means the document will not
        // be prefetched.
        // TODO: The build id comment is currently only used during prefetches, but
        // if we eventually use this mechanism for regular navigations, we may need
        // to error during build if we fail to insert it for some reason.
        return originalHtml;
    }
    // The comment must be inserted after the doctype.
    return originalHtml.replace(DOCTYPE_PREFIX, DOCTYPE_PREFIX + '<!--' + escapeBuildId(buildId) + '-->');
}
function doesExportedHtmlMatchBuildId(partialHtmlDocument, buildId) {
    // Check whether the document starts with the expected buildId.
    return partialHtmlDocument.startsWith(DOCTYPE_PREFIX + '<!--' + escapeBuildId(buildId) + '-->');
} //# sourceMappingURL=output-export-prefetch-encoding.js.map
}),
"[project]/node_modules/next/dist/esm/server/stream-utils/node-web-streams-helper.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "chainStreams": ()=>chainStreams,
    "continueDynamicHTMLResume": ()=>continueDynamicHTMLResume,
    "continueDynamicPrerender": ()=>continueDynamicPrerender,
    "continueFizzStream": ()=>continueFizzStream,
    "continueStaticPrerender": ()=>continueStaticPrerender,
    "createBufferedTransformStream": ()=>createBufferedTransformStream,
    "createDocumentClosingStream": ()=>createDocumentClosingStream,
    "createRootLayoutValidatorStream": ()=>createRootLayoutValidatorStream,
    "renderToInitialFizzStream": ()=>renderToInitialFizzStream,
    "streamFromBuffer": ()=>streamFromBuffer,
    "streamFromString": ()=>streamFromString,
    "streamToBuffer": ()=>streamToBuffer,
    "streamToString": ()=>streamToString
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$tracer$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/lib/trace/tracer.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/lib/trace/constants.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$detached$2d$promise$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/detached-promise.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$scheduler$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/scheduler.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$encoded$2d$tags$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/stream-utils/encoded-tags.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$uint8array$2d$helpers$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/stream-utils/uint8array-helpers.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$errors$2f$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/errors/constants.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$segment$2d$cache$2f$output$2d$export$2d$prefetch$2d$encoding$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/segment-cache/output-export-prefetch-encoding.js [app-rsc] (ecmascript)");
;
;
;
;
;
;
;
;
function voidCatch() {
// this catcher is designed to be used with pipeTo where we expect the underlying
// pipe implementation to forward errors but we don't want the pipeTo promise to reject
// and be unhandled
}
// We can share the same encoder instance everywhere
// Notably we cannot do the same for TextDecoder because it is stateful
// when handling streaming data
const encoder = new TextEncoder();
function chainStreams(...streams) {
    // We could encode this invariant in the arguments but current uses of this function pass
    // use spread so it would be missed by
    if (streams.length === 0) {
        throw Object.defineProperty(new Error('Invariant: chainStreams requires at least one stream'), "__NEXT_ERROR_CODE", {
            value: "E437",
            enumerable: false,
            configurable: true
        });
    }
    // If we only have 1 stream we fast path it by returning just this stream
    if (streams.length === 1) {
        return streams[0];
    }
    const { readable, writable } = new TransformStream();
    // We always initiate pipeTo immediately. We know we have at least 2 streams
    // so we need to avoid closing the writable when this one finishes.
    let promise = streams[0].pipeTo(writable, {
        preventClose: true
    });
    let i = 1;
    for(; i < streams.length - 1; i++){
        const nextStream = streams[i];
        promise = promise.then(()=>nextStream.pipeTo(writable, {
                preventClose: true
            }));
    }
    // We can omit the length check because we halted before the last stream and there
    // is at least two streams so the lastStream here will always be defined
    const lastStream = streams[i];
    promise = promise.then(()=>lastStream.pipeTo(writable));
    // Catch any errors from the streams and ignore them, they will be handled
    // by whatever is consuming the readable stream.
    promise.catch(voidCatch);
    return readable;
}
function streamFromString(str) {
    return new ReadableStream({
        start (controller) {
            controller.enqueue(encoder.encode(str));
            controller.close();
        }
    });
}
function streamFromBuffer(chunk) {
    return new ReadableStream({
        start (controller) {
            controller.enqueue(chunk);
            controller.close();
        }
    });
}
async function streamToBuffer(stream) {
    const reader = stream.getReader();
    const chunks = [];
    while(true){
        const { done, value } = await reader.read();
        if (done) {
            break;
        }
        chunks.push(value);
    }
    return Buffer.concat(chunks);
}
async function streamToString(stream, signal) {
    const decoder = new TextDecoder('utf-8', {
        fatal: true
    });
    let string = '';
    for await (const chunk of stream){
        if (signal == null ? void 0 : signal.aborted) {
            return string;
        }
        string += decoder.decode(chunk, {
            stream: true
        });
    }
    string += decoder.decode();
    return string;
}
function createBufferedTransformStream() {
    let bufferedChunks = [];
    let bufferByteLength = 0;
    let pending;
    const flush = (controller)=>{
        // If we already have a pending flush, then return early.
        if (pending) return;
        const detached = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$detached$2d$promise$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["DetachedPromise"]();
        pending = detached;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$scheduler$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["scheduleImmediate"])(()=>{
            try {
                const chunk = new Uint8Array(bufferByteLength);
                let copiedBytes = 0;
                for(let i = 0; i < bufferedChunks.length; i++){
                    const bufferedChunk = bufferedChunks[i];
                    chunk.set(bufferedChunk, copiedBytes);
                    copiedBytes += bufferedChunk.byteLength;
                }
                // We just wrote all the buffered chunks so we need to reset the bufferedChunks array
                // and our bufferByteLength to prepare for the next round of buffered chunks
                bufferedChunks.length = 0;
                bufferByteLength = 0;
                controller.enqueue(chunk);
            } catch  {
            // If an error occurs while enqueuing it can't be due to this
            // transformers fault. It's likely due to the controller being
            // errored due to the stream being cancelled.
            } finally{
                pending = undefined;
                detached.resolve();
            }
        });
    };
    return new TransformStream({
        transform (chunk, controller) {
            // Combine the previous buffer with the new chunk.
            bufferedChunks.push(chunk);
            bufferByteLength += chunk.byteLength;
            // Flush the buffer to the controller.
            flush(controller);
        },
        flush () {
            if (!pending) return;
            return pending.promise;
        }
    });
}
function createPrefetchCommentStream(isBuildTimePrerendering, buildId) {
    // Insert an extra comment at the beginning of the HTML document. This must
    // come after the DOCTYPE, which is inserted by React.
    //
    // The first chunk sent by React will contain the doctype. After that, we can
    // pass through the rest of the chunks as-is.
    let didTransformFirstChunk = false;
    return new TransformStream({
        transform (chunk, controller) {
            if (isBuildTimePrerendering && !didTransformFirstChunk) {
                didTransformFirstChunk = true;
                const decoder = new TextDecoder('utf-8', {
                    fatal: true
                });
                const chunkStr = decoder.decode(chunk, {
                    stream: true
                });
                const updatedChunkStr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$segment$2d$cache$2f$output$2d$export$2d$prefetch$2d$encoding$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["insertBuildIdComment"])(chunkStr, buildId);
                controller.enqueue(encoder.encode(updatedChunkStr));
                return;
            }
            controller.enqueue(chunk);
        }
    });
}
function renderToInitialFizzStream({ ReactDOMServer, element, streamOptions }) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$tracer$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getTracer"])().trace(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["AppRenderSpan"].renderToReadableStream, async ()=>ReactDOMServer.renderToReadableStream(element, streamOptions));
}
function createMetadataTransformStream(insert) {
    let chunkIndex = -1;
    let isMarkRemoved = false;
    return new TransformStream({
        async transform (chunk, controller) {
            let iconMarkIndex = -1;
            let closedHeadIndex = -1;
            chunkIndex++;
            if (isMarkRemoved) {
                controller.enqueue(chunk);
                return;
            }
            let iconMarkLength = 0;
            // Only search for the closed head tag once
            if (iconMarkIndex === -1) {
                iconMarkIndex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$uint8array$2d$helpers$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["indexOfUint8Array"])(chunk, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$encoded$2d$tags$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ENCODED_TAGS"].META.ICON_MARK);
                if (iconMarkIndex === -1) {
                    controller.enqueue(chunk);
                    return;
                } else {
                    // When we found the `<meta name="nxt-icon"` tag prefix, we will remove it from the chunk.
                    // Its close tag could either be `/>` or `>`, checking the next char to ensure we cover both cases.
                    iconMarkLength = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$encoded$2d$tags$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ENCODED_TAGS"].META.ICON_MARK.length;
                    // Check if next char is /, this is for xml mode.
                    if (chunk[iconMarkIndex + iconMarkLength] === 47) {
                        iconMarkLength += 2;
                    } else {
                        // The last char is `>`
                        iconMarkLength++;
                    }
                }
            }
            // Check if icon mark is inside <head> tag in the first chunk.
            if (chunkIndex === 0) {
                closedHeadIndex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$uint8array$2d$helpers$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["indexOfUint8Array"])(chunk, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$encoded$2d$tags$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ENCODED_TAGS"].CLOSED.HEAD);
                if (iconMarkIndex !== -1) {
                    // The mark icon is located in the 1st chunk before the head tag.
                    // We do not need to insert the script tag in this case because it's in the head.
                    // Just remove the icon mark from the chunk.
                    if (iconMarkIndex < closedHeadIndex) {
                        const replaced = new Uint8Array(chunk.length - iconMarkLength);
                        // Remove the icon mark from the chunk.
                        replaced.set(chunk.subarray(0, iconMarkIndex));
                        replaced.set(chunk.subarray(iconMarkIndex + iconMarkLength), iconMarkIndex);
                        chunk = replaced;
                    } else {
                        // The icon mark is after the head tag, replace and insert the script tag at that position.
                        const insertion = await insert();
                        const encodedInsertion = encoder.encode(insertion);
                        const insertionLength = encodedInsertion.length;
                        const replaced = new Uint8Array(chunk.length - iconMarkLength + insertionLength);
                        replaced.set(chunk.subarray(0, iconMarkIndex));
                        replaced.set(encodedInsertion, iconMarkIndex);
                        replaced.set(chunk.subarray(iconMarkIndex + iconMarkLength), iconMarkIndex + insertionLength);
                        chunk = replaced;
                    }
                    isMarkRemoved = true;
                }
            // If there's no icon mark located, it will be handled later when if present in the following chunks.
            } else {
                // When it's appeared in the following chunks, we'll need to
                // remove the mark and then insert the script tag at that position.
                const insertion = await insert();
                const encodedInsertion = encoder.encode(insertion);
                const insertionLength = encodedInsertion.length;
                // Replace the icon mark with the hoist script or empty string.
                const replaced = new Uint8Array(chunk.length - iconMarkLength + insertionLength);
                // Set the first part of the chunk, before the icon mark.
                replaced.set(chunk.subarray(0, iconMarkIndex));
                // Set the insertion after the icon mark.
                replaced.set(encodedInsertion, iconMarkIndex);
                // Set the rest of the chunk after the icon mark.
                replaced.set(chunk.subarray(iconMarkIndex + iconMarkLength), iconMarkIndex + insertionLength);
                chunk = replaced;
                isMarkRemoved = true;
            }
            controller.enqueue(chunk);
        }
    });
}
function createHeadInsertionTransformStream(insert) {
    let inserted = false;
    // We need to track if this transform saw any bytes because if it didn't
    // we won't want to insert any server HTML at all
    let hasBytes = false;
    return new TransformStream({
        async transform (chunk, controller) {
            hasBytes = true;
            const insertion = await insert();
            if (inserted) {
                if (insertion) {
                    const encodedInsertion = encoder.encode(insertion);
                    controller.enqueue(encodedInsertion);
                }
                controller.enqueue(chunk);
            } else {
                // TODO (@Ethan-Arrowood): Replace the generic `indexOfUint8Array` method with something finely tuned for the subset of things actually being checked for.
                const index = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$uint8array$2d$helpers$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["indexOfUint8Array"])(chunk, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$encoded$2d$tags$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ENCODED_TAGS"].CLOSED.HEAD);
                // In fully static rendering or non PPR rendering cases:
                // `/head>` will always be found in the chunk in first chunk rendering.
                if (index !== -1) {
                    if (insertion) {
                        const encodedInsertion = encoder.encode(insertion);
                        // Get the total count of the bytes in the chunk and the insertion
                        // e.g.
                        // chunk = <head><meta charset="utf-8"></head>
                        // insertion = <script>...</script>
                        // output = <head><meta charset="utf-8"> [ <script>...</script> ] </head>
                        const insertedHeadContent = new Uint8Array(chunk.length + encodedInsertion.length);
                        // Append the first part of the chunk, before the head tag
                        insertedHeadContent.set(chunk.slice(0, index));
                        // Append the server inserted content
                        insertedHeadContent.set(encodedInsertion, index);
                        // Append the rest of the chunk
                        insertedHeadContent.set(chunk.slice(index), index + encodedInsertion.length);
                        controller.enqueue(insertedHeadContent);
                    } else {
                        controller.enqueue(chunk);
                    }
                    inserted = true;
                } else {
                    // This will happens in PPR rendering during next start, when the page is partially rendered.
                    // When the page resumes, the head tag will be found in the middle of the chunk.
                    // Where we just need to append the insertion and chunk to the current stream.
                    // e.g.
                    // PPR-static: <head>...</head><body> [ resume content ] </body>
                    // PPR-resume: [ insertion ] [ rest content ]
                    if (insertion) {
                        controller.enqueue(encoder.encode(insertion));
                    }
                    controller.enqueue(chunk);
                    inserted = true;
                }
            }
        },
        async flush (controller) {
            // Check before closing if there's anything remaining to insert.
            if (hasBytes) {
                const insertion = await insert();
                if (insertion) {
                    controller.enqueue(encoder.encode(insertion));
                }
            }
        }
    });
}
// Suffix after main body content - scripts before </body>,
// but wait for the major chunks to be enqueued.
function createDeferredSuffixStream(suffix) {
    let flushed = false;
    let pending;
    const flush = (controller)=>{
        const detached = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$detached$2d$promise$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["DetachedPromise"]();
        pending = detached;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$scheduler$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["scheduleImmediate"])(()=>{
            try {
                controller.enqueue(encoder.encode(suffix));
            } catch  {
            // If an error occurs while enqueuing it can't be due to this
            // transformers fault. It's likely due to the controller being
            // errored due to the stream being cancelled.
            } finally{
                pending = undefined;
                detached.resolve();
            }
        });
    };
    return new TransformStream({
        transform (chunk, controller) {
            controller.enqueue(chunk);
            // If we've already flushed, we're done.
            if (flushed) return;
            // Schedule the flush to happen.
            flushed = true;
            flush(controller);
        },
        flush (controller) {
            if (pending) return pending.promise;
            if (flushed) return;
            // Flush now.
            controller.enqueue(encoder.encode(suffix));
        }
    });
}
// Merge two streams into one. Ensure the final transform stream is closed
// when both are finished.
function createMergedTransformStream(stream) {
    let pull = null;
    let donePulling = false;
    async function startPulling(controller) {
        if (pull) {
            return;
        }
        const reader = stream.getReader();
        // NOTE: streaming flush
        // We are buffering here for the inlined data stream because the
        // "shell" stream might be chunkenized again by the underlying stream
        // implementation, e.g. with a specific high-water mark. To ensure it's
        // the safe timing to pipe the data stream, this extra tick is
        // necessary.
        // We don't start reading until we've left the current Task to ensure
        // that it's inserted after flushing the shell. Note that this implementation
        // might get stale if impl details of Fizz change in the future.
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$scheduler$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["atLeastOneTask"])();
        try {
            while(true){
                const { done, value } = await reader.read();
                if (done) {
                    donePulling = true;
                    return;
                }
                controller.enqueue(value);
            }
        } catch (err) {
            controller.error(err);
        }
    }
    return new TransformStream({
        transform (chunk, controller) {
            controller.enqueue(chunk);
            // Start the streaming if it hasn't already been started yet.
            if (!pull) {
                pull = startPulling(controller);
            }
        },
        flush (controller) {
            if (donePulling) {
                return;
            }
            return pull || startPulling(controller);
        }
    });
}
const CLOSE_TAG = '</body></html>';
/**
 * This transform stream moves the suffix to the end of the stream, so results
 * like `</body></html><script>...</script>` will be transformed to
 * `<script>...</script></body></html>`.
 */ function createMoveSuffixStream() {
    let foundSuffix = false;
    return new TransformStream({
        transform (chunk, controller) {
            if (foundSuffix) {
                return controller.enqueue(chunk);
            }
            const index = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$uint8array$2d$helpers$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["indexOfUint8Array"])(chunk, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$encoded$2d$tags$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ENCODED_TAGS"].CLOSED.BODY_AND_HTML);
            if (index > -1) {
                foundSuffix = true;
                // If the whole chunk is the suffix, then don't write anything, it will
                // be written in the flush.
                if (chunk.length === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$encoded$2d$tags$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ENCODED_TAGS"].CLOSED.BODY_AND_HTML.length) {
                    return;
                }
                // Write out the part before the suffix.
                const before = chunk.slice(0, index);
                controller.enqueue(before);
                // In the case where the suffix is in the middle of the chunk, we need
                // to split the chunk into two parts.
                if (chunk.length > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$encoded$2d$tags$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ENCODED_TAGS"].CLOSED.BODY_AND_HTML.length + index) {
                    // Write out the part after the suffix.
                    const after = chunk.slice(index + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$encoded$2d$tags$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ENCODED_TAGS"].CLOSED.BODY_AND_HTML.length);
                    controller.enqueue(after);
                }
            } else {
                controller.enqueue(chunk);
            }
        },
        flush (controller) {
            // Even if we didn't find the suffix, the HTML is not valid if we don't
            // add it, so insert it at the end.
            controller.enqueue(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$encoded$2d$tags$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ENCODED_TAGS"].CLOSED.BODY_AND_HTML);
        }
    });
}
function createStripDocumentClosingTagsTransform() {
    return new TransformStream({
        transform (chunk, controller) {
            // We rely on the assumption that chunks will never break across a code unit.
            // This is reasonable because we currently concat all of React's output from a single
            // flush into one chunk before streaming it forward which means the chunk will represent
            // a single coherent utf-8 string. This is not safe to use if we change our streaming to no
            // longer do this large buffered chunk
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$uint8array$2d$helpers$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isEquivalentUint8Arrays"])(chunk, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$encoded$2d$tags$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ENCODED_TAGS"].CLOSED.BODY_AND_HTML) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$uint8array$2d$helpers$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isEquivalentUint8Arrays"])(chunk, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$encoded$2d$tags$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ENCODED_TAGS"].CLOSED.BODY) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$uint8array$2d$helpers$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isEquivalentUint8Arrays"])(chunk, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$encoded$2d$tags$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ENCODED_TAGS"].CLOSED.HTML)) {
                // the entire chunk is the closing tags; return without enqueueing anything.
                return;
            }
            // We assume these tags will go at together at the end of the document and that
            // they won't appear anywhere else in the document. This is not really a safe assumption
            // but until we revamp our streaming infra this is a performant way to string the tags
            chunk = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$uint8array$2d$helpers$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["removeFromUint8Array"])(chunk, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$encoded$2d$tags$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ENCODED_TAGS"].CLOSED.BODY);
            chunk = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$uint8array$2d$helpers$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["removeFromUint8Array"])(chunk, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$encoded$2d$tags$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ENCODED_TAGS"].CLOSED.HTML);
            controller.enqueue(chunk);
        }
    });
}
function createRootLayoutValidatorStream() {
    let foundHtml = false;
    let foundBody = false;
    return new TransformStream({
        async transform (chunk, controller) {
            // Peek into the streamed chunk to see if the tags are present.
            if (!foundHtml && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$uint8array$2d$helpers$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["indexOfUint8Array"])(chunk, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$encoded$2d$tags$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ENCODED_TAGS"].OPENING.HTML) > -1) {
                foundHtml = true;
            }
            if (!foundBody && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$uint8array$2d$helpers$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["indexOfUint8Array"])(chunk, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$encoded$2d$tags$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ENCODED_TAGS"].OPENING.BODY) > -1) {
                foundBody = true;
            }
            controller.enqueue(chunk);
        },
        flush (controller) {
            const missingTags = [];
            if (!foundHtml) missingTags.push('html');
            if (!foundBody) missingTags.push('body');
            if (!missingTags.length) return;
            controller.enqueue(encoder.encode(`<html id="__next_error__">
            <template
              data-next-error-message="Missing ${missingTags.map((c)=>`<${c}>`).join(missingTags.length > 1 ? ' and ' : '')} tags in the root layout.\nRead more at https://nextjs.org/docs/messages/missing-root-layout-tags""
              data-next-error-digest="${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$errors$2f$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["MISSING_ROOT_TAGS_ERROR"]}"
              data-next-error-stack=""
            ></template>
          `));
        }
    });
}
function chainTransformers(readable, transformers) {
    let stream = readable;
    for (const transformer of transformers){
        if (!transformer) continue;
        stream = stream.pipeThrough(transformer);
    }
    return stream;
}
async function continueFizzStream(renderStream, { suffix, inlinedDataStream, isStaticGeneration, isBuildTimePrerendering, buildId, getServerInsertedHTML, getServerInsertedMetadata, validateRootLayout }) {
    // Suffix itself might contain close tags at the end, so we need to split it.
    const suffixUnclosed = suffix ? suffix.split(CLOSE_TAG, 1)[0] : null;
    // If we're generating static HTML and there's an `allReady` promise on the
    // stream, we need to wait for it to resolve before continuing.
    if (isStaticGeneration && 'allReady' in renderStream) {
        await renderStream.allReady;
    }
    return chainTransformers(renderStream, [
        // Buffer everything to avoid flushing too frequently
        createBufferedTransformStream(),
        // Add build id comment to start of the HTML document (in export mode)
        createPrefetchCommentStream(isBuildTimePrerendering, buildId),
        // Transform metadata
        createMetadataTransformStream(getServerInsertedMetadata),
        // Insert suffix content
        suffixUnclosed != null && suffixUnclosed.length > 0 ? createDeferredSuffixStream(suffixUnclosed) : null,
        // Insert the inlined data (Flight data, form state, etc.) stream into the HTML
        inlinedDataStream ? createMergedTransformStream(inlinedDataStream) : null,
        // Validate the root layout for missing html or body tags
        validateRootLayout ? createRootLayoutValidatorStream() : null,
        // Close tags should always be deferred to the end
        createMoveSuffixStream(),
        // Special head insertions
        // TODO-APP: Insert server side html to end of head in app layout rendering, to avoid
        // hydration errors. Remove this once it's ready to be handled by react itself.
        createHeadInsertionTransformStream(getServerInsertedHTML)
    ]);
}
async function continueDynamicPrerender(prerenderStream, { getServerInsertedHTML, getServerInsertedMetadata }) {
    return prerenderStream // Buffer everything to avoid flushing too frequently
    .pipeThrough(createBufferedTransformStream()).pipeThrough(createStripDocumentClosingTagsTransform()) // Insert generated tags to head
    .pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML)) // Transform metadata
    .pipeThrough(createMetadataTransformStream(getServerInsertedMetadata));
}
async function continueStaticPrerender(prerenderStream, { inlinedDataStream, getServerInsertedHTML, getServerInsertedMetadata, isBuildTimePrerendering, buildId }) {
    return prerenderStream // Buffer everything to avoid flushing too frequently
    .pipeThrough(createBufferedTransformStream()) // Add build id comment to start of the HTML document (in export mode)
    .pipeThrough(createPrefetchCommentStream(isBuildTimePrerendering, buildId)) // Insert generated tags to head
    .pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML)) // Transform metadata
    .pipeThrough(createMetadataTransformStream(getServerInsertedMetadata)) // Insert the inlined data (Flight data, form state, etc.) stream into the HTML
    .pipeThrough(createMergedTransformStream(inlinedDataStream)) // Close tags should always be deferred to the end
    .pipeThrough(createMoveSuffixStream());
}
async function continueDynamicHTMLResume(renderStream, { inlinedDataStream, getServerInsertedHTML, getServerInsertedMetadata }) {
    return renderStream // Buffer everything to avoid flushing too frequently
    .pipeThrough(createBufferedTransformStream()) // Insert generated tags to head
    .pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML)) // Transform metadata
    .pipeThrough(createMetadataTransformStream(getServerInsertedMetadata)) // Insert the inlined data (Flight data, form state, etc.) stream into the HTML
    .pipeThrough(createMergedTransformStream(inlinedDataStream)) // Close tags should always be deferred to the end
    .pipeThrough(createMoveSuffixStream());
}
function createDocumentClosingStream() {
    return streamFromString(CLOSE_TAG);
} //# sourceMappingURL=node-web-streams-helper.js.map
}),
"[project]/node_modules/next/dist/esm/shared/lib/segment-cache/segment-value-encoding.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "ROOT_SEGMENT_KEY": ()=>ROOT_SEGMENT_KEY,
    "convertSegmentPathToStaticExportFilename": ()=>convertSegmentPathToStaticExportFilename,
    "encodeChildSegmentKey": ()=>encodeChildSegmentKey,
    "encodeSegment": ()=>encodeSegment
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$segment$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/segment.js [app-rsc] (ecmascript)");
;
function encodeSegment(segment) {
    if (typeof segment === 'string') {
        if (segment.startsWith(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$segment$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["PAGE_SEGMENT_KEY"])) {
            // The Flight Router State type sometimes includes the search params in
            // the page segment. However, the Segment Cache tracks this as a separate
            // key. So, we strip the search params here, and then add them back when
            // the cache entry is turned back into a FlightRouterState. This is an
            // unfortunate consequence of the FlightRouteState being used both as a
            // transport type and as a cache key; we'll address this once more of the
            // Segment Cache implementation has settled.
            // TODO: We should hoist the search params out of the FlightRouterState
            // type entirely, This is our plan for dynamic route params, too.
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$segment$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["PAGE_SEGMENT_KEY"];
        }
        const safeName = // But params typically don't include the leading slash. We should use
        // a different encoding to avoid this special case.
        segment === '/_not-found' ? '_not-found' : encodeToFilesystemAndURLSafeString(segment);
        // Since this is not a dynamic segment, it's fully encoded. It does not
        // need to be "hydrated" with a param value.
        return safeName;
    }
    const name = segment[0];
    const paramValue = segment[1];
    const paramType = segment[2];
    const safeName = encodeToFilesystemAndURLSafeString(name);
    const safeValue = encodeToFilesystemAndURLSafeString(paramValue);
    const encodedName = '$' + paramType + '$' + safeName + '$' + safeValue;
    return encodedName;
}
const ROOT_SEGMENT_KEY = '';
function encodeChildSegmentKey(parentSegmentKey, parallelRouteKey, segment) {
    // Aside from being filesystem safe, segment keys are also designed so that
    // each segment and parallel route creates its own subdirectory. Roughly in
    // the same shape as the source app directory. This is mostly just for easier
    // debugging (you can open up the build folder and navigate the output); if
    // we wanted to do we could just use a flat structure.
    // Omit the parallel route key for children, since this is the most
    // common case. Saves some bytes (and it's what the app directory does).
    const slotKey = parallelRouteKey === 'children' ? segment : "@" + encodeToFilesystemAndURLSafeString(parallelRouteKey) + "/" + segment;
    return parentSegmentKey + '/' + slotKey;
}
// Define a regex pattern to match the most common characters found in a route
// param. It excludes anything that might not be cross-platform filesystem
// compatible, like |. It does not need to be precise because the fallback is to
// just base64url-encode the whole parameter, which is fine; we just don't do it
// by default for compactness, and for easier debugging.
const simpleParamValueRegex = /^[a-zA-Z0-9\-_@]+$/;
function encodeToFilesystemAndURLSafeString(value) {
    if (simpleParamValueRegex.test(value)) {
        return value;
    }
    // If there are any unsafe characters, base64url-encode the entire value.
    // We also add a ! prefix so it doesn't collide with the simple case.
    const base64url = btoa(value).replace(/\+/g, '-') // Replace '+' with '-'
    .replace(/\//g, '_') // Replace '/' with '_'
    .replace(/=+$/, '') // Remove trailing '='
    ;
    return '!' + base64url;
}
function convertSegmentPathToStaticExportFilename(segmentPath) {
    return "__next" + segmentPath.replace(/\//g, '.') + ".txt";
} //# sourceMappingURL=segment-value-encoding.js.map
}),
"[project]/node_modules/next/dist/compiled/string-hash/index.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
(()=>{
    "use strict";
    var e = {
        328: (e)=>{
            function hash(e) {
                var r = 5381, _ = e.length;
                while(_){
                    r = r * 33 ^ e.charCodeAt(--_);
                }
                return r >>> 0;
            }
            e.exports = hash;
        }
    };
    var r = {};
    function __nccwpck_require__(_) {
        var a = r[_];
        if (a !== undefined) {
            return a.exports;
        }
        var t = r[_] = {
            exports: {}
        };
        var i = true;
        try {
            e[_](t, t.exports, __nccwpck_require__);
            i = false;
        } finally{
            if (i) delete r[_];
        }
        return t.exports;
    }
    if (typeof __nccwpck_require__ !== "undefined") __nccwpck_require__.ab = ("TURBOPACK compile-time value", "/ROOT/node_modules/next/dist/compiled/string-hash") + "/";
    var _ = __nccwpck_require__(328);
    module.exports = _;
})();
}}),
"[project]/node_modules/next/dist/esm/lib/format-server-error.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "formatServerError": ()=>formatServerError,
    "getStackWithoutErrorMessage": ()=>getStackWithoutErrorMessage
});
const invalidServerComponentReactHooks = [
    'useDeferredValue',
    'useEffect',
    'useImperativeHandle',
    'useInsertionEffect',
    'useLayoutEffect',
    'useReducer',
    'useRef',
    'useState',
    'useSyncExternalStore',
    'useTransition',
    'experimental_useOptimistic',
    'useOptimistic'
];
function setMessage(error, message) {
    error.message = message;
    if (error.stack) {
        const lines = error.stack.split('\n');
        lines[0] = message;
        error.stack = lines.join('\n');
    }
}
function getStackWithoutErrorMessage(error) {
    const stack = error.stack;
    if (!stack) return '';
    return stack.replace(/^[^\n]*\n/, '');
}
function formatServerError(error) {
    if (typeof (error == null ? void 0 : error.message) !== 'string') return;
    if (error.message.includes('Class extends value undefined is not a constructor or null')) {
        const addedMessage = 'This might be caused by a React Class Component being rendered in a Server Component, React Class Components only works in Client Components. Read more: https://nextjs.org/docs/messages/class-component-in-server-component';
        // If this error instance already has the message, don't add it again
        if (error.message.includes(addedMessage)) return;
        setMessage(error, `${error.message}

${addedMessage}`);
        return;
    }
    if (error.message.includes('createContext is not a function')) {
        setMessage(error, 'createContext only works in Client Components. Add the "use client" directive at the top of the file to use it. Read more: https://nextjs.org/docs/messages/context-in-server-component');
        return;
    }
    for (const clientHook of invalidServerComponentReactHooks){
        const regex = new RegExp(`\\b${clientHook}\\b.*is not a function`);
        if (regex.test(error.message)) {
            setMessage(error, `${clientHook} only works in Client Components. Add the "use client" directive at the top of the file to use it. Read more: https://nextjs.org/docs/messages/react-client-hook-in-server-component`);
            return;
        }
    }
} //# sourceMappingURL=format-server-error.js.map
}),
"[project]/node_modules/next/dist/esm/server/request-meta.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/* eslint-disable no-redeclare */ // FIXME: (wyattjoh) this is a temporary solution to allow us to pass data between bundled modules
__turbopack_context__.s({
    "NEXT_REQUEST_META": ()=>NEXT_REQUEST_META,
    "addRequestMeta": ()=>addRequestMeta,
    "getRequestMeta": ()=>getRequestMeta,
    "removeRequestMeta": ()=>removeRequestMeta,
    "setRequestMeta": ()=>setRequestMeta
});
const NEXT_REQUEST_META = Symbol.for('NextInternalRequestMeta');
function getRequestMeta(req, key) {
    const meta = req[NEXT_REQUEST_META] || {};
    return typeof key === 'string' ? meta[key] : meta;
}
function setRequestMeta(req, meta) {
    req[NEXT_REQUEST_META] = meta;
    return meta;
}
function addRequestMeta(request, key, value) {
    const meta = getRequestMeta(request);
    meta[key] = value;
    return setRequestMeta(request, meta);
}
function removeRequestMeta(request, key) {
    const meta = getRequestMeta(request);
    delete meta[key];
    return setRequestMeta(request, meta);
} //# sourceMappingURL=request-meta.js.map
}),
"[project]/node_modules/next/dist/esm/lib/constants.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "ACTION_SUFFIX": ()=>ACTION_SUFFIX,
    "APP_DIR_ALIAS": ()=>APP_DIR_ALIAS,
    "CACHE_ONE_YEAR": ()=>CACHE_ONE_YEAR,
    "DOT_NEXT_ALIAS": ()=>DOT_NEXT_ALIAS,
    "ESLINT_DEFAULT_DIRS": ()=>ESLINT_DEFAULT_DIRS,
    "GSP_NO_RETURNED_VALUE": ()=>GSP_NO_RETURNED_VALUE,
    "GSSP_COMPONENT_MEMBER_ERROR": ()=>GSSP_COMPONENT_MEMBER_ERROR,
    "GSSP_NO_RETURNED_VALUE": ()=>GSSP_NO_RETURNED_VALUE,
    "INFINITE_CACHE": ()=>INFINITE_CACHE,
    "INSTRUMENTATION_HOOK_FILENAME": ()=>INSTRUMENTATION_HOOK_FILENAME,
    "MATCHED_PATH_HEADER": ()=>MATCHED_PATH_HEADER,
    "MIDDLEWARE_FILENAME": ()=>MIDDLEWARE_FILENAME,
    "MIDDLEWARE_LOCATION_REGEXP": ()=>MIDDLEWARE_LOCATION_REGEXP,
    "NEXT_BODY_SUFFIX": ()=>NEXT_BODY_SUFFIX,
    "NEXT_CACHE_IMPLICIT_TAG_ID": ()=>NEXT_CACHE_IMPLICIT_TAG_ID,
    "NEXT_CACHE_REVALIDATED_TAGS_HEADER": ()=>NEXT_CACHE_REVALIDATED_TAGS_HEADER,
    "NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER": ()=>NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER,
    "NEXT_CACHE_SOFT_TAG_MAX_LENGTH": ()=>NEXT_CACHE_SOFT_TAG_MAX_LENGTH,
    "NEXT_CACHE_TAGS_HEADER": ()=>NEXT_CACHE_TAGS_HEADER,
    "NEXT_CACHE_TAG_MAX_ITEMS": ()=>NEXT_CACHE_TAG_MAX_ITEMS,
    "NEXT_CACHE_TAG_MAX_LENGTH": ()=>NEXT_CACHE_TAG_MAX_LENGTH,
    "NEXT_DATA_SUFFIX": ()=>NEXT_DATA_SUFFIX,
    "NEXT_INTERCEPTION_MARKER_PREFIX": ()=>NEXT_INTERCEPTION_MARKER_PREFIX,
    "NEXT_META_SUFFIX": ()=>NEXT_META_SUFFIX,
    "NEXT_QUERY_PARAM_PREFIX": ()=>NEXT_QUERY_PARAM_PREFIX,
    "NEXT_RESUME_HEADER": ()=>NEXT_RESUME_HEADER,
    "NON_STANDARD_NODE_ENV": ()=>NON_STANDARD_NODE_ENV,
    "PAGES_DIR_ALIAS": ()=>PAGES_DIR_ALIAS,
    "PRERENDER_REVALIDATE_HEADER": ()=>PRERENDER_REVALIDATE_HEADER,
    "PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER": ()=>PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER,
    "PUBLIC_DIR_MIDDLEWARE_CONFLICT": ()=>PUBLIC_DIR_MIDDLEWARE_CONFLICT,
    "ROOT_DIR_ALIAS": ()=>ROOT_DIR_ALIAS,
    "RSC_ACTION_CLIENT_WRAPPER_ALIAS": ()=>RSC_ACTION_CLIENT_WRAPPER_ALIAS,
    "RSC_ACTION_ENCRYPTION_ALIAS": ()=>RSC_ACTION_ENCRYPTION_ALIAS,
    "RSC_ACTION_PROXY_ALIAS": ()=>RSC_ACTION_PROXY_ALIAS,
    "RSC_ACTION_VALIDATE_ALIAS": ()=>RSC_ACTION_VALIDATE_ALIAS,
    "RSC_CACHE_WRAPPER_ALIAS": ()=>RSC_CACHE_WRAPPER_ALIAS,
    "RSC_DYNAMIC_IMPORT_WRAPPER_ALIAS": ()=>RSC_DYNAMIC_IMPORT_WRAPPER_ALIAS,
    "RSC_MOD_REF_PROXY_ALIAS": ()=>RSC_MOD_REF_PROXY_ALIAS,
    "RSC_PREFETCH_SUFFIX": ()=>RSC_PREFETCH_SUFFIX,
    "RSC_SEGMENTS_DIR_SUFFIX": ()=>RSC_SEGMENTS_DIR_SUFFIX,
    "RSC_SEGMENT_SUFFIX": ()=>RSC_SEGMENT_SUFFIX,
    "RSC_SUFFIX": ()=>RSC_SUFFIX,
    "SERVER_PROPS_EXPORT_ERROR": ()=>SERVER_PROPS_EXPORT_ERROR,
    "SERVER_PROPS_GET_INIT_PROPS_CONFLICT": ()=>SERVER_PROPS_GET_INIT_PROPS_CONFLICT,
    "SERVER_PROPS_SSG_CONFLICT": ()=>SERVER_PROPS_SSG_CONFLICT,
    "SERVER_RUNTIME": ()=>SERVER_RUNTIME,
    "SSG_FALLBACK_EXPORT_ERROR": ()=>SSG_FALLBACK_EXPORT_ERROR,
    "SSG_GET_INITIAL_PROPS_CONFLICT": ()=>SSG_GET_INITIAL_PROPS_CONFLICT,
    "STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR": ()=>STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR,
    "UNSTABLE_REVALIDATE_RENAME_ERROR": ()=>UNSTABLE_REVALIDATE_RENAME_ERROR,
    "WEBPACK_LAYERS": ()=>WEBPACK_LAYERS,
    "WEBPACK_RESOURCE_QUERIES": ()=>WEBPACK_RESOURCE_QUERIES
});
const NEXT_QUERY_PARAM_PREFIX = 'nxtP';
const NEXT_INTERCEPTION_MARKER_PREFIX = 'nxtI';
const MATCHED_PATH_HEADER = 'x-matched-path';
const PRERENDER_REVALIDATE_HEADER = 'x-prerender-revalidate';
const PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER = 'x-prerender-revalidate-if-generated';
const RSC_PREFETCH_SUFFIX = '.prefetch.rsc';
const RSC_SEGMENTS_DIR_SUFFIX = '.segments';
const RSC_SEGMENT_SUFFIX = '.segment.rsc';
const RSC_SUFFIX = '.rsc';
const ACTION_SUFFIX = '.action';
const NEXT_DATA_SUFFIX = '.json';
const NEXT_META_SUFFIX = '.meta';
const NEXT_BODY_SUFFIX = '.body';
const NEXT_CACHE_TAGS_HEADER = 'x-next-cache-tags';
const NEXT_CACHE_REVALIDATED_TAGS_HEADER = 'x-next-revalidated-tags';
const NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER = 'x-next-revalidate-tag-token';
const NEXT_RESUME_HEADER = 'next-resume';
const NEXT_CACHE_TAG_MAX_ITEMS = 128;
const NEXT_CACHE_TAG_MAX_LENGTH = 256;
const NEXT_CACHE_SOFT_TAG_MAX_LENGTH = 1024;
const NEXT_CACHE_IMPLICIT_TAG_ID = '_N_T_';
const CACHE_ONE_YEAR = 31536000;
const INFINITE_CACHE = 0xfffffffe;
const MIDDLEWARE_FILENAME = 'middleware';
const MIDDLEWARE_LOCATION_REGEXP = `(?:src/)?${MIDDLEWARE_FILENAME}`;
const INSTRUMENTATION_HOOK_FILENAME = 'instrumentation';
const PAGES_DIR_ALIAS = 'private-next-pages';
const DOT_NEXT_ALIAS = 'private-dot-next';
const ROOT_DIR_ALIAS = 'private-next-root-dir';
const APP_DIR_ALIAS = 'private-next-app-dir';
const RSC_MOD_REF_PROXY_ALIAS = 'private-next-rsc-mod-ref-proxy';
const RSC_ACTION_VALIDATE_ALIAS = 'private-next-rsc-action-validate';
const RSC_ACTION_PROXY_ALIAS = 'private-next-rsc-server-reference';
const RSC_CACHE_WRAPPER_ALIAS = 'private-next-rsc-cache-wrapper';
const RSC_DYNAMIC_IMPORT_WRAPPER_ALIAS = 'private-next-rsc-track-dynamic-import';
const RSC_ACTION_ENCRYPTION_ALIAS = 'private-next-rsc-action-encryption';
const RSC_ACTION_CLIENT_WRAPPER_ALIAS = 'private-next-rsc-action-client-wrapper';
const PUBLIC_DIR_MIDDLEWARE_CONFLICT = `You can not have a '_next' folder inside of your public folder. This conflicts with the internal '/_next' route. https://nextjs.org/docs/messages/public-next-folder-conflict`;
const SSG_GET_INITIAL_PROPS_CONFLICT = `You can not use getInitialProps with getStaticProps. To use SSG, please remove your getInitialProps`;
const SERVER_PROPS_GET_INIT_PROPS_CONFLICT = `You can not use getInitialProps with getServerSideProps. Please remove getInitialProps.`;
const SERVER_PROPS_SSG_CONFLICT = `You can not use getStaticProps or getStaticPaths with getServerSideProps. To use SSG, please remove getServerSideProps`;
const STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR = `can not have getInitialProps/getServerSideProps, https://nextjs.org/docs/messages/404-get-initial-props`;
const SERVER_PROPS_EXPORT_ERROR = `pages with \`getServerSideProps\` can not be exported. See more info here: https://nextjs.org/docs/messages/gssp-export`;
const GSP_NO_RETURNED_VALUE = 'Your `getStaticProps` function did not return an object. Did you forget to add a `return`?';
const GSSP_NO_RETURNED_VALUE = 'Your `getServerSideProps` function did not return an object. Did you forget to add a `return`?';
const UNSTABLE_REVALIDATE_RENAME_ERROR = 'The `unstable_revalidate` property is available for general use.\n' + 'Please use `revalidate` instead.';
const GSSP_COMPONENT_MEMBER_ERROR = `can not be attached to a page's component and must be exported from the page. See more info here: https://nextjs.org/docs/messages/gssp-component-member`;
const NON_STANDARD_NODE_ENV = `You are using a non-standard "NODE_ENV" value in your environment. This creates inconsistencies in the project and is strongly advised against. Read more: https://nextjs.org/docs/messages/non-standard-node-env`;
const SSG_FALLBACK_EXPORT_ERROR = `Pages with \`fallback\` enabled in \`getStaticPaths\` can not be exported. See more info here: https://nextjs.org/docs/messages/ssg-fallback-true-export`;
const ESLINT_DEFAULT_DIRS = [
    'app',
    'pages',
    'components',
    'lib',
    'src'
];
const SERVER_RUNTIME = {
    edge: 'edge',
    experimentalEdge: 'experimental-edge',
    nodejs: 'nodejs'
};
/**
 * The names of the webpack layers. These layers are the primitives for the
 * webpack chunks.
 */ const WEBPACK_LAYERS_NAMES = {
    /**
   * The layer for the shared code between the client and server bundles.
   */ shared: 'shared',
    /**
   * The layer for server-only runtime and picking up `react-server` export conditions.
   * Including app router RSC pages and app router custom routes and metadata routes.
   */ reactServerComponents: 'rsc',
    /**
   * Server Side Rendering layer for app (ssr).
   */ serverSideRendering: 'ssr',
    /**
   * The browser client bundle layer for actions.
   */ actionBrowser: 'action-browser',
    /**
   * The Node.js bundle layer for the API routes.
   */ apiNode: 'api-node',
    /**
   * The Edge Lite bundle layer for the API routes.
   */ apiEdge: 'api-edge',
    /**
   * The layer for the middleware code.
   */ middleware: 'middleware',
    /**
   * The layer for the instrumentation hooks.
   */ instrument: 'instrument',
    /**
   * The layer for assets on the edge.
   */ edgeAsset: 'edge-asset',
    /**
   * The browser client bundle layer for App directory.
   */ appPagesBrowser: 'app-pages-browser',
    /**
   * The browser client bundle layer for Pages directory.
   */ pagesDirBrowser: 'pages-dir-browser',
    /**
   * The Edge Lite bundle layer for Pages directory.
   */ pagesDirEdge: 'pages-dir-edge',
    /**
   * The Node.js bundle layer for Pages directory.
   */ pagesDirNode: 'pages-dir-node'
};
const WEBPACK_LAYERS = {
    ...WEBPACK_LAYERS_NAMES,
    GROUP: {
        builtinReact: [
            WEBPACK_LAYERS_NAMES.reactServerComponents,
            WEBPACK_LAYERS_NAMES.actionBrowser
        ],
        serverOnly: [
            WEBPACK_LAYERS_NAMES.reactServerComponents,
            WEBPACK_LAYERS_NAMES.actionBrowser,
            WEBPACK_LAYERS_NAMES.instrument,
            WEBPACK_LAYERS_NAMES.middleware
        ],
        neutralTarget: [
            // pages api
            WEBPACK_LAYERS_NAMES.apiNode,
            WEBPACK_LAYERS_NAMES.apiEdge
        ],
        clientOnly: [
            WEBPACK_LAYERS_NAMES.serverSideRendering,
            WEBPACK_LAYERS_NAMES.appPagesBrowser
        ],
        bundled: [
            WEBPACK_LAYERS_NAMES.reactServerComponents,
            WEBPACK_LAYERS_NAMES.actionBrowser,
            WEBPACK_LAYERS_NAMES.serverSideRendering,
            WEBPACK_LAYERS_NAMES.appPagesBrowser,
            WEBPACK_LAYERS_NAMES.shared,
            WEBPACK_LAYERS_NAMES.instrument,
            WEBPACK_LAYERS_NAMES.middleware
        ],
        appPages: [
            // app router pages and layouts
            WEBPACK_LAYERS_NAMES.reactServerComponents,
            WEBPACK_LAYERS_NAMES.serverSideRendering,
            WEBPACK_LAYERS_NAMES.appPagesBrowser,
            WEBPACK_LAYERS_NAMES.actionBrowser
        ]
    }
};
const WEBPACK_RESOURCE_QUERIES = {
    edgeSSREntry: '__next_edge_ssr_entry__',
    metadata: '__next_metadata__',
    metadataRoute: '__next_metadata_route__',
    metadataImageMeta: '__next_metadata_image_meta__'
};
;
 //# sourceMappingURL=constants.js.map
}),
"[project]/node_modules/next/dist/esm/server/web/utils.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "fromNodeOutgoingHttpHeaders": ()=>fromNodeOutgoingHttpHeaders,
    "normalizeNextQueryParam": ()=>normalizeNextQueryParam,
    "splitCookiesString": ()=>splitCookiesString,
    "toNodeOutgoingHttpHeaders": ()=>toNodeOutgoingHttpHeaders,
    "validateURL": ()=>validateURL
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/constants.js [app-rsc] (ecmascript)");
;
function fromNodeOutgoingHttpHeaders(nodeHeaders) {
    const headers = new Headers();
    for (let [key, value] of Object.entries(nodeHeaders)){
        const values = Array.isArray(value) ? value : [
            value
        ];
        for (let v of values){
            if (typeof v === 'undefined') continue;
            if (typeof v === 'number') {
                v = v.toString();
            }
            headers.append(key, v);
        }
    }
    return headers;
}
function splitCookiesString(cookiesString) {
    var cookiesStrings = [];
    var pos = 0;
    var start;
    var ch;
    var lastComma;
    var nextStart;
    var cookiesSeparatorFound;
    function skipWhitespace() {
        while(pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))){
            pos += 1;
        }
        return pos < cookiesString.length;
    }
    function notSpecialChar() {
        ch = cookiesString.charAt(pos);
        return ch !== '=' && ch !== ';' && ch !== ',';
    }
    while(pos < cookiesString.length){
        start = pos;
        cookiesSeparatorFound = false;
        while(skipWhitespace()){
            ch = cookiesString.charAt(pos);
            if (ch === ',') {
                // ',' is a cookie separator if we have later first '=', not ';' or ','
                lastComma = pos;
                pos += 1;
                skipWhitespace();
                nextStart = pos;
                while(pos < cookiesString.length && notSpecialChar()){
                    pos += 1;
                }
                // currently special character
                if (pos < cookiesString.length && cookiesString.charAt(pos) === '=') {
                    // we found cookies separator
                    cookiesSeparatorFound = true;
                    // pos is inside the next cookie, so back up and return it.
                    pos = nextStart;
                    cookiesStrings.push(cookiesString.substring(start, lastComma));
                    start = pos;
                } else {
                    // in param ',' or param separator ';',
                    // we continue from that comma
                    pos = lastComma + 1;
                }
            } else {
                pos += 1;
            }
        }
        if (!cookiesSeparatorFound || pos >= cookiesString.length) {
            cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
        }
    }
    return cookiesStrings;
}
function toNodeOutgoingHttpHeaders(headers) {
    const nodeHeaders = {};
    const cookies = [];
    if (headers) {
        for (const [key, value] of headers.entries()){
            if (key.toLowerCase() === 'set-cookie') {
                // We may have gotten a comma joined string of cookies, or multiple
                // set-cookie headers. We need to merge them into one header array
                // to represent all the cookies.
                cookies.push(...splitCookiesString(value));
                nodeHeaders[key] = cookies.length === 1 ? cookies[0] : cookies;
            } else {
                nodeHeaders[key] = value;
            }
        }
    }
    return nodeHeaders;
}
function validateURL(url) {
    try {
        return String(new URL(String(url)));
    } catch (error) {
        throw Object.defineProperty(new Error(`URL is malformed "${String(url)}". Please use only absolute URLs - https://nextjs.org/docs/messages/middleware-relative-urls`, {
            cause: error
        }), "__NEXT_ERROR_CODE", {
            value: "E61",
            enumerable: false,
            configurable: true
        });
    }
}
function normalizeNextQueryParam(key) {
    const prefixes = [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["NEXT_QUERY_PARAM_PREFIX"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["NEXT_INTERCEPTION_MARKER_PREFIX"]
    ];
    for (const prefix of prefixes){
        if (key !== prefix && key.startsWith(prefix)) {
            return key.substring(prefix.length);
        }
    }
    return null;
} //# sourceMappingURL=utils.js.map
}),
"[project]/node_modules/next/dist/esm/shared/lib/i18n/detect-domain-locale.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "detectDomainLocale": ()=>detectDomainLocale
});
function detectDomainLocale(domainItems, hostname, detectedLocale) {
    if (!domainItems) return;
    if (detectedLocale) {
        detectedLocale = detectedLocale.toLowerCase();
    }
    for (const item of domainItems){
        var _item_domain, _item_locales;
        // remove port if present
        const domainHostname = (_item_domain = item.domain) == null ? void 0 : _item_domain.split(':', 1)[0].toLowerCase();
        if (hostname === domainHostname || detectedLocale === item.defaultLocale.toLowerCase() || ((_item_locales = item.locales) == null ? void 0 : _item_locales.some((locale)=>locale.toLowerCase() === detectedLocale))) {
            return item;
        }
    }
} //# sourceMappingURL=detect-domain-locale.js.map
}),
"[project]/node_modules/next/dist/esm/shared/lib/router/utils/remove-trailing-slash.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * Removes the trailing slash for a given route or page path. Preserves the
 * root page. Examples:
 *   - `/foo/bar/` -> `/foo/bar`
 *   - `/foo/bar` -> `/foo/bar`
 *   - `/` -> `/`
 */ __turbopack_context__.s({
    "removeTrailingSlash": ()=>removeTrailingSlash
});
function removeTrailingSlash(route) {
    return route.replace(/\/$/, '') || '/';
} //# sourceMappingURL=remove-trailing-slash.js.map
}),
"[project]/node_modules/next/dist/esm/shared/lib/router/utils/parse-path.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * Given a path this function will find the pathname, query and hash and return
 * them. This is useful to parse full paths on the client side.
 * @param path A path to parse e.g. /foo/bar?id=1#hash
 */ __turbopack_context__.s({
    "parsePath": ()=>parsePath
});
function parsePath(path) {
    const hashIndex = path.indexOf('#');
    const queryIndex = path.indexOf('?');
    const hasQuery = queryIndex > -1 && (hashIndex < 0 || queryIndex < hashIndex);
    if (hasQuery || hashIndex > -1) {
        return {
            pathname: path.substring(0, hasQuery ? queryIndex : hashIndex),
            query: hasQuery ? path.substring(queryIndex, hashIndex > -1 ? hashIndex : undefined) : '',
            hash: hashIndex > -1 ? path.slice(hashIndex) : ''
        };
    }
    return {
        pathname: path,
        query: '',
        hash: ''
    };
} //# sourceMappingURL=parse-path.js.map
}),
"[project]/node_modules/next/dist/esm/shared/lib/router/utils/add-path-prefix.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "addPathPrefix": ()=>addPathPrefix
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$parse$2d$path$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/router/utils/parse-path.js [app-rsc] (ecmascript)");
;
function addPathPrefix(path, prefix) {
    if (!path.startsWith('/') || !prefix) {
        return path;
    }
    const { pathname, query, hash } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$parse$2d$path$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["parsePath"])(path);
    return "" + prefix + pathname + query + hash;
} //# sourceMappingURL=add-path-prefix.js.map
}),
"[project]/node_modules/next/dist/esm/shared/lib/router/utils/add-path-suffix.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "addPathSuffix": ()=>addPathSuffix
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$parse$2d$path$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/router/utils/parse-path.js [app-rsc] (ecmascript)");
;
function addPathSuffix(path, suffix) {
    if (!path.startsWith('/') || !suffix) {
        return path;
    }
    const { pathname, query, hash } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$parse$2d$path$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["parsePath"])(path);
    return "" + pathname + suffix + query + hash;
} //# sourceMappingURL=add-path-suffix.js.map
}),
"[project]/node_modules/next/dist/esm/shared/lib/router/utils/path-has-prefix.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "pathHasPrefix": ()=>pathHasPrefix
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$parse$2d$path$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/router/utils/parse-path.js [app-rsc] (ecmascript)");
;
function pathHasPrefix(path, prefix) {
    if (typeof path !== 'string') {
        return false;
    }
    const { pathname } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$parse$2d$path$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["parsePath"])(path);
    return pathname === prefix || pathname.startsWith(prefix + '/');
} //# sourceMappingURL=path-has-prefix.js.map
}),
"[project]/node_modules/next/dist/esm/shared/lib/router/utils/add-locale.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "addLocale": ()=>addLocale
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$add$2d$path$2d$prefix$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/router/utils/add-path-prefix.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$path$2d$has$2d$prefix$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/router/utils/path-has-prefix.js [app-rsc] (ecmascript)");
;
;
function addLocale(path, locale, defaultLocale, ignorePrefix) {
    // If no locale was given or the locale is the default locale, we don't need
    // to prefix the path.
    if (!locale || locale === defaultLocale) return path;
    const lower = path.toLowerCase();
    // If the path is an API path or the path already has the locale prefix, we
    // don't need to prefix the path.
    if (!ignorePrefix) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$path$2d$has$2d$prefix$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["pathHasPrefix"])(lower, '/api')) return path;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$path$2d$has$2d$prefix$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["pathHasPrefix"])(lower, "/" + locale.toLowerCase())) return path;
    }
    // Add the locale prefix to the path.
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$add$2d$path$2d$prefix$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["addPathPrefix"])(path, "/" + locale);
} //# sourceMappingURL=add-locale.js.map
}),
"[project]/node_modules/next/dist/esm/shared/lib/router/utils/format-next-pathname-info.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "formatNextPathnameInfo": ()=>formatNextPathnameInfo
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$remove$2d$trailing$2d$slash$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/router/utils/remove-trailing-slash.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$add$2d$path$2d$prefix$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/router/utils/add-path-prefix.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$add$2d$path$2d$suffix$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/router/utils/add-path-suffix.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$add$2d$locale$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/router/utils/add-locale.js [app-rsc] (ecmascript)");
;
;
;
;
function formatNextPathnameInfo(info) {
    let pathname = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$add$2d$locale$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["addLocale"])(info.pathname, info.locale, info.buildId ? undefined : info.defaultLocale, info.ignorePrefix);
    if (info.buildId || !info.trailingSlash) {
        pathname = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$remove$2d$trailing$2d$slash$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["removeTrailingSlash"])(pathname);
    }
    if (info.buildId) {
        pathname = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$add$2d$path$2d$suffix$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["addPathSuffix"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$add$2d$path$2d$prefix$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["addPathPrefix"])(pathname, "/_next/data/" + info.buildId), info.pathname === '/' ? 'index.json' : '.json');
    }
    pathname = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$add$2d$path$2d$prefix$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["addPathPrefix"])(pathname, info.basePath);
    return !info.buildId && info.trailingSlash ? !pathname.endsWith('/') ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$add$2d$path$2d$suffix$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["addPathSuffix"])(pathname, '/') : pathname : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$remove$2d$trailing$2d$slash$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["removeTrailingSlash"])(pathname);
} //# sourceMappingURL=format-next-pathname-info.js.map
}),
"[project]/node_modules/next/dist/esm/shared/lib/get-hostname.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * Takes an object with a hostname property (like a parsed URL) and some
 * headers that may contain Host and returns the preferred hostname.
 * @param parsed An object containing a hostname property.
 * @param headers A dictionary with headers containing a `host`.
 */ __turbopack_context__.s({
    "getHostname": ()=>getHostname
});
function getHostname(parsed, headers) {
    // Get the hostname from the headers if it exists, otherwise use the parsed
    // hostname.
    let hostname;
    if ((headers == null ? void 0 : headers.host) && !Array.isArray(headers.host)) {
        hostname = headers.host.toString().split(':', 1)[0];
    } else if (parsed.hostname) {
        hostname = parsed.hostname;
    } else return;
    return hostname.toLowerCase();
} //# sourceMappingURL=get-hostname.js.map
}),
"[project]/node_modules/next/dist/esm/shared/lib/i18n/normalize-locale-path.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * A cache of lowercased locales for each list of locales. This is stored as a
 * WeakMap so if the locales are garbage collected, the cache entry will be
 * removed as well.
 */ __turbopack_context__.s({
    "normalizeLocalePath": ()=>normalizeLocalePath
});
const cache = new WeakMap();
function normalizeLocalePath(pathname, locales) {
    // If locales is undefined, return the pathname as is.
    if (!locales) return {
        pathname
    };
    // Get the cached lowercased locales or create a new cache entry.
    let lowercasedLocales = cache.get(locales);
    if (!lowercasedLocales) {
        lowercasedLocales = locales.map((locale)=>locale.toLowerCase());
        cache.set(locales, lowercasedLocales);
    }
    let detectedLocale;
    // The first segment will be empty, because it has a leading `/`. If
    // there is no further segment, there is no locale (or it's the default).
    const segments = pathname.split('/', 2);
    // If there's no second segment (ie, the pathname is just `/`), there's no
    // locale.
    if (!segments[1]) return {
        pathname
    };
    // The second segment will contain the locale part if any.
    const segment = segments[1].toLowerCase();
    // See if the segment matches one of the locales. If it doesn't, there is
    // no locale (or it's the default).
    const index = lowercasedLocales.indexOf(segment);
    if (index < 0) return {
        pathname
    };
    // Return the case-sensitive locale.
    detectedLocale = locales[index];
    // Remove the `/${locale}` part of the pathname.
    pathname = pathname.slice(detectedLocale.length + 1) || '/';
    return {
        pathname,
        detectedLocale
    };
} //# sourceMappingURL=normalize-locale-path.js.map
}),
"[project]/node_modules/next/dist/esm/shared/lib/router/utils/remove-path-prefix.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "removePathPrefix": ()=>removePathPrefix
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$path$2d$has$2d$prefix$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/router/utils/path-has-prefix.js [app-rsc] (ecmascript)");
;
function removePathPrefix(path, prefix) {
    // If the path doesn't start with the prefix we can return it as is. This
    // protects us from situations where the prefix is a substring of the path
    // prefix such as:
    //
    // For prefix: /blog
    //
    //   /blog -> true
    //   /blog/ -> true
    //   /blog/1 -> true
    //   /blogging -> false
    //   /blogging/ -> false
    //   /blogging/1 -> false
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$path$2d$has$2d$prefix$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["pathHasPrefix"])(path, prefix)) {
        return path;
    }
    // Remove the prefix from the path via slicing.
    const withoutPrefix = path.slice(prefix.length);
    // If the path without the prefix starts with a `/` we can return it as is.
    if (withoutPrefix.startsWith('/')) {
        return withoutPrefix;
    }
    // If the path without the prefix doesn't start with a `/` we need to add it
    // back to the path to make sure it's a valid path.
    return "/" + withoutPrefix;
} //# sourceMappingURL=remove-path-prefix.js.map
}),
"[project]/node_modules/next/dist/esm/shared/lib/router/utils/get-next-pathname-info.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "getNextPathnameInfo": ()=>getNextPathnameInfo
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$i18n$2f$normalize$2d$locale$2d$path$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/i18n/normalize-locale-path.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$remove$2d$path$2d$prefix$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/router/utils/remove-path-prefix.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$path$2d$has$2d$prefix$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/router/utils/path-has-prefix.js [app-rsc] (ecmascript)");
;
;
;
function getNextPathnameInfo(pathname, options) {
    var _options_nextConfig;
    const { basePath, i18n, trailingSlash } = (_options_nextConfig = options.nextConfig) != null ? _options_nextConfig : {};
    const info = {
        pathname,
        trailingSlash: pathname !== '/' ? pathname.endsWith('/') : trailingSlash
    };
    if (basePath && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$path$2d$has$2d$prefix$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["pathHasPrefix"])(info.pathname, basePath)) {
        info.pathname = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$remove$2d$path$2d$prefix$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["removePathPrefix"])(info.pathname, basePath);
        info.basePath = basePath;
    }
    let pathnameNoDataPrefix = info.pathname;
    if (info.pathname.startsWith('/_next/data/') && info.pathname.endsWith('.json')) {
        const paths = info.pathname.replace(/^\/_next\/data\//, '').replace(/\.json$/, '').split('/');
        const buildId = paths[0];
        info.buildId = buildId;
        pathnameNoDataPrefix = paths[1] !== 'index' ? "/" + paths.slice(1).join('/') : '/';
        // update pathname with normalized if enabled although
        // we use normalized to populate locale info still
        if (options.parseData === true) {
            info.pathname = pathnameNoDataPrefix;
        }
    }
    // If provided, use the locale route normalizer to detect the locale instead
    // of the function below.
    if (i18n) {
        let result = options.i18nProvider ? options.i18nProvider.analyze(info.pathname) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$i18n$2f$normalize$2d$locale$2d$path$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["normalizeLocalePath"])(info.pathname, i18n.locales);
        info.locale = result.detectedLocale;
        var _result_pathname;
        info.pathname = (_result_pathname = result.pathname) != null ? _result_pathname : info.pathname;
        if (!result.detectedLocale && info.buildId) {
            result = options.i18nProvider ? options.i18nProvider.analyze(pathnameNoDataPrefix) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$i18n$2f$normalize$2d$locale$2d$path$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["normalizeLocalePath"])(pathnameNoDataPrefix, i18n.locales);
            if (result.detectedLocale) {
                info.locale = result.detectedLocale;
            }
        }
    }
    return info;
} //# sourceMappingURL=get-next-pathname-info.js.map
}),
"[project]/node_modules/next/dist/esm/server/web/next-url.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "NextURL": ()=>NextURL
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$i18n$2f$detect$2d$domain$2d$locale$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/i18n/detect-domain-locale.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$format$2d$next$2d$pathname$2d$info$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/router/utils/format-next-pathname-info.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$get$2d$hostname$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/get-hostname.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$get$2d$next$2d$pathname$2d$info$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/router/utils/get-next-pathname-info.js [app-rsc] (ecmascript)");
;
;
;
;
const REGEX_LOCALHOST_HOSTNAME = /(?!^https?:\/\/)(127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}|\[::1\]|localhost)/;
function parseURL(url, base) {
    return new URL(String(url).replace(REGEX_LOCALHOST_HOSTNAME, 'localhost'), base && String(base).replace(REGEX_LOCALHOST_HOSTNAME, 'localhost'));
}
const Internal = Symbol('NextURLInternal');
class NextURL {
    constructor(input, baseOrOpts, opts){
        let base;
        let options;
        if (typeof baseOrOpts === 'object' && 'pathname' in baseOrOpts || typeof baseOrOpts === 'string') {
            base = baseOrOpts;
            options = opts || {};
        } else {
            options = opts || baseOrOpts || {};
        }
        this[Internal] = {
            url: parseURL(input, base ?? options.base),
            options: options,
            basePath: ''
        };
        this.analyze();
    }
    analyze() {
        var _this_Internal_options_nextConfig_i18n, _this_Internal_options_nextConfig, _this_Internal_domainLocale, _this_Internal_options_nextConfig_i18n1, _this_Internal_options_nextConfig1;
        const info = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$get$2d$next$2d$pathname$2d$info$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getNextPathnameInfo"])(this[Internal].url.pathname, {
            nextConfig: this[Internal].options.nextConfig,
            parseData: !("TURBOPACK compile-time value", void 0),
            i18nProvider: this[Internal].options.i18nProvider
        });
        const hostname = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$get$2d$hostname$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getHostname"])(this[Internal].url, this[Internal].options.headers);
        this[Internal].domainLocale = this[Internal].options.i18nProvider ? this[Internal].options.i18nProvider.detectDomainLocale(hostname) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$i18n$2f$detect$2d$domain$2d$locale$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["detectDomainLocale"])((_this_Internal_options_nextConfig = this[Internal].options.nextConfig) == null ? void 0 : (_this_Internal_options_nextConfig_i18n = _this_Internal_options_nextConfig.i18n) == null ? void 0 : _this_Internal_options_nextConfig_i18n.domains, hostname);
        const defaultLocale = ((_this_Internal_domainLocale = this[Internal].domainLocale) == null ? void 0 : _this_Internal_domainLocale.defaultLocale) || ((_this_Internal_options_nextConfig1 = this[Internal].options.nextConfig) == null ? void 0 : (_this_Internal_options_nextConfig_i18n1 = _this_Internal_options_nextConfig1.i18n) == null ? void 0 : _this_Internal_options_nextConfig_i18n1.defaultLocale);
        this[Internal].url.pathname = info.pathname;
        this[Internal].defaultLocale = defaultLocale;
        this[Internal].basePath = info.basePath ?? '';
        this[Internal].buildId = info.buildId;
        this[Internal].locale = info.locale ?? defaultLocale;
        this[Internal].trailingSlash = info.trailingSlash;
    }
    formatPathname() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$format$2d$next$2d$pathname$2d$info$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["formatNextPathnameInfo"])({
            basePath: this[Internal].basePath,
            buildId: this[Internal].buildId,
            defaultLocale: !this[Internal].options.forceLocale ? this[Internal].defaultLocale : undefined,
            locale: this[Internal].locale,
            pathname: this[Internal].url.pathname,
            trailingSlash: this[Internal].trailingSlash
        });
    }
    formatSearch() {
        return this[Internal].url.search;
    }
    get buildId() {
        return this[Internal].buildId;
    }
    set buildId(buildId) {
        this[Internal].buildId = buildId;
    }
    get locale() {
        return this[Internal].locale ?? '';
    }
    set locale(locale) {
        var _this_Internal_options_nextConfig_i18n, _this_Internal_options_nextConfig;
        if (!this[Internal].locale || !((_this_Internal_options_nextConfig = this[Internal].options.nextConfig) == null ? void 0 : (_this_Internal_options_nextConfig_i18n = _this_Internal_options_nextConfig.i18n) == null ? void 0 : _this_Internal_options_nextConfig_i18n.locales.includes(locale))) {
            throw Object.defineProperty(new TypeError(`The NextURL configuration includes no locale "${locale}"`), "__NEXT_ERROR_CODE", {
                value: "E597",
                enumerable: false,
                configurable: true
            });
        }
        this[Internal].locale = locale;
    }
    get defaultLocale() {
        return this[Internal].defaultLocale;
    }
    get domainLocale() {
        return this[Internal].domainLocale;
    }
    get searchParams() {
        return this[Internal].url.searchParams;
    }
    get host() {
        return this[Internal].url.host;
    }
    set host(value) {
        this[Internal].url.host = value;
    }
    get hostname() {
        return this[Internal].url.hostname;
    }
    set hostname(value) {
        this[Internal].url.hostname = value;
    }
    get port() {
        return this[Internal].url.port;
    }
    set port(value) {
        this[Internal].url.port = value;
    }
    get protocol() {
        return this[Internal].url.protocol;
    }
    set protocol(value) {
        this[Internal].url.protocol = value;
    }
    get href() {
        const pathname = this.formatPathname();
        const search = this.formatSearch();
        return `${this.protocol}//${this.host}${pathname}${search}${this.hash}`;
    }
    set href(url) {
        this[Internal].url = parseURL(url);
        this.analyze();
    }
    get origin() {
        return this[Internal].url.origin;
    }
    get pathname() {
        return this[Internal].url.pathname;
    }
    set pathname(value) {
        this[Internal].url.pathname = value;
    }
    get hash() {
        return this[Internal].url.hash;
    }
    set hash(value) {
        this[Internal].url.hash = value;
    }
    get search() {
        return this[Internal].url.search;
    }
    set search(value) {
        this[Internal].url.search = value;
    }
    get password() {
        return this[Internal].url.password;
    }
    set password(value) {
        this[Internal].url.password = value;
    }
    get username() {
        return this[Internal].url.username;
    }
    set username(value) {
        this[Internal].url.username = value;
    }
    get basePath() {
        return this[Internal].basePath;
    }
    set basePath(value) {
        this[Internal].basePath = value.startsWith('/') ? value : `/${value}`;
    }
    toString() {
        return this.href;
    }
    toJSON() {
        return this.href;
    }
    [Symbol.for('edge-runtime.inspect.custom')]() {
        return {
            href: this.href,
            origin: this.origin,
            protocol: this.protocol,
            username: this.username,
            password: this.password,
            host: this.host,
            hostname: this.hostname,
            port: this.port,
            pathname: this.pathname,
            search: this.search,
            searchParams: this.searchParams,
            hash: this.hash
        };
    }
    clone() {
        return new NextURL(String(this), this[Internal].options);
    }
} //# sourceMappingURL=next-url.js.map
}),
"[project]/node_modules/next/dist/esm/server/web/error.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "PageSignatureError": ()=>PageSignatureError,
    "RemovedPageError": ()=>RemovedPageError,
    "RemovedUAError": ()=>RemovedUAError
});
class PageSignatureError extends Error {
    constructor({ page }){
        super(`The middleware "${page}" accepts an async API directly with the form:
  
  export function middleware(request, event) {
    return NextResponse.redirect('/new-location')
  }
  
  Read more: https://nextjs.org/docs/messages/middleware-new-signature
  `);
    }
}
class RemovedPageError extends Error {
    constructor(){
        super(`The request.page has been deprecated in favour of \`URLPattern\`.
  Read more: https://nextjs.org/docs/messages/middleware-request-page
  `);
    }
}
class RemovedUAError extends Error {
    constructor(){
        super(`The request.ua has been removed in favour of \`userAgent\` function.
  Read more: https://nextjs.org/docs/messages/middleware-parse-user-agent
  `);
    }
} //# sourceMappingURL=error.js.map
}),
"[project]/node_modules/next/dist/compiled/@edge-runtime/cookies/index.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
// src/index.ts
var src_exports = {};
__export(src_exports, {
    RequestCookies: ()=>RequestCookies,
    ResponseCookies: ()=>ResponseCookies,
    parseCookie: ()=>parseCookie,
    parseSetCookie: ()=>parseSetCookie,
    stringifyCookie: ()=>stringifyCookie
});
module.exports = __toCommonJS(src_exports);
// src/serialize.ts
function stringifyCookie(c) {
    var _a;
    const attrs = [
        "path" in c && c.path && `Path=${c.path}`,
        "expires" in c && (c.expires || c.expires === 0) && `Expires=${(typeof c.expires === "number" ? new Date(c.expires) : c.expires).toUTCString()}`,
        "maxAge" in c && typeof c.maxAge === "number" && `Max-Age=${c.maxAge}`,
        "domain" in c && c.domain && `Domain=${c.domain}`,
        "secure" in c && c.secure && "Secure",
        "httpOnly" in c && c.httpOnly && "HttpOnly",
        "sameSite" in c && c.sameSite && `SameSite=${c.sameSite}`,
        "partitioned" in c && c.partitioned && "Partitioned",
        "priority" in c && c.priority && `Priority=${c.priority}`
    ].filter(Boolean);
    const stringified = `${c.name}=${encodeURIComponent((_a = c.value) != null ? _a : "")}`;
    return attrs.length === 0 ? stringified : `${stringified}; ${attrs.join("; ")}`;
}
function parseCookie(cookie) {
    const map = /* @__PURE__ */ new Map();
    for (const pair of cookie.split(/; */)){
        if (!pair) continue;
        const splitAt = pair.indexOf("=");
        if (splitAt === -1) {
            map.set(pair, "true");
            continue;
        }
        const [key, value] = [
            pair.slice(0, splitAt),
            pair.slice(splitAt + 1)
        ];
        try {
            map.set(key, decodeURIComponent(value != null ? value : "true"));
        } catch  {}
    }
    return map;
}
function parseSetCookie(setCookie) {
    if (!setCookie) {
        return void 0;
    }
    const [[name, value], ...attributes] = parseCookie(setCookie);
    const { domain, expires, httponly, maxage, path, samesite, secure, partitioned, priority } = Object.fromEntries(attributes.map(([key, value2])=>[
            key.toLowerCase().replace(/-/g, ""),
            value2
        ]));
    const cookie = {
        name,
        value: decodeURIComponent(value),
        domain,
        ...expires && {
            expires: new Date(expires)
        },
        ...httponly && {
            httpOnly: true
        },
        ...typeof maxage === "string" && {
            maxAge: Number(maxage)
        },
        path,
        ...samesite && {
            sameSite: parseSameSite(samesite)
        },
        ...secure && {
            secure: true
        },
        ...priority && {
            priority: parsePriority(priority)
        },
        ...partitioned && {
            partitioned: true
        }
    };
    return compact(cookie);
}
function compact(t) {
    const newT = {};
    for(const key in t){
        if (t[key]) {
            newT[key] = t[key];
        }
    }
    return newT;
}
var SAME_SITE = [
    "strict",
    "lax",
    "none"
];
function parseSameSite(string) {
    string = string.toLowerCase();
    return SAME_SITE.includes(string) ? string : void 0;
}
var PRIORITY = [
    "low",
    "medium",
    "high"
];
function parsePriority(string) {
    string = string.toLowerCase();
    return PRIORITY.includes(string) ? string : void 0;
}
function splitCookiesString(cookiesString) {
    if (!cookiesString) return [];
    var cookiesStrings = [];
    var pos = 0;
    var start;
    var ch;
    var lastComma;
    var nextStart;
    var cookiesSeparatorFound;
    function skipWhitespace() {
        while(pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))){
            pos += 1;
        }
        return pos < cookiesString.length;
    }
    function notSpecialChar() {
        ch = cookiesString.charAt(pos);
        return ch !== "=" && ch !== ";" && ch !== ",";
    }
    while(pos < cookiesString.length){
        start = pos;
        cookiesSeparatorFound = false;
        while(skipWhitespace()){
            ch = cookiesString.charAt(pos);
            if (ch === ",") {
                lastComma = pos;
                pos += 1;
                skipWhitespace();
                nextStart = pos;
                while(pos < cookiesString.length && notSpecialChar()){
                    pos += 1;
                }
                if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
                    cookiesSeparatorFound = true;
                    pos = nextStart;
                    cookiesStrings.push(cookiesString.substring(start, lastComma));
                    start = pos;
                } else {
                    pos = lastComma + 1;
                }
            } else {
                pos += 1;
            }
        }
        if (!cookiesSeparatorFound || pos >= cookiesString.length) {
            cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
        }
    }
    return cookiesStrings;
}
// src/request-cookies.ts
var RequestCookies = class {
    constructor(requestHeaders){
        /** @internal */ this._parsed = /* @__PURE__ */ new Map();
        this._headers = requestHeaders;
        const header = requestHeaders.get("cookie");
        if (header) {
            const parsed = parseCookie(header);
            for (const [name, value] of parsed){
                this._parsed.set(name, {
                    name,
                    value
                });
            }
        }
    }
    [Symbol.iterator]() {
        return this._parsed[Symbol.iterator]();
    }
    /**
   * The amount of cookies received from the client
   */ get size() {
        return this._parsed.size;
    }
    get(...args) {
        const name = typeof args[0] === "string" ? args[0] : args[0].name;
        return this._parsed.get(name);
    }
    getAll(...args) {
        var _a;
        const all = Array.from(this._parsed);
        if (!args.length) {
            return all.map(([_, value])=>value);
        }
        const name = typeof args[0] === "string" ? args[0] : (_a = args[0]) == null ? void 0 : _a.name;
        return all.filter(([n])=>n === name).map(([_, value])=>value);
    }
    has(name) {
        return this._parsed.has(name);
    }
    set(...args) {
        const [name, value] = args.length === 1 ? [
            args[0].name,
            args[0].value
        ] : args;
        const map = this._parsed;
        map.set(name, {
            name,
            value
        });
        this._headers.set("cookie", Array.from(map).map(([_, value2])=>stringifyCookie(value2)).join("; "));
        return this;
    }
    /**
   * Delete the cookies matching the passed name or names in the request.
   */ delete(names) {
        const map = this._parsed;
        const result = !Array.isArray(names) ? map.delete(names) : names.map((name)=>map.delete(name));
        this._headers.set("cookie", Array.from(map).map(([_, value])=>stringifyCookie(value)).join("; "));
        return result;
    }
    /**
   * Delete all the cookies in the cookies in the request.
   */ clear() {
        this.delete(Array.from(this._parsed.keys()));
        return this;
    }
    /**
   * Format the cookies in the request as a string for logging
   */ [Symbol.for("edge-runtime.inspect.custom")]() {
        return `RequestCookies ${JSON.stringify(Object.fromEntries(this._parsed))}`;
    }
    toString() {
        return [
            ...this._parsed.values()
        ].map((v)=>`${v.name}=${encodeURIComponent(v.value)}`).join("; ");
    }
};
// src/response-cookies.ts
var ResponseCookies = class {
    constructor(responseHeaders){
        /** @internal */ this._parsed = /* @__PURE__ */ new Map();
        var _a, _b, _c;
        this._headers = responseHeaders;
        const setCookie = (_c = (_b = (_a = responseHeaders.getSetCookie) == null ? void 0 : _a.call(responseHeaders)) != null ? _b : responseHeaders.get("set-cookie")) != null ? _c : [];
        const cookieStrings = Array.isArray(setCookie) ? setCookie : splitCookiesString(setCookie);
        for (const cookieString of cookieStrings){
            const parsed = parseSetCookie(cookieString);
            if (parsed) this._parsed.set(parsed.name, parsed);
        }
    }
    /**
   * {@link https://wicg.github.io/cookie-store/#CookieStore-get CookieStore#get} without the Promise.
   */ get(...args) {
        const key = typeof args[0] === "string" ? args[0] : args[0].name;
        return this._parsed.get(key);
    }
    /**
   * {@link https://wicg.github.io/cookie-store/#CookieStore-getAll CookieStore#getAll} without the Promise.
   */ getAll(...args) {
        var _a;
        const all = Array.from(this._parsed.values());
        if (!args.length) {
            return all;
        }
        const key = typeof args[0] === "string" ? args[0] : (_a = args[0]) == null ? void 0 : _a.name;
        return all.filter((c)=>c.name === key);
    }
    has(name) {
        return this._parsed.has(name);
    }
    /**
   * {@link https://wicg.github.io/cookie-store/#CookieStore-set CookieStore#set} without the Promise.
   */ set(...args) {
        const [name, value, cookie] = args.length === 1 ? [
            args[0].name,
            args[0].value,
            args[0]
        ] : args;
        const map = this._parsed;
        map.set(name, normalizeCookie({
            name,
            value,
            ...cookie
        }));
        replace(map, this._headers);
        return this;
    }
    /**
   * {@link https://wicg.github.io/cookie-store/#CookieStore-delete CookieStore#delete} without the Promise.
   */ delete(...args) {
        const [name, options] = typeof args[0] === "string" ? [
            args[0]
        ] : [
            args[0].name,
            args[0]
        ];
        return this.set({
            ...options,
            name,
            value: "",
            expires: /* @__PURE__ */ new Date(0)
        });
    }
    [Symbol.for("edge-runtime.inspect.custom")]() {
        return `ResponseCookies ${JSON.stringify(Object.fromEntries(this._parsed))}`;
    }
    toString() {
        return [
            ...this._parsed.values()
        ].map(stringifyCookie).join("; ");
    }
};
function replace(bag, headers) {
    headers.delete("set-cookie");
    for (const [, value] of bag){
        const serialized = stringifyCookie(value);
        headers.append("set-cookie", serialized);
    }
}
function normalizeCookie(cookie = {
    name: "",
    value: ""
}) {
    if (typeof cookie.expires === "number") {
        cookie.expires = new Date(cookie.expires);
    }
    if (cookie.maxAge) {
        cookie.expires = new Date(Date.now() + cookie.maxAge * 1e3);
    }
    if (cookie.path === null || cookie.path === void 0) {
        cookie.path = "/";
    }
    return cookie;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    RequestCookies,
    ResponseCookies,
    parseCookie,
    parseSetCookie,
    stringifyCookie
});
}}),
"[project]/node_modules/next/dist/esm/server/web/spec-extension/cookies.js [app-rsc] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f40$edge$2d$runtime$2f$cookies$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/@edge-runtime/cookies/index.js [app-rsc] (ecmascript)"); //# sourceMappingURL=cookies.js.map
;
}),
"[project]/node_modules/next/dist/esm/server/web/spec-extension/cookies.js [app-rsc] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f40$edge$2d$runtime$2f$cookies$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/@edge-runtime/cookies/index.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$spec$2d$extension$2f$cookies$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/web/spec-extension/cookies.js [app-rsc] (ecmascript) <locals>");
}),
"[project]/node_modules/next/dist/esm/server/web/spec-extension/request.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "INTERNALS": ()=>INTERNALS,
    "NextRequest": ()=>NextRequest
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$next$2d$url$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/web/next-url.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/web/utils.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$error$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/web/error.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$spec$2d$extension$2f$cookies$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/web/spec-extension/cookies.js [app-rsc] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f40$edge$2d$runtime$2f$cookies$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/@edge-runtime/cookies/index.js [app-rsc] (ecmascript)");
;
;
;
;
const INTERNALS = Symbol('internal request');
class NextRequest extends Request {
    constructor(input, init = {}){
        const url = typeof input !== 'string' && 'url' in input ? input.url : String(input);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["validateURL"])(url);
        // node Request instance requires duplex option when a body
        // is present or it errors, we don't handle this for
        // Request being passed in since it would have already
        // errored if this wasn't configured
        if ("TURBOPACK compile-time truthy", 1) {
            if (init.body && init.duplex !== 'half') {
                init.duplex = 'half';
            }
        }
        if (input instanceof Request) super(input, init);
        else super(url, init);
        const nextUrl = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$next$2d$url$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["NextURL"](url, {
            headers: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["toNodeOutgoingHttpHeaders"])(this.headers),
            nextConfig: init.nextConfig
        });
        this[INTERNALS] = {
            cookies: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f40$edge$2d$runtime$2f$cookies$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["RequestCookies"](this.headers),
            nextUrl,
            url: ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : nextUrl.toString()
        };
    }
    [Symbol.for('edge-runtime.inspect.custom')]() {
        return {
            cookies: this.cookies,
            nextUrl: this.nextUrl,
            url: this.url,
            // rest of props come from Request
            bodyUsed: this.bodyUsed,
            cache: this.cache,
            credentials: this.credentials,
            destination: this.destination,
            headers: Object.fromEntries(this.headers),
            integrity: this.integrity,
            keepalive: this.keepalive,
            method: this.method,
            mode: this.mode,
            redirect: this.redirect,
            referrer: this.referrer,
            referrerPolicy: this.referrerPolicy,
            signal: this.signal
        };
    }
    get cookies() {
        return this[INTERNALS].cookies;
    }
    get nextUrl() {
        return this[INTERNALS].nextUrl;
    }
    /**
   * @deprecated
   * `page` has been deprecated in favour of `URLPattern`.
   * Read more: https://nextjs.org/docs/messages/middleware-request-page
   */ get page() {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$error$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["RemovedPageError"]();
    }
    /**
   * @deprecated
   * `ua` has been removed in favour of \`userAgent\` function.
   * Read more: https://nextjs.org/docs/messages/middleware-parse-user-agent
   */ get ua() {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$error$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["RemovedUAError"]();
    }
    get url() {
        return this[INTERNALS].url;
    }
} //# sourceMappingURL=request.js.map
}),
"[project]/node_modules/next/dist/esm/server/base-http/helpers.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * This file provides some helpers that should be used in conjunction with
 * explicit environment checks. When combined with the environment checks, it
 * will ensure that the correct typings are used as well as enable code
 * elimination.
 */ /**
 * Type guard to determine if a request is a WebNextRequest. This does not
 * actually check the type of the request, but rather the runtime environment.
 * It's expected that when the runtime environment is the edge runtime, that any
 * base request is a WebNextRequest.
 */ __turbopack_context__.s({
    "isNodeNextRequest": ()=>isNodeNextRequest,
    "isNodeNextResponse": ()=>isNodeNextResponse,
    "isWebNextRequest": ()=>isWebNextRequest,
    "isWebNextResponse": ()=>isWebNextResponse
});
const isWebNextRequest = (req)=>("TURBOPACK compile-time value", "nodejs") === 'edge';
const isWebNextResponse = (res)=>("TURBOPACK compile-time value", "nodejs") === 'edge';
const isNodeNextRequest = (req)=>("TURBOPACK compile-time value", "nodejs") !== 'edge';
const isNodeNextResponse = (res)=>("TURBOPACK compile-time value", "nodejs") !== 'edge'; //# sourceMappingURL=helpers.js.map
}),
"[project]/node_modules/next/dist/esm/server/web/spec-extension/adapters/next-request.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "NextRequestAdapter": ()=>NextRequestAdapter,
    "ResponseAborted": ()=>ResponseAborted,
    "ResponseAbortedName": ()=>ResponseAbortedName,
    "createAbortController": ()=>createAbortController,
    "signalFromNodeResponse": ()=>signalFromNodeResponse
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2d$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/request-meta.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/web/utils.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$spec$2d$extension$2f$request$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/web/spec-extension/request.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$base$2d$http$2f$helpers$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/base-http/helpers.js [app-rsc] (ecmascript)");
;
;
;
;
const ResponseAbortedName = 'ResponseAborted';
class ResponseAborted extends Error {
    constructor(...args){
        super(...args), this.name = ResponseAbortedName;
    }
}
function createAbortController(response) {
    const controller = new AbortController();
    // If `finish` fires first, then `res.end()` has been called and the close is
    // just us finishing the stream on our side. If `close` fires first, then we
    // know the client disconnected before we finished.
    response.once('close', ()=>{
        if (response.writableFinished) return;
        controller.abort(new ResponseAborted());
    });
    return controller;
}
function signalFromNodeResponse(response) {
    const { errored, destroyed } = response;
    if (errored || destroyed) {
        return AbortSignal.abort(errored ?? new ResponseAborted());
    }
    const { signal } = createAbortController(response);
    return signal;
}
class NextRequestAdapter {
    static fromBaseNextRequest(request, signal) {
        if (// environment variable check provides dead code elimination.
        ("TURBOPACK compile-time value", "nodejs") === 'edge' && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$base$2d$http$2f$helpers$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isWebNextRequest"])(request)) //TURBOPACK unreachable
        ;
        else if (// environment variable check provides dead code elimination.
        ("TURBOPACK compile-time value", "nodejs") !== 'edge' && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$base$2d$http$2f$helpers$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isNodeNextRequest"])(request)) {
            return NextRequestAdapter.fromNodeNextRequest(request, signal);
        } else {
            throw Object.defineProperty(new Error('Invariant: Unsupported NextRequest type'), "__NEXT_ERROR_CODE", {
                value: "E345",
                enumerable: false,
                configurable: true
            });
        }
    }
    static fromNodeNextRequest(request, signal) {
        // HEAD and GET requests can not have a body.
        let body = null;
        if (request.method !== 'GET' && request.method !== 'HEAD' && request.body) {
            // @ts-expect-error - this is handled by undici, when streams/web land use it instead
            body = request.body;
        }
        let url;
        if (request.url.startsWith('http')) {
            url = new URL(request.url);
        } else {
            // Grab the full URL from the request metadata.
            const base = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2d$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getRequestMeta"])(request, 'initURL');
            if (!base || !base.startsWith('http')) {
                // Because the URL construction relies on the fact that the URL provided
                // is absolute, we need to provide a base URL. We can't use the request
                // URL because it's relative, so we use a dummy URL instead.
                url = new URL(request.url, 'http://n');
            } else {
                url = new URL(request.url, base);
            }
        }
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$spec$2d$extension$2f$request$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["NextRequest"](url, {
            method: request.method,
            headers: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["fromNodeOutgoingHttpHeaders"])(request.headers),
            duplex: 'half',
            signal,
            // geo
            // ip
            // nextConfig
            // body can not be passed if request was aborted
            // or we get a Request body was disturbed error
            ...signal.aborted ? {} : {
                body
            }
        });
    }
    static fromWebNextRequest(request) {
        // HEAD and GET requests can not have a body.
        let body = null;
        if (request.method !== 'GET' && request.method !== 'HEAD') {
            body = request.body;
        }
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$spec$2d$extension$2f$request$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["NextRequest"](request.url, {
            method: request.method,
            headers: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["fromNodeOutgoingHttpHeaders"])(request.headers),
            duplex: 'half',
            signal: request.request.signal,
            // geo
            // ip
            // nextConfig
            // body can not be passed if request was aborted
            // or we get a Request body was disturbed error
            ...request.request.signal.aborted ? {} : {
                body
            }
        });
    }
} //# sourceMappingURL=next-request.js.map
}),
"[project]/node_modules/next/dist/esm/server/client-component-renderer-logger.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// Combined load times for loading client components
__turbopack_context__.s({
    "getClientComponentLoaderMetrics": ()=>getClientComponentLoaderMetrics,
    "wrapClientComponentLoader": ()=>wrapClientComponentLoader
});
let clientComponentLoadStart = 0;
let clientComponentLoadTimes = 0;
let clientComponentLoadCount = 0;
function wrapClientComponentLoader(ComponentMod) {
    if (!('performance' in globalThis)) {
        return ComponentMod.__next_app__;
    }
    return {
        require: (...args)=>{
            const startTime = performance.now();
            if (clientComponentLoadStart === 0) {
                clientComponentLoadStart = startTime;
            }
            try {
                clientComponentLoadCount += 1;
                return ComponentMod.__next_app__.require(...args);
            } finally{
                clientComponentLoadTimes += performance.now() - startTime;
            }
        },
        loadChunk: (...args)=>{
            const startTime = performance.now();
            const result = ComponentMod.__next_app__.loadChunk(...args);
            // Avoid wrapping `loadChunk`'s result in an extra promise in case something like React depends on its identity.
            // We only need to know when it's settled.
            result.finally(()=>{
                clientComponentLoadTimes += performance.now() - startTime;
            });
            return result;
        }
    };
}
function getClientComponentLoaderMetrics(options = {}) {
    const metrics = clientComponentLoadStart === 0 ? undefined : {
        clientComponentLoadStart,
        clientComponentLoadTimes,
        clientComponentLoadCount
    };
    if (options.reset) {
        clientComponentLoadStart = 0;
        clientComponentLoadTimes = 0;
        clientComponentLoadCount = 0;
    }
    return metrics;
} //# sourceMappingURL=client-component-renderer-logger.js.map
}),
"[project]/node_modules/next/dist/esm/server/pipe-readable.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "isAbortError": ()=>isAbortError,
    "pipeToNodeResponse": ()=>pipeToNodeResponse
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$spec$2d$extension$2f$adapters$2f$next$2d$request$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/web/spec-extension/adapters/next-request.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$detached$2d$promise$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/detached-promise.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$tracer$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/lib/trace/tracer.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/lib/trace/constants.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$client$2d$component$2d$renderer$2d$logger$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/client-component-renderer-logger.js [app-rsc] (ecmascript)");
;
;
;
;
;
function isAbortError(e) {
    return (e == null ? void 0 : e.name) === 'AbortError' || (e == null ? void 0 : e.name) === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$spec$2d$extension$2f$adapters$2f$next$2d$request$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ResponseAbortedName"];
}
function createWriterFromResponse(res, waitUntilForEnd) {
    let started = false;
    // Create a promise that will resolve once the response has drained. See
    // https://nodejs.org/api/stream.html#stream_event_drain
    let drained = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$detached$2d$promise$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["DetachedPromise"]();
    function onDrain() {
        drained.resolve();
    }
    res.on('drain', onDrain);
    // If the finish event fires, it means we shouldn't block and wait for the
    // drain event.
    res.once('close', ()=>{
        res.off('drain', onDrain);
        drained.resolve();
    });
    // Create a promise that will resolve once the response has finished. See
    // https://nodejs.org/api/http.html#event-finish_1
    const finished = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$detached$2d$promise$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["DetachedPromise"]();
    res.once('finish', ()=>{
        finished.resolve();
    });
    // Create a writable stream that will write to the response.
    return new WritableStream({
        write: async (chunk)=>{
            // You'd think we'd want to use `start` instead of placing this in `write`
            // but this ensures that we don't actually flush the headers until we've
            // started writing chunks.
            if (!started) {
                started = true;
                if ('performance' in globalThis && process.env.NEXT_OTEL_PERFORMANCE_PREFIX) {
                    const metrics = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$client$2d$component$2d$renderer$2d$logger$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getClientComponentLoaderMetrics"])();
                    if (metrics) {
                        performance.measure(`${process.env.NEXT_OTEL_PERFORMANCE_PREFIX}:next-client-component-loading`, {
                            start: metrics.clientComponentLoadStart,
                            end: metrics.clientComponentLoadStart + metrics.clientComponentLoadTimes
                        });
                    }
                }
                res.flushHeaders();
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$tracer$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getTracer"])().trace(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["NextNodeServerSpan"].startResponse, {
                    spanName: 'start response'
                }, ()=>undefined);
            }
            try {
                const ok = res.write(chunk);
                // Added by the `compression` middleware, this is a function that will
                // flush the partially-compressed response to the client.
                if ('flush' in res && typeof res.flush === 'function') {
                    res.flush();
                }
                // If the write returns false, it means there's some backpressure, so
                // wait until it's streamed before continuing.
                if (!ok) {
                    await drained.promise;
                    // Reset the drained promise so that we can wait for the next drain event.
                    drained = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$detached$2d$promise$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["DetachedPromise"]();
                }
            } catch (err) {
                res.end();
                throw Object.defineProperty(new Error('failed to write chunk to response', {
                    cause: err
                }), "__NEXT_ERROR_CODE", {
                    value: "E321",
                    enumerable: false,
                    configurable: true
                });
            }
        },
        abort: (err)=>{
            if (res.writableFinished) return;
            res.destroy(err);
        },
        close: async ()=>{
            // if a waitUntil promise was passed, wait for it to resolve before
            // ending the response.
            if (waitUntilForEnd) {
                await waitUntilForEnd;
            }
            if (res.writableFinished) return;
            res.end();
            return finished.promise;
        }
    });
}
async function pipeToNodeResponse(readable, res, waitUntilForEnd) {
    try {
        // If the response has already errored, then just return now.
        const { errored, destroyed } = res;
        if (errored || destroyed) return;
        // Create a new AbortController so that we can abort the readable if the
        // client disconnects.
        const controller = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$spec$2d$extension$2f$adapters$2f$next$2d$request$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createAbortController"])(res);
        const writer = createWriterFromResponse(res, waitUntilForEnd);
        await readable.pipeTo(writer, {
            signal: controller.signal
        });
    } catch (err) {
        // If this isn't related to an abort error, re-throw it.
        if (isAbortError(err)) return;
        throw Object.defineProperty(new Error('failed to pipe response', {
            cause: err
        }), "__NEXT_ERROR_CODE", {
            value: "E180",
            enumerable: false,
            configurable: true
        });
    }
} //# sourceMappingURL=pipe-readable.js.map
}),
"[project]/node_modules/next/dist/esm/shared/lib/lazy-dynamic/bailout-to-csr.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// This has to be a shared module which is shared between client component error boundary and dynamic component
__turbopack_context__.s({
    "BailoutToCSRError": ()=>BailoutToCSRError,
    "isBailoutToCSRError": ()=>isBailoutToCSRError
});
const BAILOUT_TO_CSR = 'BAILOUT_TO_CLIENT_SIDE_RENDERING';
class BailoutToCSRError extends Error {
    constructor(reason){
        super("Bail out to client-side rendering: " + reason), this.reason = reason, this.digest = BAILOUT_TO_CSR;
    }
}
function isBailoutToCSRError(err) {
    if (typeof err !== 'object' || err === null || !('digest' in err)) {
        return false;
    }
    return err.digest === BAILOUT_TO_CSR;
} //# sourceMappingURL=bailout-to-csr.js.map
}),
"[project]/node_modules/next/dist/esm/client/components/redirect-status-code.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "RedirectStatusCode": ()=>RedirectStatusCode
});
var RedirectStatusCode = /*#__PURE__*/ function(RedirectStatusCode) {
    RedirectStatusCode[RedirectStatusCode["SeeOther"] = 303] = "SeeOther";
    RedirectStatusCode[RedirectStatusCode["TemporaryRedirect"] = 307] = "TemporaryRedirect";
    RedirectStatusCode[RedirectStatusCode["PermanentRedirect"] = 308] = "PermanentRedirect";
    return RedirectStatusCode;
}({}); //# sourceMappingURL=redirect-status-code.js.map
}),
"[project]/node_modules/next/dist/esm/client/components/redirect-error.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "REDIRECT_ERROR_CODE": ()=>REDIRECT_ERROR_CODE,
    "RedirectType": ()=>RedirectType,
    "isRedirectError": ()=>isRedirectError
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$redirect$2d$status$2d$code$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/client/components/redirect-status-code.js [app-rsc] (ecmascript)");
;
const REDIRECT_ERROR_CODE = 'NEXT_REDIRECT';
var RedirectType = /*#__PURE__*/ function(RedirectType) {
    RedirectType["push"] = "push";
    RedirectType["replace"] = "replace";
    return RedirectType;
}({});
function isRedirectError(error) {
    if (typeof error !== 'object' || error === null || !('digest' in error) || typeof error.digest !== 'string') {
        return false;
    }
    const digest = error.digest.split(';');
    const [errorCode, type] = digest;
    const destination = digest.slice(2, -2).join(';');
    const status = digest.at(-2);
    const statusCode = Number(status);
    return errorCode === REDIRECT_ERROR_CODE && (type === 'replace' || type === 'push') && typeof destination === 'string' && !isNaN(statusCode) && statusCode in __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$redirect$2d$status$2d$code$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["RedirectStatusCode"];
} //# sourceMappingURL=redirect-error.js.map
}),
"[project]/node_modules/next/dist/esm/client/components/is-next-router-error.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "isNextRouterError": ()=>isNextRouterError
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$http$2d$access$2d$fallback$2f$http$2d$access$2d$fallback$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/client/components/http-access-fallback/http-access-fallback.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$redirect$2d$error$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/client/components/redirect-error.js [app-rsc] (ecmascript)");
;
;
function isNextRouterError(error) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$redirect$2d$error$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isRedirectError"])(error) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$http$2d$access$2d$fallback$2f$http$2d$access$2d$fallback$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isHTTPAccessFallbackError"])(error);
} //# sourceMappingURL=is-next-router-error.js.map
}),
"[project]/node_modules/next/dist/esm/shared/lib/is-plain-object.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "getObjectClassLabel": ()=>getObjectClassLabel,
    "isPlainObject": ()=>isPlainObject
});
function getObjectClassLabel(value) {
    return Object.prototype.toString.call(value);
}
function isPlainObject(value) {
    if (getObjectClassLabel(value) !== '[object Object]') {
        return false;
    }
    const prototype = Object.getPrototypeOf(value);
    /**
   * this used to be previously:
   *
   * `return prototype === null || prototype === Object.prototype`
   *
   * but Edge Runtime expose Object from vm, being that kind of type-checking wrongly fail.
   *
   * It was changed to the current implementation since it's resilient to serialization.
   */ return prototype === null || prototype.hasOwnProperty('isPrototypeOf');
} //# sourceMappingURL=is-plain-object.js.map
}),
"[project]/node_modules/next/dist/esm/lib/is-error.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>isError,
    "getProperError": ()=>getProperError
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$is$2d$plain$2d$object$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/is-plain-object.js [app-rsc] (ecmascript)");
;
function isError(err) {
    return typeof err === 'object' && err !== null && 'name' in err && 'message' in err;
}
function safeStringify(obj) {
    const seen = new WeakSet();
    return JSON.stringify(obj, (_key, value)=>{
        // If value is an object and already seen, replace with "[Circular]"
        if (typeof value === 'object' && value !== null) {
            if (seen.has(value)) {
                return '[Circular]';
            }
            seen.add(value);
        }
        return value;
    });
}
function getProperError(err) {
    if (isError(err)) {
        return err;
    }
    if ("TURBOPACK compile-time truthy", 1) {
        // provide better error for case where `throw undefined`
        // is called in development
        if (typeof err === 'undefined') {
            return Object.defineProperty(new Error('An undefined error was thrown, ' + 'see here for more info: https://nextjs.org/docs/messages/threw-undefined'), "__NEXT_ERROR_CODE", {
                value: "E98",
                enumerable: false,
                configurable: true
            });
        }
        if (err === null) {
            return Object.defineProperty(new Error('A null error was thrown, ' + 'see here for more info: https://nextjs.org/docs/messages/threw-undefined'), "__NEXT_ERROR_CODE", {
                value: "E336",
                enumerable: false,
                configurable: true
            });
        }
    }
    return Object.defineProperty(new Error((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$is$2d$plain$2d$object$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isPlainObject"])(err) ? safeStringify(err) : err + ''), "__NEXT_ERROR_CODE", {
        value: "E394",
        enumerable: false,
        configurable: true
    });
} //# sourceMappingURL=is-error.js.map
}),
"[project]/node_modules/next/dist/esm/lib/error-telemetry-utils.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "createDigestWithErrorCode": ()=>createDigestWithErrorCode,
    "extractNextErrorCode": ()=>extractNextErrorCode
});
const ERROR_CODE_DELIMITER = '@';
const createDigestWithErrorCode = (thrownValue, originalDigest)=>{
    if (typeof thrownValue === 'object' && thrownValue !== null && '__NEXT_ERROR_CODE' in thrownValue) {
        return `${originalDigest}${ERROR_CODE_DELIMITER}${thrownValue.__NEXT_ERROR_CODE}`;
    }
    return originalDigest;
};
const extractNextErrorCode = (error)=>{
    if (typeof error === 'object' && error !== null && '__NEXT_ERROR_CODE' in error && typeof error.__NEXT_ERROR_CODE === 'string') {
        return error.__NEXT_ERROR_CODE;
    }
    if (typeof error === 'object' && error !== null && 'digest' in error && typeof error.digest === 'string') {
        const segments = error.digest.split(ERROR_CODE_DELIMITER);
        const errorCode = segments.find((segment)=>segment.startsWith('E'));
        return errorCode;
    }
    return undefined;
}; //# sourceMappingURL=error-telemetry-utils.js.map
}),
"[project]/node_modules/next/dist/esm/server/app-render/react-large-shell-error.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// TODO: isWellKnownError -> isNextInternalError
// isReactLargeShellError -> isWarning
__turbopack_context__.s({
    "isReactLargeShellError": ()=>isReactLargeShellError
});
function isReactLargeShellError(error) {
    return typeof error === 'object' && error !== null && 'message' in error && typeof error.message === 'string' && error.message.startsWith('This rendered a large document (>');
} //# sourceMappingURL=react-large-shell-error.js.map
}),
"[project]/node_modules/next/dist/esm/server/app-render/create-error-handler.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "createFlightReactServerErrorHandler": ()=>createFlightReactServerErrorHandler,
    "createHTMLErrorHandler": ()=>createHTMLErrorHandler,
    "createHTMLReactServerErrorHandler": ()=>createHTMLReactServerErrorHandler,
    "getDigestForWellKnownError": ()=>getDigestForWellKnownError,
    "isUserLandError": ()=>isUserLandError
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$string$2d$hash$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/string-hash/index.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$format$2d$server$2d$error$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/format-server-error.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$tracer$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/lib/trace/tracer.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$pipe$2d$readable$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/pipe-readable.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$lazy$2d$dynamic$2f$bailout$2d$to$2d$csr$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/lazy-dynamic/bailout-to-csr.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$hooks$2d$server$2d$context$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/client/components/hooks-server-context.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$is$2d$next$2d$router$2d$error$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/client/components/is-next-router-error.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$dynamic$2d$rendering$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/app-render/dynamic-rendering.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$is$2d$error$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/is-error.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$error$2d$telemetry$2d$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/error-telemetry-utils.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$react$2d$large$2d$shell$2d$error$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/app-render/react-large-shell-error.js [app-rsc] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
function getDigestForWellKnownError(error) {
    // If we're bailing out to CSR, we don't need to log the error.
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$lazy$2d$dynamic$2f$bailout$2d$to$2d$csr$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isBailoutToCSRError"])(error)) return error.digest;
    // If this is a navigation error, we don't need to log the error.
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$is$2d$next$2d$router$2d$error$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isNextRouterError"])(error)) return error.digest;
    // If this error occurs, we know that we should be stopping the static
    // render. This is only thrown in static generation when PPR is not enabled,
    // which causes the whole page to be marked as dynamic. We don't need to
    // tell the user about this error, as it's not actionable.
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$hooks$2d$server$2d$context$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isDynamicServerError"])(error)) return error.digest;
    // If this is a prerender interrupted error, we don't need to log the error.
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$dynamic$2d$rendering$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isPrerenderInterruptedError"])(error)) return error.digest;
    return undefined;
}
function createFlightReactServerErrorHandler(shouldFormatError, onReactServerRenderError) {
    return (thrownValue)=>{
        if (typeof thrownValue === 'string') {
            // TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$string$2d$hash$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"])(thrownValue).toString();
        }
        // If the response was closed, we don't need to log the error.
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$pipe$2d$readable$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isAbortError"])(thrownValue)) return;
        const digest = getDigestForWellKnownError(thrownValue);
        if (digest) {
            return digest;
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$react$2d$large$2d$shell$2d$error$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isReactLargeShellError"])(thrownValue)) {
            // TODO: Aggregate
            console.error(thrownValue);
            return undefined;
        }
        const err = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$is$2d$error$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getProperError"])(thrownValue);
        // If the error already has a digest, respect the original digest,
        // so it won't get re-generated into another new error.
        if (!err.digest) {
            // TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.
            err.digest = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$string$2d$hash$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"])(err.message + err.stack || '').toString();
        }
        // Format server errors in development to add more helpful error messages
        if (shouldFormatError) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$format$2d$server$2d$error$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["formatServerError"])(err);
        }
        // Record exception in an active span, if available.
        const span = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$tracer$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getTracer"])().getActiveScopeSpan();
        if (span) {
            span.recordException(err);
            span.setStatus({
                code: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$tracer$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["SpanStatusCode"].ERROR,
                message: err.message
            });
        }
        onReactServerRenderError(err);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$error$2d$telemetry$2d$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createDigestWithErrorCode"])(thrownValue, err.digest);
    };
}
function createHTMLReactServerErrorHandler(shouldFormatError, isNextExport, reactServerErrors, silenceLogger, onReactServerRenderError) {
    return (thrownValue)=>{
        var _err_message;
        if (typeof thrownValue === 'string') {
            // TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$string$2d$hash$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"])(thrownValue).toString();
        }
        // If the response was closed, we don't need to log the error.
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$pipe$2d$readable$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isAbortError"])(thrownValue)) return;
        const digest = getDigestForWellKnownError(thrownValue);
        if (digest) {
            return digest;
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$react$2d$large$2d$shell$2d$error$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isReactLargeShellError"])(thrownValue)) {
            // TODO: Aggregate
            console.error(thrownValue);
            return undefined;
        }
        const err = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$is$2d$error$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getProperError"])(thrownValue);
        // If the error already has a digest, respect the original digest,
        // so it won't get re-generated into another new error.
        if (!err.digest) {
            // TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.
            err.digest = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$string$2d$hash$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"])(err.message + (err.stack || '')).toString();
        }
        // @TODO by putting this here and not at the top it is possible that
        // we don't error the build in places we actually expect to
        if (!reactServerErrors.has(err.digest)) {
            reactServerErrors.set(err.digest, err);
        }
        // Format server errors in development to add more helpful error messages
        if (shouldFormatError) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$format$2d$server$2d$error$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["formatServerError"])(err);
        }
        // Don't log the suppressed error during export
        if (!(isNextExport && (err == null ? void 0 : (_err_message = err.message) == null ? void 0 : _err_message.includes('The specific message is omitted in production builds to avoid leaking sensitive details.')))) {
            // Record exception in an active span, if available.
            const span = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$tracer$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getTracer"])().getActiveScopeSpan();
            if (span) {
                span.recordException(err);
                span.setStatus({
                    code: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$tracer$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["SpanStatusCode"].ERROR,
                    message: err.message
                });
            }
            if (!silenceLogger) {
                onReactServerRenderError == null ? void 0 : onReactServerRenderError(err);
            }
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$error$2d$telemetry$2d$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createDigestWithErrorCode"])(thrownValue, err.digest);
    };
}
function createHTMLErrorHandler(shouldFormatError, isNextExport, reactServerErrors, allCapturedErrors, silenceLogger, onHTMLRenderSSRError) {
    return (thrownValue, errorInfo)=>{
        var _err_message;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$react$2d$large$2d$shell$2d$error$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isReactLargeShellError"])(thrownValue)) {
            // TODO: Aggregate
            console.error(thrownValue);
            return undefined;
        }
        let isSSRError = true;
        allCapturedErrors.push(thrownValue);
        // If the response was closed, we don't need to log the error.
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$pipe$2d$readable$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isAbortError"])(thrownValue)) return;
        const digest = getDigestForWellKnownError(thrownValue);
        if (digest) {
            return digest;
        }
        const err = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$is$2d$error$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getProperError"])(thrownValue);
        // If the error already has a digest, respect the original digest,
        // so it won't get re-generated into another new error.
        if (err.digest) {
            if (reactServerErrors.has(err.digest)) {
                // This error is likely an obfuscated error from react-server.
                // We recover the original error here.
                thrownValue = reactServerErrors.get(err.digest);
                isSSRError = false;
            } else {
            // The error is not from react-server but has a digest
            // from other means so we don't need to produce a new one
            }
        } else {
            err.digest = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$string$2d$hash$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"])(err.message + ((errorInfo == null ? void 0 : errorInfo.componentStack) || err.stack || '')).toString();
        }
        // Format server errors in development to add more helpful error messages
        if (shouldFormatError) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$format$2d$server$2d$error$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["formatServerError"])(err);
        }
        // Don't log the suppressed error during export
        if (!(isNextExport && (err == null ? void 0 : (_err_message = err.message) == null ? void 0 : _err_message.includes('The specific message is omitted in production builds to avoid leaking sensitive details.')))) {
            // Record exception in an active span, if available.
            const span = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$tracer$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getTracer"])().getActiveScopeSpan();
            if (span) {
                span.recordException(err);
                span.setStatus({
                    code: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$tracer$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["SpanStatusCode"].ERROR,
                    message: err.message
                });
            }
            if (!silenceLogger && // HTML errors contain RSC errors as well, filter them out before reporting
            isSSRError) {
                onHTMLRenderSSRError(err, errorInfo);
            }
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$error$2d$telemetry$2d$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createDigestWithErrorCode"])(thrownValue, err.digest);
    };
}
function isUserLandError(err) {
    return !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$pipe$2d$readable$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isAbortError"])(err) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$lazy$2d$dynamic$2f$bailout$2d$to$2d$csr$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isBailoutToCSRError"])(err) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$is$2d$next$2d$router$2d$error$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isNextRouterError"])(err);
} //# sourceMappingURL=create-error-handler.js.map
}),
"[project]/node_modules/next/dist/esm/server/lib/source-maps.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "devirtualizeReactServerURL": ()=>devirtualizeReactServerURL,
    "filterStackFrameDEV": ()=>filterStackFrameDEV,
    "findApplicableSourceMapPayload": ()=>findApplicableSourceMapPayload,
    "ignoreListAnonymousStackFramesIfSandwiched": ()=>ignoreListAnonymousStackFramesIfSandwiched,
    "sourceMapIgnoreListsEverything": ()=>sourceMapIgnoreListsEverything
});
var _process_versions_node;
function noSourceMap() {
    return undefined;
}
// Edge runtime does not implement `module`
const nativeFindSourceMap = ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : __turbopack_context__.r("[externals]/module [external] (module, cjs)").findSourceMap;
function sourceMapIgnoreListsEverything(sourceMap) {
    return sourceMap.ignoreList !== undefined && sourceMap.sources.length === sourceMap.ignoreList.length;
}
function findApplicableSourceMapPayload(line0, column0, payload) {
    if ('sections' in payload) {
        if (payload.sections.length === 0) {
            return undefined;
        }
        // Sections must not overlap and must be sorted: https://tc39.es/source-map/#section-object
        // Therefore the last section that has an offset less than or equal to the frame is the applicable one.
        const sections = payload.sections;
        let left = 0;
        let right = sections.length - 1;
        let result = null;
        while(left <= right){
            // fast Math.floor
            const middle = ~~((left + right) / 2);
            const section = sections[middle];
            const offset = section.offset;
            if (offset.line < line0 || offset.line === line0 && offset.column <= column0) {
                result = section;
                left = middle + 1;
            } else {
                right = middle - 1;
            }
        }
        return result === null ? undefined : result.map;
    } else {
        return payload;
    }
}
const didWarnAboutInvalidSourceMapDEV = new Set();
const findSourceMap = ("TURBOPACK compile-time value", "nodejs") === 'nodejs' && ((_process_versions_node = process.versions.node) == null ? void 0 : _process_versions_node.startsWith('18')) ? noSourceMap : nativeFindSourceMap;
function filterStackFrameDEV(sourceURL, functionName, line1, column1) {
    if (sourceURL === '') {
        // The default implementation filters out <anonymous> stack frames
        // but we want to retain them because current Server Components and
        // built-in Components in parent stacks don't have source location.
        // Filter out frames that show up in Promises to get good names in React's
        // Server Request track until we come up with a better heuristic.
        return functionName !== 'new Promise' && functionName !== 'Promise.then' && functionName !== 'Promise.catch' && functionName !== 'Promise.finally' && functionName !== 'Function.withResolvers' && functionName !== 'Function.all' && functionName !== 'Function.allSettled';
    }
    if (sourceURL.startsWith('node:') || sourceURL.includes('node_modules')) {
        return false;
    }
    try {
        // Node.js loads source maps eagerly so this call is cheap.
        // TODO: ESM sourcemaps are O(1) but CommonJS sourcemaps are O(Number of CJS modules).
        // Make sure this doesn't adversely affect performance when CJS is used by Next.js.
        const sourceMap = findSourceMap(sourceURL);
        if (sourceMap === undefined) {
            // No source map assoicated.
            // TODO: Node.js types should reflect that `findSourceMap` can return `undefined`.
            return true;
        }
        const sourceMapPayload = findApplicableSourceMapPayload(line1 - 1, column1 - 1, sourceMap.payload);
        if (sourceMapPayload === undefined) {
            // No source map section applicable to the frame.
            return true;
        }
        return !sourceMapIgnoreListsEverything(sourceMapPayload);
    } catch (cause) {
        if ("TURBOPACK compile-time truthy", 1) {
            // TODO: Share cache with patch-error-inspect
            if (!didWarnAboutInvalidSourceMapDEV.has(sourceURL)) {
                didWarnAboutInvalidSourceMapDEV.add(sourceURL);
                // We should not log an actual error instance here because that will re-enter
                // this codepath during error inspection and could lead to infinite recursion.
                console.error(`${sourceURL}: Invalid source map. Only conformant source maps can be used to filter stack frames. Cause: ${cause}`);
            }
        }
        return true;
    }
}
function devirtualizeReactServerURL(sourceURL) {
    if (sourceURL.startsWith('rsc://React/')) {
        // rsc://React/Server/file://<filename>?42 => file://<filename>
        const envIdx = sourceURL.indexOf('/', 'rsc://React/'.length);
        const suffixIdx = sourceURL.lastIndexOf('?');
        if (envIdx > -1 && suffixIdx > -1) {
            return decodeURI(sourceURL.slice(envIdx + 1, suffixIdx));
        }
    }
    return sourceURL;
}
function isAnonymousFrameLikelyJSNative(methodName) {
    // Anonymous frames can also be produced in React parent stacks either from
    // host components or Server Components. We don't want to ignore those.
    // This could hide user-space methods that are named like native JS methods but
    // should you really do that?
    return methodName.startsWith('JSON.') || // E.g. Promise.withResolves
    methodName.startsWith('Function.') || // various JS built-ins
    methodName.startsWith('Promise.') || methodName.startsWith('Array.') || methodName.startsWith('Set.') || methodName.startsWith('Map.');
}
function ignoreListAnonymousStackFramesIfSandwiched(frames, isAnonymousFrame, isIgnoredFrame, getMethodName, /** only passes frames for which `isAnonymousFrame` and their method is a native JS method or `isIgnoredFrame` return true */ ignoreFrame) {
    for(let i = 1; i < frames.length; i++){
        const currentFrame = frames[i];
        if (!(isAnonymousFrame(currentFrame) && isAnonymousFrameLikelyJSNative(getMethodName(currentFrame)))) {
            continue;
        }
        const previousFrameIsIgnored = isIgnoredFrame(frames[i - 1]);
        if (previousFrameIsIgnored && i < frames.length - 1) {
            let ignoreSandwich = false;
            let j = i + 1;
            for(j; j < frames.length; j++){
                const nextFrame = frames[j];
                const nextFrameIsAnonymous = isAnonymousFrame(nextFrame) && isAnonymousFrameLikelyJSNative(getMethodName(nextFrame));
                if (nextFrameIsAnonymous) {
                    continue;
                }
                const nextFrameIsIgnored = isIgnoredFrame(nextFrame);
                if (nextFrameIsIgnored) {
                    ignoreSandwich = true;
                    break;
                }
            }
            if (ignoreSandwich) {
                for(i; i < j; i++){
                    ignoreFrame(frames[i]);
                }
            }
        }
    }
} //# sourceMappingURL=source-maps.js.map
}),
"[project]/node_modules/next/dist/esm/server/app-render/collect-segment-data.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "collectSegmentData": ()=>collectSegmentData
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-jsx-runtime.js [app-rsc] (ecmascript)");
// eslint-disable-next-line import/no-extraneous-dependencies
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$server$2d$dom$2d$turbopack$2f$client$2e$node$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react-server-dom-turbopack/client.node.js [app-rsc] (ecmascript)");
// eslint-disable-next-line import/no-extraneous-dependencies
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$server$2d$dom$2d$turbopack$2d$static$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-server-dom-turbopack-static.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$node$2d$web$2d$streams$2d$helper$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/stream-utils/node-web-streams-helper.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$scheduler$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/scheduler.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$segment$2d$cache$2f$segment$2d$value$2d$encoding$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/segment-cache/segment-value-encoding.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$create$2d$error$2d$handler$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/app-render/create-error-handler.js [app-rsc] (ecmascript)");
;
;
;
;
;
;
;
const filterStackFrame = ("TURBOPACK compile-time truthy", 1) ? __turbopack_context__.r("[project]/node_modules/next/dist/esm/server/lib/source-maps.js [app-rsc] (ecmascript)").filterStackFrameDEV : "TURBOPACK unreachable";
function onSegmentPrerenderError(error) {
    const digest = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$create$2d$error$2d$handler$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getDigestForWellKnownError"])(error);
    if (digest) {
        return digest;
    }
// We don't need to log the errors because we would have already done that
// when generating the original Flight stream for the whole page.
}
async function collectSegmentData(fullPageDataBuffer, staleTime, clientModules, serverConsumerManifest, fallbackRouteParams) {
    // Traverse the router tree and generate a prefetch response for each segment.
    // A mutable map to collect the results as we traverse the route tree.
    const resultMap = new Map();
    // Before we start, warm up the module cache by decoding the page data once.
    // Then we can assume that any remaining async tasks that occur the next time
    // are due to hanging promises caused by dynamic data access. Note we only
    // have to do this once per page, not per individual segment.
    //
    try {
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$server$2d$dom$2d$turbopack$2f$client$2e$node$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createFromReadableStream"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$node$2d$web$2d$streams$2d$helper$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["streamFromBuffer"])(fullPageDataBuffer), {
            serverConsumerManifest
        });
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$scheduler$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["waitAtLeastOneReactRenderTask"])();
    } catch  {}
    // Create an abort controller that we'll use to stop the stream.
    const abortController = new AbortController();
    const onCompletedProcessingRouteTree = async ()=>{
        // Since all we're doing is decoding and re-encoding a cached prerender, if
        // serializing the stream takes longer than a microtask, it must because of
        // hanging promises caused by dynamic data.
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$scheduler$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["waitAtLeastOneReactRenderTask"])();
        abortController.abort();
    };
    // Generate a stream for the route tree prefetch. While we're walking the
    // tree, we'll also spawn additional tasks to generate the segment prefetches.
    // The promises for these tasks are pushed to a mutable array that we will
    // await once the route tree is fully rendered.
    const segmentTasks = [];
    const { prelude: treeStream } = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$server$2d$dom$2d$turbopack$2d$static$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["unstable_prerender"])(// we need to use a component so that when we decode the original stream
    // inside of it, the side effects are transferred to the new stream.
    // @ts-expect-error
    /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["jsx"])(PrefetchTreeData, {
        fullPageDataBuffer: fullPageDataBuffer,
        fallbackRouteParams: fallbackRouteParams,
        serverConsumerManifest: serverConsumerManifest,
        clientModules: clientModules,
        staleTime: staleTime,
        segmentTasks: segmentTasks,
        onCompletedProcessingRouteTree: onCompletedProcessingRouteTree
    }), clientModules, {
        filterStackFrame,
        signal: abortController.signal,
        onError: onSegmentPrerenderError
    });
    // Write the route tree to a special `/_tree` segment.
    const treeBuffer = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$node$2d$web$2d$streams$2d$helper$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["streamToBuffer"])(treeStream);
    resultMap.set('/_tree', treeBuffer);
    // Now that we've finished rendering the route tree, all the segment tasks
    // should have been spawned. Await them in parallel and write the segment
    // prefetches to the result map.
    for (const [segmentPath, buffer] of (await Promise.all(segmentTasks))){
        resultMap.set(segmentPath, buffer);
    }
    return resultMap;
}
async function PrefetchTreeData({ fullPageDataBuffer, fallbackRouteParams, serverConsumerManifest, clientModules, staleTime, segmentTasks, onCompletedProcessingRouteTree }) {
    // We're currently rendering a Flight response for the route tree prefetch.
    // Inside this component, decode the Flight stream for the whole page. This is
    // a hack to transfer the side effects from the original Flight stream (e.g.
    // Float preloads) onto the Flight stream for the tree prefetch.
    // TODO: React needs a better way to do this. Needed for Server Actions, too.
    const initialRSCPayload = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$server$2d$dom$2d$turbopack$2f$client$2e$node$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createFromReadableStream"])(createUnclosingPrefetchStream((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$node$2d$web$2d$streams$2d$helper$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["streamFromBuffer"])(fullPageDataBuffer)), {
        serverConsumerManifest
    });
    const buildId = initialRSCPayload.b;
    // FlightDataPath is an unsound type, hence the additional checks.
    const flightDataPaths = initialRSCPayload.f;
    if (flightDataPaths.length !== 1 && flightDataPaths[0].length !== 3) {
        console.error('Internal Next.js error: InitialRSCPayload does not match the expected ' + 'shape for a prerendered page during segment prefetch generation.');
        return null;
    }
    const flightRouterState = flightDataPaths[0][0];
    const seedData = flightDataPaths[0][1];
    const head = flightDataPaths[0][2];
    // Compute the route metadata tree by traversing the FlightRouterState. As we
    // walk the tree, we will also spawn a task to produce a prefetch response for
    // each segment.
    const tree = collectSegmentDataImpl(flightRouterState, buildId, seedData, fallbackRouteParams, clientModules, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$segment$2d$cache$2f$segment$2d$value$2d$encoding$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ROOT_SEGMENT_KEY"], segmentTasks);
    const isHeadPartial = await isPartialRSCData(head, clientModules);
    // Notify the abort controller that we're done processing the route tree.
    // Anything async that happens after this point must be due to hanging
    // promises in the original stream.
    onCompletedProcessingRouteTree();
    // Render the route tree to a special `/_tree` segment.
    const treePrefetch = {
        buildId,
        tree,
        head,
        isHeadPartial,
        staleTime
    };
    return treePrefetch;
}
function collectSegmentDataImpl(route, buildId, seedData, fallbackRouteParams, clientModules, key, segmentTasks) {
    // Metadata about the segment. Sent as part of the tree prefetch. Null if
    // there are no children.
    let slotMetadata = null;
    const children = route[1];
    const seedDataChildren = seedData !== null ? seedData[2] : null;
    for(const parallelRouteKey in children){
        const childRoute = children[parallelRouteKey];
        const childSegment = childRoute[0];
        const childSeedData = seedDataChildren !== null ? seedDataChildren[parallelRouteKey] : null;
        const childKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$segment$2d$cache$2f$segment$2d$value$2d$encoding$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["encodeChildSegmentKey"])(key, parallelRouteKey, Array.isArray(childSegment) && fallbackRouteParams !== null ? encodeSegmentWithPossibleFallbackParam(childSegment, fallbackRouteParams) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$segment$2d$cache$2f$segment$2d$value$2d$encoding$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["encodeSegment"])(childSegment));
        const childTree = collectSegmentDataImpl(childRoute, buildId, childSeedData, fallbackRouteParams, clientModules, childKey, segmentTasks);
        if (slotMetadata === null) {
            slotMetadata = {};
        }
        slotMetadata[parallelRouteKey] = childTree;
    }
    if (seedData !== null) {
        // Spawn a task to write the segment data to a new Flight stream.
        segmentTasks.push(// current task to escape the current rendering context.
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$scheduler$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["waitAtLeastOneReactRenderTask"])().then(()=>renderSegmentPrefetch(buildId, seedData, key, clientModules)));
    } else {
    // This segment does not have any seed data. Skip generating a prefetch
    // response for it. We'll still include it in the route tree, though.
    // TODO: We should encode in the route tree whether a segment is missing
    // so we don't attempt to fetch it for no reason. As of now this shouldn't
    // ever happen in practice, though.
    }
    // Metadata about the segment. Sent to the client as part of the
    // tree prefetch.
    return {
        segment: route[0],
        slots: slotMetadata,
        isRootLayout: route[4] === true
    };
}
function encodeSegmentWithPossibleFallbackParam(segment, fallbackRouteParams) {
    const name = segment[0];
    if (!fallbackRouteParams.has(name)) {
        // Normal case. No matching fallback parameter.
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$segment$2d$cache$2f$segment$2d$value$2d$encoding$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["encodeSegment"])(segment);
    }
    // This segment includes a fallback parameter. During prerendering, a random
    // placeholder value was used; however, for segment prefetches, we need the
    // segment path to be predictable so the server can create a rewrite for it.
    // So, replace the placeholder segment value with a "template" string,
    // e.g. `[name]`.
    // TODO: This will become a bit cleaner once remove route parameters from the
    // server response, and instead add them to the segment keys on the client.
    // Instead of a string replacement, like we do here, route params will always
    // be encoded in separate step from the rest of the segment, not just in the
    // case of fallback params.
    const encodedSegment = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$segment$2d$cache$2f$segment$2d$value$2d$encoding$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["encodeSegment"])(segment);
    const lastIndex = encodedSegment.lastIndexOf('$');
    const encodedFallbackSegment = // because non-simple characters (including [ and ]) trigger a base
    // 64 encoding.
    encodedSegment.substring(0, lastIndex + 1) + `[${name}]`;
    return encodedFallbackSegment;
}
async function renderSegmentPrefetch(buildId, seedData, key, clientModules) {
    // Render the segment data to a stream.
    // In the future, this is where we can include additional metadata, like the
    // stale time and cache tags.
    const rsc = seedData[1];
    const loading = seedData[3];
    const segmentPrefetch = {
        buildId,
        rsc,
        loading,
        isPartial: await isPartialRSCData(rsc, clientModules)
    };
    // Since all we're doing is decoding and re-encoding a cached prerender, if
    // it takes longer than a microtask, it must because of hanging promises
    // caused by dynamic data. Abort the stream at the end of the current task.
    const abortController = new AbortController();
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$scheduler$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["waitAtLeastOneReactRenderTask"])().then(()=>abortController.abort());
    const { prelude: segmentStream } = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$server$2d$dom$2d$turbopack$2d$static$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["unstable_prerender"])(segmentPrefetch, clientModules, {
        filterStackFrame,
        signal: abortController.signal,
        onError: onSegmentPrerenderError
    });
    const segmentBuffer = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$node$2d$web$2d$streams$2d$helper$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["streamToBuffer"])(segmentStream);
    if (key === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$segment$2d$cache$2f$segment$2d$value$2d$encoding$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ROOT_SEGMENT_KEY"]) {
        return [
            '/_index',
            segmentBuffer
        ];
    } else {
        return [
            key,
            segmentBuffer
        ];
    }
}
async function isPartialRSCData(rsc, clientModules) {
    // We can determine if a segment contains only partial data if it takes longer
    // than a task to encode, because dynamic data is encoded as an infinite
    // promise. We must do this in a separate Flight prerender from the one that
    // actually generates the prefetch stream because we need to include
    // `isPartial` in the stream itself.
    let isPartial = false;
    const abortController = new AbortController();
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$scheduler$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["waitAtLeastOneReactRenderTask"])().then(()=>{
        // If we haven't yet finished the outer task, then it must be because we
        // accessed dynamic data.
        isPartial = true;
        abortController.abort();
    });
    await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$server$2d$dom$2d$turbopack$2d$static$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["unstable_prerender"])(rsc, clientModules, {
        filterStackFrame,
        signal: abortController.signal,
        onError () {},
        onPostpone () {
            // If something postponed, i.e. when Dynamic IO is not enabled, we can
            // infer that the RSC data is partial.
            isPartial = true;
        }
    });
    return isPartial;
}
function createUnclosingPrefetchStream(originalFlightStream) {
    // When PPR is enabled, prefetch streams may contain references that never
    // resolve, because that's how we encode dynamic data access. In the decoded
    // object returned by the Flight client, these are reified into hanging
    // promises that suspend during render, which is effectively what we want.
    // The UI resolves when it switches to the dynamic data stream
    // (via useDeferredValue(dynamic, static)).
    //
    // However, the Flight implementation currently errors if the server closes
    // the response before all the references are resolved. As a cheat to work
    // around this, we wrap the original stream in a new stream that never closes,
    // and therefore doesn't error.
    const reader = originalFlightStream.getReader();
    return new ReadableStream({
        async pull (controller) {
            while(true){
                const { done, value } = await reader.read();
                if (!done) {
                    // Pass to the target stream and keep consuming the Flight response
                    // from the server.
                    controller.enqueue(value);
                    continue;
                }
                // The server stream has closed. Exit, but intentionally do not close
                // the target stream.
                return;
            }
        }
    });
} //# sourceMappingURL=collect-segment-data.js.map
}),
"[project]/node_modules/next/dist/esm/server/lib/clone-response.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * Clones a response by teeing the body so we can return two independent
 * ReadableStreams from it. This avoids the bug in the undici library around
 * response cloning.
 *
 * After cloning, the original response's body will be consumed and closed.
 *
 * @see https://github.com/vercel/next.js/pull/73274
 *
 * @param original - The original response to clone.
 * @returns A tuple containing two independent clones of the original response.
 */ __turbopack_context__.s({
    "cloneResponse": ()=>cloneResponse
});
function cloneResponse(original) {
    // If the response has no body, then we can just return the original response
    // twice because it's immutable.
    if (!original.body) {
        return [
            original,
            original
        ];
    }
    const [body1, body2] = original.body.tee();
    const cloned1 = new Response(body1, {
        status: original.status,
        statusText: original.statusText,
        headers: original.headers
    });
    Object.defineProperty(cloned1, 'url', {
        value: original.url,
        // How the original response.url behaves
        configurable: true,
        enumerable: true,
        writable: false
    });
    const cloned2 = new Response(body2, {
        status: original.status,
        statusText: original.statusText,
        headers: original.headers
    });
    Object.defineProperty(cloned2, 'url', {
        value: original.url,
        // How the original response.url behaves
        configurable: true,
        enumerable: true,
        writable: false
    });
    return [
        cloned1,
        cloned2
    ];
} //# sourceMappingURL=clone-response.js.map
}),
"[project]/node_modules/next/dist/esm/server/lib/dedupe-fetch.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * Based on https://github.com/facebook/react/blob/d4e78c42a94be027b4dc7ed2659a5fddfbf9bd4e/packages/react/src/ReactFetch.js
 */ __turbopack_context__.s({
    "createDedupeFetch": ()=>createDedupeFetch
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$clone$2d$response$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/lib/clone-response.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$invariant$2d$error$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/invariant-error.js [app-rsc] (ecmascript)");
;
;
;
const simpleCacheKey = '["GET",[],null,"follow",null,null,null,null]' // generateCacheKey(new Request('https://blank'));
;
function generateCacheKey(request) {
    // We pick the fields that goes into the key used to dedupe requests.
    // We don't include the `cache` field, because we end up using whatever
    // caching resulted from the first request.
    // Notably we currently don't consider non-standard (or future) options.
    // This might not be safe. TODO: warn for non-standard extensions differing.
    // IF YOU CHANGE THIS UPDATE THE simpleCacheKey ABOVE.
    return JSON.stringify([
        request.method,
        Array.from(request.headers.entries()),
        request.mode,
        request.redirect,
        request.credentials,
        request.referrer,
        request.referrerPolicy,
        request.integrity
    ]);
}
function createDedupeFetch(originalFetch) {
    const getCacheEntries = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["cache"]((url)=>[]);
    return function dedupeFetch(resource, options) {
        if (options && options.signal) {
            // If we're passed a signal, then we assume that
            // someone else controls the lifetime of this object and opts out of
            // caching. It's effectively the opt-out mechanism.
            // Ideally we should be able to check this on the Request but
            // it always gets initialized with its own signal so we don't
            // know if it's supposed to override - unless we also override the
            // Request constructor.
            return originalFetch(resource, options);
        }
        // Normalize the Request
        let url;
        let cacheKey;
        if (typeof resource === 'string' && !options) {
            // Fast path.
            cacheKey = simpleCacheKey;
            url = resource;
        } else {
            // Normalize the request.
            // if resource is not a string or a URL (its an instance of Request)
            // then do not instantiate a new Request but instead
            // reuse the request as to not disturb the body in the event it's a ReadableStream.
            const request = typeof resource === 'string' || resource instanceof URL ? new Request(resource, options) : resource;
            if (request.method !== 'GET' && request.method !== 'HEAD' || request.keepalive) {
                // We currently don't dedupe requests that might have side-effects. Those
                // have to be explicitly cached. We assume that the request doesn't have a
                // body if it's GET or HEAD.
                // keepalive gets treated the same as if you passed a custom cache signal.
                return originalFetch(resource, options);
            }
            cacheKey = generateCacheKey(request);
            url = request.url;
        }
        const cacheEntries = getCacheEntries(url);
        for(let i = 0, j = cacheEntries.length; i < j; i += 1){
            const [key, promise] = cacheEntries[i];
            if (key === cacheKey) {
                return promise.then(()=>{
                    const response = cacheEntries[i][2];
                    if (!response) throw Object.defineProperty(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$invariant$2d$error$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["InvariantError"]('No cached response'), "__NEXT_ERROR_CODE", {
                        value: "E579",
                        enumerable: false,
                        configurable: true
                    });
                    // We're cloning the response using this utility because there exists
                    // a bug in the undici library around response cloning. See the
                    // following pull request for more details:
                    // https://github.com/vercel/next.js/pull/73274
                    const [cloned1, cloned2] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$clone$2d$response$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["cloneResponse"])(response);
                    cacheEntries[i][2] = cloned2;
                    return cloned1;
                });
            }
        }
        // We pass the original arguments here in case normalizing the Request
        // doesn't include all the options in this environment.
        const promise = originalFetch(resource, options);
        const entry = [
            cacheKey,
            promise,
            null
        ];
        cacheEntries.push(entry);
        return promise.then((response)=>{
            // We're cloning the response using this utility because there exists
            // a bug in the undici library around response cloning. See the
            // following pull request for more details:
            // https://github.com/vercel/next.js/pull/73274
            const [cloned1, cloned2] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$clone$2d$response$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["cloneResponse"])(response);
            entry[2] = cloned2;
            return cloned1;
        });
    };
} //# sourceMappingURL=dedupe-fetch.js.map
}),
"[project]/node_modules/next/dist/esm/lib/batcher.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "Batcher": ()=>Batcher
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$detached$2d$promise$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/detached-promise.js [app-rsc] (ecmascript)");
;
class Batcher {
    constructor(cacheKeyFn, /**
     * A function that will be called to schedule the wrapped function to be
     * executed. This defaults to a function that will execute the function
     * immediately.
     */ schedulerFn = (fn)=>fn()){
        this.cacheKeyFn = cacheKeyFn;
        this.schedulerFn = schedulerFn;
        this.pending = new Map();
    }
    static create(options) {
        return new Batcher(options == null ? void 0 : options.cacheKeyFn, options == null ? void 0 : options.schedulerFn);
    }
    /**
   * Wraps a function in a promise that will be resolved or rejected only once
   * for a given key. This will allow multiple calls to the function to be
   * made, but only one will be executed at a time. The result of the first
   * call will be returned to all callers.
   *
   * @param key the key to use for the cache
   * @param fn the function to wrap
   * @returns a promise that resolves to the result of the function
   */ async batch(key, fn) {
        const cacheKey = this.cacheKeyFn ? await this.cacheKeyFn(key) : key;
        if (cacheKey === null) {
            return fn(cacheKey, Promise.resolve);
        }
        const pending = this.pending.get(cacheKey);
        if (pending) return pending;
        const { promise, resolve, reject } = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$detached$2d$promise$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["DetachedPromise"]();
        this.pending.set(cacheKey, promise);
        this.schedulerFn(async ()=>{
            try {
                const result = await fn(cacheKey, resolve);
                // Resolving a promise multiple times is a no-op, so we can safely
                // resolve all pending promises with the same result.
                resolve(result);
            } catch (err) {
                reject(err);
            } finally{
                this.pending.delete(cacheKey);
            }
        });
        return promise;
    }
} //# sourceMappingURL=batcher.js.map
}),
"[project]/node_modules/next/dist/esm/server/response-cache/types.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "CachedRouteKind": ()=>CachedRouteKind,
    "IncrementalCacheKind": ()=>IncrementalCacheKind
});
var CachedRouteKind = /*#__PURE__*/ function(CachedRouteKind) {
    CachedRouteKind["APP_PAGE"] = "APP_PAGE";
    CachedRouteKind["APP_ROUTE"] = "APP_ROUTE";
    CachedRouteKind["PAGES"] = "PAGES";
    CachedRouteKind["FETCH"] = "FETCH";
    CachedRouteKind["REDIRECT"] = "REDIRECT";
    CachedRouteKind["IMAGE"] = "IMAGE";
    return CachedRouteKind;
}({});
var IncrementalCacheKind = /*#__PURE__*/ function(IncrementalCacheKind) {
    IncrementalCacheKind["APP_PAGE"] = "APP_PAGE";
    IncrementalCacheKind["APP_ROUTE"] = "APP_ROUTE";
    IncrementalCacheKind["PAGES"] = "PAGES";
    IncrementalCacheKind["FETCH"] = "FETCH";
    IncrementalCacheKind["IMAGE"] = "IMAGE";
    return IncrementalCacheKind;
}({}); //# sourceMappingURL=types.js.map
}),
"[project]/node_modules/next/dist/esm/server/render-result.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>RenderResult
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$node$2d$web$2d$streams$2d$helper$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/stream-utils/node-web-streams-helper.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$pipe$2d$readable$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/pipe-readable.js [app-rsc] (ecmascript)");
;
;
class RenderResult {
    /**
   * Creates a new RenderResult instance from a static response.
   *
   * @param value the static response value
   * @returns a new RenderResult instance
   */ static fromStatic(value) {
        return new RenderResult(value, {
            metadata: {}
        });
    }
    constructor(response, { contentType, waitUntil, metadata }){
        this.response = response;
        this.contentType = contentType;
        this.metadata = metadata;
        this.waitUntil = waitUntil;
    }
    assignMetadata(metadata) {
        Object.assign(this.metadata, metadata);
    }
    /**
   * Returns true if the response is null. It can be null if the response was
   * not found or was already sent.
   */ get isNull() {
        return this.response === null;
    }
    /**
   * Returns false if the response is a string. It can be a string if the page
   * was prerendered. If it's not, then it was generated dynamically.
   */ get isDynamic() {
        return typeof this.response !== 'string';
    }
    toUnchunkedBuffer(stream = false) {
        if (this.response === null) {
            throw Object.defineProperty(new Error('Invariant: null responses cannot be unchunked'), "__NEXT_ERROR_CODE", {
                value: "E274",
                enumerable: false,
                configurable: true
            });
        }
        if (typeof this.response !== 'string') {
            if (!stream) {
                throw Object.defineProperty(new Error('Invariant: dynamic responses cannot be unchunked. This is a bug in Next.js'), "__NEXT_ERROR_CODE", {
                    value: "E81",
                    enumerable: false,
                    configurable: true
                });
            }
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$node$2d$web$2d$streams$2d$helper$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["streamToBuffer"])(this.readable);
        }
        return Buffer.from(this.response);
    }
    toUnchunkedString(stream = false) {
        if (this.response === null) {
            throw Object.defineProperty(new Error('Invariant: null responses cannot be unchunked'), "__NEXT_ERROR_CODE", {
                value: "E274",
                enumerable: false,
                configurable: true
            });
        }
        if (typeof this.response !== 'string') {
            if (!stream) {
                throw Object.defineProperty(new Error('Invariant: dynamic responses cannot be unchunked. This is a bug in Next.js'), "__NEXT_ERROR_CODE", {
                    value: "E81",
                    enumerable: false,
                    configurable: true
                });
            }
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$node$2d$web$2d$streams$2d$helper$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["streamToString"])(this.readable);
        }
        return this.response;
    }
    /**
   * Returns the response if it is a stream, or throws an error if it is a
   * string.
   */ get readable() {
        if (this.response === null) {
            throw Object.defineProperty(new Error('Invariant: null responses cannot be streamed'), "__NEXT_ERROR_CODE", {
                value: "E14",
                enumerable: false,
                configurable: true
            });
        }
        if (typeof this.response === 'string') {
            throw Object.defineProperty(new Error('Invariant: static responses cannot be streamed'), "__NEXT_ERROR_CODE", {
                value: "E151",
                enumerable: false,
                configurable: true
            });
        }
        if (Buffer.isBuffer(this.response)) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$node$2d$web$2d$streams$2d$helper$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["streamFromBuffer"])(this.response);
        }
        // If the response is an array of streams, then chain them together.
        if (Array.isArray(this.response)) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$node$2d$web$2d$streams$2d$helper$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["chainStreams"])(...this.response);
        }
        return this.response;
    }
    /**
   * Chains a new stream to the response. This will convert the response to an
   * array of streams if it is not already one and will add the new stream to
   * the end. When this response is piped, all of the streams will be piped
   * one after the other.
   *
   * @param readable The new stream to chain
   */ chain(readable) {
        if (this.response === null) {
            throw Object.defineProperty(new Error('Invariant: response is null. This is a bug in Next.js'), "__NEXT_ERROR_CODE", {
                value: "E258",
                enumerable: false,
                configurable: true
            });
        }
        // If the response is not an array of streams already, make it one.
        let responses;
        if (typeof this.response === 'string') {
            responses = [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$node$2d$web$2d$streams$2d$helper$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["streamFromString"])(this.response)
            ];
        } else if (Array.isArray(this.response)) {
            responses = this.response;
        } else if (Buffer.isBuffer(this.response)) {
            responses = [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$node$2d$web$2d$streams$2d$helper$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["streamFromBuffer"])(this.response)
            ];
        } else {
            responses = [
                this.response
            ];
        }
        // Add the new stream to the array.
        responses.push(readable);
        // Update the response.
        this.response = responses;
    }
    /**
   * Pipes the response to a writable stream. This will close/cancel the
   * writable stream if an error is encountered. If this doesn't throw, then
   * the writable stream will be closed or aborted.
   *
   * @param writable Writable stream to pipe the response to
   */ async pipeTo(writable) {
        try {
            await this.readable.pipeTo(writable, {
                // We want to close the writable stream ourselves so that we can wait
                // for the waitUntil promise to resolve before closing it. If an error
                // is encountered, we'll abort the writable stream if we swallowed the
                // error.
                preventClose: true
            });
            // If there is a waitUntil promise, wait for it to resolve before
            // closing the writable stream.
            if (this.waitUntil) await this.waitUntil;
            // Close the writable stream.
            await writable.close();
        } catch (err) {
            // If this is an abort error, we should abort the writable stream (as we
            // took ownership of it when we started piping). We don't need to re-throw
            // because we handled the error.
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$pipe$2d$readable$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isAbortError"])(err)) {
                // Abort the writable stream if an error is encountered.
                await writable.abort(err);
                return;
            }
            // We're not aborting the writer here as when this method throws it's not
            // clear as to how so the caller should assume it's their responsibility
            // to clean up the writer.
            throw err;
        }
    }
    /**
   * Pipes the response to a node response. This will close/cancel the node
   * response if an error is encountered.
   *
   * @param res
   */ async pipeToNodeResponse(res) {
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$pipe$2d$readable$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["pipeToNodeResponse"])(this.readable, res, this.waitUntil);
    }
} //# sourceMappingURL=render-result.js.map
}),
"[project]/node_modules/next/dist/esm/server/response-cache/utils.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "fromResponseCacheEntry": ()=>fromResponseCacheEntry,
    "routeKindToIncrementalCacheKind": ()=>routeKindToIncrementalCacheKind,
    "toResponseCacheEntry": ()=>toResponseCacheEntry
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$types$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/response-cache/types.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$render$2d$result$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/render-result.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$route$2d$kind$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/route-kind.js [app-rsc] (ecmascript)");
;
;
;
async function fromResponseCacheEntry(cacheEntry) {
    var _cacheEntry_value, _cacheEntry_value1;
    return {
        ...cacheEntry,
        value: ((_cacheEntry_value = cacheEntry.value) == null ? void 0 : _cacheEntry_value.kind) === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$types$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["CachedRouteKind"].PAGES ? {
            kind: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$types$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["CachedRouteKind"].PAGES,
            html: await cacheEntry.value.html.toUnchunkedString(true),
            pageData: cacheEntry.value.pageData,
            headers: cacheEntry.value.headers,
            status: cacheEntry.value.status
        } : ((_cacheEntry_value1 = cacheEntry.value) == null ? void 0 : _cacheEntry_value1.kind) === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$types$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["CachedRouteKind"].APP_PAGE ? {
            kind: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$types$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["CachedRouteKind"].APP_PAGE,
            html: await cacheEntry.value.html.toUnchunkedString(true),
            postponed: cacheEntry.value.postponed,
            rscData: cacheEntry.value.rscData,
            headers: cacheEntry.value.headers,
            status: cacheEntry.value.status,
            segmentData: cacheEntry.value.segmentData
        } : cacheEntry.value
    };
}
async function toResponseCacheEntry(response) {
    var _response_value, _response_value1;
    if (!response) return null;
    return {
        isMiss: response.isMiss,
        isStale: response.isStale,
        cacheControl: response.cacheControl,
        value: ((_response_value = response.value) == null ? void 0 : _response_value.kind) === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$types$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["CachedRouteKind"].PAGES ? {
            kind: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$types$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["CachedRouteKind"].PAGES,
            html: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$render$2d$result$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"].fromStatic(response.value.html),
            pageData: response.value.pageData,
            headers: response.value.headers,
            status: response.value.status
        } : ((_response_value1 = response.value) == null ? void 0 : _response_value1.kind) === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$types$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["CachedRouteKind"].APP_PAGE ? {
            kind: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$types$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["CachedRouteKind"].APP_PAGE,
            html: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$render$2d$result$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"].fromStatic(response.value.html),
            rscData: response.value.rscData,
            headers: response.value.headers,
            status: response.value.status,
            postponed: response.value.postponed,
            segmentData: response.value.segmentData
        } : response.value
    };
}
function routeKindToIncrementalCacheKind(routeKind) {
    switch(routeKind){
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$route$2d$kind$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["RouteKind"].PAGES:
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$types$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["IncrementalCacheKind"].PAGES;
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$route$2d$kind$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["RouteKind"].APP_PAGE:
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$types$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["IncrementalCacheKind"].APP_PAGE;
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$route$2d$kind$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["RouteKind"].IMAGE:
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$types$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["IncrementalCacheKind"].IMAGE;
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$route$2d$kind$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["RouteKind"].APP_ROUTE:
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$types$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["IncrementalCacheKind"].APP_ROUTE;
        default:
            throw Object.defineProperty(new Error(`Unexpected route kind ${routeKind}`), "__NEXT_ERROR_CODE", {
                value: "E64",
                enumerable: false,
                configurable: true
            });
    }
} //# sourceMappingURL=utils.js.map
}),
"[project]/node_modules/next/dist/esm/server/response-cache/index.js [app-rsc] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>ResponseCache
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$batcher$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/batcher.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$scheduler$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/scheduler.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/response-cache/utils.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$types$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/response-cache/types.js [app-rsc] (ecmascript)");
;
;
;
;
class ResponseCache {
    constructor(minimal_mode){
        this.batcher = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$batcher$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Batcher"].create({
            // Ensure on-demand revalidate doesn't block normal requests, it should be
            // safe to run an on-demand revalidate for the same key as a normal request.
            cacheKeyFn: ({ key, isOnDemandRevalidate })=>`${key}-${isOnDemandRevalidate ? '1' : '0'}`,
            // We wait to do any async work until after we've added our promise to
            // `pendingResponses` to ensure that any any other calls will reuse the
            // same promise until we've fully finished our work.
            schedulerFn: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$scheduler$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["scheduleOnNextTick"]
        });
        this.minimal_mode = minimal_mode;
    }
    async get(key, responseGenerator, context) {
        // If there is no key for the cache, we can't possibly look this up in the
        // cache so just return the result of the response generator.
        if (!key) {
            return responseGenerator({
                hasResolved: false,
                previousCacheEntry: null
            });
        }
        const { incrementalCache, isOnDemandRevalidate = false, isFallback = false, isRoutePPREnabled = false, waitUntil } = context;
        const response = await this.batcher.batch({
            key,
            isOnDemandRevalidate
        }, (cacheKey, resolve)=>{
            const prom = (async ()=>{
                var _this_previousCacheItem;
                // We keep the previous cache entry around to leverage when the
                // incremental cache is disabled in minimal mode.
                if (this.minimal_mode && ((_this_previousCacheItem = this.previousCacheItem) == null ? void 0 : _this_previousCacheItem.key) === cacheKey && this.previousCacheItem.expiresAt > Date.now()) {
                    return this.previousCacheItem.entry;
                }
                // Coerce the kindHint into a given kind for the incremental cache.
                const kind = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["routeKindToIncrementalCacheKind"])(context.routeKind);
                let resolved = false;
                let cachedResponse = null;
                try {
                    cachedResponse = !this.minimal_mode ? await incrementalCache.get(key, {
                        kind,
                        isRoutePPREnabled: context.isRoutePPREnabled,
                        isFallback
                    }) : null;
                    if (cachedResponse && !isOnDemandRevalidate) {
                        resolve(cachedResponse);
                        resolved = true;
                        if (!cachedResponse.isStale || context.isPrefetch) {
                            // The cached value is still valid, so we don't need
                            // to update it yet.
                            return null;
                        }
                    }
                    const cacheEntry = await responseGenerator({
                        hasResolved: resolved,
                        previousCacheEntry: cachedResponse,
                        isRevalidating: true
                    });
                    // If the cache entry couldn't be generated, we don't want to cache
                    // the result.
                    if (!cacheEntry) {
                        // Unset the previous cache item if it was set.
                        if (this.minimal_mode) this.previousCacheItem = undefined;
                        return null;
                    }
                    const resolveValue = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["fromResponseCacheEntry"])({
                        ...cacheEntry,
                        isMiss: !cachedResponse
                    });
                    if (!resolveValue) {
                        // Unset the previous cache item if it was set.
                        if (this.minimal_mode) this.previousCacheItem = undefined;
                        return null;
                    }
                    // For on-demand revalidate wait to resolve until cache is set.
                    // Otherwise resolve now.
                    if (!isOnDemandRevalidate && !resolved) {
                        resolve(resolveValue);
                        resolved = true;
                    }
                    // We want to persist the result only if it has a cache control value
                    // defined.
                    if (resolveValue.cacheControl) {
                        if (this.minimal_mode) {
                            this.previousCacheItem = {
                                key: cacheKey,
                                entry: resolveValue,
                                expiresAt: Date.now() + 1000
                            };
                        } else {
                            await incrementalCache.set(key, resolveValue.value, {
                                cacheControl: resolveValue.cacheControl,
                                isRoutePPREnabled,
                                isFallback
                            });
                        }
                    }
                    return resolveValue;
                } catch (err) {
                    // When a path is erroring we automatically re-set the existing cache
                    // with new revalidate and expire times to prevent non-stop retrying.
                    if (cachedResponse == null ? void 0 : cachedResponse.cacheControl) {
                        const newRevalidate = Math.min(Math.max(cachedResponse.cacheControl.revalidate || 3, 3), 30);
                        const newExpire = cachedResponse.cacheControl.expire === undefined ? undefined : Math.max(newRevalidate + 3, cachedResponse.cacheControl.expire);
                        await incrementalCache.set(key, cachedResponse.value, {
                            cacheControl: {
                                revalidate: newRevalidate,
                                expire: newExpire
                            },
                            isRoutePPREnabled,
                            isFallback
                        });
                    }
                    // While revalidating in the background we can't reject as we already
                    // resolved the cache entry so log the error here.
                    if (resolved) {
                        console.error(err);
                        return null;
                    }
                    // We haven't resolved yet, so let's throw to indicate an error.
                    throw err;
                }
            })();
            // we need to ensure background revalidates are
            // passed to waitUntil
            if (waitUntil) {
                waitUntil(prom);
            }
            return prom;
        });
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["toResponseCacheEntry"])(response);
    }
} //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/next/dist/esm/server/response-cache/index.js [app-rsc] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$batcher$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/batcher.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$scheduler$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/scheduler.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/response-cache/utils.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$types$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/response-cache/types.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/response-cache/index.js [app-rsc] (ecmascript) <locals>");
}),
"[project]/node_modules/next/dist/esm/server/lib/patch-fetch.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "NEXT_PATCH_SYMBOL": ()=>NEXT_PATCH_SYMBOL,
    "createPatchedFetcher": ()=>createPatchedFetcher,
    "patchFetch": ()=>patchFetch,
    "validateRevalidate": ()=>validateRevalidate,
    "validateTags": ()=>validateTags
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/lib/trace/constants.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$tracer$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/lib/trace/tracer.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/constants.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$dynamic$2d$rendering$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/app-render/dynamic-rendering.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$dynamic$2d$rendering$2d$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/dynamic-rendering-utils.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$dedupe$2d$fetch$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/lib/dedupe-fetch.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/response-cache/index.js [app-rsc] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$types$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/response-cache/types.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$scheduler$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/scheduler.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$clone$2d$response$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/lib/clone-response.js [app-rsc] (ecmascript)");
;
;
;
;
;
;
;
;
;
const isEdgeRuntime = ("TURBOPACK compile-time value", "nodejs") === 'edge';
const NEXT_PATCH_SYMBOL = Symbol.for('next-patch');
function isFetchPatched() {
    return globalThis[NEXT_PATCH_SYMBOL] === true;
}
function validateRevalidate(revalidateVal, route) {
    try {
        let normalizedRevalidate = undefined;
        if (revalidateVal === false) {
            normalizedRevalidate = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["INFINITE_CACHE"];
        } else if (typeof revalidateVal === 'number' && !isNaN(revalidateVal) && revalidateVal > -1) {
            normalizedRevalidate = revalidateVal;
        } else if (typeof revalidateVal !== 'undefined') {
            throw Object.defineProperty(new Error(`Invalid revalidate value "${revalidateVal}" on "${route}", must be a non-negative number or false`), "__NEXT_ERROR_CODE", {
                value: "E179",
                enumerable: false,
                configurable: true
            });
        }
        return normalizedRevalidate;
    } catch (err) {
        // handle client component error from attempting to check revalidate value
        if (err instanceof Error && err.message.includes('Invalid revalidate')) {
            throw err;
        }
        return undefined;
    }
}
function validateTags(tags, description) {
    const validTags = [];
    const invalidTags = [];
    for(let i = 0; i < tags.length; i++){
        const tag = tags[i];
        if (typeof tag !== 'string') {
            invalidTags.push({
                tag,
                reason: 'invalid type, must be a string'
            });
        } else if (tag.length > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["NEXT_CACHE_TAG_MAX_LENGTH"]) {
            invalidTags.push({
                tag,
                reason: `exceeded max length of ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["NEXT_CACHE_TAG_MAX_LENGTH"]}`
            });
        } else {
            validTags.push(tag);
        }
        if (validTags.length > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["NEXT_CACHE_TAG_MAX_ITEMS"]) {
            console.warn(`Warning: exceeded max tag count for ${description}, dropped tags:`, tags.slice(i).join(', '));
            break;
        }
    }
    if (invalidTags.length > 0) {
        console.warn(`Warning: invalid tags passed to ${description}: `);
        for (const { tag, reason } of invalidTags){
            console.log(`tag: "${tag}" ${reason}`);
        }
    }
    return validTags;
}
function trackFetchMetric(workStore, ctx) {
    var _workStore_requestEndedState;
    // If the static generation store is not available, we can't track the fetch
    if (!workStore) return;
    if ((_workStore_requestEndedState = workStore.requestEndedState) == null ? void 0 : _workStore_requestEndedState.ended) return;
    const isDebugBuild = (!!process.env.NEXT_DEBUG_BUILD || process.env.NEXT_SSG_FETCH_METRICS === '1') && workStore.isStaticGeneration;
    const isDevelopment = ("TURBOPACK compile-time value", "development") === 'development';
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    workStore.fetchMetrics ??= [];
    workStore.fetchMetrics.push({
        ...ctx,
        end: performance.timeOrigin + performance.now(),
        idx: workStore.nextFetchId || 0
    });
}
function createPatchedFetcher(originFetch, { workAsyncStorage, workUnitAsyncStorage }) {
    // Create the patched fetch function.
    const patched = async function fetch(input, init) {
        var _init_method, _init_next;
        let url;
        try {
            url = new URL(input instanceof Request ? input.url : input);
            url.username = '';
            url.password = '';
        } catch  {
            // Error caused by malformed URL should be handled by native fetch
            url = undefined;
        }
        const fetchUrl = (url == null ? void 0 : url.href) ?? '';
        const method = (init == null ? void 0 : (_init_method = init.method) == null ? void 0 : _init_method.toUpperCase()) || 'GET';
        // Do create a new span trace for internal fetches in the
        // non-verbose mode.
        const isInternal = (init == null ? void 0 : (_init_next = init.next) == null ? void 0 : _init_next.internal) === true;
        const hideSpan = process.env.NEXT_OTEL_FETCH_DISABLED === '1';
        // We don't track fetch metrics for internal fetches
        // so it's not critical that we have a start time, as it won't be recorded.
        // This is to workaround a flaky issue where performance APIs might
        // not be available and will require follow-up investigation.
        const fetchStart = isInternal ? undefined : performance.timeOrigin + performance.now();
        const workStore = workAsyncStorage.getStore();
        const workUnitStore = workUnitAsyncStorage.getStore();
        // During static generation we track cache reads so we can reason about when they fill
        let cacheSignal = workUnitStore && workUnitStore.type === 'prerender' ? workUnitStore.cacheSignal : null;
        if (cacheSignal) {
            cacheSignal.beginRead();
        }
        const result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$tracer$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getTracer"])().trace(isInternal ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["NextNodeServerSpan"].internalFetch : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["AppRenderSpan"].fetch, {
            hideSpan,
            kind: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$tracer$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["SpanKind"].CLIENT,
            spanName: [
                'fetch',
                method,
                fetchUrl
            ].filter(Boolean).join(' '),
            attributes: {
                'http.url': fetchUrl,
                'http.method': method,
                'net.peer.name': url == null ? void 0 : url.hostname,
                'net.peer.port': (url == null ? void 0 : url.port) || undefined
            }
        }, async ()=>{
            var _getRequestMeta;
            // If this is an internal fetch, we should not do any special treatment.
            if (isInternal) {
                return originFetch(input, init);
            }
            // If the workStore is not available, we can't do any
            // special treatment of fetch, therefore fallback to the original
            // fetch implementation.
            if (!workStore) {
                return originFetch(input, init);
            }
            // We should also fallback to the original fetch implementation if we
            // are in draft mode, it does not constitute a static generation.
            if (workStore.isDraftMode) {
                return originFetch(input, init);
            }
            const isRequestInput = input && typeof input === 'object' && typeof input.method === 'string';
            const getRequestMeta = (field)=>{
                // If request input is present but init is not, retrieve from input first.
                const value = init == null ? void 0 : init[field];
                return value || (isRequestInput ? input[field] : null);
            };
            let finalRevalidate = undefined;
            const getNextField = (field)=>{
                var _init_next, _init_next1, _input_next;
                return typeof (init == null ? void 0 : (_init_next = init.next) == null ? void 0 : _init_next[field]) !== 'undefined' ? init == null ? void 0 : (_init_next1 = init.next) == null ? void 0 : _init_next1[field] : isRequestInput ? (_input_next = input.next) == null ? void 0 : _input_next[field] : undefined;
            };
            // RequestInit doesn't keep extra fields e.g. next so it's
            // only available if init is used separate
            const originalFetchRevalidate = getNextField('revalidate');
            let currentFetchRevalidate = originalFetchRevalidate;
            const tags = validateTags(getNextField('tags') || [], `fetch ${input.toString()}`);
            const revalidateStore = workUnitStore && (workUnitStore.type === 'cache' || workUnitStore.type === 'prerender' || // TODO: stop accumulating tags in client prerender
            workUnitStore.type === 'prerender-client' || workUnitStore.type === 'prerender-ppr' || workUnitStore.type === 'prerender-legacy') ? workUnitStore : undefined;
            if (revalidateStore) {
                if (Array.isArray(tags)) {
                    // Collect tags onto parent caches or parent prerenders.
                    const collectedTags = revalidateStore.tags ?? (revalidateStore.tags = []);
                    for (const tag of tags){
                        if (!collectedTags.includes(tag)) {
                            collectedTags.push(tag);
                        }
                    }
                }
            }
            const implicitTags = workUnitStore == null ? void 0 : workUnitStore.implicitTags;
            // Inside unstable-cache we treat it the same as force-no-store on the
            // page.
            const pageFetchCacheMode = workUnitStore && workUnitStore.type === 'unstable-cache' ? 'force-no-store' : workStore.fetchCache;
            const isUsingNoStore = !!workStore.isUnstableNoStore;
            let currentFetchCacheConfig = getRequestMeta('cache');
            let cacheReason = '';
            let cacheWarning;
            if (typeof currentFetchCacheConfig === 'string' && typeof currentFetchRevalidate !== 'undefined') {
                // If the revalidate value conflicts with the cache value, we should warn the user and unset the conflicting values.
                const isConflictingRevalidate = currentFetchCacheConfig === 'force-cache' && currentFetchRevalidate === 0 || // revalidate: >0 or revalidate: false and cache: no-store
                currentFetchCacheConfig === 'no-store' && (currentFetchRevalidate > 0 || currentFetchRevalidate === false);
                if (isConflictingRevalidate) {
                    cacheWarning = `Specified "cache: ${currentFetchCacheConfig}" and "revalidate: ${currentFetchRevalidate}", only one should be specified.`;
                    currentFetchCacheConfig = undefined;
                    currentFetchRevalidate = undefined;
                }
            }
            const hasExplicitFetchCacheOptOut = currentFetchCacheConfig === 'no-cache' || currentFetchCacheConfig === 'no-store' || // the fetch isn't explicitly caching and the segment level cache config signals not to cache
            // note: `pageFetchCacheMode` is also set by being in an unstable_cache context.
            pageFetchCacheMode === 'force-no-store' || pageFetchCacheMode === 'only-no-store';
            // If no explicit fetch cache mode is set, but dynamic = `force-dynamic` is set,
            // we shouldn't consider caching the fetch. This is because the `dynamic` cache
            // is considered a "top-level" cache mode, whereas something like `fetchCache` is more
            // fine-grained. Top-level modes are responsible for setting reasonable defaults for the
            // other configurations.
            const noFetchConfigAndForceDynamic = !pageFetchCacheMode && !currentFetchCacheConfig && !currentFetchRevalidate && workStore.forceDynamic;
            if (// which will signal the cache to not revalidate
            currentFetchCacheConfig === 'force-cache' && typeof currentFetchRevalidate === 'undefined') {
                currentFetchRevalidate = false;
            } else if (hasExplicitFetchCacheOptOut || noFetchConfigAndForceDynamic) {
                currentFetchRevalidate = 0;
            }
            if (currentFetchCacheConfig === 'no-cache' || currentFetchCacheConfig === 'no-store') {
                cacheReason = `cache: ${currentFetchCacheConfig}`;
            }
            finalRevalidate = validateRevalidate(currentFetchRevalidate, workStore.route);
            const _headers = getRequestMeta('headers');
            const initHeaders = typeof (_headers == null ? void 0 : _headers.get) === 'function' ? _headers : new Headers(_headers || {});
            const hasUnCacheableHeader = initHeaders.get('authorization') || initHeaders.get('cookie');
            const isUnCacheableMethod = ![
                'get',
                'head'
            ].includes(((_getRequestMeta = getRequestMeta('method')) == null ? void 0 : _getRequestMeta.toLowerCase()) || 'get');
            /**
         * We automatically disable fetch caching under the following conditions:
         * - Fetch cache configs are not set. Specifically:
         *    - A page fetch cache mode is not set (export const fetchCache=...)
         *    - A fetch cache mode is not set in the fetch call (fetch(url, { cache: ... }))
         *      or the fetch cache mode is set to 'default'
         *    - A fetch revalidate value is not set in the fetch call (fetch(url, { revalidate: ... }))
         * - OR the fetch comes after a configuration that triggered dynamic rendering (e.g., reading cookies())
         *   and the fetch was considered uncacheable (e.g., POST method or has authorization headers)
         */ const hasNoExplicitCacheConfig = pageFetchCacheMode == undefined && // eslint-disable-next-line eqeqeq
            (currentFetchCacheConfig == undefined || // when considering whether to opt into the default "no-cache" fetch semantics,
            // a "default" cache config should be treated the same as no cache config
            currentFetchCacheConfig === 'default') && // eslint-disable-next-line eqeqeq
            currentFetchRevalidate == undefined;
            let autoNoCache = Boolean((hasUnCacheableHeader || isUnCacheableMethod) && (revalidateStore == null ? void 0 : revalidateStore.revalidate) === 0);
            let isImplicitBuildTimeCache = false;
            if (!autoNoCache && hasNoExplicitCacheConfig) {
                // We don't enable automatic no-cache behavior during build-time
                // prerendering so that we can still leverage the fetch cache between
                // export workers.
                if (workStore.isBuildTimePrerendering) {
                    isImplicitBuildTimeCache = true;
                } else {
                    autoNoCache = true;
                }
            }
            if (hasNoExplicitCacheConfig && workUnitStore !== undefined && (workUnitStore.type === 'prerender' || // While we don't want to do caching in the client scope
            // we know the fetch will be dynamic for dynamicIO so we
            // may as well avoid the call here
            workUnitStore.type === 'prerender-client')) {
                // If we have no cache config, and we're in Dynamic I/O prerendering, it'll be a dynamic call.
                // We don't have to issue that dynamic call.
                if (cacheSignal) {
                    cacheSignal.endRead();
                    cacheSignal = null;
                }
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$dynamic$2d$rendering$2d$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["makeHangingPromise"])(workUnitStore.renderSignal, 'fetch()');
            }
            switch(pageFetchCacheMode){
                case 'force-no-store':
                    {
                        cacheReason = 'fetchCache = force-no-store';
                        break;
                    }
                case 'only-no-store':
                    {
                        if (currentFetchCacheConfig === 'force-cache' || typeof finalRevalidate !== 'undefined' && finalRevalidate > 0) {
                            throw Object.defineProperty(new Error(`cache: 'force-cache' used on fetch for ${fetchUrl} with 'export const fetchCache = 'only-no-store'`), "__NEXT_ERROR_CODE", {
                                value: "E448",
                                enumerable: false,
                                configurable: true
                            });
                        }
                        cacheReason = 'fetchCache = only-no-store';
                        break;
                    }
                case 'only-cache':
                    {
                        if (currentFetchCacheConfig === 'no-store') {
                            throw Object.defineProperty(new Error(`cache: 'no-store' used on fetch for ${fetchUrl} with 'export const fetchCache = 'only-cache'`), "__NEXT_ERROR_CODE", {
                                value: "E521",
                                enumerable: false,
                                configurable: true
                            });
                        }
                        break;
                    }
                case 'force-cache':
                    {
                        if (typeof currentFetchRevalidate === 'undefined' || currentFetchRevalidate === 0) {
                            cacheReason = 'fetchCache = force-cache';
                            finalRevalidate = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["INFINITE_CACHE"];
                        }
                        break;
                    }
                default:
            }
            if (typeof finalRevalidate === 'undefined') {
                if (pageFetchCacheMode === 'default-cache' && !isUsingNoStore) {
                    finalRevalidate = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["INFINITE_CACHE"];
                    cacheReason = 'fetchCache = default-cache';
                } else if (pageFetchCacheMode === 'default-no-store') {
                    finalRevalidate = 0;
                    cacheReason = 'fetchCache = default-no-store';
                } else if (isUsingNoStore) {
                    finalRevalidate = 0;
                    cacheReason = 'noStore call';
                } else if (autoNoCache) {
                    finalRevalidate = 0;
                    cacheReason = 'auto no cache';
                } else {
                    // TODO: should we consider this case an invariant?
                    cacheReason = 'auto cache';
                    finalRevalidate = revalidateStore ? revalidateStore.revalidate : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["INFINITE_CACHE"];
                }
            } else if (!cacheReason) {
                cacheReason = `revalidate: ${finalRevalidate}`;
            }
            if (// `revalidate: 0` values
            !(workStore.forceStatic && finalRevalidate === 0) && // we don't consider autoNoCache to switch to dynamic for ISR
            !autoNoCache && // If the revalidate value isn't currently set or the value is less
            // than the current revalidate value, we should update the revalidate
            // value.
            revalidateStore && finalRevalidate < revalidateStore.revalidate) {
                // If we were setting the revalidate value to 0, we should try to
                // postpone instead first.
                if (finalRevalidate === 0) {
                    if (workUnitStore) {
                        switch(workUnitStore.type){
                            case 'prerender':
                            case 'prerender-client':
                                if (cacheSignal) {
                                    cacheSignal.endRead();
                                    cacheSignal = null;
                                }
                                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$dynamic$2d$rendering$2d$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["makeHangingPromise"])(workUnitStore.renderSignal, 'fetch()');
                            default:
                        }
                    }
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$dynamic$2d$rendering$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["markCurrentScopeAsDynamic"])(workStore, workUnitStore, `revalidate: 0 fetch ${input} ${workStore.route}`);
                }
                // We only want to set the revalidate store's revalidate time if it
                // was explicitly set for the fetch call, i.e.
                // originalFetchRevalidate.
                if (revalidateStore && originalFetchRevalidate === finalRevalidate) {
                    revalidateStore.revalidate = finalRevalidate;
                }
            }
            const isCacheableRevalidate = typeof finalRevalidate === 'number' && finalRevalidate > 0;
            let cacheKey;
            const { incrementalCache } = workStore;
            const useCacheOrRequestStore = (workUnitStore == null ? void 0 : workUnitStore.type) === 'request' || (workUnitStore == null ? void 0 : workUnitStore.type) === 'cache' ? workUnitStore : undefined;
            if (incrementalCache && (isCacheableRevalidate || (useCacheOrRequestStore == null ? void 0 : useCacheOrRequestStore.serverComponentsHmrCache))) {
                try {
                    cacheKey = await incrementalCache.generateCacheKey(fetchUrl, isRequestInput ? input : init);
                } catch (err) {
                    console.error(`Failed to generate cache key for`, input);
                }
            }
            const fetchIdx = workStore.nextFetchId ?? 1;
            workStore.nextFetchId = fetchIdx + 1;
            let handleUnlock = ()=>{};
            const doOriginalFetch = async (isStale, cacheReasonOverride)=>{
                const requestInputFields = [
                    'cache',
                    'credentials',
                    'headers',
                    'integrity',
                    'keepalive',
                    'method',
                    'mode',
                    'redirect',
                    'referrer',
                    'referrerPolicy',
                    'window',
                    'duplex',
                    // don't pass through signal when revalidating
                    ...isStale ? [] : [
                        'signal'
                    ]
                ];
                if (isRequestInput) {
                    const reqInput = input;
                    const reqOptions = {
                        body: reqInput._ogBody || reqInput.body
                    };
                    for (const field of requestInputFields){
                        // @ts-expect-error custom fields
                        reqOptions[field] = reqInput[field];
                    }
                    input = new Request(reqInput.url, reqOptions);
                } else if (init) {
                    const { _ogBody, body, signal, ...otherInput } = init;
                    init = {
                        ...otherInput,
                        body: _ogBody || body,
                        signal: isStale ? undefined : signal
                    };
                }
                // add metadata to init without editing the original
                const clonedInit = {
                    ...init,
                    next: {
                        ...init == null ? void 0 : init.next,
                        fetchType: 'origin',
                        fetchIdx
                    }
                };
                return originFetch(input, clonedInit).then(async (res)=>{
                    if (!isStale && fetchStart) {
                        trackFetchMetric(workStore, {
                            start: fetchStart,
                            url: fetchUrl,
                            cacheReason: cacheReasonOverride || cacheReason,
                            cacheStatus: finalRevalidate === 0 || cacheReasonOverride ? 'skip' : 'miss',
                            cacheWarning,
                            status: res.status,
                            method: clonedInit.method || 'GET'
                        });
                    }
                    if (res.status === 200 && incrementalCache && cacheKey && (isCacheableRevalidate || (useCacheOrRequestStore == null ? void 0 : useCacheOrRequestStore.serverComponentsHmrCache))) {
                        const normalizedRevalidate = finalRevalidate >= __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["INFINITE_CACHE"] ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["CACHE_ONE_YEAR"] : finalRevalidate;
                        if (workUnitStore && (workUnitStore.type === 'prerender' || workUnitStore.type === 'prerender-client')) {
                            // We are prerendering at build time or revalidate time with dynamicIO so we need to
                            // buffer the response so we can guarantee it can be read in a microtask
                            const bodyBuffer = await res.arrayBuffer();
                            const fetchedData = {
                                headers: Object.fromEntries(res.headers.entries()),
                                body: Buffer.from(bodyBuffer).toString('base64'),
                                status: res.status,
                                url: res.url
                            };
                            // We can skip checking the serverComponentsHmrCache because we aren't in
                            // dev mode.
                            await incrementalCache.set(cacheKey, {
                                kind: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$types$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["CachedRouteKind"].FETCH,
                                data: fetchedData,
                                revalidate: normalizedRevalidate
                            }, {
                                fetchCache: true,
                                fetchUrl,
                                fetchIdx,
                                tags,
                                isImplicitBuildTimeCache
                            });
                            await handleUnlock();
                            // We return a new Response to the caller.
                            return new Response(bodyBuffer, {
                                headers: res.headers,
                                status: res.status,
                                statusText: res.statusText
                            });
                        } else {
                            // We're cloning the response using this utility because there
                            // exists a bug in the undici library around response cloning.
                            // See the following pull request for more details:
                            // https://github.com/vercel/next.js/pull/73274
                            const [cloned1, cloned2] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$clone$2d$response$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["cloneResponse"])(res);
                            // We are dynamically rendering including dev mode. We want to return
                            // the response to the caller as soon as possible because it might stream
                            // over a very long time.
                            const cacheSetPromise = cloned1.arrayBuffer().then(async (arrayBuffer)=>{
                                var _useCacheOrRequestStore_serverComponentsHmrCache;
                                const bodyBuffer = Buffer.from(arrayBuffer);
                                const fetchedData = {
                                    headers: Object.fromEntries(cloned1.headers.entries()),
                                    body: bodyBuffer.toString('base64'),
                                    status: cloned1.status,
                                    url: cloned1.url
                                };
                                useCacheOrRequestStore == null ? void 0 : (_useCacheOrRequestStore_serverComponentsHmrCache = useCacheOrRequestStore.serverComponentsHmrCache) == null ? void 0 : _useCacheOrRequestStore_serverComponentsHmrCache.set(cacheKey, fetchedData);
                                if (isCacheableRevalidate) {
                                    await incrementalCache.set(cacheKey, {
                                        kind: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$types$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["CachedRouteKind"].FETCH,
                                        data: fetchedData,
                                        revalidate: normalizedRevalidate
                                    }, {
                                        fetchCache: true,
                                        fetchUrl,
                                        fetchIdx,
                                        tags,
                                        isImplicitBuildTimeCache
                                    });
                                }
                            }).catch((error)=>console.warn(`Failed to set fetch cache`, input, error)).finally(handleUnlock);
                            const pendingRevalidateKey = `cache-set-${cacheKey}`;
                            workStore.pendingRevalidates ??= {};
                            if (pendingRevalidateKey in workStore.pendingRevalidates) {
                                // there is already a pending revalidate entry that
                                // we need to await to avoid race conditions
                                await workStore.pendingRevalidates[pendingRevalidateKey];
                            }
                            workStore.pendingRevalidates[pendingRevalidateKey] = cacheSetPromise.finally(()=>{
                                var _workStore_pendingRevalidates;
                                // If the pending revalidate is not present in the store, then
                                // we have nothing to delete.
                                if (!((_workStore_pendingRevalidates = workStore.pendingRevalidates) == null ? void 0 : _workStore_pendingRevalidates[pendingRevalidateKey])) {
                                    return;
                                }
                                delete workStore.pendingRevalidates[pendingRevalidateKey];
                            });
                            return cloned2;
                        }
                    }
                    // we had response that we determined shouldn't be cached so we return it
                    // and don't cache it. This also needs to unlock the cache lock we acquired.
                    await handleUnlock();
                    return res;
                }).catch((error)=>{
                    handleUnlock();
                    throw error;
                });
            };
            let cacheReasonOverride;
            let isForegroundRevalidate = false;
            let isHmrRefreshCache = false;
            if (cacheKey && incrementalCache) {
                let cachedFetchData;
                if ((useCacheOrRequestStore == null ? void 0 : useCacheOrRequestStore.isHmrRefresh) && useCacheOrRequestStore.serverComponentsHmrCache) {
                    cachedFetchData = useCacheOrRequestStore.serverComponentsHmrCache.get(cacheKey);
                    isHmrRefreshCache = true;
                }
                if (isCacheableRevalidate && !cachedFetchData) {
                    handleUnlock = await incrementalCache.lock(cacheKey);
                    const entry = workStore.isOnDemandRevalidate ? null : await incrementalCache.get(cacheKey, {
                        kind: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$types$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["IncrementalCacheKind"].FETCH,
                        revalidate: finalRevalidate,
                        fetchUrl,
                        fetchIdx,
                        tags,
                        softTags: implicitTags == null ? void 0 : implicitTags.tags
                    });
                    if (hasNoExplicitCacheConfig) {
                        // We sometimes use the cache to dedupe fetches that do not specify a cache configuration
                        // In these cases we want to make sure we still exclude them from prerenders if dynamicIO is on
                        // so we introduce an artificial Task boundary here.
                        if (workUnitStore && (workUnitStore.type === 'prerender' || workUnitStore.type === 'prerender-client')) {
                            await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$scheduler$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["waitAtLeastOneReactRenderTask"])();
                        }
                    }
                    if (entry) {
                        await handleUnlock();
                    } else {
                        // in dev, incremental cache response will be null in case the browser adds `cache-control: no-cache` in the request headers
                        cacheReasonOverride = 'cache-control: no-cache (hard refresh)';
                    }
                    if ((entry == null ? void 0 : entry.value) && entry.value.kind === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$types$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["CachedRouteKind"].FETCH) {
                        // when stale and is revalidating we wait for fresh data
                        // so the revalidated entry has the updated data
                        if (workStore.isRevalidate && entry.isStale) {
                            isForegroundRevalidate = true;
                        } else {
                            if (entry.isStale) {
                                workStore.pendingRevalidates ??= {};
                                if (!workStore.pendingRevalidates[cacheKey]) {
                                    const pendingRevalidate = doOriginalFetch(true).then(async (response)=>({
                                            body: await response.arrayBuffer(),
                                            headers: response.headers,
                                            status: response.status,
                                            statusText: response.statusText
                                        })).finally(()=>{
                                        workStore.pendingRevalidates ??= {};
                                        delete workStore.pendingRevalidates[cacheKey || ''];
                                    });
                                    // Attach the empty catch here so we don't get a "unhandled
                                    // promise rejection" warning.
                                    pendingRevalidate.catch(console.error);
                                    workStore.pendingRevalidates[cacheKey] = pendingRevalidate;
                                }
                            }
                            cachedFetchData = entry.value.data;
                        }
                    }
                }
                if (cachedFetchData) {
                    if (fetchStart) {
                        trackFetchMetric(workStore, {
                            start: fetchStart,
                            url: fetchUrl,
                            cacheReason,
                            cacheStatus: isHmrRefreshCache ? 'hmr' : 'hit',
                            cacheWarning,
                            status: cachedFetchData.status || 200,
                            method: (init == null ? void 0 : init.method) || 'GET'
                        });
                    }
                    const response = new Response(Buffer.from(cachedFetchData.body, 'base64'), {
                        headers: cachedFetchData.headers,
                        status: cachedFetchData.status
                    });
                    Object.defineProperty(response, 'url', {
                        value: cachedFetchData.url
                    });
                    return response;
                }
            }
            if (workStore.isStaticGeneration && init && typeof init === 'object') {
                const { cache } = init;
                // Delete `cache` property as Cloudflare Workers will throw an error
                if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
                ;
                if (cache === 'no-store') {
                    // If enabled, we should bail out of static generation.
                    if (workUnitStore) {
                        switch(workUnitStore.type){
                            case 'prerender':
                            case 'prerender-client':
                                if (cacheSignal) {
                                    cacheSignal.endRead();
                                    cacheSignal = null;
                                }
                                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$dynamic$2d$rendering$2d$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["makeHangingPromise"])(workUnitStore.renderSignal, 'fetch()');
                            default:
                        }
                    }
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$dynamic$2d$rendering$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["markCurrentScopeAsDynamic"])(workStore, workUnitStore, `no-store fetch ${input} ${workStore.route}`);
                }
                const hasNextConfig = 'next' in init;
                const { next = {} } = init;
                if (typeof next.revalidate === 'number' && revalidateStore && next.revalidate < revalidateStore.revalidate) {
                    if (next.revalidate === 0) {
                        // If enabled, we should bail out of static generation.
                        if (workUnitStore) {
                            switch(workUnitStore.type){
                                case 'prerender':
                                case 'prerender-client':
                                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$dynamic$2d$rendering$2d$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["makeHangingPromise"])(workUnitStore.renderSignal, 'fetch()');
                                default:
                            }
                        }
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$dynamic$2d$rendering$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["markCurrentScopeAsDynamic"])(workStore, workUnitStore, `revalidate: 0 fetch ${input} ${workStore.route}`);
                    }
                    if (!workStore.forceStatic || next.revalidate !== 0) {
                        revalidateStore.revalidate = next.revalidate;
                    }
                }
                if (hasNextConfig) delete init.next;
            }
            // if we are revalidating the whole page via time or on-demand and
            // the fetch cache entry is stale we should still de-dupe the
            // origin hit if it's a cache-able entry
            if (cacheKey && isForegroundRevalidate) {
                const pendingRevalidateKey = cacheKey;
                workStore.pendingRevalidates ??= {};
                let pendingRevalidate = workStore.pendingRevalidates[pendingRevalidateKey];
                if (pendingRevalidate) {
                    const revalidatedResult = await pendingRevalidate;
                    return new Response(revalidatedResult.body, {
                        headers: revalidatedResult.headers,
                        status: revalidatedResult.status,
                        statusText: revalidatedResult.statusText
                    });
                }
                // We used to just resolve the Response and clone it however for
                // static generation with dynamicIO we need the response to be able to
                // be resolved in a microtask and cloning the response will never have
                // a body that can resolve in a microtask in node (as observed through
                // experimentation) So instead we await the body and then when it is
                // available we construct manually cloned Response objects with the
                // body as an ArrayBuffer. This will be resolvable in a microtask
                // making it compatible with dynamicIO.
                const pendingResponse = doOriginalFetch(true, cacheReasonOverride) // We're cloning the response using this utility because there
                // exists a bug in the undici library around response cloning.
                // See the following pull request for more details:
                // https://github.com/vercel/next.js/pull/73274
                .then(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$clone$2d$response$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["cloneResponse"]);
                pendingRevalidate = pendingResponse.then(async (responses)=>{
                    const response = responses[0];
                    return {
                        body: await response.arrayBuffer(),
                        headers: response.headers,
                        status: response.status,
                        statusText: response.statusText
                    };
                }).finally(()=>{
                    var _workStore_pendingRevalidates;
                    // If the pending revalidate is not present in the store, then
                    // we have nothing to delete.
                    if (!((_workStore_pendingRevalidates = workStore.pendingRevalidates) == null ? void 0 : _workStore_pendingRevalidates[pendingRevalidateKey])) {
                        return;
                    }
                    delete workStore.pendingRevalidates[pendingRevalidateKey];
                });
                // Attach the empty catch here so we don't get a "unhandled promise
                // rejection" warning
                pendingRevalidate.catch(()=>{});
                workStore.pendingRevalidates[pendingRevalidateKey] = pendingRevalidate;
                return pendingResponse.then((responses)=>responses[1]);
            } else {
                return doOriginalFetch(false, cacheReasonOverride);
            }
        });
        if (cacheSignal) {
            try {
                return await result;
            } finally{
                if (cacheSignal) {
                    cacheSignal.endRead();
                }
            }
        }
        return result;
    };
    // Attach the necessary properties to the patched fetch function.
    // We don't use this to determine if the fetch function has been patched,
    // but for external consumers to determine if the fetch function has been
    // patched.
    patched.__nextPatched = true;
    patched.__nextGetStaticStore = ()=>workAsyncStorage;
    patched._nextOriginalFetch = originFetch;
    globalThis[NEXT_PATCH_SYMBOL] = true;
    // Assign the function name also as a name property, so that it's preserved
    // even when mangling is enabled.
    Object.defineProperty(patched, 'name', {
        value: 'fetch',
        writable: false
    });
    return patched;
}
function patchFetch(options) {
    // If we've already patched fetch, we should not patch it again.
    if (isFetchPatched()) return;
    // Grab the original fetch function. We'll attach this so we can use it in
    // the patched fetch function.
    const original = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$dedupe$2d$fetch$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createDedupeFetch"])(globalThis.fetch);
    // Set the global fetch to the patched fetch.
    globalThis.fetch = createPatchedFetcher(original, options);
} //# sourceMappingURL=patch-fetch.js.map
}),
"[project]/node_modules/next/dist/esm/next-devtools/userspace/app/segment-explorer-node.js [app-rsc] (client reference proxy) <module evaluation>": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const { createClientModuleProxy } = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-server-dom-turbopack-server.js [app-rsc] (ecmascript)");
__turbopack_context__.n(createClientModuleProxy("[project]/node_modules/next/dist/esm/next-devtools/userspace/app/segment-explorer-node.js <module evaluation>"));
}}),
"[project]/node_modules/next/dist/esm/next-devtools/userspace/app/segment-explorer-node.js [app-rsc] (client reference proxy)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const { createClientModuleProxy } = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-server-dom-turbopack-server.js [app-rsc] (ecmascript)");
__turbopack_context__.n(createClientModuleProxy("[project]/node_modules/next/dist/esm/next-devtools/userspace/app/segment-explorer-node.js"));
}}),
"[project]/node_modules/next/dist/esm/next-devtools/userspace/app/segment-explorer-node.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$next$2d$devtools$2f$userspace$2f$app$2f$segment$2d$explorer$2d$node$2e$js__$5b$app$2d$rsc$5d$__$28$client__reference__proxy$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/next-devtools/userspace/app/segment-explorer-node.js [app-rsc] (client reference proxy) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$next$2d$devtools$2f$userspace$2f$app$2f$segment$2d$explorer$2d$node$2e$js__$5b$app$2d$rsc$5d$__$28$client__reference__proxy$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/next-devtools/userspace/app/segment-explorer-node.js [app-rsc] (client reference proxy)");
;
__turbopack_context__.n(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$next$2d$devtools$2f$userspace$2f$app$2f$segment$2d$explorer$2d$node$2e$js__$5b$app$2d$rsc$5d$__$28$client__reference__proxy$29$__);
}),
"[project]/node_modules/next/dist/esm/server/app-render/entry-base.js [app-rsc] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

// eslint-disable-next-line import/no-extraneous-dependencies
__turbopack_context__.s({
    "SegmentViewNode": ()=>SegmentViewNode,
    "SegmentViewStateNode": ()=>SegmentViewStateNode,
    "patchFetch": ()=>patchFetch
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$server$2d$dom$2d$turbopack$2d$server$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-server-dom-turbopack-server.js [app-rsc] (ecmascript)");
// eslint-disable-next-line import/no-extraneous-dependencies
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$server$2d$dom$2d$turbopack$2d$static$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-server-dom-turbopack-static.js [app-rsc] (ecmascript)");
// eslint-disable-next-line import/no-extraneous-dependencies
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$layout$2d$router$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/client/components/layout-router.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$render$2d$from$2d$template$2d$context$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/client/components/render-from-template-context.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$async$2d$storage$2e$external$2e$js__$5b$external$5d$__$28$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$async$2d$storage$2e$external$2e$js$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$unit$2d$async$2d$storage$2e$external$2e$js__$5b$external$5d$__$28$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$unit$2d$async$2d$storage$2e$external$2e$js$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$next$2f$dist$2f$server$2f$app$2d$render$2f$action$2d$async$2d$storage$2e$external$2e$js__$5b$external$5d$__$28$next$2f$dist$2f$server$2f$app$2d$render$2f$action$2d$async$2d$storage$2e$external$2e$js$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/next/dist/server/app-render/action-async-storage.external.js [external] (next/dist/server/app-render/action-async-storage.external.js, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$client$2d$page$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/client/components/client-page.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$client$2d$segment$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/client/components/client-segment.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2f$search$2d$params$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/request/search-params.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2f$params$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/request/params.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$hooks$2d$server$2d$context$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/client/components/hooks-server-context.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$http$2d$access$2d$fallback$2f$error$2d$boundary$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/client/components/http-access-fallback/error-boundary.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$metadata$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/metadata/metadata.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$metadata$2f$metadata$2d$boundary$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/client/components/metadata/metadata-boundary.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$rsc$2f$preloads$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/app-render/rsc/preloads.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$rsc$2f$postpone$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/app-render/rsc/postpone.js [app-rsc] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$rsc$2f$taint$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/app-render/rsc/taint.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$collect$2d$segment$2d$data$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/app-render/collect-segment-data.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$patch$2d$fetch$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/lib/patch-fetch.js [app-rsc] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
let SegmentViewNode = ()=>null;
let SegmentViewStateNode = ()=>null;
if ("TURBOPACK compile-time truthy", 1) {
    const mod = __turbopack_context__.r("[project]/node_modules/next/dist/esm/next-devtools/userspace/app/segment-explorer-node.js [app-rsc] (ecmascript)");
    SegmentViewNode = mod.SegmentViewNode;
    SegmentViewStateNode = mod.SegmentViewStateNode;
}
function patchFetch() {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$patch$2d$fetch$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["patchFetch"])({
        workAsyncStorage: __TURBOPACK__imported__module__$5b$externals$5d2f$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$async$2d$storage$2e$external$2e$js__$5b$external$5d$__$28$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$async$2d$storage$2e$external$2e$js$2c$__cjs$29$__["workAsyncStorage"],
        workUnitAsyncStorage: __TURBOPACK__imported__module__$5b$externals$5d2f$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$unit$2d$async$2d$storage$2e$external$2e$js__$5b$external$5d$__$28$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$unit$2d$async$2d$storage$2e$external$2e$js$2c$__cjs$29$__["workUnitAsyncStorage"]
    });
}
;
 //# sourceMappingURL=entry-base.js.map
}),
"[project]/node_modules/next/dist/esm/server/app-render/entry-base.js [app-rsc] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$server$2d$dom$2d$turbopack$2d$server$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-server-dom-turbopack-server.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$server$2d$dom$2d$turbopack$2d$static$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-server-dom-turbopack-static.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$layout$2d$router$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/client/components/layout-router.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$render$2d$from$2d$template$2d$context$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/client/components/render-from-template-context.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$async$2d$storage$2e$external$2e$js__$5b$external$5d$__$28$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$async$2d$storage$2e$external$2e$js$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$unit$2d$async$2d$storage$2e$external$2e$js__$5b$external$5d$__$28$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$unit$2d$async$2d$storage$2e$external$2e$js$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$next$2f$dist$2f$server$2f$app$2d$render$2f$action$2d$async$2d$storage$2e$external$2e$js__$5b$external$5d$__$28$next$2f$dist$2f$server$2f$app$2d$render$2f$action$2d$async$2d$storage$2e$external$2e$js$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/next/dist/server/app-render/action-async-storage.external.js [external] (next/dist/server/app-render/action-async-storage.external.js, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$client$2d$page$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/client/components/client-page.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$client$2d$segment$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/client/components/client-segment.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2f$search$2d$params$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/request/search-params.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2f$params$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/request/params.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$hooks$2d$server$2d$context$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/client/components/hooks-server-context.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$http$2d$access$2d$fallback$2f$error$2d$boundary$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/client/components/http-access-fallback/error-boundary.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$metadata$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/metadata/metadata.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$metadata$2f$metadata$2d$boundary$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/client/components/metadata/metadata-boundary.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$rsc$2f$preloads$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/app-render/rsc/preloads.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$rsc$2f$postpone$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/app-render/rsc/postpone.js [app-rsc] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$rsc$2f$taint$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/app-render/rsc/taint.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$collect$2d$segment$2d$data$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/app-render/collect-segment-data.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$patch$2d$fetch$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/lib/patch-fetch.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/app-render/entry-base.js [app-rsc] (ecmascript) <locals>");
}),
"[project]/node_modules/next/dist/esm/server/app-render/entry-base.js [app-rsc] (ecmascript) <exports>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "ClientPageRoot": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$client$2d$page$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ClientPageRoot"],
    "ClientSegmentRoot": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$client$2d$segment$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ClientSegmentRoot"],
    "HTTPAccessFallbackBoundary": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$http$2d$access$2d$fallback$2f$error$2d$boundary$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["HTTPAccessFallbackBoundary"],
    "LayoutRouter": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$layout$2d$router$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"],
    "MetadataBoundary": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$metadata$2f$metadata$2d$boundary$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["MetadataBoundary"],
    "OutletBoundary": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$metadata$2f$metadata$2d$boundary$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["OutletBoundary"],
    "Postpone": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$dynamic$2d$rendering$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Postpone"],
    "RenderFromTemplateContext": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$render$2d$from$2d$template$2d$context$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"],
    "SegmentViewNode": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["SegmentViewNode"],
    "SegmentViewStateNode": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["SegmentViewStateNode"],
    "ViewportBoundary": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$metadata$2f$metadata$2d$boundary$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ViewportBoundary"],
    "actionAsyncStorage": ()=>__TURBOPACK__imported__module__$5b$externals$5d2f$next$2f$dist$2f$server$2f$app$2d$render$2f$action$2d$async$2d$storage$2e$external$2e$js__$5b$external$5d$__$28$next$2f$dist$2f$server$2f$app$2d$render$2f$action$2d$async$2d$storage$2e$external$2e$js$2c$__cjs$29$__["actionAsyncStorage"],
    "captureOwnerStack": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["captureOwnerStack"],
    "collectSegmentData": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$collect$2d$segment$2d$data$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["collectSegmentData"],
    "createMetadataComponents": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$metadata$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMetadataComponents"],
    "createPrerenderParamsForClientSegment": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2f$params$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createPrerenderParamsForClientSegment"],
    "createPrerenderSearchParamsForClientPage": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2f$search$2d$params$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createPrerenderSearchParamsForClientPage"],
    "createServerParamsForServerSegment": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2f$params$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createServerParamsForServerSegment"],
    "createServerSearchParamsForServerPage": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2f$search$2d$params$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createServerSearchParamsForServerPage"],
    "createTemporaryReferenceSet": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$server$2d$dom$2d$turbopack$2d$server$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createTemporaryReferenceSet"],
    "decodeAction": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$server$2d$dom$2d$turbopack$2d$server$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["decodeAction"],
    "decodeFormState": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$server$2d$dom$2d$turbopack$2d$server$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["decodeFormState"],
    "decodeReply": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$server$2d$dom$2d$turbopack$2d$server$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["decodeReply"],
    "patchFetch": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["patchFetch"],
    "preconnect": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$rsc$2f$preloads$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["preconnect"],
    "preloadFont": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$rsc$2f$preloads$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["preloadFont"],
    "preloadStyle": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$rsc$2f$preloads$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["preloadStyle"],
    "prerender": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$server$2d$dom$2d$turbopack$2d$static$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["unstable_prerender"],
    "renderToReadableStream": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$server$2d$dom$2d$turbopack$2d$server$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["renderToReadableStream"],
    "serverHooks": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$hooks$2d$server$2d$context$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__,
    "taintObjectReference": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$rsc$2f$taint$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["taintObjectReference"],
    "workAsyncStorage": ()=>__TURBOPACK__imported__module__$5b$externals$5d2f$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$async$2d$storage$2e$external$2e$js__$5b$external$5d$__$28$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$async$2d$storage$2e$external$2e$js$2c$__cjs$29$__["workAsyncStorage"],
    "workUnitAsyncStorage": ()=>__TURBOPACK__imported__module__$5b$externals$5d2f$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$unit$2d$async$2d$storage$2e$external$2e$js__$5b$external$5d$__$28$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$unit$2d$async$2d$storage$2e$external$2e$js$2c$__cjs$29$__["workUnitAsyncStorage"]
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$server$2d$dom$2d$turbopack$2d$server$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-server-dom-turbopack-server.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$server$2d$dom$2d$turbopack$2d$static$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-server-dom-turbopack-static.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$layout$2d$router$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/client/components/layout-router.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$render$2d$from$2d$template$2d$context$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/client/components/render-from-template-context.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$async$2d$storage$2e$external$2e$js__$5b$external$5d$__$28$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$async$2d$storage$2e$external$2e$js$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$unit$2d$async$2d$storage$2e$external$2e$js__$5b$external$5d$__$28$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$unit$2d$async$2d$storage$2e$external$2e$js$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$next$2f$dist$2f$server$2f$app$2d$render$2f$action$2d$async$2d$storage$2e$external$2e$js__$5b$external$5d$__$28$next$2f$dist$2f$server$2f$app$2d$render$2f$action$2d$async$2d$storage$2e$external$2e$js$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/next/dist/server/app-render/action-async-storage.external.js [external] (next/dist/server/app-render/action-async-storage.external.js, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$client$2d$page$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/client/components/client-page.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$client$2d$segment$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/client/components/client-segment.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2f$search$2d$params$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/request/search-params.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2f$params$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/request/params.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$hooks$2d$server$2d$context$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/client/components/hooks-server-context.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$http$2d$access$2d$fallback$2f$error$2d$boundary$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/client/components/http-access-fallback/error-boundary.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$metadata$2f$metadata$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/metadata/metadata.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$metadata$2f$metadata$2d$boundary$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/client/components/metadata/metadata-boundary.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$rsc$2f$preloads$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/app-render/rsc/preloads.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$dynamic$2d$rendering$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/app-render/dynamic-rendering.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$rsc$2f$taint$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/app-render/rsc/taint.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$collect$2d$segment$2d$data$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/app-render/collect-segment-data.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/app-render/entry-base.js [app-rsc] (ecmascript) <locals>");
}),
"[project]/node_modules/next/dist/esm/server/app-render/entry-base.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "ClientPageRoot": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$exports$3e$__["ClientPageRoot"],
    "ClientSegmentRoot": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$exports$3e$__["ClientSegmentRoot"],
    "HTTPAccessFallbackBoundary": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$exports$3e$__["HTTPAccessFallbackBoundary"],
    "LayoutRouter": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$exports$3e$__["LayoutRouter"],
    "MetadataBoundary": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$exports$3e$__["MetadataBoundary"],
    "OutletBoundary": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$exports$3e$__["OutletBoundary"],
    "Postpone": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$exports$3e$__["Postpone"],
    "RenderFromTemplateContext": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$exports$3e$__["RenderFromTemplateContext"],
    "SegmentViewNode": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$exports$3e$__["SegmentViewNode"],
    "SegmentViewStateNode": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$exports$3e$__["SegmentViewStateNode"],
    "ViewportBoundary": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$exports$3e$__["ViewportBoundary"],
    "actionAsyncStorage": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$exports$3e$__["actionAsyncStorage"],
    "captureOwnerStack": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$exports$3e$__["captureOwnerStack"],
    "collectSegmentData": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$exports$3e$__["collectSegmentData"],
    "createMetadataComponents": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$exports$3e$__["createMetadataComponents"],
    "createPrerenderParamsForClientSegment": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$exports$3e$__["createPrerenderParamsForClientSegment"],
    "createPrerenderSearchParamsForClientPage": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$exports$3e$__["createPrerenderSearchParamsForClientPage"],
    "createServerParamsForServerSegment": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$exports$3e$__["createServerParamsForServerSegment"],
    "createServerSearchParamsForServerPage": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$exports$3e$__["createServerSearchParamsForServerPage"],
    "createTemporaryReferenceSet": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$exports$3e$__["createTemporaryReferenceSet"],
    "decodeAction": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$exports$3e$__["decodeAction"],
    "decodeFormState": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$exports$3e$__["decodeFormState"],
    "decodeReply": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$exports$3e$__["decodeReply"],
    "patchFetch": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$exports$3e$__["patchFetch"],
    "preconnect": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$exports$3e$__["preconnect"],
    "preloadFont": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$exports$3e$__["preloadFont"],
    "preloadStyle": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$exports$3e$__["preloadStyle"],
    "prerender": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$exports$3e$__["prerender"],
    "renderToReadableStream": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$exports$3e$__["renderToReadableStream"],
    "serverHooks": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$exports$3e$__["serverHooks"],
    "taintObjectReference": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$exports$3e$__["taintObjectReference"],
    "workAsyncStorage": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$exports$3e$__["workAsyncStorage"],
    "workUnitAsyncStorage": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$exports$3e$__["workUnitAsyncStorage"]
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/app-render/entry-base.js [app-rsc] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$exports$3e$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/app-render/entry-base.js [app-rsc] (ecmascript) <exports>");
}),

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFtdLAogICJzZWN0aW9ucyI6IFsKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL3NlcnZlci9yb3V0ZS1raW5kLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBlbnVtIFJvdXRlS2luZCB7XG4gIC8qKlxuICAgKiBgUEFHRVNgIHJlcHJlc2VudHMgYWxsIHRoZSBSZWFjdCBwYWdlcyB0aGF0IGFyZSB1bmRlciBgcGFnZXMvYC5cbiAgICovXG4gIFBBR0VTID0gJ1BBR0VTJyxcbiAgLyoqXG4gICAqIGBQQUdFU19BUElgIHJlcHJlc2VudHMgYWxsIHRoZSBBUEkgcm91dGVzIHVuZGVyIGBwYWdlcy9hcGkvYC5cbiAgICovXG4gIFBBR0VTX0FQSSA9ICdQQUdFU19BUEknLFxuICAvKipcbiAgICogYEFQUF9QQUdFYCByZXByZXNlbnRzIGFsbCB0aGUgUmVhY3QgcGFnZXMgdGhhdCBhcmUgdW5kZXIgYGFwcC9gIHdpdGggdGhlXG4gICAqIGZpbGVuYW1lIG9mIGBwYWdlLntqLHR9c3sseH1gLlxuICAgKi9cbiAgQVBQX1BBR0UgPSAnQVBQX1BBR0UnLFxuICAvKipcbiAgICogYEFQUF9ST1VURWAgcmVwcmVzZW50cyBhbGwgdGhlIEFQSSByb3V0ZXMgYW5kIG1ldGFkYXRhIHJvdXRlcyB0aGF0IGFyZSB1bmRlciBgYXBwL2Agd2l0aCB0aGVcbiAgICogZmlsZW5hbWUgb2YgYHJvdXRlLntqLHR9c3sseH1gLlxuICAgKi9cbiAgQVBQX1JPVVRFID0gJ0FQUF9ST1VURScsXG5cbiAgLyoqXG4gICAqIGBJTUFHRWAgcmVwcmVzZW50cyBhbGwgdGhlIGltYWdlcyB0aGF0IGFyZSBnZW5lcmF0ZWQgYnkgYG5leHQvaW1hZ2VgLlxuICAgKi9cbiAgSU1BR0UgPSAnSU1BR0UnLFxufVxuIl0sIm5hbWVzIjpbIlJvdXRlS2luZCJdLCJtYXBwaW5ncyI6Ijs7O0FBQU8sSUFBV0EsWUFBQUEsV0FBQUEsR0FBQUEsU0FBQUEsU0FBQUE7SUFDaEI7O0dBRUMsR0FBQSxTQUFBLENBQUEsUUFBQSxHQUFBO0lBRUQ7O0dBRUMsR0FBQSxTQUFBLENBQUEsWUFBQSxHQUFBO0lBRUQ7OztHQUdDLEdBQUEsU0FBQSxDQUFBLFdBQUEsR0FBQTtJQUVEOzs7R0FHQyxHQUFBLFNBQUEsQ0FBQSxZQUFBLEdBQUE7SUFHRDs7R0FFQyxHQUFBLFNBQUEsQ0FBQSxRQUFBLEdBQUE7V0F0QmVBO01Bd0JqQiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAzNCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9zZXJ2ZXIvcm91dGUtbW9kdWxlcy9hcHAtcGFnZS9tb2R1bGUuY29tcGlsZWQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaWYgKHByb2Nlc3MuZW52Lk5FWFRfUlVOVElNRSA9PT0gJ2VkZ2UnKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnbmV4dC9kaXN0L3NlcnZlci9yb3V0ZS1tb2R1bGVzL2FwcC1wYWdlL21vZHVsZS5qcycpXG59IGVsc2Uge1xuICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0VYUEVSSU1FTlRBTF9SRUFDVCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgaWYgKHByb2Nlc3MuZW52LlRVUkJPUEFDSykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ25leHQvZGlzdC9jb21waWxlZC9uZXh0LXNlcnZlci9hcHAtcGFnZS10dXJiby1leHBlcmltZW50YWwucnVudGltZS5kZXYuanMnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCduZXh0L2Rpc3QvY29tcGlsZWQvbmV4dC1zZXJ2ZXIvYXBwLXBhZ2UtZXhwZXJpbWVudGFsLnJ1bnRpbWUuZGV2LmpzJylcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb2Nlc3MuZW52LlRVUkJPUEFDSykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ25leHQvZGlzdC9jb21waWxlZC9uZXh0LXNlcnZlci9hcHAtcGFnZS10dXJiby1leHBlcmltZW50YWwucnVudGltZS5wcm9kLmpzJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnbmV4dC9kaXN0L2NvbXBpbGVkL25leHQtc2VydmVyL2FwcC1wYWdlLWV4cGVyaW1lbnRhbC5ydW50aW1lLnByb2QuanMnKVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5UVVJCT1BBQ0spIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCduZXh0L2Rpc3QvY29tcGlsZWQvbmV4dC1zZXJ2ZXIvYXBwLXBhZ2UtdHVyYm8ucnVudGltZS5kZXYuanMnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCduZXh0L2Rpc3QvY29tcGlsZWQvbmV4dC1zZXJ2ZXIvYXBwLXBhZ2UucnVudGltZS5kZXYuanMnKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuVFVSQk9QQUNLKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnbmV4dC9kaXN0L2NvbXBpbGVkL25leHQtc2VydmVyL2FwcC1wYWdlLXR1cmJvLnJ1bnRpbWUucHJvZC5qcycpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ25leHQvZGlzdC9jb21waWxlZC9uZXh0LXNlcnZlci9hcHAtcGFnZS5ydW50aW1lLnByb2QuanMnKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJlbnYiLCJORVhUX1JVTlRJTUUiLCJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSIsIl9fTkVYVF9FWFBFUklNRU5UQUxfUkVBQ1QiLCJOT0RFX0VOViIsIlRVUkJPUEFDSyJdLCJtYXBwaW5ncyI6IkFBQUEsSUFBSUEsUUFBUUMsR0FBRyxDQUFDQyxZQUFZLEtBQUssUUFBUTs7S0FFbEM7SUFDTCxJQUFJRixRQUFRQyxHQUFHLENBQUNLLHlCQUF5QixFQUFFOztTQWNwQztRQUNMLElBQUlOLFFBQVFDLEdBQUcsQ0FBQ00sUUFBUSxLQUFLLFdBQWU7WUFDMUMsSUFBSVAsUUFBUUMsR0FBRyxDQUFDTyxTQUFTLGVBQUU7Z0JBQ3pCTCxPQUFPQyxPQUFPLEdBQUdDLFFBQVE7WUFDM0IsT0FBTzs7UUFHVCxPQUFPOztJQU9UO0FBQ0YiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNTUsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvc2VydmVyL3JvdXRlLW1vZHVsZXMvYXBwLXBhZ2UvdmVuZG9yZWQvcnNjL3JlYWN0LXNlcnZlci1kb20tdHVyYm9wYWNrLXNlcnZlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IChcbiAgcmVxdWlyZSgnLi4vLi4vbW9kdWxlLmNvbXBpbGVkJykgYXMgdHlwZW9mIGltcG9ydCgnLi4vLi4vbW9kdWxlLmNvbXBpbGVkJylcbikudmVuZG9yZWRbJ3JlYWN0LXJzYyddIS5SZWFjdFNlcnZlckRPTVR1cmJvcGFja1NlcnZlclxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIiwidmVuZG9yZWQiLCJSZWFjdFNlcnZlckRPTVR1cmJvcGFja1NlcnZlciJdLCJtYXBwaW5ncyI6IkFBQUFBLE9BQU9DLE9BQU8sR0FDWkMsUUFBUSw0SEFDUkMsUUFBUSxDQUFDLFlBQVksQ0FBRUMsNkJBQTZCIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDYyLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL3NlcnZlci9yb3V0ZS1tb2R1bGVzL2FwcC1wYWdlL3ZlbmRvcmVkL3JzYy9yZWFjdC1zZXJ2ZXItZG9tLXR1cmJvcGFjay1zdGF0aWMudHMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSAoXG4gIHJlcXVpcmUoJy4uLy4uL21vZHVsZS5jb21waWxlZCcpIGFzIHR5cGVvZiBpbXBvcnQoJy4uLy4uL21vZHVsZS5jb21waWxlZCcpXG4pLnZlbmRvcmVkWydyZWFjdC1yc2MnXSEuUmVhY3RTZXJ2ZXJET01UdXJib3BhY2tTdGF0aWNcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSIsInZlbmRvcmVkIiwiUmVhY3RTZXJ2ZXJET01UdXJib3BhY2tTdGF0aWMiXSwibWFwcGluZ3MiOiJBQUFBQSxPQUFPQyxPQUFPLEdBQ1pDLFFBQVEsNEhBQ1JDLFFBQVEsQ0FBQyxZQUFZLENBQUVDLDZCQUE2QiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA2OSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9zZXJ2ZXIvcm91dGUtbW9kdWxlcy9hcHAtcGFnZS92ZW5kb3JlZC9yc2MvcmVhY3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSAoXG4gIHJlcXVpcmUoJy4uLy4uL21vZHVsZS5jb21waWxlZCcpIGFzIHR5cGVvZiBpbXBvcnQoJy4uLy4uL21vZHVsZS5jb21waWxlZCcpXG4pLnZlbmRvcmVkWydyZWFjdC1yc2MnXSEuUmVhY3RcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSIsInZlbmRvcmVkIiwiUmVhY3QiXSwibWFwcGluZ3MiOiJBQUFBQSxPQUFPQyxPQUFPLEdBQ1pDLFFBQVEsNEhBQ1JDLFFBQVEsQ0FBQyxZQUFZLENBQUVDLEtBQUsiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNzUsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2VzbS9jbGllbnQvY29tcG9uZW50cy9sYXlvdXQtcm91dGVyLmpzL3Byb3h5LmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB7IGNyZWF0ZUNsaWVudE1vZHVsZVByb3h5IH0gPSByZXF1aXJlKFwicmVhY3Qtc2VydmVyLWRvbS10dXJib3BhY2svc2VydmVyXCIpO1xuXG5fX3R1cmJvcGFja19jb250ZXh0X18ubihjcmVhdGVDbGllbnRNb2R1bGVQcm94eShcIltwcm9qZWN0XS9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2VzbS9jbGllbnQvY29tcG9uZW50cy9sYXlvdXQtcm91dGVyLmpzIDxtb2R1bGUgZXZhbHVhdGlvbj5cIikpO1xuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE1BQU0sRUFBRSx1QkFBdUIsRUFBRTtBQUVqQyxzQkFBc0IsQ0FBQyxDQUFDLHdCQUF3QiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA4MiwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvZXNtL2NsaWVudC9jb21wb25lbnRzL2xheW91dC1yb3V0ZXIuanMvcHJveHkuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHsgY3JlYXRlQ2xpZW50TW9kdWxlUHJveHkgfSA9IHJlcXVpcmUoXCJyZWFjdC1zZXJ2ZXItZG9tLXR1cmJvcGFjay9zZXJ2ZXJcIik7XG5cbl9fdHVyYm9wYWNrX2NvbnRleHRfXy5uKGNyZWF0ZUNsaWVudE1vZHVsZVByb3h5KFwiW3Byb2plY3RdL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvZXNtL2NsaWVudC9jb21wb25lbnRzL2xheW91dC1yb3V0ZXIuanNcIikpO1xuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE1BQU0sRUFBRSx1QkFBdUIsRUFBRTtBQUVqQyxzQkFBc0IsQ0FBQyxDQUFDLHdCQUF3QiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA4OCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL2NsaWVudC9jb21wb25lbnRzL2xheW91dC1yb3V0ZXIudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuXG5pbXBvcnQgdHlwZSB7XG4gIENhY2hlTm9kZSxcbiAgTGF6eUNhY2hlTm9kZSxcbiAgTG9hZGluZ01vZHVsZURhdGEsXG59IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHR5cGUge1xuICBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgRmxpZ2h0U2VnbWVudFBhdGgsXG59IGZyb20gJy4uLy4uL3NlcnZlci9hcHAtcmVuZGVyL3R5cGVzJ1xuaW1wb3J0IHR5cGUgeyBFcnJvckNvbXBvbmVudCB9IGZyb20gJy4vZXJyb3ItYm91bmRhcnknXG5pbXBvcnQge1xuICBBQ1RJT05fU0VSVkVSX1BBVENILFxuICB0eXBlIEZvY3VzQW5kU2Nyb2xsUmVmLFxufSBmcm9tICcuL3JvdXRlci1yZWR1Y2VyL3JvdXRlci1yZWR1Y2VyLXR5cGVzJ1xuXG5pbXBvcnQgUmVhY3QsIHtcbiAgdXNlQ29udGV4dCxcbiAgdXNlLFxuICBzdGFydFRyYW5zaXRpb24sXG4gIFN1c3BlbnNlLFxuICB1c2VEZWZlcnJlZFZhbHVlLFxuICB0eXBlIEpTWCxcbn0gZnJvbSAncmVhY3QnXG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJ1xuaW1wb3J0IHtcbiAgTGF5b3V0Um91dGVyQ29udGV4dCxcbiAgR2xvYmFsTGF5b3V0Um91dGVyQ29udGV4dCxcbiAgVGVtcGxhdGVDb250ZXh0LFxufSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB7IGZldGNoU2VydmVyUmVzcG9uc2UgfSBmcm9tICcuL3JvdXRlci1yZWR1Y2VyL2ZldGNoLXNlcnZlci1yZXNwb25zZSdcbmltcG9ydCB7IHVucmVzb2x2ZWRUaGVuYWJsZSB9IGZyb20gJy4vdW5yZXNvbHZlZC10aGVuYWJsZSdcbmltcG9ydCB7IEVycm9yQm91bmRhcnkgfSBmcm9tICcuL2Vycm9yLWJvdW5kYXJ5J1xuaW1wb3J0IHsgbWF0Y2hTZWdtZW50IH0gZnJvbSAnLi9tYXRjaC1zZWdtZW50cydcbmltcG9ydCB7IGRpc2FibGVTbW9vdGhTY3JvbGxEdXJpbmdSb3V0ZVRyYW5zaXRpb24gfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9kaXNhYmxlLXNtb290aC1zY3JvbGwnXG5pbXBvcnQgeyBSZWRpcmVjdEJvdW5kYXJ5IH0gZnJvbSAnLi9yZWRpcmVjdC1ib3VuZGFyeSdcbmltcG9ydCB7IEhUVFBBY2Nlc3NGYWxsYmFja0JvdW5kYXJ5IH0gZnJvbSAnLi9odHRwLWFjY2Vzcy1mYWxsYmFjay9lcnJvci1ib3VuZGFyeSdcbmltcG9ydCB7IGNyZWF0ZVJvdXRlckNhY2hlS2V5IH0gZnJvbSAnLi9yb3V0ZXItcmVkdWNlci9jcmVhdGUtcm91dGVyLWNhY2hlLWtleSdcbmltcG9ydCB7IGhhc0ludGVyY2VwdGlvblJvdXRlSW5DdXJyZW50VHJlZSB9IGZyb20gJy4vcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvaGFzLWludGVyY2VwdGlvbi1yb3V0ZS1pbi1jdXJyZW50LXRyZWUnXG5pbXBvcnQgeyBkaXNwYXRjaEFwcFJvdXRlckFjdGlvbiB9IGZyb20gJy4vdXNlLWFjdGlvbi1xdWV1ZSdcbmltcG9ydCB7IHVzZVJvdXRlckJGQ2FjaGUsIHR5cGUgUm91dGVyQkZDYWNoZUVudHJ5IH0gZnJvbSAnLi9iZmNhY2hlJ1xuaW1wb3J0IHsgbm9ybWFsaXplQXBwUGF0aCB9IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2FwcC1wYXRocydcblxuY29uc3QgQWN0aXZpdHkgPSBwcm9jZXNzLmVudi5fX05FWFRfUk9VVEVSX0JGX0NBQ0hFXG4gID8gKHJlcXVpcmUoJ3JlYWN0JykgYXMgdHlwZW9mIGltcG9ydCgncmVhY3QnKSkudW5zdGFibGVfQWN0aXZpdHlcbiAgOiBudWxsIVxuXG4vKipcbiAqIEFkZCByZWZldGNoIG1hcmtlciB0byByb3V0ZXIgc3RhdGUgYXQgdGhlIHBvaW50IG9mIHRoZSBjdXJyZW50IGxheW91dCBzZWdtZW50LlxuICogVGhpcyBlbnN1cmVzIHRoZSByZXNwb25zZSByZXR1cm5lZCBpcyBub3QgZnVydGhlciBkb3duIHRoYW4gdGhlIGN1cnJlbnQgbGF5b3V0IHNlZ21lbnQuXG4gKi9cbmZ1bmN0aW9uIHdhbGtBZGRSZWZldGNoKFxuICBzZWdtZW50UGF0aFRvV2FsazogRmxpZ2h0U2VnbWVudFBhdGggfCB1bmRlZmluZWQsXG4gIHRyZWVUb1JlY3JlYXRlOiBGbGlnaHRSb3V0ZXJTdGF0ZVxuKTogRmxpZ2h0Um91dGVyU3RhdGUge1xuICBpZiAoc2VnbWVudFBhdGhUb1dhbGspIHtcbiAgICBjb25zdCBbc2VnbWVudCwgcGFyYWxsZWxSb3V0ZUtleV0gPSBzZWdtZW50UGF0aFRvV2Fsa1xuICAgIGNvbnN0IGlzTGFzdCA9IHNlZ21lbnRQYXRoVG9XYWxrLmxlbmd0aCA9PT0gMlxuXG4gICAgaWYgKG1hdGNoU2VnbWVudCh0cmVlVG9SZWNyZWF0ZVswXSwgc2VnbWVudCkpIHtcbiAgICAgIGlmICh0cmVlVG9SZWNyZWF0ZVsxXS5oYXNPd25Qcm9wZXJ0eShwYXJhbGxlbFJvdXRlS2V5KSkge1xuICAgICAgICBpZiAoaXNMYXN0KSB7XG4gICAgICAgICAgY29uc3Qgc3ViVHJlZSA9IHdhbGtBZGRSZWZldGNoKFxuICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgdHJlZVRvUmVjcmVhdGVbMV1bcGFyYWxsZWxSb3V0ZUtleV1cbiAgICAgICAgICApXG4gICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHRyZWVUb1JlY3JlYXRlWzBdLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAuLi50cmVlVG9SZWNyZWF0ZVsxXSxcbiAgICAgICAgICAgICAgW3BhcmFsbGVsUm91dGVLZXldOiBbXG4gICAgICAgICAgICAgICAgc3ViVHJlZVswXSxcbiAgICAgICAgICAgICAgICBzdWJUcmVlWzFdLFxuICAgICAgICAgICAgICAgIHN1YlRyZWVbMl0sXG4gICAgICAgICAgICAgICAgJ3JlZmV0Y2gnLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICBdXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIHRyZWVUb1JlY3JlYXRlWzBdLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC4uLnRyZWVUb1JlY3JlYXRlWzFdLFxuICAgICAgICAgICAgW3BhcmFsbGVsUm91dGVLZXldOiB3YWxrQWRkUmVmZXRjaChcbiAgICAgICAgICAgICAgc2VnbWVudFBhdGhUb1dhbGsuc2xpY2UoMiksXG4gICAgICAgICAgICAgIHRyZWVUb1JlY3JlYXRlWzFdW3BhcmFsbGVsUm91dGVLZXldXG4gICAgICAgICAgICApLFxuICAgICAgICAgIH0sXG4gICAgICAgIF1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJlZVRvUmVjcmVhdGVcbn1cblxuY29uc3QgX19ET01fSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfV0FSTl9VU0VSU19USEVZX0NBTk5PVF9VUEdSQURFID0gKFxuICBSZWFjdERPTSBhcyBhbnlcbikuX19ET01fSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfV0FSTl9VU0VSU19USEVZX0NBTk5PVF9VUEdSQURFXG5cbi8vIFRPRE8tQVBQOiBSZXBsYWNlIHdpdGggbmV3IFJlYWN0IEFQSSBmb3IgZmluZGluZyBkb20gbm9kZXMgd2l0aG91dCBhIGByZWZgIHdoZW4gYXZhaWxhYmxlXG4vKipcbiAqIFdyYXBzIFJlYWN0RE9NLmZpbmRET01Ob2RlIHdpdGggYWRkaXRpb25hbCBsb2dpYyB0byBoaWRlIFJlYWN0IFN0cmljdCBNb2RlIHdhcm5pbmdcbiAqL1xuZnVuY3Rpb24gZmluZERPTU5vZGUoXG4gIGluc3RhbmNlOiBSZWFjdC5SZWFjdEluc3RhbmNlIHwgbnVsbCB8IHVuZGVmaW5lZFxuKTogRWxlbWVudCB8IFRleHQgfCBudWxsIHtcbiAgLy8gVHJlZS1zaGFrZSBmb3Igc2VydmVyIGJ1bmRsZVxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBudWxsXG5cbiAgLy8gX19ET01fSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfV0FSTl9VU0VSU19USEVZX0NBTk5PVF9VUEdSQURFLmZpbmRET01Ob2RlIGlzIG51bGwgZHVyaW5nIG1vZHVsZSBpbml0LlxuICAvLyBXZSBuZWVkIHRvIGxhemlseSByZWZlcmVuY2UgaXQuXG4gIGNvbnN0IGludGVybmFsX3JlYWN0RE9NZmluZERPTU5vZGUgPVxuICAgIF9fRE9NX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERS5maW5kRE9NTm9kZVxuICByZXR1cm4gaW50ZXJuYWxfcmVhY3RET01maW5kRE9NTm9kZShpbnN0YW5jZSlcbn1cblxuY29uc3QgcmVjdFByb3BlcnRpZXMgPSBbXG4gICdib3R0b20nLFxuICAnaGVpZ2h0JyxcbiAgJ2xlZnQnLFxuICAncmlnaHQnLFxuICAndG9wJyxcbiAgJ3dpZHRoJyxcbiAgJ3gnLFxuICAneScsXG5dIGFzIGNvbnN0XG4vKipcbiAqIENoZWNrIGlmIGEgSFRNTEVsZW1lbnQgaXMgaGlkZGVuIG9yIGZpeGVkL3N0aWNreSBwb3NpdGlvblxuICovXG5mdW5jdGlvbiBzaG91bGRTa2lwRWxlbWVudChlbGVtZW50OiBIVE1MRWxlbWVudCkge1xuICAvLyB3ZSBpZ25vcmUgZml4ZWQgb3Igc3RpY2t5IHBvc2l0aW9uZWQgZWxlbWVudHMgc2luY2UgdGhleSdsbCBsaWtlbHkgcGFzcyB0aGUgXCJpbi12aWV3cG9ydFwiIGNoZWNrXG4gIC8vIGFuZCB3aWxsIHJlc3VsdCBpbiBhIHNpdHVhdGlvbiB3ZSBiYWlsIG9uIHNjcm9sbCBiZWNhdXNlIG9mIHNvbWV0aGluZyBsaWtlIGEgZml4ZWQgbmF2LFxuICAvLyBldmVuIHRob3VnaCB0aGUgYWN0dWFsIHBhZ2UgY29udGVudCBpcyBvZmZzY3JlZW5cbiAgaWYgKFsnc3RpY2t5JywgJ2ZpeGVkJ10uaW5jbHVkZXMoZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbikpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgJ1NraXBwaW5nIGF1dG8tc2Nyb2xsIGJlaGF2aW9yIGR1ZSB0byBgcG9zaXRpb246IHN0aWNreWAgb3IgYHBvc2l0aW9uOiBmaXhlZGAgb24gZWxlbWVudDonLFxuICAgICAgICBlbGVtZW50XG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvLyBVc2VzIGBnZXRCb3VuZGluZ0NsaWVudFJlY3RgIHRvIGNoZWNrIGlmIHRoZSBlbGVtZW50IGlzIGhpZGRlbiBpbnN0ZWFkIG9mIGBvZmZzZXRQYXJlbnRgXG4gIC8vIGJlY2F1c2UgYG9mZnNldFBhcmVudGAgZG9lc24ndCBjb25zaWRlciBkb2N1bWVudC9ib2R5XG4gIGNvbnN0IHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gIHJldHVybiByZWN0UHJvcGVydGllcy5ldmVyeSgoaXRlbSkgPT4gcmVjdFtpdGVtXSA9PT0gMClcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgdG9wIGNvcm5lciBvZiB0aGUgSFRNTEVsZW1lbnQgaXMgaW4gdGhlIHZpZXdwb3J0LlxuICovXG5mdW5jdGlvbiB0b3BPZkVsZW1lbnRJblZpZXdwb3J0KGVsZW1lbnQ6IEhUTUxFbGVtZW50LCB2aWV3cG9ydEhlaWdodDogbnVtYmVyKSB7XG4gIGNvbnN0IHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gIHJldHVybiByZWN0LnRvcCA+PSAwICYmIHJlY3QudG9wIDw9IHZpZXdwb3J0SGVpZ2h0XG59XG5cbi8qKlxuICogRmluZCB0aGUgRE9NIG5vZGUgZm9yIGEgaGFzaCBmcmFnbWVudC5cbiAqIElmIGB0b3BgIHRoZSBwYWdlIGhhcyB0byBzY3JvbGwgdG8gdGhlIHRvcCBvZiB0aGUgcGFnZS4gVGhpcyBtaXJyb3JzIHRoZSBicm93c2VyJ3MgYmVoYXZpb3IuXG4gKiBJZiB0aGUgaGFzaCBmcmFnbWVudCBpcyBhbiBpZCwgdGhlIHBhZ2UgaGFzIHRvIHNjcm9sbCB0byB0aGUgZWxlbWVudCB3aXRoIHRoYXQgaWQuXG4gKiBJZiB0aGUgaGFzaCBmcmFnbWVudCBpcyBhIG5hbWUsIHRoZSBwYWdlIGhhcyB0byBzY3JvbGwgdG8gdGhlIGZpcnN0IGVsZW1lbnQgd2l0aCB0aGF0IG5hbWUuXG4gKi9cbmZ1bmN0aW9uIGdldEhhc2hGcmFnbWVudERvbU5vZGUoaGFzaEZyYWdtZW50OiBzdHJpbmcpIHtcbiAgLy8gSWYgdGhlIGhhc2ggZnJhZ21lbnQgaXMgYHRvcGAgdGhlIHBhZ2UgaGFzIHRvIHNjcm9sbCB0byB0aGUgdG9wIG9mIHRoZSBwYWdlLlxuICBpZiAoaGFzaEZyYWdtZW50ID09PSAndG9wJykge1xuICAgIHJldHVybiBkb2N1bWVudC5ib2R5XG4gIH1cblxuICAvLyBJZiB0aGUgaGFzaCBmcmFnbWVudCBpcyBhbiBpZCwgdGhlIHBhZ2UgaGFzIHRvIHNjcm9sbCB0byB0aGUgZWxlbWVudCB3aXRoIHRoYXQgaWQuXG4gIHJldHVybiAoXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaGFzaEZyYWdtZW50KSA/P1xuICAgIC8vIElmIHRoZSBoYXNoIGZyYWdtZW50IGlzIGEgbmFtZSwgdGhlIHBhZ2UgaGFzIHRvIHNjcm9sbCB0byB0aGUgZmlyc3QgZWxlbWVudCB3aXRoIHRoYXQgbmFtZS5cbiAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZShoYXNoRnJhZ21lbnQpWzBdXG4gIClcbn1cbmludGVyZmFjZSBTY3JvbGxBbmRGb2N1c0hhbmRsZXJQcm9wcyB7XG4gIGZvY3VzQW5kU2Nyb2xsUmVmOiBGb2N1c0FuZFNjcm9sbFJlZlxuICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlXG4gIHNlZ21lbnRQYXRoOiBGbGlnaHRTZWdtZW50UGF0aFxufVxuY2xhc3MgSW5uZXJTY3JvbGxBbmRGb2N1c0hhbmRsZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8U2Nyb2xsQW5kRm9jdXNIYW5kbGVyUHJvcHM+IHtcbiAgaGFuZGxlUG90ZW50aWFsU2Nyb2xsID0gKCkgPT4ge1xuICAgIC8vIEhhbmRsZSBzY3JvbGwgYW5kIGZvY3VzLCBpdCdzIG9ubHkgYXBwbGllZCBvbmNlIGluIHRoZSBmaXJzdCB1c2VFZmZlY3QgdGhhdCB0cmlnZ2VycyB0aGF0IGNoYW5nZWQuXG4gICAgY29uc3QgeyBmb2N1c0FuZFNjcm9sbFJlZiwgc2VnbWVudFBhdGggfSA9IHRoaXMucHJvcHNcblxuICAgIGlmIChmb2N1c0FuZFNjcm9sbFJlZi5hcHBseSkge1xuICAgICAgLy8gc2VnbWVudFBhdGhzIGlzIGFuIGFycmF5IG9mIHNlZ21lbnQgcGF0aHMgdGhhdCBzaG91bGQgYmUgc2Nyb2xsZWQgdG9cbiAgICAgIC8vIGlmIHRoZSBjdXJyZW50IHNlZ21lbnQgcGF0aCBpcyBub3QgaW4gdGhlIGFycmF5LCB0aGUgc2Nyb2xsIGlzIG5vdCBhcHBsaWVkXG4gICAgICAvLyB1bmxlc3MgdGhlIGFycmF5IGlzIGVtcHR5LCBpbiB3aGljaCBjYXNlIHRoZSBzY3JvbGwgaXMgYWx3YXlzIGFwcGxpZWRcbiAgICAgIGlmIChcbiAgICAgICAgZm9jdXNBbmRTY3JvbGxSZWYuc2VnbWVudFBhdGhzLmxlbmd0aCAhPT0gMCAmJlxuICAgICAgICAhZm9jdXNBbmRTY3JvbGxSZWYuc2VnbWVudFBhdGhzLnNvbWUoKHNjcm9sbFJlZlNlZ21lbnRQYXRoKSA9PlxuICAgICAgICAgIHNlZ21lbnRQYXRoLmV2ZXJ5KChzZWdtZW50LCBpbmRleCkgPT5cbiAgICAgICAgICAgIG1hdGNoU2VnbWVudChzZWdtZW50LCBzY3JvbGxSZWZTZWdtZW50UGF0aFtpbmRleF0pXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGxldCBkb21Ob2RlOlxuICAgICAgICB8IFJldHVyblR5cGU8dHlwZW9mIGdldEhhc2hGcmFnbWVudERvbU5vZGU+XG4gICAgICAgIHwgUmV0dXJuVHlwZTx0eXBlb2YgZmluZERPTU5vZGU+ID0gbnVsbFxuICAgICAgY29uc3QgaGFzaEZyYWdtZW50ID0gZm9jdXNBbmRTY3JvbGxSZWYuaGFzaEZyYWdtZW50XG5cbiAgICAgIGlmIChoYXNoRnJhZ21lbnQpIHtcbiAgICAgICAgZG9tTm9kZSA9IGdldEhhc2hGcmFnbWVudERvbU5vZGUoaGFzaEZyYWdtZW50KVxuICAgICAgfVxuXG4gICAgICAvLyBgZmluZERPTU5vZGVgIGlzIHRyaWNreSBiZWNhdXNlIGl0IHJldHVybnMganVzdCB0aGUgZmlyc3QgY2hpbGQgaWYgdGhlIGNvbXBvbmVudCBpcyBhIGZyYWdtZW50LlxuICAgICAgLy8gVGhpcyBhbHJlYWR5IGNhdXNlZCBhIGJ1ZyB3aGVyZSB0aGUgZmlyc3QgY2hpbGQgd2FzIGEgPGxpbmsvPiBpbiBoZWFkLlxuICAgICAgaWYgKCFkb21Ob2RlKSB7XG4gICAgICAgIGRvbU5vZGUgPSBmaW5kRE9NTm9kZSh0aGlzKVxuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGVyZSBpcyBubyBET00gbm9kZSB0aGlzIGxheW91dC1yb3V0ZXIgbGV2ZWwgaXMgc2tpcHBlZC4gSXQnbGwgYmUgaGFuZGxlZCBoaWdoZXItdXAgaW4gdGhlIHRyZWUuXG4gICAgICBpZiAoIShkb21Ob2RlIGluc3RhbmNlb2YgRWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIFZlcmlmeSBpZiB0aGUgZWxlbWVudCBpcyBhIEhUTUxFbGVtZW50IGFuZCBpZiB3ZSB3YW50IHRvIGNvbnNpZGVyIGl0IGZvciBzY3JvbGwgYmVoYXZpb3IuXG4gICAgICAvLyBJZiB0aGUgZWxlbWVudCBpcyBza2lwcGVkLCB0cnkgdG8gc2VsZWN0IHRoZSBuZXh0IHNpYmxpbmcgYW5kIHRyeSBhZ2Fpbi5cbiAgICAgIHdoaWxlICghKGRvbU5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkgfHwgc2hvdWxkU2tpcEVsZW1lbnQoZG9tTm9kZSkpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAoZG9tTm9kZS5wYXJlbnRFbGVtZW50Py5sb2NhbE5hbWUgPT09ICdoZWFkJykge1xuICAgICAgICAgICAgLy8gVE9ETzogV2UgZW50ZXIgdGhpcyBzdGF0ZSB3aGVuIG1ldGFkYXRhIHdhcyByZW5kZXJlZCBhcyBwYXJ0IG9mIHRoZSBwYWdlIG9yIHZpYSBOZXh0LmpzLlxuICAgICAgICAgICAgLy8gVGhpcyBpcyBhbHdheXMgYSBidWcgaW4gTmV4dC5qcyBhbmQgY2F1c2VkIGJ5IFJlYWN0IGhvaXN0aW5nIG1ldGFkYXRhLlxuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byByZXBsYWNlIGBmaW5kRE9NTm9kZWAgaW4gZmF2b3Igb2YgRnJhZ21lbnQgUmVmcyAod2hlbiBhdmFpbGFibGUpIHNvIHRoYXQgd2UgY2FuIHNraXAgb3ZlciBtZXRhZGF0YS5cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBObyBzaWJsaW5ncyBmb3VuZCB0aGF0IG1hdGNoIHRoZSBjcml0ZXJpYSBhcmUgZm91bmQsIHNvIGhhbmRsZSBzY3JvbGwgaGlnaGVyIHVwIGluIHRoZSB0cmVlIGluc3RlYWQuXG4gICAgICAgIGlmIChkb21Ob2RlLm5leHRFbGVtZW50U2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGRvbU5vZGUgPSBkb21Ob2RlLm5leHRFbGVtZW50U2libGluZ1xuICAgICAgfVxuXG4gICAgICAvLyBTdGF0ZSBpcyBtdXRhdGVkIHRvIGVuc3VyZSB0aGF0IHRoZSBmb2N1cyBhbmQgc2Nyb2xsIGlzIGFwcGxpZWQgb25seSBvbmNlLlxuICAgICAgZm9jdXNBbmRTY3JvbGxSZWYuYXBwbHkgPSBmYWxzZVxuICAgICAgZm9jdXNBbmRTY3JvbGxSZWYuaGFzaEZyYWdtZW50ID0gbnVsbFxuICAgICAgZm9jdXNBbmRTY3JvbGxSZWYuc2VnbWVudFBhdGhzID0gW11cblxuICAgICAgZGlzYWJsZVNtb290aFNjcm9sbER1cmluZ1JvdXRlVHJhbnNpdGlvbihcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIC8vIEluIGNhc2Ugb2YgaGFzaCBzY3JvbGwsIHdlIG9ubHkgbmVlZCB0byBzY3JvbGwgdGhlIGVsZW1lbnQgaW50byB2aWV3XG4gICAgICAgICAgaWYgKGhhc2hGcmFnbWVudCkge1xuICAgICAgICAgICAgOyhkb21Ob2RlIGFzIEhUTUxFbGVtZW50KS5zY3JvbGxJbnRvVmlldygpXG5cbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBTdG9yZSB0aGUgY3VycmVudCB2aWV3cG9ydCBoZWlnaHQgYmVjYXVzZSByZWFkaW5nIGBjbGllbnRIZWlnaHRgIGNhdXNlcyBhIHJlZmxvdyxcbiAgICAgICAgICAvLyBhbmQgaXQgd29uJ3QgY2hhbmdlIGR1cmluZyB0aGlzIGZ1bmN0aW9uLlxuICAgICAgICAgIGNvbnN0IGh0bWxFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XG4gICAgICAgICAgY29uc3Qgdmlld3BvcnRIZWlnaHQgPSBodG1sRWxlbWVudC5jbGllbnRIZWlnaHRcblxuICAgICAgICAgIC8vIElmIHRoZSBlbGVtZW50J3MgdG9wIGVkZ2UgaXMgYWxyZWFkeSBpbiB0aGUgdmlld3BvcnQsIGV4aXQgZWFybHkuXG4gICAgICAgICAgaWYgKHRvcE9mRWxlbWVudEluVmlld3BvcnQoZG9tTm9kZSBhcyBIVE1MRWxlbWVudCwgdmlld3BvcnRIZWlnaHQpKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBPdGhlcndpc2UsIHRyeSBzY3JvbGxpbmcgZ28gdGhlIHRvcCBvZiB0aGUgZG9jdW1lbnQgdG8gYmUgYmFja3dhcmQgY29tcGF0aWJsZSB3aXRoIHBhZ2VzXG4gICAgICAgICAgLy8gc2Nyb2xsSW50b1ZpZXcoKSBjYWxsZWQgb24gYDxodG1sLz5gIGVsZW1lbnQgc2Nyb2xscyBob3Jpem9udGFsbHkgb24gY2hyb21lIGFuZCBmaXJlZm94ICh0aGF0IHNob3VsZG4ndCBoYXBwZW4pXG4gICAgICAgICAgLy8gV2UgY291bGQgdXNlIGl0IHRvIHNjcm9sbCBob3Jpem9udGFsbHkgZm9sbG93aW5nIFJUTCBidXQgdGhhdCBhbHNvIHNlZW1zIHRvIGJlIGJyb2tlbiAtIGl0IHdpbGwgYWx3YXlzIHNjcm9sbCBsZWZ0XG4gICAgICAgICAgLy8gc2Nyb2xsTGVmdCA9IDAgYWxzbyBzZWVtcyB0byBpZ25vcmUgUlRMIGFuZCBtYW51YWxseSBjaGVja2luZyBmb3IgUlRMIGlzIHRvbyBtdWNoIGhhc3NsZSBzbyB3ZSB3aWxsIHNjcm9sbCBqdXN0IHZlcnRpY2FsbHlcbiAgICAgICAgICBodG1sRWxlbWVudC5zY3JvbGxUb3AgPSAwXG5cbiAgICAgICAgICAvLyBTY3JvbGwgdG8gZG9tTm9kZSBpZiBkb21Ob2RlIGlzIG5vdCBpbiB2aWV3cG9ydCB3aGVuIHNjcm9sbGVkIHRvIHRvcCBvZiBkb2N1bWVudFxuICAgICAgICAgIGlmICghdG9wT2ZFbGVtZW50SW5WaWV3cG9ydChkb21Ob2RlIGFzIEhUTUxFbGVtZW50LCB2aWV3cG9ydEhlaWdodCkpIHtcbiAgICAgICAgICAgIC8vIFNjcm9sbCBpbnRvIHZpZXcgZG9lc24ndCBzY3JvbGwgaG9yaXpvbnRhbGx5IGJ5IGRlZmF1bHQgd2hlbiBub3QgbmVlZGVkXG4gICAgICAgICAgICA7KGRvbU5vZGUgYXMgSFRNTEVsZW1lbnQpLnNjcm9sbEludG9WaWV3KClcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAvLyBXZSB3aWxsIGZvcmNlIGxheW91dCBieSBxdWVyeWluZyBkb21Ob2RlIHBvc2l0aW9uXG4gICAgICAgICAgZG9udEZvcmNlTGF5b3V0OiB0cnVlLFxuICAgICAgICAgIG9ubHlIYXNoQ2hhbmdlOiBmb2N1c0FuZFNjcm9sbFJlZi5vbmx5SGFzaENoYW5nZSxcbiAgICAgICAgfVxuICAgICAgKVxuXG4gICAgICAvLyBNdXRhdGUgYWZ0ZXIgc2Nyb2xsaW5nIHNvIHRoYXQgaXQgY2FuIGJlIHJlYWQgYnkgYGRpc2FibGVTbW9vdGhTY3JvbGxEdXJpbmdSb3V0ZVRyYW5zaXRpb25gXG4gICAgICBmb2N1c0FuZFNjcm9sbFJlZi5vbmx5SGFzaENoYW5nZSA9IGZhbHNlXG5cbiAgICAgIC8vIFNldCBmb2N1cyBvbiB0aGUgZWxlbWVudFxuICAgICAgZG9tTm9kZS5mb2N1cygpXG4gICAgfVxuICB9XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy5oYW5kbGVQb3RlbnRpYWxTY3JvbGwoKVxuICB9XG5cbiAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgIC8vIEJlY2F1c2UgdGhpcyBwcm9wZXJ0eSBpcyBvdmVyd3JpdHRlbiBpbiBoYW5kbGVQb3RlbnRpYWxTY3JvbGwgaXQncyBmaW5lIHRvIGFsd2F5cyBydW4gaXQgd2hlbiB0cnVlIGFzIGl0J2xsIGJlIHNldCB0byBmYWxzZSBmb3Igc3Vic2VxdWVudCByZW5kZXJzLlxuICAgIGlmICh0aGlzLnByb3BzLmZvY3VzQW5kU2Nyb2xsUmVmLmFwcGx5KSB7XG4gICAgICB0aGlzLmhhbmRsZVBvdGVudGlhbFNjcm9sbCgpXG4gICAgfVxuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuXG4gIH1cbn1cblxuZnVuY3Rpb24gU2Nyb2xsQW5kRm9jdXNIYW5kbGVyKHtcbiAgc2VnbWVudFBhdGgsXG4gIGNoaWxkcmVuLFxufToge1xuICBzZWdtZW50UGF0aDogRmxpZ2h0U2VnbWVudFBhdGhcbiAgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZVxufSkge1xuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dChHbG9iYWxMYXlvdXRSb3V0ZXJDb250ZXh0KVxuICBpZiAoIWNvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCBnbG9iYWwgbGF5b3V0IHJvdXRlciBub3QgbW91bnRlZCcpXG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxJbm5lclNjcm9sbEFuZEZvY3VzSGFuZGxlclxuICAgICAgc2VnbWVudFBhdGg9e3NlZ21lbnRQYXRofVxuICAgICAgZm9jdXNBbmRTY3JvbGxSZWY9e2NvbnRleHQuZm9jdXNBbmRTY3JvbGxSZWZ9XG4gICAgPlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvSW5uZXJTY3JvbGxBbmRGb2N1c0hhbmRsZXI+XG4gIClcbn1cblxuLyoqXG4gKiBJbm5lckxheW91dFJvdXRlciBoYW5kbGVzIHJlbmRlcmluZyB0aGUgcHJvdmlkZWQgc2VnbWVudCBiYXNlZCBvbiB0aGUgY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIElubmVyTGF5b3V0Um91dGVyKHtcbiAgdHJlZSxcbiAgc2VnbWVudFBhdGgsXG4gIGNhY2hlTm9kZSxcbiAgdXJsLFxufToge1xuICB0cmVlOiBGbGlnaHRSb3V0ZXJTdGF0ZVxuICBzZWdtZW50UGF0aDogRmxpZ2h0U2VnbWVudFBhdGhcbiAgY2FjaGVOb2RlOiBDYWNoZU5vZGVcbiAgdXJsOiBzdHJpbmdcbn0pIHtcbiAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoR2xvYmFsTGF5b3V0Um91dGVyQ29udGV4dClcbiAgaWYgKCFjb250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgZ2xvYmFsIGxheW91dCByb3V0ZXIgbm90IG1vdW50ZWQnKVxuICB9XG5cbiAgY29uc3QgeyB0cmVlOiBmdWxsVHJlZSB9ID0gY29udGV4dFxuXG4gIC8vIGByc2NgIHJlcHJlc2VudHMgdGhlIHJlbmRlcmFibGUgbm9kZSBmb3IgdGhpcyBzZWdtZW50LlxuXG4gIC8vIElmIHRoaXMgc2VnbWVudCBoYXMgYSBgcHJlZmV0Y2hSc2NgLCBpdCdzIHRoZSBzdGF0aWNhbGx5IHByZWZldGNoZWQgZGF0YS5cbiAgLy8gV2Ugc2hvdWxkIHVzZSB0aGF0IG9uIGluaXRpYWwgcmVuZGVyIGluc3RlYWQgb2YgYHJzY2AuIFRoZW4gd2UnbGwgc3dpdGNoXG4gIC8vIHRvIGByc2NgIHdoZW4gdGhlIGR5bmFtaWMgcmVzcG9uc2Ugc3RyZWFtcyBpbi5cbiAgLy9cbiAgLy8gSWYgbm8gcHJlZmV0Y2ggZGF0YSBpcyBhdmFpbGFibGUsIHRoZW4gd2UgZ28gc3RyYWlnaHQgdG8gcmVuZGVyaW5nIGByc2NgLlxuICBjb25zdCByZXNvbHZlZFByZWZldGNoUnNjID1cbiAgICBjYWNoZU5vZGUucHJlZmV0Y2hSc2MgIT09IG51bGwgPyBjYWNoZU5vZGUucHJlZmV0Y2hSc2MgOiBjYWNoZU5vZGUucnNjXG5cbiAgLy8gV2UgdXNlIGB1c2VEZWZlcnJlZFZhbHVlYCB0byBoYW5kbGUgc3dpdGNoaW5nIGJldHdlZW4gdGhlIHByZWZldGNoZWQgYW5kXG4gIC8vIGZpbmFsIHZhbHVlcy4gVGhlIHNlY29uZCBhcmd1bWVudCBpcyByZXR1cm5lZCBvbiBpbml0aWFsIHJlbmRlciwgdGhlbiBpdFxuICAvLyByZS1yZW5kZXJzIHdpdGggdGhlIGZpcnN0IGFyZ3VtZW50LlxuICBjb25zdCByc2M6IGFueSA9IHVzZURlZmVycmVkVmFsdWUoY2FjaGVOb2RlLnJzYywgcmVzb2x2ZWRQcmVmZXRjaFJzYylcblxuICAvLyBgcnNjYCBpcyBlaXRoZXIgYSBSZWFjdCBub2RlIG9yIGEgcHJvbWlzZSBmb3IgYSBSZWFjdCBub2RlLCBleGNlcHQgd2VcbiAgLy8gc3BlY2lhbCBjYXNlIGBudWxsYCB0byByZXByZXNlbnQgdGhhdCB0aGlzIHNlZ21lbnQncyBkYXRhIGlzIG1pc3NpbmcuIElmXG4gIC8vIGl0J3MgYSBwcm9taXNlLCB3ZSBuZWVkIHRvIHVud3JhcCBpdCBzbyB3ZSBjYW4gZGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IHRoZVxuICAvLyBkYXRhIGlzIG1pc3NpbmcuXG4gIGNvbnN0IHJlc29sdmVkUnNjOiBSZWFjdC5SZWFjdE5vZGUgPVxuICAgIHR5cGVvZiByc2MgPT09ICdvYmplY3QnICYmIHJzYyAhPT0gbnVsbCAmJiB0eXBlb2YgcnNjLnRoZW4gPT09ICdmdW5jdGlvbidcbiAgICAgID8gdXNlKHJzYylcbiAgICAgIDogcnNjXG5cbiAgaWYgKCFyZXNvbHZlZFJzYykge1xuICAgIC8vIFRoZSBkYXRhIGZvciB0aGlzIHNlZ21lbnQgaXMgbm90IGF2YWlsYWJsZSwgYW5kIHRoZXJlJ3Mgbm8gcGVuZGluZ1xuICAgIC8vIG5hdmlnYXRpb24gdGhhdCB3aWxsIGJlIGFibGUgdG8gZnVsZmlsbCBpdC4gV2UgbmVlZCB0byBmZXRjaCBtb3JlIGZyb21cbiAgICAvLyB0aGUgc2VydmVyIGFuZCBwYXRjaCB0aGUgY2FjaGUuXG5cbiAgICAvLyBDaGVjayBpZiB0aGVyZSdzIGFscmVhZHkgYSBwZW5kaW5nIHJlcXVlc3QuXG4gICAgbGV0IGxhenlEYXRhID0gY2FjaGVOb2RlLmxhenlEYXRhXG4gICAgaWYgKGxhenlEYXRhID09PSBudWxsKSB7XG4gICAgICAvKipcbiAgICAgICAqIFJvdXRlciBzdGF0ZSB3aXRoIHJlZmV0Y2ggbWFya2VyIGFkZGVkXG4gICAgICAgKi9cbiAgICAgIC8vIFRPRE8tQVBQOiByZW1vdmUgJydcbiAgICAgIGNvbnN0IHJlZmV0Y2hUcmVlID0gd2Fsa0FkZFJlZmV0Y2goWycnLCAuLi5zZWdtZW50UGF0aF0sIGZ1bGxUcmVlKVxuICAgICAgY29uc3QgaW5jbHVkZU5leHRVcmwgPSBoYXNJbnRlcmNlcHRpb25Sb3V0ZUluQ3VycmVudFRyZWUoZnVsbFRyZWUpXG4gICAgICBjb25zdCBuYXZpZ2F0ZWRBdCA9IERhdGUubm93KClcbiAgICAgIGNhY2hlTm9kZS5sYXp5RGF0YSA9IGxhenlEYXRhID0gZmV0Y2hTZXJ2ZXJSZXNwb25zZShcbiAgICAgICAgbmV3IFVSTCh1cmwsIGxvY2F0aW9uLm9yaWdpbiksXG4gICAgICAgIHtcbiAgICAgICAgICBmbGlnaHRSb3V0ZXJTdGF0ZTogcmVmZXRjaFRyZWUsXG4gICAgICAgICAgbmV4dFVybDogaW5jbHVkZU5leHRVcmwgPyBjb250ZXh0Lm5leHRVcmwgOiBudWxsLFxuICAgICAgICB9XG4gICAgICApLnRoZW4oKHNlcnZlclJlc3BvbnNlKSA9PiB7XG4gICAgICAgIHN0YXJ0VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICAgICAgZGlzcGF0Y2hBcHBSb3V0ZXJBY3Rpb24oe1xuICAgICAgICAgICAgdHlwZTogQUNUSU9OX1NFUlZFUl9QQVRDSCxcbiAgICAgICAgICAgIHByZXZpb3VzVHJlZTogZnVsbFRyZWUsXG4gICAgICAgICAgICBzZXJ2ZXJSZXNwb25zZSxcbiAgICAgICAgICAgIG5hdmlnYXRlZEF0LFxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG5cbiAgICAgICAgcmV0dXJuIHNlcnZlclJlc3BvbnNlXG4gICAgICB9KVxuXG4gICAgICAvLyBTdXNwZW5kIHdoaWxlIHdhaXRpbmcgZm9yIGxhenlEYXRhIHRvIHJlc29sdmVcbiAgICAgIHVzZShsYXp5RGF0YSlcbiAgICB9XG4gICAgLy8gU3VzcGVuZCBpbmZpbml0ZWx5IGFzIGBjaGFuZ2VCeVNlcnZlclJlc3BvbnNlYCB3aWxsIGNhdXNlIGEgZGlmZmVyZW50IHBhcnQgb2YgdGhlIHRyZWUgdG8gYmUgcmVuZGVyZWQuXG4gICAgLy8gQSBmYWxzZXkgYHJlc29sdmVkUnNjYCBpbmRpY2F0ZXMgbWlzc2luZyBkYXRhIC0tIHdlIHNob3VsZCBub3QgY29tbWl0IHRoYXQgYnJhbmNoLCBhbmQgd2UgbmVlZCB0byB3YWl0IGZvciB0aGUgZGF0YSB0byBhcnJpdmUuXG4gICAgdXNlKHVucmVzb2x2ZWRUaGVuYWJsZSkgYXMgbmV2ZXJcbiAgfVxuXG4gIC8vIElmIHdlIGdldCB0byB0aGlzIHBvaW50LCB0aGVuIHdlIGtub3cgd2UgaGF2ZSBzb21ldGhpbmcgd2UgY2FuIHJlbmRlci5cbiAgY29uc3Qgc3VidHJlZSA9IChcbiAgICAvLyBUaGUgbGF5b3V0IHJvdXRlciBjb250ZXh0IG5hcnJvd3MgZG93biB0cmVlIGFuZCBjaGlsZE5vZGVzIGF0IGVhY2ggbGV2ZWwuXG4gICAgPExheW91dFJvdXRlckNvbnRleHQuUHJvdmlkZXJcbiAgICAgIHZhbHVlPXt7XG4gICAgICAgIHBhcmVudFRyZWU6IHRyZWUsXG4gICAgICAgIHBhcmVudENhY2hlTm9kZTogY2FjaGVOb2RlLFxuICAgICAgICBwYXJlbnRTZWdtZW50UGF0aDogc2VnbWVudFBhdGgsXG5cbiAgICAgICAgLy8gVE9ETy1BUFA6IG92ZXJyaWRpbmcgb2YgdXJsIGZvciBwYXJhbGxlbCByb3V0ZXNcbiAgICAgICAgdXJsOiB1cmwsXG4gICAgICB9fVxuICAgID5cbiAgICAgIHtyZXNvbHZlZFJzY31cbiAgICA8L0xheW91dFJvdXRlckNvbnRleHQuUHJvdmlkZXI+XG4gIClcbiAgLy8gRW5zdXJlIHJvb3QgbGF5b3V0IGlzIG5vdCB3cmFwcGVkIGluIGEgZGl2IGFzIHRoZSByb290IGxheW91dCByZW5kZXJzIGA8aHRtbD5gXG4gIHJldHVybiBzdWJ0cmVlXG59XG5cbi8qKlxuICogUmVuZGVycyBzdXNwZW5zZSBib3VuZGFyeSB3aXRoIHRoZSBwcm92aWRlZCBcImxvYWRpbmdcIiBwcm9wZXJ0eSBhcyB0aGUgZmFsbGJhY2suXG4gKiBJZiBubyBsb2FkaW5nIHByb3BlcnR5IGlzIHByb3ZpZGVkIGl0IHJlbmRlcnMgdGhlIGNoaWxkcmVuIHdpdGhvdXQgYSBzdXNwZW5zZSBib3VuZGFyeS5cbiAqL1xuZnVuY3Rpb24gTG9hZGluZ0JvdW5kYXJ5KHtcbiAgbG9hZGluZyxcbiAgY2hpbGRyZW4sXG59OiB7XG4gIGxvYWRpbmc6IExvYWRpbmdNb2R1bGVEYXRhIHwgUHJvbWlzZTxMb2FkaW5nTW9kdWxlRGF0YT5cbiAgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZVxufSk6IEpTWC5FbGVtZW50IHtcbiAgLy8gSWYgbG9hZGluZyBpcyBhIHByb21pc2UsIHVud3JhcCBpdC4gVGhpcyBoYXBwZW5zIGluIGNhc2VzIHdoZXJlIHdlIGhhdmVuJ3RcbiAgLy8geWV0IHJlY2VpdmVkIHRoZSBsb2FkaW5nIGRhdGEgZnJvbSB0aGUgc2VydmVyIOKAlCB3aGljaCBpbmNsdWRlcyB3aGV0aGVyIG9yXG4gIC8vIG5vdCB0aGlzIGxheW91dCBoYXMgYSBsb2FkaW5nIGNvbXBvbmVudCBhdCBhbGwuXG4gIC8vXG4gIC8vIEl0J3MgT0sgdG8gc3VzcGVuZCBoZXJlIGluc3RlYWQgb2YgaW5zaWRlIHRoZSBmYWxsYmFjayBiZWNhdXNlIHRoaXNcbiAgLy8gcHJvbWlzZSB3aWxsIHJlc29sdmUgc2ltdWx0YW5lb3VzbHkgd2l0aCB0aGUgZGF0YSBmb3IgdGhlIHNlZ21lbnQgaXRzZWxmLlxuICAvLyBTbyBpdCB3aWxsIG5ldmVyIHN1c3BlbmQgZm9yIGxvbmdlciB0aGFuIGl0IHdvdWxkIGhhdmUgaWYgd2UgZGlkbid0IHVzZVxuICAvLyBhIFN1c3BlbnNlIGZhbGxiYWNrIGF0IGFsbC5cbiAgbGV0IGxvYWRpbmdNb2R1bGVEYXRhXG4gIGlmIChcbiAgICB0eXBlb2YgbG9hZGluZyA9PT0gJ29iamVjdCcgJiZcbiAgICBsb2FkaW5nICE9PSBudWxsICYmXG4gICAgdHlwZW9mIChsb2FkaW5nIGFzIGFueSkudGhlbiA9PT0gJ2Z1bmN0aW9uJ1xuICApIHtcbiAgICBjb25zdCBwcm9taXNlRm9yTG9hZGluZyA9IGxvYWRpbmcgYXMgUHJvbWlzZTxMb2FkaW5nTW9kdWxlRGF0YT5cbiAgICBsb2FkaW5nTW9kdWxlRGF0YSA9IHVzZShwcm9taXNlRm9yTG9hZGluZylcbiAgfSBlbHNlIHtcbiAgICBsb2FkaW5nTW9kdWxlRGF0YSA9IGxvYWRpbmcgYXMgTG9hZGluZ01vZHVsZURhdGFcbiAgfVxuXG4gIGlmIChsb2FkaW5nTW9kdWxlRGF0YSkge1xuICAgIGNvbnN0IGxvYWRpbmdSc2MgPSBsb2FkaW5nTW9kdWxlRGF0YVswXVxuICAgIGNvbnN0IGxvYWRpbmdTdHlsZXMgPSBsb2FkaW5nTW9kdWxlRGF0YVsxXVxuICAgIGNvbnN0IGxvYWRpbmdTY3JpcHRzID0gbG9hZGluZ01vZHVsZURhdGFbMl1cbiAgICByZXR1cm4gKFxuICAgICAgPFN1c3BlbnNlXG4gICAgICAgIGZhbGxiYWNrPXtcbiAgICAgICAgICA8PlxuICAgICAgICAgICAge2xvYWRpbmdTdHlsZXN9XG4gICAgICAgICAgICB7bG9hZGluZ1NjcmlwdHN9XG4gICAgICAgICAgICB7bG9hZGluZ1JzY31cbiAgICAgICAgICA8Lz5cbiAgICAgICAgfVxuICAgICAgPlxuICAgICAgICB7Y2hpbGRyZW59XG4gICAgICA8L1N1c3BlbnNlPlxuICAgIClcbiAgfVxuXG4gIHJldHVybiA8PntjaGlsZHJlbn08Lz5cbn1cblxuZnVuY3Rpb24gUmVuZGVyQ2hpbGRyZW4oeyBjaGlsZHJlbiB9OiB7IGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGUgfSkge1xuICByZXR1cm4gPD57Y2hpbGRyZW59PC8+XG59XG5cbi8qKlxuICogT3V0ZXJMYXlvdXRSb3V0ZXIgaGFuZGxlcyB0aGUgY3VycmVudCBzZWdtZW50IGFzIHdlbGwgYXMgPE9mZnNjcmVlbj4gcmVuZGVyaW5nIG9mIG90aGVyIHNlZ21lbnRzLlxuICogSXQgY2FuIGJlIHJlbmRlcmVkIG5leHQgdG8gZWFjaCBvdGhlciB3aXRoIGEgZGlmZmVyZW50IGBwYXJhbGxlbFJvdXRlcktleWAsIGFsbG93aW5nIGZvciBQYXJhbGxlbCByb3V0ZXMuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE91dGVyTGF5b3V0Um91dGVyKHtcbiAgcGFyYWxsZWxSb3V0ZXJLZXksXG4gIGVycm9yLFxuICBlcnJvclN0eWxlcyxcbiAgZXJyb3JTY3JpcHRzLFxuICB0ZW1wbGF0ZVN0eWxlcyxcbiAgdGVtcGxhdGVTY3JpcHRzLFxuICB0ZW1wbGF0ZSxcbiAgbm90Rm91bmQsXG4gIGZvcmJpZGRlbixcbiAgdW5hdXRob3JpemVkLFxuICBncmFjZWZ1bGx5RGVncmFkZSxcbiAgc2VnbWVudFZpZXdCb3VuZGFyaWVzLFxufToge1xuICBwYXJhbGxlbFJvdXRlcktleTogc3RyaW5nXG4gIGVycm9yOiBFcnJvckNvbXBvbmVudCB8IHVuZGVmaW5lZFxuICBlcnJvclN0eWxlczogUmVhY3QuUmVhY3ROb2RlIHwgdW5kZWZpbmVkXG4gIGVycm9yU2NyaXB0czogUmVhY3QuUmVhY3ROb2RlIHwgdW5kZWZpbmVkXG4gIHRlbXBsYXRlU3R5bGVzOiBSZWFjdC5SZWFjdE5vZGUgfCB1bmRlZmluZWRcbiAgdGVtcGxhdGVTY3JpcHRzOiBSZWFjdC5SZWFjdE5vZGUgfCB1bmRlZmluZWRcbiAgdGVtcGxhdGU6IFJlYWN0LlJlYWN0Tm9kZVxuICBub3RGb3VuZDogUmVhY3QuUmVhY3ROb2RlIHwgdW5kZWZpbmVkXG4gIGZvcmJpZGRlbjogUmVhY3QuUmVhY3ROb2RlIHwgdW5kZWZpbmVkXG4gIHVuYXV0aG9yaXplZDogUmVhY3QuUmVhY3ROb2RlIHwgdW5kZWZpbmVkXG4gIGdyYWNlZnVsbHlEZWdyYWRlPzogYm9vbGVhblxuICBzZWdtZW50Vmlld0JvdW5kYXJpZXM/OiBSZWFjdC5SZWFjdE5vZGVcbn0pIHtcbiAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoTGF5b3V0Um91dGVyQ29udGV4dClcbiAgaWYgKCFjb250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgZXhwZWN0ZWQgbGF5b3V0IHJvdXRlciB0byBiZSBtb3VudGVkJylcbiAgfVxuXG4gIGNvbnN0IHsgcGFyZW50VHJlZSwgcGFyZW50Q2FjaGVOb2RlLCBwYXJlbnRTZWdtZW50UGF0aCwgdXJsIH0gPSBjb250ZXh0XG5cbiAgLy8gR2V0IHRoZSBDYWNoZU5vZGUgZm9yIHRoaXMgc2VnbWVudCBieSByZWFkaW5nIGl0IGZyb20gdGhlIHBhcmVudCBzZWdtZW50J3NcbiAgLy8gY2hpbGQgbWFwLlxuICBjb25zdCBwYXJlbnRQYXJhbGxlbFJvdXRlcyA9IHBhcmVudENhY2hlTm9kZS5wYXJhbGxlbFJvdXRlc1xuICBsZXQgc2VnbWVudE1hcCA9IHBhcmVudFBhcmFsbGVsUm91dGVzLmdldChwYXJhbGxlbFJvdXRlcktleSlcbiAgLy8gSWYgdGhlIHBhcmFsbGVsIHJvdXRlciBjYWNoZSBub2RlIGRvZXMgbm90IGV4aXN0IHlldCwgY3JlYXRlIGl0LlxuICAvLyBUaGlzIHdyaXRlcyB0byB0aGUgY2FjaGUgd2hlbiB0aGVyZSBpcyBubyBpdGVtIGluIHRoZSBjYWNoZSB5ZXQuIEl0IG5ldmVyICpvdmVyd3JpdGVzKiBleGlzdGluZyBjYWNoZSBpdGVtcyB3aGljaCBpcyB3aHkgaXQncyBzYWZlIGluIGNvbmN1cnJlbnQgbW9kZS5cbiAgaWYgKCFzZWdtZW50TWFwKSB7XG4gICAgc2VnbWVudE1hcCA9IG5ldyBNYXAoKVxuICAgIHBhcmVudFBhcmFsbGVsUm91dGVzLnNldChwYXJhbGxlbFJvdXRlcktleSwgc2VnbWVudE1hcClcbiAgfVxuICBjb25zdCBwYXJlbnRUcmVlU2VnbWVudCA9IHBhcmVudFRyZWVbMF1cbiAgY29uc3Qgc2VnbWVudFBhdGggPVxuICAgIHBhcmVudFNlZ21lbnRQYXRoID09PSBudWxsXG4gICAgICA/IC8vIFRPRE86IFRoZSByb290IHNlZ21lbnQgdmFsdWUgaXMgY3VycmVudGx5IG9taXR0ZWQgZnJvbSB0aGUgc2VnbWVudFxuICAgICAgICAvLyBwYXRoLiBUaGlzIGhhcyBsZWQgdG8gYSBidW5jaCBvZiBzcGVjaWFsIGNhc2VzIHNjYXR0ZXJlZCB0aHJvdWdob3V0XG4gICAgICAgIC8vIHRoZSBjb2RlLiBXZSBzaG91bGQgY2xlYW4gdGhpcyB1cC5cbiAgICAgICAgW3BhcmFsbGVsUm91dGVyS2V5XVxuICAgICAgOiBwYXJlbnRTZWdtZW50UGF0aC5jb25jYXQoW3BhcmVudFRyZWVTZWdtZW50LCBwYXJhbGxlbFJvdXRlcktleV0pXG5cbiAgLy8gVGhlIFwic3RhdGVcIiBrZXkgb2YgYSBzZWdtZW50IGlzIHRoZSBvbmUgcGFzc2VkIHRvIFJlYWN0IOKAlCBpdCByZXByZXNlbnRzIHRoZVxuICAvLyBpZGVudGl0eSBvZiB0aGUgVUkgdHJlZS4gV2hlbmV2ZXIgdGhlIHN0YXRlIGtleSBjaGFuZ2VzLCB0aGUgdHJlZSBpc1xuICAvLyByZWNyZWF0ZWQgYW5kIHRoZSBzdGF0ZSBpcyByZXNldC4gSW4gdGhlIEFwcCBSb3V0ZXIgbW9kZWwsIHNlYXJjaCBwYXJhbXMgZG9cbiAgLy8gbm90IGNhdXNlIHN0YXRlIHRvIGJlIGxvc3QsIHNvIHR3byBzZWdtZW50cyB3aXRoIHRoZSBzYW1lIHNlZ21lbnQgcGF0aCBidXRcbiAgLy8gZGlmZmVyZW50IHNlYXJjaCBwYXJhbXMgc2hvdWxkIGhhdmUgdGhlIHNhbWUgc3RhdGUga2V5LlxuICAvL1xuICAvLyBUaGUgXCJjYWNoZVwiIGtleSBvZiBhIHNlZ21lbnQsIGhvd2V2ZXIsICpkb2VzKiBpbmNsdWRlIHRoZSBzZWFyY2ggcGFyYW1zLCBpZlxuICAvLyBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIHNlZ21lbnQgYWNjZXNzZWQgdGhlIHNlYXJjaCBwYXJhbXMgb24gdGhlIHNlcnZlci5cbiAgLy8gKFRoaXMgb25seSBhcHBsaWVzIHRvIHBhZ2Ugc2VnbWVudHM7IGxheW91dCBzZWdtZW50cyBjYW5ub3QgYWNjZXNzIHNlYXJjaFxuICAvLyBwYXJhbXMgb24gdGhlIHNlcnZlci4pXG4gIGNvbnN0IGFjdGl2ZVRyZWUgPSBwYXJlbnRUcmVlWzFdW3BhcmFsbGVsUm91dGVyS2V5XVxuICBjb25zdCBhY3RpdmVTZWdtZW50ID0gYWN0aXZlVHJlZVswXVxuICBjb25zdCBhY3RpdmVTdGF0ZUtleSA9IGNyZWF0ZVJvdXRlckNhY2hlS2V5KGFjdGl2ZVNlZ21lbnQsIHRydWUpIC8vIG5vIHNlYXJjaCBwYXJhbXNcblxuICAvLyBBdCBlYWNoIGxldmVsIG9mIHRoZSByb3V0ZSB0cmVlLCBub3Qgb25seSBkbyB3ZSByZW5kZXIgdGhlIGN1cnJlbnRseVxuICAvLyBhY3RpdmUgc2VnbWVudCDigJQgd2UgYWxzbyByZW5kZXIgdGhlIGxhc3QgTiBzZWdtZW50cyB0aGF0IHdlcmUgYWN0aXZlIGF0XG4gIC8vIHRoaXMgbGV2ZWwgaW5zaWRlIGEgaGlkZGVuIDxBY3Rpdml0eT4gYm91bmRhcnksIHRvIHByZXNlcnZlIHRoZWlyIHN0YXRlXG4gIC8vIGlmIG9yIHdoZW4gdGhlIHVzZXIgbmF2aWdhdGVzIHRvIHRoZW0gYWdhaW4uXG4gIC8vXG4gIC8vIGJmY2FjaGVFbnRyeSBpcyBhIGxpbmtlZCBsaXN0IG9mIEZsaWdodFJvdXRlclN0YXRlcy5cbiAgbGV0IGJmY2FjaGVFbnRyeTogUm91dGVyQkZDYWNoZUVudHJ5IHwgbnVsbCA9IHVzZVJvdXRlckJGQ2FjaGUoXG4gICAgYWN0aXZlVHJlZSxcbiAgICBhY3RpdmVTdGF0ZUtleVxuICApXG4gIGxldCBjaGlsZHJlbjogQXJyYXk8UmVhY3QuUmVhY3ROb2RlPiA9IFtdXG4gIGRvIHtcbiAgICBjb25zdCB0cmVlID0gYmZjYWNoZUVudHJ5LnRyZWVcbiAgICBjb25zdCBzdGF0ZUtleSA9IGJmY2FjaGVFbnRyeS5zdGF0ZUtleVxuICAgIGNvbnN0IHNlZ21lbnQgPSB0cmVlWzBdXG4gICAgY29uc3QgY2FjaGVLZXkgPSBjcmVhdGVSb3V0ZXJDYWNoZUtleShzZWdtZW50KVxuXG4gICAgLy8gUmVhZCBzZWdtZW50IHBhdGggZnJvbSB0aGUgcGFyYWxsZWwgcm91dGVyIGNhY2hlIG5vZGUuXG4gICAgbGV0IGNhY2hlTm9kZSA9IHNlZ21lbnRNYXAuZ2V0KGNhY2hlS2V5KVxuICAgIGlmIChjYWNoZU5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gV2hlbiBkYXRhIGlzIG5vdCBhdmFpbGFibGUgZHVyaW5nIHJlbmRlcmluZyBjbGllbnQtc2lkZSB3ZSBuZWVkIHRvIGZldGNoXG4gICAgICAvLyBpdCBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgICBjb25zdCBuZXdMYXp5Q2FjaGVOb2RlOiBMYXp5Q2FjaGVOb2RlID0ge1xuICAgICAgICBsYXp5RGF0YTogbnVsbCxcbiAgICAgICAgcnNjOiBudWxsLFxuICAgICAgICBwcmVmZXRjaFJzYzogbnVsbCxcbiAgICAgICAgaGVhZDogbnVsbCxcbiAgICAgICAgcHJlZmV0Y2hIZWFkOiBudWxsLFxuICAgICAgICBwYXJhbGxlbFJvdXRlczogbmV3IE1hcCgpLFxuICAgICAgICBsb2FkaW5nOiBudWxsLFxuICAgICAgICBuYXZpZ2F0ZWRBdDogLTEsXG4gICAgICB9XG5cbiAgICAgIC8vIEZsaWdodCBkYXRhIGZldGNoIGtpY2tlZCBvZmYgZHVyaW5nIHJlbmRlciBhbmQgcHV0IGludG8gdGhlIGNhY2hlLlxuICAgICAgY2FjaGVOb2RlID0gbmV3TGF6eUNhY2hlTm9kZVxuICAgICAgc2VnbWVudE1hcC5zZXQoY2FjaGVLZXksIG5ld0xhenlDYWNoZU5vZGUpXG4gICAgfVxuXG4gICAgLypcbiAgICAtIEVycm9yIGJvdW5kYXJ5XG4gICAgICAtIE9ubHkgcmVuZGVycyBlcnJvciBib3VuZGFyeSBpZiBlcnJvciBjb21wb25lbnQgaXMgcHJvdmlkZWQuXG4gICAgICAtIFJlbmRlcmVkIGZvciBlYWNoIHNlZ21lbnQgdG8gZW5zdXJlIHRoZXkgaGF2ZSB0aGVpciBvd24gZXJyb3Igc3RhdGUuXG4gICAgICAtIFdoZW4gZ3JhY2VmdWxseSBkZWdyYWRlIGZvciBib3RzLCBza2lwIHJlbmRlcmluZyBlcnJvciBib3VuZGFyeS5cbiAgICAtIExvYWRpbmcgYm91bmRhcnlcbiAgICAgIC0gT25seSByZW5kZXJzIHN1c3BlbnNlIGJvdW5kYXJ5IGlmIGxvYWRpbmcgY29tcG9uZW50cyBpcyBwcm92aWRlZC5cbiAgICAgIC0gUmVuZGVyZWQgZm9yIGVhY2ggc2VnbWVudCB0byBlbnN1cmUgdGhleSBoYXZlIHRoZWlyIG93biBsb2FkaW5nIHN0YXRlLlxuICAgICAgLSBQYXNzZWQgdG8gdGhlIHJvdXRlciBkdXJpbmcgcmVuZGVyaW5nIHRvIGVuc3VyZSBpdCBjYW4gYmUgaW1tZWRpYXRlbHkgcmVuZGVyZWQgd2hlbiBzdXNwZW5kaW5nIG9uIGEgRmxpZ2h0IGZldGNoLlxuICAqL1xuXG4gICAgY29uc3QgRXJyb3JCb3VuZGFyeUNvbXBvbmVudCA9IGdyYWNlZnVsbHlEZWdyYWRlXG4gICAgICA/IFJlbmRlckNoaWxkcmVuXG4gICAgICA6IEVycm9yQm91bmRhcnlcblxuICAgIGxldCBzZWdtZW50Qm91bmRhcnlUcmlnZ2VyTm9kZTogUmVhY3QuUmVhY3ROb2RlID0gbnVsbFxuICAgIGxldCBzZWdtZW50Vmlld1N0YXRlTm9kZTogUmVhY3QuUmVhY3ROb2RlID0gbnVsbFxuICAgIGlmIChcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIHByb2Nlc3MuZW52Ll9fTkVYVF9ERVZUT09MX1NFR01FTlRfRVhQTE9SRVJcbiAgICApIHtcbiAgICAgIGNvbnN0IHsgU2VnbWVudEJvdW5kYXJ5VHJpZ2dlck5vZGUsIFNlZ21lbnRWaWV3U3RhdGVOb2RlIH0gPVxuICAgICAgICByZXF1aXJlKCcuLi8uLi9uZXh0LWRldnRvb2xzL3VzZXJzcGFjZS9hcHAvc2VnbWVudC1leHBsb3Jlci1ub2RlJykgYXMgdHlwZW9mIGltcG9ydCgnLi4vLi4vbmV4dC1kZXZ0b29scy91c2Vyc3BhY2UvYXBwL3NlZ21lbnQtZXhwbG9yZXItbm9kZScpXG5cbiAgICAgIGNvbnN0IHBhZ2VQcmVmaXggPSBub3JtYWxpemVBcHBQYXRoKHVybClcbiAgICAgIHNlZ21lbnRWaWV3U3RhdGVOb2RlID0gKFxuICAgICAgICA8U2VnbWVudFZpZXdTdGF0ZU5vZGUga2V5PXtwYWdlUHJlZml4fSBwYWdlPXtwYWdlUHJlZml4fSAvPlxuICAgICAgKVxuXG4gICAgICBzZWdtZW50Qm91bmRhcnlUcmlnZ2VyTm9kZSA9IChcbiAgICAgICAgPD5cbiAgICAgICAgICA8U2VnbWVudEJvdW5kYXJ5VHJpZ2dlck5vZGUgLz5cbiAgICAgICAgPC8+XG4gICAgICApXG4gICAgfVxuXG4gICAgLy8gVE9ETzogVGhlIGxvYWRpbmcgbW9kdWxlIGRhdGEgZm9yIGEgc2VnbWVudCBpcyBzdG9yZWQgb24gdGhlIHBhcmVudCwgdGhlblxuICAgIC8vIGFwcGxpZWQgdG8gZWFjaCBvZiB0aGF0IHBhcmVudCBzZWdtZW50J3MgcGFyYWxsZWwgcm91dGUgc2xvdHMuIEluIHRoZVxuICAgIC8vIHNpbXBsZSBjYXNlIHdoZXJlIHRoZXJlJ3Mgb25seSBvbmUgcGFyYWxsZWwgcm91dGUgKHRoZSBgY2hpbGRyZW5gIHNsb3QpLFxuICAgIC8vIHRoaXMgaXMgbm8gZGlmZmVyZW50IGZyb20gaWYgdGhlIGxvYWRpbmcgbW9kdWxlIGRhdGEgd2hlcmUgc3RvcmVkIG9uIHRoZVxuICAgIC8vIGNoaWxkIGRpcmVjdGx5LiBCdXQgSSdtIG5vdCBzdXJlIHRoaXMgYWN0dWFsbHkgbWFrZXMgc2Vuc2Ugd2hlbiB0aGVyZSBhcmVcbiAgICAvLyBtdWx0aXBsZSBwYXJhbGxlbCByb3V0ZXMuIEl0J3Mgbm90IGEgaHVnZSBpc3N1ZSBiZWNhdXNlIHlvdSBhbHdheXMgaGF2ZVxuICAgIC8vIHRoZSBvcHRpb24gdG8gZGVmaW5lIGEgbmFycm93ZXIgbG9hZGluZyBib3VuZGFyeSBmb3IgYSBwYXJ0aWN1bGFyIHNsb3QuIEJ1dFxuICAgIC8vIHRoaXMgc29ydCBvZiBzbWVsbHMgbGlrZSBhbiBpbXBsZW1lbnRhdGlvbiBhY2NpZGVudCB0byBtZS5cbiAgICBjb25zdCBsb2FkaW5nTW9kdWxlRGF0YSA9IHBhcmVudENhY2hlTm9kZS5sb2FkaW5nXG4gICAgbGV0IGNoaWxkID0gKFxuICAgICAgPFRlbXBsYXRlQ29udGV4dC5Qcm92aWRlclxuICAgICAgICBrZXk9e3N0YXRlS2V5fVxuICAgICAgICB2YWx1ZT17XG4gICAgICAgICAgPFNjcm9sbEFuZEZvY3VzSGFuZGxlciBzZWdtZW50UGF0aD17c2VnbWVudFBhdGh9PlxuICAgICAgICAgICAgPEVycm9yQm91bmRhcnlDb21wb25lbnRcbiAgICAgICAgICAgICAgZXJyb3JDb21wb25lbnQ9e2Vycm9yfVxuICAgICAgICAgICAgICBlcnJvclN0eWxlcz17ZXJyb3JTdHlsZXN9XG4gICAgICAgICAgICAgIGVycm9yU2NyaXB0cz17ZXJyb3JTY3JpcHRzfVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICA8TG9hZGluZ0JvdW5kYXJ5IGxvYWRpbmc9e2xvYWRpbmdNb2R1bGVEYXRhfT5cbiAgICAgICAgICAgICAgICA8SFRUUEFjY2Vzc0ZhbGxiYWNrQm91bmRhcnlcbiAgICAgICAgICAgICAgICAgIG5vdEZvdW5kPXtub3RGb3VuZH1cbiAgICAgICAgICAgICAgICAgIGZvcmJpZGRlbj17Zm9yYmlkZGVufVxuICAgICAgICAgICAgICAgICAgdW5hdXRob3JpemVkPXt1bmF1dGhvcml6ZWR9XG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgPFJlZGlyZWN0Qm91bmRhcnk+XG4gICAgICAgICAgICAgICAgICAgIDxJbm5lckxheW91dFJvdXRlclxuICAgICAgICAgICAgICAgICAgICAgIHVybD17dXJsfVxuICAgICAgICAgICAgICAgICAgICAgIHRyZWU9e3RyZWV9XG4gICAgICAgICAgICAgICAgICAgICAgY2FjaGVOb2RlPXtjYWNoZU5vZGV9XG4gICAgICAgICAgICAgICAgICAgICAgc2VnbWVudFBhdGg9e3NlZ21lbnRQYXRofVxuICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICB7c2VnbWVudEJvdW5kYXJ5VHJpZ2dlck5vZGV9XG4gICAgICAgICAgICAgICAgICA8L1JlZGlyZWN0Qm91bmRhcnk+XG4gICAgICAgICAgICAgICAgPC9IVFRQQWNjZXNzRmFsbGJhY2tCb3VuZGFyeT5cbiAgICAgICAgICAgICAgPC9Mb2FkaW5nQm91bmRhcnk+XG4gICAgICAgICAgICA8L0Vycm9yQm91bmRhcnlDb21wb25lbnQ+XG4gICAgICAgICAgICB7c2VnbWVudFZpZXdTdGF0ZU5vZGV9XG4gICAgICAgICAgPC9TY3JvbGxBbmRGb2N1c0hhbmRsZXI+XG4gICAgICAgIH1cbiAgICAgID5cbiAgICAgICAge3RlbXBsYXRlU3R5bGVzfVxuICAgICAgICB7dGVtcGxhdGVTY3JpcHRzfVxuICAgICAgICB7dGVtcGxhdGV9XG4gICAgICA8L1RlbXBsYXRlQ29udGV4dC5Qcm92aWRlcj5cbiAgICApXG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgY29uc3QgeyBTZWdtZW50U3RhdGVQcm92aWRlciB9ID1cbiAgICAgICAgcmVxdWlyZSgnLi4vLi4vbmV4dC1kZXZ0b29scy91c2Vyc3BhY2UvYXBwL3NlZ21lbnQtZXhwbG9yZXItbm9kZScpIGFzIHR5cGVvZiBpbXBvcnQoJy4uLy4uL25leHQtZGV2dG9vbHMvdXNlcnNwYWNlL2FwcC9zZWdtZW50LWV4cGxvcmVyLW5vZGUnKVxuXG4gICAgICBjaGlsZCA9IChcbiAgICAgICAgPFNlZ21lbnRTdGF0ZVByb3ZpZGVyIGtleT17c3RhdGVLZXl9PlxuICAgICAgICAgIHtjaGlsZH1cbiAgICAgICAgICB7c2VnbWVudFZpZXdCb3VuZGFyaWVzfVxuICAgICAgICA8L1NlZ21lbnRTdGF0ZVByb3ZpZGVyPlxuICAgICAgKVxuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfUk9VVEVSX0JGX0NBQ0hFKSB7XG4gICAgICBjaGlsZCA9IChcbiAgICAgICAgPEFjdGl2aXR5XG4gICAgICAgICAga2V5PXtzdGF0ZUtleX1cbiAgICAgICAgICBtb2RlPXtzdGF0ZUtleSA9PT0gYWN0aXZlU3RhdGVLZXkgPyAndmlzaWJsZScgOiAnaGlkZGVuJ31cbiAgICAgICAgPlxuICAgICAgICAgIHtjaGlsZH1cbiAgICAgICAgPC9BY3Rpdml0eT5cbiAgICAgIClcbiAgICB9XG5cbiAgICBjaGlsZHJlbi5wdXNoKGNoaWxkKVxuXG4gICAgYmZjYWNoZUVudHJ5ID0gYmZjYWNoZUVudHJ5Lm5leHRcbiAgfSB3aGlsZSAoYmZjYWNoZUVudHJ5ICE9PSBudWxsKVxuXG4gIHJldHVybiBjaGlsZHJlblxufVxuIl0sIm5hbWVzIjpbIkFDVElPTl9TRVJWRVJfUEFUQ0giLCJSZWFjdCIsInVzZUNvbnRleHQiLCJ1c2UiLCJzdGFydFRyYW5zaXRpb24iLCJTdXNwZW5zZSIsInVzZURlZmVycmVkVmFsdWUiLCJSZWFjdERPTSIsIkxheW91dFJvdXRlckNvbnRleHQiLCJHbG9iYWxMYXlvdXRSb3V0ZXJDb250ZXh0IiwiVGVtcGxhdGVDb250ZXh0IiwiZmV0Y2hTZXJ2ZXJSZXNwb25zZSIsInVucmVzb2x2ZWRUaGVuYWJsZSIsIkVycm9yQm91bmRhcnkiLCJtYXRjaFNlZ21lbnQiLCJkaXNhYmxlU21vb3RoU2Nyb2xsRHVyaW5nUm91dGVUcmFuc2l0aW9uIiwiUmVkaXJlY3RCb3VuZGFyeSIsIkhUVFBBY2Nlc3NGYWxsYmFja0JvdW5kYXJ5IiwiY3JlYXRlUm91dGVyQ2FjaGVLZXkiLCJoYXNJbnRlcmNlcHRpb25Sb3V0ZUluQ3VycmVudFRyZWUiLCJkaXNwYXRjaEFwcFJvdXRlckFjdGlvbiIsInVzZVJvdXRlckJGQ2FjaGUiLCJub3JtYWxpemVBcHBQYXRoIiwiQWN0aXZpdHkiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX1JPVVRFUl9CRl9DQUNIRSIsInJlcXVpcmUiLCJ1bnN0YWJsZV9BY3Rpdml0eSIsIndhbGtBZGRSZWZldGNoIiwic2VnbWVudFBhdGhUb1dhbGsiLCJ0cmVlVG9SZWNyZWF0ZSIsInNlZ21lbnQiLCJwYXJhbGxlbFJvdXRlS2V5IiwiaXNMYXN0IiwibGVuZ3RoIiwiaGFzT3duUHJvcGVydHkiLCJzdWJUcmVlIiwidW5kZWZpbmVkIiwic2xpY2UiLCJfX0RPTV9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUiLCJmaW5kRE9NTm9kZSIsImluc3RhbmNlIiwid2luZG93IiwiaW50ZXJuYWxfcmVhY3RET01maW5kRE9NTm9kZSIsInJlY3RQcm9wZXJ0aWVzIiwic2hvdWxkU2tpcEVsZW1lbnQiLCJlbGVtZW50IiwiaW5jbHVkZXMiLCJnZXRDb21wdXRlZFN0eWxlIiwicG9zaXRpb24iLCJOT0RFX0VOViIsImNvbnNvbGUiLCJ3YXJuIiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImV2ZXJ5IiwiaXRlbSIsInRvcE9mRWxlbWVudEluVmlld3BvcnQiLCJ2aWV3cG9ydEhlaWdodCIsInRvcCIsImdldEhhc2hGcmFnbWVudERvbU5vZGUiLCJoYXNoRnJhZ21lbnQiLCJkb2N1bWVudCIsImJvZHkiLCJnZXRFbGVtZW50QnlJZCIsImdldEVsZW1lbnRzQnlOYW1lIiwiSW5uZXJTY3JvbGxBbmRGb2N1c0hhbmRsZXIiLCJDb21wb25lbnQiLCJjb21wb25lbnREaWRNb3VudCIsImhhbmRsZVBvdGVudGlhbFNjcm9sbCIsImNvbXBvbmVudERpZFVwZGF0ZSIsInByb3BzIiwiZm9jdXNBbmRTY3JvbGxSZWYiLCJhcHBseSIsInJlbmRlciIsImNoaWxkcmVuIiwic2VnbWVudFBhdGgiLCJzZWdtZW50UGF0aHMiLCJzb21lIiwic2Nyb2xsUmVmU2VnbWVudFBhdGgiLCJpbmRleCIsImRvbU5vZGUiLCJFbGVtZW50IiwiSFRNTEVsZW1lbnQiLCJwYXJlbnRFbGVtZW50IiwibG9jYWxOYW1lIiwibmV4dEVsZW1lbnRTaWJsaW5nIiwic2Nyb2xsSW50b1ZpZXciLCJodG1sRWxlbWVudCIsImRvY3VtZW50RWxlbWVudCIsImNsaWVudEhlaWdodCIsInNjcm9sbFRvcCIsImRvbnRGb3JjZUxheW91dCIsIm9ubHlIYXNoQ2hhbmdlIiwiZm9jdXMiLCJTY3JvbGxBbmRGb2N1c0hhbmRsZXIiLCJjb250ZXh0IiwiRXJyb3IiLCJJbm5lckxheW91dFJvdXRlciIsInRyZWUiLCJjYWNoZU5vZGUiLCJ1cmwiLCJmdWxsVHJlZSIsInJlc29sdmVkUHJlZmV0Y2hSc2MiLCJwcmVmZXRjaFJzYyIsInJzYyIsInJlc29sdmVkUnNjIiwidGhlbiIsImxhenlEYXRhIiwicmVmZXRjaFRyZWUiLCJpbmNsdWRlTmV4dFVybCIsIm5hdmlnYXRlZEF0IiwiRGF0ZSIsIm5vdyIsIlVSTCIsImxvY2F0aW9uIiwib3JpZ2luIiwiZmxpZ2h0Um91dGVyU3RhdGUiLCJuZXh0VXJsIiwic2VydmVyUmVzcG9uc2UiLCJ0eXBlIiwicHJldmlvdXNUcmVlIiwic3VidHJlZSIsIlByb3ZpZGVyIiwidmFsdWUiLCJwYXJlbnRUcmVlIiwicGFyZW50Q2FjaGVOb2RlIiwicGFyZW50U2VnbWVudFBhdGgiLCJMb2FkaW5nQm91bmRhcnkiLCJsb2FkaW5nIiwibG9hZGluZ01vZHVsZURhdGEiLCJwcm9taXNlRm9yTG9hZGluZyIsImxvYWRpbmdSc2MiLCJsb2FkaW5nU3R5bGVzIiwibG9hZGluZ1NjcmlwdHMiLCJmYWxsYmFjayIsIlJlbmRlckNoaWxkcmVuIiwiT3V0ZXJMYXlvdXRSb3V0ZXIiLCJwYXJhbGxlbFJvdXRlcktleSIsImVycm9yIiwiZXJyb3JTdHlsZXMiLCJlcnJvclNjcmlwdHMiLCJ0ZW1wbGF0ZVN0eWxlcyIsInRlbXBsYXRlU2NyaXB0cyIsInRlbXBsYXRlIiwibm90Rm91bmQiLCJmb3JiaWRkZW4iLCJ1bmF1dGhvcml6ZWQiLCJncmFjZWZ1bGx5RGVncmFkZSIsInNlZ21lbnRWaWV3Qm91bmRhcmllcyIsInBhcmVudFBhcmFsbGVsUm91dGVzIiwicGFyYWxsZWxSb3V0ZXMiLCJzZWdtZW50TWFwIiwiZ2V0IiwiTWFwIiwic2V0IiwicGFyZW50VHJlZVNlZ21lbnQiLCJjb25jYXQiLCJhY3RpdmVUcmVlIiwiYWN0aXZlU2VnbWVudCIsImFjdGl2ZVN0YXRlS2V5IiwiYmZjYWNoZUVudHJ5Iiwic3RhdGVLZXkiLCJjYWNoZUtleSIsIm5ld0xhenlDYWNoZU5vZGUiLCJoZWFkIiwicHJlZmV0Y2hIZWFkIiwiRXJyb3JCb3VuZGFyeUNvbXBvbmVudCIsInNlZ21lbnRCb3VuZGFyeVRyaWdnZXJOb2RlIiwic2VnbWVudFZpZXdTdGF0ZU5vZGUiLCJfX05FWFRfREVWVE9PTF9TRUdNRU5UX0VYUExPUkVSIiwiU2VnbWVudEJvdW5kYXJ5VHJpZ2dlck5vZGUiLCJTZWdtZW50Vmlld1N0YXRlTm9kZSIsInBhZ2VQcmVmaXgiLCJwYWdlIiwiY2hpbGQiLCJlcnJvckNvbXBvbmVudCIsIlNlZ21lbnRTdGF0ZVByb3ZpZGVyIiwibW9kZSIsInB1c2giLCJuZXh0Il0sIm1hcHBpbmdzIjoiIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDk3LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9lc20vY2xpZW50L2NvbXBvbmVudHMvcmVuZGVyLWZyb20tdGVtcGxhdGUtY29udGV4dC5qcy9wcm94eS5janMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgeyBjcmVhdGVDbGllbnRNb2R1bGVQcm94eSB9ID0gcmVxdWlyZShcInJlYWN0LXNlcnZlci1kb20tdHVyYm9wYWNrL3NlcnZlclwiKTtcblxuX190dXJib3BhY2tfY29udGV4dF9fLm4oY3JlYXRlQ2xpZW50TW9kdWxlUHJveHkoXCJbcHJvamVjdF0vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9lc20vY2xpZW50L2NvbXBvbmVudHMvcmVuZGVyLWZyb20tdGVtcGxhdGUtY29udGV4dC5qcyA8bW9kdWxlIGV2YWx1YXRpb24+XCIpKTtcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxNQUFNLEVBQUUsdUJBQXVCLEVBQUU7QUFFakMsc0JBQXNCLENBQUMsQ0FBQyx3QkFBd0IiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTA0LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9lc20vY2xpZW50L2NvbXBvbmVudHMvcmVuZGVyLWZyb20tdGVtcGxhdGUtY29udGV4dC5qcy9wcm94eS5janMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgeyBjcmVhdGVDbGllbnRNb2R1bGVQcm94eSB9ID0gcmVxdWlyZShcInJlYWN0LXNlcnZlci1kb20tdHVyYm9wYWNrL3NlcnZlclwiKTtcblxuX190dXJib3BhY2tfY29udGV4dF9fLm4oY3JlYXRlQ2xpZW50TW9kdWxlUHJveHkoXCJbcHJvamVjdF0vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9lc20vY2xpZW50L2NvbXBvbmVudHMvcmVuZGVyLWZyb20tdGVtcGxhdGUtY29udGV4dC5qc1wiKSk7XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsTUFBTSxFQUFFLHVCQUF1QixFQUFFO0FBRWpDLHNCQUFzQixDQUFDLENBQUMsd0JBQXdCIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDExMCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL2NsaWVudC9jb21wb25lbnRzL3JlbmRlci1mcm9tLXRlbXBsYXRlLWNvbnRleHQudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuXG5pbXBvcnQgUmVhY3QsIHsgdXNlQ29udGV4dCwgdHlwZSBKU1ggfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IFRlbXBsYXRlQ29udGV4dCB9IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBSZW5kZXJGcm9tVGVtcGxhdGVDb250ZXh0KCk6IEpTWC5FbGVtZW50IHtcbiAgY29uc3QgY2hpbGRyZW4gPSB1c2VDb250ZXh0KFRlbXBsYXRlQ29udGV4dClcbiAgcmV0dXJuIDw+e2NoaWxkcmVufTwvPlxufVxuIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlQ29udGV4dCIsIlRlbXBsYXRlQ29udGV4dCIsIlJlbmRlckZyb21UZW1wbGF0ZUNvbnRleHQiLCJjaGlsZHJlbiJdLCJtYXBwaW5ncyI6IiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxMTksICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2VzbS9jbGllbnQvY29tcG9uZW50cy9jbGllbnQtcGFnZS5qcy9wcm94eS5janMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgeyBjcmVhdGVDbGllbnRNb2R1bGVQcm94eSB9ID0gcmVxdWlyZShcInJlYWN0LXNlcnZlci1kb20tdHVyYm9wYWNrL3NlcnZlclwiKTtcblxuX190dXJib3BhY2tfY29udGV4dF9fLm4oY3JlYXRlQ2xpZW50TW9kdWxlUHJveHkoXCJbcHJvamVjdF0vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9lc20vY2xpZW50L2NvbXBvbmVudHMvY2xpZW50LXBhZ2UuanMgPG1vZHVsZSBldmFsdWF0aW9uPlwiKSk7XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsTUFBTSxFQUFFLHVCQUF1QixFQUFFO0FBRWpDLHNCQUFzQixDQUFDLENBQUMsd0JBQXdCIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDEyNiwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvZXNtL2NsaWVudC9jb21wb25lbnRzL2NsaWVudC1wYWdlLmpzL3Byb3h5LmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB7IGNyZWF0ZUNsaWVudE1vZHVsZVByb3h5IH0gPSByZXF1aXJlKFwicmVhY3Qtc2VydmVyLWRvbS10dXJib3BhY2svc2VydmVyXCIpO1xuXG5fX3R1cmJvcGFja19jb250ZXh0X18ubihjcmVhdGVDbGllbnRNb2R1bGVQcm94eShcIltwcm9qZWN0XS9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2VzbS9jbGllbnQvY29tcG9uZW50cy9jbGllbnQtcGFnZS5qc1wiKSk7XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsTUFBTSxFQUFFLHVCQUF1QixFQUFFO0FBRWpDLHNCQUFzQixDQUFDLENBQUMsd0JBQXdCIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDEzMiwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL2NsaWVudC9jb21wb25lbnRzL2NsaWVudC1wYWdlLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuaW1wb3J0IHR5cGUgeyBQYXJzZWRVcmxRdWVyeSB9IGZyb20gJ3F1ZXJ5c3RyaW5nJ1xuaW1wb3J0IHsgSW52YXJpYW50RXJyb3IgfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL2ludmFyaWFudC1lcnJvcidcblxuaW1wb3J0IHR5cGUgeyBQYXJhbXMgfSBmcm9tICcuLi8uLi9zZXJ2ZXIvcmVxdWVzdC9wYXJhbXMnXG5cbi8qKlxuICogV2hlbiB0aGUgUGFnZSBpcyBhIGNsaWVudCBjb21wb25lbnQgd2Ugc2VuZCB0aGUgcGFyYW1zIGFuZCBzZWFyY2hQYXJhbXMgdG8gdGhpcyBjbGllbnQgd3JhcHBlclxuICogd2hlcmUgdGhleSBhcmUgdHVybmVkIGludG8gZHluYW1pY2FsbHkgdHJhY2tlZCB2YWx1ZXMgYmVmb3JlIGJlaW5nIHBhc3NlZCB0byB0aGUgYWN0dWFsIFBhZ2UgY29tcG9uZW50LlxuICpcbiAqIGFkZGl0aW9uYWxseSB3ZSBtYXkgc2VuZCBwcm9taXNlcyByZXByZXNlbnRpbmcgdGhlIHBhcmFtcyBhbmQgc2VhcmNoUGFyYW1zLiBXZSBkb24ndCBldmVyIHVzZSB0aGVzZSBwYXNzZWRcbiAqIHZhbHVlcyBidXQgaXQgY2FuIGJlIG5lY2Vzc2FyeSBmb3IgdGhlIHNlbmRlciB0byBzZW5kIGEgUHJvbWlzZSB0aGF0IGRvZXNuJ3QgcmVzb2x2ZSBpbiBjZXJ0YWluIHNpdHVhdGlvbnMuXG4gKiBJdCBpcyB1cCB0byB0aGUgY2FsbGVyIHRvIGRlY2lkZSBpZiB0aGUgcHJvbWlzZXMgYXJlIG5lZWRlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIENsaWVudFBhZ2VSb290KHtcbiAgQ29tcG9uZW50LFxuICBzZWFyY2hQYXJhbXMsXG4gIHBhcmFtcyxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICBwcm9taXNlcyxcbn06IHtcbiAgQ29tcG9uZW50OiBSZWFjdC5Db21wb25lbnRUeXBlPGFueT5cbiAgc2VhcmNoUGFyYW1zOiBQYXJzZWRVcmxRdWVyeVxuICBwYXJhbXM6IFBhcmFtc1xuICBwcm9taXNlcz86IEFycmF5PFByb21pc2U8YW55Pj5cbn0pIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc3QgeyB3b3JrQXN5bmNTdG9yYWdlIH0gPVxuICAgICAgcmVxdWlyZSgnLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvd29yay1hc3luYy1zdG9yYWdlLmV4dGVybmFsJykgYXMgdHlwZW9mIGltcG9ydCgnLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvd29yay1hc3luYy1zdG9yYWdlLmV4dGVybmFsJylcblxuICAgIGxldCBjbGllbnRTZWFyY2hQYXJhbXM6IFByb21pc2U8UGFyc2VkVXJsUXVlcnk+XG4gICAgbGV0IGNsaWVudFBhcmFtczogUHJvbWlzZTxQYXJhbXM+XG4gICAgLy8gV2UgYXJlIGdvaW5nIHRvIGluc3RydW1lbnQgdGhlIHNlYXJjaFBhcmFtcyBwcm9wIHdpdGggdHJhY2tpbmcgZm9yIHRoZVxuICAgIC8vIGFwcHJvcHJpYXRlIGNvbnRleHQuIFdlIHdyYXAgZGlmZmVyZW50bHkgaW4gcHJlcmVuZGVyaW5nIHZzIHJlbmRlcmluZ1xuICAgIGNvbnN0IHN0b3JlID0gd29ya0FzeW5jU3RvcmFnZS5nZXRTdG9yZSgpXG4gICAgaWYgKCFzdG9yZSkge1xuICAgICAgdGhyb3cgbmV3IEludmFyaWFudEVycm9yKFxuICAgICAgICAnRXhwZWN0ZWQgd29ya1N0b3JlIHRvIGV4aXN0IHdoZW4gaGFuZGxpbmcgc2VhcmNoUGFyYW1zIGluIGEgY2xpZW50IFBhZ2UuJ1xuICAgICAgKVxuICAgIH1cblxuICAgIGNvbnN0IHsgY3JlYXRlU2VhcmNoUGFyYW1zRnJvbUNsaWVudCB9ID1cbiAgICAgIHJlcXVpcmUoJy4uLy4uL3NlcnZlci9yZXF1ZXN0L3NlYXJjaC1wYXJhbXMnKSBhcyB0eXBlb2YgaW1wb3J0KCcuLi8uLi9zZXJ2ZXIvcmVxdWVzdC9zZWFyY2gtcGFyYW1zJylcbiAgICBjbGllbnRTZWFyY2hQYXJhbXMgPSBjcmVhdGVTZWFyY2hQYXJhbXNGcm9tQ2xpZW50KHNlYXJjaFBhcmFtcywgc3RvcmUpXG5cbiAgICBjb25zdCB7IGNyZWF0ZVBhcmFtc0Zyb21DbGllbnQgfSA9XG4gICAgICByZXF1aXJlKCcuLi8uLi9zZXJ2ZXIvcmVxdWVzdC9wYXJhbXMnKSBhcyB0eXBlb2YgaW1wb3J0KCcuLi8uLi9zZXJ2ZXIvcmVxdWVzdC9wYXJhbXMnKVxuICAgIGNsaWVudFBhcmFtcyA9IGNyZWF0ZVBhcmFtc0Zyb21DbGllbnQocGFyYW1zLCBzdG9yZSlcblxuICAgIHJldHVybiA8Q29tcG9uZW50IHBhcmFtcz17Y2xpZW50UGFyYW1zfSBzZWFyY2hQYXJhbXM9e2NsaWVudFNlYXJjaFBhcmFtc30gLz5cbiAgfSBlbHNlIHtcbiAgICBjb25zdCB7IGNyZWF0ZVJlbmRlclNlYXJjaFBhcmFtc0Zyb21DbGllbnQgfSA9XG4gICAgICByZXF1aXJlKCcuLi9yZXF1ZXN0L3NlYXJjaC1wYXJhbXMuYnJvd3NlcicpIGFzIHR5cGVvZiBpbXBvcnQoJy4uL3JlcXVlc3Qvc2VhcmNoLXBhcmFtcy5icm93c2VyJylcbiAgICBjb25zdCBjbGllbnRTZWFyY2hQYXJhbXMgPSBjcmVhdGVSZW5kZXJTZWFyY2hQYXJhbXNGcm9tQ2xpZW50KHNlYXJjaFBhcmFtcylcbiAgICBjb25zdCB7IGNyZWF0ZVJlbmRlclBhcmFtc0Zyb21DbGllbnQgfSA9XG4gICAgICByZXF1aXJlKCcuLi9yZXF1ZXN0L3BhcmFtcy5icm93c2VyJykgYXMgdHlwZW9mIGltcG9ydCgnLi4vcmVxdWVzdC9wYXJhbXMuYnJvd3NlcicpXG4gICAgY29uc3QgY2xpZW50UGFyYW1zID0gY3JlYXRlUmVuZGVyUGFyYW1zRnJvbUNsaWVudChwYXJhbXMpXG5cbiAgICByZXR1cm4gPENvbXBvbmVudCBwYXJhbXM9e2NsaWVudFBhcmFtc30gc2VhcmNoUGFyYW1zPXtjbGllbnRTZWFyY2hQYXJhbXN9IC8+XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJJbnZhcmlhbnRFcnJvciIsIkNsaWVudFBhZ2VSb290IiwiQ29tcG9uZW50Iiwic2VhcmNoUGFyYW1zIiwicGFyYW1zIiwicHJvbWlzZXMiLCJ3aW5kb3ciLCJ3b3JrQXN5bmNTdG9yYWdlIiwicmVxdWlyZSIsImNsaWVudFNlYXJjaFBhcmFtcyIsImNsaWVudFBhcmFtcyIsInN0b3JlIiwiZ2V0U3RvcmUiLCJjcmVhdGVTZWFyY2hQYXJhbXNGcm9tQ2xpZW50IiwiY3JlYXRlUGFyYW1zRnJvbUNsaWVudCIsImNyZWF0ZVJlbmRlclNlYXJjaFBhcmFtc0Zyb21DbGllbnQiLCJjcmVhdGVSZW5kZXJQYXJhbXNGcm9tQ2xpZW50Il0sIm1hcHBpbmdzIjoiIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDE0MSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvZXNtL2NsaWVudC9jb21wb25lbnRzL2NsaWVudC1zZWdtZW50LmpzL3Byb3h5LmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB7IGNyZWF0ZUNsaWVudE1vZHVsZVByb3h5IH0gPSByZXF1aXJlKFwicmVhY3Qtc2VydmVyLWRvbS10dXJib3BhY2svc2VydmVyXCIpO1xuXG5fX3R1cmJvcGFja19jb250ZXh0X18ubihjcmVhdGVDbGllbnRNb2R1bGVQcm94eShcIltwcm9qZWN0XS9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2VzbS9jbGllbnQvY29tcG9uZW50cy9jbGllbnQtc2VnbWVudC5qcyA8bW9kdWxlIGV2YWx1YXRpb24+XCIpKTtcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxNQUFNLEVBQUUsdUJBQXVCLEVBQUU7QUFFakMsc0JBQXNCLENBQUMsQ0FBQyx3QkFBd0IiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTQ4LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9lc20vY2xpZW50L2NvbXBvbmVudHMvY2xpZW50LXNlZ21lbnQuanMvcHJveHkuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHsgY3JlYXRlQ2xpZW50TW9kdWxlUHJveHkgfSA9IHJlcXVpcmUoXCJyZWFjdC1zZXJ2ZXItZG9tLXR1cmJvcGFjay9zZXJ2ZXJcIik7XG5cbl9fdHVyYm9wYWNrX2NvbnRleHRfXy5uKGNyZWF0ZUNsaWVudE1vZHVsZVByb3h5KFwiW3Byb2plY3RdL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvZXNtL2NsaWVudC9jb21wb25lbnRzL2NsaWVudC1zZWdtZW50LmpzXCIpKTtcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxNQUFNLEVBQUUsdUJBQXVCLEVBQUU7QUFFakMsc0JBQXNCLENBQUMsQ0FBQyx3QkFBd0IiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTU0LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zcmMvY2xpZW50L2NvbXBvbmVudHMvY2xpZW50LXNlZ21lbnQudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuXG5pbXBvcnQgeyBJbnZhcmlhbnRFcnJvciB9IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvaW52YXJpYW50LWVycm9yJ1xuXG5pbXBvcnQgdHlwZSB7IFBhcmFtcyB9IGZyb20gJy4uLy4uL3NlcnZlci9yZXF1ZXN0L3BhcmFtcydcblxuLyoqXG4gKiBXaGVuIHRoZSBQYWdlIGlzIGEgY2xpZW50IGNvbXBvbmVudCB3ZSBzZW5kIHRoZSBwYXJhbXMgdG8gdGhpcyBjbGllbnQgd3JhcHBlclxuICogd2hlcmUgdGhleSBhcmUgdHVybmVkIGludG8gZHluYW1pY2FsbHkgdHJhY2tlZCB2YWx1ZXMgYmVmb3JlIGJlaW5nIHBhc3NlZCB0byB0aGUgYWN0dWFsIFNlZ21lbnQgY29tcG9uZW50LlxuICpcbiAqIGFkZGl0aW9uYWxseSB3ZSBtYXkgc2VuZCBhIHByb21pc2UgcmVwcmVzZW50aW5nIHBhcmFtcy4gV2UgZG9uJ3QgZXZlciB1c2UgdGhpcyBwYXNzZWRcbiAqIHZhbHVlIGJ1dCBpdCBjYW4gYmUgbmVjZXNzYXJ5IGZvciB0aGUgc2VuZGVyIHRvIHNlbmQgYSBQcm9taXNlIHRoYXQgZG9lc24ndCByZXNvbHZlIGluIGNlcnRhaW4gc2l0dWF0aW9uc1xuICogc3VjaCBhcyB3aGVuIGR5bmFtaWNJTyBpcyBlbmFibGVkLiBJdCBpcyB1cCB0byB0aGUgY2FsbGVyIHRvIGRlY2lkZSBpZiB0aGUgcHJvbWlzZXMgYXJlIG5lZWRlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIENsaWVudFNlZ21lbnRSb290KHtcbiAgQ29tcG9uZW50LFxuICBzbG90cyxcbiAgcGFyYW1zLFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gIHByb21pc2UsXG59OiB7XG4gIENvbXBvbmVudDogUmVhY3QuQ29tcG9uZW50VHlwZTxhbnk+XG4gIHNsb3RzOiB7IFtrZXk6IHN0cmluZ106IFJlYWN0LlJlYWN0Tm9kZSB9XG4gIHBhcmFtczogUGFyYW1zXG4gIHByb21pc2U/OiBQcm9taXNlPGFueT5cbn0pIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc3QgeyB3b3JrQXN5bmNTdG9yYWdlIH0gPVxuICAgICAgcmVxdWlyZSgnLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvd29yay1hc3luYy1zdG9yYWdlLmV4dGVybmFsJykgYXMgdHlwZW9mIGltcG9ydCgnLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvd29yay1hc3luYy1zdG9yYWdlLmV4dGVybmFsJylcblxuICAgIGxldCBjbGllbnRQYXJhbXM6IFByb21pc2U8UGFyYW1zPlxuICAgIC8vIFdlIGFyZSBnb2luZyB0byBpbnN0cnVtZW50IHRoZSBzZWFyY2hQYXJhbXMgcHJvcCB3aXRoIHRyYWNraW5nIGZvciB0aGVcbiAgICAvLyBhcHByb3ByaWF0ZSBjb250ZXh0LiBXZSB3cmFwIGRpZmZlcmVudGx5IGluIHByZXJlbmRlcmluZyB2cyByZW5kZXJpbmdcbiAgICBjb25zdCBzdG9yZSA9IHdvcmtBc3luY1N0b3JhZ2UuZ2V0U3RvcmUoKVxuICAgIGlmICghc3RvcmUpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhcmlhbnRFcnJvcihcbiAgICAgICAgJ0V4cGVjdGVkIHdvcmtTdG9yZSB0byBleGlzdCB3aGVuIGhhbmRsaW5nIHBhcmFtcyBpbiBhIGNsaWVudCBzZWdtZW50IHN1Y2ggYXMgYSBMYXlvdXQgb3IgVGVtcGxhdGUuJ1xuICAgICAgKVxuICAgIH1cblxuICAgIGNvbnN0IHsgY3JlYXRlUGFyYW1zRnJvbUNsaWVudCB9ID1cbiAgICAgIHJlcXVpcmUoJy4uLy4uL3NlcnZlci9yZXF1ZXN0L3BhcmFtcycpIGFzIHR5cGVvZiBpbXBvcnQoJy4uLy4uL3NlcnZlci9yZXF1ZXN0L3BhcmFtcycpXG4gICAgY2xpZW50UGFyYW1zID0gY3JlYXRlUGFyYW1zRnJvbUNsaWVudChwYXJhbXMsIHN0b3JlKVxuXG4gICAgcmV0dXJuIDxDb21wb25lbnQgey4uLnNsb3RzfSBwYXJhbXM9e2NsaWVudFBhcmFtc30gLz5cbiAgfSBlbHNlIHtcbiAgICBjb25zdCB7IGNyZWF0ZVJlbmRlclBhcmFtc0Zyb21DbGllbnQgfSA9XG4gICAgICByZXF1aXJlKCcuLi9yZXF1ZXN0L3BhcmFtcy5icm93c2VyJykgYXMgdHlwZW9mIGltcG9ydCgnLi4vcmVxdWVzdC9wYXJhbXMuYnJvd3NlcicpXG4gICAgY29uc3QgY2xpZW50UGFyYW1zID0gY3JlYXRlUmVuZGVyUGFyYW1zRnJvbUNsaWVudChwYXJhbXMpXG4gICAgcmV0dXJuIDxDb21wb25lbnQgey4uLnNsb3RzfSBwYXJhbXM9e2NsaWVudFBhcmFtc30gLz5cbiAgfVxufVxuIl0sIm5hbWVzIjpbIkludmFyaWFudEVycm9yIiwiQ2xpZW50U2VnbWVudFJvb3QiLCJDb21wb25lbnQiLCJzbG90cyIsInBhcmFtcyIsInByb21pc2UiLCJ3aW5kb3ciLCJ3b3JrQXN5bmNTdG9yYWdlIiwicmVxdWlyZSIsImNsaWVudFBhcmFtcyIsInN0b3JlIiwiZ2V0U3RvcmUiLCJjcmVhdGVQYXJhbXNGcm9tQ2xpZW50IiwiY3JlYXRlUmVuZGVyUGFyYW1zRnJvbUNsaWVudCJdLCJtYXBwaW5ncyI6IiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxNjIsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NyYy9zZXJ2ZXIvd2ViL3NwZWMtZXh0ZW5zaW9uL2FkYXB0ZXJzL3JlZmxlY3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNsYXNzIFJlZmxlY3RBZGFwdGVyIHtcbiAgc3RhdGljIGdldDxUIGV4dGVuZHMgb2JqZWN0PihcbiAgICB0YXJnZXQ6IFQsXG4gICAgcHJvcDogc3RyaW5nIHwgc3ltYm9sLFxuICAgIHJlY2VpdmVyOiB1bmtub3duXG4gICk6IGFueSB7XG4gICAgY29uc3QgdmFsdWUgPSBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiB2YWx1ZS5iaW5kKHRhcmdldClcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIHN0YXRpYyBzZXQ8VCBleHRlbmRzIG9iamVjdD4oXG4gICAgdGFyZ2V0OiBULFxuICAgIHByb3A6IHN0cmluZyB8IHN5bWJvbCxcbiAgICB2YWx1ZTogYW55LFxuICAgIHJlY2VpdmVyOiBhbnlcbiAgKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIFJlZmxlY3Quc2V0KHRhcmdldCwgcHJvcCwgdmFsdWUsIHJlY2VpdmVyKVxuICB9XG5cbiAgc3RhdGljIGhhczxUIGV4dGVuZHMgb2JqZWN0Pih0YXJnZXQ6IFQsIHByb3A6IHN0cmluZyB8IHN5bWJvbCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3ApXG4gIH1cblxuICBzdGF0aWMgZGVsZXRlUHJvcGVydHk8VCBleHRlbmRzIG9iamVjdD4oXG4gICAgdGFyZ2V0OiBULFxuICAgIHByb3A6IHN0cmluZyB8IHN5bWJvbFxuICApOiBib29sZWFuIHtcbiAgICByZXR1cm4gUmVmbGVjdC5kZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3ApXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJSZWZsZWN0QWRhcHRlciIsImdldCIsInRhcmdldCIsInByb3AiLCJyZWNlaXZlciIsInZhbHVlIiwiUmVmbGVjdCIsImJpbmQiLCJzZXQiLCJoYXMiLCJkZWxldGVQcm9wZXJ0eSJdLCJtYXBwaW5ncyI6Ijs7O0FBQU8sTUFBTUE7SUFDWCxPQUFPQyxJQUNMQyxNQUFTLEVBQ1RDLElBQXFCLEVBQ3JCQyxRQUFpQixFQUNaO1FBQ0wsTUFBTUMsUUFBUUMsUUFBUUwsR0FBRyxDQUFDQyxRQUFRQyxNQUFNQztRQUN4QyxJQUFJLE9BQU9DLFVBQVUsWUFBWTtZQUMvQixPQUFPQSxNQUFNRSxJQUFJLENBQUNMO1FBQ3BCO1FBRUEsT0FBT0c7SUFDVDtJQUVBLE9BQU9HLElBQ0xOLE1BQVMsRUFDVEMsSUFBcUIsRUFDckJFLEtBQVUsRUFDVkQsUUFBYSxFQUNKO1FBQ1QsT0FBT0UsUUFBUUUsR0FBRyxDQUFDTixRQUFRQyxNQUFNRSxPQUFPRDtJQUMxQztJQUVBLE9BQU9LLElBQXNCUCxNQUFTLEVBQUVDLElBQXFCLEVBQVc7UUFDdEUsT0FBT0csUUFBUUcsR0FBRyxDQUFDUCxRQUFRQztJQUM3QjtJQUVBLE9BQU9PLGVBQ0xSLE1BQVMsRUFDVEMsSUFBcUIsRUFDWjtRQUNULE9BQU9HLFFBQVFJLGNBQWMsQ0FBQ1IsUUFBUUM7SUFDeEM7QUFDRiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxODcsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NyYy9jbGllbnQvY29tcG9uZW50cy9ob29rcy1zZXJ2ZXItY29udGV4dC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBEWU5BTUlDX0VSUk9SX0NPREUgPSAnRFlOQU1JQ19TRVJWRVJfVVNBR0UnXG5cbmV4cG9ydCBjbGFzcyBEeW5hbWljU2VydmVyRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGRpZ2VzdDogdHlwZW9mIERZTkFNSUNfRVJST1JfQ09ERSA9IERZTkFNSUNfRVJST1JfQ09ERVxuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyByZWFkb25seSBkZXNjcmlwdGlvbjogc3RyaW5nKSB7XG4gICAgc3VwZXIoYER5bmFtaWMgc2VydmVyIHVzYWdlOiAke2Rlc2NyaXB0aW9ufWApXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRHluYW1pY1NlcnZlckVycm9yKGVycjogdW5rbm93bik6IGVyciBpcyBEeW5hbWljU2VydmVyRXJyb3Ige1xuICBpZiAoXG4gICAgdHlwZW9mIGVyciAhPT0gJ29iamVjdCcgfHxcbiAgICBlcnIgPT09IG51bGwgfHxcbiAgICAhKCdkaWdlc3QnIGluIGVycikgfHxcbiAgICB0eXBlb2YgZXJyLmRpZ2VzdCAhPT0gJ3N0cmluZydcbiAgKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gZXJyLmRpZ2VzdCA9PT0gRFlOQU1JQ19FUlJPUl9DT0RFXG59XG4iXSwibmFtZXMiOlsiRFlOQU1JQ19FUlJPUl9DT0RFIiwiRHluYW1pY1NlcnZlckVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsImRlc2NyaXB0aW9uIiwiZGlnZXN0IiwiaXNEeW5hbWljU2VydmVyRXJyb3IiLCJlcnIiXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxNQUFNQSxxQkFBcUI7QUFFcEIsTUFBTUMsMkJBQTJCQztJQUd0Q0MsWUFBNEJDLFdBQW1CLENBQUU7UUFDL0MsS0FBSyxDQUFFLDJCQUF3QkEsY0FBQUEsSUFBQUEsQ0FETEEsV0FBQUEsR0FBQUEsYUFBQUEsSUFBQUEsQ0FGNUJDLE1BQUFBLEdBQW9DTDtJQUlwQztBQUNGO0FBRU8sU0FBU00scUJBQXFCQyxHQUFZO0lBQy9DLElBQ0UsT0FBT0EsUUFBUSxZQUNmQSxRQUFRLFFBQ1IsQ0FBRSxDQUFBLFlBQVlBLEdBQUUsS0FDaEIsT0FBT0EsSUFBSUYsTUFBTSxLQUFLLFVBQ3RCO1FBQ0EsT0FBTztJQUNUO0lBRUEsT0FBT0UsSUFBSUYsTUFBTSxLQUFLTDtBQUN4QiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAyMDcsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NyYy9jbGllbnQvY29tcG9uZW50cy9zdGF0aWMtZ2VuZXJhdGlvbi1iYWlsb3V0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IE5FWFRfU1RBVElDX0dFTl9CQUlMT1VUID0gJ05FWFRfU1RBVElDX0dFTl9CQUlMT1VUJ1xuXG5leHBvcnQgY2xhc3MgU3RhdGljR2VuQmFpbG91dEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBwdWJsaWMgcmVhZG9ubHkgY29kZSA9IE5FWFRfU1RBVElDX0dFTl9CQUlMT1VUXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1N0YXRpY0dlbkJhaWxvdXRFcnJvcihcbiAgZXJyb3I6IHVua25vd25cbik6IGVycm9yIGlzIFN0YXRpY0dlbkJhaWxvdXRFcnJvciB7XG4gIGlmICh0eXBlb2YgZXJyb3IgIT09ICdvYmplY3QnIHx8IGVycm9yID09PSBudWxsIHx8ICEoJ2NvZGUnIGluIGVycm9yKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIGVycm9yLmNvZGUgPT09IE5FWFRfU1RBVElDX0dFTl9CQUlMT1VUXG59XG4iXSwibmFtZXMiOlsiTkVYVF9TVEFUSUNfR0VOX0JBSUxPVVQiLCJTdGF0aWNHZW5CYWlsb3V0RXJyb3IiLCJFcnJvciIsImNvZGUiLCJpc1N0YXRpY0dlbkJhaWxvdXRFcnJvciIsImVycm9yIl0sIm1hcHBpbmdzIjoiOzs7O0FBQUEsTUFBTUEsMEJBQTBCO0FBRXpCLE1BQU1DLDhCQUE4QkM7O1FBQXBDLEtBQUEsSUFBQSxPQUFBLElBQUEsQ0FDV0MsSUFBQUEsR0FBT0g7O0FBQ3pCO0FBRU8sU0FBU0ksd0JBQ2RDLEtBQWM7SUFFZCxJQUFJLE9BQU9BLFVBQVUsWUFBWUEsVUFBVSxRQUFRLENBQUUsQ0FBQSxVQUFVQSxLQUFJLEdBQUk7UUFDckUsT0FBTztJQUNUO0lBRUEsT0FBT0EsTUFBTUYsSUFBSSxLQUFLSDtBQUN4QiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAyMjcsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NyYy9zZXJ2ZXIvZHluYW1pYy1yZW5kZXJpbmctdXRpbHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGlzSGFuZ2luZ1Byb21pc2VSZWplY3Rpb25FcnJvcihcbiAgZXJyOiB1bmtub3duXG4pOiBlcnIgaXMgSGFuZ2luZ1Byb21pc2VSZWplY3Rpb25FcnJvciB7XG4gIGlmICh0eXBlb2YgZXJyICE9PSAnb2JqZWN0JyB8fCBlcnIgPT09IG51bGwgfHwgISgnZGlnZXN0JyBpbiBlcnIpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gZXJyLmRpZ2VzdCA9PT0gSEFOR0lOR19QUk9NSVNFX1JFSkVDVElPTlxufVxuXG5jb25zdCBIQU5HSU5HX1BST01JU0VfUkVKRUNUSU9OID0gJ0hBTkdJTkdfUFJPTUlTRV9SRUpFQ1RJT04nXG5cbmNsYXNzIEhhbmdpbmdQcm9taXNlUmVqZWN0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIHB1YmxpYyByZWFkb25seSBkaWdlc3QgPSBIQU5HSU5HX1BST01JU0VfUkVKRUNUSU9OXG5cbiAgY29uc3RydWN0b3IocHVibGljIHJlYWRvbmx5IGV4cHJlc3Npb246IHN0cmluZykge1xuICAgIHN1cGVyKFxuICAgICAgYER1cmluZyBwcmVyZW5kZXJpbmcsICR7ZXhwcmVzc2lvbn0gcmVqZWN0cyB3aGVuIHRoZSBwcmVyZW5kZXIgaXMgY29tcGxldGUuIFR5cGljYWxseSB0aGVzZSBlcnJvcnMgYXJlIGhhbmRsZWQgYnkgUmVhY3QgYnV0IGlmIHlvdSBtb3ZlICR7ZXhwcmVzc2lvbn0gdG8gYSBkaWZmZXJlbnQgY29udGV4dCBieSB1c2luZyBcXGBzZXRUaW1lb3V0XFxgLCBcXGBhZnRlclxcYCwgb3Igc2ltaWxhciBmdW5jdGlvbnMgeW91IG1heSBvYnNlcnZlIHRoaXMgZXJyb3IgYW5kIHlvdSBzaG91bGQgaGFuZGxlIGl0IGluIHRoYXQgY29udGV4dC5gXG4gICAgKVxuICB9XG59XG5cbnR5cGUgQWJvcnRMaXN0ZW5lcnMgPSBBcnJheTwoZXJyOiB1bmtub3duKSA9PiB2b2lkPlxuY29uc3QgYWJvcnRMaXN0ZW5lcnNCeVNpZ25hbCA9IG5ldyBXZWFrTWFwPEFib3J0U2lnbmFsLCBBYm9ydExpc3RlbmVycz4oKVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gY29uc3RydWN0cyBhIHByb21pc2UgdGhhdCB3aWxsIG5ldmVyIHJlc29sdmUuIFRoaXMgaXMgcHJpbWFyaWx5XG4gKiB1c2VmdWwgZm9yIGR5bmFtaWNJTyB3aGVyZSB3ZSB1c2UgcHJvbWlzZSByZXNvbHV0aW9uIHRpbWluZyB0byBkZXRlcm1pbmUgd2hpY2hcbiAqIHBhcnRzIG9mIGEgcmVuZGVyIGNhbiBiZSBpbmNsdWRlZCBpbiBhIHByZXJlbmRlci5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VIYW5naW5nUHJvbWlzZTxUPihcbiAgc2lnbmFsOiBBYm9ydFNpZ25hbCxcbiAgZXhwcmVzc2lvbjogc3RyaW5nXG4pOiBQcm9taXNlPFQ+IHtcbiAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBIYW5naW5nUHJvbWlzZVJlamVjdGlvbkVycm9yKGV4cHJlc3Npb24pKVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGhhbmdpbmdQcm9taXNlID0gbmV3IFByb21pc2U8VD4oKF8sIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgYm91bmRSZWplY3Rpb24gPSByZWplY3QuYmluZChcbiAgICAgICAgbnVsbCxcbiAgICAgICAgbmV3IEhhbmdpbmdQcm9taXNlUmVqZWN0aW9uRXJyb3IoZXhwcmVzc2lvbilcbiAgICAgIClcbiAgICAgIGxldCBjdXJyZW50TGlzdGVuZXJzID0gYWJvcnRMaXN0ZW5lcnNCeVNpZ25hbC5nZXQoc2lnbmFsKVxuICAgICAgaWYgKGN1cnJlbnRMaXN0ZW5lcnMpIHtcbiAgICAgICAgY3VycmVudExpc3RlbmVycy5wdXNoKGJvdW5kUmVqZWN0aW9uKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gW2JvdW5kUmVqZWN0aW9uXVxuICAgICAgICBhYm9ydExpc3RlbmVyc0J5U2lnbmFsLnNldChzaWduYWwsIGxpc3RlbmVycylcbiAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgJ2Fib3J0JyxcbiAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBsaXN0ZW5lcnNbaV0oKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgeyBvbmNlOiB0cnVlIH1cbiAgICAgICAgKVxuICAgICAgfVxuICAgIH0pXG4gICAgLy8gV2UgYXJlIGZpbmUgaWYgbm8gb25lIGFjdHVhbGx5IGF3YWl0cyB0aGlzIHByb21pc2UuIFdlIHNob3VsZG4ndCBjb25zaWRlciB0aGlzIGFuIHVuaGFuZGxlZCByZWplY3Rpb24gc29cbiAgICAvLyB3ZSBhdHRhY2ggYSBub29wIGNhdGNoIGhhbmRsZXIgaGVyZSB0byBzdXBwcmVzcyB0aGlzIHdhcm5pbmcuIElmIHlvdSBhY3R1YWxseSBhd2FpdCBzb21ld2hlcmUgb3IgY29uc3RydWN0XG4gICAgLy8geW91ciBvd24gcHJvbWlzZSBvdXQgb2YgaXQgeW91J2xsIG5lZWQgdG8gZW5zdXJlIHlvdSBoYW5kbGUgdGhlIGVycm9yIHdoZW4gaXQgcmVqZWN0cy5cbiAgICBoYW5naW5nUHJvbWlzZS5jYXRjaChpZ25vcmVSZWplY3QpXG4gICAgcmV0dXJuIGhhbmdpbmdQcm9taXNlXG4gIH1cbn1cblxuZnVuY3Rpb24gaWdub3JlUmVqZWN0KCkge31cbiJdLCJuYW1lcyI6WyJpc0hhbmdpbmdQcm9taXNlUmVqZWN0aW9uRXJyb3IiLCJlcnIiLCJkaWdlc3QiLCJIQU5HSU5HX1BST01JU0VfUkVKRUNUSU9OIiwiSGFuZ2luZ1Byb21pc2VSZWplY3Rpb25FcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJleHByZXNzaW9uIiwiYWJvcnRMaXN0ZW5lcnNCeVNpZ25hbCIsIldlYWtNYXAiLCJtYWtlSGFuZ2luZ1Byb21pc2UiLCJzaWduYWwiLCJhYm9ydGVkIiwiUHJvbWlzZSIsInJlamVjdCIsImhhbmdpbmdQcm9taXNlIiwiXyIsImJvdW5kUmVqZWN0aW9uIiwiYmluZCIsImN1cnJlbnRMaXN0ZW5lcnMiLCJnZXQiLCJwdXNoIiwibGlzdGVuZXJzIiwic2V0IiwiYWRkRXZlbnRMaXN0ZW5lciIsImkiLCJsZW5ndGgiLCJvbmNlIiwiY2F0Y2giLCJpZ25vcmVSZWplY3QiXSwibWFwcGluZ3MiOiI7Ozs7QUFBTyxTQUFTQSwrQkFDZEMsR0FBWTtJQUVaLElBQUksT0FBT0EsUUFBUSxZQUFZQSxRQUFRLFFBQVEsQ0FBRSxDQUFBLFlBQVlBLEdBQUUsR0FBSTtRQUNqRSxPQUFPO0lBQ1Q7SUFFQSxPQUFPQSxJQUFJQyxNQUFNLEtBQUtDO0FBQ3hCO0FBRUEsTUFBTUEsNEJBQTRCO0FBRWxDLE1BQU1DLHFDQUFxQ0M7SUFHekNDLFlBQTRCQyxVQUFrQixDQUFFO1FBQzlDLEtBQUssQ0FDSCxDQUFDLHFCQUFxQixFQUFFQSxXQUFXLHFHQUFxRyxFQUFFQSxXQUFXLHFKQUFxSixDQUFDLEdBQUEsSUFBQSxDQUZuUkEsVUFBQUEsR0FBQUEsWUFBQUEsSUFBQUEsQ0FGWkwsTUFBQUEsR0FBU0M7SUFNekI7QUFDRjtBQUdBLE1BQU1LLHlCQUF5QixJQUFJQztBQVM1QixTQUFTQyxtQkFDZEMsTUFBbUIsRUFDbkJKLFVBQWtCO0lBRWxCLElBQUlJLE9BQU9DLE9BQU8sRUFBRTtRQUNsQixPQUFPQyxRQUFRQyxNQUFNLENBQUMsSUFBSVYsNkJBQTZCRztJQUN6RCxPQUFPO1FBQ0wsTUFBTVEsaUJBQWlCLElBQUlGLFFBQVcsQ0FBQ0csR0FBR0Y7WUFDeEMsTUFBTUcsaUJBQWlCSCxPQUFPSSxJQUFJLENBQ2hDLE1BQ0EsSUFBSWQsNkJBQTZCRztZQUVuQyxJQUFJWSxtQkFBbUJYLHVCQUF1QlksR0FBRyxDQUFDVDtZQUNsRCxJQUFJUSxrQkFBa0I7Z0JBQ3BCQSxpQkFBaUJFLElBQUksQ0FBQ0o7WUFDeEIsT0FBTztnQkFDTCxNQUFNSyxZQUFZO29CQUFDTDtpQkFBZTtnQkFDbENULHVCQUF1QmUsR0FBRyxDQUFDWixRQUFRVztnQkFDbkNYLE9BQU9hLGdCQUFnQixDQUNyQixTQUNBO29CQUNFLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJSCxVQUFVSSxNQUFNLEVBQUVELElBQUs7d0JBQ3pDSCxTQUFTLENBQUNHLEVBQUU7b0JBQ2Q7Z0JBQ0YsR0FDQTtvQkFBRUUsTUFBTTtnQkFBSztZQUVqQjtRQUNGO1FBQ0EsMkdBQTJHO1FBQzNHLDZHQUE2RztRQUM3Ryx5RkFBeUY7UUFDekZaLGVBQWVhLEtBQUssQ0FBQ0M7UUFDckIsT0FBT2Q7SUFDVDtBQUNGO0FBRUEsU0FBU2MsZ0JBQWdCIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDI3OSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL2xpYi9tZXRhZGF0YS9tZXRhZGF0YS1jb25zdGFudHMudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBNRVRBREFUQV9CT1VOREFSWV9OQU1FID0gJ19fbmV4dF9tZXRhZGF0YV9ib3VuZGFyeV9fJ1xuZXhwb3J0IGNvbnN0IFZJRVdQT1JUX0JPVU5EQVJZX05BTUUgPSAnX19uZXh0X3ZpZXdwb3J0X2JvdW5kYXJ5X18nXG5leHBvcnQgY29uc3QgT1VUTEVUX0JPVU5EQVJZX05BTUUgPSAnX19uZXh0X291dGxldF9ib3VuZGFyeV9fJ1xuIl0sIm5hbWVzIjpbIk1FVEFEQVRBX0JPVU5EQVJZX05BTUUiLCJWSUVXUE9SVF9CT1VOREFSWV9OQU1FIiwiT1VUTEVUX0JPVU5EQVJZX05BTUUiXSwibWFwcGluZ3MiOiI7Ozs7O0FBQU8sTUFBTUEseUJBQXlCLDZCQUE0QjtBQUMzRCxNQUFNQyx5QkFBeUIsNkJBQTRCO0FBQzNELE1BQU1DLHVCQUF1QiwyQkFBMEIiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMjkxLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zcmMvbGliL3NjaGVkdWxlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgdHlwZSBTY2hlZHVsZWRGbjxUID0gdm9pZD4gPSAoKSA9PiBUIHwgUHJvbWlzZUxpa2U8VD5cbmV4cG9ydCB0eXBlIFNjaGVkdWxlckZuPFQgPSB2b2lkPiA9IChjYjogU2NoZWR1bGVkRm48VD4pID0+IHZvaWRcblxuLyoqXG4gKiBTY2hlZHVsZXMgYSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb24gdGhlIG5leHQgdGljayBhZnRlciB0aGUgb3RoZXIgcHJvbWlzZXNcbiAqIGhhdmUgYmVlbiByZXNvbHZlZC5cbiAqXG4gKiBAcGFyYW0gY2IgdGhlIGZ1bmN0aW9uIHRvIHNjaGVkdWxlXG4gKi9cbmV4cG9ydCBjb25zdCBzY2hlZHVsZU9uTmV4dFRpY2sgPSAoY2I6IFNjaGVkdWxlZEZuPHZvaWQ+KSA9PiB7XG4gIC8vIFdlIHVzZSBQcm9taXNlLnJlc29sdmUoKS50aGVuKCkgaGVyZSBzbyB0aGF0IHRoZSBvcGVyYXRpb24gaXMgc2NoZWR1bGVkIGF0XG4gIC8vIHRoZSBlbmQgb2YgdGhlIHByb21pc2Ugam9iIHF1ZXVlLCB3ZSB0aGVuIGFkZCBpdCB0byB0aGUgbmV4dCBwcm9jZXNzIHRpY2tcbiAgLy8gdG8gZW5zdXJlIGl0J3MgZXZhbHVhdGVkIGFmdGVyd2FyZHMuXG4gIC8vXG4gIC8vIFRoaXMgd2FzIGluc3BpcmVkIGJ5IHRoZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgRGF0YUxvYWRlciBpbnRlcmZhY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9ncmFwaHFsL2RhdGFsb2FkZXIvYmxvYi9kMzM2YmQxNTI4MjY2NGUwYmU0YjRhNjU3Y2I3OTZmMDliYWZiYzZiL3NyYy9pbmRleC5qcyNMMjEzLUwyNTVcbiAgLy9cbiAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5FWFRfUlVOVElNRSA9PT0gJ2VkZ2UnKSB7XG4gICAgICBzZXRUaW1lb3V0KGNiLCAwKVxuICAgIH0gZWxzZSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGNiKVxuICAgIH1cbiAgfSlcbn1cblxuLyoqXG4gKiBTY2hlZHVsZXMgYSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgdXNpbmcgYHNldEltbWVkaWF0ZWAgb3IgYHNldFRpbWVvdXRgIGlmXG4gKiBgc2V0SW1tZWRpYXRlYCBpcyBub3QgYXZhaWxhYmxlIChsaWtlIGluIHRoZSBFZGdlIHJ1bnRpbWUpLlxuICpcbiAqIEBwYXJhbSBjYiB0aGUgZnVuY3Rpb24gdG8gc2NoZWR1bGVcbiAqL1xuZXhwb3J0IGNvbnN0IHNjaGVkdWxlSW1tZWRpYXRlID0gKGNiOiBTY2hlZHVsZWRGbjx2b2lkPik6IHZvaWQgPT4ge1xuICBpZiAocHJvY2Vzcy5lbnYuTkVYVF9SVU5USU1FID09PSAnZWRnZScpIHtcbiAgICBzZXRUaW1lb3V0KGNiLCAwKVxuICB9IGVsc2Uge1xuICAgIHNldEltbWVkaWF0ZShjYilcbiAgfVxufVxuXG4vKipcbiAqIHJldHVybnMgYSBwcm9taXNlIHRoYW4gcmVzb2x2ZXMgaW4gYSBmdXR1cmUgdGFzay4gVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgdGhlIHRhc2sgaXQgcmVzb2x2ZXMgaW5cbiAqIHdpbGwgYmUgdGhlIG5leHQgdGFzayBidXQgaWYgeW91IGF3YWl0IGl0IHlvdSBjYW4gYXQgbGVhc3QgYmUgc3VyZSB0aGF0IHRoZSBjdXJyZW50IHRhc2sgaXMgb3ZlciBhbmRcbiAqIG1vc3QgdXNlZnVsbHkgdGhhdCB0aGUgZW50aXJlIG1pY3JvdGFzayBxdWV1ZSBvZiB0aGUgY3VycmVudCB0YXNrIGhhcyBiZWVuIGVtcHRpZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhdExlYXN0T25lVGFzaygpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlKSA9PiBzY2hlZHVsZUltbWVkaWF0ZShyZXNvbHZlKSlcbn1cblxuLyoqXG4gKiBUaGlzIHV0aWxpdHkgZnVuY3Rpb24gaXMgZXh0cmFjdGVkIHRvIG1ha2UgaXQgZWFzaWVyIHRvIGZpbmQgcGxhY2VzIHdoZXJlIHdlIGFyZSBkb2luZ1xuICogc3BlY2lmaWMgdGltaW5nIHRyaWNrcyB0byB0cnkgdG8gc2NoZWR1bGUgd29yayBhZnRlciBSZWFjdCBoYXMgcmVuZGVyZWQuIFRoaXMgaXMgZXNwZWNpYWxseVxuICogaW1wb3J0YW50IGF0IHRoZSBtb21lbnQgYmVjYXVzZSBOZXh0LmpzIHVzZXMgdGhlIGVkZ2UgYnVpbGRzIG9mIFJlYWN0IHdoaWNoIHVzZSBzZXRUaW1lb3V0IHRvXG4gKiBzY2hlZHVsZSB3b3JrIHdoZW4geW91IG1pZ2h0IGV4cGVjdCB0aGF0IHNvbWV0aGluZyBsaWtlIHNldEltbWVkaWF0ZSB3b3VsZCBkbyB0aGUgdHJpY2suXG4gKlxuICogTG9uZyB0ZXJtIHdlIHNob3VsZCBzd2l0Y2ggdG8gdGhlIG5vZGUgdmVyc2lvbnMgb2YgUmVhY3QgcmVuZGVyaW5nIHdoZW4gcG9zc2libGUgYW5kIHRoZW5cbiAqIHVwZGF0ZSB0aGlzIHRvIHVzZSBzZXRJbW1lZGlhdGUgcmF0aGVyIHRoYW4gc2V0VGltZW91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gd2FpdEF0TGVhc3RPbmVSZWFjdFJlbmRlclRhc2soKTogUHJvbWlzZTx2b2lkPiB7XG4gIGlmIChwcm9jZXNzLmVudi5ORVhUX1JVTlRJTUUgPT09ICdlZGdlJykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocikgPT4gc2V0VGltZW91dChyLCAwKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHIpID0+IHNldEltbWVkaWF0ZShyKSlcbiAgfVxufVxuIl0sIm5hbWVzIjpbInNjaGVkdWxlT25OZXh0VGljayIsImNiIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUlVOVElNRSIsInNldFRpbWVvdXQiLCJuZXh0VGljayIsInNjaGVkdWxlSW1tZWRpYXRlIiwic2V0SW1tZWRpYXRlIiwiYXRMZWFzdE9uZVRhc2siLCJ3YWl0QXRMZWFzdE9uZVJlYWN0UmVuZGVyVGFzayIsInIiXSwibWFwcGluZ3MiOiJBQUdBOzs7OztDQUtDLEdBQ0Q7Ozs7OztBQUFPLE1BQU1BLHFCQUFxQixDQUFDQztJQUNqQyw2RUFBNkU7SUFDN0UsNEVBQTRFO0lBQzVFLHVDQUF1QztJQUN2QyxFQUFFO0lBQ0Ysa0xBQWtMO0lBQ2xMLEVBQUU7SUFDRkMsUUFBUUMsT0FBTyxHQUFHQyxJQUFJLENBQUM7UUFDckIsSUFBSUMsUUFBUUMsR0FBRyxDQUFDQyxZQUFZLEtBQUssUUFBUTs7YUFFbEM7WUFDTEYsUUFBUUksUUFBUSxDQUFDUjtRQUNuQjtJQUNGO0FBQ0YsRUFBQztBQVFNLE1BQU1TLG9CQUFvQixDQUFDVDtJQUNoQyxJQUFJSSxRQUFRQyxHQUFHLENBQUNDLFlBQVksS0FBSyxRQUFROztTQUVsQztRQUNMSSxhQUFhVjtJQUNmO0FBQ0YsRUFBQztBQU9NLFNBQVNXO0lBQ2QsT0FBTyxJQUFJVixRQUFjLENBQUNDLFVBQVlPLGtCQUFrQlA7QUFDMUQ7QUFXTyxTQUFTVTtJQUNkLElBQUlSLFFBQVFDLEdBQUcsQ0FBQ0MsWUFBWSxLQUFLLFFBQVE7O1NBRWxDO1FBQ0wsT0FBTyxJQUFJTCxRQUFRLENBQUNZLElBQU1ILGFBQWFHO0lBQ3pDO0FBQ0YiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMzM4LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zcmMvc2VydmVyL2FwcC1yZW5kZXIvZHluYW1pYy1yZW5kZXJpbmcudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUaGUgZnVuY3Rpb25zIHByb3ZpZGVkIGJ5IHRoaXMgbW9kdWxlIGFyZSB1c2VkIHRvIGNvbW11bmljYXRlIGNlcnRhaW4gcHJvcGVydGllc1xuICogYWJvdXQgdGhlIGN1cnJlbnRseSBydW5uaW5nIGNvZGUgc28gdGhhdCBOZXh0LmpzIGNhbiBtYWtlIGRlY2lzaW9ucyBvbiBob3cgdG8gaGFuZGxlXG4gKiB0aGUgY3VycmVudCBleGVjdXRpb24gaW4gZGlmZmVyZW50IHJlbmRlcmluZyBtb2RlcyBzdWNoIGFzIHByZS1yZW5kZXJpbmcsIHJlc3VtaW5nLCBhbmQgU1NSLlxuICpcbiAqIFRvZGF5IE5leHQuanMgdHJlYXRzIGFsbCBjb2RlIGFzIHBvdGVudGlhbGx5IHN0YXRpYy4gQ2VydGFpbiBBUElzIG1heSBvbmx5IG1ha2Ugc2Vuc2Ugd2hlbiBkeW5hbWljYWxseSByZW5kZXJpbmcuXG4gKiBUcmFkaXRpb25hbGx5IHRoaXMgbWVhbnQgZGVvcHRpbmcgdGhlIGVudGlyZSByZW5kZXIgdG8gZHluYW1pYyBob3dldmVyIHdpdGggUFBSIHdlIGNhbiBub3cgZGVvcHQgcGFydHNcbiAqIG9mIGEgUmVhY3QgdHJlZSBhcyBkeW5hbWljIHdoaWxlIHN0aWxsIGtlZXBpbmcgb3RoZXIgcGFydHMgc3RhdGljLiBUaGVyZSBhcmUgcmVhbGx5IHR3byBkaWZmZXJlbnQga2luZHMgb2ZcbiAqIER5bmFtaWMgaW5kaWNhdGlvbnMuXG4gKlxuICogVGhlIGZpcnN0IGlzIHNpbXBseSBhbiBpbnRlbnRpb24gdG8gYmUgZHluYW1pYy4gdW5zdGFibGVfbm9TdG9yZSBpcyBhbiBleGFtcGxlIG9mIHRoaXMgd2hlcmVcbiAqIHRoZSBjdXJyZW50bHkgZXhlY3V0aW5nIGNvZGUgc2ltcGx5IGRlY2xhcmVzIHRoYXQgdGhlIGN1cnJlbnQgc2NvcGUgaXMgZHluYW1pYyBidXQgaWYgeW91IHVzZSBpdFxuICogaW5zaWRlIHVuc3RhYmxlX2NhY2hlIGl0IGNhbiBzdGlsbCBiZSBjYWNoZWQuIFRoaXMgdHlwZSBvZiBpbmRpY2F0aW9uIGNhbiBiZSByZW1vdmVkIGlmIHdlIGV2ZXJcbiAqIG1ha2UgdGhlIGRlZmF1bHQgZHluYW1pYyB0byBiZWdpbiB3aXRoIGJlY2F1c2UgdGhlIG9ubHkgd2F5IHlvdSB3b3VsZCBldmVyIGJlIHN0YXRpYyBpcyBpbnNpZGVcbiAqIGEgY2FjaGUgc2NvcGUgd2hpY2ggdGhpcyBpbmRpY2F0aW9uIGRvZXMgbm90IGFmZmVjdC5cbiAqXG4gKiBUaGUgc2Vjb25kIGlzIGFuIGluZGljYXRpb24gdGhhdCBhIGR5bmFtaWMgZGF0YSBzb3VyY2Ugd2FzIHJlYWQuIFRoaXMgaXMgYSBzdHJvbmdlciBmb3JtIG9mIGR5bmFtaWNcbiAqIGJlY2F1c2UgaXQgbWVhbnMgdGhhdCBpdCBpcyBpbmFwcHJvcHJpYXRlIHRvIGNhY2hlIHRoaXMgYXQgYWxsLiB1c2luZyBhIGR5bmFtaWMgZGF0YSBzb3VyY2UgaW5zaWRlXG4gKiB1bnN0YWJsZV9jYWNoZSBzaG91bGQgZXJyb3IuIElmIHlvdSB3YW50IHRvIHVzZSBzb21lIGR5bmFtaWMgZGF0YSBpbnNpZGUgdW5zdGFibGVfY2FjaGUgeW91IHNob3VsZFxuICogcmVhZCB0aGF0IGRhdGEgb3V0c2lkZSB0aGUgY2FjaGUgYW5kIHBhc3MgaXQgaW4gYXMgYW4gYXJndW1lbnQgdG8gdGhlIGNhY2hlZCBmdW5jdGlvbi5cbiAqL1xuXG5pbXBvcnQgdHlwZSB7IFdvcmtTdG9yZSB9IGZyb20gJy4uL2FwcC1yZW5kZXIvd29yay1hc3luYy1zdG9yYWdlLmV4dGVybmFsJ1xuaW1wb3J0IHR5cGUge1xuICBXb3JrVW5pdFN0b3JlLFxuICBSZXF1ZXN0U3RvcmUsXG4gIFByZXJlbmRlclN0b3JlTGVnYWN5LFxuICBQcmVyZW5kZXJTdG9yZU1vZGVybixcbn0gZnJvbSAnLi4vYXBwLXJlbmRlci93b3JrLXVuaXQtYXN5bmMtc3RvcmFnZS5leHRlcm5hbCdcblxuLy8gT25jZSBwb3N0cG9uZSBpcyBpbiBzdGFibGUgd2Ugc2hvdWxkIHN3aXRjaCB0byBpbXBvcnRpbmcgdGhlIHBvc3Rwb25lIGV4cG9ydCBkaXJlY3RseVxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuXG5pbXBvcnQgeyBEeW5hbWljU2VydmVyRXJyb3IgfSBmcm9tICcuLi8uLi9jbGllbnQvY29tcG9uZW50cy9ob29rcy1zZXJ2ZXItY29udGV4dCdcbmltcG9ydCB7IFN0YXRpY0dlbkJhaWxvdXRFcnJvciB9IGZyb20gJy4uLy4uL2NsaWVudC9jb21wb25lbnRzL3N0YXRpYy1nZW5lcmF0aW9uLWJhaWxvdXQnXG5pbXBvcnQgeyB3b3JrVW5pdEFzeW5jU3RvcmFnZSB9IGZyb20gJy4vd29yay11bml0LWFzeW5jLXN0b3JhZ2UuZXh0ZXJuYWwnXG5pbXBvcnQgeyB3b3JrQXN5bmNTdG9yYWdlIH0gZnJvbSAnLi4vYXBwLXJlbmRlci93b3JrLWFzeW5jLXN0b3JhZ2UuZXh0ZXJuYWwnXG5pbXBvcnQgeyBtYWtlSGFuZ2luZ1Byb21pc2UgfSBmcm9tICcuLi9keW5hbWljLXJlbmRlcmluZy11dGlscydcbmltcG9ydCB7XG4gIE1FVEFEQVRBX0JPVU5EQVJZX05BTUUsXG4gIFZJRVdQT1JUX0JPVU5EQVJZX05BTUUsXG4gIE9VVExFVF9CT1VOREFSWV9OQU1FLFxufSBmcm9tICcuLi8uLi9saWIvbWV0YWRhdGEvbWV0YWRhdGEtY29uc3RhbnRzJ1xuaW1wb3J0IHsgc2NoZWR1bGVPbk5leHRUaWNrIH0gZnJvbSAnLi4vLi4vbGliL3NjaGVkdWxlcidcblxuY29uc3QgaGFzUG9zdHBvbmUgPSB0eXBlb2YgUmVhY3QudW5zdGFibGVfcG9zdHBvbmUgPT09ICdmdW5jdGlvbidcblxuZXhwb3J0IHR5cGUgRHluYW1pY0FjY2VzcyA9IHtcbiAgLyoqXG4gICAqIElmIGRlYnVnZ2luZywgdGhpcyB3aWxsIGNvbnRhaW4gdGhlIHN0YWNrIHRyYWNlIG9mIHdoZXJlIHRoZSBkeW5hbWljIGFjY2Vzc1xuICAgKiBvY2N1cnJlZC4gVGhpcyBpcyB1c2VkIHRvIHByb3ZpZGUgbW9yZSBpbmZvcm1hdGlvbiB0byB0aGUgdXNlciBhYm91dCB3aHlcbiAgICogdGhlaXIgcGFnZSBpcyBiZWluZyByZW5kZXJlZCBkeW5hbWljYWxseS5cbiAgICovXG4gIHN0YWNrPzogc3RyaW5nXG5cbiAgLyoqXG4gICAqIFRoZSBleHByZXNzaW9uIHRoYXQgd2FzIGFjY2Vzc2VkIGR5bmFtaWNhbGx5LlxuICAgKi9cbiAgZXhwcmVzc2lvbjogc3RyaW5nXG59XG5cbi8vIFN0b3JlcyBkeW5hbWljIHJlYXNvbnMgdXNlZCBkdXJpbmcgYW4gUlNDIHJlbmRlci5cbmV4cG9ydCB0eXBlIER5bmFtaWNUcmFja2luZ1N0YXRlID0ge1xuICAvKipcbiAgICogV2hlbiB0cnVlLCBzdGFjayBpbmZvcm1hdGlvbiB3aWxsIGFsc28gYmUgdHJhY2tlZCBkdXJpbmcgZHluYW1pYyBhY2Nlc3MuXG4gICAqL1xuICByZWFkb25seSBpc0RlYnVnRHluYW1pY0FjY2Vzc2VzOiBib29sZWFuIHwgdW5kZWZpbmVkXG5cbiAgLyoqXG4gICAqIFRoZSBkeW5hbWljIGFjY2Vzc2VzIHRoYXQgb2NjdXJyZWQgZHVyaW5nIHRoZSByZW5kZXIuXG4gICAqL1xuICByZWFkb25seSBkeW5hbWljQWNjZXNzZXM6IEFycmF5PER5bmFtaWNBY2Nlc3M+XG5cbiAgc3luY0R5bmFtaWNFcnJvcldpdGhTdGFjazogbnVsbCB8IEVycm9yXG59XG5cbi8vIFN0b3JlcyBkeW5hbWljIHJlYXNvbnMgdXNlZCBkdXJpbmcgYW4gU1NSIHJlbmRlci5cbmV4cG9ydCB0eXBlIER5bmFtaWNWYWxpZGF0aW9uU3RhdGUgPSB7XG4gIGhhc1N1c3BlbnNlQWJvdmVCb2R5OiBib29sZWFuXG4gIGhhc0R5bmFtaWNNZXRhZGF0YTogYm9vbGVhblxuICBoYXNEeW5hbWljVmlld3BvcnQ6IGJvb2xlYW5cbiAgaGFzQWxsb3dlZER5bmFtaWM6IGJvb2xlYW5cbiAgZHluYW1pY0Vycm9yczogQXJyYXk8RXJyb3I+XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVEeW5hbWljVHJhY2tpbmdTdGF0ZShcbiAgaXNEZWJ1Z0R5bmFtaWNBY2Nlc3NlczogYm9vbGVhbiB8IHVuZGVmaW5lZFxuKTogRHluYW1pY1RyYWNraW5nU3RhdGUge1xuICByZXR1cm4ge1xuICAgIGlzRGVidWdEeW5hbWljQWNjZXNzZXMsXG4gICAgZHluYW1pY0FjY2Vzc2VzOiBbXSxcbiAgICBzeW5jRHluYW1pY0Vycm9yV2l0aFN0YWNrOiBudWxsLFxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVEeW5hbWljVmFsaWRhdGlvblN0YXRlKCk6IER5bmFtaWNWYWxpZGF0aW9uU3RhdGUge1xuICByZXR1cm4ge1xuICAgIGhhc1N1c3BlbnNlQWJvdmVCb2R5OiBmYWxzZSxcbiAgICBoYXNEeW5hbWljTWV0YWRhdGE6IGZhbHNlLFxuICAgIGhhc0R5bmFtaWNWaWV3cG9ydDogZmFsc2UsXG4gICAgaGFzQWxsb3dlZER5bmFtaWM6IGZhbHNlLFxuICAgIGR5bmFtaWNFcnJvcnM6IFtdLFxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGaXJzdER5bmFtaWNSZWFzb24oXG4gIHRyYWNraW5nU3RhdGU6IER5bmFtaWNUcmFja2luZ1N0YXRlXG4pOiB1bmRlZmluZWQgfCBzdHJpbmcge1xuICByZXR1cm4gdHJhY2tpbmdTdGF0ZS5keW5hbWljQWNjZXNzZXNbMF0/LmV4cHJlc3Npb25cbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGNvbW11bmljYXRlcyB0aGF0IHRoZSBjdXJyZW50IHNjb3BlIHNob3VsZCBiZSB0cmVhdGVkIGFzIGR5bmFtaWMuXG4gKlxuICogSW4gbW9zdCBjYXNlcyB0aGlzIGZ1bmN0aW9uIGlzIGEgbm8tb3AgYnV0IGlmIGNhbGxlZCBkdXJpbmdcbiAqIGEgUFBSIHByZXJlbmRlciBpdCB3aWxsIHBvc3Rwb25lIHRoZSBjdXJyZW50IHN1Yi10cmVlIGFuZCBjYWxsaW5nXG4gKiBpdCBkdXJpbmcgYSBub3JtYWwgcHJlcmVuZGVyIHdpbGwgY2F1c2UgdGhlIGVudGlyZSBwcmVyZW5kZXIgdG8gYWJvcnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcmtDdXJyZW50U2NvcGVBc0R5bmFtaWMoXG4gIHN0b3JlOiBXb3JrU3RvcmUsXG4gIHdvcmtVbml0U3RvcmU6IHVuZGVmaW5lZCB8IEV4Y2x1ZGU8V29ya1VuaXRTdG9yZSwgUHJlcmVuZGVyU3RvcmVNb2Rlcm4+LFxuICBleHByZXNzaW9uOiBzdHJpbmdcbik6IHZvaWQge1xuICBpZiAod29ya1VuaXRTdG9yZSkge1xuICAgIGlmIChcbiAgICAgIHdvcmtVbml0U3RvcmUudHlwZSA9PT0gJ2NhY2hlJyB8fFxuICAgICAgd29ya1VuaXRTdG9yZS50eXBlID09PSAndW5zdGFibGUtY2FjaGUnXG4gICAgKSB7XG4gICAgICAvLyBpbnNpZGUgY2FjaGUgc2NvcGVzIG1hcmtpbmcgYSBzY29wZSBhcyBkeW5hbWljIGhhcyBubyBlZmZlY3QgYmVjYXVzZSB0aGUgb3V0ZXIgY2FjaGUgc2NvcGVcbiAgICAgIC8vIGNyZWF0ZXMgYSBjYWNoZSBib3VuZGFyeS4gVGhpcyBpcyBzdWJ0bHkgZGlmZmVyZW50IGZyb20gcmVhZGluZyBhIGR5bmFtaWMgZGF0YSBzb3VyY2Ugd2hpY2ggaXNcbiAgICAgIC8vIGZvcmJpZGRlbiBpbnNpZGUgYSBjYWNoZSBzY29wZS5cbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxuXG4gIC8vIElmIHdlJ3JlIGZvcmNpbmcgZHluYW1pYyByZW5kZXJpbmcgb3Igd2UncmUgZm9yY2luZyBzdGF0aWMgcmVuZGVyaW5nLCB3ZVxuICAvLyBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nIGhlcmUgYmVjYXVzZSB0aGUgZW50aXJlIHBhZ2UgaXMgYWxyZWFkeSBkeW5hbWljXG4gIC8vIG9yIGl0J3Mgc3RhdGljIGFuZCBpdCBzaG91bGQgbm90IHRocm93IG9yIHBvc3Rwb25lIGhlcmUuXG4gIGlmIChzdG9yZS5mb3JjZUR5bmFtaWMgfHwgc3RvcmUuZm9yY2VTdGF0aWMpIHJldHVyblxuXG4gIGlmIChzdG9yZS5keW5hbWljU2hvdWxkRXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgU3RhdGljR2VuQmFpbG91dEVycm9yKFxuICAgICAgYFJvdXRlICR7c3RvcmUucm91dGV9IHdpdGggXFxgZHluYW1pYyA9IFwiZXJyb3JcIlxcYCBjb3VsZG4ndCBiZSByZW5kZXJlZCBzdGF0aWNhbGx5IGJlY2F1c2UgaXQgdXNlZCBcXGAke2V4cHJlc3Npb259XFxgLiBTZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL3JlbmRlcmluZy9zdGF0aWMtYW5kLWR5bmFtaWMjZHluYW1pYy1yZW5kZXJpbmdgXG4gICAgKVxuICB9XG5cbiAgaWYgKHdvcmtVbml0U3RvcmUpIHtcbiAgICBpZiAod29ya1VuaXRTdG9yZS50eXBlID09PSAncHJlcmVuZGVyLXBwcicpIHtcbiAgICAgIHBvc3Rwb25lV2l0aFRyYWNraW5nKFxuICAgICAgICBzdG9yZS5yb3V0ZSxcbiAgICAgICAgZXhwcmVzc2lvbixcbiAgICAgICAgd29ya1VuaXRTdG9yZS5keW5hbWljVHJhY2tpbmdcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKHdvcmtVbml0U3RvcmUudHlwZSA9PT0gJ3ByZXJlbmRlci1sZWdhY3knKSB7XG4gICAgICB3b3JrVW5pdFN0b3JlLnJldmFsaWRhdGUgPSAwXG5cbiAgICAgIC8vIFdlIGFyZW4ndCBwcmVyZW5kZXJpbmcgYnV0IHdlIGFyZSBnZW5lcmF0aW5nIGEgc3RhdGljIHBhZ2UuIFdlIG5lZWQgdG8gYmFpbCBvdXQgb2Ygc3RhdGljIGdlbmVyYXRpb25cbiAgICAgIGNvbnN0IGVyciA9IG5ldyBEeW5hbWljU2VydmVyRXJyb3IoXG4gICAgICAgIGBSb3V0ZSAke3N0b3JlLnJvdXRlfSBjb3VsZG4ndCBiZSByZW5kZXJlZCBzdGF0aWNhbGx5IGJlY2F1c2UgaXQgdXNlZCAke2V4cHJlc3Npb259LiBTZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2R5bmFtaWMtc2VydmVyLWVycm9yYFxuICAgICAgKVxuICAgICAgc3RvcmUuZHluYW1pY1VzYWdlRGVzY3JpcHRpb24gPSBleHByZXNzaW9uXG4gICAgICBzdG9yZS5keW5hbWljVXNhZ2VTdGFjayA9IGVyci5zdGFja1xuXG4gICAgICB0aHJvdyBlcnJcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiZcbiAgICAgIHdvcmtVbml0U3RvcmUgJiZcbiAgICAgIHdvcmtVbml0U3RvcmUudHlwZSA9PT0gJ3JlcXVlc3QnXG4gICAgKSB7XG4gICAgICB3b3JrVW5pdFN0b3JlLnVzZWREeW5hbWljID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gY29tbXVuaWNhdGVzIHRoYXQgc29tZSBkeW5hbWljIHBhdGggcGFyYW1ldGVyIHdhcyByZWFkLiBUaGlzXG4gKiBkaWZmZXJzIGZyb20gdGhlIG1vcmUgZ2VuZXJhbCBgdHJhY2tEeW5hbWljRGF0YUFjY2Vzc2VkYCBpbiB0aGF0IGl0IGlzIHdpbGxcbiAqIG5vdCBlcnJvciB3aGVuIGBkeW5hbWljID0gXCJlcnJvclwiYCBpcyBzZXQuXG4gKlxuICogQHBhcmFtIHN0b3JlIFRoZSBzdGF0aWMgZ2VuZXJhdGlvbiBzdG9yZVxuICogQHBhcmFtIGV4cHJlc3Npb24gVGhlIGV4cHJlc3Npb24gdGhhdCB3YXMgYWNjZXNzZWQgZHluYW1pY2FsbHlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYWNrRmFsbGJhY2tQYXJhbUFjY2Vzc2VkKFxuICBzdG9yZTogV29ya1N0b3JlLFxuICBleHByZXNzaW9uOiBzdHJpbmdcbik6IHZvaWQge1xuICBjb25zdCBwcmVyZW5kZXJTdG9yZSA9IHdvcmtVbml0QXN5bmNTdG9yYWdlLmdldFN0b3JlKClcbiAgaWYgKCFwcmVyZW5kZXJTdG9yZSB8fCBwcmVyZW5kZXJTdG9yZS50eXBlICE9PSAncHJlcmVuZGVyLXBwcicpIHJldHVyblxuXG4gIHBvc3Rwb25lV2l0aFRyYWNraW5nKHN0b3JlLnJvdXRlLCBleHByZXNzaW9uLCBwcmVyZW5kZXJTdG9yZS5keW5hbWljVHJhY2tpbmcpXG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBtZWFudCB0byBiZSB1c2VkIHdoZW4gcHJlcmVuZGVyaW5nIHdpdGhvdXQgZHluYW1pY0lPIG9yIFBQUi5cbiAqIFdoZW4gY2FsbGVkIGR1cmluZyBhIGJ1aWxkIGl0IHdpbGwgY2F1c2UgTmV4dC5qcyB0byBjb25zaWRlciB0aGUgcm91dGUgYXMgZHluYW1pYy5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRocm93VG9JbnRlcnJ1cHRTdGF0aWNHZW5lcmF0aW9uKFxuICBleHByZXNzaW9uOiBzdHJpbmcsXG4gIHN0b3JlOiBXb3JrU3RvcmUsXG4gIHByZXJlbmRlclN0b3JlOiBQcmVyZW5kZXJTdG9yZUxlZ2FjeVxuKTogbmV2ZXIge1xuICAvLyBXZSBhcmVuJ3QgcHJlcmVuZGVyaW5nIGJ1dCB3ZSBhcmUgZ2VuZXJhdGluZyBhIHN0YXRpYyBwYWdlLiBXZSBuZWVkIHRvIGJhaWwgb3V0IG9mIHN0YXRpYyBnZW5lcmF0aW9uXG4gIGNvbnN0IGVyciA9IG5ldyBEeW5hbWljU2VydmVyRXJyb3IoXG4gICAgYFJvdXRlICR7c3RvcmUucm91dGV9IGNvdWxkbid0IGJlIHJlbmRlcmVkIHN0YXRpY2FsbHkgYmVjYXVzZSBpdCB1c2VkIFxcYCR7ZXhwcmVzc2lvbn1cXGAuIFNlZSBtb3JlIGluZm8gaGVyZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvZHluYW1pYy1zZXJ2ZXItZXJyb3JgXG4gIClcblxuICBwcmVyZW5kZXJTdG9yZS5yZXZhbGlkYXRlID0gMFxuXG4gIHN0b3JlLmR5bmFtaWNVc2FnZURlc2NyaXB0aW9uID0gZXhwcmVzc2lvblxuICBzdG9yZS5keW5hbWljVXNhZ2VTdGFjayA9IGVyci5zdGFja1xuXG4gIHRocm93IGVyclxufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIHVzZWQgdG8gdHJhY2sgd2hldGhlciBzb21ldGhpbmcgZHluYW1pYyBoYXBwZW5lZCBldmVuIHdoZW5cbiAqIHdlIGFyZSBpbiBhIGR5bmFtaWMgcmVuZGVyLiBUaGlzIGlzIHVzZWZ1bCBmb3IgRGV2IHdoZXJlIGFsbCByZW5kZXJzIGFyZSBkeW5hbWljIGJ1dFxuICogd2Ugc3RpbGwgdHJhY2sgd2hldGhlciBkeW5hbWljIEFQSXMgd2VyZSBhY2Nlc3NlZCBmb3IgaGVscGZ1bCBtZXNzYWdpbmdcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYWNrRHluYW1pY0RhdGFJbkR5bmFtaWNSZW5kZXIoXG4gIF9zdG9yZTogV29ya1N0b3JlLFxuICB3b3JrVW5pdFN0b3JlOiB2b2lkIHwgV29ya1VuaXRTdG9yZVxuKSB7XG4gIGlmICh3b3JrVW5pdFN0b3JlKSB7XG4gICAgaWYgKFxuICAgICAgd29ya1VuaXRTdG9yZS50eXBlID09PSAnY2FjaGUnIHx8XG4gICAgICB3b3JrVW5pdFN0b3JlLnR5cGUgPT09ICd1bnN0YWJsZS1jYWNoZSdcbiAgICApIHtcbiAgICAgIC8vIGluc2lkZSBjYWNoZSBzY29wZXMgbWFya2luZyBhIHNjb3BlIGFzIGR5bmFtaWMgaGFzIG5vIGVmZmVjdCBiZWNhdXNlIHRoZSBvdXRlciBjYWNoZSBzY29wZVxuICAgICAgLy8gY3JlYXRlcyBhIGNhY2hlIGJvdW5kYXJ5LiBUaGlzIGlzIHN1YnRseSBkaWZmZXJlbnQgZnJvbSByZWFkaW5nIGEgZHluYW1pYyBkYXRhIHNvdXJjZSB3aGljaCBpc1xuICAgICAgLy8gZm9yYmlkZGVuIGluc2lkZSBhIGNhY2hlIHNjb3BlLlxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIFRPRE86IGl0IG1ha2VzIG5vIHNlbnNlIHRvIGhhdmUgdGhlc2Ugd29yayB1bml0IHN0b3JlIHR5cGVzIGR1cmluZyBhIGRldiByZW5kZXIuXG4gICAgaWYgKFxuICAgICAgd29ya1VuaXRTdG9yZS50eXBlID09PSAncHJlcmVuZGVyJyB8fFxuICAgICAgd29ya1VuaXRTdG9yZS50eXBlID09PSAncHJlcmVuZGVyLWNsaWVudCcgfHxcbiAgICAgIHdvcmtVbml0U3RvcmUudHlwZSA9PT0gJ3ByZXJlbmRlci1sZWdhY3knXG4gICAgKSB7XG4gICAgICB3b3JrVW5pdFN0b3JlLnJldmFsaWRhdGUgPSAwXG4gICAgfVxuICAgIGlmIChcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmXG4gICAgICB3b3JrVW5pdFN0b3JlLnR5cGUgPT09ICdyZXF1ZXN0J1xuICAgICkge1xuICAgICAgd29ya1VuaXRTdG9yZS51c2VkRHluYW1pYyA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWJvcnRPblN5bmNocm9ub3VzRHluYW1pY0RhdGFBY2Nlc3MoXG4gIHJvdXRlOiBzdHJpbmcsXG4gIGV4cHJlc3Npb246IHN0cmluZyxcbiAgcHJlcmVuZGVyU3RvcmU6IFByZXJlbmRlclN0b3JlTW9kZXJuXG4pOiB2b2lkIHtcbiAgY29uc3QgcmVhc29uID0gYFJvdXRlICR7cm91dGV9IG5lZWRzIHRvIGJhaWwgb3V0IG9mIHByZXJlbmRlcmluZyBhdCB0aGlzIHBvaW50IGJlY2F1c2UgaXQgdXNlZCAke2V4cHJlc3Npb259LmBcblxuICBjb25zdCBlcnJvciA9IGNyZWF0ZVByZXJlbmRlckludGVycnVwdGVkRXJyb3IocmVhc29uKVxuXG4gIHByZXJlbmRlclN0b3JlLmNvbnRyb2xsZXIuYWJvcnQoZXJyb3IpXG5cbiAgY29uc3QgZHluYW1pY1RyYWNraW5nID0gcHJlcmVuZGVyU3RvcmUuZHluYW1pY1RyYWNraW5nXG4gIGlmIChkeW5hbWljVHJhY2tpbmcpIHtcbiAgICBkeW5hbWljVHJhY2tpbmcuZHluYW1pY0FjY2Vzc2VzLnB1c2goe1xuICAgICAgLy8gV2hlbiB3ZSBhcmVuJ3QgZGVidWdnaW5nLCB3ZSBkb24ndCBuZWVkIHRvIGNyZWF0ZSBhbm90aGVyIGVycm9yIGZvciB0aGVcbiAgICAgIC8vIHN0YWNrIHRyYWNlLlxuICAgICAgc3RhY2s6IGR5bmFtaWNUcmFja2luZy5pc0RlYnVnRHluYW1pY0FjY2Vzc2VzXG4gICAgICAgID8gbmV3IEVycm9yKCkuc3RhY2tcbiAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICBleHByZXNzaW9uLFxuICAgIH0pXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFib3J0T25TeW5jaHJvbm91c1BsYXRmb3JtSU9BY2Nlc3MoXG4gIHJvdXRlOiBzdHJpbmcsXG4gIGV4cHJlc3Npb246IHN0cmluZyxcbiAgZXJyb3JXaXRoU3RhY2s6IEVycm9yLFxuICBwcmVyZW5kZXJTdG9yZTogUHJlcmVuZGVyU3RvcmVNb2Rlcm5cbik6IHZvaWQge1xuICBjb25zdCBkeW5hbWljVHJhY2tpbmcgPSBwcmVyZW5kZXJTdG9yZS5keW5hbWljVHJhY2tpbmdcbiAgYWJvcnRPblN5bmNocm9ub3VzRHluYW1pY0RhdGFBY2Nlc3Mocm91dGUsIGV4cHJlc3Npb24sIHByZXJlbmRlclN0b3JlKVxuICAvLyBJdCBpcyBpbXBvcnRhbnQgdGhhdCB3ZSBzZXQgdGhpcyB0cmFja2luZyB2YWx1ZSBhZnRlciBhYm9ydGluZy4gQWJvcnRzIGFyZSBleGVjdXRlZFxuICAvLyBzeW5jaHJvbm91c2x5IGV4Y2VwdCBmb3IgdGhlIGNhc2Ugd2hlcmUgeW91IGFib3J0IGR1cmluZyByZW5kZXIgaXRzZWxmLiBCeSBzZXR0aW5nIHRoaXNcbiAgLy8gdmFsdWUgbGF0ZSB3ZSBjYW4gdXNlIGl0IHRvIGRldGVybWluZSBpZiBhbnkgb2YgdGhlIGFib3J0ZWQgdGFza3MgYXJlIHRoZSB0YXNrIHRoYXRcbiAgLy8gY2FsbGVkIHRoZSBzeW5jIElPIGV4cHJlc3Npb24gaW4gdGhlIGZpcnN0IHBsYWNlLlxuICBpZiAoZHluYW1pY1RyYWNraW5nKSB7XG4gICAgaWYgKGR5bmFtaWNUcmFja2luZy5zeW5jRHluYW1pY0Vycm9yV2l0aFN0YWNrID09PSBudWxsKSB7XG4gICAgICBkeW5hbWljVHJhY2tpbmcuc3luY0R5bmFtaWNFcnJvcldpdGhTdGFjayA9IGVycm9yV2l0aFN0YWNrXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFja1N5bmNocm9ub3VzUGxhdGZvcm1JT0FjY2Vzc0luRGV2KFxuICByZXF1ZXN0U3RvcmU6IFJlcXVlc3RTdG9yZVxuKTogdm9pZCB7XG4gIC8vIFdlIGRvbid0IGFjdHVhbGx5IGhhdmUgYSBjb250cm9sbGVyIHRvIGFib3J0IGJ1dCB3ZSBkbyB0aGUgc2VtYW50aWMgZXF1aXZhbGVudCBieVxuICAvLyBhZHZhbmNpbmcgdGhlIHJlcXVlc3Qgc3RvcmUgb3V0IG9mIHByZXJlbmRlciBtb2RlXG4gIHJlcXVlc3RTdG9yZS5wcmVyZW5kZXJQaGFzZSA9IGZhbHNlXG59XG5cbi8qKlxuICogdXNlIHRoaXMgZnVuY3Rpb24gd2hlbiBwcmVyZW5kZXJpbmcgd2l0aCBkeW5hbWljSU8uIElmIHdlIGFyZSBkb2luZyBhXG4gKiBwcm9zcGVjdGl2ZSBwcmVyZW5kZXIgd2UgZG9uJ3QgYWN0dWFsbHkgYWJvcnQgYmVjYXVzZSB3ZSB3YW50IHRvIGRpc2NvdmVyXG4gKiBhbGwgY2FjaGVzIGZvciB0aGUgc2hlbGwuIElmIHRoaXMgaXMgdGhlIGFjdHVhbCBwcmVyZW5kZXIgd2UgZG8gYWJvcnQuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBhY2NlcHRzIGEgcHJlcmVuZGVyU3RvcmUgYnV0IHRoZSBjYWxsZXIgc2hvdWxkIGVuc3VyZSB3ZSdyZVxuICogYWN0dWFsbHkgcnVubmluZyBpbiBkeW5hbWljSU8gbW9kZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFib3J0QW5kVGhyb3dPblN5bmNocm9ub3VzUmVxdWVzdERhdGFBY2Nlc3MoXG4gIHJvdXRlOiBzdHJpbmcsXG4gIGV4cHJlc3Npb246IHN0cmluZyxcbiAgZXJyb3JXaXRoU3RhY2s6IEVycm9yLFxuICBwcmVyZW5kZXJTdG9yZTogUHJlcmVuZGVyU3RvcmVNb2Rlcm5cbik6IG5ldmVyIHtcbiAgY29uc3QgcHJlcmVuZGVyU2lnbmFsID0gcHJlcmVuZGVyU3RvcmUuY29udHJvbGxlci5zaWduYWxcbiAgaWYgKHByZXJlbmRlclNpZ25hbC5hYm9ydGVkID09PSBmYWxzZSkge1xuICAgIC8vIFRPRE8gaXQgd291bGQgYmUgYmV0dGVyIHRvIG1vdmUgdGhpcyBhYm9ydGVkIGNoZWNrIGludG8gdGhlIGNhbGxzaXRlIHNvIHdlIGNhbiBhdm9pZCBtYWtpbmdcbiAgICAvLyB0aGUgZXJyb3Igb2JqZWN0IHdoZW4gaXQgaXNuJ3QgcmVsZXZhbnQgdG8gdGhlIGFib3J0aW5nIG9mIHRoZSBwcmVyZW5kZXIgaG93ZXZlclxuICAgIC8vIHNpbmNlIHdlIG5lZWQgdGhlIHRocm93IHNlbWFudGljcyByZWdhcmRsZXNzIG9mIHdoZXRoZXIgd2UgYWJvcnQgaXQgaXMgZWFzaWVyIHRvIGxhbmRcbiAgICAvLyB0aGlzIHdheS4gU2VlIGhvdyB0aGlzIHdhcyBoYW5kbGVkIHdpdGggYGFib3J0T25TeW5jaHJvbm91c1BsYXRmb3JtSU9BY2Nlc3NgIGZvciBhIGNsb3NlclxuICAgIC8vIHRvIGlkZWFsIGltcGxlbWVudGF0aW9uXG4gICAgYWJvcnRPblN5bmNocm9ub3VzRHluYW1pY0RhdGFBY2Nlc3Mocm91dGUsIGV4cHJlc3Npb24sIHByZXJlbmRlclN0b3JlKVxuICAgIC8vIEl0IGlzIGltcG9ydGFudCB0aGF0IHdlIHNldCB0aGlzIHRyYWNraW5nIHZhbHVlIGFmdGVyIGFib3J0aW5nLiBBYm9ydHMgYXJlIGV4ZWN1dGVkXG4gICAgLy8gc3luY2hyb25vdXNseSBleGNlcHQgZm9yIHRoZSBjYXNlIHdoZXJlIHlvdSBhYm9ydCBkdXJpbmcgcmVuZGVyIGl0c2VsZi4gQnkgc2V0dGluZyB0aGlzXG4gICAgLy8gdmFsdWUgbGF0ZSB3ZSBjYW4gdXNlIGl0IHRvIGRldGVybWluZSBpZiBhbnkgb2YgdGhlIGFib3J0ZWQgdGFza3MgYXJlIHRoZSB0YXNrIHRoYXRcbiAgICAvLyBjYWxsZWQgdGhlIHN5bmMgSU8gZXhwcmVzc2lvbiBpbiB0aGUgZmlyc3QgcGxhY2UuXG4gICAgY29uc3QgZHluYW1pY1RyYWNraW5nID0gcHJlcmVuZGVyU3RvcmUuZHluYW1pY1RyYWNraW5nXG4gICAgaWYgKGR5bmFtaWNUcmFja2luZykge1xuICAgICAgaWYgKGR5bmFtaWNUcmFja2luZy5zeW5jRHluYW1pY0Vycm9yV2l0aFN0YWNrID09PSBudWxsKSB7XG4gICAgICAgIGR5bmFtaWNUcmFja2luZy5zeW5jRHluYW1pY0Vycm9yV2l0aFN0YWNrID0gZXJyb3JXaXRoU3RhY2tcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdGhyb3cgY3JlYXRlUHJlcmVuZGVySW50ZXJydXB0ZWRFcnJvcihcbiAgICBgUm91dGUgJHtyb3V0ZX0gbmVlZHMgdG8gYmFpbCBvdXQgb2YgcHJlcmVuZGVyaW5nIGF0IHRoaXMgcG9pbnQgYmVjYXVzZSBpdCB1c2VkICR7ZXhwcmVzc2lvbn0uYFxuICApXG59XG5cbi8vIEZvciBub3cgdGhlc2UgaW1wbGVtZW50YXRpb25zIGFyZSB0aGUgc2FtZSBzbyB3ZSBqdXN0IHJlZXhwb3J0XG5leHBvcnQgY29uc3QgdHJhY2tTeW5jaHJvbm91c1JlcXVlc3REYXRhQWNjZXNzSW5EZXYgPVxuICB0cmFja1N5bmNocm9ub3VzUGxhdGZvcm1JT0FjY2Vzc0luRGV2XG5cbi8qKlxuICogVGhpcyBjb21wb25lbnQgd2lsbCBjYWxsIGBSZWFjdC5wb3N0cG9uZWAgdGhhdCB0aHJvd3MgdGhlIHBvc3Rwb25lZCBlcnJvci5cbiAqL1xudHlwZSBQb3N0cG9uZVByb3BzID0ge1xuICByZWFzb246IHN0cmluZ1xuICByb3V0ZTogc3RyaW5nXG59XG5leHBvcnQgZnVuY3Rpb24gUG9zdHBvbmUoeyByZWFzb24sIHJvdXRlIH06IFBvc3Rwb25lUHJvcHMpOiBuZXZlciB7XG4gIGNvbnN0IHByZXJlbmRlclN0b3JlID0gd29ya1VuaXRBc3luY1N0b3JhZ2UuZ2V0U3RvcmUoKVxuICBjb25zdCBkeW5hbWljVHJhY2tpbmcgPVxuICAgIHByZXJlbmRlclN0b3JlICYmIHByZXJlbmRlclN0b3JlLnR5cGUgPT09ICdwcmVyZW5kZXItcHByJ1xuICAgICAgPyBwcmVyZW5kZXJTdG9yZS5keW5hbWljVHJhY2tpbmdcbiAgICAgIDogbnVsbFxuICBwb3N0cG9uZVdpdGhUcmFja2luZyhyb3V0ZSwgcmVhc29uLCBkeW5hbWljVHJhY2tpbmcpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwb3N0cG9uZVdpdGhUcmFja2luZyhcbiAgcm91dGU6IHN0cmluZyxcbiAgZXhwcmVzc2lvbjogc3RyaW5nLFxuICBkeW5hbWljVHJhY2tpbmc6IG51bGwgfCBEeW5hbWljVHJhY2tpbmdTdGF0ZVxuKTogbmV2ZXIge1xuICBhc3NlcnRQb3N0cG9uZSgpXG4gIGlmIChkeW5hbWljVHJhY2tpbmcpIHtcbiAgICBkeW5hbWljVHJhY2tpbmcuZHluYW1pY0FjY2Vzc2VzLnB1c2goe1xuICAgICAgLy8gV2hlbiB3ZSBhcmVuJ3QgZGVidWdnaW5nLCB3ZSBkb24ndCBuZWVkIHRvIGNyZWF0ZSBhbm90aGVyIGVycm9yIGZvciB0aGVcbiAgICAgIC8vIHN0YWNrIHRyYWNlLlxuICAgICAgc3RhY2s6IGR5bmFtaWNUcmFja2luZy5pc0RlYnVnRHluYW1pY0FjY2Vzc2VzXG4gICAgICAgID8gbmV3IEVycm9yKCkuc3RhY2tcbiAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICBleHByZXNzaW9uLFxuICAgIH0pXG4gIH1cblxuICBSZWFjdC51bnN0YWJsZV9wb3N0cG9uZShjcmVhdGVQb3N0cG9uZVJlYXNvbihyb3V0ZSwgZXhwcmVzc2lvbikpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBvc3Rwb25lUmVhc29uKHJvdXRlOiBzdHJpbmcsIGV4cHJlc3Npb246IHN0cmluZykge1xuICByZXR1cm4gKFxuICAgIGBSb3V0ZSAke3JvdXRlfSBuZWVkcyB0byBiYWlsIG91dCBvZiBwcmVyZW5kZXJpbmcgYXQgdGhpcyBwb2ludCBiZWNhdXNlIGl0IHVzZWQgJHtleHByZXNzaW9ufS4gYCArXG4gICAgYFJlYWN0IHRocm93cyB0aGlzIHNwZWNpYWwgb2JqZWN0IHRvIGluZGljYXRlIHdoZXJlLiBJdCBzaG91bGQgbm90IGJlIGNhdWdodCBieSBgICtcbiAgICBgeW91ciBvd24gdHJ5L2NhdGNoLiBMZWFybiBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9wcHItY2F1Z2h0LWVycm9yYFxuICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0R5bmFtaWNQb3N0cG9uZShlcnI6IHVua25vd24pIHtcbiAgaWYgKFxuICAgIHR5cGVvZiBlcnIgPT09ICdvYmplY3QnICYmXG4gICAgZXJyICE9PSBudWxsICYmXG4gICAgdHlwZW9mIChlcnIgYXMgYW55KS5tZXNzYWdlID09PSAnc3RyaW5nJ1xuICApIHtcbiAgICByZXR1cm4gaXNEeW5hbWljUG9zdHBvbmVSZWFzb24oKGVyciBhcyBhbnkpLm1lc3NhZ2UpXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGlzRHluYW1pY1Bvc3Rwb25lUmVhc29uKHJlYXNvbjogc3RyaW5nKSB7XG4gIHJldHVybiAoXG4gICAgcmVhc29uLmluY2x1ZGVzKFxuICAgICAgJ25lZWRzIHRvIGJhaWwgb3V0IG9mIHByZXJlbmRlcmluZyBhdCB0aGlzIHBvaW50IGJlY2F1c2UgaXQgdXNlZCdcbiAgICApICYmXG4gICAgcmVhc29uLmluY2x1ZGVzKFxuICAgICAgJ0xlYXJuIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL3Bwci1jYXVnaHQtZXJyb3InXG4gICAgKVxuICApXG59XG5cbmlmIChpc0R5bmFtaWNQb3N0cG9uZVJlYXNvbihjcmVhdGVQb3N0cG9uZVJlYXNvbignJSUlJywgJ15eXicpKSA9PT0gZmFsc2UpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICdJbnZhcmlhbnQ6IGlzRHluYW1pY1Bvc3Rwb25lIG1pc2lkZW50aWZpZWQgYSBwb3N0cG9uZSByZWFzb24uIFRoaXMgaXMgYSBidWcgaW4gTmV4dC5qcydcbiAgKVxufVxuXG5jb25zdCBORVhUX1BSRVJFTkRFUl9JTlRFUlJVUFRFRCA9ICdORVhUX1BSRVJFTkRFUl9JTlRFUlJVUFRFRCdcblxuZnVuY3Rpb24gY3JlYXRlUHJlcmVuZGVySW50ZXJydXB0ZWRFcnJvcihtZXNzYWdlOiBzdHJpbmcpOiBFcnJvciB7XG4gIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpXG4gIDsoZXJyb3IgYXMgYW55KS5kaWdlc3QgPSBORVhUX1BSRVJFTkRFUl9JTlRFUlJVUFRFRFxuICByZXR1cm4gZXJyb3Jcbn1cblxudHlwZSBEaWdlc3RFcnJvciA9IEVycm9yICYge1xuICBkaWdlc3Q6IHN0cmluZ1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNQcmVyZW5kZXJJbnRlcnJ1cHRlZEVycm9yKFxuICBlcnJvcjogdW5rbm93blxuKTogZXJyb3IgaXMgRGlnZXN0RXJyb3Ige1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcgJiZcbiAgICBlcnJvciAhPT0gbnVsbCAmJlxuICAgIChlcnJvciBhcyBhbnkpLmRpZ2VzdCA9PT0gTkVYVF9QUkVSRU5ERVJfSU5URVJSVVBURUQgJiZcbiAgICAnbmFtZScgaW4gZXJyb3IgJiZcbiAgICAnbWVzc2FnZScgaW4gZXJyb3IgJiZcbiAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yXG4gIClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFjY2Vzc2VkRHluYW1pY0RhdGEoXG4gIGR5bmFtaWNBY2Nlc3NlczogQXJyYXk8RHluYW1pY0FjY2Vzcz5cbik6IGJvb2xlYW4ge1xuICByZXR1cm4gZHluYW1pY0FjY2Vzc2VzLmxlbmd0aCA+IDBcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnN1bWVEeW5hbWljQWNjZXNzKFxuICBzZXJ2ZXJEeW5hbWljOiBEeW5hbWljVHJhY2tpbmdTdGF0ZSxcbiAgY2xpZW50RHluYW1pYzogRHluYW1pY1RyYWNraW5nU3RhdGVcbik6IER5bmFtaWNUcmFja2luZ1N0YXRlWydkeW5hbWljQWNjZXNzZXMnXSB7XG4gIC8vIFdlIG11dGF0ZSBiZWNhdXNlIHdlIG9ubHkgY2FsbCB0aGlzIG9uY2Ugd2UgYXJlIG5vIGxvbmdlciB3cml0aW5nXG4gIC8vIHRvIHRoZSBkeW5hbWljVHJhY2tpbmdTdGF0ZSBhbmQgaXQncyBtb3JlIGVmZmljaWVudCB0aGFuIGNyZWF0aW5nIGEgbmV3XG4gIC8vIGFycmF5LlxuICBzZXJ2ZXJEeW5hbWljLmR5bmFtaWNBY2Nlc3Nlcy5wdXNoKC4uLmNsaWVudER5bmFtaWMuZHluYW1pY0FjY2Vzc2VzKVxuICByZXR1cm4gc2VydmVyRHluYW1pYy5keW5hbWljQWNjZXNzZXNcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdER5bmFtaWNBUElBY2Nlc3NlcyhcbiAgZHluYW1pY0FjY2Vzc2VzOiBBcnJheTxEeW5hbWljQWNjZXNzPlxuKTogc3RyaW5nW10ge1xuICByZXR1cm4gZHluYW1pY0FjY2Vzc2VzXG4gICAgLmZpbHRlcihcbiAgICAgIChhY2Nlc3MpOiBhY2Nlc3MgaXMgUmVxdWlyZWQ8RHluYW1pY0FjY2Vzcz4gPT5cbiAgICAgICAgdHlwZW9mIGFjY2Vzcy5zdGFjayA9PT0gJ3N0cmluZycgJiYgYWNjZXNzLnN0YWNrLmxlbmd0aCA+IDBcbiAgICApXG4gICAgLm1hcCgoeyBleHByZXNzaW9uLCBzdGFjayB9KSA9PiB7XG4gICAgICBzdGFjayA9IHN0YWNrXG4gICAgICAgIC5zcGxpdCgnXFxuJylcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBcIkVycm9yOiBcIiBwcmVmaXggZnJvbSB0aGUgZmlyc3QgbGluZSBvZiB0aGUgc3RhY2sgdHJhY2UgYXNcbiAgICAgICAgLy8gd2VsbCBhcyB0aGUgZmlyc3QgNCBsaW5lcyBvZiB0aGUgc3RhY2sgdHJhY2Ugd2hpY2ggaXMgdGhlIGRpc3RhbmNlXG4gICAgICAgIC8vIGZyb20gdGhlIHVzZXIgY29kZSBhbmQgdGhlIGBuZXcgRXJyb3IoKS5zdGFja2AgY2FsbC5cbiAgICAgICAgLnNsaWNlKDQpXG4gICAgICAgIC5maWx0ZXIoKGxpbmUpID0+IHtcbiAgICAgICAgICAvLyBFeGNsdWRlIE5leHQuanMgaW50ZXJuYWxzIGZyb20gdGhlIHN0YWNrIHRyYWNlLlxuICAgICAgICAgIGlmIChsaW5lLmluY2x1ZGVzKCdub2RlX21vZHVsZXMvbmV4dC8nKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRXhjbHVkZSBhbm9ueW1vdXMgZnVuY3Rpb25zIGZyb20gdGhlIHN0YWNrIHRyYWNlLlxuICAgICAgICAgIGlmIChsaW5lLmluY2x1ZGVzKCcgKDxhbm9ueW1vdXM+KScpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBFeGNsdWRlIE5vZGUuanMgaW50ZXJuYWxzIGZyb20gdGhlIHN0YWNrIHRyYWNlLlxuICAgICAgICAgIGlmIChsaW5lLmluY2x1ZGVzKCcgKG5vZGU6JykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH0pXG4gICAgICAgIC5qb2luKCdcXG4nKVxuICAgICAgcmV0dXJuIGBEeW5hbWljIEFQSSBVc2FnZSBEZWJ1ZyAtICR7ZXhwcmVzc2lvbn06XFxuJHtzdGFja31gXG4gICAgfSlcbn1cblxuZnVuY3Rpb24gYXNzZXJ0UG9zdHBvbmUoKSB7XG4gIGlmICghaGFzUG9zdHBvbmUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgSW52YXJpYW50OiBSZWFjdC51bnN0YWJsZV9wb3N0cG9uZSBpcyBub3QgZGVmaW5lZC4gVGhpcyBzdWdnZXN0cyB0aGUgd3JvbmcgdmVyc2lvbiBvZiBSZWFjdCB3YXMgbG9hZGVkLiBUaGlzIGlzIGEgYnVnIGluIE5leHQuanNgXG4gICAgKVxuICB9XG59XG5cbi8qKlxuICogVGhpcyBpcyBhIGJpdCBvZiBhIGhhY2sgdG8gYWxsb3cgdXMgdG8gYWJvcnQgYSByZW5kZXIgdXNpbmcgYSBQb3N0cG9uZSBpbnN0YW5jZSBpbnN0ZWFkIG9mIGFuIEVycm9yIHdoaWNoIGNoYW5nZXMgUmVhY3Qnc1xuICogYWJvcnQgc2VtYW50aWNzIHNsaWdodGx5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUG9zdHBvbmVkQWJvcnRTaWduYWwocmVhc29uOiBzdHJpbmcpOiBBYm9ydFNpZ25hbCB7XG4gIGFzc2VydFBvc3Rwb25lKClcbiAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuICAvLyBXZSBnZXQgb3VyIGhhbmRzIG9uIGEgcG9zdHBvbmUgaW5zdGFuY2UgYnkgY2FsbGluZyBwb3N0cG9uZSBhbmQgY2F0Y2hpbmcgdGhlIHRocm93XG4gIHRyeSB7XG4gICAgUmVhY3QudW5zdGFibGVfcG9zdHBvbmUocmVhc29uKVxuICB9IGNhdGNoICh4OiB1bmtub3duKSB7XG4gICAgY29udHJvbGxlci5hYm9ydCh4KVxuICB9XG4gIHJldHVybiBjb250cm9sbGVyLnNpZ25hbFxufVxuXG4vKipcbiAqIEluIGEgcHJlcmVuZGVyLCB3ZSBtYXkgZW5kIHVwIHdpdGggaGFuZ2luZyBQcm9taXNlcyBhcyBpbnB1dHMgZHVlIHRoZW1cbiAqIHN0YWxsaW5nIG9uIGNvbm5lY3Rpb24oKSBvciBiZWNhdXNlIHRoZXkncmUgbG9hZGluZyBkeW5hbWljIGRhdGEuIEluIHRoYXRcbiAqIGNhc2Ugd2UgbmVlZCB0byBhYm9ydCB0aGUgZW5jb2Rpbmcgb2YgYXJndW1lbnRzIHNpbmNlIHRoZXknbGwgbmV2ZXIgY29tcGxldGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVIYW5naW5nSW5wdXRBYm9ydFNpZ25hbChcbiAgd29ya1VuaXRTdG9yZTogUHJlcmVuZGVyU3RvcmVNb2Rlcm5cbik6IEFib3J0U2lnbmFsIHtcbiAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuXG4gIGlmICh3b3JrVW5pdFN0b3JlLmNhY2hlU2lnbmFsKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBhIGNhY2hlU2lnbmFsIGl0IG1lYW5zIHdlJ3JlIGluIGEgcHJvc3BlY3RpdmUgcmVuZGVyLiBJZiB0aGUgaW5wdXRcbiAgICAvLyB3ZSdyZSB3YWl0aW5nIG9uIGlzIGNvbWluZyBmcm9tIGFub3RoZXIgY2FjaGUsIHdlIGRvIHdhbnQgdG8gd2FpdCBmb3IgaXQgc28gdGhhdFxuICAgIC8vIHdlIGNhbiByZXNvbHZlIHRoaXMgY2FjaGUgZW50cnkgdG9vLlxuICAgIHdvcmtVbml0U3RvcmUuY2FjaGVTaWduYWwuaW5wdXRSZWFkeSgpLnRoZW4oKCkgPT4ge1xuICAgICAgY29udHJvbGxlci5hYm9ydCgpXG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICAvLyBPdGhlcndpc2Ugd2UncmUgaW4gdGhlIGZpbmFsIHJlbmRlciBhbmQgd2Ugc2hvdWxkIGFscmVhZHkgaGF2ZSBhbGwgb3VyIGNhY2hlc1xuICAgIC8vIGZpbGxlZC4gV2UgbWlnaHQgc3RpbGwgYmUgd2FpdGluZyBvbiBzb21lIG1pY3JvdGFza3Mgc28gd2Ugd2FpdCBvbmUgdGljayBiZWZvcmVcbiAgICAvLyBnaXZpbmcgdXAuIFdoZW4gd2UgZ2l2ZSB1cCwgd2Ugc3RpbGwgd2FudCB0byByZW5kZXIgdGhlIGNvbnRlbnQgb2YgdGhpcyBjYWNoZVxuICAgIC8vIGFzIGRlZXBseSBhcyB3ZSBjYW4gc28gdGhhdCB3ZSBjYW4gc3VzcGVuZCBhcyBkZWVwbHkgYXMgcG9zc2libGUgaW4gdGhlIHRyZWVcbiAgICAvLyBvciBub3QgYXQgYWxsIGlmIHdlIGRvbid0IGVuZCB1cCB3YWl0aW5nIGZvciB0aGUgaW5wdXQuXG4gICAgc2NoZWR1bGVPbk5leHRUaWNrKCgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKSlcbiAgfVxuXG4gIHJldHVybiBjb250cm9sbGVyLnNpZ25hbFxufVxuXG5leHBvcnQgZnVuY3Rpb24gYW5ub3RhdGVEeW5hbWljQWNjZXNzKFxuICBleHByZXNzaW9uOiBzdHJpbmcsXG4gIHByZXJlbmRlclN0b3JlOiBQcmVyZW5kZXJTdG9yZU1vZGVyblxuKSB7XG4gIGNvbnN0IGR5bmFtaWNUcmFja2luZyA9IHByZXJlbmRlclN0b3JlLmR5bmFtaWNUcmFja2luZ1xuICBpZiAoZHluYW1pY1RyYWNraW5nKSB7XG4gICAgZHluYW1pY1RyYWNraW5nLmR5bmFtaWNBY2Nlc3Nlcy5wdXNoKHtcbiAgICAgIHN0YWNrOiBkeW5hbWljVHJhY2tpbmcuaXNEZWJ1Z0R5bmFtaWNBY2Nlc3Nlc1xuICAgICAgICA/IG5ldyBFcnJvcigpLnN0YWNrXG4gICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgZXhwcmVzc2lvbixcbiAgICB9KVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VEeW5hbWljUm91dGVQYXJhbXMoZXhwcmVzc2lvbjogc3RyaW5nKSB7XG4gIGNvbnN0IHdvcmtTdG9yZSA9IHdvcmtBc3luY1N0b3JhZ2UuZ2V0U3RvcmUoKVxuXG4gIGlmIChcbiAgICB3b3JrU3RvcmUgJiZcbiAgICB3b3JrU3RvcmUuaXNTdGF0aWNHZW5lcmF0aW9uICYmXG4gICAgd29ya1N0b3JlLmZhbGxiYWNrUm91dGVQYXJhbXMgJiZcbiAgICB3b3JrU3RvcmUuZmFsbGJhY2tSb3V0ZVBhcmFtcy5zaXplID4gMFxuICApIHtcbiAgICAvLyBUaGVyZSBhcmUgZmFsbGJhY2sgcm91dGUgcGFyYW1zLCB3ZSBzaG91bGQgdHJhY2sgdGhlc2UgYXMgZHluYW1pY1xuICAgIC8vIGFjY2Vzc2VzLlxuICAgIGNvbnN0IHdvcmtVbml0U3RvcmUgPSB3b3JrVW5pdEFzeW5jU3RvcmFnZS5nZXRTdG9yZSgpXG4gICAgaWYgKHdvcmtVbml0U3RvcmUpIHtcbiAgICAgIC8vIFdlJ3JlIHByZXJlbmRlcmluZyB3aXRoIGR5bmFtaWNJTyBvciBQUFIgb3IgYm90aFxuICAgICAgaWYgKHdvcmtVbml0U3RvcmUudHlwZSA9PT0gJ3ByZXJlbmRlci1jbGllbnQnKSB7XG4gICAgICAgIC8vIFdlIGFyZSBpbiBhIHByZXJlbmRlciB3aXRoIGR5bmFtaWNJTyBzZW1hbnRpY3NcbiAgICAgICAgLy8gV2UgYXJlIGdvaW5nIHRvIGhhbmcgaGVyZSBhbmQgbmV2ZXIgcmVzb2x2ZS4gVGhpcyB3aWxsIGNhdXNlIHRoZSBjdXJyZW50bHlcbiAgICAgICAgLy8gcmVuZGVyaW5nIGNvbXBvbmVudCB0byBlZmZlY3RpdmVseSBiZSBhIGR5bmFtaWMgaG9sZVxuICAgICAgICBSZWFjdC51c2UobWFrZUhhbmdpbmdQcm9taXNlKHdvcmtVbml0U3RvcmUucmVuZGVyU2lnbmFsLCBleHByZXNzaW9uKSlcbiAgICAgIH0gZWxzZSBpZiAod29ya1VuaXRTdG9yZS50eXBlID09PSAncHJlcmVuZGVyLXBwcicpIHtcbiAgICAgICAgLy8gV2UncmUgcHJlcmVuZGVyaW5nIHdpdGggUFBSXG4gICAgICAgIHBvc3Rwb25lV2l0aFRyYWNraW5nKFxuICAgICAgICAgIHdvcmtTdG9yZS5yb3V0ZSxcbiAgICAgICAgICBleHByZXNzaW9uLFxuICAgICAgICAgIHdvcmtVbml0U3RvcmUuZHluYW1pY1RyYWNraW5nXG4gICAgICAgIClcbiAgICAgIH0gZWxzZSBpZiAod29ya1VuaXRTdG9yZS50eXBlID09PSAncHJlcmVuZGVyLWxlZ2FjeScpIHtcbiAgICAgICAgdGhyb3dUb0ludGVycnVwdFN0YXRpY0dlbmVyYXRpb24oZXhwcmVzc2lvbiwgd29ya1N0b3JlLCB3b3JrVW5pdFN0b3JlKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBoYXNTdXNwZW5zZVJlZ2V4ID0gL1xcblxccythdCBTdXNwZW5zZSBcXCg8YW5vbnltb3VzPlxcKS9cbmNvbnN0IGhhc1N1c3BlbnNlQWZ0ZXJCb2R5T3JIdG1sUmVnZXggPVxuICAvXFxuXFxzK2F0ICg/OmJvZHl8aHRtbCkgXFwoPGFub255bW91cz5cXClbXFxzXFxTXSo/XFxuXFxzK2F0IFN1c3BlbnNlIFxcKDxhbm9ueW1vdXM+XFwpL1xuY29uc3QgaGFzTWV0YWRhdGFSZWdleCA9IG5ldyBSZWdFeHAoXG4gIGBcXFxcblxcXFxzK2F0ICR7TUVUQURBVEFfQk9VTkRBUllfTkFNRX1bXFxcXG5cXFxcc11gXG4pXG5jb25zdCBoYXNWaWV3cG9ydFJlZ2V4ID0gbmV3IFJlZ0V4cChcbiAgYFxcXFxuXFxcXHMrYXQgJHtWSUVXUE9SVF9CT1VOREFSWV9OQU1FfVtcXFxcblxcXFxzXWBcbilcbmNvbnN0IGhhc091dGxldFJlZ2V4ID0gbmV3IFJlZ0V4cChgXFxcXG5cXFxccythdCAke09VVExFVF9CT1VOREFSWV9OQU1FfVtcXFxcblxcXFxzXWApXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFja0FsbG93ZWREeW5hbWljQWNjZXNzKFxuICB3b3JrU3RvcmU6IFdvcmtTdG9yZSxcbiAgY29tcG9uZW50U3RhY2s6IHN0cmluZyxcbiAgZHluYW1pY1ZhbGlkYXRpb246IER5bmFtaWNWYWxpZGF0aW9uU3RhdGUsXG4gIGNsaWVudER5bmFtaWM6IER5bmFtaWNUcmFja2luZ1N0YXRlXG4pIHtcbiAgaWYgKGhhc091dGxldFJlZ2V4LnRlc3QoY29tcG9uZW50U3RhY2spKSB7XG4gICAgLy8gV2UgZG9uJ3QgbmVlZCB0byB0cmFjayB0aGF0IHRoaXMgaXMgZHluYW1pYy4gSXQgaXMgb25seSBzbyB3aGVuIHNvbWV0aGluZyBlbHNlIGlzIGFsc28gZHluYW1pYy5cbiAgICByZXR1cm5cbiAgfSBlbHNlIGlmIChoYXNNZXRhZGF0YVJlZ2V4LnRlc3QoY29tcG9uZW50U3RhY2spKSB7XG4gICAgZHluYW1pY1ZhbGlkYXRpb24uaGFzRHluYW1pY01ldGFkYXRhID0gdHJ1ZVxuICAgIHJldHVyblxuICB9IGVsc2UgaWYgKGhhc1ZpZXdwb3J0UmVnZXgudGVzdChjb21wb25lbnRTdGFjaykpIHtcbiAgICBkeW5hbWljVmFsaWRhdGlvbi5oYXNEeW5hbWljVmlld3BvcnQgPSB0cnVlXG4gICAgcmV0dXJuXG4gIH0gZWxzZSBpZiAoaGFzU3VzcGVuc2VBZnRlckJvZHlPckh0bWxSZWdleC50ZXN0KGNvbXBvbmVudFN0YWNrKSkge1xuICAgIC8vIFRoaXMgcHJlcmVuZGVyIGhhcyBhIFN1c3BlbnNlIGJvdW5kYXJ5IGFib3ZlIHRoZSBib2R5IHdoaWNoXG4gICAgLy8gZWZmZWN0aXZlbHkgb3B0cyB0aGUgcGFnZSBpbnRvIGFsbG93aW5nIDEwMCUgZHluYW1pYyByZW5kZXJpbmdcbiAgICBkeW5hbWljVmFsaWRhdGlvbi5oYXNBbGxvd2VkRHluYW1pYyA9IHRydWVcbiAgICBkeW5hbWljVmFsaWRhdGlvbi5oYXNTdXNwZW5zZUFib3ZlQm9keSA9IHRydWVcbiAgICByZXR1cm5cbiAgfSBlbHNlIGlmIChoYXNTdXNwZW5zZVJlZ2V4LnRlc3QoY29tcG9uZW50U3RhY2spKSB7XG4gICAgLy8gdGhpcyBlcnJvciBoYWQgYSBTdXNwZW5zZSBib3VuZGFyeSBhYm92ZSBpdCBzbyB3ZSBkb24ndCBuZWVkIHRvIHJlcG9ydCBpdCBhcyBhIHNvdXJjZVxuICAgIC8vIG9mIGRpc2FsbG93ZWRcbiAgICBkeW5hbWljVmFsaWRhdGlvbi5oYXNBbGxvd2VkRHluYW1pYyA9IHRydWVcbiAgICByZXR1cm5cbiAgfSBlbHNlIGlmIChjbGllbnREeW5hbWljLnN5bmNEeW5hbWljRXJyb3JXaXRoU3RhY2spIHtcbiAgICAvLyBUaGlzIHRhc2sgd2FzIHRoZSB0YXNrIHRoYXQgY2FsbGVkIHRoZSBzeW5jIGVycm9yLlxuICAgIGR5bmFtaWNWYWxpZGF0aW9uLmR5bmFtaWNFcnJvcnMucHVzaChcbiAgICAgIGNsaWVudER5bmFtaWMuc3luY0R5bmFtaWNFcnJvcldpdGhTdGFja1xuICAgIClcbiAgICByZXR1cm5cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBtZXNzYWdlID0gYFJvdXRlIFwiJHt3b3JrU3RvcmUucm91dGV9XCI6IEEgY29tcG9uZW50IGFjY2Vzc2VkIGRhdGEsIGhlYWRlcnMsIHBhcmFtcywgc2VhcmNoUGFyYW1zLCBvciBhIHNob3J0LWxpdmVkIGNhY2hlIHdpdGhvdXQgYSBTdXNwZW5zZSBib3VuZGFyeSBub3IgYSBcInVzZSBjYWNoZVwiIGFib3ZlIGl0LiBTZWUgbW9yZSBpbmZvOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LXByZXJlbmRlci1taXNzaW5nLXN1c3BlbnNlYFxuICAgIGNvbnN0IGVycm9yID0gY3JlYXRlRXJyb3JXaXRoQ29tcG9uZW50T3JPd25lclN0YWNrKG1lc3NhZ2UsIGNvbXBvbmVudFN0YWNrKVxuICAgIGR5bmFtaWNWYWxpZGF0aW9uLmR5bmFtaWNFcnJvcnMucHVzaChlcnJvcilcbiAgICByZXR1cm5cbiAgfVxufVxuXG4vKipcbiAqIEluIGRldiBtb2RlLCB3ZSBwcmVmZXIgdXNpbmcgdGhlIG93bmVyIHN0YWNrLCBvdGhlcndpc2UgdGhlIHByb3ZpZGVkXG4gKiBjb21wb25lbnQgc3RhY2sgaXMgdXNlZC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRXJyb3JXaXRoQ29tcG9uZW50T3JPd25lclN0YWNrKFxuICBtZXNzYWdlOiBzdHJpbmcsXG4gIGNvbXBvbmVudFN0YWNrOiBzdHJpbmdcbikge1xuICBjb25zdCBvd25lclN0YWNrID1cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIFJlYWN0LmNhcHR1cmVPd25lclN0YWNrXG4gICAgICA/IFJlYWN0LmNhcHR1cmVPd25lclN0YWNrKClcbiAgICAgIDogbnVsbFxuXG4gIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpXG4gIGVycm9yLnN0YWNrID0gZXJyb3IubmFtZSArICc6ICcgKyBtZXNzYWdlICsgKG93bmVyU3RhY2sgPz8gY29tcG9uZW50U3RhY2spXG4gIHJldHVybiBlcnJvclxufVxuXG5leHBvcnQgZW51bSBQcmVsdWRlU3RhdGUge1xuICBGdWxsID0gMCxcbiAgRW1wdHkgPSAxLFxuICBFcnJvcmVkID0gMixcbn1cblxuZnVuY3Rpb24gbG9nRGlzYWxsb3dlZER5bmFtaWNFcnJvcih3b3JrU3RvcmU6IFdvcmtTdG9yZSwgZXJyb3I6IEVycm9yKTogdm9pZCB7XG4gIGNvbnNvbGUuZXJyb3IoZXJyb3IpXG5cbiAgaWYgKCF3b3JrU3RvcmUuZGV2KSB7XG4gICAgaWYgKHdvcmtTdG9yZS5oYXNSZWFkYWJsZUVycm9yU3RhY2tzKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBgVG8gZ2V0IGEgbW9yZSBkZXRhaWxlZCBzdGFjayB0cmFjZSBhbmQgcGlucG9pbnQgdGhlIGlzc3VlLCBzdGFydCB0aGUgYXBwIGluIGRldmVsb3BtZW50IG1vZGUgYnkgcnVubmluZyBcXGBuZXh0IGRldlxcYCwgdGhlbiBvcGVuIFwiJHt3b3JrU3RvcmUucm91dGV9XCIgaW4geW91ciBicm93c2VyIHRvIGludmVzdGlnYXRlIHRoZSBlcnJvci5gXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYFRvIGdldCBhIG1vcmUgZGV0YWlsZWQgc3RhY2sgdHJhY2UgYW5kIHBpbnBvaW50IHRoZSBpc3N1ZSwgdHJ5IG9uZSBvZiB0aGUgZm9sbG93aW5nOlxuICAtIFN0YXJ0IHRoZSBhcHAgaW4gZGV2ZWxvcG1lbnQgbW9kZSBieSBydW5uaW5nIFxcYG5leHQgZGV2XFxgLCB0aGVuIG9wZW4gXCIke3dvcmtTdG9yZS5yb3V0ZX1cIiBpbiB5b3VyIGJyb3dzZXIgdG8gaW52ZXN0aWdhdGUgdGhlIGVycm9yLlxuICAtIFJlcnVuIHRoZSBwcm9kdWN0aW9uIGJ1aWxkIHdpdGggXFxgbmV4dCBidWlsZCAtLWRlYnVnLXByZXJlbmRlclxcYCB0byBnZW5lcmF0ZSBiZXR0ZXIgc3RhY2sgdHJhY2VzLmApXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0aHJvd0lmRGlzYWxsb3dlZER5bmFtaWMoXG4gIHdvcmtTdG9yZTogV29ya1N0b3JlLFxuICBwcmVsdWRlOiBQcmVsdWRlU3RhdGUsXG4gIGR5bmFtaWNWYWxpZGF0aW9uOiBEeW5hbWljVmFsaWRhdGlvblN0YXRlLFxuICBzZXJ2ZXJEeW5hbWljOiBEeW5hbWljVHJhY2tpbmdTdGF0ZVxuKTogdm9pZCB7XG4gIGlmICh3b3JrU3RvcmUuaW52YWxpZER5bmFtaWNVc2FnZUVycm9yKSB7XG4gICAgbG9nRGlzYWxsb3dlZER5bmFtaWNFcnJvcih3b3JrU3RvcmUsIHdvcmtTdG9yZS5pbnZhbGlkRHluYW1pY1VzYWdlRXJyb3IpXG4gICAgdGhyb3cgbmV3IFN0YXRpY0dlbkJhaWxvdXRFcnJvcigpXG4gIH1cblxuICBpZiAocHJlbHVkZSAhPT0gUHJlbHVkZVN0YXRlLkZ1bGwpIHtcbiAgICBpZiAoZHluYW1pY1ZhbGlkYXRpb24uaGFzU3VzcGVuc2VBYm92ZUJvZHkpIHtcbiAgICAgIC8vIFRoaXMgcm91dGUgaGFzIG9wdGVkIGludG8gYWxsb3dpbmcgZnVsbHkgZHluYW1pYyByZW5kZXJpbmdcbiAgICAgIC8vIGJ5IGluY2x1ZGluZyBhIFN1c3BlbnNlIGJvdW5kYXJ5IGFib3ZlIHRoZSBib2R5LiBJbiB0aGlzIGNhc2VcbiAgICAgIC8vIGEgbGFjayBvZiBhIHNoZWxsIGlzIG5vdCBjb25zaWRlcmVkIGRpc2FsbG93ZWQgc28gd2Ugc2ltcGx5IHJldHVyblxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHNlcnZlckR5bmFtaWMuc3luY0R5bmFtaWNFcnJvcldpdGhTdGFjaykge1xuICAgICAgLy8gVGhlcmUgaXMgbm8gc2hlbGwgYW5kIHRoZSBzZXJ2ZXIgZGlkIHNvbWV0aGluZyBzeW5jIGR5bmFtaWMgbGlrZWx5XG4gICAgICAvLyBsZWFkaW5nIHRvIGFuIGVhcmx5IHRlcm1pbmF0aW9uIG9mIHRoZSBwcmVyZW5kZXIgYmVmb3JlIHRoZSBzaGVsbFxuICAgICAgLy8gY291bGQgYmUgY29tcGxldGVkLiBXZSB0ZXJtaW5hdGUgdGhlIGJ1aWxkL3ZhbGlkYXRpbmcgcmVuZGVyLlxuICAgICAgbG9nRGlzYWxsb3dlZER5bmFtaWNFcnJvcihcbiAgICAgICAgd29ya1N0b3JlLFxuICAgICAgICBzZXJ2ZXJEeW5hbWljLnN5bmNEeW5hbWljRXJyb3JXaXRoU3RhY2tcbiAgICAgIClcbiAgICAgIHRocm93IG5ldyBTdGF0aWNHZW5CYWlsb3V0RXJyb3IoKVxuICAgIH1cblxuICAgIC8vIFdlIGRpZG4ndCBoYXZlIGFueSBzeW5jIGJhaWxvdXRzIGJ1dCB0aGVyZSBtYXkgYmUgdXNlciBjb2RlIHdoaWNoXG4gICAgLy8gYmxvY2tlZCB0aGUgcm9vdC4gV2Ugd291bGQgaGF2ZSBjYXB0dXJlZCB0aGVzZSBkdXJpbmcgdGhlIHByZXJlbmRlclxuICAgIC8vIGFuZCBjYW4gbG9nIHRoZW0gaGVyZSBhbmQgdGhlbiB0ZXJtaW5hdGUgdGhlIGJ1aWxkL3ZhbGlkYXRpbmcgcmVuZGVyXG4gICAgY29uc3QgZHluYW1pY0Vycm9ycyA9IGR5bmFtaWNWYWxpZGF0aW9uLmR5bmFtaWNFcnJvcnNcbiAgICBpZiAoZHluYW1pY0Vycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGR5bmFtaWNFcnJvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbG9nRGlzYWxsb3dlZER5bmFtaWNFcnJvcih3b3JrU3RvcmUsIGR5bmFtaWNFcnJvcnNbaV0pXG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBTdGF0aWNHZW5CYWlsb3V0RXJyb3IoKVxuICAgIH1cblxuICAgIC8vIElmIHdlIGdvdCB0aGlzIGZhciB0aGVuIHRoZSBvbmx5IG90aGVyIHRoaW5nIHRoYXQgY291bGQgYmUgYmxvY2tpbmdcbiAgICAvLyB0aGUgcm9vdCBpcyBkeW5hbWljIFZpZXdwb3J0LiBJZiB0aGlzIGlzIGR5bmFtaWMgdGhlblxuICAgIC8vIHlvdSBuZWVkIHRvIG9wdCBpbnRvIHRoYXQgYnkgYWRkaW5nIGEgU3VzcGVuc2UgYm91bmRhcnkgYWJvdmUgdGhlIGJvZHlcbiAgICAvLyB0byBpbmRpY2F0ZSB5b3VyIGFyZSBvayB3aXRoIGZ1bGx5IGR5bmFtaWMgcmVuZGVyaW5nLlxuICAgIGlmIChkeW5hbWljVmFsaWRhdGlvbi5oYXNEeW5hbWljVmlld3BvcnQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIGBSb3V0ZSBcIiR7d29ya1N0b3JlLnJvdXRlfVwiIGhhcyBhIFxcYGdlbmVyYXRlVmlld3BvcnRcXGAgdGhhdCBkZXBlbmRzIG9uIFJlcXVlc3QgZGF0YSAoXFxgY29va2llcygpXFxgLCBldGMuLi4pIG9yIHVuY2FjaGVkIGV4dGVybmFsIGRhdGEgKFxcYGZldGNoKC4uLilcXGAsIGV0Yy4uLikgd2l0aG91dCBleHBsaWNpdGx5IGFsbG93aW5nIGZ1bGx5IGR5bmFtaWMgcmVuZGVyaW5nLiBTZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL25leHQtcHJlcmVuZGVyLWR5bmFtaWMtdmlld3BvcnRgXG4gICAgICApXG4gICAgICB0aHJvdyBuZXcgU3RhdGljR2VuQmFpbG91dEVycm9yKClcbiAgICB9XG5cbiAgICBpZiAocHJlbHVkZSA9PT0gUHJlbHVkZVN0YXRlLkVtcHR5KSB7XG4gICAgICAvLyBJZiB3ZSBldmVyIGdldCB0aGlzIGZhciB0aGVuIHdlIG1lc3NlZCB1cCB0aGUgdHJhY2tpbmcgb2YgaW52YWxpZCBkeW5hbWljLlxuICAgICAgLy8gV2Ugc3RpbGwgYWRoZXJlIHRvIHRoZSBjb25zdHJhaW50IHRoYXQgeW91IG11c3QgcHJvZHVjZSBhIHNoZWxsIGJ1dCBpbnZpdGUgdGhlXG4gICAgICAvLyB1c2VyIHRvIHJlcG9ydCB0aGlzIGFzIGEgYnVnIGluIE5leHQuanMuXG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBgUm91dGUgXCIke3dvcmtTdG9yZS5yb3V0ZX1cIiBkaWQgbm90IHByb2R1Y2UgYSBzdGF0aWMgc2hlbGwgYW5kIE5leHQuanMgd2FzIHVuYWJsZSB0byBkZXRlcm1pbmUgYSByZWFzb24uIFRoaXMgaXMgYSBidWcgaW4gTmV4dC5qcy5gXG4gICAgICApXG4gICAgICB0aHJvdyBuZXcgU3RhdGljR2VuQmFpbG91dEVycm9yKClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKFxuICAgICAgZHluYW1pY1ZhbGlkYXRpb24uaGFzQWxsb3dlZER5bmFtaWMgPT09IGZhbHNlICYmXG4gICAgICBkeW5hbWljVmFsaWRhdGlvbi5oYXNEeW5hbWljTWV0YWRhdGFcbiAgICApIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIGBSb3V0ZSBcIiR7d29ya1N0b3JlLnJvdXRlfVwiIGhhcyBhIFxcYGdlbmVyYXRlTWV0YWRhdGFcXGAgdGhhdCBkZXBlbmRzIG9uIFJlcXVlc3QgZGF0YSAoXFxgY29va2llcygpXFxgLCBldGMuLi4pIG9yIHVuY2FjaGVkIGV4dGVybmFsIGRhdGEgKFxcYGZldGNoKC4uLilcXGAsIGV0Yy4uLikgd2hlbiB0aGUgcmVzdCBvZiB0aGUgcm91dGUgZG9lcyBub3QuIFNlZSBtb3JlIGluZm8gaGVyZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbmV4dC1wcmVyZW5kZXItZHluYW1pYy1tZXRhZGF0YWBcbiAgICAgIClcbiAgICAgIHRocm93IG5ldyBTdGF0aWNHZW5CYWlsb3V0RXJyb3IoKVxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbIlJlYWN0IiwiRHluYW1pY1NlcnZlckVycm9yIiwiU3RhdGljR2VuQmFpbG91dEVycm9yIiwid29ya1VuaXRBc3luY1N0b3JhZ2UiLCJ3b3JrQXN5bmNTdG9yYWdlIiwibWFrZUhhbmdpbmdQcm9taXNlIiwiTUVUQURBVEFfQk9VTkRBUllfTkFNRSIsIlZJRVdQT1JUX0JPVU5EQVJZX05BTUUiLCJPVVRMRVRfQk9VTkRBUllfTkFNRSIsInNjaGVkdWxlT25OZXh0VGljayIsImhhc1Bvc3Rwb25lIiwidW5zdGFibGVfcG9zdHBvbmUiLCJjcmVhdGVEeW5hbWljVHJhY2tpbmdTdGF0ZSIsImlzRGVidWdEeW5hbWljQWNjZXNzZXMiLCJkeW5hbWljQWNjZXNzZXMiLCJzeW5jRHluYW1pY0Vycm9yV2l0aFN0YWNrIiwiY3JlYXRlRHluYW1pY1ZhbGlkYXRpb25TdGF0ZSIsImhhc1N1c3BlbnNlQWJvdmVCb2R5IiwiaGFzRHluYW1pY01ldGFkYXRhIiwiaGFzRHluYW1pY1ZpZXdwb3J0IiwiaGFzQWxsb3dlZER5bmFtaWMiLCJkeW5hbWljRXJyb3JzIiwiZ2V0Rmlyc3REeW5hbWljUmVhc29uIiwidHJhY2tpbmdTdGF0ZSIsImV4cHJlc3Npb24iLCJtYXJrQ3VycmVudFNjb3BlQXNEeW5hbWljIiwic3RvcmUiLCJ3b3JrVW5pdFN0b3JlIiwidHlwZSIsImZvcmNlRHluYW1pYyIsImZvcmNlU3RhdGljIiwiZHluYW1pY1Nob3VsZEVycm9yIiwicm91dGUiLCJwb3N0cG9uZVdpdGhUcmFja2luZyIsImR5bmFtaWNUcmFja2luZyIsInJldmFsaWRhdGUiLCJlcnIiLCJkeW5hbWljVXNhZ2VEZXNjcmlwdGlvbiIsImR5bmFtaWNVc2FnZVN0YWNrIiwic3RhY2siLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJ1c2VkRHluYW1pYyIsInRyYWNrRmFsbGJhY2tQYXJhbUFjY2Vzc2VkIiwicHJlcmVuZGVyU3RvcmUiLCJnZXRTdG9yZSIsInRocm93VG9JbnRlcnJ1cHRTdGF0aWNHZW5lcmF0aW9uIiwidHJhY2tEeW5hbWljRGF0YUluRHluYW1pY1JlbmRlciIsIl9zdG9yZSIsImFib3J0T25TeW5jaHJvbm91c0R5bmFtaWNEYXRhQWNjZXNzIiwicmVhc29uIiwiZXJyb3IiLCJjcmVhdGVQcmVyZW5kZXJJbnRlcnJ1cHRlZEVycm9yIiwiY29udHJvbGxlciIsImFib3J0IiwicHVzaCIsIkVycm9yIiwidW5kZWZpbmVkIiwiYWJvcnRPblN5bmNocm9ub3VzUGxhdGZvcm1JT0FjY2VzcyIsImVycm9yV2l0aFN0YWNrIiwidHJhY2tTeW5jaHJvbm91c1BsYXRmb3JtSU9BY2Nlc3NJbkRldiIsInJlcXVlc3RTdG9yZSIsInByZXJlbmRlclBoYXNlIiwiYWJvcnRBbmRUaHJvd09uU3luY2hyb25vdXNSZXF1ZXN0RGF0YUFjY2VzcyIsInByZXJlbmRlclNpZ25hbCIsInNpZ25hbCIsImFib3J0ZWQiLCJ0cmFja1N5bmNocm9ub3VzUmVxdWVzdERhdGFBY2Nlc3NJbkRldiIsIlBvc3Rwb25lIiwiYXNzZXJ0UG9zdHBvbmUiLCJjcmVhdGVQb3N0cG9uZVJlYXNvbiIsImlzRHluYW1pY1Bvc3Rwb25lIiwibWVzc2FnZSIsImlzRHluYW1pY1Bvc3Rwb25lUmVhc29uIiwiaW5jbHVkZXMiLCJORVhUX1BSRVJFTkRFUl9JTlRFUlJVUFRFRCIsImRpZ2VzdCIsImlzUHJlcmVuZGVySW50ZXJydXB0ZWRFcnJvciIsImFjY2Vzc2VkRHluYW1pY0RhdGEiLCJsZW5ndGgiLCJjb25zdW1lRHluYW1pY0FjY2VzcyIsInNlcnZlckR5bmFtaWMiLCJjbGllbnREeW5hbWljIiwiZm9ybWF0RHluYW1pY0FQSUFjY2Vzc2VzIiwiZmlsdGVyIiwiYWNjZXNzIiwibWFwIiwic3BsaXQiLCJzbGljZSIsImxpbmUiLCJqb2luIiwiY3JlYXRlUG9zdHBvbmVkQWJvcnRTaWduYWwiLCJBYm9ydENvbnRyb2xsZXIiLCJ4IiwiY3JlYXRlSGFuZ2luZ0lucHV0QWJvcnRTaWduYWwiLCJjYWNoZVNpZ25hbCIsImlucHV0UmVhZHkiLCJ0aGVuIiwiYW5ub3RhdGVEeW5hbWljQWNjZXNzIiwidXNlRHluYW1pY1JvdXRlUGFyYW1zIiwid29ya1N0b3JlIiwiaXNTdGF0aWNHZW5lcmF0aW9uIiwiZmFsbGJhY2tSb3V0ZVBhcmFtcyIsInNpemUiLCJ1c2UiLCJyZW5kZXJTaWduYWwiLCJoYXNTdXNwZW5zZVJlZ2V4IiwiaGFzU3VzcGVuc2VBZnRlckJvZHlPckh0bWxSZWdleCIsImhhc01ldGFkYXRhUmVnZXgiLCJSZWdFeHAiLCJoYXNWaWV3cG9ydFJlZ2V4IiwiaGFzT3V0bGV0UmVnZXgiLCJ0cmFja0FsbG93ZWREeW5hbWljQWNjZXNzIiwiY29tcG9uZW50U3RhY2siLCJkeW5hbWljVmFsaWRhdGlvbiIsInRlc3QiLCJjcmVhdGVFcnJvcldpdGhDb21wb25lbnRPck93bmVyU3RhY2siLCJvd25lclN0YWNrIiwiY2FwdHVyZU93bmVyU3RhY2siLCJuYW1lIiwiUHJlbHVkZVN0YXRlIiwibG9nRGlzYWxsb3dlZER5bmFtaWNFcnJvciIsImNvbnNvbGUiLCJkZXYiLCJoYXNSZWFkYWJsZUVycm9yU3RhY2tzIiwidGhyb3dJZkRpc2FsbG93ZWREeW5hbWljIiwicHJlbHVkZSIsImludmFsaWREeW5hbWljVXNhZ2VFcnJvciIsImkiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW9CQyxHQVVELHdGQUF3Rjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUN4RixPQUFPQSxXQUFXLFFBQU87QUFFekIsU0FBU0Msa0JBQWtCLFFBQVEsK0NBQThDO0FBQ2pGLFNBQVNDLHFCQUFxQixRQUFRLG9EQUFtRDtBQUN6RixTQUFTQyxvQkFBb0IsUUFBUSxxQ0FBb0M7QUFDekUsU0FBU0MsZ0JBQWdCLFFBQVEsNENBQTJDO0FBQzVFLFNBQVNDLGtCQUFrQixRQUFRLDZCQUE0QjtBQUMvRCxTQUNFQyxzQkFBc0IsRUFDdEJDLHNCQUFzQixFQUN0QkMsb0JBQW9CLFFBQ2Ysd0NBQXVDO0FBQzlDLFNBQVNDLGtCQUFrQixRQUFRLHNCQUFxQjs7Ozs7Ozs7O0FBRXhELE1BQU1DLGNBQWMsT0FBT1YsZ05BQUFBLENBQU1XLGlCQUFpQixLQUFLO0FBd0NoRCxTQUFTQywyQkFDZEMsc0JBQTJDO0lBRTNDLE9BQU87UUFDTEE7UUFDQUMsaUJBQWlCLEVBQUU7UUFDbkJDLDJCQUEyQjtJQUM3QjtBQUNGO0FBRU8sU0FBU0M7SUFDZCxPQUFPO1FBQ0xDLHNCQUFzQjtRQUN0QkMsb0JBQW9CO1FBQ3BCQyxvQkFBb0I7UUFDcEJDLG1CQUFtQjtRQUNuQkMsZUFBZSxFQUFFO0lBQ25CO0FBQ0Y7QUFFTyxTQUFTQyxzQkFDZEMsYUFBbUM7UUFFNUJBO0lBQVAsT0FBQSxDQUFPQSxrQ0FBQUEsY0FBY1QsZUFBZSxDQUFDLEVBQUUsS0FBQSxPQUFB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aEYsYUFBYSxDQUFDNEcsRUFBRTtZQUN2RDtZQUVBLE1BQU0sa01BQUkvSCx5QkFBQUE7UUFDWjtRQUVBLHNFQUFzRTtRQUN0RSx3REFBd0Q7UUFDeEQseUVBQXlFO1FBQ3pFLHdEQUF3RDtRQUN4RCxJQUFJaUgsa0JBQWtCaEcsa0JBQWtCLEVBQUU7WUFDeEN3RyxRQUFRdkUsS0FBSyxDQUNYLENBQUMsT0FBTyxFQUFFaUQsVUFBVXJFLEtBQUssQ0FBQyw4UUFBOFEsQ0FBQztZQUUzUyxNQUFNLG1NQUFJOUIsd0JBQUFBO1FBQ1o7UUFFQSxJQUFJNkgsWUFBQUEsR0FBZ0M7WUFDbEMsNkVBQTZFO1lBQzdFLGlGQUFpRjtZQUNqRiwyQ0FBMkM7WUFDM0NKLFFBQVF2RSxLQUFLLENBQ1gsQ0FBQyxPQUFPLEVBQUVpRCxVQUFVckUsS0FBSyxDQUFDLHdHQUF3RyxDQUFDO1lBRXJJLE1BQU0sbU1BQUk5Qix3QkFBQUE7UUFDWjtJQUNGLE9BQU87UUFDTCxJQUNFaUgsa0JBQWtCL0YsaUJBQWlCLEtBQUssU0FDeEMrRixrQkFBa0JqRyxrQkFBa0IsRUFDcEM7WUFDQXlHLFFBQVF2RSxLQUFLLENBQ1gsQ0FBQyxPQUFPLEVBQUVpRCxVQUFVckUsS0FBSyxDQUFDLDhQQUE4UCxDQUFDO1lBRTNSLE1BQU0sbU1BQUk5Qix3QkFBQUE7UUFDWjtJQUNGO0FBQ0YiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogODI2LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zcmMvc2hhcmVkL2xpYi9pbnZhcmlhbnQtZXJyb3IudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNsYXNzIEludmFyaWFudEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIG9wdGlvbnM/OiBFcnJvck9wdGlvbnMpIHtcbiAgICBzdXBlcihcbiAgICAgIGBJbnZhcmlhbnQ6ICR7bWVzc2FnZS5lbmRzV2l0aCgnLicpID8gbWVzc2FnZSA6IG1lc3NhZ2UgKyAnLid9IFRoaXMgaXMgYSBidWcgaW4gTmV4dC5qcy5gLFxuICAgICAgb3B0aW9uc1xuICAgIClcbiAgICB0aGlzLm5hbWUgPSAnSW52YXJpYW50RXJyb3InXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJJbnZhcmlhbnRFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJtZXNzYWdlIiwib3B0aW9ucyIsImVuZHNXaXRoIiwibmFtZSJdLCJtYXBwaW5ncyI6Ijs7O0FBQU8sTUFBTUEsdUJBQXVCQztJQUNsQ0MsWUFBWUMsT0FBZSxFQUFFQyxPQUFzQixDQUFFO1FBQ25ELEtBQUssQ0FDRixnQkFBYUQsQ0FBQUEsUUFBUUUsUUFBUSxDQUFDLE9BQU9GLFVBQVVBLFVBQVUsR0FBRSxJQUFFLDhCQUM5REM7UUFFRixJQUFJLENBQUNFLElBQUksR0FBRztJQUNkO0FBQ0YiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogODM5LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zcmMvc2VydmVyL2NyZWF0ZS1kZWR1cGVkLWJ5LWNhbGxzaXRlLXNlcnZlci1lcnJvci1sb2dnZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnXG5cbmNvbnN0IGVycm9yUmVmOiB7IGN1cnJlbnQ6IG51bGwgfCBFcnJvciB9ID0geyBjdXJyZW50OiBudWxsIH1cblxuLy8gUmVhY3QuY2FjaGUgaXMgY3VycmVudGx5IG9ubHkgYXZhaWxhYmxlIGluIGNhbmFyeS9leHBlcmltZW50YWwgUmVhY3QgY2hhbm5lbHMuXG5jb25zdCBjYWNoZSA9XG4gIHR5cGVvZiBSZWFjdC5jYWNoZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gUmVhY3QuY2FjaGVcbiAgICA6IChmbjogKGtleTogdW5rbm93bikgPT4gdm9pZCkgPT4gZm5cblxuLy8gV2hlbiBEeW5hbWljIElPIGlzIGVuYWJsZWQsIHdlIHJlY29yZCB0aGVzZSBhcyBlcnJvcnMgc28gdGhhdCB0aGV5XG4vLyBhcmUgY2FwdHVyZWQgYnkgdGhlIGRldiBvdmVybGF5IGFzIGl0J3MgbW9yZSBjcml0aWNhbCB0byBmaXggdGhlc2Vcbi8vIHdoZW4gZW5hYmxlZC5cbmNvbnN0IGxvZ0Vycm9yT3JXYXJuID0gcHJvY2Vzcy5lbnYuX19ORVhUX0RZTkFNSUNfSU9cbiAgPyBjb25zb2xlLmVycm9yXG4gIDogY29uc29sZS53YXJuXG5cbi8vIFdlIGRvbid0IHdhbnQgdG8gZGVkdXBlIGFjcm9zcyByZXF1ZXN0cy5cbi8vIFRoZSBkZXZlbG9wZXIgbWlnaHQndmUganVzdCBhdHRlbXB0ZWQgdG8gZml4IHRoZSB3YXJuaW5nIHNvIHdlIHNob3VsZCB3YXJuIGFnYWluIGlmIGl0IHN0aWxsIGhhcHBlbnMuXG5jb25zdCBmbHVzaEN1cnJlbnRFcnJvcklmTmV3ID0gY2FjaGUoXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMgLS0gY2FjaGUga2V5XG4gIChrZXk6IHVua25vd24pID0+IHtcbiAgICB0cnkge1xuICAgICAgbG9nRXJyb3JPcldhcm4oZXJyb3JSZWYuY3VycmVudClcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZXJyb3JSZWYuY3VycmVudCA9IG51bGxcbiAgICB9XG4gIH1cbilcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBsb2dzIGFuIGVycm9yIG1lc3NhZ2UgdGhhdCBpcyBkZWR1cGVkIGJ5IHRoZSB1c2VybGFuZFxuICogY2FsbHNpdGUuXG4gKiBUaGlzIHJlcXVpcmVzIG5vIGluZGlyZWN0aW9uIGJldHdlZW4gdGhlIGNhbGwgb2YgdGhpcyBmdW5jdGlvbiBhbmQgdGhlIHVzZXJsYW5kXG4gKiBjYWxsc2l0ZSBpLmUuIHRoZXJlJ3Mgb25seSBhIHNpbmdsZSBsaWJyYXJ5IGZyYW1lIGFib3ZlIHRoaXMuXG4gKiBEbyBub3QgdXNlIG9uIHRoZSBDbGllbnQgd2hlcmUgc291cmNlbWFwcyBhbmQgaWdub3JlIGxpc3RpbmcgbWlnaHQgYmUgZW5hYmxlZC5cbiAqIE9ubHkgdXNlIHRoYXQgZm9yIHdhcm5pbmdzIG5lZWQgYSBmaXggaW5kZXBlbmRlbnQgb2YgdGhlIGNhbGxzdGFjay5cbiAqXG4gKiBAcGFyYW0gZ2V0TWVzc2FnZVxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZURlZHVwZWRCeUNhbGxzaXRlU2VydmVyRXJyb3JMb2dnZXJEZXY8QXJncyBleHRlbmRzIGFueVtdPihcbiAgZ2V0TWVzc2FnZTogKC4uLmFyZ3M6IEFyZ3MpID0+IEVycm9yXG4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGxvZ0RlZHVwZWRFcnJvciguLi5hcmdzOiBBcmdzKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGdldE1lc3NhZ2UoLi4uYXJncylcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBjb25zdCBjYWxsU3RhY2tGcmFtZXMgPSBuZXcgRXJyb3IoKS5zdGFjaz8uc3BsaXQoJ1xcbicpXG4gICAgICBpZiAoY2FsbFN0YWNrRnJhbWVzID09PSB1bmRlZmluZWQgfHwgY2FsbFN0YWNrRnJhbWVzLmxlbmd0aCA8IDQpIHtcbiAgICAgICAgbG9nRXJyb3JPcldhcm4obWVzc2FnZSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEVycm9yOlxuICAgICAgICAvLyAgIGxvZ0RlZHVwZWRFcnJvclxuICAgICAgICAvLyAgIGFzeW5jQXBpQmVpbmdBY2Nlc3NlZFN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gICA8dXNlcmxhbmQgY2FsbHNpdGU+XG4gICAgICAgIC8vIFRPRE86IFRoaXMgYnJlYWtzIGlmIHNvdXJjZW1hcHMgd2l0aCBpZ25vcmUgbGlzdHMgYXJlIGVuYWJsZWQuXG4gICAgICAgIGNvbnN0IGtleSA9IGNhbGxTdGFja0ZyYW1lc1s0XVxuICAgICAgICBlcnJvclJlZi5jdXJyZW50ID0gbWVzc2FnZVxuICAgICAgICBmbHVzaEN1cnJlbnRFcnJvcklmTmV3KGtleSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbG9nRXJyb3JPcldhcm4obWVzc2FnZSlcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJSZWFjdCIsImVycm9yUmVmIiwiY3VycmVudCIsImNhY2hlIiwiZm4iLCJsb2dFcnJvck9yV2FybiIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfRFlOQU1JQ19JTyIsImNvbnNvbGUiLCJlcnJvciIsIndhcm4iLCJmbHVzaEN1cnJlbnRFcnJvcklmTmV3Iiwia2V5IiwiY3JlYXRlRGVkdXBlZEJ5Q2FsbHNpdGVTZXJ2ZXJFcnJvckxvZ2dlckRldiIsImdldE1lc3NhZ2UiLCJsb2dEZWR1cGVkRXJyb3IiLCJhcmdzIiwibWVzc2FnZSIsIk5PREVfRU5WIiwiY2FsbFN0YWNrRnJhbWVzIiwiRXJyb3IiLCJzdGFjayIsInNwbGl0IiwidW5kZWZpbmVkIiwibGVuZ3RoIl0sIm1hcHBpbmdzIjoiOzs7QUFBQSxZQUFZQSxXQUFXLFFBQU87O0FBRTlCLE1BQU1DLFdBQXNDO0lBQUVDLFNBQVM7QUFBSztBQUU1RCxpRkFBaUY7QUFDakYsTUFBTUMsUUFDSiw2TUFBT0gsTUFBTUcsRUFBSyxLQUFLLG1OQUNuQkgsTUFBTUcsRUFBSyxHQUNYLENBQUNDLEtBQStCQTtBQUV0QyxxRUFBcUU7QUFDckUscUVBQXFFO0FBQ3JFLGdCQUFnQjtBQUNoQixNQUFNQyxpQkFBaUJDLFFBQVFDLEdBQUcsQ0FBQ0MsaUJBQWlCLFNBQ2hEQyxRQUFRQyxLQUFLLGFBQ2JELFFBQVFFLElBQUk7QUFFaEIsMkNBQTJDO0FBQzNDLHdHQUF3RztBQUN4RyxNQUFNQyx5QkFBeUJULE1BQzdCLEFBQ0EsQ0FBQ1UseUVBRHlFO0lBRXhFLElBQUk7UUFDRlIsZUFBZUosU0FBU0MsT0FBTztJQUNqQyxTQUFVO1FBQ1JELFNBQVNDLE9BQU8sR0FBRztJQUNyQjtBQUNGO0FBY0ssU0FBU1ksNENBQ2RDLFVBQW9DO0lBRXBDLE9BQU8sU0FBU0MsZ0JBQWdCLEdBQUdDLElBQVU7UUFDM0MsTUFBTUMsVUFBVUgsY0FBY0U7UUFFOUIsSUFBSVgsUUFBUUMsR0FBRyxDQUFDWSxRQUFRLEtBQUssV0FBYztnQkFDakI7WUFBeEIsTUFBTUMsa0JBQUFBLENBQWtCLFNBQUEsSUFBSUMsUUFBUUMsS0FBSyxLQUFBLE9BQUEsS0FBQSxJQUFqQixPQUFtQkMsS0FBSyxDQUFDO1lBQ2pELElBQUlILG9CQUFvQkksYUFBYUosZ0JBQWdCSyxNQUFNLEdBQUcsR0FBRztnQkFDL0RwQixlQUFlYTtZQUNqQixPQUFPO2dCQUNMLFNBQVM7Z0JBQ1Qsb0JBQW9CO2dCQUNwQix1Q0FBdUM7Z0JBQ3ZDLHdCQUF3QjtnQkFDeEIsaUVBQWlFO2dCQUNqRSxNQUFNTCxNQUFNTyxlQUFlLENBQUMsRUFBRTtnQkFDOUJuQixTQUFTQyxPQUFPLEdBQUdnQjtnQkFDbkJOLHVCQUF1QkM7WUFDekI7UUFDRixPQUFPOztJQUdUO0FBQ0YiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogODg4LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zcmMvc2hhcmVkL2xpYi91dGlscy9yZWZsZWN0LXV0aWxzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRoaXMgcmVnZXggd2lsbCBoYXZlIGZhc3QgbmVnYXRpdmVzIG1lYW5pbmcgdmFsaWQgaWRlbnRpZmllcnMgbWF5IG5vdCBwYXNzXG4vLyB0aGlzIHRlc3QuIEhvd2V2ZXIgdGhpcyBpcyBvbmx5IHVzZWQgZHVyaW5nIHN0YXRpYyBnZW5lcmF0aW9uIHRvIHByb3ZpZGUgaGludHNcbi8vIGFib3V0IHdoeSBhIHBhZ2UgYmFpbGVkIG91dCBvZiBzb21lIG9yIGFsbCBwcmVyZW5kZXJpbmcgYW5kIHdlIGNhbiB1c2UgYnJhY2tldCBub3RhdGlvblxuLy8gZm9yIGV4YW1wbGUgd2hpbGUgYOCyoF/gsqBgIGlzIGEgdmFsaWQgaWRlbnRpZmllciBpdCdzIG9rIHRvIHByaW50IGBzZWFyY2hQYXJhbXNbJ+CyoF/gsqAnXWBcbi8vIGV2ZW4gaWYgdGhpcyB3b3VsZCBoYXZlIGJlZW4gZmluZSB0b28gYHNlYXJjaFBhcmFtcy7gsqBf4LKgYFxuY29uc3QgaXNEZWZpbml0ZWx5QVZhbGlkSWRlbnRpZmllciA9IC9eW0EtWmEtel8kXVtBLVphLXowLTlfJF0qJC9cblxuZXhwb3J0IGZ1bmN0aW9uIGRlc2NyaWJlU3RyaW5nUHJvcGVydHlBY2Nlc3ModGFyZ2V0OiBzdHJpbmcsIHByb3A6IHN0cmluZykge1xuICBpZiAoaXNEZWZpbml0ZWx5QVZhbGlkSWRlbnRpZmllci50ZXN0KHByb3ApKSB7XG4gICAgcmV0dXJuIGBcXGAke3RhcmdldH0uJHtwcm9wfVxcYGBcbiAgfVxuICByZXR1cm4gYFxcYCR7dGFyZ2V0fVske0pTT04uc3RyaW5naWZ5KHByb3ApfV1cXGBgXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZXNjcmliZUhhc0NoZWNraW5nU3RyaW5nUHJvcGVydHkoXG4gIHRhcmdldDogc3RyaW5nLFxuICBwcm9wOiBzdHJpbmdcbikge1xuICBjb25zdCBzdHJpbmdpZmllZFByb3AgPSBKU09OLnN0cmluZ2lmeShwcm9wKVxuICByZXR1cm4gYFxcYFJlZmxlY3QuaGFzKCR7dGFyZ2V0fSwgJHtzdHJpbmdpZmllZFByb3B9KVxcYCwgXFxgJHtzdHJpbmdpZmllZFByb3B9IGluICR7dGFyZ2V0fVxcYCwgb3Igc2ltaWxhcmBcbn1cblxuZXhwb3J0IGNvbnN0IHdlbGxLbm93blByb3BlcnRpZXMgPSBuZXcgU2V0KFtcbiAgJ2hhc093blByb3BlcnR5JyxcbiAgJ2lzUHJvdG90eXBlT2YnLFxuICAncHJvcGVydHlJc0VudW1lcmFibGUnLFxuICAndG9TdHJpbmcnLFxuICAndmFsdWVPZicsXG4gICd0b0xvY2FsZVN0cmluZycsXG5cbiAgLy8gUHJvbWlzZSBwcm90b3R5cGVcbiAgLy8gZmFsbHRocm91Z2hcbiAgJ3RoZW4nLFxuICAnY2F0Y2gnLFxuICAnZmluYWxseScsXG5cbiAgLy8gUmVhY3QgUHJvbWlzZSBleHRlbnNpb25cbiAgLy8gZmFsbHRocm91Z2hcbiAgJ3N0YXR1cycsXG5cbiAgLy8gUmVhY3QgaW50cm9zcGVjdGlvblxuICAnZGlzcGxheU5hbWUnLFxuICAnX2RlYnVnSW5mbycsXG5cbiAgLy8gQ29tbW9uIHRlc3RlZCBwcm9wZXJ0aWVzXG4gIC8vIGZhbGx0aHJvdWdoXG4gICd0b0pTT04nLFxuICAnJCR0eXBlb2YnLFxuICAnX19lc01vZHVsZScsXG5dKVxuIl0sIm5hbWVzIjpbImlzRGVmaW5pdGVseUFWYWxpZElkZW50aWZpZXIiLCJkZXNjcmliZVN0cmluZ1Byb3BlcnR5QWNjZXNzIiwidGFyZ2V0IiwicHJvcCIsInRlc3QiLCJKU09OIiwic3RyaW5naWZ5IiwiZGVzY3JpYmVIYXNDaGVja2luZ1N0cmluZ1Byb3BlcnR5Iiwic3RyaW5naWZpZWRQcm9wIiwid2VsbEtub3duUHJvcGVydGllcyIsIlNldCJdLCJtYXBwaW5ncyI6IkFBQUEsNkVBQTZFO0FBQzdFLGlGQUFpRjtBQUNqRiwwRkFBMEY7QUFDMUYsdUZBQXVGO0FBQ3ZGLDJEQUEyRDs7Ozs7O0FBQzNELE1BQU1BLCtCQUErQjtBQUU5QixTQUFTQyw2QkFBNkJDLE1BQWMsRUFBRUMsSUFBWTtJQUN2RSxJQUFJSCw2QkFBNkJJLElBQUksQ0FBQ0QsT0FBTztRQUMzQyxPQUFRLE1BQUlELFNBQU8sTUFBR0MsT0FBSztJQUM3QjtJQUNBLE9BQVEsTUFBSUQsU0FBTyxNQUFHRyxLQUFLQyxTQUFTLENBQUNILFFBQU07QUFDN0M7QUFFTyxTQUFTSSxrQ0FDZEwsTUFBYyxFQUNkQyxJQUFZO0lBRVosTUFBTUssa0JBQWtCSCxLQUFLQyxTQUFTLENBQUNIO0lBQ3ZDLE9BQVEsa0JBQWdCRCxTQUFPLE9BQUlNLGtCQUFnQixVQUFTQSxrQkFBZ0IsU0FBTU4sU0FBTztBQUMzRjtBQUVPLE1BQU1PLHNCQUFzQixJQUFJQyxJQUFJO0lBQ3pDO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUVBLG9CQUFvQjtJQUNwQixjQUFjO0lBQ2Q7SUFDQTtJQUNBO0lBRUEsMEJBQTBCO0lBQzFCLGNBQWM7SUFDZDtJQUVBLHNCQUFzQjtJQUN0QjtJQUNBO0lBRUEsMkJBQTJCO0lBQzNCLGNBQWM7SUFDZDtJQUNBO0lBQ0E7Q0FDRCxFQUFDIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDkzNywgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL3NlcnZlci9yZXF1ZXN0L3V0aWxzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFN0YXRpY0dlbkJhaWxvdXRFcnJvciB9IGZyb20gJy4uLy4uL2NsaWVudC9jb21wb25lbnRzL3N0YXRpYy1nZW5lcmF0aW9uLWJhaWxvdXQnXG5pbXBvcnQgeyBhZnRlclRhc2tBc3luY1N0b3JhZ2UgfSBmcm9tICcuLi9hcHAtcmVuZGVyL2FmdGVyLXRhc2stYXN5bmMtc3RvcmFnZS5leHRlcm5hbCdcbmltcG9ydCB0eXBlIHsgV29ya1N0b3JlIH0gZnJvbSAnLi4vYXBwLXJlbmRlci93b3JrLWFzeW5jLXN0b3JhZ2UuZXh0ZXJuYWwnXG5cbmV4cG9ydCBmdW5jdGlvbiB0aHJvd1dpdGhTdGF0aWNHZW5lcmF0aW9uQmFpbG91dEVycm9yKFxuICByb3V0ZTogc3RyaW5nLFxuICBleHByZXNzaW9uOiBzdHJpbmdcbik6IG5ldmVyIHtcbiAgdGhyb3cgbmV3IFN0YXRpY0dlbkJhaWxvdXRFcnJvcihcbiAgICBgUm91dGUgJHtyb3V0ZX0gY291bGRuJ3QgYmUgcmVuZGVyZWQgc3RhdGljYWxseSBiZWNhdXNlIGl0IHVzZWQgJHtleHByZXNzaW9ufS4gU2VlIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYnVpbGRpbmcteW91ci1hcHBsaWNhdGlvbi9yZW5kZXJpbmcvc3RhdGljLWFuZC1keW5hbWljI2R5bmFtaWMtcmVuZGVyaW5nYFxuICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0aHJvd1dpdGhTdGF0aWNHZW5lcmF0aW9uQmFpbG91dEVycm9yV2l0aER5bmFtaWNFcnJvcihcbiAgcm91dGU6IHN0cmluZyxcbiAgZXhwcmVzc2lvbjogc3RyaW5nXG4pOiBuZXZlciB7XG4gIHRocm93IG5ldyBTdGF0aWNHZW5CYWlsb3V0RXJyb3IoXG4gICAgYFJvdXRlICR7cm91dGV9IHdpdGggXFxgZHluYW1pYyA9IFwiZXJyb3JcIlxcYCBjb3VsZG4ndCBiZSByZW5kZXJlZCBzdGF0aWNhbGx5IGJlY2F1c2UgaXQgdXNlZCAke2V4cHJlc3Npb259LiBTZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL3JlbmRlcmluZy9zdGF0aWMtYW5kLWR5bmFtaWMjZHluYW1pYy1yZW5kZXJpbmdgXG4gIClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRocm93Rm9yU2VhcmNoUGFyYW1zQWNjZXNzSW5Vc2VDYWNoZShcbiAgd29ya1N0b3JlOiBXb3JrU3RvcmUsXG4gIGNvbnN0cnVjdG9yT3B0OiBGdW5jdGlvblxuKTogbmV2ZXIge1xuICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcbiAgICBgUm91dGUgJHt3b3JrU3RvcmUucm91dGV9IHVzZWQgXCJzZWFyY2hQYXJhbXNcIiBpbnNpZGUgXCJ1c2UgY2FjaGVcIi4gQWNjZXNzaW5nIER5bmFtaWMgZGF0YSBzb3VyY2VzIGluc2lkZSBhIGNhY2hlIHNjb3BlIGlzIG5vdCBzdXBwb3J0ZWQuIElmIHlvdSBuZWVkIHRoaXMgZGF0YSBpbnNpZGUgYSBjYWNoZWQgZnVuY3Rpb24gdXNlIFwic2VhcmNoUGFyYW1zXCIgb3V0c2lkZSBvZiB0aGUgY2FjaGVkIGZ1bmN0aW9uIGFuZCBwYXNzIHRoZSByZXF1aXJlZCBkeW5hbWljIGRhdGEgaW4gYXMgYW4gYXJndW1lbnQuIFNlZSBtb3JlIGluZm8gaGVyZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbmV4dC1yZXF1ZXN0LWluLXVzZS1jYWNoZWBcbiAgKVxuXG4gIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVycm9yLCBjb25zdHJ1Y3Rvck9wdClcbiAgd29ya1N0b3JlLmludmFsaWREeW5hbWljVXNhZ2VFcnJvciA/Pz0gZXJyb3JcblxuICB0aHJvdyBlcnJvclxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNSZXF1ZXN0QVBJQ2FsbGFibGVJbnNpZGVBZnRlcigpIHtcbiAgY29uc3QgYWZ0ZXJUYXNrU3RvcmUgPSBhZnRlclRhc2tBc3luY1N0b3JhZ2UuZ2V0U3RvcmUoKVxuICByZXR1cm4gYWZ0ZXJUYXNrU3RvcmU/LnJvb3RUYXNrU3Bhd25QaGFzZSA9PT0gJ2FjdGlvbidcbn1cbiJdLCJuYW1lcyI6WyJTdGF0aWNHZW5CYWlsb3V0RXJyb3IiLCJhZnRlclRhc2tBc3luY1N0b3JhZ2UiLCJ0aHJvd1dpdGhTdGF0aWNHZW5lcmF0aW9uQmFpbG91dEVycm9yIiwicm91dGUiLCJleHByZXNzaW9uIiwidGhyb3dXaXRoU3RhdGljR2VuZXJhdGlvbkJhaWxvdXRFcnJvcldpdGhEeW5hbWljRXJyb3IiLCJ0aHJvd0ZvclNlYXJjaFBhcmFtc0FjY2Vzc0luVXNlQ2FjaGUiLCJ3b3JrU3RvcmUiLCJjb25zdHJ1Y3Rvck9wdCIsImVycm9yIiwiRXJyb3IiLCJjYXB0dXJlU3RhY2tUcmFjZSIsImludmFsaWREeW5hbWljVXNhZ2VFcnJvciIsImlzUmVxdWVzdEFQSUNhbGxhYmxlSW5zaWRlQWZ0ZXIiLCJhZnRlclRhc2tTdG9yZSIsImdldFN0b3JlIiwicm9vdFRhc2tTcGF3blBoYXNlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxTQUFTQSxxQkFBcUIsUUFBUSxvREFBbUQ7QUFDekYsU0FBU0MscUJBQXFCLFFBQVEsa0RBQWlEOzs7QUFHaEYsU0FBU0Msc0NBQ2RDLEtBQWEsRUFDYkMsVUFBa0I7SUFFbEIsTUFBTSxPQUFBLGNBRUwsQ0FGSyxtTUFBSUosd0JBQUFBLENBQ1IsQ0FBQyxNQUFNLEVBQUVHLE1BQU0saURBQWlELEVBQUVDLFdBQVcsMEhBQTBILENBQUMsR0FEcE0scUJBQUE7ZUFBQTtvQkFBQTtzQkFBQTtJQUVOO0FBQ0Y7QUFFTyxTQUFTQyxzREFDZEYsS0FBYSxFQUNiQyxVQUFrQjtJQUVsQixNQUFNLE9BQUEsY0FFTCxDQUZLLG1NQUFJSix3QkFBQUEsQ0FDUixDQUFDLE1BQU0sRUFBRUcsTUFBTSw0RUFBNEUsRUFBRUMsV0FBVywwSEFBMEgsQ0FBQyxHQUQvTixxQkFBQTtlQUFBO29CQUFBO3NCQUFBO0lBRU47QUFDRjtBQUVPLFNBQVNFLHFDQUNkQyxTQUFvQixFQUNwQkMsY0FBd0I7SUFFeEIsTUFBTUMsUUFBUSxPQUFBLGNBRWIsQ0FGYSxJQUFJQyxNQUNoQixDQUFDLE1BQU0sRUFBRUgsVUFBVUosS0FBSyxDQUFDLG9WQUFvVixDQUFDLEdBRGxXLHFCQUFBO2VBQUE7b0JBQUE7c0JBQUE7SUFFZDtJQUVBTyxNQUFNQyxpQkFBaUIsQ0FBQ0YsT0FBT0Q7SUFDL0JELFVBQVVLLHdCQUF3QixLQUFLSDtJQUV2QyxNQUFNQTtBQUNSO0FBRU8sU0FBU0k7SUFDZCxNQUFNQyx1U0FBaUJiLHdCQUFBQSxDQUFzQmMsUUFBUTtJQUNyRCxPQUFPRCxDQUFBQSxrQkFBQUEsT0FBQUEsS0FBQUEsSUFBQUEsZUFBZ0JFLGtCQUFrQixNQUFLO0FBQ2hEIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDk3OSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL3NlcnZlci9yZXF1ZXN0L3NlYXJjaC1wYXJhbXMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBXb3JrU3RvcmUgfSBmcm9tICcuLi9hcHAtcmVuZGVyL3dvcmstYXN5bmMtc3RvcmFnZS5leHRlcm5hbCdcblxuaW1wb3J0IHsgUmVmbGVjdEFkYXB0ZXIgfSBmcm9tICcuLi93ZWIvc3BlYy1leHRlbnNpb24vYWRhcHRlcnMvcmVmbGVjdCdcbmltcG9ydCB7XG4gIHRocm93VG9JbnRlcnJ1cHRTdGF0aWNHZW5lcmF0aW9uLFxuICBwb3N0cG9uZVdpdGhUcmFja2luZyxcbiAgdHJhY2tEeW5hbWljRGF0YUluRHluYW1pY1JlbmRlcixcbiAgYW5ub3RhdGVEeW5hbWljQWNjZXNzLFxuICB0cmFja1N5bmNocm9ub3VzUmVxdWVzdERhdGFBY2Nlc3NJbkRldixcbn0gZnJvbSAnLi4vYXBwLXJlbmRlci9keW5hbWljLXJlbmRlcmluZydcblxuaW1wb3J0IHtcbiAgd29ya1VuaXRBc3luY1N0b3JhZ2UsXG4gIHR5cGUgUHJlcmVuZGVyU3RvcmUsXG4gIHR5cGUgUHJlcmVuZGVyU3RvcmVMZWdhY3ksXG4gIHR5cGUgUHJlcmVuZGVyU3RvcmVQUFIsXG4gIHR5cGUgUHJlcmVuZGVyU3RvcmVNb2Rlcm4sXG59IGZyb20gJy4uL2FwcC1yZW5kZXIvd29yay11bml0LWFzeW5jLXN0b3JhZ2UuZXh0ZXJuYWwnXG5pbXBvcnQgeyBJbnZhcmlhbnRFcnJvciB9IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvaW52YXJpYW50LWVycm9yJ1xuaW1wb3J0IHsgbWFrZUhhbmdpbmdQcm9taXNlIH0gZnJvbSAnLi4vZHluYW1pYy1yZW5kZXJpbmctdXRpbHMnXG5pbXBvcnQgeyBjcmVhdGVEZWR1cGVkQnlDYWxsc2l0ZVNlcnZlckVycm9yTG9nZ2VyRGV2IH0gZnJvbSAnLi4vY3JlYXRlLWRlZHVwZWQtYnktY2FsbHNpdGUtc2VydmVyLWVycm9yLWxvZ2dlcidcbmltcG9ydCB7XG4gIGRlc2NyaWJlU3RyaW5nUHJvcGVydHlBY2Nlc3MsXG4gIGRlc2NyaWJlSGFzQ2hlY2tpbmdTdHJpbmdQcm9wZXJ0eSxcbiAgd2VsbEtub3duUHJvcGVydGllcyxcbn0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi91dGlscy9yZWZsZWN0LXV0aWxzJ1xuaW1wb3J0IHtcbiAgdGhyb3dXaXRoU3RhdGljR2VuZXJhdGlvbkJhaWxvdXRFcnJvcldpdGhEeW5hbWljRXJyb3IsXG4gIHRocm93Rm9yU2VhcmNoUGFyYW1zQWNjZXNzSW5Vc2VDYWNoZSxcbn0gZnJvbSAnLi91dGlscydcbmltcG9ydCB7IHNjaGVkdWxlSW1tZWRpYXRlIH0gZnJvbSAnLi4vLi4vbGliL3NjaGVkdWxlcidcblxuZXhwb3J0IHR5cGUgU2VhcmNoUGFyYW1zID0geyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfCBzdHJpbmdbXSB8IHVuZGVmaW5lZCB9XG5cbi8qKlxuICogSW4gdGhpcyB2ZXJzaW9uIG9mIE5leHQuanMgdGhlIGBwYXJhbXNgIHByb3AgcGFzc2VkIHRvIExheW91dHMsIFBhZ2VzLCBhbmQgb3RoZXIgU2VnbWVudHMgaXMgYSBQcm9taXNlLlxuICogSG93ZXZlciB0byBmYWNpbGl0YXRlIG1pZ3JhdGlvbiB0byB0aGlzIG5ldyBQcm9taXNlIHR5cGUgeW91IGNhbiBjdXJyZW50bHkgc3RpbGwgYWNjZXNzIHBhcmFtcyBkaXJlY3RseSBvbiB0aGUgUHJvbWlzZSBpbnN0YW5jZSBwYXNzZWQgdG8gdGhlc2UgU2VnbWVudHMuXG4gKiBUaGUgYFVuc2FmZVVud3JhcHBlZFNlYXJjaFBhcmFtc2AgdHlwZSBpcyBhdmFpbGFibGUgaWYgeW91IG5lZWQgdG8gdGVtcG9yYXJpbHkgYWNjZXNzIHRoZSB1bmRlcmx5aW5nIHBhcmFtcyB3aXRob3V0IGZpcnN0IGF3YWl0aW5nIG9yIGB1c2VgaW5nIHRoZSBQcm9taXNlLlxuICpcbiAqIEluIGEgZnV0dXJlIHZlcnNpb24gb2YgTmV4dC5qcyB0aGUgYHBhcmFtc2AgcHJvcCB3aWxsIGJlIGEgcGxhaW4gUHJvbWlzZSBhbmQgdGhpcyB0eXBlIHdpbGwgYmUgcmVtb3ZlZC5cbiAqXG4gKiBUeXBpY2FsbHkgaW5zdGFuY2VzIG9mIGBwYXJhbXNgIGNhbiBiZSB1cGRhdGVkIGF1dG9tYXRpY2FsbHkgdG8gYmUgdHJlYXRlZCBhcyBhIFByb21pc2UgYnkgYSBjb2RlbW9kIHB1Ymxpc2hlZCBhbG9uZ3NpZGUgdGhpcyBOZXh0LmpzIHZlcnNpb24gaG93ZXZlciBpZiB5b3VcbiAqIGhhdmUgbm90IHlldCBydW4gdGhlIGNvZGVtb2Qgb2YgdGhlIGNvZGVtb2QgY2Fubm90IGRldGVjdCBjZXJ0YWluIGluc3RhbmNlcyBvZiBgcGFyYW1zYCB1c2FnZSB5b3Ugc2hvdWxkIGZpcnN0IHRyeSB0byByZWZhY3RvciB5b3VyIGNvZGUgdG8gYXdhaXQgYHBhcmFtc2AuXG4gKlxuICogSWYgcmVmYWN0b3JpbmcgaXMgbm90IHBvc3NpYmxlIGJ1dCB5b3Ugc3RpbGwgd2FudCB0byBiZSBhYmxlIHRvIGFjY2VzcyBwYXJhbXMgZGlyZWN0bHkgd2l0aG91dCB0eXBlc2NyaXB0IGVycm9ycyB5b3UgY2FuIGNhc3QgdGhlIHBhcmFtcyBQcm9taXNlIHRvIHRoaXMgdHlwZVxuICpcbiAqIGBgYHRzeFxuICogdHlwZSBQcm9wcyA9IHsgc2VhcmNoUGFyYW1zOiBQcm9taXNlPHsgZm9vOiBzdHJpbmcgfT4gfVxuICpcbiAqIGV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIFBhZ2UocHJvcHM6IFByb3BzKSB7XG4gKiAgY29uc3QgeyBzZWFyY2hQYXJhbXMgfSA9IChwcm9wcy5zZWFyY2hQYXJhbXMgYXMgdW5rbm93biBhcyBVbnNhZmVVbndyYXBwZWRTZWFyY2hQYXJhbXM8dHlwZW9mIHByb3BzLnNlYXJjaFBhcmFtcz4pXG4gKiAgcmV0dXJuIC4uLlxuICogfVxuICogYGBgXG4gKlxuICogVGhpcyB0eXBlIGlzIG1hcmtlZCBkZXByZWNhdGVkIHRvIGhlbHAgaWRlbnRpZnkgaXQgYXMgdGFyZ2V0IGZvciByZWZhY3RvcmluZyBhd2F5LlxuICpcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmV4cG9ydCB0eXBlIFVuc2FmZVVud3JhcHBlZFNlYXJjaFBhcmFtczxQPiA9XG4gIFAgZXh0ZW5kcyBQcm9taXNlPGluZmVyIFU+ID8gT21pdDxVLCAndGhlbicgfCAnc3RhdHVzJyB8ICd2YWx1ZSc+IDogbmV2ZXJcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNlYXJjaFBhcmFtc0Zyb21DbGllbnQoXG4gIHVuZGVybHlpbmdTZWFyY2hQYXJhbXM6IFNlYXJjaFBhcmFtcyxcbiAgd29ya1N0b3JlOiBXb3JrU3RvcmVcbikge1xuICBjb25zdCB3b3JrVW5pdFN0b3JlID0gd29ya1VuaXRBc3luY1N0b3JhZ2UuZ2V0U3RvcmUoKVxuICBpZiAod29ya1VuaXRTdG9yZSkge1xuICAgIHN3aXRjaCAod29ya1VuaXRTdG9yZS50eXBlKSB7XG4gICAgICBjYXNlICdwcmVyZW5kZXInOlxuICAgICAgY2FzZSAncHJlcmVuZGVyLWNsaWVudCc6XG4gICAgICBjYXNlICdwcmVyZW5kZXItcHByJzpcbiAgICAgIGNhc2UgJ3ByZXJlbmRlci1sZWdhY3knOlxuICAgICAgICByZXR1cm4gY3JlYXRlUHJlcmVuZGVyU2VhcmNoUGFyYW1zKHdvcmtTdG9yZSwgd29ya1VuaXRTdG9yZSlcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAvLyBmYWxsdGhyb3VnaFxuICAgIH1cbiAgfVxuICByZXR1cm4gY3JlYXRlUmVuZGVyU2VhcmNoUGFyYW1zKHVuZGVybHlpbmdTZWFyY2hQYXJhbXMsIHdvcmtTdG9yZSlcbn1cblxuLy8gZ2VuZXJhdGVNZXRhZGF0YSBhbHdheXMgcnVucyBpbiBSU0MgY29udGV4dCBzbyBpdCBpcyBlcXVpdmFsZW50IHRvIGEgU2VydmVyIFBhZ2UgQ29tcG9uZW50XG5leHBvcnQgY29uc3QgY3JlYXRlU2VydmVyU2VhcmNoUGFyYW1zRm9yTWV0YWRhdGEgPVxuICBjcmVhdGVTZXJ2ZXJTZWFyY2hQYXJhbXNGb3JTZXJ2ZXJQYWdlXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTZXJ2ZXJTZWFyY2hQYXJhbXNGb3JTZXJ2ZXJQYWdlKFxuICB1bmRlcmx5aW5nU2VhcmNoUGFyYW1zOiBTZWFyY2hQYXJhbXMsXG4gIHdvcmtTdG9yZTogV29ya1N0b3JlXG4pOiBQcm9taXNlPFNlYXJjaFBhcmFtcz4ge1xuICBjb25zdCB3b3JrVW5pdFN0b3JlID0gd29ya1VuaXRBc3luY1N0b3JhZ2UuZ2V0U3RvcmUoKVxuICBpZiAod29ya1VuaXRTdG9yZSkge1xuICAgIHN3aXRjaCAod29ya1VuaXRTdG9yZS50eXBlKSB7XG4gICAgICBjYXNlICdwcmVyZW5kZXInOlxuICAgICAgY2FzZSAncHJlcmVuZGVyLWNsaWVudCc6XG4gICAgICBjYXNlICdwcmVyZW5kZXItcHByJzpcbiAgICAgIGNhc2UgJ3ByZXJlbmRlci1sZWdhY3knOlxuICAgICAgICByZXR1cm4gY3JlYXRlUHJlcmVuZGVyU2VhcmNoUGFyYW1zKHdvcmtTdG9yZSwgd29ya1VuaXRTdG9yZSlcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAvLyBmYWxsdGhyb3VnaFxuICAgIH1cbiAgfVxuICByZXR1cm4gY3JlYXRlUmVuZGVyU2VhcmNoUGFyYW1zKHVuZGVybHlpbmdTZWFyY2hQYXJhbXMsIHdvcmtTdG9yZSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVByZXJlbmRlclNlYXJjaFBhcmFtc0ZvckNsaWVudFBhZ2UoXG4gIHdvcmtTdG9yZTogV29ya1N0b3JlXG4pOiBQcm9taXNlPFNlYXJjaFBhcmFtcz4ge1xuICBpZiAod29ya1N0b3JlLmZvcmNlU3RhdGljKSB7XG4gICAgLy8gV2hlbiB1c2luZyBmb3JjZVN0YXRpYyB3ZSBvdmVycmlkZSBhbGwgb3RoZXIgbG9naWMgYW5kIGFsd2F5cyBqdXN0IHJldHVybiBhbiBlbXB0eVxuICAgIC8vIGRpY3Rpb25hcnkgb2JqZWN0LlxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe30pXG4gIH1cblxuICBjb25zdCBwcmVyZW5kZXJTdG9yZSA9IHdvcmtVbml0QXN5bmNTdG9yYWdlLmdldFN0b3JlKClcbiAgaWYgKFxuICAgIHByZXJlbmRlclN0b3JlICYmXG4gICAgKHByZXJlbmRlclN0b3JlLnR5cGUgPT09ICdwcmVyZW5kZXInIHx8XG4gICAgICBwcmVyZW5kZXJTdG9yZS50eXBlID09PSAncHJlcmVuZGVyLWNsaWVudCcpXG4gICkge1xuICAgIC8vIGR5bmFtaWNJTyBQcmVyZW5kZXJcbiAgICAvLyBXZSdyZSBwcmVyZW5kZXJpbmcgaW4gYSBtb2RlIHRoYXQgYWJvcnRzIChkeW5hbWljSU8pIGFuZCBzaG91bGQgc3RhbGxcbiAgICAvLyB0aGUgcHJvbWlzZSB0byBlbnN1cmUgdGhlIFJTQyBzaWRlIGlzIGNvbnNpZGVyZWQgZHluYW1pY1xuICAgIHJldHVybiBtYWtlSGFuZ2luZ1Byb21pc2UocHJlcmVuZGVyU3RvcmUucmVuZGVyU2lnbmFsLCAnYHNlYXJjaFBhcmFtc2AnKVxuICB9XG4gIC8vIFdlJ3JlIHByZXJlbmRlcmluZyBpbiBhIG1vZGUgdGhhdCBkb2VzIG5vdCBhYm9ydHMuIFdlIHJlc29sdmUgdGhlIHByb21pc2Ugd2l0aG91dFxuICAvLyBhbnkgdHJhY2tpbmcgYmVjYXVzZSB3ZSdyZSBqdXN0IHRyYW5zcG9ydGluZyBhIHZhbHVlIGZyb20gc2VydmVyIHRvIGNsaWVudCB3aGVyZSB0aGUgdHJhY2tpbmdcbiAgLy8gd2lsbCBiZSBhcHBsaWVkLlxuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHt9KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVQcmVyZW5kZXJTZWFyY2hQYXJhbXMoXG4gIHdvcmtTdG9yZTogV29ya1N0b3JlLFxuICBwcmVyZW5kZXJTdG9yZTogUHJlcmVuZGVyU3RvcmVcbik6IFByb21pc2U8U2VhcmNoUGFyYW1zPiB7XG4gIGlmICh3b3JrU3RvcmUuZm9yY2VTdGF0aWMpIHtcbiAgICAvLyBXaGVuIHVzaW5nIGZvcmNlU3RhdGljIHdlIG92ZXJyaWRlIGFsbCBvdGhlciBsb2dpYyBhbmQgYWx3YXlzIGp1c3QgcmV0dXJuIGFuIGVtcHR5XG4gICAgLy8gZGljdGlvbmFyeSBvYmplY3QuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7fSlcbiAgfVxuXG4gIHN3aXRjaCAocHJlcmVuZGVyU3RvcmUudHlwZSkge1xuICAgIGNhc2UgJ3ByZXJlbmRlcic6XG4gICAgY2FzZSAncHJlcmVuZGVyLWNsaWVudCc6XG4gICAgICAvLyBXZSBhcmUgaW4gYSBkeW5hbWljSU8gKFBQUiBvciBvdGhlcndpc2UpIHByZXJlbmRlclxuICAgICAgcmV0dXJuIG1ha2VIYW5naW5nU2VhcmNoUGFyYW1zKHByZXJlbmRlclN0b3JlKVxuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBUaGUgcmVtYWluaW5nIGNhc2VzIGFyZSBwcmVyZW5kZXItcHByIGFuZCBwcmVyZW5kZXItbGVnYWN5XG4gICAgICAvLyBXZSBhcmUgaW4gYSBsZWdhY3kgc3RhdGljIGdlbmVyYXRpb24gYW5kIG5lZWQgdG8gaW50ZXJydXB0IHRoZSBwcmVyZW5kZXJcbiAgICAgIC8vIHdoZW4gc2VhcmNoIHBhcmFtcyBhcmUgYWNjZXNzZWQuXG4gICAgICByZXR1cm4gbWFrZUVycm9yaW5nRXhvdGljU2VhcmNoUGFyYW1zKHdvcmtTdG9yZSwgcHJlcmVuZGVyU3RvcmUpXG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlUmVuZGVyU2VhcmNoUGFyYW1zKFxuICB1bmRlcmx5aW5nU2VhcmNoUGFyYW1zOiBTZWFyY2hQYXJhbXMsXG4gIHdvcmtTdG9yZTogV29ya1N0b3JlXG4pOiBQcm9taXNlPFNlYXJjaFBhcmFtcz4ge1xuICBpZiAod29ya1N0b3JlLmZvcmNlU3RhdGljKSB7XG4gICAgLy8gV2hlbiB1c2luZyBmb3JjZVN0YXRpYyB3ZSBvdmVycmlkZSBhbGwgb3RoZXIgbG9naWMgYW5kIGFsd2F5cyBqdXN0IHJldHVybiBhbiBlbXB0eVxuICAgIC8vIGRpY3Rpb25hcnkgb2JqZWN0LlxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe30pXG4gIH0gZWxzZSB7XG4gICAgaWYgKFxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiZcbiAgICAgICF3b3JrU3RvcmUuaXNQcmVmZXRjaFJlcXVlc3RcbiAgICApIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfRFlOQU1JQ19JTykge1xuICAgICAgICByZXR1cm4gbWFrZVVudHJhY2tlZFNlYXJjaFBhcmFtc1dpdGhEZXZXYXJuaW5ncyhcbiAgICAgICAgICB1bmRlcmx5aW5nU2VhcmNoUGFyYW1zLFxuICAgICAgICAgIHdvcmtTdG9yZVxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYWtlRHluYW1pY2FsbHlUcmFja2VkRXhvdGljU2VhcmNoUGFyYW1zV2l0aERldldhcm5pbmdzKFxuICAgICAgICB1bmRlcmx5aW5nU2VhcmNoUGFyYW1zLFxuICAgICAgICB3b3JrU3RvcmVcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9EWU5BTUlDX0lPKSB7XG4gICAgICAgIHJldHVybiBtYWtlVW50cmFja2VkU2VhcmNoUGFyYW1zKHVuZGVybHlpbmdTZWFyY2hQYXJhbXMpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYWtlVW50cmFja2VkRXhvdGljU2VhcmNoUGFyYW1zKHVuZGVybHlpbmdTZWFyY2hQYXJhbXMsIHdvcmtTdG9yZSlcbiAgICB9XG4gIH1cbn1cblxuaW50ZXJmYWNlIENhY2hlTGlmZXRpbWUge31cbmNvbnN0IENhY2hlZFNlYXJjaFBhcmFtcyA9IG5ldyBXZWFrTWFwPENhY2hlTGlmZXRpbWUsIFByb21pc2U8U2VhcmNoUGFyYW1zPj4oKVxuXG5jb25zdCBDYWNoZWRTZWFyY2hQYXJhbXNGb3JVc2VDYWNoZSA9IG5ldyBXZWFrTWFwPFxuICBDYWNoZUxpZmV0aW1lLFxuICBQcm9taXNlPFNlYXJjaFBhcmFtcz5cbj4oKVxuXG5mdW5jdGlvbiBtYWtlSGFuZ2luZ1NlYXJjaFBhcmFtcyhcbiAgcHJlcmVuZGVyU3RvcmU6IFByZXJlbmRlclN0b3JlTW9kZXJuXG4pOiBQcm9taXNlPFNlYXJjaFBhcmFtcz4ge1xuICBjb25zdCBjYWNoZWRTZWFyY2hQYXJhbXMgPSBDYWNoZWRTZWFyY2hQYXJhbXMuZ2V0KHByZXJlbmRlclN0b3JlKVxuICBpZiAoY2FjaGVkU2VhcmNoUGFyYW1zKSB7XG4gICAgcmV0dXJuIGNhY2hlZFNlYXJjaFBhcmFtc1xuICB9XG5cbiAgY29uc3QgcHJvbWlzZSA9IG1ha2VIYW5naW5nUHJvbWlzZTxTZWFyY2hQYXJhbXM+KFxuICAgIHByZXJlbmRlclN0b3JlLnJlbmRlclNpZ25hbCxcbiAgICAnYHNlYXJjaFBhcmFtc2AnXG4gIClcblxuICBjb25zdCBwcm94aWVkUHJvbWlzZSA9IG5ldyBQcm94eShwcm9taXNlLCB7XG4gICAgZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICAgIGlmIChPYmplY3QuaGFzT3duKHByb21pc2UsIHByb3ApKSB7XG4gICAgICAgIC8vIFRoZSBwcm9taXNlIGhhcyB0aGlzIHByb3BlcnR5IGRpcmVjdGx5LiB3ZSBtdXN0IHJldHVybiBpdC5cbiAgICAgICAgLy8gV2Uga25vdyBpdCBpc24ndCBhIGR5bmFtaWMgYWNjZXNzIGJlY2F1c2UgaXQgY2FuIG9ubHkgYmUgc29tZXRoaW5nXG4gICAgICAgIC8vIHRoYXQgd2FzIHByZXZpb3VzbHkgd3JpdHRlbiB0byB0aGUgcHJvbWlzZSBhbmQgdGh1cyBub3QgYW4gdW5kZXJseWluZyBzZWFyY2hQYXJhbSB2YWx1ZVxuICAgICAgICByZXR1cm4gUmVmbGVjdEFkYXB0ZXIuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpXG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAocHJvcCkge1xuICAgICAgICBjYXNlICd0aGVuJzoge1xuICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPVxuICAgICAgICAgICAgJ2Bhd2FpdCBzZWFyY2hQYXJhbXNgLCBgc2VhcmNoUGFyYW1zLnRoZW5gLCBvciBzaW1pbGFyJ1xuICAgICAgICAgIGFubm90YXRlRHluYW1pY0FjY2VzcyhleHByZXNzaW9uLCBwcmVyZW5kZXJTdG9yZSlcbiAgICAgICAgICByZXR1cm4gUmVmbGVjdEFkYXB0ZXIuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpXG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnc3RhdHVzJzoge1xuICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPVxuICAgICAgICAgICAgJ2B1c2Uoc2VhcmNoUGFyYW1zKWAsIGBzZWFyY2hQYXJhbXMuc3RhdHVzYCwgb3Igc2ltaWxhcidcbiAgICAgICAgICBhbm5vdGF0ZUR5bmFtaWNBY2Nlc3MoZXhwcmVzc2lvbiwgcHJlcmVuZGVyU3RvcmUpXG4gICAgICAgICAgcmV0dXJuIFJlZmxlY3RBZGFwdGVyLmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKVxuICAgICAgICB9XG5cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIHJldHVybiBSZWZsZWN0QWRhcHRlci5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcilcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gIH0pXG5cbiAgQ2FjaGVkU2VhcmNoUGFyYW1zLnNldChwcmVyZW5kZXJTdG9yZSwgcHJveGllZFByb21pc2UpXG4gIHJldHVybiBwcm94aWVkUHJvbWlzZVxufVxuXG5mdW5jdGlvbiBtYWtlRXJyb3JpbmdFeG90aWNTZWFyY2hQYXJhbXMoXG4gIHdvcmtTdG9yZTogV29ya1N0b3JlLFxuICBwcmVyZW5kZXJTdG9yZTogUHJlcmVuZGVyU3RvcmVMZWdhY3kgfCBQcmVyZW5kZXJTdG9yZVBQUlxuKTogUHJvbWlzZTxTZWFyY2hQYXJhbXM+IHtcbiAgY29uc3QgY2FjaGVkU2VhcmNoUGFyYW1zID0gQ2FjaGVkU2VhcmNoUGFyYW1zLmdldCh3b3JrU3RvcmUpXG4gIGlmIChjYWNoZWRTZWFyY2hQYXJhbXMpIHtcbiAgICByZXR1cm4gY2FjaGVkU2VhcmNoUGFyYW1zXG4gIH1cblxuICBjb25zdCB1bmRlcmx5aW5nU2VhcmNoUGFyYW1zID0ge31cbiAgLy8gRm9yIHNlYXJjaCBwYXJhbXMgd2UgZG9uJ3QgY29uc3RydWN0IGEgUmVhY3RQcm9taXNlIGJlY2F1c2Ugd2Ugd2FudCB0byBpbnRlcnJ1cHRcbiAgLy8gcmVuZGVyaW5nIG9uIGFueSBwcm9wZXJ0eSBhY2Nlc3MgdGhhdCB3YXMgbm90IHNldCBmcm9tIG91dHNpZGUgYW5kIHNvIHdlIG9ubHkgd2FudFxuICAvLyB0byBoYXZlIHByb3BlcnRpZXMgbGlrZSB2YWx1ZSBhbmQgc3RhdHVzIGlmIFJlYWN0IHNldHMgdGhlbS5cbiAgY29uc3QgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSh1bmRlcmx5aW5nU2VhcmNoUGFyYW1zKVxuXG4gIGNvbnN0IHByb3hpZWRQcm9taXNlID0gbmV3IFByb3h5KHByb21pc2UsIHtcbiAgICBnZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgaWYgKE9iamVjdC5oYXNPd24ocHJvbWlzZSwgcHJvcCkpIHtcbiAgICAgICAgLy8gVGhlIHByb21pc2UgaGFzIHRoaXMgcHJvcGVydHkgZGlyZWN0bHkuIHdlIG11c3QgcmV0dXJuIGl0LlxuICAgICAgICAvLyBXZSBrbm93IGl0IGlzbid0IGEgZHluYW1pYyBhY2Nlc3MgYmVjYXVzZSBpdCBjYW4gb25seSBiZSBzb21ldGhpbmdcbiAgICAgICAgLy8gdGhhdCB3YXMgcHJldmlvdXNseSB3cml0dGVuIHRvIHRoZSBwcm9taXNlIGFuZCB0aHVzIG5vdCBhbiB1bmRlcmx5aW5nIHNlYXJjaFBhcmFtIHZhbHVlXG4gICAgICAgIHJldHVybiBSZWZsZWN0QWRhcHRlci5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcilcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChwcm9wKSB7XG4gICAgICAgIGNhc2UgJ3RoZW4nOiB7XG4gICAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9XG4gICAgICAgICAgICAnYGF3YWl0IHNlYXJjaFBhcmFtc2AsIGBzZWFyY2hQYXJhbXMudGhlbmAsIG9yIHNpbWlsYXInXG4gICAgICAgICAgaWYgKHdvcmtTdG9yZS5keW5hbWljU2hvdWxkRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93V2l0aFN0YXRpY0dlbmVyYXRpb25CYWlsb3V0RXJyb3JXaXRoRHluYW1pY0Vycm9yKFxuICAgICAgICAgICAgICB3b3JrU3RvcmUucm91dGUsXG4gICAgICAgICAgICAgIGV4cHJlc3Npb25cbiAgICAgICAgICAgIClcbiAgICAgICAgICB9IGVsc2UgaWYgKHByZXJlbmRlclN0b3JlLnR5cGUgPT09ICdwcmVyZW5kZXItcHByJykge1xuICAgICAgICAgICAgLy8gUFBSIFByZXJlbmRlciAobm8gZHluYW1pY0lPKVxuICAgICAgICAgICAgcG9zdHBvbmVXaXRoVHJhY2tpbmcoXG4gICAgICAgICAgICAgIHdvcmtTdG9yZS5yb3V0ZSxcbiAgICAgICAgICAgICAgZXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgcHJlcmVuZGVyU3RvcmUuZHluYW1pY1RyYWNraW5nXG4gICAgICAgICAgICApXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIExlZ2FjeSBQcmVyZW5kZXJcbiAgICAgICAgICAgIHRocm93VG9JbnRlcnJ1cHRTdGF0aWNHZW5lcmF0aW9uKFxuICAgICAgICAgICAgICBleHByZXNzaW9uLFxuICAgICAgICAgICAgICB3b3JrU3RvcmUsXG4gICAgICAgICAgICAgIHByZXJlbmRlclN0b3JlXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3N0YXR1cyc6IHtcbiAgICAgICAgICBjb25zdCBleHByZXNzaW9uID1cbiAgICAgICAgICAgICdgdXNlKHNlYXJjaFBhcmFtcylgLCBgc2VhcmNoUGFyYW1zLnN0YXR1c2AsIG9yIHNpbWlsYXInXG4gICAgICAgICAgaWYgKHdvcmtTdG9yZS5keW5hbWljU2hvdWxkRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93V2l0aFN0YXRpY0dlbmVyYXRpb25CYWlsb3V0RXJyb3JXaXRoRHluYW1pY0Vycm9yKFxuICAgICAgICAgICAgICB3b3JrU3RvcmUucm91dGUsXG4gICAgICAgICAgICAgIGV4cHJlc3Npb25cbiAgICAgICAgICAgIClcbiAgICAgICAgICB9IGVsc2UgaWYgKHByZXJlbmRlclN0b3JlLnR5cGUgPT09ICdwcmVyZW5kZXItcHByJykge1xuICAgICAgICAgICAgLy8gUFBSIFByZXJlbmRlciAobm8gZHluYW1pY0lPKVxuICAgICAgICAgICAgcG9zdHBvbmVXaXRoVHJhY2tpbmcoXG4gICAgICAgICAgICAgIHdvcmtTdG9yZS5yb3V0ZSxcbiAgICAgICAgICAgICAgZXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgcHJlcmVuZGVyU3RvcmUuZHluYW1pY1RyYWNraW5nXG4gICAgICAgICAgICApXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIExlZ2FjeSBQcmVyZW5kZXJcbiAgICAgICAgICAgIHRocm93VG9JbnRlcnJ1cHRTdGF0aWNHZW5lcmF0aW9uKFxuICAgICAgICAgICAgICBleHByZXNzaW9uLFxuICAgICAgICAgICAgICB3b3JrU3RvcmUsXG4gICAgICAgICAgICAgIHByZXJlbmRlclN0b3JlXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdzdHJpbmcnICYmICF3ZWxsS25vd25Qcm9wZXJ0aWVzLmhhcyhwcm9wKSkge1xuICAgICAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IGRlc2NyaWJlU3RyaW5nUHJvcGVydHlBY2Nlc3MoXG4gICAgICAgICAgICAgICdzZWFyY2hQYXJhbXMnLFxuICAgICAgICAgICAgICBwcm9wXG4gICAgICAgICAgICApXG4gICAgICAgICAgICBpZiAod29ya1N0b3JlLmR5bmFtaWNTaG91bGRFcnJvcikge1xuICAgICAgICAgICAgICB0aHJvd1dpdGhTdGF0aWNHZW5lcmF0aW9uQmFpbG91dEVycm9yV2l0aER5bmFtaWNFcnJvcihcbiAgICAgICAgICAgICAgICB3b3JrU3RvcmUucm91dGUsXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvblxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByZXJlbmRlclN0b3JlLnR5cGUgPT09ICdwcmVyZW5kZXItcHByJykge1xuICAgICAgICAgICAgICAvLyBQUFIgUHJlcmVuZGVyIChubyBkeW5hbWljSU8pXG4gICAgICAgICAgICAgIHBvc3Rwb25lV2l0aFRyYWNraW5nKFxuICAgICAgICAgICAgICAgIHdvcmtTdG9yZS5yb3V0ZSxcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uLFxuICAgICAgICAgICAgICAgIHByZXJlbmRlclN0b3JlLmR5bmFtaWNUcmFja2luZ1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBMZWdhY3kgUHJlcmVuZGVyXG4gICAgICAgICAgICAgIHRocm93VG9JbnRlcnJ1cHRTdGF0aWNHZW5lcmF0aW9uKFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgd29ya1N0b3JlLFxuICAgICAgICAgICAgICAgIHByZXJlbmRlclN0b3JlXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFJlZmxlY3RBZGFwdGVyLmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBoYXModGFyZ2V0LCBwcm9wKSB7XG4gICAgICAvLyBXZSBkb24ndCBleHBlY3Qga2V5IGNoZWNraW5nIHRvIGJlIHVzZWQgZXhjZXB0IGZvciB0ZXN0aW5nIHRoZSBleGlzdGVuY2Ugb2ZcbiAgICAgIC8vIHNlYXJjaFBhcmFtcyBzbyB3ZSBtYWtlIGFsbCBoYXMgdGVzdHMgdHJpZ2dlciBkeW5hbWljLiB0aGlzIG1lYW5zIHRoYXQgYHByb21pc2UudGhlbmBcbiAgICAgIC8vIGNhbiByZXNvbHZlIHRvIHRoZSB0aGVuIGZ1bmN0aW9uIG9uIHRoZSBQcm9taXNlIHByb3RvdHlwZSBidXQgJ3RoZW4nIGluIHByb21pc2Ugd2lsbCBhc3N1bWVcbiAgICAgIC8vIHlvdSBhcmUgdGVzdGluZyB3aGV0aGVyIHRoZSBzZWFyY2hQYXJhbXMgaGFzIGEgJ3RoZW4nIHByb3BlcnR5LlxuICAgICAgaWYgKHR5cGVvZiBwcm9wID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCBleHByZXNzaW9uID0gZGVzY3JpYmVIYXNDaGVja2luZ1N0cmluZ1Byb3BlcnR5KFxuICAgICAgICAgICdzZWFyY2hQYXJhbXMnLFxuICAgICAgICAgIHByb3BcbiAgICAgICAgKVxuICAgICAgICBpZiAod29ya1N0b3JlLmR5bmFtaWNTaG91bGRFcnJvcikge1xuICAgICAgICAgIHRocm93V2l0aFN0YXRpY0dlbmVyYXRpb25CYWlsb3V0RXJyb3JXaXRoRHluYW1pY0Vycm9yKFxuICAgICAgICAgICAgd29ya1N0b3JlLnJvdXRlLFxuICAgICAgICAgICAgZXhwcmVzc2lvblxuICAgICAgICAgIClcbiAgICAgICAgfSBlbHNlIGlmIChwcmVyZW5kZXJTdG9yZS50eXBlID09PSAncHJlcmVuZGVyLXBwcicpIHtcbiAgICAgICAgICAvLyBQUFIgUHJlcmVuZGVyIChubyBkeW5hbWljSU8pXG4gICAgICAgICAgcG9zdHBvbmVXaXRoVHJhY2tpbmcoXG4gICAgICAgICAgICB3b3JrU3RvcmUucm91dGUsXG4gICAgICAgICAgICBleHByZXNzaW9uLFxuICAgICAgICAgICAgcHJlcmVuZGVyU3RvcmUuZHluYW1pY1RyYWNraW5nXG4gICAgICAgICAgKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIExlZ2FjeSBQcmVyZW5kZXJcbiAgICAgICAgICB0aHJvd1RvSW50ZXJydXB0U3RhdGljR2VuZXJhdGlvbihcbiAgICAgICAgICAgIGV4cHJlc3Npb24sXG4gICAgICAgICAgICB3b3JrU3RvcmUsXG4gICAgICAgICAgICBwcmVyZW5kZXJTdG9yZVxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIHJldHVybiBSZWZsZWN0QWRhcHRlci5oYXModGFyZ2V0LCBwcm9wKVxuICAgIH0sXG4gICAgb3duS2V5cygpIHtcbiAgICAgIGNvbnN0IGV4cHJlc3Npb24gPVxuICAgICAgICAnYHsuLi5zZWFyY2hQYXJhbXN9YCwgYE9iamVjdC5rZXlzKHNlYXJjaFBhcmFtcylgLCBvciBzaW1pbGFyJ1xuICAgICAgaWYgKHdvcmtTdG9yZS5keW5hbWljU2hvdWxkRXJyb3IpIHtcbiAgICAgICAgdGhyb3dXaXRoU3RhdGljR2VuZXJhdGlvbkJhaWxvdXRFcnJvcldpdGhEeW5hbWljRXJyb3IoXG4gICAgICAgICAgd29ya1N0b3JlLnJvdXRlLFxuICAgICAgICAgIGV4cHJlc3Npb25cbiAgICAgICAgKVxuICAgICAgfSBlbHNlIGlmIChwcmVyZW5kZXJTdG9yZS50eXBlID09PSAncHJlcmVuZGVyLXBwcicpIHtcbiAgICAgICAgLy8gUFBSIFByZXJlbmRlciAobm8gZHluYW1pY0lPKVxuICAgICAgICBwb3N0cG9uZVdpdGhUcmFja2luZyhcbiAgICAgICAgICB3b3JrU3RvcmUucm91dGUsXG4gICAgICAgICAgZXhwcmVzc2lvbixcbiAgICAgICAgICBwcmVyZW5kZXJTdG9yZS5keW5hbWljVHJhY2tpbmdcbiAgICAgICAgKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTGVnYWN5IFByZXJlbmRlclxuICAgICAgICB0aHJvd1RvSW50ZXJydXB0U3RhdGljR2VuZXJhdGlvbihleHByZXNzaW9uLCB3b3JrU3RvcmUsIHByZXJlbmRlclN0b3JlKVxuICAgICAgfVxuICAgIH0sXG4gIH0pXG5cbiAgQ2FjaGVkU2VhcmNoUGFyYW1zLnNldCh3b3JrU3RvcmUsIHByb3hpZWRQcm9taXNlKVxuICByZXR1cm4gcHJveGllZFByb21pc2Vcbn1cblxuLyoqXG4gKiBUaGlzIGlzIGEgdmFyaWF0aW9uIG9mIGBtYWtlRXJyb3JpbmdFeG90aWNTZWFyY2hQYXJhbXNgIHRoYXQgYWx3YXlzIHRocm93cyBhblxuICogZXJyb3Igb24gYWNjZXNzLCBiZWNhdXNlIGFjY2Vzc2luZyBzZWFyY2hQYXJhbXMgaW5zaWRlIG9mIGBcInVzZSBjYWNoZVwiYCBpc1xuICogbm90IGFsbG93ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlRXJyb3JpbmdFeG90aWNTZWFyY2hQYXJhbXNGb3JVc2VDYWNoZShcbiAgd29ya1N0b3JlOiBXb3JrU3RvcmVcbik6IFByb21pc2U8U2VhcmNoUGFyYW1zPiB7XG4gIGNvbnN0IGNhY2hlZFNlYXJjaFBhcmFtcyA9IENhY2hlZFNlYXJjaFBhcmFtc0ZvclVzZUNhY2hlLmdldCh3b3JrU3RvcmUpXG4gIGlmIChjYWNoZWRTZWFyY2hQYXJhbXMpIHtcbiAgICByZXR1cm4gY2FjaGVkU2VhcmNoUGFyYW1zXG4gIH1cblxuICBjb25zdCBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHt9KVxuXG4gIGNvbnN0IHByb3hpZWRQcm9taXNlID0gbmV3IFByb3h5KHByb21pc2UsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG4gICAgICBpZiAoT2JqZWN0Lmhhc093bihwcm9taXNlLCBwcm9wKSkge1xuICAgICAgICAvLyBUaGUgcHJvbWlzZSBoYXMgdGhpcyBwcm9wZXJ0eSBkaXJlY3RseS4gd2UgbXVzdCByZXR1cm4gaXQuIFdlIGtub3cgaXRcbiAgICAgICAgLy8gaXNuJ3QgYSBkeW5hbWljIGFjY2VzcyBiZWNhdXNlIGl0IGNhbiBvbmx5IGJlIHNvbWV0aGluZyB0aGF0IHdhc1xuICAgICAgICAvLyBwcmV2aW91c2x5IHdyaXR0ZW4gdG8gdGhlIHByb21pc2UgYW5kIHRodXMgbm90IGFuIHVuZGVybHlpbmdcbiAgICAgICAgLy8gc2VhcmNoUGFyYW0gdmFsdWVcbiAgICAgICAgcmV0dXJuIFJlZmxlY3RBZGFwdGVyLmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKVxuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgIHR5cGVvZiBwcm9wID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAocHJvcCA9PT0gJ3RoZW4nIHx8ICF3ZWxsS25vd25Qcm9wZXJ0aWVzLmhhcyhwcm9wKSlcbiAgICAgICkge1xuICAgICAgICB0aHJvd0ZvclNlYXJjaFBhcmFtc0FjY2Vzc0luVXNlQ2FjaGUod29ya1N0b3JlLCBnZXQpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBSZWZsZWN0QWRhcHRlci5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcilcbiAgICB9LFxuICAgIGhhczogZnVuY3Rpb24gaGFzKHRhcmdldCwgcHJvcCkge1xuICAgICAgLy8gV2UgZG9uJ3QgZXhwZWN0IGtleSBjaGVja2luZyB0byBiZSB1c2VkIGV4Y2VwdCBmb3IgdGVzdGluZyB0aGUgZXhpc3RlbmNlIG9mXG4gICAgICAvLyBzZWFyY2hQYXJhbXMgc28gd2UgbWFrZSBhbGwgaGFzIHRlc3RzIHRocm93IGFuIGVycm9yLiB0aGlzIG1lYW5zIHRoYXQgYHByb21pc2UudGhlbmBcbiAgICAgIC8vIGNhbiByZXNvbHZlIHRvIHRoZSB0aGVuIGZ1bmN0aW9uIG9uIHRoZSBQcm9taXNlIHByb3RvdHlwZSBidXQgJ3RoZW4nIGluIHByb21pc2Ugd2lsbCBhc3N1bWVcbiAgICAgIC8vIHlvdSBhcmUgdGVzdGluZyB3aGV0aGVyIHRoZSBzZWFyY2hQYXJhbXMgaGFzIGEgJ3RoZW4nIHByb3BlcnR5LlxuICAgICAgaWYgKFxuICAgICAgICB0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgKHByb3AgPT09ICd0aGVuJyB8fCAhd2VsbEtub3duUHJvcGVydGllcy5oYXMocHJvcCkpXG4gICAgICApIHtcbiAgICAgICAgdGhyb3dGb3JTZWFyY2hQYXJhbXNBY2Nlc3NJblVzZUNhY2hlKHdvcmtTdG9yZSwgaGFzKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gUmVmbGVjdEFkYXB0ZXIuaGFzKHRhcmdldCwgcHJvcClcbiAgICB9LFxuICAgIG93bktleXM6IGZ1bmN0aW9uIG93bktleXMoKSB7XG4gICAgICB0aHJvd0ZvclNlYXJjaFBhcmFtc0FjY2Vzc0luVXNlQ2FjaGUod29ya1N0b3JlLCBvd25LZXlzKVxuICAgIH0sXG4gIH0pXG5cbiAgQ2FjaGVkU2VhcmNoUGFyYW1zRm9yVXNlQ2FjaGUuc2V0KHdvcmtTdG9yZSwgcHJveGllZFByb21pc2UpXG4gIHJldHVybiBwcm94aWVkUHJvbWlzZVxufVxuXG5mdW5jdGlvbiBtYWtlVW50cmFja2VkRXhvdGljU2VhcmNoUGFyYW1zKFxuICB1bmRlcmx5aW5nU2VhcmNoUGFyYW1zOiBTZWFyY2hQYXJhbXMsXG4gIHN0b3JlOiBXb3JrU3RvcmVcbik6IFByb21pc2U8U2VhcmNoUGFyYW1zPiB7XG4gIGNvbnN0IGNhY2hlZFNlYXJjaFBhcmFtcyA9IENhY2hlZFNlYXJjaFBhcmFtcy5nZXQodW5kZXJseWluZ1NlYXJjaFBhcmFtcylcbiAgaWYgKGNhY2hlZFNlYXJjaFBhcmFtcykge1xuICAgIHJldHVybiBjYWNoZWRTZWFyY2hQYXJhbXNcbiAgfVxuXG4gIC8vIFdlIGRvbid0IHVzZSBtYWtlUmVzb2x2ZWRSZWFjdFByb21pc2UgaGVyZSBiZWNhdXNlIHNlYXJjaFBhcmFtc1xuICAvLyBzdXBwb3J0cyBjb3B5aW5nIHdpdGggc3ByZWFkIGFuZCB3ZSBkb24ndCB3YW50IHRvIHVubmVjZXNzYXJpbHlcbiAgLy8gaW5zdHJ1bWVudCB0aGUgcHJvbWlzZSB3aXRoIHNwcmVhZGFibGUgcHJvcGVydGllcyBvZiBSZWFjdFByb21pc2UuXG4gIGNvbnN0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUodW5kZXJseWluZ1NlYXJjaFBhcmFtcylcbiAgQ2FjaGVkU2VhcmNoUGFyYW1zLnNldCh1bmRlcmx5aW5nU2VhcmNoUGFyYW1zLCBwcm9taXNlKVxuXG4gIE9iamVjdC5rZXlzKHVuZGVybHlpbmdTZWFyY2hQYXJhbXMpLmZvckVhY2goKHByb3ApID0+IHtcbiAgICBpZiAoIXdlbGxLbm93blByb3BlcnRpZXMuaGFzKHByb3ApKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgcHJvcCwge1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgY29uc3Qgd29ya1VuaXRTdG9yZSA9IHdvcmtVbml0QXN5bmNTdG9yYWdlLmdldFN0b3JlKClcbiAgICAgICAgICB0cmFja0R5bmFtaWNEYXRhSW5EeW5hbWljUmVuZGVyKHN0b3JlLCB3b3JrVW5pdFN0b3JlKVxuICAgICAgICAgIHJldHVybiB1bmRlcmx5aW5nU2VhcmNoUGFyYW1zW3Byb3BdXG4gICAgICAgIH0sXG4gICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBwcm9wLCB7XG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB9KVxuICAgIH1cbiAgfSlcblxuICByZXR1cm4gcHJvbWlzZVxufVxuXG5mdW5jdGlvbiBtYWtlVW50cmFja2VkU2VhcmNoUGFyYW1zKFxuICB1bmRlcmx5aW5nU2VhcmNoUGFyYW1zOiBTZWFyY2hQYXJhbXNcbik6IFByb21pc2U8U2VhcmNoUGFyYW1zPiB7XG4gIGNvbnN0IGNhY2hlZFNlYXJjaFBhcmFtcyA9IENhY2hlZFNlYXJjaFBhcmFtcy5nZXQodW5kZXJseWluZ1NlYXJjaFBhcmFtcylcbiAgaWYgKGNhY2hlZFNlYXJjaFBhcmFtcykge1xuICAgIHJldHVybiBjYWNoZWRTZWFyY2hQYXJhbXNcbiAgfVxuXG4gIGNvbnN0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUodW5kZXJseWluZ1NlYXJjaFBhcmFtcylcbiAgQ2FjaGVkU2VhcmNoUGFyYW1zLnNldCh1bmRlcmx5aW5nU2VhcmNoUGFyYW1zLCBwcm9taXNlKVxuXG4gIHJldHVybiBwcm9taXNlXG59XG5cbmZ1bmN0aW9uIG1ha2VEeW5hbWljYWxseVRyYWNrZWRFeG90aWNTZWFyY2hQYXJhbXNXaXRoRGV2V2FybmluZ3MoXG4gIHVuZGVybHlpbmdTZWFyY2hQYXJhbXM6IFNlYXJjaFBhcmFtcyxcbiAgc3RvcmU6IFdvcmtTdG9yZVxuKTogUHJvbWlzZTxTZWFyY2hQYXJhbXM+IHtcbiAgY29uc3QgY2FjaGVkU2VhcmNoUGFyYW1zID0gQ2FjaGVkU2VhcmNoUGFyYW1zLmdldCh1bmRlcmx5aW5nU2VhcmNoUGFyYW1zKVxuICBpZiAoY2FjaGVkU2VhcmNoUGFyYW1zKSB7XG4gICAgcmV0dXJuIGNhY2hlZFNlYXJjaFBhcmFtc1xuICB9XG5cbiAgY29uc3QgcHJveGllZFByb3BlcnRpZXMgPSBuZXcgU2V0PHN0cmluZz4oKVxuICBjb25zdCB1bnByb3hpZWRQcm9wZXJ0aWVzOiBBcnJheTxzdHJpbmc+ID0gW11cblxuICAvLyBXZSBoYXZlIGFuIHVuZm9ydHVuYXRlIHNlcXVlbmNlIG9mIGV2ZW50cyB0aGF0IHJlcXVpcmVzIHRoaXMgaW5pdGlhbGl6YXRpb24gbG9naWMuIFdlIHdhbnQgdG8gaW5zdHJ1bWVudCB0aGUgdW5kZXJseWluZ1xuICAvLyBzZWFyY2hQYXJhbXMgb2JqZWN0IHRvIGRldGVjdCBpZiB5b3UgYXJlIGFjY2Vzc2luZyB2YWx1ZXMgaW4gZGV2LiBUaGlzIGlzIHVzZWQgZm9yIHdhcm5pbmdzIGFuZCBmb3IgdGhpbmdzIGxpa2UgdGhlIHN0YXRpYyBwcmVyZW5kZXJcbiAgLy8gaW5kaWNhdG9yLiBIb3dldmVyIHdoZW4gd2UgcGFzcyB0aGlzIHByb3h5IHRvIG91ciBQcm9taXNlLnJlc29sdmUoKSBiZWxvdyB0aGUgVk0gY2hlY2tzIGlmIHRoZSByZXNvbHZlZCB2YWx1ZSBpcyBhIHByb21pc2UgYnkgbG9va2luZ1xuICAvLyBhdCB0aGUgYC50aGVuYCBwcm9wZXJ0eS4gVG8gb3VyIGR5bmFtaWMgdHJhY2tpbmcgbG9naWMgdGhpcyBpcyBpbmRpc3Rpbmd1aXNoYWJsZSBmcm9tIGEgYHRoZW5gIHNlYXJjaFBhcmFtIGFuZCBzbyB3ZSB3b3VsZCBub3JtYWxseSB0cmlnZ2VyXG4gIC8vIGR5bmFtaWMgdHJhY2tpbmcuIEhvd2V2ZXIgd2Uga25vdyB0aGF0IHRoaXMgLnRoZW4gaXMgbm90IHJlYWwgZHluYW1pYyBhY2Nlc3MsIGl0J3MganVzdCBob3cgdGhlbmFibGVzIHJlc29sdmUgaW4gc2VxdWVuY2UuIFNvIHdlIGludHJvZHVjZVxuICAvLyB0aGlzIGluaXRpYWxpemF0aW9uIGNvbmNlcHQgc28gd2Ugb21pdCB0aGUgZHluYW1pYyBjaGVjayB1bnRpbCBhZnRlciB3ZSd2ZSBjb25zdHJ1Y3RlZCBvdXIgcmVzb2x2ZWQgcHJvbWlzZS5cbiAgbGV0IHByb21pc2VJbml0aWFsaXplZCA9IGZhbHNlXG4gIGNvbnN0IHByb3hpZWRVbmRlcmx5aW5nID0gbmV3IFByb3h5KHVuZGVybHlpbmdTZWFyY2hQYXJhbXMsIHtcbiAgICBnZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgaWYgKHR5cGVvZiBwcm9wID09PSAnc3RyaW5nJyAmJiBwcm9taXNlSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgaWYgKHN0b3JlLmR5bmFtaWNTaG91bGRFcnJvcikge1xuICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBkZXNjcmliZVN0cmluZ1Byb3BlcnR5QWNjZXNzKCdzZWFyY2hQYXJhbXMnLCBwcm9wKVxuICAgICAgICAgIHRocm93V2l0aFN0YXRpY0dlbmVyYXRpb25CYWlsb3V0RXJyb3JXaXRoRHluYW1pY0Vycm9yKFxuICAgICAgICAgICAgc3RvcmUucm91dGUsXG4gICAgICAgICAgICBleHByZXNzaW9uXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdvcmtVbml0U3RvcmUgPSB3b3JrVW5pdEFzeW5jU3RvcmFnZS5nZXRTdG9yZSgpXG4gICAgICAgIHRyYWNrRHluYW1pY0RhdGFJbkR5bmFtaWNSZW5kZXIoc3RvcmUsIHdvcmtVbml0U3RvcmUpXG4gICAgICB9XG4gICAgICByZXR1cm4gUmVmbGVjdEFkYXB0ZXIuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpXG4gICAgfSxcbiAgICBoYXModGFyZ2V0LCBwcm9wKSB7XG4gICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChzdG9yZS5keW5hbWljU2hvdWxkRXJyb3IpIHtcbiAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gZGVzY3JpYmVIYXNDaGVja2luZ1N0cmluZ1Byb3BlcnR5KFxuICAgICAgICAgICAgJ3NlYXJjaFBhcmFtcycsXG4gICAgICAgICAgICBwcm9wXG4gICAgICAgICAgKVxuICAgICAgICAgIHRocm93V2l0aFN0YXRpY0dlbmVyYXRpb25CYWlsb3V0RXJyb3JXaXRoRHluYW1pY0Vycm9yKFxuICAgICAgICAgICAgc3RvcmUucm91dGUsXG4gICAgICAgICAgICBleHByZXNzaW9uXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wKVxuICAgIH0sXG4gICAgb3duS2V5cyh0YXJnZXQpIHtcbiAgICAgIGlmIChzdG9yZS5keW5hbWljU2hvdWxkRXJyb3IpIHtcbiAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9XG4gICAgICAgICAgJ2B7Li4uc2VhcmNoUGFyYW1zfWAsIGBPYmplY3Qua2V5cyhzZWFyY2hQYXJhbXMpYCwgb3Igc2ltaWxhcidcbiAgICAgICAgdGhyb3dXaXRoU3RhdGljR2VuZXJhdGlvbkJhaWxvdXRFcnJvcldpdGhEeW5hbWljRXJyb3IoXG4gICAgICAgICAgc3RvcmUucm91dGUsXG4gICAgICAgICAgZXhwcmVzc2lvblxuICAgICAgICApXG4gICAgICB9XG4gICAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKHRhcmdldClcbiAgICB9LFxuICB9KVxuXG4gIC8vIFdlIGRvbid0IHVzZSBtYWtlUmVzb2x2ZWRSZWFjdFByb21pc2UgaGVyZSBiZWNhdXNlIHNlYXJjaFBhcmFtc1xuICAvLyBzdXBwb3J0cyBjb3B5aW5nIHdpdGggc3ByZWFkIGFuZCB3ZSBkb24ndCB3YW50IHRvIHVubmVjZXNzYXJpbHlcbiAgLy8gaW5zdHJ1bWVudCB0aGUgcHJvbWlzZSB3aXRoIHNwcmVhZGFibGUgcHJvcGVydGllcyBvZiBSZWFjdFByb21pc2UuXG4gIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZTxTZWFyY2hQYXJhbXM+KChyZXNvbHZlKSA9PlxuICAgIHNjaGVkdWxlSW1tZWRpYXRlKCgpID0+IHJlc29sdmUodW5kZXJseWluZ1NlYXJjaFBhcmFtcykpXG4gIClcbiAgcHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICBwcm9taXNlSW5pdGlhbGl6ZWQgPSB0cnVlXG4gIH0pXG5cbiAgT2JqZWN0LmtleXModW5kZXJseWluZ1NlYXJjaFBhcmFtcykuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgIGlmICh3ZWxsS25vd25Qcm9wZXJ0aWVzLmhhcyhwcm9wKSkge1xuICAgICAgLy8gVGhlc2UgcHJvcGVydGllcyBjYW5ub3QgYmUgc2hhZG93ZWQgYmVjYXVzZSB0aGV5IG5lZWQgdG8gYmUgdGhlXG4gICAgICAvLyB0cnVlIHVuZGVybHlpbmcgdmFsdWUgZm9yIFByb21pc2VzIHRvIHdvcmsgY29ycmVjdGx5IGF0IHJ1bnRpbWVcbiAgICAgIHVucHJveGllZFByb3BlcnRpZXMucHVzaChwcm9wKVxuICAgIH0gZWxzZSB7XG4gICAgICBwcm94aWVkUHJvcGVydGllcy5hZGQocHJvcClcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBwcm9wLCB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gcHJveGllZFVuZGVybHlpbmdbcHJvcF1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0KG5ld1ZhbHVlKSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIHByb3AsIHtcbiAgICAgICAgICAgIHZhbHVlOiBuZXdWYWx1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB9KVxuICAgIH1cbiAgfSlcblxuICBjb25zdCBwcm94aWVkUHJvbWlzZSA9IG5ldyBQcm94eShwcm9taXNlLCB7XG4gICAgZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICAgIGlmIChwcm9wID09PSAndGhlbicgJiYgc3RvcmUuZHluYW1pY1Nob3VsZEVycm9yKSB7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSAnYHNlYXJjaFBhcmFtcy50aGVuYCdcbiAgICAgICAgdGhyb3dXaXRoU3RhdGljR2VuZXJhdGlvbkJhaWxvdXRFcnJvcldpdGhEeW5hbWljRXJyb3IoXG4gICAgICAgICAgc3RvcmUucm91dGUsXG4gICAgICAgICAgZXhwcmVzc2lvblxuICAgICAgICApXG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhd2VsbEtub3duUHJvcGVydGllcy5oYXMocHJvcCkgJiZcbiAgICAgICAgICAocHJveGllZFByb3BlcnRpZXMuaGFzKHByb3ApIHx8XG4gICAgICAgICAgICAvLyBXZSBhcmUgYWNjZXNzaW5nIGEgcHJvcGVydHkgdGhhdCBkb2Vzbid0IGV4aXN0IG9uIHRoZSBwcm9taXNlIG5vclxuICAgICAgICAgICAgLy8gdGhlIHVuZGVybHlpbmcgc2VhcmNoUGFyYW1zLlxuICAgICAgICAgICAgUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wKSA9PT0gZmFsc2UpXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBkZXNjcmliZVN0cmluZ1Byb3BlcnR5QWNjZXNzKCdzZWFyY2hQYXJhbXMnLCBwcm9wKVxuICAgICAgICAgIHN5bmNJT0RldihzdG9yZS5yb3V0ZSwgZXhwcmVzc2lvbilcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFJlZmxlY3RBZGFwdGVyLmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKVxuICAgIH0sXG4gICAgc2V0KHRhcmdldCwgcHJvcCwgdmFsdWUsIHJlY2VpdmVyKSB7XG4gICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHByb3hpZWRQcm9wZXJ0aWVzLmRlbGV0ZShwcm9wKVxuICAgICAgfVxuICAgICAgcmV0dXJuIFJlZmxlY3Quc2V0KHRhcmdldCwgcHJvcCwgdmFsdWUsIHJlY2VpdmVyKVxuICAgIH0sXG4gICAgaGFzKHRhcmdldCwgcHJvcCkge1xuICAgICAgaWYgKHR5cGVvZiBwcm9wID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgIXdlbGxLbm93blByb3BlcnRpZXMuaGFzKHByb3ApICYmXG4gICAgICAgICAgKHByb3hpZWRQcm9wZXJ0aWVzLmhhcyhwcm9wKSB8fFxuICAgICAgICAgICAgLy8gV2UgYXJlIGFjY2Vzc2luZyBhIHByb3BlcnR5IHRoYXQgZG9lc24ndCBleGlzdCBvbiB0aGUgcHJvbWlzZSBub3JcbiAgICAgICAgICAgIC8vIHRoZSB1bmRlcmx5aW5nIHNlYXJjaFBhcmFtcy5cbiAgICAgICAgICAgIFJlZmxlY3QuaGFzKHRhcmdldCwgcHJvcCkgPT09IGZhbHNlKVxuICAgICAgICApIHtcbiAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gZGVzY3JpYmVIYXNDaGVja2luZ1N0cmluZ1Byb3BlcnR5KFxuICAgICAgICAgICAgJ3NlYXJjaFBhcmFtcycsXG4gICAgICAgICAgICBwcm9wXG4gICAgICAgICAgKVxuICAgICAgICAgIHN5bmNJT0RldihzdG9yZS5yb3V0ZSwgZXhwcmVzc2lvbilcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFJlZmxlY3QuaGFzKHRhcmdldCwgcHJvcClcbiAgICB9LFxuICAgIG93bktleXModGFyZ2V0KSB7XG4gICAgICBjb25zdCBleHByZXNzaW9uID0gJ2BPYmplY3Qua2V5cyhzZWFyY2hQYXJhbXMpYCBvciBzaW1pbGFyJ1xuICAgICAgc3luY0lPRGV2KHN0b3JlLnJvdXRlLCBleHByZXNzaW9uLCB1bnByb3hpZWRQcm9wZXJ0aWVzKVxuICAgICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpXG4gICAgfSxcbiAgfSlcblxuICBDYWNoZWRTZWFyY2hQYXJhbXMuc2V0KHVuZGVybHlpbmdTZWFyY2hQYXJhbXMsIHByb3hpZWRQcm9taXNlKVxuICByZXR1cm4gcHJveGllZFByb21pc2Vcbn1cblxuLy8gU2ltaWxhciB0byBgbWFrZUR5bmFtaWNhbGx5VHJhY2tlZEV4b3RpY1NlYXJjaFBhcmFtc1dpdGhEZXZXYXJuaW5nc2AsIGJ1dFxuLy8ganVzdCBsb2dnaW5nIHRoZSBzeW5jIGFjY2VzcyB3aXRob3V0IGFjdHVhbGx5IGRlZmluaW5nIHRoZSBzZWFyY2ggcGFyYW1zIG9uXG4vLyB0aGUgcHJvbWlzZS5cbmZ1bmN0aW9uIG1ha2VVbnRyYWNrZWRTZWFyY2hQYXJhbXNXaXRoRGV2V2FybmluZ3MoXG4gIHVuZGVybHlpbmdTZWFyY2hQYXJhbXM6IFNlYXJjaFBhcmFtcyxcbiAgc3RvcmU6IFdvcmtTdG9yZVxuKTogUHJvbWlzZTxTZWFyY2hQYXJhbXM+IHtcbiAgY29uc3QgY2FjaGVkU2VhcmNoUGFyYW1zID0gQ2FjaGVkU2VhcmNoUGFyYW1zLmdldCh1bmRlcmx5aW5nU2VhcmNoUGFyYW1zKVxuICBpZiAoY2FjaGVkU2VhcmNoUGFyYW1zKSB7XG4gICAgcmV0dXJuIGNhY2hlZFNlYXJjaFBhcmFtc1xuICB9XG5cbiAgY29uc3QgcHJveGllZFByb3BlcnRpZXMgPSBuZXcgU2V0PHN0cmluZz4oKVxuICBjb25zdCB1bnByb3hpZWRQcm9wZXJ0aWVzOiBBcnJheTxzdHJpbmc+ID0gW11cbiAgY29uc3QgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSh1bmRlcmx5aW5nU2VhcmNoUGFyYW1zKVxuXG4gIE9iamVjdC5rZXlzKHVuZGVybHlpbmdTZWFyY2hQYXJhbXMpLmZvckVhY2goKHByb3ApID0+IHtcbiAgICBpZiAod2VsbEtub3duUHJvcGVydGllcy5oYXMocHJvcCkpIHtcbiAgICAgIC8vIFRoZXNlIHByb3BlcnRpZXMgY2Fubm90IGJlIHNoYWRvd2VkIGJlY2F1c2UgdGhleSBuZWVkIHRvIGJlIHRoZVxuICAgICAgLy8gdHJ1ZSB1bmRlcmx5aW5nIHZhbHVlIGZvciBQcm9taXNlcyB0byB3b3JrIGNvcnJlY3RseSBhdCBydW50aW1lXG4gICAgICB1bnByb3hpZWRQcm9wZXJ0aWVzLnB1c2gocHJvcClcbiAgICB9IGVsc2Uge1xuICAgICAgcHJveGllZFByb3BlcnRpZXMuYWRkKHByb3ApXG4gICAgfVxuICB9KVxuXG4gIGNvbnN0IHByb3hpZWRQcm9taXNlID0gbmV3IFByb3h5KHByb21pc2UsIHtcbiAgICBnZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgaWYgKHR5cGVvZiBwcm9wID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgIXdlbGxLbm93blByb3BlcnRpZXMuaGFzKHByb3ApICYmXG4gICAgICAgICAgKHByb3hpZWRQcm9wZXJ0aWVzLmhhcyhwcm9wKSB8fFxuICAgICAgICAgICAgLy8gV2UgYXJlIGFjY2Vzc2luZyBhIHByb3BlcnR5IHRoYXQgZG9lc24ndCBleGlzdCBvbiB0aGUgcHJvbWlzZSBub3JcbiAgICAgICAgICAgIC8vIHRoZSB1bmRlcmx5aW5nIHNlYXJjaFBhcmFtcy5cbiAgICAgICAgICAgIFJlZmxlY3QuaGFzKHRhcmdldCwgcHJvcCkgPT09IGZhbHNlKVxuICAgICAgICApIHtcbiAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gZGVzY3JpYmVTdHJpbmdQcm9wZXJ0eUFjY2Vzcygnc2VhcmNoUGFyYW1zJywgcHJvcClcbiAgICAgICAgICB3YXJuRm9yU3luY0FjY2VzcyhzdG9yZS5yb3V0ZSwgZXhwcmVzc2lvbilcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFJlZmxlY3RBZGFwdGVyLmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKVxuICAgIH0sXG4gICAgc2V0KHRhcmdldCwgcHJvcCwgdmFsdWUsIHJlY2VpdmVyKSB7XG4gICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHByb3hpZWRQcm9wZXJ0aWVzLmRlbGV0ZShwcm9wKVxuICAgICAgfVxuICAgICAgcmV0dXJuIFJlZmxlY3Quc2V0KHRhcmdldCwgcHJvcCwgdmFsdWUsIHJlY2VpdmVyKVxuICAgIH0sXG4gICAgaGFzKHRhcmdldCwgcHJvcCkge1xuICAgICAgaWYgKHR5cGVvZiBwcm9wID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgIXdlbGxLbm93blByb3BlcnRpZXMuaGFzKHByb3ApICYmXG4gICAgICAgICAgKHByb3hpZWRQcm9wZXJ0aWVzLmhhcyhwcm9wKSB8fFxuICAgICAgICAgICAgLy8gV2UgYXJlIGFjY2Vzc2luZyBhIHByb3BlcnR5IHRoYXQgZG9lc24ndCBleGlzdCBvbiB0aGUgcHJvbWlzZSBub3JcbiAgICAgICAgICAgIC8vIHRoZSB1bmRlcmx5aW5nIHNlYXJjaFBhcmFtcy5cbiAgICAgICAgICAgIFJlZmxlY3QuaGFzKHRhcmdldCwgcHJvcCkgPT09IGZhbHNlKVxuICAgICAgICApIHtcbiAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gZGVzY3JpYmVIYXNDaGVja2luZ1N0cmluZ1Byb3BlcnR5KFxuICAgICAgICAgICAgJ3NlYXJjaFBhcmFtcycsXG4gICAgICAgICAgICBwcm9wXG4gICAgICAgICAgKVxuICAgICAgICAgIHdhcm5Gb3JTeW5jQWNjZXNzKHN0b3JlLnJvdXRlLCBleHByZXNzaW9uKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wKVxuICAgIH0sXG4gICAgb3duS2V5cyh0YXJnZXQpIHtcbiAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSAnYE9iamVjdC5rZXlzKHNlYXJjaFBhcmFtcylgIG9yIHNpbWlsYXInXG4gICAgICB3YXJuRm9ySW5jb21wbGV0ZUVudW1lcmF0aW9uKHN0b3JlLnJvdXRlLCBleHByZXNzaW9uLCB1bnByb3hpZWRQcm9wZXJ0aWVzKVxuICAgICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpXG4gICAgfSxcbiAgfSlcblxuICBDYWNoZWRTZWFyY2hQYXJhbXMuc2V0KHVuZGVybHlpbmdTZWFyY2hQYXJhbXMsIHByb3hpZWRQcm9taXNlKVxuICByZXR1cm4gcHJveGllZFByb21pc2Vcbn1cblxuZnVuY3Rpb24gc3luY0lPRGV2KFxuICByb3V0ZTogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICBleHByZXNzaW9uOiBzdHJpbmcsXG4gIG1pc3NpbmdQcm9wZXJ0aWVzPzogQXJyYXk8c3RyaW5nPlxuKSB7XG4gIC8vIEluIGFsbCBjYXNlcyB3ZSB3YXJuIG5vcm1hbGx5XG4gIGlmIChtaXNzaW5nUHJvcGVydGllcyAmJiBtaXNzaW5nUHJvcGVydGllcy5sZW5ndGggPiAwKSB7XG4gICAgd2FybkZvckluY29tcGxldGVFbnVtZXJhdGlvbihyb3V0ZSwgZXhwcmVzc2lvbiwgbWlzc2luZ1Byb3BlcnRpZXMpXG4gIH0gZWxzZSB7XG4gICAgd2FybkZvclN5bmNBY2Nlc3Mocm91dGUsIGV4cHJlc3Npb24pXG4gIH1cblxuICBjb25zdCB3b3JrVW5pdFN0b3JlID0gd29ya1VuaXRBc3luY1N0b3JhZ2UuZ2V0U3RvcmUoKVxuICBpZiAoXG4gICAgd29ya1VuaXRTdG9yZSAmJlxuICAgIHdvcmtVbml0U3RvcmUudHlwZSA9PT0gJ3JlcXVlc3QnICYmXG4gICAgd29ya1VuaXRTdG9yZS5wcmVyZW5kZXJQaGFzZSA9PT0gdHJ1ZVxuICApIHtcbiAgICAvLyBXaGVuIHdlJ3JlIHJlbmRlcmluZyBkeW5hbWljYWxseSBpbiBkZXYgd2UgbmVlZCB0byBhZHZhbmNlIG91dCBvZiB0aGVcbiAgICAvLyBQcmVyZW5kZXIgZW52aXJvbm1lbnQgd2hlbiB3ZSByZWFkIFJlcXVlc3QgZGF0YSBzeW5jaHJvbm91c2x5XG4gICAgY29uc3QgcmVxdWVzdFN0b3JlID0gd29ya1VuaXRTdG9yZVxuICAgIHRyYWNrU3luY2hyb25vdXNSZXF1ZXN0RGF0YUFjY2Vzc0luRGV2KHJlcXVlc3RTdG9yZSlcbiAgfVxufVxuXG5jb25zdCB3YXJuRm9yU3luY0FjY2VzcyA9IGNyZWF0ZURlZHVwZWRCeUNhbGxzaXRlU2VydmVyRXJyb3JMb2dnZXJEZXYoXG4gIGNyZWF0ZVNlYXJjaEFjY2Vzc0Vycm9yXG4pXG5cbmNvbnN0IHdhcm5Gb3JJbmNvbXBsZXRlRW51bWVyYXRpb24gPVxuICBjcmVhdGVEZWR1cGVkQnlDYWxsc2l0ZVNlcnZlckVycm9yTG9nZ2VyRGV2KGNyZWF0ZUluY29tcGxldGVFbnVtZXJhdGlvbkVycm9yKVxuXG5mdW5jdGlvbiBjcmVhdGVTZWFyY2hBY2Nlc3NFcnJvcihcbiAgcm91dGU6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgZXhwcmVzc2lvbjogc3RyaW5nXG4pIHtcbiAgY29uc3QgcHJlZml4ID0gcm91dGUgPyBgUm91dGUgXCIke3JvdXRlfVwiIGAgOiAnVGhpcyByb3V0ZSAnXG4gIHJldHVybiBuZXcgRXJyb3IoXG4gICAgYCR7cHJlZml4fXVzZWQgJHtleHByZXNzaW9ufS4gYCArXG4gICAgICBgXFxgc2VhcmNoUGFyYW1zXFxgIHNob3VsZCBiZSBhd2FpdGVkIGJlZm9yZSB1c2luZyBpdHMgcHJvcGVydGllcy4gYCArXG4gICAgICBgTGVhcm4gbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvc3luYy1keW5hbWljLWFwaXNgXG4gIClcbn1cblxuZnVuY3Rpb24gY3JlYXRlSW5jb21wbGV0ZUVudW1lcmF0aW9uRXJyb3IoXG4gIHJvdXRlOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gIGV4cHJlc3Npb246IHN0cmluZyxcbiAgbWlzc2luZ1Byb3BlcnRpZXM6IEFycmF5PHN0cmluZz5cbikge1xuICBjb25zdCBwcmVmaXggPSByb3V0ZSA/IGBSb3V0ZSBcIiR7cm91dGV9XCIgYCA6ICdUaGlzIHJvdXRlICdcbiAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICBgJHtwcmVmaXh9dXNlZCAke2V4cHJlc3Npb259LiBgICtcbiAgICAgIGBcXGBzZWFyY2hQYXJhbXNcXGAgc2hvdWxkIGJlIGF3YWl0ZWQgYmVmb3JlIHVzaW5nIGl0cyBwcm9wZXJ0aWVzLiBgICtcbiAgICAgIGBUaGUgZm9sbG93aW5nIHByb3BlcnRpZXMgd2VyZSBub3QgYXZhaWxhYmxlIHRocm91Z2ggZW51bWVyYXRpb24gYCArXG4gICAgICBgYmVjYXVzZSB0aGV5IGNvbmZsaWN0IHdpdGggYnVpbHRpbiBvciB3ZWxsLWtub3duIHByb3BlcnR5IG5hbWVzOiBgICtcbiAgICAgIGAke2Rlc2NyaWJlTGlzdE9mUHJvcGVydHlOYW1lcyhtaXNzaW5nUHJvcGVydGllcyl9LiBgICtcbiAgICAgIGBMZWFybiBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9zeW5jLWR5bmFtaWMtYXBpc2BcbiAgKVxufVxuXG5mdW5jdGlvbiBkZXNjcmliZUxpc3RPZlByb3BlcnR5TmFtZXMocHJvcGVydGllczogQXJyYXk8c3RyaW5nPikge1xuICBzd2l0Y2ggKHByb3BlcnRpZXMubGVuZ3RoKSB7XG4gICAgY2FzZSAwOlxuICAgICAgdGhyb3cgbmV3IEludmFyaWFudEVycm9yKFxuICAgICAgICAnRXhwZWN0ZWQgZGVzY3JpYmVMaXN0T2ZQcm9wZXJ0eU5hbWVzIHRvIGJlIGNhbGxlZCB3aXRoIGEgbm9uLWVtcHR5IGxpc3Qgb2Ygc3RyaW5ncy4nXG4gICAgICApXG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIGBcXGAke3Byb3BlcnRpZXNbMF19XFxgYFxuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiBgXFxgJHtwcm9wZXJ0aWVzWzBdfVxcYCBhbmQgXFxgJHtwcm9wZXJ0aWVzWzFdfVxcYGBcbiAgICBkZWZhdWx0OiB7XG4gICAgICBsZXQgZGVzY3JpcHRpb24gPSAnJ1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBkZXNjcmlwdGlvbiArPSBgXFxgJHtwcm9wZXJ0aWVzW2ldfVxcYCwgYFxuICAgICAgfVxuICAgICAgZGVzY3JpcHRpb24gKz0gYCwgYW5kIFxcYCR7cHJvcGVydGllc1twcm9wZXJ0aWVzLmxlbmd0aCAtIDFdfVxcYGBcbiAgICAgIHJldHVybiBkZXNjcmlwdGlvblxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbIlJlZmxlY3RBZGFwdGVyIiwidGhyb3dUb0ludGVycnVwdFN0YXRpY0dlbmVyYXRpb24iLCJwb3N0cG9uZVdpdGhUcmFja2luZyIsInRyYWNrRHluYW1pY0RhdGFJbkR5bmFtaWNSZW5kZXIiLCJhbm5vdGF0ZUR5bmFtaWNBY2Nlc3MiLCJ0cmFja1N5bmNocm9ub3VzUmVxdWVzdERhdGFBY2Nlc3NJbkRldiIsIndvcmtVbml0QXN5bmNTdG9yYWdlIiwiSW52YXJpYW50RXJyb3IiLCJtYWtlSGFuZ2luZ1Byb21pc2UiLCJjcmVhdGVEZWR1cGVkQnlDYWxsc2l0ZVNlcnZlckVycm9yTG9nZ2VyRGV2IiwiZGVzY3JpYmVTdHJpbmdQcm9wZXJ0eUFjY2VzcyIsImRlc2NyaWJlSGFzQ2hlY2tpbmdTdHJpbmdQcm9wZXJ0eSIsIndlbGxLbm93blByb3BlcnRpZXMiLCJ0aHJvd1dpdGhTdGF0aWNHZW5lcmF0aW9uQmFpbG91dEVycm9yV2l0aER5bmFtaWNFcnJvciIsInRocm93Rm9yU2VhcmNoUGFyYW1zQWNjZXNzSW5Vc2VDYWNoZSIsInNjaGVkdWxlSW1tZWRpYXRlIiwiY3JlYXRlU2VhcmNoUGFyYW1zRnJvbUNsaWVudCIsInVuZGVybHlpbmdTZWFyY2hQYXJhbXMiLCJ3b3JrU3RvcmUiLCJ3b3JrVW5pdFN0b3JlIiwiZ2V0U3RvcmUiLCJ0eXBlIiwiY3JlYXRlUHJlcmVuZGVyU2VhcmNoUGFyYW1zIiwiY3JlYXRlUmVuZGVyU2VhcmNoUGFyYW1zIiwiY3JlYXRlU2VydmVyU2VhcmNoUGFyYW1zRm9yTWV0YWRhdGEiLCJjcmVhdGVTZXJ2ZXJTZWFyY2hQYXJhbXNGb3JTZXJ2ZXJQYWdlIiwiY3JlYXRlUHJlcmVuZGVyU2VhcmNoUGFyYW1zRm9yQ2xpZW50UGFnZSIsImZvcmNlU3RhdGljIiwiUHJvbWlzZSIsInJlc29sdmUiLCJwcmVyZW5kZXJTdG9yZSIsInJlbmRlclNpZ25hbCIsIm1ha2VIYW5naW5nU2VhcmNoUGFyYW1zIiwibWFrZUVycm9yaW5nRXhvdGljU2VhcmNoUGFyYW1zIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiaXNQcmVmZXRjaFJlcXVlc3QiLCJfX05FWFRfRFlOQU1JQ19JTyIsIm1ha2VVbnRyYWNrZWRTZWFyY2hQYXJhbXNXaXRoRGV2V2FybmluZ3MiLCJtYWtlRHluYW1pY2FsbHlUcmFja2VkRXhvdGljU2VhcmNoUGFyYW1zV2l0aERldldhcm5pbmdzIiwibWFrZVVudHJhY2tlZFNlYXJjaFBhcmFtcyIsIm1ha2VVbnRyYWNrZWRFeG90aWNTZWFyY2hQYXJhbXMiLCJDYWNoZWRTZWFyY2hQYXJhbXMiLCJXZWFrTWFwIiwiQ2FjaGVkU2VhcmNoUGFyYW1zRm9yVXNlQ2FjaGUiLCJjYWNoZWRTZWFyY2hQYXJhbXMiLCJnZXQiLCJwcm9taXNlIiwicHJveGllZFByb21pc2UiLCJQcm94eSIsInRhcmdldCIsInByb3AiLCJyZWNlaXZlciIsIk9iamVjdCIsImhhc093biIsImV4cHJlc3Npb24iLCJzZXQiLCJkeW5hbWljU2hvdWxkRXJyb3IiLCJyb3V0ZSIsImR5bmFtaWNUcmFja2luZyIsImhhcyIsIm93bktleXMiLCJtYWtlRXJyb3JpbmdFeG90aWNTZWFyY2hQYXJhbXNGb3JVc2VDYWNoZSIsInN0b3JlIiwia2V5cyIsImZvckVhY2giLCJkZWZpbmVQcm9wZXJ0eSIsInZhbHVlIiwid3JpdGFibGUiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwicHJveGllZFByb3BlcnRpZXMiLCJTZXQiLCJ1bnByb3hpZWRQcm9wZXJ0aWVzIiwicHJvbWlzZUluaXRpYWxpemVkIiwicHJveGllZFVuZGVybHlpbmciLCJSZWZsZWN0IiwidGhlbiIsInB1c2giLCJhZGQiLCJuZXdWYWx1ZSIsInN5bmNJT0RldiIsImRlbGV0ZSIsIndhcm5Gb3JTeW5jQWNjZXNzIiwid2FybkZvckluY29tcGxldGVFbnVtZXJhdGlvbiIsIm1pc3NpbmdQcm9wZXJ0aWVzIiwibGVuZ3RoIiwicHJlcmVuZGVyUGhhc2UiLCJyZXF1ZXN0U3RvcmUiLCJjcmVhdGVTZWFyY2hBY2Nlc3NFcnJvciIsImNyZWF0ZUluY29tcGxldGVFbnVtZXJhdGlvbkVycm9yIiwicHJlZml4IiwiRXJyb3IiLCJkZXNjcmliZUxpc3RPZlByb3BlcnR5TmFtZXMiLCJwcm9wZXJ0aWVzIiwiZGVzY3JpcHRpb24iLCJpIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBRUEsU0FBU0EsY0FBYyxRQUFRLHlDQUF3QztBQUN2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QUUsQ0FBQztnQkFDL0QsT0FBT1M7WUFDVDtJQUNGO0FBQ0YiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTUzNywgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL3NlcnZlci9yZXF1ZXN0L3BhcmFtcy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IFdvcmtTdG9yZSB9IGZyb20gJy4uL2FwcC1yZW5kZXIvd29yay1hc3luYy1zdG9yYWdlLmV4dGVybmFsJ1xuaW1wb3J0IHR5cGUgeyBGYWxsYmFja1JvdXRlUGFyYW1zIH0gZnJvbSAnLi9mYWxsYmFjay1wYXJhbXMnXG5cbmltcG9ydCB7IFJlZmxlY3RBZGFwdGVyIH0gZnJvbSAnLi4vd2ViL3NwZWMtZXh0ZW5zaW9uL2FkYXB0ZXJzL3JlZmxlY3QnXG5pbXBvcnQge1xuICB0aHJvd1RvSW50ZXJydXB0U3RhdGljR2VuZXJhdGlvbixcbiAgcG9zdHBvbmVXaXRoVHJhY2tpbmcsXG4gIHRyYWNrU3luY2hyb25vdXNSZXF1ZXN0RGF0YUFjY2Vzc0luRGV2LFxufSBmcm9tICcuLi9hcHAtcmVuZGVyL2R5bmFtaWMtcmVuZGVyaW5nJ1xuXG5pbXBvcnQge1xuICB3b3JrVW5pdEFzeW5jU3RvcmFnZSxcbiAgdHlwZSBQcmVyZW5kZXJTdG9yZSxcbiAgdHlwZSBQcmVyZW5kZXJTdG9yZVBQUixcbiAgdHlwZSBQcmVyZW5kZXJTdG9yZUxlZ2FjeSxcbiAgdHlwZSBQcmVyZW5kZXJTdG9yZU1vZGVybixcbn0gZnJvbSAnLi4vYXBwLXJlbmRlci93b3JrLXVuaXQtYXN5bmMtc3RvcmFnZS5leHRlcm5hbCdcbmltcG9ydCB7IEludmFyaWFudEVycm9yIH0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi9pbnZhcmlhbnQtZXJyb3InXG5pbXBvcnQge1xuICBkZXNjcmliZVN0cmluZ1Byb3BlcnR5QWNjZXNzLFxuICB3ZWxsS25vd25Qcm9wZXJ0aWVzLFxufSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL3V0aWxzL3JlZmxlY3QtdXRpbHMnXG5pbXBvcnQgeyBtYWtlSGFuZ2luZ1Byb21pc2UgfSBmcm9tICcuLi9keW5hbWljLXJlbmRlcmluZy11dGlscydcbmltcG9ydCB7IGNyZWF0ZURlZHVwZWRCeUNhbGxzaXRlU2VydmVyRXJyb3JMb2dnZXJEZXYgfSBmcm9tICcuLi9jcmVhdGUtZGVkdXBlZC1ieS1jYWxsc2l0ZS1zZXJ2ZXItZXJyb3ItbG9nZ2VyJ1xuaW1wb3J0IHsgc2NoZWR1bGVJbW1lZGlhdGUgfSBmcm9tICcuLi8uLi9saWIvc2NoZWR1bGVyJ1xuaW1wb3J0IHsgZHluYW1pY0FjY2Vzc0FzeW5jU3RvcmFnZSB9IGZyb20gJy4uL2FwcC1yZW5kZXIvZHluYW1pYy1hY2Nlc3MtYXN5bmMtc3RvcmFnZS5leHRlcm5hbCdcblxuZXhwb3J0IHR5cGUgUGFyYW1WYWx1ZSA9IHN0cmluZyB8IEFycmF5PHN0cmluZz4gfCB1bmRlZmluZWRcbmV4cG9ydCB0eXBlIFBhcmFtcyA9IFJlY29yZDxzdHJpbmcsIFBhcmFtVmFsdWU+XG5cbi8qKlxuICogSW4gdGhpcyB2ZXJzaW9uIG9mIE5leHQuanMgdGhlIGBwYXJhbXNgIHByb3AgcGFzc2VkIHRvIExheW91dHMsIFBhZ2VzLCBhbmQgb3RoZXIgU2VnbWVudHMgaXMgYSBQcm9taXNlLlxuICogSG93ZXZlciB0byBmYWNpbGl0YXRlIG1pZ3JhdGlvbiB0byB0aGlzIG5ldyBQcm9taXNlIHR5cGUgeW91IGNhbiBjdXJyZW50bHkgc3RpbGwgYWNjZXNzIHBhcmFtcyBkaXJlY3RseSBvbiB0aGUgUHJvbWlzZSBpbnN0YW5jZSBwYXNzZWQgdG8gdGhlc2UgU2VnbWVudHMuXG4gKiBUaGUgYFVuc2FmZVVud3JhcHBlZFBhcmFtc2AgdHlwZSBpcyBhdmFpbGFibGUgaWYgeW91IG5lZWQgdG8gdGVtcG9yYXJpbHkgYWNjZXNzIHRoZSB1bmRlcmx5aW5nIHBhcmFtcyB3aXRob3V0IGZpcnN0IGF3YWl0aW5nIG9yIGB1c2VgaW5nIHRoZSBQcm9taXNlLlxuICpcbiAqIEluIGEgZnV0dXJlIHZlcnNpb24gb2YgTmV4dC5qcyB0aGUgYHBhcmFtc2AgcHJvcCB3aWxsIGJlIGEgcGxhaW4gUHJvbWlzZSBhbmQgdGhpcyB0eXBlIHdpbGwgYmUgcmVtb3ZlZC5cbiAqXG4gKiBUeXBpY2FsbHkgaW5zdGFuY2VzIG9mIGBwYXJhbXNgIGNhbiBiZSB1cGRhdGVkIGF1dG9tYXRpY2FsbHkgdG8gYmUgdHJlYXRlZCBhcyBhIFByb21pc2UgYnkgYSBjb2RlbW9kIHB1Ymxpc2hlZCBhbG9uZ3NpZGUgdGhpcyBOZXh0LmpzIHZlcnNpb24gaG93ZXZlciBpZiB5b3VcbiAqIGhhdmUgbm90IHlldCBydW4gdGhlIGNvZGVtb2Qgb2YgdGhlIGNvZGVtb2QgY2Fubm90IGRldGVjdCBjZXJ0YWluIGluc3RhbmNlcyBvZiBgcGFyYW1zYCB1c2FnZSB5b3Ugc2hvdWxkIGZpcnN0IHRyeSB0byByZWZhY3RvciB5b3VyIGNvZGUgdG8gYXdhaXQgYHBhcmFtc2AuXG4gKlxuICogSWYgcmVmYWN0b3JpbmcgaXMgbm90IHBvc3NpYmxlIGJ1dCB5b3Ugc3RpbGwgd2FudCB0byBiZSBhYmxlIHRvIGFjY2VzcyBwYXJhbXMgZGlyZWN0bHkgd2l0aG91dCB0eXBlc2NyaXB0IGVycm9ycyB5b3UgY2FuIGNhc3QgdGhlIHBhcmFtcyBQcm9taXNlIHRvIHRoaXMgdHlwZVxuICpcbiAqIGBgYHRzeFxuICogdHlwZSBQcm9wcyA9IHsgcGFyYW1zOiBQcm9taXNlPHsgaWQ6IHN0cmluZyB9Pn1cbiAqXG4gKiBleHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBMYXlvdXQocHJvcHM6IFByb3BzKSB7XG4gKiAgY29uc3QgZGlyZWN0UGFyYW1zID0gKHByb3BzLnBhcmFtcyBhcyB1bmtub3duIGFzIFVuc2FmZVVud3JhcHBlZFBhcmFtczx0eXBlb2YgcHJvcHMucGFyYW1zPilcbiAqICByZXR1cm4gLi4uXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBUaGlzIHR5cGUgaXMgbWFya2VkIGRlcHJlY2F0ZWQgdG8gaGVscCBpZGVudGlmeSBpdCBhcyB0YXJnZXQgZm9yIHJlZmFjdG9yaW5nIGF3YXkuXG4gKlxuICogQGRlcHJlY2F0ZWRcbiAqL1xuZXhwb3J0IHR5cGUgVW5zYWZlVW53cmFwcGVkUGFyYW1zPFA+ID1cbiAgUCBleHRlbmRzIFByb21pc2U8aW5mZXIgVT4gPyBPbWl0PFUsICd0aGVuJyB8ICdzdGF0dXMnIHwgJ3ZhbHVlJz4gOiBuZXZlclxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUGFyYW1zRnJvbUNsaWVudChcbiAgdW5kZXJseWluZ1BhcmFtczogUGFyYW1zLFxuICB3b3JrU3RvcmU6IFdvcmtTdG9yZVxuKSB7XG4gIGNvbnN0IHdvcmtVbml0U3RvcmUgPSB3b3JrVW5pdEFzeW5jU3RvcmFnZS5nZXRTdG9yZSgpXG4gIGlmICh3b3JrVW5pdFN0b3JlKSB7XG4gICAgc3dpdGNoICh3b3JrVW5pdFN0b3JlLnR5cGUpIHtcbiAgICAgIGNhc2UgJ3ByZXJlbmRlcic6XG4gICAgICBjYXNlICdwcmVyZW5kZXItY2xpZW50JzpcbiAgICAgIGNhc2UgJ3ByZXJlbmRlci1wcHInOlxuICAgICAgY2FzZSAncHJlcmVuZGVyLWxlZ2FjeSc6XG4gICAgICAgIHJldHVybiBjcmVhdGVQcmVyZW5kZXJQYXJhbXModW5kZXJseWluZ1BhcmFtcywgd29ya1N0b3JlLCB3b3JrVW5pdFN0b3JlKVxuICAgICAgZGVmYXVsdDpcbiAgICAgIC8vIGZhbGx0aHJvdWdoXG4gICAgfVxuICB9XG4gIHJldHVybiBjcmVhdGVSZW5kZXJQYXJhbXModW5kZXJseWluZ1BhcmFtcywgd29ya1N0b3JlKVxufVxuXG4vLyBnZW5lcmF0ZU1ldGFkYXRhIGFsd2F5cyBydW5zIGluIFJTQyBjb250ZXh0IHNvIGl0IGlzIGVxdWl2YWxlbnQgdG8gYSBTZXJ2ZXIgUGFnZSBDb21wb25lbnRcbmV4cG9ydCB0eXBlIENyZWF0ZVNlcnZlclBhcmFtc0Zvck1ldGFkYXRhID0gdHlwZW9mIGNyZWF0ZVNlcnZlclBhcmFtc0Zvck1ldGFkYXRhXG5leHBvcnQgY29uc3QgY3JlYXRlU2VydmVyUGFyYW1zRm9yTWV0YWRhdGEgPSBjcmVhdGVTZXJ2ZXJQYXJhbXNGb3JTZXJ2ZXJTZWdtZW50XG5cbi8vIHJvdXRlcyBhbHdheXMgcnVucyBpbiBSU0MgY29udGV4dCBzbyBpdCBpcyBlcXVpdmFsZW50IHRvIGEgU2VydmVyIFBhZ2UgQ29tcG9uZW50XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2VydmVyUGFyYW1zRm9yUm91dGUoXG4gIHVuZGVybHlpbmdQYXJhbXM6IFBhcmFtcyxcbiAgd29ya1N0b3JlOiBXb3JrU3RvcmVcbikge1xuICBjb25zdCB3b3JrVW5pdFN0b3JlID0gd29ya1VuaXRBc3luY1N0b3JhZ2UuZ2V0U3RvcmUoKVxuICBpZiAod29ya1VuaXRTdG9yZSkge1xuICAgIHN3aXRjaCAod29ya1VuaXRTdG9yZS50eXBlKSB7XG4gICAgICBjYXNlICdwcmVyZW5kZXInOlxuICAgICAgY2FzZSAncHJlcmVuZGVyLWNsaWVudCc6XG4gICAgICBjYXNlICdwcmVyZW5kZXItcHByJzpcbiAgICAgIGNhc2UgJ3ByZXJlbmRlci1sZWdhY3knOlxuICAgICAgICByZXR1cm4gY3JlYXRlUHJlcmVuZGVyUGFyYW1zKHVuZGVybHlpbmdQYXJhbXMsIHdvcmtTdG9yZSwgd29ya1VuaXRTdG9yZSlcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAvLyBmYWxsdGhyb3VnaFxuICAgIH1cbiAgfVxuICByZXR1cm4gY3JlYXRlUmVuZGVyUGFyYW1zKHVuZGVybHlpbmdQYXJhbXMsIHdvcmtTdG9yZSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNlcnZlclBhcmFtc0ZvclNlcnZlclNlZ21lbnQoXG4gIHVuZGVybHlpbmdQYXJhbXM6IFBhcmFtcyxcbiAgd29ya1N0b3JlOiBXb3JrU3RvcmVcbik6IFByb21pc2U8UGFyYW1zPiB7XG4gIGNvbnN0IHdvcmtVbml0U3RvcmUgPSB3b3JrVW5pdEFzeW5jU3RvcmFnZS5nZXRTdG9yZSgpXG4gIGlmICh3b3JrVW5pdFN0b3JlKSB7XG4gICAgc3dpdGNoICh3b3JrVW5pdFN0b3JlLnR5cGUpIHtcbiAgICAgIGNhc2UgJ3ByZXJlbmRlcic6XG4gICAgICBjYXNlICdwcmVyZW5kZXItY2xpZW50JzpcbiAgICAgIGNhc2UgJ3ByZXJlbmRlci1wcHInOlxuICAgICAgY2FzZSAncHJlcmVuZGVyLWxlZ2FjeSc6XG4gICAgICAgIHJldHVybiBjcmVhdGVQcmVyZW5kZXJQYXJhbXModW5kZXJseWluZ1BhcmFtcywgd29ya1N0b3JlLCB3b3JrVW5pdFN0b3JlKVxuICAgICAgZGVmYXVsdDpcbiAgICAgIC8vIGZhbGx0aHJvdWdoXG4gICAgfVxuICB9XG4gIHJldHVybiBjcmVhdGVSZW5kZXJQYXJhbXModW5kZXJseWluZ1BhcmFtcywgd29ya1N0b3JlKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUHJlcmVuZGVyUGFyYW1zRm9yQ2xpZW50U2VnbWVudChcbiAgdW5kZXJseWluZ1BhcmFtczogUGFyYW1zLFxuICB3b3JrU3RvcmU6IFdvcmtTdG9yZVxuKTogUHJvbWlzZTxQYXJhbXM+IHtcbiAgY29uc3QgcHJlcmVuZGVyU3RvcmUgPSB3b3JrVW5pdEFzeW5jU3RvcmFnZS5nZXRTdG9yZSgpXG4gIGlmIChcbiAgICBwcmVyZW5kZXJTdG9yZSAmJlxuICAgIChwcmVyZW5kZXJTdG9yZS50eXBlID09PSAncHJlcmVuZGVyJyB8fFxuICAgICAgcHJlcmVuZGVyU3RvcmUudHlwZSA9PT0gJ3ByZXJlbmRlci1jbGllbnQnKVxuICApIHtcbiAgICBjb25zdCBmYWxsYmFja1BhcmFtcyA9IHdvcmtTdG9yZS5mYWxsYmFja1JvdXRlUGFyYW1zXG4gICAgaWYgKGZhbGxiYWNrUGFyYW1zKSB7XG4gICAgICBmb3IgKGxldCBrZXkgaW4gdW5kZXJseWluZ1BhcmFtcykge1xuICAgICAgICBpZiAoZmFsbGJhY2tQYXJhbXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAvLyBUaGlzIHBhcmFtcyBvYmplY3QgaGFzIG9uZSBvZiBtb3JlIGZhbGxiYWNrIHBhcmFtcyBzbyB3ZSBuZWVkIHRvIGNvbnNpZGVyXG4gICAgICAgICAgLy8gdGhlIGF3YWl0aW5nIG9mIHRoaXMgcGFyYW1zIG9iamVjdCBcImR5bmFtaWNcIi4gU2luY2Ugd2UgYXJlIGluIGR5bmFtaWNJTyBtb2RlXG4gICAgICAgICAgLy8gd2UgZW5jb2RlIHRoaXMgYXMgYSBwcm9taXNlIHRoYXQgbmV2ZXIgcmVzb2x2ZXNcbiAgICAgICAgICByZXR1cm4gbWFrZUhhbmdpbmdQcm9taXNlKHByZXJlbmRlclN0b3JlLnJlbmRlclNpZ25hbCwgJ2BwYXJhbXNgJylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBXZSdyZSBwcmVyZW5kZXJpbmcgaW4gYSBtb2RlIHRoYXQgZG9lcyBub3QgYWJvcnQuIFdlIHJlc29sdmUgdGhlIHByb21pc2Ugd2l0aG91dFxuICAvLyBhbnkgdHJhY2tpbmcgYmVjYXVzZSB3ZSdyZSBqdXN0IHRyYW5zcG9ydGluZyBhIHZhbHVlIGZyb20gc2VydmVyIHRvIGNsaWVudCB3aGVyZSB0aGUgdHJhY2tpbmdcbiAgLy8gd2lsbCBiZSBhcHBsaWVkLlxuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHVuZGVybHlpbmdQYXJhbXMpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVByZXJlbmRlclBhcmFtcyhcbiAgdW5kZXJseWluZ1BhcmFtczogUGFyYW1zLFxuICB3b3JrU3RvcmU6IFdvcmtTdG9yZSxcbiAgcHJlcmVuZGVyU3RvcmU6IFByZXJlbmRlclN0b3JlXG4pOiBQcm9taXNlPFBhcmFtcz4ge1xuICBjb25zdCBmYWxsYmFja1BhcmFtcyA9IHdvcmtTdG9yZS5mYWxsYmFja1JvdXRlUGFyYW1zXG4gIGlmIChmYWxsYmFja1BhcmFtcykge1xuICAgIGxldCBoYXNTb21lRmFsbGJhY2tQYXJhbXMgPSBmYWxzZVxuICAgIGZvciAoY29uc3Qga2V5IGluIHVuZGVybHlpbmdQYXJhbXMpIHtcbiAgICAgIGlmIChmYWxsYmFja1BhcmFtcy5oYXMoa2V5KSkge1xuICAgICAgICBoYXNTb21lRmFsbGJhY2tQYXJhbXMgPSB0cnVlXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGhhc1NvbWVGYWxsYmFja1BhcmFtcykge1xuICAgICAgLy8gcGFyYW1zIG5lZWQgdG8gYmUgdHJlYXRlZCBhcyBkeW5hbWljIGJlY2F1c2Ugd2UgaGF2ZSBhdCBsZWFzdCBvbmUgZmFsbGJhY2sgcGFyYW1cbiAgICAgIHN3aXRjaCAocHJlcmVuZGVyU3RvcmUudHlwZSkge1xuICAgICAgICBjYXNlICdwcmVyZW5kZXInOlxuICAgICAgICBjYXNlICdwcmVyZW5kZXItY2xpZW50JzpcbiAgICAgICAgICAvLyBXZSBhcmUgaW4gYSBkeW5hbWljSU8gcHJlcmVuZGVyXG4gICAgICAgICAgcmV0dXJuIG1ha2VIYW5naW5nUGFyYW1zKHVuZGVybHlpbmdQYXJhbXMsIHByZXJlbmRlclN0b3JlKVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBtYWtlRXJyb3JpbmdFeG90aWNQYXJhbXMoXG4gICAgICAgICAgICB1bmRlcmx5aW5nUGFyYW1zLFxuICAgICAgICAgICAgZmFsbGJhY2tQYXJhbXMsXG4gICAgICAgICAgICB3b3JrU3RvcmUsXG4gICAgICAgICAgICBwcmVyZW5kZXJTdG9yZVxuICAgICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBXZSBkb24ndCBoYXZlIGFueSBmYWxsYmFjayBwYXJhbXMgc28gd2UgaGF2ZSBhbiBlbnRpcmVseSBzdGF0aWMgc2FmZSBwYXJhbXMgb2JqZWN0XG4gIHJldHVybiBtYWtlVW50cmFja2VkRXhvdGljUGFyYW1zKHVuZGVybHlpbmdQYXJhbXMpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJlbmRlclBhcmFtcyhcbiAgdW5kZXJseWluZ1BhcmFtczogUGFyYW1zLFxuICB3b3JrU3RvcmU6IFdvcmtTdG9yZVxuKTogUHJvbWlzZTxQYXJhbXM+IHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICF3b3JrU3RvcmUuaXNQcmVmZXRjaFJlcXVlc3QpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0RZTkFNSUNfSU8pIHtcbiAgICAgIHJldHVybiBtYWtlRHluYW1pY2FsbHlUcmFja2VkUGFyYW1zV2l0aERldldhcm5pbmdzKFxuICAgICAgICB1bmRlcmx5aW5nUGFyYW1zLFxuICAgICAgICB3b3JrU3RvcmVcbiAgICAgIClcbiAgICB9XG5cbiAgICByZXR1cm4gbWFrZUR5bmFtaWNhbGx5VHJhY2tlZEV4b3RpY1BhcmFtc1dpdGhEZXZXYXJuaW5ncyhcbiAgICAgIHVuZGVybHlpbmdQYXJhbXMsXG4gICAgICB3b3JrU3RvcmVcbiAgICApXG4gIH0gZWxzZSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9EWU5BTUlDX0lPKSB7XG4gICAgICByZXR1cm4gbWFrZVVudHJhY2tlZFBhcmFtcyh1bmRlcmx5aW5nUGFyYW1zKVxuICAgIH1cblxuICAgIHJldHVybiBtYWtlVW50cmFja2VkRXhvdGljUGFyYW1zKHVuZGVybHlpbmdQYXJhbXMpXG4gIH1cbn1cblxuaW50ZXJmYWNlIENhY2hlTGlmZXRpbWUge31cbmNvbnN0IENhY2hlZFBhcmFtcyA9IG5ldyBXZWFrTWFwPENhY2hlTGlmZXRpbWUsIFByb21pc2U8UGFyYW1zPj4oKVxuXG5jb25zdCBmYWxsYmFja1BhcmFtc1Byb3h5SGFuZGxlcjogUHJveHlIYW5kbGVyPFByb21pc2U8UGFyYW1zPj4gPSB7XG4gIGdldDogZnVuY3Rpb24gZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICBpZiAocHJvcCA9PT0gJ3RoZW4nIHx8IHByb3AgPT09ICdjYXRjaCcgfHwgcHJvcCA9PT0gJ2ZpbmFsbHknKSB7XG4gICAgICBjb25zdCBvcmlnaW5hbE1ldGhvZCA9IFJlZmxlY3RBZGFwdGVyLmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBbcHJvcF06ICguLi5hcmdzOiB1bmtub3duW10pID0+IHtcbiAgICAgICAgICBjb25zdCBzdG9yZSA9IGR5bmFtaWNBY2Nlc3NBc3luY1N0b3JhZ2UuZ2V0U3RvcmUoKVxuXG4gICAgICAgICAgaWYgKHN0b3JlKSB7XG4gICAgICAgICAgICBzdG9yZS5hYm9ydENvbnRyb2xsZXIuYWJvcnQoXG4gICAgICAgICAgICAgIG5ldyBFcnJvcihgQWNjZXNzZWQgZmFsbGJhY2sgXFxgcGFyYW1zXFxgIGR1cmluZyBwcmVyZW5kZXJpbmcuYClcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbmV3IFByb3h5KFxuICAgICAgICAgICAgb3JpZ2luYWxNZXRob2QuYXBwbHkodGFyZ2V0LCBhcmdzKSxcbiAgICAgICAgICAgIGZhbGxiYWNrUGFyYW1zUHJveHlIYW5kbGVyXG4gICAgICAgICAgKVxuICAgICAgICB9LFxuICAgICAgfVtwcm9wXVxuICAgIH1cblxuICAgIHJldHVybiBSZWZsZWN0QWRhcHRlci5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcilcbiAgfSxcbn1cblxuZnVuY3Rpb24gbWFrZUhhbmdpbmdQYXJhbXMoXG4gIHVuZGVybHlpbmdQYXJhbXM6IFBhcmFtcyxcbiAgcHJlcmVuZGVyU3RvcmU6IFByZXJlbmRlclN0b3JlTW9kZXJuXG4pOiBQcm9taXNlPFBhcmFtcz4ge1xuICBjb25zdCBjYWNoZWRQYXJhbXMgPSBDYWNoZWRQYXJhbXMuZ2V0KHVuZGVybHlpbmdQYXJhbXMpXG4gIGlmIChjYWNoZWRQYXJhbXMpIHtcbiAgICByZXR1cm4gY2FjaGVkUGFyYW1zXG4gIH1cblxuICBjb25zdCBwcm9taXNlID0gbmV3IFByb3h5KFxuICAgIG1ha2VIYW5naW5nUHJvbWlzZTxQYXJhbXM+KHByZXJlbmRlclN0b3JlLnJlbmRlclNpZ25hbCwgJ2BwYXJhbXNgJyksXG4gICAgZmFsbGJhY2tQYXJhbXNQcm94eUhhbmRsZXJcbiAgKVxuXG4gIENhY2hlZFBhcmFtcy5zZXQodW5kZXJseWluZ1BhcmFtcywgcHJvbWlzZSlcblxuICByZXR1cm4gcHJvbWlzZVxufVxuXG5mdW5jdGlvbiBtYWtlRXJyb3JpbmdFeG90aWNQYXJhbXMoXG4gIHVuZGVybHlpbmdQYXJhbXM6IFBhcmFtcyxcbiAgZmFsbGJhY2tQYXJhbXM6IEZhbGxiYWNrUm91dGVQYXJhbXMsXG4gIHdvcmtTdG9yZTogV29ya1N0b3JlLFxuICBwcmVyZW5kZXJTdG9yZTogUHJlcmVuZGVyU3RvcmVQUFIgfCBQcmVyZW5kZXJTdG9yZUxlZ2FjeVxuKTogUHJvbWlzZTxQYXJhbXM+IHtcbiAgY29uc3QgY2FjaGVkUGFyYW1zID0gQ2FjaGVkUGFyYW1zLmdldCh1bmRlcmx5aW5nUGFyYW1zKVxuICBpZiAoY2FjaGVkUGFyYW1zKSB7XG4gICAgcmV0dXJuIGNhY2hlZFBhcmFtc1xuICB9XG5cbiAgY29uc3QgYXVnbWVudGVkVW5kZXJseWluZyA9IHsgLi4udW5kZXJseWluZ1BhcmFtcyB9XG5cbiAgLy8gV2UgZG9uJ3QgdXNlIG1ha2VSZXNvbHZlZFJlYWN0UHJvbWlzZSBoZXJlIGJlY2F1c2UgcGFyYW1zXG4gIC8vIHN1cHBvcnRzIGNvcHlpbmcgd2l0aCBzcHJlYWQgYW5kIHdlIGRvbid0IHdhbnQgdG8gdW5uZWNlc3NhcmlseVxuICAvLyBpbnN0cnVtZW50IHRoZSBwcm9taXNlIHdpdGggc3ByZWFkYWJsZSBwcm9wZXJ0aWVzIG9mIFJlYWN0UHJvbWlzZS5cbiAgY29uc3QgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShhdWdtZW50ZWRVbmRlcmx5aW5nKVxuICBDYWNoZWRQYXJhbXMuc2V0KHVuZGVybHlpbmdQYXJhbXMsIHByb21pc2UpXG5cbiAgT2JqZWN0LmtleXModW5kZXJseWluZ1BhcmFtcykuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgIGlmICh3ZWxsS25vd25Qcm9wZXJ0aWVzLmhhcyhwcm9wKSkge1xuICAgICAgLy8gVGhlc2UgcHJvcGVydGllcyBjYW5ub3QgYmUgc2hhZG93ZWQgYmVjYXVzZSB0aGV5IG5lZWQgdG8gYmUgdGhlXG4gICAgICAvLyB0cnVlIHVuZGVybHlpbmcgdmFsdWUgZm9yIFByb21pc2VzIHRvIHdvcmsgY29ycmVjdGx5IGF0IHJ1bnRpbWVcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGZhbGxiYWNrUGFyYW1zLmhhcyhwcm9wKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXVnbWVudGVkVW5kZXJseWluZywgcHJvcCwge1xuICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBkZXNjcmliZVN0cmluZ1Byb3BlcnR5QWNjZXNzKCdwYXJhbXMnLCBwcm9wKVxuICAgICAgICAgICAgLy8gSW4gbW9zdCBkeW5hbWljIEFQSXMgd2UgYWxzbyB0aHJvdyBpZiBgZHluYW1pYyA9IFwiZXJyb3JcImAgaG93ZXZlclxuICAgICAgICAgICAgLy8gZm9yIHBhcmFtcyBpcyBvbmx5IGR5bmFtaWMgd2hlbiB3ZSdyZSBnZW5lcmF0aW5nIGEgZmFsbGJhY2sgc2hlbGxcbiAgICAgICAgICAgIC8vIGFuZCBldmVuIHdoZW4gYGR5bmFtaWMgPSBcImVycm9yXCJgIHdlIHN0aWxsIHN1cHBvcnQgZ2VuZXJhdGluZyBkeW5hbWljXG4gICAgICAgICAgICAvLyBmYWxsYmFjayBzaGVsbHNcbiAgICAgICAgICAgIC8vIFRPRE8gcmVtb3ZlIHRoaXMgY29tbWVudCB3aGVuIGR5bmFtaWNJTyBpcyB0aGUgZGVmYXVsdCBzaW5jZSB0aGVyZVxuICAgICAgICAgICAgLy8gd2lsbCBiZSBubyBgZHluYW1pYyA9IFwiZXJyb3JcImBcbiAgICAgICAgICAgIGlmIChwcmVyZW5kZXJTdG9yZS50eXBlID09PSAncHJlcmVuZGVyLXBwcicpIHtcbiAgICAgICAgICAgICAgLy8gUFBSIFByZXJlbmRlciAobm8gZHluYW1pY0lPKVxuICAgICAgICAgICAgICBwb3N0cG9uZVdpdGhUcmFja2luZyhcbiAgICAgICAgICAgICAgICB3b3JrU3RvcmUucm91dGUsXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICBwcmVyZW5kZXJTdG9yZS5keW5hbWljVHJhY2tpbmdcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gTGVnYWN5IFByZXJlbmRlclxuICAgICAgICAgICAgICB0aHJvd1RvSW50ZXJydXB0U3RhdGljR2VuZXJhdGlvbihcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uLFxuICAgICAgICAgICAgICAgIHdvcmtTdG9yZSxcbiAgICAgICAgICAgICAgICBwcmVyZW5kZXJTdG9yZVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB9KVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgcHJvcCwge1xuICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBkZXNjcmliZVN0cmluZ1Byb3BlcnR5QWNjZXNzKCdwYXJhbXMnLCBwcm9wKVxuICAgICAgICAgICAgLy8gSW4gbW9zdCBkeW5hbWljIEFQSXMgd2UgYWxzbyB0aHJvdyBpZiBgZHluYW1pYyA9IFwiZXJyb3JcImAgaG93ZXZlclxuICAgICAgICAgICAgLy8gZm9yIHBhcmFtcyBpcyBvbmx5IGR5bmFtaWMgd2hlbiB3ZSdyZSBnZW5lcmF0aW5nIGEgZmFsbGJhY2sgc2hlbGxcbiAgICAgICAgICAgIC8vIGFuZCBldmVuIHdoZW4gYGR5bmFtaWMgPSBcImVycm9yXCJgIHdlIHN0aWxsIHN1cHBvcnQgZ2VuZXJhdGluZyBkeW5hbWljXG4gICAgICAgICAgICAvLyBmYWxsYmFjayBzaGVsbHNcbiAgICAgICAgICAgIC8vIFRPRE8gcmVtb3ZlIHRoaXMgY29tbWVudCB3aGVuIGR5bmFtaWNJTyBpcyB0aGUgZGVmYXVsdCBzaW5jZSB0aGVyZVxuICAgICAgICAgICAgLy8gd2lsbCBiZSBubyBgZHluYW1pYyA9IFwiZXJyb3JcImBcbiAgICAgICAgICAgIGlmIChwcmVyZW5kZXJTdG9yZS50eXBlID09PSAncHJlcmVuZGVyLXBwcicpIHtcbiAgICAgICAgICAgICAgLy8gUFBSIFByZXJlbmRlciAobm8gZHluYW1pY0lPKVxuICAgICAgICAgICAgICBwb3N0cG9uZVdpdGhUcmFja2luZyhcbiAgICAgICAgICAgICAgICB3b3JrU3RvcmUucm91dGUsXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICBwcmVyZW5kZXJTdG9yZS5keW5hbWljVHJhY2tpbmdcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gTGVnYWN5IFByZXJlbmRlclxuICAgICAgICAgICAgICB0aHJvd1RvSW50ZXJydXB0U3RhdGljR2VuZXJhdGlvbihcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uLFxuICAgICAgICAgICAgICAgIHdvcmtTdG9yZSxcbiAgICAgICAgICAgICAgICBwcmVyZW5kZXJTdG9yZVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQobmV3VmFsdWUpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBwcm9wLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBuZXdWYWx1ZSxcbiAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICA7KHByb21pc2UgYXMgYW55KVtwcm9wXSA9IHVuZGVybHlpbmdQYXJhbXNbcHJvcF1cbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIHByb21pc2Vcbn1cblxuZnVuY3Rpb24gbWFrZVVudHJhY2tlZEV4b3RpY1BhcmFtcyh1bmRlcmx5aW5nUGFyYW1zOiBQYXJhbXMpOiBQcm9taXNlPFBhcmFtcz4ge1xuICBjb25zdCBjYWNoZWRQYXJhbXMgPSBDYWNoZWRQYXJhbXMuZ2V0KHVuZGVybHlpbmdQYXJhbXMpXG4gIGlmIChjYWNoZWRQYXJhbXMpIHtcbiAgICByZXR1cm4gY2FjaGVkUGFyYW1zXG4gIH1cblxuICAvLyBXZSBkb24ndCB1c2UgbWFrZVJlc29sdmVkUmVhY3RQcm9taXNlIGhlcmUgYmVjYXVzZSBwYXJhbXNcbiAgLy8gc3VwcG9ydHMgY29weWluZyB3aXRoIHNwcmVhZCBhbmQgd2UgZG9uJ3Qgd2FudCB0byB1bm5lY2Vzc2FyaWx5XG4gIC8vIGluc3RydW1lbnQgdGhlIHByb21pc2Ugd2l0aCBzcHJlYWRhYmxlIHByb3BlcnRpZXMgb2YgUmVhY3RQcm9taXNlLlxuICBjb25zdCBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHVuZGVybHlpbmdQYXJhbXMpXG4gIENhY2hlZFBhcmFtcy5zZXQodW5kZXJseWluZ1BhcmFtcywgcHJvbWlzZSlcblxuICBPYmplY3Qua2V5cyh1bmRlcmx5aW5nUGFyYW1zKS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgaWYgKHdlbGxLbm93blByb3BlcnRpZXMuaGFzKHByb3ApKSB7XG4gICAgICAvLyBUaGVzZSBwcm9wZXJ0aWVzIGNhbm5vdCBiZSBzaGFkb3dlZCBiZWNhdXNlIHRoZXkgbmVlZCB0byBiZSB0aGVcbiAgICAgIC8vIHRydWUgdW5kZXJseWluZyB2YWx1ZSBmb3IgUHJvbWlzZXMgdG8gd29yayBjb3JyZWN0bHkgYXQgcnVudGltZVxuICAgIH0gZWxzZSB7XG4gICAgICA7KHByb21pc2UgYXMgYW55KVtwcm9wXSA9IHVuZGVybHlpbmdQYXJhbXNbcHJvcF1cbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIHByb21pc2Vcbn1cblxuZnVuY3Rpb24gbWFrZVVudHJhY2tlZFBhcmFtcyh1bmRlcmx5aW5nUGFyYW1zOiBQYXJhbXMpOiBQcm9taXNlPFBhcmFtcz4ge1xuICBjb25zdCBjYWNoZWRQYXJhbXMgPSBDYWNoZWRQYXJhbXMuZ2V0KHVuZGVybHlpbmdQYXJhbXMpXG4gIGlmIChjYWNoZWRQYXJhbXMpIHtcbiAgICByZXR1cm4gY2FjaGVkUGFyYW1zXG4gIH1cblxuICBjb25zdCBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHVuZGVybHlpbmdQYXJhbXMpXG4gIENhY2hlZFBhcmFtcy5zZXQodW5kZXJseWluZ1BhcmFtcywgcHJvbWlzZSlcblxuICByZXR1cm4gcHJvbWlzZVxufVxuXG5mdW5jdGlvbiBtYWtlRHluYW1pY2FsbHlUcmFja2VkRXhvdGljUGFyYW1zV2l0aERldldhcm5pbmdzKFxuICB1bmRlcmx5aW5nUGFyYW1zOiBQYXJhbXMsXG4gIHN0b3JlOiBXb3JrU3RvcmVcbik6IFByb21pc2U8UGFyYW1zPiB7XG4gIGNvbnN0IGNhY2hlZFBhcmFtcyA9IENhY2hlZFBhcmFtcy5nZXQodW5kZXJseWluZ1BhcmFtcylcbiAgaWYgKGNhY2hlZFBhcmFtcykge1xuICAgIHJldHVybiBjYWNoZWRQYXJhbXNcbiAgfVxuXG4gIC8vIFdlIGRvbid0IHVzZSBtYWtlUmVzb2x2ZWRSZWFjdFByb21pc2UgaGVyZSBiZWNhdXNlIHBhcmFtc1xuICAvLyBzdXBwb3J0cyBjb3B5aW5nIHdpdGggc3ByZWFkIGFuZCB3ZSBkb24ndCB3YW50IHRvIHVubmVjZXNzYXJpbHlcbiAgLy8gaW5zdHJ1bWVudCB0aGUgcHJvbWlzZSB3aXRoIHNwcmVhZGFibGUgcHJvcGVydGllcyBvZiBSZWFjdFByb21pc2UuXG4gIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZTxQYXJhbXM+KChyZXNvbHZlKSA9PlxuICAgIHNjaGVkdWxlSW1tZWRpYXRlKCgpID0+IHJlc29sdmUodW5kZXJseWluZ1BhcmFtcykpXG4gIClcblxuICBjb25zdCBwcm94aWVkUHJvcGVydGllcyA9IG5ldyBTZXQ8c3RyaW5nPigpXG4gIGNvbnN0IHVucHJveGllZFByb3BlcnRpZXM6IEFycmF5PHN0cmluZz4gPSBbXVxuXG4gIE9iamVjdC5rZXlzKHVuZGVybHlpbmdQYXJhbXMpLmZvckVhY2goKHByb3ApID0+IHtcbiAgICBpZiAod2VsbEtub3duUHJvcGVydGllcy5oYXMocHJvcCkpIHtcbiAgICAgIC8vIFRoZXNlIHByb3BlcnRpZXMgY2Fubm90IGJlIHNoYWRvd2VkIGJlY2F1c2UgdGhleSBuZWVkIHRvIGJlIHRoZVxuICAgICAgLy8gdHJ1ZSB1bmRlcmx5aW5nIHZhbHVlIGZvciBQcm9taXNlcyB0byB3b3JrIGNvcnJlY3RseSBhdCBydW50aW1lXG4gICAgICB1bnByb3hpZWRQcm9wZXJ0aWVzLnB1c2gocHJvcClcbiAgICB9IGVsc2Uge1xuICAgICAgcHJveGllZFByb3BlcnRpZXMuYWRkKHByb3ApXG4gICAgICA7KHByb21pc2UgYXMgYW55KVtwcm9wXSA9IHVuZGVybHlpbmdQYXJhbXNbcHJvcF1cbiAgICB9XG4gIH0pXG5cbiAgY29uc3QgcHJveGllZFByb21pc2UgPSBuZXcgUHJveHkocHJvbWlzZSwge1xuICAgIGdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG4gICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAvLyBXZSBhcmUgYWNjZXNzaW5nIGEgcHJvcGVydHkgdGhhdCB3YXMgcHJveGllZCB0byB0aGUgcHJvbWlzZSBpbnN0YW5jZVxuICAgICAgICAgIHByb3hpZWRQcm9wZXJ0aWVzLmhhcyhwcm9wKVxuICAgICAgICApIHtcbiAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gZGVzY3JpYmVTdHJpbmdQcm9wZXJ0eUFjY2VzcygncGFyYW1zJywgcHJvcClcbiAgICAgICAgICBzeW5jSU9EZXYoc3RvcmUucm91dGUsIGV4cHJlc3Npb24pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBSZWZsZWN0QWRhcHRlci5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcilcbiAgICB9LFxuICAgIHNldCh0YXJnZXQsIHByb3AsIHZhbHVlLCByZWNlaXZlcikge1xuICAgICAgaWYgKHR5cGVvZiBwcm9wID09PSAnc3RyaW5nJykge1xuICAgICAgICBwcm94aWVkUHJvcGVydGllcy5kZWxldGUocHJvcClcbiAgICAgIH1cbiAgICAgIHJldHVybiBSZWZsZWN0QWRhcHRlci5zZXQodGFyZ2V0LCBwcm9wLCB2YWx1ZSwgcmVjZWl2ZXIpXG4gICAgfSxcbiAgICBvd25LZXlzKHRhcmdldCkge1xuICAgICAgY29uc3QgZXhwcmVzc2lvbiA9ICdgLi4ucGFyYW1zYCBvciBzaW1pbGFyIGV4cHJlc3Npb24nXG4gICAgICBzeW5jSU9EZXYoc3RvcmUucm91dGUsIGV4cHJlc3Npb24sIHVucHJveGllZFByb3BlcnRpZXMpXG4gICAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKHRhcmdldClcbiAgICB9LFxuICB9KVxuXG4gIENhY2hlZFBhcmFtcy5zZXQodW5kZXJseWluZ1BhcmFtcywgcHJveGllZFByb21pc2UpXG4gIHJldHVybiBwcm94aWVkUHJvbWlzZVxufVxuXG4vLyBTaW1pbGFyIHRvIGBtYWtlRHluYW1pY2FsbHlUcmFja2VkRXhvdGljUGFyYW1zV2l0aERldldhcm5pbmdzYCwgYnV0IGp1c3Rcbi8vIGxvZ2dpbmcgdGhlIHN5bmMgYWNjZXNzIHdpdGhvdXQgYWN0dWFsbHkgZGVmaW5pbmcgdGhlIHBhcmFtcyBvbiB0aGUgcHJvbWlzZS5cbmZ1bmN0aW9uIG1ha2VEeW5hbWljYWxseVRyYWNrZWRQYXJhbXNXaXRoRGV2V2FybmluZ3MoXG4gIHVuZGVybHlpbmdQYXJhbXM6IFBhcmFtcyxcbiAgc3RvcmU6IFdvcmtTdG9yZVxuKTogUHJvbWlzZTxQYXJhbXM+IHtcbiAgY29uc3QgY2FjaGVkUGFyYW1zID0gQ2FjaGVkUGFyYW1zLmdldCh1bmRlcmx5aW5nUGFyYW1zKVxuICBpZiAoY2FjaGVkUGFyYW1zKSB7XG4gICAgcmV0dXJuIGNhY2hlZFBhcmFtc1xuICB9XG5cbiAgLy8gV2UgZG9uJ3QgdXNlIG1ha2VSZXNvbHZlZFJlYWN0UHJvbWlzZSBoZXJlIGJlY2F1c2UgcGFyYW1zXG4gIC8vIHN1cHBvcnRzIGNvcHlpbmcgd2l0aCBzcHJlYWQgYW5kIHdlIGRvbid0IHdhbnQgdG8gdW5uZWNlc3NhcmlseVxuICAvLyBpbnN0cnVtZW50IHRoZSBwcm9taXNlIHdpdGggc3ByZWFkYWJsZSBwcm9wZXJ0aWVzIG9mIFJlYWN0UHJvbWlzZS5cbiAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlPFBhcmFtcz4oKHJlc29sdmUpID0+XG4gICAgc2NoZWR1bGVJbW1lZGlhdGUoKCkgPT4gcmVzb2x2ZSh1bmRlcmx5aW5nUGFyYW1zKSlcbiAgKVxuXG4gIGNvbnN0IHByb3hpZWRQcm9wZXJ0aWVzID0gbmV3IFNldDxzdHJpbmc+KClcbiAgY29uc3QgdW5wcm94aWVkUHJvcGVydGllczogQXJyYXk8c3RyaW5nPiA9IFtdXG5cbiAgT2JqZWN0LmtleXModW5kZXJseWluZ1BhcmFtcykuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgIGlmICh3ZWxsS25vd25Qcm9wZXJ0aWVzLmhhcyhwcm9wKSkge1xuICAgICAgLy8gVGhlc2UgcHJvcGVydGllcyBjYW5ub3QgYmUgc2hhZG93ZWQgYmVjYXVzZSB0aGV5IG5lZWQgdG8gYmUgdGhlXG4gICAgICAvLyB0cnVlIHVuZGVybHlpbmcgdmFsdWUgZm9yIFByb21pc2VzIHRvIHdvcmsgY29ycmVjdGx5IGF0IHJ1bnRpbWVcbiAgICAgIHVucHJveGllZFByb3BlcnRpZXMucHVzaChwcm9wKVxuICAgIH0gZWxzZSB7XG4gICAgICBwcm94aWVkUHJvcGVydGllcy5hZGQocHJvcClcbiAgICB9XG4gIH0pXG5cbiAgY29uc3QgcHJveGllZFByb21pc2UgPSBuZXcgUHJveHkocHJvbWlzZSwge1xuICAgIGdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG4gICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAvLyBXZSBhcmUgYWNjZXNzaW5nIGEgcHJvcGVydHkgdGhhdCB3YXMgcHJveGllZCB0byB0aGUgcHJvbWlzZSBpbnN0YW5jZVxuICAgICAgICAgIHByb3hpZWRQcm9wZXJ0aWVzLmhhcyhwcm9wKVxuICAgICAgICApIHtcbiAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gZGVzY3JpYmVTdHJpbmdQcm9wZXJ0eUFjY2VzcygncGFyYW1zJywgcHJvcClcbiAgICAgICAgICB3YXJuRm9yU3luY0FjY2VzcyhzdG9yZS5yb3V0ZSwgZXhwcmVzc2lvbilcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFJlZmxlY3RBZGFwdGVyLmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKVxuICAgIH0sXG4gICAgc2V0KHRhcmdldCwgcHJvcCwgdmFsdWUsIHJlY2VpdmVyKSB7XG4gICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHByb3hpZWRQcm9wZXJ0aWVzLmRlbGV0ZShwcm9wKVxuICAgICAgfVxuICAgICAgcmV0dXJuIFJlZmxlY3RBZGFwdGVyLnNldCh0YXJnZXQsIHByb3AsIHZhbHVlLCByZWNlaXZlcilcbiAgICB9LFxuICAgIG93bktleXModGFyZ2V0KSB7XG4gICAgICBjb25zdCBleHByZXNzaW9uID0gJ2AuLi5wYXJhbXNgIG9yIHNpbWlsYXIgZXhwcmVzc2lvbidcbiAgICAgIHdhcm5Gb3JJbmNvbXBsZXRlRW51bWVyYXRpb24oc3RvcmUucm91dGUsIGV4cHJlc3Npb24sIHVucHJveGllZFByb3BlcnRpZXMpXG4gICAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKHRhcmdldClcbiAgICB9LFxuICB9KVxuXG4gIENhY2hlZFBhcmFtcy5zZXQodW5kZXJseWluZ1BhcmFtcywgcHJveGllZFByb21pc2UpXG4gIHJldHVybiBwcm94aWVkUHJvbWlzZVxufVxuXG5mdW5jdGlvbiBzeW5jSU9EZXYoXG4gIHJvdXRlOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gIGV4cHJlc3Npb246IHN0cmluZyxcbiAgbWlzc2luZ1Byb3BlcnRpZXM/OiBBcnJheTxzdHJpbmc+XG4pIHtcbiAgY29uc3Qgd29ya1VuaXRTdG9yZSA9IHdvcmtVbml0QXN5bmNTdG9yYWdlLmdldFN0b3JlKClcbiAgaWYgKFxuICAgIHdvcmtVbml0U3RvcmUgJiZcbiAgICB3b3JrVW5pdFN0b3JlLnR5cGUgPT09ICdyZXF1ZXN0JyAmJlxuICAgIHdvcmtVbml0U3RvcmUucHJlcmVuZGVyUGhhc2UgPT09IHRydWVcbiAgKSB7XG4gICAgLy8gV2hlbiB3ZSdyZSByZW5kZXJpbmcgZHluYW1pY2FsbHkgaW4gZGV2IHdlIG5lZWQgdG8gYWR2YW5jZSBvdXQgb2YgdGhlXG4gICAgLy8gUHJlcmVuZGVyIGVudmlyb25tZW50IHdoZW4gd2UgcmVhZCBSZXF1ZXN0IGRhdGEgc3luY2hyb25vdXNseVxuICAgIGNvbnN0IHJlcXVlc3RTdG9yZSA9IHdvcmtVbml0U3RvcmVcbiAgICB0cmFja1N5bmNocm9ub3VzUmVxdWVzdERhdGFBY2Nlc3NJbkRldihyZXF1ZXN0U3RvcmUpXG4gIH1cbiAgLy8gSW4gYWxsIGNhc2VzIHdlIHdhcm4gbm9ybWFsbHlcbiAgaWYgKG1pc3NpbmdQcm9wZXJ0aWVzICYmIG1pc3NpbmdQcm9wZXJ0aWVzLmxlbmd0aCA+IDApIHtcbiAgICB3YXJuRm9ySW5jb21wbGV0ZUVudW1lcmF0aW9uKHJvdXRlLCBleHByZXNzaW9uLCBtaXNzaW5nUHJvcGVydGllcylcbiAgfSBlbHNlIHtcbiAgICB3YXJuRm9yU3luY0FjY2Vzcyhyb3V0ZSwgZXhwcmVzc2lvbilcbiAgfVxufVxuXG5jb25zdCB3YXJuRm9yU3luY0FjY2VzcyA9IGNyZWF0ZURlZHVwZWRCeUNhbGxzaXRlU2VydmVyRXJyb3JMb2dnZXJEZXYoXG4gIGNyZWF0ZVBhcmFtc0FjY2Vzc0Vycm9yXG4pXG5cbmNvbnN0IHdhcm5Gb3JJbmNvbXBsZXRlRW51bWVyYXRpb24gPVxuICBjcmVhdGVEZWR1cGVkQnlDYWxsc2l0ZVNlcnZlckVycm9yTG9nZ2VyRGV2KGNyZWF0ZUluY29tcGxldGVFbnVtZXJhdGlvbkVycm9yKVxuXG5mdW5jdGlvbiBjcmVhdGVQYXJhbXNBY2Nlc3NFcnJvcihcbiAgcm91dGU6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgZXhwcmVzc2lvbjogc3RyaW5nXG4pIHtcbiAgY29uc3QgcHJlZml4ID0gcm91dGUgPyBgUm91dGUgXCIke3JvdXRlfVwiIGAgOiAnVGhpcyByb3V0ZSAnXG4gIHJldHVybiBuZXcgRXJyb3IoXG4gICAgYCR7cHJlZml4fXVzZWQgJHtleHByZXNzaW9ufS4gYCArXG4gICAgICBgXFxgcGFyYW1zXFxgIHNob3VsZCBiZSBhd2FpdGVkIGJlZm9yZSB1c2luZyBpdHMgcHJvcGVydGllcy4gYCArXG4gICAgICBgTGVhcm4gbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvc3luYy1keW5hbWljLWFwaXNgXG4gIClcbn1cblxuZnVuY3Rpb24gY3JlYXRlSW5jb21wbGV0ZUVudW1lcmF0aW9uRXJyb3IoXG4gIHJvdXRlOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gIGV4cHJlc3Npb246IHN0cmluZyxcbiAgbWlzc2luZ1Byb3BlcnRpZXM6IEFycmF5PHN0cmluZz5cbikge1xuICBjb25zdCBwcmVmaXggPSByb3V0ZSA/IGBSb3V0ZSBcIiR7cm91dGV9XCIgYCA6ICdUaGlzIHJvdXRlICdcbiAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICBgJHtwcmVmaXh9dXNlZCAke2V4cHJlc3Npb259LiBgICtcbiAgICAgIGBcXGBwYXJhbXNcXGAgc2hvdWxkIGJlIGF3YWl0ZWQgYmVmb3JlIHVzaW5nIGl0cyBwcm9wZXJ0aWVzLiBgICtcbiAgICAgIGBUaGUgZm9sbG93aW5nIHByb3BlcnRpZXMgd2VyZSBub3QgYXZhaWxhYmxlIHRocm91Z2ggZW51bWVyYXRpb24gYCArXG4gICAgICBgYmVjYXVzZSB0aGV5IGNvbmZsaWN0IHdpdGggYnVpbHRpbiBwcm9wZXJ0eSBuYW1lczogYCArXG4gICAgICBgJHtkZXNjcmliZUxpc3RPZlByb3BlcnR5TmFtZXMobWlzc2luZ1Byb3BlcnRpZXMpfS4gYCArXG4gICAgICBgTGVhcm4gbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvc3luYy1keW5hbWljLWFwaXNgXG4gIClcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVMaXN0T2ZQcm9wZXJ0eU5hbWVzKHByb3BlcnRpZXM6IEFycmF5PHN0cmluZz4pIHtcbiAgc3dpdGNoIChwcm9wZXJ0aWVzLmxlbmd0aCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHRocm93IG5ldyBJbnZhcmlhbnRFcnJvcihcbiAgICAgICAgJ0V4cGVjdGVkIGRlc2NyaWJlTGlzdE9mUHJvcGVydHlOYW1lcyB0byBiZSBjYWxsZWQgd2l0aCBhIG5vbi1lbXB0eSBsaXN0IG9mIHN0cmluZ3MuJ1xuICAgICAgKVxuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiBgXFxgJHtwcm9wZXJ0aWVzWzBdfVxcYGBcbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gYFxcYCR7cHJvcGVydGllc1swXX1cXGAgYW5kIFxcYCR7cHJvcGVydGllc1sxXX1cXGBgXG4gICAgZGVmYXVsdDoge1xuICAgICAgbGV0IGRlc2NyaXB0aW9uID0gJydcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgZGVzY3JpcHRpb24gKz0gYFxcYCR7cHJvcGVydGllc1tpXX1cXGAsIGBcbiAgICAgIH1cbiAgICAgIGRlc2NyaXB0aW9uICs9IGAsIGFuZCBcXGAke3Byb3BlcnRpZXNbcHJvcGVydGllcy5sZW5ndGggLSAxXX1cXGBgXG4gICAgICByZXR1cm4gZGVzY3JpcHRpb25cbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJSZWZsZWN0QWRhcHRlciIsInRocm93VG9JbnRlcnJ1cHRTdGF0aWNHZW5lcmF0aW9uIiwicG9zdHBvbmVXaXRoVHJhY2tpbmciLCJ0cmFja1N5bmNocm9ub3VzUmVxdWVzdERhdGFBY2Nlc3NJbkRldiIsIndvcmtVbml0QXN5bmNTdG9yYWdlIiwiSW52YXJpYW50RXJyb3IiLCJkZXNjcmliZVN0cmluZ1Byb3BlcnR5QWNjZXNzIiwid2VsbEtub3duUHJvcGVydGllcyIsIm1ha2VIYW5naW5nUHJvbWlzZSIsImNyZWF0ZURlZHVwZWRCeUNhbGxzaXRlU2VydmVyRXJyb3JMb2dnZXJEZXYiLCJzY2hlZHVsZUltbWVkaWF0ZSIsImR5bmFtaWNBY2Nlc3NBc3luY1N0b3JhZ2UiLCJjcmVhdGVQYXJhbXNGcm9tQ2xpZW50IiwidW5kZXJseWluZ1BhcmFtcyIsIndvcmtTdG9yZSIsIndvcmtVbml0U3RvcmUiLCJnZXRTdG9yZSIsInR5cGUiLCJjcmVhdGVQcmVyZW5kZXJQYXJhbXMiLCJjcmVhdGVSZW5kZXJQYXJhbXMiLCJjcmVhdGVTZXJ2ZXJQYXJhbXNGb3JNZXRhZGF0YSIsImNyZWF0ZVNlcnZlclBhcmFtc0ZvclNlcnZlclNlZ21lbnQiLCJjcmVhdGVTZXJ2ZXJQYXJhbXNGb3JSb3V0ZSIsImNyZWF0ZVByZXJlbmRlclBhcmFtc0ZvckNsaWVudFNlZ21lbnQiLCJwcmVyZW5kZXJTdG9yZSIsImZhbGxiYWNrUGFyYW1zIiwiZmFsbGJhY2tSb3V0ZVBhcmFtcyIsImtleSIsImhhcyIsInJlbmRlclNpZ25hbCIsIlByb21pc2UiLCJyZXNvbHZlIiwiaGFzU29tZUZhbGxiYWNrUGFyYW1zIiwibWFrZUhhbmdpbmdQYXJhbXMiLCJtYWtlRXJyb3JpbmdFeG90aWNQYXJhbXMiLCJtYWtlVW50cmFja2VkRXhvdGljUGFyYW1zIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiaXNQcmVmZXRjaFJlcXVlc3QiLCJfX05FWFRfRFlOQU1JQ19JTyIsIm1ha2VEeW5hbWljYWxseVRyYWNrZWRQYXJhbXNXaXRoRGV2V2FybmluZ3MiLCJtYWtlRHluYW1pY2FsbHlUcmFja2VkRXhvdGljUGFyYW1zV2l0aERldldhcm5pbmdzIiwibWFrZVVudHJhY2tlZFBhcmFtcyIsIkNhY2hlZFBhcmFtcyIsIldlYWtNYXAiLCJmYWxsYmFja1BhcmFtc1Byb3h5SGFuZGxlciIsImdldCIsInRhcmdldCIsInByb3AiLCJyZWNlaXZlciIsIm9yaWdpbmFsTWV0aG9kIiwiYXJncyIsInN0b3JlIiwiYWJvcnRDb250cm9sbGVyIiwiYWJvcnQiLCJFcnJvciIsIlByb3h5IiwiYXBwbHkiLCJjYWNoZWRQYXJhbXMiLCJwcm9taXNlIiwic2V0IiwiYXVnbWVudGVkVW5kZXJseWluZyIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwiZGVmaW5lUHJvcGVydHkiLCJleHByZXNzaW9uIiwicm91dGUiLCJkeW5hbWljVHJhY2tpbmciLCJlbnVtZXJhYmxlIiwibmV3VmFsdWUiLCJ2YWx1ZSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwicHJveGllZFByb3BlcnRpZXMiLCJTZXQiLCJ1bnByb3hpZWRQcm9wZXJ0aWVzIiwicHVzaCIsImFkZCIsInByb3hpZWRQcm9taXNlIiwic3luY0lPRGV2IiwiZGVsZXRlIiwib3duS2V5cyIsIlJlZmxlY3QiLCJ3YXJuRm9yU3luY0FjY2VzcyIsIndhcm5Gb3JJbmNvbXBsZXRlRW51bWVyYXRpb24iLCJtaXNzaW5nUHJvcGVydGllcyIsInByZXJlbmRlclBoYXNlIiwicmVxdWVzdFN0b3JlIiwibGVuZ3RoIiwiY3JlYXRlUGFyYW1zQWNjZXNzRXJyb3IiLCJjcmVhdGVJbmNvbXBsZXRlRW51bWVyYXRpb25FcnJvciIsInByZWZpeCIsImRlc2NyaWJlTGlzdE9mUHJvcGVydHlOYW1lcyIsInByb3BlcnRpZXMiLCJkZXNjcmlwdGlvbiIsImkiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFHQSxTQUFTQSxj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Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDE5NDksICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2VzbS9jbGllbnQvY29tcG9uZW50cy9odHRwLWFjY2Vzcy1mYWxsYmFjay9lcnJvci1ib3VuZGFyeS5qcy9wcm94eS5janMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgeyBjcmVhdGVDbGllbnRNb2R1bGVQcm94eSB9ID0gcmVxdWlyZShcInJlYWN0LXNlcnZlci1kb20tdHVyYm9wYWNrL3NlcnZlclwiKTtcblxuX190dXJib3BhY2tfY29udGV4dF9fLm4oY3JlYXRlQ2xpZW50TW9kdWxlUHJveHkoXCJbcHJvamVjdF0vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9lc20vY2xpZW50L2NvbXBvbmVudHMvaHR0cC1hY2Nlc3MtZmFsbGJhY2svZXJyb3ItYm91bmRhcnkuanMgPG1vZHVsZSBldmFsdWF0aW9uPlwiKSk7XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsTUFBTSxFQUFFLHVCQUF1QixFQUFFO0FBRWpDLHNCQUFzQixDQUFDLENBQUMsd0JBQXdCIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDE5NTYsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2VzbS9jbGllbnQvY29tcG9uZW50cy9odHRwLWFjY2Vzcy1mYWxsYmFjay9lcnJvci1ib3VuZGFyeS5qcy9wcm94eS5janMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgeyBjcmVhdGVDbGllbnRNb2R1bGVQcm94eSB9ID0gcmVxdWlyZShcInJlYWN0LXNlcnZlci1kb20tdHVyYm9wYWNrL3NlcnZlclwiKTtcblxuX190dXJib3BhY2tfY29udGV4dF9fLm4oY3JlYXRlQ2xpZW50TW9kdWxlUHJveHkoXCJbcHJvamVjdF0vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9lc20vY2xpZW50L2NvbXBvbmVudHMvaHR0cC1hY2Nlc3MtZmFsbGJhY2svZXJyb3ItYm91bmRhcnkuanNcIikpO1xuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE1BQU0sRUFBRSx1QkFBdUIsRUFBRTtBQUVqQyxzQkFBc0IsQ0FBQyxDQUFDLHdCQUF3QiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxOTYyLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zcmMvY2xpZW50L2NvbXBvbmVudHMvaHR0cC1hY2Nlc3MtZmFsbGJhY2svZXJyb3ItYm91bmRhcnkudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuXG4vKipcbiAqIEhUVFBBY2Nlc3NGYWxsYmFja0JvdW5kYXJ5IGlzIGEgYm91bmRhcnkgdGhhdCBjYXRjaGVzIGVycm9ycyBhbmQgcmVuZGVycyBhXG4gKiBmYWxsYmFjayBjb21wb25lbnQgZm9yIEhUVFAgZXJyb3JzLlxuICpcbiAqIEl0IHJlY2VpdmVzIHRoZSBzdGF0dXMgY29kZSwgYW5kIGRldGVybWluZSBpZiBpdCBzaG91bGQgcmVuZGVyIGZhbGxiYWNrcyBmb3IgZmV3IEhUVFAgNHh4IGVycm9ycy5cbiAqXG4gKiBlLmcuIDQwNFxuICogNDA0IHJlcHJlc2VudHMgbm90IGZvdW5kLCBhbmQgdGhlIGZhbGxiYWNrIGNvbXBvbmVudCBwYWlyIGNvbnRhaW5zIHRoZSBjb21wb25lbnQgYW5kIGl0cyBzdHlsZXMuXG4gKlxuICovXG5cbmltcG9ydCBSZWFjdCwgeyB1c2VDb250ZXh0IH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyB1c2VVbnRyYWNrZWRQYXRobmFtZSB9IGZyb20gJy4uL25hdmlnYXRpb24tdW50cmFja2VkJ1xuaW1wb3J0IHtcbiAgSFRUUEFjY2Vzc0Vycm9yU3RhdHVzLFxuICBnZXRBY2Nlc3NGYWxsYmFja0hUVFBTdGF0dXMsXG4gIGdldEFjY2Vzc0ZhbGxiYWNrRXJyb3JUeXBlQnlTdGF0dXMsXG4gIGlzSFRUUEFjY2Vzc0ZhbGxiYWNrRXJyb3IsXG59IGZyb20gJy4vaHR0cC1hY2Nlc3MtZmFsbGJhY2snXG5pbXBvcnQgeyB3YXJuT25jZSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9saWIvdXRpbHMvd2Fybi1vbmNlJ1xuaW1wb3J0IHsgTWlzc2luZ1Nsb3RDb250ZXh0IH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5cbmludGVyZmFjZSBIVFRQQWNjZXNzRmFsbGJhY2tCb3VuZGFyeVByb3BzIHtcbiAgbm90Rm91bmQ/OiBSZWFjdC5SZWFjdE5vZGVcbiAgZm9yYmlkZGVuPzogUmVhY3QuUmVhY3ROb2RlXG4gIHVuYXV0aG9yaXplZD86IFJlYWN0LlJlYWN0Tm9kZVxuICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlXG4gIG1pc3NpbmdTbG90cz86IFNldDxzdHJpbmc+XG59XG5cbmludGVyZmFjZSBIVFRQQWNjZXNzRmFsbGJhY2tFcnJvckJvdW5kYXJ5UHJvcHNcbiAgZXh0ZW5kcyBIVFRQQWNjZXNzRmFsbGJhY2tCb3VuZGFyeVByb3BzIHtcbiAgcGF0aG5hbWU6IHN0cmluZyB8IG51bGxcbiAgbWlzc2luZ1Nsb3RzPzogU2V0PHN0cmluZz5cbn1cblxuaW50ZXJmYWNlIEhUVFBBY2Nlc3NCb3VuZGFyeVN0YXRlIHtcbiAgdHJpZ2dlcmVkU3RhdHVzOiBudW1iZXIgfCB1bmRlZmluZWRcbiAgcHJldmlvdXNQYXRobmFtZTogc3RyaW5nIHwgbnVsbFxufVxuXG5jbGFzcyBIVFRQQWNjZXNzRmFsbGJhY2tFcnJvckJvdW5kYXJ5IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFxuICBIVFRQQWNjZXNzRmFsbGJhY2tFcnJvckJvdW5kYXJ5UHJvcHMsXG4gIEhUVFBBY2Nlc3NCb3VuZGFyeVN0YXRlXG4+IHtcbiAgY29uc3RydWN0b3IocHJvcHM6IEhUVFBBY2Nlc3NGYWxsYmFja0Vycm9yQm91bmRhcnlQcm9wcykge1xuICAgIHN1cGVyKHByb3BzKVxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICB0cmlnZ2VyZWRTdGF0dXM6IHVuZGVmaW5lZCxcbiAgICAgIHByZXZpb3VzUGF0aG5hbWU6IHByb3BzLnBhdGhuYW1lLFxuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudERpZENhdGNoKCk6IHZvaWQge1xuICAgIGlmIChcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmXG4gICAgICB0aGlzLnByb3BzLm1pc3NpbmdTbG90cyAmJlxuICAgICAgdGhpcy5wcm9wcy5taXNzaW5nU2xvdHMuc2l6ZSA+IDAgJiZcbiAgICAgIC8vIEEgbWlzc2luZyBjaGlsZHJlbiBzbG90IGlzIHRoZSB0eXBpY2FsIG5vdC1mb3VuZCBjYXNlLCBzbyBubyBuZWVkIHRvIHdhcm5cbiAgICAgICF0aGlzLnByb3BzLm1pc3NpbmdTbG90cy5oYXMoJ2NoaWxkcmVuJylcbiAgICApIHtcbiAgICAgIGxldCB3YXJuaW5nTWVzc2FnZSA9XG4gICAgICAgICdObyBkZWZhdWx0IGNvbXBvbmVudCB3YXMgZm91bmQgZm9yIGEgcGFyYWxsZWwgcm91dGUgcmVuZGVyZWQgb24gdGhpcyBwYWdlLiBGYWxsaW5nIGJhY2sgdG8gbmVhcmVzdCBOb3RGb3VuZCBib3VuZGFyeS5cXG4nICtcbiAgICAgICAgJ0xlYXJuIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL3JvdXRpbmcvcGFyYWxsZWwtcm91dGVzI2RlZmF1bHRqc1xcblxcbidcblxuICAgICAgY29uc3QgZm9ybWF0dGVkU2xvdHMgPSBBcnJheS5mcm9tKHRoaXMucHJvcHMubWlzc2luZ1Nsb3RzKVxuICAgICAgICAuc29ydCgoYSwgYikgPT4gYS5sb2NhbGVDb21wYXJlKGIpKVxuICAgICAgICAubWFwKChzbG90KSA9PiBgQCR7c2xvdH1gKVxuICAgICAgICAuam9pbignLCAnKVxuXG4gICAgICB3YXJuaW5nTWVzc2FnZSArPSAnTWlzc2luZyBzbG90czogJyArIGZvcm1hdHRlZFNsb3RzXG5cbiAgICAgIHdhcm5PbmNlKHdhcm5pbmdNZXNzYWdlKVxuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoZXJyb3I6IGFueSkge1xuICAgIGlmIChpc0hUVFBBY2Nlc3NGYWxsYmFja0Vycm9yKGVycm9yKSkge1xuICAgICAgY29uc3QgaHR0cFN0YXR1cyA9IGdldEFjY2Vzc0ZhbGxiYWNrSFRUUFN0YXR1cyhlcnJvcilcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRyaWdnZXJlZFN0YXR1czogaHR0cFN0YXR1cyxcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUmUtdGhyb3cgaWYgZXJyb3IgaXMgbm90IGZvciA0MDRcbiAgICB0aHJvdyBlcnJvclxuICB9XG5cbiAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhcbiAgICBwcm9wczogSFRUUEFjY2Vzc0ZhbGxiYWNrRXJyb3JCb3VuZGFyeVByb3BzLFxuICAgIHN0YXRlOiBIVFRQQWNjZXNzQm91bmRhcnlTdGF0ZVxuICApOiBIVFRQQWNjZXNzQm91bmRhcnlTdGF0ZSB8IG51bGwge1xuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgcmVzZXQgb2YgdGhlIGVycm9yIGJvdW5kYXJ5IHdoZW4gYSBuYXZpZ2F0aW9uIGhhcHBlbnMuXG4gICAgICogRW5zdXJlcyB0aGUgZXJyb3IgYm91bmRhcnkgZG9lcyBub3Qgc3RheSBlbmFibGVkIHdoZW4gbmF2aWdhdGluZyB0byBhIG5ldyBwYWdlLlxuICAgICAqIEFwcHJvYWNoIG9mIHNldFN0YXRlIGluIHJlbmRlciBpcyBzYWZlIGFzIGl0IGNoZWNrcyB0aGUgcHJldmlvdXMgcGF0aG5hbWUgYW5kIHRoZW4gb3ZlcnJpZGVzXG4gICAgICogaXQgYXMgb3V0bGluZWQgaW4gaHR0cHM6Ly9yZWFjdC5kZXYvcmVmZXJlbmNlL3JlYWN0L3VzZVN0YXRlI3N0b3JpbmctaW5mb3JtYXRpb24tZnJvbS1wcmV2aW91cy1yZW5kZXJzXG4gICAgICovXG4gICAgaWYgKHByb3BzLnBhdGhuYW1lICE9PSBzdGF0ZS5wcmV2aW91c1BhdGhuYW1lICYmIHN0YXRlLnRyaWdnZXJlZFN0YXR1cykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHJpZ2dlcmVkU3RhdHVzOiB1bmRlZmluZWQsXG4gICAgICAgIHByZXZpb3VzUGF0aG5hbWU6IHByb3BzLnBhdGhuYW1lLFxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHJpZ2dlcmVkU3RhdHVzOiBzdGF0ZS50cmlnZ2VyZWRTdGF0dXMsXG4gICAgICBwcmV2aW91c1BhdGhuYW1lOiBwcm9wcy5wYXRobmFtZSxcbiAgICB9XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBub3RGb3VuZCwgZm9yYmlkZGVuLCB1bmF1dGhvcml6ZWQsIGNoaWxkcmVuIH0gPSB0aGlzLnByb3BzXG4gICAgY29uc3QgeyB0cmlnZ2VyZWRTdGF0dXMgfSA9IHRoaXMuc3RhdGVcbiAgICBjb25zdCBlcnJvckNvbXBvbmVudHMgPSB7XG4gICAgICBbSFRUUEFjY2Vzc0Vycm9yU3RhdHVzLk5PVF9GT1VORF06IG5vdEZvdW5kLFxuICAgICAgW0hUVFBBY2Nlc3NFcnJvclN0YXR1cy5GT1JCSURERU5dOiBmb3JiaWRkZW4sXG4gICAgICBbSFRUUEFjY2Vzc0Vycm9yU3RhdHVzLlVOQVVUSE9SSVpFRF06IHVuYXV0aG9yaXplZCxcbiAgICB9XG5cbiAgICBpZiAodHJpZ2dlcmVkU3RhdHVzKSB7XG4gICAgICBjb25zdCBpc05vdEZvdW5kID1cbiAgICAgICAgdHJpZ2dlcmVkU3RhdHVzID09PSBIVFRQQWNjZXNzRXJyb3JTdGF0dXMuTk9UX0ZPVU5EICYmIG5vdEZvdW5kXG4gICAgICBjb25zdCBpc0ZvcmJpZGRlbiA9XG4gICAgICAgIHRyaWdnZXJlZFN0YXR1cyA9PT0gSFRUUEFjY2Vzc0Vycm9yU3RhdHVzLkZPUkJJRERFTiAmJiBmb3JiaWRkZW5cbiAgICAgIGNvbnN0IGlzVW5hdXRob3JpemVkID1cbiAgICAgICAgdHJpZ2dlcmVkU3RhdHVzID09PSBIVFRQQWNjZXNzRXJyb3JTdGF0dXMuVU5BVVRIT1JJWkVEICYmIHVuYXV0aG9yaXplZFxuXG4gICAgICAvLyBJZiB0aGVyZSdzIG5vIG1hdGNoZWQgYm91bmRhcnkgaW4gdGhpcyBsYXllciwga2VlcCB0aHJvd2luZyB0aGUgZXJyb3IgYnkgcmVuZGVyaW5nIHRoZSBjaGlsZHJlblxuICAgICAgaWYgKCEoaXNOb3RGb3VuZCB8fCBpc0ZvcmJpZGRlbiB8fCBpc1VuYXV0aG9yaXplZCkpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuXG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoXG4gICAgICAgIDw+XG4gICAgICAgICAgPG1ldGEgbmFtZT1cInJvYm90c1wiIGNvbnRlbnQ9XCJub2luZGV4XCIgLz5cbiAgICAgICAgICB7cHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgKFxuICAgICAgICAgICAgPG1ldGFcbiAgICAgICAgICAgICAgbmFtZT1cImJvdW5kYXJ5LW5leHQtZXJyb3JcIlxuICAgICAgICAgICAgICBjb250ZW50PXtnZXRBY2Nlc3NGYWxsYmFja0Vycm9yVHlwZUJ5U3RhdHVzKHRyaWdnZXJlZFN0YXR1cyl9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICl9XG4gICAgICAgICAge2Vycm9yQ29tcG9uZW50c1t0cmlnZ2VyZWRTdGF0dXNdfVxuICAgICAgICA8Lz5cbiAgICAgIClcbiAgICB9XG5cbiAgICByZXR1cm4gY2hpbGRyZW5cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gSFRUUEFjY2Vzc0ZhbGxiYWNrQm91bmRhcnkoe1xuICBub3RGb3VuZCxcbiAgZm9yYmlkZGVuLFxuICB1bmF1dGhvcml6ZWQsXG4gIGNoaWxkcmVuLFxufTogSFRUUEFjY2Vzc0ZhbGxiYWNrQm91bmRhcnlQcm9wcykge1xuICAvLyBXaGVuIHdlJ3JlIHJlbmRlcmluZyB0aGUgbWlzc2luZyBwYXJhbXMgc2hlbGwsIHRoaXMgd2lsbCByZXR1cm4gbnVsbC4gVGhpc1xuICAvLyBpcyBiZWNhdXNlIHdlIHdvbid0IGJlIHJlbmRlcmluZyBhbnkgbm90IGZvdW5kIGJvdW5kYXJpZXMgb3IgZXJyb3JcbiAgLy8gYm91bmRhcmllcyBmb3IgdGhlIG1pc3NpbmcgcGFyYW1zIHNoZWxsLiBXaGVuIHRoaXMgcnVucyBvbiB0aGUgY2xpZW50XG4gIC8vICh3aGVyZSB0aGVzZSBlcnJvciBjYW4gb2NjdXIpLCB3ZSB3aWxsIGdldCB0aGUgY29ycmVjdCBwYXRobmFtZS5cbiAgY29uc3QgcGF0aG5hbWUgPSB1c2VVbnRyYWNrZWRQYXRobmFtZSgpXG4gIGNvbnN0IG1pc3NpbmdTbG90cyA9IHVzZUNvbnRleHQoTWlzc2luZ1Nsb3RDb250ZXh0KVxuICBjb25zdCBoYXNFcnJvckZhbGxiYWNrID0gISEobm90Rm91bmQgfHwgZm9yYmlkZGVuIHx8IHVuYXV0aG9yaXplZClcblxuICBpZiAoaGFzRXJyb3JGYWxsYmFjaykge1xuICAgIHJldHVybiAoXG4gICAgICA8SFRUUEFjY2Vzc0ZhbGxiYWNrRXJyb3JCb3VuZGFyeVxuICAgICAgICBwYXRobmFtZT17cGF0aG5hbWV9XG4gICAgICAgIG5vdEZvdW5kPXtub3RGb3VuZH1cbiAgICAgICAgZm9yYmlkZGVuPXtmb3JiaWRkZW59XG4gICAgICAgIHVuYXV0aG9yaXplZD17dW5hdXRob3JpemVkfVxuICAgICAgICBtaXNzaW5nU2xvdHM9e21pc3NpbmdTbG90c31cbiAgICAgID5cbiAgICAgICAge2NoaWxkcmVufVxuICAgICAgPC9IVFRQQWNjZXNzRmFsbGJhY2tFcnJvckJvdW5kYXJ5PlxuICAgIClcbiAgfVxuXG4gIHJldHVybiA8PntjaGlsZHJlbn08Lz5cbn1cbiJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZUNvbnRleHQiLCJ1c2VVbnRyYWNrZWRQYXRobmFtZSIsIkhUVFBBY2Nlc3NFcnJvclN0YXR1cyIsImdldEFjY2Vzc0ZhbGxiYWNrSFRUUFN0YXR1cyIsImdldEFjY2Vzc0ZhbGxiYWNrRXJyb3JUeXBlQnlTdGF0dXMiLCJpc0hUVFBBY2Nlc3NGYWxsYmFja0Vycm9yIiwid2Fybk9uY2UiLCJNaXNzaW5nU2xvdENvbnRleHQiLCJIVFRQQWNjZXNzRmFsbGJhY2tFcnJvckJvdW5kYXJ5IiwiQ29tcG9uZW50IiwiY29tcG9uZW50RGlkQ2F0Y2giLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJwcm9wcyIsIm1pc3NpbmdTbG90cyIsInNpemUiLCJoYXMiLCJ3YXJuaW5nTWVzc2FnZSIsImZvcm1hdHRlZFNsb3RzIiwiQXJyYXkiLCJmcm9tIiwic29ydCIsImEiLCJiIiwibG9jYWxlQ29tcGFyZSIsIm1hcCIsInNsb3QiLCJqb2luIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIiwiZXJyb3IiLCJodHRwU3RhdHVzIiwidHJpZ2dlcmVkU3RhdHVzIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwic3RhdGUiLCJwYXRobmFtZSIsInByZXZpb3VzUGF0aG5hbWUiLCJ1bmRlZmluZWQiLCJyZW5kZXIiLCJub3RGb3VuZCIsImZvcmJpZGRlbiIsInVuYXV0aG9yaXplZCIsImNoaWxkcmVuIiwiZXJyb3JDb21wb25lbnRzIiwiTk9UX0ZPVU5EIiwiRk9SQklEREVOIiwiVU5BVVRIT1JJWkVEIiwiaXNOb3RGb3VuZCIsImlzRm9yYmlkZGVuIiwiaXNVbmF1dGhvcml6ZWQiLCJtZXRhIiwibmFtZSIsImNvbnRlbnQiLCJjb25zdHJ1Y3RvciIsIkhUVFBBY2Nlc3NGYWxsYmFja0JvdW5kYXJ5IiwiaGFzRXJyb3JGYWxsYmFjayJdLCJtYXBwaW5ncyI6IiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxOTcyLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL3NlcnZlci9yb3V0ZS1tb2R1bGVzL2FwcC1wYWdlL3ZlbmRvcmVkL3JzYy9yZWFjdC1qc3gtcnVudGltZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IChcbiAgcmVxdWlyZSgnLi4vLi4vbW9kdWxlLmNvbXBpbGVkJykgYXMgdHlwZW9mIGltcG9ydCgnLi4vLi4vbW9kdWxlLmNvbXBpbGVkJylcbikudmVuZG9yZWRbJ3JlYWN0LXJzYyddIS5SZWFjdEpzeFJ1bnRpbWVcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSIsInZlbmRvcmVkIiwiUmVhY3RKc3hSdW50aW1lIl0sIm1hcHBpbmdzIjoiQUFBQUEsT0FBT0MsT0FBTyxHQUNaQyxRQUFRLDRIQUNSQyxRQUFRLENBQUMsWUFBWSxDQUFFQyxlQUFlIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDE5NzcsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NyYy9saWIvbm9uLW51bGxhYmxlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBub25OdWxsYWJsZTxUPih2YWx1ZTogVCk6IHZhbHVlIGlzIE5vbk51bGxhYmxlPFQ+IHtcbiAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWRcbn1cbiJdLCJuYW1lcyI6WyJub25OdWxsYWJsZSIsInZhbHVlIiwidW5kZWZpbmVkIl0sIm1hcHBpbmdzIjoiOzs7QUFBTyxTQUFTQSxZQUFlQyxLQUFRO0lBQ3JDLE9BQU9BLFVBQVUsUUFBUUEsVUFBVUM7QUFDckMiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTk4NywgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL2xpYi9tZXRhZGF0YS9nZW5lcmF0ZS9tZXRhLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBub25OdWxsYWJsZSB9IGZyb20gJy4uLy4uL25vbi1udWxsYWJsZSdcblxuZXhwb3J0IGZ1bmN0aW9uIE1ldGEoe1xuICBuYW1lLFxuICBwcm9wZXJ0eSxcbiAgY29udGVudCxcbiAgbWVkaWEsXG59OiB7XG4gIG5hbWU/OiBzdHJpbmdcbiAgcHJvcGVydHk/OiBzdHJpbmdcbiAgbWVkaWE/OiBzdHJpbmdcbiAgY29udGVudDogc3RyaW5nIHwgbnVtYmVyIHwgVVJMIHwgbnVsbCB8IHVuZGVmaW5lZFxufSk6IFJlYWN0LlJlYWN0RWxlbWVudCB8IG51bGwge1xuICBpZiAodHlwZW9mIGNvbnRlbnQgIT09ICd1bmRlZmluZWQnICYmIGNvbnRlbnQgIT09IG51bGwgJiYgY29udGVudCAhPT0gJycpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPG1ldGFcbiAgICAgICAgey4uLihuYW1lID8geyBuYW1lIH0gOiB7IHByb3BlcnR5IH0pfVxuICAgICAgICB7Li4uKG1lZGlhID8geyBtZWRpYSB9IDogdW5kZWZpbmVkKX1cbiAgICAgICAgY29udGVudD17dHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnID8gY29udGVudCA6IGNvbnRlbnQudG9TdHJpbmcoKX1cbiAgICAgIC8+XG4gICAgKVxuICB9XG4gIHJldHVybiBudWxsXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBNZXRhRmlsdGVyPFQgZXh0ZW5kcyB7fSB8IHt9W10+KFxuICBpdGVtczogKFQgfCBudWxsKVtdXG4pOiBOb25OdWxsYWJsZTxUPltdIHtcbiAgY29uc3QgYWNjOiBOb25OdWxsYWJsZTxUPltdID0gW11cbiAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgIGFjYy5wdXNoKC4uLml0ZW0uZmlsdGVyKG5vbk51bGxhYmxlKSlcbiAgICB9IGVsc2UgaWYgKG5vbk51bGxhYmxlKGl0ZW0pKSB7XG4gICAgICBhY2MucHVzaChpdGVtKVxuICAgIH1cbiAgfVxuICByZXR1cm4gYWNjXG59XG5cbnR5cGUgRXh0ZW5kTWV0YUNvbnRlbnQgPSBSZWNvcmQ8XG4gIHN0cmluZyxcbiAgdW5kZWZpbmVkIHwgc3RyaW5nIHwgVVJMIHwgbnVtYmVyIHwgYm9vbGVhbiB8IG51bGwgfCB1bmRlZmluZWRcbj5cbnR5cGUgTXVsdGlNZXRhQ29udGVudCA9XG4gIHwgKEV4dGVuZE1ldGFDb250ZW50IHwgc3RyaW5nIHwgVVJMIHwgbnVtYmVyKVtdXG4gIHwgbnVsbFxuICB8IHVuZGVmaW5lZFxuXG5mdW5jdGlvbiBjYW1lbFRvU25ha2UoY2FtZWxDYXNlU3RyOiBzdHJpbmcpIHtcbiAgcmV0dXJuIGNhbWVsQ2FzZVN0ci5yZXBsYWNlKC8oW0EtWl0pL2csIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHJldHVybiAnXycgKyBtYXRjaC50b0xvd2VyQ2FzZSgpXG4gIH0pXG59XG5cbmNvbnN0IGFsaWFzUHJvcFByZWZpeGVzID0gbmV3IFNldChbXG4gICdvZzppbWFnZScsXG4gICd0d2l0dGVyOmltYWdlJyxcbiAgJ29nOnZpZGVvJyxcbiAgJ29nOmF1ZGlvJyxcbl0pXG5mdW5jdGlvbiBnZXRNZXRhS2V5KHByZWZpeDogc3RyaW5nLCBrZXk6IHN0cmluZykge1xuICAvLyBVc2UgYHR3aXR0ZXI6aW1hZ2VgIGFuZCBgb2c6aW1hZ2VgIGluc3RlYWQgb2YgYHR3aXR0ZXI6aW1hZ2U6dXJsYCBhbmQgYG9nOmltYWdlOnVybGBcbiAgLy8gdG8gYmUgbW9yZSBjb21wYXRpYmxlIGFzIGl0J3MgYSBtb3JlIGNvbW1vbiBmb3JtYXQuXG4gIC8vIGBvZzp2aWRlb2AgJiBgb2c6YXVkaW9gIGRvIG5vdCBoYXZlIGEgYDp1cmxgIHN1ZmZpeCBhbGlhc1xuICBpZiAoYWxpYXNQcm9wUHJlZml4ZXMuaGFzKHByZWZpeCkgJiYga2V5ID09PSAndXJsJykge1xuICAgIHJldHVybiBwcmVmaXhcbiAgfVxuICBpZiAocHJlZml4LnN0YXJ0c1dpdGgoJ29nOicpIHx8IHByZWZpeC5zdGFydHNXaXRoKCd0d2l0dGVyOicpKSB7XG4gICAga2V5ID0gY2FtZWxUb1NuYWtlKGtleSlcbiAgfVxuICByZXR1cm4gcHJlZml4ICsgJzonICsga2V5XG59XG5cbmZ1bmN0aW9uIEV4dGVuZE1ldGEoe1xuICBjb250ZW50LFxuICBuYW1lUHJlZml4LFxuICBwcm9wZXJ0eVByZWZpeCxcbn06IHtcbiAgY29udGVudD86IEV4dGVuZE1ldGFDb250ZW50XG4gIG5hbWVQcmVmaXg/OiBzdHJpbmdcbiAgcHJvcGVydHlQcmVmaXg/OiBzdHJpbmdcbn0pIHtcbiAgaWYgKCFjb250ZW50KSByZXR1cm4gbnVsbFxuICByZXR1cm4gTWV0YUZpbHRlcihcbiAgICBPYmplY3QuZW50cmllcyhjb250ZW50KS5tYXAoKFtrLCB2XSkgPT4ge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2ID09PSAndW5kZWZpbmVkJ1xuICAgICAgICA/IG51bGxcbiAgICAgICAgOiBNZXRhKHtcbiAgICAgICAgICAgIC4uLihwcm9wZXJ0eVByZWZpeCAmJiB7IHByb3BlcnR5OiBnZXRNZXRhS2V5KHByb3BlcnR5UHJlZml4LCBrKSB9KSxcbiAgICAgICAgICAgIC4uLihuYW1lUHJlZml4ICYmIHsgbmFtZTogZ2V0TWV0YUtleShuYW1lUHJlZml4LCBrKSB9KSxcbiAgICAgICAgICAgIGNvbnRlbnQ6IHR5cGVvZiB2ID09PSAnc3RyaW5nJyA/IHYgOiB2Py50b1N0cmluZygpLFxuICAgICAgICAgIH0pXG4gICAgfSlcbiAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gTXVsdGlNZXRhKHtcbiAgcHJvcGVydHlQcmVmaXgsXG4gIG5hbWVQcmVmaXgsXG4gIGNvbnRlbnRzLFxufToge1xuICBwcm9wZXJ0eVByZWZpeD86IHN0cmluZ1xuICBuYW1lUHJlZml4Pzogc3RyaW5nXG4gIGNvbnRlbnRzPzogTXVsdGlNZXRhQ29udGVudCB8IG51bGxcbn0pIHtcbiAgaWYgKHR5cGVvZiBjb250ZW50cyA9PT0gJ3VuZGVmaW5lZCcgfHwgY29udGVudHMgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgcmV0dXJuIE1ldGFGaWx0ZXIoXG4gICAgY29udGVudHMubWFwKChjb250ZW50KSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgIHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJyB8fFxuICAgICAgICB0eXBlb2YgY29udGVudCA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgY29udGVudCBpbnN0YW5jZW9mIFVSTFxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBNZXRhKHtcbiAgICAgICAgICAuLi4ocHJvcGVydHlQcmVmaXhcbiAgICAgICAgICAgID8geyBwcm9wZXJ0eTogcHJvcGVydHlQcmVmaXggfVxuICAgICAgICAgICAgOiB7IG5hbWU6IG5hbWVQcmVmaXggfSksXG4gICAgICAgICAgY29udGVudCxcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBFeHRlbmRNZXRhKHtcbiAgICAgICAgICBuYW1lUHJlZml4LFxuICAgICAgICAgIHByb3BlcnR5UHJlZml4LFxuICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSlcbiAgKVxufVxuIl0sIm5hbWVzIjpbIlJlYWN0Iiwibm9uTnVsbGFibGUiLCJNZXRhIiwibmFtZSIsInByb3BlcnR5IiwiY29udGVudCIsIm1lZGlhIiwibWV0YSIsInVuZGVmaW5lZCIsInRvU3RyaW5nIiwiTWV0YUZpbHRlciIsIml0ZW1zIiwiYWNjIiwiaXRlbSIsIkFycmF5IiwiaXNBcnJheSIsInB1c2giLCJmaWx0ZXIiLCJjYW1lbFRvU25ha2UiLCJjYW1lbENhc2VTdHIiLCJyZXBsYWNlIiwibWF0Y2giLCJ0b0xvd2VyQ2FzZSIsImFsaWFzUHJvcFByZWZpeGVzIiwiU2V0IiwiZ2V0TWV0YUtleSIsInByZWZpeCIsImtleSIsImhhcyIsInN0YXJ0c1dpdGgiLCJFeHRlbmRNZXRhIiwibmFtZVByZWZpeCIsInByb3BlcnR5UHJlZml4IiwiT2JqZWN0IiwiZW50cmllcyIsIm1hcCIsImsiLCJ2IiwiTXVsdGlNZXRhIiwiY29udGVudHMiLCJVUkwiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLE9BQU9BLFdBQVcsUUFBTztBQUN6QixTQUFTQyxXQUFXLFFBQVEscUJBQW9COzs7O0FBRXpDLFNBQVNDLEtBQUssRUFDbkJDLElBQUksRUFDSkMsUUFBUSxFQUNSQyxPQUFPLEVBQ1BDLEtBQUssRUFNTjtJQUNDLElBQUksT0FBT0QsWUFBWSxlQUFlQSxZQUFZLFFBQVFBLFlBQVksSUFBSTtRQUN4RSxPQUFBLFdBQUEsOE5BQ0UsT0FBQSxFQUFDRSxRQUFBQTtZQUNFLEdBQUlKLE9BQU87Z0JBQUVBO1lBQUssSUFBSTtnQkFBRUM7WUFBUyxDQUFDO1lBQ2xDLEdBQUlFLFFBQVE7Z0JBQUVBO1lBQU0sSUFBSUUsU0FBUztZQUNsQ0gsU0FBUyxPQUFPQSxZQUFZLFdBQVdBLFVBQVVBLFFBQVFJLFFBQVE7O0lBR3ZFO0lBQ0EsT0FBTztBQUNUO0FBRU8sU0FBU0MsV0FDZEMsS0FBbUI7SUFFbkIsTUFBTUMsTUFBd0IsRUFBRTtJQUNoQyxLQUFLLE1BQU1DLFFBQVFGLE1BQU87UUFDeEIsSUFBSUcsTUFBTUMsT0FBTyxDQUFDRixPQUFPO1lBQ3ZCRCxJQUFJSSxJQUFJLElBQUlILEtBQUtJLE1BQU0sK0pBQUNoQixjQUFBQTtRQUMxQixPQUFPLElBQUlBLGdMQUFBQSxFQUFZWSxPQUFPO1lBQzVCRCxJQUFJSSxJQUFJLENBQUNIO1FBQ1g7SUFDRjtJQUNBLE9BQU9EO0FBQ1Q7QUFXQSxTQUFTTSxhQUFhQyxZQUFvQjtJQUN4QyxPQUFPQSxhQUFhQyxPQUFPLENBQUMsWUFBWSxTQUFVQyxLQUFLO1FBQ3JELE9BQU8sTUFBTUEsTUFBTUMsV0FBVztJQUNoQztBQUNGO0FBRUEsTUFBTUMsb0JBQW9CLElBQUlDLElBQUk7SUFDaEM7SUFDQTtJQUNBO0lBQ0E7Q0FDRDtBQUNELFNBQVNDLFdBQVdDLE1BQWMsRUFBRUMsR0FBVztJQUM3Qyx1RkFBdUY7SUFDdkYsc0RBQXNEO0lBQ3RELDREQUE0RDtJQUM1RCxJQUFJSixrQkFBa0JLLEdBQUcsQ0FBQ0YsV0FBV0MsUUFBUSxPQUFPO1FBQ2xELE9BQU9EO0lBQ1Q7SUFDQSxJQUFJQSxPQUFPRyxVQUFVLENBQUMsVUFBVUgsT0FBT0csVUFBVSxDQUFDLGFBQWE7UUFDN0RGLE1BQU1ULGFBQWFTO0lBQ3JCO0lBQ0EsT0FBT0QsU0FBUyxNQUFNQztBQUN4QjtBQUVBLFNBQVNHLFdBQVcsRUFDbEJ6QixPQUFPLEVBQ1AwQixVQUFVLEVBQ1ZDLGNBQWMsRUFLZjtJQUNDLElBQUksQ0FBQzNCLFNBQVMsT0FBTztJQUNyQixPQUFPSyxXQUNMdUIsT0FBT0MsT0FBTyxDQUFDN0IsU0FBUzhCLEdBQUcsQ0FBQyxDQUFDLENBQUNDLEdBQUdDLEVBQUU7UUFDakMsT0FBTyxPQUFPQSxNQUFNLGNBQ2hCLE9BQ0FuQyxLQUFLO1lBQ0gsR0FBSThCLGtCQUFrQjtnQkFBRTVCLFVBQVVxQixXQUFXTyxnQkFBZ0JJO1lBQUcsQ0FBQztZQUNqRSxHQUFJTCxjQUFjO2dCQUFFNUIsTUFBTXNCLFdBQVdNLFlBQVlLO1lBQUcsQ0FBQztZQUNyRC9CLFNBQVMsT0FBT2dDLE1BQU0sV0FBV0EsSUFBSUEsS0FBQUEsT0FBQUEsS0FBQUEsSUFBQUEsRUFBRzVCLFFBQVE7UUFDbEQ7SUFDTjtBQUVKO0FBRU8sU0FBUzZCLFVBQVUsRUFDeEJOLGNBQWMsRUFDZEQsVUFBVSxFQUNWUSxRQUFRLEVBS1Q7SUFDQyxJQUFJLE9BQU9BLGFBQWEsZUFBZUEsYUFBYSxNQUFNO1FBQ3hELE9BQU87SUFDVDtJQUVBLE9BQU83QixXQUNMNkIsU0FBU0osR0FBRyxDQUFDLENBQUM5QjtRQUNaLElBQ0UsT0FBT0EsWUFBWSxZQUNuQixPQUFPQSxZQUFZLFlBQ25CQSxtQkFBbUJtQyxLQUNuQjtZQUNBLE9BQU90QyxLQUFLO2dCQUNWLEdBQUk4QixpQkFDQTtvQkFBRTVCLFVBQVU0QjtnQkFBZSxJQUMzQjtvQkFBRTdCLE1BQU00QjtnQkFBVyxDQUFDO2dCQUN4QjFCO1lBQ0Y7UUFDRixPQUFPO1lBQ0wsT0FBT3lCLFdBQVc7Z0JBQ2hCQztnQkFDQUM7Z0JBQ0EzQjtZQUNGO1FBQ0Y7SUFDRjtBQUVKIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDIwODksICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NyYy9saWIvbWV0YWRhdGEvY29uc3RhbnRzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgVmlld3BvcnRMYXlvdXQgfSBmcm9tICcuL3R5cGVzL2V4dHJhLXR5cGVzJ1xuaW1wb3J0IHR5cGUgeyBJY29ucyB9IGZyb20gJy4vdHlwZXMvbWV0YWRhdGEtdHlwZXMnXG5cbmV4cG9ydCBjb25zdCBWaWV3cG9ydE1ldGFLZXlzOiB7IFtrIGluIGtleW9mIFZpZXdwb3J0TGF5b3V0XTogc3RyaW5nIH0gPSB7XG4gIHdpZHRoOiAnd2lkdGgnLFxuICBoZWlnaHQ6ICdoZWlnaHQnLFxuICBpbml0aWFsU2NhbGU6ICdpbml0aWFsLXNjYWxlJyxcbiAgbWluaW11bVNjYWxlOiAnbWluaW11bS1zY2FsZScsXG4gIG1heGltdW1TY2FsZTogJ21heGltdW0tc2NhbGUnLFxuICB2aWV3cG9ydEZpdDogJ3ZpZXdwb3J0LWZpdCcsXG4gIHVzZXJTY2FsYWJsZTogJ3VzZXItc2NhbGFibGUnLFxuICBpbnRlcmFjdGl2ZVdpZGdldDogJ2ludGVyYWN0aXZlLXdpZGdldCcsXG59IGFzIGNvbnN0XG5cbmV4cG9ydCBjb25zdCBJY29uS2V5czogKGtleW9mIEljb25zKVtdID0gWydpY29uJywgJ3Nob3J0Y3V0JywgJ2FwcGxlJywgJ290aGVyJ11cbiJdLCJuYW1lcyI6WyJWaWV3cG9ydE1ldGFLZXlzIiwid2lkdGgiLCJoZWlnaHQiLCJpbml0aWFsU2NhbGUiLCJtaW5pbXVtU2NhbGUiLCJtYXhpbXVtU2NhbGUiLCJ2aWV3cG9ydEZpdCIsInVzZXJTY2FsYWJsZSIsImludGVyYWN0aXZlV2lkZ2V0IiwiSWNvbktleXMiXSwibWFwcGluZ3MiOiI7Ozs7QUFHTyxNQUFNQSxtQkFBNEQ7SUFDdkVDLE9BQU87SUFDUEMsUUFBUTtJQUNSQyxjQUFjO0lBQ2RDLGNBQWM7SUFDZEMsY0FBYztJQUNkQyxhQUFhO0lBQ2JDLGNBQWM7SUFDZEMsbUJBQW1CO0FBQ3JCLEVBQVU7QUFFSCxNQUFNQyxXQUE0QjtJQUFDO0lBQVE7SUFBWTtJQUFTO0NBQVEsQ0FBQSIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAyMTEzLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zcmMvbGliL21ldGFkYXRhL2dlbmVyYXRlL3V0aWxzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIHJlc29sdmVBcnJheTxUPih2YWx1ZTogVCB8IFRbXSk6IFRbXSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZSBhcyBhbnlcbiAgfVxuICByZXR1cm4gW3ZhbHVlXSBhcyBhbnlcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUFzQXJyYXlPclVuZGVmaW5lZDxUPihcbiAgdmFsdWU6IFQgfCBUW10gfCB1bmRlZmluZWQgfCBudWxsXG4pOiBUIGV4dGVuZHMgdW5kZWZpbmVkIHwgbnVsbCA/IHVuZGVmaW5lZCA6IFRbXSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZCBhcyBhbnlcbiAgfVxuICByZXR1cm4gcmVzb2x2ZUFycmF5KHZhbHVlKSBhcyBhbnlcbn1cblxuZnVuY3Rpb24gZ2V0T3JpZ2luKHVybDogc3RyaW5nIHwgVVJMKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgbGV0IG9yaWdpbiA9IHVuZGVmaW5lZFxuICBpZiAodHlwZW9mIHVybCA9PT0gJ3N0cmluZycpIHtcbiAgICB0cnkge1xuICAgICAgdXJsID0gbmV3IFVSTCh1cmwpXG4gICAgICBvcmlnaW4gPSB1cmwub3JpZ2luXG4gICAgfSBjYXRjaCB7fVxuICB9XG4gIHJldHVybiBvcmlnaW5cbn1cblxuZXhwb3J0IHsgcmVzb2x2ZUFzQXJyYXlPclVuZGVmaW5lZCwgcmVzb2x2ZUFycmF5LCBnZXRPcmlnaW4gfVxuIl0sIm5hbWVzIjpbInJlc29sdmVBcnJheSIsInZhbHVlIiwiQXJyYXkiLCJpc0FycmF5IiwicmVzb2x2ZUFzQXJyYXlPclVuZGVmaW5lZCIsInVuZGVmaW5lZCIsImdldE9yaWdpbiIsInVybCIsIm9yaWdpbiIsIlVSTCJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxTQUFTQSxhQUFnQkMsS0FBYztJQUNyQyxJQUFJQyxNQUFNQyxPQUFPLENBQUNGLFFBQVE7UUFDeEIsT0FBT0E7SUFDVDtJQUNBLE9BQU87UUFBQ0E7S0FBTTtBQUNoQjtBQUVBLFNBQVNHLDBCQUNQSCxLQUFpQztJQUVqQyxJQUFJLE9BQU9BLFVBQVUsZUFBZUEsVUFBVSxNQUFNO1FBQ2xELE9BQU9JO0lBQ1Q7SUFDQSxPQUFPTCxhQUFhQztBQUN0QjtBQUVBLFNBQVNLLFVBQVVDLEdBQWlCO0lBQ2xDLElBQUlDLFNBQVNIO0lBQ2IsSUFBSSxPQUFPRSxRQUFRLFVBQVU7UUFDM0IsSUFBSTtZQUNGQSxNQUFNLElBQUlFLElBQUlGO1lBQ2RDLFNBQVNELElBQUlDLE1BQU07UUFDckIsRUFBRSxPQUFNLENBQUM7SUFDWDtJQUNBLE9BQU9BO0FBQ1QiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMjE0OCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL2xpYi9tZXRhZGF0YS9nZW5lcmF0ZS9iYXNpYy50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUge1xuICBSZXNvbHZlZE1ldGFkYXRhLFxuICBSZXNvbHZlZFZpZXdwb3J0LFxuICBWaWV3cG9ydCxcbn0gZnJvbSAnLi4vdHlwZXMvbWV0YWRhdGEtaW50ZXJmYWNlJ1xuaW1wb3J0IHR5cGUgeyBWaWV3cG9ydExheW91dCB9IGZyb20gJy4uL3R5cGVzL2V4dHJhLXR5cGVzJ1xuXG5pbXBvcnQgeyBNZXRhLCBNZXRhRmlsdGVyLCBNdWx0aU1ldGEgfSBmcm9tICcuL21ldGEnXG5pbXBvcnQgeyBWaWV3cG9ydE1ldGFLZXlzIH0gZnJvbSAnLi4vY29uc3RhbnRzJ1xuaW1wb3J0IHsgZ2V0T3JpZ2luIH0gZnJvbSAnLi91dGlscydcblxuLy8gY29udmVydCB2aWV3cG9ydCBvYmplY3QgdG8gc3RyaW5nIGZvciB2aWV3cG9ydCBtZXRhIHRhZ1xuZnVuY3Rpb24gcmVzb2x2ZVZpZXdwb3J0TGF5b3V0KHZpZXdwb3J0OiBWaWV3cG9ydCkge1xuICBsZXQgcmVzb2x2ZWQ6IHN0cmluZyB8IG51bGwgPSBudWxsXG5cbiAgaWYgKHZpZXdwb3J0ICYmIHR5cGVvZiB2aWV3cG9ydCA9PT0gJ29iamVjdCcpIHtcbiAgICByZXNvbHZlZCA9ICcnXG4gICAgZm9yIChjb25zdCB2aWV3cG9ydEtleV8gaW4gVmlld3BvcnRNZXRhS2V5cykge1xuICAgICAgY29uc3Qgdmlld3BvcnRLZXkgPSB2aWV3cG9ydEtleV8gYXMga2V5b2YgVmlld3BvcnRMYXlvdXRcbiAgICAgIGlmICh2aWV3cG9ydEtleSBpbiB2aWV3cG9ydCkge1xuICAgICAgICBsZXQgdmFsdWUgPSB2aWV3cG9ydFt2aWV3cG9ydEtleV1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZSA/ICd5ZXMnIDogJ25vJ1xuICAgICAgICB9IGVsc2UgaWYgKCF2YWx1ZSAmJiB2aWV3cG9ydEtleSA9PT0gJ2luaXRpYWxTY2FsZScpIHtcbiAgICAgICAgICB2YWx1ZSA9IHVuZGVmaW5lZFxuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIGlmIChyZXNvbHZlZCkgcmVzb2x2ZWQgKz0gJywgJ1xuICAgICAgICAgIHJlc29sdmVkICs9IGAke1ZpZXdwb3J0TWV0YUtleXNbdmlld3BvcnRLZXldfT0ke3ZhbHVlfWBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzb2x2ZWRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFZpZXdwb3J0TWV0YSh7IHZpZXdwb3J0IH06IHsgdmlld3BvcnQ6IFJlc29sdmVkVmlld3BvcnQgfSkge1xuICByZXR1cm4gTWV0YUZpbHRlcihbXG4gICAgPG1ldGEgY2hhclNldD1cInV0Zi04XCIgLz4sXG4gICAgTWV0YSh7IG5hbWU6ICd2aWV3cG9ydCcsIGNvbnRlbnQ6IHJlc29sdmVWaWV3cG9ydExheW91dCh2aWV3cG9ydCkgfSksXG4gICAgLi4uKHZpZXdwb3J0LnRoZW1lQ29sb3JcbiAgICAgID8gdmlld3BvcnQudGhlbWVDb2xvci5tYXAoKHRoZW1lQ29sb3IpID0+XG4gICAgICAgICAgTWV0YSh7XG4gICAgICAgICAgICBuYW1lOiAndGhlbWUtY29sb3InLFxuICAgICAgICAgICAgY29udGVudDogdGhlbWVDb2xvci5jb2xvcixcbiAgICAgICAgICAgIG1lZGlhOiB0aGVtZUNvbG9yLm1lZGlhLFxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgIDogW10pLFxuICAgIE1ldGEoeyBuYW1lOiAnY29sb3Itc2NoZW1lJywgY29udGVudDogdmlld3BvcnQuY29sb3JTY2hlbWUgfSksXG4gIF0pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBCYXNpY01ldGEoeyBtZXRhZGF0YSB9OiB7IG1ldGFkYXRhOiBSZXNvbHZlZE1ldGFkYXRhIH0pIHtcbiAgY29uc3QgbWFuaWZlc3RPcmlnaW4gPSBtZXRhZGF0YS5tYW5pZmVzdFxuICAgID8gZ2V0T3JpZ2luKG1ldGFkYXRhLm1hbmlmZXN0KVxuICAgIDogdW5kZWZpbmVkXG5cbiAgcmV0dXJuIE1ldGFGaWx0ZXIoW1xuICAgIG1ldGFkYXRhLnRpdGxlICE9PSBudWxsICYmIG1ldGFkYXRhLnRpdGxlLmFic29sdXRlID8gKFxuICAgICAgPHRpdGxlPnttZXRhZGF0YS50aXRsZS5hYnNvbHV0ZX08L3RpdGxlPlxuICAgICkgOiBudWxsLFxuICAgIE1ldGEoeyBuYW1lOiAnZGVzY3JpcHRpb24nLCBjb250ZW50OiBtZXRhZGF0YS5kZXNjcmlwdGlvbiB9KSxcbiAgICBNZXRhKHsgbmFtZTogJ2FwcGxpY2F0aW9uLW5hbWUnLCBjb250ZW50OiBtZXRhZGF0YS5hcHBsaWNhdGlvbk5hbWUgfSksXG4gICAgLi4uKG1ldGFkYXRhLmF1dGhvcnNcbiAgICAgID8gbWV0YWRhdGEuYXV0aG9ycy5tYXAoKGF1dGhvcikgPT4gW1xuICAgICAgICAgIGF1dGhvci51cmwgPyAoXG4gICAgICAgICAgICA8bGluayByZWw9XCJhdXRob3JcIiBocmVmPXthdXRob3IudXJsLnRvU3RyaW5nKCl9IC8+XG4gICAgICAgICAgKSA6IG51bGwsXG4gICAgICAgICAgTWV0YSh7IG5hbWU6ICdhdXRob3InLCBjb250ZW50OiBhdXRob3IubmFtZSB9KSxcbiAgICAgICAgXSlcbiAgICAgIDogW10pLFxuICAgIG1ldGFkYXRhLm1hbmlmZXN0ID8gKFxuICAgICAgPGxpbmtcbiAgICAgICAgcmVsPVwibWFuaWZlc3RcIlxuICAgICAgICBocmVmPXttZXRhZGF0YS5tYW5pZmVzdC50b1N0cmluZygpfVxuICAgICAgICAvLyBJZiBpdCdzIHNhbWUgb3JpZ2luLCBhbmQgaXQncyBhIHByZXZpZXcgZGVwbG95bWVudCxcbiAgICAgICAgLy8gaW5jbHVkaW5nIGNyZWRlbnRpYWxzIGZvciBtYW5pZmVzdCByZXF1ZXN0LlxuICAgICAgICBjcm9zc09yaWdpbj17XG4gICAgICAgICAgIW1hbmlmZXN0T3JpZ2luICYmIHByb2Nlc3MuZW52LlZFUkNFTF9FTlYgPT09ICdwcmV2aWV3J1xuICAgICAgICAgICAgPyAndXNlLWNyZWRlbnRpYWxzJ1xuICAgICAgICAgICAgOiB1bmRlZmluZWRcbiAgICAgICAgfVxuICAgICAgLz5cbiAgICApIDogbnVsbCxcbiAgICBNZXRhKHsgbmFtZTogJ2dlbmVyYXRvcicsIGNvbnRlbnQ6IG1ldGFkYXRhLmdlbmVyYXRvciB9KSxcbiAgICBNZXRhKHsgbmFtZTogJ2tleXdvcmRzJywgY29udGVudDogbWV0YWRhdGEua2V5d29yZHM/LmpvaW4oJywnKSB9KSxcbiAgICBNZXRhKHsgbmFtZTogJ3JlZmVycmVyJywgY29udGVudDogbWV0YWRhdGEucmVmZXJyZXIgfSksXG4gICAgTWV0YSh7IG5hbWU6ICdjcmVhdG9yJywgY29udGVudDogbWV0YWRhdGEuY3JlYXRvciB9KSxcbiAgICBNZXRhKHsgbmFtZTogJ3B1Ymxpc2hlcicsIGNvbnRlbnQ6IG1ldGFkYXRhLnB1Ymxpc2hlciB9KSxcbiAgICBNZXRhKHsgbmFtZTogJ3JvYm90cycsIGNvbnRlbnQ6IG1ldGFkYXRhLnJvYm90cz8uYmFzaWMgfSksXG4gICAgTWV0YSh7IG5hbWU6ICdnb29nbGVib3QnLCBjb250ZW50OiBtZXRhZGF0YS5yb2JvdHM/Lmdvb2dsZUJvdCB9KSxcbiAgICBNZXRhKHsgbmFtZTogJ2Fic3RyYWN0JywgY29udGVudDogbWV0YWRhdGEuYWJzdHJhY3QgfSksXG4gICAgLi4uKG1ldGFkYXRhLmFyY2hpdmVzXG4gICAgICA/IG1ldGFkYXRhLmFyY2hpdmVzLm1hcCgoYXJjaGl2ZSkgPT4gKFxuICAgICAgICAgIDxsaW5rIHJlbD1cImFyY2hpdmVzXCIgaHJlZj17YXJjaGl2ZX0gLz5cbiAgICAgICAgKSlcbiAgICAgIDogW10pLFxuICAgIC4uLihtZXRhZGF0YS5hc3NldHNcbiAgICAgID8gbWV0YWRhdGEuYXNzZXRzLm1hcCgoYXNzZXQpID0+IDxsaW5rIHJlbD1cImFzc2V0c1wiIGhyZWY9e2Fzc2V0fSAvPilcbiAgICAgIDogW10pLFxuICAgIC4uLihtZXRhZGF0YS5ib29rbWFya3NcbiAgICAgID8gbWV0YWRhdGEuYm9va21hcmtzLm1hcCgoYm9va21hcmspID0+IChcbiAgICAgICAgICA8bGluayByZWw9XCJib29rbWFya3NcIiBocmVmPXtib29rbWFya30gLz5cbiAgICAgICAgKSlcbiAgICAgIDogW10pLFxuICAgIC4uLihtZXRhZGF0YS5wYWdpbmF0aW9uXG4gICAgICA/IFtcbiAgICAgICAgICBtZXRhZGF0YS5wYWdpbmF0aW9uLnByZXZpb3VzID8gKFxuICAgICAgICAgICAgPGxpbmsgcmVsPVwicHJldlwiIGhyZWY9e21ldGFkYXRhLnBhZ2luYXRpb24ucHJldmlvdXN9IC8+XG4gICAgICAgICAgKSA6IG51bGwsXG4gICAgICAgICAgbWV0YWRhdGEucGFnaW5hdGlvbi5uZXh0ID8gKFxuICAgICAgICAgICAgPGxpbmsgcmVsPVwibmV4dFwiIGhyZWY9e21ldGFkYXRhLnBhZ2luYXRpb24ubmV4dH0gLz5cbiAgICAgICAgICApIDogbnVsbCxcbiAgICAgICAgXVxuICAgICAgOiBbXSksXG4gICAgTWV0YSh7IG5hbWU6ICdjYXRlZ29yeScsIGNvbnRlbnQ6IG1ldGFkYXRhLmNhdGVnb3J5IH0pLFxuICAgIE1ldGEoeyBuYW1lOiAnY2xhc3NpZmljYXRpb24nLCBjb250ZW50OiBtZXRhZGF0YS5jbGFzc2lmaWNhdGlvbiB9KSxcbiAgICAuLi4obWV0YWRhdGEub3RoZXJcbiAgICAgID8gT2JqZWN0LmVudHJpZXMobWV0YWRhdGEub3RoZXIpLm1hcCgoW25hbWUsIGNvbnRlbnRdKSA9PiB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29udGVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZW50Lm1hcCgoY29udGVudEl0ZW0pID0+XG4gICAgICAgICAgICAgIE1ldGEoeyBuYW1lLCBjb250ZW50OiBjb250ZW50SXRlbSB9KVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWV0YSh7IG5hbWUsIGNvbnRlbnQgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICA6IFtdKSxcbiAgXSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEl0dW5lc01ldGEoeyBpdHVuZXMgfTogeyBpdHVuZXM6IFJlc29sdmVkTWV0YWRhdGFbJ2l0dW5lcyddIH0pIHtcbiAgaWYgKCFpdHVuZXMpIHJldHVybiBudWxsXG4gIGNvbnN0IHsgYXBwSWQsIGFwcEFyZ3VtZW50IH0gPSBpdHVuZXNcbiAgbGV0IGNvbnRlbnQgPSBgYXBwLWlkPSR7YXBwSWR9YFxuICBpZiAoYXBwQXJndW1lbnQpIHtcbiAgICBjb250ZW50ICs9IGAsIGFwcC1hcmd1bWVudD0ke2FwcEFyZ3VtZW50fWBcbiAgfVxuICByZXR1cm4gPG1ldGEgbmFtZT1cImFwcGxlLWl0dW5lcy1hcHBcIiBjb250ZW50PXtjb250ZW50fSAvPlxufVxuXG5leHBvcnQgZnVuY3Rpb24gRmFjZWJvb2tNZXRhKHtcbiAgZmFjZWJvb2ssXG59OiB7XG4gIGZhY2Vib29rOiBSZXNvbHZlZE1ldGFkYXRhWydmYWNlYm9vayddXG59KSB7XG4gIGlmICghZmFjZWJvb2spIHJldHVybiBudWxsXG5cbiAgY29uc3QgeyBhcHBJZCwgYWRtaW5zIH0gPSBmYWNlYm9va1xuXG4gIHJldHVybiBNZXRhRmlsdGVyKFtcbiAgICBhcHBJZCA/IDxtZXRhIHByb3BlcnR5PVwiZmI6YXBwX2lkXCIgY29udGVudD17YXBwSWR9IC8+IDogbnVsbCxcbiAgICAuLi4oYWRtaW5zXG4gICAgICA/IGFkbWlucy5tYXAoKGFkbWluKSA9PiA8bWV0YSBwcm9wZXJ0eT1cImZiOmFkbWluc1wiIGNvbnRlbnQ9e2FkbWlufSAvPilcbiAgICAgIDogW10pLFxuICBdKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gUGludGVyZXN0TWV0YSh7XG4gIHBpbnRlcmVzdCxcbn06IHtcbiAgcGludGVyZXN0OiBSZXNvbHZlZE1ldGFkYXRhWydwaW50ZXJlc3QnXVxufSkge1xuICBpZiAoIXBpbnRlcmVzdCB8fCAhcGludGVyZXN0LnJpY2hQaW4pIHJldHVybiBudWxsXG5cbiAgY29uc3QgeyByaWNoUGluIH0gPSBwaW50ZXJlc3RcblxuICByZXR1cm4gPG1ldGEgcHJvcGVydHk9XCJwaW50ZXJlc3QtcmljaC1waW5cIiBjb250ZW50PXtyaWNoUGluLnRvU3RyaW5nKCl9IC8+XG59XG5cbmNvbnN0IGZvcm1hdERldGVjdGlvbktleXMgPSBbXG4gICd0ZWxlcGhvbmUnLFxuICAnZGF0ZScsXG4gICdhZGRyZXNzJyxcbiAgJ2VtYWlsJyxcbiAgJ3VybCcsXG5dIGFzIGNvbnN0XG5leHBvcnQgZnVuY3Rpb24gRm9ybWF0RGV0ZWN0aW9uTWV0YSh7XG4gIGZvcm1hdERldGVjdGlvbixcbn06IHtcbiAgZm9ybWF0RGV0ZWN0aW9uOiBSZXNvbHZlZE1ldGFkYXRhWydmb3JtYXREZXRlY3Rpb24nXVxufSkge1xuICBpZiAoIWZvcm1hdERldGVjdGlvbikgcmV0dXJuIG51bGxcbiAgbGV0IGNvbnRlbnQgPSAnJ1xuICBmb3IgKGNvbnN0IGtleSBvZiBmb3JtYXREZXRlY3Rpb25LZXlzKSB7XG4gICAgaWYgKGtleSBpbiBmb3JtYXREZXRlY3Rpb24pIHtcbiAgICAgIGlmIChjb250ZW50KSBjb250ZW50ICs9ICcsICdcbiAgICAgIGNvbnRlbnQgKz0gYCR7a2V5fT1ub2BcbiAgICB9XG4gIH1cbiAgcmV0dXJuIDxtZXRhIG5hbWU9XCJmb3JtYXQtZGV0ZWN0aW9uXCIgY29udGVudD17Y29udGVudH0gLz5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEFwcGxlV2ViQXBwTWV0YSh7XG4gIGFwcGxlV2ViQXBwLFxufToge1xuICBhcHBsZVdlYkFwcDogUmVzb2x2ZWRNZXRhZGF0YVsnYXBwbGVXZWJBcHAnXVxufSkge1xuICBpZiAoIWFwcGxlV2ViQXBwKSByZXR1cm4gbnVsbFxuXG4gIGNvbnN0IHsgY2FwYWJsZSwgdGl0bGUsIHN0YXJ0dXBJbWFnZSwgc3RhdHVzQmFyU3R5bGUgfSA9IGFwcGxlV2ViQXBwXG5cbiAgcmV0dXJuIE1ldGFGaWx0ZXIoW1xuICAgIGNhcGFibGUgPyBNZXRhKHsgbmFtZTogJ21vYmlsZS13ZWItYXBwLWNhcGFibGUnLCBjb250ZW50OiAneWVzJyB9KSA6IG51bGwsXG4gICAgTWV0YSh7IG5hbWU6ICdhcHBsZS1tb2JpbGUtd2ViLWFwcC10aXRsZScsIGNvbnRlbnQ6IHRpdGxlIH0pLFxuICAgIHN0YXJ0dXBJbWFnZVxuICAgICAgPyBzdGFydHVwSW1hZ2UubWFwKChpbWFnZSkgPT4gKFxuICAgICAgICAgIDxsaW5rXG4gICAgICAgICAgICBocmVmPXtpbWFnZS51cmx9XG4gICAgICAgICAgICBtZWRpYT17aW1hZ2UubWVkaWF9XG4gICAgICAgICAgICByZWw9XCJhcHBsZS10b3VjaC1zdGFydHVwLWltYWdlXCJcbiAgICAgICAgICAvPlxuICAgICAgICApKVxuICAgICAgOiBudWxsLFxuICAgIHN0YXR1c0JhclN0eWxlXG4gICAgICA/IE1ldGEoe1xuICAgICAgICAgIG5hbWU6ICdhcHBsZS1tb2JpbGUtd2ViLWFwcC1zdGF0dXMtYmFyLXN0eWxlJyxcbiAgICAgICAgICBjb250ZW50OiBzdGF0dXNCYXJTdHlsZSxcbiAgICAgICAgfSlcbiAgICAgIDogbnVsbCxcbiAgXSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFZlcmlmaWNhdGlvbk1ldGEoe1xuICB2ZXJpZmljYXRpb24sXG59OiB7XG4gIHZlcmlmaWNhdGlvbjogUmVzb2x2ZWRNZXRhZGF0YVsndmVyaWZpY2F0aW9uJ11cbn0pIHtcbiAgaWYgKCF2ZXJpZmljYXRpb24pIHJldHVybiBudWxsXG5cbiAgcmV0dXJuIE1ldGFGaWx0ZXIoW1xuICAgIE11bHRpTWV0YSh7XG4gICAgICBuYW1lUHJlZml4OiAnZ29vZ2xlLXNpdGUtdmVyaWZpY2F0aW9uJyxcbiAgICAgIGNvbnRlbnRzOiB2ZXJpZmljYXRpb24uZ29vZ2xlLFxuICAgIH0pLFxuICAgIE11bHRpTWV0YSh7IG5hbWVQcmVmaXg6ICd5X2tleScsIGNvbnRlbnRzOiB2ZXJpZmljYXRpb24ueWFob28gfSksXG4gICAgTXVsdGlNZXRhKHtcbiAgICAgIG5hbWVQcmVmaXg6ICd5YW5kZXgtdmVyaWZpY2F0aW9uJyxcbiAgICAgIGNvbnRlbnRzOiB2ZXJpZmljYXRpb24ueWFuZGV4LFxuICAgIH0pLFxuICAgIE11bHRpTWV0YSh7IG5hbWVQcmVmaXg6ICdtZScsIGNvbnRlbnRzOiB2ZXJpZmljYXRpb24ubWUgfSksXG4gICAgLi4uKHZlcmlmaWNhdGlvbi5vdGhlclxuICAgICAgPyBPYmplY3QuZW50cmllcyh2ZXJpZmljYXRpb24ub3RoZXIpLm1hcCgoW2tleSwgdmFsdWVdKSA9PlxuICAgICAgICAgIE11bHRpTWV0YSh7IG5hbWVQcmVmaXg6IGtleSwgY29udGVudHM6IHZhbHVlIH0pXG4gICAgICAgIClcbiAgICAgIDogW10pLFxuICBdKVxufVxuIl0sIm5hbWVzIjpbIk1ldGEiLCJNZXRhRmlsdGVyIiwiTXVsdGlNZXRhIiwiVmlld3BvcnRNZXRhS2V5cyIsImdldE9yaWdpbiIsInJlc29sdmVWaWV3cG9ydExheW91dCIsInZpZXdwb3J0IiwicmVzb2x2ZWQiLCJ2aWV3cG9ydEtleV8iLCJ2aWV3cG9ydEtleSIsInZhbHVlIiwidW5kZWZpbmVkIiwiVmlld3BvcnRNZXRhIiwibWV0YSIsImNoYXJTZXQiLCJuYW1lIiwiY29udGVudCIsInRoZW1lQ29sb3IiLCJtYXAiLCJjb2xvciIsIm1lZGlhIiwiY29sb3JTY2hlbWUiLCJCYXNpY01ldGEiLCJtZXRhZGF0YSIsIm1hbmlmZXN0T3JpZ2luIiwibWFuaWZlc3QiLCJ0aXRsZSIsImFic29sdXRlIiwiZGVzY3JpcHRpb24iLCJhcHBsaWNhdGlvbk5hbWUiLCJhdXRob3JzIiwiYXV0aG9yIiwidXJsIiwibGluayIsInJlbCIsImhyZWYiLCJ0b1N0cmluZyIsImNyb3NzT3JpZ2luIiwicHJvY2VzcyIsImVudiIsIlZFUkNFTF9FTlYiLCJnZW5lcmF0b3IiLCJrZXl3b3JkcyIsImpvaW4iLCJyZWZlcnJlciIsImNyZWF0b3IiLCJwdWJsaXNoZXIiLCJyb2JvdHMiLCJiYXNpYyIsImdvb2dsZUJvdCIsImFic3RyYWN0IiwiYXJjaGl2ZXMiLCJhcmNoaXZlIiwiYXNzZXRzIiwiYXNzZXQiLCJib29rbWFya3MiLCJib29rbWFyayIsInBhZ2luYXRpb24iLCJwcmV2aW91cyIsIm5leHQiLCJjYXRlZ29yeSIsImNsYXNzaWZpY2F0aW9uIiwib3RoZXIiLCJPYmplY3QiLCJlbnRyaWVzIiwiQXJyYXkiLCJpc0FycmF5IiwiY29udGVudEl0ZW0iLCJJdHVuZXNNZXRhIiwiaXR1bmVzIiwiYXBwSWQiLCJhcHBBcmd1bWVudCIsIkZhY2Vib29rTWV0YSIsImZhY2Vib29rIiwiYWRtaW5zIiwicHJvcGVydHkiLCJhZG1pbiIsIlBpbnRlcmVzdE1ldGEiLCJwaW50ZXJlc3QiLCJyaWNoUGluIiwiZm9ybWF0RGV0ZWN0aW9uS2V5cyIsIkZvcm1hdERldGVjdGlvbk1ldGEiLCJmb3JtYXREZXRlY3Rpb24iLCJrZXkiLCJBcHBsZVdlYkFwcE1ldGEiLCJhcHBsZVdlYkFwcCIsImNhcGFibGUiLCJzdGFydHVwSW1hZ2UiLCJzdGF0dXNCYXJTdHlsZSIsImltYWdlIiwiVmVyaWZpY2F0aW9uTWV0YSIsInZlcmlmaWNhdGlvbiIsIm5hbWVQcmVmaXgiLCJjb250ZW50cyIsImdvb2dsZSIsInlhaG9vIiwieWFuZGV4IiwibWUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBT0EsU0FBU0EsSUFBSSxFQUFFQyxVQUFVLEVBQUVDLFNBQVMsUUFBUSxTQUFRO0FBQ3BELFNBQVNDLGdCQUFnQixRQUFRLGVBQWM7QUFDL0MsU0FBU0MsU0FBUyxRQUFRLFVBQVM7Ozs7O0FBRW5DLDBEQUEwRDtBQUMxRCxTQUFTQyxzQkFBc0JDLFFBQWtCO0lBQy9DLElBQUlDLFdBQTBCO0lBRTlCLElBQUlELFlBQVksT0FBT0EsYUFBYSxVQUFVO1FBQzVDQyxXQUFXO1FBQ1gsSUFBSyxNQUFNQyxvTEFBZ0JMLG1CQUFBQSxDQUFrQjtZQUMzQyxNQUFNTSxjQUFjRDtZQUNwQixJQUFJQyxlQUFlSCxVQUFVO2dCQUMzQixJQUFJSSxRQUFRSixRQUFRLENBQUNHLFlBQVk7Z0JBQ2pDLElBQUksT0FBT0MsVUFBVSxXQUFXO29CQUM5QkEsUUFBUUEsUUFBUSxRQUFRO2dCQUMxQixPQUFPLElBQUksQ0FBQ0EsU0FBU0QsZ0JBQWdCLGdCQUFnQjtvQkFDbkRDLFFBQVFDO2dCQUNWO2dCQUNBLElBQUlELE9BQU87b0JBQ1QsSUFBSUgsVUFBVUEsWUFBWTtvQkFDMUJBLFlBQVksdUtBQUdKLG1CQUFnQixDQUFDTSxZQUFZLENBQUMsQ0FBQyxFQUFFQyxPQUFPO2dCQUN6RDtZQUNG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SztnQkFDbEJjLEtBQUk7a0JBR1I7UUFDSnNELGtCQUNJeEYscUxBQUFBLEVBQUs7WUFDSGUsTUFBTTtZQUNOQyxTQUFTd0U7UUFDWCxLQUNBO0tBQ0w7QUFDSDtBQUVPLFNBQVNFLGlCQUFpQixFQUMvQkMsWUFBWSxFQUdiO0lBQ0MsSUFBSSxDQUFDQSxjQUFjLE9BQU87SUFFMUIsT0FBTzFGLDRMQUFBQSxFQUFXO3VMQUNoQkMsWUFBQUEsRUFBVTtZQUNSMEYsWUFBWTtZQUNaQyxVQUFVRixhQUFhRyxNQUFNO1FBQy9CO1NBQ0E1RiwwTEFBQUEsRUFBVTtZQUFFMEYsWUFBWTtZQUFTQyxVQUFVRixhQUFhSSxLQUFLO1FBQUM7dUxBQzlEN0YsWUFBQUEsRUFBVTtZQUNSMEYsWUFBWTtZQUNaQyxVQUFVRixhQUFhSyxNQUFNO1FBQy9CO1NBQ0E5RiwwTEFBQUEsRUFBVTtZQUFFMEYsWUFBWTtZQUFNQyxVQUFVRixhQUFhTSxFQUFFO1FBQUM7V0FDcEROLGFBQWE3QixLQUFLLEdBQ2xCQyxPQUFPQyxPQUFPLENBQUMyQixhQUFhN0IsS0FBSyxFQUFFNUMsR0FBRyxDQUFDLENBQUMsQ0FBQ2lFLEtBQUt6RSxNQUFNLGtMQUNsRFIsWUFBQUEsRUFBVTtnQkFBRTBGLFlBQVlUO2dCQUFLVSxVQUFVbkY7WUFBTSxNQUUvQyxFQUFFO0tBQ1A7QUFDSCIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAyNDI1LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zcmMvbGliL21ldGFkYXRhL2dlbmVyYXRlL2FsdGVybmF0ZS50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBSZXNvbHZlZE1ldGFkYXRhIH0gZnJvbSAnLi4vdHlwZXMvbWV0YWRhdGEtaW50ZXJmYWNlJ1xuaW1wb3J0IHR5cGUgeyBBbHRlcm5hdGVMaW5rRGVzY3JpcHRvciB9IGZyb20gJy4uL3R5cGVzL2FsdGVybmF0aXZlLXVybHMtdHlwZXMnXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCB7IE1ldGFGaWx0ZXIgfSBmcm9tICcuL21ldGEnXG5cbmZ1bmN0aW9uIEFsdGVybmF0ZUxpbmsoe1xuICBkZXNjcmlwdG9yLFxuICAuLi5wcm9wc1xufToge1xuICBkZXNjcmlwdG9yOiBBbHRlcm5hdGVMaW5rRGVzY3JpcHRvclxufSAmIFJlYWN0LkxpbmtIVE1MQXR0cmlidXRlczxIVE1MTGlua0VsZW1lbnQ+KSB7XG4gIGlmICghZGVzY3JpcHRvci51cmwpIHJldHVybiBudWxsXG4gIHJldHVybiAoXG4gICAgPGxpbmtcbiAgICAgIHsuLi5wcm9wc31cbiAgICAgIHsuLi4oZGVzY3JpcHRvci50aXRsZSAmJiB7IHRpdGxlOiBkZXNjcmlwdG9yLnRpdGxlIH0pfVxuICAgICAgaHJlZj17ZGVzY3JpcHRvci51cmwudG9TdHJpbmcoKX1cbiAgICAvPlxuICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBBbHRlcm5hdGVzTWV0YWRhdGEoe1xuICBhbHRlcm5hdGVzLFxufToge1xuICBhbHRlcm5hdGVzOiBSZXNvbHZlZE1ldGFkYXRhWydhbHRlcm5hdGVzJ11cbn0pIHtcbiAgaWYgKCFhbHRlcm5hdGVzKSByZXR1cm4gbnVsbFxuXG4gIGNvbnN0IHsgY2Fub25pY2FsLCBsYW5ndWFnZXMsIG1lZGlhLCB0eXBlcyB9ID0gYWx0ZXJuYXRlc1xuXG4gIHJldHVybiBNZXRhRmlsdGVyKFtcbiAgICBjYW5vbmljYWxcbiAgICAgID8gQWx0ZXJuYXRlTGluayh7IHJlbDogJ2Nhbm9uaWNhbCcsIGRlc2NyaXB0b3I6IGNhbm9uaWNhbCB9KVxuICAgICAgOiBudWxsLFxuICAgIGxhbmd1YWdlc1xuICAgICAgPyBPYmplY3QuZW50cmllcyhsYW5ndWFnZXMpLmZsYXRNYXAoKFtsb2NhbGUsIGRlc2NyaXB0b3JzXSkgPT5cbiAgICAgICAgICBkZXNjcmlwdG9ycz8ubWFwKChkZXNjcmlwdG9yKSA9PlxuICAgICAgICAgICAgQWx0ZXJuYXRlTGluayh7IHJlbDogJ2FsdGVybmF0ZScsIGhyZWZMYW5nOiBsb2NhbGUsIGRlc2NyaXB0b3IgfSlcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgIDogbnVsbCxcbiAgICBtZWRpYVxuICAgICAgPyBPYmplY3QuZW50cmllcyhtZWRpYSkuZmxhdE1hcCgoW21lZGlhTmFtZSwgZGVzY3JpcHRvcnNdKSA9PlxuICAgICAgICAgIGRlc2NyaXB0b3JzPy5tYXAoKGRlc2NyaXB0b3IpID0+XG4gICAgICAgICAgICBBbHRlcm5hdGVMaW5rKHsgcmVsOiAnYWx0ZXJuYXRlJywgbWVkaWE6IG1lZGlhTmFtZSwgZGVzY3JpcHRvciB9KVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgOiBudWxsLFxuICAgIHR5cGVzXG4gICAgICA/IE9iamVjdC5lbnRyaWVzKHR5cGVzKS5mbGF0TWFwKChbdHlwZSwgZGVzY3JpcHRvcnNdKSA9PlxuICAgICAgICAgIGRlc2NyaXB0b3JzPy5tYXAoKGRlc2NyaXB0b3IpID0+XG4gICAgICAgICAgICBBbHRlcm5hdGVMaW5rKHsgcmVsOiAnYWx0ZXJuYXRlJywgdHlwZSwgZGVzY3JpcHRvciB9KVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgOiBudWxsLFxuICBdKVxufVxuIl0sIm5hbWVzIjpbIlJlYWN0IiwiTWV0YUZpbHRlciIsIkFsdGVybmF0ZUxpbmsiLCJkZXNjcmlwdG9yIiwicHJvcHMiLCJ1cmwiLCJsaW5rIiwidGl0bGUiLCJocmVmIiwidG9TdHJpbmciLCJBbHRlcm5hdGVzTWV0YWRhdGEiLCJhbHRlcm5hdGVzIiwiY2Fub25pY2FsIiwibGFuZ3VhZ2VzIiwibWVkaWEiLCJ0eXBlcyIsInJlbCIsIk9iamVjdCIsImVudHJpZXMiLCJmbGF0TWFwIiwibG9jYWxlIiwiZGVzY3JpcHRvcnMiLCJtYXAiLCJocmVmTGFuZyIsIm1lZGlhTmFtZSIsInR5cGUiXSwibWFwcGluZ3MiOiI7Ozs7QUFHQSxPQUFPQSxXQUFXLFFBQU87QUFDekIsU0FBU0MsVUFBVSxRQUFRLFNBQVE7Ozs7QUFFbkMsU0FBU0MsY0FBYyxFQUNyQkMsVUFBVSxFQUNWLEdBQUdDLE9BR3dDO0lBQzNDLElBQUksQ0FBQ0QsV0FBV0UsR0FBRyxFQUFFLE9BQU87SUFDNUIsT0FBQSxXQUFBLCtOQUNFLE1BQUEsRUFBQ0MsUUFBQUE7UUFDRSxHQUFHRixLQUFLO1FBQ1IsR0FBSUQsV0FBV0ksS0FBSyxJQUFJO1lBQUVBLE9BQU9KLFdBQVdJLEtBQUs7UUFBQyxDQUFDO1FBQ3BEQyxNQUFNTCxXQUFXRSxHQUFHLENBQUNJLFFBQVE7O0FBR25DO0FBRU8sU0FBU0MsbUJBQW1CLEVBQ2pDQyxVQUFVLEVBR1g7SUFDQyxJQUFJLENBQUNBLFlBQVksT0FBTztJQUV4QixNQUFNLEVBQUVDLFNBQVMsRUFBRUMsU0FBUyxFQUFFQyxLQUFLLEVBQUVDLEtBQUssRUFBRSxHQUFHSjtJQUUvQyxPQUFPViw0TEFBQUEsRUFBVztRQUNoQlcsWUFDSVYsY0FBYztZQUFFYyxLQUFLO1lBQWFiLFlBQVlTO1FBQVUsS0FDeEQ7UUFDSkMsWUFDSUksT0FBT0MsT0FBTyxDQUFDTCxXQUFXTSxPQUFPLENBQUMsQ0FBQyxDQUFDQyxRQUFRQyxZQUFZLEdBQ3REQSxlQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxZQUFhQyxHQUFHLENBQUMsQ0FBQ25CLGFBQ2hCRCxjQUFjO29CQUFFYyxLQUFLO29CQUFhTyxVQUFVSDtvQkFBUWpCO2dCQUFXLE9BR25FO1FBQ0pXLFFBQ0lHLE9BQU9DLE9BQU8sQ0FBQ0osT0FBT0ssT0FBTyxDQUFDLENBQUMsQ0FBQ0ssV0FBV0gsWUFBWSxHQUNyREEsZUFBQUEsT0FBQUEsS0FBQUEsSUFBQUEsWUFBYUMsR0FBRyxDQUFDLENBQUNuQixhQUNoQkQsY0FBYztvQkFBRWMsS0FBSztvQkFBYUYsT0FBT1U7b0JBQVdyQjtnQkFBVyxPQUduRTtRQUNKWSxRQUNJRSxPQUFPQyxPQUFPLENBQUNILE9BQU9JLE9BQU8sQ0FBQyxDQUFDLENBQUNNLE1BQU1KLFlBQVksR0FDaERBLGVBQUFBLE9BQUFBLEtBQUFBLElBQUFBLFlBQWFDLEdBQUcsQ0FBQyxDQUFDbkIsYUFDaEJELGNBQWM7b0JBQUVjLEtBQUs7b0JBQWFTO29CQUFNdEI7Z0JBQVcsT0FHdkQ7S0FDTDtBQUNIIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDI0NzMsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NyYy9saWIvbWV0YWRhdGEvZ2VuZXJhdGUvb3BlbmdyYXBoLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IFJlc29sdmVkTWV0YWRhdGEgfSBmcm9tICcuLi90eXBlcy9tZXRhZGF0YS1pbnRlcmZhY2UnXG5pbXBvcnQgdHlwZSB7IFR3aXR0ZXJBcHBEZXNjcmlwdG9yIH0gZnJvbSAnLi4vdHlwZXMvdHdpdHRlci10eXBlcydcblxuaW1wb3J0IHsgTWV0YSwgTWV0YUZpbHRlciwgTXVsdGlNZXRhIH0gZnJvbSAnLi9tZXRhJ1xuXG5leHBvcnQgZnVuY3Rpb24gT3BlbkdyYXBoTWV0YWRhdGEoe1xuICBvcGVuR3JhcGgsXG59OiB7XG4gIG9wZW5HcmFwaDogUmVzb2x2ZWRNZXRhZGF0YVsnb3BlbkdyYXBoJ11cbn0pIHtcbiAgaWYgKCFvcGVuR3JhcGgpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgbGV0IHR5cGVkT3BlbkdyYXBoXG4gIGlmICgndHlwZScgaW4gb3BlbkdyYXBoKSB7XG4gICAgY29uc3Qgb3BlbkdyYXBoVHlwZSA9IG9wZW5HcmFwaC50eXBlXG4gICAgc3dpdGNoIChvcGVuR3JhcGhUeXBlKSB7XG4gICAgICBjYXNlICd3ZWJzaXRlJzpcbiAgICAgICAgdHlwZWRPcGVuR3JhcGggPSBbTWV0YSh7IHByb3BlcnR5OiAnb2c6dHlwZScsIGNvbnRlbnQ6ICd3ZWJzaXRlJyB9KV1cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ2FydGljbGUnOlxuICAgICAgICB0eXBlZE9wZW5HcmFwaCA9IFtcbiAgICAgICAgICBNZXRhKHsgcHJvcGVydHk6ICdvZzp0eXBlJywgY29udGVudDogJ2FydGljbGUnIH0pLFxuICAgICAgICAgIE1ldGEoe1xuICAgICAgICAgICAgcHJvcGVydHk6ICdhcnRpY2xlOnB1Ymxpc2hlZF90aW1lJyxcbiAgICAgICAgICAgIGNvbnRlbnQ6IG9wZW5HcmFwaC5wdWJsaXNoZWRUaW1lPy50b1N0cmluZygpLFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIE1ldGEoe1xuICAgICAgICAgICAgcHJvcGVydHk6ICdhcnRpY2xlOm1vZGlmaWVkX3RpbWUnLFxuICAgICAgICAgICAgY29udGVudDogb3BlbkdyYXBoLm1vZGlmaWVkVGltZT8udG9TdHJpbmcoKSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBNZXRhKHtcbiAgICAgICAgICAgIHByb3BlcnR5OiAnYXJ0aWNsZTpleHBpcmF0aW9uX3RpbWUnLFxuICAgICAgICAgICAgY29udGVudDogb3BlbkdyYXBoLmV4cGlyYXRpb25UaW1lPy50b1N0cmluZygpLFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIE11bHRpTWV0YSh7XG4gICAgICAgICAgICBwcm9wZXJ0eVByZWZpeDogJ2FydGljbGU6YXV0aG9yJyxcbiAgICAgICAgICAgIGNvbnRlbnRzOiBvcGVuR3JhcGguYXV0aG9ycyxcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBNZXRhKHsgcHJvcGVydHk6ICdhcnRpY2xlOnNlY3Rpb24nLCBjb250ZW50OiBvcGVuR3JhcGguc2VjdGlvbiB9KSxcbiAgICAgICAgICBNdWx0aU1ldGEoe1xuICAgICAgICAgICAgcHJvcGVydHlQcmVmaXg6ICdhcnRpY2xlOnRhZycsXG4gICAgICAgICAgICBjb250ZW50czogb3BlbkdyYXBoLnRhZ3MsXG4gICAgICAgICAgfSksXG4gICAgICAgIF1cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ2Jvb2snOlxuICAgICAgICB0eXBlZE9wZW5HcmFwaCA9IFtcbiAgICAgICAgICBNZXRhKHsgcHJvcGVydHk6ICdvZzp0eXBlJywgY29udGVudDogJ2Jvb2snIH0pLFxuICAgICAgICAgIE1ldGEoeyBwcm9wZXJ0eTogJ2Jvb2s6aXNibicsIGNvbnRlbnQ6IG9wZW5HcmFwaC5pc2JuIH0pLFxuICAgICAgICAgIE1ldGEoe1xuICAgICAgICAgICAgcHJvcGVydHk6ICdib29rOnJlbGVhc2VfZGF0ZScsXG4gICAgICAgICAgICBjb250ZW50OiBvcGVuR3JhcGgucmVsZWFzZURhdGUsXG4gICAgICAgICAgfSksXG4gICAgICAgICAgTXVsdGlNZXRhKHtcbiAgICAgICAgICAgIHByb3BlcnR5UHJlZml4OiAnYm9vazphdXRob3InLFxuICAgICAgICAgICAgY29udGVudHM6IG9wZW5HcmFwaC5hdXRob3JzLFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIE11bHRpTWV0YSh7IHByb3BlcnR5UHJlZml4OiAnYm9vazp0YWcnLCBjb250ZW50czogb3BlbkdyYXBoLnRhZ3MgfSksXG4gICAgICAgIF1cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3Byb2ZpbGUnOlxuICAgICAgICB0eXBlZE9wZW5HcmFwaCA9IFtcbiAgICAgICAgICBNZXRhKHsgcHJvcGVydHk6ICdvZzp0eXBlJywgY29udGVudDogJ3Byb2ZpbGUnIH0pLFxuICAgICAgICAgIE1ldGEoe1xuICAgICAgICAgICAgcHJvcGVydHk6ICdwcm9maWxlOmZpcnN0X25hbWUnLFxuICAgICAgICAgICAgY29udGVudDogb3BlbkdyYXBoLmZpcnN0TmFtZSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBNZXRhKHsgcHJvcGVydHk6ICdwcm9maWxlOmxhc3RfbmFtZScsIGNvbnRlbnQ6IG9wZW5HcmFwaC5sYXN0TmFtZSB9KSxcbiAgICAgICAgICBNZXRhKHsgcHJvcGVydHk6ICdwcm9maWxlOnVzZXJuYW1lJywgY29udGVudDogb3BlbkdyYXBoLnVzZXJuYW1lIH0pLFxuICAgICAgICAgIE1ldGEoeyBwcm9wZXJ0eTogJ3Byb2ZpbGU6Z2VuZGVyJywgY29udGVudDogb3BlbkdyYXBoLmdlbmRlciB9KSxcbiAgICAgICAgXVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnbXVzaWMuc29uZyc6XG4gICAgICAgIHR5cGVkT3BlbkdyYXBoID0gW1xuICAgICAgICAgIE1ldGEoeyBwcm9wZXJ0eTogJ29nOnR5cGUnLCBjb250ZW50OiAnbXVzaWMuc29uZycgfSksXG4gICAgICAgICAgTWV0YSh7XG4gICAgICAgICAgICBwcm9wZXJ0eTogJ211c2ljOmR1cmF0aW9uJyxcbiAgICAgICAgICAgIGNvbnRlbnQ6IG9wZW5HcmFwaC5kdXJhdGlvbj8udG9TdHJpbmcoKSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBNdWx0aU1ldGEoe1xuICAgICAgICAgICAgcHJvcGVydHlQcmVmaXg6ICdtdXNpYzphbGJ1bScsXG4gICAgICAgICAgICBjb250ZW50czogb3BlbkdyYXBoLmFsYnVtcyxcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBNdWx0aU1ldGEoe1xuICAgICAgICAgICAgcHJvcGVydHlQcmVmaXg6ICdtdXNpYzptdXNpY2lhbicsXG4gICAgICAgICAgICBjb250ZW50czogb3BlbkdyYXBoLm11c2ljaWFucyxcbiAgICAgICAgICB9KSxcbiAgICAgICAgXVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnbXVzaWMuYWxidW0nOlxuICAgICAgICB0eXBlZE9wZW5HcmFwaCA9IFtcbiAgICAgICAgICBNZXRhKHsgcHJvcGVydHk6ICdvZzp0eXBlJywgY29udGVudDogJ211c2ljLmFsYnVtJyB9KSxcbiAgICAgICAgICBNdWx0aU1ldGEoe1xuICAgICAgICAgICAgcHJvcGVydHlQcmVmaXg6ICdtdXNpYzpzb25nJyxcbiAgICAgICAgICAgIGNvbnRlbnRzOiBvcGVuR3JhcGguc29uZ3MsXG4gICAgICAgICAgfSksXG4gICAgICAgICAgTXVsdGlNZXRhKHtcbiAgICAgICAgICAgIHByb3BlcnR5UHJlZml4OiAnbXVzaWM6bXVzaWNpYW4nLFxuICAgICAgICAgICAgY29udGVudHM6IG9wZW5HcmFwaC5tdXNpY2lhbnMsXG4gICAgICAgICAgfSksXG4gICAgICAgICAgTWV0YSh7XG4gICAgICAgICAgICBwcm9wZXJ0eTogJ211c2ljOnJlbGVhc2VfZGF0ZScsXG4gICAgICAgICAgICBjb250ZW50OiBvcGVuR3JhcGgucmVsZWFzZURhdGUsXG4gICAgICAgICAgfSksXG4gICAgICAgIF1cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ211c2ljLnBsYXlsaXN0JzpcbiAgICAgICAgdHlwZWRPcGVuR3JhcGggPSBbXG4gICAgICAgICAgTWV0YSh7IHByb3BlcnR5OiAnb2c6dHlwZScsIGNvbnRlbnQ6ICdtdXNpYy5wbGF5bGlzdCcgfSksXG4gICAgICAgICAgTXVsdGlNZXRhKHtcbiAgICAgICAgICAgIHByb3BlcnR5UHJlZml4OiAnbXVzaWM6c29uZycsXG4gICAgICAgICAgICBjb250ZW50czogb3BlbkdyYXBoLnNvbmdzLFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIE11bHRpTWV0YSh7XG4gICAgICAgICAgICBwcm9wZXJ0eVByZWZpeDogJ211c2ljOmNyZWF0b3InLFxuICAgICAgICAgICAgY29udGVudHM6IG9wZW5HcmFwaC5jcmVhdG9ycyxcbiAgICAgICAgICB9KSxcbiAgICAgICAgXVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnbXVzaWMucmFkaW9fc3RhdGlvbic6XG4gICAgICAgIHR5cGVkT3BlbkdyYXBoID0gW1xuICAgICAgICAgIE1ldGEoeyBwcm9wZXJ0eTogJ29nOnR5cGUnLCBjb250ZW50OiAnbXVzaWMucmFkaW9fc3RhdGlvbicgfSksXG4gICAgICAgICAgTXVsdGlNZXRhKHtcbiAgICAgICAgICAgIHByb3BlcnR5UHJlZml4OiAnbXVzaWM6Y3JlYXRvcicsXG4gICAgICAgICAgICBjb250ZW50czogb3BlbkdyYXBoLmNyZWF0b3JzLFxuICAgICAgICAgIH0pLFxuICAgICAgICBdXG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgJ3ZpZGVvLm1vdmllJzpcbiAgICAgICAgdHlwZWRPcGVuR3JhcGggPSBbXG4gICAgICAgICAgTWV0YSh7IHByb3BlcnR5OiAnb2c6dHlwZScsIGNvbnRlbnQ6ICd2aWRlby5tb3ZpZScgfSksXG4gICAgICAgICAgTXVsdGlNZXRhKHtcbiAgICAgICAgICAgIHByb3BlcnR5UHJlZml4OiAndmlkZW86YWN0b3InLFxuICAgICAgICAgICAgY29udGVudHM6IG9wZW5HcmFwaC5hY3RvcnMsXG4gICAgICAgICAgfSksXG4gICAgICAgICAgTXVsdGlNZXRhKHtcbiAgICAgICAgICAgIHByb3BlcnR5UHJlZml4OiAndmlkZW86ZGlyZWN0b3InLFxuICAgICAgICAgICAgY29udGVudHM6IG9wZW5HcmFwaC5kaXJlY3RvcnMsXG4gICAgICAgICAgfSksXG4gICAgICAgICAgTXVsdGlNZXRhKHtcbiAgICAgICAgICAgIHByb3BlcnR5UHJlZml4OiAndmlkZW86d3JpdGVyJyxcbiAgICAgICAgICAgIGNvbnRlbnRzOiBvcGVuR3JhcGgud3JpdGVycyxcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBNZXRhKHsgcHJvcGVydHk6ICd2aWRlbzpkdXJhdGlvbicsIGNvbnRlbnQ6IG9wZW5HcmFwaC5kdXJhdGlvbiB9KSxcbiAgICAgICAgICBNZXRhKHtcbiAgICAgICAgICAgIHByb3BlcnR5OiAndmlkZW86cmVsZWFzZV9kYXRlJyxcbiAgICAgICAgICAgIGNvbnRlbnQ6IG9wZW5HcmFwaC5yZWxlYXNlRGF0ZSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBNdWx0aU1ldGEoeyBwcm9wZXJ0eVByZWZpeDogJ3ZpZGVvOnRhZycsIGNvbnRlbnRzOiBvcGVuR3JhcGgudGFncyB9KSxcbiAgICAgICAgXVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAndmlkZW8uZXBpc29kZSc6XG4gICAgICAgIHR5cGVkT3BlbkdyYXBoID0gW1xuICAgICAgICAgIE1ldGEoeyBwcm9wZXJ0eTogJ29nOnR5cGUnLCBjb250ZW50OiAndmlkZW8uZXBpc29kZScgfSksXG4gICAgICAgICAgTXVsdGlNZXRhKHtcbiAgICAgICAgICAgIHByb3BlcnR5UHJlZml4OiAndmlkZW86YWN0b3InLFxuICAgICAgICAgICAgY29udGVudHM6IG9wZW5HcmFwaC5hY3RvcnMsXG4gICAgICAgICAgfSksXG4gICAgICAgICAgTXVsdGlNZXRhKHtcbiAgICAgICAgICAgIHByb3BlcnR5UHJlZml4OiAndmlkZW86ZGlyZWN0b3InLFxuICAgICAgICAgICAgY29udGVudHM6IG9wZW5HcmFwaC5kaXJlY3RvcnMsXG4gICAgICAgICAgfSksXG4gICAgICAgICAgTXVsdGlNZXRhKHtcbiAgICAgICAgICAgIHByb3BlcnR5UHJlZml4OiAndmlkZW86d3JpdGVyJyxcbiAgICAgICAgICAgIGNvbnRlbnRzOiBvcGVuR3JhcGgud3JpdGVycyxcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBNZXRhKHsgcHJvcGVydHk6ICd2aWRlbzpkdXJhdGlvbicsIGNvbnRlbnQ6IG9wZW5HcmFwaC5kdXJhdGlvbiB9KSxcbiAgICAgICAgICBNZXRhKHtcbiAgICAgICAgICAgIHByb3BlcnR5OiAndmlkZW86cmVsZWFzZV9kYXRlJyxcbiAgICAgICAgICAgIGNvbnRlbnQ6IG9wZW5HcmFwaC5yZWxlYXNlRGF0ZSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBNdWx0aU1ldGEoeyBwcm9wZXJ0eVByZWZpeDogJ3ZpZGVvOnRhZycsIGNvbnRlbnRzOiBvcGVuR3JhcGgudGFncyB9KSxcbiAgICAgICAgICBNZXRhKHsgcHJvcGVydHk6ICd2aWRlbzpzZXJpZXMnLCBjb250ZW50OiBvcGVuR3JhcGguc2VyaWVzIH0pLFxuICAgICAgICBdXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICd2aWRlby50dl9zaG93JzpcbiAgICAgICAgdHlwZWRPcGVuR3JhcGggPSBbXG4gICAgICAgICAgTWV0YSh7IHByb3BlcnR5OiAnb2c6dHlwZScsIGNvbnRlbnQ6ICd2aWRlby50dl9zaG93JyB9KSxcbiAgICAgICAgXVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAndmlkZW8ub3RoZXInOlxuICAgICAgICB0eXBlZE9wZW5HcmFwaCA9IFtNZXRhKHsgcHJvcGVydHk6ICdvZzp0eXBlJywgY29udGVudDogJ3ZpZGVvLm90aGVyJyB9KV1cbiAgICAgICAgYnJlYWtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjazogbmV2ZXIgPSBvcGVuR3JhcGhUeXBlXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBPcGVuR3JhcGggdHlwZTogJHtfZXhoYXVzdGl2ZUNoZWNrfWApXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIE1ldGFGaWx0ZXIoW1xuICAgIE1ldGEoeyBwcm9wZXJ0eTogJ29nOmRldGVybWluZXInLCBjb250ZW50OiBvcGVuR3JhcGguZGV0ZXJtaW5lciB9KSxcbiAgICBNZXRhKHsgcHJvcGVydHk6ICdvZzp0aXRsZScsIGNvbnRlbnQ6IG9wZW5HcmFwaC50aXRsZT8uYWJzb2x1dGUgfSksXG4gICAgTWV0YSh7IHByb3BlcnR5OiAnb2c6ZGVzY3JpcHRpb24nLCBjb250ZW50OiBvcGVuR3JhcGguZGVzY3JpcHRpb24gfSksXG4gICAgTWV0YSh7IHByb3BlcnR5OiAnb2c6dXJsJywgY29udGVudDogb3BlbkdyYXBoLnVybD8udG9TdHJpbmcoKSB9KSxcbiAgICBNZXRhKHsgcHJvcGVydHk6ICdvZzpzaXRlX25hbWUnLCBjb250ZW50OiBvcGVuR3JhcGguc2l0ZU5hbWUgfSksXG4gICAgTWV0YSh7IHByb3BlcnR5OiAnb2c6bG9jYWxlJywgY29udGVudDogb3BlbkdyYXBoLmxvY2FsZSB9KSxcbiAgICBNZXRhKHsgcHJvcGVydHk6ICdvZzpjb3VudHJ5X25hbWUnLCBjb250ZW50OiBvcGVuR3JhcGguY291bnRyeU5hbWUgfSksXG4gICAgTWV0YSh7IHByb3BlcnR5OiAnb2c6dHRsJywgY29udGVudDogb3BlbkdyYXBoLnR0bD8udG9TdHJpbmcoKSB9KSxcbiAgICBNdWx0aU1ldGEoeyBwcm9wZXJ0eVByZWZpeDogJ29nOmltYWdlJywgY29udGVudHM6IG9wZW5HcmFwaC5pbWFnZXMgfSksXG4gICAgTXVsdGlNZXRhKHsgcHJvcGVydHlQcmVmaXg6ICdvZzp2aWRlbycsIGNvbnRlbnRzOiBvcGVuR3JhcGgudmlkZW9zIH0pLFxuICAgIE11bHRpTWV0YSh7IHByb3BlcnR5UHJlZml4OiAnb2c6YXVkaW8nLCBjb250ZW50czogb3BlbkdyYXBoLmF1ZGlvIH0pLFxuICAgIE11bHRpTWV0YSh7IHByb3BlcnR5UHJlZml4OiAnb2c6ZW1haWwnLCBjb250ZW50czogb3BlbkdyYXBoLmVtYWlscyB9KSxcbiAgICBNdWx0aU1ldGEoe1xuICAgICAgcHJvcGVydHlQcmVmaXg6ICdvZzpwaG9uZV9udW1iZXInLFxuICAgICAgY29udGVudHM6IG9wZW5HcmFwaC5waG9uZU51bWJlcnMsXG4gICAgfSksXG4gICAgTXVsdGlNZXRhKHtcbiAgICAgIHByb3BlcnR5UHJlZml4OiAnb2c6ZmF4X251bWJlcicsXG4gICAgICBjb250ZW50czogb3BlbkdyYXBoLmZheE51bWJlcnMsXG4gICAgfSksXG4gICAgTXVsdGlNZXRhKHtcbiAgICAgIHByb3BlcnR5UHJlZml4OiAnb2c6bG9jYWxlOmFsdGVybmF0ZScsXG4gICAgICBjb250ZW50czogb3BlbkdyYXBoLmFsdGVybmF0ZUxvY2FsZSxcbiAgICB9KSxcbiAgICAuLi4odHlwZWRPcGVuR3JhcGggPyB0eXBlZE9wZW5HcmFwaCA6IFtdKSxcbiAgXSlcbn1cblxuZnVuY3Rpb24gVHdpdHRlckFwcEl0ZW0oe1xuICBhcHAsXG4gIHR5cGUsXG59OiB7XG4gIGFwcDogVHdpdHRlckFwcERlc2NyaXB0b3JcbiAgdHlwZTogJ2lwaG9uZScgfCAnaXBhZCcgfCAnZ29vZ2xlcGxheSdcbn0pIHtcbiAgcmV0dXJuIFtcbiAgICBNZXRhKHsgbmFtZTogYHR3aXR0ZXI6YXBwOm5hbWU6JHt0eXBlfWAsIGNvbnRlbnQ6IGFwcC5uYW1lIH0pLFxuICAgIE1ldGEoeyBuYW1lOiBgdHdpdHRlcjphcHA6aWQ6JHt0eXBlfWAsIGNvbnRlbnQ6IGFwcC5pZFt0eXBlXSB9KSxcbiAgICBNZXRhKHtcbiAgICAgIG5hbWU6IGB0d2l0dGVyOmFwcDp1cmw6JHt0eXBlfWAsXG4gICAgICBjb250ZW50OiBhcHAudXJsPy5bdHlwZV0/LnRvU3RyaW5nKCksXG4gICAgfSksXG4gIF1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFR3aXR0ZXJNZXRhZGF0YSh7XG4gIHR3aXR0ZXIsXG59OiB7XG4gIHR3aXR0ZXI6IFJlc29sdmVkTWV0YWRhdGFbJ3R3aXR0ZXInXVxufSkge1xuICBpZiAoIXR3aXR0ZXIpIHJldHVybiBudWxsXG4gIGNvbnN0IHsgY2FyZCB9ID0gdHdpdHRlclxuXG4gIHJldHVybiBNZXRhRmlsdGVyKFtcbiAgICBNZXRhKHsgbmFtZTogJ3R3aXR0ZXI6Y2FyZCcsIGNvbnRlbnQ6IGNhcmQgfSksXG4gICAgTWV0YSh7IG5hbWU6ICd0d2l0dGVyOnNpdGUnLCBjb250ZW50OiB0d2l0dGVyLnNpdGUgfSksXG4gICAgTWV0YSh7IG5hbWU6ICd0d2l0dGVyOnNpdGU6aWQnLCBjb250ZW50OiB0d2l0dGVyLnNpdGVJZCB9KSxcbiAgICBNZXRhKHsgbmFtZTogJ3R3aXR0ZXI6Y3JlYXRvcicsIGNvbnRlbnQ6IHR3aXR0ZXIuY3JlYXRvciB9KSxcbiAgICBNZXRhKHsgbmFtZTogJ3R3aXR0ZXI6Y3JlYXRvcjppZCcsIGNvbnRlbnQ6IHR3aXR0ZXIuY3JlYXRvcklkIH0pLFxuICAgIE1ldGEoeyBuYW1lOiAndHdpdHRlcjp0aXRsZScsIGNvbnRlbnQ6IHR3aXR0ZXIudGl0bGU/LmFic29sdXRlIH0pLFxuICAgIE1ldGEoeyBuYW1lOiAndHdpdHRlcjpkZXNjcmlwdGlvbicsIGNvbnRlbnQ6IHR3aXR0ZXIuZGVzY3JpcHRpb24gfSksXG4gICAgTXVsdGlNZXRhKHsgbmFtZVByZWZpeDogJ3R3aXR0ZXI6aW1hZ2UnLCBjb250ZW50czogdHdpdHRlci5pbWFnZXMgfSksXG4gICAgLi4uKGNhcmQgPT09ICdwbGF5ZXInXG4gICAgICA/IHR3aXR0ZXIucGxheWVycy5mbGF0TWFwKChwbGF5ZXIpID0+IFtcbiAgICAgICAgICBNZXRhKHtcbiAgICAgICAgICAgIG5hbWU6ICd0d2l0dGVyOnBsYXllcicsXG4gICAgICAgICAgICBjb250ZW50OiBwbGF5ZXIucGxheWVyVXJsLnRvU3RyaW5nKCksXG4gICAgICAgICAgfSksXG4gICAgICAgICAgTWV0YSh7XG4gICAgICAgICAgICBuYW1lOiAndHdpdHRlcjpwbGF5ZXI6c3RyZWFtJyxcbiAgICAgICAgICAgIGNvbnRlbnQ6IHBsYXllci5zdHJlYW1VcmwudG9TdHJpbmcoKSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBNZXRhKHsgbmFtZTogJ3R3aXR0ZXI6cGxheWVyOndpZHRoJywgY29udGVudDogcGxheWVyLndpZHRoIH0pLFxuICAgICAgICAgIE1ldGEoeyBuYW1lOiAndHdpdHRlcjpwbGF5ZXI6aGVpZ2h0JywgY29udGVudDogcGxheWVyLmhlaWdodCB9KSxcbiAgICAgICAgXSlcbiAgICAgIDogW10pLFxuICAgIC4uLihjYXJkID09PSAnYXBwJ1xuICAgICAgPyBbXG4gICAgICAgICAgVHdpdHRlckFwcEl0ZW0oeyBhcHA6IHR3aXR0ZXIuYXBwLCB0eXBlOiAnaXBob25lJyB9KSxcbiAgICAgICAgICBUd2l0dGVyQXBwSXRlbSh7IGFwcDogdHdpdHRlci5hcHAsIHR5cGU6ICdpcGFkJyB9KSxcbiAgICAgICAgICBUd2l0dGVyQXBwSXRlbSh7IGFwcDogdHdpdHRlci5hcHAsIHR5cGU6ICdnb29nbGVwbGF5JyB9KSxcbiAgICAgICAgXVxuICAgICAgOiBbXSksXG4gIF0pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBBcHBMaW5rc01ldGEoe1xuICBhcHBMaW5rcyxcbn06IHtcbiAgYXBwTGlua3M6IFJlc29sdmVkTWV0YWRhdGFbJ2FwcExpbmtzJ11cbn0pIHtcbiAgaWYgKCFhcHBMaW5rcykgcmV0dXJuIG51bGxcbiAgcmV0dXJuIE1ldGFGaWx0ZXIoW1xuICAgIE11bHRpTWV0YSh7IHByb3BlcnR5UHJlZml4OiAnYWw6aW9zJywgY29udGVudHM6IGFwcExpbmtzLmlvcyB9KSxcbiAgICBNdWx0aU1ldGEoeyBwcm9wZXJ0eVByZWZpeDogJ2FsOmlwaG9uZScsIGNvbnRlbnRzOiBhcHBMaW5rcy5pcGhvbmUgfSksXG4gICAgTXVsdGlNZXRhKHsgcHJvcGVydHlQcmVmaXg6ICdhbDppcGFkJywgY29udGVudHM6IGFwcExpbmtzLmlwYWQgfSksXG4gICAgTXVsdGlNZXRhKHsgcHJvcGVydHlQcmVmaXg6ICdhbDphbmRyb2lkJywgY29udGVudHM6IGFwcExpbmtzLmFuZHJvaWQgfSksXG4gICAgTXVsdGlNZXRhKHtcbiAgICAgIHByb3BlcnR5UHJlZml4OiAnYWw6d2luZG93c19waG9uZScsXG4gICAgICBjb250ZW50czogYXBwTGlua3Mud2luZG93c19waG9uZSxcbiAgICB9KSxcbiAgICBNdWx0aU1ldGEoeyBwcm9wZXJ0eVByZWZpeDogJ2FsOndpbmRvd3MnLCBjb250ZW50czogYXBwTGlua3Mud2luZG93cyB9KSxcbiAgICBNdWx0aU1ldGEoe1xuICAgICAgcHJvcGVydHlQcmVmaXg6ICdhbDp3aW5kb3dzX3VuaXZlcnNhbCcsXG4gICAgICBjb250ZW50czogYXBwTGlua3Mud2luZG93c191bml2ZXJzYWwsXG4gICAgfSksXG4gICAgTXVsdGlNZXRhKHsgcHJvcGVydHlQcmVmaXg6ICdhbDp3ZWInLCBjb250ZW50czogYXBwTGlua3Mud2ViIH0pLFxuICBdKVxufVxuIl0sIm5hbWVzIjpbIk1ldGEiLCJNZXRhRmlsdGVyIiwiTXVsdGlNZXRhIiwiT3BlbkdyYXBoTWV0YWRhdGEiLCJvcGVuR3JhcGgiLCJ0eXBlZE9wZW5HcmFwaCIsIm9wZW5HcmFwaFR5cGUiLCJ0eXBlIiwicHJvcGVydHkiLCJjb250ZW50IiwicHVibGlzaGVkVGltZSIsInRvU3RyaW5nIiwibW9kaWZpZWRUaW1lIiwiZXhwaXJhdGlvblRpbWUiLCJwcm9wZXJ0eVByZWZpeCIsImNvbnRlbnRzIiwiYXV0aG9ycyIsInNlY3Rpb24iLCJ0YWdzIiwiaXNibiIsInJlbGVhc2VEYXRlIiwiZmlyc3ROYW1lIiwibGFzdE5hbWUiLCJ1c2VybmFtZSIsImdlbmRlciIsImR1cmF0aW9uIiwiYWxidW1zIiwibXVzaWNpYW5zIiwic29uZ3MiLCJjcmVhdG9ycyIsImFjdG9ycyIsImRpcmVjdG9ycyIsIndyaXRlcnMiLCJzZXJpZXMiLCJfZXhoYXVzdGl2ZUNoZWNrIiwiRXJyb3IiLCJkZXRlcm1pbmVyIiwidGl0bGUiLCJhYnNvbHV0ZSIsImRlc2NyaXB0aW9uIiwidXJsIiwic2l0ZU5hbWUiLCJsb2NhbGUiLCJjb3VudHJ5TmFtZSIsInR0bCIsImltYWdlcyIsInZpZGVvcyIsImF1ZGlvIiwiZW1haWxzIiwicGhvbmVOdW1iZXJzIiwiZmF4TnVtYmVycyIsImFsdGVybmF0ZUxvY2FsZSIsIlR3aXR0ZXJBcHBJdGVtIiwiYXBwIiwibmFtZSIsImlkIiwiVHdpdHRlck1ldGFkYXRhIiwidHdpdHRlciIsImNhcmQiLCJzaXRlIiwic2l0ZUlkIiwiY3JlYXRvciIsImNyZWF0b3JJZCIsIm5hbWVQcmVmaXgiLCJwbGF5ZXJzIiwiZmxhdE1hcCIsInBsYXllciIsInBsYXllclVybCIsInN0cmVhbVVybCIsIndpZHRoIiwiaGVpZ2h0IiwiQXBwTGlua3NNZXRhIiwiYXBwTGlua3MiLCJpb3MiLCJpcGhvbmUiLCJpcGFkIiwiYW5kcm9pZCIsIndpbmRvd3NfcGhvbmUiLCJ3aW5kb3dzIiwid2luZG93c191bml2ZXJzYWwiLCJ3ZWIiXSwibWFwcGluZ3Mi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QUFVeUQsU0FBU00sT0FBTztRQUFDO3VMQUNyRTVFLFlBQUFBLEVBQVU7WUFDUlksZ0JBQWdCO1lBQ2hCQyxVQUFVeUQsU0FBU08saUJBQWlCO1FBQ3RDO3VMQUNBN0UsWUFBQUEsRUFBVTtZQUFFWSxnQkFBZ0I7WUFBVUMsVUFBVXlELFNBQVNRLEdBQUc7UUFBQztLQUM5RDtBQUNIIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDI5MzQsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2VzbS9saWIvbWV0YWRhdGEvZ2VuZXJhdGUvaWNvbi1tYXJrLmpzL3Byb3h5LmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB7IGNyZWF0ZUNsaWVudE1vZHVsZVByb3h5IH0gPSByZXF1aXJlKFwicmVhY3Qtc2VydmVyLWRvbS10dXJib3BhY2svc2VydmVyXCIpO1xuXG5fX3R1cmJvcGFja19jb250ZXh0X18ubihjcmVhdGVDbGllbnRNb2R1bGVQcm94eShcIltwcm9qZWN0XS9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2VzbS9saWIvbWV0YWRhdGEvZ2VuZXJhdGUvaWNvbi1tYXJrLmpzIDxtb2R1bGUgZXZhbHVhdGlvbj5cIikpO1xuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE1BQU0sRUFBRSx1QkFBdUIsRUFBRTtBQUVqQyxzQkFBc0IsQ0FBQyxDQUFDLHdCQUF3QiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAyOTQxLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9lc20vbGliL21ldGFkYXRhL2dlbmVyYXRlL2ljb24tbWFyay5qcy9wcm94eS5janMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgeyBjcmVhdGVDbGllbnRNb2R1bGVQcm94eSB9ID0gcmVxdWlyZShcInJlYWN0LXNlcnZlci1kb20tdHVyYm9wYWNrL3NlcnZlclwiKTtcblxuX190dXJib3BhY2tfY29udGV4dF9fLm4oY3JlYXRlQ2xpZW50TW9kdWxlUHJveHkoXCJbcHJvamVjdF0vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9lc20vbGliL21ldGFkYXRhL2dlbmVyYXRlL2ljb24tbWFyay5qc1wiKSk7XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsTUFBTSxFQUFFLHVCQUF1QixFQUFFO0FBRWpDLHNCQUFzQixDQUFDLENBQUMsd0JBQXdCIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDI5NDcsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NyYy9saWIvbWV0YWRhdGEvZ2VuZXJhdGUvaWNvbi1tYXJrLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuLy8gVGhpcyBpcyBhIGNsaWVudCBjb21wb25lbnQgdGhhdCBvbmx5IHJlbmRlcnMgZHVyaW5nIFNTUixcbi8vIGJ1dCB3aWxsIGJlIHJlcGxhY2VkIGR1cmluZyBzdHJlYW1pbmcgd2l0aCBhbiBpY29uIGluc2VydGlvbiBzY3JpcHQgdGFnLlxuLy8gV2UgZG9uJ3Qgd2FudCBpdCB0byBiZSBwcmVzZW50ZWQgYW55d2hlcmUgc28gaXQncyBvbmx5IHZpc2libGUgZHVyaW5nIHN0cmVhbWluZyxcbi8vIHJpZ2h0IGFmdGVyIHRoZSBpY29uIG1ldGEgdGFncyBzbyB0aGF0IGJyb3dzZXIgY2FuIHBpY2sgaXQgdXAgYXMgc29vbiBhcyBpdCdzIHJlbmRlcmVkLlxuLy8gTm90ZTogd2UgZG9uJ3QganVzdCBlbWl0IHRoZSBzY3JpcHQgaGVyZSBiZWNhdXNlIHdlIG9ubHkgbmVlZCB0aGUgc2NyaXB0IGlmIGl0J3Mgbm90IGluIHRoZSBoZWFkLFxuLy8gYW5kIHdlIG5lZWQgaXQgdG8gYmUgaG9pc3RhYmxlIGFsb25nc2lkZSB0aGUgb3RoZXIgbWV0YWRhdGEgYnV0IHN5bmMgc2NyaXB0cyBhcmUgbm90IGhvaXN0YWJsZS5cbmV4cG9ydCBjb25zdCBJY29uTWFyayA9ICgpID0+IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICByZXR1cm4gPG1ldGEgbmFtZT1cIsKrbnh0LWljb27Cu1wiIC8+XG59XG4iXSwibmFtZXMiOlsiSWNvbk1hcmsiLCJ3aW5kb3ciLCJtZXRhIiwibmFtZSJdLCJtYXBwaW5ncyI6IiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAyOTU1LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zcmMvbGliL21ldGFkYXRhL2dlbmVyYXRlL2ljb25zLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IFJlc29sdmVkTWV0YWRhdGEgfSBmcm9tICcuLi90eXBlcy9tZXRhZGF0YS1pbnRlcmZhY2UnXG5pbXBvcnQgdHlwZSB7IEljb24sIEljb25EZXNjcmlwdG9yIH0gZnJvbSAnLi4vdHlwZXMvbWV0YWRhdGEtdHlwZXMnXG5pbXBvcnQgeyBJY29uTWFyayB9IGZyb20gJy4vaWNvbi1tYXJrJ1xuXG5pbXBvcnQgeyBNZXRhRmlsdGVyIH0gZnJvbSAnLi9tZXRhJ1xuXG5mdW5jdGlvbiBJY29uRGVzY3JpcHRvckxpbmsoeyBpY29uIH06IHsgaWNvbjogSWNvbkRlc2NyaXB0b3IgfSkge1xuICBjb25zdCB7IHVybCwgcmVsID0gJ2ljb24nLCAuLi5wcm9wcyB9ID0gaWNvblxuXG4gIHJldHVybiA8bGluayByZWw9e3JlbH0gaHJlZj17dXJsLnRvU3RyaW5nKCl9IHsuLi5wcm9wc30gLz5cbn1cblxuZnVuY3Rpb24gSWNvbkxpbmsoeyByZWwsIGljb24gfTogeyByZWw/OiBzdHJpbmc7IGljb246IEljb24gfSkge1xuICBpZiAodHlwZW9mIGljb24gPT09ICdvYmplY3QnICYmICEoaWNvbiBpbnN0YW5jZW9mIFVSTCkpIHtcbiAgICBpZiAoIWljb24ucmVsICYmIHJlbCkgaWNvbi5yZWwgPSByZWxcbiAgICByZXR1cm4gSWNvbkRlc2NyaXB0b3JMaW5rKHsgaWNvbiB9KVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGhyZWYgPSBpY29uLnRvU3RyaW5nKClcbiAgICByZXR1cm4gPGxpbmsgcmVsPXtyZWx9IGhyZWY9e2hyZWZ9IC8+XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEljb25zTWV0YWRhdGEoeyBpY29ucyB9OiB7IGljb25zOiBSZXNvbHZlZE1ldGFkYXRhWydpY29ucyddIH0pIHtcbiAgaWYgKCFpY29ucykgcmV0dXJuIG51bGxcblxuICBjb25zdCBzaG9ydGN1dExpc3QgPSBpY29ucy5zaG9ydGN1dFxuICBjb25zdCBpY29uTGlzdCA9IGljb25zLmljb25cbiAgY29uc3QgYXBwbGVMaXN0ID0gaWNvbnMuYXBwbGVcbiAgY29uc3Qgb3RoZXJMaXN0ID0gaWNvbnMub3RoZXJcblxuICBjb25zdCBoYXNJY29uID0gQm9vbGVhbihcbiAgICBzaG9ydGN1dExpc3Q/Lmxlbmd0aCB8fFxuICAgICAgaWNvbkxpc3Q/Lmxlbmd0aCB8fFxuICAgICAgYXBwbGVMaXN0Py5sZW5ndGggfHxcbiAgICAgIG90aGVyTGlzdD8ubGVuZ3RoXG4gIClcbiAgaWYgKCFoYXNJY29uKSByZXR1cm4gbnVsbFxuXG4gIHJldHVybiBNZXRhRmlsdGVyKFtcbiAgICBzaG9ydGN1dExpc3RcbiAgICAgID8gc2hvcnRjdXRMaXN0Lm1hcCgoaWNvbikgPT4gSWNvbkxpbmsoeyByZWw6ICdzaG9ydGN1dCBpY29uJywgaWNvbiB9KSlcbiAgICAgIDogbnVsbCxcbiAgICBpY29uTGlzdCA/IGljb25MaXN0Lm1hcCgoaWNvbikgPT4gSWNvbkxpbmsoeyByZWw6ICdpY29uJywgaWNvbiB9KSkgOiBudWxsLFxuICAgIGFwcGxlTGlzdFxuICAgICAgPyBhcHBsZUxpc3QubWFwKChpY29uKSA9PiBJY29uTGluayh7IHJlbDogJ2FwcGxlLXRvdWNoLWljb24nLCBpY29uIH0pKVxuICAgICAgOiBudWxsLFxuICAgIG90aGVyTGlzdCA/IG90aGVyTGlzdC5tYXAoKGljb24pID0+IEljb25EZXNjcmlwdG9yTGluayh7IGljb24gfSkpIDogbnVsbCxcbiAgICBoYXNJY29uID8gPEljb25NYXJrIC8+IDogbnVsbCxcbiAgXSlcbn1cbiJdLCJuYW1lcyI6WyJJY29uTWFyayIsIk1ldGFGaWx0ZXIiLCJJY29uRGVzY3JpcHRvckxpbmsiLCJpY29uIiwidXJsIiwicmVsIiwicHJvcHMiLCJsaW5rIiwiaHJlZiIsInRvU3RyaW5nIiwiSWNvbkxpbmsiLCJVUkwiLCJJY29uc01ldGFkYXRhIiwiaWNvbnMiLCJzaG9ydGN1dExpc3QiLCJzaG9ydGN1dCIsImljb25MaXN0IiwiYXBwbGVMaXN0IiwiYXBwbGUiLCJvdGhlckxpc3QiLCJvdGhlciIsImhhc0ljb24iLCJCb29sZWFuIiwibGVuZ3RoIiwibWFwIl0sIm1hcHBpbmdzIjoiOzs7O0FBRUEsU0FBU0EsUUFBUSxRQUFRLGNBQWE7QUFFdEMsU0FBU0MsVUFBVSxRQUFRLFNBQVE7Ozs7QUFFbkMsU0FBU0MsbUJBQW1CLEVBQUVDLElBQUksRUFBNEI7SUFDNUQsTUFBTSxFQUFFQyxHQUFHLEVBQUVDLE1BQU0sTUFBTSxFQUFFLEdBQUdDLE9BQU8sR0FBR0g7SUFFeEMsT0FBQSxXQUFBLDhOQUFPLE9BQUEsRUFBQ0ksUUFBQUE7UUFBS0YsS0FBS0E7UUFBS0csTUFBTUosSUFBSUssUUFBUTtRQUFLLEdBQUdILEtBQUs7O0FBQ3hEO0FBRUEsU0FBU0ksU0FBUyxFQUFFTCxHQUFHLEVBQUVGLElBQUksRUFBZ0M7SUFDM0QsSUFBSSxPQUFPQSxTQUFTLFlBQVksQ0FBRUEsQ0FBQUEsZ0JBQWdCUSxHQUFFLEdBQUk7UUFDdEQsSUFBSSxDQUFDUixLQUFLRSxHQUFHLElBQUlBLEtBQUtGLEtBQUtFLEdBQUcsR0FBR0E7UUFDakMsT0FBT0gsbUJBQW1CO1lBQUVDO1FBQUs7SUFDbkMsT0FBTztRQUNMLE1BQU1LLE9BQU9MLEtBQUtNLFFBQVE7UUFDMUIsT0FBQSxXQUFBLCtOQUFPLE1BQUEsRUFBQ0YsUUFBQUE7WUFBS0YsS0FBS0E7WUFBS0csTUFBTUE7O0lBQy9CO0FBQ0Y7QUFFTyxTQUFTSSxjQUFjLEVBQUVDLEtBQUssRUFBd0M7SUFDM0UsSUFBSSxDQUFDQSxPQUFPLE9BQU87SUFFbkIsTUFBTUMsZUFBZUQsTUFBTUUsUUFBUTtJQUNuQyxNQUFNQyxXQUFXSCxNQUFNVixJQUFJO0lBQzNCLE1BQU1jLFlBQVlKLE1BQU1LLEtBQUs7SUFDN0IsTUFBTUMsWUFBWU4sTUFBTU8sS0FBSztJQUU3QixNQUFNQyxVQUFVQyxRQUNkUixDQUFBQSxnQkFBQUEsT0FBQUEsS0FBQUEsSUFBQUEsYUFBY1MsTUFBTSxLQUFBLENBQ2xCUCxZQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxTQUFVTyxNQUFNLEtBQUEsQ0FDaEJOLGFBQUFBLE9BQUFBLEtBQUFBLElBQUFBLFVBQVdNLE1BQU0sS0FBQSxDQUNqQkosYUFBQUEsT0FBQUEsS0FBQUEsSUFBQUEsVUFBV0ksTUFBTTtJQUVyQixJQUFJLENBQUNGLFNBQVMsT0FBTztJQUVyQixzTEFBT3BCLGFBQUFBLEVBQVc7UUFDaEJhLGVBQ0lBLGFBQWFVLEdBQUcsQ0FBQyxDQUFDckIsT0FBU08sU0FBUztnQkFBRUwsS0FBSztnQkFBaUJGO1lBQUssTUFDakU7UUFDSmEsV0FBV0EsU0FBU1EsR0FBRyxDQUFDLENBQUNyQixPQUFTTyxTQUFTO2dCQUFFTCxLQUFLO2dCQUFRRjtZQUFLLE1BQU07UUFDckVjLFlBQ0lBLFVBQVVPLEdBQUcsQ0FBQyxDQUFDckIsT0FBU08sU0FBUztnQkFBRUwsS0FBSztnQkFBb0JGO1lBQUssTUFDakU7UUFDSmdCLFlBQVlBLFVBQVVLLEdBQUcsQ0FBQyxDQUFDckIsT0FBU0QsbUJBQW1CO2dCQUFFQztZQUFLLE1BQU07UUFDcEVrQixVQUFBQSxXQUFBQSwrTkFBVSxNQUFBLHFMQUFDckIsV0FBQUEsRUFBQUEsQ0FBQUEsS0FBYztLQUMxQjtBQUNIIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDMwMTgsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6W10sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiIiLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDMwMjIsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NyYy9saWIvbWV0YWRhdGEvZGVmYXVsdC1tZXRhZGF0YS50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUge1xuICBSZXNvbHZlZE1ldGFkYXRhLFxuICBSZXNvbHZlZFZpZXdwb3J0LFxufSBmcm9tICcuL3R5cGVzL21ldGFkYXRhLWludGVyZmFjZSdcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZURlZmF1bHRWaWV3cG9ydCgpOiBSZXNvbHZlZFZpZXdwb3J0IHtcbiAgcmV0dXJuIHtcbiAgICAvLyBuYW1lPXZpZXdwb3J0XG4gICAgd2lkdGg6ICdkZXZpY2Utd2lkdGgnLFxuICAgIGluaXRpYWxTY2FsZTogMSxcbiAgICAvLyB2aXN1YWwgbWV0YWRhdGFcbiAgICB0aGVtZUNvbG9yOiBudWxsLFxuICAgIGNvbG9yU2NoZW1lOiBudWxsLFxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVEZWZhdWx0TWV0YWRhdGEoKTogUmVzb2x2ZWRNZXRhZGF0YSB7XG4gIHJldHVybiB7XG4gICAgLy8gRGVwcmVjYXRlZCBvbmVzXG4gICAgdmlld3BvcnQ6IG51bGwsXG4gICAgdGhlbWVDb2xvcjogbnVsbCxcbiAgICBjb2xvclNjaGVtZTogbnVsbCxcblxuICAgIG1ldGFkYXRhQmFzZTogbnVsbCxcbiAgICAvLyBPdGhlciB2YWx1ZXMgYXJlIGFsbCBudWxsXG4gICAgdGl0bGU6IG51bGwsXG4gICAgZGVzY3JpcHRpb246IG51bGwsXG4gICAgYXBwbGljYXRpb25OYW1lOiBudWxsLFxuICAgIGF1dGhvcnM6IG51bGwsXG4gICAgZ2VuZXJhdG9yOiBudWxsLFxuICAgIGtleXdvcmRzOiBudWxsLFxuICAgIHJlZmVycmVyOiBudWxsLFxuICAgIGNyZWF0b3I6IG51bGwsXG4gICAgcHVibGlzaGVyOiBudWxsLFxuICAgIHJvYm90czogbnVsbCxcbiAgICBtYW5pZmVzdDogbnVsbCxcbiAgICBhbHRlcm5hdGVzOiB7XG4gICAgICBjYW5vbmljYWw6IG51bGwsXG4gICAgICBsYW5ndWFnZXM6IG51bGwsXG4gICAgICBtZWRpYTogbnVsbCxcbiAgICAgIHR5cGVzOiBudWxsLFxuICAgIH0sXG4gICAgaWNvbnM6IG51bGwsXG4gICAgb3BlbkdyYXBoOiBudWxsLFxuICAgIHR3aXR0ZXI6IG51bGwsXG4gICAgdmVyaWZpY2F0aW9uOiB7fSxcbiAgICBhcHBsZVdlYkFwcDogbnVsbCxcbiAgICBmb3JtYXREZXRlY3Rpb246IG51bGwsXG4gICAgaXR1bmVzOiBudWxsLFxuICAgIGZhY2Vib29rOiBudWxsLFxuICAgIHBpbnRlcmVzdDogbnVsbCxcbiAgICBhYnN0cmFjdDogbnVsbCxcbiAgICBhcHBMaW5rczogbnVsbCxcbiAgICBhcmNoaXZlczogbnVsbCxcbiAgICBhc3NldHM6IG51bGwsXG4gICAgYm9va21hcmtzOiBudWxsLFxuICAgIGNhdGVnb3J5OiBudWxsLFxuICAgIGNsYXNzaWZpY2F0aW9uOiBudWxsLFxuICAgIHBhZ2luYXRpb246IHtcbiAgICAgIHByZXZpb3VzOiBudWxsLFxuICAgICAgbmV4dDogbnVsbCxcbiAgICB9LFxuICAgIG90aGVyOiB7fSxcbiAgfVxufVxuIl0sIm5hbWVzIjpbImNyZWF0ZURlZmF1bHRWaWV3cG9ydCIsIndpZHRoIiwiaW5pdGlhbFNjYWxlIiwidGhlbWVDb2xvciIsImNvbG9yU2NoZW1lIiwiY3JlYXRlRGVmYXVsdE1ldGFkYXRhIiwidmlld3BvcnQiLCJtZXRhZGF0YUJhc2UiLCJ0aXRsZSIsImRlc2NyaXB0aW9uIiwiYXBwbGljYXRpb25OYW1lIiwiYXV0aG9ycyIsImdlbmVyYXRvciIsImtleXdvcmRzIiwicmVmZXJyZXIiLCJjcmVhdG9yIiwicHVibGlzaGVyIiwicm9ib3RzIiwibWFuaWZlc3QiLCJhbHRlcm5hdGVzIiwiY2Fub25pY2FsIiwibGFuZ3VhZ2VzIiwibWVkaWEiLCJ0eXBlcyIsImljb25zIiwib3BlbkdyYXBoIiwidHdpdHRlciIsInZlcmlmaWNhdGlvbiIsImFwcGxlV2ViQXBwIiwiZm9ybWF0RGV0ZWN0aW9uIiwiaXR1bmVzIiwiZmFjZWJvb2siLCJwaW50ZXJlc3QiLCJhYnN0cmFjdCIsImFwcExpbmtzIiwiYXJjaGl2ZXMiLCJhc3NldHMiLCJib29rbWFya3MiLCJjYXRlZ29yeSIsImNsYXNzaWZpY2F0aW9uIiwicGFnaW5hdGlvbiIsInByZXZpb3VzIiwibmV4dCIsIm90aGVyIl0sIm1hcHBpbmdzIjoiOzs7O0FBS08sU0FBU0E7SUFDZCxPQUFPO1FBQ0wsZ0JBQWdCO1FBQ2hCQyxPQUFPO1FBQ1BDLGNBQWM7UUFDZCxrQkFBa0I7UUFDbEJDLFlBQVk7UUFDWkMsYUFBYTtJQUNmO0FBQ0Y7QUFFTyxTQUFTQztJQUNkLE9BQU87UUFDTCxrQkFBa0I7UUFDbEJDLFVBQVU7UUFDVkgsWUFBWTtRQUNaQyxhQUFhO1FBRWJHLGNBQWM7UUFDZCw0QkFBNEI7UUFDNUJDLE9BQU87UUFDUEMsYUFBYTtRQUNiQyxpQkFBaUI7UUFDakJDLFNBQVM7UUFDVEMsV0FBVztRQUNYQyxVQUFVO1FBQ1ZDLFVBQVU7UUFDVkMsU0FBUztRQUNUQyxXQUFXO1FBQ1hDLFFBQVE7UUFDUkMsVUFBVTtRQUNWQyxZQUFZO1lBQ1ZDLFdBQVc7WUFDWEMsV0FBVztZQUNYQyxPQUFPO1lBQ1BDLE9BQU87UUFDVDtRQUNBQyxPQUFPO1FBQ1BDLFdBQVc7UUFDWEMsU0FBUztRQUNUQyxjQUFjLENBQUM7UUFDZkMsYUFBYTtRQUNiQyxpQkFBaUI7UUFDakJDLFFBQVE7UUFDUkMsVUFBVTtRQUNWQyxXQUFXO1FBQ1hDLFVBQVU7UUFDVkMsVUFBVTtRQUNWQyxVQUFVO1FBQ1ZDLFFBQVE7UUFDUkMsV0FBVztRQUNYQyxVQUFVO1FBQ1ZDLGdCQUFnQjtRQUNoQkMsWUFBWTtZQUNWQyxVQUFVO1lBQ1ZDLE1BQU07UUFDUjtRQUNBQyxPQUFPLENBQUM7SUFDVjtBQUNGIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDMwODksICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NyYy9zaGFyZWQvbGliL2lzb21vcnBoaWMvcGF0aC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRoaXMgbW9kdWxlIGlzIGZvciBuZXh0LmpzIHNlcnZlciBpbnRlcm5hbCB1c2FnZSBvZiBwYXRoIG1vZHVsZS5cbiAqIEl0IHdpbGwgdXNlIG5hdGl2ZSBwYXRoIG1vZHVsZSBmb3Igbm9kZWpzIHJ1bnRpbWUuXG4gKiBJdCB3aWxsIHVzZSBwYXRoLWJyb3dzZXJpZnkgcG9seWZpbGwgZm9yIGVkZ2UgcnVudGltZS5cbiAqL1xubGV0IHBhdGhcblxuaWYgKHByb2Nlc3MuZW52Lk5FWFRfUlVOVElNRSA9PT0gJ2VkZ2UnKSB7XG4gIHBhdGggPSByZXF1aXJlKCduZXh0L2Rpc3QvY29tcGlsZWQvcGF0aC1icm93c2VyaWZ5Jylcbn0gZWxzZSB7XG4gIHBhdGggPSByZXF1aXJlKCdwYXRoJylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXRoXG4iXSwibmFtZXMiOlsicGF0aCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1JVTlRJTUUiLCJyZXF1aXJlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Q0FJQyxHQUNELElBQUlBO0FBRUosSUFBSUMsUUFBUUMsR0FBRyxDQUFDQyxZQUFZLEtBQUssUUFBUTs7S0FFbEM7SUFDTEgsT0FBT0ksUUFBUTtBQUNqQjtBQUVBQyxPQUFPQyxPQUFPLEdBQUdOIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDMxMDQsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NyYy9saWIvbWV0YWRhdGEvcmVzb2x2ZXJzL3Jlc29sdmUtdXJsLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBwYXRoIGZyb20gJy4uLy4uLy4uL3NoYXJlZC9saWIvaXNvbW9ycGhpYy9wYXRoJ1xuaW1wb3J0IHR5cGUgeyBNZXRhZGF0YUNvbnRleHQgfSBmcm9tICcuLi90eXBlcy9yZXNvbHZlcnMnXG5cbmZ1bmN0aW9uIGlzU3RyaW5nT3JVUkwoaWNvbjogYW55KTogaWNvbiBpcyBzdHJpbmcgfCBVUkwge1xuICByZXR1cm4gdHlwZW9mIGljb24gPT09ICdzdHJpbmcnIHx8IGljb24gaW5zdGFuY2VvZiBVUkxcbn1cblxuZnVuY3Rpb24gY3JlYXRlTG9jYWxNZXRhZGF0YUJhc2UoKSB7XG4gIC8vIENoZWNrIGlmIGV4cGVyaW1lbnRhbCBIVFRQUyBpcyBlbmFibGVkXG4gIGNvbnN0IGlzRXhwZXJpbWVudGFsSHR0cHMgPSBCb29sZWFuKHByb2Nlc3MuZW52Ll9fTkVYVF9FWFBFUklNRU5UQUxfSFRUUFMpXG4gIGNvbnN0IHByb3RvY29sID0gaXNFeHBlcmltZW50YWxIdHRwcyA/ICdodHRwcycgOiAnaHR0cCdcbiAgcmV0dXJuIG5ldyBVUkwoYCR7cHJvdG9jb2x9Oi8vbG9jYWxob3N0OiR7cHJvY2Vzcy5lbnYuUE9SVCB8fCAzMDAwfWApXG59XG5cbmZ1bmN0aW9uIGdldFByZXZpZXdEZXBsb3ltZW50VXJsKCk6IFVSTCB8IHVuZGVmaW5lZCB7XG4gIGNvbnN0IG9yaWdpbiA9IHByb2Nlc3MuZW52LlZFUkNFTF9CUkFOQ0hfVVJMIHx8IHByb2Nlc3MuZW52LlZFUkNFTF9VUkxcbiAgcmV0dXJuIG9yaWdpbiA/IG5ldyBVUkwoYGh0dHBzOi8vJHtvcmlnaW59YCkgOiB1bmRlZmluZWRcbn1cblxuZnVuY3Rpb24gZ2V0UHJvZHVjdGlvbkRlcGxveW1lbnRVcmwoKTogVVJMIHwgdW5kZWZpbmVkIHtcbiAgY29uc3Qgb3JpZ2luID0gcHJvY2Vzcy5lbnYuVkVSQ0VMX1BST0pFQ1RfUFJPRFVDVElPTl9VUkxcbiAgcmV0dXJuIG9yaWdpbiA/IG5ldyBVUkwoYGh0dHBzOi8vJHtvcmlnaW59YCkgOiB1bmRlZmluZWRcbn1cblxuLyoqXG4gKiBHaXZlbiBhbiBvcHRpb25hbCB1c2VyLXByb3ZpZGVkIG1ldGFkYXRhQmFzZSwgdGhpcyBkZXRlcm1pbmVzIHdoYXQgdGhlIG1ldGFkYXRhQmFzZSBzaG91bGRcbiAqIGZhbGxiYWNrIHRvLiBTcGVjaWZpY2FsbHk6XG4gKiAtIEluIGRldiwgaXQgc2hvdWxkIGFsd2F5cyBiZSBsb2NhbGhvc3RcbiAqIC0gSW4gVmVyY2VsIHByZXZpZXcgYnVpbGRzLCBpdCBzaG91bGQgYmUgdGhlIHByZXZpZXcgYnVpbGQgSURcbiAqIC0gSW4gc3RhcnQsIGl0IHNob3VsZCBiZSB0aGUgdXNlci1wcm92aWRlZCBtZXRhZGF0YUJhc2UgdmFsdWUuIE90aGVyd2lzZSxcbiAqIGl0J2xsIGZhbGwgYmFjayB0byB0aGUgVmVyY2VsIHByb2R1Y3Rpb24gZGVwbG95bWVudCwgYW5kIGxvY2FsaG9zdCBhcyBhIGxhc3QgcmVzb3J0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U29jaWFsSW1hZ2VNZXRhZGF0YUJhc2VGYWxsYmFjayhcbiAgbWV0YWRhdGFCYXNlOiBVUkwgfCBudWxsXG4pOiBVUkwge1xuICBjb25zdCBkZWZhdWx0TWV0YWRhdGFCYXNlID0gY3JlYXRlTG9jYWxNZXRhZGF0YUJhc2UoKVxuICBjb25zdCBwcmV2aWV3RGVwbG95bWVudFVybCA9IGdldFByZXZpZXdEZXBsb3ltZW50VXJsKClcbiAgY29uc3QgcHJvZHVjdGlvbkRlcGxveW1lbnRVcmwgPSBnZXRQcm9kdWN0aW9uRGVwbG95bWVudFVybCgpXG5cbiAgbGV0IGZhbGxiYWNrTWV0YWRhdGFCYXNlXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgIGZhbGxiYWNrTWV0YWRhdGFCYXNlID0gZGVmYXVsdE1ldGFkYXRhQmFzZVxuICB9IGVsc2Uge1xuICAgIGZhbGxiYWNrTWV0YWRhdGFCYXNlID1cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIHByZXZpZXdEZXBsb3ltZW50VXJsICYmXG4gICAgICBwcm9jZXNzLmVudi5WRVJDRUxfRU5WID09PSAncHJldmlldydcbiAgICAgICAgPyBwcmV2aWV3RGVwbG95bWVudFVybFxuICAgICAgICA6IG1ldGFkYXRhQmFzZSB8fCBwcm9kdWN0aW9uRGVwbG95bWVudFVybCB8fCBkZWZhdWx0TWV0YWRhdGFCYXNlXG4gIH1cblxuICByZXR1cm4gZmFsbGJhY2tNZXRhZGF0YUJhc2Vcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVVybCh1cmw6IG51bGwgfCB1bmRlZmluZWQsIG1ldGFkYXRhQmFzZTogVVJMIHwgbnVsbCk6IG51bGxcbmZ1bmN0aW9uIHJlc29sdmVVcmwodXJsOiBzdHJpbmcgfCBVUkwsIG1ldGFkYXRhQmFzZTogVVJMIHwgbnVsbCk6IFVSTFxuZnVuY3Rpb24gcmVzb2x2ZVVybChcbiAgdXJsOiBzdHJpbmcgfCBVUkwgfCBudWxsIHwgdW5kZWZpbmVkLFxuICBtZXRhZGF0YUJhc2U6IFVSTCB8IG51bGxcbik6IFVSTCB8IG51bGxcbmZ1bmN0aW9uIHJlc29sdmVVcmwoXG4gIHVybDogc3RyaW5nIHwgVVJMIHwgbnVsbCB8IHVuZGVmaW5lZCxcbiAgbWV0YWRhdGFCYXNlOiBVUkwgfCBudWxsXG4pOiBVUkwgfCBudWxsIHtcbiAgaWYgKHVybCBpbnN0YW5jZW9mIFVSTCkgcmV0dXJuIHVybFxuICBpZiAoIXVybCkgcmV0dXJuIG51bGxcblxuICB0cnkge1xuICAgIC8vIElmIHdlIGNhbiBjb25zdHJ1Y3QgYSBVUkwgaW5zdGFuY2UgZnJvbSB1cmwsIGlnbm9yZSBtZXRhZGF0YUJhc2VcbiAgICBjb25zdCBwYXJzZWRVcmwgPSBuZXcgVVJMKHVybClcbiAgICByZXR1cm4gcGFyc2VkVXJsXG4gIH0gY2F0Y2gge31cblxuICBpZiAoIW1ldGFkYXRhQmFzZSkge1xuICAgIG1ldGFkYXRhQmFzZSA9IGNyZWF0ZUxvY2FsTWV0YWRhdGFCYXNlKClcbiAgfVxuXG4gIC8vIEhhbmRsZSByZWxhdGl2ZSBvciBhYnNvbHV0ZSBwYXRoc1xuICBjb25zdCBwYXRobmFtZSA9IG1ldGFkYXRhQmFzZS5wYXRobmFtZSB8fCAnJ1xuICBjb25zdCBqb2luZWRQYXRoID0gcGF0aC5wb3NpeC5qb2luKHBhdGhuYW1lLCB1cmwpXG5cbiAgcmV0dXJuIG5ldyBVUkwoam9pbmVkUGF0aCwgbWV0YWRhdGFCYXNlKVxufVxuXG4vLyBSZXNvbHZlIHdpdGggYHBhdGhuYW1lYCBpZiBgdXJsYCBpcyBhIHJlbGF0aXZlIHBhdGguXG5mdW5jdGlvbiByZXNvbHZlUmVsYXRpdmVVcmwodXJsOiBzdHJpbmcgfCBVUkwsIHBhdGhuYW1lOiBzdHJpbmcpOiBzdHJpbmcgfCBVUkwge1xuICBpZiAodHlwZW9mIHVybCA9PT0gJ3N0cmluZycgJiYgdXJsLnN0YXJ0c1dpdGgoJy4vJykpIHtcbiAgICByZXR1cm4gcGF0aC5wb3NpeC5yZXNvbHZlKHBhdGhuYW1lLCB1cmwpXG4gIH1cbiAgcmV0dXJuIHVybFxufVxuXG4vLyBUaGUgcmVnZXggaXMgbWF0Y2hpbmcgbG9naWMgZnJvbSBwYWNrYWdlcy9uZXh0L3NyYy9saWIvbG9hZC1jdXN0b20tcm91dGVzLnRzXG5jb25zdCBGSUxFX1JFR0VYID1cbiAgL14oPzpcXC8oKD8hXFwud2VsbC1rbm93big/OlxcLy4qKT8pKD86W14vXStcXC8pKlteL10rXFwuXFx3KykpKFxcLz98JCkvaVxuZnVuY3Rpb24gaXNGaWxlUGF0dGVybihwYXRobmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiBGSUxFX1JFR0VYLnRlc3QocGF0aG5hbWUpXG59XG5cbi8vIFJlc29sdmUgYHBhdGhuYW1lYCBpZiBgdXJsYCBpcyBhIHJlbGF0aXZlIHBhdGggdGhlIGNvbXBvc2Ugd2l0aCBgbWV0YWRhdGFCYXNlYC5cbmZ1bmN0aW9uIHJlc29sdmVBYnNvbHV0ZVVybFdpdGhQYXRobmFtZShcbiAgdXJsOiBzdHJpbmcgfCBVUkwsXG4gIG1ldGFkYXRhQmFzZTogVVJMIHwgbnVsbCxcbiAgcGF0aG5hbWU6IHN0cmluZyxcbiAgeyB0cmFpbGluZ1NsYXNoIH06IE1ldGFkYXRhQ29udGV4dFxuKTogc3RyaW5nIHtcbiAgLy8gUmVzb2x2ZSB1cmwgd2l0aCBwYXRobmFtZSB0aGF0IGFsd2F5cyBzdGFydHMgd2l0aCBgL2BcbiAgdXJsID0gcmVzb2x2ZVJlbGF0aXZlVXJsKHVybCwgcGF0aG5hbWUpXG5cbiAgLy8gQ29udmVydCBzdHJpbmcgdXJsIG9yIFVSTCBpbnN0YW5jZSB0byBhYnNvbHV0ZSB1cmwgc3RyaW5nLFxuICAvLyBpZiB0aGVyZSdzIGNhc2UgbmVlZHMgdG8gYmUgcmVzb2x2ZWQgd2l0aCBtZXRhZGF0YUJhc2VcbiAgbGV0IHJlc29sdmVkVXJsID0gJydcbiAgY29uc3QgcmVzdWx0ID0gbWV0YWRhdGFCYXNlID8gcmVzb2x2ZVVybCh1cmwsIG1ldGFkYXRhQmFzZSkgOiB1cmxcbiAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdzdHJpbmcnKSB7XG4gICAgcmVzb2x2ZWRVcmwgPSByZXN1bHRcbiAgfSBlbHNlIHtcbiAgICByZXNvbHZlZFVybCA9IHJlc3VsdC5wYXRobmFtZSA9PT0gJy8nID8gcmVzdWx0Lm9yaWdpbiA6IHJlc3VsdC5ocmVmXG4gIH1cblxuICAvLyBBZGQgdHJhaWxpbmcgc2xhc2ggaWYgaXQncyBlbmFibGVkIGZvciB1cmxzIG1hdGNoZXMgdGhlIGNvbmRpdGlvblxuICAvLyAtIE5vdCBleHRlcm5hbCwgc2FtZSBvcmlnaW4gd2l0aCBtZXRhZGF0YUJhc2VcbiAgLy8gLSBEb2Vzbid0IGhhdmUgcXVlcnlcbiAgaWYgKHRyYWlsaW5nU2xhc2ggJiYgIXJlc29sdmVkVXJsLmVuZHNXaXRoKCcvJykpIHtcbiAgICBsZXQgaXNSZWxhdGl2ZSA9IHJlc29sdmVkVXJsLnN0YXJ0c1dpdGgoJy8nKVxuICAgIGxldCBoYXNRdWVyeSA9IHJlc29sdmVkVXJsLmluY2x1ZGVzKCc/JylcbiAgICBsZXQgaXNFeHRlcm5hbCA9IGZhbHNlXG4gICAgbGV0IGlzRmlsZVVybCA9IGZhbHNlXG5cbiAgICBpZiAoIWlzUmVsYXRpdmUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFVybCA9IG5ldyBVUkwocmVzb2x2ZWRVcmwpXG4gICAgICAgIGlzRXh0ZXJuYWwgPVxuICAgICAgICAgIG1ldGFkYXRhQmFzZSAhPSBudWxsICYmIHBhcnNlZFVybC5vcmlnaW4gIT09IG1ldGFkYXRhQmFzZS5vcmlnaW5cbiAgICAgICAgaXNGaWxlVXJsID0gaXNGaWxlUGF0dGVybihwYXJzZWRVcmwucGF0aG5hbWUpXG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgLy8gSWYgaXQncyBub3QgYSB2YWxpZCBVUkwsIHRyZWF0IGl0IGFzIGV4dGVybmFsXG4gICAgICAgIGlzRXh0ZXJuYWwgPSB0cnVlXG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAgIC8vIERvIG5vdCBhcHBseSB0cmFpbGluZyBzbGFzaCBmb3IgZmlsZSBsaWtlIHVybHMsIGFsaWduaW5nIHdpdGggdGhlIGJlaGF2aW9yIHdpdGggYHRyYWlsaW5nU2xhc2hgXG4gICAgICAgICFpc0ZpbGVVcmwgJiZcbiAgICAgICAgIWlzRXh0ZXJuYWwgJiZcbiAgICAgICAgIWhhc1F1ZXJ5XG4gICAgICApXG4gICAgICAgIHJldHVybiBgJHtyZXNvbHZlZFVybH0vYFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXNvbHZlZFVybFxufVxuXG5leHBvcnQge1xuICBpc1N0cmluZ09yVVJMLFxuICByZXNvbHZlVXJsLFxuICByZXNvbHZlUmVsYXRpdmVVcmwsXG4gIHJlc29sdmVBYnNvbHV0ZVVybFdpdGhQYXRobmFtZSxcbn1cbiJdLCJuYW1lcyI6WyJwYXRoIiwiaXNTdHJpbmdPclVSTCIsImljb24iLCJVUkwiLCJjcmVhdGVMb2NhbE1ldGFkYXRhQmFzZSIsImlzRXhwZXJpbWVudGFsSHR0cHMiLCJCb29sZWFuIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9FWFBFUklNRU5UQUxfSFRUUFMiLCJwcm90b2NvbCIsIlBPUlQiLCJnZXRQcmV2aWV3RGVwbG95bWVudFVybCIsIm9yaWdpbiIsIlZFUkNFTF9CUkFOQ0hfVVJMIiwiVkVSQ0VMX1VSTCIsInVuZGVmaW5lZCIsImdldFByb2R1Y3Rpb25EZXBsb3ltZW50VXJsIiwiVkVSQ0VMX1BST0pFQ1RfUFJPRFVDVElPTl9VUkwiLCJnZXRTb2NpYWxJbWFnZU1ldGFkYXRhQmFzZUZhbGxiYWNrIiwibWV0YWRhdGFCYXNlIiwiZGVmYXVsdE1ldGFkYXRhQmFzZSIsInByZXZpZXdEZXBsb3ltZW50VXJsIiwicHJvZHVjdGlvbkRlcGxveW1lbnRVcmwiLCJmYWxsYmFja01ldGFkYXRhQmFzZSIsIk5PREVfRU5WIiwiVkVSQ0VMX0VOViIsInJlc29sdmVVcmwiLCJ1cmwiLCJwYXJzZWRVcmwiLCJwYXRobmFtZSIsImpvaW5lZFBhdGgiLCJwb3NpeCIsImpvaW4iLCJyZXNvbHZlUmVsYXRpdmVVcmwiLCJzdGFydHNXaXRoIiwicmVzb2x2ZSIsIkZJTEVfUkVHRVgiLCJpc0ZpbGVQYXR0ZXJuIiwidGVzdCIsInJlc29sdmVBYnNvbHV0ZVVybFdpdGhQYXRobmFtZSIsInRyYWlsaW5nU2xhc2giLCJyZXNvbHZlZFVybCIsInJlc3VsdCIsImhyZWYiLCJlbmRzV2l0aCIsImlzUmVsYXRpdmUiLCJoYXNRdWVyeSIsImluY2x1ZGVzIiwiaXNFeHRlcm5hbCIsImlzRmlsZVVybCJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLE9BQU9BLFVBQVUsc0NBQXFDOztBQUd0RCxTQUFTQyxjQUFjQyxJQUFTO0lBQzlCLE9BQU8sT0FBT0EsU0FBUyxZQUFZQSxnQkFBZ0JDO0FBQ3JEO0FBRUEsU0FBU0M7SUFDUCx5Q0FBeUM7SUFDekMsTUFBTUMsc0JBQXNCQyxRQUFRQyxRQUFRQyxHQUFHLENBQUNDLHlCQUF5QjtJQUN6RSxNQUFNQyxXQUFXTCxzQkFBc0IsVUFBVTtJQUNqRCxPQUFPLElBQUlGLElBQUksR0FBR08sU0FBUyxhQUFhLEVBQUVILFFBQVFDLEdBQUcsQ0FBQ0csSUFBSSxJQUFJLE1BQU07QUFDdEU7QUFFQSxTQUFTQztJQUNQLE1BQU1DLFNBQVNOLFFBQVFDLEdBQUcsQ0FBQ00saUJBQWlCLElBQUlQLFFBQVFDLEdBQUcsQ0FBQ08sVUFBVTtJQUN0RSxPQUFPRixTQUFTLElBQUlWLElBQUksQ0FBQyxRQUFRLEVBQUVVLFFBQVEsSUFBSUc7QUFDakQ7QUFFQSxTQUFTQztJQUNQLE1BQU1KLFNBQVNOLFFBQVFDLEdBQUcsQ0FBQ1UsNkJBQTZCO0lBQ3hELE9BQU9MLFNBQVMsSUFBSVYsSUFBSSxDQUFDLFFBQVEsRUFBRVUsUUFBUSxJQUFJRztBQUNqRDtBQVVPLFNBQVNHLG1DQUNkQyxZQUF3QjtJQUV4QixNQUFNQyxzQkFBc0JqQjtJQUM1QixNQUFNa0IsdUJBQXVCVjtJQUM3QixNQUFNVywwQkFBMEJOO0lBRWhDLElBQUlPO0lBQ0osSUFBSWpCLFFBQVFDLEdBQUcsQ0FBQ2lCLFFBQVEsS0FBSyxXQUFlO1FBQzFDRCx1QkFBdUJIO0lBQ3pCLE9BQU87O0lBU1AsT0FBT0c7QUFDVDtBQVFBLFNBQVNHLFdBQ1BDLEdBQW9DLEVBQ3BDUixZQUF3QjtJQUV4QixJQUFJUSxlQUFlekIsS0FBSyxPQUFPeUI7SUFDL0IsSUFBSSxDQUFDQSxLQUFLLE9BQU87SUFFakIsSUFBSTtRQUNGLG1FQUFtRTtRQUNuRSxNQUFNQyxZQUFZLElBQUkxQixJQUFJeUI7UUFDMUIsT0FBT0M7SUFDVCxFQUFFLE9BQU0sQ0FBQztJQUVULElBQUksQ0FBQ1QsY0FBYztRQUNqQkEsZUFBZWhCO0lBQ2pCO0lBRUEsb0NBQW9DO0lBQ3BDLE1BQU0wQixXQUFXVixhQUFhVSxRQUFRLElBQUk7SUFDMUMsTUFBTUMsd0xBQWEvQixVQUFBQSxDQUFLZ0MsS0FBSyxDQUFDQyxJQUFJLENBQUNILFVBQVVGO0lBRTdDLE9BQU8sSUFBSXpCLElBQUk0QixZQUFZWDtBQUM3QjtBQUVBLHVEQUF1RDtBQUN2RCxTQUFTYyxtQkFBbUJOLEdBQWlCLEVBQUVFLFFBQWdCO0lBQzdELElBQUksT0FBT0YsUUFBUSxZQUFZQSxJQUFJTyxVQUFVLENBQUMsT0FBTztRQUNuRCxrTEFBT25DLFVBQUFBLENBQUtnQyxLQUFLLENBQUNJLE9BQU8sQ0FBQ04sVUFBVUY7SUFDdEM7SUFDQSxPQUFPQTtBQUNUO0FBRUEsK0VBQStFO0FBQy9FLE1BQU1TLGFBQ0o7QUFDRixTQUFTQyxjQUFjUixRQUFnQjtJQUNyQyxPQUFPTyxXQUFXRSxJQUFJLENBQUNUO0FBQ3pCO0FBRUEsa0ZBQWtGO0FBQ2xGLFNBQVNVLCtCQUNQWixHQUFpQixFQUNqQlIsWUFBd0IsRUFDeEJVLFFBQWdCLEVBQ2hCLEVBQUVXLGFBQWEsRUFBbUI7SUFFbEMsd0RBQXdEO0lBQ3hEYixNQUFNTSxtQkFBbUJOLEtBQUtFO0lBRTlCLDZEQUE2RDtJQUM3RCx5REFBeUQ7SUFDekQsSUFBSVksY0FBYztJQUNsQixNQUFNQyxTQUFTdkIsZUFBZU8sV0FBV0MsS0FBS1IsZ0JBQWdCUTtJQUM5RCxJQUFJLE9BQU9lLFdBQVcsVUFBVTtRQUM5QkQsY0FBY0M7SUFDaEIsT0FBTztRQUNMRCxjQUFjQyxPQUFPYixRQUFRLEtBQUssTUFBTWEsT0FBTzlCLE1BQU0sR0FBRzhCLE9BQU9DLElBQUk7SUFDckU7SUFFQSxvRUFBb0U7SUFDcEUsZ0RBQWdEO0lBQ2hELHVCQUF1QjtJQUN2QixJQUFJSCxpQkFBaUIsQ0FBQ0MsWUFBWUcsUUFBUSxDQUFDLE1BQU07UUFDL0MsSUFBSUMsYUFBYUosWUFBWVAsVUFBVSxDQUFDO1FBQ3hDLElBQUlZLFdBQVdMLFlBQVlNLFFBQVEsQ0FBQztRQUNwQyxJQUFJQyxhQUFhO1FBQ2pCLElBQUlDLFlBQVk7UUFFaEIsSUFBSSxDQUFDSixZQUFZO1lBQ2YsSUFBSTtnQkFDRixNQUFNakIsWUFBWSxJQUFJMUIsSUFBSXVDO2dCQUMxQk8sYUFDRTdCLGdCQUFnQixRQUFRUyxVQUFVaEIsTUFBTSxLQUFLTyxhQUFhUCxNQUFNO2dCQUNsRXFDLFlBQVlaLGNBQWNULFVBQVVDLFFBQVE7WUFDOUMsRUFBRSxPQUFNO2dCQUNOLGdEQUFnRDtnQkFDaERtQixhQUFhO1lBQ2Y7WUFDQSxJQUNFLEFBQ0EsQ0FBQ0MsYUFDRCxDQUFDRCxjQUNELENBQUNGLFVBRUQsT0FBTyxHQUFHTCxZQUFZLENBQUMsQ0FBQyxrQ0FMMEU7UUFNdEc7SUFDRjtJQUVBLE9BQU9BO0FBQ1QiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMzIxMCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL2xpYi9tZXRhZGF0YS9yZXNvbHZlcnMvcmVzb2x2ZS10aXRsZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IE1ldGFkYXRhIH0gZnJvbSAnLi4vdHlwZXMvbWV0YWRhdGEtaW50ZXJmYWNlJ1xuaW1wb3J0IHR5cGUgeyBBYnNvbHV0ZVRlbXBsYXRlU3RyaW5nIH0gZnJvbSAnLi4vdHlwZXMvbWV0YWRhdGEtdHlwZXMnXG5cbmZ1bmN0aW9uIHJlc29sdmVUaXRsZVRlbXBsYXRlKFxuICB0ZW1wbGF0ZTogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZCxcbiAgdGl0bGU6IHN0cmluZ1xuKSB7XG4gIHJldHVybiB0ZW1wbGF0ZSA/IHRlbXBsYXRlLnJlcGxhY2UoLyVzL2csIHRpdGxlKSA6IHRpdGxlXG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlVGl0bGUoXG4gIHRpdGxlOiBNZXRhZGF0YVsndGl0bGUnXSxcbiAgc3Rhc2hlZFRlbXBsYXRlOiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkXG4pOiBBYnNvbHV0ZVRlbXBsYXRlU3RyaW5nIHtcbiAgbGV0IHJlc29sdmVkXG4gIGNvbnN0IHRlbXBsYXRlID1cbiAgICB0eXBlb2YgdGl0bGUgIT09ICdzdHJpbmcnICYmIHRpdGxlICYmICd0ZW1wbGF0ZScgaW4gdGl0bGVcbiAgICAgID8gdGl0bGUudGVtcGxhdGVcbiAgICAgIDogbnVsbFxuXG4gIGlmICh0eXBlb2YgdGl0bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmVzb2x2ZWQgPSByZXNvbHZlVGl0bGVUZW1wbGF0ZShzdGFzaGVkVGVtcGxhdGUsIHRpdGxlKVxuICB9IGVsc2UgaWYgKHRpdGxlKSB7XG4gICAgaWYgKCdkZWZhdWx0JyBpbiB0aXRsZSkge1xuICAgICAgcmVzb2x2ZWQgPSByZXNvbHZlVGl0bGVUZW1wbGF0ZShzdGFzaGVkVGVtcGxhdGUsIHRpdGxlLmRlZmF1bHQpXG4gICAgfVxuICAgIGlmICgnYWJzb2x1dGUnIGluIHRpdGxlICYmIHRpdGxlLmFic29sdXRlKSB7XG4gICAgICByZXNvbHZlZCA9IHRpdGxlLmFic29sdXRlXG4gICAgfVxuICB9XG5cbiAgaWYgKHRpdGxlICYmIHR5cGVvZiB0aXRsZSAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGVtcGxhdGUsXG4gICAgICBhYnNvbHV0ZTogcmVzb2x2ZWQgfHwgJycsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB7IGFic29sdXRlOiByZXNvbHZlZCB8fCB0aXRsZSB8fCAnJywgdGVtcGxhdGUgfVxuICB9XG59XG4iXSwibmFtZXMiOlsicmVzb2x2ZVRpdGxlVGVtcGxhdGUiLCJ0ZW1wbGF0ZSIsInRpdGxlIiwicmVwbGFjZSIsInJlc29sdmVUaXRsZSIsInN0YXNoZWRUZW1wbGF0ZSIsInJlc29sdmVkIiwiZGVmYXVsdCIsImFic29sdXRlIl0sIm1hcHBpbmdzIjoiOzs7QUFHQSxTQUFTQSxxQkFDUEMsUUFBbUMsRUFDbkNDLEtBQWE7SUFFYixPQUFPRCxXQUFXQSxTQUFTRSxPQUFPLENBQUMsT0FBT0QsU0FBU0E7QUFDckQ7QUFFTyxTQUFTRSxhQUNkRixLQUF3QixFQUN4QkcsZUFBMEM7SUFFMUMsSUFBSUM7SUFDSixNQUFNTCxXQUNKLE9BQU9DLFVBQVUsWUFBWUEsU0FBUyxjQUFjQSxRQUNoREEsTUFBTUQsUUFBUSxHQUNkO0lBRU4sSUFBSSxPQUFPQyxVQUFVLFVBQVU7UUFDN0JJLFdBQVdOLHFCQUFxQkssaUJBQWlCSDtJQUNuRCxPQUFPLElBQUlBLE9BQU87UUFDaEIsSUFBSSxhQUFhQSxPQUFPO1lBQ3RCSSxXQUFXTixxQkFBcUJLLGlCQUFpQkgsTUFBTUssT0FBTztRQUNoRTtRQUNBLElBQUksY0FBY0wsU0FBU0EsTUFBTU0sUUFBUSxFQUFFO1lBQ3pDRixXQUFXSixNQUFNTSxRQUFRO1FBQzNCO0lBQ0Y7SUFFQSxJQUFJTixTQUFTLE9BQU9BLFVBQVUsVUFBVTtRQUN0QyxPQUFPO1lBQ0xEO1lBQ0FPLFVBQVVGLFlBQVk7UUFDeEI7SUFDRixPQUFPO1FBQ0wsT0FBTztZQUFFRSxVQUFVRixZQUFZSixTQUFTO1lBQUlEO1FBQVM7SUFDdkQ7QUFDRiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAzMjQ1LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zcmMvY2xpZW50L2NvbXBvbmVudHMvYXBwLXJvdXRlci1oZWFkZXJzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBSU0NfSEVBREVSID0gJ1JTQycgYXMgY29uc3RcbmV4cG9ydCBjb25zdCBBQ1RJT05fSEVBREVSID0gJ05leHQtQWN0aW9uJyBhcyBjb25zdFxuLy8gVE9ETzogSW5zdGVhZCBvZiBzZW5kaW5nIHRoZSBmdWxsIHJvdXRlciBzdGF0ZSwgd2Ugb25seSBuZWVkIHRvIHNlbmQgdGhlXG4vLyBzZWdtZW50IHBhdGguIFNhdmVzIGJ5dGVzLiBUaGVuIHdlIGNvdWxkIGFsc28gdXNlIHRoaXMgZmllbGQgZm9yIHNlZ21lbnRcbi8vIHByZWZldGNoZXMsIHdoaWNoIGFsc28gbmVlZCB0byBzcGVjaWZ5IGEgcGFydGljdWxhciBzZWdtZW50LlxuZXhwb3J0IGNvbnN0IE5FWFRfUk9VVEVSX1NUQVRFX1RSRUVfSEVBREVSID0gJ05leHQtUm91dGVyLVN0YXRlLVRyZWUnIGFzIGNvbnN0XG5leHBvcnQgY29uc3QgTkVYVF9ST1VURVJfUFJFRkVUQ0hfSEVBREVSID0gJ05leHQtUm91dGVyLVByZWZldGNoJyBhcyBjb25zdFxuLy8gVGhpcyBjb250YWlucyB0aGUgcGF0aCB0byB0aGUgc2VnbWVudCBiZWluZyBwcmVmZXRjaGVkLlxuLy8gVE9ETzogSWYgd2UgY2hhbmdlIE5leHQtUm91dGVyLVN0YXRlLVRyZWUgdG8gYmUgYSBzZWdtZW50IHBhdGgsIHdlIGNhbiB1c2Vcbi8vIHRoYXQgaW5zdGVhZC4gVGhlbiBOZXh0LVJvdXRlci1QcmVmZXRjaCBhbmQgTmV4dC1Sb3V0ZXItU2VnbWVudC1QcmVmZXRjaCBjYW5cbi8vIGJlIG1lcmdlZCBpbnRvIGEgc2luZ2xlIGVudW0uXG5leHBvcnQgY29uc3QgTkVYVF9ST1VURVJfU0VHTUVOVF9QUkVGRVRDSF9IRUFERVIgPVxuICAnTmV4dC1Sb3V0ZXItU2VnbWVudC1QcmVmZXRjaCcgYXMgY29uc3RcbmV4cG9ydCBjb25zdCBORVhUX0hNUl9SRUZSRVNIX0hFQURFUiA9ICdOZXh0LUhNUi1SZWZyZXNoJyBhcyBjb25zdFxuZXhwb3J0IGNvbnN0IE5FWFRfSE1SX1JFRlJFU0hfSEFTSF9DT09LSUUgPSAnX19uZXh0X2htcl9yZWZyZXNoX2hhc2hfXycgYXMgY29uc3RcbmV4cG9ydCBjb25zdCBORVhUX1VSTCA9ICdOZXh0LVVybCcgYXMgY29uc3RcbmV4cG9ydCBjb25zdCBSU0NfQ09OVEVOVF9UWVBFX0hFQURFUiA9ICd0ZXh0L3gtY29tcG9uZW50JyBhcyBjb25zdFxuXG5leHBvcnQgY29uc3QgRkxJR0hUX0hFQURFUlMgPSBbXG4gIFJTQ19IRUFERVIsXG4gIE5FWFRfUk9VVEVSX1NUQVRFX1RSRUVfSEVBREVSLFxuICBORVhUX1JPVVRFUl9QUkVGRVRDSF9IRUFERVIsXG4gIE5FWFRfSE1SX1JFRlJFU0hfSEVBREVSLFxuICBORVhUX1JPVVRFUl9TRUdNRU5UX1BSRUZFVENIX0hFQURFUixcbl0gYXMgY29uc3RcblxuZXhwb3J0IGNvbnN0IE5FWFRfUlNDX1VOSU9OX1FVRVJZID0gJ19yc2MnIGFzIGNvbnN0XG5cbmV4cG9ydCBjb25zdCBORVhUX1JPVVRFUl9TVEFMRV9USU1FX0hFQURFUiA9ICd4LW5leHRqcy1zdGFsZS10aW1lJyBhcyBjb25zdFxuZXhwb3J0IGNvbnN0IE5FWFRfRElEX1BPU1RQT05FX0hFQURFUiA9ICd4LW5leHRqcy1wb3N0cG9uZWQnIGFzIGNvbnN0XG5leHBvcnQgY29uc3QgTkVYVF9SRVdSSVRURU5fUEFUSF9IRUFERVIgPSAneC1uZXh0anMtcmV3cml0dGVuLXBhdGgnIGFzIGNvbnN0XG5leHBvcnQgY29uc3QgTkVYVF9SRVdSSVRURU5fUVVFUllfSEVBREVSID0gJ3gtbmV4dGpzLXJld3JpdHRlbi1xdWVyeScgYXMgY29uc3RcbmV4cG9ydCBjb25zdCBORVhUX0lTX1BSRVJFTkRFUl9IRUFERVIgPSAneC1uZXh0anMtcHJlcmVuZGVyJyBhcyBjb25zdFxuZXhwb3J0IGNvbnN0IE5FWFRfQUNUSU9OX05PVF9GT1VORF9IRUFERVIgPSAneC1uZXh0anMtYWN0aW9uLW5vdC1mb3VuZCcgYXMgY29uc3RcbiJdLCJuYW1lcyI6WyJSU0NfSEVBREVSIiwiQUNUSU9OX0hFQURFUiIsIk5FWFRfUk9VVEVSX1NUQVRFX1RSRUVfSEVBREVSIiwiTkVYVF9ST1VURVJfUFJFRkVUQ0hfSEVBREVSIiwiTkVYVF9ST1VURVJfU0VHTUVOVF9QUkVGRVRDSF9IRUFERVIiLCJORVhUX0hNUl9SRUZSRVNIX0hFQURFUiIsIk5FWFRfSE1SX1JFRlJFU0hfSEFTSF9DT09LSUUiLCJORVhUX1VSTCIsIlJTQ19DT05URU5UX1RZUEVfSEVBREVSIiwiRkxJR0hUX0hFQURFUlMiLCJORVhUX1JTQ19VTklPTl9RVUVSWSIsIk5FWFRfUk9VVEVSX1NUQUxFX1RJTUVfSEVBREVSIiwiTkVYVF9ESURfUE9TVFBPTkVfSEVBREVSIiwiTkVYVF9SRVdSSVRURU5fUEFUSF9IRUFERVIiLCJORVhUX1JFV1JJVFRFTl9RVUVSWV9IRUFERVIiLCJORVhUX0lTX1BSRVJFTkRFUl9IRUFERVIiLCJORVhUX0FDVElPTl9OT1RfRk9VTkRfSEVBREVSIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQU8sTUFBTUEsYUFBYSxNQUFjO0FBQ2pDLE1BQU1DLGdCQUFnQixjQUFzQjtBQUk1QyxNQUFNQyxnQ0FBZ0MseUJBQWlDO0FBQ3ZFLE1BQU1DLDhCQUE4Qix1QkFBK0I7QUFLbkUsTUFBTUMsc0NBQ1gsK0JBQXVDO0FBQ2xDLE1BQU1DLDBCQUEwQixtQkFBMkI7QUFDM0QsTUFBTUMsK0JBQStCLDRCQUFvQztBQUN6RSxNQUFNQyxXQUFXLFdBQW1CO0FBQ3BDLE1BQU1DLDBCQUEwQixtQkFBMkI7QUFFM0QsTUFBTUMsaUJBQWlCO0lBQzVCVDtJQUNBRTtJQUNBQztJQUNBRTtJQUNBRDtDQUNELENBQVM7QUFFSCxNQUFNTSx1QkFBdUIsT0FBZTtBQUU1QyxNQUFNQyxnQ0FBZ0Msc0JBQThCO0FBQ3BFLE1BQU1DLDJCQUEyQixxQkFBNkI7QUFDOUQsTUFBTUMsNkJBQTZCLDBCQUFrQztBQUNyRSxNQUFNQyw4QkFBOEIsMkJBQW1DO0FBQ3ZFLE1BQU1DLDJCQUEyQixxQkFBNkI7QUFDOUQsTUFBTUMsK0JBQStCLDRCQUFvQyIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAzMjkxLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zcmMvbGliL3VybC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IFVybFdpdGhQYXJzZWRRdWVyeSB9IGZyb20gJ3VybCdcbmltcG9ydCB7IE5FWFRfUlNDX1VOSU9OX1FVRVJZIH0gZnJvbSAnLi4vY2xpZW50L2NvbXBvbmVudHMvYXBwLXJvdXRlci1oZWFkZXJzJ1xuXG5jb25zdCBEVU1NWV9PUklHSU4gPSAnaHR0cDovL24nXG5cbmV4cG9ydCBmdW5jdGlvbiBpc0Z1bGxTdHJpbmdVcmwodXJsOiBzdHJpbmcpIHtcbiAgcmV0dXJuIC9odHRwcz86XFwvXFwvLy50ZXN0KHVybClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlVXJsKHVybDogc3RyaW5nKTogVVJMIHwgdW5kZWZpbmVkIHtcbiAgbGV0IHBhcnNlZDogVVJMIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkXG4gIHRyeSB7XG4gICAgcGFyc2VkID0gbmV3IFVSTCh1cmwsIERVTU1ZX09SSUdJTilcbiAgfSBjYXRjaCB7fVxuICByZXR1cm4gcGFyc2VkXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVJlcVVybCh1cmw6IHN0cmluZyk6IFVybFdpdGhQYXJzZWRRdWVyeSB8IHVuZGVmaW5lZCB7XG4gIGNvbnN0IHBhcnNlZFVybDogVVJMIHwgdW5kZWZpbmVkID0gcGFyc2VVcmwodXJsKVxuXG4gIGlmICghcGFyc2VkVXJsKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCBxdWVyeTogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgc3RyaW5nW10+ID0ge31cblxuICBmb3IgKGNvbnN0IGtleSBvZiBwYXJzZWRVcmwuc2VhcmNoUGFyYW1zLmtleXMoKSkge1xuICAgIGNvbnN0IHZhbHVlcyA9IHBhcnNlZFVybC5zZWFyY2hQYXJhbXMuZ2V0QWxsKGtleSlcbiAgICBxdWVyeVtrZXldID0gdmFsdWVzLmxlbmd0aCA+IDEgPyB2YWx1ZXMgOiB2YWx1ZXNbMF1cbiAgfVxuXG4gIGNvbnN0IGxlZ2FjeVVybDogVXJsV2l0aFBhcnNlZFF1ZXJ5ID0ge1xuICAgIHF1ZXJ5LFxuICAgIGhhc2g6IHBhcnNlZFVybC5oYXNoLFxuICAgIHNlYXJjaDogcGFyc2VkVXJsLnNlYXJjaCxcbiAgICBwYXRoOiBwYXJzZWRVcmwucGF0aG5hbWUsXG4gICAgcGF0aG5hbWU6IHBhcnNlZFVybC5wYXRobmFtZSxcbiAgICBocmVmOiBgJHtwYXJzZWRVcmwucGF0aG5hbWV9JHtwYXJzZWRVcmwuc2VhcmNofSR7cGFyc2VkVXJsLmhhc2h9YCxcbiAgICBob3N0OiAnJyxcbiAgICBob3N0bmFtZTogJycsXG4gICAgYXV0aDogJycsXG4gICAgcHJvdG9jb2w6ICcnLFxuICAgIHNsYXNoZXM6IG51bGwsXG4gICAgcG9ydDogJycsXG4gIH1cbiAgcmV0dXJuIGxlZ2FjeVVybFxufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RyaXBOZXh0UnNjVW5pb25RdWVyeShyZWxhdGl2ZVVybDogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3QgdXJsSW5zdGFuY2UgPSBuZXcgVVJMKHJlbGF0aXZlVXJsLCBEVU1NWV9PUklHSU4pXG4gIHVybEluc3RhbmNlLnNlYXJjaFBhcmFtcy5kZWxldGUoTkVYVF9SU0NfVU5JT05fUVVFUlkpXG5cbiAgcmV0dXJuIHVybEluc3RhbmNlLnBhdGhuYW1lICsgdXJsSW5zdGFuY2Uuc2VhcmNoXG59XG4iXSwibmFtZXMiOlsiTkVYVF9SU0NfVU5JT05fUVVFUlkiLCJEVU1NWV9PUklHSU4iLCJpc0Z1bGxTdHJpbmdVcmwiLCJ1cmwiLCJ0ZXN0IiwicGFyc2VVcmwiLCJwYXJzZWQiLCJ1bmRlZmluZWQiLCJVUkwiLCJwYXJzZVJlcVVybCIsInBhcnNlZFVybCIsInF1ZXJ5Iiwia2V5Iiwic2VhcmNoUGFyYW1zIiwia2V5cyIsInZhbHVlcyIsImdldEFsbCIsImxlbmd0aCIsImxlZ2FjeVVybCIsImhhc2giLCJzZWFyY2giLCJwYXRoIiwicGF0aG5hbWUiLCJocmVmIiwiaG9zdCIsImhvc3RuYW1lIiwiYXV0aCIsInByb3RvY29sIiwic2xhc2hlcyIsInBvcnQiLCJzdHJpcE5leHRSc2NVbmlvblF1ZXJ5IiwicmVsYXRpdmVVcmwiLCJ1cmxJbnN0YW5jZSIsImRlbGV0ZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQ0EsU0FBU0Esb0JBQW9CLFFBQVEsMENBQXlDOztBQUU5RSxNQUFNQyxlQUFlO0FBRWQsU0FBU0MsZ0JBQWdCQyxHQUFXO0lBQ3pDLE9BQU8sY0FBY0MsSUFBSSxDQUFDRDtBQUM1QjtBQUVPLFNBQVNFLFNBQVNGLEdBQVc7SUFDbEMsSUFBSUcsU0FBMEJDO0lBQzlCLElBQUk7UUFDRkQsU0FBUyxJQUFJRSxJQUFJTCxLQUFLRjtJQUN4QixFQUFFLE9BQU0sQ0FBQztJQUNULE9BQU9LO0FBQ1Q7QUFFTyxTQUFTRyxZQUFZTixHQUFXO0lBQ3JDLE1BQU1PLFlBQTZCTCxTQUFTRjtJQUU1QyxJQUFJLENBQUNPLFdBQVc7UUFDZDtJQUNGO0lBRUEsTUFBTUMsUUFBMkMsQ0FBQztJQUVsRCxLQUFLLE1BQU1DLE9BQU9GLFVBQVVHLFlBQVksQ0FBQ0MsSUFBSSxHQUFJO1FBQy9DLE1BQU1DLFNBQVNMLFVBQVVHLFlBQVksQ0FBQ0csTUFBTSxDQUFDSjtRQUM3Q0QsS0FBSyxDQUFDQyxJQUFJLEdBQUdHLE9BQU9FLE1BQU0sR0FBRyxJQUFJRixTQUFTQSxNQUFNLENBQUMsRUFBRTtJQUNyRDtJQUVBLE1BQU1HLFlBQWdDO1FBQ3BDUDtRQUNBUSxNQUFNVCxVQUFVUyxJQUFJO1FBQ3BCQyxRQUFRVixVQUFVVSxNQUFNO1FBQ3hCQyxNQUFNWCxVQUFVWSxRQUFRO1FBQ3hCQSxVQUFVWixVQUFVWSxRQUFRO1FBQzVCQyxNQUFNLEdBQUdiLFVBQVVZLFFBQVEsR0FBR1osVUFBVVUsTUFBTSxHQUFHVixVQUFVUyxJQUFJLEVBQUU7UUFDakVLLE1BQU07UUFDTkMsVUFBVTtRQUNWQyxNQUFNO1FBQ05DLFVBQVU7UUFDVkMsU0FBUztRQUNUQyxNQUFNO0lBQ1I7SUFDQSxPQUFPWDtBQUNUO0FBRU8sU0FBU1ksdUJBQXVCQyxXQUFtQjtJQUN4RCxNQUFNQyxjQUFjLElBQUl4QixJQUFJdUIsYUFBYTlCO0lBQ3pDK0IsWUFBWW5CLFlBQVksQ0FBQ29CLE1BQU0seUxBQUNqQyx1QkFBQUE7SUFFaEMsT0FBT2dDLFlBQVlWLFFBQVEsR0FBR1UsWUFBWVosTUFBTTtBQUNsRCIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAzMzQ1LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zcmMvbGliL3BpY29jb2xvcnMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSVNDIExpY2Vuc2VcblxuLy8gQ29weXJpZ2h0IChjKSAyMDIxIEFsZXhleSBSYXNwb3BvdiwgS29zdGlhbnR5biBEZW55c292LCBBbnRvbiBWZXJpbm92XG5cbi8vIFBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxuLy8gcHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLCBwcm92aWRlZCB0aGF0IHRoZSBhYm92ZVxuLy8gY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBhcHBlYXIgaW4gYWxsIGNvcGllcy5cblxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVNcbi8vIFdJVEggUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SXG4vLyBBTlkgU1BFQ0lBTCwgRElSRUNULCBJTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTXG4vLyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NIExPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU5cbi8vIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUiBPVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GXG4vLyBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUiBQRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxuLy9cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbGV4ZXlyYXNwb3Bvdi9waWNvY29sb3JzL2Jsb2IvYjYyNjE0ODdlN2I4MWFhYWIyNDQwZTM5N2EzNTY3MzJjYWQ5ZTM0Mi9waWNvY29sb3JzLmpzI0wxXG5cbmNvbnN0IHsgZW52LCBzdGRvdXQgfSA9IGdsb2JhbFRoaXM/LnByb2Nlc3MgPz8ge31cblxuY29uc3QgZW5hYmxlZCA9XG4gIGVudiAmJlxuICAhZW52Lk5PX0NPTE9SICYmXG4gIChlbnYuRk9SQ0VfQ09MT1IgfHwgKHN0ZG91dD8uaXNUVFkgJiYgIWVudi5DSSAmJiBlbnYuVEVSTSAhPT0gJ2R1bWInKSlcblxuY29uc3QgcmVwbGFjZUNsb3NlID0gKFxuICBzdHI6IHN0cmluZyxcbiAgY2xvc2U6IHN0cmluZyxcbiAgcmVwbGFjZTogc3RyaW5nLFxuICBpbmRleDogbnVtYmVyXG4pOiBzdHJpbmcgPT4ge1xuICBjb25zdCBzdGFydCA9IHN0ci5zdWJzdHJpbmcoMCwgaW5kZXgpICsgcmVwbGFjZVxuICBjb25zdCBlbmQgPSBzdHIuc3Vic3RyaW5nKGluZGV4ICsgY2xvc2UubGVuZ3RoKVxuICBjb25zdCBuZXh0SW5kZXggPSBlbmQuaW5kZXhPZihjbG9zZSlcbiAgcmV0dXJuIH5uZXh0SW5kZXhcbiAgICA/IHN0YXJ0ICsgcmVwbGFjZUNsb3NlKGVuZCwgY2xvc2UsIHJlcGxhY2UsIG5leHRJbmRleClcbiAgICA6IHN0YXJ0ICsgZW5kXG59XG5cbmNvbnN0IGZvcm1hdHRlciA9IChvcGVuOiBzdHJpbmcsIGNsb3NlOiBzdHJpbmcsIHJlcGxhY2UgPSBvcGVuKSA9PiB7XG4gIGlmICghZW5hYmxlZCkgcmV0dXJuIFN0cmluZ1xuICByZXR1cm4gKGlucHV0OiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCBzdHJpbmcgPSAnJyArIGlucHV0XG4gICAgY29uc3QgaW5kZXggPSBzdHJpbmcuaW5kZXhPZihjbG9zZSwgb3Blbi5sZW5ndGgpXG4gICAgcmV0dXJuIH5pbmRleFxuICAgICAgPyBvcGVuICsgcmVwbGFjZUNsb3NlKHN0cmluZywgY2xvc2UsIHJlcGxhY2UsIGluZGV4KSArIGNsb3NlXG4gICAgICA6IG9wZW4gKyBzdHJpbmcgKyBjbG9zZVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCByZXNldCA9IGVuYWJsZWQgPyAoczogc3RyaW5nKSA9PiBgXFx4MWJbMG0ke3N9XFx4MWJbMG1gIDogU3RyaW5nXG5leHBvcnQgY29uc3QgYm9sZCA9IGZvcm1hdHRlcignXFx4MWJbMW0nLCAnXFx4MWJbMjJtJywgJ1xceDFiWzIybVxceDFiWzFtJylcbmV4cG9ydCBjb25zdCBkaW0gPSBmb3JtYXR0ZXIoJ1xceDFiWzJtJywgJ1xceDFiWzIybScsICdcXHgxYlsyMm1cXHgxYlsybScpXG5leHBvcnQgY29uc3QgaXRhbGljID0gZm9ybWF0dGVyKCdcXHgxYlszbScsICdcXHgxYlsyM20nKVxuZXhwb3J0IGNvbnN0IHVuZGVybGluZSA9IGZvcm1hdHRlcignXFx4MWJbNG0nLCAnXFx4MWJbMjRtJylcbmV4cG9ydCBjb25zdCBpbnZlcnNlID0gZm9ybWF0dGVyKCdcXHgxYls3bScsICdcXHgxYlsyN20nKVxuZXhwb3J0IGNvbnN0IGhpZGRlbiA9IGZvcm1hdHRlcignXFx4MWJbOG0nLCAnXFx4MWJbMjhtJylcbmV4cG9ydCBjb25zdCBzdHJpa2V0aHJvdWdoID0gZm9ybWF0dGVyKCdcXHgxYls5bScsICdcXHgxYlsyOW0nKVxuZXhwb3J0IGNvbnN0IGJsYWNrID0gZm9ybWF0dGVyKCdcXHgxYlszMG0nLCAnXFx4MWJbMzltJylcbmV4cG9ydCBjb25zdCByZWQgPSBmb3JtYXR0ZXIoJ1xceDFiWzMxbScsICdcXHgxYlszOW0nKVxuZXhwb3J0IGNvbnN0IGdyZWVuID0gZm9ybWF0dGVyKCdcXHgxYlszMm0nLCAnXFx4MWJbMzltJylcbmV4cG9ydCBjb25zdCB5ZWxsb3cgPSBmb3JtYXR0ZXIoJ1xceDFiWzMzbScsICdcXHgxYlszOW0nKVxuZXhwb3J0IGNvbnN0IGJsdWUgPSBmb3JtYXR0ZXIoJ1xceDFiWzM0bScsICdcXHgxYlszOW0nKVxuZXhwb3J0IGNvbnN0IG1hZ2VudGEgPSBmb3JtYXR0ZXIoJ1xceDFiWzM1bScsICdcXHgxYlszOW0nKVxuZXhwb3J0IGNvbnN0IHB1cnBsZSA9IGZvcm1hdHRlcignXFx4MWJbMzg7MjsxNzM7MTI3OzE2OG0nLCAnXFx4MWJbMzltJylcbmV4cG9ydCBjb25zdCBjeWFuID0gZm9ybWF0dGVyKCdcXHgxYlszNm0nLCAnXFx4MWJbMzltJylcbmV4cG9ydCBjb25zdCB3aGl0ZSA9IGZvcm1hdHRlcignXFx4MWJbMzdtJywgJ1xceDFiWzM5bScpXG5leHBvcnQgY29uc3QgZ3JheSA9IGZvcm1hdHRlcignXFx4MWJbOTBtJywgJ1xceDFiWzM5bScpXG5leHBvcnQgY29uc3QgYmdCbGFjayA9IGZvcm1hdHRlcignXFx4MWJbNDBtJywgJ1xceDFiWzQ5bScpXG5leHBvcnQgY29uc3QgYmdSZWQgPSBmb3JtYXR0ZXIoJ1xceDFiWzQxbScsICdcXHgxYls0OW0nKVxuZXhwb3J0IGNvbnN0IGJnR3JlZW4gPSBmb3JtYXR0ZXIoJ1xceDFiWzQybScsICdcXHgxYls0OW0nKVxuZXhwb3J0IGNvbnN0IGJnWWVsbG93ID0gZm9ybWF0dGVyKCdcXHgxYls0M20nLCAnXFx4MWJbNDltJylcbmV4cG9ydCBjb25zdCBiZ0JsdWUgPSBmb3JtYXR0ZXIoJ1xceDFiWzQ0bScsICdcXHgxYls0OW0nKVxuZXhwb3J0IGNvbnN0IGJnTWFnZW50YSA9IGZvcm1hdHRlcignXFx4MWJbNDVtJywgJ1xceDFiWzQ5bScpXG5leHBvcnQgY29uc3QgYmdDeWFuID0gZm9ybWF0dGVyKCdcXHgxYls0Nm0nLCAnXFx4MWJbNDltJylcbmV4cG9ydCBjb25zdCBiZ1doaXRlID0gZm9ybWF0dGVyKCdcXHgxYls0N20nLCAnXFx4MWJbNDltJylcbiJdLCJuYW1lcyI6WyJnbG9iYWxUaGlzIiwiZW52Iiwic3Rkb3V0IiwicHJvY2VzcyIsImVuYWJsZWQiLCJOT19DT0xPUiIsIkZPUkNFX0NPTE9SIiwiaXNUVFkiLCJDSSIsIlRFUk0iLCJyZXBsYWNlQ2xvc2UiLCJzdHIiLCJjbG9zZSIsInJlcGxhY2UiLCJpbmRleCIsInN0YXJ0Iiwic3Vic3RyaW5nIiwiZW5kIiwibGVuZ3RoIiwibmV4dEluZGV4IiwiaW5kZXhPZiIsImZvcm1hdHRlciIsIm9wZW4iLCJTdHJpbmciLCJpbnB1dCIsInN0cmluZyIsInJlc2V0IiwicyIsImJvbGQiLCJkaW0iLCJpdGFsaWMiLCJ1bmRlcmxpbmUiLCJpbnZlcnNlIiwiaGlkZGVuIiwic3RyaWtldGhyb3VnaCIsImJsYWNrIiwicmVkIiwiZ3JlZW4iLCJ5ZWxsb3ciLCJibHVlIiwibWFnZW50YSIsInB1cnBsZSIsImN5YW4iLCJ3aGl0ZSIsImdyYXkiLCJiZ0JsYWNrIiwiYmdSZWQiLCJiZ0dyZWVuIiwiYmdZZWxsb3ciLCJiZ0JsdWUiLCJiZ01hZ2VudGEiLCJiZ0N5YW4iLCJiZ1doaXRlIl0sIm1hcHBpbmdzIjoiQUFBQSxjQUFjO0FBRWQsd0VBQXdFO0FBRXhFLDJFQUEyRTtBQUMzRSx5RUFBeUU7QUFDekUsb0VBQW9FO0FBRXBFLDJFQUEyRTtBQUMzRSxtRUFBbUU7QUFDbkUsMEVBQTBFO0FBQzFFLHlFQUF5RTtBQUN6RSx3RUFBd0U7QUFDeEUsMEVBQTBFO0FBQzFFLGlFQUFpRTtBQUNqRSxFQUFFO0FBQ0YsOEdBQThHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQUV0RkE7QUFBeEIsTUFBTSxFQUFFQyxHQUFHLEVBQUVDLE1BQU0sRUFBRSxHQUFHRixDQUFBQSxDQUFBQSxjQUFBQSxVQUFBQSxLQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxZQUFZRyxPQUFPLEtBQUksQ0FBQztBQUVoRCxNQUFNQyxVQUNKSCxPQUNBLENBQUNBLElBQUlJLFFBQVEsSUFDWkosQ0FBQUEsSUFBSUssV0FBVyxJQUFLSixDQUFBQSxVQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxPQUFRSyxLQUFLLEtBQUksQ0FBQ04sSUFBSU8sRUFBRSxJQUFJUCxJQUFJUSxJQUFJLEtBQUssTUFBTTtBQUV0RSxNQUFNQyxlQUFlLENBQ25CQyxLQUNBQyxPQUNBQyxTQUNBQztJQUVBLE1BQU1DLFFBQVFKLElBQUlLLFNBQVMsQ0FBQyxHQUFHRixTQUFTRDtJQUN4QyxNQUFNSSxNQUFNTixJQUFJSyxTQUFTLENBQUNGLFFBQVFGLE1BQU1NLE1BQU07SUFDOUMsTUFBTUMsWUFBWUYsSUFBSUcsT0FBTyxDQUFDUjtJQUM5QixPQUFPLENBQUNPLFlBQ0pKLFFBQVFMLGFBQWFPLEtBQUtMLE9BQU9DLFNBQVNNLGFBQzFDSixRQUFRRTtBQUNkO0FBRUEsTUFBTUksWUFBWSxDQUFDQyxNQUFjVixPQUFlQyxVQUFVUyxJQUFJO0lBQzVELElBQUksQ0FBQ2xCLFNBQVMsT0FBT21CO0lBQ3JCLE9BQU8sQ0FBQ0M7UUFDTixNQUFNQyxTQUFTLEtBQUtEO1FBQ3BCLE1BQU1WLFFBQVFXLE9BQU9MLE9BQU8sQ0FBQ1IsT0FBT1UsS0FBS0osTUFBTTtRQUMvQyxPQUFPLENBQUNKLFFBQ0pRLE9BQU9aLGFBQWFlLFFBQVFiLE9BQU9DLFNBQVNDLFNBQVNGLFFBQ3JEVSxPQUFPRyxTQUFTYjtJQUN0QjtBQUNGO0FBRU8sTUFBTWMsUUFBUXRCLFVBQVUsQ0FBQ3VCLElBQWMsQ0FBQyxPQUFPLEVBQUVBLEVBQUUsT0FBTyxDQUFDLEdBQUdKLE9BQU07QUFDcEUsTUFBTUssT0FBT1AsVUFBVSxXQUFXLFlBQVksbUJBQWtCO0FBQ2hFLE1BQU1RLE1BQU1SLFVBQVUsV0FBVyxZQUFZLG1CQUFrQjtBQUMvRCxNQUFNUyxTQUFTVCxVQUFVLFdBQVcsWUFBVztBQUMvQyxNQUFNVSxZQUFZVixVQUFVLFdBQVcsWUFBVztBQUNsRCxNQUFNVyxVQUFVWCxVQUFVLFdBQVcsWUFBVztBQUNoRCxNQUFNWSxTQUFTWixVQUFVLFdBQVcsWUFBVztBQUMvQyxNQUFNYSxnQkFBZ0JiLFVBQVUsV0FBVyxZQUFXO0FBQ3RELE1BQU1jLFFBQVFkLFVBQVUsWUFBWSxZQUFXO0FBQy9DLE1BQU1lLE1BQU1mLFVBQVUsWUFBWSxZQUFXO0FBQzdDLE1BQU1nQixRQUFRaEIsVUFBVSxZQUFZLFlBQVc7QUFDL0MsTUFBTWlCLFNBQVNqQixVQUFVLFlBQVksWUFBVztBQUNoRCxNQUFNa0IsT0FBT2xCLFVBQVUsWUFBWSxZQUFXO0FBQzlDLE1BQU1tQixVQUFVbkIsVUFBVSxZQUFZLFlBQVc7QUFDakQsTUFBTW9CLFNBQVNwQixVQUFVLDBCQUEwQixZQUFXO0FBQzlELE1BQU1xQixPQUFPckIsVUFBVSxZQUFZLFlBQVc7QUFDOUMsTUFBTXNCLFFBQVF0QixVQUFVLFlBQVksWUFBVztBQUMvQyxNQUFNdUIsT0FBT3ZCLFVBQVUsWUFBWSxZQUFXO0FBQzlDLE1BQU13QixVQUFVeEIsVUFBVSxZQUFZLFlBQVc7QUFDakQsTUFBTXlCLFFBQVF6QixVQUFVLFlBQVksWUFBVztBQUMvQyxNQUFNMEIsVUFBVTFCLFVBQVUsWUFBWSxZQUFXO0FBQ2pELE1BQU0yQixXQUFXM0IsVUFBVSxZQUFZLFlBQVc7QUFDbEQsTUFBTTRCLFNBQVM1QixVQUFVLFlBQVksWUFBVztBQUNoRCxNQUFNNkIsWUFBWTdCLFVBQVUsWUFBWSxZQUFXO0FBQ25ELE1BQU04QixTQUFTOUIsVUFBVSxZQUFZLFlBQVc7QUFDaEQsTUFBTStCLFVBQVUvQixVQUFVLFlBQVksWUFBVyIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAzNDM0LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zcmMvc2VydmVyL2xpYi9scnUtY2FjaGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNsYXNzIExSVUNhY2hlPFQ+IHtcbiAgcHJpdmF0ZSBjYWNoZTogTWFwPHN0cmluZywgVD5cbiAgcHJpdmF0ZSBzaXplczogTWFwPHN0cmluZywgbnVtYmVyPlxuICBwcml2YXRlIHRvdGFsU2l6ZTogbnVtYmVyXG4gIHByaXZhdGUgbWF4U2l6ZTogbnVtYmVyXG4gIHByaXZhdGUgY2FsY3VsYXRlU2l6ZTogKHZhbHVlOiBUKSA9PiBudW1iZXJcblxuICBjb25zdHJ1Y3RvcihtYXhTaXplOiBudW1iZXIsIGNhbGN1bGF0ZVNpemU/OiAodmFsdWU6IFQpID0+IG51bWJlcikge1xuICAgIHRoaXMuY2FjaGUgPSBuZXcgTWFwKClcbiAgICB0aGlzLnNpemVzID0gbmV3IE1hcCgpXG4gICAgdGhpcy50b3RhbFNpemUgPSAwXG4gICAgdGhpcy5tYXhTaXplID0gbWF4U2l6ZVxuICAgIHRoaXMuY2FsY3VsYXRlU2l6ZSA9IGNhbGN1bGF0ZVNpemUgfHwgKCgpID0+IDEpXG4gIH1cblxuICBzZXQoa2V5Pzogc3RyaW5nIHwgbnVsbCwgdmFsdWU/OiBUKTogdm9pZCB7XG4gICAgaWYgKCFrZXkgfHwgIXZhbHVlKSByZXR1cm5cblxuICAgIGNvbnN0IHNpemUgPSB0aGlzLmNhbGN1bGF0ZVNpemUodmFsdWUpXG5cbiAgICBpZiAoc2l6ZSA+IHRoaXMubWF4U2l6ZSkge1xuICAgICAgY29uc29sZS53YXJuKCdTaW5nbGUgaXRlbSBzaXplIGV4Y2VlZHMgbWF4U2l6ZScpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodGhpcy5jYWNoZS5oYXMoa2V5KSkge1xuICAgICAgdGhpcy50b3RhbFNpemUgLT0gdGhpcy5zaXplcy5nZXQoa2V5KSB8fCAwXG4gICAgfVxuXG4gICAgdGhpcy5jYWNoZS5zZXQoa2V5LCB2YWx1ZSlcbiAgICB0aGlzLnNpemVzLnNldChrZXksIHNpemUpXG4gICAgdGhpcy50b3RhbFNpemUgKz0gc2l6ZVxuXG4gICAgdGhpcy50b3VjaChrZXkpXG4gIH1cblxuICBoYXMoa2V5Pzogc3RyaW5nIHwgbnVsbCk6IGJvb2xlYW4ge1xuICAgIGlmICgha2V5KSByZXR1cm4gZmFsc2VcblxuICAgIHRoaXMudG91Y2goa2V5KVxuICAgIHJldHVybiBCb29sZWFuKHRoaXMuY2FjaGUuZ2V0KGtleSkpXG4gIH1cblxuICBnZXQoa2V5Pzogc3RyaW5nIHwgbnVsbCk6IFQgfCB1bmRlZmluZWQge1xuICAgIGlmICgha2V5KSByZXR1cm5cblxuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5jYWNoZS5nZXQoa2V5KVxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgdGhpcy50b3VjaChrZXkpXG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICBwcml2YXRlIHRvdWNoKGtleTogc3RyaW5nKTogdm9pZCB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLmNhY2hlLmdldChrZXkpXG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuY2FjaGUuZGVsZXRlKGtleSlcbiAgICAgIHRoaXMuY2FjaGUuc2V0KGtleSwgdmFsdWUpXG4gICAgICB0aGlzLmV2aWN0SWZOZWNlc3NhcnkoKVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZXZpY3RJZk5lY2Vzc2FyeSgpOiB2b2lkIHtcbiAgICB3aGlsZSAodGhpcy50b3RhbFNpemUgPiB0aGlzLm1heFNpemUgJiYgdGhpcy5jYWNoZS5zaXplID4gMCkge1xuICAgICAgdGhpcy5ldmljdExlYXN0UmVjZW50bHlVc2VkKClcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGV2aWN0TGVhc3RSZWNlbnRseVVzZWQoKTogdm9pZCB7XG4gICAgY29uc3QgbHJ1S2V5ID0gdGhpcy5jYWNoZS5rZXlzKCkubmV4dCgpLnZhbHVlXG4gICAgaWYgKGxydUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBscnVTaXplID0gdGhpcy5zaXplcy5nZXQobHJ1S2V5KSB8fCAwXG4gICAgICB0aGlzLnRvdGFsU2l6ZSAtPSBscnVTaXplXG4gICAgICB0aGlzLmNhY2hlLmRlbGV0ZShscnVLZXkpXG4gICAgICB0aGlzLnNpemVzLmRlbGV0ZShscnVLZXkpXG4gICAgfVxuICB9XG5cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5jYWNoZS5jbGVhcigpXG4gICAgdGhpcy5zaXplcy5jbGVhcigpXG4gICAgdGhpcy50b3RhbFNpemUgPSAwXG4gIH1cblxuICBrZXlzKCkge1xuICAgIHJldHVybiBbLi4udGhpcy5jYWNoZS5rZXlzKCldXG4gIH1cblxuICByZW1vdmUoa2V5OiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5jYWNoZS5oYXMoa2V5KSkge1xuICAgICAgdGhpcy50b3RhbFNpemUgLT0gdGhpcy5zaXplcy5nZXQoa2V5KSB8fCAwXG4gICAgICB0aGlzLmNhY2hlLmRlbGV0ZShrZXkpXG4gICAgICB0aGlzLnNpemVzLmRlbGV0ZShrZXkpXG4gICAgfVxuICB9XG5cbiAgY2xlYXIoKTogdm9pZCB7XG4gICAgdGhpcy5jYWNoZS5jbGVhcigpXG4gICAgdGhpcy5zaXplcy5jbGVhcigpXG4gICAgdGhpcy50b3RhbFNpemUgPSAwXG4gIH1cblxuICBnZXQgc2l6ZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmNhY2hlLnNpemVcbiAgfVxuXG4gIGdldCBjdXJyZW50U2l6ZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnRvdGFsU2l6ZVxuICB9XG59XG4iXSwibmFtZXMiOlsiTFJVQ2FjaGUiLCJjb25zdHJ1Y3RvciIsIm1heFNpemUiLCJjYWxjdWxhdGVTaXplIiwiY2FjaGUiLCJNYXAiLCJzaXplcyIsInRvdGFsU2l6ZSIsInNldCIsImtleSIsInZhbHVlIiwic2l6ZSIsImNvbnNvbGUiLCJ3YXJuIiwiaGFzIiwiZ2V0IiwidG91Y2giLCJCb29sZWFuIiwidW5kZWZpbmVkIiwiZGVsZXRlIiwiZXZpY3RJZk5lY2Vzc2FyeSIsImV2aWN0TGVhc3RSZWNlbnRseVVzZWQiLCJscnVLZXkiLCJrZXlzIiwibmV4dCIsImxydVNpemUiLCJyZXNldCIsImNsZWFyIiwicmVtb3ZlIiwiY3VycmVudFNpemUiXSwibWFwcGluZ3MiOiI7OztBQUFPLE1BQU1BO0lBT1hD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Q3hCLElBQUksSUFBSSxDQUFDTCxLQUFLLENBQUNVLEdBQUcsQ0FBQ0wsTUFBTTtZQUN2QixJQUFJLENBQUNGLFNBQVMsSUFBSSxJQUFJLENBQUNELEtBQUssQ0FBQ1MsR0FBRyxDQUFDTixRQUFRO1lBQ3pDLElBQUksQ0FBQ0wsS0FBSyxDQUFDZSxNQUFNLENBQUNWO1lBQ2xCLElBQUksQ0FBQ0gsS0FBSyxDQUFDYSxNQUFNLENBQUNWO1FBQ3BCO0lBQ0Y7SUFFQWtCLFFBQWM7UUFDWixJQUFJLENBQUN2QixLQUFLLENBQUN1QixLQUFLO1FBQ2hCLElBQUksQ0FBQ3JCLEtBQUssQ0FBQ3FCLEtBQUs7UUFDaEIsSUFBSSxDQUFDcEIsU0FBUyxHQUFHO0lBQ25CO0lBRUEsSUFBSUksT0FBZTtRQUNqQixPQUFPLElBQUksQ0FBQ1AsS0FBSyxDQUFDTyxJQUFJO0lBQ3hCO0lBRUEsSUFBSWtCLGNBQXNCO1FBQ3hCLE9BQU8sSUFBSSxDQUFDdEIsU0FBUztJQUN2QjtBQUNGIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDM1MjksICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NyYy9idWlsZC9vdXRwdXQvbG9nLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGJvbGQsIGdyZWVuLCBtYWdlbnRhLCByZWQsIHllbGxvdywgd2hpdGUgfSBmcm9tICcuLi8uLi9saWIvcGljb2NvbG9ycydcbmltcG9ydCB7IExSVUNhY2hlIH0gZnJvbSAnLi4vLi4vc2VydmVyL2xpYi9scnUtY2FjaGUnXG5cbmV4cG9ydCBjb25zdCBwcmVmaXhlcyA9IHtcbiAgd2FpdDogd2hpdGUoYm9sZCgn4peLJykpLFxuICBlcnJvcjogcmVkKGJvbGQoJ+KorycpKSxcbiAgd2FybjogeWVsbG93KGJvbGQoJ+KaoCcpKSxcbiAgcmVhZHk6ICfilrInLCAvLyBubyBjb2xvclxuICBpbmZvOiB3aGl0ZShib2xkKCcgJykpLFxuICBldmVudDogZ3JlZW4oYm9sZCgn4pyTJykpLFxuICB0cmFjZTogbWFnZW50YShib2xkKCfCuycpKSxcbn0gYXMgY29uc3RcblxuY29uc3QgTE9HR0lOR19NRVRIT0QgPSB7XG4gIGxvZzogJ2xvZycsXG4gIHdhcm46ICd3YXJuJyxcbiAgZXJyb3I6ICdlcnJvcicsXG59IGFzIGNvbnN0XG5cbmZ1bmN0aW9uIHByZWZpeGVkTG9nKHByZWZpeFR5cGU6IGtleW9mIHR5cGVvZiBwcmVmaXhlcywgLi4ubWVzc2FnZTogYW55W10pIHtcbiAgaWYgKChtZXNzYWdlWzBdID09PSAnJyB8fCBtZXNzYWdlWzBdID09PSB1bmRlZmluZWQpICYmIG1lc3NhZ2UubGVuZ3RoID09PSAxKSB7XG4gICAgbWVzc2FnZS5zaGlmdCgpXG4gIH1cblxuICBjb25zdCBjb25zb2xlTWV0aG9kOiBrZXlvZiB0eXBlb2YgTE9HR0lOR19NRVRIT0QgPVxuICAgIHByZWZpeFR5cGUgaW4gTE9HR0lOR19NRVRIT0RcbiAgICAgID8gTE9HR0lOR19NRVRIT0RbcHJlZml4VHlwZSBhcyBrZXlvZiB0eXBlb2YgTE9HR0lOR19NRVRIT0RdXG4gICAgICA6ICdsb2cnXG5cbiAgY29uc3QgcHJlZml4ID0gcHJlZml4ZXNbcHJlZml4VHlwZV1cbiAgLy8gSWYgdGhlcmUncyBubyBtZXNzYWdlLCBkb24ndCBwcmludCB0aGUgcHJlZml4IGJ1dCBhIG5ldyBsaW5lXG4gIGlmIChtZXNzYWdlLmxlbmd0aCA9PT0gMCkge1xuICAgIGNvbnNvbGVbY29uc29sZU1ldGhvZF0oJycpXG4gIH0gZWxzZSB7XG4gICAgLy8gRW5zdXJlIGlmIHRoZXJlJ3MgQU5TSSBlc2NhcGUgY29kZXMgaXQncyBjb25jYXRlbmF0ZWQgaW50byBvbmUgc3RyaW5nLlxuICAgIC8vIENocm9tZSBEZXZUb29sIGNhbiBvbmx5IGhhbmRsZSBjb2xvciBpZiBpdCdzIGluIG9uZSBzdHJpbmcuXG4gICAgaWYgKG1lc3NhZ2UubGVuZ3RoID09PSAxICYmIHR5cGVvZiBtZXNzYWdlWzBdID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc29sZVtjb25zb2xlTWV0aG9kXSgnICcgKyBwcmVmaXggKyAnICcgKyBtZXNzYWdlWzBdKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlW2NvbnNvbGVNZXRob2RdKCcgJyArIHByZWZpeCwgLi4ubWVzc2FnZSlcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJvb3RzdHJhcCguLi5tZXNzYWdlOiBzdHJpbmdbXSkge1xuICAvLyBsb2dnaW5nIGZvcm1hdDogJyA8cHJlZml4PiA8bWVzc2FnZT4nXG4gIC8vIGUuZy4gJyDinJMgQ29tcGlsZWQgc3VjY2Vzc2Z1bGx5J1xuICAvLyBBZGQgc3BhY2VzIHRvIGFsaWduIHdpdGggdGhlIGluZGVudCBvZiBvdGhlciBsb2dzXG4gIGNvbnNvbGUubG9nKCcgICAnICsgbWVzc2FnZS5qb2luKCcgJykpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3YWl0KC4uLm1lc3NhZ2U6IGFueVtdKSB7XG4gIHByZWZpeGVkTG9nKCd3YWl0JywgLi4ubWVzc2FnZSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVycm9yKC4uLm1lc3NhZ2U6IGFueVtdKSB7XG4gIHByZWZpeGVkTG9nKCdlcnJvcicsIC4uLm1lc3NhZ2UpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3YXJuKC4uLm1lc3NhZ2U6IGFueVtdKSB7XG4gIHByZWZpeGVkTG9nKCd3YXJuJywgLi4ubWVzc2FnZSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlYWR5KC4uLm1lc3NhZ2U6IGFueVtdKSB7XG4gIHByZWZpeGVkTG9nKCdyZWFkeScsIC4uLm1lc3NhZ2UpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbmZvKC4uLm1lc3NhZ2U6IGFueVtdKSB7XG4gIHByZWZpeGVkTG9nKCdpbmZvJywgLi4ubWVzc2FnZSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV2ZW50KC4uLm1lc3NhZ2U6IGFueVtdKSB7XG4gIHByZWZpeGVkTG9nKCdldmVudCcsIC4uLm1lc3NhZ2UpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFjZSguLi5tZXNzYWdlOiBhbnlbXSkge1xuICBwcmVmaXhlZExvZygndHJhY2UnLCAuLi5tZXNzYWdlKVxufVxuXG5jb25zdCB3YXJuT25jZUNhY2hlID0gbmV3IExSVUNhY2hlPHN0cmluZz4oMTBfMDAwLCAodmFsdWUpID0+IHZhbHVlLmxlbmd0aClcbmV4cG9ydCBmdW5jdGlvbiB3YXJuT25jZSguLi5tZXNzYWdlOiBhbnlbXSkge1xuICBjb25zdCBrZXkgPSBtZXNzYWdlLmpvaW4oJyAnKVxuICBpZiAoIXdhcm5PbmNlQ2FjaGUuaGFzKGtleSkpIHtcbiAgICB3YXJuT25jZUNhY2hlLnNldChrZXksIGtleSlcbiAgICB3YXJuKC4uLm1lc3NhZ2UpXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJib2xkIiwiZ3JlZW4iLCJtYWdlbnRhIiwicmVkIiwieWVsbG93Iiwid2hpdGUiLCJMUlVDYWNoZSIsInByZWZpeGVzIiwid2FpdCIsImVycm9yIiwid2FybiIsInJlYWR5IiwiaW5mbyIsImV2ZW50IiwidHJhY2UiLCJMT0dHSU5HX01FVEhPRCIsImxvZyIsInByZWZpeGVkTG9nIiwicHJlZml4VHlwZSIsIm1lc3NhZ2UiLCJ1bmRlZmluZWQiLCJsZW5ndGgiLCJzaGlmdCIsImNvbnNvbGVNZXRob2QiLCJwcmVmaXgiLCJjb25zb2xlIiwiYm9vdHN0cmFwIiwiam9pbiIsIndhcm5PbmNlQ2FjaGUiLCJ2YWx1ZSIsIndhcm5PbmNlIiwia2V5IiwiaGFzIiwic2V0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQSxTQUFTQSxJQUFJLEVBQUVDLEtBQUssRUFBRUMsT0FBTyxFQUFFQyxHQUFHLEVBQUVDLE1BQU0sRUFBRUMsS0FBSyxRQUFRLHVCQUFzQjtBQUMvRSxTQUFTQyxRQUFRLFFBQVEsNkJBQTRCOzs7QUFFOUMsTUFBTUMsV0FBVztJQUN0QkMsbUtBQU1ILFFBQUFBLCtKQUFNTCxPQUFBQSxFQUFLO0lBQ2pCUyxvS0FBT04sTUFBQUEsTUFBSUgsZ0tBQUFBLEVBQUs7SUFDaEJVLG1LQUFNTixTQUFBQSwrSkFBT0osT0FBQUEsRUFBSztJQUNsQlcsT0FBTztJQUNQQyxNQUFNUCxxS0FBQUEsK0pBQU1MLE9BQUFBLEVBQUs7SUFDakJhLG9LQUFPWixRQUFBQSxHQUFNRCxtS0FBQUEsRUFBSztJQUNsQmMsb0tBQU9aLFVBQUFBLCtKQUFRRixPQUFBQSxFQUFLO0FBQ3RCLEVBQVU7QUFFVixNQUFNZSxpQkFBaUI7SUFDckJDLEtBQUs7SUFDTE4sTUFBTTtJQUNORCxPQUFPO0FBQ1Q7QUFFQSxTQUFTUSxZQUFZQyxVQUFpQyxFQUFFLEdBQUdDLE9BQWM7SUFDdkUsSUFBS0EsQ0FBQUEsT0FBTyxDQUFDLEVBQUUsS0FBSyxNQUFNQSxPQUFPLENBQUMsRUFBRSxLQUFLQyxTQUFRLEtBQU1ELFFBQVFFLE1BQU0sS0FBSyxHQUFHO1FBQzNFRixRQUFRRyxLQUFLO0lBQ2Y7SUFFQSxNQUFNQyxnQkFDSkwsY0FBY0gsaUJBQ1ZBLGNBQWMsQ0FBQ0csV0FBMEMsR0FDekQ7SUFFTixNQUFNTSxTQUFTakIsUUFBUSxDQUFDVyxXQUFXO0lBQ25DLCtEQUErRDtJQUMvRCxJQUFJQyxRQUFRRSxNQUFNLEtBQUssR0FBRztRQUN4QkksT0FBTyxDQUFDRixjQUFjLENBQUM7SUFDekIsT0FBTztRQUNMLHlFQUF5RTtRQUN6RSw4REFBOEQ7UUFDOUQsSUFBSUosUUFBUUUsTUFBTSxLQUFLLEtBQUssT0FBT0YsT0FBTyxDQUFDLEVBQUUsS0FBSyxVQUFVO1lBQzFETSxPQUFPLENBQUNGLGNBQWMsQ0FBQyxNQUFNQyxTQUFTLE1BQU1MLE9BQU8sQ0FBQyxFQUFFO1FBQ3hELE9BQU87WUFDTE0sT0FBTyxDQUFDRixjQUFjLENBQUMsTUFBTUMsV0FBV0w7UUFDMUM7SUFDRjtBQUNGO0FBRU8sU0FBU08sVUFBVSxHQUFHUCxPQUFpQjtJQUM1Qyx3Q0FBd0M7SUFDeEMsa0NBQWtDO0lBQ2xDLG9EQUFvRDtJQUNwRE0sUUFBUVQsR0FBRyxDQUFDLFFBQVFHLFFBQVFRLElBQUksQ0FBQztBQUNuQztBQUVPLFNBQVNuQixLQUFLLEdBQUdXLE9BQWM7SUFDcENGLFlBQVksV0FBV0U7QUFDekI7QUFFTyxTQUFTVixNQUFNLEdBQUdVLE9BQWM7SUFDckNGLFlBQVksWUFBWUU7QUFDMUI7QUFFTyxTQUFTVCxLQUFLLEdBQUdTLE9BQWM7SUFDcENGLFlBQVksV0FBV0U7QUFDekI7QUFFTyxTQUFTUixNQUFNLEdBQUdRLE9BQWM7SUFDckNGLFlBQVksWUFBWUU7QUFDMUI7QUFFTyxTQUFTUCxLQUFLLEdBQUdPLE9BQWM7SUFDcENGLFlBQVksV0FBV0U7QUFDekI7QUFFTyxTQUFTTixNQUFNLEdBQUdNLE9BQWM7SUFDckNGLFlBQVksWUFBWUU7QUFDMUI7QUFFTyxTQUFTTCxNQUFNLEdBQUdLLE9BQWM7SUFDckNGLFlBQVksWUFBWUU7QUFDMUI7QUFFQSxNQUFNUyxnQkFBZ0IseUtBQUl0QixXQUFBQSxDQUFpQixPQUFRLENBQUN1QixRQUFVQSxNQUFNUixNQUFNO0FBQ25FLFNBQVNTLFNBQVMsR0FBR1gsT0FBYztJQUN4QyxNQUFNWSxNQUFNWixRQUFRUSxJQUFJLENBQUM7SUFDekIsSUFBSSxDQUFDQyxjQUFjSSxHQUFHLENBQUNELE1BQU07UUFDM0JILGNBQWNLLEdBQUcsQ0FBQ0YsS0FBS0E7UUFDdkJyQixRQUFRUztJQUNWO0FBQ0YiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMzYxNywgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL2xpYi9tZXRhZGF0YS9yZXNvbHZlcnMvcmVzb2x2ZS1vcGVuZ3JhcGgudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBSZXNvbHZlZE1ldGFkYXRhIH0gZnJvbSAnLi4vdHlwZXMvbWV0YWRhdGEtaW50ZXJmYWNlJ1xuaW1wb3J0IHR5cGUge1xuICBPcGVuR3JhcGhUeXBlLFxuICBPcGVuR3JhcGgsXG4gIFJlc29sdmVkT3BlbkdyYXBoLFxufSBmcm9tICcuLi90eXBlcy9vcGVuZ3JhcGgtdHlwZXMnXG5pbXBvcnQgdHlwZSB7XG4gIEZpZWxkUmVzb2x2ZXJFeHRyYUFyZ3MsXG4gIEFzeW5jRmllbGRSZXNvbHZlckV4dHJhQXJncyxcbiAgTWV0YWRhdGFDb250ZXh0LFxufSBmcm9tICcuLi90eXBlcy9yZXNvbHZlcnMnXG5pbXBvcnQgdHlwZSB7IFJlc29sdmVkVHdpdHRlck1ldGFkYXRhLCBUd2l0dGVyIH0gZnJvbSAnLi4vdHlwZXMvdHdpdHRlci10eXBlcydcbmltcG9ydCB7IHJlc29sdmVBcnJheSwgcmVzb2x2ZUFzQXJyYXlPclVuZGVmaW5lZCB9IGZyb20gJy4uL2dlbmVyYXRlL3V0aWxzJ1xuaW1wb3J0IHtcbiAgZ2V0U29jaWFsSW1hZ2VNZXRhZGF0YUJhc2VGYWxsYmFjayxcbiAgaXNTdHJpbmdPclVSTCxcbiAgcmVzb2x2ZVVybCxcbiAgcmVzb2x2ZUFic29sdXRlVXJsV2l0aFBhdGhuYW1lLFxufSBmcm9tICcuL3Jlc29sdmUtdXJsJ1xuaW1wb3J0IHsgcmVzb2x2ZVRpdGxlIH0gZnJvbSAnLi9yZXNvbHZlLXRpdGxlJ1xuaW1wb3J0IHsgaXNGdWxsU3RyaW5nVXJsIH0gZnJvbSAnLi4vLi4vdXJsJ1xuaW1wb3J0IHsgd2Fybk9uY2UgfSBmcm9tICcuLi8uLi8uLi9idWlsZC9vdXRwdXQvbG9nJ1xuXG50eXBlIEZsYXR0ZW5BcnJheTxUPiA9IFQgZXh0ZW5kcyAoaW5mZXIgVSlbXSA/IFUgOiBUXG50eXBlIFJlc29sdmVkTWV0YWRhdGFCYXNlID0gUmVzb2x2ZWRNZXRhZGF0YVsnbWV0YWRhdGFCYXNlJ11cblxuY29uc3QgT2dUeXBlRmllbGRzID0ge1xuICBhcnRpY2xlOiBbJ2F1dGhvcnMnLCAndGFncyddLFxuICBzb25nOiBbJ2FsYnVtcycsICdtdXNpY2lhbnMnXSxcbiAgcGxheWxpc3Q6IFsnYWxidW1zJywgJ211c2ljaWFucyddLFxuICByYWRpbzogWydjcmVhdG9ycyddLFxuICB2aWRlbzogWydhY3RvcnMnLCAnZGlyZWN0b3JzJywgJ3dyaXRlcnMnLCAndGFncyddLFxuICBiYXNpYzogW1xuICAgICdlbWFpbHMnLFxuICAgICdwaG9uZU51bWJlcnMnLFxuICAgICdmYXhOdW1iZXJzJyxcbiAgICAnYWx0ZXJuYXRlTG9jYWxlJyxcbiAgICAnYXVkaW8nLFxuICAgICd2aWRlb3MnLFxuICBdLFxufSBhcyBjb25zdFxuXG5mdW5jdGlvbiByZXNvbHZlQW5kVmFsaWRhdGVJbWFnZShcbiAgaXRlbTogRmxhdHRlbkFycmF5PE9wZW5HcmFwaFsnaW1hZ2VzJ10gfCBUd2l0dGVyWydpbWFnZXMnXT4sXG4gIG1ldGFkYXRhQmFzZTogUmVzb2x2ZWRNZXRhZGF0YUJhc2UsXG4gIGlzU3RhdGljTWV0YWRhdGFSb3V0ZUZpbGU6IGJvb2xlYW4gfCB1bmRlZmluZWRcbikge1xuICBpZiAoIWl0ZW0pIHJldHVybiB1bmRlZmluZWRcbiAgY29uc3QgaXNJdGVtVXJsID0gaXNTdHJpbmdPclVSTChpdGVtKVxuICBjb25zdCBpbnB1dFVybCA9IGlzSXRlbVVybCA/IGl0ZW0gOiBpdGVtLnVybFxuICBpZiAoIWlucHV0VXJsKSByZXR1cm4gdW5kZWZpbmVkXG5cbiAgLy8gcHJvY2Vzcy5lbnYuVkVSQ0VMIGlzIHNldCB0byBcIjFcIiB3aGVuIFN5c3RlbSBFbnZpcm9ubWVudCBWYXJpYWJsZXMgYXJlXG4gIC8vIGV4cG9zZWQuIFdoZW4gZXhwb3NlZCwgdmFsaWRhdGlvbiBpcyBub3QgbmVjZXNzYXJ5IHNpbmNlIHdlIGFyZSBmYWxsaW5nIGJhY2sgdG9cbiAgLy8gcHJvY2Vzcy5lbnYuVkVSQ0VMX1BST0pFQ1RfUFJPRFVDVElPTl9VUkwsIHByb2Nlc3MuZW52LlZFUkNFTF9CUkFOQ0hfVVJMLCBvclxuICAvLyBwcm9jZXNzLmVudi5WRVJDRUxfVVJMIGZvciB0aGUgYG1ldGFkYXRhQmFzZWAuIHByb2Nlc3MuZW52LlZFUkNFTCBpcyB1bmRlZmluZWRcbiAgLy8gd2hlbiBTeXN0ZW0gRW52aXJvbm1lbnQgVmFyaWFibGVzIGFyZSBub3QgZXhwb3NlZC4gV2hlbiBub3QgZXhwb3NlZCwgd2UgY2Fubm90XG4gIC8vIGRldGVjdCBpbiB0aGUgYnVpbGQgZW52aXJvbm1lbnQgaWYgdGhlIGRlcGxveW1lbnQgaXMgYSBWZXJjZWwgZGVwbG95bWVudCBvciBub3QuXG4gIC8vXG4gIC8vIHgtcmVmOiBodHRwczovL3ZlcmNlbC5jb20vZG9jcy9wcm9qZWN0cy9lbnZpcm9ubWVudC12YXJpYWJsZXMvc3lzdGVtLWVudmlyb25tZW50LXZhcmlhYmxlcyNzeXN0ZW0tZW52aXJvbm1lbnQtdmFyaWFibGVzXG4gIGNvbnN0IGlzVXNpbmdWZXJjZWxTeXN0ZW1FbnZpcm9ubWVudFZhcmlhYmxlcyA9IEJvb2xlYW4ocHJvY2Vzcy5lbnYuVkVSQ0VMKVxuXG4gIGNvbnN0IGlzUmVsYXRpdmVVcmwgPVxuICAgIHR5cGVvZiBpbnB1dFVybCA9PT0gJ3N0cmluZycgJiYgIWlzRnVsbFN0cmluZ1VybChpbnB1dFVybClcblxuICAvLyBXaGVuIG5vIGV4cGxpY2l0IG1ldGFkYXRhQmFzZSBpcyBzcGVjaWZpZWQgYnkgdGhlIHVzZXIsIHdlJ2xsIG92ZXJyaWRlIGl0IHdpdGggdGhlIGZhbGxiYWNrIG1ldGFkYXRhXG4gIC8vIHVuZGVyIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgLy8gLSBUaGUgcHJvdmlkZWQgVVJMIGlzIHJlbGF0aXZlIChpZSAuL29nLWltYWdlKS5cbiAgLy8gLSBUaGUgaW1hZ2UgaXMgc3RhdGljYWxseSBnZW5lcmF0ZWQgYnkgTmV4dC5qcyAoc3VjaCBhcyB0aGUgc3BlY2lhbCBgb3BlbmdyYXBoLWltYWdlYCByb3V0ZSlcbiAgLy8gSW4gYm90aCBjYXNlcywgd2Ugd2FudCB0byBlbnN1cmUgdGhhdCBhY3Jvc3MgYWxsIGVudmlyb25tZW50cywgdGhlIG9nSW1hZ2UgaXMgYSBmdWxseSBxdWFsaWZpZWQgVVJMLlxuICAvLyBJbiB0aGUgYG9wZW5ncmFwaC1pbWFnZWAgY2FzZSwgc2luY2UgdGhlIHVzZXIgaXNuJ3QgZXhwbGljaXRseSBwYXNzaW5nIGEgcmVsYXRpdmUgcGF0aCwgdGhpcyBlbnN1cmVzXG4gIC8vIHRoZSBvZ0ltYWdlIHdpbGwgYmUgcHJvcGVybHkgZGlzY292ZXJlZCBhY3Jvc3MgZGlmZmVyZW50IGVudmlyb25tZW50cyB3aXRob3V0IHRoZSB1c2VyIG5lZWRpbmcgdG9cbiAgLy8gaGF2ZSBhIGJ1bmNoIG9mIGBwcm9jZXNzLmVudmAgY2hlY2tzIHdoZW4gZGVmaW5pbmcgdGhlaXIgYG1ldGFkYXRhQmFzZWAuXG4gIGlmIChpc1JlbGF0aXZlVXJsICYmICghbWV0YWRhdGFCYXNlIHx8IGlzU3RhdGljTWV0YWRhdGFSb3V0ZUZpbGUpKSB7XG4gICAgY29uc3QgZmFsbGJhY2tNZXRhZGF0YUJhc2UgPVxuICAgICAgZ2V0U29jaWFsSW1hZ2VNZXRhZGF0YUJhc2VGYWxsYmFjayhtZXRhZGF0YUJhc2UpXG5cbiAgICAvLyBXaGVuIG5vdCB1c2luZyBWZXJjZWwgZW52aXJvbm1lbnQgdmFyaWFibGVzIGZvciBVUkwgaW5qZWN0aW9uLCB3ZSBhcmVuJ3QgYWJsZSB0byBkZXRlcm1pbmVcbiAgICAvLyBhIGZhbGxiYWNrIHZhbHVlIGZvciBgbWV0YWRhdGFCYXNlYC4gRm9yIHNlbGYtaG9zdGVkIHNldHVwcywgd2Ugd2FudCB0byB3YXJuXG4gICAgLy8gYWJvdXQgdGhpcyBzaW5jZSB0aGUgb25seSBmYWxsYmFjayB3ZSdsbCBiZSBhYmxlIHRvIGdlbmVyYXRlIGlzIGBsb2NhbGhvc3RgLlxuICAgIC8vIEluIGRldmVsb3BtZW50LCB3ZSdsbCBvbmx5IHdhcm4gZm9yIHJlbGF0aXZlIG1ldGFkYXRhIHRoYXQgaXNuJ3QgcGFydCBvZiB0aGUgc3RhdGljXG4gICAgLy8gbWV0YWRhdGEgY29udmVudGlvbnMgKGVnIGBvcGVuZ3JhcGgtaW1hZ2VgKSwgYXMgb3RoZXJ3aXNlIGl0J3MgY3VycmVudGx5IHZlcnkgbm9pc3lcbiAgICAvLyBmb3IgY29tbW9uIGNhc2VzLiBFdmVudHVhbGx5IHdlIHNob3VsZCByZW1vdmUgdGhpcyB3YXJuaW5nIGFsbCB0b2dldGhlciBpbiBmYXZvciBvZlxuICAgIC8vIGRldnRvb2xzLlxuICAgIGNvbnN0IHNob3VsZFdhcm4gPVxuICAgICAgIWlzVXNpbmdWZXJjZWxTeXN0ZW1FbnZpcm9ubWVudFZhcmlhYmxlcyAmJlxuICAgICAgIW1ldGFkYXRhQmFzZSAmJlxuICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicgfHwgIWlzU3RhdGljTWV0YWRhdGFSb3V0ZUZpbGUpXG5cbiAgICBpZiAoc2hvdWxkV2Fybikge1xuICAgICAgd2Fybk9uY2UoXG4gICAgICAgIGBtZXRhZGF0YUJhc2UgcHJvcGVydHkgaW4gbWV0YWRhdGEgZXhwb3J0IGlzIG5vdCBzZXQgZm9yIHJlc29sdmluZyBzb2NpYWwgb3BlbiBncmFwaCBvciB0d2l0dGVyIGltYWdlcywgdXNpbmcgXCIke2ZhbGxiYWNrTWV0YWRhdGFCYXNlLm9yaWdpbn1cIi4gU2VlIGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9hcGktcmVmZXJlbmNlL2Z1bmN0aW9ucy9nZW5lcmF0ZS1tZXRhZGF0YSNtZXRhZGF0YWJhc2VgXG4gICAgICApXG4gICAgfVxuXG4gICAgbWV0YWRhdGFCYXNlID0gZmFsbGJhY2tNZXRhZGF0YUJhc2VcbiAgfVxuXG4gIHJldHVybiBpc0l0ZW1VcmxcbiAgICA/IHtcbiAgICAgICAgdXJsOiByZXNvbHZlVXJsKGlucHV0VXJsLCBtZXRhZGF0YUJhc2UpLFxuICAgICAgfVxuICAgIDoge1xuICAgICAgICAuLi5pdGVtLFxuICAgICAgICAvLyBVcGRhdGUgaW1hZ2UgZGVzY3JpcHRvciB1cmxcbiAgICAgICAgdXJsOiByZXNvbHZlVXJsKGlucHV0VXJsLCBtZXRhZGF0YUJhc2UpLFxuICAgICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZUltYWdlcyhcbiAgaW1hZ2VzOiBUd2l0dGVyWydpbWFnZXMnXSxcbiAgbWV0YWRhdGFCYXNlOiBSZXNvbHZlZE1ldGFkYXRhQmFzZSxcbiAgaXNTdGF0aWNNZXRhZGF0YVJvdXRlRmlsZTogYm9vbGVhblxuKTogTm9uTnVsbGFibGU8UmVzb2x2ZWRNZXRhZGF0YVsndHdpdHRlciddPlsnaW1hZ2VzJ11cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlSW1hZ2VzKFxuICBpbWFnZXM6IE9wZW5HcmFwaFsnaW1hZ2VzJ10sXG4gIG1ldGFkYXRhQmFzZTogUmVzb2x2ZWRNZXRhZGF0YUJhc2UsXG4gIGlzU3RhdGljTWV0YWRhdGFSb3V0ZUZpbGU6IGJvb2xlYW5cbik6IE5vbk51bGxhYmxlPFJlc29sdmVkTWV0YWRhdGFbJ29wZW5HcmFwaCddPlsnaW1hZ2VzJ11cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlSW1hZ2VzKFxuICBpbWFnZXM6IE9wZW5HcmFwaFsnaW1hZ2VzJ10gfCBUd2l0dGVyWydpbWFnZXMnXSxcbiAgbWV0YWRhdGFCYXNlOiBSZXNvbHZlZE1ldGFkYXRhQmFzZSxcbiAgaXNTdGF0aWNNZXRhZGF0YVJvdXRlRmlsZTogYm9vbGVhblxuKTpcbiAgfCBOb25OdWxsYWJsZTxSZXNvbHZlZE1ldGFkYXRhWyd0d2l0dGVyJ10+WydpbWFnZXMnXVxuICB8IE5vbk51bGxhYmxlPFJlc29sdmVkTWV0YWRhdGFbJ29wZW5HcmFwaCddPlsnaW1hZ2VzJ10ge1xuICBjb25zdCByZXNvbHZlZEltYWdlcyA9IHJlc29sdmVBc0FycmF5T3JVbmRlZmluZWQoaW1hZ2VzKVxuICBpZiAoIXJlc29sdmVkSW1hZ2VzKSByZXR1cm4gcmVzb2x2ZWRJbWFnZXNcblxuICBjb25zdCBub25OdWxsYWJsZUltYWdlcyA9IFtdXG4gIGZvciAoY29uc3QgaXRlbSBvZiByZXNvbHZlZEltYWdlcykge1xuICAgIGNvbnN0IHJlc29sdmVkSXRlbSA9IHJlc29sdmVBbmRWYWxpZGF0ZUltYWdlKFxuICAgICAgaXRlbSxcbiAgICAgIG1ldGFkYXRhQmFzZSxcbiAgICAgIGlzU3RhdGljTWV0YWRhdGFSb3V0ZUZpbGVcbiAgICApXG4gICAgaWYgKCFyZXNvbHZlZEl0ZW0pIGNvbnRpbnVlXG5cbiAgICBub25OdWxsYWJsZUltYWdlcy5wdXNoKHJlc29sdmVkSXRlbSlcbiAgfVxuXG4gIHJldHVybiBub25OdWxsYWJsZUltYWdlc1xufVxuXG5jb25zdCBvZ1R5cGVUb0ZpZWxkczogUmVjb3JkPHN0cmluZywgcmVhZG9ubHkgc3RyaW5nW10+ID0ge1xuICBhcnRpY2xlOiBPZ1R5cGVGaWVsZHMuYXJ0aWNsZSxcbiAgYm9vazogT2dUeXBlRmllbGRzLmFydGljbGUsXG4gICdtdXNpYy5zb25nJzogT2dUeXBlRmllbGRzLnNvbmcsXG4gICdtdXNpYy5hbGJ1bSc6IE9nVHlwZUZpZWxkcy5zb25nLFxuICAnbXVzaWMucGxheWxpc3QnOiBPZ1R5cGVGaWVsZHMucGxheWxpc3QsXG4gICdtdXNpYy5yYWRpb19zdGF0aW9uJzogT2dUeXBlRmllbGRzLnJhZGlvLFxuICAndmlkZW8ubW92aWUnOiBPZ1R5cGVGaWVsZHMudmlkZW8sXG4gICd2aWRlby5lcGlzb2RlJzogT2dUeXBlRmllbGRzLnZpZGVvLFxufVxuXG5mdW5jdGlvbiBnZXRGaWVsZHNCeU9nVHlwZShvZ1R5cGU6IE9wZW5HcmFwaFR5cGUgfCB1bmRlZmluZWQpIHtcbiAgaWYgKCFvZ1R5cGUgfHwgIShvZ1R5cGUgaW4gb2dUeXBlVG9GaWVsZHMpKSByZXR1cm4gT2dUeXBlRmllbGRzLmJhc2ljXG4gIHJldHVybiBvZ1R5cGVUb0ZpZWxkc1tvZ1R5cGVdLmNvbmNhdChPZ1R5cGVGaWVsZHMuYmFzaWMpXG59XG5cbmV4cG9ydCBjb25zdCByZXNvbHZlT3BlbkdyYXBoOiBBc3luY0ZpZWxkUmVzb2x2ZXJFeHRyYUFyZ3M8XG4gICdvcGVuR3JhcGgnLFxuICBbUmVzb2x2ZWRNZXRhZGF0YUJhc2UsIFByb21pc2U8c3RyaW5nPiwgTWV0YWRhdGFDb250ZXh0LCBzdHJpbmcgfCBudWxsXVxuPiA9IGFzeW5jIChcbiAgb3BlbkdyYXBoLFxuICBtZXRhZGF0YUJhc2UsXG4gIHBhdGhuYW1lLFxuICBtZXRhZGF0YUNvbnRleHQsXG4gIHRpdGxlVGVtcGxhdGVcbikgPT4ge1xuICBpZiAoIW9wZW5HcmFwaCkgcmV0dXJuIG51bGxcblxuICBmdW5jdGlvbiByZXNvbHZlUHJvcHModGFyZ2V0OiBSZXNvbHZlZE9wZW5HcmFwaCwgb2c6IE9wZW5HcmFwaCkge1xuICAgIGNvbnN0IG9nVHlwZSA9IG9nICYmICd0eXBlJyBpbiBvZyA/IG9nLnR5cGUgOiB1bmRlZmluZWRcbiAgICBjb25zdCBrZXlzID0gZ2V0RmllbGRzQnlPZ1R5cGUob2dUeXBlKVxuICAgIGZvciAoY29uc3QgayBvZiBrZXlzKSB7XG4gICAgICBjb25zdCBrZXkgPSBrIGFzIGtleW9mIFJlc29sdmVkT3BlbkdyYXBoXG4gICAgICBpZiAoa2V5IGluIG9nICYmIGtleSAhPT0gJ3VybCcpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBvZ1trZXldXG4gICAgICAgIC8vIFRPRE86IGltcHJvdmUgdHlwaW5nIGluZmVycmluZ1xuICAgICAgICA7KHRhcmdldCBhcyBhbnkpW2tleV0gPSB2YWx1ZSA/IHJlc29sdmVBcnJheSh2YWx1ZSkgOiBudWxsXG4gICAgICB9XG4gICAgfVxuICAgIHRhcmdldC5pbWFnZXMgPSByZXNvbHZlSW1hZ2VzKFxuICAgICAgb2cuaW1hZ2VzLFxuICAgICAgbWV0YWRhdGFCYXNlLFxuICAgICAgbWV0YWRhdGFDb250ZXh0LmlzU3RhdGljTWV0YWRhdGFSb3V0ZUZpbGVcbiAgICApXG4gIH1cblxuICBjb25zdCByZXNvbHZlZCA9IHtcbiAgICAuLi5vcGVuR3JhcGgsXG4gICAgdGl0bGU6IHJlc29sdmVUaXRsZShvcGVuR3JhcGgudGl0bGUsIHRpdGxlVGVtcGxhdGUpLFxuICB9IGFzIFJlc29sdmVkT3BlbkdyYXBoXG4gIHJlc29sdmVQcm9wcyhyZXNvbHZlZCwgb3BlbkdyYXBoKVxuXG4gIHJlc29sdmVkLnVybCA9IG9wZW5HcmFwaC51cmxcbiAgICA/IHJlc29sdmVBYnNvbHV0ZVVybFdpdGhQYXRobmFtZShcbiAgICAgICAgb3BlbkdyYXBoLnVybCxcbiAgICAgICAgbWV0YWRhdGFCYXNlLFxuICAgICAgICBhd2FpdCBwYXRobmFtZSxcbiAgICAgICAgbWV0YWRhdGFDb250ZXh0XG4gICAgICApXG4gICAgOiBudWxsXG5cbiAgcmV0dXJuIHJlc29sdmVkXG59XG5cbmNvbnN0IFR3aXR0ZXJCYXNpY0luZm9LZXlzID0gW1xuICAnc2l0ZScsXG4gICdzaXRlSWQnLFxuICAnY3JlYXRvcicsXG4gICdjcmVhdG9ySWQnLFxuICAnZGVzY3JpcHRpb24nLFxuXSBhcyBjb25zdFxuXG5leHBvcnQgY29uc3QgcmVzb2x2ZVR3aXR0ZXI6IEZpZWxkUmVzb2x2ZXJFeHRyYUFyZ3M8XG4gICd0d2l0dGVyJyxcbiAgW1Jlc29sdmVkTWV0YWRhdGFCYXNlLCBNZXRhZGF0YUNvbnRleHQsIHN0cmluZyB8IG51bGxdXG4+ID0gKHR3aXR0ZXIsIG1ldGFkYXRhQmFzZSwgbWV0YWRhdGFDb250ZXh0LCB0aXRsZVRlbXBsYXRlKSA9PiB7XG4gIGlmICghdHdpdHRlcikgcmV0dXJuIG51bGxcbiAgbGV0IGNhcmQgPSAnY2FyZCcgaW4gdHdpdHRlciA/IHR3aXR0ZXIuY2FyZCA6IHVuZGVmaW5lZFxuICBjb25zdCByZXNvbHZlZCA9IHtcbiAgICAuLi50d2l0dGVyLFxuICAgIHRpdGxlOiByZXNvbHZlVGl0bGUodHdpdHRlci50aXRsZSwgdGl0bGVUZW1wbGF0ZSksXG4gIH0gYXMgUmVzb2x2ZWRUd2l0dGVyTWV0YWRhdGFcbiAgZm9yIChjb25zdCBpbmZvS2V5IG9mIFR3aXR0ZXJCYXNpY0luZm9LZXlzKSB7XG4gICAgcmVzb2x2ZWRbaW5mb0tleV0gPSB0d2l0dGVyW2luZm9LZXldIHx8IG51bGxcbiAgfVxuXG4gIHJlc29sdmVkLmltYWdlcyA9IHJlc29sdmVJbWFnZXMoXG4gICAgdHdpdHRlci5pbWFnZXMsXG4gICAgbWV0YWRhdGFCYXNlLFxuICAgIG1ldGFkYXRhQ29udGV4dC5pc1N0YXRpY01ldGFkYXRhUm91dGVGaWxlXG4gIClcblxuICBjYXJkID0gY2FyZCB8fCAocmVzb2x2ZWQuaW1hZ2VzPy5sZW5ndGggPyAnc3VtbWFyeV9sYXJnZV9pbWFnZScgOiAnc3VtbWFyeScpXG4gIHJlc29sdmVkLmNhcmQgPSBjYXJkXG5cbiAgaWYgKCdjYXJkJyBpbiByZXNvbHZlZCkge1xuICAgIHN3aXRjaCAocmVzb2x2ZWQuY2FyZCkge1xuICAgICAgY2FzZSAncGxheWVyJzoge1xuICAgICAgICByZXNvbHZlZC5wbGF5ZXJzID0gcmVzb2x2ZUFzQXJyYXlPclVuZGVmaW5lZChyZXNvbHZlZC5wbGF5ZXJzKSB8fCBbXVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgY2FzZSAnYXBwJzoge1xuICAgICAgICByZXNvbHZlZC5hcHAgPSByZXNvbHZlZC5hcHAgfHwge31cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc29sdmVkXG59XG4iXSwibmFtZXMiOlsicmVzb2x2ZUFycmF5IiwicmVzb2x2ZUFzQXJyYXlPclVuZGVmaW5lZCIsImdldFNvY2lhbEltYWdlTWV0YWRhdGFCYXNlRmFsbGJhY2siLCJpc1N0cmluZ09yVVJMIiwicmVzb2x2ZVVybCIsInJlc29sdmVBYnNvbHV0ZVVybFdpdGhQYXRobmFtZSIsInJlc29sdmVUaXRsZSIsImlzRnVsbFN0cmluZ1VybCIsIndhcm5PbmNlIiwiT2dUeXBlRmllbGRzIiwiYXJ0aWNsZSIsInNvbmciLCJwbGF5bGlzdCIsInJhZGlvIiwidmlkZW8iLCJiYXNpYyIsInJlc29sdmVBbmRWYWxpZGF0ZUltYWdlIiwiaXRlbSIsIm1ldGFkYXRhQmFzZSIsImlzU3RhdGljTWV0YWRhdGFSb3V0ZUZpbGUiLCJ1bmRlZmluZWQiLCJpc0l0ZW1VcmwiLCJpbnB1dFVybCIsInVybCIsImlzVXNpbmdWZXJjZWxTeXN0ZW1FbnZpcm9ubWVudFZhcmlhYmxlcyIsIkJvb2xlYW4iLCJwcm9jZXNzIiwiZW52IiwiVkVSQ0VMIiwiaXNSZWxhdGl2ZVVybCIsImZhbGxiYWNrTWV0YWRhdGFCYXNlIiwic2hvdWxkV2FybiIsIk5PREVfRU5WIiwib3JpZ2luIiwicmVzb2x2ZUltYWdlcyIsImltYWdlcyIsInJlc29sdmVkSW1hZ2VzIiwibm9uTnVsbGFibGVJbWFnZXMiLCJyZXNvbHZlZEl0ZW0iLCJwdXNoIiwib2dUeXBlVG9GaWVsZHMiLCJib29rIiwiZ2V0RmllbGRzQnlPZ1R5cGUiLCJvZ1R5cGUiLCJjb25jYXQiLCJyZXNvbHZlT3BlbkdyYXBoIiwib3BlbkdyYXBoIiwicGF0aG5hbWUiLCJtZXRhZGF0YUNvbnRleHQiLCJ0aXRsZVRlbXBsYXRlIiwicmVzb2x2ZVByb3BzIiwidGFyZ2V0Iiwib2ciLCJ0eXBlIiwia2V5cyIsImsiLCJrZXkiLCJ2YWx1ZSIsInJlc29sdmVkIiwidGl0bGUiLCJUd2l0dGVyQmFzaWNJbmZvS2V5cyIsInJlc29sdmVUd2l0dGVyIiwidHdpdHRlciIsImNhcmQiLCJpbmZvS2V5IiwibGVuZ3RoIiwicGxheWVycyIsImFwcCJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFZQSxTQUFTQSxZQUFZLEVBQUVDLHlCQUF5QixRQUFRLG9CQUFtQjtBQUMzRSxTQUNFQyxrQ0FBa0MsRUFDbENDLGFBQWEsRUFDYkMsVUFBVSxFQUNWQyw4QkFBOEIsUUFDekIsZ0JBQWU7QUFDdEIsU0FBU0MsWUFBWSxRQUFRLGtCQUFpQjtBQUM5QyxTQUFTQyxlQUFlLFFBQVEsWUFBVztBQUMzQyxTQUFTQyxRQUFRLFFBQVEsNEJBQTJCOzs7Ozs7QUFLcEQsTUFBTUMsZUFBZTtJQUNuQkMsU0FBUztRQUFDO1FBQVc7S0FBTztJQUM1QkMsTUFBTTtRQUFDO1FBQVU7S0FBWTtJQUM3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RUFBYXdELFFBQVFILEtBQUssRUFBRVY7SUFDckM7SUFDQSxLQUFLLE1BQU1lLFdBQVdKLHFCQUFzQjtRQUMxQ0YsUUFBUSxDQUFDTSxRQUFRLEdBQUdGLE9BQU8sQ0FBQ0UsUUFBUSxJQUFJO0lBQzFDO0lBRUFOLFNBQVN2QixNQUFNLEdBQUdELGNBQ2hCNEIsUUFBUTNCLE1BQU0sRUFDZGpCLGNBQ0E4QixnQkFBZ0I3Qix5QkFBeUI7SUFHM0M0QyxPQUFPQSxRQUFTTCxDQUFBQSxDQUFBQSxDQUFBQSxtQkFBQUEsU0FBU3ZCLE1BQU0sS0FBQSxPQUFBLEtBQUEsSUFBZnVCLGlCQUFpQk8sTUFBTSxJQUFHLHdCQUF3QixTQUFRO0lBQzFFUCxTQUFTSyxJQUFJLEdBQUdBO0lBRWhCLElBQUksVUFBVUwsVUFBVTtRQUN0QixPQUFRQSxTQUFTSyxJQUFJO1lBQ25CLEtBQUs7Z0JBQVU7b0JBQ2JMLFNBQVNRLE9BQU8sbUxBQUdqRSw0QkFBQUEsRUFBMEJ5RCxTQUFTUSxPQUFPLEtBQUssRUFBRTtvQkFDcEU7Z0JBQ0Y7WUFDQSxLQUFLO2dCQUFPO29CQUNWUixTQUFTUyxHQUFHLEdBQUdULFNBQVNTLEdBQUcsSUFBSSxDQUFDO29CQUNoQztnQkFDRjtZQUNBO2dCQUNFO1FBQ0o7SUFDRjtJQUVBLE9BQU9UO0FBQ1QsRUFBQyIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAzNzk5LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zcmMvc2hhcmVkL2xpYi9zZWdtZW50LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgU2VnbWVudCB9IGZyb20gJy4uLy4uL3NlcnZlci9hcHAtcmVuZGVyL3R5cGVzJ1xuXG5leHBvcnQgZnVuY3Rpb24gaXNHcm91cFNlZ21lbnQoc2VnbWVudDogc3RyaW5nKSB7XG4gIC8vIFVzZSBhcnJheVswXSBmb3IgcGVyZm9ybWFudCBwdXJwb3NlXG4gIHJldHVybiBzZWdtZW50WzBdID09PSAnKCcgJiYgc2VnbWVudC5lbmRzV2l0aCgnKScpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1BhcmFsbGVsUm91dGVTZWdtZW50KHNlZ21lbnQ6IHN0cmluZykge1xuICByZXR1cm4gc2VnbWVudC5zdGFydHNXaXRoKCdAJykgJiYgc2VnbWVudCAhPT0gJ0BjaGlsZHJlbidcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZFNlYXJjaFBhcmFtc0lmUGFnZVNlZ21lbnQoXG4gIHNlZ21lbnQ6IFNlZ21lbnQsXG4gIHNlYXJjaFBhcmFtczogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgc3RyaW5nW10gfCB1bmRlZmluZWQ+XG4pIHtcbiAgY29uc3QgaXNQYWdlU2VnbWVudCA9IHNlZ21lbnQuaW5jbHVkZXMoUEFHRV9TRUdNRU5UX0tFWSlcblxuICBpZiAoaXNQYWdlU2VnbWVudCkge1xuICAgIGNvbnN0IHN0cmluZ2lmaWVkUXVlcnkgPSBKU09OLnN0cmluZ2lmeShzZWFyY2hQYXJhbXMpXG4gICAgcmV0dXJuIHN0cmluZ2lmaWVkUXVlcnkgIT09ICd7fSdcbiAgICAgID8gUEFHRV9TRUdNRU5UX0tFWSArICc/JyArIHN0cmluZ2lmaWVkUXVlcnlcbiAgICAgIDogUEFHRV9TRUdNRU5UX0tFWVxuICB9XG5cbiAgcmV0dXJuIHNlZ21lbnRcbn1cblxuZXhwb3J0IGNvbnN0IFBBR0VfU0VHTUVOVF9LRVkgPSAnX19QQUdFX18nXG5leHBvcnQgY29uc3QgREVGQVVMVF9TRUdNRU5UX0tFWSA9ICdfX0RFRkFVTFRfXydcbiJdLCJuYW1lcyI6WyJpc0dyb3VwU2VnbWVudCIsInNlZ21lbnQiLCJlbmRzV2l0aCIsImlzUGFyYWxsZWxSb3V0ZVNlZ21lbnQiLCJzdGFydHNXaXRoIiwiYWRkU2VhcmNoUGFyYW1zSWZQYWdlU2VnbWVudCIsInNlYXJjaFBhcmFtcyIsImlzUGFnZVNlZ21lbnQiLCJpbmNsdWRlcyIsIlBBR0VfU0VHTUVOVF9LRVkiLCJzdHJpbmdpZmllZFF1ZXJ5IiwiSlNPTiIsInN0cmluZ2lmeSIsIkRFRkFVTFRfU0VHTUVOVF9LRVkiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFFTyxTQUFTQSxlQUFlQyxPQUFlO0lBQzVDLHNDQUFzQztJQUN0QyxPQUFPQSxPQUFPLENBQUMsRUFBRSxLQUFLLE9BQU9BLFFBQVFDLFFBQVEsQ0FBQztBQUNoRDtBQUVPLFNBQVNDLHVCQUF1QkYsT0FBZTtJQUNwRCxPQUFPQSxRQUFRRyxVQUFVLENBQUMsUUFBUUgsWUFBWTtBQUNoRDtBQUVPLFNBQVNJLDZCQUNkSixPQUFnQixFQUNoQkssWUFBMkQ7SUFFM0QsTUFBTUMsZ0JBQWdCTixRQUFRTyxRQUFRLENBQUNDO0lBRXZDLElBQUlGLGVBQWU7UUFDakIsTUFBTUcsbUJBQW1CQyxLQUFLQyxTQUFTLENBQUNOO1FBQ3hDLE9BQU9JLHFCQUFxQixPQUN4QkQsbUJBQW1CLE1BQU1DLG1CQUN6QkQ7SUFDTjtJQUVBLE9BQU9SO0FBQ1Q7QUFFTyxNQUFNUSxtQkFBbUIsV0FBVTtBQUNuQyxNQUFNSSxzQkFBc0IsY0FBYSIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAzODI3LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zcmMvc2VydmVyL2xpYi9hcHAtZGlyLW1vZHVsZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IEFwcERpck1vZHVsZXMgfSBmcm9tICcuLi8uLi9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1hcHAtbG9hZGVyJ1xuaW1wb3J0IHsgREVGQVVMVF9TRUdNRU5UX0tFWSB9IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvc2VnbWVudCdcblxuLyoqXG4gKiBMb2FkZXJUcmVlIGlzIGdlbmVyYXRlZCBpbiBuZXh0LWFwcC1sb2FkZXIuXG4gKi9cbmV4cG9ydCB0eXBlIExvYWRlclRyZWUgPSBbXG4gIHNlZ21lbnQ6IHN0cmluZyxcbiAgcGFyYWxsZWxSb3V0ZXM6IHsgW3BhcmFsbGVsUm91dGVyS2V5OiBzdHJpbmddOiBMb2FkZXJUcmVlIH0sXG4gIG1vZHVsZXM6IEFwcERpck1vZHVsZXMsXG5dXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRMYXlvdXRPclBhZ2VNb2R1bGUobG9hZGVyVHJlZTogTG9hZGVyVHJlZSkge1xuICBjb25zdCB7IGxheW91dCwgcGFnZSwgZGVmYXVsdFBhZ2UgfSA9IGxvYWRlclRyZWVbMl1cbiAgY29uc3QgaXNMYXlvdXQgPSB0eXBlb2YgbGF5b3V0ICE9PSAndW5kZWZpbmVkJ1xuICBjb25zdCBpc1BhZ2UgPSB0eXBlb2YgcGFnZSAhPT0gJ3VuZGVmaW5lZCdcbiAgY29uc3QgaXNEZWZhdWx0UGFnZSA9XG4gICAgdHlwZW9mIGRlZmF1bHRQYWdlICE9PSAndW5kZWZpbmVkJyAmJiBsb2FkZXJUcmVlWzBdID09PSBERUZBVUxUX1NFR01FTlRfS0VZXG5cbiAgbGV0IG1vZCA9IHVuZGVmaW5lZFxuICBsZXQgbW9kVHlwZTogJ2xheW91dCcgfCAncGFnZScgfCB1bmRlZmluZWQgPSB1bmRlZmluZWRcbiAgbGV0IGZpbGVQYXRoID0gdW5kZWZpbmVkXG5cbiAgaWYgKGlzTGF5b3V0KSB7XG4gICAgbW9kID0gYXdhaXQgbGF5b3V0WzBdKClcbiAgICBtb2RUeXBlID0gJ2xheW91dCdcbiAgICBmaWxlUGF0aCA9IGxheW91dFsxXVxuICB9IGVsc2UgaWYgKGlzUGFnZSkge1xuICAgIG1vZCA9IGF3YWl0IHBhZ2VbMF0oKVxuICAgIG1vZFR5cGUgPSAncGFnZSdcbiAgICBmaWxlUGF0aCA9IHBhZ2VbMV1cbiAgfSBlbHNlIGlmIChpc0RlZmF1bHRQYWdlKSB7XG4gICAgbW9kID0gYXdhaXQgZGVmYXVsdFBhZ2VbMF0oKVxuICAgIG1vZFR5cGUgPSAncGFnZSdcbiAgICBmaWxlUGF0aCA9IGRlZmF1bHRQYWdlWzFdXG4gIH1cblxuICByZXR1cm4geyBtb2QsIG1vZFR5cGUsIGZpbGVQYXRoIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENvbXBvbmVudFR5cGVNb2R1bGUoXG4gIGxvYWRlclRyZWU6IExvYWRlclRyZWUsXG4gIG1vZHVsZVR5cGU6ICdsYXlvdXQnIHwgJ25vdC1mb3VuZCcgfCAnZm9yYmlkZGVuJyB8ICd1bmF1dGhvcml6ZWQnXG4pIHtcbiAgY29uc3QgeyBbbW9kdWxlVHlwZV06IG1vZHVsZSB9ID0gbG9hZGVyVHJlZVsyXVxuICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gYXdhaXQgbW9kdWxlWzBdKClcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkXG59XG4iXSwibmFtZXMiOlsiREVGQVVMVF9TRUdNRU5UX0tFWSIsImdldExheW91dE9yUGFnZU1vZHVsZSIsImxvYWRlclRyZWUiLCJsYXlvdXQiLCJwYWdlIiwiZGVmYXVsdFBhZ2UiLCJpc0xheW91dCIsImlzUGFnZSIsImlzRGVmYXVsdFBhZ2UiLCJtb2QiLCJ1bmRlZmluZWQiLCJtb2RUeXBlIiwiZmlsZVBhdGgiLCJnZXRDb21wb25lbnRUeXBlTW9kdWxlIiwibW9kdWxlVHlwZSIsIm1vZHVsZSJdLCJtYXBwaW5ncyI6Ijs7OztBQUNBLFNBQVNBLG1CQUFtQixRQUFRLDJCQUEwQjs7QUFXdkQsZUFBZUMsc0JBQXNCQyxVQUFzQjtJQUNoRSxNQUFNLEVBQUVDLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxXQUFXLEVBQUUsR0FBR0gsVUFBVSxDQUFDLEVBQUU7SUFDbkQsTUFBTUksV0FBVyxPQUFPSCxXQUFXO0lBQ25DLE1BQU1JLFNBQVMsT0FBT0gsU0FBUztJQUMvQixNQUFNSSxnQkFDSixPQUFPSCxnQkFBZ0IsZUFBZUgsVUFBVSxDQUFDLEVBQUUscUtBQUtGLHNCQUFBQTtJQUUxRCxJQUFJUyxNQUFNQztJQUNWLElBQUlDLFVBQXlDRDtJQUM3QyxJQUFJRSxXQUFXRjtJQUVmLElBQUlKLFVBQVU7UUFDWkcsTUFBTSxNQUFNTixNQUFNLENBQUMsRUFBRTtRQUNyQlEsVUFBVTtRQUNWQyxXQUFXVCxNQUFNLENBQUMsRUFBRTtJQUN0QixPQUFPLElBQUlJLFFBQVE7UUFDakJFLE1BQU0sTUFBTUwsSUFBSSxDQUFDLEVBQUU7UUFDbkJPLFVBQVU7UUFDVkMsV0FBV1IsSUFBSSxDQUFDLEVBQUU7SUFDcEIsT0FBTyxJQUFJSSxlQUFlO1FBQ3hCQyxNQUFNLE1BQU1KLFdBQVcsQ0FBQyxFQUFFO1FBQzFCTSxVQUFVO1FBQ1ZDLFdBQVdQLFdBQVcsQ0FBQyxFQUFFO0lBQzNCO0lBRUEsT0FBTztRQUFFSTtRQUFLRTtRQUFTQztJQUFTO0FBQ2xDO0FBRU8sZUFBZUMsdUJBQ3BCWCxVQUFzQixFQUN0QlksVUFBaUU7SUFFakUsTUFBTSxFQUFFLENBQUNBLFdBQVcsRUFBRUMsTUFBTSxFQUFFLEdBQUdiLFVBQVUsQ0FBQyxFQUFFO0lBQzlDLElBQUksT0FBT2EsV0FBVyxhQUFhO1FBQ2pDLE9BQU8sTUFBTUEsTUFBTSxDQUFDLEVBQUU7SUFDeEI7SUFDQSxPQUFPTDtBQUNUIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDM4NzEsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NyYy9saWIvaW50ZXJvcC1kZWZhdWx0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBpbnRlcm9wRGVmYXVsdChtb2Q6IGFueSkge1xuICByZXR1cm4gbW9kLmRlZmF1bHQgfHwgbW9kXG59XG4iXSwibmFtZXMiOlsiaW50ZXJvcERlZmF1bHQiLCJtb2QiLCJkZWZhdWx0Il0sIm1hcHBpbmdzIjoiOzs7QUFBTyxTQUFTQSxlQUFlQyxHQUFRO0lBQ3JDLE9BQU9BLElBQUlDLE9BQU8sSUFBSUQ7QUFDeEIiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMzg4MSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL2xpYi9tZXRhZGF0YS9yZXNvbHZlcnMvcmVzb2x2ZS1iYXNpY3MudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUge1xuICBBbHRlcm5hdGVMaW5rRGVzY3JpcHRvcixcbiAgUmVzb2x2ZWRBbHRlcm5hdGVVUkxzLFxufSBmcm9tICcuLi90eXBlcy9hbHRlcm5hdGl2ZS11cmxzLXR5cGVzJ1xuaW1wb3J0IHR5cGUge1xuICBNZXRhZGF0YSxcbiAgUmVzb2x2ZWRNZXRhZGF0YSxcbiAgVmlld3BvcnQsXG59IGZyb20gJy4uL3R5cGVzL21ldGFkYXRhLWludGVyZmFjZSdcbmltcG9ydCB0eXBlIHsgUmVzb2x2ZWRWZXJpZmljYXRpb24gfSBmcm9tICcuLi90eXBlcy9tZXRhZGF0YS10eXBlcydcbmltcG9ydCB0eXBlIHtcbiAgRmllbGRSZXNvbHZlcixcbiAgQXN5bmNGaWVsZFJlc29sdmVyRXh0cmFBcmdzLFxuICBNZXRhZGF0YUNvbnRleHQsXG59IGZyb20gJy4uL3R5cGVzL3Jlc29sdmVycydcbmltcG9ydCB7IHJlc29sdmVBc0FycmF5T3JVbmRlZmluZWQgfSBmcm9tICcuLi9nZW5lcmF0ZS91dGlscydcbmltcG9ydCB7IHJlc29sdmVBYnNvbHV0ZVVybFdpdGhQYXRobmFtZSB9IGZyb20gJy4vcmVzb2x2ZS11cmwnXG5cbmZ1bmN0aW9uIHJlc29sdmVBbHRlcm5hdGVVcmwoXG4gIHVybDogc3RyaW5nIHwgVVJMLFxuICBtZXRhZGF0YUJhc2U6IFVSTCB8IG51bGwsXG4gIHBhdGhuYW1lOiBzdHJpbmcsXG4gIG1ldGFkYXRhQ29udGV4dDogTWV0YWRhdGFDb250ZXh0XG4pIHtcbiAgLy8gSWYgYWx0ZXIgbmF0aXZlIHVybCBpcyBhbiBVUkwgaW5zdGFuY2UsXG4gIC8vIHdlIHRyZWF0IGl0IGFzIGEgVVJMIGJhc2UgYW5kIHJlc29sdmUgd2l0aCBjdXJyZW50IHBhdGhuYW1lXG4gIGlmICh1cmwgaW5zdGFuY2VvZiBVUkwpIHtcbiAgICBjb25zdCBuZXdVcmwgPSBuZXcgVVJMKHBhdGhuYW1lLCB1cmwpXG4gICAgdXJsLnNlYXJjaFBhcmFtcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PlxuICAgICAgbmV3VXJsLnNlYXJjaFBhcmFtcy5zZXQoa2V5LCB2YWx1ZSlcbiAgICApXG4gICAgdXJsID0gbmV3VXJsXG4gIH1cbiAgcmV0dXJuIHJlc29sdmVBYnNvbHV0ZVVybFdpdGhQYXRobmFtZShcbiAgICB1cmwsXG4gICAgbWV0YWRhdGFCYXNlLFxuICAgIHBhdGhuYW1lLFxuICAgIG1ldGFkYXRhQ29udGV4dFxuICApXG59XG5cbmV4cG9ydCBjb25zdCByZXNvbHZlVGhlbWVDb2xvcjogRmllbGRSZXNvbHZlcjwndGhlbWVDb2xvcicsIFZpZXdwb3J0PiA9IChcbiAgdGhlbWVDb2xvclxuKSA9PiB7XG4gIGlmICghdGhlbWVDb2xvcikgcmV0dXJuIG51bGxcbiAgY29uc3QgdGhlbWVDb2xvckRlc2NyaXB0b3JzOiBWaWV3cG9ydFsndGhlbWVDb2xvciddID0gW11cblxuICByZXNvbHZlQXNBcnJheU9yVW5kZWZpbmVkKHRoZW1lQ29sb3IpPy5mb3JFYWNoKChkZXNjcmlwdG9yKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBkZXNjcmlwdG9yID09PSAnc3RyaW5nJylcbiAgICAgIHRoZW1lQ29sb3JEZXNjcmlwdG9ycy5wdXNoKHsgY29sb3I6IGRlc2NyaXB0b3IgfSlcbiAgICBlbHNlIGlmICh0eXBlb2YgZGVzY3JpcHRvciA9PT0gJ29iamVjdCcpXG4gICAgICB0aGVtZUNvbG9yRGVzY3JpcHRvcnMucHVzaCh7XG4gICAgICAgIGNvbG9yOiBkZXNjcmlwdG9yLmNvbG9yLFxuICAgICAgICBtZWRpYTogZGVzY3JpcHRvci5tZWRpYSxcbiAgICAgIH0pXG4gIH0pXG5cbiAgcmV0dXJuIHRoZW1lQ29sb3JEZXNjcmlwdG9yc1xufVxuXG5hc3luYyBmdW5jdGlvbiByZXNvbHZlVXJsVmFsdWVzT2ZPYmplY3QoXG4gIG9iajpcbiAgICB8IFJlY29yZDxcbiAgICAgICAgc3RyaW5nLFxuICAgICAgICBzdHJpbmcgfCBVUkwgfCBBbHRlcm5hdGVMaW5rRGVzY3JpcHRvcltdIHwgbnVsbCB8IHVuZGVmaW5lZFxuICAgICAgPlxuICAgIHwgbnVsbFxuICAgIHwgdW5kZWZpbmVkLFxuICBtZXRhZGF0YUJhc2U6IFJlc29sdmVkTWV0YWRhdGFbJ21ldGFkYXRhQmFzZSddLFxuICBwYXRobmFtZTogUHJvbWlzZTxzdHJpbmc+LFxuICBtZXRhZGF0YUNvbnRleHQ6IE1ldGFkYXRhQ29udGV4dFxuKTogUHJvbWlzZTxudWxsIHwgUmVjb3JkPHN0cmluZywgQWx0ZXJuYXRlTGlua0Rlc2NyaXB0b3JbXT4+IHtcbiAgaWYgKCFvYmopIHJldHVybiBudWxsXG5cbiAgY29uc3QgcmVzdWx0OiBSZWNvcmQ8c3RyaW5nLCBBbHRlcm5hdGVMaW5rRGVzY3JpcHRvcltdPiA9IHt9XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG9iaikpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIFVSTCkge1xuICAgICAgY29uc3QgcGF0aG5hbWVGb3JVcmwgPSBhd2FpdCBwYXRobmFtZVxuICAgICAgcmVzdWx0W2tleV0gPSBbXG4gICAgICAgIHtcbiAgICAgICAgICB1cmw6IHJlc29sdmVBbHRlcm5hdGVVcmwoXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIG1ldGFkYXRhQmFzZSxcbiAgICAgICAgICAgIHBhdGhuYW1lRm9yVXJsLFxuICAgICAgICAgICAgbWV0YWRhdGFDb250ZXh0XG4gICAgICAgICAgKSxcbiAgICAgICAgfSxcbiAgICAgIF1cbiAgICB9IGVsc2UgaWYgKHZhbHVlICYmIHZhbHVlLmxlbmd0aCkge1xuICAgICAgcmVzdWx0W2tleV0gPSBbXVxuICAgICAgY29uc3QgcGF0aG5hbWVGb3JVcmwgPSBhd2FpdCBwYXRobmFtZVxuICAgICAgdmFsdWUuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgdXJsID0gcmVzb2x2ZUFsdGVybmF0ZVVybChcbiAgICAgICAgICBpdGVtLnVybCxcbiAgICAgICAgICBtZXRhZGF0YUJhc2UsXG4gICAgICAgICAgcGF0aG5hbWVGb3JVcmwsXG4gICAgICAgICAgbWV0YWRhdGFDb250ZXh0XG4gICAgICAgIClcbiAgICAgICAgcmVzdWx0W2tleV1baW5kZXhdID0ge1xuICAgICAgICAgIHVybCxcbiAgICAgICAgICB0aXRsZTogaXRlbS50aXRsZSxcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5hc3luYyBmdW5jdGlvbiByZXNvbHZlQ2Fub25pY2FsVXJsKFxuICB1cmxPckRlc2NyaXB0b3I6IHN0cmluZyB8IFVSTCB8IG51bGwgfCBBbHRlcm5hdGVMaW5rRGVzY3JpcHRvciB8IHVuZGVmaW5lZCxcbiAgbWV0YWRhdGFCYXNlOiBVUkwgfCBudWxsLFxuICBwYXRobmFtZTogUHJvbWlzZTxzdHJpbmc+LFxuICBtZXRhZGF0YUNvbnRleHQ6IE1ldGFkYXRhQ29udGV4dFxuKTogUHJvbWlzZTxudWxsIHwgQWx0ZXJuYXRlTGlua0Rlc2NyaXB0b3I+IHtcbiAgaWYgKCF1cmxPckRlc2NyaXB0b3IpIHJldHVybiBudWxsXG5cbiAgY29uc3QgdXJsID1cbiAgICB0eXBlb2YgdXJsT3JEZXNjcmlwdG9yID09PSAnc3RyaW5nJyB8fCB1cmxPckRlc2NyaXB0b3IgaW5zdGFuY2VvZiBVUkxcbiAgICAgID8gdXJsT3JEZXNjcmlwdG9yXG4gICAgICA6IHVybE9yRGVzY3JpcHRvci51cmxcblxuICBjb25zdCBwYXRobmFtZUZvclVybCA9IGF3YWl0IHBhdGhuYW1lXG5cbiAgLy8gUmV0dXJuIHN0cmluZyB1cmwgYmVjYXVzZSBzdHJ1Y3R1cmVDbG9uZSBjYW4ndCBoYW5kbGUgVVJMIGluc3RhbmNlXG4gIHJldHVybiB7XG4gICAgdXJsOiByZXNvbHZlQWx0ZXJuYXRlVXJsKFxuICAgICAgdXJsLFxuICAgICAgbWV0YWRhdGFCYXNlLFxuICAgICAgcGF0aG5hbWVGb3JVcmwsXG4gICAgICBtZXRhZGF0YUNvbnRleHRcbiAgICApLFxuICB9XG59XG5cbmV4cG9ydCBjb25zdCByZXNvbHZlQWx0ZXJuYXRlczogQXN5bmNGaWVsZFJlc29sdmVyRXh0cmFBcmdzPFxuICAnYWx0ZXJuYXRlcycsXG4gIFtSZXNvbHZlZE1ldGFkYXRhWydtZXRhZGF0YUJhc2UnXSwgUHJvbWlzZTxzdHJpbmc+LCBNZXRhZGF0YUNvbnRleHRdXG4+ID0gYXN5bmMgKGFsdGVybmF0ZXMsIG1ldGFkYXRhQmFzZSwgcGF0aG5hbWUsIGNvbnRleHQpID0+IHtcbiAgaWYgKCFhbHRlcm5hdGVzKSByZXR1cm4gbnVsbFxuXG4gIGNvbnN0IGNhbm9uaWNhbCA9IGF3YWl0IHJlc29sdmVDYW5vbmljYWxVcmwoXG4gICAgYWx0ZXJuYXRlcy5jYW5vbmljYWwsXG4gICAgbWV0YWRhdGFCYXNlLFxuICAgIHBhdGhuYW1lLFxuICAgIGNvbnRleHRcbiAgKVxuICBjb25zdCBsYW5ndWFnZXMgPSBhd2FpdCByZXNvbHZlVXJsVmFsdWVzT2ZPYmplY3QoXG4gICAgYWx0ZXJuYXRlcy5sYW5ndWFnZXMsXG4gICAgbWV0YWRhdGFCYXNlLFxuICAgIHBhdGhuYW1lLFxuICAgIGNvbnRleHRcbiAgKVxuICBjb25zdCBtZWRpYSA9IGF3YWl0IHJlc29sdmVVcmxWYWx1ZXNPZk9iamVjdChcbiAgICBhbHRlcm5hdGVzLm1lZGlhLFxuICAgIG1ldGFkYXRhQmFzZSxcbiAgICBwYXRobmFtZSxcbiAgICBjb250ZXh0XG4gIClcbiAgY29uc3QgdHlwZXMgPSBhd2FpdCByZXNvbHZlVXJsVmFsdWVzT2ZPYmplY3QoXG4gICAgYWx0ZXJuYXRlcy50eXBlcyxcbiAgICBtZXRhZGF0YUJhc2UsXG4gICAgcGF0aG5hbWUsXG4gICAgY29udGV4dFxuICApXG5cbiAgY29uc3QgcmVzdWx0OiBSZXNvbHZlZEFsdGVybmF0ZVVSTHMgPSB7XG4gICAgY2Fub25pY2FsLFxuICAgIGxhbmd1YWdlcyxcbiAgICBtZWRpYSxcbiAgICB0eXBlcyxcbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuY29uc3Qgcm9ib3RzS2V5cyA9IFtcbiAgJ25vYXJjaGl2ZScsXG4gICdub3NuaXBwZXQnLFxuICAnbm9pbWFnZWluZGV4JyxcbiAgJ25vY2FjaGUnLFxuICAnbm90cmFuc2xhdGUnLFxuICAnaW5kZXhpZmVtYmVkZGVkJyxcbiAgJ25vc2l0ZWxpbmtzc2VhcmNoYm94JyxcbiAgJ3VuYXZhaWxhYmxlX2FmdGVyJyxcbiAgJ21heC12aWRlby1wcmV2aWV3JyxcbiAgJ21heC1pbWFnZS1wcmV2aWV3JyxcbiAgJ21heC1zbmlwcGV0Jyxcbl0gYXMgY29uc3RcbmNvbnN0IHJlc29sdmVSb2JvdHNWYWx1ZTogKHJvYm90czogTWV0YWRhdGFbJ3JvYm90cyddKSA9PiBzdHJpbmcgfCBudWxsID0gKFxuICByb2JvdHNcbikgPT4ge1xuICBpZiAoIXJvYm90cykgcmV0dXJuIG51bGxcbiAgaWYgKHR5cGVvZiByb2JvdHMgPT09ICdzdHJpbmcnKSByZXR1cm4gcm9ib3RzXG5cbiAgY29uc3QgdmFsdWVzOiBzdHJpbmdbXSA9IFtdXG5cbiAgaWYgKHJvYm90cy5pbmRleCkgdmFsdWVzLnB1c2goJ2luZGV4JylcbiAgZWxzZSBpZiAodHlwZW9mIHJvYm90cy5pbmRleCA9PT0gJ2Jvb2xlYW4nKSB2YWx1ZXMucHVzaCgnbm9pbmRleCcpXG5cbiAgaWYgKHJvYm90cy5mb2xsb3cpIHZhbHVlcy5wdXNoKCdmb2xsb3cnKVxuICBlbHNlIGlmICh0eXBlb2Ygcm9ib3RzLmZvbGxvdyA9PT0gJ2Jvb2xlYW4nKSB2YWx1ZXMucHVzaCgnbm9mb2xsb3cnKVxuXG4gIGZvciAoY29uc3Qga2V5IG9mIHJvYm90c0tleXMpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHJvYm90c1trZXldXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgIT09IGZhbHNlKSB7XG4gICAgICB2YWx1ZXMucHVzaCh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyA/IGtleSA6IGAke2tleX06JHt2YWx1ZX1gKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB2YWx1ZXMuam9pbignLCAnKVxufVxuXG5leHBvcnQgY29uc3QgcmVzb2x2ZVJvYm90czogRmllbGRSZXNvbHZlcjwncm9ib3RzJz4gPSAocm9ib3RzKSA9PiB7XG4gIGlmICghcm9ib3RzKSByZXR1cm4gbnVsbFxuICByZXR1cm4ge1xuICAgIGJhc2ljOiByZXNvbHZlUm9ib3RzVmFsdWUocm9ib3RzKSxcbiAgICBnb29nbGVCb3Q6XG4gICAgICB0eXBlb2Ygcm9ib3RzICE9PSAnc3RyaW5nJyA/IHJlc29sdmVSb2JvdHNWYWx1ZShyb2JvdHMuZ29vZ2xlQm90KSA6IG51bGwsXG4gIH1cbn1cblxuY29uc3QgVmVyaWZpY2F0aW9uS2V5cyA9IFsnZ29vZ2xlJywgJ3lhaG9vJywgJ3lhbmRleCcsICdtZScsICdvdGhlciddIGFzIGNvbnN0XG5leHBvcnQgY29uc3QgcmVzb2x2ZVZlcmlmaWNhdGlvbjogRmllbGRSZXNvbHZlcjwndmVyaWZpY2F0aW9uJz4gPSAoXG4gIHZlcmlmaWNhdGlvblxuKSA9PiB7XG4gIGlmICghdmVyaWZpY2F0aW9uKSByZXR1cm4gbnVsbFxuICBjb25zdCByZXM6IFJlc29sdmVkVmVyaWZpY2F0aW9uID0ge31cblxuICBmb3IgKGNvbnN0IGtleSBvZiBWZXJpZmljYXRpb25LZXlzKSB7XG4gICAgY29uc3QgdmFsdWUgPSB2ZXJpZmljYXRpb25ba2V5XVxuICAgIGlmICh2YWx1ZSkge1xuICAgICAgaWYgKGtleSA9PT0gJ290aGVyJykge1xuICAgICAgICByZXMub3RoZXIgPSB7fVxuICAgICAgICBmb3IgKGNvbnN0IG90aGVyS2V5IGluIHZlcmlmaWNhdGlvbi5vdGhlcikge1xuICAgICAgICAgIGNvbnN0IG90aGVyVmFsdWUgPSByZXNvbHZlQXNBcnJheU9yVW5kZWZpbmVkKFxuICAgICAgICAgICAgdmVyaWZpY2F0aW9uLm90aGVyW290aGVyS2V5XVxuICAgICAgICAgIClcbiAgICAgICAgICBpZiAob3RoZXJWYWx1ZSkgcmVzLm90aGVyW290aGVyS2V5XSA9IG90aGVyVmFsdWVcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHJlc1trZXldID0gcmVzb2x2ZUFzQXJyYXlPclVuZGVmaW5lZCh2YWx1ZSkgYXMgKHN0cmluZyB8IG51bWJlcilbXVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmV4cG9ydCBjb25zdCByZXNvbHZlQXBwbGVXZWJBcHA6IEZpZWxkUmVzb2x2ZXI8J2FwcGxlV2ViQXBwJz4gPSAoYXBwV2ViQXBwKSA9PiB7XG4gIGlmICghYXBwV2ViQXBwKSByZXR1cm4gbnVsbFxuICBpZiAoYXBwV2ViQXBwID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhcGFibGU6IHRydWUsXG4gICAgfVxuICB9XG5cbiAgY29uc3Qgc3RhcnR1cEltYWdlcyA9IGFwcFdlYkFwcC5zdGFydHVwSW1hZ2VcbiAgICA/IHJlc29sdmVBc0FycmF5T3JVbmRlZmluZWQoYXBwV2ViQXBwLnN0YXJ0dXBJbWFnZSk/Lm1hcCgoaXRlbSkgPT5cbiAgICAgICAgdHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnID8geyB1cmw6IGl0ZW0gfSA6IGl0ZW1cbiAgICAgIClcbiAgICA6IG51bGxcblxuICByZXR1cm4ge1xuICAgIGNhcGFibGU6ICdjYXBhYmxlJyBpbiBhcHBXZWJBcHAgPyAhIWFwcFdlYkFwcC5jYXBhYmxlIDogdHJ1ZSxcbiAgICB0aXRsZTogYXBwV2ViQXBwLnRpdGxlIHx8IG51bGwsXG4gICAgc3RhcnR1cEltYWdlOiBzdGFydHVwSW1hZ2VzLFxuICAgIHN0YXR1c0JhclN0eWxlOiBhcHBXZWJBcHAuc3RhdHVzQmFyU3R5bGUgfHwgJ2RlZmF1bHQnLFxuICB9XG59XG5cbmV4cG9ydCBjb25zdCByZXNvbHZlQXBwTGlua3M6IEZpZWxkUmVzb2x2ZXI8J2FwcExpbmtzJz4gPSAoYXBwTGlua3MpID0+IHtcbiAgaWYgKCFhcHBMaW5rcykgcmV0dXJuIG51bGxcbiAgZm9yIChjb25zdCBrZXkgaW4gYXBwTGlua3MpIHtcbiAgICAvLyBAdHMtaWdub3JlIC8vIFRPRE86IHR5cGUgaW5mZXJcbiAgICBhcHBMaW5rc1trZXldID0gcmVzb2x2ZUFzQXJyYXlPclVuZGVmaW5lZChhcHBMaW5rc1trZXldKVxuICB9XG4gIHJldHVybiBhcHBMaW5rcyBhcyBSZXNvbHZlZE1ldGFkYXRhWydhcHBMaW5rcyddXG59XG5cbmV4cG9ydCBjb25zdCByZXNvbHZlSXR1bmVzOiBBc3luY0ZpZWxkUmVzb2x2ZXJFeHRyYUFyZ3M8XG4gICdpdHVuZXMnLFxuICBbUmVzb2x2ZWRNZXRhZGF0YVsnbWV0YWRhdGFCYXNlJ10sIFByb21pc2U8c3RyaW5nPiwgTWV0YWRhdGFDb250ZXh0XVxuPiA9IGFzeW5jIChpdHVuZXMsIG1ldGFkYXRhQmFzZSwgcGF0aG5hbWUsIGNvbnRleHQpID0+IHtcbiAgaWYgKCFpdHVuZXMpIHJldHVybiBudWxsXG4gIHJldHVybiB7XG4gICAgYXBwSWQ6IGl0dW5lcy5hcHBJZCxcbiAgICBhcHBBcmd1bWVudDogaXR1bmVzLmFwcEFyZ3VtZW50XG4gICAgICA/IHJlc29sdmVBbHRlcm5hdGVVcmwoXG4gICAgICAgICAgaXR1bmVzLmFwcEFyZ3VtZW50LFxuICAgICAgICAgIG1ldGFkYXRhQmFzZSxcbiAgICAgICAgICBhd2FpdCBwYXRobmFtZSxcbiAgICAgICAgICBjb250ZXh0XG4gICAgICAgIClcbiAgICAgIDogdW5kZWZpbmVkLFxuICB9XG59XG5cbmV4cG9ydCBjb25zdCByZXNvbHZlRmFjZWJvb2s6IEZpZWxkUmVzb2x2ZXI8J2ZhY2Vib29rJz4gPSAoZmFjZWJvb2spID0+IHtcbiAgaWYgKCFmYWNlYm9vaykgcmV0dXJuIG51bGxcbiAgcmV0dXJuIHtcbiAgICBhcHBJZDogZmFjZWJvb2suYXBwSWQsXG4gICAgYWRtaW5zOiByZXNvbHZlQXNBcnJheU9yVW5kZWZpbmVkKGZhY2Vib29rLmFkbWlucyksXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHJlc29sdmVQYWdpbmF0aW9uOiBBc3luY0ZpZWxkUmVzb2x2ZXJFeHRyYUFyZ3M8XG4gICdwYWdpbmF0aW9uJyxcbiAgW1Jlc29sdmVkTWV0YWRhdGFbJ21ldGFkYXRhQmFzZSddLCBQcm9taXNlPHN0cmluZz4sIE1ldGFkYXRhQ29udGV4dF1cbj4gPSBhc3luYyAocGFnaW5hdGlvbiwgbWV0YWRhdGFCYXNlLCBwYXRobmFtZSwgY29udGV4dCkgPT4ge1xuICByZXR1cm4ge1xuICAgIHByZXZpb3VzOiBwYWdpbmF0aW9uPy5wcmV2aW91c1xuICAgICAgPyByZXNvbHZlQWx0ZXJuYXRlVXJsKFxuICAgICAgICAgIHBhZ2luYXRpb24ucHJldmlvdXMsXG4gICAgICAgICAgbWV0YWRhdGFCYXNlLFxuICAgICAgICAgIGF3YWl0IHBhdGhuYW1lLFxuICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgKVxuICAgICAgOiBudWxsLFxuICAgIG5leHQ6IHBhZ2luYXRpb24/Lm5leHRcbiAgICAgID8gcmVzb2x2ZUFsdGVybmF0ZVVybChcbiAgICAgICAgICBwYWdpbmF0aW9uLm5leHQsXG4gICAgICAgICAgbWV0YWRhdGFCYXNlLFxuICAgICAgICAgIGF3YWl0IHBhdGhuYW1lLFxuICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgKVxuICAgICAgOiBudWxsLFxuICB9XG59XG4iXSwibmFtZXMiOlsicmVzb2x2ZUFzQXJyYXlPclVuZGVmaW5lZCIsInJlc29sdmVBYnNvbHV0ZVVybFdpdGhQYXRobmFtZSIsInJlc29sdmVBbHRlcm5hdGVVcmwiLCJ1cmwiLCJtZXRhZGF0YUJhc2UiLCJwYXRobmFtZSIsIm1ldGFkYXRhQ29udGV4dCIsIlVSTCIsIm5ld1VybCIsInNlYXJjaFBhcmFtcyIsImZvckVhY2giLCJ2YWx1ZSIsImtleSIsInNldCIsInJlc29sdmVUaGVtZUNvbG9yIiwidGhlbWVDb2xvciIsInRoZW1lQ29sb3JEZXNjcmlwdG9ycyIsImRlc2NyaXB0b3IiLCJwdXNoIiwiY29sb3IiLCJtZWRpYSIsInJlc29sdmVVcmxWYWx1ZXNPZk9iamVjdCIsIm9iaiIsInJlc3VsdCIsIk9iamVjdCIsImVudHJpZXMiLCJwYXRobmFtZUZvclVybCIsImxlbmd0aCIsIml0ZW0iLCJpbmRleCIsInRpdGxlIiwicmVzb2x2ZUNhbm9uaWNhbFVybCIsInVybE9yRGVzY3JpcHRvciIsInJlc29sdmVBbHRlcm5hdGVzIiwiYWx0ZXJuYXRlcyIsImNvbnRleHQiLCJjYW5vbmljYWwiLCJsYW5ndWFnZXMiLCJ0eXBlcyIsInJvYm90c0tleXMiLCJyZXNvbHZlUm9ib3RzVmFsdWUiLCJyb2JvdHMiLCJ2YWx1ZXMiLCJmb2xsb3ciLCJqb2luIiwicmVzb2x2ZVJvYm90cyIsImJhc2ljIiwiZ29vZ2xlQm90IiwiVmVyaWZpY2F0aW9uS2V5cyIsInJlc29sdmVWZXJpZmljYXRpb24iLCJ2ZXJpZmljYXRpb24iLCJyZXMiLCJvdGhlciIsIm90aGVyS2V5Iiwib3RoZXJWYWx1ZSIsInJlc29sdmVBcHBsZVdlYkFwcCIsImFwcFdlYkFwcCIsImNhcGFibGUiLCJzdGFydHVwSW1hZ2VzIiwic3RhcnR1cEltYWdlIiwibWFwIiwic3RhdHVzQmFyU3R5bGUiLCJyZXNvbHZlQXBwTGlua3MiLCJhcHBMaW5rcyIsInJlc29sdmVJdHVuZXMiLCJpdHVuZXMiLCJhcHBJZCIsImFwcEFyZ3VtZW50IiwidW5kZWZpbmVkIiwicmVzb2x2ZUZhY2Vib29rIiwiZmFjZWJvb2siLCJhZG1pbnMiLCJyZXNvbHZlUGFnaW5hdGlvbiIsInBhZ2luYXRpb24iLCJwcmV2aW91cyIsIm5leHQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBZUEsU0FBU0EseUJBQXlCLFFBQVEsb0JBQW1CO0FBQzdELFNBQVNDLDhCQUE4QixRQUFRLGdCQUFlOzs7QUFFOUQsU0FBU0Msb0JBQ1BDLEdBQWlCLEVBQ2pCQyxZQUF3QixFQUN4QkMsUUFBZ0IsRUFDaEJDLGVBQWdDO0lBRWhDLDBDQUEwQztJQUMxQyw4REFBOEQ7SUFDOUQsSUFBSUgsZUFBZUksS0FBSztRQUN0QixNQUFNQyxTQUFTLElBQUlELElBQUlGLFVBQVVGO1FBQ2pDQSxJQUFJTSxZQUFZLENBQUNDLE9BQU8sQ0FBQyxDQUFDQyxPQUFPQyxNQUMvQkosT0FBT0MsWUFBWSxDQUFDSSxHQUFHLENBQUNELEtBQUtEO1FBRS9CUixNQUFNSztJQUNSO0lBQ0EsZ01BQU9QLGtDQUFBQSxFQUNMRSxLQUNBQyxjQUNBQyxVQUNBQztBQUVKO0FBRU8sTUFBTVEsb0JBQTJELENBQ3RFQztRQUtBZjtJQUhBLElBQUksQ0FBQ2UsWUFBWSxPQUFPO0lBQ3hCLE1BQU1DLHdCQUFnRCxFQUFFO0tBRXhEaEIsNE1BQUFBLDZCQUFBQSxFQUEwQmUsV0FBQUEsS0FBQUEsT0FBQUEsS0FBQUEsSUFBMUJmLDJCQUF1Q1UsT0FBTyxDQUFDLENBQUNPO1FBQzlDLElBQUksT0FBT0EsZUFBZSxVQUN4QkQsc0JBQXNCRSxJQUFJLENBQUM7WUFBRUMsT0FBT0Y7UUFBVzthQUM1QyxJQUFJLE9BQU9BLGVBQWUsVUFDN0JELHNCQUFzQkUsSUFBSSxDQUFDO1lBQ3pCQyxPQUFPRixXQUFXRSxLQUFLO1lBQ3ZCQyxPQUFPSCxXQUFXRyxLQUFLO1FBQ3pCO0lBQ0o7SUFFQSxPQUFPSjtBQUNULEVBQUM7QUFFRCxlQUFlSyx5QkFDYkMsR0FNYSxFQUNibEIsWUFBOEMsRUFDOUNDLFFBQXlCLEVBQ3pC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QkFDRXVFLFdBQVdDLFFBQVEsRUFDbkJ0RSxjQUNBLE1BQU1DLFVBQ044QixXQUVGO1FBQ0p3QyxNQUFNRixDQUFBQSxjQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxXQUFZRSxJQUFJLElBQ2xCekUsb0JBQ0V1RSxXQUFXRSxJQUFJLEVBQ2Z2RSxjQUNBLE1BQU1DLFVBQ044QixXQUVGO0lBQ047QUFDRixFQUFDIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDQwNzksICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NyYy9saWIvbWV0YWRhdGEvcmVzb2x2ZXJzL3Jlc29sdmUtaWNvbnMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBSZXNvbHZlZE1ldGFkYXRhIH0gZnJvbSAnLi4vdHlwZXMvbWV0YWRhdGEtaW50ZXJmYWNlJ1xuaW1wb3J0IHR5cGUgeyBJY29uLCBJY29uRGVzY3JpcHRvciB9IGZyb20gJy4uL3R5cGVzL21ldGFkYXRhLXR5cGVzJ1xuaW1wb3J0IHR5cGUgeyBGaWVsZFJlc29sdmVyIH0gZnJvbSAnLi4vdHlwZXMvcmVzb2x2ZXJzJ1xuaW1wb3J0IHsgcmVzb2x2ZUFzQXJyYXlPclVuZGVmaW5lZCB9IGZyb20gJy4uL2dlbmVyYXRlL3V0aWxzJ1xuaW1wb3J0IHsgaXNTdHJpbmdPclVSTCB9IGZyb20gJy4vcmVzb2x2ZS11cmwnXG5pbXBvcnQgeyBJY29uS2V5cyB9IGZyb20gJy4uL2NvbnN0YW50cydcblxuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVJY29uKGljb246IEljb24pOiBJY29uRGVzY3JpcHRvciB7XG4gIGlmIChpc1N0cmluZ09yVVJMKGljb24pKSByZXR1cm4geyB1cmw6IGljb24gfVxuICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGljb24pKSByZXR1cm4gaWNvblxuICByZXR1cm4gaWNvblxufVxuXG5leHBvcnQgY29uc3QgcmVzb2x2ZUljb25zOiBGaWVsZFJlc29sdmVyPCdpY29ucyc+ID0gKGljb25zKSA9PiB7XG4gIGlmICghaWNvbnMpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgY29uc3QgcmVzb2x2ZWQ6IFJlc29sdmVkTWV0YWRhdGFbJ2ljb25zJ10gPSB7XG4gICAgaWNvbjogW10sXG4gICAgYXBwbGU6IFtdLFxuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGljb25zKSkge1xuICAgIHJlc29sdmVkLmljb24gPSBpY29ucy5tYXAocmVzb2x2ZUljb24pLmZpbHRlcihCb29sZWFuKVxuICB9IGVsc2UgaWYgKGlzU3RyaW5nT3JVUkwoaWNvbnMpKSB7XG4gICAgcmVzb2x2ZWQuaWNvbiA9IFtyZXNvbHZlSWNvbihpY29ucyldXG4gIH0gZWxzZSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgSWNvbktleXMpIHtcbiAgICAgIGNvbnN0IHZhbHVlcyA9IHJlc29sdmVBc0FycmF5T3JVbmRlZmluZWQoaWNvbnNba2V5XSlcbiAgICAgIGlmICh2YWx1ZXMpIHJlc29sdmVkW2tleV0gPSB2YWx1ZXMubWFwKHJlc29sdmVJY29uKVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzb2x2ZWRcbn1cbiJdLCJuYW1lcyI6WyJyZXNvbHZlQXNBcnJheU9yVW5kZWZpbmVkIiwiaXNTdHJpbmdPclVSTCIsIkljb25LZXlzIiwicmVzb2x2ZUljb24iLCJpY29uIiwidXJsIiwiQXJyYXkiLCJpc0FycmF5IiwicmVzb2x2ZUljb25zIiwiaWNvbnMiLCJyZXNvbHZlZCIsImFwcGxlIiwibWFwIiwiZmlsdGVyIiwiQm9vbGVhbiIsImtleSIsInZhbHVlcyJdLCJtYXBwaW5ncyI6Ijs7OztBQUdBLFNBQVNBLHlCQUF5QixRQUFRLG9CQUFtQjtBQUM3RCxTQUFTQyxhQUFhLFFBQVEsZ0JBQWU7QUFDN0MsU0FBU0MsUUFBUSxRQUFRLGVBQWM7Ozs7QUFFaEMsU0FBU0MsWUFBWUMsSUFBVTtJQUNwQyw4TEFBSUgsZ0JBQUFBLEVBQWNHLE9BQU8sT0FBTztRQUFFQyxLQUFLRDtJQUFLO1NBQ3ZDLElBQUlFLE1BQU1DLE9BQU8sQ0FBQ0gsT0FBTyxPQUFPQTtJQUNyQyxPQUFPQTtBQUNUO0FBRU8sTUFBTUksZUFBdUMsQ0FBQ0M7SUFDbkQsSUFBSSxDQUFDQSxPQUFPO1FBQ1YsT0FBTztJQUNUO0lBRUEsTUFBTUMsV0FBc0M7UUFDMUNOLE1BQU0sRUFBRTtRQUNSTyxPQUFPLEVBQUU7SUFDWDtJQUNBLElBQUlMLE1BQU1DLE9BQU8sQ0FBQ0UsUUFBUTtRQUN4QkMsU0FBU04sSUFBSSxHQUFHSyxNQUFNRyxHQUFHLENBQUNULGFBQWFVLE1BQU0sQ0FBQ0M7SUFDaEQsT0FBTyw4TEFBSWIsZ0JBQUFBLEVBQWNRLFFBQVE7UUFDL0JDLFNBQVNOLElBQUksR0FBRztZQUFDRCxZQUFZTTtTQUFPO0lBQ3RDLE9BQU87UUFDTCxLQUFLLE1BQU1NLDBLQUFPYixZQUFBQSxDQUFVO1lBQzFCLE1BQU1jLHlMQUFTaEIsNEJBQUFBLEVBQTBCUyxLQUFLLENBQUNNLElBQUk7WUFDbkQsSUFBSUMsUUFBUU4sUUFBUSxDQUFDSyxJQUFJLEdBQUdDLE9BQU9KLEdBQUcsQ0FBQ1Q7UUFDekM7SUFDRjtJQUNBLE9BQU9PO0FBQ1QsRUFBQyIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA0MTIyLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zcmMvc2VydmVyL2xpYi90cmFjZS9jb25zdGFudHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb250YWlucyBwcmVkZWZpbmVkIGNvbnN0YW50cyBmb3IgdGhlIHRyYWNlIHNwYW4gbmFtZSBpbiBuZXh0L3NlcnZlci5cbiAqXG4gKiBDdXJyZW50bHksIG5leHQvc2VydmVyL3RyYWNlciBpcyBpbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiBvbmx5IGZvciB0cmFja2luZ1xuICogbmV4dC5qcydzIGltcGxlbWVudGF0aW9uIG9ubHkgd2l0aCBrbm93biBzcGFuIG5hbWVzIGRlZmluZWQgaGVyZS5cbiAqKi9cblxuLy8gZXNsaW50IHR5cGVzY3JpcHQgaGFzIGEgYnVnIHdpdGggVFMgZW51bXNcbi8qIGVzbGludC1kaXNhYmxlIG5vLXNoYWRvdyAqL1xuXG5lbnVtIEJhc2VTZXJ2ZXJTcGFuIHtcbiAgaGFuZGxlUmVxdWVzdCA9ICdCYXNlU2VydmVyLmhhbmRsZVJlcXVlc3QnLFxuICBydW4gPSAnQmFzZVNlcnZlci5ydW4nLFxuICBwaXBlID0gJ0Jhc2VTZXJ2ZXIucGlwZScsXG4gIGdldFN0YXRpY0hUTUwgPSAnQmFzZVNlcnZlci5nZXRTdGF0aWNIVE1MJyxcbiAgcmVuZGVyID0gJ0Jhc2VTZXJ2ZXIucmVuZGVyJyxcbiAgcmVuZGVyVG9SZXNwb25zZVdpdGhDb21wb25lbnRzID0gJ0Jhc2VTZXJ2ZXIucmVuZGVyVG9SZXNwb25zZVdpdGhDb21wb25lbnRzJyxcbiAgcmVuZGVyVG9SZXNwb25zZSA9ICdCYXNlU2VydmVyLnJlbmRlclRvUmVzcG9uc2UnLFxuICByZW5kZXJUb0hUTUwgPSAnQmFzZVNlcnZlci5yZW5kZXJUb0hUTUwnLFxuICByZW5kZXJFcnJvciA9ICdCYXNlU2VydmVyLnJlbmRlckVycm9yJyxcbiAgcmVuZGVyRXJyb3JUb1Jlc3BvbnNlID0gJ0Jhc2VTZXJ2ZXIucmVuZGVyRXJyb3JUb1Jlc3BvbnNlJyxcbiAgcmVuZGVyRXJyb3JUb0hUTUwgPSAnQmFzZVNlcnZlci5yZW5kZXJFcnJvclRvSFRNTCcsXG4gIHJlbmRlcjQwNCA9ICdCYXNlU2VydmVyLnJlbmRlcjQwNCcsXG59XG5cbmVudW0gTG9hZENvbXBvbmVudHNTcGFuIHtcbiAgbG9hZERlZmF1bHRFcnJvckNvbXBvbmVudHMgPSAnTG9hZENvbXBvbmVudHMubG9hZERlZmF1bHRFcnJvckNvbXBvbmVudHMnLFxuICBsb2FkQ29tcG9uZW50cyA9ICdMb2FkQ29tcG9uZW50cy5sb2FkQ29tcG9uZW50cycsXG59XG5cbmVudW0gTmV4dFNlcnZlclNwYW4ge1xuICBnZXRSZXF1ZXN0SGFuZGxlciA9ICdOZXh0U2VydmVyLmdldFJlcXVlc3RIYW5kbGVyJyxcbiAgZ2V0U2VydmVyID0gJ05leHRTZXJ2ZXIuZ2V0U2VydmVyJyxcbiAgZ2V0U2VydmVyUmVxdWVzdEhhbmRsZXIgPSAnTmV4dFNlcnZlci5nZXRTZXJ2ZXJSZXF1ZXN0SGFuZGxlcicsXG4gIGNyZWF0ZVNlcnZlciA9ICdjcmVhdGVTZXJ2ZXIuY3JlYXRlU2VydmVyJyxcbn1cblxuZW51bSBOZXh0Tm9kZVNlcnZlclNwYW4ge1xuICBjb21wcmVzc2lvbiA9ICdOZXh0Tm9kZVNlcnZlci5jb21wcmVzc2lvbicsXG4gIGdldEJ1aWxkSWQgPSAnTmV4dE5vZGVTZXJ2ZXIuZ2V0QnVpbGRJZCcsXG4gIGNyZWF0ZUNvbXBvbmVudFRyZWUgPSAnTmV4dE5vZGVTZXJ2ZXIuY3JlYXRlQ29tcG9uZW50VHJlZScsXG4gIGNsaWVudENvbXBvbmVudExvYWRpbmcgPSAnTmV4dE5vZGVTZXJ2ZXIuY2xpZW50Q29tcG9uZW50TG9hZGluZycsXG4gIGdldExheW91dE9yUGFnZU1vZHVsZSA9ICdOZXh0Tm9kZVNlcnZlci5nZXRMYXlvdXRPclBhZ2VNb2R1bGUnLFxuICBnZW5lcmF0ZVN0YXRpY1JvdXRlcyA9ICdOZXh0Tm9kZVNlcnZlci5nZW5lcmF0ZVN0YXRpY1JvdXRlcycsXG4gIGdlbmVyYXRlRnNTdGF0aWNSb3V0ZXMgPSAnTmV4dE5vZGVTZXJ2ZXIuZ2VuZXJhdGVGc1N0YXRpY1JvdXRlcycsXG4gIGdlbmVyYXRlUHVibGljUm91dGVzID0gJ05leHROb2RlU2VydmVyLmdlbmVyYXRlUHVibGljUm91dGVzJyxcbiAgZ2VuZXJhdGVJbWFnZVJvdXRlcyA9ICdOZXh0Tm9kZVNlcnZlci5nZW5lcmF0ZUltYWdlUm91dGVzLnJvdXRlJyxcbiAgc2VuZFJlbmRlclJlc3VsdCA9ICdOZXh0Tm9kZVNlcnZlci5zZW5kUmVuZGVyUmVzdWx0JyxcbiAgcHJveHlSZXF1ZXN0ID0gJ05leHROb2RlU2VydmVyLnByb3h5UmVxdWVzdCcsXG4gIHJ1bkFwaSA9ICdOZXh0Tm9kZVNlcnZlci5ydW5BcGknLFxuICByZW5kZXIgPSAnTmV4dE5vZGVTZXJ2ZXIucmVuZGVyJyxcbiAgcmVuZGVySFRNTCA9ICdOZXh0Tm9kZVNlcnZlci5yZW5kZXJIVE1MJyxcbiAgaW1hZ2VPcHRpbWl6ZXIgPSAnTmV4dE5vZGVTZXJ2ZXIuaW1hZ2VPcHRpbWl6ZXInLFxuICBnZXRQYWdlUGF0aCA9ICdOZXh0Tm9kZVNlcnZlci5nZXRQYWdlUGF0aCcsXG4gIGdldFJvdXRlc01hbmlmZXN0ID0gJ05leHROb2RlU2VydmVyLmdldFJvdXRlc01hbmlmZXN0JyxcbiAgZmluZFBhZ2VDb21wb25lbnRzID0gJ05leHROb2RlU2VydmVyLmZpbmRQYWdlQ29tcG9uZW50cycsXG4gIGdldEZvbnRNYW5pZmVzdCA9ICdOZXh0Tm9kZVNlcnZlci5nZXRGb250TWFuaWZlc3QnLFxuICBnZXRTZXJ2ZXJDb21wb25lbnRNYW5pZmVzdCA9ICdOZXh0Tm9kZVNlcnZlci5nZXRTZXJ2ZXJDb21wb25lbnRNYW5pZmVzdCcsXG4gIGdldFJlcXVlc3RIYW5kbGVyID0gJ05leHROb2RlU2VydmVyLmdldFJlcXVlc3RIYW5kbGVyJyxcbiAgcmVuZGVyVG9IVE1MID0gJ05leHROb2RlU2VydmVyLnJlbmRlclRvSFRNTCcsXG4gIHJlbmRlckVycm9yID0gJ05leHROb2RlU2VydmVyLnJlbmRlckVycm9yJyxcbiAgcmVuZGVyRXJyb3JUb0hUTUwgPSAnTmV4dE5vZGVTZXJ2ZXIucmVuZGVyRXJyb3JUb0hUTUwnLFxuICByZW5kZXI0MDQgPSAnTmV4dE5vZGVTZXJ2ZXIucmVuZGVyNDA0JyxcbiAgc3RhcnRSZXNwb25zZSA9ICdOZXh0Tm9kZVNlcnZlci5zdGFydFJlc3BvbnNlJyxcblxuICAvLyBuZXN0ZWQgaW5uZXIgc3BhbiwgZG9lcyBub3QgcmVxdWlyZSBwYXJlbnQgc2NvcGUgbmFtZVxuICByb3V0ZSA9ICdyb3V0ZScsXG4gIG9uUHJveHlSZXEgPSAnb25Qcm94eVJlcScsXG4gIGFwaVJlc29sdmVyID0gJ2FwaVJlc29sdmVyJyxcbiAgaW50ZXJuYWxGZXRjaCA9ICdpbnRlcm5hbEZldGNoJyxcbn1cblxuZW51bSBTdGFydFNlcnZlclNwYW4ge1xuICBzdGFydFNlcnZlciA9ICdzdGFydFNlcnZlci5zdGFydFNlcnZlcicsXG59XG5cbmVudW0gUmVuZGVyU3BhbiB7XG4gIGdldFNlcnZlclNpZGVQcm9wcyA9ICdSZW5kZXIuZ2V0U2VydmVyU2lkZVByb3BzJyxcbiAgZ2V0U3RhdGljUHJvcHMgPSAnUmVuZGVyLmdldFN0YXRpY1Byb3BzJyxcbiAgcmVuZGVyVG9TdHJpbmcgPSAnUmVuZGVyLnJlbmRlclRvU3RyaW5nJyxcbiAgcmVuZGVyRG9jdW1lbnQgPSAnUmVuZGVyLnJlbmRlckRvY3VtZW50JyxcbiAgY3JlYXRlQm9keVJlc3VsdCA9ICdSZW5kZXIuY3JlYXRlQm9keVJlc3VsdCcsXG59XG5cbmVudW0gQXBwUmVuZGVyU3BhbiB7XG4gIHJlbmRlclRvU3RyaW5nID0gJ0FwcFJlbmRlci5yZW5kZXJUb1N0cmluZycsXG4gIHJlbmRlclRvUmVhZGFibGVTdHJlYW0gPSAnQXBwUmVuZGVyLnJlbmRlclRvUmVhZGFibGVTdHJlYW0nLFxuICBnZXRCb2R5UmVzdWx0ID0gJ0FwcFJlbmRlci5nZXRCb2R5UmVzdWx0JyxcbiAgZmV0Y2ggPSAnQXBwUmVuZGVyLmZldGNoJyxcbn1cblxuZW51bSBSb3V0ZXJTcGFuIHtcbiAgZXhlY3V0ZVJvdXRlID0gJ1JvdXRlci5leGVjdXRlUm91dGUnLFxufVxuXG5lbnVtIE5vZGVTcGFuIHtcbiAgcnVuSGFuZGxlciA9ICdOb2RlLnJ1bkhhbmRsZXInLFxufVxuXG5lbnVtIEFwcFJvdXRlUm91dGVIYW5kbGVyc1NwYW4ge1xuICBydW5IYW5kbGVyID0gJ0FwcFJvdXRlUm91dGVIYW5kbGVycy5ydW5IYW5kbGVyJyxcbn1cblxuZW51bSBSZXNvbHZlTWV0YWRhdGFTcGFuIHtcbiAgZ2VuZXJhdGVNZXRhZGF0YSA9ICdSZXNvbHZlTWV0YWRhdGEuZ2VuZXJhdGVNZXRhZGF0YScsXG4gIGdlbmVyYXRlVmlld3BvcnQgPSAnUmVzb2x2ZU1ldGFkYXRhLmdlbmVyYXRlVmlld3BvcnQnLFxufVxuXG5lbnVtIE1pZGRsZXdhcmVTcGFuIHtcbiAgZXhlY3V0ZSA9ICdNaWRkbGV3YXJlLmV4ZWN1dGUnLFxufVxuXG50eXBlIFNwYW5UeXBlcyA9XG4gIHwgYCR7QmFzZVNlcnZlclNwYW59YFxuICB8IGAke0xvYWRDb21wb25lbnRzU3Bhbn1gXG4gIHwgYCR7TmV4dFNlcnZlclNwYW59YFxuICB8IGAke1N0YXJ0U2VydmVyU3Bhbn1gXG4gIHwgYCR7TmV4dE5vZGVTZXJ2ZXJTcGFufWBcbiAgfCBgJHtSZW5kZXJTcGFufWBcbiAgfCBgJHtSb3V0ZXJTcGFufWBcbiAgfCBgJHtBcHBSZW5kZXJTcGFufWBcbiAgfCBgJHtOb2RlU3Bhbn1gXG4gIHwgYCR7QXBwUm91dGVSb3V0ZUhhbmRsZXJzU3Bhbn1gXG4gIHwgYCR7UmVzb2x2ZU1ldGFkYXRhU3Bhbn1gXG4gIHwgYCR7TWlkZGxld2FyZVNwYW59YFxuXG4vLyBUaGlzIGxpc3QgaXMgdXNlZCB0byBmaWx0ZXIgb3V0IHNwYW5zIHRoYXQgYXJlIG5vdCByZWxldmFudCB0byB0aGUgdXNlclxuZXhwb3J0IGNvbnN0IE5leHRWYW5pbGxhU3BhbkFsbG93bGlzdCA9IFtcbiAgTWlkZGxld2FyZVNwYW4uZXhlY3V0ZSxcbiAgQmFzZVNlcnZlclNwYW4uaGFuZGxlUmVxdWVzdCxcbiAgUmVuZGVyU3Bhbi5nZXRTZXJ2ZXJTaWRlUHJvcHMsXG4gIFJlbmRlclNwYW4uZ2V0U3RhdGljUHJvcHMsXG4gIEFwcFJlbmRlclNwYW4uZmV0Y2gsXG4gIEFwcFJlbmRlclNwYW4uZ2V0Qm9keVJlc3VsdCxcbiAgUmVuZGVyU3Bhbi5yZW5kZXJEb2N1bWVudCxcbiAgTm9kZVNwYW4ucnVuSGFuZGxlcixcbiAgQXBwUm91dGVSb3V0ZUhhbmRsZXJzU3Bhbi5ydW5IYW5kbGVyLFxuICBSZXNvbHZlTWV0YWRhdGFTcGFuLmdlbmVyYXRlTWV0YWRhdGEsXG4gIFJlc29sdmVNZXRhZGF0YVNwYW4uZ2VuZXJhdGVWaWV3cG9ydCxcbiAgTmV4dE5vZGVTZXJ2ZXJTcGFuLmNyZWF0ZUNvbXBvbmVudFRyZWUsXG4gIE5leHROb2RlU2VydmVyU3Bhbi5maW5kUGFnZUNvbXBvbmVudHMsXG4gIE5leHROb2RlU2VydmVyU3Bhbi5nZXRMYXlvdXRPclBhZ2VNb2R1bGUsXG4gIE5leHROb2RlU2VydmVyU3Bhbi5zdGFydFJlc3BvbnNlLFxuICBOZXh0Tm9kZVNlcnZlclNwYW4uY2xpZW50Q29tcG9uZW50TG9hZGluZyxcbl1cblxuLy8gVGhlc2UgU3BhbnMgYXJlIGFsbG93ZWQgdG8gYmUgYWx3YXlzIGxvZ2dlZFxuLy8gd2hlbiB0aGUgb3RlbCBsb2cgcHJlZml4IGVudiBpcyBzZXRcbmV4cG9ydCBjb25zdCBMb2dTcGFuQWxsb3dMaXN0ID0gW1xuICBOZXh0Tm9kZVNlcnZlclNwYW4uZmluZFBhZ2VDb21wb25lbnRzLFxuICBOZXh0Tm9kZVNlcnZlclNwYW4uY3JlYXRlQ29tcG9uZW50VHJlZSxcbiAgTmV4dE5vZGVTZXJ2ZXJTcGFuLmNsaWVudENvbXBvbmVudExvYWRpbmcsXG5dXG5cbmV4cG9ydCB7XG4gIEJhc2VTZXJ2ZXJTcGFuLFxuICBMb2FkQ29tcG9uZW50c1NwYW4sXG4gIE5leHRTZXJ2ZXJTcGFuLFxuICBOZXh0Tm9kZVNlcnZlclNwYW4sXG4gIFN0YXJ0U2VydmVyU3BhbixcbiAgUmVuZGVyU3BhbixcbiAgUm91dGVyU3BhbixcbiAgQXBwUmVuZGVyU3BhbixcbiAgTm9kZVNwYW4sXG4gIEFwcFJvdXRlUm91dGVIYW5kbGVyc1NwYW4sXG4gIFJlc29sdmVNZXRhZGF0YVNwYW4sXG4gIE1pZGRsZXdhcmVTcGFuLFxufVxuXG5leHBvcnQgdHlwZSB7IFNwYW5UeXBlcyB9XG4iXSwibmFtZXMiOlsiQmFzZVNlcnZlclNwYW4iLCJMb2FkQ29tcG9uZW50c1NwYW4iLCJOZXh0U2VydmVyU3BhbiIsIk5leHROb2RlU2VydmVyU3BhbiIsIlN0YXJ0U2VydmVyU3BhbiIsIlJlbmRlclNwYW4iLCJBcHBSZW5kZXJTcGFuIiwiUm91dGVyU3BhbiIsIk5vZGVTcGFuIiwiQXBwUm91dGVSb3V0ZUhhbmRsZXJzU3BhbiIsIlJlc29sdmVNZXRhZGF0YVNwYW4iLCJNaWRkbGV3YXJlU3BhbiIsIk5leHRWYW5pbGxhU3BhbkFsbG93bGlzdCIsIkxvZ1NwYW5BbGxvd0xpc3QiXSwibWFwcGluZ3MiOiJBQUFBOzs7OztFQUtFLEdBRUYsNENBQTRDO0FBQzVDLDRCQUE0Qjs7Ozs7Ozs7Ozs7Ozs7OztBQUU1QixJQUFLQSxpQkFBQUEsV0FBQUEsR0FBQUEsU0FBQUEsY0FBQUE7Ozs7Ozs7Ozs7Ozs7V0FBQUE7RUFBQUEsa0JBQUFBLENBQUFBO0FBZUwsSUFBS0MscUJBQUFBLFdBQUFBLEdBQUFBLFNBQUFBLGtCQUFBQTs7O1dBQUFBO0VBQUFBLHNCQUFBQSxDQUFBQTtBQUtMLElBQUtDLGlCQUFBQSxXQUFBQSxHQUFBQSxTQUFBQSxjQUFBQTs7Ozs7V0FBQUE7RUFBQUEsa0JBQUFBLENBQUFBO0FBT0wsSUFBS0MscUJBQUFBLFdBQUFBLEdBQUFBLFNBQUFBLGtCQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBNEJILHdEQUF3RDs7Ozs7V0E1QnJEQTtFQUFBQSxzQkFBQUEsQ0FBQUE7QUFtQ0wsSUFBS0Msa0JBQUFBLFdBQUFBLEdBQUFBLFNBQUFBLGVBQUFBOztXQUFBQTtFQUFBQSxtQkFBQUEsQ0FBQUE7QUFJTCxJQUFLQyxhQUFBQSxXQUFBQSxHQUFBQSxTQUFBQSxVQUFBQTs7Ozs7O1dBQUFBO0VBQUFBLGNBQUFBLENBQUFBO0FBUUwsSUFBS0MsZ0JBQUFBLFdBQUFBLEdBQUFBLFNBQUFBLGFBQUFBOzs7OztXQUFBQTtFQUFBQSxpQkFBQUEsQ0FBQUE7QUFPTCxJQUFLQyxhQUFBQSxXQUFBQSxHQUFBQSxTQUFBQSxVQUFBQTs7V0FBQUE7RUFBQUEsY0FBQUEsQ0FBQUE7QUFJTCxJQUFLQyxXQUFBQSxXQUFBQSxHQUFBQSxTQUFBQSxRQUFBQTs7V0FBQUE7RUFBQUEsWUFBQUEsQ0FBQUE7QUFJTCxJQUFLQyw0QkFBQUEsV0FBQUEsR0FBQUEsU0FBQUEseUJBQUFBOztXQUFBQTtFQUFBQSw2QkFBQUEsQ0FBQUE7QUFJTCxJQUFLQyxzQkFBQUEsV0FBQUEsR0FBQUEsU0FBQUEsbUJBQUFBOzs7V0FBQUE7RUFBQUEsdUJBQUFBLENBQUFBO0FBS0wsSUFBS0MsaUJBQUFBLFdBQUFBLEdBQUFBLFNBQUFBLGNBQUFBOztXQUFBQTtFQUFBQSxrQkFBQUEsQ0FBQUE7QUFtQkUsTUFBTUMsMkJBQTJCOzs7Ozs7Ozs7Ozs7Ozs7OztDQWlCdkMsQ0FBQTtBQUlNLE1BQU1DLG1CQUFtQjs7OztDQUkvQixDQUFBIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDQyNzQsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NyYy9zaGFyZWQvbGliL2lzLXRoZW5hYmxlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ2hlY2sgdG8gc2VlIGlmIGEgdmFsdWUgaXMgVGhlbmFibGUuXG4gKlxuICogQHBhcmFtIHByb21pc2UgdGhlIG1heWJlLXRoZW5hYmxlIHZhbHVlXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZSBpcyB0aGVuYWJsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNUaGVuYWJsZTxUID0gdW5rbm93bj4oXG4gIHByb21pc2U6IFByb21pc2U8VD4gfCBUXG4pOiBwcm9taXNlIGlzIFByb21pc2U8VD4ge1xuICByZXR1cm4gKFxuICAgIHByb21pc2UgIT09IG51bGwgJiZcbiAgICB0eXBlb2YgcHJvbWlzZSA9PT0gJ29iamVjdCcgJiZcbiAgICAndGhlbicgaW4gcHJvbWlzZSAmJlxuICAgIHR5cGVvZiBwcm9taXNlLnRoZW4gPT09ICdmdW5jdGlvbidcbiAgKVxufVxuIl0sIm5hbWVzIjpbImlzVGhlbmFibGUiLCJwcm9taXNlIiwidGhlbiJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7O0NBS0MsR0FDRDs7O0FBQU8sU0FBU0EsV0FDZEMsT0FBdUI7SUFFdkIsT0FDRUEsWUFBWSxRQUNaLE9BQU9BLFlBQVksWUFDbkIsVUFBVUEsV0FDVixPQUFPQSxRQUFRQyxJQUFJLEtBQUs7QUFFNUIiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNDI5MCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvJTQwb3BlbnRlbGVtZXRyeS9hcGkvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIGU9ezQ5MTooZSx0LHIpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTt0LkNvbnRleHRBUEk9dm9pZCAwO2NvbnN0IG49cigyMjMpO2NvbnN0IGE9cigxNzIpO2NvbnN0IG89cig5MzApO2NvbnN0IGk9XCJjb250ZXh0XCI7Y29uc3QgYz1uZXcgbi5Ob29wQ29udGV4dE1hbmFnZXI7Y2xhc3MgQ29udGV4dEFQSXtjb25zdHJ1Y3Rvcigpe31zdGF0aWMgZ2V0SW5zdGFuY2UoKXtpZighdGhpcy5faW5zdGFuY2Upe3RoaXMuX2luc3RhbmNlPW5ldyBDb250ZXh0QVBJfXJldHVybiB0aGlzLl9pbnN0YW5jZX1zZXRHbG9iYWxDb250ZXh0TWFuYWdlcihlKXtyZXR1cm4oMCxhLnJlZ2lzdGVyR2xvYmFsKShpLGUsby5EaWFnQVBJLmluc3RhbmNlKCkpfWFjdGl2ZSgpe3JldHVybiB0aGlzLl9nZXRDb250ZXh0TWFuYWdlcigpLmFjdGl2ZSgpfXdpdGgoZSx0LHIsLi4ubil7cmV0dXJuIHRoaXMuX2dldENvbnRleHRNYW5hZ2VyKCkud2l0aChlLHQsciwuLi5uKX1iaW5kKGUsdCl7cmV0dXJuIHRoaXMuX2dldENvbnRleHRNYW5hZ2VyKCkuYmluZChlLHQpfV9nZXRDb250ZXh0TWFuYWdlcigpe3JldHVybigwLGEuZ2V0R2xvYmFsKShpKXx8Y31kaXNhYmxlKCl7dGhpcy5fZ2V0Q29udGV4dE1hbmFnZXIoKS5kaXNhYmxlKCk7KDAsYS51bnJlZ2lzdGVyR2xvYmFsKShpLG8uRGlhZ0FQSS5pbnN0YW5jZSgpKX19dC5Db250ZXh0QVBJPUNvbnRleHRBUEl9LDkzMDooZSx0LHIpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTt0LkRpYWdBUEk9dm9pZCAwO2NvbnN0IG49cig1Nik7Y29uc3QgYT1yKDkxMik7Y29uc3Qgbz1yKDk1Nyk7Y29uc3QgaT1yKDE3Mik7Y29uc3QgYz1cImRpYWdcIjtjbGFzcyBEaWFnQVBJe2NvbnN0cnVjdG9yKCl7ZnVuY3Rpb24gX2xvZ1Byb3h5KGUpe3JldHVybiBmdW5jdGlvbiguLi50KXtjb25zdCByPSgwLGkuZ2V0R2xvYmFsKShcImRpYWdcIik7aWYoIXIpcmV0dXJuO3JldHVybiByW2VdKC4uLnQpfX1jb25zdCBlPXRoaXM7Y29uc3Qgc2V0TG9nZ2VyPSh0LHI9e2xvZ0xldmVsOm8uRGlhZ0xvZ0xldmVsLklORk99KT0+e3ZhciBuLGMscztpZih0PT09ZSl7Y29uc3QgdD1uZXcgRXJyb3IoXCJDYW5ub3QgdXNlIGRpYWcgYXMgdGhlIGxvZ2dlciBmb3IgaXRzZWxmLiBQbGVhc2UgdXNlIGEgRGlhZ0xvZ2dlciBpbXBsZW1lbnRhdGlvbiBsaWtlIENvbnNvbGVEaWFnTG9nZ2VyIG9yIGEgY3VzdG9tIGltcGxlbWVudGF0aW9uXCIpO2UuZXJyb3IoKG49dC5zdGFjaykhPT1udWxsJiZuIT09dm9pZCAwP246dC5tZXNzYWdlKTtyZXR1cm4gZmFsc2V9aWYodHlwZW9mIHI9PT1cIm51bWJlclwiKXtyPXtsb2dMZXZlbDpyfX1jb25zdCB1PSgwLGkuZ2V0R2xvYmFsKShcImRpYWdcIik7Y29uc3QgbD0oMCxhLmNyZWF0ZUxvZ0xldmVsRGlhZ0xvZ2dlcikoKGM9ci5sb2dMZXZlbCkhPT1udWxsJiZjIT09dm9pZCAwP2M6by5EaWFnTG9nTGV2ZWwuSU5GTyx0KTtpZih1JiYhci5zdXBwcmVzc092ZXJyaWRlTWVzc2FnZSl7Y29uc3QgZT0ocz0obmV3IEVycm9yKS5zdGFjaykhPT1udWxsJiZzIT09dm9pZCAwP3M6XCI8ZmFpbGVkIHRvIGdlbmVyYXRlIHN0YWNrdHJhY2U+XCI7dS53YXJuKGBDdXJyZW50IGxvZ2dlciB3aWxsIGJlIG92ZXJ3cml0dGVuIGZyb20gJHtlfWApO2wud2FybihgQ3VycmVudCBsb2dnZXIgd2lsbCBvdmVyd3JpdGUgb25lIGFscmVhZHkgcmVnaXN0ZXJlZCBmcm9tICR7ZX1gKX1yZXR1cm4oMCxpLnJlZ2lzdGVyR2xvYmFsKShcImRpYWdcIixsLGUsdHJ1ZSl9O2Uuc2V0TG9nZ2VyPXNldExvZ2dlcjtlLmRpc2FibGU9KCk9PnsoMCxpLnVucmVnaXN0ZXJHbG9iYWwpKGMsZSl9O2UuY3JlYXRlQ29tcG9uZW50TG9nZ2VyPWU9Pm5ldyBuLkRpYWdDb21wb25lbnRMb2dnZXIoZSk7ZS52ZXJib3NlPV9sb2dQcm94eShcInZlcmJvc2VcIik7ZS5kZWJ1Zz1fbG9nUHJveHkoXCJkZWJ1Z1wiKTtlLmluZm89X2xvZ1Byb3h5KFwiaW5mb1wiKTtlLndhcm49X2xvZ1Byb3h5KFwid2FyblwiKTtlLmVycm9yPV9sb2dQcm94eShcImVycm9yXCIpfXN0YXRpYyBpbnN0YW5jZSgpe2lmKCF0aGlzLl9pbnN0YW5jZSl7dGhpcy5faW5zdGFuY2U9bmV3IERpYWdBUEl9cmV0dXJuIHRoaXMuX2luc3RhbmNlfX10LkRpYWdBUEk9RGlhZ0FQSX0sNjUzOihlLHQscik9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO3QuTWV0cmljc0FQST12b2lkIDA7Y29uc3Qgbj1yKDY2MCk7Y29uc3QgYT1yKDE3Mik7Y29uc3Qgbz1yKDkzMCk7Y29uc3QgaT1cIm1ldHJpY3NcIjtjbGFzcyBNZXRyaWNzQVBJe2NvbnN0cnVjdG9yKCl7fXN0YXRpYyBnZXRJbnN0YW5jZSgpe2lmKCF0aGlzLl9pbnN0YW5jZSl7dGhpcy5faW5zdGFuY2U9bmV3IE1ldHJpY3NBUEl9cmV0dXJuIHRoaXMuX2luc3RhbmNlfXNldEdsb2JhbE1ldGVyUHJvdmlkZXIoZSl7cmV0dXJuKDAsYS5yZWdpc3Rlckdsb2JhbCkoaSxlLG8uRGlhZ0FQSS5pbnN0YW5jZSgpKX1nZXRNZXRlclByb3ZpZGVyKCl7cmV0dXJuKDAsYS5nZXRHbG9iYWwpKGkpfHxuLk5PT1BfTUVURVJfUFJPVklERVJ9Z2V0TWV0ZXIoZSx0LHIpe3JldHVybiB0aGlzLmdldE1ldGVyUHJvdmlkZXIoKS5nZXRNZXRlcihlLHQscil9ZGlzYWJsZSgpeygwLGEudW5yZWdpc3Rlckdsb2JhbCkoaSxvLkRpYWdBUEkuaW5zdGFuY2UoKSl9fXQuTWV0cmljc0FQST1NZXRyaWNzQVBJfSwxODE6KGUsdCxyKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dC5Qcm9wYWdhdGlvbkFQST12b2lkIDA7Y29uc3Qgbj1yKDE3Mik7Y29uc3QgYT1yKDg3NCk7Y29uc3Qgbz1yKDE5NCk7Y29uc3QgaT1yKDI3Nyk7Y29uc3QgYz1yKDM2OSk7Y29uc3Qgcz1yKDkzMCk7Y29uc3QgdT1cInByb3BhZ2F0aW9uXCI7Y29uc3QgbD1uZXcgYS5Ob29wVGV4dE1hcFByb3BhZ2F0b3I7Y2xhc3MgUHJvcGFnYXRpb25BUEl7Y29uc3RydWN0b3IoKXt0aGlzLmNyZWF0ZUJhZ2dhZ2U9Yy5jcmVhdGVCYWdnYWdlO3RoaXMuZ2V0QmFnZ2FnZT1pLmdldEJhZ2dhZ2U7dGhpcy5nZXRBY3RpdmVCYWdnYWdlPWkuZ2V0QWN0aXZlQmFnZ2FnZTt0aGlzLnNldEJhZ2dhZ2U9aS5zZXRCYWdnYWdlO3RoaXMuZGVsZXRlQmFnZ2FnZT1pLmRlbGV0ZUJhZ2dhZ2V9c3RhdGljIGdldEluc3RhbmNlKCl7aWYoIXRoaXMuX2luc3RhbmNlKXt0aGlzLl9pbnN0YW5jZT1uZXcgUHJvcGFnYXRpb25BUEl9cmV0dXJuIHRoaXMuX2luc3RhbmNlfXNldEdsb2JhbFByb3BhZ2F0b3IoZSl7cmV0dXJuKDAsbi5yZWdpc3Rlckdsb2JhbCkodSxlLHMuRGlhZ0FQSS5pbnN0YW5jZSgpKX1pbmplY3QoZSx0LHI9by5kZWZhdWx0VGV4dE1hcFNldHRlcil7cmV0dXJuIHRoaXMuX2dldEdsb2JhbFByb3BhZ2F0b3IoKS5pbmplY3QoZSx0LHIpfWV4dHJhY3QoZSx0LHI9by5kZWZhdWx0VGV4dE1hcEdldHRlcil7cmV0dXJuIHRoaXMuX2dldEdsb2JhbFByb3BhZ2F0b3IoKS5leHRyYWN0KGUsdCxyKX1maWVsZHMoKXtyZXR1cm4gdGhpcy5fZ2V0R2xvYmFsUHJvcGFnYXRvcigpLmZpZWxkcygpfWRpc2FibGUoKXsoMCxuLnVucmVnaXN0ZXJHbG9iYWwpKHUscy5EaWFnQVBJLmluc3RhbmNlKCkpfV9nZXRHbG9iYWxQcm9wYWdhdG9yKCl7cmV0dXJuKDAsbi5nZXRHbG9iYWwpKHUpfHxsfX10LlByb3BhZ2F0aW9uQVBJPVByb3BhZ2F0aW9uQVBJfSw5OTc6KGUsdCxyKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dC5UcmFjZUFQST12b2lkIDA7Y29uc3Qgbj1yKDE3Mik7Y29uc3QgYT1yKDg0Nik7Y29uc3Qgbz1yKDEzOSk7Y29uc3QgaT1yKDYwNyk7Y29uc3QgYz1yKDkzMCk7Y29uc3Qgcz1cInRyYWNlXCI7Y2xhc3MgVHJhY2VBUEl7Y29uc3RydWN0b3IoKXt0aGlzLl9wcm94eVRyYWNlclByb3ZpZGVyPW5ldyBhLlByb3h5VHJhY2VyUHJvdmlkZXI7dGhpcy53cmFwU3BhbkNvbnRleHQ9by53cmFwU3BhbkNvbnRleHQ7dGhpcy5pc1NwYW5Db250ZXh0VmFsaWQ9by5pc1NwYW5Db250ZXh0VmFsaWQ7dGhpcy5kZWxldGVTcGFuPWkuZGVsZXRlU3Bhbjt0aGlzLmdldFNwYW49aS5nZXRTcGFuO3RoaXMuZ2V0QWN0aXZlU3Bhbj1pLmdldEFjdGl2ZVNwYW47dGhpcy5nZXRTcGFuQ29udGV4dD1pLmdldFNwYW5Db250ZXh0O3RoaXMuc2V0U3Bhbj1pLnNldFNwYW47dGhpcy5zZXRTcGFuQ29udGV4dD1pLnNldFNwYW5Db250ZXh0fXN0YXRpYyBnZXRJbnN0YW5jZSgpe2lmKCF0aGlzLl9pbnN0YW5jZSl7dGhpcy5faW5zdGFuY2U9bmV3IFRyYWNlQVBJfXJldHVybiB0aGlzLl9pbnN0YW5jZX1zZXRHbG9iYWxUcmFjZXJQcm92aWRlcihlKXtjb25zdCB0PSgwLG4ucmVnaXN0ZXJHbG9iYWwpKHMsdGhpcy5fcHJveHlUcmFjZXJQcm92aWRlcixjLkRpYWdBUEkuaW5zdGFuY2UoKSk7aWYodCl7dGhpcy5fcHJveHlUcmFjZXJQcm92aWRlci5zZXREZWxlZ2F0ZShlKX1yZXR1cm4gdH1nZXRUcmFjZXJQcm92aWRlcigpe3JldHVybigwLG4uZ2V0R2xvYmFsKShzKXx8dGhpcy5fcHJveHlUcmFjZXJQcm92aWRlcn1nZXRUcmFjZXIoZSx0KXtyZXR1cm4gdGhpcy5nZXRUcmFjZXJQcm92aWRlcigpLmdldFRyYWNlcihlLHQpfWRpc2FibGUoKXsoMCxuLnVucmVnaXN0ZXJHbG9iYWwpKHMsYy5EaWFnQVBJLmluc3RhbmNlKCkpO3RoaXMuX3Byb3h5VHJhY2VyUHJvdmlkZXI9bmV3IGEuUHJveHlUcmFjZXJQcm92aWRlcn19dC5UcmFjZUFQST1UcmFjZUFQSX0sMjc3OihlLHQscik9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO3QuZGVsZXRlQmFnZ2FnZT10LnNldEJhZ2dhZ2U9dC5nZXRBY3RpdmVCYWdnYWdlPXQuZ2V0QmFnZ2FnZT12b2lkIDA7Y29uc3Qgbj1yKDQ5MSk7Y29uc3QgYT1yKDc4MCk7Y29uc3Qgbz0oMCxhLmNyZWF0ZUNvbnRleHRLZXkpKFwiT3BlblRlbGVtZXRyeSBCYWdnYWdlIEtleVwiKTtmdW5jdGlvbiBnZXRCYWdnYWdlKGUpe3JldHVybiBlLmdldFZhbHVlKG8pfHx1bmRlZmluZWR9dC5nZXRCYWdnYWdlPWdldEJhZ2dhZ2U7ZnVuY3Rpb24gZ2V0QWN0aXZlQmFnZ2FnZSgpe3JldHVybiBnZXRCYWdnYWdlKG4uQ29udGV4dEFQSS5nZXRJbnN0YW5jZSgpLmFjdGl2ZSgpKX10LmdldEFjdGl2ZUJhZ2dhZ2U9Z2V0QWN0aXZlQmFnZ2FnZTtmdW5jdGlvbiBzZXRCYWdnYWdlKGUsdCl7cmV0dXJuIGUuc2V0VmFsdWUobyx0KX10LnNldEJhZ2dhZ2U9c2V0QmFnZ2FnZTtmdW5jdGlvbiBkZWxldGVCYWdnYWdlKGUpe3JldHVybiBlLmRlbGV0ZVZhbHVlKG8pfXQuZGVsZXRlQmFnZ2FnZT1kZWxldGVCYWdnYWdlfSw5OTM6KGUsdCk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO3QuQmFnZ2FnZUltcGw9dm9pZCAwO2NsYXNzIEJhZ2dhZ2VJbXBse2NvbnN0cnVjdG9yKGUpe3RoaXMuX2VudHJpZXM9ZT9uZXcgTWFwKGUpOm5ldyBNYXB9Z2V0RW50cnkoZSl7Y29uc3QgdD10aGlzLl9lbnRyaWVzLmdldChlKTtpZighdCl7cmV0dXJuIHVuZGVmaW5lZH1yZXR1cm4gT2JqZWN0LmFzc2lnbih7fSx0KX1nZXRBbGxFbnRyaWVzKCl7cmV0dXJuIEFycmF5LmZyb20odGhpcy5fZW50cmllcy5lbnRyaWVzKCkpLm1hcCgoKFtlLHRdKT0+W2UsdF0pKX1zZXRFbnRyeShlLHQpe2NvbnN0IHI9bmV3IEJhZ2dhZ2VJbXBsKHRoaXMuX2VudHJpZXMpO3IuX2VudHJpZXMuc2V0KGUsdCk7cmV0dXJuIHJ9cmVtb3ZlRW50cnkoZSl7Y29uc3QgdD1uZXcgQmFnZ2FnZUltcGwodGhpcy5fZW50cmllcyk7dC5fZW50cmllcy5kZWxldGUoZSk7cmV0dXJuIHR9cmVtb3ZlRW50cmllcyguLi5lKXtjb25zdCB0PW5ldyBCYWdnYWdlSW1wbCh0aGlzLl9lbnRyaWVzKTtmb3IoY29uc3QgciBvZiBlKXt0Ll9lbnRyaWVzLmRlbGV0ZShyKX1yZXR1cm4gdH1jbGVhcigpe3JldHVybiBuZXcgQmFnZ2FnZUltcGx9fXQuQmFnZ2FnZUltcGw9QmFnZ2FnZUltcGx9LDgzMDooZSx0KT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dC5iYWdnYWdlRW50cnlNZXRhZGF0YVN5bWJvbD12b2lkIDA7dC5iYWdnYWdlRW50cnlNZXRhZGF0YVN5bWJvbD1TeW1ib2woXCJCYWdnYWdlRW50cnlNZXRhZGF0YVwiKX0sMzY5OihlLHQscik9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO3QuYmFnZ2FnZUVudHJ5TWV0YWRhdGFGcm9tU3RyaW5nPXQuY3JlYXRlQmFnZ2FnZT12b2lkIDA7Y29uc3Qgbj1yKDkzMCk7Y29uc3QgYT1yKDk5Myk7Y29uc3Qgbz1yKDgzMCk7Y29uc3QgaT1uLkRpYWdBUEkuaW5zdGFuY2UoKTtmdW5jdGlvbiBjcmVhdGVCYWdnYWdlKGU9e30pe3JldHVybiBuZXcgYS5CYWdnYWdlSW1wbChuZXcgTWFwKE9iamVjdC5lbnRyaWVzKGUpKSl9dC5jcmVhdGVCYWdnYWdlPWNyZWF0ZUJhZ2dhZ2U7ZnVuY3Rpb24gYmFnZ2FnZUVudHJ5TWV0YWRhdGFGcm9tU3RyaW5nKGUpe2lmKHR5cGVvZiBlIT09XCJzdHJpbmdcIil7aS5lcnJvcihgQ2Fubm90IGNyZWF0ZSBiYWdnYWdlIG1ldGFkYXRhIGZyb20gdW5rbm93biB0eXBlOiAke3R5cGVvZiBlfWApO2U9XCJcIn1yZXR1cm57X19UWVBFX186by5iYWdnYWdlRW50cnlNZXRhZGF0YVN5bWJvbCx0b1N0cmluZygpe3JldHVybiBlfX19dC5iYWdnYWdlRW50cnlNZXRhZGF0YUZyb21TdHJpbmc9YmFnZ2FnZUVudHJ5TWV0YWRhdGFGcm9tU3RyaW5nfSw2NzooZSx0LHIpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTt0LmNvbnRleHQ9dm9pZCAwO2NvbnN0IG49cig0OTEpO3QuY29udGV4dD1uLkNvbnRleHRBUEkuZ2V0SW5zdGFuY2UoKX0sMjIzOihlLHQscik9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO3QuTm9vcENvbnRleHRNYW5hZ2VyPXZvaWQgMDtjb25zdCBuPXIoNzgwKTtjbGFzcyBOb29wQ29udGV4dE1hbmFnZXJ7YWN0aXZlKCl7cmV0dXJuIG4uUk9PVF9DT05URVhUfXdpdGgoZSx0LHIsLi4ubil7cmV0dXJuIHQuY2FsbChyLC4uLm4pfWJpbmQoZSx0KXtyZXR1cm4gdH1lbmFibGUoKXtyZXR1cm4gdGhpc31kaXNhYmxlKCl7cmV0dXJuIHRoaXN9fXQuTm9vcENvbnRleHRNYW5hZ2VyPU5vb3BDb250ZXh0TWFuYWdlcn0sNzgwOihlLHQpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTt0LlJPT1RfQ09OVEVYVD10LmNyZWF0ZUNvbnRleHRLZXk9dm9pZCAwO2Z1bmN0aW9uIGNyZWF0ZUNvbnRleHRLZXkoZSl7cmV0dXJuIFN5bWJvbC5mb3IoZSl9dC5jcmVhdGVDb250ZXh0S2V5PWNyZWF0ZUNvbnRleHRLZXk7Y2xhc3MgQmFzZUNvbnRleHR7Y29uc3RydWN0b3IoZSl7Y29uc3QgdD10aGlzO3QuX2N1cnJlbnRDb250ZXh0PWU/bmV3IE1hcChlKTpuZXcgTWFwO3QuZ2V0VmFsdWU9ZT0+dC5fY3VycmVudENvbnRleHQuZ2V0KGUpO3Quc2V0VmFsdWU9KGUscik9Pntjb25zdCBuPW5ldyBCYXNlQ29udGV4dCh0Ll9jdXJyZW50Q29udGV4dCk7bi5fY3VycmVudENvbnRleHQuc2V0KGUscik7cmV0dXJuIG59O3QuZGVsZXRlVmFsdWU9ZT0+e2NvbnN0IHI9bmV3IEJhc2VDb250ZXh0KHQuX2N1cnJlbnRDb250ZXh0KTtyLl9jdXJyZW50Q29udGV4dC5kZWxldGUoZSk7cmV0dXJuIHJ9fX10LlJPT1RfQ09OVEVYVD1uZXcgQmFzZUNvbnRleHR9LDUwNjooZSx0LHIpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTt0LmRpYWc9dm9pZCAwO2NvbnN0IG49cig5MzApO3QuZGlhZz1uLkRpYWdBUEkuaW5zdGFuY2UoKX0sNTY6KGUsdCxyKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dC5EaWFnQ29tcG9uZW50TG9nZ2VyPXZvaWQgMDtjb25zdCBuPXIoMTcyKTtjbGFzcyBEaWFnQ29tcG9uZW50TG9nZ2Vye2NvbnN0cnVjdG9yKGUpe3RoaXMuX25hbWVzcGFjZT1lLm5hbWVzcGFjZXx8XCJEaWFnQ29tcG9uZW50TG9nZ2VyXCJ9ZGVidWcoLi4uZSl7cmV0dXJuIGxvZ1Byb3h5KFwiZGVidWdcIix0aGlzLl9uYW1lc3BhY2UsZSl9ZXJyb3IoLi4uZSl7cmV0dXJuIGxvZ1Byb3h5KFwiZXJyb3JcIix0aGlzLl9uYW1lc3BhY2UsZSl9aW5mbyguLi5lKXtyZXR1cm4gbG9nUHJveHkoXCJpbmZvXCIsdGhpcy5fbmFtZXNwYWNlLGUpfXdhcm4oLi4uZSl7cmV0dXJuIGxvZ1Byb3h5KFwid2FyblwiLHRoaXMuX25hbWVzcGFjZSxlKX12ZXJib3NlKC4uLmUpe3JldHVybiBsb2dQcm94eShcInZlcmJvc2VcIix0aGlzLl9uYW1lc3BhY2UsZSl9fXQuRGlhZ0NvbXBvbmVudExvZ2dlcj1EaWFnQ29tcG9uZW50TG9nZ2VyO2Z1bmN0aW9uIGxvZ1Byb3h5KGUsdCxyKXtjb25zdCBhPSgwLG4uZ2V0R2xvYmFsKShcImRpYWdcIik7aWYoIWEpe3JldHVybn1yLnVuc2hpZnQodCk7cmV0dXJuIGFbZV0oLi4ucil9fSw5NzI6KGUsdCk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO3QuRGlhZ0NvbnNvbGVMb2dnZXI9dm9pZCAwO2NvbnN0IHI9W3tuOlwiZXJyb3JcIixjOlwiZXJyb3JcIn0se246XCJ3YXJuXCIsYzpcIndhcm5cIn0se246XCJpbmZvXCIsYzpcImluZm9cIn0se246XCJkZWJ1Z1wiLGM6XCJkZWJ1Z1wifSx7bjpcInZlcmJvc2VcIixjOlwidHJhY2VcIn1dO2NsYXNzIERpYWdDb25zb2xlTG9nZ2Vye2NvbnN0cnVjdG9yKCl7ZnVuY3Rpb24gX2NvbnNvbGVGdW5jKGUpe3JldHVybiBmdW5jdGlvbiguLi50KXtpZihjb25zb2xlKXtsZXQgcj1jb25zb2xlW2VdO2lmKHR5cGVvZiByIT09XCJmdW5jdGlvblwiKXtyPWNvbnNvbGUubG9nfWlmKHR5cGVvZiByPT09XCJmdW5jdGlvblwiKXtyZXR1cm4gci5hcHBseShjb25zb2xlLHQpfX19fWZvcihsZXQgZT0wO2U8ci5sZW5ndGg7ZSsrKXt0aGlzW3JbZV0ubl09X2NvbnNvbGVGdW5jKHJbZV0uYyl9fX10LkRpYWdDb25zb2xlTG9nZ2VyPURpYWdDb25zb2xlTG9nZ2VyfSw5MTI6KGUsdCxyKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dC5jcmVhdGVMb2dMZXZlbERpYWdMb2dnZXI9dm9pZCAwO2NvbnN0IG49cig5NTcpO2Z1bmN0aW9uIGNyZWF0ZUxvZ0xldmVsRGlhZ0xvZ2dlcihlLHQpe2lmKGU8bi5EaWFnTG9nTGV2ZWwuTk9ORSl7ZT1uLkRpYWdMb2dMZXZlbC5OT05FfWVsc2UgaWYoZT5uLkRpYWdMb2dMZXZlbC5BTEwpe2U9bi5EaWFnTG9nTGV2ZWwuQUxMfXQ9dHx8e307ZnVuY3Rpb24gX2ZpbHRlckZ1bmMocixuKXtjb25zdCBhPXRbcl07aWYodHlwZW9mIGE9PT1cImZ1bmN0aW9uXCImJmU+PW4pe3JldHVybiBhLmJpbmQodCl9cmV0dXJuIGZ1bmN0aW9uKCl7fX1yZXR1cm57ZXJyb3I6X2ZpbHRlckZ1bmMoXCJlcnJvclwiLG4uRGlhZ0xvZ0xldmVsLkVSUk9SKSx3YXJuOl9maWx0ZXJGdW5jKFwid2FyblwiLG4uRGlhZ0xvZ0xldmVsLldBUk4pLGluZm86X2ZpbHRlckZ1bmMoXCJpbmZvXCIsbi5EaWFnTG9nTGV2ZWwuSU5GTyksZGVidWc6X2ZpbHRlckZ1bmMoXCJkZWJ1Z1wiLG4uRGlhZ0xvZ0xldmVsLkRFQlVHKSx2ZXJib3NlOl9maWx0ZXJGdW5jKFwidmVyYm9zZVwiLG4uRGlhZ0xvZ0xldmVsLlZFUkJPU0UpfX10LmNyZWF0ZUxvZ0xldmVsRGlhZ0xvZ2dlcj1jcmVhdGVMb2dMZXZlbERpYWdMb2dnZXJ9LDk1NzooZSx0KT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dC5EaWFnTG9nTGV2ZWw9dm9pZCAwO3ZhciByOyhmdW5jdGlvbihlKXtlW2VbXCJOT05FXCJdPTBdPVwiTk9ORVwiO2VbZVtcIkVSUk9SXCJdPTMwXT1cIkVSUk9SXCI7ZVtlW1wiV0FSTlwiXT01MF09XCJXQVJOXCI7ZVtlW1wiSU5GT1wiXT02MF09XCJJTkZPXCI7ZVtlW1wiREVCVUdcIl09NzBdPVwiREVCVUdcIjtlW2VbXCJWRVJCT1NFXCJdPTgwXT1cIlZFUkJPU0VcIjtlW2VbXCJBTExcIl09OTk5OV09XCJBTExcIn0pKHI9dC5EaWFnTG9nTGV2ZWx8fCh0LkRpYWdMb2dMZXZlbD17fSkpfSwxNzI6KGUsdCxyKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dC51bnJlZ2lzdGVyR2xvYmFsPXQuZ2V0R2xvYmFsPXQucmVnaXN0ZXJHbG9iYWw9dm9pZCAwO2NvbnN0IG49cigyMDApO2NvbnN0IGE9cig1MjEpO2NvbnN0IG89cigxMzApO2NvbnN0IGk9YS5WRVJTSU9OLnNwbGl0KFwiLlwiKVswXTtjb25zdCBjPVN5bWJvbC5mb3IoYG9wZW50ZWxlbWV0cnkuanMuYXBpLiR7aX1gKTtjb25zdCBzPW4uX2dsb2JhbFRoaXM7ZnVuY3Rpb24gcmVnaXN0ZXJHbG9iYWwoZSx0LHIsbj1mYWxzZSl7dmFyIG87Y29uc3QgaT1zW2NdPShvPXNbY10pIT09bnVsbCYmbyE9PXZvaWQgMD9vOnt2ZXJzaW9uOmEuVkVSU0lPTn07aWYoIW4mJmlbZV0pe2NvbnN0IHQ9bmV3IEVycm9yKGBAb3BlbnRlbGVtZXRyeS9hcGk6IEF0dGVtcHRlZCBkdXBsaWNhdGUgcmVnaXN0cmF0aW9uIG9mIEFQSTogJHtlfWApO3IuZXJyb3IodC5zdGFja3x8dC5tZXNzYWdlKTtyZXR1cm4gZmFsc2V9aWYoaS52ZXJzaW9uIT09YS5WRVJTSU9OKXtjb25zdCB0PW5ldyBFcnJvcihgQG9wZW50ZWxlbWV0cnkvYXBpOiBSZWdpc3RyYXRpb24gb2YgdmVyc2lvbiB2JHtpLnZlcnNpb259IGZvciAke2V9IGRvZXMgbm90IG1hdGNoIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCBBUEkgdiR7YS5WRVJTSU9OfWApO3IuZXJyb3IodC5zdGFja3x8dC5tZXNzYWdlKTtyZXR1cm4gZmFsc2V9aVtlXT10O3IuZGVidWcoYEBvcGVudGVsZW1ldHJ5L2FwaTogUmVnaXN0ZXJlZCBhIGdsb2JhbCBmb3IgJHtlfSB2JHthLlZFUlNJT059LmApO3JldHVybiB0cnVlfXQucmVnaXN0ZXJHbG9iYWw9cmVnaXN0ZXJHbG9iYWw7ZnVuY3Rpb24gZ2V0R2xvYmFsKGUpe3ZhciB0LHI7Y29uc3Qgbj0odD1zW2NdKT09PW51bGx8fHQ9PT12b2lkIDA/dm9pZCAwOnQudmVyc2lvbjtpZighbnx8ISgwLG8uaXNDb21wYXRpYmxlKShuKSl7cmV0dXJufXJldHVybihyPXNbY10pPT09bnVsbHx8cj09PXZvaWQgMD92b2lkIDA6cltlXX10LmdldEdsb2JhbD1nZXRHbG9iYWw7ZnVuY3Rpb24gdW5yZWdpc3Rlckdsb2JhbChlLHQpe3QuZGVidWcoYEBvcGVudGVsZW1ldHJ5L2FwaTogVW5yZWdpc3RlcmluZyBhIGdsb2JhbCBmb3IgJHtlfSB2JHthLlZFUlNJT059LmApO2NvbnN0IHI9c1tjXTtpZihyKXtkZWxldGUgcltlXX19dC51bnJlZ2lzdGVyR2xvYmFsPXVucmVnaXN0ZXJHbG9iYWx9LDEzMDooZSx0LHIpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTt0LmlzQ29tcGF0aWJsZT10Ll9tYWtlQ29tcGF0aWJpbGl0eUNoZWNrPXZvaWQgMDtjb25zdCBuPXIoNTIxKTtjb25zdCBhPS9eKFxcZCspXFwuKFxcZCspXFwuKFxcZCspKC0oLispKT8kLztmdW5jdGlvbiBfbWFrZUNvbXBhdGliaWxpdHlDaGVjayhlKXtjb25zdCB0PW5ldyBTZXQoW2VdKTtjb25zdCByPW5ldyBTZXQ7Y29uc3Qgbj1lLm1hdGNoKGEpO2lmKCFuKXtyZXR1cm4oKT0+ZmFsc2V9Y29uc3Qgbz17bWFqb3I6K25bMV0sbWlub3I6K25bMl0scGF0Y2g6K25bM10scHJlcmVsZWFzZTpuWzRdfTtpZihvLnByZXJlbGVhc2UhPW51bGwpe3JldHVybiBmdW5jdGlvbiBpc0V4YWN0bWF0Y2godCl7cmV0dXJuIHQ9PT1lfX1mdW5jdGlvbiBfcmVqZWN0KGUpe3IuYWRkKGUpO3JldHVybiBmYWxzZX1mdW5jdGlvbiBfYWNjZXB0KGUpe3QuYWRkKGUpO3JldHVybiB0cnVlfXJldHVybiBmdW5jdGlvbiBpc0NvbXBhdGlibGUoZSl7aWYodC5oYXMoZSkpe3JldHVybiB0cnVlfWlmKHIuaGFzKGUpKXtyZXR1cm4gZmFsc2V9Y29uc3Qgbj1lLm1hdGNoKGEpO2lmKCFuKXtyZXR1cm4gX3JlamVjdChlKX1jb25zdCBpPXttYWpvcjorblsxXSxtaW5vcjorblsyXSxwYXRjaDorblszXSxwcmVyZWxlYXNlOm5bNF19O2lmKGkucHJlcmVsZWFzZSE9bnVsbCl7cmV0dXJuIF9yZWplY3QoZSl9aWYoby5tYWpvciE9PWkubWFqb3Ipe3JldHVybiBfcmVqZWN0KGUpfWlmKG8ubWFqb3I9PT0wKXtpZihvLm1pbm9yPT09aS5taW5vciYmby5wYXRjaDw9aS5wYXRjaCl7cmV0dXJuIF9hY2NlcHQoZSl9cmV0dXJuIF9yZWplY3QoZSl9aWYoby5taW5vcjw9aS5taW5vcil7cmV0dXJuIF9hY2NlcHQoZSl9cmV0dXJuIF9yZWplY3QoZSl9fXQuX21ha2VDb21wYXRpYmlsaXR5Q2hlY2s9X21ha2VDb21wYXRpYmlsaXR5Q2hlY2s7dC5pc0NvbXBhdGlibGU9X21ha2VDb21wYXRpYmlsaXR5Q2hlY2sobi5WRVJTSU9OKX0sODg2OihlLHQscik9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO3QubWV0cmljcz12b2lkIDA7Y29uc3Qgbj1yKDY1Myk7dC5tZXRyaWNzPW4uTWV0cmljc0FQSS5nZXRJbnN0YW5jZSgpfSw5MDE6KGUsdCk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO3QuVmFsdWVUeXBlPXZvaWQgMDt2YXIgcjsoZnVuY3Rpb24oZSl7ZVtlW1wiSU5UXCJdPTBdPVwiSU5UXCI7ZVtlW1wiRE9VQkxFXCJdPTFdPVwiRE9VQkxFXCJ9KShyPXQuVmFsdWVUeXBlfHwodC5WYWx1ZVR5cGU9e30pKX0sMTAyOihlLHQpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTt0LmNyZWF0ZU5vb3BNZXRlcj10Lk5PT1BfT0JTRVJWQUJMRV9VUF9ET1dOX0NPVU5URVJfTUVUUklDPXQuTk9PUF9PQlNFUlZBQkxFX0dBVUdFX01FVFJJQz10Lk5PT1BfT0JTRVJWQUJMRV9DT1VOVEVSX01FVFJJQz10Lk5PT1BfVVBfRE9XTl9DT1VOVEVSX01FVFJJQz10Lk5PT1BfSElTVE9HUkFNX01FVFJJQz10Lk5PT1BfQ09VTlRFUl9NRVRSSUM9dC5OT09QX01FVEVSPXQuTm9vcE9ic2VydmFibGVVcERvd25Db3VudGVyTWV0cmljPXQuTm9vcE9ic2VydmFibGVHYXVnZU1ldHJpYz10Lk5vb3BPYnNlcnZhYmxlQ291bnRlck1ldHJpYz10Lk5vb3BPYnNlcnZhYmxlTWV0cmljPXQuTm9vcEhpc3RvZ3JhbU1ldHJpYz10Lk5vb3BVcERvd25Db3VudGVyTWV0cmljPXQuTm9vcENvdW50ZXJNZXRyaWM9dC5Ob29wTWV0cmljPXQuTm9vcE1ldGVyPXZvaWQgMDtjbGFzcyBOb29wTWV0ZXJ7Y29uc3RydWN0b3IoKXt9Y3JlYXRlSGlzdG9ncmFtKGUscil7cmV0dXJuIHQuTk9PUF9ISVNUT0dSQU1fTUVUUklDfWNyZWF0ZUNvdW50ZXIoZSxyKXtyZXR1cm4gdC5OT09QX0NPVU5URVJfTUVUUklDfWNyZWF0ZVVwRG93bkNvdW50ZXIoZSxyKXtyZXR1cm4gdC5OT09QX1VQX0RPV05fQ09VTlRFUl9NRVRSSUN9Y3JlYXRlT2JzZXJ2YWJsZUdhdWdlKGUscil7cmV0dXJuIHQuTk9PUF9PQlNFUlZBQkxFX0dBVUdFX01FVFJJQ31jcmVhdGVPYnNlcnZhYmxlQ291bnRlcihlLHIpe3JldHVybiB0Lk5PT1BfT0JTRVJWQUJMRV9DT1VOVEVSX01FVFJJQ31jcmVhdGVPYnNlcnZhYmxlVXBEb3duQ291bnRlcihlLHIpe3JldHVybiB0Lk5PT1BfT0JTRVJWQUJMRV9VUF9ET1dOX0NPVU5URVJfTUVUUklDfWFkZEJhdGNoT2JzZXJ2YWJsZUNhbGxiYWNrKGUsdCl7fXJlbW92ZUJhdGNoT2JzZXJ2YWJsZUNhbGxiYWNrKGUpe319dC5Ob29wTWV0ZXI9Tm9vcE1ldGVyO2NsYXNzIE5vb3BNZXRyaWN7fXQuTm9vcE1ldHJpYz1Ob29wTWV0cmljO2NsYXNzIE5vb3BDb3VudGVyTWV0cmljIGV4dGVuZHMgTm9vcE1ldHJpY3thZGQoZSx0KXt9fXQuTm9vcENvdW50ZXJNZXRyaWM9Tm9vcENvdW50ZXJNZXRyaWM7Y2xhc3MgTm9vcFVwRG93bkNvdW50ZXJNZXRyaWMgZXh0ZW5kcyBOb29wTWV0cmlje2FkZChlLHQpe319dC5Ob29wVXBEb3duQ291bnRlck1ldHJpYz1Ob29wVXBEb3duQ291bnRlck1ldHJpYztjbGFzcyBOb29wSGlzdG9ncmFtTWV0cmljIGV4dGVuZHMgTm9vcE1ldHJpY3tyZWNvcmQoZSx0KXt9fXQuTm9vcEhpc3RvZ3JhbU1ldHJpYz1Ob29wSGlzdG9ncmFtTWV0cmljO2NsYXNzIE5vb3BPYnNlcnZhYmxlTWV0cmlje2FkZENhbGxiYWNrKGUpe31yZW1vdmVDYWxsYmFjayhlKXt9fXQuTm9vcE9ic2VydmFibGVNZXRyaWM9Tm9vcE9ic2VydmFibGVNZXRyaWM7Y2xhc3MgTm9vcE9ic2VydmFibGVDb3VudGVyTWV0cmljIGV4dGVuZHMgTm9vcE9ic2VydmFibGVNZXRyaWN7fXQuTm9vcE9ic2VydmFibGVDb3VudGVyTWV0cmljPU5vb3BPYnNlcnZhYmxlQ291bnRlck1ldHJpYztjbGFzcyBOb29wT2JzZXJ2YWJsZUdhdWdlTWV0cmljIGV4dGVuZHMgTm9vcE9ic2VydmFibGVNZXRyaWN7fXQuTm9vcE9ic2VydmFibGVHYXVnZU1ldHJpYz1Ob29wT2JzZXJ2YWJsZUdhdWdlTWV0cmljO2NsYXNzIE5vb3BPYnNlcnZhYmxlVXBEb3duQ291bnRlck1ldHJpYyBleHRlbmRzIE5vb3BPYnNlcnZhYmxlTWV0cmlje310Lk5vb3BPYnNlcnZhYmxlVXBEb3duQ291bnRlck1ldHJpYz1Ob29wT2JzZXJ2YWJsZVVwRG93bkNvdW50ZXJNZXRyaWM7dC5OT09QX01FVEVSPW5ldyBOb29wTWV0ZXI7dC5OT09QX0NPVU5URVJfTUVUUklDPW5ldyBOb29wQ291bnRlck1ldHJpYzt0Lk5PT1BfSElTVE9HUkFNX01FVFJJQz1uZXcgTm9vcEhpc3RvZ3JhbU1ldHJpYzt0Lk5PT1BfVVBfRE9XTl9DT1VOVEVSX01FVFJJQz1uZXcgTm9vcFVwRG93bkNvdW50ZXJNZXRyaWM7dC5OT09QX09CU0VSVkFCTEVfQ09VTlRFUl9NRVRSSUM9bmV3IE5vb3BPYnNlcnZhYmxlQ291bnRlck1ldHJpYzt0Lk5PT1BfT0JTRVJWQUJMRV9HQVVHRV9NRVRSSUM9bmV3IE5vb3BPYnNlcnZhYmxlR2F1Z2VNZXRyaWM7dC5OT09QX09CU0VSVkFCTEVfVVBfRE9XTl9DT1VOVEVSX01FVFJJQz1uZXcgTm9vcE9ic2VydmFibGVVcERvd25Db3VudGVyTWV0cmljO2Z1bmN0aW9uIGNyZWF0ZU5vb3BNZXRlcigpe3JldHVybiB0Lk5PT1BfTUVURVJ9dC5jcmVhdGVOb29wTWV0ZXI9Y3JlYXRlTm9vcE1ldGVyfSw2NjA6KGUsdCxyKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dC5OT09QX01FVEVSX1BST1ZJREVSPXQuTm9vcE1ldGVyUHJvdmlkZXI9dm9pZCAwO2NvbnN0IG49cigxMDIpO2NsYXNzIE5vb3BNZXRlclByb3ZpZGVye2dldE1ldGVyKGUsdCxyKXtyZXR1cm4gbi5OT09QX01FVEVSfX10Lk5vb3BNZXRlclByb3ZpZGVyPU5vb3BNZXRlclByb3ZpZGVyO3QuTk9PUF9NRVRFUl9QUk9WSURFUj1uZXcgTm9vcE1ldGVyUHJvdmlkZXJ9LDIwMDpmdW5jdGlvbihlLHQscil7dmFyIG49dGhpcyYmdGhpcy5fX2NyZWF0ZUJpbmRpbmd8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKGUsdCxyLG4pe2lmKG49PT11bmRlZmluZWQpbj1yO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG4se2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdFtyXX19KX06ZnVuY3Rpb24oZSx0LHIsbil7aWYobj09PXVuZGVmaW5lZCluPXI7ZVtuXT10W3JdfSk7dmFyIGE9dGhpcyYmdGhpcy5fX2V4cG9ydFN0YXJ8fGZ1bmN0aW9uKGUsdCl7Zm9yKHZhciByIGluIGUpaWYociE9PVwiZGVmYXVsdFwiJiYhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQscikpbih0LGUscil9O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7YShyKDQ2KSx0KX0sNjUxOihlLHQpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTt0Ll9nbG9iYWxUaGlzPXZvaWQgMDt0Ll9nbG9iYWxUaGlzPXR5cGVvZiBnbG9iYWxUaGlzPT09XCJvYmplY3RcIj9nbG9iYWxUaGlzOmdsb2JhbH0sNDY6ZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXRoaXMmJnRoaXMuX19jcmVhdGVCaW5kaW5nfHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihlLHQscixuKXtpZihuPT09dW5kZWZpbmVkKW49cjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxuLHtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRbcl19fSl9OmZ1bmN0aW9uKGUsdCxyLG4pe2lmKG49PT11bmRlZmluZWQpbj1yO2Vbbl09dFtyXX0pO3ZhciBhPXRoaXMmJnRoaXMuX19leHBvcnRTdGFyfHxmdW5jdGlvbihlLHQpe2Zvcih2YXIgciBpbiBlKWlmKHIhPT1cImRlZmF1bHRcIiYmIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LHIpKW4odCxlLHIpfTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO2Eocig2NTEpLHQpfSw5Mzk6KGUsdCxyKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dC5wcm9wYWdhdGlvbj12b2lkIDA7Y29uc3Qgbj1yKDE4MSk7dC5wcm9wYWdhdGlvbj1uLlByb3BhZ2F0aW9uQVBJLmdldEluc3RhbmNlKCl9LDg3NDooZSx0KT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dC5Ob29wVGV4dE1hcFByb3BhZ2F0b3I9dm9pZCAwO2NsYXNzIE5vb3BUZXh0TWFwUHJvcGFnYXRvcntpbmplY3QoZSx0KXt9ZXh0cmFjdChlLHQpe3JldHVybiBlfWZpZWxkcygpe3JldHVybltdfX10Lk5vb3BUZXh0TWFwUHJvcGFnYXRvcj1Ob29wVGV4dE1hcFByb3BhZ2F0b3J9LDE5NDooZSx0KT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dC5kZWZhdWx0VGV4dE1hcFNldHRlcj10LmRlZmF1bHRUZXh0TWFwR2V0dGVyPXZvaWQgMDt0LmRlZmF1bHRUZXh0TWFwR2V0dGVyPXtnZXQoZSx0KXtpZihlPT1udWxsKXtyZXR1cm4gdW5kZWZpbmVkfXJldHVybiBlW3RdfSxrZXlzKGUpe2lmKGU9PW51bGwpe3JldHVybltdfXJldHVybiBPYmplY3Qua2V5cyhlKX19O3QuZGVmYXVsdFRleHRNYXBTZXR0ZXI9e3NldChlLHQscil7aWYoZT09bnVsbCl7cmV0dXJufWVbdF09cn19fSw4NDU6KGUsdCxyKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dC50cmFjZT12b2lkIDA7Y29uc3Qgbj1yKDk5Nyk7dC50cmFjZT1uLlRyYWNlQVBJLmdldEluc3RhbmNlKCl9LDQwMzooZSx0LHIpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTt0Lk5vblJlY29yZGluZ1NwYW49dm9pZCAwO2NvbnN0IG49cig0NzYpO2NsYXNzIE5vblJlY29yZGluZ1NwYW57Y29uc3RydWN0b3IoZT1uLklOVkFMSURfU1BBTl9DT05URVhUKXt0aGlzLl9zcGFuQ29udGV4dD1lfXNwYW5Db250ZXh0KCl7cmV0dXJuIHRoaXMuX3NwYW5Db250ZXh0fXNldEF0dHJpYnV0ZShlLHQpe3JldHVybiB0aGlzfXNldEF0dHJpYnV0ZXMoZSl7cmV0dXJuIHRoaXN9YWRkRXZlbnQoZSx0KXtyZXR1cm4gdGhpc31zZXRTdGF0dXMoZSl7cmV0dXJuIHRoaXN9dXBkYXRlTmFtZShlKXtyZXR1cm4gdGhpc31lbmQoZSl7fWlzUmVjb3JkaW5nKCl7cmV0dXJuIGZhbHNlfXJlY29yZEV4Y2VwdGlvbihlLHQpe319dC5Ob25SZWNvcmRpbmdTcGFuPU5vblJlY29yZGluZ1NwYW59LDYxNDooZSx0LHIpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTt0Lk5vb3BUcmFjZXI9dm9pZCAwO2NvbnN0IG49cig0OTEpO2NvbnN0IGE9cig2MDcpO2NvbnN0IG89cig0MDMpO2NvbnN0IGk9cigxMzkpO2NvbnN0IGM9bi5Db250ZXh0QVBJLmdldEluc3RhbmNlKCk7Y2xhc3MgTm9vcFRyYWNlcntzdGFydFNwYW4oZSx0LHI9Yy5hY3RpdmUoKSl7Y29uc3Qgbj1Cb29sZWFuKHQ9PT1udWxsfHx0PT09dm9pZCAwP3ZvaWQgMDp0LnJvb3QpO2lmKG4pe3JldHVybiBuZXcgby5Ob25SZWNvcmRpbmdTcGFufWNvbnN0IHM9ciYmKDAsYS5nZXRTcGFuQ29udGV4dCkocik7aWYoaXNTcGFuQ29udGV4dChzKSYmKDAsaS5pc1NwYW5Db250ZXh0VmFsaWQpKHMpKXtyZXR1cm4gbmV3IG8uTm9uUmVjb3JkaW5nU3BhbihzKX1lbHNle3JldHVybiBuZXcgby5Ob25SZWNvcmRpbmdTcGFufX1zdGFydEFjdGl2ZVNwYW4oZSx0LHIsbil7bGV0IG87bGV0IGk7bGV0IHM7aWYoYXJndW1lbnRzLmxlbmd0aDwyKXtyZXR1cm59ZWxzZSBpZihhcmd1bWVudHMubGVuZ3RoPT09Mil7cz10fWVsc2UgaWYoYXJndW1lbnRzLmxlbmd0aD09PTMpe289dDtzPXJ9ZWxzZXtvPXQ7aT1yO3M9bn1jb25zdCB1PWkhPT1udWxsJiZpIT09dm9pZCAwP2k6Yy5hY3RpdmUoKTtjb25zdCBsPXRoaXMuc3RhcnRTcGFuKGUsbyx1KTtjb25zdCBnPSgwLGEuc2V0U3BhbikodSxsKTtyZXR1cm4gYy53aXRoKGcscyx1bmRlZmluZWQsbCl9fXQuTm9vcFRyYWNlcj1Ob29wVHJhY2VyO2Z1bmN0aW9uIGlzU3BhbkNvbnRleHQoZSl7cmV0dXJuIHR5cGVvZiBlPT09XCJvYmplY3RcIiYmdHlwZW9mIGVbXCJzcGFuSWRcIl09PT1cInN0cmluZ1wiJiZ0eXBlb2YgZVtcInRyYWNlSWRcIl09PT1cInN0cmluZ1wiJiZ0eXBlb2YgZVtcInRyYWNlRmxhZ3NcIl09PT1cIm51bWJlclwifX0sMTI0OihlLHQscik9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO3QuTm9vcFRyYWNlclByb3ZpZGVyPXZvaWQgMDtjb25zdCBuPXIoNjE0KTtjbGFzcyBOb29wVHJhY2VyUHJvdmlkZXJ7Z2V0VHJhY2VyKGUsdCxyKXtyZXR1cm4gbmV3IG4uTm9vcFRyYWNlcn19dC5Ob29wVHJhY2VyUHJvdmlkZXI9Tm9vcFRyYWNlclByb3ZpZGVyfSwxMjU6KGUsdCxyKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dC5Qcm94eVRyYWNlcj12b2lkIDA7Y29uc3Qgbj1yKDYxNCk7Y29uc3QgYT1uZXcgbi5Ob29wVHJhY2VyO2NsYXNzIFByb3h5VHJhY2Vye2NvbnN0cnVjdG9yKGUsdCxyLG4pe3RoaXMuX3Byb3ZpZGVyPWU7dGhpcy5uYW1lPXQ7dGhpcy52ZXJzaW9uPXI7dGhpcy5vcHRpb25zPW59c3RhcnRTcGFuKGUsdCxyKXtyZXR1cm4gdGhpcy5fZ2V0VHJhY2VyKCkuc3RhcnRTcGFuKGUsdCxyKX1zdGFydEFjdGl2ZVNwYW4oZSx0LHIsbil7Y29uc3QgYT10aGlzLl9nZXRUcmFjZXIoKTtyZXR1cm4gUmVmbGVjdC5hcHBseShhLnN0YXJ0QWN0aXZlU3BhbixhLGFyZ3VtZW50cyl9X2dldFRyYWNlcigpe2lmKHRoaXMuX2RlbGVnYXRlKXtyZXR1cm4gdGhpcy5fZGVsZWdhdGV9Y29uc3QgZT10aGlzLl9wcm92aWRlci5nZXREZWxlZ2F0ZVRyYWNlcih0aGlzLm5hbWUsdGhpcy52ZXJzaW9uLHRoaXMub3B0aW9ucyk7aWYoIWUpe3JldHVybiBhfXRoaXMuX2RlbGVnYXRlPWU7cmV0dXJuIHRoaXMuX2RlbGVnYXRlfX10LlByb3h5VHJhY2VyPVByb3h5VHJhY2VyfSw4NDY6KGUsdCxyKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dC5Qcm94eVRyYWNlclByb3ZpZGVyPXZvaWQgMDtjb25zdCBuPXIoMTI1KTtjb25zdCBhPXIoMTI0KTtjb25zdCBvPW5ldyBhLk5vb3BUcmFjZXJQcm92aWRlcjtjbGFzcyBQcm94eVRyYWNlclByb3ZpZGVye2dldFRyYWNlcihlLHQscil7dmFyIGE7cmV0dXJuKGE9dGhpcy5nZXREZWxlZ2F0ZVRyYWNlcihlLHQscikpIT09bnVsbCYmYSE9PXZvaWQgMD9hOm5ldyBuLlByb3h5VHJhY2VyKHRoaXMsZSx0LHIpfWdldERlbGVnYXRlKCl7dmFyIGU7cmV0dXJuKGU9dGhpcy5fZGVsZWdhdGUpIT09bnVsbCYmZSE9PXZvaWQgMD9lOm99c2V0RGVsZWdhdGUoZSl7dGhpcy5fZGVsZWdhdGU9ZX1nZXREZWxlZ2F0ZVRyYWNlcihlLHQscil7dmFyIG47cmV0dXJuKG49dGhpcy5fZGVsZWdhdGUpPT09bnVsbHx8bj09PXZvaWQgMD92b2lkIDA6bi5nZXRUcmFjZXIoZSx0LHIpfX10LlByb3h5VHJhY2VyUHJvdmlkZXI9UHJveHlUcmFjZXJQcm92aWRlcn0sOTk2OihlLHQpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTt0LlNhbXBsaW5nRGVjaXNpb249dm9pZCAwO3ZhciByOyhmdW5jdGlvbihlKXtlW2VbXCJOT1RfUkVDT1JEXCJdPTBdPVwiTk9UX1JFQ09SRFwiO2VbZVtcIlJFQ09SRFwiXT0xXT1cIlJFQ09SRFwiO2VbZVtcIlJFQ09SRF9BTkRfU0FNUExFRFwiXT0yXT1cIlJFQ09SRF9BTkRfU0FNUExFRFwifSkocj10LlNhbXBsaW5nRGVjaXNpb258fCh0LlNhbXBsaW5nRGVjaXNpb249e30pKX0sNjA3OihlLHQscik9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO3QuZ2V0U3BhbkNvbnRleHQ9dC5zZXRTcGFuQ29udGV4dD10LmRlbGV0ZVNwYW49dC5zZXRTcGFuPXQuZ2V0QWN0aXZlU3Bhbj10LmdldFNwYW49dm9pZCAwO2NvbnN0IG49cig3ODApO2NvbnN0IGE9cig0MDMpO2NvbnN0IG89cig0OTEpO2NvbnN0IGk9KDAsbi5jcmVhdGVDb250ZXh0S2V5KShcIk9wZW5UZWxlbWV0cnkgQ29udGV4dCBLZXkgU1BBTlwiKTtmdW5jdGlvbiBnZXRTcGFuKGUpe3JldHVybiBlLmdldFZhbHVlKGkpfHx1bmRlZmluZWR9dC5nZXRTcGFuPWdldFNwYW47ZnVuY3Rpb24gZ2V0QWN0aXZlU3Bhbigpe3JldHVybiBnZXRTcGFuKG8uQ29udGV4dEFQSS5nZXRJbnN0YW5jZSgpLmFjdGl2ZSgpKX10LmdldEFjdGl2ZVNwYW49Z2V0QWN0aXZlU3BhbjtmdW5jdGlvbiBzZXRTcGFuKGUsdCl7cmV0dXJuIGUuc2V0VmFsdWUoaSx0KX10LnNldFNwYW49c2V0U3BhbjtmdW5jdGlvbiBkZWxldGVTcGFuKGUpe3JldHVybiBlLmRlbGV0ZVZhbHVlKGkpfXQuZGVsZXRlU3Bhbj1kZWxldGVTcGFuO2Z1bmN0aW9uIHNldFNwYW5Db250ZXh0KGUsdCl7cmV0dXJuIHNldFNwYW4oZSxuZXcgYS5Ob25SZWNvcmRpbmdTcGFuKHQpKX10LnNldFNwYW5Db250ZXh0PXNldFNwYW5Db250ZXh0O2Z1bmN0aW9uIGdldFNwYW5Db250ZXh0KGUpe3ZhciB0O3JldHVybih0PWdldFNwYW4oZSkpPT09bnVsbHx8dD09PXZvaWQgMD92b2lkIDA6dC5zcGFuQ29udGV4dCgpfXQuZ2V0U3BhbkNvbnRleHQ9Z2V0U3BhbkNvbnRleHR9LDMyNTooZSx0LHIpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTt0LlRyYWNlU3RhdGVJbXBsPXZvaWQgMDtjb25zdCBuPXIoNTY0KTtjb25zdCBhPTMyO2NvbnN0IG89NTEyO2NvbnN0IGk9XCIsXCI7Y29uc3QgYz1cIj1cIjtjbGFzcyBUcmFjZVN0YXRlSW1wbHtjb25zdHJ1Y3RvcihlKXt0aGlzLl9pbnRlcm5hbFN0YXRlPW5ldyBNYXA7aWYoZSl0aGlzLl9wYXJzZShlKX1zZXQoZSx0KXtjb25zdCByPXRoaXMuX2Nsb25lKCk7aWYoci5faW50ZXJuYWxTdGF0ZS5oYXMoZSkpe3IuX2ludGVybmFsU3RhdGUuZGVsZXRlKGUpfXIuX2ludGVybmFsU3RhdGUuc2V0KGUsdCk7cmV0dXJuIHJ9dW5zZXQoZSl7Y29uc3QgdD10aGlzLl9jbG9uZSgpO3QuX2ludGVybmFsU3RhdGUuZGVsZXRlKGUpO3JldHVybiB0fWdldChlKXtyZXR1cm4gdGhpcy5faW50ZXJuYWxTdGF0ZS5nZXQoZSl9c2VyaWFsaXplKCl7cmV0dXJuIHRoaXMuX2tleXMoKS5yZWR1Y2UoKChlLHQpPT57ZS5wdXNoKHQrYyt0aGlzLmdldCh0KSk7cmV0dXJuIGV9KSxbXSkuam9pbihpKX1fcGFyc2UoZSl7aWYoZS5sZW5ndGg+bylyZXR1cm47dGhpcy5faW50ZXJuYWxTdGF0ZT1lLnNwbGl0KGkpLnJldmVyc2UoKS5yZWR1Y2UoKChlLHQpPT57Y29uc3Qgcj10LnRyaW0oKTtjb25zdCBhPXIuaW5kZXhPZihjKTtpZihhIT09LTEpe2NvbnN0IG89ci5zbGljZSgwLGEpO2NvbnN0IGk9ci5zbGljZShhKzEsdC5sZW5ndGgpO2lmKCgwLG4udmFsaWRhdGVLZXkpKG8pJiYoMCxuLnZhbGlkYXRlVmFsdWUpKGkpKXtlLnNldChvLGkpfWVsc2V7fX1yZXR1cm4gZX0pLG5ldyBNYXApO2lmKHRoaXMuX2ludGVybmFsU3RhdGUuc2l6ZT5hKXt0aGlzLl9pbnRlcm5hbFN0YXRlPW5ldyBNYXAoQXJyYXkuZnJvbSh0aGlzLl9pbnRlcm5hbFN0YXRlLmVudHJpZXMoKSkucmV2ZXJzZSgpLnNsaWNlKDAsYSkpfX1fa2V5cygpe3JldHVybiBBcnJheS5mcm9tKHRoaXMuX2ludGVybmFsU3RhdGUua2V5cygpKS5yZXZlcnNlKCl9X2Nsb25lKCl7Y29uc3QgZT1uZXcgVHJhY2VTdGF0ZUltcGw7ZS5faW50ZXJuYWxTdGF0ZT1uZXcgTWFwKHRoaXMuX2ludGVybmFsU3RhdGUpO3JldHVybiBlfX10LlRyYWNlU3RhdGVJbXBsPVRyYWNlU3RhdGVJbXBsfSw1NjQ6KGUsdCk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO3QudmFsaWRhdGVWYWx1ZT10LnZhbGlkYXRlS2V5PXZvaWQgMDtjb25zdCByPVwiW18wLTlhLXotKi9dXCI7Y29uc3Qgbj1gW2Etel0ke3J9ezAsMjU1fWA7Y29uc3QgYT1gW2EtejAtOV0ke3J9ezAsMjQwfUBbYS16XSR7cn17MCwxM31gO2NvbnN0IG89bmV3IFJlZ0V4cChgXig/OiR7bn18JHthfSkkYCk7Y29uc3QgaT0vXlsgLX5dezAsMjU1fVshLX5dJC87Y29uc3QgYz0vLHw9LztmdW5jdGlvbiB2YWxpZGF0ZUtleShlKXtyZXR1cm4gby50ZXN0KGUpfXQudmFsaWRhdGVLZXk9dmFsaWRhdGVLZXk7ZnVuY3Rpb24gdmFsaWRhdGVWYWx1ZShlKXtyZXR1cm4gaS50ZXN0KGUpJiYhYy50ZXN0KGUpfXQudmFsaWRhdGVWYWx1ZT12YWxpZGF0ZVZhbHVlfSw5ODooZSx0LHIpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTt0LmNyZWF0ZVRyYWNlU3RhdGU9dm9pZCAwO2NvbnN0IG49cigzMjUpO2Z1bmN0aW9uIGNyZWF0ZVRyYWNlU3RhdGUoZSl7cmV0dXJuIG5ldyBuLlRyYWNlU3RhdGVJbXBsKGUpfXQuY3JlYXRlVHJhY2VTdGF0ZT1jcmVhdGVUcmFjZVN0YXRlfSw0NzY6KGUsdCxyKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dC5JTlZBTElEX1NQQU5fQ09OVEVYVD10LklOVkFMSURfVFJBQ0VJRD10LklOVkFMSURfU1BBTklEPXZvaWQgMDtjb25zdCBuPXIoNDc1KTt0LklOVkFMSURfU1BBTklEPVwiMDAwMDAwMDAwMDAwMDAwMFwiO3QuSU5WQUxJRF9UUkFDRUlEPVwiMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIjt0LklOVkFMSURfU1BBTl9DT05URVhUPXt0cmFjZUlkOnQuSU5WQUxJRF9UUkFDRUlELHNwYW5JZDp0LklOVkFMSURfU1BBTklELHRyYWNlRmxhZ3M6bi5UcmFjZUZsYWdzLk5PTkV9fSwzNTc6KGUsdCk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO3QuU3BhbktpbmQ9dm9pZCAwO3ZhciByOyhmdW5jdGlvbihlKXtlW2VbXCJJTlRFUk5BTFwiXT0wXT1cIklOVEVSTkFMXCI7ZVtlW1wiU0VSVkVSXCJdPTFdPVwiU0VSVkVSXCI7ZVtlW1wiQ0xJRU5UXCJdPTJdPVwiQ0xJRU5UXCI7ZVtlW1wiUFJPRFVDRVJcIl09M109XCJQUk9EVUNFUlwiO2VbZVtcIkNPTlNVTUVSXCJdPTRdPVwiQ09OU1VNRVJcIn0pKHI9dC5TcGFuS2luZHx8KHQuU3BhbktpbmQ9e30pKX0sMTM5OihlLHQscik9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO3Qud3JhcFNwYW5Db250ZXh0PXQuaXNTcGFuQ29udGV4dFZhbGlkPXQuaXNWYWxpZFNwYW5JZD10LmlzVmFsaWRUcmFjZUlkPXZvaWQgMDtjb25zdCBuPXIoNDc2KTtjb25zdCBhPXIoNDAzKTtjb25zdCBvPS9eKFswLTlhLWZdezMyfSkkL2k7Y29uc3QgaT0vXlswLTlhLWZdezE2fSQvaTtmdW5jdGlvbiBpc1ZhbGlkVHJhY2VJZChlKXtyZXR1cm4gby50ZXN0KGUpJiZlIT09bi5JTlZBTElEX1RSQUNFSUR9dC5pc1ZhbGlkVHJhY2VJZD1pc1ZhbGlkVHJhY2VJZDtmdW5jdGlvbiBpc1ZhbGlkU3BhbklkKGUpe3JldHVybiBpLnRlc3QoZSkmJmUhPT1uLklOVkFMSURfU1BBTklEfXQuaXNWYWxpZFNwYW5JZD1pc1ZhbGlkU3BhbklkO2Z1bmN0aW9uIGlzU3BhbkNvbnRleHRWYWxpZChlKXtyZXR1cm4gaXNWYWxpZFRyYWNlSWQoZS50cmFjZUlkKSYmaXNWYWxpZFNwYW5JZChlLnNwYW5JZCl9dC5pc1NwYW5Db250ZXh0VmFsaWQ9aXNTcGFuQ29udGV4dFZhbGlkO2Z1bmN0aW9uIHdyYXBTcGFuQ29udGV4dChlKXtyZXR1cm4gbmV3IGEuTm9uUmVjb3JkaW5nU3BhbihlKX10LndyYXBTcGFuQ29udGV4dD13cmFwU3BhbkNvbnRleHR9LDg0NzooZSx0KT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dC5TcGFuU3RhdHVzQ29kZT12b2lkIDA7dmFyIHI7KGZ1bmN0aW9uKGUpe2VbZVtcIlVOU0VUXCJdPTBdPVwiVU5TRVRcIjtlW2VbXCJPS1wiXT0xXT1cIk9LXCI7ZVtlW1wiRVJST1JcIl09Ml09XCJFUlJPUlwifSkocj10LlNwYW5TdGF0dXNDb2RlfHwodC5TcGFuU3RhdHVzQ29kZT17fSkpfSw0NzU6KGUsdCk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO3QuVHJhY2VGbGFncz12b2lkIDA7dmFyIHI7KGZ1bmN0aW9uKGUpe2VbZVtcIk5PTkVcIl09MF09XCJOT05FXCI7ZVtlW1wiU0FNUExFRFwiXT0xXT1cIlNBTVBMRURcIn0pKHI9dC5UcmFjZUZsYWdzfHwodC5UcmFjZUZsYWdzPXt9KSl9LDUyMTooZSx0KT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dC5WRVJTSU9OPXZvaWQgMDt0LlZFUlNJT049XCIxLjYuMFwifX07dmFyIHQ9e307ZnVuY3Rpb24gX19uY2N3cGNrX3JlcXVpcmVfXyhyKXt2YXIgbj10W3JdO2lmKG4hPT11bmRlZmluZWQpe3JldHVybiBuLmV4cG9ydHN9dmFyIGE9dFtyXT17ZXhwb3J0czp7fX07dmFyIG89dHJ1ZTt0cnl7ZVtyXS5jYWxsKGEuZXhwb3J0cyxhLGEuZXhwb3J0cyxfX25jY3dwY2tfcmVxdWlyZV9fKTtvPWZhbHNlfWZpbmFsbHl7aWYobylkZWxldGUgdFtyXX1yZXR1cm4gYS5leHBvcnRzfWlmKHR5cGVvZiBfX25jY3dwY2tfcmVxdWlyZV9fIT09XCJ1bmRlZmluZWRcIilfX25jY3dwY2tfcmVxdWlyZV9fLmFiPV9fZGlybmFtZStcIi9cIjt2YXIgcj17fTsoKCk9Pnt2YXIgZT1yO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7ZS50cmFjZT1lLnByb3BhZ2F0aW9uPWUubWV0cmljcz1lLmRpYWc9ZS5jb250ZXh0PWUuSU5WQUxJRF9TUEFOX0NPTlRFWFQ9ZS5JTlZBTElEX1RSQUNFSUQ9ZS5JTlZBTElEX1NQQU5JRD1lLmlzVmFsaWRTcGFuSWQ9ZS5pc1ZhbGlkVHJhY2VJZD1lLmlzU3BhbkNvbnRleHRWYWxpZD1lLmNyZWF0ZVRyYWNlU3RhdGU9ZS5UcmFjZUZsYWdzPWUuU3BhblN0YXR1c0NvZGU9ZS5TcGFuS2luZD1lLlNhbXBsaW5nRGVjaXNpb249ZS5Qcm94eVRyYWNlclByb3ZpZGVyPWUuUHJveHlUcmFjZXI9ZS5kZWZhdWx0VGV4dE1hcFNldHRlcj1lLmRlZmF1bHRUZXh0TWFwR2V0dGVyPWUuVmFsdWVUeXBlPWUuY3JlYXRlTm9vcE1ldGVyPWUuRGlhZ0xvZ0xldmVsPWUuRGlhZ0NvbnNvbGVMb2dnZXI9ZS5ST09UX0NPTlRFWFQ9ZS5jcmVhdGVDb250ZXh0S2V5PWUuYmFnZ2FnZUVudHJ5TWV0YWRhdGFGcm9tU3RyaW5nPXZvaWQgMDt2YXIgdD1fX25jY3dwY2tfcmVxdWlyZV9fKDM2OSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJiYWdnYWdlRW50cnlNZXRhZGF0YUZyb21TdHJpbmdcIix7ZW51bWVyYWJsZTp0cnVlLGdldDpmdW5jdGlvbigpe3JldHVybiB0LmJhZ2dhZ2VFbnRyeU1ldGFkYXRhRnJvbVN0cmluZ319KTt2YXIgbj1fX25jY3dwY2tfcmVxdWlyZV9fKDc4MCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJjcmVhdGVDb250ZXh0S2V5XCIse2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbi5jcmVhdGVDb250ZXh0S2V5fX0pO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiUk9PVF9DT05URVhUXCIse2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbi5ST09UX0NPTlRFWFR9fSk7dmFyIGE9X19uY2N3cGNrX3JlcXVpcmVfXyg5NzIpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiRGlhZ0NvbnNvbGVMb2dnZXJcIix7ZW51bWVyYWJsZTp0cnVlLGdldDpmdW5jdGlvbigpe3JldHVybiBhLkRpYWdDb25zb2xlTG9nZ2VyfX0pO3ZhciBvPV9fbmNjd3Bja19yZXF1aXJlX18oOTU3KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIkRpYWdMb2dMZXZlbFwiLHtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG8uRGlhZ0xvZ0xldmVsfX0pO3ZhciBpPV9fbmNjd3Bja19yZXF1aXJlX18oMTAyKTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcImNyZWF0ZU5vb3BNZXRlclwiLHtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGkuY3JlYXRlTm9vcE1ldGVyfX0pO3ZhciBjPV9fbmNjd3Bja19yZXF1aXJlX18oOTAxKTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIlZhbHVlVHlwZVwiLHtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGMuVmFsdWVUeXBlfX0pO3ZhciBzPV9fbmNjd3Bja19yZXF1aXJlX18oMTk0KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcImRlZmF1bHRUZXh0TWFwR2V0dGVyXCIse2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcy5kZWZhdWx0VGV4dE1hcEdldHRlcn19KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcImRlZmF1bHRUZXh0TWFwU2V0dGVyXCIse2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcy5kZWZhdWx0VGV4dE1hcFNldHRlcn19KTt2YXIgdT1fX25jY3dwY2tfcmVxdWlyZV9fKDEyNSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJQcm94eVRyYWNlclwiLHtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHUuUHJveHlUcmFjZXJ9fSk7dmFyIGw9X19uY2N3cGNrX3JlcXVpcmVfXyg4NDYpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiUHJveHlUcmFjZXJQcm92aWRlclwiLHtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGwuUHJveHlUcmFjZXJQcm92aWRlcn19KTt2YXIgZz1fX25jY3dwY2tfcmVxdWlyZV9fKDk5Nik7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJTYW1wbGluZ0RlY2lzaW9uXCIse2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZy5TYW1wbGluZ0RlY2lzaW9ufX0pO3ZhciBwPV9fbmNjd3Bja19yZXF1aXJlX18oMzU3KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIlNwYW5LaW5kXCIse2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcC5TcGFuS2luZH19KTt2YXIgZD1fX25jY3dwY2tfcmVxdWlyZV9fKDg0Nyk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJTcGFuU3RhdHVzQ29kZVwiLHtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGQuU3BhblN0YXR1c0NvZGV9fSk7dmFyIF89X19uY2N3cGNrX3JlcXVpcmVfXyg0NzUpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiVHJhY2VGbGFnc1wiLHtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIF8uVHJhY2VGbGFnc319KTt2YXIgZj1fX25jY3dwY2tfcmVxdWlyZV9fKDk4KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcImNyZWF0ZVRyYWNlU3RhdGVcIix7ZW51bWVyYWJsZTp0cnVlLGdldDpmdW5jdGlvbigpe3JldHVybiBmLmNyZWF0ZVRyYWNlU3RhdGV9fSk7dmFyIGI9X19uY2N3cGNrX3JlcXVpcmVfXygxMzkpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiaXNTcGFuQ29udGV4dFZhbGlkXCIse2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYi5pc1NwYW5Db250ZXh0VmFsaWR9fSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJpc1ZhbGlkVHJhY2VJZFwiLHtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGIuaXNWYWxpZFRyYWNlSWR9fSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJpc1ZhbGlkU3BhbklkXCIse2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYi5pc1ZhbGlkU3BhbklkfX0pO3ZhciB2PV9fbmNjd3Bja19yZXF1aXJlX18oNDc2KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIklOVkFMSURfU1BBTklEXCIse2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdi5JTlZBTElEX1NQQU5JRH19KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIklOVkFMSURfVFJBQ0VJRFwiLHtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHYuSU5WQUxJRF9UUkFDRUlEfX0pO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiSU5WQUxJRF9TUEFOX0NPTlRFWFRcIix7ZW51bWVyYWJsZTp0cnVlLGdldDpmdW5jdGlvbigpe3JldHVybiB2LklOVkFMSURfU1BBTl9DT05URVhUfX0pO2NvbnN0IE89X19uY2N3cGNrX3JlcXVpcmVfXyg2Nyk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJjb250ZXh0XCIse2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gTy5jb250ZXh0fX0pO2NvbnN0IFA9X19uY2N3cGNrX3JlcXVpcmVfXyg1MDYpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiZGlhZ1wiLHtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIFAuZGlhZ319KTtjb25zdCBOPV9fbmNjd3Bja19yZXF1aXJlX18oODg2KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIm1ldHJpY3NcIix7ZW51bWVyYWJsZTp0cnVlLGdldDpmdW5jdGlvbigpe3JldHVybiBOLm1ldHJpY3N9fSk7Y29uc3QgUz1fX25jY3dwY2tfcmVxdWlyZV9fKDkzOSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJwcm9wYWdhdGlvblwiLHtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIFMucHJvcGFnYXRpb259fSk7Y29uc3QgQz1fX25jY3dwY2tfcmVxdWlyZV9fKDg0NSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJ0cmFjZVwiLHtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIEMudHJhY2V9fSk7ZVtcImRlZmF1bHRcIl09e2NvbnRleHQ6Ty5jb250ZXh0LGRpYWc6UC5kaWFnLG1ldHJpY3M6Ti5tZXRyaWNzLHByb3BhZ2F0aW9uOlMucHJvcGFnYXRpb24sdHJhY2U6Qy50cmFjZX19KSgpO21vZHVsZS5leHBvcnRzPXJ9KSgpOyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxDQUFDO0lBQUs7SUFBYSxJQUFJLElBQUU7UUFBQyxLQUFJLENBQUMsR0FBRSxHQUFFO1lBQUssT0FBTyxjQUFjLENBQUMsR0FBRSxjQUFhO2dCQUFDLE9BQU07WUFBSTtZQUFH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Q0FBQyxHQUFFLFdBQVU7WUFBQyxZQUFXO1lBQUssS0FBSTtnQkFBVyxPQUFPLEVBQUUsT0FBTztZQUFBO1FBQUM7UUFBRyxNQUFNLElBQUUsb0JBQW9CO1FBQUssT0FBTyxjQUFjLENBQUMsR0FBRSxRQUFPO1lBQUMsWUFBVztZQUFLLEtBQUk7Z0JBQVcsT0FBTyxFQUFFLElBQUk7WUFBQTtRQUFDO1FBQUcsTUFBTSxJQUFFLG9CQUFvQjtRQUFLLE9BQU8sY0FBYyxDQUFDLEdBQUUsV0FBVTtZQUFDLFlBQVc7WUFBSyxLQUFJO2dCQUFXLE9BQU8sRUFBRSxPQUFPO1lBQUE7UUFBQztRQUFHLE1BQU0sSUFBRSxvQkFBb0I7UUFBSyxPQUFPLGNBQWMsQ0FBQyxHQUFFLGVBQWM7WUFBQyxZQUFXO1lBQUssS0FBSTtnQkFBVyxPQUFPLEVBQUUsV0FBVztZQUFBO1FBQUM7UUFBRyxNQUFNLElBQUUsb0JBQW9CO1FBQUssT0FBTyxjQUFjLENBQUMsR0FBRSxTQUFRO1lBQUMsWUFBVztZQUFLLEtBQUk7Z0JBQVcsT0FBTyxFQUFFLEtBQUs7WUFBQTtRQUFDO1FBQUcsQ0FBQyxDQUFDLFVBQVUsR0FBQztZQUFDLFNBQVEsRUFBRSxPQUFPO1lBQUMsTUFBSyxFQUFFLElBQUk7WUFBQyxTQUFRLEVBQUUsT0FBTztZQUFDLGFBQVksRUFBRSxXQUFXO1lBQUMsT0FBTSxFQUFFLEtBQUs7UUFBQTtJQUFDLENBQUM7SUFBSSxPQUFPLE9BQU8sR0FBQztBQUFDLENBQUMiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNTc3NiwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL3NlcnZlci9saWIvdHJhY2UvdHJhY2VyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgRmV0Y2hFdmVudFJlc3VsdCB9IGZyb20gJy4uLy4uL3dlYi90eXBlcydcbmltcG9ydCB0eXBlIHsgVGV4dE1hcFNldHRlciB9IGZyb20gJ0BvcGVudGVsZW1ldHJ5L2FwaSdcbmltcG9ydCB0eXBlIHsgU3BhblR5cGVzIH0gZnJvbSAnLi9jb25zdGFudHMnXG5pbXBvcnQgeyBMb2dTcGFuQWxsb3dMaXN0LCBOZXh0VmFuaWxsYVNwYW5BbGxvd2xpc3QgfSBmcm9tICcuL2NvbnN0YW50cydcblxuaW1wb3J0IHR5cGUge1xuICBDb250ZXh0QVBJLFxuICBTcGFuLFxuICBTcGFuT3B0aW9ucyxcbiAgVHJhY2VyLFxuICBBdHRyaWJ1dGVWYWx1ZSxcbiAgVGV4dE1hcEdldHRlcixcbn0gZnJvbSAnbmV4dC9kaXN0L2NvbXBpbGVkL0BvcGVudGVsZW1ldHJ5L2FwaSdcbmltcG9ydCB7IGlzVGhlbmFibGUgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvbGliL2lzLXRoZW5hYmxlJ1xuXG5sZXQgYXBpOiB0eXBlb2YgaW1wb3J0KCduZXh0L2Rpc3QvY29tcGlsZWQvQG9wZW50ZWxlbWV0cnkvYXBpJylcblxuLy8gd2Ugd2FudCB0byBhbGxvdyB1c2VycyB0byB1c2UgdGhlaXIgb3duIHZlcnNpb24gb2YgQG9wZW50ZWxlbWV0cnkvYXBpIGlmIHRoZXlcbi8vIHdhbnQgdG8sIHNvIHdlIHRyeSB0byByZXF1aXJlIGl0IGZpcnN0LCBhbmQgaWYgaXQgZmFpbHMgd2UgZmFsbCBiYWNrIHRvIHRoZVxuLy8gdmVyc2lvbiB0aGF0IGlzIGJ1bmRsZWQgd2l0aCBOZXh0LmpzXG4vLyB0aGlzIGlzIGJlY2F1c2UgQG9wZW50ZWxlbWV0cnkvYXBpIGhhcyB0byBiZSBzeW5jZWQgd2l0aCB0aGUgdmVyc2lvbiBvZlxuLy8gQG9wZW50ZWxlbWV0cnkvdHJhY2luZyB0aGF0IGlzIHVzZWQsIGFuZCB3ZSBkb24ndCB3YW50IHRvIGZvcmNlIHVzZXJzIHRvIHVzZVxuLy8gdGhlIHZlcnNpb24gdGhhdCBpcyBidW5kbGVkIHdpdGggTmV4dC5qcy5cbi8vIHRoZSBBUEkgaXMgfnN0YWJsZSwgc28gdGhpcyBzaG91bGQgYmUgZmluZVxuaWYgKHByb2Nlc3MuZW52Lk5FWFRfUlVOVElNRSA9PT0gJ2VkZ2UnKSB7XG4gIGFwaSA9IHJlcXVpcmUoJ0BvcGVudGVsZW1ldHJ5L2FwaScpIGFzIHR5cGVvZiBpbXBvcnQoJ0BvcGVudGVsZW1ldHJ5L2FwaScpXG59IGVsc2Uge1xuICB0cnkge1xuICAgIGFwaSA9IHJlcXVpcmUoJ0BvcGVudGVsZW1ldHJ5L2FwaScpIGFzIHR5cGVvZiBpbXBvcnQoJ0BvcGVudGVsZW1ldHJ5L2FwaScpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGFwaSA9XG4gICAgICByZXF1aXJlKCduZXh0L2Rpc3QvY29tcGlsZWQvQG9wZW50ZWxlbWV0cnkvYXBpJykgYXMgdHlwZW9mIGltcG9ydCgnbmV4dC9kaXN0L2NvbXBpbGVkL0BvcGVudGVsZW1ldHJ5L2FwaScpXG4gIH1cbn1cblxuY29uc3QgeyBjb250ZXh0LCBwcm9wYWdhdGlvbiwgdHJhY2UsIFNwYW5TdGF0dXNDb2RlLCBTcGFuS2luZCwgUk9PVF9DT05URVhUIH0gPVxuICBhcGlcblxuZXhwb3J0IGNsYXNzIEJ1YmJsZWRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIHJlYWRvbmx5IGJ1YmJsZT86IGJvb2xlYW4sXG4gICAgcHVibGljIHJlYWRvbmx5IHJlc3VsdD86IEZldGNoRXZlbnRSZXN1bHRcbiAgKSB7XG4gICAgc3VwZXIoKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0J1YmJsZWRFcnJvcihlcnJvcjogdW5rbm93bik6IGVycm9yIGlzIEJ1YmJsZWRFcnJvciB7XG4gIGlmICh0eXBlb2YgZXJyb3IgIT09ICdvYmplY3QnIHx8IGVycm9yID09PSBudWxsKSByZXR1cm4gZmFsc2VcbiAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgQnViYmxlZEVycm9yXG59XG5cbmNvbnN0IGNsb3NlU3BhbldpdGhFcnJvciA9IChzcGFuOiBTcGFuLCBlcnJvcj86IEVycm9yKSA9PiB7XG4gIGlmIChpc0J1YmJsZWRFcnJvcihlcnJvcikgJiYgZXJyb3IuYnViYmxlKSB7XG4gICAgc3Bhbi5zZXRBdHRyaWJ1dGUoJ25leHQuYnViYmxlJywgdHJ1ZSlcbiAgfSBlbHNlIHtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHNwYW4ucmVjb3JkRXhjZXB0aW9uKGVycm9yKVxuICAgIH1cbiAgICBzcGFuLnNldFN0YXR1cyh7IGNvZGU6IFNwYW5TdGF0dXNDb2RlLkVSUk9SLCBtZXNzYWdlOiBlcnJvcj8ubWVzc2FnZSB9KVxuICB9XG4gIHNwYW4uZW5kKClcbn1cblxudHlwZSBUcmFjZXJTcGFuT3B0aW9ucyA9IE9taXQ8U3Bhbk9wdGlvbnMsICdhdHRyaWJ1dGVzJz4gJiB7XG4gIHBhcmVudFNwYW4/OiBTcGFuXG4gIHNwYW5OYW1lPzogc3RyaW5nXG4gIGF0dHJpYnV0ZXM/OiBQYXJ0aWFsPFJlY29yZDxBdHRyaWJ1dGVOYW1lcywgQXR0cmlidXRlVmFsdWUgfCB1bmRlZmluZWQ+PlxuICBoaWRlU3Bhbj86IGJvb2xlYW5cbn1cblxuaW50ZXJmYWNlIE5leHRUcmFjZXIge1xuICBnZXRDb250ZXh0KCk6IENvbnRleHRBUElcblxuICAvKipcbiAgICogSW5zdHJ1bWVudHMgYSBmdW5jdGlvbiBieSBhdXRvbWF0aWNhbGx5IGNyZWF0aW5nIGEgc3BhbiBhY3RpdmF0ZWQgb24gaXRzXG4gICAqIHNjb3BlLlxuICAgKlxuICAgKiBUaGUgc3BhbiB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgZmluaXNoZWQgd2hlbiBvbmUgb2YgdGhlc2UgY29uZGl0aW9ucyBpc1xuICAgKiBtZXQ6XG4gICAqXG4gICAqICogVGhlIGZ1bmN0aW9uIHJldHVybnMgYSBwcm9taXNlLCBpbiB3aGljaCBjYXNlIHRoZSBzcGFuIHdpbGwgZmluaXNoIHdoZW5cbiAgICogdGhlIHByb21pc2UgaXMgcmVzb2x2ZWQgb3IgcmVqZWN0ZWQuXG4gICAqICogVGhlIGZ1bmN0aW9uIHRha2VzIGEgY2FsbGJhY2sgYXMgaXRzIHNlY29uZCBwYXJhbWV0ZXIsIGluIHdoaWNoIGNhc2UgdGhlXG4gICAqIHNwYW4gd2lsbCBmaW5pc2ggd2hlbiB0aGF0IGNhbGxiYWNrIGlzIGNhbGxlZC5cbiAgICogKiBUaGUgZnVuY3Rpb24gZG9lc24ndCBhY2NlcHQgYSBjYWxsYmFjayBhbmQgZG9lc24ndCByZXR1cm4gYSBwcm9taXNlLCBpblxuICAgKiB3aGljaCBjYXNlIHRoZSBzcGFuIHdpbGwgZmluaXNoIGF0IHRoZSBlbmQgb2YgdGhlIGZ1bmN0aW9uIGV4ZWN1dGlvbi5cbiAgICpcbiAgICovXG4gIHRyYWNlPFQ+KFxuICAgIHR5cGU6IFNwYW5UeXBlcyxcbiAgICBmbjogKHNwYW4/OiBTcGFuLCBkb25lPzogKGVycm9yPzogRXJyb3IpID0+IGFueSkgPT4gUHJvbWlzZTxUPlxuICApOiBQcm9taXNlPFQ+XG4gIHRyYWNlPFQ+KFxuICAgIHR5cGU6IFNwYW5UeXBlcyxcbiAgICBmbjogKHNwYW4/OiBTcGFuLCBkb25lPzogKGVycm9yPzogRXJyb3IpID0+IGFueSkgPT4gVFxuICApOiBUXG4gIHRyYWNlPFQ+KFxuICAgIHR5cGU6IFNwYW5UeXBlcyxcbiAgICBvcHRpb25zOiBUcmFjZXJTcGFuT3B0aW9ucyxcbiAgICBmbjogKHNwYW4/OiBTcGFuLCBkb25lPzogKGVycm9yPzogRXJyb3IpID0+IGFueSkgPT4gUHJvbWlzZTxUPlxuICApOiBQcm9taXNlPFQ+XG4gIHRyYWNlPFQ+KFxuICAgIHR5cGU6IFNwYW5UeXBlcyxcbiAgICBvcHRpb25zOiBUcmFjZXJTcGFuT3B0aW9ucyxcbiAgICBmbjogKHNwYW4/OiBTcGFuLCBkb25lPzogKGVycm9yPzogRXJyb3IpID0+IGFueSkgPT4gVFxuICApOiBUXG5cbiAgLyoqXG4gICAqIFdyYXAgYSBmdW5jdGlvbiB0byBhdXRvbWF0aWNhbGx5IGNyZWF0ZSBhIHNwYW4gYWN0aXZhdGVkIG9uIGl0c1xuICAgKiBzY29wZSB3aGVuIGl0J3MgY2FsbGVkLlxuICAgKlxuICAgKiBUaGUgc3BhbiB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgZmluaXNoZWQgd2hlbiBvbmUgb2YgdGhlc2UgY29uZGl0aW9ucyBpc1xuICAgKiBtZXQ6XG4gICAqXG4gICAqICogVGhlIGZ1bmN0aW9uIHJldHVybnMgYSBwcm9taXNlLCBpbiB3aGljaCBjYXNlIHRoZSBzcGFuIHdpbGwgZmluaXNoIHdoZW5cbiAgICogdGhlIHByb21pc2UgaXMgcmVzb2x2ZWQgb3IgcmVqZWN0ZWQuXG4gICAqICogVGhlIGZ1bmN0aW9uIHRha2VzIGEgY2FsbGJhY2sgYXMgaXRzIGxhc3QgcGFyYW1ldGVyLCBpbiB3aGljaCBjYXNlIHRoZVxuICAgKiBzcGFuIHdpbGwgZmluaXNoIHdoZW4gdGhhdCBjYWxsYmFjayBpcyBjYWxsZWQuXG4gICAqICogVGhlIGZ1bmN0aW9uIGRvZXNuJ3QgYWNjZXB0IGEgY2FsbGJhY2sgYW5kIGRvZXNuJ3QgcmV0dXJuIGEgcHJvbWlzZSwgaW5cbiAgICogd2hpY2ggY2FzZSB0aGUgc3BhbiB3aWxsIGZpbmlzaCBhdCB0aGUgZW5kIG9mIHRoZSBmdW5jdGlvbiBleGVjdXRpb24uXG4gICAqL1xuICB3cmFwPFQgPSAoLi4uYXJnczogQXJyYXk8YW55PikgPT4gYW55Pih0eXBlOiBTcGFuVHlwZXMsIGZuOiBUKTogVFxuICB3cmFwPFQgPSAoLi4uYXJnczogQXJyYXk8YW55PikgPT4gYW55PihcbiAgICB0eXBlOiBTcGFuVHlwZXMsXG4gICAgb3B0aW9uczogVHJhY2VyU3Bhbk9wdGlvbnMsXG4gICAgZm46IFRcbiAgKTogVFxuICB3cmFwPFQgPSAoLi4uYXJnczogQXJyYXk8YW55PikgPT4gYW55PihcbiAgICB0eXBlOiBTcGFuVHlwZXMsXG4gICAgb3B0aW9uczogKC4uLmFyZ3M6IGFueVtdKSA9PiBUcmFjZXJTcGFuT3B0aW9ucyxcbiAgICBmbjogVFxuICApOiBUXG5cbiAgLyoqXG4gICAqIFN0YXJ0cyBhbmQgcmV0dXJucyBhIG5ldyBTcGFuIHJlcHJlc2VudGluZyBhIGxvZ2ljYWwgdW5pdCBvZiB3b3JrLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBkbyBOT1QgbW9kaWZ5IHRoZSBjdXJyZW50IENvbnRleHQgYnkgZGVmYXVsdC4gSW4gcmVzdWx0LCBhbnkgaW5uZXIgc3BhbiB3aWxsIG5vdFxuICAgKiBhdXRvbWF0aWNhbGx5IHNldCBpdHMgcGFyZW50IGNvbnRleHQgdG8gdGhlIHNwYW4gY3JlYXRlZCBieSB0aGlzIG1ldGhvZCB1bmxlc3MgbWFudWFsbHkgYWN0aXZhdGVcbiAgICogY29udGV4dCB2aWEgYHRyYWNlci5nZXRDb250ZXh0KCkud2l0aGAuIGB0cmFjZWAsIG9yIGB3cmFwYCBpcyBnZW5lcmFsbHkgcmVjb21tZW5kZWQgYXMgaXQgZ3JhY2VmdWxseVxuICAgKiBoYW5kbGVzIGNvbnRleHQgYWN0aXZhdGlvbi4gKHJlZjogaHR0cHM6Ly9naXRodWIuY29tL29wZW4tdGVsZW1ldHJ5L29wZW50ZWxlbWV0cnktanMvaXNzdWVzLzE5MjMpXG4gICAqL1xuICBzdGFydFNwYW4odHlwZTogU3BhblR5cGVzKTogU3BhblxuICBzdGFydFNwYW4odHlwZTogU3BhblR5cGVzLCBvcHRpb25zOiBUcmFjZXJTcGFuT3B0aW9ucyk6IFNwYW5cblxuICAvKipcbiAgICogUmV0dXJucyBjdXJyZW50bHkgYWN0aXZhdGVkIHNwYW4gaWYgY3VycmVudCBjb250ZXh0IGlzIGluIHRoZSBzY29wZSBvZiB0aGUgc3Bhbi5cbiAgICogUmV0dXJucyB1bmRlZmluZWQgb3RoZXJ3aXNlLlxuICAgKi9cbiAgZ2V0QWN0aXZlU2NvcGVTcGFuKCk6IFNwYW4gfCB1bmRlZmluZWRcblxuICAvKipcbiAgICogUmV0dXJucyB0cmFjZSBwcm9wYWdhdGlvbiBkYXRhIGZvciB0aGUgY3VycmVudGx5IGFjdGl2ZSBjb250ZXh0LiBUaGUgZm9ybWF0IGlzIGVxdWFsIHRvIGRhdGEgcHJvdmlkZWRcbiAgICogdGhyb3VnaCB0aGUgT3BlblRlbGVtZXRyeSBwcm9wYWdhdG9yIEFQSS5cbiAgICovXG4gIGdldFRyYWNlUHJvcGFnYXRpb25EYXRhKCk6IENsaWVudFRyYWNlRGF0YUVudHJ5W11cbn1cblxudHlwZSBOZXh0QXR0cmlidXRlTmFtZXMgPVxuICB8ICduZXh0LnJvdXRlJ1xuICB8ICduZXh0LnBhZ2UnXG4gIHwgJ25leHQucnNjJ1xuICB8ICduZXh0LnNlZ21lbnQnXG4gIHwgJ25leHQuc3Bhbl9uYW1lJ1xuICB8ICduZXh0LnNwYW5fdHlwZSdcbiAgfCAnbmV4dC5jbGllbnRDb21wb25lbnRMb2FkQ291bnQnXG50eXBlIE9URUxBdHRyaWJ1dGVOYW1lcyA9IGBodHRwLiR7c3RyaW5nfWAgfCBgbmV0LiR7c3RyaW5nfWBcbnR5cGUgQXR0cmlidXRlTmFtZXMgPSBOZXh0QXR0cmlidXRlTmFtZXMgfCBPVEVMQXR0cmlidXRlTmFtZXNcblxuLyoqIHdlIHVzZSB0aGlzIG1hcCB0byBwcm9wYWdhdGUgYXR0cmlidXRlcyBmcm9tIG5lc3RlZCBzcGFucyB0byB0aGUgdG9wIHNwYW4gKi9cbmNvbnN0IHJvb3RTcGFuQXR0cmlidXRlc1N0b3JlID0gbmV3IE1hcDxcbiAgbnVtYmVyLFxuICBNYXA8QXR0cmlidXRlTmFtZXMsIEF0dHJpYnV0ZVZhbHVlIHwgdW5kZWZpbmVkPlxuPigpXG5jb25zdCByb290U3BhbklkS2V5ID0gYXBpLmNyZWF0ZUNvbnRleHRLZXkoJ25leHQucm9vdFNwYW5JZCcpXG5sZXQgbGFzdFNwYW5JZCA9IDBcbmNvbnN0IGdldFNwYW5JZCA9ICgpID0+IGxhc3RTcGFuSWQrK1xuXG5leHBvcnQgaW50ZXJmYWNlIENsaWVudFRyYWNlRGF0YUVudHJ5IHtcbiAga2V5OiBzdHJpbmdcbiAgdmFsdWU6IHN0cmluZ1xufVxuXG5jb25zdCBjbGllbnRUcmFjZURhdGFTZXR0ZXI6IFRleHRNYXBTZXR0ZXI8Q2xpZW50VHJhY2VEYXRhRW50cnlbXT4gPSB7XG4gIHNldChjYXJyaWVyLCBrZXksIHZhbHVlKSB7XG4gICAgY2Fycmllci5wdXNoKHtcbiAgICAgIGtleSxcbiAgICAgIHZhbHVlLFxuICAgIH0pXG4gIH0sXG59XG5cbmNsYXNzIE5leHRUcmFjZXJJbXBsIGltcGxlbWVudHMgTmV4dFRyYWNlciB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGluc3RhbmNlIHRvIHRoZSB0cmFjZSB3aXRoIGNvbmZpZ3VyZWQgbmFtZS5cbiAgICogU2luY2Ugd3JhcCAvIHRyYWNlIGNhbiBiZSBkZWZpbmVkIGluIGFueSBwbGFjZSBwcmlvciB0byBhY3R1YWwgdHJhY2Ugc3Vic2NyaWJlciBpbml0aWFsaXphdGlvbixcbiAgICogVGhpcyBzaG91bGQgYmUgbGF6aWx5IGV2YWx1YXRlZC5cbiAgICovXG4gIHByaXZhdGUgZ2V0VHJhY2VySW5zdGFuY2UoKTogVHJhY2VyIHtcbiAgICByZXR1cm4gdHJhY2UuZ2V0VHJhY2VyKCduZXh0LmpzJywgJzAuMC4xJylcbiAgfVxuXG4gIHB1YmxpYyBnZXRDb250ZXh0KCk6IENvbnRleHRBUEkge1xuICAgIHJldHVybiBjb250ZXh0XG4gIH1cblxuICBwdWJsaWMgZ2V0VHJhY2VQcm9wYWdhdGlvbkRhdGEoKTogQ2xpZW50VHJhY2VEYXRhRW50cnlbXSB7XG4gICAgY29uc3QgYWN0aXZlQ29udGV4dCA9IGNvbnRleHQuYWN0aXZlKClcbiAgICBjb25zdCBlbnRyaWVzOiBDbGllbnRUcmFjZURhdGFFbnRyeVtdID0gW11cbiAgICBwcm9wYWdhdGlvbi5pbmplY3QoYWN0aXZlQ29udGV4dCwgZW50cmllcywgY2xpZW50VHJhY2VEYXRhU2V0dGVyKVxuICAgIHJldHVybiBlbnRyaWVzXG4gIH1cblxuICBwdWJsaWMgZ2V0QWN0aXZlU2NvcGVTcGFuKCk6IFNwYW4gfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0cmFjZS5nZXRTcGFuKGNvbnRleHQ/LmFjdGl2ZSgpKVxuICB9XG5cbiAgcHVibGljIHdpdGhQcm9wYWdhdGVkQ29udGV4dDxULCBDPihcbiAgICBjYXJyaWVyOiBDLFxuICAgIGZuOiAoKSA9PiBULFxuICAgIGdldHRlcj86IFRleHRNYXBHZXR0ZXI8Qz5cbiAgKTogVCB7XG4gICAgY29uc3QgYWN0aXZlQ29udGV4dCA9IGNvbnRleHQuYWN0aXZlKClcbiAgICBpZiAodHJhY2UuZ2V0U3BhbkNvbnRleHQoYWN0aXZlQ29udGV4dCkpIHtcbiAgICAgIC8vIEFjdGl2ZSBzcGFuIGlzIGFscmVhZHkgc2V0LCB0b28gbGF0ZSB0byBwcm9wYWdhdGUuXG4gICAgICByZXR1cm4gZm4oKVxuICAgIH1cbiAgICBjb25zdCByZW1vdGVDb250ZXh0ID0gcHJvcGFnYXRpb24uZXh0cmFjdChhY3RpdmVDb250ZXh0LCBjYXJyaWVyLCBnZXR0ZXIpXG4gICAgcmV0dXJuIGNvbnRleHQud2l0aChyZW1vdGVDb250ZXh0LCBmbilcbiAgfVxuXG4gIC8vIFRyYWNlLCB3cmFwIGltcGxlbWVudGF0aW9uIGlzIGluc3BpcmVkIGJ5IGRhdGFkb2cgdHJhY2UgaW1wbGVtZW50YXRpb25cbiAgLy8gKGh0dHBzOi8vZGF0YWRvZ2hxLmRldi9kZC10cmFjZS1qcy9pbnRlcmZhY2VzL3RyYWNlci5odG1sI3RyYWNlKS5cbiAgcHVibGljIHRyYWNlPFQ+KFxuICAgIHR5cGU6IFNwYW5UeXBlcyxcbiAgICBmbjogKHNwYW4/OiBTcGFuLCBkb25lPzogKGVycm9yPzogRXJyb3IpID0+IGFueSkgPT4gUHJvbWlzZTxUPlxuICApOiBQcm9taXNlPFQ+XG4gIHB1YmxpYyB0cmFjZTxUPihcbiAgICB0eXBlOiBTcGFuVHlwZXMsXG4gICAgZm46IChzcGFuPzogU3BhbiwgZG9uZT86IChlcnJvcj86IEVycm9yKSA9PiBhbnkpID0+IFRcbiAgKTogVFxuICBwdWJsaWMgdHJhY2U8VD4oXG4gICAgdHlwZTogU3BhblR5cGVzLFxuICAgIG9wdGlvbnM6IFRyYWNlclNwYW5PcHRpb25zLFxuICAgIGZuOiAoc3Bhbj86IFNwYW4sIGRvbmU/OiAoZXJyb3I/OiBFcnJvcikgPT4gYW55KSA9PiBQcm9taXNlPFQ+XG4gICk6IFByb21pc2U8VD5cbiAgcHVibGljIHRyYWNlPFQ+KFxuICAgIHR5cGU6IFNwYW5UeXBlcyxcbiAgICBvcHRpb25zOiBUcmFjZXJTcGFuT3B0aW9ucyxcbiAgICBmbjogKHNwYW4/OiBTcGFuLCBkb25lPzogKGVycm9yPzogRXJyb3IpID0+IGFueSkgPT4gVFxuICApOiBUXG4gIHB1YmxpYyB0cmFjZTxUPiguLi5hcmdzOiBBcnJheTxhbnk+KSB7XG4gICAgY29uc3QgW3R5cGUsIGZuT3JPcHRpb25zLCBmbk9yRW1wdHldID0gYXJnc1xuXG4gICAgLy8gY29lcmNlIG9wdGlvbnMgZm9ybSBvdmVybG9hZFxuICAgIGNvbnN0IHtcbiAgICAgIGZuLFxuICAgICAgb3B0aW9ucyxcbiAgICB9OiB7XG4gICAgICBmbjogKHNwYW4/OiBTcGFuLCBkb25lPzogKGVycm9yPzogRXJyb3IpID0+IGFueSkgPT4gVCB8IFByb21pc2U8VD5cbiAgICAgIG9wdGlvbnM6IFRyYWNlclNwYW5PcHRpb25zXG4gICAgfSA9XG4gICAgICB0eXBlb2YgZm5Pck9wdGlvbnMgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyB7XG4gICAgICAgICAgICBmbjogZm5Pck9wdGlvbnMsXG4gICAgICAgICAgICBvcHRpb25zOiB7fSxcbiAgICAgICAgICB9XG4gICAgICAgIDoge1xuICAgICAgICAgICAgZm46IGZuT3JFbXB0eSxcbiAgICAgICAgICAgIG9wdGlvbnM6IHsgLi4uZm5Pck9wdGlvbnMgfSxcbiAgICAgICAgICB9XG5cbiAgICBjb25zdCBzcGFuTmFtZSA9IG9wdGlvbnMuc3Bhbk5hbWUgPz8gdHlwZVxuXG4gICAgaWYgKFxuICAgICAgKCFOZXh0VmFuaWxsYVNwYW5BbGxvd2xpc3QuaW5jbHVkZXModHlwZSkgJiZcbiAgICAgICAgcHJvY2Vzcy5lbnYuTkVYVF9PVEVMX1ZFUkJPU0UgIT09ICcxJykgfHxcbiAgICAgIG9wdGlvbnMuaGlkZVNwYW5cbiAgICApIHtcbiAgICAgIHJldHVybiBmbigpXG4gICAgfVxuXG4gICAgLy8gVHJ5aW5nIHRvIGdldCBhY3RpdmUgc2NvcGVkIHNwYW4gdG8gYXNzaWduIHBhcmVudC4gSWYgb3B0aW9uIHNwZWNpZmllcyBwYXJlbnQgc3BhbiBtYW51YWxseSwgd2lsbCB0cnkgdG8gdXNlIGl0LlxuICAgIGxldCBzcGFuQ29udGV4dCA9IHRoaXMuZ2V0U3BhbkNvbnRleHQoXG4gICAgICBvcHRpb25zPy5wYXJlbnRTcGFuID8/IHRoaXMuZ2V0QWN0aXZlU2NvcGVTcGFuKClcbiAgICApXG4gICAgbGV0IGlzUm9vdFNwYW4gPSBmYWxzZVxuXG4gICAgaWYgKCFzcGFuQ29udGV4dCkge1xuICAgICAgc3BhbkNvbnRleHQgPSBjb250ZXh0Py5hY3RpdmUoKSA/PyBST09UX0NPTlRFWFRcbiAgICAgIGlzUm9vdFNwYW4gPSB0cnVlXG4gICAgfSBlbHNlIGlmICh0cmFjZS5nZXRTcGFuQ29udGV4dChzcGFuQ29udGV4dCk/LmlzUmVtb3RlKSB7XG4gICAgICBpc1Jvb3RTcGFuID0gdHJ1ZVxuICAgIH1cblxuICAgIGNvbnN0IHNwYW5JZCA9IGdldFNwYW5JZCgpXG5cbiAgICBvcHRpb25zLmF0dHJpYnV0ZXMgPSB7XG4gICAgICAnbmV4dC5zcGFuX25hbWUnOiBzcGFuTmFtZSxcbiAgICAgICduZXh0LnNwYW5fdHlwZSc6IHR5cGUsXG4gICAgICAuLi5vcHRpb25zLmF0dHJpYnV0ZXMsXG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnRleHQud2l0aChzcGFuQ29udGV4dC5zZXRWYWx1ZShyb290U3BhbklkS2V5LCBzcGFuSWQpLCAoKSA9PlxuICAgICAgdGhpcy5nZXRUcmFjZXJJbnN0YW5jZSgpLnN0YXJ0QWN0aXZlU3BhbihcbiAgICAgICAgc3Bhbk5hbWUsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIChzcGFuOiBTcGFuKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3RhcnRUaW1lID1cbiAgICAgICAgICAgICdwZXJmb3JtYW5jZScgaW4gZ2xvYmFsVGhpcyAmJiAnbWVhc3VyZScgaW4gcGVyZm9ybWFuY2VcbiAgICAgICAgICAgICAgPyBnbG9iYWxUaGlzLnBlcmZvcm1hbmNlLm5vdygpXG4gICAgICAgICAgICAgIDogdW5kZWZpbmVkXG5cbiAgICAgICAgICBjb25zdCBvbkNsZWFudXAgPSAoKSA9PiB7XG4gICAgICAgICAgICByb290U3BhbkF0dHJpYnV0ZXNTdG9yZS5kZWxldGUoc3BhbklkKVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBzdGFydFRpbWUgJiZcbiAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTkVYVF9PVEVMX1BFUkZPUk1BTkNFX1BSRUZJWCAmJlxuICAgICAgICAgICAgICBMb2dTcGFuQWxsb3dMaXN0LmluY2x1ZGVzKHR5cGUgfHwgKCcnIGFzIGFueSkpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgcGVyZm9ybWFuY2UubWVhc3VyZShcbiAgICAgICAgICAgICAgICBgJHtwcm9jZXNzLmVudi5ORVhUX09URUxfUEVSRk9STUFOQ0VfUFJFRklYfTpuZXh0LSR7KFxuICAgICAgICAgICAgICAgICAgdHlwZS5zcGxpdCgnLicpLnBvcCgpIHx8ICcnXG4gICAgICAgICAgICAgICAgKS5yZXBsYWNlKFxuICAgICAgICAgICAgICAgICAgL1tBLVpdL2csXG4gICAgICAgICAgICAgICAgICAobWF0Y2g6IHN0cmluZykgPT4gJy0nICsgbWF0Y2gudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgICAgICl9YCxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgICAgZW5kOiBwZXJmb3JtYW5jZS5ub3coKSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNSb290U3Bhbikge1xuICAgICAgICAgICAgcm9vdFNwYW5BdHRyaWJ1dGVzU3RvcmUuc2V0KFxuICAgICAgICAgICAgICBzcGFuSWQsXG4gICAgICAgICAgICAgIG5ldyBNYXAoXG4gICAgICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMob3B0aW9ucy5hdHRyaWJ1dGVzID8/IHt9KSBhcyBbXG4gICAgICAgICAgICAgICAgICBBdHRyaWJ1dGVOYW1lcyxcbiAgICAgICAgICAgICAgICAgIEF0dHJpYnV0ZVZhbHVlIHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIF1bXVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoZm4ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICByZXR1cm4gZm4oc3BhbiwgKGVycikgPT4gY2xvc2VTcGFuV2l0aEVycm9yKHNwYW4sIGVycikpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGZuKHNwYW4pXG4gICAgICAgICAgICBpZiAoaXNUaGVuYWJsZShyZXN1bHQpKSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoZXJlJ3MgZXJyb3IgbWFrZSBzdXJlIGl0IHRocm93c1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICAgICAgICAgICAgLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgc3Bhbi5lbmQoKVxuICAgICAgICAgICAgICAgICAgLy8gTmVlZCB0byBwYXNzIGRvd24gdGhlIHByb21pc2UgcmVzdWx0LFxuICAgICAgICAgICAgICAgICAgLy8gaXQgY291bGQgYmUgcmVhY3Qgc3RyZWFtIHJlc3BvbnNlIHdpdGggZXJyb3IgeyBlcnJvciwgc3RyZWFtIH1cbiAgICAgICAgICAgICAgICAgIHJldHVybiByZXNcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICBjbG9zZVNwYW5XaXRoRXJyb3Ioc3BhbiwgZXJyKVxuICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuZmluYWxseShvbkNsZWFudXApXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzcGFuLmVuZCgpXG4gICAgICAgICAgICAgIG9uQ2xlYW51cCgpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgICAgICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgICAgICAgICAgY2xvc2VTcGFuV2l0aEVycm9yKHNwYW4sIGVycilcbiAgICAgICAgICAgIG9uQ2xlYW51cCgpXG4gICAgICAgICAgICB0aHJvdyBlcnJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIClcbiAgICApXG4gIH1cblxuICBwdWJsaWMgd3JhcDxUID0gKC4uLmFyZ3M6IEFycmF5PGFueT4pID0+IGFueT4odHlwZTogU3BhblR5cGVzLCBmbjogVCk6IFRcbiAgcHVibGljIHdyYXA8VCA9ICguLi5hcmdzOiBBcnJheTxhbnk+KSA9PiBhbnk+KFxuICAgIHR5cGU6IFNwYW5UeXBlcyxcbiAgICBvcHRpb25zOiBUcmFjZXJTcGFuT3B0aW9ucyxcbiAgICBmbjogVFxuICApOiBUXG4gIHB1YmxpYyB3cmFwPFQgPSAoLi4uYXJnczogQXJyYXk8YW55PikgPT4gYW55PihcbiAgICB0eXBlOiBTcGFuVHlwZXMsXG4gICAgb3B0aW9uczogKC4uLmFyZ3M6IGFueVtdKSA9PiBUcmFjZXJTcGFuT3B0aW9ucyxcbiAgICBmbjogVFxuICApOiBUXG4gIHB1YmxpYyB3cmFwKC4uLmFyZ3M6IEFycmF5PGFueT4pIHtcbiAgICBjb25zdCB0cmFjZXIgPSB0aGlzXG4gICAgY29uc3QgW25hbWUsIG9wdGlvbnMsIGZuXSA9XG4gICAgICBhcmdzLmxlbmd0aCA9PT0gMyA/IGFyZ3MgOiBbYXJnc1swXSwge30sIGFyZ3NbMV1dXG5cbiAgICBpZiAoXG4gICAgICAhTmV4dFZhbmlsbGFTcGFuQWxsb3dsaXN0LmluY2x1ZGVzKG5hbWUpICYmXG4gICAgICBwcm9jZXNzLmVudi5ORVhUX09URUxfVkVSQk9TRSAhPT0gJzEnXG4gICAgKSB7XG4gICAgICByZXR1cm4gZm5cbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKHRoaXM6IGFueSkge1xuICAgICAgbGV0IG9wdGlvbnNPYmogPSBvcHRpb25zXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnNPYmogPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9wdGlvbnNPYmogPSBvcHRpb25zT2JqLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH1cblxuICAgICAgY29uc3QgbGFzdEFyZ0lkID0gYXJndW1lbnRzLmxlbmd0aCAtIDFcbiAgICAgIGNvbnN0IGNiID0gYXJndW1lbnRzW2xhc3RBcmdJZF1cblxuICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb25zdCBzY29wZUJvdW5kQ2IgPSB0cmFjZXIuZ2V0Q29udGV4dCgpLmJpbmQoY29udGV4dC5hY3RpdmUoKSwgY2IpXG4gICAgICAgIHJldHVybiB0cmFjZXIudHJhY2UobmFtZSwgb3B0aW9uc09iaiwgKF9zcGFuLCBkb25lKSA9PiB7XG4gICAgICAgICAgYXJndW1lbnRzW2xhc3RBcmdJZF0gPSBmdW5jdGlvbiAoZXJyOiBhbnkpIHtcbiAgICAgICAgICAgIGRvbmU/LihlcnIpXG4gICAgICAgICAgICByZXR1cm4gc2NvcGVCb3VuZENiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRyYWNlci50cmFjZShuYW1lLCBvcHRpb25zT2JqLCAoKSA9PiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzdGFydFNwYW4odHlwZTogU3BhblR5cGVzKTogU3BhblxuICBwdWJsaWMgc3RhcnRTcGFuKHR5cGU6IFNwYW5UeXBlcywgb3B0aW9uczogVHJhY2VyU3Bhbk9wdGlvbnMpOiBTcGFuXG4gIHB1YmxpYyBzdGFydFNwYW4oLi4uYXJnczogQXJyYXk8YW55Pik6IFNwYW4ge1xuICAgIGNvbnN0IFt0eXBlLCBvcHRpb25zXTogW3N0cmluZywgVHJhY2VyU3Bhbk9wdGlvbnMgfCB1bmRlZmluZWRdID0gYXJncyBhcyBhbnlcblxuICAgIGNvbnN0IHNwYW5Db250ZXh0ID0gdGhpcy5nZXRTcGFuQ29udGV4dChcbiAgICAgIG9wdGlvbnM/LnBhcmVudFNwYW4gPz8gdGhpcy5nZXRBY3RpdmVTY29wZVNwYW4oKVxuICAgIClcbiAgICByZXR1cm4gdGhpcy5nZXRUcmFjZXJJbnN0YW5jZSgpLnN0YXJ0U3Bhbih0eXBlLCBvcHRpb25zLCBzcGFuQ29udGV4dClcbiAgfVxuXG4gIHByaXZhdGUgZ2V0U3BhbkNvbnRleHQocGFyZW50U3Bhbj86IFNwYW4pIHtcbiAgICBjb25zdCBzcGFuQ29udGV4dCA9IHBhcmVudFNwYW5cbiAgICAgID8gdHJhY2Uuc2V0U3Bhbihjb250ZXh0LmFjdGl2ZSgpLCBwYXJlbnRTcGFuKVxuICAgICAgOiB1bmRlZmluZWRcblxuICAgIHJldHVybiBzcGFuQ29udGV4dFxuICB9XG5cbiAgcHVibGljIGdldFJvb3RTcGFuQXR0cmlidXRlcygpIHtcbiAgICBjb25zdCBzcGFuSWQgPSBjb250ZXh0LmFjdGl2ZSgpLmdldFZhbHVlKHJvb3RTcGFuSWRLZXkpIGFzIG51bWJlclxuICAgIHJldHVybiByb290U3BhbkF0dHJpYnV0ZXNTdG9yZS5nZXQoc3BhbklkKVxuICB9XG5cbiAgcHVibGljIHNldFJvb3RTcGFuQXR0cmlidXRlKGtleTogQXR0cmlidXRlTmFtZXMsIHZhbHVlOiBBdHRyaWJ1dGVWYWx1ZSkge1xuICAgIGNvbnN0IHNwYW5JZCA9IGNvbnRleHQuYWN0aXZlKCkuZ2V0VmFsdWUocm9vdFNwYW5JZEtleSkgYXMgbnVtYmVyXG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHJvb3RTcGFuQXR0cmlidXRlc1N0b3JlLmdldChzcGFuSWQpXG4gICAgaWYgKGF0dHJpYnV0ZXMpIHtcbiAgICAgIGF0dHJpYnV0ZXMuc2V0KGtleSwgdmFsdWUpXG4gICAgfVxuICB9XG59XG5cbmNvbnN0IGdldFRyYWNlciA9ICgoKSA9PiB7XG4gIGNvbnN0IHRyYWNlciA9IG5ldyBOZXh0VHJhY2VySW1wbCgpXG5cbiAgcmV0dXJuICgpID0+IHRyYWNlclxufSkoKVxuXG5leHBvcnQgeyBnZXRUcmFjZXIsIFNwYW5TdGF0dXNDb2RlLCBTcGFuS2luZCB9XG5leHBvcnQgdHlwZSB7IE5leHRUcmFjZXIsIFNwYW4sIFNwYW5PcHRpb25zLCBDb250ZXh0QVBJLCBUcmFjZXJTcGFuT3B0aW9ucyB9XG4iXSwibmFtZXMiOlsiTG9nU3BhbkFsbG93TGlzdCIsIk5leHRWYW5pbGxhU3BhbkFsbG93bGlzdCIsImlzVGhlbmFibGUiLCJhcGkiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9SVU5USU1FIiwicmVxdWlyZSIsImVyciIsImNvbnRleHQiLCJwcm9wYWdhdGlvbiIsInRyYWNlIiwiU3BhblN0YXR1c0NvZGUiLCJTcGFuS2luZCIsIlJPT1RfQ09OVEVYVCIsIkJ1YmJsZWRFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJidWJibGUiLCJyZXN1bHQiLCJpc0J1YmJsZWRFcnJvciIsImVycm9yIiwiY2xvc2VTcGFuV2l0aEVycm9yIiwic3BhbiIsInNldEF0dHJpYnV0ZSIsInJlY29yZEV4Y2VwdGlvbiIsInNldFN0YXR1cyIsImNvZGUiLCJFUlJPUiIsIm1lc3NhZ2UiLCJlbmQiLCJyb290U3BhbkF0dHJpYnV0ZXNTdG9yZSIsIk1hcCIsInJvb3RTcGFuSWRLZXkiLCJjcmVhdGVDb250ZXh0S2V5IiwibGFzdFNwYW5JZCIsImdldFNwYW5JZCIsImNsaWVudFRyYWNlRGF0YVNldHRlciIsInNldCIsImNhcnJpZXIiLCJrZXkiLCJ2YWx1ZSIsInB1c2giLCJOZXh0VHJhY2VySW1wbCIsImdldFRyYWNlckluc3RhbmNlIiwiZ2V0VHJhY2VyIiwiZ2V0Q29udGV4dCIsImdldFRyYWNlUHJvcGFnYXRpb25EYXRhIiwiYWN0aXZlQ29udGV4dCIsImFjdGl2ZSIsImVudHJpZXMiLCJpbmplY3QiLCJnZXRBY3RpdmVTY29wZVNwYW4iLCJnZXRTcGFuIiwid2l0aFByb3BhZ2F0ZWRDb250ZXh0IiwiZm4iLCJnZXR0ZXIiLCJnZXRTcGFuQ29udGV4dCIsInJlbW90ZUNvbnRleHQiLCJleHRyYWN0Iiwid2l0aCIsImFyZ3MiLCJ0eXBlIiwiZm5Pck9wdGlvbnMiLCJmbk9yRW1wdHkiLCJvcHRpb25zIiwic3Bhbk5hbWUiLCJpbmNsdWRlcyIsIk5FWFRfT1RFTF9WRVJCT1NFIiwiaGlkZVNwYW4iLCJzcGFuQ29udGV4dCIsInBhcmVudFNwYW4iLCJpc1Jvb3RTcGFuIiwiaXNSZW1vdGUiLCJzcGFuSWQiLCJhdHRyaWJ1dGVzIiwic2V0VmFsdWUiLCJzdGFydEFjdGl2ZVNwYW4iLCJzdGFydFRpbWUiLCJnbG9iYWxUaGlzIiwicGVyZm9ybWFuY2UiLCJub3ciLCJ1bmRlZmluZWQiLCJvbkNsZWFudXAiLCJkZWxldGUiLCJORVhUX09URUxfUEVSRk9STUFOQ0VfUFJFRklYIiwibWVhc3VyZSIsInNwbGl0IiwicG9wIiwicmVwbGFjZSIsIm1hdGNoIiwidG9Mb3dlckNhc2UiLCJzdGFydCIsIk9iamVjdCIsImxlbmd0aCIsInRoZW4iLCJyZXMiLCJjYXRjaCIsImZpbmFsbHkiLCJ3cmFwIiwidHJhY2VyIiwibmFtZSIsIm9wdGlvbnNPYmoiLCJhcHBseSIsImFyZ3VtZW50cyIsImxhc3RBcmdJZCIsImNiIiwic2NvcGVCb3VuZENiIiwiYmluZCIsIl9zcGFuIiwiZG9uZSIsInN0YXJ0U3BhbiIsInNldFNwYW4iLCJnZXRSb290U3BhbkF0dHJpYnV0ZXMiLCJnZXRWYWx1ZSIsImdldCIsInNldFJvb3RTcGFuQXR0cmlidXRlIl0sIm1hcHBpbmdzIjoi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c2V0IjogeyJsaW5lIjogNjAwNSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL3NoYXJlZC9saWIvZGVlcC1mcmVlemUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBEZWVwUmVhZG9ubHkgfSBmcm9tICcuL2RlZXAtcmVhZG9ubHknXG5cbi8qKlxuICogUmVjdXJzaXZlbHkgZnJlZXplcyBhbiBvYmplY3QgYW5kIGFsbCBvZiBpdHMgcHJvcGVydGllcy4gVGhpcyBwcmV2ZW50cyB0aGVcbiAqIG9iamVjdCBmcm9tIGJlaW5nIG1vZGlmaWVkIGF0IHJ1bnRpbWUuIFdoZW4gdGhlIEpTIHJ1bnRpbWUgaXMgcnVubmluZyBpblxuICogc3RyaWN0IG1vZGUsIGFueSBhdHRlbXB0cyB0byBtb2RpZnkgYSBmcm96ZW4gb2JqZWN0IHdpbGwgdGhyb3cgYW4gZXJyb3IuXG4gKlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvZnJlZXplXG4gKiBAcGFyYW0gb2JqIFRoZSBvYmplY3QgdG8gZnJlZXplLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVlcEZyZWV6ZTxUIGV4dGVuZHMgb2JqZWN0PihvYmo6IFQpOiBEZWVwUmVhZG9ubHk8VD4ge1xuICAvLyBJZiB0aGUgb2JqZWN0IGlzIGFscmVhZHkgZnJvemVuLCB0aGVyZSdzIG5vIG5lZWQgdG8gZnJlZXplIGl0IGFnYWluLlxuICBpZiAoT2JqZWN0LmlzRnJvemVuKG9iaikpIHJldHVybiBvYmogYXMgRGVlcFJlYWRvbmx5PFQ+XG5cbiAgLy8gQW4gYXJyYXkgaXMgYW4gb2JqZWN0LCBidXQgd2UgYWxzbyB3YW50IHRvIGZyZWV6ZSBlYWNoIGVsZW1lbnQgaW4gdGhlIGFycmF5XG4gIC8vIGFzIHdlbGwuXG4gIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2Ygb2JqKSB7XG4gICAgICBpZiAoIWl0ZW0gfHwgdHlwZW9mIGl0ZW0gIT09ICdvYmplY3QnKSBjb250aW51ZVxuICAgICAgZGVlcEZyZWV6ZShpdGVtKVxuICAgIH1cblxuICAgIHJldHVybiBPYmplY3QuZnJlZXplKG9iaikgYXMgRGVlcFJlYWRvbmx5PFQ+XG4gIH1cblxuICBmb3IgKGNvbnN0IHZhbHVlIG9mIE9iamVjdC52YWx1ZXMob2JqKSkge1xuICAgIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JykgY29udGludWVcbiAgICBkZWVwRnJlZXplKHZhbHVlKVxuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5mcmVlemUob2JqKSBhcyBEZWVwUmVhZG9ubHk8VD5cbn1cbiJdLCJuYW1lcyI6WyJkZWVwRnJlZXplIiwib2JqIiwiT2JqZWN0IiwiaXNGcm96ZW4iLCJBcnJheSIsImlzQXJyYXkiLCJpdGVtIiwiZnJlZXplIiwidmFsdWUiLCJ2YWx1ZXMiXSwibWFwcGluZ3MiOiJBQUVBOzs7Ozs7O0NBT0MsR0FDRDs7O0FBQU8sU0FBU0EsV0FBNkJDLEdBQU07SUFDakQsdUVBQXVFO0lBQ3ZFLElBQUlDLE9BQU9DLFFBQVEsQ0FBQ0YsTUFBTSxPQUFPQTtJQUVqQyw4RUFBOEU7SUFDOUUsV0FBVztJQUNYLElBQUlHLE1BQU1DLE9BQU8sQ0FBQ0osTUFBTTtRQUN0QixLQUFLLE1BQU1LLFFBQVFMLElBQUs7WUFDdEIsSUFBSSxDQUFDSyxRQUFRLE9BQU9BLFNBQVMsVUFBVTtZQUN2Q04sV0FBV007UUFDYjtRQUVBLE9BQU9KLE9BQU9LLE1BQU0sQ0FBQ047SUFDdkI7SUFFQSxLQUFLLE1BQU1PLFNBQVNOLE9BQU9PLE1BQU0sQ0FBQ1IsS0FBTTtRQUN0QyxJQUFJLENBQUNPLFNBQVMsT0FBT0EsVUFBVSxVQUFVO1FBQ3pDUixXQUFXUTtJQUNiO0lBRUEsT0FBT04sT0FBT0ssTUFBTSxDQUFDTjtBQUN2QiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA2MDM3LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zcmMvbGliL21ldGFkYXRhL2Nsb25lLW1ldGFkYXRhLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHtcbiAgUmVzb2x2ZWRNZXRhZGF0YSxcbiAgUmVzb2x2ZWRWaWV3cG9ydCxcbn0gZnJvbSAnLi90eXBlcy9tZXRhZGF0YS1pbnRlcmZhY2UnXG5cbmNvbnN0IFRZUEVfVVJMID0gJ19fTUVUQURBVEFfVVJMJ1xuXG5mdW5jdGlvbiByZXBsYWNlcihfa2V5OiBzdHJpbmcsIHZhbDogYW55KSB7XG4gIC8vIGNsb25lIFVSTCBhcyBzdHJpbmcgYnV0IHJlY292ZXIgaXQgYXMgVVJMXG4gIGlmICh2YWwgaW5zdGFuY2VvZiBVUkwpIHtcbiAgICByZXR1cm4geyBfdHlwZTogVFlQRV9VUkwsIHZhbHVlOiB2YWwuaHJlZiB9XG4gIH1cbiAgcmV0dXJuIHZhbFxufVxuXG5mdW5jdGlvbiByZXZpdmVyKF9rZXk6IHN0cmluZywgdmFsOiBhbnkpIHtcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbCAmJiB2YWwuX3R5cGUgPT09IFRZUEVfVVJMKSB7XG4gICAgcmV0dXJuIG5ldyBVUkwodmFsLnZhbHVlKVxuICB9XG4gIHJldHVybiB2YWxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNsb25lTWV0YWRhdGE8VCBleHRlbmRzIFJlc29sdmVkTWV0YWRhdGEgfCBSZXNvbHZlZFZpZXdwb3J0PihcbiAgbWV0YWRhdGE6IFRcbik6IFQge1xuICBjb25zdCBqc29uU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEsIHJlcGxhY2VyKVxuICByZXR1cm4gSlNPTi5wYXJzZShqc29uU3RyaW5nLCByZXZpdmVyKVxufVxuIl0sIm5hbWVzIjpbIlRZUEVfVVJMIiwicmVwbGFjZXIiLCJfa2V5IiwidmFsIiwiVVJMIiwiX3R5cGUiLCJ2YWx1ZSIsImhyZWYiLCJyZXZpdmVyIiwiY2xvbmVNZXRhZGF0YSIsIm1ldGFkYXRhIiwianNvblN0cmluZyIsIkpTT04iLCJzdHJpbmdpZnkiLCJwYXJzZSJdLCJtYXBwaW5ncyI6Ijs7O0FBS0EsTUFBTUEsV0FBVztBQUVqQixTQUFTQyxTQUFTQyxJQUFZLEVBQUVDLEdBQVE7SUFDdEMsNENBQTRDO0lBQzVDLElBQUlBLGVBQWVDLEtBQUs7UUFDdEIsT0FBTztZQUFFQyxPQUFPTDtZQUFVTSxPQUFPSCxJQUFJSSxJQUFJO1FBQUM7SUFDNUM7SUFDQSxPQUFPSjtBQUNUO0FBRUEsU0FBU0ssUUFBUU4sSUFBWSxFQUFFQyxHQUFRO0lBQ3JDLElBQUksT0FBT0EsUUFBUSxZQUFZQSxRQUFRLFFBQVFBLElBQUlFLEtBQUssS0FBS0wsVUFBVTtRQUNyRSxPQUFPLElBQUlJLElBQUlELElBQUlHLEtBQUs7SUFDMUI7SUFDQSxPQUFPSDtBQUNUO0FBRU8sU0FBU00sY0FDZEMsUUFBVztJQUVYLE1BQU1DLGFBQWFDLEtBQUtDLFNBQVMsQ0FBQ0gsVUFBVVQ7SUFDNUMsT0FBT1csS0FBS0UsS0FBSyxDQUFDSCxZQUFZSDtBQUNoQyIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA2MDY1LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zcmMvbGliL21ldGFkYXRhL3Jlc29sdmUtbWV0YWRhdGEudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUge1xuICBNZXRhZGF0YSxcbiAgUmVzb2x2ZWRNZXRhZGF0YSxcbiAgUmVzb2x2ZWRWaWV3cG9ydCxcbiAgUmVzb2x2aW5nTWV0YWRhdGEsXG4gIFJlc29sdmluZ1ZpZXdwb3J0LFxuICBWaWV3cG9ydCxcbn0gZnJvbSAnLi90eXBlcy9tZXRhZGF0YS1pbnRlcmZhY2UnXG5pbXBvcnQgdHlwZSB7IE1ldGFkYXRhSW1hZ2VNb2R1bGUgfSBmcm9tICcuLi8uLi9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbWV0YWRhdGEvdHlwZXMnXG5pbXBvcnQgdHlwZSB7IEdldER5bmFtaWNQYXJhbUZyb21TZWdtZW50IH0gZnJvbSAnLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvYXBwLXJlbmRlcidcbmltcG9ydCB0eXBlIHsgVHdpdHRlciB9IGZyb20gJy4vdHlwZXMvdHdpdHRlci10eXBlcydcbmltcG9ydCB0eXBlIHsgT3BlbkdyYXBoIH0gZnJvbSAnLi90eXBlcy9vcGVuZ3JhcGgtdHlwZXMnXG5pbXBvcnQgdHlwZSB7IEFwcERpck1vZHVsZXMgfSBmcm9tICcuLi8uLi9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1hcHAtbG9hZGVyJ1xuaW1wb3J0IHR5cGUgeyBNZXRhZGF0YUNvbnRleHQgfSBmcm9tICcuL3R5cGVzL3Jlc29sdmVycydcbmltcG9ydCB0eXBlIHsgTG9hZGVyVHJlZSB9IGZyb20gJy4uLy4uL3NlcnZlci9saWIvYXBwLWRpci1tb2R1bGUnXG5pbXBvcnQgdHlwZSB7XG4gIEFic29sdXRlVGVtcGxhdGVTdHJpbmcsXG4gIEljb25EZXNjcmlwdG9yLFxuICBSZXNvbHZlZEljb25zLFxufSBmcm9tICcuL3R5cGVzL21ldGFkYXRhLXR5cGVzJ1xuaW1wb3J0IHR5cGUgeyBQYXJzZWRVcmxRdWVyeSB9IGZyb20gJ3F1ZXJ5c3RyaW5nJ1xuaW1wb3J0IHR5cGUgeyBTdGF0aWNNZXRhZGF0YSB9IGZyb20gJy4vdHlwZXMvaWNvbnMnXG5pbXBvcnQgdHlwZSB7IFdvcmtTdG9yZSB9IGZyb20gJy4uLy4uL3NlcnZlci9hcHAtcmVuZGVyL3dvcmstYXN5bmMtc3RvcmFnZS5leHRlcm5hbCdcbmltcG9ydCB0eXBlIHsgUGFyYW1zIH0gZnJvbSAnLi4vLi4vc2VydmVyL3JlcXVlc3QvcGFyYW1zJ1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzXG5pbXBvcnQgJ3NlcnZlci1vbmx5J1xuXG5pbXBvcnQgeyBjYWNoZSB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHtcbiAgY3JlYXRlRGVmYXVsdE1ldGFkYXRhLFxuICBjcmVhdGVEZWZhdWx0Vmlld3BvcnQsXG59IGZyb20gJy4vZGVmYXVsdC1tZXRhZGF0YSdcbmltcG9ydCB7IHJlc29sdmVPcGVuR3JhcGgsIHJlc29sdmVUd2l0dGVyIH0gZnJvbSAnLi9yZXNvbHZlcnMvcmVzb2x2ZS1vcGVuZ3JhcGgnXG5pbXBvcnQgeyByZXNvbHZlVGl0bGUgfSBmcm9tICcuL3Jlc29sdmVycy9yZXNvbHZlLXRpdGxlJ1xuaW1wb3J0IHsgcmVzb2x2ZUFzQXJyYXlPclVuZGVmaW5lZCB9IGZyb20gJy4vZ2VuZXJhdGUvdXRpbHMnXG5pbXBvcnQge1xuICBnZXRDb21wb25lbnRUeXBlTW9kdWxlLFxuICBnZXRMYXlvdXRPclBhZ2VNb2R1bGUsXG59IGZyb20gJy4uLy4uL3NlcnZlci9saWIvYXBwLWRpci1tb2R1bGUnXG5pbXBvcnQgeyBpbnRlcm9wRGVmYXVsdCB9IGZyb20gJy4uL2ludGVyb3AtZGVmYXVsdCdcbmltcG9ydCB7XG4gIHJlc29sdmVBbHRlcm5hdGVzLFxuICByZXNvbHZlQXBwbGVXZWJBcHAsXG4gIHJlc29sdmVBcHBMaW5rcyxcbiAgcmVzb2x2ZVJvYm90cyxcbiAgcmVzb2x2ZVRoZW1lQ29sb3IsXG4gIHJlc29sdmVWZXJpZmljYXRpb24sXG4gIHJlc29sdmVJdHVuZXMsXG4gIHJlc29sdmVGYWNlYm9vayxcbiAgcmVzb2x2ZVBhZ2luYXRpb24sXG59IGZyb20gJy4vcmVzb2x2ZXJzL3Jlc29sdmUtYmFzaWNzJ1xuaW1wb3J0IHsgcmVzb2x2ZUljb25zIH0gZnJvbSAnLi9yZXNvbHZlcnMvcmVzb2x2ZS1pY29ucydcbmltcG9ydCB7IGdldFRyYWNlciB9IGZyb20gJy4uLy4uL3NlcnZlci9saWIvdHJhY2UvdHJhY2VyJ1xuaW1wb3J0IHsgUmVzb2x2ZU1ldGFkYXRhU3BhbiB9IGZyb20gJy4uLy4uL3NlcnZlci9saWIvdHJhY2UvY29uc3RhbnRzJ1xuaW1wb3J0IHsgUEFHRV9TRUdNRU5UX0tFWSB9IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvc2VnbWVudCdcbmltcG9ydCAqIGFzIExvZyBmcm9tICcuLi8uLi9idWlsZC9vdXRwdXQvbG9nJ1xuaW1wb3J0IHsgY3JlYXRlU2VydmVyUGFyYW1zRm9yTWV0YWRhdGEgfSBmcm9tICcuLi8uLi9zZXJ2ZXIvcmVxdWVzdC9wYXJhbXMnXG5cbnR5cGUgU3RhdGljSWNvbnMgPSBQaWNrPFJlc29sdmVkSWNvbnMsICdpY29uJyB8ICdhcHBsZSc+XG5cbnR5cGUgTWV0YWRhdGFSZXNvbHZlciA9IChcbiAgcGFyZW50OiBSZXNvbHZpbmdNZXRhZGF0YVxuKSA9PiBNZXRhZGF0YSB8IFByb21pc2U8TWV0YWRhdGE+XG50eXBlIFZpZXdwb3J0UmVzb2x2ZXIgPSAoXG4gIHBhcmVudDogUmVzb2x2aW5nVmlld3BvcnRcbikgPT4gVmlld3BvcnQgfCBQcm9taXNlPFZpZXdwb3J0PlxuXG5leHBvcnQgdHlwZSBNZXRhZGF0YUVycm9yVHlwZSA9ICdub3QtZm91bmQnIHwgJ2ZvcmJpZGRlbicgfCAndW5hdXRob3JpemVkJ1xuXG5leHBvcnQgdHlwZSBNZXRhZGF0YUl0ZW1zID0gQXJyYXk8XG4gIFtNZXRhZGF0YSB8IE1ldGFkYXRhUmVzb2x2ZXIgfCBudWxsLCBTdGF0aWNNZXRhZGF0YV1cbj5cblxuZXhwb3J0IHR5cGUgVmlld3BvcnRJdGVtcyA9IEFycmF5PFZpZXdwb3J0IHwgVmlld3BvcnRSZXNvbHZlciB8IG51bGw+XG5cbnR5cGUgVGl0bGVUZW1wbGF0ZXMgPSB7XG4gIHRpdGxlOiBzdHJpbmcgfCBudWxsXG4gIHR3aXR0ZXI6IHN0cmluZyB8IG51bGxcbiAgb3BlbkdyYXBoOiBzdHJpbmcgfCBudWxsXG59XG5cbnR5cGUgQnVpbGRTdGF0ZSA9IHtcbiAgd2FybmluZ3M6IFNldDxzdHJpbmc+XG59XG5cbnR5cGUgTGF5b3V0UHJvcHMgPSB7XG4gIHBhcmFtczogeyBba2V5OiBzdHJpbmddOiBhbnkgfVxufVxudHlwZSBQYWdlUHJvcHMgPSB7XG4gIHBhcmFtczogeyBba2V5OiBzdHJpbmddOiBhbnkgfVxuICBzZWFyY2hQYXJhbXM6IHsgW2tleTogc3RyaW5nXTogYW55IH1cbn1cblxuZnVuY3Rpb24gaXNGYXZpY29uKGljb246IEljb25EZXNjcmlwdG9yIHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XG4gIGlmICghaWNvbikge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gdHVyYm9wYWNrIGFwcGVuZHMgYSBoYXNoIHRvIGFsbCBpbWFnZXNcbiAgcmV0dXJuIChcbiAgICAoaWNvbi51cmwgPT09ICcvZmF2aWNvbi5pY28nIHx8XG4gICAgICBpY29uLnVybC50b1N0cmluZygpLnN0YXJ0c1dpdGgoJy9mYXZpY29uLmljbz8nKSkgJiZcbiAgICBpY29uLnR5cGUgPT09ICdpbWFnZS94LWljb24nXG4gIClcbn1cblxuYXN5bmMgZnVuY3Rpb24gbWVyZ2VTdGF0aWNNZXRhZGF0YShcbiAgc291cmNlOiBNZXRhZGF0YSB8IG51bGwsXG4gIHRhcmdldDogUmVzb2x2ZWRNZXRhZGF0YSxcbiAgc3RhdGljRmlsZXNNZXRhZGF0YTogU3RhdGljTWV0YWRhdGEsXG4gIG1ldGFkYXRhQ29udGV4dDogTWV0YWRhdGFDb250ZXh0LFxuICB0aXRsZVRlbXBsYXRlczogVGl0bGVUZW1wbGF0ZXMsXG4gIGxlYWZTZWdtZW50U3RhdGljSWNvbnM6IFN0YXRpY0ljb25zLFxuICBwYXRobmFtZTogUHJvbWlzZTxzdHJpbmc+XG4pOiBQcm9taXNlPFJlc29sdmVkTWV0YWRhdGE+IHtcbiAgaWYgKCFzdGF0aWNGaWxlc01ldGFkYXRhKSByZXR1cm4gdGFyZ2V0XG4gIGNvbnN0IHsgaWNvbiwgYXBwbGUsIG9wZW5HcmFwaCwgdHdpdHRlciwgbWFuaWZlc3QgfSA9IHN0YXRpY0ZpbGVzTWV0YWRhdGFcblxuICAvLyBLZWVwIHVwZGF0aW5nIHRoZSBzdGF0aWMgaWNvbnMgaW4gdGhlIG1vc3QgbGVhZiBub2RlXG5cbiAgaWYgKGljb24pIHtcbiAgICBsZWFmU2VnbWVudFN0YXRpY0ljb25zLmljb24gPSBpY29uXG4gIH1cbiAgaWYgKGFwcGxlKSB7XG4gICAgbGVhZlNlZ21lbnRTdGF0aWNJY29ucy5hcHBsZSA9IGFwcGxlXG4gIH1cblxuICAvLyBmaWxlIGJhc2VkIG1ldGFkYXRhIGlzIHNwZWNpZmllZCBhbmQgY3VycmVudCBsZXZlbCBtZXRhZGF0YSB0d2l0dGVyLmltYWdlcyBpcyBub3Qgc3BlY2lmaWVkXG4gIGlmICh0d2l0dGVyICYmICFzb3VyY2U/LnR3aXR0ZXI/Lmhhc093blByb3BlcnR5KCdpbWFnZXMnKSkge1xuICAgIGNvbnN0IHJlc29sdmVkVHdpdHRlciA9IHJlc29sdmVUd2l0dGVyKFxuICAgICAgeyAuLi50YXJnZXQudHdpdHRlciwgaW1hZ2VzOiB0d2l0dGVyIH0gYXMgVHdpdHRlcixcbiAgICAgIHRhcmdldC5tZXRhZGF0YUJhc2UsXG4gICAgICB7IC4uLm1ldGFkYXRhQ29udGV4dCwgaXNTdGF0aWNNZXRhZGF0YVJvdXRlRmlsZTogdHJ1ZSB9LFxuICAgICAgdGl0bGVUZW1wbGF0ZXMudHdpdHRlclxuICAgIClcbiAgICB0YXJnZXQudHdpdHRlciA9IHJlc29sdmVkVHdpdHRlclxuICB9XG5cbiAgLy8gZmlsZSBiYXNlZCBtZXRhZGF0YSBpcyBzcGVjaWZpZWQgYW5kIGN1cnJlbnQgbGV2ZWwgbWV0YWRhdGEgb3BlbkdyYXBoLmltYWdlcyBpcyBub3Qgc3BlY2lmaWVkXG4gIGlmIChvcGVuR3JhcGggJiYgIXNvdXJjZT8ub3BlbkdyYXBoPy5oYXNPd25Qcm9wZXJ0eSgnaW1hZ2VzJykpIHtcbiAgICBjb25zdCByZXNvbHZlZE9wZW5HcmFwaCA9IGF3YWl0IHJlc29sdmVPcGVuR3JhcGgoXG4gICAgICB7IC4uLnRhcmdldC5vcGVuR3JhcGgsIGltYWdlczogb3BlbkdyYXBoIH0gYXMgT3BlbkdyYXBoLFxuICAgICAgdGFyZ2V0Lm1ldGFkYXRhQmFzZSxcbiAgICAgIHBhdGhuYW1lLFxuICAgICAgeyAuLi5tZXRhZGF0YUNvbnRleHQsIGlzU3RhdGljTWV0YWRhdGFSb3V0ZUZpbGU6IHRydWUgfSxcbiAgICAgIHRpdGxlVGVtcGxhdGVzLm9wZW5HcmFwaFxuICAgIClcbiAgICB0YXJnZXQub3BlbkdyYXBoID0gcmVzb2x2ZWRPcGVuR3JhcGhcbiAgfVxuICBpZiAobWFuaWZlc3QpIHtcbiAgICB0YXJnZXQubWFuaWZlc3QgPSBtYW5pZmVzdFxuICB9XG5cbiAgcmV0dXJuIHRhcmdldFxufVxuXG4vLyBNZXJnZSB0aGUgc291cmNlIG1ldGFkYXRhIGludG8gdGhlIHJlc29sdmVkIHRhcmdldCBtZXRhZGF0YS5cbmFzeW5jIGZ1bmN0aW9uIG1lcmdlTWV0YWRhdGEoXG4gIHJvdXRlOiBzdHJpbmcsXG4gIHBhdGhuYW1lOiBQcm9taXNlPHN0cmluZz4sXG4gIHtcbiAgICBzb3VyY2UsXG4gICAgdGFyZ2V0LFxuICAgIHN0YXRpY0ZpbGVzTWV0YWRhdGEsXG4gICAgdGl0bGVUZW1wbGF0ZXMsXG4gICAgbWV0YWRhdGFDb250ZXh0LFxuICAgIGJ1aWxkU3RhdGUsXG4gICAgbGVhZlNlZ21lbnRTdGF0aWNJY29ucyxcbiAgfToge1xuICAgIHNvdXJjZTogTWV0YWRhdGEgfCBudWxsXG4gICAgdGFyZ2V0OiBSZXNvbHZlZE1ldGFkYXRhXG4gICAgc3RhdGljRmlsZXNNZXRhZGF0YTogU3RhdGljTWV0YWRhdGFcbiAgICB0aXRsZVRlbXBsYXRlczogVGl0bGVUZW1wbGF0ZXNcbiAgICBtZXRhZGF0YUNvbnRleHQ6IE1ldGFkYXRhQ29udGV4dFxuICAgIGJ1aWxkU3RhdGU6IEJ1aWxkU3RhdGVcbiAgICBsZWFmU2VnbWVudFN0YXRpY0ljb25zOiBTdGF0aWNJY29uc1xuICB9XG4pOiBQcm9taXNlPFJlc29sdmVkTWV0YWRhdGE+IHtcbiAgLy8gSWYgdGhlcmUncyBvdmVycmlkZSBtZXRhZGF0YSwgcHJlZmVyIGl0IG90aGVyd2lzZSBmYWxsYmFjayB0byB0aGUgZGVmYXVsdCBtZXRhZGF0YS5cbiAgY29uc3QgbWV0YWRhdGFCYXNlID1cbiAgICB0eXBlb2Ygc291cmNlPy5tZXRhZGF0YUJhc2UgIT09ICd1bmRlZmluZWQnXG4gICAgICA/IHNvdXJjZS5tZXRhZGF0YUJhc2VcbiAgICAgIDogdGFyZ2V0Lm1ldGFkYXRhQmFzZVxuICBmb3IgKGNvbnN0IGtleV8gaW4gc291cmNlKSB7XG4gICAgY29uc3Qga2V5ID0ga2V5XyBhcyBrZXlvZiBNZXRhZGF0YVxuXG4gICAgc3dpdGNoIChrZXkpIHtcbiAgICAgIGNhc2UgJ3RpdGxlJzoge1xuICAgICAgICB0YXJnZXQudGl0bGUgPSByZXNvbHZlVGl0bGUoc291cmNlLnRpdGxlLCB0aXRsZVRlbXBsYXRlcy50aXRsZSlcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ2FsdGVybmF0ZXMnOiB7XG4gICAgICAgIHRhcmdldC5hbHRlcm5hdGVzID0gYXdhaXQgcmVzb2x2ZUFsdGVybmF0ZXMoXG4gICAgICAgICAgc291cmNlLmFsdGVybmF0ZXMsXG4gICAgICAgICAgbWV0YWRhdGFCYXNlLFxuICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgIG1ldGFkYXRhQ29udGV4dFxuICAgICAgICApXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBjYXNlICdvcGVuR3JhcGgnOiB7XG4gICAgICAgIHRhcmdldC5vcGVuR3JhcGggPSBhd2FpdCByZXNvbHZlT3BlbkdyYXBoKFxuICAgICAgICAgIHNvdXJjZS5vcGVuR3JhcGgsXG4gICAgICAgICAgbWV0YWRhdGFCYXNlLFxuICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgIG1ldGFkYXRhQ29udGV4dCxcbiAgICAgICAgICB0aXRsZVRlbXBsYXRlcy5vcGVuR3JhcGhcbiAgICAgICAgKVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgY2FzZSAndHdpdHRlcic6IHtcbiAgICAgICAgdGFyZ2V0LnR3aXR0ZXIgPSByZXNvbHZlVHdpdHRlcihcbiAgICAgICAgICBzb3VyY2UudHdpdHRlcixcbiAgICAgICAgICBtZXRhZGF0YUJhc2UsXG4gICAgICAgICAgbWV0YWRhdGFDb250ZXh0LFxuICAgICAgICAgIHRpdGxlVGVtcGxhdGVzLnR3aXR0ZXJcbiAgICAgICAgKVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgY2FzZSAnZmFjZWJvb2snOlxuICAgICAgICB0YXJnZXQuZmFjZWJvb2sgPSByZXNvbHZlRmFjZWJvb2soc291cmNlLmZhY2Vib29rKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAndmVyaWZpY2F0aW9uJzpcbiAgICAgICAgdGFyZ2V0LnZlcmlmaWNhdGlvbiA9IHJlc29sdmVWZXJpZmljYXRpb24oc291cmNlLnZlcmlmaWNhdGlvbilcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSAnaWNvbnMnOiB7XG4gICAgICAgIHRhcmdldC5pY29ucyA9IHJlc29sdmVJY29ucyhzb3VyY2UuaWNvbnMpXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBjYXNlICdhcHBsZVdlYkFwcCc6XG4gICAgICAgIHRhcmdldC5hcHBsZVdlYkFwcCA9IHJlc29sdmVBcHBsZVdlYkFwcChzb3VyY2UuYXBwbGVXZWJBcHApXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdhcHBMaW5rcyc6XG4gICAgICAgIHRhcmdldC5hcHBMaW5rcyA9IHJlc29sdmVBcHBMaW5rcyhzb3VyY2UuYXBwTGlua3MpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdyb2JvdHMnOiB7XG4gICAgICAgIHRhcmdldC5yb2JvdHMgPSByZXNvbHZlUm9ib3RzKHNvdXJjZS5yb2JvdHMpXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBjYXNlICdhcmNoaXZlcyc6XG4gICAgICBjYXNlICdhc3NldHMnOlxuICAgICAgY2FzZSAnYm9va21hcmtzJzpcbiAgICAgIGNhc2UgJ2tleXdvcmRzJzoge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHJlc29sdmVBc0FycmF5T3JVbmRlZmluZWQoc291cmNlW2tleV0pXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBjYXNlICdhdXRob3JzJzoge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHJlc29sdmVBc0FycmF5T3JVbmRlZmluZWQoc291cmNlLmF1dGhvcnMpXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBjYXNlICdpdHVuZXMnOiB7XG4gICAgICAgIHRhcmdldFtrZXldID0gYXdhaXQgcmVzb2x2ZUl0dW5lcyhcbiAgICAgICAgICBzb3VyY2UuaXR1bmVzLFxuICAgICAgICAgIG1ldGFkYXRhQmFzZSxcbiAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICBtZXRhZGF0YUNvbnRleHRcbiAgICAgICAgKVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgY2FzZSAncGFnaW5hdGlvbic6IHtcbiAgICAgICAgdGFyZ2V0LnBhZ2luYXRpb24gPSBhd2FpdCByZXNvbHZlUGFnaW5hdGlvbihcbiAgICAgICAgICBzb3VyY2UucGFnaW5hdGlvbixcbiAgICAgICAgICBtZXRhZGF0YUJhc2UsXG4gICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgbWV0YWRhdGFDb250ZXh0XG4gICAgICAgIClcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIC8vIGRpcmVjdGx5IGFzc2lnbiBmaWVsZHMgdGhhdCBmYWxsYmFjayB0byBudWxsXG4gICAgICBjYXNlICdhcHBsaWNhdGlvbk5hbWUnOlxuICAgICAgY2FzZSAnZGVzY3JpcHRpb24nOlxuICAgICAgY2FzZSAnZ2VuZXJhdG9yJzpcbiAgICAgIGNhc2UgJ2NyZWF0b3InOlxuICAgICAgY2FzZSAncHVibGlzaGVyJzpcbiAgICAgIGNhc2UgJ2NhdGVnb3J5JzpcbiAgICAgIGNhc2UgJ2NsYXNzaWZpY2F0aW9uJzpcbiAgICAgIGNhc2UgJ3JlZmVycmVyJzpcbiAgICAgIGNhc2UgJ2Zvcm1hdERldGVjdGlvbic6XG4gICAgICBjYXNlICdtYW5pZmVzdCc6XG4gICAgICBjYXNlICdwaW50ZXJlc3QnOlxuICAgICAgICAvLyBAdHMtaWdub3JlIFRPRE86IHN1cHBvcnQgaW5mZXJyaW5nXG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV0gfHwgbnVsbFxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnb3RoZXInOlxuICAgICAgICB0YXJnZXQub3RoZXIgPSBPYmplY3QuYXNzaWduKHt9LCB0YXJnZXQub3RoZXIsIHNvdXJjZS5vdGhlcilcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ21ldGFkYXRhQmFzZSc6XG4gICAgICAgIHRhcmdldC5tZXRhZGF0YUJhc2UgPSBtZXRhZGF0YUJhc2VcbiAgICAgICAgYnJlYWtcblxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgKGtleSA9PT0gJ3ZpZXdwb3J0JyB8fFxuICAgICAgICAgICAga2V5ID09PSAndGhlbWVDb2xvcicgfHxcbiAgICAgICAgICAgIGtleSA9PT0gJ2NvbG9yU2NoZW1lJykgJiZcbiAgICAgICAgICBzb3VyY2Vba2V5XSAhPSBudWxsXG4gICAgICAgICkge1xuICAgICAgICAgIGJ1aWxkU3RhdGUud2FybmluZ3MuYWRkKFxuICAgICAgICAgICAgYFVuc3VwcG9ydGVkIG1ldGFkYXRhICR7a2V5fSBpcyBjb25maWd1cmVkIGluIG1ldGFkYXRhIGV4cG9ydCBpbiAke3JvdXRlfS4gUGxlYXNlIG1vdmUgaXQgdG8gdmlld3BvcnQgZXhwb3J0IGluc3RlYWQuXFxuUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYXBpLXJlZmVyZW5jZS9mdW5jdGlvbnMvZ2VuZXJhdGUtdmlld3BvcnRgXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBtZXJnZVN0YXRpY01ldGFkYXRhKFxuICAgIHNvdXJjZSxcbiAgICB0YXJnZXQsXG4gICAgc3RhdGljRmlsZXNNZXRhZGF0YSxcbiAgICBtZXRhZGF0YUNvbnRleHQsXG4gICAgdGl0bGVUZW1wbGF0ZXMsXG4gICAgbGVhZlNlZ21lbnRTdGF0aWNJY29ucyxcbiAgICBwYXRobmFtZVxuICApXG59XG5cbmZ1bmN0aW9uIG1lcmdlVmlld3BvcnQoe1xuICB0YXJnZXQsXG4gIHNvdXJjZSxcbn06IHtcbiAgdGFyZ2V0OiBSZXNvbHZlZFZpZXdwb3J0XG4gIHNvdXJjZTogVmlld3BvcnQgfCBudWxsXG59KTogdm9pZCB7XG4gIGlmICghc291cmNlKSByZXR1cm5cbiAgZm9yIChjb25zdCBrZXlfIGluIHNvdXJjZSkge1xuICAgIGNvbnN0IGtleSA9IGtleV8gYXMga2V5b2YgVmlld3BvcnRcblxuICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICBjYXNlICd0aGVtZUNvbG9yJzoge1xuICAgICAgICB0YXJnZXQudGhlbWVDb2xvciA9IHJlc29sdmVUaGVtZUNvbG9yKHNvdXJjZS50aGVtZUNvbG9yKVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgY2FzZSAnY29sb3JTY2hlbWUnOlxuICAgICAgICB0YXJnZXQuY29sb3JTY2hlbWUgPSBzb3VyY2UuY29sb3JTY2hlbWUgfHwgbnVsbFxuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gYWx3YXlzIG92ZXJyaWRlIHRoZSB0YXJnZXQgd2l0aCB0aGUgc291cmNlXG4gICAgICAgIC8vIEB0cy1pZ25vcmUgdmlld3BvcnQgcHJvcGVydGllc1xuICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldXG4gICAgICAgIGJyZWFrXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlZmluZWRWaWV3cG9ydChcbiAgbW9kOiBhbnksXG4gIHByb3BzOiBhbnksXG4gIHRyYWNpbmdQcm9wczogeyByb3V0ZTogc3RyaW5nIH1cbik6IFZpZXdwb3J0IHwgVmlld3BvcnRSZXNvbHZlciB8IG51bGwge1xuICBpZiAodHlwZW9mIG1vZC5nZW5lcmF0ZVZpZXdwb3J0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc3QgeyByb3V0ZSB9ID0gdHJhY2luZ1Byb3BzXG4gICAgcmV0dXJuIChwYXJlbnQ6IFJlc29sdmluZ1ZpZXdwb3J0KSA9PlxuICAgICAgZ2V0VHJhY2VyKCkudHJhY2UoXG4gICAgICAgIFJlc29sdmVNZXRhZGF0YVNwYW4uZ2VuZXJhdGVWaWV3cG9ydCxcbiAgICAgICAge1xuICAgICAgICAgIHNwYW5OYW1lOiBgZ2VuZXJhdGVWaWV3cG9ydCAke3JvdXRlfWAsXG4gICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgJ25leHQucGFnZSc6IHJvdXRlLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgICgpID0+IG1vZC5nZW5lcmF0ZVZpZXdwb3J0KHByb3BzLCBwYXJlbnQpXG4gICAgICApXG4gIH1cbiAgcmV0dXJuIG1vZC52aWV3cG9ydCB8fCBudWxsXG59XG5cbmZ1bmN0aW9uIGdldERlZmluZWRNZXRhZGF0YShcbiAgbW9kOiBhbnksXG4gIHByb3BzOiBhbnksXG4gIHRyYWNpbmdQcm9wczogeyByb3V0ZTogc3RyaW5nIH1cbik6IE1ldGFkYXRhIHwgTWV0YWRhdGFSZXNvbHZlciB8IG51bGwge1xuICBpZiAodHlwZW9mIG1vZC5nZW5lcmF0ZU1ldGFkYXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc3QgeyByb3V0ZSB9ID0gdHJhY2luZ1Byb3BzXG4gICAgcmV0dXJuIChwYXJlbnQ6IFJlc29sdmluZ01ldGFkYXRhKSA9PlxuICAgICAgZ2V0VHJhY2VyKCkudHJhY2UoXG4gICAgICAgIFJlc29sdmVNZXRhZGF0YVNwYW4uZ2VuZXJhdGVNZXRhZGF0YSxcbiAgICAgICAge1xuICAgICAgICAgIHNwYW5OYW1lOiBgZ2VuZXJhdGVNZXRhZGF0YSAke3JvdXRlfWAsXG4gICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgJ25leHQucGFnZSc6IHJvdXRlLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgICgpID0+IG1vZC5nZW5lcmF0ZU1ldGFkYXRhKHByb3BzLCBwYXJlbnQpXG4gICAgICApXG4gIH1cbiAgcmV0dXJuIG1vZC5tZXRhZGF0YSB8fCBudWxsXG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNvbGxlY3RTdGF0aWNJbWFnZXNGaWxlcyhcbiAgbWV0YWRhdGE6IEFwcERpck1vZHVsZXNbJ21ldGFkYXRhJ10sXG4gIHByb3BzOiBhbnksXG4gIHR5cGU6IGtleW9mIE5vbk51bGxhYmxlPEFwcERpck1vZHVsZXNbJ21ldGFkYXRhJ10+XG4pIHtcbiAgaWYgKCFtZXRhZGF0YT8uW3R5cGVdKSByZXR1cm4gdW5kZWZpbmVkXG5cbiAgY29uc3QgaWNvblByb21pc2VzID0gbWV0YWRhdGFbdHlwZSBhcyAnaWNvbicgfCAnYXBwbGUnXS5tYXAoXG4gICAgYXN5bmMgKGltYWdlTW9kdWxlOiAocDogYW55KSA9PiBQcm9taXNlPE1ldGFkYXRhSW1hZ2VNb2R1bGVbXT4pID0+XG4gICAgICBpbnRlcm9wRGVmYXVsdChhd2FpdCBpbWFnZU1vZHVsZShwcm9wcykpXG4gIClcblxuICByZXR1cm4gaWNvblByb21pc2VzPy5sZW5ndGggPiAwXG4gICAgPyAoYXdhaXQgUHJvbWlzZS5hbGwoaWNvblByb21pc2VzKSk/LmZsYXQoKVxuICAgIDogdW5kZWZpbmVkXG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlc29sdmVTdGF0aWNNZXRhZGF0YShcbiAgbW9kdWxlczogQXBwRGlyTW9kdWxlcyxcbiAgcHJvcHM6IGFueVxuKTogUHJvbWlzZTxTdGF0aWNNZXRhZGF0YT4ge1xuICBjb25zdCB7IG1ldGFkYXRhIH0gPSBtb2R1bGVzXG4gIGlmICghbWV0YWRhdGEpIHJldHVybiBudWxsXG5cbiAgY29uc3QgW2ljb24sIGFwcGxlLCBvcGVuR3JhcGgsIHR3aXR0ZXJdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgIGNvbGxlY3RTdGF0aWNJbWFnZXNGaWxlcyhtZXRhZGF0YSwgcHJvcHMsICdpY29uJyksXG4gICAgY29sbGVjdFN0YXRpY0ltYWdlc0ZpbGVzKG1ldGFkYXRhLCBwcm9wcywgJ2FwcGxlJyksXG4gICAgY29sbGVjdFN0YXRpY0ltYWdlc0ZpbGVzKG1ldGFkYXRhLCBwcm9wcywgJ29wZW5HcmFwaCcpLFxuICAgIGNvbGxlY3RTdGF0aWNJbWFnZXNGaWxlcyhtZXRhZGF0YSwgcHJvcHMsICd0d2l0dGVyJyksXG4gIF0pXG5cbiAgY29uc3Qgc3RhdGljTWV0YWRhdGEgPSB7XG4gICAgaWNvbixcbiAgICBhcHBsZSxcbiAgICBvcGVuR3JhcGgsXG4gICAgdHdpdHRlcixcbiAgICBtYW5pZmVzdDogbWV0YWRhdGEubWFuaWZlc3QsXG4gIH1cblxuICByZXR1cm4gc3RhdGljTWV0YWRhdGFcbn1cblxuLy8gW2xheW91dC5tZXRhZGF0YSwgc3RhdGljIGZpbGVzIG1ldGFkYXRhXSAtPiAuLi4gLT4gW3BhZ2UubWV0YWRhdGEsIHN0YXRpYyBmaWxlcyBtZXRhZGF0YV1cbmFzeW5jIGZ1bmN0aW9uIGNvbGxlY3RNZXRhZGF0YSh7XG4gIHRyZWUsXG4gIG1ldGFkYXRhSXRlbXMsXG4gIGVycm9yTWV0YWRhdGFJdGVtLFxuICBwcm9wcyxcbiAgcm91dGUsXG4gIGVycm9yQ29udmVudGlvbixcbn06IHtcbiAgdHJlZTogTG9hZGVyVHJlZVxuICBtZXRhZGF0YUl0ZW1zOiBNZXRhZGF0YUl0ZW1zXG4gIGVycm9yTWV0YWRhdGFJdGVtOiBNZXRhZGF0YUl0ZW1zW251bWJlcl1cbiAgcHJvcHM6IGFueVxuICByb3V0ZTogc3RyaW5nXG4gIGVycm9yQ29udmVudGlvbj86IE1ldGFkYXRhRXJyb3JUeXBlXG59KSB7XG4gIGxldCBtb2RcbiAgbGV0IG1vZFR5cGVcbiAgY29uc3QgaGFzRXJyb3JDb252ZW50aW9uQ29tcG9uZW50ID0gQm9vbGVhbihcbiAgICBlcnJvckNvbnZlbnRpb24gJiYgdHJlZVsyXVtlcnJvckNvbnZlbnRpb25dXG4gIClcbiAgaWYgKGVycm9yQ29udmVudGlvbikge1xuICAgIG1vZCA9IGF3YWl0IGdldENvbXBvbmVudFR5cGVNb2R1bGUodHJlZSwgJ2xheW91dCcpXG4gICAgbW9kVHlwZSA9IGVycm9yQ29udmVudGlvblxuICB9IGVsc2Uge1xuICAgIGNvbnN0IHsgbW9kOiBsYXlvdXRPclBhZ2VNb2QsIG1vZFR5cGU6IGxheW91dE9yUGFnZU1vZFR5cGUgfSA9XG4gICAgICBhd2FpdCBnZXRMYXlvdXRPclBhZ2VNb2R1bGUodHJlZSlcbiAgICBtb2QgPSBsYXlvdXRPclBhZ2VNb2RcbiAgICBtb2RUeXBlID0gbGF5b3V0T3JQYWdlTW9kVHlwZVxuICB9XG5cbiAgaWYgKG1vZFR5cGUpIHtcbiAgICByb3V0ZSArPSBgLyR7bW9kVHlwZX1gXG4gIH1cblxuICBjb25zdCBzdGF0aWNGaWxlc01ldGFkYXRhID0gYXdhaXQgcmVzb2x2ZVN0YXRpY01ldGFkYXRhKHRyZWVbMl0sIHByb3BzKVxuICBjb25zdCBtZXRhZGF0YUV4cG9ydCA9IG1vZCA/IGdldERlZmluZWRNZXRhZGF0YShtb2QsIHByb3BzLCB7IHJvdXRlIH0pIDogbnVsbFxuXG4gIG1ldGFkYXRhSXRlbXMucHVzaChbbWV0YWRhdGFFeHBvcnQsIHN0YXRpY0ZpbGVzTWV0YWRhdGFdKVxuXG4gIGlmIChoYXNFcnJvckNvbnZlbnRpb25Db21wb25lbnQgJiYgZXJyb3JDb252ZW50aW9uKSB7XG4gICAgY29uc3QgZXJyb3JNb2QgPSBhd2FpdCBnZXRDb21wb25lbnRUeXBlTW9kdWxlKHRyZWUsIGVycm9yQ29udmVudGlvbilcbiAgICBjb25zdCBlcnJvck1ldGFkYXRhRXhwb3J0ID0gZXJyb3JNb2RcbiAgICAgID8gZ2V0RGVmaW5lZE1ldGFkYXRhKGVycm9yTW9kLCBwcm9wcywgeyByb3V0ZSB9KVxuICAgICAgOiBudWxsXG5cbiAgICBlcnJvck1ldGFkYXRhSXRlbVswXSA9IGVycm9yTWV0YWRhdGFFeHBvcnRcbiAgICBlcnJvck1ldGFkYXRhSXRlbVsxXSA9IHN0YXRpY0ZpbGVzTWV0YWRhdGFcbiAgfVxufVxuXG4vLyBbbGF5b3V0Lm1ldGFkYXRhLCBzdGF0aWMgZmlsZXMgbWV0YWRhdGFdIC0+IC4uLiAtPiBbcGFnZS5tZXRhZGF0YSwgc3RhdGljIGZpbGVzIG1ldGFkYXRhXVxuYXN5bmMgZnVuY3Rpb24gY29sbGVjdFZpZXdwb3J0KHtcbiAgdHJlZSxcbiAgdmlld3BvcnRJdGVtcyxcbiAgZXJyb3JWaWV3cG9ydEl0ZW1SZWYsXG4gIHByb3BzLFxuICByb3V0ZSxcbiAgZXJyb3JDb252ZW50aW9uLFxufToge1xuICB0cmVlOiBMb2FkZXJUcmVlXG4gIHZpZXdwb3J0SXRlbXM6IFZpZXdwb3J0SXRlbXNcbiAgZXJyb3JWaWV3cG9ydEl0ZW1SZWY6IEVycm9yVmlld3BvcnRJdGVtUmVmXG4gIHByb3BzOiBhbnlcbiAgcm91dGU6IHN0cmluZ1xuICBlcnJvckNvbnZlbnRpb24/OiBNZXRhZGF0YUVycm9yVHlwZVxufSkge1xuICBsZXQgbW9kXG4gIGxldCBtb2RUeXBlXG4gIGNvbnN0IGhhc0Vycm9yQ29udmVudGlvbkNvbXBvbmVudCA9IEJvb2xlYW4oXG4gICAgZXJyb3JDb252ZW50aW9uICYmIHRyZWVbMl1bZXJyb3JDb252ZW50aW9uXVxuICApXG4gIGlmIChlcnJvckNvbnZlbnRpb24pIHtcbiAgICBtb2QgPSBhd2FpdCBnZXRDb21wb25lbnRUeXBlTW9kdWxlKHRyZWUsICdsYXlvdXQnKVxuICAgIG1vZFR5cGUgPSBlcnJvckNvbnZlbnRpb25cbiAgfSBlbHNlIHtcbiAgICBjb25zdCB7IG1vZDogbGF5b3V0T3JQYWdlTW9kLCBtb2RUeXBlOiBsYXlvdXRPclBhZ2VNb2RUeXBlIH0gPVxuICAgICAgYXdhaXQgZ2V0TGF5b3V0T3JQYWdlTW9kdWxlKHRyZWUpXG4gICAgbW9kID0gbGF5b3V0T3JQYWdlTW9kXG4gICAgbW9kVHlwZSA9IGxheW91dE9yUGFnZU1vZFR5cGVcbiAgfVxuXG4gIGlmIChtb2RUeXBlKSB7XG4gICAgcm91dGUgKz0gYC8ke21vZFR5cGV9YFxuICB9XG5cbiAgY29uc3Qgdmlld3BvcnRFeHBvcnQgPSBtb2QgPyBnZXREZWZpbmVkVmlld3BvcnQobW9kLCBwcm9wcywgeyByb3V0ZSB9KSA6IG51bGxcblxuICB2aWV3cG9ydEl0ZW1zLnB1c2godmlld3BvcnRFeHBvcnQpXG5cbiAgaWYgKGhhc0Vycm9yQ29udmVudGlvbkNvbXBvbmVudCAmJiBlcnJvckNvbnZlbnRpb24pIHtcbiAgICBjb25zdCBlcnJvck1vZCA9IGF3YWl0IGdldENvbXBvbmVudFR5cGVNb2R1bGUodHJlZSwgZXJyb3JDb252ZW50aW9uKVxuICAgIGNvbnN0IGVycm9yVmlld3BvcnRFeHBvcnQgPSBlcnJvck1vZFxuICAgICAgPyBnZXREZWZpbmVkVmlld3BvcnQoZXJyb3JNb2QsIHByb3BzLCB7IHJvdXRlIH0pXG4gICAgICA6IG51bGxcblxuICAgIGVycm9yVmlld3BvcnRJdGVtUmVmLmN1cnJlbnQgPSBlcnJvclZpZXdwb3J0RXhwb3J0XG4gIH1cbn1cblxuY29uc3QgcmVzb2x2ZU1ldGFkYXRhSXRlbXMgPSBjYWNoZShhc3luYyBmdW5jdGlvbiAoXG4gIHRyZWU6IExvYWRlclRyZWUsXG4gIHNlYXJjaFBhcmFtczogUHJvbWlzZTxQYXJzZWRVcmxRdWVyeT4sXG4gIGVycm9yQ29udmVudGlvbjogTWV0YWRhdGFFcnJvclR5cGUgfCB1bmRlZmluZWQsXG4gIGdldER5bmFtaWNQYXJhbUZyb21TZWdtZW50OiBHZXREeW5hbWljUGFyYW1Gcm9tU2VnbWVudCxcbiAgd29ya1N0b3JlOiBXb3JrU3RvcmVcbikge1xuICBjb25zdCBwYXJlbnRQYXJhbXMgPSB7fVxuICBjb25zdCBtZXRhZGF0YUl0ZW1zOiBNZXRhZGF0YUl0ZW1zID0gW11cbiAgY29uc3QgZXJyb3JNZXRhZGF0YUl0ZW06IE1ldGFkYXRhSXRlbXNbbnVtYmVyXSA9IFtudWxsLCBudWxsXVxuICBjb25zdCB0cmVlUHJlZml4ID0gdW5kZWZpbmVkXG4gIHJldHVybiByZXNvbHZlTWV0YWRhdGFJdGVtc0ltcGwoXG4gICAgbWV0YWRhdGFJdGVtcyxcbiAgICB0cmVlLFxuICAgIHRyZWVQcmVmaXgsXG4gICAgcGFyZW50UGFyYW1zLFxuICAgIHNlYXJjaFBhcmFtcyxcbiAgICBlcnJvckNvbnZlbnRpb24sXG4gICAgZXJyb3JNZXRhZGF0YUl0ZW0sXG4gICAgZ2V0RHluYW1pY1BhcmFtRnJvbVNlZ21lbnQsXG4gICAgd29ya1N0b3JlXG4gIClcbn0pXG5cbmFzeW5jIGZ1bmN0aW9uIHJlc29sdmVNZXRhZGF0YUl0ZW1zSW1wbChcbiAgbWV0YWRhdGFJdGVtczogTWV0YWRhdGFJdGVtcyxcbiAgdHJlZTogTG9hZGVyVHJlZSxcbiAgLyoqIFByb3ZpZGVkIHRyZWUgY2FuIGJlIG5lc3RlZCBzdWJ0cmVlLCB0aGlzIGFyZ3VtZW50IHNheXMgd2hhdCBpcyB0aGUgcGF0aCBvZiBzdWNoIHN1YnRyZWUgKi9cbiAgdHJlZVByZWZpeDogdW5kZWZpbmVkIHwgc3RyaW5nW10sXG4gIHBhcmVudFBhcmFtczogUGFyYW1zLFxuICBzZWFyY2hQYXJhbXM6IFByb21pc2U8UGFyc2VkVXJsUXVlcnk+LFxuICBlcnJvckNvbnZlbnRpb246IE1ldGFkYXRhRXJyb3JUeXBlIHwgdW5kZWZpbmVkLFxuICBlcnJvck1ldGFkYXRhSXRlbTogTWV0YWRhdGFJdGVtc1tudW1iZXJdLFxuICBnZXREeW5hbWljUGFyYW1Gcm9tU2VnbWVudDogR2V0RHluYW1pY1BhcmFtRnJvbVNlZ21lbnQsXG4gIHdvcmtTdG9yZTogV29ya1N0b3JlXG4pOiBQcm9taXNlPE1ldGFkYXRhSXRlbXM+IHtcbiAgY29uc3QgW3NlZ21lbnQsIHBhcmFsbGVsUm91dGVzLCB7IHBhZ2UgfV0gPSB0cmVlXG4gIGNvbnN0IGN1cnJlbnRUcmVlUHJlZml4ID1cbiAgICB0cmVlUHJlZml4ICYmIHRyZWVQcmVmaXgubGVuZ3RoID8gWy4uLnRyZWVQcmVmaXgsIHNlZ21lbnRdIDogW3NlZ21lbnRdXG4gIGNvbnN0IGlzUGFnZSA9IHR5cGVvZiBwYWdlICE9PSAndW5kZWZpbmVkJ1xuXG4gIC8vIEhhbmRsZSBkeW5hbWljIHNlZ21lbnQgcGFyYW1zLlxuICBjb25zdCBzZWdtZW50UGFyYW0gPSBnZXREeW5hbWljUGFyYW1Gcm9tU2VnbWVudChzZWdtZW50KVxuICAvKipcbiAgICogQ3JlYXRlIG9iamVjdCBob2xkaW5nIHRoZSBwYXJlbnQgcGFyYW1zIGFuZCBjdXJyZW50IHBhcmFtc1xuICAgKi9cbiAgbGV0IGN1cnJlbnRQYXJhbXMgPSBwYXJlbnRQYXJhbXNcbiAgaWYgKHNlZ21lbnRQYXJhbSAmJiBzZWdtZW50UGFyYW0udmFsdWUgIT09IG51bGwpIHtcbiAgICBjdXJyZW50UGFyYW1zID0ge1xuICAgICAgLi4ucGFyZW50UGFyYW1zLFxuICAgICAgW3NlZ21lbnRQYXJhbS5wYXJhbV06IHNlZ21lbnRQYXJhbS52YWx1ZSxcbiAgICB9XG4gIH1cblxuICBjb25zdCBwYXJhbXMgPSBjcmVhdGVTZXJ2ZXJQYXJhbXNGb3JNZXRhZGF0YShjdXJyZW50UGFyYW1zLCB3b3JrU3RvcmUpXG5cbiAgbGV0IGxheWVyUHJvcHM6IExheW91dFByb3BzIHwgUGFnZVByb3BzXG4gIGlmIChpc1BhZ2UpIHtcbiAgICBsYXllclByb3BzID0ge1xuICAgICAgcGFyYW1zLFxuICAgICAgc2VhcmNoUGFyYW1zLFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsYXllclByb3BzID0ge1xuICAgICAgcGFyYW1zLFxuICAgIH1cbiAgfVxuXG4gIGF3YWl0IGNvbGxlY3RNZXRhZGF0YSh7XG4gICAgdHJlZSxcbiAgICBtZXRhZGF0YUl0ZW1zLFxuICAgIGVycm9yTWV0YWRhdGFJdGVtLFxuICAgIGVycm9yQ29udmVudGlvbixcbiAgICBwcm9wczogbGF5ZXJQcm9wcyxcbiAgICByb3V0ZTogY3VycmVudFRyZWVQcmVmaXhcbiAgICAgIC8vIF9fUEFHRV9fIHNob3VsZG4ndCBiZSBzaG93biBpbiBhIHJvdXRlXG4gICAgICAuZmlsdGVyKChzKSA9PiBzICE9PSBQQUdFX1NFR01FTlRfS0VZKVxuICAgICAgLmpvaW4oJy8nKSxcbiAgfSlcblxuICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbGxlbFJvdXRlcykge1xuICAgIGNvbnN0IGNoaWxkVHJlZSA9IHBhcmFsbGVsUm91dGVzW2tleV1cbiAgICBhd2FpdCByZXNvbHZlTWV0YWRhdGFJdGVtc0ltcGwoXG4gICAgICBtZXRhZGF0YUl0ZW1zLFxuICAgICAgY2hpbGRUcmVlLFxuICAgICAgY3VycmVudFRyZWVQcmVmaXgsXG4gICAgICBjdXJyZW50UGFyYW1zLFxuICAgICAgc2VhcmNoUGFyYW1zLFxuICAgICAgZXJyb3JDb252ZW50aW9uLFxuICAgICAgZXJyb3JNZXRhZGF0YUl0ZW0sXG4gICAgICBnZXREeW5hbWljUGFyYW1Gcm9tU2VnbWVudCxcbiAgICAgIHdvcmtTdG9yZVxuICAgIClcbiAgfVxuXG4gIGlmIChPYmplY3Qua2V5cyhwYXJhbGxlbFJvdXRlcykubGVuZ3RoID09PSAwICYmIGVycm9yQ29udmVudGlvbikge1xuICAgIC8vIElmIHRoZXJlIGFyZSBubyBwYXJhbGxlbCByb3V0ZXMsIHBsYWNlIGVycm9yIG1ldGFkYXRhIGFzIHRoZSBsYXN0IGl0ZW0uXG4gICAgLy8gZS5nLiBsYXlvdXQgLT4gbGF5b3V0IC0+IG5vdC1mb3VuZFxuICAgIG1ldGFkYXRhSXRlbXMucHVzaChlcnJvck1ldGFkYXRhSXRlbSlcbiAgfVxuXG4gIHJldHVybiBtZXRhZGF0YUl0ZW1zXG59XG5cbnR5cGUgRXJyb3JWaWV3cG9ydEl0ZW1SZWYgPSB7IGN1cnJlbnQ6IFZpZXdwb3J0SXRlbXNbbnVtYmVyXSB9XG5jb25zdCByZXNvbHZlVmlld3BvcnRJdGVtcyA9IGNhY2hlKGFzeW5jIGZ1bmN0aW9uIChcbiAgdHJlZTogTG9hZGVyVHJlZSxcbiAgc2VhcmNoUGFyYW1zOiBQcm9taXNlPFBhcnNlZFVybFF1ZXJ5PixcbiAgZXJyb3JDb252ZW50aW9uOiBNZXRhZGF0YUVycm9yVHlwZSB8IHVuZGVmaW5lZCxcbiAgZ2V0RHluYW1pY1BhcmFtRnJvbVNlZ21lbnQ6IEdldER5bmFtaWNQYXJhbUZyb21TZWdtZW50LFxuICB3b3JrU3RvcmU6IFdvcmtTdG9yZVxuKSB7XG4gIGNvbnN0IHBhcmVudFBhcmFtcyA9IHt9XG4gIGNvbnN0IHZpZXdwb3J0SXRlbXM6IFZpZXdwb3J0SXRlbXMgPSBbXVxuICBjb25zdCBlcnJvclZpZXdwb3J0SXRlbVJlZjogRXJyb3JWaWV3cG9ydEl0ZW1SZWYgPSB7XG4gICAgY3VycmVudDogbnVsbCxcbiAgfVxuICBjb25zdCB0cmVlUHJlZml4ID0gdW5kZWZpbmVkXG4gIHJldHVybiByZXNvbHZlVmlld3BvcnRJdGVtc0ltcGwoXG4gICAgdmlld3BvcnRJdGVtcyxcbiAgICB0cmVlLFxuICAgIHRyZWVQcmVmaXgsXG4gICAgcGFyZW50UGFyYW1zLFxuICAgIHNlYXJjaFBhcmFtcyxcbiAgICBlcnJvckNvbnZlbnRpb24sXG4gICAgZXJyb3JWaWV3cG9ydEl0ZW1SZWYsXG4gICAgZ2V0RHluYW1pY1BhcmFtRnJvbVNlZ21lbnQsXG4gICAgd29ya1N0b3JlXG4gIClcbn0pXG5cbmFzeW5jIGZ1bmN0aW9uIHJlc29sdmVWaWV3cG9ydEl0ZW1zSW1wbChcbiAgdmlld3BvcnRJdGVtczogVmlld3BvcnRJdGVtcyxcbiAgdHJlZTogTG9hZGVyVHJlZSxcbiAgLyoqIFByb3ZpZGVkIHRyZWUgY2FuIGJlIG5lc3RlZCBzdWJ0cmVlLCB0aGlzIGFyZ3VtZW50IHNheXMgd2hhdCBpcyB0aGUgcGF0aCBvZiBzdWNoIHN1YnRyZWUgKi9cbiAgdHJlZVByZWZpeDogdW5kZWZpbmVkIHwgc3RyaW5nW10sXG4gIHBhcmVudFBhcmFtczogUGFyYW1zLFxuICBzZWFyY2hQYXJhbXM6IFByb21pc2U8UGFyc2VkVXJsUXVlcnk+LFxuICBlcnJvckNvbnZlbnRpb246IE1ldGFkYXRhRXJyb3JUeXBlIHwgdW5kZWZpbmVkLFxuICBlcnJvclZpZXdwb3J0SXRlbVJlZjogRXJyb3JWaWV3cG9ydEl0ZW1SZWYsXG4gIGdldER5bmFtaWNQYXJhbUZyb21TZWdtZW50OiBHZXREeW5hbWljUGFyYW1Gcm9tU2VnbWVudCxcbiAgd29ya1N0b3JlOiBXb3JrU3RvcmVcbik6IFByb21pc2U8Vmlld3BvcnRJdGVtcz4ge1xuICBjb25zdCBbc2VnbWVudCwgcGFyYWxsZWxSb3V0ZXMsIHsgcGFnZSB9XSA9IHRyZWVcbiAgY29uc3QgY3VycmVudFRyZWVQcmVmaXggPVxuICAgIHRyZWVQcmVmaXggJiYgdHJlZVByZWZpeC5sZW5ndGggPyBbLi4udHJlZVByZWZpeCwgc2VnbWVudF0gOiBbc2VnbWVudF1cbiAgY29uc3QgaXNQYWdlID0gdHlwZW9mIHBhZ2UgIT09ICd1bmRlZmluZWQnXG5cbiAgLy8gSGFuZGxlIGR5bmFtaWMgc2VnbWVudCBwYXJhbXMuXG4gIGNvbnN0IHNlZ21lbnRQYXJhbSA9IGdldER5bmFtaWNQYXJhbUZyb21TZWdtZW50KHNlZ21lbnQpXG4gIC8qKlxuICAgKiBDcmVhdGUgb2JqZWN0IGhvbGRpbmcgdGhlIHBhcmVudCBwYXJhbXMgYW5kIGN1cnJlbnQgcGFyYW1zXG4gICAqL1xuICBsZXQgY3VycmVudFBhcmFtcyA9IHBhcmVudFBhcmFtc1xuICBpZiAoc2VnbWVudFBhcmFtICYmIHNlZ21lbnRQYXJhbS52YWx1ZSAhPT0gbnVsbCkge1xuICAgIGN1cnJlbnRQYXJhbXMgPSB7XG4gICAgICAuLi5wYXJlbnRQYXJhbXMsXG4gICAgICBbc2VnbWVudFBhcmFtLnBhcmFtXTogc2VnbWVudFBhcmFtLnZhbHVlLFxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHBhcmFtcyA9IGNyZWF0ZVNlcnZlclBhcmFtc0Zvck1ldGFkYXRhKGN1cnJlbnRQYXJhbXMsIHdvcmtTdG9yZSlcblxuICBsZXQgbGF5ZXJQcm9wczogTGF5b3V0UHJvcHMgfCBQYWdlUHJvcHNcbiAgaWYgKGlzUGFnZSkge1xuICAgIGxheWVyUHJvcHMgPSB7XG4gICAgICBwYXJhbXMsXG4gICAgICBzZWFyY2hQYXJhbXMsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxheWVyUHJvcHMgPSB7XG4gICAgICBwYXJhbXMsXG4gICAgfVxuICB9XG5cbiAgYXdhaXQgY29sbGVjdFZpZXdwb3J0KHtcbiAgICB0cmVlLFxuICAgIHZpZXdwb3J0SXRlbXMsXG4gICAgZXJyb3JWaWV3cG9ydEl0ZW1SZWYsXG4gICAgZXJyb3JDb252ZW50aW9uLFxuICAgIHByb3BzOiBsYXllclByb3BzLFxuICAgIHJvdXRlOiBjdXJyZW50VHJlZVByZWZpeFxuICAgICAgLy8gX19QQUdFX18gc2hvdWxkbid0IGJlIHNob3duIGluIGEgcm91dGVcbiAgICAgIC5maWx0ZXIoKHMpID0+IHMgIT09IFBBR0VfU0VHTUVOVF9LRVkpXG4gICAgICAuam9pbignLycpLFxuICB9KVxuXG4gIGZvciAoY29uc3Qga2V5IGluIHBhcmFsbGVsUm91dGVzKSB7XG4gICAgY29uc3QgY2hpbGRUcmVlID0gcGFyYWxsZWxSb3V0ZXNba2V5XVxuICAgIGF3YWl0IHJlc29sdmVWaWV3cG9ydEl0ZW1zSW1wbChcbiAgICAgIHZpZXdwb3J0SXRlbXMsXG4gICAgICBjaGlsZFRyZWUsXG4gICAgICBjdXJyZW50VHJlZVByZWZpeCxcbiAgICAgIGN1cnJlbnRQYXJhbXMsXG4gICAgICBzZWFyY2hQYXJhbXMsXG4gICAgICBlcnJvckNvbnZlbnRpb24sXG4gICAgICBlcnJvclZpZXdwb3J0SXRlbVJlZixcbiAgICAgIGdldER5bmFtaWNQYXJhbUZyb21TZWdtZW50LFxuICAgICAgd29ya1N0b3JlXG4gICAgKVxuICB9XG5cbiAgaWYgKE9iamVjdC5rZXlzKHBhcmFsbGVsUm91dGVzKS5sZW5ndGggPT09IDAgJiYgZXJyb3JDb252ZW50aW9uKSB7XG4gICAgLy8gSWYgdGhlcmUgYXJlIG5vIHBhcmFsbGVsIHJvdXRlcywgcGxhY2UgZXJyb3IgbWV0YWRhdGEgYXMgdGhlIGxhc3QgaXRlbS5cbiAgICAvLyBlLmcuIGxheW91dCAtPiBsYXlvdXQgLT4gbm90LWZvdW5kXG4gICAgdmlld3BvcnRJdGVtcy5wdXNoKGVycm9yVmlld3BvcnRJdGVtUmVmLmN1cnJlbnQpXG4gIH1cblxuICByZXR1cm4gdmlld3BvcnRJdGVtc1xufVxuXG50eXBlIFdpdGhUaXRsZSA9IHsgdGl0bGU/OiBBYnNvbHV0ZVRlbXBsYXRlU3RyaW5nIHwgbnVsbCB9XG50eXBlIFdpdGhEZXNjcmlwdGlvbiA9IHsgZGVzY3JpcHRpb24/OiBzdHJpbmcgfCBudWxsIH1cblxuY29uc3QgaXNUaXRsZVRydXRoeSA9ICh0aXRsZTogQWJzb2x1dGVUZW1wbGF0ZVN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQpID0+XG4gICEhdGl0bGU/LmFic29sdXRlXG5jb25zdCBoYXNUaXRsZSA9IChtZXRhZGF0YTogV2l0aFRpdGxlIHwgbnVsbCkgPT4gaXNUaXRsZVRydXRoeShtZXRhZGF0YT8udGl0bGUpXG5cbmZ1bmN0aW9uIGluaGVyaXRGcm9tTWV0YWRhdGEoXG4gIHRhcmdldDogKFdpdGhUaXRsZSAmIFdpdGhEZXNjcmlwdGlvbikgfCBudWxsLFxuICBtZXRhZGF0YTogUmVzb2x2ZWRNZXRhZGF0YVxuKSB7XG4gIGlmICh0YXJnZXQpIHtcbiAgICBpZiAoIWhhc1RpdGxlKHRhcmdldCkgJiYgaGFzVGl0bGUobWV0YWRhdGEpKSB7XG4gICAgICB0YXJnZXQudGl0bGUgPSBtZXRhZGF0YS50aXRsZVxuICAgIH1cbiAgICBpZiAoIXRhcmdldC5kZXNjcmlwdGlvbiAmJiBtZXRhZGF0YS5kZXNjcmlwdGlvbikge1xuICAgICAgdGFyZ2V0LmRlc2NyaXB0aW9uID0gbWV0YWRhdGEuZGVzY3JpcHRpb25cbiAgICB9XG4gIH1cbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuY29uc3QgY29tbW9uT2dLZXlzID0gWyd0aXRsZScsICdkZXNjcmlwdGlvbicsICdpbWFnZXMnXSBhcyBjb25zdFxuZnVuY3Rpb24gcG9zdFByb2Nlc3NNZXRhZGF0YShcbiAgbWV0YWRhdGE6IFJlc29sdmVkTWV0YWRhdGEsXG4gIGZhdmljb246IGFueSxcbiAgdGl0bGVUZW1wbGF0ZXM6IFRpdGxlVGVtcGxhdGVzLFxuICBtZXRhZGF0YUNvbnRleHQ6IE1ldGFkYXRhQ29udGV4dFxuKTogUmVzb2x2ZWRNZXRhZGF0YSB7XG4gIGNvbnN0IHsgb3BlbkdyYXBoLCB0d2l0dGVyIH0gPSBtZXRhZGF0YVxuXG4gIGlmIChvcGVuR3JhcGgpIHtcbiAgICAvLyBJZiB0aGVyZSdzIG9wZW5HcmFwaCBpbmZvcm1hdGlvbiBidXQgbm90IGNvbmZpZ3VyZWQgaW4gdHdpdHRlcixcbiAgICAvLyBpbmhlcml0IHRoZW0gZnJvbSBvcGVuR3JhcGggbWV0YWRhdGEuXG4gICAgbGV0IGF1dG9GaWxsUHJvcHM6IFBhcnRpYWw8e1xuICAgICAgW0tleSBpbiAodHlwZW9mIGNvbW1vbk9nS2V5cylbbnVtYmVyXV06IE5vbk51bGxhYmxlPFxuICAgICAgICBSZXNvbHZlZE1ldGFkYXRhWydvcGVuR3JhcGgnXVxuICAgICAgPltLZXldXG4gICAgfT4gPSB7fVxuICAgIGNvbnN0IGhhc1R3VGl0bGUgPSBoYXNUaXRsZSh0d2l0dGVyKVxuICAgIGNvbnN0IGhhc1R3RGVzY3JpcHRpb24gPSB0d2l0dGVyPy5kZXNjcmlwdGlvblxuICAgIGNvbnN0IGhhc1R3SW1hZ2VzID0gQm9vbGVhbihcbiAgICAgIHR3aXR0ZXI/Lmhhc093blByb3BlcnR5KCdpbWFnZXMnKSAmJiB0d2l0dGVyLmltYWdlc1xuICAgIClcbiAgICBpZiAoIWhhc1R3VGl0bGUpIHtcbiAgICAgIGlmIChpc1RpdGxlVHJ1dGh5KG9wZW5HcmFwaC50aXRsZSkpIHtcbiAgICAgICAgYXV0b0ZpbGxQcm9wcy50aXRsZSA9IG9wZW5HcmFwaC50aXRsZVxuICAgICAgfSBlbHNlIGlmIChtZXRhZGF0YS50aXRsZSAmJiBpc1RpdGxlVHJ1dGh5KG1ldGFkYXRhLnRpdGxlKSkge1xuICAgICAgICBhdXRvRmlsbFByb3BzLnRpdGxlID0gbWV0YWRhdGEudGl0bGVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFoYXNUd0Rlc2NyaXB0aW9uKVxuICAgICAgYXV0b0ZpbGxQcm9wcy5kZXNjcmlwdGlvbiA9XG4gICAgICAgIG9wZW5HcmFwaC5kZXNjcmlwdGlvbiB8fCBtZXRhZGF0YS5kZXNjcmlwdGlvbiB8fCB1bmRlZmluZWRcbiAgICBpZiAoIWhhc1R3SW1hZ2VzKSBhdXRvRmlsbFByb3BzLmltYWdlcyA9IG9wZW5HcmFwaC5pbWFnZXNcblxuICAgIGlmIChPYmplY3Qua2V5cyhhdXRvRmlsbFByb3BzKS5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBwYXJ0aWFsVHdpdHRlciA9IHJlc29sdmVUd2l0dGVyKFxuICAgICAgICBhdXRvRmlsbFByb3BzLFxuICAgICAgICBtZXRhZGF0YS5tZXRhZGF0YUJhc2UsXG4gICAgICAgIG1ldGFkYXRhQ29udGV4dCxcbiAgICAgICAgdGl0bGVUZW1wbGF0ZXMudHdpdHRlclxuICAgICAgKVxuICAgICAgaWYgKG1ldGFkYXRhLnR3aXR0ZXIpIHtcbiAgICAgICAgbWV0YWRhdGEudHdpdHRlciA9IE9iamVjdC5hc3NpZ24oe30sIG1ldGFkYXRhLnR3aXR0ZXIsIHtcbiAgICAgICAgICAuLi4oIWhhc1R3VGl0bGUgJiYgeyB0aXRsZTogcGFydGlhbFR3aXR0ZXI/LnRpdGxlIH0pLFxuICAgICAgICAgIC4uLighaGFzVHdEZXNjcmlwdGlvbiAmJiB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogcGFydGlhbFR3aXR0ZXI/LmRlc2NyaXB0aW9uLFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIC4uLighaGFzVHdJbWFnZXMgJiYgeyBpbWFnZXM6IHBhcnRpYWxUd2l0dGVyPy5pbWFnZXMgfSksXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZXRhZGF0YS50d2l0dGVyID0gcGFydGlhbFR3aXR0ZXJcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBJZiB0aGVyZSdzIG5vIHRpdGxlIGFuZCBkZXNjcmlwdGlvbiBjb25maWd1cmVkIGluIG9wZW5HcmFwaCBvciB0d2l0dGVyLFxuICAvLyB1c2UgdGhlIHRpdGxlIGFuZCBkZXNjcmlwdGlvbiBmcm9tIG1ldGFkYXRhLlxuICBpbmhlcml0RnJvbU1ldGFkYXRhKG9wZW5HcmFwaCwgbWV0YWRhdGEpXG4gIGluaGVyaXRGcm9tTWV0YWRhdGEodHdpdHRlciwgbWV0YWRhdGEpXG5cbiAgaWYgKGZhdmljb24pIHtcbiAgICBpZiAoIW1ldGFkYXRhLmljb25zKSB7XG4gICAgICBtZXRhZGF0YS5pY29ucyA9IHtcbiAgICAgICAgaWNvbjogW10sXG4gICAgICAgIGFwcGxlOiBbXSxcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtZXRhZGF0YS5pY29ucy5pY29uLnVuc2hpZnQoZmF2aWNvbilcbiAgfVxuXG4gIHJldHVybiBtZXRhZGF0YVxufVxuXG50eXBlIFJlc3VsdDxUPiA9IG51bGwgfCBUIHwgUHJvbWlzZTxudWxsIHwgVD4gfCBQcm9taXNlTGlrZTxudWxsIHwgVD5cblxuZnVuY3Rpb24gcHJlcmVuZGVyTWV0YWRhdGEobWV0YWRhdGFJdGVtczogTWV0YWRhdGFJdGVtcykge1xuICAvLyBJZiB0aGUgaW5kZXggaXMgYSBmdW5jdGlvbiB0aGVuIGl0IGlzIGEgcmVzb2x2ZXIgYW5kIHRoZSBuZXh0IHNsb3RcbiAgLy8gaXMgdGhlIGNvcnJlc3BvbmRpbmcgcmVzdWx0LiBJZiB0aGUgaW5kZXggaXMgbm90IGEgZnVuY3Rpb24gaXQgaXMgdGhlIHJlc3VsdFxuICAvLyBpdHNlbGYuXG4gIGNvbnN0IHJlc29sdmVyc0FuZFJlc3VsdHM6IEFycmF5PFxuICAgICgodmFsdWU6IFJlc29sdmVkTWV0YWRhdGEpID0+IHZvaWQpIHwgUmVzdWx0PE1ldGFkYXRhPlxuICA+ID0gW11cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXRhZGF0YUl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgbWV0YWRhdGFFeHBvcnQgPSBtZXRhZGF0YUl0ZW1zW2ldWzBdXG4gICAgZ2V0UmVzdWx0KHJlc29sdmVyc0FuZFJlc3VsdHMsIG1ldGFkYXRhRXhwb3J0KVxuICB9XG4gIHJldHVybiByZXNvbHZlcnNBbmRSZXN1bHRzXG59XG5cbmZ1bmN0aW9uIHByZXJlbmRlclZpZXdwb3J0KHZpZXdwb3J0SXRlbXM6IFZpZXdwb3J0SXRlbXMpIHtcbiAgLy8gSWYgdGhlIGluZGV4IGlzIGEgZnVuY3Rpb24gdGhlbiBpdCBpcyBhIHJlc29sdmVyIGFuZCB0aGUgbmV4dCBzbG90XG4gIC8vIGlzIHRoZSBjb3JyZXNwb25kaW5nIHJlc3VsdC4gSWYgdGhlIGluZGV4IGlzIG5vdCBhIGZ1bmN0aW9uIGl0IGlzIHRoZSByZXN1bHRcbiAgLy8gaXRzZWxmLlxuICBjb25zdCByZXNvbHZlcnNBbmRSZXN1bHRzOiBBcnJheTxcbiAgICAoKHZhbHVlOiBSZXNvbHZlZFZpZXdwb3J0KSA9PiB2b2lkKSB8IFJlc3VsdDxWaWV3cG9ydD5cbiAgPiA9IFtdXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmlld3BvcnRJdGVtcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHZpZXdwb3J0RXhwb3J0ID0gdmlld3BvcnRJdGVtc1tpXVxuICAgIGdldFJlc3VsdChyZXNvbHZlcnNBbmRSZXN1bHRzLCB2aWV3cG9ydEV4cG9ydClcbiAgfVxuICByZXR1cm4gcmVzb2x2ZXJzQW5kUmVzdWx0c1xufVxuXG50eXBlIFJlc29sdmVkPFQ+ID0gVCBleHRlbmRzIE1ldGFkYXRhID8gUmVzb2x2ZWRNZXRhZGF0YSA6IFJlc29sdmVkVmlld3BvcnRcblxuZnVuY3Rpb24gZ2V0UmVzdWx0PFQgZXh0ZW5kcyBNZXRhZGF0YSB8IFZpZXdwb3J0PihcbiAgcmVzb2x2ZXJzQW5kUmVzdWx0czogQXJyYXk8KCh2YWx1ZTogUmVzb2x2ZWQ8VD4pID0+IHZvaWQpIHwgUmVzdWx0PFQ+PixcbiAgZXhwb3J0Rm9yUmVzdWx0OiBudWxsIHwgVCB8ICgocGFyZW50OiBQcm9taXNlPFJlc29sdmVkPFQ+PikgPT4gUmVzdWx0PFQ+KVxuKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0Rm9yUmVzdWx0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gZXhwb3J0Rm9yUmVzdWx0KFxuICAgICAgbmV3IFByb21pc2U8UmVzb2x2ZWQ8VD4+KChyZXNvbHZlKSA9PiByZXNvbHZlcnNBbmRSZXN1bHRzLnB1c2gocmVzb2x2ZSkpXG4gICAgKVxuICAgIHJlc29sdmVyc0FuZFJlc3VsdHMucHVzaChyZXN1bHQpXG4gICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgIC8vIHNpbmNlIHdlIGVhZ2VyIGV4ZWN1dGUgZ2VuZXJhdGVNZXRhZGF0YSBhbmRcbiAgICAgIC8vIHRoZXkgY2FuIHJlamVjdCBhdCBhbnl0aW1lIHdlIG5lZWQgdG8gZW5zdXJlXG4gICAgICAvLyB3ZSBhdHRhY2ggdGhlIGNhdGNoIGhhbmRsZXIgcmlnaHQgYXdheSB0b1xuICAgICAgLy8gcHJldmVudCB1bmhhbmRsZWQgcmVqZWN0aW9ucyBjcmFzaGluZyB0aGUgcHJvY2Vzc1xuICAgICAgcmVzdWx0LmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBfX25leHRFcnJvcjogZXJyLFxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0Rm9yUmVzdWx0ID09PSAnb2JqZWN0Jykge1xuICAgIHJlc29sdmVyc0FuZFJlc3VsdHMucHVzaChleHBvcnRGb3JSZXN1bHQpXG4gIH0gZWxzZSB7XG4gICAgcmVzb2x2ZXJzQW5kUmVzdWx0cy5wdXNoKG51bGwpXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVBlbmRpbmdSZXN1bHQ8XG4gIFJlc29sdmVkVHlwZSBleHRlbmRzIFJlc29sdmVkTWV0YWRhdGEgfCBSZXNvbHZlZFZpZXdwb3J0LFxuPihcbiAgcGFyZW50UmVzdWx0OiBSZXNvbHZlZFR5cGUsXG4gIHJlc29sdmVQYXJlbnRSZXN1bHQ6ICh2YWx1ZTogUmVzb2x2ZWRUeXBlKSA9PiB2b2lkXG4pOiB2b2lkIHtcbiAgLy8gSW4gZGV2IHdlIGNsb25lIGFuZCBmcmVlemUgdG8gcHJldmVudCByZWx5aW5nIG9uIG11dGF0aW5nIHJlc29sdmVkTWV0YWRhdGEgZGlyZWN0bHkuXG4gIC8vIEluIHByb2Qgd2UganVzdCBwYXNzIHJlc29sdmVkTWV0YWRhdGEgdGhyb3VnaCB3aXRob3V0IGFueSBjb3B5aW5nLlxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0tIERlZXBSZWFkb25seTxUPiBpcyBieSBkZWZpbml0aW9uIG5vdCBhc3NpZ25hYmxlIHRvIFRcbiAgICAvLyBJbnN0ZWFkLCB3ZSBzaG91bGQgb25seSBhY2NlcHQgRGVlcFJlYWRvbmx5PFJlc29sdmVkVHlwZT5cbiAgICBwYXJlbnRSZXN1bHQgPSAoXG4gICAgICByZXF1aXJlKCcuLi8uLi9zaGFyZWQvbGliL2RlZXAtZnJlZXplJykgYXMgdHlwZW9mIGltcG9ydCgnLi4vLi4vc2hhcmVkL2xpYi9kZWVwLWZyZWV6ZScpXG4gICAgKS5kZWVwRnJlZXplKFxuICAgICAgKFxuICAgICAgICByZXF1aXJlKCcuL2Nsb25lLW1ldGFkYXRhJykgYXMgdHlwZW9mIGltcG9ydCgnLi9jbG9uZS1tZXRhZGF0YScpXG4gICAgICApLmNsb25lTWV0YWRhdGEocGFyZW50UmVzdWx0KVxuICAgIClcbiAgfVxuXG4gIHJlc29sdmVQYXJlbnRSZXN1bHQocGFyZW50UmVzdWx0KVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYWNjdW11bGF0ZU1ldGFkYXRhKFxuICByb3V0ZTogc3RyaW5nLFxuICBtZXRhZGF0YUl0ZW1zOiBNZXRhZGF0YUl0ZW1zLFxuICBwYXRobmFtZTogUHJvbWlzZTxzdHJpbmc+LFxuICBtZXRhZGF0YUNvbnRleHQ6IE1ldGFkYXRhQ29udGV4dFxuKTogUHJvbWlzZTxSZXNvbHZlZE1ldGFkYXRhPiB7XG4gIGxldCByZXNvbHZlZE1ldGFkYXRhID0gY3JlYXRlRGVmYXVsdE1ldGFkYXRhKClcblxuICBsZXQgdGl0bGVUZW1wbGF0ZXM6IFRpdGxlVGVtcGxhdGVzID0ge1xuICAgIHRpdGxlOiBudWxsLFxuICAgIHR3aXR0ZXI6IG51bGwsXG4gICAgb3BlbkdyYXBoOiBudWxsLFxuICB9XG5cbiAgY29uc3QgYnVpbGRTdGF0ZSA9IHtcbiAgICB3YXJuaW5nczogbmV3IFNldDxzdHJpbmc+KCksXG4gIH1cblxuICBsZXQgZmF2aWNvblxuXG4gIC8vIENvbGxlY3QgdGhlIHN0YXRpYyBpY29ucyBpbiB0aGUgbW9zdCBsZWFmIG5vZGUsXG4gIC8vIHNpbmNlIHdlIGRvbid0IGNvbGxlY3QgYWxsIHRoZSBzdGF0aWMgbWV0YWRhdGEgaWNvbnMgaW4gdGhlIHBhcmVudCBzZWdtZW50cy5cbiAgY29uc3QgbGVhZlNlZ21lbnRTdGF0aWNJY29ucyA9IHtcbiAgICBpY29uOiBbXSxcbiAgICBhcHBsZTogW10sXG4gIH1cblxuICBjb25zdCByZXNvbHZlcnNBbmRSZXN1bHRzID0gcHJlcmVuZGVyTWV0YWRhdGEobWV0YWRhdGFJdGVtcylcbiAgbGV0IHJlc3VsdEluZGV4ID0gMFxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWV0YWRhdGFJdGVtcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHN0YXRpY0ZpbGVzTWV0YWRhdGEgPSBtZXRhZGF0YUl0ZW1zW2ldWzFdXG4gICAgLy8gVHJlYXQgZmF2aWNvbiBhcyBzcGVjaWFsIGNhc2UsIGl0IHNob3VsZCBiZSB0aGUgZmlyc3QgaWNvbiBpbiB0aGUgbGlzdFxuICAgIC8vIGkgPD0gMSByZXByZXNlbnRzIHJvb3QgbGF5b3V0LCBhbmQgaWYgY3VycmVudCBwYWdlIGlzIGFsc28gYXQgcm9vdFxuICAgIGlmIChpIDw9IDEgJiYgaXNGYXZpY29uKHN0YXRpY0ZpbGVzTWV0YWRhdGE/Lmljb24/LlswXSkpIHtcbiAgICAgIGNvbnN0IGljb25Nb2QgPSBzdGF0aWNGaWxlc01ldGFkYXRhPy5pY29uPy5zaGlmdCgpXG4gICAgICBpZiAoaSA9PT0gMCkgZmF2aWNvbiA9IGljb25Nb2RcbiAgICB9XG5cbiAgICBsZXQgcGVuZGluZ01ldGFkYXRhID0gcmVzb2x2ZXJzQW5kUmVzdWx0c1tyZXN1bHRJbmRleCsrXVxuICAgIGlmICh0eXBlb2YgcGVuZGluZ01ldGFkYXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBUaGlzIG1ldGFkYXRhIGl0ZW0gaGFkIGEgYGdlbmVyYXRlTWV0YWRhdGFgIGFuZFxuICAgICAgLy8gd2UgbmVlZCB0byBwcm92aWRlIHRoZSBjdXJyZW50bHkgcmVzb2x2ZWQgbWV0YWRhdGFcbiAgICAgIC8vIHRvIGl0IGJlZm9yZSB3ZSBjb250aW51ZTtcbiAgICAgIGNvbnN0IHJlc29sdmVQYXJlbnRNZXRhZGF0YSA9IHBlbmRpbmdNZXRhZGF0YVxuICAgICAgLy8gd2Uga25vdyB0aGF0IHRoZSBuZXh0IGl0ZW0gaXMgYSByZXN1bHQgaWYgdGhpcyBpdGVtXG4gICAgICAvLyB3YXMgYSByZXNvbHZlclxuICAgICAgcGVuZGluZ01ldGFkYXRhID0gcmVzb2x2ZXJzQW5kUmVzdWx0c1tyZXN1bHRJbmRleCsrXSBhcyBSZXN1bHQ8TWV0YWRhdGE+XG5cbiAgICAgIHJlc29sdmVQZW5kaW5nUmVzdWx0KHJlc29sdmVkTWV0YWRhdGEsIHJlc29sdmVQYXJlbnRNZXRhZGF0YSlcbiAgICB9XG4gICAgLy8gT3RoZXJ3aXNlIHRoZSBpdGVtIHdhcyBlaXRoZXIgbnVsbCBvciBhIHN0YXRpYyBleHBvcnRcblxuICAgIGxldCBtZXRhZGF0YTogTWV0YWRhdGEgfCBudWxsXG4gICAgaWYgKGlzUHJvbWlzZUxpa2UocGVuZGluZ01ldGFkYXRhKSkge1xuICAgICAgbWV0YWRhdGEgPSBhd2FpdCBwZW5kaW5nTWV0YWRhdGFcbiAgICB9IGVsc2Uge1xuICAgICAgbWV0YWRhdGEgPSBwZW5kaW5nTWV0YWRhdGFcbiAgICB9XG5cbiAgICByZXNvbHZlZE1ldGFkYXRhID0gYXdhaXQgbWVyZ2VNZXRhZGF0YShyb3V0ZSwgcGF0aG5hbWUsIHtcbiAgICAgIHRhcmdldDogcmVzb2x2ZWRNZXRhZGF0YSxcbiAgICAgIHNvdXJjZTogbWV0YWRhdGEsXG4gICAgICBtZXRhZGF0YUNvbnRleHQsXG4gICAgICBzdGF0aWNGaWxlc01ldGFkYXRhLFxuICAgICAgdGl0bGVUZW1wbGF0ZXMsXG4gICAgICBidWlsZFN0YXRlLFxuICAgICAgbGVhZlNlZ21lbnRTdGF0aWNJY29ucyxcbiAgICB9KVxuXG4gICAgLy8gSWYgdGhlIGxheW91dCBpcyB0aGUgc2FtZSBsYXllciB3aXRoIHBhZ2UsIHNraXAgdGhlIGxlYWYgbGF5b3V0IGFuZCBsZWFmIHBhZ2VcbiAgICAvLyBUaGUgbGVhZiBsYXlvdXQgYW5kIHBhZ2UgYXJlIHRoZSBsYXN0IHR3byBpdGVtc1xuICAgIGlmIChpIDwgbWV0YWRhdGFJdGVtcy5sZW5ndGggLSAyKSB7XG4gICAgICB0aXRsZVRlbXBsYXRlcyA9IHtcbiAgICAgICAgdGl0bGU6IHJlc29sdmVkTWV0YWRhdGEudGl0bGU/LnRlbXBsYXRlIHx8IG51bGwsXG4gICAgICAgIG9wZW5HcmFwaDogcmVzb2x2ZWRNZXRhZGF0YS5vcGVuR3JhcGg/LnRpdGxlLnRlbXBsYXRlIHx8IG51bGwsXG4gICAgICAgIHR3aXR0ZXI6IHJlc29sdmVkTWV0YWRhdGEudHdpdHRlcj8udGl0bGUudGVtcGxhdGUgfHwgbnVsbCxcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoXG4gICAgbGVhZlNlZ21lbnRTdGF0aWNJY29ucy5pY29uLmxlbmd0aCA+IDAgfHxcbiAgICBsZWFmU2VnbWVudFN0YXRpY0ljb25zLmFwcGxlLmxlbmd0aCA+IDBcbiAgKSB7XG4gICAgaWYgKCFyZXNvbHZlZE1ldGFkYXRhLmljb25zKSB7XG4gICAgICByZXNvbHZlZE1ldGFkYXRhLmljb25zID0ge1xuICAgICAgICBpY29uOiBbXSxcbiAgICAgICAgYXBwbGU6IFtdLFxuICAgICAgfVxuICAgICAgaWYgKGxlYWZTZWdtZW50U3RhdGljSWNvbnMuaWNvbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJlc29sdmVkTWV0YWRhdGEuaWNvbnMuaWNvbi51bnNoaWZ0KC4uLmxlYWZTZWdtZW50U3RhdGljSWNvbnMuaWNvbilcbiAgICAgIH1cbiAgICAgIGlmIChsZWFmU2VnbWVudFN0YXRpY0ljb25zLmFwcGxlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmVzb2x2ZWRNZXRhZGF0YS5pY29ucy5hcHBsZS51bnNoaWZ0KC4uLmxlYWZTZWdtZW50U3RhdGljSWNvbnMuYXBwbGUpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gT25seSBsb2cgd2FybmluZ3MgaWYgdGhlcmUgYXJlIGFueSwgYW5kIG9ubHkgb25jZSBhZnRlciB0aGUgbWV0YWRhdGEgcmVzb2x2aW5nIHByb2Nlc3MgaXMgZmluaXNoZWRcbiAgaWYgKGJ1aWxkU3RhdGUud2FybmluZ3Muc2l6ZSA+IDApIHtcbiAgICBmb3IgKGNvbnN0IHdhcm5pbmcgb2YgYnVpbGRTdGF0ZS53YXJuaW5ncykge1xuICAgICAgTG9nLndhcm4od2FybmluZylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcG9zdFByb2Nlc3NNZXRhZGF0YShcbiAgICByZXNvbHZlZE1ldGFkYXRhLFxuICAgIGZhdmljb24sXG4gICAgdGl0bGVUZW1wbGF0ZXMsXG4gICAgbWV0YWRhdGFDb250ZXh0XG4gIClcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFjY3VtdWxhdGVWaWV3cG9ydChcbiAgdmlld3BvcnRJdGVtczogVmlld3BvcnRJdGVtc1xuKTogUHJvbWlzZTxSZXNvbHZlZFZpZXdwb3J0PiB7XG4gIGNvbnN0IHJlc29sdmVkVmlld3BvcnQ6IFJlc29sdmVkVmlld3BvcnQgPSBjcmVhdGVEZWZhdWx0Vmlld3BvcnQoKVxuXG4gIGNvbnN0IHJlc29sdmVyc0FuZFJlc3VsdHMgPSBwcmVyZW5kZXJWaWV3cG9ydCh2aWV3cG9ydEl0ZW1zKVxuICBsZXQgaSA9IDBcblxuICB3aGlsZSAoaSA8IHJlc29sdmVyc0FuZFJlc3VsdHMubGVuZ3RoKSB7XG4gICAgbGV0IHBlbmRpbmdWaWV3cG9ydCA9IHJlc29sdmVyc0FuZFJlc3VsdHNbaSsrXVxuICAgIGlmICh0eXBlb2YgcGVuZGluZ1ZpZXdwb3J0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyB0aGlzIHZpZXdwb3J0IGl0ZW0gaGFkIGEgYGdlbmVyYXRlVmlld3BvcnRgIGFuZFxuICAgICAgLy8gd2UgbmVlZCB0byBwcm92aWRlIHRoZSBjdXJyZW50bHkgcmVzb2x2ZWQgdmlld3BvcnRcbiAgICAgIC8vIHRvIGl0IGJlZm9yZSB3ZSBjb250aW51ZTtcbiAgICAgIGNvbnN0IHJlc29sdmVQYXJlbnRWaWV3cG9ydCA9IHBlbmRpbmdWaWV3cG9ydFxuICAgICAgLy8gd2Uga25vdyB0aGF0IHRoZSBuZXh0IGl0ZW0gaXMgYSByZXN1bHQgaWYgdGhpcyBpdGVtXG4gICAgICAvLyB3YXMgYSByZXNvbHZlclxuICAgICAgcGVuZGluZ1ZpZXdwb3J0ID0gcmVzb2x2ZXJzQW5kUmVzdWx0c1tpKytdIGFzIFJlc3VsdDxWaWV3cG9ydD5cblxuICAgICAgcmVzb2x2ZVBlbmRpbmdSZXN1bHQocmVzb2x2ZWRWaWV3cG9ydCwgcmVzb2x2ZVBhcmVudFZpZXdwb3J0KVxuICAgIH1cbiAgICAvLyBPdGhlcndpc2UgdGhlIGl0ZW0gd2FzIGVpdGhlciBudWxsIG9yIGEgc3RhdGljIGV4cG9ydFxuXG4gICAgbGV0IHZpZXdwb3J0OiBWaWV3cG9ydCB8IG51bGxcbiAgICBpZiAoaXNQcm9taXNlTGlrZShwZW5kaW5nVmlld3BvcnQpKSB7XG4gICAgICB2aWV3cG9ydCA9IGF3YWl0IHBlbmRpbmdWaWV3cG9ydFxuICAgIH0gZWxzZSB7XG4gICAgICB2aWV3cG9ydCA9IHBlbmRpbmdWaWV3cG9ydFxuICAgIH1cblxuICAgIG1lcmdlVmlld3BvcnQoe1xuICAgICAgdGFyZ2V0OiByZXNvbHZlZFZpZXdwb3J0LFxuICAgICAgc291cmNlOiB2aWV3cG9ydCxcbiAgICB9KVxuICB9XG4gIHJldHVybiByZXNvbHZlZFZpZXdwb3J0XG59XG5cbi8vIEV4cG9zZWQgQVBJIGZvciBtZXRhZGF0YSBjb21wb25lbnQsIHRoYXQgZGlyZWN0bHkgcmVzb2x2ZSB0aGUgbG9hZGVyIHRyZWUgYW5kIHJlbGF0ZWQgY29udGV4dCBhcyByZXNvbHZlZCBtZXRhZGF0YS5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZXNvbHZlTWV0YWRhdGEoXG4gIHRyZWU6IExvYWRlclRyZWUsXG4gIHBhdGhuYW1lOiBQcm9taXNlPHN0cmluZz4sXG4gIHNlYXJjaFBhcmFtczogUHJvbWlzZTxQYXJzZWRVcmxRdWVyeT4sXG4gIGVycm9yQ29udmVudGlvbjogTWV0YWRhdGFFcnJvclR5cGUgfCB1bmRlZmluZWQsXG4gIGdldER5bmFtaWNQYXJhbUZyb21TZWdtZW50OiBHZXREeW5hbWljUGFyYW1Gcm9tU2VnbWVudCxcbiAgd29ya1N0b3JlOiBXb3JrU3RvcmUsXG4gIG1ldGFkYXRhQ29udGV4dDogTWV0YWRhdGFDb250ZXh0XG4pOiBQcm9taXNlPFJlc29sdmVkTWV0YWRhdGE+IHtcbiAgY29uc3QgbWV0YWRhdGFJdGVtcyA9IGF3YWl0IHJlc29sdmVNZXRhZGF0YUl0ZW1zKFxuICAgIHRyZWUsXG4gICAgc2VhcmNoUGFyYW1zLFxuICAgIGVycm9yQ29udmVudGlvbixcbiAgICBnZXREeW5hbWljUGFyYW1Gcm9tU2VnbWVudCxcbiAgICB3b3JrU3RvcmVcbiAgKVxuICByZXR1cm4gYWNjdW11bGF0ZU1ldGFkYXRhKFxuICAgIHdvcmtTdG9yZS5yb3V0ZSxcbiAgICBtZXRhZGF0YUl0ZW1zLFxuICAgIHBhdGhuYW1lLFxuICAgIG1ldGFkYXRhQ29udGV4dFxuICApXG59XG5cbi8vIEV4cG9zZWQgQVBJIGZvciB2aWV3cG9ydCBjb21wb25lbnQsIHRoYXQgZGlyZWN0bHkgcmVzb2x2ZSB0aGUgbG9hZGVyIHRyZWUgYW5kIHJlbGF0ZWQgY29udGV4dCBhcyByZXNvbHZlZCB2aWV3cG9ydC5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZXNvbHZlVmlld3BvcnQoXG4gIHRyZWU6IExvYWRlclRyZWUsXG4gIHNlYXJjaFBhcmFtczogUHJvbWlzZTxQYXJzZWRVcmxRdWVyeT4sXG4gIGVycm9yQ29udmVudGlvbjogTWV0YWRhdGFFcnJvclR5cGUgfCB1bmRlZmluZWQsXG4gIGdldER5bmFtaWNQYXJhbUZyb21TZWdtZW50OiBHZXREeW5hbWljUGFyYW1Gcm9tU2VnbWVudCxcbiAgd29ya1N0b3JlOiBXb3JrU3RvcmVcbik6IFByb21pc2U8UmVzb2x2ZWRWaWV3cG9ydD4ge1xuICBjb25zdCB2aWV3cG9ydEl0ZW1zID0gYXdhaXQgcmVzb2x2ZVZpZXdwb3J0SXRlbXMoXG4gICAgdHJlZSxcbiAgICBzZWFyY2hQYXJhbXMsXG4gICAgZXJyb3JDb252ZW50aW9uLFxuICAgIGdldER5bmFtaWNQYXJhbUZyb21TZWdtZW50LFxuICAgIHdvcmtTdG9yZVxuICApXG4gIHJldHVybiBhY2N1bXVsYXRlVmlld3BvcnQodmlld3BvcnRJdGVtcylcbn1cblxuZnVuY3Rpb24gaXNQcm9taXNlTGlrZTxUPihcbiAgdmFsdWU6IHVua25vd24gfCBQcm9taXNlTGlrZTxUPlxuKTogdmFsdWUgaXMgUHJvbWlzZUxpa2U8VD4ge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICB2YWx1ZSAhPT0gbnVsbCAmJlxuICAgIHR5cGVvZiAodmFsdWUgYXMgUHJvbWlzZUxpa2U8dW5rbm93bj4pLnRoZW4gPT09ICdmdW5jdGlvbidcbiAgKVxufVxuIl0sIm5hbWVzIjpbImNhY2hlIiwiY3JlYXRlRGVmYXVsdE1ldGFkYXRhIiwiY3JlYXRlRGVmYXVsdFZpZXdwb3J0IiwicmVzb2x2ZU9wZW5HcmFwaCIsInJlc29sdmVUd2l0dGVyIiwicmVzb2x2ZVRpdGxlIiwicmVzb2x2ZUFzQXJyYXlPclVuZGVmaW5lZCIsImdldENvbXBvbmVudFR5cGVNb2R1bGUiLCJnZXRMYXlvdXRPclBhZ2VNb2R1bGUiLCJpbnRlcm9wRGVmYXVsdCIsInJlc29sdmVBbHRlcm5hdGVzIiwicmVzb2x2ZUFwcGxlV2ViQXBwIiwicmVzb2x2ZUFwcExpbmtzIiwicmVzb2x2ZVJvYm90cyIsInJlc29sdmVUaGVtZUNvbG9yIiwicmVzb2x2ZVZlcmlmaWNhdGlvbiIsInJlc29sdmVJdHVuZXMiLCJyZXNvbHZlRmFjZWJvb2siLCJyZXNvbHZlUGFnaW5hdGlvbiIsInJlc29sdmVJY29ucyIsImdldFRyYWNlciIsIlJlc29sdmVNZXRhZGF0YVNwYW4iLCJQQUdFX1NFR01FTlRfS0VZIiwiTG9nIiwiY3JlYXRlU2VydmVyUGFyYW1zRm9yTWV0YWRhdGEiLCJpc0Zhdmljb24iLCJpY29uIiwidXJsIiwidG9TdHJpbmciLCJzdGFydHNXaXRoIiwidHlwZSIsIm1lcmdlU3RhdGljTWV0YWRhdGEiLCJzb3VyY2UiLCJ0YXJnZXQiLCJzdGF0aWNGaWxlc01ldGFkYXRhIiwibWV0YWRhdGFDb250ZXh0IiwidGl0bGVUZW1wbGF0ZXMiLCJsZWFmU2VnbWVudFN0YXRpY0ljb25zIiwicGF0aG5hbWUiLCJhcHBsZSIsIm9wZW5HcmFwaCIsInR3aXR0ZXIiLCJtYW5pZmVzdCIsImhhc093blByb3BlcnR5IiwicmVzb2x2ZWRUd2l0dGVyIiwiaW1hZ2VzIiwibWV0YWRhdGFCYXNlIiwiaXNTdGF0aWNNZXRhZGF0YVJvdXRlRmlsZSIsInJlc29sdmVkT3BlbkdyYXBoIiwibWVyZ2VNZXRhZGF0YSIsInJvdXRlIiwiYnVpbGRTdGF0ZSIsImtleV8iLCJrZXkiLCJ0aXRsZSIsImFsdGVybmF0ZXMiLCJmYWNlYm9vayIsInZlcmlmaWNhdGlvbiIsImljb25zIiwiYXBwbGVXZWJBcHAiLCJhcHBMaW5rcyIsInJvYm90cyIsImF1dGhvcnMiLCJpdHVuZXMiLCJwYWdpbmF0aW9uIiwib3RoZXIiLCJPYmplY3QiLCJhc3NpZ24iLCJ3YXJuaW5ncyIsImFkZCIsIm1lcmdlVmlld3BvcnQiLCJ0aGVtZUNvbG9yIiwiY29sb3JTY2hlbWUiLCJnZXREZWZpbmVkVmlld3BvcnQiLCJtb2QiLCJwcm9wcyIsInRyYWNpbmdQcm9wcyIsImdlbmVyYXRlVmlld3BvcnQiLCJwYXJlbnQiLCJ0cmFjZSIsInNwYW5OYW1lIiwiYXR0cmlidXRlcyIsInZpZXdwb3J0IiwiZ2V0RGVmaW5lZE1ldGFkYXRhIiwiZ2VuZXJhdGVNZXRhZGF0YSIsIm1ldGFkYXRhIiwiY29sbGVjdFN0YXRpY0ltYWdlc0ZpbGVzIiwidW5kZWZpbmVkIiwiaWNvblByb21pc2VzIiwibWFwIiwiaW1hZ2VNb2R1bGUiLCJsZW5ndGgiLCJQcm9taXNlIiwiYWxsIiwiZmxhdCIsInJlc29sdmVTdGF0aWNNZXRhZGF0YSIsIm1vZHVsZXMiLCJzdGF0aWNNZXRhZGF0YSIsImNvbGxlY3RNZXRhZGF0YSIsInRyZWUiLCJtZXRhZGF0YUl0ZW1zIiwiZXJyb3JNZXRhZGF0YUl0ZW0iLCJlcnJvckNvbnZlbnRpb24iLCJtb2RUeXBlIiwiaGFzRXJyb3JDb252ZW50aW9uQ29tcG9uZW50IiwiQm9vbGVhbiIsImxheW91dE9yUGFnZU1vZCIsImxheW91dE9yUGFnZU1vZFR5cGUiLCJtZXRhZGF0YUV4cG9ydCIsInB1c2giLCJlcnJvck1vZCIsImVycm9yTWV0YWRhdGFFeHBvcnQiLCJjb2xsZWN0Vmlld3BvcnQiLCJ2aWV3cG9ydEl0ZW1zIiwiZXJyb3JWaWV3cG9ydEl0ZW1SZWYiLCJ2aWV3cG9ydEV4cG9ydCIsImVycm9yVmlld3BvcnRFeHBvcnQiLCJjdXJyZW50IiwicmVzb2x2ZU1ldGFkYXRhSXRlbXMiLCJzZWFyY2hQYXJhbXMiLCJnZXREeW5hbWljUGFyYW1Gcm9tU2VnbWVudCIsIndvcmtTdG9yZSIsInBhcmVudFBhcmFtcyIsInRyZWVQcmVmaXgiLCJyZXNvbHZlTWV0YWRhdGFJdGVtc0ltcGwiLCJzZWdtZW50IiwicGFyYWxsZWxSb3V0ZXMiLCJwYWdlIiwiY3VycmVudFRyZWVQcmVmaXgiLCJpc1BhZ2UiLCJzZWdtZW50UGFyYW0iLCJjdXJyZW50UGFyYW1zIiwidmFsdWUiLCJwYXJhbSIsInBhcmFtcyIsImxheWVyUHJvcHMiLCJmaWx0ZXIiLCJzIiwiam9pbiIsImNoaWxkVHJlZSIsImtleXMiLCJyZXNvbHZlVmlld3BvcnRJdGVtcyIsInJlc29sdmVWaWV3cG9ydEl0ZW1zSW1wbCIsImlzVGl0bGVUcnV0aHkiLCJhYnNvbHV0ZSIsImhhc1RpdGxlIiwiaW5oZXJpdEZyb21NZXRhZGF0YSIsImRlc2NyaXB0aW9uIiwiY29tbW9uT2dLZXlzIiwicG9zdFByb2Nlc3NNZXRhZGF0YSIsImZhdmljb24iLCJhdXRvRmlsbFByb3BzIiwiaGFzVHdUaXRsZSIsImhhc1R3RGVzY3JpcHRpb24iLCJoYXNUd0ltYWdlcyIsInBhcnRpYWxUd2l0dGVyIiwidW5zaGlmdCIsInByZXJlbmRlck1ldGFkYXRhIiwicmVzb2x2ZXJzQW5kUmVzdWx0cyIsImkiLCJnZXRSZXN1bHQiLCJwcmVyZW5kZXJWaWV3cG9ydCIsImV4cG9ydEZvclJlc3VsdCIsInJlc3VsdCIsInJlc29sdmUiLCJjYXRjaCIsImVyciIsIl9fbmV4dEVycm9yIiwicmVzb2x2ZVBlbmRpbmdSZXN1bHQiLCJwYXJlbnRSZXN1bHQiLCJyZXNvbHZlUGFyZW50UmVzdWx0IiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwicmVxdWlyZSIsImRlZXBGcmVlemUiLCJjbG9uZU1ldGFkYXRhIiwiYWNjdW11bGF0ZU1ldGFkYXRhIiwicmVzb2x2ZWRNZXRhZGF0YSIsIlNldCIsInJlc3VsdEluZGV4IiwiaWNvbk1vZCIsInNoaWZ0IiwicGVuZGluZ01ldGFkYXRhIiwicmVzb2x2ZVBhcmVudE1ldGFkYXRhIiwiaXNQcm9taXNlTGlrZSIsInRlbXBsYXRlIiwic2l6ZSIsIndhcm5pbmciLCJ3YXJuIiwiYWNjdW11bGF0ZVZpZXdwb3J0IiwicmVzb2x2ZWRWaWV3cG9ydCIsInBlbmRpbmdWaWV3cG9ydCIsInJlc29sdmVQYXJlbnRWaWV3cG9ydCIsInJlc29sdmVNZXRhZGF0YSIsInJlc29sdmVWaWV3cG9ydCIsInRoZW4iXSwibWFwcGluZ3MiOiJBQXlCQSw2REFBNkQ7Ozs7Ozs7QUFDN0QsT0FBTyxjQUFhO0FBRXBCLFNBQVNBLEtBQUssUUFBUSxRQUFPO0FBQzdCLFNBQ0VDLHFCQUFxQixFQUNyQkMscUJBQXFCLFFBQ2hCLHFCQUFvQjtBQUMzQixTQUFTQyxnQkFBZ0IsRUFBRUMsY0FBYyxRQUFRLGdDQUErQjtBQUNoRixTQUFTQyxZQUFZLFFBQVEsNEJBQTJCO0FBQ3hELFNBQVNDLHlCQUF5QixRQUFRLG1CQUFrQjtBQUM1RCxTQUNFQyxzQkFBc0IsRUFDdEJDLHFCQUFxQixRQUNoQixrQ0FBaUM7QUFDeEMsU0FBU0MsY0FBYyxRQUFRLHFCQUFvQjtBQUNuRCxTQUNFQyxpQkFBaUIsRUFDakJDLGtCQUFrQixFQUNsQkMsZUFBZSxFQUNmQyxhQUFhLEVBQ2JDLGlCQUFpQixFQUNqQkMsbUJBQW1CLEVBQ25CQyxhQUFhLEVBQ2JDLGVBQWUsRUFDZkMsaUJBQWlCLFFBQ1osNkJBQTRCO0FBQ25DLFNBQVNDLFlBQVksUUFBUSw0QkFBMkI7QUFDeEQsU0FBU0MsU0FBUyxRQUFRLGdDQUErQjtBQUN6RCxTQUFTQyxtQkFBbUIsUUFBUSxtQ0FBa0M7QUFDdEUsU0FBU0MsZ0JBQWdCLFFBQVEsMkJBQTBCO0FBQzNELFlBQVlDLFNBQVMseUJBQXdCO0FBQzdDLFNBQVNDLDZCQUE2QixRQUFRLDhCQUE2Qjs7Ozs7Ozs7Ozs7Ozs7OztBQXFDM0UsU0FBU0MsVUFBVUMsSUFBZ0M7SUFDakQsSUFBSSxDQUFDQSxNQUFNO1FBQ1QsT0FBTztJQUNUO0lBRUEseUNBQXlDO0lBQ3pDLE9BQ0dBLENBQUFBLEtBQUtDLEdBQUcsS0FBSyxrQkFDWkQsS0FBS0MsR0FBRyxDQUFDQyxRQUFRLEdBQUdDLFVBQVUsQ0FBQyxnQkFBZSxLQUNoREgsS0FBS0ksSUFBSSxLQUFLO0FBRWxCO0FBRUEsZUFBZUMsb0JBQ2JDLE1BQXVCLEVBQ3ZCQyxNQUF3QixFQUN4QkMsbUJBQW1DLEVBQ25DQyxlQUFnQyxFQUNoQ0MsY0FBOEIsRUFDOUJDLHNCQUFtQyxFQUNuQ0MsUUFBeUI7UUFlVE4saUJBV0VBO0lBeEJsQixJQUFJLENBQUNFLHFCQUFxQixPQUFPRDtJQUNqQyxNQUFNLEVBQUVQLElBQUksRUFBRWEsS0FBSyxFQUFFQyxTQUFTLEVBQUVDLE9BQU8sRUFBRUMsUUFBUSxFQUFFLEdBQUdSO0lBRXRELHVEQUF1RDtJQUV2RCxJQUFJUixNQUFNO1FBQ1JXLHVCQUF1QlgsSUFBSSxHQUFHQTtJQUNoQztJQUNBLElBQUlhLE9BQU87UUFDVEYsdUJBQXVCRSxLQUFLLEdBQUdBO0lBQ2pDO0lBRUEsOEZBQThGO0lBQzlGLElBQUlFLFdBQVcsQ0FBQSxDQUFDVCxVQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxDQUFBQSxrQkFBQUEsT0FBUVMsT0FBTyxLQUFBLE9BQUEsS0FBQSxJQUFmVCxnQkFBaUJXLGNBQWMsQ0FBQyxTQUFBLEdBQVc7UUFDekQsTUFBTUMsa05BQWtCeEMsaUJBQUFBLEVBQ3RCO1lBQUUsR0FBRzZCLE9BQU9RLE9BQU87WUFBRUksUUFBUUo7UUFBUSxHQUNyQ1IsT0FBT2EsWUFBWSxFQUNuQjtZQUFFLEdBQUdYLGVBQWU7WUFBRVksMkJBQTJCO1FBQUssR0FDdERYLGVBQWVLLE9BQU87UUFFeEJSLE9BQU9RLE9BQU8sR0FBR0c7SUFDbkI7SUFFQSxnR0FBZ0c7SUFDaEcsSUFBSUosYUFBYSxDQUFBLENBQUNSLFVBQUFBLE9BQUFBLEtBQUFBLElBQUFBLENBQUFBLG9CQUFBQSxPQUFRUSxTQUFTLEtBQUEsT0FBQSxLQUFBLElBQWpCUixrQkFBbUJXLGNBQWMsQ0FBQyxTQUFBLEdBQVc7UUFDN0QsTUFBTUssb0JBQW9CLHNNQUFNN0MsbUJBQUFBLEVBQzlCO1lBQUUsR0FBRzhCLE9BQU9PLFNBQVM7WUFBRUssUUFBUUw7UUFBVSxHQUN6Q1AsT0FBT2EsWUFBWSxFQUNuQlIsVUFDQTtZQUFFLEdBQUdILGVBQWU7WUFBRVksMkJBQTJCO1FBQUssR0FDdERYLGVBQWVJLFNBQVM7UUFFMUJQLE9BQU9PLFNBQVMsR0FBR1E7SUFDckI7SUFDQSxJQUFJTixVQUFVO1FBQ1pULE9BQU9TLFFBQVEsR0FBR0E7SUFDcEI7SUFFQSxPQUFPVDtBQUNUO0FBRUEsK0RBQStEO0FBQy9ELGVBQWVnQixjQUNiQyxLQUFhLEVBQ2JaLFFBQXlCLEVBQ3pCLEVBQ0VOLE1BQU0sRUFDTkMsTUFBTSxFQUNOQyxtQkFBbUIsRUFDbkJFLGNBQWMsRUFDZEQsZUFBZSxFQUNmZ0IsVUFBVSxFQUNWZCxzQkFBc0IsRUFTdkI7SUFFRCxzRkFBc0Y7SUFDdEYsTUFBTVMsZUFDSixPQUFBLENBQU9kLFVBQUFBLE9BQUFBLEtBQUFBLElBQUFBLE9BQVFjLFlBQVksTUFBSyxjQUM1QmQsT0FBT2MsWUFBWSxHQUNuQmIsT0FBT2EsWUFBWTtJQUN6QixJQUFLLE1BQU1NLFFBQVFwQixPQUFRO1FBQ3pCLE1BQU1xQixNQUFNRDtRQUVaLE9BQVFDO1lBQ04sS0FBSztnQkFBUztvQkFDWnBCLE9BQU9xQixLQUFLLEdBQUdqRCwyTUFBQUEsRUFBYTJCLE9BQU9zQixLQUFLLEVBQUVsQixlQUFla0IsS0FBSztvQkFDOUQ7Z0JBQ0Y7WUFDQSxLQUFLO2dCQUFjO29CQUNqQnJCLE9BQU9zQixVQUFVLEdBQUcsbU1BQU03QyxvQkFBQUEsRUFDeEJzQixPQUFPdUIsVUFBVSxFQUNqQlQsY0FDQVIsVUFDQUg7b0JBRUY7Z0JBQ0Y7WUFDQSxLQUFLO2dCQUFhO29CQUNoQkYsT0FBT08sU0FBUyxHQUFHLHNNQUFNckMsbUJBQUFBLEVBQ3ZCNkIsT0FBT1EsU0FBUyxFQUNoQk0sY0FDQVIsVUFDQUgsaUJBQ0FDLGVBQWVJLFNBQVM7b0JBRTFCO2dCQUNGO1lBQ0EsS0FBSztnQkFBVztvQkFDZFAsT0FBT1EsT0FBTyxtTUFBR3JDLGlCQUFBQSxFQUNmNEIsT0FBT1MsT0FBTyxFQUNkSyxjQUNBWCxpQkFDQUMsZUFBZUssT0FBTztvQkFFeEI7Z0JBQ0Y7WUFDQSxLQUFLO2dCQUNIUixPQUFPdUIsUUFBUSxPQUFHdkMsMk1BQUFBLEVBQWdCZSxPQUFPd0IsUUFBUTtnQkFDakQ7WUFDRixLQUFLO2dCQUNIdkIsT0FBT3dCLFlBQVksZ01BQUcxQyxzQkFBQUEsRUFBb0JpQixPQUFPeUIsWUFBWTtnQkFDN0Q7WUFFRixLQUFLO2dCQUFTO29CQUNaeEIsT0FBT3lCLEtBQUssK0xBQUd2QyxlQUFBQSxFQUFhYSxPQUFPMEIsS0FBSztvQkFDeEM7Z0JBQ0Y7WUFDQSxLQUFLO2dCQUNIekIsT0FBTzBCLFdBQVcsZ01BQUdoRCxxQkFBQUEsRUFBbUJxQixPQUFPMkIsV0FBVztnQkFDMUQ7WUFDRixLQUFLO2dCQUNIMUIsT0FBTzJCLFFBQVEsZ01BQUdoRCxrQkFBQUEsRUFBZ0JvQixPQUFPNEIsUUFBUTtnQkFDakQ7WUFDRixLQUFLO2dCQUFVO29CQUNiM0IsT0FBTzRCLE1BQU0sR0FBR2hELDZNQUFBQSxFQUFjbUIsT0FBTzZCLE1BQU07b0JBQzNDO2dCQUNGO1lBQ0EsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztnQkFBWTtvQkFDZjVCLE1BQU0sQ0FBQ29CLElBQUksbUxBQUcvQyw0QkFBQUEsRUFBMEIwQixNQUFNLENBQUNxQixJQUFJO29CQUNuRDtnQkFDRjtZQUNBLEtBQUs7Z0JBQVc7b0JBQ2RwQixNQUFNLENBQUNvQixJQUFJLG1MQUFHL0MsNEJBQUFBLEVBQTBCMEIsT0FBTzhCLE9BQU87b0JBQ3REO2dCQUNGO1lBQ0EsS0FBSztnQkFBVTtvQkFDYjdCLE1BQU0sQ0FBQ29CLElBQUksR0FBRyxtTUFBTXJDLGdCQUFBQSxFQUNsQmdCLE9BQU8rQixNQUFNLEVBQ2JqQixjQUNBUixVQUNBSDtvQkFFRjtnQkFDRjtZQUNBLEtBQUs7Z0JBQWM7b0JBQ2pCRixPQUFPK0IsVUFBVSxHQUFHLE1BQU05QyxpTkFBQUEsRUFDeEJjLE9BQU9nQyxVQUFVLEVBQ2pCbEIsY0FDQVIsVUFDQUg7b0JBRUY7Z0JBQ0Y7WUFDQSwrQ0FBK0M7WUFDL0MsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7Z0JBQ0gscUNBQXFDO2dCQUNyQ0YsTUFBTSxDQUFDb0IsSUFBSSxHQUFHckIsTUFBTSxDQUFDcUIsSUFBSSxJQUFJO2dCQUM3QjtZQUNGLEtBQUs7Z0JBQ0hwQixPQUFPZ0MsS0FBSyxHQUFHQyxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHbEMsT0FBT2dDLEtBQUssRUFBRWpDLE9BQU9pQyxLQUFLO2dCQUMzRDtZQUNGLEtBQUs7Z0JBQ0hoQyxPQUFPYSxZQUFZLEdBQUdBO2dCQUN0QjtZQUVGO2dCQUFTO29CQUNQLElBQ0dPLENBQUFBLFFBQVEsY0FDUEEsUUFBUSxnQkFDUkEsUUFBUSxhQUFZLEtBQ3RCckIsTUFBTSxDQUFDcUIsSUFBSSxJQUFJLE1BQ2Y7d0JBQ0FGLFdBQVdpQixRQUFRLENBQUNDLEdBQUcsQ0FDckIsQ0FBQyxxQkFBcUIsRUFBRWhCLElBQUkscUNBQXFDLEVBQUVILE1BQU0sOEhBQThILENBQUM7b0JBRTVNO29CQUNBO2dCQUNGO1FBQ0Y7SUFDRjtJQUNBLE9BQU9uQixvQkFDTEMsUUFDQUMsUUFDQUMscUJBQ0FDLGlCQUNBQyxnQkFDQUMsd0JBQ0FDO0FBRUo7QUFFQSxTQUFTZ0MsY0FBYyxFQUNyQnJDLE1BQU0sRUFDTkQsTUFBTSxFQUlQO0lBQ0MsSUFBSSxDQUFDQSxRQUFRO0lBQ2IsSUFBSyxNQUFNb0IsUUFBUXBCLE9BQVE7UUFDekIsTUFBTXFCLE1BQU1EO1FBRVosT0FBUUM7WUFDTixLQUFLO2dCQUFjO29CQUNqQnBCLE9BQU9zQyxVQUFVLEdBQUd6RCxpTkFBQUEsRUFBa0JrQixPQUFPdUMsVUFBVTtvQkFDdkQ7Z0JBQ0Y7WUFDQSxLQUFLO2dCQUNIdEMsT0FBT3VDLFdBQVcsR0FBR3hDLE9BQU93QyxXQUFXLElBQUk7Z0JBQzNDO1lBQ0Y7Z0JBQ0UsNkNBQTZDO2dCQUM3QyxpQ0FBaUM7Z0JBQ2pDdkMsTUFBTSxDQUFDb0IsSUFBSSxHQUFHckIsTUFBTSxDQUFDcUIsSUFBSTtnQkFDekI7UUFDSjtJQUNGO0FBQ0Y7QUFFQSxTQUFTb0IsbUJBQ1BDLEdBQVEsRUFDUkMsS0FBVSxFQUNWQyxZQUErQjtJQUUvQixJQUFJLE9BQU9GLElBQUlHLGdCQUFnQixLQUFLLFlBQVk7UUFDOUMsTUFBTSxFQUFFM0IsS0FBSyxFQUFFLEdBQUcwQjtRQUNsQixPQUFPLENBQUNFLHFMQUNOMUQsWUFBQUEsSUFBWTJELEtBQUssQ0FDZjFELGlNQUFBQSxDQUFvQndELGdCQUFnQixFQUNwQztnQkFDRUcsVUFBVSxDQUFDLGlCQUFpQixFQUFFOUIsT0FBTztnQkFDckMrQixZQUFZO29CQUNWLGFBQWEvQjtnQkFDZjtZQUNGLEdBQ0EsSUFBTXdCLElBQUlHLGdCQUFnQixDQUFDRixPQUFPRztJQUV4QztJQUNBLE9BQU9KLElBQUlRLFFBQVEsSUFBSTtBQUN6QjtBQUVBLFNBQVNDLG1CQUNQVCxHQUFRLEVBQ1JDLEtBQVUsRUFDVkMsWUFBK0I7SUFFL0IsSUFBSSxPQUFPRixJQUFJVSxnQkFBZ0IsS0FBSyxZQUFZO1FBQzlDLE1BQU0sRUFBRWxDLEtBQUssRUFBRSxHQUFHMEI7UUFDbEIsT0FBTyxDQUFDRSxxTEFDTjFELFlBQUFBLElBQVkyRCxLQUFLLDRLQUNmMUQsc0JBQUFBLENBQW9CK0QsZ0JBQWdCLEVBQ3BDO2dCQUNFSixVQUFVLENBQUMsaUJBQWlCLEVBQUU5QixPQUFPO2dCQUNyQytCLFlBQVk7b0JBQ1YsYUFBYS9CO2dCQUNmO1lBQ0YsR0FDQSxJQUFNd0IsSUFBSVUsZ0JBQWdCLENBQUNULE9BQU9HO0lBRXhDO0lBQ0EsT0FBT0osSUFBSVcsUUFBUSxJQUFJO0FBQ3pCO0FBRUEsZUFBZUMseUJBQ2JELFFBQW1DLEVBQ25DVixLQUFVLEVBQ1Y3QyxJQUFrRDtRQVU3QztJQVJMLElBQUksQ0FBQSxDQUFDdUQsWUFBQUEsT0FBQUEsS0FBQUEsSUFBQUEsUUFBVSxDQUFDdkQsS0FBSyxHQUFFLE9BQU95RDtJQUU5QixNQUFNQyxlQUFlSCxRQUFRLENBQUN2RCxLQUF5QixDQUFDMkQsR0FBRyxDQUN6RCxPQUFPQyxrTEFDTGpGLGtCQUFBQSxFQUFlLE1BQU1pRixZQUFZZjtJQUdyQyxPQUFPYSxDQUFBQSxnQkFBQUEsT0FBQUEsS0FBQUEsSUFBQUEsYUFBY0csTUFBTSxJQUFHLElBQUEsQ0FDekIsUUFBQSxNQUFNQyxRQUFRQyxHQUFHLENBQUNMLGFBQUFBLEtBQUFBLE9BQUFBLEtBQUFBLElBQWxCLE1BQWtDTSxJQUFJLEtBQ3ZDUDtBQUNOO0FBRUEsZUFBZVEsc0JBQ2JDLE9BQXNCLEVBQ3RCckIsS0FBVTtJQUVWLE1BQU0sRUFBRVUsUUFBUSxFQUFFLEdBQUdXO0lBQ3JCLElBQUksQ0FBQ1gsVUFBVSxPQUFPO0lBRXRCLE1BQU0sQ0FBQzNELE1BQU1hLE9BQU9DLFdBQVdDLFFBQVEsR0FBRyxNQUFNbUQsUUFBUUMsR0FBRyxDQUFDO1FBQzFEUCx5QkFBeUJELFVBQVVWLE9BQU87UUFDMUNXLHlCQUF5QkQsVUFBVVYsT0FBTztRQUMxQ1cseUJBQXlCRCxVQUFVVixPQUFPO1FBQzFDVyx5QkFBeUJELFVBQVVWLE9BQU87S0FDM0M7SUFFRCxNQUFNc0IsaUJBQWlCO1FBQ3JCdkU7UUFDQWE7UUFDQUM7UUFDQUM7UUFDQUMsVUFBVTJDLFNBQVMzQyxRQUFRO0lBQzdCO0lBRUEsT0FBT3VEO0FBQ1Q7QUFFQSw0RkFBNEY7QUFDNUYsZUFBZUMsZ0JBQWdCLEVBQzdCQyxJQUFJLEVBQ0pDLGFBQWEsRUFDYkMsaUJBQWlCLEVBQ2pCMUIsS0FBSyxFQUNMekIsS0FBSyxFQUNMb0QsZUFBZSxFQVFoQjtJQUNDLElBQUk1QjtJQUNKLElBQUk2QjtJQUNKLE1BQU1DLDhCQUE4QkMsUUFDbENILG1CQUFtQkgsSUFBSSxDQUFDLEVBQUUsQ0FBQ0csZ0JBQWdCO0lBRTdDLElBQUlBLGlCQUFpQjtRQUNuQjVCLE1BQU0sdUxBQU1uRSx5QkFBQUEsRUFBdUI0RixNQUFNO1FBQ3pDSSxVQUFVRDtJQUNaLE9BQU87UUFDTCxNQUFNLEVBQUU1QixLQUFLZ0MsZUFBZSxFQUFFSCxTQUFTSSxtQkFBbUIsRUFBRSxHQUMxRCxNQUFNbkcseU1BQUFBLEVBQXNCMkY7UUFDOUJ6QixNQUFNZ0M7UUFDTkgsVUFBVUk7SUFDWjtJQUVBLElBQUlKLFNBQVM7UUFDWHJELFNBQVMsQ0FBQyxDQUFDLEVBQUVxRCxTQUFTO0lBQ3hCO0lBRUEsTUFBTXJFLHNCQUFzQixNQUFNNkQsc0JBQXNCSSxJQUFJLENBQUMsRUFBRSxFQUFFeEI7SUFDakUsTUFBTWlDLGlCQUFpQmxDLE1BQU1TLG1CQUFtQlQsS0FBS0MsT0FBTztRQUFFekI7SUFBTSxLQUFLO0lBRXpFa0QsY0FBY1MsSUFBSSxDQUFDO1FBQUNEO1FBQWdCMUU7S0FBb0I7SUFFeEQsSUFBSXNFLCtCQUErQkYsaUJBQWlCO1FBQ2xELE1BQU1RLFdBQVcsdUxBQU12Ryx5QkFBQUEsRUFBdUI0RixNQUFNRztRQUNwRCxNQUFNUyxzQkFBc0JELFdBQ3hCM0IsbUJBQW1CMkIsVUFBVW5DLE9BQU87WUFBRXpCO1FBQU0sS0FDNUM7UUFFSm1ELGlCQUFpQixDQUFDLEVBQUUsR0FBR1U7UUFDdkJWLGlCQUFpQixDQUFDLEVBQUUsR0FBR25FO0lBQ3pCO0FBQ0Y7QUFFQSw0RkFBNEY7QUFDNUYsZUFBZThFLGdCQUFnQixFQUM3QmIsSUFBSSxFQUNKYyxhQUFhLEVBQ2JDLG9CQUFvQixFQUNwQnZDLEtBQUssRUFDTHpCLEtBQUssRUFDTG9ELGVBQWUsRUFRaEI7SUFDQyxJQUFJNUI7SUFDSixJQUFJNkI7SUFDSixNQUFNQyw4QkFBOEJDLFFBQ2xDSCxtQkFBbUJILElBQUksQ0FBQyxFQUFFLENBQUNHLGdCQUFnQjtJQUU3QyxJQUFJQSxpQkFBaUI7UUFDbkI1QixNQUFNLHVMQUFNbkUseUJBQUFBLEVBQXVCNEYsTUFBTTtRQUN6Q0ksVUFBVUQ7SUFDWixPQUFPO1FBQ0wsTUFBTSxFQUFFNUIsS0FBS2dDLGVBQWUsRUFBRUgsU0FBU0ksbUJBQW1CLEVBQUUsR0FDMUQsdUxBQU1uRyx3QkFBQUEsRUFBc0IyRjtRQUM5QnpCLE1BQU1nQztRQUNOSCxVQUFVSTtJQUNaO0lBRUEsSUFBSUosU0FBUztRQUNYckQsU0FBUyxDQUFDLENBQUMsRUFBRXFELFNBQVM7SUFDeEI7SUFFQSxNQUFNWSxpQkFBaUJ6QyxNQUFNRCxtQkFBbUJDLEtBQUtDLE9BQU87UUFBRXpCO0lBQU0sS0FBSztJQUV6RStELGNBQWNKLElBQUksQ0FBQ007SUFFbkIsSUFBSVgsK0JBQStCRixpQkFBaUI7UUFDbEQsTUFBTVEsV0FBVyx1TEFBTXZHLHlCQUFBQSxFQUF1QjRGLE1BQU1HO1FBQ3BELE1BQU1jLHNCQUFzQk4sV0FDeEJyQyxtQkFBbUJxQyxVQUFVbkMsT0FBTztZQUFFekI7UUFBTSxLQUM1QztRQUVKZ0UscUJBQXFCRyxPQUFPLEdBQUdEO0lBQ2pDO0FBQ0Y7QUFFQSxNQUFNRSx1QkFBdUJ0SCxrTkFBQUEsRUFBTSxlQUNqQ21HLElBQWdCLEVBQ2hCb0IsWUFBcUMsRUFDckNqQixlQUE4QyxFQUM5Q2tCLDBCQUFzRCxFQUN0REMsU0FBb0I7SUFFcEIsTUFBTUMsZUFBZSxDQUFDO0lBQ3RCLE1BQU10QixnQkFBK0IsRUFBRTtJQUN2QyxNQUFNQyxvQkFBMkM7UUFBQztRQUFNO0tBQUs7SUFDN0QsTUFBTXNCLGFBQWFwQztJQUNuQixPQUFPcUMseUJBQ0x4QixlQUNBRCxNQUNBd0IsWUFDQUQsY0FDQUgsY0FDQWpCLGlCQUNBRCxtQkFDQW1CLDRCQUNBQztBQUVKO0FBRUEsZUFBZUcseUJBQ2J4QixhQUE0QixFQUM1QkQsSUFBZ0IsRUFDaEIsNkZBQTZGLEdBQzdGd0IsVUFBZ0MsRUFDaENELFlBQW9CLEVBQ3BCSCxZQUFxQyxFQUNyQ2pCLGVBQThDLEVBQzlDRCxpQkFBd0MsRUFDeENtQiwwQkFBc0QsRUFDdERDLFNBQW9CO0lBRXBCLE1BQU0sQ0FBQ0ksU0FBU0MsZ0JBQWdCLEVBQUVDLElBQUksRUFBRSxDQUFDLEdBQUc1QjtJQUM1QyxNQUFNNkIsb0JBQ0pMLGNBQWNBLFdBQVdoQyxNQUFNLEdBQUc7V0FBSWdDO1FBQVlFO0tBQVEsR0FBRztRQUFDQTtLQUFRO0lBQ3hFLE1BQU1JLFNBQVMsT0FBT0YsU0FBUztJQUUvQixpQ0FBaUM7SUFDakMsTUFBTUcsZUFBZVYsMkJBQTJCSztJQUNoRDs7R0FFQyxHQUNELElBQUlNLGdCQUFnQlQ7SUFDcEIsSUFBSVEsZ0JBQWdCQSxhQUFhRSxLQUFLLEtBQUssTUFBTTtRQUMvQ0QsZ0JBQWdCO1lBQ2QsR0FBR1QsWUFBWTtZQUNmLENBQUNRLGFBQWFHLEtBQUssQ0FBQyxFQUFFSCxhQUFhRSxLQUFLO1FBQzFDO0lBQ0Y7SUFFQSxNQUFNRSxnTEFBUzlHLGdDQUFBQSxFQUE4QjJHLGVBQWVWO0lBRTVELElBQUljO0lBQ0osSUFBSU4sUUFBUTtRQUNWTSxhQUFhO1lBQ1hEO1lBQ0FmO1FBQ0Y7SUFDRixPQUFPO1FBQ0xnQixhQUFhO1lBQ1hEO1FBQ0Y7SUFDRjtJQUVBLE1BQU1wQyxnQkFBZ0I7UUFDcEJDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0EzQixPQUFPNEQ7UUFDUHJGLE9BQU84RSxrQkFDTCx5Q0FBeUM7U0FDeENRLE1BQU0sQ0FBQyxDQUFDQyxJQUFNQSxzS0FBTW5ILG1CQUFBQSxFQUNwQm9ILElBQUksQ0FBQztJQUNWO0lBRUEsSUFBSyxNQUFNckYsT0FBT3lFLGVBQWdCO1FBQ2hDLE1BQU1hLFlBQVliLGNBQWMsQ0FBQ3pFLElBQUk7UUFDckMsTUFBTXVFLHlCQUNKeEIsZUFDQXVDLFdBQ0FYLG1CQUNBRyxlQUNBWixjQUNBakIsaUJBQ0FELG1CQUNBbUIsNEJBQ0FDO0lBRUo7SUFFQSxJQUFJdkQsT0FBTzBFLElBQUksQ0FBQ2QsZ0JBQWdCbkMsTUFBTSxLQUFLLEtBQUtXLGlCQUFpQjtRQUMvRCwwRUFBMEU7UUFDMUUscUNBQXFDO1FBQ3JDRixjQUFjUyxJQUFJLENBQUNSO0lBQ3JCO0lBRUEsT0FBT0Q7QUFDVDtBQUdBLE1BQU15Qyx3QkFBdUI3SSxpTkFBQUEsRUFBTSxlQUNqQ21HLElBQWdCLEVBQ2hCb0IsWUFBcUMsRUFDckNqQixlQUE4QyxFQUM5Q2tCLDBCQUFzRCxFQUN0REMsU0FBb0I7SUFFcEIsTUFBTUMsZUFBZSxDQUFDO0lBQ3RCLE1BQU1ULGdCQUErQixFQUFFO0lBQ3ZDLE1BQU1DLHVCQUE2QztRQUNqREcsU0FBUztJQUNYO0lBQ0EsTUFBTU0sYUFBYXBDO0lBQ25CLE9BQU91RCx5QkFDTDdCLGVBQ0FkLE1BQ0F3QixZQUNBRCxjQUNBSCxjQUNBakIsaUJBQ0FZLHNCQUNBTSw0QkFDQUM7QUFFSjtBQUVBLGVBQWVxQix5QkFDYjdCLGFBQTRCLEVBQzVCZCxJQUFnQixFQUNoQiw2RkFBNkYsR0FDN0Z3QixVQUFnQyxFQUNoQ0QsWUFBb0IsRUFDcEJILFlBQXFDLEVBQ3JDakIsZUFBOEMsRUFDOUNZLG9CQUEwQyxFQUMxQ00sMEJBQXNELEVBQ3REQyxTQUFvQjtJQUVwQixNQUFNLENBQUNJLFNBQVNDLGdCQUFnQixFQUFFQyxJQUFJLEVBQUUsQ0FBQyxHQUFHNUI7SUFDNUMsTUFBTTZCLG9CQUNKTCxjQUFjQSxXQUFXaEMsTUFBTSxHQUFHO1dBQUlnQztRQUFZRTtLQUFRLEdBQUc7UUFBQ0E7S0FBUTtJQUN4RSxNQUFNSSxTQUFTLE9BQU9GLFNBQVM7SUFFL0IsaUNBQWlDO0lBQ2pDLE1BQU1HLGVBQWVWLDJCQUEyQks7SUFDaEQ7O0dBRUMsR0FDRCxJQUFJTSxnQkFBZ0JUO0lBQ3BCLElBQUlRLGdCQUFnQkEsYUFBYUUsS0FBSyxLQUFLLE1BQU07UUFDL0NELGdCQUFnQjtZQUNkLEdBQUdULFlBQVk7WUFDZixDQUFDUSxhQUFhRyxLQUFLLENBQUMsRUFBRUgsYUFBYUUsS0FBSztRQUMxQztJQUNGO0lBRUEsTUFBTUUsZ0xBQVM5RyxnQ0FBQUEsRUFBOEIyRyxlQUFlVjtJQUU1RCxJQUFJYztJQUNKLElBQUlOLFFBQVE7UUFDVk0sYUFBYTtZQUNYRDtZQUNBZjtRQUNGO0lBQ0YsT0FBTztRQUNMZ0IsYUFBYTtZQUNYRDtRQUNGO0lBQ0Y7SUFFQSxNQUFNdEIsZ0JBQWdCO1FBQ3BCYjtRQUNBYztRQUNBQztRQUNBWjtRQUNBM0IsT0FBTzREO1FBQ1ByRixPQUFPOEUsa0JBQ0wseUNBQXlDO1NBQ3hDUSxNQUFNLENBQUMsQ0FBQ0MsSUFBTUEsc0tBQU1uSCxtQkFBQUEsRUFDcEJvSCxJQUFJLENBQUM7SUFDVjtJQUVBLElBQUssTUFBTXJGLE9BQU95RSxlQUFnQjtRQUNoQyxNQUFNYSxZQUFZYixjQUFjLENBQUN6RSxJQUFJO1FBQ3JDLE1BQU15Rix5QkFDSjdCLGVBQ0EwQixXQUNBWCxtQkFDQUcsZUFDQVosY0FDQWpCLGlCQUNBWSxzQkFDQU0sNEJBQ0FDO0lBRUo7SUFFQSxJQUFJdkQsT0FBTzBFLElBQUksQ0FBQ2QsZ0JBQWdCbkMsTUFBTSxLQUFLLEtBQUtXLGlCQUFpQjtRQUMvRCwwRUFBMEU7UUFDMUUscUNBQXFDO1FBQ3JDVyxjQUFjSixJQUFJLENBQUNLLHFCQUFxQkcsT0FBTztJQUNqRDtJQUVBLE9BQU9KO0FBQ1Q7QUFLQSxNQUFNOEIsZ0JBQWdCLENBQUN6RixRQUNyQixDQUFDLENBQUEsQ0FBQ0EsU0FBQUEsT0FBQUEsS0FBQUEsSUFBQUEsTUFBTzBGLFFBQVE7QUFDbkIsTUFBTUMsV0FBVyxDQUFDNUQsV0FBK0IwRCxjQUFjMUQsWUFBQUEsT0FBQUEsS0FBQUEsSUFBQUEsU0FBVS9CLEtBQUs7QUFFOUUsU0FBUzRGLG9CQUNQakgsTUFBNEMsRUFDNUNvRCxRQUEwQjtJQUUxQixJQUFJcEQsUUFBUTtRQUNWLElBQUksQ0FBQ2dILFNBQVNoSCxXQUFXZ0gsU0FBUzVELFdBQVc7WUFDM0NwRCxPQUFPcUIsS0FBSyxHQUFHK0IsU0FBUy9CLEtBQUs7UUFDL0I7UUFDQSxJQUFJLENBQUNyQixPQUFPa0gsV0FBVyxJQUFJOUQsU0FBUzhELFdBQVcsRUFBRTtZQUMvQ2xILE9BQU9rSCxXQUFXLEdBQUc5RCxTQUFTOEQsV0FBVztRQUMzQztJQUNGO0FBQ0Y7QUFFQSw2REFBNkQ7QUFDN0QsTUFBTUMsZUFBZTtJQUFDO0lBQVM7SUFBZTtDQUFTO0FBQ3ZELFNBQVNDLG9CQUNQaEUsUUFBMEIsRUFDMUJpRSxPQUFZLEVBQ1psSCxjQUE4QixFQUM5QkQsZUFBZ0M7SUFFaEMsTUFBTSxFQUFFSyxTQUFTLEVBQUVDLE9BQU8sRUFBRSxHQUFHNEM7SUFFL0IsSUFBSTdDLFdBQVc7UUFDYixrRUFBa0U7UUFDbEUsd0NBQXdDO1FBQ3hDLElBQUkrRyxnQkFJQyxDQUFDO1FBQ04sTUFBTUMsYUFBYVAsU0FBU3hHO1FBQzVCLE1BQU1nSCxtQkFBbUJoSCxXQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxRQUFTMEcsV0FBVztRQUM3QyxNQUFNTyxjQUFjakQsUUFDbEJoRSxDQUFBQSxXQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxRQUFTRSxjQUFjLENBQUMsU0FBQSxLQUFhRixRQUFRSSxNQUFNO1FBRXJELElBQUksQ0FBQzJHLFlBQVk7WUFDZixJQUFJVCxjQUFjdkcsVUFBVWMsS0FBSyxHQUFHO2dCQUNsQ2lHLGNBQWNqRyxLQUFLLEdBQUdkLFVBQVVjLEtBQUs7WUFDdkMsT0FBTyxJQUFJK0IsU0FBUy9CLEtBQUssSUFBSXlGLGNBQWMxRCxTQUFTL0IsS0FBSyxHQUFHO2dCQUMxRGlHLGNBQWNqRyxLQUFLLEdBQUcrQixTQUFTL0IsS0FBSztZQUN0QztRQUNGO1FBQ0EsSUFBSSxDQUFDbUcsa0JBQ0hGLGNBQWNKLFdBQVcsR0FDdkIzRyxVQUFVMkcsV0FBVyxJQUFJOUQsU0FBUzhELFdBQVcsSUFBSTVEO1FBQ3JELElBQUksQ0FBQ21FLGFBQWFILGNBQWMxRyxNQUFNLEdBQUdMLFVBQVVLLE1BQU07UUFFekQsSUFBSXFCLE9BQU8wRSxJQUFJLENBQUNXLGVBQWU1RCxNQUFNLEdBQUcsR0FBRztZQUN6QyxNQUFNZ0UsaU5BQWlCdkosaUJBQUFBLEVBQ3JCbUosZUFDQWxFLFNBQVN2QyxZQUFZLEVBQ3JCWCxpQkFDQUMsZUFBZUssT0FBTztZQUV4QixJQUFJNEMsU0FBUzVDLE9BQU8sRUFBRTtnQkFDcEI0QyxTQUFTNUMsT0FBTyxHQUFHeUIsT0FBT0MsTUFBTSxDQUFDLENBQUMsR0FBR2tCLFNBQVM1QyxPQUFPLEVBQUU7b0JBQ3JELEdBQUksQ0FBQytHLGNBQWM7d0JBQUVsRyxLQUFLLEVBQUVxRyxrQkFBQUEsT0FBQUEsS0FBQUEsSUFBQUEsZUFBZ0JyRyxLQUFLO29CQUFDLENBQUM7b0JBQ25ELEdBQUksQ0FBQ21HLG9CQUFvQjt3QkFDdkJOLFdBQVcsRUFBRVEsa0JBQUFBLE9BQUFBLEtBQUFBLElBQUFBLGVBQWdCUixXQUFXO29CQUMxQyxDQUFDO29CQUNELEdBQUksQ0FBQ08sZUFBZTt3QkFBRTdHLE1BQU0sRUFBRThHLGtCQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxlQUFnQjlHLE1BQU07b0JBQUMsQ0FBQztnQkFDeEQ7WUFDRixPQUFPO2dCQUNMd0MsU0FBUzVDLE9BQU8sR0FBR2tIO1lBQ3JCO1FBQ0Y7SUFDRjtJQUVBLDBFQUEwRTtJQUMxRSwrQ0FBK0M7SUFDL0NULG9CQUFvQjFHLFdBQVc2QztJQUMvQjZELG9CQUFvQnpHLFNBQVM0QztJQUU3QixJQUFJaUUsU0FBUztRQUNYLElBQUksQ0FBQ2pFLFNBQVMzQixLQUFLLEVBQUU7WUFDbkIyQixTQUFTM0IsS0FBSyxHQUFHO2dCQUNmaEMsTUFBTSxFQUFFO2dCQUNSYSxPQUFPLEVBQUU7WUFDWDtRQUNGO1FBRUE4QyxTQUFTM0IsS0FBSyxDQUFDaEMsSUFBSSxDQUFDa0ksT0FBTyxDQUFDTjtJQUM5QjtJQUVBLE9BQU9qRTtBQUNUO0FBSUEsU0FBU3dFLGtCQUFrQnpELGFBQTRCO0lBQ3JELHFFQUFxRTtJQUNyRSwrRUFBK0U7SUFDL0UsVUFBVTtJQUNWLE1BQU0wRCxzQkFFRixFQUFFO0lBQ04sSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUkzRCxjQUFjVCxNQUFNLEVBQUVvRSxJQUFLO1FBQzdDLE1BQU1uRCxpQkFBaUJSLGFBQWEsQ0FBQzJELEVBQUUsQ0FBQyxFQUFFO1FBQzFDQyxVQUFVRixxQkFBcUJsRDtJQUNqQztJQUNBLE9BQU9rRDtBQUNUO0FBRUEsU0FBU0csa0JBQWtCaEQsYUFBNEI7SUFDckQscUVBQXFFO0lBQ3JFLCtFQUErRTtJQUMvRSxVQUFVO0lBQ1YsTUFBTTZDLHNCQUVGLEVBQUU7SUFDTixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSTlDLGNBQWN0QixNQUFNLEVBQUVvRSxJQUFLO1FBQzdDLE1BQU01QyxpQkFBaUJGLGFBQWEsQ0FBQzhDLEVBQUU7UUFDdkNDLFVBQVVGLHFCQUFxQjNDO0lBQ2pDO0lBQ0EsT0FBTzJDO0FBQ1Q7QUFJQSxTQUFTRSxVQUNQRixtQkFBc0UsRUFDdEVJLGVBQXlFO0lBRXpFLElBQUksT0FBT0Esb0JBQW9CLFlBQVk7UUFDekMsTUFBTUMsU0FBU0QsZ0JBQ2IsSUFBSXRFLFFBQXFCLENBQUN3RSxVQUFZTixvQkFBb0JqRCxJQUFJLENBQUN1RDtRQUVqRU4sb0JBQW9CakQsSUFBSSxDQUFDc0Q7UUFDekIsSUFBSUEsa0JBQWtCdkUsU0FBUztZQUM3Qiw4Q0FBOEM7WUFDOUMsK0NBQStDO1lBQy9DLDRDQUE0QztZQUM1QyxvREFBb0Q7WUFDcER1RSxPQUFPRSxLQUFLLENBQUMsQ0FBQ0M7Z0JBQ1osT0FBTztvQkFDTEMsYUFBYUQ7Z0JBQ2Y7WUFDRjtRQUNGO0lBQ0YsT0FBTyxJQUFJLE9BQU9KLG9CQUFvQixVQUFVO1FBQzlDSixvQkFBb0JqRCxJQUFJLENBQUNxRDtJQUMzQixPQUFPO1FBQ0xKLG9CQUFvQmpELElBQUksQ0FBQztJQUMzQjtBQUNGO0FBRUEsU0FBUzJELHFCQUdQQyxZQUEwQixFQUMxQkMsbUJBQWtEO0lBRWxELHVGQUF1RjtJQUN2RixxRUFBcUU7SUFDckUsSUFBSUMsUUFBUUMsR0FBRyxDQUFDQyxRQUFRLEtBQUssV0FBZTtRQUMxQywyRUFBMkU7UUFDM0UsNERBQTREO1FBQzVESixlQUNFSyxRQUFRLHlHQUNSQyxVQUFVLENBRVJELFFBQVEsOEdBQ1JFLGFBQWEsQ0FBQ1A7SUFFcEI7SUFFQUMsb0JBQW9CRDtBQUN0QjtBQUVPLGVBQWVRLG1CQUNwQi9ILEtBQWEsRUFDYmtELGFBQTRCLEVBQzVCOUQsUUFBeUIsRUFDekJILGVBQWdDO0lBRWhDLElBQUkrSSxtQkFBbUJqTCwwTUFBQUE7SUFFdkIsSUFBSW1DLGlCQUFpQztRQUNuQ2tCLE9BQU87UUFDUGIsU0FBUztRQUNURCxXQUFXO0lBQ2I7SUFFQSxNQUFNVyxhQUFhO1FBQ2pCaUIsVUFBVSxJQUFJK0c7SUFDaEI7SUFFQSxJQUFJN0I7SUFFSixrREFBa0Q7SUFDbEQsK0VBQStFO0lBQy9FLE1BQU1qSCx5QkFBeUI7UUFDN0JYLE1BQU0sRUFBRTtRQUNSYSxPQUFPLEVBQUU7SUFDWDtJQUVBLE1BQU11SCxzQkFBc0JELGtCQUFrQnpEO0lBQzlDLElBQUlnRixjQUFjO0lBRWxCLElBQUssSUFBSXJCLElBQUksR0FBR0EsSUFBSTNELGNBQWNULE1BQU0sRUFBRW9FLElBQUs7WUFJckI3SDtRQUh4QixNQUFNQSxzQkFBc0JrRSxhQUFhLENBQUMyRCxFQUFFLENBQUMsRUFBRTtRQUMvQyx5RUFBeUU7UUFDekUscUVBQXFFO1FBQ3JFLElBQUlBLEtBQUssS0FBS3RJLFVBQVVTLHVCQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxDQUFBQSw0QkFBQUEsb0JBQXFCUixJQUFJLEtBQUEsT0FBQSxLQUFBLElBQXpCUSx5QkFBMkIsQ0FBQyxFQUFFLEdBQUc7Z0JBQ3ZDQTtZQUFoQixNQUFNbUosVUFBVW5KLHVCQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxDQUFBQSw2QkFBQUEsb0JBQXFCUixJQUFJLEtBQUEsT0FBQSxLQUFBLElBQXpCUSwyQkFBMkJvSixLQUFLO1lBQ2hELElBQUl2QixNQUFNLEdBQUdULFVBQVUrQjtRQUN6QjtRQUVBLElBQUlFLGtCQUFrQnpCLG1CQUFtQixDQUFDc0IsY0FBYztRQUN4RCxJQUFJLE9BQU9HLG9CQUFvQixZQUFZO1lBQ3pDLGtEQUFrRDtZQUNsRCxxREFBcUQ7WUFDckQsNEJBQTRCO1lBQzVCLE1BQU1DLHdCQUF3QkQ7WUFDOUIsc0RBQXNEO1lBQ3RELGlCQUFpQjtZQUNqQkEsa0JBQWtCekIsbUJBQW1CLENBQUNzQixjQUFjO1lBRXBEWixxQkFBcUJVLGtCQUFrQk07UUFDekM7UUFDQSx3REFBd0Q7UUFFeEQsSUFBSW5HO1FBQ0osSUFBSW9HLGNBQWNGLGtCQUFrQjtZQUNsQ2xHLFdBQVcsTUFBTWtHO1FBQ25CLE9BQU87WUFDTGxHLFdBQVdrRztRQUNiO1FBRUFMLG1CQUFtQixNQUFNakksY0FBY0MsT0FBT1osVUFBVTtZQUN0REwsUUFBUWlKO1lBQ1JsSixRQUFRcUQ7WUFDUmxEO1lBQ0FEO1lBQ0FFO1lBQ0FlO1lBQ0FkO1FBQ0Y7UUFFQSxnRkFBZ0Y7UUFDaEYsa0RBQWtEO1FBQ2xELElBQUkwSCxJQUFJM0QsY0FBY1QsTUFBTSxHQUFHLEdBQUc7Z0JBRXZCdUYseUJBQ0lBLDZCQUNGQTtZQUhYOUksaUJBQWlCO2dCQUNma0IsT0FBTzRILENBQUFBLENBQUFBLDBCQUFBQSxpQkFBaUI1SCxLQUFLLEtBQUEsT0FBQSxLQUFBLElBQXRCNEgsd0JBQXdCUSxRQUFRLEtBQUk7Z0JBQzNDbEosV0FBVzBJLENBQUFBLENBQUFBLDhCQUFBQSxpQkFBaUIxSSxTQUFTLEtBQUEsT0FBQSxLQUFBLElBQTFCMEksNEJBQTRCNUgsS0FBSyxDQUFDb0ksUUFBUSxLQUFJO2dCQUN6RGpKLFNBQVN5SSxDQUFBQSxDQUFBQSw0QkFBQUEsaUJBQWlCekksT0FBTyxLQUFBLE9BQUEsS0FBQSxJQUF4QnlJLDBCQUEwQjVILEtBQUssQ0FBQ29JLFFBQVEsS0FBSTtZQUN2RDtRQUNGO0lBQ0Y7SUFFQSxJQUNFckosdUJBQXVCWCxJQUFJLENBQUNpRSxNQUFNLEdBQUcsS0FDckN0RCx1QkFBdUJFLEtBQUssQ0FBQ29ELE1BQU0sR0FBRyxHQUN0QztRQUNBLElBQUksQ0FBQ3VGLGlCQUFpQnhILEtBQUssRUFBRTtZQUMzQndILGlCQUFpQnhILEtBQUssR0FBRztnQkFDdkJoQyxNQUFNLEVBQUU7Z0JBQ1JhLE9BQU8sRUFBRTtZQUNYO1lBQ0EsSUFBSUYsdUJBQXVCWCxJQUFJLENBQUNpRSxNQUFNLEdBQUcsR0FBRztnQkFDMUN1RixpQkFBaUJ4SCxLQUFLLENBQUNoQyxJQUFJLENBQUNrSSxPQUFPLElBQUl2SCx1QkFBdUJYLElBQUk7WUFDcEU7WUFDQSxJQUFJVyx1QkFBdUJFLEtBQUssQ0FBQ29ELE1BQU0sR0FBRyxHQUFHO2dCQUMzQ3VGLGlCQUFpQnhILEtBQUssQ0FBQ25CLEtBQUssQ0FBQ3FILE9BQU8sSUFBSXZILHVCQUF1QkUsS0FBSztZQUN0RTtRQUNGO0lBQ0Y7SUFFQSxxR0FBcUc7SUFDckcsSUFBSVksV0FBV2lCLFFBQVEsQ0FBQ3VILElBQUksR0FBRyxHQUFHO1FBQ2hDLEtBQUssTUFBTUMsV0FBV3pJLFdBQVdpQixRQUFRLENBQUU7MEtBQ3pDN0MsSUFBSXNLLEdBQUksQ0FBQ0Q7UUFDWDtJQUNGO0lBRUEsT0FBT3ZDLG9CQUNMNkIsa0JBQ0E1QixTQUNBbEgsZ0JBQ0FEO0FBRUo7QUFFTyxlQUFlMkosbUJBQ3BCN0UsYUFBNEI7SUFFNUIsTUFBTThFLG1CQUFxQzdMLDBNQUFBQTtJQUUzQyxNQUFNNEosc0JBQXNCRyxrQkFBa0JoRDtJQUM5QyxJQUFJOEMsSUFBSTtJQUVSLE1BQU9BLElBQUlELG9CQUFvQm5FLE1BQU0sQ0FBRTtRQUNyQyxJQUFJcUcsa0JBQWtCbEMsbUJBQW1CLENBQUNDLElBQUk7UUFDOUMsSUFBSSxPQUFPaUMsb0JBQW9CLFlBQVk7WUFDekMsa0RBQWtEO1lBQ2xELHFEQUFxRDtZQUNyRCw0QkFBNEI7WUFDNUIsTUFBTUMsd0JBQXdCRDtZQUM5QixzREFBc0Q7WUFDdEQsaUJBQWlCO1lBQ2pCQSxrQkFBa0JsQyxtQkFBbUIsQ0FBQ0MsSUFBSTtZQUUxQ1MscUJBQXFCdUIsa0JBQWtCRTtRQUN6QztRQUNBLHdEQUF3RDtRQUV4RCxJQUFJL0c7UUFDSixJQUFJdUcsY0FBY08sa0JBQWtCO1lBQ2xDOUcsV0FBVyxNQUFNOEc7UUFDbkIsT0FBTztZQUNMOUcsV0FBVzhHO1FBQ2I7UUFFQTFILGNBQWM7WUFDWnJDLFFBQVE4SjtZQUNSL0osUUFBUWtEO1FBQ1Y7SUFDRjtJQUNBLE9BQU82RztBQUNUO0FBR08sZUFBZUcsZ0JBQ3BCL0YsSUFBZ0IsRUFDaEI3RCxRQUF5QixFQUN6QmlGLFlBQXFDLEVBQ3JDakIsZUFBOEMsRUFDOUNrQiwwQkFBc0QsRUFDdERDLFNBQW9CLEVBQ3BCdEYsZUFBZ0M7SUFFaEMsTUFBTWlFLGdCQUFnQixNQUFNa0IscUJBQzFCbkIsTUFDQW9CLGNBQ0FqQixpQkFDQWtCLDRCQUNBQztJQUVGLE9BQU93RCxtQkFDTHhELFVBQVV2RSxLQUFLLEVBQ2ZrRCxlQUNBOUQsVUFDQUg7QUFFSjtBQUdPLGVBQWVnSyxnQkFDcEJoRyxJQUFnQixFQUNoQm9CLFlBQXFDLEVBQ3JDakIsZUFBOEMsRUFDOUNrQiwwQkFBc0QsRUFDdERDLFNBQW9CO0lBRXBCLE1BQU1SLGdCQUFnQixNQUFNNEIscUJBQzFCMUMsTUFDQW9CLGNBQ0FqQixpQkFDQWtCLDRCQUNBQztJQUVGLE9BQU9xRSxtQkFBbUI3RTtBQUM1QjtBQUVBLFNBQVN3RSxjQUNQckQsS0FBK0I7SUFFL0IsT0FDRSxPQUFPQSxVQUFVLFlBQ2pCQSxVQUFVLFFBQ1YsT0FBUUEsTUFBK0JnRSxJQUFJLEtBQUs7QUFFcEQiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNjc2MSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL2NsaWVudC9jb21wb25lbnRzL2h0dHAtYWNjZXNzLWZhbGxiYWNrL2h0dHAtYWNjZXNzLWZhbGxiYWNrLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBIVFRQQWNjZXNzRXJyb3JTdGF0dXMgPSB7XG4gIE5PVF9GT1VORDogNDA0LFxuICBGT1JCSURERU46IDQwMyxcbiAgVU5BVVRIT1JJWkVEOiA0MDEsXG59XG5cbmNvbnN0IEFMTE9XRURfQ09ERVMgPSBuZXcgU2V0KE9iamVjdC52YWx1ZXMoSFRUUEFjY2Vzc0Vycm9yU3RhdHVzKSlcblxuZXhwb3J0IGNvbnN0IEhUVFBfRVJST1JfRkFMTEJBQ0tfRVJST1JfQ09ERSA9ICdORVhUX0hUVFBfRVJST1JfRkFMTEJBQ0snXG5cbmV4cG9ydCB0eXBlIEhUVFBBY2Nlc3NGYWxsYmFja0Vycm9yID0gRXJyb3IgJiB7XG4gIGRpZ2VzdDogYCR7dHlwZW9mIEhUVFBfRVJST1JfRkFMTEJBQ0tfRVJST1JfQ09ERX07JHtzdHJpbmd9YFxufVxuXG4vKipcbiAqIENoZWNrcyBhbiBlcnJvciB0byBkZXRlcm1pbmUgaWYgaXQncyBhbiBlcnJvciBnZW5lcmF0ZWQgYnlcbiAqIHRoZSBIVFRQIG5hdmlnYXRpb24gQVBJcyBgbm90Rm91bmQoKWAsIGBmb3JiaWRkZW4oKWAgb3IgYHVuYXV0aG9yaXplZCgpYC5cbiAqXG4gKiBAcGFyYW0gZXJyb3IgdGhlIGVycm9yIHRoYXQgbWF5IHJlZmVyZW5jZSBhIEhUVFAgYWNjZXNzIGVycm9yXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBlcnJvciBpcyBhIEhUVFAgYWNjZXNzIGVycm9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0hUVFBBY2Nlc3NGYWxsYmFja0Vycm9yKFxuICBlcnJvcjogdW5rbm93blxuKTogZXJyb3IgaXMgSFRUUEFjY2Vzc0ZhbGxiYWNrRXJyb3Ige1xuICBpZiAoXG4gICAgdHlwZW9mIGVycm9yICE9PSAnb2JqZWN0JyB8fFxuICAgIGVycm9yID09PSBudWxsIHx8XG4gICAgISgnZGlnZXN0JyBpbiBlcnJvcikgfHxcbiAgICB0eXBlb2YgZXJyb3IuZGlnZXN0ICE9PSAnc3RyaW5nJ1xuICApIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBjb25zdCBbcHJlZml4LCBodHRwU3RhdHVzXSA9IGVycm9yLmRpZ2VzdC5zcGxpdCgnOycpXG5cbiAgcmV0dXJuIChcbiAgICBwcmVmaXggPT09IEhUVFBfRVJST1JfRkFMTEJBQ0tfRVJST1JfQ09ERSAmJlxuICAgIEFMTE9XRURfQ09ERVMuaGFzKE51bWJlcihodHRwU3RhdHVzKSlcbiAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWNjZXNzRmFsbGJhY2tIVFRQU3RhdHVzKFxuICBlcnJvcjogSFRUUEFjY2Vzc0ZhbGxiYWNrRXJyb3Jcbik6IG51bWJlciB7XG4gIGNvbnN0IGh0dHBTdGF0dXMgPSBlcnJvci5kaWdlc3Quc3BsaXQoJzsnKVsxXVxuICByZXR1cm4gTnVtYmVyKGh0dHBTdGF0dXMpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRBY2Nlc3NGYWxsYmFja0Vycm9yVHlwZUJ5U3RhdHVzKFxuICBzdGF0dXM6IG51bWJlclxuKTogJ25vdC1mb3VuZCcgfCAnZm9yYmlkZGVuJyB8ICd1bmF1dGhvcml6ZWQnIHwgdW5kZWZpbmVkIHtcbiAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICBjYXNlIDQwMTpcbiAgICAgIHJldHVybiAndW5hdXRob3JpemVkJ1xuICAgIGNhc2UgNDAzOlxuICAgICAgcmV0dXJuICdmb3JiaWRkZW4nXG4gICAgY2FzZSA0MDQ6XG4gICAgICByZXR1cm4gJ25vdC1mb3VuZCdcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJIVFRQQWNjZXNzRXJyb3JTdGF0dXMiLCJOT1RfRk9VTkQiLCJGT1JCSURERU4iLCJVTkFVVEhPUklaRUQiLCJBTExPV0VEX0NPREVTIiwiU2V0IiwiT2JqZWN0IiwidmFsdWVzIiwiSFRUUF9FUlJPUl9GQUxMQkFDS19FUlJPUl9DT0RFIiwiaXNIVFRQQWNjZXNzRmFsbGJhY2tFcnJvciIsImVycm9yIiwiZGlnZXN0IiwicHJlZml4IiwiaHR0cFN0YXR1cyIsInNwbGl0IiwiaGFzIiwiTnVtYmVyIiwiZ2V0QWNjZXNzRmFsbGJhY2tIVFRQU3RhdHVzIiwiZ2V0QWNjZXNzRmFsbGJhY2tFcnJvclR5cGVCeVN0YXR1cyIsInN0YXR1cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFPLE1BQU1BLHdCQUF3QjtJQUNuQ0MsV0FBVztJQUNYQyxXQUFXO0lBQ1hDLGNBQWM7QUFDaEIsRUFBQztBQUVELE1BQU1DLGdCQUFnQixJQUFJQyxJQUFJQyxPQUFPQyxNQUFNLENBQUNQO0FBRXJDLE1BQU1RLGlDQUFpQywyQkFBMEI7QUFhakUsU0FBU0MsMEJBQ2RDLEtBQWM7SUFFZCxJQUNFLE9BQU9BLFVBQVUsWUFDakJBLFVBQVUsUUFDVixDQUFFLENBQUEsWUFBWUEsS0FBSSxLQUNsQixPQUFPQSxNQUFNQyxNQUFNLEtBQUssVUFDeEI7UUFDQSxPQUFPO0lBQ1Q7SUFDQSxNQUFNLENBQUNDLFFBQVFDLFdBQVcsR0FBR0gsTUFBTUMsTUFBTSxDQUFDRyxLQUFLLENBQUM7SUFFaEQsT0FDRUYsV0FBV0osa0NBQ1hKLGNBQWNXLEdBQUcsQ0FBQ0MsT0FBT0g7QUFFN0I7QUFFTyxTQUFTSSw0QkFDZFAsS0FBOEI7SUFFOUIsTUFBTUcsYUFBYUgsTUFBTUMsTUFBTSxDQUFDRyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7SUFDN0MsT0FBT0UsT0FBT0g7QUFDaEI7QUFFTyxTQUFTSyxtQ0FDZEMsTUFBYztJQUVkLE9BQVFBO1FBQ04sS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7WUFDSCxPQUFPO1FBQ1Q7WUFDRTtJQUNKO0FBQ0YiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNjgwMywgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvZXNtL2NsaWVudC9jb21wb25lbnRzL21ldGFkYXRhL2FzeW5jLW1ldGFkYXRhLmpzL3Byb3h5LmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB7IGNyZWF0ZUNsaWVudE1vZHVsZVByb3h5IH0gPSByZXF1aXJlKFwicmVhY3Qtc2VydmVyLWRvbS10dXJib3BhY2svc2VydmVyXCIpO1xuXG5fX3R1cmJvcGFja19jb250ZXh0X18ubihjcmVhdGVDbGllbnRNb2R1bGVQcm94eShcIltwcm9qZWN0XS9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2VzbS9jbGllbnQvY29tcG9uZW50cy9tZXRhZGF0YS9hc3luYy1tZXRhZGF0YS5qcyA8bW9kdWxlIGV2YWx1YXRpb24+XCIpKTtcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxNQUFNLEVBQUUsdUJBQXVCLEVBQUU7QUFFakMsc0JBQXNCLENBQUMsQ0FBQyx3QkFBd0IiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNjgxMCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvZXNtL2NsaWVudC9jb21wb25lbnRzL21ldGFkYXRhL2FzeW5jLW1ldGFkYXRhLmpzL3Byb3h5LmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB7IGNyZWF0ZUNsaWVudE1vZHVsZVByb3h5IH0gPSByZXF1aXJlKFwicmVhY3Qtc2VydmVyLWRvbS10dXJib3BhY2svc2VydmVyXCIpO1xuXG5fX3R1cmJvcGFja19jb250ZXh0X18ubihjcmVhdGVDbGllbnRNb2R1bGVQcm94eShcIltwcm9qZWN0XS9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2VzbS9jbGllbnQvY29tcG9uZW50cy9tZXRhZGF0YS9hc3luYy1tZXRhZGF0YS5qc1wiKSk7XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsTUFBTSxFQUFFLHVCQUF1QixFQUFFO0FBRWpDLHNCQUFzQixDQUFDLENBQUMsd0JBQXdCIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDY4MTYsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NyYy9jbGllbnQvY29tcG9uZW50cy9tZXRhZGF0YS9hc3luYy1tZXRhZGF0YS50c3giXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbmltcG9ydCB7IFN1c3BlbnNlLCB1c2UgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB0eXBlIHsgU3RyZWFtaW5nTWV0YWRhdGFSZXNvbHZlZFN0YXRlIH0gZnJvbSAnLi90eXBlcydcblxuZnVuY3Rpb24gTWV0YWRhdGFPdXRsZXQoe1xuICBwcm9taXNlLFxufToge1xuICBwcm9taXNlOiBQcm9taXNlPFN0cmVhbWluZ01ldGFkYXRhUmVzb2x2ZWRTdGF0ZT5cbn0pIHtcbiAgY29uc3QgeyBlcnJvciwgZGlnZXN0IH0gPSB1c2UocHJvbWlzZSlcbiAgaWYgKGVycm9yKSB7XG4gICAgaWYgKGRpZ2VzdCkge1xuICAgICAgLy8gVGhlIGVycm9yIHdpbGwgbG9zZSBpdHMgb3JpZ2luYWwgZGlnZXN0IGFmdGVyIHBhc3NpbmcgZnJvbSBzZXJ2ZXIgbGF5ZXIgdG8gY2xpZW50IGxheWVy77ybXG4gICAgICAvLyBXZSByZWNvdmVyIHRoZSBkaWdlc3QgcHJvcGVydHkgaGVyZSB0byBvdmVycmlkZSB0aGUgUmVhY3QgY3JlYXRlZCBvbmUgaWYgb3JpZ2luYWwgZGlnZXN0IGV4aXN0cy5cbiAgICAgIDsoZXJyb3IgYXMgYW55KS5kaWdlc3QgPSBkaWdlc3RcbiAgICB9XG4gICAgdGhyb3cgZXJyb3JcbiAgfVxuICByZXR1cm4gbnVsbFxufVxuXG5leHBvcnQgZnVuY3Rpb24gQXN5bmNNZXRhZGF0YU91dGxldCh7XG4gIHByb21pc2UsXG59OiB7XG4gIHByb21pc2U6IFByb21pc2U8U3RyZWFtaW5nTWV0YWRhdGFSZXNvbHZlZFN0YXRlPlxufSkge1xuICByZXR1cm4gKFxuICAgIDxTdXNwZW5zZSBmYWxsYmFjaz17bnVsbH0+XG4gICAgICA8TWV0YWRhdGFPdXRsZXQgcHJvbWlzZT17cHJvbWlzZX0gLz5cbiAgICA8L1N1c3BlbnNlPlxuICApXG59XG4iXSwibmFtZXMiOlsiU3VzcGVuc2UiLCJ1c2UiLCJNZXRhZGF0YU91dGxldCIsInByb21pc2UiLCJlcnJvciIsImRpZ2VzdCIsIkFzeW5jTWV0YWRhdGFPdXRsZXQiLCJmYWxsYmFjayJdLCJtYXBwaW5ncyI6IiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA2ODI0LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zcmMvc2VydmVyL2xpYi9yb3V0ZXItdXRpbHMvaXMtcG9zdHBvbmUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgUkVBQ1RfUE9TVFBPTkVfVFlQRTogc3ltYm9sID0gU3ltYm9sLmZvcigncmVhY3QucG9zdHBvbmUnKVxuXG5leHBvcnQgZnVuY3Rpb24gaXNQb3N0cG9uZShlcnJvcjogYW55KTogYm9vbGVhbiB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJlxuICAgIGVycm9yICE9PSBudWxsICYmXG4gICAgZXJyb3IuJCR0eXBlb2YgPT09IFJFQUNUX1BPU1RQT05FX1RZUEVcbiAgKVxufVxuIl0sIm5hbWVzIjpbIlJFQUNUX1BPU1RQT05FX1RZUEUiLCJTeW1ib2wiLCJmb3IiLCJpc1Bvc3Rwb25lIiwiZXJyb3IiLCIkJHR5cGVvZiJdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsTUFBTUEsc0JBQThCQyxPQUFPQyxHQUFHLENBQUM7QUFFeEMsU0FBU0MsV0FBV0MsS0FBVTtJQUNuQyxPQUNFLE9BQU9BLFVBQVUsWUFDakJBLFVBQVUsUUFDVkEsTUFBTUMsUUFBUSxLQUFLTDtBQUV2QiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA2ODM1LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zcmMvc2VydmVyL3JlcXVlc3QvcGF0aG5hbWUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBXb3JrU3RvcmUgfSBmcm9tICcuLi9hcHAtcmVuZGVyL3dvcmstYXN5bmMtc3RvcmFnZS5leHRlcm5hbCdcblxuaW1wb3J0IHtcbiAgcG9zdHBvbmVXaXRoVHJhY2tpbmcsXG4gIHR5cGUgRHluYW1pY1RyYWNraW5nU3RhdGUsXG59IGZyb20gJy4uL2FwcC1yZW5kZXIvZHluYW1pYy1yZW5kZXJpbmcnXG5cbmltcG9ydCB7XG4gIHdvcmtVbml0QXN5bmNTdG9yYWdlLFxuICB0eXBlIFByZXJlbmRlclN0b3JlLFxufSBmcm9tICcuLi9hcHAtcmVuZGVyL3dvcmstdW5pdC1hc3luYy1zdG9yYWdlLmV4dGVybmFsJ1xuaW1wb3J0IHsgbWFrZUhhbmdpbmdQcm9taXNlIH0gZnJvbSAnLi4vZHluYW1pYy1yZW5kZXJpbmctdXRpbHMnXG5pbXBvcnQgeyBJbnZhcmlhbnRFcnJvciB9IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvaW52YXJpYW50LWVycm9yJ1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2VydmVyUGF0aG5hbWVGb3JNZXRhZGF0YShcbiAgdW5kZXJseWluZ1BhdGhuYW1lOiBzdHJpbmcsXG4gIHdvcmtTdG9yZTogV29ya1N0b3JlXG4pOiBQcm9taXNlPHN0cmluZz4ge1xuICBjb25zdCB3b3JrVW5pdFN0b3JlID0gd29ya1VuaXRBc3luY1N0b3JhZ2UuZ2V0U3RvcmUoKVxuICBpZiAod29ya1VuaXRTdG9yZSkge1xuICAgIHN3aXRjaCAod29ya1VuaXRTdG9yZS50eXBlKSB7XG4gICAgICBjYXNlICdwcmVyZW5kZXInOlxuICAgICAgY2FzZSAncHJlcmVuZGVyLWNsaWVudCc6XG4gICAgICBjYXNlICdwcmVyZW5kZXItcHByJzpcbiAgICAgIGNhc2UgJ3ByZXJlbmRlci1sZWdhY3knOiB7XG4gICAgICAgIHJldHVybiBjcmVhdGVQcmVyZW5kZXJQYXRobmFtZShcbiAgICAgICAgICB1bmRlcmx5aW5nUGF0aG5hbWUsXG4gICAgICAgICAgd29ya1N0b3JlLFxuICAgICAgICAgIHdvcmtVbml0U3RvcmVcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgIC8vIGZhbGx0aHJvdWdoXG4gICAgfVxuICB9XG4gIHJldHVybiBjcmVhdGVSZW5kZXJQYXRobmFtZSh1bmRlcmx5aW5nUGF0aG5hbWUpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVByZXJlbmRlclBhdGhuYW1lKFxuICB1bmRlcmx5aW5nUGF0aG5hbWU6IHN0cmluZyxcbiAgd29ya1N0b3JlOiBXb3JrU3RvcmUsXG4gIHByZXJlbmRlclN0b3JlOiBQcmVyZW5kZXJTdG9yZVxuKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgY29uc3QgZmFsbGJhY2tQYXJhbXMgPSB3b3JrU3RvcmUuZmFsbGJhY2tSb3V0ZVBhcmFtc1xuICBpZiAoZmFsbGJhY2tQYXJhbXMgJiYgZmFsbGJhY2tQYXJhbXMuc2l6ZSA+IDApIHtcbiAgICBzd2l0Y2ggKHByZXJlbmRlclN0b3JlLnR5cGUpIHtcbiAgICAgIGNhc2UgJ3ByZXJlbmRlcic6XG4gICAgICAgIHJldHVybiBtYWtlSGFuZ2luZ1Byb21pc2U8c3RyaW5nPihcbiAgICAgICAgICBwcmVyZW5kZXJTdG9yZS5yZW5kZXJTaWduYWwsXG4gICAgICAgICAgJ2BwYXRobmFtZWAnXG4gICAgICAgIClcbiAgICAgIGNhc2UgJ3ByZXJlbmRlci1jbGllbnQnOlxuICAgICAgICB0aHJvdyBuZXcgSW52YXJpYW50RXJyb3IoXG4gICAgICAgICAgJ2NyZWF0ZVByZXJlbmRlclBhdGhuYW1lIHdhcyBjYWxsZWQgaW5zaWRlIGEgY2xpZW50IGNvbXBvbmVudCBzY29wZS4nXG4gICAgICAgIClcbiAgICAgIGNhc2UgJ3ByZXJlbmRlci1wcHInOlxuICAgICAgICByZXR1cm4gbWFrZUVycm9yaW5nUGF0aG5hbWUod29ya1N0b3JlLCBwcmVyZW5kZXJTdG9yZS5keW5hbWljVHJhY2tpbmcpXG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbWFrZUVycm9yaW5nUGF0aG5hbWUod29ya1N0b3JlLCBudWxsKVxuICAgIH1cbiAgfVxuXG4gIC8vIFdlIGRvbid0IGhhdmUgYW55IGZhbGxiYWNrIHBhcmFtcyBzbyB3ZSBoYXZlIGFuIGVudGlyZWx5IHN0YXRpYyBzYWZlIHBhcmFtcyBvYmplY3RcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh1bmRlcmx5aW5nUGF0aG5hbWUpXG59XG5cbmZ1bmN0aW9uIG1ha2VFcnJvcmluZ1BhdGhuYW1lPFQ+KFxuICB3b3JrU3RvcmU6IFdvcmtTdG9yZSxcbiAgZHluYW1pY1RyYWNraW5nOiBudWxsIHwgRHluYW1pY1RyYWNraW5nU3RhdGVcbik6IFByb21pc2U8VD4ge1xuICBsZXQgcmVqZWN0OiBudWxsIHwgKChyZWFzb246IHVua25vd24pID0+IHZvaWQpID0gbnVsbFxuICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2U8VD4oKF8sIHJlKSA9PiB7XG4gICAgcmVqZWN0ID0gcmVcbiAgfSlcblxuICBjb25zdCBvcmlnaW5hbFRoZW4gPSBwcm9taXNlLnRoZW4uYmluZChwcm9taXNlKVxuXG4gIC8vIFdlIGluc3RydW1lbnQgLnRoZW4gc28gdGhhdCB3ZSBjYW4gZ2VuZXJhdGUgYSB0cmFja2luZyBldmVudCBvbmx5IGlmIHlvdSBhY3R1YWxseVxuICAvLyBhd2FpdCB0aGlzIHByb21pc2UsIG5vdCBqdXN0IHRoYXQgaXQgaXMgY3JlYXRlZC5cbiAgcHJvbWlzZS50aGVuID0gKG9uZnVsZmlsbGVkLCBvbnJlamVjdGVkKSA9PiB7XG4gICAgaWYgKHJlamVjdCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcG9zdHBvbmVXaXRoVHJhY2tpbmcoXG4gICAgICAgICAgd29ya1N0b3JlLnJvdXRlLFxuICAgICAgICAgICdtZXRhZGF0YSByZWxhdGl2ZSB1cmwgcmVzb2x2aW5nJyxcbiAgICAgICAgICBkeW5hbWljVHJhY2tpbmdcbiAgICAgICAgKVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmVqZWN0KGVycm9yKVxuICAgICAgICByZWplY3QgPSBudWxsXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvcmlnaW5hbFRoZW4ob25mdWxmaWxsZWQsIG9ucmVqZWN0ZWQpXG4gIH1cblxuICAvLyBXZSB3cmFwIGluIGEgbm9vcCBwcm94eSB0byB0cmljayB0aGUgcnVudGltZSBpbnRvIHRoaW5raW5nIGl0XG4gIC8vIGlzbid0IGEgbmF0aXZlIHByb21pc2UgKGl0J3Mgbm90IHJlYWxseSkuIFRoaXMgaXMgc28gdGhhdCBhd2FpdGluZ1xuICAvLyB0aGUgcHJvbWlzZSB3aWxsIGNhbGwgdGhlIGB0aGVuYCBwcm9wZXJ0eSB0cmlnZ2VyaW5nIHRoZSBsYXp5IHBvc3Rwb25lXG4gIHJldHVybiBuZXcgUHJveHkocHJvbWlzZSwge30pXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJlbmRlclBhdGhuYW1lKHVuZGVybHlpbmdQYXRobmFtZTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh1bmRlcmx5aW5nUGF0aG5hbWUpXG59XG4iXSwibmFtZXMiOlsicG9zdHBvbmVXaXRoVHJhY2tpbmciLCJ3b3JrVW5pdEFzeW5jU3RvcmFnZSIsIm1ha2VIYW5naW5nUHJvbWlzZSIsIkludmFyaWFudEVycm9yIiwiY3JlYXRlU2VydmVyUGF0aG5hbWVGb3JNZXRhZGF0YSIsInVuZGVybHlpbmdQYXRobmFtZSIsIndvcmtTdG9yZSIsIndvcmtVbml0U3RvcmUiLCJnZXRTdG9yZSIsInR5cGUiLCJjcmVhdGVQcmVyZW5kZXJQYXRobmFtZSIsImNyZWF0ZVJlbmRlclBhdGhuYW1lIiwicHJlcmVuZGVyU3RvcmUiLCJmYWxsYmFja1BhcmFtcyIsImZhbGxiYWNrUm91dGVQYXJhbXMiLCJzaXplIiwicmVuZGVyU2lnbmFsIiwibWFrZUVycm9yaW5nUGF0aG5hbWUiLCJkeW5hbWljVHJhY2tpbmciLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInByb21pc2UiLCJfIiwicmUiLCJvcmlnaW5hbFRoZW4iLCJ0aGVuIiwiYmluZCIsIm9uZnVsZmlsbGVkIiwib25yZWplY3RlZCIsInJvdXRlIiwiZXJyb3IiLCJQcm94eSJdLCJtYXBwaW5ncyI6Ijs7O0FBRUEsU0FDRUEsb0JBQW9CLFFBRWYsa0NBQWlDO0FBRXhDLFNBQ0VDLG9CQUFvQixRQUVmLGlEQUFnRDtBQUN2RCxTQUFTQyxrQkFBa0IsUUFBUSw2QkFBNEI7QUFDL0QsU0FBU0MsY0FBYyxRQUFRLG1DQUFrQzs7Ozs7QUFFMUQsU0FBU0MsZ0NBQ2RDLGtCQUEwQixFQUMxQkMsU0FBb0I7SUFFcEIsTUFBTUMsb1NBQWdCTix1QkFBQUEsQ0FBcUJPLFFBQVE7SUFDbkQsSUFBSUQsZUFBZTtRQUNqQixPQUFRQSxjQUFjRSxJQUFJO1lBQ3hCLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7Z0JBQW9CO29CQUN2QixPQUFPQyx3QkFDTEwsb0JBQ0FDLFdBQ0FDO2dCQUVKO1lBQ0E7UUFFRjtJQUNGO0lBQ0EsT0FBT0kscUJBQXFCTjtBQUM5QjtBQUVBLFNBQVNLLHdCQUNQTCxrQkFBMEIsRUFDMUJDLFNBQW9CLEVBQ3BCTSxjQUE4QjtJQUU5QixNQUFNQyxpQkFBaUJQLFVBQVVRLG1CQUFtQjtJQUNwRCxJQUFJRCxrQkFBa0JBLGVBQWVFLElBQUksR0FBRyxHQUFHO1FBQzdDLE9BQVFILGVBQWVILElBQUk7WUFDekIsS0FBSztnQkFDSCwwTEFBT1AscUJBQUFBLEVBQ0xVLGVBQWVJLFlBQVksRUFDM0I7WUFFSixLQUFLO2dCQUNILE1BQU0sT0FBQSxjQUVMLENBRkssSUFBSWIsNExBQUFBLENBQ1Isd0VBREkscUJBQUE7MkJBQUE7Z0NBQUE7a0NBQUE7Z0JBRU47WUFDRixLQUFLO2dCQUNILE9BQU9jLHFCQUFxQlgsV0FBV00sZUFBZU0sZUFBZTs7O1lBRXZFO2dCQUNFLE9BQU9ELHFCQUFxQlgsV0FBVztRQUMzQztJQUNGO0lBRUEscUZBQXFGO0lBQ3JGLE9BQU9hLFFBQVFDLE9BQU8sQ0FBQ2Y7QUFDekI7QUFFQSxTQUFTWSxxQkFDUFgsU0FBb0IsRUFDcEJZLGVBQTRDO0lBRTVDLElBQUlHLFNBQTZDO0lBQ2pELE1BQU1DLFVBQVUsSUFBSUgsUUFBVyxDQUFDSSxHQUFHQztRQUNqQ0gsU0FBU0c7SUFDWDtJQUVBLE1BQU1DLGVBQWVILFFBQVFJLElBQUksQ0FBQ0MsSUFBSSxDQUFDTDtJQUV2QyxvRkFBb0Y7SUFDcEYsbURBQW1EO0lBQ25EQSxRQUFRSSxJQUFJLEdBQUcsQ0FBQ0UsYUFBYUM7UUFDM0IsSUFBSVIsUUFBUTtZQUNWLElBQUk7aUJBQ0ZyQixpTkFBQUEsRUFDRU0sVUFBVXdCLEtBQUssRUFDZixtQ0FDQVo7WUFFSixFQUFFLE9BQU9hLE9BQU87Z0JBQ2RWLE9BQU9VO2dCQUNQVixTQUFTO1lBQ1g7UUFDRjtRQUNBLE9BQU9JLGFBQWFHLGFBQWFDO0lBQ25DO0lBRUEsZ0VBQWdFO0lBQ2hFLHFFQUFxRTtJQUNyRSx5RUFBeUU7SUFDekUsT0FBTyxJQUFJRyxNQUFNVixTQUFTLENBQUM7QUFDN0I7QUFFQSxTQUFTWCxxQkFBcUJOLGtCQUEwQjtJQUN0RCxPQUFPYyxRQUFRQyxPQUFPLENBQUNmO0FBQ3pCIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDY5MTYsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NyYy9saWIvbWV0YWRhdGEvbWV0YWRhdGEudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyBTdXNwZW5zZSwgY2FjaGUsIGNsb25lRWxlbWVudCB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHR5cGUgeyBQYXJzZWRVcmxRdWVyeSB9IGZyb20gJ3F1ZXJ5c3RyaW5nJ1xuaW1wb3J0IHR5cGUgeyBHZXREeW5hbWljUGFyYW1Gcm9tU2VnbWVudCB9IGZyb20gJy4uLy4uL3NlcnZlci9hcHAtcmVuZGVyL2FwcC1yZW5kZXInXG5pbXBvcnQgdHlwZSB7IExvYWRlclRyZWUgfSBmcm9tICcuLi8uLi9zZXJ2ZXIvbGliL2FwcC1kaXItbW9kdWxlJ1xuaW1wb3J0IHR5cGUgeyBTdHJlYW1pbmdNZXRhZGF0YVJlc29sdmVkU3RhdGUgfSBmcm9tICcuLi8uLi9jbGllbnQvY29tcG9uZW50cy9tZXRhZGF0YS90eXBlcydcbmltcG9ydCB0eXBlIHsgU2VhcmNoUGFyYW1zIH0gZnJvbSAnLi4vLi4vc2VydmVyL3JlcXVlc3Qvc2VhcmNoLXBhcmFtcydcbmltcG9ydCB7XG4gIEFwcGxlV2ViQXBwTWV0YSxcbiAgRm9ybWF0RGV0ZWN0aW9uTWV0YSxcbiAgSXR1bmVzTWV0YSxcbiAgQmFzaWNNZXRhLFxuICBWaWV3cG9ydE1ldGEsXG4gIFZlcmlmaWNhdGlvbk1ldGEsXG4gIEZhY2Vib29rTWV0YSxcbiAgUGludGVyZXN0TWV0YSxcbn0gZnJvbSAnLi9nZW5lcmF0ZS9iYXNpYydcbmltcG9ydCB7IEFsdGVybmF0ZXNNZXRhZGF0YSB9IGZyb20gJy4vZ2VuZXJhdGUvYWx0ZXJuYXRlJ1xuaW1wb3J0IHtcbiAgT3BlbkdyYXBoTWV0YWRhdGEsXG4gIFR3aXR0ZXJNZXRhZGF0YSxcbiAgQXBwTGlua3NNZXRhLFxufSBmcm9tICcuL2dlbmVyYXRlL29wZW5ncmFwaCdcbmltcG9ydCB7IEljb25zTWV0YWRhdGEgfSBmcm9tICcuL2dlbmVyYXRlL2ljb25zJ1xuaW1wb3J0IHtcbiAgdHlwZSBNZXRhZGF0YUVycm9yVHlwZSxcbiAgcmVzb2x2ZU1ldGFkYXRhLFxuICByZXNvbHZlVmlld3BvcnQsXG59IGZyb20gJy4vcmVzb2x2ZS1tZXRhZGF0YSdcbmltcG9ydCB7IE1ldGFGaWx0ZXIgfSBmcm9tICcuL2dlbmVyYXRlL21ldGEnXG5pbXBvcnQgdHlwZSB7XG4gIFJlc29sdmVkTWV0YWRhdGEsXG4gIFJlc29sdmVkVmlld3BvcnQsXG59IGZyb20gJy4vdHlwZXMvbWV0YWRhdGEtaW50ZXJmYWNlJ1xuaW1wb3J0IHsgaXNIVFRQQWNjZXNzRmFsbGJhY2tFcnJvciB9IGZyb20gJy4uLy4uL2NsaWVudC9jb21wb25lbnRzL2h0dHAtYWNjZXNzLWZhbGxiYWNrL2h0dHAtYWNjZXNzLWZhbGxiYWNrJ1xuaW1wb3J0IHR5cGUgeyBNZXRhZGF0YUNvbnRleHQgfSBmcm9tICcuL3R5cGVzL3Jlc29sdmVycydcbmltcG9ydCB0eXBlIHsgV29ya1N0b3JlIH0gZnJvbSAnLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvd29yay1hc3luYy1zdG9yYWdlLmV4dGVybmFsJ1xuaW1wb3J0IHtcbiAgTUVUQURBVEFfQk9VTkRBUllfTkFNRSxcbiAgVklFV1BPUlRfQk9VTkRBUllfTkFNRSxcbn0gZnJvbSAnLi9tZXRhZGF0YS1jb25zdGFudHMnXG5pbXBvcnQgeyBBc3luY01ldGFkYXRhT3V0bGV0IH0gZnJvbSAnLi4vLi4vY2xpZW50L2NvbXBvbmVudHMvbWV0YWRhdGEvYXN5bmMtbWV0YWRhdGEnXG5pbXBvcnQgeyBpc1Bvc3Rwb25lIH0gZnJvbSAnLi4vLi4vc2VydmVyL2xpYi9yb3V0ZXItdXRpbHMvaXMtcG9zdHBvbmUnXG5pbXBvcnQgeyBjcmVhdGVTZXJ2ZXJTZWFyY2hQYXJhbXNGb3JNZXRhZGF0YSB9IGZyb20gJy4uLy4uL3NlcnZlci9yZXF1ZXN0L3NlYXJjaC1wYXJhbXMnXG5pbXBvcnQgeyBjcmVhdGVTZXJ2ZXJQYXRobmFtZUZvck1ldGFkYXRhIH0gZnJvbSAnLi4vLi4vc2VydmVyL3JlcXVlc3QvcGF0aG5hbWUnXG5cbi8vIFVzZSBhIHByb21pc2UgdG8gc2hhcmUgdGhlIHN0YXR1cyBvZiB0aGUgbWV0YWRhdGEgcmVzb2x2aW5nLFxuLy8gcmV0dXJuaW5nIHR3byBjb21wb25lbnRzIGBNZXRhZGF0YVRyZWVgIGFuZCBgTWV0YWRhdGFPdXRsZXRgXG4vLyBgTWV0YWRhdGFUcmVlYCBpcyB0aGUgb25lIHRoYXQgd2lsbCBiZSByZW5kZXJlZCBhdCBmaXJzdCBpbiB0aGUgY29udGVudCBzZXF1ZW5jZSBmb3IgbWV0YWRhdGEgdGFncy5cbi8vIGBNZXRhZGF0YU91dGxldGAgaXMgdGhlIG9uZSB0aGF0IHdpbGwgYmUgcmVuZGVyZWQgdW5kZXIgZXJyb3IgYm91bmRhcmllcyBmb3IgbWV0YWRhdGEgcmVzb2x2aW5nIGVycm9ycy5cbi8vIEluIHRoaXMgd2F5IHdlIGNhbiBsZXQgdGhlIG1ldGFkYXRhIHRhZ3MgYWx3YXlzIHJlbmRlciBzdWNjZXNzZnVsbHksXG4vLyBhbmQgdGhlIGVycm9yIHdpbGwgYmUgY2F1Z2h0IGJ5IHRoZSBlcnJvciBib3VuZGFyeSBhbmQgdHJpZ2dlciBmYWxsYmFja3MuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTWV0YWRhdGFDb21wb25lbnRzKHtcbiAgdHJlZSxcbiAgcGF0aG5hbWUsXG4gIHBhcnNlZFF1ZXJ5LFxuICBtZXRhZGF0YUNvbnRleHQsXG4gIGdldER5bmFtaWNQYXJhbUZyb21TZWdtZW50LFxuICBhcHBVc2luZ1NpemVBZGp1c3RtZW50LFxuICBlcnJvclR5cGUsXG4gIHdvcmtTdG9yZSxcbiAgTWV0YWRhdGFCb3VuZGFyeSxcbiAgVmlld3BvcnRCb3VuZGFyeSxcbiAgc2VydmVTdHJlYW1pbmdNZXRhZGF0YSxcbn06IHtcbiAgdHJlZTogTG9hZGVyVHJlZVxuICBwYXRobmFtZTogc3RyaW5nXG4gIHBhcnNlZFF1ZXJ5OiBTZWFyY2hQYXJhbXNcbiAgbWV0YWRhdGFDb250ZXh0OiBNZXRhZGF0YUNvbnRleHRcbiAgZ2V0RHluYW1pY1BhcmFtRnJvbVNlZ21lbnQ6IEdldER5bmFtaWNQYXJhbUZyb21TZWdtZW50XG4gIGFwcFVzaW5nU2l6ZUFkanVzdG1lbnQ6IGJvb2xlYW5cbiAgZXJyb3JUeXBlPzogTWV0YWRhdGFFcnJvclR5cGUgfCAncmVkaXJlY3QnXG4gIHdvcmtTdG9yZTogV29ya1N0b3JlXG4gIE1ldGFkYXRhQm91bmRhcnk6IChwcm9wczogeyBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlIH0pID0+IFJlYWN0LlJlYWN0Tm9kZVxuICBWaWV3cG9ydEJvdW5kYXJ5OiAocHJvcHM6IHsgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZSB9KSA9PiBSZWFjdC5SZWFjdE5vZGVcbiAgc2VydmVTdHJlYW1pbmdNZXRhZGF0YTogYm9vbGVhblxufSk6IHtcbiAgTWV0YWRhdGFUcmVlOiBSZWFjdC5Db21wb25lbnRUeXBlXG4gIFZpZXdwb3J0VHJlZTogUmVhY3QuQ29tcG9uZW50VHlwZVxuICBnZXRNZXRhZGF0YVJlYWR5OiAoKSA9PiBQcm9taXNlPHZvaWQ+XG4gIGdldFZpZXdwb3J0UmVhZHk6ICgpID0+IFByb21pc2U8dm9pZD5cbiAgU3RyZWFtaW5nTWV0YWRhdGFPdXRsZXQ6IFJlYWN0LkNvbXBvbmVudFR5cGUgfCBudWxsXG59IHtcbiAgY29uc3Qgc2VhcmNoUGFyYW1zID0gY3JlYXRlU2VydmVyU2VhcmNoUGFyYW1zRm9yTWV0YWRhdGEoXG4gICAgcGFyc2VkUXVlcnksXG4gICAgd29ya1N0b3JlXG4gIClcbiAgY29uc3QgcGF0aG5hbWVGb3JNZXRhZGF0YSA9IGNyZWF0ZVNlcnZlclBhdGhuYW1lRm9yTWV0YWRhdGEoXG4gICAgcGF0aG5hbWUsXG4gICAgd29ya1N0b3JlXG4gIClcblxuICBmdW5jdGlvbiBWaWV3cG9ydFRyZWUoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDw+XG4gICAgICAgIDxWaWV3cG9ydEJvdW5kYXJ5PlxuICAgICAgICAgIDxWaWV3cG9ydCAvPlxuICAgICAgICA8L1ZpZXdwb3J0Qm91bmRhcnk+XG4gICAgICAgIHsvKiBUaGlzIG1ldGEgdGFnIGlzIGZvciBuZXh0L2ZvbnQgd2hpY2ggaXMgc3RpbGwgcmVxdWlyZWQgdG8gYmUgYmxvY2tpbmcuICovfVxuICAgICAgICB7YXBwVXNpbmdTaXplQWRqdXN0bWVudCA/IChcbiAgICAgICAgICA8bWV0YSBuYW1lPVwibmV4dC1zaXplLWFkanVzdFwiIGNvbnRlbnQ9XCJcIiAvPlxuICAgICAgICApIDogbnVsbH1cbiAgICAgIDwvPlxuICAgIClcbiAgfVxuXG4gIGZ1bmN0aW9uIE1ldGFkYXRhVHJlZSgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPE1ldGFkYXRhQm91bmRhcnk+XG4gICAgICAgIDxNZXRhZGF0YSAvPlxuICAgICAgPC9NZXRhZGF0YUJvdW5kYXJ5PlxuICAgIClcbiAgfVxuXG4gIGZ1bmN0aW9uIHZpZXdwb3J0KCkge1xuICAgIHJldHVybiBnZXRSZXNvbHZlZFZpZXdwb3J0KFxuICAgICAgdHJlZSxcbiAgICAgIHNlYXJjaFBhcmFtcyxcbiAgICAgIGdldER5bmFtaWNQYXJhbUZyb21TZWdtZW50LFxuICAgICAgd29ya1N0b3JlLFxuICAgICAgZXJyb3JUeXBlXG4gICAgKVxuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gVmlld3BvcnQoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCB2aWV3cG9ydCgpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmICghZXJyb3JUeXBlICYmIGlzSFRUUEFjY2Vzc0ZhbGxiYWNrRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGF3YWl0IGdldE5vdEZvdW5kVmlld3BvcnQoXG4gICAgICAgICAgICB0cmVlLFxuICAgICAgICAgICAgc2VhcmNoUGFyYW1zLFxuICAgICAgICAgICAgZ2V0RHluYW1pY1BhcmFtRnJvbVNlZ21lbnQsXG4gICAgICAgICAgICB3b3JrU3RvcmVcbiAgICAgICAgICApXG4gICAgICAgIH0gY2F0Y2gge31cbiAgICAgIH1cbiAgICAgIC8vIFdlIGRvbid0IGFjdHVhbGx5IHdhbnQgdG8gZXJyb3IgaW4gdGhpcyBjb21wb25lbnQuIFdlIHdpbGxcbiAgICAgIC8vIGFsc28gZXJyb3IgaW4gdGhlIE1ldGFkYXRhT3V0bGV0IHdoaWNoIGNhdXNlcyB0aGUgZXJyb3IgdG9cbiAgICAgIC8vIGJ1YmJsZSBmcm9tIHRoZSByaWdodCBwb3NpdGlvbiBpbiB0aGUgcGFnZSB0byBiZSBjYXVnaHQgYnkgdGhlXG4gICAgICAvLyBhcHByb3ByaWF0ZSBib3VuZGFyaWVzXG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxuICBWaWV3cG9ydC5kaXNwbGF5TmFtZSA9IFZJRVdQT1JUX0JPVU5EQVJZX05BTUVcblxuICBmdW5jdGlvbiBtZXRhZGF0YSgpIHtcbiAgICByZXR1cm4gZ2V0UmVzb2x2ZWRNZXRhZGF0YShcbiAgICAgIHRyZWUsXG4gICAgICBwYXRobmFtZUZvck1ldGFkYXRhLFxuICAgICAgc2VhcmNoUGFyYW1zLFxuICAgICAgZ2V0RHluYW1pY1BhcmFtRnJvbVNlZ21lbnQsXG4gICAgICBtZXRhZGF0YUNvbnRleHQsXG4gICAgICB3b3JrU3RvcmUsXG4gICAgICBlcnJvclR5cGVcbiAgICApXG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiByZXNvbHZlRmluYWxNZXRhZGF0YSgpOiBQcm9taXNlPFN0cmVhbWluZ01ldGFkYXRhUmVzb2x2ZWRTdGF0ZT4ge1xuICAgIGxldCByZXN1bHQ6IFJlYWN0LlJlYWN0Tm9kZVxuICAgIGxldCBlcnJvciA9IG51bGxcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gYXdhaXQgbWV0YWRhdGEoKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWV0YWRhdGE6IHJlc3VsdCxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgIGRpZ2VzdDogdW5kZWZpbmVkLFxuICAgICAgfVxuICAgIH0gY2F0Y2ggKG1ldGFkYXRhRXJyKSB7XG4gICAgICBlcnJvciA9IG1ldGFkYXRhRXJyXG4gICAgICBpZiAoIWVycm9yVHlwZSAmJiBpc0hUVFBBY2Nlc3NGYWxsYmFja0Vycm9yKG1ldGFkYXRhRXJyKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IGdldE5vdEZvdW5kTWV0YWRhdGEoXG4gICAgICAgICAgICB0cmVlLFxuICAgICAgICAgICAgcGF0aG5hbWVGb3JNZXRhZGF0YSxcbiAgICAgICAgICAgIHNlYXJjaFBhcmFtcyxcbiAgICAgICAgICAgIGdldER5bmFtaWNQYXJhbUZyb21TZWdtZW50LFxuICAgICAgICAgICAgbWV0YWRhdGFDb250ZXh0LFxuICAgICAgICAgICAgd29ya1N0b3JlXG4gICAgICAgICAgKVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZXRhZGF0YTogcmVzdWx0LFxuICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICBkaWdlc3Q6IChlcnJvciBhcyBhbnkpPy5kaWdlc3QsXG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChub3RGb3VuZE1ldGFkYXRhRXJyKSB7XG4gICAgICAgICAgZXJyb3IgPSBub3RGb3VuZE1ldGFkYXRhRXJyXG4gICAgICAgICAgLy8gSW4gUFBSIHJlbmRlcmluZyB3ZSBzdGlsbCBuZWVkIHRvIHRocm93IHRoZSBwb3N0cG9uZSBlcnJvci5cbiAgICAgICAgICAvLyBJZiBtZXRhZGF0YSBpcyBwb3N0cG9uZWQsIFJlYWN0IG5lZWRzIHRvIGJlIGF3YXJlIG9mIHRoZSBsb2NhdGlvbiBvZiBlcnJvci5cbiAgICAgICAgICBpZiAoc2VydmVTdHJlYW1pbmdNZXRhZGF0YSAmJiBpc1Bvc3Rwb25lKG5vdEZvdW5kTWV0YWRhdGFFcnIpKSB7XG4gICAgICAgICAgICB0aHJvdyBub3RGb3VuZE1ldGFkYXRhRXJyXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBJbiBQUFIgcmVuZGVyaW5nIHdlIHN0aWxsIG5lZWQgdG8gdGhyb3cgdGhlIHBvc3Rwb25lIGVycm9yLlxuICAgICAgLy8gSWYgbWV0YWRhdGEgaXMgcG9zdHBvbmVkLCBSZWFjdCBuZWVkcyB0byBiZSBhd2FyZSBvZiB0aGUgbG9jYXRpb24gb2YgZXJyb3IuXG4gICAgICBpZiAoc2VydmVTdHJlYW1pbmdNZXRhZGF0YSAmJiBpc1Bvc3Rwb25lKG1ldGFkYXRhRXJyKSkge1xuICAgICAgICB0aHJvdyBtZXRhZGF0YUVyclxuICAgICAgfVxuICAgICAgLy8gV2UgZG9uJ3QgYWN0dWFsbHkgd2FudCB0byBlcnJvciBpbiB0aGlzIGNvbXBvbmVudC4gV2Ugd2lsbFxuICAgICAgLy8gYWxzbyBlcnJvciBpbiB0aGUgTWV0YWRhdGFPdXRsZXQgd2hpY2ggY2F1c2VzIHRoZSBlcnJvciB0b1xuICAgICAgLy8gYnViYmxlIGZyb20gdGhlIHJpZ2h0IHBvc2l0aW9uIGluIHRoZSBwYWdlIHRvIGJlIGNhdWdodCBieSB0aGVcbiAgICAgIC8vIGFwcHJvcHJpYXRlIGJvdW5kYXJpZXNcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1ldGFkYXRhOiByZXN1bHQsXG4gICAgICAgIGVycm9yLFxuICAgICAgICBkaWdlc3Q6IChlcnJvciBhcyBhbnkpPy5kaWdlc3QsXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gTWV0YWRhdGEoKSB7XG4gICAgaWYgKCFzZXJ2ZVN0cmVhbWluZ01ldGFkYXRhKSB7XG4gICAgICByZXR1cm4gPE1ldGFkYXRhUmVzb2x2ZXIgLz5cbiAgICB9XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgaGlkZGVuPlxuICAgICAgICA8U3VzcGVuc2UgZmFsbGJhY2s9e251bGx9PlxuICAgICAgICAgIDxNZXRhZGF0YVJlc29sdmVyIC8+XG4gICAgICAgIDwvU3VzcGVuc2U+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBNZXRhZGF0YVJlc29sdmVyKCkge1xuICAgIGNvbnN0IG1ldGFkYXRhU3RhdGUgPSBhd2FpdCByZXNvbHZlRmluYWxNZXRhZGF0YSgpXG4gICAgcmV0dXJuIG1ldGFkYXRhU3RhdGUubWV0YWRhdGFcbiAgfVxuXG4gIE1ldGFkYXRhLmRpc3BsYXlOYW1lID0gTUVUQURBVEFfQk9VTkRBUllfTkFNRVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGdldE1ldGFkYXRhUmVhZHkoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgLy8gT25seSB3YXJtIHVwIG1ldGFkYXRhKCkgY2FsbCB3aGVuIGl0J3MgYmxvY2tpbmcgbWV0YWRhdGEsXG4gICAgLy8gb3RoZXJ3aXNlIGl0IHdpbGwgYmUgZnVsbHkgbWFuYWdlZCBieSBBc3luY01ldGFkYXRhIGNvbXBvbmVudC5cbiAgICBpZiAoIXNlcnZlU3RyZWFtaW5nTWV0YWRhdGEpIHtcbiAgICAgIGF3YWl0IG1ldGFkYXRhKClcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0Vmlld3BvcnRSZWFkeSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBhd2FpdCB2aWV3cG9ydCgpXG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG5cbiAgZnVuY3Rpb24gU3RyZWFtaW5nTWV0YWRhdGFPdXRsZXRJbXBsKCkge1xuICAgIHJldHVybiA8QXN5bmNNZXRhZGF0YU91dGxldCBwcm9taXNlPXtyZXNvbHZlRmluYWxNZXRhZGF0YSgpfSAvPlxuICB9XG5cbiAgY29uc3QgU3RyZWFtaW5nTWV0YWRhdGFPdXRsZXQgPSBzZXJ2ZVN0cmVhbWluZ01ldGFkYXRhXG4gICAgPyBTdHJlYW1pbmdNZXRhZGF0YU91dGxldEltcGxcbiAgICA6IG51bGxcblxuICByZXR1cm4ge1xuICAgIFZpZXdwb3J0VHJlZSxcbiAgICBNZXRhZGF0YVRyZWUsXG4gICAgZ2V0Vmlld3BvcnRSZWFkeSxcbiAgICBnZXRNZXRhZGF0YVJlYWR5LFxuICAgIFN0cmVhbWluZ01ldGFkYXRhT3V0bGV0LFxuICB9XG59XG5cbmNvbnN0IGdldFJlc29sdmVkTWV0YWRhdGEgPSBjYWNoZShnZXRSZXNvbHZlZE1ldGFkYXRhSW1wbClcbmFzeW5jIGZ1bmN0aW9uIGdldFJlc29sdmVkTWV0YWRhdGFJbXBsKFxuICB0cmVlOiBMb2FkZXJUcmVlLFxuICBwYXRobmFtZTogUHJvbWlzZTxzdHJpbmc+LFxuICBzZWFyY2hQYXJhbXM6IFByb21pc2U8UGFyc2VkVXJsUXVlcnk+LFxuICBnZXREeW5hbWljUGFyYW1Gcm9tU2VnbWVudDogR2V0RHluYW1pY1BhcmFtRnJvbVNlZ21lbnQsXG4gIG1ldGFkYXRhQ29udGV4dDogTWV0YWRhdGFDb250ZXh0LFxuICB3b3JrU3RvcmU6IFdvcmtTdG9yZSxcbiAgZXJyb3JUeXBlPzogTWV0YWRhdGFFcnJvclR5cGUgfCAncmVkaXJlY3QnXG4pOiBQcm9taXNlPFJlYWN0LlJlYWN0Tm9kZT4ge1xuICBjb25zdCBlcnJvckNvbnZlbnRpb24gPSBlcnJvclR5cGUgPT09ICdyZWRpcmVjdCcgPyB1bmRlZmluZWQgOiBlcnJvclR5cGVcbiAgcmV0dXJuIHJlbmRlck1ldGFkYXRhKFxuICAgIHRyZWUsXG4gICAgcGF0aG5hbWUsXG4gICAgc2VhcmNoUGFyYW1zLFxuICAgIGdldER5bmFtaWNQYXJhbUZyb21TZWdtZW50LFxuICAgIG1ldGFkYXRhQ29udGV4dCxcbiAgICB3b3JrU3RvcmUsXG4gICAgZXJyb3JDb252ZW50aW9uXG4gIClcbn1cblxuY29uc3QgZ2V0Tm90Rm91bmRNZXRhZGF0YSA9IGNhY2hlKGdldE5vdEZvdW5kTWV0YWRhdGFJbXBsKVxuYXN5bmMgZnVuY3Rpb24gZ2V0Tm90Rm91bmRNZXRhZGF0YUltcGwoXG4gIHRyZWU6IExvYWRlclRyZWUsXG4gIHBhdGhuYW1lOiBQcm9taXNlPHN0cmluZz4sXG4gIHNlYXJjaFBhcmFtczogUHJvbWlzZTxQYXJzZWRVcmxRdWVyeT4sXG4gIGdldER5bmFtaWNQYXJhbUZyb21TZWdtZW50OiBHZXREeW5hbWljUGFyYW1Gcm9tU2VnbWVudCxcbiAgbWV0YWRhdGFDb250ZXh0OiBNZXRhZGF0YUNvbnRleHQsXG4gIHdvcmtTdG9yZTogV29ya1N0b3JlXG4pOiBQcm9taXNlPFJlYWN0LlJlYWN0Tm9kZT4ge1xuICBjb25zdCBub3RGb3VuZEVycm9yQ29udmVudGlvbiA9ICdub3QtZm91bmQnXG4gIHJldHVybiByZW5kZXJNZXRhZGF0YShcbiAgICB0cmVlLFxuICAgIHBhdGhuYW1lLFxuICAgIHNlYXJjaFBhcmFtcyxcbiAgICBnZXREeW5hbWljUGFyYW1Gcm9tU2VnbWVudCxcbiAgICBtZXRhZGF0YUNvbnRleHQsXG4gICAgd29ya1N0b3JlLFxuICAgIG5vdEZvdW5kRXJyb3JDb252ZW50aW9uXG4gIClcbn1cblxuY29uc3QgZ2V0UmVzb2x2ZWRWaWV3cG9ydCA9IGNhY2hlKGdldFJlc29sdmVkVmlld3BvcnRJbXBsKVxuYXN5bmMgZnVuY3Rpb24gZ2V0UmVzb2x2ZWRWaWV3cG9ydEltcGwoXG4gIHRyZWU6IExvYWRlclRyZWUsXG4gIHNlYXJjaFBhcmFtczogUHJvbWlzZTxQYXJzZWRVcmxRdWVyeT4sXG4gIGdldER5bmFtaWNQYXJhbUZyb21TZWdtZW50OiBHZXREeW5hbWljUGFyYW1Gcm9tU2VnbWVudCxcbiAgd29ya1N0b3JlOiBXb3JrU3RvcmUsXG4gIGVycm9yVHlwZT86IE1ldGFkYXRhRXJyb3JUeXBlIHwgJ3JlZGlyZWN0J1xuKTogUHJvbWlzZTxSZWFjdC5SZWFjdE5vZGU+IHtcbiAgY29uc3QgZXJyb3JDb252ZW50aW9uID0gZXJyb3JUeXBlID09PSAncmVkaXJlY3QnID8gdW5kZWZpbmVkIDogZXJyb3JUeXBlXG4gIHJldHVybiByZW5kZXJWaWV3cG9ydChcbiAgICB0cmVlLFxuICAgIHNlYXJjaFBhcmFtcyxcbiAgICBnZXREeW5hbWljUGFyYW1Gcm9tU2VnbWVudCxcbiAgICB3b3JrU3RvcmUsXG4gICAgZXJyb3JDb252ZW50aW9uXG4gIClcbn1cblxuY29uc3QgZ2V0Tm90Rm91bmRWaWV3cG9ydCA9IGNhY2hlKGdldE5vdEZvdW5kVmlld3BvcnRJbXBsKVxuYXN5bmMgZnVuY3Rpb24gZ2V0Tm90Rm91bmRWaWV3cG9ydEltcGwoXG4gIHRyZWU6IExvYWRlclRyZWUsXG4gIHNlYXJjaFBhcmFtczogUHJvbWlzZTxQYXJzZWRVcmxRdWVyeT4sXG4gIGdldER5bmFtaWNQYXJhbUZyb21TZWdtZW50OiBHZXREeW5hbWljUGFyYW1Gcm9tU2VnbWVudCxcbiAgd29ya1N0b3JlOiBXb3JrU3RvcmVcbik6IFByb21pc2U8UmVhY3QuUmVhY3ROb2RlPiB7XG4gIGNvbnN0IG5vdEZvdW5kRXJyb3JDb252ZW50aW9uID0gJ25vdC1mb3VuZCdcbiAgcmV0dXJuIHJlbmRlclZpZXdwb3J0KFxuICAgIHRyZWUsXG4gICAgc2VhcmNoUGFyYW1zLFxuICAgIGdldER5bmFtaWNQYXJhbUZyb21TZWdtZW50LFxuICAgIHdvcmtTdG9yZSxcbiAgICBub3RGb3VuZEVycm9yQ29udmVudGlvblxuICApXG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlbmRlck1ldGFkYXRhKFxuICB0cmVlOiBMb2FkZXJUcmVlLFxuICBwYXRobmFtZTogUHJvbWlzZTxzdHJpbmc+LFxuICBzZWFyY2hQYXJhbXM6IFByb21pc2U8UGFyc2VkVXJsUXVlcnk+LFxuICBnZXREeW5hbWljUGFyYW1Gcm9tU2VnbWVudDogR2V0RHluYW1pY1BhcmFtRnJvbVNlZ21lbnQsXG4gIG1ldGFkYXRhQ29udGV4dDogTWV0YWRhdGFDb250ZXh0LFxuICB3b3JrU3RvcmU6IFdvcmtTdG9yZSxcbiAgZXJyb3JDb252ZW50aW9uPzogTWV0YWRhdGFFcnJvclR5cGVcbikge1xuICBjb25zdCByZXNvbHZlZE1ldGFkYXRhID0gYXdhaXQgcmVzb2x2ZU1ldGFkYXRhKFxuICAgIHRyZWUsXG4gICAgcGF0aG5hbWUsXG4gICAgc2VhcmNoUGFyYW1zLFxuICAgIGVycm9yQ29udmVudGlvbixcbiAgICBnZXREeW5hbWljUGFyYW1Gcm9tU2VnbWVudCxcbiAgICB3b3JrU3RvcmUsXG4gICAgbWV0YWRhdGFDb250ZXh0XG4gIClcbiAgY29uc3QgZWxlbWVudHM6IEFycmF5PFJlYWN0LlJlYWN0Tm9kZT4gPVxuICAgIGNyZWF0ZU1ldGFkYXRhRWxlbWVudHMocmVzb2x2ZWRNZXRhZGF0YSlcbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAge2VsZW1lbnRzLm1hcCgoZWwsIGluZGV4KSA9PiB7XG4gICAgICAgIHJldHVybiBjbG9uZUVsZW1lbnQoZWwgYXMgUmVhY3QuUmVhY3RFbGVtZW50LCB7IGtleTogaW5kZXggfSlcbiAgICAgIH0pfVxuICAgIDwvPlxuICApXG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlbmRlclZpZXdwb3J0KFxuICB0cmVlOiBMb2FkZXJUcmVlLFxuICBzZWFyY2hQYXJhbXM6IFByb21pc2U8UGFyc2VkVXJsUXVlcnk+LFxuICBnZXREeW5hbWljUGFyYW1Gcm9tU2VnbWVudDogR2V0RHluYW1pY1BhcmFtRnJvbVNlZ21lbnQsXG4gIHdvcmtTdG9yZTogV29ya1N0b3JlLFxuICBlcnJvckNvbnZlbnRpb24/OiBNZXRhZGF0YUVycm9yVHlwZVxuKSB7XG4gIGNvbnN0IHJlc29sdmVkVmlld3BvcnQgPSBhd2FpdCByZXNvbHZlVmlld3BvcnQoXG4gICAgdHJlZSxcbiAgICBzZWFyY2hQYXJhbXMsXG4gICAgZXJyb3JDb252ZW50aW9uLFxuICAgIGdldER5bmFtaWNQYXJhbUZyb21TZWdtZW50LFxuICAgIHdvcmtTdG9yZVxuICApXG5cbiAgY29uc3QgZWxlbWVudHM6IEFycmF5PFJlYWN0LlJlYWN0Tm9kZT4gPVxuICAgIGNyZWF0ZVZpZXdwb3J0RWxlbWVudHMocmVzb2x2ZWRWaWV3cG9ydClcbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAge2VsZW1lbnRzLm1hcCgoZWwsIGluZGV4KSA9PiB7XG4gICAgICAgIHJldHVybiBjbG9uZUVsZW1lbnQoZWwgYXMgUmVhY3QuUmVhY3RFbGVtZW50LCB7IGtleTogaW5kZXggfSlcbiAgICAgIH0pfVxuICAgIDwvPlxuICApXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU1ldGFkYXRhRWxlbWVudHMobWV0YWRhdGE6IFJlc29sdmVkTWV0YWRhdGEpIHtcbiAgcmV0dXJuIE1ldGFGaWx0ZXIoW1xuICAgIEJhc2ljTWV0YSh7IG1ldGFkYXRhIH0pLFxuICAgIEFsdGVybmF0ZXNNZXRhZGF0YSh7IGFsdGVybmF0ZXM6IG1ldGFkYXRhLmFsdGVybmF0ZXMgfSksXG4gICAgSXR1bmVzTWV0YSh7IGl0dW5lczogbWV0YWRhdGEuaXR1bmVzIH0pLFxuICAgIEZhY2Vib29rTWV0YSh7IGZhY2Vib29rOiBtZXRhZGF0YS5mYWNlYm9vayB9KSxcbiAgICBQaW50ZXJlc3RNZXRhKHsgcGludGVyZXN0OiBtZXRhZGF0YS5waW50ZXJlc3QgfSksXG4gICAgRm9ybWF0RGV0ZWN0aW9uTWV0YSh7IGZvcm1hdERldGVjdGlvbjogbWV0YWRhdGEuZm9ybWF0RGV0ZWN0aW9uIH0pLFxuICAgIFZlcmlmaWNhdGlvbk1ldGEoeyB2ZXJpZmljYXRpb246IG1ldGFkYXRhLnZlcmlmaWNhdGlvbiB9KSxcbiAgICBBcHBsZVdlYkFwcE1ldGEoeyBhcHBsZVdlYkFwcDogbWV0YWRhdGEuYXBwbGVXZWJBcHAgfSksXG4gICAgT3BlbkdyYXBoTWV0YWRhdGEoeyBvcGVuR3JhcGg6IG1ldGFkYXRhLm9wZW5HcmFwaCB9KSxcbiAgICBUd2l0dGVyTWV0YWRhdGEoeyB0d2l0dGVyOiBtZXRhZGF0YS50d2l0dGVyIH0pLFxuICAgIEFwcExpbmtzTWV0YSh7IGFwcExpbmtzOiBtZXRhZGF0YS5hcHBMaW5rcyB9KSxcbiAgICBJY29uc01ldGFkYXRhKHsgaWNvbnM6IG1ldGFkYXRhLmljb25zIH0pLFxuICBdKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVWaWV3cG9ydEVsZW1lbnRzKHZpZXdwb3J0OiBSZXNvbHZlZFZpZXdwb3J0KSB7XG4gIHJldHVybiBNZXRhRmlsdGVyKFtWaWV3cG9ydE1ldGEoeyB2aWV3cG9ydDogdmlld3BvcnQgfSldKVxufVxuIl0sIm5hbWVzIjpbIlJlYWN0IiwiU3VzcGVuc2UiLCJjYWNoZSIsImNsb25lRWxlbWVudCIsIkFwcGxlV2ViQXBwTWV0YSIsIkZvcm1hdERldGVjdGlvbk1ldGEiLCJJdHVuZXNNZXRhIiwiQmFzaWNNZXRhIiwiVmlld3BvcnRNZXRhIiwiVmVyaWZpY2F0aW9uTWV0YSIsIkZhY2Vib29rTWV0YSIsIlBpbnRlcmVzdE1ldGEiLCJBbHRlcm5hdGVzTWV0YWRhdGEiLCJPcGVuR3JhcGhNZXRhZGF0YSIsIlR3aXR0ZXJNZXRhZGF0YSIsIkFwcExpbmtzTWV0YSIsIkljb25zTWV0YWRhdGEiLCJyZXNvbHZlTWV0YWRhdGEiLCJyZXNvbHZlVmlld3BvcnQiLCJNZXRhRmlsdGVyIiwiaXNIVFRQQWNjZXNzRmFsbGJhY2tFcnJvciIsIk1FVEFEQVRBX0JPVU5EQVJZX05BTUUiLCJWSUVXUE9SVF9CT1VOREFSWV9OQU1FIiwiQXN5bmNNZXRhZGF0YU91dGxldCIsImlzUG9zdHBvbmUiLCJjcmVhdGVTZXJ2ZXJTZWFyY2hQYXJhbXNGb3JNZXRhZGF0YSIsImNyZWF0ZVNlcnZlclBhdGhuYW1lRm9yTWV0YWRhdGEiLCJjcmVhdGVNZXRhZGF0YUNvbXBvbmVudHMiLCJ0cmVlIiwicGF0aG5hbWUiLCJwYXJzZWRRdWVyeSIsIm1ldGFkYXRhQ29udGV4dCIsImdldER5bmFtaWNQYXJhbUZyb21TZWdtZW50IiwiYXBwVXNpbmdTaXplQWRqdXN0bWVudCIsImVycm9yVHlwZSIsIndvcmtTdG9yZSIsIk1ldGFkYXRhQm91bmRhcnkiLCJWaWV3cG9ydEJvdW5kYXJ5Iiwic2VydmVTdHJlYW1pbmdNZXRhZGF0YSIsInNlYXJjaFBhcmFtcyIsInBhdGhuYW1lRm9yTWV0YWRhdGEiLCJWaWV3cG9ydFRyZWUiLCJWaWV3cG9ydCIsIm1ldGEiLCJuYW1lIiwiY29udGVudCIsIk1ldGFkYXRhVHJlZSIsIk1ldGFkYXRhIiwidmlld3BvcnQiLCJnZXRSZXNvbHZlZFZpZXdwb3J0IiwiZXJyb3IiLCJnZXROb3RGb3VuZFZpZXdwb3J0IiwiZGlzcGxheU5hbWUiLCJtZXRhZGF0YSIsImdldFJlc29sdmVkTWV0YWRhdGEiLCJyZXNvbHZlRmluYWxNZXRhZGF0YSIsInJlc3VsdCIsImRpZ2VzdCIsInVuZGVmaW5lZCIsIm1ldGFkYXRhRXJyIiwiZ2V0Tm90Rm91bmRNZXRhZGF0YSIsIm5vdEZvdW5kTWV0YWRhdGFFcnIiLCJNZXRhZGF0YVJlc29sdmVyIiwiZGl2IiwiaGlkZGVuIiwiZmFsbGJhY2siLCJtZXRhZGF0YVN0YXRlIiwiZ2V0TWV0YWRhdGFSZWFkeSIsImdldFZpZXdwb3J0UmVhZHkiLCJTdHJlYW1pbmdNZXRhZGF0YU91dGxldEltcGwiLCJwcm9taXNlIiwiU3RyZWFtaW5nTWV0YWRhdGFPdXRsZXQiLCJnZXRSZXNvbHZlZE1ldGFkYXRhSW1wbCIsImVycm9yQ29udmVudGlvbiIsInJlbmRlck1ldGFkYXRhIiwiZ2V0Tm90Rm91bmRNZXRhZGF0YUltcGwiLCJub3RGb3VuZEVycm9yQ29udmVudGlvbiIsImdldFJlc29sdmVkVmlld3BvcnRJbXBsIiwicmVuZGVyVmlld3BvcnQiLCJnZXROb3RGb3VuZFZpZXdwb3J0SW1wbCIsInJlc29sdmVkTWV0YWRhdGEiLCJlbGVtZW50cyIsImNyZWF0ZU1ldGFkYXRhRWxlbWVudHMiLCJtYXAiLCJlbCIsImluZGV4Iiwia2V5IiwicmVzb2x2ZWRWaWV3cG9ydCIsImNyZWF0ZVZpZXdwb3J0RWxlbWVudHMiLCJhbHRlcm5hdGVzIiwiaXR1bmVzIiwiZmFjZWJvb2siLCJwaW50ZXJlc3QiLCJmb3JtYXREZXRlY3Rpb24iLCJ2ZXJpZmljYXRpb24iLCJhcHBsZVdlYkFwcCIsIm9wZW5HcmFwaCIsInR3aXR0ZXIiLCJhcHBMaW5rcyIsImljb25zIl0sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBT0EsU0FBU0MsUUFBUSxFQUFFQyxLQUFLLEVBQUVDLFlBQVksUUFBUSxRQUFPO0FBTTVELFNBQ0VDLGVBQWUsRUFDZkMsbUJBQW1CLEVBQ25CQyxVQUFVLEVBQ1ZDLFNBQVMsRUFDVEMsWUFBWSxFQUNaQyxnQkFBZ0IsRUFDaEJDLFlBQVksRUFDWkMsYUFBYSxRQUNSLG1CQUFrQjtBQUN6QixTQUFTQyxrQkFBa0IsUUFBUSx1QkFBc0I7QUFDekQs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QUFXdkMsU0FBU3VDLFNBQVM7UUFBQzt3TEFDOUN2RixzQkFBQUEsRUFBb0I7WUFBRXdGLGlCQUFpQnhDLFNBQVN3QyxlQUFlO1FBQUM7d0xBQ2hFcEYsbUJBQUFBLEVBQWlCO1lBQUVxRixjQUFjekMsU0FBU3lDLFlBQVk7UUFBQzt3TEFDdkQxRixrQkFBQUEsRUFBZ0I7WUFBRTJGLGFBQWExQyxTQUFTMEMsV0FBVztRQUFDOzRMQUNwRGxGLG9CQUFBQSxFQUFrQjtZQUFFbUYsV0FBVzNDLFNBQVMyQyxTQUFTO1FBQUM7UUFDbERsRixzTUFBQUEsRUFBZ0I7WUFBRW1GLFNBQVM1QyxTQUFTNEMsT0FBTztRQUFDOzRMQUM1Q2xGLGVBQUFBLEVBQWE7WUFBRW1GLFVBQVU3QyxTQUFTNkMsUUFBUTtRQUFDO1NBQzNDbEYsK0xBQUFBLEVBQWM7WUFBRW1GLE9BQU85QyxTQUFTOEMsS0FBSztRQUFDO0tBQ3ZDO0FBQ0g7QUFFQSxTQUFTWCx1QkFBdUJ4QyxRQUEwQjtJQUN4RCxzTEFBTzdCLGFBQUFBLEVBQVc7d0xBQUNYLGVBQUFBLEVBQWE7WUFBRXdDLFVBQVVBO1FBQVM7S0FBRztBQUMxRCIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA3MTczLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9lc20vY2xpZW50L2NvbXBvbmVudHMvbWV0YWRhdGEvbWV0YWRhdGEtYm91bmRhcnkuanMvcHJveHkuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHsgY3JlYXRlQ2xpZW50TW9kdWxlUHJveHkgfSA9IHJlcXVpcmUoXCJyZWFjdC1zZXJ2ZXItZG9tLXR1cmJvcGFjay9zZXJ2ZXJcIik7XG5cbl9fdHVyYm9wYWNrX2NvbnRleHRfXy5uKGNyZWF0ZUNsaWVudE1vZHVsZVByb3h5KFwiW3Byb2plY3RdL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvZXNtL2NsaWVudC9jb21wb25lbnRzL21ldGFkYXRhL21ldGFkYXRhLWJvdW5kYXJ5LmpzIDxtb2R1bGUgZXZhbHVhdGlvbj5cIikpO1xuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE1BQU0sRUFBRSx1QkFBdUIsRUFBRTtBQUVqQyxzQkFBc0IsQ0FBQyxDQUFDLHdCQUF3QiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA3MTgwLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9lc20vY2xpZW50L2NvbXBvbmVudHMvbWV0YWRhdGEvbWV0YWRhdGEtYm91bmRhcnkuanMvcHJveHkuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHsgY3JlYXRlQ2xpZW50TW9kdWxlUHJveHkgfSA9IHJlcXVpcmUoXCJyZWFjdC1zZXJ2ZXItZG9tLXR1cmJvcGFjay9zZXJ2ZXJcIik7XG5cbl9fdHVyYm9wYWNrX2NvbnRleHRfXy5uKGNyZWF0ZUNsaWVudE1vZHVsZVByb3h5KFwiW3Byb2plY3RdL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvZXNtL2NsaWVudC9jb21wb25lbnRzL21ldGFkYXRhL21ldGFkYXRhLWJvdW5kYXJ5LmpzXCIpKTtcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxNQUFNLEVBQUUsdUJBQXVCLEVBQUU7QUFFakMsc0JBQXNCLENBQUMsQ0FBQyx3QkFBd0IiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNzE4NiwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL2NsaWVudC9jb21wb25lbnRzL21ldGFkYXRhL21ldGFkYXRhLWJvdW5kYXJ5LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuaW1wb3J0IHtcbiAgTUVUQURBVEFfQk9VTkRBUllfTkFNRSxcbiAgVklFV1BPUlRfQk9VTkRBUllfTkFNRSxcbiAgT1VUTEVUX0JPVU5EQVJZX05BTUUsXG59IGZyb20gJy4uLy4uLy4uL2xpYi9tZXRhZGF0YS9tZXRhZGF0YS1jb25zdGFudHMnXG5cbi8vIFdlIHVzZSBhIG5hbWVzcGFjZSBvYmplY3QgdG8gYWxsb3cgdXMgdG8gcmVjb3ZlciB0aGUgbmFtZSBvZiB0aGUgZnVuY3Rpb25cbi8vIGF0IHJ1bnRpbWUgZXZlbiB3aGVuIHByb2R1Y3Rpb24gYnVuZGxpbmcvbWluaWZpY2F0aW9uIGlzIHVzZWQuXG5jb25zdCBOYW1lU3BhY2UgPSB7XG4gIFtNRVRBREFUQV9CT1VOREFSWV9OQU1FXTogZnVuY3Rpb24gKHtcbiAgICBjaGlsZHJlbixcbiAgfToge1xuICAgIGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGVcbiAgfSkge1xuICAgIHJldHVybiBjaGlsZHJlblxuICB9LFxuICBbVklFV1BPUlRfQk9VTkRBUllfTkFNRV06IGZ1bmN0aW9uICh7XG4gICAgY2hpbGRyZW4sXG4gIH06IHtcbiAgICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlXG4gIH0pIHtcbiAgICByZXR1cm4gY2hpbGRyZW5cbiAgfSxcbiAgW09VVExFVF9CT1VOREFSWV9OQU1FXTogZnVuY3Rpb24gKHtcbiAgICBjaGlsZHJlbixcbiAgfToge1xuICAgIGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGVcbiAgfSkge1xuICAgIHJldHVybiBjaGlsZHJlblxuICB9LFxufVxuXG5leHBvcnQgY29uc3QgTWV0YWRhdGFCb3VuZGFyeSA9XG4gIC8vIFdlIHVzZSBzbGljZSgwKSB0byB0cmljayB0aGUgYnVuZGxlciBpbnRvIG5vdCBpbmxpbmluZy9taW5pZnlpbmcgdGhlIGZ1bmN0aW9uXG4gIC8vIHNvIGl0IHJldGFpbnMgdGhlIG5hbWUgaW5mZXJyZWQgZnJvbSB0aGUgbmFtZXNwYWNlIG9iamVjdFxuICBOYW1lU3BhY2VbTUVUQURBVEFfQk9VTkRBUllfTkFNRS5zbGljZSgwKSBhcyB0eXBlb2YgTUVUQURBVEFfQk9VTkRBUllfTkFNRV1cblxuZXhwb3J0IGNvbnN0IFZpZXdwb3J0Qm91bmRhcnkgPVxuICAvLyBXZSB1c2Ugc2xpY2UoMCkgdG8gdHJpY2sgdGhlIGJ1bmRsZXIgaW50byBub3QgaW5saW5pbmcvbWluaWZ5aW5nIHRoZSBmdW5jdGlvblxuICAvLyBzbyBpdCByZXRhaW5zIHRoZSBuYW1lIGluZmVycmVkIGZyb20gdGhlIG5hbWVzcGFjZSBvYmplY3RcbiAgTmFtZVNwYWNlW1ZJRVdQT1JUX0JPVU5EQVJZX05BTUUuc2xpY2UoMCkgYXMgdHlwZW9mIFZJRVdQT1JUX0JPVU5EQVJZX05BTUVdXG5cbmV4cG9ydCBjb25zdCBPdXRsZXRCb3VuZGFyeSA9XG4gIC8vIFdlIHVzZSBzbGljZSgwKSB0byB0cmljayB0aGUgYnVuZGxlciBpbnRvIG5vdCBpbmxpbmluZy9taW5pZnlpbmcgdGhlIGZ1bmN0aW9uXG4gIC8vIHNvIGl0IHJldGFpbnMgdGhlIG5hbWUgaW5mZXJyZWQgZnJvbSB0aGUgbmFtZXNwYWNlIG9iamVjdFxuICBOYW1lU3BhY2VbT1VUTEVUX0JPVU5EQVJZX05BTUUuc2xpY2UoMCkgYXMgdHlwZW9mIE9VVExFVF9CT1VOREFSWV9OQU1FXVxuIl0sIm5hbWVzIjpbIk1FVEFEQVRBX0JPVU5EQVJZX05BTUUiLCJWSUVXUE9SVF9CT1VOREFSWV9OQU1FIiwiT1VUTEVUX0JPVU5EQVJZX05BTUUiLCJOYW1lU3BhY2UiLCJjaGlsZHJlbiIsIk1ldGFkYXRhQm91bmRhcnkiLCJzbGljZSIsIlZpZXdwb3J0Qm91bmRhcnkiLCJPdXRsZXRCb3VuZGFyeSJdLCJtYXBwaW5ncyI6IiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA3MTk2LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL3NlcnZlci9yb3V0ZS1tb2R1bGVzL2FwcC1wYWdlL3ZlbmRvcmVkL3JzYy9yZWFjdC1kb20udHMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSAoXG4gIHJlcXVpcmUoJy4uLy4uL21vZHVsZS5jb21waWxlZCcpIGFzIHR5cGVvZiBpbXBvcnQoJy4uLy4uL21vZHVsZS5jb21waWxlZCcpXG4pLnZlbmRvcmVkWydyZWFjdC1yc2MnXSEuUmVhY3RET01cbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSIsInZlbmRvcmVkIiwiUmVhY3RET00iXSwibWFwcGluZ3MiOiJBQUFBQSxPQUFPQyxPQUFPLEdBQ1pDLFFBQVEsNEhBQ1JDLFFBQVEsQ0FBQyxZQUFZLENBQUVDLFFBQVEiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNzIwMSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL3NlcnZlci9hcHAtcmVuZGVyL3JzYy9wcmVsb2Fkcy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuXG5GaWxlcyBpbiB0aGUgcnNjIGRpcmVjdG9yeSBhcmUgbWVhbnQgdG8gYmUgcGFja2FnZWQgYXMgcGFydCBvZiB0aGUgUlNDIGdyYXBoIHVzaW5nIG5leHQtYXBwLWxvYWRlci5cblxuKi9cblxuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSdcblxuZXhwb3J0IGZ1bmN0aW9uIHByZWxvYWRTdHlsZShcbiAgaHJlZjogc3RyaW5nLFxuICBjcm9zc09yaWdpbjogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICBub25jZTogc3RyaW5nIHwgdW5kZWZpbmVkXG4pIHtcbiAgY29uc3Qgb3B0czogYW55ID0geyBhczogJ3N0eWxlJyB9XG4gIGlmICh0eXBlb2YgY3Jvc3NPcmlnaW4gPT09ICdzdHJpbmcnKSB7XG4gICAgb3B0cy5jcm9zc09yaWdpbiA9IGNyb3NzT3JpZ2luXG4gIH1cbiAgaWYgKHR5cGVvZiBub25jZSA9PT0gJ3N0cmluZycpIHtcbiAgICBvcHRzLm5vbmNlID0gbm9uY2VcbiAgfVxuICBSZWFjdERPTS5wcmVsb2FkKGhyZWYsIG9wdHMpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcmVsb2FkRm9udChcbiAgaHJlZjogc3RyaW5nLFxuICB0eXBlOiBzdHJpbmcsXG4gIGNyb3NzT3JpZ2luOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gIG5vbmNlOiBzdHJpbmcgfCB1bmRlZmluZWRcbikge1xuICBjb25zdCBvcHRzOiBhbnkgPSB7IGFzOiAnZm9udCcsIHR5cGUgfVxuICBpZiAodHlwZW9mIGNyb3NzT3JpZ2luID09PSAnc3RyaW5nJykge1xuICAgIG9wdHMuY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpblxuICB9XG4gIGlmICh0eXBlb2Ygbm9uY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgb3B0cy5ub25jZSA9IG5vbmNlXG4gIH1cbiAgUmVhY3RET00ucHJlbG9hZChocmVmLCBvcHRzKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJlY29ubmVjdChcbiAgaHJlZjogc3RyaW5nLFxuICBjcm9zc09yaWdpbjogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICBub25jZTogc3RyaW5nIHwgdW5kZWZpbmVkXG4pIHtcbiAgY29uc3Qgb3B0czogYW55ID0ge31cbiAgaWYgKHR5cGVvZiBjcm9zc09yaWdpbiA9PT0gJ3N0cmluZycpIHtcbiAgICBvcHRzLmNyb3NzT3JpZ2luID0gY3Jvc3NPcmlnaW5cbiAgfVxuICBpZiAodHlwZW9mIG5vbmNlID09PSAnc3RyaW5nJykge1xuICAgIG9wdHMubm9uY2UgPSBub25jZVxuICB9XG4gIDsoUmVhY3RET00gYXMgYW55KS5wcmVjb25uZWN0KGhyZWYsIG9wdHMpXG59XG4iXSwibmFtZXMiOlsiUmVhY3RET00iLCJwcmVsb2FkU3R5bGUiLCJocmVmIiwiY3Jvc3NPcmlnaW4iLCJub25jZSIsIm9wdHMiLCJhcyIsInByZWxvYWQiLCJwcmVsb2FkRm9udCIsInR5cGUiLCJwcmVjb25uZWN0Il0sIm1hcHBpbmdzIjoiQUFBQTs7OztBQUlBOzs7OztBQUVBLE9BQU9BLGNBQWMsWUFBVzs7QUFFekIsU0FBU0MsYUFDZEMsSUFBWSxFQUNaQyxXQUErQixFQUMvQkMsS0FBeUI7SUFFekIsTUFBTUMsT0FBWTtRQUFFQyxJQUFJO0lBQVE7SUFDaEMsSUFBSSxPQUFPSCxnQkFBZ0IsVUFBVTtRQUNuQ0UsS0FBS0YsV0FBVyxHQUFHQTtJQUNyQjtJQUNBLElBQUksT0FBT0MsVUFBVSxVQUFVO1FBQzdCQyxLQUFLRCxLQUFLLEdBQUdBO0lBQ2Y7aU5BQ0FKLFVBQUFBLENBQVNPLE9BQU8sQ0FBQ0wsTUFBTUc7QUFDekI7QUFFTyxTQUFTRyxZQUNkTixJQUFZLEVBQ1pPLElBQVksRUFDWk4sV0FBK0IsRUFDL0JDLEtBQXlCO0lBRXpCLE1BQU1DLE9BQVk7UUFBRUMsSUFBSTtRQUFRRztJQUFLO0lBQ3JDLElBQUksT0FBT04sZ0JBQWdCLFVBQVU7UUFDbkNFLEtBQUtGLFdBQVcsR0FBR0E7SUFDckI7SUFDQSxJQUFJLE9BQU9DLFVBQVUsVUFBVTtRQUM3QkMsS0FBS0QsS0FBSyxHQUFHQTtJQUNmO2lOQUNBSixVQUFBQSxDQUFTTyxPQUFPLENBQUNMLE1BQU1HO0FBQ3pCO0FBRU8sU0FBU0ssV0FDZFIsSUFBWSxFQUNaQyxXQUErQixFQUMvQkMsS0FBeUI7SUFFekIsTUFBTUMsT0FBWSxDQUFDO0lBQ25CLElBQUksT0FBT0YsZ0JBQWdCLFVBQVU7UUFDbkNFLEtBQUtGLFdBQVcsR0FBR0E7SUFDckI7SUFDQSxJQUFJLE9BQU9DLFVBQVUsVUFBVTtRQUM3QkMsS0FBS0QsS0FBSyxHQUFHQTtJQUNmOztpTkFDRUosVUFBQUEsQ0FBaUJVLFVBQVUsQ0FBQ1IsTUFBTUc7QUFDdEMiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNzI1MiwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL3NlcnZlci9hcHAtcmVuZGVyL3JzYy9wb3N0cG9uZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuXG5GaWxlcyBpbiB0aGUgcnNjIGRpcmVjdG9yeSBhcmUgbWVhbnQgdG8gYmUgcGFja2FnZWQgYXMgcGFydCBvZiB0aGUgUlNDIGdyYXBoIHVzaW5nIG5leHQtYXBwLWxvYWRlci5cblxuKi9cblxuLy8gV2hlbiBwb3N0cG9uZSBpcyBhdmFpbGFibGUgaW4gY2FuYXJ5IFJlYWN0IHdlIGNhbiBzd2l0Y2ggdG8gaW1wb3J0aW5nIGl0IGRpcmVjdGx5XG5leHBvcnQgeyBQb3N0cG9uZSB9IGZyb20gJy4uL2R5bmFtaWMtcmVuZGVyaW5nJ1xuIl0sIm5hbWVzIjpbIlBvc3Rwb25lIl0sIm1hcHBpbmdzIjoiQUFBQTs7OztBQUlBLEdBRUEsb0ZBQW9GOztBQUNwRixTQUFTQSxRQUFRLFFBQVEsdUJBQXNCIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDcyNzEsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NyYy9zZXJ2ZXIvYXBwLXJlbmRlci9yc2MvdGFpbnQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcblxuRmlsZXMgaW4gdGhlIHJzYyBkaXJlY3RvcnkgYXJlIG1lYW50IHRvIGJlIHBhY2thZ2VkIGFzIHBhcnQgb2YgdGhlIFJTQyBncmFwaCB1c2luZyBuZXh0LWFwcC1sb2FkZXIuXG5cbiovXG5cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0J1xuXG50eXBlIFJlZmVyZW5jZSA9IG9iamVjdFxudHlwZSBUYWludGFibGVVbmlxdWVWYWx1ZSA9IHN0cmluZyB8IGJpZ2ludCB8IEFycmF5QnVmZmVyVmlld1xuXG5mdW5jdGlvbiBub3RJbXBsZW1lbnRlZCgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdUYWludCBjYW4gb25seSBiZSB1c2VkIHdpdGggdGhlIHRhaW50IGZsYWcuJylcbn1cblxuZXhwb3J0IGNvbnN0IHRhaW50T2JqZWN0UmVmZXJlbmNlOiAoXG4gIG1lc3NhZ2U6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgb2JqZWN0OiBSZWZlcmVuY2VcbikgPT4gdm9pZCA9IHByb2Nlc3MuZW52Ll9fTkVYVF9FWFBFUklNRU5UQUxfUkVBQ1RcbiAgPyAvLyBAdHMtaWdub3JlXG4gICAgUmVhY3QuZXhwZXJpbWVudGFsX3RhaW50T2JqZWN0UmVmZXJlbmNlXG4gIDogbm90SW1wbGVtZW50ZWRcbmV4cG9ydCBjb25zdCB0YWludFVuaXF1ZVZhbHVlOiAoXG4gIG1lc3NhZ2U6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgbGlmZXRpbWU6IFJlZmVyZW5jZSxcbiAgdmFsdWU6IFRhaW50YWJsZVVuaXF1ZVZhbHVlXG4pID0+IHZvaWQgPSBwcm9jZXNzLmVudi5fX05FWFRfRVhQRVJJTUVOVEFMX1JFQUNUXG4gID8gLy8gQHRzLWlnbm9yZVxuICAgIFJlYWN0LmV4cGVyaW1lbnRhbF90YWludFVuaXF1ZVZhbHVlXG4gIDogbm90SW1wbGVtZW50ZWRcbiJdLCJuYW1lcyI6WyJSZWFjdCIsIm5vdEltcGxlbWVudGVkIiwiRXJyb3IiLCJ0YWludE9iamVjdFJlZmVyZW5jZSIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfRVhQRVJJTUVOVEFMX1JFQUNUIiwiZXhwZXJpbWVudGFsX3RhaW50T2JqZWN0UmVmZXJlbmNlIiwidGFpbnRVbmlxdWVWYWx1ZSIsImV4cGVyaW1lbnRhbF90YWludFVuaXF1ZVZhbHVlIl0sIm1hcHBpbmdzIjoiQUFBQTs7OztBQUlBOzs7O0FBRUEsWUFBWUEsV0FBVyxRQUFPOztBQUs5QixTQUFTQztJQUNQLE1BQU0sT0FBQSxjQUF3RCxDQUF4RCxJQUFJQyxNQUFNLGdEQUFWLHFCQUFBO2VBQUE7b0JBQUE7c0JBQUE7SUFBdUQ7QUFDL0Q7QUFFTyxNQUFNQyx1QkFHREMsUUFBUUMsR0FBRyxDQUFDQyx5QkFBeUIsQ0FFN0NOLE1BQU1PLG9CQUNOTixhQUR1QyxFQUN6QjtBQUNYLE1BQU1PLG1CQUlESixRQUFRQyxHQUFHLENBQUNDLHlCQUF5QixDQUU3Q04sTUFBTVMsb0JBQ05SLFNBRG1DLE1BQ3JCIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDcyOTYsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LXNlcnZlci1kb20tdHVyYm9wYWNrL2Nqcy9yZWFjdC1zZXJ2ZXItZG9tLXR1cmJvcGFjay1jbGllbnQubm9kZS5kZXZlbG9wbWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1zZXJ2ZXItZG9tLXR1cmJvcGFjay1jbGllbnQubm9kZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgJiZcbiAgKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiByZXNvbHZlQ2xpZW50UmVmZXJlbmNlKGJ1bmRsZXJDb25maWcsIG1ldGFkYXRhKSB7XG4gICAgICBpZiAoYnVuZGxlckNvbmZpZykge1xuICAgICAgICB2YXIgbW9kdWxlRXhwb3J0cyA9IGJ1bmRsZXJDb25maWdbbWV0YWRhdGFbMF1dO1xuICAgICAgICBpZiAoKGJ1bmRsZXJDb25maWcgPSBtb2R1bGVFeHBvcnRzICYmIG1vZHVsZUV4cG9ydHNbbWV0YWRhdGFbMl1dKSlcbiAgICAgICAgICBtb2R1bGVFeHBvcnRzID0gYnVuZGxlckNvbmZpZy5uYW1lO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBidW5kbGVyQ29uZmlnID0gbW9kdWxlRXhwb3J0cyAmJiBtb2R1bGVFeHBvcnRzW1wiKlwiXTtcbiAgICAgICAgICBpZiAoIWJ1bmRsZXJDb25maWcpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgJ0NvdWxkIG5vdCBmaW5kIHRoZSBtb2R1bGUgXCInICtcbiAgICAgICAgICAgICAgICBtZXRhZGF0YVswXSArXG4gICAgICAgICAgICAgICAgJ1wiIGluIHRoZSBSZWFjdCBTZXJ2ZXIgQ29uc3VtZXIgTWFuaWZlc3QuIFRoaXMgaXMgcHJvYmFibHkgYSBidWcgaW4gdGhlIFJlYWN0IFNlcnZlciBDb21wb25lbnRzIGJ1bmRsZXIuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICBtb2R1bGVFeHBvcnRzID0gbWV0YWRhdGFbMl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDQgPT09IG1ldGFkYXRhLmxlbmd0aFxuICAgICAgICAgID8gW2J1bmRsZXJDb25maWcuaWQsIGJ1bmRsZXJDb25maWcuY2h1bmtzLCBtb2R1bGVFeHBvcnRzLCAxXVxuICAgICAgICAgIDogW2J1bmRsZXJDb25maWcuaWQsIGJ1bmRsZXJDb25maWcuY2h1bmtzLCBtb2R1bGVFeHBvcnRzXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZXRhZGF0YTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzb2x2ZVNlcnZlclJlZmVyZW5jZShidW5kbGVyQ29uZmlnLCBpZCkge1xuICAgICAgdmFyIG5hbWUgPSBcIlwiLFxuICAgICAgICByZXNvbHZlZE1vZHVsZURhdGEgPSBidW5kbGVyQ29uZmlnW2lkXTtcbiAgICAgIGlmIChyZXNvbHZlZE1vZHVsZURhdGEpIG5hbWUgPSByZXNvbHZlZE1vZHVsZURhdGEubmFtZTtcbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgaWR4ID0gaWQubGFzdEluZGV4T2YoXCIjXCIpO1xuICAgICAgICAtMSAhPT0gaWR4ICYmXG4gICAgICAgICAgKChuYW1lID0gaWQuc2xpY2UoaWR4ICsgMSkpLFxuICAgICAgICAgIChyZXNvbHZlZE1vZHVsZURhdGEgPSBidW5kbGVyQ29uZmlnW2lkLnNsaWNlKDAsIGlkeCldKSk7XG4gICAgICAgIGlmICghcmVzb2x2ZWRNb2R1bGVEYXRhKVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgJ0NvdWxkIG5vdCBmaW5kIHRoZSBtb2R1bGUgXCInICtcbiAgICAgICAgICAgICAgaWQgK1xuICAgICAgICAgICAgICAnXCIgaW4gdGhlIFJlYWN0IFNlcnZlciBNYW5pZmVzdC4gVGhpcyBpcyBwcm9iYWJseSBhIGJ1ZyBpbiB0aGUgUmVhY3QgU2VydmVyIENvbXBvbmVudHMgYnVuZGxlci4nXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbcmVzb2x2ZWRNb2R1bGVEYXRhLmlkLCByZXNvbHZlZE1vZHVsZURhdGEuY2h1bmtzLCBuYW1lXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVxdWlyZUFzeW5jTW9kdWxlKGlkKSB7XG4gICAgICB2YXIgcHJvbWlzZSA9IGdsb2JhbFRoaXMuX19uZXh0X3JlcXVpcmVfXyhpZCk7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgcHJvbWlzZS50aGVuIHx8IFwiZnVsZmlsbGVkXCIgPT09IHByb21pc2Uuc3RhdHVzKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIHByb21pc2UudGhlbihcbiAgICAgICAgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgcHJvbWlzZS5zdGF0dXMgPSBcImZ1bGZpbGxlZFwiO1xuICAgICAgICAgIHByb21pc2UudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgIHByb21pc2Uuc3RhdHVzID0gXCJyZWplY3RlZFwiO1xuICAgICAgICAgIHByb21pc2UucmVhc29uID0gcmVhc29uO1xuICAgICAgICB9XG4gICAgICApO1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlnbm9yZVJlamVjdCgpIHt9XG4gICAgZnVuY3Rpb24gcHJlbG9hZE1vZHVsZShtZXRhZGF0YSkge1xuICAgICAgZm9yIChcbiAgICAgICAgdmFyIGNodW5rcyA9IG1ldGFkYXRhWzFdLCBwcm9taXNlcyA9IFtdLCBpID0gMDtcbiAgICAgICAgaSA8IGNodW5rcy5sZW5ndGg7XG4gICAgICAgIGkrK1xuICAgICAgKSB7XG4gICAgICAgIHZhciBjaHVua0ZpbGVuYW1lID0gY2h1bmtzW2ldLFxuICAgICAgICAgIGVudHJ5ID0gY2h1bmtDYWNoZS5nZXQoY2h1bmtGaWxlbmFtZSk7XG4gICAgICAgIGlmICh2b2lkIDAgPT09IGVudHJ5KSB7XG4gICAgICAgICAgZW50cnkgPSBnbG9iYWxUaGlzLl9fbmV4dF9jaHVua19sb2FkX18oY2h1bmtGaWxlbmFtZSk7XG4gICAgICAgICAgcHJvbWlzZXMucHVzaChlbnRyeSk7XG4gICAgICAgICAgdmFyIHJlc29sdmUgPSBjaHVua0NhY2hlLnNldC5iaW5kKGNodW5rQ2FjaGUsIGNodW5rRmlsZW5hbWUsIG51bGwpO1xuICAgICAgICAgIGVudHJ5LnRoZW4ocmVzb2x2ZSwgaWdub3JlUmVqZWN0KTtcbiAgICAgICAgICBjaHVua0NhY2hlLnNldChjaHVua0ZpbGVuYW1lLCBlbnRyeSk7XG4gICAgICAgIH0gZWxzZSBudWxsICE9PSBlbnRyeSAmJiBwcm9taXNlcy5wdXNoKGVudHJ5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiA0ID09PSBtZXRhZGF0YS5sZW5ndGhcbiAgICAgICAgPyAwID09PSBwcm9taXNlcy5sZW5ndGhcbiAgICAgICAgICA/IHJlcXVpcmVBc3luY01vZHVsZShtZXRhZGF0YVswXSlcbiAgICAgICAgICA6IFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlcXVpcmVBc3luY01vZHVsZShtZXRhZGF0YVswXSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICA6IDAgPCBwcm9taXNlcy5sZW5ndGhcbiAgICAgICAgICA/IFByb21pc2UuYWxsKHByb21pc2VzKVxuICAgICAgICAgIDogbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVxdWlyZU1vZHVsZShtZXRhZGF0YSkge1xuICAgICAgdmFyIG1vZHVsZUV4cG9ydHMgPSBnbG9iYWxUaGlzLl9fbmV4dF9yZXF1aXJlX18obWV0YWRhdGFbMF0pO1xuICAgICAgaWYgKDQgPT09IG1ldGFkYXRhLmxlbmd0aCAmJiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBtb2R1bGVFeHBvcnRzLnRoZW4pXG4gICAgICAgIGlmIChcImZ1bGZpbGxlZFwiID09PSBtb2R1bGVFeHBvcnRzLnN0YXR1cylcbiAgICAgICAgICBtb2R1bGVFeHBvcnRzID0gbW9kdWxlRXhwb3J0cy52YWx1ZTtcbiAgICAgICAgZWxzZSB0aHJvdyBtb2R1bGVFeHBvcnRzLnJlYXNvbjtcbiAgICAgIHJldHVybiBcIipcIiA9PT0gbWV0YWRhdGFbMl1cbiAgICAgICAgPyBtb2R1bGVFeHBvcnRzXG4gICAgICAgIDogXCJcIiA9PT0gbWV0YWRhdGFbMl1cbiAgICAgICAgICA/IG1vZHVsZUV4cG9ydHMuX19lc01vZHVsZVxuICAgICAgICAgICAgPyBtb2R1bGVFeHBvcnRzLmRlZmF1bHRcbiAgICAgICAgICAgIDogbW9kdWxlRXhwb3J0c1xuICAgICAgICAgIDogbW9kdWxlRXhwb3J0c1ttZXRhZGF0YVsyXV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByZXBhcmVEZXN0aW5hdGlvbldpdGhDaHVua3MoXG4gICAgICBtb2R1bGVMb2FkaW5nLFxuICAgICAgY2h1bmtzLFxuICAgICAgbm9uY2UkanNjb21wJDBcbiAgICApIHtcbiAgICAgIGlmIChudWxsICE9PSBtb2R1bGVMb2FkaW5nKVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNodW5rcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBub25jZSA9IG5vbmNlJGpzY29tcCQwLFxuICAgICAgICAgICAgSlNDb21waWxlcl90ZW1wX2NvbnN0ID0gUmVhY3RET01TaGFyZWRJbnRlcm5hbHMuZCxcbiAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcF9jb25zdCRqc2NvbXAkMCA9IEpTQ29tcGlsZXJfdGVtcF9jb25zdC5YLFxuICAgICAgICAgICAgSlNDb21waWxlcl90ZW1wX2NvbnN0JGpzY29tcCQxID0gbW9kdWxlTG9hZGluZy5wcmVmaXggKyBjaHVua3NbaV07XG4gICAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IG1vZHVsZUxvYWRpbmcuY3Jvc3NPcmlnaW47XG4gICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID1cbiAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHRcbiAgICAgICAgICAgICAgPyBcInVzZS1jcmVkZW50aWFsc1wiID09PSBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHRcbiAgICAgICAgICAgICAgICA/IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdFxuICAgICAgICAgICAgICAgIDogXCJcIlxuICAgICAgICAgICAgICA6IHZvaWQgMDtcbiAgICAgICAgICBKU0NvbXBpbGVyX3RlbXBfY29uc3QkanNjb21wJDAuY2FsbChcbiAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcF9jb25zdCxcbiAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcF9jb25zdCRqc2NvbXAkMSxcbiAgICAgICAgICAgIHsgY3Jvc3NPcmlnaW46IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCwgbm9uY2U6IG5vbmNlIH1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICAgICAgaWYgKG51bGwgPT09IG1heWJlSXRlcmFibGUgfHwgXCJvYmplY3RcIiAhPT0gdHlwZW9mIG1heWJlSXRlcmFibGUpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgbWF5YmVJdGVyYWJsZSA9XG4gICAgICAgIChNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdKSB8fFxuICAgICAgICBtYXliZUl0ZXJhYmxlW1wiQEBpdGVyYXRvclwiXTtcbiAgICAgIHJldHVybiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBtYXliZUl0ZXJhYmxlID8gbWF5YmVJdGVyYWJsZSA6IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzT2JqZWN0UHJvdG90eXBlKG9iamVjdCkge1xuICAgICAgaWYgKCFvYmplY3QpIHJldHVybiAhMTtcbiAgICAgIHZhciBPYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xuICAgICAgaWYgKG9iamVjdCA9PT0gT2JqZWN0UHJvdG90eXBlKSByZXR1cm4gITA7XG4gICAgICBpZiAoZ2V0UHJvdG90eXBlT2Yob2JqZWN0KSkgcmV0dXJuICExO1xuICAgICAgb2JqZWN0ID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqZWN0KTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoIShvYmplY3RbaV0gaW4gT2JqZWN0UHJvdG90eXBlKSkgcmV0dXJuICExO1xuICAgICAgcmV0dXJuICEwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1NpbXBsZU9iamVjdChvYmplY3QpIHtcbiAgICAgIGlmICghaXNPYmplY3RQcm90b3R5cGUoZ2V0UHJvdG90eXBlT2Yob2JqZWN0KSkpIHJldHVybiAhMTtcbiAgICAgIGZvciAoXG4gICAgICAgIHZhciBuYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iamVjdCksIGkgPSAwO1xuICAgICAgICBpIDwgbmFtZXMubGVuZ3RoO1xuICAgICAgICBpKytcbiAgICAgICkge1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBuYW1lc1tpXSk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhZGVzY3JpcHRvciB8fFxuICAgICAgICAgICghZGVzY3JpcHRvci5lbnVtZXJhYmxlICYmXG4gICAgICAgICAgICAoKFwia2V5XCIgIT09IG5hbWVzW2ldICYmIFwicmVmXCIgIT09IG5hbWVzW2ldKSB8fFxuICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBkZXNjcmlwdG9yLmdldCkpXG4gICAgICAgIClcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gITA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9iamVjdE5hbWUob2JqZWN0KSB7XG4gICAgICBvYmplY3QgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KTtcbiAgICAgIHJldHVybiBvYmplY3Quc2xpY2UoOCwgb2JqZWN0Lmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZUtleUZvckVycm9yTWVzc2FnZShrZXkpIHtcbiAgICAgIHZhciBlbmNvZGVkS2V5ID0gSlNPTi5zdHJpbmdpZnkoa2V5KTtcbiAgICAgIHJldHVybiAnXCInICsga2V5ICsgJ1wiJyA9PT0gZW5jb2RlZEtleSA/IGtleSA6IGVuY29kZWRLZXk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlVmFsdWVGb3JFcnJvck1lc3NhZ2UodmFsdWUpIHtcbiAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAxMCA+PSB2YWx1ZS5sZW5ndGggPyB2YWx1ZSA6IHZhbHVlLnNsaWNlKDAsIDEwKSArIFwiLi4uXCJcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgaWYgKGlzQXJyYXlJbXBsKHZhbHVlKSkgcmV0dXJuIFwiWy4uLl1cIjtcbiAgICAgICAgICBpZiAobnVsbCAhPT0gdmFsdWUgJiYgdmFsdWUuJCR0eXBlb2YgPT09IENMSUVOVF9SRUZFUkVOQ0VfVEFHKVxuICAgICAgICAgICAgcmV0dXJuIFwiY2xpZW50XCI7XG4gICAgICAgICAgdmFsdWUgPSBvYmplY3ROYW1lKHZhbHVlKTtcbiAgICAgICAgICByZXR1cm4gXCJPYmplY3RcIiA9PT0gdmFsdWUgPyBcInsuLi59XCIgOiB2YWx1ZTtcbiAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgcmV0dXJuIHZhbHVlLiQkdHlwZW9mID09PSBDTElFTlRfUkVGRVJFTkNFX1RBR1xuICAgICAgICAgICAgPyBcImNsaWVudFwiXG4gICAgICAgICAgICA6ICh2YWx1ZSA9IHZhbHVlLmRpc3BsYXlOYW1lIHx8IHZhbHVlLm5hbWUpXG4gICAgICAgICAgICAgID8gXCJmdW5jdGlvbiBcIiArIHZhbHVlXG4gICAgICAgICAgICAgIDogXCJmdW5jdGlvblwiO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZUVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZSkgcmV0dXJuIHR5cGU7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlTGlzdFwiO1xuICAgICAgfVxuICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVFbGVtZW50VHlwZSh0eXBlLnJlbmRlcik7XG4gICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVFbGVtZW50VHlwZSh0eXBlLnR5cGUpO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgdmFyIHBheWxvYWQgPSB0eXBlLl9wYXlsb2FkO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVFbGVtZW50VHlwZSh0eXBlKHBheWxvYWQpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZU9iamVjdEZvckVycm9yTWVzc2FnZShvYmplY3RPckFycmF5LCBleHBhbmRlZE5hbWUpIHtcbiAgICAgIHZhciBvYmpLaW5kID0gb2JqZWN0TmFtZShvYmplY3RPckFycmF5KTtcbiAgICAgIGlmIChcIk9iamVjdFwiICE9PSBvYmpLaW5kICYmIFwiQXJyYXlcIiAhPT0gb2JqS2luZCkgcmV0dXJuIG9iaktpbmQ7XG4gICAgICB2YXIgc3RhcnQgPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gMDtcbiAgICAgIGlmIChpc0FycmF5SW1wbChvYmplY3RPckFycmF5KSlcbiAgICAgICAgaWYgKGpzeENoaWxkcmVuUGFyZW50cy5oYXMob2JqZWN0T3JBcnJheSkpIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IGpzeENoaWxkcmVuUGFyZW50cy5nZXQob2JqZWN0T3JBcnJheSk7XG4gICAgICAgICAgb2JqS2luZCA9IFwiPFwiICsgZGVzY3JpYmVFbGVtZW50VHlwZSh0eXBlKSArIFwiPlwiO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0T3JBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gb2JqZWN0T3JBcnJheVtpXTtcbiAgICAgICAgICAgIHZhbHVlID1cbiAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHZhbHVlXG4gICAgICAgICAgICAgICAgPyB2YWx1ZVxuICAgICAgICAgICAgICAgIDogXCJvYmplY3RcIiA9PT0gdHlwZW9mIHZhbHVlICYmIG51bGwgIT09IHZhbHVlXG4gICAgICAgICAgICAgICAgICA/IFwie1wiICsgZGVzY3JpYmVPYmplY3RGb3JFcnJvck1lc3NhZ2UodmFsdWUpICsgXCJ9XCJcbiAgICAgICAgICAgICAgICAgIDogXCJ7XCIgKyBkZXNjcmliZVZhbHVlRm9yRXJyb3JNZXNzYWdlKHZhbHVlKSArIFwifVwiO1xuICAgICAgICAgICAgXCJcIiArIGkgPT09IGV4cGFuZGVkTmFtZVxuICAgICAgICAgICAgICA/ICgoc3RhcnQgPSBvYmpLaW5kLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgKGxlbmd0aCA9IHZhbHVlLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgKG9iaktpbmQgKz0gdmFsdWUpKVxuICAgICAgICAgICAgICA6IChvYmpLaW5kID1cbiAgICAgICAgICAgICAgICAgIDE1ID4gdmFsdWUubGVuZ3RoICYmIDQwID4gb2JqS2luZC5sZW5ndGggKyB2YWx1ZS5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgPyBvYmpLaW5kICsgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgOiBvYmpLaW5kICsgXCJ7Li4ufVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb2JqS2luZCArPSBcIjwvXCIgKyBkZXNjcmliZUVsZW1lbnRUeXBlKHR5cGUpICsgXCI+XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2JqS2luZCA9IFwiW1wiO1xuICAgICAgICAgIGZvciAodHlwZSA9IDA7IHR5cGUgPCBvYmplY3RPckFycmF5Lmxlbmd0aDsgdHlwZSsrKVxuICAgICAgICAgICAgMCA8IHR5cGUgJiYgKG9iaktpbmQgKz0gXCIsIFwiKSxcbiAgICAgICAgICAgICAgKGkgPSBvYmplY3RPckFycmF5W3R5cGVdKSxcbiAgICAgICAgICAgICAgKGkgPVxuICAgICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBpICYmIG51bGwgIT09IGlcbiAgICAgICAgICAgICAgICAgID8gZGVzY3JpYmVPYmplY3RGb3JFcnJvck1lc3NhZ2UoaSlcbiAgICAgICAgICAgICAgICAgIDogZGVzY3JpYmVWYWx1ZUZvckVycm9yTWVzc2FnZShpKSksXG4gICAgICAgICAgICAgIFwiXCIgKyB0eXBlID09PSBleHBhbmRlZE5hbWVcbiAgICAgICAgICAgICAgICA/ICgoc3RhcnQgPSBvYmpLaW5kLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgICAobGVuZ3RoID0gaS5sZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgKG9iaktpbmQgKz0gaSkpXG4gICAgICAgICAgICAgICAgOiAob2JqS2luZCA9XG4gICAgICAgICAgICAgICAgICAgIDEwID4gaS5sZW5ndGggJiYgNDAgPiBvYmpLaW5kLmxlbmd0aCArIGkubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgPyBvYmpLaW5kICsgaVxuICAgICAgICAgICAgICAgICAgICAgIDogb2JqS2luZCArIFwiLi4uXCIpO1xuICAgICAgICAgIG9iaktpbmQgKz0gXCJdXCI7XG4gICAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9iamVjdE9yQXJyYXkuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSlcbiAgICAgICAgb2JqS2luZCA9IFwiPFwiICsgZGVzY3JpYmVFbGVtZW50VHlwZShvYmplY3RPckFycmF5LnR5cGUpICsgXCIvPlwiO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChvYmplY3RPckFycmF5LiQkdHlwZW9mID09PSBDTElFTlRfUkVGRVJFTkNFX1RBRykgcmV0dXJuIFwiY2xpZW50XCI7XG4gICAgICAgIGlmIChqc3hQcm9wc1BhcmVudHMuaGFzKG9iamVjdE9yQXJyYXkpKSB7XG4gICAgICAgICAgb2JqS2luZCA9IGpzeFByb3BzUGFyZW50cy5nZXQob2JqZWN0T3JBcnJheSk7XG4gICAgICAgICAgb2JqS2luZCA9IFwiPFwiICsgKGRlc2NyaWJlRWxlbWVudFR5cGUob2JqS2luZCkgfHwgXCIuLi5cIik7XG4gICAgICAgICAgdHlwZSA9IE9iamVjdC5rZXlzKG9iamVjdE9yQXJyYXkpO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0eXBlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBvYmpLaW5kICs9IFwiIFwiO1xuICAgICAgICAgICAgdmFsdWUgPSB0eXBlW2ldO1xuICAgICAgICAgICAgb2JqS2luZCArPSBkZXNjcmliZUtleUZvckVycm9yTWVzc2FnZSh2YWx1ZSkgKyBcIj1cIjtcbiAgICAgICAgICAgIHZhciBfdmFsdWUyID0gb2JqZWN0T3JBcnJheVt2YWx1ZV07XG4gICAgICAgICAgICB2YXIgX3N1YnN0cjIgPVxuICAgICAgICAgICAgICB2YWx1ZSA9PT0gZXhwYW5kZWROYW1lICYmXG4gICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBfdmFsdWUyICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IF92YWx1ZTJcbiAgICAgICAgICAgICAgICA/IGRlc2NyaWJlT2JqZWN0Rm9yRXJyb3JNZXNzYWdlKF92YWx1ZTIpXG4gICAgICAgICAgICAgICAgOiBkZXNjcmliZVZhbHVlRm9yRXJyb3JNZXNzYWdlKF92YWx1ZTIpO1xuICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIF92YWx1ZTIgJiYgKF9zdWJzdHIyID0gXCJ7XCIgKyBfc3Vic3RyMiArIFwifVwiKTtcbiAgICAgICAgICAgIHZhbHVlID09PSBleHBhbmRlZE5hbWVcbiAgICAgICAgICAgICAgPyAoKHN0YXJ0ID0gb2JqS2luZC5sZW5ndGgpLFxuICAgICAgICAgICAgICAgIChsZW5ndGggPSBfc3Vic3RyMi5sZW5ndGgpLFxuICAgICAgICAgICAgICAgIChvYmpLaW5kICs9IF9zdWJzdHIyKSlcbiAgICAgICAgICAgICAgOiAob2JqS2luZCA9XG4gICAgICAgICAgICAgICAgICAxMCA+IF9zdWJzdHIyLmxlbmd0aCAmJiA0MCA+IG9iaktpbmQubGVuZ3RoICsgX3N1YnN0cjIubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgID8gb2JqS2luZCArIF9zdWJzdHIyXG4gICAgICAgICAgICAgICAgICAgIDogb2JqS2luZCArIFwiLi4uXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvYmpLaW5kICs9IFwiPlwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9iaktpbmQgPSBcIntcIjtcbiAgICAgICAgICB0eXBlID0gT2JqZWN0LmtleXMob2JqZWN0T3JBcnJheSk7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IHR5cGUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAwIDwgaSAmJiAob2JqS2luZCArPSBcIiwgXCIpLFxuICAgICAgICAgICAgICAodmFsdWUgPSB0eXBlW2ldKSxcbiAgICAgICAgICAgICAgKG9iaktpbmQgKz0gZGVzY3JpYmVLZXlGb3JFcnJvck1lc3NhZ2UodmFsdWUpICsgXCI6IFwiKSxcbiAgICAgICAgICAgICAgKF92YWx1ZTIgPSBvYmplY3RPckFycmF5W3ZhbHVlXSksXG4gICAgICAgICAgICAgIChfdmFsdWUyID1cbiAgICAgICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgX3ZhbHVlMiAmJiBudWxsICE9PSBfdmFsdWUyXG4gICAgICAgICAgICAgICAgICA/IGRlc2NyaWJlT2JqZWN0Rm9yRXJyb3JNZXNzYWdlKF92YWx1ZTIpXG4gICAgICAgICAgICAgICAgICA6IGRlc2NyaWJlVmFsdWVGb3JFcnJvck1lc3NhZ2UoX3ZhbHVlMikpLFxuICAgICAgICAgICAgICB2YWx1ZSA9PT0gZXhwYW5kZWROYW1lXG4gICAgICAgICAgICAgICAgPyAoKHN0YXJ0ID0gb2JqS2luZC5sZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgKGxlbmd0aCA9IF92YWx1ZTIubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgIChvYmpLaW5kICs9IF92YWx1ZTIpKVxuICAgICAgICAgICAgICAgIDogKG9iaktpbmQgPVxuICAgICAgICAgICAgICAgICAgICAxMCA+IF92YWx1ZTIubGVuZ3RoICYmIDQwID4gb2JqS2luZC5sZW5ndGggKyBfdmFsdWUyLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgID8gb2JqS2luZCArIF92YWx1ZTJcbiAgICAgICAgICAgICAgICAgICAgICA6IG9iaktpbmQgKyBcIi4uLlwiKTtcbiAgICAgICAgICBvYmpLaW5kICs9IFwifVwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwID09PSBleHBhbmRlZE5hbWVcbiAgICAgICAgPyBvYmpLaW5kXG4gICAgICAgIDogLTEgPCBzdGFydCAmJiAwIDwgbGVuZ3RoXG4gICAgICAgICAgPyAoKG9iamVjdE9yQXJyYXkgPSBcIiBcIi5yZXBlYXQoc3RhcnQpICsgXCJeXCIucmVwZWF0KGxlbmd0aCkpLFxuICAgICAgICAgICAgXCJcXG4gIFwiICsgb2JqS2luZCArIFwiXFxuICBcIiArIG9iamVjdE9yQXJyYXkpXG4gICAgICAgICAgOiBcIlxcbiAgXCIgKyBvYmpLaW5kO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXJpYWxpemVOdW1iZXIobnVtYmVyKSB7XG4gICAgICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKG51bWJlcilcbiAgICAgICAgPyAwID09PSBudW1iZXIgJiYgLUluZmluaXR5ID09PSAxIC8gbnVtYmVyXG4gICAgICAgICAgPyBcIiQtMFwiXG4gICAgICAgICAgOiBudW1iZXJcbiAgICAgICAgOiBJbmZpbml0eSA9PT0gbnVtYmVyXG4gICAgICAgICAgPyBcIiRJbmZpbml0eVwiXG4gICAgICAgICAgOiAtSW5maW5pdHkgPT09IG51bWJlclxuICAgICAgICAgICAgPyBcIiQtSW5maW5pdHlcIlxuICAgICAgICAgICAgOiBcIiROYU5cIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJvY2Vzc1JlcGx5KFxuICAgICAgcm9vdCxcbiAgICAgIGZvcm1GaWVsZFByZWZpeCxcbiAgICAgIHRlbXBvcmFyeVJlZmVyZW5jZXMsXG4gICAgICByZXNvbHZlLFxuICAgICAgcmVqZWN0XG4gICAgKSB7XG4gICAgICBmdW5jdGlvbiBzZXJpYWxpemVUeXBlZEFycmF5KHRhZywgdHlwZWRBcnJheSkge1xuICAgICAgICB0eXBlZEFycmF5ID0gbmV3IEJsb2IoW1xuICAgICAgICAgIG5ldyBVaW50OEFycmF5KFxuICAgICAgICAgICAgdHlwZWRBcnJheS5idWZmZXIsXG4gICAgICAgICAgICB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsXG4gICAgICAgICAgICB0eXBlZEFycmF5LmJ5dGVMZW5ndGhcbiAgICAgICAgICApXG4gICAgICAgIF0pO1xuICAgICAgICB2YXIgYmxvYklkID0gbmV4dFBhcnRJZCsrO1xuICAgICAgICBudWxsID09PSBmb3JtRGF0YSAmJiAoZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKSk7XG4gICAgICAgIGZvcm1EYXRhLmFwcGVuZChmb3JtRmllbGRQcmVmaXggKyBibG9iSWQsIHR5cGVkQXJyYXkpO1xuICAgICAgICByZXR1cm4gXCIkXCIgKyB0YWcgKyBibG9iSWQudG9TdHJpbmcoMTYpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gc2VyaWFsaXplQmluYXJ5UmVhZGVyKHJlYWRlcikge1xuICAgICAgICBmdW5jdGlvbiBwcm9ncmVzcyhlbnRyeSkge1xuICAgICAgICAgIGVudHJ5LmRvbmVcbiAgICAgICAgICAgID8gKChlbnRyeSA9IG5leHRQYXJ0SWQrKyksXG4gICAgICAgICAgICAgIGRhdGEuYXBwZW5kKGZvcm1GaWVsZFByZWZpeCArIGVudHJ5LCBuZXcgQmxvYihidWZmZXIpKSxcbiAgICAgICAgICAgICAgZGF0YS5hcHBlbmQoXG4gICAgICAgICAgICAgICAgZm9ybUZpZWxkUHJlZml4ICsgc3RyZWFtSWQsXG4gICAgICAgICAgICAgICAgJ1wiJG8nICsgZW50cnkudG9TdHJpbmcoMTYpICsgJ1wiJ1xuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICBkYXRhLmFwcGVuZChmb3JtRmllbGRQcmVmaXggKyBzdHJlYW1JZCwgXCJDXCIpLFxuICAgICAgICAgICAgICBwZW5kaW5nUGFydHMtLSxcbiAgICAgICAgICAgICAgMCA9PT0gcGVuZGluZ1BhcnRzICYmIHJlc29sdmUoZGF0YSkpXG4gICAgICAgICAgICA6IChidWZmZXIucHVzaChlbnRyeS52YWx1ZSksXG4gICAgICAgICAgICAgIHJlYWRlci5yZWFkKG5ldyBVaW50OEFycmF5KDEwMjQpKS50aGVuKHByb2dyZXNzLCByZWplY3QpKTtcbiAgICAgICAgfVxuICAgICAgICBudWxsID09PSBmb3JtRGF0YSAmJiAoZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKSk7XG4gICAgICAgIHZhciBkYXRhID0gZm9ybURhdGE7XG4gICAgICAgIHBlbmRpbmdQYXJ0cysrO1xuICAgICAgICB2YXIgc3RyZWFtSWQgPSBuZXh0UGFydElkKyssXG4gICAgICAgICAgYnVmZmVyID0gW107XG4gICAgICAgIHJlYWRlci5yZWFkKG5ldyBVaW50OEFycmF5KDEwMjQpKS50aGVuKHByb2dyZXNzLCByZWplY3QpO1xuICAgICAgICByZXR1cm4gXCIkclwiICsgc3RyZWFtSWQudG9TdHJpbmcoMTYpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gc2VyaWFsaXplUmVhZGVyKHJlYWRlcikge1xuICAgICAgICBmdW5jdGlvbiBwcm9ncmVzcyhlbnRyeSkge1xuICAgICAgICAgIGlmIChlbnRyeS5kb25lKVxuICAgICAgICAgICAgZGF0YS5hcHBlbmQoZm9ybUZpZWxkUHJlZml4ICsgc3RyZWFtSWQsIFwiQ1wiKSxcbiAgICAgICAgICAgICAgcGVuZGluZ1BhcnRzLS0sXG4gICAgICAgICAgICAgIDAgPT09IHBlbmRpbmdQYXJ0cyAmJiByZXNvbHZlKGRhdGEpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHZhciBwYXJ0SlNPTiA9IEpTT04uc3RyaW5naWZ5KGVudHJ5LnZhbHVlLCByZXNvbHZlVG9KU09OKTtcbiAgICAgICAgICAgICAgZGF0YS5hcHBlbmQoZm9ybUZpZWxkUHJlZml4ICsgc3RyZWFtSWQsIHBhcnRKU09OKTtcbiAgICAgICAgICAgICAgcmVhZGVyLnJlYWQoKS50aGVuKHByb2dyZXNzLCByZWplY3QpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICByZWplY3QoeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbnVsbCA9PT0gZm9ybURhdGEgJiYgKGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCkpO1xuICAgICAgICB2YXIgZGF0YSA9IGZvcm1EYXRhO1xuICAgICAgICBwZW5kaW5nUGFydHMrKztcbiAgICAgICAgdmFyIHN0cmVhbUlkID0gbmV4dFBhcnRJZCsrO1xuICAgICAgICByZWFkZXIucmVhZCgpLnRoZW4ocHJvZ3Jlc3MsIHJlamVjdCk7XG4gICAgICAgIHJldHVybiBcIiRSXCIgKyBzdHJlYW1JZC50b1N0cmluZygxNik7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBzZXJpYWxpemVSZWFkYWJsZVN0cmVhbShzdHJlYW0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgYmluYXJ5UmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcih7IG1vZGU6IFwiYnlvYlwiIH0pO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZVJlYWRlcihzdHJlYW0uZ2V0UmVhZGVyKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVCaW5hcnlSZWFkZXIoYmluYXJ5UmVhZGVyKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHNlcmlhbGl6ZUFzeW5jSXRlcmFibGUoaXRlcmFibGUsIGl0ZXJhdG9yKSB7XG4gICAgICAgIGZ1bmN0aW9uIHByb2dyZXNzKGVudHJ5KSB7XG4gICAgICAgICAgaWYgKGVudHJ5LmRvbmUpIHtcbiAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IGVudHJ5LnZhbHVlKVxuICAgICAgICAgICAgICBkYXRhLmFwcGVuZChmb3JtRmllbGRQcmVmaXggKyBzdHJlYW1JZCwgXCJDXCIpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJ0SlNPTiA9IEpTT04uc3RyaW5naWZ5KGVudHJ5LnZhbHVlLCByZXNvbHZlVG9KU09OKTtcbiAgICAgICAgICAgICAgICBkYXRhLmFwcGVuZChmb3JtRmllbGRQcmVmaXggKyBzdHJlYW1JZCwgXCJDXCIgKyBwYXJ0SlNPTik7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoeCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBwZW5kaW5nUGFydHMtLTtcbiAgICAgICAgICAgIDAgPT09IHBlbmRpbmdQYXJ0cyAmJiByZXNvbHZlKGRhdGEpO1xuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdmFyIF9wYXJ0SlNPTiA9IEpTT04uc3RyaW5naWZ5KGVudHJ5LnZhbHVlLCByZXNvbHZlVG9KU09OKTtcbiAgICAgICAgICAgICAgZGF0YS5hcHBlbmQoZm9ybUZpZWxkUHJlZml4ICsgc3RyZWFtSWQsIF9wYXJ0SlNPTik7XG4gICAgICAgICAgICAgIGl0ZXJhdG9yLm5leHQoKS50aGVuKHByb2dyZXNzLCByZWplY3QpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCQwKSB7XG4gICAgICAgICAgICAgIHJlamVjdCh4JDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG51bGwgPT09IGZvcm1EYXRhICYmIChmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpKTtcbiAgICAgICAgdmFyIGRhdGEgPSBmb3JtRGF0YTtcbiAgICAgICAgcGVuZGluZ1BhcnRzKys7XG4gICAgICAgIHZhciBzdHJlYW1JZCA9IG5leHRQYXJ0SWQrKztcbiAgICAgICAgaXRlcmFibGUgPSBpdGVyYWJsZSA9PT0gaXRlcmF0b3I7XG4gICAgICAgIGl0ZXJhdG9yLm5leHQoKS50aGVuKHByb2dyZXNzLCByZWplY3QpO1xuICAgICAgICByZXR1cm4gXCIkXCIgKyAoaXRlcmFibGUgPyBcInhcIiA6IFwiWFwiKSArIHN0cmVhbUlkLnRvU3RyaW5nKDE2KTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHJlc29sdmVUb0pTT04oa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgb3JpZ2luYWxWYWx1ZSA9IHRoaXNba2V5XTtcbiAgICAgICAgXCJvYmplY3RcIiAhPT0gdHlwZW9mIG9yaWdpbmFsVmFsdWUgfHxcbiAgICAgICAgICBvcmlnaW5hbFZhbHVlID09PSB2YWx1ZSB8fFxuICAgICAgICAgIG9yaWdpbmFsVmFsdWUgaW5zdGFuY2VvZiBEYXRlIHx8XG4gICAgICAgICAgKFwiT2JqZWN0XCIgIT09IG9iamVjdE5hbWUob3JpZ2luYWxWYWx1ZSlcbiAgICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIk9ubHkgcGxhaW4gb2JqZWN0cyBjYW4gYmUgcGFzc2VkIHRvIFNlcnZlciBGdW5jdGlvbnMgZnJvbSB0aGUgQ2xpZW50LiAlcyBvYmplY3RzIGFyZSBub3Qgc3VwcG9ydGVkLiVzXCIsXG4gICAgICAgICAgICAgICAgb2JqZWN0TmFtZShvcmlnaW5hbFZhbHVlKSxcbiAgICAgICAgICAgICAgICBkZXNjcmliZU9iamVjdEZvckVycm9yTWVzc2FnZSh0aGlzLCBrZXkpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIDogY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIk9ubHkgcGxhaW4gb2JqZWN0cyBjYW4gYmUgcGFzc2VkIHRvIFNlcnZlciBGdW5jdGlvbnMgZnJvbSB0aGUgQ2xpZW50LiBPYmplY3RzIHdpdGggdG9KU09OIG1ldGhvZHMgYXJlIG5vdCBzdXBwb3J0ZWQuIENvbnZlcnQgaXQgbWFudWFsbHkgdG8gYSBzaW1wbGUgdmFsdWUgYmVmb3JlIHBhc3NpbmcgaXQgdG8gcHJvcHMuJXNcIixcbiAgICAgICAgICAgICAgICBkZXNjcmliZU9iamVjdEZvckVycm9yTWVzc2FnZSh0aGlzLCBrZXkpXG4gICAgICAgICAgICAgICkpO1xuICAgICAgICBpZiAobnVsbCA9PT0gdmFsdWUpIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHZhbHVlKSB7XG4gICAgICAgICAgc3dpdGNoICh2YWx1ZS4kJHR5cGVvZikge1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IHRlbXBvcmFyeVJlZmVyZW5jZXMgJiYgLTEgPT09IGtleS5pbmRleE9mKFwiOlwiKSkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRSZWZlcmVuY2UgPSB3cml0dGVuT2JqZWN0cy5nZXQodGhpcyk7XG4gICAgICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gcGFyZW50UmVmZXJlbmNlKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgdGVtcG9yYXJ5UmVmZXJlbmNlcy5zZXQocGFyZW50UmVmZXJlbmNlICsgXCI6XCIgKyBrZXksIHZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgXCIkVFwiXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiUmVhY3QgRWxlbWVudCBjYW5ub3QgYmUgcGFzc2VkIHRvIFNlcnZlciBGdW5jdGlvbnMgZnJvbSB0aGUgQ2xpZW50IHdpdGhvdXQgYSB0ZW1wb3JhcnkgcmVmZXJlbmNlIHNldC4gUGFzcyBhIFRlbXBvcmFyeVJlZmVyZW5jZVNldCB0byB0aGUgb3B0aW9ucy5cIiArXG4gICAgICAgICAgICAgICAgICBkZXNjcmliZU9iamVjdEZvckVycm9yTWVzc2FnZSh0aGlzLCBrZXkpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgICAgb3JpZ2luYWxWYWx1ZSA9IHZhbHVlLl9wYXlsb2FkO1xuICAgICAgICAgICAgICB2YXIgaW5pdCA9IHZhbHVlLl9pbml0O1xuICAgICAgICAgICAgICBudWxsID09PSBmb3JtRGF0YSAmJiAoZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKSk7XG4gICAgICAgICAgICAgIHBlbmRpbmdQYXJ0cysrO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBhcmVudFJlZmVyZW5jZSA9IGluaXQob3JpZ2luYWxWYWx1ZSk7XG4gICAgICAgICAgICAgICAgdmFyIGxhenlJZCA9IG5leHRQYXJ0SWQrKyxcbiAgICAgICAgICAgICAgICAgIHBhcnRKU09OID0gc2VyaWFsaXplTW9kZWwocGFyZW50UmVmZXJlbmNlLCBsYXp5SWQpO1xuICAgICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChmb3JtRmllbGRQcmVmaXggKyBsYXp5SWQsIHBhcnRKU09OKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCIkXCIgKyBsYXp5SWQudG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHggJiZcbiAgICAgICAgICAgICAgICAgIG51bGwgIT09IHggJiZcbiAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHgudGhlblxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgcGVuZGluZ1BhcnRzKys7XG4gICAgICAgICAgICAgICAgICB2YXIgX2xhenlJZCA9IG5leHRQYXJ0SWQrKztcbiAgICAgICAgICAgICAgICAgIHBhcmVudFJlZmVyZW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgX3BhcnRKU09OMiA9IHNlcmlhbGl6ZU1vZGVsKHZhbHVlLCBfbGF6eUlkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9kYXRhID0gZm9ybURhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgX2RhdGEuYXBwZW5kKGZvcm1GaWVsZFByZWZpeCArIF9sYXp5SWQsIF9wYXJ0SlNPTjIpO1xuICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmdQYXJ0cy0tO1xuICAgICAgICAgICAgICAgICAgICAgIDAgPT09IHBlbmRpbmdQYXJ0cyAmJiByZXNvbHZlKF9kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAocmVhc29uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHJlYXNvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICB4LnRoZW4ocGFyZW50UmVmZXJlbmNlLCBwYXJlbnRSZWZlcmVuY2UpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiJFwiICsgX2xhenlJZC50b1N0cmluZygxNik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlamVjdCh4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBwZW5kaW5nUGFydHMtLTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdmFsdWUudGhlbikge1xuICAgICAgICAgICAgbnVsbCA9PT0gZm9ybURhdGEgJiYgKGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCkpO1xuICAgICAgICAgICAgcGVuZGluZ1BhcnRzKys7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZUlkID0gbmV4dFBhcnRJZCsrO1xuICAgICAgICAgICAgdmFsdWUudGhlbihmdW5jdGlvbiAocGFydFZhbHVlKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIF9wYXJ0SlNPTjMgPSBzZXJpYWxpemVNb2RlbChwYXJ0VmFsdWUsIHByb21pc2VJZCk7XG4gICAgICAgICAgICAgICAgcGFydFZhbHVlID0gZm9ybURhdGE7XG4gICAgICAgICAgICAgICAgcGFydFZhbHVlLmFwcGVuZChmb3JtRmllbGRQcmVmaXggKyBwcm9taXNlSWQsIF9wYXJ0SlNPTjMpO1xuICAgICAgICAgICAgICAgIHBlbmRpbmdQYXJ0cy0tO1xuICAgICAgICAgICAgICAgIDAgPT09IHBlbmRpbmdQYXJ0cyAmJiByZXNvbHZlKHBhcnRWYWx1ZSk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKHJlYXNvbikge1xuICAgICAgICAgICAgICAgIHJlamVjdChyZWFzb24pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICAgICAgcmV0dXJuIFwiJEBcIiArIHByb21pc2VJZC50b1N0cmluZygxNik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcmVudFJlZmVyZW5jZSA9IHdyaXR0ZW5PYmplY3RzLmdldCh2YWx1ZSk7XG4gICAgICAgICAgaWYgKHZvaWQgMCAhPT0gcGFyZW50UmVmZXJlbmNlKVxuICAgICAgICAgICAgaWYgKG1vZGVsUm9vdCA9PT0gdmFsdWUpIG1vZGVsUm9vdCA9IG51bGw7XG4gICAgICAgICAgICBlbHNlIHJldHVybiBwYXJlbnRSZWZlcmVuY2U7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgLTEgPT09IGtleS5pbmRleE9mKFwiOlwiKSAmJlxuICAgICAgICAgICAgICAoKHBhcmVudFJlZmVyZW5jZSA9IHdyaXR0ZW5PYmplY3RzLmdldCh0aGlzKSksXG4gICAgICAgICAgICAgIHZvaWQgMCAhPT0gcGFyZW50UmVmZXJlbmNlICYmXG4gICAgICAgICAgICAgICAgKChwYXJlbnRSZWZlcmVuY2UgPSBwYXJlbnRSZWZlcmVuY2UgKyBcIjpcIiArIGtleSksXG4gICAgICAgICAgICAgICAgd3JpdHRlbk9iamVjdHMuc2V0KHZhbHVlLCBwYXJlbnRSZWZlcmVuY2UpLFxuICAgICAgICAgICAgICAgIHZvaWQgMCAhPT0gdGVtcG9yYXJ5UmVmZXJlbmNlcyAmJlxuICAgICAgICAgICAgICAgICAgdGVtcG9yYXJ5UmVmZXJlbmNlcy5zZXQocGFyZW50UmVmZXJlbmNlLCB2YWx1ZSkpKTtcbiAgICAgICAgICBpZiAoaXNBcnJheUltcGwodmFsdWUpKSByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRm9ybURhdGEpIHtcbiAgICAgICAgICAgIG51bGwgPT09IGZvcm1EYXRhICYmIChmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpKTtcbiAgICAgICAgICAgIHZhciBfZGF0YTMgPSBmb3JtRGF0YTtcbiAgICAgICAgICAgIGtleSA9IG5leHRQYXJ0SWQrKztcbiAgICAgICAgICAgIHZhciBwcmVmaXggPSBmb3JtRmllbGRQcmVmaXggKyBrZXkgKyBcIl9cIjtcbiAgICAgICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKG9yaWdpbmFsVmFsdWUsIG9yaWdpbmFsS2V5KSB7XG4gICAgICAgICAgICAgIF9kYXRhMy5hcHBlbmQocHJlZml4ICsgb3JpZ2luYWxLZXksIG9yaWdpbmFsVmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gXCIkS1wiICsga2V5LnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWFwKVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKGtleSA9IG5leHRQYXJ0SWQrKyksXG4gICAgICAgICAgICAgIChwYXJlbnRSZWZlcmVuY2UgPSBzZXJpYWxpemVNb2RlbChBcnJheS5mcm9tKHZhbHVlKSwga2V5KSksXG4gICAgICAgICAgICAgIG51bGwgPT09IGZvcm1EYXRhICYmIChmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpKSxcbiAgICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKGZvcm1GaWVsZFByZWZpeCArIGtleSwgcGFyZW50UmVmZXJlbmNlKSxcbiAgICAgICAgICAgICAgXCIkUVwiICsga2V5LnRvU3RyaW5nKDE2KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBTZXQpXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAoa2V5ID0gbmV4dFBhcnRJZCsrKSxcbiAgICAgICAgICAgICAgKHBhcmVudFJlZmVyZW5jZSA9IHNlcmlhbGl6ZU1vZGVsKEFycmF5LmZyb20odmFsdWUpLCBrZXkpKSxcbiAgICAgICAgICAgICAgbnVsbCA9PT0gZm9ybURhdGEgJiYgKGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCkpLFxuICAgICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoZm9ybUZpZWxkUHJlZml4ICsga2V5LCBwYXJlbnRSZWZlcmVuY2UpLFxuICAgICAgICAgICAgICBcIiRXXCIgKyBrZXkudG9TdHJpbmcoMTYpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKGtleSA9IG5ldyBCbG9iKFt2YWx1ZV0pKSxcbiAgICAgICAgICAgICAgKHBhcmVudFJlZmVyZW5jZSA9IG5leHRQYXJ0SWQrKyksXG4gICAgICAgICAgICAgIG51bGwgPT09IGZvcm1EYXRhICYmIChmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpKSxcbiAgICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKGZvcm1GaWVsZFByZWZpeCArIHBhcmVudFJlZmVyZW5jZSwga2V5KSxcbiAgICAgICAgICAgICAgXCIkQVwiICsgcGFyZW50UmVmZXJlbmNlLnRvU3RyaW5nKDE2KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBJbnQ4QXJyYXkpXG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplVHlwZWRBcnJheShcIk9cIiwgdmFsdWUpO1xuICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpXG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplVHlwZWRBcnJheShcIm9cIiwgdmFsdWUpO1xuICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5KVxuICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZVR5cGVkQXJyYXkoXCJVXCIsIHZhbHVlKTtcbiAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBJbnQxNkFycmF5KVxuICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZVR5cGVkQXJyYXkoXCJTXCIsIHZhbHVlKTtcbiAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50MTZBcnJheSlcbiAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVUeXBlZEFycmF5KFwic1wiLCB2YWx1ZSk7XG4gICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgSW50MzJBcnJheSlcbiAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVUeXBlZEFycmF5KFwiTFwiLCB2YWx1ZSk7XG4gICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDMyQXJyYXkpXG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplVHlwZWRBcnJheShcImxcIiwgdmFsdWUpO1xuICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSlcbiAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVUeXBlZEFycmF5KFwiR1wiLCB2YWx1ZSk7XG4gICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5KVxuICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZVR5cGVkQXJyYXkoXCJnXCIsIHZhbHVlKTtcbiAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBCaWdJbnQ2NEFycmF5KVxuICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZVR5cGVkQXJyYXkoXCJNXCIsIHZhbHVlKTtcbiAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBCaWdVaW50NjRBcnJheSlcbiAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVUeXBlZEFycmF5KFwibVwiLCB2YWx1ZSk7XG4gICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0YVZpZXcpIHJldHVybiBzZXJpYWxpemVUeXBlZEFycmF5KFwiVlwiLCB2YWx1ZSk7XG4gICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIEJsb2IgJiYgdmFsdWUgaW5zdGFuY2VvZiBCbG9iKVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgbnVsbCA9PT0gZm9ybURhdGEgJiYgKGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCkpLFxuICAgICAgICAgICAgICAoa2V5ID0gbmV4dFBhcnRJZCsrKSxcbiAgICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKGZvcm1GaWVsZFByZWZpeCArIGtleSwgdmFsdWUpLFxuICAgICAgICAgICAgICBcIiRCXCIgKyBrZXkudG9TdHJpbmcoMTYpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGlmICgocGFyZW50UmVmZXJlbmNlID0gZ2V0SXRlcmF0b3JGbih2YWx1ZSkpKVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKHBhcmVudFJlZmVyZW5jZSA9IHBhcmVudFJlZmVyZW5jZS5jYWxsKHZhbHVlKSksXG4gICAgICAgICAgICAgIHBhcmVudFJlZmVyZW5jZSA9PT0gdmFsdWVcbiAgICAgICAgICAgICAgICA/ICgoa2V5ID0gbmV4dFBhcnRJZCsrKSxcbiAgICAgICAgICAgICAgICAgIChwYXJlbnRSZWZlcmVuY2UgPSBzZXJpYWxpemVNb2RlbChcbiAgICAgICAgICAgICAgICAgICAgQXJyYXkuZnJvbShwYXJlbnRSZWZlcmVuY2UpLFxuICAgICAgICAgICAgICAgICAgICBrZXlcbiAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgICAgbnVsbCA9PT0gZm9ybURhdGEgJiYgKGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCkpLFxuICAgICAgICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKGZvcm1GaWVsZFByZWZpeCArIGtleSwgcGFyZW50UmVmZXJlbmNlKSxcbiAgICAgICAgICAgICAgICAgIFwiJGlcIiArIGtleS50b1N0cmluZygxNikpXG4gICAgICAgICAgICAgICAgOiBBcnJheS5mcm9tKHBhcmVudFJlZmVyZW5jZSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgUmVhZGFibGVTdHJlYW0gJiZcbiAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW1cbiAgICAgICAgICApXG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplUmVhZGFibGVTdHJlYW0odmFsdWUpO1xuICAgICAgICAgIHBhcmVudFJlZmVyZW5jZSA9IHZhbHVlW0FTWU5DX0lURVJBVE9SXTtcbiAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcGFyZW50UmVmZXJlbmNlKVxuICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZUFzeW5jSXRlcmFibGUodmFsdWUsIHBhcmVudFJlZmVyZW5jZS5jYWxsKHZhbHVlKSk7XG4gICAgICAgICAgcGFyZW50UmVmZXJlbmNlID0gZ2V0UHJvdG90eXBlT2YodmFsdWUpO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHBhcmVudFJlZmVyZW5jZSAhPT0gT2JqZWN0UHJvdG90eXBlICYmXG4gICAgICAgICAgICAobnVsbCA9PT0gcGFyZW50UmVmZXJlbmNlIHx8XG4gICAgICAgICAgICAgIG51bGwgIT09IGdldFByb3RvdHlwZU9mKHBhcmVudFJlZmVyZW5jZSkpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAodm9pZCAwID09PSB0ZW1wb3JhcnlSZWZlcmVuY2VzKVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIk9ubHkgcGxhaW4gb2JqZWN0cywgYW5kIGEgZmV3IGJ1aWx0LWlucywgY2FuIGJlIHBhc3NlZCB0byBTZXJ2ZXIgRnVuY3Rpb25zLiBDbGFzc2VzIG9yIG51bGwgcHJvdG90eXBlcyBhcmUgbm90IHN1cHBvcnRlZC5cIiArXG4gICAgICAgICAgICAgICAgICBkZXNjcmliZU9iamVjdEZvckVycm9yTWVzc2FnZSh0aGlzLCBrZXkpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gXCIkVFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YWx1ZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFXG4gICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJSZWFjdCBDb250ZXh0IFByb3ZpZGVycyBjYW5ub3QgYmUgcGFzc2VkIHRvIFNlcnZlciBGdW5jdGlvbnMgZnJvbSB0aGUgQ2xpZW50LiVzXCIsXG4gICAgICAgICAgICAgICAgZGVzY3JpYmVPYmplY3RGb3JFcnJvck1lc3NhZ2UodGhpcywga2V5KVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICA6IFwiT2JqZWN0XCIgIT09IG9iamVjdE5hbWUodmFsdWUpXG4gICAgICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiT25seSBwbGFpbiBvYmplY3RzIGNhbiBiZSBwYXNzZWQgdG8gU2VydmVyIEZ1bmN0aW9ucyBmcm9tIHRoZSBDbGllbnQuICVzIG9iamVjdHMgYXJlIG5vdCBzdXBwb3J0ZWQuJXNcIixcbiAgICAgICAgICAgICAgICAgIG9iamVjdE5hbWUodmFsdWUpLFxuICAgICAgICAgICAgICAgICAgZGVzY3JpYmVPYmplY3RGb3JFcnJvck1lc3NhZ2UodGhpcywga2V5KVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiBpc1NpbXBsZU9iamVjdCh2YWx1ZSlcbiAgICAgICAgICAgICAgICA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgJiZcbiAgICAgICAgICAgICAgICAgICgocGFyZW50UmVmZXJlbmNlID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh2YWx1ZSkpLFxuICAgICAgICAgICAgICAgICAgMCA8IHBhcmVudFJlZmVyZW5jZS5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICBcIk9ubHkgcGxhaW4gb2JqZWN0cyBjYW4gYmUgcGFzc2VkIHRvIFNlcnZlciBGdW5jdGlvbnMgZnJvbSB0aGUgQ2xpZW50LiBPYmplY3RzIHdpdGggc3ltYm9sIHByb3BlcnRpZXMgbGlrZSAlcyBhcmUgbm90IHN1cHBvcnRlZC4lc1wiLFxuICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFJlZmVyZW5jZVswXS5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICBkZXNjcmliZU9iamVjdEZvckVycm9yTWVzc2FnZSh0aGlzLCBrZXkpXG4gICAgICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICAgICAgOiBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIk9ubHkgcGxhaW4gb2JqZWN0cyBjYW4gYmUgcGFzc2VkIHRvIFNlcnZlciBGdW5jdGlvbnMgZnJvbSB0aGUgQ2xpZW50LiBDbGFzc2VzIG9yIG90aGVyIG9iamVjdHMgd2l0aCBtZXRob2RzIGFyZSBub3Qgc3VwcG9ydGVkLiVzXCIsXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaWJlT2JqZWN0Rm9yRXJyb3JNZXNzYWdlKHRoaXMsIGtleSlcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgICBpZiAoXCJaXCIgPT09IHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdICYmIHRoaXNba2V5XSBpbnN0YW5jZW9mIERhdGUpXG4gICAgICAgICAgICByZXR1cm4gXCIkRFwiICsgdmFsdWU7XG4gICAgICAgICAga2V5ID0gXCIkXCIgPT09IHZhbHVlWzBdID8gXCIkXCIgKyB2YWx1ZSA6IHZhbHVlO1xuICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwiYm9vbGVhblwiID09PSB0eXBlb2YgdmFsdWUpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgaWYgKFwibnVtYmVyXCIgPT09IHR5cGVvZiB2YWx1ZSkgcmV0dXJuIHNlcmlhbGl6ZU51bWJlcih2YWx1ZSk7XG4gICAgICAgIGlmIChcInVuZGVmaW5lZFwiID09PSB0eXBlb2YgdmFsdWUpIHJldHVybiBcIiR1bmRlZmluZWRcIjtcbiAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHZhbHVlKSB7XG4gICAgICAgICAgcGFyZW50UmVmZXJlbmNlID0ga25vd25TZXJ2ZXJSZWZlcmVuY2VzLmdldCh2YWx1ZSk7XG4gICAgICAgICAgaWYgKHZvaWQgMCAhPT0gcGFyZW50UmVmZXJlbmNlKVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKGtleSA9IEpTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAgIHsgaWQ6IHBhcmVudFJlZmVyZW5jZS5pZCwgYm91bmQ6IHBhcmVudFJlZmVyZW5jZS5ib3VuZCB9LFxuICAgICAgICAgICAgICAgIHJlc29sdmVUb0pTT05cbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIG51bGwgPT09IGZvcm1EYXRhICYmIChmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpKSxcbiAgICAgICAgICAgICAgKHBhcmVudFJlZmVyZW5jZSA9IG5leHRQYXJ0SWQrKyksXG4gICAgICAgICAgICAgIGZvcm1EYXRhLnNldChmb3JtRmllbGRQcmVmaXggKyBwYXJlbnRSZWZlcmVuY2UsIGtleSksXG4gICAgICAgICAgICAgIFwiJEZcIiArIHBhcmVudFJlZmVyZW5jZS50b1N0cmluZygxNilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgdm9pZCAwICE9PSB0ZW1wb3JhcnlSZWZlcmVuY2VzICYmXG4gICAgICAgICAgICAtMSA9PT0ga2V5LmluZGV4T2YoXCI6XCIpICYmXG4gICAgICAgICAgICAoKHBhcmVudFJlZmVyZW5jZSA9IHdyaXR0ZW5PYmplY3RzLmdldCh0aGlzKSksXG4gICAgICAgICAgICB2b2lkIDAgIT09IHBhcmVudFJlZmVyZW5jZSlcbiAgICAgICAgICApXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICB0ZW1wb3JhcnlSZWZlcmVuY2VzLnNldChwYXJlbnRSZWZlcmVuY2UgKyBcIjpcIiArIGtleSwgdmFsdWUpLCBcIiRUXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIkNsaWVudCBGdW5jdGlvbnMgY2Fubm90IGJlIHBhc3NlZCBkaXJlY3RseSB0byBTZXJ2ZXIgRnVuY3Rpb25zLiBPbmx5IEZ1bmN0aW9ucyBwYXNzZWQgZnJvbSB0aGUgU2VydmVyIGNhbiBiZSBwYXNzZWQgYmFjayBhZ2Fpbi5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwic3ltYm9sXCIgPT09IHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHZvaWQgMCAhPT0gdGVtcG9yYXJ5UmVmZXJlbmNlcyAmJlxuICAgICAgICAgICAgLTEgPT09IGtleS5pbmRleE9mKFwiOlwiKSAmJlxuICAgICAgICAgICAgKChwYXJlbnRSZWZlcmVuY2UgPSB3cml0dGVuT2JqZWN0cy5nZXQodGhpcykpLFxuICAgICAgICAgICAgdm9pZCAwICE9PSBwYXJlbnRSZWZlcmVuY2UpXG4gICAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgdGVtcG9yYXJ5UmVmZXJlbmNlcy5zZXQocGFyZW50UmVmZXJlbmNlICsgXCI6XCIgKyBrZXksIHZhbHVlKSwgXCIkVFwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJTeW1ib2xzIGNhbm5vdCBiZSBwYXNzZWQgdG8gYSBTZXJ2ZXIgRnVuY3Rpb24gd2l0aG91dCBhIHRlbXBvcmFyeSByZWZlcmVuY2Ugc2V0LiBQYXNzIGEgVGVtcG9yYXJ5UmVmZXJlbmNlU2V0IHRvIHRoZSBvcHRpb25zLlwiICtcbiAgICAgICAgICAgICAgZGVzY3JpYmVPYmplY3RGb3JFcnJvck1lc3NhZ2UodGhpcywga2V5KVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwiYmlnaW50XCIgPT09IHR5cGVvZiB2YWx1ZSkgcmV0dXJuIFwiJG5cIiArIHZhbHVlLnRvU3RyaW5nKDEwKTtcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJUeXBlIFwiICtcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSArXG4gICAgICAgICAgICBcIiBpcyBub3Qgc3VwcG9ydGVkIGFzIGFuIGFyZ3VtZW50IHRvIGEgU2VydmVyIEZ1bmN0aW9uLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBzZXJpYWxpemVNb2RlbChtb2RlbCwgaWQpIHtcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIG1vZGVsICYmXG4gICAgICAgICAgbnVsbCAhPT0gbW9kZWwgJiZcbiAgICAgICAgICAoKGlkID0gXCIkXCIgKyBpZC50b1N0cmluZygxNikpLFxuICAgICAgICAgIHdyaXR0ZW5PYmplY3RzLnNldChtb2RlbCwgaWQpLFxuICAgICAgICAgIHZvaWQgMCAhPT0gdGVtcG9yYXJ5UmVmZXJlbmNlcyAmJiB0ZW1wb3JhcnlSZWZlcmVuY2VzLnNldChpZCwgbW9kZWwpKTtcbiAgICAgICAgbW9kZWxSb290ID0gbW9kZWw7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShtb2RlbCwgcmVzb2x2ZVRvSlNPTik7XG4gICAgICB9XG4gICAgICB2YXIgbmV4dFBhcnRJZCA9IDEsXG4gICAgICAgIHBlbmRpbmdQYXJ0cyA9IDAsXG4gICAgICAgIGZvcm1EYXRhID0gbnVsbCxcbiAgICAgICAgd3JpdHRlbk9iamVjdHMgPSBuZXcgV2Vha01hcCgpLFxuICAgICAgICBtb2RlbFJvb3QgPSByb290LFxuICAgICAgICBqc29uID0gc2VyaWFsaXplTW9kZWwocm9vdCwgMCk7XG4gICAgICBudWxsID09PSBmb3JtRGF0YVxuICAgICAgICA/IHJlc29sdmUoanNvbilcbiAgICAgICAgOiAoZm9ybURhdGEuc2V0KGZvcm1GaWVsZFByZWZpeCArIFwiMFwiLCBqc29uKSxcbiAgICAgICAgICAwID09PSBwZW5kaW5nUGFydHMgJiYgcmVzb2x2ZShmb3JtRGF0YSkpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgMCA8IHBlbmRpbmdQYXJ0cyAmJlxuICAgICAgICAgICgocGVuZGluZ1BhcnRzID0gMCksXG4gICAgICAgICAgbnVsbCA9PT0gZm9ybURhdGEgPyByZXNvbHZlKGpzb24pIDogcmVzb2x2ZShmb3JtRGF0YSkpO1xuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5jb2RlRm9ybURhdGEocmVmZXJlbmNlKSB7XG4gICAgICB2YXIgcmVzb2x2ZSxcbiAgICAgICAgcmVqZWN0LFxuICAgICAgICB0aGVuYWJsZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXMsIHJlaikge1xuICAgICAgICAgIHJlc29sdmUgPSByZXM7XG4gICAgICAgICAgcmVqZWN0ID0gcmVqO1xuICAgICAgICB9KTtcbiAgICAgIHByb2Nlc3NSZXBseShcbiAgICAgICAgcmVmZXJlbmNlLFxuICAgICAgICBcIlwiLFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIGZ1bmN0aW9uIChib2R5KSB7XG4gICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBib2R5KSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgICAgICAgZGF0YS5hcHBlbmQoXCIwXCIsIGJvZHkpO1xuICAgICAgICAgICAgYm9keSA9IGRhdGE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoZW5hYmxlLnN0YXR1cyA9IFwiZnVsZmlsbGVkXCI7XG4gICAgICAgICAgdGhlbmFibGUudmFsdWUgPSBib2R5O1xuICAgICAgICAgIHJlc29sdmUoYm9keSk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgdGhlbmFibGUuc3RhdHVzID0gXCJyZWplY3RlZFwiO1xuICAgICAgICAgIHRoZW5hYmxlLnJlYXNvbiA9IGU7XG4gICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgICApO1xuICAgICAgcmV0dXJuIHRoZW5hYmxlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZhdWx0RW5jb2RlRm9ybUFjdGlvbihpZGVudGlmaWVyUHJlZml4KSB7XG4gICAgICB2YXIgcmVmZXJlbmNlQ2xvc3VyZSA9IGtub3duU2VydmVyUmVmZXJlbmNlcy5nZXQodGhpcyk7XG4gICAgICBpZiAoIXJlZmVyZW5jZUNsb3N1cmUpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiVHJpZWQgdG8gZW5jb2RlIGEgU2VydmVyIEFjdGlvbiBmcm9tIGEgZGlmZmVyZW50IGluc3RhbmNlIHRoYW4gdGhlIGVuY29kZXIgaXMgZnJvbS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICApO1xuICAgICAgdmFyIGRhdGEgPSBudWxsO1xuICAgICAgaWYgKG51bGwgIT09IHJlZmVyZW5jZUNsb3N1cmUuYm91bmQpIHtcbiAgICAgICAgZGF0YSA9IGJvdW5kQ2FjaGUuZ2V0KHJlZmVyZW5jZUNsb3N1cmUpO1xuICAgICAgICBkYXRhIHx8XG4gICAgICAgICAgKChkYXRhID0gZW5jb2RlRm9ybURhdGEoe1xuICAgICAgICAgICAgaWQ6IHJlZmVyZW5jZUNsb3N1cmUuaWQsXG4gICAgICAgICAgICBib3VuZDogcmVmZXJlbmNlQ2xvc3VyZS5ib3VuZFxuICAgICAgICAgIH0pKSxcbiAgICAgICAgICBib3VuZENhY2hlLnNldChyZWZlcmVuY2VDbG9zdXJlLCBkYXRhKSk7XG4gICAgICAgIGlmIChcInJlamVjdGVkXCIgPT09IGRhdGEuc3RhdHVzKSB0aHJvdyBkYXRhLnJlYXNvbjtcbiAgICAgICAgaWYgKFwiZnVsZmlsbGVkXCIgIT09IGRhdGEuc3RhdHVzKSB0aHJvdyBkYXRhO1xuICAgICAgICByZWZlcmVuY2VDbG9zdXJlID0gZGF0YS52YWx1ZTtcbiAgICAgICAgdmFyIHByZWZpeGVkRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgICByZWZlcmVuY2VDbG9zdXJlLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICBwcmVmaXhlZERhdGEuYXBwZW5kKFwiJEFDVElPTl9cIiArIGlkZW50aWZpZXJQcmVmaXggKyBcIjpcIiArIGtleSwgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgZGF0YSA9IHByZWZpeGVkRGF0YTtcbiAgICAgICAgcmVmZXJlbmNlQ2xvc3VyZSA9IFwiJEFDVElPTl9SRUZfXCIgKyBpZGVudGlmaWVyUHJlZml4O1xuICAgICAgfSBlbHNlIHJlZmVyZW5jZUNsb3N1cmUgPSBcIiRBQ1RJT05fSURfXCIgKyByZWZlcmVuY2VDbG9zdXJlLmlkO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogcmVmZXJlbmNlQ2xvc3VyZSxcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgZW5jVHlwZTogXCJtdWx0aXBhcnQvZm9ybS1kYXRhXCIsXG4gICAgICAgIGRhdGE6IGRhdGFcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzU2lnbmF0dXJlRXF1YWwocmVmZXJlbmNlSWQsIG51bWJlck9mQm91bmRBcmdzKSB7XG4gICAgICB2YXIgcmVmZXJlbmNlQ2xvc3VyZSA9IGtub3duU2VydmVyUmVmZXJlbmNlcy5nZXQodGhpcyk7XG4gICAgICBpZiAoIXJlZmVyZW5jZUNsb3N1cmUpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiVHJpZWQgdG8gZW5jb2RlIGEgU2VydmVyIEFjdGlvbiBmcm9tIGEgZGlmZmVyZW50IGluc3RhbmNlIHRoYW4gdGhlIGVuY29kZXIgaXMgZnJvbS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICApO1xuICAgICAgaWYgKHJlZmVyZW5jZUNsb3N1cmUuaWQgIT09IHJlZmVyZW5jZUlkKSByZXR1cm4gITE7XG4gICAgICB2YXIgYm91bmRQcm9taXNlID0gcmVmZXJlbmNlQ2xvc3VyZS5ib3VuZDtcbiAgICAgIGlmIChudWxsID09PSBib3VuZFByb21pc2UpIHJldHVybiAwID09PSBudW1iZXJPZkJvdW5kQXJncztcbiAgICAgIHN3aXRjaCAoYm91bmRQcm9taXNlLnN0YXR1cykge1xuICAgICAgICBjYXNlIFwiZnVsZmlsbGVkXCI6XG4gICAgICAgICAgcmV0dXJuIGJvdW5kUHJvbWlzZS52YWx1ZS5sZW5ndGggPT09IG51bWJlck9mQm91bmRBcmdzO1xuICAgICAgICBjYXNlIFwicGVuZGluZ1wiOlxuICAgICAgICAgIHRocm93IGJvdW5kUHJvbWlzZTtcbiAgICAgICAgY2FzZSBcInJlamVjdGVkXCI6XG4gICAgICAgICAgdGhyb3cgYm91bmRQcm9taXNlLnJlYXNvbjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyAoXG4gICAgICAgICAgICAoXCJzdHJpbmdcIiAhPT0gdHlwZW9mIGJvdW5kUHJvbWlzZS5zdGF0dXMgJiZcbiAgICAgICAgICAgICAgKChib3VuZFByb21pc2Uuc3RhdHVzID0gXCJwZW5kaW5nXCIpLFxuICAgICAgICAgICAgICBib3VuZFByb21pc2UudGhlbihcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoYm91bmRBcmdzKSB7XG4gICAgICAgICAgICAgICAgICBib3VuZFByb21pc2Uuc3RhdHVzID0gXCJmdWxmaWxsZWRcIjtcbiAgICAgICAgICAgICAgICAgIGJvdW5kUHJvbWlzZS52YWx1ZSA9IGJvdW5kQXJncztcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgYm91bmRQcm9taXNlLnN0YXR1cyA9IFwicmVqZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICAgIGJvdW5kUHJvbWlzZS5yZWFzb24gPSBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgYm91bmRQcm9taXNlKVxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZha2VTZXJ2ZXJGdW5jdGlvbihcbiAgICAgIG5hbWUsXG4gICAgICBmaWxlbmFtZSxcbiAgICAgIHNvdXJjZU1hcCxcbiAgICAgIGxpbmUsXG4gICAgICBjb2wsXG4gICAgICBlbnZpcm9ubWVudE5hbWUsXG4gICAgICBpbm5lckZ1bmN0aW9uXG4gICAgKSB7XG4gICAgICBuYW1lIHx8IChuYW1lID0gXCI8YW5vbnltb3VzPlwiKTtcbiAgICAgIHZhciBlbmNvZGVkTmFtZSA9IEpTT04uc3RyaW5naWZ5KG5hbWUpO1xuICAgICAgMSA+PSBsaW5lXG4gICAgICAgID8gKChsaW5lID0gZW5jb2RlZE5hbWUubGVuZ3RoICsgNyksXG4gICAgICAgICAgKGNvbCA9XG4gICAgICAgICAgICBcInM9Pih7XCIgK1xuICAgICAgICAgICAgZW5jb2RlZE5hbWUgK1xuICAgICAgICAgICAgXCIgXCIucmVwZWF0KGNvbCA8IGxpbmUgPyAwIDogY29sIC0gbGluZSkgK1xuICAgICAgICAgICAgXCI6KC4uLmFyZ3MpID0+IHMoLi4uYXJncyl9KVxcbi8qIFRoaXMgbW9kdWxlIGlzIGEgcHJveHkgdG8gYSBTZXJ2ZXIgQWN0aW9uLiBUdXJuIG9uIFNvdXJjZSBNYXBzIHRvIHNlZSB0aGUgc2VydmVyIHNvdXJjZS4gKi9cIikpXG4gICAgICAgIDogKGNvbCA9XG4gICAgICAgICAgICBcIi8qIFRoaXMgbW9kdWxlIGlzIGEgcHJveHkgdG8gYSBTZXJ2ZXIgQWN0aW9uLiBUdXJuIG9uIFNvdXJjZSBNYXBzIHRvIHNlZSB0aGUgc2VydmVyIHNvdXJjZS4gKi9cIiArXG4gICAgICAgICAgICBcIlxcblwiLnJlcGVhdChsaW5lIC0gMikgK1xuICAgICAgICAgICAgXCJzZXJ2ZXI9Pih7XCIgK1xuICAgICAgICAgICAgZW5jb2RlZE5hbWUgK1xuICAgICAgICAgICAgXCI6XFxuXCIgK1xuICAgICAgICAgICAgXCIgXCIucmVwZWF0KDEgPiBjb2wgPyAwIDogY29sIC0gMSkgK1xuICAgICAgICAgICAgXCIoLi4uYXJncykgPT4gc2VydmVyKC4uLmFyZ3MpfSlcIik7XG4gICAgICBmaWxlbmFtZS5zdGFydHNXaXRoKFwiL1wiKSAmJiAoZmlsZW5hbWUgPSBcImZpbGU6Ly9cIiArIGZpbGVuYW1lKTtcbiAgICAgIHNvdXJjZU1hcFxuICAgICAgICA/ICgoY29sICs9XG4gICAgICAgICAgICBcIlxcbi8vIyBzb3VyY2VVUkw9cnNjOi8vUmVhY3QvXCIgK1xuICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KGVudmlyb25tZW50TmFtZSkgK1xuICAgICAgICAgICAgXCIvXCIgK1xuICAgICAgICAgICAgZW5jb2RlVVJJKGZpbGVuYW1lKSArXG4gICAgICAgICAgICBcIj9zXCIgK1xuICAgICAgICAgICAgZmFrZVNlcnZlckZ1bmN0aW9uSWR4KyspLFxuICAgICAgICAgIChjb2wgKz0gXCJcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1cIiArIHNvdXJjZU1hcCkpXG4gICAgICAgIDogZmlsZW5hbWUgJiYgKGNvbCArPSBcIlxcbi8vIyBzb3VyY2VVUkw9XCIgKyBmaWxlbmFtZSk7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gKDAsIGV2YWwpKGNvbCkoaW5uZXJGdW5jdGlvbilbbmFtZV07XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHJldHVybiBpbm5lckZ1bmN0aW9uO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZWdpc3RlckJvdW5kU2VydmVyUmVmZXJlbmNlKFxuICAgICAgcmVmZXJlbmNlLFxuICAgICAgaWQsXG4gICAgICBib3VuZCxcbiAgICAgIGVuY29kZUZvcm1BY3Rpb25cbiAgICApIHtcbiAgICAgIGtub3duU2VydmVyUmVmZXJlbmNlcy5oYXMocmVmZXJlbmNlKSB8fFxuICAgICAgICAoa25vd25TZXJ2ZXJSZWZlcmVuY2VzLnNldChyZWZlcmVuY2UsIHtcbiAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgb3JpZ2luYWxCaW5kOiByZWZlcmVuY2UuYmluZCxcbiAgICAgICAgICBib3VuZDogYm91bmRcbiAgICAgICAgfSksXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHJlZmVyZW5jZSwge1xuICAgICAgICAgICQkRk9STV9BQ1RJT046IHtcbiAgICAgICAgICAgIHZhbHVlOlxuICAgICAgICAgICAgICB2b2lkIDAgPT09IGVuY29kZUZvcm1BY3Rpb25cbiAgICAgICAgICAgICAgICA/IGRlZmF1bHRFbmNvZGVGb3JtQWN0aW9uXG4gICAgICAgICAgICAgICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWZlcmVuY2VDbG9zdXJlID0ga25vd25TZXJ2ZXJSZWZlcmVuY2VzLmdldCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWZlcmVuY2VDbG9zdXJlKVxuICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJUcmllZCB0byBlbmNvZGUgYSBTZXJ2ZXIgQWN0aW9uIGZyb20gYSBkaWZmZXJlbnQgaW5zdGFuY2UgdGhhbiB0aGUgZW5jb2RlciBpcyBmcm9tLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvdW5kUHJvbWlzZSA9IHJlZmVyZW5jZUNsb3N1cmUuYm91bmQ7XG4gICAgICAgICAgICAgICAgICAgIG51bGwgPT09IGJvdW5kUHJvbWlzZSAmJlxuICAgICAgICAgICAgICAgICAgICAgIChib3VuZFByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoW10pKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVuY29kZUZvcm1BY3Rpb24ocmVmZXJlbmNlQ2xvc3VyZS5pZCwgYm91bmRQcm9taXNlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgICQkSVNfU0lHTkFUVVJFX0VRVUFMOiB7IHZhbHVlOiBpc1NpZ25hdHVyZUVxdWFsIH0sXG4gICAgICAgICAgYmluZDogeyB2YWx1ZTogYmluZCB9XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYmluZCgpIHtcbiAgICAgIHZhciByZWZlcmVuY2VDbG9zdXJlID0ga25vd25TZXJ2ZXJSZWZlcmVuY2VzLmdldCh0aGlzKTtcbiAgICAgIGlmICghcmVmZXJlbmNlQ2xvc3VyZSkgcmV0dXJuIEZ1bmN0aW9uQmluZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgdmFyIG5ld0ZuID0gcmVmZXJlbmNlQ2xvc3VyZS5vcmlnaW5hbEJpbmQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIG51bGwgIT0gYXJndW1lbnRzWzBdICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgJ0Nhbm5vdCBiaW5kIFwidGhpc1wiIG9mIGEgU2VydmVyIEFjdGlvbi4gUGFzcyBudWxsIG9yIHVuZGVmaW5lZCBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gLmJpbmQoKS4nXG4gICAgICAgICk7XG4gICAgICB2YXIgYXJncyA9IEFycmF5U2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLFxuICAgICAgICBib3VuZFByb21pc2UgPSBudWxsO1xuICAgICAgYm91bmRQcm9taXNlID1cbiAgICAgICAgbnVsbCAhPT0gcmVmZXJlbmNlQ2xvc3VyZS5ib3VuZFxuICAgICAgICAgID8gUHJvbWlzZS5yZXNvbHZlKHJlZmVyZW5jZUNsb3N1cmUuYm91bmQpLnRoZW4oZnVuY3Rpb24gKGJvdW5kQXJncykge1xuICAgICAgICAgICAgICByZXR1cm4gYm91bmRBcmdzLmNvbmNhdChhcmdzKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgOiBQcm9taXNlLnJlc29sdmUoYXJncyk7XG4gICAgICBrbm93blNlcnZlclJlZmVyZW5jZXMuc2V0KG5ld0ZuLCB7XG4gICAgICAgIGlkOiByZWZlcmVuY2VDbG9zdXJlLmlkLFxuICAgICAgICBvcmlnaW5hbEJpbmQ6IG5ld0ZuLmJpbmQsXG4gICAgICAgIGJvdW5kOiBib3VuZFByb21pc2VcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMobmV3Rm4sIHtcbiAgICAgICAgJCRGT1JNX0FDVElPTjogeyB2YWx1ZTogdGhpcy4kJEZPUk1fQUNUSU9OIH0sXG4gICAgICAgICQkSVNfU0lHTkFUVVJFX0VRVUFMOiB7IHZhbHVlOiBpc1NpZ25hdHVyZUVxdWFsIH0sXG4gICAgICAgIGJpbmQ6IHsgdmFsdWU6IGJpbmQgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3Rm47XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUJvdW5kU2VydmVyUmVmZXJlbmNlKFxuICAgICAgbWV0YURhdGEsXG4gICAgICBjYWxsU2VydmVyLFxuICAgICAgZW5jb2RlRm9ybUFjdGlvbixcbiAgICAgIGZpbmRTb3VyY2VNYXBVUkxcbiAgICApIHtcbiAgICAgIGZ1bmN0aW9uIGFjdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gYm91bmRcbiAgICAgICAgICA/IFwiZnVsZmlsbGVkXCIgPT09IGJvdW5kLnN0YXR1c1xuICAgICAgICAgICAgPyBjYWxsU2VydmVyKGlkLCBib3VuZC52YWx1ZS5jb25jYXQoYXJncykpXG4gICAgICAgICAgICA6IFByb21pc2UucmVzb2x2ZShib3VuZCkudGhlbihmdW5jdGlvbiAoYm91bmRBcmdzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxTZXJ2ZXIoaWQsIGJvdW5kQXJncy5jb25jYXQoYXJncykpO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgIDogY2FsbFNlcnZlcihpZCwgYXJncyk7XG4gICAgICB9XG4gICAgICB2YXIgaWQgPSBtZXRhRGF0YS5pZCxcbiAgICAgICAgYm91bmQgPSBtZXRhRGF0YS5ib3VuZCxcbiAgICAgICAgbG9jYXRpb24gPSBtZXRhRGF0YS5sb2NhdGlvbjtcbiAgICAgIGlmIChsb2NhdGlvbikge1xuICAgICAgICB2YXIgZnVuY3Rpb25OYW1lID0gbWV0YURhdGEubmFtZSB8fCBcIlwiLFxuICAgICAgICAgIGZpbGVuYW1lID0gbG9jYXRpb25bMV0sXG4gICAgICAgICAgbGluZSA9IGxvY2F0aW9uWzJdO1xuICAgICAgICBsb2NhdGlvbiA9IGxvY2F0aW9uWzNdO1xuICAgICAgICBtZXRhRGF0YSA9IG1ldGFEYXRhLmVudiB8fCBcIlNlcnZlclwiO1xuICAgICAgICBmaW5kU291cmNlTWFwVVJMID1cbiAgICAgICAgICBudWxsID09IGZpbmRTb3VyY2VNYXBVUkxcbiAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgOiBmaW5kU291cmNlTWFwVVJMKGZpbGVuYW1lLCBtZXRhRGF0YSk7XG4gICAgICAgIGFjdGlvbiA9IGNyZWF0ZUZha2VTZXJ2ZXJGdW5jdGlvbihcbiAgICAgICAgICBmdW5jdGlvbk5hbWUsXG4gICAgICAgICAgZmlsZW5hbWUsXG4gICAgICAgICAgZmluZFNvdXJjZU1hcFVSTCxcbiAgICAgICAgICBsaW5lLFxuICAgICAgICAgIGxvY2F0aW9uLFxuICAgICAgICAgIG1ldGFEYXRhLFxuICAgICAgICAgIGFjdGlvblxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmVnaXN0ZXJCb3VuZFNlcnZlclJlZmVyZW5jZShhY3Rpb24sIGlkLCBib3VuZCwgZW5jb2RlRm9ybUFjdGlvbik7XG4gICAgICByZXR1cm4gYWN0aW9uO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZVN0YWNrTG9jYXRpb24oZXJyb3IpIHtcbiAgICAgIGVycm9yID0gZXJyb3Iuc3RhY2s7XG4gICAgICBlcnJvci5zdGFydHNXaXRoKFwiRXJyb3I6IHJlYWN0LXN0YWNrLXRvcC1mcmFtZVxcblwiKSAmJlxuICAgICAgICAoZXJyb3IgPSBlcnJvci5zbGljZSgyOSkpO1xuICAgICAgdmFyIGVuZE9mRmlyc3QgPSBlcnJvci5pbmRleE9mKFwiXFxuXCIpO1xuICAgICAgaWYgKC0xICE9PSBlbmRPZkZpcnN0KSB7XG4gICAgICAgIHZhciBlbmRPZlNlY29uZCA9IGVycm9yLmluZGV4T2YoXCJcXG5cIiwgZW5kT2ZGaXJzdCArIDEpO1xuICAgICAgICBlbmRPZkZpcnN0ID1cbiAgICAgICAgICAtMSA9PT0gZW5kT2ZTZWNvbmRcbiAgICAgICAgICAgID8gZXJyb3Iuc2xpY2UoZW5kT2ZGaXJzdCArIDEpXG4gICAgICAgICAgICA6IGVycm9yLnNsaWNlKGVuZE9mRmlyc3QgKyAxLCBlbmRPZlNlY29uZCk7XG4gICAgICB9IGVsc2UgZW5kT2ZGaXJzdCA9IGVycm9yO1xuICAgICAgZXJyb3IgPSB2OEZyYW1lUmVnRXhwLmV4ZWMoZW5kT2ZGaXJzdCk7XG4gICAgICBpZiAoXG4gICAgICAgICFlcnJvciAmJlxuICAgICAgICAoKGVycm9yID0ganNjU3BpZGVyTW9ua2V5RnJhbWVSZWdFeHAuZXhlYyhlbmRPZkZpcnN0KSksICFlcnJvcilcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBlbmRPZkZpcnN0ID0gZXJyb3JbMV0gfHwgXCJcIjtcbiAgICAgIFwiPGFub255bW91cz5cIiA9PT0gZW5kT2ZGaXJzdCAmJiAoZW5kT2ZGaXJzdCA9IFwiXCIpO1xuICAgICAgZW5kT2ZTZWNvbmQgPSBlcnJvclsyXSB8fCBlcnJvcls1XSB8fCBcIlwiO1xuICAgICAgXCI8YW5vbnltb3VzPlwiID09PSBlbmRPZlNlY29uZCAmJiAoZW5kT2ZTZWNvbmQgPSBcIlwiKTtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIGVuZE9mRmlyc3QsXG4gICAgICAgIGVuZE9mU2Vjb25kLFxuICAgICAgICArKGVycm9yWzNdIHx8IGVycm9yWzZdKSxcbiAgICAgICAgKyhlcnJvcls0XSB8fCBlcnJvcls3XSlcbiAgICAgIF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVNlcnZlclJlZmVyZW5jZSQxKFxuICAgICAgaWQsXG4gICAgICBjYWxsU2VydmVyLFxuICAgICAgZW5jb2RlRm9ybUFjdGlvbixcbiAgICAgIGZpbmRTb3VyY2VNYXBVUkwsXG4gICAgICBmdW5jdGlvbk5hbWVcbiAgICApIHtcbiAgICAgIGZ1bmN0aW9uIGFjdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gY2FsbFNlcnZlcihpZCwgYXJncyk7XG4gICAgICB9XG4gICAgICB2YXIgbG9jYXRpb24gPSBwYXJzZVN0YWNrTG9jYXRpb24oRXJyb3IoXCJyZWFjdC1zdGFjay10b3AtZnJhbWVcIikpO1xuICAgICAgaWYgKG51bGwgIT09IGxvY2F0aW9uKSB7XG4gICAgICAgIHZhciBmaWxlbmFtZSA9IGxvY2F0aW9uWzFdLFxuICAgICAgICAgIGxpbmUgPSBsb2NhdGlvblsyXTtcbiAgICAgICAgbG9jYXRpb24gPSBsb2NhdGlvblszXTtcbiAgICAgICAgZmluZFNvdXJjZU1hcFVSTCA9XG4gICAgICAgICAgbnVsbCA9PSBmaW5kU291cmNlTWFwVVJMXG4gICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgIDogZmluZFNvdXJjZU1hcFVSTChmaWxlbmFtZSwgXCJDbGllbnRcIik7XG4gICAgICAgIGFjdGlvbiA9IGNyZWF0ZUZha2VTZXJ2ZXJGdW5jdGlvbihcbiAgICAgICAgICBmdW5jdGlvbk5hbWUgfHwgXCJcIixcbiAgICAgICAgICBmaWxlbmFtZSxcbiAgICAgICAgICBmaW5kU291cmNlTWFwVVJMLFxuICAgICAgICAgIGxpbmUsXG4gICAgICAgICAgbG9jYXRpb24sXG4gICAgICAgICAgXCJDbGllbnRcIixcbiAgICAgICAgICBhY3Rpb25cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJlZ2lzdGVyQm91bmRTZXJ2ZXJSZWZlcmVuY2UoYWN0aW9uLCBpZCwgbnVsbCwgZW5jb2RlRm9ybUFjdGlvbik7XG4gICAgICByZXR1cm4gYWN0aW9uO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkge1xuICAgICAgaWYgKG51bGwgPT0gdHlwZSkgcmV0dXJuIG51bGw7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgcmV0dXJuIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0VcbiAgICAgICAgICA/IG51bGxcbiAgICAgICAgICA6IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHR5cGUpIHJldHVybiB0eXBlO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJGcmFnbWVudFwiO1xuICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiUHJvZmlsZXJcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN0cmljdE1vZGVcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlTGlzdFwiO1xuICAgICAgICBjYXNlIFJFQUNUX0FDVElWSVRZX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiQWN0aXZpdHlcIjtcbiAgICAgIH1cbiAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgc3dpdGNoIChcbiAgICAgICAgICAoXCJudW1iZXJcIiA9PT0gdHlwZW9mIHR5cGUudGFnICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgdHlwZS4kJHR5cGVvZilcbiAgICAgICAgKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiBcIlBvcnRhbFwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgXCJDb250ZXh0XCI7XG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuICh0eXBlLl9jb250ZXh0LmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiKSArIFwiLkNvbnN1bWVyXCI7XG4gICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgdmFyIGlubmVyVHlwZSA9IHR5cGUucmVuZGVyO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuZGlzcGxheU5hbWU7XG4gICAgICAgICAgICB0eXBlIHx8XG4gICAgICAgICAgICAgICgodHlwZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCBcIlwiKSxcbiAgICAgICAgICAgICAgKHR5cGUgPSBcIlwiICE9PSB0eXBlID8gXCJGb3J3YXJkUmVmKFwiICsgdHlwZSArIFwiKVwiIDogXCJGb3J3YXJkUmVmXCIpKTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKGlubmVyVHlwZSA9IHR5cGUuZGlzcGxheU5hbWUgfHwgbnVsbCksXG4gICAgICAgICAgICAgIG51bGwgIT09IGlubmVyVHlwZVxuICAgICAgICAgICAgICAgID8gaW5uZXJUeXBlXG4gICAgICAgICAgICAgICAgOiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCBcIk1lbW9cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgIGlubmVyVHlwZSA9IHR5cGUuX3BheWxvYWQ7XG4gICAgICAgICAgICB0eXBlID0gdHlwZS5faW5pdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZShpbm5lclR5cGUpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcmVwYXJlU3RhY2tUcmFjZShlcnJvciwgc3RydWN0dXJlZFN0YWNrVHJhY2UpIHtcbiAgICAgIGVycm9yID0gKGVycm9yLm5hbWUgfHwgXCJFcnJvclwiKSArIFwiOiBcIiArIChlcnJvci5tZXNzYWdlIHx8IFwiXCIpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJ1Y3R1cmVkU3RhY2tUcmFjZS5sZW5ndGg7IGkrKylcbiAgICAgICAgZXJyb3IgKz0gXCJcXG4gICAgYXQgXCIgKyBzdHJ1Y3R1cmVkU3RhY2tUcmFjZVtpXS50b1N0cmluZygpO1xuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFjdFByb21pc2Uoc3RhdHVzLCB2YWx1ZSwgcmVhc29uKSB7XG4gICAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIHRoaXMucmVhc29uID0gcmVhc29uO1xuICAgICAgdGhpcy5fZGVidWdJbmZvID0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdW53cmFwV2Vha1Jlc3BvbnNlKHdlYWtSZXNwb25zZSkge1xuICAgICAgd2Vha1Jlc3BvbnNlID0gd2Vha1Jlc3BvbnNlLndlYWsuZGVyZWYoKTtcbiAgICAgIGlmICh2b2lkIDAgPT09IHdlYWtSZXNwb25zZSlcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJXZSBkaWQgbm90IGV4cGVjdCB0byByZWNlaXZlIG5ldyBkYXRhIGFmdGVyIEdDOmluZyB0aGUgcmVzcG9uc2UuXCJcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiB3ZWFrUmVzcG9uc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsZWFudXBEZWJ1Z0NoYW5uZWwoZGVidWdDaGFubmVsKSB7XG4gICAgICBkZWJ1Z0NoYW5uZWwoXCJcIik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlYWRDaHVuayhjaHVuaykge1xuICAgICAgc3dpdGNoIChjaHVuay5zdGF0dXMpIHtcbiAgICAgICAgY2FzZSBcInJlc29sdmVkX21vZGVsXCI6XG4gICAgICAgICAgaW5pdGlhbGl6ZU1vZGVsQ2h1bmsoY2h1bmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicmVzb2x2ZWRfbW9kdWxlXCI6XG4gICAgICAgICAgaW5pdGlhbGl6ZU1vZHVsZUNodW5rKGNodW5rKTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoY2h1bmsuc3RhdHVzKSB7XG4gICAgICAgIGNhc2UgXCJmdWxmaWxsZWRcIjpcbiAgICAgICAgICByZXR1cm4gY2h1bmsudmFsdWU7XG4gICAgICAgIGNhc2UgXCJwZW5kaW5nXCI6XG4gICAgICAgIGNhc2UgXCJibG9ja2VkXCI6XG4gICAgICAgIGNhc2UgXCJoYWx0ZWRcIjpcbiAgICAgICAgICB0aHJvdyBjaHVuaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBjaHVuay5yZWFzb247XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFJvb3Qod2Vha1Jlc3BvbnNlKSB7XG4gICAgICB3ZWFrUmVzcG9uc2UgPSB1bndyYXBXZWFrUmVzcG9uc2Uod2Vha1Jlc3BvbnNlKTtcbiAgICAgIHJldHVybiBnZXRDaHVuayh3ZWFrUmVzcG9uc2UsIDApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVQZW5kaW5nQ2h1bmsocmVzcG9uc2UpIHtcbiAgICAgIDAgPT09IHJlc3BvbnNlLl9wZW5kaW5nQ2h1bmtzKysgJiZcbiAgICAgICAgKChyZXNwb25zZS5fd2Vha1Jlc3BvbnNlLnJlc3BvbnNlID0gcmVzcG9uc2UpLFxuICAgICAgICBudWxsICE9PSByZXNwb25zZS5fcGVuZGluZ0luaXRpYWxSZW5kZXIgJiZcbiAgICAgICAgICAoY2xlYXJUaW1lb3V0KHJlc3BvbnNlLl9wZW5kaW5nSW5pdGlhbFJlbmRlciksXG4gICAgICAgICAgKHJlc3BvbnNlLl9wZW5kaW5nSW5pdGlhbFJlbmRlciA9IG51bGwpKSk7XG4gICAgICByZXR1cm4gbmV3IFJlYWN0UHJvbWlzZShcInBlbmRpbmdcIiwgbnVsbCwgbnVsbCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbGVhc2VQZW5kaW5nQ2h1bmsocmVzcG9uc2UsIGNodW5rKSB7XG4gICAgICBcInBlbmRpbmdcIiA9PT0gY2h1bmsuc3RhdHVzICYmXG4gICAgICAgIDAgPT09IC0tcmVzcG9uc2UuX3BlbmRpbmdDaHVua3MgJiZcbiAgICAgICAgKChyZXNwb25zZS5fd2Vha1Jlc3BvbnNlLnJlc3BvbnNlID0gbnVsbCksXG4gICAgICAgIChyZXNwb25zZS5fcGVuZGluZ0luaXRpYWxSZW5kZXIgPSBzZXRUaW1lb3V0KFxuICAgICAgICAgIGZsdXNoSW5pdGlhbFJlbmRlclBlcmZvcm1hbmNlLmJpbmQobnVsbCwgcmVzcG9uc2UpLFxuICAgICAgICAgIDEwMFxuICAgICAgICApKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdha2VDaHVuayhsaXN0ZW5lcnMsIHZhbHVlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbaV07XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGxpc3RlbmVyXG4gICAgICAgICAgPyBsaXN0ZW5lcih2YWx1ZSlcbiAgICAgICAgICA6IGZ1bGZpbGxSZWZlcmVuY2UobGlzdGVuZXIsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVqZWN0Q2h1bmsobGlzdGVuZXJzLCBlcnJvcikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJzW2ldO1xuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBsaXN0ZW5lclxuICAgICAgICAgID8gbGlzdGVuZXIoZXJyb3IpXG4gICAgICAgICAgOiByZWplY3RSZWZlcmVuY2UobGlzdGVuZXIsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzb2x2ZUJsb2NrZWRDeWNsZShyZXNvbHZlZENodW5rLCByZWZlcmVuY2UpIHtcbiAgICAgIHZhciByZWZlcmVuY2VkQ2h1bmsgPSByZWZlcmVuY2UuaGFuZGxlci5jaHVuaztcbiAgICAgIGlmIChudWxsID09PSByZWZlcmVuY2VkQ2h1bmspIHJldHVybiBudWxsO1xuICAgICAgaWYgKHJlZmVyZW5jZWRDaHVuayA9PT0gcmVzb2x2ZWRDaHVuaykgcmV0dXJuIHJlZmVyZW5jZS5oYW5kbGVyO1xuICAgICAgcmVmZXJlbmNlID0gcmVmZXJlbmNlZENodW5rLnZhbHVlO1xuICAgICAgaWYgKG51bGwgIT09IHJlZmVyZW5jZSlcbiAgICAgICAgZm9yIChcbiAgICAgICAgICByZWZlcmVuY2VkQ2h1bmsgPSAwO1xuICAgICAgICAgIHJlZmVyZW5jZWRDaHVuayA8IHJlZmVyZW5jZS5sZW5ndGg7XG4gICAgICAgICAgcmVmZXJlbmNlZENodW5rKytcbiAgICAgICAgKSB7XG4gICAgICAgICAgdmFyIGxpc3RlbmVyID0gcmVmZXJlbmNlW3JlZmVyZW5jZWRDaHVua107XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgbGlzdGVuZXIgJiZcbiAgICAgICAgICAgICgobGlzdGVuZXIgPSByZXNvbHZlQmxvY2tlZEN5Y2xlKHJlc29sdmVkQ2h1bmssIGxpc3RlbmVyKSksXG4gICAgICAgICAgICBudWxsICE9PSBsaXN0ZW5lcilcbiAgICAgICAgICApXG4gICAgICAgICAgICByZXR1cm4gbGlzdGVuZXI7XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3YWtlQ2h1bmtJZkluaXRpYWxpemVkKGNodW5rLCByZXNvbHZlTGlzdGVuZXJzLCByZWplY3RMaXN0ZW5lcnMpIHtcbiAgICAgIHN3aXRjaCAoY2h1bmsuc3RhdHVzKSB7XG4gICAgICAgIGNhc2UgXCJmdWxmaWxsZWRcIjpcbiAgICAgICAgICB3YWtlQ2h1bmsocmVzb2x2ZUxpc3RlbmVycywgY2h1bmsudmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYmxvY2tlZFwiOlxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzb2x2ZUxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gcmVzb2x2ZUxpc3RlbmVyc1tpXTtcbiAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBsaXN0ZW5lcikge1xuICAgICAgICAgICAgICB2YXIgY3ljbGljSGFuZGxlciA9IHJlc29sdmVCbG9ja2VkQ3ljbGUoY2h1bmssIGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgbnVsbCAhPT0gY3ljbGljSGFuZGxlciAmJlxuICAgICAgICAgICAgICAgIChmdWxmaWxsUmVmZXJlbmNlKGxpc3RlbmVyLCBjeWNsaWNIYW5kbGVyLnZhbHVlKSxcbiAgICAgICAgICAgICAgICByZXNvbHZlTGlzdGVuZXJzLnNwbGljZShpLCAxKSxcbiAgICAgICAgICAgICAgICBpLS0sXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gcmVqZWN0TGlzdGVuZXJzICYmXG4gICAgICAgICAgICAgICAgICAoKGxpc3RlbmVyID0gcmVqZWN0TGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpKSxcbiAgICAgICAgICAgICAgICAgIC0xICE9PSBsaXN0ZW5lciAmJiByZWplY3RMaXN0ZW5lcnMuc3BsaWNlKGxpc3RlbmVyLCAxKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBcInBlbmRpbmdcIjpcbiAgICAgICAgICBpZiAoY2h1bmsudmFsdWUpXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcmVzb2x2ZUxpc3RlbmVycy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgY2h1bmsudmFsdWUucHVzaChyZXNvbHZlTGlzdGVuZXJzW2ldKTtcbiAgICAgICAgICBlbHNlIGNodW5rLnZhbHVlID0gcmVzb2x2ZUxpc3RlbmVycztcbiAgICAgICAgICBpZiAoY2h1bmsucmVhc29uKSB7XG4gICAgICAgICAgICBpZiAocmVqZWN0TGlzdGVuZXJzKVxuICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgIHJlc29sdmVMaXN0ZW5lcnMgPSAwO1xuICAgICAgICAgICAgICAgIHJlc29sdmVMaXN0ZW5lcnMgPCByZWplY3RMaXN0ZW5lcnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHJlc29sdmVMaXN0ZW5lcnMrK1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgY2h1bmsucmVhc29uLnB1c2gocmVqZWN0TGlzdGVuZXJzW3Jlc29sdmVMaXN0ZW5lcnNdKTtcbiAgICAgICAgICB9IGVsc2UgY2h1bmsucmVhc29uID0gcmVqZWN0TGlzdGVuZXJzO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicmVqZWN0ZWRcIjpcbiAgICAgICAgICByZWplY3RMaXN0ZW5lcnMgJiYgcmVqZWN0Q2h1bmsocmVqZWN0TGlzdGVuZXJzLCBjaHVuay5yZWFzb24pO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0cmlnZ2VyRXJyb3JPbkNodW5rKHJlc3BvbnNlLCBjaHVuaywgZXJyb3IpIHtcbiAgICAgIFwicGVuZGluZ1wiICE9PSBjaHVuay5zdGF0dXMgJiYgXCJibG9ja2VkXCIgIT09IGNodW5rLnN0YXR1c1xuICAgICAgICA/IGNodW5rLnJlYXNvbi5lcnJvcihlcnJvcilcbiAgICAgICAgOiAocmVsZWFzZVBlbmRpbmdDaHVuayhyZXNwb25zZSwgY2h1bmspLFxuICAgICAgICAgIChyZXNwb25zZSA9IGNodW5rLnJlYXNvbiksXG4gICAgICAgICAgKGNodW5rLnN0YXR1cyA9IFwicmVqZWN0ZWRcIiksXG4gICAgICAgICAgKGNodW5rLnJlYXNvbiA9IGVycm9yKSxcbiAgICAgICAgICBudWxsICE9PSByZXNwb25zZSAmJiByZWplY3RDaHVuayhyZXNwb25zZSwgZXJyb3IpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlUmVzb2x2ZWRJdGVyYXRvclJlc3VsdENodW5rKHJlc3BvbnNlLCB2YWx1ZSwgZG9uZSkge1xuICAgICAgcmV0dXJuIG5ldyBSZWFjdFByb21pc2UoXG4gICAgICAgIFwicmVzb2x2ZWRfbW9kZWxcIixcbiAgICAgICAgKGRvbmUgPyAne1wiZG9uZVwiOnRydWUsXCJ2YWx1ZVwiOicgOiAne1wiZG9uZVwiOmZhbHNlLFwidmFsdWVcIjonKSArXG4gICAgICAgICAgdmFsdWUgK1xuICAgICAgICAgIFwifVwiLFxuICAgICAgICByZXNwb25zZVxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzb2x2ZUl0ZXJhdG9yUmVzdWx0Q2h1bmsocmVzcG9uc2UsIGNodW5rLCB2YWx1ZSwgZG9uZSkge1xuICAgICAgcmVzb2x2ZU1vZGVsQ2h1bmsoXG4gICAgICAgIHJlc3BvbnNlLFxuICAgICAgICBjaHVuayxcbiAgICAgICAgKGRvbmUgPyAne1wiZG9uZVwiOnRydWUsXCJ2YWx1ZVwiOicgOiAne1wiZG9uZVwiOmZhbHNlLFwidmFsdWVcIjonKSArXG4gICAgICAgICAgdmFsdWUgK1xuICAgICAgICAgIFwifVwiXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNvbHZlTW9kZWxDaHVuayhyZXNwb25zZSwgY2h1bmssIHZhbHVlKSB7XG4gICAgICBpZiAoXCJwZW5kaW5nXCIgIT09IGNodW5rLnN0YXR1cykgY2h1bmsucmVhc29uLmVucXVldWVNb2RlbCh2YWx1ZSk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVsZWFzZVBlbmRpbmdDaHVuayhyZXNwb25zZSwgY2h1bmspO1xuICAgICAgICB2YXIgcmVzb2x2ZUxpc3RlbmVycyA9IGNodW5rLnZhbHVlLFxuICAgICAgICAgIHJlamVjdExpc3RlbmVycyA9IGNodW5rLnJlYXNvbjtcbiAgICAgICAgY2h1bmsuc3RhdHVzID0gXCJyZXNvbHZlZF9tb2RlbFwiO1xuICAgICAgICBjaHVuay52YWx1ZSA9IHZhbHVlO1xuICAgICAgICBjaHVuay5yZWFzb24gPSByZXNwb25zZTtcbiAgICAgICAgbnVsbCAhPT0gcmVzb2x2ZUxpc3RlbmVycyAmJlxuICAgICAgICAgIChpbml0aWFsaXplTW9kZWxDaHVuayhjaHVuayksXG4gICAgICAgICAgd2FrZUNodW5rSWZJbml0aWFsaXplZChjaHVuaywgcmVzb2x2ZUxpc3RlbmVycywgcmVqZWN0TGlzdGVuZXJzKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc29sdmVNb2R1bGVDaHVuayhyZXNwb25zZSwgY2h1bmssIHZhbHVlKSB7XG4gICAgICBpZiAoXCJwZW5kaW5nXCIgPT09IGNodW5rLnN0YXR1cyB8fCBcImJsb2NrZWRcIiA9PT0gY2h1bmsuc3RhdHVzKSB7XG4gICAgICAgIHJlbGVhc2VQZW5kaW5nQ2h1bmsocmVzcG9uc2UsIGNodW5rKTtcbiAgICAgICAgcmVzcG9uc2UgPSBjaHVuay52YWx1ZTtcbiAgICAgICAgdmFyIHJlamVjdExpc3RlbmVycyA9IGNodW5rLnJlYXNvbjtcbiAgICAgICAgY2h1bmsuc3RhdHVzID0gXCJyZXNvbHZlZF9tb2R1bGVcIjtcbiAgICAgICAgY2h1bmsudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgbnVsbCAhPT0gcmVzcG9uc2UgJiZcbiAgICAgICAgICAoaW5pdGlhbGl6ZU1vZHVsZUNodW5rKGNodW5rKSxcbiAgICAgICAgICB3YWtlQ2h1bmtJZkluaXRpYWxpemVkKGNodW5rLCByZXNwb25zZSwgcmVqZWN0TGlzdGVuZXJzKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGluaXRpYWxpemVNb2RlbENodW5rKGNodW5rKSB7XG4gICAgICB2YXIgcHJldkhhbmRsZXIgPSBpbml0aWFsaXppbmdIYW5kbGVyO1xuICAgICAgaW5pdGlhbGl6aW5nSGFuZGxlciA9IG51bGw7XG4gICAgICB2YXIgcmVzb2x2ZWRNb2RlbCA9IGNodW5rLnZhbHVlLFxuICAgICAgICByZXNwb25zZSA9IGNodW5rLnJlYXNvbjtcbiAgICAgIGNodW5rLnN0YXR1cyA9IFwiYmxvY2tlZFwiO1xuICAgICAgY2h1bmsudmFsdWUgPSBudWxsO1xuICAgICAgY2h1bmsucmVhc29uID0gbnVsbDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IEpTT04ucGFyc2UocmVzb2x2ZWRNb2RlbCwgcmVzcG9uc2UuX2Zyb21KU09OKSxcbiAgICAgICAgICByZXNvbHZlTGlzdGVuZXJzID0gY2h1bmsudmFsdWU7XG4gICAgICAgIG51bGwgIT09IHJlc29sdmVMaXN0ZW5lcnMgJiZcbiAgICAgICAgICAoKGNodW5rLnZhbHVlID0gbnVsbCksXG4gICAgICAgICAgKGNodW5rLnJlYXNvbiA9IG51bGwpLFxuICAgICAgICAgIHdha2VDaHVuayhyZXNvbHZlTGlzdGVuZXJzLCB2YWx1ZSkpO1xuICAgICAgICBpZiAobnVsbCAhPT0gaW5pdGlhbGl6aW5nSGFuZGxlcikge1xuICAgICAgICAgIGlmIChpbml0aWFsaXppbmdIYW5kbGVyLmVycm9yZWQpIHRocm93IGluaXRpYWxpemluZ0hhbmRsZXIudmFsdWU7XG4gICAgICAgICAgaWYgKDAgPCBpbml0aWFsaXppbmdIYW5kbGVyLmRlcHMpIHtcbiAgICAgICAgICAgIGluaXRpYWxpemluZ0hhbmRsZXIudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIGluaXRpYWxpemluZ0hhbmRsZXIuY2h1bmsgPSBjaHVuaztcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2h1bmsuc3RhdHVzID0gXCJmdWxmaWxsZWRcIjtcbiAgICAgICAgY2h1bmsudmFsdWUgPSB2YWx1ZTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIChjaHVuay5zdGF0dXMgPSBcInJlamVjdGVkXCIpLCAoY2h1bmsucmVhc29uID0gZXJyb3IpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaW5pdGlhbGl6aW5nSGFuZGxlciA9IHByZXZIYW5kbGVyO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBpbml0aWFsaXplTW9kdWxlQ2h1bmsoY2h1bmspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlcXVpcmVNb2R1bGUoY2h1bmsudmFsdWUpO1xuICAgICAgICBjaHVuay5zdGF0dXMgPSBcImZ1bGZpbGxlZFwiO1xuICAgICAgICBjaHVuay52YWx1ZSA9IHZhbHVlO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgKGNodW5rLnN0YXR1cyA9IFwicmVqZWN0ZWRcIiksIChjaHVuay5yZWFzb24gPSBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcG9ydEdsb2JhbEVycm9yKHdlYWtSZXNwb25zZSwgZXJyb3IpIHtcbiAgICAgIGlmICh2b2lkIDAgIT09IHdlYWtSZXNwb25zZS53ZWFrLmRlcmVmKCkpIHtcbiAgICAgICAgdmFyIHJlc3BvbnNlID0gdW53cmFwV2Vha1Jlc3BvbnNlKHdlYWtSZXNwb25zZSk7XG4gICAgICAgIHJlc3BvbnNlLl9jbG9zZWQgPSAhMDtcbiAgICAgICAgcmVzcG9uc2UuX2Nsb3NlZFJlYXNvbiA9IGVycm9yO1xuICAgICAgICByZXNwb25zZS5fY2h1bmtzLmZvckVhY2goZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgICAgXCJwZW5kaW5nXCIgPT09IGNodW5rLnN0YXR1cyAmJlxuICAgICAgICAgICAgdHJpZ2dlckVycm9yT25DaHVuayhyZXNwb25zZSwgY2h1bmssIGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHdlYWtSZXNwb25zZSA9IHJlc3BvbnNlLl9kZWJ1Z0NoYW5uZWw7XG4gICAgICAgIHZvaWQgMCAhPT0gd2Vha1Jlc3BvbnNlICYmXG4gICAgICAgICAgKHdlYWtSZXNwb25zZShcIlwiKSwgKHJlc3BvbnNlLl9kZWJ1Z0NoYW5uZWwgPSB2b2lkIDApKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbnVsbFJlZkdldHRlcigpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRUYXNrTmFtZSh0eXBlKSB7XG4gICAgICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkgcmV0dXJuIFwiPD5cIjtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlKSByZXR1cm4gJ1widXNlIGNsaWVudFwiJztcbiAgICAgIGlmIChcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUgJiZcbiAgICAgICAgbnVsbCAhPT0gdHlwZSAmJlxuICAgICAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEVcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIHR5cGUuX2luaXQgPT09IHJlYWRDaHVuayA/ICdcInVzZSBjbGllbnRcIicgOiBcIjwuLi4+XCI7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcbiAgICAgICAgcmV0dXJuIG5hbWUgPyBcIjxcIiArIG5hbWUgKyBcIj5cIiA6IFwiPC4uLj5cIjtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgcmV0dXJuIFwiPC4uLj5cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaW5pdGlhbGl6ZUVsZW1lbnQocmVzcG9uc2UsIGVsZW1lbnQpIHtcbiAgICAgIHZhciBzdGFjayA9IGVsZW1lbnQuX2RlYnVnU3RhY2ssXG4gICAgICAgIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICBudWxsID09PSBvd25lciAmJiAoZWxlbWVudC5fb3duZXIgPSByZXNwb25zZS5fZGVidWdSb290T3duZXIpO1xuICAgICAgdmFyIGVudiA9IHJlc3BvbnNlLl9yb290RW52aXJvbm1lbnROYW1lO1xuICAgICAgbnVsbCAhPT0gb3duZXIgJiYgbnVsbCAhPSBvd25lci5lbnYgJiYgKGVudiA9IG93bmVyLmVudik7XG4gICAgICB2YXIgbm9ybWFsaXplZFN0YWNrVHJhY2UgPSBudWxsO1xuICAgICAgbnVsbCA9PT0gb3duZXIgJiYgbnVsbCAhPSByZXNwb25zZS5fZGVidWdSb290U3RhY2tcbiAgICAgICAgPyAobm9ybWFsaXplZFN0YWNrVHJhY2UgPSByZXNwb25zZS5fZGVidWdSb290U3RhY2spXG4gICAgICAgIDogbnVsbCAhPT0gc3RhY2sgJiZcbiAgICAgICAgICAobm9ybWFsaXplZFN0YWNrVHJhY2UgPSBjcmVhdGVGYWtlSlNYQ2FsbFN0YWNrSW5ERVYoXG4gICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgIHN0YWNrLFxuICAgICAgICAgICAgZW52XG4gICAgICAgICAgKSk7XG4gICAgICBlbGVtZW50Ll9kZWJ1Z1N0YWNrID0gbm9ybWFsaXplZFN0YWNrVHJhY2U7XG4gICAgICBub3JtYWxpemVkU3RhY2tUcmFjZSA9IG51bGw7XG4gICAgICBzdXBwb3J0c0NyZWF0ZVRhc2sgJiZcbiAgICAgICAgbnVsbCAhPT0gc3RhY2sgJiZcbiAgICAgICAgKChub3JtYWxpemVkU3RhY2tUcmFjZSA9IGNvbnNvbGUuY3JlYXRlVGFzay5iaW5kKFxuICAgICAgICAgIGNvbnNvbGUsXG4gICAgICAgICAgZ2V0VGFza05hbWUoZWxlbWVudC50eXBlKVxuICAgICAgICApKSxcbiAgICAgICAgKHN0YWNrID0gYnVpbGRGYWtlQ2FsbFN0YWNrKFxuICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgIHN0YWNrLFxuICAgICAgICAgIGVudixcbiAgICAgICAgICAhMSxcbiAgICAgICAgICBub3JtYWxpemVkU3RhY2tUcmFjZVxuICAgICAgICApKSxcbiAgICAgICAgKGVudiA9IG51bGwgPT09IG93bmVyID8gbnVsbCA6IGluaXRpYWxpemVGYWtlVGFzayhyZXNwb25zZSwgb3duZXIpKSxcbiAgICAgICAgbnVsbCA9PT0gZW52XG4gICAgICAgICAgPyAoKGVudiA9IHJlc3BvbnNlLl9kZWJ1Z1Jvb3RUYXNrKSxcbiAgICAgICAgICAgIChub3JtYWxpemVkU3RhY2tUcmFjZSA9IG51bGwgIT0gZW52ID8gZW52LnJ1bihzdGFjaykgOiBzdGFjaygpKSlcbiAgICAgICAgICA6IChub3JtYWxpemVkU3RhY2tUcmFjZSA9IGVudi5ydW4oc3RhY2spKSk7XG4gICAgICBlbGVtZW50Ll9kZWJ1Z1Rhc2sgPSBub3JtYWxpemVkU3RhY2tUcmFjZTtcbiAgICAgIG51bGwgIT09IG93bmVyICYmIGluaXRpYWxpemVGYWtlU3RhY2socmVzcG9uc2UsIG93bmVyKTtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUxhenlDaHVua1dyYXBwZXIoY2h1bmspIHtcbiAgICAgIHZhciBsYXp5VHlwZSA9IHtcbiAgICAgICAgJCR0eXBlb2Y6IFJFQUNUX0xBWllfVFlQRSxcbiAgICAgICAgX3BheWxvYWQ6IGNodW5rLFxuICAgICAgICBfaW5pdDogcmVhZENodW5rXG4gICAgICB9O1xuICAgICAgY2h1bmsgPSBjaHVuay5fZGVidWdJbmZvIHx8IChjaHVuay5fZGVidWdJbmZvID0gW10pO1xuICAgICAgbGF6eVR5cGUuX2RlYnVnSW5mbyA9IGNodW5rO1xuICAgICAgcmV0dXJuIGxhenlUeXBlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRDaHVuayhyZXNwb25zZSwgaWQpIHtcbiAgICAgIHZhciBjaHVua3MgPSByZXNwb25zZS5fY2h1bmtzLFxuICAgICAgICBjaHVuayA9IGNodW5rcy5nZXQoaWQpO1xuICAgICAgY2h1bmsgfHxcbiAgICAgICAgKChjaHVuayA9IHJlc3BvbnNlLl9jbG9zZWRcbiAgICAgICAgICA/IG5ldyBSZWFjdFByb21pc2UoXCJyZWplY3RlZFwiLCBudWxsLCByZXNwb25zZS5fY2xvc2VkUmVhc29uKVxuICAgICAgICAgIDogY3JlYXRlUGVuZGluZ0NodW5rKHJlc3BvbnNlKSksXG4gICAgICAgIGNodW5rcy5zZXQoaWQsIGNodW5rKSk7XG4gICAgICByZXR1cm4gY2h1bms7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZ1bGZpbGxSZWZlcmVuY2UocmVmZXJlbmNlLCB2YWx1ZSkge1xuICAgICAgZm9yIChcbiAgICAgICAgdmFyIHJlc3BvbnNlID0gcmVmZXJlbmNlLnJlc3BvbnNlLFxuICAgICAgICAgIGhhbmRsZXIgPSByZWZlcmVuY2UuaGFuZGxlcixcbiAgICAgICAgICBwYXJlbnRPYmplY3QgPSByZWZlcmVuY2UucGFyZW50T2JqZWN0LFxuICAgICAgICAgIGtleSA9IHJlZmVyZW5jZS5rZXksXG4gICAgICAgICAgbWFwID0gcmVmZXJlbmNlLm1hcCxcbiAgICAgICAgICBwYXRoID0gcmVmZXJlbmNlLnBhdGgsXG4gICAgICAgICAgaSA9IDE7XG4gICAgICAgIGkgPCBwYXRoLmxlbmd0aDtcbiAgICAgICAgaSsrXG4gICAgICApIHtcbiAgICAgICAgZm9yICg7IHZhbHVlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEU7IClcbiAgICAgICAgICBpZiAoKCh2YWx1ZSA9IHZhbHVlLl9wYXlsb2FkKSwgdmFsdWUgPT09IGhhbmRsZXIuY2h1bmspKVxuICAgICAgICAgICAgdmFsdWUgPSBoYW5kbGVyLnZhbHVlO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3dpdGNoICh2YWx1ZS5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgY2FzZSBcInJlc29sdmVkX21vZGVsXCI6XG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6ZU1vZGVsQ2h1bmsodmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwicmVzb2x2ZWRfbW9kdWxlXCI6XG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6ZU1vZHVsZUNodW5rKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAodmFsdWUuc3RhdHVzKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJmdWxmaWxsZWRcIjpcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnZhbHVlO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICBjYXNlIFwiYmxvY2tlZFwiOlxuICAgICAgICAgICAgICAgIHZhciBjeWNsaWNIYW5kbGVyID0gcmVzb2x2ZUJsb2NrZWRDeWNsZSh2YWx1ZSwgcmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgICBpZiAobnVsbCAhPT0gY3ljbGljSGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjeWNsaWNIYW5kbGVyLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIFwicGVuZGluZ1wiOlxuICAgICAgICAgICAgICAgIHBhdGguc3BsaWNlKDAsIGkgLSAxKTtcbiAgICAgICAgICAgICAgICBudWxsID09PSB2YWx1ZS52YWx1ZVxuICAgICAgICAgICAgICAgICAgPyAodmFsdWUudmFsdWUgPSBbcmVmZXJlbmNlXSlcbiAgICAgICAgICAgICAgICAgIDogdmFsdWUudmFsdWUucHVzaChyZWZlcmVuY2UpO1xuICAgICAgICAgICAgICAgIG51bGwgPT09IHZhbHVlLnJlYXNvblxuICAgICAgICAgICAgICAgICAgPyAodmFsdWUucmVhc29uID0gW3JlZmVyZW5jZV0pXG4gICAgICAgICAgICAgICAgICA6IHZhbHVlLnJlYXNvbi5wdXNoKHJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICBjYXNlIFwiaGFsdGVkXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlamVjdFJlZmVyZW5jZShyZWZlcmVuY2UsIHZhbHVlLnJlYXNvbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgdmFsdWUgPSB2YWx1ZVtwYXRoW2ldXTtcbiAgICAgIH1cbiAgICAgIHJlZmVyZW5jZSA9IG1hcChyZXNwb25zZSwgdmFsdWUsIHBhcmVudE9iamVjdCwga2V5KTtcbiAgICAgIHBhcmVudE9iamVjdFtrZXldID0gcmVmZXJlbmNlO1xuICAgICAgXCJcIiA9PT0ga2V5ICYmIG51bGwgPT09IGhhbmRsZXIudmFsdWUgJiYgKGhhbmRsZXIudmFsdWUgPSByZWZlcmVuY2UpO1xuICAgICAgaWYgKFxuICAgICAgICBwYXJlbnRPYmplY3RbMF0gPT09IFJFQUNUX0VMRU1FTlRfVFlQRSAmJlxuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgaGFuZGxlci52YWx1ZSAmJlxuICAgICAgICBudWxsICE9PSBoYW5kbGVyLnZhbHVlICYmXG4gICAgICAgIGhhbmRsZXIudmFsdWUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRVxuICAgICAgKVxuICAgICAgICBzd2l0Y2ggKCgocGFyZW50T2JqZWN0ID0gaGFuZGxlci52YWx1ZSksIGtleSkpIHtcbiAgICAgICAgICBjYXNlIFwiM1wiOlxuICAgICAgICAgICAgcGFyZW50T2JqZWN0LnByb3BzID0gcmVmZXJlbmNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIjRcIjpcbiAgICAgICAgICAgIHBhcmVudE9iamVjdC5fb3duZXIgPSByZWZlcmVuY2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiNVwiOlxuICAgICAgICAgICAgcGFyZW50T2JqZWN0Ll9kZWJ1Z1N0YWNrID0gcmVmZXJlbmNlO1xuICAgICAgICB9XG4gICAgICBoYW5kbGVyLmRlcHMtLTtcbiAgICAgIDAgPT09IGhhbmRsZXIuZGVwcyAmJlxuICAgICAgICAoKGtleSA9IGhhbmRsZXIuY2h1bmspLFxuICAgICAgICBudWxsICE9PSBrZXkgJiZcbiAgICAgICAgICBcImJsb2NrZWRcIiA9PT0ga2V5LnN0YXR1cyAmJlxuICAgICAgICAgICgocGFyZW50T2JqZWN0ID0ga2V5LnZhbHVlKSxcbiAgICAgICAgICAoa2V5LnN0YXR1cyA9IFwiZnVsZmlsbGVkXCIpLFxuICAgICAgICAgIChrZXkudmFsdWUgPSBoYW5kbGVyLnZhbHVlKSxcbiAgICAgICAgICBudWxsICE9PSBwYXJlbnRPYmplY3QgJiYgd2FrZUNodW5rKHBhcmVudE9iamVjdCwgaGFuZGxlci52YWx1ZSkpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVqZWN0UmVmZXJlbmNlKHJlZmVyZW5jZSwgZXJyb3IpIHtcbiAgICAgIHZhciBoYW5kbGVyID0gcmVmZXJlbmNlLmhhbmRsZXI7XG4gICAgICByZWZlcmVuY2UgPSByZWZlcmVuY2UucmVzcG9uc2U7XG4gICAgICBpZiAoIWhhbmRsZXIuZXJyb3JlZCkge1xuICAgICAgICB2YXIgYmxvY2tlZFZhbHVlID0gaGFuZGxlci52YWx1ZTtcbiAgICAgICAgaGFuZGxlci5lcnJvcmVkID0gITA7XG4gICAgICAgIGhhbmRsZXIudmFsdWUgPSBlcnJvcjtcbiAgICAgICAgaGFuZGxlciA9IGhhbmRsZXIuY2h1bms7XG4gICAgICAgIGlmIChudWxsICE9PSBoYW5kbGVyICYmIFwiYmxvY2tlZFwiID09PSBoYW5kbGVyLnN0YXR1cykge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBibG9ja2VkVmFsdWUgJiZcbiAgICAgICAgICAgIG51bGwgIT09IGJsb2NrZWRWYWx1ZSAmJlxuICAgICAgICAgICAgYmxvY2tlZFZhbHVlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEVcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciBlcnJvcmVkQ29tcG9uZW50ID0ge1xuICAgICAgICAgICAgICBuYW1lOiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoYmxvY2tlZFZhbHVlLnR5cGUpIHx8IFwiXCIsXG4gICAgICAgICAgICAgIG93bmVyOiBibG9ja2VkVmFsdWUuX293bmVyXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXJyb3JlZENvbXBvbmVudC5kZWJ1Z1N0YWNrID0gYmxvY2tlZFZhbHVlLl9kZWJ1Z1N0YWNrO1xuICAgICAgICAgICAgc3VwcG9ydHNDcmVhdGVUYXNrICYmXG4gICAgICAgICAgICAgIChlcnJvcmVkQ29tcG9uZW50LmRlYnVnVGFzayA9IGJsb2NrZWRWYWx1ZS5fZGVidWdUYXNrKTtcbiAgICAgICAgICAgIChoYW5kbGVyLl9kZWJ1Z0luZm8gfHwgKGhhbmRsZXIuX2RlYnVnSW5mbyA9IFtdKSkucHVzaChcbiAgICAgICAgICAgICAgZXJyb3JlZENvbXBvbmVudFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJpZ2dlckVycm9yT25DaHVuayhyZWZlcmVuY2UsIGhhbmRsZXIsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB3YWl0Rm9yUmVmZXJlbmNlKFxuICAgICAgcmVmZXJlbmNlZENodW5rLFxuICAgICAgcGFyZW50T2JqZWN0LFxuICAgICAga2V5LFxuICAgICAgcmVzcG9uc2UsXG4gICAgICBtYXAsXG4gICAgICBwYXRoXG4gICAgKSB7XG4gICAgICBpZiAoaW5pdGlhbGl6aW5nSGFuZGxlcikge1xuICAgICAgICB2YXIgaGFuZGxlciA9IGluaXRpYWxpemluZ0hhbmRsZXI7XG4gICAgICAgIGhhbmRsZXIuZGVwcysrO1xuICAgICAgfSBlbHNlXG4gICAgICAgIGhhbmRsZXIgPSBpbml0aWFsaXppbmdIYW5kbGVyID0ge1xuICAgICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgICBjaHVuazogbnVsbCxcbiAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICBkZXBzOiAxLFxuICAgICAgICAgIGVycm9yZWQ6ICExXG4gICAgICAgIH07XG4gICAgICBwYXJlbnRPYmplY3QgPSB7XG4gICAgICAgIHJlc3BvbnNlOiByZXNwb25zZSxcbiAgICAgICAgaGFuZGxlcjogaGFuZGxlcixcbiAgICAgICAgcGFyZW50T2JqZWN0OiBwYXJlbnRPYmplY3QsXG4gICAgICAgIGtleToga2V5LFxuICAgICAgICBtYXA6IG1hcCxcbiAgICAgICAgcGF0aDogcGF0aFxuICAgICAgfTtcbiAgICAgIG51bGwgPT09IHJlZmVyZW5jZWRDaHVuay52YWx1ZVxuICAgICAgICA/IChyZWZlcmVuY2VkQ2h1bmsudmFsdWUgPSBbcGFyZW50T2JqZWN0XSlcbiAgICAgICAgOiByZWZlcmVuY2VkQ2h1bmsudmFsdWUucHVzaChwYXJlbnRPYmplY3QpO1xuICAgICAgbnVsbCA9PT0gcmVmZXJlbmNlZENodW5rLnJlYXNvblxuICAgICAgICA/IChyZWZlcmVuY2VkQ2h1bmsucmVhc29uID0gW3BhcmVudE9iamVjdF0pXG4gICAgICAgIDogcmVmZXJlbmNlZENodW5rLnJlYXNvbi5wdXNoKHBhcmVudE9iamVjdCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbG9hZFNlcnZlclJlZmVyZW5jZShyZXNwb25zZSwgbWV0YURhdGEsIHBhcmVudE9iamVjdCwga2V5KSB7XG4gICAgICBpZiAoIXJlc3BvbnNlLl9zZXJ2ZXJSZWZlcmVuY2VDb25maWcpXG4gICAgICAgIHJldHVybiBjcmVhdGVCb3VuZFNlcnZlclJlZmVyZW5jZShcbiAgICAgICAgICBtZXRhRGF0YSxcbiAgICAgICAgICByZXNwb25zZS5fY2FsbFNlcnZlcixcbiAgICAgICAgICByZXNwb25zZS5fZW5jb2RlRm9ybUFjdGlvbixcbiAgICAgICAgICByZXNwb25zZS5fZGVidWdGaW5kU291cmNlTWFwVVJMXG4gICAgICAgICk7XG4gICAgICB2YXIgc2VydmVyUmVmZXJlbmNlID0gcmVzb2x2ZVNlcnZlclJlZmVyZW5jZShcbiAgICAgICAgICByZXNwb25zZS5fc2VydmVyUmVmZXJlbmNlQ29uZmlnLFxuICAgICAgICAgIG1ldGFEYXRhLmlkXG4gICAgICAgICksXG4gICAgICAgIHByb21pc2UgPSBwcmVsb2FkTW9kdWxlKHNlcnZlclJlZmVyZW5jZSk7XG4gICAgICBpZiAocHJvbWlzZSlcbiAgICAgICAgbWV0YURhdGEuYm91bmQgJiYgKHByb21pc2UgPSBQcm9taXNlLmFsbChbcHJvbWlzZSwgbWV0YURhdGEuYm91bmRdKSk7XG4gICAgICBlbHNlIGlmIChtZXRhRGF0YS5ib3VuZCkgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShtZXRhRGF0YS5ib3VuZCk7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgKHByb21pc2UgPSByZXF1aXJlTW9kdWxlKHNlcnZlclJlZmVyZW5jZSkpLFxuICAgICAgICAgIHJlZ2lzdGVyQm91bmRTZXJ2ZXJSZWZlcmVuY2UoXG4gICAgICAgICAgICBwcm9taXNlLFxuICAgICAgICAgICAgbWV0YURhdGEuaWQsXG4gICAgICAgICAgICBtZXRhRGF0YS5ib3VuZCxcbiAgICAgICAgICAgIHJlc3BvbnNlLl9lbmNvZGVGb3JtQWN0aW9uXG4gICAgICAgICAgKSxcbiAgICAgICAgICBwcm9taXNlXG4gICAgICAgICk7XG4gICAgICBpZiAoaW5pdGlhbGl6aW5nSGFuZGxlcikge1xuICAgICAgICB2YXIgaGFuZGxlciA9IGluaXRpYWxpemluZ0hhbmRsZXI7XG4gICAgICAgIGhhbmRsZXIuZGVwcysrO1xuICAgICAgfSBlbHNlXG4gICAgICAgIGhhbmRsZXIgPSBpbml0aWFsaXppbmdIYW5kbGVyID0ge1xuICAgICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgICBjaHVuazogbnVsbCxcbiAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICBkZXBzOiAxLFxuICAgICAgICAgIGVycm9yZWQ6ICExXG4gICAgICAgIH07XG4gICAgICBwcm9taXNlLnRoZW4oXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgcmVzb2x2ZWRWYWx1ZSA9IHJlcXVpcmVNb2R1bGUoc2VydmVyUmVmZXJlbmNlKTtcbiAgICAgICAgICBpZiAobWV0YURhdGEuYm91bmQpIHtcbiAgICAgICAgICAgIHZhciBib3VuZEFyZ3MgPSBtZXRhRGF0YS5ib3VuZC52YWx1ZS5zbGljZSgwKTtcbiAgICAgICAgICAgIGJvdW5kQXJncy51bnNoaWZ0KG51bGwpO1xuICAgICAgICAgICAgcmVzb2x2ZWRWYWx1ZSA9IHJlc29sdmVkVmFsdWUuYmluZC5hcHBseShyZXNvbHZlZFZhbHVlLCBib3VuZEFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZWdpc3RlckJvdW5kU2VydmVyUmVmZXJlbmNlKFxuICAgICAgICAgICAgcmVzb2x2ZWRWYWx1ZSxcbiAgICAgICAgICAgIG1ldGFEYXRhLmlkLFxuICAgICAgICAgICAgbWV0YURhdGEuYm91bmQsXG4gICAgICAgICAgICByZXNwb25zZS5fZW5jb2RlRm9ybUFjdGlvblxuICAgICAgICAgICk7XG4gICAgICAgICAgcGFyZW50T2JqZWN0W2tleV0gPSByZXNvbHZlZFZhbHVlO1xuICAgICAgICAgIFwiXCIgPT09IGtleSAmJlxuICAgICAgICAgICAgbnVsbCA9PT0gaGFuZGxlci52YWx1ZSAmJlxuICAgICAgICAgICAgKGhhbmRsZXIudmFsdWUgPSByZXNvbHZlZFZhbHVlKTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBwYXJlbnRPYmplY3RbMF0gPT09IFJFQUNUX0VMRU1FTlRfVFlQRSAmJlxuICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGhhbmRsZXIudmFsdWUgJiZcbiAgICAgICAgICAgIG51bGwgIT09IGhhbmRsZXIudmFsdWUgJiZcbiAgICAgICAgICAgIGhhbmRsZXIudmFsdWUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRVxuICAgICAgICAgIClcbiAgICAgICAgICAgIHN3aXRjaCAoKChib3VuZEFyZ3MgPSBoYW5kbGVyLnZhbHVlKSwga2V5KSkge1xuICAgICAgICAgICAgICBjYXNlIFwiM1wiOlxuICAgICAgICAgICAgICAgIGJvdW5kQXJncy5wcm9wcyA9IHJlc29sdmVkVmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCI0XCI6XG4gICAgICAgICAgICAgICAgYm91bmRBcmdzLl9vd25lciA9IHJlc29sdmVkVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgaGFuZGxlci5kZXBzLS07XG4gICAgICAgICAgMCA9PT0gaGFuZGxlci5kZXBzICYmXG4gICAgICAgICAgICAoKHJlc29sdmVkVmFsdWUgPSBoYW5kbGVyLmNodW5rKSxcbiAgICAgICAgICAgIG51bGwgIT09IHJlc29sdmVkVmFsdWUgJiZcbiAgICAgICAgICAgICAgXCJibG9ja2VkXCIgPT09IHJlc29sdmVkVmFsdWUuc3RhdHVzICYmXG4gICAgICAgICAgICAgICgoYm91bmRBcmdzID0gcmVzb2x2ZWRWYWx1ZS52YWx1ZSksXG4gICAgICAgICAgICAgIChyZXNvbHZlZFZhbHVlLnN0YXR1cyA9IFwiZnVsZmlsbGVkXCIpLFxuICAgICAgICAgICAgICAocmVzb2x2ZWRWYWx1ZS52YWx1ZSA9IGhhbmRsZXIudmFsdWUpLFxuICAgICAgICAgICAgICBudWxsICE9PSBib3VuZEFyZ3MgJiYgd2FrZUNodW5rKGJvdW5kQXJncywgaGFuZGxlci52YWx1ZSkpKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgaWYgKCFoYW5kbGVyLmVycm9yZWQpIHtcbiAgICAgICAgICAgIHZhciBibG9ja2VkVmFsdWUgPSBoYW5kbGVyLnZhbHVlO1xuICAgICAgICAgICAgaGFuZGxlci5lcnJvcmVkID0gITA7XG4gICAgICAgICAgICBoYW5kbGVyLnZhbHVlID0gZXJyb3I7XG4gICAgICAgICAgICB2YXIgY2h1bmsgPSBoYW5kbGVyLmNodW5rO1xuICAgICAgICAgICAgaWYgKG51bGwgIT09IGNodW5rICYmIFwiYmxvY2tlZFwiID09PSBjaHVuay5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBibG9ja2VkVmFsdWUgJiZcbiAgICAgICAgICAgICAgICBudWxsICE9PSBibG9ja2VkVmFsdWUgJiZcbiAgICAgICAgICAgICAgICBibG9ja2VkVmFsdWUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3JlZENvbXBvbmVudCA9IHtcbiAgICAgICAgICAgICAgICAgIG5hbWU6IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShibG9ja2VkVmFsdWUudHlwZSkgfHwgXCJcIixcbiAgICAgICAgICAgICAgICAgIG93bmVyOiBibG9ja2VkVmFsdWUuX293bmVyXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBlcnJvcmVkQ29tcG9uZW50LmRlYnVnU3RhY2sgPSBibG9ja2VkVmFsdWUuX2RlYnVnU3RhY2s7XG4gICAgICAgICAgICAgICAgc3VwcG9ydHNDcmVhdGVUYXNrICYmXG4gICAgICAgICAgICAgICAgICAoZXJyb3JlZENvbXBvbmVudC5kZWJ1Z1Rhc2sgPSBibG9ja2VkVmFsdWUuX2RlYnVnVGFzayk7XG4gICAgICAgICAgICAgICAgKGNodW5rLl9kZWJ1Z0luZm8gfHwgKGNodW5rLl9kZWJ1Z0luZm8gPSBbXSkpLnB1c2goXG4gICAgICAgICAgICAgICAgICBlcnJvcmVkQ29tcG9uZW50XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0cmlnZ2VyRXJyb3JPbkNodW5rKHJlc3BvbnNlLCBjaHVuaywgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRPdXRsaW5lZE1vZGVsKHJlc3BvbnNlLCByZWZlcmVuY2UsIHBhcmVudE9iamVjdCwga2V5LCBtYXApIHtcbiAgICAgIHJlZmVyZW5jZSA9IHJlZmVyZW5jZS5zcGxpdChcIjpcIik7XG4gICAgICB2YXIgaWQgPSBwYXJzZUludChyZWZlcmVuY2VbMF0sIDE2KTtcbiAgICAgIGlkID0gZ2V0Q2h1bmsocmVzcG9uc2UsIGlkKTtcbiAgICAgIHN3aXRjaCAoaWQuc3RhdHVzKSB7XG4gICAgICAgIGNhc2UgXCJyZXNvbHZlZF9tb2RlbFwiOlxuICAgICAgICAgIGluaXRpYWxpemVNb2RlbENodW5rKGlkKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInJlc29sdmVkX21vZHVsZVwiOlxuICAgICAgICAgIGluaXRpYWxpemVNb2R1bGVDaHVuayhpZCk7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGlkLnN0YXR1cykge1xuICAgICAgICBjYXNlIFwiZnVsZmlsbGVkXCI6XG4gICAgICAgICAgZm9yICh2YXIgdmFsdWUgPSBpZC52YWx1ZSwgaSA9IDE7IGkgPCByZWZlcmVuY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAoOyB2YWx1ZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFOyApIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5fcGF5bG9hZDtcbiAgICAgICAgICAgICAgc3dpdGNoICh2YWx1ZS5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwicmVzb2x2ZWRfbW9kZWxcIjpcbiAgICAgICAgICAgICAgICAgIGluaXRpYWxpemVNb2RlbENodW5rKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJyZXNvbHZlZF9tb2R1bGVcIjpcbiAgICAgICAgICAgICAgICAgIGluaXRpYWxpemVNb2R1bGVDaHVuayh2YWx1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3dpdGNoICh2YWx1ZS5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZnVsZmlsbGVkXCI6XG4gICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImJsb2NrZWRcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwicGVuZGluZ1wiOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHdhaXRGb3JSZWZlcmVuY2UoXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRPYmplY3QsXG4gICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIG1hcCxcbiAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlLnNsaWNlKGkgLSAxKVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiaGFsdGVkXCI6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICBpbml0aWFsaXppbmdIYW5kbGVyXG4gICAgICAgICAgICAgICAgICAgICAgPyAoKHJlc3BvbnNlID0gaW5pdGlhbGl6aW5nSGFuZGxlciksIHJlc3BvbnNlLmRlcHMrKylcbiAgICAgICAgICAgICAgICAgICAgICA6IChpbml0aWFsaXppbmdIYW5kbGVyID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGVwczogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JlZDogITFcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICBpbml0aWFsaXppbmdIYW5kbGVyXG4gICAgICAgICAgICAgICAgICAgICAgPyAoKGluaXRpYWxpemluZ0hhbmRsZXIuZXJyb3JlZCA9ICEwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIChpbml0aWFsaXppbmdIYW5kbGVyLnZhbHVlID0gdmFsdWUucmVhc29uKSlcbiAgICAgICAgICAgICAgICAgICAgICA6IChpbml0aWFsaXppbmdIYW5kbGVyID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUucmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBkZXBzOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcmVkOiAhMFxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWVbcmVmZXJlbmNlW2ldXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzcG9uc2UgPSBtYXAocmVzcG9uc2UsIHZhbHVlLCBwYXJlbnRPYmplY3QsIGtleSk7XG4gICAgICAgICAgaWQuX2RlYnVnSW5mbyAmJlxuICAgICAgICAgICAgKFwib2JqZWN0XCIgIT09IHR5cGVvZiByZXNwb25zZSB8fFxuICAgICAgICAgICAgICBudWxsID09PSByZXNwb25zZSB8fFxuICAgICAgICAgICAgICAoIWlzQXJyYXlJbXBsKHJlc3BvbnNlKSAmJlxuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHJlc3BvbnNlW0FTWU5DX0lURVJBVE9SXSAmJlxuICAgICAgICAgICAgICAgIHJlc3BvbnNlLiQkdHlwZW9mICE9PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHx8XG4gICAgICAgICAgICAgIHJlc3BvbnNlLl9kZWJ1Z0luZm8gfHxcbiAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3BvbnNlLCBcIl9kZWJ1Z0luZm9cIiwge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBpZC5fZGVidWdJbmZvXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIGNhc2UgXCJwZW5kaW5nXCI6XG4gICAgICAgIGNhc2UgXCJibG9ja2VkXCI6XG4gICAgICAgICAgcmV0dXJuIHdhaXRGb3JSZWZlcmVuY2UoXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHBhcmVudE9iamVjdCxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgbWFwLFxuICAgICAgICAgICAgcmVmZXJlbmNlXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBcImhhbHRlZFwiOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBpbml0aWFsaXppbmdIYW5kbGVyXG4gICAgICAgICAgICAgID8gKChyZXNwb25zZSA9IGluaXRpYWxpemluZ0hhbmRsZXIpLCByZXNwb25zZS5kZXBzKyspXG4gICAgICAgICAgICAgIDogKGluaXRpYWxpemluZ0hhbmRsZXIgPSB7XG4gICAgICAgICAgICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICBjaHVuazogbnVsbCxcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgICAgZGVwczogMSxcbiAgICAgICAgICAgICAgICAgIGVycm9yZWQ6ICExXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBudWxsXG4gICAgICAgICAgKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgaW5pdGlhbGl6aW5nSGFuZGxlclxuICAgICAgICAgICAgICA/ICgoaW5pdGlhbGl6aW5nSGFuZGxlci5lcnJvcmVkID0gITApLFxuICAgICAgICAgICAgICAgIChpbml0aWFsaXppbmdIYW5kbGVyLnZhbHVlID0gaWQucmVhc29uKSlcbiAgICAgICAgICAgICAgOiAoaW5pdGlhbGl6aW5nSGFuZGxlciA9IHtcbiAgICAgICAgICAgICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgICAgICAgICAgIGNodW5rOiBudWxsLFxuICAgICAgICAgICAgICAgICAgdmFsdWU6IGlkLnJlYXNvbixcbiAgICAgICAgICAgICAgICAgIGRlcHM6IDAsXG4gICAgICAgICAgICAgICAgICBlcnJvcmVkOiAhMFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZU1hcChyZXNwb25zZSwgbW9kZWwpIHtcbiAgICAgIHJldHVybiBuZXcgTWFwKG1vZGVsKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlU2V0KHJlc3BvbnNlLCBtb2RlbCkge1xuICAgICAgcmV0dXJuIG5ldyBTZXQobW9kZWwpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVCbG9iKHJlc3BvbnNlLCBtb2RlbCkge1xuICAgICAgcmV0dXJuIG5ldyBCbG9iKG1vZGVsLnNsaWNlKDEpLCB7IHR5cGU6IG1vZGVsWzBdIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVGb3JtRGF0YShyZXNwb25zZSwgbW9kZWwpIHtcbiAgICAgIHJlc3BvbnNlID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1vZGVsLmxlbmd0aDsgaSsrKVxuICAgICAgICByZXNwb25zZS5hcHBlbmQobW9kZWxbaV1bMF0sIG1vZGVsW2ldWzFdKTtcbiAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXBwbHlDb25zdHJ1Y3RvcihyZXNwb25zZSwgbW9kZWwsIHBhcmVudE9iamVjdCkge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHBhcmVudE9iamVjdCwgbW9kZWwucHJvdG90eXBlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVmaW5lTGF6eUdldHRlcihyZXNwb25zZSwgY2h1bmssIHBhcmVudE9iamVjdCwga2V5KSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocGFyZW50T2JqZWN0LCBrZXksIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgXCJyZXNvbHZlZF9tb2RlbFwiID09PSBjaHVuay5zdGF0dXMgJiYgaW5pdGlhbGl6ZU1vZGVsQ2h1bmsoY2h1bmspO1xuICAgICAgICAgIHN3aXRjaCAoY2h1bmsuc3RhdHVzKSB7XG4gICAgICAgICAgICBjYXNlIFwiZnVsZmlsbGVkXCI6XG4gICAgICAgICAgICAgIHJldHVybiBjaHVuay52YWx1ZTtcbiAgICAgICAgICAgIGNhc2UgXCJyZWplY3RlZFwiOlxuICAgICAgICAgICAgICB0aHJvdyBjaHVuay5yZWFzb247XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBcIlRoaXMgb2JqZWN0IGhhcyBiZWVuIG9taXR0ZWQgYnkgUmVhY3QgaW4gdGhlIGNvbnNvbGUgbG9nIHRvIGF2b2lkIHNlbmRpbmcgdG9vIG11Y2ggZGF0YSBmcm9tIHRoZSBzZXJ2ZXIuIFRyeSBsb2dnaW5nIHNtYWxsZXIgb3IgbW9yZSBzcGVjaWZpYyBvYmplY3RzLlwiO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXh0cmFjdEl0ZXJhdG9yKHJlc3BvbnNlLCBtb2RlbCkge1xuICAgICAgcmV0dXJuIG1vZGVsW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlTW9kZWwocmVzcG9uc2UsIG1vZGVsKSB7XG4gICAgICByZXR1cm4gbW9kZWw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlTW9kZWxTdHJpbmcocmVzcG9uc2UsIHBhcmVudE9iamVjdCwga2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKFwiJFwiID09PSB2YWx1ZVswXSkge1xuICAgICAgICBpZiAoXCIkXCIgPT09IHZhbHVlKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBudWxsICE9PSBpbml0aWFsaXppbmdIYW5kbGVyICYmXG4gICAgICAgICAgICAgIFwiMFwiID09PSBrZXkgJiZcbiAgICAgICAgICAgICAgKGluaXRpYWxpemluZ0hhbmRsZXIgPSB7XG4gICAgICAgICAgICAgICAgcGFyZW50OiBpbml0aWFsaXppbmdIYW5kbGVyLFxuICAgICAgICAgICAgICAgIGNodW5rOiBudWxsLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgIGRlcHM6IDAsXG4gICAgICAgICAgICAgICAgZXJyb3JlZDogITFcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBSRUFDVF9FTEVNRU5UX1RZUEVcbiAgICAgICAgICApO1xuICAgICAgICBzd2l0Y2ggKHZhbHVlWzFdKSB7XG4gICAgICAgICAgY2FzZSBcIiRcIjpcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5zbGljZSgxKTtcbiAgICAgICAgICBjYXNlIFwiTFwiOlxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKHBhcmVudE9iamVjdCA9IHBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCAxNikpLFxuICAgICAgICAgICAgICAocmVzcG9uc2UgPSBnZXRDaHVuayhyZXNwb25zZSwgcGFyZW50T2JqZWN0KSksXG4gICAgICAgICAgICAgIGNyZWF0ZUxhenlDaHVua1dyYXBwZXIocmVzcG9uc2UpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNhc2UgXCJAXCI6XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAocGFyZW50T2JqZWN0ID0gcGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIDE2KSksXG4gICAgICAgICAgICAgIGdldENodW5rKHJlc3BvbnNlLCBwYXJlbnRPYmplY3QpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNhc2UgXCJTXCI6XG4gICAgICAgICAgICByZXR1cm4gU3ltYm9sLmZvcih2YWx1ZS5zbGljZSgyKSk7XG4gICAgICAgICAgY2FzZSBcIkZcIjpcbiAgICAgICAgICAgIHZhciByZWYgPSB2YWx1ZS5zbGljZSgyKTtcbiAgICAgICAgICAgIHJldHVybiBnZXRPdXRsaW5lZE1vZGVsKFxuICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgICAgcmVmLFxuICAgICAgICAgICAgICBwYXJlbnRPYmplY3QsXG4gICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgbG9hZFNlcnZlclJlZmVyZW5jZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBjYXNlIFwiVFwiOlxuICAgICAgICAgICAgcGFyZW50T2JqZWN0ID0gXCIkXCIgKyB2YWx1ZS5zbGljZSgyKTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gcmVzcG9uc2UuX3RlbXBSZWZzO1xuICAgICAgICAgICAgaWYgKG51bGwgPT0gcmVzcG9uc2UpXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiTWlzc2luZyBhIHRlbXBvcmFyeSByZWZlcmVuY2Ugc2V0IGJ1dCB0aGUgUlNDIHJlc3BvbnNlIHJldHVybmVkIGEgdGVtcG9yYXJ5IHJlZmVyZW5jZS4gUGFzcyBhIHRlbXBvcmFyeVJlZmVyZW5jZSBvcHRpb24gd2l0aCB0aGUgc2V0IHRoYXQgd2FzIHVzZWQgd2l0aCB0aGUgcmVwbHkuXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5nZXQocGFyZW50T2JqZWN0KTtcbiAgICAgICAgICBjYXNlIFwiUVwiOlxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKHJlZiA9IHZhbHVlLnNsaWNlKDIpKSxcbiAgICAgICAgICAgICAgZ2V0T3V0bGluZWRNb2RlbChyZXNwb25zZSwgcmVmLCBwYXJlbnRPYmplY3QsIGtleSwgY3JlYXRlTWFwKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBjYXNlIFwiV1wiOlxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKHJlZiA9IHZhbHVlLnNsaWNlKDIpKSxcbiAgICAgICAgICAgICAgZ2V0T3V0bGluZWRNb2RlbChyZXNwb25zZSwgcmVmLCBwYXJlbnRPYmplY3QsIGtleSwgY3JlYXRlU2V0KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBjYXNlIFwiQlwiOlxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKHJlZiA9IHZhbHVlLnNsaWNlKDIpKSxcbiAgICAgICAgICAgICAgZ2V0T3V0bGluZWRNb2RlbChyZXNwb25zZSwgcmVmLCBwYXJlbnRPYmplY3QsIGtleSwgY3JlYXRlQmxvYilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSBcIktcIjpcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChyZWYgPSB2YWx1ZS5zbGljZSgyKSksXG4gICAgICAgICAgICAgIGdldE91dGxpbmVkTW9kZWwocmVzcG9uc2UsIHJlZiwgcGFyZW50T2JqZWN0LCBrZXksIGNyZWF0ZUZvcm1EYXRhKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBjYXNlIFwiWlwiOlxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKHJlZiA9IHZhbHVlLnNsaWNlKDIpKSxcbiAgICAgICAgICAgICAgZ2V0T3V0bGluZWRNb2RlbChcbiAgICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgICAgICByZWYsXG4gICAgICAgICAgICAgICAgcGFyZW50T2JqZWN0LFxuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICByZXNvbHZlRXJyb3JEZXZcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBjYXNlIFwiaVwiOlxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKHJlZiA9IHZhbHVlLnNsaWNlKDIpKSxcbiAgICAgICAgICAgICAgZ2V0T3V0bGluZWRNb2RlbChcbiAgICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgICAgICByZWYsXG4gICAgICAgICAgICAgICAgcGFyZW50T2JqZWN0LFxuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICBleHRyYWN0SXRlcmF0b3JcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBjYXNlIFwiSVwiOlxuICAgICAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgICAgIGNhc2UgXCItXCI6XG4gICAgICAgICAgICByZXR1cm4gXCIkLTBcIiA9PT0gdmFsdWUgPyAtMCA6IC1JbmZpbml0eTtcbiAgICAgICAgICBjYXNlIFwiTlwiOlxuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgICBjYXNlIFwidVwiOlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGNhc2UgXCJEXCI6XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5wYXJzZSh2YWx1ZS5zbGljZSgyKSkpO1xuICAgICAgICAgIGNhc2UgXCJuXCI6XG4gICAgICAgICAgICByZXR1cm4gQmlnSW50KHZhbHVlLnNsaWNlKDIpKTtcbiAgICAgICAgICBjYXNlIFwiUFwiOlxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKHJlZiA9IHZhbHVlLnNsaWNlKDIpKSxcbiAgICAgICAgICAgICAgZ2V0T3V0bGluZWRNb2RlbChcbiAgICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgICAgICByZWYsXG4gICAgICAgICAgICAgICAgcGFyZW50T2JqZWN0LFxuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICBhcHBseUNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSBcIkVcIjpcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdmFsdWUuc2xpY2UoMik7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gKDAsIGV2YWwpKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXJ0c1dpdGgoXCIoYXN5bmMgZnVuY3Rpb25cIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAoKHBhcmVudE9iamVjdCA9IHJlc3BvbnNlLmluZGV4T2YoXCIoXCIsIDE1KSksXG4gICAgICAgICAgICAgICAgICAtMSAhPT0gcGFyZW50T2JqZWN0KVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgIChyZXNwb25zZSA9IHJlc3BvbnNlLnNsaWNlKDE1LCBwYXJlbnRPYmplY3QpLnRyaW0oKSksXG4gICAgICAgICAgICAgICAgICAgICgwLCBldmFsKShcbiAgICAgICAgICAgICAgICAgICAgICBcIih7XCIgKyBKU09OLnN0cmluZ2lmeShyZXNwb25zZSkgKyBcIjphc3luYyBmdW5jdGlvbigpe319KVwiXG4gICAgICAgICAgICAgICAgICAgIClbcmVzcG9uc2VdXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXJ0c1dpdGgoXCIoZnVuY3Rpb25cIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAoKHBhcmVudE9iamVjdCA9IHJlc3BvbnNlLmluZGV4T2YoXCIoXCIsIDkpKSxcbiAgICAgICAgICAgICAgICAgIC0xICE9PSBwYXJlbnRPYmplY3QpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgKHJlc3BvbnNlID0gcmVzcG9uc2Uuc2xpY2UoOSwgcGFyZW50T2JqZWN0KS50cmltKCkpLFxuICAgICAgICAgICAgICAgICAgICAoMCwgZXZhbCkoXG4gICAgICAgICAgICAgICAgICAgICAgXCIoe1wiICsgSlNPTi5zdHJpbmdpZnkocmVzcG9uc2UpICsgXCI6ZnVuY3Rpb24oKXt9fSlcIlxuICAgICAgICAgICAgICAgICAgICApW3Jlc3BvbnNlXVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICByZXNwb25zZS5zdGFydHNXaXRoKFwiKGNsYXNzXCIpICYmXG4gICAgICAgICAgICAgICAgKChwYXJlbnRPYmplY3QgPSByZXNwb25zZS5pbmRleE9mKFwie1wiLCA2KSksIC0xICE9PSBwYXJlbnRPYmplY3QpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgKHJlc3BvbnNlID0gcmVzcG9uc2Uuc2xpY2UoNiwgcGFyZW50T2JqZWN0KS50cmltKCkpLFxuICAgICAgICAgICAgICAgICAgKDAsIGV2YWwpKFwiKHtcIiArIEpTT04uc3RyaW5naWZ5KHJlc3BvbnNlKSArIFwiOmNsYXNze319KVwiKVtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VcbiAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIllcIjpcbiAgICAgICAgICAgIGlmICgyIDwgdmFsdWUubGVuZ3RoICYmIChyZWYgPSByZXNwb25zZS5fZGVidWdDaGFubmVsKSkge1xuICAgICAgICAgICAgICBpZiAoXCJAXCIgPT09IHZhbHVlWzJdKVxuICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAocGFyZW50T2JqZWN0ID0gdmFsdWUuc2xpY2UoMykpLFxuICAgICAgICAgICAgICAgICAgKGtleSA9IHBhcnNlSW50KHBhcmVudE9iamVjdCwgMTYpKSxcbiAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLl9jaHVua3MuaGFzKGtleSkgfHwgcmVmKFwiUDpcIiArIHBhcmVudE9iamVjdCksXG4gICAgICAgICAgICAgICAgICBnZXRDaHVuayhyZXNwb25zZSwga2V5KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMik7XG4gICAgICAgICAgICAgIHZhciBfaWQyID0gcGFyc2VJbnQodmFsdWUsIDE2KTtcbiAgICAgICAgICAgICAgcmVzcG9uc2UuX2NodW5rcy5oYXMoX2lkMikgfHwgcmVmKFwiUTpcIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgcmVmID0gZ2V0Q2h1bmsocmVzcG9uc2UsIF9pZDIpO1xuICAgICAgICAgICAgICByZXR1cm4gXCJmdWxmaWxsZWRcIiA9PT0gcmVmLnN0YXR1c1xuICAgICAgICAgICAgICAgID8gcmVmLnZhbHVlXG4gICAgICAgICAgICAgICAgOiBkZWZpbmVMYXp5R2V0dGVyKHJlc3BvbnNlLCByZWYsIHBhcmVudE9iamVjdCwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwYXJlbnRPYmplY3QsIGtleSwge1xuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJUaGlzIG9iamVjdCBoYXMgYmVlbiBvbWl0dGVkIGJ5IFJlYWN0IGluIHRoZSBjb25zb2xlIGxvZyB0byBhdm9pZCBzZW5kaW5nIHRvbyBtdWNoIGRhdGEgZnJvbSB0aGUgc2VydmVyLiBUcnkgbG9nZ2luZyBzbWFsbGVyIG9yIG1vcmUgc3BlY2lmaWMgb2JqZWN0cy5cIjtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChyZWYgPSB2YWx1ZS5zbGljZSgxKSksXG4gICAgICAgICAgICAgIGdldE91dGxpbmVkTW9kZWwocmVzcG9uc2UsIHJlZiwgcGFyZW50T2JqZWN0LCBrZXksIGNyZWF0ZU1vZGVsKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtaXNzaW5nQ2FsbCgpIHtcbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAnVHJ5aW5nIHRvIGNhbGwgYSBmdW5jdGlvbiBmcm9tIFwidXNlIHNlcnZlclwiIGJ1dCB0aGUgY2FsbFNlcnZlciBvcHRpb24gd2FzIG5vdCBpbXBsZW1lbnRlZCBpbiB5b3VyIHJvdXRlciBydW50aW1lLidcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlc3BvbnNlSW5zdGFuY2UoXG4gICAgICBidW5kbGVyQ29uZmlnLFxuICAgICAgc2VydmVyUmVmZXJlbmNlQ29uZmlnLFxuICAgICAgbW9kdWxlTG9hZGluZyxcbiAgICAgIGNhbGxTZXJ2ZXIsXG4gICAgICBlbmNvZGVGb3JtQWN0aW9uLFxuICAgICAgbm9uY2UsXG4gICAgICB0ZW1wb3JhcnlSZWZlcmVuY2VzLFxuICAgICAgZmluZFNvdXJjZU1hcFVSTCxcbiAgICAgIHJlcGxheUNvbnNvbGUsXG4gICAgICBlbnZpcm9ubWVudE5hbWUsXG4gICAgICBkZWJ1Z0NoYW5uZWxcbiAgICApIHtcbiAgICAgIHZhciBjaHVua3MgPSBuZXcgTWFwKCk7XG4gICAgICB0aGlzLl9idW5kbGVyQ29uZmlnID0gYnVuZGxlckNvbmZpZztcbiAgICAgIHRoaXMuX3NlcnZlclJlZmVyZW5jZUNvbmZpZyA9IHNlcnZlclJlZmVyZW5jZUNvbmZpZztcbiAgICAgIHRoaXMuX21vZHVsZUxvYWRpbmcgPSBtb2R1bGVMb2FkaW5nO1xuICAgICAgdGhpcy5fY2FsbFNlcnZlciA9IHZvaWQgMCAhPT0gY2FsbFNlcnZlciA/IGNhbGxTZXJ2ZXIgOiBtaXNzaW5nQ2FsbDtcbiAgICAgIHRoaXMuX2VuY29kZUZvcm1BY3Rpb24gPSBlbmNvZGVGb3JtQWN0aW9uO1xuICAgICAgdGhpcy5fbm9uY2UgPSBub25jZTtcbiAgICAgIHRoaXMuX2NodW5rcyA9IGNodW5rcztcbiAgICAgIHRoaXMuX3N0cmluZ0RlY29kZXIgPSBuZXcgdXRpbC5UZXh0RGVjb2RlcigpO1xuICAgICAgdGhpcy5fZnJvbUpTT04gPSBudWxsO1xuICAgICAgdGhpcy5fY2xvc2VkID0gITE7XG4gICAgICB0aGlzLl9jbG9zZWRSZWFzb24gPSBudWxsO1xuICAgICAgdGhpcy5fdGVtcFJlZnMgPSB0ZW1wb3JhcnlSZWZlcmVuY2VzO1xuICAgICAgdGhpcy5fcGVuZGluZ0NodW5rcyA9IDA7XG4gICAgICB0aGlzLl93ZWFrUmVzcG9uc2UgPSB7IHdlYWs6IG5ldyBXZWFrUmVmKHRoaXMpLCByZXNwb25zZTogdGhpcyB9O1xuICAgICAgdGhpcy5fZGVidWdSb290T3duZXIgPSBidW5kbGVyQ29uZmlnID1cbiAgICAgICAgdm9pZCAwID09PSBSZWFjdFNoYXJlZEludGVyYWxzU2VydmVyIHx8XG4gICAgICAgIG51bGwgPT09IFJlYWN0U2hhcmVkSW50ZXJhbHNTZXJ2ZXIuQVxuICAgICAgICAgID8gbnVsbFxuICAgICAgICAgIDogUmVhY3RTaGFyZWRJbnRlcmFsc1NlcnZlci5BLmdldE93bmVyKCk7XG4gICAgICB0aGlzLl9kZWJ1Z1Jvb3RTdGFjayA9XG4gICAgICAgIG51bGwgIT09IGJ1bmRsZXJDb25maWcgPyBFcnJvcihcInJlYWN0LXN0YWNrLXRvcC1mcmFtZVwiKSA6IG51bGw7XG4gICAgICBlbnZpcm9ubWVudE5hbWUgPSB2b2lkIDAgPT09IGVudmlyb25tZW50TmFtZSA/IFwiU2VydmVyXCIgOiBlbnZpcm9ubWVudE5hbWU7XG4gICAgICBzdXBwb3J0c0NyZWF0ZVRhc2sgJiZcbiAgICAgICAgKHRoaXMuX2RlYnVnUm9vdFRhc2sgPSBjb25zb2xlLmNyZWF0ZVRhc2soXG4gICAgICAgICAgJ1widXNlICcgKyBlbnZpcm9ubWVudE5hbWUudG9Mb3dlckNhc2UoKSArICdcIidcbiAgICAgICAgKSk7XG4gICAgICB0aGlzLl9kZWJ1Z0ZpbmRTb3VyY2VNYXBVUkwgPSBmaW5kU291cmNlTWFwVVJMO1xuICAgICAgdGhpcy5fZGVidWdDaGFubmVsID0gZGVidWdDaGFubmVsO1xuICAgICAgdGhpcy5fcmVwbGF5Q29uc29sZSA9IHJlcGxheUNvbnNvbGU7XG4gICAgICB0aGlzLl9yb290RW52aXJvbm1lbnROYW1lID0gZW52aXJvbm1lbnROYW1lO1xuICAgICAgZGVidWdDaGFubmVsICYmXG4gICAgICAgIChudWxsID09PSBkZWJ1Z0NoYW5uZWxSZWdpc3RyeVxuICAgICAgICAgID8gKGRlYnVnQ2hhbm5lbChcIlwiKSwgKHRoaXMuX2RlYnVnQ2hhbm5lbCA9IHZvaWQgMCkpXG4gICAgICAgICAgOiBkZWJ1Z0NoYW5uZWxSZWdpc3RyeS5yZWdpc3Rlcih0aGlzLCBkZWJ1Z0NoYW5uZWwpKTtcbiAgICAgIHRoaXMuX2Zyb21KU09OID0gY3JlYXRlRnJvbUpTT05DYWxsYmFjayh0aGlzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlU3RyZWFtU3RhdGUoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBfcm93U3RhdGU6IDAsXG4gICAgICAgIF9yb3dJRDogMCxcbiAgICAgICAgX3Jvd1RhZzogMCxcbiAgICAgICAgX3Jvd0xlbmd0aDogMCxcbiAgICAgICAgX2J1ZmZlcjogW11cbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc29sdmVEZWJ1Z0hhbHQocmVzcG9uc2UsIGlkKSB7XG4gICAgICB2YXIgY2h1bmtzID0gcmVzcG9uc2UuX2NodW5rcyxcbiAgICAgICAgY2h1bmsgPSBjaHVua3MuZ2V0KGlkKTtcbiAgICAgIGNodW5rIHx8IGNodW5rcy5zZXQoaWQsIChjaHVuayA9IGNyZWF0ZVBlbmRpbmdDaHVuayhyZXNwb25zZSkpKTtcbiAgICAgIGlmIChcInBlbmRpbmdcIiA9PT0gY2h1bmsuc3RhdHVzIHx8IFwiYmxvY2tlZFwiID09PSBjaHVuay5zdGF0dXMpXG4gICAgICAgIHJlbGVhc2VQZW5kaW5nQ2h1bmsocmVzcG9uc2UsIGNodW5rKSxcbiAgICAgICAgICAocmVzcG9uc2UgPSBjaHVuayksXG4gICAgICAgICAgKHJlc3BvbnNlLnN0YXR1cyA9IFwiaGFsdGVkXCIpLFxuICAgICAgICAgIChyZXNwb25zZS52YWx1ZSA9IG51bGwpLFxuICAgICAgICAgIChyZXNwb25zZS5yZWFzb24gPSBudWxsKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzb2x2ZU1vZGVsKHJlc3BvbnNlLCBpZCwgbW9kZWwpIHtcbiAgICAgIHZhciBjaHVua3MgPSByZXNwb25zZS5fY2h1bmtzLFxuICAgICAgICBjaHVuayA9IGNodW5rcy5nZXQoaWQpO1xuICAgICAgY2h1bmtcbiAgICAgICAgPyByZXNvbHZlTW9kZWxDaHVuayhyZXNwb25zZSwgY2h1bmssIG1vZGVsKVxuICAgICAgICA6IGNodW5rcy5zZXQoaWQsIG5ldyBSZWFjdFByb21pc2UoXCJyZXNvbHZlZF9tb2RlbFwiLCBtb2RlbCwgcmVzcG9uc2UpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzb2x2ZVRleHQocmVzcG9uc2UsIGlkLCB0ZXh0KSB7XG4gICAgICB2YXIgY2h1bmtzID0gcmVzcG9uc2UuX2NodW5rcyxcbiAgICAgICAgY2h1bmsgPSBjaHVua3MuZ2V0KGlkKTtcbiAgICAgIGNodW5rICYmIFwicGVuZGluZ1wiICE9PSBjaHVuay5zdGF0dXNcbiAgICAgICAgPyBjaHVuay5yZWFzb24uZW5xdWV1ZVZhbHVlKHRleHQpXG4gICAgICAgIDogKGNodW5rICYmIHJlbGVhc2VQZW5kaW5nQ2h1bmsocmVzcG9uc2UsIGNodW5rKSxcbiAgICAgICAgICBjaHVua3Muc2V0KGlkLCBuZXcgUmVhY3RQcm9taXNlKFwiZnVsZmlsbGVkXCIsIHRleHQsIG51bGwpKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc29sdmVCdWZmZXIocmVzcG9uc2UsIGlkLCBidWZmZXIpIHtcbiAgICAgIHZhciBjaHVua3MgPSByZXNwb25zZS5fY2h1bmtzLFxuICAgICAgICBjaHVuayA9IGNodW5rcy5nZXQoaWQpO1xuICAgICAgY2h1bmsgJiYgXCJwZW5kaW5nXCIgIT09IGNodW5rLnN0YXR1c1xuICAgICAgICA/IGNodW5rLnJlYXNvbi5lbnF1ZXVlVmFsdWUoYnVmZmVyKVxuICAgICAgICA6IChjaHVuayAmJiByZWxlYXNlUGVuZGluZ0NodW5rKHJlc3BvbnNlLCBjaHVuayksXG4gICAgICAgICAgY2h1bmtzLnNldChpZCwgbmV3IFJlYWN0UHJvbWlzZShcImZ1bGZpbGxlZFwiLCBidWZmZXIsIG51bGwpKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc29sdmVNb2R1bGUocmVzcG9uc2UsIGlkLCBtb2RlbCkge1xuICAgICAgdmFyIGNodW5rcyA9IHJlc3BvbnNlLl9jaHVua3MsXG4gICAgICAgIGNodW5rID0gY2h1bmtzLmdldChpZCk7XG4gICAgICBtb2RlbCA9IEpTT04ucGFyc2UobW9kZWwsIHJlc3BvbnNlLl9mcm9tSlNPTik7XG4gICAgICB2YXIgY2xpZW50UmVmZXJlbmNlID0gcmVzb2x2ZUNsaWVudFJlZmVyZW5jZShcbiAgICAgICAgcmVzcG9uc2UuX2J1bmRsZXJDb25maWcsXG4gICAgICAgIG1vZGVsXG4gICAgICApO1xuICAgICAgcHJlcGFyZURlc3RpbmF0aW9uV2l0aENodW5rcyhcbiAgICAgICAgcmVzcG9uc2UuX21vZHVsZUxvYWRpbmcsXG4gICAgICAgIG1vZGVsWzFdLFxuICAgICAgICByZXNwb25zZS5fbm9uY2VcbiAgICAgICk7XG4gICAgICBpZiAoKG1vZGVsID0gcHJlbG9hZE1vZHVsZShjbGllbnRSZWZlcmVuY2UpKSkge1xuICAgICAgICBpZiAoY2h1bmspIHtcbiAgICAgICAgICByZWxlYXNlUGVuZGluZ0NodW5rKHJlc3BvbnNlLCBjaHVuayk7XG4gICAgICAgICAgdmFyIGJsb2NrZWRDaHVuayA9IGNodW5rO1xuICAgICAgICAgIGJsb2NrZWRDaHVuay5zdGF0dXMgPSBcImJsb2NrZWRcIjtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgKGJsb2NrZWRDaHVuayA9IG5ldyBSZWFjdFByb21pc2UoXCJibG9ja2VkXCIsIG51bGwsIG51bGwpKSxcbiAgICAgICAgICAgIGNodW5rcy5zZXQoaWQsIGJsb2NrZWRDaHVuayk7XG4gICAgICAgIG1vZGVsLnRoZW4oXG4gICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVNb2R1bGVDaHVuayhyZXNwb25zZSwgYmxvY2tlZENodW5rLCBjbGllbnRSZWZlcmVuY2UpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJpZ2dlckVycm9yT25DaHVuayhyZXNwb25zZSwgYmxvY2tlZENodW5rLCBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfSBlbHNlXG4gICAgICAgIGNodW5rXG4gICAgICAgICAgPyByZXNvbHZlTW9kdWxlQ2h1bmsocmVzcG9uc2UsIGNodW5rLCBjbGllbnRSZWZlcmVuY2UpXG4gICAgICAgICAgOiBjaHVua3Muc2V0KFxuICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgbmV3IFJlYWN0UHJvbWlzZShcInJlc29sdmVkX21vZHVsZVwiLCBjbGllbnRSZWZlcmVuY2UsIG51bGwpXG4gICAgICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNvbHZlU3RyZWFtKHJlc3BvbnNlLCBpZCwgc3RyZWFtLCBjb250cm9sbGVyKSB7XG4gICAgICB2YXIgY2h1bmtzID0gcmVzcG9uc2UuX2NodW5rcyxcbiAgICAgICAgY2h1bmsgPSBjaHVua3MuZ2V0KGlkKTtcbiAgICAgIGNodW5rXG4gICAgICAgID8gXCJwZW5kaW5nXCIgPT09IGNodW5rLnN0YXR1cyAmJlxuICAgICAgICAgIChyZWxlYXNlUGVuZGluZ0NodW5rKHJlc3BvbnNlLCBjaHVuayksXG4gICAgICAgICAgKHJlc3BvbnNlID0gY2h1bmsudmFsdWUpLFxuICAgICAgICAgIChjaHVuay5zdGF0dXMgPSBcImZ1bGZpbGxlZFwiKSxcbiAgICAgICAgICAoY2h1bmsudmFsdWUgPSBzdHJlYW0pLFxuICAgICAgICAgIChjaHVuay5yZWFzb24gPSBjb250cm9sbGVyKSxcbiAgICAgICAgICBudWxsICE9PSByZXNwb25zZSAmJiB3YWtlQ2h1bmsocmVzcG9uc2UsIGNodW5rLnZhbHVlKSlcbiAgICAgICAgOiBjaHVua3Muc2V0KGlkLCBuZXcgUmVhY3RQcm9taXNlKFwiZnVsZmlsbGVkXCIsIHN0cmVhbSwgY29udHJvbGxlcikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdGFydFJlYWRhYmxlU3RyZWFtKHJlc3BvbnNlLCBpZCwgdHlwZSkge1xuICAgICAgdmFyIGNvbnRyb2xsZXIgPSBudWxsO1xuICAgICAgdHlwZSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIHN0YXJ0OiBmdW5jdGlvbiAoYykge1xuICAgICAgICAgIGNvbnRyb2xsZXIgPSBjO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHZhciBwcmV2aW91c0Jsb2NrZWRDaHVuayA9IG51bGw7XG4gICAgICByZXNvbHZlU3RyZWFtKHJlc3BvbnNlLCBpZCwgdHlwZSwge1xuICAgICAgICBlbnF1ZXVlVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIG51bGwgPT09IHByZXZpb3VzQmxvY2tlZENodW5rXG4gICAgICAgICAgICA/IGNvbnRyb2xsZXIuZW5xdWV1ZSh2YWx1ZSlcbiAgICAgICAgICAgIDogcHJldmlvdXNCbG9ja2VkQ2h1bmsudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHZhbHVlKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVucXVldWVNb2RlbDogZnVuY3Rpb24gKGpzb24pIHtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gcHJldmlvdXNCbG9ja2VkQ2h1bmspIHtcbiAgICAgICAgICAgIHZhciBjaHVuayA9IG5ldyBSZWFjdFByb21pc2UoXCJyZXNvbHZlZF9tb2RlbFwiLCBqc29uLCByZXNwb25zZSk7XG4gICAgICAgICAgICBpbml0aWFsaXplTW9kZWxDaHVuayhjaHVuayk7XG4gICAgICAgICAgICBcImZ1bGZpbGxlZFwiID09PSBjaHVuay5zdGF0dXNcbiAgICAgICAgICAgICAgPyBjb250cm9sbGVyLmVucXVldWUoY2h1bmsudmFsdWUpXG4gICAgICAgICAgICAgIDogKGNodW5rLnRoZW4oXG4gICAgICAgICAgICAgICAgICBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udHJvbGxlci5lbnF1ZXVlKHYpO1xuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250cm9sbGVyLmVycm9yKGUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgKHByZXZpb3VzQmxvY2tlZENodW5rID0gY2h1bmspKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2h1bmsgPSBwcmV2aW91c0Jsb2NrZWRDaHVuaztcbiAgICAgICAgICAgIHZhciBfY2h1bmszID0gY3JlYXRlUGVuZGluZ0NodW5rKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIF9jaHVuazMudGhlbihcbiAgICAgICAgICAgICAgZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udHJvbGxlci5lbnF1ZXVlKHYpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250cm9sbGVyLmVycm9yKGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcHJldmlvdXNCbG9ja2VkQ2h1bmsgPSBfY2h1bmszO1xuICAgICAgICAgICAgY2h1bmsudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHByZXZpb3VzQmxvY2tlZENodW5rID09PSBfY2h1bmszICYmIChwcmV2aW91c0Jsb2NrZWRDaHVuayA9IG51bGwpO1xuICAgICAgICAgICAgICByZXNvbHZlTW9kZWxDaHVuayhyZXNwb25zZSwgX2NodW5rMywganNvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKG51bGwgPT09IHByZXZpb3VzQmxvY2tlZENodW5rKSBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgYmxvY2tlZENodW5rID0gcHJldmlvdXNCbG9ja2VkQ2h1bms7XG4gICAgICAgICAgICBwcmV2aW91c0Jsb2NrZWRDaHVuayA9IG51bGw7XG4gICAgICAgICAgICBibG9ja2VkQ2h1bmsudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gcHJldmlvdXNCbG9ja2VkQ2h1bmspIGNvbnRyb2xsZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGJsb2NrZWRDaHVuayA9IHByZXZpb3VzQmxvY2tlZENodW5rO1xuICAgICAgICAgICAgcHJldmlvdXNCbG9ja2VkQ2h1bmsgPSBudWxsO1xuICAgICAgICAgICAgYmxvY2tlZENodW5rLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gY29udHJvbGxlci5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhc3luY0l0ZXJhdG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUl0ZXJhdG9yKG5leHQpIHtcbiAgICAgIG5leHQgPSB7IG5leHQ6IG5leHQgfTtcbiAgICAgIG5leHRbQVNZTkNfSVRFUkFUT1JdID0gYXN5bmNJdGVyYXRvcjtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdGFydEFzeW5jSXRlcmFibGUocmVzcG9uc2UsIGlkLCBpdGVyYXRvcikge1xuICAgICAgdmFyIGJ1ZmZlciA9IFtdLFxuICAgICAgICBjbG9zZWQgPSAhMSxcbiAgICAgICAgbmV4dFdyaXRlSW5kZXggPSAwLFxuICAgICAgICBpdGVyYWJsZSA9IHt9O1xuICAgICAgaXRlcmFibGVbQVNZTkNfSVRFUkFUT1JdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmV4dFJlYWRJbmRleCA9IDA7XG4gICAgICAgIHJldHVybiBjcmVhdGVJdGVyYXRvcihmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgaWYgKHZvaWQgMCAhPT0gYXJnKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgIFwiVmFsdWVzIGNhbm5vdCBiZSBwYXNzZWQgdG8gbmV4dCgpIG9mIEFzeW5jSXRlcmFibGVzIHBhc3NlZCB0byBDbGllbnQgQ29tcG9uZW50cy5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBpZiAobmV4dFJlYWRJbmRleCA9PT0gYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGNsb3NlZClcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWFjdFByb21pc2UoXG4gICAgICAgICAgICAgICAgXCJmdWxmaWxsZWRcIixcbiAgICAgICAgICAgICAgICB7IGRvbmU6ICEwLCB2YWx1ZTogdm9pZCAwIH0sXG4gICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgYnVmZmVyW25leHRSZWFkSW5kZXhdID0gY3JlYXRlUGVuZGluZ0NodW5rKHJlc3BvbnNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGJ1ZmZlcltuZXh0UmVhZEluZGV4KytdO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICByZXNvbHZlU3RyZWFtKFxuICAgICAgICByZXNwb25zZSxcbiAgICAgICAgaWQsXG4gICAgICAgIGl0ZXJhdG9yID8gaXRlcmFibGVbQVNZTkNfSVRFUkFUT1JdKCkgOiBpdGVyYWJsZSxcbiAgICAgICAge1xuICAgICAgICAgIGVucXVldWVWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAobmV4dFdyaXRlSW5kZXggPT09IGJ1ZmZlci5sZW5ndGgpXG4gICAgICAgICAgICAgIGJ1ZmZlcltuZXh0V3JpdGVJbmRleF0gPSBuZXcgUmVhY3RQcm9taXNlKFxuICAgICAgICAgICAgICAgIFwiZnVsZmlsbGVkXCIsXG4gICAgICAgICAgICAgICAgeyBkb25lOiAhMSwgdmFsdWU6IHZhbHVlIH0sXG4gICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBjaHVuayA9IGJ1ZmZlcltuZXh0V3JpdGVJbmRleF0sXG4gICAgICAgICAgICAgICAgcmVzb2x2ZUxpc3RlbmVycyA9IGNodW5rLnZhbHVlLFxuICAgICAgICAgICAgICAgIHJlamVjdExpc3RlbmVycyA9IGNodW5rLnJlYXNvbjtcbiAgICAgICAgICAgICAgY2h1bmsuc3RhdHVzID0gXCJmdWxmaWxsZWRcIjtcbiAgICAgICAgICAgICAgY2h1bmsudmFsdWUgPSB7IGRvbmU6ICExLCB2YWx1ZTogdmFsdWUgfTtcbiAgICAgICAgICAgICAgbnVsbCAhPT0gcmVzb2x2ZUxpc3RlbmVycyAmJlxuICAgICAgICAgICAgICAgIHdha2VDaHVua0lmSW5pdGlhbGl6ZWQoXG4gICAgICAgICAgICAgICAgICBjaHVuayxcbiAgICAgICAgICAgICAgICAgIHJlc29sdmVMaXN0ZW5lcnMsXG4gICAgICAgICAgICAgICAgICByZWplY3RMaXN0ZW5lcnNcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dFdyaXRlSW5kZXgrKztcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVucXVldWVNb2RlbDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBuZXh0V3JpdGVJbmRleCA9PT0gYnVmZmVyLmxlbmd0aFxuICAgICAgICAgICAgICA/IChidWZmZXJbbmV4dFdyaXRlSW5kZXhdID0gY3JlYXRlUmVzb2x2ZWRJdGVyYXRvclJlc3VsdENodW5rKFxuICAgICAgICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICExXG4gICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgOiByZXNvbHZlSXRlcmF0b3JSZXN1bHRDaHVuayhcbiAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgYnVmZmVyW25leHRXcml0ZUluZGV4XSxcbiAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgbmV4dFdyaXRlSW5kZXgrKztcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNsb3NlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGNsb3NlZCA9ICEwO1xuICAgICAgICAgICAgbmV4dFdyaXRlSW5kZXggPT09IGJ1ZmZlci5sZW5ndGhcbiAgICAgICAgICAgICAgPyAoYnVmZmVyW25leHRXcml0ZUluZGV4XSA9IGNyZWF0ZVJlc29sdmVkSXRlcmF0b3JSZXN1bHRDaHVuayhcbiAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAhMFxuICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICAgIDogcmVzb2x2ZUl0ZXJhdG9yUmVzdWx0Q2h1bmsoXG4gICAgICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgIGJ1ZmZlcltuZXh0V3JpdGVJbmRleF0sXG4gICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICEwXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGZvciAobmV4dFdyaXRlSW5kZXgrKzsgbmV4dFdyaXRlSW5kZXggPCBidWZmZXIubGVuZ3RoOyApXG4gICAgICAgICAgICAgIHJlc29sdmVJdGVyYXRvclJlc3VsdENodW5rKFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIGJ1ZmZlcltuZXh0V3JpdGVJbmRleCsrXSxcbiAgICAgICAgICAgICAgICAnXCIkdW5kZWZpbmVkXCInLFxuICAgICAgICAgICAgICAgICEwXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlcnJvcjogZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBjbG9zZWQgPSAhMDtcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIG5leHRXcml0ZUluZGV4ID09PSBidWZmZXIubGVuZ3RoICYmXG4gICAgICAgICAgICAgIChidWZmZXJbbmV4dFdyaXRlSW5kZXhdID0gY3JlYXRlUGVuZGluZ0NodW5rKHJlc3BvbnNlKSk7XG4gICAgICAgICAgICAgIG5leHRXcml0ZUluZGV4IDwgYnVmZmVyLmxlbmd0aDtcblxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB0cmlnZ2VyRXJyb3JPbkNodW5rKHJlc3BvbnNlLCBidWZmZXJbbmV4dFdyaXRlSW5kZXgrK10sIGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0b3BTdHJlYW0ocmVzcG9uc2UsIGlkLCByb3cpIHtcbiAgICAgIChyZXNwb25zZSA9IHJlc3BvbnNlLl9jaHVua3MuZ2V0KGlkKSkgJiZcbiAgICAgICAgXCJmdWxmaWxsZWRcIiA9PT0gcmVzcG9uc2Uuc3RhdHVzICYmXG4gICAgICAgIHJlc3BvbnNlLnJlYXNvbi5jbG9zZShcIlwiID09PSByb3cgPyAnXCIkdW5kZWZpbmVkXCInIDogcm93KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzb2x2ZUVycm9yRGV2KHJlc3BvbnNlLCBlcnJvckluZm8pIHtcbiAgICAgIHZhciBuYW1lID0gZXJyb3JJbmZvLm5hbWUsXG4gICAgICAgIGVudiA9IGVycm9ySW5mby5lbnY7XG4gICAgICBlcnJvckluZm8gPSBidWlsZEZha2VDYWxsU3RhY2soXG4gICAgICAgIHJlc3BvbnNlLFxuICAgICAgICBlcnJvckluZm8uc3RhY2ssXG4gICAgICAgIGVudixcbiAgICAgICAgITEsXG4gICAgICAgIEVycm9yLmJpbmQoXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBlcnJvckluZm8ubWVzc2FnZSB8fFxuICAgICAgICAgICAgXCJBbiBlcnJvciBvY2N1cnJlZCBpbiB0aGUgU2VydmVyIENvbXBvbmVudHMgcmVuZGVyIGJ1dCBubyBtZXNzYWdlIHdhcyBwcm92aWRlZFwiXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICByZXNwb25zZSA9IGdldFJvb3RUYXNrKHJlc3BvbnNlLCBlbnYpO1xuICAgICAgcmVzcG9uc2UgPSBudWxsICE9IHJlc3BvbnNlID8gcmVzcG9uc2UucnVuKGVycm9ySW5mbykgOiBlcnJvckluZm8oKTtcbiAgICAgIHJlc3BvbnNlLm5hbWUgPSBuYW1lO1xuICAgICAgcmVzcG9uc2UuZW52aXJvbm1lbnROYW1lID0gZW52O1xuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNvbHZlSGludChyZXNwb25zZSwgY29kZSwgbW9kZWwpIHtcbiAgICAgIHJlc3BvbnNlID0gSlNPTi5wYXJzZShtb2RlbCwgcmVzcG9uc2UuX2Zyb21KU09OKTtcbiAgICAgIG1vZGVsID0gUmVhY3RET01TaGFyZWRJbnRlcm5hbHMuZDtcbiAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICBjYXNlIFwiRFwiOlxuICAgICAgICAgIG1vZGVsLkQocmVzcG9uc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiQ1wiOlxuICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiByZXNwb25zZVxuICAgICAgICAgICAgPyBtb2RlbC5DKHJlc3BvbnNlKVxuICAgICAgICAgICAgOiBtb2RlbC5DKHJlc3BvbnNlWzBdLCByZXNwb25zZVsxXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJMXCI6XG4gICAgICAgICAgY29kZSA9IHJlc3BvbnNlWzBdO1xuICAgICAgICAgIHZhciBhcyA9IHJlc3BvbnNlWzFdO1xuICAgICAgICAgIDMgPT09IHJlc3BvbnNlLmxlbmd0aFxuICAgICAgICAgICAgPyBtb2RlbC5MKGNvZGUsIGFzLCByZXNwb25zZVsyXSlcbiAgICAgICAgICAgIDogbW9kZWwuTChjb2RlLCBhcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJtXCI6XG4gICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHJlc3BvbnNlXG4gICAgICAgICAgICA/IG1vZGVsLm0ocmVzcG9uc2UpXG4gICAgICAgICAgICA6IG1vZGVsLm0ocmVzcG9uc2VbMF0sIHJlc3BvbnNlWzFdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlhcIjpcbiAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgcmVzcG9uc2VcbiAgICAgICAgICAgID8gbW9kZWwuWChyZXNwb25zZSlcbiAgICAgICAgICAgIDogbW9kZWwuWChyZXNwb25zZVswXSwgcmVzcG9uc2VbMV0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiU1wiOlxuICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiByZXNwb25zZVxuICAgICAgICAgICAgPyBtb2RlbC5TKHJlc3BvbnNlKVxuICAgICAgICAgICAgOiBtb2RlbC5TKFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlWzBdLFxuICAgICAgICAgICAgICAgIDAgPT09IHJlc3BvbnNlWzFdID8gdm9pZCAwIDogcmVzcG9uc2VbMV0sXG4gICAgICAgICAgICAgICAgMyA9PT0gcmVzcG9uc2UubGVuZ3RoID8gcmVzcG9uc2VbMl0gOiB2b2lkIDBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIk1cIjpcbiAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgcmVzcG9uc2VcbiAgICAgICAgICAgID8gbW9kZWwuTShyZXNwb25zZSlcbiAgICAgICAgICAgIDogbW9kZWwuTShyZXNwb25zZVswXSwgcmVzcG9uc2VbMV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVGYWtlRnVuY3Rpb24oXG4gICAgICBuYW1lLFxuICAgICAgZmlsZW5hbWUsXG4gICAgICBzb3VyY2VNYXAsXG4gICAgICBsaW5lLFxuICAgICAgY29sLFxuICAgICAgZW5jbG9zaW5nTGluZSxcbiAgICAgIGVuY2xvc2luZ0NvbCxcbiAgICAgIGVudmlyb25tZW50TmFtZVxuICAgICkge1xuICAgICAgbmFtZSB8fCAobmFtZSA9IFwiPGFub255bW91cz5cIik7XG4gICAgICB2YXIgZW5jb2RlZE5hbWUgPSBKU09OLnN0cmluZ2lmeShuYW1lKTtcbiAgICAgIDEgPiBlbmNsb3NpbmdMaW5lID8gKGVuY2xvc2luZ0xpbmUgPSAwKSA6IGVuY2xvc2luZ0xpbmUtLTtcbiAgICAgIDEgPiBlbmNsb3NpbmdDb2wgPyAoZW5jbG9zaW5nQ29sID0gMCkgOiBlbmNsb3NpbmdDb2wtLTtcbiAgICAgIDEgPiBsaW5lID8gKGxpbmUgPSAwKSA6IGxpbmUtLTtcbiAgICAgIDEgPiBjb2wgPyAoY29sID0gMCkgOiBjb2wtLTtcbiAgICAgIGlmIChcbiAgICAgICAgbGluZSA8IGVuY2xvc2luZ0xpbmUgfHxcbiAgICAgICAgKGxpbmUgPT09IGVuY2xvc2luZ0xpbmUgJiYgY29sIDwgZW5jbG9zaW5nQ29sKVxuICAgICAgKVxuICAgICAgICBlbmNsb3NpbmdDb2wgPSBlbmNsb3NpbmdMaW5lID0gMDtcbiAgICAgIDEgPiBsaW5lXG4gICAgICAgID8gKChsaW5lID0gZW5jb2RlZE5hbWUubGVuZ3RoICsgMyksXG4gICAgICAgICAgKGVuY2xvc2luZ0NvbCAtPSBsaW5lKSxcbiAgICAgICAgICAwID4gZW5jbG9zaW5nQ29sICYmIChlbmNsb3NpbmdDb2wgPSAwKSxcbiAgICAgICAgICAoY29sID0gY29sIC0gZW5jbG9zaW5nQ29sIC0gbGluZSAtIDMpLFxuICAgICAgICAgIDAgPiBjb2wgJiYgKGNvbCA9IDApLFxuICAgICAgICAgIChlbmNvZGVkTmFtZSA9XG4gICAgICAgICAgICBcIih7XCIgK1xuICAgICAgICAgICAgZW5jb2RlZE5hbWUgK1xuICAgICAgICAgICAgXCI6XCIgK1xuICAgICAgICAgICAgXCIgXCIucmVwZWF0KGVuY2xvc2luZ0NvbCkgK1xuICAgICAgICAgICAgXCJfPT5cIiArXG4gICAgICAgICAgICBcIiBcIi5yZXBlYXQoY29sKSArXG4gICAgICAgICAgICBcIl8oKX0pXCIpKVxuICAgICAgICA6IDEgPiBlbmNsb3NpbmdMaW5lXG4gICAgICAgICAgPyAoKGVuY2xvc2luZ0NvbCAtPSBlbmNvZGVkTmFtZS5sZW5ndGggKyAzKSxcbiAgICAgICAgICAgIDAgPiBlbmNsb3NpbmdDb2wgJiYgKGVuY2xvc2luZ0NvbCA9IDApLFxuICAgICAgICAgICAgKGVuY29kZWROYW1lID1cbiAgICAgICAgICAgICAgXCIoe1wiICtcbiAgICAgICAgICAgICAgZW5jb2RlZE5hbWUgK1xuICAgICAgICAgICAgICBcIjpcIiArXG4gICAgICAgICAgICAgIFwiIFwiLnJlcGVhdChlbmNsb3NpbmdDb2wpICtcbiAgICAgICAgICAgICAgXCJfPT5cIiArXG4gICAgICAgICAgICAgIFwiXFxuXCIucmVwZWF0KGxpbmUgLSBlbmNsb3NpbmdMaW5lKSArXG4gICAgICAgICAgICAgIFwiIFwiLnJlcGVhdChjb2wpICtcbiAgICAgICAgICAgICAgXCJfKCl9KVwiKSlcbiAgICAgICAgICA6IGVuY2xvc2luZ0xpbmUgPT09IGxpbmVcbiAgICAgICAgICAgID8gKChjb2wgPSBjb2wgLSBlbmNsb3NpbmdDb2wgLSAzKSxcbiAgICAgICAgICAgICAgMCA+IGNvbCAmJiAoY29sID0gMCksXG4gICAgICAgICAgICAgIChlbmNvZGVkTmFtZSA9XG4gICAgICAgICAgICAgICAgXCJcXG5cIi5yZXBlYXQoZW5jbG9zaW5nTGluZSAtIDEpICtcbiAgICAgICAgICAgICAgICBcIih7XCIgK1xuICAgICAgICAgICAgICAgIGVuY29kZWROYW1lICtcbiAgICAgICAgICAgICAgICBcIjpcXG5cIiArXG4gICAgICAgICAgICAgICAgXCIgXCIucmVwZWF0KGVuY2xvc2luZ0NvbCkgK1xuICAgICAgICAgICAgICAgIFwiXz0+XCIgK1xuICAgICAgICAgICAgICAgIFwiIFwiLnJlcGVhdChjb2wpICtcbiAgICAgICAgICAgICAgICBcIl8oKX0pXCIpKVxuICAgICAgICAgICAgOiAoZW5jb2RlZE5hbWUgPVxuICAgICAgICAgICAgICAgIFwiXFxuXCIucmVwZWF0KGVuY2xvc2luZ0xpbmUgLSAxKSArXG4gICAgICAgICAgICAgICAgXCIoe1wiICtcbiAgICAgICAgICAgICAgICBlbmNvZGVkTmFtZSArXG4gICAgICAgICAgICAgICAgXCI6XFxuXCIgK1xuICAgICAgICAgICAgICAgIFwiIFwiLnJlcGVhdChlbmNsb3NpbmdDb2wpICtcbiAgICAgICAgICAgICAgICBcIl89PlwiICtcbiAgICAgICAgICAgICAgICBcIlxcblwiLnJlcGVhdChsaW5lIC0gZW5jbG9zaW5nTGluZSkgK1xuICAgICAgICAgICAgICAgIFwiIFwiLnJlcGVhdChjb2wpICtcbiAgICAgICAgICAgICAgICBcIl8oKX0pXCIpO1xuICAgICAgZW5jb2RlZE5hbWUgPVxuICAgICAgICAxID4gZW5jbG9zaW5nTGluZVxuICAgICAgICAgID8gZW5jb2RlZE5hbWUgK1xuICAgICAgICAgICAgXCJcXG4vKiBUaGlzIG1vZHVsZSB3YXMgcmVuZGVyZWQgYnkgYSBTZXJ2ZXIgQ29tcG9uZW50LiBUdXJuIG9uIFNvdXJjZSBNYXBzIHRvIHNlZSB0aGUgc2VydmVyIHNvdXJjZS4gKi9cIlxuICAgICAgICAgIDogXCIvKiBUaGlzIG1vZHVsZSB3YXMgcmVuZGVyZWQgYnkgYSBTZXJ2ZXIgQ29tcG9uZW50LiBUdXJuIG9uIFNvdXJjZSBNYXBzIHRvIHNlZSB0aGUgc2VydmVyIHNvdXJjZS4gKi9cIiArXG4gICAgICAgICAgICBlbmNvZGVkTmFtZTtcbiAgICAgIGZpbGVuYW1lLnN0YXJ0c1dpdGgoXCIvXCIpICYmIChmaWxlbmFtZSA9IFwiZmlsZTovL1wiICsgZmlsZW5hbWUpO1xuICAgICAgc291cmNlTWFwXG4gICAgICAgID8gKChlbmNvZGVkTmFtZSArPVxuICAgICAgICAgICAgXCJcXG4vLyMgc291cmNlVVJMPXJzYzovL1JlYWN0L1wiICtcbiAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChlbnZpcm9ubWVudE5hbWUpICtcbiAgICAgICAgICAgIFwiL1wiICtcbiAgICAgICAgICAgIGVuY29kZVVSSShmaWxlbmFtZSkgK1xuICAgICAgICAgICAgXCI/XCIgK1xuICAgICAgICAgICAgZmFrZUZ1bmN0aW9uSWR4KyspLFxuICAgICAgICAgIChlbmNvZGVkTmFtZSArPSBcIlxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVwiICsgc291cmNlTWFwKSlcbiAgICAgICAgOiAoZW5jb2RlZE5hbWUgPSBmaWxlbmFtZVxuICAgICAgICAgICAgPyBlbmNvZGVkTmFtZSArIChcIlxcbi8vIyBzb3VyY2VVUkw9XCIgKyBlbmNvZGVVUkkoZmlsZW5hbWUpKVxuICAgICAgICAgICAgOiBlbmNvZGVkTmFtZSArIFwiXFxuLy8jIHNvdXJjZVVSTD08YW5vbnltb3VzPlwiKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBmbiA9ICgwLCBldmFsKShlbmNvZGVkTmFtZSlbbmFtZV07XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIGZuID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICByZXR1cm4gXygpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBidWlsZEZha2VDYWxsU3RhY2soXG4gICAgICByZXNwb25zZSxcbiAgICAgIHN0YWNrLFxuICAgICAgZW52aXJvbm1lbnROYW1lLFxuICAgICAgdXNlRW5jbG9zaW5nTGluZSxcbiAgICAgIGlubmVyQ2FsbFxuICAgICkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZnJhbWUgPSBzdGFja1tpXSxcbiAgICAgICAgICBmcmFtZUtleSA9XG4gICAgICAgICAgICBmcmFtZS5qb2luKFwiLVwiKSArXG4gICAgICAgICAgICBcIi1cIiArXG4gICAgICAgICAgICBlbnZpcm9ubWVudE5hbWUgK1xuICAgICAgICAgICAgKHVzZUVuY2xvc2luZ0xpbmUgPyBcIi1lXCIgOiBcIi1uXCIpLFxuICAgICAgICAgIGZuID0gZmFrZUZ1bmN0aW9uQ2FjaGUuZ2V0KGZyYW1lS2V5KTtcbiAgICAgICAgaWYgKHZvaWQgMCA9PT0gZm4pIHtcbiAgICAgICAgICBmbiA9IGZyYW1lWzBdO1xuICAgICAgICAgIHZhciBmaWxlbmFtZSA9IGZyYW1lWzFdLFxuICAgICAgICAgICAgbGluZSA9IGZyYW1lWzJdLFxuICAgICAgICAgICAgY29sID0gZnJhbWVbM10sXG4gICAgICAgICAgICBlbmNsb3NpbmdMaW5lID0gZnJhbWVbNF07XG4gICAgICAgICAgZnJhbWUgPSBmcmFtZVs1XTtcbiAgICAgICAgICB2YXIgZmluZFNvdXJjZU1hcFVSTCA9IHJlc3BvbnNlLl9kZWJ1Z0ZpbmRTb3VyY2VNYXBVUkw7XG4gICAgICAgICAgZmluZFNvdXJjZU1hcFVSTCA9IGZpbmRTb3VyY2VNYXBVUkxcbiAgICAgICAgICAgID8gZmluZFNvdXJjZU1hcFVSTChmaWxlbmFtZSwgZW52aXJvbm1lbnROYW1lKVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgIGZuID0gY3JlYXRlRmFrZUZ1bmN0aW9uKFxuICAgICAgICAgICAgZm4sXG4gICAgICAgICAgICBmaWxlbmFtZSxcbiAgICAgICAgICAgIGZpbmRTb3VyY2VNYXBVUkwsXG4gICAgICAgICAgICBsaW5lLFxuICAgICAgICAgICAgY29sLFxuICAgICAgICAgICAgdXNlRW5jbG9zaW5nTGluZSA/IGxpbmUgOiBlbmNsb3NpbmdMaW5lLFxuICAgICAgICAgICAgdXNlRW5jbG9zaW5nTGluZSA/IGNvbCA6IGZyYW1lLFxuICAgICAgICAgICAgZW52aXJvbm1lbnROYW1lXG4gICAgICAgICAgKTtcbiAgICAgICAgICBmYWtlRnVuY3Rpb25DYWNoZS5zZXQoZnJhbWVLZXksIGZuKTtcbiAgICAgICAgfVxuICAgICAgICBpbm5lckNhbGwgPSBmbi5iaW5kKG51bGwsIGlubmVyQ2FsbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5uZXJDYWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRSb290VGFzayhyZXNwb25zZSwgY2hpbGRFbnZpcm9ubWVudE5hbWUpIHtcbiAgICAgIHZhciByb290VGFzayA9IHJlc3BvbnNlLl9kZWJ1Z1Jvb3RUYXNrO1xuICAgICAgcmV0dXJuIHJvb3RUYXNrXG4gICAgICAgID8gcmVzcG9uc2UuX3Jvb3RFbnZpcm9ubWVudE5hbWUgIT09IGNoaWxkRW52aXJvbm1lbnROYW1lXG4gICAgICAgICAgPyAoKHJlc3BvbnNlID0gY29uc29sZS5jcmVhdGVUYXNrLmJpbmQoXG4gICAgICAgICAgICAgIGNvbnNvbGUsXG4gICAgICAgICAgICAgICdcInVzZSAnICsgY2hpbGRFbnZpcm9ubWVudE5hbWUudG9Mb3dlckNhc2UoKSArICdcIidcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgcm9vdFRhc2sucnVuKHJlc3BvbnNlKSlcbiAgICAgICAgICA6IHJvb3RUYXNrXG4gICAgICAgIDogbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW5pdGlhbGl6ZUZha2VUYXNrKHJlc3BvbnNlLCBkZWJ1Z0luZm8pIHtcbiAgICAgIGlmICghc3VwcG9ydHNDcmVhdGVUYXNrIHx8IG51bGwgPT0gZGVidWdJbmZvLnN0YWNrKSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBjYWNoZWRFbnRyeSA9IGRlYnVnSW5mby5kZWJ1Z1Rhc2s7XG4gICAgICBpZiAodm9pZCAwICE9PSBjYWNoZWRFbnRyeSkgcmV0dXJuIGNhY2hlZEVudHJ5O1xuICAgICAgdmFyIHVzZUVuY2xvc2luZ0xpbmUgPSB2b2lkIDAgPT09IGRlYnVnSW5mby5rZXksXG4gICAgICAgIHN0YWNrID0gZGVidWdJbmZvLnN0YWNrLFxuICAgICAgICBlbnYgPVxuICAgICAgICAgIG51bGwgPT0gZGVidWdJbmZvLmVudiA/IHJlc3BvbnNlLl9yb290RW52aXJvbm1lbnROYW1lIDogZGVidWdJbmZvLmVudjtcbiAgICAgIGNhY2hlZEVudHJ5ID1cbiAgICAgICAgbnVsbCA9PSBkZWJ1Z0luZm8ub3duZXIgfHwgbnVsbCA9PSBkZWJ1Z0luZm8ub3duZXIuZW52XG4gICAgICAgICAgPyByZXNwb25zZS5fcm9vdEVudmlyb25tZW50TmFtZVxuICAgICAgICAgIDogZGVidWdJbmZvLm93bmVyLmVudjtcbiAgICAgIHZhciBvd25lclRhc2sgPVxuICAgICAgICBudWxsID09IGRlYnVnSW5mby5vd25lclxuICAgICAgICAgID8gbnVsbFxuICAgICAgICAgIDogaW5pdGlhbGl6ZUZha2VUYXNrKHJlc3BvbnNlLCBkZWJ1Z0luZm8ub3duZXIpO1xuICAgICAgZW52ID1cbiAgICAgICAgZW52ICE9PSBjYWNoZWRFbnRyeVxuICAgICAgICAgID8gJ1widXNlICcgKyBlbnYudG9Mb3dlckNhc2UoKSArICdcIidcbiAgICAgICAgICA6IHZvaWQgMCAhPT0gZGVidWdJbmZvLmtleVxuICAgICAgICAgICAgPyBcIjxcIiArIChkZWJ1Z0luZm8ubmFtZSB8fCBcIi4uLlwiKSArIFwiPlwiXG4gICAgICAgICAgICA6IHZvaWQgMCAhPT0gZGVidWdJbmZvLm5hbWVcbiAgICAgICAgICAgICAgPyBkZWJ1Z0luZm8ubmFtZSB8fCBcInVua25vd25cIlxuICAgICAgICAgICAgICA6IFwiYXdhaXQgXCIgKyAoZGVidWdJbmZvLmF3YWl0ZWQubmFtZSB8fCBcInVua25vd25cIik7XG4gICAgICBlbnYgPSBjb25zb2xlLmNyZWF0ZVRhc2suYmluZChjb25zb2xlLCBlbnYpO1xuICAgICAgdXNlRW5jbG9zaW5nTGluZSA9IGJ1aWxkRmFrZUNhbGxTdGFjayhcbiAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgIHN0YWNrLFxuICAgICAgICBjYWNoZWRFbnRyeSxcbiAgICAgICAgdXNlRW5jbG9zaW5nTGluZSxcbiAgICAgICAgZW52XG4gICAgICApO1xuICAgICAgbnVsbCA9PT0gb3duZXJUYXNrXG4gICAgICAgID8gKChyZXNwb25zZSA9IGdldFJvb3RUYXNrKHJlc3BvbnNlLCBjYWNoZWRFbnRyeSkpLFxuICAgICAgICAgIChyZXNwb25zZSA9XG4gICAgICAgICAgICBudWxsICE9IHJlc3BvbnNlXG4gICAgICAgICAgICAgID8gcmVzcG9uc2UucnVuKHVzZUVuY2xvc2luZ0xpbmUpXG4gICAgICAgICAgICAgIDogdXNlRW5jbG9zaW5nTGluZSgpKSlcbiAgICAgICAgOiAocmVzcG9uc2UgPSBvd25lclRhc2sucnVuKHVzZUVuY2xvc2luZ0xpbmUpKTtcbiAgICAgIHJldHVybiAoZGVidWdJbmZvLmRlYnVnVGFzayA9IHJlc3BvbnNlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmFrZUpTWENhbGxTaXRlKCkge1xuICAgICAgcmV0dXJuIEVycm9yKFwicmVhY3Qtc3RhY2stdG9wLWZyYW1lXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbml0aWFsaXplRmFrZVN0YWNrKHJlc3BvbnNlLCBkZWJ1Z0luZm8pIHtcbiAgICAgIGlmICh2b2lkIDAgPT09IGRlYnVnSW5mby5kZWJ1Z1N0YWNrKSB7XG4gICAgICAgIG51bGwgIT0gZGVidWdJbmZvLnN0YWNrICYmXG4gICAgICAgICAgKGRlYnVnSW5mby5kZWJ1Z1N0YWNrID0gY3JlYXRlRmFrZUpTWENhbGxTdGFja0luREVWKFxuICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICBkZWJ1Z0luZm8uc3RhY2ssXG4gICAgICAgICAgICBudWxsID09IGRlYnVnSW5mby5lbnYgPyBcIlwiIDogZGVidWdJbmZvLmVudlxuICAgICAgICAgICkpO1xuICAgICAgICB2YXIgb3duZXIgPSBkZWJ1Z0luZm8ub3duZXI7XG4gICAgICAgIG51bGwgIT0gb3duZXIgJiZcbiAgICAgICAgICAoaW5pdGlhbGl6ZUZha2VTdGFjayhyZXNwb25zZSwgb3duZXIpLFxuICAgICAgICAgIHZvaWQgMCA9PT0gb3duZXIuZGVidWdMb2NhdGlvbiAmJlxuICAgICAgICAgICAgbnVsbCAhPSBkZWJ1Z0luZm8uZGVidWdTdGFjayAmJlxuICAgICAgICAgICAgKG93bmVyLmRlYnVnTG9jYXRpb24gPSBkZWJ1Z0luZm8uZGVidWdTdGFjaykpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZXNvbHZlRGVidWdJbmZvKHJlc3BvbnNlLCBpZCwgZGVidWdJbmZvKSB7XG4gICAgICB2b2lkIDAgIT09IGRlYnVnSW5mby5zdGFjayAmJiBpbml0aWFsaXplRmFrZVRhc2socmVzcG9uc2UsIGRlYnVnSW5mbyk7XG4gICAgICBudWxsID09IGRlYnVnSW5mby5vd25lciAmJiBudWxsICE9IHJlc3BvbnNlLl9kZWJ1Z1Jvb3RPd25lclxuICAgICAgICA/ICgoZGVidWdJbmZvLm93bmVyID0gcmVzcG9uc2UuX2RlYnVnUm9vdE93bmVyKSxcbiAgICAgICAgICAoZGVidWdJbmZvLnN0YWNrID0gbnVsbCksXG4gICAgICAgICAgKGRlYnVnSW5mby5kZWJ1Z1N0YWNrID0gcmVzcG9uc2UuX2RlYnVnUm9vdFN0YWNrKSxcbiAgICAgICAgICAoZGVidWdJbmZvLmRlYnVnVGFzayA9IHJlc3BvbnNlLl9kZWJ1Z1Jvb3RUYXNrKSlcbiAgICAgICAgOiB2b2lkIDAgIT09IGRlYnVnSW5mby5zdGFjayAmJlxuICAgICAgICAgIGluaXRpYWxpemVGYWtlU3RhY2socmVzcG9uc2UsIGRlYnVnSW5mbyk7XG4gICAgICByZXNwb25zZSA9IGdldENodW5rKHJlc3BvbnNlLCBpZCk7XG4gICAgICAocmVzcG9uc2UuX2RlYnVnSW5mbyB8fCAocmVzcG9uc2UuX2RlYnVnSW5mbyA9IFtdKSkucHVzaChkZWJ1Z0luZm8pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRDdXJyZW50U3RhY2tJbkRFVigpIHtcbiAgICAgIHZhciBvd25lciA9IGN1cnJlbnRPd25lckluREVWO1xuICAgICAgaWYgKG51bGwgPT09IG93bmVyKSByZXR1cm4gXCJcIjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBpbmZvID0gXCJcIjtcbiAgICAgICAgaWYgKG93bmVyLm93bmVyIHx8IFwic3RyaW5nXCIgIT09IHR5cGVvZiBvd25lci5uYW1lKSB7XG4gICAgICAgICAgZm9yICg7IG93bmVyOyApIHtcbiAgICAgICAgICAgIHZhciBvd25lclN0YWNrID0gb3duZXIuZGVidWdTdGFjaztcbiAgICAgICAgICAgIGlmIChudWxsICE9IG93bmVyU3RhY2spIHtcbiAgICAgICAgICAgICAgaWYgKChvd25lciA9IG93bmVyLm93bmVyKSkge1xuICAgICAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX3RlbXBfY29uc3QgPSBpbmZvO1xuICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IG93bmVyU3RhY2ssXG4gICAgICAgICAgICAgICAgICBwcmV2UHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTtcbiAgICAgICAgICAgICAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXBhcmVTdGFja1RyYWNlO1xuICAgICAgICAgICAgICAgIHZhciBzdGFjayA9IGVycm9yLnN0YWNrO1xuICAgICAgICAgICAgICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldlByZXBhcmVTdGFja1RyYWNlO1xuICAgICAgICAgICAgICAgIHN0YWNrLnN0YXJ0c1dpdGgoXCJFcnJvcjogcmVhY3Qtc3RhY2stdG9wLWZyYW1lXFxuXCIpICYmXG4gICAgICAgICAgICAgICAgICAoc3RhY2sgPSBzdGFjay5zbGljZSgyOSkpO1xuICAgICAgICAgICAgICAgIHZhciBpZHggPSBzdGFjay5pbmRleE9mKFwiXFxuXCIpO1xuICAgICAgICAgICAgICAgIC0xICE9PSBpZHggJiYgKHN0YWNrID0gc3RhY2suc2xpY2UoaWR4ICsgMSkpO1xuICAgICAgICAgICAgICAgIGlkeCA9IHN0YWNrLmluZGV4T2YoXCJyZWFjdF9zdGFja19ib3R0b21fZnJhbWVcIik7XG4gICAgICAgICAgICAgICAgLTEgIT09IGlkeCAmJiAoaWR4ID0gc3RhY2subGFzdEluZGV4T2YoXCJcXG5cIiwgaWR4KSk7XG4gICAgICAgICAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9XG4gICAgICAgICAgICAgICAgICAtMSAhPT0gaWR4ID8gKHN0YWNrID0gc3RhY2suc2xpY2UoMCwgaWR4KSkgOiBcIlwiO1xuICAgICAgICAgICAgICAgIGluZm8gPVxuICAgICAgICAgICAgICAgICAgSlNDb21waWxlcl90ZW1wX2NvbnN0ICsgKFwiXFxuXCIgKyBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDAgPSBpbmZvO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcF9jb25zdCA9IG93bmVyLm5hbWU7XG4gICAgICAgICAgaWYgKHZvaWQgMCA9PT0gcHJlZml4KVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgKHByZWZpeCA9XG4gICAgICAgICAgICAgICAgKChlcnJvciA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLykpICYmIGVycm9yWzFdKSB8fFxuICAgICAgICAgICAgICAgIFwiXCIpLFxuICAgICAgICAgICAgICAgIChzdWZmaXggPVxuICAgICAgICAgICAgICAgICAgLTEgPCB4LnN0YWNrLmluZGV4T2YoXCJcXG4gICAgYXRcIilcbiAgICAgICAgICAgICAgICAgICAgPyBcIiAoPGFub255bW91cz4pXCJcbiAgICAgICAgICAgICAgICAgICAgOiAtMSA8IHguc3RhY2suaW5kZXhPZihcIkBcIilcbiAgICAgICAgICAgICAgICAgICAgICA/IFwiQHVua25vd246MDowXCJcbiAgICAgICAgICAgICAgICAgICAgICA6IFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMCA9XG4gICAgICAgICAgICBcIlxcblwiICsgcHJlZml4ICsgSlNDb21waWxlcl90ZW1wX2NvbnN0ICsgc3VmZml4O1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMCA9XG4gICAgICAgICAgXCJcXG5FcnJvciBnZW5lcmF0aW5nIHN0YWNrOiBcIiArIHgubWVzc2FnZSArIFwiXFxuXCIgKyB4LnN0YWNrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzb2x2ZUNvbnNvbGVFbnRyeShyZXNwb25zZSwgdmFsdWUpIHtcbiAgICAgIGlmIChyZXNwb25zZS5fcmVwbGF5Q29uc29sZSkge1xuICAgICAgICB2YXIgcGF5bG9hZCA9IEpTT04ucGFyc2UodmFsdWUsIHJlc3BvbnNlLl9mcm9tSlNPTik7XG4gICAgICAgIHZhbHVlID0gcGF5bG9hZFswXTtcbiAgICAgICAgdmFyIHN0YWNrVHJhY2UgPSBwYXlsb2FkWzFdLFxuICAgICAgICAgIG93bmVyID0gcGF5bG9hZFsyXSxcbiAgICAgICAgICBlbnYgPSBwYXlsb2FkWzNdO1xuICAgICAgICBwYXlsb2FkID0gcGF5bG9hZC5zbGljZSg0KTtcbiAgICAgICAgcmVwbGF5Q29uc29sZVdpdGhDYWxsU3RhY2tJbkRFVihcbiAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBzdGFja1RyYWNlLFxuICAgICAgICAgIG93bmVyLFxuICAgICAgICAgIGVudixcbiAgICAgICAgICBwYXlsb2FkXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1lcmdlQnVmZmVyKGJ1ZmZlciwgbGFzdENodW5rKSB7XG4gICAgICBmb3IgKFxuICAgICAgICB2YXIgbCA9IGJ1ZmZlci5sZW5ndGgsIGJ5dGVMZW5ndGggPSBsYXN0Q2h1bmsubGVuZ3RoLCBpID0gMDtcbiAgICAgICAgaSA8IGw7XG4gICAgICAgIGkrK1xuICAgICAgKVxuICAgICAgICBieXRlTGVuZ3RoICs9IGJ1ZmZlcltpXS5ieXRlTGVuZ3RoO1xuICAgICAgYnl0ZUxlbmd0aCA9IG5ldyBVaW50OEFycmF5KGJ5dGVMZW5ndGgpO1xuICAgICAgZm9yICh2YXIgX2kzID0gKGkgPSAwKTsgX2kzIDwgbDsgX2kzKyspIHtcbiAgICAgICAgdmFyIGNodW5rID0gYnVmZmVyW19pM107XG4gICAgICAgIGJ5dGVMZW5ndGguc2V0KGNodW5rLCBpKTtcbiAgICAgICAgaSArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgICAgfVxuICAgICAgYnl0ZUxlbmd0aC5zZXQobGFzdENodW5rLCBpKTtcbiAgICAgIHJldHVybiBieXRlTGVuZ3RoO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNvbHZlVHlwZWRBcnJheShcbiAgICAgIHJlc3BvbnNlLFxuICAgICAgaWQsXG4gICAgICBidWZmZXIsXG4gICAgICBsYXN0Q2h1bmssXG4gICAgICBjb25zdHJ1Y3RvcixcbiAgICAgIGJ5dGVzUGVyRWxlbWVudFxuICAgICkge1xuICAgICAgYnVmZmVyID1cbiAgICAgICAgMCA9PT0gYnVmZmVyLmxlbmd0aCAmJiAwID09PSBsYXN0Q2h1bmsuYnl0ZU9mZnNldCAlIGJ5dGVzUGVyRWxlbWVudFxuICAgICAgICAgID8gbGFzdENodW5rXG4gICAgICAgICAgOiBtZXJnZUJ1ZmZlcihidWZmZXIsIGxhc3RDaHVuayk7XG4gICAgICBjb25zdHJ1Y3RvciA9IG5ldyBjb25zdHJ1Y3RvcihcbiAgICAgICAgYnVmZmVyLmJ1ZmZlcixcbiAgICAgICAgYnVmZmVyLmJ5dGVPZmZzZXQsXG4gICAgICAgIGJ1ZmZlci5ieXRlTGVuZ3RoIC8gYnl0ZXNQZXJFbGVtZW50XG4gICAgICApO1xuICAgICAgcmVzb2x2ZUJ1ZmZlcihyZXNwb25zZSwgaWQsIGNvbnN0cnVjdG9yKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmx1c2hJbml0aWFsUmVuZGVyUGVyZm9ybWFuY2UoKSB7fVxuICAgIGZ1bmN0aW9uIHByb2Nlc3NGdWxsQmluYXJ5Um93KHJlc3BvbnNlLCBpZCwgdGFnLCBidWZmZXIsIGNodW5rKSB7XG4gICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICBjYXNlIDY1OlxuICAgICAgICAgIHJlc29sdmVCdWZmZXIocmVzcG9uc2UsIGlkLCBtZXJnZUJ1ZmZlcihidWZmZXIsIGNodW5rKS5idWZmZXIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSA3OTpcbiAgICAgICAgICByZXNvbHZlVHlwZWRBcnJheShyZXNwb25zZSwgaWQsIGJ1ZmZlciwgY2h1bmssIEludDhBcnJheSwgMSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlIDExMTpcbiAgICAgICAgICByZXNvbHZlQnVmZmVyKFxuICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIDAgPT09IGJ1ZmZlci5sZW5ndGggPyBjaHVuayA6IG1lcmdlQnVmZmVyKGJ1ZmZlciwgY2h1bmspXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgODU6XG4gICAgICAgICAgcmVzb2x2ZVR5cGVkQXJyYXkocmVzcG9uc2UsIGlkLCBidWZmZXIsIGNodW5rLCBVaW50OENsYW1wZWRBcnJheSwgMSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlIDgzOlxuICAgICAgICAgIHJlc29sdmVUeXBlZEFycmF5KHJlc3BvbnNlLCBpZCwgYnVmZmVyLCBjaHVuaywgSW50MTZBcnJheSwgMik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlIDExNTpcbiAgICAgICAgICByZXNvbHZlVHlwZWRBcnJheShyZXNwb25zZSwgaWQsIGJ1ZmZlciwgY2h1bmssIFVpbnQxNkFycmF5LCAyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgNzY6XG4gICAgICAgICAgcmVzb2x2ZVR5cGVkQXJyYXkocmVzcG9uc2UsIGlkLCBidWZmZXIsIGNodW5rLCBJbnQzMkFycmF5LCA0KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgMTA4OlxuICAgICAgICAgIHJlc29sdmVUeXBlZEFycmF5KHJlc3BvbnNlLCBpZCwgYnVmZmVyLCBjaHVuaywgVWludDMyQXJyYXksIDQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSA3MTpcbiAgICAgICAgICByZXNvbHZlVHlwZWRBcnJheShyZXNwb25zZSwgaWQsIGJ1ZmZlciwgY2h1bmssIEZsb2F0MzJBcnJheSwgNCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlIDEwMzpcbiAgICAgICAgICByZXNvbHZlVHlwZWRBcnJheShyZXNwb25zZSwgaWQsIGJ1ZmZlciwgY2h1bmssIEZsb2F0NjRBcnJheSwgOCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlIDc3OlxuICAgICAgICAgIHJlc29sdmVUeXBlZEFycmF5KHJlc3BvbnNlLCBpZCwgYnVmZmVyLCBjaHVuaywgQmlnSW50NjRBcnJheSwgOCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlIDEwOTpcbiAgICAgICAgICByZXNvbHZlVHlwZWRBcnJheShyZXNwb25zZSwgaWQsIGJ1ZmZlciwgY2h1bmssIEJpZ1VpbnQ2NEFycmF5LCA4KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgODY6XG4gICAgICAgICAgcmVzb2x2ZVR5cGVkQXJyYXkocmVzcG9uc2UsIGlkLCBidWZmZXIsIGNodW5rLCBEYXRhVmlldywgMSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm9yIChcbiAgICAgICAgdmFyIHN0cmluZ0RlY29kZXIgPSByZXNwb25zZS5fc3RyaW5nRGVjb2Rlciwgcm93ID0gXCJcIiwgaSA9IDA7XG4gICAgICAgIGkgPCBidWZmZXIubGVuZ3RoO1xuICAgICAgICBpKytcbiAgICAgIClcbiAgICAgICAgcm93ICs9IHN0cmluZ0RlY29kZXIuZGVjb2RlKGJ1ZmZlcltpXSwgZGVjb2Rlck9wdGlvbnMpO1xuICAgICAgcm93ICs9IHN0cmluZ0RlY29kZXIuZGVjb2RlKGNodW5rKTtcbiAgICAgIHByb2Nlc3NGdWxsU3RyaW5nUm93KHJlc3BvbnNlLCBpZCwgdGFnLCByb3cpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcm9jZXNzRnVsbFN0cmluZ1JvdyhyZXNwb25zZSwgaWQsIHRhZywgcm93KSB7XG4gICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICBjYXNlIDczOlxuICAgICAgICAgIHJlc29sdmVNb2R1bGUocmVzcG9uc2UsIGlkLCByb3cpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDcyOlxuICAgICAgICAgIHJlc29sdmVIaW50KHJlc3BvbnNlLCByb3dbMF0sIHJvdy5zbGljZSgxKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNjk6XG4gICAgICAgICAgcm93ID0gSlNPTi5wYXJzZShyb3cpO1xuICAgICAgICAgIHRhZyA9IHJlc29sdmVFcnJvckRldihyZXNwb25zZSwgcm93KTtcbiAgICAgICAgICB0YWcuZGlnZXN0ID0gcm93LmRpZ2VzdDtcbiAgICAgICAgICByb3cgPSByZXNwb25zZS5fY2h1bmtzO1xuICAgICAgICAgIHZhciBjaHVuayA9IHJvdy5nZXQoaWQpO1xuICAgICAgICAgIGNodW5rXG4gICAgICAgICAgICA/IHRyaWdnZXJFcnJvck9uQ2h1bmsocmVzcG9uc2UsIGNodW5rLCB0YWcpXG4gICAgICAgICAgICA6IHJvdy5zZXQoaWQsIG5ldyBSZWFjdFByb21pc2UoXCJyZWplY3RlZFwiLCBudWxsLCB0YWcpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA4NDpcbiAgICAgICAgICByZXNvbHZlVGV4dChyZXNwb25zZSwgaWQsIHJvdyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNzg6XG4gICAgICAgIGNhc2UgNjg6XG4gICAgICAgICAgdGFnID0gbmV3IFJlYWN0UHJvbWlzZShcInJlc29sdmVkX21vZGVsXCIsIHJvdywgcmVzcG9uc2UpO1xuICAgICAgICAgIGluaXRpYWxpemVNb2RlbENodW5rKHRhZyk7XG4gICAgICAgICAgXCJmdWxmaWxsZWRcIiA9PT0gdGFnLnN0YXR1c1xuICAgICAgICAgICAgPyByZXNvbHZlRGVidWdJbmZvKHJlc3BvbnNlLCBpZCwgdGFnLnZhbHVlKVxuICAgICAgICAgICAgOiB0YWcudGhlbihcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVEZWJ1Z0luZm8ocmVzcG9uc2UsIGlkLCB2KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHt9XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNzQ6XG4gICAgICAgIGNhc2UgODc6XG4gICAgICAgICAgcmVzb2x2ZUNvbnNvbGVFbnRyeShyZXNwb25zZSwgcm93KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA4MjpcbiAgICAgICAgICBzdGFydFJlYWRhYmxlU3RyZWFtKHJlc3BvbnNlLCBpZCwgdm9pZCAwKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMTQ6XG4gICAgICAgICAgc3RhcnRSZWFkYWJsZVN0cmVhbShyZXNwb25zZSwgaWQsIFwiYnl0ZXNcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgODg6XG4gICAgICAgICAgc3RhcnRBc3luY0l0ZXJhYmxlKHJlc3BvbnNlLCBpZCwgITEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEyMDpcbiAgICAgICAgICBzdGFydEFzeW5jSXRlcmFibGUocmVzcG9uc2UsIGlkLCAhMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNjc6XG4gICAgICAgICAgc3RvcFN0cmVhbShyZXNwb25zZSwgaWQsIHJvdyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgXCJcIiA9PT0gcm93XG4gICAgICAgICAgICA/IHJlc29sdmVEZWJ1Z0hhbHQocmVzcG9uc2UsIGlkKVxuICAgICAgICAgICAgOiByZXNvbHZlTW9kZWwocmVzcG9uc2UsIGlkLCByb3cpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwcm9jZXNzQmluYXJ5Q2h1bmsod2Vha1Jlc3BvbnNlLCBzdHJlYW1TdGF0ZSwgY2h1bmspIHtcbiAgICAgIGlmICh2b2lkIDAgIT09IHdlYWtSZXNwb25zZS53ZWFrLmRlcmVmKCkpIHtcbiAgICAgICAgdmFyIHJlc3BvbnNlID0gdW53cmFwV2Vha1Jlc3BvbnNlKHdlYWtSZXNwb25zZSksXG4gICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgcm93U3RhdGUgPSBzdHJlYW1TdGF0ZS5fcm93U3RhdGU7XG4gICAgICAgIHdlYWtSZXNwb25zZSA9IHN0cmVhbVN0YXRlLl9yb3dJRDtcbiAgICAgICAgZm9yIChcbiAgICAgICAgICB2YXIgcm93VGFnID0gc3RyZWFtU3RhdGUuX3Jvd1RhZyxcbiAgICAgICAgICAgIHJvd0xlbmd0aCA9IHN0cmVhbVN0YXRlLl9yb3dMZW5ndGgsXG4gICAgICAgICAgICBidWZmZXIgPSBzdHJlYW1TdGF0ZS5fYnVmZmVyLFxuICAgICAgICAgICAgY2h1bmtMZW5ndGggPSBjaHVuay5sZW5ndGg7XG4gICAgICAgICAgaSA8IGNodW5rTGVuZ3RoO1xuXG4gICAgICAgICkge1xuICAgICAgICAgIHZhciBsYXN0SWR4ID0gLTE7XG4gICAgICAgICAgc3dpdGNoIChyb3dTdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBsYXN0SWR4ID0gY2h1bmtbaSsrXTtcbiAgICAgICAgICAgICAgNTggPT09IGxhc3RJZHhcbiAgICAgICAgICAgICAgICA/IChyb3dTdGF0ZSA9IDEpXG4gICAgICAgICAgICAgICAgOiAod2Vha1Jlc3BvbnNlID1cbiAgICAgICAgICAgICAgICAgICAgKHdlYWtSZXNwb25zZSA8PCA0KSB8XG4gICAgICAgICAgICAgICAgICAgICg5NiA8IGxhc3RJZHggPyBsYXN0SWR4IC0gODcgOiBsYXN0SWR4IC0gNDgpKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIHJvd1N0YXRlID0gY2h1bmtbaV07XG4gICAgICAgICAgICAgIDg0ID09PSByb3dTdGF0ZSB8fFxuICAgICAgICAgICAgICA2NSA9PT0gcm93U3RhdGUgfHxcbiAgICAgICAgICAgICAgNzkgPT09IHJvd1N0YXRlIHx8XG4gICAgICAgICAgICAgIDExMSA9PT0gcm93U3RhdGUgfHxcbiAgICAgICAgICAgICAgODUgPT09IHJvd1N0YXRlIHx8XG4gICAgICAgICAgICAgIDgzID09PSByb3dTdGF0ZSB8fFxuICAgICAgICAgICAgICAxMTUgPT09IHJvd1N0YXRlIHx8XG4gICAgICAgICAgICAgIDc2ID09PSByb3dTdGF0ZSB8fFxuICAgICAgICAgICAgICAxMDggPT09IHJvd1N0YXRlIHx8XG4gICAgICAgICAgICAgIDcxID09PSByb3dTdGF0ZSB8fFxuICAgICAgICAgICAgICAxMDMgPT09IHJvd1N0YXRlIHx8XG4gICAgICAgICAgICAgIDc3ID09PSByb3dTdGF0ZSB8fFxuICAgICAgICAgICAgICAxMDkgPT09IHJvd1N0YXRlIHx8XG4gICAgICAgICAgICAgIDg2ID09PSByb3dTdGF0ZVxuICAgICAgICAgICAgICAgID8gKChyb3dUYWcgPSByb3dTdGF0ZSksIChyb3dTdGF0ZSA9IDIpLCBpKyspXG4gICAgICAgICAgICAgICAgOiAoNjQgPCByb3dTdGF0ZSAmJiA5MSA+IHJvd1N0YXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAzNSA9PT0gcm93U3RhdGUgfHxcbiAgICAgICAgICAgICAgICAgICAgMTE0ID09PSByb3dTdGF0ZSB8fFxuICAgICAgICAgICAgICAgICAgICAxMjAgPT09IHJvd1N0YXRlXG4gICAgICAgICAgICAgICAgICA/ICgocm93VGFnID0gcm93U3RhdGUpLCAocm93U3RhdGUgPSAzKSwgaSsrKVxuICAgICAgICAgICAgICAgICAgOiAoKHJvd1RhZyA9IDApLCAocm93U3RhdGUgPSAzKSk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBsYXN0SWR4ID0gY2h1bmtbaSsrXTtcbiAgICAgICAgICAgICAgNDQgPT09IGxhc3RJZHhcbiAgICAgICAgICAgICAgICA/IChyb3dTdGF0ZSA9IDQpXG4gICAgICAgICAgICAgICAgOiAocm93TGVuZ3RoID1cbiAgICAgICAgICAgICAgICAgICAgKHJvd0xlbmd0aCA8PCA0KSB8XG4gICAgICAgICAgICAgICAgICAgICg5NiA8IGxhc3RJZHggPyBsYXN0SWR4IC0gODcgOiBsYXN0SWR4IC0gNDgpKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIGxhc3RJZHggPSBjaHVuay5pbmRleE9mKDEwLCBpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIChsYXN0SWR4ID0gaSArIHJvd0xlbmd0aCksXG4gICAgICAgICAgICAgICAgbGFzdElkeCA+IGNodW5rLmxlbmd0aCAmJiAobGFzdElkeCA9IC0xKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG9mZnNldCA9IGNodW5rLmJ5dGVPZmZzZXQgKyBpO1xuICAgICAgICAgIGlmICgtMSA8IGxhc3RJZHgpXG4gICAgICAgICAgICAocm93TGVuZ3RoID0gbmV3IFVpbnQ4QXJyYXkoY2h1bmsuYnVmZmVyLCBvZmZzZXQsIGxhc3RJZHggLSBpKSksXG4gICAgICAgICAgICAgIHByb2Nlc3NGdWxsQmluYXJ5Um93KFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIHdlYWtSZXNwb25zZSxcbiAgICAgICAgICAgICAgICByb3dUYWcsXG4gICAgICAgICAgICAgICAgYnVmZmVyLFxuICAgICAgICAgICAgICAgIHJvd0xlbmd0aFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAoaSA9IGxhc3RJZHgpLFxuICAgICAgICAgICAgICAzID09PSByb3dTdGF0ZSAmJiBpKyssXG4gICAgICAgICAgICAgIChyb3dMZW5ndGggPSB3ZWFrUmVzcG9uc2UgPSByb3dUYWcgPSByb3dTdGF0ZSA9IDApLFxuICAgICAgICAgICAgICAoYnVmZmVyLmxlbmd0aCA9IDApO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2h1bmsgPSBuZXcgVWludDhBcnJheShjaHVuay5idWZmZXIsIG9mZnNldCwgY2h1bmsuYnl0ZUxlbmd0aCAtIGkpO1xuICAgICAgICAgICAgYnVmZmVyLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgcm93TGVuZ3RoIC09IGNodW5rLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtU3RhdGUuX3Jvd1N0YXRlID0gcm93U3RhdGU7XG4gICAgICAgIHN0cmVhbVN0YXRlLl9yb3dJRCA9IHdlYWtSZXNwb25zZTtcbiAgICAgICAgc3RyZWFtU3RhdGUuX3Jvd1RhZyA9IHJvd1RhZztcbiAgICAgICAgc3RyZWFtU3RhdGUuX3Jvd0xlbmd0aCA9IHJvd0xlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlRnJvbUpTT05DYWxsYmFjayhyZXNwb25zZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdmFsdWUpXG4gICAgICAgICAgcmV0dXJuIHBhcnNlTW9kZWxTdHJpbmcocmVzcG9uc2UsIHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHZhbHVlICYmIG51bGwgIT09IHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHZhbHVlWzBdID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpXG4gICAgICAgICAgICBiOiB7XG4gICAgICAgICAgICAgIHZhciBvd25lciA9IHZhbHVlWzRdO1xuICAgICAgICAgICAgICBrZXkgPSB2YWx1ZVs1XTtcbiAgICAgICAgICAgICAgdmFyIHZhbGlkYXRlZCA9IHZhbHVlWzZdO1xuICAgICAgICAgICAgICB2YWx1ZSA9IHtcbiAgICAgICAgICAgICAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgICAgICAgICAgICAgIHR5cGU6IHZhbHVlWzFdLFxuICAgICAgICAgICAgICAgIGtleTogdmFsdWVbMl0sXG4gICAgICAgICAgICAgICAgcHJvcHM6IHZhbHVlWzNdLFxuICAgICAgICAgICAgICAgIF9vd25lcjogdm9pZCAwID09PSBvd25lciA/IG51bGwgOiBvd25lclxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsdWUsIFwicmVmXCIsIHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgICAgICAgICBnZXQ6IG51bGxSZWZHZXR0ZXJcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHZhbHVlLl9zdG9yZSA9IHt9O1xuICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsdWUuX3N0b3JlLCBcInZhbGlkYXRlZFwiLCB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbGlkYXRlZFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbHVlLCBcIl9kZWJ1Z0luZm9cIiwge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsdWUsIFwiX2RlYnVnU3RhY2tcIiwge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2b2lkIDAgPT09IGtleSA/IG51bGwgOiBrZXlcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWx1ZSwgXCJfZGVidWdUYXNrXCIsIHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKG51bGwgIT09IGluaXRpYWxpemluZ0hhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZWQgPSBpbml0aWFsaXppbmdIYW5kbGVyO1xuICAgICAgICAgICAgICAgIGluaXRpYWxpemluZ0hhbmRsZXIgPSB2YWxpZGF0ZWQucGFyZW50O1xuICAgICAgICAgICAgICAgIGlmICh2YWxpZGF0ZWQuZXJyb3JlZCkge1xuICAgICAgICAgICAgICAgICAga2V5ID0gbmV3IFJlYWN0UHJvbWlzZShcInJlamVjdGVkXCIsIG51bGwsIHZhbGlkYXRlZC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICBpbml0aWFsaXplRWxlbWVudChyZXNwb25zZSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgdmFsaWRhdGVkID0ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodmFsdWUudHlwZSkgfHwgXCJcIixcbiAgICAgICAgICAgICAgICAgICAgb3duZXI6IHZhbHVlLl9vd25lclxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIHZhbGlkYXRlZC5kZWJ1Z1N0YWNrID0gdmFsdWUuX2RlYnVnU3RhY2s7XG4gICAgICAgICAgICAgICAgICBzdXBwb3J0c0NyZWF0ZVRhc2sgJiZcbiAgICAgICAgICAgICAgICAgICAgKHZhbGlkYXRlZC5kZWJ1Z1Rhc2sgPSB2YWx1ZS5fZGVidWdUYXNrKTtcbiAgICAgICAgICAgICAgICAgIGtleS5fZGVidWdJbmZvID0gW3ZhbGlkYXRlZF07XG4gICAgICAgICAgICAgICAgICB2YWx1ZSA9IGNyZWF0ZUxhenlDaHVua1dyYXBwZXIoa2V5KTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgwIDwgdmFsaWRhdGVkLmRlcHMpIHtcbiAgICAgICAgICAgICAgICAgIGtleSA9IG5ldyBSZWFjdFByb21pc2UoXCJibG9ja2VkXCIsIG51bGwsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgdmFsaWRhdGVkLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICB2YWxpZGF0ZWQuY2h1bmsgPSBrZXk7XG4gICAgICAgICAgICAgICAgICB2YWx1ZSA9IGluaXRpYWxpemVFbGVtZW50LmJpbmQobnVsbCwgcmVzcG9uc2UsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIGtleS50aGVuKHZhbHVlLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICB2YWx1ZSA9IGNyZWF0ZUxhenlDaHVua1dyYXBwZXIoa2V5KTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGluaXRpYWxpemVFbGVtZW50KHJlc3BvbnNlLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsb3NlKHdlYWtSZXNwb25zZSkge1xuICAgICAgcmVwb3J0R2xvYmFsRXJyb3Iod2Vha1Jlc3BvbnNlLCBFcnJvcihcIkNvbm5lY3Rpb24gY2xvc2VkLlwiKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vU2VydmVyQ2FsbCQxKCkge1xuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgIFwiU2VydmVyIEZ1bmN0aW9ucyBjYW5ub3QgYmUgY2FsbGVkIGR1cmluZyBpbml0aWFsIHJlbmRlci4gVGhpcyB3b3VsZCBjcmVhdGUgYSBmZXRjaCB3YXRlcmZhbGwuIFRyeSB0byB1c2UgYSBTZXJ2ZXIgQ29tcG9uZW50IHRvIHBhc3MgZGF0YSB0byBDbGllbnQgQ29tcG9uZW50cyBpbnN0ZWFkLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVSZXNwb25zZUZyb21PcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBuZXcgUmVzcG9uc2VJbnN0YW5jZShcbiAgICAgICAgb3B0aW9ucy5zZXJ2ZXJDb25zdW1lck1hbmlmZXN0Lm1vZHVsZU1hcCxcbiAgICAgICAgb3B0aW9ucy5zZXJ2ZXJDb25zdW1lck1hbmlmZXN0LnNlcnZlck1vZHVsZU1hcCxcbiAgICAgICAgb3B0aW9ucy5zZXJ2ZXJDb25zdW1lck1hbmlmZXN0Lm1vZHVsZUxvYWRpbmcsXG4gICAgICAgIG5vU2VydmVyQ2FsbCQxLFxuICAgICAgICBvcHRpb25zLmVuY29kZUZvcm1BY3Rpb24sXG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLm5vbmNlID8gb3B0aW9ucy5ub25jZSA6IHZvaWQgMCxcbiAgICAgICAgb3B0aW9ucyAmJiBvcHRpb25zLnRlbXBvcmFyeVJlZmVyZW5jZXNcbiAgICAgICAgICA/IG9wdGlvbnMudGVtcG9yYXJ5UmVmZXJlbmNlc1xuICAgICAgICAgIDogdm9pZCAwLFxuICAgICAgICBvcHRpb25zICYmIG9wdGlvbnMuZmluZFNvdXJjZU1hcFVSTCA/IG9wdGlvbnMuZmluZFNvdXJjZU1hcFVSTCA6IHZvaWQgMCxcbiAgICAgICAgb3B0aW9ucyA/ICEwID09PSBvcHRpb25zLnJlcGxheUNvbnNvbGVMb2dzIDogITEsXG4gICAgICAgIG9wdGlvbnMgJiYgb3B0aW9ucy5lbnZpcm9ubWVudE5hbWUgPyBvcHRpb25zLmVudmlyb25tZW50TmFtZSA6IHZvaWQgMCxcbiAgICAgICAgdm9pZCAwXG4gICAgICApLl93ZWFrUmVzcG9uc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0YXJ0UmVhZGluZ0Zyb21TdHJlYW0ocmVzcG9uc2UsIHN0cmVhbSkge1xuICAgICAgZnVuY3Rpb24gcHJvZ3Jlc3MoX3JlZikge1xuICAgICAgICB2YXIgdmFsdWUgPSBfcmVmLnZhbHVlO1xuICAgICAgICBpZiAoX3JlZi5kb25lKSBjbG9zZShyZXNwb25zZSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgcHJvY2Vzc0JpbmFyeUNodW5rKHJlc3BvbnNlLCBzdHJlYW1TdGF0ZSwgdmFsdWUpLFxuICAgICAgICAgICAgcmVhZGVyLnJlYWQoKS50aGVuKHByb2dyZXNzKS5jYXRjaChlcnJvcilcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZXJyb3IoZSkge1xuICAgICAgICByZXBvcnRHbG9iYWxFcnJvcihyZXNwb25zZSwgZSk7XG4gICAgICB9XG4gICAgICB2YXIgc3RyZWFtU3RhdGUgPSBjcmVhdGVTdHJlYW1TdGF0ZSgpLFxuICAgICAgICByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgICByZWFkZXIucmVhZCgpLnRoZW4ocHJvZ3Jlc3MpLmNhdGNoKGVycm9yKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbm9TZXJ2ZXJDYWxsKCkge1xuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgIFwiU2VydmVyIEZ1bmN0aW9ucyBjYW5ub3QgYmUgY2FsbGVkIGR1cmluZyBpbml0aWFsIHJlbmRlci4gVGhpcyB3b3VsZCBjcmVhdGUgYSBmZXRjaCB3YXRlcmZhbGwuIFRyeSB0byB1c2UgYSBTZXJ2ZXIgQ29tcG9uZW50IHRvIHBhc3MgZGF0YSB0byBDbGllbnQgQ29tcG9uZW50cyBpbnN0ZWFkLlwiXG4gICAgICApO1xuICAgIH1cbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoXCJ1dGlsXCIpLFxuICAgICAgUmVhY3RET00gPSByZXF1aXJlKFwicmVhY3QtZG9tXCIpLFxuICAgICAgUmVhY3QgPSByZXF1aXJlKFwicmVhY3RcIiksXG4gICAgICBkZWNvZGVyT3B0aW9ucyA9IHsgc3RyZWFtOiAhMCB9LFxuICAgICAgYmluZCQxID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQsXG4gICAgICBjaHVua0NhY2hlID0gbmV3IE1hcCgpLFxuICAgICAgUmVhY3RET01TaGFyZWRJbnRlcm5hbHMgPVxuICAgICAgICBSZWFjdERPTS5fX0RPTV9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUsXG4gICAgICBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QudHJhbnNpdGlvbmFsLmVsZW1lbnRcIiksXG4gICAgICBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wb3J0YWxcIiksXG4gICAgICBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpLFxuICAgICAgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKSxcbiAgICAgIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucHJvZmlsZXJcIiksXG4gICAgICBSRUFDVF9DT05TVU1FUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnN1bWVyXCIpLFxuICAgICAgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnRleHRcIiksXG4gICAgICBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpLFxuICAgICAgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZVwiKSxcbiAgICAgIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZV9saXN0XCIpLFxuICAgICAgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9cIiksXG4gICAgICBSRUFDVF9MQVpZX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QubGF6eVwiKSxcbiAgICAgIFJFQUNUX0FDVElWSVRZX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuYWN0aXZpdHlcIiksXG4gICAgICBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSBTeW1ib2wuaXRlcmF0b3IsXG4gICAgICBBU1lOQ19JVEVSQVRPUiA9IFN5bWJvbC5hc3luY0l0ZXJhdG9yLFxuICAgICAgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5LFxuICAgICAgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YsXG4gICAgICBqc3hQcm9wc1BhcmVudHMgPSBuZXcgV2Vha01hcCgpLFxuICAgICAganN4Q2hpbGRyZW5QYXJlbnRzID0gbmV3IFdlYWtNYXAoKSxcbiAgICAgIENMSUVOVF9SRUZFUkVOQ0VfVEFHID0gU3ltYm9sLmZvcihcInJlYWN0LmNsaWVudC5yZWZlcmVuY2VcIiksXG4gICAgICBPYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlLFxuICAgICAga25vd25TZXJ2ZXJSZWZlcmVuY2VzID0gbmV3IFdlYWtNYXAoKSxcbiAgICAgIGJvdW5kQ2FjaGUgPSBuZXcgV2Vha01hcCgpLFxuICAgICAgZmFrZVNlcnZlckZ1bmN0aW9uSWR4ID0gMCxcbiAgICAgIEZ1bmN0aW9uQmluZCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLFxuICAgICAgQXJyYXlTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZSxcbiAgICAgIHY4RnJhbWVSZWdFeHAgPVxuICAgICAgICAvXiB7M30gYXQgKD86KC4rKSBcXCgoLispOihcXGQrKTooXFxkKylcXCl8KD86YXN5bmMgKT8oLispOihcXGQrKTooXFxkKykpJC8sXG4gICAgICBqc2NTcGlkZXJNb25rZXlGcmFtZVJlZ0V4cCA9IC8oPzooLiopQCk/KC4qKTooXFxkKyk6KFxcZCspLyxcbiAgICAgIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UgPSBTeW1ib2wuZm9yKFwicmVhY3QuY2xpZW50LnJlZmVyZW5jZVwiKSxcbiAgICAgIHByZWZpeCxcbiAgICAgIHN1ZmZpeDtcbiAgICBuZXcgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFdlYWtNYXAgPyBXZWFrTWFwIDogTWFwKSgpO1xuICAgIHZhciBSZWFjdFNoYXJlZEludGVyYWxzU2VydmVyID1cbiAgICAgICAgUmVhY3QuX19TRVJWRVJfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfV0FSTl9VU0VSU19USEVZX0NBTk5PVF9VUEdSQURFLFxuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPVxuICAgICAgICBSZWFjdC5fX0NMSUVOVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUgfHxcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcmFsc1NlcnZlcjtcbiAgICBSZWFjdFByb21pc2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShQcm9taXNlLnByb3RvdHlwZSk7XG4gICAgUmVhY3RQcm9taXNlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgc3dpdGNoICh0aGlzLnN0YXR1cykge1xuICAgICAgICBjYXNlIFwicmVzb2x2ZWRfbW9kZWxcIjpcbiAgICAgICAgICBpbml0aWFsaXplTW9kZWxDaHVuayh0aGlzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInJlc29sdmVkX21vZHVsZVwiOlxuICAgICAgICAgIGluaXRpYWxpemVNb2R1bGVDaHVuayh0aGlzKTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodGhpcy5zdGF0dXMpIHtcbiAgICAgICAgY2FzZSBcImZ1bGZpbGxlZFwiOlxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJlc29sdmUgJiYgcmVzb2x2ZSh0aGlzLnZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInBlbmRpbmdcIjpcbiAgICAgICAgY2FzZSBcImJsb2NrZWRcIjpcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZXNvbHZlICYmXG4gICAgICAgICAgICAobnVsbCA9PT0gdGhpcy52YWx1ZSAmJiAodGhpcy52YWx1ZSA9IFtdKSxcbiAgICAgICAgICAgIHRoaXMudmFsdWUucHVzaChyZXNvbHZlKSk7XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmVqZWN0ICYmXG4gICAgICAgICAgICAobnVsbCA9PT0gdGhpcy5yZWFzb24gJiYgKHRoaXMucmVhc29uID0gW10pLFxuICAgICAgICAgICAgdGhpcy5yZWFzb24ucHVzaChyZWplY3QpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImhhbHRlZFwiOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJlamVjdCAmJiByZWplY3QodGhpcy5yZWFzb24pO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIGRlYnVnQ2hhbm5lbFJlZ2lzdHJ5ID1cbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnlcbiAgICAgICAgICA/IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShjbGVhbnVwRGVidWdDaGFubmVsKVxuICAgICAgICAgIDogbnVsbCxcbiAgICAgIGluaXRpYWxpemluZ0hhbmRsZXIgPSBudWxsLFxuICAgICAgc3VwcG9ydHNDcmVhdGVUYXNrID0gISFjb25zb2xlLmNyZWF0ZVRhc2ssXG4gICAgICBmYWtlRnVuY3Rpb25DYWNoZSA9IG5ldyBNYXAoKSxcbiAgICAgIGZha2VGdW5jdGlvbklkeCA9IDAsXG4gICAgICBjcmVhdGVGYWtlSlNYQ2FsbFN0YWNrID0ge1xuICAgICAgICByZWFjdF9zdGFja19ib3R0b21fZnJhbWU6IGZ1bmN0aW9uIChyZXNwb25zZSwgc3RhY2ssIGVudmlyb25tZW50TmFtZSkge1xuICAgICAgICAgIHJldHVybiBidWlsZEZha2VDYWxsU3RhY2soXG4gICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgIHN0YWNrLFxuICAgICAgICAgICAgZW52aXJvbm1lbnROYW1lLFxuICAgICAgICAgICAgITEsXG4gICAgICAgICAgICBmYWtlSlNYQ2FsbFNpdGVcbiAgICAgICAgICApKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjcmVhdGVGYWtlSlNYQ2FsbFN0YWNrSW5ERVYgPVxuICAgICAgICBjcmVhdGVGYWtlSlNYQ2FsbFN0YWNrLnJlYWN0X3N0YWNrX2JvdHRvbV9mcmFtZS5iaW5kKFxuICAgICAgICAgIGNyZWF0ZUZha2VKU1hDYWxsU3RhY2tcbiAgICAgICAgKSxcbiAgICAgIGN1cnJlbnRPd25lckluREVWID0gbnVsbCxcbiAgICAgIHJlcGxheUNvbnNvbGVXaXRoQ2FsbFN0YWNrID0ge1xuICAgICAgICByZWFjdF9zdGFja19ib3R0b21fZnJhbWU6IGZ1bmN0aW9uIChcbiAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICBtZXRob2ROYW1lLFxuICAgICAgICAgIHN0YWNrVHJhY2UsXG4gICAgICAgICAgb3duZXIsXG4gICAgICAgICAgZW52LFxuICAgICAgICAgIGFyZ3NcbiAgICAgICAgKSB7XG4gICAgICAgICAgdmFyIHByZXZTdGFjayA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjaztcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2sgPSBnZXRDdXJyZW50U3RhY2tJbkRFVjtcbiAgICAgICAgICBjdXJyZW50T3duZXJJbkRFViA9IG51bGwgPT09IG93bmVyID8gcmVzcG9uc2UuX2RlYnVnUm9vdE93bmVyIDogb3duZXI7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgICAgICAgIHN3aXRjaCAobWV0aG9kTmFtZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJkaXJcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZGlyeG1sXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcImdyb3VwRW5kXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInRhYmxlXCI6XG4gICAgICAgICAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gYmluZCQxLmFwcGx5KFxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlW21ldGhvZE5hbWVdLFxuICAgICAgICAgICAgICAgICAgICBbY29uc29sZV0uY29uY2F0KGFyZ3MpXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiYXNzZXJ0XCI6XG4gICAgICAgICAgICAgICAgICBvZmZzZXQgPSAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBuZXdBcmdzID0gYXJncy5zbGljZSgwKTtcbiAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG5ld0FyZ3Nbb2Zmc2V0XVxuICAgICAgICAgICAgICAgID8gbmV3QXJncy5zcGxpY2UoXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgMSxcbiAgICAgICAgICAgICAgICAgICAgXCJcXHUwMDFiWzBtXFx1MDAxYls3bSVjJXNcXHUwMDFiWzBtJWMgXCIgKyBuZXdBcmdzW29mZnNldF0sXG4gICAgICAgICAgICAgICAgICAgIFwiYmFja2dyb3VuZDogI2U2ZTZlNjtiYWNrZ3JvdW5kOiBsaWdodC1kYXJrKHJnYmEoMCwwLDAsMC4xKSwgcmdiYSgyNTUsMjU1LDI1NSwwLjI1KSk7Y29sb3I6ICMwMDAwMDA7Y29sb3I6IGxpZ2h0LWRhcmsoIzAwMDAwMCwgI2ZmZmZmZik7Ym9yZGVyLXJhZGl1czogMnB4XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiIFwiICsgZW52ICsgXCIgXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiXCJcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICA6IG5ld0FyZ3Muc3BsaWNlKFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgIFwiXFx1MDAxYlswbVxcdTAwMWJbN20lYyVzXFx1MDAxYlswbSVjIFwiLFxuICAgICAgICAgICAgICAgICAgICBcImJhY2tncm91bmQ6ICNlNmU2ZTY7YmFja2dyb3VuZDogbGlnaHQtZGFyayhyZ2JhKDAsMCwwLDAuMSksIHJnYmEoMjU1LDI1NSwyNTUsMC4yNSkpO2NvbG9yOiAjMDAwMDAwO2NvbG9yOiBsaWdodC1kYXJrKCMwMDAwMDAsICNmZmZmZmYpO2JvcmRlci1yYWRpdXM6IDJweFwiLFxuICAgICAgICAgICAgICAgICAgICBcIiBcIiArIGVudiArIFwiIFwiLFxuICAgICAgICAgICAgICAgICAgICBcIlwiXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBuZXdBcmdzLnVuc2hpZnQoY29uc29sZSk7XG4gICAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IGJpbmQkMS5hcHBseShcbiAgICAgICAgICAgICAgICBjb25zb2xlW21ldGhvZE5hbWVdLFxuICAgICAgICAgICAgICAgIG5ld0FyZ3NcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjYWxsU3RhY2sgPSBidWlsZEZha2VDYWxsU3RhY2soXG4gICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICBzdGFja1RyYWNlLFxuICAgICAgICAgICAgICBlbnYsXG4gICAgICAgICAgICAgICExLFxuICAgICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAobnVsbCAhPSBvd25lcikge1xuICAgICAgICAgICAgICB2YXIgdGFzayA9IGluaXRpYWxpemVGYWtlVGFzayhyZXNwb25zZSwgb3duZXIpO1xuICAgICAgICAgICAgICBpbml0aWFsaXplRmFrZVN0YWNrKHJlc3BvbnNlLCBvd25lcik7XG4gICAgICAgICAgICAgIGlmIChudWxsICE9PSB0YXNrKSB7XG4gICAgICAgICAgICAgICAgdGFzay5ydW4oY2FsbFN0YWNrKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByb290VGFzayA9IGdldFJvb3RUYXNrKHJlc3BvbnNlLCBlbnYpO1xuICAgICAgICAgICAgbnVsbCAhPSByb290VGFzayA/IHJvb3RUYXNrLnJ1bihjYWxsU3RhY2spIDogY2FsbFN0YWNrKCk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIChjdXJyZW50T3duZXJJbkRFViA9IG51bGwpLFxuICAgICAgICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuZ2V0Q3VycmVudFN0YWNrID0gcHJldlN0YWNrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZXBsYXlDb25zb2xlV2l0aENhbGxTdGFja0luREVWID1cbiAgICAgICAgcmVwbGF5Q29uc29sZVdpdGhDYWxsU3RhY2sucmVhY3Rfc3RhY2tfYm90dG9tX2ZyYW1lLmJpbmQoXG4gICAgICAgICAgcmVwbGF5Q29uc29sZVdpdGhDYWxsU3RhY2tcbiAgICAgICAgKTtcbiAgICBleHBvcnRzLmNyZWF0ZUZyb21GZXRjaCA9IGZ1bmN0aW9uIChwcm9taXNlRm9yUmVzcG9uc2UsIG9wdGlvbnMpIHtcbiAgICAgIHZhciByZXNwb25zZSA9IGNyZWF0ZVJlc3BvbnNlRnJvbU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICBwcm9taXNlRm9yUmVzcG9uc2UudGhlbihcbiAgICAgICAgZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICBzdGFydFJlYWRpbmdGcm9tU3RyZWFtKHJlc3BvbnNlLCByLmJvZHkpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHJlcG9ydEdsb2JhbEVycm9yKHJlc3BvbnNlLCBlKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIHJldHVybiBnZXRSb290KHJlc3BvbnNlKTtcbiAgICB9O1xuICAgIGV4cG9ydHMuY3JlYXRlRnJvbU5vZGVTdHJlYW0gPSBmdW5jdGlvbiAoXG4gICAgICBzdHJlYW0sXG4gICAgICBzZXJ2ZXJDb25zdW1lck1hbmlmZXN0LFxuICAgICAgb3B0aW9uc1xuICAgICkge1xuICAgICAgdmFyIHJlc3BvbnNlJGpzY29tcCQwID0gbmV3IFJlc3BvbnNlSW5zdGFuY2UoXG4gICAgICAgICAgc2VydmVyQ29uc3VtZXJNYW5pZmVzdC5tb2R1bGVNYXAsXG4gICAgICAgICAgc2VydmVyQ29uc3VtZXJNYW5pZmVzdC5zZXJ2ZXJNb2R1bGVNYXAsXG4gICAgICAgICAgc2VydmVyQ29uc3VtZXJNYW5pZmVzdC5tb2R1bGVMb2FkaW5nLFxuICAgICAgICAgIG5vU2VydmVyQ2FsbCxcbiAgICAgICAgICBvcHRpb25zID8gb3B0aW9ucy5lbmNvZGVGb3JtQWN0aW9uIDogdm9pZCAwLFxuICAgICAgICAgIG9wdGlvbnMgJiYgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMubm9uY2UgPyBvcHRpb25zLm5vbmNlIDogdm9pZCAwLFxuICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICBvcHRpb25zICYmIG9wdGlvbnMuZmluZFNvdXJjZU1hcFVSTFxuICAgICAgICAgICAgPyBvcHRpb25zLmZpbmRTb3VyY2VNYXBVUkxcbiAgICAgICAgICAgIDogdm9pZCAwLFxuICAgICAgICAgIG9wdGlvbnMgPyAhMCA9PT0gb3B0aW9ucy5yZXBsYXlDb25zb2xlTG9ncyA6ICExLFxuICAgICAgICAgIG9wdGlvbnMgJiYgb3B0aW9ucy5lbnZpcm9ubWVudE5hbWUgPyBvcHRpb25zLmVudmlyb25tZW50TmFtZSA6IHZvaWQgMCxcbiAgICAgICAgICB2b2lkIDBcbiAgICAgICAgKS5fd2Vha1Jlc3BvbnNlLFxuICAgICAgICBzdHJlYW1TdGF0ZSA9IGNyZWF0ZVN0cmVhbVN0YXRlKCk7XG4gICAgICBzdHJlYW0ub24oXCJkYXRhXCIsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGNodW5rKSB7XG4gICAgICAgICAgaWYgKHZvaWQgMCAhPT0gcmVzcG9uc2UkanNjb21wJDAud2Vhay5kZXJlZigpKSB7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICB2YXIgcmVzcG9uc2UgPSB1bndyYXBXZWFrUmVzcG9uc2UocmVzcG9uc2UkanNjb21wJDApLFxuICAgICAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgICAgIHJvd1N0YXRlID0gc3RyZWFtU3RhdGUuX3Jvd1N0YXRlLFxuICAgICAgICAgICAgICAgIHJvd0lEID0gc3RyZWFtU3RhdGUuX3Jvd0lELFxuICAgICAgICAgICAgICAgIHJvd1RhZyA9IHN0cmVhbVN0YXRlLl9yb3dUYWcsXG4gICAgICAgICAgICAgICAgcm93TGVuZ3RoID0gc3RyZWFtU3RhdGUuX3Jvd0xlbmd0aCxcbiAgICAgICAgICAgICAgICBidWZmZXIgPSBzdHJlYW1TdGF0ZS5fYnVmZmVyLFxuICAgICAgICAgICAgICAgIGNodW5rTGVuZ3RoID0gY2h1bmsubGVuZ3RoO1xuICAgICAgICAgICAgICBpIDwgY2h1bmtMZW5ndGg7XG5cbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICB2YXIgbGFzdElkeCA9IC0xO1xuICAgICAgICAgICAgICBzd2l0Y2ggKHJvd1N0YXRlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgbGFzdElkeCA9IGNodW5rLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgICAgICAgICAgICAgIDU4ID09PSBsYXN0SWR4XG4gICAgICAgICAgICAgICAgICAgID8gKHJvd1N0YXRlID0gMSlcbiAgICAgICAgICAgICAgICAgICAgOiAocm93SUQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgKHJvd0lEIDw8IDQpIHxcbiAgICAgICAgICAgICAgICAgICAgICAgICg5NiA8IGxhc3RJZHggPyBsYXN0SWR4IC0gODcgOiBsYXN0SWR4IC0gNDgpKTtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgIHJvd1N0YXRlID0gY2h1bmsuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgICAgICAgIDg0ID09PSByb3dTdGF0ZSB8fFxuICAgICAgICAgICAgICAgICAgNjUgPT09IHJvd1N0YXRlIHx8XG4gICAgICAgICAgICAgICAgICA3OSA9PT0gcm93U3RhdGUgfHxcbiAgICAgICAgICAgICAgICAgIDExMSA9PT0gcm93U3RhdGUgfHxcbiAgICAgICAgICAgICAgICAgIDg1ID09PSByb3dTdGF0ZSB8fFxuICAgICAgICAgICAgICAgICAgODMgPT09IHJvd1N0YXRlIHx8XG4gICAgICAgICAgICAgICAgICAxMTUgPT09IHJvd1N0YXRlIHx8XG4gICAgICAgICAgICAgICAgICA3NiA9PT0gcm93U3RhdGUgfHxcbiAgICAgICAgICAgICAgICAgIDEwOCA9PT0gcm93U3RhdGUgfHxcbiAgICAgICAgICAgICAgICAgIDcxID09PSByb3dTdGF0ZSB8fFxuICAgICAgICAgICAgICAgICAgMTAzID09PSByb3dTdGF0ZSB8fFxuICAgICAgICAgICAgICAgICAgNzcgPT09IHJvd1N0YXRlIHx8XG4gICAgICAgICAgICAgICAgICAxMDkgPT09IHJvd1N0YXRlIHx8XG4gICAgICAgICAgICAgICAgICA4NiA9PT0gcm93U3RhdGVcbiAgICAgICAgICAgICAgICAgICAgPyAoKHJvd1RhZyA9IHJvd1N0YXRlKSwgKHJvd1N0YXRlID0gMiksIGkrKylcbiAgICAgICAgICAgICAgICAgICAgOiAoNjQgPCByb3dTdGF0ZSAmJiA5MSA+IHJvd1N0YXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgMTE0ID09PSByb3dTdGF0ZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgMTIwID09PSByb3dTdGF0ZVxuICAgICAgICAgICAgICAgICAgICAgID8gKChyb3dUYWcgPSByb3dTdGF0ZSksIChyb3dTdGF0ZSA9IDMpLCBpKyspXG4gICAgICAgICAgICAgICAgICAgICAgOiAoKHJvd1RhZyA9IDApLCAocm93U3RhdGUgPSAzKSk7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICBsYXN0SWR4ID0gY2h1bmsuY2hhckNvZGVBdChpKyspO1xuICAgICAgICAgICAgICAgICAgNDQgPT09IGxhc3RJZHhcbiAgICAgICAgICAgICAgICAgICAgPyAocm93U3RhdGUgPSA0KVxuICAgICAgICAgICAgICAgICAgICA6IChyb3dMZW5ndGggPVxuICAgICAgICAgICAgICAgICAgICAgICAgKHJvd0xlbmd0aCA8PCA0KSB8XG4gICAgICAgICAgICAgICAgICAgICAgICAoOTYgPCBsYXN0SWR4ID8gbGFzdElkeCAtIDg3IDogbGFzdElkeCAtIDQ4KSk7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICBsYXN0SWR4ID0gY2h1bmsuaW5kZXhPZihcIlxcblwiLCBpKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgIGlmICg4NCAhPT0gcm93VGFnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICBcIkJpbmFyeSBSU0MgY2h1bmtzIGNhbm5vdCBiZSBlbmNvZGVkIGFzIHN0cmluZ3MuIFRoaXMgaXMgYSBidWcgaW4gdGhlIHdpcmluZyBvZiB0aGUgUmVhY3Qgc3RyZWFtcy5cIlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgaWYgKHJvd0xlbmd0aCA8IGNodW5rLmxlbmd0aCB8fCBjaHVuay5sZW5ndGggPiAzICogcm93TGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICBcIlN0cmluZyBjaHVua3MgbmVlZCB0byBiZSBwYXNzZWQgaW4gdGhlaXIgb3JpZ2luYWwgc2hhcGUuIE5vdCBzcGxpdCBpbnRvIHNtYWxsZXIgc3RyaW5nIGNodW5rcy4gVGhpcyBpcyBhIGJ1ZyBpbiB0aGUgd2lyaW5nIG9mIHRoZSBSZWFjdCBzdHJlYW1zLlwiXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBsYXN0SWR4ID0gY2h1bmsubGVuZ3RoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICgtMSA8IGxhc3RJZHgpIHtcbiAgICAgICAgICAgICAgICBpZiAoMCA8IGJ1ZmZlci5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJTdHJpbmcgY2h1bmtzIG5lZWQgdG8gYmUgcGFzc2VkIGluIHRoZWlyIG9yaWdpbmFsIHNoYXBlLiBOb3Qgc3BsaXQgaW50byBzbWFsbGVyIHN0cmluZyBjaHVua3MuIFRoaXMgaXMgYSBidWcgaW4gdGhlIHdpcmluZyBvZiB0aGUgUmVhY3Qgc3RyZWFtcy5cIlxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpID0gY2h1bmsuc2xpY2UoaSwgbGFzdElkeCk7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc0Z1bGxTdHJpbmdSb3cocmVzcG9uc2UsIHJvd0lELCByb3dUYWcsIGkpO1xuICAgICAgICAgICAgICAgIGkgPSBsYXN0SWR4O1xuICAgICAgICAgICAgICAgIDMgPT09IHJvd1N0YXRlICYmIGkrKztcbiAgICAgICAgICAgICAgICByb3dMZW5ndGggPSByb3dJRCA9IHJvd1RhZyA9IHJvd1N0YXRlID0gMDtcbiAgICAgICAgICAgICAgICBidWZmZXIubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaHVuay5sZW5ndGggIT09IGkpXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIlN0cmluZyBjaHVua3MgbmVlZCB0byBiZSBwYXNzZWQgaW4gdGhlaXIgb3JpZ2luYWwgc2hhcGUuIE5vdCBzcGxpdCBpbnRvIHNtYWxsZXIgc3RyaW5nIGNodW5rcy4gVGhpcyBpcyBhIGJ1ZyBpbiB0aGUgd2lyaW5nIG9mIHRoZSBSZWFjdCBzdHJlYW1zLlwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0cmVhbVN0YXRlLl9yb3dTdGF0ZSA9IHJvd1N0YXRlO1xuICAgICAgICAgICAgc3RyZWFtU3RhdGUuX3Jvd0lEID0gcm93SUQ7XG4gICAgICAgICAgICBzdHJlYW1TdGF0ZS5fcm93VGFnID0gcm93VGFnO1xuICAgICAgICAgICAgc3RyZWFtU3RhdGUuX3Jvd0xlbmd0aCA9IHJvd0xlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBwcm9jZXNzQmluYXJ5Q2h1bmsocmVzcG9uc2UkanNjb21wJDAsIHN0cmVhbVN0YXRlLCBjaHVuayk7XG4gICAgICB9KTtcbiAgICAgIHN0cmVhbS5vbihcImVycm9yXCIsIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICByZXBvcnRHbG9iYWxFcnJvcihyZXNwb25zZSRqc2NvbXAkMCwgZXJyb3IpO1xuICAgICAgfSk7XG4gICAgICBzdHJlYW0ub24oXCJlbmRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY2xvc2UocmVzcG9uc2UkanNjb21wJDApO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZ2V0Um9vdChyZXNwb25zZSRqc2NvbXAkMCk7XG4gICAgfTtcbiAgICBleHBvcnRzLmNyZWF0ZUZyb21SZWFkYWJsZVN0cmVhbSA9IGZ1bmN0aW9uIChzdHJlYW0sIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBjcmVhdGVSZXNwb25zZUZyb21PcHRpb25zKG9wdGlvbnMpO1xuICAgICAgc3RhcnRSZWFkaW5nRnJvbVN0cmVhbShvcHRpb25zLCBzdHJlYW0pO1xuICAgICAgcmV0dXJuIGdldFJvb3Qob3B0aW9ucyk7XG4gICAgfTtcbiAgICBleHBvcnRzLmNyZWF0ZVNlcnZlclJlZmVyZW5jZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVNlcnZlclJlZmVyZW5jZSQxKGlkLCBub1NlcnZlckNhbGwkMSk7XG4gICAgfTtcbiAgICBleHBvcnRzLmNyZWF0ZVRlbXBvcmFyeVJlZmVyZW5jZVNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgTWFwKCk7XG4gICAgfTtcbiAgICBleHBvcnRzLmVuY29kZVJlcGx5ID0gZnVuY3Rpb24gKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgYWJvcnQgPSBwcm9jZXNzUmVwbHkoXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgXCJcIixcbiAgICAgICAgICBvcHRpb25zICYmIG9wdGlvbnMudGVtcG9yYXJ5UmVmZXJlbmNlc1xuICAgICAgICAgICAgPyBvcHRpb25zLnRlbXBvcmFyeVJlZmVyZW5jZXNcbiAgICAgICAgICAgIDogdm9pZCAwLFxuICAgICAgICAgIHJlc29sdmUsXG4gICAgICAgICAgcmVqZWN0XG4gICAgICAgICk7XG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuc2lnbmFsKSB7XG4gICAgICAgICAgdmFyIHNpZ25hbCA9IG9wdGlvbnMuc2lnbmFsO1xuICAgICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkgYWJvcnQoc2lnbmFsLnJlYXNvbik7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGFib3J0KHNpZ25hbC5yZWFzb24pO1xuICAgICAgICAgICAgICBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGxpc3RlbmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgZXhwb3J0cy5yZWdpc3RlclNlcnZlclJlZmVyZW5jZSA9IGZ1bmN0aW9uIChcbiAgICAgIHJlZmVyZW5jZSxcbiAgICAgIGlkLFxuICAgICAgZW5jb2RlRm9ybUFjdGlvblxuICAgICkge1xuICAgICAgcmVnaXN0ZXJCb3VuZFNlcnZlclJlZmVyZW5jZShyZWZlcmVuY2UsIGlkLCBudWxsLCBlbmNvZGVGb3JtQWN0aW9uKTtcbiAgICAgIHJldHVybiByZWZlcmVuY2U7XG4gICAgfTtcbiAgfSkoKTtcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Q0FRQyxHQUdELG9FQUNFLEFBQUM7SUFDQyxTQUFTLHVCQUF1QixhQUFhLEVBQUUsUUFBUTtRQUNyRCxJQUFJLGVBQWU7WUFDakIsSUFBSSxnQkFBZ0IsYUFBYSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUM7WUFDOUMsSUFBSyxnQkFBZ0IsaUJBQWlCLGFBQWEsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLEVBQzlELGdCQUFnQixjQUFjLElBQUk7aUJBQy9CO2dCQUNILGdCQUFnQixpQkFBaUIsYUFBYSxDQUFDLElBQUk7Z0JBQ25ELElBQUksQ0FBQyxlQUNILE1BQU0sTUFDSixnQ0FDRSxRQUFRLENBQUMsRUFBRSxHQUNYO2dCQUVOLGdCQUFnQixRQUFRLENBQUMsRUFBRTtZQUM3QjtZQUNBLE9BQU8sTUFBTSxTQUFTLE1BQU0sR0FDeEI7Z0JBQUMsY0FBYyxFQUFFO2dCQUFFLGNBQWMsTUFBTTtnQkFBRTtnQkFBZTthQUFFLEdBQzFEO2dCQUFDLGNBQWMsRUFBRTtnQkFBRSxjQUFjLE1BQU07Z0JBQUU7YUFBYztRQUM3RDtRQUNBLE9BQU87SUFDVDtJQUNBLFNBQVMsdUJBQXVCLGFBQWEsRUFBRSxFQUFFO1FBQy9DLElBQUksT0FBTyxJQUNULHFCQUFxQixhQUFhLENBQUMsR0FBRztRQUN4QyxJQUFJLG9CQUFvQixPQUFPLG1CQUFtQixJQUFJO2FBQ2pEO1lBQ0gsSUFBSSxNQUFNLEdBQUcsV0FBVyxDQUFDO1lBQ3pCLENBQUMsTUFBTSxPQUNMLENBQUMsQUFBQyxPQUFPLEdBQUcsS0FBSyxDQUFDLE1BQU0sSUFDdkIscUJBQXFCLGFBQWEsQ0FBQyxHQUFHLEtBQUssQ0FBQyxHQUFHLEtBQUssQUFBQztZQUN4RCxJQUFJLENBQUMsb0JBQ0gsTUFBTSxNQUNKLGdDQUNFLEtBQ0E7UUFFUjtRQUNBLE9BQU87WUFBQyxtQkFBbUIsRUFBRTtZQUFFLG1CQUFtQixNQUFNO1lBQUU7U0FBSztJQUNqRTtJQUNBLFNBQVMsbUJBQW1CLEVBQUU7UUFDNUIsSUFBSSxVQUFVLFdBQVcsZ0JBQWdCLENBQUM7UUFDMUMsSUFBSSxlQUFlLE9BQU8sUUFBUSxJQUFJLElBQUksZ0JBQWdCLFFBQVEsTUFBTSxFQUN0RSxPQUFPO1FBQ1QsUUFBUSxJQUFJLENBQ1YsU0FBVSxLQUFLO1lBQ2IsUUFBUSxNQUFNLEdBQUc7WUFDakIsUUFBUSxLQUFLLEdBQUc7UUFDbEIsR0FDQSxTQUFVLE1BQU07WUFDZCxRQUFRLE1BQU0sR0FBRztZQUNqQixRQUFRLE1BQU0sR0FBRztRQUNuQjtRQUVGLE9BQU87SUFDVDtJQUNBLFNBQVMsZ0JBQWdCO0lBQ3pCLFNBQVMsY0FBYyxRQUFRO1FBQzdCLElBQ0UsSUFBSSxTQUFTLFFBQVEsQ0FBQyxFQUFFLEVBQUUsV0FBVyxFQUFFLEVBQUUsSUFBSSxHQUM3QyxJQUFJLE9BQU8sTUFBTSxFQUNqQixJQUNBO1lBQ0EsSUFBSSxnQkFBZ0IsTUFBTSxDQUFDLEVBQUUsRUFDM0IsUUFBUSxXQUFXLEdBQUcsQ0FBQztZQUN6QixJQUFJLEtBQUssTUFBTSxPQUFPO2dCQUNwQixRQUFRLFdBQVcsbUJBQW1CLENBQUM7Z0JBQ3ZDLFNBQVMsSUFBSSxDQUFDO2dCQUNkLElBQUksVUFBVSxXQUFXLEdBQUcsQ0FBQyxJQUFJLENBQUMsWUFBWSxlQUFlO2dCQUM3RCxNQUFNLElBQUksQ0FBQyxTQUFTO2dCQUNwQixXQUFXLEdBQUcsQ0FBQyxlQUFlO1lBQ2hDLE9BQU8sU0FBUyxTQUFTLFNBQVMsSUFBSSxDQUFDO1FBQ3pDO1FBQ0EsT0FBTyxNQUFNLFNBQVMsTUFBTSxHQUN4QixNQUFNLFNBQVMsTUFBTSxHQUNuQixtQkFBbUIsUUFBUSxDQUFDLEVBQUUsSUFDOUIsUUFBUSxHQUFHLENBQUMsVUFBVSxJQUFJLENBQUM7WUFDekIsT0FBTyxtQkFBbUIsUUFBUSxDQUFDLEVBQUU7UUFDdkMsS0FDRixJQUFJLFNBQVMsTUFBTSxHQUNqQixRQUFRLEdBQUcsQ0FBQyxZQUNaO0lBQ1I7SUFDQSxTQUFTLGNBQWMsUUFBUTtRQUM3QixJQUFJLGdCQUFnQixXQUFXLGdCQUFnQixDQUFDLFFBQVEsQ0FBQyxFQUFFO1FBQzNELElBQUksTUFBTSxTQUFTLE1BQU0sSUFBSSxlQUFlLE9BQU8sY0FBYyxJQUFJLEVBQ25FLElBQUksZ0JBQWdCLGNBQWMsTUFBTSxFQUN0QyxnQkFBZ0IsY0FBYyxLQUFLO2FBQ2hDLE1BQU0sY0FBYyxNQUFNO1FBQ2pDLE9BQU8sUUFBUSxRQUFRLENBQUMsRUFBRSxHQUN0QixnQkFDQSxPQUFPLFFBQVEsQ0FBQyxFQUFFLEdBQ2hCLGNBQWMsVUFBVSxHQUN0QixjQUFjLE9BQU8sR0FDckIsZ0JBQ0YsYUFBYSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUM7SUFDbEM7SUFDQSxTQUFTLDZCQUNQLGFBQWEsRUFDYixNQUFNLEVBQ04sY0FBYztRQUVkLElBQUksU0FBUyxlQUNYLElBQUssSUFBSSxJQUFJLEdBQUcsSUFBSSxPQUFPLE1BQU0sRUFBRSxJQUFLO1lBQ3RDLElBQUksUUFBUSxnQkFDVix3QkFBd0Isd0JBQXdCLENBQUMsRUFDakQsaUNBQWlDLHNCQUFzQixDQUFDLEVBQ3hELGlDQUFpQyxjQUFjLE1BQU0sR0FBRyxNQUFNLENBQUMsRUFBRTtZQUNuRSxJQUFJLDJCQUEyQixjQUFjLFdBQVc7WUFDeEQsMkJBQ0UsYUFBYSxPQUFPLDJCQUNoQixzQkFBc0IsMkJBQ3BCLDJCQUNBLEtBQ0YsS0FBSztZQUNYLCtCQUErQixJQUFJLENBQ2pDLHVCQUNBLGdDQUNBO2dCQUFFLGFBQWE7Z0JBQTBCLE9BQU87WUFBTTtRQUUxRDtJQUNKO0lBQ0EsU0FBUyxjQUFjLGFBQWE7UUFDbEMsSUFBSSxTQUFTLGlCQUFpQixhQUFhLE9BQU8sZUFDaEQsT0FBTztRQUNULGdCQUNFLEFBQUMseUJBQXlCLGFBQWEsQ0FBQyxzQkFBc0IsSUFDOUQsYUFBYSxDQUFDLGFBQWE7UUFDN0IsT0FBTyxlQUFlLE9BQU8sZ0JBQWdCLGdCQUFnQjtJQUMvRDtJQUNBLFNBQVMsa0JBQWtCLE1BQU07UUFDL0IsSUFBSSxDQUFDLFFBQVEsT0FBTyxDQUFDO1FBQ3JCLElBQUksa0JBQWtCLE9BQU8sU0FBUztRQUN0QyxJQUFJLFdBQVcsaUJBQWlCLE9BQU8sQ0FBQztRQUN4QyxJQUFJLGVBQWUsU0FBUyxPQUFPLENBQUM7UUFDcEMsU0FBUyxPQUFPLG1CQUFtQixDQUFDO1FBQ3BDLElBQUssSUFBSSxJQUFJLEdBQUcsSUFBSSxPQUFPLE1BQU0sRUFBRSxJQUNqQyxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxJQUFJLGVBQWUsR0FBRyxPQUFPLENBQUM7UUFDL0MsT0FBTyxDQUFDO0lBQ1Y7SUFDQSxTQUFTLGVBQWUsTUFBTTtRQUM1QixJQUFJLENBQUMsa0JBQWtCLGVBQWUsVUFBVSxPQUFPLENBQUM7UUFDeEQsSUFDRSxJQUFJLFFBQVEsT0FBTyxtQkFBbUIsQ0FBQyxTQUFTLElBQUksR0FDcEQsSUFBSSxNQUFNLE1BQU0sRUFDaEIsSUFDQTtZQUNBLElBQUksYUFBYSxPQUFPLHdCQUF3QixDQUFDLFFBQVEsS0FBSyxDQUFDLEVBQUU7WUFDakUsSUFDRSxDQUFDLGNBQ0EsQ0FBQyxXQUFXLFVBQVUsSUFDckIsQ0FBQyxBQUFDLFVBQVUsS0FBSyxDQUFDLEVBQUUsSUFBSSxVQUFVLEtBQUssQ0FBQyxFQUFFLElBQ3hDLGVBQWUsT0FBTyxXQUFXLEdBQUcsR0FFeEMsT0FBTyxDQUFDO1FBQ1o7UUFDQSxPQUFPLENBQUM7SUFDVjtJQUNBLFNBQVMsV0FBVyxNQUFNO1FBQ3hCLFNBQVMsT0FBTyxTQUFTLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQztRQUN4QyxPQUFPLE9BQU8sS0FBSyxDQUFDLEdBQUcsT0FBTyxNQUFNLEdBQUc7SUFDekM7SUFDQSxTQUFTLDJCQUEyQixHQUFHO1FBQ3JDLElBQUksYUFBYSxLQUFLLFNBQVMsQ0FBQztRQUNoQyxPQUFPLE1BQU0sTUFBTSxRQUFRLGFBQWEsTUFBTTtJQUNoRDtJQUNBLFNBQVMsNkJBQTZCLEtBQUs7UUFDekMsT0FBUSxPQUFPO1lBQ2IsS0FBSztnQkFDSCxPQUFPLEtBQUssU0FBUyxDQUNuQixNQUFNLE1BQU0sTUFBTSxHQUFHLFFBQVEsTUFBTSxLQUFLLENBQUMsR0FBRyxNQUFNO1lBRXRELEtBQUs7Z0JBQ0gsSUFBSSxZQUFZLFFBQVEsT0FBTztnQkFDL0IsSUFBSSxTQUFTLFNBQVMsTUFBTSxRQUFRLEtBQUssc0JBQ3ZDLE9BQU87Z0JBQ1QsUUFBUSxXQUFXO2dCQUNuQixPQUFPLGFBQWEsUUFBUSxVQUFVO1lBQ3hDLEtBQUs7Z0JBQ0gsT0FBTyxNQUFNLFFBQVEsS0FBSyx1QkFDdEIsV0FDQSxDQUFDLFFBQVEsTUFBTSxXQUFXLElBQUksTUFBTSxJQUFJLElBQ3RDLGNBQWMsUUFDZDtZQUNSO2dCQUNFLE9BQU8sT0FBTztRQUNsQjtJQUNGO0lBQ0EsU0FBUyxvQkFBb0IsSUFBSTtRQUMvQixJQUFJLGFBQWEsT0FBTyxNQUFNLE9BQU87UUFDckMsT0FBUTtZQUNOLEtBQUs7Z0JBQ0gsT0FBTztZQUNULEtBQUs7Z0JBQ0gsT0FBTztRQUNYO1FBQ0EsSUFBSSxhQUFhLE9BQU8sTUFDdEIsT0FBUSxLQUFLLFFBQVE7WUFDbkIsS0FBSztnQkFDSCxPQUFPLG9CQUFvQixLQUFLLE1BQU07WUFDeEMsS0FBSztnQkFDSCxPQUFPLG9CQUFvQixLQUFLLElBQUk7WUFDdEMsS0FBSztnQkFDSCxJQUFJLFVBQVUsS0FBSyxRQUFRO2dCQUMzQixPQUFPLEtBQUssS0FBSztnQkFDakIsSUFBSTtvQkFDRixPQUFPLG9CQUFvQixLQUFLO2dCQUNsQyxFQUFFLE9BQU8sR0FBRyxDQUFDO1FBQ2pCO1FBQ0YsT0FBTztJQUNUO0lBQ0EsU0FBUyw4QkFBOEIsYUFBYSxFQUFFLFlBQVk7UUFDaEUsSUFBSSxVQUFVLFdBQVc7UUFDekIsSUFBSSxhQUFhLFdBQVcsWUFBWSxTQUFTLE9BQU87UUFDeEQsSUFBSSxRQUFRLENBQUMsR0FDWCxTQUFTO1FBQ1gsSUFBSSxZQUFZLGdCQUNkLElBQUksbUJBQW1CLEdBQUcsQ0FBQyxnQkFBZ0I7WUFDekMsSUFBSSxPQUFPLG1CQUFtQixHQUFHLENBQUM7WUFDbEMsVUFBVSxNQUFNLG9CQUFvQixRQUFRO1lBQzVDLElBQUssSUFBSSxJQUFJLEdBQUcsSUFBSSxjQUFjLE1BQU0sRUFBRSxJQUFLO2dCQUM3QyxJQUFJLFFBQVEsYUFBYSxDQUFDLEVBQUU7Z0JBQzVCLFFBQ0UsYUFBYSxPQUFPLFFBQ2hCLFFBQ0EsYUFBYSxPQUFPLFNBQVMsU0FBUyxRQUNwQyxNQUFNLDhCQUE4QixTQUFTLE1BQzdDLE1BQU0sNkJBQTZCLFNBQVM7Z0JBQ3BELEtBQUssTUFBTSxlQUNQLENBQUMsQUFBQyxRQUFRLFFBQVEsTUFBTSxFQUN2QixTQUFTLE1BQU0sTUFBTSxFQUNyQixXQUFXLEtBQU0sSUFDakIsVUFDQyxLQUFLLE1BQU0sTUFBTSxJQUFJLEtBQUssUUFBUSxNQUFNLEdBQUcsTUFBTSxNQUFNLEdBQ25ELFVBQVUsUUFDVixVQUFVO1lBQ3RCO1lBQ0EsV0FBVyxPQUFPLG9CQUFvQixRQUFRO1FBQ2hELE9BQU87WUFDTCxVQUFVO1lBQ1YsSUFBSyxPQUFPLEdBQUcsT0FBTyxjQUFjLE1BQU0sRUFBRSxPQUMxQyxJQUFJLFFBQVEsQ0FBQyxXQUFXLElBQUksR0FDekIsSUFBSSxhQUFhLENBQUMsS0FBSyxFQUN2QixJQUNDLGFBQWEsT0FBTyxLQUFLLFNBQVMsSUFDOUIsOEJBQThCLEtBQzlCLDZCQUE2QixJQUNuQyxLQUFLLFNBQVMsZUFDVixDQUFDLEFBQUMsUUFBUSxRQUFRLE1BQU0sRUFDdkIsU0FBUyxFQUFFLE1BQU0sRUFDakIsV0FBVyxDQUFFLElBQ2IsVUFDQyxLQUFLLEVBQUUsTUFBTSxJQUFJLEtBQUssUUFBUSxNQUFNLEdBQUcsRUFBRSxNQUFNLEdBQzNDLFVBQVUsSUFDVixVQUFVO1lBQ3hCLFdBQVc7UUFDYjthQUNHLElBQUksY0FBYyxRQUFRLEtBQUssb0JBQ2xDLFVBQVUsTUFBTSxvQkFBb0IsY0FBYyxJQUFJLElBQUk7YUFDdkQ7WUFDSCxJQUFJLGNBQWMsUUFBUSxLQUFLLHNCQUFzQixPQUFPO1lBQzVELElBQUksZ0JBQWdCLEdBQUcsQ0FBQyxnQkFBZ0I7Z0JBQ3RDLFVBQVUsZ0JBQWdCLEdBQUcsQ0FBQztnQkFDOUIsVUFBVSxNQUFNLENBQUMsb0JBQW9CLFlBQVksS0FBSztnQkFDdEQsT0FBTyxPQUFPLElBQUksQ0FBQztnQkFDbkIsSUFBSyxJQUFJLEdBQUcsSUFBSSxLQUFLLE1BQU0sRUFBRSxJQUFLO29CQUNoQyxXQUFXO29CQUNYLFFBQVEsSUFBSSxDQUFDLEVBQUU7b0JBQ2YsV0FBVywyQkFBMkIsU0FBUztvQkFDL0MsSUFBSSxVQUFVLGFBQWEsQ0FBQyxNQUFNO29CQUNsQyxJQUFJLFdBQ0YsVUFBVSxnQkFDVixhQUFhLE9BQU8sV0FDcEIsU0FBUyxVQUNMLDhCQUE4QixXQUM5Qiw2QkFBNkI7b0JBQ25DLGFBQWEsT0FBTyxXQUFXLENBQUMsV0FBVyxNQUFNLFdBQVcsR0FBRztvQkFDL0QsVUFBVSxlQUNOLENBQUMsQUFBQyxRQUFRLFFBQVEsTUFBTSxFQUN2QixTQUFTLFNBQVMsTUFBTSxFQUN4QixXQUFXLFFBQVMsSUFDcEIsVUFDQyxLQUFLLFNBQVMsTUFBTSxJQUFJLEtBQUssUUFBUSxNQUFNLEdBQUcsU0FBUyxNQUFNLEdBQ3pELFVBQVUsV0FDVixVQUFVO2dCQUN0QjtnQkFDQSxXQUFXO1lBQ2IsT0FBTztnQkFDTCxVQUFVO2dCQUNWLE9BQU8sT0FBTyxJQUFJLENBQUM7Z0JBQ25CLElBQUssSUFBSSxHQUFHLElBQUksS0FBSyxNQUFNLEVBQUUsSUFDM0IsSUFBSSxLQUFLLENBQUMsV0FBVyxJQUFJLEdBQ3RCLFFBQVEsSUFBSSxDQUFDLEVBQUUsRUFDZixXQUFXLDJCQUEyQixTQUFTLE1BQy9DLFVBQVUsYUFBYSxDQUFDLE1BQU0sRUFDOUIsVUFDQyxhQUFhLE9BQU8sV0FBVyxTQUFTLFVBQ3BDLDhCQUE4QixXQUM5Qiw2QkFBNkIsVUFDbkMsVUFBVSxlQUNOLENBQUMsQUFBQyxRQUFRLFFBQVEsTUFBTSxFQUN2QixTQUFTLFFBQVEsTUFBTSxFQUN2QixXQUFXLE9BQVEsSUFDbkIsVUFDQyxLQUFLLFFBQVEsTUFBTSxJQUFJLEtBQUssUUFBUSxNQUFNLEdBQUcsUUFBUSxNQUFNLEdBQ3ZELFVBQVUsVUFDVixVQUFVO2dCQUN4QixXQUFXO1lBQ2I7UUFDRjtRQUNBLE9BQU8sS0FBSyxNQUFNLGVBQ2QsVUFDQSxDQUFDLElBQUksU0FBUyxJQUFJLFNBQ2hCLENBQUMsQUFBQyxnQkFBZ0IsSUFBSSxNQUFNLENBQUMsU0FBUyxJQUFJLE1BQU0sQ0FBQyxTQUNqRCxTQUFTLFVBQVUsU0FBUyxhQUFhLElBQ3pDLFNBQVM7SUFDakI7SUFDQSxTQUFTLGdCQUFnQixNQUFNO1FBQzdCLE9BQU8sT0FBTyxRQUFRLENBQUMsVUFDbkIsTUFBTSxVQUFVLENBQUMsYUFBYSxJQUFJLFNBQ2hDLFFBQ0EsU0FDRixhQUFhLFNBQ1gsY0FDQSxDQUFDLGFBQWEsU0FDWixlQUNBO0lBQ1Y7SUFDQSxTQUFTLGFBQ1AsSUFBSSxFQUNKLGVBQWUsRUFDZixtQkFBbUIsRUFDbkIsT0FBTyxFQUNQLE1BQU07UUFFTixTQUFTLG9CQUFvQixHQUFHLEVBQUUsVUFBVTtZQUMxQyxhQUFhLElBQUksS0FBSztnQkFDcEIsSUFBSSxXQUNGLFdBQVcsTUFBTSxFQUNqQixXQUFXLFVBQVUsRUFDckIsV0FBVyxVQUFVO2FBRXhCO1lBQ0QsSUFBSSxTQUFTO1lBQ2IsU0FBUyxZQUFZLENBQUMsV0FBVyxJQUFJLFVBQVU7WUFDL0MsU0FBUyxNQUFNLENBQUMsa0JBQWtCLFFBQVE7WUFDMUMsT0FBTyxNQUFNLE1BQU0sT0FBTyxRQUFRLENBQUM7UUFDckM7UUFDQSxTQUFTLHNCQUFzQixNQUFNO1lBQ25DLFNBQVMsU0FBUyxLQUFLO2dCQUNyQixNQUFNLElBQUksR0FDTixDQUFDLEFBQUMsUUFBUSxjQUNWLEtBQUssTUFBTSxDQUFDLGtCQUFrQixPQUFPLElBQUksS0FBSyxVQUM5QyxLQUFLLE1BQU0sQ0FDVCxrQkFBa0IsVUFDbEIsUUFBUSxNQUFNLFFBQVEsQ0FBQyxNQUFNLE1BRS9CLEtBQUssTUFBTSxDQUFDLGtCQUFrQixVQUFVLE1BQ3hDLGdCQUNBLE1BQU0sZ0JBQWdCLFFBQVEsS0FBSyxJQUNuQyxDQUFDLE9BQU8sSUFBSSxDQUFDLE1BQU0sS0FBSyxHQUN4QixPQUFPLElBQUksQ0FBQyxJQUFJLFdBQVcsT0FBTyxJQUFJLENBQUMsVUFBVSxPQUFPO1lBQzlEO1lBQ0EsU0FBUyxZQUFZLENBQUMsV0FBVyxJQUFJLFVBQVU7WUFDL0MsSUFBSSxPQUFPO1lBQ1g7WUFDQSxJQUFJLFdBQVcsY0FDYixTQUFTLEVBQUU7WUFDYixPQUFPLElBQUksQ0FBQyxJQUFJLFdBQVcsT0FBTyxJQUFJLENBQUMsVUFBVTtZQUNqRCxPQUFPLE9BQU8sU0FBUyxRQUFRLENBQUM7UUFDbEM7UUFDQSxTQUFTLGdCQUFnQixNQUFNO1lBQzdCLFNBQVMsU0FBUyxLQUFLO2dCQUNyQixJQUFJLE1BQU0sSUFBSSxFQUNaLEtBQUssTUFBTSxDQUFDLGtCQUFrQixVQUFVLE1BQ3RDLGdCQUNBLE1BQU0sZ0JBQWdCLFFBQVE7cUJBRWhDLElBQUk7b0JBQ0YsSUFBSSxXQUFXLEtBQUssU0FBUyxDQUFDLE1BQU0sS0FBSyxFQUFFO29CQUMzQyxLQUFLLE1BQU0sQ0FBQyxrQkFBa0IsVUFBVTtvQkFDeEMsT0FBTyxJQUFJLEdBQUcsSUFBSSxDQUFDLFVBQVU7Z0JBQy9CLEVBQUUsT0FBTyxHQUFHO29CQUNWLE9BQU87Z0JBQ1Q7WUFDSjtZQUNBLFNBQVMsWUFBWSxDQUFDLFdBQVcsSUFBSSxVQUFVO1lBQy9DLElBQUksT0FBTztZQUNYO1lBQ0EsSUFBSSxXQUFXO1lBQ2YsT0FBTyxJQUFJLEdBQUcsSUFBSSxDQUFDLFVBQVU7WUFDN0IsT0FBTyxPQUFPLFNBQVMsUUFBUSxDQUFDO1FBQ2xDO1FBQ0EsU0FBUyx3QkFBd0IsTUFBTTtZQUNyQyxJQUFJO2dCQUNGLElBQUksZUFBZSxPQUFPLFNBQVMsQ0FBQztvQkFBRSxNQUFNO2dCQUFPO1lBQ3JELEVBQUUsT0FBTyxHQUFHO2dCQUNWLE9BQU8sZ0JBQWdCLE9BQU8sU0FBUztZQUN6QztZQUNBLE9BQU8sc0JBQXNCO1FBQy9CO1FBQ0EsU0FBUyx1QkFBdUIsUUFBUSxFQUFFLFFBQVE7WUFDaEQsU0FBUyxTQUFTLEtBQUs7Z0JBQ3JCLElBQUksTUFBTSxJQUFJLEVBQUU7b0JBQ2QsSUFBSSxLQUFLLE1BQU0sTUFBTSxLQUFLLEVBQ3hCLEtBQUssTUFBTSxDQUFDLGtCQUFrQixVQUFVO3lCQUV4QyxJQUFJO3dCQUNGLElBQUksV0FBVyxLQUFLLFNBQVMsQ0FBQyxNQUFNLEtBQUssRUFBRTt3QkFDM0MsS0FBSyxNQUFNLENBQUMsa0JBQWtCLFVBQVUsTUFBTTtvQkFDaEQsRUFBRSxPQUFPLEdBQUc7d0JBQ1YsT0FBTzt3QkFDUDtvQkFDRjtvQkFDRjtvQkFDQSxNQUFNLGdCQUFnQixRQUFRO2dCQUNoQyxPQUNFLElBQUk7b0JBQ0YsSUFBSSxZQUFZLEtBQUssU0FBUyxDQUFDLE1BQU0sS0FBSyxFQUFFO29CQUM1QyxLQUFLLE1BQU0sQ0FBQyxrQkFBa0IsVUFBVTtvQkFDeEMsU0FBUyxJQUFJLEdBQUcsSUFBSSxDQUFDLFVBQVU7Z0JBQ2pDLEVBQUUsT0FBTyxLQUFLO29CQUNaLE9BQU87Z0JBQ1Q7WUFDSjtZQUNBLFNBQVMsWUFBWSxDQUFDLFdBQVcsSUFBSSxVQUFVO1lBQy9DLElBQUksT0FBTztZQUNYO1lBQ0EsSUFBSSxXQUFXO1lBQ2YsV0FBVyxhQUFhO1lBQ3hCLFNBQVMsSUFBSSxHQUFHLElBQUksQ0FBQyxVQUFVO1lBQy9CLE9BQU8sTUFBTSxDQUFDLFdBQVcsTUFBTSxHQUFHLElBQUksU0FBUyxRQUFRLENBQUM7UUFDMUQ7UUFDQSxTQUFTLGNBQWMsR0FBRyxFQUFFLEtBQUs7WUFDL0IsSUFBSSxnQkFBZ0IsSUFBSSxDQUFDLElBQUk7WUFDN0IsYUFBYSxPQUFPLGlCQUNsQixrQkFBa0IsU0FDbEIseUJBQXlCLFFBQ3pCLENBQUMsYUFBYSxXQUFXLGlCQUNyQixRQUFRLEtBQUssQ0FDWCx5R0FDQSxXQUFXLGdCQUNYLDhCQUE4QixJQUFJLEVBQUUsUUFFdEMsUUFBUSxLQUFLLENBQ1gsNExBQ0EsOEJBQThCLElBQUksRUFBRSxLQUNyQztZQUNQLElBQUksU0FBUyxPQUFPLE9BQU87WUFDM0IsSUFBSSxhQUFhLE9BQU8sT0FBTztnQkFDN0IsT0FBUSxNQUFNLFFBQVE7b0JBQ3BCLEtBQUs7d0JBQ0gsSUFBSSxLQUFLLE1BQU0sdUJBQXVCLENBQUMsTUFBTSxJQUFJLE9BQU8sQ0FBQyxNQUFNOzRCQUM3RCxJQUFJLGtCQUFrQixlQUFlLEdBQUcsQ0FBQyxJQUFJOzRCQUM3QyxJQUFJLEtBQUssTUFBTSxpQkFDYixPQUNFLG9CQUFvQixHQUFHLENBQUMsa0JBQWtCLE1BQU0sS0FBSyxRQUNyRDt3QkFFTjt3QkFDQSxNQUFNLE1BQ0osdUpBQ0UsOEJBQThCLElBQUksRUFBRTtvQkFFMUMsS0FBSzt3QkFDSCxnQkFBZ0IsTUFBTSxRQUFRO3dCQUM5QixJQUFJLE9BQU8sTUFBTSxLQUFLO3dCQUN0QixTQUFTLFlBQVksQ0FBQyxXQUFXLElBQUksVUFBVTt3QkFDL0M7d0JBQ0EsSUFBSTs0QkFDRixrQkFBa0IsS0FBSzs0QkFDdkIsSUFBSSxTQUFTLGNBQ1gsV0FBVyxlQUFlLGlCQUFpQjs0QkFDN0MsU0FBUyxNQUFNLENBQUMsa0JBQWtCLFFBQVE7NEJBQzFDLE9BQU8sTUFBTSxPQUFPLFFBQVEsQ0FBQzt3QkFDL0IsRUFBRSxPQUFPLEdBQUc7NEJBQ1YsSUFDRSxhQUFhLE9BQU8sS0FDcEIsU0FBUyxLQUNULGVBQWUsT0FBTyxFQUFFLElBQUksRUFDNUI7Z0NBQ0E7Z0NBQ0EsSUFBSSxVQUFVO2dDQUNkLGtCQUFrQjtvQ0FDaEIsSUFBSTt3Q0FDRixJQUFJLGFBQWEsZUFBZSxPQUFPLFVBQ3JDLFFBQVE7d0NBQ1YsTUFBTSxNQUFNLENBQUMsa0JBQWtCLFNBQVM7d0NBQ3hDO3dDQUNBLE1BQU0sZ0JBQWdCLFFBQVE7b0NBQ2hDLEVBQUUsT0FBTyxRQUFRO3dDQUNmLE9BQU87b0NBQ1Q7Z0NBQ0Y7Z0NBQ0EsRUFBRSxJQUFJLENBQUMsaUJBQWlCO2dDQUN4QixPQUFPLE1BQU0sUUFBUSxRQUFRLENBQUM7NEJBQ2hDOzRCQUNBLE9BQU87NEJBQ1AsT0FBTzt3QkFDVCxTQUFVOzRCQUNSO3dCQUNGO2dCQUNKO2dCQUNBLElBQUksZUFBZSxPQUFPLE1BQU0sSUFBSSxFQUFFO29CQUNwQyxTQUFTLFlBQVksQ0FBQyxXQUFXLElBQUksVUFBVTtvQkFDL0M7b0JBQ0EsSUFBSSxZQUFZO29CQUNoQixNQUFNLElBQUksQ0FBQyxTQUFVLFNBQVM7d0JBQzVCLElBQUk7NEJBQ0YsSUFBSSxhQUFhLGVBQWUsV0FBVzs0QkFDM0MsWUFBWTs0QkFDWixVQUFVLE1BQU0sQ0FBQyxrQkFBa0IsV0FBVzs0QkFDOUM7NEJBQ0EsTUFBTSxnQkFBZ0IsUUFBUTt3QkFDaEMsRUFBRSxPQUFPLFFBQVE7NEJBQ2YsT0FBTzt3QkFDVDtvQkFDRixHQUFHO29CQUNILE9BQU8sT0FBTyxVQUFVLFFBQVEsQ0FBQztnQkFDbkM7Z0JBQ0Esa0JBQWtCLGVBQWUsR0FBRyxDQUFDO2dCQUNyQyxJQUFJLEtBQUssTUFBTSxpQkFDYixJQUFJLGNBQWMsT0FBTyxZQUFZO3FCQUNoQyxPQUFPO3FCQUVaLENBQUMsTUFBTSxJQUFJLE9BQU8sQ0FBQyxRQUNqQixDQUFDLEFBQUMsa0JBQWtCLGVBQWUsR0FBRyxDQUFDLElBQUksR0FDM0MsS0FBSyxNQUFNLG1CQUNULENBQUMsQUFBQyxrQkFBa0Isa0JBQWtCLE1BQU0sS0FDNUMsZUFBZSxHQUFHLENBQUMsT0FBTyxrQkFDMUIsS0FBSyxNQUFNLHVCQUNULG9CQUFvQixHQUFHLENBQUMsaUJBQWlCLE1BQU0sQ0FBQztnQkFDeEQsSUFBSSxZQUFZLFFBQVEsT0FBTztnQkFDL0IsSUFBSSxpQkFBaUIsVUFBVTtvQkFDN0IsU0FBUyxZQUFZLENBQUMsV0FBVyxJQUFJLFVBQVU7b0JBQy9DLElBQUksU0FBUztvQkFDYixNQUFNO29CQUNOLElBQUksU0FBUyxrQkFBa0IsTUFBTTtvQkFDckMsTUFBTSxPQUFPLENBQUMsU0FBVSxhQUFhLEVBQUUsV0FBVzt3QkFDaEQsT0FBTyxNQUFNLENBQUMsU0FBUyxhQUFhO29CQUN0QztvQkFDQSxPQUFPLE9BQU8sSUFBSSxRQUFRLENBQUM7Z0JBQzdCO2dCQUNBLElBQUksaUJBQWlCLEtBQ25CLE9BQ0UsQUFBQyxNQUFNLGNBQ04sa0JBQWtCLGVBQWUsTUFBTSxJQUFJLENBQUMsUUFBUSxNQUNyRCxTQUFTLFlBQVksQ0FBQyxXQUFXLElBQUksVUFBVSxHQUMvQyxTQUFTLE1BQU0sQ0FBQyxrQkFBa0IsS0FBSyxrQkFDdkMsT0FBTyxJQUFJLFFBQVEsQ0FBQztnQkFFeEIsSUFBSSxpQkFBaUIsS0FDbkIsT0FDRSxBQUFDLE1BQU0sY0FDTixrQkFBa0IsZUFBZSxNQUFNLElBQUksQ0FBQyxRQUFRLE1BQ3JELFNBQVMsWUFBWSxDQUFDLFdBQVcsSUFBSSxVQUFVLEdBQy9DLFNBQVMsTUFBTSxDQUFDLGtCQUFrQixLQUFLLGtCQUN2QyxPQUFPLElBQUksUUFBUSxDQUFDO2dCQUV4QixJQUFJLGlCQUFpQixhQUNuQixPQUNFLEFBQUMsTUFBTSxJQUFJLEtBQUs7b0JBQUM7aUJBQU0sR0FDdEIsa0JBQWtCLGNBQ25CLFNBQVMsWUFBWSxDQUFDLFdBQVcsSUFBSSxVQUFVLEdBQy9DLFNBQVMsTUFBTSxDQUFDLGtCQUFrQixpQkFBaUIsTUFDbkQsT0FBTyxnQkFBZ0IsUUFBUSxDQUFDO2dCQUVwQyxJQUFJLGlCQUFpQixXQUNuQixPQUFPLG9CQUFvQixLQUFLO2dCQUNsQyxJQUFJLGlCQUFpQixZQUNuQixPQUFPLG9CQUFvQixLQUFLO2dCQUNsQyxJQUFJLGlCQUFpQixtQkFDbkIsT0FBTyxvQkFBb0IsS0FBSztnQkFDbEMsSUFBSSxpQkFBaUIsWUFDbkIsT0FBTyxvQkFBb0IsS0FBSztnQkFDbEMsSUFBSSxpQkFBaUIsYUFDbkIsT0FBTyxvQkFBb0IsS0FBSztnQkFDbEMsSUFBSSxpQkFBaUIsWUFDbkIsT0FBTyxvQkFBb0IsS0FBSztnQkFDbEMsSUFBSSxpQkFBaUIsYUFDbkIsT0FBTyxvQkFBb0IsS0FBSztnQkFDbEMsSUFBSSxpQkFBaUIsY0FDbkIsT0FBTyxvQkFBb0IsS0FBSztnQkFDbEMsSUFBSSxpQkFBaUIsY0FDbkIsT0FBTyxvQkFBb0IsS0FBSztnQkFDbEMsSUFBSSxpQkFBaUIsZUFDbkIsT0FBTyxvQkFBb0IsS0FBSztnQkFDbEMsSUFBSSxpQkFBaUIsZ0JBQ25CLE9BQU8sb0JBQW9CLEtBQUs7Z0JBQ2xDLElBQUksaUJBQWlCLFVBQVUsT0FBTyxvQkFBb0IsS0FBSztnQkFDL0QsSUFBSSxlQUFlLE9BQU8sUUFBUSxpQkFBaUIsTUFDakQsT0FDRSxTQUFTLFlBQVksQ0FBQyxXQUFXLElBQUksVUFBVSxHQUM5QyxNQUFNLGNBQ1AsU0FBUyxNQUFNLENBQUMsa0JBQWtCLEtBQUssUUFDdkMsT0FBTyxJQUFJLFFBQVEsQ0FBQztnQkFFeEIsSUFBSyxrQkFBa0IsY0FBYyxRQUNuQyxPQUNFLEFBQUMsa0JBQWtCLGdCQUFnQixJQUFJLENBQUMsUUFDeEMsb0JBQW9CLFFBQ2hCLENBQUMsQUFBQyxNQUFNLGNBQ1Asa0JBQWtCLGVBQ2pCLE1BQU0sSUFBSSxDQUFDLGtCQUNYLE1BRUYsU0FBUyxZQUFZLENBQUMsV0FBVyxJQUFJLFVBQVUsR0FDL0MsU0FBUyxNQUFNLENBQUMsa0JBQWtCLEtBQUssa0JBQ3ZDLE9BQU8sSUFBSSxRQUFRLENBQUMsR0FBRyxJQUN2QixNQUFNLElBQUksQ0FBQztnQkFFbkIsSUFDRSxlQUFlLE9BQU8sa0JBQ3RCLGlCQUFpQixnQkFFakIsT0FBTyx3QkFBd0I7Z0JBQ2pDLGtCQUFrQixLQUFLLENBQUMsZUFBZTtnQkFDdkMsSUFBSSxlQUFlLE9BQU8saUJBQ3hCLE9BQU8sdUJBQXVCLE9BQU8sZ0JBQWdCLElBQUksQ0FBQztnQkFDNUQsa0JBQWtCLGVBQWU7Z0JBQ2pDLElBQ0Usb0JBQW9CLG1CQUNwQixDQUFDLFNBQVMsbUJBQ1IsU0FBUyxlQUFlLGdCQUFnQixHQUMxQztvQkFDQSxJQUFJLEtBQUssTUFBTSxxQkFDYixNQUFNLE1BQ0osOEhBQ0UsOEJBQThCLElBQUksRUFBRTtvQkFFMUMsT0FBTztnQkFDVDtnQkFDQSxNQUFNLFFBQVEsS0FBSyxxQkFDZixRQUFRLEtBQUssQ0FDWCxtRkFDQSw4QkFBOEIsSUFBSSxFQUFFLFFBRXRDLGFBQWEsV0FBVyxTQUN0QixRQUFRLEtBQUssQ0FDWCx5R0FDQSxXQUFXLFFBQ1gsOEJBQThCLElBQUksRUFBRSxRQUV0QyxlQUFlLFNBQ2IsT0FBTyxxQkFBcUIsSUFDNUIsQ0FBQyxBQUFDLGtCQUFrQixPQUFPLHFCQUFxQixDQUFDLFFBQ2pELElBQUksZ0JBQWdCLE1BQU0sSUFDeEIsUUFBUSxLQUFLLENBQ1gscUlBQ0EsZUFBZSxDQUFDLEVBQUUsQ0FBQyxXQUFXLEVBQzlCLDhCQUE4QixJQUFJLEVBQUUsS0FDckMsSUFDSCxRQUFRLEtBQUssQ0FDWCxvSUFDQSw4QkFBOEIsSUFBSSxFQUFFO2dCQUU5QyxPQUFPO1lBQ1Q7WUFDQSxJQUFJLGFBQWEsT0FBTyxPQUFPO2dCQUM3QixJQUFJLFFBQVEsS0FBSyxDQUFDLE1BQU0sTUFBTSxHQUFHLEVBQUUsSUFBSSxJQUFJLENBQUMsSUFBSSxZQUFZLE1BQzFELE9BQU8sT0FBTztnQkFDaEIsTUFBTSxRQUFRLEtBQUssQ0FBQyxFQUFFLEdBQUcsTUFBTSxRQUFRO2dCQUN2QyxPQUFPO1lBQ1Q7WUFDQSxJQUFJLGNBQWMsT0FBTyxPQUFPLE9BQU87WUFDdkMsSUFBSSxhQUFhLE9BQU8sT0FBTyxPQUFPLGdCQUFnQjtZQUN0RCxJQUFJLGdCQUFnQixPQUFPLE9BQU8sT0FBTztZQUN6QyxJQUFJLGVBQWUsT0FBTyxPQUFPO2dCQUMvQixrQkFBa0Isc0JBQXNCLEdBQUcsQ0FBQztnQkFDNUMsSUFBSSxLQUFLLE1BQU0saUJBQ2IsT0FDRSxBQUFDLE1BQU0sS0FBSyxTQUFTLENBQ25CO29CQUFFLElBQUksZ0JBQWdCLEVBQUU7b0JBQUUsT0FBTyxnQkFBZ0IsS0FBSztnQkFBQyxHQUN2RCxnQkFFRixTQUFTLFlBQVksQ0FBQyxXQUFXLElBQUksVUFBVSxHQUM5QyxrQkFBa0IsY0FDbkIsU0FBUyxHQUFHLENBQUMsa0JBQWtCLGlCQUFpQixNQUNoRCxPQUFPLGdCQUFnQixRQUFRLENBQUM7Z0JBRXBDLElBQ0UsS0FBSyxNQUFNLHVCQUNYLENBQUMsTUFBTSxJQUFJLE9BQU8sQ0FBQyxRQUNuQixDQUFDLEFBQUMsa0JBQWtCLGVBQWUsR0FBRyxDQUFDLElBQUksR0FDM0MsS0FBSyxNQUFNLGVBQWUsR0FFMUIsT0FDRSxvQkFBb0IsR0FBRyxDQUFDLGtCQUFrQixNQUFNLEtBQUssUUFBUTtnQkFFakUsTUFBTSxNQUNKO1lBRUo7WUFDQSxJQUFJLGFBQWEsT0FBTyxPQUFPO2dCQUM3QixJQUNFLEtBQUssTUFBTSx1QkFDWCxDQUFDLE1BQU0sSUFBSSxPQUFPLENBQUMsUUFDbkIsQ0FBQyxBQUFDLGtCQUFrQixlQUFlLEdBQUcsQ0FBQyxJQUFJLEdBQzNDLEtBQUssTUFBTSxlQUFlLEdBRTFCLE9BQ0Usb0JBQW9CLEdBQUcsQ0FBQyxrQkFBa0IsTUFBTSxLQUFLLFFBQVE7Z0JBRWpFLE1BQU0sTUFDSixrSUFDRSw4QkFBOEIsSUFBSSxFQUFFO1lBRTFDO1lBQ0EsSUFBSSxhQUFhLE9BQU8sT0FBTyxPQUFPLE9BQU8sTUFBTSxRQUFRLENBQUM7WUFDNUQsTUFBTSxNQUNKLFVBQ0UsT0FBTyxRQUNQO1FBRU47UUFDQSxTQUFTLGVBQWUsS0FBSyxFQUFFLEVBQUU7WUFDL0IsYUFBYSxPQUFPLFNBQ2xCLFNBQVMsU0FDVCxDQUFDLEFBQUMsS0FBSyxNQUFNLEdBQUcsUUFBUSxDQUFDLEtBQ3pCLGVBQWUsR0FBRyxDQUFDLE9BQU8sS0FDMUIsS0FBSyxNQUFNLHVCQUF1QixvQkFBb0IsR0FBRyxDQUFDLElBQUksTUFBTTtZQUN0RSxZQUFZO1lBQ1osT0FBTyxLQUFLLFNBQVMsQ0FBQyxPQUFPO1FBQy9CO1FBQ0EsSUFBSSxhQUFhLEdBQ2YsZUFBZSxHQUNmLFdBQVcsTUFDWCxpQkFBaUIsSUFBSSxXQUNyQixZQUFZLE1BQ1osT0FBTyxlQUFlLE1BQU07UUFDOUIsU0FBUyxXQUNMLFFBQVEsUUFDUixDQUFDLFNBQVMsR0FBRyxDQUFDLGtCQUFrQixLQUFLLE9BQ3JDLE1BQU0sZ0JBQWdCLFFBQVEsU0FBUztRQUMzQyxPQUFPO1lBQ0wsSUFBSSxnQkFDRixDQUFDLEFBQUMsZUFBZSxHQUNqQixTQUFTLFdBQVcsUUFBUSxRQUFRLFFBQVEsU0FBUztRQUN6RDtJQUNGO0lBQ0EsU0FBUyxlQUFlLFNBQVM7UUFDL0IsSUFBSSxTQUNGLFFBQ0EsV0FBVyxJQUFJLFFBQVEsU0FBVSxHQUFHLEVBQUUsR0FBRztZQUN2QyxVQUFVO1lBQ1YsU0FBUztRQUNYO1FBQ0YsYUFDRSxXQUNBLElBQ0EsS0FBSyxHQUNMLFNBQVUsSUFBSTtZQUNaLElBQUksYUFBYSxPQUFPLE1BQU07Z0JBQzVCLElBQUksT0FBTyxJQUFJO2dCQUNmLEtBQUssTUFBTSxDQUFDLEtBQUs7Z0JBQ2pCLE9BQU87WUFDVDtZQUNBLFNBQVMsTUFBTSxHQUFHO1lBQ2xCLFNBQVMsS0FBSyxHQUFHO1lBQ2pCLFFBQVE7UUFDVixHQUNBLFNBQVUsQ0FBQztZQUNULFNBQVMsTUFBTSxHQUFHO1lBQ2xCLFNBQVMsTUFBTSxHQUFHO1lBQ2xCLE9BQU87UUFDVDtRQUVGLE9BQU87SUFDVDtJQUNBLFNBQVMsd0JBQXdCLGdCQUFnQjtRQUMvQyxJQUFJLG1CQUFtQixzQkFBc0IsR0FBRyxDQUFDLElBQUk7UUFDckQsSUFBSSxDQUFDLGtCQUNILE1BQU0sTUFDSjtRQUVKLElBQUksT0FBTztRQUNYLElBQUksU0FBUyxpQkFBaUIsS0FBSyxFQUFFO1lBQ25DLE9BQU8sV0FBVyxHQUFHLENBQUM7WUFDdEIsUUFDRSxDQUFDLEFBQUMsT0FBTyxlQUFlO2dCQUN0QixJQUFJLGlCQUFpQixFQUFFO2dCQUN2QixPQUFPLGlCQUFpQixLQUFLO1lBQy9CLElBQ0EsV0FBVyxHQUFHLENBQUMsa0JBQWtCLEtBQUs7WUFDeEMsSUFBSSxlQUFlLEtBQUssTUFBTSxFQUFFLE1BQU0sS0FBSyxNQUFNO1lBQ2pELElBQUksZ0JBQWdCLEtBQUssTUFBTSxFQUFFLE1BQU07WUFDdkMsbUJBQW1CLEtBQUssS0FBSztZQUM3QixJQUFJLGVBQWUsSUFBSTtZQUN2QixpQkFBaUIsT0FBTyxDQUFDLFNBQVUsS0FBSyxFQUFFLEdBQUc7Z0JBQzNDLGFBQWEsTUFBTSxDQUFDLGFBQWEsbUJBQW1CLE1BQU0sS0FBSztZQUNqRTtZQUNBLE9BQU87WUFDUCxtQkFBbUIsaUJBQWlCO1FBQ3RDLE9BQU8sbUJBQW1CLGdCQUFnQixpQkFBaUIsRUFBRTtRQUM3RCxPQUFPO1lBQ0wsTUFBTTtZQUNOLFFBQVE7WUFDUixTQUFTO1lBQ1QsTUFBTTtRQUNSO0lBQ0Y7SUFDQSxTQUFTLGlCQUFpQixXQUFXLEVBQUUsaUJBQWlCO1FBQ3RELElBQUksbUJBQW1CLHNCQUFzQixHQUFHLENBQUMsSUFBSTtRQUNyRCxJQUFJLENBQUMsa0JBQ0gsTUFBTSxNQUNKO1FBRUosSUFBSSxpQkFBaUIsRUFBRSxLQUFLLGFBQWEsT0FBTyxDQUFDO1FBQ2pELElBQUksZUFBZSxpQkFBaUIsS0FBSztRQUN6QyxJQUFJLFNBQVMsY0FBYyxPQUFPLE1BQU07UUFDeEMsT0FBUSxhQUFhLE1BQU07WUFDekIsS0FBSztnQkFDSCxPQUFPLGFBQWEsS0FBSyxDQUFDLE1BQU0sS0FBSztZQUN2QyxLQUFLO2dCQUNILE1BQU07WUFDUixLQUFLO2dCQUNILE1BQU0sYUFBYSxNQUFNO1lBQzNCO2dCQUNFLE1BQ0csYUFBYSxPQUFPLGFBQWEsTUFBTSxJQUN0QyxDQUFDLEFBQUMsYUFBYSxNQUFNLEdBQUcsV0FDeEIsYUFBYSxJQUFJLENBQ2YsU0FBVSxTQUFTO29CQUNqQixhQUFhLE1BQU0sR0FBRztvQkFDdEIsYUFBYSxLQUFLLEdBQUc7Z0JBQ3ZCLEdBQ0EsU0FBVSxLQUFLO29CQUNiLGFBQWEsTUFBTSxHQUFHO29CQUN0QixhQUFhLE1BQU0sR0FBRztnQkFDeEIsRUFDRCxHQUNIO1FBRU47SUFDRjtJQUNBLFNBQVMseUJBQ1AsSUFBSSxFQUNKLFFBQVEsRUFDUixTQUFTLEVBQ1QsSUFBSSxFQUNKLEdBQUcsRUFDSCxlQUFlLEVBQ2YsYUFBYTtRQUViLFFBQVEsQ0FBQyxPQUFPLGFBQWE7UUFDN0IsSUFBSSxjQUFjLEtBQUssU0FBUyxDQUFDO1FBQ2pDLEtBQUssT0FDRCxDQUFDLEFBQUMsT0FBTyxZQUFZLE1BQU0sR0FBRyxHQUM3QixNQUNDLFVBQ0EsY0FDQSxJQUFJLE1BQU0sQ0FBQyxNQUFNLE9BQU8sSUFBSSxNQUFNLFFBQ2xDLDRIQUE2SCxJQUM5SCxNQUNDLG1HQUNBLEtBQUssTUFBTSxDQUFDLE9BQU8sS0FDbkIsZUFDQSxjQUNBLFFBQ0EsSUFBSSxNQUFNLENBQUMsSUFBSSxNQUFNLElBQUksTUFBTSxLQUMvQjtRQUNOLFNBQVMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxXQUFXLFlBQVksUUFBUTtRQUM1RCxZQUNJLENBQUMsQUFBQyxPQUNBLGlDQUNBLG1CQUFtQixtQkFDbkIsTUFDQSxVQUFVLFlBQ1YsT0FDQSx5QkFDRCxPQUFPLDRCQUE0QixTQUFVLElBQzlDLFlBQVksQ0FBQyxPQUFPLHFCQUFxQixRQUFRO1FBQ3JELElBQUk7WUFDRixPQUFPLENBQUMsR0FBRyxJQUFJLEVBQUUsS0FBSyxjQUFjLENBQUMsS0FBSztRQUM1QyxFQUFFLE9BQU8sR0FBRztZQUNWLE9BQU87UUFDVDtJQUNGO0lBQ0EsU0FBUyw2QkFDUCxTQUFTLEVBQ1QsRUFBRSxFQUNGLEtBQUssRUFDTCxnQkFBZ0I7UUFFaEIsc0JBQXNCLEdBQUcsQ0FBQyxjQUN4QixDQUFDLHNCQUFzQixHQUFHLENBQUMsV0FBVztZQUNwQyxJQUFJO1lBQ0osY0FBYyxVQUFVLElBQUk7WUFDNUIsT0FBTztRQUNULElBQ0EsT0FBTyxnQkFBZ0IsQ0FBQyxXQUFXO1lBQ2pDLGVBQWU7Z0JBQ2IsT0FDRSxLQUFLLE1BQU0sbUJBQ1AsMEJBQ0E7b0JBQ0UsSUFBSSxtQkFBbUIsc0JBQXNCLEdBQUcsQ0FBQyxJQUFJO29CQUNyRCxJQUFJLENBQUMsa0JBQ0gsTUFBTSxNQUNKO29CQUVKLElBQUksZUFBZSxpQkFBaUIsS0FBSztvQkFDekMsU0FBUyxnQkFDUCxDQUFDLGVBQWUsUUFBUSxPQUFPLENBQUMsRUFBRSxDQUFDO29CQUNyQyxPQUFPLGlCQUFpQixpQkFBaUIsRUFBRSxFQUFFO2dCQUMvQztZQUNSO1lBQ0Esc0JBQXNCO2dCQUFFLE9BQU87WUFBaUI7WUFDaEQsTUFBTTtnQkFBRSxPQUFPO1lBQUs7UUFDdEIsRUFBRTtJQUNOO0lBQ0EsU0FBUztRQUNQLElBQUksbUJBQW1CLHNCQUFzQixHQUFHLENBQUMsSUFBSTtRQUNyRCxJQUFJLENBQUMsa0JBQWtCLE9BQU8sYUFBYSxLQUFLLENBQUMsSUFBSSxFQUFFO1FBQ3ZELElBQUksUUFBUSxpQkFBaUIsWUFBWSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUU7UUFDdEQsUUFBUSxTQUFTLENBQUMsRUFBRSxJQUNsQixRQUFRLEtBQUssQ0FDWDtRQUVKLElBQUksT0FBTyxXQUFXLElBQUksQ0FBQyxXQUFXLElBQ3BDLGVBQWU7UUFDakIsZUFDRSxTQUFTLGlCQUFpQixLQUFLLEdBQzNCLFFBQVEsT0FBTyxDQUFDLGlCQUFpQixLQUFLLEVBQUUsSUFBSSxDQUFDLFNBQVUsU0FBUztZQUM5RCxPQUFPLFVBQVUsTUFBTSxDQUFDO1FBQzFCLEtBQ0EsUUFBUSxPQUFPLENBQUM7UUFDdEIsc0JBQXNCLEdBQUcsQ0FBQyxPQUFPO1lBQy9CLElBQUksaUJBQWlCLEVBQUU7WUFDdkIsY0FBYyxNQUFNLElBQUk7WUFDeEIsT0FBTztRQUNUO1FBQ0EsT0FBTyxnQkFBZ0IsQ0FBQyxPQUFPO1lBQzdCLGVBQWU7Z0JBQUUsT0FBTyxJQUFJLENBQUMsYUFBYTtZQUFDO1lBQzNDLHNCQUFzQjtnQkFBRSxPQUFPO1lBQWlCO1lBQ2hELE1BQU07Z0JBQUUsT0FBTztZQUFLO1FBQ3RCO1FBQ0EsT0FBTztJQUNUO0lBQ0EsU0FBUywyQkFDUCxRQUFRLEVBQ1IsVUFBVSxFQUNWLGdCQUFnQixFQUNoQixnQkFBZ0I7UUFFaEIsU0FBUztZQUNQLElBQUksT0FBTyxNQUFNLFNBQVMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDO1lBQ3RDLE9BQU8sUUFDSCxnQkFBZ0IsTUFBTSxNQUFNLEdBQzFCLFdBQVcsSUFBSSxNQUFNLEtBQUssQ0FBQyxNQUFNLENBQUMsU0FDbEMsUUFBUSxPQUFPLENBQUMsT0FBTyxJQUFJLENBQUMsU0FBVSxTQUFTO2dCQUM3QyxPQUFPLFdBQVcsSUFBSSxVQUFVLE1BQU0sQ0FBQztZQUN6QyxLQUNGLFdBQVcsSUFBSTtRQUNyQjtRQUNBLElBQUksS0FBSyxTQUFTLEVBQUUsRUFDbEIsUUFBUSxTQUFTLEtBQUssRUFDdEIsV0FBVyxTQUFTLFFBQVE7UUFDOUIsSUFBSSxVQUFVO1lBQ1osSUFBSSxlQUFlLFNBQVMsSUFBSSxJQUFJLElBQ2xDLFdBQVcsUUFBUSxDQUFDLEVBQUUsRUFDdEIsT0FBTyxRQUFRLENBQUMsRUFBRTtZQUNwQixXQUFXLFFBQVEsQ0FBQyxFQUFFO1lBQ3RCLFdBQVcsU0FBUyxHQUFHLElBQUk7WUFDM0IsbUJBQ0UsUUFBUSxtQkFDSixPQUNBLGlCQUFpQixVQUFVO1lBQ2pDLFNBQVMseUJBQ1AsY0FDQSxVQUNBLGtCQUNBLE1BQ0EsVUFDQSxVQUNBO1FBRUo7UUFDQSw2QkFBNkIsUUFBUSxJQUFJLE9BQU87UUFDaEQsT0FBTztJQUNUO0lBQ0EsU0FBUyxtQkFBbUIsS0FBSztRQUMvQixRQUFRLE1BQU0sS0FBSztRQUNuQixNQUFNLFVBQVUsQ0FBQyxxQ0FDZixDQUFDLFFBQVEsTUFBTSxLQUFLLENBQUMsR0FBRztRQUMxQixJQUFJLGFBQWEsTUFBTSxPQUFPLENBQUM7UUFDL0IsSUFBSSxDQUFDLE1BQU0sWUFBWTtZQUNyQixJQUFJLGNBQWMsTUFBTSxPQUFPLENBQUMsTUFBTSxhQUFhO1lBQ25ELGFBQ0UsQ0FBQyxNQUFNLGNBQ0gsTUFBTSxLQUFLLENBQUMsYUFBYSxLQUN6QixNQUFNLEtBQUssQ0FBQyxhQUFhLEdBQUc7UUFDcEMsT0FBTyxhQUFhO1FBQ3BCLFFBQVEsY0FBYyxJQUFJLENBQUM7UUFDM0IsSUFDRSxDQUFDLFNBQ0QsQ0FBQyxBQUFDLFFBQVEsMkJBQTJCLElBQUksQ0FBQyxhQUFjLENBQUMsS0FBSyxHQUU5RCxPQUFPO1FBQ1QsYUFBYSxLQUFLLENBQUMsRUFBRSxJQUFJO1FBQ3pCLGtCQUFrQixjQUFjLENBQUMsYUFBYSxFQUFFO1FBQ2hELGNBQWMsS0FBSyxDQUFDLEVBQUUsSUFBSSxLQUFLLENBQUMsRUFBRSxJQUFJO1FBQ3RDLGtCQUFrQixlQUFlLENBQUMsY0FBYyxFQUFFO1FBQ2xELE9BQU87WUFDTDtZQUNBO1lBQ0EsQ0FBQyxDQUFDLEtBQUssQ0FBQyxFQUFFLElBQUksS0FBSyxDQUFDLEVBQUU7WUFDdEIsQ0FBQyxDQUFDLEtBQUssQ0FBQyxFQUFFLElBQUksS0FBSyxDQUFDLEVBQUU7U0FDdkI7SUFDSDtJQUNBLFNBQVMsd0JBQ1AsRUFBRSxFQUNGLFVBQVUsRUFDVixnQkFBZ0IsRUFDaEIsZ0JBQWdCLEVBQ2hCLFlBQVk7UUFFWixTQUFTO1lBQ1AsSUFBSSxPQUFPLE1BQU0sU0FBUyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUM7WUFDdEMsT0FBTyxXQUFXLElBQUk7UUFDeEI7UUFDQSxJQUFJLFdBQVcsbUJBQW1CLE1BQU07UUFDeEMsSUFBSSxTQUFTLFVBQVU7WUFDckIsSUFBSSxXQUFXLFFBQVEsQ0FBQyxFQUFFLEVBQ3hCLE9BQU8sUUFBUSxDQUFDLEVBQUU7WUFDcEIsV0FBVyxRQUFRLENBQUMsRUFBRTtZQUN0QixtQkFDRSxRQUFRLG1CQUNKLE9BQ0EsaUJBQWlCLFVBQVU7WUFDakMsU0FBUyx5QkFDUCxnQkFBZ0IsSUFDaEIsVUFDQSxrQkFDQSxNQUNBLFVBQ0EsVUFDQTtRQUVKO1FBQ0EsNkJBQTZCLFFBQVEsSUFBSSxNQUFNO1FBQy9DLE9BQU87SUFDVDtJQUNBLFNBQVMseUJBQXlCLElBQUk7UUFDcEMsSUFBSSxRQUFRLE1BQU0sT0FBTztRQUN6QixJQUFJLGVBQWUsT0FBTyxNQUN4QixPQUFPLEtBQUssUUFBUSxLQUFLLHlCQUNyQixPQUNBLEtBQUssV0FBVyxJQUFJLEtBQUssSUFBSSxJQUFJO1FBQ3ZDLElBQUksYUFBYSxPQUFPLE1BQU0sT0FBTztRQUNyQyxPQUFRO1lBQ04sS0FBSztnQkFDSCxPQUFPO1lBQ1QsS0FBSztnQkFDSCxPQUFPO1lBQ1QsS0FBSztnQkFDSCxPQUFPO1lBQ1QsS0FBSztnQkFDSCxPQUFPO1lBQ1QsS0FBSztnQkFDSCxPQUFPO1lBQ1QsS0FBSztnQkFDSCxPQUFPO1FBQ1g7UUFDQSxJQUFJLGFBQWEsT0FBTyxNQUN0QixPQUNHLGFBQWEsT0FBTyxLQUFLLEdBQUcsSUFDM0IsUUFBUSxLQUFLLENBQ1gsc0hBRUosS0FBSyxRQUFRO1lBRWIsS0FBSztnQkFDSCxPQUFPO1lBQ1QsS0FBSztnQkFDSCxPQUFPLEtBQUssV0FBVyxJQUFJO1lBQzdCLEtBQUs7Z0JBQ0gsT0FBTyxDQUFDLEtBQUssUUFBUSxDQUFDLFdBQVcsSUFBSSxTQUFTLElBQUk7WUFDcEQsS0FBSztnQkFDSCxJQUFJLFlBQVksS0FBSyxNQUFNO2dCQUMzQixPQUFPLEtBQUssV0FBVztnQkFDdkIsUUFDRSxDQUFDLEFBQUMsT0FBTyxVQUFVLFdBQVcsSUFBSSxVQUFVLElBQUksSUFBSSxJQUNuRCxPQUFPLE9BQU8sT0FBTyxnQkFBZ0IsT0FBTyxNQUFNLFlBQWE7Z0JBQ2xFLE9BQU87WUFDVCxLQUFLO2dCQUNILE9BQ0UsQUFBQyxZQUFZLEtBQUssV0FBVyxJQUFJLE1BQ2pDLFNBQVMsWUFDTCxZQUNBLHlCQUF5QixLQUFLLElBQUksS0FBSztZQUUvQyxLQUFLO2dCQUNILFlBQVksS0FBSyxRQUFRO2dCQUN6QixPQUFPLEtBQUssS0FBSztnQkFDakIsSUFBSTtvQkFDRixPQUFPLHlCQUF5QixLQUFLO2dCQUN2QyxFQUFFLE9BQU8sR0FBRyxDQUFDO1FBQ2pCO1FBQ0YsT0FBTztJQUNUO0lBQ0EsU0FBUyxrQkFBa0IsS0FBSyxFQUFFLG9CQUFvQjtRQUNwRCxRQUFRLENBQUMsTUFBTSxJQUFJLElBQUksT0FBTyxJQUFJLE9BQU8sQ0FBQyxNQUFNLE9BQU8sSUFBSSxFQUFFO1FBQzdELElBQUssSUFBSSxJQUFJLEdBQUcsSUFBSSxxQkFBcUIsTUFBTSxFQUFFLElBQy9DLFNBQVMsY0FBYyxvQkFBb0IsQ0FBQyxFQUFFLENBQUMsUUFBUTtRQUN6RCxPQUFPO0lBQ1Q7SUFDQSxTQUFTLGFBQWEsTUFBTSxFQUFFLEtBQUssRUFBRSxNQUFNO1FBQ3pDLElBQUksQ0FBQyxNQUFNLEdBQUc7UUFDZCxJQUFJLENBQUMsS0FBSyxHQUFHO1FBQ2IsSUFBSSxDQUFDLE1BQU0sR0FBRztRQUNkLElBQUksQ0FBQyxVQUFVLEdBQUc7SUFDcEI7SUFDQSxTQUFTLG1CQUFtQixZQUFZO1FBQ3RDLGVBQWUsYUFBYSxJQUFJLENBQUMsS0FBSztRQUN0QyxJQUFJLEtBQUssTUFBTSxjQUNiLE1BQU0sTUFDSjtRQUVKLE9BQU87SUFDVDtJQUNBLFNBQVMsb0JBQW9CLFlBQVk7UUFDdkMsYUFBYTtJQUNmO0lBQ0EsU0FBUyxVQUFVLEtBQUs7UUFDdEIsT0FBUSxNQUFNLE1BQU07WUFDbEIsS0FBSztnQkFDSCxxQkFBcUI7Z0JBQ3JCO1lBQ0YsS0FBSztnQkFDSCxzQkFBc0I7UUFDMUI7UUFDQSxPQUFRLE1BQU0sTUFBTTtZQUNsQixLQUFLO2dCQUNILE9BQU8sTUFBTSxLQUFLO1lBQ3BCLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztnQkFDSCxNQUFNO1lBQ1I7Z0JBQ0UsTUFBTSxNQUFNLE1BQU07UUFDdEI7SUFDRjtJQUNBLFNBQVMsUUFBUSxZQUFZO1FBQzNCLGVBQWUsbUJBQW1CO1FBQ2xDLE9BQU8sU0FBUyxjQUFjO0lBQ2hDO0lBQ0EsU0FBUyxtQkFBbUIsUUFBUTtRQUNsQyxNQUFNLFNBQVMsY0FBYyxNQUMzQixDQUFDLEFBQUMsU0FBUyxhQUFhLENBQUMsUUFBUSxHQUFHLFVBQ3BDLFNBQVMsU0FBUyxxQkFBcUIsSUFDckMsQ0FBQyxhQUFhLFNBQVMscUJBQXFCLEdBQzNDLFNBQVMscUJBQXFCLEdBQUcsSUFBSyxDQUFDO1FBQzVDLE9BQU8sSUFBSSxhQUFhLFdBQVcsTUFBTTtJQUMzQztJQUNBLFNBQVMsb0JBQW9CLFFBQVEsRUFBRSxLQUFLO1FBQzFDLGNBQWMsTUFBTSxNQUFNLElBQ3hCLE1BQU0sRUFBRSxTQUFTLGNBQWMsSUFDL0IsQ0FBQyxBQUFDLFNBQVMsYUFBYSxDQUFDLFFBQVEsR0FBRyxNQUNuQyxTQUFTLHFCQUFxQixHQUFHLFdBQ2hDLDhCQUE4QixJQUFJLENBQUMsTUFBTSxXQUN6QyxJQUNBO0lBQ047SUFDQSxTQUFTLFVBQVUsU0FBUyxFQUFFLEtBQUs7UUFDakMsSUFBSyxJQUFJLElBQUksR0FBRyxJQUFJLFVBQVUsTUFBTSxFQUFFLElBQUs7WUFDekMsSUFBSSxXQUFXLFNBQVMsQ0FBQyxFQUFFO1lBQzNCLGVBQWUsT0FBTyxXQUNsQixTQUFTLFNBQ1QsaUJBQWlCLFVBQVU7UUFDakM7SUFDRjtJQUNBLFNBQVMsWUFBWSxTQUFTLEVBQUUsS0FBSztRQUNuQyxJQUFLLElBQUksSUFBSSxHQUFHLElBQUksVUFBVSxNQUFNLEVBQUUsSUFBSztZQUN6QyxJQUFJLFdBQVcsU0FBUyxDQUFDLEVBQUU7WUFDM0IsZUFBZSxPQUFPLFdBQ2xCLFNBQVMsU0FDVCxnQkFBZ0IsVUFBVTtRQUNoQztJQUNGO0lBQ0EsU0FBUyxvQkFBb0IsYUFBYSxFQUFFLFNBQVM7UUFDbkQsSUFBSSxrQkFBa0IsVUFBVSxPQUFPLENBQUMsS0FBSztRQUM3QyxJQUFJLFNBQVMsaUJBQWlCLE9BQU87UUFDckMsSUFBSSxvQkFBb0IsZUFBZSxPQUFPLFVBQVUsT0FBTztRQUMvRCxZQUFZLGdCQUFnQixLQUFLO1FBQ2pDLElBQUksU0FBUyxXQUNYLElBQ0Usa0JBQWtCLEdBQ2xCLGtCQUFrQixVQUFVLE1BQU0sRUFDbEMsa0JBQ0E7WUFDQSxJQUFJLFdBQVcsU0FBUyxDQUFDLGdCQUFnQjtZQUN6QyxJQUNFLGVBQWUsT0FBTyxZQUN0QixDQUFDLEFBQUMsV0FBVyxvQkFBb0IsZUFBZSxXQUNoRCxTQUFTLFFBQVEsR0FFakIsT0FBTztRQUNYO1FBQ0YsT0FBTztJQUNUO0lBQ0EsU0FBUyx1QkFBdUIsS0FBSyxFQUFFLGdCQUFnQixFQUFFLGVBQWU7UUFDdEUsT0FBUSxNQUFNLE1BQU07WUFDbEIsS0FBSztnQkFDSCxVQUFVLGtCQUFrQixNQUFNLEtBQUs7Z0JBQ3ZDO1lBQ0YsS0FBSztnQkFDSCxJQUFLLElBQUksSUFBSSxHQUFHLElBQUksaUJBQWlCLE1BQU0sRUFBRSxJQUFLO29CQUNoRCxJQUFJLFdBQVcsZ0JBQWdCLENBQUMsRUFBRTtvQkFDbEMsSUFBSSxlQUFlLE9BQU8sVUFBVTt3QkFDbEMsSUFBSSxnQkFBZ0Isb0JBQW9CLE9BQU87d0JBQy9DLFNBQVMsaUJBQ1AsQ0FBQyxpQkFBaUIsVUFBVSxjQUFjLEtBQUssR0FDL0MsaUJBQWlCLE1BQU0sQ0FBQyxHQUFHLElBQzNCLEtBQ0EsU0FBUyxtQkFDUCxDQUFDLEFBQUMsV0FBVyxnQkFBZ0IsT0FBTyxDQUFDLFdBQ3JDLENBQUMsTUFBTSxZQUFZLGdCQUFnQixNQUFNLENBQUMsVUFBVSxFQUFFLENBQUM7b0JBQzdEO2dCQUNGO1lBQ0YsS0FBSztnQkFDSCxJQUFJLE1BQU0sS0FBSyxFQUNiLElBQUssSUFBSSxHQUFHLElBQUksaUJBQWlCLE1BQU0sRUFBRSxJQUN2QyxNQUFNLEtBQUssQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsRUFBRTtxQkFDbkMsTUFBTSxLQUFLLEdBQUc7Z0JBQ25CLElBQUksTUFBTSxNQUFNLEVBQUU7b0JBQ2hCLElBQUksaUJBQ0YsSUFDRSxtQkFBbUIsR0FDbkIsbUJBQW1CLGdCQUFnQixNQUFNLEVBQ3pDLG1CQUVBLE1BQU0sTUFBTSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsaUJBQWlCO2dCQUN6RCxPQUFPLE1BQU0sTUFBTSxHQUFHO2dCQUN0QjtZQUNGLEtBQUs7Z0JBQ0gsbUJBQW1CLFlBQVksaUJBQWlCLE1BQU0sTUFBTTtRQUNoRTtJQUNGO0lBQ0EsU0FBUyxvQkFBb0IsUUFBUSxFQUFFLEtBQUssRUFBRSxLQUFLO1FBQ2pELGNBQWMsTUFBTSxNQUFNLElBQUksY0FBYyxNQUFNLE1BQU0sR0FDcEQsTUFBTSxNQUFNLENBQUMsS0FBSyxDQUFDLFNBQ25CLENBQUMsb0JBQW9CLFVBQVUsUUFDOUIsV0FBVyxNQUFNLE1BQU0sRUFDdkIsTUFBTSxNQUFNLEdBQUcsWUFDZixNQUFNLE1BQU0sR0FBRyxPQUNoQixTQUFTLFlBQVksWUFBWSxVQUFVLE1BQU07SUFDdkQ7SUFDQSxTQUFTLGtDQUFrQyxRQUFRLEVBQUUsS0FBSyxFQUFFLElBQUk7UUFDOUQsT0FBTyxJQUFJLGFBQ1Qsa0JBQ0EsQ0FBQyxPQUFPLDBCQUEwQix3QkFBd0IsSUFDeEQsUUFDQSxLQUNGO0lBRUo7SUFDQSxTQUFTLDJCQUEyQixRQUFRLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxJQUFJO1FBQzlELGtCQUNFLFVBQ0EsT0FDQSxDQUFDLE9BQU8sMEJBQTBCLHdCQUF3QixJQUN4RCxRQUNBO0lBRU47SUFDQSxTQUFTLGtCQUFrQixRQUFRLEVBQUUsS0FBSyxFQUFFLEtBQUs7UUFDL0MsSUFBSSxjQUFjLE1BQU0sTUFBTSxFQUFFLE1BQU0sTUFBTSxDQUFDLFlBQVksQ0FBQzthQUNyRDtZQUNILG9CQUFvQixVQUFVO1lBQzlCLElBQUksbUJBQW1CLE1BQU0sS0FBSyxFQUNoQyxrQkFBa0IsTUFBTSxNQUFNO1lBQ2hDLE1BQU0sTUFBTSxHQUFHO1lBQ2YsTUFBTSxLQUFLLEdBQUc7WUFDZCxNQUFNLE1BQU0sR0FBRztZQUNmLFNBQVMsb0JBQ1AsQ0FBQyxxQkFBcUIsUUFDdEIsdUJBQXVCLE9BQU8sa0JBQWtCLGdCQUFnQjtRQUNwRTtJQUNGO0lBQ0EsU0FBUyxtQkFBbUIsUUFBUSxFQUFFLEtBQUssRUFBRSxLQUFLO1FBQ2hELElBQUksY0FBYyxNQUFNLE1BQU0sSUFBSSxjQUFjLE1BQU0sTUFBTSxFQUFFO1lBQzVELG9CQUFvQixVQUFVO1lBQzlCLFdBQVcsTUFBTSxLQUFLO1lBQ3RCLElBQUksa0JBQWtCLE1BQU0sTUFBTTtZQUNsQyxNQUFNLE1BQU0sR0FBRztZQUNmLE1BQU0sS0FBSyxHQUFHO1lBQ2QsU0FBUyxZQUNQLENBQUMsc0JBQXNCLFFBQ3ZCLHVCQUF1QixPQUFPLFVBQVUsZ0JBQWdCO1FBQzVEO0lBQ0Y7SUFDQSxTQUFTLHFCQUFxQixLQUFLO1FBQ2pDLElBQUksY0FBYztRQUNsQixzQkFBc0I7UUFDdEIsSUFBSSxnQkFBZ0IsTUFBTSxLQUFLLEVBQzdCLFdBQVcsTUFBTSxNQUFNO1FBQ3pCLE1BQU0sTUFBTSxHQUFHO1FBQ2YsTUFBTSxLQUFLLEdBQUc7UUFDZCxNQUFNLE1BQU0sR0FBRztRQUNmLElBQUk7WUFDRixJQUFJLFFBQVEsS0FBSyxLQUFLLENBQUMsZUFBZSxTQUFTLFNBQVMsR0FDdEQsbUJBQW1CLE1BQU0sS0FBSztZQUNoQyxTQUFTLG9CQUNQLENBQUMsQUFBQyxNQUFNLEtBQUssR0FBRyxNQUNmLE1BQU0sTUFBTSxHQUFHLE1BQ2hCLFVBQVUsa0JBQWtCLE1BQU07WUFDcEMsSUFBSSxTQUFTLHFCQUFxQjtnQkFDaEMsSUFBSSxvQkFBb0IsT0FBTyxFQUFFLE1BQU0sb0JBQW9CLEtBQUs7Z0JBQ2hFLElBQUksSUFBSSxvQkFBb0IsSUFBSSxFQUFFO29CQUNoQyxvQkFBb0IsS0FBSyxHQUFHO29CQUM1QixvQkFBb0IsS0FBSyxHQUFHO29CQUM1QjtnQkFDRjtZQUNGO1lBQ0EsTUFBTSxNQUFNLEdBQUc7WUFDZixNQUFNLEtBQUssR0FBRztRQUNoQixFQUFFLE9BQU8sT0FBTztZQUNiLE1BQU0sTUFBTSxHQUFHLFlBQWMsTUFBTSxNQUFNLEdBQUc7UUFDL0MsU0FBVTtZQUNSLHNCQUFzQjtRQUN4QjtJQUNGO0lBQ0EsU0FBUyxzQkFBc0IsS0FBSztRQUNsQyxJQUFJO1lBQ0YsSUFBSSxRQUFRLGNBQWMsTUFBTSxLQUFLO1lBQ3JDLE1BQU0sTUFBTSxHQUFHO1lBQ2YsTUFBTSxLQUFLLEdBQUc7UUFDaEIsRUFBRSxPQUFPLE9BQU87WUFDYixNQUFNLE1BQU0sR0FBRyxZQUFjLE1BQU0sTUFBTSxHQUFHO1FBQy9DO0lBQ0Y7SUFDQSxTQUFTLGtCQUFrQixZQUFZLEVBQUUsS0FBSztRQUM1QyxJQUFJLEtBQUssTUFBTSxhQUFhLElBQUksQ0FBQyxLQUFLLElBQUk7WUFDeEMsSUFBSSxXQUFXLG1CQUFtQjtZQUNsQyxTQUFTLE9BQU8sR0FBRyxDQUFDO1lBQ3BCLFNBQVMsYUFBYSxHQUFHO1lBQ3pCLFNBQVMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxTQUFVLEtBQUs7Z0JBQ3RDLGNBQWMsTUFBTSxNQUFNLElBQ3hCLG9CQUFvQixVQUFVLE9BQU87WUFDekM7WUFDQSxlQUFlLFNBQVMsYUFBYTtZQUNyQyxLQUFLLE1BQU0sZ0JBQ1QsQ0FBQyxhQUFhLEtBQU0sU0FBUyxhQUFhLEdBQUcsS0FBSyxDQUFFO1FBQ3hEO0lBQ0Y7SUFDQSxTQUFTO1FBQ1AsT0FBTztJQUNUO0lBQ0EsU0FBUyxZQUFZLElBQUk7UUFDdkIsSUFBSSxTQUFTLHFCQUFxQixPQUFPO1FBQ3pDLElBQUksZUFBZSxPQUFPLE1BQU0sT0FBTztRQUN2QyxJQUNFLGFBQWEsT0FBTyxRQUNwQixTQUFTLFFBQ1QsS0FBSyxRQUFRLEtBQUssaUJBRWxCLE9BQU8sS0FBSyxLQUFLLEtBQUssWUFBWSxpQkFBaUI7UUFDckQsSUFBSTtZQUNGLElBQUksT0FBTyx5QkFBeUI7WUFDcEMsT0FBTyxPQUFPLE1BQU0sT0FBTyxNQUFNO1FBQ25DLEVBQUUsT0FBTyxHQUFHO1lBQ1YsT0FBTztRQUNUO0lBQ0Y7SUFDQSxTQUFTLGtCQUFrQixRQUFRLEVBQUUsT0FBTztRQUMxQyxJQUFJLFFBQVEsUUFBUSxXQUFXLEVBQzdCLFFBQVEsUUFBUSxNQUFNO1FBQ3hCLFNBQVMsU0FBUyxDQUFDLFFBQVEsTUFBTSxHQUFHLFNBQVMsZUFBZTtRQUM1RCxJQUFJLE1BQU0sU0FBUyxvQkFBb0I7UUFDdkMsU0FBUyxTQUFTLFFBQVEsTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNLE1BQU0sR0FBRztRQUN2RCxJQUFJLHVCQUF1QjtRQUMzQixTQUFTLFNBQVMsUUFBUSxTQUFTLGVBQWUsR0FDN0MsdUJBQXVCLFNBQVMsZUFBZSxHQUNoRCxTQUFTLFNBQ1QsQ0FBQyx1QkFBdUIsNEJBQ3RCLFVBQ0EsT0FDQSxJQUNEO1FBQ0wsUUFBUSxXQUFXLEdBQUc7UUFDdEIsdUJBQXVCO1FBQ3ZCLHNCQUNFLFNBQVMsU0FDVCxDQUFDLEFBQUMsdUJBQXVCLFFBQVEsVUFBVSxDQUFDLElBQUksQ0FDOUMsU0FDQSxZQUFZLFFBQVEsSUFBSSxJQUV6QixRQUFRLG1CQUNQLFVBQ0EsT0FDQSxLQUNBLENBQUMsR0FDRCx1QkFFRCxNQUFNLFNBQVMsUUFBUSxPQUFPLG1CQUFtQixVQUFVLFFBQzVELFNBQVMsTUFDTCxDQUFDLEFBQUMsTUFBTSxTQUFTLGNBQWMsRUFDOUIsdUJBQXVCLFFBQVEsTUFBTSxJQUFJLEdBQUcsQ0FBQyxTQUFTLE9BQVEsSUFDOUQsdUJBQXVCLElBQUksR0FBRyxDQUFDLE1BQU87UUFDN0MsUUFBUSxVQUFVLEdBQUc7UUFDckIsU0FBUyxTQUFTLG9CQUFvQixVQUFVO1FBQ2hELE9BQU8sTUFBTSxDQUFDLFFBQVEsS0FBSztJQUM3QjtJQUNBLFNBQVMsdUJBQXVCLEtBQUs7UUFDbkMsSUFBSSxXQUFXO1lBQ2IsVUFBVTtZQUNWLFVBQVU7WUFDVixPQUFPO1FBQ1Q7UUFDQSxRQUFRLE1BQU0sVUFBVSxJQUFJLENBQUMsTUFBTSxVQUFVLEdBQUcsRUFBRTtRQUNsRCxTQUFTLFVBQVUsR0FBRztRQUN0QixPQUFPO0lBQ1Q7SUFDQSxTQUFTLFNBQVMsUUFBUSxFQUFFLEVBQUU7UUFDNUIsSUFBSSxTQUFTLFNBQVMsT0FBTyxFQUMzQixRQUFRLE9BQU8sR0FBRyxDQUFDO1FBQ3JCLFNBQ0UsQ0FBQyxBQUFDLFFBQVEsU0FBUyxPQUFPLEdBQ3RCLElBQUksYUFBYSxZQUFZLE1BQU0sU0FBUyxhQUFhLElBQ3pELG1CQUFtQixXQUN2QixPQUFPLEdBQUcsQ0FBQyxJQUFJLE1BQU07UUFDdkIsT0FBTztJQUNUO0lBQ0EsU0FBUyxpQkFBaUIsU0FBUyxFQUFFLEtBQUs7UUFDeEMsSUFDRSxJQUFJLFdBQVcsVUFBVSxRQUFRLEVBQy9CLFVBQVUsVUFBVSxPQUFPLEVBQzNCLGVBQWUsVUFBVSxZQUFZLEVBQ3JDLE1BQU0sVUFBVSxHQUFHLEVBQ25CLE1BQU0sVUFBVSxHQUFHLEVBQ25CLE9BQU8sVUFBVSxJQUFJLEVBQ3JCLElBQUksR0FDTixJQUFJLEtBQUssTUFBTSxFQUNmLElBQ0E7WUFDQSxNQUFPLE1BQU0sUUFBUSxLQUFLLGlCQUN4QixJQUFLLEFBQUMsUUFBUSxNQUFNLFFBQVEsRUFBRyxVQUFVLFFBQVEsS0FBSyxFQUNwRCxRQUFRLFFBQVEsS0FBSztpQkFDbEI7Z0JBQ0gsT0FBUSxNQUFNLE1BQU07b0JBQ2xCLEtBQUs7d0JBQ0gscUJBQXFCO3dCQUNyQjtvQkFDRixLQUFLO3dCQUNILHNCQUFzQjtnQkFDMUI7Z0JBQ0EsT0FBUSxNQUFNLE1BQU07b0JBQ2xCLEtBQUs7d0JBQ0gsUUFBUSxNQUFNLEtBQUs7d0JBQ25CO29CQUNGLEtBQUs7d0JBQ0gsSUFBSSxnQkFBZ0Isb0JBQW9CLE9BQU87d0JBQy9DLElBQUksU0FBUyxlQUFlOzRCQUMxQixRQUFRLGNBQWMsS0FBSzs0QkFDM0I7d0JBQ0Y7b0JBQ0YsS0FBSzt3QkFDSCxLQUFLLE1BQU0sQ0FBQyxHQUFHLElBQUk7d0JBQ25CLFNBQVMsTUFBTSxLQUFLLEdBQ2YsTUFBTSxLQUFLLEdBQUc7NEJBQUM7eUJBQVUsR0FDMUIsTUFBTSxLQUFLLENBQUMsSUFBSSxDQUFDO3dCQUNyQixTQUFTLE1BQU0sTUFBTSxHQUNoQixNQUFNLE1BQU0sR0FBRzs0QkFBQzt5QkFBVSxHQUMzQixNQUFNLE1BQU0sQ0FBQyxJQUFJLENBQUM7d0JBQ3RCO29CQUNGLEtBQUs7d0JBQ0g7b0JBQ0Y7d0JBQ0UsZ0JBQWdCLFdBQVcsTUFBTSxNQUFNO3dCQUN2QztnQkFDSjtZQUNGO1lBQ0YsUUFBUSxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQztRQUN4QjtRQUNBLFlBQVksSUFBSSxVQUFVLE9BQU8sY0FBYztRQUMvQyxZQUFZLENBQUMsSUFBSSxHQUFHO1FBQ3BCLE9BQU8sT0FBTyxTQUFTLFFBQVEsS0FBSyxJQUFJLENBQUMsUUFBUSxLQUFLLEdBQUcsU0FBUztRQUNsRSxJQUNFLFlBQVksQ0FBQyxFQUFFLEtBQUssc0JBQ3BCLGFBQWEsT0FBTyxRQUFRLEtBQUssSUFDakMsU0FBUyxRQUFRLEtBQUssSUFDdEIsUUFBUSxLQUFLLENBQUMsUUFBUSxLQUFLLG9CQUUzQixPQUFTLEFBQUMsZUFBZSxRQUFRLEtBQUssRUFBRztZQUN2QyxLQUFLO2dCQUNILGFBQWEsS0FBSyxHQUFHO2dCQUNyQjtZQUNGLEtBQUs7Z0JBQ0gsYUFBYSxNQUFNLEdBQUc7Z0JBQ3RCO1lBQ0YsS0FBSztnQkFDSCxhQUFhLFdBQVcsR0FBRztRQUMvQjtRQUNGLFFBQVEsSUFBSTtRQUNaLE1BQU0sUUFBUSxJQUFJLElBQ2hCLENBQUMsQUFBQyxNQUFNLFFBQVEsS0FBSyxFQUNyQixTQUFTLE9BQ1AsY0FBYyxJQUFJLE1BQU0sSUFDeEIsQ0FBQyxBQUFDLGVBQWUsSUFBSSxLQUFLLEVBQ3pCLElBQUksTUFBTSxHQUFHLGFBQ2IsSUFBSSxLQUFLLEdBQUcsUUFBUSxLQUFLLEVBQzFCLFNBQVMsZ0JBQWdCLFVBQVUsY0FBYyxRQUFRLEtBQUssQ0FBQyxDQUFDO0lBQ3RFO0lBQ0EsU0FBUyxnQkFBZ0IsU0FBUyxFQUFFLEtBQUs7UUFDdkMsSUFBSSxVQUFVLFVBQVUsT0FBTztRQUMvQixZQUFZLFVBQVUsUUFBUTtRQUM5QixJQUFJLENBQUMsUUFBUSxPQUFPLEVBQUU7WUFDcEIsSUFBSSxlQUFlLFFBQVEsS0FBSztZQUNoQyxRQUFRLE9BQU8sR0FBRyxDQUFDO1lBQ25CLFFBQVEsS0FBSyxHQUFHO1lBQ2hCLFVBQVUsUUFBUSxLQUFLO1lBQ3ZCLElBQUksU0FBUyxXQUFXLGNBQWMsUUFBUSxNQUFNLEVBQUU7Z0JBQ3BELElBQ0UsYUFBYSxPQUFPLGdCQUNwQixTQUFTLGdCQUNULGFBQWEsUUFBUSxLQUFLLG9CQUMxQjtvQkFDQSxJQUFJLG1CQUFtQjt3QkFDckIsTUFBTSx5QkFBeUIsYUFBYSxJQUFJLEtBQUs7d0JBQ3JELE9BQU8sYUFBYSxNQUFNO29CQUM1QjtvQkFDQSxpQkFBaUIsVUFBVSxHQUFHLGFBQWEsV0FBVztvQkFDdEQsc0JBQ0UsQ0FBQyxpQkFBaUIsU0FBUyxHQUFHLGFBQWEsVUFBVTtvQkFDdkQsQ0FBQyxRQUFRLFVBQVUsSUFBSSxDQUFDLFFBQVEsVUFBVSxHQUFHLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FDcEQ7Z0JBRUo7Z0JBQ0Esb0JBQW9CLFdBQVcsU0FBUztZQUMxQztRQUNGO0lBQ0Y7SUFDQSxTQUFTLGlCQUNQLGVBQWUsRUFDZixZQUFZLEVBQ1osR0FBRyxFQUNILFFBQVEsRUFDUixHQUFHLEVBQ0gsSUFBSTtRQUVKLElBQUkscUJBQXFCO1lBQ3ZCLElBQUksVUFBVTtZQUNkLFFBQVEsSUFBSTtRQUNkLE9BQ0UsVUFBVSxzQkFBc0I7WUFDOUIsUUFBUTtZQUNSLE9BQU87WUFDUCxPQUFPO1lBQ1AsTUFBTTtZQUNOLFNBQVMsQ0FBQztRQUNaO1FBQ0YsZUFBZTtZQUNiLFVBQVU7WUFDVixTQUFTO1lBQ1QsY0FBYztZQUNkLEtBQUs7WUFDTCxLQUFLO1lBQ0wsTUFBTTtRQUNSO1FBQ0EsU0FBUyxnQkFBZ0IsS0FBSyxHQUN6QixnQkFBZ0IsS0FBSyxHQUFHO1lBQUM7U0FBYSxHQUN2QyxnQkFBZ0IsS0FBSyxDQUFDLElBQUksQ0FBQztRQUMvQixTQUFTLGdCQUFnQixNQUFNLEdBQzFCLGdCQUFnQixNQUFNLEdBQUc7WUFBQztTQUFhLEdBQ3hDLGdCQUFnQixNQUFNLENBQUMsSUFBSSxDQUFDO1FBQ2hDLE9BQU87SUFDVDtJQUNBLFNBQVMsb0JBQW9CLFFBQVEsRUFBRSxRQUFRLEVBQUUsWUFBWSxFQUFFLEdBQUc7UUFDaEUsSUFBSSxDQUFDLFNBQVMsc0JBQXNCLEVBQ2xDLE9BQU8sMkJBQ0wsVUFDQSxTQUFTLFdBQVcsRUFDcEIsU0FBUyxpQkFBaUIsRUFDMUIsU0FBUyxzQkFBc0I7UUFFbkMsSUFBSSxrQkFBa0IsdUJBQ2xCLFNBQVMsc0JBQXNCLEVBQy9CLFNBQVMsRUFBRSxHQUViLFVBQVUsY0FBYztRQUMxQixJQUFJLFNBQ0YsU0FBUyxLQUFLLElBQUksQ0FBQyxVQUFVLFFBQVEsR0FBRyxDQUFDO1lBQUM7WUFBUyxTQUFTLEtBQUs7U0FBQyxDQUFDO2FBQ2hFLElBQUksU0FBUyxLQUFLLEVBQUUsVUFBVSxRQUFRLE9BQU8sQ0FBQyxTQUFTLEtBQUs7YUFFL0QsT0FDRSxBQUFDLFVBQVUsY0FBYyxrQkFDekIsNkJBQ0UsU0FDQSxTQUFTLEVBQUUsRUFDWCxTQUFTLEtBQUssRUFDZCxTQUFTLGlCQUFpQixHQUU1QjtRQUVKLElBQUkscUJBQXFCO1lBQ3ZCLElBQUksVUFBVTtZQUNkLFFBQVEsSUFBSTtRQUNkLE9BQ0UsVUFBVSxzQkFBc0I7WUFDOUIsUUFBUTtZQUNSLE9BQU87WUFDUCxPQUFPO1lBQ1AsTUFBTTtZQUNOLFNBQVMsQ0FBQztRQUNaO1FBQ0YsUUFBUSxJQUFJLENBQ1Y7WUFDRSxJQUFJLGdCQUFnQixjQUFjO1lBQ2xDLElBQUksU0FBUyxLQUFLLEVBQUU7Z0JBQ2xCLElBQUksWUFBWSxTQUFTLEtBQUssQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDO2dCQUMzQyxVQUFVLE9BQU8sQ0FBQztnQkFDbEIsZ0JBQWdCLGNBQWMsSUFBSSxDQUFDLEtBQUssQ0FBQyxlQUFlO1lBQzFEO1lBQ0EsNkJBQ0UsZUFDQSxTQUFTLEVBQUUsRUFDWCxTQUFTLEtBQUssRUFDZCxTQUFTLGlCQUFpQjtZQUU1QixZQUFZLENBQUMsSUFBSSxHQUFHO1lBQ3BCLE9BQU8sT0FDTCxTQUFTLFFBQVEsS0FBSyxJQUN0QixDQUFDLFFBQVEsS0FBSyxHQUFHLGFBQWE7WUFDaEMsSUFDRSxZQUFZLENBQUMsRUFBRSxLQUFLLHNCQUNwQixhQUFhLE9BQU8sUUFBUSxLQUFLLElBQ2pDLFNBQVMsUUFBUSxLQUFLLElBQ3RCLFFBQVEsS0FBSyxDQUFDLFFBQVEsS0FBSyxvQkFFM0IsT0FBUyxBQUFDLFlBQVksUUFBUSxLQUFLLEVBQUc7Z0JBQ3BDLEtBQUs7b0JBQ0gsVUFBVSxLQUFLLEdBQUc7b0JBQ2xCO2dCQUNGLEtBQUs7b0JBQ0gsVUFBVSxNQUFNLEdBQUc7WUFDdkI7WUFDRixRQUFRLElBQUk7WUFDWixNQUFNLFFBQVEsSUFBSSxJQUNoQixDQUFDLEFBQUMsZ0JBQWdCLFFBQVEsS0FBSyxFQUMvQixTQUFTLGlCQUNQLGNBQWMsY0FBYyxNQUFNLElBQ2xDLENBQUMsQUFBQyxZQUFZLGNBQWMsS0FBSyxFQUNoQyxjQUFjLE1BQU0sR0FBRyxhQUN2QixjQUFjLEtBQUssR0FBRyxRQUFRLEtBQUssRUFDcEMsU0FBUyxhQUFhLFVBQVUsV0FBVyxRQUFRLEtBQUssQ0FBQyxDQUFDO1FBQ2hFLEdBQ0EsU0FBVSxLQUFLO1lBQ2IsSUFBSSxDQUFDLFFBQVEsT0FBTyxFQUFFO2dCQUNwQixJQUFJLGVBQWUsUUFBUSxLQUFLO2dCQUNoQyxRQUFRLE9BQU8sR0FBRyxDQUFDO2dCQUNuQixRQUFRLEtBQUssR0FBRztnQkFDaEIsSUFBSSxRQUFRLFFBQVEsS0FBSztnQkFDekIsSUFBSSxTQUFTLFNBQVMsY0FBYyxNQUFNLE1BQU0sRUFBRTtvQkFDaEQsSUFDRSxhQUFhLE9BQU8sZ0JBQ3BCLFNBQVMsZ0JBQ1QsYUFBYSxRQUFRLEtBQUssb0JBQzFCO3dCQUNBLElBQUksbUJBQW1COzRCQUNyQixNQUFNLHlCQUF5QixhQUFhLElBQUksS0FBSzs0QkFDckQsT0FBTyxhQUFhLE1BQU07d0JBQzVCO3dCQUNBLGlCQUFpQixVQUFVLEdBQUcsYUFBYSxXQUFXO3dCQUN0RCxzQkFDRSxDQUFDLGlCQUFpQixTQUFTLEdBQUcsYUFBYSxVQUFVO3dCQUN2RCxDQUFDLE1BQU0sVUFBVSxJQUFJLENBQUMsTUFBTSxVQUFVLEdBQUcsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUNoRDtvQkFFSjtvQkFDQSxvQkFBb0IsVUFBVSxPQUFPO2dCQUN2QztZQUNGO1FBQ0Y7UUFFRixPQUFPO0lBQ1Q7SUFDQSxTQUFTLGlCQUFpQixRQUFRLEVBQUUsU0FBUyxFQUFFLFlBQVksRUFBRSxHQUFHLEVBQUUsR0FBRztRQUNuRSxZQUFZLFVBQVUsS0FBSyxDQUFDO1FBQzVCLElBQUksS0FBSyxTQUFTLFNBQVMsQ0FBQyxFQUFFLEVBQUU7UUFDaEMsS0FBSyxTQUFTLFVBQVU7UUFDeEIsT0FBUSxHQUFHLE1BQU07WUFDZixLQUFLO2dCQUNILHFCQUFxQjtnQkFDckI7WUFDRixLQUFLO2dCQUNILHNCQUFzQjtRQUMxQjtRQUNBLE9BQVEsR0FBRyxNQUFNO1lBQ2YsS0FBSztnQkFDSCxJQUFLLElBQUksUUFBUSxHQUFHLEtBQUssRUFBRSxJQUFJLEdBQUcsSUFBSSxVQUFVLE1BQU0sRUFBRSxJQUFLO29CQUMzRCxNQUFPLE1BQU0sUUFBUSxLQUFLLGlCQUFtQjt3QkFDM0MsUUFBUSxNQUFNLFFBQVE7d0JBQ3RCLE9BQVEsTUFBTSxNQUFNOzRCQUNsQixLQUFLO2dDQUNILHFCQUFxQjtnQ0FDckI7NEJBQ0YsS0FBSztnQ0FDSCxzQkFBc0I7d0JBQzFCO3dCQUNBLE9BQVEsTUFBTSxNQUFNOzRCQUNsQixLQUFLO2dDQUNILFFBQVEsTUFBTSxLQUFLO2dDQUNuQjs0QkFDRixLQUFLOzRCQUNMLEtBQUs7Z0NBQ0gsT0FBTyxpQkFDTCxPQUNBLGNBQ0EsS0FDQSxVQUNBLEtBQ0EsVUFBVSxLQUFLLENBQUMsSUFBSTs0QkFFeEIsS0FBSztnQ0FDSCxPQUNFLHNCQUNJLENBQUMsQUFBQyxXQUFXLHFCQUFzQixTQUFTLElBQUksRUFBRSxJQUNqRCxzQkFBc0I7b0NBQ3JCLFFBQVE7b0NBQ1IsT0FBTztvQ0FDUCxPQUFPO29DQUNQLE1BQU07b0NBQ04sU0FBUyxDQUFDO2dDQUNaLEdBQ0o7NEJBRUo7Z0NBQ0UsT0FDRSxzQkFDSSxDQUFDLEFBQUMsb0JBQW9CLE9BQU8sR0FBRyxDQUFDLEdBQ2hDLG9CQUFvQixLQUFLLEdBQUcsTUFBTSxNQUFNLEFBQUMsSUFDekMsc0JBQXNCO29DQUNyQixRQUFRO29DQUNSLE9BQU87b0NBQ1AsT0FBTyxNQUFNLE1BQU07b0NBQ25CLE1BQU07b0NBQ04sU0FBUyxDQUFDO2dDQUNaLEdBQ0o7d0JBRU47b0JBQ0Y7b0JBQ0EsUUFBUSxLQUFLLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQztnQkFDN0I7Z0JBQ0EsV0FBVyxJQUFJLFVBQVUsT0FBTyxjQUFjO2dCQUM5QyxHQUFHLFVBQVUsSUFDWCxDQUFDLGFBQWEsT0FBTyxZQUNuQixTQUFTLFlBQ1IsQ0FBQyxZQUFZLGFBQ1osZUFBZSxPQUFPLFFBQVEsQ0FBQyxlQUFlLElBQzlDLFNBQVMsUUFBUSxLQUFLLHNCQUN4QixTQUFTLFVBQVUsSUFDbkIsT0FBTyxjQUFjLENBQUMsVUFBVSxjQUFjO29CQUM1QyxjQUFjLENBQUM7b0JBQ2YsWUFBWSxDQUFDO29CQUNiLFVBQVUsQ0FBQztvQkFDWCxPQUFPLEdBQUcsVUFBVTtnQkFDdEIsRUFBRTtnQkFDTixPQUFPO1lBQ1QsS0FBSztZQUNMLEtBQUs7Z0JBQ0gsT0FBTyxpQkFDTCxJQUNBLGNBQ0EsS0FDQSxVQUNBLEtBQ0E7WUFFSixLQUFLO2dCQUNILE9BQ0Usc0JBQ0ksQ0FBQyxBQUFDLFdBQVcscUJBQXNCLFNBQVMsSUFBSSxFQUFFLElBQ2pELHNCQUFzQjtvQkFDckIsUUFBUTtvQkFDUixPQUFPO29CQUNQLE9BQU87b0JBQ1AsTUFBTTtvQkFDTixTQUFTLENBQUM7Z0JBQ1osR0FDSjtZQUVKO2dCQUNFLE9BQ0Usc0JBQ0ksQ0FBQyxBQUFDLG9CQUFvQixPQUFPLEdBQUcsQ0FBQyxHQUNoQyxvQkFBb0IsS0FBSyxHQUFHLEdBQUcsTUFBTSxBQUFDLElBQ3RDLHNCQUFzQjtvQkFDckIsUUFBUTtvQkFDUixPQUFPO29CQUNQLE9BQU8sR0FBRyxNQUFNO29CQUNoQixNQUFNO29CQUNOLFNBQVMsQ0FBQztnQkFDWixHQUNKO1FBRU47SUFDRjtJQUNBLFNBQVMsVUFBVSxRQUFRLEVBQUUsS0FBSztRQUNoQyxPQUFPLElBQUksSUFBSTtJQUNqQjtJQUNBLFNBQVMsVUFBVSxRQUFRLEVBQUUsS0FBSztRQUNoQyxPQUFPLElBQUksSUFBSTtJQUNqQjtJQUNBLFNBQVMsV0FBVyxRQUFRLEVBQUUsS0FBSztRQUNqQyxPQUFPLElBQUksS0FBSyxNQUFNLEtBQUssQ0FBQyxJQUFJO1lBQUUsTUFBTSxLQUFLLENBQUMsRUFBRTtRQUFDO0lBQ25EO0lBQ0EsU0FBUyxlQUFlLFFBQVEsRUFBRSxLQUFLO1FBQ3JDLFdBQVcsSUFBSTtRQUNmLElBQUssSUFBSSxJQUFJLEdBQUcsSUFBSSxNQUFNLE1BQU0sRUFBRSxJQUNoQyxTQUFTLE1BQU0sQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxLQUFLLENBQUMsRUFBRSxDQUFDLEVBQUU7UUFDMUMsT0FBTztJQUNUO0lBQ0EsU0FBUyxpQkFBaUIsUUFBUSxFQUFFLEtBQUssRUFBRSxZQUFZO1FBQ3JELE9BQU8sY0FBYyxDQUFDLGNBQWMsTUFBTSxTQUFTO0lBQ3JEO0lBQ0EsU0FBUyxpQkFBaUIsUUFBUSxFQUFFLEtBQUssRUFBRSxZQUFZLEVBQUUsR0FBRztRQUMxRCxPQUFPLGNBQWMsQ0FBQyxjQUFjLEtBQUs7WUFDdkMsS0FBSztnQkFDSCxxQkFBcUIsTUFBTSxNQUFNLElBQUkscUJBQXFCO2dCQUMxRCxPQUFRLE1BQU0sTUFBTTtvQkFDbEIsS0FBSzt3QkFDSCxPQUFPLE1BQU0sS0FBSztvQkFDcEIsS0FBSzt3QkFDSCxNQUFNLE1BQU0sTUFBTTtnQkFDdEI7Z0JBQ0EsT0FBTztZQUNUO1lBQ0EsWUFBWSxDQUFDO1lBQ2IsY0FBYyxDQUFDO1FBQ2pCO1FBQ0EsT0FBTztJQUNUO0lBQ0EsU0FBUyxnQkFBZ0IsUUFBUSxFQUFFLEtBQUs7UUFDdEMsT0FBTyxLQUFLLENBQUMsT0FBTyxRQUFRLENBQUM7SUFDL0I7SUFDQSxTQUFTLFlBQVksUUFBUSxFQUFFLEtBQUs7UUFDbEMsT0FBTztJQUNUO0lBQ0EsU0FBUyxpQkFBaUIsUUFBUSxFQUFFLFlBQVksRUFBRSxHQUFHLEVBQUUsS0FBSztRQUMxRCxJQUFJLFFBQVEsS0FBSyxDQUFDLEVBQUUsRUFBRTtZQUNwQixJQUFJLFFBQVEsT0FDVixPQUNFLFNBQVMsdUJBQ1AsUUFBUSxPQUNSLENBQUMsc0JBQXNCO2dCQUNyQixRQUFRO2dCQUNSLE9BQU87Z0JBQ1AsT0FBTztnQkFDUCxNQUFNO2dCQUNOLFNBQVMsQ0FBQztZQUNaLENBQUMsR0FDSDtZQUVKLE9BQVEsS0FBSyxDQUFDLEVBQUU7Z0JBQ2QsS0FBSztvQkFDSCxPQUFPLE1BQU0sS0FBSyxDQUFDO2dCQUNyQixLQUFLO29CQUNILE9BQ0UsQUFBQyxlQUFlLFNBQVMsTUFBTSxLQUFLLENBQUMsSUFBSSxLQUN4QyxXQUFXLFNBQVMsVUFBVSxlQUMvQix1QkFBdUI7Z0JBRTNCLEtBQUs7b0JBQ0gsT0FDRSxBQUFDLGVBQWUsU0FBUyxNQUFNLEtBQUssQ0FBQyxJQUFJLEtBQ3pDLFNBQVMsVUFBVTtnQkFFdkIsS0FBSztvQkFDSCxPQUFPLE9BQU8sR0FBRyxDQUFDLE1BQU0sS0FBSyxDQUFDO2dCQUNoQyxLQUFLO29CQUNILElBQUksTUFBTSxNQUFNLEtBQUssQ0FBQztvQkFDdEIsT0FBTyxpQkFDTCxVQUNBLEtBQ0EsY0FDQSxLQUNBO2dCQUVKLEtBQUs7b0JBQ0gsZUFBZSxNQUFNLE1BQU0sS0FBSyxDQUFDO29CQUNqQyxXQUFXLFNBQVMsU0FBUztvQkFDN0IsSUFBSSxRQUFRLFVBQ1YsTUFBTSxNQUNKO29CQUVKLE9BQU8sU0FBUyxHQUFHLENBQUM7Z0JBQ3RCLEtBQUs7b0JBQ0gsT0FDRSxBQUFDLE1BQU0sTUFBTSxLQUFLLENBQUMsSUFDbkIsaUJBQWlCLFVBQVUsS0FBSyxjQUFjLEtBQUs7Z0JBRXZELEtBQUs7b0JBQ0gsT0FDRSxBQUFDLE1BQU0sTUFBTSxLQUFLLENBQUMsSUFDbkIsaUJBQWlCLFVBQVUsS0FBSyxjQUFjLEtBQUs7Z0JBRXZELEtBQUs7b0JBQ0gsT0FDRSxBQUFDLE1BQU0sTUFBTSxLQUFLLENBQUMsSUFDbkIsaUJBQWlCLFVBQVUsS0FBSyxjQUFjLEtBQUs7Z0JBRXZELEtBQUs7b0JBQ0gsT0FDRSxBQUFDLE1BQU0sTUFBTSxLQUFLLENBQUMsSUFDbkIsaUJBQWlCLFVBQVUsS0FBSyxjQUFjLEtBQUs7Z0JBRXZELEtBQUs7b0JBQ0gsT0FDRSxBQUFDLE1BQU0sTUFBTSxLQUFLLENBQUMsSUFDbkIsaUJBQ0UsVUFDQSxLQUNBLGNBQ0EsS0FDQTtnQkFHTixLQUFLO29CQUNILE9BQ0UsQUFBQyxNQUFNLE1BQU0sS0FBSyxDQUFDLElBQ25CLGlCQUNFLFVBQ0EsS0FDQSxjQUNBLEtBQ0E7Z0JBR04sS0FBSztvQkFDSCxPQUFPO2dCQUNULEtBQUs7b0JBQ0gsT0FBTyxVQUFVLFFBQVEsQ0FBQyxJQUFJLENBQUM7Z0JBQ2pDLEtBQUs7b0JBQ0gsT0FBTztnQkFDVCxLQUFLO29CQUNIO2dCQUNGLEtBQUs7b0JBQ0gsT0FBTyxJQUFJLEtBQUssS0FBSyxLQUFLLENBQUMsTUFBTSxLQUFLLENBQUM7Z0JBQ3pDLEtBQUs7b0JBQ0gsT0FBTyxPQUFPLE1BQU0sS0FBSyxDQUFDO2dCQUM1QixLQUFLO29CQUNILE9BQ0UsQUFBQyxNQUFNLE1BQU0sS0FBSyxDQUFDLElBQ25CLGlCQUNFLFVBQ0EsS0FDQSxjQUNBLEtBQ0E7Z0JBR04sS0FBSztvQkFDSCxXQUFXLE1BQU0sS0FBSyxDQUFDO29CQUN2QixJQUFJO3dCQUNGLE9BQU8sQ0FBQyxHQUFHLElBQUksRUFBRTtvQkFDbkIsRUFBRSxPQUFPLEdBQUc7d0JBQ1YsSUFBSSxTQUFTLFVBQVUsQ0FBQyxvQkFBb0I7NEJBQzFDLElBQ0csQUFBQyxlQUFlLFNBQVMsT0FBTyxDQUFDLEtBQUssS0FDdkMsQ0FBQyxNQUFNLGNBRVAsT0FDRSxBQUFDLFdBQVcsU0FBUyxLQUFLLENBQUMsSUFBSSxjQUFjLElBQUksSUFDakQsQ0FBQyxHQUFHLElBQUksRUFDTixPQUFPLEtBQUssU0FBUyxDQUFDLFlBQVksd0JBQ25DLENBQUMsU0FBUzt3QkFFakIsT0FBTyxJQUFJLFNBQVMsVUFBVSxDQUFDLGNBQWM7NEJBQzNDLElBQ0csQUFBQyxlQUFlLFNBQVMsT0FBTyxDQUFDLEtBQUssSUFDdkMsQ0FBQyxNQUFNLGNBRVAsT0FDRSxBQUFDLFdBQVcsU0FBUyxLQUFLLENBQUMsR0FBRyxjQUFjLElBQUksSUFDaEQsQ0FBQyxHQUFHLElBQUksRUFDTixPQUFPLEtBQUssU0FBUyxDQUFDLFlBQVksa0JBQ25DLENBQUMsU0FBUzt3QkFFakIsT0FBTyxJQUNMLFNBQVMsVUFBVSxDQUFDLGFBQ3BCLENBQUMsQUFBQyxlQUFlLFNBQVMsT0FBTyxDQUFDLEtBQUssSUFBSyxDQUFDLE1BQU0sWUFBWSxHQUUvRCxPQUNFLEFBQUMsV0FBVyxTQUFTLEtBQUssQ0FBQyxHQUFHLGNBQWMsSUFBSSxJQUNoRCxDQUFDLEdBQUcsSUFBSSxFQUFFLE9BQU8sS0FBSyxTQUFTLENBQUMsWUFBWSxhQUFhLENBQ3ZELFNBQ0Q7d0JBRUwsT0FBTyxZQUFhO29CQUN0QjtnQkFDRixLQUFLO29CQUNILElBQUksSUFBSSxNQUFNLE1BQU0sSUFBSSxDQUFDLE1BQU0sU0FBUyxhQUFhLEdBQUc7d0JBQ3RELElBQUksUUFBUSxLQUFLLENBQUMsRUFBRSxFQUNsQixPQUNFLEFBQUMsZUFBZSxNQUFNLEtBQUssQ0FBQyxJQUMzQixNQUFNLFNBQVMsY0FBYyxLQUM5QixTQUFTLE9BQU8sQ0FBQyxHQUFHLENBQUMsUUFBUSxJQUFJLE9BQU8sZUFDeEMsU0FBUyxVQUFVO3dCQUV2QixRQUFRLE1BQU0sS0FBSyxDQUFDO3dCQUNwQixJQUFJLE9BQU8sU0FBUyxPQUFPO3dCQUMzQixTQUFTLE9BQU8sQ0FBQyxHQUFHLENBQUMsU0FBUyxJQUFJLE9BQU87d0JBQ3pDLE1BQU0sU0FBUyxVQUFVO3dCQUN6QixPQUFPLGdCQUFnQixJQUFJLE1BQU0sR0FDN0IsSUFBSSxLQUFLLEdBQ1QsaUJBQWlCLFVBQVUsS0FBSyxjQUFjO29CQUNwRDtvQkFDQSxPQUFPLGNBQWMsQ0FBQyxjQUFjLEtBQUs7d0JBQ3ZDLEtBQUs7NEJBQ0gsT0FBTzt3QkFDVDt3QkFDQSxZQUFZLENBQUM7d0JBQ2IsY0FBYyxDQUFDO29CQUNqQjtvQkFDQSxPQUFPO2dCQUNUO29CQUNFLE9BQ0UsQUFBQyxNQUFNLE1BQU0sS0FBSyxDQUFDLElBQ25CLGlCQUFpQixVQUFVLEtBQUssY0FBYyxLQUFLO1lBRXpEO1FBQ0Y7UUFDQSxPQUFPO0lBQ1Q7SUFDQSxTQUFTO1FBQ1AsTUFBTSxNQUNKO0lBRUo7SUFDQSxTQUFTLGlCQUNQLGFBQWEsRUFDYixxQkFBcUIsRUFDckIsYUFBYSxFQUNiLFVBQVUsRUFDVixnQkFBZ0IsRUFDaEIsS0FBSyxFQUNMLG1CQUFtQixFQUNuQixnQkFBZ0IsRUFDaEIsYUFBYSxFQUNiLGVBQWUsRUFDZixZQUFZO1FBRVosSUFBSSxTQUFTLElBQUk7UUFDakIsSUFBSSxDQUFDLGNBQWMsR0FBRztRQUN0QixJQUFJLENBQUMsc0JBQXNCLEdBQUc7UUFDOUIsSUFBSSxDQUFDLGNBQWMsR0FBRztRQUN0QixJQUFJLENBQUMsV0FBVyxHQUFHLEtBQUssTUFBTSxhQUFhLGFBQWE7UUFDeEQsSUFBSSxDQUFDLGlCQUFpQixHQUFHO1FBQ3pCLElBQUksQ0FBQyxNQUFNLEdBQUc7UUFDZCxJQUFJLENBQUMsT0FBTyxHQUFHO1FBQ2YsSUFBSSxDQUFDLGNBQWMsR0FBRyxJQUFJLEtBQUssV0FBVztRQUMxQyxJQUFJLENBQUMsU0FBUyxHQUFHO1FBQ2pCLElBQUksQ0FBQyxPQUFPLEdBQUcsQ0FBQztRQUNoQixJQUFJLENBQUMsYUFBYSxHQUFHO1FBQ3JCLElBQUksQ0FBQyxTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDLGNBQWMsR0FBRztRQUN0QixJQUFJLENBQUMsYUFBYSxHQUFHO1lBQUUsTUFBTSxJQUFJLFFBQVEsSUFBSTtZQUFHLFVBQVUsSUFBSTtRQUFDO1FBQy9ELElBQUksQ0FBQyxlQUFlLEdBQUcsZ0JBQ3JCLEtBQUssTUFBTSw2QkFDWCxTQUFTLDBCQUEwQixDQUFDLEdBQ2hDLE9BQ0EsMEJBQTBCLENBQUMsQ0FBQyxRQUFRO1FBQzFDLElBQUksQ0FBQyxlQUFlLEdBQ2xCLFNBQVMsZ0JBQWdCLE1BQU0sMkJBQTJCO1FBQzVELGtCQUFrQixLQUFLLE1BQU0sa0JBQWtCLFdBQVc7UUFDMUQsc0JBQ0UsQ0FBQyxJQUFJLENBQUMsY0FBYyxHQUFHLFFBQVEsVUFBVSxDQUN2QyxVQUFVLGdCQUFnQixXQUFXLEtBQUssSUFDM0M7UUFDSCxJQUFJLENBQUMsc0JBQXNCLEdBQUc7UUFDOUIsSUFBSSxDQUFDLGFBQWEsR0FBRztRQUNyQixJQUFJLENBQUMsY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQyxvQkFBb0IsR0FBRztRQUM1QixnQkFDRSxDQUFDLFNBQVMsdUJBQ04sQ0FBQyxhQUFhLEtBQU0sSUFBSSxDQUFDLGFBQWEsR0FBRyxLQUFLLENBQUUsSUFDaEQscUJBQXFCLFFBQVEsQ0FBQyxJQUFJLEVBQUUsYUFBYTtRQUN2RCxJQUFJLENBQUMsU0FBUyxHQUFHLHVCQUF1QixJQUFJO0lBQzlDO0lBQ0EsU0FBUztRQUNQLE9BQU87WUFDTCxXQUFXO1lBQ1gsUUFBUTtZQUNSLFNBQVM7WUFDVCxZQUFZO1lBQ1osU0FBUyxFQUFFO1FBQ2I7SUFDRjtJQUNBLFNBQVMsaUJBQWlCLFFBQVEsRUFBRSxFQUFFO1FBQ3BDLElBQUksU0FBUyxTQUFTLE9BQU8sRUFDM0IsUUFBUSxPQUFPLEdBQUcsQ0FBQztRQUNyQixTQUFTLE9BQU8sR0FBRyxDQUFDLElBQUssUUFBUSxtQkFBbUI7UUFDcEQsSUFBSSxjQUFjLE1BQU0sTUFBTSxJQUFJLGNBQWMsTUFBTSxNQUFNLEVBQzFELG9CQUFvQixVQUFVLFFBQzNCLFdBQVcsT0FDWCxTQUFTLE1BQU0sR0FBRyxVQUNsQixTQUFTLEtBQUssR0FBRyxNQUNqQixTQUFTLE1BQU0sR0FBRztJQUN6QjtJQUNBLFNBQVMsYUFBYSxRQUFRLEVBQUUsRUFBRSxFQUFFLEtBQUs7UUFDdkMsSUFBSSxTQUFTLFNBQVMsT0FBTyxFQUMzQixRQUFRLE9BQU8sR0FBRyxDQUFDO1FBQ3JCLFFBQ0ksa0JBQWtCLFVBQVUsT0FBTyxTQUNuQyxPQUFPLEdBQUcsQ0FBQyxJQUFJLElBQUksYUFBYSxrQkFBa0IsT0FBTztJQUMvRDtJQUNBLFNBQVMsWUFBWSxRQUFRLEVBQUUsRUFBRSxFQUFFLElBQUk7UUFDckMsSUFBSSxTQUFTLFNBQVMsT0FBTyxFQUMzQixRQUFRLE9BQU8sR0FBRyxDQUFDO1FBQ3JCLFNBQVMsY0FBYyxNQUFNLE1BQU0sR0FDL0IsTUFBTSxNQUFNLENBQUMsWUFBWSxDQUFDLFFBQzFCLENBQUMsU0FBUyxvQkFBb0IsVUFBVSxRQUN4QyxPQUFPLEdBQUcsQ0FBQyxJQUFJLElBQUksYUFBYSxhQUFhLE1BQU0sTUFBTTtJQUMvRDtJQUNBLFNBQVMsY0FBYyxRQUFRLEVBQUUsRUFBRSxFQUFFLE1BQU07UUFDekMsSUFBSSxTQUFTLFNBQVMsT0FBTyxFQUMzQixRQUFRLE9BQU8sR0FBRyxDQUFDO1FBQ3JCLFNBQVMsY0FBYyxNQUFNLE1BQU0sR0FDL0IsTUFBTSxNQUFNLENBQUMsWUFBWSxDQUFDLFVBQzFCLENBQUMsU0FBUyxvQkFBb0IsVUFBVSxRQUN4QyxPQUFPLEdBQUcsQ0FBQyxJQUFJLElBQUksYUFBYSxhQUFhLFFBQVEsTUFBTTtJQUNqRTtJQUNBLFNBQVMsY0FBYyxRQUFRLEVBQUUsRUFBRSxFQUFFLEtBQUs7UUFDeEMsSUFBSSxTQUFTLFNBQVMsT0FBTyxFQUMzQixRQUFRLE9BQU8sR0FBRyxDQUFDO1FBQ3JCLFFBQVEsS0FBSyxLQUFLLENBQUMsT0FBTyxTQUFTLFNBQVM7UUFDNUMsSUFBSSxrQkFBa0IsdUJBQ3BCLFNBQVMsY0FBYyxFQUN2QjtRQUVGLDZCQUNFLFNBQVMsY0FBYyxFQUN2QixLQUFLLENBQUMsRUFBRSxFQUNSLFNBQVMsTUFBTTtRQUVqQixJQUFLLFFBQVEsY0FBYyxrQkFBbUI7WUFDNUMsSUFBSSxPQUFPO2dCQUNULG9CQUFvQixVQUFVO2dCQUM5QixJQUFJLGVBQWU7Z0JBQ25CLGFBQWEsTUFBTSxHQUFHO1lBQ3hCLE9BQ0UsQUFBQyxlQUFlLElBQUksYUFBYSxXQUFXLE1BQU0sT0FDaEQsT0FBTyxHQUFHLENBQUMsSUFBSTtZQUNuQixNQUFNLElBQUksQ0FDUjtnQkFDRSxPQUFPLG1CQUFtQixVQUFVLGNBQWM7WUFDcEQsR0FDQSxTQUFVLEtBQUs7Z0JBQ2IsT0FBTyxvQkFBb0IsVUFBVSxjQUFjO1lBQ3JEO1FBRUosT0FDRSxRQUNJLG1CQUFtQixVQUFVLE9BQU8sbUJBQ3BDLE9BQU8sR0FBRyxDQUNSLElBQ0EsSUFBSSxhQUFhLG1CQUFtQixpQkFBaUI7SUFFL0Q7SUFDQSxTQUFTLGNBQWMsUUFBUSxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsVUFBVTtRQUNyRCxJQUFJLFNBQVMsU0FBUyxPQUFPLEVBQzNCLFFBQVEsT0FBTyxHQUFHLENBQUM7UUFDckIsUUFDSSxjQUFjLE1BQU0sTUFBTSxJQUMxQixDQUFDLG9CQUFvQixVQUFVLFFBQzlCLFdBQVcsTUFBTSxLQUFLLEVBQ3RCLE1BQU0sTUFBTSxHQUFHLGFBQ2YsTUFBTSxLQUFLLEdBQUcsUUFDZCxNQUFNLE1BQU0sR0FBRyxZQUNoQixTQUFTLFlBQVksVUFBVSxVQUFVLE1BQU0sS0FBSyxDQUFDLElBQ3JELE9BQU8sR0FBRyxDQUFDLElBQUksSUFBSSxhQUFhLGFBQWEsUUFBUTtJQUMzRDtJQUNBLFNBQVMsb0JBQW9CLFFBQVEsRUFBRSxFQUFFLEVBQUUsSUFBSTtRQUM3QyxJQUFJLGFBQWE7UUFDakIsT0FBTyxJQUFJLGVBQWU7WUFDeEIsTUFBTTtZQUNOLE9BQU8sU0FBVSxDQUFDO2dCQUNoQixhQUFhO1lBQ2Y7UUFDRjtRQUNBLElBQUksdUJBQXVCO1FBQzNCLGNBQWMsVUFBVSxJQUFJLE1BQU07WUFDaEMsY0FBYyxTQUFVLEtBQUs7Z0JBQzNCLFNBQVMsdUJBQ0wsV0FBVyxPQUFPLENBQUMsU0FDbkIscUJBQXFCLElBQUksQ0FBQztvQkFDeEIsV0FBVyxPQUFPLENBQUM7Z0JBQ3JCO1lBQ047WUFDQSxjQUFjLFNBQVUsSUFBSTtnQkFDMUIsSUFBSSxTQUFTLHNCQUFzQjtvQkFDakMsSUFBSSxRQUFRLElBQUksYUFBYSxrQkFBa0IsTUFBTTtvQkFDckQscUJBQXFCO29CQUNyQixnQkFBZ0IsTUFBTSxNQUFNLEdBQ3hCLFdBQVcsT0FBTyxDQUFDLE1BQU0sS0FBSyxJQUM5QixDQUFDLE1BQU0sSUFBSSxDQUNULFNBQVUsQ0FBQzt3QkFDVCxPQUFPLFdBQVcsT0FBTyxDQUFDO29CQUM1QixHQUNBLFNBQVUsQ0FBQzt3QkFDVCxPQUFPLFdBQVcsS0FBSyxDQUFDO29CQUMxQixJQUVELHVCQUF1QixLQUFNO2dCQUNwQyxPQUFPO29CQUNMLFFBQVE7b0JBQ1IsSUFBSSxVQUFVLG1CQUFtQjtvQkFDakMsUUFBUSxJQUFJLENBQ1YsU0FBVSxDQUFDO3dCQUNULE9BQU8sV0FBVyxPQUFPLENBQUM7b0JBQzVCLEdBQ0EsU0FBVSxDQUFDO3dCQUNULE9BQU8sV0FBVyxLQUFLLENBQUM7b0JBQzFCO29CQUVGLHVCQUF1QjtvQkFDdkIsTUFBTSxJQUFJLENBQUM7d0JBQ1QseUJBQXlCLFdBQVcsQ0FBQyx1QkFBdUIsSUFBSTt3QkFDaEUsa0JBQWtCLFVBQVUsU0FBUztvQkFDdkM7Z0JBQ0Y7WUFDRjtZQUNBLE9BQU87Z0JBQ0wsSUFBSSxTQUFTLHNCQUFzQixXQUFXLEtBQUs7cUJBQzlDO29CQUNILElBQUksZUFBZTtvQkFDbkIsdUJBQXVCO29CQUN2QixhQUFhLElBQUksQ0FBQzt3QkFDaEIsT0FBTyxXQUFXLEtBQUs7b0JBQ3pCO2dCQUNGO1lBQ0Y7WUFDQSxPQUFPLFNBQVUsS0FBSztnQkFDcEIsSUFBSSxTQUFTLHNCQUFzQixXQUFXLEtBQUssQ0FBQztxQkFDL0M7b0JBQ0gsSUFBSSxlQUFlO29CQUNuQix1QkFBdUI7b0JBQ3ZCLGFBQWEsSUFBSSxDQUFDO3dCQUNoQixPQUFPLFdBQVcsS0FBSyxDQUFDO29CQUMxQjtnQkFDRjtZQUNGO1FBQ0Y7SUFDRjtJQUNBLFNBQVM7UUFDUCxPQUFPLElBQUk7SUFDYjtJQUNBLFNBQVMsZUFBZSxJQUFJO1FBQzFCLE9BQU87WUFBRSxNQUFNO1FBQUs7UUFDcEIsSUFBSSxDQUFDLGVBQWUsR0FBRztRQUN2QixPQUFPO0lBQ1Q7SUFDQSxTQUFTLG1CQUFtQixRQUFRLEVBQUUsRUFBRSxFQUFFLFFBQVE7UUFDaEQsSUFBSSxTQUFTLEVBQUUsRUFDYixTQUFTLENBQUMsR0FDVixpQkFBaUIsR0FDakIsV0FBVyxDQUFDO1FBQ2QsUUFBUSxDQUFDLGVBQWUsR0FBRztZQUN6QixJQUFJLGdCQUFnQjtZQUNwQixPQUFPLGVBQWUsU0FBVSxHQUFHO2dCQUNqQyxJQUFJLEtBQUssTUFBTSxLQUNiLE1BQU0sTUFDSjtnQkFFSixJQUFJLGtCQUFrQixPQUFPLE1BQU0sRUFBRTtvQkFDbkMsSUFBSSxRQUNGLE9BQU8sSUFBSSxhQUNULGFBQ0E7d0JBQUUsTUFBTSxDQUFDO3dCQUFHLE9BQU8sS0FBSztvQkFBRSxHQUMxQjtvQkFFSixNQUFNLENBQUMsY0FBYyxHQUFHLG1CQUFtQjtnQkFDN0M7Z0JBQ0EsT0FBTyxNQUFNLENBQUMsZ0JBQWdCO1lBQ2hDO1FBQ0Y7UUFDQSxjQUNFLFVBQ0EsSUFDQSxXQUFXLFFBQVEsQ0FBQyxlQUFlLEtBQUssVUFDeEM7WUFDRSxjQUFjLFNBQVUsS0FBSztnQkFDM0IsSUFBSSxtQkFBbUIsT0FBTyxNQUFNLEVBQ2xDLE1BQU0sQ0FBQyxlQUFlLEdBQUcsSUFBSSxhQUMzQixhQUNBO29CQUFFLE1BQU0sQ0FBQztvQkFBRyxPQUFPO2dCQUFNLEdBQ3pCO3FCQUVDO29CQUNILElBQUksUUFBUSxNQUFNLENBQUMsZUFBZSxFQUNoQyxtQkFBbUIsTUFBTSxLQUFLLEVBQzlCLGtCQUFrQixNQUFNLE1BQU07b0JBQ2hDLE1BQU0sTUFBTSxHQUFHO29CQUNmLE1BQU0sS0FBSyxHQUFHO3dCQUFFLE1BQU0sQ0FBQzt3QkFBRyxPQUFPO29CQUFNO29CQUN2QyxTQUFTLG9CQUNQLHVCQUNFLE9BQ0Esa0JBQ0E7Z0JBRU47Z0JBQ0E7WUFDRjtZQUNBLGNBQWMsU0FBVSxLQUFLO2dCQUMzQixtQkFBbUIsT0FBTyxNQUFNLEdBQzNCLE1BQU0sQ0FBQyxlQUFlLEdBQUcsa0NBQ3hCLFVBQ0EsT0FDQSxDQUFDLEtBRUgsMkJBQ0UsVUFDQSxNQUFNLENBQUMsZUFBZSxFQUN0QixPQUNBLENBQUM7Z0JBRVA7WUFDRjtZQUNBLE9BQU8sU0FBVSxLQUFLO2dCQUNwQixTQUFTLENBQUM7Z0JBQ1YsbUJBQW1CLE9BQU8sTUFBTSxHQUMzQixNQUFNLENBQUMsZUFBZSxHQUFHLGtDQUN4QixVQUNBLE9BQ0EsQ0FBQyxLQUVILDJCQUNFLFVBQ0EsTUFBTSxDQUFDLGVBQWUsRUFDdEIsT0FDQSxDQUFDO2dCQUVQLElBQUssa0JBQWtCLGlCQUFpQixPQUFPLE1BQU0sRUFDbkQsMkJBQ0UsVUFDQSxNQUFNLENBQUMsaUJBQWlCLEVBQ3hCLGdCQUNBLENBQUM7WUFFUDtZQUNBLE9BQU8sU0FBVSxLQUFLO2dCQUNwQixTQUFTLENBQUM7Z0JBQ1YsSUFDRSxtQkFBbUIsT0FBTyxNQUFNLElBQ2hDLENBQUMsTUFBTSxDQUFDLGVBQWUsR0FBRyxtQkFBbUIsU0FBUyxHQUN0RCxpQkFBaUIsT0FBTyxNQUFNLEVBRzlCLG9CQUFvQixVQUFVLE1BQU0sQ0FBQyxpQkFBaUIsRUFBRTtZQUM1RDtRQUNGO0lBRUo7SUFDQSxTQUFTLFdBQVcsUUFBUSxFQUFFLEVBQUUsRUFBRSxHQUFHO1FBQ25DLENBQUMsV0FBVyxTQUFTLE9BQU8sQ0FBQyxHQUFHLENBQUMsR0FBRyxLQUNsQyxnQkFBZ0IsU0FBUyxNQUFNLElBQy9CLFNBQVMsTUFBTSxDQUFDLEtBQUssQ0FBQyxPQUFPLE1BQU0saUJBQWlCO0lBQ3hEO0lBQ0EsU0FBUyxnQkFBZ0IsUUFBUSxFQUFFLFNBQVM7UUFDMUMsSUFBSSxPQUFPLFVBQVUsSUFBSSxFQUN2QixNQUFNLFVBQVUsR0FBRztRQUNyQixZQUFZLG1CQUNWLFVBQ0EsVUFBVSxLQUFLLEVBQ2YsS0FDQSxDQUFDLEdBQ0QsTUFBTSxJQUFJLENBQ1IsTUFDQSxVQUFVLE9BQU8sSUFDZjtRQUdOLFdBQVcsWUFBWSxVQUFVO1FBQ2pDLFdBQVcsUUFBUSxXQUFXLFNBQVMsR0FBRyxDQUFDLGFBQWE7UUFDeEQsU0FBUyxJQUFJLEdBQUc7UUFDaEIsU0FBUyxlQUFlLEdBQUc7UUFDM0IsT0FBTztJQUNUO0lBQ0EsU0FBUyxZQUFZLFFBQVEsRUFBRSxJQUFJLEVBQUUsS0FBSztRQUN4QyxXQUFXLEtBQUssS0FBSyxDQUFDLE9BQU8sU0FBUyxTQUFTO1FBQy9DLFFBQVEsd0JBQXdCLENBQUM7UUFDakMsT0FBUTtZQUNOLEtBQUs7Z0JBQ0gsTUFBTSxDQUFDLENBQUM7Z0JBQ1I7WUFDRixLQUFLO2dCQUNILGFBQWEsT0FBTyxXQUNoQixNQUFNLENBQUMsQ0FBQyxZQUNSLE1BQU0sQ0FBQyxDQUFDLFFBQVEsQ0FBQyxFQUFFLEVBQUUsUUFBUSxDQUFDLEVBQUU7Z0JBQ3BDO1lBQ0YsS0FBSztnQkFDSCxPQUFPLFFBQVEsQ0FBQyxFQUFFO2dCQUNsQixJQUFJLEtBQUssUUFBUSxDQUFDLEVBQUU7Z0JBQ3BCLE1BQU0sU0FBUyxNQUFNLEdBQ2pCLE1BQU0sQ0FBQyxDQUFDLE1BQU0sSUFBSSxRQUFRLENBQUMsRUFBRSxJQUM3QixNQUFNLENBQUMsQ0FBQyxNQUFNO2dCQUNsQjtZQUNGLEtBQUs7Z0JBQ0gsYUFBYSxPQUFPLFdBQ2hCLE1BQU0sQ0FBQyxDQUFDLFlBQ1IsTUFBTSxDQUFDLENBQUMsUUFBUSxDQUFDLEVBQUUsRUFBRSxRQUFRLENBQUMsRUFBRTtnQkFDcEM7WUFDRixLQUFLO2dCQUNILGFBQWEsT0FBTyxXQUNoQixNQUFNLENBQUMsQ0FBQyxZQUNSLE1BQU0sQ0FBQyxDQUFDLFFBQVEsQ0FBQyxFQUFFLEVBQUUsUUFBUSxDQUFDLEVBQUU7Z0JBQ3BDO1lBQ0YsS0FBSztnQkFDSCxhQUFhLE9BQU8sV0FDaEIsTUFBTSxDQUFDLENBQUMsWUFDUixNQUFNLENBQUMsQ0FDTCxRQUFRLENBQUMsRUFBRSxFQUNYLE1BQU0sUUFBUSxDQUFDLEVBQUUsR0FBRyxLQUFLLElBQUksUUFBUSxDQUFDLEVBQUUsRUFDeEMsTUFBTSxTQUFTLE1BQU0sR0FBRyxRQUFRLENBQUMsRUFBRSxHQUFHLEtBQUs7Z0JBRWpEO1lBQ0YsS0FBSztnQkFDSCxhQUFhLE9BQU8sV0FDaEIsTUFBTSxDQUFDLENBQUMsWUFDUixNQUFNLENBQUMsQ0FBQyxRQUFRLENBQUMsRUFBRSxFQUFFLFFBQVEsQ0FBQyxFQUFFO1FBQ3hDO0lBQ0Y7SUFDQSxTQUFTLG1CQUNQLElBQUksRUFDSixRQUFRLEVBQ1IsU0FBUyxFQUNULElBQUksRUFDSixHQUFHLEVBQ0gsYUFBYSxFQUNiLFlBQVksRUFDWixlQUFlO1FBRWYsUUFBUSxDQUFDLE9BQU8sYUFBYTtRQUM3QixJQUFJLGNBQWMsS0FBSyxTQUFTLENBQUM7UUFDakMsSUFBSSxnQkFBaUIsZ0JBQWdCLElBQUs7UUFDMUMsSUFBSSxlQUFnQixlQUFlLElBQUs7UUFDeEMsSUFBSSxPQUFRLE9BQU8sSUFBSztRQUN4QixJQUFJLE1BQU8sTUFBTSxJQUFLO1FBQ3RCLElBQ0UsT0FBTyxpQkFDTixTQUFTLGlCQUFpQixNQUFNLGNBRWpDLGVBQWUsZ0JBQWdCO1FBQ2pDLElBQUksT0FDQSxDQUFDLEFBQUMsT0FBTyxZQUFZLE1BQU0sR0FBRyxHQUM3QixnQkFBZ0IsTUFDakIsSUFBSSxnQkFBZ0IsQ0FBQyxlQUFlLENBQUMsR0FDcEMsTUFBTSxNQUFNLGVBQWUsT0FBTyxHQUNuQyxJQUFJLE9BQU8sQ0FBQyxNQUFNLENBQUMsR0FDbEIsY0FDQyxPQUNBLGNBQ0EsTUFDQSxJQUFJLE1BQU0sQ0FBQyxnQkFDWCxRQUNBLElBQUksTUFBTSxDQUFDLE9BQ1gsT0FBUSxJQUNWLElBQUksZ0JBQ0YsQ0FBQyxBQUFDLGdCQUFnQixZQUFZLE1BQU0sR0FBRyxHQUN2QyxJQUFJLGdCQUFnQixDQUFDLGVBQWUsQ0FBQyxHQUNwQyxjQUNDLE9BQ0EsY0FDQSxNQUNBLElBQUksTUFBTSxDQUFDLGdCQUNYLFFBQ0EsS0FBSyxNQUFNLENBQUMsT0FBTyxpQkFDbkIsSUFBSSxNQUFNLENBQUMsT0FDWCxPQUFRLElBQ1Ysa0JBQWtCLE9BQ2hCLENBQUMsQUFBQyxNQUFNLE1BQU0sZUFBZSxHQUM3QixJQUFJLE9BQU8sQ0FBQyxNQUFNLENBQUMsR0FDbEIsY0FDQyxLQUFLLE1BQU0sQ0FBQyxnQkFBZ0IsS0FDNUIsT0FDQSxjQUNBLFFBQ0EsSUFBSSxNQUFNLENBQUMsZ0JBQ1gsUUFDQSxJQUFJLE1BQU0sQ0FBQyxPQUNYLE9BQVEsSUFDVCxjQUNDLEtBQUssTUFBTSxDQUFDLGdCQUFnQixLQUM1QixPQUNBLGNBQ0EsUUFDQSxJQUFJLE1BQU0sQ0FBQyxnQkFDWCxRQUNBLEtBQUssTUFBTSxDQUFDLE9BQU8saUJBQ25CLElBQUksTUFBTSxDQUFDLE9BQ1g7UUFDVixjQUNFLElBQUksZ0JBQ0EsY0FDQSwwR0FDQSx3R0FDQTtRQUNOLFNBQVMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxXQUFXLFlBQVksUUFBUTtRQUM1RCxZQUNJLENBQUMsQUFBQyxlQUNBLGlDQUNBLG1CQUFtQixtQkFDbkIsTUFDQSxVQUFVLFlBQ1YsTUFDQSxtQkFDRCxlQUFlLDRCQUE0QixTQUFVLElBQ3JELGNBQWMsV0FDWCxjQUFjLENBQUMscUJBQXFCLFVBQVUsU0FBUyxJQUN2RCxjQUFjO1FBQ3RCLElBQUk7WUFDRixJQUFJLEtBQUssQ0FBQyxHQUFHLElBQUksRUFBRSxZQUFZLENBQUMsS0FBSztRQUN2QyxFQUFFLE9BQU8sR0FBRztZQUNWLEtBQUssU0FBVSxDQUFDO2dCQUNkLE9BQU87WUFDVDtRQUNGO1FBQ0EsT0FBTztJQUNUO0lBQ0EsU0FBUyxtQkFDUCxRQUFRLEVBQ1IsS0FBSyxFQUNMLGVBQWUsRUFDZixnQkFBZ0IsRUFDaEIsU0FBUztRQUVULElBQUssSUFBSSxJQUFJLEdBQUcsSUFBSSxNQUFNLE1BQU0sRUFBRSxJQUFLO1lBQ3JDLElBQUksUUFBUSxLQUFLLENBQUMsRUFBRSxFQUNsQixXQUNFLE1BQU0sSUFBSSxDQUFDLE9BQ1gsTUFDQSxrQkFDQSxDQUFDLG1CQUFtQixPQUFPLElBQUksR0FDakMsS0FBSyxrQkFBa0IsR0FBRyxDQUFDO1lBQzdCLElBQUksS0FBSyxNQUFNLElBQUk7Z0JBQ2pCLEtBQUssS0FBSyxDQUFDLEVBQUU7Z0JBQ2IsSUFBSSxXQUFXLEtBQUssQ0FBQyxFQUFFLEVBQ3JCLE9BQU8sS0FBSyxDQUFDLEVBQUUsRUFDZixNQUFNLEtBQUssQ0FBQyxFQUFFLEVBQ2QsZ0JBQWdCLEtBQUssQ0FBQyxFQUFFO2dCQUMxQixRQUFRLEtBQUssQ0FBQyxFQUFFO2dCQUNoQixJQUFJLG1CQUFtQixTQUFTLHNCQUFzQjtnQkFDdEQsbUJBQW1CLG1CQUNmLGlCQUFpQixVQUFVLG1CQUMzQjtnQkFDSixLQUFLLG1CQUNILElBQ0EsVUFDQSxrQkFDQSxNQUNBLEtBQ0EsbUJBQW1CLE9BQU8sZUFDMUIsbUJBQW1CLE1BQU0sT0FDekI7Z0JBRUYsa0JBQWtCLEdBQUcsQ0FBQyxVQUFVO1lBQ2xDO1lBQ0EsWUFBWSxHQUFHLElBQUksQ0FBQyxNQUFNO1FBQzVCO1FBQ0EsT0FBTztJQUNUO0lBQ0EsU0FBUyxZQUFZLFFBQVEsRUFBRSxvQkFBb0I7UUFDakQsSUFBSSxXQUFXLFNBQVMsY0FBYztRQUN0QyxPQUFPLFdBQ0gsU0FBUyxvQkFBb0IsS0FBSyx1QkFDaEMsQ0FBQyxBQUFDLFdBQVcsUUFBUSxVQUFVLENBQUMsSUFBSSxDQUNsQyxTQUNBLFVBQVUscUJBQXFCLFdBQVcsS0FBSyxNQUVqRCxTQUFTLEdBQUcsQ0FBQyxTQUFTLElBQ3RCLFdBQ0Y7SUFDTjtJQUNBLFNBQVMsbUJBQW1CLFFBQVEsRUFBRSxTQUFTO1FBQzdDLElBQUksQ0FBQyxzQkFBc0IsUUFBUSxVQUFVLEtBQUssRUFBRSxPQUFPO1FBQzNELElBQUksY0FBYyxVQUFVLFNBQVM7UUFDckMsSUFBSSxLQUFLLE1BQU0sYUFBYSxPQUFPO1FBQ25DLElBQUksbUJBQW1CLEtBQUssTUFBTSxVQUFVLEdBQUcsRUFDN0MsUUFBUSxVQUFVLEtBQUssRUFDdkIsTUFDRSxRQUFRLFVBQVUsR0FBRyxHQUFHLFNBQVMsb0JBQW9CLEdBQUcsVUFBVSxHQUFHO1FBQ3pFLGNBQ0UsUUFBUSxVQUFVLEtBQUssSUFBSSxRQUFRLFVBQVUsS0FBSyxDQUFDLEdBQUcsR0FDbEQsU0FBUyxvQkFBb0IsR0FDN0IsVUFBVSxLQUFLLENBQUMsR0FBRztRQUN6QixJQUFJLFlBQ0YsUUFBUSxVQUFVLEtBQUssR0FDbkIsT0FDQSxtQkFBbUIsVUFBVSxVQUFVLEtBQUs7UUFDbEQsTUFDRSxRQUFRLGNBQ0osVUFBVSxJQUFJLFdBQVcsS0FBSyxNQUM5QixLQUFLLE1BQU0sVUFBVSxHQUFHLEdBQ3RCLE1BQU0sQ0FBQyxVQUFVLElBQUksSUFBSSxLQUFLLElBQUksTUFDbEMsS0FBSyxNQUFNLFVBQVUsSUFBSSxHQUN2QixVQUFVLElBQUksSUFBSSxZQUNsQixXQUFXLENBQUMsVUFBVSxPQUFPLENBQUMsSUFBSSxJQUFJLFNBQVM7UUFDekQsTUFBTSxRQUFRLFVBQVUsQ0FBQyxJQUFJLENBQUMsU0FBUztRQUN2QyxtQkFBbUIsbUJBQ2pCLFVBQ0EsT0FDQSxhQUNBLGtCQUNBO1FBRUYsU0FBUyxZQUNMLENBQUMsQUFBQyxXQUFXLFlBQVksVUFBVSxjQUNsQyxXQUNDLFFBQVEsV0FDSixTQUFTLEdBQUcsQ0FBQyxvQkFDYixrQkFBbUIsSUFDeEIsV0FBVyxVQUFVLEdBQUcsQ0FBQztRQUM5QixPQUFRLFVBQVUsU0FBUyxHQUFHO0lBQ2hDO0lBQ0EsU0FBUztRQUNQLE9BQU8sTUFBTTtJQUNmO0lBQ0EsU0FBUyxvQkFBb0IsUUFBUSxFQUFFLFNBQVM7UUFDOUMsSUFBSSxLQUFLLE1BQU0sVUFBVSxVQUFVLEVBQUU7WUFDbkMsUUFBUSxVQUFVLEtBQUssSUFDckIsQ0FBQyxVQUFVLFVBQVUsR0FBRyw0QkFDdEIsVUFDQSxVQUFVLEtBQUssRUFDZixRQUFRLFVBQVUsR0FBRyxHQUFHLEtBQUssVUFBVSxHQUFHLENBQzNDO1lBQ0gsSUFBSSxRQUFRLFVBQVUsS0FBSztZQUMzQixRQUFRLFNBQ04sQ0FBQyxvQkFBb0IsVUFBVSxRQUMvQixLQUFLLE1BQU0sTUFBTSxhQUFhLElBQzVCLFFBQVEsVUFBVSxVQUFVLElBQzVCLENBQUMsTUFBTSxhQUFhLEdBQUcsVUFBVSxVQUFVLENBQUM7UUFDbEQ7SUFDRjtJQUNBLFNBQVMsaUJBQWlCLFFBQVEsRUFBRSxFQUFFLEVBQUUsU0FBUztRQUMvQyxLQUFLLE1BQU0sVUFBVSxLQUFLLElBQUksbUJBQW1CLFVBQVU7UUFDM0QsUUFBUSxVQUFVLEtBQUssSUFBSSxRQUFRLFNBQVMsZUFBZSxHQUN2RCxDQUFDLEFBQUMsVUFBVSxLQUFLLEdBQUcsU0FBUyxlQUFlLEVBQzNDLFVBQVUsS0FBSyxHQUFHLE1BQ2xCLFVBQVUsVUFBVSxHQUFHLFNBQVMsZUFBZSxFQUMvQyxVQUFVLFNBQVMsR0FBRyxTQUFTLGNBQWMsQUFBQyxJQUMvQyxLQUFLLE1BQU0sVUFBVSxLQUFLLElBQzFCLG9CQUFvQixVQUFVO1FBQ2xDLFdBQVcsU0FBUyxVQUFVO1FBQzlCLENBQUMsU0FBUyxVQUFVLElBQUksQ0FBQyxTQUFTLFVBQVUsR0FBRyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUM7SUFDM0Q7SUFDQSxTQUFTO1FBQ1AsSUFBSSxRQUFRO1FBQ1osSUFBSSxTQUFTLE9BQU8sT0FBTztRQUMzQixJQUFJO1lBQ0YsSUFBSSxPQUFPO1lBQ1gsSUFBSSxNQUFNLEtBQUssSUFBSSxhQUFhLE9BQU8sTUFBTSxJQUFJLEVBQUU7Z0JBQ2pELE1BQU8sT0FBUztvQkFDZCxJQUFJLGFBQWEsTUFBTSxVQUFVO29CQUNqQyxJQUFJLFFBQVEsWUFBWTt3QkFDdEIsSUFBSyxRQUFRLE1BQU0sS0FBSyxFQUFHOzRCQUN6QixJQUFJLHdCQUF3Qjs0QkFDNUIsSUFBSSxRQUFRLFlBQ1Ysd0JBQXdCLE1BQU0saUJBQWlCOzRCQUNqRCxNQUFNLGlCQUFpQixHQUFHOzRCQUMxQixJQUFJLFFBQVEsTUFBTSxLQUFLOzRCQUN2QixNQUFNLGlCQUFpQixHQUFHOzRCQUMxQixNQUFNLFVBQVUsQ0FBQyxxQ0FDZixDQUFDLFFBQVEsTUFBTSxLQUFLLENBQUMsR0FBRzs0QkFDMUIsSUFBSSxNQUFNLE1BQU0sT0FBTyxDQUFDOzRCQUN4QixDQUFDLE1BQU0sT0FBTyxDQUFDLFFBQVEsTUFBTSxLQUFLLENBQUMsTUFBTSxFQUFFOzRCQUMzQyxNQUFNLE1BQU0sT0FBTyxDQUFDOzRCQUNwQixDQUFDLE1BQU0sT0FBTyxDQUFDLE1BQU0sTUFBTSxXQUFXLENBQUMsTUFBTSxJQUFJOzRCQUNqRCxJQUFJLDJCQUNGLENBQUMsTUFBTSxNQUFPLFFBQVEsTUFBTSxLQUFLLENBQUMsR0FBRyxPQUFROzRCQUMvQyxPQUNFLHdCQUF3QixDQUFDLE9BQU8sd0JBQXdCO3dCQUM1RDtvQkFDRixPQUFPO2dCQUNUO2dCQUNBLElBQUksb0NBQW9DO1lBQzFDLE9BQU87Z0JBQ0wsd0JBQXdCLE1BQU0sSUFBSTtnQkFDbEMsSUFBSSxLQUFLLE1BQU0sUUFDYixJQUFJO29CQUNGLE1BQU07Z0JBQ1IsRUFBRSxPQUFPLEdBQUc7b0JBQ1QsU0FDQyxBQUFDLENBQUMsUUFBUSxFQUFFLEtBQUssQ0FBQyxJQUFJLEdBQUcsS0FBSyxDQUFDLGVBQWUsS0FBSyxLQUFLLENBQUMsRUFBRSxJQUMzRCxJQUNDLFNBQ0MsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLE9BQU8sQ0FBQyxjQUNqQixtQkFDQSxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsT0FBTyxDQUFDLE9BQ25CLGlCQUNBO2dCQUNaO2dCQUNGLG9DQUNFLE9BQU8sU0FBUyx3QkFBd0I7WUFDNUM7UUFDRixFQUFFLE9BQU8sR0FBRztZQUNWLG9DQUNFLCtCQUErQixFQUFFLE9BQU8sR0FBRyxPQUFPLEVBQUUsS0FBSztRQUM3RDtRQUNBLE9BQU87SUFDVDtJQUNBLFNBQVMsb0JBQW9CLFFBQVEsRUFBRSxLQUFLO1FBQzFDLElBQUksU0FBUyxjQUFjLEVBQUU7WUFDM0IsSUFBSSxVQUFVLEtBQUssS0FBSyxDQUFDLE9BQU8sU0FBUyxTQUFTO1lBQ2xELFFBQVEsT0FBTyxDQUFDLEVBQUU7WUFDbEIsSUFBSSxhQUFhLE9BQU8sQ0FBQyxFQUFFLEVBQ3pCLFFBQVEsT0FBTyxDQUFDLEVBQUUsRUFDbEIsTUFBTSxPQUFPLENBQUMsRUFBRTtZQUNsQixVQUFVLFFBQVEsS0FBSyxDQUFDO1lBQ3hCLGdDQUNFLFVBQ0EsT0FDQSxZQUNBLE9BQ0EsS0FDQTtRQUVKO0lBQ0Y7SUFDQSxTQUFTLFlBQVksTUFBTSxFQUFFLFNBQVM7UUFDcEMsSUFDRSxJQUFJLElBQUksT0FBTyxNQUFNLEVBQUUsYUFBYSxVQUFVLE1BQU0sRUFBRSxJQUFJLEdBQzFELElBQUksR0FDSixJQUVBLGNBQWMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVO1FBQ3BDLGFBQWEsSUFBSSxXQUFXO1FBQzVCLElBQUssSUFBSSxNQUFPLElBQUksR0FBSSxNQUFNLEdBQUcsTUFBTztZQUN0QyxJQUFJLFFBQVEsTUFBTSxDQUFDLElBQUk7WUFDdkIsV0FBVyxHQUFHLENBQUMsT0FBTztZQUN0QixLQUFLLE1BQU0sVUFBVTtRQUN2QjtRQUNBLFdBQVcsR0FBRyxDQUFDLFdBQVc7UUFDMUIsT0FBTztJQUNUO0lBQ0EsU0FBUyxrQkFDUCxRQUFRLEVBQ1IsRUFBRSxFQUNGLE1BQU0sRUFDTixTQUFTLEVBQ1QsV0FBVyxFQUNYLGVBQWU7UUFFZixTQUNFLE1BQU0sT0FBTyxNQUFNLElBQUksTUFBTSxVQUFVLFVBQVUsR0FBRyxrQkFDaEQsWUFDQSxZQUFZLFFBQVE7UUFDMUIsY0FBYyxJQUFJLFlBQ2hCLE9BQU8sTUFBTSxFQUNiLE9BQU8sVUFBVSxFQUNqQixPQUFPLFVBQVUsR0FBRztRQUV0QixjQUFjLFVBQVUsSUFBSTtJQUM5QjtJQUNBLFNBQVMsaUNBQWlDO0lBQzFDLFNBQVMscUJBQXFCLFFBQVEsRUFBRSxFQUFFLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxLQUFLO1FBQzVELE9BQVE7WUFDTixLQUFLO2dCQUNILGNBQWMsVUFBVSxJQUFJLFlBQVksUUFBUSxPQUFPLE1BQU07Z0JBQzdEO1lBQ0YsS0FBSztnQkFDSCxrQkFBa0IsVUFBVSxJQUFJLFFBQVEsT0FBTyxXQUFXO2dCQUMxRDtZQUNGLEtBQUs7Z0JBQ0gsY0FDRSxVQUNBLElBQ0EsTUFBTSxPQUFPLE1BQU0sR0FBRyxRQUFRLFlBQVksUUFBUTtnQkFFcEQ7WUFDRixLQUFLO2dCQUNILGtCQUFrQixVQUFVLElBQUksUUFBUSxPQUFPLG1CQUFtQjtnQkFDbEU7WUFDRixLQUFLO2dCQUNILGtCQUFrQixVQUFVLElBQUksUUFBUSxPQUFPLFlBQVk7Z0JBQzNEO1lBQ0YsS0FBSztnQkFDSCxrQkFBa0IsVUFBVSxJQUFJLFFBQVEsT0FBTyxhQUFhO2dCQUM1RDtZQUNGLEtBQUs7Z0JBQ0gsa0JBQWtCLFVBQVUsSUFBSSxRQUFRLE9BQU8sWUFBWTtnQkFDM0Q7WUFDRixLQUFLO2dCQUNILGtCQUFrQixVQUFVLElBQUksUUFBUSxPQUFPLGFBQWE7Z0JBQzVEO1lBQ0YsS0FBSztnQkFDSCxrQkFBa0IsVUFBVSxJQUFJLFFBQVEsT0FBTyxjQUFjO2dCQUM3RDtZQUNGLEtBQUs7Z0JBQ0gsa0JBQWtCLFVBQVUsSUFBSSxRQUFRLE9BQU8sY0FBYztnQkFDN0Q7WUFDRixLQUFLO2dCQUNILGtCQUFrQixVQUFVLElBQUksUUFBUSxPQUFPLGVBQWU7Z0JBQzlEO1lBQ0YsS0FBSztnQkFDSCxrQkFBa0IsVUFBVSxJQUFJLFFBQVEsT0FBTyxnQkFBZ0I7Z0JBQy9EO1lBQ0YsS0FBSztnQkFDSCxrQkFBa0IsVUFBVSxJQUFJLFFBQVEsT0FBTyxVQUFVO2dCQUN6RDtRQUNKO1FBQ0EsSUFDRSxJQUFJLGdCQUFnQixTQUFTLGNBQWMsRUFBRSxNQUFNLElBQUksSUFBSSxHQUMzRCxJQUFJLE9BQU8sTUFBTSxFQUNqQixJQUVBLE9BQU8sY0FBYyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRTtRQUN6QyxPQUFPLGNBQWMsTUFBTSxDQUFDO1FBQzVCLHFCQUFxQixVQUFVLElBQUksS0FBSztJQUMxQztJQUNBLFNBQVMscUJBQXFCLFFBQVEsRUFBRSxFQUFFLEVBQUUsR0FBRyxFQUFFLEdBQUc7UUFDbEQsT0FBUTtZQUNOLEtBQUs7Z0JBQ0gsY0FBYyxVQUFVLElBQUk7Z0JBQzVCO1lBQ0YsS0FBSztnQkFDSCxZQUFZLFVBQVUsR0FBRyxDQUFDLEVBQUUsRUFBRSxJQUFJLEtBQUssQ0FBQztnQkFDeEM7WUFDRixLQUFLO2dCQUNILE1BQU0sS0FBSyxLQUFLLENBQUM7Z0JBQ2pCLE1BQU0sZ0JBQWdCLFVBQVU7Z0JBQ2hDLElBQUksTUFBTSxHQUFHLElBQUksTUFBTTtnQkFDdkIsTUFBTSxTQUFTLE9BQU87Z0JBQ3RCLElBQUksUUFBUSxJQUFJLEdBQUcsQ0FBQztnQkFDcEIsUUFDSSxvQkFBb0IsVUFBVSxPQUFPLE9BQ3JDLElBQUksR0FBRyxDQUFDLElBQUksSUFBSSxhQUFhLFlBQVksTUFBTTtnQkFDbkQ7WUFDRixLQUFLO2dCQUNILFlBQVksVUFBVSxJQUFJO2dCQUMxQjtZQUNGLEtBQUs7WUFDTCxLQUFLO2dCQUNILE1BQU0sSUFBSSxhQUFhLGtCQUFrQixLQUFLO2dCQUM5QyxxQkFBcUI7Z0JBQ3JCLGdCQUFnQixJQUFJLE1BQU0sR0FDdEIsaUJBQWlCLFVBQVUsSUFBSSxJQUFJLEtBQUssSUFDeEMsSUFBSSxJQUFJLENBQ04sU0FBVSxDQUFDO29CQUNULE9BQU8saUJBQWlCLFVBQVUsSUFBSTtnQkFDeEMsR0FDQSxZQUFhO2dCQUVuQjtZQUNGLEtBQUs7WUFDTCxLQUFLO2dCQUNILG9CQUFvQixVQUFVO2dCQUM5QjtZQUNGLEtBQUs7Z0JBQ0gsb0JBQW9CLFVBQVUsSUFBSSxLQUFLO2dCQUN2QztZQUNGLEtBQUs7Z0JBQ0gsb0JBQW9CLFVBQVUsSUFBSTtnQkFDbEM7WUFDRixLQUFLO2dCQUNILG1CQUFtQixVQUFVLElBQUksQ0FBQztnQkFDbEM7WUFDRixLQUFLO2dCQUNILG1CQUFtQixVQUFVLElBQUksQ0FBQztnQkFDbEM7WUFDRixLQUFLO2dCQUNILFdBQVcsVUFBVSxJQUFJO2dCQUN6QjtZQUNGO2dCQUNFLE9BQU8sTUFDSCxpQkFBaUIsVUFBVSxNQUMzQixhQUFhLFVBQVUsSUFBSTtRQUNuQztJQUNGO0lBQ0EsU0FBUyxtQkFBbUIsWUFBWSxFQUFFLFdBQVcsRUFBRSxLQUFLO1FBQzFELElBQUksS0FBSyxNQUFNLGFBQWEsSUFBSSxDQUFDLEtBQUssSUFBSTtZQUN4QyxJQUFJLFdBQVcsbUJBQW1CLGVBQ2hDLElBQUksR0FDSixXQUFXLFlBQVksU0FBUztZQUNsQyxlQUFlLFlBQVksTUFBTTtZQUNqQyxJQUNFLElBQUksU0FBUyxZQUFZLE9BQU8sRUFDOUIsWUFBWSxZQUFZLFVBQVUsRUFDbEMsU0FBUyxZQUFZLE9BQU8sRUFDNUIsY0FBYyxNQUFNLE1BQU0sRUFDNUIsSUFBSSxhQUVKO2dCQUNBLElBQUksVUFBVSxDQUFDO2dCQUNmLE9BQVE7b0JBQ04sS0FBSzt3QkFDSCxVQUFVLEtBQUssQ0FBQyxJQUFJO3dCQUNwQixPQUFPLFVBQ0YsV0FBVyxJQUNYLGVBQ0MsQUFBQyxnQkFBZ0IsSUFDakIsQ0FBQyxLQUFLLFVBQVUsVUFBVSxLQUFLLFVBQVUsRUFBRTt3QkFDakQ7b0JBQ0YsS0FBSzt3QkFDSCxXQUFXLEtBQUssQ0FBQyxFQUFFO3dCQUNuQixPQUFPLFlBQ1AsT0FBTyxZQUNQLE9BQU8sWUFDUCxRQUFRLFlBQ1IsT0FBTyxZQUNQLE9BQU8sWUFDUCxRQUFRLFlBQ1IsT0FBTyxZQUNQLFFBQVEsWUFDUixPQUFPLFlBQ1AsUUFBUSxZQUNSLE9BQU8sWUFDUCxRQUFRLFlBQ1IsT0FBTyxXQUNILENBQUMsQUFBQyxTQUFTLFVBQVksV0FBVyxHQUFJLEdBQUcsSUFDekMsQUFBQyxLQUFLLFlBQVksS0FBSyxZQUNyQixPQUFPLFlBQ1AsUUFBUSxZQUNSLFFBQVEsV0FDUixDQUFDLEFBQUMsU0FBUyxVQUFZLFdBQVcsR0FBSSxHQUFHLElBQ3pDLENBQUMsQUFBQyxTQUFTLEdBQUssV0FBVyxDQUFFO3dCQUNuQztvQkFDRixLQUFLO3dCQUNILFVBQVUsS0FBSyxDQUFDLElBQUk7d0JBQ3BCLE9BQU8sVUFDRixXQUFXLElBQ1gsWUFDQyxBQUFDLGFBQWEsSUFDZCxDQUFDLEtBQUssVUFBVSxVQUFVLEtBQUssVUFBVSxFQUFFO3dCQUNqRDtvQkFDRixLQUFLO3dCQUNILFVBQVUsTUFBTSxPQUFPLENBQUMsSUFBSTt3QkFDNUI7b0JBQ0YsS0FBSzt3QkFDRixVQUFVLElBQUksV0FDYixVQUFVLE1BQU0sTUFBTSxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7Z0JBQzdDO2dCQUNBLElBQUksU0FBUyxNQUFNLFVBQVUsR0FBRztnQkFDaEMsSUFBSSxDQUFDLElBQUksU0FDUCxBQUFDLFlBQVksSUFBSSxXQUFXLE1BQU0sTUFBTSxFQUFFLFFBQVEsVUFBVSxJQUMxRCxxQkFDRSxVQUNBLGNBQ0EsUUFDQSxRQUNBLFlBRUQsSUFBSSxTQUNMLE1BQU0sWUFBWSxLQUNqQixZQUFZLGVBQWUsU0FBUyxXQUFXLEdBQy9DLE9BQU8sTUFBTSxHQUFHO3FCQUNoQjtvQkFDSCxRQUFRLElBQUksV0FBVyxNQUFNLE1BQU0sRUFBRSxRQUFRLE1BQU0sVUFBVSxHQUFHO29CQUNoRSxPQUFPLElBQUksQ0FBQztvQkFDWixhQUFhLE1BQU0sVUFBVTtvQkFDN0I7Z0JBQ0Y7WUFDRjtZQUNBLFlBQVksU0FBUyxHQUFHO1lBQ3hCLFlBQVksTUFBTSxHQUFHO1lBQ3JCLFlBQVksT0FBTyxHQUFHO1lBQ3RCLFlBQVksVUFBVSxHQUFHO1FBQzNCO0lBQ0Y7SUFDQSxTQUFTLHVCQUF1QixRQUFRO1FBQ3RDLE9BQU8sU0FBVSxHQUFHLEVBQUUsS0FBSztZQUN6QixJQUFJLGFBQWEsT0FBTyxPQUN0QixPQUFPLGlCQUFpQixVQUFVLElBQUksRUFBRSxLQUFLO1lBQy9DLElBQUksYUFBYSxPQUFPLFNBQVMsU0FBUyxPQUFPO2dCQUMvQyxJQUFJLEtBQUssQ0FBQyxFQUFFLEtBQUssb0JBQ2YsR0FBRztvQkFDRCxJQUFJLFFBQVEsS0FBSyxDQUFDLEVBQUU7b0JBQ3BCLE1BQU0sS0FBSyxDQUFDLEVBQUU7b0JBQ2QsSUFBSSxZQUFZLEtBQUssQ0FBQyxFQUFFO29CQUN4QixRQUFRO3dCQUNOLFVBQVU7d0JBQ1YsTUFBTSxLQUFLLENBQUMsRUFBRTt3QkFDZCxLQUFLLEtBQUssQ0FBQyxFQUFFO3dCQUNiLE9BQU8sS0FBSyxDQUFDLEVBQUU7d0JBQ2YsUUFBUSxLQUFLLE1BQU0sUUFBUSxPQUFPO29CQUNwQztvQkFDQSxPQUFPLGNBQWMsQ0FBQyxPQUFPLE9BQU87d0JBQ2xDLFlBQVksQ0FBQzt3QkFDYixLQUFLO29CQUNQO29CQUNBLE1BQU0sTUFBTSxHQUFHLENBQUM7b0JBQ2hCLE9BQU8sY0FBYyxDQUFDLE1BQU0sTUFBTSxFQUFFLGFBQWE7d0JBQy9DLGNBQWMsQ0FBQzt3QkFDZixZQUFZLENBQUM7d0JBQ2IsVUFBVSxDQUFDO3dCQUNYLE9BQU87b0JBQ1Q7b0JBQ0EsT0FBTyxjQUFjLENBQUMsT0FBTyxjQUFjO3dCQUN6QyxjQUFjLENBQUM7d0JBQ2YsWUFBWSxDQUFDO3dCQUNiLFVBQVUsQ0FBQzt3QkFDWCxPQUFPO29CQUNUO29CQUNBLE9BQU8sY0FBYyxDQUFDLE9BQU8sZUFBZTt3QkFDMUMsY0FBYyxDQUFDO3dCQUNmLFlBQVksQ0FBQzt3QkFDYixVQUFVLENBQUM7d0JBQ1gsT0FBTyxLQUFLLE1BQU0sTUFBTSxPQUFPO29CQUNqQztvQkFDQSxPQUFPLGNBQWMsQ0FBQyxPQUFPLGNBQWM7d0JBQ3pDLGNBQWMsQ0FBQzt3QkFDZixZQUFZLENBQUM7d0JBQ2IsVUFBVSxDQUFDO3dCQUNYLE9BQU87b0JBQ1Q7b0JBQ0EsSUFBSSxTQUFTLHFCQUFxQjt3QkFDaEMsWUFBWTt3QkFDWixzQkFBc0IsVUFBVSxNQUFNO3dCQUN0QyxJQUFJLFVBQVUsT0FBTyxFQUFFOzRCQUNyQixNQUFNLElBQUksYUFBYSxZQUFZLE1BQU0sVUFBVSxLQUFLOzRCQUN4RCxrQkFBa0IsVUFBVTs0QkFDNUIsWUFBWTtnQ0FDVixNQUFNLHlCQUF5QixNQUFNLElBQUksS0FBSztnQ0FDOUMsT0FBTyxNQUFNLE1BQU07NEJBQ3JCOzRCQUNBLFVBQVUsVUFBVSxHQUFHLE1BQU0sV0FBVzs0QkFDeEMsc0JBQ0UsQ0FBQyxVQUFVLFNBQVMsR0FBRyxNQUFNLFVBQVU7NEJBQ3pDLElBQUksVUFBVSxHQUFHO2dDQUFDOzZCQUFVOzRCQUM1QixRQUFRLHVCQUF1Qjs0QkFDL0IsTUFBTTt3QkFDUjt3QkFDQSxJQUFJLElBQUksVUFBVSxJQUFJLEVBQUU7NEJBQ3RCLE1BQU0sSUFBSSxhQUFhLFdBQVcsTUFBTTs0QkFDeEMsVUFBVSxLQUFLLEdBQUc7NEJBQ2xCLFVBQVUsS0FBSyxHQUFHOzRCQUNsQixRQUFRLGtCQUFrQixJQUFJLENBQUMsTUFBTSxVQUFVOzRCQUMvQyxJQUFJLElBQUksQ0FBQyxPQUFPOzRCQUNoQixRQUFRLHVCQUF1Qjs0QkFDL0IsTUFBTTt3QkFDUjtvQkFDRjtvQkFDQSxrQkFBa0IsVUFBVTtnQkFDOUI7Z0JBQ0YsT0FBTztZQUNUO1lBQ0EsT0FBTztRQUNUO0lBQ0Y7SUFDQSxTQUFTLE1BQU0sWUFBWTtRQUN6QixrQkFBa0IsY0FBYyxNQUFNO0lBQ3hDO0lBQ0EsU0FBUztRQUNQLE1BQU0sTUFDSjtJQUVKO0lBQ0EsU0FBUywwQkFBMEIsT0FBTztRQUN4QyxPQUFPLElBQUksaUJBQ1QsUUFBUSxzQkFBc0IsQ0FBQyxTQUFTLEVBQ3hDLFFBQVEsc0JBQXNCLENBQUMsZUFBZSxFQUM5QyxRQUFRLHNCQUFzQixDQUFDLGFBQWEsRUFDNUMsZ0JBQ0EsUUFBUSxnQkFBZ0IsRUFDeEIsYUFBYSxPQUFPLFFBQVEsS0FBSyxHQUFHLFFBQVEsS0FBSyxHQUFHLEtBQUssR0FDekQsV0FBVyxRQUFRLG1CQUFtQixHQUNsQyxRQUFRLG1CQUFtQixHQUMzQixLQUFLLEdBQ1QsV0FBVyxRQUFRLGdCQUFnQixHQUFHLFFBQVEsZ0JBQWdCLEdBQUcsS0FBSyxHQUN0RSxVQUFVLENBQUMsTUFBTSxRQUFRLGlCQUFpQixHQUFHLENBQUMsR0FDOUMsV0FBVyxRQUFRLGVBQWUsR0FBRyxRQUFRLGVBQWUsR0FBRyxLQUFLLEdBQ3BFLEtBQUssR0FDTCxhQUFhO0lBQ2pCO0lBQ0EsU0FBUyx1QkFBdUIsUUFBUSxFQUFFLE1BQU07UUFDOUMsU0FBUyxTQUFTLElBQUk7WUFDcEIsSUFBSSxRQUFRLEtBQUssS0FBSztZQUN0QixJQUFJLEtBQUssSUFBSSxFQUFFLE1BQU07aUJBRW5CLE9BQ0UsbUJBQW1CLFVBQVUsYUFBYSxRQUMxQyxPQUFPLElBQUksR0FBRyxJQUFJLENBQUMsVUFBVSxLQUFLLENBQUM7UUFFekM7UUFDQSxTQUFTLE1BQU0sQ0FBQztZQUNkLGtCQUFrQixVQUFVO1FBQzlCO1FBQ0EsSUFBSSxjQUFjLHFCQUNoQixTQUFTLE9BQU8sU0FBUztRQUMzQixPQUFPLElBQUksR0FBRyxJQUFJLENBQUMsVUFBVSxLQUFLLENBQUM7SUFDckM7SUFDQSxTQUFTO1FBQ1AsTUFBTSxNQUNKO0lBRUo7SUFDQSxJQUFJLDJFQUNGLHVKQUNBLGdKQUNBLGlCQUFpQjtRQUFFLFFBQVEsQ0FBQztJQUFFLEdBQzlCLFNBQVMsU0FBUyxTQUFTLENBQUMsSUFBSSxFQUNoQyxhQUFhLElBQUksT0FDakIsMEJBQ0UsU0FBUyw0REFBNEQsRUFDdkUscUJBQXFCLE9BQU8sR0FBRyxDQUFDLCtCQUNoQyxvQkFBb0IsT0FBTyxHQUFHLENBQUMsaUJBQy9CLHNCQUFzQixPQUFPLEdBQUcsQ0FBQyxtQkFDakMseUJBQXlCLE9BQU8sR0FBRyxDQUFDLHNCQUNwQyxzQkFBc0IsT0FBTyxHQUFHLENBQUMsbUJBQ2pDLHNCQUFzQixPQUFPLEdBQUcsQ0FBQyxtQkFDakMscUJBQXFCLE9BQU8sR0FBRyxDQUFDLGtCQUNoQyx5QkFBeUIsT0FBTyxHQUFHLENBQUMsc0JBQ3BDLHNCQUFzQixPQUFPLEdBQUcsQ0FBQyxtQkFDakMsMkJBQTJCLE9BQU8sR0FBRyxDQUFDLHdCQUN0QyxrQkFBa0IsT0FBTyxHQUFHLENBQUMsZUFDN0Isa0JBQWtCLE9BQU8sR0FBRyxDQUFDLGVBQzdCLHNCQUFzQixPQUFPLEdBQUcsQ0FBQyxtQkFDakMsd0JBQXdCLE9BQU8sUUFBUSxFQUN2QyxpQkFBaUIsT0FBTyxhQUFhLEVBQ3JDLGNBQWMsTUFBTSxPQUFPLEVBQzNCLGlCQUFpQixPQUFPLGNBQWMsRUFDdEMsa0JBQWtCLElBQUksV0FDdEIscUJBQXFCLElBQUksV0FDekIsdUJBQXVCLE9BQU8sR0FBRyxDQUFDLDJCQUNsQyxrQkFBa0IsT0FBTyxTQUFTLEVBQ2xDLHdCQUF3QixJQUFJLFdBQzVCLGFBQWEsSUFBSSxXQUNqQix3QkFBd0IsR0FDeEIsZUFBZSxTQUFTLFNBQVMsQ0FBQyxJQUFJLEVBQ3RDLGFBQWEsTUFBTSxTQUFTLENBQUMsS0FBSyxFQUNsQyxnQkFDRSx1RUFDRiw2QkFBNkIsOEJBQzdCLHlCQUF5QixPQUFPLEdBQUcsQ0FBQywyQkFDcEMsUUFDQTtJQUNGLElBQUksQ0FBQyxlQUFlLE9BQU8sVUFBVSxVQUFVLEdBQUc7SUFDbEQsSUFBSSw0QkFDQSxNQUFNLCtEQUErRCxFQUN2RSx1QkFDRSxNQUFNLCtEQUErRCxJQUNyRTtJQUNKLGFBQWEsU0FBUyxHQUFHLE9BQU8sTUFBTSxDQUFDLFFBQVEsU0FBUztJQUN4RCxhQUFhLFNBQVMsQ0FBQyxJQUFJLEdBQUcsU0FBVSxPQUFPLEVBQUUsTUFBTTtRQUNyRCxPQUFRLElBQUksQ0FBQyxNQUFNO1lBQ2pCLEtBQUs7Z0JBQ0gscUJBQXFCLElBQUk7Z0JBQ3pCO1lBQ0YsS0FBSztnQkFDSCxzQkFBc0IsSUFBSTtRQUM5QjtRQUNBLE9BQVEsSUFBSSxDQUFDLE1BQU07WUFDakIsS0FBSztnQkFDSCxlQUFlLE9BQU8sV0FBVyxRQUFRLElBQUksQ0FBQyxLQUFLO2dCQUNuRDtZQUNGLEtBQUs7WUFDTCxLQUFLO2dCQUNILGVBQWUsT0FBTyxXQUNwQixDQUFDLFNBQVMsSUFBSSxDQUFDLEtBQUssSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLEdBQUcsRUFBRSxHQUN4QyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxRQUFRO2dCQUMxQixlQUFlLE9BQU8sVUFDcEIsQ0FBQyxTQUFTLElBQUksQ0FBQyxNQUFNLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxHQUFHLEVBQUUsR0FDMUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTztnQkFDMUI7WUFDRixLQUFLO2dCQUNIO1lBQ0Y7Z0JBQ0UsZUFBZSxPQUFPLFVBQVUsT0FBTyxJQUFJLENBQUMsTUFBTTtRQUN0RDtJQUNGO0lBQ0EsSUFBSSx1QkFDQSxlQUFlLE9BQU8sdUJBQ2xCLElBQUkscUJBQXFCLHVCQUN6QixNQUNOLHNCQUFzQixNQUN0QixxQkFBcUIsQ0FBQyxDQUFDLFFBQVEsVUFBVSxFQUN6QyxvQkFBb0IsSUFBSSxPQUN4QixrQkFBa0IsR0FDbEIseUJBQXlCO1FBQ3ZCLDBCQUEwQixTQUFVLFFBQVEsRUFBRSxLQUFLLEVBQUUsZUFBZTtZQUNsRSxPQUFPLG1CQUNMLFVBQ0EsT0FDQSxpQkFDQSxDQUFDLEdBQ0Q7UUFFSjtJQUNGLEdBQ0EsOEJBQ0UsdUJBQXVCLHdCQUF3QixDQUFDLElBQUksQ0FDbEQseUJBRUosb0JBQW9CLE1BQ3BCLDZCQUE2QjtRQUMzQiwwQkFBMEIsU0FDeEIsUUFBUSxFQUNSLFVBQVUsRUFDVixVQUFVLEVBQ1YsS0FBSyxFQUNMLEdBQUcsRUFDSCxJQUFJO1lBRUosSUFBSSxZQUFZLHFCQUFxQixlQUFlO1lBQ3BELHFCQUFxQixlQUFlLEdBQUc7WUFDdkMsb0JBQW9CLFNBQVMsUUFBUSxTQUFTLGVBQWUsR0FBRztZQUNoRSxJQUFJO2dCQUNGLEdBQUc7b0JBQ0QsSUFBSSxTQUFTO29CQUNiLE9BQVE7d0JBQ04sS0FBSzt3QkFDTCxLQUFLO3dCQUNMLEtBQUs7d0JBQ0wsS0FBSzs0QkFDSCxJQUFJLDJCQUEyQixPQUFPLEtBQUssQ0FDekMsT0FBTyxDQUFDLFdBQVcsRUFDbkI7Z0NBQUM7NkJBQVEsQ0FBQyxNQUFNLENBQUM7NEJBRW5CLE1BQU07d0JBQ1IsS0FBSzs0QkFDSCxTQUFTO29CQUNiO29CQUNBLElBQUksVUFBVSxLQUFLLEtBQUssQ0FBQztvQkFDekIsYUFBYSxPQUFPLE9BQU8sQ0FBQyxPQUFPLEdBQy9CLFFBQVEsTUFBTSxDQUNaLFFBQ0EsR0FDQSx1Q0FBdUMsT0FBTyxDQUFDLE9BQU8sRUFDdEQsNkpBQ0EsTUFBTSxNQUFNLEtBQ1osTUFFRixRQUFRLE1BQU0sQ0FDWixRQUNBLEdBQ0Esc0NBQ0EsNkpBQ0EsTUFBTSxNQUFNLEtBQ1o7b0JBRU4sUUFBUSxPQUFPLENBQUM7b0JBQ2hCLDJCQUEyQixPQUFPLEtBQUssQ0FDckMsT0FBTyxDQUFDLFdBQVcsRUFDbkI7Z0JBRUo7Z0JBQ0EsSUFBSSxZQUFZLG1CQUNkLFVBQ0EsWUFDQSxLQUNBLENBQUMsR0FDRDtnQkFFRixJQUFJLFFBQVEsT0FBTztvQkFDakIsSUFBSSxPQUFPLG1CQUFtQixVQUFVO29CQUN4QyxvQkFBb0IsVUFBVTtvQkFDOUIsSUFBSSxTQUFTLE1BQU07d0JBQ2pCLEtBQUssR0FBRyxDQUFDO3dCQUNUO29CQUNGO2dCQUNGO2dCQUNBLElBQUksV0FBVyxZQUFZLFVBQVU7Z0JBQ3JDLFFBQVEsV0FBVyxTQUFTLEdBQUcsQ0FBQyxhQUFhO1lBQy9DLFNBQVU7Z0JBQ1Asb0JBQW9CLE1BQ2xCLHFCQUFxQixlQUFlLEdBQUc7WUFDNUM7UUFDRjtJQUNGLEdBQ0Esa0NBQ0UsMkJBQTJCLHdCQUF3QixDQUFDLElBQUksQ0FDdEQ7SUFFTixRQUFRLGVBQWUsR0FBRyxTQUFVLGtCQUFrQixFQUFFLE9BQU87UUFDN0QsSUFBSSxXQUFXLDBCQUEwQjtRQUN6QyxtQkFBbUIsSUFBSSxDQUNyQixTQUFVLENBQUM7WUFDVCx1QkFBdUIsVUFBVSxFQUFFLElBQUk7UUFDekMsR0FDQSxTQUFVLENBQUM7WUFDVCxrQkFBa0IsVUFBVTtRQUM5QjtRQUVGLE9BQU8sUUFBUTtJQUNqQjtJQUNBLFFBQVEsb0JBQW9CLEdBQUcsU0FDN0IsTUFBTSxFQUNOLHNCQUFzQixFQUN0QixPQUFPO1FBRVAsSUFBSSxvQkFBb0IsSUFBSSxpQkFDeEIsdUJBQXVCLFNBQVMsRUFDaEMsdUJBQXVCLGVBQWUsRUFDdEMsdUJBQXVCLGFBQWEsRUFDcEMsY0FDQSxVQUFVLFFBQVEsZ0JBQWdCLEdBQUcsS0FBSyxHQUMxQyxXQUFXLGFBQWEsT0FBTyxRQUFRLEtBQUssR0FBRyxRQUFRLEtBQUssR0FBRyxLQUFLLEdBQ3BFLEtBQUssR0FDTCxXQUFXLFFBQVEsZ0JBQWdCLEdBQy9CLFFBQVEsZ0JBQWdCLEdBQ3hCLEtBQUssR0FDVCxVQUFVLENBQUMsTUFBTSxRQUFRLGlCQUFpQixHQUFHLENBQUMsR0FDOUMsV0FBVyxRQUFRLGVBQWUsR0FBRyxRQUFRLGVBQWUsR0FBRyxLQUFLLEdBQ3BFLEtBQUssR0FDTCxhQUFhLEVBQ2YsY0FBYztRQUNoQixPQUFPLEVBQUUsQ0FBQyxRQUFRLFNBQVUsS0FBSztZQUMvQixJQUFJLGFBQWEsT0FBTyxPQUFPO2dCQUM3QixJQUFJLEtBQUssTUFBTSxrQkFBa0IsSUFBSSxDQUFDLEtBQUssSUFBSTtvQkFDN0MsSUFDRSxJQUFJLFdBQVcsbUJBQW1CLG9CQUNoQyxJQUFJLEdBQ0osV0FBVyxZQUFZLFNBQVMsRUFDaEMsUUFBUSxZQUFZLE1BQU0sRUFDMUIsU0FBUyxZQUFZLE9BQU8sRUFDNUIsWUFBWSxZQUFZLFVBQVUsRUFDbEMsU0FBUyxZQUFZLE9BQU8sRUFDNUIsY0FBYyxNQUFNLE1BQU0sRUFDNUIsSUFBSSxhQUVKO3dCQUNBLElBQUksVUFBVSxDQUFDO3dCQUNmLE9BQVE7NEJBQ04sS0FBSztnQ0FDSCxVQUFVLE1BQU0sVUFBVSxDQUFDO2dDQUMzQixPQUFPLFVBQ0YsV0FBVyxJQUNYLFFBQ0MsQUFBQyxTQUFTLElBQ1YsQ0FBQyxLQUFLLFVBQVUsVUFBVSxLQUFLLFVBQVUsRUFBRTtnQ0FDakQ7NEJBQ0YsS0FBSztnQ0FDSCxXQUFXLE1BQU0sVUFBVSxDQUFDO2dDQUM1QixPQUFPLFlBQ1AsT0FBTyxZQUNQLE9BQU8sWUFDUCxRQUFRLFlBQ1IsT0FBTyxZQUNQLE9BQU8sWUFDUCxRQUFRLFlBQ1IsT0FBTyxZQUNQLFFBQVEsWUFDUixPQUFPLFlBQ1AsUUFBUSxZQUNSLE9BQU8sWUFDUCxRQUFRLFlBQ1IsT0FBTyxXQUNILENBQUMsQUFBQyxTQUFTLFVBQVksV0FBVyxHQUFJLEdBQUcsSUFDekMsQUFBQyxLQUFLLFlBQVksS0FBSyxZQUNyQixRQUFRLFlBQ1IsUUFBUSxXQUNSLENBQUMsQUFBQyxTQUFTLFVBQVksV0FBVyxHQUFJLEdBQUcsSUFDekMsQ0FBQyxBQUFDLFNBQVMsR0FBSyxXQUFXLENBQUU7Z0NBQ25DOzRCQUNGLEtBQUs7Z0NBQ0gsVUFBVSxNQUFNLFVBQVUsQ0FBQztnQ0FDM0IsT0FBTyxVQUNGLFdBQVcsSUFDWCxZQUNDLEFBQUMsYUFBYSxJQUNkLENBQUMsS0FBSyxVQUFVLFVBQVUsS0FBSyxVQUFVLEVBQUU7Z0NBQ2pEOzRCQUNGLEtBQUs7Z0NBQ0gsVUFBVSxNQUFNLE9BQU8sQ0FBQyxNQUFNO2dDQUM5Qjs0QkFDRixLQUFLO2dDQUNILElBQUksT0FBTyxRQUNULE1BQU0sTUFDSjtnQ0FFSixJQUFJLFlBQVksTUFBTSxNQUFNLElBQUksTUFBTSxNQUFNLEdBQUcsSUFBSSxXQUNqRCxNQUFNLE1BQ0o7Z0NBRUosVUFBVSxNQUFNLE1BQU07d0JBQzFCO3dCQUNBLElBQUksQ0FBQyxJQUFJLFNBQVM7NEJBQ2hCLElBQUksSUFBSSxPQUFPLE1BQU0sRUFDbkIsTUFBTSxNQUNKOzRCQUVKLElBQUksTUFBTSxLQUFLLENBQUMsR0FBRzs0QkFDbkIscUJBQXFCLFVBQVUsT0FBTyxRQUFROzRCQUM5QyxJQUFJOzRCQUNKLE1BQU0sWUFBWTs0QkFDbEIsWUFBWSxRQUFRLFNBQVMsV0FBVzs0QkFDeEMsT0FBTyxNQUFNLEdBQUc7d0JBQ2xCLE9BQU8sSUFBSSxNQUFNLE1BQU0sS0FBSyxHQUMxQixNQUFNLE1BQ0o7b0JBRU47b0JBQ0EsWUFBWSxTQUFTLEdBQUc7b0JBQ3hCLFlBQVksTUFBTSxHQUFHO29CQUNyQixZQUFZLE9BQU8sR0FBRztvQkFDdEIsWUFBWSxVQUFVLEdBQUc7Z0JBQzNCO1lBQ0YsT0FBTyxtQkFBbUIsbUJBQW1CLGFBQWE7UUFDNUQ7UUFDQSxPQUFPLEVBQUUsQ0FBQyxTQUFTLFNBQVUsS0FBSztZQUNoQyxrQkFBa0IsbUJBQW1CO1FBQ3ZDO1FBQ0EsT0FBTyxFQUFFLENBQUMsT0FBTztZQUNmLE9BQU8sTUFBTTtRQUNmO1FBQ0EsT0FBTyxRQUFRO0lBQ2pCO0lBQ0EsUUFBUSx3QkFBd0IsR0FBRyxTQUFVLE1BQU0sRUFBRSxPQUFPO1FBQzFELFVBQVUsMEJBQTBCO1FBQ3BDLHVCQUF1QixTQUFTO1FBQ2hDLE9BQU8sUUFBUTtJQUNqQjtJQUNBLFFBQVEscUJBQXFCLEdBQUcsU0FBVSxFQUFFO1FBQzFDLE9BQU8sd0JBQXdCLElBQUk7SUFDckM7SUFDQSxRQUFRLDJCQUEyQixHQUFHO1FBQ3BDLE9BQU8sSUFBSTtJQUNiO0lBQ0EsUUFBUSxXQUFXLEdBQUcsU0FBVSxLQUFLLEVBQUUsT0FBTztRQUM1QyxPQUFPLElBQUksUUFBUSxTQUFVLE9BQU8sRUFBRSxNQUFNO1lBQzFDLElBQUksUUFBUSxhQUNWLE9BQ0EsSUFDQSxXQUFXLFFBQVEsbUJBQW1CLEdBQ2xDLFFBQVEsbUJBQW1CLEdBQzNCLEtBQUssR0FDVCxTQUNBO1lBRUYsSUFBSSxXQUFXLFFBQVEsTUFBTSxFQUFFO2dCQUM3QixJQUFJLFNBQVMsUUFBUSxNQUFNO2dCQUMzQixJQUFJLE9BQU8sT0FBTyxFQUFFLE1BQU0sT0FBTyxNQUFNO3FCQUNsQztvQkFDSCxJQUFJLFdBQVc7d0JBQ2IsTUFBTSxPQUFPLE1BQU07d0JBQ25CLE9BQU8sbUJBQW1CLENBQUMsU0FBUztvQkFDdEM7b0JBQ0EsT0FBTyxnQkFBZ0IsQ0FBQyxTQUFTO2dCQUNuQztZQUNGO1FBQ0Y7SUFDRjtJQUNBLFFBQVEsdUJBQXVCLEdBQUcsU0FDaEMsU0FBUyxFQUNULEVBQUUsRUFDRixnQkFBZ0I7UUFFaEIsNkJBQTZCLFdBQVcsSUFBSSxNQUFNO1FBQ2xELE9BQU87SUFDVDtBQUNGIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDkzMjUsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LXNlcnZlci1kb20tdHVyYm9wYWNrL2NsaWVudC5ub2RlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1zZXJ2ZXItZG9tLXR1cmJvcGFjay1jbGllbnQubm9kZS5wcm9kdWN0aW9uLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LXNlcnZlci1kb20tdHVyYm9wYWNrLWNsaWVudC5ub2RlLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBRUE7O0tBRU87SUFDTCxPQUFPLE9BQU87QUFDaEIiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogOTMzNCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL2xpYi9kZXRhY2hlZC1wcm9taXNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQSBgUHJvbWlzZS53aXRoUmVzb2x2ZXJzYCBpbXBsZW1lbnRhdGlvbiB0aGF0IGV4cG9zZXMgdGhlIGByZXNvbHZlYCBhbmRcbiAqIGByZWplY3RgIGZ1bmN0aW9ucyBvbiBhIGBQcm9taXNlYC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vdGMzOS5lcy9wcm9wb3NhbC1wcm9taXNlLXdpdGgtcmVzb2x2ZXJzL1xuICovXG5leHBvcnQgY2xhc3MgRGV0YWNoZWRQcm9taXNlPFQgPSBhbnk+IHtcbiAgcHVibGljIHJlYWRvbmx5IHJlc29sdmU6ICh2YWx1ZTogVCB8IFByb21pc2VMaWtlPFQ+KSA9PiB2b2lkXG4gIHB1YmxpYyByZWFkb25seSByZWplY3Q6IChyZWFzb246IGFueSkgPT4gdm9pZFxuICBwdWJsaWMgcmVhZG9ubHkgcHJvbWlzZTogUHJvbWlzZTxUPlxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGxldCByZXNvbHZlOiAodmFsdWU6IFQgfCBQcm9taXNlTGlrZTxUPikgPT4gdm9pZFxuICAgIGxldCByZWplY3Q6IChyZWFzb246IGFueSkgPT4gdm9pZFxuXG4gICAgLy8gQ3JlYXRlIHRoZSBwcm9taXNlIGFuZCBhc3NpZ24gdGhlIHJlc29sdmVycyB0byB0aGUgb2JqZWN0LlxuICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlPFQ+KChyZXMsIHJlaikgPT4ge1xuICAgICAgcmVzb2x2ZSA9IHJlc1xuICAgICAgcmVqZWN0ID0gcmVqXG4gICAgfSlcblxuICAgIC8vIFdlIGtub3cgdGhhdCByZXNvbHZlcnMgaXMgZGVmaW5lZCBiZWNhdXNlIHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHJ1bnNcbiAgICAvLyBzeW5jaHJvbm91c2x5LlxuICAgIHRoaXMucmVzb2x2ZSA9IHJlc29sdmUhXG4gICAgdGhpcy5yZWplY3QgPSByZWplY3QhXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJEZXRhY2hlZFByb21pc2UiLCJjb25zdHJ1Y3RvciIsInJlc29sdmUiLCJyZWplY3QiLCJwcm9taXNlIiwiUHJvbWlzZSIsInJlcyIsInJlaiJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7O0NBS0MsR0FDRDs7O0FBQU8sTUFBTUE7SUFLWEMsYUFBYztRQUNaLElBQUlDO1FBQ0osSUFBSUM7UUFFSiw2REFBNkQ7UUFDN0QsSUFBSSxDQUFDQyxPQUFPLEdBQUcsSUFBSUMsUUFBVyxDQUFDQyxLQUFLQztZQUNsQ0wsVUFBVUk7WUFDVkgsU0FBU0k7UUFDWDtRQUVBLHlFQUF5RTtRQUN6RSxpQkFBaUI7UUFDakIsSUFBSSxDQUFDTCxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDQyxNQUFNLEdBQUdBO0lBQ2hCO0FBQ0YiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogOTM2MSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL3NlcnZlci9zdHJlYW0tdXRpbHMvZW5jb2RlZC10YWdzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBFTkNPREVEX1RBR1MgPSB7XG4gIC8vIG9wZW5pbmcgdGFncyBkbyBub3QgaGF2ZSB0aGUgY2xvc2luZyBgPmAgc2luY2UgdGhleSBjYW4gY29udGFpbiBvdGhlciBhdHRyaWJ1dGVzIHN1Y2ggYXMgYDxib2R5IGNsYXNzTmFtZT0nJz5gXG4gIE9QRU5JTkc6IHtcbiAgICAvLyA8aHRtbFxuICAgIEhUTUw6IG5ldyBVaW50OEFycmF5KFs2MCwgMTA0LCAxMTYsIDEwOSwgMTA4XSksXG4gICAgLy8gPGJvZHlcbiAgICBCT0RZOiBuZXcgVWludDhBcnJheShbNjAsIDk4LCAxMTEsIDEwMCwgMTIxXSksXG4gIH0sXG4gIENMT1NFRDoge1xuICAgIC8vIDwvaGVhZD5cbiAgICBIRUFEOiBuZXcgVWludDhBcnJheShbNjAsIDQ3LCAxMDQsIDEwMSwgOTcsIDEwMCwgNjJdKSxcbiAgICAvLyA8L2JvZHk+XG4gICAgQk9EWTogbmV3IFVpbnQ4QXJyYXkoWzYwLCA0NywgOTgsIDExMSwgMTAwLCAxMjEsIDYyXSksXG4gICAgLy8gPC9odG1sPlxuICAgIEhUTUw6IG5ldyBVaW50OEFycmF5KFs2MCwgNDcsIDEwNCwgMTE2LCAxMDksIDEwOCwgNjJdKSxcbiAgICAvLyA8L2JvZHk+PC9odG1sPlxuICAgIEJPRFlfQU5EX0hUTUw6IG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDYwLCA0NywgOTgsIDExMSwgMTAwLCAxMjEsIDYyLCA2MCwgNDcsIDEwNCwgMTE2LCAxMDksIDEwOCwgNjIsXG4gICAgXSksXG4gIH0sXG4gIE1FVEE6IHtcbiAgICAvLyBPbmx5IHRoZSBtYXRjaCB0aGUgcHJlZml4IGNhdXNlIHRoZSBzdWZmaXggY2FuIGJlIGRpZmZlcmVudCB3ZXRoZXIgaXQncyB4bWwgY29tcGF0aWJsZSBvciBub3QgXCI+XCIgb3IgXCIvPlwiXG4gICAgLy8gPG1ldGEgbmFtZT1cIsKrbnh0LWljb27Cu1wiXG4gICAgLy8gVGhpcyBpcyBhIHNwZWNpYWwgbWFyayB0aGF0IHdpbGwgYmUgcmVwbGFjZWQgYnkgdGhlIGljb24gaW5zZXJ0aW9uIHNjcmlwdCB0YWcuXG4gICAgSUNPTl9NQVJLOiBuZXcgVWludDhBcnJheShbXG4gICAgICA2MCwgMTA5LCAxMDEsIDExNiwgOTcsIDMyLCAxMTAsIDk3LCAxMDksIDEwMSwgNjEsIDM0LCAxOTQsIDE3MSwgMTEwLCAxMjAsXG4gICAgICAxMTYsIDQ1LCAxMDUsIDk5LCAxMTEsIDExMCwgMTk0LCAxODcsIDM0LFxuICAgIF0pLFxuICB9LFxufSBhcyBjb25zdFxuIl0sIm5hbWVzIjpbIkVOQ09ERURfVEFHUyIsIk9QRU5JTkciLCJIVE1MIiwiVWludDhBcnJheSIsIkJPRFkiLCJDTE9TRUQiLCJIRUFEIiwiQk9EWV9BTkRfSFRNTCIsIk1FVEEiLCJJQ09OX01BUksiXSwibWFwcGluZ3MiOiI7OztBQUFPLE1BQU1BLGVBQWU7SUFDMUIsaUhBQWlIO0lBQ2pIQyxTQUFTO1FBQ1AsUUFBUTtRQUNSQyxNQUFNLElBQUlDLFdBQVc7WUFBQztZQUFJO1lBQUs7WUFBSztZQUFLO1NBQUk7UUFDN0MsUUFBUTtRQUNSQyxNQUFNLElBQUlELFdBQVc7WUFBQztZQUFJO1lBQUk7WUFBSztZQUFLO1NBQUk7SUFDOUM7SUFDQUUsUUFBUTtRQUNOLFVBQVU7UUFDVkMsTUFBTSxJQUFJSCxXQUFXO1lBQUM7WUFBSTtZQUFJO1lBQUs7WUFBSztZQUFJO1lBQUs7U0FBRztRQUNwRCxVQUFVO1FBQ1ZDLE1BQU0sSUFBSUQsV0FBVztZQUFDO1lBQUk7WUFBSTtZQUFJO1lBQUs7WUFBSztZQUFLO1NBQUc7UUFDcEQsVUFBVTtRQUNWRCxNQUFNLElBQUlDLFdBQVc7WUFBQztZQUFJO1lBQUk7WUFBSztZQUFLO1lBQUs7WUFBSztTQUFHO1FBQ3JELGlCQUFpQjtRQUNqQkksZUFBZSxJQUFJSixXQUFXO1lBQzVCO1lBQUk7WUFBSTtZQUFJO1lBQUs7WUFBSztZQUFLO1lBQUk7WUFBSTtZQUFJO1lBQUs7WUFBSztZQUFLO1lBQUs7U0FDNUQ7SUFDSDtJQUNBSyxNQUFNO1FBQ0osNEdBQTRHO1FBQzVHLDBCQUEwQjtRQUMxQixpRkFBaUY7UUFDakZDLFdBQVcsSUFBSU4sV0FBVztZQUN4QjtZQUFJO1lBQUs7WUFBSztZQUFLO1lBQUk7WUFBSTtZQUFLO1lBQUk7WUFBSztZQUFLO1lBQUk7WUFBSTtZQUFLO1lBQUs7WUFBSztZQUNyRTtZQUFLO1lBQUk7WUFBSztZQUFJO1lBQUs7WUFBSztZQUFLO1lBQUs7U0FDdkM7SUFDSDtBQUNGLEVBQVUiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogOTQ3MCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL3NlcnZlci9zdHJlYW0tdXRpbHMvdWludDhhcnJheS1oZWxwZXJzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRmluZCB0aGUgc3RhcnRpbmcgaW5kZXggb2YgVWludDhBcnJheSBgYmAgd2l0aGluIFVpbnQ4QXJyYXkgYGFgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5kZXhPZlVpbnQ4QXJyYXkoYTogVWludDhBcnJheSwgYjogVWludDhBcnJheSkge1xuICBpZiAoYi5sZW5ndGggPT09IDApIHJldHVybiAwXG4gIGlmIChhLmxlbmd0aCA9PT0gMCB8fCBiLmxlbmd0aCA+IGEubGVuZ3RoKSByZXR1cm4gLTFcblxuICAvLyBzdGFydCBpdGVyYXRpbmcgdGhyb3VnaCBgYWBcbiAgZm9yIChsZXQgaSA9IDA7IGkgPD0gYS5sZW5ndGggLSBiLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IGNvbXBsZXRlTWF0Y2ggPSB0cnVlXG4gICAgLy8gZnJvbSBpbmRleCBgaWAsIGl0ZXJhdGUgdGhyb3VnaCBgYmAgYW5kIGNoZWNrIGZvciBtaXNtYXRjaFxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgYi5sZW5ndGg7IGorKykge1xuICAgICAgLy8gaWYgdGhlIHZhbHVlcyBkbyBub3QgbWF0Y2gsIHRoZW4gdGhpcyBpc24ndCBhIGNvbXBsZXRlIG1hdGNoLCBleGl0IGBiYCBpdGVyYXRpb24gZWFybHkgYW5kIGl0ZXJhdGUgdG8gbmV4dCBpbmRleCBvZiBgYWAuXG4gICAgICBpZiAoYVtpICsgal0gIT09IGJbal0pIHtcbiAgICAgICAgY29tcGxldGVNYXRjaCA9IGZhbHNlXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvbXBsZXRlTWF0Y2gpIHtcbiAgICAgIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIFVpbnQ4QXJyYXlzIGFyZSBzdHJpY3RseSBlcXVpdmFsZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNFcXVpdmFsZW50VWludDhBcnJheXMoYTogVWludDhBcnJheSwgYjogVWludDhBcnJheSkge1xuICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2VcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG4vKipcbiAqIFJlbW92ZSBVaW50OEFycmF5IGBiYCBmcm9tIFVpbnQ4QXJyYXkgYGFgLlxuICpcbiAqIElmIGBiYCBpcyBub3QgaW4gYGFgLCBgYWAgaXMgcmV0dXJuZWQgdW5jaGFuZ2VkLlxuICpcbiAqIE90aGVyd2lzZSwgdGhlIGZ1bmN0aW9uIHJldHVybnMgYSBuZXcgVWludDhBcnJheSBpbnN0YW5jZSB3aXRoIHNpemUgYGEubGVuZ3RoIC0gYi5sZW5ndGhgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVGcm9tVWludDhBcnJheShhOiBVaW50OEFycmF5LCBiOiBVaW50OEFycmF5KSB7XG4gIGNvbnN0IHRhZ0luZGV4ID0gaW5kZXhPZlVpbnQ4QXJyYXkoYSwgYilcbiAgaWYgKHRhZ0luZGV4ID09PSAwKSByZXR1cm4gYS5zdWJhcnJheShiLmxlbmd0aClcbiAgaWYgKHRhZ0luZGV4ID4gLTEpIHtcbiAgICBjb25zdCByZW1vdmVkID0gbmV3IFVpbnQ4QXJyYXkoYS5sZW5ndGggLSBiLmxlbmd0aClcbiAgICByZW1vdmVkLnNldChhLnNsaWNlKDAsIHRhZ0luZGV4KSlcbiAgICByZW1vdmVkLnNldChhLnNsaWNlKHRhZ0luZGV4ICsgYi5sZW5ndGgpLCB0YWdJbmRleClcbiAgICByZXR1cm4gcmVtb3ZlZFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBhXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJpbmRleE9mVWludDhBcnJheSIsImEiLCJiIiwibGVuZ3RoIiwiaSIsImNvbXBsZXRlTWF0Y2giLCJqIiwiaXNFcXVpdmFsZW50VWludDhBcnJheXMiLCJyZW1vdmVGcm9tVWludDhBcnJheSIsInRhZ0luZGV4Iiwic3ViYXJyYXkiLCJyZW1vdmVkIiwiVWludDhBcnJheSIsInNldCIsInNsaWNlIl0sIm1hcHBpbmdzIjoiQUFBQTs7Q0FFQyxHQUNEOzs7OztBQUFPLFNBQVNBLGtCQUFrQkMsQ0FBYSxFQUFFQyxDQUFhO0lBQzVELElBQUlBLEVBQUVDLE1BQU0sS0FBSyxHQUFHLE9BQU87SUFDM0IsSUFBSUYsRUFBRUUsTUFBTSxLQUFLLEtBQUtELEVBQUVDLE1BQU0sR0FBR0YsRUFBRUUsTUFBTSxFQUFFLE9BQU8sQ0FBQztJQUVuRCw4QkFBOEI7SUFDOUIsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLEtBQUtILEVBQUVFLE1BQU0sR0FBR0QsRUFBRUMsTUFBTSxFQUFFQyxJQUFLO1FBQzdDLElBQUlDLGdCQUFnQjtRQUNwQiw2REFBNkQ7UUFDN0QsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlKLEVBQUVDLE1BQU0sRUFBRUcsSUFBSztZQUNqQywySEFBMkg7WUFDM0gsSUFBSUwsQ0FBQyxDQUFDRyxJQUFJRSxFQUFFLEtBQUtKLENBQUMsQ0FBQ0ksRUFBRSxFQUFFO2dCQUNyQkQsZ0JBQWdCO2dCQUNoQjtZQUNGO1FBQ0Y7UUFFQSxJQUFJQSxlQUFlO1lBQ2pCLE9BQU9EO1FBQ1Q7SUFDRjtJQUVBLE9BQU8sQ0FBQztBQUNWO0FBS08sU0FBU0csd0JBQXdCTixDQUFhLEVBQUVDLENBQWE7SUFDbEUsSUFBSUQsRUFBRUUsTUFBTSxLQUFLRCxFQUFFQyxNQUFNLEVBQUUsT0FBTztJQUVsQyxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUgsRUFBRUUsTUFBTSxFQUFFQyxJQUFLO1FBQ2pDLElBQUlILENBQUMsQ0FBQ0csRUFBRSxLQUFLRixDQUFDLENBQUNFLEVBQUUsRUFBRSxPQUFPO0lBQzVCO0lBRUEsT0FBTztBQUNUO0FBU08sU0FBU0kscUJBQXFCUCxDQUFhLEVBQUVDLENBQWE7SUFDL0QsTUFBTU8sV0FBV1Qsa0JBQWtCQyxHQUFHQztJQUN0QyxJQUFJTyxhQUFhLEdBQUcsT0FBT1IsRUFBRVMsUUFBUSxDQUFDUixFQUFFQyxNQUFNO0lBQzlDLElBQUlNLFdBQVcsQ0FBQyxHQUFHO1FBQ2pCLE1BQU1FLFVBQVUsSUFBSUMsV0FBV1gsRUFBRUUsTUFBTSxHQUFHRCxFQUFFQyxNQUFNO1FBQ2xEUSxRQUFRRSxHQUFHLENBQUNaLEVBQUVhLEtBQUssQ0FBQyxHQUFHTDtRQUN2QkUsUUFBUUUsR0FBRyxDQUFDWixFQUFFYSxLQUFLLENBQUNMLFdBQVdQLEVBQUVDLE1BQU0sR0FBR007UUFDMUMsT0FBT0U7SUFDVCxPQUFPO1FBQ0wsT0FBT1Y7SUFDVDtBQUNGIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDk1MjAsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NyYy9zaGFyZWQvbGliL2Vycm9ycy9jb25zdGFudHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IE1JU1NJTkdfUk9PVF9UQUdTX0VSUk9SID0gJ05FWFRfTUlTU0lOR19ST09UX1RBR1MnXG4iXSwibmFtZXMiOlsiTUlTU0lOR19ST09UX1RBR1NfRVJST1IiXSwibWFwcGluZ3MiOiI7OztBQUFPLE1BQU1BLDBCQUEwQix5QkFBd0IiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogOTUyOCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL3NoYXJlZC9saWIvc2VnbWVudC1jYWNoZS9vdXRwdXQtZXhwb3J0LXByZWZldGNoLWVuY29kaW5nLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEluIG91dHB1dDogZXhwb3J0IG1vZGUsIHRoZSBidWlsZCBpZCBpcyBhZGRlZCB0byB0aGUgc3RhcnQgb2YgdGhlIEhUTUxcbi8vIGRvY3VtZW50LCBkaXJlY3RseSBhZnRlciB0aGUgZG9jdHlwZSBkZWNsYXJhdGlvbi4gRHVyaW5nIGEgcHJlZmV0Y2gsIHRoZVxuLy8gY2xpZW50IHBlcmZvcm1zIGEgcmFuZ2UgcmVxdWVzdCB0byBnZXQgdGhlIGJ1aWxkIGlkLCBzbyBpdCBjYW4gY2hlY2sgd2hldGhlclxuLy8gdGhlIHRhcmdldCBwYWdlIGJlbG9uZ3MgdG8gdGhlIHNhbWUgYnVpbGQuXG4vL1xuLy8gVGhlIGZpcnN0IDY0IGJ5dGVzIG9mIHRoZSBkb2N1bWVudCBhcmUgcmVxdWVzdGVkLiBUaGUgZXhhY3QgbnVtYmVyIGlzbid0XG4vLyB0b28gaW1wb3J0YW50OyBpdCBtdXN0IGJlIGxhcmdlciB0aGFuIHRoZSBidWlsZCBpZCArIGRvY3R5cGUgKyBjbG9zaW5nIGFuZFxuLy8gZW5kaW5nIGNvbW1lbnQgbWFya2VycywgYnV0IGl0IGRvZXNuJ3QgbmVlZCB0byBtYXRjaCB0aGUgZW5kIG9mIHRoZVxuLy8gY29tbWVudCBleGFjdGx5LlxuLy9cbi8vIEJ1aWxkIGlkcyBhcmUgMjEgYnl0ZXMgbG9uZyBpbiB0aGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiwgdGhvdWdoIHRoaXNcbi8vIGNhbiBiZSBvdmVycmlkZGVuIGluIHRoZSBOZXh0LmpzIGNvbmZpZy4gRm9yIHRoZSBwdXJwb3NlcyBvZiB0aGlzIGNoZWNrLFxuLy8gaXQncyBPSyB0byBvbmx5IG1hdGNoIHRoZSBzdGFydCBvZiB0aGUgaWQsIHNvIHdlJ2xsIHRydW5jYXRlIGl0IGlmIGV4Y2VlZHNcbi8vIGEgY2VydGFpbiBsZW5ndGguXG5cbmNvbnN0IERPQ1RZUEVfUFJFRklYID0gJzwhRE9DVFlQRSBodG1sPicgLy8gMTUgYnl0ZXNcbmNvbnN0IE1BWF9CVUlMRF9JRF9MRU5HVEggPSAyNFxuXG4vLyBSZXF1ZXN0IHRoZSBmaXJzdCA2NCBieXRlcy4gVGhlIFJhbmdlIGhlYWRlciBpcyBpbmNsdXNpdmUgb2YgdGhlIGVuZCB2YWx1ZS5cbmV4cG9ydCBjb25zdCBET0NfUFJFRkVUQ0hfUkFOR0VfSEVBREVSX1ZBTFVFID0gJ2J5dGVzPTAtNjMnXG5cbmZ1bmN0aW9uIGVzY2FwZUJ1aWxkSWQoYnVpbGRJZDogc3RyaW5nKSB7XG4gIC8vIElmIHRoZSBidWlsZCBpZCBpcyBsb25nZXIgdGhhbiB0aGUgZ2l2ZW4gbGltaXQsIGl0J3MgT0sgZm9yIG91ciBwdXJwb3Nlc1xuICAvLyB0byBvbmx5IG1hdGNoIHRoZSBiZWdpbm5pbmcuXG4gIGNvbnN0IHRydW5jYXRlZCA9IGJ1aWxkSWQuc2xpY2UoMCwgTUFYX0JVSUxEX0lEX0xFTkdUSClcbiAgLy8gUmVwbGFjZSBoeXBoZW5zIHdpdGggdW5kZXJzY29yZXMgc28gaXQgZG9lc24ndCBicmVhayB0aGUgSFRNTCBjb21tZW50LlxuICAvLyAoVW5saWtlbHksIGJ1dCBpZiB0aGlzIGRpZCBoYXBwZW4gaXQgd291bGQgYnJlYWsgdGhlIHdob2xlIGRvY3VtZW50LilcbiAgcmV0dXJuIHRydW5jYXRlZC5yZXBsYWNlKC8tL2csICdfJylcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluc2VydEJ1aWxkSWRDb21tZW50KG9yaWdpbmFsSHRtbDogc3RyaW5nLCBidWlsZElkOiBzdHJpbmcpIHtcbiAgaWYgKFxuICAgIC8vIFNraXAgaWYgdGhlIGJ1aWxkIGlkIGNvbnRhaW5zIGEgY2xvc2luZyBjb21tZW50IG1hcmtlci5cbiAgICBidWlsZElkLmluY2x1ZGVzKCctLT4nKSB8fFxuICAgIC8vIFJlYWN0IGFsd2F5cyBpbnNlcnRzIGEgZG9jdHlwZSBhdCB0aGUgc3RhcnQgb2YgdGhlIGRvY3VtZW50LiBTa2lwIGlmIGl0XG4gICAgLy8gaXNuJ3QgcHJlc2VudC4gU2hvdWxkbid0IGhhcHBlbjsgc3VnZ2VzdHMgYW4gaXNzdWUgZWxzZXdoZXJlLlxuICAgICFvcmlnaW5hbEh0bWwuc3RhcnRzV2l0aChET0NUWVBFX1BSRUZJWClcbiAgKSB7XG4gICAgLy8gUmV0dXJuIHRoZSBvcmlnaW5hbCBIVE1MIHVuY2hhbmdlZC4gVGhpcyBtZWFucyB0aGUgZG9jdW1lbnQgd2lsbCBub3RcbiAgICAvLyBiZSBwcmVmZXRjaGVkLlxuICAgIC8vIFRPRE86IFRoZSBidWlsZCBpZCBjb21tZW50IGlzIGN1cnJlbnRseSBvbmx5IHVzZWQgZHVyaW5nIHByZWZldGNoZXMsIGJ1dFxuICAgIC8vIGlmIHdlIGV2ZW50dWFsbHkgdXNlIHRoaXMgbWVjaGFuaXNtIGZvciByZWd1bGFyIG5hdmlnYXRpb25zLCB3ZSBtYXkgbmVlZFxuICAgIC8vIHRvIGVycm9yIGR1cmluZyBidWlsZCBpZiB3ZSBmYWlsIHRvIGluc2VydCBpdCBmb3Igc29tZSByZWFzb24uXG4gICAgcmV0dXJuIG9yaWdpbmFsSHRtbFxuICB9XG4gIC8vIFRoZSBjb21tZW50IG11c3QgYmUgaW5zZXJ0ZWQgYWZ0ZXIgdGhlIGRvY3R5cGUuXG4gIHJldHVybiBvcmlnaW5hbEh0bWwucmVwbGFjZShcbiAgICBET0NUWVBFX1BSRUZJWCxcbiAgICBET0NUWVBFX1BSRUZJWCArICc8IS0tJyArIGVzY2FwZUJ1aWxkSWQoYnVpbGRJZCkgKyAnLS0+J1xuICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkb2VzRXhwb3J0ZWRIdG1sTWF0Y2hCdWlsZElkKFxuICBwYXJ0aWFsSHRtbERvY3VtZW50OiBzdHJpbmcsXG4gIGJ1aWxkSWQ6IHN0cmluZ1xuKSB7XG4gIC8vIENoZWNrIHdoZXRoZXIgdGhlIGRvY3VtZW50IHN0YXJ0cyB3aXRoIHRoZSBleHBlY3RlZCBidWlsZElkLlxuICByZXR1cm4gcGFydGlhbEh0bWxEb2N1bWVudC5zdGFydHNXaXRoKFxuICAgIERPQ1RZUEVfUFJFRklYICsgJzwhLS0nICsgZXNjYXBlQnVpbGRJZChidWlsZElkKSArICctLT4nXG4gIClcbn1cbiJdLCJuYW1lcyI6WyJET0NUWVBFX1BSRUZJWCIsIk1BWF9CVUlMRF9JRF9MRU5HVEgiLCJET0NfUFJFRkVUQ0hfUkFOR0VfSEVBREVSX1ZBTFVFIiwiZXNjYXBlQnVpbGRJZCIsImJ1aWxkSWQiLCJ0cnVuY2F0ZWQiLCJzbGljZSIsInJlcGxhY2UiLCJpbnNlcnRCdWlsZElkQ29tbWVudCIsIm9yaWdpbmFsSHRtbCIsImluY2x1ZGVzIiwic3RhcnRzV2l0aCIsImRvZXNFeHBvcnRlZEh0bWxNYXRjaEJ1aWxkSWQiLCJwYXJ0aWFsSHRtbERvY3VtZW50Il0sIm1hcHBpbmdzIjoiQUFBQSx5RUFBeUU7QUFDekUsMkVBQTJFO0FBQzNFLCtFQUErRTtBQUMvRSw2Q0FBNkM7QUFDN0MsRUFBRTtBQUNGLDJFQUEyRTtBQUMzRSw2RUFBNkU7QUFDN0Usc0VBQXNFO0FBQ3RFLG1CQUFtQjtBQUNuQixFQUFFO0FBQ0YseUVBQXlFO0FBQ3pFLDJFQUEyRTtBQUMzRSw2RUFBNkU7QUFDN0Usb0JBQW9COzs7Ozs7QUFFcEIsTUFBTUEsaUJBQWlCLGtCQUFrQixXQUFXOztBQUNwRCxNQUFNQyxzQkFBc0I7QUFHckIsTUFBTUMsa0NBQWtDLGFBQVk7QUFFM0QsU0FBU0MsY0FBY0MsT0FBZTtJQUNwQywyRUFBMkU7SUFDM0UsK0JBQStCO0lBQy9CLE1BQU1DLFlBQVlELFFBQVFFLEtBQUssQ0FBQyxHQUFHTDtJQUNuQyx5RUFBeUU7SUFDekUsd0VBQXdFO0lBQ3hFLE9BQU9JLFVBQVVFLE9BQU8sQ0FBQyxNQUFNO0FBQ2pDO0FBRU8sU0FBU0MscUJBQXFCQyxZQUFvQixFQUFFTCxPQUFlO0lBQ3hFLElBRUVBLEFBREEsUUFDUU0sUUFBUSxDQUFDLFVBQ2pCLCtCQUYwRCwyQ0FFZ0I7SUFDMUUsZ0VBQWdFO0lBQ2hFLENBQUNELGFBQWFFLFVBQVUsQ0FBQ1gsaUJBQ3pCO1FBQ0EsdUVBQXVFO1FBQ3ZFLGlCQUFpQjtRQUNqQiwyRUFBMkU7UUFDM0UsMkVBQTJFO1FBQzNFLGlFQUFpRTtRQUNqRSxPQUFPUztJQUNUO0lBQ0Esa0RBQWtEO0lBQ2xELE9BQU9BLGFBQWFGLE9BQU8sQ0FDekJQLGdCQUNBQSxpQkFBaUIsU0FBU0csY0FBY0MsV0FBVztBQUV2RDtBQUVPLFNBQVNRLDZCQUNkQyxtQkFBMkIsRUFDM0JULE9BQWU7SUFFZiwrREFBK0Q7SUFDL0QsT0FBT1Msb0JBQW9CRixVQUFVLENBQ25DWCxpQkFBaUIsU0FBU0csY0FBY0MsV0FBVztBQUV2RCIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA5NTgxLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zcmMvc2VydmVyL3N0cmVhbS11dGlscy9ub2RlLXdlYi1zdHJlYW1zLWhlbHBlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRUcmFjZXIgfSBmcm9tICcuLi9saWIvdHJhY2UvdHJhY2VyJ1xuaW1wb3J0IHsgQXBwUmVuZGVyU3BhbiB9IGZyb20gJy4uL2xpYi90cmFjZS9jb25zdGFudHMnXG5pbXBvcnQgeyBEZXRhY2hlZFByb21pc2UgfSBmcm9tICcuLi8uLi9saWIvZGV0YWNoZWQtcHJvbWlzZSdcbmltcG9ydCB7IHNjaGVkdWxlSW1tZWRpYXRlLCBhdExlYXN0T25lVGFzayB9IGZyb20gJy4uLy4uL2xpYi9zY2hlZHVsZXInXG5pbXBvcnQgeyBFTkNPREVEX1RBR1MgfSBmcm9tICcuL2VuY29kZWQtdGFncydcbmltcG9ydCB7XG4gIGluZGV4T2ZVaW50OEFycmF5LFxuICBpc0VxdWl2YWxlbnRVaW50OEFycmF5cyxcbiAgcmVtb3ZlRnJvbVVpbnQ4QXJyYXksXG59IGZyb20gJy4vdWludDhhcnJheS1oZWxwZXJzJ1xuaW1wb3J0IHsgTUlTU0lOR19ST09UX1RBR1NfRVJST1IgfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL2Vycm9ycy9jb25zdGFudHMnXG5pbXBvcnQgeyBpbnNlcnRCdWlsZElkQ29tbWVudCB9IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvc2VnbWVudC1jYWNoZS9vdXRwdXQtZXhwb3J0LXByZWZldGNoLWVuY29kaW5nJ1xuXG5mdW5jdGlvbiB2b2lkQ2F0Y2goKSB7XG4gIC8vIHRoaXMgY2F0Y2hlciBpcyBkZXNpZ25lZCB0byBiZSB1c2VkIHdpdGggcGlwZVRvIHdoZXJlIHdlIGV4cGVjdCB0aGUgdW5kZXJseWluZ1xuICAvLyBwaXBlIGltcGxlbWVudGF0aW9uIHRvIGZvcndhcmQgZXJyb3JzIGJ1dCB3ZSBkb24ndCB3YW50IHRoZSBwaXBlVG8gcHJvbWlzZSB0byByZWplY3RcbiAgLy8gYW5kIGJlIHVuaGFuZGxlZFxufVxuXG5leHBvcnQgdHlwZSBSZWFjdFJlYWRhYmxlU3RyZWFtID0gUmVhZGFibGVTdHJlYW08VWludDhBcnJheT4gJiB7XG4gIGFsbFJlYWR5PzogUHJvbWlzZTx2b2lkPiB8IHVuZGVmaW5lZFxufVxuXG4vLyBXZSBjYW4gc2hhcmUgdGhlIHNhbWUgZW5jb2RlciBpbnN0YW5jZSBldmVyeXdoZXJlXG4vLyBOb3RhYmx5IHdlIGNhbm5vdCBkbyB0aGUgc2FtZSBmb3IgVGV4dERlY29kZXIgYmVjYXVzZSBpdCBpcyBzdGF0ZWZ1bFxuLy8gd2hlbiBoYW5kbGluZyBzdHJlYW1pbmcgZGF0YVxuY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpXG5cbmV4cG9ydCBmdW5jdGlvbiBjaGFpblN0cmVhbXM8VD4oXG4gIC4uLnN0cmVhbXM6IFJlYWRhYmxlU3RyZWFtPFQ+W11cbik6IFJlYWRhYmxlU3RyZWFtPFQ+IHtcbiAgLy8gV2UgY291bGQgZW5jb2RlIHRoaXMgaW52YXJpYW50IGluIHRoZSBhcmd1bWVudHMgYnV0IGN1cnJlbnQgdXNlcyBvZiB0aGlzIGZ1bmN0aW9uIHBhc3NcbiAgLy8gdXNlIHNwcmVhZCBzbyBpdCB3b3VsZCBiZSBtaXNzZWQgYnlcbiAgaWYgKHN0cmVhbXMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhcmlhbnQ6IGNoYWluU3RyZWFtcyByZXF1aXJlcyBhdCBsZWFzdCBvbmUgc3RyZWFtJylcbiAgfVxuXG4gIC8vIElmIHdlIG9ubHkgaGF2ZSAxIHN0cmVhbSB3ZSBmYXN0IHBhdGggaXQgYnkgcmV0dXJuaW5nIGp1c3QgdGhpcyBzdHJlYW1cbiAgaWYgKHN0cmVhbXMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHN0cmVhbXNbMF1cbiAgfVxuXG4gIGNvbnN0IHsgcmVhZGFibGUsIHdyaXRhYmxlIH0gPSBuZXcgVHJhbnNmb3JtU3RyZWFtKClcblxuICAvLyBXZSBhbHdheXMgaW5pdGlhdGUgcGlwZVRvIGltbWVkaWF0ZWx5LiBXZSBrbm93IHdlIGhhdmUgYXQgbGVhc3QgMiBzdHJlYW1zXG4gIC8vIHNvIHdlIG5lZWQgdG8gYXZvaWQgY2xvc2luZyB0aGUgd3JpdGFibGUgd2hlbiB0aGlzIG9uZSBmaW5pc2hlcy5cbiAgbGV0IHByb21pc2UgPSBzdHJlYW1zWzBdLnBpcGVUbyh3cml0YWJsZSwgeyBwcmV2ZW50Q2xvc2U6IHRydWUgfSlcblxuICBsZXQgaSA9IDFcbiAgZm9yICg7IGkgPCBzdHJlYW1zLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIGNvbnN0IG5leHRTdHJlYW0gPSBzdHJlYW1zW2ldXG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbigoKSA9PlxuICAgICAgbmV4dFN0cmVhbS5waXBlVG8od3JpdGFibGUsIHsgcHJldmVudENsb3NlOiB0cnVlIH0pXG4gICAgKVxuICB9XG5cbiAgLy8gV2UgY2FuIG9taXQgdGhlIGxlbmd0aCBjaGVjayBiZWNhdXNlIHdlIGhhbHRlZCBiZWZvcmUgdGhlIGxhc3Qgc3RyZWFtIGFuZCB0aGVyZVxuICAvLyBpcyBhdCBsZWFzdCB0d28gc3RyZWFtcyBzbyB0aGUgbGFzdFN0cmVhbSBoZXJlIHdpbGwgYWx3YXlzIGJlIGRlZmluZWRcbiAgY29uc3QgbGFzdFN0cmVhbSA9IHN0cmVhbXNbaV1cbiAgcHJvbWlzZSA9IHByb21pc2UudGhlbigoKSA9PiBsYXN0U3RyZWFtLnBpcGVUbyh3cml0YWJsZSkpXG5cbiAgLy8gQ2F0Y2ggYW55IGVycm9ycyBmcm9tIHRoZSBzdHJlYW1zIGFuZCBpZ25vcmUgdGhlbSwgdGhleSB3aWxsIGJlIGhhbmRsZWRcbiAgLy8gYnkgd2hhdGV2ZXIgaXMgY29uc3VtaW5nIHRoZSByZWFkYWJsZSBzdHJlYW0uXG4gIHByb21pc2UuY2F0Y2godm9pZENhdGNoKVxuXG4gIHJldHVybiByZWFkYWJsZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RyZWFtRnJvbVN0cmluZyhzdHI6IHN0cmluZyk6IFJlYWRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+IHtcbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGVuY29kZXIuZW5jb2RlKHN0cikpXG4gICAgICBjb250cm9sbGVyLmNsb3NlKClcbiAgICB9LFxuICB9KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RyZWFtRnJvbUJ1ZmZlcihjaHVuazogQnVmZmVyKTogUmVhZGFibGVTdHJlYW08VWludDhBcnJheT4ge1xuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspXG4gICAgICBjb250cm9sbGVyLmNsb3NlKClcbiAgICB9LFxuICB9KVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc3RyZWFtVG9CdWZmZXIoXG4gIHN0cmVhbTogUmVhZGFibGVTdHJlYW08VWludDhBcnJheT5cbik6IFByb21pc2U8QnVmZmVyPiB7XG4gIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKVxuICBjb25zdCBjaHVua3M6IFVpbnQ4QXJyYXlbXSA9IFtdXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpXG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgY2h1bmtzLnB1c2godmFsdWUpXG4gIH1cblxuICByZXR1cm4gQnVmZmVyLmNvbmNhdChjaHVua3MpXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzdHJlYW1Ub1N0cmluZyhcbiAgc3RyZWFtOiBSZWFkYWJsZVN0cmVhbTxVaW50OEFycmF5PixcbiAgc2lnbmFsPzogQWJvcnRTaWduYWxcbik6IFByb21pc2U8c3RyaW5nPiB7XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoJ3V0Zi04JywgeyBmYXRhbDogdHJ1ZSB9KVxuICBsZXQgc3RyaW5nID0gJydcblxuICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgIGlmIChzaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgIHJldHVybiBzdHJpbmdcbiAgICB9XG5cbiAgICBzdHJpbmcgKz0gZGVjb2Rlci5kZWNvZGUoY2h1bmssIHsgc3RyZWFtOiB0cnVlIH0pXG4gIH1cblxuICBzdHJpbmcgKz0gZGVjb2Rlci5kZWNvZGUoKVxuXG4gIHJldHVybiBzdHJpbmdcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlcmVkVHJhbnNmb3JtU3RyZWFtKCk6IFRyYW5zZm9ybVN0cmVhbTxcbiAgVWludDhBcnJheSxcbiAgVWludDhBcnJheVxuPiB7XG4gIGxldCBidWZmZXJlZENodW5rczogQXJyYXk8VWludDhBcnJheT4gPSBbXVxuICBsZXQgYnVmZmVyQnl0ZUxlbmd0aDogbnVtYmVyID0gMFxuICBsZXQgcGVuZGluZzogRGV0YWNoZWRQcm9taXNlPHZvaWQ+IHwgdW5kZWZpbmVkXG5cbiAgY29uc3QgZmx1c2ggPSAoY29udHJvbGxlcjogVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIpID0+IHtcbiAgICAvLyBJZiB3ZSBhbHJlYWR5IGhhdmUgYSBwZW5kaW5nIGZsdXNoLCB0aGVuIHJldHVybiBlYXJseS5cbiAgICBpZiAocGVuZGluZykgcmV0dXJuXG5cbiAgICBjb25zdCBkZXRhY2hlZCA9IG5ldyBEZXRhY2hlZFByb21pc2U8dm9pZD4oKVxuICAgIHBlbmRpbmcgPSBkZXRhY2hlZFxuXG4gICAgc2NoZWR1bGVJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY2h1bmsgPSBuZXcgVWludDhBcnJheShidWZmZXJCeXRlTGVuZ3RoKVxuICAgICAgICBsZXQgY29waWVkQnl0ZXMgPSAwXG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXJlZENodW5rcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGJ1ZmZlcmVkQ2h1bmsgPSBidWZmZXJlZENodW5rc1tpXVxuICAgICAgICAgIGNodW5rLnNldChidWZmZXJlZENodW5rLCBjb3BpZWRCeXRlcylcbiAgICAgICAgICBjb3BpZWRCeXRlcyArPSBidWZmZXJlZENodW5rLmJ5dGVMZW5ndGhcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBqdXN0IHdyb3RlIGFsbCB0aGUgYnVmZmVyZWQgY2h1bmtzIHNvIHdlIG5lZWQgdG8gcmVzZXQgdGhlIGJ1ZmZlcmVkQ2h1bmtzIGFycmF5XG4gICAgICAgIC8vIGFuZCBvdXIgYnVmZmVyQnl0ZUxlbmd0aCB0byBwcmVwYXJlIGZvciB0aGUgbmV4dCByb3VuZCBvZiBidWZmZXJlZCBjaHVua3NcbiAgICAgICAgYnVmZmVyZWRDaHVua3MubGVuZ3RoID0gMFxuICAgICAgICBidWZmZXJCeXRlTGVuZ3RoID0gMFxuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspXG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgLy8gSWYgYW4gZXJyb3Igb2NjdXJzIHdoaWxlIGVucXVldWluZyBpdCBjYW4ndCBiZSBkdWUgdG8gdGhpc1xuICAgICAgICAvLyB0cmFuc2Zvcm1lcnMgZmF1bHQuIEl0J3MgbGlrZWx5IGR1ZSB0byB0aGUgY29udHJvbGxlciBiZWluZ1xuICAgICAgICAvLyBlcnJvcmVkIGR1ZSB0byB0aGUgc3RyZWFtIGJlaW5nIGNhbmNlbGxlZC5cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHBlbmRpbmcgPSB1bmRlZmluZWRcbiAgICAgICAgZGV0YWNoZWQucmVzb2x2ZSgpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgIC8vIENvbWJpbmUgdGhlIHByZXZpb3VzIGJ1ZmZlciB3aXRoIHRoZSBuZXcgY2h1bmsuXG4gICAgICBidWZmZXJlZENodW5rcy5wdXNoKGNodW5rKVxuICAgICAgYnVmZmVyQnl0ZUxlbmd0aCArPSBjaHVuay5ieXRlTGVuZ3RoXG5cbiAgICAgIC8vIEZsdXNoIHRoZSBidWZmZXIgdG8gdGhlIGNvbnRyb2xsZXIuXG4gICAgICBmbHVzaChjb250cm9sbGVyKVxuICAgIH0sXG4gICAgZmx1c2goKSB7XG4gICAgICBpZiAoIXBlbmRpbmcpIHJldHVyblxuXG4gICAgICByZXR1cm4gcGVuZGluZy5wcm9taXNlXG4gICAgfSxcbiAgfSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlUHJlZmV0Y2hDb21tZW50U3RyZWFtKFxuICBpc0J1aWxkVGltZVByZXJlbmRlcmluZzogYm9vbGVhbixcbiAgYnVpbGRJZDogc3RyaW5nXG4pOiBUcmFuc2Zvcm1TdHJlYW08VWludDhBcnJheSwgVWludDhBcnJheT4ge1xuICAvLyBJbnNlcnQgYW4gZXh0cmEgY29tbWVudCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBIVE1MIGRvY3VtZW50LiBUaGlzIG11c3RcbiAgLy8gY29tZSBhZnRlciB0aGUgRE9DVFlQRSwgd2hpY2ggaXMgaW5zZXJ0ZWQgYnkgUmVhY3QuXG4gIC8vXG4gIC8vIFRoZSBmaXJzdCBjaHVuayBzZW50IGJ5IFJlYWN0IHdpbGwgY29udGFpbiB0aGUgZG9jdHlwZS4gQWZ0ZXIgdGhhdCwgd2UgY2FuXG4gIC8vIHBhc3MgdGhyb3VnaCB0aGUgcmVzdCBvZiB0aGUgY2h1bmtzIGFzLWlzLlxuICBsZXQgZGlkVHJhbnNmb3JtRmlyc3RDaHVuayA9IGZhbHNlXG4gIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgIGlmIChpc0J1aWxkVGltZVByZXJlbmRlcmluZyAmJiAhZGlkVHJhbnNmb3JtRmlyc3RDaHVuaykge1xuICAgICAgICBkaWRUcmFuc2Zvcm1GaXJzdENodW5rID0gdHJ1ZVxuICAgICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCd1dGYtOCcsIHsgZmF0YWw6IHRydWUgfSlcbiAgICAgICAgY29uc3QgY2h1bmtTdHIgPSBkZWNvZGVyLmRlY29kZShjaHVuaywge1xuICAgICAgICAgIHN0cmVhbTogdHJ1ZSxcbiAgICAgICAgfSlcbiAgICAgICAgY29uc3QgdXBkYXRlZENodW5rU3RyID0gaW5zZXJ0QnVpbGRJZENvbW1lbnQoY2h1bmtTdHIsIGJ1aWxkSWQpXG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShlbmNvZGVyLmVuY29kZSh1cGRhdGVkQ2h1bmtTdHIpKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuaylcbiAgICB9LFxuICB9KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyVG9Jbml0aWFsRml6elN0cmVhbSh7XG4gIFJlYWN0RE9NU2VydmVyLFxuICBlbGVtZW50LFxuICBzdHJlYW1PcHRpb25zLFxufToge1xuICBSZWFjdERPTVNlcnZlcjoge1xuICAgIHJlbmRlclRvUmVhZGFibGVTdHJlYW06IHR5cGVvZiBpbXBvcnQoJ3JlYWN0LWRvbS9zZXJ2ZXInKS5yZW5kZXJUb1JlYWRhYmxlU3RyZWFtXG4gIH1cbiAgZWxlbWVudDogUmVhY3QuUmVhY3RFbGVtZW50XG4gIHN0cmVhbU9wdGlvbnM/OiBQYXJhbWV0ZXJzPHR5cGVvZiBSZWFjdERPTVNlcnZlci5yZW5kZXJUb1JlYWRhYmxlU3RyZWFtPlsxXVxufSk6IFByb21pc2U8UmVhY3RSZWFkYWJsZVN0cmVhbT4ge1xuICByZXR1cm4gZ2V0VHJhY2VyKCkudHJhY2UoQXBwUmVuZGVyU3Bhbi5yZW5kZXJUb1JlYWRhYmxlU3RyZWFtLCBhc3luYyAoKSA9PlxuICAgIFJlYWN0RE9NU2VydmVyLnJlbmRlclRvUmVhZGFibGVTdHJlYW0oZWxlbWVudCwgc3RyZWFtT3B0aW9ucylcbiAgKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVNZXRhZGF0YVRyYW5zZm9ybVN0cmVhbShcbiAgaW5zZXJ0OiAoKSA9PiBQcm9taXNlPHN0cmluZz4gfCBzdHJpbmdcbik6IFRyYW5zZm9ybVN0cmVhbTxVaW50OEFycmF5LCBVaW50OEFycmF5PiB7XG4gIGxldCBjaHVua0luZGV4ID0gLTFcbiAgbGV0IGlzTWFya1JlbW92ZWQgPSBmYWxzZVxuXG4gIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICBhc3luYyB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgIGxldCBpY29uTWFya0luZGV4ID0gLTFcbiAgICAgIGxldCBjbG9zZWRIZWFkSW5kZXggPSAtMVxuICAgICAgY2h1bmtJbmRleCsrXG5cbiAgICAgIGlmIChpc01hcmtSZW1vdmVkKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuaylcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBsZXQgaWNvbk1hcmtMZW5ndGggPSAwXG4gICAgICAvLyBPbmx5IHNlYXJjaCBmb3IgdGhlIGNsb3NlZCBoZWFkIHRhZyBvbmNlXG4gICAgICBpZiAoaWNvbk1hcmtJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgaWNvbk1hcmtJbmRleCA9IGluZGV4T2ZVaW50OEFycmF5KGNodW5rLCBFTkNPREVEX1RBR1MuTUVUQS5JQ09OX01BUkspXG4gICAgICAgIGlmIChpY29uTWFya0luZGV4ID09PSAtMSkge1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuaylcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBXaGVuIHdlIGZvdW5kIHRoZSBgPG1ldGEgbmFtZT1cIsKrbnh0LWljb27Cu1wiYCB0YWcgcHJlZml4LCB3ZSB3aWxsIHJlbW92ZSBpdCBmcm9tIHRoZSBjaHVuay5cbiAgICAgICAgICAvLyBJdHMgY2xvc2UgdGFnIGNvdWxkIGVpdGhlciBiZSBgLz5gIG9yIGA+YCwgY2hlY2tpbmcgdGhlIG5leHQgY2hhciB0byBlbnN1cmUgd2UgY292ZXIgYm90aCBjYXNlcy5cbiAgICAgICAgICBpY29uTWFya0xlbmd0aCA9IEVOQ09ERURfVEFHUy5NRVRBLklDT05fTUFSSy5sZW5ndGhcbiAgICAgICAgICAvLyBDaGVjayBpZiBuZXh0IGNoYXIgaXMgLywgdGhpcyBpcyBmb3IgeG1sIG1vZGUuXG4gICAgICAgICAgaWYgKGNodW5rW2ljb25NYXJrSW5kZXggKyBpY29uTWFya0xlbmd0aF0gPT09IDQ3KSB7XG4gICAgICAgICAgICBpY29uTWFya0xlbmd0aCArPSAyXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoZSBsYXN0IGNoYXIgaXMgYD5gXG4gICAgICAgICAgICBpY29uTWFya0xlbmd0aCsrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGlmIGljb24gbWFyayBpcyBpbnNpZGUgPGhlYWQ+IHRhZyBpbiB0aGUgZmlyc3QgY2h1bmsuXG4gICAgICBpZiAoY2h1bmtJbmRleCA9PT0gMCkge1xuICAgICAgICBjbG9zZWRIZWFkSW5kZXggPSBpbmRleE9mVWludDhBcnJheShjaHVuaywgRU5DT0RFRF9UQUdTLkNMT1NFRC5IRUFEKVxuICAgICAgICBpZiAoaWNvbk1hcmtJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAvLyBUaGUgbWFyayBpY29uIGlzIGxvY2F0ZWQgaW4gdGhlIDFzdCBjaHVuayBiZWZvcmUgdGhlIGhlYWQgdGFnLlxuICAgICAgICAgIC8vIFdlIGRvIG5vdCBuZWVkIHRvIGluc2VydCB0aGUgc2NyaXB0IHRhZyBpbiB0aGlzIGNhc2UgYmVjYXVzZSBpdCdzIGluIHRoZSBoZWFkLlxuICAgICAgICAgIC8vIEp1c3QgcmVtb3ZlIHRoZSBpY29uIG1hcmsgZnJvbSB0aGUgY2h1bmsuXG4gICAgICAgICAgaWYgKGljb25NYXJrSW5kZXggPCBjbG9zZWRIZWFkSW5kZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcGxhY2VkID0gbmV3IFVpbnQ4QXJyYXkoY2h1bmsubGVuZ3RoIC0gaWNvbk1hcmtMZW5ndGgpXG5cbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgaWNvbiBtYXJrIGZyb20gdGhlIGNodW5rLlxuICAgICAgICAgICAgcmVwbGFjZWQuc2V0KGNodW5rLnN1YmFycmF5KDAsIGljb25NYXJrSW5kZXgpKVxuICAgICAgICAgICAgcmVwbGFjZWQuc2V0KFxuICAgICAgICAgICAgICBjaHVuay5zdWJhcnJheShpY29uTWFya0luZGV4ICsgaWNvbk1hcmtMZW5ndGgpLFxuICAgICAgICAgICAgICBpY29uTWFya0luZGV4XG4gICAgICAgICAgICApXG4gICAgICAgICAgICBjaHVuayA9IHJlcGxhY2VkXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoZSBpY29uIG1hcmsgaXMgYWZ0ZXIgdGhlIGhlYWQgdGFnLCByZXBsYWNlIGFuZCBpbnNlcnQgdGhlIHNjcmlwdCB0YWcgYXQgdGhhdCBwb3NpdGlvbi5cbiAgICAgICAgICAgIGNvbnN0IGluc2VydGlvbiA9IGF3YWl0IGluc2VydCgpXG4gICAgICAgICAgICBjb25zdCBlbmNvZGVkSW5zZXJ0aW9uID0gZW5jb2Rlci5lbmNvZGUoaW5zZXJ0aW9uKVxuICAgICAgICAgICAgY29uc3QgaW5zZXJ0aW9uTGVuZ3RoID0gZW5jb2RlZEluc2VydGlvbi5sZW5ndGhcbiAgICAgICAgICAgIGNvbnN0IHJlcGxhY2VkID0gbmV3IFVpbnQ4QXJyYXkoXG4gICAgICAgICAgICAgIGNodW5rLmxlbmd0aCAtIGljb25NYXJrTGVuZ3RoICsgaW5zZXJ0aW9uTGVuZ3RoXG4gICAgICAgICAgICApXG4gICAgICAgICAgICByZXBsYWNlZC5zZXQoY2h1bmsuc3ViYXJyYXkoMCwgaWNvbk1hcmtJbmRleCkpXG4gICAgICAgICAgICByZXBsYWNlZC5zZXQoZW5jb2RlZEluc2VydGlvbiwgaWNvbk1hcmtJbmRleClcbiAgICAgICAgICAgIHJlcGxhY2VkLnNldChcbiAgICAgICAgICAgICAgY2h1bmsuc3ViYXJyYXkoaWNvbk1hcmtJbmRleCArIGljb25NYXJrTGVuZ3RoKSxcbiAgICAgICAgICAgICAgaWNvbk1hcmtJbmRleCArIGluc2VydGlvbkxlbmd0aFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgY2h1bmsgPSByZXBsYWNlZFxuICAgICAgICAgIH1cbiAgICAgICAgICBpc01hcmtSZW1vdmVkID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gaWNvbiBtYXJrIGxvY2F0ZWQsIGl0IHdpbGwgYmUgaGFuZGxlZCBsYXRlciB3aGVuIGlmIHByZXNlbnQgaW4gdGhlIGZvbGxvd2luZyBjaHVua3MuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXaGVuIGl0J3MgYXBwZWFyZWQgaW4gdGhlIGZvbGxvd2luZyBjaHVua3MsIHdlJ2xsIG5lZWQgdG9cbiAgICAgICAgLy8gcmVtb3ZlIHRoZSBtYXJrIGFuZCB0aGVuIGluc2VydCB0aGUgc2NyaXB0IHRhZyBhdCB0aGF0IHBvc2l0aW9uLlxuICAgICAgICBjb25zdCBpbnNlcnRpb24gPSBhd2FpdCBpbnNlcnQoKVxuICAgICAgICBjb25zdCBlbmNvZGVkSW5zZXJ0aW9uID0gZW5jb2Rlci5lbmNvZGUoaW5zZXJ0aW9uKVxuICAgICAgICBjb25zdCBpbnNlcnRpb25MZW5ndGggPSBlbmNvZGVkSW5zZXJ0aW9uLmxlbmd0aFxuICAgICAgICAvLyBSZXBsYWNlIHRoZSBpY29uIG1hcmsgd2l0aCB0aGUgaG9pc3Qgc2NyaXB0IG9yIGVtcHR5IHN0cmluZy5cbiAgICAgICAgY29uc3QgcmVwbGFjZWQgPSBuZXcgVWludDhBcnJheShcbiAgICAgICAgICBjaHVuay5sZW5ndGggLSBpY29uTWFya0xlbmd0aCArIGluc2VydGlvbkxlbmd0aFxuICAgICAgICApXG4gICAgICAgIC8vIFNldCB0aGUgZmlyc3QgcGFydCBvZiB0aGUgY2h1bmssIGJlZm9yZSB0aGUgaWNvbiBtYXJrLlxuICAgICAgICByZXBsYWNlZC5zZXQoY2h1bmsuc3ViYXJyYXkoMCwgaWNvbk1hcmtJbmRleCkpXG4gICAgICAgIC8vIFNldCB0aGUgaW5zZXJ0aW9uIGFmdGVyIHRoZSBpY29uIG1hcmsuXG4gICAgICAgIHJlcGxhY2VkLnNldChlbmNvZGVkSW5zZXJ0aW9uLCBpY29uTWFya0luZGV4KVxuXG4gICAgICAgIC8vIFNldCB0aGUgcmVzdCBvZiB0aGUgY2h1bmsgYWZ0ZXIgdGhlIGljb24gbWFyay5cbiAgICAgICAgcmVwbGFjZWQuc2V0KFxuICAgICAgICAgIGNodW5rLnN1YmFycmF5KGljb25NYXJrSW5kZXggKyBpY29uTWFya0xlbmd0aCksXG4gICAgICAgICAgaWNvbk1hcmtJbmRleCArIGluc2VydGlvbkxlbmd0aFxuICAgICAgICApXG4gICAgICAgIGNodW5rID0gcmVwbGFjZWRcbiAgICAgICAgaXNNYXJrUmVtb3ZlZCA9IHRydWVcbiAgICAgIH1cbiAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuaylcbiAgICB9LFxuICB9KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVIZWFkSW5zZXJ0aW9uVHJhbnNmb3JtU3RyZWFtKFxuICBpbnNlcnQ6ICgpID0+IFByb21pc2U8c3RyaW5nPlxuKTogVHJhbnNmb3JtU3RyZWFtPFVpbnQ4QXJyYXksIFVpbnQ4QXJyYXk+IHtcbiAgbGV0IGluc2VydGVkID0gZmFsc2VcblxuICAvLyBXZSBuZWVkIHRvIHRyYWNrIGlmIHRoaXMgdHJhbnNmb3JtIHNhdyBhbnkgYnl0ZXMgYmVjYXVzZSBpZiBpdCBkaWRuJ3RcbiAgLy8gd2Ugd29uJ3Qgd2FudCB0byBpbnNlcnQgYW55IHNlcnZlciBIVE1MIGF0IGFsbFxuICBsZXQgaGFzQnl0ZXMgPSBmYWxzZVxuXG4gIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICBhc3luYyB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgIGhhc0J5dGVzID0gdHJ1ZVxuXG4gICAgICBjb25zdCBpbnNlcnRpb24gPSBhd2FpdCBpbnNlcnQoKVxuICAgICAgaWYgKGluc2VydGVkKSB7XG4gICAgICAgIGlmIChpbnNlcnRpb24pIHtcbiAgICAgICAgICBjb25zdCBlbmNvZGVkSW5zZXJ0aW9uID0gZW5jb2Rlci5lbmNvZGUoaW5zZXJ0aW9uKVxuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShlbmNvZGVkSW5zZXJ0aW9uKVxuICAgICAgICB9XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuaylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRPRE8gKEBFdGhhbi1BcnJvd29vZCk6IFJlcGxhY2UgdGhlIGdlbmVyaWMgYGluZGV4T2ZVaW50OEFycmF5YCBtZXRob2Qgd2l0aCBzb21ldGhpbmcgZmluZWx5IHR1bmVkIGZvciB0aGUgc3Vic2V0IG9mIHRoaW5ncyBhY3R1YWxseSBiZWluZyBjaGVja2VkIGZvci5cbiAgICAgICAgY29uc3QgaW5kZXggPSBpbmRleE9mVWludDhBcnJheShjaHVuaywgRU5DT0RFRF9UQUdTLkNMT1NFRC5IRUFEKVxuICAgICAgICAvLyBJbiBmdWxseSBzdGF0aWMgcmVuZGVyaW5nIG9yIG5vbiBQUFIgcmVuZGVyaW5nIGNhc2VzOlxuICAgICAgICAvLyBgL2hlYWQ+YCB3aWxsIGFsd2F5cyBiZSBmb3VuZCBpbiB0aGUgY2h1bmsgaW4gZmlyc3QgY2h1bmsgcmVuZGVyaW5nLlxuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgaWYgKGluc2VydGlvbikge1xuICAgICAgICAgICAgY29uc3QgZW5jb2RlZEluc2VydGlvbiA9IGVuY29kZXIuZW5jb2RlKGluc2VydGlvbilcbiAgICAgICAgICAgIC8vIEdldCB0aGUgdG90YWwgY291bnQgb2YgdGhlIGJ5dGVzIGluIHRoZSBjaHVuayBhbmQgdGhlIGluc2VydGlvblxuICAgICAgICAgICAgLy8gZS5nLlxuICAgICAgICAgICAgLy8gY2h1bmsgPSA8aGVhZD48bWV0YSBjaGFyc2V0PVwidXRmLThcIj48L2hlYWQ+XG4gICAgICAgICAgICAvLyBpbnNlcnRpb24gPSA8c2NyaXB0Pi4uLjwvc2NyaXB0PlxuICAgICAgICAgICAgLy8gb3V0cHV0ID0gPGhlYWQ+PG1ldGEgY2hhcnNldD1cInV0Zi04XCI+IFsgPHNjcmlwdD4uLi48L3NjcmlwdD4gXSA8L2hlYWQ+XG4gICAgICAgICAgICBjb25zdCBpbnNlcnRlZEhlYWRDb250ZW50ID0gbmV3IFVpbnQ4QXJyYXkoXG4gICAgICAgICAgICAgIGNodW5rLmxlbmd0aCArIGVuY29kZWRJbnNlcnRpb24ubGVuZ3RoXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAvLyBBcHBlbmQgdGhlIGZpcnN0IHBhcnQgb2YgdGhlIGNodW5rLCBiZWZvcmUgdGhlIGhlYWQgdGFnXG4gICAgICAgICAgICBpbnNlcnRlZEhlYWRDb250ZW50LnNldChjaHVuay5zbGljZSgwLCBpbmRleCkpXG4gICAgICAgICAgICAvLyBBcHBlbmQgdGhlIHNlcnZlciBpbnNlcnRlZCBjb250ZW50XG4gICAgICAgICAgICBpbnNlcnRlZEhlYWRDb250ZW50LnNldChlbmNvZGVkSW5zZXJ0aW9uLCBpbmRleClcbiAgICAgICAgICAgIC8vIEFwcGVuZCB0aGUgcmVzdCBvZiB0aGUgY2h1bmtcbiAgICAgICAgICAgIGluc2VydGVkSGVhZENvbnRlbnQuc2V0KFxuICAgICAgICAgICAgICBjaHVuay5zbGljZShpbmRleCksXG4gICAgICAgICAgICAgIGluZGV4ICsgZW5jb2RlZEluc2VydGlvbi5sZW5ndGhcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShpbnNlcnRlZEhlYWRDb250ZW50KVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspXG4gICAgICAgICAgfVxuICAgICAgICAgIGluc2VydGVkID0gdHJ1ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoaXMgd2lsbCBoYXBwZW5zIGluIFBQUiByZW5kZXJpbmcgZHVyaW5nIG5leHQgc3RhcnQsIHdoZW4gdGhlIHBhZ2UgaXMgcGFydGlhbGx5IHJlbmRlcmVkLlxuICAgICAgICAgIC8vIFdoZW4gdGhlIHBhZ2UgcmVzdW1lcywgdGhlIGhlYWQgdGFnIHdpbGwgYmUgZm91bmQgaW4gdGhlIG1pZGRsZSBvZiB0aGUgY2h1bmsuXG4gICAgICAgICAgLy8gV2hlcmUgd2UganVzdCBuZWVkIHRvIGFwcGVuZCB0aGUgaW5zZXJ0aW9uIGFuZCBjaHVuayB0byB0aGUgY3VycmVudCBzdHJlYW0uXG4gICAgICAgICAgLy8gZS5nLlxuICAgICAgICAgIC8vIFBQUi1zdGF0aWM6IDxoZWFkPi4uLjwvaGVhZD48Ym9keT4gWyByZXN1bWUgY29udGVudCBdIDwvYm9keT5cbiAgICAgICAgICAvLyBQUFItcmVzdW1lOiBbIGluc2VydGlvbiBdIFsgcmVzdCBjb250ZW50IF1cbiAgICAgICAgICBpZiAoaW5zZXJ0aW9uKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoZW5jb2Rlci5lbmNvZGUoaW5zZXJ0aW9uKSlcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKVxuICAgICAgICAgIGluc2VydGVkID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBhc3luYyBmbHVzaChjb250cm9sbGVyKSB7XG4gICAgICAvLyBDaGVjayBiZWZvcmUgY2xvc2luZyBpZiB0aGVyZSdzIGFueXRoaW5nIHJlbWFpbmluZyB0byBpbnNlcnQuXG4gICAgICBpZiAoaGFzQnl0ZXMpIHtcbiAgICAgICAgY29uc3QgaW5zZXJ0aW9uID0gYXdhaXQgaW5zZXJ0KClcbiAgICAgICAgaWYgKGluc2VydGlvbikge1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShlbmNvZGVyLmVuY29kZShpbnNlcnRpb24pKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgfSlcbn1cblxuLy8gU3VmZml4IGFmdGVyIG1haW4gYm9keSBjb250ZW50IC0gc2NyaXB0cyBiZWZvcmUgPC9ib2R5Pixcbi8vIGJ1dCB3YWl0IGZvciB0aGUgbWFqb3IgY2h1bmtzIHRvIGJlIGVucXVldWVkLlxuZnVuY3Rpb24gY3JlYXRlRGVmZXJyZWRTdWZmaXhTdHJlYW0oXG4gIHN1ZmZpeDogc3RyaW5nXG4pOiBUcmFuc2Zvcm1TdHJlYW08VWludDhBcnJheSwgVWludDhBcnJheT4ge1xuICBsZXQgZmx1c2hlZCA9IGZhbHNlXG4gIGxldCBwZW5kaW5nOiBEZXRhY2hlZFByb21pc2U8dm9pZD4gfCB1bmRlZmluZWRcblxuICBjb25zdCBmbHVzaCA9IChjb250cm9sbGVyOiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcikgPT4ge1xuICAgIGNvbnN0IGRldGFjaGVkID0gbmV3IERldGFjaGVkUHJvbWlzZTx2b2lkPigpXG4gICAgcGVuZGluZyA9IGRldGFjaGVkXG5cbiAgICBzY2hlZHVsZUltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoZW5jb2Rlci5lbmNvZGUoc3VmZml4KSlcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICAvLyBJZiBhbiBlcnJvciBvY2N1cnMgd2hpbGUgZW5xdWV1aW5nIGl0IGNhbid0IGJlIGR1ZSB0byB0aGlzXG4gICAgICAgIC8vIHRyYW5zZm9ybWVycyBmYXVsdC4gSXQncyBsaWtlbHkgZHVlIHRvIHRoZSBjb250cm9sbGVyIGJlaW5nXG4gICAgICAgIC8vIGVycm9yZWQgZHVlIHRvIHRoZSBzdHJlYW0gYmVpbmcgY2FuY2VsbGVkLlxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgcGVuZGluZyA9IHVuZGVmaW5lZFxuICAgICAgICBkZXRhY2hlZC5yZXNvbHZlKClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKVxuXG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGZsdXNoZWQsIHdlJ3JlIGRvbmUuXG4gICAgICBpZiAoZmx1c2hlZCkgcmV0dXJuXG5cbiAgICAgIC8vIFNjaGVkdWxlIHRoZSBmbHVzaCB0byBoYXBwZW4uXG4gICAgICBmbHVzaGVkID0gdHJ1ZVxuICAgICAgZmx1c2goY29udHJvbGxlcilcbiAgICB9LFxuICAgIGZsdXNoKGNvbnRyb2xsZXIpIHtcbiAgICAgIGlmIChwZW5kaW5nKSByZXR1cm4gcGVuZGluZy5wcm9taXNlXG4gICAgICBpZiAoZmx1c2hlZCkgcmV0dXJuXG5cbiAgICAgIC8vIEZsdXNoIG5vdy5cbiAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShlbmNvZGVyLmVuY29kZShzdWZmaXgpKVxuICAgIH0sXG4gIH0pXG59XG5cbi8vIE1lcmdlIHR3byBzdHJlYW1zIGludG8gb25lLiBFbnN1cmUgdGhlIGZpbmFsIHRyYW5zZm9ybSBzdHJlYW0gaXMgY2xvc2VkXG4vLyB3aGVuIGJvdGggYXJlIGZpbmlzaGVkLlxuZnVuY3Rpb24gY3JlYXRlTWVyZ2VkVHJhbnNmb3JtU3RyZWFtKFxuICBzdHJlYW06IFJlYWRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+XG4pOiBUcmFuc2Zvcm1TdHJlYW08VWludDhBcnJheSwgVWludDhBcnJheT4ge1xuICBsZXQgcHVsbDogUHJvbWlzZTx2b2lkPiB8IG51bGwgPSBudWxsXG4gIGxldCBkb25lUHVsbGluZyA9IGZhbHNlXG5cbiAgYXN5bmMgZnVuY3Rpb24gc3RhcnRQdWxsaW5nKGNvbnRyb2xsZXI6IFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyKSB7XG4gICAgaWYgKHB1bGwpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKVxuXG4gICAgLy8gTk9URTogc3RyZWFtaW5nIGZsdXNoXG4gICAgLy8gV2UgYXJlIGJ1ZmZlcmluZyBoZXJlIGZvciB0aGUgaW5saW5lZCBkYXRhIHN0cmVhbSBiZWNhdXNlIHRoZVxuICAgIC8vIFwic2hlbGxcIiBzdHJlYW0gbWlnaHQgYmUgY2h1bmtlbml6ZWQgYWdhaW4gYnkgdGhlIHVuZGVybHlpbmcgc3RyZWFtXG4gICAgLy8gaW1wbGVtZW50YXRpb24sIGUuZy4gd2l0aCBhIHNwZWNpZmljIGhpZ2gtd2F0ZXIgbWFyay4gVG8gZW5zdXJlIGl0J3NcbiAgICAvLyB0aGUgc2FmZSB0aW1pbmcgdG8gcGlwZSB0aGUgZGF0YSBzdHJlYW0sIHRoaXMgZXh0cmEgdGljayBpc1xuICAgIC8vIG5lY2Vzc2FyeS5cblxuICAgIC8vIFdlIGRvbid0IHN0YXJ0IHJlYWRpbmcgdW50aWwgd2UndmUgbGVmdCB0aGUgY3VycmVudCBUYXNrIHRvIGVuc3VyZVxuICAgIC8vIHRoYXQgaXQncyBpbnNlcnRlZCBhZnRlciBmbHVzaGluZyB0aGUgc2hlbGwuIE5vdGUgdGhhdCB0aGlzIGltcGxlbWVudGF0aW9uXG4gICAgLy8gbWlnaHQgZ2V0IHN0YWxlIGlmIGltcGwgZGV0YWlscyBvZiBGaXp6IGNoYW5nZSBpbiB0aGUgZnV0dXJlLlxuICAgIGF3YWl0IGF0TGVhc3RPbmVUYXNrKClcblxuICAgIHRyeSB7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpXG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgZG9uZVB1bGxpbmcgPSB0cnVlXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBjb250cm9sbGVyLmVucXVldWUodmFsdWUpXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb250cm9sbGVyLmVycm9yKGVycilcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspXG5cbiAgICAgIC8vIFN0YXJ0IHRoZSBzdHJlYW1pbmcgaWYgaXQgaGFzbid0IGFscmVhZHkgYmVlbiBzdGFydGVkIHlldC5cbiAgICAgIGlmICghcHVsbCkge1xuICAgICAgICBwdWxsID0gc3RhcnRQdWxsaW5nKGNvbnRyb2xsZXIpXG4gICAgICB9XG4gICAgfSxcbiAgICBmbHVzaChjb250cm9sbGVyKSB7XG4gICAgICBpZiAoZG9uZVB1bGxpbmcpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICByZXR1cm4gcHVsbCB8fCBzdGFydFB1bGxpbmcoY29udHJvbGxlcilcbiAgICB9LFxuICB9KVxufVxuXG5jb25zdCBDTE9TRV9UQUcgPSAnPC9ib2R5PjwvaHRtbD4nXG5cbi8qKlxuICogVGhpcyB0cmFuc2Zvcm0gc3RyZWFtIG1vdmVzIHRoZSBzdWZmaXggdG8gdGhlIGVuZCBvZiB0aGUgc3RyZWFtLCBzbyByZXN1bHRzXG4gKiBsaWtlIGA8L2JvZHk+PC9odG1sPjxzY3JpcHQ+Li4uPC9zY3JpcHQ+YCB3aWxsIGJlIHRyYW5zZm9ybWVkIHRvXG4gKiBgPHNjcmlwdD4uLi48L3NjcmlwdD48L2JvZHk+PC9odG1sPmAuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU1vdmVTdWZmaXhTdHJlYW0oKTogVHJhbnNmb3JtU3RyZWFtPFVpbnQ4QXJyYXksIFVpbnQ4QXJyYXk+IHtcbiAgbGV0IGZvdW5kU3VmZml4ID0gZmFsc2VcblxuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICBpZiAoZm91bmRTdWZmaXgpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuaylcbiAgICAgIH1cblxuICAgICAgY29uc3QgaW5kZXggPSBpbmRleE9mVWludDhBcnJheShjaHVuaywgRU5DT0RFRF9UQUdTLkNMT1NFRC5CT0RZX0FORF9IVE1MKVxuICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgZm91bmRTdWZmaXggPSB0cnVlXG5cbiAgICAgICAgLy8gSWYgdGhlIHdob2xlIGNodW5rIGlzIHRoZSBzdWZmaXgsIHRoZW4gZG9uJ3Qgd3JpdGUgYW55dGhpbmcsIGl0IHdpbGxcbiAgICAgICAgLy8gYmUgd3JpdHRlbiBpbiB0aGUgZmx1c2guXG4gICAgICAgIGlmIChjaHVuay5sZW5ndGggPT09IEVOQ09ERURfVEFHUy5DTE9TRUQuQk9EWV9BTkRfSFRNTC5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdyaXRlIG91dCB0aGUgcGFydCBiZWZvcmUgdGhlIHN1ZmZpeC5cbiAgICAgICAgY29uc3QgYmVmb3JlID0gY2h1bmsuc2xpY2UoMCwgaW5kZXgpXG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShiZWZvcmUpXG5cbiAgICAgICAgLy8gSW4gdGhlIGNhc2Ugd2hlcmUgdGhlIHN1ZmZpeCBpcyBpbiB0aGUgbWlkZGxlIG9mIHRoZSBjaHVuaywgd2UgbmVlZFxuICAgICAgICAvLyB0byBzcGxpdCB0aGUgY2h1bmsgaW50byB0d28gcGFydHMuXG4gICAgICAgIGlmIChjaHVuay5sZW5ndGggPiBFTkNPREVEX1RBR1MuQ0xPU0VELkJPRFlfQU5EX0hUTUwubGVuZ3RoICsgaW5kZXgpIHtcbiAgICAgICAgICAvLyBXcml0ZSBvdXQgdGhlIHBhcnQgYWZ0ZXIgdGhlIHN1ZmZpeC5cbiAgICAgICAgICBjb25zdCBhZnRlciA9IGNodW5rLnNsaWNlKFxuICAgICAgICAgICAgaW5kZXggKyBFTkNPREVEX1RBR1MuQ0xPU0VELkJPRFlfQU5EX0hUTUwubGVuZ3RoXG4gICAgICAgICAgKVxuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShhZnRlcilcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKVxuICAgICAgfVxuICAgIH0sXG4gICAgZmx1c2goY29udHJvbGxlcikge1xuICAgICAgLy8gRXZlbiBpZiB3ZSBkaWRuJ3QgZmluZCB0aGUgc3VmZml4LCB0aGUgSFRNTCBpcyBub3QgdmFsaWQgaWYgd2UgZG9uJ3RcbiAgICAgIC8vIGFkZCBpdCwgc28gaW5zZXJ0IGl0IGF0IHRoZSBlbmQuXG4gICAgICBjb250cm9sbGVyLmVucXVldWUoRU5DT0RFRF9UQUdTLkNMT1NFRC5CT0RZX0FORF9IVE1MKVxuICAgIH0sXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0cmlwRG9jdW1lbnRDbG9zaW5nVGFnc1RyYW5zZm9ybSgpOiBUcmFuc2Zvcm1TdHJlYW08XG4gIFVpbnQ4QXJyYXksXG4gIFVpbnQ4QXJyYXlcbj4ge1xuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAvLyBXZSByZWx5IG9uIHRoZSBhc3N1bXB0aW9uIHRoYXQgY2h1bmtzIHdpbGwgbmV2ZXIgYnJlYWsgYWNyb3NzIGEgY29kZSB1bml0LlxuICAgICAgLy8gVGhpcyBpcyByZWFzb25hYmxlIGJlY2F1c2Ugd2UgY3VycmVudGx5IGNvbmNhdCBhbGwgb2YgUmVhY3QncyBvdXRwdXQgZnJvbSBhIHNpbmdsZVxuICAgICAgLy8gZmx1c2ggaW50byBvbmUgY2h1bmsgYmVmb3JlIHN0cmVhbWluZyBpdCBmb3J3YXJkIHdoaWNoIG1lYW5zIHRoZSBjaHVuayB3aWxsIHJlcHJlc2VudFxuICAgICAgLy8gYSBzaW5nbGUgY29oZXJlbnQgdXRmLTggc3RyaW5nLiBUaGlzIGlzIG5vdCBzYWZlIHRvIHVzZSBpZiB3ZSBjaGFuZ2Ugb3VyIHN0cmVhbWluZyB0byBub1xuICAgICAgLy8gbG9uZ2VyIGRvIHRoaXMgbGFyZ2UgYnVmZmVyZWQgY2h1bmtcbiAgICAgIGlmIChcbiAgICAgICAgaXNFcXVpdmFsZW50VWludDhBcnJheXMoY2h1bmssIEVOQ09ERURfVEFHUy5DTE9TRUQuQk9EWV9BTkRfSFRNTCkgfHxcbiAgICAgICAgaXNFcXVpdmFsZW50VWludDhBcnJheXMoY2h1bmssIEVOQ09ERURfVEFHUy5DTE9TRUQuQk9EWSkgfHxcbiAgICAgICAgaXNFcXVpdmFsZW50VWludDhBcnJheXMoY2h1bmssIEVOQ09ERURfVEFHUy5DTE9TRUQuSFRNTClcbiAgICAgICkge1xuICAgICAgICAvLyB0aGUgZW50aXJlIGNodW5rIGlzIHRoZSBjbG9zaW5nIHRhZ3M7IHJldHVybiB3aXRob3V0IGVucXVldWVpbmcgYW55dGhpbmcuXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyBXZSBhc3N1bWUgdGhlc2UgdGFncyB3aWxsIGdvIGF0IHRvZ2V0aGVyIGF0IHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50IGFuZCB0aGF0XG4gICAgICAvLyB0aGV5IHdvbid0IGFwcGVhciBhbnl3aGVyZSBlbHNlIGluIHRoZSBkb2N1bWVudC4gVGhpcyBpcyBub3QgcmVhbGx5IGEgc2FmZSBhc3N1bXB0aW9uXG4gICAgICAvLyBidXQgdW50aWwgd2UgcmV2YW1wIG91ciBzdHJlYW1pbmcgaW5mcmEgdGhpcyBpcyBhIHBlcmZvcm1hbnQgd2F5IHRvIHN0cmluZyB0aGUgdGFnc1xuICAgICAgY2h1bmsgPSByZW1vdmVGcm9tVWludDhBcnJheShjaHVuaywgRU5DT0RFRF9UQUdTLkNMT1NFRC5CT0RZKVxuICAgICAgY2h1bmsgPSByZW1vdmVGcm9tVWludDhBcnJheShjaHVuaywgRU5DT0RFRF9UQUdTLkNMT1NFRC5IVE1MKVxuXG4gICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspXG4gICAgfSxcbiAgfSlcbn1cblxuLypcbiAqIENoZWNrcyBpZiB0aGUgcm9vdCBsYXlvdXQgaXMgbWlzc2luZyB0aGUgaHRtbCBvciBib2R5IHRhZ3NcbiAqIGFuZCBpZiBzbywgaXQgd2lsbCBpbmplY3QgYSBzY3JpcHQgdGFnIHRvIHRocm93IGFuIGVycm9yIGluIHRoZSBicm93c2VyLCBzaG93aW5nIHRoZSB1c2VyXG4gKiB0aGUgZXJyb3IgbWVzc2FnZSBpbiB0aGUgZXJyb3Igb3ZlcmxheS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJvb3RMYXlvdXRWYWxpZGF0b3JTdHJlYW0oKTogVHJhbnNmb3JtU3RyZWFtPFxuICBVaW50OEFycmF5LFxuICBVaW50OEFycmF5XG4+IHtcbiAgbGV0IGZvdW5kSHRtbCA9IGZhbHNlXG4gIGxldCBmb3VuZEJvZHkgPSBmYWxzZVxuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgYXN5bmMgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAvLyBQZWVrIGludG8gdGhlIHN0cmVhbWVkIGNodW5rIHRvIHNlZSBpZiB0aGUgdGFncyBhcmUgcHJlc2VudC5cbiAgICAgIGlmIChcbiAgICAgICAgIWZvdW5kSHRtbCAmJlxuICAgICAgICBpbmRleE9mVWludDhBcnJheShjaHVuaywgRU5DT0RFRF9UQUdTLk9QRU5JTkcuSFRNTCkgPiAtMVxuICAgICAgKSB7XG4gICAgICAgIGZvdW5kSHRtbCA9IHRydWVcbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgICAhZm91bmRCb2R5ICYmXG4gICAgICAgIGluZGV4T2ZVaW50OEFycmF5KGNodW5rLCBFTkNPREVEX1RBR1MuT1BFTklORy5CT0RZKSA+IC0xXG4gICAgICApIHtcbiAgICAgICAgZm91bmRCb2R5ID0gdHJ1ZVxuICAgICAgfVxuXG4gICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspXG4gICAgfSxcbiAgICBmbHVzaChjb250cm9sbGVyKSB7XG4gICAgICBjb25zdCBtaXNzaW5nVGFnczogKCdodG1sJyB8ICdib2R5JylbXSA9IFtdXG4gICAgICBpZiAoIWZvdW5kSHRtbCkgbWlzc2luZ1RhZ3MucHVzaCgnaHRtbCcpXG4gICAgICBpZiAoIWZvdW5kQm9keSkgbWlzc2luZ1RhZ3MucHVzaCgnYm9keScpXG5cbiAgICAgIGlmICghbWlzc2luZ1RhZ3MubGVuZ3RoKSByZXR1cm5cblxuICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICBlbmNvZGVyLmVuY29kZShcbiAgICAgICAgICBgPGh0bWwgaWQ9XCJfX25leHRfZXJyb3JfX1wiPlxuICAgICAgICAgICAgPHRlbXBsYXRlXG4gICAgICAgICAgICAgIGRhdGEtbmV4dC1lcnJvci1tZXNzYWdlPVwiTWlzc2luZyAke21pc3NpbmdUYWdzXG4gICAgICAgICAgICAgICAgLm1hcCgoYykgPT4gYDwke2N9PmApXG4gICAgICAgICAgICAgICAgLmpvaW4oXG4gICAgICAgICAgICAgICAgICBtaXNzaW5nVGFncy5sZW5ndGggPiAxID8gJyBhbmQgJyA6ICcnXG4gICAgICAgICAgICAgICAgKX0gdGFncyBpbiB0aGUgcm9vdCBsYXlvdXQuXFxuUmVhZCBtb3JlIGF0IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL21pc3Npbmctcm9vdC1sYXlvdXQtdGFnc1wiXCJcbiAgICAgICAgICAgICAgZGF0YS1uZXh0LWVycm9yLWRpZ2VzdD1cIiR7TUlTU0lOR19ST09UX1RBR1NfRVJST1J9XCJcbiAgICAgICAgICAgICAgZGF0YS1uZXh0LWVycm9yLXN0YWNrPVwiXCJcbiAgICAgICAgICAgID48L3RlbXBsYXRlPlxuICAgICAgICAgIGBcbiAgICAgICAgKVxuICAgICAgKVxuICAgIH0sXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGNoYWluVHJhbnNmb3JtZXJzPFQ+KFxuICByZWFkYWJsZTogUmVhZGFibGVTdHJlYW08VD4sXG4gIHRyYW5zZm9ybWVyczogUmVhZG9ubHlBcnJheTxUcmFuc2Zvcm1TdHJlYW08VCwgVD4gfCBudWxsPlxuKTogUmVhZGFibGVTdHJlYW08VD4ge1xuICBsZXQgc3RyZWFtID0gcmVhZGFibGVcbiAgZm9yIChjb25zdCB0cmFuc2Zvcm1lciBvZiB0cmFuc2Zvcm1lcnMpIHtcbiAgICBpZiAoIXRyYW5zZm9ybWVyKSBjb250aW51ZVxuXG4gICAgc3RyZWFtID0gc3RyZWFtLnBpcGVUaHJvdWdoKHRyYW5zZm9ybWVyKVxuICB9XG4gIHJldHVybiBzdHJlYW1cbn1cblxuZXhwb3J0IHR5cGUgQ29udGludWVTdHJlYW1PcHRpb25zID0ge1xuICBpbmxpbmVkRGF0YVN0cmVhbTogUmVhZGFibGVTdHJlYW08VWludDhBcnJheT4gfCB1bmRlZmluZWRcbiAgaXNTdGF0aWNHZW5lcmF0aW9uOiBib29sZWFuXG4gIGlzQnVpbGRUaW1lUHJlcmVuZGVyaW5nOiBib29sZWFuXG4gIGJ1aWxkSWQ6IHN0cmluZ1xuICBnZXRTZXJ2ZXJJbnNlcnRlZEhUTUw6ICgpID0+IFByb21pc2U8c3RyaW5nPlxuICBnZXRTZXJ2ZXJJbnNlcnRlZE1ldGFkYXRhOiAoKSA9PiBQcm9taXNlPHN0cmluZz5cbiAgdmFsaWRhdGVSb290TGF5b3V0PzogYm9vbGVhblxuICAvKipcbiAgICogU3VmZml4IHRvIGluamVjdCBhZnRlciB0aGUgYnVmZmVyZWQgZGF0YSwgYnV0IGJlZm9yZSB0aGUgY2xvc2UgdGFncy5cbiAgICovXG4gIHN1ZmZpeD86IHN0cmluZyB8IHVuZGVmaW5lZFxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY29udGludWVGaXp6U3RyZWFtKFxuICByZW5kZXJTdHJlYW06IFJlYWN0UmVhZGFibGVTdHJlYW0sXG4gIHtcbiAgICBzdWZmaXgsXG4gICAgaW5saW5lZERhdGFTdHJlYW0sXG4gICAgaXNTdGF0aWNHZW5lcmF0aW9uLFxuICAgIGlzQnVpbGRUaW1lUHJlcmVuZGVyaW5nLFxuICAgIGJ1aWxkSWQsXG4gICAgZ2V0U2VydmVySW5zZXJ0ZWRIVE1MLFxuICAgIGdldFNlcnZlckluc2VydGVkTWV0YWRhdGEsXG4gICAgdmFsaWRhdGVSb290TGF5b3V0LFxuICB9OiBDb250aW51ZVN0cmVhbU9wdGlvbnNcbik6IFByb21pc2U8UmVhZGFibGVTdHJlYW08VWludDhBcnJheT4+IHtcbiAgLy8gU3VmZml4IGl0c2VsZiBtaWdodCBjb250YWluIGNsb3NlIHRhZ3MgYXQgdGhlIGVuZCwgc28gd2UgbmVlZCB0byBzcGxpdCBpdC5cbiAgY29uc3Qgc3VmZml4VW5jbG9zZWQgPSBzdWZmaXggPyBzdWZmaXguc3BsaXQoQ0xPU0VfVEFHLCAxKVswXSA6IG51bGxcblxuICAvLyBJZiB3ZSdyZSBnZW5lcmF0aW5nIHN0YXRpYyBIVE1MIGFuZCB0aGVyZSdzIGFuIGBhbGxSZWFkeWAgcHJvbWlzZSBvbiB0aGVcbiAgLy8gc3RyZWFtLCB3ZSBuZWVkIHRvIHdhaXQgZm9yIGl0IHRvIHJlc29sdmUgYmVmb3JlIGNvbnRpbnVpbmcuXG4gIGlmIChpc1N0YXRpY0dlbmVyYXRpb24gJiYgJ2FsbFJlYWR5JyBpbiByZW5kZXJTdHJlYW0pIHtcbiAgICBhd2FpdCByZW5kZXJTdHJlYW0uYWxsUmVhZHlcbiAgfVxuXG4gIHJldHVybiBjaGFpblRyYW5zZm9ybWVycyhyZW5kZXJTdHJlYW0sIFtcbiAgICAvLyBCdWZmZXIgZXZlcnl0aGluZyB0byBhdm9pZCBmbHVzaGluZyB0b28gZnJlcXVlbnRseVxuICAgIGNyZWF0ZUJ1ZmZlcmVkVHJhbnNmb3JtU3RyZWFtKCksXG5cbiAgICAvLyBBZGQgYnVpbGQgaWQgY29tbWVudCB0byBzdGFydCBvZiB0aGUgSFRNTCBkb2N1bWVudCAoaW4gZXhwb3J0IG1vZGUpXG4gICAgY3JlYXRlUHJlZmV0Y2hDb21tZW50U3RyZWFtKGlzQnVpbGRUaW1lUHJlcmVuZGVyaW5nLCBidWlsZElkKSxcblxuICAgIC8vIFRyYW5zZm9ybSBtZXRhZGF0YVxuICAgIGNyZWF0ZU1ldGFkYXRhVHJhbnNmb3JtU3RyZWFtKGdldFNlcnZlckluc2VydGVkTWV0YWRhdGEpLFxuXG4gICAgLy8gSW5zZXJ0IHN1ZmZpeCBjb250ZW50XG4gICAgc3VmZml4VW5jbG9zZWQgIT0gbnVsbCAmJiBzdWZmaXhVbmNsb3NlZC5sZW5ndGggPiAwXG4gICAgICA/IGNyZWF0ZURlZmVycmVkU3VmZml4U3RyZWFtKHN1ZmZpeFVuY2xvc2VkKVxuICAgICAgOiBudWxsLFxuXG4gICAgLy8gSW5zZXJ0IHRoZSBpbmxpbmVkIGRhdGEgKEZsaWdodCBkYXRhLCBmb3JtIHN0YXRlLCBldGMuKSBzdHJlYW0gaW50byB0aGUgSFRNTFxuICAgIGlubGluZWREYXRhU3RyZWFtID8gY3JlYXRlTWVyZ2VkVHJhbnNmb3JtU3RyZWFtKGlubGluZWREYXRhU3RyZWFtKSA6IG51bGwsXG5cbiAgICAvLyBWYWxpZGF0ZSB0aGUgcm9vdCBsYXlvdXQgZm9yIG1pc3NpbmcgaHRtbCBvciBib2R5IHRhZ3NcbiAgICB2YWxpZGF0ZVJvb3RMYXlvdXQgPyBjcmVhdGVSb290TGF5b3V0VmFsaWRhdG9yU3RyZWFtKCkgOiBudWxsLFxuXG4gICAgLy8gQ2xvc2UgdGFncyBzaG91bGQgYWx3YXlzIGJlIGRlZmVycmVkIHRvIHRoZSBlbmRcbiAgICBjcmVhdGVNb3ZlU3VmZml4U3RyZWFtKCksXG5cbiAgICAvLyBTcGVjaWFsIGhlYWQgaW5zZXJ0aW9uc1xuICAgIC8vIFRPRE8tQVBQOiBJbnNlcnQgc2VydmVyIHNpZGUgaHRtbCB0byBlbmQgb2YgaGVhZCBpbiBhcHAgbGF5b3V0IHJlbmRlcmluZywgdG8gYXZvaWRcbiAgICAvLyBoeWRyYXRpb24gZXJyb3JzLiBSZW1vdmUgdGhpcyBvbmNlIGl0J3MgcmVhZHkgdG8gYmUgaGFuZGxlZCBieSByZWFjdCBpdHNlbGYuXG4gICAgY3JlYXRlSGVhZEluc2VydGlvblRyYW5zZm9ybVN0cmVhbShnZXRTZXJ2ZXJJbnNlcnRlZEhUTUwpLFxuICBdKVxufVxuXG50eXBlIENvbnRpbnVlRHluYW1pY1ByZXJlbmRlck9wdGlvbnMgPSB7XG4gIGdldFNlcnZlckluc2VydGVkSFRNTDogKCkgPT4gUHJvbWlzZTxzdHJpbmc+XG4gIGdldFNlcnZlckluc2VydGVkTWV0YWRhdGE6ICgpID0+IFByb21pc2U8c3RyaW5nPlxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY29udGludWVEeW5hbWljUHJlcmVuZGVyKFxuICBwcmVyZW5kZXJTdHJlYW06IFJlYWRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+LFxuICB7XG4gICAgZ2V0U2VydmVySW5zZXJ0ZWRIVE1MLFxuICAgIGdldFNlcnZlckluc2VydGVkTWV0YWRhdGEsXG4gIH06IENvbnRpbnVlRHluYW1pY1ByZXJlbmRlck9wdGlvbnNcbikge1xuICByZXR1cm4gKFxuICAgIHByZXJlbmRlclN0cmVhbVxuICAgICAgLy8gQnVmZmVyIGV2ZXJ5dGhpbmcgdG8gYXZvaWQgZmx1c2hpbmcgdG9vIGZyZXF1ZW50bHlcbiAgICAgIC5waXBlVGhyb3VnaChjcmVhdGVCdWZmZXJlZFRyYW5zZm9ybVN0cmVhbSgpKVxuICAgICAgLnBpcGVUaHJvdWdoKGNyZWF0ZVN0cmlwRG9jdW1lbnRDbG9zaW5nVGFnc1RyYW5zZm9ybSgpKVxuICAgICAgLy8gSW5zZXJ0IGdlbmVyYXRlZCB0YWdzIHRvIGhlYWRcbiAgICAgIC5waXBlVGhyb3VnaChjcmVhdGVIZWFkSW5zZXJ0aW9uVHJhbnNmb3JtU3RyZWFtKGdldFNlcnZlckluc2VydGVkSFRNTCkpXG4gICAgICAvLyBUcmFuc2Zvcm0gbWV0YWRhdGFcbiAgICAgIC5waXBlVGhyb3VnaChjcmVhdGVNZXRhZGF0YVRyYW5zZm9ybVN0cmVhbShnZXRTZXJ2ZXJJbnNlcnRlZE1ldGFkYXRhKSlcbiAgKVxufVxuXG50eXBlIENvbnRpbnVlU3RhdGljUHJlcmVuZGVyT3B0aW9ucyA9IHtcbiAgaW5saW5lZERhdGFTdHJlYW06IFJlYWRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+XG4gIGdldFNlcnZlckluc2VydGVkSFRNTDogKCkgPT4gUHJvbWlzZTxzdHJpbmc+XG4gIGdldFNlcnZlckluc2VydGVkTWV0YWRhdGE6ICgpID0+IFByb21pc2U8c3RyaW5nPlxuICBpc0J1aWxkVGltZVByZXJlbmRlcmluZzogYm9vbGVhblxuICBidWlsZElkOiBzdHJpbmdcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNvbnRpbnVlU3RhdGljUHJlcmVuZGVyKFxuICBwcmVyZW5kZXJTdHJlYW06IFJlYWRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+LFxuICB7XG4gICAgaW5saW5lZERhdGFTdHJlYW0sXG4gICAgZ2V0U2VydmVySW5zZXJ0ZWRIVE1MLFxuICAgIGdldFNlcnZlckluc2VydGVkTWV0YWRhdGEsXG4gICAgaXNCdWlsZFRpbWVQcmVyZW5kZXJpbmcsXG4gICAgYnVpbGRJZCxcbiAgfTogQ29udGludWVTdGF0aWNQcmVyZW5kZXJPcHRpb25zXG4pIHtcbiAgcmV0dXJuIChcbiAgICBwcmVyZW5kZXJTdHJlYW1cbiAgICAgIC8vIEJ1ZmZlciBldmVyeXRoaW5nIHRvIGF2b2lkIGZsdXNoaW5nIHRvbyBmcmVxdWVudGx5XG4gICAgICAucGlwZVRocm91Z2goY3JlYXRlQnVmZmVyZWRUcmFuc2Zvcm1TdHJlYW0oKSlcbiAgICAgIC8vIEFkZCBidWlsZCBpZCBjb21tZW50IHRvIHN0YXJ0IG9mIHRoZSBIVE1MIGRvY3VtZW50IChpbiBleHBvcnQgbW9kZSlcbiAgICAgIC5waXBlVGhyb3VnaChcbiAgICAgICAgY3JlYXRlUHJlZmV0Y2hDb21tZW50U3RyZWFtKGlzQnVpbGRUaW1lUHJlcmVuZGVyaW5nLCBidWlsZElkKVxuICAgICAgKVxuICAgICAgLy8gSW5zZXJ0IGdlbmVyYXRlZCB0YWdzIHRvIGhlYWRcbiAgICAgIC5waXBlVGhyb3VnaChjcmVhdGVIZWFkSW5zZXJ0aW9uVHJhbnNmb3JtU3RyZWFtKGdldFNlcnZlckluc2VydGVkSFRNTCkpXG4gICAgICAvLyBUcmFuc2Zvcm0gbWV0YWRhdGFcbiAgICAgIC5waXBlVGhyb3VnaChjcmVhdGVNZXRhZGF0YVRyYW5zZm9ybVN0cmVhbShnZXRTZXJ2ZXJJbnNlcnRlZE1ldGFkYXRhKSlcbiAgICAgIC8vIEluc2VydCB0aGUgaW5saW5lZCBkYXRhIChGbGlnaHQgZGF0YSwgZm9ybSBzdGF0ZSwgZXRjLikgc3RyZWFtIGludG8gdGhlIEhUTUxcbiAgICAgIC5waXBlVGhyb3VnaChjcmVhdGVNZXJnZWRUcmFuc2Zvcm1TdHJlYW0oaW5saW5lZERhdGFTdHJlYW0pKVxuICAgICAgLy8gQ2xvc2UgdGFncyBzaG91bGQgYWx3YXlzIGJlIGRlZmVycmVkIHRvIHRoZSBlbmRcbiAgICAgIC5waXBlVGhyb3VnaChjcmVhdGVNb3ZlU3VmZml4U3RyZWFtKCkpXG4gIClcbn1cblxudHlwZSBDb250aW51ZVJlc3VtZU9wdGlvbnMgPSB7XG4gIGlubGluZWREYXRhU3RyZWFtOiBSZWFkYWJsZVN0cmVhbTxVaW50OEFycmF5PlxuICBnZXRTZXJ2ZXJJbnNlcnRlZEhUTUw6ICgpID0+IFByb21pc2U8c3RyaW5nPlxuICBnZXRTZXJ2ZXJJbnNlcnRlZE1ldGFkYXRhOiAoKSA9PiBQcm9taXNlPHN0cmluZz5cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNvbnRpbnVlRHluYW1pY0hUTUxSZXN1bWUoXG4gIHJlbmRlclN0cmVhbTogUmVhZGFibGVTdHJlYW08VWludDhBcnJheT4sXG4gIHtcbiAgICBpbmxpbmVkRGF0YVN0cmVhbSxcbiAgICBnZXRTZXJ2ZXJJbnNlcnRlZEhUTUwsXG4gICAgZ2V0U2VydmVySW5zZXJ0ZWRNZXRhZGF0YSxcbiAgfTogQ29udGludWVSZXN1bWVPcHRpb25zXG4pIHtcbiAgcmV0dXJuIChcbiAgICByZW5kZXJTdHJlYW1cbiAgICAgIC8vIEJ1ZmZlciBldmVyeXRoaW5nIHRvIGF2b2lkIGZsdXNoaW5nIHRvbyBmcmVxdWVudGx5XG4gICAgICAucGlwZVRocm91Z2goY3JlYXRlQnVmZmVyZWRUcmFuc2Zvcm1TdHJlYW0oKSlcbiAgICAgIC8vIEluc2VydCBnZW5lcmF0ZWQgdGFncyB0byBoZWFkXG4gICAgICAucGlwZVRocm91Z2goY3JlYXRlSGVhZEluc2VydGlvblRyYW5zZm9ybVN0cmVhbShnZXRTZXJ2ZXJJbnNlcnRlZEhUTUwpKVxuICAgICAgLy8gVHJhbnNmb3JtIG1ldGFkYXRhXG4gICAgICAucGlwZVRocm91Z2goY3JlYXRlTWV0YWRhdGFUcmFuc2Zvcm1TdHJlYW0oZ2V0U2VydmVySW5zZXJ0ZWRNZXRhZGF0YSkpXG4gICAgICAvLyBJbnNlcnQgdGhlIGlubGluZWQgZGF0YSAoRmxpZ2h0IGRhdGEsIGZvcm0gc3RhdGUsIGV0Yy4pIHN0cmVhbSBpbnRvIHRoZSBIVE1MXG4gICAgICAucGlwZVRocm91Z2goY3JlYXRlTWVyZ2VkVHJhbnNmb3JtU3RyZWFtKGlubGluZWREYXRhU3RyZWFtKSlcbiAgICAgIC8vIENsb3NlIHRhZ3Mgc2hvdWxkIGFsd2F5cyBiZSBkZWZlcnJlZCB0byB0aGUgZW5kXG4gICAgICAucGlwZVRocm91Z2goY3JlYXRlTW92ZVN1ZmZpeFN0cmVhbSgpKVxuICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVEb2N1bWVudENsb3NpbmdTdHJlYW0oKTogUmVhZGFibGVTdHJlYW08VWludDhBcnJheT4ge1xuICByZXR1cm4gc3RyZWFtRnJvbVN0cmluZyhDTE9TRV9UQUcpXG59XG4iXSwibmFtZXMiOlsiZ2V0VHJhY2VyIiwiQXBwUmVuZGVyU3BhbiIsIkRldGFjaGVkUHJvbWlzZSIsInNjaGVkdWxlSW1tZWRpYXRlIiwiYXRMZWFzdE9uZVRhc2siLCJFTkNPREVEX1RBR1MiLCJpbmRleE9mVWludDhBcnJheSIsImlzRXF1aXZhbGVudFVpbnQ4QXJyYXlzIiwicmVtb3ZlRnJvbVVpbnQ4QXJyYXkiLCJNSVNTSU5HX1JPT1RfVEFHU19FUlJPUiIsImluc2VydEJ1aWxkSWRDb21tZW50Iiwidm9pZENhdGNoIiwiZW5jb2RlciIsIlRleHRFbmNvZGVyIiwiY2hhaW5TdHJlYW1zIiwic3RyZWFtcyIsImxlbmd0aCIsIkVycm9yIiwicmVhZGFibGUiLCJ3cml0YWJsZSIsIlRyYW5zZm9ybVN0cmVhbSIsInByb21pc2UiLCJwaXBlVG8iLCJwcmV2ZW50Q2xvc2UiLCJpIiwibmV4dFN0cmVhbSIsInRoZW4iLCJsYXN0U3RyZWFtIiwiY2F0Y2giLCJzdHJlYW1Gcm9tU3RyaW5nIiwic3RyIiwiUmVhZGFibGVTdHJlYW0iLCJzdGFydCIsImNvbnRyb2xsZXIiLCJlbnF1ZXVlIiwiZW5jb2RlIiwiY2xvc2UiLCJzdHJlYW1Gcm9tQnVmZmVyIiwiY2h1bmsiLCJzdHJlYW1Ub0J1ZmZlciIsInN0cmVhbSIsInJlYWRlciIsImdldFJlYWRlciIsImNodW5rcyIsImRvbmUiLCJ2YWx1ZSIsInJlYWQiLCJwdXNoIiwiQnVmZmVyIiwiY29uY2F0Iiwic3RyZWFtVG9TdHJpbmciLCJzaWduYWwiLCJkZWNvZGVyIiwiVGV4dERlY29kZXIiLCJmYXRhbCIsInN0cmluZyIsImFib3J0ZWQiLCJkZWNvZGUiLCJjcmVhdGVCdWZmZXJlZFRyYW5zZm9ybVN0cmVhbSIsImJ1ZmZlcmVkQ2h1bmtzIiwiYnVmZmVyQnl0ZUxlbmd0aCIsInBlbmRpbmciLCJmbHVzaCIsImRldGFjaGVkIiwiVWludDhBcnJheSIsImNvcGllZEJ5dGVzIiwiYnVmZmVyZWRDaHVuayIsInNldCIsImJ5dGVMZW5ndGgiLCJ1bmRlZmluZWQiLCJyZXNvbHZlIiwidHJhbnNmb3JtIiwiY3JlYXRlUHJlZmV0Y2hDb21tZW50U3RyZWFtIiwiaXNCdWlsZFRpbWVQcmVyZW5kZXJpbmciLCJidWlsZElkIiwiZGlkVHJhbnNmb3JtRmlyc3RDaHVuayIsImNodW5rU3RyIiwidXBkYXRlZENodW5rU3RyIiwicmVuZGVyVG9Jbml0aWFsRml6elN0cmVhbSIsIlJlYWN0RE9NU2VydmVyIiwiZWxlbWVudCIsInN0cmVhbU9wdGlvbnMiLCJ0cmFjZSIsInJlbmRlclRvUmVhZGFibGVTdHJlYW0iLCJjcmVhdGVNZXRhZGF0YVRyYW5zZm9ybVN0cmVhbSIsImluc2VydCIsImNodW5rSW5kZXgiLCJpc01hcmtSZW1vdmVkIiwiaWNvbk1hcmtJbmRleCIsImNsb3NlZEhlYWRJbmRleCIsImljb25NYXJrTGVuZ3RoIiwiTUVUQSIsIklDT05fTUFSSyIsIkNMT1NFRCIsIkhFQUQiLCJyZXBsYWNlZCIsInN1YmFycmF5IiwiaW5zZXJ0aW9uIiwiZW5jb2RlZEluc2VydGlvbiIsImluc2VydGlvbkxlbmd0aCIsImNyZWF0ZUhlYWRJbnNlcnRpb25UcmFuc2Zvcm1TdHJlYW0iLCJpbnNlcnRlZCIsImhhc0J5dGVzIiwiaW5kZXgiLCJpbnNlcnRlZEhlYWRDb250ZW50Iiwic2xpY2UiLCJjcmVhdGVEZWZlcnJlZFN1ZmZpeFN0cmVhbSIsInN1ZmZpeCIsImZsdXNoZWQiLCJjcmVhdGVNZXJnZWRUcmFuc2Zvcm1TdHJlYW0iLCJwdWxsIiwiZG9uZVB1bGxpbmciLCJzdGFydFB1bGxpbmciLCJlcnIiLCJlcnJvciIsIkNMT1NFX1RBRyIsImNyZWF0ZU1vdmVTdWZmaXhTdHJlYW0iLCJmb3VuZFN1ZmZpeCIsIkJPRFlfQU5EX0hUTUwiLCJiZWZvcmUiLCJhZnRlciIsImNyZWF0ZVN0cmlwRG9jdW1lbnRDbG9zaW5nVGFnc1RyYW5zZm9ybSIsIkJPRFkiLCJIVE1MIiwiY3JlYXRlUm9vdExheW91dFZhbGlkYXRvclN0cmVhbSIsImZvdW5kSHRtbCIsImZvdW5kQm9keSIsIk9QRU5JTkciLCJtaXNzaW5nVGFncyIsIm1hcCIsImMiLCJqb2luIiwiY2hhaW5UcmFuc2Zvcm1lcnMiLCJ0cmFuc2Zvcm1lcnMiLCJ0cmFuc2Zvcm1lciIsInBpcGVUaHJvdWdoIiwiY29udGludWVGaXp6U3RyZWFtIiwicmVuZGVyU3RyZWFtIiwiaW5saW5lZERhdGFTdHJlYW0iLCJpc1N0YXRpY0dlbmVyYXRpb24iLCJnZXRTZXJ2ZXJJbnNlcnRlZEhUTUwiLCJnZXRTZXJ2ZXJJbnNlcnRlZE1ldGFkYXRhIiwidmFsaWRhdGVSb290TGF5b3V0Iiwic3VmZml4VW5jbG9zZWQiLCJzcGxpdCIsImFsbFJlYWR5IiwiY29udGludWVEeW5hbWljUHJlcmVuZGVyIiwicHJlcmVuZGVyU3RyZWFtIiwiY29udGludWVTdGF0aWNQcmVyZW5kZXIiLCJjb250aW51ZUR5bmFtaWNIVE1MUmVzdW1lIiwiY3JlYXRlRG9jdW1lbnRDbG9zaW5nU3RyZWFtIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQSxTQUFTQSxTQUFTLFFBQVEsc0JBQXFCO0FBQy9DLFNBQVNDLGFBQWEsUUFBUSx5QkFBd0I7QUFDdEQsU0FBU0MsZUFBZSxRQUFRLDZCQUE0QjtBQUM1RCxTQUFTQyxpQkFBaUIsRUFBRUMsY0FBYyxRQUFRLHNCQUFxQjtBQUN2RSxTQUFTQyxZQUFZLFFBQVEsaUJBQWdCO0FBQzdDLFNBQ0VDLGlCQUFpQixFQUNqQkMsdUJBQXVCLEVBQ3ZCQyxvQkFBb0IsUUFDZix1QkFBc0I7QUFDN0IsU0FBU0MsdUJBQXVCLFFBQVEsb0NBQW1DO0FBQzNFLFNBQVNDLG9CQUFv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REgsV0FBVyxDQUFDbkI7QUFFbkI7QUFFTyxTQUFTa0M7SUFDZCxPQUFPekgsaUJBQWlCc0Y7QUFDMUIiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTAxNjcsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NyYy9zaGFyZWQvbGliL3NlZ21lbnQtY2FjaGUvc2VnbWVudC12YWx1ZS1lbmNvZGluZy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQQUdFX1NFR01FTlRfS0VZIH0gZnJvbSAnLi4vc2VnbWVudCdcbmltcG9ydCB0eXBlIHsgU2VnbWVudCBhcyBGbGlnaHRSb3V0ZXJTdGF0ZVNlZ21lbnQgfSBmcm9tICcuLi8uLi8uLi9zZXJ2ZXIvYXBwLXJlbmRlci90eXBlcydcblxuLy8gVHlwZVNjcmlwdCB0cmljayB0byBzaW11bGF0ZSBvcGFxdWUgdHlwZXMsIGxpa2UgaW4gRmxvdy5cbnR5cGUgT3BhcXVlPEssIFQ+ID0gVCAmIHsgX19icmFuZDogSyB9XG5cbmV4cG9ydCB0eXBlIEVuY29kZWRTZWdtZW50ID0gT3BhcXVlPCdFbmNvZGVkU2VnbWVudCcsIHN0cmluZz5cblxuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZVNlZ21lbnQoXG4gIHNlZ21lbnQ6IEZsaWdodFJvdXRlclN0YXRlU2VnbWVudFxuKTogRW5jb2RlZFNlZ21lbnQge1xuICBpZiAodHlwZW9mIHNlZ21lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHNlZ21lbnQuc3RhcnRzV2l0aChQQUdFX1NFR01FTlRfS0VZKSkge1xuICAgICAgLy8gVGhlIEZsaWdodCBSb3V0ZXIgU3RhdGUgdHlwZSBzb21ldGltZXMgaW5jbHVkZXMgdGhlIHNlYXJjaCBwYXJhbXMgaW5cbiAgICAgIC8vIHRoZSBwYWdlIHNlZ21lbnQuIEhvd2V2ZXIsIHRoZSBTZWdtZW50IENhY2hlIHRyYWNrcyB0aGlzIGFzIGEgc2VwYXJhdGVcbiAgICAgIC8vIGtleS4gU28sIHdlIHN0cmlwIHRoZSBzZWFyY2ggcGFyYW1zIGhlcmUsIGFuZCB0aGVuIGFkZCB0aGVtIGJhY2sgd2hlblxuICAgICAgLy8gdGhlIGNhY2hlIGVudHJ5IGlzIHR1cm5lZCBiYWNrIGludG8gYSBGbGlnaHRSb3V0ZXJTdGF0ZS4gVGhpcyBpcyBhblxuICAgICAgLy8gdW5mb3J0dW5hdGUgY29uc2VxdWVuY2Ugb2YgdGhlIEZsaWdodFJvdXRlU3RhdGUgYmVpbmcgdXNlZCBib3RoIGFzIGFcbiAgICAgIC8vIHRyYW5zcG9ydCB0eXBlIGFuZCBhcyBhIGNhY2hlIGtleTsgd2UnbGwgYWRkcmVzcyB0aGlzIG9uY2UgbW9yZSBvZiB0aGVcbiAgICAgIC8vIFNlZ21lbnQgQ2FjaGUgaW1wbGVtZW50YXRpb24gaGFzIHNldHRsZWQuXG4gICAgICAvLyBUT0RPOiBXZSBzaG91bGQgaG9pc3QgdGhlIHNlYXJjaCBwYXJhbXMgb3V0IG9mIHRoZSBGbGlnaHRSb3V0ZXJTdGF0ZVxuICAgICAgLy8gdHlwZSBlbnRpcmVseSwgVGhpcyBpcyBvdXIgcGxhbiBmb3IgZHluYW1pYyByb3V0ZSBwYXJhbXMsIHRvby5cbiAgICAgIHJldHVybiBQQUdFX1NFR01FTlRfS0VZIGFzIEVuY29kZWRTZWdtZW50XG4gICAgfVxuICAgIGNvbnN0IHNhZmVOYW1lID1cbiAgICAgIC8vIFRPRE86IEZsaWdodFJvdXRlclN0YXRlIGVuY29kZXMgTm90IEZvdW5kIHJvdXRlcyBhcyBcIi9fbm90LWZvdW5kXCIuXG4gICAgICAvLyBCdXQgcGFyYW1zIHR5cGljYWxseSBkb24ndCBpbmNsdWRlIHRoZSBsZWFkaW5nIHNsYXNoLiBXZSBzaG91bGQgdXNlXG4gICAgICAvLyBhIGRpZmZlcmVudCBlbmNvZGluZyB0byBhdm9pZCB0aGlzIHNwZWNpYWwgY2FzZS5cbiAgICAgIHNlZ21lbnQgPT09ICcvX25vdC1mb3VuZCdcbiAgICAgICAgPyAnX25vdC1mb3VuZCdcbiAgICAgICAgOiBlbmNvZGVUb0ZpbGVzeXN0ZW1BbmRVUkxTYWZlU3RyaW5nKHNlZ21lbnQpXG4gICAgLy8gU2luY2UgdGhpcyBpcyBub3QgYSBkeW5hbWljIHNlZ21lbnQsIGl0J3MgZnVsbHkgZW5jb2RlZC4gSXQgZG9lcyBub3RcbiAgICAvLyBuZWVkIHRvIGJlIFwiaHlkcmF0ZWRcIiB3aXRoIGEgcGFyYW0gdmFsdWUuXG4gICAgcmV0dXJuIHNhZmVOYW1lIGFzIEVuY29kZWRTZWdtZW50XG4gIH1cbiAgY29uc3QgbmFtZSA9IHNlZ21lbnRbMF1cbiAgY29uc3QgcGFyYW1WYWx1ZSA9IHNlZ21lbnRbMV1cbiAgY29uc3QgcGFyYW1UeXBlID0gc2VnbWVudFsyXVxuICBjb25zdCBzYWZlTmFtZSA9IGVuY29kZVRvRmlsZXN5c3RlbUFuZFVSTFNhZmVTdHJpbmcobmFtZSlcbiAgY29uc3Qgc2FmZVZhbHVlID0gZW5jb2RlVG9GaWxlc3lzdGVtQW5kVVJMU2FmZVN0cmluZyhwYXJhbVZhbHVlKVxuXG4gIGNvbnN0IGVuY29kZWROYW1lID0gJyQnICsgcGFyYW1UeXBlICsgJyQnICsgc2FmZU5hbWUgKyAnJCcgKyBzYWZlVmFsdWVcbiAgcmV0dXJuIGVuY29kZWROYW1lIGFzIEVuY29kZWRTZWdtZW50XG59XG5cbmV4cG9ydCBjb25zdCBST09UX1NFR01FTlRfS0VZID0gJydcblxuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZUNoaWxkU2VnbWVudEtleShcbiAgLy8gVE9ETzogTWFrZSBzZWdtZW50IGtleXMgYW4gb3BhcXVlIHR5cGUsIHRvbz9cbiAgcGFyZW50U2VnbWVudEtleTogc3RyaW5nLFxuICBwYXJhbGxlbFJvdXRlS2V5OiBzdHJpbmcsXG4gIHNlZ21lbnQ6IEVuY29kZWRTZWdtZW50XG4pOiBzdHJpbmcge1xuICAvLyBBc2lkZSBmcm9tIGJlaW5nIGZpbGVzeXN0ZW0gc2FmZSwgc2VnbWVudCBrZXlzIGFyZSBhbHNvIGRlc2lnbmVkIHNvIHRoYXRcbiAgLy8gZWFjaCBzZWdtZW50IGFuZCBwYXJhbGxlbCByb3V0ZSBjcmVhdGVzIGl0cyBvd24gc3ViZGlyZWN0b3J5LiBSb3VnaGx5IGluXG4gIC8vIHRoZSBzYW1lIHNoYXBlIGFzIHRoZSBzb3VyY2UgYXBwIGRpcmVjdG9yeS4gVGhpcyBpcyBtb3N0bHkganVzdCBmb3IgZWFzaWVyXG4gIC8vIGRlYnVnZ2luZyAoeW91IGNhbiBvcGVuIHVwIHRoZSBidWlsZCBmb2xkZXIgYW5kIG5hdmlnYXRlIHRoZSBvdXRwdXQpOyBpZlxuICAvLyB3ZSB3YW50ZWQgdG8gZG8gd2UgY291bGQganVzdCB1c2UgYSBmbGF0IHN0cnVjdHVyZS5cblxuICAvLyBPbWl0IHRoZSBwYXJhbGxlbCByb3V0ZSBrZXkgZm9yIGNoaWxkcmVuLCBzaW5jZSB0aGlzIGlzIHRoZSBtb3N0XG4gIC8vIGNvbW1vbiBjYXNlLiBTYXZlcyBzb21lIGJ5dGVzIChhbmQgaXQncyB3aGF0IHRoZSBhcHAgZGlyZWN0b3J5IGRvZXMpLlxuICBjb25zdCBzbG90S2V5ID1cbiAgICBwYXJhbGxlbFJvdXRlS2V5ID09PSAnY2hpbGRyZW4nXG4gICAgICA/IHNlZ21lbnRcbiAgICAgIDogYEAke2VuY29kZVRvRmlsZXN5c3RlbUFuZFVSTFNhZmVTdHJpbmcocGFyYWxsZWxSb3V0ZUtleSl9LyR7c2VnbWVudH1gXG5cbiAgcmV0dXJuIHBhcmVudFNlZ21lbnRLZXkgKyAnLycgKyBzbG90S2V5XG59XG5cbi8vIERlZmluZSBhIHJlZ2V4IHBhdHRlcm4gdG8gbWF0Y2ggdGhlIG1vc3QgY29tbW9uIGNoYXJhY3RlcnMgZm91bmQgaW4gYSByb3V0ZVxuLy8gcGFyYW0uIEl0IGV4Y2x1ZGVzIGFueXRoaW5nIHRoYXQgbWlnaHQgbm90IGJlIGNyb3NzLXBsYXRmb3JtIGZpbGVzeXN0ZW1cbi8vIGNvbXBhdGlibGUsIGxpa2UgfC4gSXQgZG9lcyBub3QgbmVlZCB0byBiZSBwcmVjaXNlIGJlY2F1c2UgdGhlIGZhbGxiYWNrIGlzIHRvXG4vLyBqdXN0IGJhc2U2NHVybC1lbmNvZGUgdGhlIHdob2xlIHBhcmFtZXRlciwgd2hpY2ggaXMgZmluZTsgd2UganVzdCBkb24ndCBkbyBpdFxuLy8gYnkgZGVmYXVsdCBmb3IgY29tcGFjdG5lc3MsIGFuZCBmb3IgZWFzaWVyIGRlYnVnZ2luZy5cbmNvbnN0IHNpbXBsZVBhcmFtVmFsdWVSZWdleCA9IC9eW2EtekEtWjAtOVxcLV9AXSskL1xuXG5mdW5jdGlvbiBlbmNvZGVUb0ZpbGVzeXN0ZW1BbmRVUkxTYWZlU3RyaW5nKHZhbHVlOiBzdHJpbmcpIHtcbiAgaWYgKHNpbXBsZVBhcmFtVmFsdWVSZWdleC50ZXN0KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZVxuICB9XG4gIC8vIElmIHRoZXJlIGFyZSBhbnkgdW5zYWZlIGNoYXJhY3RlcnMsIGJhc2U2NHVybC1lbmNvZGUgdGhlIGVudGlyZSB2YWx1ZS5cbiAgLy8gV2UgYWxzbyBhZGQgYSAhIHByZWZpeCBzbyBpdCBkb2Vzbid0IGNvbGxpZGUgd2l0aCB0aGUgc2ltcGxlIGNhc2UuXG4gIGNvbnN0IGJhc2U2NHVybCA9IGJ0b2EodmFsdWUpXG4gICAgLnJlcGxhY2UoL1xcKy9nLCAnLScpIC8vIFJlcGxhY2UgJysnIHdpdGggJy0nXG4gICAgLnJlcGxhY2UoL1xcLy9nLCAnXycpIC8vIFJlcGxhY2UgJy8nIHdpdGggJ18nXG4gICAgLnJlcGxhY2UoLz0rJC8sICcnKSAvLyBSZW1vdmUgdHJhaWxpbmcgJz0nXG4gIHJldHVybiAnIScgKyBiYXNlNjR1cmxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRTZWdtZW50UGF0aFRvU3RhdGljRXhwb3J0RmlsZW5hbWUoXG4gIHNlZ21lbnRQYXRoOiBzdHJpbmdcbik6IHN0cmluZyB7XG4gIHJldHVybiBgX19uZXh0JHtzZWdtZW50UGF0aC5yZXBsYWNlKC9cXC8vZywgJy4nKX0udHh0YFxufVxuIl0sIm5hbWVzIjpbIlBBR0VfU0VHTUVOVF9LRVkiLCJlbmNvZGVTZWdtZW50Iiwic2VnbWVudCIsInN0YXJ0c1dpdGgiLCJzYWZlTmFtZSIsImVuY29kZVRvRmlsZXN5c3RlbUFuZFVSTFNhZmVTdHJpbmciLCJuYW1lIiwicGFyYW1WYWx1ZSIsInBhcmFtVHlwZSIsInNhZmVWYWx1ZSIsImVuY29kZWROYW1lIiwiUk9PVF9TRUdNRU5UX0tFWSIsImVuY29kZUNoaWxkU2VnbWVudEtleSIsInBhcmVudFNlZ21lbnRLZXkiLCJwYXJhbGxlbFJvdXRlS2V5Iiwic2xvdEtleSIsInNpbXBsZVBhcmFtVmFsdWVSZWdleCIsInZhbHVlIiwidGVzdCIsImJhc2U2NHVybCIsImJ0b2EiLCJyZXBsYWNlIiwiY29udmVydFNlZ21lbnRQYXRoVG9TdGF0aWNFeHBvcnRGaWxlbmFtZSIsInNlZ21lbnRQYXRoIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxTQUFTQSxnQkFBZ0IsUUFBUSxhQUFZOztBQVF0QyxTQUFTQyxjQUNkQyxPQUFpQztJQUVqQyxJQUFJLE9BQU9BLFlBQVksVUFBVTtRQUMvQixJQUFJQSxRQUFRQyxVQUFVLGlLQUFDSCxtQkFBQUEsR0FBbUI7WUFDeEMsdUVBQXVFO1lBQ3ZFLHlFQUF5RTtZQUN6RSx3RUFBd0U7WUFDeEUsc0VBQXNFO1lBQ3RFLHVFQUF1RTtZQUN2RSx5RUFBeUU7WUFDekUsNENBQTRDO1lBQzVDLHVFQUF1RTtZQUN2RSxpRUFBaUU7WUFDakUsdUtBQU9BLG1CQUFBQTtRQUNUO1FBQ0EsTUFBTUksV0FDSixBQUNBLHFFQURxRSxDQUNDO1FBQ3RFLG1EQUFtRDtRQUNuREYsWUFBWSxnQkFDUixlQUNBRyxtQ0FBbUNIO1FBQ3pDLHVFQUF1RTtRQUN2RSw0Q0FBNEM7UUFDNUMsT0FBT0U7SUFDVDtJQUNBLE1BQU1FLE9BQU9KLE9BQU8sQ0FBQyxFQUFFO0lBQ3ZCLE1BQU1LLGFBQWFMLE9BQU8sQ0FBQyxFQUFFO0lBQzdCLE1BQU1NLFlBQVlOLE9BQU8sQ0FBQyxFQUFFO0lBQzVCLE1BQU1FLFdBQVdDLG1DQUFtQ0M7SUFDcEQsTUFBTUcsWUFBWUosbUNBQW1DRTtJQUVyRCxNQUFNRyxjQUFjLE1BQU1GLFlBQVksTUFBTUosV0FBVyxNQUFNSztJQUM3RCxPQUFPQztBQUNUO0FBRU8sTUFBTUMsbUJBQW1CLEdBQUU7QUFFM0IsU0FBU0Msc0JBQ2QsQUFDQUMsZ0JBQXdCLEVBQ3hCQyxnQkFBd0IsRUFDeEJaLE9BQXVCLElBSHdCO0lBSy9DLDJFQUEyRTtJQUMzRSwyRUFBMkU7SUFDM0UsNkVBQTZFO0lBQzdFLDJFQUEyRTtJQUMzRSxzREFBc0Q7SUFFdEQsbUVBQW1FO0lBQ25FLHdFQUF3RTtJQUN4RSxNQUFNYSxVQUNKRCxxQkFBcUIsYUFDakJaLFVBQ0MsTUFBR0csbUNBQW1DUyxvQkFBa0IsTUFBR1o7SUFFbEUsT0FBT1csbUJBQW1CLE1BQU1FO0FBQ2xDO0FBRUEsOEVBQThFO0FBQzlFLDBFQUEwRTtBQUMxRSxnRkFBZ0Y7QUFDaEYsZ0ZBQWdGO0FBQ2hGLHdEQUF3RDtBQUN4RCxNQUFNQyx3QkFBd0I7QUFFOUIsU0FBU1gsbUNBQW1DWSxLQUFhO0lBQ3ZELElBQUlELHNCQUFzQkUsSUFBSSxDQUFDRCxRQUFRO1FBQ3JDLE9BQU9BO0lBQ1Q7SUFDQSx5RUFBeUU7SUFDekUscUVBQXFFO0lBQ3JFLE1BQU1FLFlBQVlDLEtBQUtILE9BQ3BCSSxPQUFPLENBQUMsT0FBTyxLQUFLLHVCQUF1QjtLQUMzQ0EsT0FBTyxDQUFDLE9BQU8sS0FBSyx1QkFBdUI7S0FDM0NBLE9BQU8sQ0FBQyxPQUFPLElBQUksc0JBQXNCOztJQUM1QyxPQUFPLE1BQU1GO0FBQ2Y7QUFFTyxTQUFTRyx5Q0FDZEMsV0FBbUI7SUFFbkIsT0FBUSxXQUFRQSxZQUFZRixPQUFPLENBQUMsT0FBTyxPQUFLO0FBQ2xEIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDEwMjQyLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9zdHJpbmctaGFzaC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIoKCk9PntcInVzZSBzdHJpY3RcIjt2YXIgZT17MzI4OmU9PntmdW5jdGlvbiBoYXNoKGUpe3ZhciByPTUzODEsXz1lLmxlbmd0aDt3aGlsZShfKXtyPXIqMzNeZS5jaGFyQ29kZUF0KC0tXyl9cmV0dXJuIHI+Pj4wfWUuZXhwb3J0cz1oYXNofX07dmFyIHI9e307ZnVuY3Rpb24gX19uY2N3cGNrX3JlcXVpcmVfXyhfKXt2YXIgYT1yW19dO2lmKGEhPT11bmRlZmluZWQpe3JldHVybiBhLmV4cG9ydHN9dmFyIHQ9cltfXT17ZXhwb3J0czp7fX07dmFyIGk9dHJ1ZTt0cnl7ZVtfXSh0LHQuZXhwb3J0cyxfX25jY3dwY2tfcmVxdWlyZV9fKTtpPWZhbHNlfWZpbmFsbHl7aWYoaSlkZWxldGUgcltfXX1yZXR1cm4gdC5leHBvcnRzfWlmKHR5cGVvZiBfX25jY3dwY2tfcmVxdWlyZV9fIT09XCJ1bmRlZmluZWRcIilfX25jY3dwY2tfcmVxdWlyZV9fLmFiPV9fZGlybmFtZStcIi9cIjt2YXIgXz1fX25jY3dwY2tfcmVxdWlyZV9fKDMyOCk7bW9kdWxlLmV4cG9ydHM9X30pKCk7Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLENBQUM7SUFBSztJQUFhLElBQUksSUFBRTtRQUFDLEtBQUksQ0FBQTtZQUFJLFNBQVMsS0FBSyxDQUFDO2dCQUFFLElBQUksSUFBRSxNQUFLLElBQUUsRUFBRSxNQUFNO2dCQUFDLE1BQU0sRUFBRTtvQkFBQyxJQUFFLElBQUUsS0FBRyxFQUFFLFVBQVUsQ0FBQyxFQUFFO2dCQUFFO2dCQUFDLE9BQU8sTUFBSTtZQUFDO1lBQUMsRUFBRSxPQUFPLEdBQUM7UUFBSTtJQUFDO0lBQUUsSUFBSSxJQUFFLENBQUM7SUFBRSxTQUFTLG9CQUFvQixDQUFDO1FBQUUsSUFBSSxJQUFFLENBQUMsQ0FBQyxFQUFFO1FBQUMsSUFBRyxNQUFJLFdBQVU7WUFBQyxPQUFPLEVBQUUsT0FBTztRQUFBO1FBQUMsSUFBSSxJQUFFLENBQUMsQ0FBQyxFQUFFLEdBQUM7WUFBQyxTQUFRLENBQUM7UUFBQztRQUFFLElBQUksSUFBRTtRQUFLLElBQUc7WUFBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUUsRUFBRSxPQUFPLEVBQUM7WUFBcUIsSUFBRTtRQUFLLFNBQVE7WUFBQyxJQUFHLEdBQUUsT0FBTyxDQUFDLENBQUMsRUFBRTtRQUFBO1FBQUMsT0FBTyxFQUFFLE9BQU87SUFBQTtJQUFDLElBQUcsT0FBTyx3QkFBc0IsYUFBWSxvQkFBb0IsRUFBRSxHQUFDLHdGQUFVO0lBQUksSUFBSSxJQUFFLG9CQUFvQjtJQUFLLE9BQU8sT0FBTyxHQUFDO0FBQUMsQ0FBQyIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxMDI4MiwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL2xpYi9mb3JtYXQtc2VydmVyLWVycm9yLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGludmFsaWRTZXJ2ZXJDb21wb25lbnRSZWFjdEhvb2tzID0gW1xuICAndXNlRGVmZXJyZWRWYWx1ZScsXG4gICd1c2VFZmZlY3QnLFxuICAndXNlSW1wZXJhdGl2ZUhhbmRsZScsXG4gICd1c2VJbnNlcnRpb25FZmZlY3QnLFxuICAndXNlTGF5b3V0RWZmZWN0JyxcbiAgJ3VzZVJlZHVjZXInLFxuICAndXNlUmVmJyxcbiAgJ3VzZVN0YXRlJyxcbiAgJ3VzZVN5bmNFeHRlcm5hbFN0b3JlJyxcbiAgJ3VzZVRyYW5zaXRpb24nLFxuICAnZXhwZXJpbWVudGFsX3VzZU9wdGltaXN0aWMnLFxuICAndXNlT3B0aW1pc3RpYycsXG5dXG5cbmZ1bmN0aW9uIHNldE1lc3NhZ2UoZXJyb3I6IEVycm9yLCBtZXNzYWdlOiBzdHJpbmcpOiB2b2lkIHtcbiAgZXJyb3IubWVzc2FnZSA9IG1lc3NhZ2VcbiAgaWYgKGVycm9yLnN0YWNrKSB7XG4gICAgY29uc3QgbGluZXMgPSBlcnJvci5zdGFjay5zcGxpdCgnXFxuJylcbiAgICBsaW5lc1swXSA9IG1lc3NhZ2VcbiAgICBlcnJvci5zdGFjayA9IGxpbmVzLmpvaW4oJ1xcbicpXG4gIH1cbn1cblxuLyoqXG4gKiBJbnB1dDpcbiAqIEVycm9yOiBTb21ldGhpbmcgd2VudCB3cm9uZ1xuICAgIGF0IGZ1bmNOYW1lICgvcGF0aC90by9maWxlLmpzOjEwOjUpXG4gICAgYXQgYW5vdGhlckZ1bmMgKC9wYXRoL3RvL2ZpbGUuanM6MTU6MTApXG4gXG4gKiBPdXRwdXQ6XG4gICAgYXQgZnVuY05hbWUgKC9wYXRoL3RvL2ZpbGUuanM6MTA6NSlcbiAgICBhdCBhbm90aGVyRnVuYyAoL3BhdGgvdG8vZmlsZS5qczoxNToxMCkgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTdGFja1dpdGhvdXRFcnJvck1lc3NhZ2UoZXJyb3I6IEVycm9yKTogc3RyaW5nIHtcbiAgY29uc3Qgc3RhY2sgPSBlcnJvci5zdGFja1xuICBpZiAoIXN0YWNrKSByZXR1cm4gJydcbiAgcmV0dXJuIHN0YWNrLnJlcGxhY2UoL15bXlxcbl0qXFxuLywgJycpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRTZXJ2ZXJFcnJvcihlcnJvcjogRXJyb3IpOiB2b2lkIHtcbiAgaWYgKHR5cGVvZiBlcnJvcj8ubWVzc2FnZSAhPT0gJ3N0cmluZycpIHJldHVyblxuXG4gIGlmIChcbiAgICBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKFxuICAgICAgJ0NsYXNzIGV4dGVuZHMgdmFsdWUgdW5kZWZpbmVkIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGwnXG4gICAgKVxuICApIHtcbiAgICBjb25zdCBhZGRlZE1lc3NhZ2UgPVxuICAgICAgJ1RoaXMgbWlnaHQgYmUgY2F1c2VkIGJ5IGEgUmVhY3QgQ2xhc3MgQ29tcG9uZW50IGJlaW5nIHJlbmRlcmVkIGluIGEgU2VydmVyIENvbXBvbmVudCwgUmVhY3QgQ2xhc3MgQ29tcG9uZW50cyBvbmx5IHdvcmtzIGluIENsaWVudCBDb21wb25lbnRzLiBSZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2NsYXNzLWNvbXBvbmVudC1pbi1zZXJ2ZXItY29tcG9uZW50J1xuXG4gICAgLy8gSWYgdGhpcyBlcnJvciBpbnN0YW5jZSBhbHJlYWR5IGhhcyB0aGUgbWVzc2FnZSwgZG9uJ3QgYWRkIGl0IGFnYWluXG4gICAgaWYgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoYWRkZWRNZXNzYWdlKSkgcmV0dXJuXG5cbiAgICBzZXRNZXNzYWdlKFxuICAgICAgZXJyb3IsXG4gICAgICBgJHtlcnJvci5tZXNzYWdlfVxuXG4ke2FkZGVkTWVzc2FnZX1gXG4gICAgKVxuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ2NyZWF0ZUNvbnRleHQgaXMgbm90IGEgZnVuY3Rpb24nKSkge1xuICAgIHNldE1lc3NhZ2UoXG4gICAgICBlcnJvcixcbiAgICAgICdjcmVhdGVDb250ZXh0IG9ubHkgd29ya3MgaW4gQ2xpZW50IENvbXBvbmVudHMuIEFkZCB0aGUgXCJ1c2UgY2xpZW50XCIgZGlyZWN0aXZlIGF0IHRoZSB0b3Agb2YgdGhlIGZpbGUgdG8gdXNlIGl0LiBSZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2NvbnRleHQtaW4tc2VydmVyLWNvbXBvbmVudCdcbiAgICApXG4gICAgcmV0dXJuXG4gIH1cblxuICBmb3IgKGNvbnN0IGNsaWVudEhvb2sgb2YgaW52YWxpZFNlcnZlckNvbXBvbmVudFJlYWN0SG9va3MpIHtcbiAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAoYFxcXFxiJHtjbGllbnRIb29rfVxcXFxiLippcyBub3QgYSBmdW5jdGlvbmApXG4gICAgaWYgKHJlZ2V4LnRlc3QoZXJyb3IubWVzc2FnZSkpIHtcbiAgICAgIHNldE1lc3NhZ2UoXG4gICAgICAgIGVycm9yLFxuICAgICAgICBgJHtjbGllbnRIb29rfSBvbmx5IHdvcmtzIGluIENsaWVudCBDb21wb25lbnRzLiBBZGQgdGhlIFwidXNlIGNsaWVudFwiIGRpcmVjdGl2ZSBhdCB0aGUgdG9wIG9mIHRoZSBmaWxlIHRvIHVzZSBpdC4gUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9yZWFjdC1jbGllbnQtaG9vay1pbi1zZXJ2ZXItY29tcG9uZW50YFxuICAgICAgKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOlsiaW52YWxpZFNlcnZlckNvbXBvbmVudFJlYWN0SG9va3MiLCJzZXRNZXNzYWdlIiwiZXJyb3IiLCJtZXNzYWdlIiwic3RhY2siLCJsaW5lcyIsInNwbGl0Iiwiam9pbiIsImdldFN0YWNrV2l0aG91dEVycm9yTWVzc2FnZSIsInJlcGxhY2UiLCJmb3JtYXRTZXJ2ZXJFcnJvciIsImluY2x1ZGVzIiwiYWRkZWRNZXNzYWdlIiwiY2xpZW50SG9vayIsInJlZ2V4IiwiUmVnRXhwIiwidGVzdCJdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE1BQU1BLG1DQUFtQztJQUN2QztJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDRDtBQUVELFNBQVNDLFdBQVdDLEtBQVksRUFBRUMsT0FBZTtJQUMvQ0QsTUFBTUMsT0FBTyxHQUFHQTtJQUNoQixJQUFJRCxNQUFNRSxLQUFLLEVBQUU7UUFDZixNQUFNQyxRQUFRSCxNQUFNRSxLQUFLLENBQUNFLEtBQUssQ0FBQztRQUNoQ0QsS0FBSyxDQUFDLEVBQUUsR0FBR0Y7UUFDWEQsTUFBTUUsS0FBSyxHQUFHQyxNQUFNRSxJQUFJLENBQUM7SUFDM0I7QUFDRjtBQVlPLFNBQVNDLDRCQUE0Qk4sS0FBWTtJQUN0RCxNQUFNRSxRQUFRRixNQUFNRSxLQUFLO0lBQ3pCLElBQUksQ0FBQ0EsT0FBTyxPQUFPO0lBQ25CLE9BQU9BLE1BQU1LLE9BQU8sQ0FBQyxhQUFhO0FBQ3BDO0FBRU8sU0FBU0Msa0JBQWtCUixLQUFZO0lBQzVDLElBQUksT0FBQSxDQUFPQSxTQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxNQUFPQyxPQUFPLE1BQUssVUFBVTtJQUV4QyxJQUNFRCxNQUFNQyxPQUFPLENBQUNRLFFBQVEsQ0FDcEIsK0RBRUY7UUFDQSxNQUFNQyxlQUNKO1FBRUYscUVBQXFFO1FBQ3JFLElBQUlWLE1BQU1DLE9BQU8sQ0FBQ1EsUUFBUSxDQUFDQyxlQUFlO1FBRTFDWCxXQUNFQyxPQUNBLEdBQUdBLE1BQU1DLE9BQU8sQ0FBQzs7QUFFdkIsRUFBRVMsY0FBYztRQUVaO0lBQ0Y7SUFFQSxJQUFJVixNQUFNQyxPQUFPLENBQUNRLFFBQVEsQ0FBQyxvQ0FBb0M7UUFDN0RWLFdBQ0VDLE9BQ0E7UUFFRjtJQUNGO0lBRUEsS0FBSyxNQUFNVyxjQUFjYixpQ0FBa0M7UUFDekQsTUFBTWMsUUFBUSxJQUFJQyxPQUFPLENBQUMsR0FBRyxFQUFFRixXQUFXLHNCQUFzQixDQUFDO1FBQ2pFLElBQUlDLE1BQU1FLElBQUksQ0FBQ2QsTUFBTUMsT0FBTyxHQUFHO1lBQzdCRixXQUNFQyxPQUNBLEdBQUdXLFdBQVcsb0xBQW9MLENBQUM7WUFFck07UUFDRjtJQUNGO0FBQ0YiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTAzNDAsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NyYy9zZXJ2ZXIvcmVxdWVzdC1tZXRhLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIG5vLXJlZGVjbGFyZSAqL1xuaW1wb3J0IHR5cGUgeyBJbmNvbWluZ01lc3NhZ2UgfSBmcm9tICdodHRwJ1xuaW1wb3J0IHR5cGUgeyBQYXJzZWRVcmxRdWVyeSB9IGZyb20gJ3F1ZXJ5c3RyaW5nJ1xuaW1wb3J0IHR5cGUgeyBVcmxXaXRoUGFyc2VkUXVlcnkgfSBmcm9tICd1cmwnXG5pbXBvcnQgdHlwZSB7IEJhc2VOZXh0UmVxdWVzdCB9IGZyb20gJy4vYmFzZS1odHRwJ1xuaW1wb3J0IHR5cGUgeyBDbG9uZWFibGVCb2R5IH0gZnJvbSAnLi9ib2R5LXN0cmVhbXMnXG5pbXBvcnQgdHlwZSB7IFJvdXRlTWF0Y2ggfSBmcm9tICcuL3JvdXRlLW1hdGNoZXMvcm91dGUtbWF0Y2gnXG5pbXBvcnQgdHlwZSB7IE5FWFRfUlNDX1VOSU9OX1FVRVJZIH0gZnJvbSAnLi4vY2xpZW50L2NvbXBvbmVudHMvYXBwLXJvdXRlci1oZWFkZXJzJ1xuaW1wb3J0IHR5cGUgeyBTZXJ2ZXJDb21wb25lbnRzSG1yQ2FjaGUgfSBmcm9tICcuL3Jlc3BvbnNlLWNhY2hlJ1xuaW1wb3J0IHR5cGUgeyBQYWdlc0Rldk92ZXJsYXlCcmlkZ2VUeXBlIH0gZnJvbSAnLi4vbmV4dC1kZXZ0b29scy91c2Vyc3BhY2UvcGFnZXMvcGFnZXMtZGV2LW92ZXJsYXktc2V0dXAnXG5cbi8vIEZJWE1FOiAod3lhdHRqb2gpIHRoaXMgaXMgYSB0ZW1wb3Jhcnkgc29sdXRpb24gdG8gYWxsb3cgdXMgdG8gcGFzcyBkYXRhIGJldHdlZW4gYnVuZGxlZCBtb2R1bGVzXG5leHBvcnQgY29uc3QgTkVYVF9SRVFVRVNUX01FVEEgPSBTeW1ib2wuZm9yKCdOZXh0SW50ZXJuYWxSZXF1ZXN0TWV0YScpXG5cbmV4cG9ydCB0eXBlIE5leHRJbmNvbWluZ01lc3NhZ2UgPSAoQmFzZU5leHRSZXF1ZXN0IHwgSW5jb21pbmdNZXNzYWdlKSAmIHtcbiAgW05FWFRfUkVRVUVTVF9NRVRBXT86IFJlcXVlc3RNZXRhXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVxdWVzdE1ldGEge1xuICAvKipcbiAgICogVGhlIHF1ZXJ5IHRoYXQgd2FzIHVzZWQgdG8gbWFrZSB0aGUgcmVxdWVzdC5cbiAgICovXG4gIGluaXRRdWVyeT86IFBhcnNlZFVybFF1ZXJ5XG5cbiAgLyoqXG4gICAqIFRoZSBVUkwgdGhhdCB3YXMgdXNlZCB0byBtYWtlIHRoZSByZXF1ZXN0LlxuICAgKi9cbiAgaW5pdFVSTD86IHN0cmluZ1xuXG4gIC8qKlxuICAgKiBUaGUgcHJvdG9jb2wgdGhhdCB3YXMgdXNlZCB0byBtYWtlIHRoZSByZXF1ZXN0LlxuICAgKi9cbiAgaW5pdFByb3RvY29sPzogc3RyaW5nXG5cbiAgLyoqXG4gICAqIFRoZSBib2R5IHRoYXQgd2FzIHJlYWQgZnJvbSB0aGUgcmVxdWVzdC4gVGhpcyBpcyB1c2VkIHRvIGFsbG93IHRoZSBib2R5IHRvXG4gICAqIGJlIHJlYWQgbXVsdGlwbGUgdGltZXMuXG4gICAqL1xuICBjbG9uYWJsZUJvZHk/OiBDbG9uZWFibGVCb2R5XG5cbiAgLyoqXG4gICAqIFRydWUgd2hlbiB0aGUgcmVxdWVzdCBtYXRjaGVkIGEgbG9jYWxlIGRvbWFpbiB0aGF0IHdhcyBjb25maWd1cmVkIGluIHRoZVxuICAgKiBuZXh0LmNvbmZpZy5qcyBmaWxlLlxuICAgKi9cbiAgaXNMb2NhbGVEb21haW4/OiBib29sZWFuXG5cbiAgLyoqXG4gICAqIFRydWUgd2hlbiB0aGUgcmVxdWVzdCBoYWQgbG9jYWxlIGluZm9ybWF0aW9uIHN0cmlwcGVkIGZyb20gdGhlIHBhdGhuYW1lXG4gICAqIHBhcnQgb2YgdGhlIFVSTC5cbiAgICovXG4gIGRpZFN0cmlwTG9jYWxlPzogYm9vbGVhblxuXG4gIC8qKlxuICAgKiBJZiB0aGUgcmVxdWVzdCBoYWQgaXQncyBVUkwgcmV3cml0dGVuLCB0aGlzIGlzIHRoZSBVUkwgaXQgd2FzIHJld3JpdHRlbiB0by5cbiAgICovXG4gIHJld3JvdGVVUkw/OiBzdHJpbmdcblxuICAvKipcbiAgICogVGhlIGNvb2tpZXMgdGhhdCB3ZXJlIGFkZGVkIGJ5IG1pZGRsZXdhcmUgYW5kIHdlcmUgYWRkZWQgdG8gdGhlIHJlc3BvbnNlLlxuICAgKi9cbiAgbWlkZGxld2FyZUNvb2tpZT86IHN0cmluZ1tdXG5cbiAgLyoqXG4gICAqIFRoZSBtYXRjaCBvbiB0aGUgcmVxdWVzdCBmb3IgYSBnaXZlbiByb3V0ZS5cbiAgICovXG4gIG1hdGNoPzogUm91dGVNYXRjaFxuXG4gIC8qKlxuICAgKiBUaGUgaW5jcmVtZW50YWwgY2FjaGUgdG8gdXNlIGZvciB0aGUgcmVxdWVzdC5cbiAgICovXG4gIGluY3JlbWVudGFsQ2FjaGU/OiBhbnlcblxuICAvKipcbiAgICogVGhlIHNlcnZlciBjb21wb25lbnRzIEhNUiBjYWNoZSwgb25seSBmb3IgZGV2LlxuICAgKi9cbiAgc2VydmVyQ29tcG9uZW50c0htckNhY2hlPzogU2VydmVyQ29tcG9uZW50c0htckNhY2hlXG5cbiAgLyoqXG4gICAqIEVxdWFscyB0aGUgc2VnbWVudCBwYXRoIHRoYXQgd2FzIHVzZWQgZm9yIHRoZSBwcmVmZXRjaCBSU0MgcmVxdWVzdC5cbiAgICovXG4gIHNlZ21lbnRQcmVmZXRjaFJTQ1JlcXVlc3Q/OiBzdHJpbmdcblxuICAvKipcbiAgICogVHJ1ZSB3aGVuIHRoZSByZXF1ZXN0IGlzIGZvciB0aGUgcHJlZmV0Y2ggZmxpZ2h0IGRhdGEuXG4gICAqL1xuICBpc1ByZWZldGNoUlNDUmVxdWVzdD86IHRydWVcblxuICAvKipcbiAgICogVHJ1ZSB3aGVuIHRoZSByZXF1ZXN0IGlzIGZvciB0aGUgZmxpZ2h0IGRhdGEuXG4gICAqL1xuICBpc1JTQ1JlcXVlc3Q/OiB0cnVlXG5cbiAgLyoqXG4gICAqIEEgc2VhcmNoIHBhcmFtIHNldCBieSB0aGUgTmV4dC5qcyBjbGllbnQgd2hlbiBwZXJmb3JtaW5nIFJTQyByZXF1ZXN0cy5cbiAgICogQmVjYXVzZSBzb21lIENETnMgZG8gbm90IHZhcnkgdGhlaXIgY2FjaGUgZW50cmllcyBvbiBvdXIgY3VzdG9tIGhlYWRlcnMsXG4gICAqIHRoaXMgc2VhcmNoIHBhcmFtIHJlcHJlc2VudHMgYSBoYXNoIG9mIHRoZSBoZWFkZXIgdmFsdWVzLiBGb3IgYW55IGNhY2hlZFxuICAgKiBSU0MgcmVxdWVzdCwgd2Ugc2hvdWxkIHZlcmlmeSB0aGF0IHRoZSBoYXNoIG1hdGNoZXMgYmVmb3JlIHJlc3BvbmRpbmcuXG4gICAqIE90aGVyd2lzZSB0aGlzIGNhbiBsZWFkIHRvIGNhY2hlIHBvaXNvbmluZy5cbiAgICogVE9ETzogQ29uc2lkZXIgbm90IHVzaW5nIGN1c3RvbSByZXF1ZXN0IGhlYWRlcnMgYXQgYWxsLCBhbmQgaW5zdGVhZCBlbmNvZGVcbiAgICogZXZlcnl0aGluZyBpbnRvIHRoZSBzZWFyY2ggcGFyYW0uXG4gICAqL1xuICBjYWNoZUJ1c3RpbmdTZWFyY2hQYXJhbT86IHN0cmluZ1xuXG4gIC8qKlxuICAgKiBUcnVlIHdoZW4gdGhlIHJlcXVlc3QgaXMgZm9yIHRoZSBgL19uZXh0L2RhdGFgIHJvdXRlIHVzaW5nIHRoZSBwYWdlc1xuICAgKiByb3V0ZXIuXG4gICAqL1xuICBpc05leHREYXRhUmVxPzogdHJ1ZVxuXG4gIC8qKlxuICAgKiBQb3N0cG9uZWQgc3RhdGUgdG8gdXNlIGZvciByZXN1bXB0aW9uLiBJZiBwcmVzZW50IGl0J3MgYXNzdW1lZCB0aGF0IHRoZVxuICAgKiByZXF1ZXN0IGlzIGZvciBhIHBhZ2UgdGhhdCBoYXMgcG9zdHBvbmVkICh0aGVyZSBhcmUgbm8gZ3VhcmFudGVlcyB0aGF0IHRoZVxuICAgKiBwYWdlIGFjdHVhbGx5IGhhcyBwb3N0cG9uZWQgdGhvdWdoIGFzIGl0IHdvdWxkIGluY3VyIGFuIGFkZGl0aW9uYWwgY2FjaGVcbiAgICogbG9va3VwKS5cbiAgICovXG4gIHBvc3Rwb25lZD86IHN0cmluZ1xuXG4gIC8qKlxuICAgKiBJZiBwcm92aWRlZCwgdGhpcyB3aWxsIGJlIGNhbGxlZCB3aGVuIGEgcmVzcG9uc2UgY2FjaGUgZW50cnkgd2FzIGdlbmVyYXRlZFxuICAgKiBvciBsb29rZWQgdXAgaW4gdGhlIGNhY2hlLlxuICAgKi9cbiAgb25DYWNoZUVudHJ5PzogKFxuICAgIGNhY2hlRW50cnk6IGFueSxcbiAgICByZXF1ZXN0TWV0YTogYW55XG4gICkgPT4gUHJvbWlzZTxib29sZWFuIHwgdm9pZD4gfCBib29sZWFuIHwgdm9pZFxuXG4gIC8qKlxuICAgKiBUaGUgcHJldmlvdXMgcmV2YWxpZGF0ZSBiZWZvcmUgcmVuZGVyaW5nIDQwNCBwYWdlIGZvciBub3RGb3VuZDogdHJ1ZVxuICAgKi9cbiAgbm90Rm91bmRSZXZhbGlkYXRlPzogbnVtYmVyIHwgZmFsc2VcblxuICAvKipcbiAgICogSW4gZGV2ZWxvcG1lbnQsIHRoZSBvcmlnaW5hbCBzb3VyY2UgcGFnZSB0aGF0IHJldHVybmVkIGEgNDA0LlxuICAgKi9cbiAgZGV2ZWxvcG1lbnROb3RGb3VuZFNvdXJjZVBhZ2U/OiBzdHJpbmdcblxuICAvKipcbiAgICogVGhlIHBhdGggd2Ugcm91dGVkIHRvIGFuZCBzaG91bGQgYmUgaW52b2tlZFxuICAgKi9cbiAgaW52b2tlUGF0aD86IHN0cmluZ1xuXG4gIC8qKlxuICAgKiBUaGUgc3BlY2lmaWMgcGFnZSBvdXRwdXQgd2Ugc2hvdWxkIGJlIG1hdGNoaW5nXG4gICAqL1xuICBpbnZva2VPdXRwdXQ/OiBzdHJpbmdcblxuICAvKipcbiAgICogVGhlIHN0YXR1cyB3ZSBhcmUgaW52b2tpbmcgdGhlIHJlcXVlc3Qgd2l0aCBmcm9tIHJvdXRpbmdcbiAgICovXG4gIGludm9rZVN0YXR1cz86IG51bWJlclxuXG4gIC8qKlxuICAgKiBUaGUgcm91dGluZyBlcnJvciB3ZSBhcmUgaW52b2tpbmcgd2l0aFxuICAgKi9cbiAgaW52b2tlRXJyb3I/OiBFcnJvclxuXG4gIC8qKlxuICAgKiBUaGUgcXVlcnkgcGFyc2VkIGZvciB0aGUgaW52b2NhdGlvblxuICAgKi9cbiAgaW52b2tlUXVlcnk/OiBSZWNvcmQ8c3RyaW5nLCB1bmRlZmluZWQgfCBzdHJpbmcgfCBzdHJpbmdbXT5cblxuICAvKipcbiAgICogV2hldGhlciB0aGUgcmVxdWVzdCBpcyBhIG1pZGRsZXdhcmUgaW52b2NhdGlvblxuICAgKi9cbiAgbWlkZGxld2FyZUludm9rZT86IGJvb2xlYW5cblxuICAvKipcbiAgICogV2hldGhlciB0aGUgcmVxdWVzdCBzaG91bGQgcmVuZGVyIHRoZSBmYWxsYmFjayBzaGVsbCBvciBub3QuXG4gICAqL1xuICByZW5kZXJGYWxsYmFja1NoZWxsPzogYm9vbGVhblxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSByZXF1ZXN0IGlzIGZvciB0aGUgY3VzdG9tIGVycm9yIHBhZ2UuXG4gICAqL1xuICBjdXN0b21FcnJvclJlbmRlcj86IHRydWVcblxuICAvKipcbiAgICogV2hldGhlciB0byBidWJibGUgdXAgdGhlIE5vRmFsbGJhY2tFcnJvciB0byB0aGUgY2FsbGVyIHdoZW4gYSA0MDQgaXNcbiAgICogcmV0dXJuZWQuXG4gICAqL1xuICBidWJibGVOb0ZhbGxiYWNrPzogdHJ1ZVxuXG4gIC8qKlxuICAgKiBUcnVlIHdoZW4gdGhlIHJlcXVlc3QgaGFkIGxvY2FsZSBpbmZvcm1hdGlvbiBpbmZlcnJlZCBmcm9tIHRoZSBkZWZhdWx0XG4gICAqIGxvY2FsZS5cbiAgICovXG4gIGxvY2FsZUluZmVycmVkRnJvbURlZmF1bHQ/OiB0cnVlXG5cbiAgLyoqXG4gICAqIFRoZSBsb2NhbGUgdGhhdCB3YXMgaW5mZXJyZWQgb3IgZXhwbGljaXRseSBzZXQgZm9yIHRoZSByZXF1ZXN0LlxuICAgKi9cbiAgbG9jYWxlPzogc3RyaW5nXG5cbiAgLyoqXG4gICAqIFRoZSBkZWZhdWx0IGxvY2FsZSB0aGF0IHdhcyBpbmZlcnJlZCBvciBleHBsaWNpdGx5IHNldCBmb3IgdGhlIHJlcXVlc3QuXG4gICAqL1xuICBkZWZhdWx0TG9jYWxlPzogc3RyaW5nXG5cbiAgLyoqXG4gICAqIFRoZSBwcm9qZWN0IGRpciB0aGUgc2VydmVyIGlzIHJ1bm5pbmcgaW5cbiAgICovXG4gIHByb2plY3REaXI/OiBzdHJpbmdcblxuICAvKipcbiAgICogVGhlIGRpc3QgZGlyZWN0b3J5IHRoZSBzZXJ2ZXIgaXMgY3VycmVudGx5IHVzaW5nXG4gICAqL1xuICBkaXN0RGlyPzogc3RyaW5nXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgd2UgYXJlIGdlbmVyYXRpbmcgdGhlIGZhbGxiYWNrIHZlcnNpb24gb2YgdGhlIHBhZ2UgaW4gZGV2IG1vZGVcbiAgICovXG4gIGlzSXNyRmFsbGJhY2s/OiBib29sZWFuXG5cbiAgLyoqXG4gICAqIFRoZSBxdWVyeSBhZnRlciByZXNvbHZpbmcgcm91dGVzXG4gICAqL1xuICBxdWVyeT86IFBhcnNlZFVybFF1ZXJ5XG5cbiAgLyoqXG4gICAqIFRoZSBwYXJhbXMgYWZ0ZXIgcmVzb2x2aW5nIHJvdXRlc1xuICAgKi9cbiAgcGFyYW1zPzogUGFyc2VkVXJsUXVlcnlcblxuICAvKipcbiAgICogVGhlIEFNUCB2YWxpZGF0b3IgdG8gdXNlIGluIGRldmVsb3BtZW50XG4gICAqL1xuICBhbXBWYWxpZGF0b3I/OiAoaHRtbDogc3RyaW5nLCBwYXRobmFtZTogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+XG5cbiAgLyoqXG4gICAqIEVycm9yT3ZlcmxheSBjb21wb25lbnQgdG8gdXNlIGluIGRldmVsb3BtZW50IGZvciBwYWdlcyByb3V0ZXJcbiAgICovXG4gIFBhZ2VzRXJyb3JEZWJ1Zz86IFBhZ2VzRGV2T3ZlcmxheUJyaWRnZVR5cGVcblxuICAvKipcbiAgICogV2hldGhlciBzZXJ2ZXIgaXMgaW4gbWluaW1hbCBtb2RlICh0aGlzIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBtb3JlXG4gICAqIHNwZWNpZmljIGZsYWdzIGluIGZ1dHVyZSlcbiAgICovXG4gIG1pbmltYWxNb2RlPzogYm9vbGVhblxufVxuXG4vKipcbiAqIEdldHMgdGhlIHJlcXVlc3QgbWV0YWRhdGEuIElmIG5vIGtleSBpcyBwcm92aWRlZCwgdGhlIGVudGlyZSBtZXRhZGF0YSBvYmplY3RcbiAqIGlzIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSByZXEgdGhlIHJlcXVlc3QgdG8gZ2V0IHRoZSBtZXRhZGF0YSBmcm9tXG4gKiBAcGFyYW0ga2V5IHRoZSBrZXkgdG8gZ2V0IGZyb20gdGhlIG1ldGFkYXRhIChvcHRpb25hbClcbiAqIEByZXR1cm5zIHRoZSB2YWx1ZSBmb3IgdGhlIGtleSBvciB0aGUgZW50aXJlIG1ldGFkYXRhIG9iamVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmVxdWVzdE1ldGEoXG4gIHJlcTogTmV4dEluY29taW5nTWVzc2FnZSxcbiAga2V5PzogdW5kZWZpbmVkXG4pOiBSZXF1ZXN0TWV0YVxuZXhwb3J0IGZ1bmN0aW9uIGdldFJlcXVlc3RNZXRhPEsgZXh0ZW5kcyBrZXlvZiBSZXF1ZXN0TWV0YT4oXG4gIHJlcTogTmV4dEluY29taW5nTWVzc2FnZSxcbiAga2V5OiBLXG4pOiBSZXF1ZXN0TWV0YVtLXVxuZXhwb3J0IGZ1bmN0aW9uIGdldFJlcXVlc3RNZXRhPEsgZXh0ZW5kcyBrZXlvZiBSZXF1ZXN0TWV0YT4oXG4gIHJlcTogTmV4dEluY29taW5nTWVzc2FnZSxcbiAga2V5PzogS1xuKTogUmVxdWVzdE1ldGEgfCBSZXF1ZXN0TWV0YVtLXSB7XG4gIGNvbnN0IG1ldGEgPSByZXFbTkVYVF9SRVFVRVNUX01FVEFdIHx8IHt9XG4gIHJldHVybiB0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyA/IG1ldGFba2V5XSA6IG1ldGFcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSByZXF1ZXN0IG1ldGFkYXRhLlxuICpcbiAqIEBwYXJhbSByZXEgdGhlIHJlcXVlc3QgdG8gc2V0IHRoZSBtZXRhZGF0YSBvblxuICogQHBhcmFtIG1ldGEgdGhlIG1ldGFkYXRhIHRvIHNldFxuICogQHJldHVybnMgdGhlIG11dGF0ZWQgcmVxdWVzdCBtZXRhZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0UmVxdWVzdE1ldGEocmVxOiBOZXh0SW5jb21pbmdNZXNzYWdlLCBtZXRhOiBSZXF1ZXN0TWV0YSkge1xuICByZXFbTkVYVF9SRVFVRVNUX01FVEFdID0gbWV0YVxuICByZXR1cm4gbWV0YVxufVxuXG4vKipcbiAqIEFkZHMgYSB2YWx1ZSB0byB0aGUgcmVxdWVzdCBtZXRhZGF0YS5cbiAqXG4gKiBAcGFyYW0gcmVxdWVzdCB0aGUgcmVxdWVzdCB0byBtdXRhdGVcbiAqIEBwYXJhbSBrZXkgdGhlIGtleSB0byBzZXRcbiAqIEBwYXJhbSB2YWx1ZSB0aGUgdmFsdWUgdG8gc2V0XG4gKiBAcmV0dXJucyB0aGUgbXV0YXRlZCByZXF1ZXN0IG1ldGFkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRSZXF1ZXN0TWV0YTxLIGV4dGVuZHMga2V5b2YgUmVxdWVzdE1ldGE+KFxuICByZXF1ZXN0OiBOZXh0SW5jb21pbmdNZXNzYWdlLFxuICBrZXk6IEssXG4gIHZhbHVlOiBSZXF1ZXN0TWV0YVtLXVxuKSB7XG4gIGNvbnN0IG1ldGEgPSBnZXRSZXF1ZXN0TWV0YShyZXF1ZXN0KVxuICBtZXRhW2tleV0gPSB2YWx1ZVxuICByZXR1cm4gc2V0UmVxdWVzdE1ldGEocmVxdWVzdCwgbWV0YSlcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGEga2V5IGZyb20gdGhlIHJlcXVlc3QgbWV0YWRhdGEuXG4gKlxuICogQHBhcmFtIHJlcXVlc3QgdGhlIHJlcXVlc3QgdG8gbXV0YXRlXG4gKiBAcGFyYW0ga2V5IHRoZSBrZXkgdG8gcmVtb3ZlXG4gKiBAcmV0dXJucyB0aGUgbXV0YXRlZCByZXF1ZXN0IG1ldGFkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVSZXF1ZXN0TWV0YTxLIGV4dGVuZHMga2V5b2YgUmVxdWVzdE1ldGE+KFxuICByZXF1ZXN0OiBOZXh0SW5jb21pbmdNZXNzYWdlLFxuICBrZXk6IEtcbikge1xuICBjb25zdCBtZXRhID0gZ2V0UmVxdWVzdE1ldGEocmVxdWVzdClcbiAgZGVsZXRlIG1ldGFba2V5XVxuICByZXR1cm4gc2V0UmVxdWVzdE1ldGEocmVxdWVzdCwgbWV0YSlcbn1cblxudHlwZSBOZXh0UXVlcnlNZXRhZGF0YSA9IHtcbiAgLyoqXG4gICAqIFRoZSBgX3JzY2AgcXVlcnkgcGFyYW1ldGVyIHVzZWQgZm9yIGNhY2hlIGJ1c3RpbmcgdG8gZW5zdXJlIHRoYXQgdGhlIFJTQ1xuICAgKiByZXF1ZXN0cyBkbyBub3QgZ2V0IGNhY2hlZCBieSB0aGUgYnJvd3NlciBleHBsaWNpdGx5LlxuICAgKi9cbiAgW05FWFRfUlNDX1VOSU9OX1FVRVJZXT86IHN0cmluZ1xufVxuXG5leHBvcnQgdHlwZSBOZXh0UGFyc2VkVXJsUXVlcnkgPSBQYXJzZWRVcmxRdWVyeSAmXG4gIE5leHRRdWVyeU1ldGFkYXRhICYge1xuICAgIGFtcD86ICcxJ1xuICB9XG5cbmV4cG9ydCBpbnRlcmZhY2UgTmV4dFVybFdpdGhQYXJzZWRRdWVyeSBleHRlbmRzIFVybFdpdGhQYXJzZWRRdWVyeSB7XG4gIHF1ZXJ5OiBOZXh0UGFyc2VkVXJsUXVlcnlcbn1cbiJdLCJuYW1lcyI6WyJORVhUX1JFUVVFU1RfTUVUQSIsIlN5bWJvbCIsImZvciIsImdldFJlcXVlc3RNZXRhIiwicmVxIiwia2V5IiwibWV0YSIsInNldFJlcXVlc3RNZXRhIiwiYWRkUmVxdWVzdE1ldGEiLCJyZXF1ZXN0IiwidmFsdWUiLCJyZW1vdmVSZXF1ZXN0TWV0YSJdLCJtYXBwaW5ncyI6IkFBQUEsK0JBQStCLEdBVy9CLGtHQUFrRzs7Ozs7Ozs7QUFDM0YsTUFBTUEsb0JBQW9CQyxPQUFPQyxHQUFHLENBQUMsMkJBQTBCO0FBb1AvRCxTQUFTQyxlQUNkQyxHQUF3QixFQUN4QkMsR0FBTztJQUVQLE1BQU1DLE9BQU9GLEdBQUcsQ0FBQ0osa0JBQWtCLElBQUksQ0FBQztJQUN4QyxPQUFPLE9BQU9LLFFBQVEsV0FBV0MsSUFBSSxDQUFDRCxJQUFJLEdBQUdDO0FBQy9DO0FBU08sU0FBU0MsZUFBZUgsR0FBd0IsRUFBRUUsSUFBaUI7SUFDeEVGLEdBQUcsQ0FBQ0osa0JBQWtCLEdBQUdNO0lBQ3pCLE9BQU9BO0FBQ1Q7QUFVTyxTQUFTRSxlQUNkQyxPQUE0QixFQUM1QkosR0FBTSxFQUNOSyxLQUFxQjtJQUVyQixNQUFNSixPQUFPSCxlQUFlTTtJQUM1QkgsSUFBSSxDQUFDRCxJQUFJLEdBQUdLO0lBQ1osT0FBT0gsZUFBZUUsU0FBU0g7QUFDakM7QUFTTyxTQUFTSyxrQkFDZEYsT0FBNEIsRUFDNUJKLEdBQU07SUFFTixNQUFNQyxPQUFPSCxlQUFlTTtJQUM1QixPQUFPSCxJQUFJLENBQUNELElBQUk7SUFDaEIsT0FBT0UsZUFBZUUsU0FBU0g7QUFDakMiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTAzNzEsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NyYy9saWIvY29uc3RhbnRzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgU2VydmVyUnVudGltZSB9IGZyb20gJy4uL3R5cGVzJ1xuXG5leHBvcnQgY29uc3QgTkVYVF9RVUVSWV9QQVJBTV9QUkVGSVggPSAnbnh0UCdcbmV4cG9ydCBjb25zdCBORVhUX0lOVEVSQ0VQVElPTl9NQVJLRVJfUFJFRklYID0gJ254dEknXG5cbmV4cG9ydCBjb25zdCBNQVRDSEVEX1BBVEhfSEVBREVSID0gJ3gtbWF0Y2hlZC1wYXRoJ1xuZXhwb3J0IGNvbnN0IFBSRVJFTkRFUl9SRVZBTElEQVRFX0hFQURFUiA9ICd4LXByZXJlbmRlci1yZXZhbGlkYXRlJ1xuZXhwb3J0IGNvbnN0IFBSRVJFTkRFUl9SRVZBTElEQVRFX09OTFlfR0VORVJBVEVEX0hFQURFUiA9XG4gICd4LXByZXJlbmRlci1yZXZhbGlkYXRlLWlmLWdlbmVyYXRlZCdcblxuZXhwb3J0IGNvbnN0IFJTQ19QUkVGRVRDSF9TVUZGSVggPSAnLnByZWZldGNoLnJzYydcbmV4cG9ydCBjb25zdCBSU0NfU0VHTUVOVFNfRElSX1NVRkZJWCA9ICcuc2VnbWVudHMnXG5leHBvcnQgY29uc3QgUlNDX1NFR01FTlRfU1VGRklYID0gJy5zZWdtZW50LnJzYydcbmV4cG9ydCBjb25zdCBSU0NfU1VGRklYID0gJy5yc2MnXG5leHBvcnQgY29uc3QgQUNUSU9OX1NVRkZJWCA9ICcuYWN0aW9uJ1xuZXhwb3J0IGNvbnN0IE5FWFRfREFUQV9TVUZGSVggPSAnLmpzb24nXG5leHBvcnQgY29uc3QgTkVYVF9NRVRBX1NVRkZJWCA9ICcubWV0YSdcbmV4cG9ydCBjb25zdCBORVhUX0JPRFlfU1VGRklYID0gJy5ib2R5J1xuXG5leHBvcnQgY29uc3QgTkVYVF9DQUNIRV9UQUdTX0hFQURFUiA9ICd4LW5leHQtY2FjaGUtdGFncydcbmV4cG9ydCBjb25zdCBORVhUX0NBQ0hFX1JFVkFMSURBVEVEX1RBR1NfSEVBREVSID0gJ3gtbmV4dC1yZXZhbGlkYXRlZC10YWdzJ1xuZXhwb3J0IGNvbnN0IE5FWFRfQ0FDSEVfUkVWQUxJREFURV9UQUdfVE9LRU5fSEVBREVSID1cbiAgJ3gtbmV4dC1yZXZhbGlkYXRlLXRhZy10b2tlbidcblxuZXhwb3J0IGNvbnN0IE5FWFRfUkVTVU1FX0hFQURFUiA9ICduZXh0LXJlc3VtZSdcblxuLy8gaWYgdGhlc2UgY2hhbmdlIG1ha2Ugc3VyZSB3ZSB1cGRhdGUgdGhlIHJlbGF0ZWRcbi8vIGRvY3VtZW50YXRpb24gYXMgd2VsbFxuZXhwb3J0IGNvbnN0IE5FWFRfQ0FDSEVfVEFHX01BWF9JVEVNUyA9IDEyOFxuZXhwb3J0IGNvbnN0IE5FWFRfQ0FDSEVfVEFHX01BWF9MRU5HVEggPSAyNTZcbmV4cG9ydCBjb25zdCBORVhUX0NBQ0hFX1NPRlRfVEFHX01BWF9MRU5HVEggPSAxMDI0XG5leHBvcnQgY29uc3QgTkVYVF9DQUNIRV9JTVBMSUNJVF9UQUdfSUQgPSAnX05fVF8nXG5cbi8vIGluIHNlY29uZHNcbmV4cG9ydCBjb25zdCBDQUNIRV9PTkVfWUVBUiA9IDMxNTM2MDAwXG5cbi8vIGluIHNlY29uZHMsIHJlcHJlc2VudHMgcmV2YWxpZGF0ZT1mYWxzZS4gSS5lLiBuZXZlciByZXZhbGlhdGUuXG4vLyBXZSB1c2UgdGhpcyB2YWx1ZSBzaW5jZSBpdCBjYW4gYmUgcmVwcmVzZW50ZWQgYXMgYSBWOCBTTUkgZm9yIG9wdGltYWwgcGVyZm9ybWFuY2UuXG4vLyBJdCBjYW4gYWxzbyBiZSBzZXJpYWxpemVkIGFzIEpTT04gaWYgaXQgZXZlciBsZWFrcyBhY2NpZGVudGFsbHkgYXMgYW4gYWN0dWFsIHZhbHVlLlxuZXhwb3J0IGNvbnN0IElORklOSVRFX0NBQ0hFID0gMHhmZmZmZmZmZVxuXG4vLyBQYXR0ZXJucyB0byBkZXRlY3QgbWlkZGxld2FyZSBmaWxlc1xuZXhwb3J0IGNvbnN0IE1JRERMRVdBUkVfRklMRU5BTUUgPSAnbWlkZGxld2FyZSdcbmV4cG9ydCBjb25zdCBNSURETEVXQVJFX0xPQ0FUSU9OX1JFR0VYUCA9IGAoPzpzcmMvKT8ke01JRERMRVdBUkVfRklMRU5BTUV9YFxuXG4vLyBQYXR0ZXJuIHRvIGRldGVjdCBpbnN0cnVtZW50YXRpb24gaG9va3MgZmlsZVxuZXhwb3J0IGNvbnN0IElOU1RSVU1FTlRBVElPTl9IT09LX0ZJTEVOQU1FID0gJ2luc3RydW1lbnRhdGlvbidcblxuLy8gQmVjYXVzZSBvbiBXaW5kb3dzIGFic29sdXRlIHBhdGhzIGluIHRoZSBnZW5lcmF0ZWQgY29kZSBjYW4gYnJlYWsgYmVjYXVzZSBvZiBudW1iZXJzLCBlZyAxIGluIHRoZSBwYXRoLFxuLy8gd2UgaGF2ZSB0byB1c2UgYSBwcml2YXRlIGFsaWFzXG5leHBvcnQgY29uc3QgUEFHRVNfRElSX0FMSUFTID0gJ3ByaXZhdGUtbmV4dC1wYWdlcydcbmV4cG9ydCBjb25zdCBET1RfTkVYVF9BTElBUyA9ICdwcml2YXRlLWRvdC1uZXh0J1xuZXhwb3J0IGNvbnN0IFJPT1RfRElSX0FMSUFTID0gJ3ByaXZhdGUtbmV4dC1yb290LWRpcidcbmV4cG9ydCBjb25zdCBBUFBfRElSX0FMSUFTID0gJ3ByaXZhdGUtbmV4dC1hcHAtZGlyJ1xuZXhwb3J0IGNvbnN0IFJTQ19NT0RfUkVGX1BST1hZX0FMSUFTID0gJ3ByaXZhdGUtbmV4dC1yc2MtbW9kLXJlZi1wcm94eSdcbmV4cG9ydCBjb25zdCBSU0NfQUNUSU9OX1ZBTElEQVRFX0FMSUFTID0gJ3ByaXZhdGUtbmV4dC1yc2MtYWN0aW9uLXZhbGlkYXRlJ1xuZXhwb3J0IGNvbnN0IFJTQ19BQ1RJT05fUFJPWFlfQUxJQVMgPSAncHJpdmF0ZS1uZXh0LXJzYy1zZXJ2ZXItcmVmZXJlbmNlJ1xuZXhwb3J0IGNvbnN0IFJTQ19DQUNIRV9XUkFQUEVSX0FMSUFTID0gJ3ByaXZhdGUtbmV4dC1yc2MtY2FjaGUtd3JhcHBlcidcbmV4cG9ydCBjb25zdCBSU0NfRFlOQU1JQ19JTVBPUlRfV1JBUFBFUl9BTElBUyA9XG4gICdwcml2YXRlLW5leHQtcnNjLXRyYWNrLWR5bmFtaWMtaW1wb3J0J1xuZXhwb3J0IGNvbnN0IFJTQ19BQ1RJT05fRU5DUllQVElPTl9BTElBUyA9ICdwcml2YXRlLW5leHQtcnNjLWFjdGlvbi1lbmNyeXB0aW9uJ1xuZXhwb3J0IGNvbnN0IFJTQ19BQ1RJT05fQ0xJRU5UX1dSQVBQRVJfQUxJQVMgPVxuICAncHJpdmF0ZS1uZXh0LXJzYy1hY3Rpb24tY2xpZW50LXdyYXBwZXInXG5cbmV4cG9ydCBjb25zdCBQVUJMSUNfRElSX01JRERMRVdBUkVfQ09ORkxJQ1QgPSBgWW91IGNhbiBub3QgaGF2ZSBhICdfbmV4dCcgZm9sZGVyIGluc2lkZSBvZiB5b3VyIHB1YmxpYyBmb2xkZXIuIFRoaXMgY29uZmxpY3RzIHdpdGggdGhlIGludGVybmFsICcvX25leHQnIHJvdXRlLiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9wdWJsaWMtbmV4dC1mb2xkZXItY29uZmxpY3RgXG5cbmV4cG9ydCBjb25zdCBTU0dfR0VUX0lOSVRJQUxfUFJPUFNfQ09ORkxJQ1QgPSBgWW91IGNhbiBub3QgdXNlIGdldEluaXRpYWxQcm9wcyB3aXRoIGdldFN0YXRpY1Byb3BzLiBUbyB1c2UgU1NHLCBwbGVhc2UgcmVtb3ZlIHlvdXIgZ2V0SW5pdGlhbFByb3BzYFxuXG5leHBvcnQgY29uc3QgU0VSVkVSX1BST1BTX0dFVF9JTklUX1BST1BTX0NPTkZMSUNUID0gYFlvdSBjYW4gbm90IHVzZSBnZXRJbml0aWFsUHJvcHMgd2l0aCBnZXRTZXJ2ZXJTaWRlUHJvcHMuIFBsZWFzZSByZW1vdmUgZ2V0SW5pdGlhbFByb3BzLmBcblxuZXhwb3J0IGNvbnN0IFNFUlZFUl9QUk9QU19TU0dfQ09ORkxJQ1QgPSBgWW91IGNhbiBub3QgdXNlIGdldFN0YXRpY1Byb3BzIG9yIGdldFN0YXRpY1BhdGhzIHdpdGggZ2V0U2VydmVyU2lkZVByb3BzLiBUbyB1c2UgU1NHLCBwbGVhc2UgcmVtb3ZlIGdldFNlcnZlclNpZGVQcm9wc2BcblxuZXhwb3J0IGNvbnN0IFNUQVRJQ19TVEFUVVNfUEFHRV9HRVRfSU5JVElBTF9QUk9QU19FUlJPUiA9IGBjYW4gbm90IGhhdmUgZ2V0SW5pdGlhbFByb3BzL2dldFNlcnZlclNpZGVQcm9wcywgaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvNDA0LWdldC1pbml0aWFsLXByb3BzYFxuXG5leHBvcnQgY29uc3QgU0VSVkVSX1BST1BTX0VYUE9SVF9FUlJPUiA9IGBwYWdlcyB3aXRoIFxcYGdldFNlcnZlclNpZGVQcm9wc1xcYCBjYW4gbm90IGJlIGV4cG9ydGVkLiBTZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2dzc3AtZXhwb3J0YFxuXG5leHBvcnQgY29uc3QgR1NQX05PX1JFVFVSTkVEX1ZBTFVFID1cbiAgJ1lvdXIgYGdldFN0YXRpY1Byb3BzYCBmdW5jdGlvbiBkaWQgbm90IHJldHVybiBhbiBvYmplY3QuIERpZCB5b3UgZm9yZ2V0IHRvIGFkZCBhIGByZXR1cm5gPydcbmV4cG9ydCBjb25zdCBHU1NQX05PX1JFVFVSTkVEX1ZBTFVFID1cbiAgJ1lvdXIgYGdldFNlcnZlclNpZGVQcm9wc2AgZnVuY3Rpb24gZGlkIG5vdCByZXR1cm4gYW4gb2JqZWN0LiBEaWQgeW91IGZvcmdldCB0byBhZGQgYSBgcmV0dXJuYD8nXG5cbmV4cG9ydCBjb25zdCBVTlNUQUJMRV9SRVZBTElEQVRFX1JFTkFNRV9FUlJPUiA9XG4gICdUaGUgYHVuc3RhYmxlX3JldmFsaWRhdGVgIHByb3BlcnR5IGlzIGF2YWlsYWJsZSBmb3IgZ2VuZXJhbCB1c2UuXFxuJyArXG4gICdQbGVhc2UgdXNlIGByZXZhbGlkYXRlYCBpbnN0ZWFkLidcblxuZXhwb3J0IGNvbnN0IEdTU1BfQ09NUE9ORU5UX01FTUJFUl9FUlJPUiA9IGBjYW4gbm90IGJlIGF0dGFjaGVkIHRvIGEgcGFnZSdzIGNvbXBvbmVudCBhbmQgbXVzdCBiZSBleHBvcnRlZCBmcm9tIHRoZSBwYWdlLiBTZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2dzc3AtY29tcG9uZW50LW1lbWJlcmBcblxuZXhwb3J0IGNvbnN0IE5PTl9TVEFOREFSRF9OT0RFX0VOViA9IGBZb3UgYXJlIHVzaW5nIGEgbm9uLXN0YW5kYXJkIFwiTk9ERV9FTlZcIiB2YWx1ZSBpbiB5b3VyIGVudmlyb25tZW50LiBUaGlzIGNyZWF0ZXMgaW5jb25zaXN0ZW5jaWVzIGluIHRoZSBwcm9qZWN0IGFuZCBpcyBzdHJvbmdseSBhZHZpc2VkIGFnYWluc3QuIFJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbm9uLXN0YW5kYXJkLW5vZGUtZW52YFxuXG5leHBvcnQgY29uc3QgU1NHX0ZBTExCQUNLX0VYUE9SVF9FUlJPUiA9IGBQYWdlcyB3aXRoIFxcYGZhbGxiYWNrXFxgIGVuYWJsZWQgaW4gXFxgZ2V0U3RhdGljUGF0aHNcXGAgY2FuIG5vdCBiZSBleHBvcnRlZC4gU2VlIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9zc2ctZmFsbGJhY2stdHJ1ZS1leHBvcnRgXG5cbmV4cG9ydCBjb25zdCBFU0xJTlRfREVGQVVMVF9ESVJTID0gWydhcHAnLCAncGFnZXMnLCAnY29tcG9uZW50cycsICdsaWInLCAnc3JjJ11cblxuZXhwb3J0IGNvbnN0IFNFUlZFUl9SVU5USU1FOiBSZWNvcmQ8c3RyaW5nLCBTZXJ2ZXJSdW50aW1lPiA9IHtcbiAgZWRnZTogJ2VkZ2UnLFxuICBleHBlcmltZW50YWxFZGdlOiAnZXhwZXJpbWVudGFsLWVkZ2UnLFxuICBub2RlanM6ICdub2RlanMnLFxufVxuXG4vKipcbiAqIFRoZSBuYW1lcyBvZiB0aGUgd2VicGFjayBsYXllcnMuIFRoZXNlIGxheWVycyBhcmUgdGhlIHByaW1pdGl2ZXMgZm9yIHRoZVxuICogd2VicGFjayBjaHVua3MuXG4gKi9cbmNvbnN0IFdFQlBBQ0tfTEFZRVJTX05BTUVTID0ge1xuICAvKipcbiAgICogVGhlIGxheWVyIGZvciB0aGUgc2hhcmVkIGNvZGUgYmV0d2VlbiB0aGUgY2xpZW50IGFuZCBzZXJ2ZXIgYnVuZGxlcy5cbiAgICovXG4gIHNoYXJlZDogJ3NoYXJlZCcsXG4gIC8qKlxuICAgKiBUaGUgbGF5ZXIgZm9yIHNlcnZlci1vbmx5IHJ1bnRpbWUgYW5kIHBpY2tpbmcgdXAgYHJlYWN0LXNlcnZlcmAgZXhwb3J0IGNvbmRpdGlvbnMuXG4gICAqIEluY2x1ZGluZyBhcHAgcm91dGVyIFJTQyBwYWdlcyBhbmQgYXBwIHJvdXRlciBjdXN0b20gcm91dGVzIGFuZCBtZXRhZGF0YSByb3V0ZXMuXG4gICAqL1xuICByZWFjdFNlcnZlckNvbXBvbmVudHM6ICdyc2MnLFxuICAvKipcbiAgICogU2VydmVyIFNpZGUgUmVuZGVyaW5nIGxheWVyIGZvciBhcHAgKHNzcikuXG4gICAqL1xuICBzZXJ2ZXJTaWRlUmVuZGVyaW5nOiAnc3NyJyxcbiAgLyoqXG4gICAqIFRoZSBicm93c2VyIGNsaWVudCBidW5kbGUgbGF5ZXIgZm9yIGFjdGlvbnMuXG4gICAqL1xuICBhY3Rpb25Ccm93c2VyOiAnYWN0aW9uLWJyb3dzZXInLFxuICAvKipcbiAgICogVGhlIE5vZGUuanMgYnVuZGxlIGxheWVyIGZvciB0aGUgQVBJIHJvdXRlcy5cbiAgICovXG4gIGFwaU5vZGU6ICdhcGktbm9kZScsXG4gIC8qKlxuICAgKiBUaGUgRWRnZSBMaXRlIGJ1bmRsZSBsYXllciBmb3IgdGhlIEFQSSByb3V0ZXMuXG4gICAqL1xuICBhcGlFZGdlOiAnYXBpLWVkZ2UnLFxuICAvKipcbiAgICogVGhlIGxheWVyIGZvciB0aGUgbWlkZGxld2FyZSBjb2RlLlxuICAgKi9cbiAgbWlkZGxld2FyZTogJ21pZGRsZXdhcmUnLFxuICAvKipcbiAgICogVGhlIGxheWVyIGZvciB0aGUgaW5zdHJ1bWVudGF0aW9uIGhvb2tzLlxuICAgKi9cbiAgaW5zdHJ1bWVudDogJ2luc3RydW1lbnQnLFxuICAvKipcbiAgICogVGhlIGxheWVyIGZvciBhc3NldHMgb24gdGhlIGVkZ2UuXG4gICAqL1xuICBlZGdlQXNzZXQ6ICdlZGdlLWFzc2V0JyxcbiAgLyoqXG4gICAqIFRoZSBicm93c2VyIGNsaWVudCBidW5kbGUgbGF5ZXIgZm9yIEFwcCBkaXJlY3RvcnkuXG4gICAqL1xuICBhcHBQYWdlc0Jyb3dzZXI6ICdhcHAtcGFnZXMtYnJvd3NlcicsXG4gIC8qKlxuICAgKiBUaGUgYnJvd3NlciBjbGllbnQgYnVuZGxlIGxheWVyIGZvciBQYWdlcyBkaXJlY3RvcnkuXG4gICAqL1xuICBwYWdlc0RpckJyb3dzZXI6ICdwYWdlcy1kaXItYnJvd3NlcicsXG4gIC8qKlxuICAgKiBUaGUgRWRnZSBMaXRlIGJ1bmRsZSBsYXllciBmb3IgUGFnZXMgZGlyZWN0b3J5LlxuICAgKi9cbiAgcGFnZXNEaXJFZGdlOiAncGFnZXMtZGlyLWVkZ2UnLFxuICAvKipcbiAgICogVGhlIE5vZGUuanMgYnVuZGxlIGxheWVyIGZvciBQYWdlcyBkaXJlY3RvcnkuXG4gICAqL1xuICBwYWdlc0Rpck5vZGU6ICdwYWdlcy1kaXItbm9kZScsXG59IGFzIGNvbnN0XG5cbmV4cG9ydCB0eXBlIFdlYnBhY2tMYXllck5hbWUgPVxuICAodHlwZW9mIFdFQlBBQ0tfTEFZRVJTX05BTUVTKVtrZXlvZiB0eXBlb2YgV0VCUEFDS19MQVlFUlNfTkFNRVNdXG5cbmNvbnN0IFdFQlBBQ0tfTEFZRVJTID0ge1xuICAuLi5XRUJQQUNLX0xBWUVSU19OQU1FUyxcbiAgR1JPVVA6IHtcbiAgICBidWlsdGluUmVhY3Q6IFtcbiAgICAgIFdFQlBBQ0tfTEFZRVJTX05BTUVTLnJlYWN0U2VydmVyQ29tcG9uZW50cyxcbiAgICAgIFdFQlBBQ0tfTEFZRVJTX05BTUVTLmFjdGlvbkJyb3dzZXIsXG4gICAgXSxcbiAgICBzZXJ2ZXJPbmx5OiBbXG4gICAgICBXRUJQQUNLX0xBWUVSU19OQU1FUy5yZWFjdFNlcnZlckNvbXBvbmVudHMsXG4gICAgICBXRUJQQUNLX0xBWUVSU19OQU1FUy5hY3Rpb25Ccm93c2VyLFxuICAgICAgV0VCUEFDS19MQVlFUlNfTkFNRVMuaW5zdHJ1bWVudCxcbiAgICAgIFdFQlBBQ0tfTEFZRVJTX05BTUVTLm1pZGRsZXdhcmUsXG4gICAgXSxcbiAgICBuZXV0cmFsVGFyZ2V0OiBbXG4gICAgICAvLyBwYWdlcyBhcGlcbiAgICAgIFdFQlBBQ0tfTEFZRVJTX05BTUVTLmFwaU5vZGUsXG4gICAgICBXRUJQQUNLX0xBWUVSU19OQU1FUy5hcGlFZGdlLFxuICAgIF0sXG4gICAgY2xpZW50T25seTogW1xuICAgICAgV0VCUEFDS19MQVlFUlNfTkFNRVMuc2VydmVyU2lkZVJlbmRlcmluZyxcbiAgICAgIFdFQlBBQ0tfTEFZRVJTX05BTUVTLmFwcFBhZ2VzQnJvd3NlcixcbiAgICBdLFxuICAgIGJ1bmRsZWQ6IFtcbiAgICAgIFdFQlBBQ0tfTEFZRVJTX05BTUVTLnJlYWN0U2VydmVyQ29tcG9uZW50cyxcbiAgICAgIFdFQlBBQ0tfTEFZRVJTX05BTUVTLmFjdGlvbkJyb3dzZXIsXG4gICAgICBXRUJQQUNLX0xBWUVSU19OQU1FUy5zZXJ2ZXJTaWRlUmVuZGVyaW5nLFxuICAgICAgV0VCUEFDS19MQVlFUlNfTkFNRVMuYXBwUGFnZXNCcm93c2VyLFxuICAgICAgV0VCUEFDS19MQVlFUlNfTkFNRVMuc2hhcmVkLFxuICAgICAgV0VCUEFDS19MQVlFUlNfTkFNRVMuaW5zdHJ1bWVudCxcbiAgICAgIFdFQlBBQ0tfTEFZRVJTX05BTUVTLm1pZGRsZXdhcmUsXG4gICAgXSxcbiAgICBhcHBQYWdlczogW1xuICAgICAgLy8gYXBwIHJvdXRlciBwYWdlcyBhbmQgbGF5b3V0c1xuICAgICAgV0VCUEFDS19MQVlFUlNfTkFNRVMucmVhY3RTZXJ2ZXJDb21wb25lbnRzLFxuICAgICAgV0VCUEFDS19MQVlFUlNfTkFNRVMuc2VydmVyU2lkZVJlbmRlcmluZyxcbiAgICAgIFdFQlBBQ0tfTEFZRVJTX05BTUVTLmFwcFBhZ2VzQnJvd3NlcixcbiAgICAgIFdFQlBBQ0tfTEFZRVJTX05BTUVTLmFjdGlvbkJyb3dzZXIsXG4gICAgXSxcbiAgfSxcbn1cblxuY29uc3QgV0VCUEFDS19SRVNPVVJDRV9RVUVSSUVTID0ge1xuICBlZGdlU1NSRW50cnk6ICdfX25leHRfZWRnZV9zc3JfZW50cnlfXycsXG4gIG1ldGFkYXRhOiAnX19uZXh0X21ldGFkYXRhX18nLFxuICBtZXRhZGF0YVJvdXRlOiAnX19uZXh0X21ldGFkYXRhX3JvdXRlX18nLFxuICBtZXRhZGF0YUltYWdlTWV0YTogJ19fbmV4dF9tZXRhZGF0YV9pbWFnZV9tZXRhX18nLFxufVxuXG5leHBvcnQgeyBXRUJQQUNLX0xBWUVSUywgV0VCUEFDS19SRVNPVVJDRV9RVUVSSUVTIH1cbiJdLCJuYW1lcyI6WyJORVhUX1FVRVJZX1BBUkFNX1BSRUZJWCIsIk5FWFRfSU5URVJDRVBUSU9OX01BUktFUl9QUkVGSVgiLCJNQVRDSEVEX1BBVEhfSEVBREVSIiwiUFJFUkVOREVSX1JFVkFMSURBVEVfSEVBREVSIiwiUFJFUkVOREVSX1JFVkFMSURBVEVfT05MWV9HRU5FUkFURURfSEVBREVSIiwiUlNDX1BSRUZFVENIX1NVRkZJWCIsIlJTQ19TRUdNRU5UU19ESVJfU1VGRklYIiwiUlNDX1NFR01FTlRfU1VGRklYIiwiUlNDX1NVRkZJWCIsIkFDVElPTl9TVUZGSVgiLCJORVhUX0RBVEFfU1VGRklYIiwiTkVYVF9NRVRBX1NVRkZJWCIsIk5FWFRfQk9EWV9TVUZGSVgiLCJORVhUX0NBQ0hFX1RBR1NfSEVBREVSIiwiTkVYVF9DQUNIRV9SRVZBTElEQVRFRF9UQUdTX0hFQURFUiIsIk5FWFRfQ0FDSEVfUkVWQUxJREFURV9UQUdfVE9LRU5fSEVBREVSIiwiTkVYVF9SRVNVTUVfSEVBREVSIiwiTkVYVF9DQUNIRV9UQUdfTUFYX0lURU1TIiwiTkVYVF9DQUNIRV9UQUdfTUFYX0xFTkdUSCIsIk5FWFRfQ0FDSEVfU09GVF9UQUdfTUFYX0xFTkdUSCIsIk5FWFRfQ0FDSEVfSU1QTElDSVRfVEFHX0lEIiwiQ0FDSEVfT05FX1lFQVIiLCJJTkZJTklURV9DQUNIRSIsIk1JRERMRVdBUkVfRklMRU5BTUUiLCJNSURETEVXQVJFX0xPQ0FUSU9OX1JFR0VYUCIsIklOU1RSVU1FTlRBVElPTl9IT09LX0ZJTEVOQU1FIiwiUEFHRVNfRElSX0FMSUFTIiwiRE9UX05FWFRfQUxJQVMiLCJST09UX0RJUl9BTElBUyIsIkFQUF9ESVJfQUxJQVMiLCJSU0NfTU9EX1JFRl9QUk9YWV9BTElBUyIsIlJTQ19BQ1RJT05fVkFMSURBVEVfQUxJQVMiLCJSU0NfQUNUSU9OX1BST1hZX0FMSUFTIiwiUlNDX0NBQ0hFX1dSQVBQRVJfQUxJQVMiLCJSU0NfRFlOQU1JQ19JTVBPUlRfV1JBUFBFUl9BTElBUyIsIlJTQ19BQ1RJT05fRU5DUllQVElPTl9BTElBUyIsIlJTQ19BQ1RJT05fQ0xJRU5UX1dSQVBQRVJfQUxJQVMiLCJQVUJMSUNfRElSX01JRERMRVdBUkVfQ09ORkxJQ1QiLCJTU0dfR0VUX0lOSVRJQUxfUFJPUFNfQ09ORkxJQ1QiLCJTRVJWRVJfUFJPUFNfR0VUX0lOSVRfUFJPUFNfQ09ORkxJQ1QiLCJTRVJWRVJfUFJPUFNfU1NHX0NPTkZMSUNUIiwiU1RBVElDX1NUQVRVU19QQUdFX0dFVF9JTklUSUFMX1BST1BTX0VSUk9SIiwiU0VSVkVSX1BST1BTX0VYUE9SVF9FUlJPUiIsIkdTUF9OT19SRVRVUk5FRF9WQUxVRSIsIkdTU1BfTk9fUkVUVVJORURfVkFMVUUiLCJVTlNUQUJMRV9SRVZBTElEQVRFX1JFTkFNRV9FUlJPUiIsIkdTU1BfQ09NUE9ORU5UX01FTUJFUl9FUlJPUiIsIk5PTl9TVEFOREFSRF9OT0RFX0VOViIsIlNTR19GQUxMQkFDS19FWFBPUlRfRVJST1IiLCJFU0xJTlRfREVGQVVMVF9ESVJTIiwiU0VSVkVSX1JVTlRJTUUiLCJlZGdlIiwiZXhwZXJpbWVudGFsRWRnZSIsIm5vZGVqcyIsIldFQlBBQ0tfTEFZRVJTX05BTUVTIiwic2hhcmVkIiwicmVhY3RTZXJ2ZXJDb21wb25lbnRzIiwic2VydmVyU2lkZVJlbmRlcmluZyIsImFjdGlvbkJyb3dzZXIiLCJhcGlOb2RlIiwiYXBpRWRnZSIsIm1pZGRsZXdhcmUiLCJpbnN0cnVtZW50IiwiZWRnZUFzc2V0IiwiYXBwUGFnZXNCcm93c2VyIiwicGFnZXNEaXJCcm93c2VyIiwicGFnZXNEaXJFZGdlIiwicGFnZXNEaXJOb2RlIiwiV0VCUEFDS19MQVlFUlMiLCJHUk9VUCIsImJ1aWx0aW5SZWFjdCIsInNlcnZlck9ubHkiLCJuZXV0cmFsVGFyZ2V0IiwiY2xpZW50T25seSIsImJ1bmRsZWQiLCJhcHBQYWdlcyIsIldFQlBBQ0tfUkVTT1VSQ0VfUVVFUklFUyIsImVkZ2VTU1JFbnRyeSIsIm1ldGFkYXRhIiwibWV0YWRhdGFSb3V0ZSIsIm1ldGFkYXRhSW1hZ2VNZXRhIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRU8sTUFBTUEsMEJBQTBCLE9BQU07QUFDdEMsTUFBTUMsa0NBQWtDLE9BQU07QUFFOUMsTUFBTUMsc0JBQXNCLGlCQUFnQjtBQUM1QyxNQUFNQyw4QkFBOEIseUJBQXdCO0FBQzVELE1BQU1DLDZDQUNYLHNDQUFxQztBQUVoQyxNQUFNQyxzQkFBc0IsZ0JBQWU7QUFDM0MsTUFBTUMsMEJBQTBCLFlBQVc7QUFDM0MsTUFBTUMscUJBQXFCLGVBQWM7QUFDekMsTUFBTUMsYUFBYSxPQUFN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QXFCUSxVQUFVO1lBQy9CUixxQkFBcUJPLFVBQVU7U0FDaEM7UUFDRFcsZUFBZTtZQUNiLFlBQVk7WUFDWmxCLHFCQUFxQkssT0FBTztZQUM1QkwscUJBQXFCTSxPQUFPO1NBQzdCO1FBQ0RhLFlBQVk7WUFDVm5CLHFCQUFxQkcsbUJBQW1CO1lBQ3hDSCxxQkFBcUJVLGVBQWU7U0FDckM7UUFDRFUsU0FBUztZQUNQcEIscUJBQXFCRSxxQkFBcUI7WUFDMUNGLHFCQUFxQkksYUFBYTtZQUNsQ0oscUJBQXFCRyxtQkFBbUI7WUFDeENILHFCQUFxQlUsZUFBZTtZQUNwQ1YscUJBQXFCQyxNQUFNO1lBQzNCRCxxQkFBcUJRLFVBQVU7WUFDL0JSLHFCQUFxQk8sVUFBVTtTQUNoQztRQUNEYyxVQUFVO1lBQ1IsK0JBQStCO1lBQy9CckIscUJBQXFCRSxxQkFBcUI7WUFDMUNGLHFCQUFxQkcsbUJBQW1CO1lBQ3hDSCxxQkFBcUJVLGVBQWU7WUFDcENWLHFCQUFxQkksYUFBYTtTQUNuQztJQUNIO0FBQ0Y7QUFFQSxNQUFNa0IsMkJBQTJCO0lBQy9CQyxjQUFjO0lBQ2RDLFVBQVU7SUFDVkMsZUFBZTtJQUNmQyxtQkFBbUI7QUFDckIiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTA1ODQsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NyYy9zZXJ2ZXIvd2ViL3V0aWxzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgT3V0Z29pbmdIdHRwSGVhZGVycyB9IGZyb20gJ2h0dHAnXG5pbXBvcnQge1xuICBORVhUX0lOVEVSQ0VQVElPTl9NQVJLRVJfUFJFRklYLFxuICBORVhUX1FVRVJZX1BBUkFNX1BSRUZJWCxcbn0gZnJvbSAnLi4vLi4vbGliL2NvbnN0YW50cydcblxuLyoqXG4gKiBDb252ZXJ0cyBhIE5vZGUuanMgSW5jb21pbmdIdHRwSGVhZGVycyBvYmplY3QgdG8gYSBIZWFkZXJzIG9iamVjdC4gQW55XG4gKiBoZWFkZXJzIHdpdGggbXVsdGlwbGUgdmFsdWVzIHdpbGwgYmUgam9pbmVkIHdpdGggYSBjb21tYSBhbmQgc3BhY2UuIEFueVxuICogaGVhZGVycyB0aGF0IGhhdmUgYW4gdW5kZWZpbmVkIHZhbHVlIHdpbGwgYmUgaWdub3JlZCBhbmQgb3RoZXJzIHdpbGwgYmVcbiAqIGNvZXJjZWQgdG8gc3RyaW5ncy5cbiAqXG4gKiBAcGFyYW0gbm9kZUhlYWRlcnMgdGhlIGhlYWRlcnMgb2JqZWN0IHRvIGNvbnZlcnRcbiAqIEByZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaGVhZGVycyBvYmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21Ob2RlT3V0Z29pbmdIdHRwSGVhZGVycyhcbiAgbm9kZUhlYWRlcnM6IE91dGdvaW5nSHR0cEhlYWRlcnNcbik6IEhlYWRlcnMge1xuICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKVxuICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMobm9kZUhlYWRlcnMpKSB7XG4gICAgY29uc3QgdmFsdWVzID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV1cbiAgICBmb3IgKGxldCB2IG9mIHZhbHVlcykge1xuICAgICAgaWYgKHR5cGVvZiB2ID09PSAndW5kZWZpbmVkJykgY29udGludWVcbiAgICAgIGlmICh0eXBlb2YgdiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdiA9IHYudG9TdHJpbmcoKVxuICAgICAgfVxuXG4gICAgICBoZWFkZXJzLmFwcGVuZChrZXksIHYpXG4gICAgfVxuICB9XG4gIHJldHVybiBoZWFkZXJzXG59XG5cbi8qXG4gIFNldC1Db29raWUgaGVhZGVyIGZpZWxkLXZhbHVlcyBhcmUgc29tZXRpbWVzIGNvbW1hIGpvaW5lZCBpbiBvbmUgc3RyaW5nLiBUaGlzIHNwbGl0cyB0aGVtIHdpdGhvdXQgY2hva2luZyBvbiBjb21tYXNcbiAgdGhhdCBhcmUgd2l0aGluIGEgc2luZ2xlIHNldC1jb29raWUgZmllbGQtdmFsdWUsIHN1Y2ggYXMgaW4gdGhlIEV4cGlyZXMgcG9ydGlvbi5cbiAgVGhpcyBpcyB1bmNvbW1vbiwgYnV0IGV4cGxpY2l0bHkgYWxsb3dlZCAtIHNlZSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMjYxNiNzZWN0aW9uLTQuMlxuICBOb2RlLmpzIGRvZXMgdGhpcyBmb3IgZXZlcnkgaGVhZGVyICpleGNlcHQqIHNldC1jb29raWUgLSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvZDVlMzYzYjc3ZWJhZjFjYWY2N2NkNzUyODIyNGI2NTFjODY4MTVjMS9saWIvX2h0dHBfaW5jb21pbmcuanMjTDEyOFxuICBSZWFjdCBOYXRpdmUncyBmZXRjaCBkb2VzIHRoaXMgZm9yICpldmVyeSogaGVhZGVyLCBpbmNsdWRpbmcgc2V0LWNvb2tpZS5cbiAgXG4gIEJhc2VkIG9uOiBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL2oyb2JqYy9jb21taXQvMTY4MjBmZGJjOGY3NmNhMGMzMzQ3MjgxMGNlMGNiMDNkMjBlZmUyNVxuICBDcmVkaXRzIHRvOiBodHRwczovL2dpdGh1Yi5jb20vdG9tYmFsbCBmb3Igb3JpZ2luYWwgYW5kIGh0dHBzOi8vZ2l0aHViLmNvbS9jaHJ1c2FydCBmb3IgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvblxuKi9cbmV4cG9ydCBmdW5jdGlvbiBzcGxpdENvb2tpZXNTdHJpbmcoY29va2llc1N0cmluZzogc3RyaW5nKSB7XG4gIHZhciBjb29raWVzU3RyaW5ncyA9IFtdXG4gIHZhciBwb3MgPSAwXG4gIHZhciBzdGFydFxuICB2YXIgY2hcbiAgdmFyIGxhc3RDb21tYVxuICB2YXIgbmV4dFN0YXJ0XG4gIHZhciBjb29raWVzU2VwYXJhdG9yRm91bmRcblxuICBmdW5jdGlvbiBza2lwV2hpdGVzcGFjZSgpIHtcbiAgICB3aGlsZSAocG9zIDwgY29va2llc1N0cmluZy5sZW5ndGggJiYgL1xccy8udGVzdChjb29raWVzU3RyaW5nLmNoYXJBdChwb3MpKSkge1xuICAgICAgcG9zICs9IDFcbiAgICB9XG4gICAgcmV0dXJuIHBvcyA8IGNvb2tpZXNTdHJpbmcubGVuZ3RoXG4gIH1cblxuICBmdW5jdGlvbiBub3RTcGVjaWFsQ2hhcigpIHtcbiAgICBjaCA9IGNvb2tpZXNTdHJpbmcuY2hhckF0KHBvcylcblxuICAgIHJldHVybiBjaCAhPT0gJz0nICYmIGNoICE9PSAnOycgJiYgY2ggIT09ICcsJ1xuICB9XG5cbiAgd2hpbGUgKHBvcyA8IGNvb2tpZXNTdHJpbmcubGVuZ3RoKSB7XG4gICAgc3RhcnQgPSBwb3NcbiAgICBjb29raWVzU2VwYXJhdG9yRm91bmQgPSBmYWxzZVxuXG4gICAgd2hpbGUgKHNraXBXaGl0ZXNwYWNlKCkpIHtcbiAgICAgIGNoID0gY29va2llc1N0cmluZy5jaGFyQXQocG9zKVxuICAgICAgaWYgKGNoID09PSAnLCcpIHtcbiAgICAgICAgLy8gJywnIGlzIGEgY29va2llIHNlcGFyYXRvciBpZiB3ZSBoYXZlIGxhdGVyIGZpcnN0ICc9Jywgbm90ICc7JyBvciAnLCdcbiAgICAgICAgbGFzdENvbW1hID0gcG9zXG4gICAgICAgIHBvcyArPSAxXG5cbiAgICAgICAgc2tpcFdoaXRlc3BhY2UoKVxuICAgICAgICBuZXh0U3RhcnQgPSBwb3NcblxuICAgICAgICB3aGlsZSAocG9zIDwgY29va2llc1N0cmluZy5sZW5ndGggJiYgbm90U3BlY2lhbENoYXIoKSkge1xuICAgICAgICAgIHBvcyArPSAxXG4gICAgICAgIH1cblxuICAgICAgICAvLyBjdXJyZW50bHkgc3BlY2lhbCBjaGFyYWN0ZXJcbiAgICAgICAgaWYgKHBvcyA8IGNvb2tpZXNTdHJpbmcubGVuZ3RoICYmIGNvb2tpZXNTdHJpbmcuY2hhckF0KHBvcykgPT09ICc9Jykge1xuICAgICAgICAgIC8vIHdlIGZvdW5kIGNvb2tpZXMgc2VwYXJhdG9yXG4gICAgICAgICAgY29va2llc1NlcGFyYXRvckZvdW5kID0gdHJ1ZVxuICAgICAgICAgIC8vIHBvcyBpcyBpbnNpZGUgdGhlIG5leHQgY29va2llLCBzbyBiYWNrIHVwIGFuZCByZXR1cm4gaXQuXG4gICAgICAgICAgcG9zID0gbmV4dFN0YXJ0XG4gICAgICAgICAgY29va2llc1N0cmluZ3MucHVzaChjb29raWVzU3RyaW5nLnN1YnN0cmluZyhzdGFydCwgbGFzdENvbW1hKSlcbiAgICAgICAgICBzdGFydCA9IHBvc1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGluIHBhcmFtICcsJyBvciBwYXJhbSBzZXBhcmF0b3IgJzsnLFxuICAgICAgICAgIC8vIHdlIGNvbnRpbnVlIGZyb20gdGhhdCBjb21tYVxuICAgICAgICAgIHBvcyA9IGxhc3RDb21tYSArIDFcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9zICs9IDFcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWNvb2tpZXNTZXBhcmF0b3JGb3VuZCB8fCBwb3MgPj0gY29va2llc1N0cmluZy5sZW5ndGgpIHtcbiAgICAgIGNvb2tpZXNTdHJpbmdzLnB1c2goY29va2llc1N0cmluZy5zdWJzdHJpbmcoc3RhcnQsIGNvb2tpZXNTdHJpbmcubGVuZ3RoKSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29va2llc1N0cmluZ3Ncbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIEhlYWRlcnMgb2JqZWN0IHRvIGEgTm9kZS5qcyBPdXRnb2luZ0h0dHBIZWFkZXJzIG9iamVjdC4gVGhpcyBpc1xuICogcmVxdWlyZWQgdG8gc3VwcG9ydCB0aGUgc2V0LWNvb2tpZSBoZWFkZXIsIHdoaWNoIG1heSBoYXZlIG11bHRpcGxlIHZhbHVlcy5cbiAqXG4gKiBAcGFyYW0gaGVhZGVycyB0aGUgaGVhZGVycyBvYmplY3QgdG8gY29udmVydFxuICogQHJldHVybnMgdGhlIGNvbnZlcnRlZCBoZWFkZXJzIG9iamVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9Ob2RlT3V0Z29pbmdIdHRwSGVhZGVycyhcbiAgaGVhZGVyczogSGVhZGVyc1xuKTogT3V0Z29pbmdIdHRwSGVhZGVycyB7XG4gIGNvbnN0IG5vZGVIZWFkZXJzOiBPdXRnb2luZ0h0dHBIZWFkZXJzID0ge31cbiAgY29uc3QgY29va2llczogc3RyaW5nW10gPSBbXVxuICBpZiAoaGVhZGVycykge1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGhlYWRlcnMuZW50cmllcygpKSB7XG4gICAgICBpZiAoa2V5LnRvTG93ZXJDYXNlKCkgPT09ICdzZXQtY29va2llJykge1xuICAgICAgICAvLyBXZSBtYXkgaGF2ZSBnb3R0ZW4gYSBjb21tYSBqb2luZWQgc3RyaW5nIG9mIGNvb2tpZXMsIG9yIG11bHRpcGxlXG4gICAgICAgIC8vIHNldC1jb29raWUgaGVhZGVycy4gV2UgbmVlZCB0byBtZXJnZSB0aGVtIGludG8gb25lIGhlYWRlciBhcnJheVxuICAgICAgICAvLyB0byByZXByZXNlbnQgYWxsIHRoZSBjb29raWVzLlxuICAgICAgICBjb29raWVzLnB1c2goLi4uc3BsaXRDb29raWVzU3RyaW5nKHZhbHVlKSlcbiAgICAgICAgbm9kZUhlYWRlcnNba2V5XSA9IGNvb2tpZXMubGVuZ3RoID09PSAxID8gY29va2llc1swXSA6IGNvb2tpZXNcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVIZWFkZXJzW2tleV0gPSB2YWx1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbm9kZUhlYWRlcnNcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSB0aGUgY29ycmVjdG5lc3Mgb2YgYSB1c2VyLXByb3ZpZGVkIFVSTC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlVVJMKHVybDogc3RyaW5nIHwgVVJMKTogc3RyaW5nIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gU3RyaW5nKG5ldyBVUkwoU3RyaW5nKHVybCkpKVxuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFVSTCBpcyBtYWxmb3JtZWQgXCIke1N0cmluZyhcbiAgICAgICAgdXJsXG4gICAgICApfVwiLiBQbGVhc2UgdXNlIG9ubHkgYWJzb2x1dGUgVVJMcyAtIGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL21pZGRsZXdhcmUtcmVsYXRpdmUtdXJsc2AsXG4gICAgICB7IGNhdXNlOiBlcnJvciB9XG4gICAgKVxuICB9XG59XG5cbi8qKlxuICogTm9ybWFsaXplcyBgbnh0UGAgYW5kIGBueHRJYCBxdWVyeSBwYXJhbSB2YWx1ZXMgdG8gcmVtb3ZlIHRoZSBwcmVmaXguXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IG11dGF0ZSB0aGUgaW5wdXQga2V5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplTmV4dFF1ZXJ5UGFyYW0oa2V5OiBzdHJpbmcpOiBudWxsIHwgc3RyaW5nIHtcbiAgY29uc3QgcHJlZml4ZXMgPSBbTkVYVF9RVUVSWV9QQVJBTV9QUkVGSVgsIE5FWFRfSU5URVJDRVBUSU9OX01BUktFUl9QUkVGSVhdXG4gIGZvciAoY29uc3QgcHJlZml4IG9mIHByZWZpeGVzKSB7XG4gICAgaWYgKGtleSAhPT0gcHJlZml4ICYmIGtleS5zdGFydHNXaXRoKHByZWZpeCkpIHtcbiAgICAgIHJldHVybiBrZXkuc3Vic3RyaW5nKHByZWZpeC5sZW5ndGgpXG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsXG59XG4iXSwibmFtZXMiOlsiTkVYVF9JTlRFUkNFUFRJT05fTUFSS0VSX1BSRUZJWCIsIk5FWFRfUVVFUllfUEFSQU1fUFJFRklYIiwiZnJvbU5vZGVPdXRnb2luZ0h0dHBIZWFkZXJzIiwibm9kZUhlYWRlcnMiLCJoZWFkZXJzIiwiSGVhZGVycyIsImtleSIsInZhbHVlIiwiT2JqZWN0IiwiZW50cmllcyIsInZhbHVlcyIsIkFycmF5IiwiaXNBcnJheSIsInYiLCJ0b1N0cmluZyIsImFwcGVuZCIsInNwbGl0Q29va2llc1N0cmluZyIsImNvb2tpZXNTdHJpbmciLCJjb29raWVzU3RyaW5ncyIsInBvcyIsInN0YXJ0IiwiY2giLCJsYXN0Q29tbWEiLCJuZXh0U3RhcnQiLCJjb29raWVzU2VwYXJhdG9yRm91bmQiLCJza2lwV2hpdGVzcGFjZSIsImxlbmd0aCIsInRlc3QiLCJjaGFyQXQiLCJub3RTcGVjaWFsQ2hhciIsInB1c2giLCJzdWJzdHJpbmciLCJ0b05vZGVPdXRnb2luZ0h0dHBIZWFkZXJzIiwiY29va2llcyIsInRvTG93ZXJDYXNlIiwidmFsaWRhdGVVUkwiLCJ1cmwiLCJTdHJpbmciLCJVUkwiLCJlcnJvciIsIkVycm9yIiwiY2F1c2UiLCJub3JtYWxpemVOZXh0UXVlcnlQYXJhbSIsInByZWZpeGVzIiwicHJlZml4Iiwic3RhcnRzV2l0aCJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUNBLFNBQ0VBLCtCQUErQixFQUMvQkMsdUJBQXVCLFFBQ2xCLHNCQUFxQjs7QUFXckIsU0FBU0MsNEJBQ2RDLFdBQWdDO0lBRWhDLE1BQU1DLFVBQVUsSUFBSUM7SUFDcEIsS0FBSyxJQUFJLENBQUNDLEtBQUtDLE1BQU0sSUFBSUMsT0FBT0MsT0FBTyxDQUFDTixhQUFjO1FBQ3BELE1BQU1PLFNBQVNDLE1BQU1DLE9BQU8sQ0FBQ0wsU0FBU0EsUUFBUTtZQUFDQTtTQUFNO1FBQ3JELEtBQUssSUFBSU0sS0FBS0gsT0FBUTtZQUNwQixJQUFJLE9BQU9HLE1BQU0sYUFBYTtZQUM5QixJQUFJLE9BQU9BLE1BQU0sVUFBVTtnQkFDekJBLElBQUlBLEVBQUVDLFFBQVE7WUFDaEI7WUFFQVYsUUFBUVcsTUFBTSxDQUFDVCxLQUFLTztRQUN0QjtJQUNGO0lBQ0EsT0FBT1Q7QUFDVDtBQVlPLFNBQVNZLG1CQUFtQkMsYUFBcUI7SUFDdEQsSUFBSUMsaUJBQWlCLEVBQUU7SUFDdkIsSUFBSUMsTUFBTTtJQUNWLElBQUlDO0lBQ0osSUFBSUM7SUFDSixJQUFJQztJQUNKLElBQUlDO0lBQ0osSUFBSUM7SUFFSixT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ImxpbmUiOiAxMDcxMSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL3NoYXJlZC9saWIvaTE4bi9kZXRlY3QtZG9tYWluLWxvY2FsZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IERvbWFpbkxvY2FsZSB9IGZyb20gJy4uLy4uLy4uL3NlcnZlci9jb25maWctc2hhcmVkJ1xuXG5leHBvcnQgZnVuY3Rpb24gZGV0ZWN0RG9tYWluTG9jYWxlKFxuICBkb21haW5JdGVtcz86IHJlYWRvbmx5IERvbWFpbkxvY2FsZVtdLFxuICBob3N0bmFtZT86IHN0cmluZyxcbiAgZGV0ZWN0ZWRMb2NhbGU/OiBzdHJpbmdcbikge1xuICBpZiAoIWRvbWFpbkl0ZW1zKSByZXR1cm5cblxuICBpZiAoZGV0ZWN0ZWRMb2NhbGUpIHtcbiAgICBkZXRlY3RlZExvY2FsZSA9IGRldGVjdGVkTG9jYWxlLnRvTG93ZXJDYXNlKClcbiAgfVxuXG4gIGZvciAoY29uc3QgaXRlbSBvZiBkb21haW5JdGVtcykge1xuICAgIC8vIHJlbW92ZSBwb3J0IGlmIHByZXNlbnRcbiAgICBjb25zdCBkb21haW5Ib3N0bmFtZSA9IGl0ZW0uZG9tYWluPy5zcGxpdCgnOicsIDEpWzBdLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoXG4gICAgICBob3N0bmFtZSA9PT0gZG9tYWluSG9zdG5hbWUgfHxcbiAgICAgIGRldGVjdGVkTG9jYWxlID09PSBpdGVtLmRlZmF1bHRMb2NhbGUudG9Mb3dlckNhc2UoKSB8fFxuICAgICAgaXRlbS5sb2NhbGVzPy5zb21lKChsb2NhbGUpID0+IGxvY2FsZS50b0xvd2VyQ2FzZSgpID09PSBkZXRlY3RlZExvY2FsZSlcbiAgICApIHtcbiAgICAgIHJldHVybiBpdGVtXG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOlsiZGV0ZWN0RG9tYWluTG9jYWxlIiwiZG9tYWluSXRlbXMiLCJob3N0bmFtZSIsImRldGVjdGVkTG9jYWxlIiwidG9Mb3dlckNhc2UiLCJpdGVtIiwiZG9tYWluSG9zdG5hbWUiLCJkb21haW4iLCJzcGxpdCIsImRlZmF1bHRMb2NhbGUiLCJsb2NhbGVzIiwic29tZSIsImxvY2FsZSJdLCJtYXBwaW5ncyI6Ijs7O0FBRU8sU0FBU0EsbUJBQ2RDLFdBQXFDLEVBQ3JDQyxRQUFpQixFQUNqQkMsY0FBdUI7SUFFdkIsSUFBSSxDQUFDRixhQUFhO0lBRWxCLElBQUlFLGdCQUFnQjtRQUNsQkEsaUJBQWlCQSxlQUFlQyxXQUFXO0lBQzdDO0lBRUEsS0FBSyxNQUFNQyxRQUFRSixZQUFhO1lBRVBJLGNBSXJCQTtRQUxGLHlCQUF5QjtRQUN6QixNQUFNQyxpQkFBQUEsQ0FBaUJELGVBQUFBLEtBQUtFLE1BQU0sS0FBQSxPQUFBLEtBQUEsSUFBWEYsYUFBYUcsS0FBSyxDQUFDLEtBQUssRUFBRSxDQUFDLEVBQUUsQ0FBQ0osV0FBVztRQUNoRSxJQUNFRixhQUFhSSxrQkFDYkgsbUJBQW1CRSxLQUFLSSxhQUFhLENBQUNMLFdBQVcsTUFBQSxDQUFBLENBQ2pEQyxnQkFBQUEsS0FBS0ssT0FBTyxLQUFBLE9BQUEsS0FBQSxJQUFaTCxjQUFjTSxJQUFJLENBQUMsQ0FBQ0MsU0FBV0EsT0FBT1IsV0FBVyxPQUFPRCxlQUFBQSxHQUN4RDtZQUNBLE9BQU9FO1FBQ1Q7SUFDRjtBQUNGIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDEwNzMyLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zcmMvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcmVtb3ZlLXRyYWlsaW5nLXNsYXNoLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUmVtb3ZlcyB0aGUgdHJhaWxpbmcgc2xhc2ggZm9yIGEgZ2l2ZW4gcm91dGUgb3IgcGFnZSBwYXRoLiBQcmVzZXJ2ZXMgdGhlXG4gKiByb290IHBhZ2UuIEV4YW1wbGVzOlxuICogICAtIGAvZm9vL2Jhci9gIC0+IGAvZm9vL2JhcmBcbiAqICAgLSBgL2Zvby9iYXJgIC0+IGAvZm9vL2JhcmBcbiAqICAgLSBgL2AgLT4gYC9gXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVUcmFpbGluZ1NsYXNoKHJvdXRlOiBzdHJpbmcpIHtcbiAgcmV0dXJuIHJvdXRlLnJlcGxhY2UoL1xcLyQvLCAnJykgfHwgJy8nXG59XG4iXSwibmFtZXMiOlsicmVtb3ZlVHJhaWxpbmdTbGFzaCIsInJvdXRlIiwicmVwbGFjZSJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztDQU1DLEdBQ0Q7OztBQUFPLFNBQVNBLG9CQUFvQkMsS0FBYTtJQUMvQyxPQUFPQSxNQUFNQyxPQUFPLENBQUMsT0FBTyxPQUFPO0FBQ3JDIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDEwNzQ4LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zcmMvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcGFyc2UtcGF0aC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEdpdmVuIGEgcGF0aCB0aGlzIGZ1bmN0aW9uIHdpbGwgZmluZCB0aGUgcGF0aG5hbWUsIHF1ZXJ5IGFuZCBoYXNoIGFuZCByZXR1cm5cbiAqIHRoZW0uIFRoaXMgaXMgdXNlZnVsIHRvIHBhcnNlIGZ1bGwgcGF0aHMgb24gdGhlIGNsaWVudCBzaWRlLlxuICogQHBhcmFtIHBhdGggQSBwYXRoIHRvIHBhcnNlIGUuZy4gL2Zvby9iYXI/aWQ9MSNoYXNoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVBhdGgocGF0aDogc3RyaW5nKSB7XG4gIGNvbnN0IGhhc2hJbmRleCA9IHBhdGguaW5kZXhPZignIycpXG4gIGNvbnN0IHF1ZXJ5SW5kZXggPSBwYXRoLmluZGV4T2YoJz8nKVxuICBjb25zdCBoYXNRdWVyeSA9IHF1ZXJ5SW5kZXggPiAtMSAmJiAoaGFzaEluZGV4IDwgMCB8fCBxdWVyeUluZGV4IDwgaGFzaEluZGV4KVxuXG4gIGlmIChoYXNRdWVyeSB8fCBoYXNoSW5kZXggPiAtMSkge1xuICAgIHJldHVybiB7XG4gICAgICBwYXRobmFtZTogcGF0aC5zdWJzdHJpbmcoMCwgaGFzUXVlcnkgPyBxdWVyeUluZGV4IDogaGFzaEluZGV4KSxcbiAgICAgIHF1ZXJ5OiBoYXNRdWVyeVxuICAgICAgICA/IHBhdGguc3Vic3RyaW5nKHF1ZXJ5SW5kZXgsIGhhc2hJbmRleCA+IC0xID8gaGFzaEluZGV4IDogdW5kZWZpbmVkKVxuICAgICAgICA6ICcnLFxuICAgICAgaGFzaDogaGFzaEluZGV4ID4gLTEgPyBwYXRoLnNsaWNlKGhhc2hJbmRleCkgOiAnJyxcbiAgICB9XG4gIH1cblxuICByZXR1cm4geyBwYXRobmFtZTogcGF0aCwgcXVlcnk6ICcnLCBoYXNoOiAnJyB9XG59XG4iXSwibmFtZXMiOlsicGFyc2VQYXRoIiwicGF0aCIsImhhc2hJbmRleCIsImluZGV4T2YiLCJxdWVyeUluZGV4IiwiaGFzUXVlcnkiLCJwYXRobmFtZSIsInN1YnN0cmluZyIsInF1ZXJ5IiwidW5kZWZpbmVkIiwiaGFzaCIsInNsaWNlIl0sIm1hcHBpbmdzIjoiQUFBQTs7OztDQUlDLEdBQ0Q7OztBQUFPLFNBQVNBLFVBQVVDLElBQVk7SUFDcEMsTUFBTUMsWUFBWUQsS0FBS0UsT0FBTyxDQUFDO0lBQy9CLE1BQU1DLGFBQWFILEtBQUtFLE9BQU8sQ0FBQztJQUNoQyxNQUFNRSxXQUFXRCxhQUFhLENBQUMsS0FBTUYsQ0FBQUEsWUFBWSxLQUFLRSxhQUFhRixTQUFRO0lBRTNFLElBQUlHLFlBQVlILFlBQVksQ0FBQyxHQUFHO1FBQzlCLE9BQU87WUFDTEksVUFBVUwsS0FBS00sU0FBUyxDQUFDLEdBQUdGLFdBQVdELGFBQWFGO1lBQ3BETSxPQUFPSCxXQUNISixLQUFLTSxTQUFTLENBQUNILFlBQVlGLFlBQVksQ0FBQyxJQUFJQSxZQUFZTyxhQUN4RDtZQUNKQyxNQUFNUixZQUFZLENBQUMsSUFBSUQsS0FBS1UsS0FBSyxDQUFDVCxhQUFhO1FBQ2pEO0lBQ0Y7SUFFQSxPQUFPO1FBQUVJLFVBQVVMO1FBQU1PLE9BQU87UUFBSUUsTUFBTTtJQUFHO0FBQy9DIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDEwNzc2LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zcmMvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvYWRkLXBhdGgtcHJlZml4LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHBhcnNlUGF0aCB9IGZyb20gJy4vcGFyc2UtcGF0aCdcblxuLyoqXG4gKiBBZGRzIHRoZSBwcm92aWRlZCBwcmVmaXggdG8gdGhlIGdpdmVuIHBhdGguIEl0IGZpcnN0IGVuc3VyZXMgdGhhdCB0aGUgcGF0aFxuICogaXMgaW5kZWVkIHN0YXJ0aW5nIHdpdGggYSBzbGFzaC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZFBhdGhQcmVmaXgocGF0aDogc3RyaW5nLCBwcmVmaXg/OiBzdHJpbmcpIHtcbiAgaWYgKCFwYXRoLnN0YXJ0c1dpdGgoJy8nKSB8fCAhcHJlZml4KSB7XG4gICAgcmV0dXJuIHBhdGhcbiAgfVxuXG4gIGNvbnN0IHsgcGF0aG5hbWUsIHF1ZXJ5LCBoYXNoIH0gPSBwYXJzZVBhdGgocGF0aClcbiAgcmV0dXJuIGAke3ByZWZpeH0ke3BhdGhuYW1lfSR7cXVlcnl9JHtoYXNofWBcbn1cbiJdLCJuYW1lcyI6WyJwYXJzZVBhdGgiLCJhZGRQYXRoUHJlZml4IiwicGF0aCIsInByZWZpeCIsInN0YXJ0c1dpdGgiLCJwYXRobmFtZSIsInF1ZXJ5IiwiaGFzaCJdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsU0FBU0EsU0FBUyxRQUFRLGVBQWM7O0FBTWpDLFNBQVNDLGNBQWNDLElBQVksRUFBRUMsTUFBZTtJQUN6RCxJQUFJLENBQUNELEtBQUtFLFVBQVUsQ0FBQyxRQUFRLENBQUNELFFBQVE7UUFDcEMsT0FBT0Q7SUFDVDtJQUVBLE1BQU0sRUFBRUcsUUFBUSxFQUFFQyxLQUFLLEVBQUVDLElBQUksRUFBRSxnTUFBR1AsWUFBQUEsRUFBVUU7SUFDNUMsT0FBUSxLQUFFQyxTQUFTRSxXQUFXQyxRQUFRQztBQUN4QyIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxMDc5MiwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2FkZC1wYXRoLXN1ZmZpeC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwYXJzZVBhdGggfSBmcm9tICcuL3BhcnNlLXBhdGgnXG5cbi8qKlxuICogU2ltaWxhcmx5IHRvIGBhZGRQYXRoUHJlZml4YCwgdGhpcyBmdW5jdGlvbiBhZGRzIGEgc3VmZml4IGF0IHRoZSBlbmQgb24gdGhlXG4gKiBwcm92aWRlZCBwYXRoLiBJdCBhbHNvIHdvcmtzIG9ubHkgZm9yIHBhdGhzIGVuc3VyaW5nIHRoZSBhcmd1bWVudCBzdGFydHNcbiAqIHdpdGggYSBzbGFzaC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZFBhdGhTdWZmaXgocGF0aDogc3RyaW5nLCBzdWZmaXg/OiBzdHJpbmcpIHtcbiAgaWYgKCFwYXRoLnN0YXJ0c1dpdGgoJy8nKSB8fCAhc3VmZml4KSB7XG4gICAgcmV0dXJuIHBhdGhcbiAgfVxuXG4gIGNvbnN0IHsgcGF0aG5hbWUsIHF1ZXJ5LCBoYXNoIH0gPSBwYXJzZVBhdGgocGF0aClcbiAgcmV0dXJuIGAke3BhdGhuYW1lfSR7c3VmZml4fSR7cXVlcnl9JHtoYXNofWBcbn1cbiJdLCJuYW1lcyI6WyJwYXJzZVBhdGgiLCJhZGRQYXRoU3VmZml4IiwicGF0aCIsInN1ZmZpeCIsInN0YXJ0c1dpdGgiLCJwYXRobmFtZSIsInF1ZXJ5IiwiaGFzaCJdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsU0FBU0EsU0FBUyxRQUFRLGVBQWM7O0FBT2pDLFNBQVNDLGNBQWNDLElBQVksRUFBRUMsTUFBZTtJQUN6RCxJQUFJLENBQUNELEtBQUtFLFVBQVUsQ0FBQyxRQUFRLENBQUNELFFBQVE7UUFDcEMsT0FBT0Q7SUFDVDtJQUVBLE1BQU0sRUFBRUcsUUFBUSxFQUFFQyxLQUFLLEVBQUVDLElBQUksRUFBRSxnTUFBR1AsWUFBQUEsRUFBVUU7SUFDNUMsT0FBUSxLQUFFRyxXQUFXRixTQUFTRyxRQUFRQztBQUN4QyIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxMDgwOCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3BhdGgtaGFzLXByZWZpeC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwYXJzZVBhdGggfSBmcm9tICcuL3BhcnNlLXBhdGgnXG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgZ2l2ZW4gcGF0aCBzdGFydHMgd2l0aCBhIGdpdmVuIHByZWZpeC4gSXQgZW5zdXJlcyBpdCBtYXRjaGVzXG4gKiBleGFjdGx5IHdpdGhvdXQgY29udGFpbmluZyBleHRyYSBjaGFycy4gZS5nLiBwcmVmaXggL2RvY3Mgc2hvdWxkIHJlcGxhY2VcbiAqIGZvciAvZG9jcywgL2RvY3MvLCAvZG9jcy9hIGJ1dCBub3QgL2RvY3Nzc1xuICogQHBhcmFtIHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcGFyYW0gcHJlZml4IFRoZSBwcmVmaXggdG8gY2hlY2sgYWdhaW5zdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhdGhIYXNQcmVmaXgocGF0aDogc3RyaW5nLCBwcmVmaXg6IHN0cmluZykge1xuICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBjb25zdCB7IHBhdGhuYW1lIH0gPSBwYXJzZVBhdGgocGF0aClcbiAgcmV0dXJuIHBhdGhuYW1lID09PSBwcmVmaXggfHwgcGF0aG5hbWUuc3RhcnRzV2l0aChwcmVmaXggKyAnLycpXG59XG4iXSwibmFtZXMiOlsicGFyc2VQYXRoIiwicGF0aEhhc1ByZWZpeCIsInBhdGgiLCJwcmVmaXgiLCJwYXRobmFtZSIsInN0YXJ0c1dpdGgiXSwibWFwcGluZ3MiOiI7OztBQUFBLFNBQVNBLFNBQVMsUUFBUSxlQUFjOztBQVNqQyxTQUFTQyxjQUFjQyxJQUFZLEVBQUVDLE1BQWM7SUFDeEQsSUFBSSxPQUFPRCxTQUFTLFVBQVU7UUFDNUIsT0FBTztJQUNUO0lBRUEsTUFBTSxFQUFFRSxRQUFRLEVBQUUsZ01BQUdKLFlBQUFBLEVBQVVFO0lBQy9CLE9BQU9FLGFBQWFELFVBQVVDLFNBQVNDLFVBQVUsQ0FBQ0YsU0FBUztBQUM3RCIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxMDgyNCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2FkZC1sb2NhbGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYWRkUGF0aFByZWZpeCB9IGZyb20gJy4vYWRkLXBhdGgtcHJlZml4J1xuaW1wb3J0IHsgcGF0aEhhc1ByZWZpeCB9IGZyb20gJy4vcGF0aC1oYXMtcHJlZml4J1xuXG4vKipcbiAqIEZvciBhIGdpdmVuIHBhdGggYW5kIGEgbG9jYWxlLCBpZiB0aGUgbG9jYWxlIGlzIGdpdmVuLCBpdCB3aWxsIHByZWZpeCB0aGVcbiAqIGxvY2FsZS4gVGhlIHBhdGggc2hvdWxkbid0IGJlIGFuIEFQSSBwYXRoLiBJZiBhIGRlZmF1bHQgbG9jYWxlIGlzIGdpdmVuIHRoZVxuICogcHJlZml4IHdpbGwgYmUgb21pdHRlZCBpZiB0aGUgbG9jYWxlIGlzIGFscmVhZHkgdGhlIGRlZmF1bHQgbG9jYWxlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkTG9jYWxlKFxuICBwYXRoOiBzdHJpbmcsXG4gIGxvY2FsZT86IHN0cmluZyB8IGZhbHNlLFxuICBkZWZhdWx0TG9jYWxlPzogc3RyaW5nLFxuICBpZ25vcmVQcmVmaXg/OiBib29sZWFuXG4pIHtcbiAgLy8gSWYgbm8gbG9jYWxlIHdhcyBnaXZlbiBvciB0aGUgbG9jYWxlIGlzIHRoZSBkZWZhdWx0IGxvY2FsZSwgd2UgZG9uJ3QgbmVlZFxuICAvLyB0byBwcmVmaXggdGhlIHBhdGguXG4gIGlmICghbG9jYWxlIHx8IGxvY2FsZSA9PT0gZGVmYXVsdExvY2FsZSkgcmV0dXJuIHBhdGhcblxuICBjb25zdCBsb3dlciA9IHBhdGgudG9Mb3dlckNhc2UoKVxuXG4gIC8vIElmIHRoZSBwYXRoIGlzIGFuIEFQSSBwYXRoIG9yIHRoZSBwYXRoIGFscmVhZHkgaGFzIHRoZSBsb2NhbGUgcHJlZml4LCB3ZVxuICAvLyBkb24ndCBuZWVkIHRvIHByZWZpeCB0aGUgcGF0aC5cbiAgaWYgKCFpZ25vcmVQcmVmaXgpIHtcbiAgICBpZiAocGF0aEhhc1ByZWZpeChsb3dlciwgJy9hcGknKSkgcmV0dXJuIHBhdGhcbiAgICBpZiAocGF0aEhhc1ByZWZpeChsb3dlciwgYC8ke2xvY2FsZS50b0xvd2VyQ2FzZSgpfWApKSByZXR1cm4gcGF0aFxuICB9XG5cbiAgLy8gQWRkIHRoZSBsb2NhbGUgcHJlZml4IHRvIHRoZSBwYXRoLlxuICByZXR1cm4gYWRkUGF0aFByZWZpeChwYXRoLCBgLyR7bG9jYWxlfWApXG59XG4iXSwibmFtZXMiOlsiYWRkUGF0aFByZWZpeCIsInBhdGhIYXNQcmVmaXgiLCJhZGRMb2NhbGUiLCJwYXRoIiwibG9jYWxlIiwiZGVmYXVsdExvY2FsZSIsImlnbm9yZVByZWZpeCIsImxvd2VyIiwidG9Mb3dlckNhc2UiXSwibWFwcGluZ3MiOiI7OztBQUFBLFNBQVNBLGFBQWEsUUFBUSxvQkFBbUI7QUFDakQsU0FBU0MsYUFBYSxRQUFRLG9CQUFtQjs7O0FBTzFDLFNBQVNDLFVBQ2RDLElBQVksRUFDWkMsTUFBdUIsRUFDdkJDLGFBQXNCLEVBQ3RCQyxZQUFzQjtJQUV0Qiw0RUFBNEU7SUFDNUUsc0JBQXNCO0lBQ3RCLElBQUksQ0FBQ0YsVUFBVUEsV0FBV0MsZUFBZSxPQUFPRjtJQUVoRCxNQUFNSSxRQUFRSixLQUFLSyxXQUFXO0lBRTlCLDJFQUEyRTtJQUMzRSxpQ0FBaUM7SUFDakMsSUFBSSxDQUFDRixjQUFjO1FBQ2pCLHlNQUFJTCxnQkFBQUEsRUFBY00sT0FBTyxTQUFTLE9BQU9KO1FBQ3pDLHlNQUFJRixnQkFBQUEsRUFBY00sT0FBUSxNQUFHSCxPQUFPSSxXQUFXLEtBQU8sT0FBT0w7SUFDL0Q7SUFFQSxxQ0FBcUM7SUFDckMsNE1BQU9ILGdCQUFBQSxFQUFjRyxNQUFPLE1BQUdDO0FBQ2pDIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDEwODQ5LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zcmMvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvZm9ybWF0LW5leHQtcGF0aG5hbWUtaW5mby50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IE5leHRQYXRobmFtZUluZm8gfSBmcm9tICcuL2dldC1uZXh0LXBhdGhuYW1lLWluZm8nXG5pbXBvcnQgeyByZW1vdmVUcmFpbGluZ1NsYXNoIH0gZnJvbSAnLi9yZW1vdmUtdHJhaWxpbmctc2xhc2gnXG5pbXBvcnQgeyBhZGRQYXRoUHJlZml4IH0gZnJvbSAnLi9hZGQtcGF0aC1wcmVmaXgnXG5pbXBvcnQgeyBhZGRQYXRoU3VmZml4IH0gZnJvbSAnLi9hZGQtcGF0aC1zdWZmaXgnXG5pbXBvcnQgeyBhZGRMb2NhbGUgfSBmcm9tICcuL2FkZC1sb2NhbGUnXG5cbmludGVyZmFjZSBFeHRlbmRlZEluZm8gZXh0ZW5kcyBOZXh0UGF0aG5hbWVJbmZvIHtcbiAgZGVmYXVsdExvY2FsZT86IHN0cmluZ1xuICBpZ25vcmVQcmVmaXg/OiBib29sZWFuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXROZXh0UGF0aG5hbWVJbmZvKGluZm86IEV4dGVuZGVkSW5mbykge1xuICBsZXQgcGF0aG5hbWUgPSBhZGRMb2NhbGUoXG4gICAgaW5mby5wYXRobmFtZSxcbiAgICBpbmZvLmxvY2FsZSxcbiAgICBpbmZvLmJ1aWxkSWQgPyB1bmRlZmluZWQgOiBpbmZvLmRlZmF1bHRMb2NhbGUsXG4gICAgaW5mby5pZ25vcmVQcmVmaXhcbiAgKVxuXG4gIGlmIChpbmZvLmJ1aWxkSWQgfHwgIWluZm8udHJhaWxpbmdTbGFzaCkge1xuICAgIHBhdGhuYW1lID0gcmVtb3ZlVHJhaWxpbmdTbGFzaChwYXRobmFtZSlcbiAgfVxuXG4gIGlmIChpbmZvLmJ1aWxkSWQpIHtcbiAgICBwYXRobmFtZSA9IGFkZFBhdGhTdWZmaXgoXG4gICAgICBhZGRQYXRoUHJlZml4KHBhdGhuYW1lLCBgL19uZXh0L2RhdGEvJHtpbmZvLmJ1aWxkSWR9YCksXG4gICAgICBpbmZvLnBhdGhuYW1lID09PSAnLycgPyAnaW5kZXguanNvbicgOiAnLmpzb24nXG4gICAgKVxuICB9XG5cbiAgcGF0aG5hbWUgPSBhZGRQYXRoUHJlZml4KHBhdGhuYW1lLCBpbmZvLmJhc2VQYXRoKVxuICByZXR1cm4gIWluZm8uYnVpbGRJZCAmJiBpbmZvLnRyYWlsaW5nU2xhc2hcbiAgICA/ICFwYXRobmFtZS5lbmRzV2l0aCgnLycpXG4gICAgICA/IGFkZFBhdGhTdWZmaXgocGF0aG5hbWUsICcvJylcbiAgICAgIDogcGF0aG5hbWVcbiAgICA6IHJlbW92ZVRyYWlsaW5nU2xhc2gocGF0aG5hbWUpXG59XG4iXSwibmFtZXMiOlsicmVtb3ZlVHJhaWxpbmdTbGFzaCIsImFkZFBhdGhQcmVmaXgiLCJhZGRQYXRoU3VmZml4IiwiYWRkTG9jYWxlIiwiZm9ybWF0TmV4dFBhdGhuYW1lSW5mbyIsImluZm8iLCJwYXRobmFtZSIsImxvY2FsZSIsImJ1aWxkSWQiLCJ1bmRlZmluZWQiLCJkZWZhdWx0TG9jYWxlIiwiaWdub3JlUHJlZml4IiwidHJhaWxpbmdTbGFzaCIsImJhc2VQYXRoIiwiZW5kc1dpdGgiXSwibWFwcGluZ3MiOiI7OztBQUNBLFNBQVNBLG1CQUFtQixRQUFRLDBCQUF5QjtBQUM3RCxTQUFTQyxhQUFhLFFBQVEsb0JBQW1CO0FBQ2pELFNBQVNDLGFBQWEsUUFBUSxvQkFBbUI7QUFDakQsU0FBU0MsU0FBUyxRQUFRLGVBQWM7Ozs7O0FBT2pDLFNBQVNDLHVCQUF1QkMsSUFBa0I7SUFDdkQsSUFBSUMsd01BQVdILFlBQUFBLEVBQ2JFLEtBQUtDLFFBQVEsRUFDYkQsS0FBS0UsTUFBTSxFQUNYRixLQUFLRyxPQUFPLEdBQUdDLFlBQVlKLEtBQUtLLGFBQWEsRUFDN0NMLEtBQUtNLFlBQVk7SUFHbkIsSUFBSU4sS0FBS0csT0FBTyxJQUFJLENBQUNILEtBQUtPLGFBQWEsRUFBRTtRQUN2Q04sc05BQVdOLHNCQUFBQSxFQUFvQk07SUFDakM7SUFFQSxJQUFJRCxLQUFLRyxPQUFPLEVBQUU7UUFDaEJGLGdOQUFXSixnQkFBQUEsdU1BQ1RELGdCQUFBQSxFQUFjSyxVQUFXLGlCQUFjRCxLQUFLRyxPQUFPLEdBQ25ESCxLQUFLQyxRQUFRLEtBQUssTUFBTSxlQUFlO0lBRTNDO0lBRUFBLGdOQUFXTCxnQkFBQUEsRUFBY0ssVUFBVUQsS0FBS1EsUUFBUTtJQUNoRCxPQUFPLENBQUNSLEtBQUtHLE9BQU8sSUFBSUgsS0FBS08sYUFBYSxHQUN0QyxDQUFDTixTQUFTUSxRQUFRLENBQUMsNE1BQ2pCWixnQkFBQUEsRUFBY0ksVUFBVSxPQUN4QkEsc05BQ0ZOLHNCQUFBQSxFQUFvQk07QUFDMUIiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTA4NzUsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NyYy9zaGFyZWQvbGliL2dldC1ob3N0bmFtZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IE91dGdvaW5nSHR0cEhlYWRlcnMgfSBmcm9tICdodHRwJ1xuXG4vKipcbiAqIFRha2VzIGFuIG9iamVjdCB3aXRoIGEgaG9zdG5hbWUgcHJvcGVydHkgKGxpa2UgYSBwYXJzZWQgVVJMKSBhbmQgc29tZVxuICogaGVhZGVycyB0aGF0IG1heSBjb250YWluIEhvc3QgYW5kIHJldHVybnMgdGhlIHByZWZlcnJlZCBob3N0bmFtZS5cbiAqIEBwYXJhbSBwYXJzZWQgQW4gb2JqZWN0IGNvbnRhaW5pbmcgYSBob3N0bmFtZSBwcm9wZXJ0eS5cbiAqIEBwYXJhbSBoZWFkZXJzIEEgZGljdGlvbmFyeSB3aXRoIGhlYWRlcnMgY29udGFpbmluZyBhIGBob3N0YC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEhvc3RuYW1lKFxuICBwYXJzZWQ6IHsgaG9zdG5hbWU/OiBzdHJpbmcgfCBudWxsIH0sXG4gIGhlYWRlcnM/OiBPdXRnb2luZ0h0dHBIZWFkZXJzXG4pOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAvLyBHZXQgdGhlIGhvc3RuYW1lIGZyb20gdGhlIGhlYWRlcnMgaWYgaXQgZXhpc3RzLCBvdGhlcndpc2UgdXNlIHRoZSBwYXJzZWRcbiAgLy8gaG9zdG5hbWUuXG4gIGxldCBob3N0bmFtZTogc3RyaW5nXG4gIGlmIChoZWFkZXJzPy5ob3N0ICYmICFBcnJheS5pc0FycmF5KGhlYWRlcnMuaG9zdCkpIHtcbiAgICBob3N0bmFtZSA9IGhlYWRlcnMuaG9zdC50b1N0cmluZygpLnNwbGl0KCc6JywgMSlbMF1cbiAgfSBlbHNlIGlmIChwYXJzZWQuaG9zdG5hbWUpIHtcbiAgICBob3N0bmFtZSA9IHBhcnNlZC5ob3N0bmFtZVxuICB9IGVsc2UgcmV0dXJuXG5cbiAgcmV0dXJuIGhvc3RuYW1lLnRvTG93ZXJDYXNlKClcbn1cbiJdLCJuYW1lcyI6WyJnZXRIb3N0bmFtZSIsInBhcnNlZCIsImhlYWRlcnMiLCJob3N0bmFtZSIsImhvc3QiLCJBcnJheSIsImlzQXJyYXkiLCJ0b1N0cmluZyIsInNwbGl0IiwidG9Mb3dlckNhc2UiXSwibWFwcGluZ3MiOiJBQUVBOzs7OztDQUtDLEdBQ0Q7OztBQUFPLFNBQVNBLFlBQ2RDLE1BQW9DLEVBQ3BDQyxPQUE2QjtJQUU3QiwyRUFBMkU7SUFDM0UsWUFBWTtJQUNaLElBQUlDO0lBQ0osSUFBSUQsQ0FBQUEsV0FBQUEsT0FBQUEsS0FBQUEsSUFBQUEsUUFBU0UsSUFBSSxLQUFJLENBQUNDLE1BQU1DLE9BQU8sQ0FBQ0osUUFBUUUsSUFBSSxHQUFHO1FBQ2pERCxXQUFXRCxRQUFRRSxJQUFJLENBQUNHLFFBQVEsR0FBR0MsS0FBSyxDQUFDLEtBQUssRUFBRSxDQUFDLEVBQUU7SUFDckQsT0FBTyxJQUFJUCxPQUFPRSxRQUFRLEVBQUU7UUFDMUJBLFdBQVdGLE9BQU9FLFFBQVE7SUFDNUIsT0FBTztJQUVQLE9BQU9BLFNBQVNNLFdBQVc7QUFDN0IiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTA4OTgsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NyYy9zaGFyZWQvbGliL2kxOG4vbm9ybWFsaXplLWxvY2FsZS1wYXRoLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBpbnRlcmZhY2UgUGF0aExvY2FsZSB7XG4gIGRldGVjdGVkTG9jYWxlPzogc3RyaW5nXG4gIHBhdGhuYW1lOiBzdHJpbmdcbn1cblxuLyoqXG4gKiBBIGNhY2hlIG9mIGxvd2VyY2FzZWQgbG9jYWxlcyBmb3IgZWFjaCBsaXN0IG9mIGxvY2FsZXMuIFRoaXMgaXMgc3RvcmVkIGFzIGFcbiAqIFdlYWtNYXAgc28gaWYgdGhlIGxvY2FsZXMgYXJlIGdhcmJhZ2UgY29sbGVjdGVkLCB0aGUgY2FjaGUgZW50cnkgd2lsbCBiZVxuICogcmVtb3ZlZCBhcyB3ZWxsLlxuICovXG5jb25zdCBjYWNoZSA9IG5ldyBXZWFrTWFwPHJlYWRvbmx5IHN0cmluZ1tdLCByZWFkb25seSBzdHJpbmdbXT4oKVxuXG4vKipcbiAqIEZvciBhIHBhdGhuYW1lIHRoYXQgbWF5IGluY2x1ZGUgYSBsb2NhbGUgZnJvbSBhIGxpc3Qgb2YgbG9jYWxlcywgaXRcbiAqIHJlbW92ZXMgdGhlIGxvY2FsZSBmcm9tIHRoZSBwYXRobmFtZSByZXR1cm5pbmcgaXQgYWxvbmdzaWRlIHdpdGggdGhlXG4gKiBkZXRlY3RlZCBsb2NhbGUuXG4gKlxuICogQHBhcmFtIHBhdGhuYW1lIEEgcGF0aG5hbWUgdGhhdCBtYXkgaW5jbHVkZSBhIGxvY2FsZS5cbiAqIEBwYXJhbSBsb2NhbGVzIEEgbGlzdCBvZiBsb2NhbGVzLlxuICogQHJldHVybnMgVGhlIGRldGVjdGVkIGxvY2FsZSBhbmQgcGF0aG5hbWUgd2l0aG91dCBsb2NhbGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZUxvY2FsZVBhdGgoXG4gIHBhdGhuYW1lOiBzdHJpbmcsXG4gIGxvY2FsZXM/OiByZWFkb25seSBzdHJpbmdbXVxuKTogUGF0aExvY2FsZSB7XG4gIC8vIElmIGxvY2FsZXMgaXMgdW5kZWZpbmVkLCByZXR1cm4gdGhlIHBhdGhuYW1lIGFzIGlzLlxuICBpZiAoIWxvY2FsZXMpIHJldHVybiB7IHBhdGhuYW1lIH1cblxuICAvLyBHZXQgdGhlIGNhY2hlZCBsb3dlcmNhc2VkIGxvY2FsZXMgb3IgY3JlYXRlIGEgbmV3IGNhY2hlIGVudHJ5LlxuICBsZXQgbG93ZXJjYXNlZExvY2FsZXMgPSBjYWNoZS5nZXQobG9jYWxlcylcbiAgaWYgKCFsb3dlcmNhc2VkTG9jYWxlcykge1xuICAgIGxvd2VyY2FzZWRMb2NhbGVzID0gbG9jYWxlcy5tYXAoKGxvY2FsZSkgPT4gbG9jYWxlLnRvTG93ZXJDYXNlKCkpXG4gICAgY2FjaGUuc2V0KGxvY2FsZXMsIGxvd2VyY2FzZWRMb2NhbGVzKVxuICB9XG5cbiAgbGV0IGRldGVjdGVkTG9jYWxlOiBzdHJpbmcgfCB1bmRlZmluZWRcblxuICAvLyBUaGUgZmlyc3Qgc2VnbWVudCB3aWxsIGJlIGVtcHR5LCBiZWNhdXNlIGl0IGhhcyBhIGxlYWRpbmcgYC9gLiBJZlxuICAvLyB0aGVyZSBpcyBubyBmdXJ0aGVyIHNlZ21lbnQsIHRoZXJlIGlzIG5vIGxvY2FsZSAob3IgaXQncyB0aGUgZGVmYXVsdCkuXG4gIGNvbnN0IHNlZ21lbnRzID0gcGF0aG5hbWUuc3BsaXQoJy8nLCAyKVxuXG4gIC8vIElmIHRoZXJlJ3Mgbm8gc2Vjb25kIHNlZ21lbnQgKGllLCB0aGUgcGF0aG5hbWUgaXMganVzdCBgL2ApLCB0aGVyZSdzIG5vXG4gIC8vIGxvY2FsZS5cbiAgaWYgKCFzZWdtZW50c1sxXSkgcmV0dXJuIHsgcGF0aG5hbWUgfVxuXG4gIC8vIFRoZSBzZWNvbmQgc2VnbWVudCB3aWxsIGNvbnRhaW4gdGhlIGxvY2FsZSBwYXJ0IGlmIGFueS5cbiAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnRzWzFdLnRvTG93ZXJDYXNlKClcblxuICAvLyBTZWUgaWYgdGhlIHNlZ21lbnQgbWF0Y2hlcyBvbmUgb2YgdGhlIGxvY2FsZXMuIElmIGl0IGRvZXNuJ3QsIHRoZXJlIGlzXG4gIC8vIG5vIGxvY2FsZSAob3IgaXQncyB0aGUgZGVmYXVsdCkuXG4gIGNvbnN0IGluZGV4ID0gbG93ZXJjYXNlZExvY2FsZXMuaW5kZXhPZihzZWdtZW50KVxuICBpZiAoaW5kZXggPCAwKSByZXR1cm4geyBwYXRobmFtZSB9XG5cbiAgLy8gUmV0dXJuIHRoZSBjYXNlLXNlbnNpdGl2ZSBsb2NhbGUuXG4gIGRldGVjdGVkTG9jYWxlID0gbG9jYWxlc1tpbmRleF1cblxuICAvLyBSZW1vdmUgdGhlIGAvJHtsb2NhbGV9YCBwYXJ0IG9mIHRoZSBwYXRobmFtZS5cbiAgcGF0aG5hbWUgPSBwYXRobmFtZS5zbGljZShkZXRlY3RlZExvY2FsZS5sZW5ndGggKyAxKSB8fCAnLydcblxuICByZXR1cm4geyBwYXRobmFtZSwgZGV0ZWN0ZWRMb2NhbGUgfVxufVxuIl0sIm5hbWVzIjpbImNhY2hlIiwiV2Vha01hcCIsIm5vcm1hbGl6ZUxvY2FsZVBhdGgiLCJwYXRobmFtZSIsImxvY2FsZXMiLCJsb3dlcmNhc2VkTG9jYWxlcyIsImdldCIsIm1hcCIsImxvY2FsZSIsInRvTG93ZXJDYXNlIiwic2V0IiwiZGV0ZWN0ZWRMb2NhbGUiLCJzZWdtZW50cyIsInNwbGl0Iiwic2VnbWVudCIsImluZGV4IiwiaW5kZXhPZiIsInNsaWNlIiwibGVuZ3RoIl0sIm1hcHBpbmdzIjoiQUFLQTs7OztDQUlDOzs7QUFDRCxNQUFNQSxRQUFRLElBQUlDO0FBV1gsU0FBU0Msb0JBQ2RDLFFBQWdCLEVBQ2hCQyxPQUEyQjtJQUUzQixzREFBc0Q7SUFDdEQsSUFBSSxDQUFDQSxTQUFTLE9BQU87UUFBRUQ7SUFBUztJQUVoQyxpRUFBaUU7SUFDakUsSUFBSUUsb0JBQW9CTCxNQUFNTSxHQUFHLENBQUNGO0lBQ2xDLElBQUksQ0FBQ0MsbUJBQW1CO1FBQ3RCQSxvQkFBb0JELFFBQVFHLEdBQUcsQ0FBQyxDQUFDQyxTQUFXQSxPQUFPQyxXQUFXO1FBQzlEVCxNQUFNVSxHQUFHLENBQUNOLFNBQVNDO0lBQ3JCO0lBRUEsSUFBSU07SUFFSixvRUFBb0U7SUFDcEUseUVBQXlFO0lBQ3pFLE1BQU1DLFdBQVdULFNBQVNVLEtBQUssQ0FBQyxLQUFLO0lBRXJDLDBFQUEwRTtJQUMxRSxVQUFVO0lBQ1YsSUFBSSxDQUFDRCxRQUFRLENBQUMsRUFBRSxFQUFFLE9BQU87UUFBRVQ7SUFBUztJQUVwQywwREFBMEQ7SUFDMUQsTUFBTVcsVUFBVUYsUUFBUSxDQUFDLEVBQUUsQ0FBQ0gsV0FBVztJQUV2Qyx5RUFBeUU7SUFDekUsbUNBQW1DO0lBQ25DLE1BQU1NLFFBQVFWLGtCQUFrQlcsT0FBTyxDQUFDRjtJQUN4QyxJQUFJQyxRQUFRLEdBQUcsT0FBTztRQUFFWjtJQUFTO0lBRWpDLG9DQUFvQztJQUNwQ1EsaUJBQWlCUCxPQUFPLENBQUNXLE1BQU07SUFFL0IsZ0RBQWdEO0lBQ2hEWixXQUFXQSxTQUFTYyxLQUFLLENBQUNOLGVBQWVPLE1BQU0sR0FBRyxNQUFNO0lBRXhELE9BQU87UUFBRWY7UUFBVVE7SUFBZTtBQUNwQyIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxMDk0NywgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3JlbW92ZS1wYXRoLXByZWZpeC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwYXRoSGFzUHJlZml4IH0gZnJvbSAnLi9wYXRoLWhhcy1wcmVmaXgnXG5cbi8qKlxuICogR2l2ZW4gYSBwYXRoIGFuZCBhIHByZWZpeCBpdCB3aWxsIHJlbW92ZSB0aGUgcHJlZml4IHdoZW4gaXQgZXhpc3RzIGluIHRoZVxuICogZ2l2ZW4gcGF0aC4gSXQgZW5zdXJlcyBpdCBtYXRjaGVzIGV4YWN0bHkgd2l0aG91dCBjb250YWluaW5nIGV4dHJhIGNoYXJzXG4gKiBhbmQgaWYgdGhlIHByZWZpeCBpcyBub3QgdGhlcmUgaXQgd2lsbCBiZSBub29wLlxuICpcbiAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIHRvIHJlbW92ZSB0aGUgcHJlZml4IGZyb20uXG4gKiBAcGFyYW0gcHJlZml4IFRoZSBwcmVmaXggdG8gYmUgcmVtb3ZlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVBhdGhQcmVmaXgocGF0aDogc3RyaW5nLCBwcmVmaXg6IHN0cmluZyk6IHN0cmluZyB7XG4gIC8vIElmIHRoZSBwYXRoIGRvZXNuJ3Qgc3RhcnQgd2l0aCB0aGUgcHJlZml4IHdlIGNhbiByZXR1cm4gaXQgYXMgaXMuIFRoaXNcbiAgLy8gcHJvdGVjdHMgdXMgZnJvbSBzaXR1YXRpb25zIHdoZXJlIHRoZSBwcmVmaXggaXMgYSBzdWJzdHJpbmcgb2YgdGhlIHBhdGhcbiAgLy8gcHJlZml4IHN1Y2ggYXM6XG4gIC8vXG4gIC8vIEZvciBwcmVmaXg6IC9ibG9nXG4gIC8vXG4gIC8vICAgL2Jsb2cgLT4gdHJ1ZVxuICAvLyAgIC9ibG9nLyAtPiB0cnVlXG4gIC8vICAgL2Jsb2cvMSAtPiB0cnVlXG4gIC8vICAgL2Jsb2dnaW5nIC0+IGZhbHNlXG4gIC8vICAgL2Jsb2dnaW5nLyAtPiBmYWxzZVxuICAvLyAgIC9ibG9nZ2luZy8xIC0+IGZhbHNlXG4gIGlmICghcGF0aEhhc1ByZWZpeChwYXRoLCBwcmVmaXgpKSB7XG4gICAgcmV0dXJuIHBhdGhcbiAgfVxuXG4gIC8vIFJlbW92ZSB0aGUgcHJlZml4IGZyb20gdGhlIHBhdGggdmlhIHNsaWNpbmcuXG4gIGNvbnN0IHdpdGhvdXRQcmVmaXggPSBwYXRoLnNsaWNlKHByZWZpeC5sZW5ndGgpXG5cbiAgLy8gSWYgdGhlIHBhdGggd2l0aG91dCB0aGUgcHJlZml4IHN0YXJ0cyB3aXRoIGEgYC9gIHdlIGNhbiByZXR1cm4gaXQgYXMgaXMuXG4gIGlmICh3aXRob3V0UHJlZml4LnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgIHJldHVybiB3aXRob3V0UHJlZml4XG4gIH1cblxuICAvLyBJZiB0aGUgcGF0aCB3aXRob3V0IHRoZSBwcmVmaXggZG9lc24ndCBzdGFydCB3aXRoIGEgYC9gIHdlIG5lZWQgdG8gYWRkIGl0XG4gIC8vIGJhY2sgdG8gdGhlIHBhdGggdG8gbWFrZSBzdXJlIGl0J3MgYSB2YWxpZCBwYXRoLlxuICByZXR1cm4gYC8ke3dpdGhvdXRQcmVmaXh9YFxufVxuIl0sIm5hbWVzIjpbInBhdGhIYXNQcmVmaXgiLCJyZW1vdmVQYXRoUHJlZml4IiwicGF0aCIsInByZWZpeCIsIndpdGhvdXRQcmVmaXgiLCJzbGljZSIsImxlbmd0aCIsInN0YXJ0c1dpdGgiXSwibWFwcGluZ3MiOiI7OztBQUFBLFNBQVNBLGFBQWEsUUFBUSxvQkFBbUI7O0FBVTFDLFNBQVNDLGlCQUFpQkMsSUFBWSxFQUFFQyxNQUFjO0lBQzNELHlFQUF5RTtJQUN6RSwwRUFBMEU7SUFDMUUsa0JBQWtCO0lBQ2xCLEVBQUU7SUFDRixvQkFBb0I7SUFDcEIsRUFBRTtJQUNGLGtCQUFrQjtJQUNsQixtQkFBbUI7SUFDbkIsb0JBQW9CO0lBQ3BCLHVCQUF1QjtJQUN2Qix3QkFBd0I7SUFDeEIseUJBQXlCO0lBQ3pCLElBQUksc01BQUNILGdCQUFBQSxFQUFjRSxNQUFNQyxTQUFTO1FBQ2hDLE9BQU9EO0lBQ1Q7SUFFQSwrQ0FBK0M7SUFDL0MsTUFBTUUsZ0JBQWdCRixLQUFLRyxLQUFLLENBQUNGLE9BQU9HLE1BQU07SUFFOUMsMkVBQTJFO0lBQzNFLElBQUlGLGNBQWNHLFVBQVUsQ0FBQyxNQUFNO1FBQ2pDLE9BQU9IO0lBQ1Q7SUFFQSw0RUFBNEU7SUFDNUUsbURBQW1EO0lBQ25ELE9BQVEsTUFBR0E7QUFDYiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxMDk4MiwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2dldC1uZXh0LXBhdGhuYW1lLWluZm8udHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbm9ybWFsaXplTG9jYWxlUGF0aCB9IGZyb20gJy4uLy4uL2kxOG4vbm9ybWFsaXplLWxvY2FsZS1wYXRoJ1xuaW1wb3J0IHsgcmVtb3ZlUGF0aFByZWZpeCB9IGZyb20gJy4vcmVtb3ZlLXBhdGgtcHJlZml4J1xuaW1wb3J0IHsgcGF0aEhhc1ByZWZpeCB9IGZyb20gJy4vcGF0aC1oYXMtcHJlZml4J1xuaW1wb3J0IHR5cGUgeyBJMThOUHJvdmlkZXIgfSBmcm9tICcuLi8uLi8uLi8uLi9zZXJ2ZXIvbGliL2kxOG4tcHJvdmlkZXInXG5cbmV4cG9ydCBpbnRlcmZhY2UgTmV4dFBhdGhuYW1lSW5mbyB7XG4gIC8qKlxuICAgKiBUaGUgYmFzZSBwYXRoIGluIGNhc2UgdGhlIHBhdGhuYW1lIGluY2x1ZGVkIGl0LlxuICAgKi9cbiAgYmFzZVBhdGg/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFRoZSBidWlsZElkIGZvciB3aGVuIHRoZSBwYXJzZWQgVVJMIGlzIGEgZGF0YSBVUkwuIFBhcnNpbmcgaXQgY2FuIGJlXG4gICAqIGRpc2FibGVkIHdpdGggdGhlIGBwYXJzZURhdGFgIG9wdGlvbi5cbiAgICovXG4gIGJ1aWxkSWQ/OiBzdHJpbmdcbiAgLyoqXG4gICAqIElmIHRoZXJlIHdhcyBhIGxvY2FsZSBpbiB0aGUgcGF0aG5hbWUsIHRoaXMgd2lsbCBob2xkIGl0cyB2YWx1ZS5cbiAgICovXG4gIGxvY2FsZT86IHN0cmluZ1xuICAvKipcbiAgICogVGhlIHByb2Nlc3NlZCBwYXRobmFtZSB3aXRob3V0IGEgYmFzZSBwYXRoLCBsb2NhbGUsIG9yIGRhdGEgVVJMIGVsZW1lbnRzXG4gICAqIHdoZW4gcGFyc2luZyBpdCBpcyBlbmFibGVkLlxuICAgKi9cbiAgcGF0aG5hbWU6IHN0cmluZ1xuICAvKipcbiAgICogQSBib29sZWFuIHRlbGxpbmcgaWYgdGhlIHBhdGhuYW1lIGhhZCBhIHRyYWlsaW5nU2xhc2guIFRoaXMgY2FuIGJlIG9ubHlcbiAgICogdHJ1ZSBpZiB0cmFpbGluZ1NsYXNoIGlzIGVuYWJsZWQuXG4gICAqL1xuICB0cmFpbGluZ1NsYXNoPzogYm9vbGVhblxufVxuXG5pbnRlcmZhY2UgT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBXaGVuIHBhc3NlZCB0byB0cnVlLCB0aGlzIGZ1bmN0aW9uIHdpbGwgYWxzbyBwYXJzZSBOZXh0anMgZGF0YSBVUkxzLlxuICAgKi9cbiAgcGFyc2VEYXRhPzogYm9vbGVhblxuICAvKipcbiAgICogQSBwYXJ0aWFsIG9mIHRoZSBOZXh0LmpzIGNvbmZpZ3VyYXRpb24gdG8gcGFyc2UgdGhlIFVSTC5cbiAgICovXG4gIG5leHRDb25maWc/OiB7XG4gICAgYmFzZVBhdGg/OiBzdHJpbmdcbiAgICBpMThuPzogeyBsb2NhbGVzPzogcmVhZG9ubHkgc3RyaW5nW10gfSB8IG51bGxcbiAgICB0cmFpbGluZ1NsYXNoPzogYm9vbGVhblxuICB9XG5cbiAgLyoqXG4gICAqIElmIHByb3ZpZGVkLCB0aGlzIG5vcm1hbGl6ZXIgd2lsbCBiZSB1c2VkIHRvIGRldGVjdCB0aGUgbG9jYWxlIGluc3RlYWQgb2ZcbiAgICogdGhlIGRlZmF1bHQgbG9jYWxlIGRldGVjdGlvbi5cbiAgICovXG4gIGkxOG5Qcm92aWRlcj86IEkxOE5Qcm92aWRlclxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TmV4dFBhdGhuYW1lSW5mbyhcbiAgcGF0aG5hbWU6IHN0cmluZyxcbiAgb3B0aW9uczogT3B0aW9uc1xuKTogTmV4dFBhdGhuYW1lSW5mbyB7XG4gIGNvbnN0IHsgYmFzZVBhdGgsIGkxOG4sIHRyYWlsaW5nU2xhc2ggfSA9IG9wdGlvbnMubmV4dENvbmZpZyA/PyB7fVxuICBjb25zdCBpbmZvOiBOZXh0UGF0aG5hbWVJbmZvID0ge1xuICAgIHBhdGhuYW1lLFxuICAgIHRyYWlsaW5nU2xhc2g6IHBhdGhuYW1lICE9PSAnLycgPyBwYXRobmFtZS5lbmRzV2l0aCgnLycpIDogdHJhaWxpbmdTbGFzaCxcbiAgfVxuXG4gIGlmIChiYXNlUGF0aCAmJiBwYXRoSGFzUHJlZml4KGluZm8ucGF0aG5hbWUsIGJhc2VQYXRoKSkge1xuICAgIGluZm8ucGF0aG5hbWUgPSByZW1vdmVQYXRoUHJlZml4KGluZm8ucGF0aG5hbWUsIGJhc2VQYXRoKVxuICAgIGluZm8uYmFzZVBhdGggPSBiYXNlUGF0aFxuICB9XG4gIGxldCBwYXRobmFtZU5vRGF0YVByZWZpeCA9IGluZm8ucGF0aG5hbWVcblxuICBpZiAoXG4gICAgaW5mby5wYXRobmFtZS5zdGFydHNXaXRoKCcvX25leHQvZGF0YS8nKSAmJlxuICAgIGluZm8ucGF0aG5hbWUuZW5kc1dpdGgoJy5qc29uJylcbiAgKSB7XG4gICAgY29uc3QgcGF0aHMgPSBpbmZvLnBhdGhuYW1lXG4gICAgICAucmVwbGFjZSgvXlxcL19uZXh0XFwvZGF0YVxcLy8sICcnKVxuICAgICAgLnJlcGxhY2UoL1xcLmpzb24kLywgJycpXG4gICAgICAuc3BsaXQoJy8nKVxuXG4gICAgY29uc3QgYnVpbGRJZCA9IHBhdGhzWzBdXG4gICAgaW5mby5idWlsZElkID0gYnVpbGRJZFxuICAgIHBhdGhuYW1lTm9EYXRhUHJlZml4ID1cbiAgICAgIHBhdGhzWzFdICE9PSAnaW5kZXgnID8gYC8ke3BhdGhzLnNsaWNlKDEpLmpvaW4oJy8nKX1gIDogJy8nXG5cbiAgICAvLyB1cGRhdGUgcGF0aG5hbWUgd2l0aCBub3JtYWxpemVkIGlmIGVuYWJsZWQgYWx0aG91Z2hcbiAgICAvLyB3ZSB1c2Ugbm9ybWFsaXplZCB0byBwb3B1bGF0ZSBsb2NhbGUgaW5mbyBzdGlsbFxuICAgIGlmIChvcHRpb25zLnBhcnNlRGF0YSA9PT0gdHJ1ZSkge1xuICAgICAgaW5mby5wYXRobmFtZSA9IHBhdGhuYW1lTm9EYXRhUHJlZml4XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgcHJvdmlkZWQsIHVzZSB0aGUgbG9jYWxlIHJvdXRlIG5vcm1hbGl6ZXIgdG8gZGV0ZWN0IHRoZSBsb2NhbGUgaW5zdGVhZFxuICAvLyBvZiB0aGUgZnVuY3Rpb24gYmVsb3cuXG4gIGlmIChpMThuKSB7XG4gICAgbGV0IHJlc3VsdCA9IG9wdGlvbnMuaTE4blByb3ZpZGVyXG4gICAgICA/IG9wdGlvbnMuaTE4blByb3ZpZGVyLmFuYWx5emUoaW5mby5wYXRobmFtZSlcbiAgICAgIDogbm9ybWFsaXplTG9jYWxlUGF0aChpbmZvLnBhdGhuYW1lLCBpMThuLmxvY2FsZXMpXG5cbiAgICBpbmZvLmxvY2FsZSA9IHJlc3VsdC5kZXRlY3RlZExvY2FsZVxuICAgIGluZm8ucGF0aG5hbWUgPSByZXN1bHQucGF0aG5hbWUgPz8gaW5mby5wYXRobmFtZVxuXG4gICAgaWYgKCFyZXN1bHQuZGV0ZWN0ZWRMb2NhbGUgJiYgaW5mby5idWlsZElkKSB7XG4gICAgICByZXN1bHQgPSBvcHRpb25zLmkxOG5Qcm92aWRlclxuICAgICAgICA/IG9wdGlvbnMuaTE4blByb3ZpZGVyLmFuYWx5emUocGF0aG5hbWVOb0RhdGFQcmVmaXgpXG4gICAgICAgIDogbm9ybWFsaXplTG9jYWxlUGF0aChwYXRobmFtZU5vRGF0YVByZWZpeCwgaTE4bi5sb2NhbGVzKVxuXG4gICAgICBpZiAocmVzdWx0LmRldGVjdGVkTG9jYWxlKSB7XG4gICAgICAgIGluZm8ubG9jYWxlID0gcmVzdWx0LmRldGVjdGVkTG9jYWxlXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBpbmZvXG59XG4iXSwibmFtZXMiOlsibm9ybWFsaXplTG9jYWxlUGF0aCIsInJlbW92ZVBhdGhQcmVmaXgiLCJwYXRoSGFzUHJlZml4IiwiZ2V0TmV4dFBhdGhuYW1lSW5mbyIsInBhdGhuYW1lIiwib3B0aW9ucyIsImJhc2VQYXRoIiwiaTE4biIsInRyYWlsaW5nU2xhc2giLCJuZXh0Q29uZmlnIiwiaW5mbyIsImVuZHNXaXRoIiwicGF0aG5hbWVOb0RhdGFQcmVmaXgiLCJzdGFydHNXaXRoIiwicGF0aHMiLCJyZXBsYWNlIiwic3BsaXQiLCJidWlsZElkIiwic2xpY2UiLCJqb2luIiwicGFyc2VEYXRhIiwicmVzdWx0IiwiaTE4blByb3ZpZGVyIiwiYW5hbHl6ZSIsImxvY2FsZXMiLCJsb2NhbGUiLCJkZXRlY3RlZExvY2FsZSJdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsU0FBU0EsbUJBQW1CLFFBQVEsbUNBQWtDO0FBQ3RFLFNBQVNDLGdCQUFnQixRQUFRLHVCQUFzQjtBQUN2RCxTQUFTQyxhQUFhLFFBQVEsb0JBQW1COzs7O0FBa0QxQyxTQUFTQyxvQkFDZEMsUUFBZ0IsRUFDaEJDLE9BQWdCO1FBRTBCQTtJQUExQyxNQUFNLEVBQUVDLFFBQVEsRUFBRUMsSUFBSSxFQUFFQyxhQUFhLEVBQUUsR0FBR0gsQ0FBQUEsc0JBQUFBLFFBQVFJLFVBQVUsS0FBQSxPQUFsQkosc0JBQXNCLENBQUM7SUFDakUsTUFBTUssT0FBeUI7UUFDN0JOO1FBQ0FJLGVBQWVKLGFBQWEsTUFBTUEsU0FBU08sUUFBUSxDQUFDLE9BQU9IO0lBQzdEO0lBRUEsSUFBSUYsWUFBWUoscU5BQUFBLEVBQWNRLEtBQUtOLFFBQVEsRUFBRUUsV0FBVztRQUN0REksS0FBS04sUUFBUSxHQUFHSCwyTkFBQUEsRUFBaUJTLEtBQUtOLFFBQVEsRUFBRUU7UUFDaERJLEtBQUtKLFFBQVEsR0FBR0E7SUFDbEI7SUFDQSxJQUFJTSx1QkFBdUJGLEtBQUtOLFFBQVE7SUFFeEMsSUFDRU0sS0FBS04sUUFBUSxDQUFDUyxVQUFVLENBQUMsbUJBQ3pCSCxLQUFLTixRQUFRLENBQUNPLFFBQVEsQ0FBQyxVQUN2QjtRQUNBLE1BQU1HLFFBQVFKLEtBQUtOLFFBQVEsQ0FDeEJXLE9BQU8sQ0FBQyxvQkFBb0IsSUFDNUJBLE9BQU8sQ0FBQyxXQUFXLElBQ25CQyxLQUFLLENBQUM7UUFFVCxNQUFNQyxVQUFVSCxLQUFLLENBQUMsRUFBRTtRQUN4QkosS0FBS08sT0FBTyxHQUFHQTtRQUNmTCx1QkFDRUUsS0FBSyxDQUFDLEVBQUUsS0FBSyxVQUFXLE1BQUdBLE1BQU1JLEtBQUssQ0FBQyxHQUFHQyxJQUFJLENBQUMsT0FBUztRQUUxRCxzREFBc0Q7UUFDdEQsa0RBQWtEO1FBQ2xELElBQUlkLFFBQVFlLFNBQVMsS0FBSyxNQUFNO1lBQzlCVixLQUFLTixRQUFRLEdBQUdRO1FBQ2xCO0lBQ0Y7SUFFQSw0RUFBNEU7SUFDNUUseUJBQXlCO0lBQ3pCLElBQUlMLE1BQU07UUFDUixJQUFJYyxTQUFTaEIsUUFBUWlCLFlBQVksR0FDN0JqQixRQUFRaUIsWUFBWSxDQUFDQyxPQUFPLENBQUNiLEtBQUtOLFFBQVEsb01BQzFDSixzQkFBQUEsRUFBb0JVLEtBQUtOLFFBQVEsRUFBRUcsS0FBS2lCLE9BQU87UUFFbkRkLEtBQUtlLE1BQU0sR0FBR0osT0FBT0ssY0FBYztZQUNuQkw7UUFBaEJYLEtBQUtOLFFBQVEsR0FBR2lCLENBQUFBLG1CQUFBQSxPQUFPakIsUUFBUSxLQUFBLE9BQWZpQixtQkFBbUJYLEtBQUtOLFFBQVE7UUFFaEQsSUFBSSxDQUFDaUIsT0FBT0ssY0FBYyxJQUFJaEIsS0FBS08sT0FBTyxFQUFFO1lBQzFDSSxTQUFTaEIsUUFBUWlCLFlBQVksR0FDekJqQixRQUFRaUIsWUFBWSxDQUFDQyxPQUFPLENBQUNYLHdOQUM3Qlosc0JBQUFBLEVBQW9CWSxzQkFBc0JMLEtBQUtpQixPQUFPO1lBRTFELElBQUlILE9BQU9LLGNBQWMsRUFBRTtnQkFDekJoQixLQUFLZSxNQUFNLEdBQUdKLE9BQU9LLGNBQWM7WUFDckM7UUFDRjtJQUNGO0lBQ0EsT0FBT2hCO0FBQ1QiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTEwMzQsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NyYy9zZXJ2ZXIvd2ViL25leHQtdXJsLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgT3V0Z29pbmdIdHRwSGVhZGVycyB9IGZyb20gJ2h0dHAnXG5pbXBvcnQgdHlwZSB7IERvbWFpbkxvY2FsZSwgSTE4TkNvbmZpZyB9IGZyb20gJy4uL2NvbmZpZy1zaGFyZWQnXG5pbXBvcnQgdHlwZSB7IEkxOE5Qcm92aWRlciB9IGZyb20gJy4uL2xpYi9pMThuLXByb3ZpZGVyJ1xuXG5pbXBvcnQgeyBkZXRlY3REb21haW5Mb2NhbGUgfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL2kxOG4vZGV0ZWN0LWRvbWFpbi1sb2NhbGUnXG5pbXBvcnQgeyBmb3JtYXROZXh0UGF0aG5hbWVJbmZvIH0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvZm9ybWF0LW5leHQtcGF0aG5hbWUtaW5mbydcbmltcG9ydCB7IGdldEhvc3RuYW1lIH0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi9nZXQtaG9zdG5hbWUnXG5pbXBvcnQgeyBnZXROZXh0UGF0aG5hbWVJbmZvIH0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvZ2V0LW5leHQtcGF0aG5hbWUtaW5mbydcblxuaW50ZXJmYWNlIE9wdGlvbnMge1xuICBiYXNlPzogc3RyaW5nIHwgVVJMXG4gIGhlYWRlcnM/OiBPdXRnb2luZ0h0dHBIZWFkZXJzXG4gIGZvcmNlTG9jYWxlPzogYm9vbGVhblxuICBuZXh0Q29uZmlnPzoge1xuICAgIGJhc2VQYXRoPzogc3RyaW5nXG4gICAgaTE4bj86IEkxOE5Db25maWcgfCBudWxsXG4gICAgdHJhaWxpbmdTbGFzaD86IGJvb2xlYW5cbiAgfVxuICBpMThuUHJvdmlkZXI/OiBJMThOUHJvdmlkZXJcbn1cblxuY29uc3QgUkVHRVhfTE9DQUxIT1NUX0hPU1ROQU1FID1cbiAgLyg/IV5odHRwcz86XFwvXFwvKSgxMjcoPzpcXC4oPzoyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT8pKXszfXxcXFs6OjFcXF18bG9jYWxob3N0KS9cblxuZnVuY3Rpb24gcGFyc2VVUkwodXJsOiBzdHJpbmcgfCBVUkwsIGJhc2U/OiBzdHJpbmcgfCBVUkwpIHtcbiAgcmV0dXJuIG5ldyBVUkwoXG4gICAgU3RyaW5nKHVybCkucmVwbGFjZShSRUdFWF9MT0NBTEhPU1RfSE9TVE5BTUUsICdsb2NhbGhvc3QnKSxcbiAgICBiYXNlICYmIFN0cmluZyhiYXNlKS5yZXBsYWNlKFJFR0VYX0xPQ0FMSE9TVF9IT1NUTkFNRSwgJ2xvY2FsaG9zdCcpXG4gIClcbn1cblxuY29uc3QgSW50ZXJuYWwgPSBTeW1ib2woJ05leHRVUkxJbnRlcm5hbCcpXG5cbmV4cG9ydCBjbGFzcyBOZXh0VVJMIHtcbiAgcHJpdmF0ZSBbSW50ZXJuYWxdOiB7XG4gICAgYmFzZVBhdGg6IHN0cmluZ1xuICAgIGJ1aWxkSWQ/OiBzdHJpbmdcbiAgICBmbGlnaHRTZWFyY2hQYXJhbWV0ZXJzPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuICAgIGRlZmF1bHRMb2NhbGU/OiBzdHJpbmdcbiAgICBkb21haW5Mb2NhbGU/OiBEb21haW5Mb2NhbGVcbiAgICBsb2NhbGU/OiBzdHJpbmdcbiAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgdHJhaWxpbmdTbGFzaD86IGJvb2xlYW5cbiAgICB1cmw6IFVSTFxuICB9XG5cbiAgY29uc3RydWN0b3IoaW5wdXQ6IHN0cmluZyB8IFVSTCwgYmFzZT86IHN0cmluZyB8IFVSTCwgb3B0cz86IE9wdGlvbnMpXG4gIGNvbnN0cnVjdG9yKGlucHV0OiBzdHJpbmcgfCBVUkwsIG9wdHM/OiBPcHRpb25zKVxuICBjb25zdHJ1Y3RvcihcbiAgICBpbnB1dDogc3RyaW5nIHwgVVJMLFxuICAgIGJhc2VPck9wdHM/OiBzdHJpbmcgfCBVUkwgfCBPcHRpb25zLFxuICAgIG9wdHM/OiBPcHRpb25zXG4gICkge1xuICAgIGxldCBiYXNlOiB1bmRlZmluZWQgfCBzdHJpbmcgfCBVUkxcbiAgICBsZXQgb3B0aW9uczogT3B0aW9uc1xuXG4gICAgaWYgKFxuICAgICAgKHR5cGVvZiBiYXNlT3JPcHRzID09PSAnb2JqZWN0JyAmJiAncGF0aG5hbWUnIGluIGJhc2VPck9wdHMpIHx8XG4gICAgICB0eXBlb2YgYmFzZU9yT3B0cyA9PT0gJ3N0cmluZydcbiAgICApIHtcbiAgICAgIGJhc2UgPSBiYXNlT3JPcHRzXG4gICAgICBvcHRpb25zID0gb3B0cyB8fCB7fVxuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zID0gb3B0cyB8fCBiYXNlT3JPcHRzIHx8IHt9XG4gICAgfVxuXG4gICAgdGhpc1tJbnRlcm5hbF0gPSB7XG4gICAgICB1cmw6IHBhcnNlVVJMKGlucHV0LCBiYXNlID8/IG9wdGlvbnMuYmFzZSksXG4gICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgYmFzZVBhdGg6ICcnLFxuICAgIH1cblxuICAgIHRoaXMuYW5hbHl6ZSgpXG4gIH1cblxuICBwcml2YXRlIGFuYWx5emUoKSB7XG4gICAgY29uc3QgaW5mbyA9IGdldE5leHRQYXRobmFtZUluZm8odGhpc1tJbnRlcm5hbF0udXJsLnBhdGhuYW1lLCB7XG4gICAgICBuZXh0Q29uZmlnOiB0aGlzW0ludGVybmFsXS5vcHRpb25zLm5leHRDb25maWcsXG4gICAgICBwYXJzZURhdGE6ICFwcm9jZXNzLmVudi5fX05FWFRfTk9fTUlERExFV0FSRV9VUkxfTk9STUFMSVpFLFxuICAgICAgaTE4blByb3ZpZGVyOiB0aGlzW0ludGVybmFsXS5vcHRpb25zLmkxOG5Qcm92aWRlcixcbiAgICB9KVxuXG4gICAgY29uc3QgaG9zdG5hbWUgPSBnZXRIb3N0bmFtZShcbiAgICAgIHRoaXNbSW50ZXJuYWxdLnVybCxcbiAgICAgIHRoaXNbSW50ZXJuYWxdLm9wdGlvbnMuaGVhZGVyc1xuICAgIClcbiAgICB0aGlzW0ludGVybmFsXS5kb21haW5Mb2NhbGUgPSB0aGlzW0ludGVybmFsXS5vcHRpb25zLmkxOG5Qcm92aWRlclxuICAgICAgPyB0aGlzW0ludGVybmFsXS5vcHRpb25zLmkxOG5Qcm92aWRlci5kZXRlY3REb21haW5Mb2NhbGUoaG9zdG5hbWUpXG4gICAgICA6IGRldGVjdERvbWFpbkxvY2FsZShcbiAgICAgICAgICB0aGlzW0ludGVybmFsXS5vcHRpb25zLm5leHRDb25maWc/LmkxOG4/LmRvbWFpbnMsXG4gICAgICAgICAgaG9zdG5hbWVcbiAgICAgICAgKVxuXG4gICAgY29uc3QgZGVmYXVsdExvY2FsZSA9XG4gICAgICB0aGlzW0ludGVybmFsXS5kb21haW5Mb2NhbGU/LmRlZmF1bHRMb2NhbGUgfHxcbiAgICAgIHRoaXNbSW50ZXJuYWxdLm9wdGlvbnMubmV4dENvbmZpZz8uaTE4bj8uZGVmYXVsdExvY2FsZVxuXG4gICAgdGhpc1tJbnRlcm5hbF0udXJsLnBhdGhuYW1lID0gaW5mby5wYXRobmFtZVxuICAgIHRoaXNbSW50ZXJuYWxdLmRlZmF1bHRMb2NhbGUgPSBkZWZhdWx0TG9jYWxlXG4gICAgdGhpc1tJbnRlcm5hbF0uYmFzZVBhdGggPSBpbmZvLmJhc2VQYXRoID8/ICcnXG4gICAgdGhpc1tJbnRlcm5hbF0uYnVpbGRJZCA9IGluZm8uYnVpbGRJZFxuICAgIHRoaXNbSW50ZXJuYWxdLmxvY2FsZSA9IGluZm8ubG9jYWxlID8/IGRlZmF1bHRMb2NhbGVcbiAgICB0aGlzW0ludGVybmFsXS50cmFpbGluZ1NsYXNoID0gaW5mby50cmFpbGluZ1NsYXNoXG4gIH1cblxuICBwcml2YXRlIGZvcm1hdFBhdGhuYW1lKCkge1xuICAgIHJldHVybiBmb3JtYXROZXh0UGF0aG5hbWVJbmZvKHtcbiAgICAgIGJhc2VQYXRoOiB0aGlzW0ludGVybmFsXS5iYXNlUGF0aCxcbiAgICAgIGJ1aWxkSWQ6IHRoaXNbSW50ZXJuYWxdLmJ1aWxkSWQsXG4gICAgICBkZWZhdWx0TG9jYWxlOiAhdGhpc1tJbnRlcm5hbF0ub3B0aW9ucy5mb3JjZUxvY2FsZVxuICAgICAgICA/IHRoaXNbSW50ZXJuYWxdLmRlZmF1bHRMb2NhbGVcbiAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICBsb2NhbGU6IHRoaXNbSW50ZXJuYWxdLmxvY2FsZSxcbiAgICAgIHBhdGhuYW1lOiB0aGlzW0ludGVybmFsXS51cmwucGF0aG5hbWUsXG4gICAgICB0cmFpbGluZ1NsYXNoOiB0aGlzW0ludGVybmFsXS50cmFpbGluZ1NsYXNoLFxuICAgIH0pXG4gIH1cblxuICBwcml2YXRlIGZvcm1hdFNlYXJjaCgpIHtcbiAgICByZXR1cm4gdGhpc1tJbnRlcm5hbF0udXJsLnNlYXJjaFxuICB9XG5cbiAgcHVibGljIGdldCBidWlsZElkKCkge1xuICAgIHJldHVybiB0aGlzW0ludGVybmFsXS5idWlsZElkXG4gIH1cblxuICBwdWJsaWMgc2V0IGJ1aWxkSWQoYnVpbGRJZDogc3RyaW5nIHwgdW5kZWZpbmVkKSB7XG4gICAgdGhpc1tJbnRlcm5hbF0uYnVpbGRJZCA9IGJ1aWxkSWRcbiAgfVxuXG4gIHB1YmxpYyBnZXQgbG9jYWxlKCkge1xuICAgIHJldHVybiB0aGlzW0ludGVybmFsXS5sb2NhbGUgPz8gJydcbiAgfVxuXG4gIHB1YmxpYyBzZXQgbG9jYWxlKGxvY2FsZTogc3RyaW5nKSB7XG4gICAgaWYgKFxuICAgICAgIXRoaXNbSW50ZXJuYWxdLmxvY2FsZSB8fFxuICAgICAgIXRoaXNbSW50ZXJuYWxdLm9wdGlvbnMubmV4dENvbmZpZz8uaTE4bj8ubG9jYWxlcy5pbmNsdWRlcyhsb2NhbGUpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBgVGhlIE5leHRVUkwgY29uZmlndXJhdGlvbiBpbmNsdWRlcyBubyBsb2NhbGUgXCIke2xvY2FsZX1cImBcbiAgICAgIClcbiAgICB9XG5cbiAgICB0aGlzW0ludGVybmFsXS5sb2NhbGUgPSBsb2NhbGVcbiAgfVxuXG4gIGdldCBkZWZhdWx0TG9jYWxlKCkge1xuICAgIHJldHVybiB0aGlzW0ludGVybmFsXS5kZWZhdWx0TG9jYWxlXG4gIH1cblxuICBnZXQgZG9tYWluTG9jYWxlKCkge1xuICAgIHJldHVybiB0aGlzW0ludGVybmFsXS5kb21haW5Mb2NhbGVcbiAgfVxuXG4gIGdldCBzZWFyY2hQYXJhbXMoKSB7XG4gICAgcmV0dXJuIHRoaXNbSW50ZXJuYWxdLnVybC5zZWFyY2hQYXJhbXNcbiAgfVxuXG4gIGdldCBob3N0KCkge1xuICAgIHJldHVybiB0aGlzW0ludGVybmFsXS51cmwuaG9zdFxuICB9XG5cbiAgc2V0IGhvc3QodmFsdWU6IHN0cmluZykge1xuICAgIHRoaXNbSW50ZXJuYWxdLnVybC5ob3N0ID0gdmFsdWVcbiAgfVxuXG4gIGdldCBob3N0bmFtZSgpIHtcbiAgICByZXR1cm4gdGhpc1tJbnRlcm5hbF0udXJsLmhvc3RuYW1lXG4gIH1cblxuICBzZXQgaG9zdG5hbWUodmFsdWU6IHN0cmluZykge1xuICAgIHRoaXNbSW50ZXJuYWxdLnVybC5ob3N0bmFtZSA9IHZhbHVlXG4gIH1cblxuICBnZXQgcG9ydCgpIHtcbiAgICByZXR1cm4gdGhpc1tJbnRlcm5hbF0udXJsLnBvcnRcbiAgfVxuXG4gIHNldCBwb3J0KHZhbHVlOiBzdHJpbmcpIHtcbiAgICB0aGlzW0ludGVybmFsXS51cmwucG9ydCA9IHZhbHVlXG4gIH1cblxuICBnZXQgcHJvdG9jb2woKSB7XG4gICAgcmV0dXJuIHRoaXNbSW50ZXJuYWxdLnVybC5wcm90b2NvbFxuICB9XG5cbiAgc2V0IHByb3RvY29sKHZhbHVlOiBzdHJpbmcpIHtcbiAgICB0aGlzW0ludGVybmFsXS51cmwucHJvdG9jb2wgPSB2YWx1ZVxuICB9XG5cbiAgZ2V0IGhyZWYoKSB7XG4gICAgY29uc3QgcGF0aG5hbWUgPSB0aGlzLmZvcm1hdFBhdGhuYW1lKClcbiAgICBjb25zdCBzZWFyY2ggPSB0aGlzLmZvcm1hdFNlYXJjaCgpXG4gICAgcmV0dXJuIGAke3RoaXMucHJvdG9jb2x9Ly8ke3RoaXMuaG9zdH0ke3BhdGhuYW1lfSR7c2VhcmNofSR7dGhpcy5oYXNofWBcbiAgfVxuXG4gIHNldCBocmVmKHVybDogc3RyaW5nKSB7XG4gICAgdGhpc1tJbnRlcm5hbF0udXJsID0gcGFyc2VVUkwodXJsKVxuICAgIHRoaXMuYW5hbHl6ZSgpXG4gIH1cblxuICBnZXQgb3JpZ2luKCkge1xuICAgIHJldHVybiB0aGlzW0ludGVybmFsXS51cmwub3JpZ2luXG4gIH1cblxuICBnZXQgcGF0aG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXNbSW50ZXJuYWxdLnVybC5wYXRobmFtZVxuICB9XG5cbiAgc2V0IHBhdGhuYW1lKHZhbHVlOiBzdHJpbmcpIHtcbiAgICB0aGlzW0ludGVybmFsXS51cmwucGF0aG5hbWUgPSB2YWx1ZVxuICB9XG5cbiAgZ2V0IGhhc2goKSB7XG4gICAgcmV0dXJuIHRoaXNbSW50ZXJuYWxdLnVybC5oYXNoXG4gIH1cblxuICBzZXQgaGFzaCh2YWx1ZTogc3RyaW5nKSB7XG4gICAgdGhpc1tJbnRlcm5hbF0udXJsLmhhc2ggPSB2YWx1ZVxuICB9XG5cbiAgZ2V0IHNlYXJjaCgpIHtcbiAgICByZXR1cm4gdGhpc1tJbnRlcm5hbF0udXJsLnNlYXJjaFxuICB9XG5cbiAgc2V0IHNlYXJjaCh2YWx1ZTogc3RyaW5nKSB7XG4gICAgdGhpc1tJbnRlcm5hbF0udXJsLnNlYXJjaCA9IHZhbHVlXG4gIH1cblxuICBnZXQgcGFzc3dvcmQoKSB7XG4gICAgcmV0dXJuIHRoaXNbSW50ZXJuYWxdLnVybC5wYXNzd29yZFxuICB9XG5cbiAgc2V0IHBhc3N3b3JkKHZhbHVlOiBzdHJpbmcpIHtcbiAgICB0aGlzW0ludGVybmFsXS51cmwucGFzc3dvcmQgPSB2YWx1ZVxuICB9XG5cbiAgZ2V0IHVzZXJuYW1lKCkge1xuICAgIHJldHVybiB0aGlzW0ludGVybmFsXS51cmwudXNlcm5hbWVcbiAgfVxuXG4gIHNldCB1c2VybmFtZSh2YWx1ZTogc3RyaW5nKSB7XG4gICAgdGhpc1tJbnRlcm5hbF0udXJsLnVzZXJuYW1lID0gdmFsdWVcbiAgfVxuXG4gIGdldCBiYXNlUGF0aCgpIHtcbiAgICByZXR1cm4gdGhpc1tJbnRlcm5hbF0uYmFzZVBhdGhcbiAgfVxuXG4gIHNldCBiYXNlUGF0aCh2YWx1ZTogc3RyaW5nKSB7XG4gICAgdGhpc1tJbnRlcm5hbF0uYmFzZVBhdGggPSB2YWx1ZS5zdGFydHNXaXRoKCcvJykgPyB2YWx1ZSA6IGAvJHt2YWx1ZX1gXG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5ocmVmXG4gIH1cblxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMuaHJlZlxuICB9XG5cbiAgW1N5bWJvbC5mb3IoJ2VkZ2UtcnVudGltZS5pbnNwZWN0LmN1c3RvbScpXSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaHJlZjogdGhpcy5ocmVmLFxuICAgICAgb3JpZ2luOiB0aGlzLm9yaWdpbixcbiAgICAgIHByb3RvY29sOiB0aGlzLnByb3RvY29sLFxuICAgICAgdXNlcm5hbWU6IHRoaXMudXNlcm5hbWUsXG4gICAgICBwYXNzd29yZDogdGhpcy5wYXNzd29yZCxcbiAgICAgIGhvc3Q6IHRoaXMuaG9zdCxcbiAgICAgIGhvc3RuYW1lOiB0aGlzLmhvc3RuYW1lLFxuICAgICAgcG9ydDogdGhpcy5wb3J0LFxuICAgICAgcGF0aG5hbWU6IHRoaXMucGF0aG5hbWUsXG4gICAgICBzZWFyY2g6IHRoaXMuc2VhcmNoLFxuICAgICAgc2VhcmNoUGFyYW1zOiB0aGlzLnNlYXJjaFBhcmFtcyxcbiAgICAgIGhhc2g6IHRoaXMuaGFzaCxcbiAgICB9XG4gIH1cblxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IE5leHRVUkwoU3RyaW5nKHRoaXMpLCB0aGlzW0ludGVybmFsXS5vcHRpb25zKVxuICB9XG59XG4iXSwibmFtZXMiOlsiZGV0ZWN0RG9tYWluTG9jYWxlIiwiZm9ybWF0TmV4dFBhdGhuYW1lSW5mbyIsImdldEhvc3RuYW1lIiwiZ2V0TmV4dFBhdGhuYW1lSW5mbyIsIlJFR0VYX0xPQ0FMSE9TVF9IT1NUTkFNRSIsInBhcnNlVVJMIiwidXJsIiwiYmFzZSIsIlVSTCIsIlN0cmluZyIsInJlcGxhY2UiLCJJbnRlcm5hbCIsIlN5bWJvbCIsIk5leHRVUkwiLCJjb25zdHJ1Y3RvciIsImlucHV0IiwiYmFzZU9yT3B0cyIsIm9wdHMiLCJvcHRpb25zIiwiYmFzZVBhdGgiLCJhbmFseXplIiwiaW5mbyIsInBhdGhuYW1lIiwibmV4dENvbmZpZyIsInBhcnNlRGF0YSIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfTk9fTUlERExFV0FSRV9VUkxfTk9STUFMSVpFIiwiaTE4blByb3ZpZGVyIiwiaG9zdG5hbWUiLCJoZWFkZXJzIiwiZG9tYWluTG9jYWxlIiwiaTE4biIsImRvbWFpbnMiLCJkZWZhdWx0TG9jYWxlIiwiYnVpbGRJZCIsImxvY2FsZSIsInRyYWlsaW5nU2xhc2giLCJmb3JtYXRQYXRobmFtZSIsImZvcmNlTG9jYWxlIiwidW5kZWZpbmVkIiwiZm9ybWF0U2VhcmNoIiwic2VhcmNoIiwibG9jYWxlcyIsImluY2x1ZGVzIiwiVHlwZUVycm9yIiwic2VhcmNoUGFyYW1zIiwiaG9zdCIsInZhbHVlIiwicG9ydCIsInByb3RvY29sIiwiaHJlZiIsImhhc2giLCJvcmlnaW4iLCJwYXNzd29yZCIsInVzZXJuYW1lIiwic3RhcnRzV2l0aCIsInRvU3RyaW5nIiwidG9KU09OIiwiZm9yIiwiY2xvbmUiXSwibWFwcGluZ3MiOiI7OztBQUlBLFNBQVNBLGtCQUFrQixRQUFRLDZDQUE0QztBQUMvRSxTQUFTQyxzQkFBc0IsUUFBUSwwREFBeUQ7QUFDaEcsU0FBU0MsV0FBVyxRQUFRLGdD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QVEsSUFBSSxDQUFDQSxNQUFNO1lBQ25CSSxjQUFjLElBQUksQ0FBQ0EsWUFBWTtZQUMvQk0sTUFBTSxJQUFJLENBQUNBLElBQUk7UUFDakI7SUFDRjtJQUVBUSxRQUFRO1FBQ04sT0FBTyxJQUFJL0MsUUFBUUosT0FBTyxJQUFJLEdBQUcsSUFBSSxDQUFDRSxTQUFTLENBQUNPLE9BQU87SUFDekQ7QUFDRiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxMTIyOCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL3NlcnZlci93ZWIvZXJyb3IudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNsYXNzIFBhZ2VTaWduYXR1cmVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoeyBwYWdlIH06IHsgcGFnZTogc3RyaW5nIH0pIHtcbiAgICBzdXBlcihgVGhlIG1pZGRsZXdhcmUgXCIke3BhZ2V9XCIgYWNjZXB0cyBhbiBhc3luYyBBUEkgZGlyZWN0bHkgd2l0aCB0aGUgZm9ybTpcbiAgXG4gIGV4cG9ydCBmdW5jdGlvbiBtaWRkbGV3YXJlKHJlcXVlc3QsIGV2ZW50KSB7XG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5yZWRpcmVjdCgnL25ldy1sb2NhdGlvbicpXG4gIH1cbiAgXG4gIFJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbWlkZGxld2FyZS1uZXctc2lnbmF0dXJlXG4gIGApXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFJlbW92ZWRQYWdlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKGBUaGUgcmVxdWVzdC5wYWdlIGhhcyBiZWVuIGRlcHJlY2F0ZWQgaW4gZmF2b3VyIG9mIFxcYFVSTFBhdHRlcm5cXGAuXG4gIFJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbWlkZGxld2FyZS1yZXF1ZXN0LXBhZ2VcbiAgYClcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgUmVtb3ZlZFVBRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKGBUaGUgcmVxdWVzdC51YSBoYXMgYmVlbiByZW1vdmVkIGluIGZhdm91ciBvZiBcXGB1c2VyQWdlbnRcXGAgZnVuY3Rpb24uXG4gIFJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbWlkZGxld2FyZS1wYXJzZS11c2VyLWFnZW50XG4gIGApXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJQYWdlU2lnbmF0dXJlRXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwicGFnZSIsIlJlbW92ZWRQYWdlRXJyb3IiLCJSZW1vdmVkVUFFcnJvciJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTyxNQUFNQSwyQkFBMkJDO0lBQ3RDQyxZQUFZLEVBQUVDLElBQUksRUFBb0IsQ0FBRTtRQUN0QyxLQUFLLENBQUMsQ0FBQyxnQkFBZ0IsRUFBRUEsS0FBSzs7Ozs7OztFQU9oQyxDQUFDO0lBQ0Q7QUFDRjtBQUVPLE1BQU1DLHlCQUF5Qkg7SUFDcENDLGFBQWM7UUFDWixLQUFLLENBQUMsQ0FBQzs7RUFFVCxDQUFDO0lBQ0Q7QUFDRjtBQUVPLE1BQU1HLHVCQUF1Qko7SUFDbENDLGFBQWM7UUFDWixLQUFLLENBQUMsQ0FBQzs7RUFFVCxDQUFDO0lBQ0Q7QUFDRiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxMTI2NSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvJTQwZWRnZS1ydW50aW1lL2Nvb2tpZXMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBzcmNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoc3JjX2V4cG9ydHMsIHtcbiAgUmVxdWVzdENvb2tpZXM6ICgpID0+IFJlcXVlc3RDb29raWVzLFxuICBSZXNwb25zZUNvb2tpZXM6ICgpID0+IFJlc3BvbnNlQ29va2llcyxcbiAgcGFyc2VDb29raWU6ICgpID0+IHBhcnNlQ29va2llLFxuICBwYXJzZVNldENvb2tpZTogKCkgPT4gcGFyc2VTZXRDb29raWUsXG4gIHN0cmluZ2lmeUNvb2tpZTogKCkgPT4gc3RyaW5naWZ5Q29va2llXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKHNyY19leHBvcnRzKTtcblxuLy8gc3JjL3NlcmlhbGl6ZS50c1xuZnVuY3Rpb24gc3RyaW5naWZ5Q29va2llKGMpIHtcbiAgdmFyIF9hO1xuICBjb25zdCBhdHRycyA9IFtcbiAgICBcInBhdGhcIiBpbiBjICYmIGMucGF0aCAmJiBgUGF0aD0ke2MucGF0aH1gLFxuICAgIFwiZXhwaXJlc1wiIGluIGMgJiYgKGMuZXhwaXJlcyB8fCBjLmV4cGlyZXMgPT09IDApICYmIGBFeHBpcmVzPSR7KHR5cGVvZiBjLmV4cGlyZXMgPT09IFwibnVtYmVyXCIgPyBuZXcgRGF0ZShjLmV4cGlyZXMpIDogYy5leHBpcmVzKS50b1VUQ1N0cmluZygpfWAsXG4gICAgXCJtYXhBZ2VcIiBpbiBjICYmIHR5cGVvZiBjLm1heEFnZSA9PT0gXCJudW1iZXJcIiAmJiBgTWF4LUFnZT0ke2MubWF4QWdlfWAsXG4gICAgXCJkb21haW5cIiBpbiBjICYmIGMuZG9tYWluICYmIGBEb21haW49JHtjLmRvbWFpbn1gLFxuICAgIFwic2VjdXJlXCIgaW4gYyAmJiBjLnNlY3VyZSAmJiBcIlNlY3VyZVwiLFxuICAgIFwiaHR0cE9ubHlcIiBpbiBjICYmIGMuaHR0cE9ubHkgJiYgXCJIdHRwT25seVwiLFxuICAgIFwic2FtZVNpdGVcIiBpbiBjICYmIGMuc2FtZVNpdGUgJiYgYFNhbWVTaXRlPSR7Yy5zYW1lU2l0ZX1gLFxuICAgIFwicGFydGl0aW9uZWRcIiBpbiBjICYmIGMucGFydGl0aW9uZWQgJiYgXCJQYXJ0aXRpb25lZFwiLFxuICAgIFwicHJpb3JpdHlcIiBpbiBjICYmIGMucHJpb3JpdHkgJiYgYFByaW9yaXR5PSR7Yy5wcmlvcml0eX1gXG4gIF0uZmlsdGVyKEJvb2xlYW4pO1xuICBjb25zdCBzdHJpbmdpZmllZCA9IGAke2MubmFtZX09JHtlbmNvZGVVUklDb21wb25lbnQoKF9hID0gYy52YWx1ZSkgIT0gbnVsbCA/IF9hIDogXCJcIil9YDtcbiAgcmV0dXJuIGF0dHJzLmxlbmd0aCA9PT0gMCA/IHN0cmluZ2lmaWVkIDogYCR7c3RyaW5naWZpZWR9OyAke2F0dHJzLmpvaW4oXCI7IFwiKX1gO1xufVxuZnVuY3Rpb24gcGFyc2VDb29raWUoY29va2llKSB7XG4gIGNvbnN0IG1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGZvciAoY29uc3QgcGFpciBvZiBjb29raWUuc3BsaXQoLzsgKi8pKSB7XG4gICAgaWYgKCFwYWlyKVxuICAgICAgY29udGludWU7XG4gICAgY29uc3Qgc3BsaXRBdCA9IHBhaXIuaW5kZXhPZihcIj1cIik7XG4gICAgaWYgKHNwbGl0QXQgPT09IC0xKSB7XG4gICAgICBtYXAuc2V0KHBhaXIsIFwidHJ1ZVwiKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSBbcGFpci5zbGljZSgwLCBzcGxpdEF0KSwgcGFpci5zbGljZShzcGxpdEF0ICsgMSldO1xuICAgIHRyeSB7XG4gICAgICBtYXAuc2V0KGtleSwgZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IFwidHJ1ZVwiKSk7XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICB9XG4gIHJldHVybiBtYXA7XG59XG5mdW5jdGlvbiBwYXJzZVNldENvb2tpZShzZXRDb29raWUpIHtcbiAgaWYgKCFzZXRDb29raWUpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGNvbnN0IFtbbmFtZSwgdmFsdWVdLCAuLi5hdHRyaWJ1dGVzXSA9IHBhcnNlQ29va2llKHNldENvb2tpZSk7XG4gIGNvbnN0IHtcbiAgICBkb21haW4sXG4gICAgZXhwaXJlcyxcbiAgICBodHRwb25seSxcbiAgICBtYXhhZ2UsXG4gICAgcGF0aCxcbiAgICBzYW1lc2l0ZSxcbiAgICBzZWN1cmUsXG4gICAgcGFydGl0aW9uZWQsXG4gICAgcHJpb3JpdHlcbiAgfSA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBhdHRyaWJ1dGVzLm1hcCgoW2tleSwgdmFsdWUyXSkgPT4gW1xuICAgICAga2V5LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvLS9nLCBcIlwiKSxcbiAgICAgIHZhbHVlMlxuICAgIF0pXG4gICk7XG4gIGNvbnN0IGNvb2tpZSA9IHtcbiAgICBuYW1lLFxuICAgIHZhbHVlOiBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpLFxuICAgIGRvbWFpbixcbiAgICAuLi5leHBpcmVzICYmIHsgZXhwaXJlczogbmV3IERhdGUoZXhwaXJlcykgfSxcbiAgICAuLi5odHRwb25seSAmJiB7IGh0dHBPbmx5OiB0cnVlIH0sXG4gICAgLi4udHlwZW9mIG1heGFnZSA9PT0gXCJzdHJpbmdcIiAmJiB7IG1heEFnZTogTnVtYmVyKG1heGFnZSkgfSxcbiAgICBwYXRoLFxuICAgIC4uLnNhbWVzaXRlICYmIHsgc2FtZVNpdGU6IHBhcnNlU2FtZVNpdGUoc2FtZXNpdGUpIH0sXG4gICAgLi4uc2VjdXJlICYmIHsgc2VjdXJlOiB0cnVlIH0sXG4gICAgLi4ucHJpb3JpdHkgJiYgeyBwcmlvcml0eTogcGFyc2VQcmlvcml0eShwcmlvcml0eSkgfSxcbiAgICAuLi5wYXJ0aXRpb25lZCAmJiB7IHBhcnRpdGlvbmVkOiB0cnVlIH1cbiAgfTtcbiAgcmV0dXJuIGNvbXBhY3QoY29va2llKTtcbn1cbmZ1bmN0aW9uIGNvbXBhY3QodCkge1xuICBjb25zdCBuZXdUID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIHQpIHtcbiAgICBpZiAodFtrZXldKSB7XG4gICAgICBuZXdUW2tleV0gPSB0W2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXdUO1xufVxudmFyIFNBTUVfU0lURSA9IFtcInN0cmljdFwiLCBcImxheFwiLCBcIm5vbmVcIl07XG5mdW5jdGlvbiBwYXJzZVNhbWVTaXRlKHN0cmluZykge1xuICBzdHJpbmcgPSBzdHJpbmcudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIFNBTUVfU0lURS5pbmNsdWRlcyhzdHJpbmcpID8gc3RyaW5nIDogdm9pZCAwO1xufVxudmFyIFBSSU9SSVRZID0gW1wibG93XCIsIFwibWVkaXVtXCIsIFwiaGlnaFwiXTtcbmZ1bmN0aW9uIHBhcnNlUHJpb3JpdHkoc3RyaW5nKSB7XG4gIHN0cmluZyA9IHN0cmluZy50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gUFJJT1JJVFkuaW5jbHVkZXMoc3RyaW5nKSA/IHN0cmluZyA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIHNwbGl0Q29va2llc1N0cmluZyhjb29raWVzU3RyaW5nKSB7XG4gIGlmICghY29va2llc1N0cmluZylcbiAgICByZXR1cm4gW107XG4gIHZhciBjb29raWVzU3RyaW5ncyA9IFtdO1xuICB2YXIgcG9zID0gMDtcbiAgdmFyIHN0YXJ0O1xuICB2YXIgY2g7XG4gIHZhciBsYXN0Q29tbWE7XG4gIHZhciBuZXh0U3RhcnQ7XG4gIHZhciBjb29raWVzU2VwYXJhdG9yRm91bmQ7XG4gIGZ1bmN0aW9uIHNraXBXaGl0ZXNwYWNlKCkge1xuICAgIHdoaWxlIChwb3MgPCBjb29raWVzU3RyaW5nLmxlbmd0aCAmJiAvXFxzLy50ZXN0KGNvb2tpZXNTdHJpbmcuY2hhckF0KHBvcykpKSB7XG4gICAgICBwb3MgKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHBvcyA8IGNvb2tpZXNTdHJpbmcubGVuZ3RoO1xuICB9XG4gIGZ1bmN0aW9uIG5vdFNwZWNpYWxDaGFyKCkge1xuICAgIGNoID0gY29va2llc1N0cmluZy5jaGFyQXQocG9zKTtcbiAgICByZXR1cm4gY2ggIT09IFwiPVwiICYmIGNoICE9PSBcIjtcIiAmJiBjaCAhPT0gXCIsXCI7XG4gIH1cbiAgd2hpbGUgKHBvcyA8IGNvb2tpZXNTdHJpbmcubGVuZ3RoKSB7XG4gICAgc3RhcnQgPSBwb3M7XG4gICAgY29va2llc1NlcGFyYXRvckZvdW5kID0gZmFsc2U7XG4gICAgd2hpbGUgKHNraXBXaGl0ZXNwYWNlKCkpIHtcbiAgICAgIGNoID0gY29va2llc1N0cmluZy5jaGFyQXQocG9zKTtcbiAgICAgIGlmIChjaCA9PT0gXCIsXCIpIHtcbiAgICAgICAgbGFzdENvbW1hID0gcG9zO1xuICAgICAgICBwb3MgKz0gMTtcbiAgICAgICAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgICAgICAgbmV4dFN0YXJ0ID0gcG9zO1xuICAgICAgICB3aGlsZSAocG9zIDwgY29va2llc1N0cmluZy5sZW5ndGggJiYgbm90U3BlY2lhbENoYXIoKSkge1xuICAgICAgICAgIHBvcyArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3MgPCBjb29raWVzU3RyaW5nLmxlbmd0aCAmJiBjb29raWVzU3RyaW5nLmNoYXJBdChwb3MpID09PSBcIj1cIikge1xuICAgICAgICAgIGNvb2tpZXNTZXBhcmF0b3JGb3VuZCA9IHRydWU7XG4gICAgICAgICAgcG9zID0gbmV4dFN0YXJ0O1xuICAgICAgICAgIGNvb2tpZXNTdHJpbmdzLnB1c2goY29va2llc1N0cmluZy5zdWJzdHJpbmcoc3RhcnQsIGxhc3RDb21tYSkpO1xuICAgICAgICAgIHN0YXJ0ID0gcG9zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBvcyA9IGxhc3RDb21tYSArIDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBvcyArPSAxO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWNvb2tpZXNTZXBhcmF0b3JGb3VuZCB8fCBwb3MgPj0gY29va2llc1N0cmluZy5sZW5ndGgpIHtcbiAgICAgIGNvb2tpZXNTdHJpbmdzLnB1c2goY29va2llc1N0cmluZy5zdWJzdHJpbmcoc3RhcnQsIGNvb2tpZXNTdHJpbmcubGVuZ3RoKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjb29raWVzU3RyaW5ncztcbn1cblxuLy8gc3JjL3JlcXVlc3QtY29va2llcy50c1xudmFyIFJlcXVlc3RDb29raWVzID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihyZXF1ZXN0SGVhZGVycykge1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9wYXJzZWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuX2hlYWRlcnMgPSByZXF1ZXN0SGVhZGVycztcbiAgICBjb25zdCBoZWFkZXIgPSByZXF1ZXN0SGVhZGVycy5nZXQoXCJjb29raWVcIik7XG4gICAgaWYgKGhlYWRlcikge1xuICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VDb29raWUoaGVhZGVyKTtcbiAgICAgIGZvciAoY29uc3QgW25hbWUsIHZhbHVlXSBvZiBwYXJzZWQpIHtcbiAgICAgICAgdGhpcy5fcGFyc2VkLnNldChuYW1lLCB7IG5hbWUsIHZhbHVlIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFyc2VkW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGFtb3VudCBvZiBjb29raWVzIHJlY2VpdmVkIGZyb20gdGhlIGNsaWVudFxuICAgKi9cbiAgZ2V0IHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcnNlZC5zaXplO1xuICB9XG4gIGdldCguLi5hcmdzKSB7XG4gICAgY29uc3QgbmFtZSA9IHR5cGVvZiBhcmdzWzBdID09PSBcInN0cmluZ1wiID8gYXJnc1swXSA6IGFyZ3NbMF0ubmFtZTtcbiAgICByZXR1cm4gdGhpcy5fcGFyc2VkLmdldChuYW1lKTtcbiAgfVxuICBnZXRBbGwoLi4uYXJncykge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBhbGwgPSBBcnJheS5mcm9tKHRoaXMuX3BhcnNlZCk7XG4gICAgaWYgKCFhcmdzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGFsbC5tYXAoKFtfLCB2YWx1ZV0pID0+IHZhbHVlKTtcbiAgICB9XG4gICAgY29uc3QgbmFtZSA9IHR5cGVvZiBhcmdzWzBdID09PSBcInN0cmluZ1wiID8gYXJnc1swXSA6IChfYSA9IGFyZ3NbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfYS5uYW1lO1xuICAgIHJldHVybiBhbGwuZmlsdGVyKChbbl0pID0+IG4gPT09IG5hbWUpLm1hcCgoW18sIHZhbHVlXSkgPT4gdmFsdWUpO1xuICB9XG4gIGhhcyhuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcnNlZC5oYXMobmFtZSk7XG4gIH1cbiAgc2V0KC4uLmFyZ3MpIHtcbiAgICBjb25zdCBbbmFtZSwgdmFsdWVdID0gYXJncy5sZW5ndGggPT09IDEgPyBbYXJnc1swXS5uYW1lLCBhcmdzWzBdLnZhbHVlXSA6IGFyZ3M7XG4gICAgY29uc3QgbWFwID0gdGhpcy5fcGFyc2VkO1xuICAgIG1hcC5zZXQobmFtZSwgeyBuYW1lLCB2YWx1ZSB9KTtcbiAgICB0aGlzLl9oZWFkZXJzLnNldChcbiAgICAgIFwiY29va2llXCIsXG4gICAgICBBcnJheS5mcm9tKG1hcCkubWFwKChbXywgdmFsdWUyXSkgPT4gc3RyaW5naWZ5Q29va2llKHZhbHVlMikpLmpvaW4oXCI7IFwiKVxuICAgICk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZSB0aGUgY29va2llcyBtYXRjaGluZyB0aGUgcGFzc2VkIG5hbWUgb3IgbmFtZXMgaW4gdGhlIHJlcXVlc3QuXG4gICAqL1xuICBkZWxldGUobmFtZXMpIHtcbiAgICBjb25zdCBtYXAgPSB0aGlzLl9wYXJzZWQ7XG4gICAgY29uc3QgcmVzdWx0ID0gIUFycmF5LmlzQXJyYXkobmFtZXMpID8gbWFwLmRlbGV0ZShuYW1lcykgOiBuYW1lcy5tYXAoKG5hbWUpID0+IG1hcC5kZWxldGUobmFtZSkpO1xuICAgIHRoaXMuX2hlYWRlcnMuc2V0KFxuICAgICAgXCJjb29raWVcIixcbiAgICAgIEFycmF5LmZyb20obWFwKS5tYXAoKFtfLCB2YWx1ZV0pID0+IHN0cmluZ2lmeUNvb2tpZSh2YWx1ZSkpLmpvaW4oXCI7IFwiKVxuICAgICk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlIGFsbCB0aGUgY29va2llcyBpbiB0aGUgY29va2llcyBpbiB0aGUgcmVxdWVzdC5cbiAgICovXG4gIGNsZWFyKCkge1xuICAgIHRoaXMuZGVsZXRlKEFycmF5LmZyb20odGhpcy5fcGFyc2VkLmtleXMoKSkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBGb3JtYXQgdGhlIGNvb2tpZXMgaW4gdGhlIHJlcXVlc3QgYXMgYSBzdHJpbmcgZm9yIGxvZ2dpbmdcbiAgICovXG4gIFtTeW1ib2wuZm9yKFwiZWRnZS1ydW50aW1lLmluc3BlY3QuY3VzdG9tXCIpXSgpIHtcbiAgICByZXR1cm4gYFJlcXVlc3RDb29raWVzICR7SlNPTi5zdHJpbmdpZnkoT2JqZWN0LmZyb21FbnRyaWVzKHRoaXMuX3BhcnNlZCkpfWA7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIFsuLi50aGlzLl9wYXJzZWQudmFsdWVzKCldLm1hcCgodikgPT4gYCR7di5uYW1lfT0ke2VuY29kZVVSSUNvbXBvbmVudCh2LnZhbHVlKX1gKS5qb2luKFwiOyBcIik7XG4gIH1cbn07XG5cbi8vIHNyYy9yZXNwb25zZS1jb29raWVzLnRzXG52YXIgUmVzcG9uc2VDb29raWVzID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihyZXNwb25zZUhlYWRlcnMpIHtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fcGFyc2VkID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICB0aGlzLl9oZWFkZXJzID0gcmVzcG9uc2VIZWFkZXJzO1xuICAgIGNvbnN0IHNldENvb2tpZSA9IChfYyA9IChfYiA9IChfYSA9IHJlc3BvbnNlSGVhZGVycy5nZXRTZXRDb29raWUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKHJlc3BvbnNlSGVhZGVycykpICE9IG51bGwgPyBfYiA6IHJlc3BvbnNlSGVhZGVycy5nZXQoXCJzZXQtY29va2llXCIpKSAhPSBudWxsID8gX2MgOiBbXTtcbiAgICBjb25zdCBjb29raWVTdHJpbmdzID0gQXJyYXkuaXNBcnJheShzZXRDb29raWUpID8gc2V0Q29va2llIDogc3BsaXRDb29raWVzU3RyaW5nKHNldENvb2tpZSk7XG4gICAgZm9yIChjb25zdCBjb29raWVTdHJpbmcgb2YgY29va2llU3RyaW5ncykge1xuICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VTZXRDb29raWUoY29va2llU3RyaW5nKTtcbiAgICAgIGlmIChwYXJzZWQpXG4gICAgICAgIHRoaXMuX3BhcnNlZC5zZXQocGFyc2VkLm5hbWUsIHBhcnNlZCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiB7QGxpbmsgaHR0cHM6Ly93aWNnLmdpdGh1Yi5pby9jb29raWUtc3RvcmUvI0Nvb2tpZVN0b3JlLWdldCBDb29raWVTdG9yZSNnZXR9IHdpdGhvdXQgdGhlIFByb21pc2UuXG4gICAqL1xuICBnZXQoLi4uYXJncykge1xuICAgIGNvbnN0IGtleSA9IHR5cGVvZiBhcmdzWzBdID09PSBcInN0cmluZ1wiID8gYXJnc1swXSA6IGFyZ3NbMF0ubmFtZTtcbiAgICByZXR1cm4gdGhpcy5fcGFyc2VkLmdldChrZXkpO1xuICB9XG4gIC8qKlxuICAgKiB7QGxpbmsgaHR0cHM6Ly93aWNnLmdpdGh1Yi5pby9jb29raWUtc3RvcmUvI0Nvb2tpZVN0b3JlLWdldEFsbCBDb29raWVTdG9yZSNnZXRBbGx9IHdpdGhvdXQgdGhlIFByb21pc2UuXG4gICAqL1xuICBnZXRBbGwoLi4uYXJncykge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBhbGwgPSBBcnJheS5mcm9tKHRoaXMuX3BhcnNlZC52YWx1ZXMoKSk7XG4gICAgaWYgKCFhcmdzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGFsbDtcbiAgICB9XG4gICAgY29uc3Qga2V5ID0gdHlwZW9mIGFyZ3NbMF0gPT09IFwic3RyaW5nXCIgPyBhcmdzWzBdIDogKF9hID0gYXJnc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLm5hbWU7XG4gICAgcmV0dXJuIGFsbC5maWx0ZXIoKGMpID0+IGMubmFtZSA9PT0ga2V5KTtcbiAgfVxuICBoYXMobmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9wYXJzZWQuaGFzKG5hbWUpO1xuICB9XG4gIC8qKlxuICAgKiB7QGxpbmsgaHR0cHM6Ly93aWNnLmdpdGh1Yi5pby9jb29raWUtc3RvcmUvI0Nvb2tpZVN0b3JlLXNldCBDb29raWVTdG9yZSNzZXR9IHdpdGhvdXQgdGhlIFByb21pc2UuXG4gICAqL1xuICBzZXQoLi4uYXJncykge1xuICAgIGNvbnN0IFtuYW1lLCB2YWx1ZSwgY29va2llXSA9IGFyZ3MubGVuZ3RoID09PSAxID8gW2FyZ3NbMF0ubmFtZSwgYXJnc1swXS52YWx1ZSwgYXJnc1swXV0gOiBhcmdzO1xuICAgIGNvbnN0IG1hcCA9IHRoaXMuX3BhcnNlZDtcbiAgICBtYXAuc2V0KG5hbWUsIG5vcm1hbGl6ZUNvb2tpZSh7IG5hbWUsIHZhbHVlLCAuLi5jb29raWUgfSkpO1xuICAgIHJlcGxhY2UobWFwLCB0aGlzLl9oZWFkZXJzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICoge0BsaW5rIGh0dHBzOi8vd2ljZy5naXRodWIuaW8vY29va2llLXN0b3JlLyNDb29raWVTdG9yZS1kZWxldGUgQ29va2llU3RvcmUjZGVsZXRlfSB3aXRob3V0IHRoZSBQcm9taXNlLlxuICAgKi9cbiAgZGVsZXRlKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBbbmFtZSwgb3B0aW9uc10gPSB0eXBlb2YgYXJnc1swXSA9PT0gXCJzdHJpbmdcIiA/IFthcmdzWzBdXSA6IFthcmdzWzBdLm5hbWUsIGFyZ3NbMF1dO1xuICAgIHJldHVybiB0aGlzLnNldCh7IC4uLm9wdGlvbnMsIG5hbWUsIHZhbHVlOiBcIlwiLCBleHBpcmVzOiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoMCkgfSk7XG4gIH1cbiAgW1N5bWJvbC5mb3IoXCJlZGdlLXJ1bnRpbWUuaW5zcGVjdC5jdXN0b21cIildKCkge1xuICAgIHJldHVybiBgUmVzcG9uc2VDb29raWVzICR7SlNPTi5zdHJpbmdpZnkoT2JqZWN0LmZyb21FbnRyaWVzKHRoaXMuX3BhcnNlZCkpfWA7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIFsuLi50aGlzLl9wYXJzZWQudmFsdWVzKCldLm1hcChzdHJpbmdpZnlDb29raWUpLmpvaW4oXCI7IFwiKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHJlcGxhY2UoYmFnLCBoZWFkZXJzKSB7XG4gIGhlYWRlcnMuZGVsZXRlKFwic2V0LWNvb2tpZVwiKTtcbiAgZm9yIChjb25zdCBbLCB2YWx1ZV0gb2YgYmFnKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IHN0cmluZ2lmeUNvb2tpZSh2YWx1ZSk7XG4gICAgaGVhZGVycy5hcHBlbmQoXCJzZXQtY29va2llXCIsIHNlcmlhbGl6ZWQpO1xuICB9XG59XG5mdW5jdGlvbiBub3JtYWxpemVDb29raWUoY29va2llID0geyBuYW1lOiBcIlwiLCB2YWx1ZTogXCJcIiB9KSB7XG4gIGlmICh0eXBlb2YgY29va2llLmV4cGlyZXMgPT09IFwibnVtYmVyXCIpIHtcbiAgICBjb29raWUuZXhwaXJlcyA9IG5ldyBEYXRlKGNvb2tpZS5leHBpcmVzKTtcbiAgfVxuICBpZiAoY29va2llLm1heEFnZSkge1xuICAgIGNvb2tpZS5leHBpcmVzID0gbmV3IERhdGUoRGF0ZS5ub3coKSArIGNvb2tpZS5tYXhBZ2UgKiAxZTMpO1xuICB9XG4gIGlmIChjb29raWUucGF0aCA9PT0gbnVsbCB8fCBjb29raWUucGF0aCA9PT0gdm9pZCAwKSB7XG4gICAgY29va2llLnBhdGggPSBcIi9cIjtcbiAgfVxuICByZXR1cm4gY29va2llO1xufVxuLy8gQW5ub3RhdGUgdGhlIENvbW1vbkpTIGV4cG9ydCBuYW1lcyBmb3IgRVNNIGltcG9ydCBpbiBub2RlOlxuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gIFJlcXVlc3RDb29raWVzLFxuICBSZXNwb25zZUNvb2tpZXMsXG4gIHBhcnNlQ29va2llLFxuICBwYXJzZVNldENvb2tpZSxcbiAgc3RyaW5naWZ5Q29va2llXG59KTtcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxJQUFJLFlBQVksT0FBTyxjQUFjO0FBQ3JDLElBQUksbUJBQW1CLE9BQU8sd0JBQXdCO0FBQ3RELElBQUksb0JBQW9CLE9BQU8sbUJBQW1CO0FBQ2xELElBQUksZUFBZSxPQUFPLFNBQVMsQ0FBQyxjQUFjO0FBQ2xELElBQUksV0FBVyxDQUFDLFFBQVE7SUFDdEIsSUFBSyxJQUFJLFFBQVEsSUFDZixVQUFVLFFBQVEsTUFBTTtRQUFFLEtBQUssR0FBRyxDQUFDLEtBQUs7UUFBRSxZQUFZO0lBQUs7QUFDL0Q7QUFDQSxJQUFJLGNBQWMsQ0FBQyxJQUFJLE1BQU0sUUFBUTtJQUNuQyxJQUFJLFFBQVEsT0FBTyxTQUFTLFlBQVksT0FBTyxTQUFTLFlBQVk7UUFDbEUsS0FBSyxJQUFJLE9BQU8sa0JBQWtCLE1BQ2hDLElBQUksQ0FBQyxhQUFhLElBQUksQ0FBQyxJQUFJLFFBQVEsUUFBUSxRQUN6QyxVQUFVLElBQUksS0FBSztZQUFFLEtBQUssSUFBTSxJQUFJLENBQUMsSUFBSTtZQUFFLFlBQVksQ0FBQyxDQUFDLE9BQU8saUJBQWlCLE1BQU0sSUFBSSxLQUFLLEtBQUssVUFBVTtRQUFDO0lBQ3RIO0lBQ0EsT0FBTztBQUNUO0FBQ0EsSUFBSSxlQUFlLENBQUMsTUFBUSxZQUFZLFVBQVUsQ0FBQyxHQUFHLGNBQWM7UUFBRSxPQUFPO0lBQUssSUFBSTtBQUV0RixlQUFlO0FBQ2YsSUFBSSxjQUFj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QyxPQUFPLElBQUk7SUFDOUU7SUFDQSxXQUFXO1FBQ1QsT0FBTztlQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTTtTQUFHLENBQUMsR0FBRyxDQUFDLGlCQUFpQixJQUFJLENBQUM7SUFDOUQ7QUFDRjtBQUNBLFNBQVMsUUFBUSxHQUFHLEVBQUUsT0FBTztJQUMzQixRQUFRLE1BQU0sQ0FBQztJQUNmLEtBQUssTUFBTSxHQUFHLE1BQU0sSUFBSSxJQUFLO1FBQzNCLE1BQU0sYUFBYSxnQkFBZ0I7UUFDbkMsUUFBUSxNQUFNLENBQUMsY0FBYztJQUMvQjtBQUNGO0FBQ0EsU0FBUyxnQkFBZ0IsU0FBUztJQUFFLE1BQU07SUFBSSxPQUFPO0FBQUcsQ0FBQztJQUN2RCxJQUFJLE9BQU8sT0FBTyxPQUFPLEtBQUssVUFBVTtRQUN0QyxPQUFPLE9BQU8sR0FBRyxJQUFJLEtBQUssT0FBTyxPQUFPO0lBQzFDO0lBQ0EsSUFBSSxPQUFPLE1BQU0sRUFBRTtRQUNqQixPQUFPLE9BQU8sR0FBRyxJQUFJLEtBQUssS0FBSyxHQUFHLEtBQUssT0FBTyxNQUFNLEdBQUc7SUFDekQ7SUFDQSxJQUFJLE9BQU8sSUFBSSxLQUFLLFFBQVEsT0FBTyxJQUFJLEtBQUssS0FBSyxHQUFHO1FBQ2xELE9BQU8sSUFBSSxHQUFHO0lBQ2hCO0lBQ0EsT0FBTztBQUNUO0FBQ0EsNkRBQTZEO0FBQzdELEtBQUssQ0FBQyxPQUFPLE9BQU8sR0FBRztJQUNyQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0FBQ0YsQ0FBQyIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxMTYzNSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL3NlcnZlci93ZWIvc3BlYy1leHRlbnNpb24vY29va2llcy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQge1xuICBSZXF1ZXN0Q29va2llcyxcbiAgUmVzcG9uc2VDb29raWVzLFxuICBzdHJpbmdpZnlDb29raWUsXG59IGZyb20gJ25leHQvZGlzdC9jb21waWxlZC9AZWRnZS1ydW50aW1lL2Nvb2tpZXMnXG4iXSwibmFtZXMiOlsiUmVxdWVzdENvb2tpZXMiLCJSZXNwb25zZUNvb2tpZXMiLCJzdHJpbmdpZnlDb29raWUiXSwibWFwcGluZ3MiOiI7QUFBQSxTQUNFQSxjQUFjLEVBQ2RDLGVBQWUsRUFDZkMsZUFBZSxRQUNWLDJDQUEwQyIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxMTY0OSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL3NlcnZlci93ZWIvc3BlYy1leHRlbnNpb24vcmVxdWVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IEkxOE5Db25maWcgfSBmcm9tICcuLi8uLi9jb25maWctc2hhcmVkJ1xuaW1wb3J0IHsgTmV4dFVSTCB9IGZyb20gJy4uL25leHQtdXJsJ1xuaW1wb3J0IHsgdG9Ob2RlT3V0Z29pbmdIdHRwSGVhZGVycywgdmFsaWRhdGVVUkwgfSBmcm9tICcuLi91dGlscydcbmltcG9ydCB7IFJlbW92ZWRVQUVycm9yLCBSZW1vdmVkUGFnZUVycm9yIH0gZnJvbSAnLi4vZXJyb3InXG5pbXBvcnQgeyBSZXF1ZXN0Q29va2llcyB9IGZyb20gJy4vY29va2llcydcblxuZXhwb3J0IGNvbnN0IElOVEVSTkFMUyA9IFN5bWJvbCgnaW50ZXJuYWwgcmVxdWVzdCcpXG5cbi8qKlxuICogVGhpcyBjbGFzcyBleHRlbmRzIHRoZSBbV2ViIGBSZXF1ZXN0YCBBUEldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9SZXF1ZXN0KSB3aXRoIGFkZGl0aW9uYWwgY29udmVuaWVuY2UgbWV0aG9kcy5cbiAqXG4gKiBSZWFkIG1vcmU6IFtOZXh0LmpzIERvY3M6IGBOZXh0UmVxdWVzdGBdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9hcGktcmVmZXJlbmNlL2Z1bmN0aW9ucy9uZXh0LXJlcXVlc3QpXG4gKi9cbmV4cG9ydCBjbGFzcyBOZXh0UmVxdWVzdCBleHRlbmRzIFJlcXVlc3Qge1xuICBbSU5URVJOQUxTXToge1xuICAgIGNvb2tpZXM6IFJlcXVlc3RDb29raWVzXG4gICAgdXJsOiBzdHJpbmdcbiAgICBuZXh0VXJsOiBOZXh0VVJMXG4gIH1cblxuICBjb25zdHJ1Y3RvcihpbnB1dDogVVJMIHwgUmVxdWVzdEluZm8sIGluaXQ6IFJlcXVlc3RJbml0ID0ge30pIHtcbiAgICBjb25zdCB1cmwgPVxuICAgICAgdHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJyAmJiAndXJsJyBpbiBpbnB1dCA/IGlucHV0LnVybCA6IFN0cmluZyhpbnB1dClcblxuICAgIHZhbGlkYXRlVVJMKHVybClcblxuICAgIC8vIG5vZGUgUmVxdWVzdCBpbnN0YW5jZSByZXF1aXJlcyBkdXBsZXggb3B0aW9uIHdoZW4gYSBib2R5XG4gICAgLy8gaXMgcHJlc2VudCBvciBpdCBlcnJvcnMsIHdlIGRvbid0IGhhbmRsZSB0aGlzIGZvclxuICAgIC8vIFJlcXVlc3QgYmVpbmcgcGFzc2VkIGluIHNpbmNlIGl0IHdvdWxkIGhhdmUgYWxyZWFkeVxuICAgIC8vIGVycm9yZWQgaWYgdGhpcyB3YXNuJ3QgY29uZmlndXJlZFxuICAgIGlmIChwcm9jZXNzLmVudi5ORVhUX1JVTlRJTUUgIT09ICdlZGdlJykge1xuICAgICAgaWYgKGluaXQuYm9keSAmJiBpbml0LmR1cGxleCAhPT0gJ2hhbGYnKSB7XG4gICAgICAgIGluaXQuZHVwbGV4ID0gJ2hhbGYnXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlucHV0IGluc3RhbmNlb2YgUmVxdWVzdCkgc3VwZXIoaW5wdXQsIGluaXQpXG4gICAgZWxzZSBzdXBlcih1cmwsIGluaXQpXG5cbiAgICBjb25zdCBuZXh0VXJsID0gbmV3IE5leHRVUkwodXJsLCB7XG4gICAgICBoZWFkZXJzOiB0b05vZGVPdXRnb2luZ0h0dHBIZWFkZXJzKHRoaXMuaGVhZGVycyksXG4gICAgICBuZXh0Q29uZmlnOiBpbml0Lm5leHRDb25maWcsXG4gICAgfSlcbiAgICB0aGlzW0lOVEVSTkFMU10gPSB7XG4gICAgICBjb29raWVzOiBuZXcgUmVxdWVzdENvb2tpZXModGhpcy5oZWFkZXJzKSxcbiAgICAgIG5leHRVcmwsXG4gICAgICB1cmw6IHByb2Nlc3MuZW52Ll9fTkVYVF9OT19NSURETEVXQVJFX1VSTF9OT1JNQUxJWkVcbiAgICAgICAgPyB1cmxcbiAgICAgICAgOiBuZXh0VXJsLnRvU3RyaW5nKCksXG4gICAgfVxuICB9XG5cbiAgW1N5bWJvbC5mb3IoJ2VkZ2UtcnVudGltZS5pbnNwZWN0LmN1c3RvbScpXSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29va2llczogdGhpcy5jb29raWVzLFxuICAgICAgbmV4dFVybDogdGhpcy5uZXh0VXJsLFxuICAgICAgdXJsOiB0aGlzLnVybCxcbiAgICAgIC8vIHJlc3Qgb2YgcHJvcHMgY29tZSBmcm9tIFJlcXVlc3RcbiAgICAgIGJvZHlVc2VkOiB0aGlzLmJvZHlVc2VkLFxuICAgICAgY2FjaGU6IHRoaXMuY2FjaGUsXG4gICAgICBjcmVkZW50aWFsczogdGhpcy5jcmVkZW50aWFscyxcbiAgICAgIGRlc3RpbmF0aW9uOiB0aGlzLmRlc3RpbmF0aW9uLFxuICAgICAgaGVhZGVyczogT2JqZWN0LmZyb21FbnRyaWVzKHRoaXMuaGVhZGVycyksXG4gICAgICBpbnRlZ3JpdHk6IHRoaXMuaW50ZWdyaXR5LFxuICAgICAga2VlcGFsaXZlOiB0aGlzLmtlZXBhbGl2ZSxcbiAgICAgIG1ldGhvZDogdGhpcy5tZXRob2QsXG4gICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICByZWRpcmVjdDogdGhpcy5yZWRpcmVjdCxcbiAgICAgIHJlZmVycmVyOiB0aGlzLnJlZmVycmVyLFxuICAgICAgcmVmZXJyZXJQb2xpY3k6IHRoaXMucmVmZXJyZXJQb2xpY3ksXG4gICAgICBzaWduYWw6IHRoaXMuc2lnbmFsLFxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBnZXQgY29va2llcygpIHtcbiAgICByZXR1cm4gdGhpc1tJTlRFUk5BTFNdLmNvb2tpZXNcbiAgfVxuXG4gIHB1YmxpYyBnZXQgbmV4dFVybCgpIHtcbiAgICByZXR1cm4gdGhpc1tJTlRFUk5BTFNdLm5leHRVcmxcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBgcGFnZWAgaGFzIGJlZW4gZGVwcmVjYXRlZCBpbiBmYXZvdXIgb2YgYFVSTFBhdHRlcm5gLlxuICAgKiBSZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL21pZGRsZXdhcmUtcmVxdWVzdC1wYWdlXG4gICAqL1xuICBwdWJsaWMgZ2V0IHBhZ2UoKSB7XG4gICAgdGhyb3cgbmV3IFJlbW92ZWRQYWdlRXJyb3IoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIGB1YWAgaGFzIGJlZW4gcmVtb3ZlZCBpbiBmYXZvdXIgb2YgXFxgdXNlckFnZW50XFxgIGZ1bmN0aW9uLlxuICAgKiBSZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL21pZGRsZXdhcmUtcGFyc2UtdXNlci1hZ2VudFxuICAgKi9cbiAgcHVibGljIGdldCB1YSgpIHtcbiAgICB0aHJvdyBuZXcgUmVtb3ZlZFVBRXJyb3IoKVxuICB9XG5cbiAgcHVibGljIGdldCB1cmwoKSB7XG4gICAgcmV0dXJuIHRoaXNbSU5URVJOQUxTXS51cmxcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlcXVlc3RJbml0IGV4dGVuZHMgZ2xvYmFsVGhpcy5SZXF1ZXN0SW5pdCB7XG4gIG5leHRDb25maWc/OiB7XG4gICAgYmFzZVBhdGg/OiBzdHJpbmdcbiAgICBpMThuPzogSTE4TkNvbmZpZyB8IG51bGxcbiAgICB0cmFpbGluZ1NsYXNoPzogYm9vbGVhblxuICB9XG4gIHNpZ25hbD86IEFib3J0U2lnbmFsXG4gIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2hhdHdnL2ZldGNoL3B1bGwvMTQ1N1xuICBkdXBsZXg/OiAnaGFsZidcbn1cbiJdLCJuYW1lcyI6WyJOZXh0VVJMIiwidG9Ob2RlT3V0Z29pbmdIdHRwSGVhZGVycyIsInZhbGlkYXRlVVJMIiwiUmVtb3ZlZFVBRXJyb3IiLCJSZW1vdmVkUGFnZUVycm9yIiwiUmVxdWVzdENvb2tpZXMiLCJJTlRFUk5BTFMiLCJTeW1ib2wiLCJOZXh0UmVxdWVzdCIsIlJlcXVlc3QiLCJjb25zdHJ1Y3RvciIsImlucHV0IiwiaW5pdCIsInVybCIsIlN0cmluZyIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1JVTlRJTUUiLCJib2R5IiwiZHVwbGV4IiwibmV4dFVybCIsImhlYWRlcnMiLCJuZXh0Q29uZmlnIiwiY29va2llcyIsIl9fTkVYVF9OT19NSURETEVXQVJFX1VSTF9OT1JNQUxJWkUiLCJ0b1N0cmluZyIsImZvciIsImJvZHlVc2VkIiwiY2FjaGUiLCJjcmVkZW50aWFscyIsImRlc3RpbmF0aW9uIiwiT2JqZWN0IiwiZnJvbUVudHJpZXMiLCJpbnRlZ3JpdHkiLCJrZWVwYWxpdmUiLCJtZXRob2QiLCJtb2RlIiwicmVkaXJlY3QiLCJyZWZlcnJlciIsInJlZmVycmVyUG9saWN5Iiwic2lnbmFsIiwicGFnZSIsInVhIl0sIm1hcHBpbmdzIjoiOzs7O0FBQ0EsU0FBU0EsT0FBTyxRQUFRLGNBQWE7QUFDckMsU0FBU0MseUJBQXlCLEVBQUVDLFdBQVcsUUFBUSxXQUFVO0FBQ2pFLFNBQVNDLGNBQWMsRUFBRUMsZ0JBQWdCLFFBQVEsV0FBVTtBQUMzRCxTQUFTQyxjQUFjLFFBQVEsWUFBVzs7Ozs7O0FBRW5DLE1BQU1DLFlBQVlDLE9BQU8sb0JBQW1CO0FBTzVDLE1BQU1DLG9CQUFvQkM7SUFPL0JDLFlBQVlDLEtBQXdCLEVBQUVDLE9BQW9CLENBQUMsQ0FBQyxDQUFFO1FBQzVELE1BQU1DLE1BQ0osT0FBT0YsVUFBVSxZQUFZLFNBQVNBLFFBQVFBLE1BQU1FLEdBQUcsR0FBR0MsT0FBT0g7MEtBRW5FVCxjQUFBQSxFQUFZVztRQUVaLDJEQUEyRDtRQUMzRCxvREFBb0Q7UUFDcEQsc0RBQXNEO1FBQ3RELG9DQUFvQztRQUNwQyxJQUFJRSxRQUFRQyxHQUFHLENBQUNDLFlBQVksS0FBSyxPQUFRO1lBQ3ZDLElBQUlMLEtBQUtNLElBQUksSUFBSU4sS0FBS08sTUFBTSxLQUFLLFFBQVE7Z0JBQ3ZDUCxLQUFLTyxNQUFNLEdBQUc7WUFDaEI7UUFDRjtRQUVBLElBQUlSLGlCQUFpQkYsU0FBUyxLQUFLLENBQUNFLE9BQU9DO2FBQ3RDLEtBQUssQ0FBQ0MsS0FBS0Q7UUFFaEIsTUFBTVEsVUFBVSx3S0FBSXBCLFVBQUFBLENBQVFhLEtBQUs7WUFDL0JRLFNBQVNwQiw4TEFBQUEsRUFBMEIsSUFBSSxDQUFDb0IsT0FBTztZQUMvQ0MsWUFBWVYsS0FBS1UsVUFBVTtRQUM3QjtRQUNBLElBQUksQ0FBQ2hCLFVBQVUsR0FBRztZQUNoQmlCLFNBQVMsc0xBQUlsQixpQkFBQUEsQ0FBZSxJQUFJLENBQUNnQixPQUFPO1lBQ3hDRDtZQUNBUCxLQUFLRSxRQUFRQyxHQUFHLENBQUNRLDBCQUNiWCxRQUQrQyxrQkFFL0NPLFFBQVFLLFFBQVE7UUFDdEI7SUFDRjtJQUVBLENBQUNsQixPQUFPbUIsR0FBRyxDQUFDLCtCQUErQixHQUFHO1FBQzVDLE9BQU87WUFDTEgsU0FBUyxJQUFJLENBQUNBLE9BQU87WUFDckJILFNBQVMsSUFBSSxDQUFDQSxPQUFPO1lBQ3JCUCxLQUFLLElBQUksQ0FBQ0EsR0FBRztZQUNiLGtDQUFrQztZQUNsQ2MsVUFBVSxJQUFJLENBQUNBLFFBQVE7WUFDdkJDLE9BQU8sSUFBSSxDQUFDQSxLQUFLO1lBQ2pCQyxhQUFhLElBQUksQ0FBQ0EsV0FBVztZQUM3QkMsYUFBYSxJQUFJLENBQUNBLFdBQVc7WUFDN0JULFNBQVNVLE9BQU9DLFdBQVcsQ0FBQyxJQUFJLENBQUNYLE9BQU87WUFDeENZLFdBQVcsSUFBSSxDQUFDQSxTQUFTO1lBQ3pCQyxXQUFXLElBQUksQ0FBQ0EsU0FBUztZQUN6QkMsUUFBUSxJQUFJLENBQUNBLE1BQU07WUFDbkJDLE1BQU0sSUFBSSxDQUFDQSxJQUFJO1lBQ2ZDLFVBQVUsSUFBSSxDQUFDQSxRQUFRO1lBQ3ZCQyxVQUFVLElBQUksQ0FBQ0EsUUFBUTtZQUN2QkMsZ0JBQWdCLElBQUksQ0FBQ0EsY0FBYztZQUNuQ0MsUUFBUSxJQUFJLENBQUNBLE1BQU07UUFDckI7SUFDRjtJQUVBLElBQVdqQixVQUFVO1FBQ25CLE9BQU8sSUFBSSxDQUFDakIsVUFBVSxDQUFDaUIsT0FBTztJQUNoQztJQUVBLElBQVdILFVBQVU7UUFDbkIsT0FBTyxJQUFJLENBQUNkLFVBQVUsQ0FBQ2MsT0FBTztJQUNoQztJQUVBOzs7O0dBSUMsR0FDRCxJQUFXcUIsT0FBTztRQUNoQixNQUFNLGtLQUFJckMsbUJBQUFBO0lBQ1o7SUFFQTs7OztHQUlDLEdBQ0QsSUFBV3NDLEtBQUs7UUFDZCxNQUFNLGtLQUFJdkMsaUJBQUFBO0lBQ1o7SUFFQSxJQUFXVSxNQUFNO1FBQ2YsT0FBTyxJQUFJLENBQUNQLFVBQVUsQ0FBQ08sR0FBRztJQUM1QjtBQUNGIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDExNzM3LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zcmMvc2VydmVyL2Jhc2UtaHR0cC9oZWxwZXJzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgQmFzZU5leHRSZXF1ZXN0LCBCYXNlTmV4dFJlc3BvbnNlIH0gZnJvbSAnLi8nXG5pbXBvcnQgdHlwZSB7IE5vZGVOZXh0UmVxdWVzdCwgTm9kZU5leHRSZXNwb25zZSB9IGZyb20gJy4vbm9kZSdcbmltcG9ydCB0eXBlIHsgV2ViTmV4dFJlcXVlc3QsIFdlYk5leHRSZXNwb25zZSB9IGZyb20gJy4vd2ViJ1xuXG4vKipcbiAqIFRoaXMgZmlsZSBwcm92aWRlcyBzb21lIGhlbHBlcnMgdGhhdCBzaG91bGQgYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoXG4gKiBleHBsaWNpdCBlbnZpcm9ubWVudCBjaGVja3MuIFdoZW4gY29tYmluZWQgd2l0aCB0aGUgZW52aXJvbm1lbnQgY2hlY2tzLCBpdFxuICogd2lsbCBlbnN1cmUgdGhhdCB0aGUgY29ycmVjdCB0eXBpbmdzIGFyZSB1c2VkIGFzIHdlbGwgYXMgZW5hYmxlIGNvZGVcbiAqIGVsaW1pbmF0aW9uLlxuICovXG5cbi8qKlxuICogVHlwZSBndWFyZCB0byBkZXRlcm1pbmUgaWYgYSByZXF1ZXN0IGlzIGEgV2ViTmV4dFJlcXVlc3QuIFRoaXMgZG9lcyBub3RcbiAqIGFjdHVhbGx5IGNoZWNrIHRoZSB0eXBlIG9mIHRoZSByZXF1ZXN0LCBidXQgcmF0aGVyIHRoZSBydW50aW1lIGVudmlyb25tZW50LlxuICogSXQncyBleHBlY3RlZCB0aGF0IHdoZW4gdGhlIHJ1bnRpbWUgZW52aXJvbm1lbnQgaXMgdGhlIGVkZ2UgcnVudGltZSwgdGhhdCBhbnlcbiAqIGJhc2UgcmVxdWVzdCBpcyBhIFdlYk5leHRSZXF1ZXN0LlxuICovXG5leHBvcnQgY29uc3QgaXNXZWJOZXh0UmVxdWVzdCA9IChyZXE6IEJhc2VOZXh0UmVxdWVzdCk6IHJlcSBpcyBXZWJOZXh0UmVxdWVzdCA9PlxuICBwcm9jZXNzLmVudi5ORVhUX1JVTlRJTUUgPT09ICdlZGdlJ1xuXG4vKipcbiAqIFR5cGUgZ3VhcmQgdG8gZGV0ZXJtaW5lIGlmIGEgcmVzcG9uc2UgaXMgYSBXZWJOZXh0UmVzcG9uc2UuIFRoaXMgZG9lcyBub3RcbiAqIGFjdHVhbGx5IGNoZWNrIHRoZSB0eXBlIG9mIHRoZSByZXNwb25zZSwgYnV0IHJhdGhlciB0aGUgcnVudGltZSBlbnZpcm9ubWVudC5cbiAqIEl0J3MgZXhwZWN0ZWQgdGhhdCB3aGVuIHRoZSBydW50aW1lIGVudmlyb25tZW50IGlzIHRoZSBlZGdlIHJ1bnRpbWUsIHRoYXQgYW55XG4gKiBiYXNlIHJlc3BvbnNlIGlzIGEgV2ViTmV4dFJlc3BvbnNlLlxuICovXG5leHBvcnQgY29uc3QgaXNXZWJOZXh0UmVzcG9uc2UgPSAoXG4gIHJlczogQmFzZU5leHRSZXNwb25zZVxuKTogcmVzIGlzIFdlYk5leHRSZXNwb25zZSA9PiBwcm9jZXNzLmVudi5ORVhUX1JVTlRJTUUgPT09ICdlZGdlJ1xuXG4vKipcbiAqIFR5cGUgZ3VhcmQgdG8gZGV0ZXJtaW5lIGlmIGEgcmVxdWVzdCBpcyBhIE5vZGVOZXh0UmVxdWVzdC4gVGhpcyBkb2VzIG5vdFxuICogYWN0dWFsbHkgY2hlY2sgdGhlIHR5cGUgb2YgdGhlIHJlcXVlc3QsIGJ1dCByYXRoZXIgdGhlIHJ1bnRpbWUgZW52aXJvbm1lbnQuXG4gKiBJdCdzIGV4cGVjdGVkIHRoYXQgd2hlbiB0aGUgcnVudGltZSBlbnZpcm9ubWVudCBpcyB0aGUgbm9kZSBydW50aW1lLCB0aGF0IGFueVxuICogYmFzZSByZXF1ZXN0IGlzIGEgTm9kZU5leHRSZXF1ZXN0LlxuICovXG5leHBvcnQgY29uc3QgaXNOb2RlTmV4dFJlcXVlc3QgPSAoXG4gIHJlcTogQmFzZU5leHRSZXF1ZXN0XG4pOiByZXEgaXMgTm9kZU5leHRSZXF1ZXN0ID0+IHByb2Nlc3MuZW52Lk5FWFRfUlVOVElNRSAhPT0gJ2VkZ2UnXG5cbi8qKlxuICogVHlwZSBndWFyZCB0byBkZXRlcm1pbmUgaWYgYSByZXNwb25zZSBpcyBhIE5vZGVOZXh0UmVzcG9uc2UuIFRoaXMgZG9lcyBub3RcbiAqIGFjdHVhbGx5IGNoZWNrIHRoZSB0eXBlIG9mIHRoZSByZXNwb25zZSwgYnV0IHJhdGhlciB0aGUgcnVudGltZSBlbnZpcm9ubWVudC5cbiAqIEl0J3MgZXhwZWN0ZWQgdGhhdCB3aGVuIHRoZSBydW50aW1lIGVudmlyb25tZW50IGlzIHRoZSBub2RlIHJ1bnRpbWUsIHRoYXQgYW55XG4gKiBiYXNlIHJlc3BvbnNlIGlzIGEgTm9kZU5leHRSZXNwb25zZS5cbiAqL1xuZXhwb3J0IGNvbnN0IGlzTm9kZU5leHRSZXNwb25zZSA9IChcbiAgcmVzOiBCYXNlTmV4dFJlc3BvbnNlXG4pOiByZXMgaXMgTm9kZU5leHRSZXNwb25zZSA9PiBwcm9jZXNzLmVudi5ORVhUX1JVTlRJTUUgIT09ICdlZGdlJ1xuIl0sIm5hbWVzIjpbImlzV2ViTmV4dFJlcXVlc3QiLCJyZXEiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9SVU5USU1FIiwiaXNXZWJOZXh0UmVzcG9uc2UiLCJyZXMiLCJpc05vZGVOZXh0UmVxdWVzdCIsImlzTm9kZU5leHRSZXNwb25zZSJdLCJtYXBwaW5ncyI6IkFBSUE7Ozs7O0NBS0MsR0FFRDs7Ozs7Q0FLQyxHQUNEOzs7Ozs7QUFBTyxNQUFNQSxtQkFBbUIsQ0FBQ0MsTUFDL0JDLFFBQVFDLEdBQUcsQ0FBQ0MsWUFBWSx1QkFBSyxPQUFNO0FBUTlCLE1BQU1DLG9CQUFvQixDQUMvQkMsTUFDMkJKLFFBQVFDLEdBQUcsQ0FBQ0MsWUFBWSx1QkFBSyxPQUFNO0FBUXpELE1BQU1HLG9CQUFvQixDQUMvQk4sTUFDMkJDLFFBQVFDLEdBQUcsQ0FBQ0MsWUFBWSx1QkFBSyxPQUFNO0FBUXpELE1BQU1JLHFCQUFxQixDQUNoQ0YsTUFDNEJKLFFBQVFDLEdBQUcsQ0FBQ0MsWUFBWSx1QkFBSyxPQUFNIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDExNzYxLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zcmMvc2VydmVyL3dlYi9zcGVjLWV4dGVuc2lvbi9hZGFwdGVycy9uZXh0LXJlcXVlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBCYXNlTmV4dFJlcXVlc3QgfSBmcm9tICcuLi8uLi8uLi9iYXNlLWh0dHAnXG5pbXBvcnQgdHlwZSB7IE5vZGVOZXh0UmVxdWVzdCB9IGZyb20gJy4uLy4uLy4uL2Jhc2UtaHR0cC9ub2RlJ1xuaW1wb3J0IHR5cGUgeyBXZWJOZXh0UmVxdWVzdCB9IGZyb20gJy4uLy4uLy4uL2Jhc2UtaHR0cC93ZWInXG5pbXBvcnQgdHlwZSB7IFdyaXRhYmxlIH0gZnJvbSAnbm9kZTpzdHJlYW0nXG5cbmltcG9ydCB7IGdldFJlcXVlc3RNZXRhIH0gZnJvbSAnLi4vLi4vLi4vcmVxdWVzdC1tZXRhJ1xuaW1wb3J0IHsgZnJvbU5vZGVPdXRnb2luZ0h0dHBIZWFkZXJzIH0gZnJvbSAnLi4vLi4vdXRpbHMnXG5pbXBvcnQgeyBOZXh0UmVxdWVzdCB9IGZyb20gJy4uL3JlcXVlc3QnXG5pbXBvcnQgeyBpc05vZGVOZXh0UmVxdWVzdCwgaXNXZWJOZXh0UmVxdWVzdCB9IGZyb20gJy4uLy4uLy4uL2Jhc2UtaHR0cC9oZWxwZXJzJ1xuXG5leHBvcnQgY29uc3QgUmVzcG9uc2VBYm9ydGVkTmFtZSA9ICdSZXNwb25zZUFib3J0ZWQnXG5leHBvcnQgY2xhc3MgUmVzcG9uc2VBYm9ydGVkIGV4dGVuZHMgRXJyb3Ige1xuICBwdWJsaWMgcmVhZG9ubHkgbmFtZSA9IFJlc3BvbnNlQWJvcnRlZE5hbWVcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIEFib3J0Q29udHJvbGxlciB0aWVkIHRvIHRoZSBjbG9zaW5nIG9mIGEgU2VydmVyUmVzcG9uc2UgKG9yIG90aGVyXG4gKiBhcHByb3ByaWF0ZSBXcml0YWJsZSkuXG4gKlxuICogSWYgdGhlIGBjbG9zZWAgZXZlbnQgaXMgZmlyZWQgYmVmb3JlIHRoZSBgZmluaXNoYCBldmVudCwgdGhlbiB3ZSdsbCBzZW5kIHRoZVxuICogYGFib3J0YCBzaWduYWwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVBYm9ydENvbnRyb2xsZXIocmVzcG9uc2U6IFdyaXRhYmxlKTogQWJvcnRDb250cm9sbGVyIHtcbiAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuXG4gIC8vIElmIGBmaW5pc2hgIGZpcmVzIGZpcnN0LCB0aGVuIGByZXMuZW5kKClgIGhhcyBiZWVuIGNhbGxlZCBhbmQgdGhlIGNsb3NlIGlzXG4gIC8vIGp1c3QgdXMgZmluaXNoaW5nIHRoZSBzdHJlYW0gb24gb3VyIHNpZGUuIElmIGBjbG9zZWAgZmlyZXMgZmlyc3QsIHRoZW4gd2VcbiAgLy8ga25vdyB0aGUgY2xpZW50IGRpc2Nvbm5lY3RlZCBiZWZvcmUgd2UgZmluaXNoZWQuXG4gIHJlc3BvbnNlLm9uY2UoJ2Nsb3NlJywgKCkgPT4ge1xuICAgIGlmIChyZXNwb25zZS53cml0YWJsZUZpbmlzaGVkKSByZXR1cm5cblxuICAgIGNvbnRyb2xsZXIuYWJvcnQobmV3IFJlc3BvbnNlQWJvcnRlZCgpKVxuICB9KVxuXG4gIHJldHVybiBjb250cm9sbGVyXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBBYm9ydFNpZ25hbCB0aWVkIHRvIHRoZSBjbG9zaW5nIG9mIGEgU2VydmVyUmVzcG9uc2UgKG9yIG90aGVyXG4gKiBhcHByb3ByaWF0ZSBXcml0YWJsZSkuXG4gKlxuICogVGhpcyBjYW5ub3QgYmUgZG9uZSB3aXRoIHRoZSByZXF1ZXN0IChJbmNvbWluZ01lc3NhZ2Ugb3IgUmVhZGFibGUpIGJlY2F1c2VcbiAqIHRoZSBgYWJvcnRgIGV2ZW50IHdpbGwgbm90IGZpcmUgaWYgdG8gZGF0YSBoYXMgYmVlbiBmdWxseSByZWFkIChiZWNhdXNlIHRoYXRcbiAqIHdpbGwgXCJjbG9zZVwiIHRoZSByZWFkYWJsZSBzdHJlYW0gYW5kIG5vdGhpbmcgZmlyZXMgYWZ0ZXIgdGhhdCkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaWduYWxGcm9tTm9kZVJlc3BvbnNlKHJlc3BvbnNlOiBXcml0YWJsZSk6IEFib3J0U2lnbmFsIHtcbiAgY29uc3QgeyBlcnJvcmVkLCBkZXN0cm95ZWQgfSA9IHJlc3BvbnNlXG4gIGlmIChlcnJvcmVkIHx8IGRlc3Ryb3llZCkge1xuICAgIHJldHVybiBBYm9ydFNpZ25hbC5hYm9ydChlcnJvcmVkID8/IG5ldyBSZXNwb25zZUFib3J0ZWQoKSlcbiAgfVxuXG4gIGNvbnN0IHsgc2lnbmFsIH0gPSBjcmVhdGVBYm9ydENvbnRyb2xsZXIocmVzcG9uc2UpXG4gIHJldHVybiBzaWduYWxcbn1cblxuZXhwb3J0IGNsYXNzIE5leHRSZXF1ZXN0QWRhcHRlciB7XG4gIHB1YmxpYyBzdGF0aWMgZnJvbUJhc2VOZXh0UmVxdWVzdChcbiAgICByZXF1ZXN0OiBCYXNlTmV4dFJlcXVlc3QsXG4gICAgc2lnbmFsOiBBYm9ydFNpZ25hbFxuICApOiBOZXh0UmVxdWVzdCB7XG4gICAgaWYgKFxuICAgICAgLy8gVGhlIHR5cGUgY2hlY2sgaGVyZSBlbnN1cmVzIHRoYXQgYHJlcWAgaXMgY29ycmVjdGx5IHR5cGVkLCBhbmQgdGhlXG4gICAgICAvLyBlbnZpcm9ubWVudCB2YXJpYWJsZSBjaGVjayBwcm92aWRlcyBkZWFkIGNvZGUgZWxpbWluYXRpb24uXG4gICAgICBwcm9jZXNzLmVudi5ORVhUX1JVTlRJTUUgPT09ICdlZGdlJyAmJlxuICAgICAgaXNXZWJOZXh0UmVxdWVzdChyZXF1ZXN0KVxuICAgICkge1xuICAgICAgcmV0dXJuIE5leHRSZXF1ZXN0QWRhcHRlci5mcm9tV2ViTmV4dFJlcXVlc3QocmVxdWVzdClcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgLy8gVGhlIHR5cGUgY2hlY2sgaGVyZSBlbnN1cmVzIHRoYXQgYHJlcWAgaXMgY29ycmVjdGx5IHR5cGVkLCBhbmQgdGhlXG4gICAgICAvLyBlbnZpcm9ubWVudCB2YXJpYWJsZSBjaGVjayBwcm92aWRlcyBkZWFkIGNvZGUgZWxpbWluYXRpb24uXG4gICAgICBwcm9jZXNzLmVudi5ORVhUX1JVTlRJTUUgIT09ICdlZGdlJyAmJlxuICAgICAgaXNOb2RlTmV4dFJlcXVlc3QocmVxdWVzdClcbiAgICApIHtcbiAgICAgIHJldHVybiBOZXh0UmVxdWVzdEFkYXB0ZXIuZnJvbU5vZGVOZXh0UmVxdWVzdChyZXF1ZXN0LCBzaWduYWwpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YXJpYW50OiBVbnN1cHBvcnRlZCBOZXh0UmVxdWVzdCB0eXBlJylcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGZyb21Ob2RlTmV4dFJlcXVlc3QoXG4gICAgcmVxdWVzdDogTm9kZU5leHRSZXF1ZXN0LFxuICAgIHNpZ25hbDogQWJvcnRTaWduYWxcbiAgKTogTmV4dFJlcXVlc3Qge1xuICAgIC8vIEhFQUQgYW5kIEdFVCByZXF1ZXN0cyBjYW4gbm90IGhhdmUgYSBib2R5LlxuICAgIGxldCBib2R5OiBCb2R5SW5pdCB8IG51bGwgPSBudWxsXG4gICAgaWYgKHJlcXVlc3QubWV0aG9kICE9PSAnR0VUJyAmJiByZXF1ZXN0Lm1ldGhvZCAhPT0gJ0hFQUQnICYmIHJlcXVlc3QuYm9keSkge1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtIHRoaXMgaXMgaGFuZGxlZCBieSB1bmRpY2ksIHdoZW4gc3RyZWFtcy93ZWIgbGFuZCB1c2UgaXQgaW5zdGVhZFxuICAgICAgYm9keSA9IHJlcXVlc3QuYm9keVxuICAgIH1cblxuICAgIGxldCB1cmw6IFVSTFxuICAgIGlmIChyZXF1ZXN0LnVybC5zdGFydHNXaXRoKCdodHRwJykpIHtcbiAgICAgIHVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEdyYWIgdGhlIGZ1bGwgVVJMIGZyb20gdGhlIHJlcXVlc3QgbWV0YWRhdGEuXG4gICAgICBjb25zdCBiYXNlID0gZ2V0UmVxdWVzdE1ldGEocmVxdWVzdCwgJ2luaXRVUkwnKVxuICAgICAgaWYgKCFiYXNlIHx8ICFiYXNlLnN0YXJ0c1dpdGgoJ2h0dHAnKSkge1xuICAgICAgICAvLyBCZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0aW9uIHJlbGllcyBvbiB0aGUgZmFjdCB0aGF0IHRoZSBVUkwgcHJvdmlkZWRcbiAgICAgICAgLy8gaXMgYWJzb2x1dGUsIHdlIG5lZWQgdG8gcHJvdmlkZSBhIGJhc2UgVVJMLiBXZSBjYW4ndCB1c2UgdGhlIHJlcXVlc3RcbiAgICAgICAgLy8gVVJMIGJlY2F1c2UgaXQncyByZWxhdGl2ZSwgc28gd2UgdXNlIGEgZHVtbXkgVVJMIGluc3RlYWQuXG4gICAgICAgIHVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwsICdodHRwOi8vbicpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cmwgPSBuZXcgVVJMKHJlcXVlc3QudXJsLCBiYXNlKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgTmV4dFJlcXVlc3QodXJsLCB7XG4gICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgICAgaGVhZGVyczogZnJvbU5vZGVPdXRnb2luZ0h0dHBIZWFkZXJzKHJlcXVlc3QuaGVhZGVycyksXG4gICAgICBkdXBsZXg6ICdoYWxmJyxcbiAgICAgIHNpZ25hbCxcbiAgICAgIC8vIGdlb1xuICAgICAgLy8gaXBcbiAgICAgIC8vIG5leHRDb25maWdcblxuICAgICAgLy8gYm9keSBjYW4gbm90IGJlIHBhc3NlZCBpZiByZXF1ZXN0IHdhcyBhYm9ydGVkXG4gICAgICAvLyBvciB3ZSBnZXQgYSBSZXF1ZXN0IGJvZHkgd2FzIGRpc3R1cmJlZCBlcnJvclxuICAgICAgLi4uKHNpZ25hbC5hYm9ydGVkXG4gICAgICAgID8ge31cbiAgICAgICAgOiB7XG4gICAgICAgICAgICBib2R5LFxuICAgICAgICAgIH0pLFxuICAgIH0pXG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGZyb21XZWJOZXh0UmVxdWVzdChyZXF1ZXN0OiBXZWJOZXh0UmVxdWVzdCk6IE5leHRSZXF1ZXN0IHtcbiAgICAvLyBIRUFEIGFuZCBHRVQgcmVxdWVzdHMgY2FuIG5vdCBoYXZlIGEgYm9keS5cbiAgICBsZXQgYm9keTogUmVhZGFibGVTdHJlYW0gfCBudWxsID0gbnVsbFxuICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCAhPT0gJ0dFVCcgJiYgcmVxdWVzdC5tZXRob2QgIT09ICdIRUFEJykge1xuICAgICAgYm9keSA9IHJlcXVlc3QuYm9keVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgTmV4dFJlcXVlc3QocmVxdWVzdC51cmwsIHtcbiAgICAgIG1ldGhvZDogcmVxdWVzdC5tZXRob2QsXG4gICAgICBoZWFkZXJzOiBmcm9tTm9kZU91dGdvaW5nSHR0cEhlYWRlcnMocmVxdWVzdC5oZWFkZXJzKSxcbiAgICAgIGR1cGxleDogJ2hhbGYnLFxuICAgICAgc2lnbmFsOiByZXF1ZXN0LnJlcXVlc3Quc2lnbmFsLFxuICAgICAgLy8gZ2VvXG4gICAgICAvLyBpcFxuICAgICAgLy8gbmV4dENvbmZpZ1xuXG4gICAgICAvLyBib2R5IGNhbiBub3QgYmUgcGFzc2VkIGlmIHJlcXVlc3Qgd2FzIGFib3J0ZWRcbiAgICAgIC8vIG9yIHdlIGdldCBhIFJlcXVlc3QgYm9keSB3YXMgZGlzdHVyYmVkIGVycm9yXG4gICAgICAuLi4ocmVxdWVzdC5yZXF1ZXN0LnNpZ25hbC5hYm9ydGVkXG4gICAgICAgID8ge31cbiAgICAgICAgOiB7XG4gICAgICAgICAgICBib2R5LFxuICAgICAgICAgIH0pLFxuICAgIH0pXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJnZXRSZXF1ZXN0TWV0YSIsImZyb21Ob2RlT3V0Z29pbmdIdHRwSGVhZGVycyIsIk5leHRSZXF1ZXN0IiwiaXNOb2RlTmV4dFJlcXVlc3QiLCJpc1dlYk5leHRSZXF1ZXN0IiwiUmVzcG9uc2VBYm9ydGVkTmFtZSIsIlJlc3BvbnNlQWJvcnRlZCIsIkVycm9yIiwibmFtZSIsImNyZWF0ZUFib3J0Q29udHJvbGxlciIsInJlc3BvbnNlIiwiY29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlciIsIm9uY2UiLCJ3cml0YWJsZUZpbmlzaGVkIiwiYWJvcnQiLCJzaWduYWxGcm9tTm9kZVJlc3BvbnNlIiwiZXJyb3JlZCIsImRlc3Ryb3llZCIsIkFib3J0U2lnbmFsIiwic2lnbmFsIiwiTmV4dFJlcXVlc3RBZGFwdGVyIiwiZnJvbUJhc2VOZXh0UmVxdWVzdCIsInJlcXVlc3QiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9SVU5USU1FIiwiZnJvbVdlYk5leHRSZXF1ZXN0IiwiZnJvbU5vZGVOZXh0UmVxdWVzdCIsImJvZHkiLCJtZXRob2QiLCJ1cmwiLCJzdGFydHNXaXRoIiwiVVJMIiwiYmFzZSIsImhlYWRlcnMiLCJkdXBsZXgiLCJhYm9ydGVkIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBS0EsU0FBU0EsY0FBYyxRQUFRLHdCQUF1QjtBQUN0RCxTQUFTQywyQkFBMkIsUUFBUSxjQUFhO0FBQ3pELFNBQVNDLFdBQVcsUUFBUSxhQUFZO0FBQ3hDLFNBQVNDLGlCQUFpQixFQUFFQyxnQkFBZ0IsUUFBUSw2QkFBNEI7Ozs7O0FBRXpFLE1BQU1DLHNCQUFzQixrQkFBaUI7QUFDN0MsTUFBTUMsd0JBQXdCQzs7UUFBOUIsS0FBQSxJQUFBLE9BQUEsSUFBQSxDQUNXQyxJQUFBQSxHQUFPSDs7QUFDekI7QUFTTyxTQUFTSSxzQkFBc0JDLFFBQWtCO0lBQ3RELE1BQU1DLGFBQWEsSUFBSUM7SUFFdkIsNkVBQTZFO0lBQzdFLDRFQUE0RTtJQUM1RSxtREFBbUQ7SUFDbkRGLFNBQVNHLElBQUksQ0FBQyxTQUFTO1FBQ3JCLElBQUlILFNBQVNJLGdCQUFnQixFQUFFO1FBRS9CSCxXQUFXSSxLQUFLLENBQUMsSUFBSVQ7SUFDdkI7SUFFQSxPQUFPSztBQUNUO0FBVU8sU0FBU0ssdUJBQXVCTixRQUFrQjtJQUN2RCxNQUFNLEVBQUVPLE9BQU8sRUFBRUMsU0FBUyxFQUFFLEdBQUdSO0lBQy9CLElBQUlPLFdBQVdDLFdBQVc7UUFDeEIsT0FBT0MsWUFBWUosS0FBSyxDQUFDRSxXQUFXLElBQUlYO0lBQzFDO0lBRUEsTUFBTSxFQUFFYyxNQUFNLEVBQUUsR0FBR1gsc0JBQXNCQztJQUN6QyxPQUFPVTtBQUNUO0FBRU8sTUFBTUM7SUFDWCxPQUFjQyxvQkFDWkMsT0FBd0IsRUFDeEJILE1BQW1CLEVBQ047UUFDYixJQUVFLEFBREEsNkRBQzZELFFBRFE7UUFFckVJLFFBQVFDLEdBQUcsQ0FBQ0MsWUFBWSx1QkFBSyx1TEFDN0J0QixtQkFBQUEsRUFBaUJtQixVQUNqQjs7YUFFSyxJQUNMLEFBQ0EsNkRBQTZELFFBRFE7UUFFckVDLFFBQVFDLEdBQUcsQ0FBQ0MsWUFBWSx1QkFBSyxXQUM3QnZCLGdNQUFBQSxFQUFrQm9CLFVBQ2xCO1lBQ0EsT0FBT0YsbUJBQW1CTyxtQkFBbUIsQ0FBQ0wsU0FBU0g7UUFDekQsT0FBTztZQUNMLE1BQU0sT0FBQSxjQUFvRCxDQUFwRCxJQUFJYixNQUFNLDRDQUFWLHFCQUFBO3VCQUFBOzRCQUFBOzhCQUFBO1lBQW1EO1FBQzNEO0lBQ0Y7SUFFQSxPQUFjcUIsb0JBQ1pMLE9BQXdCLEVBQ3hCSCxNQUFtQixFQUNOO1FBQ2IsNkNBQTZDO1FBQzdDLElBQUlTLE9BQXdCO1FBQzVCLElBQUlOLFFBQVFPLE1BQU0sS0FBSyxTQUFTUCxRQUFRTyxNQUFNLEtBQUssVUFBVVAsUUFBUU0sSUFBSSxFQUFFO1lBQ3pFLHFGQUFxRjtZQUNyRkEsT0FBT04sUUFBUU0sSUFBSTtRQUNyQjtRQUVBLElBQUlFO1FBQ0osSUFBSVIsUUFBUVEsR0FBRyxDQUFDQyxVQUFVLENBQUMsU0FBUztZQUNsQ0QsTUFBTSxJQUFJRSxJQUFJVixRQUFRUSxHQUFHO1FBQzNCLE9BQU87WUFDTCwrQ0FBK0M7WUFDL0MsTUFBTUcsNEtBQU9sQyxpQkFBQUEsRUFBZXVCLFNBQVM7WUFDckMsSUFBSSxDQUFDVyxRQUFRLENBQUNBLEtBQUtGLFVBQVUsQ0FBQyxTQUFTO2dCQUNyQyx3RUFBd0U7Z0JBQ3hFLHVFQUF1RTtnQkFDdkUsNERBQTREO2dCQUM1REQsTUFBTSxJQUFJRSxJQUFJVixRQUFRUSxHQUFHLEVBQUU7WUFDN0IsT0FBTztnQkFDTEEsTUFBTSxJQUFJRSxJQUFJVixRQUFRUSxHQUFHLEVBQUVHO1lBQzdCO1FBQ0Y7UUFFQSxPQUFPLHlMQUFJaEMsY0FBQUEsQ0FBWTZCLEtBQUs7WUFDMUJELFFBQVFQLFFBQVFPLE1BQU07WUFDdEJLLFVBQVNsQywrTEFBQUEsRUFBNEJzQixRQUFRWSxPQUFPO1lBQ3BEQyxRQUFRO1lBQ1JoQjtZQUNBLE1BQU07WUFDTixLQUFLO1lBQ0wsYUFBYTtZQUViLGdEQUFnRDtZQUNoRCwrQ0FBK0M7WUFDL0MsR0FBSUEsT0FBT2lCLE9BQU8sR0FDZCxDQUFDLElBQ0Q7Z0JBQ0VSO1lBQ0YsQ0FBQztRQUNQO0lBQ0Y7SUFFQSxPQUFjRixtQkFBbUJKLE9BQXVCLEVBQWU7UUFDckUsNkNBQTZDO1FBQzdDLElBQUlNLE9BQThCO1FBQ2xDLElBQUlOLFFBQVFPLE1BQU0sS0FBSyxTQUFTUCxRQUFRTyxNQUFNLEtBQUssUUFBUTtZQUN6REQsT0FBT04sUUFBUU0sSUFBSTtRQUNyQjtRQUVBLE9BQU8seUxBQUkzQixjQUFBQSxDQUFZcUIsUUFBUVEsR0FBRyxFQUFFO1lBQ2xDRCxRQUFRUCxRQUFRTyxNQUFNO1lBQ3RCSywyS0FBU2xDLDhCQUFBQSxFQUE0QnNCLFFBQVFZLE9BQU87WUFDcERDLFFBQVE7WUFDUmhCLFFBQVFHLFFBQVFBLE9BQU8sQ0FBQ0gsTUFBTTtZQUM5QixNQUFNO1lBQ04sS0FBSztZQUNMLGFBQWE7WUFFYixnREFBZ0Q7WUFDaEQsK0NBQStDO1lBQy9DLEdBQUlHLFFBQVFBLE9BQU8sQ0FBQ0gsTUFBTSxDQUFDaUIsT0FBTyxHQUM5QixDQUFDLElBQ0Q7Z0JBQ0VSO1lBQ0YsQ0FBQztRQUNQO0lBQ0Y7QUFDRiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxMTg4MCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL3NlcnZlci9jbGllbnQtY29tcG9uZW50LXJlbmRlcmVyLWxvZ2dlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IEFwcFBhZ2VNb2R1bGUgfSBmcm9tICcuL3JvdXRlLW1vZHVsZXMvYXBwLXBhZ2UvbW9kdWxlJ1xuXG4vLyBDb21iaW5lZCBsb2FkIHRpbWVzIGZvciBsb2FkaW5nIGNsaWVudCBjb21wb25lbnRzXG5sZXQgY2xpZW50Q29tcG9uZW50TG9hZFN0YXJ0ID0gMFxubGV0IGNsaWVudENvbXBvbmVudExvYWRUaW1lcyA9IDBcbmxldCBjbGllbnRDb21wb25lbnRMb2FkQ291bnQgPSAwXG5cbmV4cG9ydCBmdW5jdGlvbiB3cmFwQ2xpZW50Q29tcG9uZW50TG9hZGVyKFxuICBDb21wb25lbnRNb2Q6IEFwcFBhZ2VNb2R1bGVcbik6IEFwcFBhZ2VNb2R1bGVbJ19fbmV4dF9hcHBfXyddIHtcbiAgaWYgKCEoJ3BlcmZvcm1hbmNlJyBpbiBnbG9iYWxUaGlzKSkge1xuICAgIHJldHVybiBDb21wb25lbnRNb2QuX19uZXh0X2FwcF9fXG4gIH1cblxuICByZXR1cm4ge1xuICAgIHJlcXVpcmU6ICguLi5hcmdzKSA9PiB7XG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKVxuXG4gICAgICBpZiAoY2xpZW50Q29tcG9uZW50TG9hZFN0YXJ0ID09PSAwKSB7XG4gICAgICAgIGNsaWVudENvbXBvbmVudExvYWRTdGFydCA9IHN0YXJ0VGltZVxuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICBjbGllbnRDb21wb25lbnRMb2FkQ291bnQgKz0gMVxuICAgICAgICByZXR1cm4gQ29tcG9uZW50TW9kLl9fbmV4dF9hcHBfXy5yZXF1aXJlKC4uLmFyZ3MpXG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBjbGllbnRDb21wb25lbnRMb2FkVGltZXMgKz0gcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydFRpbWVcbiAgICAgIH1cbiAgICB9LFxuICAgIGxvYWRDaHVuazogKC4uLmFyZ3MpID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgICBjb25zdCByZXN1bHQgPSBDb21wb25lbnRNb2QuX19uZXh0X2FwcF9fLmxvYWRDaHVuayguLi5hcmdzKVxuICAgICAgLy8gQXZvaWQgd3JhcHBpbmcgYGxvYWRDaHVua2AncyByZXN1bHQgaW4gYW4gZXh0cmEgcHJvbWlzZSBpbiBjYXNlIHNvbWV0aGluZyBsaWtlIFJlYWN0IGRlcGVuZHMgb24gaXRzIGlkZW50aXR5LlxuICAgICAgLy8gV2Ugb25seSBuZWVkIHRvIGtub3cgd2hlbiBpdCdzIHNldHRsZWQuXG4gICAgICByZXN1bHQuZmluYWxseSgoKSA9PiB7XG4gICAgICAgIGNsaWVudENvbXBvbmVudExvYWRUaW1lcyArPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZVxuICAgICAgfSlcbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9LFxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDbGllbnRDb21wb25lbnRMb2FkZXJNZXRyaWNzKFxuICBvcHRpb25zOiB7IHJlc2V0PzogYm9vbGVhbiB9ID0ge31cbikge1xuICBjb25zdCBtZXRyaWNzID1cbiAgICBjbGllbnRDb21wb25lbnRMb2FkU3RhcnQgPT09IDBcbiAgICAgID8gdW5kZWZpbmVkXG4gICAgICA6IHtcbiAgICAgICAgICBjbGllbnRDb21wb25lbnRMb2FkU3RhcnQsXG4gICAgICAgICAgY2xpZW50Q29tcG9uZW50TG9hZFRpbWVzLFxuICAgICAgICAgIGNsaWVudENvbXBvbmVudExvYWRDb3VudCxcbiAgICAgICAgfVxuXG4gIGlmIChvcHRpb25zLnJlc2V0KSB7XG4gICAgY2xpZW50Q29tcG9uZW50TG9hZFN0YXJ0ID0gMFxuICAgIGNsaWVudENvbXBvbmVudExvYWRUaW1lcyA9IDBcbiAgICBjbGllbnRDb21wb25lbnRMb2FkQ291bnQgPSAwXG4gIH1cblxuICByZXR1cm4gbWV0cmljc1xufVxuIl0sIm5hbWVzIjpbImNsaWVudENvbXBvbmVudExvYWRTdGFydCIsImNsaWVudENvbXBvbmVudExvYWRUaW1lcyIsImNsaWVudENvbXBvbmVudExvYWRDb3VudCIsIndyYXBDbGllbnRDb21wb25lbnRMb2FkZXIiLCJDb21wb25lbnRNb2QiLCJnbG9iYWxUaGlzIiwiX19uZXh0X2FwcF9fIiwicmVxdWlyZSIsImFyZ3MiLCJzdGFydFRpbWUiLCJwZXJmb3JtYW5jZSIsIm5vdyIsImxvYWRDaHVuayIsInJlc3VsdCIsImZpbmFsbHkiLCJnZXRDbGllbnRDb21wb25lbnRMb2FkZXJNZXRyaWNzIiwib3B0aW9ucyIsIm1ldHJpY3MiLCJ1bmRlZmluZWQiLCJyZXNldCJdLCJtYXBwaW5ncyI6IkFBRUEsb0RBQW9EOzs7OztBQUNwRCxJQUFJQSwyQkFBMkI7QUFDL0IsSUFBSUMsMkJBQTJCO0FBQy9CLElBQUlDLDJCQUEyQjtBQUV4QixTQUFTQywwQkFDZEMsWUFBMkI7SUFFM0IsSUFBSSxDQUFFLENBQUEsaUJBQWlCQyxVQUFTLEdBQUk7UUFDbEMsT0FBT0QsYUFBYUUsWUFBWTtJQUNsQztJQUVBLE9BQU87UUFDTEMsU0FBUyxDQUFDLEdBQUdDO1lBQ1gsTUFBTUMsWUFBWUMsWUFBWUMsR0FBRztZQUVqQyxJQUFJWCw2QkFBNkIsR0FBRztnQkFDbENBLDJCQUEyQlM7WUFDN0I7WUFFQSxJQUFJO2dCQUNGUCw0QkFBNEI7Z0JBQzVCLE9BQU9FLGFBQWFFLFlBQVksQ0FBQ0MsT0FBTyxJQUFJQztZQUM5QyxTQUFVO2dCQUNSUCw0QkFBNEJTLFlBQVlDLEdBQUcsS0FBS0Y7WUFDbEQ7UUFDRjtRQUNBRyxXQUFXLENBQUMsR0FBR0o7WUFDYixNQUFNQyxZQUFZQyxZQUFZQyxHQUFHO1lBQ2pDLE1BQU1FLFNBQVNULGFBQWFFLFlBQVksQ0FBQ00sU0FBUyxJQUFJSjtZQUN0RCxnSEFBZ0g7WUFDaEgsMENBQTBDO1lBQzFDSyxPQUFPQyxPQUFPLENBQUM7Z0JBQ2JiLDRCQUE0QlMsWUFBWUMsR0FBRyxLQUFLRjtZQUNsRDtZQUNBLE9BQU9JO1FBQ1Q7SUFDRjtBQUNGO0FBRU8sU0FBU0UsZ0NBQ2RDLFVBQStCLENBQUMsQ0FBQztJQUVqQyxNQUFNQyxVQUNKakIsNkJBQTZCLElBQ3pCa0IsWUFDQTtRQUNFbEI7UUFDQUM7UUFDQUM7SUFDRjtJQUVOLElBQUljLFFBQVFHLEtBQUssRUFBRTtRQUNqQm5CLDJCQUEyQjtRQUMzQkMsMkJBQTJCO1FBQzNCQywyQkFBMkI7SUFDN0I7SUFFQSxPQUFPZTtBQUNUIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDExOTM0LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zcmMvc2VydmVyL3BpcGUtcmVhZGFibGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBTZXJ2ZXJSZXNwb25zZSB9IGZyb20gJ25vZGU6aHR0cCdcblxuaW1wb3J0IHtcbiAgUmVzcG9uc2VBYm9ydGVkTmFtZSxcbiAgY3JlYXRlQWJvcnRDb250cm9sbGVyLFxufSBmcm9tICcuL3dlYi9zcGVjLWV4dGVuc2lvbi9hZGFwdGVycy9uZXh0LXJlcXVlc3QnXG5pbXBvcnQgeyBEZXRhY2hlZFByb21pc2UgfSBmcm9tICcuLi9saWIvZGV0YWNoZWQtcHJvbWlzZSdcbmltcG9ydCB7IGdldFRyYWNlciB9IGZyb20gJy4vbGliL3RyYWNlL3RyYWNlcidcbmltcG9ydCB7IE5leHROb2RlU2VydmVyU3BhbiB9IGZyb20gJy4vbGliL3RyYWNlL2NvbnN0YW50cydcbmltcG9ydCB7IGdldENsaWVudENvbXBvbmVudExvYWRlck1ldHJpY3MgfSBmcm9tICcuL2NsaWVudC1jb21wb25lbnQtcmVuZGVyZXItbG9nZ2VyJ1xuXG5leHBvcnQgZnVuY3Rpb24gaXNBYm9ydEVycm9yKGU6IGFueSk6IGUgaXMgRXJyb3IgJiB7IG5hbWU6ICdBYm9ydEVycm9yJyB9IHtcbiAgcmV0dXJuIGU/Lm5hbWUgPT09ICdBYm9ydEVycm9yJyB8fCBlPy5uYW1lID09PSBSZXNwb25zZUFib3J0ZWROYW1lXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVdyaXRlckZyb21SZXNwb25zZShcbiAgcmVzOiBTZXJ2ZXJSZXNwb25zZSxcbiAgd2FpdFVudGlsRm9yRW5kPzogUHJvbWlzZTx1bmtub3duPlxuKTogV3JpdGFibGVTdHJlYW08VWludDhBcnJheT4ge1xuICBsZXQgc3RhcnRlZCA9IGZhbHNlXG5cbiAgLy8gQ3JlYXRlIGEgcHJvbWlzZSB0aGF0IHdpbGwgcmVzb2x2ZSBvbmNlIHRoZSByZXNwb25zZSBoYXMgZHJhaW5lZC4gU2VlXG4gIC8vIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvc3RyZWFtLmh0bWwjc3RyZWFtX2V2ZW50X2RyYWluXG4gIGxldCBkcmFpbmVkID0gbmV3IERldGFjaGVkUHJvbWlzZTx2b2lkPigpXG4gIGZ1bmN0aW9uIG9uRHJhaW4oKSB7XG4gICAgZHJhaW5lZC5yZXNvbHZlKClcbiAgfVxuICByZXMub24oJ2RyYWluJywgb25EcmFpbilcblxuICAvLyBJZiB0aGUgZmluaXNoIGV2ZW50IGZpcmVzLCBpdCBtZWFucyB3ZSBzaG91bGRuJ3QgYmxvY2sgYW5kIHdhaXQgZm9yIHRoZVxuICAvLyBkcmFpbiBldmVudC5cbiAgcmVzLm9uY2UoJ2Nsb3NlJywgKCkgPT4ge1xuICAgIHJlcy5vZmYoJ2RyYWluJywgb25EcmFpbilcbiAgICBkcmFpbmVkLnJlc29sdmUoKVxuICB9KVxuXG4gIC8vIENyZWF0ZSBhIHByb21pc2UgdGhhdCB3aWxsIHJlc29sdmUgb25jZSB0aGUgcmVzcG9uc2UgaGFzIGZpbmlzaGVkLiBTZWVcbiAgLy8gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9odHRwLmh0bWwjZXZlbnQtZmluaXNoXzFcbiAgY29uc3QgZmluaXNoZWQgPSBuZXcgRGV0YWNoZWRQcm9taXNlPHZvaWQ+KClcbiAgcmVzLm9uY2UoJ2ZpbmlzaCcsICgpID0+IHtcbiAgICBmaW5pc2hlZC5yZXNvbHZlKClcbiAgfSlcblxuICAvLyBDcmVhdGUgYSB3cml0YWJsZSBzdHJlYW0gdGhhdCB3aWxsIHdyaXRlIHRvIHRoZSByZXNwb25zZS5cbiAgcmV0dXJuIG5ldyBXcml0YWJsZVN0cmVhbTxVaW50OEFycmF5Pih7XG4gICAgd3JpdGU6IGFzeW5jIChjaHVuaykgPT4ge1xuICAgICAgLy8gWW91J2QgdGhpbmsgd2UnZCB3YW50IHRvIHVzZSBgc3RhcnRgIGluc3RlYWQgb2YgcGxhY2luZyB0aGlzIGluIGB3cml0ZWBcbiAgICAgIC8vIGJ1dCB0aGlzIGVuc3VyZXMgdGhhdCB3ZSBkb24ndCBhY3R1YWxseSBmbHVzaCB0aGUgaGVhZGVycyB1bnRpbCB3ZSd2ZVxuICAgICAgLy8gc3RhcnRlZCB3cml0aW5nIGNodW5rcy5cbiAgICAgIGlmICghc3RhcnRlZCkge1xuICAgICAgICBzdGFydGVkID0gdHJ1ZVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAncGVyZm9ybWFuY2UnIGluIGdsb2JhbFRoaXMgJiZcbiAgICAgICAgICBwcm9jZXNzLmVudi5ORVhUX09URUxfUEVSRk9STUFOQ0VfUFJFRklYXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IG1ldHJpY3MgPSBnZXRDbGllbnRDb21wb25lbnRMb2FkZXJNZXRyaWNzKClcbiAgICAgICAgICBpZiAobWV0cmljcykge1xuICAgICAgICAgICAgcGVyZm9ybWFuY2UubWVhc3VyZShcbiAgICAgICAgICAgICAgYCR7cHJvY2Vzcy5lbnYuTkVYVF9PVEVMX1BFUkZPUk1BTkNFX1BSRUZJWH06bmV4dC1jbGllbnQtY29tcG9uZW50LWxvYWRpbmdgLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IG1ldHJpY3MuY2xpZW50Q29tcG9uZW50TG9hZFN0YXJ0LFxuICAgICAgICAgICAgICAgIGVuZDpcbiAgICAgICAgICAgICAgICAgIG1ldHJpY3MuY2xpZW50Q29tcG9uZW50TG9hZFN0YXJ0ICtcbiAgICAgICAgICAgICAgICAgIG1ldHJpY3MuY2xpZW50Q29tcG9uZW50TG9hZFRpbWVzLFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmVzLmZsdXNoSGVhZGVycygpXG4gICAgICAgIGdldFRyYWNlcigpLnRyYWNlKFxuICAgICAgICAgIE5leHROb2RlU2VydmVyU3Bhbi5zdGFydFJlc3BvbnNlLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHNwYW5OYW1lOiAnc3RhcnQgcmVzcG9uc2UnLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgKCkgPT4gdW5kZWZpbmVkXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgb2sgPSByZXMud3JpdGUoY2h1bmspXG5cbiAgICAgICAgLy8gQWRkZWQgYnkgdGhlIGBjb21wcmVzc2lvbmAgbWlkZGxld2FyZSwgdGhpcyBpcyBhIGZ1bmN0aW9uIHRoYXQgd2lsbFxuICAgICAgICAvLyBmbHVzaCB0aGUgcGFydGlhbGx5LWNvbXByZXNzZWQgcmVzcG9uc2UgdG8gdGhlIGNsaWVudC5cbiAgICAgICAgaWYgKCdmbHVzaCcgaW4gcmVzICYmIHR5cGVvZiByZXMuZmx1c2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXMuZmx1c2goKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlIHdyaXRlIHJldHVybnMgZmFsc2UsIGl0IG1lYW5zIHRoZXJlJ3Mgc29tZSBiYWNrcHJlc3N1cmUsIHNvXG4gICAgICAgIC8vIHdhaXQgdW50aWwgaXQncyBzdHJlYW1lZCBiZWZvcmUgY29udGludWluZy5cbiAgICAgICAgaWYgKCFvaykge1xuICAgICAgICAgIGF3YWl0IGRyYWluZWQucHJvbWlzZVxuXG4gICAgICAgICAgLy8gUmVzZXQgdGhlIGRyYWluZWQgcHJvbWlzZSBzbyB0aGF0IHdlIGNhbiB3YWl0IGZvciB0aGUgbmV4dCBkcmFpbiBldmVudC5cbiAgICAgICAgICBkcmFpbmVkID0gbmV3IERldGFjaGVkUHJvbWlzZTx2b2lkPigpXG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXMuZW5kKClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmYWlsZWQgdG8gd3JpdGUgY2h1bmsgdG8gcmVzcG9uc2UnLCB7IGNhdXNlOiBlcnIgfSlcbiAgICAgIH1cbiAgICB9LFxuICAgIGFib3J0OiAoZXJyKSA9PiB7XG4gICAgICBpZiAocmVzLndyaXRhYmxlRmluaXNoZWQpIHJldHVyblxuXG4gICAgICByZXMuZGVzdHJveShlcnIpXG4gICAgfSxcbiAgICBjbG9zZTogYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gaWYgYSB3YWl0VW50aWwgcHJvbWlzZSB3YXMgcGFzc2VkLCB3YWl0IGZvciBpdCB0byByZXNvbHZlIGJlZm9yZVxuICAgICAgLy8gZW5kaW5nIHRoZSByZXNwb25zZS5cbiAgICAgIGlmICh3YWl0VW50aWxGb3JFbmQpIHtcbiAgICAgICAgYXdhaXQgd2FpdFVudGlsRm9yRW5kXG4gICAgICB9XG5cbiAgICAgIGlmIChyZXMud3JpdGFibGVGaW5pc2hlZCkgcmV0dXJuXG5cbiAgICAgIHJlcy5lbmQoKVxuICAgICAgcmV0dXJuIGZpbmlzaGVkLnByb21pc2VcbiAgICB9LFxuICB9KVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcGlwZVRvTm9kZVJlc3BvbnNlKFxuICByZWFkYWJsZTogUmVhZGFibGVTdHJlYW08VWludDhBcnJheT4sXG4gIHJlczogU2VydmVyUmVzcG9uc2UsXG4gIHdhaXRVbnRpbEZvckVuZD86IFByb21pc2U8dW5rbm93bj5cbikge1xuICB0cnkge1xuICAgIC8vIElmIHRoZSByZXNwb25zZSBoYXMgYWxyZWFkeSBlcnJvcmVkLCB0aGVuIGp1c3QgcmV0dXJuIG5vdy5cbiAgICBjb25zdCB7IGVycm9yZWQsIGRlc3Ryb3llZCB9ID0gcmVzXG4gICAgaWYgKGVycm9yZWQgfHwgZGVzdHJveWVkKSByZXR1cm5cblxuICAgIC8vIENyZWF0ZSBhIG5ldyBBYm9ydENvbnRyb2xsZXIgc28gdGhhdCB3ZSBjYW4gYWJvcnQgdGhlIHJlYWRhYmxlIGlmIHRoZVxuICAgIC8vIGNsaWVudCBkaXNjb25uZWN0cy5cbiAgICBjb25zdCBjb250cm9sbGVyID0gY3JlYXRlQWJvcnRDb250cm9sbGVyKHJlcylcblxuICAgIGNvbnN0IHdyaXRlciA9IGNyZWF0ZVdyaXRlckZyb21SZXNwb25zZShyZXMsIHdhaXRVbnRpbEZvckVuZClcblxuICAgIGF3YWl0IHJlYWRhYmxlLnBpcGVUbyh3cml0ZXIsIHsgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCB9KVxuICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgIC8vIElmIHRoaXMgaXNuJ3QgcmVsYXRlZCB0byBhbiBhYm9ydCBlcnJvciwgcmUtdGhyb3cgaXQuXG4gICAgaWYgKGlzQWJvcnRFcnJvcihlcnIpKSByZXR1cm5cblxuICAgIHRocm93IG5ldyBFcnJvcignZmFpbGVkIHRvIHBpcGUgcmVzcG9uc2UnLCB7IGNhdXNlOiBlcnIgfSlcbiAgfVxufVxuIl0sIm5hbWVzIjpbIlJlc3BvbnNlQWJvcnRlZE5hbWUiLCJjcmVhdGVBYm9ydENvbnRyb2xsZXIiLCJEZXRhY2hlZFByb21pc2UiLCJnZXRUcmFjZXIiLCJOZXh0Tm9kZVNlcnZlclNwYW4iLCJnZXRDbGllbnRDb21wb25lbnRMb2FkZXJNZXRyaWNzIiwiaXNBYm9ydEVycm9yIiwiZSIsIm5hbWUiLCJjcmVhdGVXcml0ZXJGcm9tUmVzcG9uc2UiLCJyZXMiLCJ3YWl0VW50aWxGb3JFbmQiLCJzdGFydGVkIiwiZHJhaW5lZCIsIm9uRHJhaW4iLCJyZXNvbHZlIiwib24iLCJvbmNlIiwib2ZmIiwiZmluaXNoZWQiLCJXcml0YWJsZVN0cmVhbSIsIndyaXRlIiwiY2h1bmsiLCJnbG9iYWxUaGlzIiwicHJvY2VzcyIsImVudiIsIk5FWFRfT1RFTF9QRVJGT1JNQU5DRV9QUkVGSVgiLCJtZXRyaWNzIiwicGVyZm9ybWFuY2UiLCJtZWFzdXJlIiwic3RhcnQiLCJjbGllbnRDb21wb25lbnRMb2FkU3RhcnQiLCJlbmQiLCJjbGllbnRDb21wb25lbnRMb2FkVGltZXMiLCJmbHVzaEhlYWRlcnMiLCJ0cmFjZSIsInN0YXJ0UmVzcG9uc2UiLCJzcGFuTmFtZSIsInVuZGVmaW5lZCIsIm9rIiwiZmx1c2giLCJwcm9taXNlIiwiZXJyIiwiRXJyb3IiLCJjYXVzZSIsImFib3J0Iiwid3JpdGFibGVGaW5pc2hlZCIsImRlc3Ryb3kiLCJjbG9zZSIsInBpcGVUb05vZGVSZXNwb25zZSIsInJlYWRhYmxlIiwiZXJyb3JlZCIsImRlc3Ryb3llZCIsImNvbnRyb2xsZXIiLCJ3cml0ZXIiLCJwaXBlVG8iLCJzaWduYWwiXSwibWFwcGluZ3MiOiI7Ozs7QUFFQSxTQUNFQSxtQkFBbUIsRUFDbkJDLHFCQUFxQixRQUNoQiw2Q0FBNEM7QUFDbkQsU0FBU0MsZUFBZSxRQUFRLDBCQUF5QjtBQUN6RCxTQUFTQyxTQUFTLFFBQVEscUJBQW9CO0FBQzlDLFNBQVNDLGtCQUFrQixRQUFRLHdCQUF1QjtBQUMxRCxTQUFTQywrQkFBK0IsUUFBUSxxQ0FBb0M7Ozs7OztBQUU3RSxTQUFTQyxhQUFhQyxDQUFNO0lBQ2pDLE9BQU9BLENBQUFBLEtBQUFBLE9BQUFBLEtBQUFBLElBQUFBLEVBQUdDLElBQUksTUFBSyxnQkFBZ0JELENBQUFBLEtBQUFBLE9BQUFBLEtBQUFBLElBQUFBLEVBQUdDLElBQUksK01BQUtSLHNCQUFBQTtBQUNqRDtBQUVBLFNBQVNTLHlCQUNQQyxHQUFtQixFQUNuQkMsZUFBa0M7SUFFbEMsSUFBSUMsVUFBVTtJQUVkLHdFQUF3RTtJQUN4RSx3REFBd0Q7SUFDeEQsSUFBSUMsVUFBVSxzS0FBSVgsa0JBQUFBO0lBQ2xCLFNBQVNZO1FBQ1BELFFBQVFF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QUV2QixNQUFNLE9BQUEsY0FBb0QsQ0FBcEQsSUFBSUMsTUFBTSwyQkFBMkI7WUFBRUMsT0FBT0Y7UUFBSSxJQUFsRCxxQkFBQTttQkFBQTt3QkFBQTswQkFBQTtRQUFtRDtJQUMzRDtBQUNGIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDEyMDYzLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zcmMvc2hhcmVkL2xpYi9sYXp5LWR5bmFtaWMvYmFpbG91dC10by1jc3IudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVGhpcyBoYXMgdG8gYmUgYSBzaGFyZWQgbW9kdWxlIHdoaWNoIGlzIHNoYXJlZCBiZXR3ZWVuIGNsaWVudCBjb21wb25lbnQgZXJyb3IgYm91bmRhcnkgYW5kIGR5bmFtaWMgY29tcG9uZW50XG5jb25zdCBCQUlMT1VUX1RPX0NTUiA9ICdCQUlMT1VUX1RPX0NMSUVOVF9TSURFX1JFTkRFUklORydcblxuLyoqIEFuIGVycm9yIHRoYXQgc2hvdWxkIGJlIHRocm93biB3aGVuIHdlIHdhbnQgdG8gYmFpbCBvdXQgdG8gY2xpZW50LXNpZGUgcmVuZGVyaW5nLiAqL1xuZXhwb3J0IGNsYXNzIEJhaWxvdXRUb0NTUkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBwdWJsaWMgcmVhZG9ubHkgZGlnZXN0ID0gQkFJTE9VVF9UT19DU1JcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgcmVhZG9ubHkgcmVhc29uOiBzdHJpbmcpIHtcbiAgICBzdXBlcihgQmFpbCBvdXQgdG8gY2xpZW50LXNpZGUgcmVuZGVyaW5nOiAke3JlYXNvbn1gKVxuICB9XG59XG5cbi8qKiBDaGVja3MgaWYgYSBwYXNzZWQgYXJndW1lbnQgaXMgYW4gZXJyb3IgdGhhdCBpcyB0aHJvd24gaWYgd2Ugd2FudCB0byBiYWlsIG91dCB0byBjbGllbnQtc2lkZSByZW5kZXJpbmcuICovXG5leHBvcnQgZnVuY3Rpb24gaXNCYWlsb3V0VG9DU1JFcnJvcihlcnI6IHVua25vd24pOiBlcnIgaXMgQmFpbG91dFRvQ1NSRXJyb3Ige1xuICBpZiAodHlwZW9mIGVyciAhPT0gJ29iamVjdCcgfHwgZXJyID09PSBudWxsIHx8ICEoJ2RpZ2VzdCcgaW4gZXJyKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIGVyci5kaWdlc3QgPT09IEJBSUxPVVRfVE9fQ1NSXG59XG4iXSwibmFtZXMiOlsiQkFJTE9VVF9UT19DU1IiLCJCYWlsb3V0VG9DU1JFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJyZWFzb24iLCJkaWdlc3QiLCJpc0JhaWxvdXRUb0NTUkVycm9yIiwiZXJyIl0sIm1hcHBpbmdzIjoiQUFBQSwrR0FBK0c7Ozs7O0FBQy9HLE1BQU1BLGlCQUFpQjtBQUdoQixNQUFNQywwQkFBMEJDO0lBR3JDQyxZQUE0QkMsTUFBYyxDQUFFO1FBQzFDLEtBQUssQ0FBRSx3Q0FBcUNBLFNBQUFBLElBQUFBLENBRGxCQSxNQUFBQSxHQUFBQSxRQUFBQSxJQUFBQSxDQUZaQyxNQUFBQSxHQUFTTDtJQUl6QjtBQUNGO0FBR08sU0FBU00sb0JBQW9CQyxHQUFZO0lBQzlDLElBQUksT0FBT0EsUUFBUSxZQUFZQSxRQUFRLFFBQVEsQ0FBRSxDQUFBLFlBQVlBLEdBQUUsR0FBSTtRQUNqRSxPQUFPO0lBQ1Q7SUFFQSxPQUFPQSxJQUFJRixNQUFNLEtBQUtMO0FBQ3hCIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDEyMDg0LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zcmMvY2xpZW50L2NvbXBvbmVudHMvcmVkaXJlY3Qtc3RhdHVzLWNvZGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGVudW0gUmVkaXJlY3RTdGF0dXNDb2RlIHtcbiAgU2VlT3RoZXIgPSAzMDMsXG4gIFRlbXBvcmFyeVJlZGlyZWN0ID0gMzA3LFxuICBQZXJtYW5lbnRSZWRpcmVjdCA9IDMwOCxcbn1cbiJdLCJuYW1lcyI6WyJSZWRpcmVjdFN0YXR1c0NvZGUiXSwibWFwcGluZ3MiOiI7OztBQUFPLElBQUtBLHFCQUFBQSxXQUFBQSxHQUFBQSxTQUFBQSxrQkFBQUE7Ozs7V0FBQUE7TUFJWCIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxMjA5NywgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL2NsaWVudC9jb21wb25lbnRzL3JlZGlyZWN0LWVycm9yLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJlZGlyZWN0U3RhdHVzQ29kZSB9IGZyb20gJy4vcmVkaXJlY3Qtc3RhdHVzLWNvZGUnXG5cbmV4cG9ydCBjb25zdCBSRURJUkVDVF9FUlJPUl9DT0RFID0gJ05FWFRfUkVESVJFQ1QnXG5cbmV4cG9ydCBlbnVtIFJlZGlyZWN0VHlwZSB7XG4gIHB1c2ggPSAncHVzaCcsXG4gIHJlcGxhY2UgPSAncmVwbGFjZScsXG59XG5cbmV4cG9ydCB0eXBlIFJlZGlyZWN0RXJyb3IgPSBFcnJvciAmIHtcbiAgZGlnZXN0OiBgJHt0eXBlb2YgUkVESVJFQ1RfRVJST1JfQ09ERX07JHtSZWRpcmVjdFR5cGV9OyR7c3RyaW5nfTske1JlZGlyZWN0U3RhdHVzQ29kZX07YFxufVxuXG4vKipcbiAqIENoZWNrcyBhbiBlcnJvciB0byBkZXRlcm1pbmUgaWYgaXQncyBhbiBlcnJvciBnZW5lcmF0ZWQgYnkgdGhlXG4gKiBgcmVkaXJlY3QodXJsKWAgaGVscGVyLlxuICpcbiAqIEBwYXJhbSBlcnJvciB0aGUgZXJyb3IgdGhhdCBtYXkgcmVmZXJlbmNlIGEgcmVkaXJlY3QgZXJyb3JcbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGVycm9yIGlzIGEgcmVkaXJlY3QgZXJyb3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzUmVkaXJlY3RFcnJvcihlcnJvcjogdW5rbm93bik6IGVycm9yIGlzIFJlZGlyZWN0RXJyb3Ige1xuICBpZiAoXG4gICAgdHlwZW9mIGVycm9yICE9PSAnb2JqZWN0JyB8fFxuICAgIGVycm9yID09PSBudWxsIHx8XG4gICAgISgnZGlnZXN0JyBpbiBlcnJvcikgfHxcbiAgICB0eXBlb2YgZXJyb3IuZGlnZXN0ICE9PSAnc3RyaW5nJ1xuICApIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGNvbnN0IGRpZ2VzdCA9IGVycm9yLmRpZ2VzdC5zcGxpdCgnOycpXG4gIGNvbnN0IFtlcnJvckNvZGUsIHR5cGVdID0gZGlnZXN0XG4gIGNvbnN0IGRlc3RpbmF0aW9uID0gZGlnZXN0LnNsaWNlKDIsIC0yKS5qb2luKCc7JylcbiAgY29uc3Qgc3RhdHVzID0gZGlnZXN0LmF0KC0yKVxuXG4gIGNvbnN0IHN0YXR1c0NvZGUgPSBOdW1iZXIoc3RhdHVzKVxuXG4gIHJldHVybiAoXG4gICAgZXJyb3JDb2RlID09PSBSRURJUkVDVF9FUlJPUl9DT0RFICYmXG4gICAgKHR5cGUgPT09ICdyZXBsYWNlJyB8fCB0eXBlID09PSAncHVzaCcpICYmXG4gICAgdHlwZW9mIGRlc3RpbmF0aW9uID09PSAnc3RyaW5nJyAmJlxuICAgICFpc05hTihzdGF0dXNDb2RlKSAmJlxuICAgIHN0YXR1c0NvZGUgaW4gUmVkaXJlY3RTdGF0dXNDb2RlXG4gIClcbn1cbiJdLCJuYW1lcyI6WyJSZWRpcmVjdFN0YXR1c0NvZGUiLCJSRURJUkVDVF9FUlJPUl9DT0RFIiwiUmVkaXJlY3RUeXBlIiwiaXNSZWRpcmVjdEVycm9yIiwiZXJyb3IiLCJkaWdlc3QiLCJzcGxpdCIsImVycm9yQ29kZSIsInR5cGUiLCJkZXN0aW5hdGlvbiIsInNsaWNlIiwiam9pbiIsInN0YXR1cyIsImF0Iiwic3RhdHVzQ29kZSIsIk51bWJlciIsImlzTmFOIl0sIm1hcHBpbmdzIjoiOzs7OztBQUFBLFNBQVNBLGtCQUFrQixRQUFRLHlCQUF3Qjs7QUFFcEQsTUFBTUMsc0JBQXNCLGdCQUFlO0FBRTNDLElBQUtDLGVBQUFBLFdBQUFBLEdBQUFBLFNBQUFBLFlBQUFBOzs7V0FBQUE7TUFHWDtBQWFNLFNBQVNDLGdCQUFnQkMsS0FBYztJQUM1QyxJQUNFLE9BQU9BLFVBQVUsWUFDakJBLFVBQVUsUUFDVixDQUFFLENBQUEsWUFBWUEsS0FBSSxLQUNsQixPQUFPQSxNQUFNQyxNQUFNLEtBQUssVUFDeEI7UUFDQSxPQUFPO0lBQ1Q7SUFFQSxNQUFNQSxTQUFTRCxNQUFNQyxNQUFNLENBQUNDLEtBQUssQ0FBQztJQUNsQyxNQUFNLENBQUNDLFdBQVdDLEtBQUssR0FBR0g7SUFDMUIsTUFBTUksY0FBY0osT0FBT0ssS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHQyxJQUFJLENBQUM7SUFDN0MsTUFBTUMsU0FBU1AsT0FBT1EsRUFBRSxDQUFDLENBQUM7SUFFMUIsTUFBTUMsYUFBYUMsT0FBT0g7SUFFMUIsT0FDRUwsY0FBY04sdUJBQ2JPLENBQUFBLFNBQVMsYUFBYUEsU0FBUyxNQUFLLEtBQ3JDLE9BQU9DLGdCQUFnQixZQUN2QixDQUFDTyxNQUFNRixlQUNQQSx3TUFBY2QscUJBQUFBO0FBRWxCIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDEyMTI1LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zcmMvY2xpZW50L2NvbXBvbmVudHMvaXMtbmV4dC1yb3V0ZXItZXJyb3IudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgaXNIVFRQQWNjZXNzRmFsbGJhY2tFcnJvcixcbiAgdHlwZSBIVFRQQWNjZXNzRmFsbGJhY2tFcnJvcixcbn0gZnJvbSAnLi9odHRwLWFjY2Vzcy1mYWxsYmFjay9odHRwLWFjY2Vzcy1mYWxsYmFjaydcbmltcG9ydCB7IGlzUmVkaXJlY3RFcnJvciwgdHlwZSBSZWRpcmVjdEVycm9yIH0gZnJvbSAnLi9yZWRpcmVjdC1lcnJvcidcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGVycm9yIGlzIGEgbmF2aWdhdGlvbiBzaWduYWwgZXJyb3IuIFRoZXNlIGVycm9ycyBhcmVcbiAqIHRocm93biBieSB1c2VyIGNvZGUgdG8gcGVyZm9ybSBuYXZpZ2F0aW9uIG9wZXJhdGlvbnMgYW5kIGludGVycnVwdCB0aGUgUmVhY3RcbiAqIHJlbmRlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTmV4dFJvdXRlckVycm9yKFxuICBlcnJvcjogdW5rbm93blxuKTogZXJyb3IgaXMgUmVkaXJlY3RFcnJvciB8IEhUVFBBY2Nlc3NGYWxsYmFja0Vycm9yIHtcbiAgcmV0dXJuIGlzUmVkaXJlY3RFcnJvcihlcnJvcikgfHwgaXNIVFRQQWNjZXNzRmFsbGJhY2tFcnJvcihlcnJvcilcbn1cbiJdLCJuYW1lcyI6WyJpc0hUVFBBY2Nlc3NGYWxsYmFja0Vycm9yIiwiaXNSZWRpcmVjdEVycm9yIiwiaXNOZXh0Um91dGVyRXJyb3IiLCJlcnJvciJdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsU0FDRUEseUJBQXlCLFFBRXBCLDhDQUE2QztBQUNwRCxTQUFTQyxlQUFlLFFBQTRCLG1CQUFrQjs7O0FBTy9ELFNBQVNDLGtCQUNkQyxLQUFjO0lBRWQsNExBQU9GLGtCQUFBQSxFQUFnQkUsc09BQVVILDRCQUFBQSxFQUEwQkc7QUFDN0QiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTIxMzksICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NyYy9zaGFyZWQvbGliL2lzLXBsYWluLW9iamVjdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gZ2V0T2JqZWN0Q2xhc3NMYWJlbCh2YWx1ZTogYW55KTogc3RyaW5nIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWU6IGFueSk6IGJvb2xlYW4ge1xuICBpZiAoZ2V0T2JqZWN0Q2xhc3NMYWJlbCh2YWx1ZSkgIT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBjb25zdCBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpXG5cbiAgLyoqXG4gICAqIHRoaXMgdXNlZCB0byBiZSBwcmV2aW91c2x5OlxuICAgKlxuICAgKiBgcmV0dXJuIHByb3RvdHlwZSA9PT0gbnVsbCB8fCBwcm90b3R5cGUgPT09IE9iamVjdC5wcm90b3R5cGVgXG4gICAqXG4gICAqIGJ1dCBFZGdlIFJ1bnRpbWUgZXhwb3NlIE9iamVjdCBmcm9tIHZtLCBiZWluZyB0aGF0IGtpbmQgb2YgdHlwZS1jaGVja2luZyB3cm9uZ2x5IGZhaWwuXG4gICAqXG4gICAqIEl0IHdhcyBjaGFuZ2VkIHRvIHRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIHNpbmNlIGl0J3MgcmVzaWxpZW50IHRvIHNlcmlhbGl6YXRpb24uXG4gICAqL1xuICByZXR1cm4gcHJvdG90eXBlID09PSBudWxsIHx8IHByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnaXNQcm90b3R5cGVPZicpXG59XG4iXSwibmFtZXMiOlsiZ2V0T2JqZWN0Q2xhc3NMYWJlbCIsInZhbHVlIiwiT2JqZWN0IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwiaXNQbGFpbk9iamVjdCIsImdldFByb3RvdHlwZU9mIiwiaGFzT3duUHJvcGVydHkiXSwibWFwcGluZ3MiOiI7Ozs7QUFBTyxTQUFTQSxvQkFBb0JDLEtBQVU7SUFDNUMsT0FBT0MsT0FBT0MsU0FBUyxDQUFDQyxRQUFRLENBQUNDLElBQUksQ0FBQ0o7QUFDeEM7QUFFTyxTQUFTSyxjQUFjTCxLQUFVO0lBQ3RDLElBQUlELG9CQUFvQkMsV0FBVyxtQkFBbUI7UUFDcEQsT0FBTztJQUNUO0lBRUEsTUFBTUUsWUFBWUQsT0FBT0ssY0FBYyxDQUFDTjtJQUV4Qzs7Ozs7Ozs7R0FRQyxHQUNELE9BQU9FLGNBQWMsUUFBUUEsVUFBVUssY0FBYyxDQUFDO0FBQ3hEIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDEyMTY1LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zcmMvbGliL2lzLWVycm9yLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzUGxhaW5PYmplY3QgfSBmcm9tICcuLi9zaGFyZWQvbGliL2lzLXBsYWluLW9iamVjdCdcblxuLy8gV2UgYWxsb3cgc29tZSBhZGRpdGlvbmFsIGF0dGFjaGVkIHByb3BlcnRpZXMgZm9yIE5leHQuanMgZXJyb3JzXG5leHBvcnQgaW50ZXJmYWNlIE5leHRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgdHlwZT86IHN0cmluZ1xuICBwYWdlPzogc3RyaW5nXG4gIGNvZGU/OiBzdHJpbmcgfCBudW1iZXJcbiAgY2FuY2VsbGVkPzogYm9vbGVhblxuICBkaWdlc3Q/OiBudW1iZXJcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBOZXh0RXJyb3IuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIHByaW50IGEgbW9yZSBkZXRhaWxlZCBlcnJvciBtZXNzYWdlIHdpdGggcHJvcGVydGllcyBsaWtlIGBjb2RlYCAmIGBkaWdlc3RgLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc0Vycm9yKGVycjogdW5rbm93bik6IGVyciBpcyBOZXh0RXJyb3Ige1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBlcnIgPT09ICdvYmplY3QnICYmIGVyciAhPT0gbnVsbCAmJiAnbmFtZScgaW4gZXJyICYmICdtZXNzYWdlJyBpbiBlcnJcbiAgKVxufVxuXG5mdW5jdGlvbiBzYWZlU3RyaW5naWZ5KG9iajogYW55KSB7XG4gIGNvbnN0IHNlZW4gPSBuZXcgV2Vha1NldCgpXG5cbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaiwgKF9rZXksIHZhbHVlKSA9PiB7XG4gICAgLy8gSWYgdmFsdWUgaXMgYW4gb2JqZWN0IGFuZCBhbHJlYWR5IHNlZW4sIHJlcGxhY2Ugd2l0aCBcIltDaXJjdWxhcl1cIlxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICBpZiAoc2Vlbi5oYXModmFsdWUpKSB7XG4gICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSdcbiAgICAgIH1cbiAgICAgIHNlZW4uYWRkKHZhbHVlKVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWVcbiAgfSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFByb3BlckVycm9yKGVycjogdW5rbm93bik6IEVycm9yIHtcbiAgaWYgKGlzRXJyb3IoZXJyKSkge1xuICAgIHJldHVybiBlcnJcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgIC8vIHByb3ZpZGUgYmV0dGVyIGVycm9yIGZvciBjYXNlIHdoZXJlIGB0aHJvdyB1bmRlZmluZWRgXG4gICAgLy8gaXMgY2FsbGVkIGluIGRldmVsb3BtZW50XG4gICAgaWYgKHR5cGVvZiBlcnIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgICAgICAnQW4gdW5kZWZpbmVkIGVycm9yIHdhcyB0aHJvd24sICcgK1xuICAgICAgICAgICdzZWUgaGVyZSBmb3IgbW9yZSBpbmZvOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy90aHJldy11bmRlZmluZWQnXG4gICAgICApXG4gICAgfVxuXG4gICAgaWYgKGVyciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICAgICAgJ0EgbnVsbCBlcnJvciB3YXMgdGhyb3duLCAnICtcbiAgICAgICAgICAnc2VlIGhlcmUgZm9yIG1vcmUgaW5mbzogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvdGhyZXctdW5kZWZpbmVkJ1xuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgRXJyb3IoaXNQbGFpbk9iamVjdChlcnIpID8gc2FmZVN0cmluZ2lmeShlcnIpIDogZXJyICsgJycpXG59XG4iXSwibmFtZXMiOlsiaXNQbGFpbk9iamVjdCIsImlzRXJyb3IiLCJlcnIiLCJzYWZlU3RyaW5naWZ5Iiwib2JqIiwic2VlbiIsIldlYWtTZXQiLCJKU09OIiwic3RyaW5naWZ5IiwiX2tleSIsInZhbHVlIiwiaGFzIiwiYWRkIiwiZ2V0UHJvcGVyRXJyb3IiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJFcnJvciJdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLFNBQVNBLGFBQWEsUUFBUSxnQ0FBK0I7O0FBZTlDLFNBQVNDLFFBQVFDLEdBQVk7SUFDMUMsT0FDRSxPQUFPQSxRQUFRLFlBQVlBLFFBQVEsUUFBUSxVQUFVQSxPQUFPLGFBQWFBO0FBRTdFO0FBRUEsU0FBU0MsY0FBY0MsR0FBUTtJQUM3QixNQUFNQyxPQUFPLElBQUlDO0lBRWpCLE9BQU9DLEtBQUtDLFNBQVMsQ0FBQ0osS0FBSyxDQUFDSyxNQUFNQztRQUNoQyxvRUFBb0U7UUFDcEUsSUFBSSxPQUFPQSxVQUFVLFlBQVlBLFVBQVUsTUFBTTtZQUMvQyxJQUFJTCxLQUFLTSxHQUFHLENBQUNELFFBQVE7Z0JBQ25CLE9BQU87WUFDVDtZQUNBTCxLQUFLTyxHQUFHLENBQUNGO1FBQ1g7UUFDQSxPQUFPQTtJQUNUO0FBQ0Y7QUFFTyxTQUFTRyxlQUFlWCxHQUFZO0lBQ3pDLElBQUlELFFBQVFDLE1BQU07UUFDaEIsT0FBT0E7SUFDVDtJQUVBLElBQUlZLFFBQVFDLEdBQUcsQ0FBQ0MsUUFBUSxLQUFLLFdBQWU7UUFDMUMsd0RBQXdEO1FBQ3hELDJCQUEyQjtRQUMzQixJQUFJLE9BQU9kLFFBQVEsYUFBYTtZQUM5QixPQUFPLE9BQUEsY0FHTixDQUhNLElBQUllLE1BQ1Qsb0NBQ0UsNkVBRkcscUJBQUE7dUJBQUE7NEJBQUE7OEJBQUE7WUFHUDtRQUNGO1FBRUEsSUFBSWYsUUFBUSxNQUFNO1lBQ2hCLE9BQU8sT0FBQSxjQUdOLENBSE0sSUFBSWUsTUFDVCw4QkFDRSw2RUFGRyxxQkFBQTt1QkFBQTs0QkFBQTs4QkFBQTtZQUdQO1FBQ0Y7SUFDRjtJQUVBLE9BQU8sT0FBQSxjQUE2RCxDQUE3RCxJQUFJQSx3TEFBTWpCLGdCQUFBQSxFQUFjRSxPQUFPQyxjQUFjRCxPQUFPQSxNQUFNLEtBQTFELHFCQUFBO2VBQUE7b0JBQUE7c0JBQUE7SUFBNEQ7QUFDckUiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTIyMTksICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NyYy9saWIvZXJyb3ItdGVsZW1ldHJ5LXV0aWxzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IEVSUk9SX0NPREVfREVMSU1JVEVSID0gJ0AnXG5cbi8qKlxuICogQXVnbWVudHMgdGhlIGRpZ2VzdCBmaWVsZCBvZiBlcnJvcnMgdGhyb3duIGluIFJlYWN0IFNlcnZlciBDb21wb25lbnRzIChSU0MpIHdpdGggYW4gZXJyb3IgY29kZS5cbiAqIFNpbmNlIFJTQyBlcnJvcnMgY2FuIG9ubHkgYmUgc2VyaWFsaXplZCB0aHJvdWdoIHRoZSBkaWdlc3QgZmllbGQsIHRoaXMgcHJvdmlkZXMgYSB3YXkgdG8gaW5jbHVkZVxuICogYW4gYWRkaXRpb25hbCBlcnJvciBjb2RlIHRoYXQgY2FuIGJlIGV4dHJhY3RlZCBjbGllbnQtc2lkZSB2aWEgYGV4dHJhY3ROZXh0RXJyb3JDb2RlYC5cbiAqXG4gKiBUaGUgZXJyb3IgY29kZSBpcyBhcHBlbmRlZCB0byB0aGUgZGlnZXN0IHN0cmluZyB3aXRoIGEgc2VtaWNvbG9uIHNlcGFyYXRvciwgYWxsb3dpbmcgaXQgdG8gYmVcbiAqIHBhcnNlZCBvdXQgbGF0ZXIgd2hpbGUgcHJlc2VydmluZyB0aGUgb3JpZ2luYWwgZGlnZXN0IHZhbHVlLlxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlRGlnZXN0V2l0aEVycm9yQ29kZSA9IChcbiAgdGhyb3duVmFsdWU6IHVua25vd24sXG4gIG9yaWdpbmFsRGlnZXN0OiBzdHJpbmdcbik6IHN0cmluZyA9PiB7XG4gIGlmIChcbiAgICB0eXBlb2YgdGhyb3duVmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgdGhyb3duVmFsdWUgIT09IG51bGwgJiZcbiAgICAnX19ORVhUX0VSUk9SX0NPREUnIGluIHRocm93blZhbHVlXG4gICkge1xuICAgIHJldHVybiBgJHtvcmlnaW5hbERpZ2VzdH0ke0VSUk9SX0NPREVfREVMSU1JVEVSfSR7dGhyb3duVmFsdWUuX19ORVhUX0VSUk9SX0NPREV9YFxuICB9XG4gIHJldHVybiBvcmlnaW5hbERpZ2VzdFxufVxuXG5leHBvcnQgY29uc3QgZXh0cmFjdE5leHRFcnJvckNvZGUgPSAoZXJyb3I6IHVua25vd24pOiBzdHJpbmcgfCB1bmRlZmluZWQgPT4ge1xuICBpZiAoXG4gICAgdHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJlxuICAgIGVycm9yICE9PSBudWxsICYmXG4gICAgJ19fTkVYVF9FUlJPUl9DT0RFJyBpbiBlcnJvciAmJlxuICAgIHR5cGVvZiBlcnJvci5fX05FWFRfRVJST1JfQ09ERSA9PT0gJ3N0cmluZydcbiAgKSB7XG4gICAgcmV0dXJuIGVycm9yLl9fTkVYVF9FUlJPUl9DT0RFXG4gIH1cblxuICBpZiAoXG4gICAgdHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJlxuICAgIGVycm9yICE9PSBudWxsICYmXG4gICAgJ2RpZ2VzdCcgaW4gZXJyb3IgJiZcbiAgICB0eXBlb2YgZXJyb3IuZGlnZXN0ID09PSAnc3RyaW5nJ1xuICApIHtcbiAgICBjb25zdCBzZWdtZW50cyA9IGVycm9yLmRpZ2VzdC5zcGxpdChFUlJPUl9DT0RFX0RFTElNSVRFUilcbiAgICBjb25zdCBlcnJvckNvZGUgPSBzZWdtZW50cy5maW5kKChzZWdtZW50KSA9PiBzZWdtZW50LnN0YXJ0c1dpdGgoJ0UnKSlcbiAgICByZXR1cm4gZXJyb3JDb2RlXG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkXG59XG4iXSwibmFtZXMiOlsiRVJST1JfQ09ERV9ERUxJTUlURVIiLCJjcmVhdGVEaWdlc3RXaXRoRXJyb3JDb2RlIiwidGhyb3duVmFsdWUiLCJvcmlnaW5hbERpZ2VzdCIsIl9fTkVYVF9FUlJPUl9DT0RFIiwiZXh0cmFjdE5leHRFcnJvckNvZGUiLCJlcnJvciIsImRpZ2VzdCIsInNlZ21lbnRzIiwic3BsaXQiLCJlcnJvckNvZGUiLCJmaW5kIiwic2VnbWVudCIsInN0YXJ0c1dpdGgiLCJ1bmRlZmluZWQiXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxNQUFNQSx1QkFBdUI7QUFVdEIsTUFBTUMsNEJBQTRCLENBQ3ZDQyxhQUNBQztJQUVBLElBQ0UsT0FBT0QsZ0JBQWdCLFlBQ3ZCQSxnQkFBZ0IsUUFDaEIsdUJBQXVCQSxhQUN2QjtRQUNBLE9BQU8sR0FBR0MsaUJBQWlCSCx1QkFBdUJFLFlBQVlFLGlCQUFpQixFQUFFO0lBQ25GO0lBQ0EsT0FBT0Q7QUFDVCxFQUFDO0FBRU0sTUFBTUUsdUJBQXVCLENBQUNDO0lBQ25DLElBQ0UsT0FBT0EsVUFBVSxZQUNqQkEsVUFBVSxRQUNWLHVCQUF1QkEsU0FDdkIsT0FBT0EsTUFBTUYsaUJBQWlCLEtBQUssVUFDbkM7UUFDQSxPQUFPRSxNQUFNRixpQkFBaUI7SUFDaEM7SUFFQSxJQUNFLE9BQU9FLFVBQVUsWUFDakJBLFVBQVUsUUFDVixZQUFZQSxTQUNaLE9BQU9BLE1BQU1DLE1BQU0sS0FBSyxVQUN4QjtRQUNBLE1BQU1DLFdBQVdGLE1BQU1DLE1BQU0sQ0FBQ0UsS0FBSyxDQUFDVDtRQUNwQyxNQUFNVSxZQUFZRixTQUFTRyxJQUFJLENBQUMsQ0FBQ0MsVUFBWUEsUUFBUUMsVUFBVSxDQUFDO1FBQ2hFLE9BQU9IO0lBQ1Q7SUFFQSxPQUFPSTtBQUNULEVBQUMiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTIyNDUsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NyYy9zZXJ2ZXIvYXBwLXJlbmRlci9yZWFjdC1sYXJnZS1zaGVsbC1lcnJvci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUT0RPOiBpc1dlbGxLbm93bkVycm9yIC0+IGlzTmV4dEludGVybmFsRXJyb3Jcbi8vIGlzUmVhY3RMYXJnZVNoZWxsRXJyb3IgLT4gaXNXYXJuaW5nXG5leHBvcnQgZnVuY3Rpb24gaXNSZWFjdExhcmdlU2hlbGxFcnJvcihcbiAgZXJyb3I6IHVua25vd25cbik6IGVycm9yIGlzIEVycm9yICYgeyBkaWdlc3Q/OiBzdHJpbmcgfSB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJlxuICAgIGVycm9yICE9PSBudWxsICYmXG4gICAgJ21lc3NhZ2UnIGluIGVycm9yICYmXG4gICAgdHlwZW9mIGVycm9yLm1lc3NhZ2UgPT09ICdzdHJpbmcnICYmXG4gICAgZXJyb3IubWVzc2FnZS5zdGFydHNXaXRoKCdUaGlzIHJlbmRlcmVkIGEgbGFyZ2UgZG9jdW1lbnQgKD4nKVxuICApXG59XG4iXSwibmFtZXMiOlsiaXNSZWFjdExhcmdlU2hlbGxFcnJvciIsImVycm9yIiwibWVzc2FnZSIsInN0YXJ0c1dpdGgiXSwibWFwcGluZ3MiOiJBQUFBLGdEQUFnRDtBQUNoRCxzQ0FBc0M7Ozs7QUFDL0IsU0FBU0EsdUJBQ2RDLEtBQWM7SUFFZCxPQUNFLE9BQU9BLFVBQVUsWUFDakJBLFVBQVUsUUFDVixhQUFhQSxTQUNiLE9BQU9BLE1BQU1DLE9BQU8sS0FBSyxZQUN6QkQsTUFBTUMsT0FBTyxDQUFDQyxVQUFVLENBQUM7QUFFN0IiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTIyNTcsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NyYy9zZXJ2ZXIvYXBwLXJlbmRlci9jcmVhdGUtZXJyb3ItaGFuZGxlci50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBFcnJvckluZm8gfSBmcm9tICdyZWFjdCdcblxuaW1wb3J0IHN0cmluZ0hhc2ggZnJvbSAnbmV4dC9kaXN0L2NvbXBpbGVkL3N0cmluZy1oYXNoJ1xuaW1wb3J0IHsgZm9ybWF0U2VydmVyRXJyb3IgfSBmcm9tICcuLi8uLi9saWIvZm9ybWF0LXNlcnZlci1lcnJvcidcbmltcG9ydCB7IFNwYW5TdGF0dXNDb2RlLCBnZXRUcmFjZXIgfSBmcm9tICcuLi9saWIvdHJhY2UvdHJhY2VyJ1xuaW1wb3J0IHsgaXNBYm9ydEVycm9yIH0gZnJvbSAnLi4vcGlwZS1yZWFkYWJsZSdcbmltcG9ydCB7IGlzQmFpbG91dFRvQ1NSRXJyb3IgfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL2xhenktZHluYW1pYy9iYWlsb3V0LXRvLWNzcidcbmltcG9ydCB7IGlzRHluYW1pY1NlcnZlckVycm9yIH0gZnJvbSAnLi4vLi4vY2xpZW50L2NvbXBvbmVudHMvaG9va3Mtc2VydmVyLWNvbnRleHQnXG5pbXBvcnQgeyBpc05leHRSb3V0ZXJFcnJvciB9IGZyb20gJy4uLy4uL2NsaWVudC9jb21wb25lbnRzL2lzLW5leHQtcm91dGVyLWVycm9yJ1xuaW1wb3J0IHsgaXNQcmVyZW5kZXJJbnRlcnJ1cHRlZEVycm9yIH0gZnJvbSAnLi9keW5hbWljLXJlbmRlcmluZydcbmltcG9ydCB7IGdldFByb3BlckVycm9yIH0gZnJvbSAnLi4vLi4vbGliL2lzLWVycm9yJ1xuaW1wb3J0IHsgY3JlYXRlRGlnZXN0V2l0aEVycm9yQ29kZSB9IGZyb20gJy4uLy4uL2xpYi9lcnJvci10ZWxlbWV0cnktdXRpbHMnXG5pbXBvcnQgeyBpc1JlYWN0TGFyZ2VTaGVsbEVycm9yIH0gZnJvbSAnLi9yZWFjdC1sYXJnZS1zaGVsbC1lcnJvcidcblxuZGVjbGFyZSBnbG9iYWwge1xuICB2YXIgX19uZXh0X2xvZ19lcnJvcl9fOiB1bmRlZmluZWQgfCAoKGVycjogdW5rbm93bikgPT4gdm9pZClcbn1cblxudHlwZSBSU0NFcnJvckhhbmRsZXIgPSAoZXJyOiB1bmtub3duKSA9PiBzdHJpbmcgfCB1bmRlZmluZWRcbnR5cGUgU1NSRXJyb3JIYW5kbGVyID0gKFxuICBlcnI6IHVua25vd24sXG4gIGVycm9ySW5mbz86IEVycm9ySW5mb1xuKSA9PiBzdHJpbmcgfCB1bmRlZmluZWRcblxuZXhwb3J0IHR5cGUgRGlnZXN0ZWRFcnJvciA9IEVycm9yICYgeyBkaWdlc3Q6IHN0cmluZyB9XG5cbi8qKlxuICogUmV0dXJucyBhIGRpZ2VzdCBmb3Igd2VsbC1rbm93biBOZXh0LmpzIGVycm9ycywgb3RoZXJ3aXNlIGB1bmRlZmluZWRgLiBJZiBhXG4gKiBkaWdlc3QgaXMgcmV0dXJuZWQgdGhpcyBhbHNvIG1lYW5zIHRoYXQgdGhlIGVycm9yIGRvZXMgbm90IG5lZWQgdG8gYmVcbiAqIHJlcG9ydGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGlnZXN0Rm9yV2VsbEtub3duRXJyb3IoZXJyb3I6IHVua25vd24pOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAvLyBJZiB3ZSdyZSBiYWlsaW5nIG91dCB0byBDU1IsIHdlIGRvbid0IG5lZWQgdG8gbG9nIHRoZSBlcnJvci5cbiAgaWYgKGlzQmFpbG91dFRvQ1NSRXJyb3IoZXJyb3IpKSByZXR1cm4gZXJyb3IuZGlnZXN0XG5cbiAgLy8gSWYgdGhpcyBpcyBhIG5hdmlnYXRpb24gZXJyb3IsIHdlIGRvbid0IG5lZWQgdG8gbG9nIHRoZSBlcnJvci5cbiAgaWYgKGlzTmV4dFJvdXRlckVycm9yKGVycm9yKSkgcmV0dXJuIGVycm9yLmRpZ2VzdFxuXG4gIC8vIElmIHRoaXMgZXJyb3Igb2NjdXJzLCB3ZSBrbm93IHRoYXQgd2Ugc2hvdWxkIGJlIHN0b3BwaW5nIHRoZSBzdGF0aWNcbiAgLy8gcmVuZGVyLiBUaGlzIGlzIG9ubHkgdGhyb3duIGluIHN0YXRpYyBnZW5lcmF0aW9uIHdoZW4gUFBSIGlzIG5vdCBlbmFibGVkLFxuICAvLyB3aGljaCBjYXVzZXMgdGhlIHdob2xlIHBhZ2UgdG8gYmUgbWFya2VkIGFzIGR5bmFtaWMuIFdlIGRvbid0IG5lZWQgdG9cbiAgLy8gdGVsbCB0aGUgdXNlciBhYm91dCB0aGlzIGVycm9yLCBhcyBpdCdzIG5vdCBhY3Rpb25hYmxlLlxuICBpZiAoaXNEeW5hbWljU2VydmVyRXJyb3IoZXJyb3IpKSByZXR1cm4gZXJyb3IuZGlnZXN0XG5cbiAgLy8gSWYgdGhpcyBpcyBhIHByZXJlbmRlciBpbnRlcnJ1cHRlZCBlcnJvciwgd2UgZG9uJ3QgbmVlZCB0byBsb2cgdGhlIGVycm9yLlxuICBpZiAoaXNQcmVyZW5kZXJJbnRlcnJ1cHRlZEVycm9yKGVycm9yKSkgcmV0dXJuIGVycm9yLmRpZ2VzdFxuXG4gIHJldHVybiB1bmRlZmluZWRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZsaWdodFJlYWN0U2VydmVyRXJyb3JIYW5kbGVyKFxuICBzaG91bGRGb3JtYXRFcnJvcjogYm9vbGVhbixcbiAgb25SZWFjdFNlcnZlclJlbmRlckVycm9yOiAoZXJyOiBEaWdlc3RlZEVycm9yKSA9PiB2b2lkXG4pOiBSU0NFcnJvckhhbmRsZXIge1xuICByZXR1cm4gKHRocm93blZhbHVlOiB1bmtub3duKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB0aHJvd25WYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFRPRE8tQVBQOiBsb29rIGF0IHVzaW5nIHdlYmNyeXB0byBpbnN0ZWFkLiBSZXF1aXJlcyBhIHByb21pc2UgdG8gYmUgYXdhaXRlZC5cbiAgICAgIHJldHVybiBzdHJpbmdIYXNoKHRocm93blZhbHVlKS50b1N0cmluZygpXG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHJlc3BvbnNlIHdhcyBjbG9zZWQsIHdlIGRvbid0IG5lZWQgdG8gbG9nIHRoZSBlcnJvci5cbiAgICBpZiAoaXNBYm9ydEVycm9yKHRocm93blZhbHVlKSkgcmV0dXJuXG5cbiAgICBjb25zdCBkaWdlc3QgPSBnZXREaWdlc3RGb3JXZWxsS25vd25FcnJvcih0aHJvd25WYWx1ZSlcblxuICAgIGlmIChkaWdlc3QpIHtcbiAgICAgIHJldHVybiBkaWdlc3RcbiAgICB9XG5cbiAgICBpZiAoaXNSZWFjdExhcmdlU2hlbGxFcnJvcih0aHJvd25WYWx1ZSkpIHtcbiAgICAgIC8vIFRPRE86IEFnZ3JlZ2F0ZVxuICAgICAgY29uc29sZS5lcnJvcih0aHJvd25WYWx1ZSlcbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9XG5cbiAgICBjb25zdCBlcnIgPSBnZXRQcm9wZXJFcnJvcih0aHJvd25WYWx1ZSkgYXMgRGlnZXN0ZWRFcnJvclxuXG4gICAgLy8gSWYgdGhlIGVycm9yIGFscmVhZHkgaGFzIGEgZGlnZXN0LCByZXNwZWN0IHRoZSBvcmlnaW5hbCBkaWdlc3QsXG4gICAgLy8gc28gaXQgd29uJ3QgZ2V0IHJlLWdlbmVyYXRlZCBpbnRvIGFub3RoZXIgbmV3IGVycm9yLlxuICAgIGlmICghZXJyLmRpZ2VzdCkge1xuICAgICAgLy8gVE9ETy1BUFA6IGxvb2sgYXQgdXNpbmcgd2ViY3J5cHRvIGluc3RlYWQuIFJlcXVpcmVzIGEgcHJvbWlzZSB0byBiZSBhd2FpdGVkLlxuICAgICAgZXJyLmRpZ2VzdCA9IHN0cmluZ0hhc2goZXJyLm1lc3NhZ2UgKyBlcnIuc3RhY2sgfHwgJycpLnRvU3RyaW5nKClcbiAgICB9XG5cbiAgICAvLyBGb3JtYXQgc2VydmVyIGVycm9ycyBpbiBkZXZlbG9wbWVudCB0byBhZGQgbW9yZSBoZWxwZnVsIGVycm9yIG1lc3NhZ2VzXG4gICAgaWYgKHNob3VsZEZvcm1hdEVycm9yKSB7XG4gICAgICBmb3JtYXRTZXJ2ZXJFcnJvcihlcnIpXG4gICAgfVxuXG4gICAgLy8gUmVjb3JkIGV4Y2VwdGlvbiBpbiBhbiBhY3RpdmUgc3BhbiwgaWYgYXZhaWxhYmxlLlxuICAgIGNvbnN0IHNwYW4gPSBnZXRUcmFjZXIoKS5nZXRBY3RpdmVTY29wZVNwYW4oKVxuICAgIGlmIChzcGFuKSB7XG4gICAgICBzcGFuLnJlY29yZEV4Y2VwdGlvbihlcnIpXG4gICAgICBzcGFuLnNldFN0YXR1cyh7XG4gICAgICAgIGNvZGU6IFNwYW5TdGF0dXNDb2RlLkVSUk9SLFxuICAgICAgICBtZXNzYWdlOiBlcnIubWVzc2FnZSxcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgb25SZWFjdFNlcnZlclJlbmRlckVycm9yKGVycilcblxuICAgIHJldHVybiBjcmVhdGVEaWdlc3RXaXRoRXJyb3JDb2RlKHRocm93blZhbHVlLCBlcnIuZGlnZXN0KVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVIVE1MUmVhY3RTZXJ2ZXJFcnJvckhhbmRsZXIoXG4gIHNob3VsZEZvcm1hdEVycm9yOiBib29sZWFuLFxuICBpc05leHRFeHBvcnQ6IGJvb2xlYW4sXG4gIHJlYWN0U2VydmVyRXJyb3JzOiBNYXA8c3RyaW5nLCBEaWdlc3RlZEVycm9yPixcbiAgc2lsZW5jZUxvZ2dlcjogYm9vbGVhbixcbiAgb25SZWFjdFNlcnZlclJlbmRlckVycm9yOiB1bmRlZmluZWQgfCAoKGVycjogRGlnZXN0ZWRFcnJvcikgPT4gdm9pZClcbik6IFJTQ0Vycm9ySGFuZGxlciB7XG4gIHJldHVybiAodGhyb3duVmFsdWU6IHVua25vd24pID0+IHtcbiAgICBpZiAodHlwZW9mIHRocm93blZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gVE9ETy1BUFA6IGxvb2sgYXQgdXNpbmcgd2ViY3J5cHRvIGluc3RlYWQuIFJlcXVpcmVzIGEgcHJvbWlzZSB0byBiZSBhd2FpdGVkLlxuICAgICAgcmV0dXJuIHN0cmluZ0hhc2godGhyb3duVmFsdWUpLnRvU3RyaW5nKClcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgcmVzcG9uc2Ugd2FzIGNsb3NlZCwgd2UgZG9uJ3QgbmVlZCB0byBsb2cgdGhlIGVycm9yLlxuICAgIGlmIChpc0Fib3J0RXJyb3IodGhyb3duVmFsdWUpKSByZXR1cm5cblxuICAgIGNvbnN0IGRpZ2VzdCA9IGdldERpZ2VzdEZvcldlbGxLbm93bkVycm9yKHRocm93blZhbHVlKVxuXG4gICAgaWYgKGRpZ2VzdCkge1xuICAgICAgcmV0dXJuIGRpZ2VzdFxuICAgIH1cblxuICAgIGlmIChpc1JlYWN0TGFyZ2VTaGVsbEVycm9yKHRocm93blZhbHVlKSkge1xuICAgICAgLy8gVE9ETzogQWdncmVnYXRlXG4gICAgICBjb25zb2xlLmVycm9yKHRocm93blZhbHVlKVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH1cblxuICAgIGNvbnN0IGVyciA9IGdldFByb3BlckVycm9yKHRocm93blZhbHVlKSBhcyBEaWdlc3RlZEVycm9yXG5cbiAgICAvLyBJZiB0aGUgZXJyb3IgYWxyZWFkeSBoYXMgYSBkaWdlc3QsIHJlc3BlY3QgdGhlIG9yaWdpbmFsIGRpZ2VzdCxcbiAgICAvLyBzbyBpdCB3b24ndCBnZXQgcmUtZ2VuZXJhdGVkIGludG8gYW5vdGhlciBuZXcgZXJyb3IuXG4gICAgaWYgKCFlcnIuZGlnZXN0KSB7XG4gICAgICAvLyBUT0RPLUFQUDogbG9vayBhdCB1c2luZyB3ZWJjcnlwdG8gaW5zdGVhZC4gUmVxdWlyZXMgYSBwcm9taXNlIHRvIGJlIGF3YWl0ZWQuXG4gICAgICBlcnIuZGlnZXN0ID0gc3RyaW5nSGFzaChlcnIubWVzc2FnZSArIChlcnIuc3RhY2sgfHwgJycpKS50b1N0cmluZygpXG4gICAgfVxuXG4gICAgLy8gQFRPRE8gYnkgcHV0dGluZyB0aGlzIGhlcmUgYW5kIG5vdCBhdCB0aGUgdG9wIGl0IGlzIHBvc3NpYmxlIHRoYXRcbiAgICAvLyB3ZSBkb24ndCBlcnJvciB0aGUgYnVpbGQgaW4gcGxhY2VzIHdlIGFjdHVhbGx5IGV4cGVjdCB0b1xuICAgIGlmICghcmVhY3RTZXJ2ZXJFcnJvcnMuaGFzKGVyci5kaWdlc3QpKSB7XG4gICAgICByZWFjdFNlcnZlckVycm9ycy5zZXQoZXJyLmRpZ2VzdCwgZXJyKVxuICAgIH1cblxuICAgIC8vIEZvcm1hdCBzZXJ2ZXIgZXJyb3JzIGluIGRldmVsb3BtZW50IHRvIGFkZCBtb3JlIGhlbHBmdWwgZXJyb3IgbWVzc2FnZXNcbiAgICBpZiAoc2hvdWxkRm9ybWF0RXJyb3IpIHtcbiAgICAgIGZvcm1hdFNlcnZlckVycm9yKGVycilcbiAgICB9XG5cbiAgICAvLyBEb24ndCBsb2cgdGhlIHN1cHByZXNzZWQgZXJyb3IgZHVyaW5nIGV4cG9ydFxuICAgIGlmIChcbiAgICAgICEoXG4gICAgICAgIGlzTmV4dEV4cG9ydCAmJlxuICAgICAgICBlcnI/Lm1lc3NhZ2U/LmluY2x1ZGVzKFxuICAgICAgICAgICdUaGUgc3BlY2lmaWMgbWVzc2FnZSBpcyBvbWl0dGVkIGluIHByb2R1Y3Rpb24gYnVpbGRzIHRvIGF2b2lkIGxlYWtpbmcgc2Vuc2l0aXZlIGRldGFpbHMuJ1xuICAgICAgICApXG4gICAgICApXG4gICAgKSB7XG4gICAgICAvLyBSZWNvcmQgZXhjZXB0aW9uIGluIGFuIGFjdGl2ZSBzcGFuLCBpZiBhdmFpbGFibGUuXG4gICAgICBjb25zdCBzcGFuID0gZ2V0VHJhY2VyKCkuZ2V0QWN0aXZlU2NvcGVTcGFuKClcbiAgICAgIGlmIChzcGFuKSB7XG4gICAgICAgIHNwYW4ucmVjb3JkRXhjZXB0aW9uKGVycilcbiAgICAgICAgc3Bhbi5zZXRTdGF0dXMoe1xuICAgICAgICAgIGNvZGU6IFNwYW5TdGF0dXNDb2RlLkVSUk9SLFxuICAgICAgICAgIG1lc3NhZ2U6IGVyci5tZXNzYWdlLFxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBpZiAoIXNpbGVuY2VMb2dnZXIpIHtcbiAgICAgICAgb25SZWFjdFNlcnZlclJlbmRlckVycm9yPy4oZXJyKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVEaWdlc3RXaXRoRXJyb3JDb2RlKHRocm93blZhbHVlLCBlcnIuZGlnZXN0KVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVIVE1MRXJyb3JIYW5kbGVyKFxuICBzaG91bGRGb3JtYXRFcnJvcjogYm9vbGVhbixcbiAgaXNOZXh0RXhwb3J0OiBib29sZWFuLFxuICByZWFjdFNlcnZlckVycm9yczogTWFwPHN0cmluZywgRGlnZXN0ZWRFcnJvcj4sXG4gIGFsbENhcHR1cmVkRXJyb3JzOiBBcnJheTx1bmtub3duPixcbiAgc2lsZW5jZUxvZ2dlcjogYm9vbGVhbixcbiAgb25IVE1MUmVuZGVyU1NSRXJyb3I6IChlcnI6IERpZ2VzdGVkRXJyb3IsIGVycm9ySW5mbz86IEVycm9ySW5mbykgPT4gdm9pZFxuKTogU1NSRXJyb3JIYW5kbGVyIHtcbiAgcmV0dXJuICh0aHJvd25WYWx1ZTogdW5rbm93biwgZXJyb3JJbmZvPzogRXJyb3JJbmZvKSA9PiB7XG4gICAgaWYgKGlzUmVhY3RMYXJnZVNoZWxsRXJyb3IodGhyb3duVmFsdWUpKSB7XG4gICAgICAvLyBUT0RPOiBBZ2dyZWdhdGVcbiAgICAgIGNvbnNvbGUuZXJyb3IodGhyb3duVmFsdWUpXG4gICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgbGV0IGlzU1NSRXJyb3IgPSB0cnVlXG5cbiAgICBhbGxDYXB0dXJlZEVycm9ycy5wdXNoKHRocm93blZhbHVlKVxuXG4gICAgLy8gSWYgdGhlIHJlc3BvbnNlIHdhcyBjbG9zZWQsIHdlIGRvbid0IG5lZWQgdG8gbG9nIHRoZSBlcnJvci5cbiAgICBpZiAoaXNBYm9ydEVycm9yKHRocm93blZhbHVlKSkgcmV0dXJuXG5cbiAgICBjb25zdCBkaWdlc3QgPSBnZXREaWdlc3RGb3JXZWxsS25vd25FcnJvcih0aHJvd25WYWx1ZSlcblxuICAgIGlmIChkaWdlc3QpIHtcbiAgICAgIHJldHVybiBkaWdlc3RcbiAgICB9XG5cbiAgICBjb25zdCBlcnIgPSBnZXRQcm9wZXJFcnJvcih0aHJvd25WYWx1ZSkgYXMgRGlnZXN0ZWRFcnJvclxuICAgIC8vIElmIHRoZSBlcnJvciBhbHJlYWR5IGhhcyBhIGRpZ2VzdCwgcmVzcGVjdCB0aGUgb3JpZ2luYWwgZGlnZXN0LFxuICAgIC8vIHNvIGl0IHdvbid0IGdldCByZS1nZW5lcmF0ZWQgaW50byBhbm90aGVyIG5ldyBlcnJvci5cbiAgICBpZiAoZXJyLmRpZ2VzdCkge1xuICAgICAgaWYgKHJlYWN0U2VydmVyRXJyb3JzLmhhcyhlcnIuZGlnZXN0KSkge1xuICAgICAgICAvLyBUaGlzIGVycm9yIGlzIGxpa2VseSBhbiBvYmZ1c2NhdGVkIGVycm9yIGZyb20gcmVhY3Qtc2VydmVyLlxuICAgICAgICAvLyBXZSByZWNvdmVyIHRoZSBvcmlnaW5hbCBlcnJvciBoZXJlLlxuICAgICAgICB0aHJvd25WYWx1ZSA9IHJlYWN0U2VydmVyRXJyb3JzLmdldChlcnIuZGlnZXN0KVxuICAgICAgICBpc1NTUkVycm9yID0gZmFsc2VcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoZSBlcnJvciBpcyBub3QgZnJvbSByZWFjdC1zZXJ2ZXIgYnV0IGhhcyBhIGRpZ2VzdFxuICAgICAgICAvLyBmcm9tIG90aGVyIG1lYW5zIHNvIHdlIGRvbid0IG5lZWQgdG8gcHJvZHVjZSBhIG5ldyBvbmVcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZXJyLmRpZ2VzdCA9IHN0cmluZ0hhc2goXG4gICAgICAgIGVyci5tZXNzYWdlICsgKGVycm9ySW5mbz8uY29tcG9uZW50U3RhY2sgfHwgZXJyLnN0YWNrIHx8ICcnKVxuICAgICAgKS50b1N0cmluZygpXG4gICAgfVxuXG4gICAgLy8gRm9ybWF0IHNlcnZlciBlcnJvcnMgaW4gZGV2ZWxvcG1lbnQgdG8gYWRkIG1vcmUgaGVscGZ1bCBlcnJvciBtZXNzYWdlc1xuICAgIGlmIChzaG91bGRGb3JtYXRFcnJvcikge1xuICAgICAgZm9ybWF0U2VydmVyRXJyb3IoZXJyKVxuICAgIH1cblxuICAgIC8vIERvbid0IGxvZyB0aGUgc3VwcHJlc3NlZCBlcnJvciBkdXJpbmcgZXhwb3J0XG4gICAgaWYgKFxuICAgICAgIShcbiAgICAgICAgaXNOZXh0RXhwb3J0ICYmXG4gICAgICAgIGVycj8ubWVzc2FnZT8uaW5jbHVkZXMoXG4gICAgICAgICAgJ1RoZSBzcGVjaWZpYyBtZXNzYWdlIGlzIG9taXR0ZWQgaW4gcHJvZHVjdGlvbiBidWlsZHMgdG8gYXZvaWQgbGVha2luZyBzZW5zaXRpdmUgZGV0YWlscy4nXG4gICAgICAgIClcbiAgICAgIClcbiAgICApIHtcbiAgICAgIC8vIFJlY29yZCBleGNlcHRpb24gaW4gYW4gYWN0aXZlIHNwYW4sIGlmIGF2YWlsYWJsZS5cbiAgICAgIGNvbnN0IHNwYW4gPSBnZXRUcmFjZXIoKS5nZXRBY3RpdmVTY29wZVNwYW4oKVxuICAgICAgaWYgKHNwYW4pIHtcbiAgICAgICAgc3Bhbi5yZWNvcmRFeGNlcHRpb24oZXJyKVxuICAgICAgICBzcGFuLnNldFN0YXR1cyh7XG4gICAgICAgICAgY29kZTogU3BhblN0YXR1c0NvZGUuRVJST1IsXG4gICAgICAgICAgbWVzc2FnZTogZXJyLm1lc3NhZ2UsXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgIXNpbGVuY2VMb2dnZXIgJiZcbiAgICAgICAgLy8gSFRNTCBlcnJvcnMgY29udGFpbiBSU0MgZXJyb3JzIGFzIHdlbGwsIGZpbHRlciB0aGVtIG91dCBiZWZvcmUgcmVwb3J0aW5nXG4gICAgICAgIGlzU1NSRXJyb3JcbiAgICAgICkge1xuICAgICAgICBvbkhUTUxSZW5kZXJTU1JFcnJvcihlcnIsIGVycm9ySW5mbylcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlRGlnZXN0V2l0aEVycm9yQ29kZSh0aHJvd25WYWx1ZSwgZXJyLmRpZ2VzdClcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNVc2VyTGFuZEVycm9yKGVycjogYW55KTogYm9vbGVhbiB7XG4gIHJldHVybiAoXG4gICAgIWlzQWJvcnRFcnJvcihlcnIpICYmICFpc0JhaWxvdXRUb0NTUkVycm9yKGVycikgJiYgIWlzTmV4dFJvdXRlckVycm9yKGVycilcbiAgKVxufVxuIl0sIm5hbWVzIjpbInN0cmluZ0hhc2giLCJmb3JtYXRTZXJ2ZXJFcnJvciIsIlNwYW5TdGF0dXNDb2RlIiwiZ2V0VHJhY2VyIiwiaXNBYm9ydEVycm9yIiwiaXNCYWlsb3V0VG9DU1JFcnJvciIsImlzRHluYW1pY1NlcnZlckVycm9yIiwiaXNOZXh0Um91dGVyRXJyb3IiLCJpc1ByZXJlbmRlckludGVycnVwdGVkRXJyb3IiLCJnZXRQcm9wZXJFcnJvciIsImNyZWF0ZURpZ2VzdFdpdGhFcnJvckNvZGUiLCJpc1JlYWN0TGFyZ2VTaGVsbEVycm9yIiwiZ2V0RGlnZXN0Rm9yV2VsbEtub3duRXJyb3IiLCJlcnJvciIsImRpZ2VzdCIsInVuZGVmaW5lZCIsImNyZWF0ZUZsaWdodFJlYWN0U2VydmVyRXJyb3JIYW5kbGVyIiwic2hvdWxkRm9ybWF0RXJyb3IiLCJvblJlYWN0U2VydmVyUmVuZGVyRXJyb3IiLCJ0aHJvd25WYWx1ZSIsInRvU3RyaW5nIiwiY29uc29sZSIsImVyciIsIm1lc3NhZ2UiLCJzdGFjayIsInNwYW4iLCJnZXRBY3RpdmVTY29wZVNwYW4iLCJyZWNvcmRFeGNlcHRpb24iLCJzZXRTdGF0dXMiLCJjb2RlIiwiRVJST1IiLCJjcmVhdGVIVE1MUmVhY3RTZXJ2ZXJFcnJvckhhbmRsZXIiLCJpc05leHRFeHBvcnQiLCJyZWFjdFNlcnZlckVycm9ycyIsInNpbGVuY2VMb2dnZXIiLCJoYXMiLCJzZXQiLCJpbmNsdWRlcyIsImNyZWF0ZUhUTUxFcnJvckhhbmRsZXIiLCJhbGxDYXB0dXJlZEVycm9ycyIsIm9uSFRNTFJlbmRlclNTUkVycm9yIiwiZXJyb3JJbmZvIiwiaXNTU1JFcnJvciIsInB1c2giLCJnZXQiLCJjb21wb25lbnRTdGFjayIsImlzVXNlckxhbmRFcnJvciJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUVBLE9BQU9BLGdCQUFnQixpQ0FBZ0M7QUFDdkQsU0FBU0MsaUJBQWlCLFFBQVEsZ0NBQStCO0FBQ2pFLFNBQVNDLGNBQWMsRUFBRUMsU0FBUyxRQUFRLHNCQUFxQjtBQUMvRCxTQUFTQyxZQUFZLFFBQVEsbUJBQWtCO0FBQy9DLFNBQVNDLG1CQUFtQixRQUFRLCtDQUE4QztBQUNsRixTQUFTQyxvQkFBb0IsUUFBUSwrQ0FBOEM7QUFDbkYsU0FBU0MsaUJBQWlCLFFBQVEsK0NBQThDO0FBQ2hGLFNBQVNDLDJCQUEyQixRQUFRLHNCQUFxQjtBQUNqRSxTQUFTQyxjQUFjLFFBQVEscUJBQW9CO0FBQ25ELFNBQVNDLHlCQUF5QixRQUFRLGtDQUFpQztBQUMzRSxTQUFTQyxzQkFBc0IsUUFBUSw0QkFBMkI7Ozs7Ozs7Ozs7OztBQW1CM0QsU0FBU0Ms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cUJBQXFCbEIsS0FBS21CO1lBQzVCO1FBQ0Y7UUFFQSxxTEFBTy9CLDRCQUFBQSxFQUEwQlMsYUFBYUcsSUFBSVIsTUFBTTtJQUMxRDtBQUNGO0FBRU8sU0FBU2dDLGdCQUFnQnhCLEdBQVE7SUFDdEMsT0FDRSx1S0FBQ2xCLGVBQUFBLEVBQWFrQixRQUFRLHFNQUFDakIsc0JBQUFBLEVBQW9CaUIsUUFBUSxrTUFBQ2Ysb0JBQUFBLEVBQWtCZTtBQUUxRSIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxMjQ1NSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL3NlcnZlci9saWIvc291cmNlLW1hcHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBTb3VyY2VNYXAgfSBmcm9tICdtb2R1bGUnXG5cbmZ1bmN0aW9uIG5vU291cmNlTWFwKCk6IFNvdXJjZU1hcCB8IHVuZGVmaW5lZCB7XG4gIHJldHVybiB1bmRlZmluZWRcbn1cblxuLy8gRWRnZSBydW50aW1lIGRvZXMgbm90IGltcGxlbWVudCBgbW9kdWxlYFxuY29uc3QgbmF0aXZlRmluZFNvdXJjZU1hcCA9XG4gIHByb2Nlc3MuZW52Lk5FWFRfUlVOVElNRSA9PT0gJ2VkZ2UnXG4gICAgPyBub1NvdXJjZU1hcFxuICAgIDogKHJlcXVpcmUoJ21vZHVsZScpIGFzIHR5cGVvZiBpbXBvcnQoJ21vZHVsZScpKS5maW5kU291cmNlTWFwXG5cbi8qKlxuICogaHR0cHM6Ly90YzM5LmVzL3NvdXJjZS1tYXAvI2luZGV4LW1hcFxuICovXG5pbnRlcmZhY2UgSW5kZXhTb3VyY2VNYXBTZWN0aW9uIHtcbiAgb2Zmc2V0OiB7XG4gICAgbGluZTogbnVtYmVyXG4gICAgY29sdW1uOiBudW1iZXJcbiAgfVxuICBtYXA6IEJhc2ljU291cmNlTWFwUGF5bG9hZFxufVxuXG4vLyBUT0RPKHZlaWwpOiBVcHN0cmVhbSB0eXBlc1xuLyoqIGh0dHBzOi8vdGMzOS5lcy9lY21hNDI2LyNzZWMtaW5kZXgtc291cmNlLW1hcCAqL1xuaW50ZXJmYWNlIEluZGV4U291cmNlTWFwIHtcbiAgdmVyc2lvbjogbnVtYmVyXG4gIGZpbGU6IHN0cmluZ1xuICBzZWN0aW9uczogSW5kZXhTb3VyY2VNYXBTZWN0aW9uW11cbn1cblxuLyoqIGh0dHBzOi8vdGMzOS5lcy9lY21hNDI2LyNzZWMtc291cmNlLW1hcC1mb3JtYXQgKi9cbmV4cG9ydCBpbnRlcmZhY2UgQmFzaWNTb3VyY2VNYXBQYXlsb2FkIHtcbiAgdmVyc2lvbjogbnVtYmVyXG4gIC8vIFRPRE86IE1vdmUgdG8gaHR0cHM6Ly9naXRodWIuY29tL2pyaWRnZXdlbGwvc291cmNlbWFwcyB3aGljaCBpcyBhY3RpdmVseSBtYWludGFpbmVkXG4gIC8qKiBXQVJOSU5HOiBgZmlsZWAgaXMgb3B0aW9uYWwuICovXG4gIGZpbGU6IHN0cmluZ1xuICBzb3VyY2VSb290Pzogc3RyaW5nXG4gIC8vIFRPRE86IE1vdmUgdG8gaHR0cHM6Ly9naXRodWIuY29tL2pyaWRnZXdlbGwvc291cmNlbWFwcyB3aGljaCBpcyBhY3RpdmVseSBtYWludGFpbmVkXG4gIC8qKiBXQVJOSU5HOiBgc291cmNlc1tudW1iZXJdYCBjYW4gYmUgYG51bGxgLiAqL1xuICBzb3VyY2VzOiBBcnJheTxzdHJpbmc+XG4gIG5hbWVzOiBBcnJheTxzdHJpbmc+XG4gIG1hcHBpbmdzOiBzdHJpbmdcbiAgaWdub3JlTGlzdD86IG51bWJlcltdXG59XG5cbmV4cG9ydCB0eXBlIE1vZGVyblNvdXJjZU1hcFBheWxvYWQgPSBCYXNpY1NvdXJjZU1hcFBheWxvYWQgfCBJbmRleFNvdXJjZU1hcFxuXG5leHBvcnQgZnVuY3Rpb24gc291cmNlTWFwSWdub3JlTGlzdHNFdmVyeXRoaW5nKFxuICBzb3VyY2VNYXA6IEJhc2ljU291cmNlTWFwUGF5bG9hZFxuKTogYm9vbGVhbiB7XG4gIHJldHVybiAoXG4gICAgc291cmNlTWFwLmlnbm9yZUxpc3QgIT09IHVuZGVmaW5lZCAmJlxuICAgIHNvdXJjZU1hcC5zb3VyY2VzLmxlbmd0aCA9PT0gc291cmNlTWFwLmlnbm9yZUxpc3QubGVuZ3RoXG4gIClcbn1cblxuLyoqXG4gKiBGaW5kcyB0aGUgc291cmNlbWFwIHBheWxvYWQgYXBwbGljYWJsZSB0byBhIGdpdmVuIGZyYW1lLlxuICogRXF1YWwgdG8gdGhlIGlucHV0IHVubGVzcyBhbiBJbmRleCBTb3VyY2UgTWFwIGlzIHVzZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kQXBwbGljYWJsZVNvdXJjZU1hcFBheWxvYWQoXG4gIGxpbmUwOiBudW1iZXIsXG4gIGNvbHVtbjA6IG51bWJlcixcbiAgcGF5bG9hZDogTW9kZXJuU291cmNlTWFwUGF5bG9hZFxuKTogQmFzaWNTb3VyY2VNYXBQYXlsb2FkIHwgdW5kZWZpbmVkIHtcbiAgaWYgKCdzZWN0aW9ucycgaW4gcGF5bG9hZCkge1xuICAgIGlmIChwYXlsb2FkLnNlY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH1cblxuICAgIC8vIFNlY3Rpb25zIG11c3Qgbm90IG92ZXJsYXAgYW5kIG11c3QgYmUgc29ydGVkOiBodHRwczovL3RjMzkuZXMvc291cmNlLW1hcC8jc2VjdGlvbi1vYmplY3RcbiAgICAvLyBUaGVyZWZvcmUgdGhlIGxhc3Qgc2VjdGlvbiB0aGF0IGhhcyBhbiBvZmZzZXQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBmcmFtZSBpcyB0aGUgYXBwbGljYWJsZSBvbmUuXG4gICAgY29uc3Qgc2VjdGlvbnMgPSBwYXlsb2FkLnNlY3Rpb25zXG4gICAgbGV0IGxlZnQgPSAwXG4gICAgbGV0IHJpZ2h0ID0gc2VjdGlvbnMubGVuZ3RoIC0gMVxuICAgIGxldCByZXN1bHQ6IEluZGV4U291cmNlTWFwU2VjdGlvbiB8IG51bGwgPSBudWxsXG5cbiAgICB3aGlsZSAobGVmdCA8PSByaWdodCkge1xuICAgICAgLy8gZmFzdCBNYXRoLmZsb29yXG4gICAgICBjb25zdCBtaWRkbGUgPSB+figobGVmdCArIHJpZ2h0KSAvIDIpXG4gICAgICBjb25zdCBzZWN0aW9uID0gc2VjdGlvbnNbbWlkZGxlXVxuICAgICAgY29uc3Qgb2Zmc2V0ID0gc2VjdGlvbi5vZmZzZXRcblxuICAgICAgaWYgKFxuICAgICAgICBvZmZzZXQubGluZSA8IGxpbmUwIHx8XG4gICAgICAgIChvZmZzZXQubGluZSA9PT0gbGluZTAgJiYgb2Zmc2V0LmNvbHVtbiA8PSBjb2x1bW4wKVxuICAgICAgKSB7XG4gICAgICAgIHJlc3VsdCA9IHNlY3Rpb25cbiAgICAgICAgbGVmdCA9IG1pZGRsZSArIDFcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJpZ2h0ID0gbWlkZGxlIC0gMVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQgPT09IG51bGwgPyB1bmRlZmluZWQgOiByZXN1bHQubWFwXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHBheWxvYWRcbiAgfVxufVxuXG5jb25zdCBkaWRXYXJuQWJvdXRJbnZhbGlkU291cmNlTWFwREVWID0gbmV3IFNldDxzdHJpbmc+KClcblxuY29uc3QgZmluZFNvdXJjZU1hcDogKHNjcmlwdE5hbWVPclNvdXJjZVVSTDogc3RyaW5nKSA9PiBTb3VyY2VNYXAgfCB1bmRlZmluZWQgPVxuICBwcm9jZXNzLmVudi5ORVhUX1JVTlRJTUUgPT09ICdub2RlanMnICYmXG4gIHByb2Nlc3MudmVyc2lvbnMubm9kZT8uc3RhcnRzV2l0aCgnMTgnKVxuICAgID8gLy8gTm9kZS5qcyAxOCBoYXMgYSBob3JyaWJseSBzbG93IGBmaW5kU291cmNlTWFwYCBpbXBsZW1lbnRhdGlvblxuICAgICAgbm9Tb3VyY2VNYXBcbiAgICA6IG5hdGl2ZUZpbmRTb3VyY2VNYXBcblxuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlclN0YWNrRnJhbWVERVYoXG4gIHNvdXJjZVVSTDogc3RyaW5nLFxuICBmdW5jdGlvbk5hbWU6IHN0cmluZyxcbiAgbGluZTE6IG51bWJlcixcbiAgY29sdW1uMTogbnVtYmVyXG4pOiBib29sZWFuIHtcbiAgaWYgKHNvdXJjZVVSTCA9PT0gJycpIHtcbiAgICAvLyBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBmaWx0ZXJzIG91dCA8YW5vbnltb3VzPiBzdGFjayBmcmFtZXNcbiAgICAvLyBidXQgd2Ugd2FudCB0byByZXRhaW4gdGhlbSBiZWNhdXNlIGN1cnJlbnQgU2VydmVyIENvbXBvbmVudHMgYW5kXG4gICAgLy8gYnVpbHQtaW4gQ29tcG9uZW50cyBpbiBwYXJlbnQgc3RhY2tzIGRvbid0IGhhdmUgc291cmNlIGxvY2F0aW9uLlxuICAgIC8vIEZpbHRlciBvdXQgZnJhbWVzIHRoYXQgc2hvdyB1cCBpbiBQcm9taXNlcyB0byBnZXQgZ29vZCBuYW1lcyBpbiBSZWFjdCdzXG4gICAgLy8gU2VydmVyIFJlcXVlc3QgdHJhY2sgdW50aWwgd2UgY29tZSB1cCB3aXRoIGEgYmV0dGVyIGhldXJpc3RpYy5cbiAgICByZXR1cm4gKFxuICAgICAgZnVuY3Rpb25OYW1lICE9PSAnbmV3IFByb21pc2UnICYmXG4gICAgICBmdW5jdGlvbk5hbWUgIT09ICdQcm9taXNlLnRoZW4nICYmXG4gICAgICBmdW5jdGlvbk5hbWUgIT09ICdQcm9taXNlLmNhdGNoJyAmJlxuICAgICAgZnVuY3Rpb25OYW1lICE9PSAnUHJvbWlzZS5maW5hbGx5JyAmJlxuICAgICAgZnVuY3Rpb25OYW1lICE9PSAnRnVuY3Rpb24ud2l0aFJlc29sdmVycycgJiZcbiAgICAgIGZ1bmN0aW9uTmFtZSAhPT0gJ0Z1bmN0aW9uLmFsbCcgJiZcbiAgICAgIGZ1bmN0aW9uTmFtZSAhPT0gJ0Z1bmN0aW9uLmFsbFNldHRsZWQnXG4gICAgKVxuICB9XG4gIGlmIChzb3VyY2VVUkwuc3RhcnRzV2l0aCgnbm9kZTonKSB8fCBzb3VyY2VVUkwuaW5jbHVkZXMoJ25vZGVfbW9kdWxlcycpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgdHJ5IHtcbiAgICAvLyBOb2RlLmpzIGxvYWRzIHNvdXJjZSBtYXBzIGVhZ2VybHkgc28gdGhpcyBjYWxsIGlzIGNoZWFwLlxuICAgIC8vIFRPRE86IEVTTSBzb3VyY2VtYXBzIGFyZSBPKDEpIGJ1dCBDb21tb25KUyBzb3VyY2VtYXBzIGFyZSBPKE51bWJlciBvZiBDSlMgbW9kdWxlcykuXG4gICAgLy8gTWFrZSBzdXJlIHRoaXMgZG9lc24ndCBhZHZlcnNlbHkgYWZmZWN0IHBlcmZvcm1hbmNlIHdoZW4gQ0pTIGlzIHVzZWQgYnkgTmV4dC5qcy5cbiAgICBjb25zdCBzb3VyY2VNYXAgPSBmaW5kU291cmNlTWFwKHNvdXJjZVVSTClcbiAgICBpZiAoc291cmNlTWFwID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIE5vIHNvdXJjZSBtYXAgYXNzb2ljYXRlZC5cbiAgICAgIC8vIFRPRE86IE5vZGUuanMgdHlwZXMgc2hvdWxkIHJlZmxlY3QgdGhhdCBgZmluZFNvdXJjZU1hcGAgY2FuIHJldHVybiBgdW5kZWZpbmVkYC5cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGNvbnN0IHNvdXJjZU1hcFBheWxvYWQgPSBmaW5kQXBwbGljYWJsZVNvdXJjZU1hcFBheWxvYWQoXG4gICAgICBsaW5lMSAtIDEsXG4gICAgICBjb2x1bW4xIC0gMSxcbiAgICAgIHNvdXJjZU1hcC5wYXlsb2FkXG4gICAgKVxuICAgIGlmIChzb3VyY2VNYXBQYXlsb2FkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIE5vIHNvdXJjZSBtYXAgc2VjdGlvbiBhcHBsaWNhYmxlIHRvIHRoZSBmcmFtZS5cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiAhc291cmNlTWFwSWdub3JlTGlzdHNFdmVyeXRoaW5nKHNvdXJjZU1hcFBheWxvYWQpXG4gIH0gY2F0Y2ggKGNhdXNlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIFRPRE86IFNoYXJlIGNhY2hlIHdpdGggcGF0Y2gtZXJyb3ItaW5zcGVjdFxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRJbnZhbGlkU291cmNlTWFwREVWLmhhcyhzb3VyY2VVUkwpKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dEludmFsaWRTb3VyY2VNYXBERVYuYWRkKHNvdXJjZVVSTClcbiAgICAgICAgLy8gV2Ugc2hvdWxkIG5vdCBsb2cgYW4gYWN0dWFsIGVycm9yIGluc3RhbmNlIGhlcmUgYmVjYXVzZSB0aGF0IHdpbGwgcmUtZW50ZXJcbiAgICAgICAgLy8gdGhpcyBjb2RlcGF0aCBkdXJpbmcgZXJyb3IgaW5zcGVjdGlvbiBhbmQgY291bGQgbGVhZCB0byBpbmZpbml0ZSByZWN1cnNpb24uXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgYCR7c291cmNlVVJMfTogSW52YWxpZCBzb3VyY2UgbWFwLiBPbmx5IGNvbmZvcm1hbnQgc291cmNlIG1hcHMgY2FuIGJlIHVzZWQgdG8gZmlsdGVyIHN0YWNrIGZyYW1lcy4gQ2F1c2U6ICR7Y2F1c2V9YFxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGV2aXJ0dWFsaXplUmVhY3RTZXJ2ZXJVUkwoc291cmNlVVJMOiBzdHJpbmcpOiBzdHJpbmcge1xuICBpZiAoc291cmNlVVJMLnN0YXJ0c1dpdGgoJ3JzYzovL1JlYWN0LycpKSB7XG4gICAgLy8gcnNjOi8vUmVhY3QvU2VydmVyL2ZpbGU6Ly88ZmlsZW5hbWU+PzQyID0+IGZpbGU6Ly88ZmlsZW5hbWU+XG4gICAgY29uc3QgZW52SWR4ID0gc291cmNlVVJMLmluZGV4T2YoJy8nLCAncnNjOi8vUmVhY3QvJy5sZW5ndGgpXG4gICAgY29uc3Qgc3VmZml4SWR4ID0gc291cmNlVVJMLmxhc3RJbmRleE9mKCc/JylcbiAgICBpZiAoZW52SWR4ID4gLTEgJiYgc3VmZml4SWR4ID4gLTEpIHtcbiAgICAgIHJldHVybiBkZWNvZGVVUkkoc291cmNlVVJMLnNsaWNlKGVudklkeCArIDEsIHN1ZmZpeElkeCkpXG4gICAgfVxuICB9XG4gIHJldHVybiBzb3VyY2VVUkxcbn1cblxuZnVuY3Rpb24gaXNBbm9ueW1vdXNGcmFtZUxpa2VseUpTTmF0aXZlKG1ldGhvZE5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAvLyBBbm9ueW1vdXMgZnJhbWVzIGNhbiBhbHNvIGJlIHByb2R1Y2VkIGluIFJlYWN0IHBhcmVudCBzdGFja3MgZWl0aGVyIGZyb21cbiAgLy8gaG9zdCBjb21wb25lbnRzIG9yIFNlcnZlciBDb21wb25lbnRzLiBXZSBkb24ndCB3YW50IHRvIGlnbm9yZSB0aG9zZS5cbiAgLy8gVGhpcyBjb3VsZCBoaWRlIHVzZXItc3BhY2UgbWV0aG9kcyB0aGF0IGFyZSBuYW1lZCBsaWtlIG5hdGl2ZSBKUyBtZXRob2RzIGJ1dFxuICAvLyBzaG91bGQgeW91IHJlYWxseSBkbyB0aGF0P1xuICByZXR1cm4gKFxuICAgIC8vIGUuZy4gSlNPTi5wYXJzZVxuICAgIG1ldGhvZE5hbWUuc3RhcnRzV2l0aCgnSlNPTi4nKSB8fFxuICAgIC8vIEUuZy4gUHJvbWlzZS53aXRoUmVzb2x2ZXNcbiAgICBtZXRob2ROYW1lLnN0YXJ0c1dpdGgoJ0Z1bmN0aW9uLicpIHx8XG4gICAgLy8gdmFyaW91cyBKUyBidWlsdC1pbnNcbiAgICBtZXRob2ROYW1lLnN0YXJ0c1dpdGgoJ1Byb21pc2UuJykgfHxcbiAgICBtZXRob2ROYW1lLnN0YXJ0c1dpdGgoJ0FycmF5LicpIHx8XG4gICAgbWV0aG9kTmFtZS5zdGFydHNXaXRoKCdTZXQuJykgfHxcbiAgICBtZXRob2ROYW1lLnN0YXJ0c1dpdGgoJ01hcC4nKVxuICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpZ25vcmVMaXN0QW5vbnltb3VzU3RhY2tGcmFtZXNJZlNhbmR3aWNoZWQ8RnJhbWU+KFxuICBmcmFtZXM6IEZyYW1lW10sXG4gIGlzQW5vbnltb3VzRnJhbWU6IChmcmFtZTogRnJhbWUpID0+IGJvb2xlYW4sXG4gIGlzSWdub3JlZEZyYW1lOiAoZnJhbWU6IEZyYW1lKSA9PiBib29sZWFuLFxuICBnZXRNZXRob2ROYW1lOiAoZnJhbWU6IEZyYW1lKSA9PiBzdHJpbmcsXG4gIC8qKiBvbmx5IHBhc3NlcyBmcmFtZXMgZm9yIHdoaWNoIGBpc0Fub255bW91c0ZyYW1lYCBhbmQgdGhlaXIgbWV0aG9kIGlzIGEgbmF0aXZlIEpTIG1ldGhvZCBvciBgaXNJZ25vcmVkRnJhbWVgIHJldHVybiB0cnVlICovXG4gIGlnbm9yZUZyYW1lOiAoZnJhbWU6IEZyYW1lKSA9PiB2b2lkXG4pOiB2b2lkIHtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBmcmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjdXJyZW50RnJhbWUgPSBmcmFtZXNbaV1cbiAgICBpZiAoXG4gICAgICAhKFxuICAgICAgICBpc0Fub255bW91c0ZyYW1lKGN1cnJlbnRGcmFtZSkgJiZcbiAgICAgICAgaXNBbm9ueW1vdXNGcmFtZUxpa2VseUpTTmF0aXZlKGdldE1ldGhvZE5hbWUoY3VycmVudEZyYW1lKSlcbiAgICAgIClcbiAgICApIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgY29uc3QgcHJldmlvdXNGcmFtZUlzSWdub3JlZCA9IGlzSWdub3JlZEZyYW1lKGZyYW1lc1tpIC0gMV0pXG4gICAgaWYgKHByZXZpb3VzRnJhbWVJc0lnbm9yZWQgJiYgaSA8IGZyYW1lcy5sZW5ndGggLSAxKSB7XG4gICAgICBsZXQgaWdub3JlU2FuZHdpY2ggPSBmYWxzZVxuICAgICAgbGV0IGogPSBpICsgMVxuICAgICAgZm9yIChqOyBqIDwgZnJhbWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGNvbnN0IG5leHRGcmFtZSA9IGZyYW1lc1tqXVxuICAgICAgICBjb25zdCBuZXh0RnJhbWVJc0Fub255bW91cyA9XG4gICAgICAgICAgaXNBbm9ueW1vdXNGcmFtZShuZXh0RnJhbWUpICYmXG4gICAgICAgICAgaXNBbm9ueW1vdXNGcmFtZUxpa2VseUpTTmF0aXZlKGdldE1ldGhvZE5hbWUobmV4dEZyYW1lKSlcbiAgICAgICAgaWYgKG5leHRGcmFtZUlzQW5vbnltb3VzKSB7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5leHRGcmFtZUlzSWdub3JlZCA9IGlzSWdub3JlZEZyYW1lKG5leHRGcmFtZSlcbiAgICAgICAgaWYgKG5leHRGcmFtZUlzSWdub3JlZCkge1xuICAgICAgICAgIGlnbm9yZVNhbmR3aWNoID0gdHJ1ZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlnbm9yZVNhbmR3aWNoKSB7XG4gICAgICAgIGZvciAoaTsgaSA8IGo7IGkrKykge1xuICAgICAgICAgIGlnbm9yZUZyYW1lKGZyYW1lc1tpXSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJub1NvdXJjZU1hcCIsInVuZGVmaW5lZCIsIm5hdGl2ZUZpbmRTb3VyY2VNYXAiLCJlbnYiLCJORVhUX1JVTlRJTUUiLCJyZXF1aXJlIiwiZmluZFNvdXJjZU1hcCIsInNvdXJjZU1hcElnbm9yZUxpc3RzRXZlcnl0aGluZyIsInNvdXJjZU1hcCIsImlnbm9yZUxpc3QiLCJzb3VyY2VzIiwibGVuZ3RoIiwiZmluZEFwcGxpY2FibGVTb3VyY2VNYXBQYXlsb2FkIiwibGluZTAiLCJjb2x1bW4wIiwicGF5bG9hZCIsInNlY3Rpb25zIiwibGVmdCIsInJpZ2h0IiwicmVzdWx0IiwibWlkZGxlIiwic2VjdGlvbiIsIm9mZnNldCIsImxpbmUiLCJjb2x1bW4iLCJtYXAiLCJkaWRXYXJuQWJvdXRJbnZhbGlkU291cmNlTWFwREVWIiwiU2V0IiwidmVyc2lvbnMiLCJub2RlIiwic3RhcnRzV2l0aCIsImZpbHRlclN0YWNrRnJhbWVERVYiLCJzb3VyY2VVUkwiLCJmdW5jdGlvbk5hbWUiLCJsaW5lMSIsImNvbHVtbjEiLCJpbmNsdWRlcyIsInNvdXJjZU1hcFBheWxvYWQiLCJjYXVzZSIsIk5PREVfRU5WIiwiaGFzIiwiYWRkIiwiY29uc29sZSIsImVycm9yIiwiZGV2aXJ0dWFsaXplUmVhY3RTZXJ2ZXJVUkwiLCJlbnZJZHgiLCJpbmRleE9mIiwic3VmZml4SWR4IiwibGFzdEluZGV4T2YiLCJkZWNvZGVVUkkiLCJzbGljZSIsImlzQW5vbnltb3VzRnJhbWVMaWtlbHlKU05hdGl2ZSIsIm1ldGhvZE5hbWUiLCJpZ25vcmVMaXN0QW5vbnltb3VzU3RhY2tGcmFtZXNJZlNhbmR3aWNoZWQiLCJmcmFtZXMiLCJpc0Fub255bW91c0ZyYW1lIiwiaXNJZ25vcmVkRnJhbWUiLCJnZXRNZXRob2ROYW1lIiwiaWdub3JlRnJhbWUiLCJpIiwiY3VycmVudEZyYW1lIiwicHJldmlvdXNGcmFtZUlzSWdub3JlZCIsImlnbm9yZVNhbmR3aWNoIiwiaiIsIm5leHRGcmFtZSIsIm5leHRGcmFtZUlzQW5vbnltb3VzIiwibmV4dEZyYW1lSXNJZ25vcmVkIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0lBeUdFQTtBQXZHRixTQUFTQztJQUNQLE9BQU9DO0FBQ1Q7QUFFQSwyQ0FBMkM7QUFDM0MsTUFBTUMsc0JBQ0pILFFBQVFJLEdBQUcsQ0FBQ0MsWUFBWSxLQUFLLFNBQ3pCSiwwQkFDQ0ssUUFBUSwrREFBc0NDLGFBQWE7QUFzQzNELFNBQVNDLCtCQUNkQyxTQUFnQztJQUVoQyxPQUNFQSxVQUFVQyxVQUFVLEtBQUtSLGFBQ3pCTyxVQUFVRSxPQUFPLENBQUNDLE1BQU0sS0FBS0gsVUFBVUMsVUFBVSxDQUFDRSxNQUFNO0FBRTVEO0FBTU8sU0FBU0MsK0JBQ2RDLEtBQWEsRUFDYkMsT0FBZSxFQUNmQyxPQUErQjtJQUUvQixJQUFJLGNBQWNBLFNBQVM7UUFDekIsSUFBSUEsUUFBUUMsUUFBUSxDQUFDTCxNQUFNLEtBQUssR0FBRztZQUNqQyxPQUFPVjtRQUNUO1FBRUEsMkZBQTJGO1FBQzNGLHVHQUF1RztRQUN2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QkFBaUI7b0JBQ2pCO2dCQUNGO1lBQ0Y7WUFFQSxJQUFJQSxnQkFBZ0I7Z0JBQ2xCLElBQUtILEdBQUdBLElBQUlJLEdBQUdKLElBQUs7b0JBQ2xCRCxZQUFZSixNQUFNLENBQUNLLEVBQUU7Z0JBQ3ZCO1lBQ0Y7UUFDRjtJQUNGO0FBQ0YiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTI1OTYsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NyYy9zZXJ2ZXIvYXBwLXJlbmRlci9jb2xsZWN0LXNlZ21lbnQtZGF0YS50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUge1xuICBDYWNoZU5vZGVTZWVkRGF0YSxcbiAgRmxpZ2h0Um91dGVyU3RhdGUsXG4gIEluaXRpYWxSU0NQYXlsb2FkLFxuICBTZWdtZW50IGFzIEZsaWdodFJvdXRlclN0YXRlU2VnbWVudCxcbiAgRHluYW1pY1BhcmFtVHlwZXNTaG9ydCxcbn0gZnJvbSAnLi90eXBlcydcbmltcG9ydCB0eXBlIHsgTWFuaWZlc3ROb2RlIH0gZnJvbSAnLi4vLi4vYnVpbGQvd2VicGFjay9wbHVnaW5zL2ZsaWdodC1tYW5pZmVzdC1wbHVnaW4nXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tZXh0cmFuZW91cy1kZXBlbmRlbmNpZXNcbmltcG9ydCB7IGNyZWF0ZUZyb21SZWFkYWJsZVN0cmVhbSB9IGZyb20gJ3JlYWN0LXNlcnZlci1kb20td2VicGFjay9jbGllbnQnXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzXG5pbXBvcnQgeyB1bnN0YWJsZV9wcmVyZW5kZXIgYXMgcHJlcmVuZGVyIH0gZnJvbSAncmVhY3Qtc2VydmVyLWRvbS13ZWJwYWNrL3N0YXRpYydcblxuaW1wb3J0IHtcbiAgc3RyZWFtRnJvbUJ1ZmZlcixcbiAgc3RyZWFtVG9CdWZmZXIsXG59IGZyb20gJy4uL3N0cmVhbS11dGlscy9ub2RlLXdlYi1zdHJlYW1zLWhlbHBlcidcbmltcG9ydCB7IHdhaXRBdExlYXN0T25lUmVhY3RSZW5kZXJUYXNrIH0gZnJvbSAnLi4vLi4vbGliL3NjaGVkdWxlcidcbmltcG9ydCB0eXBlIHtcbiAgSGVhZERhdGEsXG4gIExvYWRpbmdNb2R1bGVEYXRhLFxufSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB7XG4gIGVuY29kZUNoaWxkU2VnbWVudEtleSxcbiAgZW5jb2RlU2VnbWVudCxcbiAgUk9PVF9TRUdNRU5UX0tFWSxcbiAgdHlwZSBFbmNvZGVkU2VnbWVudCxcbn0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi9zZWdtZW50LWNhY2hlL3NlZ21lbnQtdmFsdWUtZW5jb2RpbmcnXG5pbXBvcnQgeyBnZXREaWdlc3RGb3JXZWxsS25vd25FcnJvciB9IGZyb20gJy4vY3JlYXRlLWVycm9yLWhhbmRsZXInXG5pbXBvcnQgdHlwZSB7IEZhbGxiYWNrUm91dGVQYXJhbXMgfSBmcm9tICcuLi9yZXF1ZXN0L2ZhbGxiYWNrLXBhcmFtcydcblxuLy8gQ29udGFpbnMgbWV0YWRhdGEgYWJvdXQgdGhlIHJvdXRlIHRyZWUuIFRoZSBjbGllbnQgbXVzdCBmZXRjaCB0aGlzIGJlZm9yZVxuLy8gaXQgY2FuIGZldGNoIGFueSBhY3R1YWwgc2VnbWVudCBkYXRhLlxuZXhwb3J0IHR5cGUgUm9vdFRyZWVQcmVmZXRjaCA9IHtcbiAgYnVpbGRJZDogc3RyaW5nXG4gIHRyZWU6IFRyZWVQcmVmZXRjaFxuICBoZWFkOiBIZWFkRGF0YVxuICBpc0hlYWRQYXJ0aWFsOiBib29sZWFuXG4gIHN0YWxlVGltZTogbnVtYmVyXG59XG5cbmV4cG9ydCB0eXBlIFRyZWVQcmVmZXRjaCA9IHtcbiAgLy8gVGhlIHNlZ21lbnQsIGluIHRoZSBmb3JtYXQgZXhwZWN0ZWQgYnkgYSBGbGlnaHRSb3V0ZXJTdGF0ZS5cbiAgc2VnbWVudDogRmxpZ2h0Um91dGVyU3RhdGVTZWdtZW50XG5cbiAgLy8gQ2hpbGQgc2VnbWVudHMuXG4gIHNsb3RzOiBudWxsIHwge1xuICAgIFtwYXJhbGxlbFJvdXRlS2V5OiBzdHJpbmddOiBUcmVlUHJlZmV0Y2hcbiAgfVxuXG4gIC8vIEV4dHJhIGZpZWxkcyB0aGF0IG9ubHkgZXhpc3Qgc28gd2UgY2FuIHJlY29uc3RydWN0IGEgRmxpZ2h0Um91dGVyU3RhdGUgb25cbiAgLy8gdGhlIGNsaWVudC4gV2UgbWF5IGJlIGFibGUgdG8gdW5pZnkgVHJlZVByZWZldGNoIGFuZCBGbGlnaHRSb3V0ZXJTdGF0ZVxuICAvLyBhZnRlciBzb21lIHJlZmFjdG9yaW5nLCBidXQgaW4gdGhlIG1lYW50aW1lIGl0IHdvdWxkIGJlIHdhc3RlZnVsIHRvIGFkZCBhXG4gIC8vIGJ1bmNoIG9mIG5ldyBwcmVmZXRjaC1vbmx5IGZpZWxkcyB0byBGbGlnaHRSb3V0ZXJTdGF0ZS4gU28gdGhpbmsgb2ZcbiAgLy8gVHJlZVByZWZldGNoIGFzIGEgc3VwZXJzZXQgb2YgRmxpZ2h0Um91dGVyU3RhdGUuXG4gIGlzUm9vdExheW91dDogYm9vbGVhblxufVxuXG5leHBvcnQgdHlwZSBTZWdtZW50UHJlZmV0Y2ggPSB7XG4gIGJ1aWxkSWQ6IHN0cmluZ1xuICByc2M6IFJlYWN0LlJlYWN0Tm9kZSB8IG51bGxcbiAgbG9hZGluZzogTG9hZGluZ01vZHVsZURhdGEgfCBQcm9taXNlPExvYWRpbmdNb2R1bGVEYXRhPlxuICBpc1BhcnRpYWw6IGJvb2xlYW5cbn1cblxuY29uc3QgZmlsdGVyU3RhY2tGcmFtZSA9XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbidcbiAgICA/IChyZXF1aXJlKCcuLi9saWIvc291cmNlLW1hcHMnKSBhcyB0eXBlb2YgaW1wb3J0KCcuLi9saWIvc291cmNlLW1hcHMnKSlcbiAgICAgICAgLmZpbHRlclN0YWNrRnJhbWVERVZcbiAgICA6IHVuZGVmaW5lZFxuXG5mdW5jdGlvbiBvblNlZ21lbnRQcmVyZW5kZXJFcnJvcihlcnJvcjogdW5rbm93bikge1xuICBjb25zdCBkaWdlc3QgPSBnZXREaWdlc3RGb3JXZWxsS25vd25FcnJvcihlcnJvcilcbiAgaWYgKGRpZ2VzdCkge1xuICAgIHJldHVybiBkaWdlc3RcbiAgfVxuICAvLyBXZSBkb24ndCBuZWVkIHRvIGxvZyB0aGUgZXJyb3JzIGJlY2F1c2Ugd2Ugd291bGQgaGF2ZSBhbHJlYWR5IGRvbmUgdGhhdFxuICAvLyB3aGVuIGdlbmVyYXRpbmcgdGhlIG9yaWdpbmFsIEZsaWdodCBzdHJlYW0gZm9yIHRoZSB3aG9sZSBwYWdlLlxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY29sbGVjdFNlZ21lbnREYXRhKFxuICBmdWxsUGFnZURhdGFCdWZmZXI6IEJ1ZmZlcixcbiAgc3RhbGVUaW1lOiBudW1iZXIsXG4gIGNsaWVudE1vZHVsZXM6IE1hbmlmZXN0Tm9kZSxcbiAgc2VydmVyQ29uc3VtZXJNYW5pZmVzdDogYW55LFxuICBmYWxsYmFja1JvdXRlUGFyYW1zOiBGYWxsYmFja1JvdXRlUGFyYW1zIHwgbnVsbFxuKTogUHJvbWlzZTxNYXA8c3RyaW5nLCBCdWZmZXI+PiB7XG4gIC8vIFRyYXZlcnNlIHRoZSByb3V0ZXIgdHJlZSBhbmQgZ2VuZXJhdGUgYSBwcmVmZXRjaCByZXNwb25zZSBmb3IgZWFjaCBzZWdtZW50LlxuXG4gIC8vIEEgbXV0YWJsZSBtYXAgdG8gY29sbGVjdCB0aGUgcmVzdWx0cyBhcyB3ZSB0cmF2ZXJzZSB0aGUgcm91dGUgdHJlZS5cbiAgY29uc3QgcmVzdWx0TWFwID0gbmV3IE1hcDxzdHJpbmcsIEJ1ZmZlcj4oKVxuXG4gIC8vIEJlZm9yZSB3ZSBzdGFydCwgd2FybSB1cCB0aGUgbW9kdWxlIGNhY2hlIGJ5IGRlY29kaW5nIHRoZSBwYWdlIGRhdGEgb25jZS5cbiAgLy8gVGhlbiB3ZSBjYW4gYXNzdW1lIHRoYXQgYW55IHJlbWFpbmluZyBhc3luYyB0YXNrcyB0aGF0IG9jY3VyIHRoZSBuZXh0IHRpbWVcbiAgLy8gYXJlIGR1ZSB0byBoYW5naW5nIHByb21pc2VzIGNhdXNlZCBieSBkeW5hbWljIGRhdGEgYWNjZXNzLiBOb3RlIHdlIG9ubHlcbiAgLy8gaGF2ZSB0byBkbyB0aGlzIG9uY2UgcGVyIHBhZ2UsIG5vdCBwZXIgaW5kaXZpZHVhbCBzZWdtZW50LlxuICAvL1xuICB0cnkge1xuICAgIGF3YWl0IGNyZWF0ZUZyb21SZWFkYWJsZVN0cmVhbShzdHJlYW1Gcm9tQnVmZmVyKGZ1bGxQYWdlRGF0YUJ1ZmZlciksIHtcbiAgICAgIHNlcnZlckNvbnN1bWVyTWFuaWZlc3QsXG4gICAgfSlcbiAgICBhd2FpdCB3YWl0QXRMZWFzdE9uZVJlYWN0UmVuZGVyVGFzaygpXG4gIH0gY2F0Y2gge31cblxuICAvLyBDcmVhdGUgYW4gYWJvcnQgY29udHJvbGxlciB0aGF0IHdlJ2xsIHVzZSB0byBzdG9wIHRoZSBzdHJlYW0uXG4gIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuICBjb25zdCBvbkNvbXBsZXRlZFByb2Nlc3NpbmdSb3V0ZVRyZWUgPSBhc3luYyAoKSA9PiB7XG4gICAgLy8gU2luY2UgYWxsIHdlJ3JlIGRvaW5nIGlzIGRlY29kaW5nIGFuZCByZS1lbmNvZGluZyBhIGNhY2hlZCBwcmVyZW5kZXIsIGlmXG4gICAgLy8gc2VyaWFsaXppbmcgdGhlIHN0cmVhbSB0YWtlcyBsb25nZXIgdGhhbiBhIG1pY3JvdGFzaywgaXQgbXVzdCBiZWNhdXNlIG9mXG4gICAgLy8gaGFuZ2luZyBwcm9taXNlcyBjYXVzZWQgYnkgZHluYW1pYyBkYXRhLlxuICAgIGF3YWl0IHdhaXRBdExlYXN0T25lUmVhY3RSZW5kZXJUYXNrKClcbiAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKVxuICB9XG5cbiAgLy8gR2VuZXJhdGUgYSBzdHJlYW0gZm9yIHRoZSByb3V0ZSB0cmVlIHByZWZldGNoLiBXaGlsZSB3ZSdyZSB3YWxraW5nIHRoZVxuICAvLyB0cmVlLCB3ZSdsbCBhbHNvIHNwYXduIGFkZGl0aW9uYWwgdGFza3MgdG8gZ2VuZXJhdGUgdGhlIHNlZ21lbnQgcHJlZmV0Y2hlcy5cbiAgLy8gVGhlIHByb21pc2VzIGZvciB0aGVzZSB0YXNrcyBhcmUgcHVzaGVkIHRvIGEgbXV0YWJsZSBhcnJheSB0aGF0IHdlIHdpbGxcbiAgLy8gYXdhaXQgb25jZSB0aGUgcm91dGUgdHJlZSBpcyBmdWxseSByZW5kZXJlZC5cbiAgY29uc3Qgc2VnbWVudFRhc2tzOiBBcnJheTxQcm9taXNlPFtzdHJpbmcsIEJ1ZmZlcl0+PiA9IFtdXG4gIGNvbnN0IHsgcHJlbHVkZTogdHJlZVN0cmVhbSB9ID0gYXdhaXQgcHJlcmVuZGVyKFxuICAgIC8vIFJvb3RUcmVlUHJlZmV0Y2ggaXMgbm90IGEgdmFsaWQgcmV0dXJuIHR5cGUgZm9yIGEgUmVhY3QgY29tcG9uZW50LCBidXRcbiAgICAvLyB3ZSBuZWVkIHRvIHVzZSBhIGNvbXBvbmVudCBzbyB0aGF0IHdoZW4gd2UgZGVjb2RlIHRoZSBvcmlnaW5hbCBzdHJlYW1cbiAgICAvLyBpbnNpZGUgb2YgaXQsIHRoZSBzaWRlIGVmZmVjdHMgYXJlIHRyYW5zZmVycmVkIHRvIHRoZSBuZXcgc3RyZWFtLlxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICA8UHJlZmV0Y2hUcmVlRGF0YVxuICAgICAgZnVsbFBhZ2VEYXRhQnVmZmVyPXtmdWxsUGFnZURhdGFCdWZmZXJ9XG4gICAgICBmYWxsYmFja1JvdXRlUGFyYW1zPXtmYWxsYmFja1JvdXRlUGFyYW1zfVxuICAgICAgc2VydmVyQ29uc3VtZXJNYW5pZmVzdD17c2VydmVyQ29uc3VtZXJNYW5pZmVzdH1cbiAgICAgIGNsaWVudE1vZHVsZXM9e2NsaWVudE1vZHVsZXN9XG4gICAgICBzdGFsZVRpbWU9e3N0YWxlVGltZX1cbiAgICAgIHNlZ21lbnRUYXNrcz17c2VnbWVudFRhc2tzfVxuICAgICAgb25Db21wbGV0ZWRQcm9jZXNzaW5nUm91dGVUcmVlPXtvbkNvbXBsZXRlZFByb2Nlc3NpbmdSb3V0ZVRyZWV9XG4gICAgLz4sXG4gICAgY2xpZW50TW9kdWxlcyxcbiAgICB7XG4gICAgICBmaWx0ZXJTdGFja0ZyYW1lLFxuICAgICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgb25FcnJvcjogb25TZWdtZW50UHJlcmVuZGVyRXJyb3IsXG4gICAgfVxuICApXG5cbiAgLy8gV3JpdGUgdGhlIHJvdXRlIHRyZWUgdG8gYSBzcGVjaWFsIGAvX3RyZWVgIHNlZ21lbnQuXG4gIGNvbnN0IHRyZWVCdWZmZXIgPSBhd2FpdCBzdHJlYW1Ub0J1ZmZlcih0cmVlU3RyZWFtKVxuICByZXN1bHRNYXAuc2V0KCcvX3RyZWUnLCB0cmVlQnVmZmVyKVxuXG4gIC8vIE5vdyB0aGF0IHdlJ3ZlIGZpbmlzaGVkIHJlbmRlcmluZyB0aGUgcm91dGUgdHJlZSwgYWxsIHRoZSBzZWdtZW50IHRhc2tzXG4gIC8vIHNob3VsZCBoYXZlIGJlZW4gc3Bhd25lZC4gQXdhaXQgdGhlbSBpbiBwYXJhbGxlbCBhbmQgd3JpdGUgdGhlIHNlZ21lbnRcbiAgLy8gcHJlZmV0Y2hlcyB0byB0aGUgcmVzdWx0IG1hcC5cbiAgZm9yIChjb25zdCBbc2VnbWVudFBhdGgsIGJ1ZmZlcl0gb2YgYXdhaXQgUHJvbWlzZS5hbGwoc2VnbWVudFRhc2tzKSkge1xuICAgIHJlc3VsdE1hcC5zZXQoc2VnbWVudFBhdGgsIGJ1ZmZlcilcbiAgfVxuXG4gIHJldHVybiByZXN1bHRNYXBcbn1cblxuYXN5bmMgZnVuY3Rpb24gUHJlZmV0Y2hUcmVlRGF0YSh7XG4gIGZ1bGxQYWdlRGF0YUJ1ZmZlcixcbiAgZmFsbGJhY2tSb3V0ZVBhcmFtcyxcbiAgc2VydmVyQ29uc3VtZXJNYW5pZmVzdCxcbiAgY2xpZW50TW9kdWxlcyxcbiAgc3RhbGVUaW1lLFxuICBzZWdtZW50VGFza3MsXG4gIG9uQ29tcGxldGVkUHJvY2Vzc2luZ1JvdXRlVHJlZSxcbn06IHtcbiAgZnVsbFBhZ2VEYXRhQnVmZmVyOiBCdWZmZXJcbiAgc2VydmVyQ29uc3VtZXJNYW5pZmVzdDogYW55XG4gIGZhbGxiYWNrUm91dGVQYXJhbXM6IEZhbGxiYWNrUm91dGVQYXJhbXMgfCBudWxsXG4gIGNsaWVudE1vZHVsZXM6IE1hbmlmZXN0Tm9kZVxuICBzdGFsZVRpbWU6IG51bWJlclxuICBzZWdtZW50VGFza3M6IEFycmF5PFByb21pc2U8W3N0cmluZywgQnVmZmVyXT4+XG4gIG9uQ29tcGxldGVkUHJvY2Vzc2luZ1JvdXRlVHJlZTogKCkgPT4gdm9pZFxufSk6IFByb21pc2U8Um9vdFRyZWVQcmVmZXRjaCB8IG51bGw+IHtcbiAgLy8gV2UncmUgY3VycmVudGx5IHJlbmRlcmluZyBhIEZsaWdodCByZXNwb25zZSBmb3IgdGhlIHJvdXRlIHRyZWUgcHJlZmV0Y2guXG4gIC8vIEluc2lkZSB0aGlzIGNvbXBvbmVudCwgZGVjb2RlIHRoZSBGbGlnaHQgc3RyZWFtIGZvciB0aGUgd2hvbGUgcGFnZS4gVGhpcyBpc1xuICAvLyBhIGhhY2sgdG8gdHJhbnNmZXIgdGhlIHNpZGUgZWZmZWN0cyBmcm9tIHRoZSBvcmlnaW5hbCBGbGlnaHQgc3RyZWFtIChlLmcuXG4gIC8vIEZsb2F0IHByZWxvYWRzKSBvbnRvIHRoZSBGbGlnaHQgc3RyZWFtIGZvciB0aGUgdHJlZSBwcmVmZXRjaC5cbiAgLy8gVE9ETzogUmVhY3QgbmVlZHMgYSBiZXR0ZXIgd2F5IHRvIGRvIHRoaXMuIE5lZWRlZCBmb3IgU2VydmVyIEFjdGlvbnMsIHRvby5cbiAgY29uc3QgaW5pdGlhbFJTQ1BheWxvYWQ6IEluaXRpYWxSU0NQYXlsb2FkID0gYXdhaXQgY3JlYXRlRnJvbVJlYWRhYmxlU3RyZWFtKFxuICAgIGNyZWF0ZVVuY2xvc2luZ1ByZWZldGNoU3RyZWFtKHN0cmVhbUZyb21CdWZmZXIoZnVsbFBhZ2VEYXRhQnVmZmVyKSksXG4gICAge1xuICAgICAgc2VydmVyQ29uc3VtZXJNYW5pZmVzdCxcbiAgICB9XG4gIClcblxuICBjb25zdCBidWlsZElkID0gaW5pdGlhbFJTQ1BheWxvYWQuYlxuXG4gIC8vIEZsaWdodERhdGFQYXRoIGlzIGFuIHVuc291bmQgdHlwZSwgaGVuY2UgdGhlIGFkZGl0aW9uYWwgY2hlY2tzLlxuICBjb25zdCBmbGlnaHREYXRhUGF0aHMgPSBpbml0aWFsUlNDUGF5bG9hZC5mXG4gIGlmIChmbGlnaHREYXRhUGF0aHMubGVuZ3RoICE9PSAxICYmIGZsaWdodERhdGFQYXRoc1swXS5sZW5ndGggIT09IDMpIHtcbiAgICBjb25zb2xlLmVycm9yKFxuICAgICAgJ0ludGVybmFsIE5leHQuanMgZXJyb3I6IEluaXRpYWxSU0NQYXlsb2FkIGRvZXMgbm90IG1hdGNoIHRoZSBleHBlY3RlZCAnICtcbiAgICAgICAgJ3NoYXBlIGZvciBhIHByZXJlbmRlcmVkIHBhZ2UgZHVyaW5nIHNlZ21lbnQgcHJlZmV0Y2ggZ2VuZXJhdGlvbi4nXG4gICAgKVxuICAgIHJldHVybiBudWxsXG4gIH1cbiAgY29uc3QgZmxpZ2h0Um91dGVyU3RhdGU6IEZsaWdodFJvdXRlclN0YXRlID0gZmxpZ2h0RGF0YVBhdGhzWzBdWzBdXG4gIGNvbnN0IHNlZWREYXRhOiBDYWNoZU5vZGVTZWVkRGF0YSA9IGZsaWdodERhdGFQYXRoc1swXVsxXVxuICBjb25zdCBoZWFkOiBIZWFkRGF0YSA9IGZsaWdodERhdGFQYXRoc1swXVsyXVxuXG4gIC8vIENvbXB1dGUgdGhlIHJvdXRlIG1ldGFkYXRhIHRyZWUgYnkgdHJhdmVyc2luZyB0aGUgRmxpZ2h0Um91dGVyU3RhdGUuIEFzIHdlXG4gIC8vIHdhbGsgdGhlIHRyZWUsIHdlIHdpbGwgYWxzbyBzcGF3biBhIHRhc2sgdG8gcHJvZHVjZSBhIHByZWZldGNoIHJlc3BvbnNlIGZvclxuICAvLyBlYWNoIHNlZ21lbnQuXG4gIGNvbnN0IHRyZWUgPSBjb2xsZWN0U2VnbWVudERhdGFJbXBsKFxuICAgIGZsaWdodFJvdXRlclN0YXRlLFxuICAgIGJ1aWxkSWQsXG4gICAgc2VlZERhdGEsXG4gICAgZmFsbGJhY2tSb3V0ZVBhcmFtcyxcbiAgICBjbGllbnRNb2R1bGVzLFxuICAgIFJPT1RfU0VHTUVOVF9LRVksXG4gICAgc2VnbWVudFRhc2tzXG4gIClcblxuICBjb25zdCBpc0hlYWRQYXJ0aWFsID0gYXdhaXQgaXNQYXJ0aWFsUlNDRGF0YShoZWFkLCBjbGllbnRNb2R1bGVzKVxuXG4gIC8vIE5vdGlmeSB0aGUgYWJvcnQgY29udHJvbGxlciB0aGF0IHdlJ3JlIGRvbmUgcHJvY2Vzc2luZyB0aGUgcm91dGUgdHJlZS5cbiAgLy8gQW55dGhpbmcgYXN5bmMgdGhhdCBoYXBwZW5zIGFmdGVyIHRoaXMgcG9pbnQgbXVzdCBiZSBkdWUgdG8gaGFuZ2luZ1xuICAvLyBwcm9taXNlcyBpbiB0aGUgb3JpZ2luYWwgc3RyZWFtLlxuICBvbkNvbXBsZXRlZFByb2Nlc3NpbmdSb3V0ZVRyZWUoKVxuXG4gIC8vIFJlbmRlciB0aGUgcm91dGUgdHJlZSB0byBhIHNwZWNpYWwgYC9fdHJlZWAgc2VnbWVudC5cbiAgY29uc3QgdHJlZVByZWZldGNoOiBSb290VHJlZVByZWZldGNoID0ge1xuICAgIGJ1aWxkSWQsXG4gICAgdHJlZSxcbiAgICBoZWFkLFxuICAgIGlzSGVhZFBhcnRpYWwsXG4gICAgc3RhbGVUaW1lLFxuICB9XG4gIHJldHVybiB0cmVlUHJlZmV0Y2hcbn1cblxuZnVuY3Rpb24gY29sbGVjdFNlZ21lbnREYXRhSW1wbChcbiAgcm91dGU6IEZsaWdodFJvdXRlclN0YXRlLFxuICBidWlsZElkOiBzdHJpbmcsXG4gIHNlZWREYXRhOiBDYWNoZU5vZGVTZWVkRGF0YSB8IG51bGwsXG4gIGZhbGxiYWNrUm91dGVQYXJhbXM6IEZhbGxiYWNrUm91dGVQYXJhbXMgfCBudWxsLFxuICBjbGllbnRNb2R1bGVzOiBNYW5pZmVzdE5vZGUsXG4gIGtleTogc3RyaW5nLFxuICBzZWdtZW50VGFza3M6IEFycmF5PFByb21pc2U8W3N0cmluZywgQnVmZmVyXT4+XG4pOiBUcmVlUHJlZmV0Y2gge1xuICAvLyBNZXRhZGF0YSBhYm91dCB0aGUgc2VnbWVudC4gU2VudCBhcyBwYXJ0IG9mIHRoZSB0cmVlIHByZWZldGNoLiBOdWxsIGlmXG4gIC8vIHRoZXJlIGFyZSBubyBjaGlsZHJlbi5cbiAgbGV0IHNsb3RNZXRhZGF0YTogeyBbcGFyYWxsZWxSb3V0ZUtleTogc3RyaW5nXTogVHJlZVByZWZldGNoIH0gfCBudWxsID0gbnVsbFxuXG4gIGNvbnN0IGNoaWxkcmVuID0gcm91dGVbMV1cbiAgY29uc3Qgc2VlZERhdGFDaGlsZHJlbiA9IHNlZWREYXRhICE9PSBudWxsID8gc2VlZERhdGFbMl0gOiBudWxsXG4gIGZvciAoY29uc3QgcGFyYWxsZWxSb3V0ZUtleSBpbiBjaGlsZHJlbikge1xuICAgIGNvbnN0IGNoaWxkUm91dGUgPSBjaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XVxuICAgIGNvbnN0IGNoaWxkU2VnbWVudCA9IGNoaWxkUm91dGVbMF1cbiAgICBjb25zdCBjaGlsZFNlZWREYXRhID1cbiAgICAgIHNlZWREYXRhQ2hpbGRyZW4gIT09IG51bGwgPyBzZWVkRGF0YUNoaWxkcmVuW3BhcmFsbGVsUm91dGVLZXldIDogbnVsbFxuXG4gICAgY29uc3QgY2hpbGRLZXkgPSBlbmNvZGVDaGlsZFNlZ21lbnRLZXkoXG4gICAgICBrZXksXG4gICAgICBwYXJhbGxlbFJvdXRlS2V5LFxuICAgICAgQXJyYXkuaXNBcnJheShjaGlsZFNlZ21lbnQpICYmIGZhbGxiYWNrUm91dGVQYXJhbXMgIT09IG51bGxcbiAgICAgICAgPyBlbmNvZGVTZWdtZW50V2l0aFBvc3NpYmxlRmFsbGJhY2tQYXJhbShcbiAgICAgICAgICAgIGNoaWxkU2VnbWVudCxcbiAgICAgICAgICAgIGZhbGxiYWNrUm91dGVQYXJhbXNcbiAgICAgICAgICApXG4gICAgICAgIDogZW5jb2RlU2VnbWVudChjaGlsZFNlZ21lbnQpXG4gICAgKVxuICAgIGNvbnN0IGNoaWxkVHJlZSA9IGNvbGxlY3RTZWdtZW50RGF0YUltcGwoXG4gICAgICBjaGlsZFJvdXRlLFxuICAgICAgYnVpbGRJZCxcbiAgICAgIGNoaWxkU2VlZERhdGEsXG4gICAgICBmYWxsYmFja1JvdXRlUGFyYW1zLFxuICAgICAgY2xpZW50TW9kdWxlcyxcbiAgICAgIGNoaWxkS2V5LFxuICAgICAgc2VnbWVudFRhc2tzXG4gICAgKVxuICAgIGlmIChzbG90TWV0YWRhdGEgPT09IG51bGwpIHtcbiAgICAgIHNsb3RNZXRhZGF0YSA9IHt9XG4gICAgfVxuICAgIHNsb3RNZXRhZGF0YVtwYXJhbGxlbFJvdXRlS2V5XSA9IGNoaWxkVHJlZVxuICB9XG5cbiAgaWYgKHNlZWREYXRhICE9PSBudWxsKSB7XG4gICAgLy8gU3Bhd24gYSB0YXNrIHRvIHdyaXRlIHRoZSBzZWdtZW50IGRhdGEgdG8gYSBuZXcgRmxpZ2h0IHN0cmVhbS5cbiAgICBzZWdtZW50VGFza3MucHVzaChcbiAgICAgIC8vIFNpbmNlIHdlJ3JlIGFscmVhZHkgaW4gdGhlIG1pZGRsZSBvZiBhIHJlbmRlciwgd2FpdCB1bnRpbCBhZnRlciB0aGVcbiAgICAgIC8vIGN1cnJlbnQgdGFzayB0byBlc2NhcGUgdGhlIGN1cnJlbnQgcmVuZGVyaW5nIGNvbnRleHQuXG4gICAgICB3YWl0QXRMZWFzdE9uZVJlYWN0UmVuZGVyVGFzaygpLnRoZW4oKCkgPT5cbiAgICAgICAgcmVuZGVyU2VnbWVudFByZWZldGNoKGJ1aWxkSWQsIHNlZWREYXRhLCBrZXksIGNsaWVudE1vZHVsZXMpXG4gICAgICApXG4gICAgKVxuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgc2VnbWVudCBkb2VzIG5vdCBoYXZlIGFueSBzZWVkIGRhdGEuIFNraXAgZ2VuZXJhdGluZyBhIHByZWZldGNoXG4gICAgLy8gcmVzcG9uc2UgZm9yIGl0LiBXZSdsbCBzdGlsbCBpbmNsdWRlIGl0IGluIHRoZSByb3V0ZSB0cmVlLCB0aG91Z2guXG4gICAgLy8gVE9ETzogV2Ugc2hvdWxkIGVuY29kZSBpbiB0aGUgcm91dGUgdHJlZSB3aGV0aGVyIGEgc2VnbWVudCBpcyBtaXNzaW5nXG4gICAgLy8gc28gd2UgZG9uJ3QgYXR0ZW1wdCB0byBmZXRjaCBpdCBmb3Igbm8gcmVhc29uLiBBcyBvZiBub3cgdGhpcyBzaG91bGRuJ3RcbiAgICAvLyBldmVyIGhhcHBlbiBpbiBwcmFjdGljZSwgdGhvdWdoLlxuICB9XG5cbiAgLy8gTWV0YWRhdGEgYWJvdXQgdGhlIHNlZ21lbnQuIFNlbnQgdG8gdGhlIGNsaWVudCBhcyBwYXJ0IG9mIHRoZVxuICAvLyB0cmVlIHByZWZldGNoLlxuICByZXR1cm4ge1xuICAgIHNlZ21lbnQ6IHJvdXRlWzBdLFxuICAgIHNsb3RzOiBzbG90TWV0YWRhdGEsXG4gICAgaXNSb290TGF5b3V0OiByb3V0ZVs0XSA9PT0gdHJ1ZSxcbiAgfVxufVxuXG5mdW5jdGlvbiBlbmNvZGVTZWdtZW50V2l0aFBvc3NpYmxlRmFsbGJhY2tQYXJhbShcbiAgc2VnbWVudDogW3N0cmluZywgc3RyaW5nLCBEeW5hbWljUGFyYW1UeXBlc1Nob3J0XSxcbiAgZmFsbGJhY2tSb3V0ZVBhcmFtczogRmFsbGJhY2tSb3V0ZVBhcmFtc1xuKTogRW5jb2RlZFNlZ21lbnQge1xuICBjb25zdCBuYW1lID0gc2VnbWVudFswXVxuICBpZiAoIWZhbGxiYWNrUm91dGVQYXJhbXMuaGFzKG5hbWUpKSB7XG4gICAgLy8gTm9ybWFsIGNhc2UuIE5vIG1hdGNoaW5nIGZhbGxiYWNrIHBhcmFtZXRlci5cbiAgICByZXR1cm4gZW5jb2RlU2VnbWVudChzZWdtZW50KVxuICB9XG4gIC8vIFRoaXMgc2VnbWVudCBpbmNsdWRlcyBhIGZhbGxiYWNrIHBhcmFtZXRlci4gRHVyaW5nIHByZXJlbmRlcmluZywgYSByYW5kb21cbiAgLy8gcGxhY2Vob2xkZXIgdmFsdWUgd2FzIHVzZWQ7IGhvd2V2ZXIsIGZvciBzZWdtZW50IHByZWZldGNoZXMsIHdlIG5lZWQgdGhlXG4gIC8vIHNlZ21lbnQgcGF0aCB0byBiZSBwcmVkaWN0YWJsZSBzbyB0aGUgc2VydmVyIGNhbiBjcmVhdGUgYSByZXdyaXRlIGZvciBpdC5cbiAgLy8gU28sIHJlcGxhY2UgdGhlIHBsYWNlaG9sZGVyIHNlZ21lbnQgdmFsdWUgd2l0aCBhIFwidGVtcGxhdGVcIiBzdHJpbmcsXG4gIC8vIGUuZy4gYFtuYW1lXWAuXG4gIC8vIFRPRE86IFRoaXMgd2lsbCBiZWNvbWUgYSBiaXQgY2xlYW5lciBvbmNlIHJlbW92ZSByb3V0ZSBwYXJhbWV0ZXJzIGZyb20gdGhlXG4gIC8vIHNlcnZlciByZXNwb25zZSwgYW5kIGluc3RlYWQgYWRkIHRoZW0gdG8gdGhlIHNlZ21lbnQga2V5cyBvbiB0aGUgY2xpZW50LlxuICAvLyBJbnN0ZWFkIG9mIGEgc3RyaW5nIHJlcGxhY2VtZW50LCBsaWtlIHdlIGRvIGhlcmUsIHJvdXRlIHBhcmFtcyB3aWxsIGFsd2F5c1xuICAvLyBiZSBlbmNvZGVkIGluIHNlcGFyYXRlIHN0ZXAgZnJvbSB0aGUgcmVzdCBvZiB0aGUgc2VnbWVudCwgbm90IGp1c3QgaW4gdGhlXG4gIC8vIGNhc2Ugb2YgZmFsbGJhY2sgcGFyYW1zLlxuICBjb25zdCBlbmNvZGVkU2VnbWVudCA9IGVuY29kZVNlZ21lbnQoc2VnbWVudClcbiAgY29uc3QgbGFzdEluZGV4ID0gZW5jb2RlZFNlZ21lbnQubGFzdEluZGV4T2YoJyQnKVxuICBjb25zdCBlbmNvZGVkRmFsbGJhY2tTZWdtZW50ID1cbiAgICAvLyBOT1RFOiBUaGlzIGlzIGd1YXJhbnRlZWQgbm90IHRvIGNsYXNoIHdpdGggdGhlIHJlc3Qgb2YgdGhlIHNlZ21lbnRcbiAgICAvLyBiZWNhdXNlIG5vbi1zaW1wbGUgY2hhcmFjdGVycyAoaW5jbHVkaW5nIFsgYW5kIF0pIHRyaWdnZXIgYSBiYXNlXG4gICAgLy8gNjQgZW5jb2RpbmcuXG4gICAgZW5jb2RlZFNlZ21lbnQuc3Vic3RyaW5nKDAsIGxhc3RJbmRleCArIDEpICsgYFske25hbWV9XWBcbiAgcmV0dXJuIGVuY29kZWRGYWxsYmFja1NlZ21lbnQgYXMgRW5jb2RlZFNlZ21lbnRcbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVuZGVyU2VnbWVudFByZWZldGNoKFxuICBidWlsZElkOiBzdHJpbmcsXG4gIHNlZWREYXRhOiBDYWNoZU5vZGVTZWVkRGF0YSxcbiAga2V5OiBzdHJpbmcsXG4gIGNsaWVudE1vZHVsZXM6IE1hbmlmZXN0Tm9kZVxuKTogUHJvbWlzZTxbc3RyaW5nLCBCdWZmZXJdPiB7XG4gIC8vIFJlbmRlciB0aGUgc2VnbWVudCBkYXRhIHRvIGEgc3RyZWFtLlxuICAvLyBJbiB0aGUgZnV0dXJlLCB0aGlzIGlzIHdoZXJlIHdlIGNhbiBpbmNsdWRlIGFkZGl0aW9uYWwgbWV0YWRhdGEsIGxpa2UgdGhlXG4gIC8vIHN0YWxlIHRpbWUgYW5kIGNhY2hlIHRhZ3MuXG4gIGNvbnN0IHJzYyA9IHNlZWREYXRhWzFdXG4gIGNvbnN0IGxvYWRpbmcgPSBzZWVkRGF0YVszXVxuICBjb25zdCBzZWdtZW50UHJlZmV0Y2g6IFNlZ21lbnRQcmVmZXRjaCA9IHtcbiAgICBidWlsZElkLFxuICAgIHJzYyxcbiAgICBsb2FkaW5nLFxuICAgIGlzUGFydGlhbDogYXdhaXQgaXNQYXJ0aWFsUlNDRGF0YShyc2MsIGNsaWVudE1vZHVsZXMpLFxuICB9XG4gIC8vIFNpbmNlIGFsbCB3ZSdyZSBkb2luZyBpcyBkZWNvZGluZyBhbmQgcmUtZW5jb2RpbmcgYSBjYWNoZWQgcHJlcmVuZGVyLCBpZlxuICAvLyBpdCB0YWtlcyBsb25nZXIgdGhhbiBhIG1pY3JvdGFzaywgaXQgbXVzdCBiZWNhdXNlIG9mIGhhbmdpbmcgcHJvbWlzZXNcbiAgLy8gY2F1c2VkIGJ5IGR5bmFtaWMgZGF0YS4gQWJvcnQgdGhlIHN0cmVhbSBhdCB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IHRhc2suXG4gIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuICB3YWl0QXRMZWFzdE9uZVJlYWN0UmVuZGVyVGFzaygpLnRoZW4oKCkgPT4gYWJvcnRDb250cm9sbGVyLmFib3J0KCkpXG4gIGNvbnN0IHsgcHJlbHVkZTogc2VnbWVudFN0cmVhbSB9ID0gYXdhaXQgcHJlcmVuZGVyKFxuICAgIHNlZ21lbnRQcmVmZXRjaCxcbiAgICBjbGllbnRNb2R1bGVzLFxuICAgIHtcbiAgICAgIGZpbHRlclN0YWNrRnJhbWUsXG4gICAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgICBvbkVycm9yOiBvblNlZ21lbnRQcmVyZW5kZXJFcnJvcixcbiAgICB9XG4gIClcbiAgY29uc3Qgc2VnbWVudEJ1ZmZlciA9IGF3YWl0IHN0cmVhbVRvQnVmZmVyKHNlZ21lbnRTdHJlYW0pXG4gIGlmIChrZXkgPT09IFJPT1RfU0VHTUVOVF9LRVkpIHtcbiAgICByZXR1cm4gWycvX2luZGV4Jywgc2VnbWVudEJ1ZmZlcl1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW2tleSwgc2VnbWVudEJ1ZmZlcl1cbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBpc1BhcnRpYWxSU0NEYXRhKFxuICByc2M6IFJlYWN0LlJlYWN0Tm9kZSxcbiAgY2xpZW50TW9kdWxlczogTWFuaWZlc3ROb2RlXG4pOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgLy8gV2UgY2FuIGRldGVybWluZSBpZiBhIHNlZ21lbnQgY29udGFpbnMgb25seSBwYXJ0aWFsIGRhdGEgaWYgaXQgdGFrZXMgbG9uZ2VyXG4gIC8vIHRoYW4gYSB0YXNrIHRvIGVuY29kZSwgYmVjYXVzZSBkeW5hbWljIGRhdGEgaXMgZW5jb2RlZCBhcyBhbiBpbmZpbml0ZVxuICAvLyBwcm9taXNlLiBXZSBtdXN0IGRvIHRoaXMgaW4gYSBzZXBhcmF0ZSBGbGlnaHQgcHJlcmVuZGVyIGZyb20gdGhlIG9uZSB0aGF0XG4gIC8vIGFjdHVhbGx5IGdlbmVyYXRlcyB0aGUgcHJlZmV0Y2ggc3RyZWFtIGJlY2F1c2Ugd2UgbmVlZCB0byBpbmNsdWRlXG4gIC8vIGBpc1BhcnRpYWxgIGluIHRoZSBzdHJlYW0gaXRzZWxmLlxuICBsZXQgaXNQYXJ0aWFsID0gZmFsc2VcbiAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpXG4gIHdhaXRBdExlYXN0T25lUmVhY3RSZW5kZXJUYXNrKCkudGhlbigoKSA9PiB7XG4gICAgLy8gSWYgd2UgaGF2ZW4ndCB5ZXQgZmluaXNoZWQgdGhlIG91dGVyIHRhc2ssIHRoZW4gaXQgbXVzdCBiZSBiZWNhdXNlIHdlXG4gICAgLy8gYWNjZXNzZWQgZHluYW1pYyBkYXRhLlxuICAgIGlzUGFydGlhbCA9IHRydWVcbiAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKVxuICB9KVxuICBhd2FpdCBwcmVyZW5kZXIocnNjLCBjbGllbnRNb2R1bGVzLCB7XG4gICAgZmlsdGVyU3RhY2tGcmFtZSxcbiAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgb25FcnJvcigpIHt9LFxuICAgIG9uUG9zdHBvbmUoKSB7XG4gICAgICAvLyBJZiBzb21ldGhpbmcgcG9zdHBvbmVkLCBpLmUuIHdoZW4gRHluYW1pYyBJTyBpcyBub3QgZW5hYmxlZCwgd2UgY2FuXG4gICAgICAvLyBpbmZlciB0aGF0IHRoZSBSU0MgZGF0YSBpcyBwYXJ0aWFsLlxuICAgICAgaXNQYXJ0aWFsID0gdHJ1ZVxuICAgIH0sXG4gIH0pXG4gIHJldHVybiBpc1BhcnRpYWxcbn1cblxuZnVuY3Rpb24gY3JlYXRlVW5jbG9zaW5nUHJlZmV0Y2hTdHJlYW0oXG4gIG9yaWdpbmFsRmxpZ2h0U3RyZWFtOiBSZWFkYWJsZVN0cmVhbTxVaW50OEFycmF5PlxuKTogUmVhZGFibGVTdHJlYW08VWludDhBcnJheT4ge1xuICAvLyBXaGVuIFBQUiBpcyBlbmFibGVkLCBwcmVmZXRjaCBzdHJlYW1zIG1heSBjb250YWluIHJlZmVyZW5jZXMgdGhhdCBuZXZlclxuICAvLyByZXNvbHZlLCBiZWNhdXNlIHRoYXQncyBob3cgd2UgZW5jb2RlIGR5bmFtaWMgZGF0YSBhY2Nlc3MuIEluIHRoZSBkZWNvZGVkXG4gIC8vIG9iamVjdCByZXR1cm5lZCBieSB0aGUgRmxpZ2h0IGNsaWVudCwgdGhlc2UgYXJlIHJlaWZpZWQgaW50byBoYW5naW5nXG4gIC8vIHByb21pc2VzIHRoYXQgc3VzcGVuZCBkdXJpbmcgcmVuZGVyLCB3aGljaCBpcyBlZmZlY3RpdmVseSB3aGF0IHdlIHdhbnQuXG4gIC8vIFRoZSBVSSByZXNvbHZlcyB3aGVuIGl0IHN3aXRjaGVzIHRvIHRoZSBkeW5hbWljIGRhdGEgc3RyZWFtXG4gIC8vICh2aWEgdXNlRGVmZXJyZWRWYWx1ZShkeW5hbWljLCBzdGF0aWMpKS5cbiAgLy9cbiAgLy8gSG93ZXZlciwgdGhlIEZsaWdodCBpbXBsZW1lbnRhdGlvbiBjdXJyZW50bHkgZXJyb3JzIGlmIHRoZSBzZXJ2ZXIgY2xvc2VzXG4gIC8vIHRoZSByZXNwb25zZSBiZWZvcmUgYWxsIHRoZSByZWZlcmVuY2VzIGFyZSByZXNvbHZlZC4gQXMgYSBjaGVhdCB0byB3b3JrXG4gIC8vIGFyb3VuZCB0aGlzLCB3ZSB3cmFwIHRoZSBvcmlnaW5hbCBzdHJlYW0gaW4gYSBuZXcgc3RyZWFtIHRoYXQgbmV2ZXIgY2xvc2VzLFxuICAvLyBhbmQgdGhlcmVmb3JlIGRvZXNuJ3QgZXJyb3IuXG4gIGNvbnN0IHJlYWRlciA9IG9yaWdpbmFsRmxpZ2h0U3RyZWFtLmdldFJlYWRlcigpXG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIGFzeW5jIHB1bGwoY29udHJvbGxlcikge1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKVxuICAgICAgICBpZiAoIWRvbmUpIHtcbiAgICAgICAgICAvLyBQYXNzIHRvIHRoZSB0YXJnZXQgc3RyZWFtIGFuZCBrZWVwIGNvbnN1bWluZyB0aGUgRmxpZ2h0IHJlc3BvbnNlXG4gICAgICAgICAgLy8gZnJvbSB0aGUgc2VydmVyLlxuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh2YWx1ZSlcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBzZXJ2ZXIgc3RyZWFtIGhhcyBjbG9zZWQuIEV4aXQsIGJ1dCBpbnRlbnRpb25hbGx5IGRvIG5vdCBjbG9zZVxuICAgICAgICAvLyB0aGUgdGFyZ2V0IHN0cmVhbS5cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfSxcbiAgfSlcbn1cbiJdLCJuYW1lcyI6WyJjcmVhdGVGcm9tUmVhZGFibGVTdHJlYW0iLCJ1bnN0YWJsZV9wcmVyZW5kZXIiLCJwcmVyZW5kZXIiLCJzdHJlYW1Gcm9tQnVmZmVyIiwic3RyZWFtVG9CdWZmZXIiLCJ3YWl0QXRMZWFzdE9uZVJlYWN0UmVuZGVyVGFzayIsImVuY29kZUNoaWxkU2VnbWVudEtleSIsImVuY29kZVNlZ21lbnQiLCJST09UX1NFR01FTlRfS0VZIiwiZ2V0RGlnZXN0Rm9yV2VsbEtub3duRXJyb3IiLCJmaWx0ZXJTdGFja0ZyYW1lIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwicmVxdWlyZSIsImZpbHRlclN0YWNrRnJhbWVERVYiLCJ1bmRlZmluZWQiLCJvblNlZ21lbnRQcmVyZW5kZXJFcnJvciIsImVycm9yIiwiZGlnZXN0IiwiY29sbGVjdFNlZ21lbnREYXRhIiwiZnVsbFBhZ2VEYXRhQnVmZmVyIiwic3RhbGVUaW1lIiwiY2xpZW50TW9kdWxlcyIsInNlcnZlckNvbnN1bWVyTWFuaWZlc3QiLCJmYWxsYmFja1JvdXRlUGFyYW1zIiwicmVzdWx0TWFwIiwiTWFwIiwiYWJvcnRDb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwib25Db21wbGV0ZWRQcm9jZXNzaW5nUm91dGVUcmVlIiwiYWJvcnQiLCJzZWdtZW50VGFza3MiLCJwcmVsdWRlIiwidHJlZVN0cmVhbSIsIlByZWZldGNoVHJlZURhdGEiLCJzaWduYWwiLCJvbkVycm9yIiwidHJlZUJ1ZmZlciIsInNldCIsInNlZ21lbnRQYXRoIiwiYnVmZmVyIiwiUHJvbWlzZSIsImFsbCIsImluaXRpYWxSU0NQYXlsb2FkIiwiY3JlYXRlVW5jbG9zaW5nUHJlZmV0Y2hTdHJlYW0iLCJidWlsZElkIiwiYiIsImZsaWdodERhdGFQYXRocyIsImYiLCJsZW5ndGgiLCJjb25zb2xlIiwiZmxpZ2h0Um91dGVyU3RhdGUiLCJzZWVkRGF0YSIsImhlYWQiLCJ0cmVlIiwiY29sbGVjdFNlZ21lbnREYXRhSW1wbCIsImlzSGVhZFBhcnRpYWwiLCJpc1BhcnRpYWxSU0NEYXRhIiwidHJlZVByZWZldGNoIiwicm91dGUiLCJrZXkiLCJzbG90TWV0YWRhdGEiLCJjaGlsZHJlbiIsInNlZWREYXRhQ2hpbGRyZW4iLCJwYXJhbGxlbFJvdXRlS2V5IiwiY2hpbGRSb3V0ZSIsImNoaWxkU2VnbWVudCIsImNoaWxkU2VlZERhdGEiLCJjaGlsZEtleSIsIkFycmF5IiwiaXNBcnJheSIsImVuY29kZVNlZ21lbnRXaXRoUG9zc2libGVGYWxsYmFja1BhcmFtIiwiY2hpbGRUcmVlIiwicHVzaCIsInRoZW4iLCJyZW5kZXJTZWdtZW50UHJlZmV0Y2giLCJzZWdtZW50Iiwic2xvdHMiLCJpc1Jvb3RMYXlvdXQiLCJuYW1lIiwiaGFzIiwiZW5jb2RlZFNlZ21lbnQiLCJsYXN0SW5kZXgiLCJsYXN0SW5kZXhPZiIsImVuY29kZWRGYWxsYmFja1NlZ21lbnQiLCJzdWJzdHJpbmciLCJyc2MiLCJsb2FkaW5nIiwic2VnbWVudFByZWZldGNoIiwiaXNQYXJ0aWFsIiwic2VnbWVudFN0cmVhbSIsInNlZ21lbnRCdWZmZXIiLCJvblBvc3Rwb25lIiwib3JpZ2luYWxGbGlnaHRTdHJlYW0iLCJyZWFkZXIiLCJnZXRSZWFkZXIiLCJSZWFkYWJsZVN0cmVhbSIsInB1bGwiLCJjb250cm9sbGVyIiwiZG9uZSIsInZhbHVlIiwicmVhZCIsImVucXVldWUiXSwibWFwcGluZ3MiOiI7Ozs7QUFTQSw2REFBNkQ7QUFDN0QsU0FBU0Esd0JBQXdCLFFBQVEsa0NBQWlDO0FBQzFFLDZEQUE2RDtBQUM3RCxTQUFTQyxzQkFBc0JDLFNBQVMsUUFBUSxrQ0FBaUM7QUFFakYsU0FDRUMsZ0JBQWdCLEVBQ2hCQyxjQUFjLFFBQ1QsMENBQXlDO0FBQ2hELFNBQVND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QUNwQyxJQUFJbUUsWUFBWTtJQUNoQixNQUFNOUQsa0JBQWtCLElBQUlDO0tBQzVCeEIsMkxBQUFBLElBQWdDc0UsSUFBSSxDQUFDO1FBQ25DLHdFQUF3RTtRQUN4RSx5QkFBeUI7UUFDekJlLFlBQVk7UUFDWjlELGdCQUFnQkcsS0FBSztJQUN2QjtJQUNBLE1BQU03Qix1UUFBQUEsRUFBVXFGLEtBQUtoRSxlQUFlO1FBQ2xDYjtRQUNBMEIsUUFBUVIsZ0JBQWdCUSxNQUFNO1FBQzlCQyxZQUFXO1FBQ1h3RDtZQUNFLHNFQUFzRTtZQUN0RSxzQ0FBc0M7WUFDdENILFlBQVk7UUFDZDtJQUNGO0lBQ0EsT0FBT0E7QUFDVDtBQUVBLFNBQVM3Qyw4QkFDUGlELG9CQUFnRDtJQUVoRCwwRUFBMEU7SUFDMUUsNEVBQTRFO0lBQzVFLHVFQUF1RTtJQUN2RSwwRUFBMEU7SUFDMUUsOERBQThEO0lBQzlELDJDQUEyQztJQUMzQyxFQUFFO0lBQ0YsMkVBQTJFO0lBQzNFLDBFQUEwRTtJQUMxRSw4RUFBOEU7SUFDOUUsK0JBQStCO0lBQy9CLE1BQU1DLFNBQVNELHFCQUFxQkUsU0FBUztJQUM3QyxPQUFPLElBQUlDLGVBQWU7UUFDeEIsTUFBTUMsTUFBS0MsVUFBVTtZQUNuQixNQUFPLEtBQU07Z0JBQ1gsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLEtBQUssRUFBRSxHQUFHLE1BQU1OLE9BQU9PLElBQUk7Z0JBQ3pDLElBQUksQ0FBQ0YsTUFBTTtvQkFDVCxtRUFBbUU7b0JBQ25FLG1CQUFtQjtvQkFDbkJELFdBQVdJLE9BQU8sQ0FBQ0Y7b0JBQ25CO2dCQUNGO2dCQUNBLHFFQUFxRTtnQkFDckUscUJBQXFCO2dCQUNyQjtZQUNGO1FBQ0Y7SUFDRjtBQUNGIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDEyODcyLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zcmMvc2VydmVyL2xpYi9jbG9uZS1yZXNwb25zZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENsb25lcyBhIHJlc3BvbnNlIGJ5IHRlZWluZyB0aGUgYm9keSBzbyB3ZSBjYW4gcmV0dXJuIHR3byBpbmRlcGVuZGVudFxuICogUmVhZGFibGVTdHJlYW1zIGZyb20gaXQuIFRoaXMgYXZvaWRzIHRoZSBidWcgaW4gdGhlIHVuZGljaSBsaWJyYXJ5IGFyb3VuZFxuICogcmVzcG9uc2UgY2xvbmluZy5cbiAqXG4gKiBBZnRlciBjbG9uaW5nLCB0aGUgb3JpZ2luYWwgcmVzcG9uc2UncyBib2R5IHdpbGwgYmUgY29uc3VtZWQgYW5kIGNsb3NlZC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvbmV4dC5qcy9wdWxsLzczMjc0XG4gKlxuICogQHBhcmFtIG9yaWdpbmFsIC0gVGhlIG9yaWdpbmFsIHJlc3BvbnNlIHRvIGNsb25lLlxuICogQHJldHVybnMgQSB0dXBsZSBjb250YWluaW5nIHR3byBpbmRlcGVuZGVudCBjbG9uZXMgb2YgdGhlIG9yaWdpbmFsIHJlc3BvbnNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xvbmVSZXNwb25zZShvcmlnaW5hbDogUmVzcG9uc2UpOiBbUmVzcG9uc2UsIFJlc3BvbnNlXSB7XG4gIC8vIElmIHRoZSByZXNwb25zZSBoYXMgbm8gYm9keSwgdGhlbiB3ZSBjYW4ganVzdCByZXR1cm4gdGhlIG9yaWdpbmFsIHJlc3BvbnNlXG4gIC8vIHR3aWNlIGJlY2F1c2UgaXQncyBpbW11dGFibGUuXG4gIGlmICghb3JpZ2luYWwuYm9keSkge1xuICAgIHJldHVybiBbb3JpZ2luYWwsIG9yaWdpbmFsXVxuICB9XG5cbiAgY29uc3QgW2JvZHkxLCBib2R5Ml0gPSBvcmlnaW5hbC5ib2R5LnRlZSgpXG5cbiAgY29uc3QgY2xvbmVkMSA9IG5ldyBSZXNwb25zZShib2R5MSwge1xuICAgIHN0YXR1czogb3JpZ2luYWwuc3RhdHVzLFxuICAgIHN0YXR1c1RleHQ6IG9yaWdpbmFsLnN0YXR1c1RleHQsXG4gICAgaGVhZGVyczogb3JpZ2luYWwuaGVhZGVycyxcbiAgfSlcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xvbmVkMSwgJ3VybCcsIHtcbiAgICB2YWx1ZTogb3JpZ2luYWwudXJsLFxuICAgIC8vIEhvdyB0aGUgb3JpZ2luYWwgcmVzcG9uc2UudXJsIGJlaGF2ZXNcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogZmFsc2UsXG4gIH0pXG5cbiAgY29uc3QgY2xvbmVkMiA9IG5ldyBSZXNwb25zZShib2R5Miwge1xuICAgIHN0YXR1czogb3JpZ2luYWwuc3RhdHVzLFxuICAgIHN0YXR1c1RleHQ6IG9yaWdpbmFsLnN0YXR1c1RleHQsXG4gICAgaGVhZGVyczogb3JpZ2luYWwuaGVhZGVycyxcbiAgfSlcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xvbmVkMiwgJ3VybCcsIHtcbiAgICB2YWx1ZTogb3JpZ2luYWwudXJsLFxuICAgIC8vIEhvdyB0aGUgb3JpZ2luYWwgcmVzcG9uc2UudXJsIGJlaGF2ZXNcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogZmFsc2UsXG4gIH0pXG5cbiAgcmV0dXJuIFtjbG9uZWQxLCBjbG9uZWQyXVxufVxuIl0sIm5hbWVzIjpbImNsb25lUmVzcG9uc2UiLCJvcmlnaW5hbCIsImJvZHkiLCJib2R5MSIsImJvZHkyIiwidGVlIiwiY2xvbmVkMSIsIlJlc3BvbnNlIiwic3RhdHVzIiwic3RhdHVzVGV4dCIsImhlYWRlcnMiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsInZhbHVlIiwidXJsIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIiwiY2xvbmVkMiJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7O0NBV0MsR0FDRDs7O0FBQU8sU0FBU0EsY0FBY0MsUUFBa0I7SUFDOUMsNkVBQTZFO0lBQzdFLGdDQUFnQztJQUNoQyxJQUFJLENBQUNBLFNBQVNDLElBQUksRUFBRTtRQUNsQixPQUFPO1lBQUNEO1lBQVVBO1NBQVM7SUFDN0I7SUFFQSxNQUFNLENBQUNFLE9BQU9DLE1BQU0sR0FBR0gsU0FBU0MsSUFBSSxDQUFDRyxHQUFHO0lBRXhDLE1BQU1DLFVBQVUsSUFBSUMsU0FBU0osT0FBTztRQUNsQ0ssUUFBUVAsU0FBU08sTUFBTTtRQUN2QkMsWUFBWVIsU0FBU1EsVUFBVTtRQUMvQkMsU0FBU1QsU0FBU1MsT0FBTztJQUMzQjtJQUVBQyxPQUFPQyxjQUFjLENBQUNOLFNBQVMsT0FBTztRQUNwQ08sT0FBT1osU0FBU2EsR0FBRztRQUNuQix3Q0FBd0M7UUFDeENDLGNBQWM7UUFDZEMsWUFBWTtRQUNaQyxVQUFVO0lBQ1o7SUFFQSxNQUFNQyxVQUFVLElBQUlYLFNBQVNILE9BQU87UUFDbENJLFFBQVFQLFNBQVNPLE1BQU07UUFDdkJDLFlBQVlSLFNBQVNRLFVBQVU7UUFDL0JDLFNBQVNULFNBQVNTLE9BQU87SUFDM0I7SUFFQUMsT0FBT0MsY0FBYyxDQUFDTSxTQUFTLE9BQU87UUFDcENMLE9BQU9aLFNBQVNhLEdBQUc7UUFDbkIsd0NBQXdDO1FBQ3hDQyxjQUFjO1FBQ2RDLFlBQVk7UUFDWkMsVUFBVTtJQUNaO0lBRUEsT0FBTztRQUFDWDtRQUFTWTtLQUFRO0FBQzNCIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDEyOTI5LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zcmMvc2VydmVyL2xpYi9kZWR1cGUtZmV0Y2gudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi9kNGU3OGM0MmE5NGJlMDI3YjRkYzdlZDI2NTlhNWZkZGZiZjliZDRlL3BhY2thZ2VzL3JlYWN0L3NyYy9SZWFjdEZldGNoLmpzXG4gKi9cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgY2xvbmVSZXNwb25zZSB9IGZyb20gJy4vY2xvbmUtcmVzcG9uc2UnXG5pbXBvcnQgeyBJbnZhcmlhbnRFcnJvciB9IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvaW52YXJpYW50LWVycm9yJ1xuXG5jb25zdCBzaW1wbGVDYWNoZUtleSA9ICdbXCJHRVRcIixbXSxudWxsLFwiZm9sbG93XCIsbnVsbCxudWxsLG51bGwsbnVsbF0nIC8vIGdlbmVyYXRlQ2FjaGVLZXkobmV3IFJlcXVlc3QoJ2h0dHBzOi8vYmxhbmsnKSk7XG5cbmZ1bmN0aW9uIGdlbmVyYXRlQ2FjaGVLZXkocmVxdWVzdDogUmVxdWVzdCk6IHN0cmluZyB7XG4gIC8vIFdlIHBpY2sgdGhlIGZpZWxkcyB0aGF0IGdvZXMgaW50byB0aGUga2V5IHVzZWQgdG8gZGVkdXBlIHJlcXVlc3RzLlxuICAvLyBXZSBkb24ndCBpbmNsdWRlIHRoZSBgY2FjaGVgIGZpZWxkLCBiZWNhdXNlIHdlIGVuZCB1cCB1c2luZyB3aGF0ZXZlclxuICAvLyBjYWNoaW5nIHJlc3VsdGVkIGZyb20gdGhlIGZpcnN0IHJlcXVlc3QuXG4gIC8vIE5vdGFibHkgd2UgY3VycmVudGx5IGRvbid0IGNvbnNpZGVyIG5vbi1zdGFuZGFyZCAob3IgZnV0dXJlKSBvcHRpb25zLlxuICAvLyBUaGlzIG1pZ2h0IG5vdCBiZSBzYWZlLiBUT0RPOiB3YXJuIGZvciBub24tc3RhbmRhcmQgZXh0ZW5zaW9ucyBkaWZmZXJpbmcuXG4gIC8vIElGIFlPVSBDSEFOR0UgVEhJUyBVUERBVEUgVEhFIHNpbXBsZUNhY2hlS2V5IEFCT1ZFLlxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoW1xuICAgIHJlcXVlc3QubWV0aG9kLFxuICAgIEFycmF5LmZyb20ocmVxdWVzdC5oZWFkZXJzLmVudHJpZXMoKSksXG4gICAgcmVxdWVzdC5tb2RlLFxuICAgIHJlcXVlc3QucmVkaXJlY3QsXG4gICAgcmVxdWVzdC5jcmVkZW50aWFscyxcbiAgICByZXF1ZXN0LnJlZmVycmVyLFxuICAgIHJlcXVlc3QucmVmZXJyZXJQb2xpY3ksXG4gICAgcmVxdWVzdC5pbnRlZ3JpdHksXG4gIF0pXG59XG5cbnR5cGUgQ2FjaGVFbnRyeSA9IFtcbiAga2V5OiBzdHJpbmcsXG4gIHByb21pc2U6IFByb21pc2U8UmVzcG9uc2U+LFxuICByZXNwb25zZTogUmVzcG9uc2UgfCBudWxsLFxuXVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRGVkdXBlRmV0Y2gob3JpZ2luYWxGZXRjaDogdHlwZW9mIGZldGNoKSB7XG4gIGNvbnN0IGdldENhY2hlRW50cmllcyA9IFJlYWN0LmNhY2hlKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMgLS0gdXJsIGlzIHRoZSBjYWNoZSBrZXlcbiAgICAodXJsOiBzdHJpbmcpOiBDYWNoZUVudHJ5W10gPT4gW11cbiAgKVxuXG4gIHJldHVybiBmdW5jdGlvbiBkZWR1cGVGZXRjaChcbiAgICByZXNvdXJjZTogVVJMIHwgUmVxdWVzdEluZm8sXG4gICAgb3B0aW9ucz86IFJlcXVlc3RJbml0XG4gICk6IFByb21pc2U8UmVzcG9uc2U+IHtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnNpZ25hbCkge1xuICAgICAgLy8gSWYgd2UncmUgcGFzc2VkIGEgc2lnbmFsLCB0aGVuIHdlIGFzc3VtZSB0aGF0XG4gICAgICAvLyBzb21lb25lIGVsc2UgY29udHJvbHMgdGhlIGxpZmV0aW1lIG9mIHRoaXMgb2JqZWN0IGFuZCBvcHRzIG91dCBvZlxuICAgICAgLy8gY2FjaGluZy4gSXQncyBlZmZlY3RpdmVseSB0aGUgb3B0LW91dCBtZWNoYW5pc20uXG4gICAgICAvLyBJZGVhbGx5IHdlIHNob3VsZCBiZSBhYmxlIHRvIGNoZWNrIHRoaXMgb24gdGhlIFJlcXVlc3QgYnV0XG4gICAgICAvLyBpdCBhbHdheXMgZ2V0cyBpbml0aWFsaXplZCB3aXRoIGl0cyBvd24gc2lnbmFsIHNvIHdlIGRvbid0XG4gICAgICAvLyBrbm93IGlmIGl0J3Mgc3VwcG9zZWQgdG8gb3ZlcnJpZGUgLSB1bmxlc3Mgd2UgYWxzbyBvdmVycmlkZSB0aGVcbiAgICAgIC8vIFJlcXVlc3QgY29uc3RydWN0b3IuXG4gICAgICByZXR1cm4gb3JpZ2luYWxGZXRjaChyZXNvdXJjZSwgb3B0aW9ucylcbiAgICB9XG4gICAgLy8gTm9ybWFsaXplIHRoZSBSZXF1ZXN0XG4gICAgbGV0IHVybDogc3RyaW5nXG4gICAgbGV0IGNhY2hlS2V5OiBzdHJpbmdcbiAgICBpZiAodHlwZW9mIHJlc291cmNlID09PSAnc3RyaW5nJyAmJiAhb3B0aW9ucykge1xuICAgICAgLy8gRmFzdCBwYXRoLlxuICAgICAgY2FjaGVLZXkgPSBzaW1wbGVDYWNoZUtleVxuICAgICAgdXJsID0gcmVzb3VyY2VcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm9ybWFsaXplIHRoZSByZXF1ZXN0LlxuICAgICAgLy8gaWYgcmVzb3VyY2UgaXMgbm90IGEgc3RyaW5nIG9yIGEgVVJMIChpdHMgYW4gaW5zdGFuY2Ugb2YgUmVxdWVzdClcbiAgICAgIC8vIHRoZW4gZG8gbm90IGluc3RhbnRpYXRlIGEgbmV3IFJlcXVlc3QgYnV0IGluc3RlYWRcbiAgICAgIC8vIHJldXNlIHRoZSByZXF1ZXN0IGFzIHRvIG5vdCBkaXN0dXJiIHRoZSBib2R5IGluIHRoZSBldmVudCBpdCdzIGEgUmVhZGFibGVTdHJlYW0uXG4gICAgICBjb25zdCByZXF1ZXN0ID1cbiAgICAgICAgdHlwZW9mIHJlc291cmNlID09PSAnc3RyaW5nJyB8fCByZXNvdXJjZSBpbnN0YW5jZW9mIFVSTFxuICAgICAgICAgID8gbmV3IFJlcXVlc3QocmVzb3VyY2UsIG9wdGlvbnMpXG4gICAgICAgICAgOiByZXNvdXJjZVxuICAgICAgaWYgKFxuICAgICAgICAocmVxdWVzdC5tZXRob2QgIT09ICdHRVQnICYmIHJlcXVlc3QubWV0aG9kICE9PSAnSEVBRCcpIHx8XG4gICAgICAgIHJlcXVlc3Qua2VlcGFsaXZlXG4gICAgICApIHtcbiAgICAgICAgLy8gV2UgY3VycmVudGx5IGRvbid0IGRlZHVwZSByZXF1ZXN0cyB0aGF0IG1pZ2h0IGhhdmUgc2lkZS1lZmZlY3RzLiBUaG9zZVxuICAgICAgICAvLyBoYXZlIHRvIGJlIGV4cGxpY2l0bHkgY2FjaGVkLiBXZSBhc3N1bWUgdGhhdCB0aGUgcmVxdWVzdCBkb2Vzbid0IGhhdmUgYVxuICAgICAgICAvLyBib2R5IGlmIGl0J3MgR0VUIG9yIEhFQUQuXG4gICAgICAgIC8vIGtlZXBhbGl2ZSBnZXRzIHRyZWF0ZWQgdGhlIHNhbWUgYXMgaWYgeW91IHBhc3NlZCBhIGN1c3RvbSBjYWNoZSBzaWduYWwuXG4gICAgICAgIHJldHVybiBvcmlnaW5hbEZldGNoKHJlc291cmNlLCBvcHRpb25zKVxuICAgICAgfVxuICAgICAgY2FjaGVLZXkgPSBnZW5lcmF0ZUNhY2hlS2V5KHJlcXVlc3QpXG4gICAgICB1cmwgPSByZXF1ZXN0LnVybFxuICAgIH1cblxuICAgIGNvbnN0IGNhY2hlRW50cmllcyA9IGdldENhY2hlRW50cmllcyh1cmwpXG4gICAgZm9yIChsZXQgaSA9IDAsIGogPSBjYWNoZUVudHJpZXMubGVuZ3RoOyBpIDwgajsgaSArPSAxKSB7XG4gICAgICBjb25zdCBba2V5LCBwcm9taXNlXSA9IGNhY2hlRW50cmllc1tpXVxuICAgICAgaWYgKGtleSA9PT0gY2FjaGVLZXkpIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBjYWNoZUVudHJpZXNbaV1bMl1cbiAgICAgICAgICBpZiAoIXJlc3BvbnNlKSB0aHJvdyBuZXcgSW52YXJpYW50RXJyb3IoJ05vIGNhY2hlZCByZXNwb25zZScpXG5cbiAgICAgICAgICAvLyBXZSdyZSBjbG9uaW5nIHRoZSByZXNwb25zZSB1c2luZyB0aGlzIHV0aWxpdHkgYmVjYXVzZSB0aGVyZSBleGlzdHNcbiAgICAgICAgICAvLyBhIGJ1ZyBpbiB0aGUgdW5kaWNpIGxpYnJhcnkgYXJvdW5kIHJlc3BvbnNlIGNsb25pbmcuIFNlZSB0aGVcbiAgICAgICAgICAvLyBmb2xsb3dpbmcgcHVsbCByZXF1ZXN0IGZvciBtb3JlIGRldGFpbHM6XG4gICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3ZlcmNlbC9uZXh0LmpzL3B1bGwvNzMyNzRcbiAgICAgICAgICBjb25zdCBbY2xvbmVkMSwgY2xvbmVkMl0gPSBjbG9uZVJlc3BvbnNlKHJlc3BvbnNlKVxuICAgICAgICAgIGNhY2hlRW50cmllc1tpXVsyXSA9IGNsb25lZDJcbiAgICAgICAgICByZXR1cm4gY2xvbmVkMVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFdlIHBhc3MgdGhlIG9yaWdpbmFsIGFyZ3VtZW50cyBoZXJlIGluIGNhc2Ugbm9ybWFsaXppbmcgdGhlIFJlcXVlc3RcbiAgICAvLyBkb2Vzbid0IGluY2x1ZGUgYWxsIHRoZSBvcHRpb25zIGluIHRoaXMgZW52aXJvbm1lbnQuXG4gICAgY29uc3QgcHJvbWlzZSA9IG9yaWdpbmFsRmV0Y2gocmVzb3VyY2UsIG9wdGlvbnMpXG4gICAgY29uc3QgZW50cnk6IENhY2hlRW50cnkgPSBbY2FjaGVLZXksIHByb21pc2UsIG51bGxdXG4gICAgY2FjaGVFbnRyaWVzLnB1c2goZW50cnkpXG5cbiAgICByZXR1cm4gcHJvbWlzZS50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgLy8gV2UncmUgY2xvbmluZyB0aGUgcmVzcG9uc2UgdXNpbmcgdGhpcyB1dGlsaXR5IGJlY2F1c2UgdGhlcmUgZXhpc3RzXG4gICAgICAvLyBhIGJ1ZyBpbiB0aGUgdW5kaWNpIGxpYnJhcnkgYXJvdW5kIHJlc3BvbnNlIGNsb25pbmcuIFNlZSB0aGVcbiAgICAgIC8vIGZvbGxvd2luZyBwdWxsIHJlcXVlc3QgZm9yIG1vcmUgZGV0YWlsczpcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvbmV4dC5qcy9wdWxsLzczMjc0XG4gICAgICBjb25zdCBbY2xvbmVkMSwgY2xvbmVkMl0gPSBjbG9uZVJlc3BvbnNlKHJlc3BvbnNlKVxuICAgICAgZW50cnlbMl0gPSBjbG9uZWQyXG4gICAgICByZXR1cm4gY2xvbmVkMVxuICAgIH0pXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJSZWFjdCIsImNsb25lUmVzcG9uc2UiLCJJbnZhcmlhbnRFcnJvciIsInNpbXBsZUNhY2hlS2V5IiwiZ2VuZXJhdGVDYWNoZUtleSIsInJlcXVlc3QiLCJKU09OIiwic3RyaW5naWZ5IiwibWV0aG9kIiwiQXJyYXkiLCJmcm9tIiwiaGVhZGVycyIsImVudHJpZXMiLCJtb2RlIiwicmVkaXJlY3QiLCJjcmVkZW50aWFscyIsInJlZmVycmVyIiwicmVmZXJyZXJQb2xpY3kiLCJpbnRlZ3JpdHkiLCJjcmVhdGVEZWR1cGVGZXRjaCIsIm9yaWdpbmFsRmV0Y2giLCJnZXRDYWNoZUVudHJpZXMiLCJjYWNoZSIsInVybCIsImRlZHVwZUZldGNoIiwicmVzb3VyY2UiLCJvcHRpb25zIiwic2lnbmFsIiwiY2FjaGVLZXkiLCJVUkwiLCJSZXF1ZXN0Iiwia2VlcGFsaXZlIiwiY2FjaGVFbnRyaWVzIiwiaSIsImoiLCJsZW5ndGgiLCJrZXkiLCJwcm9taXNlIiwidGhlbiIsInJlc3BvbnNlIiwiY2xvbmVkMSIsImNsb25lZDIiLCJlbnRyeSIsInB1c2giXSwibWFwcGluZ3MiOiJBQUFBOztDQUVDOzs7QUFDRCxZQUFZQSxXQUFXLFFBQU87QUFDOUIsU0FBU0MsYUFBYSxRQUFRLG1CQUFrQjtBQUNoRCxTQUFTQyxjQUFjLFFBQVEsbUNBQWtDOzs7O0FBRWpFLE1BQU1DLGlCQUFpQiwrQ0FBK0Msa0RB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WUFDL0MsTUFBTSxDQUFDQyxTQUFTQyxRQUFRLGlMQUFHeEMsZ0JBQUFBLEVBQWNzQztZQUN6Q0csS0FBSyxDQUFDLEVBQUUsR0FBR0Q7WUFDWCxPQUFPRDtRQUNUO0lBQ0Y7QUFDRiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxMzA0MSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL2xpYi9iYXRjaGVyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgU2NoZWR1bGVyRm4gfSBmcm9tICcuL3NjaGVkdWxlcidcblxuaW1wb3J0IHsgRGV0YWNoZWRQcm9taXNlIH0gZnJvbSAnLi9kZXRhY2hlZC1wcm9taXNlJ1xuXG50eXBlIENhY2hlS2V5Rm48SywgQyBleHRlbmRzIHN0cmluZyB8IG51bWJlciB8IG51bGw+ID0gKFxuICBrZXk6IEtcbikgPT4gUHJvbWlzZUxpa2U8Qz4gfCBDXG5cbnR5cGUgQmF0Y2hlck9wdGlvbnM8SywgQyBleHRlbmRzIHN0cmluZyB8IG51bWJlciB8IG51bGw+ID0ge1xuICBjYWNoZUtleUZuPzogQ2FjaGVLZXlGbjxLLCBDPlxuICBzY2hlZHVsZXJGbj86IFNjaGVkdWxlckZuPHZvaWQ+XG59XG5cbnR5cGUgV29ya0ZuPFYsIEM+ID0gKFxuICBrZXk6IEMsXG4gIHJlc29sdmU6ICh2YWx1ZTogViB8IFByb21pc2VMaWtlPFY+KSA9PiB2b2lkXG4pID0+IFByb21pc2U8Vj5cblxuLyoqXG4gKiBBIHdyYXBwZXIgZm9yIGEgZnVuY3Rpb24gdGhhdCB3aWxsIG9ubHkgYWxsb3cgb25lIGNhbGwgdG8gdGhlIGZ1bmN0aW9uIHRvXG4gKiBleGVjdXRlIGF0IGEgdGltZS5cbiAqL1xuZXhwb3J0IGNsYXNzIEJhdGNoZXI8SywgViwgQyBleHRlbmRzIHN0cmluZyB8IG51bWJlciB8IG51bGw+IHtcbiAgcHJpdmF0ZSByZWFkb25seSBwZW5kaW5nID0gbmV3IE1hcDxDLCBQcm9taXNlPFY+PigpXG5cbiAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgY2FjaGVLZXlGbj86IENhY2hlS2V5Rm48SywgQz4sXG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHRvIHNjaGVkdWxlIHRoZSB3cmFwcGVkIGZ1bmN0aW9uIHRvIGJlXG4gICAgICogZXhlY3V0ZWQuIFRoaXMgZGVmYXVsdHMgdG8gYSBmdW5jdGlvbiB0aGF0IHdpbGwgZXhlY3V0ZSB0aGUgZnVuY3Rpb25cbiAgICAgKiBpbW1lZGlhdGVseS5cbiAgICAgKi9cbiAgICBwcml2YXRlIHJlYWRvbmx5IHNjaGVkdWxlckZuOiBTY2hlZHVsZXJGbjx2b2lkPiA9IChmbikgPT4gZm4oKVxuICApIHt9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgUGVuZGluZ1dyYXBwZXIuIElmIHRoZSBrZXkgZXh0ZW5kcyBhIHN0cmluZyBvclxuICAgKiBudW1iZXIsIHRoZSBrZXkgd2lsbCBiZSB1c2VkIGFzIHRoZSBjYWNoZSBrZXkuIElmIHRoZSBrZXkgaXMgYW4gb2JqZWN0LCBhXG4gICAqIGNhY2hlIGtleSBmdW5jdGlvbiBtdXN0IGJlIHByb3ZpZGVkLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBjcmVhdGU8SyBleHRlbmRzIHN0cmluZyB8IG51bWJlciB8IG51bGwsIFY+KFxuICAgIG9wdGlvbnM/OiBCYXRjaGVyT3B0aW9uczxLLCBLPlxuICApOiBCYXRjaGVyPEssIFYsIEs+XG4gIHB1YmxpYyBzdGF0aWMgY3JlYXRlPEssIFYsIEMgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXIgfCBudWxsPihcbiAgICBvcHRpb25zOiBCYXRjaGVyT3B0aW9uczxLLCBDPiAmXG4gICAgICBSZXF1aXJlZDxQaWNrPEJhdGNoZXJPcHRpb25zPEssIEM+LCAnY2FjaGVLZXlGbic+PlxuICApOiBCYXRjaGVyPEssIFYsIEM+XG4gIHB1YmxpYyBzdGF0aWMgY3JlYXRlPEssIFYsIEMgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXIgfCBudWxsPihcbiAgICBvcHRpb25zPzogQmF0Y2hlck9wdGlvbnM8SywgQz5cbiAgKTogQmF0Y2hlcjxLLCBWLCBDPiB7XG4gICAgcmV0dXJuIG5ldyBCYXRjaGVyPEssIFYsIEM+KG9wdGlvbnM/LmNhY2hlS2V5Rm4sIG9wdGlvbnM/LnNjaGVkdWxlckZuKVxuICB9XG5cbiAgLyoqXG4gICAqIFdyYXBzIGEgZnVuY3Rpb24gaW4gYSBwcm9taXNlIHRoYXQgd2lsbCBiZSByZXNvbHZlZCBvciByZWplY3RlZCBvbmx5IG9uY2VcbiAgICogZm9yIGEgZ2l2ZW4ga2V5LiBUaGlzIHdpbGwgYWxsb3cgbXVsdGlwbGUgY2FsbHMgdG8gdGhlIGZ1bmN0aW9uIHRvIGJlXG4gICAqIG1hZGUsIGJ1dCBvbmx5IG9uZSB3aWxsIGJlIGV4ZWN1dGVkIGF0IGEgdGltZS4gVGhlIHJlc3VsdCBvZiB0aGUgZmlyc3RcbiAgICogY2FsbCB3aWxsIGJlIHJldHVybmVkIHRvIGFsbCBjYWxsZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ga2V5IHRoZSBrZXkgdG8gdXNlIGZvciB0aGUgY2FjaGVcbiAgICogQHBhcmFtIGZuIHRoZSBmdW5jdGlvbiB0byB3cmFwXG4gICAqIEByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSByZXN1bHQgb2YgdGhlIGZ1bmN0aW9uXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgYmF0Y2goa2V5OiBLLCBmbjogV29ya0ZuPFYsIEM+KTogUHJvbWlzZTxWPiB7XG4gICAgY29uc3QgY2FjaGVLZXkgPSAodGhpcy5jYWNoZUtleUZuID8gYXdhaXQgdGhpcy5jYWNoZUtleUZuKGtleSkgOiBrZXkpIGFzIENcbiAgICBpZiAoY2FjaGVLZXkgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBmbihjYWNoZUtleSwgUHJvbWlzZS5yZXNvbHZlKVxuICAgIH1cblxuICAgIGNvbnN0IHBlbmRpbmcgPSB0aGlzLnBlbmRpbmcuZ2V0KGNhY2hlS2V5KVxuICAgIGlmIChwZW5kaW5nKSByZXR1cm4gcGVuZGluZ1xuXG4gICAgY29uc3QgeyBwcm9taXNlLCByZXNvbHZlLCByZWplY3QgfSA9IG5ldyBEZXRhY2hlZFByb21pc2U8Vj4oKVxuICAgIHRoaXMucGVuZGluZy5zZXQoY2FjaGVLZXksIHByb21pc2UpXG5cbiAgICB0aGlzLnNjaGVkdWxlckZuKGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZuKGNhY2hlS2V5LCByZXNvbHZlKVxuXG4gICAgICAgIC8vIFJlc29sdmluZyBhIHByb21pc2UgbXVsdGlwbGUgdGltZXMgaXMgYSBuby1vcCwgc28gd2UgY2FuIHNhZmVseVxuICAgICAgICAvLyByZXNvbHZlIGFsbCBwZW5kaW5nIHByb21pc2VzIHdpdGggdGhlIHNhbWUgcmVzdWx0LlxuICAgICAgICByZXNvbHZlKHJlc3VsdClcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZWplY3QoZXJyKVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5wZW5kaW5nLmRlbGV0ZShjYWNoZUtleSlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgcmV0dXJuIHByb21pc2VcbiAgfVxufVxuIl0sIm5hbWVzIjpbIkRldGFjaGVkUHJvbWlzZSIsIkJhdGNoZXIiLCJjYWNoZUtleUZuIiwic2NoZWR1bGVyRm4iLCJmbiIsInBlbmRpbmciLCJNYXAiLCJjcmVhdGUiLCJvcHRpb25zIiwiYmF0Y2giLCJrZXkiLCJjYWNoZUtleSIsIlByb21pc2UiLCJyZXNvbHZlIiwiZ2V0IiwicHJvbWlzZSIsInJlamVjdCIsInNldCIsInJlc3VsdCIsImVyciIsImRlbGV0ZSJdLCJtYXBwaW5ncyI6Ijs7O0FBRUEsU0FBU0EsZUFBZSxRQUFRLHFCQUFvQjs7QUFvQjdDLE1BQU1DO0lBR1gsWUFDbUJDLFVBQTZCLEVBQzlDOzs7O0tBSUMsR0FDZ0JDLGNBQWlDLENBQUNDLEtBQU9BLElBQUksQ0FDOUQ7YUFQaUJGLFVBQUFBLEdBQUFBO2FBTUFDLFdBQUFBLEdBQUFBO2FBVEZFLE9BQUFBLEdBQVUsSUFBSUM7SUFVNUI7SUFjSCxPQUFjQyxPQUNaQyxPQUE4QixFQUNaO1FBQ2xCLE9BQU8sSUFBSVAsUUFBaUJPLFdBQUFBLE9BQUFBLEtBQUFBLElBQUFBLFFBQVNOLFVBQVUsRUFBRU0sV0FBQUEsT0FBQUEsS0FBQUEsSUFBQUEsUUFBU0wsV0FBVztJQUN2RTtJQUVBOzs7Ozs7Ozs7R0FTQyxHQUNELE1BQWFNLE1BQU1DLEdBQU0sRUFBRU4sRUFBZ0IsRUFBYztRQUN2RCxNQUFNTyxXQUFZLElBQUksQ0FBQ1QsVUFBVSxHQUFHLE1BQU0sSUFBSSxDQUFDQSxVQUFVLENBQUNRLE9BQU9BO1FBQ2pFLElBQUlDLGFBQWEsTUFBTTtZQUNyQixPQUFPUCxHQUFHTyxVQUFVQyxRQUFRQyxPQUFPO1FBQ3JDO1FBRUEsTUFBTVIsVUFBVSxJQUFJLENBQUNBLE9BQU8sQ0FBQ1MsR0FBRyxDQUFDSDtRQUNqQyxJQUFJTixTQUFTLE9BQU9BO1FBRXBCLE1BQU0sRUFBRVUsT0FBTyxFQUFFRixPQUFPLEVBQUVHLE1BQU0sRUFBRSxHQUFHLHNLQUFJaEIsa0JBQUFBO1FBQ3pDLElBQUksQ0FBQ0ssT0FBTyxDQUFDWSxHQUFHLENBQUNOLFVBQVVJO1FBRTNCLElBQUksQ0FBQ1osV0FBVyxDQUFDO1lBQ2YsSUFBSTtnQkFDRixNQUFNZSxTQUFTLE1BQU1kLEdBQUdPLFVBQVVFO2dCQUVsQyxrRUFBa0U7Z0JBQ2xFLHFEQUFxRDtnQkFDckRBLFFBQVFLO1lBQ1YsRUFBRSxPQUFPQyxLQUFLO2dCQUNaSCxPQUFPRztZQUNULFNBQVU7Z0JBQ1IsSUFBSSxDQUFDZCxPQUFPLENBQUNlLE1BQU0sQ0FBQ1Q7WUFDdEI7UUFDRjtRQUVBLE9BQU9JO0lBQ1Q7QUFDRiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxMzA5NiwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL3NlcnZlci9yZXNwb25zZS1jYWNoZS90eXBlcy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IE91dGdvaW5nSHR0cEhlYWRlcnMgfSBmcm9tICdodHRwJ1xuaW1wb3J0IHR5cGUgUmVuZGVyUmVzdWx0IGZyb20gJy4uL3JlbmRlci1yZXN1bHQnXG5pbXBvcnQgdHlwZSB7IENhY2hlQ29udHJvbCwgUmV2YWxpZGF0ZSB9IGZyb20gJy4uL2xpYi9jYWNoZS1jb250cm9sJ1xuaW1wb3J0IHR5cGUgeyBSb3V0ZUtpbmQgfSBmcm9tICcuLi9yb3V0ZS1raW5kJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFJlc3BvbnNlQ2FjaGVCYXNlIHtcbiAgZ2V0KFxuICAgIGtleTogc3RyaW5nIHwgbnVsbCxcbiAgICByZXNwb25zZUdlbmVyYXRvcjogUmVzcG9uc2VHZW5lcmF0b3IsXG4gICAgY29udGV4dDoge1xuICAgICAgaXNPbkRlbWFuZFJldmFsaWRhdGU/OiBib29sZWFuXG4gICAgICBpc1ByZWZldGNoPzogYm9vbGVhblxuICAgICAgaW5jcmVtZW50YWxDYWNoZTogSW5jcmVtZW50YWxDYWNoZVxuICAgICAgLyoqXG4gICAgICAgKiBUaGlzIGlzIGEgaGludCB0byB0aGUgY2FjaGUgdG8gaGVscCBpdCBkZXRlcm1pbmUgd2hhdCBraW5kIG9mIHJvdXRlXG4gICAgICAgKiB0aGlzIGlzIHNvIGl0IGtub3dzIHdoZXJlIHRvIGxvb2sgdXAgdGhlIGNhY2hlIGVudHJ5IGZyb20uIElmIG5vdFxuICAgICAgICogcHJvdmlkZWQgaXQgd2lsbCB0ZXN0IHRoZSBmaWxlc3lzdGVtIHRvIGNoZWNrLlxuICAgICAgICovXG4gICAgICByb3V0ZUtpbmQ6IFJvdXRlS2luZFxuXG4gICAgICAvKipcbiAgICAgICAqIFRydWUgaWYgdGhpcyBpcyBhIGZhbGxiYWNrIHJlcXVlc3QuXG4gICAgICAgKi9cbiAgICAgIGlzRmFsbGJhY2s/OiBib29sZWFuXG5cbiAgICAgIC8qKlxuICAgICAgICogVHJ1ZSBpZiB0aGUgcm91dGUgaXMgZW5hYmxlZCBmb3IgUFBSLlxuICAgICAgICovXG4gICAgICBpc1JvdXRlUFBSRW5hYmxlZD86IGJvb2xlYW5cbiAgICB9XG4gICk6IFByb21pc2U8UmVzcG9uc2VDYWNoZUVudHJ5IHwgbnVsbD5cbn1cblxuLy8gVGhlIHNlcnZlciBjb21wb25lbnRzIEhNUiBjYWNoZSBtaWdodCBzdG9yZSBvdGhlciBkYXRhIGFzIHdlbGwgaW4gdGhlIGZ1dHVyZSxcbi8vIGF0IHdoaWNoIHBvaW50IHRoaXMgc2hvdWxkIGJlIHJlZmFjdG9yZWQgdG8gYSBkaXNjcmltaW5hdGVkIHVuaW9uIHR5cGUuXG5leHBvcnQgaW50ZXJmYWNlIFNlcnZlckNvbXBvbmVudHNIbXJDYWNoZSB7XG4gIGdldChrZXk6IHN0cmluZyk6IENhY2hlZEZldGNoRGF0YSB8IHVuZGVmaW5lZFxuICBzZXQoa2V5OiBzdHJpbmcsIGRhdGE6IENhY2hlZEZldGNoRGF0YSk6IHZvaWRcbn1cblxuZXhwb3J0IHR5cGUgQ2FjaGVkRmV0Y2hEYXRhID0ge1xuICBoZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG4gIGJvZHk6IHN0cmluZ1xuICB1cmw6IHN0cmluZ1xuICBzdGF0dXM/OiBudW1iZXJcbn1cblxuZXhwb3J0IGNvbnN0IGVudW0gQ2FjaGVkUm91dGVLaW5kIHtcbiAgQVBQX1BBR0UgPSAnQVBQX1BBR0UnLFxuICBBUFBfUk9VVEUgPSAnQVBQX1JPVVRFJyxcbiAgUEFHRVMgPSAnUEFHRVMnLFxuICBGRVRDSCA9ICdGRVRDSCcsXG4gIFJFRElSRUNUID0gJ1JFRElSRUNUJyxcbiAgSU1BR0UgPSAnSU1BR0UnLFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIENhY2hlZEZldGNoVmFsdWUge1xuICBraW5kOiBDYWNoZWRSb3V0ZUtpbmQuRkVUQ0hcbiAgZGF0YTogQ2FjaGVkRmV0Y2hEYXRhXG4gIC8vIHRhZ3MgYXJlIG9ubHkgcHJlc2VudCB3aXRoIGZpbGUtc3lzdGVtLWNhY2hlXG4gIC8vIGZldGNoIGNhY2hlIHN0b3JlcyB0YWdzIG91dHNpZGUgb2YgY2FjaGUgZW50cnlcbiAgdGFncz86IHN0cmluZ1tdXG4gIHJldmFsaWRhdGU6IG51bWJlclxufVxuXG5leHBvcnQgaW50ZXJmYWNlIENhY2hlZFJlZGlyZWN0VmFsdWUge1xuICBraW5kOiBDYWNoZWRSb3V0ZUtpbmQuUkVESVJFQ1RcbiAgcHJvcHM6IE9iamVjdFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIENhY2hlZEFwcFBhZ2VWYWx1ZSB7XG4gIGtpbmQ6IENhY2hlZFJvdXRlS2luZC5BUFBfUEFHRVxuICAvLyB0aGlzIG5lZWRzIHRvIGJlIGEgUmVuZGVyUmVzdWx0IHNvIHNpbmNlIHJlbmRlclJlc3BvbnNlXG4gIC8vIGV4cGVjdHMgdGhhdCB0eXBlIGluc3RlYWQgb2YgYSBzdHJpbmdcbiAgaHRtbDogUmVuZGVyUmVzdWx0XG4gIHJzY0RhdGE6IEJ1ZmZlciB8IHVuZGVmaW5lZFxuICBzdGF0dXM6IG51bWJlciB8IHVuZGVmaW5lZFxuICBwb3N0cG9uZWQ6IHN0cmluZyB8IHVuZGVmaW5lZFxuICBoZWFkZXJzOiBPdXRnb2luZ0h0dHBIZWFkZXJzIHwgdW5kZWZpbmVkXG4gIHNlZ21lbnREYXRhOiBNYXA8c3RyaW5nLCBCdWZmZXI+IHwgdW5kZWZpbmVkXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2FjaGVkUGFnZVZhbHVlIHtcbiAga2luZDogQ2FjaGVkUm91dGVLaW5kLlBBR0VTXG4gIC8vIHRoaXMgbmVlZHMgdG8gYmUgYSBSZW5kZXJSZXN1bHQgc28gc2luY2UgcmVuZGVyUmVzcG9uc2VcbiAgLy8gZXhwZWN0cyB0aGF0IHR5cGUgaW5zdGVhZCBvZiBhIHN0cmluZ1xuICBodG1sOiBSZW5kZXJSZXN1bHRcbiAgcGFnZURhdGE6IE9iamVjdFxuICBzdGF0dXM6IG51bWJlciB8IHVuZGVmaW5lZFxuICBoZWFkZXJzOiBPdXRnb2luZ0h0dHBIZWFkZXJzIHwgdW5kZWZpbmVkXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2FjaGVkUm91dGVWYWx1ZSB7XG4gIGtpbmQ6IENhY2hlZFJvdXRlS2luZC5BUFBfUk9VVEVcbiAgLy8gdGhpcyBuZWVkcyB0byBiZSBhIFJlbmRlclJlc3VsdCBzbyBzaW5jZSByZW5kZXJSZXNwb25zZVxuICAvLyBleHBlY3RzIHRoYXQgdHlwZSBpbnN0ZWFkIG9mIGEgc3RyaW5nXG4gIGJvZHk6IEJ1ZmZlclxuICBzdGF0dXM6IG51bWJlclxuICBoZWFkZXJzOiBPdXRnb2luZ0h0dHBIZWFkZXJzXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2FjaGVkSW1hZ2VWYWx1ZSB7XG4gIGtpbmQ6IENhY2hlZFJvdXRlS2luZC5JTUFHRVxuICBldGFnOiBzdHJpbmdcbiAgdXBzdHJlYW1FdGFnOiBzdHJpbmdcbiAgYnVmZmVyOiBCdWZmZXJcbiAgZXh0ZW5zaW9uOiBzdHJpbmdcbiAgaXNNaXNzPzogYm9vbGVhblxuICBpc1N0YWxlPzogYm9vbGVhblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEluY3JlbWVudGFsQ2FjaGVkQXBwUGFnZVZhbHVlIHtcbiAga2luZDogQ2FjaGVkUm91dGVLaW5kLkFQUF9QQUdFXG4gIC8vIHRoaXMgbmVlZHMgdG8gYmUgYSBzdHJpbmcgc2luY2UgdGhlIGNhY2hlIGV4cGVjdHMgdG8gc3RvcmVcbiAgLy8gdGhlIHN0cmluZyB2YWx1ZVxuICBodG1sOiBzdHJpbmdcbiAgcnNjRGF0YTogQnVmZmVyIHwgdW5kZWZpbmVkXG4gIGhlYWRlcnM6IE91dGdvaW5nSHR0cEhlYWRlcnMgfCB1bmRlZmluZWRcbiAgcG9zdHBvbmVkOiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgc3RhdHVzOiBudW1iZXIgfCB1bmRlZmluZWRcbiAgc2VnbWVudERhdGE6IE1hcDxzdHJpbmcsIEJ1ZmZlcj4gfCB1bmRlZmluZWRcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbmNyZW1lbnRhbENhY2hlZFBhZ2VWYWx1ZSB7XG4gIGtpbmQ6IENhY2hlZFJvdXRlS2luZC5QQUdFU1xuICAvLyB0aGlzIG5lZWRzIHRvIGJlIGEgc3RyaW5nIHNpbmNlIHRoZSBjYWNoZSBleHBlY3RzIHRvIHN0b3JlXG4gIC8vIHRoZSBzdHJpbmcgdmFsdWVcbiAgaHRtbDogc3RyaW5nXG4gIHBhZ2VEYXRhOiBPYmplY3RcbiAgaGVhZGVyczogT3V0Z29pbmdIdHRwSGVhZGVycyB8IHVuZGVmaW5lZFxuICBzdGF0dXM6IG51bWJlciB8IHVuZGVmaW5lZFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEluY3JlbWVudGFsUmVzcG9uc2VDYWNoZUVudHJ5IHtcbiAgY2FjaGVDb250cm9sPzogQ2FjaGVDb250cm9sXG4gIC8qKlxuICAgKiB0aW1lc3RhbXAgaW4gbWlsbGlzZWNvbmRzIHRvIHJldmFsaWRhdGUgYWZ0ZXJcbiAgICovXG4gIHJldmFsaWRhdGVBZnRlcj86IFJldmFsaWRhdGVcbiAgLyoqXG4gICAqIGAtMWAgaGVyZSBkaWN0YXRlcyBhIGJsb2NraW5nIHJldmFsaWRhdGUgc2hvdWxkIGJlIHVzZWRcbiAgICovXG4gIGlzU3RhbGU/OiBib29sZWFuIHwgLTFcbiAgaXNNaXNzPzogYm9vbGVhblxuICB2YWx1ZTogRXhjbHVkZTxJbmNyZW1lbnRhbENhY2hlVmFsdWUsIENhY2hlZEZldGNoVmFsdWU+IHwgbnVsbFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEluY3JlbWVudGFsRmV0Y2hDYWNoZUVudHJ5IHtcbiAgLyoqXG4gICAqIGAtMWAgaGVyZSBkaWN0YXRlcyBhIGJsb2NraW5nIHJldmFsaWRhdGUgc2hvdWxkIGJlIHVzZWRcbiAgICovXG4gIGlzU3RhbGU/OiBib29sZWFuIHwgLTFcbiAgdmFsdWU6IENhY2hlZEZldGNoVmFsdWVcbn1cblxuZXhwb3J0IHR5cGUgSW5jcmVtZW50YWxDYWNoZUVudHJ5ID1cbiAgfCBJbmNyZW1lbnRhbFJlc3BvbnNlQ2FjaGVFbnRyeVxuICB8IEluY3JlbWVudGFsRmV0Y2hDYWNoZUVudHJ5XG5cbmV4cG9ydCB0eXBlIEluY3JlbWVudGFsQ2FjaGVWYWx1ZSA9XG4gIHwgQ2FjaGVkUmVkaXJlY3RWYWx1ZVxuICB8IEluY3JlbWVudGFsQ2FjaGVkUGFnZVZhbHVlXG4gIHwgSW5jcmVtZW50YWxDYWNoZWRBcHBQYWdlVmFsdWVcbiAgfCBDYWNoZWRJbWFnZVZhbHVlXG4gIHwgQ2FjaGVkRmV0Y2hWYWx1ZVxuICB8IENhY2hlZFJvdXRlVmFsdWVcblxuZXhwb3J0IHR5cGUgUmVzcG9uc2VDYWNoZVZhbHVlID1cbiAgfCBDYWNoZWRSZWRpcmVjdFZhbHVlXG4gIHwgQ2FjaGVkUGFnZVZhbHVlXG4gIHwgQ2FjaGVkQXBwUGFnZVZhbHVlXG4gIHwgQ2FjaGVkSW1hZ2VWYWx1ZVxuICB8IENhY2hlZFJvdXRlVmFsdWVcblxuZXhwb3J0IHR5cGUgUmVzcG9uc2VDYWNoZUVudHJ5ID0ge1xuICBjYWNoZUNvbnRyb2w/OiBDYWNoZUNvbnRyb2xcbiAgdmFsdWU6IFJlc3BvbnNlQ2FjaGVWYWx1ZSB8IG51bGxcbiAgaXNTdGFsZT86IGJvb2xlYW4gfCAtMVxuICBpc01pc3M/OiBib29sZWFuXG59XG5cbi8qKlxuICogQHBhcmFtIGhhc1Jlc29sdmVkIHdoZXRoZXIgdGhlIHJlc3BvbnNlR2VuZXJhdG9yIGhhcyByZXNvbHZlZCBpdCdzIHByb21pc2VcbiAqIEBwYXJhbSBwcmV2aW91c0NhY2hlRW50cnkgdGhlIHByZXZpb3VzIGNhY2hlIGVudHJ5IGlmIGl0IGV4aXN0cyBvciB0aGUgY3VycmVudFxuICovXG5leHBvcnQgdHlwZSBSZXNwb25zZUdlbmVyYXRvciA9IChzdGF0ZToge1xuICBoYXNSZXNvbHZlZDogYm9vbGVhblxuICBwcmV2aW91c0NhY2hlRW50cnk/OiBJbmNyZW1lbnRhbFJlc3BvbnNlQ2FjaGVFbnRyeSB8IG51bGxcbiAgaXNSZXZhbGlkYXRpbmc/OiBib29sZWFuXG4gIHNwYW4/OiBhbnlcbn0pID0+IFByb21pc2U8UmVzcG9uc2VDYWNoZUVudHJ5IHwgbnVsbD5cblxuZXhwb3J0IGNvbnN0IGVudW0gSW5jcmVtZW50YWxDYWNoZUtpbmQge1xuICBBUFBfUEFHRSA9ICdBUFBfUEFHRScsXG4gIEFQUF9ST1VURSA9ICdBUFBfUk9VVEUnLFxuICBQQUdFUyA9ICdQQUdFUycsXG4gIEZFVENIID0gJ0ZFVENIJyxcbiAgSU1BR0UgPSAnSU1BR0UnLFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdldEluY3JlbWVudGFsRmV0Y2hDYWNoZUNvbnRleHQge1xuICBraW5kOiBJbmNyZW1lbnRhbENhY2hlS2luZC5GRVRDSFxuICByZXZhbGlkYXRlPzogUmV2YWxpZGF0ZVxuICBmZXRjaFVybD86IHN0cmluZ1xuICBmZXRjaElkeD86IG51bWJlclxuICB0YWdzPzogc3RyaW5nW11cbiAgc29mdFRhZ3M/OiBzdHJpbmdbXVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdldEluY3JlbWVudGFsUmVzcG9uc2VDYWNoZUNvbnRleHQge1xuICBraW5kOiBFeGNsdWRlPEluY3JlbWVudGFsQ2FjaGVLaW5kLCBJbmNyZW1lbnRhbENhY2hlS2luZC5GRVRDSD5cblxuICAvKipcbiAgICogVHJ1ZSBpZiB0aGUgcm91dGUgaXMgZW5hYmxlZCBmb3IgUFBSLlxuICAgKi9cbiAgaXNSb3V0ZVBQUkVuYWJsZWQ/OiBib29sZWFuXG5cbiAgLyoqXG4gICAqIFRydWUgaWYgdGhpcyBpcyBhIGZhbGxiYWNrIHJlcXVlc3QuXG4gICAqL1xuICBpc0ZhbGxiYWNrOiBib29sZWFuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2V0SW5jcmVtZW50YWxGZXRjaENhY2hlQ29udGV4dCB7XG4gIGZldGNoQ2FjaGU6IHRydWVcbiAgZmV0Y2hVcmw/OiBzdHJpbmdcbiAgZmV0Y2hJZHg/OiBudW1iZXJcbiAgdGFncz86IHN0cmluZ1tdXG4gIGlzSW1wbGljaXRCdWlsZFRpbWVDYWNoZT86IGJvb2xlYW5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBTZXRJbmNyZW1lbnRhbFJlc3BvbnNlQ2FjaGVDb250ZXh0IHtcbiAgZmV0Y2hDYWNoZT86IGZhbHNlXG4gIGNhY2hlQ29udHJvbD86IENhY2hlQ29udHJvbFxuXG4gIC8qKlxuICAgKiBUcnVlIGlmIHRoZSByb3V0ZSBpcyBlbmFibGVkIGZvciBQUFIuXG4gICAqL1xuICBpc1JvdXRlUFBSRW5hYmxlZD86IGJvb2xlYW5cblxuICAvKipcbiAgICogVHJ1ZSBpZiB0aGlzIGlzIGEgZmFsbGJhY2sgcmVxdWVzdC5cbiAgICovXG4gIGlzRmFsbGJhY2s/OiBib29sZWFuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW5jcmVtZW50YWxSZXNwb25zZUNhY2hlIHtcbiAgZ2V0KFxuICAgIGNhY2hlS2V5OiBzdHJpbmcsXG4gICAgY3R4OiBHZXRJbmNyZW1lbnRhbFJlc3BvbnNlQ2FjaGVDb250ZXh0XG4gICk6IFByb21pc2U8SW5jcmVtZW50YWxSZXNwb25zZUNhY2hlRW50cnkgfCBudWxsPlxuICBzZXQoXG4gICAga2V5OiBzdHJpbmcsXG4gICAgZGF0YTogRXhjbHVkZTxJbmNyZW1lbnRhbENhY2hlVmFsdWUsIENhY2hlZEZldGNoVmFsdWU+IHwgbnVsbCxcbiAgICBjdHg6IFNldEluY3JlbWVudGFsUmVzcG9uc2VDYWNoZUNvbnRleHRcbiAgKTogUHJvbWlzZTx2b2lkPlxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEluY3JlbWVudGFsQ2FjaGUgZXh0ZW5kcyBJbmNyZW1lbnRhbFJlc3BvbnNlQ2FjaGUge1xuICBnZXQoXG4gICAgY2FjaGVLZXk6IHN0cmluZyxcbiAgICBjdHg6IEdldEluY3JlbWVudGFsRmV0Y2hDYWNoZUNvbnRleHRcbiAgKTogUHJvbWlzZTxJbmNyZW1lbnRhbEZldGNoQ2FjaGVFbnRyeSB8IG51bGw+XG4gIGdldChcbiAgICBjYWNoZUtleTogc3RyaW5nLFxuICAgIGN0eDogR2V0SW5jcmVtZW50YWxSZXNwb25zZUNhY2hlQ29udGV4dFxuICApOiBQcm9taXNlPEluY3JlbWVudGFsUmVzcG9uc2VDYWNoZUVudHJ5IHwgbnVsbD5cbiAgc2V0KFxuICAgIGtleTogc3RyaW5nLFxuICAgIGRhdGE6IENhY2hlZEZldGNoVmFsdWUgfCBudWxsLFxuICAgIGN0eDogU2V0SW5jcmVtZW50YWxGZXRjaENhY2hlQ29udGV4dFxuICApOiBQcm9taXNlPHZvaWQ+XG4gIHNldChcbiAgICBrZXk6IHN0cmluZyxcbiAgICBkYXRhOiBFeGNsdWRlPEluY3JlbWVudGFsQ2FjaGVWYWx1ZSwgQ2FjaGVkRmV0Y2hWYWx1ZT4gfCBudWxsLFxuICAgIGN0eDogU2V0SW5jcmVtZW50YWxSZXNwb25zZUNhY2hlQ29udGV4dFxuICApOiBQcm9taXNlPHZvaWQ+XG59XG4iXSwibmFtZXMiOlsiQ2FjaGVkUm91dGVLaW5kIiwiSW5jcmVtZW50YWxDYWNoZUtpbmQiXSwibWFwcGluZ3MiOiI7Ozs7QUErQ08sSUFBV0Esa0JBQUFBLFdBQUFBLEdBQUFBLFNBQUFBLGVBQUFBOzs7Ozs7O1dBQUFBO01BT2pCO0FBMElNLElBQVdDLHVCQUFBQSxXQUFBQSxHQUFBQSxTQUFBQSxvQkFBQUE7Ozs7OztXQUFBQTtNQU1qQiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxMzEyMSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL3NlcnZlci9yZW5kZXItcmVzdWx0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgT3V0Z29pbmdIdHRwSGVhZGVycywgU2VydmVyUmVzcG9uc2UgfSBmcm9tICdodHRwJ1xuaW1wb3J0IHR5cGUgeyBDYWNoZUNvbnRyb2wgfSBmcm9tICcuL2xpYi9jYWNoZS1jb250cm9sJ1xuaW1wb3J0IHR5cGUgeyBGZXRjaE1ldHJpY3MgfSBmcm9tICcuL2Jhc2UtaHR0cCdcblxuaW1wb3J0IHtcbiAgY2hhaW5TdHJlYW1zLFxuICBzdHJlYW1Gcm9tQnVmZmVyLFxuICBzdHJlYW1Gcm9tU3RyaW5nLFxuICBzdHJlYW1Ub0J1ZmZlcixcbiAgc3RyZWFtVG9TdHJpbmcsXG59IGZyb20gJy4vc3RyZWFtLXV0aWxzL25vZGUtd2ViLXN0cmVhbXMtaGVscGVyJ1xuaW1wb3J0IHsgaXNBYm9ydEVycm9yLCBwaXBlVG9Ob2RlUmVzcG9uc2UgfSBmcm9tICcuL3BpcGUtcmVhZGFibGUnXG5pbXBvcnQgdHlwZSB7IFJlbmRlclJlc3VtZURhdGFDYWNoZSB9IGZyb20gJy4vcmVzdW1lLWRhdGEtY2FjaGUvcmVzdW1lLWRhdGEtY2FjaGUnXG5cbnR5cGUgQ29udGVudFR5cGVPcHRpb24gPSBzdHJpbmcgfCB1bmRlZmluZWRcblxuZXhwb3J0IHR5cGUgQXBwUGFnZVJlbmRlclJlc3VsdE1ldGFkYXRhID0ge1xuICBmbGlnaHREYXRhPzogQnVmZmVyXG4gIGNhY2hlQ29udHJvbD86IENhY2hlQ29udHJvbFxuICBzdGF0aWNCYWlsb3V0SW5mbz86IHtcbiAgICBzdGFjaz86IHN0cmluZ1xuICAgIGRlc2NyaXB0aW9uPzogc3RyaW5nXG4gIH1cblxuICAvKipcbiAgICogVGhlIHBvc3Rwb25lZCBzdGF0ZSBpZiB0aGUgcmVuZGVyIGhhZCBwb3N0cG9uZWQgYW5kIG5lZWRzIHRvIGJlIHJlc3VtZWQuXG4gICAqL1xuICBwb3N0cG9uZWQ/OiBzdHJpbmdcblxuICAvKipcbiAgICogVGhlIGhlYWRlcnMgdG8gc2V0IG9uIHRoZSByZXNwb25zZSB0aGF0IHdlcmUgYWRkZWQgYnkgdGhlIHJlbmRlci5cbiAgICovXG4gIGhlYWRlcnM/OiBPdXRnb2luZ0h0dHBIZWFkZXJzXG4gIHN0YXR1c0NvZGU/OiBudW1iZXJcbiAgZmV0Y2hUYWdzPzogc3RyaW5nXG4gIGZldGNoTWV0cmljcz86IEZldGNoTWV0cmljc1xuXG4gIHNlZ21lbnREYXRhPzogTWFwPHN0cmluZywgQnVmZmVyPlxuXG4gIC8qKlxuICAgKiBJbiBkZXZlbG9wbWVudCwgdGhlIHJlc3VtZSBkYXRhIGNhY2hlIGlzIHdhcm1lZCB1cCBiZWZvcmUgdGhlIHJlbmRlci4gVGhpc1xuICAgKiBpcyBhdHRhY2hlZCB0byB0aGUgbWV0YWRhdGEgc28gdGhhdCBpdCBjYW4gYmUgdXNlZCBkdXJpbmcgdGhlIHJlbmRlci4gV2hlblxuICAgKiBwcmVyZW5kZXJpbmcsIHRoZSBmaWxsZWQgcmVzdW1lIGRhdGEgY2FjaGUgaXMgYWxzbyBhdHRhY2hlZCB0byB0aGUgbWV0YWRhdGFcbiAgICogc28gdGhhdCBpdCBjYW4gYmUgdXNlZCB3aGVuIHByZXJlbmRlcmluZyBtYXRjaGluZyBmYWxsYmFjayBzaGVsbHMuXG4gICAqL1xuICByZW5kZXJSZXN1bWVEYXRhQ2FjaGU/OiBSZW5kZXJSZXN1bWVEYXRhQ2FjaGVcbn1cblxuZXhwb3J0IHR5cGUgUGFnZXNSZW5kZXJSZXN1bHRNZXRhZGF0YSA9IHtcbiAgcGFnZURhdGE/OiBhbnlcbiAgY2FjaGVDb250cm9sPzogQ2FjaGVDb250cm9sXG4gIGFzc2V0UXVlcnlTdHJpbmc/OiBzdHJpbmdcbiAgaXNOb3RGb3VuZD86IGJvb2xlYW5cbiAgaXNSZWRpcmVjdD86IGJvb2xlYW5cbn1cblxuZXhwb3J0IHR5cGUgU3RhdGljUmVuZGVyUmVzdWx0TWV0YWRhdGEgPSB7fVxuXG5leHBvcnQgdHlwZSBSZW5kZXJSZXN1bHRNZXRhZGF0YSA9IEFwcFBhZ2VSZW5kZXJSZXN1bHRNZXRhZGF0YSAmXG4gIFBhZ2VzUmVuZGVyUmVzdWx0TWV0YWRhdGEgJlxuICBTdGF0aWNSZW5kZXJSZXN1bHRNZXRhZGF0YVxuXG5leHBvcnQgdHlwZSBSZW5kZXJSZXN1bHRSZXNwb25zZSA9XG4gIHwgUmVhZGFibGVTdHJlYW08VWludDhBcnJheT5bXVxuICB8IFJlYWRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+XG4gIHwgc3RyaW5nXG4gIHwgQnVmZmVyXG4gIHwgbnVsbFxuXG5leHBvcnQgdHlwZSBSZW5kZXJSZXN1bHRPcHRpb25zPFxuICBNZXRhZGF0YSBleHRlbmRzIFJlbmRlclJlc3VsdE1ldGFkYXRhID0gUmVuZGVyUmVzdWx0TWV0YWRhdGEsXG4+ID0ge1xuICBjb250ZW50VHlwZT86IENvbnRlbnRUeXBlT3B0aW9uXG4gIHdhaXRVbnRpbD86IFByb21pc2U8dW5rbm93bj5cbiAgbWV0YWRhdGE6IE1ldGFkYXRhXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlbmRlclJlc3VsdDxcbiAgTWV0YWRhdGEgZXh0ZW5kcyBSZW5kZXJSZXN1bHRNZXRhZGF0YSA9IFJlbmRlclJlc3VsdE1ldGFkYXRhLFxuPiB7XG4gIC8qKlxuICAgKiBUaGUgZGV0ZWN0ZWQgY29udGVudCB0eXBlIGZvciB0aGUgcmVzcG9uc2UuIFRoaXMgaXMgdXNlZCB0byBzZXQgdGhlXG4gICAqIGBDb250ZW50LVR5cGVgIGhlYWRlci5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBjb250ZW50VHlwZTogQ29udGVudFR5cGVPcHRpb25cblxuICAvKipcbiAgICogVGhlIG1ldGFkYXRhIGZvciB0aGUgcmVzcG9uc2UuIFRoaXMgaXMgdXNlZCB0byBzZXQgdGhlIHJldmFsaWRhdGlvbiB0aW1lc1xuICAgKiBhbmQgb3RoZXIgbWV0YWRhdGEuXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgbWV0YWRhdGE6IFJlYWRvbmx5PE1ldGFkYXRhPlxuXG4gIC8qKlxuICAgKiBUaGUgcmVzcG9uc2UgaXRzZWxmLiBUaGlzIGNhbiBiZSBhIHN0cmluZywgYSBzdHJlYW0sIG9yIG51bGwuIElmIGl0J3MgYVxuICAgKiBzdHJpbmcsIHRoZW4gaXQncyBhIHN0YXRpYyByZXNwb25zZS4gSWYgaXQncyBhIHN0cmVhbSwgdGhlbiBpdCdzIGFcbiAgICogZHluYW1pYyByZXNwb25zZS4gSWYgaXQncyBudWxsLCB0aGVuIHRoZSByZXNwb25zZSB3YXMgbm90IGZvdW5kIG9yIHdhc1xuICAgKiBhbHJlYWR5IHNlbnQuXG4gICAqL1xuICBwcml2YXRlIHJlc3BvbnNlOiBSZW5kZXJSZXN1bHRSZXNwb25zZVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFJlbmRlclJlc3VsdCBpbnN0YW5jZSBmcm9tIGEgc3RhdGljIHJlc3BvbnNlLlxuICAgKlxuICAgKiBAcGFyYW0gdmFsdWUgdGhlIHN0YXRpYyByZXNwb25zZSB2YWx1ZVxuICAgKiBAcmV0dXJucyBhIG5ldyBSZW5kZXJSZXN1bHQgaW5zdGFuY2VcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZnJvbVN0YXRpYyh2YWx1ZTogc3RyaW5nIHwgQnVmZmVyKSB7XG4gICAgcmV0dXJuIG5ldyBSZW5kZXJSZXN1bHQ8U3RhdGljUmVuZGVyUmVzdWx0TWV0YWRhdGE+KHZhbHVlLCB7IG1ldGFkYXRhOiB7fSB9KVxuICB9XG5cbiAgcHJpdmF0ZSByZWFkb25seSB3YWl0VW50aWw/OiBQcm9taXNlPHVua25vd24+XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcmVzcG9uc2U6IFJlbmRlclJlc3VsdFJlc3BvbnNlLFxuICAgIHsgY29udGVudFR5cGUsIHdhaXRVbnRpbCwgbWV0YWRhdGEgfTogUmVuZGVyUmVzdWx0T3B0aW9uczxNZXRhZGF0YT5cbiAgKSB7XG4gICAgdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlXG4gICAgdGhpcy5jb250ZW50VHlwZSA9IGNvbnRlbnRUeXBlXG4gICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhXG4gICAgdGhpcy53YWl0VW50aWwgPSB3YWl0VW50aWxcbiAgfVxuXG4gIHB1YmxpYyBhc3NpZ25NZXRhZGF0YShtZXRhZGF0YTogTWV0YWRhdGEpIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMubWV0YWRhdGEsIG1ldGFkYXRhKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcmVzcG9uc2UgaXMgbnVsbC4gSXQgY2FuIGJlIG51bGwgaWYgdGhlIHJlc3BvbnNlIHdhc1xuICAgKiBub3QgZm91bmQgb3Igd2FzIGFscmVhZHkgc2VudC5cbiAgICovXG4gIHB1YmxpYyBnZXQgaXNOdWxsKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnJlc3BvbnNlID09PSBudWxsXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBmYWxzZSBpZiB0aGUgcmVzcG9uc2UgaXMgYSBzdHJpbmcuIEl0IGNhbiBiZSBhIHN0cmluZyBpZiB0aGUgcGFnZVxuICAgKiB3YXMgcHJlcmVuZGVyZWQuIElmIGl0J3Mgbm90LCB0aGVuIGl0IHdhcyBnZW5lcmF0ZWQgZHluYW1pY2FsbHkuXG4gICAqL1xuICBwdWJsaWMgZ2V0IGlzRHluYW1pYygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaXMucmVzcG9uc2UgIT09ICdzdHJpbmcnXG4gIH1cblxuICBwdWJsaWMgdG9VbmNodW5rZWRCdWZmZXIoc3RyZWFtPzogZmFsc2UpOiBCdWZmZXJcbiAgcHVibGljIHRvVW5jaHVua2VkQnVmZmVyKHN0cmVhbTogdHJ1ZSk6IFByb21pc2U8QnVmZmVyPlxuICBwdWJsaWMgdG9VbmNodW5rZWRCdWZmZXIoc3RyZWFtID0gZmFsc2UpOiBQcm9taXNlPEJ1ZmZlcj4gfCBCdWZmZXIge1xuICAgIGlmICh0aGlzLnJlc3BvbnNlID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFyaWFudDogbnVsbCByZXNwb25zZXMgY2Fubm90IGJlIHVuY2h1bmtlZCcpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0aGlzLnJlc3BvbnNlICE9PSAnc3RyaW5nJykge1xuICAgICAgaWYgKCFzdHJlYW0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdJbnZhcmlhbnQ6IGR5bmFtaWMgcmVzcG9uc2VzIGNhbm5vdCBiZSB1bmNodW5rZWQuIFRoaXMgaXMgYSBidWcgaW4gTmV4dC5qcydcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RyZWFtVG9CdWZmZXIodGhpcy5yZWFkYWJsZSlcbiAgICB9XG5cbiAgICByZXR1cm4gQnVmZmVyLmZyb20odGhpcy5yZXNwb25zZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByZXNwb25zZSBpZiBpdCBpcyBhIHN0cmluZy4gSWYgdGhlIHBhZ2Ugd2FzIGR5bmFtaWMsIHRoaXMgd2lsbFxuICAgKiByZXR1cm4gYSBwcm9taXNlIGlmIHRoZSBgc3RyZWFtYCBvcHRpb24gaXMgdHJ1ZSwgb3IgaXQgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAgICpcbiAgICogQHBhcmFtIHN0cmVhbSBXaGV0aGVyIG9yIG5vdCB0byByZXR1cm4gYSBwcm9taXNlIGlmIHRoZSByZXNwb25zZSBpcyBkeW5hbWljXG4gICAqIEByZXR1cm5zIFRoZSByZXNwb25zZSBhcyBhIHN0cmluZ1xuICAgKi9cbiAgcHVibGljIHRvVW5jaHVua2VkU3RyaW5nKHN0cmVhbT86IGZhbHNlKTogc3RyaW5nXG4gIHB1YmxpYyB0b1VuY2h1bmtlZFN0cmluZyhzdHJlYW06IHRydWUpOiBQcm9taXNlPHN0cmluZz5cbiAgcHVibGljIHRvVW5jaHVua2VkU3RyaW5nKHN0cmVhbSA9IGZhbHNlKTogUHJvbWlzZTxzdHJpbmc+IHwgc3RyaW5nIHtcbiAgICBpZiAodGhpcy5yZXNwb25zZSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhcmlhbnQ6IG51bGwgcmVzcG9uc2VzIGNhbm5vdCBiZSB1bmNodW5rZWQnKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGhpcy5yZXNwb25zZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGlmICghc3RyZWFtKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnSW52YXJpYW50OiBkeW5hbWljIHJlc3BvbnNlcyBjYW5ub3QgYmUgdW5jaHVua2VkLiBUaGlzIGlzIGEgYnVnIGluIE5leHQuanMnXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0cmVhbVRvU3RyaW5nKHRoaXMucmVhZGFibGUpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucmVzcG9uc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByZXNwb25zZSBpZiBpdCBpcyBhIHN0cmVhbSwgb3IgdGhyb3dzIGFuIGVycm9yIGlmIGl0IGlzIGFcbiAgICogc3RyaW5nLlxuICAgKi9cbiAgcHJpdmF0ZSBnZXQgcmVhZGFibGUoKTogUmVhZGFibGVTdHJlYW08VWludDhBcnJheT4ge1xuICAgIGlmICh0aGlzLnJlc3BvbnNlID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFyaWFudDogbnVsbCByZXNwb25zZXMgY2Fubm90IGJlIHN0cmVhbWVkJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0aGlzLnJlc3BvbnNlID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhcmlhbnQ6IHN0YXRpYyByZXNwb25zZXMgY2Fubm90IGJlIHN0cmVhbWVkJylcbiAgICB9XG5cbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHRoaXMucmVzcG9uc2UpKSB7XG4gICAgICByZXR1cm4gc3RyZWFtRnJvbUJ1ZmZlcih0aGlzLnJlc3BvbnNlKVxuICAgIH1cblxuICAgIC8vIElmIHRoZSByZXNwb25zZSBpcyBhbiBhcnJheSBvZiBzdHJlYW1zLCB0aGVuIGNoYWluIHRoZW0gdG9nZXRoZXIuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5yZXNwb25zZSkpIHtcbiAgICAgIHJldHVybiBjaGFpblN0cmVhbXMoLi4udGhpcy5yZXNwb25zZSlcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5yZXNwb25zZVxuICB9XG5cbiAgLyoqXG4gICAqIENoYWlucyBhIG5ldyBzdHJlYW0gdG8gdGhlIHJlc3BvbnNlLiBUaGlzIHdpbGwgY29udmVydCB0aGUgcmVzcG9uc2UgdG8gYW5cbiAgICogYXJyYXkgb2Ygc3RyZWFtcyBpZiBpdCBpcyBub3QgYWxyZWFkeSBvbmUgYW5kIHdpbGwgYWRkIHRoZSBuZXcgc3RyZWFtIHRvXG4gICAqIHRoZSBlbmQuIFdoZW4gdGhpcyByZXNwb25zZSBpcyBwaXBlZCwgYWxsIG9mIHRoZSBzdHJlYW1zIHdpbGwgYmUgcGlwZWRcbiAgICogb25lIGFmdGVyIHRoZSBvdGhlci5cbiAgICpcbiAgICogQHBhcmFtIHJlYWRhYmxlIFRoZSBuZXcgc3RyZWFtIHRvIGNoYWluXG4gICAqL1xuICBwdWJsaWMgY2hhaW4ocmVhZGFibGU6IFJlYWRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+KSB7XG4gICAgaWYgKHRoaXMucmVzcG9uc2UgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YXJpYW50OiByZXNwb25zZSBpcyBudWxsLiBUaGlzIGlzIGEgYnVnIGluIE5leHQuanMnKVxuICAgIH1cblxuICAgIC8vIElmIHRoZSByZXNwb25zZSBpcyBub3QgYW4gYXJyYXkgb2Ygc3RyZWFtcyBhbHJlYWR5LCBtYWtlIGl0IG9uZS5cbiAgICBsZXQgcmVzcG9uc2VzOiBSZWFkYWJsZVN0cmVhbTxVaW50OEFycmF5PltdXG4gICAgaWYgKHR5cGVvZiB0aGlzLnJlc3BvbnNlID09PSAnc3RyaW5nJykge1xuICAgICAgcmVzcG9uc2VzID0gW3N0cmVhbUZyb21TdHJpbmcodGhpcy5yZXNwb25zZSldXG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHRoaXMucmVzcG9uc2UpKSB7XG4gICAgICByZXNwb25zZXMgPSB0aGlzLnJlc3BvbnNlXG4gICAgfSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIodGhpcy5yZXNwb25zZSkpIHtcbiAgICAgIHJlc3BvbnNlcyA9IFtzdHJlYW1Gcm9tQnVmZmVyKHRoaXMucmVzcG9uc2UpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXNwb25zZXMgPSBbdGhpcy5yZXNwb25zZV1cbiAgICB9XG5cbiAgICAvLyBBZGQgdGhlIG5ldyBzdHJlYW0gdG8gdGhlIGFycmF5LlxuICAgIHJlc3BvbnNlcy5wdXNoKHJlYWRhYmxlKVxuXG4gICAgLy8gVXBkYXRlIHRoZSByZXNwb25zZS5cbiAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2VzXG4gIH1cblxuICAvKipcbiAgICogUGlwZXMgdGhlIHJlc3BvbnNlIHRvIGEgd3JpdGFibGUgc3RyZWFtLiBUaGlzIHdpbGwgY2xvc2UvY2FuY2VsIHRoZVxuICAgKiB3cml0YWJsZSBzdHJlYW0gaWYgYW4gZXJyb3IgaXMgZW5jb3VudGVyZWQuIElmIHRoaXMgZG9lc24ndCB0aHJvdywgdGhlblxuICAgKiB0aGUgd3JpdGFibGUgc3RyZWFtIHdpbGwgYmUgY2xvc2VkIG9yIGFib3J0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB3cml0YWJsZSBXcml0YWJsZSBzdHJlYW0gdG8gcGlwZSB0aGUgcmVzcG9uc2UgdG9cbiAgICovXG4gIHB1YmxpYyBhc3luYyBwaXBlVG8od3JpdGFibGU6IFdyaXRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMucmVhZGFibGUucGlwZVRvKHdyaXRhYmxlLCB7XG4gICAgICAgIC8vIFdlIHdhbnQgdG8gY2xvc2UgdGhlIHdyaXRhYmxlIHN0cmVhbSBvdXJzZWx2ZXMgc28gdGhhdCB3ZSBjYW4gd2FpdFxuICAgICAgICAvLyBmb3IgdGhlIHdhaXRVbnRpbCBwcm9taXNlIHRvIHJlc29sdmUgYmVmb3JlIGNsb3NpbmcgaXQuIElmIGFuIGVycm9yXG4gICAgICAgIC8vIGlzIGVuY291bnRlcmVkLCB3ZSdsbCBhYm9ydCB0aGUgd3JpdGFibGUgc3RyZWFtIGlmIHdlIHN3YWxsb3dlZCB0aGVcbiAgICAgICAgLy8gZXJyb3IuXG4gICAgICAgIHByZXZlbnRDbG9zZTogdHJ1ZSxcbiAgICAgIH0pXG5cbiAgICAgIC8vIElmIHRoZXJlIGlzIGEgd2FpdFVudGlsIHByb21pc2UsIHdhaXQgZm9yIGl0IHRvIHJlc29sdmUgYmVmb3JlXG4gICAgICAvLyBjbG9zaW5nIHRoZSB3cml0YWJsZSBzdHJlYW0uXG4gICAgICBpZiAodGhpcy53YWl0VW50aWwpIGF3YWl0IHRoaXMud2FpdFVudGlsXG5cbiAgICAgIC8vIENsb3NlIHRoZSB3cml0YWJsZSBzdHJlYW0uXG4gICAgICBhd2FpdCB3cml0YWJsZS5jbG9zZSgpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBJZiB0aGlzIGlzIGFuIGFib3J0IGVycm9yLCB3ZSBzaG91bGQgYWJvcnQgdGhlIHdyaXRhYmxlIHN0cmVhbSAoYXMgd2VcbiAgICAgIC8vIHRvb2sgb3duZXJzaGlwIG9mIGl0IHdoZW4gd2Ugc3RhcnRlZCBwaXBpbmcpLiBXZSBkb24ndCBuZWVkIHRvIHJlLXRocm93XG4gICAgICAvLyBiZWNhdXNlIHdlIGhhbmRsZWQgdGhlIGVycm9yLlxuICAgICAgaWYgKGlzQWJvcnRFcnJvcihlcnIpKSB7XG4gICAgICAgIC8vIEFib3J0IHRoZSB3cml0YWJsZSBzdHJlYW0gaWYgYW4gZXJyb3IgaXMgZW5jb3VudGVyZWQuXG4gICAgICAgIGF3YWl0IHdyaXRhYmxlLmFib3J0KGVycilcblxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gV2UncmUgbm90IGFib3J0aW5nIHRoZSB3cml0ZXIgaGVyZSBhcyB3aGVuIHRoaXMgbWV0aG9kIHRocm93cyBpdCdzIG5vdFxuICAgICAgLy8gY2xlYXIgYXMgdG8gaG93IHNvIHRoZSBjYWxsZXIgc2hvdWxkIGFzc3VtZSBpdCdzIHRoZWlyIHJlc3BvbnNpYmlsaXR5XG4gICAgICAvLyB0byBjbGVhbiB1cCB0aGUgd3JpdGVyLlxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBpcGVzIHRoZSByZXNwb25zZSB0byBhIG5vZGUgcmVzcG9uc2UuIFRoaXMgd2lsbCBjbG9zZS9jYW5jZWwgdGhlIG5vZGVcbiAgICogcmVzcG9uc2UgaWYgYW4gZXJyb3IgaXMgZW5jb3VudGVyZWQuXG4gICAqXG4gICAqIEBwYXJhbSByZXNcbiAgICovXG4gIHB1YmxpYyBhc3luYyBwaXBlVG9Ob2RlUmVzcG9uc2UocmVzOiBTZXJ2ZXJSZXNwb25zZSkge1xuICAgIGF3YWl0IHBpcGVUb05vZGVSZXNwb25zZSh0aGlzLnJlYWRhYmxlLCByZXMsIHRoaXMud2FpdFVudGlsKVxuICB9XG59XG4iXSwibmFtZXMiOlsiY2hhaW5TdHJlYW1zIiwic3RyZWFtRnJvbUJ1ZmZlciIsInN0cmVhbUZyb21TdHJpbmciLCJzdHJlYW1Ub0J1ZmZlciIsInN0cmVhbVRvU3RyaW5nIiwiaXNBYm9ydEVycm9yIiwicGlwZVRvTm9kZVJlc3BvbnNlIiwiUmVuZGVyUmVzdWx0IiwiZnJvbVN0YXRpYyIsInZhbHVlIiwibWV0YWRhdGEiLCJjb25zdHJ1Y3RvciIsInJlc3BvbnNlIiwiY29udGVudFR5cGUiLCJ3YWl0VW50aWwiLCJhc3NpZ25NZXRhZGF0YSIsIk9iamVjdCIsImFzc2lnbiIsImlzTnVsbCIsImlzRHluYW1pYyIsInRvVW5jaHVua2VkQnVmZmVyIiwic3RyZWFtIiwiRXJyb3IiLCJyZWFkYWJsZSIsIkJ1ZmZlciIsImZyb20iLCJ0b1VuY2h1bmtlZFN0cmluZyIsImlzQnVmZmVyIiwiQXJyYXkiLCJpc0FycmF5IiwiY2hhaW4iLCJyZXNwb25zZXMiLCJwdXNoIiwicGlwZVRvIiwid3JpdGFibGUiLCJwcmV2ZW50Q2xvc2UiLCJjbG9zZSIsImVyciIsImFib3J0IiwicmVzIl0sIm1hcHBpbmdzIjoiOzs7QUFJQSxTQUNFQSxZQUFZLEVBQ1pDLGdCQUFnQixFQUNoQkMsZ0JBQWdCLEVBQ2hCQyxjQUFjLEVBQ2RDLGNBQWMsUUFDVCx5Q0FBd0M7QUFDL0MsU0FBU0MsWUFBWSxFQUFFQyxrQkFBa0IsUUFBUSxrQkFBaUI7OztBQWtFbkQsTUFBTUM7SUF1Qm5COzs7OztHQUtDLEdBQ0QsT0FBY0MsV0FBV0MsS0FBc0IsRUFBRTtRQUMvQyxPQUFPLElBQUlGLGFBQXlDRSxPQUFPO1lBQUVDLFVBQVUsQ0FBQztRQUFFO0lBQzVFO0lBSUFDLFlBQ0VDLFFBQThC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LHlFQUF5RTtZQUN6RSx3RUFBd0U7WUFDeEUsMEJBQTBCO1lBQzFCLE1BQU1BO1FBQ1I7SUFDRjtJQUVBOzs7OztHQUtDLEdBQ0QsTUFBYS9CLG1CQUFtQmlDLEdBQW1CLEVBQUU7UUFDbkQsNEtBQU1qQyxxQkFBQUEsRUFBbUIsSUFBSSxDQUFDaUIsUUFBUSxFQUFFZ0IsS0FBSyxJQUFJLENBQUN6QixTQUFTO0lBQzdEO0FBQ0YiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTMzMTIsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NyYy9zZXJ2ZXIvcmVzcG9uc2UtY2FjaGUvdXRpbHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQ2FjaGVkUm91dGVLaW5kLFxuICBJbmNyZW1lbnRhbENhY2hlS2luZCxcbiAgdHlwZSBDYWNoZWRBcHBQYWdlVmFsdWUsXG4gIHR5cGUgQ2FjaGVkUGFnZVZhbHVlLFxuICB0eXBlIEluY3JlbWVudGFsUmVzcG9uc2VDYWNoZUVudHJ5LFxuICB0eXBlIFJlc3BvbnNlQ2FjaGVFbnRyeSxcbn0gZnJvbSAnLi90eXBlcydcblxuaW1wb3J0IFJlbmRlclJlc3VsdCBmcm9tICcuLi9yZW5kZXItcmVzdWx0J1xuaW1wb3J0IHsgUm91dGVLaW5kIH0gZnJvbSAnLi4vcm91dGUta2luZCdcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZyb21SZXNwb25zZUNhY2hlRW50cnkoXG4gIGNhY2hlRW50cnk6IFJlc3BvbnNlQ2FjaGVFbnRyeVxuKTogUHJvbWlzZTxJbmNyZW1lbnRhbFJlc3BvbnNlQ2FjaGVFbnRyeT4ge1xuICByZXR1cm4ge1xuICAgIC4uLmNhY2hlRW50cnksXG4gICAgdmFsdWU6XG4gICAgICBjYWNoZUVudHJ5LnZhbHVlPy5raW5kID09PSBDYWNoZWRSb3V0ZUtpbmQuUEFHRVNcbiAgICAgICAgPyB7XG4gICAgICAgICAgICBraW5kOiBDYWNoZWRSb3V0ZUtpbmQuUEFHRVMsXG4gICAgICAgICAgICBodG1sOiBhd2FpdCBjYWNoZUVudHJ5LnZhbHVlLmh0bWwudG9VbmNodW5rZWRTdHJpbmcodHJ1ZSksXG4gICAgICAgICAgICBwYWdlRGF0YTogY2FjaGVFbnRyeS52YWx1ZS5wYWdlRGF0YSxcbiAgICAgICAgICAgIGhlYWRlcnM6IGNhY2hlRW50cnkudmFsdWUuaGVhZGVycyxcbiAgICAgICAgICAgIHN0YXR1czogY2FjaGVFbnRyeS52YWx1ZS5zdGF0dXMsXG4gICAgICAgICAgfVxuICAgICAgICA6IGNhY2hlRW50cnkudmFsdWU/LmtpbmQgPT09IENhY2hlZFJvdXRlS2luZC5BUFBfUEFHRVxuICAgICAgICAgID8ge1xuICAgICAgICAgICAgICBraW5kOiBDYWNoZWRSb3V0ZUtpbmQuQVBQX1BBR0UsXG4gICAgICAgICAgICAgIGh0bWw6IGF3YWl0IGNhY2hlRW50cnkudmFsdWUuaHRtbC50b1VuY2h1bmtlZFN0cmluZyh0cnVlKSxcbiAgICAgICAgICAgICAgcG9zdHBvbmVkOiBjYWNoZUVudHJ5LnZhbHVlLnBvc3Rwb25lZCxcbiAgICAgICAgICAgICAgcnNjRGF0YTogY2FjaGVFbnRyeS52YWx1ZS5yc2NEYXRhLFxuICAgICAgICAgICAgICBoZWFkZXJzOiBjYWNoZUVudHJ5LnZhbHVlLmhlYWRlcnMsXG4gICAgICAgICAgICAgIHN0YXR1czogY2FjaGVFbnRyeS52YWx1ZS5zdGF0dXMsXG4gICAgICAgICAgICAgIHNlZ21lbnREYXRhOiBjYWNoZUVudHJ5LnZhbHVlLnNlZ21lbnREYXRhLFxuICAgICAgICAgICAgfVxuICAgICAgICAgIDogY2FjaGVFbnRyeS52YWx1ZSxcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdG9SZXNwb25zZUNhY2hlRW50cnkoXG4gIHJlc3BvbnNlOiBJbmNyZW1lbnRhbFJlc3BvbnNlQ2FjaGVFbnRyeSB8IG51bGxcbik6IFByb21pc2U8UmVzcG9uc2VDYWNoZUVudHJ5IHwgbnVsbD4ge1xuICBpZiAoIXJlc3BvbnNlKSByZXR1cm4gbnVsbFxuXG4gIHJldHVybiB7XG4gICAgaXNNaXNzOiByZXNwb25zZS5pc01pc3MsXG4gICAgaXNTdGFsZTogcmVzcG9uc2UuaXNTdGFsZSxcbiAgICBjYWNoZUNvbnRyb2w6IHJlc3BvbnNlLmNhY2hlQ29udHJvbCxcbiAgICB2YWx1ZTpcbiAgICAgIHJlc3BvbnNlLnZhbHVlPy5raW5kID09PSBDYWNoZWRSb3V0ZUtpbmQuUEFHRVNcbiAgICAgICAgPyAoe1xuICAgICAgICAgICAga2luZDogQ2FjaGVkUm91dGVLaW5kLlBBR0VTLFxuICAgICAgICAgICAgaHRtbDogUmVuZGVyUmVzdWx0LmZyb21TdGF0aWMocmVzcG9uc2UudmFsdWUuaHRtbCksXG4gICAgICAgICAgICBwYWdlRGF0YTogcmVzcG9uc2UudmFsdWUucGFnZURhdGEsXG4gICAgICAgICAgICBoZWFkZXJzOiByZXNwb25zZS52YWx1ZS5oZWFkZXJzLFxuICAgICAgICAgICAgc3RhdHVzOiByZXNwb25zZS52YWx1ZS5zdGF0dXMsXG4gICAgICAgICAgfSBzYXRpc2ZpZXMgQ2FjaGVkUGFnZVZhbHVlKVxuICAgICAgICA6IHJlc3BvbnNlLnZhbHVlPy5raW5kID09PSBDYWNoZWRSb3V0ZUtpbmQuQVBQX1BBR0VcbiAgICAgICAgICA/ICh7XG4gICAgICAgICAgICAgIGtpbmQ6IENhY2hlZFJvdXRlS2luZC5BUFBfUEFHRSxcbiAgICAgICAgICAgICAgaHRtbDogUmVuZGVyUmVzdWx0LmZyb21TdGF0aWMocmVzcG9uc2UudmFsdWUuaHRtbCksXG4gICAgICAgICAgICAgIHJzY0RhdGE6IHJlc3BvbnNlLnZhbHVlLnJzY0RhdGEsXG4gICAgICAgICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlLnZhbHVlLmhlYWRlcnMsXG4gICAgICAgICAgICAgIHN0YXR1czogcmVzcG9uc2UudmFsdWUuc3RhdHVzLFxuICAgICAgICAgICAgICBwb3N0cG9uZWQ6IHJlc3BvbnNlLnZhbHVlLnBvc3Rwb25lZCxcbiAgICAgICAgICAgICAgc2VnbWVudERhdGE6IHJlc3BvbnNlLnZhbHVlLnNlZ21lbnREYXRhLFxuICAgICAgICAgICAgfSBzYXRpc2ZpZXMgQ2FjaGVkQXBwUGFnZVZhbHVlKVxuICAgICAgICAgIDogcmVzcG9uc2UudmFsdWUsXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdXRlS2luZFRvSW5jcmVtZW50YWxDYWNoZUtpbmQoXG4gIHJvdXRlS2luZDogUm91dGVLaW5kXG4pOiBFeGNsdWRlPEluY3JlbWVudGFsQ2FjaGVLaW5kLCBJbmNyZW1lbnRhbENhY2hlS2luZC5GRVRDSD4ge1xuICBzd2l0Y2ggKHJvdXRlS2luZCkge1xuICAgIGNhc2UgUm91dGVLaW5kLlBBR0VTOlxuICAgICAgcmV0dXJuIEluY3JlbWVudGFsQ2FjaGVLaW5kLlBBR0VTXG4gICAgY2FzZSBSb3V0ZUtpbmQuQVBQX1BBR0U6XG4gICAgICByZXR1cm4gSW5jcmVtZW50YWxDYWNoZUtpbmQuQVBQX1BBR0VcbiAgICBjYXNlIFJvdXRlS2luZC5JTUFHRTpcbiAgICAgIHJldHVybiBJbmNyZW1lbnRhbENhY2hlS2luZC5JTUFHRVxuICAgIGNhc2UgUm91dGVLaW5kLkFQUF9ST1VURTpcbiAgICAgIHJldHVybiBJbmNyZW1lbnRhbENhY2hlS2luZC5BUFBfUk9VVEVcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIHJvdXRlIGtpbmQgJHtyb3V0ZUtpbmR9YClcbiAgfVxufVxuIl0sIm5hbWVzIjpbIkNhY2hlZFJvdXRlS2luZCIsIkluY3JlbWVudGFsQ2FjaGVLaW5kIiwiUmVuZGVyUmVzdWx0IiwiUm91dGVLaW5kIiwiZnJvbVJlc3BvbnNlQ2FjaGVFbnRyeSIsImNhY2hlRW50cnkiLCJ2YWx1ZSIsImtpbmQiLCJQQUdFUyIsImh0bWwiLCJ0b1VuY2h1bmtlZFN0cmluZyIsInBhZ2VEYXRhIiwiaGVhZGVycyIsInN0YXR1cyIsIkFQUF9QQUdFIiwicG9zdHBvbmVkIiwicnNjRGF0YSIsInNlZ21lbnREYXRhIiwidG9SZXNwb25zZUNhY2hlRW50cnkiLCJyZXNwb25zZSIsImlzTWlzcyIsImlzU3RhbGUiLCJjYWNoZUNvbnRyb2wiLCJmcm9tU3RhdGljIiwicm91dGVLaW5kVG9JbmNyZW1lbnRhbENhY2hlS2luZCIsInJvdXRlS2luZCIsIklNQUdFIiwiQVBQX1JPVVRFIiwiRXJyb3IiXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsU0FDRUEsZUFBZSxFQUNmQyxvQkFBb0IsUUFLZixVQUFTO0FBRWhCLE9BQU9DLGtCQUFrQixtQkFBa0I7QUFDM0MsU0FBU0MsU0FBUyxRQUFRLGdCQUFlOzs7O0FBRWxDLGVBQWVDLHVCQUNwQkMsVUFBOEI7UUFLMUJBLG1CQVFJQTtJQVhSLE9BQU87UUFDTCxHQUFHQSxVQUFVO1FBQ2JDLE9BQ0VELENBQUFBLENBQUFBLG9CQUFBQSxXQUFXQyxLQUFLLEtBQUEsT0FBQSxLQUFBLElBQWhCRCxrQkFBa0JFLElBQUksa0xBQUtQLGtCQUFBQSxDQUFnQlEsS0FBSyxHQUM1QztZQUNFRCxrTEFBTVAsa0JBQUFBLENBQWdCUSxLQUFLO1lBQzNCQyxNQUFNLE1BQU1KLFdBQVdDLEtBQUssQ0FBQ0csSUFBSSxDQUFDQyxpQkFBaUIsQ0FBQztZQUNwREMsVUFBVU4sV0FBV0MsS0FBSyxDQUFDSyxRQUFRO1lBQ25DQyxTQUFTUCxXQUFXQyxLQUFLLENBQUNNLE9BQU87WUFDakNDLFFBQVFSLFdBQVdDLEtBQUssQ0FBQ08sTUFBTTtRQUNqQyxJQUNBUixDQUFBQSxDQUFBQSxxQkFBQUEsV0FBV0MsS0FBSyxLQUFBLE9BQUEsS0FBQSxJQUFoQkQsbUJBQWtCRSxJQUFJLGtMQUFLUCxrQkFBQUEsQ0FBZ0JjLFFBQVEsR0FDakQ7WUFDRVAsa0xBQU1QLGtCQUFBQSxDQUFnQmMsUUFBUTtZQUM5QkwsTUFBTSxNQUFNSixXQUFXQyxLQUFLLENBQUNHLElBQUksQ0FBQ0MsaUJBQWlCLENBQUM7WUFDcERLLFdBQVdWLFdBQVdDLEtBQUssQ0FBQ1MsU0FBUztZQUNyQ0MsU0FBU1gsV0FBV0MsS0FBSyxDQUFDVSxPQUFPO1lBQ2pDSixTQUFTUCxXQUFXQyxLQUFLLENBQUNNLE9BQU87WUFDakNDLFFBQVFSLFdBQVdDLEtBQUssQ0FBQ08sTUFBTTtZQUMvQkksYUFBYVosV0FBV0MsS0FBSyxDQUFDVyxXQUFXO1FBQzNDLElBQ0FaLFdBQVdDLEtBQUs7SUFDMUI7QUFDRjtBQUVPLGVBQWVZLHFCQUNwQkMsUUFBOEM7UUFTMUNBLGlCQVFJQTtJQWZSLElBQUksQ0FBQ0EsVUFBVSxPQUFPO0lBRXRCLE9BQU87UUFDTEMsUUFBUUQsU0FBU0MsTUFBTTtRQUN2QkMsU0FBU0YsU0FBU0UsT0FBTztRQUN6QkMsY0FBY0gsU0FBU0csWUFBWTtRQUNuQ2hCLE9BQ0VhLENBQUFBLENBQUFBLGtCQUFBQSxTQUFTYixLQUFLLEtBQUEsT0FBQSxLQUFBLElBQWRhLGdCQUFnQlosSUFBSSxrTEFBS1Asa0JBQUFBLENBQWdCUSxLQUFLLEdBQ3pDO1lBQ0NELGtMQUFNUCxrQkFBQUEsQ0FBZ0JRLEtBQUs7WUFDM0JDLHdLQUFNUCxVQUFBQSxDQUFhcUIsVUFBVSxDQUFDSixTQUFTYixLQUFLLENBQUNHLElBQUk7WUFDakRFLFVBQVVRLFNBQVNiLEtBQUssQ0FBQ0ssUUFBUTtZQUNqQ0MsU0FBU08sU0FBU2IsS0FBSyxDQUFDTSxPQUFPO1lBQy9CQyxRQUFRTSxTQUFTYixLQUFLLENBQUNPLE1BQU07UUFDL0IsSUFDQU0sQ0FBQUEsQ0FBQUEsbUJBQUFBLFNBQVNiLEtBQUssS0FBQSxPQUFBLEtBQUEsSUFBZGEsaUJBQWdCWixJQUFJLGtMQUFLUCxrQkFBQUEsQ0FBZ0JjLFFBQVEsR0FDOUM7WUFDQ1Asa0xBQU1QLGtCQUFBQSxDQUFnQmMsUUFBUTtZQUM5Qkwsd0tBQU1QLFVBQUFBLENBQWFxQixVQUFVLENBQUNKLFNBQVNiLEtBQUssQ0FBQ0csSUFBSTtZQUNqRE8sU0FBU0csU0FBU2IsS0FBSyxDQUFDVSxPQUFPO1lBQy9CSixTQUFTTyxTQUFTYixLQUFLLENBQUNNLE9BQU87WUFDL0JDLFFBQVFNLFNBQVNiLEtBQUssQ0FBQ08sTUFBTTtZQUM3QkUsV0FBV0ksU0FBU2IsS0FBSyxDQUFDUyxTQUFTO1lBQ25DRSxhQUFhRSxTQUFTYixLQUFLLENBQUNXLFdBQVc7UUFDekMsSUFDQUUsU0FBU2IsS0FBSztJQUN4QjtBQUNGO0FBRU8sU0FBU2tCLGdDQUNkQyxTQUFvQjtJQUVwQixPQUFRQTtRQUNOLG9LQUFLdEIsWUFBQUEsQ0FBVUssS0FBSztZQUNsQixtTEFBT1AsdUJBQUFBLENBQXFCTyxLQUFLO1FBQ25DLG9LQUFLTCxZQUFBQSxDQUFVVyxRQUFRO1lBQ3JCLG1MQUFPYix1QkFBQUEsQ0FBcUJhLFFBQVE7UUFDdEMsb0tBQUtYLFlBQUFBLENBQVV1QixLQUFLO1lBQ2xCLG1MQUFPekIsdUJBQUFBLENBQXFCeUIsS0FBSztRQUNuQyxvS0FBS3ZCLFlBQUFBLENBQVV3QixTQUFTO1lBQ3RCLG1MQUFPMUIsdUJBQUFBLENBQXFCMEIsU0FBUztRQUN2QztZQUNFLE1BQU0sT0FBQSxjQUErQyxDQUEvQyxJQUFJQyxNQUFNLENBQUMsc0JBQXNCLEVBQUVILFdBQVcsR0FBOUMscUJBQUE7dUJBQUE7NEJBQUE7OEJBQUE7WUFBOEM7SUFDeEQ7QUFDRiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxMzM5MCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc3JjL3NlcnZlci9yZXNwb25zZS1jYWNoZS9pbmRleC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7XG4gIFJlc3BvbnNlQ2FjaGVFbnRyeSxcbiAgUmVzcG9uc2VHZW5lcmF0b3IsXG4gIFJlc3BvbnNlQ2FjaGVCYXNlLFxuICBJbmNyZW1lbnRhbFJlc3BvbnNlQ2FjaGVFbnRyeSxcbiAgSW5jcmVtZW50YWxSZXNwb25zZUNhY2hlLFxufSBmcm9tICcuL3R5cGVzJ1xuXG5pbXBvcnQgeyBCYXRjaGVyIH0gZnJvbSAnLi4vLi4vbGliL2JhdGNoZXInXG5pbXBvcnQgeyBzY2hlZHVsZU9uTmV4dFRpY2sgfSBmcm9tICcuLi8uLi9saWIvc2NoZWR1bGVyJ1xuaW1wb3J0IHtcbiAgZnJvbVJlc3BvbnNlQ2FjaGVFbnRyeSxcbiAgcm91dGVLaW5kVG9JbmNyZW1lbnRhbENhY2hlS2luZCxcbiAgdG9SZXNwb25zZUNhY2hlRW50cnksXG59IGZyb20gJy4vdXRpbHMnXG5pbXBvcnQgdHlwZSB7IFJvdXRlS2luZCB9IGZyb20gJy4uL3JvdXRlLWtpbmQnXG5cbmV4cG9ydCAqIGZyb20gJy4vdHlwZXMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlc3BvbnNlQ2FjaGUgaW1wbGVtZW50cyBSZXNwb25zZUNhY2hlQmFzZSB7XG4gIHByaXZhdGUgcmVhZG9ubHkgYmF0Y2hlciA9IEJhdGNoZXIuY3JlYXRlPFxuICAgIHsga2V5OiBzdHJpbmc7IGlzT25EZW1hbmRSZXZhbGlkYXRlOiBib29sZWFuIH0sXG4gICAgSW5jcmVtZW50YWxSZXNwb25zZUNhY2hlRW50cnkgfCBudWxsLFxuICAgIHN0cmluZ1xuICA+KHtcbiAgICAvLyBFbnN1cmUgb24tZGVtYW5kIHJldmFsaWRhdGUgZG9lc24ndCBibG9jayBub3JtYWwgcmVxdWVzdHMsIGl0IHNob3VsZCBiZVxuICAgIC8vIHNhZmUgdG8gcnVuIGFuIG9uLWRlbWFuZCByZXZhbGlkYXRlIGZvciB0aGUgc2FtZSBrZXkgYXMgYSBub3JtYWwgcmVxdWVzdC5cbiAgICBjYWNoZUtleUZuOiAoeyBrZXksIGlzT25EZW1hbmRSZXZhbGlkYXRlIH0pID0+XG4gICAgICBgJHtrZXl9LSR7aXNPbkRlbWFuZFJldmFsaWRhdGUgPyAnMScgOiAnMCd9YCxcbiAgICAvLyBXZSB3YWl0IHRvIGRvIGFueSBhc3luYyB3b3JrIHVudGlsIGFmdGVyIHdlJ3ZlIGFkZGVkIG91ciBwcm9taXNlIHRvXG4gICAgLy8gYHBlbmRpbmdSZXNwb25zZXNgIHRvIGVuc3VyZSB0aGF0IGFueSBhbnkgb3RoZXIgY2FsbHMgd2lsbCByZXVzZSB0aGVcbiAgICAvLyBzYW1lIHByb21pc2UgdW50aWwgd2UndmUgZnVsbHkgZmluaXNoZWQgb3VyIHdvcmsuXG4gICAgc2NoZWR1bGVyRm46IHNjaGVkdWxlT25OZXh0VGljayxcbiAgfSlcblxuICBwcml2YXRlIHByZXZpb3VzQ2FjaGVJdGVtPzoge1xuICAgIGtleTogc3RyaW5nXG4gICAgZW50cnk6IEluY3JlbWVudGFsUmVzcG9uc2VDYWNoZUVudHJ5IHwgbnVsbFxuICAgIGV4cGlyZXNBdDogbnVtYmVyXG4gIH1cblxuICAvLyB3ZSBkb24ndCB1c2UgbWluaW1hbF9tb2RlIG5hbWUgaGVyZSBhcyB0aGlzLm1pbmltYWxfbW9kZSBpc1xuICAvLyBzdGF0aWNhbGx5IHJlcGxhY2UgZm9yIHNlcnZlciBydW50aW1lcyBidXQgd2UgbmVlZCBpdCB0b1xuICAvLyBiZSBkeW5hbWljIGhlcmVcbiAgcHJpdmF0ZSBtaW5pbWFsX21vZGU/OiBib29sZWFuXG5cbiAgY29uc3RydWN0b3IobWluaW1hbF9tb2RlOiBib29sZWFuKSB7XG4gICAgdGhpcy5taW5pbWFsX21vZGUgPSBtaW5pbWFsX21vZGVcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBnZXQoXG4gICAga2V5OiBzdHJpbmcgfCBudWxsLFxuICAgIHJlc3BvbnNlR2VuZXJhdG9yOiBSZXNwb25zZUdlbmVyYXRvcixcbiAgICBjb250ZXh0OiB7XG4gICAgICByb3V0ZUtpbmQ6IFJvdXRlS2luZFxuICAgICAgaXNPbkRlbWFuZFJldmFsaWRhdGU/OiBib29sZWFuXG4gICAgICBpc1ByZWZldGNoPzogYm9vbGVhblxuICAgICAgaW5jcmVtZW50YWxDYWNoZTogSW5jcmVtZW50YWxSZXNwb25zZUNhY2hlXG4gICAgICBpc1JvdXRlUFBSRW5hYmxlZD86IGJvb2xlYW5cbiAgICAgIGlzRmFsbGJhY2s/OiBib29sZWFuXG4gICAgICB3YWl0VW50aWw/OiAocHJvbTogUHJvbWlzZTxhbnk+KSA9PiB2b2lkXG4gICAgfVxuICApOiBQcm9taXNlPFJlc3BvbnNlQ2FjaGVFbnRyeSB8IG51bGw+IHtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBrZXkgZm9yIHRoZSBjYWNoZSwgd2UgY2FuJ3QgcG9zc2libHkgbG9vayB0aGlzIHVwIGluIHRoZVxuICAgIC8vIGNhY2hlIHNvIGp1c3QgcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIHJlc3BvbnNlIGdlbmVyYXRvci5cbiAgICBpZiAoIWtleSkge1xuICAgICAgcmV0dXJuIHJlc3BvbnNlR2VuZXJhdG9yKHsgaGFzUmVzb2x2ZWQ6IGZhbHNlLCBwcmV2aW91c0NhY2hlRW50cnk6IG51bGwgfSlcbiAgICB9XG5cbiAgICBjb25zdCB7XG4gICAgICBpbmNyZW1lbnRhbENhY2hlLFxuICAgICAgaXNPbkRlbWFuZFJldmFsaWRhdGUgPSBmYWxzZSxcbiAgICAgIGlzRmFsbGJhY2sgPSBmYWxzZSxcbiAgICAgIGlzUm91dGVQUFJFbmFibGVkID0gZmFsc2UsXG4gICAgICB3YWl0VW50aWwsXG4gICAgfSA9IGNvbnRleHRcblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5iYXRjaGVyLmJhdGNoKFxuICAgICAgeyBrZXksIGlzT25EZW1hbmRSZXZhbGlkYXRlIH0sXG4gICAgICAoY2FjaGVLZXksIHJlc29sdmUpID0+IHtcbiAgICAgICAgY29uc3QgcHJvbSA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgLy8gV2Uga2VlcCB0aGUgcHJldmlvdXMgY2FjaGUgZW50cnkgYXJvdW5kIHRvIGxldmVyYWdlIHdoZW4gdGhlXG4gICAgICAgICAgLy8gaW5jcmVtZW50YWwgY2FjaGUgaXMgZGlzYWJsZWQgaW4gbWluaW1hbCBtb2RlLlxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMubWluaW1hbF9tb2RlICYmXG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzQ2FjaGVJdGVtPy5rZXkgPT09IGNhY2hlS2V5ICYmXG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzQ2FjaGVJdGVtLmV4cGlyZXNBdCA+IERhdGUubm93KClcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByZXZpb3VzQ2FjaGVJdGVtLmVudHJ5XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQ29lcmNlIHRoZSBraW5kSGludCBpbnRvIGEgZ2l2ZW4ga2luZCBmb3IgdGhlIGluY3JlbWVudGFsIGNhY2hlLlxuICAgICAgICAgIGNvbnN0IGtpbmQgPSByb3V0ZUtpbmRUb0luY3JlbWVudGFsQ2FjaGVLaW5kKGNvbnRleHQucm91dGVLaW5kKVxuXG4gICAgICAgICAgbGV0IHJlc29sdmVkID0gZmFsc2VcbiAgICAgICAgICBsZXQgY2FjaGVkUmVzcG9uc2U6IEluY3JlbWVudGFsUmVzcG9uc2VDYWNoZUVudHJ5IHwgbnVsbCA9IG51bGxcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY2FjaGVkUmVzcG9uc2UgPSAhdGhpcy5taW5pbWFsX21vZGVcbiAgICAgICAgICAgICAgPyBhd2FpdCBpbmNyZW1lbnRhbENhY2hlLmdldChrZXksIHtcbiAgICAgICAgICAgICAgICAgIGtpbmQsXG4gICAgICAgICAgICAgICAgICBpc1JvdXRlUFBSRW5hYmxlZDogY29udGV4dC5pc1JvdXRlUFBSRW5hYmxlZCxcbiAgICAgICAgICAgICAgICAgIGlzRmFsbGJhY2ssXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgOiBudWxsXG5cbiAgICAgICAgICAgIGlmIChjYWNoZWRSZXNwb25zZSAmJiAhaXNPbkRlbWFuZFJldmFsaWRhdGUpIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShjYWNoZWRSZXNwb25zZSlcbiAgICAgICAgICAgICAgcmVzb2x2ZWQgPSB0cnVlXG5cbiAgICAgICAgICAgICAgaWYgKCFjYWNoZWRSZXNwb25zZS5pc1N0YWxlIHx8IGNvbnRleHQuaXNQcmVmZXRjaCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBjYWNoZWQgdmFsdWUgaXMgc3RpbGwgdmFsaWQsIHNvIHdlIGRvbid0IG5lZWRcbiAgICAgICAgICAgICAgICAvLyB0byB1cGRhdGUgaXQgeWV0LlxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgY2FjaGVFbnRyeSA9IGF3YWl0IHJlc3BvbnNlR2VuZXJhdG9yKHtcbiAgICAgICAgICAgICAgaGFzUmVzb2x2ZWQ6IHJlc29sdmVkLFxuICAgICAgICAgICAgICBwcmV2aW91c0NhY2hlRW50cnk6IGNhY2hlZFJlc3BvbnNlLFxuICAgICAgICAgICAgICBpc1JldmFsaWRhdGluZzogdHJ1ZSxcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBjYWNoZSBlbnRyeSBjb3VsZG4ndCBiZSBnZW5lcmF0ZWQsIHdlIGRvbid0IHdhbnQgdG8gY2FjaGVcbiAgICAgICAgICAgIC8vIHRoZSByZXN1bHQuXG4gICAgICAgICAgICBpZiAoIWNhY2hlRW50cnkpIHtcbiAgICAgICAgICAgICAgLy8gVW5zZXQgdGhlIHByZXZpb3VzIGNhY2hlIGl0ZW0gaWYgaXQgd2FzIHNldC5cbiAgICAgICAgICAgICAgaWYgKHRoaXMubWluaW1hbF9tb2RlKSB0aGlzLnByZXZpb3VzQ2FjaGVJdGVtID0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVWYWx1ZSA9IGF3YWl0IGZyb21SZXNwb25zZUNhY2hlRW50cnkoe1xuICAgICAgICAgICAgICAuLi5jYWNoZUVudHJ5LFxuICAgICAgICAgICAgICBpc01pc3M6ICFjYWNoZWRSZXNwb25zZSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBpZiAoIXJlc29sdmVWYWx1ZSkge1xuICAgICAgICAgICAgICAvLyBVbnNldCB0aGUgcHJldmlvdXMgY2FjaGUgaXRlbSBpZiBpdCB3YXMgc2V0LlxuICAgICAgICAgICAgICBpZiAodGhpcy5taW5pbWFsX21vZGUpIHRoaXMucHJldmlvdXNDYWNoZUl0ZW0gPSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRm9yIG9uLWRlbWFuZCByZXZhbGlkYXRlIHdhaXQgdG8gcmVzb2x2ZSB1bnRpbCBjYWNoZSBpcyBzZXQuXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgcmVzb2x2ZSBub3cuXG4gICAgICAgICAgICBpZiAoIWlzT25EZW1hbmRSZXZhbGlkYXRlICYmICFyZXNvbHZlZCkge1xuICAgICAgICAgICAgICByZXNvbHZlKHJlc29sdmVWYWx1ZSlcbiAgICAgICAgICAgICAgcmVzb2x2ZWQgPSB0cnVlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFdlIHdhbnQgdG8gcGVyc2lzdCB0aGUgcmVzdWx0IG9ubHkgaWYgaXQgaGFzIGEgY2FjaGUgY29udHJvbCB2YWx1ZVxuICAgICAgICAgICAgLy8gZGVmaW5lZC5cbiAgICAgICAgICAgIGlmIChyZXNvbHZlVmFsdWUuY2FjaGVDb250cm9sKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLm1pbmltYWxfbW9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJldmlvdXNDYWNoZUl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgICBrZXk6IGNhY2hlS2V5LFxuICAgICAgICAgICAgICAgICAgZW50cnk6IHJlc29sdmVWYWx1ZSxcbiAgICAgICAgICAgICAgICAgIGV4cGlyZXNBdDogRGF0ZS5ub3coKSArIDEwMDAsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGF3YWl0IGluY3JlbWVudGFsQ2FjaGUuc2V0KGtleSwgcmVzb2x2ZVZhbHVlLnZhbHVlLCB7XG4gICAgICAgICAgICAgICAgICBjYWNoZUNvbnRyb2w6IHJlc29sdmVWYWx1ZS5jYWNoZUNvbnRyb2wsXG4gICAgICAgICAgICAgICAgICBpc1JvdXRlUFBSRW5hYmxlZCxcbiAgICAgICAgICAgICAgICAgIGlzRmFsbGJhY2ssXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZVZhbHVlXG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAvLyBXaGVuIGEgcGF0aCBpcyBlcnJvcmluZyB3ZSBhdXRvbWF0aWNhbGx5IHJlLXNldCB0aGUgZXhpc3RpbmcgY2FjaGVcbiAgICAgICAgICAgIC8vIHdpdGggbmV3IHJldmFsaWRhdGUgYW5kIGV4cGlyZSB0aW1lcyB0byBwcmV2ZW50IG5vbi1zdG9wIHJldHJ5aW5nLlxuICAgICAgICAgICAgaWYgKGNhY2hlZFJlc3BvbnNlPy5jYWNoZUNvbnRyb2wpIHtcbiAgICAgICAgICAgICAgY29uc3QgbmV3UmV2YWxpZGF0ZSA9IE1hdGgubWluKFxuICAgICAgICAgICAgICAgIE1hdGgubWF4KGNhY2hlZFJlc3BvbnNlLmNhY2hlQ29udHJvbC5yZXZhbGlkYXRlIHx8IDMsIDMpLFxuICAgICAgICAgICAgICAgIDMwXG4gICAgICAgICAgICAgIClcblxuICAgICAgICAgICAgICBjb25zdCBuZXdFeHBpcmUgPVxuICAgICAgICAgICAgICAgIGNhY2hlZFJlc3BvbnNlLmNhY2hlQ29udHJvbC5leHBpcmUgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgIDogTWF0aC5tYXgoXG4gICAgICAgICAgICAgICAgICAgICAgbmV3UmV2YWxpZGF0ZSArIDMsXG4gICAgICAgICAgICAgICAgICAgICAgY2FjaGVkUmVzcG9uc2UuY2FjaGVDb250cm9sLmV4cGlyZVxuICAgICAgICAgICAgICAgICAgICApXG5cbiAgICAgICAgICAgICAgYXdhaXQgaW5jcmVtZW50YWxDYWNoZS5zZXQoa2V5LCBjYWNoZWRSZXNwb25zZS52YWx1ZSwge1xuICAgICAgICAgICAgICAgIGNhY2hlQ29udHJvbDogeyByZXZhbGlkYXRlOiBuZXdSZXZhbGlkYXRlLCBleHBpcmU6IG5ld0V4cGlyZSB9LFxuICAgICAgICAgICAgICAgIGlzUm91dGVQUFJFbmFibGVkLFxuICAgICAgICAgICAgICAgIGlzRmFsbGJhY2ssXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFdoaWxlIHJldmFsaWRhdGluZyBpbiB0aGUgYmFja2dyb3VuZCB3ZSBjYW4ndCByZWplY3QgYXMgd2UgYWxyZWFkeVxuICAgICAgICAgICAgLy8gcmVzb2x2ZWQgdGhlIGNhY2hlIGVudHJ5IHNvIGxvZyB0aGUgZXJyb3IgaGVyZS5cbiAgICAgICAgICAgIGlmIChyZXNvbHZlZCkge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycilcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gV2UgaGF2ZW4ndCByZXNvbHZlZCB5ZXQsIHNvIGxldCdzIHRocm93IHRvIGluZGljYXRlIGFuIGVycm9yLlxuICAgICAgICAgICAgdGhyb3cgZXJyXG4gICAgICAgICAgfVxuICAgICAgICB9KSgpXG5cbiAgICAgICAgLy8gd2UgbmVlZCB0byBlbnN1cmUgYmFja2dyb3VuZCByZXZhbGlkYXRlcyBhcmVcbiAgICAgICAgLy8gcGFzc2VkIHRvIHdhaXRVbnRpbFxuICAgICAgICBpZiAod2FpdFVudGlsKSB7XG4gICAgICAgICAgd2FpdFVudGlsKHByb20pXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb21cbiAgICAgIH1cbiAgICApXG5cbiAgICByZXR1cm4gdG9SZXNwb25zZUNhY2hlRW50cnkocmVzcG9uc2UpXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJCYXRjaGVyIiwic2NoZWR1bGVPbk5leHRUaWNrIiwiZnJvbVJlc3BvbnNlQ2FjaGVFbnRyeSIsInJvdXRlS2luZFRvSW5jcmVtZW50YWxDYWNoZUtpbmQiLCJ0b1Jlc3BvbnNlQ2FjaGVFbnRyeSIsIlJlc3BvbnNlQ2FjaGUiLCJjb25zdHJ1Y3RvciIsIm1pbmltYWxfbW9kZSIsImJhdGNoZXIiLCJjcmVhdGUiLCJjYWNoZUtleUZuIiwia2V5IiwiaXNPbkRlbWFuZFJldmFsaWRhdGUiLCJzY2hlZHVsZXJGbiIsImdldCIsInJlc3BvbnNlR2VuZXJhdG9yIiwiY29udGV4dCIsImhhc1Jlc29sdmVkIiwicHJldmlvdXNDYWNoZUVudHJ5IiwiaW5jcmVtZW50YWxDYWNoZSIsImlzRmFsbGJhY2siLCJpc1JvdXRlUFBSRW5hYmxlZCIsIndhaXRVbnRpbCIsInJlc3BvbnNlIiwiYmF0Y2giLCJjYWNoZUtleSIsInJlc29sdmUiLCJwcm9tIiwicHJldmlvdXNDYWNoZUl0ZW0iLCJleHBpcmVzQXQiLCJEYXRlIiwibm93IiwiZW50cnkiLCJraW5kIiwicm91dGVLaW5kIiwicmVzb2x2ZWQiLCJjYWNoZWRSZXNwb25zZSIsImlzU3RhbGUiLCJpc1ByZWZldGNoIiwiY2FjaGVFbnRyeSIsImlzUmV2YWxpZGF0aW5nIiwidW5kZWZpbmVkIiwicmVzb2x2ZVZhbHVlIiwiaXNNaXNzIiwiY2FjaGVDb250cm9sIiwic2V0IiwidmFsdWUiLCJlcnIiLCJuZXdSZXZhbGlkYXRlIiwiTWF0aCIsIm1pbiIsIm1heCIsInJldmFsaWRhdGUiLCJuZXdFeHBpcmUiLCJleHBpcmUiLCJjb25zb2xlIiwiZXJyb3IiXSwibWFwcGluZ3MiOiI7OztBQVFBLFNBQVNBLE9BQU8sUUFBUSxvQkFBbUI7QUFDM0MsU0FBU0Msa0JBQWtCLFFBQVEsc0JBQXFCO0FBQ3hELFNBQ0VDLHNCQUFzQixFQUN0QkMsK0JBQStC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Q0FBQ1Q7d0JBQ2QsT0FBTztvQkFDVDtvQkFFQSxnRUFBZ0U7b0JBQ2hFLE1BQU1BO2dCQUNSO1lBQ0YsQ0FBQTtZQUVBLCtDQUErQztZQUMvQyxzQkFBc0I7WUFDdEIsSUFBSXpCLFdBQVc7Z0JBQ2JBLFVBQVVLO1lBQ1o7WUFDQSxPQUFPQTtRQUNUO1FBR0YsdUxBQU92Qix1QkFBQUEsRUFBcUJtQjtJQUM5QjtBQUNGIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDEzNTQ4LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zcmMvc2VydmVyL2xpYi9wYXRjaC1mZXRjaC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7XG4gIFdvcmtBc3luY1N0b3JhZ2UsXG4gIFdvcmtTdG9yZSxcbn0gZnJvbSAnLi4vYXBwLXJlbmRlci93b3JrLWFzeW5jLXN0b3JhZ2UuZXh0ZXJuYWwnXG5cbmltcG9ydCB7IEFwcFJlbmRlclNwYW4sIE5leHROb2RlU2VydmVyU3BhbiB9IGZyb20gJy4vdHJhY2UvY29uc3RhbnRzJ1xuaW1wb3J0IHsgZ2V0VHJhY2VyLCBTcGFuS2luZCB9IGZyb20gJy4vdHJhY2UvdHJhY2VyJ1xuaW1wb3J0IHtcbiAgQ0FDSEVfT05FX1lFQVIsXG4gIElORklOSVRFX0NBQ0hFLFxuICBORVhUX0NBQ0hFX1RBR19NQVhfSVRFTVMsXG4gIE5FWFRfQ0FDSEVfVEFHX01BWF9MRU5HVEgsXG59IGZyb20gJy4uLy4uL2xpYi9jb25zdGFudHMnXG5pbXBvcnQgeyBtYXJrQ3VycmVudFNjb3BlQXNEeW5hbWljIH0gZnJvbSAnLi4vYXBwLXJlbmRlci9keW5hbWljLXJlbmRlcmluZydcbmltcG9ydCB7IG1ha2VIYW5naW5nUHJvbWlzZSB9IGZyb20gJy4uL2R5bmFtaWMtcmVuZGVyaW5nLXV0aWxzJ1xuaW1wb3J0IHR5cGUgeyBGZXRjaE1ldHJpYyB9IGZyb20gJy4uL2Jhc2UtaHR0cCdcbmltcG9ydCB7IGNyZWF0ZURlZHVwZUZldGNoIH0gZnJvbSAnLi9kZWR1cGUtZmV0Y2gnXG5pbXBvcnQgdHlwZSB7IFdvcmtVbml0QXN5bmNTdG9yYWdlIH0gZnJvbSAnLi4vYXBwLXJlbmRlci93b3JrLXVuaXQtYXN5bmMtc3RvcmFnZS5leHRlcm5hbCdcbmltcG9ydCB7XG4gIENhY2hlZFJvdXRlS2luZCxcbiAgSW5jcmVtZW50YWxDYWNoZUtpbmQsXG4gIHR5cGUgQ2FjaGVkRmV0Y2hEYXRhLFxufSBmcm9tICcuLi9yZXNwb25zZS1jYWNoZSdcbmltcG9ydCB7IHdhaXRBdExlYXN0T25lUmVhY3RSZW5kZXJUYXNrIH0gZnJvbSAnLi4vLi4vbGliL3NjaGVkdWxlcidcbmltcG9ydCB7IGNsb25lUmVzcG9uc2UgfSBmcm9tICcuL2Nsb25lLXJlc3BvbnNlJ1xuXG5jb25zdCBpc0VkZ2VSdW50aW1lID0gcHJvY2Vzcy5lbnYuTkVYVF9SVU5USU1FID09PSAnZWRnZSdcblxudHlwZSBGZXRjaGVyID0gdHlwZW9mIGZldGNoXG5cbnR5cGUgUGF0Y2hlZEZldGNoZXIgPSBGZXRjaGVyICYge1xuICByZWFkb25seSBfX25leHRQYXRjaGVkOiB0cnVlXG4gIHJlYWRvbmx5IF9fbmV4dEdldFN0YXRpY1N0b3JlOiAoKSA9PiBXb3JrQXN5bmNTdG9yYWdlXG4gIHJlYWRvbmx5IF9uZXh0T3JpZ2luYWxGZXRjaDogRmV0Y2hlclxufVxuXG5leHBvcnQgY29uc3QgTkVYVF9QQVRDSF9TWU1CT0wgPSBTeW1ib2wuZm9yKCduZXh0LXBhdGNoJylcblxuZnVuY3Rpb24gaXNGZXRjaFBhdGNoZWQoKSB7XG4gIHJldHVybiAoZ2xvYmFsVGhpcyBhcyBSZWNvcmQ8c3ltYm9sLCB1bmtub3duPilbTkVYVF9QQVRDSF9TWU1CT0xdID09PSB0cnVlXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVJldmFsaWRhdGUoXG4gIHJldmFsaWRhdGVWYWw6IHVua25vd24sXG4gIHJvdXRlOiBzdHJpbmdcbik6IHVuZGVmaW5lZCB8IG51bWJlciB7XG4gIHRyeSB7XG4gICAgbGV0IG5vcm1hbGl6ZWRSZXZhbGlkYXRlOiBudW1iZXIgfCB1bmRlZmluZWQgPSB1bmRlZmluZWRcblxuICAgIGlmIChyZXZhbGlkYXRlVmFsID09PSBmYWxzZSkge1xuICAgICAgbm9ybWFsaXplZFJldmFsaWRhdGUgPSBJTkZJTklURV9DQUNIRVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICB0eXBlb2YgcmV2YWxpZGF0ZVZhbCA9PT0gJ251bWJlcicgJiZcbiAgICAgICFpc05hTihyZXZhbGlkYXRlVmFsKSAmJlxuICAgICAgcmV2YWxpZGF0ZVZhbCA+IC0xXG4gICAgKSB7XG4gICAgICBub3JtYWxpemVkUmV2YWxpZGF0ZSA9IHJldmFsaWRhdGVWYWxcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiByZXZhbGlkYXRlVmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgSW52YWxpZCByZXZhbGlkYXRlIHZhbHVlIFwiJHtyZXZhbGlkYXRlVmFsfVwiIG9uIFwiJHtyb3V0ZX1cIiwgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIgb3IgZmFsc2VgXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBub3JtYWxpemVkUmV2YWxpZGF0ZVxuICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgIC8vIGhhbmRsZSBjbGllbnQgY29tcG9uZW50IGVycm9yIGZyb20gYXR0ZW1wdGluZyB0byBjaGVjayByZXZhbGlkYXRlIHZhbHVlXG4gICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yICYmIGVyci5tZXNzYWdlLmluY2x1ZGVzKCdJbnZhbGlkIHJldmFsaWRhdGUnKSkge1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVUYWdzKHRhZ3M6IGFueVtdLCBkZXNjcmlwdGlvbjogc3RyaW5nKSB7XG4gIGNvbnN0IHZhbGlkVGFnczogc3RyaW5nW10gPSBbXVxuICBjb25zdCBpbnZhbGlkVGFnczogQXJyYXk8e1xuICAgIHRhZzogYW55XG4gICAgcmVhc29uOiBzdHJpbmdcbiAgfT4gPSBbXVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGFncy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHRhZyA9IHRhZ3NbaV1cblxuICAgIGlmICh0eXBlb2YgdGFnICE9PSAnc3RyaW5nJykge1xuICAgICAgaW52YWxpZFRhZ3MucHVzaCh7IHRhZywgcmVhc29uOiAnaW52YWxpZCB0eXBlLCBtdXN0IGJlIGEgc3RyaW5nJyB9KVxuICAgIH0gZWxzZSBpZiAodGFnLmxlbmd0aCA+IE5FWFRfQ0FDSEVfVEFHX01BWF9MRU5HVEgpIHtcbiAgICAgIGludmFsaWRUYWdzLnB1c2goe1xuICAgICAgICB0YWcsXG4gICAgICAgIHJlYXNvbjogYGV4Y2VlZGVkIG1heCBsZW5ndGggb2YgJHtORVhUX0NBQ0hFX1RBR19NQVhfTEVOR1RIfWAsXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICB2YWxpZFRhZ3MucHVzaCh0YWcpXG4gICAgfVxuXG4gICAgaWYgKHZhbGlkVGFncy5sZW5ndGggPiBORVhUX0NBQ0hFX1RBR19NQVhfSVRFTVMpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYFdhcm5pbmc6IGV4Y2VlZGVkIG1heCB0YWcgY291bnQgZm9yICR7ZGVzY3JpcHRpb259LCBkcm9wcGVkIHRhZ3M6YCxcbiAgICAgICAgdGFncy5zbGljZShpKS5qb2luKCcsICcpXG4gICAgICApXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmIChpbnZhbGlkVGFncy5sZW5ndGggPiAwKSB7XG4gICAgY29uc29sZS53YXJuKGBXYXJuaW5nOiBpbnZhbGlkIHRhZ3MgcGFzc2VkIHRvICR7ZGVzY3JpcHRpb259OiBgKVxuXG4gICAgZm9yIChjb25zdCB7IHRhZywgcmVhc29uIH0gb2YgaW52YWxpZFRhZ3MpIHtcbiAgICAgIGNvbnNvbGUubG9nKGB0YWc6IFwiJHt0YWd9XCIgJHtyZWFzb259YClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbGlkVGFnc1xufVxuXG5mdW5jdGlvbiB0cmFja0ZldGNoTWV0cmljKFxuICB3b3JrU3RvcmU6IFdvcmtTdG9yZSxcbiAgY3R4OiBPbWl0PEZldGNoTWV0cmljLCAnZW5kJyB8ICdpZHgnPlxuKSB7XG4gIC8vIElmIHRoZSBzdGF0aWMgZ2VuZXJhdGlvbiBzdG9yZSBpcyBub3QgYXZhaWxhYmxlLCB3ZSBjYW4ndCB0cmFjayB0aGUgZmV0Y2hcbiAgaWYgKCF3b3JrU3RvcmUpIHJldHVyblxuICBpZiAod29ya1N0b3JlLnJlcXVlc3RFbmRlZFN0YXRlPy5lbmRlZCkgcmV0dXJuXG5cbiAgY29uc3QgaXNEZWJ1Z0J1aWxkID1cbiAgICAoISFwcm9jZXNzLmVudi5ORVhUX0RFQlVHX0JVSUxEIHx8XG4gICAgICBwcm9jZXNzLmVudi5ORVhUX1NTR19GRVRDSF9NRVRSSUNTID09PSAnMScpICYmXG4gICAgd29ya1N0b3JlLmlzU3RhdGljR2VuZXJhdGlvblxuICBjb25zdCBpc0RldmVsb3BtZW50ID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCdcblxuICBpZiAoXG4gICAgLy8gVGhlIG9ubHkgdGltZSB3ZSB3YW50IHRvIHRyYWNrIGZldGNoIG1ldHJpY3Mgb3V0c2lkZSBvZiBkZXZlbG9wbWVudCBpcyB3aGVuXG4gICAgLy8gd2UgYXJlIHBlcmZvcm1pbmcgYSBzdGF0aWMgZ2VuZXJhdGlvbiAmIHdlIGFyZSBpbiBkZWJ1ZyBtb2RlLlxuICAgICFpc0RlYnVnQnVpbGQgJiZcbiAgICAhaXNEZXZlbG9wbWVudFxuICApIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHdvcmtTdG9yZS5mZXRjaE1ldHJpY3MgPz89IFtdXG5cbiAgd29ya1N0b3JlLmZldGNoTWV0cmljcy5wdXNoKHtcbiAgICAuLi5jdHgsXG4gICAgZW5kOiBwZXJmb3JtYW5jZS50aW1lT3JpZ2luICsgcGVyZm9ybWFuY2Uubm93KCksXG4gICAgaWR4OiB3b3JrU3RvcmUubmV4dEZldGNoSWQgfHwgMCxcbiAgfSlcbn1cblxuaW50ZXJmYWNlIFBhdGNoYWJsZU1vZHVsZSB7XG4gIHdvcmtBc3luY1N0b3JhZ2U6IFdvcmtBc3luY1N0b3JhZ2VcbiAgd29ya1VuaXRBc3luY1N0b3JhZ2U6IFdvcmtVbml0QXN5bmNTdG9yYWdlXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQYXRjaGVkRmV0Y2hlcihcbiAgb3JpZ2luRmV0Y2g6IEZldGNoZXIsXG4gIHsgd29ya0FzeW5jU3RvcmFnZSwgd29ya1VuaXRBc3luY1N0b3JhZ2UgfTogUGF0Y2hhYmxlTW9kdWxlXG4pOiBQYXRjaGVkRmV0Y2hlciB7XG4gIC8vIENyZWF0ZSB0aGUgcGF0Y2hlZCBmZXRjaCBmdW5jdGlvbi5cbiAgY29uc3QgcGF0Y2hlZCA9IGFzeW5jIGZ1bmN0aW9uIGZldGNoKFxuICAgIGlucHV0OiBSZXF1ZXN0SW5mbyB8IFVSTCxcbiAgICBpbml0OiBSZXF1ZXN0SW5pdCB8IHVuZGVmaW5lZFxuICApOiBQcm9taXNlPFJlc3BvbnNlPiB7XG4gICAgbGV0IHVybDogVVJMIHwgdW5kZWZpbmVkXG4gICAgdHJ5IHtcbiAgICAgIHVybCA9IG5ldyBVUkwoaW5wdXQgaW5zdGFuY2VvZiBSZXF1ZXN0ID8gaW5wdXQudXJsIDogaW5wdXQpXG4gICAgICB1cmwudXNlcm5hbWUgPSAnJ1xuICAgICAgdXJsLnBhc3N3b3JkID0gJydcbiAgICB9IGNhdGNoIHtcbiAgICAgIC8vIEVycm9yIGNhdXNlZCBieSBtYWxmb3JtZWQgVVJMIHNob3VsZCBiZSBoYW5kbGVkIGJ5IG5hdGl2ZSBmZXRjaFxuICAgICAgdXJsID0gdW5kZWZpbmVkXG4gICAgfVxuICAgIGNvbnN0IGZldGNoVXJsID0gdXJsPy5ocmVmID8/ICcnXG4gICAgY29uc3QgbWV0aG9kID0gaW5pdD8ubWV0aG9kPy50b1VwcGVyQ2FzZSgpIHx8ICdHRVQnXG5cbiAgICAvLyBEbyBjcmVhdGUgYSBuZXcgc3BhbiB0cmFjZSBmb3IgaW50ZXJuYWwgZmV0Y2hlcyBpbiB0aGVcbiAgICAvLyBub24tdmVyYm9zZSBtb2RlLlxuICAgIGNvbnN0IGlzSW50ZXJuYWwgPSAoaW5pdD8ubmV4dCBhcyBhbnkpPy5pbnRlcm5hbCA9PT0gdHJ1ZVxuICAgIGNvbnN0IGhpZGVTcGFuID0gcHJvY2Vzcy5lbnYuTkVYVF9PVEVMX0ZFVENIX0RJU0FCTEVEID09PSAnMSdcbiAgICAvLyBXZSBkb24ndCB0cmFjayBmZXRjaCBtZXRyaWNzIGZvciBpbnRlcm5hbCBmZXRjaGVzXG4gICAgLy8gc28gaXQncyBub3QgY3JpdGljYWwgdGhhdCB3ZSBoYXZlIGEgc3RhcnQgdGltZSwgYXMgaXQgd29uJ3QgYmUgcmVjb3JkZWQuXG4gICAgLy8gVGhpcyBpcyB0byB3b3JrYXJvdW5kIGEgZmxha3kgaXNzdWUgd2hlcmUgcGVyZm9ybWFuY2UgQVBJcyBtaWdodFxuICAgIC8vIG5vdCBiZSBhdmFpbGFibGUgYW5kIHdpbGwgcmVxdWlyZSBmb2xsb3ctdXAgaW52ZXN0aWdhdGlvbi5cbiAgICBjb25zdCBmZXRjaFN0YXJ0OiBudW1iZXIgfCB1bmRlZmluZWQgPSBpc0ludGVybmFsXG4gICAgICA/IHVuZGVmaW5lZFxuICAgICAgOiBwZXJmb3JtYW5jZS50aW1lT3JpZ2luICsgcGVyZm9ybWFuY2Uubm93KClcblxuICAgIGNvbnN0IHdvcmtTdG9yZSA9IHdvcmtBc3luY1N0b3JhZ2UuZ2V0U3RvcmUoKVxuICAgIGNvbnN0IHdvcmtVbml0U3RvcmUgPSB3b3JrVW5pdEFzeW5jU3RvcmFnZS5nZXRTdG9yZSgpXG5cbiAgICAvLyBEdXJpbmcgc3RhdGljIGdlbmVyYXRpb24gd2UgdHJhY2sgY2FjaGUgcmVhZHMgc28gd2UgY2FuIHJlYXNvbiBhYm91dCB3aGVuIHRoZXkgZmlsbFxuICAgIGxldCBjYWNoZVNpZ25hbCA9XG4gICAgICB3b3JrVW5pdFN0b3JlICYmIHdvcmtVbml0U3RvcmUudHlwZSA9PT0gJ3ByZXJlbmRlcidcbiAgICAgICAgPyB3b3JrVW5pdFN0b3JlLmNhY2hlU2lnbmFsXG4gICAgICAgIDogbnVsbFxuICAgIGlmIChjYWNoZVNpZ25hbCkge1xuICAgICAgY2FjaGVTaWduYWwuYmVnaW5SZWFkKClcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBnZXRUcmFjZXIoKS50cmFjZShcbiAgICAgIGlzSW50ZXJuYWwgPyBOZXh0Tm9kZVNlcnZlclNwYW4uaW50ZXJuYWxGZXRjaCA6IEFwcFJlbmRlclNwYW4uZmV0Y2gsXG4gICAgICB7XG4gICAgICAgIGhpZGVTcGFuLFxuICAgICAgICBraW5kOiBTcGFuS2luZC5DTElFTlQsXG4gICAgICAgIHNwYW5OYW1lOiBbJ2ZldGNoJywgbWV0aG9kLCBmZXRjaFVybF0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oJyAnKSxcbiAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICdodHRwLnVybCc6IGZldGNoVXJsLFxuICAgICAgICAgICdodHRwLm1ldGhvZCc6IG1ldGhvZCxcbiAgICAgICAgICAnbmV0LnBlZXIubmFtZSc6IHVybD8uaG9zdG5hbWUsXG4gICAgICAgICAgJ25ldC5wZWVyLnBvcnQnOiB1cmw/LnBvcnQgfHwgdW5kZWZpbmVkLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIGFzeW5jICgpID0+IHtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhbiBpbnRlcm5hbCBmZXRjaCwgd2Ugc2hvdWxkIG5vdCBkbyBhbnkgc3BlY2lhbCB0cmVhdG1lbnQuXG4gICAgICAgIGlmIChpc0ludGVybmFsKSB7XG4gICAgICAgICAgcmV0dXJuIG9yaWdpbkZldGNoKGlucHV0LCBpbml0KVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlIHdvcmtTdG9yZSBpcyBub3QgYXZhaWxhYmxlLCB3ZSBjYW4ndCBkbyBhbnlcbiAgICAgICAgLy8gc3BlY2lhbCB0cmVhdG1lbnQgb2YgZmV0Y2gsIHRoZXJlZm9yZSBmYWxsYmFjayB0byB0aGUgb3JpZ2luYWxcbiAgICAgICAgLy8gZmV0Y2ggaW1wbGVtZW50YXRpb24uXG4gICAgICAgIGlmICghd29ya1N0b3JlKSB7XG4gICAgICAgICAgcmV0dXJuIG9yaWdpbkZldGNoKGlucHV0LCBpbml0KVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2Ugc2hvdWxkIGFsc28gZmFsbGJhY2sgdG8gdGhlIG9yaWdpbmFsIGZldGNoIGltcGxlbWVudGF0aW9uIGlmIHdlXG4gICAgICAgIC8vIGFyZSBpbiBkcmFmdCBtb2RlLCBpdCBkb2VzIG5vdCBjb25zdGl0dXRlIGEgc3RhdGljIGdlbmVyYXRpb24uXG4gICAgICAgIGlmICh3b3JrU3RvcmUuaXNEcmFmdE1vZGUpIHtcbiAgICAgICAgICByZXR1cm4gb3JpZ2luRmV0Y2goaW5wdXQsIGluaXQpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpc1JlcXVlc3RJbnB1dCA9XG4gICAgICAgICAgaW5wdXQgJiZcbiAgICAgICAgICB0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgdHlwZW9mIChpbnB1dCBhcyBSZXF1ZXN0KS5tZXRob2QgPT09ICdzdHJpbmcnXG5cbiAgICAgICAgY29uc3QgZ2V0UmVxdWVzdE1ldGEgPSAoZmllbGQ6IHN0cmluZykgPT4ge1xuICAgICAgICAgIC8vIElmIHJlcXVlc3QgaW5wdXQgaXMgcHJlc2VudCBidXQgaW5pdCBpcyBub3QsIHJldHJpZXZlIGZyb20gaW5wdXQgZmlyc3QuXG4gICAgICAgICAgY29uc3QgdmFsdWUgPSAoaW5pdCBhcyBhbnkpPy5bZmllbGRdXG4gICAgICAgICAgcmV0dXJuIHZhbHVlIHx8IChpc1JlcXVlc3RJbnB1dCA/IChpbnB1dCBhcyBhbnkpW2ZpZWxkXSA6IG51bGwpXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZmluYWxSZXZhbGlkYXRlOiBudW1iZXIgfCB1bmRlZmluZWQgPSB1bmRlZmluZWRcbiAgICAgICAgY29uc3QgZ2V0TmV4dEZpZWxkID0gKGZpZWxkOiAncmV2YWxpZGF0ZScgfCAndGFncycpID0+IHtcbiAgICAgICAgICByZXR1cm4gdHlwZW9mIGluaXQ/Lm5leHQ/LltmaWVsZF0gIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICA/IGluaXQ/Lm5leHQ/LltmaWVsZF1cbiAgICAgICAgICAgIDogaXNSZXF1ZXN0SW5wdXRcbiAgICAgICAgICAgICAgPyAoaW5wdXQgYXMgYW55KS5uZXh0Py5bZmllbGRdXG4gICAgICAgICAgICAgIDogdW5kZWZpbmVkXG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVxdWVzdEluaXQgZG9lc24ndCBrZWVwIGV4dHJhIGZpZWxkcyBlLmcuIG5leHQgc28gaXQnc1xuICAgICAgICAvLyBvbmx5IGF2YWlsYWJsZSBpZiBpbml0IGlzIHVzZWQgc2VwYXJhdGVcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxGZXRjaFJldmFsaWRhdGUgPSBnZXROZXh0RmllbGQoJ3JldmFsaWRhdGUnKVxuICAgICAgICBsZXQgY3VycmVudEZldGNoUmV2YWxpZGF0ZSA9IG9yaWdpbmFsRmV0Y2hSZXZhbGlkYXRlXG4gICAgICAgIGNvbnN0IHRhZ3M6IHN0cmluZ1tdID0gdmFsaWRhdGVUYWdzKFxuICAgICAgICAgIGdldE5leHRGaWVsZCgndGFncycpIHx8IFtdLFxuICAgICAgICAgIGBmZXRjaCAke2lucHV0LnRvU3RyaW5nKCl9YFxuICAgICAgICApXG5cbiAgICAgICAgY29uc3QgcmV2YWxpZGF0ZVN0b3JlID1cbiAgICAgICAgICB3b3JrVW5pdFN0b3JlICYmXG4gICAgICAgICAgKHdvcmtVbml0U3RvcmUudHlwZSA9PT0gJ2NhY2hlJyB8fFxuICAgICAgICAgICAgd29ya1VuaXRTdG9yZS50eXBlID09PSAncHJlcmVuZGVyJyB8fFxuICAgICAgICAgICAgLy8gVE9ETzogc3RvcCBhY2N1bXVsYXRpbmcgdGFncyBpbiBjbGllbnQgcHJlcmVuZGVyXG4gICAgICAgICAgICB3b3JrVW5pdFN0b3JlLnR5cGUgPT09ICdwcmVyZW5kZXItY2xpZW50JyB8fFxuICAgICAgICAgICAgd29ya1VuaXRTdG9yZS50eXBlID09PSAncHJlcmVuZGVyLXBwcicgfHxcbiAgICAgICAgICAgIHdvcmtVbml0U3RvcmUudHlwZSA9PT0gJ3ByZXJlbmRlci1sZWdhY3knKVxuICAgICAgICAgICAgPyB3b3JrVW5pdFN0b3JlXG4gICAgICAgICAgICA6IHVuZGVmaW5lZFxuXG4gICAgICAgIGlmIChyZXZhbGlkYXRlU3RvcmUpIHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0YWdzKSkge1xuICAgICAgICAgICAgLy8gQ29sbGVjdCB0YWdzIG9udG8gcGFyZW50IGNhY2hlcyBvciBwYXJlbnQgcHJlcmVuZGVycy5cbiAgICAgICAgICAgIGNvbnN0IGNvbGxlY3RlZFRhZ3MgPVxuICAgICAgICAgICAgICByZXZhbGlkYXRlU3RvcmUudGFncyA/PyAocmV2YWxpZGF0ZVN0b3JlLnRhZ3MgPSBbXSlcbiAgICAgICAgICAgIGZvciAoY29uc3QgdGFnIG9mIHRhZ3MpIHtcbiAgICAgICAgICAgICAgaWYgKCFjb2xsZWN0ZWRUYWdzLmluY2x1ZGVzKHRhZykpIHtcbiAgICAgICAgICAgICAgICBjb2xsZWN0ZWRUYWdzLnB1c2godGFnKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaW1wbGljaXRUYWdzID0gd29ya1VuaXRTdG9yZT8uaW1wbGljaXRUYWdzXG5cbiAgICAgICAgLy8gSW5zaWRlIHVuc3RhYmxlLWNhY2hlIHdlIHRyZWF0IGl0IHRoZSBzYW1lIGFzIGZvcmNlLW5vLXN0b3JlIG9uIHRoZVxuICAgICAgICAvLyBwYWdlLlxuICAgICAgICBjb25zdCBwYWdlRmV0Y2hDYWNoZU1vZGUgPVxuICAgICAgICAgIHdvcmtVbml0U3RvcmUgJiYgd29ya1VuaXRTdG9yZS50eXBlID09PSAndW5zdGFibGUtY2FjaGUnXG4gICAgICAgICAgICA/ICdmb3JjZS1uby1zdG9yZSdcbiAgICAgICAgICAgIDogd29ya1N0b3JlLmZldGNoQ2FjaGVcblxuICAgICAgICBjb25zdCBpc1VzaW5nTm9TdG9yZSA9ICEhd29ya1N0b3JlLmlzVW5zdGFibGVOb1N0b3JlXG5cbiAgICAgICAgbGV0IGN1cnJlbnRGZXRjaENhY2hlQ29uZmlnID0gZ2V0UmVxdWVzdE1ldGEoJ2NhY2hlJylcbiAgICAgICAgbGV0IGNhY2hlUmVhc29uID0gJydcbiAgICAgICAgbGV0IGNhY2hlV2FybmluZzogc3RyaW5nIHwgdW5kZWZpbmVkXG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIHR5cGVvZiBjdXJyZW50RmV0Y2hDYWNoZUNvbmZpZyA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICB0eXBlb2YgY3VycmVudEZldGNoUmV2YWxpZGF0ZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIHJldmFsaWRhdGUgdmFsdWUgY29uZmxpY3RzIHdpdGggdGhlIGNhY2hlIHZhbHVlLCB3ZSBzaG91bGQgd2FybiB0aGUgdXNlciBhbmQgdW5zZXQgdGhlIGNvbmZsaWN0aW5nIHZhbHVlcy5cbiAgICAgICAgICBjb25zdCBpc0NvbmZsaWN0aW5nUmV2YWxpZGF0ZSA9XG4gICAgICAgICAgICAvLyByZXZhbGlkYXRlOiAwIGFuZCBjYWNoZTogZm9yY2UtY2FjaGVcbiAgICAgICAgICAgIChjdXJyZW50RmV0Y2hDYWNoZUNvbmZpZyA9PT0gJ2ZvcmNlLWNhY2hlJyAmJlxuICAgICAgICAgICAgICBjdXJyZW50RmV0Y2hSZXZhbGlkYXRlID09PSAwKSB8fFxuICAgICAgICAgICAgLy8gcmV2YWxpZGF0ZTogPjAgb3IgcmV2YWxpZGF0ZTogZmFsc2UgYW5kIGNhY2hlOiBuby1zdG9yZVxuICAgICAgICAgICAgKGN1cnJlbnRGZXRjaENhY2hlQ29uZmlnID09PSAnbm8tc3RvcmUnICYmXG4gICAgICAgICAgICAgIChjdXJyZW50RmV0Y2hSZXZhbGlkYXRlID4gMCB8fCBjdXJyZW50RmV0Y2hSZXZhbGlkYXRlID09PSBmYWxzZSkpXG5cbiAgICAgICAgICBpZiAoaXNDb25mbGljdGluZ1JldmFsaWRhdGUpIHtcbiAgICAgICAgICAgIGNhY2hlV2FybmluZyA9IGBTcGVjaWZpZWQgXCJjYWNoZTogJHtjdXJyZW50RmV0Y2hDYWNoZUNvbmZpZ31cIiBhbmQgXCJyZXZhbGlkYXRlOiAke2N1cnJlbnRGZXRjaFJldmFsaWRhdGV9XCIsIG9ubHkgb25lIHNob3VsZCBiZSBzcGVjaWZpZWQuYFxuICAgICAgICAgICAgY3VycmVudEZldGNoQ2FjaGVDb25maWcgPSB1bmRlZmluZWRcbiAgICAgICAgICAgIGN1cnJlbnRGZXRjaFJldmFsaWRhdGUgPSB1bmRlZmluZWRcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBoYXNFeHBsaWNpdEZldGNoQ2FjaGVPcHRPdXQgPVxuICAgICAgICAgIC8vIGZldGNoIGNvbmZpZyBpdHNlbGYgc2lnbmFscyBub3QgdG8gY2FjaGVcbiAgICAgICAgICBjdXJyZW50RmV0Y2hDYWNoZUNvbmZpZyA9PT0gJ25vLWNhY2hlJyB8fFxuICAgICAgICAgIGN1cnJlbnRGZXRjaENhY2hlQ29uZmlnID09PSAnbm8tc3RvcmUnIHx8XG4gICAgICAgICAgLy8gdGhlIGZldGNoIGlzbid0IGV4cGxpY2l0bHkgY2FjaGluZyBhbmQgdGhlIHNlZ21lbnQgbGV2ZWwgY2FjaGUgY29uZmlnIHNpZ25hbHMgbm90IHRvIGNhY2hlXG4gICAgICAgICAgLy8gbm90ZTogYHBhZ2VGZXRjaENhY2hlTW9kZWAgaXMgYWxzbyBzZXQgYnkgYmVpbmcgaW4gYW4gdW5zdGFibGVfY2FjaGUgY29udGV4dC5cbiAgICAgICAgICBwYWdlRmV0Y2hDYWNoZU1vZGUgPT09ICdmb3JjZS1uby1zdG9yZScgfHxcbiAgICAgICAgICBwYWdlRmV0Y2hDYWNoZU1vZGUgPT09ICdvbmx5LW5vLXN0b3JlJ1xuXG4gICAgICAgIC8vIElmIG5vIGV4cGxpY2l0IGZldGNoIGNhY2hlIG1vZGUgaXMgc2V0LCBidXQgZHluYW1pYyA9IGBmb3JjZS1keW5hbWljYCBpcyBzZXQsXG4gICAgICAgIC8vIHdlIHNob3VsZG4ndCBjb25zaWRlciBjYWNoaW5nIHRoZSBmZXRjaC4gVGhpcyBpcyBiZWNhdXNlIHRoZSBgZHluYW1pY2AgY2FjaGVcbiAgICAgICAgLy8gaXMgY29uc2lkZXJlZCBhIFwidG9wLWxldmVsXCIgY2FjaGUgbW9kZSwgd2hlcmVhcyBzb21ldGhpbmcgbGlrZSBgZmV0Y2hDYWNoZWAgaXMgbW9yZVxuICAgICAgICAvLyBmaW5lLWdyYWluZWQuIFRvcC1sZXZlbCBtb2RlcyBhcmUgcmVzcG9uc2libGUgZm9yIHNldHRpbmcgcmVhc29uYWJsZSBkZWZhdWx0cyBmb3IgdGhlXG4gICAgICAgIC8vIG90aGVyIGNvbmZpZ3VyYXRpb25zLlxuICAgICAgICBjb25zdCBub0ZldGNoQ29uZmlnQW5kRm9yY2VEeW5hbWljID1cbiAgICAgICAgICAhcGFnZUZldGNoQ2FjaGVNb2RlICYmXG4gICAgICAgICAgIWN1cnJlbnRGZXRjaENhY2hlQ29uZmlnICYmXG4gICAgICAgICAgIWN1cnJlbnRGZXRjaFJldmFsaWRhdGUgJiZcbiAgICAgICAgICB3b3JrU3RvcmUuZm9yY2VEeW5hbWljXG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIC8vIGZvcmNlLWNhY2hlIHdhcyBzcGVjaWZpZWQgd2l0aG91dCBhIHJldmFsaWRhdGUgdmFsdWUuIFdlIHNldCB0aGUgcmV2YWxpZGF0ZSB2YWx1ZSB0byBmYWxzZVxuICAgICAgICAgIC8vIHdoaWNoIHdpbGwgc2lnbmFsIHRoZSBjYWNoZSB0byBub3QgcmV2YWxpZGF0ZVxuICAgICAgICAgIGN1cnJlbnRGZXRjaENhY2hlQ29uZmlnID09PSAnZm9yY2UtY2FjaGUnICYmXG4gICAgICAgICAgdHlwZW9mIGN1cnJlbnRGZXRjaFJldmFsaWRhdGUgPT09ICd1bmRlZmluZWQnXG4gICAgICAgICkge1xuICAgICAgICAgIGN1cnJlbnRGZXRjaFJldmFsaWRhdGUgPSBmYWxzZVxuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIGhhc0V4cGxpY2l0RmV0Y2hDYWNoZU9wdE91dCB8fFxuICAgICAgICAgIG5vRmV0Y2hDb25maWdBbmRGb3JjZUR5bmFtaWNcbiAgICAgICAgKSB7XG4gICAgICAgICAgY3VycmVudEZldGNoUmV2YWxpZGF0ZSA9IDBcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBjdXJyZW50RmV0Y2hDYWNoZUNvbmZpZyA9PT0gJ25vLWNhY2hlJyB8fFxuICAgICAgICAgIGN1cnJlbnRGZXRjaENhY2hlQ29uZmlnID09PSAnbm8tc3RvcmUnXG4gICAgICAgICkge1xuICAgICAgICAgIGNhY2hlUmVhc29uID0gYGNhY2hlOiAke2N1cnJlbnRGZXRjaENhY2hlQ29uZmlnfWBcbiAgICAgICAgfVxuXG4gICAgICAgIGZpbmFsUmV2YWxpZGF0ZSA9IHZhbGlkYXRlUmV2YWxpZGF0ZShcbiAgICAgICAgICBjdXJyZW50RmV0Y2hSZXZhbGlkYXRlLFxuICAgICAgICAgIHdvcmtTdG9yZS5yb3V0ZVxuICAgICAgICApXG5cbiAgICAgICAgY29uc3QgX2hlYWRlcnMgPSBnZXRSZXF1ZXN0TWV0YSgnaGVhZGVycycpXG4gICAgICAgIGNvbnN0IGluaXRIZWFkZXJzOiBIZWFkZXJzID1cbiAgICAgICAgICB0eXBlb2YgX2hlYWRlcnM/LmdldCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBfaGVhZGVyc1xuICAgICAgICAgICAgOiBuZXcgSGVhZGVycyhfaGVhZGVycyB8fCB7fSlcblxuICAgICAgICBjb25zdCBoYXNVbkNhY2hlYWJsZUhlYWRlciA9XG4gICAgICAgICAgaW5pdEhlYWRlcnMuZ2V0KCdhdXRob3JpemF0aW9uJykgfHwgaW5pdEhlYWRlcnMuZ2V0KCdjb29raWUnKVxuXG4gICAgICAgIGNvbnN0IGlzVW5DYWNoZWFibGVNZXRob2QgPSAhWydnZXQnLCAnaGVhZCddLmluY2x1ZGVzKFxuICAgICAgICAgIGdldFJlcXVlc3RNZXRhKCdtZXRob2QnKT8udG9Mb3dlckNhc2UoKSB8fCAnZ2V0J1xuICAgICAgICApXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdlIGF1dG9tYXRpY2FsbHkgZGlzYWJsZSBmZXRjaCBjYWNoaW5nIHVuZGVyIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgICAgICAgICogLSBGZXRjaCBjYWNoZSBjb25maWdzIGFyZSBub3Qgc2V0LiBTcGVjaWZpY2FsbHk6XG4gICAgICAgICAqICAgIC0gQSBwYWdlIGZldGNoIGNhY2hlIG1vZGUgaXMgbm90IHNldCAoZXhwb3J0IGNvbnN0IGZldGNoQ2FjaGU9Li4uKVxuICAgICAgICAgKiAgICAtIEEgZmV0Y2ggY2FjaGUgbW9kZSBpcyBub3Qgc2V0IGluIHRoZSBmZXRjaCBjYWxsIChmZXRjaCh1cmwsIHsgY2FjaGU6IC4uLiB9KSlcbiAgICAgICAgICogICAgICBvciB0aGUgZmV0Y2ggY2FjaGUgbW9kZSBpcyBzZXQgdG8gJ2RlZmF1bHQnXG4gICAgICAgICAqICAgIC0gQSBmZXRjaCByZXZhbGlkYXRlIHZhbHVlIGlzIG5vdCBzZXQgaW4gdGhlIGZldGNoIGNhbGwgKGZldGNoKHVybCwgeyByZXZhbGlkYXRlOiAuLi4gfSkpXG4gICAgICAgICAqIC0gT1IgdGhlIGZldGNoIGNvbWVzIGFmdGVyIGEgY29uZmlndXJhdGlvbiB0aGF0IHRyaWdnZXJlZCBkeW5hbWljIHJlbmRlcmluZyAoZS5nLiwgcmVhZGluZyBjb29raWVzKCkpXG4gICAgICAgICAqICAgYW5kIHRoZSBmZXRjaCB3YXMgY29uc2lkZXJlZCB1bmNhY2hlYWJsZSAoZS5nLiwgUE9TVCBtZXRob2Qgb3IgaGFzIGF1dGhvcml6YXRpb24gaGVhZGVycylcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGhhc05vRXhwbGljaXRDYWNoZUNvbmZpZyA9XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuICAgICAgICAgIHBhZ2VGZXRjaENhY2hlTW9kZSA9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG4gICAgICAgICAgKGN1cnJlbnRGZXRjaENhY2hlQ29uZmlnID09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgLy8gd2hlbiBjb25zaWRlcmluZyB3aGV0aGVyIHRvIG9wdCBpbnRvIHRoZSBkZWZhdWx0IFwibm8tY2FjaGVcIiBmZXRjaCBzZW1hbnRpY3MsXG4gICAgICAgICAgICAvLyBhIFwiZGVmYXVsdFwiIGNhY2hlIGNvbmZpZyBzaG91bGQgYmUgdHJlYXRlZCB0aGUgc2FtZSBhcyBubyBjYWNoZSBjb25maWdcbiAgICAgICAgICAgIGN1cnJlbnRGZXRjaENhY2hlQ29uZmlnID09PSAnZGVmYXVsdCcpICYmXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuICAgICAgICAgIGN1cnJlbnRGZXRjaFJldmFsaWRhdGUgPT0gdW5kZWZpbmVkXG5cbiAgICAgICAgbGV0IGF1dG9Ob0NhY2hlID0gQm9vbGVhbihcbiAgICAgICAgICAoaGFzVW5DYWNoZWFibGVIZWFkZXIgfHwgaXNVbkNhY2hlYWJsZU1ldGhvZCkgJiZcbiAgICAgICAgICAgIHJldmFsaWRhdGVTdG9yZT8ucmV2YWxpZGF0ZSA9PT0gMFxuICAgICAgICApXG5cbiAgICAgICAgbGV0IGlzSW1wbGljaXRCdWlsZFRpbWVDYWNoZSA9IGZhbHNlXG5cbiAgICAgICAgaWYgKCFhdXRvTm9DYWNoZSAmJiBoYXNOb0V4cGxpY2l0Q2FjaGVDb25maWcpIHtcbiAgICAgICAgICAvLyBXZSBkb24ndCBlbmFibGUgYXV0b21hdGljIG5vLWNhY2hlIGJlaGF2aW9yIGR1cmluZyBidWlsZC10aW1lXG4gICAgICAgICAgLy8gcHJlcmVuZGVyaW5nIHNvIHRoYXQgd2UgY2FuIHN0aWxsIGxldmVyYWdlIHRoZSBmZXRjaCBjYWNoZSBiZXR3ZWVuXG4gICAgICAgICAgLy8gZXhwb3J0IHdvcmtlcnMuXG4gICAgICAgICAgaWYgKHdvcmtTdG9yZS5pc0J1aWxkVGltZVByZXJlbmRlcmluZykge1xuICAgICAgICAgICAgaXNJbXBsaWNpdEJ1aWxkVGltZUNhY2hlID0gdHJ1ZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhdXRvTm9DYWNoZSA9IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgaGFzTm9FeHBsaWNpdENhY2hlQ29uZmlnICYmXG4gICAgICAgICAgd29ya1VuaXRTdG9yZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgKHdvcmtVbml0U3RvcmUudHlwZSA9PT0gJ3ByZXJlbmRlcicgfHxcbiAgICAgICAgICAgIC8vIFdoaWxlIHdlIGRvbid0IHdhbnQgdG8gZG8gY2FjaGluZyBpbiB0aGUgY2xpZW50IHNjb3BlXG4gICAgICAgICAgICAvLyB3ZSBrbm93IHRoZSBmZXRjaCB3aWxsIGJlIGR5bmFtaWMgZm9yIGR5bmFtaWNJTyBzbyB3ZVxuICAgICAgICAgICAgLy8gbWF5IGFzIHdlbGwgYXZvaWQgdGhlIGNhbGwgaGVyZVxuICAgICAgICAgICAgd29ya1VuaXRTdG9yZS50eXBlID09PSAncHJlcmVuZGVyLWNsaWVudCcpXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIElmIHdlIGhhdmUgbm8gY2FjaGUgY29uZmlnLCBhbmQgd2UncmUgaW4gRHluYW1pYyBJL08gcHJlcmVuZGVyaW5nLCBpdCdsbCBiZSBhIGR5bmFtaWMgY2FsbC5cbiAgICAgICAgICAvLyBXZSBkb24ndCBoYXZlIHRvIGlzc3VlIHRoYXQgZHluYW1pYyBjYWxsLlxuICAgICAgICAgIGlmIChjYWNoZVNpZ25hbCkge1xuICAgICAgICAgICAgY2FjaGVTaWduYWwuZW5kUmVhZCgpXG4gICAgICAgICAgICBjYWNoZVNpZ25hbCA9IG51bGxcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1ha2VIYW5naW5nUHJvbWlzZTxSZXNwb25zZT4oXG4gICAgICAgICAgICB3b3JrVW5pdFN0b3JlLnJlbmRlclNpZ25hbCxcbiAgICAgICAgICAgICdmZXRjaCgpJ1xuICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAocGFnZUZldGNoQ2FjaGVNb2RlKSB7XG4gICAgICAgICAgY2FzZSAnZm9yY2Utbm8tc3RvcmUnOiB7XG4gICAgICAgICAgICBjYWNoZVJlYXNvbiA9ICdmZXRjaENhY2hlID0gZm9yY2Utbm8tc3RvcmUnXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdvbmx5LW5vLXN0b3JlJzoge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBjdXJyZW50RmV0Y2hDYWNoZUNvbmZpZyA9PT0gJ2ZvcmNlLWNhY2hlJyB8fFxuICAgICAgICAgICAgICAodHlwZW9mIGZpbmFsUmV2YWxpZGF0ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgZmluYWxSZXZhbGlkYXRlID4gMClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgYGNhY2hlOiAnZm9yY2UtY2FjaGUnIHVzZWQgb24gZmV0Y2ggZm9yICR7ZmV0Y2hVcmx9IHdpdGggJ2V4cG9ydCBjb25zdCBmZXRjaENhY2hlID0gJ29ubHktbm8tc3RvcmUnYFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWNoZVJlYXNvbiA9ICdmZXRjaENhY2hlID0gb25seS1uby1zdG9yZSdcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ29ubHktY2FjaGUnOiB7XG4gICAgICAgICAgICBpZiAoY3VycmVudEZldGNoQ2FjaGVDb25maWcgPT09ICduby1zdG9yZScpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIGBjYWNoZTogJ25vLXN0b3JlJyB1c2VkIG9uIGZldGNoIGZvciAke2ZldGNoVXJsfSB3aXRoICdleHBvcnQgY29uc3QgZmV0Y2hDYWNoZSA9ICdvbmx5LWNhY2hlJ2BcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnZm9yY2UtY2FjaGUnOiB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHR5cGVvZiBjdXJyZW50RmV0Y2hSZXZhbGlkYXRlID09PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICAgICAgICBjdXJyZW50RmV0Y2hSZXZhbGlkYXRlID09PSAwXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgY2FjaGVSZWFzb24gPSAnZmV0Y2hDYWNoZSA9IGZvcmNlLWNhY2hlJ1xuICAgICAgICAgICAgICBmaW5hbFJldmFsaWRhdGUgPSBJTkZJTklURV9DQUNIRVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAvLyBzb21ldGltZXMgd2Ugd29uJ3QgbWF0Y2ggdGhlIGFib3ZlIGNhc2VzLiB0aGUgcmVhc29uIHdlIGRvbid0IG1vdmVcbiAgICAgICAgICAvLyBldmVyeXRoaW5nIHRvIHRoaXMgc3dpdGNoIGlzIHRoZSB1c2Ugb2YgYXV0b05vQ2FjaGUgd2hpY2ggaXMgbm90IGEgZmV0Y2hDYWNoZU1vZGVcbiAgICAgICAgICAvLyBJIHN1c3BlY3QgdGhpcyBjb3VsZCBiZSB1bmlmaWVkIHdpdGggZmV0Y2hDYWNoZU1vZGUgaG93ZXZlciBpbiB3aGljaCBjYXNlIHdlIGNvdWxkXG4gICAgICAgICAgLy8gc2ltcGxpZnkgdGhlIHN3aXRjaCBjYXNlIGFuZCBlbnN1cmUgd2UgaGF2ZSBhbiBleGhhdXN0aXZlIHN3aXRjaCBoYW5kbGluZyBhbGwgbW9kZXNcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZmluYWxSZXZhbGlkYXRlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGlmIChwYWdlRmV0Y2hDYWNoZU1vZGUgPT09ICdkZWZhdWx0LWNhY2hlJyAmJiAhaXNVc2luZ05vU3RvcmUpIHtcbiAgICAgICAgICAgIGZpbmFsUmV2YWxpZGF0ZSA9IElORklOSVRFX0NBQ0hFXG4gICAgICAgICAgICBjYWNoZVJlYXNvbiA9ICdmZXRjaENhY2hlID0gZGVmYXVsdC1jYWNoZSdcbiAgICAgICAgICB9IGVsc2UgaWYgKHBhZ2VGZXRjaENhY2hlTW9kZSA9PT0gJ2RlZmF1bHQtbm8tc3RvcmUnKSB7XG4gICAgICAgICAgICBmaW5hbFJldmFsaWRhdGUgPSAwXG4gICAgICAgICAgICBjYWNoZVJlYXNvbiA9ICdmZXRjaENhY2hlID0gZGVmYXVsdC1uby1zdG9yZSdcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzVXNpbmdOb1N0b3JlKSB7XG4gICAgICAgICAgICBmaW5hbFJldmFsaWRhdGUgPSAwXG4gICAgICAgICAgICBjYWNoZVJlYXNvbiA9ICdub1N0b3JlIGNhbGwnXG4gICAgICAgICAgfSBlbHNlIGlmIChhdXRvTm9DYWNoZSkge1xuICAgICAgICAgICAgZmluYWxSZXZhbGlkYXRlID0gMFxuICAgICAgICAgICAgY2FjaGVSZWFzb24gPSAnYXV0byBubyBjYWNoZSdcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVE9ETzogc2hvdWxkIHdlIGNvbnNpZGVyIHRoaXMgY2FzZSBhbiBpbnZhcmlhbnQ/XG4gICAgICAgICAgICBjYWNoZVJlYXNvbiA9ICdhdXRvIGNhY2hlJ1xuICAgICAgICAgICAgZmluYWxSZXZhbGlkYXRlID0gcmV2YWxpZGF0ZVN0b3JlXG4gICAgICAgICAgICAgID8gcmV2YWxpZGF0ZVN0b3JlLnJldmFsaWRhdGVcbiAgICAgICAgICAgICAgOiBJTkZJTklURV9DQUNIRVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghY2FjaGVSZWFzb24pIHtcbiAgICAgICAgICBjYWNoZVJlYXNvbiA9IGByZXZhbGlkYXRlOiAke2ZpbmFsUmV2YWxpZGF0ZX1gXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgLy8gd2hlbiBmb3JjZSBzdGF0aWMgaXMgY29uZmlndXJlZCB3ZSBkb24ndCBiYWlsIGZyb21cbiAgICAgICAgICAvLyBgcmV2YWxpZGF0ZTogMGAgdmFsdWVzXG4gICAgICAgICAgISh3b3JrU3RvcmUuZm9yY2VTdGF0aWMgJiYgZmluYWxSZXZhbGlkYXRlID09PSAwKSAmJlxuICAgICAgICAgIC8vIHdlIGRvbid0IGNvbnNpZGVyIGF1dG9Ob0NhY2hlIHRvIHN3aXRjaCB0byBkeW5hbWljIGZvciBJU1JcbiAgICAgICAgICAhYXV0b05vQ2FjaGUgJiZcbiAgICAgICAgICAvLyBJZiB0aGUgcmV2YWxpZGF0ZSB2YWx1ZSBpc24ndCBjdXJyZW50bHkgc2V0IG9yIHRoZSB2YWx1ZSBpcyBsZXNzXG4gICAgICAgICAgLy8gdGhhbiB0aGUgY3VycmVudCByZXZhbGlkYXRlIHZhbHVlLCB3ZSBzaG91bGQgdXBkYXRlIHRoZSByZXZhbGlkYXRlXG4gICAgICAgICAgLy8gdmFsdWUuXG4gICAgICAgICAgcmV2YWxpZGF0ZVN0b3JlICYmXG4gICAgICAgICAgZmluYWxSZXZhbGlkYXRlIDwgcmV2YWxpZGF0ZVN0b3JlLnJldmFsaWRhdGVcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gSWYgd2Ugd2VyZSBzZXR0aW5nIHRoZSByZXZhbGlkYXRlIHZhbHVlIHRvIDAsIHdlIHNob3VsZCB0cnkgdG9cbiAgICAgICAgICAvLyBwb3N0cG9uZSBpbnN0ZWFkIGZpcnN0LlxuICAgICAgICAgIGlmIChmaW5hbFJldmFsaWRhdGUgPT09IDApIHtcbiAgICAgICAgICAgIGlmICh3b3JrVW5pdFN0b3JlKSB7XG4gICAgICAgICAgICAgIHN3aXRjaCAod29ya1VuaXRTdG9yZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAncHJlcmVuZGVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdwcmVyZW5kZXItY2xpZW50JzpcbiAgICAgICAgICAgICAgICAgIGlmIChjYWNoZVNpZ25hbCkge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZVNpZ25hbC5lbmRSZWFkKClcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVTaWduYWwgPSBudWxsXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZUhhbmdpbmdQcm9taXNlPFJlc3BvbnNlPihcbiAgICAgICAgICAgICAgICAgICAgd29ya1VuaXRTdG9yZS5yZW5kZXJTaWduYWwsXG4gICAgICAgICAgICAgICAgICAgICdmZXRjaCgpJ1xuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gZmFsbHRocm91Z2hcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtYXJrQ3VycmVudFNjb3BlQXNEeW5hbWljKFxuICAgICAgICAgICAgICB3b3JrU3RvcmUsXG4gICAgICAgICAgICAgIHdvcmtVbml0U3RvcmUsXG4gICAgICAgICAgICAgIGByZXZhbGlkYXRlOiAwIGZldGNoICR7aW5wdXR9ICR7d29ya1N0b3JlLnJvdXRlfWBcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBXZSBvbmx5IHdhbnQgdG8gc2V0IHRoZSByZXZhbGlkYXRlIHN0b3JlJ3MgcmV2YWxpZGF0ZSB0aW1lIGlmIGl0XG4gICAgICAgICAgLy8gd2FzIGV4cGxpY2l0bHkgc2V0IGZvciB0aGUgZmV0Y2ggY2FsbCwgaS5lLlxuICAgICAgICAgIC8vIG9yaWdpbmFsRmV0Y2hSZXZhbGlkYXRlLlxuICAgICAgICAgIGlmIChyZXZhbGlkYXRlU3RvcmUgJiYgb3JpZ2luYWxGZXRjaFJldmFsaWRhdGUgPT09IGZpbmFsUmV2YWxpZGF0ZSkge1xuICAgICAgICAgICAgcmV2YWxpZGF0ZVN0b3JlLnJldmFsaWRhdGUgPSBmaW5hbFJldmFsaWRhdGVcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpc0NhY2hlYWJsZVJldmFsaWRhdGUgPVxuICAgICAgICAgIHR5cGVvZiBmaW5hbFJldmFsaWRhdGUgPT09ICdudW1iZXInICYmIGZpbmFsUmV2YWxpZGF0ZSA+IDBcblxuICAgICAgICBsZXQgY2FjaGVLZXk6IHN0cmluZyB8IHVuZGVmaW5lZFxuICAgICAgICBjb25zdCB7IGluY3JlbWVudGFsQ2FjaGUgfSA9IHdvcmtTdG9yZVxuXG4gICAgICAgIGNvbnN0IHVzZUNhY2hlT3JSZXF1ZXN0U3RvcmUgPVxuICAgICAgICAgIHdvcmtVbml0U3RvcmU/LnR5cGUgPT09ICdyZXF1ZXN0JyB8fCB3b3JrVW5pdFN0b3JlPy50eXBlID09PSAnY2FjaGUnXG4gICAgICAgICAgICA/IHdvcmtVbml0U3RvcmVcbiAgICAgICAgICAgIDogdW5kZWZpbmVkXG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIGluY3JlbWVudGFsQ2FjaGUgJiZcbiAgICAgICAgICAoaXNDYWNoZWFibGVSZXZhbGlkYXRlIHx8XG4gICAgICAgICAgICB1c2VDYWNoZU9yUmVxdWVzdFN0b3JlPy5zZXJ2ZXJDb21wb25lbnRzSG1yQ2FjaGUpXG4gICAgICAgICkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjYWNoZUtleSA9IGF3YWl0IGluY3JlbWVudGFsQ2FjaGUuZ2VuZXJhdGVDYWNoZUtleShcbiAgICAgICAgICAgICAgZmV0Y2hVcmwsXG4gICAgICAgICAgICAgIGlzUmVxdWVzdElucHV0ID8gKGlucHV0IGFzIFJlcXVlc3RJbml0KSA6IGluaXRcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBnZW5lcmF0ZSBjYWNoZSBrZXkgZm9yYCwgaW5wdXQpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZmV0Y2hJZHggPSB3b3JrU3RvcmUubmV4dEZldGNoSWQgPz8gMVxuICAgICAgICB3b3JrU3RvcmUubmV4dEZldGNoSWQgPSBmZXRjaElkeCArIDFcblxuICAgICAgICBsZXQgaGFuZGxlVW5sb2NrOiAoKSA9PiBQcm9taXNlPHZvaWQ+IHwgdm9pZCA9ICgpID0+IHt9XG5cbiAgICAgICAgY29uc3QgZG9PcmlnaW5hbEZldGNoID0gYXN5bmMgKFxuICAgICAgICAgIGlzU3RhbGU/OiBib29sZWFuLFxuICAgICAgICAgIGNhY2hlUmVhc29uT3ZlcnJpZGU/OiBzdHJpbmdcbiAgICAgICAgKSA9PiB7XG4gICAgICAgICAgY29uc3QgcmVxdWVzdElucHV0RmllbGRzID0gW1xuICAgICAgICAgICAgJ2NhY2hlJyxcbiAgICAgICAgICAgICdjcmVkZW50aWFscycsXG4gICAgICAgICAgICAnaGVhZGVycycsXG4gICAgICAgICAgICAnaW50ZWdyaXR5JyxcbiAgICAgICAgICAgICdrZWVwYWxpdmUnLFxuICAgICAgICAgICAgJ21ldGhvZCcsXG4gICAgICAgICAgICAnbW9kZScsXG4gICAgICAgICAgICAncmVkaXJlY3QnLFxuICAgICAgICAgICAgJ3JlZmVycmVyJyxcbiAgICAgICAgICAgICdyZWZlcnJlclBvbGljeScsXG4gICAgICAgICAgICAnd2luZG93JyxcbiAgICAgICAgICAgICdkdXBsZXgnLFxuXG4gICAgICAgICAgICAvLyBkb24ndCBwYXNzIHRocm91Z2ggc2lnbmFsIHdoZW4gcmV2YWxpZGF0aW5nXG4gICAgICAgICAgICAuLi4oaXNTdGFsZSA/IFtdIDogWydzaWduYWwnXSksXG4gICAgICAgICAgXVxuXG4gICAgICAgICAgaWYgKGlzUmVxdWVzdElucHV0KSB7XG4gICAgICAgICAgICBjb25zdCByZXFJbnB1dDogUmVxdWVzdCA9IGlucHV0IGFzIGFueVxuICAgICAgICAgICAgY29uc3QgcmVxT3B0aW9uczogUmVxdWVzdEluaXQgPSB7XG4gICAgICAgICAgICAgIGJvZHk6IChyZXFJbnB1dCBhcyBhbnkpLl9vZ0JvZHkgfHwgcmVxSW5wdXQuYm9keSxcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiByZXF1ZXN0SW5wdXRGaWVsZHMpIHtcbiAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBjdXN0b20gZmllbGRzXG4gICAgICAgICAgICAgIHJlcU9wdGlvbnNbZmllbGRdID0gcmVxSW5wdXRbZmllbGRdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnB1dCA9IG5ldyBSZXF1ZXN0KHJlcUlucHV0LnVybCwgcmVxT3B0aW9ucylcbiAgICAgICAgICB9IGVsc2UgaWYgKGluaXQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgX29nQm9keSwgYm9keSwgc2lnbmFsLCAuLi5vdGhlcklucHV0IH0gPVxuICAgICAgICAgICAgICBpbml0IGFzIFJlcXVlc3RJbml0ICYgeyBfb2dCb2R5PzogYW55IH1cbiAgICAgICAgICAgIGluaXQgPSB7XG4gICAgICAgICAgICAgIC4uLm90aGVySW5wdXQsXG4gICAgICAgICAgICAgIGJvZHk6IF9vZ0JvZHkgfHwgYm9keSxcbiAgICAgICAgICAgICAgc2lnbmFsOiBpc1N0YWxlID8gdW5kZWZpbmVkIDogc2lnbmFsLFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGFkZCBtZXRhZGF0YSB0byBpbml0IHdpdGhvdXQgZWRpdGluZyB0aGUgb3JpZ2luYWxcbiAgICAgICAgICBjb25zdCBjbG9uZWRJbml0ID0ge1xuICAgICAgICAgICAgLi4uaW5pdCxcbiAgICAgICAgICAgIG5leHQ6IHsgLi4uaW5pdD8ubmV4dCwgZmV0Y2hUeXBlOiAnb3JpZ2luJywgZmV0Y2hJZHggfSxcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gb3JpZ2luRmV0Y2goaW5wdXQsIGNsb25lZEluaXQpXG4gICAgICAgICAgICAudGhlbihhc3luYyAocmVzKSA9PiB7XG4gICAgICAgICAgICAgIGlmICghaXNTdGFsZSAmJiBmZXRjaFN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgdHJhY2tGZXRjaE1ldHJpYyh3b3JrU3RvcmUsIHtcbiAgICAgICAgICAgICAgICAgIHN0YXJ0OiBmZXRjaFN0YXJ0LFxuICAgICAgICAgICAgICAgICAgdXJsOiBmZXRjaFVybCxcbiAgICAgICAgICAgICAgICAgIGNhY2hlUmVhc29uOiBjYWNoZVJlYXNvbk92ZXJyaWRlIHx8IGNhY2hlUmVhc29uLFxuICAgICAgICAgICAgICAgICAgY2FjaGVTdGF0dXM6XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsUmV2YWxpZGF0ZSA9PT0gMCB8fCBjYWNoZVJlYXNvbk92ZXJyaWRlXG4gICAgICAgICAgICAgICAgICAgICAgPyAnc2tpcCdcbiAgICAgICAgICAgICAgICAgICAgICA6ICdtaXNzJyxcbiAgICAgICAgICAgICAgICAgIGNhY2hlV2FybmluZyxcbiAgICAgICAgICAgICAgICAgIHN0YXR1czogcmVzLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgIG1ldGhvZDogY2xvbmVkSW5pdC5tZXRob2QgfHwgJ0dFVCcsXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgcmVzLnN0YXR1cyA9PT0gMjAwICYmXG4gICAgICAgICAgICAgICAgaW5jcmVtZW50YWxDYWNoZSAmJlxuICAgICAgICAgICAgICAgIGNhY2hlS2V5ICYmXG4gICAgICAgICAgICAgICAgKGlzQ2FjaGVhYmxlUmV2YWxpZGF0ZSB8fFxuICAgICAgICAgICAgICAgICAgdXNlQ2FjaGVPclJlcXVlc3RTdG9yZT8uc2VydmVyQ29tcG9uZW50c0htckNhY2hlKVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBub3JtYWxpemVkUmV2YWxpZGF0ZSA9XG4gICAgICAgICAgICAgICAgICBmaW5hbFJldmFsaWRhdGUgPj0gSU5GSU5JVEVfQ0FDSEVcbiAgICAgICAgICAgICAgICAgICAgPyBDQUNIRV9PTkVfWUVBUlxuICAgICAgICAgICAgICAgICAgICA6IGZpbmFsUmV2YWxpZGF0ZVxuXG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgd29ya1VuaXRTdG9yZSAmJlxuICAgICAgICAgICAgICAgICAgKHdvcmtVbml0U3RvcmUudHlwZSA9PT0gJ3ByZXJlbmRlcicgfHxcbiAgICAgICAgICAgICAgICAgICAgd29ya1VuaXRTdG9yZS50eXBlID09PSAncHJlcmVuZGVyLWNsaWVudCcpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAvLyBXZSBhcmUgcHJlcmVuZGVyaW5nIGF0IGJ1aWxkIHRpbWUgb3IgcmV2YWxpZGF0ZSB0aW1lIHdpdGggZHluYW1pY0lPIHNvIHdlIG5lZWQgdG9cbiAgICAgICAgICAgICAgICAgIC8vIGJ1ZmZlciB0aGUgcmVzcG9uc2Ugc28gd2UgY2FuIGd1YXJhbnRlZSBpdCBjYW4gYmUgcmVhZCBpbiBhIG1pY3JvdGFza1xuICAgICAgICAgICAgICAgICAgY29uc3QgYm9keUJ1ZmZlciA9IGF3YWl0IHJlcy5hcnJheUJ1ZmZlcigpXG5cbiAgICAgICAgICAgICAgICAgIGNvbnN0IGZldGNoZWREYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBPYmplY3QuZnJvbUVudHJpZXMocmVzLmhlYWRlcnMuZW50cmllcygpKSxcbiAgICAgICAgICAgICAgICAgICAgYm9keTogQnVmZmVyLmZyb20oYm9keUJ1ZmZlcikudG9TdHJpbmcoJ2Jhc2U2NCcpLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHJlcy5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgIHVybDogcmVzLnVybCxcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgLy8gV2UgY2FuIHNraXAgY2hlY2tpbmcgdGhlIHNlcnZlckNvbXBvbmVudHNIbXJDYWNoZSBiZWNhdXNlIHdlIGFyZW4ndCBpblxuICAgICAgICAgICAgICAgICAgLy8gZGV2IG1vZGUuXG5cbiAgICAgICAgICAgICAgICAgIGF3YWl0IGluY3JlbWVudGFsQ2FjaGUuc2V0KFxuICAgICAgICAgICAgICAgICAgICBjYWNoZUtleSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IENhY2hlZFJvdXRlS2luZC5GRVRDSCxcbiAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBmZXRjaGVkRGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICByZXZhbGlkYXRlOiBub3JtYWxpemVkUmV2YWxpZGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgIGZldGNoQ2FjaGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgZmV0Y2hVcmwsXG4gICAgICAgICAgICAgICAgICAgICAgZmV0Y2hJZHgsXG4gICAgICAgICAgICAgICAgICAgICAgdGFncyxcbiAgICAgICAgICAgICAgICAgICAgICBpc0ltcGxpY2l0QnVpbGRUaW1lQ2FjaGUsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZVVubG9jaygpXG5cbiAgICAgICAgICAgICAgICAgIC8vIFdlIHJldHVybiBhIG5ldyBSZXNwb25zZSB0byB0aGUgY2FsbGVyLlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShib2R5QnVmZmVyLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHJlcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHJlcy5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1c1RleHQ6IHJlcy5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gV2UncmUgY2xvbmluZyB0aGUgcmVzcG9uc2UgdXNpbmcgdGhpcyB1dGlsaXR5IGJlY2F1c2UgdGhlcmVcbiAgICAgICAgICAgICAgICAgIC8vIGV4aXN0cyBhIGJ1ZyBpbiB0aGUgdW5kaWNpIGxpYnJhcnkgYXJvdW5kIHJlc3BvbnNlIGNsb25pbmcuXG4gICAgICAgICAgICAgICAgICAvLyBTZWUgdGhlIGZvbGxvd2luZyBwdWxsIHJlcXVlc3QgZm9yIG1vcmUgZGV0YWlsczpcbiAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvbmV4dC5qcy9wdWxsLzczMjc0XG5cbiAgICAgICAgICAgICAgICAgIGNvbnN0IFtjbG9uZWQxLCBjbG9uZWQyXSA9IGNsb25lUmVzcG9uc2UocmVzKVxuXG4gICAgICAgICAgICAgICAgICAvLyBXZSBhcmUgZHluYW1pY2FsbHkgcmVuZGVyaW5nIGluY2x1ZGluZyBkZXYgbW9kZS4gV2Ugd2FudCB0byByZXR1cm5cbiAgICAgICAgICAgICAgICAgIC8vIHRoZSByZXNwb25zZSB0byB0aGUgY2FsbGVyIGFzIHNvb24gYXMgcG9zc2libGUgYmVjYXVzZSBpdCBtaWdodCBzdHJlYW1cbiAgICAgICAgICAgICAgICAgIC8vIG92ZXIgYSB2ZXJ5IGxvbmcgdGltZS5cbiAgICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlU2V0UHJvbWlzZSA9IGNsb25lZDFcbiAgICAgICAgICAgICAgICAgICAgLmFycmF5QnVmZmVyKClcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oYXN5bmMgKGFycmF5QnVmZmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgYm9keUJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyKVxuXG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmV0Y2hlZERhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBPYmplY3QuZnJvbUVudHJpZXMoY2xvbmVkMS5oZWFkZXJzLmVudHJpZXMoKSksXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBib2R5QnVmZmVyLnRvU3RyaW5nKCdiYXNlNjQnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogY2xvbmVkMS5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGNsb25lZDEudXJsLFxuICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgIHVzZUNhY2hlT3JSZXF1ZXN0U3RvcmU/LnNlcnZlckNvbXBvbmVudHNIbXJDYWNoZT8uc2V0KFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBmZXRjaGVkRGF0YVxuICAgICAgICAgICAgICAgICAgICAgIClcblxuICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0NhY2hlYWJsZVJldmFsaWRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGluY3JlbWVudGFsQ2FjaGUuc2V0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IENhY2hlZFJvdXRlS2luZC5GRVRDSCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBmZXRjaGVkRGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXZhbGlkYXRlOiBub3JtYWxpemVkUmV2YWxpZGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZldGNoQ2FjaGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmV0Y2hVcmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmV0Y2hJZHgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0ltcGxpY2l0QnVpbGRUaW1lQ2FjaGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+XG4gICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBGYWlsZWQgdG8gc2V0IGZldGNoIGNhY2hlYCwgaW5wdXQsIGVycm9yKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIC5maW5hbGx5KGhhbmRsZVVubG9jaylcblxuICAgICAgICAgICAgICAgICAgY29uc3QgcGVuZGluZ1JldmFsaWRhdGVLZXkgPSBgY2FjaGUtc2V0LSR7Y2FjaGVLZXl9YFxuICAgICAgICAgICAgICAgICAgd29ya1N0b3JlLnBlbmRpbmdSZXZhbGlkYXRlcyA/Pz0ge31cbiAgICAgICAgICAgICAgICAgIGlmIChwZW5kaW5nUmV2YWxpZGF0ZUtleSBpbiB3b3JrU3RvcmUucGVuZGluZ1JldmFsaWRhdGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZXJlIGlzIGFscmVhZHkgYSBwZW5kaW5nIHJldmFsaWRhdGUgZW50cnkgdGhhdFxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGF3YWl0IHRvIGF2b2lkIHJhY2UgY29uZGl0aW9uc1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB3b3JrU3RvcmUucGVuZGluZ1JldmFsaWRhdGVzW3BlbmRpbmdSZXZhbGlkYXRlS2V5XVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgd29ya1N0b3JlLnBlbmRpbmdSZXZhbGlkYXRlc1twZW5kaW5nUmV2YWxpZGF0ZUtleV0gPVxuICAgICAgICAgICAgICAgICAgICBjYWNoZVNldFByb21pc2UuZmluYWxseSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHBlbmRpbmcgcmV2YWxpZGF0ZSBpcyBub3QgcHJlc2VudCBpbiB0aGUgc3RvcmUsIHRoZW5cbiAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBoYXZlIG5vdGhpbmcgdG8gZGVsZXRlLlxuICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICF3b3JrU3RvcmUucGVuZGluZ1JldmFsaWRhdGVzPy5bcGVuZGluZ1JldmFsaWRhdGVLZXldXG4gICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgd29ya1N0b3JlLnBlbmRpbmdSZXZhbGlkYXRlc1twZW5kaW5nUmV2YWxpZGF0ZUtleV1cbiAgICAgICAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsb25lZDJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyB3ZSBoYWQgcmVzcG9uc2UgdGhhdCB3ZSBkZXRlcm1pbmVkIHNob3VsZG4ndCBiZSBjYWNoZWQgc28gd2UgcmV0dXJuIGl0XG4gICAgICAgICAgICAgIC8vIGFuZCBkb24ndCBjYWNoZSBpdC4gVGhpcyBhbHNvIG5lZWRzIHRvIHVubG9jayB0aGUgY2FjaGUgbG9jayB3ZSBhY3F1aXJlZC5cbiAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlVW5sb2NrKClcblxuICAgICAgICAgICAgICByZXR1cm4gcmVzXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICBoYW5kbGVVbmxvY2soKVxuICAgICAgICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjYWNoZVJlYXNvbk92ZXJyaWRlXG4gICAgICAgIGxldCBpc0ZvcmVncm91bmRSZXZhbGlkYXRlID0gZmFsc2VcbiAgICAgICAgbGV0IGlzSG1yUmVmcmVzaENhY2hlID0gZmFsc2VcblxuICAgICAgICBpZiAoY2FjaGVLZXkgJiYgaW5jcmVtZW50YWxDYWNoZSkge1xuICAgICAgICAgIGxldCBjYWNoZWRGZXRjaERhdGE6IENhY2hlZEZldGNoRGF0YSB8IHVuZGVmaW5lZFxuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgdXNlQ2FjaGVPclJlcXVlc3RTdG9yZT8uaXNIbXJSZWZyZXNoICYmXG4gICAgICAgICAgICB1c2VDYWNoZU9yUmVxdWVzdFN0b3JlLnNlcnZlckNvbXBvbmVudHNIbXJDYWNoZVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgY2FjaGVkRmV0Y2hEYXRhID1cbiAgICAgICAgICAgICAgdXNlQ2FjaGVPclJlcXVlc3RTdG9yZS5zZXJ2ZXJDb21wb25lbnRzSG1yQ2FjaGUuZ2V0KGNhY2hlS2V5KVxuXG4gICAgICAgICAgICBpc0htclJlZnJlc2hDYWNoZSA9IHRydWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNDYWNoZWFibGVSZXZhbGlkYXRlICYmICFjYWNoZWRGZXRjaERhdGEpIHtcbiAgICAgICAgICAgIGhhbmRsZVVubG9jayA9IGF3YWl0IGluY3JlbWVudGFsQ2FjaGUubG9jayhjYWNoZUtleSlcbiAgICAgICAgICAgIGNvbnN0IGVudHJ5ID0gd29ya1N0b3JlLmlzT25EZW1hbmRSZXZhbGlkYXRlXG4gICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICA6IGF3YWl0IGluY3JlbWVudGFsQ2FjaGUuZ2V0KGNhY2hlS2V5LCB7XG4gICAgICAgICAgICAgICAgICBraW5kOiBJbmNyZW1lbnRhbENhY2hlS2luZC5GRVRDSCxcbiAgICAgICAgICAgICAgICAgIHJldmFsaWRhdGU6IGZpbmFsUmV2YWxpZGF0ZSxcbiAgICAgICAgICAgICAgICAgIGZldGNoVXJsLFxuICAgICAgICAgICAgICAgICAgZmV0Y2hJZHgsXG4gICAgICAgICAgICAgICAgICB0YWdzLFxuICAgICAgICAgICAgICAgICAgc29mdFRhZ3M6IGltcGxpY2l0VGFncz8udGFncyxcbiAgICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICBpZiAoaGFzTm9FeHBsaWNpdENhY2hlQ29uZmlnKSB7XG4gICAgICAgICAgICAgIC8vIFdlIHNvbWV0aW1lcyB1c2UgdGhlIGNhY2hlIHRvIGRlZHVwZSBmZXRjaGVzIHRoYXQgZG8gbm90IHNwZWNpZnkgYSBjYWNoZSBjb25maWd1cmF0aW9uXG4gICAgICAgICAgICAgIC8vIEluIHRoZXNlIGNhc2VzIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHdlIHN0aWxsIGV4Y2x1ZGUgdGhlbSBmcm9tIHByZXJlbmRlcnMgaWYgZHluYW1pY0lPIGlzIG9uXG4gICAgICAgICAgICAgIC8vIHNvIHdlIGludHJvZHVjZSBhbiBhcnRpZmljaWFsIFRhc2sgYm91bmRhcnkgaGVyZS5cbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHdvcmtVbml0U3RvcmUgJiZcbiAgICAgICAgICAgICAgICAod29ya1VuaXRTdG9yZS50eXBlID09PSAncHJlcmVuZGVyJyB8fFxuICAgICAgICAgICAgICAgICAgd29ya1VuaXRTdG9yZS50eXBlID09PSAncHJlcmVuZGVyLWNsaWVudCcpXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHdhaXRBdExlYXN0T25lUmVhY3RSZW5kZXJUYXNrKClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlVW5sb2NrKClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGluIGRldiwgaW5jcmVtZW50YWwgY2FjaGUgcmVzcG9uc2Ugd2lsbCBiZSBudWxsIGluIGNhc2UgdGhlIGJyb3dzZXIgYWRkcyBgY2FjaGUtY29udHJvbDogbm8tY2FjaGVgIGluIHRoZSByZXF1ZXN0IGhlYWRlcnNcbiAgICAgICAgICAgICAgY2FjaGVSZWFzb25PdmVycmlkZSA9ICdjYWNoZS1jb250cm9sOiBuby1jYWNoZSAoaGFyZCByZWZyZXNoKSdcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVudHJ5Py52YWx1ZSAmJiBlbnRyeS52YWx1ZS5raW5kID09PSBDYWNoZWRSb3V0ZUtpbmQuRkVUQ0gpIHtcbiAgICAgICAgICAgICAgLy8gd2hlbiBzdGFsZSBhbmQgaXMgcmV2YWxpZGF0aW5nIHdlIHdhaXQgZm9yIGZyZXNoIGRhdGFcbiAgICAgICAgICAgICAgLy8gc28gdGhlIHJldmFsaWRhdGVkIGVudHJ5IGhhcyB0aGUgdXBkYXRlZCBkYXRhXG4gICAgICAgICAgICAgIGlmICh3b3JrU3RvcmUuaXNSZXZhbGlkYXRlICYmIGVudHJ5LmlzU3RhbGUpIHtcbiAgICAgICAgICAgICAgICBpc0ZvcmVncm91bmRSZXZhbGlkYXRlID0gdHJ1ZVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChlbnRyeS5pc1N0YWxlKSB7XG4gICAgICAgICAgICAgICAgICB3b3JrU3RvcmUucGVuZGluZ1JldmFsaWRhdGVzID8/PSB7fVxuICAgICAgICAgICAgICAgICAgaWYgKCF3b3JrU3RvcmUucGVuZGluZ1JldmFsaWRhdGVzW2NhY2hlS2V5XSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwZW5kaW5nUmV2YWxpZGF0ZSA9IGRvT3JpZ2luYWxGZXRjaCh0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGFzeW5jIChyZXNwb25zZSkgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiByZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0OiByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAgICAgICAgIC5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtTdG9yZS5wZW5kaW5nUmV2YWxpZGF0ZXMgPz89IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgd29ya1N0b3JlLnBlbmRpbmdSZXZhbGlkYXRlc1tjYWNoZUtleSB8fCAnJ11cbiAgICAgICAgICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEF0dGFjaCB0aGUgZW1wdHkgY2F0Y2ggaGVyZSBzbyB3ZSBkb24ndCBnZXQgYSBcInVuaGFuZGxlZFxuICAgICAgICAgICAgICAgICAgICAvLyBwcm9taXNlIHJlamVjdGlvblwiIHdhcm5pbmcuXG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdSZXZhbGlkYXRlLmNhdGNoKGNvbnNvbGUuZXJyb3IpXG5cbiAgICAgICAgICAgICAgICAgICAgd29ya1N0b3JlLnBlbmRpbmdSZXZhbGlkYXRlc1tjYWNoZUtleV0gPSBwZW5kaW5nUmV2YWxpZGF0ZVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNhY2hlZEZldGNoRGF0YSA9IGVudHJ5LnZhbHVlLmRhdGFcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjYWNoZWRGZXRjaERhdGEpIHtcbiAgICAgICAgICAgIGlmIChmZXRjaFN0YXJ0KSB7XG4gICAgICAgICAgICAgIHRyYWNrRmV0Y2hNZXRyaWMod29ya1N0b3JlLCB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IGZldGNoU3RhcnQsXG4gICAgICAgICAgICAgICAgdXJsOiBmZXRjaFVybCxcbiAgICAgICAgICAgICAgICBjYWNoZVJlYXNvbixcbiAgICAgICAgICAgICAgICBjYWNoZVN0YXR1czogaXNIbXJSZWZyZXNoQ2FjaGUgPyAnaG1yJyA6ICdoaXQnLFxuICAgICAgICAgICAgICAgIGNhY2hlV2FybmluZyxcbiAgICAgICAgICAgICAgICBzdGF0dXM6IGNhY2hlZEZldGNoRGF0YS5zdGF0dXMgfHwgMjAwLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogaW5pdD8ubWV0aG9kIHx8ICdHRVQnLFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IG5ldyBSZXNwb25zZShcbiAgICAgICAgICAgICAgQnVmZmVyLmZyb20oY2FjaGVkRmV0Y2hEYXRhLmJvZHksICdiYXNlNjQnKSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGNhY2hlZEZldGNoRGF0YS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHN0YXR1czogY2FjaGVkRmV0Y2hEYXRhLnN0YXR1cyxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzcG9uc2UsICd1cmwnLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBjYWNoZWRGZXRjaERhdGEudXJsLFxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHdvcmtTdG9yZS5pc1N0YXRpY0dlbmVyYXRpb24gJiYgaW5pdCAmJiB0eXBlb2YgaW5pdCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBjb25zdCB7IGNhY2hlIH0gPSBpbml0XG5cbiAgICAgICAgICAvLyBEZWxldGUgYGNhY2hlYCBwcm9wZXJ0eSBhcyBDbG91ZGZsYXJlIFdvcmtlcnMgd2lsbCB0aHJvdyBhbiBlcnJvclxuICAgICAgICAgIGlmIChpc0VkZ2VSdW50aW1lKSBkZWxldGUgaW5pdC5jYWNoZVxuXG4gICAgICAgICAgaWYgKGNhY2hlID09PSAnbm8tc3RvcmUnKSB7XG4gICAgICAgICAgICAvLyBJZiBlbmFibGVkLCB3ZSBzaG91bGQgYmFpbCBvdXQgb2Ygc3RhdGljIGdlbmVyYXRpb24uXG4gICAgICAgICAgICBpZiAod29ya1VuaXRTdG9yZSkge1xuICAgICAgICAgICAgICBzd2l0Y2ggKHdvcmtVbml0U3RvcmUudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3ByZXJlbmRlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAncHJlcmVuZGVyLWNsaWVudCc6XG4gICAgICAgICAgICAgICAgICBpZiAoY2FjaGVTaWduYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVTaWduYWwuZW5kUmVhZCgpXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlU2lnbmFsID0gbnVsbFxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VIYW5naW5nUHJvbWlzZTxSZXNwb25zZT4oXG4gICAgICAgICAgICAgICAgICAgIHdvcmtVbml0U3RvcmUucmVuZGVyU2lnbmFsLFxuICAgICAgICAgICAgICAgICAgICAnZmV0Y2goKSdcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIGZhbGx0aHJvdWdoXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hcmtDdXJyZW50U2NvcGVBc0R5bmFtaWMoXG4gICAgICAgICAgICAgIHdvcmtTdG9yZSxcbiAgICAgICAgICAgICAgd29ya1VuaXRTdG9yZSxcbiAgICAgICAgICAgICAgYG5vLXN0b3JlIGZldGNoICR7aW5wdXR9ICR7d29ya1N0b3JlLnJvdXRlfWBcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBoYXNOZXh0Q29uZmlnID0gJ25leHQnIGluIGluaXRcbiAgICAgICAgICBjb25zdCB7IG5leHQgPSB7fSB9ID0gaW5pdFxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHR5cGVvZiBuZXh0LnJldmFsaWRhdGUgPT09ICdudW1iZXInICYmXG4gICAgICAgICAgICByZXZhbGlkYXRlU3RvcmUgJiZcbiAgICAgICAgICAgIG5leHQucmV2YWxpZGF0ZSA8IHJldmFsaWRhdGVTdG9yZS5yZXZhbGlkYXRlXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAobmV4dC5yZXZhbGlkYXRlID09PSAwKSB7XG4gICAgICAgICAgICAgIC8vIElmIGVuYWJsZWQsIHdlIHNob3VsZCBiYWlsIG91dCBvZiBzdGF0aWMgZ2VuZXJhdGlvbi5cbiAgICAgICAgICAgICAgaWYgKHdvcmtVbml0U3RvcmUpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHdvcmtVbml0U3RvcmUudHlwZSkge1xuICAgICAgICAgICAgICAgICAgY2FzZSAncHJlcmVuZGVyJzpcbiAgICAgICAgICAgICAgICAgIGNhc2UgJ3ByZXJlbmRlci1jbGllbnQnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZUhhbmdpbmdQcm9taXNlPFJlc3BvbnNlPihcbiAgICAgICAgICAgICAgICAgICAgICB3b3JrVW5pdFN0b3JlLnJlbmRlclNpZ25hbCxcbiAgICAgICAgICAgICAgICAgICAgICAnZmV0Y2goKSdcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIC8vIGZhbGx0aHJvdWdoXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG1hcmtDdXJyZW50U2NvcGVBc0R5bmFtaWMoXG4gICAgICAgICAgICAgICAgd29ya1N0b3JlLFxuICAgICAgICAgICAgICAgIHdvcmtVbml0U3RvcmUsXG4gICAgICAgICAgICAgICAgYHJldmFsaWRhdGU6IDAgZmV0Y2ggJHtpbnB1dH0gJHt3b3JrU3RvcmUucm91dGV9YFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghd29ya1N0b3JlLmZvcmNlU3RhdGljIHx8IG5leHQucmV2YWxpZGF0ZSAhPT0gMCkge1xuICAgICAgICAgICAgICByZXZhbGlkYXRlU3RvcmUucmV2YWxpZGF0ZSA9IG5leHQucmV2YWxpZGF0ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGFzTmV4dENvbmZpZykgZGVsZXRlIGluaXQubmV4dFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgd2UgYXJlIHJldmFsaWRhdGluZyB0aGUgd2hvbGUgcGFnZSB2aWEgdGltZSBvciBvbi1kZW1hbmQgYW5kXG4gICAgICAgIC8vIHRoZSBmZXRjaCBjYWNoZSBlbnRyeSBpcyBzdGFsZSB3ZSBzaG91bGQgc3RpbGwgZGUtZHVwZSB0aGVcbiAgICAgICAgLy8gb3JpZ2luIGhpdCBpZiBpdCdzIGEgY2FjaGUtYWJsZSBlbnRyeVxuICAgICAgICBpZiAoY2FjaGVLZXkgJiYgaXNGb3JlZ3JvdW5kUmV2YWxpZGF0ZSkge1xuICAgICAgICAgIGNvbnN0IHBlbmRpbmdSZXZhbGlkYXRlS2V5ID0gY2FjaGVLZXlcbiAgICAgICAgICB3b3JrU3RvcmUucGVuZGluZ1JldmFsaWRhdGVzID8/PSB7fVxuICAgICAgICAgIGxldCBwZW5kaW5nUmV2YWxpZGF0ZSA9XG4gICAgICAgICAgICB3b3JrU3RvcmUucGVuZGluZ1JldmFsaWRhdGVzW3BlbmRpbmdSZXZhbGlkYXRlS2V5XVxuXG4gICAgICAgICAgaWYgKHBlbmRpbmdSZXZhbGlkYXRlKSB7XG4gICAgICAgICAgICBjb25zdCByZXZhbGlkYXRlZFJlc3VsdDoge1xuICAgICAgICAgICAgICBib2R5OiBBcnJheUJ1ZmZlclxuICAgICAgICAgICAgICBoZWFkZXJzOiBIZWFkZXJzXG4gICAgICAgICAgICAgIHN0YXR1czogbnVtYmVyXG4gICAgICAgICAgICAgIHN0YXR1c1RleHQ6IHN0cmluZ1xuICAgICAgICAgICAgfSA9IGF3YWl0IHBlbmRpbmdSZXZhbGlkYXRlXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKHJldmFsaWRhdGVkUmVzdWx0LmJvZHksIHtcbiAgICAgICAgICAgICAgaGVhZGVyczogcmV2YWxpZGF0ZWRSZXN1bHQuaGVhZGVycyxcbiAgICAgICAgICAgICAgc3RhdHVzOiByZXZhbGlkYXRlZFJlc3VsdC5zdGF0dXMsXG4gICAgICAgICAgICAgIHN0YXR1c1RleHQ6IHJldmFsaWRhdGVkUmVzdWx0LnN0YXR1c1RleHQsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFdlIHVzZWQgdG8ganVzdCByZXNvbHZlIHRoZSBSZXNwb25zZSBhbmQgY2xvbmUgaXQgaG93ZXZlciBmb3JcbiAgICAgICAgICAvLyBzdGF0aWMgZ2VuZXJhdGlvbiB3aXRoIGR5bmFtaWNJTyB3ZSBuZWVkIHRoZSByZXNwb25zZSB0byBiZSBhYmxlIHRvXG4gICAgICAgICAgLy8gYmUgcmVzb2x2ZWQgaW4gYSBtaWNyb3Rhc2sgYW5kIGNsb25pbmcgdGhlIHJlc3BvbnNlIHdpbGwgbmV2ZXIgaGF2ZVxuICAgICAgICAgIC8vIGEgYm9keSB0aGF0IGNhbiByZXNvbHZlIGluIGEgbWljcm90YXNrIGluIG5vZGUgKGFzIG9ic2VydmVkIHRocm91Z2hcbiAgICAgICAgICAvLyBleHBlcmltZW50YXRpb24pIFNvIGluc3RlYWQgd2UgYXdhaXQgdGhlIGJvZHkgYW5kIHRoZW4gd2hlbiBpdCBpc1xuICAgICAgICAgIC8vIGF2YWlsYWJsZSB3ZSBjb25zdHJ1Y3QgbWFudWFsbHkgY2xvbmVkIFJlc3BvbnNlIG9iamVjdHMgd2l0aCB0aGVcbiAgICAgICAgICAvLyBib2R5IGFzIGFuIEFycmF5QnVmZmVyLiBUaGlzIHdpbGwgYmUgcmVzb2x2YWJsZSBpbiBhIG1pY3JvdGFza1xuICAgICAgICAgIC8vIG1ha2luZyBpdCBjb21wYXRpYmxlIHdpdGggZHluYW1pY0lPLlxuICAgICAgICAgIGNvbnN0IHBlbmRpbmdSZXNwb25zZSA9IGRvT3JpZ2luYWxGZXRjaCh0cnVlLCBjYWNoZVJlYXNvbk92ZXJyaWRlKVxuICAgICAgICAgICAgLy8gV2UncmUgY2xvbmluZyB0aGUgcmVzcG9uc2UgdXNpbmcgdGhpcyB1dGlsaXR5IGJlY2F1c2UgdGhlcmVcbiAgICAgICAgICAgIC8vIGV4aXN0cyBhIGJ1ZyBpbiB0aGUgdW5kaWNpIGxpYnJhcnkgYXJvdW5kIHJlc3BvbnNlIGNsb25pbmcuXG4gICAgICAgICAgICAvLyBTZWUgdGhlIGZvbGxvd2luZyBwdWxsIHJlcXVlc3QgZm9yIG1vcmUgZGV0YWlsczpcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvbmV4dC5qcy9wdWxsLzczMjc0XG4gICAgICAgICAgICAudGhlbihjbG9uZVJlc3BvbnNlKVxuXG4gICAgICAgICAgcGVuZGluZ1JldmFsaWRhdGUgPSBwZW5kaW5nUmVzcG9uc2VcbiAgICAgICAgICAgIC50aGVuKGFzeW5jIChyZXNwb25zZXMpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSByZXNwb25zZXNbMF1cbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBib2R5OiBhd2FpdCByZXNwb25zZS5hcnJheUJ1ZmZlcigpLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgICAgLy8gSWYgdGhlIHBlbmRpbmcgcmV2YWxpZGF0ZSBpcyBub3QgcHJlc2VudCBpbiB0aGUgc3RvcmUsIHRoZW5cbiAgICAgICAgICAgICAgLy8gd2UgaGF2ZSBub3RoaW5nIHRvIGRlbGV0ZS5cbiAgICAgICAgICAgICAgaWYgKCF3b3JrU3RvcmUucGVuZGluZ1JldmFsaWRhdGVzPy5bcGVuZGluZ1JldmFsaWRhdGVLZXldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBkZWxldGUgd29ya1N0b3JlLnBlbmRpbmdSZXZhbGlkYXRlc1twZW5kaW5nUmV2YWxpZGF0ZUtleV1cbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAvLyBBdHRhY2ggdGhlIGVtcHR5IGNhdGNoIGhlcmUgc28gd2UgZG9uJ3QgZ2V0IGEgXCJ1bmhhbmRsZWQgcHJvbWlzZVxuICAgICAgICAgIC8vIHJlamVjdGlvblwiIHdhcm5pbmdcbiAgICAgICAgICBwZW5kaW5nUmV2YWxpZGF0ZS5jYXRjaCgoKSA9PiB7fSlcblxuICAgICAgICAgIHdvcmtTdG9yZS5wZW5kaW5nUmV2YWxpZGF0ZXNbcGVuZGluZ1JldmFsaWRhdGVLZXldID0gcGVuZGluZ1JldmFsaWRhdGVcblxuICAgICAgICAgIHJldHVybiBwZW5kaW5nUmVzcG9uc2UudGhlbigocmVzcG9uc2VzKSA9PiByZXNwb25zZXNbMV0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGRvT3JpZ2luYWxGZXRjaChmYWxzZSwgY2FjaGVSZWFzb25PdmVycmlkZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIClcblxuICAgIGlmIChjYWNoZVNpZ25hbCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHJlc3VsdFxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGNhY2hlU2lnbmFsKSB7XG4gICAgICAgICAgY2FjaGVTaWduYWwuZW5kUmVhZCgpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgLy8gQXR0YWNoIHRoZSBuZWNlc3NhcnkgcHJvcGVydGllcyB0byB0aGUgcGF0Y2hlZCBmZXRjaCBmdW5jdGlvbi5cbiAgLy8gV2UgZG9uJ3QgdXNlIHRoaXMgdG8gZGV0ZXJtaW5lIGlmIHRoZSBmZXRjaCBmdW5jdGlvbiBoYXMgYmVlbiBwYXRjaGVkLFxuICAvLyBidXQgZm9yIGV4dGVybmFsIGNvbnN1bWVycyB0byBkZXRlcm1pbmUgaWYgdGhlIGZldGNoIGZ1bmN0aW9uIGhhcyBiZWVuXG4gIC8vIHBhdGNoZWQuXG4gIHBhdGNoZWQuX19uZXh0UGF0Y2hlZCA9IHRydWUgYXMgY29uc3RcbiAgcGF0Y2hlZC5fX25leHRHZXRTdGF0aWNTdG9yZSA9ICgpID0+IHdvcmtBc3luY1N0b3JhZ2VcbiAgcGF0Y2hlZC5fbmV4dE9yaWdpbmFsRmV0Y2ggPSBvcmlnaW5GZXRjaFxuICA7KGdsb2JhbFRoaXMgYXMgUmVjb3JkPHN5bWJvbCwgdW5rbm93bj4pW05FWFRfUEFUQ0hfU1lNQk9MXSA9IHRydWVcblxuICAvLyBBc3NpZ24gdGhlIGZ1bmN0aW9uIG5hbWUgYWxzbyBhcyBhIG5hbWUgcHJvcGVydHksIHNvIHRoYXQgaXQncyBwcmVzZXJ2ZWRcbiAgLy8gZXZlbiB3aGVuIG1hbmdsaW5nIGlzIGVuYWJsZWQuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwYXRjaGVkLCAnbmFtZScsIHsgdmFsdWU6ICdmZXRjaCcsIHdyaXRhYmxlOiBmYWxzZSB9KVxuXG4gIHJldHVybiBwYXRjaGVkXG59XG4vLyB3ZSBwYXRjaCBmZXRjaCB0byBjb2xsZWN0IGNhY2hlIGluZm9ybWF0aW9uIHVzZWQgZm9yXG4vLyBkZXRlcm1pbmluZyBpZiBhIHBhZ2UgaXMgc3RhdGljIG9yIG5vdFxuZXhwb3J0IGZ1bmN0aW9uIHBhdGNoRmV0Y2gob3B0aW9uczogUGF0Y2hhYmxlTW9kdWxlKSB7XG4gIC8vIElmIHdlJ3ZlIGFscmVhZHkgcGF0Y2hlZCBmZXRjaCwgd2Ugc2hvdWxkIG5vdCBwYXRjaCBpdCBhZ2Fpbi5cbiAgaWYgKGlzRmV0Y2hQYXRjaGVkKCkpIHJldHVyblxuXG4gIC8vIEdyYWIgdGhlIG9yaWdpbmFsIGZldGNoIGZ1bmN0aW9uLiBXZSdsbCBhdHRhY2ggdGhpcyBzbyB3ZSBjYW4gdXNlIGl0IGluXG4gIC8vIHRoZSBwYXRjaGVkIGZldGNoIGZ1bmN0aW9uLlxuICBjb25zdCBvcmlnaW5hbCA9IGNyZWF0ZURlZHVwZUZldGNoKGdsb2JhbFRoaXMuZmV0Y2gpXG5cbiAgLy8gU2V0IHRoZSBnbG9iYWwgZmV0Y2ggdG8gdGhlIHBhdGNoZWQgZmV0Y2guXG4gIGdsb2JhbFRoaXMuZmV0Y2ggPSBjcmVhdGVQYXRjaGVkRmV0Y2hlcihvcmlnaW5hbCwgb3B0aW9ucylcbn1cbiJdLCJuYW1lcyI6WyJBcHBSZW5kZXJTcGFuIiwiTmV4dE5vZGVTZXJ2ZXJTcGFuIiwiZ2V0VHJhY2VyIiwiU3BhbktpbmQiLCJDQUNIRV9PTkVfWUVBUiIsIklORklOSVRFX0NBQ0hFIiwiTkVYVF9DQUNIRV9UQUdfTUFYX0lURU1TIiwiTkVYVF9DQUNIRV9UQUdfTUFYX0xFTkdUSCIsIm1hcmtDdXJyZW50U2NvcGVBc0R5bmFtaWMiLCJtYWtlSGFuZ2luZ1Byb21pc2UiLCJjcmVhdGVEZWR1cGVGZXRjaCIsIkNhY2hlZFJvdXRlS2luZCIsIkluY3JlbWVudGFsQ2FjaGVLaW5kIiwid2FpdEF0TGVhc3RPbmVSZWFjdFJlbmRlclRhc2siLCJjbG9uZVJlc3BvbnNlIiwiaXNFZGdlUnVudGltZSIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1JVTlRJTUUiLCJORVhUX1BBVENIX1NZTUJPTCIsIlN5bWJvbCIsImZvciIsImlzRmV0Y2hQYXRjaGVkIiwiZ2xvYmFsVGhpcyIsInZhbGlkYXRlUmV2YWxpZGF0ZSIsInJldmFsaWRhdGVWYWwiLCJyb3V0ZSIsIm5vcm1hbGl6ZWRSZXZhbGlkYXRlIiwidW5kZWZpbmVkIiwiaXNOYU4iLCJFcnJvciIsImVyciIsIm1lc3NhZ2UiLCJpbmNsdWRlcyIsInZhbGlkYXRlVGFncyIsInRhZ3MiLCJkZXNjcmlwdGlvbiIsInZhbGlkVGFncyIsImludmFsaWRUYWdzIiwiaSIsImxlbmd0aCIsInRhZyIsInB1c2giLCJyZWFzb24iLCJjb25zb2xlIiwid2FybiIsInNsaWNlIiwiam9pbiIsImxvZyIsInRyYWNrRmV0Y2hNZXRyaWMiLCJ3b3JrU3RvcmUiLCJjdHgiLCJyZXF1ZXN0RW5kZWRTdGF0ZSIsImVuZGVkIiwiaXNEZWJ1Z0J1aWxkIiwiTkVYVF9ERUJVR19CVUlMRCIsIk5FWFRfU1NHX0ZFVENIX01FVFJJQ1MiLCJpc1N0YXRpY0dlbmVyYXRpb24iLCJpc0RldmVsb3BtZW50IiwiTk9ERV9FTlYiLCJmZXRjaE1ldHJpY3MiLCJlbmQiLCJwZXJmb3JtYW5jZSIsInRpbWVPcmlnaW4iLCJub3ciLCJpZHgiLCJuZXh0RmV0Y2hJZCIsImNyZWF0ZVBhdGNoZWRGZXRjaGVyIiwib3JpZ2luRmV0Y2giLCJ3b3JrQXN5bmNTdG9yYWdlIiwid29ya1VuaXRBc3luY1N0b3JhZ2UiLCJwYXRjaGVkIiwiZmV0Y2giLCJpbnB1dCIsImluaXQiLCJ1cmwiLCJVUkwiLCJSZXF1ZXN0IiwidXNlcm5hbWUiLCJwYXNzd29yZCIsImZldGNoVXJsIiwiaHJlZiIsIm1ldGhvZCIsInRvVXBwZXJDYXNlIiwiaXNJbnRlcm5hbCIsIm5leHQiLCJpbnRlcm5hbCIsImhpZGVTcGFuIiwiTkVYVF9PVEVMX0ZFVENIX0RJU0FCTEVEIiwiZmV0Y2hTdGFydCIsImdldFN0b3JlIiwid29ya1VuaXRTdG9yZSIsImNhY2hlU2lnbmFsIiwidHlwZSIsImJlZ2luUmVhZCIsInJlc3VsdCIsInRyYWNlIiwiaW50ZXJuYWxGZXRjaCIsImtpbmQiLCJDTElFTlQiLCJzcGFuTmFtZSIsImZpbHRlciIsIkJvb2xlYW4iLCJhdHRyaWJ1dGVzIiwiaG9zdG5hbWUiLCJwb3J0IiwiZ2V0UmVxdWVzdE1ldGEiLCJpc0RyYWZ0TW9kZSIsImlzUmVxdWVzdElucHV0IiwiZmllbGQiLCJ2YWx1ZSIsImZpbmFsUmV2YWxpZGF0ZSIsImdldE5leHRGaWVsZCIsIm9yaWdpbmFsRmV0Y2hSZXZhbGlkYXRlIiwiY3VycmVudEZldGNoUmV2YWxpZGF0ZSIsInRvU3RyaW5nIiwicmV2YWxpZGF0ZVN0b3JlIiwiQXJyYXkiLCJpc0FycmF5IiwiY29sbGVjdGVkVGFncyIsImltcGxpY2l0VGFncyIsInBhZ2VGZXRjaENhY2hlTW9kZSIsImZldGNoQ2FjaGUiLCJpc1VzaW5nTm9TdG9yZSIsImlzVW5zdGFibGVOb1N0b3JlIiwiY3VycmVudEZldGNoQ2FjaGVDb25maWciLCJjYWNoZVJlYXNvbiIsImNhY2hlV2FybmluZyIsImlzQ29uZmxpY3RpbmdSZXZhbGlkYXRlIiwiaGFzRXhwbGljaXRGZXRjaENhY2hlT3B0T3V0Iiwibm9GZXRjaENvbmZpZ0FuZEZvcmNlRHluYW1pYyIsImZvcmNlRHluYW1pYyIsIl9oZWFkZXJzIiwiaW5pdEhlYWRlcnMiLCJnZXQiLCJIZWFkZXJzIiwiaGFzVW5DYWNoZWFibGVIZWFkZXIiLCJpc1VuQ2FjaGVhYmxlTWV0aG9kIiwidG9Mb3dlckNhc2UiLCJoYXNOb0V4cGxpY2l0Q2FjaGVDb25maWciLCJhdXRvTm9DYWNoZSIsInJldmFsaWRhdGUiLCJpc0ltcGxpY2l0QnVpbGRUaW1lQ2FjaGUiLCJpc0J1aWxkVGltZVByZXJlbmRlcmluZyIsImVuZFJlYWQiLCJyZW5kZXJTaWduYWwiLCJmb3JjZVN0YXRpYyIsImlzQ2FjaGVhYmxlUmV2YWxpZGF0ZSIsImNhY2hlS2V5IiwiaW5jcmVtZW50YWxDYWNoZSIsInVzZUNhY2hlT3JSZXF1ZXN0U3RvcmUiLCJzZXJ2ZXJDb21wb25lbnRzSG1yQ2FjaGUiLCJnZW5lcmF0ZUNhY2hlS2V5IiwiZXJyb3IiLCJmZXRjaElkeCIsImhhbmRsZVVubG9jayIsImRvT3JpZ2luYWxGZXRjaCIsImlzU3RhbGUiLCJjYWNoZVJlYXNvbk92ZXJyaWRlIiwicmVxdWVzdElucHV0RmllbGRzIiwicmVxSW5wdXQiLCJyZXFPcHRpb25zIiwiYm9keSIsIl9vZ0JvZHkiLCJzaWduYWwiLCJvdGhlcklucHV0IiwiY2xvbmVkSW5pdCIsImZldGNoVHlwZSIsInRoZW4iLCJyZXMiLCJzdGFydCIsImNhY2hlU3RhdHVzIiwic3RhdHVzIiwiYm9keUJ1ZmZlciIsImFycmF5QnVmZmVyIiwiZmV0Y2hlZERhdGEiLCJoZWFkZXJzIiwiT2JqZWN0IiwiZnJvbUVudHJpZXMiLCJlbnRyaWVzIiwiQnVmZmVyIiwiZnJvbSIsInNldCIsIkZFVENIIiwiZGF0YSIsIlJlc3BvbnNlIiwic3RhdHVzVGV4dCIsImNsb25lZDEiLCJjbG9uZWQyIiwiY2FjaGVTZXRQcm9taXNlIiwiY2F0Y2giLCJmaW5hbGx5IiwicGVuZGluZ1JldmFsaWRhdGVLZXkiLCJwZW5kaW5nUmV2YWxpZGF0ZXMiLCJpc0ZvcmVncm91bmRSZXZhbGlkYXRlIiwiaXNIbXJSZWZyZXNoQ2FjaGUiLCJjYWNoZWRGZXRjaERhdGEiLCJpc0htclJlZnJlc2giLCJsb2NrIiwiZW50cnkiLCJpc09uRGVtYW5kUmV2YWxpZGF0ZSIsInNvZnRUYWdzIiwiaXNSZXZhbGlkYXRlIiwicGVuZGluZ1JldmFsaWRhdGUiLCJyZXNwb25zZSIsImRlZmluZVByb3BlcnR5IiwiY2FjaGUiLCJoYXNOZXh0Q29uZmlnIiwicmV2YWxpZGF0ZWRSZXN1bHQiLCJwZW5kaW5nUmVzcG9uc2UiLCJyZXNwb25zZXMiLCJfX25leHRQYXRjaGVkIiwiX19uZXh0R2V0U3RhdGljU3RvcmUiLCJfbmV4dE9yaWdpbmFsRmV0Y2giLCJ3cml0YWJsZSIsInBhdGNoRmV0Y2giLCJvcHRpb25zIiwib3JpZ2luYWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFLQSxTQUFTQSxhQUFhLEVBQUVDLGtCQUFrQixR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O1FBQ0EsT0FBT2pEO0lBQ1Q7SUFFQSxpRUFBaUU7SUFDakUseUVBQXlFO0lBQ3pFLHlFQUF5RTtJQUN6RSxXQUFXO0lBQ1h4QixRQUFRNEksYUFBYSxHQUFHO0lBQ3hCNUksUUFBUTZJLG9CQUFvQixHQUFHLElBQU0vSTtJQUNyQ0UsUUFBUThJLGtCQUFrQixHQUFHako7SUFDM0I3QyxVQUFzQyxDQUFDSixrQkFBa0IsR0FBRztJQUU5RCwyRUFBMkU7SUFDM0UsaUNBQWlDO0lBQ2pDOEosT0FBTzRCLGNBQWMsQ0FBQ3RJLFNBQVMsUUFBUTtRQUFFdUMsT0FBTztRQUFTd0csVUFBVTtJQUFNO0lBRXpFLE9BQU8vSTtBQUNUO0FBR08sU0FBU2dKLFdBQVdDLE9BQXdCO0lBQ2pELGdFQUFnRTtJQUNoRSxJQUFJbE0sa0JBQWtCO0lBRXRCLDBFQUEwRTtJQUMxRSw4QkFBOEI7SUFDOUIsTUFBTW1NLHVMQUFXL00sb0JBQUFBLEVBQWtCYSxXQUFXaUQsS0FBSztJQUVuRCw2Q0FBNkM7SUFDN0NqRCxXQUFXaUQsS0FBSyxHQUFHTCxxQkFBcUJzSixVQUFVRDtBQUNwRCIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxNDI5NywgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvZXNtL25leHQtZGV2dG9vbHMvdXNlcnNwYWNlL2FwcC9zZWdtZW50LWV4cGxvcmVyLW5vZGUuanMvcHJveHkuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHsgY3JlYXRlQ2xpZW50TW9kdWxlUHJveHkgfSA9IHJlcXVpcmUoXCJyZWFjdC1zZXJ2ZXItZG9tLXR1cmJvcGFjay9zZXJ2ZXJcIik7XG5cbl9fdHVyYm9wYWNrX2NvbnRleHRfXy5uKGNyZWF0ZUNsaWVudE1vZHVsZVByb3h5KFwiW3Byb2plY3RdL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvZXNtL25leHQtZGV2dG9vbHMvdXNlcnNwYWNlL2FwcC9zZWdtZW50LWV4cGxvcmVyLW5vZGUuanMgPG1vZHVsZSBldmFsdWF0aW9uPlwiKSk7XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsTUFBTSxFQUFFLHVCQUF1QixFQUFFO0FBRWpDLHNCQUFzQixDQUFDLENBQUMsd0JBQXdCIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDE0MzA0LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9lc20vbmV4dC1kZXZ0b29scy91c2Vyc3BhY2UvYXBwL3NlZ21lbnQtZXhwbG9yZXItbm9kZS5qcy9wcm94eS5janMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgeyBjcmVhdGVDbGllbnRNb2R1bGVQcm94eSB9ID0gcmVxdWlyZShcInJlYWN0LXNlcnZlci1kb20tdHVyYm9wYWNrL3NlcnZlclwiKTtcblxuX190dXJib3BhY2tfY29udGV4dF9fLm4oY3JlYXRlQ2xpZW50TW9kdWxlUHJveHkoXCJbcHJvamVjdF0vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9lc20vbmV4dC1kZXZ0b29scy91c2Vyc3BhY2UvYXBwL3NlZ21lbnQtZXhwbG9yZXItbm9kZS5qc1wiKSk7XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsTUFBTSxFQUFFLHVCQUF1QixFQUFFO0FBRWpDLHNCQUFzQixDQUFDLENBQUMsd0JBQXdCIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDE0MzEwLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zcmMvbmV4dC1kZXZ0b29scy91c2Vyc3BhY2UvYXBwL3NlZ21lbnQtZXhwbG9yZXItbm9kZS50c3giXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbmltcG9ydCB0eXBlIHsgUmVhY3ROb2RlIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQge1xuICB1c2VTdGF0ZSxcbiAgY3JlYXRlQ29udGV4dCxcbiAgdXNlQ29udGV4dCxcbiAgdXNlLFxuICB1c2VNZW1vLFxuICB1c2VDYWxsYmFjayxcbn0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IGRpc3BhdGNoZXIgfSBmcm9tICduZXh0L2Rpc3QvY29tcGlsZWQvbmV4dC1kZXZ0b29scydcbmltcG9ydCB7IG5vdEZvdW5kIH0gZnJvbSAnLi4vLi4vLi4vY2xpZW50L2NvbXBvbmVudHMvbm90LWZvdW5kJ1xuXG5leHBvcnQgY29uc3QgU0VHTUVOVF9FWFBMT1JFUl9TSU1VTEFURURfRVJST1JfTUVTU0FHRSA9XG4gICdORVhUX0RFVlRPT0xTX1NJTVVMQVRFRF9FUlJPUidcblxuZXhwb3J0IHR5cGUgU2VnbWVudE5vZGVTdGF0ZSA9IHtcbiAgdHlwZTogc3RyaW5nXG4gIHBhZ2VQYXRoOiBzdHJpbmdcbiAgYm91bmRhcnlUeXBlOiBzdHJpbmcgfCBudWxsXG4gIHNldEJvdW5kYXJ5VHlwZTogKHR5cGU6ICdlcnJvcicgfCAnbm90LWZvdW5kJyB8ICdsb2FkaW5nJyB8IG51bGwpID0+IHZvaWRcbn1cblxuZnVuY3Rpb24gU2VnbWVudFRyaWVOb2RlKHtcbiAgdHlwZSxcbiAgcGFnZVBhdGgsXG59OiB7XG4gIHR5cGU6IHN0cmluZ1xuICBwYWdlUGF0aDogc3RyaW5nXG59KTogUmVhY3QuUmVhY3ROb2RlIHtcbiAgY29uc3QgeyBib3VuZGFyeVR5cGUsIHNldEJvdW5kYXJ5VHlwZSB9ID0gdXNlU2VnbWVudFN0YXRlKClcbiAgY29uc3Qgbm9kZVN0YXRlOiBTZWdtZW50Tm9kZVN0YXRlID0gdXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGUsXG4gICAgICBwYWdlUGF0aCxcbiAgICAgIGJvdW5kYXJ5VHlwZSxcbiAgICAgIHNldEJvdW5kYXJ5VHlwZSxcbiAgICB9XG4gIH0sIFt0eXBlLCBwYWdlUGF0aCwgYm91bmRhcnlUeXBlLCBzZXRCb3VuZGFyeVR5cGVdKVxuXG4gIC8vIFVzZSBgdXNlTGF5b3V0RWZmZWN0YCB0byBlbnN1cmUgdGhlIHN0YXRlIGlzIHVwZGF0ZWQgZHVyaW5nIHN1c3BlbnNlLlxuICAvLyBgdXNlRWZmZWN0YCB3b24ndCB3b3JrIGFzIHRoZSBzdGF0ZSBpcyBwcmVzZXJ2ZWQgZHVyaW5nIHN1c3BlbnNlLlxuICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGRpc3BhdGNoZXIuc2VnbWVudEV4cGxvcmVyTm9kZUFkZChub2RlU3RhdGUpXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGRpc3BhdGNoZXIuc2VnbWVudEV4cGxvcmVyTm9kZVJlbW92ZShub2RlU3RhdGUpXG4gICAgfVxuICB9LCBbbm9kZVN0YXRlXSlcblxuICByZXR1cm4gbnVsbFxufVxuXG5mdW5jdGlvbiBOb3RGb3VuZFNlZ21lbnROb2RlKCk6IFJlYWN0LlJlYWN0Tm9kZSB7XG4gIG5vdEZvdW5kKClcbn1cblxuZnVuY3Rpb24gRXJyb3JTZWdtZW50Tm9kZSgpOiBSZWFjdC5SZWFjdE5vZGUge1xuICB0aHJvdyBuZXcgRXJyb3IoU0VHTUVOVF9FWFBMT1JFUl9TSU1VTEFURURfRVJST1JfTUVTU0FHRSlcbn1cblxuY29uc3QgZm9yZXZlciA9IG5ldyBQcm9taXNlKCgpID0+IHt9KVxuZnVuY3Rpb24gTG9hZGluZ1NlZ21lbnROb2RlKCk6IFJlYWN0LlJlYWN0Tm9kZSB7XG4gIHVzZShmb3JldmVyKVxuICByZXR1cm4gbnVsbFxufVxuXG5leHBvcnQgZnVuY3Rpb24gU2VnbWVudFZpZXdTdGF0ZU5vZGUoeyBwYWdlIH06IHsgcGFnZTogc3RyaW5nIH0pIHtcbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBkaXNwYXRjaGVyLnNlZ21lbnRFeHBsb3JlclVwZGF0ZVJvdXRlU3RhdGUocGFnZSlcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZGlzcGF0Y2hlci5zZWdtZW50RXhwbG9yZXJVcGRhdGVSb3V0ZVN0YXRlKCcnKVxuICAgIH1cbiAgfSwgW3BhZ2VdKVxuICByZXR1cm4gbnVsbFxufVxuXG5leHBvcnQgZnVuY3Rpb24gU2VnbWVudEJvdW5kYXJ5VHJpZ2dlck5vZGUoKSB7XG4gIGNvbnN0IHsgYm91bmRhcnlUeXBlIH0gPSB1c2VTZWdtZW50U3RhdGUoKVxuICBsZXQgc2VnbWVudE5vZGU6IFJlYWN0LlJlYWN0Tm9kZSA9IG51bGxcbiAgaWYgKGJvdW5kYXJ5VHlwZSA9PT0gJ2xvYWRpbmcnKSB7XG4gICAgc2VnbWVudE5vZGUgPSA8TG9hZGluZ1NlZ21lbnROb2RlIC8+XG4gIH0gZWxzZSBpZiAoYm91bmRhcnlUeXBlID09PSAnbm90LWZvdW5kJykge1xuICAgIHNlZ21lbnROb2RlID0gPE5vdEZvdW5kU2VnbWVudE5vZGUgLz5cbiAgfSBlbHNlIGlmIChib3VuZGFyeVR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBzZWdtZW50Tm9kZSA9IDxFcnJvclNlZ21lbnROb2RlIC8+XG4gIH1cbiAgcmV0dXJuIHNlZ21lbnROb2RlXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBTZWdtZW50Vmlld05vZGUoe1xuICB0eXBlLFxuICBwYWdlUGF0aCxcbiAgY2hpbGRyZW4sXG59OiB7XG4gIHR5cGU6IHN0cmluZ1xuICBwYWdlUGF0aDogc3RyaW5nXG4gIGNoaWxkcmVuPzogUmVhY3ROb2RlXG59KTogUmVhY3QuUmVhY3ROb2RlIHtcbiAgY29uc3Qgc2VnbWVudE5vZGUgPSAoXG4gICAgPFNlZ21lbnRUcmllTm9kZSBrZXk9e3R5cGV9IHR5cGU9e3R5cGV9IHBhZ2VQYXRoPXtwYWdlUGF0aH0gLz5cbiAgKVxuXG4gIHJldHVybiAoXG4gICAgPD5cbiAgICAgIHtzZWdtZW50Tm9kZX1cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8Lz5cbiAgKVxufVxuXG5jb25zdCBTZWdtZW50U3RhdGVDb250ZXh0ID0gY3JlYXRlQ29udGV4dDx7XG4gIGJvdW5kYXJ5VHlwZTogJ25vdC1mb3VuZCcgfCAnZXJyb3InIHwgJ2xvYWRpbmcnIHwgbnVsbFxuICBzZXRCb3VuZGFyeVR5cGU6ICh0eXBlOiAnbm90LWZvdW5kJyB8ICdlcnJvcicgfCAnbG9hZGluZycgfCBudWxsKSA9PiB2b2lkXG59Pih7XG4gIGJvdW5kYXJ5VHlwZTogbnVsbCxcbiAgc2V0Qm91bmRhcnlUeXBlOiAoKSA9PiB7fSxcbn0pXG5cbmV4cG9ydCBmdW5jdGlvbiBTZWdtZW50U3RhdGVQcm92aWRlcih7IGNoaWxkcmVuIH06IHsgY2hpbGRyZW46IFJlYWN0Tm9kZSB9KSB7XG4gIGNvbnN0IFtib3VuZGFyeVR5cGUsIHNldEJvdW5kYXJ5VHlwZV0gPSB1c2VTdGF0ZTxcbiAgICAnbm90LWZvdW5kJyB8ICdlcnJvcicgfCAnbG9hZGluZycgfCBudWxsXG4gID4obnVsbClcblxuICBjb25zdCBbZXJyb3JCb3VuZGFyeUtleSwgc2V0RXJyb3JCb3VuZGFyeUtleV0gPSB1c2VTdGF0ZSgwKVxuICBjb25zdCByZWxvYWRCb3VuZGFyeSA9IHVzZUNhbGxiYWNrKFxuICAgICgpID0+IHNldEVycm9yQm91bmRhcnlLZXkoKHByZXYpID0+IHByZXYgKyAxKSxcbiAgICBbXVxuICApXG5cbiAgY29uc3Qgc2V0Qm91bmRhcnlUeXBlQW5kUmVsb2FkID0gdXNlQ2FsbGJhY2soXG4gICAgKHR5cGU6ICdub3QtZm91bmQnIHwgJ2Vycm9yJyB8ICdsb2FkaW5nJyB8IG51bGwpID0+IHtcbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHJlbG9hZEJvdW5kYXJ5KClcbiAgICAgIH1cbiAgICAgIHNldEJvdW5kYXJ5VHlwZSh0eXBlKVxuICAgIH0sXG4gICAgW3JlbG9hZEJvdW5kYXJ5XVxuICApXG5cbiAgcmV0dXJuIChcbiAgICA8U2VnbWVudFN0YXRlQ29udGV4dC5Qcm92aWRlclxuICAgICAga2V5PXtlcnJvckJvdW5kYXJ5S2V5fVxuICAgICAgdmFsdWU9e3tcbiAgICAgICAgYm91bmRhcnlUeXBlLFxuICAgICAgICBzZXRCb3VuZGFyeVR5cGU6IHNldEJvdW5kYXJ5VHlwZUFuZFJlbG9hZCxcbiAgICAgIH19XG4gICAgPlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvU2VnbWVudFN0YXRlQ29udGV4dC5Qcm92aWRlcj5cbiAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlU2VnbWVudFN0YXRlKCkge1xuICByZXR1cm4gdXNlQ29udGV4dChTZWdtZW50U3RhdGVDb250ZXh0KVxufVxuIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2UiLCJ1c2VNZW1vIiwidXNlQ2FsbGJhY2siLCJ1c2VMYXlvdXRFZmZlY3QiLCJkaXNwYXRjaGVyIiwibm90Rm91bmQiLCJTRUdNRU5UX0VYUExPUkVSX1NJTVVMQVRFRF9FUlJPUl9NRVNTQUdFIiwiU2VnbWVudFRyaWVOb2RlIiwidHlwZSIsInBhZ2VQYXRoIiwiYm91bmRhcnlUeXBlIiwic2V0Qm91bmRhcnlUeXBlIiwidXNlU2VnbWVudFN0YXRlIiwibm9kZVN0YXRlIiwic2VnbWVudEV4cGxvcmVyTm9kZUFkZCIsInNlZ21lbnRFeHBsb3Jlck5vZGVSZW1vdmUiLCJOb3RGb3VuZFNlZ21lbnROb2RlIiwiRXJyb3JTZWdtZW50Tm9kZSIsIkVycm9yIiwiZm9yZXZlciIsIlByb21pc2UiLCJMb2FkaW5nU2VnbWVudE5vZGUiLCJTZWdtZW50Vmlld1N0YXRlTm9kZSIsInBhZ2UiLCJzZWdtZW50RXhwbG9yZXJVcGRhdGVSb3V0ZVN0YXRlIiwiU2VnbWVudEJvdW5kYXJ5VHJpZ2dlck5vZGUiLCJzZWdtZW50Tm9kZSIsIlNlZ21lbnRWaWV3Tm9kZSIsImNoaWxkcmVuIiwiU2VnbWVudFN0YXRlQ29udGV4dCIsIlNlZ21lbnRTdGF0ZVByb3ZpZGVyIiwiZXJyb3JCb3VuZGFyeUtleSIsInNldEVycm9yQm91bmRhcnlLZXkiLCJyZWxvYWRCb3VuZGFyeSIsInByZXYiLCJzZXRCb3VuZGFyeVR5cGVBbmRSZWxvYWQiLCJQcm92aWRlciIsInZhbHVlIl0sIm1hcHBpbmdzIjoiIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDE0MzE4LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zcmMvc2VydmVyL2FwcC1yZW5kZXIvZW50cnktYmFzZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzXG5leHBvcnQge1xuICBjcmVhdGVUZW1wb3JhcnlSZWZlcmVuY2VTZXQsXG4gIHJlbmRlclRvUmVhZGFibGVTdHJlYW0sXG4gIGRlY29kZVJlcGx5LFxuICBkZWNvZGVBY3Rpb24sXG4gIGRlY29kZUZvcm1TdGF0ZSxcbn0gZnJvbSAncmVhY3Qtc2VydmVyLWRvbS13ZWJwYWNrL3NlcnZlcidcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1leHRyYW5lb3VzLWRlcGVuZGVuY2llc1xuZXhwb3J0IHsgdW5zdGFibGVfcHJlcmVuZGVyIGFzIHByZXJlbmRlciB9IGZyb20gJ3JlYWN0LXNlcnZlci1kb20td2VicGFjay9zdGF0aWMnXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tZXh0cmFuZW91cy1kZXBlbmRlbmNpZXNcbmV4cG9ydCB7IGNhcHR1cmVPd25lclN0YWNrIH0gZnJvbSAncmVhY3QnXG5cbmV4cG9ydCB7IGRlZmF1bHQgYXMgTGF5b3V0Um91dGVyIH0gZnJvbSAnLi4vLi4vY2xpZW50L2NvbXBvbmVudHMvbGF5b3V0LXJvdXRlcidcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUmVuZGVyRnJvbVRlbXBsYXRlQ29udGV4dCB9IGZyb20gJy4uLy4uL2NsaWVudC9jb21wb25lbnRzL3JlbmRlci1mcm9tLXRlbXBsYXRlLWNvbnRleHQnXG5leHBvcnQgeyB3b3JrQXN5bmNTdG9yYWdlIH0gZnJvbSAnLi4vYXBwLXJlbmRlci93b3JrLWFzeW5jLXN0b3JhZ2UuZXh0ZXJuYWwnXG5leHBvcnQgeyB3b3JrVW5pdEFzeW5jU3RvcmFnZSB9IGZyb20gJy4vd29yay11bml0LWFzeW5jLXN0b3JhZ2UuZXh0ZXJuYWwnXG5leHBvcnQgeyBhY3Rpb25Bc3luY1N0b3JhZ2UgfSBmcm9tICcuLi9hcHAtcmVuZGVyL2FjdGlvbi1hc3luYy1zdG9yYWdlLmV4dGVybmFsJ1xuXG5leHBvcnQgeyBDbGllbnRQYWdlUm9vdCB9IGZyb20gJy4uLy4uL2NsaWVudC9jb21wb25lbnRzL2NsaWVudC1wYWdlJ1xuZXhwb3J0IHsgQ2xpZW50U2VnbWVudFJvb3QgfSBmcm9tICcuLi8uLi9jbGllbnQvY29tcG9uZW50cy9jbGllbnQtc2VnbWVudCdcbmV4cG9ydCB7XG4gIGNyZWF0ZVNlcnZlclNlYXJjaFBhcmFtc0ZvclNlcnZlclBhZ2UsXG4gIGNyZWF0ZVByZXJlbmRlclNlYXJjaFBhcmFtc0ZvckNsaWVudFBhZ2UsXG59IGZyb20gJy4uL3JlcXVlc3Qvc2VhcmNoLXBhcmFtcydcbmV4cG9ydCB7XG4gIGNyZWF0ZVNlcnZlclBhcmFtc0ZvclNlcnZlclNlZ21lbnQsXG4gIGNyZWF0ZVByZXJlbmRlclBhcmFtc0ZvckNsaWVudFNlZ21lbnQsXG59IGZyb20gJy4uL3JlcXVlc3QvcGFyYW1zJ1xuZXhwb3J0ICogYXMgc2VydmVySG9va3MgZnJvbSAnLi4vLi4vY2xpZW50L2NvbXBvbmVudHMvaG9va3Mtc2VydmVyLWNvbnRleHQnXG5leHBvcnQgeyBIVFRQQWNjZXNzRmFsbGJhY2tCb3VuZGFyeSB9IGZyb20gJy4uLy4uL2NsaWVudC9jb21wb25lbnRzL2h0dHAtYWNjZXNzLWZhbGxiYWNrL2Vycm9yLWJvdW5kYXJ5J1xuZXhwb3J0IHsgY3JlYXRlTWV0YWRhdGFDb21wb25lbnRzIH0gZnJvbSAnLi4vLi4vbGliL21ldGFkYXRhL21ldGFkYXRhJ1xuZXhwb3J0IHtcbiAgTWV0YWRhdGFCb3VuZGFyeSxcbiAgVmlld3BvcnRCb3VuZGFyeSxcbiAgT3V0bGV0Qm91bmRhcnksXG59IGZyb20gJy4uLy4uL2NsaWVudC9jb21wb25lbnRzL21ldGFkYXRhL21ldGFkYXRhLWJvdW5kYXJ5J1xuXG5leHBvcnQgeyBwcmVsb2FkU3R5bGUsIHByZWxvYWRGb250LCBwcmVjb25uZWN0IH0gZnJvbSAnLi9yc2MvcHJlbG9hZHMnXG5leHBvcnQgeyBQb3N0cG9uZSB9IGZyb20gJy4vcnNjL3Bvc3Rwb25lJ1xuZXhwb3J0IHsgdGFpbnRPYmplY3RSZWZlcmVuY2UgfSBmcm9tICcuL3JzYy90YWludCdcbmV4cG9ydCB7IGNvbGxlY3RTZWdtZW50RGF0YSB9IGZyb20gJy4vY29sbGVjdC1zZWdtZW50LWRhdGEnXG5cbmltcG9ydCB7IHdvcmtBc3luY1N0b3JhZ2UgfSBmcm9tICcuLi9hcHAtcmVuZGVyL3dvcmstYXN5bmMtc3RvcmFnZS5leHRlcm5hbCdcbmltcG9ydCB7IHdvcmtVbml0QXN5bmNTdG9yYWdlIH0gZnJvbSAnLi93b3JrLXVuaXQtYXN5bmMtc3RvcmFnZS5leHRlcm5hbCdcbmltcG9ydCB7IHBhdGNoRmV0Y2ggYXMgX3BhdGNoRmV0Y2ggfSBmcm9tICcuLi9saWIvcGF0Y2gtZmV0Y2gnXG5cbmxldCBTZWdtZW50Vmlld05vZGU6IHR5cGVvZiBpbXBvcnQoJy4uLy4uL25leHQtZGV2dG9vbHMvdXNlcnNwYWNlL2FwcC9zZWdtZW50LWV4cGxvcmVyLW5vZGUnKS5TZWdtZW50Vmlld05vZGUgPVxuICAoKSA9PiBudWxsXG5sZXQgU2VnbWVudFZpZXdTdGF0ZU5vZGU6IHR5cGVvZiBpbXBvcnQoJy4uLy4uL25leHQtZGV2dG9vbHMvdXNlcnNwYWNlL2FwcC9zZWdtZW50LWV4cGxvcmVyLW5vZGUnKS5TZWdtZW50Vmlld1N0YXRlTm9kZSA9XG4gICgpID0+IG51bGxcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICBjb25zdCBtb2QgPVxuICAgIHJlcXVpcmUoJy4uLy4uL25leHQtZGV2dG9vbHMvdXNlcnNwYWNlL2FwcC9zZWdtZW50LWV4cGxvcmVyLW5vZGUnKSBhcyB0eXBlb2YgaW1wb3J0KCcuLi8uLi9uZXh0LWRldnRvb2xzL3VzZXJzcGFjZS9hcHAvc2VnbWVudC1leHBsb3Jlci1ub2RlJylcbiAgU2VnbWVudFZpZXdOb2RlID0gbW9kLlNlZ21lbnRWaWV3Tm9kZVxuICBTZWdtZW50Vmlld1N0YXRlTm9kZSA9IG1vZC5TZWdtZW50Vmlld1N0YXRlTm9kZVxufVxuXG4vLyBwYXRjaEZldGNoIG1ha2VzIHVzZSBvZiBBUElzIHN1Y2ggYXMgYFJlYWN0LnVuc3RhYmxlX3Bvc3Rwb25lYCB3aGljaCBhcmUgb25seSBhdmFpbGFibGVcbi8vIGluIHRoZSBleHBlcmltZW50YWwgY2hhbm5lbCBvZiBSZWFjdCwgc28gZXhwb3J0IGl0IGZyb20gaGVyZSBzbyB0aGF0IGl0IGNvbWVzIGZyb20gdGhlIGJ1bmRsZWQgcnVudGltZVxuZXhwb3J0IGZ1bmN0aW9uIHBhdGNoRmV0Y2goKSB7XG4gIHJldHVybiBfcGF0Y2hGZXRjaCh7XG4gICAgd29ya0FzeW5jU3RvcmFnZSxcbiAgICB3b3JrVW5pdEFzeW5jU3RvcmFnZSxcbiAgfSlcbn1cblxuLy8gRGV2ZWxvcG1lbnQgb25seVxuZXhwb3J0IHsgU2VnbWVudFZpZXdOb2RlLCBTZWdtZW50Vmlld1N0YXRlTm9kZSB9XG4iXSwibmFtZXMiOlsiY3JlYXRlVGVtcG9yYXJ5UmVmZXJlbmNlU2V0IiwicmVuZGVyVG9SZWFkYWJsZVN0cmVhbSIsImRlY29kZVJlcGx5IiwiZGVjb2RlQWN0aW9uIiwiZGVjb2RlRm9ybVN0YXRlIiwidW5zdGFibGVfcHJlcmVuZGVyIiwicHJlcmVuZGVyIiwiY2FwdHVyZU93bmVyU3RhY2siLCJkZWZhdWx0IiwiTGF5b3V0Um91dGVyIiwiUmVuZGVyRnJvbVRlbXBsYXRlQ29udGV4dCIsIndvcmtBc3luY1N0b3JhZ2UiLCJ3b3JrVW5pdEFzeW5jU3RvcmFnZSIsImFjdGlvbkFzeW5jU3RvcmFnZSIsIkNsaWVudFBhZ2VSb290IiwiQ2xpZW50U2VnbWVudFJvb3QiLCJjcmVhdGVTZXJ2ZXJTZWFyY2hQYXJhbXNGb3JTZXJ2ZXJQYWdlIiwiY3JlYXRlUHJlcmVuZGVyU2VhcmNoUGFyYW1zRm9yQ2xpZW50UGFnZSIsImNyZWF0ZVNlcnZlclBhcmFtc0ZvclNlcnZlclNlZ21lbnQiLCJjcmVhdGVQcmVyZW5kZXJQYXJhbXNGb3JDbGllbnRTZWdtZW50Iiwic2VydmVySG9va3MiLCJIVFRQQWNjZXNzRmFsbGJhY2tCb3VuZGFyeSIsImNyZWF0ZU1ldGFkYXRhQ29tcG9uZW50cyIsIk1ldGFkYXRhQm91bmRhcnkiLCJWaWV3cG9ydEJvdW5kYXJ5IiwiT3V0bGV0Qm91bmRhcnkiLCJwcmVsb2FkU3R5bGUiLCJwcmVsb2FkRm9udCIsInByZWNvbm5lY3QiLCJQb3N0cG9uZSIsInRhaW50T2JqZWN0UmVmZXJlbmNlIiwiY29sbGVjdFNlZ21lbnREYXRhIiwicGF0Y2hGZXRjaCIsIl9wYXRjaEZldGNoIiwiU2VnbWVudFZpZXdOb2RlIiwiU2VnbWVudFZpZXdTdGF0ZU5vZGUiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJtb2QiLCJyZXF1aXJlIl0sIm1hcHBpbmdzIjoiQUFBQSw2REFBNkQ7Ozs7OztBQUM3RCxTQUNFQSwyQkFBMkIsRUFDM0JDLHNCQUFzQixFQUN0QkMsV0FBVyxFQUNYQyxZQUFZLEVBQ1pDLGVBQWUsUUFDVixrQ0FBaUM7QUFFeEMsNkRBQTZEO0FBQzdELFNBQVNDLHNCQUFzQkMsU0FBUyxRQUFRLGtDQUFpQztBQUVqRiw2REFBNkQ7QUFDN0QsU0FBU0MsaUJBQWlCLFFBQVEsUUFBTztBQUV6QyxTQUFTQyxXQUFXQyxZQUFZLFFBQVEsd0NBQXVDO0FBQy9FLFNBQVNELFdBQVdFLHlCQUF5QixRQUFRLHVEQUFzRDtBQUMzRyxTQUFTQyxnQkFBZ0IsUUFBUSw0Q0FBMkM7QUFDNUUsU0FBU0Msb0JBQW9CLFFBQVEscUNBQW9DO0FBQ3pFLFNBQVNDLGtCQUFrQixRQUFRLDhDQUE2QztBQUVoRixTQUFTQyxjQUFjLFFBQVEsc0NBQXFDO0FBQ3BFLFNBQVNDLGlCQUFpQixRQUFRLHlDQUF3QztBQUMxRSxTQUNFQyxxQ0FBcUMsRUFDckNDLHdDQUF3QyxRQUNuQywyQkFBMEI7QUFDakMsU0FDRUMsa0NBQWtDLEVBQ2xDQyxxQ0FBcUMsUUFDaEMsb0JBQW1CO0FBQzFCLE9BQU8sS0FBS0MsV0FBVyxNQUFNLCtDQUE4QztBQUMzRSxTQUFTQywwQkFBMEIsUUFBUSw4REFBNkQ7QUFDeEcsU0FBU0Msd0JBQXdCLFFBQVEsOEJBQTZCO0FBQ3RFLFNBQ0VDLGdCQUFnQixFQUNoQkMsZ0JBQWdCLEVBQ2hCQyxjQUFjLFFBQ1QscURBQW9EO0FBRTNELFNBQVNDLFlBQVksRUFBRUMsV0FBVyxFQUFFQyxVQUFVLFFBQVEsaUJBQWdCO0FBQ3RFLFNBQVNDLFFBQVEsUUFBUSxpQkFBZ0I7QUFDekMsU0FBU0Msb0JBQW9CLFFBQVEsY0FBYTtBQUNsRCxTQUFTQyxrQkFBa0IsUUFBUSx5QkFBd0I7QUFJM0QsU0FBU0MsY0FBY0MsV0FBVyxRQUFRLHFCQUFvQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRTlELElBQUlDLGtCQUNGLElBQU07QUFDUixJQUFJQyx1QkFDRixJQUFNO0FBQ1IsSUFBSUMsUUFBUUMsR0FBRyxDQUFDQyxRQUFRLEtBQUssV0FBZTtJQUMxQyxNQUFNQyxNQUNKQyxRQUFRO0lBQ1ZOLGtCQUFrQkssSUFBSUwsZUFBZTtJQUNyQ0MsdUJBQXVCSSxJQUFJSixvQkFBb0I7QUFDakQ7QUFJTyxTQUFTSDtJQUNkLGtMQUFPQyxhQUFBQSxFQUFZOzhSQUNqQnRCLG1CQUFBQTtrVEFDQUMsdUJBQUFBO0lBQ0Y7QUFDRiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19XQp9