(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push([typeof document === "object" ? document.currentScript : undefined, {

"[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var _global_process, _global_process1;
module.exports = ((_global_process = ("TURBOPACK ident replacement", globalThis).process) == null ? void 0 : _global_process.env) && typeof ((_global_process1 = ("TURBOPACK ident replacement", globalThis).process) == null ? void 0 : _global_process1.env) === 'object' ? ("TURBOPACK ident replacement", globalThis).process : __turbopack_context__.r("[project]/node_modules/next/dist/compiled/process/browser.js [client] (ecmascript)"); //# sourceMappingURL=process.js.map
}}),
"[project]/node_modules/next/dist/build/polyfills/polyfill-module.js [client] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
"trimStart" in String.prototype || (String.prototype.trimStart = String.prototype.trimLeft), "trimEnd" in String.prototype || (String.prototype.trimEnd = String.prototype.trimRight), "description" in Symbol.prototype || Object.defineProperty(Symbol.prototype, "description", {
    configurable: !0,
    get: function() {
        var t = /\((.*)\)/.exec(this.toString());
        return t ? t[1] : void 0;
    }
}), Array.prototype.flat || (Array.prototype.flat = function(t, r) {
    return r = this.concat.apply([], this), t > 1 && r.some(Array.isArray) ? r.flat(t - 1) : r;
}, Array.prototype.flatMap = function(t, r) {
    return this.map(t, r).flat();
}), Promise.prototype.finally || (Promise.prototype.finally = function(t) {
    if ("function" != typeof t) return this.then(t, t);
    var r = this.constructor || Promise;
    return this.then(function(n) {
        return r.resolve(t()).then(function() {
            return n;
        });
    }, function(n) {
        return r.resolve(t()).then(function() {
            throw n;
        });
    });
}), Object.fromEntries || (Object.fromEntries = function(t) {
    return Array.from(t).reduce(function(t, r) {
        return t[r[0]] = r[1], t;
    }, {});
}), Array.prototype.at || (Array.prototype.at = function(t) {
    var r = Math.trunc(t) || 0;
    if (r < 0 && (r += this.length), !(r < 0 || r >= this.length)) return this[r];
}), Object.hasOwn || (Object.hasOwn = function(t, r) {
    if (null == t) throw new TypeError("Cannot convert undefined or null to object");
    return Object.prototype.hasOwnProperty.call(Object(t), r);
}), "canParse" in URL || (URL.canParse = function(t, r) {
    try {
        return !!new URL(t, r);
    } catch (t) {
        return !1;
    }
});
}}),
"[project]/node_modules/next/dist/build/deployment-id.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "getDeploymentIdQueryOrEmptyString", {
    enumerable: true,
    get: function() {
        return getDeploymentIdQueryOrEmptyString;
    }
});
function getDeploymentIdQueryOrEmptyString() {
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    return '';
} //# sourceMappingURL=deployment-id.js.map
}}),
"[project]/node_modules/next/dist/lib/constants.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    ACTION_SUFFIX: null,
    APP_DIR_ALIAS: null,
    CACHE_ONE_YEAR: null,
    DOT_NEXT_ALIAS: null,
    ESLINT_DEFAULT_DIRS: null,
    GSP_NO_RETURNED_VALUE: null,
    GSSP_COMPONENT_MEMBER_ERROR: null,
    GSSP_NO_RETURNED_VALUE: null,
    INFINITE_CACHE: null,
    INSTRUMENTATION_HOOK_FILENAME: null,
    MATCHED_PATH_HEADER: null,
    MIDDLEWARE_FILENAME: null,
    MIDDLEWARE_LOCATION_REGEXP: null,
    NEXT_BODY_SUFFIX: null,
    NEXT_CACHE_IMPLICIT_TAG_ID: null,
    NEXT_CACHE_REVALIDATED_TAGS_HEADER: null,
    NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER: null,
    NEXT_CACHE_SOFT_TAG_MAX_LENGTH: null,
    NEXT_CACHE_TAGS_HEADER: null,
    NEXT_CACHE_TAG_MAX_ITEMS: null,
    NEXT_CACHE_TAG_MAX_LENGTH: null,
    NEXT_DATA_SUFFIX: null,
    NEXT_INTERCEPTION_MARKER_PREFIX: null,
    NEXT_META_SUFFIX: null,
    NEXT_QUERY_PARAM_PREFIX: null,
    NEXT_RESUME_HEADER: null,
    NON_STANDARD_NODE_ENV: null,
    PAGES_DIR_ALIAS: null,
    PRERENDER_REVALIDATE_HEADER: null,
    PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER: null,
    PUBLIC_DIR_MIDDLEWARE_CONFLICT: null,
    ROOT_DIR_ALIAS: null,
    RSC_ACTION_CLIENT_WRAPPER_ALIAS: null,
    RSC_ACTION_ENCRYPTION_ALIAS: null,
    RSC_ACTION_PROXY_ALIAS: null,
    RSC_ACTION_VALIDATE_ALIAS: null,
    RSC_CACHE_WRAPPER_ALIAS: null,
    RSC_DYNAMIC_IMPORT_WRAPPER_ALIAS: null,
    RSC_MOD_REF_PROXY_ALIAS: null,
    RSC_PREFETCH_SUFFIX: null,
    RSC_SEGMENTS_DIR_SUFFIX: null,
    RSC_SEGMENT_SUFFIX: null,
    RSC_SUFFIX: null,
    SERVER_PROPS_EXPORT_ERROR: null,
    SERVER_PROPS_GET_INIT_PROPS_CONFLICT: null,
    SERVER_PROPS_SSG_CONFLICT: null,
    SERVER_RUNTIME: null,
    SSG_FALLBACK_EXPORT_ERROR: null,
    SSG_GET_INITIAL_PROPS_CONFLICT: null,
    STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR: null,
    UNSTABLE_REVALIDATE_RENAME_ERROR: null,
    WEBPACK_LAYERS: null,
    WEBPACK_RESOURCE_QUERIES: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    ACTION_SUFFIX: function() {
        return ACTION_SUFFIX;
    },
    APP_DIR_ALIAS: function() {
        return APP_DIR_ALIAS;
    },
    CACHE_ONE_YEAR: function() {
        return CACHE_ONE_YEAR;
    },
    DOT_NEXT_ALIAS: function() {
        return DOT_NEXT_ALIAS;
    },
    ESLINT_DEFAULT_DIRS: function() {
        return ESLINT_DEFAULT_DIRS;
    },
    GSP_NO_RETURNED_VALUE: function() {
        return GSP_NO_RETURNED_VALUE;
    },
    GSSP_COMPONENT_MEMBER_ERROR: function() {
        return GSSP_COMPONENT_MEMBER_ERROR;
    },
    GSSP_NO_RETURNED_VALUE: function() {
        return GSSP_NO_RETURNED_VALUE;
    },
    INFINITE_CACHE: function() {
        return INFINITE_CACHE;
    },
    INSTRUMENTATION_HOOK_FILENAME: function() {
        return INSTRUMENTATION_HOOK_FILENAME;
    },
    MATCHED_PATH_HEADER: function() {
        return MATCHED_PATH_HEADER;
    },
    MIDDLEWARE_FILENAME: function() {
        return MIDDLEWARE_FILENAME;
    },
    MIDDLEWARE_LOCATION_REGEXP: function() {
        return MIDDLEWARE_LOCATION_REGEXP;
    },
    NEXT_BODY_SUFFIX: function() {
        return NEXT_BODY_SUFFIX;
    },
    NEXT_CACHE_IMPLICIT_TAG_ID: function() {
        return NEXT_CACHE_IMPLICIT_TAG_ID;
    },
    NEXT_CACHE_REVALIDATED_TAGS_HEADER: function() {
        return NEXT_CACHE_REVALIDATED_TAGS_HEADER;
    },
    NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER: function() {
        return NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER;
    },
    NEXT_CACHE_SOFT_TAG_MAX_LENGTH: function() {
        return NEXT_CACHE_SOFT_TAG_MAX_LENGTH;
    },
    NEXT_CACHE_TAGS_HEADER: function() {
        return NEXT_CACHE_TAGS_HEADER;
    },
    NEXT_CACHE_TAG_MAX_ITEMS: function() {
        return NEXT_CACHE_TAG_MAX_ITEMS;
    },
    NEXT_CACHE_TAG_MAX_LENGTH: function() {
        return NEXT_CACHE_TAG_MAX_LENGTH;
    },
    NEXT_DATA_SUFFIX: function() {
        return NEXT_DATA_SUFFIX;
    },
    NEXT_INTERCEPTION_MARKER_PREFIX: function() {
        return NEXT_INTERCEPTION_MARKER_PREFIX;
    },
    NEXT_META_SUFFIX: function() {
        return NEXT_META_SUFFIX;
    },
    NEXT_QUERY_PARAM_PREFIX: function() {
        return NEXT_QUERY_PARAM_PREFIX;
    },
    NEXT_RESUME_HEADER: function() {
        return NEXT_RESUME_HEADER;
    },
    NON_STANDARD_NODE_ENV: function() {
        return NON_STANDARD_NODE_ENV;
    },
    PAGES_DIR_ALIAS: function() {
        return PAGES_DIR_ALIAS;
    },
    PRERENDER_REVALIDATE_HEADER: function() {
        return PRERENDER_REVALIDATE_HEADER;
    },
    PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER: function() {
        return PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER;
    },
    PUBLIC_DIR_MIDDLEWARE_CONFLICT: function() {
        return PUBLIC_DIR_MIDDLEWARE_CONFLICT;
    },
    ROOT_DIR_ALIAS: function() {
        return ROOT_DIR_ALIAS;
    },
    RSC_ACTION_CLIENT_WRAPPER_ALIAS: function() {
        return RSC_ACTION_CLIENT_WRAPPER_ALIAS;
    },
    RSC_ACTION_ENCRYPTION_ALIAS: function() {
        return RSC_ACTION_ENCRYPTION_ALIAS;
    },
    RSC_ACTION_PROXY_ALIAS: function() {
        return RSC_ACTION_PROXY_ALIAS;
    },
    RSC_ACTION_VALIDATE_ALIAS: function() {
        return RSC_ACTION_VALIDATE_ALIAS;
    },
    RSC_CACHE_WRAPPER_ALIAS: function() {
        return RSC_CACHE_WRAPPER_ALIAS;
    },
    RSC_DYNAMIC_IMPORT_WRAPPER_ALIAS: function() {
        return RSC_DYNAMIC_IMPORT_WRAPPER_ALIAS;
    },
    RSC_MOD_REF_PROXY_ALIAS: function() {
        return RSC_MOD_REF_PROXY_ALIAS;
    },
    RSC_PREFETCH_SUFFIX: function() {
        return RSC_PREFETCH_SUFFIX;
    },
    RSC_SEGMENTS_DIR_SUFFIX: function() {
        return RSC_SEGMENTS_DIR_SUFFIX;
    },
    RSC_SEGMENT_SUFFIX: function() {
        return RSC_SEGMENT_SUFFIX;
    },
    RSC_SUFFIX: function() {
        return RSC_SUFFIX;
    },
    SERVER_PROPS_EXPORT_ERROR: function() {
        return SERVER_PROPS_EXPORT_ERROR;
    },
    SERVER_PROPS_GET_INIT_PROPS_CONFLICT: function() {
        return SERVER_PROPS_GET_INIT_PROPS_CONFLICT;
    },
    SERVER_PROPS_SSG_CONFLICT: function() {
        return SERVER_PROPS_SSG_CONFLICT;
    },
    SERVER_RUNTIME: function() {
        return SERVER_RUNTIME;
    },
    SSG_FALLBACK_EXPORT_ERROR: function() {
        return SSG_FALLBACK_EXPORT_ERROR;
    },
    SSG_GET_INITIAL_PROPS_CONFLICT: function() {
        return SSG_GET_INITIAL_PROPS_CONFLICT;
    },
    STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR: function() {
        return STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR;
    },
    UNSTABLE_REVALIDATE_RENAME_ERROR: function() {
        return UNSTABLE_REVALIDATE_RENAME_ERROR;
    },
    WEBPACK_LAYERS: function() {
        return WEBPACK_LAYERS;
    },
    WEBPACK_RESOURCE_QUERIES: function() {
        return WEBPACK_RESOURCE_QUERIES;
    }
});
const NEXT_QUERY_PARAM_PREFIX = 'nxtP';
const NEXT_INTERCEPTION_MARKER_PREFIX = 'nxtI';
const MATCHED_PATH_HEADER = 'x-matched-path';
const PRERENDER_REVALIDATE_HEADER = 'x-prerender-revalidate';
const PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER = 'x-prerender-revalidate-if-generated';
const RSC_PREFETCH_SUFFIX = '.prefetch.rsc';
const RSC_SEGMENTS_DIR_SUFFIX = '.segments';
const RSC_SEGMENT_SUFFIX = '.segment.rsc';
const RSC_SUFFIX = '.rsc';
const ACTION_SUFFIX = '.action';
const NEXT_DATA_SUFFIX = '.json';
const NEXT_META_SUFFIX = '.meta';
const NEXT_BODY_SUFFIX = '.body';
const NEXT_CACHE_TAGS_HEADER = 'x-next-cache-tags';
const NEXT_CACHE_REVALIDATED_TAGS_HEADER = 'x-next-revalidated-tags';
const NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER = 'x-next-revalidate-tag-token';
const NEXT_RESUME_HEADER = 'next-resume';
const NEXT_CACHE_TAG_MAX_ITEMS = 128;
const NEXT_CACHE_TAG_MAX_LENGTH = 256;
const NEXT_CACHE_SOFT_TAG_MAX_LENGTH = 1024;
const NEXT_CACHE_IMPLICIT_TAG_ID = '_N_T_';
const CACHE_ONE_YEAR = 31536000;
const INFINITE_CACHE = 0xfffffffe;
const MIDDLEWARE_FILENAME = 'middleware';
const MIDDLEWARE_LOCATION_REGEXP = "(?:src/)?".concat(MIDDLEWARE_FILENAME);
const INSTRUMENTATION_HOOK_FILENAME = 'instrumentation';
const PAGES_DIR_ALIAS = 'private-next-pages';
const DOT_NEXT_ALIAS = 'private-dot-next';
const ROOT_DIR_ALIAS = 'private-next-root-dir';
const APP_DIR_ALIAS = 'private-next-app-dir';
const RSC_MOD_REF_PROXY_ALIAS = 'private-next-rsc-mod-ref-proxy';
const RSC_ACTION_VALIDATE_ALIAS = 'private-next-rsc-action-validate';
const RSC_ACTION_PROXY_ALIAS = 'private-next-rsc-server-reference';
const RSC_CACHE_WRAPPER_ALIAS = 'private-next-rsc-cache-wrapper';
const RSC_DYNAMIC_IMPORT_WRAPPER_ALIAS = 'private-next-rsc-track-dynamic-import';
const RSC_ACTION_ENCRYPTION_ALIAS = 'private-next-rsc-action-encryption';
const RSC_ACTION_CLIENT_WRAPPER_ALIAS = 'private-next-rsc-action-client-wrapper';
const PUBLIC_DIR_MIDDLEWARE_CONFLICT = "You can not have a '_next' folder inside of your public folder. This conflicts with the internal '/_next' route. https://nextjs.org/docs/messages/public-next-folder-conflict";
const SSG_GET_INITIAL_PROPS_CONFLICT = "You can not use getInitialProps with getStaticProps. To use SSG, please remove your getInitialProps";
const SERVER_PROPS_GET_INIT_PROPS_CONFLICT = "You can not use getInitialProps with getServerSideProps. Please remove getInitialProps.";
const SERVER_PROPS_SSG_CONFLICT = "You can not use getStaticProps or getStaticPaths with getServerSideProps. To use SSG, please remove getServerSideProps";
const STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR = "can not have getInitialProps/getServerSideProps, https://nextjs.org/docs/messages/404-get-initial-props";
const SERVER_PROPS_EXPORT_ERROR = "pages with `getServerSideProps` can not be exported. See more info here: https://nextjs.org/docs/messages/gssp-export";
const GSP_NO_RETURNED_VALUE = 'Your `getStaticProps` function did not return an object. Did you forget to add a `return`?';
const GSSP_NO_RETURNED_VALUE = 'Your `getServerSideProps` function did not return an object. Did you forget to add a `return`?';
const UNSTABLE_REVALIDATE_RENAME_ERROR = 'The `unstable_revalidate` property is available for general use.\n' + 'Please use `revalidate` instead.';
const GSSP_COMPONENT_MEMBER_ERROR = "can not be attached to a page's component and must be exported from the page. See more info here: https://nextjs.org/docs/messages/gssp-component-member";
const NON_STANDARD_NODE_ENV = 'You are using a non-standard "NODE_ENV" value in your environment. This creates inconsistencies in the project and is strongly advised against. Read more: https://nextjs.org/docs/messages/non-standard-node-env';
const SSG_FALLBACK_EXPORT_ERROR = "Pages with `fallback` enabled in `getStaticPaths` can not be exported. See more info here: https://nextjs.org/docs/messages/ssg-fallback-true-export";
const ESLINT_DEFAULT_DIRS = [
    'app',
    'pages',
    'components',
    'lib',
    'src'
];
const SERVER_RUNTIME = {
    edge: 'edge',
    experimentalEdge: 'experimental-edge',
    nodejs: 'nodejs'
};
/**
 * The names of the webpack layers. These layers are the primitives for the
 * webpack chunks.
 */ const WEBPACK_LAYERS_NAMES = {
    /**
   * The layer for the shared code between the client and server bundles.
   */ shared: 'shared',
    /**
   * The layer for server-only runtime and picking up `react-server` export conditions.
   * Including app router RSC pages and app router custom routes and metadata routes.
   */ reactServerComponents: 'rsc',
    /**
   * Server Side Rendering layer for app (ssr).
   */ serverSideRendering: 'ssr',
    /**
   * The browser client bundle layer for actions.
   */ actionBrowser: 'action-browser',
    /**
   * The Node.js bundle layer for the API routes.
   */ apiNode: 'api-node',
    /**
   * The Edge Lite bundle layer for the API routes.
   */ apiEdge: 'api-edge',
    /**
   * The layer for the middleware code.
   */ middleware: 'middleware',
    /**
   * The layer for the instrumentation hooks.
   */ instrument: 'instrument',
    /**
   * The layer for assets on the edge.
   */ edgeAsset: 'edge-asset',
    /**
   * The browser client bundle layer for App directory.
   */ appPagesBrowser: 'app-pages-browser',
    /**
   * The browser client bundle layer for Pages directory.
   */ pagesDirBrowser: 'pages-dir-browser',
    /**
   * The Edge Lite bundle layer for Pages directory.
   */ pagesDirEdge: 'pages-dir-edge',
    /**
   * The Node.js bundle layer for Pages directory.
   */ pagesDirNode: 'pages-dir-node'
};
const WEBPACK_LAYERS = {
    ...WEBPACK_LAYERS_NAMES,
    GROUP: {
        builtinReact: [
            WEBPACK_LAYERS_NAMES.reactServerComponents,
            WEBPACK_LAYERS_NAMES.actionBrowser
        ],
        serverOnly: [
            WEBPACK_LAYERS_NAMES.reactServerComponents,
            WEBPACK_LAYERS_NAMES.actionBrowser,
            WEBPACK_LAYERS_NAMES.instrument,
            WEBPACK_LAYERS_NAMES.middleware
        ],
        neutralTarget: [
            // pages api
            WEBPACK_LAYERS_NAMES.apiNode,
            WEBPACK_LAYERS_NAMES.apiEdge
        ],
        clientOnly: [
            WEBPACK_LAYERS_NAMES.serverSideRendering,
            WEBPACK_LAYERS_NAMES.appPagesBrowser
        ],
        bundled: [
            WEBPACK_LAYERS_NAMES.reactServerComponents,
            WEBPACK_LAYERS_NAMES.actionBrowser,
            WEBPACK_LAYERS_NAMES.serverSideRendering,
            WEBPACK_LAYERS_NAMES.appPagesBrowser,
            WEBPACK_LAYERS_NAMES.shared,
            WEBPACK_LAYERS_NAMES.instrument,
            WEBPACK_LAYERS_NAMES.middleware
        ],
        appPages: [
            // app router pages and layouts
            WEBPACK_LAYERS_NAMES.reactServerComponents,
            WEBPACK_LAYERS_NAMES.serverSideRendering,
            WEBPACK_LAYERS_NAMES.appPagesBrowser,
            WEBPACK_LAYERS_NAMES.actionBrowser
        ]
    }
};
const WEBPACK_RESOURCE_QUERIES = {
    edgeSSREntry: '__next_edge_ssr_entry__',
    metadata: '__next_metadata__',
    metadataRoute: '__next_metadata_route__',
    metadataImageMeta: '__next_metadata_image_meta__'
}; //# sourceMappingURL=constants.js.map
}}),
"[project]/node_modules/next/dist/lib/is-error.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    default: null,
    getProperError: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    /**
 * Checks whether the given value is a NextError.
 * This can be used to print a more detailed error message with properties like `code` & `digest`.
 */ default: function() {
        return isError;
    },
    getProperError: function() {
        return getProperError;
    }
});
const _isplainobject = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/is-plain-object.js [client] (ecmascript)");
function isError(err) {
    return typeof err === 'object' && err !== null && 'name' in err && 'message' in err;
}
function safeStringify(obj) {
    const seen = new WeakSet();
    return JSON.stringify(obj, (_key, value)=>{
        // If value is an object and already seen, replace with "[Circular]"
        if (typeof value === 'object' && value !== null) {
            if (seen.has(value)) {
                return '[Circular]';
            }
            seen.add(value);
        }
        return value;
    });
}
function getProperError(err) {
    if (isError(err)) {
        return err;
    }
    if ("TURBOPACK compile-time truthy", 1) {
        // provide better error for case where `throw undefined`
        // is called in development
        if (typeof err === 'undefined') {
            return Object.defineProperty(new Error('An undefined error was thrown, ' + 'see here for more info: https://nextjs.org/docs/messages/threw-undefined'), "__NEXT_ERROR_CODE", {
                value: "E98",
                enumerable: false,
                configurable: true
            });
        }
        if (err === null) {
            return Object.defineProperty(new Error('A null error was thrown, ' + 'see here for more info: https://nextjs.org/docs/messages/threw-undefined'), "__NEXT_ERROR_CODE", {
                value: "E336",
                enumerable: false,
                configurable: true
            });
        }
    }
    return Object.defineProperty(new Error((0, _isplainobject.isPlainObject)(err) ? safeStringify(err) : err + ''), "__NEXT_ERROR_CODE", {
        value: "E394",
        enumerable: false,
        configurable: true
    });
} //# sourceMappingURL=is-error.js.map
}}),
"[project]/node_modules/next/dist/lib/is-api-route.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "isAPIRoute", {
    enumerable: true,
    get: function() {
        return isAPIRoute;
    }
});
function isAPIRoute(value) {
    return value === '/api' || Boolean(value == null ? void 0 : value.startsWith('/api/'));
} //# sourceMappingURL=is-api-route.js.map
}}),
"[project]/node_modules/next/dist/lib/require-instrumentation-client.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/**
 * This module imports the client instrumentation hook from the project root.
 *
 * The `private-next-instrumentation-client` module is automatically aliased to
 * the `instrumentation-client.ts` file in the project root by webpack or turbopack.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
"use strict";
if ("TURBOPACK compile-time truthy", 1) {
    const measureName = 'Client Instrumentation Hook';
    const startTime = performance.now();
    // eslint-disable-next-line @next/internal/typechecked-require -- Not a module.
    module.exports = {};
    const endTime = performance.now();
    const duration = endTime - startTime;
    // Using 16ms threshold as it represents one frame (1000ms/60fps)
    // This helps identify if the instrumentation hook initialization
    // could potentially cause frame drops during development.
    const THRESHOLD = 16;
    if (duration > THRESHOLD) {
        console.log("[".concat(measureName, "] Slow execution detected: ").concat(duration.toFixed(0), "ms (Note: Code download overhead is not included in this measurement)"));
    }
} else //TURBOPACK unreachable
;
 //# sourceMappingURL=require-instrumentation-client.js.map
}}),
"[project]/node_modules/next/dist/next-devtools/userspace/app/errors/stitched-error.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    coerceError: null,
    decorateDevError: null,
    getComponentStack: null,
    getOwnerStack: null,
    setComponentStack: null,
    setOwnerStack: null,
    setOwnerStackIfAvailable: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    coerceError: function() {
        return coerceError;
    },
    decorateDevError: function() {
        return decorateDevError;
    },
    getComponentStack: function() {
        return getComponentStack;
    },
    getOwnerStack: function() {
        return getOwnerStack;
    },
    setComponentStack: function() {
        return setComponentStack;
    },
    setOwnerStack: function() {
        return setOwnerStack;
    },
    setOwnerStackIfAvailable: function() {
        return setOwnerStackIfAvailable;
    }
});
const _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [client] (ecmascript)");
const _react = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/react/index.js [client] (ecmascript)"));
const _iserror = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/lib/is-error.js [client] (ecmascript)"));
const ownerStacks = new WeakMap();
const componentStacks = new WeakMap();
function getComponentStack(error) {
    return componentStacks.get(error);
}
function setComponentStack(error, stack) {
    componentStacks.set(error, stack);
}
function getOwnerStack(error) {
    return ownerStacks.get(error);
}
function setOwnerStack(error, stack) {
    ownerStacks.set(error, stack);
}
function coerceError(value) {
    return (0, _iserror.default)(value) ? value : Object.defineProperty(new Error('' + value), "__NEXT_ERROR_CODE", {
        value: "E394",
        enumerable: false,
        configurable: true
    });
}
function setOwnerStackIfAvailable(error) {
    // React 18 and prod does not have `captureOwnerStack`
    if ('captureOwnerStack' in _react.default) {
        setOwnerStack(error, _react.default.captureOwnerStack());
    }
}
function decorateDevError(thrownValue, errorInfo) {
    const error = coerceError(thrownValue);
    setOwnerStackIfAvailable(error);
    // TODO: change to passing down errorInfo later
    // In development mode, pass along the component stack to the error
    if (errorInfo.componentStack) {
        setComponentStack(error, errorInfo.componentStack);
    }
    return error;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=stitched-error.js.map
}}),
"[project]/node_modules/next/dist/next-devtools/shared/react-18-hydration-error.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    getHydrationWarningType: null,
    isHydrationError: null,
    isHydrationWarning: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    getHydrationWarningType: function() {
        return getHydrationWarningType;
    },
    isHydrationError: function() {
        return isHydrationError;
    },
    isHydrationWarning: function() {
        return isHydrationWarning;
    }
});
const _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [client] (ecmascript)");
const _iserror = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/lib/is-error.js [client] (ecmascript)"));
function isHydrationError(error) {
    return (0, _iserror.default)(error) && (error.message === 'Hydration failed because the initial UI does not match what was rendered on the server.' || error.message === 'Text content does not match server-rendered HTML.');
}
function isHydrationWarning(message) {
    return isHtmlTagsWarning(message) || isTextInTagsMismatchWarning(message) || isTextWarning(message);
}
// https://github.com/facebook/react/blob/main/packages/react-dom/src/__tests__/ReactDOMHydrationDiff-test.js used as a reference
const htmlTagsWarnings = new Set([
    'Warning: Expected server HTML to contain a matching <%s> in <%s>.%s',
    'Warning: Did not expect server HTML to contain a <%s> in <%s>.%s'
]);
const textAndTagsMismatchWarnings = new Set([
    'Warning: Expected server HTML to contain a matching text node for "%s" in <%s>.%s',
    'Warning: Did not expect server HTML to contain the text node "%s" in <%s>.%s'
]);
const textWarnings = new Set([
    'Warning: Text content did not match. Server: "%s" Client: "%s"%s'
]);
const getHydrationWarningType = (message)=>{
    if (typeof message !== 'string') {
        // TODO: Doesn't make sense to treat no message as a hydration error message.
        // We should bail out somewhere earlier.
        return 'text';
    }
    const normalizedMessage = message.startsWith('Warning: ') ? message : "Warning: " + message;
    if (isHtmlTagsWarning(normalizedMessage)) return 'tag';
    if (isTextInTagsMismatchWarning(normalizedMessage)) return 'text-in-tag';
    return 'text';
};
const isHtmlTagsWarning = (message)=>typeof message === 'string' && htmlTagsWarnings.has(message);
const isTextInTagsMismatchWarning = (msg)=>typeof msg === 'string' && textAndTagsMismatchWarnings.has(msg);
const isTextWarning = (msg)=>typeof msg === 'string' && textWarnings.has(msg);
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=react-18-hydration-error.js.map
}}),
"[project]/node_modules/next/dist/next-devtools/shared/react-19-hydration-error.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    NEXTJS_HYDRATION_ERROR_LINK: null,
    REACT_HYDRATION_ERROR_LINK: null,
    getHydrationErrorStackInfo: null,
    isErrorMessageWithComponentStackDiff: null,
    isHydrationError: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    NEXTJS_HYDRATION_ERROR_LINK: function() {
        return NEXTJS_HYDRATION_ERROR_LINK;
    },
    REACT_HYDRATION_ERROR_LINK: function() {
        return REACT_HYDRATION_ERROR_LINK;
    },
    getHydrationErrorStackInfo: function() {
        return getHydrationErrorStackInfo;
    },
    isErrorMessageWithComponentStackDiff: function() {
        return isErrorMessageWithComponentStackDiff;
    },
    isHydrationError: function() {
        return isHydrationError;
    }
});
const REACT_HYDRATION_ERROR_LINK = 'https://react.dev/link/hydration-mismatch';
const NEXTJS_HYDRATION_ERROR_LINK = 'https://nextjs.org/docs/messages/react-hydration-error';
/**
 * Only React 19+ contains component stack diff in the error message
 */ const errorMessagesWithComponentStackDiff = [
    /^In HTML, (.+?) cannot be a child of <(.+?)>\.(.*)\nThis will cause a hydration error\.(.*)/,
    /^In HTML, (.+?) cannot be a descendant of <(.+?)>\.\nThis will cause a hydration error\.(.*)/,
    /^In HTML, text nodes cannot be a child of <(.+?)>\.\nThis will cause a hydration error\./,
    /^In HTML, whitespace text nodes cannot be a child of <(.+?)>\. Make sure you don't have any extra whitespace between tags on each line of your source code\.\nThis will cause a hydration error\./
];
function isHydrationError(error) {
    return isErrorMessageWithComponentStackDiff(error.message) || /Hydration failed because the server rendered (text|HTML) didn't match the client\./.test(error.message) || /A tree hydrated but some attributes of the server rendered HTML didn't match the client properties./.test(error.message);
}
function isErrorMessageWithComponentStackDiff(msg) {
    return errorMessagesWithComponentStackDiff.some((regex)=>regex.test(msg));
}
function getHydrationErrorStackInfo(error) {
    const errorMessage = error.message;
    if (isErrorMessageWithComponentStackDiff(errorMessage)) {
        const [message, diffLog = ''] = errorMessage.split('\n\n');
        const diff = diffLog.trim();
        return {
            message: diff === '' ? errorMessage.trim() : message.trim(),
            diff,
            notes: null
        };
    }
    const [message, maybeComponentStackDiff] = errorMessage.split("" + REACT_HYDRATION_ERROR_LINK);
    const trimmedMessage = message.trim();
    // React built-in hydration diff starts with a newline
    if (maybeComponentStackDiff !== undefined && maybeComponentStackDiff.length > 1) {
        const diffs = [];
        maybeComponentStackDiff.split('\n').forEach((line)=>{
            if (line.trim() === '') return;
            if (!line.trim().startsWith('at ')) {
                diffs.push(line);
            }
        });
        const [displayedMessage, ...notes] = trimmedMessage.split('\n\n');
        return {
            message: displayedMessage,
            diff: diffs.join('\n'),
            notes: notes.join('\n\n') || null
        };
    } else {
        const [displayedMessage, ...notes] = trimmedMessage.split('\n\n');
        return {
            message: displayedMessage,
            diff: null,
            notes: notes.join('\n\n')
        };
    }
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=react-19-hydration-error.js.map
}}),
"[project]/node_modules/next/dist/next-devtools/userspace/pages/hydration-error-state.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    attachHydrationErrorState: null,
    getSquashedHydrationErrorDetails: null,
    storeHydrationErrorStateFromConsoleArgs: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    attachHydrationErrorState: function() {
        return attachHydrationErrorState;
    },
    getSquashedHydrationErrorDetails: function() {
        return getSquashedHydrationErrorDetails;
    },
    storeHydrationErrorStateFromConsoleArgs: function() {
        return storeHydrationErrorStateFromConsoleArgs;
    }
});
const _react18hydrationerror = __turbopack_context__.r("[project]/node_modules/next/dist/next-devtools/shared/react-18-hydration-error.js [client] (ecmascript)");
const _react19hydrationerror = __turbopack_context__.r("[project]/node_modules/next/dist/next-devtools/shared/react-19-hydration-error.js [client] (ecmascript)");
// We only need this for React 18 or hydration console errors in React 19.
// Once we surface console.error in the dev overlay in pages router, we should only
// use this for React 18.
let hydrationErrorState = {};
const squashedHydrationErrorDetails = new WeakMap();
function getSquashedHydrationErrorDetails(error) {
    return squashedHydrationErrorDetails.has(error) ? squashedHydrationErrorDetails.get(error) : null;
}
function attachHydrationErrorState(error) {
    if (!(0, _react18hydrationerror.isHydrationError)(error) && !(0, _react19hydrationerror.isHydrationError)(error)) {
        return;
    }
    let parsedHydrationErrorState = {};
    // If there's any extra information in the error message to display,
    // append it to the error message details property
    if (hydrationErrorState.warning) {
        // The patched console.error found hydration errors logged by React
        // Append the logged warning to the error message
        parsedHydrationErrorState = {
            // It contains the warning, component stack, server and client tag names
            ...hydrationErrorState
        };
        // Consume the cached hydration diff.
        // This is only required for now when we still squashed the hydration diff log into hydration error.
        // Once the all error is logged to dev overlay in order, this will go away.
        if (hydrationErrorState.reactOutputComponentDiff) {
            parsedHydrationErrorState.reactOutputComponentDiff = hydrationErrorState.reactOutputComponentDiff;
        }
        squashedHydrationErrorDetails.set(error, parsedHydrationErrorState);
    }
}
function storeHydrationErrorStateFromConsoleArgs() {
    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
        args[_key] = arguments[_key];
    }
    let [message, firstContent, secondContent, ...rest] = args;
    if ((0, _react18hydrationerror.isHydrationWarning)(message)) {
        // Some hydration warnings has 4 arguments, some has 3, fallback to the last argument
        // when the 3rd argument is not the component stack but an empty string
        // For some warnings, there's only 1 argument for template.
        // The second argument is the diff or component stack.
        if (args.length === 3) {
            secondContent = '';
        }
        const warning = message.replace(/Warning: /, '').replace('%s', firstContent).replace('%s', secondContent) // remove the last %s from the message
        .replace(/%s/g, '');
        const lastArg = (rest[rest.length - 1] || '').trim();
        hydrationErrorState.reactOutputComponentDiff = generateHydrationDiffReact18(message, firstContent, secondContent, lastArg);
        hydrationErrorState.warning = warning;
    } else if ((0, _react19hydrationerror.isErrorMessageWithComponentStackDiff)(message)) {
        // Some hydration warnings has 4 arguments, some has 3, fallback to the last argument
        // when the 3rd argument is not the component stack but an empty string
        // For some warnings, there's only 1 argument for template.
        // The second argument is the diff or component stack.
        if (args.length === 3) {
            secondContent = '';
        }
        const warning = message.replace('%s', firstContent).replace('%s', secondContent) // remove the last %s from the message
        .replace(/%s/g, '');
        const lastArg = (args[args.length - 1] || '').trim();
        hydrationErrorState.reactOutputComponentDiff = lastArg;
        hydrationErrorState.warning = warning;
    }
}
/*
 * Some hydration errors in React 18 does not have the diff in the error message.
 * Instead it has the error stack trace which is component stack that we can leverage.
 * Will parse the diff from the error stack trace
 *  e.g.
 *  Warning: Expected server HTML to contain a matching <div> in <p>.
 *    at div
 *    at p
 *    at div
 *    at div
 *    at Page
 *  output:
 *    <Page>
 *      <div>
 *        <p>
 *  >       <div>
 *
 */ function generateHydrationDiffReact18(message, firstContent, secondContent, lastArg) {
    const componentStack = lastArg;
    let firstIndex = -1;
    let secondIndex = -1;
    const hydrationWarningType = (0, _react18hydrationerror.getHydrationWarningType)(message);
    // at div\n at Foo\n at Bar (....)\n -> [div, Foo]
    const components = componentStack.split('\n') // .reverse()
    .map((line, index)=>{
        // `<space>at <component> (<location>)` -> `at <component> (<location>)`
        line = line.trim();
        // extract `<space>at <component>` to `<<component>>`
        // e.g. `  at Foo` -> `<Foo>`
        const [, component, location] = /at (\w+)( \((.*)\))?/.exec(line) || [];
        // If there's no location then it's user-land stack frame
        if (!location) {
            if (component === firstContent && firstIndex === -1) {
                firstIndex = index;
            } else if (component === secondContent && secondIndex === -1) {
                secondIndex = index;
            }
        }
        return location ? '' : component;
    }).filter(Boolean).reverse();
    let diff = '';
    for(let i = 0; i < components.length; i++){
        const component = components[i];
        const matchFirstContent = hydrationWarningType === 'tag' && i === components.length - firstIndex - 1;
        const matchSecondContent = hydrationWarningType === 'tag' && i === components.length - secondIndex - 1;
        if (matchFirstContent || matchSecondContent) {
            const spaces = ' '.repeat(Math.max(i * 2 - 2, 0) + 2);
            diff += "> " + spaces + "<" + component + ">\n";
        } else {
            const spaces = ' '.repeat(i * 2 + 2);
            diff += spaces + "<" + component + ">\n";
        }
    }
    if (hydrationWarningType === 'text') {
        const spaces = ' '.repeat(components.length * 2);
        diff += "+ " + spaces + '"' + firstContent + '"\n';
        diff += "- " + spaces + '"' + secondContent + '"\n';
    } else if (hydrationWarningType === 'text-in-tag') {
        const spaces = ' '.repeat(components.length * 2);
        diff += "> " + spaces + "<" + secondContent + ">\n";
        diff += ">   " + spaces + '"' + firstContent + '"\n';
    }
    return diff;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=hydration-error-state.js.map
}}),
"[project]/node_modules/next/dist/next-devtools/userspace/pages/pages-dev-overlay-error-boundary.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "PagesDevOverlayErrorBoundary", {
    enumerable: true,
    get: function() {
        return PagesDevOverlayErrorBoundary;
    }
});
const _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [client] (ecmascript)");
const _react = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/react/index.js [client] (ecmascript)"));
class PagesDevOverlayErrorBoundary extends _react.default.PureComponent {
    static getDerivedStateFromError(error) {
        return {
            error
        };
    }
    // Explicit type is needed to avoid the generated `.d.ts` having a wide return type that could be specific to the `@types/react` version.
    render() {
        // The component has to be unmounted or else it would continue to error
        return this.state.error ? null : this.props.children;
    }
    constructor(...args){
        super(...args), this.state = {
            error: null
        };
    }
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=pages-dev-overlay-error-boundary.js.map
}}),
"[project]/node_modules/next/dist/next-devtools/userspace/app/terminal-logging-config.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    getIsTerminalLoggingEnabled: null,
    getTerminalLoggingConfig: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    getIsTerminalLoggingEnabled: function() {
        return getIsTerminalLoggingEnabled;
    },
    getTerminalLoggingConfig: function() {
        return getTerminalLoggingConfig;
    }
});
function getTerminalLoggingConfig() {
    try {
        return JSON.parse(("TURBOPACK compile-time value", "false") || 'false');
    } catch (e) {
        return false;
    }
}
function getIsTerminalLoggingEnabled() {
    const config = getTerminalLoggingConfig();
    return Boolean(config);
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=terminal-logging-config.js.map
}}),
"[project]/node_modules/next/dist/next-devtools/shared/forward-logs-shared.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    UNDEFINED_MARKER: null,
    patchConsoleMethod: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    UNDEFINED_MARKER: function() {
        return UNDEFINED_MARKER;
    },
    patchConsoleMethod: function() {
        return patchConsoleMethod;
    }
});
const UNDEFINED_MARKER = '__next_tagged_undefined';
function patchConsoleMethod(methodName, wrapper) {
    const descriptor = Object.getOwnPropertyDescriptor(console, methodName);
    if (descriptor && (descriptor.configurable || descriptor.writable) && typeof descriptor.value === 'function') {
        const originalMethod = descriptor.value;
        const originalName = Object.getOwnPropertyDescriptor(originalMethod, 'name');
        const wrapperMethod = function() {
            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                args[_key] = arguments[_key];
            }
            wrapper(methodName, ...args);
            originalMethod.apply(this, args);
        };
        if (originalName) {
            Object.defineProperty(wrapperMethod, 'name', originalName);
        }
        Object.defineProperty(console, methodName, {
            value: wrapperMethod
        });
        return ()=>{
            Object.defineProperty(console, methodName, {
                value: originalMethod,
                writable: descriptor.writable,
                configurable: descriptor.configurable
            });
        };
    }
    return ()=>{};
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=forward-logs-shared.js.map
}}),
"[project]/node_modules/next/dist/next-devtools/userspace/app/forward-logs.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    PROMISE_MARKER: null,
    UNAVAILABLE_MARKER: null,
    forwardErrorLog: null,
    forwardUnhandledError: null,
    initializeDebugLogForwarding: null,
    isTerminalLoggingEnabled: null,
    logQueue: null,
    logStringify: null,
    logUnhandledRejection: null,
    preLogSerializationClone: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    PROMISE_MARKER: function() {
        return PROMISE_MARKER;
    },
    UNAVAILABLE_MARKER: function() {
        return UNAVAILABLE_MARKER;
    },
    forwardErrorLog: function() {
        return forwardErrorLog;
    },
    forwardUnhandledError: function() {
        return forwardUnhandledError;
    },
    initializeDebugLogForwarding: function() {
        return initializeDebugLogForwarding;
    },
    isTerminalLoggingEnabled: function() {
        return isTerminalLoggingEnabled;
    },
    logQueue: function() {
        return logQueue;
    },
    logStringify: function() {
        return logStringify;
    },
    logUnhandledRejection: function() {
        return logUnhandledRejection;
    },
    preLogSerializationClone: function() {
        return preLogSerializationClone;
    }
});
const _safestablestringify = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/safe-stable-stringify/index.js [client] (ecmascript)");
const _stitchederror = __turbopack_context__.r("[project]/node_modules/next/dist/next-devtools/userspace/app/errors/stitched-error.js [client] (ecmascript)");
const _errorsource = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/error-source.js [client] (ecmascript)");
const _terminalloggingconfig = __turbopack_context__.r("[project]/node_modules/next/dist/next-devtools/userspace/app/terminal-logging-config.js [client] (ecmascript)");
const _forwardlogsshared = __turbopack_context__.r("[project]/node_modules/next/dist/next-devtools/shared/forward-logs-shared.js [client] (ecmascript)");
const terminalLoggingConfig = (0, _terminalloggingconfig.getTerminalLoggingConfig)();
const PROMISE_MARKER = 'Promise {}';
const UNAVAILABLE_MARKER = '[Unable to view]';
const maximumDepth = typeof terminalLoggingConfig === 'object' && terminalLoggingConfig.depthLimit ? terminalLoggingConfig.depthLimit : 5;
const maximumBreadth = typeof terminalLoggingConfig === 'object' && terminalLoggingConfig.edgeLimit ? terminalLoggingConfig.edgeLimit : 100;
const stringify = (0, _safestablestringify.configure)({
    maximumDepth,
    maximumBreadth
});
const isTerminalLoggingEnabled = (0, _terminalloggingconfig.getIsTerminalLoggingEnabled)();
const methods = [
    'log',
    'info',
    'warn',
    'debug',
    'table',
    'assert',
    'dir',
    'dirxml',
    'group',
    'groupCollapsed',
    'groupEnd',
    'trace'
];
function preLogSerializationClone(value, seen) {
    if (seen === void 0) seen = new WeakMap();
    if (value === undefined) return _forwardlogsshared.UNDEFINED_MARKER;
    if (value === null || typeof value !== 'object') return value;
    if (seen.has(value)) return seen.get(value);
    try {
        Object.keys(value);
    } catch (e) {
        return UNAVAILABLE_MARKER;
    }
    try {
        if (typeof value.then === 'function') return PROMISE_MARKER;
    } catch (e) {
        return UNAVAILABLE_MARKER;
    }
    if (Array.isArray(value)) {
        const out = [];
        seen.set(value, out);
        for (const item of value){
            try {
                out.push(preLogSerializationClone(item, seen));
            } catch (e) {
                out.push(UNAVAILABLE_MARKER);
            }
        }
        return out;
    }
    const proto = Object.getPrototypeOf(value);
    if (proto === Object.prototype || proto === null) {
        const out = {};
        seen.set(value, out);
        for (const key of Object.keys(value)){
            try {
                out[key] = preLogSerializationClone(value[key], seen);
            } catch (e) {
                out[key] = UNAVAILABLE_MARKER;
            }
        }
        return out;
    }
    return Object.prototype.toString.call(value);
}
const logStringify = (data)=>{
    try {
        const result = stringify(data);
        return result != null ? result : '"' + UNAVAILABLE_MARKER + '"';
    } catch (e) {
        return '"' + UNAVAILABLE_MARKER + '"';
    }
};
const afterThisFrame = (cb)=>{
    let timeout;
    const rafId = requestAnimationFrame(()=>{
        timeout = setTimeout(()=>{
            cb();
        });
    });
    return ()=>{
        cancelAnimationFrame(rafId);
        clearTimeout(timeout);
    };
};
let isPatched = false;
const serializeEntries = (entries)=>entries.map((clientEntry)=>{
        switch(clientEntry.kind){
            case 'any-logged-error':
            case 'console':
                {
                    return {
                        ...clientEntry,
                        args: clientEntry.args.map(stringifyUserArg)
                    };
                }
            case 'formatted-error':
                {
                    return clientEntry;
                }
            default:
                {
                    return null;
                }
        }
    });
const logQueue = {
    entries: [],
    flushScheduled: false,
    cancelFlush: null,
    socket: null,
    sourceType: undefined,
    router: null,
    scheduleLogSend: (entry)=>{
        logQueue.entries.push(entry);
        if (logQueue.flushScheduled) {
            return;
        }
        // safe to deref and use in setTimeout closure since we cancel on new socket
        const socket = logQueue.socket;
        if (!socket) {
            return;
        }
        // we probably dont need this
        logQueue.flushScheduled = true;
        // non blocking log flush, runs at most once per frame
        logQueue.cancelFlush = afterThisFrame(()=>{
            logQueue.flushScheduled = false;
            // just incase
            try {
                const payload = JSON.stringify({
                    event: 'browser-logs',
                    entries: serializeEntries(logQueue.entries),
                    router: logQueue.router,
                    // needed for source mapping, we just assign the sourceType from the last error for the whole batch
                    sourceType: logQueue.sourceType
                });
                socket.send(payload);
                logQueue.entries = [];
                logQueue.sourceType = undefined;
            } catch (e) {
            // error (make sure u don't infinite loop)
            /* noop */ }
        });
    },
    onSocketReady: (socket)=>{
        if (socket.readyState !== WebSocket.OPEN) {
            // invariant
            return;
        }
        // incase an existing timeout was going to run with a stale socket
        logQueue.cancelFlush == null ? void 0 : logQueue.cancelFlush.call(logQueue);
        logQueue.socket = socket;
        try {
            const payload = JSON.stringify({
                event: 'browser-logs',
                entries: serializeEntries(logQueue.entries),
                router: logQueue.router,
                sourceType: logQueue.sourceType
            });
            socket.send(payload);
            logQueue.entries = [];
            logQueue.sourceType = undefined;
        } catch (e) {
        /** noop just incase */ }
    }
};
const stringifyUserArg = (arg)=>{
    if (arg.kind !== 'arg') {
        return arg;
    }
    return {
        ...arg,
        data: logStringify(arg.data)
    };
};
const createErrorArg = (error)=>{
    const stack = stackWithOwners(error);
    return {
        kind: 'formatted-error-arg',
        prefix: error.message ? error.name + ": " + error.message : "" + error.name,
        stack
    };
};
const createLogEntry = (level, args)=>{
    // do not abstract this, it implicitly relies on which functions call it. forcing the inlined implementation makes you think about callers
    // error capture stack trace maybe
    const stack = stackWithOwners(new Error());
    const stackLines = stack == null ? void 0 : stack.split('\n');
    const cleanStack = stackLines == null ? void 0 : stackLines.slice(3).join('\n') // this is probably ignored anyways
    ;
    const entry = {
        kind: 'console',
        consoleMethodStack: cleanStack != null ? cleanStack : null,
        method: level,
        args: args.map((arg)=>{
            if (arg instanceof Error) {
                return createErrorArg(arg);
            }
            return {
                kind: 'arg',
                data: preLogSerializationClone(arg)
            };
        })
    };
    logQueue.scheduleLogSend(entry);
};
const forwardErrorLog = (args)=>{
    const errorObjects = args.filter((arg)=>arg instanceof Error);
    const first = errorObjects.at(0);
    if (first) {
        const source = (0, _errorsource.getErrorSource)(first);
        if (source) {
            logQueue.sourceType = source;
        }
    }
    /**
   * browser shows stack regardless of type of data passed to console.error, so we should do the same
   *
   * do not abstract this, it implicitly relies on which functions call it. forcing the inlined implementation makes you think about callers
   */ const stack = stackWithOwners(new Error());
    const stackLines = stack == null ? void 0 : stack.split('\n');
    const cleanStack = stackLines == null ? void 0 : stackLines.slice(3).join('\n');
    const entry = {
        kind: 'any-logged-error',
        method: 'error',
        consoleErrorStack: cleanStack != null ? cleanStack : '',
        args: args.map((arg)=>{
            if (arg instanceof Error) {
                return createErrorArg(arg);
            }
            return {
                kind: 'arg',
                data: preLogSerializationClone(arg)
            };
        })
    };
    logQueue.scheduleLogSend(entry);
};
const createUncaughtErrorEntry = (errorName, errorMessage, fullStack)=>{
    const entry = {
        kind: 'formatted-error',
        prefix: "Uncaught " + errorName + ": " + errorMessage,
        stack: fullStack,
        method: 'error'
    };
    logQueue.scheduleLogSend(entry);
};
const stackWithOwners = (error)=>{
    let ownerStack = '';
    (0, _stitchederror.setOwnerStackIfAvailable)(error);
    ownerStack = (0, _stitchederror.getOwnerStack)(error) || '';
    const stack = (error.stack || '') + ownerStack;
    return stack;
};
function logUnhandledRejection(reason) {
    if (reason instanceof Error) {
        createUnhandledRejectionErrorEntry(reason, stackWithOwners(reason));
        return;
    }
    createUnhandledRejectionNonErrorEntry(reason);
}
const createUnhandledRejectionErrorEntry = (error, fullStack)=>{
    const source = (0, _errorsource.getErrorSource)(error);
    if (source) {
        logQueue.sourceType = source;
    }
    const entry = {
        kind: 'formatted-error',
        prefix: " unhandledRejection: " + error.name + ": " + error.message,
        stack: fullStack,
        method: 'error'
    };
    logQueue.scheduleLogSend(entry);
};
const createUnhandledRejectionNonErrorEntry = (reason)=>{
    const entry = {
        kind: 'any-logged-error',
        // we can't access the stack since the event is dispatched async and creating an inline error would be meaningless
        consoleErrorStack: '',
        method: 'error',
        args: [
            {
                kind: 'arg',
                data: " unhandledRejection:",
                isRejectionMessage: true
            },
            {
                kind: 'arg',
                data: preLogSerializationClone(reason)
            }
        ]
    };
    logQueue.scheduleLogSend(entry);
};
const isHMR = (args)=>{
    const firstArg = args[0];
    if (typeof firstArg !== 'string') {
        return false;
    }
    if (firstArg.startsWith('[Fast Refresh]')) {
        return true;
    }
    if (firstArg.startsWith('[HMR]')) {
        return true;
    }
    return false;
};
const isIgnoredLog = (args)=>{
    if (args.length < 3) {
        return false;
    }
    const [format, styles, label] = args;
    if (typeof format !== 'string' || typeof styles !== 'string' || typeof label !== 'string') {
        return false;
    }
    // kinda hacky, we should define a common format for these strings so we can safely ignore
    return format.startsWith('%c%s%c') && styles.includes('background:');
};
function forwardUnhandledError(error) {
    createUncaughtErrorEntry(error.name, error.message, stackWithOwners(error));
}
const initializeDebugLogForwarding = (router)=>{
    // probably don't need this
    if (isPatched) {
        return;
    }
    // TODO(rob): why does this break rendering on server, important to know incase the same bug appears in browser
    if (typeof window === 'undefined') {
        return;
    }
    // better to be safe than sorry
    try {
        methods.forEach((method)=>(0, _forwardlogsshared.patchConsoleMethod)(method, function(_) {
                for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                    args[_key - 1] = arguments[_key];
                }
                if (isHMR(args)) {
                    return;
                }
                if (isIgnoredLog(args)) {
                    return;
                }
                createLogEntry(method, args);
            }));
    } catch (e) {}
    logQueue.router = router;
    isPatched = true;
};
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=forward-logs.js.map
}}),
"[project]/node_modules/next/dist/next-devtools/userspace/pages/pages-dev-overlay-setup.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    PagesDevOverlayBridge: null,
    register: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    PagesDevOverlayBridge: function() {
        return PagesDevOverlayBridge;
    },
    register: function() {
        return register;
    }
});
const _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [client] (ecmascript)");
const _jsxruntime = __turbopack_context__.r("[project]/node_modules/react/jsx-runtime.js [client] (ecmascript)");
const _react = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/react/index.js [client] (ecmascript)"));
const _nextdevtools = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/next-devtools/index.js [client] (ecmascript)");
const _hydrationerrorstate = __turbopack_context__.r("[project]/node_modules/next/dist/next-devtools/userspace/pages/hydration-error-state.js [client] (ecmascript)");
const _router = __turbopack_context__.r("[project]/node_modules/next/dist/client/router.js [client] (ecmascript)");
const _stitchederror = __turbopack_context__.r("[project]/node_modules/next/dist/next-devtools/userspace/app/errors/stitched-error.js [client] (ecmascript)");
const _onrecoverableerror = __turbopack_context__.r("[project]/node_modules/next/dist/client/react-client-callbacks/on-recoverable-error.js [client] (ecmascript)");
const _pagesdevoverlayerrorboundary = __turbopack_context__.r("[project]/node_modules/next/dist/next-devtools/userspace/pages/pages-dev-overlay-error-boundary.js [client] (ecmascript)");
const _forwardlogs = __turbopack_context__.r("[project]/node_modules/next/dist/next-devtools/userspace/app/forward-logs.js [client] (ecmascript)");
const usePagesDevOverlayBridge = ()=>{
    _react.default.useInsertionEffect({
        "usePagesDevOverlayBridge.useInsertionEffect": ()=>{
            // NDT uses a different React instance so it's not technically a state update
            // scheduled from useInsertionEffect.
            (0, _nextdevtools.renderPagesDevOverlay)(_stitchederror.getComponentStack, _stitchederror.getOwnerStack, _hydrationerrorstate.getSquashedHydrationErrorDetails, _onrecoverableerror.isRecoverableError);
        }
    }["usePagesDevOverlayBridge.useInsertionEffect"], []);
    _react.default.useEffect({
        "usePagesDevOverlayBridge.useEffect": ()=>{
            const { handleStaticIndicator } = __turbopack_context__.r("[project]/node_modules/next/dist/client/dev/hot-reloader/pages/hot-reloader-pages.js [client] (ecmascript)");
            _router.Router.events.on('routeChangeComplete', handleStaticIndicator);
            return ({
                "usePagesDevOverlayBridge.useEffect": function() {
                    _router.Router.events.off('routeChangeComplete', handleStaticIndicator);
                }
            })["usePagesDevOverlayBridge.useEffect"];
        }
    }["usePagesDevOverlayBridge.useEffect"], []);
};
function PagesDevOverlayBridge(param) {
    let { children } = param;
    usePagesDevOverlayBridge();
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_pagesdevoverlayerrorboundary.PagesDevOverlayErrorBoundary, {
        children: children
    });
}
let isRegistered = false;
function handleError(error) {
    if (!error || !(error instanceof Error) || typeof error.stack !== 'string') {
        // A non-error was thrown, we don't have anything to show. :-(
        return;
    }
    (0, _hydrationerrorstate.attachHydrationErrorState)(error);
    // Skip ModuleBuildError and ModuleNotFoundError, as it will be sent through onBuildError callback.
    // This is to avoid same error as different type showing up on client to cause flashing.
    if (error.name !== 'ModuleBuildError' && error.name !== 'ModuleNotFoundError') {
        _nextdevtools.dispatcher.onUnhandledError(error);
    }
}
let origConsoleError = console.error;
function nextJsHandleConsoleError() {
    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
        args[_key] = arguments[_key];
    }
    // See https://github.com/facebook/react/blob/d50323eb845c5fde0d720cae888bf35dedd05506/packages/react-reconciler/src/ReactFiberErrorLogger.js#L78
    const maybeError = ("TURBOPACK compile-time truthy", 1) ? args[1] : "TURBOPACK unreachable";
    (0, _hydrationerrorstate.storeHydrationErrorStateFromConsoleArgs)(...args);
    // TODO: Surfaces non-errors logged via `console.error`.
    handleError(maybeError);
    if (_forwardlogs.isTerminalLoggingEnabled) {
        (0, _forwardlogs.forwardErrorLog)(args);
    }
    origConsoleError.apply(window.console, args);
}
function onUnhandledError(event) {
    const error = event == null ? void 0 : event.error;
    handleError(error);
    if (error && _forwardlogs.isTerminalLoggingEnabled) {
        (0, _forwardlogs.forwardUnhandledError)(error);
    }
}
function onUnhandledRejection(ev) {
    const reason = ev == null ? void 0 : ev.reason;
    if (!reason || !(reason instanceof Error) || typeof reason.stack !== 'string') {
        // A non-error was thrown, we don't have anything to show. :-(
        return;
    }
    _nextdevtools.dispatcher.onUnhandledRejection(reason);
    if (_forwardlogs.isTerminalLoggingEnabled) {
        (0, _forwardlogs.logUnhandledRejection)(reason);
    }
}
function register() {
    if (isRegistered) {
        return;
    }
    isRegistered = true;
    try {
        Error.stackTraceLimit = 50;
    } catch (e) {}
    if (_forwardlogs.isTerminalLoggingEnabled) {
        (0, _forwardlogs.initializeDebugLogForwarding)('pages');
    }
    window.addEventListener('error', onUnhandledError);
    window.addEventListener('unhandledrejection', onUnhandledRejection);
    window.console.error = nextJsHandleConsoleError;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=pages-dev-overlay-setup.js.map
}}),
"[project]/node_modules/next/dist/server/dev/hot-reloader-types.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "HMR_ACTIONS_SENT_TO_BROWSER", {
    enumerable: true,
    get: function() {
        return HMR_ACTIONS_SENT_TO_BROWSER;
    }
});
var HMR_ACTIONS_SENT_TO_BROWSER = /*#__PURE__*/ function(HMR_ACTIONS_SENT_TO_BROWSER) {
    HMR_ACTIONS_SENT_TO_BROWSER["ADDED_PAGE"] = "addedPage";
    HMR_ACTIONS_SENT_TO_BROWSER["REMOVED_PAGE"] = "removedPage";
    HMR_ACTIONS_SENT_TO_BROWSER["RELOAD_PAGE"] = "reloadPage";
    HMR_ACTIONS_SENT_TO_BROWSER["SERVER_COMPONENT_CHANGES"] = "serverComponentChanges";
    HMR_ACTIONS_SENT_TO_BROWSER["MIDDLEWARE_CHANGES"] = "middlewareChanges";
    HMR_ACTIONS_SENT_TO_BROWSER["CLIENT_CHANGES"] = "clientChanges";
    HMR_ACTIONS_SENT_TO_BROWSER["SERVER_ONLY_CHANGES"] = "serverOnlyChanges";
    HMR_ACTIONS_SENT_TO_BROWSER["SYNC"] = "sync";
    HMR_ACTIONS_SENT_TO_BROWSER["BUILT"] = "built";
    HMR_ACTIONS_SENT_TO_BROWSER["BUILDING"] = "building";
    HMR_ACTIONS_SENT_TO_BROWSER["DEV_PAGES_MANIFEST_UPDATE"] = "devPagesManifestUpdate";
    HMR_ACTIONS_SENT_TO_BROWSER["TURBOPACK_MESSAGE"] = "turbopack-message";
    HMR_ACTIONS_SENT_TO_BROWSER["SERVER_ERROR"] = "serverError";
    HMR_ACTIONS_SENT_TO_BROWSER["TURBOPACK_CONNECTED"] = "turbopack-connected";
    HMR_ACTIONS_SENT_TO_BROWSER["ISR_MANIFEST"] = "isrManifest";
    HMR_ACTIONS_SENT_TO_BROWSER["DEV_INDICATOR"] = "devIndicator";
    return HMR_ACTIONS_SENT_TO_BROWSER;
}({}); //# sourceMappingURL=hot-reloader-types.js.map
}}),
"[project]/node_modules/next/dist/server/dev/node-stack-frames.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "getServerError", {
    enumerable: true,
    get: function() {
        return getServerError;
    }
});
const _stacktraceparser = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/stacktrace-parser/stack-trace-parser.cjs.js [client] (ecmascript)");
const _errorsource = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/error-source.js [client] (ecmascript)");
function getFilesystemFrame(frame) {
    const f = {
        ...frame
    };
    if (typeof f.file === 'string') {
        if (f.file.startsWith('/') || // Win32:
        /^[a-z]:\\/i.test(f.file) || // Win32 UNC:
        f.file.startsWith('\\\\')) {
            f.file = "file://".concat(f.file);
        }
    }
    return f;
}
function getServerError(error, type) {
    if (error.name === 'TurbopackInternalError') {
        // If this is an internal Turbopack error we shouldn't show internal details
        // to the user. These are written to a log file instead.
        const turbopackInternalError = Object.defineProperty(new Error('An unexpected Turbopack error occurred. Please see the output of `next dev` for more details.'), "__NEXT_ERROR_CODE", {
            value: "E167",
            enumerable: false,
            configurable: true
        });
        (0, _errorsource.decorateServerError)(turbopackInternalError, type);
        return turbopackInternalError;
    }
    let n;
    try {
        throw Object.defineProperty(new Error(error.message), "__NEXT_ERROR_CODE", {
            value: "E394",
            enumerable: false,
            configurable: true
        });
    } catch (e) {
        n = e;
    }
    n.name = error.name;
    try {
        n.stack = "".concat(n.toString(), "\n").concat((0, _stacktraceparser.parse)(error.stack).map(getFilesystemFrame).map((f)=>{
            let str = "    at ".concat(f.methodName);
            if (f.file) {
                let loc = f.file;
                if (f.lineNumber) {
                    loc += ":".concat(f.lineNumber);
                    if (f.column) {
                        loc += ":".concat(f.column);
                    }
                }
                str += " (".concat(loc, ")");
            }
            return str;
        }).join('\n'));
    } catch (e) {
        n.stack = error.stack;
    }
    (0, _errorsource.decorateServerError)(n, type);
    return n;
} //# sourceMappingURL=node-stack-frames.js.map
}}),
"[project]/node_modules/next/dist/server/request-meta.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/* eslint-disable no-redeclare */ Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    NEXT_REQUEST_META: null,
    addRequestMeta: null,
    getRequestMeta: null,
    removeRequestMeta: null,
    setRequestMeta: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    NEXT_REQUEST_META: function() {
        return NEXT_REQUEST_META;
    },
    addRequestMeta: function() {
        return addRequestMeta;
    },
    getRequestMeta: function() {
        return getRequestMeta;
    },
    removeRequestMeta: function() {
        return removeRequestMeta;
    },
    setRequestMeta: function() {
        return setRequestMeta;
    }
});
const NEXT_REQUEST_META = Symbol.for('NextInternalRequestMeta');
function getRequestMeta(req, key) {
    const meta = req[NEXT_REQUEST_META] || {};
    return typeof key === 'string' ? meta[key] : meta;
}
function setRequestMeta(req, meta) {
    req[NEXT_REQUEST_META] = meta;
    return meta;
}
function addRequestMeta(request, key, value) {
    const meta = getRequestMeta(request);
    meta[key] = value;
    return setRequestMeta(request, meta);
}
function removeRequestMeta(request, key) {
    const meta = getRequestMeta(request);
    delete meta[key];
    return setRequestMeta(request, meta);
} //# sourceMappingURL=request-meta.js.map
}}),
"[project]/node_modules/next/dist/pages/_error.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return Error;
    }
});
const _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [client] (ecmascript)");
const _jsxruntime = __turbopack_context__.r("[project]/node_modules/react/jsx-runtime.js [client] (ecmascript)");
const _react = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/react/index.js [client] (ecmascript)"));
const _head = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/head.js [client] (ecmascript)"));
const statusCodes = {
    400: 'Bad Request',
    404: 'This page could not be found',
    405: 'Method Not Allowed',
    500: 'Internal Server Error'
};
function _getInitialProps(param) {
    let { req, res, err } = param;
    const statusCode = res && res.statusCode ? res.statusCode : err ? err.statusCode : 404;
    let hostname;
    if (typeof window !== 'undefined') {
        hostname = window.location.hostname;
    } else if (req) {
        const { getRequestMeta } = __turbopack_context__.r("[project]/node_modules/next/dist/server/request-meta.js [client] (ecmascript)");
        const initUrl = getRequestMeta(req, 'initURL');
        if (initUrl) {
            const url = new URL(initUrl);
            hostname = url.hostname;
        }
    }
    return {
        statusCode,
        hostname
    };
}
const styles = {
    error: {
        // https://github.com/sindresorhus/modern-normalize/blob/main/modern-normalize.css#L38-L52
        fontFamily: 'system-ui,"Segoe UI",Roboto,Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji"',
        height: '100vh',
        textAlign: 'center',
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        justifyContent: 'center'
    },
    desc: {
        lineHeight: '48px'
    },
    h1: {
        display: 'inline-block',
        margin: '0 20px 0 0',
        paddingRight: 23,
        fontSize: 24,
        fontWeight: 500,
        verticalAlign: 'top'
    },
    h2: {
        fontSize: 14,
        fontWeight: 400,
        lineHeight: '28px'
    },
    wrap: {
        display: 'inline-block'
    }
};
class Error extends _react.default.Component {
    render() {
        const { statusCode, withDarkMode = true } = this.props;
        const title = this.props.title || statusCodes[statusCode] || 'An unexpected error has occurred';
        return /*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {
            style: styles.error,
            children: [
                /*#__PURE__*/ (0, _jsxruntime.jsx)(_head.default, {
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("title", {
                        children: statusCode ? statusCode + ": " + title : 'Application error: a client-side exception has occurred'
                    })
                }),
                /*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {
                    style: styles.desc,
                    children: [
                        /*#__PURE__*/ (0, _jsxruntime.jsx)("style", {
                            dangerouslySetInnerHTML: {
                                /* CSS minified from
                body { margin: 0; color: #000; background: #fff; }
                .next-error-h1 {
                  border-right: 1px solid rgba(0, 0, 0, .3);
                }

                ${
                  withDarkMode
                    ? `@media (prefers-color-scheme: dark) {
                  body { color: #fff; background: #000; }
                  .next-error-h1 {
                    border-right: 1px solid rgba(255, 255, 255, .3);
                  }
                }`
                    : ''
                }
               */ __html: "body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}" + (withDarkMode ? '@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}' : '')
                            }
                        }),
                        statusCode ? /*#__PURE__*/ (0, _jsxruntime.jsx)("h1", {
                            className: "next-error-h1",
                            style: styles.h1,
                            children: statusCode
                        }) : null,
                        /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                            style: styles.wrap,
                            children: /*#__PURE__*/ (0, _jsxruntime.jsxs)("h2", {
                                style: styles.h2,
                                children: [
                                    this.props.title || statusCode ? title : /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
                                        children: [
                                            "Application error: a client-side exception has occurred",
                                            ' ',
                                            Boolean(this.props.hostname) && /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
                                                children: [
                                                    "while loading ",
                                                    this.props.hostname
                                                ]
                                            }),
                                            ' ',
                                            "(see the browser console for more information)"
                                        ]
                                    }),
                                    "."
                                ]
                            })
                        })
                    ]
                })
            ]
        });
    }
}
Error.displayName = 'ErrorPage';
Error.getInitialProps = _getInitialProps;
Error.origGetInitialProps = _getInitialProps;
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=_error.js.map
}}),
}]);

//# sourceMappingURL=data:application/json;charset=utf-8;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFtdLAogICJzZWN0aW9ucyI6IFsKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNywgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9idWlsZC9wb2x5ZmlsbHMvcHJvY2Vzcy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9XG4gIGdsb2JhbC5wcm9jZXNzPy5lbnYgJiYgdHlwZW9mIGdsb2JhbC5wcm9jZXNzPy5lbnYgPT09ICdvYmplY3QnXG4gICAgPyBnbG9iYWwucHJvY2Vzc1xuICAgIDogKHJlcXVpcmUoJ25leHQvZGlzdC9jb21waWxlZC9wcm9jZXNzJykgYXMgdHlwZW9mIGltcG9ydCgnbmV4dC9kaXN0L2NvbXBpbGVkL3Byb2Nlc3MnKSlcbiJdLCJuYW1lcyI6WyJnbG9iYWwiLCJtb2R1bGUiLCJleHBvcnRzIiwicHJvY2VzcyIsImVudiIsInJlcXVpcmUiXSwibWFwcGluZ3MiOiJJQUNFQSxpQkFBOEJBO0FBRGhDQyxPQUFPQyxPQUFPLEdBQ1pGLENBQUFBLENBQUFBLGtCQUFBQSw0Q0FBT0csT0FBTyxLQUFBLE9BQUEsS0FBQSxJQUFkSCxnQkFBZ0JJLEdBQUcsS0FBSSxPQUFBLENBQUEsQ0FBT0osbUJBQUFBLDRDQUFPRyxPQUFPLEtBQUEsT0FBQSxLQUFBLElBQWRILGlCQUFnQkksR0FBRyxNQUFLLFdBQ2xESiw0Q0FBT0csT0FBTyxHQUNiRSxRQUFRIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDE0LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC9wb2x5ZmlsbHMvcG9seWZpbGwtbW9kdWxlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidHJpbVN0YXJ0XCJpbiBTdHJpbmcucHJvdG90eXBlfHwoU3RyaW5nLnByb3RvdHlwZS50cmltU3RhcnQ9U3RyaW5nLnByb3RvdHlwZS50cmltTGVmdCksXCJ0cmltRW5kXCJpbiBTdHJpbmcucHJvdG90eXBlfHwoU3RyaW5nLnByb3RvdHlwZS50cmltRW5kPVN0cmluZy5wcm90b3R5cGUudHJpbVJpZ2h0KSxcImRlc2NyaXB0aW9uXCJpbiBTeW1ib2wucHJvdG90eXBlfHxPYmplY3QuZGVmaW5lUHJvcGVydHkoU3ltYm9sLnByb3RvdHlwZSxcImRlc2NyaXB0aW9uXCIse2NvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXt2YXIgdD0vXFwoKC4qKVxcKS8uZXhlYyh0aGlzLnRvU3RyaW5nKCkpO3JldHVybiB0P3RbMV06dm9pZCAwfX0pLEFycmF5LnByb3RvdHlwZS5mbGF0fHwoQXJyYXkucHJvdG90eXBlLmZsYXQ9ZnVuY3Rpb24odCxyKXtyZXR1cm4gcj10aGlzLmNvbmNhdC5hcHBseShbXSx0aGlzKSx0PjEmJnIuc29tZShBcnJheS5pc0FycmF5KT9yLmZsYXQodC0xKTpyfSxBcnJheS5wcm90b3R5cGUuZmxhdE1hcD1mdW5jdGlvbih0LHIpe3JldHVybiB0aGlzLm1hcCh0LHIpLmZsYXQoKX0pLFByb21pc2UucHJvdG90eXBlLmZpbmFsbHl8fChQcm9taXNlLnByb3RvdHlwZS5maW5hbGx5PWZ1bmN0aW9uKHQpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpcmV0dXJuIHRoaXMudGhlbih0LHQpO3ZhciByPXRoaXMuY29uc3RydWN0b3J8fFByb21pc2U7cmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbihuKXtyZXR1cm4gci5yZXNvbHZlKHQoKSkudGhlbihmdW5jdGlvbigpe3JldHVybiBufSl9LGZ1bmN0aW9uKG4pe3JldHVybiByLnJlc29sdmUodCgpKS50aGVuKGZ1bmN0aW9uKCl7dGhyb3cgbn0pfSl9KSxPYmplY3QuZnJvbUVudHJpZXN8fChPYmplY3QuZnJvbUVudHJpZXM9ZnVuY3Rpb24odCl7cmV0dXJuIEFycmF5LmZyb20odCkucmVkdWNlKGZ1bmN0aW9uKHQscil7cmV0dXJuIHRbclswXV09clsxXSx0fSx7fSl9KSxBcnJheS5wcm90b3R5cGUuYXR8fChBcnJheS5wcm90b3R5cGUuYXQ9ZnVuY3Rpb24odCl7dmFyIHI9TWF0aC50cnVuYyh0KXx8MDtpZihyPDAmJihyKz10aGlzLmxlbmd0aCksIShyPDB8fHI+PXRoaXMubGVuZ3RoKSlyZXR1cm4gdGhpc1tyXX0pLE9iamVjdC5oYXNPd258fChPYmplY3QuaGFzT3duPWZ1bmN0aW9uKHQscil7aWYobnVsbD09dCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0XCIpO3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoT2JqZWN0KHQpLHIpfSksXCJjYW5QYXJzZVwiaW4gVVJMfHwoVVJMLmNhblBhcnNlPWZ1bmN0aW9uKHQscil7dHJ5e3JldHVybiEhbmV3IFVSTCh0LHIpfWNhdGNoKHQpe3JldHVybiExfX0pO1xuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGVBQWMsT0FBTyxTQUFTLElBQUUsQ0FBQyxPQUFPLFNBQVMsQ0FBQyxTQUFTLEdBQUMsT0FBTyxTQUFTLENBQUMsUUFBUSxHQUFFLGFBQVksT0FBTyxTQUFTLElBQUUsQ0FBQyxPQUFPLFNBQVMsQ0FBQyxPQUFPLEdBQUMsT0FBTyxTQUFTLENBQUMsU0FBUyxHQUFFLGlCQUFnQixPQUFPLFNBQVMsSUFBRSxPQUFPLGNBQWMsQ0FBQyxPQUFPLFNBQVMsRUFBQyxlQUFjO0lBQUMsY0FBYSxDQUFDO0lBQUUsS0FBSTtRQUFXLElBQUksSUFBRSxXQUFXLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUTtRQUFJLE9BQU8sSUFBRSxDQUFDLENBQUMsRUFBRSxHQUFDLEtBQUs7SUFBQztBQUFDLElBQUcsTUFBTSxTQUFTLENBQUMsSUFBSSxJQUFFLENBQUMsTUFBTSxTQUFTLENBQUMsSUFBSSxHQUFDLFNBQVMsQ0FBQyxFQUFDLENBQUM7SUFBRSxPQUFPLElBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsRUFBRSxFQUFDLElBQUksR0FBRSxJQUFFLEtBQUcsRUFBRSxJQUFJLENBQUMsTUFBTSxPQUFPLElBQUUsRUFBRSxJQUFJLENBQUMsSUFBRSxLQUFHO0FBQUMsR0FBRSxNQUFNLFNBQVMsQ0FBQyxPQUFPLEdBQUMsU0FBUyxDQUFDLEVBQUMsQ0FBQztJQUFFLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFFLEdBQUcsSUFBSTtBQUFFLENBQUMsR0FBRSxRQUFRLFNBQVMsQ0FBQyxPQUFPLElBQUUsQ0FBQyxRQUFRLFNBQVMsQ0FBQyxPQUFPLEdBQUMsU0FBUyxDQUFDO0lBQUUsSUFBRyxjQUFZLE9BQU8sR0FBRSxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRTtJQUFHLElBQUksSUFBRSxJQUFJLENBQUMsV0FBVyxJQUFFO0lBQVEsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQztRQUFFLE9BQU8sRUFBRSxPQUFPLENBQUMsS0FBSyxJQUFJLENBQUM7WUFBVyxPQUFPO1FBQUM7SUFBRSxHQUFFLFNBQVMsQ0FBQztRQUFFLE9BQU8sRUFBRSxPQUFPLENBQUMsS0FBSyxJQUFJLENBQUM7WUFBVyxNQUFNO1FBQUM7SUFBRTtBQUFFLENBQUMsR0FBRSxPQUFPLFdBQVcsSUFBRSxDQUFDLE9BQU8sV0FBVyxHQUFDLFNBQVMsQ0FBQztJQUFFLE9BQU8sTUFBTSxJQUFJLENBQUMsR0FBRyxNQUFNLENBQUMsU0FBUyxDQUFDLEVBQUMsQ0FBQztRQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBQyxDQUFDLENBQUMsRUFBRSxFQUFDO0lBQUMsR0FBRSxDQUFDO0FBQUUsQ0FBQyxHQUFFLE1BQU0sU0FBUyxDQUFDLEVBQUUsSUFBRSxDQUFDLE1BQU0sU0FBUyxDQUFDLEVBQUUsR0FBQyxTQUFTLENBQUM7SUFBRSxJQUFJLElBQUUsS0FBSyxLQUFLLENBQUMsTUFBSTtJQUFFLElBQUcsSUFBRSxLQUFHLENBQUMsS0FBRyxJQUFJLENBQUMsTUFBTSxHQUFFLENBQUMsQ0FBQyxJQUFFLEtBQUcsS0FBRyxJQUFJLENBQUMsTUFBTSxHQUFFLE9BQU8sSUFBSSxDQUFDLEVBQUU7QUFBQSxDQUFDLEdBQUUsT0FBTyxNQUFNLElBQUUsQ0FBQyxPQUFPLE1BQU0sR0FBQyxTQUFTLENBQUMsRUFBQyxDQUFDO0lBQUUsSUFBRyxRQUFNLEdBQUUsTUFBTSxJQUFJLFVBQVU7SUFBOEMsT0FBTyxPQUFPLFNBQVMsQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLE9BQU8sSUFBRztBQUFFLENBQUMsR0FBRSxjQUFhLE9BQUssQ0FBQyxJQUFJLFFBQVEsR0FBQyxTQUFTLENBQUMsRUFBQyxDQUFDO0lBQUUsSUFBRztRQUFDLE9BQU0sQ0FBQyxDQUFDLElBQUksSUFBSSxHQUFFO0lBQUUsRUFBQyxPQUFNLEdBQUU7UUFBQyxPQUFNLENBQUM7SUFBQztBQUFDLENBQUMiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNTksICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvYnVpbGQvZGVwbG95bWVudC1pZC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gZ2V0RGVwbG95bWVudElkUXVlcnlPckVtcHR5U3RyaW5nKCk6IHN0cmluZyB7XG4gIGlmIChwcm9jZXNzLmVudi5ORVhUX0RFUExPWU1FTlRfSUQpIHtcbiAgICByZXR1cm4gYD9kcGw9JHtwcm9jZXNzLmVudi5ORVhUX0RFUExPWU1FTlRfSUR9YFxuICB9XG4gIHJldHVybiAnJ1xufVxuIl0sIm5hbWVzIjpbImdldERlcGxveW1lbnRJZFF1ZXJ5T3JFbXB0eVN0cmluZyIsInByb2Nlc3MiLCJlbnYiLCJORVhUX0RFUExPWU1FTlRfSUQiXSwibWFwcGluZ3MiOiJBQUNNQyxRQUFRQyxHQUFHLENBQUNDLGtCQUFrQixFQUFFOzs7OzsrQkFEdEJILHFDQUFBQTs7O2VBQUFBOzs7QUFBVCxTQUFTQTtJQUNkOztJQUdBLE9BQU87QUFDVCIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA4MSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9saWIvY29uc3RhbnRzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgU2VydmVyUnVudGltZSB9IGZyb20gJy4uL3R5cGVzJ1xuXG5leHBvcnQgY29uc3QgTkVYVF9RVUVSWV9QQVJBTV9QUkVGSVggPSAnbnh0UCdcbmV4cG9ydCBjb25zdCBORVhUX0lOVEVSQ0VQVElPTl9NQVJLRVJfUFJFRklYID0gJ254dEknXG5cbmV4cG9ydCBjb25zdCBNQVRDSEVEX1BBVEhfSEVBREVSID0gJ3gtbWF0Y2hlZC1wYXRoJ1xuZXhwb3J0IGNvbnN0IFBSRVJFTkRFUl9SRVZBTElEQVRFX0hFQURFUiA9ICd4LXByZXJlbmRlci1yZXZhbGlkYXRlJ1xuZXhwb3J0IGNvbnN0IFBSRVJFTkRFUl9SRVZBTElEQVRFX09OTFlfR0VORVJBVEVEX0hFQURFUiA9XG4gICd4LXByZXJlbmRlci1yZXZhbGlkYXRlLWlmLWdlbmVyYXRlZCdcblxuZXhwb3J0IGNvbnN0IFJTQ19QUkVGRVRDSF9TVUZGSVggPSAnLnByZWZldGNoLnJzYydcbmV4cG9ydCBjb25zdCBSU0NfU0VHTUVOVFNfRElSX1NVRkZJWCA9ICcuc2VnbWVudHMnXG5leHBvcnQgY29uc3QgUlNDX1NFR01FTlRfU1VGRklYID0gJy5zZWdtZW50LnJzYydcbmV4cG9ydCBjb25zdCBSU0NfU1VGRklYID0gJy5yc2MnXG5leHBvcnQgY29uc3QgQUNUSU9OX1NVRkZJWCA9ICcuYWN0aW9uJ1xuZXhwb3J0IGNvbnN0IE5FWFRfREFUQV9TVUZGSVggPSAnLmpzb24nXG5leHBvcnQgY29uc3QgTkVYVF9NRVRBX1NVRkZJWCA9ICcubWV0YSdcbmV4cG9ydCBjb25zdCBORVhUX0JPRFlfU1VGRklYID0gJy5ib2R5J1xuXG5leHBvcnQgY29uc3QgTkVYVF9DQUNIRV9UQUdTX0hFQURFUiA9ICd4LW5leHQtY2FjaGUtdGFncydcbmV4cG9ydCBjb25zdCBORVhUX0NBQ0hFX1JFVkFMSURBVEVEX1RBR1NfSEVBREVSID0gJ3gtbmV4dC1yZXZhbGlkYXRlZC10YWdzJ1xuZXhwb3J0IGNvbnN0IE5FWFRfQ0FDSEVfUkVWQUxJREFURV9UQUdfVE9LRU5fSEVBREVSID1cbiAgJ3gtbmV4dC1yZXZhbGlkYXRlLXRhZy10b2tlbidcblxuZXhwb3J0IGNvbnN0IE5FWFRfUkVTVU1FX0hFQURFUiA9ICduZXh0LXJlc3VtZSdcblxuLy8gaWYgdGhlc2UgY2hhbmdlIG1ha2Ugc3VyZSB3ZSB1cGRhdGUgdGhlIHJlbGF0ZWRcbi8vIGRvY3VtZW50YXRpb24gYXMgd2VsbFxuZXhwb3J0IGNvbnN0IE5FWFRfQ0FDSEVfVEFHX01BWF9JVEVNUyA9IDEyOFxuZXhwb3J0IGNvbnN0IE5FWFRfQ0FDSEVfVEFHX01BWF9MRU5HVEggPSAyNTZcbmV4cG9ydCBjb25zdCBORVhUX0NBQ0hFX1NPRlRfVEFHX01BWF9MRU5HVEggPSAxMDI0XG5leHBvcnQgY29uc3QgTkVYVF9DQUNIRV9JTVBMSUNJVF9UQUdfSUQgPSAnX05fVF8nXG5cbi8vIGluIHNlY29uZHNcbmV4cG9ydCBjb25zdCBDQUNIRV9PTkVfWUVBUiA9IDMxNTM2MDAwXG5cbi8vIGluIHNlY29uZHMsIHJlcHJlc2VudHMgcmV2YWxpZGF0ZT1mYWxzZS4gSS5lLiBuZXZlciByZXZhbGlhdGUuXG4vLyBXZSB1c2UgdGhpcyB2YWx1ZSBzaW5jZSBpdCBjYW4gYmUgcmVwcmVzZW50ZWQgYXMgYSBWOCBTTUkgZm9yIG9wdGltYWwgcGVyZm9ybWFuY2UuXG4vLyBJdCBjYW4gYWxzbyBiZSBzZXJpYWxpemVkIGFzIEpTT04gaWYgaXQgZXZlciBsZWFrcyBhY2NpZGVudGFsbHkgYXMgYW4gYWN0dWFsIHZhbHVlLlxuZXhwb3J0IGNvbnN0IElORklOSVRFX0NBQ0hFID0gMHhmZmZmZmZmZVxuXG4vLyBQYXR0ZXJucyB0byBkZXRlY3QgbWlkZGxld2FyZSBmaWxlc1xuZXhwb3J0IGNvbnN0IE1JRERMRVdBUkVfRklMRU5BTUUgPSAnbWlkZGxld2FyZSdcbmV4cG9ydCBjb25zdCBNSURETEVXQVJFX0xPQ0FUSU9OX1JFR0VYUCA9IGAoPzpzcmMvKT8ke01JRERMRVdBUkVfRklMRU5BTUV9YFxuXG4vLyBQYXR0ZXJuIHRvIGRldGVjdCBpbnN0cnVtZW50YXRpb24gaG9va3MgZmlsZVxuZXhwb3J0IGNvbnN0IElOU1RSVU1FTlRBVElPTl9IT09LX0ZJTEVOQU1FID0gJ2luc3RydW1lbnRhdGlvbidcblxuLy8gQmVjYXVzZSBvbiBXaW5kb3dzIGFic29sdXRlIHBhdGhzIGluIHRoZSBnZW5lcmF0ZWQgY29kZSBjYW4gYnJlYWsgYmVjYXVzZSBvZiBudW1iZXJzLCBlZyAxIGluIHRoZSBwYXRoLFxuLy8gd2UgaGF2ZSB0byB1c2UgYSBwcml2YXRlIGFsaWFzXG5leHBvcnQgY29uc3QgUEFHRVNfRElSX0FMSUFTID0gJ3ByaXZhdGUtbmV4dC1wYWdlcydcbmV4cG9ydCBjb25zdCBET1RfTkVYVF9BTElBUyA9ICdwcml2YXRlLWRvdC1uZXh0J1xuZXhwb3J0IGNvbnN0IFJPT1RfRElSX0FMSUFTID0gJ3ByaXZhdGUtbmV4dC1yb290LWRpcidcbmV4cG9ydCBjb25zdCBBUFBfRElSX0FMSUFTID0gJ3ByaXZhdGUtbmV4dC1hcHAtZGlyJ1xuZXhwb3J0IGNvbnN0IFJTQ19NT0RfUkVGX1BST1hZX0FMSUFTID0gJ3ByaXZhdGUtbmV4dC1yc2MtbW9kLXJlZi1wcm94eSdcbmV4cG9ydCBjb25zdCBSU0NfQUNUSU9OX1ZBTElEQVRFX0FMSUFTID0gJ3ByaXZhdGUtbmV4dC1yc2MtYWN0aW9uLXZhbGlkYXRlJ1xuZXhwb3J0IGNvbnN0IFJTQ19BQ1RJT05fUFJPWFlfQUxJQVMgPSAncHJpdmF0ZS1uZXh0LXJzYy1zZXJ2ZXItcmVmZXJlbmNlJ1xuZXhwb3J0IGNvbnN0IFJTQ19DQUNIRV9XUkFQUEVSX0FMSUFTID0gJ3ByaXZhdGUtbmV4dC1yc2MtY2FjaGUtd3JhcHBlcidcbmV4cG9ydCBjb25zdCBSU0NfRFlOQU1JQ19JTVBPUlRfV1JBUFBFUl9BTElBUyA9XG4gICdwcml2YXRlLW5leHQtcnNjLXRyYWNrLWR5bmFtaWMtaW1wb3J0J1xuZXhwb3J0IGNvbnN0IFJTQ19BQ1RJT05fRU5DUllQVElPTl9BTElBUyA9ICdwcml2YXRlLW5leHQtcnNjLWFjdGlvbi1lbmNyeXB0aW9uJ1xuZXhwb3J0IGNvbnN0IFJTQ19BQ1RJT05fQ0xJRU5UX1dSQVBQRVJfQUxJQVMgPVxuICAncHJpdmF0ZS1uZXh0LXJzYy1hY3Rpb24tY2xpZW50LXdyYXBwZXInXG5cbmV4cG9ydCBjb25zdCBQVUJMSUNfRElSX01JRERMRVdBUkVfQ09ORkxJQ1QgPSBgWW91IGNhbiBub3QgaGF2ZSBhICdfbmV4dCcgZm9sZGVyIGluc2lkZSBvZiB5b3VyIHB1YmxpYyBmb2xkZXIuIFRoaXMgY29uZmxpY3RzIHdpdGggdGhlIGludGVybmFsICcvX25leHQnIHJvdXRlLiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9wdWJsaWMtbmV4dC1mb2xkZXItY29uZmxpY3RgXG5cbmV4cG9ydCBjb25zdCBTU0dfR0VUX0lOSVRJQUxfUFJPUFNfQ09ORkxJQ1QgPSBgWW91IGNhbiBub3QgdXNlIGdldEluaXRpYWxQcm9wcyB3aXRoIGdldFN0YXRpY1Byb3BzLiBUbyB1c2UgU1NHLCBwbGVhc2UgcmVtb3ZlIHlvdXIgZ2V0SW5pdGlhbFByb3BzYFxuXG5leHBvcnQgY29uc3QgU0VSVkVSX1BST1BTX0dFVF9JTklUX1BST1BTX0NPTkZMSUNUID0gYFlvdSBjYW4gbm90IHVzZSBnZXRJbml0aWFsUHJvcHMgd2l0aCBnZXRTZXJ2ZXJTaWRlUHJvcHMuIFBsZWFzZSByZW1vdmUgZ2V0SW5pdGlhbFByb3BzLmBcblxuZXhwb3J0IGNvbnN0IFNFUlZFUl9QUk9QU19TU0dfQ09ORkxJQ1QgPSBgWW91IGNhbiBub3QgdXNlIGdldFN0YXRpY1Byb3BzIG9yIGdldFN0YXRpY1BhdGhzIHdpdGggZ2V0U2VydmVyU2lkZVByb3BzLiBUbyB1c2UgU1NHLCBwbGVhc2UgcmVtb3ZlIGdldFNlcnZlclNpZGVQcm9wc2BcblxuZXhwb3J0IGNvbnN0IFNUQVRJQ19TVEFUVVNfUEFHRV9HRVRfSU5JVElBTF9QUk9QU19FUlJPUiA9IGBjYW4gbm90IGhhdmUgZ2V0SW5pdGlhbFByb3BzL2dldFNlcnZlclNpZGVQcm9wcywgaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvNDA0LWdldC1pbml0aWFsLXByb3BzYFxuXG5leHBvcnQgY29uc3QgU0VSVkVSX1BST1BTX0VYUE9SVF9FUlJPUiA9IGBwYWdlcyB3aXRoIFxcYGdldFNlcnZlclNpZGVQcm9wc1xcYCBjYW4gbm90IGJlIGV4cG9ydGVkLiBTZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2dzc3AtZXhwb3J0YFxuXG5leHBvcnQgY29uc3QgR1NQX05PX1JFVFVSTkVEX1ZBTFVFID1cbiAgJ1lvdXIgYGdldFN0YXRpY1Byb3BzYCBmdW5jdGlvbiBkaWQgbm90IHJldHVybiBhbiBvYmplY3QuIERpZCB5b3UgZm9yZ2V0IHRvIGFkZCBhIGByZXR1cm5gPydcbmV4cG9ydCBjb25zdCBHU1NQX05PX1JFVFVSTkVEX1ZBTFVFID1cbiAgJ1lvdXIgYGdldFNlcnZlclNpZGVQcm9wc2AgZnVuY3Rpb24gZGlkIG5vdCByZXR1cm4gYW4gb2JqZWN0LiBEaWQgeW91IGZvcmdldCB0byBhZGQgYSBgcmV0dXJuYD8nXG5cbmV4cG9ydCBjb25zdCBVTlNUQUJMRV9SRVZBTElEQVRFX1JFTkFNRV9FUlJPUiA9XG4gICdUaGUgYHVuc3RhYmxlX3JldmFsaWRhdGVgIHByb3BlcnR5IGlzIGF2YWlsYWJsZSBmb3IgZ2VuZXJhbCB1c2UuXFxuJyArXG4gICdQbGVhc2UgdXNlIGByZXZhbGlkYXRlYCBpbnN0ZWFkLidcblxuZXhwb3J0IGNvbnN0IEdTU1BfQ09NUE9ORU5UX01FTUJFUl9FUlJPUiA9IGBjYW4gbm90IGJlIGF0dGFjaGVkIHRvIGEgcGFnZSdzIGNvbXBvbmVudCBhbmQgbXVzdCBiZSBleHBvcnRlZCBmcm9tIHRoZSBwYWdlLiBTZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2dzc3AtY29tcG9uZW50LW1lbWJlcmBcblxuZXhwb3J0IGNvbnN0IE5PTl9TVEFOREFSRF9OT0RFX0VOViA9IGBZb3UgYXJlIHVzaW5nIGEgbm9uLXN0YW5kYXJkIFwiTk9ERV9FTlZcIiB2YWx1ZSBpbiB5b3VyIGVudmlyb25tZW50LiBUaGlzIGNyZWF0ZXMgaW5jb25zaXN0ZW5jaWVzIGluIHRoZSBwcm9qZWN0IGFuZCBpcyBzdHJvbmdseSBhZHZpc2VkIGFnYWluc3QuIFJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbm9uLXN0YW5kYXJkLW5vZGUtZW52YFxuXG5leHBvcnQgY29uc3QgU1NHX0ZBTExCQUNLX0VYUE9SVF9FUlJPUiA9IGBQYWdlcyB3aXRoIFxcYGZhbGxiYWNrXFxgIGVuYWJsZWQgaW4gXFxgZ2V0U3RhdGljUGF0aHNcXGAgY2FuIG5vdCBiZSBleHBvcnRlZC4gU2VlIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9zc2ctZmFsbGJhY2stdHJ1ZS1leHBvcnRgXG5cbmV4cG9ydCBjb25zdCBFU0xJTlRfREVGQVVMVF9ESVJTID0gWydhcHAnLCAncGFnZXMnLCAnY29tcG9uZW50cycsICdsaWInLCAnc3JjJ11cblxuZXhwb3J0IGNvbnN0IFNFUlZFUl9SVU5USU1FOiBSZWNvcmQ8c3RyaW5nLCBTZXJ2ZXJSdW50aW1lPiA9IHtcbiAgZWRnZTogJ2VkZ2UnLFxuICBleHBlcmltZW50YWxFZGdlOiAnZXhwZXJpbWVudGFsLWVkZ2UnLFxuICBub2RlanM6ICdub2RlanMnLFxufVxuXG4vKipcbiAqIFRoZSBuYW1lcyBvZiB0aGUgd2VicGFjayBsYXllcnMuIFRoZXNlIGxheWVycyBhcmUgdGhlIHByaW1pdGl2ZXMgZm9yIHRoZVxuICogd2VicGFjayBjaHVua3MuXG4gKi9cbmNvbnN0IFdFQlBBQ0tfTEFZRVJTX05BTUVTID0ge1xuICAvKipcbiAgICogVGhlIGxheWVyIGZvciB0aGUgc2hhcmVkIGNvZGUgYmV0d2VlbiB0aGUgY2xpZW50IGFuZCBzZXJ2ZXIgYnVuZGxlcy5cbiAgICovXG4gIHNoYXJlZDogJ3NoYXJlZCcsXG4gIC8qKlxuICAgKiBUaGUgbGF5ZXIgZm9yIHNlcnZlci1vbmx5IHJ1bnRpbWUgYW5kIHBpY2tpbmcgdXAgYHJlYWN0LXNlcnZlcmAgZXhwb3J0IGNvbmRpdGlvbnMuXG4gICAqIEluY2x1ZGluZyBhcHAgcm91dGVyIFJTQyBwYWdlcyBhbmQgYXBwIHJvdXRlciBjdXN0b20gcm91dGVzIGFuZCBtZXRhZGF0YSByb3V0ZXMuXG4gICAqL1xuICByZWFjdFNlcnZlckNvbXBvbmVudHM6ICdyc2MnLFxuICAvKipcbiAgICogU2VydmVyIFNpZGUgUmVuZGVyaW5nIGxheWVyIGZvciBhcHAgKHNzcikuXG4gICAqL1xuICBzZXJ2ZXJTaWRlUmVuZGVyaW5nOiAnc3NyJyxcbiAgLyoqXG4gICAqIFRoZSBicm93c2VyIGNsaWVudCBidW5kbGUgbGF5ZXIgZm9yIGFjdGlvbnMuXG4gICAqL1xuICBhY3Rpb25Ccm93c2VyOiAnYWN0aW9uLWJyb3dzZXInLFxuICAvKipcbiAgICogVGhlIE5vZGUuanMgYnVuZGxlIGxheWVyIGZvciB0aGUgQVBJIHJvdXRlcy5cbiAgICovXG4gIGFwaU5vZGU6ICdhcGktbm9kZScsXG4gIC8qKlxuICAgKiBUaGUgRWRnZSBMaXRlIGJ1bmRsZSBsYXllciBmb3IgdGhlIEFQSSByb3V0ZXMuXG4gICAqL1xuICBhcGlFZGdlOiAnYXBpLWVkZ2UnLFxuICAvKipcbiAgICogVGhlIGxheWVyIGZvciB0aGUgbWlkZGxld2FyZSBjb2RlLlxuICAgKi9cbiAgbWlkZGxld2FyZTogJ21pZGRsZXdhcmUnLFxuICAvKipcbiAgICogVGhlIGxheWVyIGZvciB0aGUgaW5zdHJ1bWVudGF0aW9uIGhvb2tzLlxuICAgKi9cbiAgaW5zdHJ1bWVudDogJ2luc3RydW1lbnQnLFxuICAvKipcbiAgICogVGhlIGxheWVyIGZvciBhc3NldHMgb24gdGhlIGVkZ2UuXG4gICAqL1xuICBlZGdlQXNzZXQ6ICdlZGdlLWFzc2V0JyxcbiAgLyoqXG4gICAqIFRoZSBicm93c2VyIGNsaWVudCBidW5kbGUgbGF5ZXIgZm9yIEFwcCBkaXJlY3RvcnkuXG4gICAqL1xuICBhcHBQYWdlc0Jyb3dzZXI6ICdhcHAtcGFnZXMtYnJvd3NlcicsXG4gIC8qKlxuICAgKiBUaGUgYnJvd3NlciBjbGllbnQgYnVuZGxlIGxheWVyIGZvciBQYWdlcyBkaXJlY3RvcnkuXG4gICAqL1xuICBwYWdlc0RpckJyb3dzZXI6ICdwYWdlcy1kaXItYnJvd3NlcicsXG4gIC8qKlxuICAgKiBUaGUgRWRnZSBMaXRlIGJ1bmRsZSBsYXllciBmb3IgUGFnZXMgZGlyZWN0b3J5LlxuICAgKi9cbiAgcGFnZXNEaXJFZGdlOiAncGFnZXMtZGlyLWVkZ2UnLFxuICAvKipcbiAgICogVGhlIE5vZGUuanMgYnVuZGxlIGxheWVyIGZvciBQYWdlcyBkaXJlY3RvcnkuXG4gICAqL1xuICBwYWdlc0Rpck5vZGU6ICdwYWdlcy1kaXItbm9kZScsXG59IGFzIGNvbnN0XG5cbmV4cG9ydCB0eXBlIFdlYnBhY2tMYXllck5hbWUgPVxuICAodHlwZW9mIFdFQlBBQ0tfTEFZRVJTX05BTUVTKVtrZXlvZiB0eXBlb2YgV0VCUEFDS19MQVlFUlNfTkFNRVNdXG5cbmNvbnN0IFdFQlBBQ0tfTEFZRVJTID0ge1xuICAuLi5XRUJQQUNLX0xBWUVSU19OQU1FUyxcbiAgR1JPVVA6IHtcbiAgICBidWlsdGluUmVhY3Q6IFtcbiAgICAgIFdFQlBBQ0tfTEFZRVJTX05BTUVTLnJlYWN0U2VydmVyQ29tcG9uZW50cyxcbiAgICAgIFdFQlBBQ0tfTEFZRVJTX05BTUVTLmFjdGlvbkJyb3dzZXIsXG4gICAgXSxcbiAgICBzZXJ2ZXJPbmx5OiBbXG4gICAgICBXRUJQQUNLX0xBWUVSU19OQU1FUy5yZWFjdFNlcnZlckNvbXBvbmVudHMsXG4gICAgICBXRUJQQUNLX0xBWUVSU19OQU1FUy5hY3Rpb25Ccm93c2VyLFxuICAgICAgV0VCUEFDS19MQVlFUlNfTkFNRVMuaW5zdHJ1bWVudCxcbiAgICAgIFdFQlBBQ0tfTEFZRVJTX05BTUVTLm1pZGRsZXdhcmUsXG4gICAgXSxcbiAgICBuZXV0cmFsVGFyZ2V0OiBbXG4gICAgICAvLyBwYWdlcyBhcGlcbiAgICAgIFdFQlBBQ0tfTEFZRVJTX05BTUVTLmFwaU5vZGUsXG4gICAgICBXRUJQQUNLX0xBWUVSU19OQU1FUy5hcGlFZGdlLFxuICAgIF0sXG4gICAgY2xpZW50T25seTogW1xuICAgICAgV0VCUEFDS19MQVlFUlNfTkFNRVMuc2VydmVyU2lkZVJlbmRlcmluZyxcbiAgICAgIFdFQlBBQ0tfTEFZRVJTX05BTUVTLmFwcFBhZ2VzQnJvd3NlcixcbiAgICBdLFxuICAgIGJ1bmRsZWQ6IFtcbiAgICAgIFdFQlBBQ0tfTEFZRVJTX05BTUVTLnJlYWN0U2VydmVyQ29tcG9uZW50cyxcbiAgICAgIFdFQlBBQ0tfTEFZRVJTX05BTUVTLmFjdGlvbkJyb3dzZXIsXG4gICAgICBXRUJQQUNLX0xBWUVSU19OQU1FUy5zZXJ2ZXJTaWRlUmVuZGVyaW5nLFxuICAgICAgV0VCUEFDS19MQVlFUlNfTkFNRVMuYXBwUGFnZXNCcm93c2VyLFxuICAgICAgV0VCUEFDS19MQVlFUlNfTkFNRVMuc2hhcmVkLFxuICAgICAgV0VCUEFDS19MQVlFUlNfTkFNRVMuaW5zdHJ1bWVudCxcbiAgICAgIFdFQlBBQ0tfTEFZRVJTX05BTUVTLm1pZGRsZXdhcmUsXG4gICAgXSxcbiAgICBhcHBQYWdlczogW1xuICAgICAgLy8gYXBwIHJvdXRlciBwYWdlcyBhbmQgbGF5b3V0c1xuICAgICAgV0VCUEFDS19MQVlFUlNfTkFNRVMucmVhY3RTZXJ2ZXJDb21wb25lbnRzLFxuICAgICAgV0VCUEFDS19MQVlFUlNfTkFNRVMuc2VydmVyU2lkZVJlbmRlcmluZyxcbiAgICAgIFdFQlBBQ0tfTEFZRVJTX05BTUVTLmFwcFBhZ2VzQnJvd3NlcixcbiAgICAgIFdFQlBBQ0tfTEFZRVJTX05BTUVTLmFjdGlvbkJyb3dzZXIsXG4gICAgXSxcbiAgfSxcbn1cblxuY29uc3QgV0VCUEFDS19SRVNPVVJDRV9RVUVSSUVTID0ge1xuICBlZGdlU1NSRW50cnk6ICdfX25leHRfZWRnZV9zc3JfZW50cnlfXycsXG4gIG1ldGFkYXRhOiAnX19uZXh0X21ldGFkYXRhX18nLFxuICBtZXRhZGF0YVJvdXRlOiAnX19uZXh0X21ldGFkYXRhX3JvdXRlX18nLFxuICBtZXRhZGF0YUltYWdlTWV0YTogJ19fbmV4dF9tZXRhZGF0YV9pbWFnZV9tZXRhX18nLFxufVxuXG5leHBvcnQgeyBXRUJQQUNLX0xBWUVSUywgV0VCUEFDS19SRVNPVVJDRV9RVUVSSUVTIH1cbiJdLCJuYW1lcyI6WyJBQ1RJT05fU1VGRklYIiwiQVBQX0RJUl9BTElBUyIsIkNBQ0hFX09ORV9ZRUFSIiwiRE9UX05FWFRfQUxJQVMiLCJFU0xJTlRfREVGQVVMVF9ESVJTIiwiR1NQX05PX1JFVFVSTkVEX1ZBTFVFIiwiR1NTUF9DT01QT05FTlRfTUVNQkVSX0VSUk9SIiwiR1NTUF9OT19SRVRVUk5FRF9WQUxVRSIsIklORklOSVRFX0NBQ0hFIiwiSU5TVFJVTUVOVEFUSU9OX0hPT0tfRklMRU5BTUUiLCJNQVRDSEVEX1BBVEhfSEVBREVSIiwiTUlERExFV0FSRV9GSUxFTkFNRSIsIk1JRERMRVdBUkVfTE9DQVRJT05fUkVHRVhQIiwiTkVYVF9CT0RZX1NVRkZJWCIsIk5FWFRfQ0FDSEVfSU1QTElDSVRfVEFHX0lEIiwiTkVYVF9DQUNIRV9SRVZBTElEQVRFRF9UQUdTX0hFQURFUiIsIk5FWFRfQ0FDSEVfUkVWQUxJREFURV9UQUdfVE9LRU5fSEVBREVSIiwiTkVYVF9DQUNIRV9TT0ZUX1RBR19NQVhfTEVOR1RIIiwiTkVYVF9DQUNIRV9UQUdTX0hFQURFUiIsIk5FWFRfQ0FDSEVfVEFHX01BWF9JVEVNUyIsIk5FWFRfQ0FDSEVfVEFHX01BWF9MRU5HVEgiLCJORVhUX0RBVEFfU1VGRklYIiwiTkVYVF9JTlRFUkNFUFRJT05fTUFSS0VSX1BSRUZJWCIsIk5FWFRfTUVUQV9TVUZGSVgiLCJORVhUX1FVRVJZX1BBUkFNX1BSRUZJWCIsIk5FWFRfUkVTVU1FX0hFQURFUiIsIk5PTl9TVEFOREFSRF9OT0RFX0VOViIsIlBBR0VTX0RJUl9BTElBUyIsIlBSRVJFTkRFUl9SRVZBTElEQVRFX0hFQURFUiIsIlBSRVJFTkRFUl9SRVZBTElEQVRFX09OTFlfR0VORVJBVEVEX0hFQURFUiIsIlBVQkxJQ19ESVJfTUlERExFV0FSRV9DT05GTElDVCIsIlJPT1RfRElSX0FMSUFTIiwiUlNDX0FDVElPTl9DTElFTlRfV1JBUFBFUl9BTElBUyIsIlJTQ19BQ1RJT05fRU5DUllQVElPTl9BTElBUyIsIlJTQ19BQ1RJT05fUFJPWFlfQUxJQVMiLCJSU0NfQUNUSU9OX1ZBTElEQVRFX0FMSUFTIiwiUlNDX0NBQ0hFX1dSQVBQRVJfQUxJQVMiLCJSU0NfRFlOQU1JQ19JTVBPUlRfV1JBUFBFUl9BTElBUyIsIlJTQ19NT0RfUkVGX1BST1hZX0FMSUFTIiwiUlNDX1BSRUZFVENIX1NVRkZJWCIsIlJTQ19TRUdNRU5UU19ESVJfU1VGRklYIiwiUlNDX1NFR01FTlRfU1VGRklYIiwiUlNDX1NVRkZJWCIsIlNFUlZFUl9QUk9QU19FWFBPUlRfRVJST1IiLCJTRVJWRVJfUFJPUFNfR0VUX0lOSVRfUFJPUFNfQ09ORkxJQ1QiLCJTRVJWRVJfUFJPUFNfU1NHX0NPTkZMSUNUIiwiU0VSVkVSX1JVTlRJTUUiLCJTU0dfRkFMTEJBQ0tfRVhQT1JUX0VSUk9SIiwiU1NHX0dFVF9JTklUSUFMX1BST1BTX0NPTkZMSUNUIiwiU1RBVElDX1NUQVRVU19QQUdFX0dFVF9JTklUSUFMX1BST1BTX0VSUk9SIiwiVU5TVEFCTEVfUkVWQUxJREFURV9SRU5BTUVfRVJST1IiLCJXRUJQQUNLX0xBWUVSUyIsIldFQlBBQ0tfUkVTT1VSQ0VfUVVFUklFUyIsImVkZ2UiLCJleHBlcmltZW50YWxFZGdlIiwibm9kZWpzIiwiV0VCUEFDS19MQVlFUlNfTkFNRVMiLCJzaGFyZWQiLCJyZWFjdFNlcnZlckNvbXBvbmVudHMiLCJzZXJ2ZXJTaWRlUmVuZGVyaW5nIiwiYWN0aW9uQnJvd3NlciIsImFwaU5vZGUiLCJhcGlFZGdlIiwibWlkZGxld2FyZSIsImluc3RydW1lbnQiLCJlZGdlQXNzZXQiLCJhcHBQYWdlc0Jyb3dzZXIiLCJwYWdlc0RpckJyb3dzZXIiLCJwYWdlc0RpckVkZ2UiLCJwYWdlc0Rpck5vZGUiLCJHUk9VUCIsImJ1aWx0aW5SZWFjdCIsInNlcnZlck9ubHkiLCJuZXV0cmFsVGFyZ2V0IiwiY2xpZW50T25seSIsImJ1bmRsZWQiLCJhcHBQYWdlcyIsImVkZ2VTU1JFbnRyeSIsIm1ldGFkYXRhIiwibWV0YWRhdGFSb3V0ZSIsIm1ldGFkYXRhSW1hZ2VNZXRhIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQWNhQSxhQUFhLEVBQUE7ZUFBYkE7O0lBdUNBQyxhQUFhLEVBQUE7ZUFBYkE7O0lBbkJBQyxjQUFjLEVBQUE7ZUFBZEE7O0lBaUJBQyxjQUFjLEVBQUE7ZUFBZEE7O0lBd0NBQyxtQkFBbUIsRUFBQTtlQUFuQkE7O0lBZkFDLHFCQUFx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VztJQUNYOztHQUVDLEdBQ0RDLGlCQUFpQjtJQUNqQjs7R0FFQyxHQUNEQyxpQkFBaUI7SUFDakI7O0dBRUMsR0FDREMsY0FBYztJQUNkOztHQUVDLEdBQ0RDLGNBQWM7QUFDaEI7QUFLQSxNQUFNbEIsaUJBQWlCO0lBQ3JCLEdBQUdLLG9CQUFvQjtJQUN2QmMsT0FBTztRQUNMQyxjQUFjO1lBQ1pmLHFCQUFxQkUscUJBQXFCO1lBQzFDRixxQkFBcUJJLGFBQWE7U0FDbkM7UUFDRFksWUFBWTtZQUNWaEIscUJBQXFCRSxxQkFBcUI7WUFDMUNGLHFCQUFxQkksYUFBYTtZQUNsQ0oscUJBQXFCUSxVQUFVO1lBQy9CUixxQkFBcUJPLFVBQVU7U0FDaEM7UUFDRFUsZUFBZTtZQUNiLFlBQVk7WUFDWmpCLHFCQUFxQkssT0FBTztZQUM1QkwscUJBQXFCTSxPQUFPO1NBQzdCO1FBQ0RZLFlBQVk7WUFDVmxCLHFCQUFxQkcsbUJBQW1CO1lBQ3hDSCxxQkFBcUJVLGVBQWU7U0FDckM7UUFDRFMsU0FBUztZQUNQbkIscUJBQXFCRSxxQkFBcUI7WUFDMUNGLHFCQUFxQkksYUFBYTtZQUNsQ0oscUJBQXFCRyxtQkFBbUI7WUFDeENILHFCQUFxQlUsZUFBZTtZQUNwQ1YscUJBQXFCQyxNQUFNO1lBQzNCRCxxQkFBcUJRLFVBQVU7WUFDL0JSLHFCQUFxQk8sVUFBVTtTQUNoQztRQUNEYSxVQUFVO1lBQ1IsK0JBQStCO1lBQy9CcEIscUJBQXFCRSxxQkFBcUI7WUFDMUNGLHFCQUFxQkcsbUJBQW1CO1lBQ3hDSCxxQkFBcUJVLGVBQWU7WUFDcENWLHFCQUFxQkksYUFBYTtTQUNuQztJQUNIO0FBQ0Y7QUFFQSxNQUFNUiwyQkFBMkI7SUFDL0J5QixjQUFjO0lBQ2RDLFVBQVU7SUFDVkMsZUFBZTtJQUNmQyxtQkFBbUI7QUFDckIiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNDY0LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2xpYi9pcy1lcnJvci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc1BsYWluT2JqZWN0IH0gZnJvbSAnLi4vc2hhcmVkL2xpYi9pcy1wbGFpbi1vYmplY3QnXG5cbi8vIFdlIGFsbG93IHNvbWUgYWRkaXRpb25hbCBhdHRhY2hlZCBwcm9wZXJ0aWVzIGZvciBOZXh0LmpzIGVycm9yc1xuZXhwb3J0IGludGVyZmFjZSBOZXh0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIHR5cGU/OiBzdHJpbmdcbiAgcGFnZT86IHN0cmluZ1xuICBjb2RlPzogc3RyaW5nIHwgbnVtYmVyXG4gIGNhbmNlbGxlZD86IGJvb2xlYW5cbiAgZGlnZXN0PzogbnVtYmVyXG59XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgTmV4dEVycm9yLlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBwcmludCBhIG1vcmUgZGV0YWlsZWQgZXJyb3IgbWVzc2FnZSB3aXRoIHByb3BlcnRpZXMgbGlrZSBgY29kZWAgJiBgZGlnZXN0YC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNFcnJvcihlcnI6IHVua25vd24pOiBlcnIgaXMgTmV4dEVycm9yIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2YgZXJyID09PSAnb2JqZWN0JyAmJiBlcnIgIT09IG51bGwgJiYgJ25hbWUnIGluIGVyciAmJiAnbWVzc2FnZScgaW4gZXJyXG4gIClcbn1cblxuZnVuY3Rpb24gc2FmZVN0cmluZ2lmeShvYmo6IGFueSkge1xuICBjb25zdCBzZWVuID0gbmV3IFdlYWtTZXQoKVxuXG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmosIChfa2V5LCB2YWx1ZSkgPT4ge1xuICAgIC8vIElmIHZhbHVlIGlzIGFuIG9iamVjdCBhbmQgYWxyZWFkeSBzZWVuLCByZXBsYWNlIHdpdGggXCJbQ2lyY3VsYXJdXCJcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKHNlZW4uaGFzKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nXG4gICAgICB9XG4gICAgICBzZWVuLmFkZCh2YWx1ZSlcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlXG4gIH0pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQcm9wZXJFcnJvcihlcnI6IHVua25vd24pOiBFcnJvciB7XG4gIGlmIChpc0Vycm9yKGVycikpIHtcbiAgICByZXR1cm4gZXJyXG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAvLyBwcm92aWRlIGJldHRlciBlcnJvciBmb3IgY2FzZSB3aGVyZSBgdGhyb3cgdW5kZWZpbmVkYFxuICAgIC8vIGlzIGNhbGxlZCBpbiBkZXZlbG9wbWVudFxuICAgIGlmICh0eXBlb2YgZXJyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICAgICAgJ0FuIHVuZGVmaW5lZCBlcnJvciB3YXMgdGhyb3duLCAnICtcbiAgICAgICAgICAnc2VlIGhlcmUgZm9yIG1vcmUgaW5mbzogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvdGhyZXctdW5kZWZpbmVkJ1xuICAgICAgKVxuICAgIH1cblxuICAgIGlmIChlcnIgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gICAgICAgICdBIG51bGwgZXJyb3Igd2FzIHRocm93biwgJyArXG4gICAgICAgICAgJ3NlZSBoZXJlIGZvciBtb3JlIGluZm86IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL3RocmV3LXVuZGVmaW5lZCdcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IEVycm9yKGlzUGxhaW5PYmplY3QoZXJyKSA/IHNhZmVTdHJpbmdpZnkoZXJyKSA6IGVyciArICcnKVxufVxuIl0sIm5hbWVzIjpbImlzRXJyb3IiLCJnZXRQcm9wZXJFcnJvciIsImVyciIsInNhZmVTdHJpbmdpZnkiLCJvYmoiLCJzZWVuIiwiV2Vha1NldCIsIkpTT04iLCJzdHJpbmdpZnkiLCJfa2V5IiwidmFsdWUiLCJoYXMiLCJhZGQiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJFcnJvciIsImlzUGxhaW5PYmplY3QiXSwibWFwcGluZ3MiOiJBQXlDTWEsUUFBUUMsR0FBRyxDQUFDQyxRQUFRLEtBQUs7Ozs7Ozs7Ozs7Ozs7Ozs7SUE5Qi9COzs7Q0FHQyxHQUNELE9BSUMsRUFBQTtlQUp1QmY7O0lBcUJSQyxjQUFjLEVBQUE7ZUFBZEE7OzsrQkFwQ2M7QUFlZixTQUFTRCxRQUFRRSxHQUFZO0lBQzFDLE9BQ0UsT0FBT0EsUUFBUSxZQUFZQSxRQUFRLFFBQVEsVUFBVUEsT0FBTyxhQUFhQTtBQUU3RTtBQUVBLFNBQVNDLGNBQWNDLEdBQVE7SUFDN0IsTUFBTUMsT0FBTyxJQUFJQztJQUVqQixPQUFPQyxLQUFLQyxTQUFTLENBQUNKLEtBQUssQ0FBQ0ssTUFBTUM7UUFDaEMsb0VBQW9FO1FBQ3BFLElBQUksT0FBT0EsVUFBVSxZQUFZQSxVQUFVLE1BQU07WUFDL0MsSUFBSUwsS0FBS00sR0FBRyxDQUFDRCxRQUFRO2dCQUNuQixPQUFPO1lBQ1Q7WUFDQUwsS0FBS08sR0FBRyxDQUFDRjtRQUNYO1FBQ0EsT0FBT0E7SUFDVDtBQUNGO0FBRU8sU0FBU1QsZUFBZUMsR0FBWTtJQUN6QyxJQUFJRixRQUFRRSxNQUFNO1FBQ2hCLE9BQU9BO0lBQ1Q7SUFFQSx3Q0FBNEM7UUFDMUMsd0RBQXdEO1FBQ3hELDJCQUEyQjtRQUMzQixJQUFJLE9BQU9BLFFBQVEsYUFBYTtZQUM5QixPQUFPLE9BQUEsY0FHTixDQUhNLElBQUljLE1BQ1Qsb0NBQ0UsNkVBRkcscUJBQUE7dUJBQUE7NEJBQUE7OEJBQUE7WUFHUDtRQUNGO1FBRUEsSUFBSWQsUUFBUSxNQUFNO1lBQ2hCLE9BQU8sT0FBQSxjQUdOLENBSE0sSUFBSWMsTUFDVCw4QkFDRSw2RUFGRyxxQkFBQTt1QkFBQTs0QkFBQTs4QkFBQTtZQUdQO1FBQ0Y7SUFDRjtJQUVBLE9BQU8sT0FBQSxjQUE2RCxDQUE3RCxJQUFJQSxNQUFNQyxDQUFBQSxHQUFBQSxlQUFBQSxhQUFhLEVBQUNmLE9BQU9DLGNBQWNELE9BQU9BLE1BQU0sS0FBMUQscUJBQUE7ZUFBQTtvQkFBQTtzQkFBQTtJQUE0RDtBQUNyRSIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA1NDEsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvbGliL2lzLWFwaS1yb3V0ZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gaXNBUElSb3V0ZSh2YWx1ZT86IHN0cmluZykge1xuICByZXR1cm4gdmFsdWUgPT09ICcvYXBpJyB8fCBCb29sZWFuKHZhbHVlPy5zdGFydHNXaXRoKCcvYXBpLycpKVxufVxuIl0sIm5hbWVzIjpbImlzQVBJUm91dGUiLCJ2YWx1ZSIsIkJvb2xlYW4iLCJzdGFydHNXaXRoIl0sIm1hcHBpbmdzIjoiOzs7K0JBQWdCQSxjQUFBQTs7O2VBQUFBOzs7QUFBVCxTQUFTQSxXQUFXQyxLQUFjO0lBQ3ZDLE9BQU9BLFVBQVUsVUFBVUMsUUFBUUQsU0FBQUEsT0FBQUEsS0FBQUEsSUFBQUEsTUFBT0UsVUFBVSxDQUFDO0FBQ3ZEIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDU1OSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9saWIvcmVxdWlyZS1pbnN0cnVtZW50YXRpb24tY2xpZW50LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGhpcyBtb2R1bGUgaW1wb3J0cyB0aGUgY2xpZW50IGluc3RydW1lbnRhdGlvbiBob29rIGZyb20gdGhlIHByb2plY3Qgcm9vdC5cbiAqXG4gKiBUaGUgYHByaXZhdGUtbmV4dC1pbnN0cnVtZW50YXRpb24tY2xpZW50YCBtb2R1bGUgaXMgYXV0b21hdGljYWxseSBhbGlhc2VkIHRvXG4gKiB0aGUgYGluc3RydW1lbnRhdGlvbi1jbGllbnQudHNgIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBieSB3ZWJwYWNrIG9yIHR1cmJvcGFjay5cbiAqL1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gIGNvbnN0IG1lYXN1cmVOYW1lID0gJ0NsaWVudCBJbnN0cnVtZW50YXRpb24gSG9vaydcbiAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KClcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEBuZXh0L2ludGVybmFsL3R5cGVjaGVja2VkLXJlcXVpcmUgLS0gTm90IGEgbW9kdWxlLlxuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ3ByaXZhdGUtbmV4dC1pbnN0cnVtZW50YXRpb24tY2xpZW50JylcbiAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpXG4gIGNvbnN0IGR1cmF0aW9uID0gZW5kVGltZSAtIHN0YXJ0VGltZVxuXG4gIC8vIFVzaW5nIDE2bXMgdGhyZXNob2xkIGFzIGl0IHJlcHJlc2VudHMgb25lIGZyYW1lICgxMDAwbXMvNjBmcHMpXG4gIC8vIFRoaXMgaGVscHMgaWRlbnRpZnkgaWYgdGhlIGluc3RydW1lbnRhdGlvbiBob29rIGluaXRpYWxpemF0aW9uXG4gIC8vIGNvdWxkIHBvdGVudGlhbGx5IGNhdXNlIGZyYW1lIGRyb3BzIGR1cmluZyBkZXZlbG9wbWVudC5cbiAgY29uc3QgVEhSRVNIT0xEID0gMTZcbiAgaWYgKGR1cmF0aW9uID4gVEhSRVNIT0xEKSB7XG4gICAgY29uc29sZS5sb2coXG4gICAgICBgWyR7bWVhc3VyZU5hbWV9XSBTbG93IGV4ZWN1dGlvbiBkZXRlY3RlZDogJHtkdXJhdGlvbi50b0ZpeGVkKDApfW1zIChOb3RlOiBDb2RlIGRvd25sb2FkIG92ZXJoZWFkIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGlzIG1lYXN1cmVtZW50KWBcbiAgICApXG4gIH1cbn0gZWxzZSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAbmV4dC9pbnRlcm5hbC90eXBlY2hlY2tlZC1yZXF1aXJlIC0tIE5vdCBhIG1vZHVsZS5cbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdwcml2YXRlLW5leHQtaW5zdHJ1bWVudGF0aW9uLWNsaWVudCcpXG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwibWVhc3VyZU5hbWUiLCJzdGFydFRpbWUiLCJwZXJmb3JtYW5jZSIsIm5vdyIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIiwiZW5kVGltZSIsImR1cmF0aW9uIiwiVEhSRVNIT0xEIiwiY29uc29sZSIsImxvZyIsInRvRml4ZWQiXSwibWFwcGluZ3MiOiJBQUFBOzs7OztDQUtDLEdBQ0dBLFFBQVFDLEdBQUcsQ0FBQ0MsUUFBUSxLQUFLO0FBRDVCO0FBQ0Qsd0NBQTRDO0lBQzFDLE1BQU1DLGNBQWM7SUFDcEIsTUFBTUMsWUFBWUMsWUFBWUMsR0FBRztJQUNqQywrRUFBK0U7SUFDL0VDLE9BQU9DLE9BQU8sR0FBR0MsUUFBUTtJQUN6QixNQUFNQyxVQUFVTCxZQUFZQyxHQUFHO0lBQy9CLE1BQU1LLFdBQVdELFVBQVVOO0lBRTNCLGlFQUFpRTtJQUNqRSxpRUFBaUU7SUFDakUsMERBQTBEO0lBQzFELE1BQU1RLFlBQVk7SUFDbEIsSUFBSUQsV0FBV0MsV0FBVztRQUN4QkMsUUFBUUMsR0FBRyxDQUNULEFBQUMsQ0FBQyxVQUFFWCxhQUFZLDJCQUEyQixXQUFFUSxTQUFTSSxPQUFPLENBQUMsSUFBRyxxRUFBcUUsQ0FBQztJQUUzSTtBQUNGLE9BQU8iLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNTg5LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL25leHQtZGV2dG9vbHMvdXNlcnNwYWNlL2FwcC9lcnJvcnMvc3RpdGNoZWQtZXJyb3IudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IGlzRXJyb3IgZnJvbSAnLi4vLi4vLi4vLi4vbGliL2lzLWVycm9yJ1xuXG5jb25zdCBvd25lclN0YWNrcyA9IG5ldyBXZWFrTWFwPEVycm9yLCBzdHJpbmcgfCBudWxsPigpXG5jb25zdCBjb21wb25lbnRTdGFja3MgPSBuZXcgV2Vha01hcDxFcnJvciwgc3RyaW5nPigpXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb21wb25lbnRTdGFjayhlcnJvcjogRXJyb3IpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICByZXR1cm4gY29tcG9uZW50U3RhY2tzLmdldChlcnJvcilcbn1cbmV4cG9ydCBmdW5jdGlvbiBzZXRDb21wb25lbnRTdGFjayhlcnJvcjogRXJyb3IsIHN0YWNrOiBzdHJpbmcpIHtcbiAgY29tcG9uZW50U3RhY2tzLnNldChlcnJvciwgc3RhY2spXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRPd25lclN0YWNrKGVycm9yOiBFcnJvcik6IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQge1xuICByZXR1cm4gb3duZXJTdGFja3MuZ2V0KGVycm9yKVxufVxuZXhwb3J0IGZ1bmN0aW9uIHNldE93bmVyU3RhY2soZXJyb3I6IEVycm9yLCBzdGFjazogc3RyaW5nIHwgbnVsbCkge1xuICBvd25lclN0YWNrcy5zZXQoZXJyb3IsIHN0YWNrKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29lcmNlRXJyb3IodmFsdWU6IHVua25vd24pOiBFcnJvciB7XG4gIHJldHVybiBpc0Vycm9yKHZhbHVlKSA/IHZhbHVlIDogbmV3IEVycm9yKCcnICsgdmFsdWUpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRPd25lclN0YWNrSWZBdmFpbGFibGUoZXJyb3I6IEVycm9yKTogdm9pZCB7XG4gIC8vIFJlYWN0IDE4IGFuZCBwcm9kIGRvZXMgbm90IGhhdmUgYGNhcHR1cmVPd25lclN0YWNrYFxuICBpZiAoJ2NhcHR1cmVPd25lclN0YWNrJyBpbiBSZWFjdCkge1xuICAgIHNldE93bmVyU3RhY2soZXJyb3IsIFJlYWN0LmNhcHR1cmVPd25lclN0YWNrKCkpXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlY29yYXRlRGV2RXJyb3IoXG4gIHRocm93blZhbHVlOiB1bmtub3duLFxuICBlcnJvckluZm86IFJlYWN0LkVycm9ySW5mb1xuKSB7XG4gIGNvbnN0IGVycm9yID0gY29lcmNlRXJyb3IodGhyb3duVmFsdWUpXG4gIHNldE93bmVyU3RhY2tJZkF2YWlsYWJsZShlcnJvcilcbiAgLy8gVE9ETzogY2hhbmdlIHRvIHBhc3NpbmcgZG93biBlcnJvckluZm8gbGF0ZXJcbiAgLy8gSW4gZGV2ZWxvcG1lbnQgbW9kZSwgcGFzcyBhbG9uZyB0aGUgY29tcG9uZW50IHN0YWNrIHRvIHRoZSBlcnJvclxuICBpZiAoZXJyb3JJbmZvLmNvbXBvbmVudFN0YWNrKSB7XG4gICAgc2V0Q29tcG9uZW50U3RhY2soZXJyb3IsIGVycm9ySW5mby5jb21wb25lbnRTdGFjaylcbiAgfVxuICByZXR1cm4gZXJyb3Jcbn1cbiJdLCJuYW1lcyI6WyJjb2VyY2VFcnJvciIsImRlY29yYXRlRGV2RXJyb3IiLCJnZXRDb21wb25lbnRTdGFjayIsImdldE93bmVyU3RhY2siLCJzZXRDb21wb25lbnRTdGFjayIsInNldE93bmVyU3RhY2siLCJzZXRPd25lclN0YWNrSWZBdmFpbGFibGUiLCJvd25lclN0YWNrcyIsIldlYWtNYXAiLCJjb21wb25lbnRTdGFja3MiLCJlcnJvciIsImdldCIsInN0YWNrIiwic2V0IiwidmFsdWUiLCJpc0Vycm9yIiwiRXJyb3IiLCJSZWFjdCIsImNhcHR1cmVPd25lclN0YWNrIiwidGhyb3duVmFsdWUiLCJlcnJvckluZm8iLCJjb21wb25lbnRTdGFjayJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQW9CZ0JBLFdBQVcsRUFBQTtlQUFYQTs7SUFXQUMsZ0JBQWdCLEVBQUE7ZUFBaEJBOztJQXpCQUMsaUJBQWlCLEVBQUE7ZUFBakJBOztJQU9BQyxhQUFhLEVBQUE7ZUFBYkE7O0lBSkFDLGlCQUFpQixFQUFBO2VBQWpCQTs7SUFPQUMsYUFBYSxFQUFBO2VBQWJBOztJQVFBQyx3QkFBd0IsRUFBQTtlQUF4QkE7Ozs7Z0VBeEJFO2tFQUNFO0FBRXBCLE1BQU1DLGNBQWMsSUFBSUM7QUFDeEIsTUFBTUMsa0JBQWtCLElBQUlEO0FBRXJCLFNBQVNOLGtCQUFrQlEsS0FBWTtJQUM1QyxPQUFPRCxnQkFBZ0JFLEdBQUcsQ0FBQ0Q7QUFDN0I7QUFDTyxTQUFTTixrQkFBa0JNLEtBQVksRUFBRUUsS0FBYTtJQUMzREgsZ0JBQWdCSSxHQUFHLENBQUNILE9BQU9FO0FBQzdCO0FBRU8sU0FBU1QsY0FBY08sS0FBWTtJQUN4QyxPQUFPSCxZQUFZSSxHQUFHLENBQUNEO0FBQ3pCO0FBQ08sU0FBU0wsY0FBY0ssS0FBWSxFQUFFRSxLQUFvQjtJQUM5REwsWUFBWU0sR0FBRyxDQUFDSCxPQUFPRTtBQUN6QjtBQUVPLFNBQVNaLFlBQVljLEtBQWM7SUFDeEMsT0FBT0MsQ0FBQUEsR0FBQUEsU0FBQUEsT0FBTyxFQUFDRCxTQUFTQSxRQUFRLE9BQUEsY0FBcUIsQ0FBckIsSUFBSUUsTUFBTSxLQUFLRixRQUFmLHFCQUFBO2VBQUE7b0JBQUE7c0JBQUE7SUFBb0I7QUFDdEQ7QUFFTyxTQUFTUix5QkFBeUJJLEtBQVk7SUFDbkQsc0RBQXNEO0lBQ3RELElBQUksdUJBQXVCTyxPQUFBQSxPQUFLLEVBQUU7UUFDaENaLGNBQWNLLE9BQU9PLE9BQUFBLE9BQUssQ0FBQ0MsaUJBQWlCO0lBQzlDO0FBQ0Y7QUFFTyxTQUFTakIsaUJBQ2RrQixXQUFvQixFQUNwQkMsU0FBMEI7SUFFMUIsTUFBTVYsUUFBUVYsWUFBWW1CO0lBQzFCYix5QkFBeUJJO0lBQ3pCLCtDQUErQztJQUMvQyxtRUFBbUU7SUFDbkUsSUFBSVUsVUFBVUMsY0FBYyxFQUFFO1FBQzVCakIsa0JBQWtCTSxPQUFPVSxVQUFVQyxjQUFjO0lBQ25EO0lBQ0EsT0FBT1g7QUFDVCIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA2ODMsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvbmV4dC1kZXZ0b29scy9zaGFyZWQvcmVhY3QtMTgtaHlkcmF0aW9uLWVycm9yLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBpc0Vycm9yIGZyb20gJy4uLy4uL2xpYi9pcy1lcnJvcidcblxuZXhwb3J0IGZ1bmN0aW9uIGlzSHlkcmF0aW9uRXJyb3IoZXJyb3I6IHVua25vd24pOiBib29sZWFuIHtcbiAgcmV0dXJuIChcbiAgICBpc0Vycm9yKGVycm9yKSAmJlxuICAgIChlcnJvci5tZXNzYWdlID09PVxuICAgICAgJ0h5ZHJhdGlvbiBmYWlsZWQgYmVjYXVzZSB0aGUgaW5pdGlhbCBVSSBkb2VzIG5vdCBtYXRjaCB3aGF0IHdhcyByZW5kZXJlZCBvbiB0aGUgc2VydmVyLicgfHxcbiAgICAgIGVycm9yLm1lc3NhZ2UgPT09ICdUZXh0IGNvbnRlbnQgZG9lcyBub3QgbWF0Y2ggc2VydmVyLXJlbmRlcmVkIEhUTUwuJylcbiAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNIeWRyYXRpb25XYXJuaW5nKG1lc3NhZ2U6IHVua25vd24pOiBtZXNzYWdlIGlzIHN0cmluZyB7XG4gIHJldHVybiAoXG4gICAgaXNIdG1sVGFnc1dhcm5pbmcobWVzc2FnZSkgfHxcbiAgICBpc1RleHRJblRhZ3NNaXNtYXRjaFdhcm5pbmcobWVzc2FnZSkgfHxcbiAgICBpc1RleHRXYXJuaW5nKG1lc3NhZ2UpXG4gIClcbn1cblxudHlwZSBOdWxsYWJsZVRleHQgPSBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkXG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iL21haW4vcGFja2FnZXMvcmVhY3QtZG9tL3NyYy9fX3Rlc3RzX18vUmVhY3RET01IeWRyYXRpb25EaWZmLXRlc3QuanMgdXNlZCBhcyBhIHJlZmVyZW5jZVxuY29uc3QgaHRtbFRhZ3NXYXJuaW5ncyA9IG5ldyBTZXQoW1xuICAnV2FybmluZzogRXhwZWN0ZWQgc2VydmVyIEhUTUwgdG8gY29udGFpbiBhIG1hdGNoaW5nIDwlcz4gaW4gPCVzPi4lcycsXG4gICdXYXJuaW5nOiBEaWQgbm90IGV4cGVjdCBzZXJ2ZXIgSFRNTCB0byBjb250YWluIGEgPCVzPiBpbiA8JXM+LiVzJyxcbl0pXG5jb25zdCB0ZXh0QW5kVGFnc01pc21hdGNoV2FybmluZ3MgPSBuZXcgU2V0KFtcbiAgJ1dhcm5pbmc6IEV4cGVjdGVkIHNlcnZlciBIVE1MIHRvIGNvbnRhaW4gYSBtYXRjaGluZyB0ZXh0IG5vZGUgZm9yIFwiJXNcIiBpbiA8JXM+LiVzJyxcbiAgJ1dhcm5pbmc6IERpZCBub3QgZXhwZWN0IHNlcnZlciBIVE1MIHRvIGNvbnRhaW4gdGhlIHRleHQgbm9kZSBcIiVzXCIgaW4gPCVzPi4lcycsXG5dKVxuY29uc3QgdGV4dFdhcm5pbmdzID0gbmV3IFNldChbXG4gICdXYXJuaW5nOiBUZXh0IGNvbnRlbnQgZGlkIG5vdCBtYXRjaC4gU2VydmVyOiBcIiVzXCIgQ2xpZW50OiBcIiVzXCIlcycsXG5dKVxuXG5leHBvcnQgY29uc3QgZ2V0SHlkcmF0aW9uV2FybmluZ1R5cGUgPSAoXG4gIG1lc3NhZ2U6IE51bGxhYmxlVGV4dFxuKTogJ3RhZycgfCAndGV4dCcgfCAndGV4dC1pbi10YWcnID0+IHtcbiAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSAnc3RyaW5nJykge1xuICAgIC8vIFRPRE86IERvZXNuJ3QgbWFrZSBzZW5zZSB0byB0cmVhdCBubyBtZXNzYWdlIGFzIGEgaHlkcmF0aW9uIGVycm9yIG1lc3NhZ2UuXG4gICAgLy8gV2Ugc2hvdWxkIGJhaWwgb3V0IHNvbWV3aGVyZSBlYXJsaWVyLlxuICAgIHJldHVybiAndGV4dCdcbiAgfVxuXG4gIGNvbnN0IG5vcm1hbGl6ZWRNZXNzYWdlID0gbWVzc2FnZS5zdGFydHNXaXRoKCdXYXJuaW5nOiAnKVxuICAgID8gbWVzc2FnZVxuICAgIDogYFdhcm5pbmc6ICR7bWVzc2FnZX1gXG5cbiAgaWYgKGlzSHRtbFRhZ3NXYXJuaW5nKG5vcm1hbGl6ZWRNZXNzYWdlKSkgcmV0dXJuICd0YWcnXG4gIGlmIChpc1RleHRJblRhZ3NNaXNtYXRjaFdhcm5pbmcobm9ybWFsaXplZE1lc3NhZ2UpKSByZXR1cm4gJ3RleHQtaW4tdGFnJ1xuXG4gIHJldHVybiAndGV4dCdcbn1cblxuY29uc3QgaXNIdG1sVGFnc1dhcm5pbmcgPSAobWVzc2FnZTogdW5rbm93bikgPT5cbiAgdHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnICYmIGh0bWxUYWdzV2FybmluZ3MuaGFzKG1lc3NhZ2UpXG5cbmNvbnN0IGlzVGV4dEluVGFnc01pc21hdGNoV2FybmluZyA9IChtc2c6IHVua25vd24pID0+XG4gIHR5cGVvZiBtc2cgPT09ICdzdHJpbmcnICYmIHRleHRBbmRUYWdzTWlzbWF0Y2hXYXJuaW5ncy5oYXMobXNnKVxuXG5jb25zdCBpc1RleHRXYXJuaW5nID0gKG1zZzogdW5rbm93bikgPT5cbiAgdHlwZW9mIG1zZyA9PT0gJ3N0cmluZycgJiYgdGV4dFdhcm5pbmdzLmhhcyhtc2cpXG4iXSwibmFtZXMiOlsiZ2V0SHlkcmF0aW9uV2FybmluZ1R5cGUiLCJpc0h5ZHJhdGlvbkVycm9yIiwiaXNIeWRyYXRpb25XYXJuaW5nIiwiZXJyb3IiLCJpc0Vycm9yIiwibWVzc2FnZSIsImlzSHRtbFRhZ3NXYXJuaW5nIiwiaXNUZXh0SW5UYWdzTWlzbWF0Y2hXYXJuaW5nIiwiaXNUZXh0V2FybmluZyIsImh0bWxUYWdzV2FybmluZ3MiLCJTZXQiLCJ0ZXh0QW5kVGFnc01pc21hdGNoV2FybmluZ3MiLCJ0ZXh0V2FybmluZ3MiLCJub3JtYWxpemVkTWVzc2FnZSIsInN0YXJ0c1dpdGgiLCJoYXMiLCJtc2ciXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztJQWtDYUEsdUJBQXVCLEVBQUE7ZUFBdkJBOztJQWhDR0MsZ0JBQWdCLEVBQUE7ZUFBaEJBOztJQVNBQyxrQkFBa0IsRUFBQTtlQUFsQkE7Ozs7a0VBWEk7QUFFYixTQUFTRCxpQkFBaUJFLEtBQWM7SUFDN0MsT0FDRUMsQ0FBQUEsR0FBQUEsU0FBQUEsT0FBTyxFQUFDRCxVQUNQQSxDQUFBQSxNQUFNRSxPQUFPLEtBQ1osNkZBQ0FGLE1BQU1FLE9BQU8sS0FBSyxtREFBa0Q7QUFFMUU7QUFFTyxTQUFTSCxtQkFBbUJHLE9BQWdCO0lBQ2pELE9BQ0VDLGtCQUFrQkQsWUFDbEJFLDRCQUE0QkYsWUFDNUJHLGNBQWNIO0FBRWxCO0FBSUEsaUlBQWlJO0FBQ2pJLE1BQU1JLG1CQUFtQixJQUFJQyxJQUFJO0lBQy9CO0lBQ0E7Q0FDRDtBQUNELE1BQU1DLDhCQUE4QixJQUFJRCxJQUFJO0lBQzFDO0lBQ0E7Q0FDRDtBQUNELE1BQU1FLGVBQWUsSUFBSUYsSUFBSTtJQUMzQjtDQUNEO0FBRU0sTUFBTVYsMEJBQTBCLENBQ3JDSztJQUVBLElBQUksT0FBT0EsWUFBWSxVQUFVO1FBQy9CLDZFQUE2RTtRQUM3RSx3Q0FBd0M7UUFDeEMsT0FBTztJQUNUO0lBRUEsTUFBTVEsb0JBQW9CUixRQUFRUyxVQUFVLENBQUMsZUFDekNULFVBQ0MsY0FBV0E7SUFFaEIsSUFBSUMsa0JBQWtCTyxvQkFBb0IsT0FBTztJQUNqRCxJQUFJTiw0QkFBNEJNLG9CQUFvQixPQUFPO0lBRTNELE9BQU87QUFDVDtBQUVBLE1BQU1QLG9CQUFvQixDQUFDRCxVQUN6QixPQUFPQSxZQUFZLFlBQVlJLGlCQUFpQk0sR0FBRyxDQUFDVjtBQUV0RCxNQUFNRSw4QkFBOEIsQ0FBQ1MsTUFDbkMsT0FBT0EsUUFBUSxZQUFZTCw0QkFBNEJJLEdBQUcsQ0FBQ0M7QUFFN0QsTUFBTVIsZ0JBQWdCLENBQUNRLE1BQ3JCLE9BQU9BLFFBQVEsWUFBWUosYUFBYUcsR0FBRyxDQUFDQyIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA3NTUsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvbmV4dC1kZXZ0b29scy9zaGFyZWQvcmVhY3QtMTktaHlkcmF0aW9uLWVycm9yLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBSRUFDVF9IWURSQVRJT05fRVJST1JfTElOSyA9XG4gICdodHRwczovL3JlYWN0LmRldi9saW5rL2h5ZHJhdGlvbi1taXNtYXRjaCdcbmV4cG9ydCBjb25zdCBORVhUSlNfSFlEUkFUSU9OX0VSUk9SX0xJTksgPVxuICAnaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvcmVhY3QtaHlkcmF0aW9uLWVycm9yJ1xuXG4vKipcbiAqIE9ubHkgUmVhY3QgMTkrIGNvbnRhaW5zIGNvbXBvbmVudCBzdGFjayBkaWZmIGluIHRoZSBlcnJvciBtZXNzYWdlXG4gKi9cbmNvbnN0IGVycm9yTWVzc2FnZXNXaXRoQ29tcG9uZW50U3RhY2tEaWZmID0gW1xuICAvXkluIEhUTUwsICguKz8pIGNhbm5vdCBiZSBhIGNoaWxkIG9mIDwoLis/KT5cXC4oLiopXFxuVGhpcyB3aWxsIGNhdXNlIGEgaHlkcmF0aW9uIGVycm9yXFwuKC4qKS8sXG4gIC9eSW4gSFRNTCwgKC4rPykgY2Fubm90IGJlIGEgZGVzY2VuZGFudCBvZiA8KC4rPyk+XFwuXFxuVGhpcyB3aWxsIGNhdXNlIGEgaHlkcmF0aW9uIGVycm9yXFwuKC4qKS8sXG4gIC9eSW4gSFRNTCwgdGV4dCBub2RlcyBjYW5ub3QgYmUgYSBjaGlsZCBvZiA8KC4rPyk+XFwuXFxuVGhpcyB3aWxsIGNhdXNlIGEgaHlkcmF0aW9uIGVycm9yXFwuLyxcbiAgL15JbiBIVE1MLCB3aGl0ZXNwYWNlIHRleHQgbm9kZXMgY2Fubm90IGJlIGEgY2hpbGQgb2YgPCguKz8pPlxcLiBNYWtlIHN1cmUgeW91IGRvbid0IGhhdmUgYW55IGV4dHJhIHdoaXRlc3BhY2UgYmV0d2VlbiB0YWdzIG9uIGVhY2ggbGluZSBvZiB5b3VyIHNvdXJjZSBjb2RlXFwuXFxuVGhpcyB3aWxsIGNhdXNlIGEgaHlkcmF0aW9uIGVycm9yXFwuLyxcbl1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzSHlkcmF0aW9uRXJyb3IoZXJyb3I6IEVycm9yKTogYm9vbGVhbiB7XG4gIHJldHVybiAoXG4gICAgaXNFcnJvck1lc3NhZ2VXaXRoQ29tcG9uZW50U3RhY2tEaWZmKGVycm9yLm1lc3NhZ2UpIHx8XG4gICAgL0h5ZHJhdGlvbiBmYWlsZWQgYmVjYXVzZSB0aGUgc2VydmVyIHJlbmRlcmVkICh0ZXh0fEhUTUwpIGRpZG4ndCBtYXRjaCB0aGUgY2xpZW50XFwuLy50ZXN0KFxuICAgICAgZXJyb3IubWVzc2FnZVxuICAgICkgfHxcbiAgICAvQSB0cmVlIGh5ZHJhdGVkIGJ1dCBzb21lIGF0dHJpYnV0ZXMgb2YgdGhlIHNlcnZlciByZW5kZXJlZCBIVE1MIGRpZG4ndCBtYXRjaCB0aGUgY2xpZW50IHByb3BlcnRpZXMuLy50ZXN0KFxuICAgICAgZXJyb3IubWVzc2FnZVxuICAgIClcbiAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNFcnJvck1lc3NhZ2VXaXRoQ29tcG9uZW50U3RhY2tEaWZmKG1zZzogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiBlcnJvck1lc3NhZ2VzV2l0aENvbXBvbmVudFN0YWNrRGlmZi5zb21lKChyZWdleCkgPT4gcmVnZXgudGVzdChtc2cpKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SHlkcmF0aW9uRXJyb3JTdGFja0luZm8oZXJyb3I6IEVycm9yKToge1xuICBtZXNzYWdlOiBzdHJpbmcgfCBudWxsXG4gIG5vdGVzOiBzdHJpbmcgfCBudWxsXG4gIGRpZmY6IHN0cmluZyB8IG51bGxcbn0ge1xuICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlXG4gIGlmIChpc0Vycm9yTWVzc2FnZVdpdGhDb21wb25lbnRTdGFja0RpZmYoZXJyb3JNZXNzYWdlKSkge1xuICAgIGNvbnN0IFttZXNzYWdlLCBkaWZmTG9nID0gJyddID0gZXJyb3JNZXNzYWdlLnNwbGl0KCdcXG5cXG4nKVxuICAgIGNvbnN0IGRpZmYgPSBkaWZmTG9nLnRyaW0oKVxuICAgIHJldHVybiB7XG4gICAgICBtZXNzYWdlOiBkaWZmID09PSAnJyA/IGVycm9yTWVzc2FnZS50cmltKCkgOiBtZXNzYWdlLnRyaW0oKSxcbiAgICAgIGRpZmYsXG4gICAgICBub3RlczogbnVsbCxcbiAgICB9XG4gIH1cblxuICBjb25zdCBbbWVzc2FnZSwgbWF5YmVDb21wb25lbnRTdGFja0RpZmZdID0gZXJyb3JNZXNzYWdlLnNwbGl0KFxuICAgIGAke1JFQUNUX0hZRFJBVElPTl9FUlJPUl9MSU5LfWBcbiAgKVxuICBjb25zdCB0cmltbWVkTWVzc2FnZSA9IG1lc3NhZ2UudHJpbSgpXG4gIC8vIFJlYWN0IGJ1aWx0LWluIGh5ZHJhdGlvbiBkaWZmIHN0YXJ0cyB3aXRoIGEgbmV3bGluZVxuICBpZiAoXG4gICAgbWF5YmVDb21wb25lbnRTdGFja0RpZmYgIT09IHVuZGVmaW5lZCAmJlxuICAgIG1heWJlQ29tcG9uZW50U3RhY2tEaWZmLmxlbmd0aCA+IDFcbiAgKSB7XG4gICAgY29uc3QgZGlmZnM6IHN0cmluZ1tdID0gW11cbiAgICBtYXliZUNvbXBvbmVudFN0YWNrRGlmZi5zcGxpdCgnXFxuJykuZm9yRWFjaCgobGluZSkgPT4ge1xuICAgICAgaWYgKGxpbmUudHJpbSgpID09PSAnJykgcmV0dXJuXG4gICAgICBpZiAoIWxpbmUudHJpbSgpLnN0YXJ0c1dpdGgoJ2F0ICcpKSB7XG4gICAgICAgIGRpZmZzLnB1c2gobGluZSlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgY29uc3QgW2Rpc3BsYXllZE1lc3NhZ2UsIC4uLm5vdGVzXSA9IHRyaW1tZWRNZXNzYWdlLnNwbGl0KCdcXG5cXG4nKVxuICAgIHJldHVybiB7XG4gICAgICBtZXNzYWdlOiBkaXNwbGF5ZWRNZXNzYWdlLFxuICAgICAgZGlmZjogZGlmZnMuam9pbignXFxuJyksXG4gICAgICBub3Rlczogbm90ZXMuam9pbignXFxuXFxuJykgfHwgbnVsbCxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgW2Rpc3BsYXllZE1lc3NhZ2UsIC4uLm5vdGVzXSA9IHRyaW1tZWRNZXNzYWdlLnNwbGl0KCdcXG5cXG4nKVxuICAgIHJldHVybiB7XG4gICAgICBtZXNzYWdlOiBkaXNwbGF5ZWRNZXNzYWdlLFxuICAgICAgZGlmZjogbnVsbCxcbiAgICAgIG5vdGVzOiBub3Rlcy5qb2luKCdcXG5cXG4nKSxcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJORVhUSlNfSFlEUkFUSU9OX0VSUk9SX0xJTksiLCJSRUFDVF9IWURSQVRJT05fRVJST1JfTElOSyIsImdldEh5ZHJhdGlvbkVycm9yU3RhY2tJbmZvIiwiaXNFcnJvck1lc3NhZ2VXaXRoQ29tcG9uZW50U3RhY2tEaWZmIiwiaXNIeWRyYXRpb25FcnJvciIsImVycm9yTWVzc2FnZXNXaXRoQ29tcG9uZW50U3RhY2tEaWZmIiwiZXJyb3IiLCJtZXNzYWdlIiwidGVzdCIsIm1zZyIsInNvbWUiLCJyZWdleCIsImVycm9yTWVzc2FnZSIsImRpZmZMb2ciLCJzcGxpdCIsImRpZmYiLCJ0cmltIiwibm90ZXMiLCJtYXliZUNvbXBvbmVudFN0YWNrRGlmZiIsInRyaW1tZWRNZXNzYWdlIiwidW5kZWZpbmVkIiwibGVuZ3RoIiwiZGlmZnMiLCJmb3JFYWNoIiwibGluZSIsInN0YXJ0c1dpdGgiLCJwdXNoIiwiZGlzcGxheWVkTWVzc2FnZSIsImpvaW4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBRWFBLDJCQUEyQixFQUFBO2VBQTNCQTs7SUFGQUMsMEJBQTBCLEVBQUE7ZUFBMUJBOztJQStCR0MsMEJBQTBCLEVBQUE7ZUFBMUJBOztJQUpBQyxvQ0FBb0MsRUFBQTtlQUFwQ0E7O0lBWkFDLGdCQUFnQixFQUFBO2VBQWhCQTs7O0FBZlQsTUFBTUgsNkJBQ1g7QUFDSyxNQUFNRCw4QkFDWDtBQUVGOztDQUVDLEdBQ0QsTUFBTUssc0NBQXNDO0lBQzFDO0lBQ0E7SUFDQTtJQUNBO0NBQ0Q7QUFFTSxTQUFTRCxpQkFBaUJFLEtBQVk7SUFDM0MsT0FDRUgscUNBQXFDRyxNQUFNQyxPQUFPLEtBQ2xELHFGQUFxRkMsSUFBSSxDQUN2RkYsTUFBTUMsT0FBTyxLQUVmLHNHQUFzR0MsSUFBSSxDQUN4R0YsTUFBTUMsT0FBTztBQUduQjtBQUVPLFNBQVNKLHFDQUFxQ00sR0FBVztJQUM5RCxPQUFPSixvQ0FBb0NLLElBQUksQ0FBQyxDQUFDQyxRQUFVQSxNQUFNSCxJQUFJLENBQUNDO0FBQ3hFO0FBRU8sU0FBU1AsMkJBQTJCSSxLQUFZO0lBS3JELE1BQU1NLGVBQWVOLE1BQU1DLE9BQU87SUFDbEMsSUFBSUoscUNBQXFDUyxlQUFlO1FBQ3RELE1BQU0sQ0FBQ0wsU0FBU00sVUFBVSxFQUFFLENBQUMsR0FBR0QsYUFBYUUsS0FBSyxDQUFDO1FBQ25ELE1BQU1DLE9BQU9GLFFBQVFHLElBQUk7UUFDekIsT0FBTztZQUNMVCxTQUFTUSxTQUFTLEtBQUtILGFBQWFJLElBQUksS0FBS1QsUUFBUVMsSUFBSTtZQUN6REQ7WUFDQUUsT0FBTztRQUNUO0lBQ0Y7SUFFQSxNQUFNLENBQUNWLFNBQVNXLHdCQUF3QixHQUFHTixhQUFhRSxLQUFLLENBQzFELEtBQUViO0lBRUwsTUFBTWtCLGlCQUFpQlosUUFBUVMsSUFBSTtJQUNuQyxzREFBc0Q7SUFDdEQsSUFDRUUsNEJBQTRCRSxhQUM1QkYsd0JBQXdCRyxNQUFNLEdBQUcsR0FDakM7UUFDQSxNQUFNQyxRQUFrQixFQUFFO1FBQzFCSix3QkFBd0JKLEtBQUssQ0FBQyxNQUFNUyxPQUFPLENBQUMsQ0FBQ0M7WUFDM0MsSUFBSUEsS0FBS1IsSUFBSSxPQUFPLElBQUk7WUFDeEIsSUFBSSxDQUFDUSxLQUFLUixJQUFJLEdBQUdTLFVBQVUsQ0FBQyxRQUFRO2dCQUNsQ0gsTUFBTUksSUFBSSxDQUFDRjtZQUNiO1FBQ0Y7UUFFQSxNQUFNLENBQUNHLGtCQUFrQixHQUFHVixNQUFNLEdBQUdFLGVBQWVMLEtBQUssQ0FBQztRQUMxRCxPQUFPO1lBQ0xQLFNBQVNvQjtZQUNUWixNQUFNTyxNQUFNTSxJQUFJLENBQUM7WUFDakJYLE9BQU9BLE1BQU1XLElBQUksQ0FBQyxXQUFXO1FBQy9CO0lBQ0YsT0FBTztRQUNMLE1BQU0sQ0FBQ0Qsa0JBQWtCLEdBQUdWLE1BQU0sR0FBR0UsZUFBZUwsS0FBSyxDQUFDO1FBQzFELE9BQU87WUFDTFAsU0FBU29CO1lBQ1RaLE1BQU07WUFDTkUsT0FBT0EsTUFBTVcsSUFBSSxDQUFDO1FBQ3BCO0lBQ0Y7QUFDRiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA4NTQsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvbmV4dC1kZXZ0b29scy91c2Vyc3BhY2UvcGFnZXMvaHlkcmF0aW9uLWVycm9yLXN0YXRlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIGdldEh5ZHJhdGlvbldhcm5pbmdUeXBlLFxuICBpc0h5ZHJhdGlvbkVycm9yIGFzIGlzUmVhY3QxOEh5ZHJhdGlvbkVycm9yLFxuICBpc0h5ZHJhdGlvbldhcm5pbmcgYXMgaXNSZWFjdDE4SHlkcmF0aW9uV2FybmluZyxcbn0gZnJvbSAnLi4vLi4vc2hhcmVkL3JlYWN0LTE4LWh5ZHJhdGlvbi1lcnJvcidcbmltcG9ydCB7XG4gIGlzSHlkcmF0aW9uRXJyb3IgYXMgaXNSZWFjdDE5SHlkcmF0aW9uRXJyb3IsXG4gIGlzRXJyb3JNZXNzYWdlV2l0aENvbXBvbmVudFN0YWNrRGlmZiBhcyBpc1JlYWN0MTlIeWRyYXRpb25XYXJuaW5nLFxufSBmcm9tICcuLi8uLi9zaGFyZWQvcmVhY3QtMTktaHlkcmF0aW9uLWVycm9yJ1xuaW1wb3J0IHR5cGUgeyBIeWRyYXRpb25FcnJvclN0YXRlIH0gZnJvbSAnLi4vLi4vc2hhcmVkL2h5ZHJhdGlvbi1lcnJvcidcblxuLy8gV2Ugb25seSBuZWVkIHRoaXMgZm9yIFJlYWN0IDE4IG9yIGh5ZHJhdGlvbiBjb25zb2xlIGVycm9ycyBpbiBSZWFjdCAxOS5cbi8vIE9uY2Ugd2Ugc3VyZmFjZSBjb25zb2xlLmVycm9yIGluIHRoZSBkZXYgb3ZlcmxheSBpbiBwYWdlcyByb3V0ZXIsIHdlIHNob3VsZCBvbmx5XG4vLyB1c2UgdGhpcyBmb3IgUmVhY3QgMTguXG5sZXQgaHlkcmF0aW9uRXJyb3JTdGF0ZTogSHlkcmF0aW9uRXJyb3JTdGF0ZSA9IHt9XG5cbmNvbnN0IHNxdWFzaGVkSHlkcmF0aW9uRXJyb3JEZXRhaWxzID0gbmV3IFdlYWtNYXA8RXJyb3IsIEh5ZHJhdGlvbkVycm9yU3RhdGU+KClcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNxdWFzaGVkSHlkcmF0aW9uRXJyb3JEZXRhaWxzKFxuICBlcnJvcjogRXJyb3Jcbik6IEh5ZHJhdGlvbkVycm9yU3RhdGUgfCBudWxsIHtcbiAgcmV0dXJuIHNxdWFzaGVkSHlkcmF0aW9uRXJyb3JEZXRhaWxzLmhhcyhlcnJvcilcbiAgICA/IHNxdWFzaGVkSHlkcmF0aW9uRXJyb3JEZXRhaWxzLmdldChlcnJvcikhXG4gICAgOiBudWxsXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhdHRhY2hIeWRyYXRpb25FcnJvclN0YXRlKGVycm9yOiBFcnJvcikge1xuICBpZiAoIWlzUmVhY3QxOEh5ZHJhdGlvbkVycm9yKGVycm9yKSAmJiAhaXNSZWFjdDE5SHlkcmF0aW9uRXJyb3IoZXJyb3IpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBsZXQgcGFyc2VkSHlkcmF0aW9uRXJyb3JTdGF0ZTogdHlwZW9mIGh5ZHJhdGlvbkVycm9yU3RhdGUgPSB7fVxuXG4gIC8vIElmIHRoZXJlJ3MgYW55IGV4dHJhIGluZm9ybWF0aW9uIGluIHRoZSBlcnJvciBtZXNzYWdlIHRvIGRpc3BsYXksXG4gIC8vIGFwcGVuZCBpdCB0byB0aGUgZXJyb3IgbWVzc2FnZSBkZXRhaWxzIHByb3BlcnR5XG4gIGlmIChoeWRyYXRpb25FcnJvclN0YXRlLndhcm5pbmcpIHtcbiAgICAvLyBUaGUgcGF0Y2hlZCBjb25zb2xlLmVycm9yIGZvdW5kIGh5ZHJhdGlvbiBlcnJvcnMgbG9nZ2VkIGJ5IFJlYWN0XG4gICAgLy8gQXBwZW5kIHRoZSBsb2dnZWQgd2FybmluZyB0byB0aGUgZXJyb3IgbWVzc2FnZVxuICAgIHBhcnNlZEh5ZHJhdGlvbkVycm9yU3RhdGUgPSB7XG4gICAgICAvLyBJdCBjb250YWlucyB0aGUgd2FybmluZywgY29tcG9uZW50IHN0YWNrLCBzZXJ2ZXIgYW5kIGNsaWVudCB0YWcgbmFtZXNcbiAgICAgIC4uLmh5ZHJhdGlvbkVycm9yU3RhdGUsXG4gICAgfVxuXG4gICAgLy8gQ29uc3VtZSB0aGUgY2FjaGVkIGh5ZHJhdGlvbiBkaWZmLlxuICAgIC8vIFRoaXMgaXMgb25seSByZXF1aXJlZCBmb3Igbm93IHdoZW4gd2Ugc3RpbGwgc3F1YXNoZWQgdGhlIGh5ZHJhdGlvbiBkaWZmIGxvZyBpbnRvIGh5ZHJhdGlvbiBlcnJvci5cbiAgICAvLyBPbmNlIHRoZSBhbGwgZXJyb3IgaXMgbG9nZ2VkIHRvIGRldiBvdmVybGF5IGluIG9yZGVyLCB0aGlzIHdpbGwgZ28gYXdheS5cbiAgICBpZiAoaHlkcmF0aW9uRXJyb3JTdGF0ZS5yZWFjdE91dHB1dENvbXBvbmVudERpZmYpIHtcbiAgICAgIHBhcnNlZEh5ZHJhdGlvbkVycm9yU3RhdGUucmVhY3RPdXRwdXRDb21wb25lbnREaWZmID1cbiAgICAgICAgaHlkcmF0aW9uRXJyb3JTdGF0ZS5yZWFjdE91dHB1dENvbXBvbmVudERpZmZcbiAgICB9XG5cbiAgICBzcXVhc2hlZEh5ZHJhdGlvbkVycm9yRGV0YWlscy5zZXQoZXJyb3IsIHBhcnNlZEh5ZHJhdGlvbkVycm9yU3RhdGUpXG4gIH1cbn1cblxuLy8gVE9ETzogT25seSBoYW5kbGUgUmVhY3QgMTguIE9uY2Ugd2Ugc3VyZmFjZSBjb25zb2xlLmVycm9yIGluIHRoZSBkZXYgb3ZlcmxheSBpbiBwYWdlcyByb3V0ZXIsXG4vLyB3ZSBjYW4gdXNlIHRoZSBzYW1lIGJlaGF2aW9yIGFzIEFwcCBSb3V0ZXIuXG5leHBvcnQgZnVuY3Rpb24gc3RvcmVIeWRyYXRpb25FcnJvclN0YXRlRnJvbUNvbnNvbGVBcmdzKC4uLmFyZ3M6IGFueVtdKSB7XG4gIGxldCBbbWVzc2FnZSwgZmlyc3RDb250ZW50LCBzZWNvbmRDb250ZW50LCAuLi5yZXN0XSA9IGFyZ3NcbiAgaWYgKGlzUmVhY3QxOEh5ZHJhdGlvbldhcm5pbmcobWVzc2FnZSkpIHtcbiAgICAvLyBTb21lIGh5ZHJhdGlvbiB3YXJuaW5ncyBoYXMgNCBhcmd1bWVudHMsIHNvbWUgaGFzIDMsIGZhbGxiYWNrIHRvIHRoZSBsYXN0IGFyZ3VtZW50XG4gICAgLy8gd2hlbiB0aGUgM3JkIGFyZ3VtZW50IGlzIG5vdCB0aGUgY29tcG9uZW50IHN0YWNrIGJ1dCBhbiBlbXB0eSBzdHJpbmdcbiAgICAvLyBGb3Igc29tZSB3YXJuaW5ncywgdGhlcmUncyBvbmx5IDEgYXJndW1lbnQgZm9yIHRlbXBsYXRlLlxuICAgIC8vIFRoZSBzZWNvbmQgYXJndW1lbnQgaXMgdGhlIGRpZmYgb3IgY29tcG9uZW50IHN0YWNrLlxuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMykge1xuICAgICAgc2Vjb25kQ29udGVudCA9ICcnXG4gICAgfVxuXG4gICAgY29uc3Qgd2FybmluZyA9IG1lc3NhZ2VcbiAgICAgIC5yZXBsYWNlKC9XYXJuaW5nOiAvLCAnJylcbiAgICAgIC5yZXBsYWNlKCclcycsIGZpcnN0Q29udGVudClcbiAgICAgIC5yZXBsYWNlKCclcycsIHNlY29uZENvbnRlbnQpXG4gICAgICAvLyByZW1vdmUgdGhlIGxhc3QgJXMgZnJvbSB0aGUgbWVzc2FnZVxuICAgICAgLnJlcGxhY2UoLyVzL2csICcnKVxuXG4gICAgY29uc3QgbGFzdEFyZyA9IChyZXN0W3Jlc3QubGVuZ3RoIC0gMV0gfHwgJycpLnRyaW0oKVxuXG4gICAgaHlkcmF0aW9uRXJyb3JTdGF0ZS5yZWFjdE91dHB1dENvbXBvbmVudERpZmYgPSBnZW5lcmF0ZUh5ZHJhdGlvbkRpZmZSZWFjdDE4KFxuICAgICAgbWVzc2FnZSxcbiAgICAgIGZpcnN0Q29udGVudCxcbiAgICAgIHNlY29uZENvbnRlbnQsXG4gICAgICBsYXN0QXJnXG4gICAgKVxuXG4gICAgaHlkcmF0aW9uRXJyb3JTdGF0ZS53YXJuaW5nID0gd2FybmluZ1xuICB9IGVsc2UgaWYgKGlzUmVhY3QxOUh5ZHJhdGlvbldhcm5pbmcobWVzc2FnZSkpIHtcbiAgICAvLyBTb21lIGh5ZHJhdGlvbiB3YXJuaW5ncyBoYXMgNCBhcmd1bWVudHMsIHNvbWUgaGFzIDMsIGZhbGxiYWNrIHRvIHRoZSBsYXN0IGFyZ3VtZW50XG4gICAgLy8gd2hlbiB0aGUgM3JkIGFyZ3VtZW50IGlzIG5vdCB0aGUgY29tcG9uZW50IHN0YWNrIGJ1dCBhbiBlbXB0eSBzdHJpbmdcbiAgICAvLyBGb3Igc29tZSB3YXJuaW5ncywgdGhlcmUncyBvbmx5IDEgYXJndW1lbnQgZm9yIHRlbXBsYXRlLlxuICAgIC8vIFRoZSBzZWNvbmQgYXJndW1lbnQgaXMgdGhlIGRpZmYgb3IgY29tcG9uZW50IHN0YWNrLlxuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMykge1xuICAgICAgc2Vjb25kQ29udGVudCA9ICcnXG4gICAgfVxuXG4gICAgY29uc3Qgd2FybmluZyA9IG1lc3NhZ2VcbiAgICAgIC5yZXBsYWNlKCclcycsIGZpcnN0Q29udGVudClcbiAgICAgIC5yZXBsYWNlKCclcycsIHNlY29uZENvbnRlbnQpXG4gICAgICAvLyByZW1vdmUgdGhlIGxhc3QgJXMgZnJvbSB0aGUgbWVzc2FnZVxuICAgICAgLnJlcGxhY2UoLyVzL2csICcnKVxuXG4gICAgY29uc3QgbGFzdEFyZyA9IChhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gfHwgJycpLnRyaW0oKVxuXG4gICAgaHlkcmF0aW9uRXJyb3JTdGF0ZS5yZWFjdE91dHB1dENvbXBvbmVudERpZmYgPSBsYXN0QXJnXG4gICAgaHlkcmF0aW9uRXJyb3JTdGF0ZS53YXJuaW5nID0gd2FybmluZ1xuICB9XG59XG5cbi8qXG4gKiBTb21lIGh5ZHJhdGlvbiBlcnJvcnMgaW4gUmVhY3QgMTggZG9lcyBub3QgaGF2ZSB0aGUgZGlmZiBpbiB0aGUgZXJyb3IgbWVzc2FnZS5cbiAqIEluc3RlYWQgaXQgaGFzIHRoZSBlcnJvciBzdGFjayB0cmFjZSB3aGljaCBpcyBjb21wb25lbnQgc3RhY2sgdGhhdCB3ZSBjYW4gbGV2ZXJhZ2UuXG4gKiBXaWxsIHBhcnNlIHRoZSBkaWZmIGZyb20gdGhlIGVycm9yIHN0YWNrIHRyYWNlXG4gKiAgZS5nLlxuICogIFdhcm5pbmc6IEV4cGVjdGVkIHNlcnZlciBIVE1MIHRvIGNvbnRhaW4gYSBtYXRjaGluZyA8ZGl2PiBpbiA8cD4uXG4gKiAgICBhdCBkaXZcbiAqICAgIGF0IHBcbiAqICAgIGF0IGRpdlxuICogICAgYXQgZGl2XG4gKiAgICBhdCBQYWdlXG4gKiAgb3V0cHV0OlxuICogICAgPFBhZ2U+XG4gKiAgICAgIDxkaXY+XG4gKiAgICAgICAgPHA+XG4gKiAgPiAgICAgICA8ZGl2PlxuICpcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVIeWRyYXRpb25EaWZmUmVhY3QxOChcbiAgbWVzc2FnZTogc3RyaW5nLFxuICBmaXJzdENvbnRlbnQ6IHN0cmluZyxcbiAgc2Vjb25kQ29udGVudDogc3RyaW5nLFxuICBsYXN0QXJnOiBzdHJpbmdcbikge1xuICBjb25zdCBjb21wb25lbnRTdGFjayA9IGxhc3RBcmdcbiAgbGV0IGZpcnN0SW5kZXggPSAtMVxuICBsZXQgc2Vjb25kSW5kZXggPSAtMVxuICBjb25zdCBoeWRyYXRpb25XYXJuaW5nVHlwZSA9IGdldEh5ZHJhdGlvbldhcm5pbmdUeXBlKG1lc3NhZ2UpXG5cbiAgLy8gYXQgZGl2XFxuIGF0IEZvb1xcbiBhdCBCYXIgKC4uLi4pXFxuIC0+IFtkaXYsIEZvb11cbiAgY29uc3QgY29tcG9uZW50cyA9IGNvbXBvbmVudFN0YWNrXG4gICAgLnNwbGl0KCdcXG4nKVxuICAgIC8vIC5yZXZlcnNlKClcbiAgICAubWFwKChsaW5lOiBzdHJpbmcsIGluZGV4OiBudW1iZXIpID0+IHtcbiAgICAgIC8vIGA8c3BhY2U+YXQgPGNvbXBvbmVudD4gKDxsb2NhdGlvbj4pYCAtPiBgYXQgPGNvbXBvbmVudD4gKDxsb2NhdGlvbj4pYFxuICAgICAgbGluZSA9IGxpbmUudHJpbSgpXG4gICAgICAvLyBleHRyYWN0IGA8c3BhY2U+YXQgPGNvbXBvbmVudD5gIHRvIGA8PGNvbXBvbmVudD4+YFxuICAgICAgLy8gZS5nLiBgICBhdCBGb29gIC0+IGA8Rm9vPmBcbiAgICAgIGNvbnN0IFssIGNvbXBvbmVudCwgbG9jYXRpb25dID0gL2F0IChcXHcrKSggXFwoKC4qKVxcKSk/Ly5leGVjKGxpbmUpIHx8IFtdXG4gICAgICAvLyBJZiB0aGVyZSdzIG5vIGxvY2F0aW9uIHRoZW4gaXQncyB1c2VyLWxhbmQgc3RhY2sgZnJhbWVcbiAgICAgIGlmICghbG9jYXRpb24pIHtcbiAgICAgICAgaWYgKGNvbXBvbmVudCA9PT0gZmlyc3RDb250ZW50ICYmIGZpcnN0SW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgZmlyc3RJbmRleCA9IGluZGV4XG4gICAgICAgIH0gZWxzZSBpZiAoY29tcG9uZW50ID09PSBzZWNvbmRDb250ZW50ICYmIHNlY29uZEluZGV4ID09PSAtMSkge1xuICAgICAgICAgIHNlY29uZEluZGV4ID0gaW5kZXhcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGxvY2F0aW9uID8gJycgOiBjb21wb25lbnRcbiAgICB9KVxuICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAucmV2ZXJzZSgpXG5cbiAgbGV0IGRpZmYgPSAnJ1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbXBvbmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjb21wb25lbnQgPSBjb21wb25lbnRzW2ldXG4gICAgY29uc3QgbWF0Y2hGaXJzdENvbnRlbnQgPVxuICAgICAgaHlkcmF0aW9uV2FybmluZ1R5cGUgPT09ICd0YWcnICYmIGkgPT09IGNvbXBvbmVudHMubGVuZ3RoIC0gZmlyc3RJbmRleCAtIDFcbiAgICBjb25zdCBtYXRjaFNlY29uZENvbnRlbnQgPVxuICAgICAgaHlkcmF0aW9uV2FybmluZ1R5cGUgPT09ICd0YWcnICYmXG4gICAgICBpID09PSBjb21wb25lbnRzLmxlbmd0aCAtIHNlY29uZEluZGV4IC0gMVxuICAgIGlmIChtYXRjaEZpcnN0Q29udGVudCB8fCBtYXRjaFNlY29uZENvbnRlbnQpIHtcbiAgICAgIGNvbnN0IHNwYWNlcyA9ICcgJy5yZXBlYXQoTWF0aC5tYXgoaSAqIDIgLSAyLCAwKSArIDIpXG4gICAgICBkaWZmICs9IGA+ICR7c3BhY2VzfTwke2NvbXBvbmVudH0+XFxuYFxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzcGFjZXMgPSAnICcucmVwZWF0KGkgKiAyICsgMilcbiAgICAgIGRpZmYgKz0gYCR7c3BhY2VzfTwke2NvbXBvbmVudH0+XFxuYFxuICAgIH1cbiAgfVxuICBpZiAoaHlkcmF0aW9uV2FybmluZ1R5cGUgPT09ICd0ZXh0Jykge1xuICAgIGNvbnN0IHNwYWNlcyA9ICcgJy5yZXBlYXQoY29tcG9uZW50cy5sZW5ndGggKiAyKVxuICAgIGRpZmYgKz0gYCsgJHtzcGFjZXN9XCIke2ZpcnN0Q29udGVudH1cIlxcbmBcbiAgICBkaWZmICs9IGAtICR7c3BhY2VzfVwiJHtzZWNvbmRDb250ZW50fVwiXFxuYFxuICB9IGVsc2UgaWYgKGh5ZHJhdGlvbldhcm5pbmdUeXBlID09PSAndGV4dC1pbi10YWcnKSB7XG4gICAgY29uc3Qgc3BhY2VzID0gJyAnLnJlcGVhdChjb21wb25lbnRzLmxlbmd0aCAqIDIpXG4gICAgZGlmZiArPSBgPiAke3NwYWNlc308JHtzZWNvbmRDb250ZW50fT5cXG5gXG4gICAgZGlmZiArPSBgPiAgICR7c3BhY2VzfVwiJHtmaXJzdENvbnRlbnR9XCJcXG5gXG4gIH1cbiAgcmV0dXJuIGRpZmZcbn1cbiJdLCJuYW1lcyI6WyJhdHRhY2hIeWRyYXRpb25FcnJvclN0YXRlIiwiZ2V0U3F1YXNoZWRIeWRyYXRpb25FcnJvckRldGFpbHMiLCJzdG9yZUh5ZHJhdGlvbkVycm9yU3RhdGVGcm9tQ29uc29sZUFyZ3MiLCJoeWRyYXRpb25FcnJvclN0YXRlIiwic3F1YXNoZWRIeWRyYXRpb25FcnJvckRldGFpbHMiLCJXZWFrTWFwIiwiZXJyb3IiLCJoYXMiLCJnZXQiLCJpc1JlYWN0MThIeWRyYXRpb25FcnJvciIsImlzUmVhY3QxOUh5ZHJhdGlvbkVycm9yIiwicGFyc2VkSHlkcmF0aW9uRXJyb3JTdGF0ZSIsIndhcm5pbmciLCJyZWFjdE91dHB1dENvbXBvbmVudERpZmYiLCJzZXQiLCJhcmdzIiwibWVzc2FnZSIsImZpcnN0Q29udGVudCIsInNlY29uZENvbnRlbnQiLCJyZXN0IiwiaXNSZWFjdDE4SHlkcmF0aW9uV2FybmluZyIsImxlbmd0aCIsInJlcGxhY2UiLCJsYXN0QXJnIiwidHJpbSIsImdlbmVyYXRlSHlkcmF0aW9uRGlmZlJlYWN0MTgiLCJpc1JlYWN0MTlIeWRyYXRpb25XYXJuaW5nIiwiY29tcG9uZW50U3RhY2siLCJmaXJzdEluZGV4Iiwic2Vjb25kSW5kZXgiLCJoeWRyYXRpb25XYXJuaW5nVHlwZSIsImdldEh5ZHJhdGlvbldhcm5pbmdUeXBlIiwiY29tcG9uZW50cyIsInNwbGl0IiwibWFwIiwibGluZSIsImluZGV4IiwiY29tcG9uZW50IiwibG9jYXRpb24iLCJleGVjIiwiZmlsdGVyIiwiQm9vbGVhbiIsInJldmVyc2UiLCJkaWZmIiwiaSIsIm1hdGNoRmlyc3RDb250ZW50IiwibWF0Y2hTZWNvbmRDb250ZW50Iiwic3BhY2VzIiwicmVwZWF0IiwiTWF0aCIsIm1heCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0lBMEJnQkEseUJBQXlCLEVBQUE7ZUFBekJBOztJQVJBQyxnQ0FBZ0MsRUFBQTtlQUFoQ0E7O0lBdUNBQyx1Q0FBdUMsRUFBQTtlQUF2Q0E7Ozt1Q0FyRFQ7dUNBSUE7QUFHUCwwRUFBMEU7QUFDMUUsbUZBQW1GO0FBQ25GLHlCQUF5QjtBQUN6QixJQUFJQyxzQkFBMkMsQ0FBQztBQUVoRCxNQUFNQyxnQ0FBZ0MsSUFBSUM7QUFFbkMsU0FBU0osaUNBQ2RLLEtBQVk7SUFFWixPQUFPRiw4QkFBOEJHLEdBQUcsQ0FBQ0QsU0FDckNGLDhCQUE4QkksR0FBRyxDQUFDRixTQUNsQztBQUNOO0FBRU8sU0FBU04sMEJBQTBCTSxLQUFZO0lBQ3BELElBQUksQ0FBQ0csQ0FBQUEsR0FBQUEsdUJBQUFBLGdCQUF1QixFQUFDSCxVQUFVLENBQUNJLENBQUFBLEdBQUFBLHVCQUFBQSxnQkFBdUIsRUFBQ0osUUFBUTtRQUN0RTtJQUNGO0lBRUEsSUFBSUssNEJBQXdELENBQUM7SUFFN0Qsb0VBQW9FO0lBQ3BFLGtEQUFrRDtJQUNsRCxJQUFJUixvQkFBb0JTLE9BQU8sRUFBRTtRQUMvQixtRUFBbUU7UUFDbkUsaURBQWlEO1FBQ2pERCw0QkFBNEI7WUFDMUIsd0VBQXdFO1lBQ3hFLEdBQUdS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LE1BQU0sQ0FBQ0MsU0FDUEMsT0FBTztJQUVWLElBQUlDLE9BQU87SUFDWCxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSVosV0FBV1gsTUFBTSxFQUFFdUIsSUFBSztRQUMxQyxNQUFNUCxZQUFZTCxVQUFVLENBQUNZLEVBQUU7UUFDL0IsTUFBTUMsb0JBQ0pmLHlCQUF5QixTQUFTYyxNQUFNWixXQUFXWCxNQUFNLEdBQUdPLGFBQWE7UUFDM0UsTUFBTWtCLHFCQUNKaEIseUJBQXlCLFNBQ3pCYyxNQUFNWixXQUFXWCxNQUFNLEdBQUdRLGNBQWM7UUFDMUMsSUFBSWdCLHFCQUFxQkMsb0JBQW9CO1lBQzNDLE1BQU1DLFNBQVMsSUFBSUMsTUFBTSxDQUFDQyxLQUFLQyxHQUFHLENBQUNOLElBQUksSUFBSSxHQUFHLEtBQUs7WUFDbkRELFFBQVMsT0FBSUksU0FBTyxNQUFHVixZQUFVO1FBQ25DLE9BQU87WUFDTCxNQUFNVSxTQUFTLElBQUlDLE1BQU0sQ0FBQ0osSUFBSSxJQUFJO1lBQ2xDRCxRQUFXSSxTQUFPLE1BQUdWLFlBQVU7UUFDakM7SUFDRjtJQUNBLElBQUlQLHlCQUF5QixRQUFRO1FBQ25DLE1BQU1pQixTQUFTLElBQUlDLE1BQU0sQ0FBQ2hCLFdBQVdYLE1BQU0sR0FBRztRQUM5Q3NCLFFBQVMsT0FBSUksU0FBTyxNQUFHOUIsZUFBYTtRQUNwQzBCLFFBQVMsT0FBSUksU0FBTyxNQUFHN0IsZ0JBQWM7SUFDdkMsT0FBTyxJQUFJWSx5QkFBeUIsZUFBZTtRQUNqRCxNQUFNaUIsU0FBUyxJQUFJQyxNQUFNLENBQUNoQixXQUFXWCxNQUFNLEdBQUc7UUFDOUNzQixRQUFTLE9BQUlJLFNBQU8sTUFBRzdCLGdCQUFjO1FBQ3JDeUIsUUFBUyxTQUFNSSxTQUFPLE1BQUc5QixlQUFhO0lBQ3hDO0lBQ0EsT0FBTzBCO0FBQ1QiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTAyMiwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9uZXh0LWRldnRvb2xzL3VzZXJzcGFjZS9wYWdlcy9wYWdlcy1kZXYtb3ZlcmxheS1lcnJvci1ib3VuZGFyeS50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuXG50eXBlIFBhZ2VzRGV2T3ZlcmxheUVycm9yQm91bmRhcnlQcm9wcyA9IHtcbiAgY2hpbGRyZW4/OiBSZWFjdC5SZWFjdE5vZGVcbn1cbnR5cGUgUGFnZXNEZXZPdmVybGF5RXJyb3JCb3VuZGFyeVN0YXRlID0geyBlcnJvcjogRXJyb3IgfCBudWxsIH1cblxuZXhwb3J0IGNsYXNzIFBhZ2VzRGV2T3ZlcmxheUVycm9yQm91bmRhcnkgZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50PFxuICBQYWdlc0Rldk92ZXJsYXlFcnJvckJvdW5kYXJ5UHJvcHMsXG4gIFBhZ2VzRGV2T3ZlcmxheUVycm9yQm91bmRhcnlTdGF0ZVxuPiB7XG4gIHN0YXRlID0geyBlcnJvcjogbnVsbCB9XG5cbiAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihlcnJvcjogRXJyb3IpIHtcbiAgICByZXR1cm4geyBlcnJvciB9XG4gIH1cblxuICAvLyBFeHBsaWNpdCB0eXBlIGlzIG5lZWRlZCB0byBhdm9pZCB0aGUgZ2VuZXJhdGVkIGAuZC50c2AgaGF2aW5nIGEgd2lkZSByZXR1cm4gdHlwZSB0aGF0IGNvdWxkIGJlIHNwZWNpZmljIHRvIHRoZSBgQHR5cGVzL3JlYWN0YCB2ZXJzaW9uLlxuICByZW5kZXIoKTogUmVhY3QuUmVhY3ROb2RlIHtcbiAgICAvLyBUaGUgY29tcG9uZW50IGhhcyB0byBiZSB1bm1vdW50ZWQgb3IgZWxzZSBpdCB3b3VsZCBjb250aW51ZSB0byBlcnJvclxuICAgIHJldHVybiB0aGlzLnN0YXRlLmVycm9yID8gbnVsbCA6IHRoaXMucHJvcHMuY2hpbGRyZW5cbiAgfVxufVxuIl0sIm5hbWVzIjpbIlBhZ2VzRGV2T3ZlcmxheUVycm9yQm91bmRhcnkiLCJSZWFjdCIsIlB1cmVDb21wb25lbnQiLCJnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IiLCJlcnJvciIsInJlbmRlciIsInN0YXRlIiwicHJvcHMiLCJjaGlsZHJlbiJdLCJtYXBwaW5ncyI6Ijs7OytCQU9hQSxnQ0FBQUE7OztlQUFBQTs7OztnRUFQSztBQU9YLE1BQU1BLHFDQUFxQ0MsT0FBQUEsT0FBSyxDQUFDQyxhQUFhO0lBTW5FLE9BQU9DLHlCQUF5QkMsS0FBWSxFQUFFO1FBQzVDLE9BQU87WUFBRUE7UUFBTTtJQUNqQjtJQUVBLHlJQUF5STtJQUN6SUMsU0FBMEI7UUFDeEIsdUVBQXVFO1FBQ3ZFLE9BQU8sSUFBSSxDQUFDQyxLQUFLLENBQUNGLEtBQUssR0FBRyxPQUFPLElBQUksQ0FBQ0csS0FBSyxDQUFDQyxRQUFRO0lBQ3REOztRQWRLLEtBQUEsSUFBQSxPQUFBLElBQUEsQ0FJTEYsS0FBQUEsR0FBUTtZQUFFRixPQUFPO1FBQUs7O0FBV3hCIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDEwNjMsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvbmV4dC1kZXZ0b29scy91c2Vyc3BhY2UvYXBwL3Rlcm1pbmFsLWxvZ2dpbmctY29uZmlnLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBnZXRUZXJtaW5hbExvZ2dpbmdDb25maWcoKTpcbiAgfCBmYWxzZVxuICB8IGJvb2xlYW5cbiAgfCB7XG4gICAgICBkZXB0aExpbWl0PzogbnVtYmVyXG4gICAgICBlZGdlTGltaXQ/OiBudW1iZXJcbiAgICAgIHNob3dTb3VyY2VMb2NhdGlvbj86IGJvb2xlYW5cbiAgICB9IHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShcbiAgICAgIHByb2Nlc3MuZW52Ll9fTkVYVF9CUk9XU0VSX0RFQlVHX0lORk9fSU5fVEVSTUlOQUwgfHwgJ2ZhbHNlJ1xuICAgIClcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldElzVGVybWluYWxMb2dnaW5nRW5hYmxlZCgpOiBib29sZWFuIHtcbiAgY29uc3QgY29uZmlnID0gZ2V0VGVybWluYWxMb2dnaW5nQ29uZmlnKClcbiAgcmV0dXJuIEJvb2xlYW4oY29uZmlnKVxufVxuIl0sIm5hbWVzIjpbImdldElzVGVybWluYWxMb2dnaW5nRW5hYmxlZCIsImdldFRlcm1pbmFsTG9nZ2luZ0NvbmZpZyIsIkpTT04iLCJwYXJzZSIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfQlJPV1NFUl9ERUJVR19JTkZPX0lOX1RFUk1JTkFMIiwiY29uZmlnIiwiQm9vbGVhbiJdLCJtYXBwaW5ncyI6IkFBVU1JLFFBQVFDLEdBQUcsQ0FBQ0MscUNBQXFDOzs7Ozs7Ozs7Ozs7Ozs7O0lBT3ZDTiwyQkFBMkIsRUFBQTtlQUEzQkE7O0lBakJBQyx3QkFBd0IsRUFBQTtlQUF4QkE7OztBQUFULFNBQVNBO0lBUWQsSUFBSTtRQUNGLE9BQU9DLEtBQUtDLEtBQUssOENBQ3NDO0lBRXpELEVBQUUsT0FBQSxHQUFNO1FBQ04sT0FBTztJQUNUO0FBQ0Y7QUFFTyxTQUFTSDtJQUNkLE1BQU1PLFNBQVNOO0lBQ2YsT0FBT08sUUFBUUQ7QUFDakIiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTExMCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9uZXh0LWRldnRvb2xzL3NoYXJlZC9mb3J3YXJkLWxvZ3Mtc2hhcmVkLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB0eXBlIExvZ01ldGhvZCA9XG4gIHwgJ2xvZydcbiAgfCAnaW5mbydcbiAgfCAnZGVidWcnXG4gIHwgJ3RhYmxlJ1xuICB8ICdlcnJvcidcbiAgfCAnYXNzZXJ0J1xuICB8ICdkaXInXG4gIHwgJ2RpcnhtbCdcbiAgfCAnZ3JvdXAnXG4gIHwgJ2dyb3VwQ29sbGFwc2VkJ1xuICB8ICdncm91cEVuZCdcbiAgfCAndHJhY2UnXG4gIHwgJ3dhcm4nXG5cbmV4cG9ydCB0eXBlIENvbnNvbGVFbnRyeTxUPiA9IHtcbiAga2luZDogJ2NvbnNvbGUnXG4gIG1ldGhvZDogTG9nTWV0aG9kXG4gIGNvbnNvbGVNZXRob2RTdGFjazogc3RyaW5nIHwgbnVsbFxuICBhcmdzOiBBcnJheTxcbiAgICB8IHtcbiAgICAgICAga2luZDogJ2FyZydcbiAgICAgICAgZGF0YTogVFxuICAgICAgfVxuICAgIHwge1xuICAgICAgICBraW5kOiAnZm9ybWF0dGVkLWVycm9yLWFyZydcbiAgICAgICAgcHJlZml4OiBzdHJpbmdcbiAgICAgICAgc3RhY2s6IHN0cmluZ1xuICAgICAgfVxuICA+XG59XG5cbmV4cG9ydCB0eXBlIENvbnNvbGVFcnJvckVudHJ5PFQ+ID0ge1xuICBraW5kOiAnYW55LWxvZ2dlZC1lcnJvcidcbiAgbWV0aG9kOiAnZXJyb3InXG4gIGNvbnNvbGVFcnJvclN0YWNrOiBzdHJpbmdcbiAgYXJnczogQXJyYXk8XG4gICAgfCB7XG4gICAgICAgIGtpbmQ6ICdhcmcnXG4gICAgICAgIGRhdGE6IFRcbiAgICAgICAgaXNSZWplY3Rpb25NZXNzYWdlPzogYm9vbGVhblxuICAgICAgfVxuICAgIHwge1xuICAgICAgICBraW5kOiAnZm9ybWF0dGVkLWVycm9yLWFyZydcbiAgICAgICAgcHJlZml4OiBzdHJpbmdcbiAgICAgICAgc3RhY2s6IHN0cmluZyB8IG51bGxcbiAgICAgIH1cbiAgPlxufVxuXG5leHBvcnQgdHlwZSBGb3JtYXR0ZWRFcnJvckVudHJ5ID0ge1xuICBraW5kOiAnZm9ybWF0dGVkLWVycm9yJ1xuICBwcmVmaXg6IHN0cmluZ1xuICBzdGFjazogc3RyaW5nXG4gIG1ldGhvZDogJ2Vycm9yJ1xufVxuXG5leHBvcnQgdHlwZSBDbGllbnRMb2dFbnRyeSA9XG4gIHwgQ29uc29sZUVudHJ5PHVua25vd24+XG4gIHwgQ29uc29sZUVycm9yRW50cnk8dW5rbm93bj5cbiAgfCBGb3JtYXR0ZWRFcnJvckVudHJ5XG5leHBvcnQgdHlwZSBTZXJ2ZXJMb2dFbnRyeSA9XG4gIHwgQ29uc29sZUVudHJ5PHN0cmluZz5cbiAgfCBDb25zb2xlRXJyb3JFbnRyeTxzdHJpbmc+XG4gIHwgRm9ybWF0dGVkRXJyb3JFbnRyeVxuXG5leHBvcnQgY29uc3QgVU5ERUZJTkVEX01BUktFUiA9ICdfX25leHRfdGFnZ2VkX3VuZGVmaW5lZCdcblxuLy8gQmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvMjhkYzA3NzZiZTJlMTM3MGZlMjE3NTQ5ZDMyYWVlMjUxOWYwY2YwNS9wYWNrYWdlcy9yZWFjdC1zZXJ2ZXIvc3JjL1JlYWN0RmxpZ2h0U2VydmVyLmpzI0wyNDhcbmV4cG9ydCBmdW5jdGlvbiBwYXRjaENvbnNvbGVNZXRob2Q8VCBleHRlbmRzIGtleW9mIENvbnNvbGU+KFxuICBtZXRob2ROYW1lOiBULFxuICB3cmFwcGVyOiAoXG4gICAgbWV0aG9kTmFtZTogVCxcbiAgICAuLi5hcmdzOiBDb25zb2xlW1RdIGV4dGVuZHMgKC4uLmFyZ3M6IGluZmVyIFApID0+IGFueSA/IFAgOiBuZXZlcltdXG4gICkgPT4gdm9pZFxuKTogKCkgPT4gdm9pZCB7XG4gIGNvbnN0IGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbnNvbGUsIG1ldGhvZE5hbWUpXG4gIGlmIChcbiAgICBkZXNjcmlwdG9yICYmXG4gICAgKGRlc2NyaXB0b3IuY29uZmlndXJhYmxlIHx8IGRlc2NyaXB0b3Iud3JpdGFibGUpICYmXG4gICAgdHlwZW9mIGRlc2NyaXB0b3IudmFsdWUgPT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgY29uc3Qgb3JpZ2luYWxNZXRob2QgPSBkZXNjcmlwdG9yLnZhbHVlIGFzIENvbnNvbGVbVF0gZXh0ZW5kcyAoXG4gICAgICAuLi5hcmdzOiBhbnlbXVxuICAgICkgPT4gYW55XG4gICAgICA/IENvbnNvbGVbVF1cbiAgICAgIDogbmV2ZXJcbiAgICBjb25zdCBvcmlnaW5hbE5hbWUgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9yaWdpbmFsTWV0aG9kLCAnbmFtZScpXG4gICAgY29uc3Qgd3JhcHBlck1ldGhvZCA9IGZ1bmN0aW9uIChcbiAgICAgIHRoaXM6IHR5cGVvZiBjb25zb2xlLFxuICAgICAgLi4uYXJnczogQ29uc29sZVtUXSBleHRlbmRzICguLi5hcmdzOiBpbmZlciBQKSA9PiBhbnkgPyBQIDogbmV2ZXJbXVxuICAgICkge1xuICAgICAgd3JhcHBlcihtZXRob2ROYW1lLCAuLi5hcmdzKVxuXG4gICAgICBvcmlnaW5hbE1ldGhvZC5hcHBseSh0aGlzLCBhcmdzKVxuICAgIH1cbiAgICBpZiAob3JpZ2luYWxOYW1lKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod3JhcHBlck1ldGhvZCwgJ25hbWUnLCBvcmlnaW5hbE5hbWUpXG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb25zb2xlLCBtZXRob2ROYW1lLCB7XG4gICAgICB2YWx1ZTogd3JhcHBlck1ldGhvZCxcbiAgICB9KVxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb25zb2xlLCBtZXRob2ROYW1lLCB7XG4gICAgICAgIHZhbHVlOiBvcmlnaW5hbE1ldGhvZCxcbiAgICAgICAgd3JpdGFibGU6IGRlc2NyaXB0b3Iud3JpdGFibGUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZGVzY3JpcHRvci5jb25maWd1cmFibGUsXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAoKSA9PiB7fVxufVxuIl0sIm5hbWVzIjpbIlVOREVGSU5FRF9NQVJLRVIiLCJwYXRjaENvbnNvbGVNZXRob2QiLCJtZXRob2ROYW1lIiwid3JhcHBlciIsImRlc2NyaXB0b3IiLCJPYmplY3QiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJjb25zb2xlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJ2YWx1ZSIsIm9yaWdpbmFsTWV0aG9kIiwib3JpZ2luYWxOYW1lIiwid3JhcHBlck1ldGhvZCIsImFyZ3MiLCJhcHBseSIsImRlZmluZVByb3BlcnR5Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztJQWtFYUEsZ0JBQWdCLEVBQUE7ZUFBaEJBOztJQUdHQyxrQkFBa0IsRUFBQTtlQUFsQkE7OztBQUhULE1BQU1ELG1CQUFtQjtBQUd6QixTQUFTQyxtQkFDZEMsVUFBYSxFQUNiQyxPQUdTO0lBRVQsTUFBTUMsYUFBYUMsT0FBT0Msd0JBQXdCLENBQUNDLFNBQVNMO0lBQzVELElBQ0VFLGNBQ0NBLENBQUFBLFdBQVdJLFlBQVksSUFBSUosV0FBV0ssUUFBTyxLQUM5QyxPQUFPTCxXQUFXTSxLQUFLLEtBQUssWUFDNUI7UUFDQSxNQUFNQyxpQkFBaUJQLFdBQVdNLEtBQUs7UUFLdkMsTUFBTUUsZUFBZVAsT0FBT0Msd0JBQXdCLENBQUNLLGdCQUFnQjtRQUNyRSxNQUFNRSxnQkFBZ0I7WUFFcEIsSUFBQSxJQUFBLE9BQUEsVUFBQSxNQUFBLEVBQUdDLE9BQUgsSUFBQSxNQUFBLE9BQUEsT0FBQSxHQUFBLE9BQUEsTUFBQSxPQUFBO2dCQUFHQSxJQUFBQSxDQUFILEtBQUEsR0FBQSxTQUFBLENBQUEsS0FBbUU7O1lBRW5FWCxRQUFRRCxlQUFlWTtZQUV2QkgsZUFBZUksS0FBSyxDQUFDLElBQUksRUFBRUQ7UUFDN0I7UUFDQSxJQUFJRixjQUFjO1lBQ2hCUCxPQUFPVyxjQUFjLENBQUNILGVBQWUsUUFBUUQ7UUFDL0M7UUFDQVAsT0FBT1csY0FBYyxDQUFDVCxTQUFTTCxZQUFZO1lBQ3pDUSxPQUFPRztRQUNUO1FBRUEsT0FBTztZQUNMUixPQUFPVyxjQUFjLENBQUNULFNBQVNMLFlBQVk7Z0JBQ3pDUSxPQUFPQztnQkFDUEYsVUFBVUwsV0FBV0ssUUFBUTtnQkFDN0JELGNBQWNKLFdBQVdJLFlBQVk7WUFDdkM7UUFDRjtJQUNGO0lBRUEsT0FBTyxLQUFPO0FBQ2hCIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDExNzMsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvbmV4dC1kZXZ0b29scy91c2Vyc3BhY2UvYXBwL2ZvcndhcmQtbG9ncy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tICduZXh0L2Rpc3QvY29tcGlsZWQvc2FmZS1zdGFibGUtc3RyaW5naWZ5J1xuaW1wb3J0IHtcbiAgZ2V0T3duZXJTdGFjayxcbiAgc2V0T3duZXJTdGFja0lmQXZhaWxhYmxlLFxufSBmcm9tICcuL2Vycm9ycy9zdGl0Y2hlZC1lcnJvcidcbmltcG9ydCB7IGdldEVycm9yU291cmNlIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2xpYi9lcnJvci1zb3VyY2UnXG5pbXBvcnQge1xuICBnZXRUZXJtaW5hbExvZ2dpbmdDb25maWcsXG4gIGdldElzVGVybWluYWxMb2dnaW5nRW5hYmxlZCxcbn0gZnJvbSAnLi90ZXJtaW5hbC1sb2dnaW5nLWNvbmZpZydcbmltcG9ydCB7XG4gIHR5cGUgQ29uc29sZUVudHJ5LFxuICB0eXBlIENvbnNvbGVFcnJvckVudHJ5LFxuICB0eXBlIEZvcm1hdHRlZEVycm9yRW50cnksXG4gIHR5cGUgQ2xpZW50TG9nRW50cnksXG4gIHR5cGUgTG9nTWV0aG9kLFxuICBwYXRjaENvbnNvbGVNZXRob2QsXG4gIFVOREVGSU5FRF9NQVJLRVIsXG59IGZyb20gJy4uLy4uL3NoYXJlZC9mb3J3YXJkLWxvZ3Mtc2hhcmVkJ1xuXG5jb25zdCB0ZXJtaW5hbExvZ2dpbmdDb25maWcgPSBnZXRUZXJtaW5hbExvZ2dpbmdDb25maWcoKVxuZXhwb3J0IGNvbnN0IFBST01JU0VfTUFSS0VSID0gJ1Byb21pc2Uge30nXG5leHBvcnQgY29uc3QgVU5BVkFJTEFCTEVfTUFSS0VSID0gJ1tVbmFibGUgdG8gdmlld10nXG5cbmNvbnN0IG1heGltdW1EZXB0aCA9XG4gIHR5cGVvZiB0ZXJtaW5hbExvZ2dpbmdDb25maWcgPT09ICdvYmplY3QnICYmIHRlcm1pbmFsTG9nZ2luZ0NvbmZpZy5kZXB0aExpbWl0XG4gICAgPyB0ZXJtaW5hbExvZ2dpbmdDb25maWcuZGVwdGhMaW1pdFxuICAgIDogNVxuY29uc3QgbWF4aW11bUJyZWFkdGggPVxuICB0eXBlb2YgdGVybWluYWxMb2dnaW5nQ29uZmlnID09PSAnb2JqZWN0JyAmJiB0ZXJtaW5hbExvZ2dpbmdDb25maWcuZWRnZUxpbWl0XG4gICAgPyB0ZXJtaW5hbExvZ2dpbmdDb25maWcuZWRnZUxpbWl0XG4gICAgOiAxMDBcblxuY29uc3Qgc3RyaW5naWZ5ID0gY29uZmlndXJlKHtcbiAgbWF4aW11bURlcHRoLFxuICBtYXhpbXVtQnJlYWR0aCxcbn0pXG5cbmV4cG9ydCBjb25zdCBpc1Rlcm1pbmFsTG9nZ2luZ0VuYWJsZWQgPSBnZXRJc1Rlcm1pbmFsTG9nZ2luZ0VuYWJsZWQoKVxuXG5jb25zdCBtZXRob2RzOiBBcnJheTxMb2dNZXRob2Q+ID0gW1xuICAnbG9nJyxcbiAgJ2luZm8nLFxuICAnd2FybicsXG4gICdkZWJ1ZycsXG4gICd0YWJsZScsXG4gICdhc3NlcnQnLFxuICAnZGlyJyxcbiAgJ2RpcnhtbCcsXG4gICdncm91cCcsXG4gICdncm91cENvbGxhcHNlZCcsXG4gICdncm91cEVuZCcsXG4gICd0cmFjZScsXG5dXG4vKipcbiAqIGFsbG93cyB1cyB0bzpcbiAqIC0gcmV2aXZlIHRoZSB1bmRlZmluZWQgbG9nIGluIHRoZSBzZXJ2ZXIgYXMgaXQgd291bGQgbG9vayBpbiB0aGUgYnJvd3NlclxuICogLSBub3QgcmVhZC9hdHRlbXB0IHRvIHNlcmlhbGl6ZSBwcm9taXNlcyAobmV4dCB3aWxsIGNvbnNvbGUgZXJyb3IgaWYgeW91IGRvIHRoYXQsIGFuZCB3aWxsIGNhdXNlIHRoaXMgcHJvZ3JhbSB0byBpbmZpbml0ZWx5IHJlY3Vyc2UpXG4gKiAtIGlmIHdlIHJlYWQgYSBwcm94eSB0aGF0IHRocm93cyAobm8gd2F5IHRvIGRldGVjdCBpZiBzb21ldGhpbmcgaXMgYSBwcm94eSksIGV4cGxhaW4gdG8gdGhlIHVzZXIgd2UgY2FuJ3QgcmVhZCB0aGlzIGRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByZUxvZ1NlcmlhbGl6YXRpb25DbG9uZTxUPihcbiAgdmFsdWU6IFQsXG4gIHNlZW4gPSBuZXcgV2Vha01hcCgpXG4pOiBhbnkge1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIFVOREVGSU5FRF9NQVJLRVJcbiAgaWYgKHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHJldHVybiB2YWx1ZVxuICBpZiAoc2Vlbi5oYXModmFsdWUgYXMgb2JqZWN0KSkgcmV0dXJuIHNlZW4uZ2V0KHZhbHVlIGFzIG9iamVjdClcblxuICB0cnkge1xuICAgIE9iamVjdC5rZXlzKHZhbHVlIGFzIG9iamVjdClcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIFVOQVZBSUxBQkxFX01BUktFUlxuICB9XG5cbiAgdHJ5IHtcbiAgICBpZiAodHlwZW9mICh2YWx1ZSBhcyBhbnkpLnRoZW4gPT09ICdmdW5jdGlvbicpIHJldHVybiBQUk9NSVNFX01BUktFUlxuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gVU5BVkFJTEFCTEVfTUFSS0VSXG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBjb25zdCBvdXQ6IGFueVtdID0gW11cbiAgICBzZWVuLnNldCh2YWx1ZSwgb3V0KVxuICAgIGZvciAoY29uc3QgaXRlbSBvZiB2YWx1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgb3V0LnB1c2gocHJlTG9nU2VyaWFsaXphdGlvbkNsb25lKGl0ZW0sIHNlZW4pKVxuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIG91dC5wdXNoKFVOQVZBSUxBQkxFX01BUktFUilcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dFxuICB9XG5cbiAgY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpXG4gIGlmIChwcm90byA9PT0gT2JqZWN0LnByb3RvdHlwZSB8fCBwcm90byA9PT0gbnVsbCkge1xuICAgIGNvbnN0IG91dDogUmVjb3JkPHN0cmluZywgdW5rbm93bj4gPSB7fVxuICAgIHNlZW4uc2V0KHZhbHVlIGFzIG9iamVjdCwgb3V0KVxuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHZhbHVlIGFzIG9iamVjdCkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG91dFtrZXldID0gcHJlTG9nU2VyaWFsaXphdGlvbkNsb25lKCh2YWx1ZSBhcyBhbnkpW2tleV0sIHNlZW4pXG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgb3V0W2tleV0gPSBVTkFWQUlMQUJMRV9NQVJLRVJcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dFxuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSlcbn1cblxuLy8gb25seSBzYWZlIGlmIHBhc3NlZCBzYWZlQ2xvbmUgZGF0YVxuZXhwb3J0IGNvbnN0IGxvZ1N0cmluZ2lmeSA9IChkYXRhOiB1bmtub3duKTogc3RyaW5nID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXN1bHQgPSBzdHJpbmdpZnkoZGF0YSlcbiAgICByZXR1cm4gcmVzdWx0ID8/IGBcIiR7VU5BVkFJTEFCTEVfTUFSS0VSfVwiYFxuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gYFwiJHtVTkFWQUlMQUJMRV9NQVJLRVJ9XCJgXG4gIH1cbn1cblxuY29uc3QgYWZ0ZXJUaGlzRnJhbWUgPSAoY2I6ICgpID0+IHZvaWQpID0+IHtcbiAgbGV0IHRpbWVvdXQ6IFJldHVyblR5cGU8dHlwZW9mIHNldFRpbWVvdXQ+IHwgdW5kZWZpbmVkXG5cbiAgY29uc3QgcmFmSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGNiKClcbiAgICB9KVxuICB9KVxuXG4gIHJldHVybiAoKSA9PiB7XG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmSWQpXG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpXG4gIH1cbn1cblxubGV0IGlzUGF0Y2hlZCA9IGZhbHNlXG5cbmNvbnN0IHNlcmlhbGl6ZUVudHJpZXMgPSAoZW50cmllczogQXJyYXk8Q2xpZW50TG9nRW50cnk+KSA9PlxuICBlbnRyaWVzLm1hcCgoY2xpZW50RW50cnkpID0+IHtcbiAgICBzd2l0Y2ggKGNsaWVudEVudHJ5LmtpbmQpIHtcbiAgICAgIGNhc2UgJ2FueS1sb2dnZWQtZXJyb3InOlxuICAgICAgY2FzZSAnY29uc29sZSc6IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5jbGllbnRFbnRyeSxcbiAgICAgICAgICBhcmdzOiBjbGllbnRFbnRyeS5hcmdzLm1hcChzdHJpbmdpZnlVc2VyQXJnKSxcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2FzZSAnZm9ybWF0dGVkLWVycm9yJzoge1xuICAgICAgICByZXR1cm4gY2xpZW50RW50cnlcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgcmV0dXJuIG51bGwhXG4gICAgICB9XG4gICAgfVxuICB9KVxuXG5leHBvcnQgY29uc3QgbG9nUXVldWU6IHtcbiAgZW50cmllczogQXJyYXk8Q2xpZW50TG9nRW50cnk+XG4gIG9uU29ja2V0UmVhZHk6IChzb2NrZXQ6IFdlYlNvY2tldCkgPT4gdm9pZFxuICBmbHVzaFNjaGVkdWxlZDogYm9vbGVhblxuICBzb2NrZXQ6IFdlYlNvY2tldCB8IG51bGxcbiAgY2FuY2VsRmx1c2g6ICgoKSA9PiB2b2lkKSB8IG51bGxcbiAgc291cmNlVHlwZT86ICdzZXJ2ZXInIHwgJ2VkZ2Utc2VydmVyJ1xuICByb3V0ZXI6ICdhcHAnIHwgJ3BhZ2VzJyB8IG51bGxcbiAgc2NoZWR1bGVMb2dTZW5kOiAoZW50cnk6IENsaWVudExvZ0VudHJ5KSA9PiB2b2lkXG59ID0ge1xuICBlbnRyaWVzOiBbXSxcbiAgZmx1c2hTY2hlZHVsZWQ6IGZhbHNlLFxuICBjYW5jZWxGbHVzaDogbnVsbCxcbiAgc29ja2V0OiBudWxsLFxuICBzb3VyY2VUeXBlOiB1bmRlZmluZWQsXG4gIHJvdXRlcjogbnVsbCxcbiAgc2NoZWR1bGVMb2dTZW5kOiAoZW50cnk6IENsaWVudExvZ0VudHJ5KSA9PiB7XG4gICAgbG9nUXVldWUuZW50cmllcy5wdXNoKGVudHJ5KVxuICAgIGlmIChsb2dRdWV1ZS5mbHVzaFNjaGVkdWxlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIHNhZmUgdG8gZGVyZWYgYW5kIHVzZSBpbiBzZXRUaW1lb3V0IGNsb3N1cmUgc2luY2Ugd2UgY2FuY2VsIG9uIG5ldyBzb2NrZXRcbiAgICBjb25zdCBzb2NrZXQgPSBsb2dRdWV1ZS5zb2NrZXRcbiAgICBpZiAoIXNvY2tldCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gd2UgcHJvYmFibHkgZG9udCBuZWVkIHRoaXNcbiAgICBsb2dRdWV1ZS5mbHVzaFNjaGVkdWxlZCA9IHRydWVcblxuICAgIC8vIG5vbiBibG9ja2luZyBsb2cgZmx1c2gsIHJ1bnMgYXQgbW9zdCBvbmNlIHBlciBmcmFtZVxuICAgIGxvZ1F1ZXVlLmNhbmNlbEZsdXNoID0gYWZ0ZXJUaGlzRnJhbWUoKCkgPT4ge1xuICAgICAgbG9nUXVldWUuZmx1c2hTY2hlZHVsZWQgPSBmYWxzZVxuXG4gICAgICAvLyBqdXN0IGluY2FzZVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBldmVudDogJ2Jyb3dzZXItbG9ncycsXG4gICAgICAgICAgZW50cmllczogc2VyaWFsaXplRW50cmllcyhsb2dRdWV1ZS5lbnRyaWVzKSxcbiAgICAgICAgICByb3V0ZXI6IGxvZ1F1ZXVlLnJvdXRlcixcbiAgICAgICAgICAvLyBuZWVkZWQgZm9yIHNvdXJjZSBtYXBwaW5nLCB3ZSBqdXN0IGFzc2lnbiB0aGUgc291cmNlVHlwZSBmcm9tIHRoZSBsYXN0IGVycm9yIGZvciB0aGUgd2hvbGUgYmF0Y2hcbiAgICAgICAgICBzb3VyY2VUeXBlOiBsb2dRdWV1ZS5zb3VyY2VUeXBlLFxuICAgICAgICB9KVxuXG4gICAgICAgIHNvY2tldC5zZW5kKHBheWxvYWQpXG4gICAgICAgIGxvZ1F1ZXVlLmVudHJpZXMgPSBbXVxuICAgICAgICBsb2dRdWV1ZS5zb3VyY2VUeXBlID0gdW5kZWZpbmVkXG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgLy8gZXJyb3IgKG1ha2Ugc3VyZSB1IGRvbid0IGluZmluaXRlIGxvb3ApXG4gICAgICAgIC8qIG5vb3AgKi9cbiAgICAgIH1cbiAgICB9KVxuICB9LFxuICBvblNvY2tldFJlYWR5OiAoc29ja2V0OiBXZWJTb2NrZXQpID0+IHtcbiAgICBpZiAoc29ja2V0LnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgICAvLyBpbnZhcmlhbnRcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIGluY2FzZSBhbiBleGlzdGluZyB0aW1lb3V0IHdhcyBnb2luZyB0byBydW4gd2l0aCBhIHN0YWxlIHNvY2tldFxuICAgIGxvZ1F1ZXVlLmNhbmNlbEZsdXNoPy4oKVxuICAgIGxvZ1F1ZXVlLnNvY2tldCA9IHNvY2tldFxuICAgIHRyeSB7XG4gICAgICBjb25zdCBwYXlsb2FkID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBldmVudDogJ2Jyb3dzZXItbG9ncycsXG4gICAgICAgIGVudHJpZXM6IHNlcmlhbGl6ZUVudHJpZXMobG9nUXVldWUuZW50cmllcyksXG4gICAgICAgIHJvdXRlcjogbG9nUXVldWUucm91dGVyLFxuICAgICAgICBzb3VyY2VUeXBlOiBsb2dRdWV1ZS5zb3VyY2VUeXBlLFxuICAgICAgfSlcblxuICAgICAgc29ja2V0LnNlbmQocGF5bG9hZClcbiAgICAgIGxvZ1F1ZXVlLmVudHJpZXMgPSBbXVxuICAgICAgbG9nUXVldWUuc291cmNlVHlwZSA9IHVuZGVmaW5lZFxuICAgIH0gY2F0Y2gge1xuICAgICAgLyoqIG5vb3AganVzdCBpbmNhc2UgKi9cbiAgICB9XG4gIH0sXG59XG5cbmNvbnN0IHN0cmluZ2lmeVVzZXJBcmcgPSAoXG4gIGFyZzpcbiAgICB8IHtcbiAgICAgICAga2luZDogJ2FyZydcbiAgICAgICAgZGF0YTogdW5rbm93blxuICAgICAgfVxuICAgIHwge1xuICAgICAgICBraW5kOiAnZm9ybWF0dGVkLWVycm9yLWFyZydcbiAgICAgIH1cbikgPT4ge1xuICBpZiAoYXJnLmtpbmQgIT09ICdhcmcnKSB7XG4gICAgcmV0dXJuIGFyZ1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4uYXJnLFxuICAgIGRhdGE6IGxvZ1N0cmluZ2lmeShhcmcuZGF0YSksXG4gIH1cbn1cblxuY29uc3QgY3JlYXRlRXJyb3JBcmcgPSAoZXJyb3I6IEVycm9yKSA9PiB7XG4gIGNvbnN0IHN0YWNrID0gc3RhY2tXaXRoT3duZXJzKGVycm9yKVxuICByZXR1cm4ge1xuICAgIGtpbmQ6ICdmb3JtYXR0ZWQtZXJyb3ItYXJnJyBhcyBjb25zdCxcbiAgICBwcmVmaXg6IGVycm9yLm1lc3NhZ2UgPyBgJHtlcnJvci5uYW1lfTogJHtlcnJvci5tZXNzYWdlfWAgOiBgJHtlcnJvci5uYW1lfWAsXG4gICAgc3RhY2ssXG4gIH1cbn1cblxuY29uc3QgY3JlYXRlTG9nRW50cnkgPSAobGV2ZWw6IExvZ01ldGhvZCwgYXJnczogYW55W10pID0+IHtcbiAgLy8gZG8gbm90IGFic3RyYWN0IHRoaXMsIGl0IGltcGxpY2l0bHkgcmVsaWVzIG9uIHdoaWNoIGZ1bmN0aW9ucyBjYWxsIGl0LiBmb3JjaW5nIHRoZSBpbmxpbmVkIGltcGxlbWVudGF0aW9uIG1ha2VzIHlvdSB0aGluayBhYm91dCBjYWxsZXJzXG4gIC8vIGVycm9yIGNhcHR1cmUgc3RhY2sgdHJhY2UgbWF5YmVcbiAgY29uc3Qgc3RhY2sgPSBzdGFja1dpdGhPd25lcnMobmV3IEVycm9yKCkpXG4gIGNvbnN0IHN0YWNrTGluZXMgPSBzdGFjaz8uc3BsaXQoJ1xcbicpXG4gIGNvbnN0IGNsZWFuU3RhY2sgPSBzdGFja0xpbmVzPy5zbGljZSgzKS5qb2luKCdcXG4nKSAvLyB0aGlzIGlzIHByb2JhYmx5IGlnbm9yZWQgYW55d2F5c1xuICBjb25zdCBlbnRyeTogQ29uc29sZUVudHJ5PHVua25vd24+ID0ge1xuICAgIGtpbmQ6ICdjb25zb2xlJyxcbiAgICBjb25zb2xlTWV0aG9kU3RhY2s6IGNsZWFuU3RhY2sgPz8gbnVsbCwgLy8gZGVwZW5kaW5nIG9uIGJyb3dzZXIgd2UgbWlnaHQgbm90IGhhdmUgc3RhY2tcbiAgICBtZXRob2Q6IGxldmVsLFxuICAgIGFyZ3M6IGFyZ3MubWFwKChhcmcpID0+IHtcbiAgICAgIGlmIChhcmcgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICByZXR1cm4gY3JlYXRlRXJyb3JBcmcoYXJnKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2luZDogJ2FyZycsXG4gICAgICAgIGRhdGE6IHByZUxvZ1NlcmlhbGl6YXRpb25DbG9uZShhcmcpLFxuICAgICAgfVxuICAgIH0pLFxuICB9XG5cbiAgbG9nUXVldWUuc2NoZWR1bGVMb2dTZW5kKGVudHJ5KVxufVxuXG5leHBvcnQgY29uc3QgZm9yd2FyZEVycm9yTG9nID0gKGFyZ3M6IGFueVtdKSA9PiB7XG4gIGNvbnN0IGVycm9yT2JqZWN0cyA9IGFyZ3MuZmlsdGVyKChhcmcpID0+IGFyZyBpbnN0YW5jZW9mIEVycm9yKVxuICBjb25zdCBmaXJzdCA9IGVycm9yT2JqZWN0cy5hdCgwKVxuICBpZiAoZmlyc3QpIHtcbiAgICBjb25zdCBzb3VyY2UgPSBnZXRFcnJvclNvdXJjZShmaXJzdClcbiAgICBpZiAoc291cmNlKSB7XG4gICAgICBsb2dRdWV1ZS5zb3VyY2VUeXBlID0gc291cmNlXG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBicm93c2VyIHNob3dzIHN0YWNrIHJlZ2FyZGxlc3Mgb2YgdHlwZSBvZiBkYXRhIHBhc3NlZCB0byBjb25zb2xlLmVycm9yLCBzbyB3ZSBzaG91bGQgZG8gdGhlIHNhbWVcbiAgICpcbiAgICogZG8gbm90IGFic3RyYWN0IHRoaXMsIGl0IGltcGxpY2l0bHkgcmVsaWVzIG9uIHdoaWNoIGZ1bmN0aW9ucyBjYWxsIGl0LiBmb3JjaW5nIHRoZSBpbmxpbmVkIGltcGxlbWVudGF0aW9uIG1ha2VzIHlvdSB0aGluayBhYm91dCBjYWxsZXJzXG4gICAqL1xuICBjb25zdCBzdGFjayA9IHN0YWNrV2l0aE93bmVycyhuZXcgRXJyb3IoKSlcbiAgY29uc3Qgc3RhY2tMaW5lcyA9IHN0YWNrPy5zcGxpdCgnXFxuJylcbiAgY29uc3QgY2xlYW5TdGFjayA9IHN0YWNrTGluZXM/LnNsaWNlKDMpLmpvaW4oJ1xcbicpXG5cbiAgY29uc3QgZW50cnk6IENvbnNvbGVFcnJvckVudHJ5PHVua25vd24+ID0ge1xuICAgIGtpbmQ6ICdhbnktbG9nZ2VkLWVycm9yJyxcbiAgICBtZXRob2Q6ICdlcnJvcicsXG4gICAgY29uc29sZUVycm9yU3RhY2s6IGNsZWFuU3RhY2sgPz8gJycsXG4gICAgYXJnczogYXJncy5tYXAoKGFyZykgPT4ge1xuICAgICAgaWYgKGFyZyBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVFcnJvckFyZyhhcmcpXG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBraW5kOiAnYXJnJyxcbiAgICAgICAgZGF0YTogcHJlTG9nU2VyaWFsaXphdGlvbkNsb25lKGFyZyksXG4gICAgICB9XG4gICAgfSksXG4gIH1cblxuICBsb2dRdWV1ZS5zY2hlZHVsZUxvZ1NlbmQoZW50cnkpXG59XG5cbmNvbnN0IGNyZWF0ZVVuY2F1Z2h0RXJyb3JFbnRyeSA9IChcbiAgZXJyb3JOYW1lOiBzdHJpbmcsXG4gIGVycm9yTWVzc2FnZTogc3RyaW5nLFxuICBmdWxsU3RhY2s6IHN0cmluZ1xuKSA9PiB7XG4gIGNvbnN0IGVudHJ5OiBGb3JtYXR0ZWRFcnJvckVudHJ5ID0ge1xuICAgIGtpbmQ6ICdmb3JtYXR0ZWQtZXJyb3InLFxuICAgIHByZWZpeDogYFVuY2F1Z2h0ICR7ZXJyb3JOYW1lfTogJHtlcnJvck1lc3NhZ2V9YCxcbiAgICBzdGFjazogZnVsbFN0YWNrLFxuICAgIG1ldGhvZDogJ2Vycm9yJyxcbiAgfVxuXG4gIGxvZ1F1ZXVlLnNjaGVkdWxlTG9nU2VuZChlbnRyeSlcbn1cblxuY29uc3Qgc3RhY2tXaXRoT3duZXJzID0gKGVycm9yOiBFcnJvcikgPT4ge1xuICBsZXQgb3duZXJTdGFjayA9ICcnXG4gIHNldE93bmVyU3RhY2tJZkF2YWlsYWJsZShlcnJvcilcbiAgb3duZXJTdGFjayA9IGdldE93bmVyU3RhY2soZXJyb3IpIHx8ICcnXG4gIGNvbnN0IHN0YWNrID0gKGVycm9yLnN0YWNrIHx8ICcnKSArIG93bmVyU3RhY2tcbiAgcmV0dXJuIHN0YWNrXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2dVbmhhbmRsZWRSZWplY3Rpb24ocmVhc29uOiB1bmtub3duKSB7XG4gIGlmIChyZWFzb24gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIGNyZWF0ZVVuaGFuZGxlZFJlamVjdGlvbkVycm9yRW50cnkocmVhc29uLCBzdGFja1dpdGhPd25lcnMocmVhc29uKSlcbiAgICByZXR1cm5cbiAgfVxuICBjcmVhdGVVbmhhbmRsZWRSZWplY3Rpb25Ob25FcnJvckVudHJ5KHJlYXNvbilcbn1cblxuY29uc3QgY3JlYXRlVW5oYW5kbGVkUmVqZWN0aW9uRXJyb3JFbnRyeSA9IChcbiAgZXJyb3I6IEVycm9yLFxuICBmdWxsU3RhY2s6IHN0cmluZ1xuKSA9PiB7XG4gIGNvbnN0IHNvdXJjZSA9IGdldEVycm9yU291cmNlKGVycm9yKVxuICBpZiAoc291cmNlKSB7XG4gICAgbG9nUXVldWUuc291cmNlVHlwZSA9IHNvdXJjZVxuICB9XG5cbiAgY29uc3QgZW50cnk6IENsaWVudExvZ0VudHJ5ID0ge1xuICAgIGtpbmQ6ICdmb3JtYXR0ZWQtZXJyb3InLFxuICAgIHByZWZpeDogYOKoryB1bmhhbmRsZWRSZWplY3Rpb246ICR7ZXJyb3IubmFtZX06ICR7ZXJyb3IubWVzc2FnZX1gLFxuICAgIHN0YWNrOiBmdWxsU3RhY2ssXG4gICAgbWV0aG9kOiAnZXJyb3InLFxuICB9XG5cbiAgbG9nUXVldWUuc2NoZWR1bGVMb2dTZW5kKGVudHJ5KVxufVxuXG5jb25zdCBjcmVhdGVVbmhhbmRsZWRSZWplY3Rpb25Ob25FcnJvckVudHJ5ID0gKHJlYXNvbjogdW5rbm93bikgPT4ge1xuICBjb25zdCBlbnRyeTogQ2xpZW50TG9nRW50cnkgPSB7XG4gICAga2luZDogJ2FueS1sb2dnZWQtZXJyb3InLFxuICAgIC8vIHdlIGNhbid0IGFjY2VzcyB0aGUgc3RhY2sgc2luY2UgdGhlIGV2ZW50IGlzIGRpc3BhdGNoZWQgYXN5bmMgYW5kIGNyZWF0aW5nIGFuIGlubGluZSBlcnJvciB3b3VsZCBiZSBtZWFuaW5nbGVzc1xuICAgIGNvbnNvbGVFcnJvclN0YWNrOiAnJyxcbiAgICBtZXRob2Q6ICdlcnJvcicsXG4gICAgYXJnczogW1xuICAgICAge1xuICAgICAgICBraW5kOiAnYXJnJyxcbiAgICAgICAgZGF0YTogYOKoryB1bmhhbmRsZWRSZWplY3Rpb246YCxcbiAgICAgICAgaXNSZWplY3Rpb25NZXNzYWdlOiB0cnVlLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAga2luZDogJ2FyZycsXG4gICAgICAgIGRhdGE6IHByZUxvZ1NlcmlhbGl6YXRpb25DbG9uZShyZWFzb24pLFxuICAgICAgfSxcbiAgICBdLFxuICB9XG5cbiAgbG9nUXVldWUuc2NoZWR1bGVMb2dTZW5kKGVudHJ5KVxufVxuXG5jb25zdCBpc0hNUiA9IChhcmdzOiBhbnlbXSkgPT4ge1xuICBjb25zdCBmaXJzdEFyZyA9IGFyZ3NbMF1cbiAgaWYgKHR5cGVvZiBmaXJzdEFyZyAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBpZiAoZmlyc3RBcmcuc3RhcnRzV2l0aCgnW0Zhc3QgUmVmcmVzaF0nKSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpZiAoZmlyc3RBcmcuc3RhcnRzV2l0aCgnW0hNUl0nKSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn1cblxuY29uc3QgaXNJZ25vcmVkTG9nID0gKGFyZ3M6IGFueVtdKSA9PiB7XG4gIGlmIChhcmdzLmxlbmd0aCA8IDMpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGNvbnN0IFtmb3JtYXQsIHN0eWxlcywgbGFiZWxdID0gYXJnc1xuXG4gIGlmIChcbiAgICB0eXBlb2YgZm9ybWF0ICE9PSAnc3RyaW5nJyB8fFxuICAgIHR5cGVvZiBzdHlsZXMgIT09ICdzdHJpbmcnIHx8XG4gICAgdHlwZW9mIGxhYmVsICE9PSAnc3RyaW5nJ1xuICApIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIGtpbmRhIGhhY2t5LCB3ZSBzaG91bGQgZGVmaW5lIGEgY29tbW9uIGZvcm1hdCBmb3IgdGhlc2Ugc3RyaW5ncyBzbyB3ZSBjYW4gc2FmZWx5IGlnbm9yZVxuICByZXR1cm4gZm9ybWF0LnN0YXJ0c1dpdGgoJyVjJXMlYycpICYmIHN0eWxlcy5pbmNsdWRlcygnYmFja2dyb3VuZDonKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9yd2FyZFVuaGFuZGxlZEVycm9yKGVycm9yOiBFcnJvcikge1xuICBjcmVhdGVVbmNhdWdodEVycm9yRW50cnkoZXJyb3IubmFtZSwgZXJyb3IubWVzc2FnZSwgc3RhY2tXaXRoT3duZXJzKGVycm9yKSlcbn1cblxuLy8gVE9ETzogdGhpcyByb3V0ZXIgY2hlY2sgaXMgYnJpdHRsZSwgd2UgbmVlZCB0byB1cGRhdGUgYmFzZWQgb24gdGhlIGN1cnJlbnQgcm91dGVyIHRoZSB1c2VyIGlzIHVzaW5nXG5leHBvcnQgY29uc3QgaW5pdGlhbGl6ZURlYnVnTG9nRm9yd2FyZGluZyA9IChyb3V0ZXI6ICdhcHAnIHwgJ3BhZ2VzJyk6IHZvaWQgPT4ge1xuICAvLyBwcm9iYWJseSBkb24ndCBuZWVkIHRoaXNcbiAgaWYgKGlzUGF0Y2hlZCkge1xuICAgIHJldHVyblxuICB9XG4gIC8vIFRPRE8ocm9iKTogd2h5IGRvZXMgdGhpcyBicmVhayByZW5kZXJpbmcgb24gc2VydmVyLCBpbXBvcnRhbnQgdG8ga25vdyBpbmNhc2UgdGhlIHNhbWUgYnVnIGFwcGVhcnMgaW4gYnJvd3NlclxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGJldHRlciB0byBiZSBzYWZlIHRoYW4gc29ycnlcbiAgdHJ5IHtcbiAgICBtZXRob2RzLmZvckVhY2goKG1ldGhvZCkgPT5cbiAgICAgIHBhdGNoQ29uc29sZU1ldGhvZChtZXRob2QsIChfLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgIGlmIChpc0hNUihhcmdzKSkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGlmIChpc0lnbm9yZWRMb2coYXJncykpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBjcmVhdGVMb2dFbnRyeShtZXRob2QsIGFyZ3MpXG4gICAgICB9KVxuICAgIClcbiAgfSBjYXRjaCB7fVxuICBsb2dRdWV1ZS5yb3V0ZXIgPSByb3V0ZXJcbiAgaXNQYXRjaGVkID0gdHJ1ZVxufVxuIl0sIm5hbWVzIjpbIlBST01JU0VfTUFSS0VSIiwiVU5BVkFJTEFCTEVfTUFSS0VSIiwiZm9yd2FyZEVycm9yTG9nIiwiZm9yd2FyZFVuaGFuZGxlZEVycm9yIiwiaW5pdGlhbGl6ZURlYnVnTG9nRm9yd2FyZGluZyIsImlzVGVybWluYWxMb2dnaW5nRW5hYmxlZCIsImxvZ1F1ZXVlIiwibG9nU3RyaW5naWZ5IiwibG9nVW5oYW5kbGVkUmVqZWN0aW9uIiwicHJlTG9nU2VyaWFsaXphdGlvbkNsb25lIiwidGVybWluYWxMb2dnaW5nQ29uZmlnIiwiZ2V0VGVybWluYWxMb2dnaW5nQ29uZmlnIiwibWF4aW11bURlcHRoIiwiZGVwdGhMaW1pdCIsIm1heGltdW1CcmVhZHRoIiwiZWRnZUxpbWl0Iiwic3RyaW5naWZ5IiwiY29uZmlndXJlIiwiZ2V0SXNUZXJtaW5hbExvZ2dpbmdFbmFibGVkIiwibWV0aG9kcyIsInZhbHVlIiwic2VlbiIsIldlYWtNYXAiLCJ1bmRlZmluZWQiLCJVTkRFRklORURfTUFSS0VSIiwiaGFzIiwiZ2V0IiwiT2JqZWN0Iiwia2V5cyIsInRoZW4iLCJBcnJheSIsImlzQXJyYXkiLCJvdXQiLCJzZXQiLCJpdGVtIiwicHVzaCIsInByb3RvIiwiZ2V0UHJvdG90eXBlT2YiLCJwcm90b3R5cGUiLCJrZXkiLCJ0b1N0cmluZyIsImNhbGwiLCJkYXRhIiwicmVzdWx0IiwiYWZ0ZXJUaGlzRnJhbWUiLCJjYiIsInRpbWVvdXQiLCJyYWZJZCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInNldFRpbWVvdXQiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImNsZWFyVGltZW91dCIsImlzUGF0Y2hlZCIsInNlcmlhbGl6ZUVudHJpZXMiLCJlbnRyaWVzIiwibWFwIiwiY2xpZW50RW50cnkiLCJraW5kIiwiYXJncyIsInN0cmluZ2lmeVVzZXJBcmciLCJmbHVzaFNjaGVkdWxlZCIsImNhbmNlbEZsdXNoIiwic29ja2V0Iiwic291cmNlVHlwZSIsInJvdXRlciIsInNjaGVkdWxlTG9nU2VuZCIsImVudHJ5IiwicGF5bG9hZCIsIkpTT04iLCJldmVudCIsInNlbmQiLCJvblNvY2tldFJlYWR5IiwicmVhZHlTdGF0ZSIsIldlYlNvY2tldCIsIk9QRU4iLCJhcmciLCJjcmVhdGVFcnJvckFyZyIsImVycm9yIiwic3RhY2siLCJzdGFja1dpdGhPd25lcnMiLCJwcmVmaXgiLCJtZXNzYWdlIiwibmFtZSIsImNyZWF0ZUxvZ0VudHJ5IiwibGV2ZWwiLCJFcnJvciIsInN0YWNrTGluZXMiLCJzcGxpdCIsImNsZWFuU3RhY2siLCJzbGljZSIsImpvaW4iLCJjb25zb2xlTWV0aG9kU3RhY2siLCJtZXRob2QiLCJlcnJvck9iamVjdHMiLCJmaWx0ZXIiLCJmaXJzdCIsImF0Iiwic291cmNlIiwiZ2V0RXJyb3JTb3VyY2UiLCJjb25zb2xlRXJyb3JTdGFjayIsImNyZWF0ZVVuY2F1Z2h0RXJyb3JFbnRyeSIsImVycm9yTmFtZSIsImVycm9yTWVzc2FnZSIsImZ1bGxTdGFjayIsIm93bmVyU3RhY2siLCJzZXRPd25lclN0YWNrSWZBdmFpbGFibGUiLCJnZXRPd25lclN0YWNrIiwicmVhc29uIiwiY3JlYXRlVW5oYW5kbGVkUmVqZWN0aW9uRXJyb3JFbnRyeSIsImNyZWF0ZVVuaGFuZGxlZFJlamVjdGlvbk5vbkVycm9yRW50cnkiLCJpc1JlamVjdGlvbk1lc3NhZ2UiLCJpc0hNUiIsImZpcnN0QXJnIiwic3RhcnRzV2l0aCIsImlzSWdub3JlZExvZyIsImxlbmd0aCIsImZvcm1hdCIsInN0eWxlcyIsImxhYmVsIiwiaW5jbHVkZXMiLCJ3aW5kb3ciLCJmb3JFYWNoIiwicGF0Y2hDb25zb2xlTWV0aG9kIiwiXyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQXFCYUEsY0FBYyxFQUFBO2VBQWRBOztJQUNBQyxrQkFBa0IsRUFBQTtlQUFsQkE7O0lBeVFBQyxlQUFlLEVBQUE7ZUFBZkE7O0lBK0lHQyxxQkFBcUIsRUFBQTtlQUFyQkE7O0lBS0hDLDRCQUE0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QUVPLFNBQVNwSCxzQkFBc0IwRSxLQUFZO0lBQ2hEdUIseUJBQXlCdkIsTUFBTUssSUFBSSxFQUFFTCxNQUFNSSxPQUFPLEVBQUVGLGdCQUFnQkY7QUFDdEU7QUFHTyxNQUFNekUsK0JBQStCLENBQUM0RDtJQUMzQywyQkFBMkI7SUFDM0IsSUFBSVosV0FBVztRQUNiO0lBQ0Y7SUFDQSwrR0FBK0c7SUFDL0csSUFBSSxPQUFPb0UsV0FBVyxhQUFhO1FBQ2pDO0lBQ0Y7SUFFQSwrQkFBK0I7SUFDL0IsSUFBSTtRQUNGckcsUUFBUXNHLE9BQU8sQ0FBQyxDQUFDN0IsU0FDZjhCLENBQUFBLEdBQUFBLG1CQUFBQSxrQkFBa0IsRUFBQzlCLFFBQVEsU0FBQytCLENBQUFBO2lEQUFNakUsT0FBQUEsSUFBQUEsTUFBQUEsT0FBQUEsSUFBQUEsT0FBQUEsSUFBQUEsSUFBQUEsT0FBQUEsR0FBQUEsT0FBQUEsTUFBQUEsT0FBQUE7b0JBQUFBLElBQUFBLENBQUFBLE9BQUFBLEVBQUFBLEdBQUFBLFNBQUFBLENBQUFBLEtBQUFBOztnQkFDaEMsSUFBSXFELE1BQU1yRCxPQUFPO29CQUNmO2dCQUNGO2dCQUNBLElBQUl3RCxhQUFheEQsT0FBTztvQkFDdEI7Z0JBQ0Y7Z0JBQ0F5QixlQUFlUyxRQUFRbEM7WUFDekI7SUFFSixFQUFFLE9BQUEsR0FBTSxDQUFDO0lBQ1RwRCxTQUFTMEQsTUFBTSxHQUFHQTtJQUNsQlosWUFBWTtBQUNkIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDE1OTQsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvbmV4dC1kZXZ0b29scy91c2Vyc3BhY2UvcGFnZXMvcGFnZXMtZGV2LW92ZXJsYXktc2V0dXAudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCB7IHJlbmRlclBhZ2VzRGV2T3ZlcmxheSB9IGZyb20gJ25leHQvZGlzdC9jb21waWxlZC9uZXh0LWRldnRvb2xzJ1xuaW1wb3J0IHsgZGlzcGF0Y2hlciB9IGZyb20gJ25leHQvZGlzdC9jb21waWxlZC9uZXh0LWRldnRvb2xzJ1xuaW1wb3J0IHtcbiAgYXR0YWNoSHlkcmF0aW9uRXJyb3JTdGF0ZSxcbiAgc3RvcmVIeWRyYXRpb25FcnJvclN0YXRlRnJvbUNvbnNvbGVBcmdzLFxufSBmcm9tICcuL2h5ZHJhdGlvbi1lcnJvci1zdGF0ZSdcbmltcG9ydCB7IFJvdXRlciB9IGZyb20gJy4uLy4uLy4uL2NsaWVudC9yb3V0ZXInXG5pbXBvcnQgeyBnZXRDb21wb25lbnRTdGFjaywgZ2V0T3duZXJTdGFjayB9IGZyb20gJy4uL2FwcC9lcnJvcnMvc3RpdGNoZWQtZXJyb3InXG5pbXBvcnQgeyBpc1JlY292ZXJhYmxlRXJyb3IgfSBmcm9tICcuLi8uLi8uLi9jbGllbnQvcmVhY3QtY2xpZW50LWNhbGxiYWNrcy9vbi1yZWNvdmVyYWJsZS1lcnJvcidcbmltcG9ydCB7IGdldFNxdWFzaGVkSHlkcmF0aW9uRXJyb3JEZXRhaWxzIH0gZnJvbSAnLi9oeWRyYXRpb24tZXJyb3Itc3RhdGUnXG5pbXBvcnQgeyBQYWdlc0Rldk92ZXJsYXlFcnJvckJvdW5kYXJ5IH0gZnJvbSAnLi9wYWdlcy1kZXYtb3ZlcmxheS1lcnJvci1ib3VuZGFyeSdcbmltcG9ydCB7XG4gIGluaXRpYWxpemVEZWJ1Z0xvZ0ZvcndhcmRpbmcsXG4gIGZvcndhcmRVbmhhbmRsZWRFcnJvcixcbiAgbG9nVW5oYW5kbGVkUmVqZWN0aW9uLFxuICBmb3J3YXJkRXJyb3JMb2csXG4gIGlzVGVybWluYWxMb2dnaW5nRW5hYmxlZCxcbn0gZnJvbSAnLi4vYXBwL2ZvcndhcmQtbG9ncydcblxuY29uc3QgdXNlUGFnZXNEZXZPdmVybGF5QnJpZGdlID0gKCkgPT4ge1xuICBSZWFjdC51c2VJbnNlcnRpb25FZmZlY3QoKCkgPT4ge1xuICAgIC8vIE5EVCB1c2VzIGEgZGlmZmVyZW50IFJlYWN0IGluc3RhbmNlIHNvIGl0J3Mgbm90IHRlY2huaWNhbGx5IGEgc3RhdGUgdXBkYXRlXG4gICAgLy8gc2NoZWR1bGVkIGZyb20gdXNlSW5zZXJ0aW9uRWZmZWN0LlxuICAgIHJlbmRlclBhZ2VzRGV2T3ZlcmxheShcbiAgICAgIGdldENvbXBvbmVudFN0YWNrLFxuICAgICAgZ2V0T3duZXJTdGFjayxcbiAgICAgIGdldFNxdWFzaGVkSHlkcmF0aW9uRXJyb3JEZXRhaWxzLFxuICAgICAgaXNSZWNvdmVyYWJsZUVycm9yXG4gICAgKVxuICB9LCBbXSlcblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHsgaGFuZGxlU3RhdGljSW5kaWNhdG9yIH0gPVxuICAgICAgcmVxdWlyZSgnLi4vLi4vLi4vY2xpZW50L2Rldi9ob3QtcmVsb2FkZXIvcGFnZXMvaG90LXJlbG9hZGVyLXBhZ2VzJykgYXMgdHlwZW9mIGltcG9ydCgnLi4vLi4vLi4vY2xpZW50L2Rldi9ob3QtcmVsb2FkZXIvcGFnZXMvaG90LXJlbG9hZGVyLXBhZ2VzJylcblxuICAgIFJvdXRlci5ldmVudHMub24oJ3JvdXRlQ2hhbmdlQ29tcGxldGUnLCBoYW5kbGVTdGF0aWNJbmRpY2F0b3IpXG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgUm91dGVyLmV2ZW50cy5vZmYoJ3JvdXRlQ2hhbmdlQ29tcGxldGUnLCBoYW5kbGVTdGF0aWNJbmRpY2F0b3IpXG4gICAgfVxuICB9LCBbXSlcbn1cblxuZXhwb3J0IHR5cGUgUGFnZXNEZXZPdmVybGF5QnJpZGdlVHlwZSA9IHR5cGVvZiBQYWdlc0Rldk92ZXJsYXlCcmlkZ2VcblxuaW50ZXJmYWNlIFBhZ2VzRGV2T3ZlcmxheUJyaWRnZVByb3BzIHtcbiAgY2hpbGRyZW4/OiBSZWFjdC5SZWFjdE5vZGVcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFBhZ2VzRGV2T3ZlcmxheUJyaWRnZSh7XG4gIGNoaWxkcmVuLFxufTogUGFnZXNEZXZPdmVybGF5QnJpZGdlUHJvcHMpIHtcbiAgdXNlUGFnZXNEZXZPdmVybGF5QnJpZGdlKClcblxuICByZXR1cm4gPFBhZ2VzRGV2T3ZlcmxheUVycm9yQm91bmRhcnk+e2NoaWxkcmVufTwvUGFnZXNEZXZPdmVybGF5RXJyb3JCb3VuZGFyeT5cbn1cblxubGV0IGlzUmVnaXN0ZXJlZCA9IGZhbHNlXG5cbmZ1bmN0aW9uIGhhbmRsZUVycm9yKGVycm9yOiB1bmtub3duKSB7XG4gIGlmICghZXJyb3IgfHwgIShlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB8fCB0eXBlb2YgZXJyb3Iuc3RhY2sgIT09ICdzdHJpbmcnKSB7XG4gICAgLy8gQSBub24tZXJyb3Igd2FzIHRocm93biwgd2UgZG9uJ3QgaGF2ZSBhbnl0aGluZyB0byBzaG93LiA6LShcbiAgICByZXR1cm5cbiAgfVxuXG4gIGF0dGFjaEh5ZHJhdGlvbkVycm9yU3RhdGUoZXJyb3IpXG5cbiAgLy8gU2tpcCBNb2R1bGVCdWlsZEVycm9yIGFuZCBNb2R1bGVOb3RGb3VuZEVycm9yLCBhcyBpdCB3aWxsIGJlIHNlbnQgdGhyb3VnaCBvbkJ1aWxkRXJyb3IgY2FsbGJhY2suXG4gIC8vIFRoaXMgaXMgdG8gYXZvaWQgc2FtZSBlcnJvciBhcyBkaWZmZXJlbnQgdHlwZSBzaG93aW5nIHVwIG9uIGNsaWVudCB0byBjYXVzZSBmbGFzaGluZy5cbiAgaWYgKFxuICAgIGVycm9yLm5hbWUgIT09ICdNb2R1bGVCdWlsZEVycm9yJyAmJlxuICAgIGVycm9yLm5hbWUgIT09ICdNb2R1bGVOb3RGb3VuZEVycm9yJ1xuICApIHtcbiAgICBkaXNwYXRjaGVyLm9uVW5oYW5kbGVkRXJyb3IoZXJyb3IpXG4gIH1cbn1cblxubGV0IG9yaWdDb25zb2xlRXJyb3IgPSBjb25zb2xlLmVycm9yXG5mdW5jdGlvbiBuZXh0SnNIYW5kbGVDb25zb2xlRXJyb3IoLi4uYXJnczogYW55W10pIHtcbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iL2Q1MDMyM2ViODQ1YzVmZGUwZDcyMGNhZTg4OGJmMzVkZWRkMDU1MDYvcGFja2FnZXMvcmVhY3QtcmVjb25jaWxlci9zcmMvUmVhY3RGaWJlckVycm9yTG9nZ2VyLmpzI0w3OFxuICBjb25zdCBtYXliZUVycm9yID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGFyZ3NbMV0gOiBhcmdzWzBdXG4gIHN0b3JlSHlkcmF0aW9uRXJyb3JTdGF0ZUZyb21Db25zb2xlQXJncyguLi5hcmdzKVxuICAvLyBUT0RPOiBTdXJmYWNlcyBub24tZXJyb3JzIGxvZ2dlZCB2aWEgYGNvbnNvbGUuZXJyb3JgLlxuICBoYW5kbGVFcnJvcihtYXliZUVycm9yKVxuICBpZiAoaXNUZXJtaW5hbExvZ2dpbmdFbmFibGVkKSB7XG4gICAgZm9yd2FyZEVycm9yTG9nKGFyZ3MpXG4gIH1cbiAgb3JpZ0NvbnNvbGVFcnJvci5hcHBseSh3aW5kb3cuY29uc29sZSwgYXJncylcbn1cblxuZnVuY3Rpb24gb25VbmhhbmRsZWRFcnJvcihldmVudDogRXJyb3JFdmVudCkge1xuICBjb25zdCBlcnJvciA9IGV2ZW50Py5lcnJvclxuICBoYW5kbGVFcnJvcihlcnJvcilcblxuICBpZiAoZXJyb3IgJiYgaXNUZXJtaW5hbExvZ2dpbmdFbmFibGVkKSB7XG4gICAgZm9yd2FyZFVuaGFuZGxlZEVycm9yKGVycm9yIGFzIEVycm9yKVxuICB9XG59XG5cbmZ1bmN0aW9uIG9uVW5oYW5kbGVkUmVqZWN0aW9uKGV2OiBQcm9taXNlUmVqZWN0aW9uRXZlbnQpIHtcbiAgY29uc3QgcmVhc29uID0gZXY/LnJlYXNvblxuICBpZiAoXG4gICAgIXJlYXNvbiB8fFxuICAgICEocmVhc29uIGluc3RhbmNlb2YgRXJyb3IpIHx8XG4gICAgdHlwZW9mIHJlYXNvbi5zdGFjayAhPT0gJ3N0cmluZydcbiAgKSB7XG4gICAgLy8gQSBub24tZXJyb3Igd2FzIHRocm93biwgd2UgZG9uJ3QgaGF2ZSBhbnl0aGluZyB0byBzaG93LiA6LShcbiAgICByZXR1cm5cbiAgfVxuXG4gIGRpc3BhdGNoZXIub25VbmhhbmRsZWRSZWplY3Rpb24ocmVhc29uKVxuICBpZiAoaXNUZXJtaW5hbExvZ2dpbmdFbmFibGVkKSB7XG4gICAgbG9nVW5oYW5kbGVkUmVqZWN0aW9uKHJlYXNvbilcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXIoKSB7XG4gIGlmIChpc1JlZ2lzdGVyZWQpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpc1JlZ2lzdGVyZWQgPSB0cnVlXG5cbiAgdHJ5IHtcbiAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSA1MFxuICB9IGNhdGNoIHt9XG5cbiAgaWYgKGlzVGVybWluYWxMb2dnaW5nRW5hYmxlZCkge1xuICAgIGluaXRpYWxpemVEZWJ1Z0xvZ0ZvcndhcmRpbmcoJ3BhZ2VzJylcbiAgfVxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvblVuaGFuZGxlZEVycm9yKVxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndW5oYW5kbGVkcmVqZWN0aW9uJywgb25VbmhhbmRsZWRSZWplY3Rpb24pXG4gIHdpbmRvdy5jb25zb2xlLmVycm9yID0gbmV4dEpzSGFuZGxlQ29uc29sZUVycm9yXG59XG4iXSwibmFtZXMiOlsiUGFnZXNEZXZPdmVybGF5QnJpZGdlIiwicmVnaXN0ZXIiLCJ1c2VQYWdlc0Rldk92ZXJsYXlCcmlkZ2UiLCJSZWFjdCIsInVzZUluc2VydGlvbkVmZmVjdCIsInJlbmRlclBhZ2VzRGV2T3ZlcmxheSIsImdldENvbXBvbmVudFN0YWNrIiwiZ2V0T3duZXJTdGFjayIsImdldFNxdWFzaGVkSHlkcmF0aW9uRXJyb3JEZXRhaWxzIiwiaXNSZWNvdmVyYWJsZUVycm9yIiwidXNlRWZmZWN0IiwiaGFuZGxlU3RhdGljSW5kaWNhdG9yIiwicmVxdWlyZSIsIlJvdXRlciIsImV2ZW50cyIsIm9uIiwib2ZmIiwiY2hpbGRyZW4iLCJQYWdlc0Rldk92ZXJsYXlFcnJvckJvdW5kYXJ5IiwiaXNSZWdpc3RlcmVkIiwiaGFuZGxlRXJyb3IiLCJlcnJvciIsIkVycm9yIiwic3RhY2siLCJhdHRhY2hIeWRyYXRpb25FcnJvclN0YXRlIiwibmFtZSIsImRpc3BhdGNoZXIiLCJvblVuaGFuZGxlZEVycm9yIiwib3JpZ0NvbnNvbGVFcnJvciIsImNvbnNvbGUiLCJuZXh0SnNIYW5kbGVDb25zb2xlRXJyb3IiLCJhcmdzIiwibWF5YmVFcnJvciIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsInN0b3JlSHlkcmF0aW9uRXJyb3JTdGF0ZUZyb21Db25zb2xlQXJncyIsImlzVGVybWluYWxMb2dnaW5nRW5hYmxlZCIsImZvcndhcmRFcnJvckxvZyIsImFwcGx5Iiwid2luZG93IiwiZXZlbnQiLCJmb3J3YXJkVW5oYW5kbGVkRXJyb3IiLCJvblVuaGFuZGxlZFJlamVjdGlvbiIsImV2IiwicmVhc29uIiwibG9nVW5oYW5kbGVkUmVqZWN0aW9uIiwic3RhY2tUcmFjZUxpbWl0IiwiaW5pdGlhbGl6ZURlYnVnTG9nRm9yd2FyZGluZyIsImFkZEV2ZW50TGlzdGVuZXIiXSwibWFwcGluZ3MiOiJBQWlGcUJpQyxRQUFRQyxHQUFHLENBQUNDLFFBQVEsS0FBSzs7Ozs7Ozs7Ozs7Ozs7OztJQS9COUJuQyxxQkFBcUIsRUFBQTtlQUFyQkE7O0lBbUVBQyxRQUFRLEVBQUE7ZUFBUkE7Ozs7O2dFQXJIRTs4QkFDb0I7cUNBSy9CO3dCQUNnQjsrQkFDMEI7b0NBQ2Q7OENBRVU7NkJBT3RDO0FBRVAsTUFBTUMsMkJBQTJCO0lBQy9CQyxPQUFBQSxPQUFLLENBQUNDLGtCQUFrQjt1REFBQztZQUN2Qiw2RUFBNkU7WUFDN0UscUNBQXFDO1lBQ3JDQyxDQUFBQSxHQUFBQSxjQUFBQSxxQkFBcUIsRUFDbkJDLGVBQUFBLGlCQUFpQixFQUNqQkMsZUFBQUEsYUFBYSxFQUNiQyxxQkFBQUEsZ0NBQWdDLEVBQ2hDQyxvQkFBQUEsa0JBQWtCO1FBRXRCO3NEQUFHLEVBQUU7SUFFTE4sT0FB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Q0FBQyxzQkFBc0JOO0lBQzlDSCxPQUFPWCxPQUFPLENBQUNSLEtBQUssR0FBR1M7QUFDekIiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTcyOCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9zZXJ2ZXIvZGV2L2hvdC1yZWxvYWRlci10eXBlcy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IEluY29taW5nTWVzc2FnZSwgU2VydmVyUmVzcG9uc2UgfSBmcm9tICdodHRwJ1xuaW1wb3J0IHR5cGUgeyBVcmxPYmplY3QgfSBmcm9tICd1cmwnXG5pbXBvcnQgdHlwZSB7IER1cGxleCB9IGZyb20gJ3N0cmVhbSdcbmltcG9ydCB0eXBlIHsgd2VicGFjayB9IGZyb20gJ25leHQvZGlzdC9jb21waWxlZC93ZWJwYWNrL3dlYnBhY2snXG5pbXBvcnQgdHlwZSBnZXRCYXNlV2VicGFja0NvbmZpZyBmcm9tICcuLi8uLi9idWlsZC93ZWJwYWNrLWNvbmZpZydcbmltcG9ydCB0eXBlIHsgUm91dGVEZWZpbml0aW9uIH0gZnJvbSAnLi4vcm91dGUtZGVmaW5pdGlvbnMvcm91dGUtZGVmaW5pdGlvbidcbmltcG9ydCB0eXBlIHsgUHJvamVjdCwgVXBkYXRlIGFzIFR1cmJvcGFja1VwZGF0ZSB9IGZyb20gJy4uLy4uL2J1aWxkL3N3Yy90eXBlcydcbmltcG9ydCB0eXBlIHsgVmVyc2lvbkluZm8gfSBmcm9tICcuL3BhcnNlLXZlcnNpb24taW5mbydcbmltcG9ydCB0eXBlIHsgRGVidWdJbmZvIH0gZnJvbSAnLi4vLi4vbmV4dC1kZXZ0b29scy9zaGFyZWQvdHlwZXMnXG5pbXBvcnQgdHlwZSB7IERldkluZGljYXRvclNlcnZlclN0YXRlIH0gZnJvbSAnLi9kZXYtaW5kaWNhdG9yLXNlcnZlci1zdGF0ZSdcblxuZXhwb3J0IGNvbnN0IGVudW0gSE1SX0FDVElPTlNfU0VOVF9UT19CUk9XU0VSIHtcbiAgQURERURfUEFHRSA9ICdhZGRlZFBhZ2UnLFxuICBSRU1PVkVEX1BBR0UgPSAncmVtb3ZlZFBhZ2UnLFxuICBSRUxPQURfUEFHRSA9ICdyZWxvYWRQYWdlJyxcbiAgU0VSVkVSX0NPTVBPTkVOVF9DSEFOR0VTID0gJ3NlcnZlckNvbXBvbmVudENoYW5nZXMnLFxuICBNSURETEVXQVJFX0NIQU5HRVMgPSAnbWlkZGxld2FyZUNoYW5nZXMnLFxuICBDTElFTlRfQ0hBTkdFUyA9ICdjbGllbnRDaGFuZ2VzJyxcbiAgU0VSVkVSX09OTFlfQ0hBTkdFUyA9ICdzZXJ2ZXJPbmx5Q2hhbmdlcycsXG4gIFNZTkMgPSAnc3luYycsXG4gIEJVSUxUID0gJ2J1aWx0JyxcbiAgQlVJTERJTkcgPSAnYnVpbGRpbmcnLFxuICBERVZfUEFHRVNfTUFOSUZFU1RfVVBEQVRFID0gJ2RldlBhZ2VzTWFuaWZlc3RVcGRhdGUnLFxuICBUVVJCT1BBQ0tfTUVTU0FHRSA9ICd0dXJib3BhY2stbWVzc2FnZScsXG4gIFNFUlZFUl9FUlJPUiA9ICdzZXJ2ZXJFcnJvcicsXG4gIFRVUkJPUEFDS19DT05ORUNURUQgPSAndHVyYm9wYWNrLWNvbm5lY3RlZCcsXG4gIElTUl9NQU5JRkVTVCA9ICdpc3JNYW5pZmVzdCcsXG4gIERFVl9JTkRJQ0FUT1IgPSAnZGV2SW5kaWNhdG9yJyxcbn1cblxuaW50ZXJmYWNlIFNlcnZlckVycm9yQWN0aW9uIHtcbiAgYWN0aW9uOiBITVJfQUNUSU9OU19TRU5UX1RPX0JST1dTRVIuU0VSVkVSX0VSUk9SXG4gIGVycm9ySlNPTjogc3RyaW5nXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHVyYm9wYWNrTWVzc2FnZUFjdGlvbiB7XG4gIGFjdGlvbjogSE1SX0FDVElPTlNfU0VOVF9UT19CUk9XU0VSLlRVUkJPUEFDS19NRVNTQUdFXG4gIGRhdGE6IFR1cmJvcGFja1VwZGF0ZSB8IFR1cmJvcGFja1VwZGF0ZVtdXG59XG5cbmludGVyZmFjZSBCdWlsZGluZ0FjdGlvbiB7XG4gIGFjdGlvbjogSE1SX0FDVElPTlNfU0VOVF9UT19CUk9XU0VSLkJVSUxESU5HXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29tcGlsYXRpb25FcnJvciB7XG4gIG1vZHVsZU5hbWU/OiBzdHJpbmdcbiAgbWVzc2FnZTogc3RyaW5nXG4gIGRldGFpbHM/OiBzdHJpbmdcbiAgbW9kdWxlVHJhY2U/OiBBcnJheTx7IG1vZHVsZU5hbWU/OiBzdHJpbmcgfT5cbiAgc3RhY2s/OiBzdHJpbmdcbn1cbmV4cG9ydCBpbnRlcmZhY2UgU3luY0FjdGlvbiB7XG4gIGFjdGlvbjogSE1SX0FDVElPTlNfU0VOVF9UT19CUk9XU0VSLlNZTkNcbiAgaGFzaDogc3RyaW5nXG4gIGVycm9yczogUmVhZG9ubHlBcnJheTxDb21waWxhdGlvbkVycm9yPlxuICB3YXJuaW5nczogUmVhZG9ubHlBcnJheTxDb21waWxhdGlvbkVycm9yPlxuICB2ZXJzaW9uSW5mbzogVmVyc2lvbkluZm9cbiAgdXBkYXRlZE1vZHVsZXM/OiBSZWFkb25seUFycmF5PHN0cmluZz5cbiAgZGVidWc/OiBEZWJ1Z0luZm9cbiAgZGV2SW5kaWNhdG9yOiBEZXZJbmRpY2F0b3JTZXJ2ZXJTdGF0ZVxufVxuaW50ZXJmYWNlIEJ1aWx0QWN0aW9uIHtcbiAgYWN0aW9uOiBITVJfQUNUSU9OU19TRU5UX1RPX0JST1dTRVIuQlVJTFRcbiAgaGFzaDogc3RyaW5nXG4gIGVycm9yczogUmVhZG9ubHlBcnJheTxDb21waWxhdGlvbkVycm9yPlxuICB3YXJuaW5nczogUmVhZG9ubHlBcnJheTxDb21waWxhdGlvbkVycm9yPlxuICB1cGRhdGVkTW9kdWxlcz86IFJlYWRvbmx5QXJyYXk8c3RyaW5nPlxufVxuXG5pbnRlcmZhY2UgQWRkZWRQYWdlQWN0aW9uIHtcbiAgYWN0aW9uOiBITVJfQUNUSU9OU19TRU5UX1RPX0JST1dTRVIuQURERURfUEFHRVxuICBkYXRhOiBbcGFnZTogc3RyaW5nIHwgbnVsbF1cbn1cblxuaW50ZXJmYWNlIFJlbW92ZWRQYWdlQWN0aW9uIHtcbiAgYWN0aW9uOiBITVJfQUNUSU9OU19TRU5UX1RPX0JST1dTRVIuUkVNT1ZFRF9QQUdFXG4gIGRhdGE6IFtwYWdlOiBzdHJpbmcgfCBudWxsXVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlbG9hZFBhZ2VBY3Rpb24ge1xuICBhY3Rpb246IEhNUl9BQ1RJT05TX1NFTlRfVE9fQlJPV1NFUi5SRUxPQURfUEFHRVxuICBkYXRhOiBzdHJpbmdcbn1cblxuaW50ZXJmYWNlIFNlcnZlckNvbXBvbmVudENoYW5nZXNBY3Rpb24ge1xuICBhY3Rpb246IEhNUl9BQ1RJT05TX1NFTlRfVE9fQlJPV1NFUi5TRVJWRVJfQ09NUE9ORU5UX0NIQU5HRVNcbiAgaGFzaDogc3RyaW5nXG59XG5cbmludGVyZmFjZSBNaWRkbGV3YXJlQ2hhbmdlc0FjdGlvbiB7XG4gIGV2ZW50OiBITVJfQUNUSU9OU19TRU5UX1RPX0JST1dTRVIuTUlERExFV0FSRV9DSEFOR0VTXG59XG5cbmludGVyZmFjZSBDbGllbnRDaGFuZ2VzQWN0aW9uIHtcbiAgZXZlbnQ6IEhNUl9BQ1RJT05TX1NFTlRfVE9fQlJPV1NFUi5DTElFTlRfQ0hBTkdFU1xufVxuXG5pbnRlcmZhY2UgU2VydmVyT25seUNoYW5nZXNBY3Rpb24ge1xuICBldmVudDogSE1SX0FDVElPTlNfU0VOVF9UT19CUk9XU0VSLlNFUlZFUl9PTkxZX0NIQU5HRVNcbiAgcGFnZXM6IFJlYWRvbmx5QXJyYXk8c3RyaW5nPlxufVxuXG5pbnRlcmZhY2UgRGV2UGFnZXNNYW5pZmVzdFVwZGF0ZUFjdGlvbiB7XG4gIGFjdGlvbjogSE1SX0FDVElPTlNfU0VOVF9UT19CUk9XU0VSLkRFVl9QQUdFU19NQU5JRkVTVF9VUERBVEVcbiAgZGF0YTogW1xuICAgIHtcbiAgICAgIGRldlBhZ2VzTWFuaWZlc3Q6IHRydWVcbiAgICB9LFxuICBdXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHVyYm9wYWNrQ29ubmVjdGVkQWN0aW9uIHtcbiAgYWN0aW9uOiBITVJfQUNUSU9OU19TRU5UX1RPX0JST1dTRVIuVFVSQk9QQUNLX0NPTk5FQ1RFRFxuICBkYXRhOiB7IHNlc3Npb25JZDogbnVtYmVyIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBBcHBJc3JNYW5pZmVzdEFjdGlvbiB7XG4gIGFjdGlvbjogSE1SX0FDVElPTlNfU0VOVF9UT19CUk9XU0VSLklTUl9NQU5JRkVTVFxuICBkYXRhOiBSZWNvcmQ8c3RyaW5nLCBib29sZWFuPlxufVxuXG5leHBvcnQgaW50ZXJmYWNlIERldkluZGljYXRvckFjdGlvbiB7XG4gIGFjdGlvbjogSE1SX0FDVElPTlNfU0VOVF9UT19CUk9XU0VSLkRFVl9JTkRJQ0FUT1JcbiAgZGV2SW5kaWNhdG9yOiBEZXZJbmRpY2F0b3JTZXJ2ZXJTdGF0ZVxufVxuXG5leHBvcnQgdHlwZSBITVJfQUNUSU9OX1RZUEVTID1cbiAgfCBUdXJib3BhY2tNZXNzYWdlQWN0aW9uXG4gIHwgVHVyYm9wYWNrQ29ubmVjdGVkQWN0aW9uXG4gIHwgQnVpbGRpbmdBY3Rpb25cbiAgfCBTeW5jQWN0aW9uXG4gIHwgQnVpbHRBY3Rpb25cbiAgfCBBZGRlZFBhZ2VBY3Rpb25cbiAgfCBSZW1vdmVkUGFnZUFjdGlvblxuICB8IFJlbG9hZFBhZ2VBY3Rpb25cbiAgfCBTZXJ2ZXJDb21wb25lbnRDaGFuZ2VzQWN0aW9uXG4gIHwgQ2xpZW50Q2hhbmdlc0FjdGlvblxuICB8IE1pZGRsZXdhcmVDaGFuZ2VzQWN0aW9uXG4gIHwgU2VydmVyT25seUNoYW5nZXNBY3Rpb25cbiAgfCBEZXZQYWdlc01hbmlmZXN0VXBkYXRlQWN0aW9uXG4gIHwgU2VydmVyRXJyb3JBY3Rpb25cbiAgfCBBcHBJc3JNYW5pZmVzdEFjdGlvblxuICB8IERldkluZGljYXRvckFjdGlvblxuXG5leHBvcnQgdHlwZSBUdXJib3BhY2tNc2dUb0Jyb3dzZXIgPVxuICB8IHsgdHlwZTogSE1SX0FDVElPTlNfU0VOVF9UT19CUk9XU0VSLlRVUkJPUEFDS19NRVNTQUdFOyBkYXRhOiBhbnkgfVxuICB8IHtcbiAgICAgIHR5cGU6IEhNUl9BQ1RJT05TX1NFTlRfVE9fQlJPV1NFUi5UVVJCT1BBQ0tfQ09OTkVDVEVEXG4gICAgICBkYXRhOiB7IHNlc3Npb25JZDogbnVtYmVyIH1cbiAgICB9XG5cbmV4cG9ydCBpbnRlcmZhY2UgTmV4dEpzSG90UmVsb2FkZXJJbnRlcmZhY2Uge1xuICB0dXJib3BhY2tQcm9qZWN0PzogUHJvamVjdFxuICBhY3RpdmVXZWJwYWNrQ29uZmlncz86IEFycmF5PEF3YWl0ZWQ8UmV0dXJuVHlwZTx0eXBlb2YgZ2V0QmFzZVdlYnBhY2tDb25maWc+Pj5cbiAgc2VydmVyU3RhdHM6IHdlYnBhY2suU3RhdHMgfCBudWxsXG4gIGVkZ2VTZXJ2ZXJTdGF0czogd2VicGFjay5TdGF0cyB8IG51bGxcbiAgcnVuKFxuICAgIHJlcTogSW5jb21pbmdNZXNzYWdlLFxuICAgIHJlczogU2VydmVyUmVzcG9uc2UsXG4gICAgcGFyc2VkVXJsOiBVcmxPYmplY3RcbiAgKTogUHJvbWlzZTx7IGZpbmlzaGVkPzogdHJ1ZSB9PlxuXG4gIHNldEhtclNlcnZlckVycm9yKGVycm9yOiBFcnJvciB8IG51bGwpOiB2b2lkXG4gIGNsZWFySG1yU2VydmVyRXJyb3IoKTogdm9pZFxuICBzdGFydCgpOiBQcm9taXNlPHZvaWQ+XG4gIHNlbmQoYWN0aW9uOiBITVJfQUNUSU9OX1RZUEVTKTogdm9pZFxuICBnZXRDb21waWxhdGlvbkVycm9ycyhwYWdlOiBzdHJpbmcpOiBQcm9taXNlPGFueVtdPlxuICBvbkhNUihcbiAgICByZXE6IEluY29taW5nTWVzc2FnZSxcbiAgICBfc29ja2V0OiBEdXBsZXgsXG4gICAgaGVhZDogQnVmZmVyLFxuICAgIG9uVXBncmFkZTogKGNsaWVudDogeyBzZW5kKGRhdGE6IHN0cmluZyk6IHZvaWQgfSkgPT4gdm9pZFxuICApOiB2b2lkXG4gIGludmFsaWRhdGUoe1xuICAgIHJlbG9hZEFmdGVySW52YWxpZGF0aW9uLFxuICB9OiB7XG4gICAgcmVsb2FkQWZ0ZXJJbnZhbGlkYXRpb246IGJvb2xlYW5cbiAgfSk6IFByb21pc2U8dm9pZD4gfCB2b2lkXG4gIGJ1aWxkRmFsbGJhY2tFcnJvcigpOiBQcm9taXNlPHZvaWQ+XG4gIGVuc3VyZVBhZ2Uoe1xuICAgIHBhZ2UsXG4gICAgY2xpZW50T25seSxcbiAgICBhcHBQYXRocyxcbiAgICBkZWZpbml0aW9uLFxuICAgIGlzQXBwLFxuICAgIHVybCxcbiAgfToge1xuICAgIHBhZ2U6IHN0cmluZ1xuICAgIGNsaWVudE9ubHk6IGJvb2xlYW5cbiAgICBhcHBQYXRocz86IFJlYWRvbmx5QXJyYXk8c3RyaW5nPiB8IG51bGxcbiAgICBpc0FwcD86IGJvb2xlYW5cbiAgICBkZWZpbml0aW9uOiBSb3V0ZURlZmluaXRpb24gfCB1bmRlZmluZWRcbiAgICB1cmw/OiBzdHJpbmdcbiAgfSk6IFByb21pc2U8dm9pZD5cbiAgY2xvc2UoKTogdm9pZFxufVxuIl0sIm5hbWVzIjpbIkhNUl9BQ1RJT05TX1NFTlRfVE9fQlJPV1NFUiJdLCJtYXBwaW5ncyI6Ijs7OytCQVdrQkEsK0JBQUFBOzs7ZUFBQUE7OztBQUFYLElBQVdBLDhCQUFBQSxXQUFBQSxHQUFBQSxTQUFBQSwyQkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7O1dBQUFBIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDE3NjIsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvc2VydmVyL2Rldi9ub2RlLXN0YWNrLWZyYW1lcy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwYXJzZSB9IGZyb20gJ25leHQvZGlzdC9jb21waWxlZC9zdGFja3RyYWNlLXBhcnNlcidcbmltcG9ydCB0eXBlIHsgU3RhY2tGcmFtZSB9IGZyb20gJ25leHQvZGlzdC9jb21waWxlZC9zdGFja3RyYWNlLXBhcnNlcidcbmltcG9ydCB7XG4gIGRlY29yYXRlU2VydmVyRXJyb3IsXG4gIHR5cGUgRXJyb3JTb3VyY2VUeXBlLFxufSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL2Vycm9yLXNvdXJjZSdcblxuZnVuY3Rpb24gZ2V0RmlsZXN5c3RlbUZyYW1lKGZyYW1lOiBTdGFja0ZyYW1lKTogU3RhY2tGcmFtZSB7XG4gIGNvbnN0IGY6IFN0YWNrRnJhbWUgPSB7IC4uLmZyYW1lIH1cblxuICBpZiAodHlwZW9mIGYuZmlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoXG4gICAgICAvLyBQb3NpeDpcbiAgICAgIGYuZmlsZS5zdGFydHNXaXRoKCcvJykgfHxcbiAgICAgIC8vIFdpbjMyOlxuICAgICAgL15bYS16XTpcXFxcL2kudGVzdChmLmZpbGUpIHx8XG4gICAgICAvLyBXaW4zMiBVTkM6XG4gICAgICBmLmZpbGUuc3RhcnRzV2l0aCgnXFxcXFxcXFwnKVxuICAgICkge1xuICAgICAgZi5maWxlID0gYGZpbGU6Ly8ke2YuZmlsZX1gXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNlcnZlckVycm9yKGVycm9yOiBFcnJvciwgdHlwZTogRXJyb3JTb3VyY2VUeXBlKTogRXJyb3Ige1xuICBpZiAoZXJyb3IubmFtZSA9PT0gJ1R1cmJvcGFja0ludGVybmFsRXJyb3InKSB7XG4gICAgLy8gSWYgdGhpcyBpcyBhbiBpbnRlcm5hbCBUdXJib3BhY2sgZXJyb3Igd2Ugc2hvdWxkbid0IHNob3cgaW50ZXJuYWwgZGV0YWlsc1xuICAgIC8vIHRvIHRoZSB1c2VyLiBUaGVzZSBhcmUgd3JpdHRlbiB0byBhIGxvZyBmaWxlIGluc3RlYWQuXG4gICAgY29uc3QgdHVyYm9wYWNrSW50ZXJuYWxFcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICdBbiB1bmV4cGVjdGVkIFR1cmJvcGFjayBlcnJvciBvY2N1cnJlZC4gUGxlYXNlIHNlZSB0aGUgb3V0cHV0IG9mIGBuZXh0IGRldmAgZm9yIG1vcmUgZGV0YWlscy4nXG4gICAgKVxuICAgIGRlY29yYXRlU2VydmVyRXJyb3IodHVyYm9wYWNrSW50ZXJuYWxFcnJvciwgdHlwZSlcbiAgICByZXR1cm4gdHVyYm9wYWNrSW50ZXJuYWxFcnJvclxuICB9XG5cbiAgbGV0IG46IEVycm9yXG4gIHRyeSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGVycm9yLm1lc3NhZ2UpXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBuID0gZSBhcyBFcnJvclxuICB9XG5cbiAgbi5uYW1lID0gZXJyb3IubmFtZVxuICB0cnkge1xuICAgIG4uc3RhY2sgPSBgJHtuLnRvU3RyaW5nKCl9XFxuJHtwYXJzZShlcnJvci5zdGFjayEpXG4gICAgICAubWFwKGdldEZpbGVzeXN0ZW1GcmFtZSlcbiAgICAgIC5tYXAoKGYpID0+IHtcbiAgICAgICAgbGV0IHN0ciA9IGAgICAgYXQgJHtmLm1ldGhvZE5hbWV9YFxuICAgICAgICBpZiAoZi5maWxlKSB7XG4gICAgICAgICAgbGV0IGxvYyA9IGYuZmlsZVxuICAgICAgICAgIGlmIChmLmxpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgIGxvYyArPSBgOiR7Zi5saW5lTnVtYmVyfWBcbiAgICAgICAgICAgIGlmIChmLmNvbHVtbikge1xuICAgICAgICAgICAgICBsb2MgKz0gYDoke2YuY29sdW1ufWBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgc3RyICs9IGAgKCR7bG9jfSlgXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0clxuICAgICAgfSlcbiAgICAgIC5qb2luKCdcXG4nKX1gXG4gIH0gY2F0Y2gge1xuICAgIG4uc3RhY2sgPSBlcnJvci5zdGFja1xuICB9XG5cbiAgZGVjb3JhdGVTZXJ2ZXJFcnJvcihuLCB0eXBlKVxuICByZXR1cm4gblxufVxuIl0sIm5hbWVzIjpbImdldFNlcnZlckVycm9yIiwiZ2V0RmlsZXN5c3RlbUZyYW1lIiwiZnJhbWUiLCJmIiwiZmlsZSIsInN0YXJ0c1dpdGgiLCJ0ZXN0IiwiZXJyb3IiLCJ0eXBlIiwibmFtZSIsInR1cmJvcGFja0ludGVybmFsRXJyb3IiLCJFcnJvciIsImRlY29yYXRlU2VydmVyRXJyb3IiLCJuIiwibWVzc2FnZSIsImUiLCJzdGFjayIsInRvU3RyaW5nIiwicGFyc2UiLCJtYXAiLCJzdHIiLCJtZXRob2ROYW1lIiwibG9jIiwibGluZU51bWJlciIsImNvbHVtbiIsImpvaW4iXSwibWFwcGluZ3MiOiI7OzsrQkEwQmdCQSxrQkFBQUE7OztlQUFBQTs7O2tDQTFCTTs2QkFLZjtBQUVQLFNBQVNDLG1CQUFtQkMsS0FBaUI7SUFDM0MsTUFBTUMsSUFBZ0I7UUFBRSxHQUFHRCxLQUFLO0lBQUM7SUFFakMsSUFBSSxPQUFPQyxFQUFFQyxJQUFJLEtBQUssVUFBVTtRQUM5QixJQUNFLEFBQ0FELEVBQUVDLElBQUksQ0FBQ0MsRUFERSxRQUNRLENBQUMsUUFDbEIsU0FBUztRQUNULGFBQWFDLElBQUksQ0FBQ0gsRUFBRUMsSUFBSSxLQUN4QixhQUFhO1FBQ2JELEVBQUVDLElBQUksQ0FBQ0MsVUFBVSxDQUFDLFNBQ2xCO1lBQ0FGLEVBQUVDLElBQUksR0FBRyxBQUFDLE9BQU8sR0FBUSxDQUFFLE1BQVJELEVBQUVDLElBQUk7UUFDM0I7SUFDRjtJQUVBLE9BQU9EO0FBQ1Q7QUFFTyxTQUFTSCxlQUFlTyxLQUFZLEVBQUVDLElBQXFCO0lBQ2hFLElBQUlELE1BQU1FLElBQUksS0FBSywwQkFBMEI7UUFDM0MsNEVBQTRFO1FBQzVFLHdEQUF3RDtRQUN4RCxNQUFNQyx5QkFBeUIsT0FBQSxjQUU5QixDQUY4QixJQUFJQyxNQUNqQyxrR0FENkIscUJBQUE7bUJBQUE7d0JBQUE7MEJBQUE7UUFFL0I7UUFDQUMsQ0FBQUEsR0FBQUEsYUFBQUEsbUJBQW1CLEVBQUNGLHdCQUF3QkY7UUFDNUMsT0FBT0U7SUFDVDtJQUVBLElBQUlHO0lBQ0osSUFBSTtRQUNGLE1BQU0sT0FBQSxjQUF3QixDQUF4QixJQUFJRixNQUFNSixNQUFNTyxPQUFPLEdBQXZCLHFCQUFBO21CQUFBO3dCQUFBOzBCQUFBO1FBQXVCO0lBQy9CLEVBQUUsT0FBT0MsR0FBRztRQUNWRixJQUFJRTtJQUNOO0lBRUFGLEVBQUVKLElBQUksR0FBR0YsTUFBTUUsSUFBSTtJQUNuQixJQUFJO1FBQ0ZJLEVBQUVHLEtBQUssR0FBRyxVQUFHSCxFQUFFSSxRQUFRLElBQUcsRUFBRSxJQWdCcEIsQ0FBTyxNQWhCZUMsQ0FBQUEsR0FBQUEsa0JBQUFBLEtBQUssRUFBQ1gsTUFBTVMsS0FBSyxFQUM1Q0csR0FBRyxDQUFDbEIsb0JBQ0prQixHQUFHLENBQUMsQ0FBQ2hCO1lBQ0osSUFBSWlCLE1BQU0sQUFBQyxPQUFPLEdBQWMsQ0FBRSxNQUFkakIsRUFBRWtCLFVBQVU7WUFDaEMsSUFBSWxCLEVBQUVDLElBQUksRUFBRTtnQkFDVixJQUFJa0IsTUFBTW5CLEVBQUVDLElBQUk7Z0JBQ2hCLElBQUlELEVBQUVvQixVQUFVLEVBQUU7b0JBQ2hCRCxPQUFPLEFBQUMsQ0FBQyxHQUFjLENBQUUsTUFBZG5CLEVBQUVvQixVQUFVO29CQUN2QixJQUFJcEIsRUFBRXFCLE1BQU0sRUFBRTt3QkFDWkYsT0FBTyxBQUFDLENBQUMsR0FBVSxDQUFFLE1BQVZuQixFQUFFcUIsTUFBTTtvQkFDckI7Z0JBQ0Y7Z0JBQ0FKLE9BQU8sQUFBQyxFQUFFLFVBQUVFLEtBQUksQ0FBQyxDQUFDO1lBQ3BCO1lBQ0EsT0FBT0Y7UUFDVCxHQUNDSyxJQUFJLENBQUM7SUFDVixFQUFFLFVBQU07UUFDTlosRUFBRUcsS0FBSyxHQUFHVCxNQUFNUyxLQUFLO0lBQ3ZCO0lBRUFKLENBQUFBLEdBQUFBLGFBQUFBLG1CQUFtQixFQUFDQyxHQUFHTDtJQUN2QixPQUFPSztBQUNUIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDE4MzYsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvc2VydmVyL3JlcXVlc3QtbWV0YS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBuby1yZWRlY2xhcmUgKi9cbmltcG9ydCB0eXBlIHsgSW5jb21pbmdNZXNzYWdlIH0gZnJvbSAnaHR0cCdcbmltcG9ydCB0eXBlIHsgUGFyc2VkVXJsUXVlcnkgfSBmcm9tICdxdWVyeXN0cmluZydcbmltcG9ydCB0eXBlIHsgVXJsV2l0aFBhcnNlZFF1ZXJ5IH0gZnJvbSAndXJsJ1xuaW1wb3J0IHR5cGUgeyBCYXNlTmV4dFJlcXVlc3QgfSBmcm9tICcuL2Jhc2UtaHR0cCdcbmltcG9ydCB0eXBlIHsgQ2xvbmVhYmxlQm9keSB9IGZyb20gJy4vYm9keS1zdHJlYW1zJ1xuaW1wb3J0IHR5cGUgeyBSb3V0ZU1hdGNoIH0gZnJvbSAnLi9yb3V0ZS1tYXRjaGVzL3JvdXRlLW1hdGNoJ1xuaW1wb3J0IHR5cGUgeyBORVhUX1JTQ19VTklPTl9RVUVSWSB9IGZyb20gJy4uL2NsaWVudC9jb21wb25lbnRzL2FwcC1yb3V0ZXItaGVhZGVycydcbmltcG9ydCB0eXBlIHsgU2VydmVyQ29tcG9uZW50c0htckNhY2hlIH0gZnJvbSAnLi9yZXNwb25zZS1jYWNoZSdcbmltcG9ydCB0eXBlIHsgUGFnZXNEZXZPdmVybGF5QnJpZGdlVHlwZSB9IGZyb20gJy4uL25leHQtZGV2dG9vbHMvdXNlcnNwYWNlL3BhZ2VzL3BhZ2VzLWRldi1vdmVybGF5LXNldHVwJ1xuXG4vLyBGSVhNRTogKHd5YXR0am9oKSB0aGlzIGlzIGEgdGVtcG9yYXJ5IHNvbHV0aW9uIHRvIGFsbG93IHVzIHRvIHBhc3MgZGF0YSBiZXR3ZWVuIGJ1bmRsZWQgbW9kdWxlc1xuZXhwb3J0IGNvbnN0IE5FWFRfUkVRVUVTVF9NRVRBID0gU3ltYm9sLmZvcignTmV4dEludGVybmFsUmVxdWVzdE1ldGEnKVxuXG5leHBvcnQgdHlwZSBOZXh0SW5jb21pbmdNZXNzYWdlID0gKEJhc2VOZXh0UmVxdWVzdCB8IEluY29taW5nTWVzc2FnZSkgJiB7XG4gIFtORVhUX1JFUVVFU1RfTUVUQV0/OiBSZXF1ZXN0TWV0YVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlcXVlc3RNZXRhIHtcbiAgLyoqXG4gICAqIFRoZSBxdWVyeSB0aGF0IHdhcyB1c2VkIHRvIG1ha2UgdGhlIHJlcXVlc3QuXG4gICAqL1xuICBpbml0UXVlcnk/OiBQYXJzZWRVcmxRdWVyeVxuXG4gIC8qKlxuICAgKiBUaGUgVVJMIHRoYXQgd2FzIHVzZWQgdG8gbWFrZSB0aGUgcmVxdWVzdC5cbiAgICovXG4gIGluaXRVUkw/OiBzdHJpbmdcblxuICAvKipcbiAgICogVGhlIHByb3RvY29sIHRoYXQgd2FzIHVzZWQgdG8gbWFrZSB0aGUgcmVxdWVzdC5cbiAgICovXG4gIGluaXRQcm90b2NvbD86IHN0cmluZ1xuXG4gIC8qKlxuICAgKiBUaGUgYm9keSB0aGF0IHdhcyByZWFkIGZyb20gdGhlIHJlcXVlc3QuIFRoaXMgaXMgdXNlZCB0byBhbGxvdyB0aGUgYm9keSB0b1xuICAgKiBiZSByZWFkIG11bHRpcGxlIHRpbWVzLlxuICAgKi9cbiAgY2xvbmFibGVCb2R5PzogQ2xvbmVhYmxlQm9keVxuXG4gIC8qKlxuICAgKiBUcnVlIHdoZW4gdGhlIHJlcXVlc3QgbWF0Y2hlZCBhIGxvY2FsZSBkb21haW4gdGhhdCB3YXMgY29uZmlndXJlZCBpbiB0aGVcbiAgICogbmV4dC5jb25maWcuanMgZmlsZS5cbiAgICovXG4gIGlzTG9jYWxlRG9tYWluPzogYm9vbGVhblxuXG4gIC8qKlxuICAgKiBUcnVlIHdoZW4gdGhlIHJlcXVlc3QgaGFkIGxvY2FsZSBpbmZvcm1hdGlvbiBzdHJpcHBlZCBmcm9tIHRoZSBwYXRobmFtZVxuICAgKiBwYXJ0IG9mIHRoZSBVUkwuXG4gICAqL1xuICBkaWRTdHJpcExvY2FsZT86IGJvb2xlYW5cblxuICAvKipcbiAgICogSWYgdGhlIHJlcXVlc3QgaGFkIGl0J3MgVVJMIHJld3JpdHRlbiwgdGhpcyBpcyB0aGUgVVJMIGl0IHdhcyByZXdyaXR0ZW4gdG8uXG4gICAqL1xuICByZXdyb3RlVVJMPzogc3RyaW5nXG5cbiAgLyoqXG4gICAqIFRoZSBjb29raWVzIHRoYXQgd2VyZSBhZGRlZCBieSBtaWRkbGV3YXJlIGFuZCB3ZXJlIGFkZGVkIHRvIHRoZSByZXNwb25zZS5cbiAgICovXG4gIG1pZGRsZXdhcmVDb29raWU/OiBzdHJpbmdbXVxuXG4gIC8qKlxuICAgKiBUaGUgbWF0Y2ggb24gdGhlIHJlcXVlc3QgZm9yIGEgZ2l2ZW4gcm91dGUuXG4gICAqL1xuICBtYXRjaD86IFJvdXRlTWF0Y2hcblxuICAvKipcbiAgICogVGhlIGluY3JlbWVudGFsIGNhY2hlIHRvIHVzZSBmb3IgdGhlIHJlcXVlc3QuXG4gICAqL1xuICBpbmNyZW1lbnRhbENhY2hlPzogYW55XG5cbiAgLyoqXG4gICAqIFRoZSBzZXJ2ZXIgY29tcG9uZW50cyBITVIgY2FjaGUsIG9ubHkgZm9yIGRldi5cbiAgICovXG4gIHNlcnZlckNvbXBvbmVudHNIbXJDYWNoZT86IFNlcnZlckNvbXBvbmVudHNIbXJDYWNoZVxuXG4gIC8qKlxuICAgKiBFcXVhbHMgdGhlIHNlZ21lbnQgcGF0aCB0aGF0IHdhcyB1c2VkIGZvciB0aGUgcHJlZmV0Y2ggUlNDIHJlcXVlc3QuXG4gICAqL1xuICBzZWdtZW50UHJlZmV0Y2hSU0NSZXF1ZXN0Pzogc3RyaW5nXG5cbiAgLyoqXG4gICAqIFRydWUgd2hlbiB0aGUgcmVxdWVzdCBpcyBmb3IgdGhlIHByZWZldGNoIGZsaWdodCBkYXRhLlxuICAgKi9cbiAgaXNQcmVmZXRjaFJTQ1JlcXVlc3Q/OiB0cnVlXG5cbiAgLyoqXG4gICAqIFRydWUgd2hlbiB0aGUgcmVxdWVzdCBpcyBmb3IgdGhlIGZsaWdodCBkYXRhLlxuICAgKi9cbiAgaXNSU0NSZXF1ZXN0PzogdHJ1ZVxuXG4gIC8qKlxuICAgKiBBIHNlYXJjaCBwYXJhbSBzZXQgYnkgdGhlIE5leHQuanMgY2xpZW50IHdoZW4gcGVyZm9ybWluZyBSU0MgcmVxdWVzdHMuXG4gICAqIEJlY2F1c2Ugc29tZSBDRE5zIGRvIG5vdCB2YXJ5IHRoZWlyIGNhY2hlIGVudHJpZXMgb24gb3VyIGN1c3RvbSBoZWFkZXJzLFxuICAgKiB0aGlzIHNlYXJjaCBwYXJhbSByZXByZXNlbnRzIGEgaGFzaCBvZiB0aGUgaGVhZGVyIHZhbHVlcy4gRm9yIGFueSBjYWNoZWRcbiAgICogUlNDIHJlcXVlc3QsIHdlIHNob3VsZCB2ZXJpZnkgdGhhdCB0aGUgaGFzaCBtYXRjaGVzIGJlZm9yZSByZXNwb25kaW5nLlxuICAgKiBPdGhlcndpc2UgdGhpcyBjYW4gbGVhZCB0byBjYWNoZSBwb2lzb25pbmcuXG4gICAqIFRPRE86IENvbnNpZGVyIG5vdCB1c2luZyBjdXN0b20gcmVxdWVzdCBoZWFkZXJzIGF0IGFsbCwgYW5kIGluc3RlYWQgZW5jb2RlXG4gICAqIGV2ZXJ5dGhpbmcgaW50byB0aGUgc2VhcmNoIHBhcmFtLlxuICAgKi9cbiAgY2FjaGVCdXN0aW5nU2VhcmNoUGFyYW0/OiBzdHJpbmdcblxuICAvKipcbiAgICogVHJ1ZSB3aGVuIHRoZSByZXF1ZXN0IGlzIGZvciB0aGUgYC9fbmV4dC9kYXRhYCByb3V0ZSB1c2luZyB0aGUgcGFnZXNcbiAgICogcm91dGVyLlxuICAgKi9cbiAgaXNOZXh0RGF0YVJlcT86IHRydWVcblxuICAvKipcbiAgICogUG9zdHBvbmVkIHN0YXRlIHRvIHVzZSBmb3IgcmVzdW1wdGlvbi4gSWYgcHJlc2VudCBpdCdzIGFzc3VtZWQgdGhhdCB0aGVcbiAgICogcmVxdWVzdCBpcyBmb3IgYSBwYWdlIHRoYXQgaGFzIHBvc3Rwb25lZCAodGhlcmUgYXJlIG5vIGd1YXJhbnRlZXMgdGhhdCB0aGVcbiAgICogcGFnZSBhY3R1YWxseSBoYXMgcG9zdHBvbmVkIHRob3VnaCBhcyBpdCB3b3VsZCBpbmN1ciBhbiBhZGRpdGlvbmFsIGNhY2hlXG4gICAqIGxvb2t1cCkuXG4gICAqL1xuICBwb3N0cG9uZWQ/OiBzdHJpbmdcblxuICAvKipcbiAgICogSWYgcHJvdmlkZWQsIHRoaXMgd2lsbCBiZSBjYWxsZWQgd2hlbiBhIHJlc3BvbnNlIGNhY2hlIGVudHJ5IHdhcyBnZW5lcmF0ZWRcbiAgICogb3IgbG9va2VkIHVwIGluIHRoZSBjYWNoZS5cbiAgICovXG4gIG9uQ2FjaGVFbnRyeT86IChcbiAgICBjYWNoZUVudHJ5OiBhbnksXG4gICAgcmVxdWVzdE1ldGE6IGFueVxuICApID0+IFByb21pc2U8Ym9vbGVhbiB8IHZvaWQ+IHwgYm9vbGVhbiB8IHZvaWRcblxuICAvKipcbiAgICogVGhlIHByZXZpb3VzIHJldmFsaWRhdGUgYmVmb3JlIHJlbmRlcmluZyA0MDQgcGFnZSBmb3Igbm90Rm91bmQ6IHRydWVcbiAgICovXG4gIG5vdEZvdW5kUmV2YWxpZGF0ZT86IG51bWJlciB8IGZhbHNlXG5cbiAgLyoqXG4gICAqIEluIGRldmVsb3BtZW50LCB0aGUgb3JpZ2luYWwgc291cmNlIHBhZ2UgdGhhdCByZXR1cm5lZCBhIDQwNC5cbiAgICovXG4gIGRldmVsb3BtZW50Tm90Rm91bmRTb3VyY2VQYWdlPzogc3RyaW5nXG5cbiAgLyoqXG4gICAqIFRoZSBwYXRoIHdlIHJvdXRlZCB0byBhbmQgc2hvdWxkIGJlIGludm9rZWRcbiAgICovXG4gIGludm9rZVBhdGg/OiBzdHJpbmdcblxuICAvKipcbiAgICogVGhlIHNwZWNpZmljIHBhZ2Ugb3V0cHV0IHdlIHNob3VsZCBiZSBtYXRjaGluZ1xuICAgKi9cbiAgaW52b2tlT3V0cHV0Pzogc3RyaW5nXG5cbiAgLyoqXG4gICAqIFRoZSBzdGF0dXMgd2UgYXJlIGludm9raW5nIHRoZSByZXF1ZXN0IHdpdGggZnJvbSByb3V0aW5nXG4gICAqL1xuICBpbnZva2VTdGF0dXM/OiBudW1iZXJcblxuICAvKipcbiAgICogVGhlIHJvdXRpbmcgZXJyb3Igd2UgYXJlIGludm9raW5nIHdpdGhcbiAgICovXG4gIGludm9rZUVycm9yPzogRXJyb3JcblxuICAvKipcbiAgICogVGhlIHF1ZXJ5IHBhcnNlZCBmb3IgdGhlIGludm9jYXRpb25cbiAgICovXG4gIGludm9rZVF1ZXJ5PzogUmVjb3JkPHN0cmluZywgdW5kZWZpbmVkIHwgc3RyaW5nIHwgc3RyaW5nW10+XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIHJlcXVlc3QgaXMgYSBtaWRkbGV3YXJlIGludm9jYXRpb25cbiAgICovXG4gIG1pZGRsZXdhcmVJbnZva2U/OiBib29sZWFuXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIHJlcXVlc3Qgc2hvdWxkIHJlbmRlciB0aGUgZmFsbGJhY2sgc2hlbGwgb3Igbm90LlxuICAgKi9cbiAgcmVuZGVyRmFsbGJhY2tTaGVsbD86IGJvb2xlYW5cblxuICAvKipcbiAgICogV2hldGhlciB0aGUgcmVxdWVzdCBpcyBmb3IgdGhlIGN1c3RvbSBlcnJvciBwYWdlLlxuICAgKi9cbiAgY3VzdG9tRXJyb3JSZW5kZXI/OiB0cnVlXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gYnViYmxlIHVwIHRoZSBOb0ZhbGxiYWNrRXJyb3IgdG8gdGhlIGNhbGxlciB3aGVuIGEgNDA0IGlzXG4gICAqIHJldHVybmVkLlxuICAgKi9cbiAgYnViYmxlTm9GYWxsYmFjaz86IHRydWVcblxuICAvKipcbiAgICogVHJ1ZSB3aGVuIHRoZSByZXF1ZXN0IGhhZCBsb2NhbGUgaW5mb3JtYXRpb24gaW5mZXJyZWQgZnJvbSB0aGUgZGVmYXVsdFxuICAgKiBsb2NhbGUuXG4gICAqL1xuICBsb2NhbGVJbmZlcnJlZEZyb21EZWZhdWx0PzogdHJ1ZVxuXG4gIC8qKlxuICAgKiBUaGUgbG9jYWxlIHRoYXQgd2FzIGluZmVycmVkIG9yIGV4cGxpY2l0bHkgc2V0IGZvciB0aGUgcmVxdWVzdC5cbiAgICovXG4gIGxvY2FsZT86IHN0cmluZ1xuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBsb2NhbGUgdGhhdCB3YXMgaW5mZXJyZWQgb3IgZXhwbGljaXRseSBzZXQgZm9yIHRoZSByZXF1ZXN0LlxuICAgKi9cbiAgZGVmYXVsdExvY2FsZT86IHN0cmluZ1xuXG4gIC8qKlxuICAgKiBUaGUgcHJvamVjdCBkaXIgdGhlIHNlcnZlciBpcyBydW5uaW5nIGluXG4gICAqL1xuICBwcm9qZWN0RGlyPzogc3RyaW5nXG5cbiAgLyoqXG4gICAqIFRoZSBkaXN0IGRpcmVjdG9yeSB0aGUgc2VydmVyIGlzIGN1cnJlbnRseSB1c2luZ1xuICAgKi9cbiAgZGlzdERpcj86IHN0cmluZ1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHdlIGFyZSBnZW5lcmF0aW5nIHRoZSBmYWxsYmFjayB2ZXJzaW9uIG9mIHRoZSBwYWdlIGluIGRldiBtb2RlXG4gICAqL1xuICBpc0lzckZhbGxiYWNrPzogYm9vbGVhblxuXG4gIC8qKlxuICAgKiBUaGUgcXVlcnkgYWZ0ZXIgcmVzb2x2aW5nIHJvdXRlc1xuICAgKi9cbiAgcXVlcnk/OiBQYXJzZWRVcmxRdWVyeVxuXG4gIC8qKlxuICAgKiBUaGUgcGFyYW1zIGFmdGVyIHJlc29sdmluZyByb3V0ZXNcbiAgICovXG4gIHBhcmFtcz86IFBhcnNlZFVybFF1ZXJ5XG5cbiAgLyoqXG4gICAqIFRoZSBBTVAgdmFsaWRhdG9yIHRvIHVzZSBpbiBkZXZlbG9wbWVudFxuICAgKi9cbiAgYW1wVmFsaWRhdG9yPzogKGh0bWw6IHN0cmluZywgcGF0aG5hbWU6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPlxuXG4gIC8qKlxuICAgKiBFcnJvck92ZXJsYXkgY29tcG9uZW50IHRvIHVzZSBpbiBkZXZlbG9wbWVudCBmb3IgcGFnZXMgcm91dGVyXG4gICAqL1xuICBQYWdlc0Vycm9yRGVidWc/OiBQYWdlc0Rldk92ZXJsYXlCcmlkZ2VUeXBlXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgc2VydmVyIGlzIGluIG1pbmltYWwgbW9kZSAodGhpcyB3aWxsIGJlIHJlcGxhY2VkIHdpdGggbW9yZVxuICAgKiBzcGVjaWZpYyBmbGFncyBpbiBmdXR1cmUpXG4gICAqL1xuICBtaW5pbWFsTW9kZT86IGJvb2xlYW5cbn1cblxuLyoqXG4gKiBHZXRzIHRoZSByZXF1ZXN0IG1ldGFkYXRhLiBJZiBubyBrZXkgaXMgcHJvdmlkZWQsIHRoZSBlbnRpcmUgbWV0YWRhdGEgb2JqZWN0XG4gKiBpcyByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0gcmVxIHRoZSByZXF1ZXN0IHRvIGdldCB0aGUgbWV0YWRhdGEgZnJvbVxuICogQHBhcmFtIGtleSB0aGUga2V5IHRvIGdldCBmcm9tIHRoZSBtZXRhZGF0YSAob3B0aW9uYWwpXG4gKiBAcmV0dXJucyB0aGUgdmFsdWUgZm9yIHRoZSBrZXkgb3IgdGhlIGVudGlyZSBtZXRhZGF0YSBvYmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFJlcXVlc3RNZXRhKFxuICByZXE6IE5leHRJbmNvbWluZ01lc3NhZ2UsXG4gIGtleT86IHVuZGVmaW5lZFxuKTogUmVxdWVzdE1ldGFcbmV4cG9ydCBmdW5jdGlvbiBnZXRSZXF1ZXN0TWV0YTxLIGV4dGVuZHMga2V5b2YgUmVxdWVzdE1ldGE+KFxuICByZXE6IE5leHRJbmNvbWluZ01lc3NhZ2UsXG4gIGtleTogS1xuKTogUmVxdWVzdE1ldGFbS11cbmV4cG9ydCBmdW5jdGlvbiBnZXRSZXF1ZXN0TWV0YTxLIGV4dGVuZHMga2V5b2YgUmVxdWVzdE1ldGE+KFxuICByZXE6IE5leHRJbmNvbWluZ01lc3NhZ2UsXG4gIGtleT86IEtcbik6IFJlcXVlc3RNZXRhIHwgUmVxdWVzdE1ldGFbS10ge1xuICBjb25zdCBtZXRhID0gcmVxW05FWFRfUkVRVUVTVF9NRVRBXSB8fCB7fVxuICByZXR1cm4gdHlwZW9mIGtleSA9PT0gJ3N0cmluZycgPyBtZXRhW2tleV0gOiBtZXRhXG59XG5cbi8qKlxuICogU2V0cyB0aGUgcmVxdWVzdCBtZXRhZGF0YS5cbiAqXG4gKiBAcGFyYW0gcmVxIHRoZSByZXF1ZXN0IHRvIHNldCB0aGUgbWV0YWRhdGEgb25cbiAqIEBwYXJhbSBtZXRhIHRoZSBtZXRhZGF0YSB0byBzZXRcbiAqIEByZXR1cm5zIHRoZSBtdXRhdGVkIHJlcXVlc3QgbWV0YWRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldFJlcXVlc3RNZXRhKHJlcTogTmV4dEluY29taW5nTWVzc2FnZSwgbWV0YTogUmVxdWVzdE1ldGEpIHtcbiAgcmVxW05FWFRfUkVRVUVTVF9NRVRBXSA9IG1ldGFcbiAgcmV0dXJuIG1ldGFcbn1cblxuLyoqXG4gKiBBZGRzIGEgdmFsdWUgdG8gdGhlIHJlcXVlc3QgbWV0YWRhdGEuXG4gKlxuICogQHBhcmFtIHJlcXVlc3QgdGhlIHJlcXVlc3QgdG8gbXV0YXRlXG4gKiBAcGFyYW0ga2V5IHRoZSBrZXkgdG8gc2V0XG4gKiBAcGFyYW0gdmFsdWUgdGhlIHZhbHVlIHRvIHNldFxuICogQHJldHVybnMgdGhlIG11dGF0ZWQgcmVxdWVzdCBtZXRhZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkUmVxdWVzdE1ldGE8SyBleHRlbmRzIGtleW9mIFJlcXVlc3RNZXRhPihcbiAgcmVxdWVzdDogTmV4dEluY29taW5nTWVzc2FnZSxcbiAga2V5OiBLLFxuICB2YWx1ZTogUmVxdWVzdE1ldGFbS11cbikge1xuICBjb25zdCBtZXRhID0gZ2V0UmVxdWVzdE1ldGEocmVxdWVzdClcbiAgbWV0YVtrZXldID0gdmFsdWVcbiAgcmV0dXJuIHNldFJlcXVlc3RNZXRhKHJlcXVlc3QsIG1ldGEpXG59XG5cbi8qKlxuICogUmVtb3ZlcyBhIGtleSBmcm9tIHRoZSByZXF1ZXN0IG1ldGFkYXRhLlxuICpcbiAqIEBwYXJhbSByZXF1ZXN0IHRoZSByZXF1ZXN0IHRvIG11dGF0ZVxuICogQHBhcmFtIGtleSB0aGUga2V5IHRvIHJlbW92ZVxuICogQHJldHVybnMgdGhlIG11dGF0ZWQgcmVxdWVzdCBtZXRhZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlUmVxdWVzdE1ldGE8SyBleHRlbmRzIGtleW9mIFJlcXVlc3RNZXRhPihcbiAgcmVxdWVzdDogTmV4dEluY29taW5nTWVzc2FnZSxcbiAga2V5OiBLXG4pIHtcbiAgY29uc3QgbWV0YSA9IGdldFJlcXVlc3RNZXRhKHJlcXVlc3QpXG4gIGRlbGV0ZSBtZXRhW2tleV1cbiAgcmV0dXJuIHNldFJlcXVlc3RNZXRhKHJlcXVlc3QsIG1ldGEpXG59XG5cbnR5cGUgTmV4dFF1ZXJ5TWV0YWRhdGEgPSB7XG4gIC8qKlxuICAgKiBUaGUgYF9yc2NgIHF1ZXJ5IHBhcmFtZXRlciB1c2VkIGZvciBjYWNoZSBidXN0aW5nIHRvIGVuc3VyZSB0aGF0IHRoZSBSU0NcbiAgICogcmVxdWVzdHMgZG8gbm90IGdldCBjYWNoZWQgYnkgdGhlIGJyb3dzZXIgZXhwbGljaXRseS5cbiAgICovXG4gIFtORVhUX1JTQ19VTklPTl9RVUVSWV0/OiBzdHJpbmdcbn1cblxuZXhwb3J0IHR5cGUgTmV4dFBhcnNlZFVybFF1ZXJ5ID0gUGFyc2VkVXJsUXVlcnkgJlxuICBOZXh0UXVlcnlNZXRhZGF0YSAmIHtcbiAgICBhbXA/OiAnMSdcbiAgfVxuXG5leHBvcnQgaW50ZXJmYWNlIE5leHRVcmxXaXRoUGFyc2VkUXVlcnkgZXh0ZW5kcyBVcmxXaXRoUGFyc2VkUXVlcnkge1xuICBxdWVyeTogTmV4dFBhcnNlZFVybFF1ZXJ5XG59XG4iXSwibmFtZXMiOlsiTkVYVF9SRVFVRVNUX01FVEEiLCJhZGRSZXF1ZXN0TWV0YSIsImdldFJlcXVlc3RNZXRhIiwicmVtb3ZlUmVxdWVzdE1ldGEiLCJzZXRSZXF1ZXN0TWV0YSIsIlN5bWJvbCIsImZvciIsInJlcSIsImtleSIsIm1ldGEiLCJyZXF1ZXN0IiwidmFsdWUiXSwibWFwcGluZ3MiOiJBQUFBLCtCQUErQjs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFZbEJBLGlCQUFpQixFQUFBO2VBQWpCQTs7SUFnUkdDLGNBQWMsRUFBQTtlQUFkQTs7SUE1QkFDLGNBQWMsRUFBQTtlQUFkQTs7SUE2Q0FDLGlCQUFpQixFQUFBO2VBQWpCQTs7SUE5QkFDLGNBQWMsRUFBQTtlQUFkQTs7O0FBblFULE1BQU1KLG9CQUFvQkssT0FBT0MsR0FBRyxDQUFDO0FBb1ByQyxTQUFTSixlQUNkSyxHQUF3QixFQUN4QkMsR0FBTztJQUVQLE1BQU1DLE9BQU9GLEdBQUcsQ0FBQ1Asa0JBQWtCLElBQUksQ0FBQztJQUN4QyxPQUFPLE9BQU9RLFFBQVEsV0FBV0MsSUFBSSxDQUFDRCxJQUFJLEdBQUdDO0FBQy9DO0FBU08sU0FBU0wsZUFBZUcsR0FBd0IsRUFBRUUsSUFBaUI7SUFDeEVGLEdBQUcsQ0FBQ1Asa0JBQWtCLEdBQUdTO0lBQ3pCLE9BQU9BO0FBQ1Q7QUFVTyxTQUFTUixlQUNkUyxPQUE0QixFQUM1QkYsR0FBTSxFQUNORyxLQUFxQjtJQUVyQixNQUFNRixPQUFPUCxlQUFlUTtJQUM1QkQsSUFBSSxDQUFDRCxJQUFJLEdBQUdHO0lBQ1osT0FBT1AsZUFBZU0sU0FBU0Q7QUFDakM7QUFTTyxTQUFTTixrQkFDZE8sT0FBNEIsRUFDNUJGLEdBQU07SUFFTixNQUFNQyxPQUFPUCxlQUFlUTtJQUM1QixPQUFPRCxJQUFJLENBQUNELElBQUk7SUFDaEIsT0FBT0osZUFBZU0sU0FBU0Q7QUFDakMiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTg5NCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9wYWdlcy9fZXJyb3IudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCBIZWFkIGZyb20gJy4uL3NoYXJlZC9saWIvaGVhZCdcbmltcG9ydCB0eXBlIHsgTmV4dFBhZ2VDb250ZXh0IH0gZnJvbSAnLi4vc2hhcmVkL2xpYi91dGlscydcblxuY29uc3Qgc3RhdHVzQ29kZXM6IHsgW2NvZGU6IG51bWJlcl06IHN0cmluZyB9ID0ge1xuICA0MDA6ICdCYWQgUmVxdWVzdCcsXG4gIDQwNDogJ1RoaXMgcGFnZSBjb3VsZCBub3QgYmUgZm91bmQnLFxuICA0MDU6ICdNZXRob2QgTm90IEFsbG93ZWQnLFxuICA1MDA6ICdJbnRlcm5hbCBTZXJ2ZXIgRXJyb3InLFxufVxuXG5leHBvcnQgdHlwZSBFcnJvclByb3BzID0ge1xuICBzdGF0dXNDb2RlOiBudW1iZXJcbiAgaG9zdG5hbWU/OiBzdHJpbmdcbiAgdGl0bGU/OiBzdHJpbmdcbiAgd2l0aERhcmtNb2RlPzogYm9vbGVhblxufVxuXG5mdW5jdGlvbiBfZ2V0SW5pdGlhbFByb3BzKHtcbiAgcmVxLFxuICByZXMsXG4gIGVycixcbn06IE5leHRQYWdlQ29udGV4dCk6IFByb21pc2U8RXJyb3JQcm9wcz4gfCBFcnJvclByb3BzIHtcbiAgY29uc3Qgc3RhdHVzQ29kZSA9XG4gICAgcmVzICYmIHJlcy5zdGF0dXNDb2RlID8gcmVzLnN0YXR1c0NvZGUgOiBlcnIgPyBlcnIuc3RhdHVzQ29kZSEgOiA0MDRcblxuICBsZXQgaG9zdG5hbWVcblxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBob3N0bmFtZSA9IHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZVxuICB9IGVsc2UgaWYgKHJlcSkge1xuICAgIGNvbnN0IHsgZ2V0UmVxdWVzdE1ldGEgfSA9XG4gICAgICByZXF1aXJlKCcuLi9zZXJ2ZXIvcmVxdWVzdC1tZXRhJykgYXMgdHlwZW9mIGltcG9ydCgnLi4vc2VydmVyL3JlcXVlc3QtbWV0YScpXG5cbiAgICBjb25zdCBpbml0VXJsID0gZ2V0UmVxdWVzdE1ldGEocmVxLCAnaW5pdFVSTCcpXG4gICAgaWYgKGluaXRVcmwpIHtcbiAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoaW5pdFVybClcbiAgICAgIGhvc3RuYW1lID0gdXJsLmhvc3RuYW1lXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHsgc3RhdHVzQ29kZSwgaG9zdG5hbWUgfVxufVxuXG5jb25zdCBzdHlsZXM6IFJlY29yZDxzdHJpbmcsIFJlYWN0LkNTU1Byb3BlcnRpZXM+ID0ge1xuICBlcnJvcjoge1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvbW9kZXJuLW5vcm1hbGl6ZS9ibG9iL21haW4vbW9kZXJuLW5vcm1hbGl6ZS5jc3MjTDM4LUw1MlxuICAgIGZvbnRGYW1pbHk6XG4gICAgICAnc3lzdGVtLXVpLFwiU2Vnb2UgVUlcIixSb2JvdG8sSGVsdmV0aWNhLEFyaWFsLHNhbnMtc2VyaWYsXCJBcHBsZSBDb2xvciBFbW9qaVwiLFwiU2Vnb2UgVUkgRW1vamlcIicsXG4gICAgaGVpZ2h0OiAnMTAwdmgnLFxuICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgIGZsZXhEaXJlY3Rpb246ICdjb2x1bW4nLFxuICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgIGp1c3RpZnlDb250ZW50OiAnY2VudGVyJyxcbiAgfSxcbiAgZGVzYzoge1xuICAgIGxpbmVIZWlnaHQ6ICc0OHB4JyxcbiAgfSxcbiAgaDE6IHtcbiAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICBtYXJnaW46ICcwIDIwcHggMCAwJyxcbiAgICBwYWRkaW5nUmlnaHQ6IDIzLFxuICAgIGZvbnRTaXplOiAyNCxcbiAgICBmb250V2VpZ2h0OiA1MDAsXG4gICAgdmVydGljYWxBbGlnbjogJ3RvcCcsXG4gIH0sXG4gIGgyOiB7XG4gICAgZm9udFNpemU6IDE0LFxuICAgIGZvbnRXZWlnaHQ6IDQwMCxcbiAgICBsaW5lSGVpZ2h0OiAnMjhweCcsXG4gIH0sXG4gIHdyYXA6IHtcbiAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgfSxcbn1cblxuLyoqXG4gKiBgRXJyb3JgIGNvbXBvbmVudCB1c2VkIGZvciBoYW5kbGluZyBlcnJvcnMuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVycm9yPFAgPSB7fT4gZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8UCAmIEVycm9yUHJvcHM+IHtcbiAgc3RhdGljIGRpc3BsYXlOYW1lID0gJ0Vycm9yUGFnZSdcblxuICBzdGF0aWMgZ2V0SW5pdGlhbFByb3BzID0gX2dldEluaXRpYWxQcm9wc1xuICBzdGF0aWMgb3JpZ0dldEluaXRpYWxQcm9wcyA9IF9nZXRJbml0aWFsUHJvcHNcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBzdGF0dXNDb2RlLCB3aXRoRGFya01vZGUgPSB0cnVlIH0gPSB0aGlzLnByb3BzXG4gICAgY29uc3QgdGl0bGUgPVxuICAgICAgdGhpcy5wcm9wcy50aXRsZSB8fFxuICAgICAgc3RhdHVzQ29kZXNbc3RhdHVzQ29kZV0gfHxcbiAgICAgICdBbiB1bmV4cGVjdGVkIGVycm9yIGhhcyBvY2N1cnJlZCdcblxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IHN0eWxlPXtzdHlsZXMuZXJyb3J9PlxuICAgICAgICA8SGVhZD5cbiAgICAgICAgICA8dGl0bGU+XG4gICAgICAgICAgICB7c3RhdHVzQ29kZVxuICAgICAgICAgICAgICA/IGAke3N0YXR1c0NvZGV9OiAke3RpdGxlfWBcbiAgICAgICAgICAgICAgOiAnQXBwbGljYXRpb24gZXJyb3I6IGEgY2xpZW50LXNpZGUgZXhjZXB0aW9uIGhhcyBvY2N1cnJlZCd9XG4gICAgICAgICAgPC90aXRsZT5cbiAgICAgICAgPC9IZWFkPlxuICAgICAgICA8ZGl2IHN0eWxlPXtzdHlsZXMuZGVzY30+XG4gICAgICAgICAgPHN0eWxlXG4gICAgICAgICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTD17e1xuICAgICAgICAgICAgICAvKiBDU1MgbWluaWZpZWQgZnJvbVxuICAgICAgICAgICAgICAgIGJvZHkgeyBtYXJnaW46IDA7IGNvbG9yOiAjMDAwOyBiYWNrZ3JvdW5kOiAjZmZmOyB9XG4gICAgICAgICAgICAgICAgLm5leHQtZXJyb3ItaDEge1xuICAgICAgICAgICAgICAgICAgYm9yZGVyLXJpZ2h0OiAxcHggc29saWQgcmdiYSgwLCAwLCAwLCAuMyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgJHtcbiAgICAgICAgICAgICAgICAgIHdpdGhEYXJrTW9kZVxuICAgICAgICAgICAgICAgICAgICA/IGBAbWVkaWEgKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKSB7XG4gICAgICAgICAgICAgICAgICBib2R5IHsgY29sb3I6ICNmZmY7IGJhY2tncm91bmQ6ICMwMDA7IH1cbiAgICAgICAgICAgICAgICAgIC5uZXh0LWVycm9yLWgxIHtcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyLXJpZ2h0OiAxcHggc29saWQgcmdiYSgyNTUsIDI1NSwgMjU1LCAuMyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfWBcbiAgICAgICAgICAgICAgICAgICAgOiAnJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgIF9faHRtbDogYGJvZHl7Y29sb3I6IzAwMDtiYWNrZ3JvdW5kOiNmZmY7bWFyZ2luOjB9Lm5leHQtZXJyb3ItaDF7Ym9yZGVyLXJpZ2h0OjFweCBzb2xpZCByZ2JhKDAsMCwwLC4zKX0ke1xuICAgICAgICAgICAgICAgIHdpdGhEYXJrTW9kZVxuICAgICAgICAgICAgICAgICAgPyAnQG1lZGlhIChwcmVmZXJzLWNvbG9yLXNjaGVtZTpkYXJrKXtib2R5e2NvbG9yOiNmZmY7YmFja2dyb3VuZDojMDAwfS5uZXh0LWVycm9yLWgxe2JvcmRlci1yaWdodDoxcHggc29saWQgcmdiYSgyNTUsMjU1LDI1NSwuMyl9fSdcbiAgICAgICAgICAgICAgICAgIDogJydcbiAgICAgICAgICAgICAgfWAsXG4gICAgICAgICAgICB9fVxuICAgICAgICAgIC8+XG5cbiAgICAgICAgICB7c3RhdHVzQ29kZSA/IChcbiAgICAgICAgICAgIDxoMSBjbGFzc05hbWU9XCJuZXh0LWVycm9yLWgxXCIgc3R5bGU9e3N0eWxlcy5oMX0+XG4gICAgICAgICAgICAgIHtzdGF0dXNDb2RlfVxuICAgICAgICAgICAgPC9oMT5cbiAgICAgICAgICApIDogbnVsbH1cbiAgICAgICAgICA8ZGl2IHN0eWxlPXtzdHlsZXMud3JhcH0+XG4gICAgICAgICAgICA8aDIgc3R5bGU9e3N0eWxlcy5oMn0+XG4gICAgICAgICAgICAgIHt0aGlzLnByb3BzLnRpdGxlIHx8IHN0YXR1c0NvZGUgPyAoXG4gICAgICAgICAgICAgICAgdGl0bGVcbiAgICAgICAgICAgICAgKSA6IChcbiAgICAgICAgICAgICAgICA8PlxuICAgICAgICAgICAgICAgICAgQXBwbGljYXRpb24gZXJyb3I6IGEgY2xpZW50LXNpZGUgZXhjZXB0aW9uIGhhcyBvY2N1cnJlZHsnICd9XG4gICAgICAgICAgICAgICAgICB7Qm9vbGVhbih0aGlzLnByb3BzLmhvc3RuYW1lKSAmJiAoXG4gICAgICAgICAgICAgICAgICAgIDw+d2hpbGUgbG9hZGluZyB7dGhpcy5wcm9wcy5ob3N0bmFtZX08Lz5cbiAgICAgICAgICAgICAgICAgICl9eycgJ31cbiAgICAgICAgICAgICAgICAgIChzZWUgdGhlIGJyb3dzZXIgY29uc29sZSBmb3IgbW9yZSBpbmZvcm1hdGlvbilcbiAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgLlxuICAgICAgICAgICAgPC9oMj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJFcnJvciIsInN0YXR1c0NvZGVzIiwiX2dldEluaXRpYWxQcm9wcyIsInJlcSIsInJlcyIsImVyciIsInN0YXR1c0NvZGUiLCJob3N0bmFtZSIsIndpbmRvdyIsImxvY2F0aW9uIiwiZ2V0UmVxdWVzdE1ldGEiLCJyZXF1aXJlIiwiaW5pdFVybCIsInVybCIsIlVSTCIsInN0eWxlcyIsImVycm9yIiwiZm9udEZhbWlseSIsImhlaWdodCIsInRleHRBbGlnbiIsImRpc3BsYXkiLCJmbGV4RGlyZWN0aW9uIiwiYWxpZ25JdGVtcyIsImp1c3RpZnlDb250ZW50IiwiZGVzYyIsImxpbmVIZWlnaHQiLCJoMSIsIm1hcmdpbiIsInBhZGRpbmdSaWdodCIsImZvbnRTaXplIiwiZm9udFdlaWdodCIsInZlcnRpY2FsQWxpZ24iLCJoMiIsIndyYXAiLCJSZWFjdCIsIkNvbXBvbmVudCIsInJlbmRlciIsIndpdGhEYXJrTW9kZSIsInByb3BzIiwidGl0bGUiLCJkaXYiLCJzdHlsZSIsIkhlYWQiLCJkYW5nZXJvdXNseVNldElubmVySFRNTCIsIl9faHRtbCIsImNsYXNzTmFtZSIsIkJvb2xlYW4iLCJkaXNwbGF5TmFtZSIsImdldEluaXRpYWxQcm9wcyIsIm9yaWdHZXRJbml0aWFsUHJvcHMiXSwibWFwcGluZ3MiOiI7Ozs7OztlQWdGcUJBOzs7OztnRUFoRkg7K0RBQ0Q7QUFHakIsTUFBTUMsY0FBMEM7SUFDOUMsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztBQUNQO0FBU0EsU0FBU0MsaUJBQWlCLEtBSVI7SUFKUSxJQUFBLEVBQ3hCQyxHQUFHLEVBQ0hDLEdBQUcsRUFDSEMsR0FBRyxFQUNhLEdBSlE7SUFLeEIsTUFBTUMsYUFDSkYsT0FBT0EsSUFBSUUsVUFBVSxHQUFHRixJQUFJRSxVQUFVLEdBQUdELE1BQU1BLElBQUlDLFVBQVUsR0FBSTtJQUVuRSxJQUFJQztJQUVKLElBQUksT0FBT0MsV0FBVyxhQUFhO1FBQ2pDRCxXQUFXQyxPQUFPQyxRQUFRLENBQUNGLFFBQVE7SUFDckMsT0FBTyxJQUFJSixLQUFLO1FBQ2QsTUFBTSxFQUFFTyxjQUFjLEVBQUUsR0FDdEJDLFFBQVE7UUFFVixNQUFNQyxVQUFVRixlQUFlUCxLQUFLO1FBQ3BDLElBQUlTLFNBQVM7WUFDWCxNQUFNQyxNQUFNLElBQUlDLElBQUlGO1lBQ3BCTCxXQUFXTSxJQUFJTixRQUFRO1FBQ3pCO0lBQ0Y7SUFFQSxPQUFPO1FBQUVEO1FBQVlDO0lBQVM7QUFDaEM7QUFFQSxNQUFNUSxTQUE4QztJQUNsREMsT0FBTztRQUNMLDBGQUEwRjtRQUMxRkMsWUFDRTtRQUNGQyxRQUFRO1FBQ1JDLFdBQVc7UUFDWEMsU0FBUztRQUNUQyxlQUFlO1FBQ2ZDLFlBQVk7UUFDWkMsZ0JBQWdCO0lBQ2xCO0lBQ0FDLE1BQU07UUFDSkMsWUFBWTtJQUNkO0lBQ0FDLElBQUk7UUFDRk4sU0FBUztRQUNUTyxRQUFRO1FBQ1JDLGNBQWM7UUFDZEMsVUFBVTtRQUNWQyxZQUFZO1FBQ1pDLGVBQWU7SUFDakI7SUFDQUMsSUFBSTtRQUNGSCxVQUFVO1FBQ1ZDLFlBQVk7UUFDWkwsWUFBWTtJQUNkO0lBQ0FRLE1BQU07UUFDSmIsU0FBUztJQUNYO0FBQ0Y7QUFLZSxNQUFNcEIsY0FBc0JrQyxPQUFBQSxPQUFLLENBQUNDLFNBQVM7SUFNeERDLFNBQVM7UUFDUCxNQUFNLEVBQUU5QixVQUFVLEVBQUUrQixlQUFlLElBQUksRUFBRSxHQUFHLElBQUksQ0FBQ0MsS0FBSztRQUN0RCxNQUFNQyxRQUNKLElBQUksQ0FBQ0QsS0FBSyxDQUFDQyxLQUFLLElBQ2hCdEMsV0FBVyxDQUFDSyxXQUFXLElBQ3ZCO1FBRUYsT0FBQSxXQUFBLEdBQ0UsQ0FBQSxHQUFBLFlBQUEsSUFBQSxFQUFDa0MsT0FBQUE7WUFBSUMsT0FBTzFCLE9BQU9DLEtBQUs7OzhCQUN0QixDQUFBLEdBQUEsWUFBQSxHQUFBLEVBQUMwQixNQUFBQSxPQUFJLEVBQUE7OEJBQ0gsV0FBQSxHQUFBLENBQUEsR0FBQSxZQUFBLEdBQUEsRUFBQ0gsU0FBQUE7a0NBQ0VqQyxhQUNNQSxhQUFXLE9BQUlpQyxRQUNsQjs7OzhCQUdSLENBQUEsR0FBQSxZQUFBLElBQUEsRUFBQ0MsT0FBQUE7b0JBQUlDLE9BQU8xQixPQUFPUyxJQUFJOztzQ0FDckIsQ0FBQSxHQUFBLFlBQUEsR0FBQSxFQUFDaUIsU0FBQUE7NEJBQ0NFLHlCQUF5QjtnQ0FDdkI7Ozs7Ozs7Ozs7Ozs7Ozs7ZUFnQkMsR0FDREMsUUFBUyxtR0FDUFAsQ0FBQUEsZUFDSSxvSUFDQSxFQUFDOzRCQUVUOzt3QkFHRC9CLGFBQUFBLFdBQUFBLEdBQ0MsQ0FBQSxHQUFBLFlBQUEsR0FBQSxFQUFDb0IsTUFBQUE7NEJBQUdtQixXQUFVOzRCQUFnQkosT0FBTzFCLE9BQU9XLEVBQUU7c0NBQzNDcEI7NkJBRUQ7c0NBQ0osQ0FBQSxHQUFBLFlBQUEsR0FBQSxFQUFDa0MsT0FBQUE7NEJBQUlDLE9BQU8xQixPQUFPa0IsSUFBSTtzQ0FDckIsV0FBQSxHQUFBLENBQUEsR0FBQSxZQUFBLElBQUEsRUFBQ0QsTUFBQUE7Z0NBQUdTLE9BQU8xQixPQUFPaUIsRUFBRTs7b0NBQ2pCLElBQUksQ0FBQ00sS0FBSyxDQUFDQyxLQUFLLElBQUlqQyxhQUNuQmlDLFFBQUFBLFdBQUFBLEdBRUEsQ0FBQSxHQUFBLFlBQUEsSUFBQSxFQUFBLFlBQUEsUUFBQSxFQUFBOzs0Q0FBRTs0Q0FDd0Q7NENBQ3ZETyxRQUFRLElBQUksQ0FBQ1IsS0FBSyxDQUFDL0IsUUFBUSxLQUFBLFdBQUEsR0FDMUIsQ0FBQSxHQUFBLFlBQUEsSUFBQSxFQUFBLFlBQUEsUUFBQSxFQUFBOztvREFBRTtvREFBZSxJQUFJLENBQUMrQixLQUFLLENBQUMvQixRQUFROzs7NENBQ25DOzRDQUFJOzs7b0NBR1Q7Ozs7Ozs7O0lBT2Q7QUFDRjtBQTNFcUJQLE1BQ1orQyxXQUFBQSxHQUFjO0FBREYvQyxNQUdaZ0QsZUFBQUEsR0FBa0I5QztBQUhORixNQUlaaUQsbUJBQUFBLEdBQXNCL0MiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fV0KfQ==