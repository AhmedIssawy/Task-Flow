(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push([typeof document === "object" ? document.currentScript : undefined, {

"[project]/node_modules/next/dist/compiled/process/browser.js [app-client] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
(function() {
    var e = {
        229: function(e) {
            var t = e.exports = {};
            var r;
            var n;
            function defaultSetTimout() {
                throw new Error("setTimeout has not been defined");
            }
            function defaultClearTimeout() {
                throw new Error("clearTimeout has not been defined");
            }
            (function() {
                try {
                    if (typeof setTimeout === "function") {
                        r = setTimeout;
                    } else {
                        r = defaultSetTimout;
                    }
                } catch (e) {
                    r = defaultSetTimout;
                }
                try {
                    if (typeof clearTimeout === "function") {
                        n = clearTimeout;
                    } else {
                        n = defaultClearTimeout;
                    }
                } catch (e) {
                    n = defaultClearTimeout;
                }
            })();
            function runTimeout(e) {
                if (r === setTimeout) {
                    return setTimeout(e, 0);
                }
                if ((r === defaultSetTimout || !r) && setTimeout) {
                    r = setTimeout;
                    return setTimeout(e, 0);
                }
                try {
                    return r(e, 0);
                } catch (t) {
                    try {
                        return r.call(null, e, 0);
                    } catch (t) {
                        return r.call(this, e, 0);
                    }
                }
            }
            function runClearTimeout(e) {
                if (n === clearTimeout) {
                    return clearTimeout(e);
                }
                if ((n === defaultClearTimeout || !n) && clearTimeout) {
                    n = clearTimeout;
                    return clearTimeout(e);
                }
                try {
                    return n(e);
                } catch (t) {
                    try {
                        return n.call(null, e);
                    } catch (t) {
                        return n.call(this, e);
                    }
                }
            }
            var i = [];
            var o = false;
            var u;
            var a = -1;
            function cleanUpNextTick() {
                if (!o || !u) {
                    return;
                }
                o = false;
                if (u.length) {
                    i = u.concat(i);
                } else {
                    a = -1;
                }
                if (i.length) {
                    drainQueue();
                }
            }
            function drainQueue() {
                if (o) {
                    return;
                }
                var e = runTimeout(cleanUpNextTick);
                o = true;
                var t = i.length;
                while(t){
                    u = i;
                    i = [];
                    while(++a < t){
                        if (u) {
                            u[a].run();
                        }
                    }
                    a = -1;
                    t = i.length;
                }
                u = null;
                o = false;
                runClearTimeout(e);
            }
            t.nextTick = function(e) {
                var t = new Array(arguments.length - 1);
                if (arguments.length > 1) {
                    for(var r = 1; r < arguments.length; r++){
                        t[r - 1] = arguments[r];
                    }
                }
                i.push(new Item(e, t));
                if (i.length === 1 && !o) {
                    runTimeout(drainQueue);
                }
            };
            function Item(e, t) {
                this.fun = e;
                this.array = t;
            }
            Item.prototype.run = function() {
                this.fun.apply(null, this.array);
            };
            t.title = "browser";
            t.browser = true;
            t.env = {};
            t.argv = [];
            t.version = "";
            t.versions = {};
            function noop() {}
            t.on = noop;
            t.addListener = noop;
            t.once = noop;
            t.off = noop;
            t.removeListener = noop;
            t.removeAllListeners = noop;
            t.emit = noop;
            t.prependListener = noop;
            t.prependOnceListener = noop;
            t.listeners = function(e) {
                return [];
            };
            t.binding = function(e) {
                throw new Error("process.binding is not supported");
            };
            t.cwd = function() {
                return "/";
            };
            t.chdir = function(e) {
                throw new Error("process.chdir is not supported");
            };
            t.umask = function() {
                return 0;
            };
        }
    };
    var t = {};
    function __nccwpck_require__(r) {
        var n = t[r];
        if (n !== undefined) {
            return n.exports;
        }
        var i = t[r] = {
            exports: {}
        };
        var o = true;
        try {
            e[r](i, i.exports, __nccwpck_require__);
            o = false;
        } finally{
            if (o) delete t[r];
        }
        return i.exports;
    }
    if (typeof __nccwpck_require__ !== "undefined") __nccwpck_require__.ab = ("TURBOPACK compile-time value", "/ROOT/node_modules/next/dist/compiled/process") + "/";
    var r = __nccwpck_require__(229);
    module.exports = r;
})();
}}),
"[project]/node_modules/next/dist/compiled/react-refresh/cjs/react-refresh-runtime.development.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/**
 * @license React
 * react-refresh-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
if ("TURBOPACK compile-time truthy", 1) {
    (function() {
        'use strict';
        // ATTENTION
        var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
        var REACT_MEMO_TYPE = Symbol.for('react.memo');
        var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map; // We never remove these associations.
        // It's OK to reference families, but use WeakMap/Set for types.
        var allFamiliesByID = new Map();
        var allFamiliesByType = new PossiblyWeakMap();
        var allSignaturesByType = new PossiblyWeakMap(); // This WeakMap is read by React, so we only put families
        // that have actually been edited here. This keeps checks fast.
        // $FlowIssue
        var updatedFamiliesByType = new PossiblyWeakMap(); // This is cleared on every performReactRefresh() call.
        // It is an array of [Family, NextType] tuples.
        var pendingUpdates = []; // This is injected by the renderer via DevTools global hook.
        var helpersByRendererID = new Map();
        var helpersByRoot = new Map(); // We keep track of mounted roots so we can schedule updates.
        var mountedRoots = new Set(); // If a root captures an error, we remember it so we can retry on edit.
        var failedRoots = new Set(); // In environments that support WeakMap, we also remember the last element for every root.
        // It needs to be weak because we do this even for roots that failed to mount.
        // If there is no WeakMap, we won't attempt to do retrying.
        // $FlowIssue
        var rootElements = typeof WeakMap === 'function' ? new WeakMap() : null;
        var isPerformingRefresh = false;
        function computeFullKey(signature) {
            if (signature.fullKey !== null) {
                return signature.fullKey;
            }
            var fullKey = signature.ownKey;
            var hooks;
            try {
                hooks = signature.getCustomHooks();
            } catch (err) {
                // This can happen in an edge case, e.g. if expression like Foo.useSomething
                // depends on Foo which is lazily initialized during rendering.
                // In that case just assume we'll have to remount.
                signature.forceReset = true;
                signature.fullKey = fullKey;
                return fullKey;
            }
            for(var i = 0; i < hooks.length; i++){
                var hook = hooks[i];
                if (typeof hook !== 'function') {
                    // Something's wrong. Assume we need to remount.
                    signature.forceReset = true;
                    signature.fullKey = fullKey;
                    return fullKey;
                }
                var nestedHookSignature = allSignaturesByType.get(hook);
                if (nestedHookSignature === undefined) {
                    continue;
                }
                var nestedHookKey = computeFullKey(nestedHookSignature);
                if (nestedHookSignature.forceReset) {
                    signature.forceReset = true;
                }
                fullKey += '\n---\n' + nestedHookKey;
            }
            signature.fullKey = fullKey;
            return fullKey;
        }
        function haveEqualSignatures(prevType, nextType) {
            var prevSignature = allSignaturesByType.get(prevType);
            var nextSignature = allSignaturesByType.get(nextType);
            if (prevSignature === undefined && nextSignature === undefined) {
                return true;
            }
            if (prevSignature === undefined || nextSignature === undefined) {
                return false;
            }
            if (computeFullKey(prevSignature) !== computeFullKey(nextSignature)) {
                return false;
            }
            if (nextSignature.forceReset) {
                return false;
            }
            return true;
        }
        function isReactClass(type) {
            return type.prototype && type.prototype.isReactComponent;
        }
        function canPreserveStateBetween(prevType, nextType) {
            if (isReactClass(prevType) || isReactClass(nextType)) {
                return false;
            }
            if (haveEqualSignatures(prevType, nextType)) {
                return true;
            }
            return false;
        }
        function resolveFamily(type) {
            // Only check updated types to keep lookups fast.
            return updatedFamiliesByType.get(type);
        } // If we didn't care about IE11, we could use new Map/Set(iterable).
        function cloneMap(map) {
            var clone = new Map();
            map.forEach(function(value, key) {
                clone.set(key, value);
            });
            return clone;
        }
        function cloneSet(set) {
            var clone = new Set();
            set.forEach(function(value) {
                clone.add(value);
            });
            return clone;
        } // This is a safety mechanism to protect against rogue getters and Proxies.
        function getProperty(object, property) {
            try {
                return object[property];
            } catch (err) {
                // Intentionally ignore.
                return undefined;
            }
        }
        function performReactRefresh() {
            if (pendingUpdates.length === 0) {
                return null;
            }
            if (isPerformingRefresh) {
                return null;
            }
            isPerformingRefresh = true;
            try {
                var staleFamilies = new Set();
                var updatedFamilies = new Set();
                var updates = pendingUpdates;
                pendingUpdates = [];
                updates.forEach(function(_ref) {
                    var family = _ref[0], nextType = _ref[1];
                    // Now that we got a real edit, we can create associations
                    // that will be read by the React reconciler.
                    var prevType = family.current;
                    updatedFamiliesByType.set(prevType, family);
                    updatedFamiliesByType.set(nextType, family);
                    family.current = nextType; // Determine whether this should be a re-render or a re-mount.
                    if (canPreserveStateBetween(prevType, nextType)) {
                        updatedFamilies.add(family);
                    } else {
                        staleFamilies.add(family);
                    }
                }); // TODO: rename these fields to something more meaningful.
                var update = {
                    updatedFamilies: updatedFamilies,
                    // Families that will re-render preserving state
                    staleFamilies: staleFamilies // Families that will be remounted
                };
                helpersByRendererID.forEach(function(helpers) {
                    // Even if there are no roots, set the handler on first update.
                    // This ensures that if *new* roots are mounted, they'll use the resolve handler.
                    helpers.setRefreshHandler(resolveFamily);
                });
                var didError = false;
                var firstError = null; // We snapshot maps and sets that are mutated during commits.
                // If we don't do this, there is a risk they will be mutated while
                // we iterate over them. For example, trying to recover a failed root
                // may cause another root to be added to the failed list -- an infinite loop.
                var failedRootsSnapshot = cloneSet(failedRoots);
                var mountedRootsSnapshot = cloneSet(mountedRoots);
                var helpersByRootSnapshot = cloneMap(helpersByRoot);
                failedRootsSnapshot.forEach(function(root) {
                    var helpers = helpersByRootSnapshot.get(root);
                    if (helpers === undefined) {
                        throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');
                    }
                    if (!failedRoots.has(root)) {}
                    if (rootElements === null) {
                        return;
                    }
                    if (!rootElements.has(root)) {
                        return;
                    }
                    var element = rootElements.get(root);
                    try {
                        helpers.scheduleRoot(root, element);
                    } catch (err) {
                        if (!didError) {
                            didError = true;
                            firstError = err;
                        } // Keep trying other roots.
                    }
                });
                mountedRootsSnapshot.forEach(function(root) {
                    var helpers = helpersByRootSnapshot.get(root);
                    if (helpers === undefined) {
                        throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');
                    }
                    if (!mountedRoots.has(root)) {}
                    try {
                        helpers.scheduleRefresh(root, update);
                    } catch (err) {
                        if (!didError) {
                            didError = true;
                            firstError = err;
                        } // Keep trying other roots.
                    }
                });
                if (didError) {
                    throw firstError;
                }
                return update;
            } finally{
                isPerformingRefresh = false;
            }
        }
        function register(type, id) {
            {
                if (type === null) {
                    return;
                }
                if (typeof type !== 'function' && typeof type !== 'object') {
                    return;
                } // This can happen in an edge case, e.g. if we register
                // return value of a HOC but it returns a cached component.
                // Ignore anything but the first registration for each type.
                if (allFamiliesByType.has(type)) {
                    return;
                } // Create family or remember to update it.
                // None of this bookkeeping affects reconciliation
                // until the first performReactRefresh() call above.
                var family = allFamiliesByID.get(id);
                if (family === undefined) {
                    family = {
                        current: type
                    };
                    allFamiliesByID.set(id, family);
                } else {
                    pendingUpdates.push([
                        family,
                        type
                    ]);
                }
                allFamiliesByType.set(type, family); // Visit inner types because we might not have registered them.
                if (typeof type === 'object' && type !== null) {
                    switch(getProperty(type, '$$typeof')){
                        case REACT_FORWARD_REF_TYPE:
                            register(type.render, id + '$render');
                            break;
                        case REACT_MEMO_TYPE:
                            register(type.type, id + '$type');
                            break;
                    }
                }
            }
        }
        function setSignature(type, key) {
            var forceReset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var getCustomHooks = arguments.length > 3 ? arguments[3] : undefined;
            {
                if (!allSignaturesByType.has(type)) {
                    allSignaturesByType.set(type, {
                        forceReset: forceReset,
                        ownKey: key,
                        fullKey: null,
                        getCustomHooks: getCustomHooks || function() {
                            return [];
                        }
                    });
                } // Visit inner types because we might not have signed them.
                if (typeof type === 'object' && type !== null) {
                    switch(getProperty(type, '$$typeof')){
                        case REACT_FORWARD_REF_TYPE:
                            setSignature(type.render, key, forceReset, getCustomHooks);
                            break;
                        case REACT_MEMO_TYPE:
                            setSignature(type.type, key, forceReset, getCustomHooks);
                            break;
                    }
                }
            }
        } // This is lazily called during first render for a type.
        // It captures Hook list at that time so inline requires don't break comparisons.
        function collectCustomHooksForSignature(type) {
            {
                var signature = allSignaturesByType.get(type);
                if (signature !== undefined) {
                    computeFullKey(signature);
                }
            }
        }
        function getFamilyByID(id) {
            {
                return allFamiliesByID.get(id);
            }
        }
        function getFamilyByType(type) {
            {
                return allFamiliesByType.get(type);
            }
        }
        function findAffectedHostInstances(families) {
            {
                var affectedInstances = new Set();
                mountedRoots.forEach(function(root) {
                    var helpers = helpersByRoot.get(root);
                    if (helpers === undefined) {
                        throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');
                    }
                    var instancesForRoot = helpers.findHostInstancesForRefresh(root, families);
                    instancesForRoot.forEach(function(inst) {
                        affectedInstances.add(inst);
                    });
                });
                return affectedInstances;
            }
        }
        function injectIntoGlobalHook(globalObject) {
            {
                // For React Native, the global hook will be set up by require('react-devtools-core').
                // That code will run before us. So we need to monkeypatch functions on existing hook.
                // For React Web, the global hook will be set up by the extension.
                // This will also run before us.
                var hook = globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__;
                if (hook === undefined) {
                    // However, if there is no DevTools extension, we'll need to set up the global hook ourselves.
                    // Note that in this case it's important that renderer code runs *after* this method call.
                    // Otherwise, the renderer will think that there is no global hook, and won't do the injection.
                    var nextID = 0;
                    globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__ = hook = {
                        renderers: new Map(),
                        supportsFiber: true,
                        inject: function(injected) {
                            return nextID++;
                        },
                        onScheduleFiberRoot: function(id, root, children) {},
                        onCommitFiberRoot: function(id, root, maybePriorityLevel, didError) {},
                        onCommitFiberUnmount: function() {}
                    };
                }
                if (hook.isDisabled) {
                    // This isn't a real property on the hook, but it can be set to opt out
                    // of DevTools integration and associated warnings and logs.
                    // Using console['warn'] to evade Babel and ESLint
                    console['warn']('Something has shimmed the React DevTools global hook (__REACT_DEVTOOLS_GLOBAL_HOOK__). ' + 'Fast Refresh is not compatible with this shim and will be disabled.');
                    return;
                } // Here, we just want to get a reference to scheduleRefresh.
                var oldInject = hook.inject;
                hook.inject = function(injected) {
                    var id = oldInject.apply(this, arguments);
                    if (typeof injected.scheduleRefresh === 'function' && typeof injected.setRefreshHandler === 'function') {
                        // This version supports React Refresh.
                        helpersByRendererID.set(id, injected);
                    }
                    return id;
                }; // Do the same for any already injected roots.
                // This is useful if ReactDOM has already been initialized.
                // https://github.com/facebook/react/issues/17626
                hook.renderers.forEach(function(injected, id) {
                    if (typeof injected.scheduleRefresh === 'function' && typeof injected.setRefreshHandler === 'function') {
                        // This version supports React Refresh.
                        helpersByRendererID.set(id, injected);
                    }
                }); // We also want to track currently mounted roots.
                var oldOnCommitFiberRoot = hook.onCommitFiberRoot;
                var oldOnScheduleFiberRoot = hook.onScheduleFiberRoot || function() {};
                hook.onScheduleFiberRoot = function(id, root, children) {
                    if (!isPerformingRefresh) {
                        // If it was intentionally scheduled, don't attempt to restore.
                        // This includes intentionally scheduled unmounts.
                        failedRoots.delete(root);
                        if (rootElements !== null) {
                            rootElements.set(root, children);
                        }
                    }
                    return oldOnScheduleFiberRoot.apply(this, arguments);
                };
                hook.onCommitFiberRoot = function(id, root, maybePriorityLevel, didError) {
                    var helpers = helpersByRendererID.get(id);
                    if (helpers !== undefined) {
                        helpersByRoot.set(root, helpers);
                        var current = root.current;
                        var alternate = current.alternate; // We need to determine whether this root has just (un)mounted.
                        // This logic is copy-pasted from similar logic in the DevTools backend.
                        // If this breaks with some refactoring, you'll want to update DevTools too.
                        if (alternate !== null) {
                            var wasMounted = alternate.memoizedState != null && alternate.memoizedState.element != null && mountedRoots.has(root);
                            var isMounted = current.memoizedState != null && current.memoizedState.element != null;
                            if (!wasMounted && isMounted) {
                                // Mount a new root.
                                mountedRoots.add(root);
                                failedRoots.delete(root);
                            } else if (wasMounted && isMounted) ;
                            else if (wasMounted && !isMounted) {
                                // Unmount an existing root.
                                mountedRoots.delete(root);
                                if (didError) {
                                    // We'll remount it on future edits.
                                    failedRoots.add(root);
                                } else {
                                    helpersByRoot.delete(root);
                                }
                            } else if (!wasMounted && !isMounted) {
                                if (didError) {
                                    // We'll remount it on future edits.
                                    failedRoots.add(root);
                                }
                            }
                        } else {
                            // Mount a new root.
                            mountedRoots.add(root);
                        }
                    } // Always call the decorated DevTools hook.
                    return oldOnCommitFiberRoot.apply(this, arguments);
                };
            }
        }
        function hasUnrecoverableErrors() {
            // TODO: delete this after removing dependency in RN.
            return false;
        } // Exposed for testing.
        function _getMountedRootCount() {
            {
                return mountedRoots.size;
            }
        } // This is a wrapper over more primitive functions for setting signature.
        // Signatures let us decide whether the Hook order has changed on refresh.
        //
        // This function is intended to be used as a transform target, e.g.:
        // var _s = createSignatureFunctionForTransform()
        //
        // function Hello() {
        //   const [foo, setFoo] = useState(0);
        //   const value = useCustomHook();
        //   _s(); /* Call without arguments triggers collecting the custom Hook list.
        //          * This doesn't happen during the module evaluation because we
        //          * don't want to change the module order with inline requires.
        //          * Next calls are noops. */
        //   return <h1>Hi</h1>;
        // }
        //
        // /* Call with arguments attaches the signature to the type: */
        // _s(
        //   Hello,
        //   'useState{[foo, setFoo]}(0)',
        //   () => [useCustomHook], /* Lazy to avoid triggering inline requires */
        // );
        function createSignatureFunctionForTransform() {
            {
                var savedType;
                var hasCustomHooks;
                var didCollectHooks = false;
                return function(type, key, forceReset, getCustomHooks) {
                    if (typeof key === 'string') {
                        // We're in the initial phase that associates signatures
                        // with the functions. Note this may be called multiple times
                        // in HOC chains like _s(hoc1(_s(hoc2(_s(actualFunction))))).
                        if (!savedType) {
                            // We're in the innermost call, so this is the actual type.
                            savedType = type;
                            hasCustomHooks = typeof getCustomHooks === 'function';
                        } // Set the signature for all types (even wrappers!) in case
                        // they have no signatures of their own. This is to prevent
                        // problems like https://github.com/facebook/react/issues/20417.
                        if (type != null && (typeof type === 'function' || typeof type === 'object')) {
                            setSignature(type, key, forceReset, getCustomHooks);
                        }
                        return type;
                    } else {
                        // We're in the _s() call without arguments, which means
                        // this is the time to collect custom Hook signatures.
                        // Only do this once. This path is hot and runs *inside* every render!
                        if (!didCollectHooks && hasCustomHooks) {
                            didCollectHooks = true;
                            collectCustomHooksForSignature(savedType);
                        }
                    }
                };
            }
        }
        function isLikelyComponentType(type) {
            {
                switch(typeof type){
                    case 'function':
                        {
                            // First, deal with classes.
                            if (type.prototype != null) {
                                if (type.prototype.isReactComponent) {
                                    // React class.
                                    return true;
                                }
                                var ownNames = Object.getOwnPropertyNames(type.prototype);
                                if (ownNames.length > 1 || ownNames[0] !== 'constructor') {
                                    // This looks like a class.
                                    return false;
                                } // eslint-disable-next-line no-proto
                                if (type.prototype.__proto__ !== Object.prototype) {
                                    // It has a superclass.
                                    return false;
                                } // Pass through.
                            // This looks like a regular function with empty prototype.
                            } // For plain functions and arrows, use name as a heuristic.
                            var name = type.name || type.displayName;
                            return typeof name === 'string' && /^[A-Z]/.test(name);
                        }
                    case 'object':
                        {
                            if (type != null) {
                                switch(getProperty(type, '$$typeof')){
                                    case REACT_FORWARD_REF_TYPE:
                                    case REACT_MEMO_TYPE:
                                        // Definitely React components.
                                        return true;
                                    default:
                                        return false;
                                }
                            }
                            return false;
                        }
                    default:
                        {
                            return false;
                        }
                }
            }
        }
        exports._getMountedRootCount = _getMountedRootCount;
        exports.collectCustomHooksForSignature = collectCustomHooksForSignature;
        exports.createSignatureFunctionForTransform = createSignatureFunctionForTransform;
        exports.findAffectedHostInstances = findAffectedHostInstances;
        exports.getFamilyByID = getFamilyByID;
        exports.getFamilyByType = getFamilyByType;
        exports.hasUnrecoverableErrors = hasUnrecoverableErrors;
        exports.injectIntoGlobalHook = injectIntoGlobalHook;
        exports.isLikelyComponentType = isLikelyComponentType;
        exports.performReactRefresh = performReactRefresh;
        exports.register = register;
        exports.setSignature = setSignature;
    })();
}
}}),
"[project]/node_modules/next/dist/compiled/react-refresh/runtime.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
else {
    module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react-refresh/cjs/react-refresh-runtime.development.js [app-client] (ecmascript)");
}
}}),
"[project]/node_modules/next/dist/compiled/@next/react-refresh-utils/dist/internal/helpers.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/**
 * MIT License
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */ var __importDefault = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
// This file is copied from the Metro JavaScript bundler, with minor tweaks for
// webpack 4 compatibility.
//
// https://github.com/facebook/metro/blob/d6b9685c730d0d63577db40f41369157f28dfa3a/packages/metro/src/lib/polyfills/require.js
const runtime_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/react-refresh/runtime.js [app-client] (ecmascript)"));
function isSafeExport(key) {
    return key === '__esModule' || key === '__N_SSG' || key === '__N_SSP' || // TODO: remove this key from page config instead of allow listing it
    key === 'config';
}
function registerExportsForReactRefresh(moduleExports, moduleID) {
    runtime_1.default.register(moduleExports, moduleID + ' %exports%');
    if (moduleExports == null || typeof moduleExports !== 'object') {
        // Exit if we can't iterate over exports.
        // (This is important for legacy environments.)
        return;
    }
    for(var key in moduleExports){
        if (isSafeExport(key)) {
            continue;
        }
        try {
            var exportValue = moduleExports[key];
        } catch (_a) {
            continue;
        }
        var typeID = moduleID + ' %exports% ' + key;
        runtime_1.default.register(exportValue, typeID);
    }
}
function getRefreshBoundarySignature(moduleExports) {
    var signature = [];
    signature.push(runtime_1.default.getFamilyByType(moduleExports));
    if (moduleExports == null || typeof moduleExports !== 'object') {
        // Exit if we can't iterate over exports.
        // (This is important for legacy environments.)
        return signature;
    }
    for(var key in moduleExports){
        if (isSafeExport(key)) {
            continue;
        }
        try {
            var exportValue = moduleExports[key];
        } catch (_a) {
            continue;
        }
        signature.push(key);
        signature.push(runtime_1.default.getFamilyByType(exportValue));
    }
    return signature;
}
function isReactRefreshBoundary(moduleExports) {
    if (runtime_1.default.isLikelyComponentType(moduleExports)) {
        return true;
    }
    if (moduleExports == null || typeof moduleExports !== 'object') {
        // Exit if we can't iterate over exports.
        return false;
    }
    var hasExports = false;
    var areAllExportsComponents = true;
    for(var key in moduleExports){
        hasExports = true;
        if (isSafeExport(key)) {
            continue;
        }
        try {
            var exportValue = moduleExports[key];
        } catch (_a) {
            // This might fail due to circular dependencies
            return false;
        }
        if (!runtime_1.default.isLikelyComponentType(exportValue)) {
            areAllExportsComponents = false;
        }
    }
    return hasExports && areAllExportsComponents;
}
function shouldInvalidateReactRefreshBoundary(prevSignature, nextSignature) {
    if (prevSignature.length !== nextSignature.length) {
        return true;
    }
    for(var i = 0; i < nextSignature.length; i++){
        if (prevSignature[i] !== nextSignature[i]) {
            return true;
        }
    }
    return false;
}
var isUpdateScheduled = false;
// This function aggregates updates from multiple modules into a single React Refresh call.
function scheduleUpdate() {
    if (isUpdateScheduled) {
        return;
    }
    isUpdateScheduled = true;
    function canApplyUpdate(status) {
        return status === 'idle';
    }
    function applyUpdate() {
        isUpdateScheduled = false;
        try {
            runtime_1.default.performReactRefresh();
        } catch (err) {
            console.warn('Warning: Failed to re-render. We will retry on the next Fast Refresh event.\n' + err);
        }
    }
    if (canApplyUpdate(module.hot.status())) {
        // Apply update on the next tick.
        Promise.resolve().then(()=>{
            applyUpdate();
        });
        return;
    }
    const statusHandler = (status)=>{
        if (canApplyUpdate(status)) {
            module.hot.removeStatusHandler(statusHandler);
            applyUpdate();
        }
    };
    // Apply update once the HMR runtime's status is idle.
    module.hot.addStatusHandler(statusHandler);
}
// Needs to be compatible with IE11
exports.default = {
    registerExportsForReactRefresh: registerExportsForReactRefresh,
    isReactRefreshBoundary: isReactRefreshBoundary,
    shouldInvalidateReactRefreshBoundary: shouldInvalidateReactRefreshBoundary,
    getRefreshBoundarySignature: getRefreshBoundarySignature,
    scheduleUpdate: scheduleUpdate
}; //# sourceMappingURL=helpers.js.map
}}),
"[project]/node_modules/next/dist/compiled/@next/react-refresh-utils/dist/runtime.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __importDefault = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
const runtime_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/react-refresh/runtime.js [app-client] (ecmascript)"));
const helpers_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/@next/react-refresh-utils/dist/internal/helpers.js [app-client] (ecmascript)"));
// Hook into ReactDOM initialization
runtime_1.default.injectIntoGlobalHook(self);
// Register global helpers
self.$RefreshHelpers$ = helpers_1.default;
// Register a helper for module execution interception
self.$RefreshInterceptModuleExecution$ = function(webpackModuleId) {
    var prevRefreshReg = self.$RefreshReg$;
    var prevRefreshSig = self.$RefreshSig$;
    self.$RefreshReg$ = function(type, id) {
        runtime_1.default.register(type, webpackModuleId + ' ' + id);
    };
    self.$RefreshSig$ = runtime_1.default.createSignatureFunctionForTransform;
    // Modeled after `useEffect` cleanup pattern:
    // https://react.dev/learn/synchronizing-with-effects#step-3-add-cleanup-if-needed
    return function() {
        self.$RefreshReg$ = prevRefreshReg;
        self.$RefreshSig$ = prevRefreshSig;
    };
}; //# sourceMappingURL=runtime.js.map
}}),
"[project]/node_modules/next/dist/compiled/react/cjs/react.development.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/**
 * @license React
 * react.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
"production" !== ("TURBOPACK compile-time value", "development") && function() {
    function defineDeprecationWarning(methodName, info) {
        Object.defineProperty(Component.prototype, methodName, {
            get: function() {
                console.warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
            }
        });
    }
    function getIteratorFn(maybeIterable) {
        if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
        maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
        return "function" === typeof maybeIterable ? maybeIterable : null;
    }
    function warnNoop(publicInstance, callerName) {
        publicInstance = (publicInstance = publicInstance.constructor) && (publicInstance.displayName || publicInstance.name) || "ReactClass";
        var warningKey = publicInstance + "." + callerName;
        didWarnStateUpdateForUnmountedComponent[warningKey] || (console.error("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, publicInstance), didWarnStateUpdateForUnmountedComponent[warningKey] = !0);
    }
    function Component(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
    }
    function ComponentDummy() {}
    function PureComponent(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
    }
    function noop() {}
    function testStringCoercion(value) {
        return "" + value;
    }
    function checkKeyStringCoercion(value) {
        try {
            testStringCoercion(value);
            var JSCompiler_inline_result = !1;
        } catch (e) {
            JSCompiler_inline_result = !0;
        }
        if (JSCompiler_inline_result) {
            JSCompiler_inline_result = console;
            var JSCompiler_temp_const = JSCompiler_inline_result.error;
            var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            JSCompiler_temp_const.call(JSCompiler_inline_result, "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", JSCompiler_inline_result$jscomp$0);
            return testStringCoercion(value);
        }
    }
    function getComponentNameFromType(type) {
        if (null == type) return null;
        if ("function" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        switch(type){
            case REACT_FRAGMENT_TYPE:
                return "Fragment";
            case REACT_PROFILER_TYPE:
                return "Profiler";
            case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
            case REACT_SUSPENSE_TYPE:
                return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
            case REACT_ACTIVITY_TYPE:
                return "Activity";
        }
        if ("object" === typeof type) switch("number" === typeof type.tag && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof){
            case REACT_PORTAL_TYPE:
                return "Portal";
            case REACT_CONTEXT_TYPE:
                return type.displayName || "Context";
            case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
                var innerType = type.render;
                type = type.displayName;
                type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                return type;
            case REACT_MEMO_TYPE:
                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
                innerType = type._payload;
                type = type._init;
                try {
                    return getComponentNameFromType(type(innerType));
                } catch (x) {}
        }
        return null;
    }
    function getTaskName(type) {
        if (type === REACT_FRAGMENT_TYPE) return "<>";
        if ("object" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE) return "<...>";
        try {
            var name = getComponentNameFromType(type);
            return name ? "<" + name + ">" : "<...>";
        } catch (x) {
            return "<...>";
        }
    }
    function getOwner() {
        var dispatcher = ReactSharedInternals.A;
        return null === dispatcher ? null : dispatcher.getOwner();
    }
    function UnknownOwner() {
        return Error("react-stack-top-frame");
    }
    function hasValidKey(config) {
        if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) return !1;
        }
        return void 0 !== config.key;
    }
    function defineKeyPropWarningGetter(props, displayName) {
        function warnAboutAccessingKey() {
            specialPropKeyWarningShown || (specialPropKeyWarningShown = !0, console.error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)", displayName));
        }
        warnAboutAccessingKey.isReactWarning = !0;
        Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: !0
        });
    }
    function elementRefGetterWithDeprecationWarning() {
        var componentName = getComponentNameFromType(this.type);
        didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = !0, console.error("Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."));
        componentName = this.props.ref;
        return void 0 !== componentName ? componentName : null;
    }
    function ReactElement(type, key, self, source, owner, props, debugStack, debugTask) {
        self = props.ref;
        type = {
            $$typeof: REACT_ELEMENT_TYPE,
            type: type,
            key: key,
            props: props,
            _owner: owner
        };
        null !== (void 0 !== self ? self : null) ? Object.defineProperty(type, "ref", {
            enumerable: !1,
            get: elementRefGetterWithDeprecationWarning
        }) : Object.defineProperty(type, "ref", {
            enumerable: !1,
            value: null
        });
        type._store = {};
        Object.defineProperty(type._store, "validated", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: 0
        });
        Object.defineProperty(type, "_debugInfo", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: null
        });
        Object.defineProperty(type, "_debugStack", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: debugStack
        });
        Object.defineProperty(type, "_debugTask", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: debugTask
        });
        Object.freeze && (Object.freeze(type.props), Object.freeze(type));
        return type;
    }
    function cloneAndReplaceKey(oldElement, newKey) {
        newKey = ReactElement(oldElement.type, newKey, void 0, void 0, oldElement._owner, oldElement.props, oldElement._debugStack, oldElement._debugTask);
        oldElement._store && (newKey._store.validated = oldElement._store.validated);
        return newKey;
    }
    function isValidElement(object) {
        return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
    }
    function escape(key) {
        var escaperLookup = {
            "=": "=0",
            ":": "=2"
        };
        return "$" + key.replace(/[=:]/g, function(match) {
            return escaperLookup[match];
        });
    }
    function getElementKey(element, index) {
        return "object" === typeof element && null !== element && null != element.key ? (checkKeyStringCoercion(element.key), escape("" + element.key)) : index.toString(36);
    }
    function resolveThenable(thenable) {
        switch(thenable.status){
            case "fulfilled":
                return thenable.value;
            case "rejected":
                throw thenable.reason;
            default:
                switch("string" === typeof thenable.status ? thenable.then(noop, noop) : (thenable.status = "pending", thenable.then(function(fulfilledValue) {
                    "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
                }, function(error) {
                    "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
                })), thenable.status){
                    case "fulfilled":
                        return thenable.value;
                    case "rejected":
                        throw thenable.reason;
                }
        }
        throw thenable;
    }
    function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
        var type = typeof children;
        if ("undefined" === type || "boolean" === type) children = null;
        var invokeCallback = !1;
        if (null === children) invokeCallback = !0;
        else switch(type){
            case "bigint":
            case "string":
            case "number":
                invokeCallback = !0;
                break;
            case "object":
                switch(children.$$typeof){
                    case REACT_ELEMENT_TYPE:
                    case REACT_PORTAL_TYPE:
                        invokeCallback = !0;
                        break;
                    case REACT_LAZY_TYPE:
                        return invokeCallback = children._init, mapIntoArray(invokeCallback(children._payload), array, escapedPrefix, nameSoFar, callback);
                }
        }
        if (invokeCallback) {
            invokeCallback = children;
            callback = callback(invokeCallback);
            var childKey = "" === nameSoFar ? "." + getElementKey(invokeCallback, 0) : nameSoFar;
            isArrayImpl(callback) ? (escapedPrefix = "", null != childKey && (escapedPrefix = childKey.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function(c) {
                return c;
            })) : null != callback && (isValidElement(callback) && (null != callback.key && (invokeCallback && invokeCallback.key === callback.key || checkKeyStringCoercion(callback.key)), escapedPrefix = cloneAndReplaceKey(callback, escapedPrefix + (null == callback.key || invokeCallback && invokeCallback.key === callback.key ? "" : ("" + callback.key).replace(userProvidedKeyEscapeRegex, "$&/") + "/") + childKey), "" !== nameSoFar && null != invokeCallback && isValidElement(invokeCallback) && null == invokeCallback.key && invokeCallback._store && !invokeCallback._store.validated && (escapedPrefix._store.validated = 2), callback = escapedPrefix), array.push(callback));
            return 1;
        }
        invokeCallback = 0;
        childKey = "" === nameSoFar ? "." : nameSoFar + ":";
        if (isArrayImpl(children)) for(var i = 0; i < children.length; i++)nameSoFar = children[i], type = childKey + getElementKey(nameSoFar, i), invokeCallback += mapIntoArray(nameSoFar, array, escapedPrefix, type, callback);
        else if (i = getIteratorFn(children), "function" === typeof i) for(i === children.entries && (didWarnAboutMaps || console.warn("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), didWarnAboutMaps = !0), children = i.call(children), i = 0; !(nameSoFar = children.next()).done;)nameSoFar = nameSoFar.value, type = childKey + getElementKey(nameSoFar, i++), invokeCallback += mapIntoArray(nameSoFar, array, escapedPrefix, type, callback);
        else if ("object" === type) {
            if ("function" === typeof children.then) return mapIntoArray(resolveThenable(children), array, escapedPrefix, nameSoFar, callback);
            array = String(children);
            throw Error("Objects are not valid as a React child (found: " + ("[object Object]" === array ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead.");
        }
        return invokeCallback;
    }
    function mapChildren(children, func, context) {
        if (null == children) return children;
        var result = [], count = 0;
        mapIntoArray(children, result, "", "", function(child) {
            return func.call(context, child, count++);
        });
        return result;
    }
    function lazyInitializer(payload) {
        if (-1 === payload._status) {
            var ctor = payload._result;
            ctor = ctor();
            ctor.then(function(moduleObject) {
                if (0 === payload._status || -1 === payload._status) payload._status = 1, payload._result = moduleObject;
            }, function(error) {
                if (0 === payload._status || -1 === payload._status) payload._status = 2, payload._result = error;
            });
            -1 === payload._status && (payload._status = 0, payload._result = ctor);
        }
        if (1 === payload._status) return ctor = payload._result, void 0 === ctor && console.error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?", ctor), "default" in ctor || console.error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))", ctor), ctor.default;
        throw payload._result;
    }
    function resolveDispatcher() {
        var dispatcher = ReactSharedInternals.H;
        null === dispatcher && console.error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.");
        return dispatcher;
    }
    function releaseAsyncTransition() {
        ReactSharedInternals.asyncTransitions--;
    }
    function enqueueTask(task) {
        if (null === enqueueTaskImpl) try {
            var requireString = ("require" + Math.random()).slice(0, 7);
            enqueueTaskImpl = (module && module[requireString]).call(module, "timers").setImmediate;
        } catch (_err) {
            enqueueTaskImpl = function(callback) {
                !1 === didWarnAboutMessageChannel && (didWarnAboutMessageChannel = !0, "undefined" === typeof MessageChannel && console.error("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."));
                var channel = new MessageChannel();
                channel.port1.onmessage = callback;
                channel.port2.postMessage(void 0);
            };
        }
        return enqueueTaskImpl(task);
    }
    function aggregateErrors(errors) {
        return 1 < errors.length && "function" === typeof AggregateError ? new AggregateError(errors) : errors[0];
    }
    function popActScope(prevActQueue, prevActScopeDepth) {
        prevActScopeDepth !== actScopeDepth - 1 && console.error("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. ");
        actScopeDepth = prevActScopeDepth;
    }
    function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
        var queue = ReactSharedInternals.actQueue;
        if (null !== queue) if (0 !== queue.length) try {
            flushActQueue(queue);
            enqueueTask(function() {
                return recursivelyFlushAsyncActWork(returnValue, resolve, reject);
            });
            return;
        } catch (error) {
            ReactSharedInternals.thrownErrors.push(error);
        }
        else ReactSharedInternals.actQueue = null;
        0 < ReactSharedInternals.thrownErrors.length ? (queue = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, reject(queue)) : resolve(returnValue);
    }
    function flushActQueue(queue) {
        if (!isFlushing) {
            isFlushing = !0;
            var i = 0;
            try {
                for(; i < queue.length; i++){
                    var callback = queue[i];
                    do {
                        ReactSharedInternals.didUsePromise = !1;
                        var continuation = callback(!1);
                        if (null !== continuation) {
                            if (ReactSharedInternals.didUsePromise) {
                                queue[i] = callback;
                                queue.splice(0, i);
                                return;
                            }
                            callback = continuation;
                        } else break;
                    }while (1)
                }
                queue.length = 0;
            } catch (error) {
                queue.splice(0, i + 1), ReactSharedInternals.thrownErrors.push(error);
            } finally{
                isFlushing = !1;
            }
        }
    }
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, didWarnStateUpdateForUnmountedComponent = {}, ReactNoopUpdateQueue = {
        isMounted: function() {
            return !1;
        },
        enqueueForceUpdate: function(publicInstance) {
            warnNoop(publicInstance, "forceUpdate");
        },
        enqueueReplaceState: function(publicInstance) {
            warnNoop(publicInstance, "replaceState");
        },
        enqueueSetState: function(publicInstance) {
            warnNoop(publicInstance, "setState");
        }
    }, assign = Object.assign, emptyObject = {};
    Object.freeze(emptyObject);
    Component.prototype.isReactComponent = {};
    Component.prototype.setState = function(partialState, callback) {
        if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState) throw Error("takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, partialState, callback, "setState");
    };
    Component.prototype.forceUpdate = function(callback) {
        this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
    };
    var deprecatedAPIs = {
        isMounted: [
            "isMounted",
            "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."
        ],
        replaceState: [
            "replaceState",
            "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."
        ]
    }, fnName;
    for(fnName in deprecatedAPIs)deprecatedAPIs.hasOwnProperty(fnName) && defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    ComponentDummy.prototype = Component.prototype;
    deprecatedAPIs = PureComponent.prototype = new ComponentDummy();
    deprecatedAPIs.constructor = PureComponent;
    assign(deprecatedAPIs, Component.prototype);
    deprecatedAPIs.isPureReactComponent = !0;
    var isArrayImpl = Array.isArray, REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = {
        H: null,
        A: null,
        T: null,
        S: null,
        actQueue: null,
        asyncTransitions: 0,
        isBatchingLegacy: !1,
        didScheduleLegacyUpdate: !1,
        didUsePromise: !1,
        thrownErrors: [],
        getCurrentStack: null,
        recentlyCreatedOwnerStacks: 0
    }, hasOwnProperty = Object.prototype.hasOwnProperty, createTask = console.createTask ? console.createTask : function() {
        return null;
    };
    deprecatedAPIs = {
        react_stack_bottom_frame: function(callStackForError) {
            return callStackForError();
        }
    };
    var specialPropKeyWarningShown, didWarnAboutOldJSXRuntime;
    var didWarnAboutElementRef = {};
    var unknownOwnerDebugStack = deprecatedAPIs.react_stack_bottom_frame.bind(deprecatedAPIs, UnknownOwner)();
    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
    var didWarnAboutMaps = !1, userProvidedKeyEscapeRegex = /\/+/g, reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
        if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
            var event = new window.ErrorEvent("error", {
                bubbles: !0,
                cancelable: !0,
                message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
                error: error
            });
            if (!window.dispatchEvent(event)) return;
        } else if ("object" === typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] && "function" === typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].emit) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].emit("uncaughtException", error);
            return;
        }
        console.error(error);
    }, didWarnAboutMessageChannel = !1, enqueueTaskImpl = null, actScopeDepth = 0, didWarnNoAwaitAct = !1, isFlushing = !1, queueSeveralMicrotasks = "function" === typeof queueMicrotask ? function(callback) {
        queueMicrotask(function() {
            return queueMicrotask(callback);
        });
    } : enqueueTask;
    deprecatedAPIs = Object.freeze({
        __proto__: null,
        c: function(size) {
            return resolveDispatcher().useMemoCache(size);
        }
    });
    exports.Children = {
        map: mapChildren,
        forEach: function(children, forEachFunc, forEachContext) {
            mapChildren(children, function() {
                forEachFunc.apply(this, arguments);
            }, forEachContext);
        },
        count: function(children) {
            var n = 0;
            mapChildren(children, function() {
                n++;
            });
            return n;
        },
        toArray: function(children) {
            return mapChildren(children, function(child) {
                return child;
            }) || [];
        },
        only: function(children) {
            if (!isValidElement(children)) throw Error("React.Children.only expected to receive a single React element child.");
            return children;
        }
    };
    exports.Component = Component;
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.Profiler = REACT_PROFILER_TYPE;
    exports.PureComponent = PureComponent;
    exports.StrictMode = REACT_STRICT_MODE_TYPE;
    exports.Suspense = REACT_SUSPENSE_TYPE;
    exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
    exports.__COMPILER_RUNTIME = deprecatedAPIs;
    exports.act = function(callback) {
        var prevActQueue = ReactSharedInternals.actQueue, prevActScopeDepth = actScopeDepth;
        actScopeDepth++;
        var queue = ReactSharedInternals.actQueue = null !== prevActQueue ? prevActQueue : [], didAwaitActCall = !1;
        try {
            var result = callback();
        } catch (error) {
            ReactSharedInternals.thrownErrors.push(error);
        }
        if (0 < ReactSharedInternals.thrownErrors.length) throw popActScope(prevActQueue, prevActScopeDepth), callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
        if (null !== result && "object" === typeof result && "function" === typeof result.then) {
            var thenable = result;
            queueSeveralMicrotasks(function() {
                didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = !0, console.error("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"));
            });
            return {
                then: function(resolve, reject) {
                    didAwaitActCall = !0;
                    thenable.then(function(returnValue) {
                        popActScope(prevActQueue, prevActScopeDepth);
                        if (0 === prevActScopeDepth) {
                            try {
                                flushActQueue(queue), enqueueTask(function() {
                                    return recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                                });
                            } catch (error$0) {
                                ReactSharedInternals.thrownErrors.push(error$0);
                            }
                            if (0 < ReactSharedInternals.thrownErrors.length) {
                                var _thrownError = aggregateErrors(ReactSharedInternals.thrownErrors);
                                ReactSharedInternals.thrownErrors.length = 0;
                                reject(_thrownError);
                            }
                        } else resolve(returnValue);
                    }, function(error) {
                        popActScope(prevActQueue, prevActScopeDepth);
                        0 < ReactSharedInternals.thrownErrors.length ? (error = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, reject(error)) : reject(error);
                    });
                }
            };
        }
        var returnValue$jscomp$0 = result;
        popActScope(prevActQueue, prevActScopeDepth);
        0 === prevActScopeDepth && (flushActQueue(queue), 0 !== queue.length && queueSeveralMicrotasks(function() {
            didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = !0, console.error("A component suspended inside an `act` scope, but the `act` call was not awaited. When testing React components that depend on asynchronous data, you must await the result:\n\nawait act(() => ...)"));
        }), ReactSharedInternals.actQueue = null);
        if (0 < ReactSharedInternals.thrownErrors.length) throw callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
        return {
            then: function(resolve, reject) {
                didAwaitActCall = !0;
                0 === prevActScopeDepth ? (ReactSharedInternals.actQueue = queue, enqueueTask(function() {
                    return recursivelyFlushAsyncActWork(returnValue$jscomp$0, resolve, reject);
                })) : resolve(returnValue$jscomp$0);
            }
        };
    };
    exports.cache = function(fn) {
        return function() {
            return fn.apply(null, arguments);
        };
    };
    exports.cacheSignal = function() {
        return null;
    };
    exports.captureOwnerStack = function() {
        var getCurrentStack = ReactSharedInternals.getCurrentStack;
        return null === getCurrentStack ? null : getCurrentStack();
    };
    exports.cloneElement = function(element, config, children) {
        if (null === element || void 0 === element) throw Error("The argument must be a React element, but you passed " + element + ".");
        var props = assign({}, element.props), key = element.key, owner = element._owner;
        if (null != config) {
            var JSCompiler_inline_result;
            a: {
                if (hasOwnProperty.call(config, "ref") && (JSCompiler_inline_result = Object.getOwnPropertyDescriptor(config, "ref").get) && JSCompiler_inline_result.isReactWarning) {
                    JSCompiler_inline_result = !1;
                    break a;
                }
                JSCompiler_inline_result = void 0 !== config.ref;
            }
            JSCompiler_inline_result && (owner = getOwner());
            hasValidKey(config) && (checkKeyStringCoercion(config.key), key = "" + config.key);
            for(propName in config)!hasOwnProperty.call(config, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config.ref || (props[propName] = config[propName]);
        }
        var propName = arguments.length - 2;
        if (1 === propName) props.children = children;
        else if (1 < propName) {
            JSCompiler_inline_result = Array(propName);
            for(var i = 0; i < propName; i++)JSCompiler_inline_result[i] = arguments[i + 2];
            props.children = JSCompiler_inline_result;
        }
        props = ReactElement(element.type, key, void 0, void 0, owner, props, element._debugStack, element._debugTask);
        for(key = 2; key < arguments.length; key++)owner = arguments[key], isValidElement(owner) && owner._store && (owner._store.validated = 1);
        return props;
    };
    exports.createContext = function(defaultValue) {
        defaultValue = {
            $$typeof: REACT_CONTEXT_TYPE,
            _currentValue: defaultValue,
            _currentValue2: defaultValue,
            _threadCount: 0,
            Provider: null,
            Consumer: null
        };
        defaultValue.Provider = defaultValue;
        defaultValue.Consumer = {
            $$typeof: REACT_CONSUMER_TYPE,
            _context: defaultValue
        };
        defaultValue._currentRenderer = null;
        defaultValue._currentRenderer2 = null;
        return defaultValue;
    };
    exports.createElement = function(type, config, children) {
        for(var i = 2; i < arguments.length; i++){
            var node = arguments[i];
            isValidElement(node) && node._store && (node._store.validated = 1);
        }
        i = {};
        node = null;
        if (null != config) for(propName in didWarnAboutOldJSXRuntime || !("__self" in config) || "key" in config || (didWarnAboutOldJSXRuntime = !0, console.warn("Your app (or one of its dependencies) is using an outdated JSX transform. Update to the modern JSX transform for faster performance: https://react.dev/link/new-jsx-transform")), hasValidKey(config) && (checkKeyStringCoercion(config.key), node = "" + config.key), config)hasOwnProperty.call(config, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (i[propName] = config[propName]);
        var childrenLength = arguments.length - 2;
        if (1 === childrenLength) i.children = children;
        else if (1 < childrenLength) {
            for(var childArray = Array(childrenLength), _i = 0; _i < childrenLength; _i++)childArray[_i] = arguments[_i + 2];
            Object.freeze && Object.freeze(childArray);
            i.children = childArray;
        }
        if (type && type.defaultProps) for(propName in childrenLength = type.defaultProps, childrenLength)void 0 === i[propName] && (i[propName] = childrenLength[propName]);
        node && defineKeyPropWarningGetter(i, "function" === typeof type ? type.displayName || type.name || "Unknown" : type);
        var propName = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
        return ReactElement(type, node, void 0, void 0, getOwner(), i, propName ? Error("react-stack-top-frame") : unknownOwnerDebugStack, propName ? createTask(getTaskName(type)) : unknownOwnerDebugTask);
    };
    exports.createRef = function() {
        var refObject = {
            current: null
        };
        Object.seal(refObject);
        return refObject;
    };
    exports.forwardRef = function(render) {
        null != render && render.$$typeof === REACT_MEMO_TYPE ? console.error("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).") : "function" !== typeof render ? console.error("forwardRef requires a render function but was given %s.", null === render ? "null" : typeof render) : 0 !== render.length && 2 !== render.length && console.error("forwardRef render functions accept exactly two parameters: props and ref. %s", 1 === render.length ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
        null != render && null != render.defaultProps && console.error("forwardRef render functions do not support defaultProps. Did you accidentally pass a React component?");
        var elementType = {
            $$typeof: REACT_FORWARD_REF_TYPE,
            render: render
        }, ownName;
        Object.defineProperty(elementType, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
                return ownName;
            },
            set: function(name) {
                ownName = name;
                render.name || render.displayName || (Object.defineProperty(render, "name", {
                    value: name
                }), render.displayName = name);
            }
        });
        return elementType;
    };
    exports.isValidElement = isValidElement;
    exports.lazy = function(ctor) {
        return {
            $$typeof: REACT_LAZY_TYPE,
            _payload: {
                _status: -1,
                _result: ctor
            },
            _init: lazyInitializer
        };
    };
    exports.memo = function(type, compare) {
        null == type && console.error("memo: The first argument must be a component. Instead received: %s", null === type ? "null" : typeof type);
        compare = {
            $$typeof: REACT_MEMO_TYPE,
            type: type,
            compare: void 0 === compare ? null : compare
        };
        var ownName;
        Object.defineProperty(compare, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
                return ownName;
            },
            set: function(name) {
                ownName = name;
                type.name || type.displayName || (Object.defineProperty(type, "name", {
                    value: name
                }), type.displayName = name);
            }
        });
        return compare;
    };
    exports.startTransition = function(scope) {
        var prevTransition = ReactSharedInternals.T, currentTransition = {};
        currentTransition._updatedFibers = new Set();
        ReactSharedInternals.T = currentTransition;
        try {
            var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
            null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
            "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && (ReactSharedInternals.asyncTransitions++, returnValue.then(releaseAsyncTransition, releaseAsyncTransition), returnValue.then(noop, reportGlobalError));
        } catch (error) {
            reportGlobalError(error);
        } finally{
            null === prevTransition && currentTransition._updatedFibers && (scope = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < scope && console.warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.")), null !== prevTransition && null !== currentTransition.types && (null !== prevTransition.types && prevTransition.types !== currentTransition.types && console.error("We expected inner Transitions to have transferred the outer types set and that you cannot add to the outer Transition while inside the inner.This is a bug in React."), prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
        }
    };
    exports.unstable_useCacheRefresh = function() {
        return resolveDispatcher().useCacheRefresh();
    };
    exports.use = function(usable) {
        return resolveDispatcher().use(usable);
    };
    exports.useActionState = function(action, initialState, permalink) {
        return resolveDispatcher().useActionState(action, initialState, permalink);
    };
    exports.useCallback = function(callback, deps) {
        return resolveDispatcher().useCallback(callback, deps);
    };
    exports.useContext = function(Context) {
        var dispatcher = resolveDispatcher();
        Context.$$typeof === REACT_CONSUMER_TYPE && console.error("Calling useContext(Context.Consumer) is not supported and will cause bugs. Did you mean to call useContext(Context) instead?");
        return dispatcher.useContext(Context);
    };
    exports.useDebugValue = function(value, formatterFn) {
        return resolveDispatcher().useDebugValue(value, formatterFn);
    };
    exports.useDeferredValue = function(value, initialValue) {
        return resolveDispatcher().useDeferredValue(value, initialValue);
    };
    exports.useEffect = function(create, deps) {
        null == create && console.warn("React Hook useEffect requires an effect callback. Did you forget to pass a callback to the hook?");
        return resolveDispatcher().useEffect(create, deps);
    };
    exports.useId = function() {
        return resolveDispatcher().useId();
    };
    exports.useImperativeHandle = function(ref, create, deps) {
        return resolveDispatcher().useImperativeHandle(ref, create, deps);
    };
    exports.useInsertionEffect = function(create, deps) {
        null == create && console.warn("React Hook useInsertionEffect requires an effect callback. Did you forget to pass a callback to the hook?");
        return resolveDispatcher().useInsertionEffect(create, deps);
    };
    exports.useLayoutEffect = function(create, deps) {
        null == create && console.warn("React Hook useLayoutEffect requires an effect callback. Did you forget to pass a callback to the hook?");
        return resolveDispatcher().useLayoutEffect(create, deps);
    };
    exports.useMemo = function(create, deps) {
        return resolveDispatcher().useMemo(create, deps);
    };
    exports.useOptimistic = function(passthrough, reducer) {
        return resolveDispatcher().useOptimistic(passthrough, reducer);
    };
    exports.useReducer = function(reducer, initialArg, init) {
        return resolveDispatcher().useReducer(reducer, initialArg, init);
    };
    exports.useRef = function(initialValue) {
        return resolveDispatcher().useRef(initialValue);
    };
    exports.useState = function(initialState) {
        return resolveDispatcher().useState(initialState);
    };
    exports.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
        return resolveDispatcher().useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
    };
    exports.useTransition = function() {
        return resolveDispatcher().useTransition();
    };
    exports.version = "19.2.0-canary-97cdd5d3-20250710";
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
}();
}}),
"[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
else {
    module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/cjs/react.development.js [app-client] (ecmascript)");
}
}}),
"[project]/node_modules/next/dist/compiled/react/cjs/react-jsx-runtime.development.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
"production" !== ("TURBOPACK compile-time value", "development") && function() {
    function getComponentNameFromType(type) {
        if (null == type) return null;
        if ("function" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        switch(type){
            case REACT_FRAGMENT_TYPE:
                return "Fragment";
            case REACT_PROFILER_TYPE:
                return "Profiler";
            case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
            case REACT_SUSPENSE_TYPE:
                return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
            case REACT_ACTIVITY_TYPE:
                return "Activity";
        }
        if ("object" === typeof type) switch("number" === typeof type.tag && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof){
            case REACT_PORTAL_TYPE:
                return "Portal";
            case REACT_CONTEXT_TYPE:
                return type.displayName || "Context";
            case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
                var innerType = type.render;
                type = type.displayName;
                type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                return type;
            case REACT_MEMO_TYPE:
                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
                innerType = type._payload;
                type = type._init;
                try {
                    return getComponentNameFromType(type(innerType));
                } catch (x) {}
        }
        return null;
    }
    function testStringCoercion(value) {
        return "" + value;
    }
    function checkKeyStringCoercion(value) {
        try {
            testStringCoercion(value);
            var JSCompiler_inline_result = !1;
        } catch (e) {
            JSCompiler_inline_result = !0;
        }
        if (JSCompiler_inline_result) {
            JSCompiler_inline_result = console;
            var JSCompiler_temp_const = JSCompiler_inline_result.error;
            var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            JSCompiler_temp_const.call(JSCompiler_inline_result, "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", JSCompiler_inline_result$jscomp$0);
            return testStringCoercion(value);
        }
    }
    function getTaskName(type) {
        if (type === REACT_FRAGMENT_TYPE) return "<>";
        if ("object" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE) return "<...>";
        try {
            var name = getComponentNameFromType(type);
            return name ? "<" + name + ">" : "<...>";
        } catch (x) {
            return "<...>";
        }
    }
    function getOwner() {
        var dispatcher = ReactSharedInternals.A;
        return null === dispatcher ? null : dispatcher.getOwner();
    }
    function UnknownOwner() {
        return Error("react-stack-top-frame");
    }
    function hasValidKey(config) {
        if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) return !1;
        }
        return void 0 !== config.key;
    }
    function defineKeyPropWarningGetter(props, displayName) {
        function warnAboutAccessingKey() {
            specialPropKeyWarningShown || (specialPropKeyWarningShown = !0, console.error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)", displayName));
        }
        warnAboutAccessingKey.isReactWarning = !0;
        Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: !0
        });
    }
    function elementRefGetterWithDeprecationWarning() {
        var componentName = getComponentNameFromType(this.type);
        didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = !0, console.error("Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."));
        componentName = this.props.ref;
        return void 0 !== componentName ? componentName : null;
    }
    function ReactElement(type, key, self, source, owner, props, debugStack, debugTask) {
        self = props.ref;
        type = {
            $$typeof: REACT_ELEMENT_TYPE,
            type: type,
            key: key,
            props: props,
            _owner: owner
        };
        null !== (void 0 !== self ? self : null) ? Object.defineProperty(type, "ref", {
            enumerable: !1,
            get: elementRefGetterWithDeprecationWarning
        }) : Object.defineProperty(type, "ref", {
            enumerable: !1,
            value: null
        });
        type._store = {};
        Object.defineProperty(type._store, "validated", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: 0
        });
        Object.defineProperty(type, "_debugInfo", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: null
        });
        Object.defineProperty(type, "_debugStack", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: debugStack
        });
        Object.defineProperty(type, "_debugTask", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: debugTask
        });
        Object.freeze && (Object.freeze(type.props), Object.freeze(type));
        return type;
    }
    function jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self, debugStack, debugTask) {
        var children = config.children;
        if (void 0 !== children) if (isStaticChildren) if (isArrayImpl(children)) {
            for(isStaticChildren = 0; isStaticChildren < children.length; isStaticChildren++)validateChildKeys(children[isStaticChildren]);
            Object.freeze && Object.freeze(children);
        } else console.error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
        else validateChildKeys(children);
        if (hasOwnProperty.call(config, "key")) {
            children = getComponentNameFromType(type);
            var keys = Object.keys(config).filter(function(k) {
                return "key" !== k;
            });
            isStaticChildren = 0 < keys.length ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
            didWarnAboutKeySpread[children + isStaticChildren] || (keys = 0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}", console.error('A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />', isStaticChildren, children, keys, children), didWarnAboutKeySpread[children + isStaticChildren] = !0);
        }
        children = null;
        void 0 !== maybeKey && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey);
        hasValidKey(config) && (checkKeyStringCoercion(config.key), children = "" + config.key);
        if ("key" in config) {
            maybeKey = {};
            for(var propName in config)"key" !== propName && (maybeKey[propName] = config[propName]);
        } else maybeKey = config;
        children && defineKeyPropWarningGetter(maybeKey, "function" === typeof type ? type.displayName || type.name || "Unknown" : type);
        return ReactElement(type, children, self, source, getOwner(), maybeKey, debugStack, debugTask);
    }
    function validateChildKeys(node) {
        "object" === typeof node && null !== node && node.$$typeof === REACT_ELEMENT_TYPE && node._store && (node._store.validated = 1);
    }
    var React = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, hasOwnProperty = Object.prototype.hasOwnProperty, isArrayImpl = Array.isArray, createTask = console.createTask ? console.createTask : function() {
        return null;
    };
    React = {
        react_stack_bottom_frame: function(callStackForError) {
            return callStackForError();
        }
    };
    var specialPropKeyWarningShown;
    var didWarnAboutElementRef = {};
    var unknownOwnerDebugStack = React.react_stack_bottom_frame.bind(React, UnknownOwner)();
    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
    var didWarnAboutKeySpread = {};
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.jsx = function(type, config, maybeKey, source, self) {
        var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
        return jsxDEVImpl(type, config, maybeKey, !1, source, self, trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack, trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask);
    };
    exports.jsxs = function(type, config, maybeKey, source, self) {
        var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
        return jsxDEVImpl(type, config, maybeKey, !0, source, self, trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack, trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask);
    };
}();
}}),
"[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
else {
    module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/cjs/react-jsx-runtime.development.js [app-client] (ecmascript)");
}
}}),
"[project]/node_modules/next/dist/compiled/safe-stable-stringify/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
(function() {
    "use strict";
    var e = {
        879: function(e, t) {
            const { hasOwnProperty: n } = Object.prototype;
            const r = configure();
            r.configure = configure;
            r.stringify = r;
            r.default = r;
            t.stringify = r;
            t.configure = configure;
            e.exports = r;
            const i = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/;
            function strEscape(e) {
                if (e.length < 5e3 && !i.test(e)) {
                    return '"'.concat(e, '"');
                }
                return JSON.stringify(e);
            }
            function sort(e, t) {
                if (e.length > 200 || t) {
                    return e.sort(t);
                }
                for(let t = 1; t < e.length; t++){
                    const n = e[t];
                    let r = t;
                    while(r !== 0 && e[r - 1] > n){
                        e[r] = e[r - 1];
                        r--;
                    }
                    e[r] = n;
                }
                return e;
            }
            const f = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Object.getPrototypeOf(new Int8Array)), Symbol.toStringTag).get;
            function isTypedArrayWithEntries(e) {
                return f.call(e) !== undefined && e.length !== 0;
            }
            function stringifyTypedArray(e, t, n) {
                if (e.length < n) {
                    n = e.length;
                }
                const r = t === "," ? "" : " ";
                let i = '"0":'.concat(r).concat(e[0]);
                for(let f = 1; f < n; f++){
                    i += "".concat(t, '"').concat(f, '":').concat(r).concat(e[f]);
                }
                return i;
            }
            function getCircularValueOption(e) {
                if (n.call(e, "circularValue")) {
                    const t = e.circularValue;
                    if (typeof t === "string") {
                        return '"'.concat(t, '"');
                    }
                    if (t == null) {
                        return t;
                    }
                    if (t === Error || t === TypeError) {
                        return {
                            toString () {
                                throw new TypeError("Converting circular structure to JSON");
                            }
                        };
                    }
                    throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined');
                }
                return '"[Circular]"';
            }
            function getDeterministicOption(e) {
                let t;
                if (n.call(e, "deterministic")) {
                    t = e.deterministic;
                    if (typeof t !== "boolean" && typeof t !== "function") {
                        throw new TypeError('The "deterministic" argument must be of type boolean or comparator function');
                    }
                }
                return t === undefined ? true : t;
            }
            function getBooleanOption(e, t) {
                let r;
                if (n.call(e, t)) {
                    r = e[t];
                    if (typeof r !== "boolean") {
                        throw new TypeError('The "'.concat(t, '" argument must be of type boolean'));
                    }
                }
                return r === undefined ? true : r;
            }
            function getPositiveIntegerOption(e, t) {
                let r;
                if (n.call(e, t)) {
                    r = e[t];
                    if (typeof r !== "number") {
                        throw new TypeError('The "'.concat(t, '" argument must be of type number'));
                    }
                    if (!Number.isInteger(r)) {
                        throw new TypeError('The "'.concat(t, '" argument must be an integer'));
                    }
                    if (r < 1) {
                        throw new RangeError('The "'.concat(t, '" argument must be >= 1'));
                    }
                }
                return r === undefined ? Infinity : r;
            }
            function getItemCount(e) {
                if (e === 1) {
                    return "1 item";
                }
                return "".concat(e, " items");
            }
            function getUniqueReplacerSet(e) {
                const t = new Set;
                for (const n of e){
                    if (typeof n === "string" || typeof n === "number") {
                        t.add(String(n));
                    }
                }
                return t;
            }
            function getStrictOption(e) {
                if (n.call(e, "strict")) {
                    const t = e.strict;
                    if (typeof t !== "boolean") {
                        throw new TypeError('The "strict" argument must be of type boolean');
                    }
                    if (t) {
                        return (e)=>{
                            let t = "Object can not safely be stringified. Received type ".concat(typeof e);
                            if (typeof e !== "function") t += " (".concat(e.toString(), ")");
                            throw new Error(t);
                        };
                    }
                }
            }
            function configure(e) {
                e = {
                    ...e
                };
                const t = getStrictOption(e);
                if (t) {
                    if (e.bigint === undefined) {
                        e.bigint = false;
                    }
                    if (!("circularValue" in e)) {
                        e.circularValue = Error;
                    }
                }
                const n = getCircularValueOption(e);
                const r = getBooleanOption(e, "bigint");
                const i = getDeterministicOption(e);
                const f = typeof i === "function" ? i : undefined;
                const u = getPositiveIntegerOption(e, "maximumDepth");
                const o = getPositiveIntegerOption(e, "maximumBreadth");
                function stringifyFnReplacer(e, s, l, c, a, g) {
                    let p = s[e];
                    if (typeof p === "object" && p !== null && typeof p.toJSON === "function") {
                        p = p.toJSON(e);
                    }
                    p = c.call(s, e, p);
                    switch(typeof p){
                        case "string":
                            return strEscape(p);
                        case "object":
                            {
                                if (p === null) {
                                    return "null";
                                }
                                if (l.indexOf(p) !== -1) {
                                    return n;
                                }
                                let e = "";
                                let t = ",";
                                const r = g;
                                if (Array.isArray(p)) {
                                    if (p.length === 0) {
                                        return "[]";
                                    }
                                    if (u < l.length + 1) {
                                        return '"[Array]"';
                                    }
                                    l.push(p);
                                    if (a !== "") {
                                        g += a;
                                        e += "\n".concat(g);
                                        t = ",\n".concat(g);
                                    }
                                    const n = Math.min(p.length, o);
                                    let i = 0;
                                    for(; i < n - 1; i++){
                                        const n = stringifyFnReplacer(String(i), p, l, c, a, g);
                                        e += n !== undefined ? n : "null";
                                        e += t;
                                    }
                                    const f = stringifyFnReplacer(String(i), p, l, c, a, g);
                                    e += f !== undefined ? f : "null";
                                    if (p.length - 1 > o) {
                                        const n = p.length - o - 1;
                                        e += "".concat(t, '"... ').concat(getItemCount(n), ' not stringified"');
                                    }
                                    if (a !== "") {
                                        e += "\n".concat(r);
                                    }
                                    l.pop();
                                    return "[".concat(e, "]");
                                }
                                let s = Object.keys(p);
                                const y = s.length;
                                if (y === 0) {
                                    return "{}";
                                }
                                if (u < l.length + 1) {
                                    return '"[Object]"';
                                }
                                let d = "";
                                let h = "";
                                if (a !== "") {
                                    g += a;
                                    t = ",\n".concat(g);
                                    d = " ";
                                }
                                const $ = Math.min(y, o);
                                if (i && !isTypedArrayWithEntries(p)) {
                                    s = sort(s, f);
                                }
                                l.push(p);
                                for(let n = 0; n < $; n++){
                                    const r = s[n];
                                    const i = stringifyFnReplacer(r, p, l, c, a, g);
                                    if (i !== undefined) {
                                        e += "".concat(h).concat(strEscape(r), ":").concat(d).concat(i);
                                        h = t;
                                    }
                                }
                                if (y > o) {
                                    const n = y - o;
                                    e += "".concat(h, '"...":').concat(d, '"').concat(getItemCount(n), ' not stringified"');
                                    h = t;
                                }
                                if (a !== "" && h.length > 1) {
                                    e = "\n".concat(g).concat(e, "\n").concat(r);
                                }
                                l.pop();
                                return "{".concat(e, "}");
                            }
                        case "number":
                            return isFinite(p) ? String(p) : t ? t(p) : "null";
                        case "boolean":
                            return p === true ? "true" : "false";
                        case "undefined":
                            return undefined;
                        case "bigint":
                            if (r) {
                                return String(p);
                            }
                        default:
                            return t ? t(p) : undefined;
                    }
                }
                function stringifyArrayReplacer(e, i, f, s, l, c) {
                    if (typeof i === "object" && i !== null && typeof i.toJSON === "function") {
                        i = i.toJSON(e);
                    }
                    switch(typeof i){
                        case "string":
                            return strEscape(i);
                        case "object":
                            {
                                if (i === null) {
                                    return "null";
                                }
                                if (f.indexOf(i) !== -1) {
                                    return n;
                                }
                                const e = c;
                                let t = "";
                                let r = ",";
                                if (Array.isArray(i)) {
                                    if (i.length === 0) {
                                        return "[]";
                                    }
                                    if (u < f.length + 1) {
                                        return '"[Array]"';
                                    }
                                    f.push(i);
                                    if (l !== "") {
                                        c += l;
                                        t += "\n".concat(c);
                                        r = ",\n".concat(c);
                                    }
                                    const n = Math.min(i.length, o);
                                    let a = 0;
                                    for(; a < n - 1; a++){
                                        const e = stringifyArrayReplacer(String(a), i[a], f, s, l, c);
                                        t += e !== undefined ? e : "null";
                                        t += r;
                                    }
                                    const g = stringifyArrayReplacer(String(a), i[a], f, s, l, c);
                                    t += g !== undefined ? g : "null";
                                    if (i.length - 1 > o) {
                                        const e = i.length - o - 1;
                                        t += "".concat(r, '"... ').concat(getItemCount(e), ' not stringified"');
                                    }
                                    if (l !== "") {
                                        t += "\n".concat(e);
                                    }
                                    f.pop();
                                    return "[".concat(t, "]");
                                }
                                f.push(i);
                                let a = "";
                                if (l !== "") {
                                    c += l;
                                    r = ",\n".concat(c);
                                    a = " ";
                                }
                                let g = "";
                                for (const e of s){
                                    const n = stringifyArrayReplacer(e, i[e], f, s, l, c);
                                    if (n !== undefined) {
                                        t += "".concat(g).concat(strEscape(e), ":").concat(a).concat(n);
                                        g = r;
                                    }
                                }
                                if (l !== "" && g.length > 1) {
                                    t = "\n".concat(c).concat(t, "\n").concat(e);
                                }
                                f.pop();
                                return "{".concat(t, "}");
                            }
                        case "number":
                            return isFinite(i) ? String(i) : t ? t(i) : "null";
                        case "boolean":
                            return i === true ? "true" : "false";
                        case "undefined":
                            return undefined;
                        case "bigint":
                            if (r) {
                                return String(i);
                            }
                        default:
                            return t ? t(i) : undefined;
                    }
                }
                function stringifyIndent(e, s, l, c, a) {
                    switch(typeof s){
                        case "string":
                            return strEscape(s);
                        case "object":
                            {
                                if (s === null) {
                                    return "null";
                                }
                                if (typeof s.toJSON === "function") {
                                    s = s.toJSON(e);
                                    if (typeof s !== "object") {
                                        return stringifyIndent(e, s, l, c, a);
                                    }
                                    if (s === null) {
                                        return "null";
                                    }
                                }
                                if (l.indexOf(s) !== -1) {
                                    return n;
                                }
                                const t = a;
                                if (Array.isArray(s)) {
                                    if (s.length === 0) {
                                        return "[]";
                                    }
                                    if (u < l.length + 1) {
                                        return '"[Array]"';
                                    }
                                    l.push(s);
                                    a += c;
                                    let e = "\n".concat(a);
                                    const n = ",\n".concat(a);
                                    const r = Math.min(s.length, o);
                                    let i = 0;
                                    for(; i < r - 1; i++){
                                        const t = stringifyIndent(String(i), s[i], l, c, a);
                                        e += t !== undefined ? t : "null";
                                        e += n;
                                    }
                                    const f = stringifyIndent(String(i), s[i], l, c, a);
                                    e += f !== undefined ? f : "null";
                                    if (s.length - 1 > o) {
                                        const t = s.length - o - 1;
                                        e += "".concat(n, '"... ').concat(getItemCount(t), ' not stringified"');
                                    }
                                    e += "\n".concat(t);
                                    l.pop();
                                    return "[".concat(e, "]");
                                }
                                let r = Object.keys(s);
                                const g = r.length;
                                if (g === 0) {
                                    return "{}";
                                }
                                if (u < l.length + 1) {
                                    return '"[Object]"';
                                }
                                a += c;
                                const p = ",\n".concat(a);
                                let y = "";
                                let d = "";
                                let h = Math.min(g, o);
                                if (isTypedArrayWithEntries(s)) {
                                    y += stringifyTypedArray(s, p, o);
                                    r = r.slice(s.length);
                                    h -= s.length;
                                    d = p;
                                }
                                if (i) {
                                    r = sort(r, f);
                                }
                                l.push(s);
                                for(let e = 0; e < h; e++){
                                    const t = r[e];
                                    const n = stringifyIndent(t, s[t], l, c, a);
                                    if (n !== undefined) {
                                        y += "".concat(d).concat(strEscape(t), ": ").concat(n);
                                        d = p;
                                    }
                                }
                                if (g > o) {
                                    const e = g - o;
                                    y += "".concat(d, '"...": "').concat(getItemCount(e), ' not stringified"');
                                    d = p;
                                }
                                if (d !== "") {
                                    y = "\n".concat(a).concat(y, "\n").concat(t);
                                }
                                l.pop();
                                return "{".concat(y, "}");
                            }
                        case "number":
                            return isFinite(s) ? String(s) : t ? t(s) : "null";
                        case "boolean":
                            return s === true ? "true" : "false";
                        case "undefined":
                            return undefined;
                        case "bigint":
                            if (r) {
                                return String(s);
                            }
                        default:
                            return t ? t(s) : undefined;
                    }
                }
                function stringifySimple(e, s, l) {
                    switch(typeof s){
                        case "string":
                            return strEscape(s);
                        case "object":
                            {
                                if (s === null) {
                                    return "null";
                                }
                                if (typeof s.toJSON === "function") {
                                    s = s.toJSON(e);
                                    if (typeof s !== "object") {
                                        return stringifySimple(e, s, l);
                                    }
                                    if (s === null) {
                                        return "null";
                                    }
                                }
                                if (l.indexOf(s) !== -1) {
                                    return n;
                                }
                                let t = "";
                                const r = s.length !== undefined;
                                if (r && Array.isArray(s)) {
                                    if (s.length === 0) {
                                        return "[]";
                                    }
                                    if (u < l.length + 1) {
                                        return '"[Array]"';
                                    }
                                    l.push(s);
                                    const e = Math.min(s.length, o);
                                    let n = 0;
                                    for(; n < e - 1; n++){
                                        const e = stringifySimple(String(n), s[n], l);
                                        t += e !== undefined ? e : "null";
                                        t += ",";
                                    }
                                    const r = stringifySimple(String(n), s[n], l);
                                    t += r !== undefined ? r : "null";
                                    if (s.length - 1 > o) {
                                        const e = s.length - o - 1;
                                        t += ',"... '.concat(getItemCount(e), ' not stringified"');
                                    }
                                    l.pop();
                                    return "[".concat(t, "]");
                                }
                                let c = Object.keys(s);
                                const a = c.length;
                                if (a === 0) {
                                    return "{}";
                                }
                                if (u < l.length + 1) {
                                    return '"[Object]"';
                                }
                                let g = "";
                                let p = Math.min(a, o);
                                if (r && isTypedArrayWithEntries(s)) {
                                    t += stringifyTypedArray(s, ",", o);
                                    c = c.slice(s.length);
                                    p -= s.length;
                                    g = ",";
                                }
                                if (i) {
                                    c = sort(c, f);
                                }
                                l.push(s);
                                for(let e = 0; e < p; e++){
                                    const n = c[e];
                                    const r = stringifySimple(n, s[n], l);
                                    if (r !== undefined) {
                                        t += "".concat(g).concat(strEscape(n), ":").concat(r);
                                        g = ",";
                                    }
                                }
                                if (a > o) {
                                    const e = a - o;
                                    t += "".concat(g, '"...":"').concat(getItemCount(e), ' not stringified"');
                                }
                                l.pop();
                                return "{".concat(t, "}");
                            }
                        case "number":
                            return isFinite(s) ? String(s) : t ? t(s) : "null";
                        case "boolean":
                            return s === true ? "true" : "false";
                        case "undefined":
                            return undefined;
                        case "bigint":
                            if (r) {
                                return String(s);
                            }
                        default:
                            return t ? t(s) : undefined;
                    }
                }
                function stringify(e, t, n) {
                    if (arguments.length > 1) {
                        let r = "";
                        if (typeof n === "number") {
                            r = " ".repeat(Math.min(n, 10));
                        } else if (typeof n === "string") {
                            r = n.slice(0, 10);
                        }
                        if (t != null) {
                            if (typeof t === "function") {
                                return stringifyFnReplacer("", {
                                    "": e
                                }, [], t, r, "");
                            }
                            if (Array.isArray(t)) {
                                return stringifyArrayReplacer("", e, [], getUniqueReplacerSet(t), r, "");
                            }
                        }
                        if (r.length !== 0) {
                            return stringifyIndent("", e, [], r, "");
                        }
                    }
                    return stringifySimple("", e, []);
                }
                return stringify;
            }
        }
    };
    var t = {};
    function __nccwpck_require__(n) {
        var r = t[n];
        if (r !== undefined) {
            return r.exports;
        }
        var i = t[n] = {
            exports: {}
        };
        var f = true;
        try {
            e[n](i, i.exports, __nccwpck_require__);
            f = false;
        } finally{
            if (f) delete t[n];
        }
        return i.exports;
    }
    if (typeof __nccwpck_require__ !== "undefined") __nccwpck_require__.ab = ("TURBOPACK compile-time value", "/ROOT/node_modules/next/dist/compiled/safe-stable-stringify") + "/";
    var n = __nccwpck_require__(879);
    module.exports = n;
})();
}}),
"[project]/node_modules/next/dist/compiled/scheduler/cjs/scheduler.development.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
"production" !== ("TURBOPACK compile-time value", "development") && function() {
    function performWorkUntilDeadline() {
        needsPaint = !1;
        if (isMessageLoopRunning) {
            var currentTime = exports.unstable_now();
            startTime = currentTime;
            var hasMoreWork = !0;
            try {
                a: {
                    isHostCallbackScheduled = !1;
                    isHostTimeoutScheduled && (isHostTimeoutScheduled = !1, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
                    isPerformingWork = !0;
                    var previousPriorityLevel = currentPriorityLevel;
                    try {
                        b: {
                            advanceTimers(currentTime);
                            for(currentTask = peek(taskQueue); null !== currentTask && !(currentTask.expirationTime > currentTime && shouldYieldToHost());){
                                var callback = currentTask.callback;
                                if ("function" === typeof callback) {
                                    currentTask.callback = null;
                                    currentPriorityLevel = currentTask.priorityLevel;
                                    var continuationCallback = callback(currentTask.expirationTime <= currentTime);
                                    currentTime = exports.unstable_now();
                                    if ("function" === typeof continuationCallback) {
                                        currentTask.callback = continuationCallback;
                                        advanceTimers(currentTime);
                                        hasMoreWork = !0;
                                        break b;
                                    }
                                    currentTask === peek(taskQueue) && pop(taskQueue);
                                    advanceTimers(currentTime);
                                } else pop(taskQueue);
                                currentTask = peek(taskQueue);
                            }
                            if (null !== currentTask) hasMoreWork = !0;
                            else {
                                var firstTimer = peek(timerQueue);
                                null !== firstTimer && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
                                hasMoreWork = !1;
                            }
                        }
                        break a;
                    } finally{
                        currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = !1;
                    }
                    hasMoreWork = void 0;
                }
            } finally{
                hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = !1;
            }
        }
    }
    function push(heap, node) {
        var index = heap.length;
        heap.push(node);
        a: for(; 0 < index;){
            var parentIndex = index - 1 >>> 1, parent = heap[parentIndex];
            if (0 < compare(parent, node)) heap[parentIndex] = node, heap[index] = parent, index = parentIndex;
            else break a;
        }
    }
    function peek(heap) {
        return 0 === heap.length ? null : heap[0];
    }
    function pop(heap) {
        if (0 === heap.length) return null;
        var first = heap[0], last = heap.pop();
        if (last !== first) {
            heap[0] = last;
            a: for(var index = 0, length = heap.length, halfLength = length >>> 1; index < halfLength;){
                var leftIndex = 2 * (index + 1) - 1, left = heap[leftIndex], rightIndex = leftIndex + 1, right = heap[rightIndex];
                if (0 > compare(left, last)) rightIndex < length && 0 > compare(right, left) ? (heap[index] = right, heap[rightIndex] = last, index = rightIndex) : (heap[index] = left, heap[leftIndex] = last, index = leftIndex);
                else if (rightIndex < length && 0 > compare(right, last)) heap[index] = right, heap[rightIndex] = last, index = rightIndex;
                else break a;
            }
        }
        return first;
    }
    function compare(a, b) {
        var diff = a.sortIndex - b.sortIndex;
        return 0 !== diff ? diff : a.id - b.id;
    }
    function advanceTimers(currentTime) {
        for(var timer = peek(timerQueue); null !== timer;){
            if (null === timer.callback) pop(timerQueue);
            else if (timer.startTime <= currentTime) pop(timerQueue), timer.sortIndex = timer.expirationTime, push(taskQueue, timer);
            else break;
            timer = peek(timerQueue);
        }
    }
    function handleTimeout(currentTime) {
        isHostTimeoutScheduled = !1;
        advanceTimers(currentTime);
        if (!isHostCallbackScheduled) if (null !== peek(taskQueue)) isHostCallbackScheduled = !0, isMessageLoopRunning || (isMessageLoopRunning = !0, schedulePerformWorkUntilDeadline());
        else {
            var firstTimer = peek(timerQueue);
            null !== firstTimer && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
        }
    }
    function shouldYieldToHost() {
        return needsPaint ? !0 : exports.unstable_now() - startTime < frameInterval ? !1 : !0;
    }
    function requestHostTimeout(callback, ms) {
        taskTimeoutID = localSetTimeout(function() {
            callback(exports.unstable_now());
        }, ms);
    }
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    exports.unstable_now = void 0;
    if ("object" === typeof performance && "function" === typeof performance.now) {
        var localPerformance = performance;
        exports.unstable_now = function() {
            return localPerformance.now();
        };
    } else {
        var localDate = Date, initialTime = localDate.now();
        exports.unstable_now = function() {
            return localDate.now() - initialTime;
        };
    }
    var taskQueue = [], timerQueue = [], taskIdCounter = 1, currentTask = null, currentPriorityLevel = 3, isPerformingWork = !1, isHostCallbackScheduled = !1, isHostTimeoutScheduled = !1, needsPaint = !1, localSetTimeout = "function" === typeof setTimeout ? setTimeout : null, localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null, localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null, isMessageLoopRunning = !1, taskTimeoutID = -1, frameInterval = 5, startTime = -1;
    if ("function" === typeof localSetImmediate) var schedulePerformWorkUntilDeadline = function() {
        localSetImmediate(performWorkUntilDeadline);
    };
    else if ("undefined" !== typeof MessageChannel) {
        var channel = new MessageChannel(), port = channel.port2;
        channel.port1.onmessage = performWorkUntilDeadline;
        schedulePerformWorkUntilDeadline = function() {
            port.postMessage(null);
        };
    } else schedulePerformWorkUntilDeadline = function() {
        localSetTimeout(performWorkUntilDeadline, 0);
    };
    exports.unstable_IdlePriority = 5;
    exports.unstable_ImmediatePriority = 1;
    exports.unstable_LowPriority = 4;
    exports.unstable_NormalPriority = 3;
    exports.unstable_Profiling = null;
    exports.unstable_UserBlockingPriority = 2;
    exports.unstable_cancelCallback = function(task) {
        task.callback = null;
    };
    exports.unstable_forceFrameRate = function(fps) {
        0 > fps || 125 < fps ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5;
    };
    exports.unstable_getCurrentPriorityLevel = function() {
        return currentPriorityLevel;
    };
    exports.unstable_next = function(eventHandler) {
        switch(currentPriorityLevel){
            case 1:
            case 2:
            case 3:
                var priorityLevel = 3;
                break;
            default:
                priorityLevel = currentPriorityLevel;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
            return eventHandler();
        } finally{
            currentPriorityLevel = previousPriorityLevel;
        }
    };
    exports.unstable_requestPaint = function() {
        needsPaint = !0;
    };
    exports.unstable_runWithPriority = function(priorityLevel, eventHandler) {
        switch(priorityLevel){
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                break;
            default:
                priorityLevel = 3;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
            return eventHandler();
        } finally{
            currentPriorityLevel = previousPriorityLevel;
        }
    };
    exports.unstable_scheduleCallback = function(priorityLevel, callback, options) {
        var currentTime = exports.unstable_now();
        "object" === typeof options && null !== options ? (options = options.delay, options = "number" === typeof options && 0 < options ? currentTime + options : currentTime) : options = currentTime;
        switch(priorityLevel){
            case 1:
                var timeout = -1;
                break;
            case 2:
                timeout = 250;
                break;
            case 5:
                timeout = 1073741823;
                break;
            case 4:
                timeout = 1e4;
                break;
            default:
                timeout = 5e3;
        }
        timeout = options + timeout;
        priorityLevel = {
            id: taskIdCounter++,
            callback: callback,
            priorityLevel: priorityLevel,
            startTime: options,
            expirationTime: timeout,
            sortIndex: -1
        };
        options > currentTime ? (priorityLevel.sortIndex = options, push(timerQueue, priorityLevel), null === peek(taskQueue) && priorityLevel === peek(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = !0, requestHostTimeout(handleTimeout, options - currentTime))) : (priorityLevel.sortIndex = timeout, push(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = !0, isMessageLoopRunning || (isMessageLoopRunning = !0, schedulePerformWorkUntilDeadline())));
        return priorityLevel;
    };
    exports.unstable_shouldYield = shouldYieldToHost;
    exports.unstable_wrapCallback = function(callback) {
        var parentPriorityLevel = currentPriorityLevel;
        return function() {
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = parentPriorityLevel;
            try {
                return callback.apply(this, arguments);
            } finally{
                currentPriorityLevel = previousPriorityLevel;
            }
        };
    };
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
}();
}}),
"[project]/node_modules/next/dist/compiled/scheduler/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
else {
    module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/scheduler/cjs/scheduler.development.js [app-client] (ecmascript)");
}
}}),
"[project]/node_modules/next/dist/compiled/react-server-dom-turbopack/cjs/react-server-dom-turbopack-client.browser.development.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/**
 * @license React
 * react-server-dom-turbopack-client.browser.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
"production" !== ("TURBOPACK compile-time value", "development") && function() {
    function resolveClientReference(bundlerConfig, metadata) {
        if (bundlerConfig) {
            var moduleExports = bundlerConfig[metadata[0]];
            if (bundlerConfig = moduleExports && moduleExports[metadata[2]]) moduleExports = bundlerConfig.name;
            else {
                bundlerConfig = moduleExports && moduleExports["*"];
                if (!bundlerConfig) throw Error('Could not find the module "' + metadata[0] + '" in the React Server Consumer Manifest. This is probably a bug in the React Server Components bundler.');
                moduleExports = metadata[2];
            }
            return 4 === metadata.length ? [
                bundlerConfig.id,
                bundlerConfig.chunks,
                moduleExports,
                1
            ] : [
                bundlerConfig.id,
                bundlerConfig.chunks,
                moduleExports
            ];
        }
        return metadata;
    }
    function resolveServerReference(bundlerConfig, id) {
        var name = "", resolvedModuleData = bundlerConfig[id];
        if (resolvedModuleData) name = resolvedModuleData.name;
        else {
            var idx = id.lastIndexOf("#");
            -1 !== idx && (name = id.slice(idx + 1), resolvedModuleData = bundlerConfig[id.slice(0, idx)]);
            if (!resolvedModuleData) throw Error('Could not find the module "' + id + '" in the React Server Manifest. This is probably a bug in the React Server Components bundler.');
        }
        return [
            resolvedModuleData.id,
            resolvedModuleData.chunks,
            name
        ];
    }
    function requireAsyncModule(id) {
        var promise = ("TURBOPACK member replacement", __turbopack_context__.r)(id);
        if ("function" !== typeof promise.then || "fulfilled" === promise.status) return null;
        promise.then(function(value) {
            promise.status = "fulfilled";
            promise.value = value;
        }, function(reason) {
            promise.status = "rejected";
            promise.reason = reason;
        });
        return promise;
    }
    function ignoreReject() {}
    function preloadModule(metadata) {
        for(var chunks = metadata[1], promises = [], i = 0; i < chunks.length; i++){
            var chunkFilename = chunks[i], entry = chunkCache.get(chunkFilename);
            if (void 0 === entry) {
                entry = ("TURBOPACK member replacement", __turbopack_context__.L)(chunkFilename);
                promises.push(entry);
                var resolve = chunkCache.set.bind(chunkCache, chunkFilename, null);
                entry.then(resolve, ignoreReject);
                chunkCache.set(chunkFilename, entry);
            } else null !== entry && promises.push(entry);
        }
        return 4 === metadata.length ? 0 === promises.length ? requireAsyncModule(metadata[0]) : Promise.all(promises).then(function() {
            return requireAsyncModule(metadata[0]);
        }) : 0 < promises.length ? Promise.all(promises) : null;
    }
    function requireModule(metadata) {
        var moduleExports = ("TURBOPACK member replacement", __turbopack_context__.r)(metadata[0]);
        if (4 === metadata.length && "function" === typeof moduleExports.then) if ("fulfilled" === moduleExports.status) moduleExports = moduleExports.value;
        else throw moduleExports.reason;
        return "*" === metadata[2] ? moduleExports : "" === metadata[2] ? moduleExports.__esModule ? moduleExports.default : moduleExports : moduleExports[metadata[2]];
    }
    function getIteratorFn(maybeIterable) {
        if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
        maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
        return "function" === typeof maybeIterable ? maybeIterable : null;
    }
    function isObjectPrototype(object) {
        if (!object) return !1;
        var ObjectPrototype = Object.prototype;
        if (object === ObjectPrototype) return !0;
        if (getPrototypeOf(object)) return !1;
        object = Object.getOwnPropertyNames(object);
        for(var i = 0; i < object.length; i++)if (!(object[i] in ObjectPrototype)) return !1;
        return !0;
    }
    function isSimpleObject(object) {
        if (!isObjectPrototype(getPrototypeOf(object))) return !1;
        for(var names = Object.getOwnPropertyNames(object), i = 0; i < names.length; i++){
            var descriptor = Object.getOwnPropertyDescriptor(object, names[i]);
            if (!descriptor || !descriptor.enumerable && ("key" !== names[i] && "ref" !== names[i] || "function" !== typeof descriptor.get)) return !1;
        }
        return !0;
    }
    function objectName(object) {
        object = Object.prototype.toString.call(object);
        return object.slice(8, object.length - 1);
    }
    function describeKeyForErrorMessage(key) {
        var encodedKey = JSON.stringify(key);
        return '"' + key + '"' === encodedKey ? key : encodedKey;
    }
    function describeValueForErrorMessage(value) {
        switch(typeof value){
            case "string":
                return JSON.stringify(10 >= value.length ? value : value.slice(0, 10) + "...");
            case "object":
                if (isArrayImpl(value)) return "[...]";
                if (null !== value && value.$$typeof === CLIENT_REFERENCE_TAG) return "client";
                value = objectName(value);
                return "Object" === value ? "{...}" : value;
            case "function":
                return value.$$typeof === CLIENT_REFERENCE_TAG ? "client" : (value = value.displayName || value.name) ? "function " + value : "function";
            default:
                return String(value);
        }
    }
    function describeElementType(type) {
        if ("string" === typeof type) return type;
        switch(type){
            case REACT_SUSPENSE_TYPE:
                return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
        }
        if ("object" === typeof type) switch(type.$$typeof){
            case REACT_FORWARD_REF_TYPE:
                return describeElementType(type.render);
            case REACT_MEMO_TYPE:
                return describeElementType(type.type);
            case REACT_LAZY_TYPE:
                var payload = type._payload;
                type = type._init;
                try {
                    return describeElementType(type(payload));
                } catch (x) {}
        }
        return "";
    }
    function describeObjectForErrorMessage(objectOrArray, expandedName) {
        var objKind = objectName(objectOrArray);
        if ("Object" !== objKind && "Array" !== objKind) return objKind;
        var start = -1, length = 0;
        if (isArrayImpl(objectOrArray)) if (jsxChildrenParents.has(objectOrArray)) {
            var type = jsxChildrenParents.get(objectOrArray);
            objKind = "<" + describeElementType(type) + ">";
            for(var i = 0; i < objectOrArray.length; i++){
                var value = objectOrArray[i];
                value = "string" === typeof value ? value : "object" === typeof value && null !== value ? "{" + describeObjectForErrorMessage(value) + "}" : "{" + describeValueForErrorMessage(value) + "}";
                "" + i === expandedName ? (start = objKind.length, length = value.length, objKind += value) : objKind = 15 > value.length && 40 > objKind.length + value.length ? objKind + value : objKind + "{...}";
            }
            objKind += "</" + describeElementType(type) + ">";
        } else {
            objKind = "[";
            for(type = 0; type < objectOrArray.length; type++)0 < type && (objKind += ", "), i = objectOrArray[type], i = "object" === typeof i && null !== i ? describeObjectForErrorMessage(i) : describeValueForErrorMessage(i), "" + type === expandedName ? (start = objKind.length, length = i.length, objKind += i) : objKind = 10 > i.length && 40 > objKind.length + i.length ? objKind + i : objKind + "...";
            objKind += "]";
        }
        else if (objectOrArray.$$typeof === REACT_ELEMENT_TYPE) objKind = "<" + describeElementType(objectOrArray.type) + "/>";
        else {
            if (objectOrArray.$$typeof === CLIENT_REFERENCE_TAG) return "client";
            if (jsxPropsParents.has(objectOrArray)) {
                objKind = jsxPropsParents.get(objectOrArray);
                objKind = "<" + (describeElementType(objKind) || "...");
                type = Object.keys(objectOrArray);
                for(i = 0; i < type.length; i++){
                    objKind += " ";
                    value = type[i];
                    objKind += describeKeyForErrorMessage(value) + "=";
                    var _value2 = objectOrArray[value];
                    var _substr2 = value === expandedName && "object" === typeof _value2 && null !== _value2 ? describeObjectForErrorMessage(_value2) : describeValueForErrorMessage(_value2);
                    "string" !== typeof _value2 && (_substr2 = "{" + _substr2 + "}");
                    value === expandedName ? (start = objKind.length, length = _substr2.length, objKind += _substr2) : objKind = 10 > _substr2.length && 40 > objKind.length + _substr2.length ? objKind + _substr2 : objKind + "...";
                }
                objKind += ">";
            } else {
                objKind = "{";
                type = Object.keys(objectOrArray);
                for(i = 0; i < type.length; i++)0 < i && (objKind += ", "), value = type[i], objKind += describeKeyForErrorMessage(value) + ": ", _value2 = objectOrArray[value], _value2 = "object" === typeof _value2 && null !== _value2 ? describeObjectForErrorMessage(_value2) : describeValueForErrorMessage(_value2), value === expandedName ? (start = objKind.length, length = _value2.length, objKind += _value2) : objKind = 10 > _value2.length && 40 > objKind.length + _value2.length ? objKind + _value2 : objKind + "...";
                objKind += "}";
            }
        }
        return void 0 === expandedName ? objKind : -1 < start && 0 < length ? (objectOrArray = " ".repeat(start) + "^".repeat(length), "\n  " + objKind + "\n  " + objectOrArray) : "\n  " + objKind;
    }
    function serializeNumber(number) {
        return Number.isFinite(number) ? 0 === number && -Infinity === 1 / number ? "$-0" : number : Infinity === number ? "$Infinity" : -Infinity === number ? "$-Infinity" : "$NaN";
    }
    function processReply(root, formFieldPrefix, temporaryReferences, resolve, reject) {
        function serializeTypedArray(tag, typedArray) {
            typedArray = new Blob([
                new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength)
            ]);
            var blobId = nextPartId++;
            null === formData && (formData = new FormData());
            formData.append(formFieldPrefix + blobId, typedArray);
            return "$" + tag + blobId.toString(16);
        }
        function serializeBinaryReader(reader) {
            function progress(entry) {
                entry.done ? (entry = nextPartId++, data.append(formFieldPrefix + entry, new Blob(buffer)), data.append(formFieldPrefix + streamId, '"$o' + entry.toString(16) + '"'), data.append(formFieldPrefix + streamId, "C"), pendingParts--, 0 === pendingParts && resolve(data)) : (buffer.push(entry.value), reader.read(new Uint8Array(1024)).then(progress, reject));
            }
            null === formData && (formData = new FormData());
            var data = formData;
            pendingParts++;
            var streamId = nextPartId++, buffer = [];
            reader.read(new Uint8Array(1024)).then(progress, reject);
            return "$r" + streamId.toString(16);
        }
        function serializeReader(reader) {
            function progress(entry) {
                if (entry.done) data.append(formFieldPrefix + streamId, "C"), pendingParts--, 0 === pendingParts && resolve(data);
                else try {
                    var partJSON = JSON.stringify(entry.value, resolveToJSON);
                    data.append(formFieldPrefix + streamId, partJSON);
                    reader.read().then(progress, reject);
                } catch (x) {
                    reject(x);
                }
            }
            null === formData && (formData = new FormData());
            var data = formData;
            pendingParts++;
            var streamId = nextPartId++;
            reader.read().then(progress, reject);
            return "$R" + streamId.toString(16);
        }
        function serializeReadableStream(stream) {
            try {
                var binaryReader = stream.getReader({
                    mode: "byob"
                });
            } catch (x) {
                return serializeReader(stream.getReader());
            }
            return serializeBinaryReader(binaryReader);
        }
        function serializeAsyncIterable(iterable, iterator) {
            function progress(entry) {
                if (entry.done) {
                    if (void 0 === entry.value) data.append(formFieldPrefix + streamId, "C");
                    else try {
                        var partJSON = JSON.stringify(entry.value, resolveToJSON);
                        data.append(formFieldPrefix + streamId, "C" + partJSON);
                    } catch (x) {
                        reject(x);
                        return;
                    }
                    pendingParts--;
                    0 === pendingParts && resolve(data);
                } else try {
                    var _partJSON = JSON.stringify(entry.value, resolveToJSON);
                    data.append(formFieldPrefix + streamId, _partJSON);
                    iterator.next().then(progress, reject);
                } catch (x$0) {
                    reject(x$0);
                }
            }
            null === formData && (formData = new FormData());
            var data = formData;
            pendingParts++;
            var streamId = nextPartId++;
            iterable = iterable === iterator;
            iterator.next().then(progress, reject);
            return "$" + (iterable ? "x" : "X") + streamId.toString(16);
        }
        function resolveToJSON(key, value) {
            var originalValue = this[key];
            "object" !== typeof originalValue || originalValue === value || originalValue instanceof Date || ("Object" !== objectName(originalValue) ? console.error("Only plain objects can be passed to Server Functions from the Client. %s objects are not supported.%s", objectName(originalValue), describeObjectForErrorMessage(this, key)) : console.error("Only plain objects can be passed to Server Functions from the Client. Objects with toJSON methods are not supported. Convert it manually to a simple value before passing it to props.%s", describeObjectForErrorMessage(this, key)));
            if (null === value) return null;
            if ("object" === typeof value) {
                switch(value.$$typeof){
                    case REACT_ELEMENT_TYPE:
                        if (void 0 !== temporaryReferences && -1 === key.indexOf(":")) {
                            var parentReference = writtenObjects.get(this);
                            if (void 0 !== parentReference) return temporaryReferences.set(parentReference + ":" + key, value), "$T";
                        }
                        throw Error("React Element cannot be passed to Server Functions from the Client without a temporary reference set. Pass a TemporaryReferenceSet to the options." + describeObjectForErrorMessage(this, key));
                    case REACT_LAZY_TYPE:
                        originalValue = value._payload;
                        var init = value._init;
                        null === formData && (formData = new FormData());
                        pendingParts++;
                        try {
                            parentReference = init(originalValue);
                            var lazyId = nextPartId++, partJSON = serializeModel(parentReference, lazyId);
                            formData.append(formFieldPrefix + lazyId, partJSON);
                            return "$" + lazyId.toString(16);
                        } catch (x) {
                            if ("object" === typeof x && null !== x && "function" === typeof x.then) {
                                pendingParts++;
                                var _lazyId = nextPartId++;
                                parentReference = function() {
                                    try {
                                        var _partJSON2 = serializeModel(value, _lazyId), _data = formData;
                                        _data.append(formFieldPrefix + _lazyId, _partJSON2);
                                        pendingParts--;
                                        0 === pendingParts && resolve(_data);
                                    } catch (reason) {
                                        reject(reason);
                                    }
                                };
                                x.then(parentReference, parentReference);
                                return "$" + _lazyId.toString(16);
                            }
                            reject(x);
                            return null;
                        } finally{
                            pendingParts--;
                        }
                }
                if ("function" === typeof value.then) {
                    null === formData && (formData = new FormData());
                    pendingParts++;
                    var promiseId = nextPartId++;
                    value.then(function(partValue) {
                        try {
                            var _partJSON3 = serializeModel(partValue, promiseId);
                            partValue = formData;
                            partValue.append(formFieldPrefix + promiseId, _partJSON3);
                            pendingParts--;
                            0 === pendingParts && resolve(partValue);
                        } catch (reason) {
                            reject(reason);
                        }
                    }, reject);
                    return "$@" + promiseId.toString(16);
                }
                parentReference = writtenObjects.get(value);
                if (void 0 !== parentReference) if (modelRoot === value) modelRoot = null;
                else return parentReference;
                else -1 === key.indexOf(":") && (parentReference = writtenObjects.get(this), void 0 !== parentReference && (parentReference = parentReference + ":" + key, writtenObjects.set(value, parentReference), void 0 !== temporaryReferences && temporaryReferences.set(parentReference, value)));
                if (isArrayImpl(value)) return value;
                if (value instanceof FormData) {
                    null === formData && (formData = new FormData());
                    var _data3 = formData;
                    key = nextPartId++;
                    var prefix = formFieldPrefix + key + "_";
                    value.forEach(function(originalValue, originalKey) {
                        _data3.append(prefix + originalKey, originalValue);
                    });
                    return "$K" + key.toString(16);
                }
                if (value instanceof Map) return key = nextPartId++, parentReference = serializeModel(Array.from(value), key), null === formData && (formData = new FormData()), formData.append(formFieldPrefix + key, parentReference), "$Q" + key.toString(16);
                if (value instanceof Set) return key = nextPartId++, parentReference = serializeModel(Array.from(value), key), null === formData && (formData = new FormData()), formData.append(formFieldPrefix + key, parentReference), "$W" + key.toString(16);
                if (value instanceof ArrayBuffer) return key = new Blob([
                    value
                ]), parentReference = nextPartId++, null === formData && (formData = new FormData()), formData.append(formFieldPrefix + parentReference, key), "$A" + parentReference.toString(16);
                if (value instanceof Int8Array) return serializeTypedArray("O", value);
                if (value instanceof Uint8Array) return serializeTypedArray("o", value);
                if (value instanceof Uint8ClampedArray) return serializeTypedArray("U", value);
                if (value instanceof Int16Array) return serializeTypedArray("S", value);
                if (value instanceof Uint16Array) return serializeTypedArray("s", value);
                if (value instanceof Int32Array) return serializeTypedArray("L", value);
                if (value instanceof Uint32Array) return serializeTypedArray("l", value);
                if (value instanceof Float32Array) return serializeTypedArray("G", value);
                if (value instanceof Float64Array) return serializeTypedArray("g", value);
                if (value instanceof BigInt64Array) return serializeTypedArray("M", value);
                if (value instanceof BigUint64Array) return serializeTypedArray("m", value);
                if (value instanceof DataView) return serializeTypedArray("V", value);
                if ("function" === typeof Blob && value instanceof Blob) return null === formData && (formData = new FormData()), key = nextPartId++, formData.append(formFieldPrefix + key, value), "$B" + key.toString(16);
                if (parentReference = getIteratorFn(value)) return parentReference = parentReference.call(value), parentReference === value ? (key = nextPartId++, parentReference = serializeModel(Array.from(parentReference), key), null === formData && (formData = new FormData()), formData.append(formFieldPrefix + key, parentReference), "$i" + key.toString(16)) : Array.from(parentReference);
                if ("function" === typeof ReadableStream && value instanceof ReadableStream) return serializeReadableStream(value);
                parentReference = value[ASYNC_ITERATOR];
                if ("function" === typeof parentReference) return serializeAsyncIterable(value, parentReference.call(value));
                parentReference = getPrototypeOf(value);
                if (parentReference !== ObjectPrototype && (null === parentReference || null !== getPrototypeOf(parentReference))) {
                    if (void 0 === temporaryReferences) throw Error("Only plain objects, and a few built-ins, can be passed to Server Functions. Classes or null prototypes are not supported." + describeObjectForErrorMessage(this, key));
                    return "$T";
                }
                value.$$typeof === REACT_CONTEXT_TYPE ? console.error("React Context Providers cannot be passed to Server Functions from the Client.%s", describeObjectForErrorMessage(this, key)) : "Object" !== objectName(value) ? console.error("Only plain objects can be passed to Server Functions from the Client. %s objects are not supported.%s", objectName(value), describeObjectForErrorMessage(this, key)) : isSimpleObject(value) ? Object.getOwnPropertySymbols && (parentReference = Object.getOwnPropertySymbols(value), 0 < parentReference.length && console.error("Only plain objects can be passed to Server Functions from the Client. Objects with symbol properties like %s are not supported.%s", parentReference[0].description, describeObjectForErrorMessage(this, key))) : console.error("Only plain objects can be passed to Server Functions from the Client. Classes or other objects with methods are not supported.%s", describeObjectForErrorMessage(this, key));
                return value;
            }
            if ("string" === typeof value) {
                if ("Z" === value[value.length - 1] && this[key] instanceof Date) return "$D" + value;
                key = "$" === value[0] ? "$" + value : value;
                return key;
            }
            if ("boolean" === typeof value) return value;
            if ("number" === typeof value) return serializeNumber(value);
            if ("undefined" === typeof value) return "$undefined";
            if ("function" === typeof value) {
                parentReference = knownServerReferences.get(value);
                if (void 0 !== parentReference) return key = JSON.stringify({
                    id: parentReference.id,
                    bound: parentReference.bound
                }, resolveToJSON), null === formData && (formData = new FormData()), parentReference = nextPartId++, formData.set(formFieldPrefix + parentReference, key), "$F" + parentReference.toString(16);
                if (void 0 !== temporaryReferences && -1 === key.indexOf(":") && (parentReference = writtenObjects.get(this), void 0 !== parentReference)) return temporaryReferences.set(parentReference + ":" + key, value), "$T";
                throw Error("Client Functions cannot be passed directly to Server Functions. Only Functions passed from the Server can be passed back again.");
            }
            if ("symbol" === typeof value) {
                if (void 0 !== temporaryReferences && -1 === key.indexOf(":") && (parentReference = writtenObjects.get(this), void 0 !== parentReference)) return temporaryReferences.set(parentReference + ":" + key, value), "$T";
                throw Error("Symbols cannot be passed to a Server Function without a temporary reference set. Pass a TemporaryReferenceSet to the options." + describeObjectForErrorMessage(this, key));
            }
            if ("bigint" === typeof value) return "$n" + value.toString(10);
            throw Error("Type " + typeof value + " is not supported as an argument to a Server Function.");
        }
        function serializeModel(model, id) {
            "object" === typeof model && null !== model && (id = "$" + id.toString(16), writtenObjects.set(model, id), void 0 !== temporaryReferences && temporaryReferences.set(id, model));
            modelRoot = model;
            return JSON.stringify(model, resolveToJSON);
        }
        var nextPartId = 1, pendingParts = 0, formData = null, writtenObjects = new WeakMap(), modelRoot = root, json = serializeModel(root, 0);
        null === formData ? resolve(json) : (formData.set(formFieldPrefix + "0", json), 0 === pendingParts && resolve(formData));
        return function() {
            0 < pendingParts && (pendingParts = 0, null === formData ? resolve(json) : resolve(formData));
        };
    }
    function createFakeServerFunction(name, filename, sourceMap, line, col, environmentName, innerFunction) {
        name || (name = "<anonymous>");
        var encodedName = JSON.stringify(name);
        1 >= line ? (line = encodedName.length + 7, col = "s=>({" + encodedName + " ".repeat(col < line ? 0 : col - line) + ":(...args) => s(...args)})\n/* This module is a proxy to a Server Action. Turn on Source Maps to see the server source. */") : col = "/* This module is a proxy to a Server Action. Turn on Source Maps to see the server source. */" + "\n".repeat(line - 2) + "server=>({" + encodedName + ":\n" + " ".repeat(1 > col ? 0 : col - 1) + "(...args) => server(...args)})";
        filename.startsWith("/") && (filename = "file://" + filename);
        sourceMap ? (col += "\n//# sourceURL=rsc://React/" + encodeURIComponent(environmentName) + "/" + encodeURI(filename) + "?s" + fakeServerFunctionIdx++, col += "\n//# sourceMappingURL=" + sourceMap) : filename && (col += "\n//# sourceURL=" + filename);
        try {
            return (0, eval)(col)(innerFunction)[name];
        } catch (x) {
            return innerFunction;
        }
    }
    function registerBoundServerReference(reference, id, bound) {
        knownServerReferences.has(reference) || knownServerReferences.set(reference, {
            id: id,
            originalBind: reference.bind,
            bound: bound
        });
    }
    function createBoundServerReference(metaData, callServer, encodeFormAction, findSourceMapURL) {
        function action() {
            var args = Array.prototype.slice.call(arguments);
            return bound ? "fulfilled" === bound.status ? callServer(id, bound.value.concat(args)) : Promise.resolve(bound).then(function(boundArgs) {
                return callServer(id, boundArgs.concat(args));
            }) : callServer(id, args);
        }
        var id = metaData.id, bound = metaData.bound, location = metaData.location;
        if (location) {
            encodeFormAction = metaData.name || "";
            var filename = location[1], line = location[2];
            location = location[3];
            metaData = metaData.env || "Server";
            findSourceMapURL = null == findSourceMapURL ? null : findSourceMapURL(filename, metaData);
            action = createFakeServerFunction(encodeFormAction, filename, findSourceMapURL, line, location, metaData, action);
        }
        registerBoundServerReference(action, id, bound);
        return action;
    }
    function parseStackLocation(error) {
        error = error.stack;
        error.startsWith("Error: react-stack-top-frame\n") && (error = error.slice(29));
        var endOfFirst = error.indexOf("\n");
        if (-1 !== endOfFirst) {
            var endOfSecond = error.indexOf("\n", endOfFirst + 1);
            endOfFirst = -1 === endOfSecond ? error.slice(endOfFirst + 1) : error.slice(endOfFirst + 1, endOfSecond);
        } else endOfFirst = error;
        error = v8FrameRegExp.exec(endOfFirst);
        if (!error && (error = jscSpiderMonkeyFrameRegExp.exec(endOfFirst), !error)) return null;
        endOfFirst = error[1] || "";
        "<anonymous>" === endOfFirst && (endOfFirst = "");
        endOfSecond = error[2] || error[5] || "";
        "<anonymous>" === endOfSecond && (endOfSecond = "");
        return [
            endOfFirst,
            endOfSecond,
            +(error[3] || error[6]),
            +(error[4] || error[7])
        ];
    }
    function getComponentNameFromType(type) {
        if (null == type) return null;
        if ("function" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        switch(type){
            case REACT_FRAGMENT_TYPE:
                return "Fragment";
            case REACT_PROFILER_TYPE:
                return "Profiler";
            case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
            case REACT_SUSPENSE_TYPE:
                return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
            case REACT_ACTIVITY_TYPE:
                return "Activity";
        }
        if ("object" === typeof type) switch("number" === typeof type.tag && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof){
            case REACT_PORTAL_TYPE:
                return "Portal";
            case REACT_CONTEXT_TYPE:
                return type.displayName || "Context";
            case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
                var innerType = type.render;
                type = type.displayName;
                type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                return type;
            case REACT_MEMO_TYPE:
                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
                innerType = type._payload;
                type = type._init;
                try {
                    return getComponentNameFromType(type(innerType));
                } catch (x) {}
        }
        return null;
    }
    function ReactPromise(status, value, reason) {
        this.status = status;
        this.value = value;
        this.reason = reason;
        this._debugInfo = null;
    }
    function unwrapWeakResponse(weakResponse) {
        weakResponse = weakResponse.weak.deref();
        if (void 0 === weakResponse) throw Error("We did not expect to receive new data after GC:ing the response.");
        return weakResponse;
    }
    function cleanupDebugChannel(debugChannel) {
        debugChannel("");
    }
    function readChunk(chunk) {
        switch(chunk.status){
            case "resolved_model":
                initializeModelChunk(chunk);
                break;
            case "resolved_module":
                initializeModuleChunk(chunk);
        }
        switch(chunk.status){
            case "fulfilled":
                return chunk.value;
            case "pending":
            case "blocked":
            case "halted":
                throw chunk;
            default:
                throw chunk.reason;
        }
    }
    function getRoot(weakResponse) {
        weakResponse = unwrapWeakResponse(weakResponse);
        return getChunk(weakResponse, 0);
    }
    function createPendingChunk(response) {
        0 === response._pendingChunks++ && (response._weakResponse.response = response, null !== response._pendingInitialRender && (clearTimeout(response._pendingInitialRender), response._pendingInitialRender = null));
        return new ReactPromise("pending", null, null);
    }
    function releasePendingChunk(response, chunk) {
        "pending" === chunk.status && 0 === --response._pendingChunks && (response._weakResponse.response = null, response._pendingInitialRender = setTimeout(flushInitialRenderPerformance.bind(null, response), 100));
    }
    function wakeChunk(listeners, value) {
        for(var i = 0; i < listeners.length; i++){
            var listener = listeners[i];
            "function" === typeof listener ? listener(value) : fulfillReference(listener, value);
        }
    }
    function rejectChunk(listeners, error) {
        for(var i = 0; i < listeners.length; i++){
            var listener = listeners[i];
            "function" === typeof listener ? listener(error) : rejectReference(listener, error);
        }
    }
    function resolveBlockedCycle(resolvedChunk, reference) {
        var referencedChunk = reference.handler.chunk;
        if (null === referencedChunk) return null;
        if (referencedChunk === resolvedChunk) return reference.handler;
        reference = referencedChunk.value;
        if (null !== reference) for(referencedChunk = 0; referencedChunk < reference.length; referencedChunk++){
            var listener = reference[referencedChunk];
            if ("function" !== typeof listener && (listener = resolveBlockedCycle(resolvedChunk, listener), null !== listener)) return listener;
        }
        return null;
    }
    function wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners) {
        switch(chunk.status){
            case "fulfilled":
                wakeChunk(resolveListeners, chunk.value);
                break;
            case "blocked":
                for(var i = 0; i < resolveListeners.length; i++){
                    var listener = resolveListeners[i];
                    if ("function" !== typeof listener) {
                        var cyclicHandler = resolveBlockedCycle(chunk, listener);
                        null !== cyclicHandler && (fulfillReference(listener, cyclicHandler.value), resolveListeners.splice(i, 1), i--, null !== rejectListeners && (listener = rejectListeners.indexOf(listener), -1 !== listener && rejectListeners.splice(listener, 1)));
                    }
                }
            case "pending":
                if (chunk.value) for(i = 0; i < resolveListeners.length; i++)chunk.value.push(resolveListeners[i]);
                else chunk.value = resolveListeners;
                if (chunk.reason) {
                    if (rejectListeners) for(resolveListeners = 0; resolveListeners < rejectListeners.length; resolveListeners++)chunk.reason.push(rejectListeners[resolveListeners]);
                } else chunk.reason = rejectListeners;
                break;
            case "rejected":
                rejectListeners && rejectChunk(rejectListeners, chunk.reason);
        }
    }
    function triggerErrorOnChunk(response, chunk, error) {
        "pending" !== chunk.status && "blocked" !== chunk.status ? chunk.reason.error(error) : (releasePendingChunk(response, chunk), response = chunk.reason, chunk.status = "rejected", chunk.reason = error, null !== response && rejectChunk(response, error));
    }
    function createResolvedIteratorResultChunk(response, value, done) {
        return new ReactPromise("resolved_model", (done ? '{"done":true,"value":' : '{"done":false,"value":') + value + "}", response);
    }
    function resolveIteratorResultChunk(response, chunk, value, done) {
        resolveModelChunk(response, chunk, (done ? '{"done":true,"value":' : '{"done":false,"value":') + value + "}");
    }
    function resolveModelChunk(response, chunk, value) {
        if ("pending" !== chunk.status) chunk.reason.enqueueModel(value);
        else {
            releasePendingChunk(response, chunk);
            var resolveListeners = chunk.value, rejectListeners = chunk.reason;
            chunk.status = "resolved_model";
            chunk.value = value;
            chunk.reason = response;
            null !== resolveListeners && (initializeModelChunk(chunk), wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners));
        }
    }
    function resolveModuleChunk(response, chunk, value) {
        if ("pending" === chunk.status || "blocked" === chunk.status) {
            releasePendingChunk(response, chunk);
            response = chunk.value;
            var rejectListeners = chunk.reason;
            chunk.status = "resolved_module";
            chunk.value = value;
            null !== response && (initializeModuleChunk(chunk), wakeChunkIfInitialized(chunk, response, rejectListeners));
        }
    }
    function initializeModelChunk(chunk) {
        var prevHandler = initializingHandler;
        initializingHandler = null;
        var resolvedModel = chunk.value, response = chunk.reason;
        chunk.status = "blocked";
        chunk.value = null;
        chunk.reason = null;
        try {
            var value = JSON.parse(resolvedModel, response._fromJSON), resolveListeners = chunk.value;
            null !== resolveListeners && (chunk.value = null, chunk.reason = null, wakeChunk(resolveListeners, value));
            if (null !== initializingHandler) {
                if (initializingHandler.errored) throw initializingHandler.value;
                if (0 < initializingHandler.deps) {
                    initializingHandler.value = value;
                    initializingHandler.chunk = chunk;
                    return;
                }
            }
            chunk.status = "fulfilled";
            chunk.value = value;
        } catch (error) {
            chunk.status = "rejected", chunk.reason = error;
        } finally{
            initializingHandler = prevHandler;
        }
    }
    function initializeModuleChunk(chunk) {
        try {
            var value = requireModule(chunk.value);
            chunk.status = "fulfilled";
            chunk.value = value;
        } catch (error) {
            chunk.status = "rejected", chunk.reason = error;
        }
    }
    function reportGlobalError(weakResponse, error) {
        if (void 0 !== weakResponse.weak.deref()) {
            var response = unwrapWeakResponse(weakResponse);
            response._closed = !0;
            response._closedReason = error;
            response._chunks.forEach(function(chunk) {
                "pending" === chunk.status && triggerErrorOnChunk(response, chunk, error);
            });
            weakResponse = response._debugChannel;
            void 0 !== weakResponse && (weakResponse(""), response._debugChannel = void 0);
        }
    }
    function nullRefGetter() {
        return null;
    }
    function getTaskName(type) {
        if (type === REACT_FRAGMENT_TYPE) return "<>";
        if ("function" === typeof type) return '"use client"';
        if ("object" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE) return type._init === readChunk ? '"use client"' : "<...>";
        try {
            var name = getComponentNameFromType(type);
            return name ? "<" + name + ">" : "<...>";
        } catch (x) {
            return "<...>";
        }
    }
    function initializeElement(response, element) {
        var stack = element._debugStack, owner = element._owner;
        null === owner && (element._owner = response._debugRootOwner);
        var env = response._rootEnvironmentName;
        null !== owner && null != owner.env && (env = owner.env);
        var normalizedStackTrace = null;
        null === owner && null != response._debugRootStack ? normalizedStackTrace = response._debugRootStack : null !== stack && (normalizedStackTrace = createFakeJSXCallStackInDEV(response, stack, env));
        element._debugStack = normalizedStackTrace;
        normalizedStackTrace = null;
        supportsCreateTask && null !== stack && (normalizedStackTrace = console.createTask.bind(console, getTaskName(element.type)), stack = buildFakeCallStack(response, stack, env, !1, normalizedStackTrace), env = null === owner ? null : initializeFakeTask(response, owner), null === env ? (env = response._debugRootTask, normalizedStackTrace = null != env ? env.run(stack) : stack()) : normalizedStackTrace = env.run(stack));
        element._debugTask = normalizedStackTrace;
        null !== owner && initializeFakeStack(response, owner);
        Object.freeze(element.props);
    }
    function createLazyChunkWrapper(chunk) {
        var lazyType = {
            $$typeof: REACT_LAZY_TYPE,
            _payload: chunk,
            _init: readChunk
        };
        chunk = chunk._debugInfo || (chunk._debugInfo = []);
        lazyType._debugInfo = chunk;
        return lazyType;
    }
    function getChunk(response, id) {
        var chunks = response._chunks, chunk = chunks.get(id);
        chunk || (chunk = response._closed ? new ReactPromise("rejected", null, response._closedReason) : createPendingChunk(response), chunks.set(id, chunk));
        return chunk;
    }
    function fulfillReference(reference, value) {
        for(var response = reference.response, handler = reference.handler, parentObject = reference.parentObject, key = reference.key, map = reference.map, path = reference.path, i = 1; i < path.length; i++){
            for(; value.$$typeof === REACT_LAZY_TYPE;)if (value = value._payload, value === handler.chunk) value = handler.value;
            else {
                switch(value.status){
                    case "resolved_model":
                        initializeModelChunk(value);
                        break;
                    case "resolved_module":
                        initializeModuleChunk(value);
                }
                switch(value.status){
                    case "fulfilled":
                        value = value.value;
                        continue;
                    case "blocked":
                        var cyclicHandler = resolveBlockedCycle(value, reference);
                        if (null !== cyclicHandler) {
                            value = cyclicHandler.value;
                            continue;
                        }
                    case "pending":
                        path.splice(0, i - 1);
                        null === value.value ? value.value = [
                            reference
                        ] : value.value.push(reference);
                        null === value.reason ? value.reason = [
                            reference
                        ] : value.reason.push(reference);
                        return;
                    case "halted":
                        return;
                    default:
                        rejectReference(reference, value.reason);
                        return;
                }
            }
            value = value[path[i]];
        }
        reference = map(response, value, parentObject, key);
        parentObject[key] = reference;
        "" === key && null === handler.value && (handler.value = reference);
        if (parentObject[0] === REACT_ELEMENT_TYPE && "object" === typeof handler.value && null !== handler.value && handler.value.$$typeof === REACT_ELEMENT_TYPE) switch(parentObject = handler.value, key){
            case "3":
                parentObject.props = reference;
                break;
            case "4":
                parentObject._owner = reference;
                break;
            case "5":
                parentObject._debugStack = reference;
        }
        handler.deps--;
        0 === handler.deps && (key = handler.chunk, null !== key && "blocked" === key.status && (parentObject = key.value, key.status = "fulfilled", key.value = handler.value, null !== parentObject && wakeChunk(parentObject, handler.value)));
    }
    function rejectReference(reference, error) {
        var handler = reference.handler;
        reference = reference.response;
        if (!handler.errored) {
            var blockedValue = handler.value;
            handler.errored = !0;
            handler.value = error;
            handler = handler.chunk;
            if (null !== handler && "blocked" === handler.status) {
                if ("object" === typeof blockedValue && null !== blockedValue && blockedValue.$$typeof === REACT_ELEMENT_TYPE) {
                    var erroredComponent = {
                        name: getComponentNameFromType(blockedValue.type) || "",
                        owner: blockedValue._owner
                    };
                    erroredComponent.debugStack = blockedValue._debugStack;
                    supportsCreateTask && (erroredComponent.debugTask = blockedValue._debugTask);
                    (handler._debugInfo || (handler._debugInfo = [])).push(erroredComponent);
                }
                triggerErrorOnChunk(reference, handler, error);
            }
        }
    }
    function waitForReference(referencedChunk, parentObject, key, response, map, path) {
        if (initializingHandler) {
            var handler = initializingHandler;
            handler.deps++;
        } else handler = initializingHandler = {
            parent: null,
            chunk: null,
            value: null,
            deps: 1,
            errored: !1
        };
        parentObject = {
            response: response,
            handler: handler,
            parentObject: parentObject,
            key: key,
            map: map,
            path: path
        };
        null === referencedChunk.value ? referencedChunk.value = [
            parentObject
        ] : referencedChunk.value.push(parentObject);
        null === referencedChunk.reason ? referencedChunk.reason = [
            parentObject
        ] : referencedChunk.reason.push(parentObject);
        return null;
    }
    function loadServerReference(response, metaData, parentObject, key) {
        if (!response._serverReferenceConfig) return createBoundServerReference(metaData, response._callServer, response._encodeFormAction, response._debugFindSourceMapURL);
        var serverReference = resolveServerReference(response._serverReferenceConfig, metaData.id), promise = preloadModule(serverReference);
        if (promise) metaData.bound && (promise = Promise.all([
            promise,
            metaData.bound
        ]));
        else if (metaData.bound) promise = Promise.resolve(metaData.bound);
        else return promise = requireModule(serverReference), registerBoundServerReference(promise, metaData.id, metaData.bound), promise;
        if (initializingHandler) {
            var handler = initializingHandler;
            handler.deps++;
        } else handler = initializingHandler = {
            parent: null,
            chunk: null,
            value: null,
            deps: 1,
            errored: !1
        };
        promise.then(function() {
            var resolvedValue = requireModule(serverReference);
            if (metaData.bound) {
                var boundArgs = metaData.bound.value.slice(0);
                boundArgs.unshift(null);
                resolvedValue = resolvedValue.bind.apply(resolvedValue, boundArgs);
            }
            registerBoundServerReference(resolvedValue, metaData.id, metaData.bound);
            parentObject[key] = resolvedValue;
            "" === key && null === handler.value && (handler.value = resolvedValue);
            if (parentObject[0] === REACT_ELEMENT_TYPE && "object" === typeof handler.value && null !== handler.value && handler.value.$$typeof === REACT_ELEMENT_TYPE) switch(boundArgs = handler.value, key){
                case "3":
                    boundArgs.props = resolvedValue;
                    break;
                case "4":
                    boundArgs._owner = resolvedValue;
            }
            handler.deps--;
            0 === handler.deps && (resolvedValue = handler.chunk, null !== resolvedValue && "blocked" === resolvedValue.status && (boundArgs = resolvedValue.value, resolvedValue.status = "fulfilled", resolvedValue.value = handler.value, null !== boundArgs && wakeChunk(boundArgs, handler.value)));
        }, function(error) {
            if (!handler.errored) {
                var blockedValue = handler.value;
                handler.errored = !0;
                handler.value = error;
                var chunk = handler.chunk;
                if (null !== chunk && "blocked" === chunk.status) {
                    if ("object" === typeof blockedValue && null !== blockedValue && blockedValue.$$typeof === REACT_ELEMENT_TYPE) {
                        var erroredComponent = {
                            name: getComponentNameFromType(blockedValue.type) || "",
                            owner: blockedValue._owner
                        };
                        erroredComponent.debugStack = blockedValue._debugStack;
                        supportsCreateTask && (erroredComponent.debugTask = blockedValue._debugTask);
                        (chunk._debugInfo || (chunk._debugInfo = [])).push(erroredComponent);
                    }
                    triggerErrorOnChunk(response, chunk, error);
                }
            }
        });
        return null;
    }
    function getOutlinedModel(response, reference, parentObject, key, map) {
        reference = reference.split(":");
        var id = parseInt(reference[0], 16);
        id = getChunk(response, id);
        switch(id.status){
            case "resolved_model":
                initializeModelChunk(id);
                break;
            case "resolved_module":
                initializeModuleChunk(id);
        }
        switch(id.status){
            case "fulfilled":
                for(var value = id.value, i = 1; i < reference.length; i++){
                    for(; value.$$typeof === REACT_LAZY_TYPE;){
                        value = value._payload;
                        switch(value.status){
                            case "resolved_model":
                                initializeModelChunk(value);
                                break;
                            case "resolved_module":
                                initializeModuleChunk(value);
                        }
                        switch(value.status){
                            case "fulfilled":
                                value = value.value;
                                break;
                            case "blocked":
                            case "pending":
                                return waitForReference(value, parentObject, key, response, map, reference.slice(i - 1));
                            case "halted":
                                return initializingHandler ? (response = initializingHandler, response.deps++) : initializingHandler = {
                                    parent: null,
                                    chunk: null,
                                    value: null,
                                    deps: 1,
                                    errored: !1
                                }, null;
                            default:
                                return initializingHandler ? (initializingHandler.errored = !0, initializingHandler.value = value.reason) : initializingHandler = {
                                    parent: null,
                                    chunk: null,
                                    value: value.reason,
                                    deps: 0,
                                    errored: !0
                                }, null;
                        }
                    }
                    value = value[reference[i]];
                }
                response = map(response, value, parentObject, key);
                id._debugInfo && ("object" !== typeof response || null === response || !isArrayImpl(response) && "function" !== typeof response[ASYNC_ITERATOR] && response.$$typeof !== REACT_ELEMENT_TYPE || response._debugInfo || Object.defineProperty(response, "_debugInfo", {
                    configurable: !1,
                    enumerable: !1,
                    writable: !0,
                    value: id._debugInfo
                }));
                return response;
            case "pending":
            case "blocked":
                return waitForReference(id, parentObject, key, response, map, reference);
            case "halted":
                return initializingHandler ? (response = initializingHandler, response.deps++) : initializingHandler = {
                    parent: null,
                    chunk: null,
                    value: null,
                    deps: 1,
                    errored: !1
                }, null;
            default:
                return initializingHandler ? (initializingHandler.errored = !0, initializingHandler.value = id.reason) : initializingHandler = {
                    parent: null,
                    chunk: null,
                    value: id.reason,
                    deps: 0,
                    errored: !0
                }, null;
        }
    }
    function createMap(response, model) {
        return new Map(model);
    }
    function createSet(response, model) {
        return new Set(model);
    }
    function createBlob(response, model) {
        return new Blob(model.slice(1), {
            type: model[0]
        });
    }
    function createFormData(response, model) {
        response = new FormData();
        for(var i = 0; i < model.length; i++)response.append(model[i][0], model[i][1]);
        return response;
    }
    function applyConstructor(response, model, parentObject) {
        Object.setPrototypeOf(parentObject, model.prototype);
    }
    function defineLazyGetter(response, chunk, parentObject, key) {
        Object.defineProperty(parentObject, key, {
            get: function() {
                "resolved_model" === chunk.status && initializeModelChunk(chunk);
                switch(chunk.status){
                    case "fulfilled":
                        return chunk.value;
                    case "rejected":
                        throw chunk.reason;
                }
                return "This object has been omitted by React in the console log to avoid sending too much data from the server. Try logging smaller or more specific objects.";
            },
            enumerable: !0,
            configurable: !1
        });
        return null;
    }
    function extractIterator(response, model) {
        return model[Symbol.iterator]();
    }
    function createModel(response, model) {
        return model;
    }
    function parseModelString(response, parentObject, key, value) {
        if ("$" === value[0]) {
            if ("$" === value) return null !== initializingHandler && "0" === key && (initializingHandler = {
                parent: initializingHandler,
                chunk: null,
                value: null,
                deps: 0,
                errored: !1
            }), REACT_ELEMENT_TYPE;
            switch(value[1]){
                case "$":
                    return value.slice(1);
                case "L":
                    return parentObject = parseInt(value.slice(2), 16), response = getChunk(response, parentObject), createLazyChunkWrapper(response);
                case "@":
                    return parentObject = parseInt(value.slice(2), 16), getChunk(response, parentObject);
                case "S":
                    return Symbol.for(value.slice(2));
                case "F":
                    var ref = value.slice(2);
                    return getOutlinedModel(response, ref, parentObject, key, loadServerReference);
                case "T":
                    parentObject = "$" + value.slice(2);
                    response = response._tempRefs;
                    if (null == response) throw Error("Missing a temporary reference set but the RSC response returned a temporary reference. Pass a temporaryReference option with the set that was used with the reply.");
                    return response.get(parentObject);
                case "Q":
                    return ref = value.slice(2), getOutlinedModel(response, ref, parentObject, key, createMap);
                case "W":
                    return ref = value.slice(2), getOutlinedModel(response, ref, parentObject, key, createSet);
                case "B":
                    return ref = value.slice(2), getOutlinedModel(response, ref, parentObject, key, createBlob);
                case "K":
                    return ref = value.slice(2), getOutlinedModel(response, ref, parentObject, key, createFormData);
                case "Z":
                    return ref = value.slice(2), getOutlinedModel(response, ref, parentObject, key, resolveErrorDev);
                case "i":
                    return ref = value.slice(2), getOutlinedModel(response, ref, parentObject, key, extractIterator);
                case "I":
                    return Infinity;
                case "-":
                    return "$-0" === value ? -0 : -Infinity;
                case "N":
                    return NaN;
                case "u":
                    return;
                case "D":
                    return new Date(Date.parse(value.slice(2)));
                case "n":
                    return BigInt(value.slice(2));
                case "P":
                    return ref = value.slice(2), getOutlinedModel(response, ref, parentObject, key, applyConstructor);
                case "E":
                    response = value.slice(2);
                    try {
                        return (0, eval)(response);
                    } catch (x) {
                        if (response.startsWith("(async function")) {
                            if (parentObject = response.indexOf("(", 15), -1 !== parentObject) return response = response.slice(15, parentObject).trim(), (0, eval)("({" + JSON.stringify(response) + ":async function(){}})")[response];
                        } else if (response.startsWith("(function")) {
                            if (parentObject = response.indexOf("(", 9), -1 !== parentObject) return response = response.slice(9, parentObject).trim(), (0, eval)("({" + JSON.stringify(response) + ":function(){}})")[response];
                        } else if (response.startsWith("(class") && (parentObject = response.indexOf("{", 6), -1 !== parentObject)) return response = response.slice(6, parentObject).trim(), (0, eval)("({" + JSON.stringify(response) + ":class{}})")[response];
                        return function() {};
                    }
                case "Y":
                    if (2 < value.length && (ref = response._debugChannel)) {
                        if ("@" === value[2]) return parentObject = value.slice(3), key = parseInt(parentObject, 16), response._chunks.has(key) || ref("P:" + parentObject), getChunk(response, key);
                        value = value.slice(2);
                        var _id2 = parseInt(value, 16);
                        response._chunks.has(_id2) || ref("Q:" + value);
                        ref = getChunk(response, _id2);
                        return "fulfilled" === ref.status ? ref.value : defineLazyGetter(response, ref, parentObject, key);
                    }
                    Object.defineProperty(parentObject, key, {
                        get: function() {
                            return "This object has been omitted by React in the console log to avoid sending too much data from the server. Try logging smaller or more specific objects.";
                        },
                        enumerable: !0,
                        configurable: !1
                    });
                    return null;
                default:
                    return ref = value.slice(1), getOutlinedModel(response, ref, parentObject, key, createModel);
            }
        }
        return value;
    }
    function missingCall() {
        throw Error('Trying to call a function from "use server" but the callServer option was not implemented in your router runtime.');
    }
    function ResponseInstance(bundlerConfig, serverReferenceConfig, moduleLoading, callServer, encodeFormAction, nonce, temporaryReferences, findSourceMapURL, replayConsole, environmentName, debugChannel) {
        var chunks = new Map();
        this._bundlerConfig = bundlerConfig;
        this._serverReferenceConfig = serverReferenceConfig;
        this._moduleLoading = moduleLoading;
        this._callServer = void 0 !== callServer ? callServer : missingCall;
        this._encodeFormAction = encodeFormAction;
        this._nonce = nonce;
        this._chunks = chunks;
        this._stringDecoder = new TextDecoder();
        this._fromJSON = null;
        this._closed = !1;
        this._closedReason = null;
        this._tempRefs = temporaryReferences;
        this._pendingChunks = 0;
        this._weakResponse = {
            weak: new WeakRef(this),
            response: this
        };
        this._debugRootOwner = bundlerConfig = void 0 === ReactSharedInteralsServer || null === ReactSharedInteralsServer.A ? null : ReactSharedInteralsServer.A.getOwner();
        this._debugRootStack = null !== bundlerConfig ? Error("react-stack-top-frame") : null;
        environmentName = void 0 === environmentName ? "Server" : environmentName;
        supportsCreateTask && (this._debugRootTask = console.createTask('"use ' + environmentName.toLowerCase() + '"'));
        this._debugFindSourceMapURL = findSourceMapURL;
        this._debugChannel = debugChannel;
        this._replayConsole = replayConsole;
        this._rootEnvironmentName = environmentName;
        debugChannel && (null === debugChannelRegistry ? (debugChannel(""), this._debugChannel = void 0) : debugChannelRegistry.register(this, debugChannel));
        this._fromJSON = createFromJSONCallback(this);
    }
    function createStreamState() {
        return {
            _rowState: 0,
            _rowID: 0,
            _rowTag: 0,
            _rowLength: 0,
            _buffer: []
        };
    }
    function resolveDebugHalt(response, id) {
        var chunks = response._chunks, chunk = chunks.get(id);
        chunk || chunks.set(id, chunk = createPendingChunk(response));
        if ("pending" === chunk.status || "blocked" === chunk.status) releasePendingChunk(response, chunk), response = chunk, response.status = "halted", response.value = null, response.reason = null;
    }
    function resolveModel(response, id, model) {
        var chunks = response._chunks, chunk = chunks.get(id);
        chunk ? resolveModelChunk(response, chunk, model) : chunks.set(id, new ReactPromise("resolved_model", model, response));
    }
    function resolveText(response, id, text) {
        var chunks = response._chunks, chunk = chunks.get(id);
        chunk && "pending" !== chunk.status ? chunk.reason.enqueueValue(text) : (chunk && releasePendingChunk(response, chunk), chunks.set(id, new ReactPromise("fulfilled", text, null)));
    }
    function resolveBuffer(response, id, buffer) {
        var chunks = response._chunks, chunk = chunks.get(id);
        chunk && "pending" !== chunk.status ? chunk.reason.enqueueValue(buffer) : (chunk && releasePendingChunk(response, chunk), chunks.set(id, new ReactPromise("fulfilled", buffer, null)));
    }
    function resolveModule(response, id, model) {
        var chunks = response._chunks, chunk = chunks.get(id);
        model = JSON.parse(model, response._fromJSON);
        var clientReference = resolveClientReference(response._bundlerConfig, model);
        if (model = preloadModule(clientReference)) {
            if (chunk) {
                releasePendingChunk(response, chunk);
                var blockedChunk = chunk;
                blockedChunk.status = "blocked";
            } else blockedChunk = new ReactPromise("blocked", null, null), chunks.set(id, blockedChunk);
            model.then(function() {
                return resolveModuleChunk(response, blockedChunk, clientReference);
            }, function(error) {
                return triggerErrorOnChunk(response, blockedChunk, error);
            });
        } else chunk ? resolveModuleChunk(response, chunk, clientReference) : chunks.set(id, new ReactPromise("resolved_module", clientReference, null));
    }
    function resolveStream(response, id, stream, controller) {
        var chunks = response._chunks, chunk = chunks.get(id);
        chunk ? "pending" === chunk.status && (releasePendingChunk(response, chunk), response = chunk.value, chunk.status = "fulfilled", chunk.value = stream, chunk.reason = controller, null !== response && wakeChunk(response, chunk.value)) : chunks.set(id, new ReactPromise("fulfilled", stream, controller));
    }
    function startReadableStream(response, id, type) {
        var controller = null;
        type = new ReadableStream({
            type: type,
            start: function(c) {
                controller = c;
            }
        });
        var previousBlockedChunk = null;
        resolveStream(response, id, type, {
            enqueueValue: function(value) {
                null === previousBlockedChunk ? controller.enqueue(value) : previousBlockedChunk.then(function() {
                    controller.enqueue(value);
                });
            },
            enqueueModel: function(json) {
                if (null === previousBlockedChunk) {
                    var chunk = new ReactPromise("resolved_model", json, response);
                    initializeModelChunk(chunk);
                    "fulfilled" === chunk.status ? controller.enqueue(chunk.value) : (chunk.then(function(v) {
                        return controller.enqueue(v);
                    }, function(e) {
                        return controller.error(e);
                    }), previousBlockedChunk = chunk);
                } else {
                    chunk = previousBlockedChunk;
                    var _chunk3 = createPendingChunk(response);
                    _chunk3.then(function(v) {
                        return controller.enqueue(v);
                    }, function(e) {
                        return controller.error(e);
                    });
                    previousBlockedChunk = _chunk3;
                    chunk.then(function() {
                        previousBlockedChunk === _chunk3 && (previousBlockedChunk = null);
                        resolveModelChunk(response, _chunk3, json);
                    });
                }
            },
            close: function() {
                if (null === previousBlockedChunk) controller.close();
                else {
                    var blockedChunk = previousBlockedChunk;
                    previousBlockedChunk = null;
                    blockedChunk.then(function() {
                        return controller.close();
                    });
                }
            },
            error: function(error) {
                if (null === previousBlockedChunk) controller.error(error);
                else {
                    var blockedChunk = previousBlockedChunk;
                    previousBlockedChunk = null;
                    blockedChunk.then(function() {
                        return controller.error(error);
                    });
                }
            }
        });
    }
    function asyncIterator() {
        return this;
    }
    function createIterator(next) {
        next = {
            next: next
        };
        next[ASYNC_ITERATOR] = asyncIterator;
        return next;
    }
    function startAsyncIterable(response, id, iterator) {
        var buffer = [], closed = !1, nextWriteIndex = 0, iterable = {};
        iterable[ASYNC_ITERATOR] = function() {
            var nextReadIndex = 0;
            return createIterator(function(arg) {
                if (void 0 !== arg) throw Error("Values cannot be passed to next() of AsyncIterables passed to Client Components.");
                if (nextReadIndex === buffer.length) {
                    if (closed) return new ReactPromise("fulfilled", {
                        done: !0,
                        value: void 0
                    }, null);
                    buffer[nextReadIndex] = createPendingChunk(response);
                }
                return buffer[nextReadIndex++];
            });
        };
        resolveStream(response, id, iterator ? iterable[ASYNC_ITERATOR]() : iterable, {
            enqueueValue: function(value) {
                if (nextWriteIndex === buffer.length) buffer[nextWriteIndex] = new ReactPromise("fulfilled", {
                    done: !1,
                    value: value
                }, null);
                else {
                    var chunk = buffer[nextWriteIndex], resolveListeners = chunk.value, rejectListeners = chunk.reason;
                    chunk.status = "fulfilled";
                    chunk.value = {
                        done: !1,
                        value: value
                    };
                    null !== resolveListeners && wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners);
                }
                nextWriteIndex++;
            },
            enqueueModel: function(value) {
                nextWriteIndex === buffer.length ? buffer[nextWriteIndex] = createResolvedIteratorResultChunk(response, value, !1) : resolveIteratorResultChunk(response, buffer[nextWriteIndex], value, !1);
                nextWriteIndex++;
            },
            close: function(value) {
                closed = !0;
                nextWriteIndex === buffer.length ? buffer[nextWriteIndex] = createResolvedIteratorResultChunk(response, value, !0) : resolveIteratorResultChunk(response, buffer[nextWriteIndex], value, !0);
                for(nextWriteIndex++; nextWriteIndex < buffer.length;)resolveIteratorResultChunk(response, buffer[nextWriteIndex++], '"$undefined"', !0);
            },
            error: function(error) {
                closed = !0;
                for(nextWriteIndex === buffer.length && (buffer[nextWriteIndex] = createPendingChunk(response)); nextWriteIndex < buffer.length;)triggerErrorOnChunk(response, buffer[nextWriteIndex++], error);
            }
        });
    }
    function stopStream(response, id, row) {
        (response = response._chunks.get(id)) && "fulfilled" === response.status && response.reason.close("" === row ? '"$undefined"' : row);
    }
    function resolveErrorDev(response, errorInfo) {
        var name = errorInfo.name, env = errorInfo.env;
        errorInfo = buildFakeCallStack(response, errorInfo.stack, env, !1, Error.bind(null, errorInfo.message || "An error occurred in the Server Components render but no message was provided"));
        response = getRootTask(response, env);
        response = null != response ? response.run(errorInfo) : errorInfo();
        response.name = name;
        response.environmentName = env;
        return response;
    }
    function resolveHint(response, code, model) {
        response = JSON.parse(model, response._fromJSON);
        model = ReactDOMSharedInternals.d;
        switch(code){
            case "D":
                model.D(response);
                break;
            case "C":
                "string" === typeof response ? model.C(response) : model.C(response[0], response[1]);
                break;
            case "L":
                code = response[0];
                var as = response[1];
                3 === response.length ? model.L(code, as, response[2]) : model.L(code, as);
                break;
            case "m":
                "string" === typeof response ? model.m(response) : model.m(response[0], response[1]);
                break;
            case "X":
                "string" === typeof response ? model.X(response) : model.X(response[0], response[1]);
                break;
            case "S":
                "string" === typeof response ? model.S(response) : model.S(response[0], 0 === response[1] ? void 0 : response[1], 3 === response.length ? response[2] : void 0);
                break;
            case "M":
                "string" === typeof response ? model.M(response) : model.M(response[0], response[1]);
        }
    }
    function createFakeFunction(name, filename, sourceMap, line, col, enclosingLine, enclosingCol, environmentName) {
        name || (name = "<anonymous>");
        var encodedName = JSON.stringify(name);
        1 > enclosingLine ? enclosingLine = 0 : enclosingLine--;
        1 > enclosingCol ? enclosingCol = 0 : enclosingCol--;
        1 > line ? line = 0 : line--;
        1 > col ? col = 0 : col--;
        if (line < enclosingLine || line === enclosingLine && col < enclosingCol) enclosingCol = enclosingLine = 0;
        1 > line ? (line = encodedName.length + 3, enclosingCol -= line, 0 > enclosingCol && (enclosingCol = 0), col = col - enclosingCol - line - 3, 0 > col && (col = 0), encodedName = "({" + encodedName + ":" + " ".repeat(enclosingCol) + "_=>" + " ".repeat(col) + "_()})") : 1 > enclosingLine ? (enclosingCol -= encodedName.length + 3, 0 > enclosingCol && (enclosingCol = 0), encodedName = "({" + encodedName + ":" + " ".repeat(enclosingCol) + "_=>" + "\n".repeat(line - enclosingLine) + " ".repeat(col) + "_()})") : enclosingLine === line ? (col = col - enclosingCol - 3, 0 > col && (col = 0), encodedName = "\n".repeat(enclosingLine - 1) + "({" + encodedName + ":\n" + " ".repeat(enclosingCol) + "_=>" + " ".repeat(col) + "_()})") : encodedName = "\n".repeat(enclosingLine - 1) + "({" + encodedName + ":\n" + " ".repeat(enclosingCol) + "_=>" + "\n".repeat(line - enclosingLine) + " ".repeat(col) + "_()})";
        encodedName = 1 > enclosingLine ? encodedName + "\n/* This module was rendered by a Server Component. Turn on Source Maps to see the server source. */" : "/* This module was rendered by a Server Component. Turn on Source Maps to see the server source. */" + encodedName;
        filename.startsWith("/") && (filename = "file://" + filename);
        sourceMap ? (encodedName += "\n//# sourceURL=rsc://React/" + encodeURIComponent(environmentName) + "/" + encodeURI(filename) + "?" + fakeFunctionIdx++, encodedName += "\n//# sourceMappingURL=" + sourceMap) : encodedName = filename ? encodedName + ("\n//# sourceURL=" + encodeURI(filename)) : encodedName + "\n//# sourceURL=<anonymous>";
        try {
            var fn = (0, eval)(encodedName)[name];
        } catch (x) {
            fn = function(_) {
                return _();
            };
        }
        return fn;
    }
    function buildFakeCallStack(response, stack, environmentName, useEnclosingLine, innerCall) {
        for(var i = 0; i < stack.length; i++){
            var frame = stack[i], frameKey = frame.join("-") + "-" + environmentName + (useEnclosingLine ? "-e" : "-n"), fn = fakeFunctionCache.get(frameKey);
            if (void 0 === fn) {
                fn = frame[0];
                var filename = frame[1], line = frame[2], col = frame[3], enclosingLine = frame[4];
                frame = frame[5];
                var findSourceMapURL = response._debugFindSourceMapURL;
                findSourceMapURL = findSourceMapURL ? findSourceMapURL(filename, environmentName) : null;
                fn = createFakeFunction(fn, filename, findSourceMapURL, line, col, useEnclosingLine ? line : enclosingLine, useEnclosingLine ? col : frame, environmentName);
                fakeFunctionCache.set(frameKey, fn);
            }
            innerCall = fn.bind(null, innerCall);
        }
        return innerCall;
    }
    function getRootTask(response, childEnvironmentName) {
        var rootTask = response._debugRootTask;
        return rootTask ? response._rootEnvironmentName !== childEnvironmentName ? (response = console.createTask.bind(console, '"use ' + childEnvironmentName.toLowerCase() + '"'), rootTask.run(response)) : rootTask : null;
    }
    function initializeFakeTask(response, debugInfo) {
        if (!supportsCreateTask || null == debugInfo.stack) return null;
        var cachedEntry = debugInfo.debugTask;
        if (void 0 !== cachedEntry) return cachedEntry;
        var useEnclosingLine = void 0 === debugInfo.key, stack = debugInfo.stack, env = null == debugInfo.env ? response._rootEnvironmentName : debugInfo.env;
        cachedEntry = null == debugInfo.owner || null == debugInfo.owner.env ? response._rootEnvironmentName : debugInfo.owner.env;
        var ownerTask = null == debugInfo.owner ? null : initializeFakeTask(response, debugInfo.owner);
        env = env !== cachedEntry ? '"use ' + env.toLowerCase() + '"' : void 0 !== debugInfo.key ? "<" + (debugInfo.name || "...") + ">" : void 0 !== debugInfo.name ? debugInfo.name || "unknown" : "await " + (debugInfo.awaited.name || "unknown");
        env = console.createTask.bind(console, env);
        useEnclosingLine = buildFakeCallStack(response, stack, cachedEntry, useEnclosingLine, env);
        null === ownerTask ? (response = getRootTask(response, cachedEntry), response = null != response ? response.run(useEnclosingLine) : useEnclosingLine()) : response = ownerTask.run(useEnclosingLine);
        return debugInfo.debugTask = response;
    }
    function fakeJSXCallSite() {
        return Error("react-stack-top-frame");
    }
    function initializeFakeStack(response, debugInfo) {
        if (void 0 === debugInfo.debugStack) {
            null != debugInfo.stack && (debugInfo.debugStack = createFakeJSXCallStackInDEV(response, debugInfo.stack, null == debugInfo.env ? "" : debugInfo.env));
            var owner = debugInfo.owner;
            null != owner && (initializeFakeStack(response, owner), void 0 === owner.debugLocation && null != debugInfo.debugStack && (owner.debugLocation = debugInfo.debugStack));
        }
    }
    function resolveDebugInfo(response, id, debugInfo) {
        void 0 !== debugInfo.stack && initializeFakeTask(response, debugInfo);
        null == debugInfo.owner && null != response._debugRootOwner ? (debugInfo.owner = response._debugRootOwner, debugInfo.stack = null, debugInfo.debugStack = response._debugRootStack, debugInfo.debugTask = response._debugRootTask) : void 0 !== debugInfo.stack && initializeFakeStack(response, debugInfo);
        response = getChunk(response, id);
        (response._debugInfo || (response._debugInfo = [])).push(debugInfo);
    }
    function getCurrentStackInDEV() {
        var owner = currentOwnerInDEV;
        if (null === owner) return "";
        try {
            var info = "";
            if (owner.owner || "string" !== typeof owner.name) {
                for(; owner;){
                    var ownerStack = owner.debugStack;
                    if (null != ownerStack) {
                        if (owner = owner.owner) {
                            var JSCompiler_temp_const = info;
                            var error = ownerStack, prevPrepareStackTrace = Error.prepareStackTrace;
                            Error.prepareStackTrace = void 0;
                            var stack = error.stack;
                            Error.prepareStackTrace = prevPrepareStackTrace;
                            stack.startsWith("Error: react-stack-top-frame\n") && (stack = stack.slice(29));
                            var idx = stack.indexOf("\n");
                            -1 !== idx && (stack = stack.slice(idx + 1));
                            idx = stack.indexOf("react_stack_bottom_frame");
                            -1 !== idx && (idx = stack.lastIndexOf("\n", idx));
                            var JSCompiler_inline_result = -1 !== idx ? stack = stack.slice(0, idx) : "";
                            info = JSCompiler_temp_const + ("\n" + JSCompiler_inline_result);
                        }
                    } else break;
                }
                var JSCompiler_inline_result$jscomp$0 = info;
            } else {
                JSCompiler_temp_const = owner.name;
                if (void 0 === prefix) try {
                    throw Error();
                } catch (x) {
                    prefix = (error = x.stack.trim().match(/\n( *(at )?)/)) && error[1] || "", suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
                }
                JSCompiler_inline_result$jscomp$0 = "\n" + prefix + JSCompiler_temp_const + suffix;
            }
        } catch (x) {
            JSCompiler_inline_result$jscomp$0 = "\nError generating stack: " + x.message + "\n" + x.stack;
        }
        return JSCompiler_inline_result$jscomp$0;
    }
    function resolveConsoleEntry(response, value) {
        if (response._replayConsole) {
            var payload = JSON.parse(value, response._fromJSON);
            value = payload[0];
            var stackTrace = payload[1], owner = payload[2], env = payload[3];
            payload = payload.slice(4);
            replayConsoleWithCallStackInDEV(response, value, stackTrace, owner, env, payload);
        }
    }
    function mergeBuffer(buffer, lastChunk) {
        for(var l = buffer.length, byteLength = lastChunk.length, i = 0; i < l; i++)byteLength += buffer[i].byteLength;
        byteLength = new Uint8Array(byteLength);
        for(var _i3 = i = 0; _i3 < l; _i3++){
            var chunk = buffer[_i3];
            byteLength.set(chunk, i);
            i += chunk.byteLength;
        }
        byteLength.set(lastChunk, i);
        return byteLength;
    }
    function resolveTypedArray(response, id, buffer, lastChunk, constructor, bytesPerElement) {
        buffer = 0 === buffer.length && 0 === lastChunk.byteOffset % bytesPerElement ? lastChunk : mergeBuffer(buffer, lastChunk);
        constructor = new constructor(buffer.buffer, buffer.byteOffset, buffer.byteLength / bytesPerElement);
        resolveBuffer(response, id, constructor);
    }
    function flushInitialRenderPerformance() {}
    function processFullBinaryRow(response, id, tag, buffer, chunk) {
        switch(tag){
            case 65:
                resolveBuffer(response, id, mergeBuffer(buffer, chunk).buffer);
                return;
            case 79:
                resolveTypedArray(response, id, buffer, chunk, Int8Array, 1);
                return;
            case 111:
                resolveBuffer(response, id, 0 === buffer.length ? chunk : mergeBuffer(buffer, chunk));
                return;
            case 85:
                resolveTypedArray(response, id, buffer, chunk, Uint8ClampedArray, 1);
                return;
            case 83:
                resolveTypedArray(response, id, buffer, chunk, Int16Array, 2);
                return;
            case 115:
                resolveTypedArray(response, id, buffer, chunk, Uint16Array, 2);
                return;
            case 76:
                resolveTypedArray(response, id, buffer, chunk, Int32Array, 4);
                return;
            case 108:
                resolveTypedArray(response, id, buffer, chunk, Uint32Array, 4);
                return;
            case 71:
                resolveTypedArray(response, id, buffer, chunk, Float32Array, 4);
                return;
            case 103:
                resolveTypedArray(response, id, buffer, chunk, Float64Array, 8);
                return;
            case 77:
                resolveTypedArray(response, id, buffer, chunk, BigInt64Array, 8);
                return;
            case 109:
                resolveTypedArray(response, id, buffer, chunk, BigUint64Array, 8);
                return;
            case 86:
                resolveTypedArray(response, id, buffer, chunk, DataView, 1);
                return;
        }
        for(var stringDecoder = response._stringDecoder, row = "", i = 0; i < buffer.length; i++)row += stringDecoder.decode(buffer[i], decoderOptions);
        row += stringDecoder.decode(chunk);
        processFullStringRow(response, id, tag, row);
    }
    function processFullStringRow(response, id, tag, row) {
        switch(tag){
            case 73:
                resolveModule(response, id, row);
                break;
            case 72:
                resolveHint(response, row[0], row.slice(1));
                break;
            case 69:
                row = JSON.parse(row);
                tag = resolveErrorDev(response, row);
                tag.digest = row.digest;
                row = response._chunks;
                var chunk = row.get(id);
                chunk ? triggerErrorOnChunk(response, chunk, tag) : row.set(id, new ReactPromise("rejected", null, tag));
                break;
            case 84:
                resolveText(response, id, row);
                break;
            case 78:
            case 68:
                tag = new ReactPromise("resolved_model", row, response);
                initializeModelChunk(tag);
                "fulfilled" === tag.status ? resolveDebugInfo(response, id, tag.value) : tag.then(function(v) {
                    return resolveDebugInfo(response, id, v);
                }, function() {});
                break;
            case 74:
            case 87:
                resolveConsoleEntry(response, row);
                break;
            case 82:
                startReadableStream(response, id, void 0);
                break;
            case 114:
                startReadableStream(response, id, "bytes");
                break;
            case 88:
                startAsyncIterable(response, id, !1);
                break;
            case 120:
                startAsyncIterable(response, id, !0);
                break;
            case 67:
                stopStream(response, id, row);
                break;
            default:
                "" === row ? resolveDebugHalt(response, id) : resolveModel(response, id, row);
        }
    }
    function processBinaryChunk(weakResponse, streamState, chunk) {
        if (void 0 !== weakResponse.weak.deref()) {
            var response = unwrapWeakResponse(weakResponse), i = 0, rowState = streamState._rowState;
            weakResponse = streamState._rowID;
            for(var rowTag = streamState._rowTag, rowLength = streamState._rowLength, buffer = streamState._buffer, chunkLength = chunk.length; i < chunkLength;){
                var lastIdx = -1;
                switch(rowState){
                    case 0:
                        lastIdx = chunk[i++];
                        58 === lastIdx ? rowState = 1 : weakResponse = weakResponse << 4 | (96 < lastIdx ? lastIdx - 87 : lastIdx - 48);
                        continue;
                    case 1:
                        rowState = chunk[i];
                        84 === rowState || 65 === rowState || 79 === rowState || 111 === rowState || 85 === rowState || 83 === rowState || 115 === rowState || 76 === rowState || 108 === rowState || 71 === rowState || 103 === rowState || 77 === rowState || 109 === rowState || 86 === rowState ? (rowTag = rowState, rowState = 2, i++) : 64 < rowState && 91 > rowState || 35 === rowState || 114 === rowState || 120 === rowState ? (rowTag = rowState, rowState = 3, i++) : (rowTag = 0, rowState = 3);
                        continue;
                    case 2:
                        lastIdx = chunk[i++];
                        44 === lastIdx ? rowState = 4 : rowLength = rowLength << 4 | (96 < lastIdx ? lastIdx - 87 : lastIdx - 48);
                        continue;
                    case 3:
                        lastIdx = chunk.indexOf(10, i);
                        break;
                    case 4:
                        lastIdx = i + rowLength, lastIdx > chunk.length && (lastIdx = -1);
                }
                var offset = chunk.byteOffset + i;
                if (-1 < lastIdx) rowLength = new Uint8Array(chunk.buffer, offset, lastIdx - i), processFullBinaryRow(response, weakResponse, rowTag, buffer, rowLength), i = lastIdx, 3 === rowState && i++, rowLength = weakResponse = rowTag = rowState = 0, buffer.length = 0;
                else {
                    chunk = new Uint8Array(chunk.buffer, offset, chunk.byteLength - i);
                    buffer.push(chunk);
                    rowLength -= chunk.byteLength;
                    break;
                }
            }
            streamState._rowState = rowState;
            streamState._rowID = weakResponse;
            streamState._rowTag = rowTag;
            streamState._rowLength = rowLength;
        }
    }
    function createFromJSONCallback(response) {
        return function(key, value) {
            if ("string" === typeof value) return parseModelString(response, this, key, value);
            if ("object" === typeof value && null !== value) {
                if (value[0] === REACT_ELEMENT_TYPE) b: {
                    var owner = value[4];
                    key = value[5];
                    var validated = value[6];
                    value = {
                        $$typeof: REACT_ELEMENT_TYPE,
                        type: value[1],
                        key: value[2],
                        props: value[3],
                        _owner: void 0 === owner ? null : owner
                    };
                    Object.defineProperty(value, "ref", {
                        enumerable: !1,
                        get: nullRefGetter
                    });
                    value._store = {};
                    Object.defineProperty(value._store, "validated", {
                        configurable: !1,
                        enumerable: !1,
                        writable: !0,
                        value: validated
                    });
                    Object.defineProperty(value, "_debugInfo", {
                        configurable: !1,
                        enumerable: !1,
                        writable: !0,
                        value: null
                    });
                    Object.defineProperty(value, "_debugStack", {
                        configurable: !1,
                        enumerable: !1,
                        writable: !0,
                        value: void 0 === key ? null : key
                    });
                    Object.defineProperty(value, "_debugTask", {
                        configurable: !1,
                        enumerable: !1,
                        writable: !0,
                        value: null
                    });
                    if (null !== initializingHandler) {
                        validated = initializingHandler;
                        initializingHandler = validated.parent;
                        if (validated.errored) {
                            key = new ReactPromise("rejected", null, validated.value);
                            initializeElement(response, value);
                            validated = {
                                name: getComponentNameFromType(value.type) || "",
                                owner: value._owner
                            };
                            validated.debugStack = value._debugStack;
                            supportsCreateTask && (validated.debugTask = value._debugTask);
                            key._debugInfo = [
                                validated
                            ];
                            value = createLazyChunkWrapper(key);
                            break b;
                        }
                        if (0 < validated.deps) {
                            key = new ReactPromise("blocked", null, null);
                            validated.value = value;
                            validated.chunk = key;
                            value = initializeElement.bind(null, response, value);
                            key.then(value, value);
                            value = createLazyChunkWrapper(key);
                            break b;
                        }
                    }
                    initializeElement(response, value);
                }
                return value;
            }
            return value;
        };
    }
    function close(weakResponse) {
        reportGlobalError(weakResponse, Error("Connection closed."));
    }
    function createDebugCallbackFromWritableStream(debugWritable) {
        var textEncoder = new TextEncoder(), writer = debugWritable.getWriter();
        return function(message) {
            "" === message ? writer.close() : writer.write(textEncoder.encode(message + "\n")).catch(console.error);
        };
    }
    function createResponseFromOptions(options) {
        var debugChannel = options && void 0 !== options.debugChannel && void 0 !== options.debugChannel.writable ? createDebugCallbackFromWritableStream(options.debugChannel.writable) : void 0;
        return new ResponseInstance(null, null, null, options && options.callServer ? options.callServer : void 0, void 0, void 0, options && options.temporaryReferences ? options.temporaryReferences : void 0, options && options.findSourceMapURL ? options.findSourceMapURL : void 0, options ? !1 !== options.replayConsoleLogs : !0, options && options.environmentName ? options.environmentName : void 0, debugChannel)._weakResponse;
    }
    function startReadingFromUniversalStream(response$jscomp$0, stream) {
        function progress(_ref) {
            var value = _ref.value;
            if (_ref.done) close(response$jscomp$0);
            else {
                if (value instanceof ArrayBuffer) processBinaryChunk(response$jscomp$0, streamState, new Uint8Array(value));
                else if ("string" === typeof value) {
                    if (_ref = streamState, void 0 !== response$jscomp$0.weak.deref()) {
                        for(var response = unwrapWeakResponse(response$jscomp$0), i = 0, rowState = _ref._rowState, rowID = _ref._rowID, rowTag = _ref._rowTag, rowLength = _ref._rowLength, buffer = _ref._buffer, chunkLength = value.length; i < chunkLength;){
                            var lastIdx = -1;
                            switch(rowState){
                                case 0:
                                    lastIdx = value.charCodeAt(i++);
                                    58 === lastIdx ? rowState = 1 : rowID = rowID << 4 | (96 < lastIdx ? lastIdx - 87 : lastIdx - 48);
                                    continue;
                                case 1:
                                    rowState = value.charCodeAt(i);
                                    84 === rowState || 65 === rowState || 79 === rowState || 111 === rowState || 85 === rowState || 83 === rowState || 115 === rowState || 76 === rowState || 108 === rowState || 71 === rowState || 103 === rowState || 77 === rowState || 109 === rowState || 86 === rowState ? (rowTag = rowState, rowState = 2, i++) : 64 < rowState && 91 > rowState || 114 === rowState || 120 === rowState ? (rowTag = rowState, rowState = 3, i++) : (rowTag = 0, rowState = 3);
                                    continue;
                                case 2:
                                    lastIdx = value.charCodeAt(i++);
                                    44 === lastIdx ? rowState = 4 : rowLength = rowLength << 4 | (96 < lastIdx ? lastIdx - 87 : lastIdx - 48);
                                    continue;
                                case 3:
                                    lastIdx = value.indexOf("\n", i);
                                    break;
                                case 4:
                                    if (84 !== rowTag) throw Error("Binary RSC chunks cannot be encoded as strings. This is a bug in the wiring of the React streams.");
                                    if (rowLength < value.length || value.length > 3 * rowLength) throw Error("String chunks need to be passed in their original shape. Not split into smaller string chunks. This is a bug in the wiring of the React streams.");
                                    lastIdx = value.length;
                            }
                            if (-1 < lastIdx) {
                                if (0 < buffer.length) throw Error("String chunks need to be passed in their original shape. Not split into smaller string chunks. This is a bug in the wiring of the React streams.");
                                i = value.slice(i, lastIdx);
                                processFullStringRow(response, rowID, rowTag, i);
                                i = lastIdx;
                                3 === rowState && i++;
                                rowLength = rowID = rowTag = rowState = 0;
                                buffer.length = 0;
                            } else if (value.length !== i) throw Error("String chunks need to be passed in their original shape. Not split into smaller string chunks. This is a bug in the wiring of the React streams.");
                        }
                        _ref._rowState = rowState;
                        _ref._rowID = rowID;
                        _ref._rowTag = rowTag;
                        _ref._rowLength = rowLength;
                    }
                } else processBinaryChunk(response$jscomp$0, streamState, value);
                return reader.read().then(progress).catch(error);
            }
        }
        function error(e) {
            reportGlobalError(response$jscomp$0, e);
        }
        var streamState = createStreamState(), reader = stream.getReader();
        reader.read().then(progress).catch(error);
    }
    function startReadingFromStream(response, stream, isSecondaryStream) {
        function progress(_ref2) {
            var value = _ref2.value;
            if (_ref2.done) isSecondaryStream || close(response);
            else return processBinaryChunk(response, streamState, value), reader.read().then(progress).catch(error);
        }
        function error(e) {
            reportGlobalError(response, e);
        }
        var streamState = createStreamState(), reader = stream.getReader();
        reader.read().then(progress).catch(error);
    }
    var React = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"), ReactDOM = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react-dom/index.js [app-client] (ecmascript)"), decoderOptions = {
        stream: !0
    }, bind = Function.prototype.bind, chunkCache = new Map(), ReactDOMSharedInternals = ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, ASYNC_ITERATOR = Symbol.asyncIterator, isArrayImpl = Array.isArray, getPrototypeOf = Object.getPrototypeOf, jsxPropsParents = new WeakMap(), jsxChildrenParents = new WeakMap(), CLIENT_REFERENCE_TAG = Symbol.for("react.client.reference"), ObjectPrototype = Object.prototype, knownServerReferences = new WeakMap(), fakeServerFunctionIdx = 0, v8FrameRegExp = /^ {3} at (?:(.+) \((.+):(\d+):(\d+)\)|(?:async )?(.+):(\d+):(\d+))$/, jscSpiderMonkeyFrameRegExp = /(?:(.*)@)?(.*):(\d+):(\d+)/, REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), prefix, suffix;
    new ("function" === typeof WeakMap ? WeakMap : Map)();
    var ReactSharedInteralsServer = React.__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE || ReactSharedInteralsServer;
    ReactPromise.prototype = Object.create(Promise.prototype);
    ReactPromise.prototype.then = function(resolve, reject) {
        switch(this.status){
            case "resolved_model":
                initializeModelChunk(this);
                break;
            case "resolved_module":
                initializeModuleChunk(this);
        }
        switch(this.status){
            case "fulfilled":
                "function" === typeof resolve && resolve(this.value);
                break;
            case "pending":
            case "blocked":
                "function" === typeof resolve && (null === this.value && (this.value = []), this.value.push(resolve));
                "function" === typeof reject && (null === this.reason && (this.reason = []), this.reason.push(reject));
                break;
            case "halted":
                break;
            default:
                "function" === typeof reject && reject(this.reason);
        }
    };
    var debugChannelRegistry = "function" === typeof FinalizationRegistry ? new FinalizationRegistry(cleanupDebugChannel) : null, initializingHandler = null, supportsCreateTask = !!console.createTask, fakeFunctionCache = new Map(), fakeFunctionIdx = 0, createFakeJSXCallStack = {
        react_stack_bottom_frame: function(response, stack, environmentName) {
            return buildFakeCallStack(response, stack, environmentName, !1, fakeJSXCallSite)();
        }
    }, createFakeJSXCallStackInDEV = createFakeJSXCallStack.react_stack_bottom_frame.bind(createFakeJSXCallStack), currentOwnerInDEV = null, replayConsoleWithCallStack = {
        react_stack_bottom_frame: function(response, methodName, stackTrace, owner, env, args) {
            var prevStack = ReactSharedInternals.getCurrentStack;
            ReactSharedInternals.getCurrentStack = getCurrentStackInDEV;
            currentOwnerInDEV = null === owner ? response._debugRootOwner : owner;
            try {
                a: {
                    var offset = 0;
                    switch(methodName){
                        case "dir":
                        case "dirxml":
                        case "groupEnd":
                        case "table":
                            var JSCompiler_inline_result = bind.apply(console[methodName], [
                                console
                            ].concat(args));
                            break a;
                        case "assert":
                            offset = 1;
                    }
                    var newArgs = args.slice(0);
                    "string" === typeof newArgs[offset] ? newArgs.splice(offset, 1, "%c%s%c " + newArgs[offset], "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px", " " + env + " ", "") : newArgs.splice(offset, 0, "%c%s%c ", "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px", " " + env + " ", "");
                    newArgs.unshift(console);
                    JSCompiler_inline_result = bind.apply(console[methodName], newArgs);
                }
                var callStack = buildFakeCallStack(response, stackTrace, env, !1, JSCompiler_inline_result);
                if (null != owner) {
                    var task = initializeFakeTask(response, owner);
                    initializeFakeStack(response, owner);
                    if (null !== task) {
                        task.run(callStack);
                        return;
                    }
                }
                var rootTask = getRootTask(response, env);
                null != rootTask ? rootTask.run(callStack) : callStack();
            } finally{
                currentOwnerInDEV = null, ReactSharedInternals.getCurrentStack = prevStack;
            }
        }
    }, replayConsoleWithCallStackInDEV = replayConsoleWithCallStack.react_stack_bottom_frame.bind(replayConsoleWithCallStack);
    (function(internals) {
        if ("undefined" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return !1;
        var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (hook.isDisabled || !hook.supportsFlight) return !0;
        try {
            hook.inject(internals);
        } catch (err) {
            console.error("React instrumentation encountered an error: %s.", err);
        }
        return hook.checkDCE ? !0 : !1;
    })({
        bundleType: 1,
        version: "19.2.0-canary-97cdd5d3-20250710",
        rendererPackageName: "react-server-dom-turbopack",
        currentDispatcherRef: ReactSharedInternals,
        reconcilerVersion: "19.2.0-canary-97cdd5d3-20250710",
        getCurrentComponentInfo: function() {
            return currentOwnerInDEV;
        }
    });
    exports.createFromFetch = function(promiseForResponse, options) {
        var response = createResponseFromOptions(options);
        promiseForResponse.then(function(r) {
            options && options.debugChannel && options.debugChannel.readable ? (startReadingFromUniversalStream(response, options.debugChannel.readable), startReadingFromStream(response, r.body, !0)) : startReadingFromStream(response, r.body, !1);
        }, function(e) {
            reportGlobalError(response, e);
        });
        return getRoot(response);
    };
    exports.createFromReadableStream = function(stream, options) {
        var response = createResponseFromOptions(options);
        options && options.debugChannel && options.debugChannel.readable ? (startReadingFromUniversalStream(response, options.debugChannel.readable), startReadingFromStream(response, stream, !0)) : startReadingFromStream(response, stream, !1);
        return getRoot(response);
    };
    exports.createServerReference = function(id, callServer, encodeFormAction, findSourceMapURL, functionName) {
        function action() {
            var args = Array.prototype.slice.call(arguments);
            return callServer(id, args);
        }
        var location = parseStackLocation(Error("react-stack-top-frame"));
        if (null !== location) {
            encodeFormAction = location[1];
            var line = location[2];
            location = location[3];
            findSourceMapURL = null == findSourceMapURL ? null : findSourceMapURL(encodeFormAction, "Client");
            action = createFakeServerFunction(functionName || "", encodeFormAction, findSourceMapURL, line, location, "Client", action);
        }
        registerBoundServerReference(action, id, null);
        return action;
    };
    exports.createTemporaryReferenceSet = function() {
        return new Map();
    };
    exports.encodeReply = function(value, options) {
        return new Promise(function(resolve, reject) {
            var abort = processReply(value, "", options && options.temporaryReferences ? options.temporaryReferences : void 0, resolve, reject);
            if (options && options.signal) {
                var signal = options.signal;
                if (signal.aborted) abort(signal.reason);
                else {
                    var listener = function() {
                        abort(signal.reason);
                        signal.removeEventListener("abort", listener);
                    };
                    signal.addEventListener("abort", listener);
                }
            }
        });
    };
    exports.registerServerReference = function(reference, id) {
        registerBoundServerReference(reference, id, null);
        return reference;
    };
}();
}}),
"[project]/node_modules/next/dist/compiled/react-server-dom-turbopack/client.browser.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
else {
    module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react-server-dom-turbopack/cjs/react-server-dom-turbopack-client.browser.development.js [app-client] (ecmascript)");
}
}}),
"[project]/node_modules/next/dist/compiled/react-server-dom-turbopack/client.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react-server-dom-turbopack/client.browser.js [app-client] (ecmascript)");
}}),
"[project]/node_modules/next/dist/compiled/strip-ansi/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
(()=>{
    "use strict";
    var e = {
        511: (e)=>{
            e.exports = function() {
                let { onlyFirst: e = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                const r = [
                    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
                    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
                ].join("|");
                return new RegExp(r, e ? undefined : "g");
            };
        },
        532: (e, r, _)=>{
            const t = _(511);
            e.exports = (e)=>typeof e === "string" ? e.replace(t(), "") : e;
        }
    };
    var r = {};
    function __nccwpck_require__(_) {
        var t = r[_];
        if (t !== undefined) {
            return t.exports;
        }
        var a = r[_] = {
            exports: {}
        };
        var n = true;
        try {
            e[_](a, a.exports, __nccwpck_require__);
            n = false;
        } finally{
            if (n) delete r[_];
        }
        return a.exports;
    }
    if (typeof __nccwpck_require__ !== "undefined") __nccwpck_require__.ab = ("TURBOPACK compile-time value", "/ROOT/node_modules/next/dist/compiled/strip-ansi") + "/";
    var _ = __nccwpck_require__(532);
    module.exports = _;
})();
}}),
}]);

//# sourceMappingURL=data:application/json;charset=utf-8;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFtdLAogICJzZWN0aW9ucyI6IFsKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNiwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzcy9icm93c2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe3ZhciBlPXsyMjk6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5leHBvcnRzPXt9O3ZhciByO3ZhciBuO2Z1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKXt0aHJvdyBuZXcgRXJyb3IoXCJzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXCIpfWZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQoKXt0aHJvdyBuZXcgRXJyb3IoXCJjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIil9KGZ1bmN0aW9uKCl7dHJ5e2lmKHR5cGVvZiBzZXRUaW1lb3V0PT09XCJmdW5jdGlvblwiKXtyPXNldFRpbWVvdXR9ZWxzZXtyPWRlZmF1bHRTZXRUaW1vdXR9fWNhdGNoKGUpe3I9ZGVmYXVsdFNldFRpbW91dH10cnl7aWYodHlwZW9mIGNsZWFyVGltZW91dD09PVwiZnVuY3Rpb25cIil7bj1jbGVhclRpbWVvdXR9ZWxzZXtuPWRlZmF1bHRDbGVhclRpbWVvdXR9fWNhdGNoKGUpe249ZGVmYXVsdENsZWFyVGltZW91dH19KSgpO2Z1bmN0aW9uIHJ1blRpbWVvdXQoZSl7aWYocj09PXNldFRpbWVvdXQpe3JldHVybiBzZXRUaW1lb3V0KGUsMCl9aWYoKHI9PT1kZWZhdWx0U2V0VGltb3V0fHwhcikmJnNldFRpbWVvdXQpe3I9c2V0VGltZW91dDtyZXR1cm4gc2V0VGltZW91dChlLDApfXRyeXtyZXR1cm4gcihlLDApfWNhdGNoKHQpe3RyeXtyZXR1cm4gci5jYWxsKG51bGwsZSwwKX1jYXRjaCh0KXtyZXR1cm4gci5jYWxsKHRoaXMsZSwwKX19fWZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChlKXtpZihuPT09Y2xlYXJUaW1lb3V0KXtyZXR1cm4gY2xlYXJUaW1lb3V0KGUpfWlmKChuPT09ZGVmYXVsdENsZWFyVGltZW91dHx8IW4pJiZjbGVhclRpbWVvdXQpe249Y2xlYXJUaW1lb3V0O3JldHVybiBjbGVhclRpbWVvdXQoZSl9dHJ5e3JldHVybiBuKGUpfWNhdGNoKHQpe3RyeXtyZXR1cm4gbi5jYWxsKG51bGwsZSl9Y2F0Y2godCl7cmV0dXJuIG4uY2FsbCh0aGlzLGUpfX19dmFyIGk9W107dmFyIG89ZmFsc2U7dmFyIHU7dmFyIGE9LTE7ZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCl7aWYoIW98fCF1KXtyZXR1cm59bz1mYWxzZTtpZih1Lmxlbmd0aCl7aT11LmNvbmNhdChpKX1lbHNle2E9LTF9aWYoaS5sZW5ndGgpe2RyYWluUXVldWUoKX19ZnVuY3Rpb24gZHJhaW5RdWV1ZSgpe2lmKG8pe3JldHVybn12YXIgZT1ydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7bz10cnVlO3ZhciB0PWkubGVuZ3RoO3doaWxlKHQpe3U9aTtpPVtdO3doaWxlKCsrYTx0KXtpZih1KXt1W2FdLnJ1bigpfX1hPS0xO3Q9aS5sZW5ndGh9dT1udWxsO289ZmFsc2U7cnVuQ2xlYXJUaW1lb3V0KGUpfXQubmV4dFRpY2s9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSk7aWYoYXJndW1lbnRzLmxlbmd0aD4xKXtmb3IodmFyIHI9MTtyPGFyZ3VtZW50cy5sZW5ndGg7cisrKXt0W3ItMV09YXJndW1lbnRzW3JdfX1pLnB1c2gobmV3IEl0ZW0oZSx0KSk7aWYoaS5sZW5ndGg9PT0xJiYhbyl7cnVuVGltZW91dChkcmFpblF1ZXVlKX19O2Z1bmN0aW9uIEl0ZW0oZSx0KXt0aGlzLmZ1bj1lO3RoaXMuYXJyYXk9dH1JdGVtLnByb3RvdHlwZS5ydW49ZnVuY3Rpb24oKXt0aGlzLmZ1bi5hcHBseShudWxsLHRoaXMuYXJyYXkpfTt0LnRpdGxlPVwiYnJvd3NlclwiO3QuYnJvd3Nlcj10cnVlO3QuZW52PXt9O3QuYXJndj1bXTt0LnZlcnNpb249XCJcIjt0LnZlcnNpb25zPXt9O2Z1bmN0aW9uIG5vb3AoKXt9dC5vbj1ub29wO3QuYWRkTGlzdGVuZXI9bm9vcDt0Lm9uY2U9bm9vcDt0Lm9mZj1ub29wO3QucmVtb3ZlTGlzdGVuZXI9bm9vcDt0LnJlbW92ZUFsbExpc3RlbmVycz1ub29wO3QuZW1pdD1ub29wO3QucHJlcGVuZExpc3RlbmVyPW5vb3A7dC5wcmVwZW5kT25jZUxpc3RlbmVyPW5vb3A7dC5saXN0ZW5lcnM9ZnVuY3Rpb24oZSl7cmV0dXJuW119O3QuYmluZGluZz1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZFwiKX07dC5jd2Q9ZnVuY3Rpb24oKXtyZXR1cm5cIi9cIn07dC5jaGRpcj1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWRcIil9O3QudW1hc2s9ZnVuY3Rpb24oKXtyZXR1cm4gMH19fTt2YXIgdD17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHIpe3ZhciBuPXRbcl07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgaT10W3JdPXtleHBvcnRzOnt9fTt2YXIgbz10cnVlO3RyeXtlW3JdKGksaS5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO289ZmFsc2V9ZmluYWxseXtpZihvKWRlbGV0ZSB0W3JdfXJldHVybiBpLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciByPV9fbmNjd3Bja19yZXF1aXJlX18oMjI5KTttb2R1bGUuZXhwb3J0cz1yfSkoKTsiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsQ0FBQztJQUFXLElBQUksSUFBRTtRQUFDLEtBQUksU0FBUyxDQUFDO1lBQUUsSUFBSSxJQUFFLEVBQUUsT0FBTyxHQUFDLENBQUM7WUFBRSxJQUFJO1lBQUUsSUFBSTtZQUFFLFNBQVM7Z0JBQW1CLE1BQU0sSUFBSSxNQUFNO1lBQWtDO1lBQUMsU0FBUztnQkFBc0IsTUFBTSxJQUFJLE1BQU07WUFBb0M7WUFBQyxDQUFDO2dCQUFXLElBQUc7b0JBQUMsSUFBRyxPQUFPLGVBQWEsWUFBVzt3QkFBQyxJQUFFO29CQUFVLE9BQUs7d0JBQUMsSUFBRTtvQkFBZ0I7Z0JBQUMsRUFBQyxPQUFNLEdBQUU7b0JBQUMsSUFBRTtnQkFBZ0I7Z0JBQUMsSUFBRztvQkFBQyxJQUFHLE9BQU8saUJBQWUsWUFBVzt3QkFBQyxJQUFFO29CQUFZLE9BQUs7d0JBQUMsSUFBRTtvQkFBbUI7Z0JBQUMsRUFBQyxPQUFNLEdBQUU7b0JBQUMsSUFBRTtnQkFBbUI7WUFBQyxDQUFDO1lBQUksU0FBUyxXQUFXLENBQUM7Z0JBQUUsSUFBRyxNQUFJLFlBQVc7b0JBQUMsT0FBTyxXQUFXLEdBQUU7Z0JBQUU7Z0JBQUMsSUFBRyxDQUFDLE1BQUksb0JBQWtCLENBQUMsQ0FBQyxLQUFHLFlBQVc7b0JBQUMsSUFBRTtvQkFBVyxPQUFPLFdBQVcsR0FBRTtnQkFBRTtnQkFBQyxJQUFHO29CQUFDLE9BQU8sRUFBRSxHQUFFO2dCQUFFLEVBQUMsT0FBTSxHQUFFO29CQUFDLElBQUc7d0JBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxNQUFLLEdBQUU7b0JBQUUsRUFBQyxPQUFNLEdBQUU7d0JBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxJQUFJLEVBQUMsR0FBRTtvQkFBRTtnQkFBQztZQUFDO1lBQUMsU0FBUyxnQkFBZ0IsQ0FBQztnQkFBRSxJQUFHLE1BQUksY0FBYTtvQkFBQyxPQUFPLGFBQWE7Z0JBQUU7Z0JBQUMsSUFBRyxDQUFDLE1BQUksdUJBQXFCLENBQUMsQ0FBQyxLQUFHLGNBQWE7b0JBQUMsSUFBRTtvQkFBYSxPQUFPLGFBQWE7Z0JBQUU7Z0JBQUMsSUFBRztvQkFBQyxPQUFPLEVBQUU7Z0JBQUUsRUFBQyxPQUFNLEdBQUU7b0JBQUMsSUFBRzt3QkFBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLE1BQUs7b0JBQUUsRUFBQyxPQUFNLEdBQUU7d0JBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxJQUFJLEVBQUM7b0JBQUU7Z0JBQUM7WUFBQztZQUFDLElBQUksSUFBRSxFQUFFO1lBQUMsSUFBSSxJQUFFO1lBQU0sSUFBSTtZQUFFLElBQUksSUFBRSxDQUFDO1lBQUUsU0FBUztnQkFBa0IsSUFBRyxDQUFDLEtBQUcsQ0FBQyxHQUFFO29CQUFDO2dCQUFNO2dCQUFDLElBQUU7Z0JBQU0sSUFBRyxFQUFFLE1BQU0sRUFBQztvQkFBQyxJQUFFLEVBQUUsTUFBTSxDQUFDO2dCQUFFLE9BQUs7b0JBQUMsSUFBRSxDQUFDO2dCQUFDO2dCQUFDLElBQUcsRUFBRSxNQUFNLEVBQUM7b0JBQUM7Z0JBQVk7WUFBQztZQUFDLFNBQVM7Z0JBQWEsSUFBRyxHQUFFO29CQUFDO2dCQUFNO2dCQUFDLElBQUksSUFBRSxXQUFXO2dCQUFpQixJQUFFO2dCQUFLLElBQUksSUFBRSxFQUFFLE1BQU07Z0JBQUMsTUFBTSxFQUFFO29CQUFDLElBQUU7b0JBQUUsSUFBRSxFQUFFO29CQUFDLE1BQU0sRUFBRSxJQUFFLEVBQUU7d0JBQUMsSUFBRyxHQUFFOzRCQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRzt3QkFBRTtvQkFBQztvQkFBQyxJQUFFLENBQUM7b0JBQUUsSUFBRSxFQUFFLE1BQU07Z0JBQUE7Z0JBQUMsSUFBRTtnQkFBSyxJQUFFO2dCQUFNLGdCQUFnQjtZQUFFO1lBQUMsRUFBRSxRQUFRLEdBQUMsU0FBUyxDQUFDO2dCQUFFLElBQUksSUFBRSxJQUFJLE1BQU0sVUFBVSxNQUFNLEdBQUM7Z0JBQUcsSUFBRyxVQUFVLE1BQU0sR0FBQyxHQUFFO29CQUFDLElBQUksSUFBSSxJQUFFLEdBQUUsSUFBRSxVQUFVLE1BQU0sRUFBQyxJQUFJO3dCQUFDLENBQUMsQ0FBQyxJQUFFLEVBQUUsR0FBQyxTQUFTLENBQUMsRUFBRTtvQkFBQTtnQkFBQztnQkFBQyxFQUFFLElBQUksQ0FBQyxJQUFJLEtBQUssR0FBRTtnQkFBSSxJQUFHLEVBQUUsTUFBTSxLQUFHLEtBQUcsQ0FBQyxHQUFFO29CQUFDLFdBQVc7Z0JBQVc7WUFBQztZQUFFLFNBQVMsS0FBSyxDQUFDLEVBQUMsQ0FBQztnQkFBRSxJQUFJLENBQUMsR0FBRyxHQUFDO2dCQUFFLElBQUksQ0FBQyxLQUFLLEdBQUM7WUFBQztZQUFDLEtBQUssU0FBUyxDQUFDLEdBQUcsR0FBQztnQkFBVyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxNQUFLLElBQUksQ0FBQyxLQUFLO1lBQUM7WUFBRSxFQUFFLEtBQUssR0FBQztZQUFVLEVBQUUsT0FBTyxHQUFDO1lBQUssRUFBRSxHQUFHLEdBQUMsQ0FBQztZQUFFLEVBQUUsSUFBSSxHQUFDLEVBQUU7WUFBQyxFQUFFLE9BQU8sR0FBQztZQUFHLEVBQUUsUUFBUSxHQUFDLENBQUM7WUFBRSxTQUFTLFFBQU87WUFBQyxFQUFFLEVBQUUsR0FBQztZQUFLLEVBQUUsV0FBVyxHQUFDO1lBQUssRUFBRSxJQUFJLEdBQUM7WUFBSyxFQUFFLEdBQUcsR0FBQztZQUFLLEVBQUUsY0FBYyxHQUFDO1lBQUssRUFBRSxrQkFBa0IsR0FBQztZQUFLLEVBQUUsSUFBSSxHQUFDO1lBQUssRUFBRSxlQUFlLEdBQUM7WUFBSyxFQUFFLG1CQUFtQixHQUFDO1lBQUssRUFBRSxTQUFTLEdBQUMsU0FBUyxDQUFDO2dCQUFFLE9BQU0sRUFBRTtZQUFBO1lBQUUsRUFBRSxPQUFPLEdBQUMsU0FBUyxDQUFDO2dCQUFFLE1BQU0sSUFBSSxNQUFNO1lBQW1DO1lBQUUsRUFBRSxHQUFHLEdBQUM7Z0JBQVcsT0FBTTtZQUFHO1lBQUUsRUFBRSxLQUFLLEdBQUMsU0FBUyxDQUFDO2dCQUFFLE1BQU0sSUFBSSxNQUFNO1lBQWlDO1lBQUUsRUFBRSxLQUFLLEdBQUM7Z0JBQVcsT0FBTztZQUFDO1FBQUM7SUFBQztJQUFFLElBQUksSUFBRSxDQUFDO0lBQUUsU0FBUyxvQkFBb0IsQ0FBQztRQUFFLElBQUksSUFBRSxDQUFDLENBQUMsRUFBRTtRQUFDLElBQUcsTUFBSSxXQUFVO1lBQUMsT0FBTyxFQUFFLE9BQU87UUFBQTtRQUFDLElBQUksSUFBRSxDQUFDLENBQUMsRUFBRSxHQUFDO1lBQUMsU0FBUSxDQUFDO1FBQUM7UUFBRSxJQUFJLElBQUU7UUFBSyxJQUFHO1lBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFFLEVBQUUsT0FBTyxFQUFDO1lBQXFCLElBQUU7UUFBSyxTQUFRO1lBQUMsSUFBRyxHQUFFLE9BQU8sQ0FBQyxDQUFDLEVBQUU7UUFBQTtRQUFDLE9BQU8sRUFBRSxPQUFPO0lBQUE7SUFBQyxJQUFHLE9BQU8sd0JBQXNCLGFBQVksb0JBQW9CLEVBQUUsR0FBQyxvRkFBVTtJQUFJLElBQUksSUFBRSxvQkFBb0I7SUFBSyxPQUFPLE9BQU8sR0FBQztBQUFDLENBQUMiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTk0LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC1yZWZyZXNoL2Nqcy9yZWFjdC1yZWZyZXNoLXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtcmVmcmVzaC1ydW50aW1lLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxuLy8gQVRURU5USU9OXG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xuXG52YXIgUG9zc2libHlXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwOyAvLyBXZSBuZXZlciByZW1vdmUgdGhlc2UgYXNzb2NpYXRpb25zLlxuLy8gSXQncyBPSyB0byByZWZlcmVuY2UgZmFtaWxpZXMsIGJ1dCB1c2UgV2Vha01hcC9TZXQgZm9yIHR5cGVzLlxuXG52YXIgYWxsRmFtaWxpZXNCeUlEID0gbmV3IE1hcCgpO1xudmFyIGFsbEZhbWlsaWVzQnlUeXBlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xudmFyIGFsbFNpZ25hdHVyZXNCeVR5cGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7IC8vIFRoaXMgV2Vha01hcCBpcyByZWFkIGJ5IFJlYWN0LCBzbyB3ZSBvbmx5IHB1dCBmYW1pbGllc1xuLy8gdGhhdCBoYXZlIGFjdHVhbGx5IGJlZW4gZWRpdGVkIGhlcmUuIFRoaXMga2VlcHMgY2hlY2tzIGZhc3QuXG4vLyAkRmxvd0lzc3VlXG5cbnZhciB1cGRhdGVkRmFtaWxpZXNCeVR5cGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7IC8vIFRoaXMgaXMgY2xlYXJlZCBvbiBldmVyeSBwZXJmb3JtUmVhY3RSZWZyZXNoKCkgY2FsbC5cbi8vIEl0IGlzIGFuIGFycmF5IG9mIFtGYW1pbHksIE5leHRUeXBlXSB0dXBsZXMuXG5cbnZhciBwZW5kaW5nVXBkYXRlcyA9IFtdOyAvLyBUaGlzIGlzIGluamVjdGVkIGJ5IHRoZSByZW5kZXJlciB2aWEgRGV2VG9vbHMgZ2xvYmFsIGhvb2suXG5cbnZhciBoZWxwZXJzQnlSZW5kZXJlcklEID0gbmV3IE1hcCgpO1xudmFyIGhlbHBlcnNCeVJvb3QgPSBuZXcgTWFwKCk7IC8vIFdlIGtlZXAgdHJhY2sgb2YgbW91bnRlZCByb290cyBzbyB3ZSBjYW4gc2NoZWR1bGUgdXBkYXRlcy5cblxudmFyIG1vdW50ZWRSb290cyA9IG5ldyBTZXQoKTsgLy8gSWYgYSByb290IGNhcHR1cmVzIGFuIGVycm9yLCB3ZSByZW1lbWJlciBpdCBzbyB3ZSBjYW4gcmV0cnkgb24gZWRpdC5cblxudmFyIGZhaWxlZFJvb3RzID0gbmV3IFNldCgpOyAvLyBJbiBlbnZpcm9ubWVudHMgdGhhdCBzdXBwb3J0IFdlYWtNYXAsIHdlIGFsc28gcmVtZW1iZXIgdGhlIGxhc3QgZWxlbWVudCBmb3IgZXZlcnkgcm9vdC5cbi8vIEl0IG5lZWRzIHRvIGJlIHdlYWsgYmVjYXVzZSB3ZSBkbyB0aGlzIGV2ZW4gZm9yIHJvb3RzIHRoYXQgZmFpbGVkIHRvIG1vdW50LlxuLy8gSWYgdGhlcmUgaXMgbm8gV2Vha01hcCwgd2Ugd29uJ3QgYXR0ZW1wdCB0byBkbyByZXRyeWluZy5cbi8vICRGbG93SXNzdWVcblxudmFyIHJvb3RFbGVtZW50cyA9IC8vICRGbG93SXNzdWVcbnR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gbmV3IFdlYWtNYXAoKSA6IG51bGw7XG52YXIgaXNQZXJmb3JtaW5nUmVmcmVzaCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBjb21wdXRlRnVsbEtleShzaWduYXR1cmUpIHtcbiAgaWYgKHNpZ25hdHVyZS5mdWxsS2V5ICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHNpZ25hdHVyZS5mdWxsS2V5O1xuICB9XG5cbiAgdmFyIGZ1bGxLZXkgPSBzaWduYXR1cmUub3duS2V5O1xuICB2YXIgaG9va3M7XG5cbiAgdHJ5IHtcbiAgICBob29rcyA9IHNpZ25hdHVyZS5nZXRDdXN0b21Ib29rcygpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaW4gYW4gZWRnZSBjYXNlLCBlLmcuIGlmIGV4cHJlc3Npb24gbGlrZSBGb28udXNlU29tZXRoaW5nXG4gICAgLy8gZGVwZW5kcyBvbiBGb28gd2hpY2ggaXMgbGF6aWx5IGluaXRpYWxpemVkIGR1cmluZyByZW5kZXJpbmcuXG4gICAgLy8gSW4gdGhhdCBjYXNlIGp1c3QgYXNzdW1lIHdlJ2xsIGhhdmUgdG8gcmVtb3VudC5cbiAgICBzaWduYXR1cmUuZm9yY2VSZXNldCA9IHRydWU7XG4gICAgc2lnbmF0dXJlLmZ1bGxLZXkgPSBmdWxsS2V5O1xuICAgIHJldHVybiBmdWxsS2V5O1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBob29rID0gaG9va3NbaV07XG5cbiAgICBpZiAodHlwZW9mIGhvb2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIFNvbWV0aGluZydzIHdyb25nLiBBc3N1bWUgd2UgbmVlZCB0byByZW1vdW50LlxuICAgICAgc2lnbmF0dXJlLmZvcmNlUmVzZXQgPSB0cnVlO1xuICAgICAgc2lnbmF0dXJlLmZ1bGxLZXkgPSBmdWxsS2V5O1xuICAgICAgcmV0dXJuIGZ1bGxLZXk7XG4gICAgfVxuXG4gICAgdmFyIG5lc3RlZEhvb2tTaWduYXR1cmUgPSBhbGxTaWduYXR1cmVzQnlUeXBlLmdldChob29rKTtcblxuICAgIGlmIChuZXN0ZWRIb29rU2lnbmF0dXJlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIE5vIHNpZ25hdHVyZSBtZWFucyBIb29rIHdhc24ndCBpbiB0aGUgc291cmNlIGNvZGUsIGUuZy4gaW4gYSBsaWJyYXJ5LlxuICAgICAgLy8gV2UnbGwgc2tpcCBpdCBiZWNhdXNlIHdlIGNhbiBhc3N1bWUgaXQgd29uJ3QgY2hhbmdlIGR1cmluZyB0aGlzIHNlc3Npb24uXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgbmVzdGVkSG9va0tleSA9IGNvbXB1dGVGdWxsS2V5KG5lc3RlZEhvb2tTaWduYXR1cmUpO1xuXG4gICAgaWYgKG5lc3RlZEhvb2tTaWduYXR1cmUuZm9yY2VSZXNldCkge1xuICAgICAgc2lnbmF0dXJlLmZvcmNlUmVzZXQgPSB0cnVlO1xuICAgIH1cblxuICAgIGZ1bGxLZXkgKz0gJ1xcbi0tLVxcbicgKyBuZXN0ZWRIb29rS2V5O1xuICB9XG5cbiAgc2lnbmF0dXJlLmZ1bGxLZXkgPSBmdWxsS2V5O1xuICByZXR1cm4gZnVsbEtleTtcbn1cblxuZnVuY3Rpb24gaGF2ZUVxdWFsU2lnbmF0dXJlcyhwcmV2VHlwZSwgbmV4dFR5cGUpIHtcbiAgdmFyIHByZXZTaWduYXR1cmUgPSBhbGxTaWduYXR1cmVzQnlUeXBlLmdldChwcmV2VHlwZSk7XG4gIHZhciBuZXh0U2lnbmF0dXJlID0gYWxsU2lnbmF0dXJlc0J5VHlwZS5nZXQobmV4dFR5cGUpO1xuXG4gIGlmIChwcmV2U2lnbmF0dXJlID09PSB1bmRlZmluZWQgJiYgbmV4dFNpZ25hdHVyZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAocHJldlNpZ25hdHVyZSA9PT0gdW5kZWZpbmVkIHx8IG5leHRTaWduYXR1cmUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChjb21wdXRlRnVsbEtleShwcmV2U2lnbmF0dXJlKSAhPT0gY29tcHV0ZUZ1bGxLZXkobmV4dFNpZ25hdHVyZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAobmV4dFNpZ25hdHVyZS5mb3JjZVJlc2V0KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzUmVhY3RDbGFzcyh0eXBlKSB7XG4gIHJldHVybiB0eXBlLnByb3RvdHlwZSAmJiB0eXBlLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50O1xufVxuXG5mdW5jdGlvbiBjYW5QcmVzZXJ2ZVN0YXRlQmV0d2VlbihwcmV2VHlwZSwgbmV4dFR5cGUpIHtcbiAgaWYgKGlzUmVhY3RDbGFzcyhwcmV2VHlwZSkgfHwgaXNSZWFjdENsYXNzKG5leHRUeXBlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChoYXZlRXF1YWxTaWduYXR1cmVzKHByZXZUeXBlLCBuZXh0VHlwZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUZhbWlseSh0eXBlKSB7XG4gIC8vIE9ubHkgY2hlY2sgdXBkYXRlZCB0eXBlcyB0byBrZWVwIGxvb2t1cHMgZmFzdC5cbiAgcmV0dXJuIHVwZGF0ZWRGYW1pbGllc0J5VHlwZS5nZXQodHlwZSk7XG59IC8vIElmIHdlIGRpZG4ndCBjYXJlIGFib3V0IElFMTEsIHdlIGNvdWxkIHVzZSBuZXcgTWFwL1NldChpdGVyYWJsZSkuXG5cblxuZnVuY3Rpb24gY2xvbmVNYXAobWFwKSB7XG4gIHZhciBjbG9uZSA9IG5ldyBNYXAoKTtcbiAgbWFwLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICBjbG9uZS5zZXQoa2V5LCB2YWx1ZSk7XG4gIH0pO1xuICByZXR1cm4gY2xvbmU7XG59XG5cbmZ1bmN0aW9uIGNsb25lU2V0KHNldCkge1xuICB2YXIgY2xvbmUgPSBuZXcgU2V0KCk7XG4gIHNldC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGNsb25lLmFkZCh2YWx1ZSk7XG4gIH0pO1xuICByZXR1cm4gY2xvbmU7XG59IC8vIFRoaXMgaXMgYSBzYWZldHkgbWVjaGFuaXNtIHRvIHByb3RlY3QgYWdhaW5zdCByb2d1ZSBnZXR0ZXJzIGFuZCBQcm94aWVzLlxuXG5cbmZ1bmN0aW9uIGdldFByb3BlcnR5KG9iamVjdCwgcHJvcGVydHkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gb2JqZWN0W3Byb3BlcnR5XTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gSW50ZW50aW9uYWxseSBpZ25vcmUuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwZXJmb3JtUmVhY3RSZWZyZXNoKCkge1xuXG4gIGlmIChwZW5kaW5nVXBkYXRlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChpc1BlcmZvcm1pbmdSZWZyZXNoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpc1BlcmZvcm1pbmdSZWZyZXNoID0gdHJ1ZTtcblxuICB0cnkge1xuICAgIHZhciBzdGFsZUZhbWlsaWVzID0gbmV3IFNldCgpO1xuICAgIHZhciB1cGRhdGVkRmFtaWxpZXMgPSBuZXcgU2V0KCk7XG4gICAgdmFyIHVwZGF0ZXMgPSBwZW5kaW5nVXBkYXRlcztcbiAgICBwZW5kaW5nVXBkYXRlcyA9IFtdO1xuICAgIHVwZGF0ZXMuZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xuICAgICAgdmFyIGZhbWlseSA9IF9yZWZbMF0sXG4gICAgICAgICAgbmV4dFR5cGUgPSBfcmVmWzFdO1xuICAgICAgLy8gTm93IHRoYXQgd2UgZ290IGEgcmVhbCBlZGl0LCB3ZSBjYW4gY3JlYXRlIGFzc29jaWF0aW9uc1xuICAgICAgLy8gdGhhdCB3aWxsIGJlIHJlYWQgYnkgdGhlIFJlYWN0IHJlY29uY2lsZXIuXG4gICAgICB2YXIgcHJldlR5cGUgPSBmYW1pbHkuY3VycmVudDtcbiAgICAgIHVwZGF0ZWRGYW1pbGllc0J5VHlwZS5zZXQocHJldlR5cGUsIGZhbWlseSk7XG4gICAgICB1cGRhdGVkRmFtaWxpZXNCeVR5cGUuc2V0KG5leHRUeXBlLCBmYW1pbHkpO1xuICAgICAgZmFtaWx5LmN1cnJlbnQgPSBuZXh0VHlwZTsgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBzaG91bGQgYmUgYSByZS1yZW5kZXIgb3IgYSByZS1tb3VudC5cblxuICAgICAgaWYgKGNhblByZXNlcnZlU3RhdGVCZXR3ZWVuKHByZXZUeXBlLCBuZXh0VHlwZSkpIHtcbiAgICAgICAgdXBkYXRlZEZhbWlsaWVzLmFkZChmYW1pbHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhbGVGYW1pbGllcy5hZGQoZmFtaWx5KTtcbiAgICAgIH1cbiAgICB9KTsgLy8gVE9ETzogcmVuYW1lIHRoZXNlIGZpZWxkcyB0byBzb21ldGhpbmcgbW9yZSBtZWFuaW5nZnVsLlxuXG4gICAgdmFyIHVwZGF0ZSA9IHtcbiAgICAgIHVwZGF0ZWRGYW1pbGllczogdXBkYXRlZEZhbWlsaWVzLFxuICAgICAgLy8gRmFtaWxpZXMgdGhhdCB3aWxsIHJlLXJlbmRlciBwcmVzZXJ2aW5nIHN0YXRlXG4gICAgICBzdGFsZUZhbWlsaWVzOiBzdGFsZUZhbWlsaWVzIC8vIEZhbWlsaWVzIHRoYXQgd2lsbCBiZSByZW1vdW50ZWRcblxuICAgIH07XG4gICAgaGVscGVyc0J5UmVuZGVyZXJJRC5mb3JFYWNoKGZ1bmN0aW9uIChoZWxwZXJzKSB7XG4gICAgICAvLyBFdmVuIGlmIHRoZXJlIGFyZSBubyByb290cywgc2V0IHRoZSBoYW5kbGVyIG9uIGZpcnN0IHVwZGF0ZS5cbiAgICAgIC8vIFRoaXMgZW5zdXJlcyB0aGF0IGlmICpuZXcqIHJvb3RzIGFyZSBtb3VudGVkLCB0aGV5J2xsIHVzZSB0aGUgcmVzb2x2ZSBoYW5kbGVyLlxuICAgICAgaGVscGVycy5zZXRSZWZyZXNoSGFuZGxlcihyZXNvbHZlRmFtaWx5KTtcbiAgICB9KTtcbiAgICB2YXIgZGlkRXJyb3IgPSBmYWxzZTtcbiAgICB2YXIgZmlyc3RFcnJvciA9IG51bGw7IC8vIFdlIHNuYXBzaG90IG1hcHMgYW5kIHNldHMgdGhhdCBhcmUgbXV0YXRlZCBkdXJpbmcgY29tbWl0cy5cbiAgICAvLyBJZiB3ZSBkb24ndCBkbyB0aGlzLCB0aGVyZSBpcyBhIHJpc2sgdGhleSB3aWxsIGJlIG11dGF0ZWQgd2hpbGVcbiAgICAvLyB3ZSBpdGVyYXRlIG92ZXIgdGhlbS4gRm9yIGV4YW1wbGUsIHRyeWluZyB0byByZWNvdmVyIGEgZmFpbGVkIHJvb3RcbiAgICAvLyBtYXkgY2F1c2UgYW5vdGhlciByb290IHRvIGJlIGFkZGVkIHRvIHRoZSBmYWlsZWQgbGlzdCAtLSBhbiBpbmZpbml0ZSBsb29wLlxuXG4gICAgdmFyIGZhaWxlZFJvb3RzU25hcHNob3QgPSBjbG9uZVNldChmYWlsZWRSb290cyk7XG4gICAgdmFyIG1vdW50ZWRSb290c1NuYXBzaG90ID0gY2xvbmVTZXQobW91bnRlZFJvb3RzKTtcbiAgICB2YXIgaGVscGVyc0J5Um9vdFNuYXBzaG90ID0gY2xvbmVNYXAoaGVscGVyc0J5Um9vdCk7XG4gICAgZmFpbGVkUm9vdHNTbmFwc2hvdC5mb3JFYWNoKGZ1bmN0aW9uIChyb290KSB7XG4gICAgICB2YXIgaGVscGVycyA9IGhlbHBlcnNCeVJvb3RTbmFwc2hvdC5nZXQocm9vdCk7XG5cbiAgICAgIGlmIChoZWxwZXJzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCBoZWxwZXJzIGZvciBhIHJvb3QuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QgUmVmcmVzaC4nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFmYWlsZWRSb290cy5oYXMocm9vdCkpIHsvLyBObyBsb25nZXIgZmFpbGVkLlxuICAgICAgfVxuXG4gICAgICBpZiAocm9vdEVsZW1lbnRzID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFyb290RWxlbWVudHMuaGFzKHJvb3QpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsZW1lbnQgPSByb290RWxlbWVudHMuZ2V0KHJvb3QpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBoZWxwZXJzLnNjaGVkdWxlUm9vdChyb290LCBlbGVtZW50KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoIWRpZEVycm9yKSB7XG4gICAgICAgICAgZGlkRXJyb3IgPSB0cnVlO1xuICAgICAgICAgIGZpcnN0RXJyb3IgPSBlcnI7XG4gICAgICAgIH0gLy8gS2VlcCB0cnlpbmcgb3RoZXIgcm9vdHMuXG5cbiAgICAgIH1cbiAgICB9KTtcbiAgICBtb3VudGVkUm9vdHNTbmFwc2hvdC5mb3JFYWNoKGZ1bmN0aW9uIChyb290KSB7XG4gICAgICB2YXIgaGVscGVycyA9IGhlbHBlcnNCeVJvb3RTbmFwc2hvdC5nZXQocm9vdCk7XG5cbiAgICAgIGlmIChoZWxwZXJzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCBoZWxwZXJzIGZvciBhIHJvb3QuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QgUmVmcmVzaC4nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFtb3VudGVkUm9vdHMuaGFzKHJvb3QpKSB7Ly8gTm8gbG9uZ2VyIG1vdW50ZWQuXG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGhlbHBlcnMuc2NoZWR1bGVSZWZyZXNoKHJvb3QsIHVwZGF0ZSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKCFkaWRFcnJvcikge1xuICAgICAgICAgIGRpZEVycm9yID0gdHJ1ZTtcbiAgICAgICAgICBmaXJzdEVycm9yID0gZXJyO1xuICAgICAgICB9IC8vIEtlZXAgdHJ5aW5nIG90aGVyIHJvb3RzLlxuXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoZGlkRXJyb3IpIHtcbiAgICAgIHRocm93IGZpcnN0RXJyb3I7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVwZGF0ZTtcbiAgfSBmaW5hbGx5IHtcbiAgICBpc1BlcmZvcm1pbmdSZWZyZXNoID0gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyKHR5cGUsIGlkKSB7XG4gIHtcbiAgICBpZiAodHlwZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdHlwZSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFRoaXMgY2FuIGhhcHBlbiBpbiBhbiBlZGdlIGNhc2UsIGUuZy4gaWYgd2UgcmVnaXN0ZXJcbiAgICAvLyByZXR1cm4gdmFsdWUgb2YgYSBIT0MgYnV0IGl0IHJldHVybnMgYSBjYWNoZWQgY29tcG9uZW50LlxuICAgIC8vIElnbm9yZSBhbnl0aGluZyBidXQgdGhlIGZpcnN0IHJlZ2lzdHJhdGlvbiBmb3IgZWFjaCB0eXBlLlxuXG5cbiAgICBpZiAoYWxsRmFtaWxpZXNCeVR5cGUuaGFzKHR5cGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBDcmVhdGUgZmFtaWx5IG9yIHJlbWVtYmVyIHRvIHVwZGF0ZSBpdC5cbiAgICAvLyBOb25lIG9mIHRoaXMgYm9va2tlZXBpbmcgYWZmZWN0cyByZWNvbmNpbGlhdGlvblxuICAgIC8vIHVudGlsIHRoZSBmaXJzdCBwZXJmb3JtUmVhY3RSZWZyZXNoKCkgY2FsbCBhYm92ZS5cblxuXG4gICAgdmFyIGZhbWlseSA9IGFsbEZhbWlsaWVzQnlJRC5nZXQoaWQpO1xuXG4gICAgaWYgKGZhbWlseSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmYW1pbHkgPSB7XG4gICAgICAgIGN1cnJlbnQ6IHR5cGVcbiAgICAgIH07XG4gICAgICBhbGxGYW1pbGllc0J5SUQuc2V0KGlkLCBmYW1pbHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZW5kaW5nVXBkYXRlcy5wdXNoKFtmYW1pbHksIHR5cGVdKTtcbiAgICB9XG5cbiAgICBhbGxGYW1pbGllc0J5VHlwZS5zZXQodHlwZSwgZmFtaWx5KTsgLy8gVmlzaXQgaW5uZXIgdHlwZXMgYmVjYXVzZSB3ZSBtaWdodCBub3QgaGF2ZSByZWdpc3RlcmVkIHRoZW0uXG5cbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICAgIHN3aXRjaCAoZ2V0UHJvcGVydHkodHlwZSwgJyQkdHlwZW9mJykpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgIHJlZ2lzdGVyKHR5cGUucmVuZGVyLCBpZCArICckcmVuZGVyJyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgcmVnaXN0ZXIodHlwZS50eXBlLCBpZCArICckdHlwZScpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gc2V0U2lnbmF0dXJlKHR5cGUsIGtleSkge1xuICB2YXIgZm9yY2VSZXNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gIHZhciBnZXRDdXN0b21Ib29rcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzID8gYXJndW1lbnRzWzNdIDogdW5kZWZpbmVkO1xuXG4gIHtcbiAgICBpZiAoIWFsbFNpZ25hdHVyZXNCeVR5cGUuaGFzKHR5cGUpKSB7XG4gICAgICBhbGxTaWduYXR1cmVzQnlUeXBlLnNldCh0eXBlLCB7XG4gICAgICAgIGZvcmNlUmVzZXQ6IGZvcmNlUmVzZXQsXG4gICAgICAgIG93bktleToga2V5LFxuICAgICAgICBmdWxsS2V5OiBudWxsLFxuICAgICAgICBnZXRDdXN0b21Ib29rczogZ2V0Q3VzdG9tSG9va3MgfHwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSAvLyBWaXNpdCBpbm5lciB0eXBlcyBiZWNhdXNlIHdlIG1pZ2h0IG5vdCBoYXZlIHNpZ25lZCB0aGVtLlxuXG5cbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICAgIHN3aXRjaCAoZ2V0UHJvcGVydHkodHlwZSwgJyQkdHlwZW9mJykpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgIHNldFNpZ25hdHVyZSh0eXBlLnJlbmRlciwga2V5LCBmb3JjZVJlc2V0LCBnZXRDdXN0b21Ib29rcyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgc2V0U2lnbmF0dXJlKHR5cGUudHlwZSwga2V5LCBmb3JjZVJlc2V0LCBnZXRDdXN0b21Ib29rcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG59IC8vIFRoaXMgaXMgbGF6aWx5IGNhbGxlZCBkdXJpbmcgZmlyc3QgcmVuZGVyIGZvciBhIHR5cGUuXG4vLyBJdCBjYXB0dXJlcyBIb29rIGxpc3QgYXQgdGhhdCB0aW1lIHNvIGlubGluZSByZXF1aXJlcyBkb24ndCBicmVhayBjb21wYXJpc29ucy5cblxuZnVuY3Rpb24gY29sbGVjdEN1c3RvbUhvb2tzRm9yU2lnbmF0dXJlKHR5cGUpIHtcbiAge1xuICAgIHZhciBzaWduYXR1cmUgPSBhbGxTaWduYXR1cmVzQnlUeXBlLmdldCh0eXBlKTtcblxuICAgIGlmIChzaWduYXR1cmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29tcHV0ZUZ1bGxLZXkoc2lnbmF0dXJlKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEZhbWlseUJ5SUQoaWQpIHtcbiAge1xuICAgIHJldHVybiBhbGxGYW1pbGllc0J5SUQuZ2V0KGlkKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0RmFtaWx5QnlUeXBlKHR5cGUpIHtcbiAge1xuICAgIHJldHVybiBhbGxGYW1pbGllc0J5VHlwZS5nZXQodHlwZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGZpbmRBZmZlY3RlZEhvc3RJbnN0YW5jZXMoZmFtaWxpZXMpIHtcbiAge1xuICAgIHZhciBhZmZlY3RlZEluc3RhbmNlcyA9IG5ldyBTZXQoKTtcbiAgICBtb3VudGVkUm9vdHMuZm9yRWFjaChmdW5jdGlvbiAocm9vdCkge1xuICAgICAgdmFyIGhlbHBlcnMgPSBoZWxwZXJzQnlSb290LmdldChyb290KTtcblxuICAgICAgaWYgKGhlbHBlcnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIGhlbHBlcnMgZm9yIGEgcm9vdC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdCBSZWZyZXNoLicpO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW5zdGFuY2VzRm9yUm9vdCA9IGhlbHBlcnMuZmluZEhvc3RJbnN0YW5jZXNGb3JSZWZyZXNoKHJvb3QsIGZhbWlsaWVzKTtcbiAgICAgIGluc3RhbmNlc0ZvclJvb3QuZm9yRWFjaChmdW5jdGlvbiAoaW5zdCkge1xuICAgICAgICBhZmZlY3RlZEluc3RhbmNlcy5hZGQoaW5zdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gYWZmZWN0ZWRJbnN0YW5jZXM7XG4gIH1cbn1cbmZ1bmN0aW9uIGluamVjdEludG9HbG9iYWxIb29rKGdsb2JhbE9iamVjdCkge1xuICB7XG4gICAgLy8gRm9yIFJlYWN0IE5hdGl2ZSwgdGhlIGdsb2JhbCBob29rIHdpbGwgYmUgc2V0IHVwIGJ5IHJlcXVpcmUoJ3JlYWN0LWRldnRvb2xzLWNvcmUnKS5cbiAgICAvLyBUaGF0IGNvZGUgd2lsbCBydW4gYmVmb3JlIHVzLiBTbyB3ZSBuZWVkIHRvIG1vbmtleXBhdGNoIGZ1bmN0aW9ucyBvbiBleGlzdGluZyBob29rLlxuICAgIC8vIEZvciBSZWFjdCBXZWIsIHRoZSBnbG9iYWwgaG9vayB3aWxsIGJlIHNldCB1cCBieSB0aGUgZXh0ZW5zaW9uLlxuICAgIC8vIFRoaXMgd2lsbCBhbHNvIHJ1biBiZWZvcmUgdXMuXG4gICAgdmFyIGhvb2sgPSBnbG9iYWxPYmplY3QuX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fO1xuXG4gICAgaWYgKGhvb2sgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gSG93ZXZlciwgaWYgdGhlcmUgaXMgbm8gRGV2VG9vbHMgZXh0ZW5zaW9uLCB3ZSdsbCBuZWVkIHRvIHNldCB1cCB0aGUgZ2xvYmFsIGhvb2sgb3Vyc2VsdmVzLlxuICAgICAgLy8gTm90ZSB0aGF0IGluIHRoaXMgY2FzZSBpdCdzIGltcG9ydGFudCB0aGF0IHJlbmRlcmVyIGNvZGUgcnVucyAqYWZ0ZXIqIHRoaXMgbWV0aG9kIGNhbGwuXG4gICAgICAvLyBPdGhlcndpc2UsIHRoZSByZW5kZXJlciB3aWxsIHRoaW5rIHRoYXQgdGhlcmUgaXMgbm8gZ2xvYmFsIGhvb2ssIGFuZCB3b24ndCBkbyB0aGUgaW5qZWN0aW9uLlxuICAgICAgdmFyIG5leHRJRCA9IDA7XG4gICAgICBnbG9iYWxPYmplY3QuX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fID0gaG9vayA9IHtcbiAgICAgICAgcmVuZGVyZXJzOiBuZXcgTWFwKCksXG4gICAgICAgIHN1cHBvcnRzRmliZXI6IHRydWUsXG4gICAgICAgIGluamVjdDogZnVuY3Rpb24gKGluamVjdGVkKSB7XG4gICAgICAgICAgcmV0dXJuIG5leHRJRCsrO1xuICAgICAgICB9LFxuICAgICAgICBvblNjaGVkdWxlRmliZXJSb290OiBmdW5jdGlvbiAoaWQsIHJvb3QsIGNoaWxkcmVuKSB7fSxcbiAgICAgICAgb25Db21taXRGaWJlclJvb3Q6IGZ1bmN0aW9uIChpZCwgcm9vdCwgbWF5YmVQcmlvcml0eUxldmVsLCBkaWRFcnJvcikge30sXG4gICAgICAgIG9uQ29tbWl0RmliZXJVbm1vdW50OiBmdW5jdGlvbiAoKSB7fVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoaG9vay5pc0Rpc2FibGVkKSB7XG4gICAgICAvLyBUaGlzIGlzbid0IGEgcmVhbCBwcm9wZXJ0eSBvbiB0aGUgaG9vaywgYnV0IGl0IGNhbiBiZSBzZXQgdG8gb3B0IG91dFxuICAgICAgLy8gb2YgRGV2VG9vbHMgaW50ZWdyYXRpb24gYW5kIGFzc29jaWF0ZWQgd2FybmluZ3MgYW5kIGxvZ3MuXG4gICAgICAvLyBVc2luZyBjb25zb2xlWyd3YXJuJ10gdG8gZXZhZGUgQmFiZWwgYW5kIEVTTGludFxuICAgICAgY29uc29sZVsnd2FybiddKCdTb21ldGhpbmcgaGFzIHNoaW1tZWQgdGhlIFJlYWN0IERldlRvb2xzIGdsb2JhbCBob29rIChfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18pLiAnICsgJ0Zhc3QgUmVmcmVzaCBpcyBub3QgY29tcGF0aWJsZSB3aXRoIHRoaXMgc2hpbSBhbmQgd2lsbCBiZSBkaXNhYmxlZC4nKTtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEhlcmUsIHdlIGp1c3Qgd2FudCB0byBnZXQgYSByZWZlcmVuY2UgdG8gc2NoZWR1bGVSZWZyZXNoLlxuXG5cbiAgICB2YXIgb2xkSW5qZWN0ID0gaG9vay5pbmplY3Q7XG5cbiAgICBob29rLmluamVjdCA9IGZ1bmN0aW9uIChpbmplY3RlZCkge1xuICAgICAgdmFyIGlkID0gb2xkSW5qZWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgIGlmICh0eXBlb2YgaW5qZWN0ZWQuc2NoZWR1bGVSZWZyZXNoID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBpbmplY3RlZC5zZXRSZWZyZXNoSGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBUaGlzIHZlcnNpb24gc3VwcG9ydHMgUmVhY3QgUmVmcmVzaC5cbiAgICAgICAgaGVscGVyc0J5UmVuZGVyZXJJRC5zZXQoaWQsIGluamVjdGVkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGlkO1xuICAgIH07IC8vIERvIHRoZSBzYW1lIGZvciBhbnkgYWxyZWFkeSBpbmplY3RlZCByb290cy5cbiAgICAvLyBUaGlzIGlzIHVzZWZ1bCBpZiBSZWFjdERPTSBoYXMgYWxyZWFkeSBiZWVuIGluaXRpYWxpemVkLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTc2MjZcblxuXG4gICAgaG9vay5yZW5kZXJlcnMuZm9yRWFjaChmdW5jdGlvbiAoaW5qZWN0ZWQsIGlkKSB7XG4gICAgICBpZiAodHlwZW9mIGluamVjdGVkLnNjaGVkdWxlUmVmcmVzaCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgaW5qZWN0ZWQuc2V0UmVmcmVzaEhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVGhpcyB2ZXJzaW9uIHN1cHBvcnRzIFJlYWN0IFJlZnJlc2guXG4gICAgICAgIGhlbHBlcnNCeVJlbmRlcmVySUQuc2V0KGlkLCBpbmplY3RlZCk7XG4gICAgICB9XG4gICAgfSk7IC8vIFdlIGFsc28gd2FudCB0byB0cmFjayBjdXJyZW50bHkgbW91bnRlZCByb290cy5cblxuICAgIHZhciBvbGRPbkNvbW1pdEZpYmVyUm9vdCA9IGhvb2sub25Db21taXRGaWJlclJvb3Q7XG5cbiAgICB2YXIgb2xkT25TY2hlZHVsZUZpYmVyUm9vdCA9IGhvb2sub25TY2hlZHVsZUZpYmVyUm9vdCB8fCBmdW5jdGlvbiAoKSB7fTtcblxuICAgIGhvb2sub25TY2hlZHVsZUZpYmVyUm9vdCA9IGZ1bmN0aW9uIChpZCwgcm9vdCwgY2hpbGRyZW4pIHtcbiAgICAgIGlmICghaXNQZXJmb3JtaW5nUmVmcmVzaCkge1xuICAgICAgICAvLyBJZiBpdCB3YXMgaW50ZW50aW9uYWxseSBzY2hlZHVsZWQsIGRvbid0IGF0dGVtcHQgdG8gcmVzdG9yZS5cbiAgICAgICAgLy8gVGhpcyBpbmNsdWRlcyBpbnRlbnRpb25hbGx5IHNjaGVkdWxlZCB1bm1vdW50cy5cbiAgICAgICAgZmFpbGVkUm9vdHMuZGVsZXRlKHJvb3QpO1xuXG4gICAgICAgIGlmIChyb290RWxlbWVudHMgIT09IG51bGwpIHtcbiAgICAgICAgICByb290RWxlbWVudHMuc2V0KHJvb3QsIGNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2xkT25TY2hlZHVsZUZpYmVyUm9vdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBob29rLm9uQ29tbWl0RmliZXJSb290ID0gZnVuY3Rpb24gKGlkLCByb290LCBtYXliZVByaW9yaXR5TGV2ZWwsIGRpZEVycm9yKSB7XG4gICAgICB2YXIgaGVscGVycyA9IGhlbHBlcnNCeVJlbmRlcmVySUQuZ2V0KGlkKTtcblxuICAgICAgaWYgKGhlbHBlcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBoZWxwZXJzQnlSb290LnNldChyb290LCBoZWxwZXJzKTtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSByb290LmN1cnJlbnQ7XG4gICAgICAgIHZhciBhbHRlcm5hdGUgPSBjdXJyZW50LmFsdGVybmF0ZTsgLy8gV2UgbmVlZCB0byBkZXRlcm1pbmUgd2hldGhlciB0aGlzIHJvb3QgaGFzIGp1c3QgKHVuKW1vdW50ZWQuXG4gICAgICAgIC8vIFRoaXMgbG9naWMgaXMgY29weS1wYXN0ZWQgZnJvbSBzaW1pbGFyIGxvZ2ljIGluIHRoZSBEZXZUb29scyBiYWNrZW5kLlxuICAgICAgICAvLyBJZiB0aGlzIGJyZWFrcyB3aXRoIHNvbWUgcmVmYWN0b3JpbmcsIHlvdSdsbCB3YW50IHRvIHVwZGF0ZSBEZXZUb29scyB0b28uXG5cbiAgICAgICAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciB3YXNNb3VudGVkID0gYWx0ZXJuYXRlLm1lbW9pemVkU3RhdGUgIT0gbnVsbCAmJiBhbHRlcm5hdGUubWVtb2l6ZWRTdGF0ZS5lbGVtZW50ICE9IG51bGwgJiYgbW91bnRlZFJvb3RzLmhhcyhyb290KTtcbiAgICAgICAgICB2YXIgaXNNb3VudGVkID0gY3VycmVudC5tZW1vaXplZFN0YXRlICE9IG51bGwgJiYgY3VycmVudC5tZW1vaXplZFN0YXRlLmVsZW1lbnQgIT0gbnVsbDtcblxuICAgICAgICAgIGlmICghd2FzTW91bnRlZCAmJiBpc01vdW50ZWQpIHtcbiAgICAgICAgICAgIC8vIE1vdW50IGEgbmV3IHJvb3QuXG4gICAgICAgICAgICBtb3VudGVkUm9vdHMuYWRkKHJvb3QpO1xuICAgICAgICAgICAgZmFpbGVkUm9vdHMuZGVsZXRlKHJvb3QpO1xuICAgICAgICAgIH0gZWxzZSBpZiAod2FzTW91bnRlZCAmJiBpc01vdW50ZWQpIDsgZWxzZSBpZiAod2FzTW91bnRlZCAmJiAhaXNNb3VudGVkKSB7XG4gICAgICAgICAgICAvLyBVbm1vdW50IGFuIGV4aXN0aW5nIHJvb3QuXG4gICAgICAgICAgICBtb3VudGVkUm9vdHMuZGVsZXRlKHJvb3QpO1xuXG4gICAgICAgICAgICBpZiAoZGlkRXJyb3IpIHtcbiAgICAgICAgICAgICAgLy8gV2UnbGwgcmVtb3VudCBpdCBvbiBmdXR1cmUgZWRpdHMuXG4gICAgICAgICAgICAgIGZhaWxlZFJvb3RzLmFkZChyb290KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGhlbHBlcnNCeVJvb3QuZGVsZXRlKHJvb3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoIXdhc01vdW50ZWQgJiYgIWlzTW91bnRlZCkge1xuICAgICAgICAgICAgaWYgKGRpZEVycm9yKSB7XG4gICAgICAgICAgICAgIC8vIFdlJ2xsIHJlbW91bnQgaXQgb24gZnV0dXJlIGVkaXRzLlxuICAgICAgICAgICAgICBmYWlsZWRSb290cy5hZGQocm9vdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE1vdW50IGEgbmV3IHJvb3QuXG4gICAgICAgICAgbW91bnRlZFJvb3RzLmFkZChyb290KTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBBbHdheXMgY2FsbCB0aGUgZGVjb3JhdGVkIERldlRvb2xzIGhvb2suXG5cblxuICAgICAgcmV0dXJuIG9sZE9uQ29tbWl0RmliZXJSb290LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gaGFzVW5yZWNvdmVyYWJsZUVycm9ycygpIHtcbiAgLy8gVE9ETzogZGVsZXRlIHRoaXMgYWZ0ZXIgcmVtb3ZpbmcgZGVwZW5kZW5jeSBpbiBSTi5cbiAgcmV0dXJuIGZhbHNlO1xufSAvLyBFeHBvc2VkIGZvciB0ZXN0aW5nLlxuXG5mdW5jdGlvbiBfZ2V0TW91bnRlZFJvb3RDb3VudCgpIHtcbiAge1xuICAgIHJldHVybiBtb3VudGVkUm9vdHMuc2l6ZTtcbiAgfVxufSAvLyBUaGlzIGlzIGEgd3JhcHBlciBvdmVyIG1vcmUgcHJpbWl0aXZlIGZ1bmN0aW9ucyBmb3Igc2V0dGluZyBzaWduYXR1cmUuXG4vLyBTaWduYXR1cmVzIGxldCB1cyBkZWNpZGUgd2hldGhlciB0aGUgSG9vayBvcmRlciBoYXMgY2hhbmdlZCBvbiByZWZyZXNoLlxuLy9cbi8vIFRoaXMgZnVuY3Rpb24gaXMgaW50ZW5kZWQgdG8gYmUgdXNlZCBhcyBhIHRyYW5zZm9ybSB0YXJnZXQsIGUuZy46XG4vLyB2YXIgX3MgPSBjcmVhdGVTaWduYXR1cmVGdW5jdGlvbkZvclRyYW5zZm9ybSgpXG4vL1xuLy8gZnVuY3Rpb24gSGVsbG8oKSB7XG4vLyAgIGNvbnN0IFtmb28sIHNldEZvb10gPSB1c2VTdGF0ZSgwKTtcbi8vICAgY29uc3QgdmFsdWUgPSB1c2VDdXN0b21Ib29rKCk7XG4vLyAgIF9zKCk7IC8qIENhbGwgd2l0aG91dCBhcmd1bWVudHMgdHJpZ2dlcnMgY29sbGVjdGluZyB0aGUgY3VzdG9tIEhvb2sgbGlzdC5cbi8vICAgICAgICAgICogVGhpcyBkb2Vzbid0IGhhcHBlbiBkdXJpbmcgdGhlIG1vZHVsZSBldmFsdWF0aW9uIGJlY2F1c2Ugd2Vcbi8vICAgICAgICAgICogZG9uJ3Qgd2FudCB0byBjaGFuZ2UgdGhlIG1vZHVsZSBvcmRlciB3aXRoIGlubGluZSByZXF1aXJlcy5cbi8vICAgICAgICAgICogTmV4dCBjYWxscyBhcmUgbm9vcHMuICovXG4vLyAgIHJldHVybiA8aDE+SGk8L2gxPjtcbi8vIH1cbi8vXG4vLyAvKiBDYWxsIHdpdGggYXJndW1lbnRzIGF0dGFjaGVzIHRoZSBzaWduYXR1cmUgdG8gdGhlIHR5cGU6ICovXG4vLyBfcyhcbi8vICAgSGVsbG8sXG4vLyAgICd1c2VTdGF0ZXtbZm9vLCBzZXRGb29dfSgwKScsXG4vLyAgICgpID0+IFt1c2VDdXN0b21Ib29rXSwgLyogTGF6eSB0byBhdm9pZCB0cmlnZ2VyaW5nIGlubGluZSByZXF1aXJlcyAqL1xuLy8gKTtcblxuZnVuY3Rpb24gY3JlYXRlU2lnbmF0dXJlRnVuY3Rpb25Gb3JUcmFuc2Zvcm0oKSB7XG4gIHtcbiAgICB2YXIgc2F2ZWRUeXBlO1xuICAgIHZhciBoYXNDdXN0b21Ib29rcztcbiAgICB2YXIgZGlkQ29sbGVjdEhvb2tzID0gZmFsc2U7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0eXBlLCBrZXksIGZvcmNlUmVzZXQsIGdldEN1c3RvbUhvb2tzKSB7XG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gV2UncmUgaW4gdGhlIGluaXRpYWwgcGhhc2UgdGhhdCBhc3NvY2lhdGVzIHNpZ25hdHVyZXNcbiAgICAgICAgLy8gd2l0aCB0aGUgZnVuY3Rpb25zLiBOb3RlIHRoaXMgbWF5IGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lc1xuICAgICAgICAvLyBpbiBIT0MgY2hhaW5zIGxpa2UgX3MoaG9jMShfcyhob2MyKF9zKGFjdHVhbEZ1bmN0aW9uKSkpKSkuXG4gICAgICAgIGlmICghc2F2ZWRUeXBlKSB7XG4gICAgICAgICAgLy8gV2UncmUgaW4gdGhlIGlubmVybW9zdCBjYWxsLCBzbyB0aGlzIGlzIHRoZSBhY3R1YWwgdHlwZS5cbiAgICAgICAgICBzYXZlZFR5cGUgPSB0eXBlO1xuICAgICAgICAgIGhhc0N1c3RvbUhvb2tzID0gdHlwZW9mIGdldEN1c3RvbUhvb2tzID09PSAnZnVuY3Rpb24nO1xuICAgICAgICB9IC8vIFNldCB0aGUgc2lnbmF0dXJlIGZvciBhbGwgdHlwZXMgKGV2ZW4gd3JhcHBlcnMhKSBpbiBjYXNlXG4gICAgICAgIC8vIHRoZXkgaGF2ZSBubyBzaWduYXR1cmVzIG9mIHRoZWlyIG93bi4gVGhpcyBpcyB0byBwcmV2ZW50XG4gICAgICAgIC8vIHByb2JsZW1zIGxpa2UgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8yMDQxNy5cblxuXG4gICAgICAgIGlmICh0eXBlICE9IG51bGwgJiYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JykpIHtcbiAgICAgICAgICBzZXRTaWduYXR1cmUodHlwZSwga2V5LCBmb3JjZVJlc2V0LCBnZXRDdXN0b21Ib29rcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdlJ3JlIGluIHRoZSBfcygpIGNhbGwgd2l0aG91dCBhcmd1bWVudHMsIHdoaWNoIG1lYW5zXG4gICAgICAgIC8vIHRoaXMgaXMgdGhlIHRpbWUgdG8gY29sbGVjdCBjdXN0b20gSG9vayBzaWduYXR1cmVzLlxuICAgICAgICAvLyBPbmx5IGRvIHRoaXMgb25jZS4gVGhpcyBwYXRoIGlzIGhvdCBhbmQgcnVucyAqaW5zaWRlKiBldmVyeSByZW5kZXIhXG4gICAgICAgIGlmICghZGlkQ29sbGVjdEhvb2tzICYmIGhhc0N1c3RvbUhvb2tzKSB7XG4gICAgICAgICAgZGlkQ29sbGVjdEhvb2tzID0gdHJ1ZTtcbiAgICAgICAgICBjb2xsZWN0Q3VzdG9tSG9va3NGb3JTaWduYXR1cmUoc2F2ZWRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGlzTGlrZWx5Q29tcG9uZW50VHlwZSh0eXBlKSB7XG4gIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiB0eXBlKSB7XG4gICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBGaXJzdCwgZGVhbCB3aXRoIGNsYXNzZXMuXG4gICAgICAgICAgaWYgKHR5cGUucHJvdG90eXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KSB7XG4gICAgICAgICAgICAgIC8vIFJlYWN0IGNsYXNzLlxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG93bk5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModHlwZS5wcm90b3R5cGUpO1xuXG4gICAgICAgICAgICBpZiAob3duTmFtZXMubGVuZ3RoID4gMSB8fCBvd25OYW1lc1swXSAhPT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgICAgICAvLyBUaGlzIGxvb2tzIGxpa2UgYSBjbGFzcy5cbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG9cblxuXG4gICAgICAgICAgICBpZiAodHlwZS5wcm90b3R5cGUuX19wcm90b19fICE9PSBPYmplY3QucHJvdG90eXBlKSB7XG4gICAgICAgICAgICAgIC8vIEl0IGhhcyBhIHN1cGVyY2xhc3MuXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0gLy8gUGFzcyB0aHJvdWdoLlxuICAgICAgICAgICAgLy8gVGhpcyBsb29rcyBsaWtlIGEgcmVndWxhciBmdW5jdGlvbiB3aXRoIGVtcHR5IHByb3RvdHlwZS5cblxuICAgICAgICAgIH0gLy8gRm9yIHBsYWluIGZ1bmN0aW9ucyBhbmQgYXJyb3dzLCB1c2UgbmFtZSBhcyBhIGhldXJpc3RpYy5cblxuXG4gICAgICAgICAgdmFyIG5hbWUgPSB0eXBlLm5hbWUgfHwgdHlwZS5kaXNwbGF5TmFtZTtcbiAgICAgICAgICByZXR1cm4gdHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnICYmIC9eW0EtWl0vLnRlc3QobmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAge1xuICAgICAgICAgIGlmICh0eXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZ2V0UHJvcGVydHkodHlwZSwgJyQkdHlwZW9mJykpIHtcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgICAgICAvLyBEZWZpbml0ZWx5IFJlYWN0IGNvbXBvbmVudHMuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0cy5fZ2V0TW91bnRlZFJvb3RDb3VudCA9IF9nZXRNb3VudGVkUm9vdENvdW50O1xuZXhwb3J0cy5jb2xsZWN0Q3VzdG9tSG9va3NGb3JTaWduYXR1cmUgPSBjb2xsZWN0Q3VzdG9tSG9va3NGb3JTaWduYXR1cmU7XG5leHBvcnRzLmNyZWF0ZVNpZ25hdHVyZUZ1bmN0aW9uRm9yVHJhbnNmb3JtID0gY3JlYXRlU2lnbmF0dXJlRnVuY3Rpb25Gb3JUcmFuc2Zvcm07XG5leHBvcnRzLmZpbmRBZmZlY3RlZEhvc3RJbnN0YW5jZXMgPSBmaW5kQWZmZWN0ZWRIb3N0SW5zdGFuY2VzO1xuZXhwb3J0cy5nZXRGYW1pbHlCeUlEID0gZ2V0RmFtaWx5QnlJRDtcbmV4cG9ydHMuZ2V0RmFtaWx5QnlUeXBlID0gZ2V0RmFtaWx5QnlUeXBlO1xuZXhwb3J0cy5oYXNVbnJlY292ZXJhYmxlRXJyb3JzID0gaGFzVW5yZWNvdmVyYWJsZUVycm9ycztcbmV4cG9ydHMuaW5qZWN0SW50b0dsb2JhbEhvb2sgPSBpbmplY3RJbnRvR2xvYmFsSG9vaztcbmV4cG9ydHMuaXNMaWtlbHlDb21wb25lbnRUeXBlID0gaXNMaWtlbHlDb21wb25lbnRUeXBlO1xuZXhwb3J0cy5wZXJmb3JtUmVhY3RSZWZyZXNoID0gcGVyZm9ybVJlYWN0UmVmcmVzaDtcbmV4cG9ydHMucmVnaXN0ZXIgPSByZWdpc3RlcjtcbmV4cG9ydHMuc2V0U2lnbmF0dXJlID0gc2V0U2lnbmF0dXJlO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztDQVFDLEdBSUc7QUFGSjtBQUVBLHdDQUEyQztJQUN6QyxDQUFDO1FBQ0g7UUFFQSxZQUFZO1FBQ1osSUFBSSx5QkFBeUIsT0FBTyxHQUFHLENBQUM7UUFDeEMsSUFBSSxrQkFBa0IsT0FBTyxHQUFHLENBQUM7UUFFakMsSUFBSSxrQkFBa0IsT0FBTyxZQUFZLGFBQWEsVUFBVSxLQUFLLHNDQUFzQztRQUMzRyxnRUFBZ0U7UUFFaEUsSUFBSSxrQkFBa0IsSUFBSTtRQUMxQixJQUFJLG9CQUFvQixJQUFJO1FBQzVCLElBQUksc0JBQXNCLElBQUksbUJBQW1CLHlEQUF5RDtRQUMxRywrREFBK0Q7UUFDL0QsYUFBYTtRQUViLElBQUksd0JBQXdCLElBQUksbUJBQW1CLHVEQUF1RDtRQUMxRywrQ0FBK0M7UUFFL0MsSUFBSSxpQkFBaUIsRUFBRSxFQUFFLDZEQUE2RDtRQUV0RixJQUFJLHNCQUFzQixJQUFJO1FBQzlCLElBQUksZ0JBQWdCLElBQUksT0FBTyw2REFBNkQ7UUFFNUYsSUFBSSxlQUFlLElBQUksT0FBTyx1RUFBdUU7UUFFckcsSUFBSSxjQUFjLElBQUksT0FBTywwRkFBMEY7UUFDdkgsOEVBQThFO1FBQzlFLDJEQUEyRDtRQUMzRCxhQUFhO1FBRWIsSUFBSSxlQUNKLE9BQU8sWUFBWSxhQUFhLElBQUksWUFBWTtRQUNoRCxJQUFJLHNCQUFzQjtRQUUxQixTQUFTLGVBQWUsU0FBUztZQUMvQixJQUFJLFVBQVUsT0FBTyxLQUFL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UUFBUSxzQkFBc0IsR0FBRztRQUNqQyxRQUFRLG9CQUFvQixHQUFHO1FBQy9CLFFBQVEscUJBQXFCLEdBQUc7UUFDaEMsUUFBUSxtQkFBbUIsR0FBRztRQUM5QixRQUFRLFFBQVEsR0FBRztRQUNuQixRQUFRLFlBQVksR0FBRztJQUNyQixDQUFDO0FBQ0giLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNzQxLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC1yZWZyZXNoL3J1bnRpbWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LXJlZnJlc2gtcnVudGltZS5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1yZWZyZXNoLXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFFSTtBQUZKO0FBRUE7O0tBRU87SUFDTCxPQUFPLE9BQU87QUFDaEIiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNzU0LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsImZpbGUiOiJ0dXJib3BhY2s6Ly8vW3Byb2plY3RdL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvQG5leHQvcmVhY3QtcmVmcmVzaC11dGlscy9kaXN0L2ludGVybmFsL2hlbHBlcnMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9pbnRlcm5hbC9oZWxwZXJzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FzQkc7Ozs7Ozs7O0FBRUgsK0VBQStFO0FBQy9FLDJCQUEyQjtBQUMzQixFQUFFO0FBQ0YsOEhBQThIO0FBRTlILE1BQUEsWUFBQSxrREFBa0Q7QUFzQmxELFNBQVMsWUFBWSxDQUFDLEdBQVc7SUFDL0IsT0FBTyxBQUNMLEdBQUcsS0FBSyxZQUFZLElBQ3BCLEdBQUcsS0FBSyxTQUFTLElBQ2pCLEdBQUcsS0FBSyxTQUFTLElBQ2pCLHFFQUFxRTtJQUNyRSxHQUFHLEtBQUssUUFBUSxDQUNqQixDQUFBO0FBQ0gsQ0FBQztBQUVELFNBQVMsOEJBQThCLENBQ3JDLGFBQXNCLEVBQ3RCLFFBQWdCO0lBRWhCLFVBQUEsT0FBYyxDQUFDLFFBQVEsQ0FBQyxhQUFhLEVBQUUsUUFBUSxHQUFHLFlBQVksQ0FBQyxDQUFBO0lBQy9ELElBQUksYUFBYSxJQUFJLElBQUksSUFBSSxPQUFPLGFBQWEsS0FBSyxRQUFRLEVBQUUsQ0FBQztRQUMvRCx5Q0FBeUM7UUFDekMsK0NBQStDO1FBQy9DLE9BQU07SUFDUixDQUFDO0lBQ0QsSUFBSyxJQUFJLEdBQUcsSUFBSSxhQUFhLENBQUUsQ0FBQztRQUM5QixJQUFJLFlBQVksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDO1lBQ3RCLFNBQVE7UUFDVixDQUFDO1FBQ0QsSUFBSSxDQUFDO1lBQ0gsSUFBSSxXQUFXLEdBQUcsYUFBYSxDQUFDLEdBQUcsQ0FBQyxDQUFBO1FBQ3RDLENBQUMsQ0FBQyxPQUFBLElBQU0sQ0FBQztZQUVQLFNBQVE7UUFDVixDQUFDO1FBQ0QsSUFBSSxNQUFNLEdBQUcsUUFBUSxHQUFHLGFBQWEsR0FBRyxHQUFHLENBQUE7UUFDM0MsVUFBQSxPQUFjLENBQUMsUUFBUSxDQUFDLFdBQVcsRUFBRSxNQUFNLENBQUMsQ0FBQTtJQUM5QyxD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IiwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA5MjEsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6MywiZmlsZSI6InR1cmJvcGFjazovLy9bcHJvamVjdF0vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9AbmV4dC9yZWFjdC1yZWZyZXNoLXV0aWxzL2Rpc3QvcnVudGltZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3J1bnRpbWUudHMiXSwic291cmNlc0NvbnRlbnQiOltdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLE1BQUEsWUFBQSxrREFBa0Q7QUFDbEQsTUFBQSxZQUFBLCtDQUErQztBQVcvQyxvQ0FBb0M7QUFDcEMsVUFBQSxPQUFjLENBQUMsb0JBQW9CLENBQUMsSUFBSSxDQUFDLENBQUE7QUFFekMsMEJBQTBCO0FBQzFCLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxVQUFBLE9BQWMsQ0FBQTtBQUV0QyxzREFBc0Q7QUFDdEQsSUFBSSxDQUFDLGlDQUFpQyxHQUFHLFNBQVUsZUFBZTtJQUNoRSxJQUFJLGNBQWMsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFBO0lBQ3RDLElBQUksY0FBYyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUE7SUFFdEMsSUFBSSxDQUFDLFlBQVksR0FBRyxTQUFVLElBQUksRUFBRSxFQUFFO1FBQ3BDLFVBQUEsT0FBYyxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsZUFBZSxHQUFHLEdBQUcsR0FBRyxFQUFFLENBQUMsQ0FBQTtJQUMzRCxDQUFDLENBQUE7SUFDRCxJQUFJLENBQUMsWUFBWSxHQUFHLFVBQUEsT0FBYyxDQUFDLG1DQUFtQyxDQUFBO0lBRXRFLDZDQUE2QztJQUM3QyxrRkFBa0Y7SUFDbEYsT0FBTztRQUNMLElBQUksQ0FBQyxZQUFZLEdBQUcsY0FBYyxDQUFBO1FBQ2xDLElBQUksQ0FBQyxZQUFZLEdBQUcsY0FBYyxDQUFBO0lBQ3BDLENBQUMsQ0FBQTtBQUNILENBQUMsQ0FBQSIsImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogOTU2LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nKG1ldGhvZE5hbWUsIGluZm8pIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnQucHJvdG90eXBlLCBtZXRob2ROYW1lLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgIFwiJXMoLi4uKSBpcyBkZXByZWNhdGVkIGluIHBsYWluIEphdmFTY3JpcHQgUmVhY3QgY2xhc3Nlcy4gJXNcIixcbiAgICAgICAgICAgIGluZm9bMF0sXG4gICAgICAgICAgICBpbmZvWzFdXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICAgICAgaWYgKG51bGwgPT09IG1heWJlSXRlcmFibGUgfHwgXCJvYmplY3RcIiAhPT0gdHlwZW9mIG1heWJlSXRlcmFibGUpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgbWF5YmVJdGVyYWJsZSA9XG4gICAgICAgIChNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdKSB8fFxuICAgICAgICBtYXliZUl0ZXJhYmxlW1wiQEBpdGVyYXRvclwiXTtcbiAgICAgIHJldHVybiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBtYXliZUl0ZXJhYmxlID8gbWF5YmVJdGVyYWJsZSA6IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gICAgICBwdWJsaWNJbnN0YW5jZSA9XG4gICAgICAgICgocHVibGljSW5zdGFuY2UgPSBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3RvcikgJiZcbiAgICAgICAgICAocHVibGljSW5zdGFuY2UuZGlzcGxheU5hbWUgfHwgcHVibGljSW5zdGFuY2UubmFtZSkpIHx8XG4gICAgICAgIFwiUmVhY3RDbGFzc1wiO1xuICAgICAgdmFyIHdhcm5pbmdLZXkgPSBwdWJsaWNJbnN0YW5jZSArIFwiLlwiICsgY2FsbGVyTmFtZTtcbiAgICAgIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFt3YXJuaW5nS2V5XSB8fFxuICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkNhbid0IGNhbGwgJXMgb24gYSBjb21wb25lbnQgdGhhdCBpcyBub3QgeWV0IG1vdW50ZWQuIFRoaXMgaXMgYSBuby1vcCwgYnV0IGl0IG1pZ2h0IGluZGljYXRlIGEgYnVnIGluIHlvdXIgYXBwbGljYXRpb24uIEluc3RlYWQsIGFzc2lnbiB0byBgdGhpcy5zdGF0ZWAgZGlyZWN0bHkgb3IgZGVmaW5lIGEgYHN0YXRlID0ge307YCBjbGFzcyBwcm9wZXJ0eSB3aXRoIHRoZSBkZXNpcmVkIHN0YXRlIGluIHRoZSAlcyBjb21wb25lbnQuXCIsXG4gICAgICAgICAgY2FsbGVyTmFtZSxcbiAgICAgICAgICBwdWJsaWNJbnN0YW5jZVxuICAgICAgICApLFxuICAgICAgICAoZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W3dhcm5pbmdLZXldID0gITApKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gQ29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gICAgICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBDb21wb25lbnREdW1teSgpIHt9XG4gICAgZnVuY3Rpb24gUHVyZUNvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAgICAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbm9vcCgpIHt9XG4gICAgZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITE7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICEwO1xuICAgICAgfVxuICAgICAgaWYgKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCkge1xuICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSBjb25zb2xlO1xuICAgICAgICB2YXIgSlNDb21waWxlcl90ZW1wX2NvbnN0ID0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LmVycm9yO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwID1cbiAgICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgU3ltYm9sICYmXG4gICAgICAgICAgICBTeW1ib2wudG9TdHJpbmdUYWcgJiZcbiAgICAgICAgICAgIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10pIHx8XG4gICAgICAgICAgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fFxuICAgICAgICAgIFwiT2JqZWN0XCI7XG4gICAgICAgIEpTQ29tcGlsZXJfdGVtcF9jb25zdC5jYWxsKFxuICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCxcbiAgICAgICAgICBcIlRoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4gVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuXCIsXG4gICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkge1xuICAgICAgaWYgKG51bGwgPT0gdHlwZSkgcmV0dXJuIG51bGw7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgcmV0dXJuIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0VcbiAgICAgICAgICA/IG51bGxcbiAgICAgICAgICA6IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHR5cGUpIHJldHVybiB0eXBlO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJGcmFnbWVudFwiO1xuICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiUHJvZmlsZXJcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN0cmljdE1vZGVcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlTGlzdFwiO1xuICAgICAgICBjYXNlIFJFQUNUX0FDVElWSVRZX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiQWN0aXZpdHlcIjtcbiAgICAgIH1cbiAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgc3dpdGNoIChcbiAgICAgICAgICAoXCJudW1iZXJcIiA9PT0gdHlwZW9mIHR5cGUudGFnICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgdHlwZS4kJHR5cGVvZilcbiAgICAgICAgKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiBcIlBvcnRhbFwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgXCJDb250ZXh0XCI7XG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuICh0eXBlLl9jb250ZXh0LmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiKSArIFwiLkNvbnN1bWVyXCI7XG4gICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgdmFyIGlubmVyVHlwZSA9IHR5cGUucmVuZGVyO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuZGlzcGxheU5hbWU7XG4gICAgICAgICAgICB0eXBlIHx8XG4gICAgICAgICAgICAgICgodHlwZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCBcIlwiKSxcbiAgICAgICAgICAgICAgKHR5cGUgPSBcIlwiICE9PSB0eXBlID8gXCJGb3J3YXJkUmVmKFwiICsgdHlwZSArIFwiKVwiIDogXCJGb3J3YXJkUmVmXCIpKTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKGlubmVyVHlwZSA9IHR5cGUuZGlzcGxheU5hbWUgfHwgbnVsbCksXG4gICAgICAgICAgICAgIG51bGwgIT09IGlubmVyVHlwZVxuICAgICAgICAgICAgICAgID8gaW5uZXJUeXBlXG4gICAgICAgICAgICAgICAgOiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCBcIk1lbW9cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgIGlubmVyVHlwZSA9IHR5cGUuX3BheWxvYWQ7XG4gICAgICAgICAgICB0eXBlID0gdHlwZS5faW5pdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZShpbm5lclR5cGUpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRUYXNrTmFtZSh0eXBlKSB7XG4gICAgICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkgcmV0dXJuIFwiPD5cIjtcbiAgICAgIGlmIChcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUgJiZcbiAgICAgICAgbnVsbCAhPT0gdHlwZSAmJlxuICAgICAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEVcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIFwiPC4uLj5cIjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgICByZXR1cm4gbmFtZSA/IFwiPFwiICsgbmFtZSArIFwiPlwiIDogXCI8Li4uPlwiO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICByZXR1cm4gXCI8Li4uPlwiO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRPd25lcigpIHtcbiAgICAgIHZhciBkaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuQTtcbiAgICAgIHJldHVybiBudWxsID09PSBkaXNwYXRjaGVyID8gbnVsbCA6IGRpc3BhdGNoZXIuZ2V0T3duZXIoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVW5rbm93bk93bmVyKCkge1xuICAgICAgcmV0dXJuIEVycm9yKFwicmVhY3Qtc3RhY2stdG9wLWZyYW1lXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgXCJrZXlcIikpIHtcbiAgICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCBcImtleVwiKS5nZXQ7XG4gICAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwICE9PSBjb25maWcua2V5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgICAgIGZ1bmN0aW9uIHdhcm5BYm91dEFjY2Vzc2luZ0tleSgpIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gfHxcbiAgICAgICAgICAoKHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gITApLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgdmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCBwcm9wLiAoaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9zcGVjaWFsLXByb3BzKVwiLFxuICAgICAgICAgICAgZGlzcGxheU5hbWVcbiAgICAgICAgICApKTtcbiAgICAgIH1cbiAgICAgIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9ICEwO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCBcImtleVwiLCB7XG4gICAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZWxlbWVudFJlZkdldHRlcldpdGhEZXByZWNhdGlvbldhcm5pbmcoKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0aGlzLnR5cGUpO1xuICAgICAgZGlkV2FybkFib3V0RWxlbWVudFJlZltjb21wb25lbnROYW1lXSB8fFxuICAgICAgICAoKGRpZFdhcm5BYm91dEVsZW1lbnRSZWZbY29tcG9uZW50TmFtZV0gPSAhMCksXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJBY2Nlc3NpbmcgZWxlbWVudC5yZWYgd2FzIHJlbW92ZWQgaW4gUmVhY3QgMTkuIHJlZiBpcyBub3cgYSByZWd1bGFyIHByb3AuIEl0IHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBKU1ggRWxlbWVudCB0eXBlIGluIGEgZnV0dXJlIHJlbGVhc2UuXCJcbiAgICAgICAgKSk7XG4gICAgICBjb21wb25lbnROYW1lID0gdGhpcy5wcm9wcy5yZWY7XG4gICAgICByZXR1cm4gdm9pZCAwICE9PSBjb21wb25lbnROYW1lID8gY29tcG9uZW50TmFtZSA6IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWN0RWxlbWVudChcbiAgICAgIHR5cGUsXG4gICAgICBrZXksXG4gICAgICBzZWxmLFxuICAgICAgc291cmNlLFxuICAgICAgb3duZXIsXG4gICAgICBwcm9wcyxcbiAgICAgIGRlYnVnU3RhY2ssXG4gICAgICBkZWJ1Z1Rhc2tcbiAgICApIHtcbiAgICAgIHNlbGYgPSBwcm9wcy5yZWY7XG4gICAgICB0eXBlID0ge1xuICAgICAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICBfb3duZXI6IG93bmVyXG4gICAgICB9O1xuICAgICAgbnVsbCAhPT0gKHZvaWQgMCAhPT0gc2VsZiA/IHNlbGYgOiBudWxsKVxuICAgICAgICA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcInJlZlwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgICAgIGdldDogZWxlbWVudFJlZkdldHRlcldpdGhEZXByZWNhdGlvbldhcm5pbmdcbiAgICAgICAgICB9KVxuICAgICAgICA6IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcInJlZlwiLCB7IGVudW1lcmFibGU6ICExLCB2YWx1ZTogbnVsbCB9KTtcbiAgICAgIHR5cGUuX3N0b3JlID0ge307XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZS5fc3RvcmUsIFwidmFsaWRhdGVkXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IDBcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwiX2RlYnVnSW5mb1wiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiBudWxsXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcIl9kZWJ1Z1N0YWNrXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IGRlYnVnU3RhY2tcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwiX2RlYnVnVGFza1wiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiBkZWJ1Z1Rhc2tcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmZyZWV6ZSAmJiAoT2JqZWN0LmZyZWV6ZSh0eXBlLnByb3BzKSwgT2JqZWN0LmZyZWV6ZSh0eXBlKSk7XG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xvbmVBbmRSZXBsYWNlS2V5KG9sZEVsZW1lbnQsIG5ld0tleSkge1xuICAgICAgbmV3S2V5ID0gUmVhY3RFbGVtZW50KFxuICAgICAgICBvbGRFbGVtZW50LnR5cGUsXG4gICAgICAgIG5ld0tleSxcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIG9sZEVsZW1lbnQuX293bmVyLFxuICAgICAgICBvbGRFbGVtZW50LnByb3BzLFxuICAgICAgICBvbGRFbGVtZW50Ll9kZWJ1Z1N0YWNrLFxuICAgICAgICBvbGRFbGVtZW50Ll9kZWJ1Z1Rhc2tcbiAgICAgICk7XG4gICAgICBvbGRFbGVtZW50Ll9zdG9yZSAmJlxuICAgICAgICAobmV3S2V5Ll9zdG9yZS52YWxpZGF0ZWQgPSBvbGRFbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQpO1xuICAgICAgcmV0dXJuIG5ld0tleTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2Ygb2JqZWN0ICYmXG4gICAgICAgIG51bGwgIT09IG9iamVjdCAmJlxuICAgICAgICBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRVxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXNjYXBlKGtleSkge1xuICAgICAgdmFyIGVzY2FwZXJMb29rdXAgPSB7IFwiPVwiOiBcIj0wXCIsIFwiOlwiOiBcIj0yXCIgfTtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIFwiJFwiICtcbiAgICAgICAga2V5LnJlcGxhY2UoL1s9Ol0vZywgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgcmV0dXJuIGVzY2FwZXJMb29rdXBbbWF0Y2hdO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0RWxlbWVudEtleShlbGVtZW50LCBpbmRleCkge1xuICAgICAgcmV0dXJuIFwib2JqZWN0XCIgPT09IHR5cGVvZiBlbGVtZW50ICYmXG4gICAgICAgIG51bGwgIT09IGVsZW1lbnQgJiZcbiAgICAgICAgbnVsbCAhPSBlbGVtZW50LmtleVxuICAgICAgICA/IChjaGVja0tleVN0cmluZ0NvZXJjaW9uKGVsZW1lbnQua2V5KSwgZXNjYXBlKFwiXCIgKyBlbGVtZW50LmtleSkpXG4gICAgICAgIDogaW5kZXgudG9TdHJpbmcoMzYpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNvbHZlVGhlbmFibGUodGhlbmFibGUpIHtcbiAgICAgIHN3aXRjaCAodGhlbmFibGUuc3RhdHVzKSB7XG4gICAgICAgIGNhc2UgXCJmdWxmaWxsZWRcIjpcbiAgICAgICAgICByZXR1cm4gdGhlbmFibGUudmFsdWU7XG4gICAgICAgIGNhc2UgXCJyZWplY3RlZFwiOlxuICAgICAgICAgIHRocm93IHRoZW5hYmxlLnJlYXNvbjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBzd2l0Y2ggKFxuICAgICAgICAgICAgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0aGVuYWJsZS5zdGF0dXNcbiAgICAgICAgICAgICAgPyB0aGVuYWJsZS50aGVuKG5vb3AsIG5vb3ApXG4gICAgICAgICAgICAgIDogKCh0aGVuYWJsZS5zdGF0dXMgPSBcInBlbmRpbmdcIiksXG4gICAgICAgICAgICAgICAgdGhlbmFibGUudGhlbihcbiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChmdWxmaWxsZWRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBcInBlbmRpbmdcIiA9PT0gdGhlbmFibGUuc3RhdHVzICYmXG4gICAgICAgICAgICAgICAgICAgICAgKCh0aGVuYWJsZS5zdGF0dXMgPSBcImZ1bGZpbGxlZFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAodGhlbmFibGUudmFsdWUgPSBmdWxmaWxsZWRWYWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBcInBlbmRpbmdcIiA9PT0gdGhlbmFibGUuc3RhdHVzICYmXG4gICAgICAgICAgICAgICAgICAgICAgKCh0aGVuYWJsZS5zdGF0dXMgPSBcInJlamVjdGVkXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICh0aGVuYWJsZS5yZWFzb24gPSBlcnJvcikpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgdGhlbmFibGUuc3RhdHVzKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgY2FzZSBcImZ1bGZpbGxlZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gdGhlbmFibGUudmFsdWU7XG4gICAgICAgICAgICBjYXNlIFwicmVqZWN0ZWRcIjpcbiAgICAgICAgICAgICAgdGhyb3cgdGhlbmFibGUucmVhc29uO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRocm93IHRoZW5hYmxlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXBJbnRvQXJyYXkoY2hpbGRyZW4sIGFycmF5LCBlc2NhcGVkUHJlZml4LCBuYW1lU29GYXIsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiBjaGlsZHJlbjtcbiAgICAgIGlmIChcInVuZGVmaW5lZFwiID09PSB0eXBlIHx8IFwiYm9vbGVhblwiID09PSB0eXBlKSBjaGlsZHJlbiA9IG51bGw7XG4gICAgICB2YXIgaW52b2tlQ2FsbGJhY2sgPSAhMTtcbiAgICAgIGlmIChudWxsID09PSBjaGlsZHJlbikgaW52b2tlQ2FsbGJhY2sgPSAhMDtcbiAgICAgIGVsc2VcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBcImJpZ2ludFwiOlxuICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICBpbnZva2VDYWxsYmFjayA9ICEwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgc3dpdGNoIChjaGlsZHJlbi4kJHR5cGVvZikge1xuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgICAgICBpbnZva2VDYWxsYmFjayA9ICEwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgKGludm9rZUNhbGxiYWNrID0gY2hpbGRyZW4uX2luaXQpLFxuICAgICAgICAgICAgICAgICAgbWFwSW50b0FycmF5KFxuICAgICAgICAgICAgICAgICAgICBpbnZva2VDYWxsYmFjayhjaGlsZHJlbi5fcGF5bG9hZCksXG4gICAgICAgICAgICAgICAgICAgIGFycmF5LFxuICAgICAgICAgICAgICAgICAgICBlc2NhcGVkUHJlZml4LFxuICAgICAgICAgICAgICAgICAgICBuYW1lU29GYXIsXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgaWYgKGludm9rZUNhbGxiYWNrKSB7XG4gICAgICAgIGludm9rZUNhbGxiYWNrID0gY2hpbGRyZW47XG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2soaW52b2tlQ2FsbGJhY2spO1xuICAgICAgICB2YXIgY2hpbGRLZXkgPVxuICAgICAgICAgIFwiXCIgPT09IG5hbWVTb0ZhciA/IFwiLlwiICsgZ2V0RWxlbWVudEtleShpbnZva2VDYWxsYmFjaywgMCkgOiBuYW1lU29GYXI7XG4gICAgICAgIGlzQXJyYXlJbXBsKGNhbGxiYWNrKVxuICAgICAgICAgID8gKChlc2NhcGVkUHJlZml4ID0gXCJcIiksXG4gICAgICAgICAgICBudWxsICE9IGNoaWxkS2V5ICYmXG4gICAgICAgICAgICAgIChlc2NhcGVkUHJlZml4ID1cbiAgICAgICAgICAgICAgICBjaGlsZEtleS5yZXBsYWNlKHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4LCBcIiQmL1wiKSArIFwiL1wiKSxcbiAgICAgICAgICAgIG1hcEludG9BcnJheShjYWxsYmFjaywgYXJyYXksIGVzY2FwZWRQcmVmaXgsIFwiXCIsIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgOiBudWxsICE9IGNhbGxiYWNrICYmXG4gICAgICAgICAgICAoaXNWYWxpZEVsZW1lbnQoY2FsbGJhY2spICYmXG4gICAgICAgICAgICAgIChudWxsICE9IGNhbGxiYWNrLmtleSAmJlxuICAgICAgICAgICAgICAgICgoaW52b2tlQ2FsbGJhY2sgJiYgaW52b2tlQ2FsbGJhY2sua2V5ID09PSBjYWxsYmFjay5rZXkpIHx8XG4gICAgICAgICAgICAgICAgICBjaGVja0tleVN0cmluZ0NvZXJjaW9uKGNhbGxiYWNrLmtleSkpLFxuICAgICAgICAgICAgICAoZXNjYXBlZFByZWZpeCA9IGNsb25lQW5kUmVwbGFjZUtleShcbiAgICAgICAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICAgICAgICBlc2NhcGVkUHJlZml4ICtcbiAgICAgICAgICAgICAgICAgIChudWxsID09IGNhbGxiYWNrLmtleSB8fFxuICAgICAgICAgICAgICAgICAgKGludm9rZUNhbGxiYWNrICYmIGludm9rZUNhbGxiYWNrLmtleSA9PT0gY2FsbGJhY2sua2V5KVxuICAgICAgICAgICAgICAgICAgICA/IFwiXCJcbiAgICAgICAgICAgICAgICAgICAgOiAoXCJcIiArIGNhbGxiYWNrLmtleSkucmVwbGFjZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4LFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIkJi9cIlxuICAgICAgICAgICAgICAgICAgICAgICkgKyBcIi9cIikgK1xuICAgICAgICAgICAgICAgICAgY2hpbGRLZXlcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIFwiXCIgIT09IG5hbWVTb0ZhciAmJlxuICAgICAgICAgICAgICAgIG51bGwgIT0gaW52b2tlQ2FsbGJhY2sgJiZcbiAgICAgICAgICAgICAgICBpc1ZhbGlkRWxlbWVudChpbnZva2VDYWxsYmFjaykgJiZcbiAgICAgICAgICAgICAgICBudWxsID09IGludm9rZUNhbGxiYWNrLmtleSAmJlxuICAgICAgICAgICAgICAgIGludm9rZUNhbGxiYWNrLl9zdG9yZSAmJlxuICAgICAgICAgICAgICAgICFpbnZva2VDYWxsYmFjay5fc3RvcmUudmFsaWRhdGVkICYmXG4gICAgICAgICAgICAgICAgKGVzY2FwZWRQcmVmaXguX3N0b3JlLnZhbGlkYXRlZCA9IDIpLFxuICAgICAgICAgICAgICAoY2FsbGJhY2sgPSBlc2NhcGVkUHJlZml4KSksXG4gICAgICAgICAgICBhcnJheS5wdXNoKGNhbGxiYWNrKSk7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgICAgaW52b2tlQ2FsbGJhY2sgPSAwO1xuICAgICAgY2hpbGRLZXkgPSBcIlwiID09PSBuYW1lU29GYXIgPyBcIi5cIiA6IG5hbWVTb0ZhciArIFwiOlwiO1xuICAgICAgaWYgKGlzQXJyYXlJbXBsKGNoaWxkcmVuKSlcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKylcbiAgICAgICAgICAobmFtZVNvRmFyID0gY2hpbGRyZW5baV0pLFxuICAgICAgICAgICAgKHR5cGUgPSBjaGlsZEtleSArIGdldEVsZW1lbnRLZXkobmFtZVNvRmFyLCBpKSksXG4gICAgICAgICAgICAoaW52b2tlQ2FsbGJhY2sgKz0gbWFwSW50b0FycmF5KFxuICAgICAgICAgICAgICBuYW1lU29GYXIsXG4gICAgICAgICAgICAgIGFycmF5LFxuICAgICAgICAgICAgICBlc2NhcGVkUHJlZml4LFxuICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICBjYWxsYmFja1xuICAgICAgICAgICAgKSk7XG4gICAgICBlbHNlIGlmICgoKGkgPSBnZXRJdGVyYXRvckZuKGNoaWxkcmVuKSksIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGkpKVxuICAgICAgICBmb3IgKFxuICAgICAgICAgIGkgPT09IGNoaWxkcmVuLmVudHJpZXMgJiZcbiAgICAgICAgICAgIChkaWRXYXJuQWJvdXRNYXBzIHx8XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICBcIlVzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgbm90IHN1cHBvcnRlZC4gVXNlIGFuIGFycmF5IG9mIGtleWVkIFJlYWN0RWxlbWVudHMgaW5zdGVhZC5cIlxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKGRpZFdhcm5BYm91dE1hcHMgPSAhMCkpLFxuICAgICAgICAgICAgY2hpbGRyZW4gPSBpLmNhbGwoY2hpbGRyZW4pLFxuICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgIShuYW1lU29GYXIgPSBjaGlsZHJlbi5uZXh0KCkpLmRvbmU7XG5cbiAgICAgICAgKVxuICAgICAgICAgIChuYW1lU29GYXIgPSBuYW1lU29GYXIudmFsdWUpLFxuICAgICAgICAgICAgKHR5cGUgPSBjaGlsZEtleSArIGdldEVsZW1lbnRLZXkobmFtZVNvRmFyLCBpKyspKSxcbiAgICAgICAgICAgIChpbnZva2VDYWxsYmFjayArPSBtYXBJbnRvQXJyYXkoXG4gICAgICAgICAgICAgIG5hbWVTb0ZhcixcbiAgICAgICAgICAgICAgYXJyYXksXG4gICAgICAgICAgICAgIGVzY2FwZWRQcmVmaXgsXG4gICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgICAgICApKTtcbiAgICAgIGVsc2UgaWYgKFwib2JqZWN0XCIgPT09IHR5cGUpIHtcbiAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNoaWxkcmVuLnRoZW4pXG4gICAgICAgICAgcmV0dXJuIG1hcEludG9BcnJheShcbiAgICAgICAgICAgIHJlc29sdmVUaGVuYWJsZShjaGlsZHJlbiksXG4gICAgICAgICAgICBhcnJheSxcbiAgICAgICAgICAgIGVzY2FwZWRQcmVmaXgsXG4gICAgICAgICAgICBuYW1lU29GYXIsXG4gICAgICAgICAgICBjYWxsYmFja1xuICAgICAgICAgICk7XG4gICAgICAgIGFycmF5ID0gU3RyaW5nKGNoaWxkcmVuKTtcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6IFwiICtcbiAgICAgICAgICAgIChcIltvYmplY3QgT2JqZWN0XVwiID09PSBhcnJheVxuICAgICAgICAgICAgICA/IFwib2JqZWN0IHdpdGgga2V5cyB7XCIgKyBPYmplY3Qua2V5cyhjaGlsZHJlbikuam9pbihcIiwgXCIpICsgXCJ9XCJcbiAgICAgICAgICAgICAgOiBhcnJheSkgK1xuICAgICAgICAgICAgXCIpLiBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5IGluc3RlYWQuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnZva2VDYWxsYmFjaztcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmMsIGNvbnRleHQpIHtcbiAgICAgIGlmIChudWxsID09IGNoaWxkcmVuKSByZXR1cm4gY2hpbGRyZW47XG4gICAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgIGNvdW50ID0gMDtcbiAgICAgIG1hcEludG9BcnJheShjaGlsZHJlbiwgcmVzdWx0LCBcIlwiLCBcIlwiLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCBjaGlsZCwgY291bnQrKyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxhenlJbml0aWFsaXplcihwYXlsb2FkKSB7XG4gICAgICBpZiAoLTEgPT09IHBheWxvYWQuX3N0YXR1cykge1xuICAgICAgICB2YXIgY3RvciA9IHBheWxvYWQuX3Jlc3VsdDtcbiAgICAgICAgY3RvciA9IGN0b3IoKTtcbiAgICAgICAgY3Rvci50aGVuKFxuICAgICAgICAgIGZ1bmN0aW9uIChtb2R1bGVPYmplY3QpIHtcbiAgICAgICAgICAgIGlmICgwID09PSBwYXlsb2FkLl9zdGF0dXMgfHwgLTEgPT09IHBheWxvYWQuX3N0YXR1cylcbiAgICAgICAgICAgICAgKHBheWxvYWQuX3N0YXR1cyA9IDEpLCAocGF5bG9hZC5fcmVzdWx0ID0gbW9kdWxlT2JqZWN0KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKDAgPT09IHBheWxvYWQuX3N0YXR1cyB8fCAtMSA9PT0gcGF5bG9hZC5fc3RhdHVzKVxuICAgICAgICAgICAgICAocGF5bG9hZC5fc3RhdHVzID0gMiksIChwYXlsb2FkLl9yZXN1bHQgPSBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgICAtMSA9PT0gcGF5bG9hZC5fc3RhdHVzICYmXG4gICAgICAgICAgKChwYXlsb2FkLl9zdGF0dXMgPSAwKSwgKHBheWxvYWQuX3Jlc3VsdCA9IGN0b3IpKTtcbiAgICAgIH1cbiAgICAgIGlmICgxID09PSBwYXlsb2FkLl9zdGF0dXMpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgKGN0b3IgPSBwYXlsb2FkLl9yZXN1bHQpLFxuICAgICAgICAgIHZvaWQgMCA9PT0gY3RvciAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJsYXp5OiBFeHBlY3RlZCB0aGUgcmVzdWx0IG9mIGEgZHluYW1pYyBpbXBvcnQoKSBjYWxsLiBJbnN0ZWFkIHJlY2VpdmVkOiAlc1xcblxcbllvdXIgY29kZSBzaG91bGQgbG9vayBsaWtlOiBcXG4gIGNvbnN0IE15Q29tcG9uZW50ID0gbGF6eSgoKSA9PiBpbXBvcnQoJy4vTXlDb21wb25lbnQnKSlcXG5cXG5EaWQgeW91IGFjY2lkZW50YWxseSBwdXQgY3VybHkgYnJhY2VzIGFyb3VuZCB0aGUgaW1wb3J0P1wiLFxuICAgICAgICAgICAgICBjdG9yXG4gICAgICAgICAgICApLFxuICAgICAgICAgIFwiZGVmYXVsdFwiIGluIGN0b3IgfHxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwibGF6eTogRXhwZWN0ZWQgdGhlIHJlc3VsdCBvZiBhIGR5bmFtaWMgaW1wb3J0KCkgY2FsbC4gSW5zdGVhZCByZWNlaXZlZDogJXNcXG5cXG5Zb3VyIGNvZGUgc2hvdWxkIGxvb2sgbGlrZTogXFxuICBjb25zdCBNeUNvbXBvbmVudCA9IGxhenkoKCkgPT4gaW1wb3J0KCcuL015Q29tcG9uZW50JykpXCIsXG4gICAgICAgICAgICAgIGN0b3JcbiAgICAgICAgICAgICksXG4gICAgICAgICAgY3Rvci5kZWZhdWx0XG4gICAgICAgICk7XG4gICAgICB0aHJvdyBwYXlsb2FkLl9yZXN1bHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc29sdmVEaXNwYXRjaGVyKCkge1xuICAgICAgdmFyIGRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgbnVsbCA9PT0gZGlzcGF0Y2hlciAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiSW52YWxpZCBob29rIGNhbGwuIEhvb2tzIGNhbiBvbmx5IGJlIGNhbGxlZCBpbnNpZGUgb2YgdGhlIGJvZHkgb2YgYSBmdW5jdGlvbiBjb21wb25lbnQuIFRoaXMgY291bGQgaGFwcGVuIGZvciBvbmUgb2YgdGhlIGZvbGxvd2luZyByZWFzb25zOlxcbjEuIFlvdSBtaWdodCBoYXZlIG1pc21hdGNoaW5nIHZlcnNpb25zIG9mIFJlYWN0IGFuZCB0aGUgcmVuZGVyZXIgKHN1Y2ggYXMgUmVhY3QgRE9NKVxcbjIuIFlvdSBtaWdodCBiZSBicmVha2luZyB0aGUgUnVsZXMgb2YgSG9va3NcXG4zLiBZb3UgbWlnaHQgaGF2ZSBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QgaW4gdGhlIHNhbWUgYXBwXFxuU2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvaW52YWxpZC1ob29rLWNhbGwgZm9yIHRpcHMgYWJvdXQgaG93IHRvIGRlYnVnIGFuZCBmaXggdGhpcyBwcm9ibGVtLlwiXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gZGlzcGF0Y2hlcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVsZWFzZUFzeW5jVHJhbnNpdGlvbigpIHtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFzeW5jVHJhbnNpdGlvbnMtLTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5xdWV1ZVRhc2sodGFzaykge1xuICAgICAgaWYgKG51bGwgPT09IGVucXVldWVUYXNrSW1wbClcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgcmVxdWlyZVN0cmluZyA9IChcInJlcXVpcmVcIiArIE1hdGgucmFuZG9tKCkpLnNsaWNlKDAsIDcpO1xuICAgICAgICAgIGVucXVldWVUYXNrSW1wbCA9IChtb2R1bGUgJiYgbW9kdWxlW3JlcXVpcmVTdHJpbmddKS5jYWxsKFxuICAgICAgICAgICAgbW9kdWxlLFxuICAgICAgICAgICAgXCJ0aW1lcnNcIlxuICAgICAgICAgICkuc2V0SW1tZWRpYXRlO1xuICAgICAgICB9IGNhdGNoIChfZXJyKSB7XG4gICAgICAgICAgZW5xdWV1ZVRhc2tJbXBsID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAhMSA9PT0gZGlkV2FybkFib3V0TWVzc2FnZUNoYW5uZWwgJiZcbiAgICAgICAgICAgICAgKChkaWRXYXJuQWJvdXRNZXNzYWdlQ2hhbm5lbCA9ICEwKSxcbiAgICAgICAgICAgICAgXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIE1lc3NhZ2VDaGFubmVsICYmXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiVGhpcyBicm93c2VyIGRvZXMgbm90IGhhdmUgYSBNZXNzYWdlQ2hhbm5lbCBpbXBsZW1lbnRhdGlvbiwgc28gZW5xdWV1aW5nIHRhc2tzIHZpYSBhd2FpdCBhY3QoYXN5bmMgKCkgPT4gLi4uKSB3aWxsIGZhaWwuIFBsZWFzZSBmaWxlIGFuIGlzc3VlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMgaWYgeW91IGVuY291bnRlciB0aGlzIHdhcm5pbmcuXCJcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZSh2b2lkIDApO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBlbnF1ZXVlVGFza0ltcGwodGFzayk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFnZ3JlZ2F0ZUVycm9ycyhlcnJvcnMpIHtcbiAgICAgIHJldHVybiAxIDwgZXJyb3JzLmxlbmd0aCAmJiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBBZ2dyZWdhdGVFcnJvclxuICAgICAgICA/IG5ldyBBZ2dyZWdhdGVFcnJvcihlcnJvcnMpXG4gICAgICAgIDogZXJyb3JzWzBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb3BBY3RTY29wZShwcmV2QWN0UXVldWUsIHByZXZBY3RTY29wZURlcHRoKSB7XG4gICAgICBwcmV2QWN0U2NvcGVEZXB0aCAhPT0gYWN0U2NvcGVEZXB0aCAtIDEgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIllvdSBzZWVtIHRvIGhhdmUgb3ZlcmxhcHBpbmcgYWN0KCkgY2FsbHMsIHRoaXMgaXMgbm90IHN1cHBvcnRlZC4gQmUgc3VyZSB0byBhd2FpdCBwcmV2aW91cyBhY3QoKSBjYWxscyBiZWZvcmUgbWFraW5nIGEgbmV3IG9uZS4gXCJcbiAgICAgICAgKTtcbiAgICAgIGFjdFNjb3BlRGVwdGggPSBwcmV2QWN0U2NvcGVEZXB0aDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVjdXJzaXZlbHlGbHVzaEFzeW5jQWN0V29yayhyZXR1cm5WYWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcXVldWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZTtcbiAgICAgIGlmIChudWxsICE9PSBxdWV1ZSlcbiAgICAgICAgaWYgKDAgIT09IHF1ZXVlLmxlbmd0aClcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZmx1c2hBY3RRdWV1ZShxdWV1ZSk7XG4gICAgICAgICAgICBlbnF1ZXVlVGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZWN1cnNpdmVseUZsdXNoQXN5bmNBY3RXb3JrKHJldHVyblZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIGVsc2UgUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWUgPSBudWxsO1xuICAgICAgMCA8IFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9ycy5sZW5ndGhcbiAgICAgICAgPyAoKHF1ZXVlID0gYWdncmVnYXRlRXJyb3JzKFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9ycykpLFxuICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy50aHJvd25FcnJvcnMubGVuZ3RoID0gMCksXG4gICAgICAgICAgcmVqZWN0KHF1ZXVlKSlcbiAgICAgICAgOiByZXNvbHZlKHJldHVyblZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmx1c2hBY3RRdWV1ZShxdWV1ZSkge1xuICAgICAgaWYgKCFpc0ZsdXNoaW5nKSB7XG4gICAgICAgIGlzRmx1c2hpbmcgPSAhMDtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IHF1ZXVlW2ldO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5kaWRVc2VQcm9taXNlID0gITE7XG4gICAgICAgICAgICAgIHZhciBjb250aW51YXRpb24gPSBjYWxsYmFjayghMSk7XG4gICAgICAgICAgICAgIGlmIChudWxsICE9PSBjb250aW51YXRpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuZGlkVXNlUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgcXVldWVbaV0gPSBjYWxsYmFjaztcbiAgICAgICAgICAgICAgICAgIHF1ZXVlLnNwbGljZSgwLCBpKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBjb250aW51YXRpb247XG4gICAgICAgICAgICAgIH0gZWxzZSBicmVhaztcbiAgICAgICAgICAgIH0gd2hpbGUgKDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBxdWV1ZS5sZW5ndGggPSAwO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHF1ZXVlLnNwbGljZSgwLCBpICsgMSksIFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpc0ZsdXNoaW5nID0gITE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAmJlxuICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydCAmJlxuICAgICAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydChFcnJvcigpKTtcbiAgICB2YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnRyYW5zaXRpb25hbC5lbGVtZW50XCIpLFxuICAgICAgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpLFxuICAgICAgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSxcbiAgICAgIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIiksXG4gICAgICBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpLFxuICAgICAgUkVBQ1RfQ09OU1VNRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb25zdW1lclwiKSxcbiAgICAgIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpLFxuICAgICAgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKSxcbiAgICAgIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIiksXG4gICAgICBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VfbGlzdFwiKSxcbiAgICAgIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpLFxuICAgICAgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmxhenlcIiksXG4gICAgICBSRUFDVF9BQ1RJVklUWV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmFjdGl2aXR5XCIpLFxuICAgICAgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yLFxuICAgICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50ID0ge30sXG4gICAgICBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IHtcbiAgICAgICAgaXNNb3VudGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICB9LFxuICAgICAgICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgICAgICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCBcImZvcmNlVXBkYXRlXCIpO1xuICAgICAgICB9LFxuICAgICAgICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICAgICAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgXCJyZXBsYWNlU3RhdGVcIik7XG4gICAgICAgIH0sXG4gICAgICAgIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgICAgICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsIFwic2V0U3RhdGVcIik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhc3NpZ24gPSBPYmplY3QuYXNzaWduLFxuICAgICAgZW1wdHlPYmplY3QgPSB7fTtcbiAgICBPYmplY3QuZnJlZXplKGVtcHR5T2JqZWN0KTtcbiAgICBDb21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB7fTtcbiAgICBDb21wb25lbnQucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gKHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2spIHtcbiAgICAgIGlmIChcbiAgICAgICAgXCJvYmplY3RcIiAhPT0gdHlwZW9mIHBhcnRpYWxTdGF0ZSAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBwYXJ0aWFsU3RhdGUgJiZcbiAgICAgICAgbnVsbCAhPSBwYXJ0aWFsU3RhdGVcbiAgICAgIClcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJ0YWtlcyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzIHRvIHVwZGF0ZSBvciBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcy5cIlxuICAgICAgICApO1xuICAgICAgdGhpcy51cGRhdGVyLmVucXVldWVTZXRTdGF0ZSh0aGlzLCBwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrLCBcInNldFN0YXRlXCIpO1xuICAgIH07XG4gICAgQ29tcG9uZW50LnByb3RvdHlwZS5mb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgdGhpcy51cGRhdGVyLmVucXVldWVGb3JjZVVwZGF0ZSh0aGlzLCBjYWxsYmFjaywgXCJmb3JjZVVwZGF0ZVwiKTtcbiAgICB9O1xuICAgIHZhciBkZXByZWNhdGVkQVBJcyA9IHtcbiAgICAgICAgaXNNb3VudGVkOiBbXG4gICAgICAgICAgXCJpc01vdW50ZWRcIixcbiAgICAgICAgICBcIkluc3RlYWQsIG1ha2Ugc3VyZSB0byBjbGVhbiB1cCBzdWJzY3JpcHRpb25zIGFuZCBwZW5kaW5nIHJlcXVlc3RzIGluIGNvbXBvbmVudFdpbGxVbm1vdW50IHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzLlwiXG4gICAgICAgIF0sXG4gICAgICAgIHJlcGxhY2VTdGF0ZTogW1xuICAgICAgICAgIFwicmVwbGFjZVN0YXRlXCIsXG4gICAgICAgICAgXCJSZWZhY3RvciB5b3VyIGNvZGUgdG8gdXNlIHNldFN0YXRlIGluc3RlYWQgKHNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzMyMzYpLlwiXG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICBmbk5hbWU7XG4gICAgZm9yIChmbk5hbWUgaW4gZGVwcmVjYXRlZEFQSXMpXG4gICAgICBkZXByZWNhdGVkQVBJcy5oYXNPd25Qcm9wZXJ0eShmbk5hbWUpICYmXG4gICAgICAgIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyhmbk5hbWUsIGRlcHJlY2F0ZWRBUElzW2ZuTmFtZV0pO1xuICAgIENvbXBvbmVudER1bW15LnByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gICAgZGVwcmVjYXRlZEFQSXMgPSBQdXJlQ29tcG9uZW50LnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnREdW1teSgpO1xuICAgIGRlcHJlY2F0ZWRBUElzLmNvbnN0cnVjdG9yID0gUHVyZUNvbXBvbmVudDtcbiAgICBhc3NpZ24oZGVwcmVjYXRlZEFQSXMsIENvbXBvbmVudC5wcm90b3R5cGUpO1xuICAgIGRlcHJlY2F0ZWRBUElzLmlzUHVyZVJlYWN0Q29tcG9uZW50ID0gITA7XG4gICAgdmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheSxcbiAgICAgIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UgPSBTeW1ib2wuZm9yKFwicmVhY3QuY2xpZW50LnJlZmVyZW5jZVwiKSxcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0ge1xuICAgICAgICBIOiBudWxsLFxuICAgICAgICBBOiBudWxsLFxuICAgICAgICBUOiBudWxsLFxuICAgICAgICBTOiBudWxsLFxuICAgICAgICBhY3RRdWV1ZTogbnVsbCxcbiAgICAgICAgYXN5bmNUcmFuc2l0aW9uczogMCxcbiAgICAgICAgaXNCYXRjaGluZ0xlZ2FjeTogITEsXG4gICAgICAgIGRpZFNjaGVkdWxlTGVnYWN5VXBkYXRlOiAhMSxcbiAgICAgICAgZGlkVXNlUHJvbWlzZTogITEsXG4gICAgICAgIHRocm93bkVycm9yczogW10sXG4gICAgICAgIGdldEN1cnJlbnRTdGFjazogbnVsbCxcbiAgICAgICAgcmVjZW50bHlDcmVhdGVkT3duZXJTdGFja3M6IDBcbiAgICAgIH0sXG4gICAgICBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG4gICAgICBjcmVhdGVUYXNrID0gY29uc29sZS5jcmVhdGVUYXNrXG4gICAgICAgID8gY29uc29sZS5jcmVhdGVUYXNrXG4gICAgICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfTtcbiAgICBkZXByZWNhdGVkQVBJcyA9IHtcbiAgICAgIHJlYWN0X3N0YWNrX2JvdHRvbV9mcmFtZTogZnVuY3Rpb24gKGNhbGxTdGFja0ZvckVycm9yKSB7XG4gICAgICAgIHJldHVybiBjYWxsU3RhY2tGb3JFcnJvcigpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duLCBkaWRXYXJuQWJvdXRPbGRKU1hSdW50aW1lO1xuICAgIHZhciBkaWRXYXJuQWJvdXRFbGVtZW50UmVmID0ge307XG4gICAgdmFyIHVua25vd25Pd25lckRlYnVnU3RhY2sgPSBkZXByZWNhdGVkQVBJcy5yZWFjdF9zdGFja19ib3R0b21fZnJhbWUuYmluZChcbiAgICAgIGRlcHJlY2F0ZWRBUElzLFxuICAgICAgVW5rbm93bk93bmVyXG4gICAgKSgpO1xuICAgIHZhciB1bmtub3duT3duZXJEZWJ1Z1Rhc2sgPSBjcmVhdGVUYXNrKGdldFRhc2tOYW1lKFVua25vd25Pd25lcikpO1xuICAgIHZhciBkaWRXYXJuQWJvdXRNYXBzID0gITEsXG4gICAgICB1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCA9IC9cXC8rL2csXG4gICAgICByZXBvcnRHbG9iYWxFcnJvciA9XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJlcG9ydEVycm9yXG4gICAgICAgICAgPyByZXBvcnRFcnJvclxuICAgICAgICAgIDogZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2Ygd2luZG93ICYmXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2Ygd2luZG93LkVycm9yRXZlbnRcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50ID0gbmV3IHdpbmRvdy5FcnJvckV2ZW50KFwiZXJyb3JcIiwge1xuICAgICAgICAgICAgICAgICAgYnViYmxlczogITAsXG4gICAgICAgICAgICAgICAgICBjYW5jZWxhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6XG4gICAgICAgICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBlcnJvciAmJlxuICAgICAgICAgICAgICAgICAgICBudWxsICE9PSBlcnJvciAmJlxuICAgICAgICAgICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgZXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgID8gU3RyaW5nKGVycm9yLm1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgICAgICAgOiBTdHJpbmcoZXJyb3IpLFxuICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKCF3aW5kb3cuZGlzcGF0Y2hFdmVudChldmVudCkpIHJldHVybjtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgcHJvY2VzcyAmJlxuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHByb2Nlc3MuZW1pdFxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzLmVtaXQoXCJ1bmNhdWdodEV4Y2VwdGlvblwiLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfSxcbiAgICAgIGRpZFdhcm5BYm91dE1lc3NhZ2VDaGFubmVsID0gITEsXG4gICAgICBlbnF1ZXVlVGFza0ltcGwgPSBudWxsLFxuICAgICAgYWN0U2NvcGVEZXB0aCA9IDAsXG4gICAgICBkaWRXYXJuTm9Bd2FpdEFjdCA9ICExLFxuICAgICAgaXNGbHVzaGluZyA9ICExLFxuICAgICAgcXVldWVTZXZlcmFsTWljcm90YXNrcyA9XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHF1ZXVlTWljcm90YXNrXG4gICAgICAgICAgPyBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBxdWV1ZU1pY3JvdGFzayhjYWxsYmFjayk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIDogZW5xdWV1ZVRhc2s7XG4gICAgZGVwcmVjYXRlZEFQSXMgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICAgIGM6IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlRGlzcGF0Y2hlcigpLnVzZU1lbW9DYWNoZShzaXplKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBleHBvcnRzLkNoaWxkcmVuID0ge1xuICAgICAgbWFwOiBtYXBDaGlsZHJlbixcbiAgICAgIGZvckVhY2g6IGZ1bmN0aW9uIChjaGlsZHJlbiwgZm9yRWFjaEZ1bmMsIGZvckVhY2hDb250ZXh0KSB7XG4gICAgICAgIG1hcENoaWxkcmVuKFxuICAgICAgICAgIGNoaWxkcmVuLFxuICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZvckVhY2hGdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBmb3JFYWNoQ29udGV4dFxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIGNvdW50OiBmdW5jdGlvbiAoY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIG4gPSAwO1xuICAgICAgICBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIG4rKztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuO1xuICAgICAgfSxcbiAgICAgIHRvQXJyYXk6IGZ1bmN0aW9uIChjaGlsZHJlbikge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgICAgICB9KSB8fCBbXVxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIG9ubHk6IGZ1bmN0aW9uIChjaGlsZHJlbikge1xuICAgICAgICBpZiAoIWlzVmFsaWRFbGVtZW50KGNoaWxkcmVuKSlcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiUmVhY3QuQ2hpbGRyZW4ub25seSBleHBlY3RlZCB0byByZWNlaXZlIGEgc2luZ2xlIFJlYWN0IGVsZW1lbnQgY2hpbGQuXCJcbiAgICAgICAgICApO1xuICAgICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLkNvbXBvbmVudCA9IENvbXBvbmVudDtcbiAgICBleHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbiAgICBleHBvcnRzLlByb2ZpbGVyID0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbiAgICBleHBvcnRzLlB1cmVDb21wb25lbnQgPSBQdXJlQ29tcG9uZW50O1xuICAgIGV4cG9ydHMuU3RyaWN0TW9kZSA9IFJFQUNUX1NUUklDVF9NT0RFX1RZUEU7XG4gICAgZXhwb3J0cy5TdXNwZW5zZSA9IFJFQUNUX1NVU1BFTlNFX1RZUEU7XG4gICAgZXhwb3J0cy5fX0NMSUVOVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUgPVxuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHM7XG4gICAgZXhwb3J0cy5fX0NPTVBJTEVSX1JVTlRJTUUgPSBkZXByZWNhdGVkQVBJcztcbiAgICBleHBvcnRzLmFjdCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgdmFyIHByZXZBY3RRdWV1ZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlLFxuICAgICAgICBwcmV2QWN0U2NvcGVEZXB0aCA9IGFjdFNjb3BlRGVwdGg7XG4gICAgICBhY3RTY29wZURlcHRoKys7XG4gICAgICB2YXIgcXVldWUgPSAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWUgPVxuICAgICAgICAgIG51bGwgIT09IHByZXZBY3RRdWV1ZSA/IHByZXZBY3RRdWV1ZSA6IFtdKSxcbiAgICAgICAgZGlkQXdhaXRBY3RDYWxsID0gITE7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY2FsbGJhY2soKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgIH1cbiAgICAgIGlmICgwIDwgUmVhY3RTaGFyZWRJbnRlcm5hbHMudGhyb3duRXJyb3JzLmxlbmd0aClcbiAgICAgICAgdGhyb3cgKFxuICAgICAgICAgIChwb3BBY3RTY29wZShwcmV2QWN0UXVldWUsIHByZXZBY3RTY29wZURlcHRoKSxcbiAgICAgICAgICAoY2FsbGJhY2sgPSBhZ2dyZWdhdGVFcnJvcnMoUmVhY3RTaGFyZWRJbnRlcm5hbHMudGhyb3duRXJyb3JzKSksXG4gICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9ycy5sZW5ndGggPSAwKSxcbiAgICAgICAgICBjYWxsYmFjaylcbiAgICAgICAgKTtcbiAgICAgIGlmIChcbiAgICAgICAgbnVsbCAhPT0gcmVzdWx0ICYmXG4gICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiByZXN1bHQgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmVzdWx0LnRoZW5cbiAgICAgICkge1xuICAgICAgICB2YXIgdGhlbmFibGUgPSByZXN1bHQ7XG4gICAgICAgIHF1ZXVlU2V2ZXJhbE1pY3JvdGFza3MoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGRpZEF3YWl0QWN0Q2FsbCB8fFxuICAgICAgICAgICAgZGlkV2Fybk5vQXdhaXRBY3QgfHxcbiAgICAgICAgICAgICgoZGlkV2Fybk5vQXdhaXRBY3QgPSAhMCksXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIllvdSBjYWxsZWQgYWN0KGFzeW5jICgpID0+IC4uLikgd2l0aG91dCBhd2FpdC4gVGhpcyBjb3VsZCBsZWFkIHRvIHVuZXhwZWN0ZWQgdGVzdGluZyBiZWhhdmlvdXIsIGludGVybGVhdmluZyBtdWx0aXBsZSBhY3QgY2FsbHMgYW5kIG1peGluZyB0aGVpciBzY29wZXMuIFlvdSBzaG91bGQgLSBhd2FpdCBhY3QoYXN5bmMgKCkgPT4gLi4uKTtcIlxuICAgICAgICAgICAgKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRoZW46IGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGRpZEF3YWl0QWN0Q2FsbCA9ICEwO1xuICAgICAgICAgICAgdGhlbmFibGUudGhlbihcbiAgICAgICAgICAgICAgZnVuY3Rpb24gKHJldHVyblZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcG9wQWN0U2NvcGUocHJldkFjdFF1ZXVlLCBwcmV2QWN0U2NvcGVEZXB0aCk7XG4gICAgICAgICAgICAgICAgaWYgKDAgPT09IHByZXZBY3RTY29wZURlcHRoKSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmbHVzaEFjdFF1ZXVlKHF1ZXVlKSxcbiAgICAgICAgICAgICAgICAgICAgICBlbnF1ZXVlVGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVjdXJzaXZlbHlGbHVzaEFzeW5jQWN0V29yayhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yJDApIHtcbiAgICAgICAgICAgICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMudGhyb3duRXJyb3JzLnB1c2goZXJyb3IkMCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoMCA8IFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aHJvd25FcnJvciA9IGFnZ3JlZ2F0ZUVycm9ycyhcbiAgICAgICAgICAgICAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy50aHJvd25FcnJvcnNcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMudGhyb3duRXJyb3JzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChfdGhyb3duRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSByZXNvbHZlKHJldHVyblZhbHVlKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcG9wQWN0U2NvcGUocHJldkFjdFF1ZXVlLCBwcmV2QWN0U2NvcGVEZXB0aCk7XG4gICAgICAgICAgICAgICAgMCA8IFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9ycy5sZW5ndGhcbiAgICAgICAgICAgICAgICAgID8gKChlcnJvciA9IGFnZ3JlZ2F0ZUVycm9ycyhcbiAgICAgICAgICAgICAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy50aHJvd25FcnJvcnNcbiAgICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy50aHJvd25FcnJvcnMubGVuZ3RoID0gMCksXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcikpXG4gICAgICAgICAgICAgICAgICA6IHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdmFyIHJldHVyblZhbHVlJGpzY29tcCQwID0gcmVzdWx0O1xuICAgICAgcG9wQWN0U2NvcGUocHJldkFjdFF1ZXVlLCBwcmV2QWN0U2NvcGVEZXB0aCk7XG4gICAgICAwID09PSBwcmV2QWN0U2NvcGVEZXB0aCAmJlxuICAgICAgICAoZmx1c2hBY3RRdWV1ZShxdWV1ZSksXG4gICAgICAgIDAgIT09IHF1ZXVlLmxlbmd0aCAmJlxuICAgICAgICAgIHF1ZXVlU2V2ZXJhbE1pY3JvdGFza3MoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZGlkQXdhaXRBY3RDYWxsIHx8XG4gICAgICAgICAgICAgIGRpZFdhcm5Ob0F3YWl0QWN0IHx8XG4gICAgICAgICAgICAgICgoZGlkV2Fybk5vQXdhaXRBY3QgPSAhMCksXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJBIGNvbXBvbmVudCBzdXNwZW5kZWQgaW5zaWRlIGFuIGBhY3RgIHNjb3BlLCBidXQgdGhlIGBhY3RgIGNhbGwgd2FzIG5vdCBhd2FpdGVkLiBXaGVuIHRlc3RpbmcgUmVhY3QgY29tcG9uZW50cyB0aGF0IGRlcGVuZCBvbiBhc3luY2hyb25vdXMgZGF0YSwgeW91IG11c3QgYXdhaXQgdGhlIHJlc3VsdDpcXG5cXG5hd2FpdCBhY3QoKCkgPT4gLi4uKVwiXG4gICAgICAgICAgICAgICkpO1xuICAgICAgICAgIH0pLFxuICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWUgPSBudWxsKSk7XG4gICAgICBpZiAoMCA8IFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9ycy5sZW5ndGgpXG4gICAgICAgIHRocm93IChcbiAgICAgICAgICAoKGNhbGxiYWNrID0gYWdncmVnYXRlRXJyb3JzKFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9ycykpLFxuICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy50aHJvd25FcnJvcnMubGVuZ3RoID0gMCksXG4gICAgICAgICAgY2FsbGJhY2spXG4gICAgICAgICk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0aGVuOiBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgZGlkQXdhaXRBY3RDYWxsID0gITA7XG4gICAgICAgICAgMCA9PT0gcHJldkFjdFNjb3BlRGVwdGhcbiAgICAgICAgICAgID8gKChSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZSA9IHF1ZXVlKSxcbiAgICAgICAgICAgICAgZW5xdWV1ZVRhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWN1cnNpdmVseUZsdXNoQXN5bmNBY3RXb3JrKFxuICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICByZXNvbHZlLFxuICAgICAgICAgICAgICAgICAgcmVqZWN0XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICA6IHJlc29sdmUocmV0dXJuVmFsdWUkanNjb21wJDApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG4gICAgZXhwb3J0cy5jYWNoZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH07XG4gICAgZXhwb3J0cy5jYWNoZVNpZ25hbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgZXhwb3J0cy5jYXB0dXJlT3duZXJTdGFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBnZXRDdXJyZW50U3RhY2sgPSBSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2s7XG4gICAgICByZXR1cm4gbnVsbCA9PT0gZ2V0Q3VycmVudFN0YWNrID8gbnVsbCA6IGdldEN1cnJlbnRTdGFjaygpO1xuICAgIH07XG4gICAgZXhwb3J0cy5jbG9uZUVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCwgY29uZmlnLCBjaGlsZHJlbikge1xuICAgICAgaWYgKG51bGwgPT09IGVsZW1lbnQgfHwgdm9pZCAwID09PSBlbGVtZW50KVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIlRoZSBhcmd1bWVudCBtdXN0IGJlIGEgUmVhY3QgZWxlbWVudCwgYnV0IHlvdSBwYXNzZWQgXCIgK1xuICAgICAgICAgICAgZWxlbWVudCArXG4gICAgICAgICAgICBcIi5cIlxuICAgICAgICApO1xuICAgICAgdmFyIHByb3BzID0gYXNzaWduKHt9LCBlbGVtZW50LnByb3BzKSxcbiAgICAgICAga2V5ID0gZWxlbWVudC5rZXksXG4gICAgICAgIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICBpZiAobnVsbCAhPSBjb25maWcpIHtcbiAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdDtcbiAgICAgICAgYToge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBcInJlZlwiKSAmJlxuICAgICAgICAgICAgKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoXG4gICAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgICAgXCJyZWZcIlxuICAgICAgICAgICAgKS5nZXQpICYmXG4gICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQuaXNSZWFjdFdhcm5pbmdcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICExO1xuICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICB9XG4gICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gdm9pZCAwICE9PSBjb25maWcucmVmO1xuICAgICAgICB9XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCAmJiAob3duZXIgPSBnZXRPd25lcigpKTtcbiAgICAgICAgaGFzVmFsaWRLZXkoY29uZmlnKSAmJlxuICAgICAgICAgIChjaGVja0tleVN0cmluZ0NvZXJjaW9uKGNvbmZpZy5rZXkpLCAoa2V5ID0gXCJcIiArIGNvbmZpZy5rZXkpKTtcbiAgICAgICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpXG4gICAgICAgICAgIWhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgfHxcbiAgICAgICAgICAgIFwia2V5XCIgPT09IHByb3BOYW1lIHx8XG4gICAgICAgICAgICBcIl9fc2VsZlwiID09PSBwcm9wTmFtZSB8fFxuICAgICAgICAgICAgXCJfX3NvdXJjZVwiID09PSBwcm9wTmFtZSB8fFxuICAgICAgICAgICAgKFwicmVmXCIgPT09IHByb3BOYW1lICYmIHZvaWQgMCA9PT0gY29uZmlnLnJlZikgfHxcbiAgICAgICAgICAgIChwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wTmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICAgICAgaWYgKDEgPT09IHByb3BOYW1lKSBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgZWxzZSBpZiAoMSA8IHByb3BOYW1lKSB7XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IEFycmF5KHByb3BOYW1lKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wTmFtZTsgaSsrKVxuICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdFtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgICAgIHByb3BzLmNoaWxkcmVuID0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0O1xuICAgICAgfVxuICAgICAgcHJvcHMgPSBSZWFjdEVsZW1lbnQoXG4gICAgICAgIGVsZW1lbnQudHlwZSxcbiAgICAgICAga2V5LFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAgb3duZXIsXG4gICAgICAgIHByb3BzLFxuICAgICAgICBlbGVtZW50Ll9kZWJ1Z1N0YWNrLFxuICAgICAgICBlbGVtZW50Ll9kZWJ1Z1Rhc2tcbiAgICAgICk7XG4gICAgICBmb3IgKGtleSA9IDI7IGtleSA8IGFyZ3VtZW50cy5sZW5ndGg7IGtleSsrKVxuICAgICAgICAob3duZXIgPSBhcmd1bWVudHNba2V5XSksXG4gICAgICAgICAgaXNWYWxpZEVsZW1lbnQob3duZXIpICYmIG93bmVyLl9zdG9yZSAmJiAob3duZXIuX3N0b3JlLnZhbGlkYXRlZCA9IDEpO1xuICAgICAgcmV0dXJuIHByb3BzO1xuICAgIH07XG4gICAgZXhwb3J0cy5jcmVhdGVDb250ZXh0ID0gZnVuY3Rpb24gKGRlZmF1bHRWYWx1ZSkge1xuICAgICAgZGVmYXVsdFZhbHVlID0ge1xuICAgICAgICAkJHR5cGVvZjogUkVBQ1RfQ09OVEVYVF9UWVBFLFxuICAgICAgICBfY3VycmVudFZhbHVlOiBkZWZhdWx0VmFsdWUsXG4gICAgICAgIF9jdXJyZW50VmFsdWUyOiBkZWZhdWx0VmFsdWUsXG4gICAgICAgIF90aHJlYWRDb3VudDogMCxcbiAgICAgICAgUHJvdmlkZXI6IG51bGwsXG4gICAgICAgIENvbnN1bWVyOiBudWxsXG4gICAgICB9O1xuICAgICAgZGVmYXVsdFZhbHVlLlByb3ZpZGVyID0gZGVmYXVsdFZhbHVlO1xuICAgICAgZGVmYXVsdFZhbHVlLkNvbnN1bWVyID0ge1xuICAgICAgICAkJHR5cGVvZjogUkVBQ1RfQ09OU1VNRVJfVFlQRSxcbiAgICAgICAgX2NvbnRleHQ6IGRlZmF1bHRWYWx1ZVxuICAgICAgfTtcbiAgICAgIGRlZmF1bHRWYWx1ZS5fY3VycmVudFJlbmRlcmVyID0gbnVsbDtcbiAgICAgIGRlZmF1bHRWYWx1ZS5fY3VycmVudFJlbmRlcmVyMiA9IG51bGw7XG4gICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgIH07XG4gICAgZXhwb3J0cy5jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBpc1ZhbGlkRWxlbWVudChub2RlKSAmJiBub2RlLl9zdG9yZSAmJiAobm9kZS5fc3RvcmUudmFsaWRhdGVkID0gMSk7XG4gICAgICB9XG4gICAgICBpID0ge307XG4gICAgICBub2RlID0gbnVsbDtcbiAgICAgIGlmIChudWxsICE9IGNvbmZpZylcbiAgICAgICAgZm9yIChwcm9wTmFtZSBpbiAoZGlkV2FybkFib3V0T2xkSlNYUnVudGltZSB8fFxuICAgICAgICAgICEoXCJfX3NlbGZcIiBpbiBjb25maWcpIHx8XG4gICAgICAgICAgXCJrZXlcIiBpbiBjb25maWcgfHxcbiAgICAgICAgICAoKGRpZFdhcm5BYm91dE9sZEpTWFJ1bnRpbWUgPSAhMCksXG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgXCJZb3VyIGFwcCAob3Igb25lIG9mIGl0cyBkZXBlbmRlbmNpZXMpIGlzIHVzaW5nIGFuIG91dGRhdGVkIEpTWCB0cmFuc2Zvcm0uIFVwZGF0ZSB0byB0aGUgbW9kZXJuIEpTWCB0cmFuc2Zvcm0gZm9yIGZhc3RlciBwZXJmb3JtYW5jZTogaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9uZXctanN4LXRyYW5zZm9ybVwiXG4gICAgICAgICAgKSksXG4gICAgICAgIGhhc1ZhbGlkS2V5KGNvbmZpZykgJiZcbiAgICAgICAgICAoY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KSwgKG5vZGUgPSBcIlwiICsgY29uZmlnLmtleSkpLFxuICAgICAgICBjb25maWcpKVxuICAgICAgICAgIGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiZcbiAgICAgICAgICAgIFwia2V5XCIgIT09IHByb3BOYW1lICYmXG4gICAgICAgICAgICBcIl9fc2VsZlwiICE9PSBwcm9wTmFtZSAmJlxuICAgICAgICAgICAgXCJfX3NvdXJjZVwiICE9PSBwcm9wTmFtZSAmJlxuICAgICAgICAgICAgKGlbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXSk7XG4gICAgICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgICAgIGlmICgxID09PSBjaGlsZHJlbkxlbmd0aCkgaS5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgZWxzZSBpZiAoMSA8IGNoaWxkcmVuTGVuZ3RoKSB7XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCksIF9pID0gMDtcbiAgICAgICAgICBfaSA8IGNoaWxkcmVuTGVuZ3RoO1xuICAgICAgICAgIF9pKytcbiAgICAgICAgKVxuICAgICAgICAgIGNoaWxkQXJyYXlbX2ldID0gYXJndW1lbnRzW19pICsgMl07XG4gICAgICAgIE9iamVjdC5mcmVlemUgJiYgT2JqZWN0LmZyZWV6ZShjaGlsZEFycmF5KTtcbiAgICAgICAgaS5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcylcbiAgICAgICAgZm9yIChwcm9wTmFtZSBpbiAoKGNoaWxkcmVuTGVuZ3RoID0gdHlwZS5kZWZhdWx0UHJvcHMpLCBjaGlsZHJlbkxlbmd0aCkpXG4gICAgICAgICAgdm9pZCAwID09PSBpW3Byb3BOYW1lXSAmJiAoaVtwcm9wTmFtZV0gPSBjaGlsZHJlbkxlbmd0aFtwcm9wTmFtZV0pO1xuICAgICAgbm9kZSAmJlxuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihcbiAgICAgICAgICBpLFxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGVcbiAgICAgICAgICAgID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgXCJVbmtub3duXCJcbiAgICAgICAgICAgIDogdHlwZVxuICAgICAgICApO1xuICAgICAgdmFyIHByb3BOYW1lID0gMWU0ID4gUmVhY3RTaGFyZWRJbnRlcm5hbHMucmVjZW50bHlDcmVhdGVkT3duZXJTdGFja3MrKztcbiAgICAgIHJldHVybiBSZWFjdEVsZW1lbnQoXG4gICAgICAgIHR5cGUsXG4gICAgICAgIG5vZGUsXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICBnZXRPd25lcigpLFxuICAgICAgICBpLFxuICAgICAgICBwcm9wTmFtZSA/IEVycm9yKFwicmVhY3Qtc3RhY2stdG9wLWZyYW1lXCIpIDogdW5rbm93bk93bmVyRGVidWdTdGFjayxcbiAgICAgICAgcHJvcE5hbWUgPyBjcmVhdGVUYXNrKGdldFRhc2tOYW1lKHR5cGUpKSA6IHVua25vd25Pd25lckRlYnVnVGFza1xuICAgICAgKTtcbiAgICB9O1xuICAgIGV4cG9ydHMuY3JlYXRlUmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHJlZk9iamVjdCA9IHsgY3VycmVudDogbnVsbCB9O1xuICAgICAgT2JqZWN0LnNlYWwocmVmT2JqZWN0KTtcbiAgICAgIHJldHVybiByZWZPYmplY3Q7XG4gICAgfTtcbiAgICBleHBvcnRzLmZvcndhcmRSZWYgPSBmdW5jdGlvbiAocmVuZGVyKSB7XG4gICAgICBudWxsICE9IHJlbmRlciAmJiByZW5kZXIuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRVxuICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcImZvcndhcmRSZWYgcmVxdWlyZXMgYSByZW5kZXIgZnVuY3Rpb24gYnV0IHJlY2VpdmVkIGEgYG1lbW9gIGNvbXBvbmVudC4gSW5zdGVhZCBvZiBmb3J3YXJkUmVmKG1lbW8oLi4uKSksIHVzZSBtZW1vKGZvcndhcmRSZWYoLi4uKSkuXCJcbiAgICAgICAgICApXG4gICAgICAgIDogXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgcmVuZGVyXG4gICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcImZvcndhcmRSZWYgcmVxdWlyZXMgYSByZW5kZXIgZnVuY3Rpb24gYnV0IHdhcyBnaXZlbiAlcy5cIixcbiAgICAgICAgICAgICAgbnVsbCA9PT0gcmVuZGVyID8gXCJudWxsXCIgOiB0eXBlb2YgcmVuZGVyXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiAwICE9PSByZW5kZXIubGVuZ3RoICYmXG4gICAgICAgICAgICAyICE9PSByZW5kZXIubGVuZ3RoICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcImZvcndhcmRSZWYgcmVuZGVyIGZ1bmN0aW9ucyBhY2NlcHQgZXhhY3RseSB0d28gcGFyYW1ldGVyczogcHJvcHMgYW5kIHJlZi4gJXNcIixcbiAgICAgICAgICAgICAgMSA9PT0gcmVuZGVyLmxlbmd0aFxuICAgICAgICAgICAgICAgID8gXCJEaWQgeW91IGZvcmdldCB0byB1c2UgdGhlIHJlZiBwYXJhbWV0ZXI/XCJcbiAgICAgICAgICAgICAgICA6IFwiQW55IGFkZGl0aW9uYWwgcGFyYW1ldGVyIHdpbGwgYmUgdW5kZWZpbmVkLlwiXG4gICAgICAgICAgICApO1xuICAgICAgbnVsbCAhPSByZW5kZXIgJiZcbiAgICAgICAgbnVsbCAhPSByZW5kZXIuZGVmYXVsdFByb3BzICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJmb3J3YXJkUmVmIHJlbmRlciBmdW5jdGlvbnMgZG8gbm90IHN1cHBvcnQgZGVmYXVsdFByb3BzLiBEaWQgeW91IGFjY2lkZW50YWxseSBwYXNzIGEgUmVhY3QgY29tcG9uZW50P1wiXG4gICAgICAgICk7XG4gICAgICB2YXIgZWxlbWVudFR5cGUgPSB7ICQkdHlwZW9mOiBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFLCByZW5kZXI6IHJlbmRlciB9LFxuICAgICAgICBvd25OYW1lO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnRUeXBlLCBcImRpc3BsYXlOYW1lXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBvd25OYW1lO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgb3duTmFtZSA9IG5hbWU7XG4gICAgICAgICAgcmVuZGVyLm5hbWUgfHxcbiAgICAgICAgICAgIHJlbmRlci5kaXNwbGF5TmFtZSB8fFxuICAgICAgICAgICAgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZW5kZXIsIFwibmFtZVwiLCB7IHZhbHVlOiBuYW1lIH0pLFxuICAgICAgICAgICAgKHJlbmRlci5kaXNwbGF5TmFtZSA9IG5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZWxlbWVudFR5cGU7XG4gICAgfTtcbiAgICBleHBvcnRzLmlzVmFsaWRFbGVtZW50ID0gaXNWYWxpZEVsZW1lbnQ7XG4gICAgZXhwb3J0cy5sYXp5ID0gZnVuY3Rpb24gKGN0b3IpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICQkdHlwZW9mOiBSRUFDVF9MQVpZX1RZUEUsXG4gICAgICAgIF9wYXlsb2FkOiB7IF9zdGF0dXM6IC0xLCBfcmVzdWx0OiBjdG9yIH0sXG4gICAgICAgIF9pbml0OiBsYXp5SW5pdGlhbGl6ZXJcbiAgICAgIH07XG4gICAgfTtcbiAgICBleHBvcnRzLm1lbW8gPSBmdW5jdGlvbiAodHlwZSwgY29tcGFyZSkge1xuICAgICAgbnVsbCA9PSB0eXBlICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJtZW1vOiBUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIGNvbXBvbmVudC4gSW5zdGVhZCByZWNlaXZlZDogJXNcIixcbiAgICAgICAgICBudWxsID09PSB0eXBlID8gXCJudWxsXCIgOiB0eXBlb2YgdHlwZVxuICAgICAgICApO1xuICAgICAgY29tcGFyZSA9IHtcbiAgICAgICAgJCR0eXBlb2Y6IFJFQUNUX01FTU9fVFlQRSxcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgY29tcGFyZTogdm9pZCAwID09PSBjb21wYXJlID8gbnVsbCA6IGNvbXBhcmVcbiAgICAgIH07XG4gICAgICB2YXIgb3duTmFtZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb21wYXJlLCBcImRpc3BsYXlOYW1lXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBvd25OYW1lO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgb3duTmFtZSA9IG5hbWU7XG4gICAgICAgICAgdHlwZS5uYW1lIHx8XG4gICAgICAgICAgICB0eXBlLmRpc3BsYXlOYW1lIHx8XG4gICAgICAgICAgICAoT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwibmFtZVwiLCB7IHZhbHVlOiBuYW1lIH0pLFxuICAgICAgICAgICAgKHR5cGUuZGlzcGxheU5hbWUgPSBuYW1lKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNvbXBhcmU7XG4gICAgfTtcbiAgICBleHBvcnRzLnN0YXJ0VHJhbnNpdGlvbiA9IGZ1bmN0aW9uIChzY29wZSkge1xuICAgICAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCxcbiAgICAgICAgY3VycmVudFRyYW5zaXRpb24gPSB7fTtcbiAgICAgIGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzID0gbmV3IFNldCgpO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IGN1cnJlbnRUcmFuc2l0aW9uO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHJldHVyblZhbHVlID0gc2NvcGUoKSxcbiAgICAgICAgICBvblN0YXJ0VHJhbnNpdGlvbkZpbmlzaCA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlM7XG4gICAgICAgIG51bGwgIT09IG9uU3RhcnRUcmFuc2l0aW9uRmluaXNoICYmXG4gICAgICAgICAgb25TdGFydFRyYW5zaXRpb25GaW5pc2goY3VycmVudFRyYW5zaXRpb24sIHJldHVyblZhbHVlKTtcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHJldHVyblZhbHVlICYmXG4gICAgICAgICAgbnVsbCAhPT0gcmV0dXJuVmFsdWUgJiZcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZXR1cm5WYWx1ZS50aGVuICYmXG4gICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFzeW5jVHJhbnNpdGlvbnMrKyxcbiAgICAgICAgICByZXR1cm5WYWx1ZS50aGVuKHJlbGVhc2VBc3luY1RyYW5zaXRpb24sIHJlbGVhc2VBc3luY1RyYW5zaXRpb24pLFxuICAgICAgICAgIHJldHVyblZhbHVlLnRoZW4obm9vcCwgcmVwb3J0R2xvYmFsRXJyb3IpKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJlcG9ydEdsb2JhbEVycm9yKGVycm9yKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIG51bGwgPT09IHByZXZUcmFuc2l0aW9uICYmXG4gICAgICAgICAgY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMgJiZcbiAgICAgICAgICAoKHNjb3BlID0gY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMuc2l6ZSksXG4gICAgICAgICAgY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMuY2xlYXIoKSxcbiAgICAgICAgICAxMCA8IHNjb3BlICYmXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgIFwiRGV0ZWN0ZWQgYSBsYXJnZSBudW1iZXIgb2YgdXBkYXRlcyBpbnNpZGUgc3RhcnRUcmFuc2l0aW9uLiBJZiB0aGlzIGlzIGR1ZSB0byBhIHN1YnNjcmlwdGlvbiBwbGVhc2UgcmUtd3JpdGUgaXQgdG8gdXNlIFJlYWN0IHByb3ZpZGVkIGhvb2tzLiBPdGhlcndpc2UgY29uY3VycmVudCBtb2RlIGd1YXJhbnRlZXMgYXJlIG9mZiB0aGUgdGFibGUuXCJcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgIG51bGwgIT09IHByZXZUcmFuc2l0aW9uICYmXG4gICAgICAgICAgICBudWxsICE9PSBjdXJyZW50VHJhbnNpdGlvbi50eXBlcyAmJlxuICAgICAgICAgICAgKG51bGwgIT09IHByZXZUcmFuc2l0aW9uLnR5cGVzICYmXG4gICAgICAgICAgICAgIHByZXZUcmFuc2l0aW9uLnR5cGVzICE9PSBjdXJyZW50VHJhbnNpdGlvbi50eXBlcyAmJlxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiV2UgZXhwZWN0ZWQgaW5uZXIgVHJhbnNpdGlvbnMgdG8gaGF2ZSB0cmFuc2ZlcnJlZCB0aGUgb3V0ZXIgdHlwZXMgc2V0IGFuZCB0aGF0IHlvdSBjYW5ub3QgYWRkIHRvIHRoZSBvdXRlciBUcmFuc2l0aW9uIHdoaWxlIGluc2lkZSB0aGUgaW5uZXIuVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKHByZXZUcmFuc2l0aW9uLnR5cGVzID0gY3VycmVudFRyYW5zaXRpb24udHlwZXMpKSxcbiAgICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IHByZXZUcmFuc2l0aW9uKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGV4cG9ydHMudW5zdGFibGVfdXNlQ2FjaGVSZWZyZXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHJlc29sdmVEaXNwYXRjaGVyKCkudXNlQ2FjaGVSZWZyZXNoKCk7XG4gICAgfTtcbiAgICBleHBvcnRzLnVzZSA9IGZ1bmN0aW9uICh1c2FibGUpIHtcbiAgICAgIHJldHVybiByZXNvbHZlRGlzcGF0Y2hlcigpLnVzZSh1c2FibGUpO1xuICAgIH07XG4gICAgZXhwb3J0cy51c2VBY3Rpb25TdGF0ZSA9IGZ1bmN0aW9uIChhY3Rpb24sIGluaXRpYWxTdGF0ZSwgcGVybWFsaW5rKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZURpc3BhdGNoZXIoKS51c2VBY3Rpb25TdGF0ZShcbiAgICAgICAgYWN0aW9uLFxuICAgICAgICBpbml0aWFsU3RhdGUsXG4gICAgICAgIHBlcm1hbGlua1xuICAgICAgKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgIHJldHVybiByZXNvbHZlRGlzcGF0Y2hlcigpLnVzZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlQ29udGV4dCA9IGZ1bmN0aW9uIChDb250ZXh0KSB7XG4gICAgICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gICAgICBDb250ZXh0LiQkdHlwZW9mID09PSBSRUFDVF9DT05TVU1FUl9UWVBFICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJDYWxsaW5nIHVzZUNvbnRleHQoQ29udGV4dC5Db25zdW1lcikgaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBjYXVzZSBidWdzLiBEaWQgeW91IG1lYW4gdG8gY2FsbCB1c2VDb250ZXh0KENvbnRleHQpIGluc3RlYWQ/XCJcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiBkaXNwYXRjaGVyLnVzZUNvbnRleHQoQ29udGV4dCk7XG4gICAgfTtcbiAgICBleHBvcnRzLnVzZURlYnVnVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUsIGZvcm1hdHRlckZuKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZURpc3BhdGNoZXIoKS51c2VEZWJ1Z1ZhbHVlKHZhbHVlLCBmb3JtYXR0ZXJGbik7XG4gICAgfTtcbiAgICBleHBvcnRzLnVzZURlZmVycmVkVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICAgICAgcmV0dXJuIHJlc29sdmVEaXNwYXRjaGVyKCkudXNlRGVmZXJyZWRWYWx1ZSh2YWx1ZSwgaW5pdGlhbFZhbHVlKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlRWZmZWN0ID0gZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgbnVsbCA9PSBjcmVhdGUgJiZcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIFwiUmVhY3QgSG9vayB1c2VFZmZlY3QgcmVxdWlyZXMgYW4gZWZmZWN0IGNhbGxiYWNrLiBEaWQgeW91IGZvcmdldCB0byBwYXNzIGEgY2FsbGJhY2sgdG8gdGhlIGhvb2s/XCJcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiByZXNvbHZlRGlzcGF0Y2hlcigpLnVzZUVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH07XG4gICAgZXhwb3J0cy51c2VJZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiByZXNvbHZlRGlzcGF0Y2hlcigpLnVzZUlkKCk7XG4gICAgfTtcbiAgICBleHBvcnRzLnVzZUltcGVyYXRpdmVIYW5kbGUgPSBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgIHJldHVybiByZXNvbHZlRGlzcGF0Y2hlcigpLnVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgIH07XG4gICAgZXhwb3J0cy51c2VJbnNlcnRpb25FZmZlY3QgPSBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBudWxsID09IGNyZWF0ZSAmJlxuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgXCJSZWFjdCBIb29rIHVzZUluc2VydGlvbkVmZmVjdCByZXF1aXJlcyBhbiBlZmZlY3QgY2FsbGJhY2suIERpZCB5b3UgZm9yZ2V0IHRvIHBhc3MgYSBjYWxsYmFjayB0byB0aGUgaG9vaz9cIlxuICAgICAgICApO1xuICAgICAgcmV0dXJuIHJlc29sdmVEaXNwYXRjaGVyKCkudXNlSW5zZXJ0aW9uRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfTtcbiAgICBleHBvcnRzLnVzZUxheW91dEVmZmVjdCA9IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIG51bGwgPT0gY3JlYXRlICYmXG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBcIlJlYWN0IEhvb2sgdXNlTGF5b3V0RWZmZWN0IHJlcXVpcmVzIGFuIGVmZmVjdCBjYWxsYmFjay4gRGlkIHlvdSBmb3JnZXQgdG8gcGFzcyBhIGNhbGxiYWNrIHRvIHRoZSBob29rP1wiXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gcmVzb2x2ZURpc3BhdGNoZXIoKS51c2VMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlTWVtbyA9IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIHJldHVybiByZXNvbHZlRGlzcGF0Y2hlcigpLnVzZU1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlT3B0aW1pc3RpYyA9IGZ1bmN0aW9uIChwYXNzdGhyb3VnaCwgcmVkdWNlcikge1xuICAgICAgcmV0dXJuIHJlc29sdmVEaXNwYXRjaGVyKCkudXNlT3B0aW1pc3RpYyhwYXNzdGhyb3VnaCwgcmVkdWNlcik7XG4gICAgfTtcbiAgICBleHBvcnRzLnVzZVJlZHVjZXIgPSBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgcmV0dXJuIHJlc29sdmVEaXNwYXRjaGVyKCkudXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlUmVmID0gZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuICAgICAgcmV0dXJuIHJlc29sdmVEaXNwYXRjaGVyKCkudXNlUmVmKGluaXRpYWxWYWx1ZSk7XG4gICAgfTtcbiAgICBleHBvcnRzLnVzZVN0YXRlID0gZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgcmV0dXJuIHJlc29sdmVEaXNwYXRjaGVyKCkudXNlU3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlU3luY0V4dGVybmFsU3RvcmUgPSBmdW5jdGlvbiAoXG4gICAgICBzdWJzY3JpYmUsXG4gICAgICBnZXRTbmFwc2hvdCxcbiAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZURpc3BhdGNoZXIoKS51c2VTeW5jRXh0ZXJuYWxTdG9yZShcbiAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICBnZXRTbmFwc2hvdCxcbiAgICAgICAgZ2V0U2VydmVyU25hcHNob3RcbiAgICAgICk7XG4gICAgfTtcbiAgICBleHBvcnRzLnVzZVRyYW5zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZURpc3BhdGNoZXIoKS51c2VUcmFuc2l0aW9uKCk7XG4gICAgfTtcbiAgICBleHBvcnRzLnZlcnNpb24gPSBcIjE5LjIuMC1jYW5hcnktOTdjZGQ1ZDMtMjAyNTA3MTBcIjtcbiAgICBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICYmXG4gICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AgJiZcbiAgICAgIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcChFcnJvcigpKTtcbiAgfSkoKTtcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Q0FRQyxHQUdnQjtBQURqQjtBQUNBLG9FQUNFLEFBQUM7SUFDQyxTQUFTLHlCQUF5QixVQUFVLEVBQUUsSUFBSTtRQUNoRCxPQUFPLGNBQWMsQ0FBQyxVQUFVLFNBQVMsRUFBRSxZQUFZO1lBQ3JELEtBQUs7Z0JBQ0gsUUFBUSxJQUFJLENBQ1YsK0RBQ0EsSUFBSSxDQUFDLEVBQUUsRUFDUCxJQUFJLENBQUMsRUFBRTtZQUVYO1FBQ0Y7SUFDRjtJ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LFFBQVEsT0FBTyxHQUFHLFNBQVUsTUFBTSxFQUFFLElBQUk7UUFDdEMsT0FBTyxvQkFBb0IsT0FBTyxDQUFDLFFBQVE7SUFDN0M7SUFDQSxRQUFRLGFBQWEsR0FBRyxTQUFVLFdBQVcsRUFBRSxPQUFPO1FBQ3BELE9BQU8sb0JBQW9CLGFBQWEsQ0FBQyxhQUFhO0lBQ3hEO0lBQ0EsUUFBUSxVQUFVLEdBQUcsU0FBVSxPQUFPLEVBQUUsVUFBVSxFQUFFLElBQUk7UUFDdEQsT0FBTyxvQkFBb0IsVUFBVSxDQUFDLFNBQVMsWUFBWTtJQUM3RDtJQUNBLFFBQVEsTUFBTSxHQUFHLFNBQVUsWUFBWTtRQUNyQyxPQUFPLG9CQUFvQixNQUFNLENBQUM7SUFDcEM7SUFDQSxRQUFRLFFBQVEsR0FBRyxTQUFVLFlBQVk7UUFDdkMsT0FBTyxvQkFBb0IsUUFBUSxDQUFDO0lBQ3RDO0lBQ0EsUUFBUSxvQkFBb0IsR0FBRyxTQUM3QixTQUFTLEVBQ1QsV0FBVyxFQUNYLGlCQUFpQjtRQUVqQixPQUFPLG9CQUFvQixvQkFBb0IsQ0FDN0MsV0FDQSxhQUNBO0lBRUo7SUFDQSxRQUFRLGFBQWEsR0FBRztRQUN0QixPQUFPLG9CQUFvQixhQUFhO0lBQzFDO0lBQ0EsUUFBUSxPQUFPLEdBQUc7SUFDbEIsZ0JBQWdCLE9BQU8sa0NBQ3JCLGVBQ0UsT0FBTywrQkFBK0IsMEJBQTBCLElBQ2xFLCtCQUErQiwwQkFBMEIsQ0FBQztBQUM5RCIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxNzE4LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QucHJvZHVjdGlvbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUVJO0FBRko7QUFFQTs7S0FFTztJQUNMLE9BQU8sT0FBTztBQUNoQiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxNzMxLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9janMvcmVhY3QtanN4LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgICAgIGlmIChudWxsID09IHR5cGUpIHJldHVybiBudWxsO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHJldHVybiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFXG4gICAgICAgICAgPyBudWxsXG4gICAgICAgICAgOiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKSByZXR1cm4gdHlwZTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiRnJhZ21lbnRcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlByb2ZpbGVyXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdHJpY3RNb2RlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZVwiO1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZUxpc3RcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9BQ1RJVklUWV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIkFjdGl2aXR5XCI7XG4gICAgICB9XG4gICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHN3aXRjaCAoXG4gICAgICAgICAgKFwibnVtYmVyXCIgPT09IHR5cGVvZiB0eXBlLnRhZyAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoKS4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgIHR5cGUuJCR0eXBlb2YpXG4gICAgICAgICkge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gXCJQb3J0YWxcIjtcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OU1VNRVJfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZS5fY29udGV4dC5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Db25zdW1lclwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgIHZhciBpbm5lclR5cGUgPSB0eXBlLnJlbmRlcjtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lO1xuICAgICAgICAgICAgdHlwZSB8fFxuICAgICAgICAgICAgICAoKHR5cGUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgXCJcIiksXG4gICAgICAgICAgICAgICh0eXBlID0gXCJcIiAhPT0gdHlwZSA/IFwiRm9yd2FyZFJlZihcIiArIHR5cGUgKyBcIilcIiA6IFwiRm9yd2FyZFJlZlwiKSk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChpbm5lclR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGwpLFxuICAgICAgICAgICAgICBudWxsICE9PSBpbm5lclR5cGVcbiAgICAgICAgICAgICAgICA/IGlubmVyVHlwZVxuICAgICAgICAgICAgICAgIDogZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgXCJNZW1vXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICBpbm5lclR5cGUgPSB0eXBlLl9wYXlsb2FkO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUoaW5uZXJUeXBlKSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITE7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICEwO1xuICAgICAgfVxuICAgICAgaWYgKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCkge1xuICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSBjb25zb2xlO1xuICAgICAgICB2YXIgSlNDb21waWxlcl90ZW1wX2NvbnN0ID0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LmVycm9yO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwID1cbiAgICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgU3ltYm9sICYmXG4gICAgICAgICAgICBTeW1ib2wudG9TdHJpbmdUYWcgJiZcbiAgICAgICAgICAgIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10pIHx8XG4gICAgICAgICAgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fFxuICAgICAgICAgIFwiT2JqZWN0XCI7XG4gICAgICAgIEpTQ29tcGlsZXJfdGVtcF9jb25zdC5jYWxsKFxuICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCxcbiAgICAgICAgICBcIlRoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4gVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuXCIsXG4gICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRUYXNrTmFtZSh0eXBlKSB7XG4gICAgICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkgcmV0dXJuIFwiPD5cIjtcbiAgICAgIGlmIChcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUgJiZcbiAgICAgICAgbnVsbCAhPT0gdHlwZSAmJlxuICAgICAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEVcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIFwiPC4uLj5cIjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgICByZXR1cm4gbmFtZSA/IFwiPFwiICsgbmFtZSArIFwiPlwiIDogXCI8Li4uPlwiO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICByZXR1cm4gXCI8Li4uPlwiO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRPd25lcigpIHtcbiAgICAgIHZhciBkaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuQTtcbiAgICAgIHJldHVybiBudWxsID09PSBkaXNwYXRjaGVyID8gbnVsbCA6IGRpc3BhdGNoZXIuZ2V0T3duZXIoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVW5rbm93bk93bmVyKCkge1xuICAgICAgcmV0dXJuIEVycm9yKFwicmVhY3Qtc3RhY2stdG9wLWZyYW1lXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgXCJrZXlcIikpIHtcbiAgICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCBcImtleVwiKS5nZXQ7XG4gICAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwICE9PSBjb25maWcua2V5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgICAgIGZ1bmN0aW9uIHdhcm5BYm91dEFjY2Vzc2luZ0tleSgpIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gfHxcbiAgICAgICAgICAoKHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gITApLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgdmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCBwcm9wLiAoaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9zcGVjaWFsLXByb3BzKVwiLFxuICAgICAgICAgICAgZGlzcGxheU5hbWVcbiAgICAgICAgICApKTtcbiAgICAgIH1cbiAgICAgIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9ICEwO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCBcImtleVwiLCB7XG4gICAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZWxlbWVudFJlZkdldHRlcldpdGhEZXByZWNhdGlvbldhcm5pbmcoKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0aGlzLnR5cGUpO1xuICAgICAgZGlkV2FybkFib3V0RWxlbWVudFJlZltjb21wb25lbnROYW1lXSB8fFxuICAgICAgICAoKGRpZFdhcm5BYm91dEVsZW1lbnRSZWZbY29tcG9uZW50TmFtZV0gPSAhMCksXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJBY2Nlc3NpbmcgZWxlbWVudC5yZWYgd2FzIHJlbW92ZWQgaW4gUmVhY3QgMTkuIHJlZiBpcyBub3cgYSByZWd1bGFyIHByb3AuIEl0IHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBKU1ggRWxlbWVudCB0eXBlIGluIGEgZnV0dXJlIHJlbGVhc2UuXCJcbiAgICAgICAgKSk7XG4gICAgICBjb21wb25lbnROYW1lID0gdGhpcy5wcm9wcy5yZWY7XG4gICAgICByZXR1cm4gdm9pZCAwICE9PSBjb21wb25lbnROYW1lID8gY29tcG9uZW50TmFtZSA6IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWN0RWxlbWVudChcbiAgICAgIHR5cGUsXG4gICAgICBrZXksXG4gICAgICBzZWxmLFxuICAgICAgc291cmNlLFxuICAgICAgb3duZXIsXG4gICAgICBwcm9wcyxcbiAgICAgIGRlYnVnU3RhY2ssXG4gICAgICBkZWJ1Z1Rhc2tcbiAgICApIHtcbiAgICAgIHNlbGYgPSBwcm9wcy5yZWY7XG4gICAgICB0eXBlID0ge1xuICAgICAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICBfb3duZXI6IG93bmVyXG4gICAgICB9O1xuICAgICAgbnVsbCAhPT0gKHZvaWQgMCAhPT0gc2VsZiA/IHNlbGYgOiBudWxsKVxuICAgICAgICA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcInJlZlwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgICAgIGdldDogZWxlbWVudFJlZkdldHRlcldpdGhEZXByZWNhdGlvbldhcm5pbmdcbiAgICAgICAgICB9KVxuICAgICAgICA6IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcInJlZlwiLCB7IGVudW1lcmFibGU6ICExLCB2YWx1ZTogbnVsbCB9KTtcbiAgICAgIHR5cGUuX3N0b3JlID0ge307XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZS5fc3RvcmUsIFwidmFsaWRhdGVkXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IDBcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwiX2RlYnVnSW5mb1wiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiBudWxsXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcIl9kZWJ1Z1N0YWNrXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IGRlYnVnU3RhY2tcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwiX2RlYnVnVGFza1wiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiBkZWJ1Z1Rhc2tcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmZyZWV6ZSAmJiAoT2JqZWN0LmZyZWV6ZSh0eXBlLnByb3BzKSwgT2JqZWN0LmZyZWV6ZSh0eXBlKSk7XG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gICAgZnVuY3Rpb24ganN4REVWSW1wbChcbiAgICAgIHR5cGUsXG4gICAgICBjb25maWcsXG4gICAgICBtYXliZUtleSxcbiAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICBzb3VyY2UsXG4gICAgICBzZWxmLFxuICAgICAgZGVidWdTdGFjayxcbiAgICAgIGRlYnVnVGFza1xuICAgICkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gY29uZmlnLmNoaWxkcmVuO1xuICAgICAgaWYgKHZvaWQgMCAhPT0gY2hpbGRyZW4pXG4gICAgICAgIGlmIChpc1N0YXRpY0NoaWxkcmVuKVxuICAgICAgICAgIGlmIChpc0FycmF5SW1wbChjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4gPSAwO1xuICAgICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuIDwgY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuKytcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baXNTdGF0aWNDaGlsZHJlbl0pO1xuICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSAmJiBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiBVc2UgdGhlIEJhYmVsIHRyYW5zZm9ybSBpbnN0ZWFkLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICBlbHNlIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuKTtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgXCJrZXlcIikpIHtcbiAgICAgICAgY2hpbGRyZW4gPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoY29uZmlnKS5maWx0ZXIoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICByZXR1cm4gXCJrZXlcIiAhPT0gaztcbiAgICAgICAgfSk7XG4gICAgICAgIGlzU3RhdGljQ2hpbGRyZW4gPVxuICAgICAgICAgIDAgPCBrZXlzLmxlbmd0aFxuICAgICAgICAgICAgPyBcIntrZXk6IHNvbWVLZXksIFwiICsga2V5cy5qb2luKFwiOiAuLi4sIFwiKSArIFwiOiAuLi59XCJcbiAgICAgICAgICAgIDogXCJ7a2V5OiBzb21lS2V5fVwiO1xuICAgICAgICBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY2hpbGRyZW4gKyBpc1N0YXRpY0NoaWxkcmVuXSB8fFxuICAgICAgICAgICgoa2V5cyA9XG4gICAgICAgICAgICAwIDwga2V5cy5sZW5ndGggPyBcIntcIiArIGtleXMuam9pbihcIjogLi4uLCBcIikgKyBcIjogLi4ufVwiIDogXCJ7fVwiKSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgJ0EgcHJvcHMgb2JqZWN0IGNvbnRhaW5pbmcgYSBcImtleVwiIHByb3AgaXMgYmVpbmcgc3ByZWFkIGludG8gSlNYOlxcbiAgbGV0IHByb3BzID0gJXM7XFxuICA8JXMgey4uLnByb3BzfSAvPlxcblJlYWN0IGtleXMgbXVzdCBiZSBwYXNzZWQgZGlyZWN0bHkgdG8gSlNYIHdpdGhvdXQgdXNpbmcgc3ByZWFkOlxcbiAgbGV0IHByb3BzID0gJXM7XFxuICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+JyxcbiAgICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgICAgIGtleXMsXG4gICAgICAgICAgICBjaGlsZHJlblxuICAgICAgICAgICksXG4gICAgICAgICAgKGRpZFdhcm5BYm91dEtleVNwcmVhZFtjaGlsZHJlbiArIGlzU3RhdGljQ2hpbGRyZW5dID0gITApKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgICAgIHZvaWQgMCAhPT0gbWF5YmVLZXkgJiZcbiAgICAgICAgKGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpLCAoY2hpbGRyZW4gPSBcIlwiICsgbWF5YmVLZXkpKTtcbiAgICAgIGhhc1ZhbGlkS2V5KGNvbmZpZykgJiZcbiAgICAgICAgKGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSksIChjaGlsZHJlbiA9IFwiXCIgKyBjb25maWcua2V5KSk7XG4gICAgICBpZiAoXCJrZXlcIiBpbiBjb25maWcpIHtcbiAgICAgICAgbWF5YmVLZXkgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gY29uZmlnKVxuICAgICAgICAgIFwia2V5XCIgIT09IHByb3BOYW1lICYmIChtYXliZUtleVtwcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdKTtcbiAgICAgIH0gZWxzZSBtYXliZUtleSA9IGNvbmZpZztcbiAgICAgIGNoaWxkcmVuICYmXG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKFxuICAgICAgICAgIG1heWJlS2V5LFxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGVcbiAgICAgICAgICAgID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgXCJVbmtub3duXCJcbiAgICAgICAgICAgIDogdHlwZVxuICAgICAgICApO1xuICAgICAgcmV0dXJuIFJlYWN0RWxlbWVudChcbiAgICAgICAgdHlwZSxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIHNlbGYsXG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgZ2V0T3duZXIoKSxcbiAgICAgICAgbWF5YmVLZXksXG4gICAgICAgIGRlYnVnU3RhY2ssXG4gICAgICAgIGRlYnVnVGFza1xuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSkge1xuICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIG5vZGUgJiZcbiAgICAgICAgbnVsbCAhPT0gbm9kZSAmJlxuICAgICAgICBub2RlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUgJiZcbiAgICAgICAgbm9kZS5fc3RvcmUgJiZcbiAgICAgICAgKG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IDEpO1xuICAgIH1cbiAgICB2YXIgUmVhY3QgPSByZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0XCIpLFxuICAgICAgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnRyYW5zaXRpb25hbC5lbGVtZW50XCIpLFxuICAgICAgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpLFxuICAgICAgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSxcbiAgICAgIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIiksXG4gICAgICBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpLFxuICAgICAgUkVBQ1RfQ09OU1VNRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb25zdW1lclwiKSxcbiAgICAgIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpLFxuICAgICAgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKSxcbiAgICAgIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIiksXG4gICAgICBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VfbGlzdFwiKSxcbiAgICAgIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpLFxuICAgICAgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmxhenlcIiksXG4gICAgICBSRUFDVF9BQ1RJVklUWV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmFjdGl2aXR5XCIpLFxuICAgICAgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCIpLFxuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPVxuICAgICAgICBSZWFjdC5fX0NMSUVOVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUsXG4gICAgICBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG4gICAgICBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXksXG4gICAgICBjcmVhdGVUYXNrID0gY29uc29sZS5jcmVhdGVUYXNrXG4gICAgICAgID8gY29uc29sZS5jcmVhdGVUYXNrXG4gICAgICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfTtcbiAgICBSZWFjdCA9IHtcbiAgICAgIHJlYWN0X3N0YWNrX2JvdHRvbV9mcmFtZTogZnVuY3Rpb24gKGNhbGxTdGFja0ZvckVycm9yKSB7XG4gICAgICAgIHJldHVybiBjYWxsU3RhY2tGb3JFcnJvcigpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xuICAgIHZhciBkaWRXYXJuQWJvdXRFbGVtZW50UmVmID0ge307XG4gICAgdmFyIHVua25vd25Pd25lckRlYnVnU3RhY2sgPSBSZWFjdC5yZWFjdF9zdGFja19ib3R0b21fZnJhbWUuYmluZChcbiAgICAgIFJlYWN0LFxuICAgICAgVW5rbm93bk93bmVyXG4gICAgKSgpO1xuICAgIHZhciB1bmtub3duT3duZXJEZWJ1Z1Rhc2sgPSBjcmVhdGVUYXNrKGdldFRhc2tOYW1lKFVua25vd25Pd25lcikpO1xuICAgIHZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbiAgICBleHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbiAgICBleHBvcnRzLmpzeCA9IGZ1bmN0aW9uICh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBzb3VyY2UsIHNlbGYpIHtcbiAgICAgIHZhciB0cmFja0FjdHVhbE93bmVyID1cbiAgICAgICAgMWU0ID4gUmVhY3RTaGFyZWRJbnRlcm5hbHMucmVjZW50bHlDcmVhdGVkT3duZXJTdGFja3MrKztcbiAgICAgIHJldHVybiBqc3hERVZJbXBsKFxuICAgICAgICB0eXBlLFxuICAgICAgICBjb25maWcsXG4gICAgICAgIG1heWJlS2V5LFxuICAgICAgICAhMSxcbiAgICAgICAgc291cmNlLFxuICAgICAgICBzZWxmLFxuICAgICAgICB0cmFja0FjdHVhbE93bmVyXG4gICAgICAgICAgPyBFcnJvcihcInJlYWN0LXN0YWNrLXRvcC1mcmFtZVwiKVxuICAgICAgICAgIDogdW5rbm93bk93bmVyRGVidWdTdGFjayxcbiAgICAgICAgdHJhY2tBY3R1YWxPd25lciA/IGNyZWF0ZVRhc2soZ2V0VGFza05hbWUodHlwZSkpIDogdW5rbm93bk93bmVyRGVidWdUYXNrXG4gICAgICApO1xuICAgIH07XG4gICAgZXhwb3J0cy5qc3hzID0gZnVuY3Rpb24gKHR5cGUsIGNvbmZpZywgbWF5YmVLZXksIHNvdXJjZSwgc2VsZikge1xuICAgICAgdmFyIHRyYWNrQWN0dWFsT3duZXIgPVxuICAgICAgICAxZTQgPiBSZWFjdFNoYXJlZEludGVybmFscy5yZWNlbnRseUNyZWF0ZWRPd25lclN0YWNrcysrO1xuICAgICAgcmV0dXJuIGpzeERFVkltcGwoXG4gICAgICAgIHR5cGUsXG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgbWF5YmVLZXksXG4gICAgICAgICEwLFxuICAgICAgICBzb3VyY2UsXG4gICAgICAgIHNlbGYsXG4gICAgICAgIHRyYWNrQWN0dWFsT3duZXJcbiAgICAgICAgICA/IEVycm9yKFwicmVhY3Qtc3RhY2stdG9wLWZyYW1lXCIpXG4gICAgICAgICAgOiB1bmtub3duT3duZXJEZWJ1Z1N0YWNrLFxuICAgICAgICB0cmFja0FjdHVhbE93bmVyID8gY3JlYXRlVGFzayhnZXRUYXNrTmFtZSh0eXBlKSkgOiB1bmtub3duT3duZXJEZWJ1Z1Rhc2tcbiAgICAgICk7XG4gICAgfTtcbiAgfSkoKTtcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Q0FRQyxHQUdnQjtBQURqQjtBQUNBLG9FQUNFLEFBQUM7SUFDQyxTQUFTLHlCQUF5QixJQUFJO1FBQ3BDLElBQUksUUFBUSxNQUFNLE9BQU87UUFDekIsSUFBSSxlQUFlLE9BQU8sTUFDeEIsT0FBTyxLQUFLLFFBQVEsS0FBSyx5QkFDckIsT0FDQSxLQUFLLFdBQVcsSUFBSSxLQUFLLElBQUksSUFBSTtRQUN2QyxJQUFJLGFBQWEsT0FBTyxNQUFNLE9BQU87UUFDckMsT0FBUTtZQUNOLEtBQUs7Z0JBQ0gsT0FBTztZQUNULEtBQUs7Z0JBQ0gsT0FBTztZQUNULEtBQUs7Z0JBQ0gsT0FBTztZQUNULEtBQUs7Z0JBQ0gsT0FBTztZQUNULEtBQUs7Z0JBQ0gsT0FBTztZQUNULEtBQUs7Z0JBQ0gsT0FBTztRQUNYO1FBQ0EsSUFBSSxhQUFhLE9BQU8sTUFDdEIsT0FDRyxhQUFhLE9BQU8sS0FBSyxHQUFHLElBQzNCLFFBQVEsS0FBSyxDQUNYLHNIQUVKLEtBQUssUUFBUTtZQUViLEtBQUs7Z0JBQ0gsT0FBTztZQUNULEtBQUs7Z0JBQ0gsT0FBTyxLQUFLLFdBQVcsSUFBSTtZQUM3QixLQUFLO2dCQUNILE9BQU8sQ0FBQyxLQUFLLFFBQVEsQ0FBQyxXQUFXLElBQUksU0FBUyxJQUFJO1lBQ3BELEtBQUs7Z0JBQ0gsSUFBSSxZQUFZLEtBQUssTUFBTTtnQkFDM0IsT0FBTyxLQUFLLFdBQVc7Z0JBQ3ZCLFFBQ0UsQ0FBQyxBQUFDLE9BQU8sVUFBVSxXQUFXLElBQUksVUFBVSxJQUFJLElBQUksSUFDbkQsT0FBTyxPQUFPLE9BQU8sZ0JBQWdCLE9BQU8sTUFBTSxZQUFhO2dCQUNsRSxPQUFPO1lBQ1QsS0FBSztnQkFDSCxPQUNFLEFBQUMsWUFBWSxLQUFLLFdBQVcsSUFBSSxNQUNqQyxTQUFTLFlBQ0wsWUFDQSx5QkFBeUIsS0FBSyxJQUFJLEtBQUs7WUFFL0MsS0FBSztnQkFDSCxZQUFZLEtBQUssUUFBUTtnQkFDekIsT0FBTyxLQUFLLEtBQUs7Z0JBQ2pCLElBQUk7b0JBQ0YsT0FBTyx5QkFBeUIsS0FBSztnQkFDdkMsRUFBRSxPQUFPLEdBQUcsQ0FBQztRQUNqQjtRQUNGLE9BQU87SUFDVDtJQUNBLFNBQVMsbUJBQW1CLEtBQUs7UUFDL0IsT0FBTyxLQUFLO0lBQ2Q7SUFDQSxTQUFTLHVCQUF1QixLQUFLO1FBQ25DLElBQUk7WUFDRixtQkFBbUI7WUFDbkIsSUFBSSwyQkFBMkIsQ0FBQztRQUNsQyxFQUFFLE9BQU8sR0FBRztZQUNWLDJCQUEyQixDQUFDO1FBQzlCO1FBQ0EsSUFBSSwwQkFBMEI7WUFDNUIsMkJBQTJCO1lBQzNCLElBQUksd0JBQXdCLHlCQUF5QixLQUFLO1lBQzFELElBQUksb0NBQ0YsQUFBQyxlQUFlLE9BQU8sVUFDckIsT0FBTyxXQUFXLElBQ2xCLEtBQUssQ0FBQyxPQUFPLFdBQVcsQ0FBQyxJQUMzQixNQUFNLFdBQVcsQ0FBQyxJQUFJLElBQ3RCO1lBQ0Ysc0JBQXNCLElBQUksQ0FDeEIsMEJBQ0EsNEdBQ0E7WUFFRixPQUFPLG1CQUFtQjtRQUM1QjtJQUNGO0lBQ0EsU0FBUyxZQUFZLElBQUk7UUFDdkIsSUFBSSxTQUFTLHFCQUFxQixPQUFPO1FBQ3pDLElBQ0UsYUFBYSxPQUFPLFFBQ3BCLFNBQVMsUUFDVCxLQUFLLFFBQVEsS0FBSyxpQkFFbEIsT0FBTztRQUNULElBQUk7WUFDRixJQUFJLE9BQU8seUJBQXlCO1lBQ3BDLE9BQU8sT0FBTyxNQUFNLE9BQU8sTUFBTTtRQUNuQyxFQUFFLE9BQU8sR0FBRztZQUNWLE9BQU87UUFDVDtJQUNGO0lBQ0EsU0FBUztRQUNQLElBQUksYUFBYSxxQkFBcUIsQ0FBQztRQUN2QyxPQUFPLFNBQVMsYUFBYSxPQUFPLFdBQVcsUUFBUTtJQUN6RDtJQUNBLFNBQVM7UUFDUCxPQUFPLE1BQU07SUFDZjtJQUNBLFNBQVMsWUFBWSxNQUFNO1FBQ3pCLElBQUksZUFBZSxJQUFJLENBQUMsUUFBUSxRQUFRO1lBQ3RDLElBQUksU0FBUyxPQUFPLHdCQUF3QixDQUFDLFFBQVEsT0FBTyxHQUFHO1lBQy9ELElBQUksVUFBVSxPQUFPLGNBQWMsRUFBRSxPQUFPLENBQUM7UUFDL0M7UUFDQSxPQUFPLEtBQUssTUFBTSxPQUFPLEdBQUc7SUFDOUI7SUFDQSxTQUFTLDJCQUEyQixLQUFLLEVBQUUsV0FBVztRQUNwRCxTQUFTO1lBQ1AsOEJBQ0UsQ0FBQyxBQUFDLDZCQUE2QixDQUFDLEdBQ2hDLFFBQVEsS0FBSyxDQUNYLDJPQUNBLFlBQ0Q7UUFDTDtRQUNBLHNCQUFzQixjQUFjLEdBQUcsQ0FBQztRQUN4QyxPQUFPLGNBQWMsQ0FBQyxPQUFPLE9BQU87WUFDbEMsS0FBSztZQUNMLGNBQWMsQ0FBQztRQUNqQjtJQUNGO0lBQ0EsU0FBUztRQUNQLElBQUksZ0JBQWdCLHlCQUF5QixJQUFJLENBQUMsSUFBSTtRQUN0RCxzQkFBc0IsQ0FBQyxjQUFjLElBQ25DLENBQUMsQUFBQyxzQkFBc0IsQ0FBQyxjQUFjLEdBQUcsQ0FBQyxHQUMzQyxRQUFRLEtBQUssQ0FDWCw4SUFDRDtRQUNILGdCQUFnQixJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUc7UUFDOUIsT0FBTyxLQUFLLE1BQU0sZ0JBQWdCLGdCQUFnQjtJQUNwRDtJQUNBLFNBQVMsYUFDUCxJQUFJLEVBQ0osR0FBRyxFQUNILElBQUksRUFDSixNQUFNLEVBQ04sS0FBSyxFQUNMLEtBQUssRUFDTCxVQUFVLEVBQ1YsU0FBUztRQUVULE9BQU8sTUFBTSxHQUFHO1FBQ2hCLE9BQU87WUFDTCxVQUFVO1lBQ1YsTUFBTTtZQUNOLEtBQUs7WUFDTCxPQUFPO1lBQ1AsUUFBUTtRQUNWO1FBQ0EsU0FBUyxDQUFDLEtBQUssTUFBTSxPQUFPLE9BQU8sSUFBSSxJQUNuQyxPQUFPLGNBQWMsQ0FBQyxNQUFNLE9BQU87WUFDakMsWUFBWSxDQUFDO1lBQ2IsS0FBSztRQUNQLEtBQ0EsT0FBTyxjQUFjLENBQUMsTUFBTSxPQUFPO1lBQUUsWUFBWSxDQUFDO1lBQUcsT0FBTztRQUFLO1FBQ3JFLEtBQUssTUFBTSxHQUFHLENBQUM7UUFDZixPQUFPLGNBQWMsQ0FBQyxLQUFLLE1BQU0sRUFBRSxhQUFhO1lBQzlDLGNBQWMsQ0FBQztZQUNmLFlBQVksQ0FBQztZQUNiLFVBQVUsQ0FBQztZQUNYLE9BQU87UUFDVDtRQUNBLE9BQU8sY0FBYyxDQUFDLE1BQU0sY0FBYztZQUN4QyxjQUFjLENBQUM7WUFDZixZQUFZLENBQUM7WUFDYixVQUFVLENBQUM7WUFDWCxPQUFPO1FBQ1Q7UUFDQSxPQUFPLGNBQWMsQ0FBQyxNQUFNLGVBQWU7WUFDekMsY0FBYyxDQUFDO1lBQ2YsWUFBWSxDQUFDO1lBQ2IsVUFBVSxDQUFDO1lBQ1gsT0FBTztRQUNUO1FBQ0EsT0FBTyxjQUFjLENBQUMsTUFBTSxjQUFjO1lBQ3hDLGNBQWMsQ0FBQztZQUNmLFlBQVksQ0FBQztZQUNiLFVBQVUsQ0FBQztZQUNYLE9BQU87UUFDVDtRQUNBLE9BQU8sTUFBTSxJQUFJLENBQUMsT0FBTyxNQUFNLENBQUMsS0FBSyxLQUFLLEdBQUcsT0FBTyxNQUFNLENBQUMsS0FBSztRQUNoRSxPQUFPO0lBQ1Q7SUFDQSxTQUFTLFdBQ1AsSUFBSSxFQUNKLE1BQU0sRUFDTixRQUFRLEVBQ1IsZ0JBQWdCLEVBQ2hCLE1BQU0sRUFDTixJQUFJLEVBQ0osVUFBVSxFQUNWLFNBQVM7UUFFVCxJQUFJLFdBQVcsT0FBTyxRQUFRO1FBQzlCLElBQUksS0FBSyxNQUFNLFVBQ2IsSUFBSSxrQkFDRixJQUFJLFlBQVksV0FBVztZQUN6QixJQUNFLG1CQUFtQixHQUNuQixtQkFBbUIsU0FBUyxNQUFNLEVBQ2xDLG1CQUVBLGtCQUFrQixRQUFRLENBQUMsaUJBQWlCO1lBQzlDLE9BQU8sTUFBTSxJQUFJLE9BQU8sTUFBTSxDQUFDO1FBQ2pDLE9BQ0UsUUFBUSxLQUFLLENBQ1g7YUFFRCxrQkFBa0I7UUFDekIsSUFBSSxlQUFlLElBQUksQ0FBQyxRQUFRLFFBQVE7WUFDdEMsV0FBVyx5QkFBeUI7WUFDcEMsSUFBSSxPQUFPLE9BQU8sSUFBSSxDQUFDLFFBQVEsTUFBTSxDQUFDLFNBQVUsQ0FBQztnQkFDL0MsT0FBTyxVQUFVO1lBQ25CO1lBQ0EsbUJBQ0UsSUFBSSxLQUFLLE1BQU0sR0FDWCxvQkFBb0IsS0FBSyxJQUFJLENBQUMsYUFBYSxXQUMzQztZQUNOLHFCQUFxQixDQUFDLFdBQVcsaUJBQWlCLElBQ2hELENBQUMsQUFBQyxPQUNBLElBQUksS0FBSyxNQUFNLEdBQUcsTUFBTSxLQUFLLElBQUksQ0FBQyxhQUFhLFdBQVcsTUFDNUQsUUFBUSxLQUFLLENBQ1gsbU9BQ0Esa0JBQ0EsVUFDQSxNQUNBLFdBRUQscUJBQXFCLENBQUMsV0FBVyxpQkFBaUIsR0FBRyxDQUFDLENBQUU7UUFDN0Q7UUFDQSxXQUFXO1FBQ1gsS0FBSyxNQUFNLFlBQ1QsQ0FBQyx1QkFBdUIsV0FBWSxXQUFXLEtBQUssUUFBUztRQUMvRCxZQUFZLFdBQ1YsQ0FBQyx1QkFBdUIsT0FBTyxHQUFHLEdBQUksV0FBVyxLQUFLLE9BQU8sR0FBRyxBQUFDO1FBQ25FLElBQUksU0FBUyxRQUFRO1lBQ25CLFdBQVcsQ0FBQztZQUNaLElBQUssSUFBSSxZQUFZLE9BQ25CLFVBQVUsWUFBWSxDQUFDLFFBQVEsQ0FBQyxTQUFTLEdBQUcsTUFBTSxDQUFDLFNBQVM7UUFDaEUsT0FBTyxXQUFXO1FBQ2xCLFlBQ0UsMkJBQ0UsVUFDQSxlQUFlLE9BQU8sT0FDbEIsS0FBSyxXQUFXLElBQUksS0FBSyxJQUFJLElBQUksWUFDakM7UUFFUixPQUFPLGFBQ0wsTUFDQSxVQUNBLE1BQ0EsUUFDQSxZQUNBLFVBQ0EsWUFDQTtJQUVKO0lBQ0EsU0FBUyxrQkFBa0IsSUFBSTtRQUM3QixhQUFhLE9BQU8sUUFDbEIsU0FBUyxRQUNULEtBQUssUUFBUSxLQUFLLHNCQUNsQixLQUFLLE1BQU0sSUFDWCxDQUFDLEtBQUssTUFBTSxDQUFDLFNBQVMsR0FBRyxDQUFDO0lBQzlCO0lBQ0EsSUFBSSx1SEFDRixxQkFBcUIsT0FBTyxHQUFHLENBQUMsK0JBQ2hDLG9CQUFvQixPQUFPLEdBQUcsQ0FBQyxpQkFDL0Isc0JBQXNCLE9BQU8sR0FBRyxDQUFDLG1CQUNqQyx5QkFBeUIsT0FBTyxHQUFHLENBQUMsc0JBQ3BDLHNCQUFzQixPQUFPLEdBQUcsQ0FBQyxtQkFDakMsc0JBQXNCLE9BQU8sR0FBRyxDQUFDLG1CQUNqQyxxQkFBcUIsT0FBTyxHQUFHLENBQUMsa0JBQ2hDLHlCQUF5QixPQUFPLEdBQUcsQ0FBQyxzQkFDcEMsc0JBQXNCLE9BQU8sR0FBRyxDQUFDLG1CQUNqQywyQkFBMkIsT0FBTyxHQUFHLENBQUMsd0JBQ3RDLGtCQUFrQixPQUFPLEdBQUcsQ0FBQyxlQUM3QixrQkFBa0IsT0FBTyxHQUFHLENBQUMsZUFDN0Isc0JBQXNCLE9BQU8sR0FBRyxDQUFDLG1CQUNqQyx5QkFBeUIsT0FBTyxHQUFHLENBQUMsMkJBQ3BDLHVCQUNFLE1BQU0sK0RBQStELEVBQ3ZFLGlCQUFpQixPQUFPLFNBQVMsQ0FBQyxjQUFjLEVBQ2hELGNBQWMsTUFBTSxPQUFPLEVBQzNCLGFBQWEsUUFBUSxVQUFVLEdBQzNCLFFBQVEsVUFBVSxHQUNsQjtRQUNFLE9BQU87SUFDVDtJQUNOLFFBQVE7UUFDTiwwQkFBMEIsU0FBVSxpQkFBaUI7WUFDbkQsT0FBTztRQUNUO0lBQ0Y7SUFDQSxJQUFJO0lBQ0osSUFBSSx5QkFBeUIsQ0FBQztJQUM5QixJQUFJLHlCQUF5QixNQUFNLHdCQUF3QixDQUFDLElBQUksQ0FDOUQsT0FDQTtJQUVGLElBQUksd0JBQXdCLFdBQVcsWUFBWTtJQUNuRCxJQUFJLHdCQUF3QixDQUFDO0lBQzdCLFFBQVEsUUFBUSxHQUFHO0lBQ25CLFFBQVEsR0FBRyxHQUFHLFNBQVUsSUFBSSxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUUsTUFBTSxFQUFFLElBQUk7UUFDMUQsSUFBSSxtQkFDRixNQUFNLHFCQUFxQiwwQkFBMEI7UUFDdkQsT0FBTyxXQUNMLE1BQ0EsUUFDQSxVQUNBLENBQUMsR0FDRCxRQUNBLE1BQ0EsbUJBQ0ksTUFBTSwyQkFDTix3QkFDSixtQkFBbUIsV0FBVyxZQUFZLFNBQVM7SUFFdkQ7SUFDQSxRQUFRLElBQUksR0FBRyxTQUFVLElBQUksRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFFLE1BQU0sRUFBRSxJQUFJO1FBQzNELElBQUksbUJBQ0YsTUFBTSxxQkFBcUIsMEJBQTBCO1FBQ3ZELE9BQU8sV0FDTCxNQUNBLFFBQ0EsVUFDQSxDQUFDLEdBQ0QsUUFDQSxNQUNBLG1CQUNJLE1BQU0sMkJBQ04sd0JBQ0osbUJBQW1CLFdBQVcsWUFBWSxTQUFTO0lBRXZEO0FBQ0YiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTk0MiwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LXJ1bnRpbWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1ydW50aW1lLnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFFSTtBQUZKO0FBRUE7O0tBRU87SUFDTCxPQUFPLE9BQU87QUFDaEIiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTk1NCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvc2FmZS1zdGFibGUtc3RyaW5naWZ5L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe1widXNlIHN0cmljdFwiO3ZhciBlPXs4Nzk6ZnVuY3Rpb24oZSx0KXtjb25zdHtoYXNPd25Qcm9wZXJ0eTpufT1PYmplY3QucHJvdG90eXBlO2NvbnN0IHI9Y29uZmlndXJlKCk7ci5jb25maWd1cmU9Y29uZmlndXJlO3Iuc3RyaW5naWZ5PXI7ci5kZWZhdWx0PXI7dC5zdHJpbmdpZnk9cjt0LmNvbmZpZ3VyZT1jb25maWd1cmU7ZS5leHBvcnRzPXI7Y29uc3QgaT0vW1xcdTAwMDAtXFx1MDAxZlxcdTAwMjJcXHUwMDVjXFx1ZDgwMC1cXHVkZmZmXS87ZnVuY3Rpb24gc3RyRXNjYXBlKGUpe2lmKGUubGVuZ3RoPDVlMyYmIWkudGVzdChlKSl7cmV0dXJuYFwiJHtlfVwiYH1yZXR1cm4gSlNPTi5zdHJpbmdpZnkoZSl9ZnVuY3Rpb24gc29ydChlLHQpe2lmKGUubGVuZ3RoPjIwMHx8dCl7cmV0dXJuIGUuc29ydCh0KX1mb3IobGV0IHQ9MTt0PGUubGVuZ3RoO3QrKyl7Y29uc3Qgbj1lW3RdO2xldCByPXQ7d2hpbGUociE9PTAmJmVbci0xXT5uKXtlW3JdPWVbci0xXTtyLS19ZVtyXT1ufXJldHVybiBlfWNvbnN0IGY9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPYmplY3QuZ2V0UHJvdG90eXBlT2YoT2JqZWN0LmdldFByb3RvdHlwZU9mKG5ldyBJbnQ4QXJyYXkpKSxTeW1ib2wudG9TdHJpbmdUYWcpLmdldDtmdW5jdGlvbiBpc1R5cGVkQXJyYXlXaXRoRW50cmllcyhlKXtyZXR1cm4gZi5jYWxsKGUpIT09dW5kZWZpbmVkJiZlLmxlbmd0aCE9PTB9ZnVuY3Rpb24gc3RyaW5naWZ5VHlwZWRBcnJheShlLHQsbil7aWYoZS5sZW5ndGg8bil7bj1lLmxlbmd0aH1jb25zdCByPXQ9PT1cIixcIj9cIlwiOlwiIFwiO2xldCBpPWBcIjBcIjoke3J9JHtlWzBdfWA7Zm9yKGxldCBmPTE7ZjxuO2YrKyl7aSs9YCR7dH1cIiR7Zn1cIjoke3J9JHtlW2ZdfWB9cmV0dXJuIGl9ZnVuY3Rpb24gZ2V0Q2lyY3VsYXJWYWx1ZU9wdGlvbihlKXtpZihuLmNhbGwoZSxcImNpcmN1bGFyVmFsdWVcIikpe2NvbnN0IHQ9ZS5jaXJjdWxhclZhbHVlO2lmKHR5cGVvZiB0PT09XCJzdHJpbmdcIil7cmV0dXJuYFwiJHt0fVwiYH1pZih0PT1udWxsKXtyZXR1cm4gdH1pZih0PT09RXJyb3J8fHQ9PT1UeXBlRXJyb3Ipe3JldHVybnt0b1N0cmluZygpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJDb252ZXJ0aW5nIGNpcmN1bGFyIHN0cnVjdHVyZSB0byBKU09OXCIpfX19dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwiY2lyY3VsYXJWYWx1ZVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcgb3IgdGhlIHZhbHVlIG51bGwgb3IgdW5kZWZpbmVkJyl9cmV0dXJuJ1wiW0NpcmN1bGFyXVwiJ31mdW5jdGlvbiBnZXREZXRlcm1pbmlzdGljT3B0aW9uKGUpe2xldCB0O2lmKG4uY2FsbChlLFwiZGV0ZXJtaW5pc3RpY1wiKSl7dD1lLmRldGVybWluaXN0aWM7aWYodHlwZW9mIHQhPT1cImJvb2xlYW5cIiYmdHlwZW9mIHQhPT1cImZ1bmN0aW9uXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImRldGVybWluaXN0aWNcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgYm9vbGVhbiBvciBjb21wYXJhdG9yIGZ1bmN0aW9uJyl9fXJldHVybiB0PT09dW5kZWZpbmVkP3RydWU6dH1mdW5jdGlvbiBnZXRCb29sZWFuT3B0aW9uKGUsdCl7bGV0IHI7aWYobi5jYWxsKGUsdCkpe3I9ZVt0XTtpZih0eXBlb2YgciE9PVwiYm9vbGVhblwiKXt0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCIke3R9XCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIGJvb2xlYW5gKX19cmV0dXJuIHI9PT11bmRlZmluZWQ/dHJ1ZTpyfWZ1bmN0aW9uIGdldFBvc2l0aXZlSW50ZWdlck9wdGlvbihlLHQpe2xldCByO2lmKG4uY2FsbChlLHQpKXtyPWVbdF07aWYodHlwZW9mIHIhPT1cIm51bWJlclwiKXt0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCIke3R9XCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlcmApfWlmKCFOdW1iZXIuaXNJbnRlZ2VyKHIpKXt0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCIke3R9XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBpbnRlZ2VyYCl9aWYocjwxKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVGhlIFwiJHt0fVwiIGFyZ3VtZW50IG11c3QgYmUgPj0gMWApfX1yZXR1cm4gcj09PXVuZGVmaW5lZD9JbmZpbml0eTpyfWZ1bmN0aW9uIGdldEl0ZW1Db3VudChlKXtpZihlPT09MSl7cmV0dXJuXCIxIGl0ZW1cIn1yZXR1cm5gJHtlfSBpdGVtc2B9ZnVuY3Rpb24gZ2V0VW5pcXVlUmVwbGFjZXJTZXQoZSl7Y29uc3QgdD1uZXcgU2V0O2Zvcihjb25zdCBuIG9mIGUpe2lmKHR5cGVvZiBuPT09XCJzdHJpbmdcInx8dHlwZW9mIG49PT1cIm51bWJlclwiKXt0LmFkZChTdHJpbmcobikpfX1yZXR1cm4gdH1mdW5jdGlvbiBnZXRTdHJpY3RPcHRpb24oZSl7aWYobi5jYWxsKGUsXCJzdHJpY3RcIikpe2NvbnN0IHQ9ZS5zdHJpY3Q7aWYodHlwZW9mIHQhPT1cImJvb2xlYW5cIil7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwic3RyaWN0XCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIGJvb2xlYW4nKX1pZih0KXtyZXR1cm4gZT0+e2xldCB0PWBPYmplY3QgY2FuIG5vdCBzYWZlbHkgYmUgc3RyaW5naWZpZWQuIFJlY2VpdmVkIHR5cGUgJHt0eXBlb2YgZX1gO2lmKHR5cGVvZiBlIT09XCJmdW5jdGlvblwiKXQrPWAgKCR7ZS50b1N0cmluZygpfSlgO3Rocm93IG5ldyBFcnJvcih0KX19fX1mdW5jdGlvbiBjb25maWd1cmUoZSl7ZT17Li4uZX07Y29uc3QgdD1nZXRTdHJpY3RPcHRpb24oZSk7aWYodCl7aWYoZS5iaWdpbnQ9PT11bmRlZmluZWQpe2UuYmlnaW50PWZhbHNlfWlmKCEoXCJjaXJjdWxhclZhbHVlXCJpbiBlKSl7ZS5jaXJjdWxhclZhbHVlPUVycm9yfX1jb25zdCBuPWdldENpcmN1bGFyVmFsdWVPcHRpb24oZSk7Y29uc3Qgcj1nZXRCb29sZWFuT3B0aW9uKGUsXCJiaWdpbnRcIik7Y29uc3QgaT1nZXREZXRlcm1pbmlzdGljT3B0aW9uKGUpO2NvbnN0IGY9dHlwZW9mIGk9PT1cImZ1bmN0aW9uXCI/aTp1bmRlZmluZWQ7Y29uc3QgdT1nZXRQb3NpdGl2ZUludGVnZXJPcHRpb24oZSxcIm1heGltdW1EZXB0aFwiKTtjb25zdCBvPWdldFBvc2l0aXZlSW50ZWdlck9wdGlvbihlLFwibWF4aW11bUJyZWFkdGhcIik7ZnVuY3Rpb24gc3RyaW5naWZ5Rm5SZXBsYWNlcihlLHMsbCxjLGEsZyl7bGV0IHA9c1tlXTtpZih0eXBlb2YgcD09PVwib2JqZWN0XCImJnAhPT1udWxsJiZ0eXBlb2YgcC50b0pTT049PT1cImZ1bmN0aW9uXCIpe3A9cC50b0pTT04oZSl9cD1jLmNhbGwocyxlLHApO3N3aXRjaCh0eXBlb2YgcCl7Y2FzZVwic3RyaW5nXCI6cmV0dXJuIHN0ckVzY2FwZShwKTtjYXNlXCJvYmplY3RcIjp7aWYocD09PW51bGwpe3JldHVyblwibnVsbFwifWlmKGwuaW5kZXhPZihwKSE9PS0xKXtyZXR1cm4gbn1sZXQgZT1cIlwiO2xldCB0PVwiLFwiO2NvbnN0IHI9ZztpZihBcnJheS5pc0FycmF5KHApKXtpZihwLmxlbmd0aD09PTApe3JldHVyblwiW11cIn1pZih1PGwubGVuZ3RoKzEpe3JldHVybidcIltBcnJheV1cIid9bC5wdXNoKHApO2lmKGEhPT1cIlwiKXtnKz1hO2UrPWBcXG4ke2d9YDt0PWAsXFxuJHtnfWB9Y29uc3Qgbj1NYXRoLm1pbihwLmxlbmd0aCxvKTtsZXQgaT0wO2Zvcig7aTxuLTE7aSsrKXtjb25zdCBuPXN0cmluZ2lmeUZuUmVwbGFjZXIoU3RyaW5nKGkpLHAsbCxjLGEsZyk7ZSs9biE9PXVuZGVmaW5lZD9uOlwibnVsbFwiO2UrPXR9Y29uc3QgZj1zdHJpbmdpZnlGblJlcGxhY2VyKFN0cmluZyhpKSxwLGwsYyxhLGcpO2UrPWYhPT11bmRlZmluZWQ/ZjpcIm51bGxcIjtpZihwLmxlbmd0aC0xPm8pe2NvbnN0IG49cC5sZW5ndGgtby0xO2UrPWAke3R9XCIuLi4gJHtnZXRJdGVtQ291bnQobil9IG5vdCBzdHJpbmdpZmllZFwiYH1pZihhIT09XCJcIil7ZSs9YFxcbiR7cn1gfWwucG9wKCk7cmV0dXJuYFske2V9XWB9bGV0IHM9T2JqZWN0LmtleXMocCk7Y29uc3QgeT1zLmxlbmd0aDtpZih5PT09MCl7cmV0dXJuXCJ7fVwifWlmKHU8bC5sZW5ndGgrMSl7cmV0dXJuJ1wiW09iamVjdF1cIid9bGV0IGQ9XCJcIjtsZXQgaD1cIlwiO2lmKGEhPT1cIlwiKXtnKz1hO3Q9YCxcXG4ke2d9YDtkPVwiIFwifWNvbnN0ICQ9TWF0aC5taW4oeSxvKTtpZihpJiYhaXNUeXBlZEFycmF5V2l0aEVudHJpZXMocCkpe3M9c29ydChzLGYpfWwucHVzaChwKTtmb3IobGV0IG49MDtuPCQ7bisrKXtjb25zdCByPXNbbl07Y29uc3QgaT1zdHJpbmdpZnlGblJlcGxhY2VyKHIscCxsLGMsYSxnKTtpZihpIT09dW5kZWZpbmVkKXtlKz1gJHtofSR7c3RyRXNjYXBlKHIpfToke2R9JHtpfWA7aD10fX1pZih5Pm8pe2NvbnN0IG49eS1vO2UrPWAke2h9XCIuLi5cIjoke2R9XCIke2dldEl0ZW1Db3VudChuKX0gbm90IHN0cmluZ2lmaWVkXCJgO2g9dH1pZihhIT09XCJcIiYmaC5sZW5ndGg+MSl7ZT1gXFxuJHtnfSR7ZX1cXG4ke3J9YH1sLnBvcCgpO3JldHVybmB7JHtlfX1gfWNhc2VcIm51bWJlclwiOnJldHVybiBpc0Zpbml0ZShwKT9TdHJpbmcocCk6dD90KHApOlwibnVsbFwiO2Nhc2VcImJvb2xlYW5cIjpyZXR1cm4gcD09PXRydWU/XCJ0cnVlXCI6XCJmYWxzZVwiO2Nhc2VcInVuZGVmaW5lZFwiOnJldHVybiB1bmRlZmluZWQ7Y2FzZVwiYmlnaW50XCI6aWYocil7cmV0dXJuIFN0cmluZyhwKX1kZWZhdWx0OnJldHVybiB0P3QocCk6dW5kZWZpbmVkfX1mdW5jdGlvbiBzdHJpbmdpZnlBcnJheVJlcGxhY2VyKGUsaSxmLHMsbCxjKXtpZih0eXBlb2YgaT09PVwib2JqZWN0XCImJmkhPT1udWxsJiZ0eXBlb2YgaS50b0pTT049PT1cImZ1bmN0aW9uXCIpe2k9aS50b0pTT04oZSl9c3dpdGNoKHR5cGVvZiBpKXtjYXNlXCJzdHJpbmdcIjpyZXR1cm4gc3RyRXNjYXBlKGkpO2Nhc2VcIm9iamVjdFwiOntpZihpPT09bnVsbCl7cmV0dXJuXCJudWxsXCJ9aWYoZi5pbmRleE9mKGkpIT09LTEpe3JldHVybiBufWNvbnN0IGU9YztsZXQgdD1cIlwiO2xldCByPVwiLFwiO2lmKEFycmF5LmlzQXJyYXkoaSkpe2lmKGkubGVuZ3RoPT09MCl7cmV0dXJuXCJbXVwifWlmKHU8Zi5sZW5ndGgrMSl7cmV0dXJuJ1wiW0FycmF5XVwiJ31mLnB1c2goaSk7aWYobCE9PVwiXCIpe2MrPWw7dCs9YFxcbiR7Y31gO3I9YCxcXG4ke2N9YH1jb25zdCBuPU1hdGgubWluKGkubGVuZ3RoLG8pO2xldCBhPTA7Zm9yKDthPG4tMTthKyspe2NvbnN0IGU9c3RyaW5naWZ5QXJyYXlSZXBsYWNlcihTdHJpbmcoYSksaVthXSxmLHMsbCxjKTt0Kz1lIT09dW5kZWZpbmVkP2U6XCJudWxsXCI7dCs9cn1jb25zdCBnPXN0cmluZ2lmeUFycmF5UmVwbGFjZXIoU3RyaW5nKGEpLGlbYV0sZixzLGwsYyk7dCs9ZyE9PXVuZGVmaW5lZD9nOlwibnVsbFwiO2lmKGkubGVuZ3RoLTE+byl7Y29uc3QgZT1pLmxlbmd0aC1vLTE7dCs9YCR7cn1cIi4uLiAke2dldEl0ZW1Db3VudChlKX0gbm90IHN0cmluZ2lmaWVkXCJgfWlmKGwhPT1cIlwiKXt0Kz1gXFxuJHtlfWB9Zi5wb3AoKTtyZXR1cm5gWyR7dH1dYH1mLnB1c2goaSk7bGV0IGE9XCJcIjtpZihsIT09XCJcIil7Yys9bDtyPWAsXFxuJHtjfWA7YT1cIiBcIn1sZXQgZz1cIlwiO2Zvcihjb25zdCBlIG9mIHMpe2NvbnN0IG49c3RyaW5naWZ5QXJyYXlSZXBsYWNlcihlLGlbZV0sZixzLGwsYyk7aWYobiE9PXVuZGVmaW5lZCl7dCs9YCR7Z30ke3N0ckVzY2FwZShlKX06JHthfSR7bn1gO2c9cn19aWYobCE9PVwiXCImJmcubGVuZ3RoPjEpe3Q9YFxcbiR7Y30ke3R9XFxuJHtlfWB9Zi5wb3AoKTtyZXR1cm5geyR7dH19YH1jYXNlXCJudW1iZXJcIjpyZXR1cm4gaXNGaW5pdGUoaSk/U3RyaW5nKGkpOnQ/dChpKTpcIm51bGxcIjtjYXNlXCJib29sZWFuXCI6cmV0dXJuIGk9PT10cnVlP1widHJ1ZVwiOlwiZmFsc2VcIjtjYXNlXCJ1bmRlZmluZWRcIjpyZXR1cm4gdW5kZWZpbmVkO2Nhc2VcImJpZ2ludFwiOmlmKHIpe3JldHVybiBTdHJpbmcoaSl9ZGVmYXVsdDpyZXR1cm4gdD90KGkpOnVuZGVmaW5lZH19ZnVuY3Rpb24gc3RyaW5naWZ5SW5kZW50KGUscyxsLGMsYSl7c3dpdGNoKHR5cGVvZiBzKXtjYXNlXCJzdHJpbmdcIjpyZXR1cm4gc3RyRXNjYXBlKHMpO2Nhc2VcIm9iamVjdFwiOntpZihzPT09bnVsbCl7cmV0dXJuXCJudWxsXCJ9aWYodHlwZW9mIHMudG9KU09OPT09XCJmdW5jdGlvblwiKXtzPXMudG9KU09OKGUpO2lmKHR5cGVvZiBzIT09XCJvYmplY3RcIil7cmV0dXJuIHN0cmluZ2lmeUluZGVudChlLHMsbCxjLGEpfWlmKHM9PT1udWxsKXtyZXR1cm5cIm51bGxcIn19aWYobC5pbmRleE9mKHMpIT09LTEpe3JldHVybiBufWNvbnN0IHQ9YTtpZihBcnJheS5pc0FycmF5KHMpKXtpZihzLmxlbmd0aD09PTApe3JldHVyblwiW11cIn1pZih1PGwubGVuZ3RoKzEpe3JldHVybidcIltBcnJheV1cIid9bC5wdXNoKHMpO2ErPWM7bGV0IGU9YFxcbiR7YX1gO2NvbnN0IG49YCxcXG4ke2F9YDtjb25zdCByPU1hdGgubWluKHMubGVuZ3RoLG8pO2xldCBpPTA7Zm9yKDtpPHItMTtpKyspe2NvbnN0IHQ9c3RyaW5naWZ5SW5kZW50KFN0cmluZyhpKSxzW2ldLGwsYyxhKTtlKz10IT09dW5kZWZpbmVkP3Q6XCJudWxsXCI7ZSs9bn1jb25zdCBmPXN0cmluZ2lmeUluZGVudChTdHJpbmcoaSksc1tpXSxsLGMsYSk7ZSs9ZiE9PXVuZGVmaW5lZD9mOlwibnVsbFwiO2lmKHMubGVuZ3RoLTE+byl7Y29uc3QgdD1zLmxlbmd0aC1vLTE7ZSs9YCR7bn1cIi4uLiAke2dldEl0ZW1Db3VudCh0KX0gbm90IHN0cmluZ2lmaWVkXCJgfWUrPWBcXG4ke3R9YDtsLnBvcCgpO3JldHVybmBbJHtlfV1gfWxldCByPU9iamVjdC5rZXlzKHMpO2NvbnN0IGc9ci5sZW5ndGg7aWYoZz09PTApe3JldHVyblwie31cIn1pZih1PGwubGVuZ3RoKzEpe3JldHVybidcIltPYmplY3RdXCInfWErPWM7Y29uc3QgcD1gLFxcbiR7YX1gO2xldCB5PVwiXCI7bGV0IGQ9XCJcIjtsZXQgaD1NYXRoLm1pbihnLG8pO2lmKGlzVHlwZWRBcnJheVdpdGhFbnRyaWVzKHMpKXt5Kz1zdHJpbmdpZnlUeXBlZEFycmF5KHMscCxvKTtyPXIuc2xpY2Uocy5sZW5ndGgpO2gtPXMubGVuZ3RoO2Q9cH1pZihpKXtyPXNvcnQocixmKX1sLnB1c2gocyk7Zm9yKGxldCBlPTA7ZTxoO2UrKyl7Y29uc3QgdD1yW2VdO2NvbnN0IG49c3RyaW5naWZ5SW5kZW50KHQsc1t0XSxsLGMsYSk7aWYobiE9PXVuZGVmaW5lZCl7eSs9YCR7ZH0ke3N0ckVzY2FwZSh0KX06ICR7bn1gO2Q9cH19aWYoZz5vKXtjb25zdCBlPWctbzt5Kz1gJHtkfVwiLi4uXCI6IFwiJHtnZXRJdGVtQ291bnQoZSl9IG5vdCBzdHJpbmdpZmllZFwiYDtkPXB9aWYoZCE9PVwiXCIpe3k9YFxcbiR7YX0ke3l9XFxuJHt0fWB9bC5wb3AoKTtyZXR1cm5geyR7eX19YH1jYXNlXCJudW1iZXJcIjpyZXR1cm4gaXNGaW5pdGUocyk/U3RyaW5nKHMpOnQ/dChzKTpcIm51bGxcIjtjYXNlXCJib29sZWFuXCI6cmV0dXJuIHM9PT10cnVlP1widHJ1ZVwiOlwiZmFsc2VcIjtjYXNlXCJ1bmRlZmluZWRcIjpyZXR1cm4gdW5kZWZpbmVkO2Nhc2VcImJpZ2ludFwiOmlmKHIpe3JldHVybiBTdHJpbmcocyl9ZGVmYXVsdDpyZXR1cm4gdD90KHMpOnVuZGVmaW5lZH19ZnVuY3Rpb24gc3RyaW5naWZ5U2ltcGxlKGUscyxsKXtzd2l0Y2godHlwZW9mIHMpe2Nhc2VcInN0cmluZ1wiOnJldHVybiBzdHJFc2NhcGUocyk7Y2FzZVwib2JqZWN0XCI6e2lmKHM9PT1udWxsKXtyZXR1cm5cIm51bGxcIn1pZih0eXBlb2Ygcy50b0pTT049PT1cImZ1bmN0aW9uXCIpe3M9cy50b0pTT04oZSk7aWYodHlwZW9mIHMhPT1cIm9iamVjdFwiKXtyZXR1cm4gc3RyaW5naWZ5U2ltcGxlKGUscyxsKX1pZihzPT09bnVsbCl7cmV0dXJuXCJudWxsXCJ9fWlmKGwuaW5kZXhPZihzKSE9PS0xKXtyZXR1cm4gbn1sZXQgdD1cIlwiO2NvbnN0IHI9cy5sZW5ndGghPT11bmRlZmluZWQ7aWYociYmQXJyYXkuaXNBcnJheShzKSl7aWYocy5sZW5ndGg9PT0wKXtyZXR1cm5cIltdXCJ9aWYodTxsLmxlbmd0aCsxKXtyZXR1cm4nXCJbQXJyYXldXCInfWwucHVzaChzKTtjb25zdCBlPU1hdGgubWluKHMubGVuZ3RoLG8pO2xldCBuPTA7Zm9yKDtuPGUtMTtuKyspe2NvbnN0IGU9c3RyaW5naWZ5U2ltcGxlKFN0cmluZyhuKSxzW25dLGwpO3QrPWUhPT11bmRlZmluZWQ/ZTpcIm51bGxcIjt0Kz1cIixcIn1jb25zdCByPXN0cmluZ2lmeVNpbXBsZShTdHJpbmcobiksc1tuXSxsKTt0Kz1yIT09dW5kZWZpbmVkP3I6XCJudWxsXCI7aWYocy5sZW5ndGgtMT5vKXtjb25zdCBlPXMubGVuZ3RoLW8tMTt0Kz1gLFwiLi4uICR7Z2V0SXRlbUNvdW50KGUpfSBub3Qgc3RyaW5naWZpZWRcImB9bC5wb3AoKTtyZXR1cm5gWyR7dH1dYH1sZXQgYz1PYmplY3Qua2V5cyhzKTtjb25zdCBhPWMubGVuZ3RoO2lmKGE9PT0wKXtyZXR1cm5cInt9XCJ9aWYodTxsLmxlbmd0aCsxKXtyZXR1cm4nXCJbT2JqZWN0XVwiJ31sZXQgZz1cIlwiO2xldCBwPU1hdGgubWluKGEsbyk7aWYociYmaXNUeXBlZEFycmF5V2l0aEVudHJpZXMocykpe3QrPXN0cmluZ2lmeVR5cGVkQXJyYXkocyxcIixcIixvKTtjPWMuc2xpY2Uocy5sZW5ndGgpO3AtPXMubGVuZ3RoO2c9XCIsXCJ9aWYoaSl7Yz1zb3J0KGMsZil9bC5wdXNoKHMpO2ZvcihsZXQgZT0wO2U8cDtlKyspe2NvbnN0IG49Y1tlXTtjb25zdCByPXN0cmluZ2lmeVNpbXBsZShuLHNbbl0sbCk7aWYociE9PXVuZGVmaW5lZCl7dCs9YCR7Z30ke3N0ckVzY2FwZShuKX06JHtyfWA7Zz1cIixcIn19aWYoYT5vKXtjb25zdCBlPWEtbzt0Kz1gJHtnfVwiLi4uXCI6XCIke2dldEl0ZW1Db3VudChlKX0gbm90IHN0cmluZ2lmaWVkXCJgfWwucG9wKCk7cmV0dXJuYHske3R9fWB9Y2FzZVwibnVtYmVyXCI6cmV0dXJuIGlzRmluaXRlKHMpP1N0cmluZyhzKTp0P3Qocyk6XCJudWxsXCI7Y2FzZVwiYm9vbGVhblwiOnJldHVybiBzPT09dHJ1ZT9cInRydWVcIjpcImZhbHNlXCI7Y2FzZVwidW5kZWZpbmVkXCI6cmV0dXJuIHVuZGVmaW5lZDtjYXNlXCJiaWdpbnRcIjppZihyKXtyZXR1cm4gU3RyaW5nKHMpfWRlZmF1bHQ6cmV0dXJuIHQ/dChzKTp1bmRlZmluZWR9fWZ1bmN0aW9uIHN0cmluZ2lmeShlLHQsbil7aWYoYXJndW1lbnRzLmxlbmd0aD4xKXtsZXQgcj1cIlwiO2lmKHR5cGVvZiBuPT09XCJudW1iZXJcIil7cj1cIiBcIi5yZXBlYXQoTWF0aC5taW4obiwxMCkpfWVsc2UgaWYodHlwZW9mIG49PT1cInN0cmluZ1wiKXtyPW4uc2xpY2UoMCwxMCl9aWYodCE9bnVsbCl7aWYodHlwZW9mIHQ9PT1cImZ1bmN0aW9uXCIpe3JldHVybiBzdHJpbmdpZnlGblJlcGxhY2VyKFwiXCIse1wiXCI6ZX0sW10sdCxyLFwiXCIpfWlmKEFycmF5LmlzQXJyYXkodCkpe3JldHVybiBzdHJpbmdpZnlBcnJheVJlcGxhY2VyKFwiXCIsZSxbXSxnZXRVbmlxdWVSZXBsYWNlclNldCh0KSxyLFwiXCIpfX1pZihyLmxlbmd0aCE9PTApe3JldHVybiBzdHJpbmdpZnlJbmRlbnQoXCJcIixlLFtdLHIsXCJcIil9fXJldHVybiBzdHJpbmdpZnlTaW1wbGUoXCJcIixlLFtdKX1yZXR1cm4gc3RyaW5naWZ5fX19O3ZhciB0PXt9O2Z1bmN0aW9uIF9fbmNjd3Bja19yZXF1aXJlX18obil7dmFyIHI9dFtuXTtpZihyIT09dW5kZWZpbmVkKXtyZXR1cm4gci5leHBvcnRzfXZhciBpPXRbbl09e2V4cG9ydHM6e319O3ZhciBmPXRydWU7dHJ5e2Vbbl0oaSxpLmV4cG9ydHMsX19uY2N3cGNrX3JlcXVpcmVfXyk7Zj1mYWxzZX1maW5hbGx5e2lmKGYpZGVsZXRlIHRbbl19cmV0dXJuIGkuZXhwb3J0c31pZih0eXBlb2YgX19uY2N3cGNrX3JlcXVpcmVfXyE9PVwidW5kZWZpbmVkXCIpX19uY2N3cGNrX3JlcXVpcmVfXy5hYj1fX2Rpcm5hbWUrXCIvXCI7dmFyIG49X19uY2N3cGNrX3JlcXVpcmVfXyg4NzkpO21vZHVsZS5leHBvcnRzPW59KSgpOyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxDQUFDO0lBQVc7SUFBYSxJQUFJLElBQUU7UUFBQyxLQUFJLFNBQVMsQ0FBQyxFQUFDLENBQUM7WUFBRSxNQUFLLEVBQUMsZ0JBQWUsQ0FBQyxFQUFDLEdBQUMsT0FBTyxTQUFTO1lBQUMsTUFBTSxJQUFFO1lBQVksRUFBRSxTQUFTLEdBQUM7WUFBVSxFQUFFLFNBQVMsR0FBQztZQUFFLEVBQUUsT0FBTyxHQUFDO1lBQUUsRUFBRSxTQUFTLEdBQUM7WUFBRSxFQUFFLFNBQVMsR0FBQztZQUFVLEVBQUUsT0FBTyxHQUFDO1lBQUUsTUFBTSxJQUFFO1lBQTJDLFNBQVMsVUFBVSxDQUFDO2dCQUFFLElBQUcsRUFBRSxNQUFNLEdBQUMsT0FBSyxDQUFDLEVBQUUsSUFBSSxDQUFDLElBQUc7b0JBQUMsT0FBTSxBQUFDLElBQUssT0FBRixHQUFFO2dCQUFFO2dCQUFDLE9BQU8sS0FBSyxTQUFTLENBQUM7WUFBRTtZQUFDLFNBQVMsS0FBSyxDQUFDLEVBQUMsQ0FBQztnQkFB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QkFBQyxJQUFHLEVBQUUsTUFBTSxLQUFHLEdBQUU7NEJBQUMsT0FBTyxnQkFBZ0IsSUFBRyxHQUFFLEVBQUUsRUFBQyxHQUFFO3dCQUFHO29CQUFDO29CQUFDLE9BQU8sZ0JBQWdCLElBQUcsR0FBRSxFQUFFO2dCQUFDO2dCQUFDLE9BQU87WUFBUztRQUFDO0lBQUM7SUFBRSxJQUFJLElBQUUsQ0FBQztJQUFFLFNBQVMsb0JBQW9CLENBQUM7UUFBRSxJQUFJLElBQUUsQ0FBQyxDQUFDLEVBQUU7UUFBQyxJQUFHLE1BQUksV0FBVTtZQUFDLE9BQU8sRUFBRSxPQUFPO1FBQUE7UUFBQyxJQUFJLElBQUUsQ0FBQyxDQUFDLEVBQUUsR0FBQztZQUFDLFNBQVEsQ0FBQztRQUFDO1FBQUUsSUFBSSxJQUFFO1FBQUssSUFBRztZQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRSxFQUFFLE9BQU8sRUFBQztZQUFxQixJQUFFO1FBQUssU0FBUTtZQUFDLElBQUcsR0FBRSxPQUFPLENBQUMsQ0FBQyxFQUFFO1FBQUE7UUFBQyxPQUFPLEVBQUUsT0FBTztJQUFBO0lBQUMsSUFBRyxPQUFPLHdCQUFzQixhQUFZLG9CQUFvQixFQUFFLEdBQUMsa0dBQVU7SUFBSSxJQUFJLElBQUUsb0JBQW9CO0lBQUssT0FBTyxPQUFPLEdBQUM7QUFBQyxDQUFDIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDI1NTYsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3NjaGVkdWxlci9janMvc2NoZWR1bGVyLmRldmVsb3BtZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHNjaGVkdWxlci5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgJiZcbiAgKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBwZXJmb3JtV29ya1VudGlsRGVhZGxpbmUoKSB7XG4gICAgICBuZWVkc1BhaW50ID0gITE7XG4gICAgICBpZiAoaXNNZXNzYWdlTG9vcFJ1bm5pbmcpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKTtcbiAgICAgICAgc3RhcnRUaW1lID0gY3VycmVudFRpbWU7XG4gICAgICAgIHZhciBoYXNNb3JlV29yayA9ICEwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gITE7XG4gICAgICAgICAgICBpc0hvc3RUaW1lb3V0U2NoZWR1bGVkICYmXG4gICAgICAgICAgICAgICgoaXNIb3N0VGltZW91dFNjaGVkdWxlZCA9ICExKSxcbiAgICAgICAgICAgICAgbG9jYWxDbGVhclRpbWVvdXQodGFza1RpbWVvdXRJRCksXG4gICAgICAgICAgICAgICh0YXNrVGltZW91dElEID0gLTEpKTtcbiAgICAgICAgICAgIGlzUGVyZm9ybWluZ1dvcmsgPSAhMDtcbiAgICAgICAgICAgIHZhciBwcmV2aW91c1ByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGI6IHtcbiAgICAgICAgICAgICAgICBhZHZhbmNlVGltZXJzKGN1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgICAgY3VycmVudFRhc2sgPSBwZWVrKHRhc2tRdWV1ZSk7XG4gICAgICAgICAgICAgICAgICBudWxsICE9PSBjdXJyZW50VGFzayAmJlxuICAgICAgICAgICAgICAgICAgIShcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRhc2suZXhwaXJhdGlvblRpbWUgPiBjdXJyZW50VGltZSAmJlxuICAgICAgICAgICAgICAgICAgICBzaG91bGRZaWVsZFRvSG9zdCgpXG4gICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBjdXJyZW50VGFzay5jYWxsYmFjaztcbiAgICAgICAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VGFzay5jYWxsYmFjayA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gY3VycmVudFRhc2sucHJpb3JpdHlMZXZlbDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRpbnVhdGlvbkNhbGxiYWNrID0gY2FsbGJhY2soXG4gICAgICAgICAgICAgICAgICAgICAgY3VycmVudFRhc2suZXhwaXJhdGlvblRpbWUgPD0gY3VycmVudFRpbWVcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRpbWUgPSBleHBvcnRzLnVuc3RhYmxlX25vdygpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY29udGludWF0aW9uQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VGFzay5jYWxsYmFjayA9IGNvbnRpbnVhdGlvbkNhbGxiYWNrO1xuICAgICAgICAgICAgICAgICAgICAgIGFkdmFuY2VUaW1lcnMoY3VycmVudFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAgIGhhc01vcmVXb3JrID0gITA7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWsgYjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VGFzayA9PT0gcGVlayh0YXNrUXVldWUpICYmIHBvcCh0YXNrUXVldWUpO1xuICAgICAgICAgICAgICAgICAgICBhZHZhbmNlVGltZXJzKGN1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBwb3AodGFza1F1ZXVlKTtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRUYXNrID0gcGVlayh0YXNrUXVldWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobnVsbCAhPT0gY3VycmVudFRhc2spIGhhc01vcmVXb3JrID0gITA7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZmlyc3RUaW1lciA9IHBlZWsodGltZXJRdWV1ZSk7XG4gICAgICAgICAgICAgICAgICBudWxsICE9PSBmaXJzdFRpbWVyICYmXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RIb3N0VGltZW91dChcbiAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVUaW1lb3V0LFxuICAgICAgICAgICAgICAgICAgICAgIGZpcnN0VGltZXIuc3RhcnRUaW1lIC0gY3VycmVudFRpbWVcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGhhc01vcmVXb3JrID0gITE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAoY3VycmVudFRhc2sgPSBudWxsKSxcbiAgICAgICAgICAgICAgICAoY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmV2aW91c1ByaW9yaXR5TGV2ZWwpLFxuICAgICAgICAgICAgICAgIChpc1BlcmZvcm1pbmdXb3JrID0gITEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFzTW9yZVdvcmsgPSB2b2lkIDA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGhhc01vcmVXb3JrXG4gICAgICAgICAgICA/IHNjaGVkdWxlUGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lKClcbiAgICAgICAgICAgIDogKGlzTWVzc2FnZUxvb3BSdW5uaW5nID0gITEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2goaGVhcCwgbm9kZSkge1xuICAgICAgdmFyIGluZGV4ID0gaGVhcC5sZW5ndGg7XG4gICAgICBoZWFwLnB1c2gobm9kZSk7XG4gICAgICBhOiBmb3IgKDsgMCA8IGluZGV4OyApIHtcbiAgICAgICAgdmFyIHBhcmVudEluZGV4ID0gKGluZGV4IC0gMSkgPj4+IDEsXG4gICAgICAgICAgcGFyZW50ID0gaGVhcFtwYXJlbnRJbmRleF07XG4gICAgICAgIGlmICgwIDwgY29tcGFyZShwYXJlbnQsIG5vZGUpKVxuICAgICAgICAgIChoZWFwW3BhcmVudEluZGV4XSA9IG5vZGUpLFxuICAgICAgICAgICAgKGhlYXBbaW5kZXhdID0gcGFyZW50KSxcbiAgICAgICAgICAgIChpbmRleCA9IHBhcmVudEluZGV4KTtcbiAgICAgICAgZWxzZSBicmVhayBhO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwZWVrKGhlYXApIHtcbiAgICAgIHJldHVybiAwID09PSBoZWFwLmxlbmd0aCA/IG51bGwgOiBoZWFwWzBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb3AoaGVhcCkge1xuICAgICAgaWYgKDAgPT09IGhlYXAubGVuZ3RoKSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBmaXJzdCA9IGhlYXBbMF0sXG4gICAgICAgIGxhc3QgPSBoZWFwLnBvcCgpO1xuICAgICAgaWYgKGxhc3QgIT09IGZpcnN0KSB7XG4gICAgICAgIGhlYXBbMF0gPSBsYXN0O1xuICAgICAgICBhOiBmb3IgKFxuICAgICAgICAgIHZhciBpbmRleCA9IDAsIGxlbmd0aCA9IGhlYXAubGVuZ3RoLCBoYWxmTGVuZ3RoID0gbGVuZ3RoID4+PiAxO1xuICAgICAgICAgIGluZGV4IDwgaGFsZkxlbmd0aDtcblxuICAgICAgICApIHtcbiAgICAgICAgICB2YXIgbGVmdEluZGV4ID0gMiAqIChpbmRleCArIDEpIC0gMSxcbiAgICAgICAgICAgIGxlZnQgPSBoZWFwW2xlZnRJbmRleF0sXG4gICAgICAgICAgICByaWdodEluZGV4ID0gbGVmdEluZGV4ICsgMSxcbiAgICAgICAgICAgIHJpZ2h0ID0gaGVhcFtyaWdodEluZGV4XTtcbiAgICAgICAgICBpZiAoMCA+IGNvbXBhcmUobGVmdCwgbGFzdCkpXG4gICAgICAgICAgICByaWdodEluZGV4IDwgbGVuZ3RoICYmIDAgPiBjb21wYXJlKHJpZ2h0LCBsZWZ0KVxuICAgICAgICAgICAgICA/ICgoaGVhcFtpbmRleF0gPSByaWdodCksXG4gICAgICAgICAgICAgICAgKGhlYXBbcmlnaHRJbmRleF0gPSBsYXN0KSxcbiAgICAgICAgICAgICAgICAoaW5kZXggPSByaWdodEluZGV4KSlcbiAgICAgICAgICAgICAgOiAoKGhlYXBbaW5kZXhdID0gbGVmdCksXG4gICAgICAgICAgICAgICAgKGhlYXBbbGVmdEluZGV4XSA9IGxhc3QpLFxuICAgICAgICAgICAgICAgIChpbmRleCA9IGxlZnRJbmRleCkpO1xuICAgICAgICAgIGVsc2UgaWYgKHJpZ2h0SW5kZXggPCBsZW5ndGggJiYgMCA+IGNvbXBhcmUocmlnaHQsIGxhc3QpKVxuICAgICAgICAgICAgKGhlYXBbaW5kZXhdID0gcmlnaHQpLFxuICAgICAgICAgICAgICAoaGVhcFtyaWdodEluZGV4XSA9IGxhc3QpLFxuICAgICAgICAgICAgICAoaW5kZXggPSByaWdodEluZGV4KTtcbiAgICAgICAgICBlbHNlIGJyZWFrIGE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmaXJzdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gICAgICB2YXIgZGlmZiA9IGEuc29ydEluZGV4IC0gYi5zb3J0SW5kZXg7XG4gICAgICByZXR1cm4gMCAhPT0gZGlmZiA/IGRpZmYgOiBhLmlkIC0gYi5pZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWR2YW5jZVRpbWVycyhjdXJyZW50VGltZSkge1xuICAgICAgZm9yICh2YXIgdGltZXIgPSBwZWVrKHRpbWVyUXVldWUpOyBudWxsICE9PSB0aW1lcjsgKSB7XG4gICAgICAgIGlmIChudWxsID09PSB0aW1lci5jYWxsYmFjaykgcG9wKHRpbWVyUXVldWUpO1xuICAgICAgICBlbHNlIGlmICh0aW1lci5zdGFydFRpbWUgPD0gY3VycmVudFRpbWUpXG4gICAgICAgICAgcG9wKHRpbWVyUXVldWUpLFxuICAgICAgICAgICAgKHRpbWVyLnNvcnRJbmRleCA9IHRpbWVyLmV4cGlyYXRpb25UaW1lKSxcbiAgICAgICAgICAgIHB1c2godGFza1F1ZXVlLCB0aW1lcik7XG4gICAgICAgIGVsc2UgYnJlYWs7XG4gICAgICAgIHRpbWVyID0gcGVlayh0aW1lclF1ZXVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlVGltZW91dChjdXJyZW50VGltZSkge1xuICAgICAgaXNIb3N0VGltZW91dFNjaGVkdWxlZCA9ICExO1xuICAgICAgYWR2YW5jZVRpbWVycyhjdXJyZW50VGltZSk7XG4gICAgICBpZiAoIWlzSG9zdENhbGxiYWNrU2NoZWR1bGVkKVxuICAgICAgICBpZiAobnVsbCAhPT0gcGVlayh0YXNrUXVldWUpKVxuICAgICAgICAgIChpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9ICEwKSxcbiAgICAgICAgICAgIGlzTWVzc2FnZUxvb3BSdW5uaW5nIHx8XG4gICAgICAgICAgICAgICgoaXNNZXNzYWdlTG9vcFJ1bm5pbmcgPSAhMCksIHNjaGVkdWxlUGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lKCkpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgZmlyc3RUaW1lciA9IHBlZWsodGltZXJRdWV1ZSk7XG4gICAgICAgICAgbnVsbCAhPT0gZmlyc3RUaW1lciAmJlxuICAgICAgICAgICAgcmVxdWVzdEhvc3RUaW1lb3V0KFxuICAgICAgICAgICAgICBoYW5kbGVUaW1lb3V0LFxuICAgICAgICAgICAgICBmaXJzdFRpbWVyLnN0YXJ0VGltZSAtIGN1cnJlbnRUaW1lXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNob3VsZFlpZWxkVG9Ib3N0KCkge1xuICAgICAgcmV0dXJuIG5lZWRzUGFpbnRcbiAgICAgICAgPyAhMFxuICAgICAgICA6IGV4cG9ydHMudW5zdGFibGVfbm93KCkgLSBzdGFydFRpbWUgPCBmcmFtZUludGVydmFsXG4gICAgICAgICAgPyAhMVxuICAgICAgICAgIDogITA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcXVlc3RIb3N0VGltZW91dChjYWxsYmFjaywgbXMpIHtcbiAgICAgIHRhc2tUaW1lb3V0SUQgPSBsb2NhbFNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBjYWxsYmFjayhleHBvcnRzLnVuc3RhYmxlX25vdygpKTtcbiAgICAgIH0sIG1zKTtcbiAgICB9XG4gICAgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAmJlxuICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydCAmJlxuICAgICAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydChFcnJvcigpKTtcbiAgICBleHBvcnRzLnVuc3RhYmxlX25vdyA9IHZvaWQgMDtcbiAgICBpZiAoXG4gICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgcGVyZm9ybWFuY2UgJiZcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHBlcmZvcm1hbmNlLm5vd1xuICAgICkge1xuICAgICAgdmFyIGxvY2FsUGVyZm9ybWFuY2UgPSBwZXJmb3JtYW5jZTtcbiAgICAgIGV4cG9ydHMudW5zdGFibGVfbm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbG9jYWxQZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBsb2NhbERhdGUgPSBEYXRlLFxuICAgICAgICBpbml0aWFsVGltZSA9IGxvY2FsRGF0ZS5ub3coKTtcbiAgICAgIGV4cG9ydHMudW5zdGFibGVfbm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbG9jYWxEYXRlLm5vdygpIC0gaW5pdGlhbFRpbWU7XG4gICAgICB9O1xuICAgIH1cbiAgICB2YXIgdGFza1F1ZXVlID0gW10sXG4gICAgICB0aW1lclF1ZXVlID0gW10sXG4gICAgICB0YXNrSWRDb3VudGVyID0gMSxcbiAgICAgIGN1cnJlbnRUYXNrID0gbnVsbCxcbiAgICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gMyxcbiAgICAgIGlzUGVyZm9ybWluZ1dvcmsgPSAhMSxcbiAgICAgIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gITEsXG4gICAgICBpc0hvc3RUaW1lb3V0U2NoZWR1bGVkID0gITEsXG4gICAgICBuZWVkc1BhaW50ID0gITEsXG4gICAgICBsb2NhbFNldFRpbWVvdXQgPSBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBzZXRUaW1lb3V0ID8gc2V0VGltZW91dCA6IG51bGwsXG4gICAgICBsb2NhbENsZWFyVGltZW91dCA9XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNsZWFyVGltZW91dCA/IGNsZWFyVGltZW91dCA6IG51bGwsXG4gICAgICBsb2NhbFNldEltbWVkaWF0ZSA9XG4gICAgICAgIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBzZXRJbW1lZGlhdGUgPyBzZXRJbW1lZGlhdGUgOiBudWxsLFxuICAgICAgaXNNZXNzYWdlTG9vcFJ1bm5pbmcgPSAhMSxcbiAgICAgIHRhc2tUaW1lb3V0SUQgPSAtMSxcbiAgICAgIGZyYW1lSW50ZXJ2YWwgPSA1LFxuICAgICAgc3RhcnRUaW1lID0gLTE7XG4gICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGxvY2FsU2V0SW1tZWRpYXRlKVxuICAgICAgdmFyIHNjaGVkdWxlUGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2NhbFNldEltbWVkaWF0ZShwZXJmb3JtV29ya1VudGlsRGVhZGxpbmUpO1xuICAgICAgfTtcbiAgICBlbHNlIGlmIChcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgTWVzc2FnZUNoYW5uZWwpIHtcbiAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCksXG4gICAgICAgIHBvcnQgPSBjaGFubmVsLnBvcnQyO1xuICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBwZXJmb3JtV29ya1VudGlsRGVhZGxpbmU7XG4gICAgICBzY2hlZHVsZVBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcG9ydC5wb3N0TWVzc2FnZShudWxsKTtcbiAgICAgIH07XG4gICAgfSBlbHNlXG4gICAgICBzY2hlZHVsZVBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9jYWxTZXRUaW1lb3V0KHBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSwgMCk7XG4gICAgICB9O1xuICAgIGV4cG9ydHMudW5zdGFibGVfSWRsZVByaW9yaXR5ID0gNTtcbiAgICBleHBvcnRzLnVuc3RhYmxlX0ltbWVkaWF0ZVByaW9yaXR5ID0gMTtcbiAgICBleHBvcnRzLnVuc3RhYmxlX0xvd1ByaW9yaXR5ID0gNDtcbiAgICBleHBvcnRzLnVuc3RhYmxlX05vcm1hbFByaW9yaXR5ID0gMztcbiAgICBleHBvcnRzLnVuc3RhYmxlX1Byb2ZpbGluZyA9IG51bGw7XG4gICAgZXhwb3J0cy51bnN0YWJsZV9Vc2VyQmxvY2tpbmdQcmlvcml0eSA9IDI7XG4gICAgZXhwb3J0cy51bnN0YWJsZV9jYW5jZWxDYWxsYmFjayA9IGZ1bmN0aW9uICh0YXNrKSB7XG4gICAgICB0YXNrLmNhbGxiYWNrID0gbnVsbDtcbiAgICB9O1xuICAgIGV4cG9ydHMudW5zdGFibGVfZm9yY2VGcmFtZVJhdGUgPSBmdW5jdGlvbiAoZnBzKSB7XG4gICAgICAwID4gZnBzIHx8IDEyNSA8IGZwc1xuICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcImZvcmNlRnJhbWVSYXRlIHRha2VzIGEgcG9zaXRpdmUgaW50IGJldHdlZW4gMCBhbmQgMTI1LCBmb3JjaW5nIGZyYW1lIHJhdGVzIGhpZ2hlciB0aGFuIDEyNSBmcHMgaXMgbm90IHN1cHBvcnRlZFwiXG4gICAgICAgICAgKVxuICAgICAgICA6IChmcmFtZUludGVydmFsID0gMCA8IGZwcyA/IE1hdGguZmxvb3IoMWUzIC8gZnBzKSA6IDUpO1xuICAgIH07XG4gICAgZXhwb3J0cy51bnN0YWJsZV9nZXRDdXJyZW50UHJpb3JpdHlMZXZlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgICB9O1xuICAgIGV4cG9ydHMudW5zdGFibGVfbmV4dCA9IGZ1bmN0aW9uIChldmVudEhhbmRsZXIpIHtcbiAgICAgIHN3aXRjaCAoY3VycmVudFByaW9yaXR5TGV2ZWwpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICBjYXNlIDI6XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICB2YXIgcHJpb3JpdHlMZXZlbCA9IDM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICAgICAgfVxuICAgICAgdmFyIHByZXZpb3VzUHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICAgICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmlvcml0eUxldmVsO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGV2ZW50SGFuZGxlcigpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmV2aW91c1ByaW9yaXR5TGV2ZWw7XG4gICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLnVuc3RhYmxlX3JlcXVlc3RQYWludCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIG5lZWRzUGFpbnQgPSAhMDtcbiAgICB9O1xuICAgIGV4cG9ydHMudW5zdGFibGVfcnVuV2l0aFByaW9yaXR5ID0gZnVuY3Rpb24gKHByaW9yaXR5TGV2ZWwsIGV2ZW50SGFuZGxlcikge1xuICAgICAgc3dpdGNoIChwcmlvcml0eUxldmVsKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICBjYXNlIDM6XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHByaW9yaXR5TGV2ZWwgPSAzO1xuICAgICAgfVxuICAgICAgdmFyIHByZXZpb3VzUHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICAgICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmlvcml0eUxldmVsO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGV2ZW50SGFuZGxlcigpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmV2aW91c1ByaW9yaXR5TGV2ZWw7XG4gICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoXG4gICAgICBwcmlvcml0eUxldmVsLFxuICAgICAgY2FsbGJhY2ssXG4gICAgICBvcHRpb25zXG4gICAgKSB7XG4gICAgICB2YXIgY3VycmVudFRpbWUgPSBleHBvcnRzLnVuc3RhYmxlX25vdygpO1xuICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIG9wdGlvbnMgJiYgbnVsbCAhPT0gb3B0aW9uc1xuICAgICAgICA/ICgob3B0aW9ucyA9IG9wdGlvbnMuZGVsYXkpLFxuICAgICAgICAgIChvcHRpb25zID1cbiAgICAgICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiBvcHRpb25zICYmIDAgPCBvcHRpb25zXG4gICAgICAgICAgICAgID8gY3VycmVudFRpbWUgKyBvcHRpb25zXG4gICAgICAgICAgICAgIDogY3VycmVudFRpbWUpKVxuICAgICAgICA6IChvcHRpb25zID0gY3VycmVudFRpbWUpO1xuICAgICAgc3dpdGNoIChwcmlvcml0eUxldmVsKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB2YXIgdGltZW91dCA9IC0xO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgdGltZW91dCA9IDI1MDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHRpbWVvdXQgPSAxMDczNzQxODIzO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgdGltZW91dCA9IDFlNDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aW1lb3V0ID0gNWUzO1xuICAgICAgfVxuICAgICAgdGltZW91dCA9IG9wdGlvbnMgKyB0aW1lb3V0O1xuICAgICAgcHJpb3JpdHlMZXZlbCA9IHtcbiAgICAgICAgaWQ6IHRhc2tJZENvdW50ZXIrKyxcbiAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICBwcmlvcml0eUxldmVsOiBwcmlvcml0eUxldmVsLFxuICAgICAgICBzdGFydFRpbWU6IG9wdGlvbnMsXG4gICAgICAgIGV4cGlyYXRpb25UaW1lOiB0aW1lb3V0LFxuICAgICAgICBzb3J0SW5kZXg6IC0xXG4gICAgICB9O1xuICAgICAgb3B0aW9ucyA+IGN1cnJlbnRUaW1lXG4gICAgICAgID8gKChwcmlvcml0eUxldmVsLnNvcnRJbmRleCA9IG9wdGlvbnMpLFxuICAgICAgICAgIHB1c2godGltZXJRdWV1ZSwgcHJpb3JpdHlMZXZlbCksXG4gICAgICAgICAgbnVsbCA9PT0gcGVlayh0YXNrUXVldWUpICYmXG4gICAgICAgICAgICBwcmlvcml0eUxldmVsID09PSBwZWVrKHRpbWVyUXVldWUpICYmXG4gICAgICAgICAgICAoaXNIb3N0VGltZW91dFNjaGVkdWxlZFxuICAgICAgICAgICAgICA/IChsb2NhbENsZWFyVGltZW91dCh0YXNrVGltZW91dElEKSwgKHRhc2tUaW1lb3V0SUQgPSAtMSkpXG4gICAgICAgICAgICAgIDogKGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgPSAhMCksXG4gICAgICAgICAgICByZXF1ZXN0SG9zdFRpbWVvdXQoaGFuZGxlVGltZW91dCwgb3B0aW9ucyAtIGN1cnJlbnRUaW1lKSkpXG4gICAgICAgIDogKChwcmlvcml0eUxldmVsLnNvcnRJbmRleCA9IHRpbWVvdXQpLFxuICAgICAgICAgIHB1c2godGFza1F1ZXVlLCBwcmlvcml0eUxldmVsKSxcbiAgICAgICAgICBpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCB8fFxuICAgICAgICAgICAgaXNQZXJmb3JtaW5nV29yayB8fFxuICAgICAgICAgICAgKChpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9ICEwKSxcbiAgICAgICAgICAgIGlzTWVzc2FnZUxvb3BSdW5uaW5nIHx8XG4gICAgICAgICAgICAgICgoaXNNZXNzYWdlTG9vcFJ1bm5pbmcgPSAhMCksXG4gICAgICAgICAgICAgIHNjaGVkdWxlUGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lKCkpKSk7XG4gICAgICByZXR1cm4gcHJpb3JpdHlMZXZlbDtcbiAgICB9O1xuICAgIGV4cG9ydHMudW5zdGFibGVfc2hvdWxkWWllbGQgPSBzaG91bGRZaWVsZFRvSG9zdDtcbiAgICBleHBvcnRzLnVuc3RhYmxlX3dyYXBDYWxsYmFjayA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgdmFyIHBhcmVudFByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcmV2aW91c1ByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgICAgICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwYXJlbnRQcmlvcml0eUxldmVsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJldmlvdXNQcmlvcml0eUxldmVsO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG4gICAgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAmJlxuICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wICYmXG4gICAgICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AoRXJyb3IoKSk7XG4gIH0pKCk7XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0NBUUMsR0FHZ0I7QUFEakI7QUFDQSxvRUFDRSxBQUFDO0lBQ0MsU0FBUztRQUNQLGFBQWEsQ0FBQztRQUNkLElBQUksc0JBQXNCO1lBQ3hCLElB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WUFDekI7UUFDRjtJQUNGO0lBQ0EsZ0JBQWdCLE9BQU8sa0NBQ3JCLGVBQ0UsT0FBTywrQkFBK0IsMEJBQTBCLElBQ2xFLCtCQUErQiwwQkFBMEIsQ0FBQztBQUM5RCIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAyODA2LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9zY2hlZHVsZXIvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3NjaGVkdWxlci5wcm9kdWN0aW9uLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3NjaGVkdWxlci5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUVJO0FBRko7QUFFQTs7S0FFTztJQUNMLE9BQU8sT0FBTztBQUNoQiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAyODE5LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC1zZXJ2ZXItZG9tLXR1cmJvcGFjay9janMvcmVhY3Qtc2VydmVyLWRvbS10dXJib3BhY2stY2xpZW50LmJyb3dzZXIuZGV2ZWxvcG1lbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3Qtc2VydmVyLWRvbS10dXJib3BhY2stY2xpZW50LmJyb3dzZXIuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gcmVzb2x2ZUNsaWVudFJlZmVyZW5jZShidW5kbGVyQ29uZmlnLCBtZXRhZGF0YSkge1xuICAgICAgaWYgKGJ1bmRsZXJDb25maWcpIHtcbiAgICAgICAgdmFyIG1vZHVsZUV4cG9ydHMgPSBidW5kbGVyQ29uZmlnW21ldGFkYXRhWzBdXTtcbiAgICAgICAgaWYgKChidW5kbGVyQ29uZmlnID0gbW9kdWxlRXhwb3J0cyAmJiBtb2R1bGVFeHBvcnRzW21ldGFkYXRhWzJdXSkpXG4gICAgICAgICAgbW9kdWxlRXhwb3J0cyA9IGJ1bmRsZXJDb25maWcubmFtZTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYnVuZGxlckNvbmZpZyA9IG1vZHVsZUV4cG9ydHMgJiYgbW9kdWxlRXhwb3J0c1tcIipcIl07XG4gICAgICAgICAgaWYgKCFidW5kbGVyQ29uZmlnKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICdDb3VsZCBub3QgZmluZCB0aGUgbW9kdWxlIFwiJyArXG4gICAgICAgICAgICAgICAgbWV0YWRhdGFbMF0gK1xuICAgICAgICAgICAgICAgICdcIiBpbiB0aGUgUmVhY3QgU2VydmVyIENvbnN1bWVyIE1hbmlmZXN0LiBUaGlzIGlzIHByb2JhYmx5IGEgYnVnIGluIHRoZSBSZWFjdCBTZXJ2ZXIgQ29tcG9uZW50cyBidW5kbGVyLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgbW9kdWxlRXhwb3J0cyA9IG1ldGFkYXRhWzJdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiA0ID09PSBtZXRhZGF0YS5sZW5ndGhcbiAgICAgICAgICA/IFtidW5kbGVyQ29uZmlnLmlkLCBidW5kbGVyQ29uZmlnLmNodW5rcywgbW9kdWxlRXhwb3J0cywgMV1cbiAgICAgICAgICA6IFtidW5kbGVyQ29uZmlnLmlkLCBidW5kbGVyQ29uZmlnLmNodW5rcywgbW9kdWxlRXhwb3J0c107XG4gICAgICB9XG4gICAgICByZXR1cm4gbWV0YWRhdGE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc29sdmVTZXJ2ZXJSZWZlcmVuY2UoYnVuZGxlckNvbmZpZywgaWQpIHtcbiAgICAgIHZhciBuYW1lID0gXCJcIixcbiAgICAgICAgcmVzb2x2ZWRNb2R1bGVEYXRhID0gYnVuZGxlckNvbmZpZ1tpZF07XG4gICAgICBpZiAocmVzb2x2ZWRNb2R1bGVEYXRhKSBuYW1lID0gcmVzb2x2ZWRNb2R1bGVEYXRhLm5hbWU7XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIGlkeCA9IGlkLmxhc3RJbmRleE9mKFwiI1wiKTtcbiAgICAgICAgLTEgIT09IGlkeCAmJlxuICAgICAgICAgICgobmFtZSA9IGlkLnNsaWNlKGlkeCArIDEpKSxcbiAgICAgICAgICAocmVzb2x2ZWRNb2R1bGVEYXRhID0gYnVuZGxlckNvbmZpZ1tpZC5zbGljZSgwLCBpZHgpXSkpO1xuICAgICAgICBpZiAoIXJlc29sdmVkTW9kdWxlRGF0YSlcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICdDb3VsZCBub3QgZmluZCB0aGUgbW9kdWxlIFwiJyArXG4gICAgICAgICAgICAgIGlkICtcbiAgICAgICAgICAgICAgJ1wiIGluIHRoZSBSZWFjdCBTZXJ2ZXIgTWFuaWZlc3QuIFRoaXMgaXMgcHJvYmFibHkgYSBidWcgaW4gdGhlIFJlYWN0IFNlcnZlciBDb21wb25lbnRzIGJ1bmRsZXIuJ1xuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW3Jlc29sdmVkTW9kdWxlRGF0YS5pZCwgcmVzb2x2ZWRNb2R1bGVEYXRhLmNodW5rcywgbmFtZV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcXVpcmVBc3luY01vZHVsZShpZCkge1xuICAgICAgdmFyIHByb21pc2UgPSBfX3R1cmJvcGFja19yZXF1aXJlX18oaWQpO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHByb21pc2UudGhlbiB8fCBcImZ1bGZpbGxlZFwiID09PSBwcm9taXNlLnN0YXR1cylcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBwcm9taXNlLnRoZW4oXG4gICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHByb21pc2Uuc3RhdHVzID0gXCJmdWxmaWxsZWRcIjtcbiAgICAgICAgICBwcm9taXNlLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICBwcm9taXNlLnN0YXR1cyA9IFwicmVqZWN0ZWRcIjtcbiAgICAgICAgICBwcm9taXNlLnJlYXNvbiA9IHJlYXNvbjtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpZ25vcmVSZWplY3QoKSB7fVxuICAgIGZ1bmN0aW9uIHByZWxvYWRNb2R1bGUobWV0YWRhdGEpIHtcbiAgICAgIGZvciAoXG4gICAgICAgIHZhciBjaHVua3MgPSBtZXRhZGF0YVsxXSwgcHJvbWlzZXMgPSBbXSwgaSA9IDA7XG4gICAgICAgIGkgPCBjaHVua3MubGVuZ3RoO1xuICAgICAgICBpKytcbiAgICAgICkge1xuICAgICAgICB2YXIgY2h1bmtGaWxlbmFtZSA9IGNodW5rc1tpXSxcbiAgICAgICAgICBlbnRyeSA9IGNodW5rQ2FjaGUuZ2V0KGNodW5rRmlsZW5hbWUpO1xuICAgICAgICBpZiAodm9pZCAwID09PSBlbnRyeSkge1xuICAgICAgICAgIGVudHJ5ID0gX190dXJib3BhY2tfbG9hZF9ieV91cmxfXyhjaHVua0ZpbGVuYW1lKTtcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKGVudHJ5KTtcbiAgICAgICAgICB2YXIgcmVzb2x2ZSA9IGNodW5rQ2FjaGUuc2V0LmJpbmQoY2h1bmtDYWNoZSwgY2h1bmtGaWxlbmFtZSwgbnVsbCk7XG4gICAgICAgICAgZW50cnkudGhlbihyZXNvbHZlLCBpZ25vcmVSZWplY3QpO1xuICAgICAgICAgIGNodW5rQ2FjaGUuc2V0KGNodW5rRmlsZW5hbWUsIGVudHJ5KTtcbiAgICAgICAgfSBlbHNlIG51bGwgIT09IGVudHJ5ICYmIHByb21pc2VzLnB1c2goZW50cnkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDQgPT09IG1ldGFkYXRhLmxlbmd0aFxuICAgICAgICA/IDAgPT09IHByb21pc2VzLmxlbmd0aFxuICAgICAgICAgID8gcmVxdWlyZUFzeW5jTW9kdWxlKG1ldGFkYXRhWzBdKVxuICAgICAgICAgIDogUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gcmVxdWlyZUFzeW5jTW9kdWxlKG1ldGFkYXRhWzBdKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIDogMCA8IHByb21pc2VzLmxlbmd0aFxuICAgICAgICAgID8gUHJvbWlzZS5hbGwocHJvbWlzZXMpXG4gICAgICAgICAgOiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXF1aXJlTW9kdWxlKG1ldGFkYXRhKSB7XG4gICAgICB2YXIgbW9kdWxlRXhwb3J0cyA9IF9fdHVyYm9wYWNrX3JlcXVpcmVfXyhtZXRhZGF0YVswXSk7XG4gICAgICBpZiAoNCA9PT0gbWV0YWRhdGEubGVuZ3RoICYmIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG1vZHVsZUV4cG9ydHMudGhlbilcbiAgICAgICAgaWYgKFwiZnVsZmlsbGVkXCIgPT09IG1vZHVsZUV4cG9ydHMuc3RhdHVzKVxuICAgICAgICAgIG1vZHVsZUV4cG9ydHMgPSBtb2R1bGVFeHBvcnRzLnZhbHVlO1xuICAgICAgICBlbHNlIHRocm93IG1vZHVsZUV4cG9ydHMucmVhc29uO1xuICAgICAgcmV0dXJuIFwiKlwiID09PSBtZXRhZGF0YVsyXVxuICAgICAgICA/IG1vZHVsZUV4cG9ydHNcbiAgICAgICAgOiBcIlwiID09PSBtZXRhZGF0YVsyXVxuICAgICAgICAgID8gbW9kdWxlRXhwb3J0cy5fX2VzTW9kdWxlXG4gICAgICAgICAgICA/IG1vZHVsZUV4cG9ydHMuZGVmYXVsdFxuICAgICAgICAgICAgOiBtb2R1bGVFeHBvcnRzXG4gICAgICAgICAgOiBtb2R1bGVFeHBvcnRzW21ldGFkYXRhWzJdXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gICAgICBpZiAobnVsbCA9PT0gbWF5YmVJdGVyYWJsZSB8fCBcIm9iamVjdFwiICE9PSB0eXBlb2YgbWF5YmVJdGVyYWJsZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBtYXliZUl0ZXJhYmxlID1cbiAgICAgICAgKE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0pIHx8XG4gICAgICAgIG1heWJlSXRlcmFibGVbXCJAQGl0ZXJhdG9yXCJdO1xuICAgICAgcmV0dXJuIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG1heWJlSXRlcmFibGUgPyBtYXliZUl0ZXJhYmxlIDogbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNPYmplY3RQcm90b3R5cGUob2JqZWN0KSB7XG4gICAgICBpZiAoIW9iamVjdCkgcmV0dXJuICExO1xuICAgICAgdmFyIE9iamVjdFByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XG4gICAgICBpZiAob2JqZWN0ID09PSBPYmplY3RQcm90b3R5cGUpIHJldHVybiAhMDtcbiAgICAgIGlmIChnZXRQcm90b3R5cGVPZihvYmplY3QpKSByZXR1cm4gITE7XG4gICAgICBvYmplY3QgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmplY3QpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmICghKG9iamVjdFtpXSBpbiBPYmplY3RQcm90b3R5cGUpKSByZXR1cm4gITE7XG4gICAgICByZXR1cm4gITA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzU2ltcGxlT2JqZWN0KG9iamVjdCkge1xuICAgICAgaWYgKCFpc09iamVjdFByb3RvdHlwZShnZXRQcm90b3R5cGVPZihvYmplY3QpKSkgcmV0dXJuICExO1xuICAgICAgZm9yIChcbiAgICAgICAgdmFyIG5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqZWN0KSwgaSA9IDA7XG4gICAgICAgIGkgPCBuYW1lcy5sZW5ndGg7XG4gICAgICAgIGkrK1xuICAgICAgKSB7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIG5hbWVzW2ldKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFkZXNjcmlwdG9yIHx8XG4gICAgICAgICAgKCFkZXNjcmlwdG9yLmVudW1lcmFibGUgJiZcbiAgICAgICAgICAgICgoXCJrZXlcIiAhPT0gbmFtZXNbaV0gJiYgXCJyZWZcIiAhPT0gbmFtZXNbaV0pIHx8XG4gICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGRlc2NyaXB0b3IuZ2V0KSlcbiAgICAgICAgKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gb2JqZWN0TmFtZShvYmplY3QpIHtcbiAgICAgIG9iamVjdCA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpO1xuICAgICAgcmV0dXJuIG9iamVjdC5zbGljZSg4LCBvYmplY3QubGVuZ3RoIC0gMSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlS2V5Rm9yRXJyb3JNZXNzYWdlKGtleSkge1xuICAgICAgdmFyIGVuY29kZWRLZXkgPSBKU09OLnN0cmluZ2lmeShrZXkpO1xuICAgICAgcmV0dXJuICdcIicgKyBrZXkgKyAnXCInID09PSBlbmNvZGVkS2V5ID8ga2V5IDogZW5jb2RlZEtleTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVWYWx1ZUZvckVycm9yTWVzc2FnZSh2YWx1ZSkge1xuICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgIDEwID49IHZhbHVlLmxlbmd0aCA/IHZhbHVlIDogdmFsdWUuc2xpY2UoMCwgMTApICsgXCIuLi5cIlxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICBpZiAoaXNBcnJheUltcGwodmFsdWUpKSByZXR1cm4gXCJbLi4uXVwiO1xuICAgICAgICAgIGlmIChudWxsICE9PSB2YWx1ZSAmJiB2YWx1ZS4kJHR5cGVvZiA9PT0gQ0xJRU5UX1JFRkVSRU5DRV9UQUcpXG4gICAgICAgICAgICByZXR1cm4gXCJjbGllbnRcIjtcbiAgICAgICAgICB2YWx1ZSA9IG9iamVjdE5hbWUodmFsdWUpO1xuICAgICAgICAgIHJldHVybiBcIk9iamVjdFwiID09PSB2YWx1ZSA/IFwiey4uLn1cIiA6IHZhbHVlO1xuICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICByZXR1cm4gdmFsdWUuJCR0eXBlb2YgPT09IENMSUVOVF9SRUZFUkVOQ0VfVEFHXG4gICAgICAgICAgICA/IFwiY2xpZW50XCJcbiAgICAgICAgICAgIDogKHZhbHVlID0gdmFsdWUuZGlzcGxheU5hbWUgfHwgdmFsdWUubmFtZSlcbiAgICAgICAgICAgICAgPyBcImZ1bmN0aW9uIFwiICsgdmFsdWVcbiAgICAgICAgICAgICAgOiBcImZ1bmN0aW9uXCI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlRWxlbWVudFR5cGUodHlwZSkge1xuICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKSByZXR1cm4gdHlwZTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VMaXN0XCI7XG4gICAgICB9XG4gICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZUVsZW1lbnRUeXBlKHR5cGUucmVuZGVyKTtcbiAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZUVsZW1lbnRUeXBlKHR5cGUudHlwZSk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICB2YXIgcGF5bG9hZCA9IHR5cGUuX3BheWxvYWQ7XG4gICAgICAgICAgICB0eXBlID0gdHlwZS5faW5pdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiBkZXNjcmliZUVsZW1lbnRUeXBlKHR5cGUocGF5bG9hZCkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlT2JqZWN0Rm9yRXJyb3JNZXNzYWdlKG9iamVjdE9yQXJyYXksIGV4cGFuZGVkTmFtZSkge1xuICAgICAgdmFyIG9iaktpbmQgPSBvYmplY3ROYW1lKG9iamVjdE9yQXJyYXkpO1xuICAgICAgaWYgKFwiT2JqZWN0XCIgIT09IG9iaktpbmQgJiYgXCJBcnJheVwiICE9PSBvYmpLaW5kKSByZXR1cm4gb2JqS2luZDtcbiAgICAgIHZhciBzdGFydCA9IC0xLFxuICAgICAgICBsZW5ndGggPSAwO1xuICAgICAgaWYgKGlzQXJyYXlJbXBsKG9iamVjdE9yQXJyYXkpKVxuICAgICAgICBpZiAoanN4Q2hpbGRyZW5QYXJlbnRzLmhhcyhvYmplY3RPckFycmF5KSkge1xuICAgICAgICAgIHZhciB0eXBlID0ganN4Q2hpbGRyZW5QYXJlbnRzLmdldChvYmplY3RPckFycmF5KTtcbiAgICAgICAgICBvYmpLaW5kID0gXCI8XCIgKyBkZXNjcmliZUVsZW1lbnRUeXBlKHR5cGUpICsgXCI+XCI7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3RPckFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBvYmplY3RPckFycmF5W2ldO1xuICAgICAgICAgICAgdmFsdWUgPVxuICAgICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgdmFsdWVcbiAgICAgICAgICAgICAgICA/IHZhbHVlXG4gICAgICAgICAgICAgICAgOiBcIm9iamVjdFwiID09PSB0eXBlb2YgdmFsdWUgJiYgbnVsbCAhPT0gdmFsdWVcbiAgICAgICAgICAgICAgICAgID8gXCJ7XCIgKyBkZXNjcmliZU9iamVjdEZvckVycm9yTWVzc2FnZSh2YWx1ZSkgKyBcIn1cIlxuICAgICAgICAgICAgICAgICAgOiBcIntcIiArIGRlc2NyaWJlVmFsdWVGb3JFcnJvck1lc3NhZ2UodmFsdWUpICsgXCJ9XCI7XG4gICAgICAgICAgICBcIlwiICsgaSA9PT0gZXhwYW5kZWROYW1lXG4gICAgICAgICAgICAgID8gKChzdGFydCA9IG9iaktpbmQubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAobGVuZ3RoID0gdmFsdWUubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAob2JqS2luZCArPSB2YWx1ZSkpXG4gICAgICAgICAgICAgIDogKG9iaktpbmQgPVxuICAgICAgICAgICAgICAgICAgMTUgPiB2YWx1ZS5sZW5ndGggJiYgNDAgPiBvYmpLaW5kLmxlbmd0aCArIHZhbHVlLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICA/IG9iaktpbmQgKyB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICA6IG9iaktpbmQgKyBcInsuLi59XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvYmpLaW5kICs9IFwiPC9cIiArIGRlc2NyaWJlRWxlbWVudFR5cGUodHlwZSkgKyBcIj5cIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvYmpLaW5kID0gXCJbXCI7XG4gICAgICAgICAgZm9yICh0eXBlID0gMDsgdHlwZSA8IG9iamVjdE9yQXJyYXkubGVuZ3RoOyB0eXBlKyspXG4gICAgICAgICAgICAwIDwgdHlwZSAmJiAob2JqS2luZCArPSBcIiwgXCIpLFxuICAgICAgICAgICAgICAoaSA9IG9iamVjdE9yQXJyYXlbdHlwZV0pLFxuICAgICAgICAgICAgICAoaSA9XG4gICAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGkgJiYgbnVsbCAhPT0gaVxuICAgICAgICAgICAgICAgICAgPyBkZXNjcmliZU9iamVjdEZvckVycm9yTWVzc2FnZShpKVxuICAgICAgICAgICAgICAgICAgOiBkZXNjcmliZVZhbHVlRm9yRXJyb3JNZXNzYWdlKGkpKSxcbiAgICAgICAgICAgICAgXCJcIiArIHR5cGUgPT09IGV4cGFuZGVkTmFtZVxuICAgICAgICAgICAgICAgID8gKChzdGFydCA9IG9iaktpbmQubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgIChsZW5ndGggPSBpLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgICAob2JqS2luZCArPSBpKSlcbiAgICAgICAgICAgICAgICA6IChvYmpLaW5kID1cbiAgICAgICAgICAgICAgICAgICAgMTAgPiBpLmxlbmd0aCAmJiA0MCA+IG9iaktpbmQubGVuZ3RoICsgaS5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICA/IG9iaktpbmQgKyBpXG4gICAgICAgICAgICAgICAgICAgICAgOiBvYmpLaW5kICsgXCIuLi5cIik7XG4gICAgICAgICAgb2JqS2luZCArPSBcIl1cIjtcbiAgICAgICAgfVxuICAgICAgZWxzZSBpZiAob2JqZWN0T3JBcnJheS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKVxuICAgICAgICBvYmpLaW5kID0gXCI8XCIgKyBkZXNjcmliZUVsZW1lbnRUeXBlKG9iamVjdE9yQXJyYXkudHlwZSkgKyBcIi8+XCI7XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKG9iamVjdE9yQXJyYXkuJCR0eXBlb2YgPT09IENMSUVOVF9SRUZFUkVOQ0VfVEFHKSByZXR1cm4gXCJjbGllbnRcIjtcbiAgICAgICAgaWYgKGpzeFByb3BzUGFyZW50cy5oYXMob2JqZWN0T3JBcnJheSkpIHtcbiAgICAgICAgICBvYmpLaW5kID0ganN4UHJvcHNQYXJlbnRzLmdldChvYmplY3RPckFycmF5KTtcbiAgICAgICAgICBvYmpLaW5kID0gXCI8XCIgKyAoZGVzY3JpYmVFbGVtZW50VHlwZShvYmpLaW5kKSB8fCBcIi4uLlwiKTtcbiAgICAgICAgICB0eXBlID0gT2JqZWN0LmtleXMob2JqZWN0T3JBcnJheSk7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IHR5cGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG9iaktpbmQgKz0gXCIgXCI7XG4gICAgICAgICAgICB2YWx1ZSA9IHR5cGVbaV07XG4gICAgICAgICAgICBvYmpLaW5kICs9IGRlc2NyaWJlS2V5Rm9yRXJyb3JNZXNzYWdlKHZhbHVlKSArIFwiPVwiO1xuICAgICAgICAgICAgdmFyIF92YWx1ZTIgPSBvYmplY3RPckFycmF5W3ZhbHVlXTtcbiAgICAgICAgICAgIHZhciBfc3Vic3RyMiA9XG4gICAgICAgICAgICAgIHZhbHVlID09PSBleHBhbmRlZE5hbWUgJiZcbiAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIF92YWx1ZTIgJiZcbiAgICAgICAgICAgICAgbnVsbCAhPT0gX3ZhbHVlMlxuICAgICAgICAgICAgICAgID8gZGVzY3JpYmVPYmplY3RGb3JFcnJvck1lc3NhZ2UoX3ZhbHVlMilcbiAgICAgICAgICAgICAgICA6IGRlc2NyaWJlVmFsdWVGb3JFcnJvck1lc3NhZ2UoX3ZhbHVlMik7XG4gICAgICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2YgX3ZhbHVlMiAmJiAoX3N1YnN0cjIgPSBcIntcIiArIF9zdWJzdHIyICsgXCJ9XCIpO1xuICAgICAgICAgICAgdmFsdWUgPT09IGV4cGFuZGVkTmFtZVxuICAgICAgICAgICAgICA/ICgoc3RhcnQgPSBvYmpLaW5kLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgKGxlbmd0aCA9IF9zdWJzdHIyLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgKG9iaktpbmQgKz0gX3N1YnN0cjIpKVxuICAgICAgICAgICAgICA6IChvYmpLaW5kID1cbiAgICAgICAgICAgICAgICAgIDEwID4gX3N1YnN0cjIubGVuZ3RoICYmIDQwID4gb2JqS2luZC5sZW5ndGggKyBfc3Vic3RyMi5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgPyBvYmpLaW5kICsgX3N1YnN0cjJcbiAgICAgICAgICAgICAgICAgICAgOiBvYmpLaW5kICsgXCIuLi5cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9iaktpbmQgKz0gXCI+XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2JqS2luZCA9IFwie1wiO1xuICAgICAgICAgIHR5cGUgPSBPYmplY3Qua2V5cyhvYmplY3RPckFycmF5KTtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdHlwZS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIDAgPCBpICYmIChvYmpLaW5kICs9IFwiLCBcIiksXG4gICAgICAgICAgICAgICh2YWx1ZSA9IHR5cGVbaV0pLFxuICAgICAgICAgICAgICAob2JqS2luZCArPSBkZXNjcmliZUtleUZvckVycm9yTWVzc2FnZSh2YWx1ZSkgKyBcIjogXCIpLFxuICAgICAgICAgICAgICAoX3ZhbHVlMiA9IG9iamVjdE9yQXJyYXlbdmFsdWVdKSxcbiAgICAgICAgICAgICAgKF92YWx1ZTIgPVxuICAgICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBfdmFsdWUyICYmIG51bGwgIT09IF92YWx1ZTJcbiAgICAgICAgICAgICAgICAgID8gZGVzY3JpYmVPYmplY3RGb3JFcnJvck1lc3NhZ2UoX3ZhbHVlMilcbiAgICAgICAgICAgICAgICAgIDogZGVzY3JpYmVWYWx1ZUZvckVycm9yTWVzc2FnZShfdmFsdWUyKSksXG4gICAgICAgICAgICAgIHZhbHVlID09PSBleHBhbmRlZE5hbWVcbiAgICAgICAgICAgICAgICA/ICgoc3RhcnQgPSBvYmpLaW5kLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgICAobGVuZ3RoID0gX3ZhbHVlMi5sZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgKG9iaktpbmQgKz0gX3ZhbHVlMikpXG4gICAgICAgICAgICAgICAgOiAob2JqS2luZCA9XG4gICAgICAgICAgICAgICAgICAgIDEwID4gX3ZhbHVlMi5sZW5ndGggJiYgNDAgPiBvYmpLaW5kLmxlbmd0aCArIF92YWx1ZTIubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgPyBvYmpLaW5kICsgX3ZhbHVlMlxuICAgICAgICAgICAgICAgICAgICAgIDogb2JqS2luZCArIFwiLi4uXCIpO1xuICAgICAgICAgIG9iaktpbmQgKz0gXCJ9XCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDAgPT09IGV4cGFuZGVkTmFtZVxuICAgICAgICA/IG9iaktpbmRcbiAgICAgICAgOiAtMSA8IHN0YXJ0ICYmIDAgPCBsZW5ndGhcbiAgICAgICAgICA/ICgob2JqZWN0T3JBcnJheSA9IFwiIFwiLnJlcGVhdChzdGFydCkgKyBcIl5cIi5yZXBlYXQobGVuZ3RoKSksXG4gICAgICAgICAgICBcIlxcbiAgXCIgKyBvYmpLaW5kICsgXCJcXG4gIFwiICsgb2JqZWN0T3JBcnJheSlcbiAgICAgICAgICA6IFwiXFxuICBcIiArIG9iaktpbmQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNlcmlhbGl6ZU51bWJlcihudW1iZXIpIHtcbiAgICAgIHJldHVybiBOdW1iZXIuaXNGaW5pdGUobnVtYmVyKVxuICAgICAgICA/IDAgPT09IG51bWJlciAmJiAtSW5maW5pdHkgPT09IDEgLyBudW1iZXJcbiAgICAgICAgICA/IFwiJC0wXCJcbiAgICAgICAgICA6IG51bWJlclxuICAgICAgICA6IEluZmluaXR5ID09PSBudW1iZXJcbiAgICAgICAgICA/IFwiJEluZmluaXR5XCJcbiAgICAgICAgICA6IC1JbmZpbml0eSA9PT0gbnVtYmVyXG4gICAgICAgICAgICA/IFwiJC1JbmZpbml0eVwiXG4gICAgICAgICAgICA6IFwiJE5hTlwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcm9jZXNzUmVwbHkoXG4gICAgICByb290LFxuICAgICAgZm9ybUZpZWxkUHJlZml4LFxuICAgICAgdGVtcG9yYXJ5UmVmZXJlbmNlcyxcbiAgICAgIHJlc29sdmUsXG4gICAgICByZWplY3RcbiAgICApIHtcbiAgICAgIGZ1bmN0aW9uIHNlcmlhbGl6ZVR5cGVkQXJyYXkodGFnLCB0eXBlZEFycmF5KSB7XG4gICAgICAgIHR5cGVkQXJyYXkgPSBuZXcgQmxvYihbXG4gICAgICAgICAgbmV3IFVpbnQ4QXJyYXkoXG4gICAgICAgICAgICB0eXBlZEFycmF5LmJ1ZmZlcixcbiAgICAgICAgICAgIHR5cGVkQXJyYXkuYnl0ZU9mZnNldCxcbiAgICAgICAgICAgIHR5cGVkQXJyYXkuYnl0ZUxlbmd0aFxuICAgICAgICAgIClcbiAgICAgICAgXSk7XG4gICAgICAgIHZhciBibG9iSWQgPSBuZXh0UGFydElkKys7XG4gICAgICAgIG51bGwgPT09IGZvcm1EYXRhICYmIChmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpKTtcbiAgICAgICAgZm9ybURhdGEuYXBwZW5kKGZvcm1GaWVsZFByZWZpeCArIGJsb2JJZCwgdHlwZWRBcnJheSk7XG4gICAgICAgIHJldHVybiBcIiRcIiArIHRhZyArIGJsb2JJZC50b1N0cmluZygxNik7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBzZXJpYWxpemVCaW5hcnlSZWFkZXIocmVhZGVyKSB7XG4gICAgICAgIGZ1bmN0aW9uIHByb2dyZXNzKGVudHJ5KSB7XG4gICAgICAgICAgZW50cnkuZG9uZVxuICAgICAgICAgICAgPyAoKGVudHJ5ID0gbmV4dFBhcnRJZCsrKSxcbiAgICAgICAgICAgICAgZGF0YS5hcHBlbmQoZm9ybUZpZWxkUHJlZml4ICsgZW50cnksIG5ldyBCbG9iKGJ1ZmZlcikpLFxuICAgICAgICAgICAgICBkYXRhLmFwcGVuZChcbiAgICAgICAgICAgICAgICBmb3JtRmllbGRQcmVmaXggKyBzdHJlYW1JZCxcbiAgICAgICAgICAgICAgICAnXCIkbycgKyBlbnRyeS50b1N0cmluZygxNikgKyAnXCInXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIGRhdGEuYXBwZW5kKGZvcm1GaWVsZFByZWZpeCArIHN0cmVhbUlkLCBcIkNcIiksXG4gICAgICAgICAgICAgIHBlbmRpbmdQYXJ0cy0tLFxuICAgICAgICAgICAgICAwID09PSBwZW5kaW5nUGFydHMgJiYgcmVzb2x2ZShkYXRhKSlcbiAgICAgICAgICAgIDogKGJ1ZmZlci5wdXNoKGVudHJ5LnZhbHVlKSxcbiAgICAgICAgICAgICAgcmVhZGVyLnJlYWQobmV3IFVpbnQ4QXJyYXkoMTAyNCkpLnRoZW4ocHJvZ3Jlc3MsIHJlamVjdCkpO1xuICAgICAgICB9XG4gICAgICAgIG51bGwgPT09IGZvcm1EYXRhICYmIChmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpKTtcbiAgICAgICAgdmFyIGRhdGEgPSBmb3JtRGF0YTtcbiAgICAgICAgcGVuZGluZ1BhcnRzKys7XG4gICAgICAgIHZhciBzdHJlYW1JZCA9IG5leHRQYXJ0SWQrKyxcbiAgICAgICAgICBidWZmZXIgPSBbXTtcbiAgICAgICAgcmVhZGVyLnJlYWQobmV3IFVpbnQ4QXJyYXkoMTAyNCkpLnRoZW4ocHJvZ3Jlc3MsIHJlamVjdCk7XG4gICAgICAgIHJldHVybiBcIiRyXCIgKyBzdHJlYW1JZC50b1N0cmluZygxNik7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBzZXJpYWxpemVSZWFkZXIocmVhZGVyKSB7XG4gICAgICAgIGZ1bmN0aW9uIHByb2dyZXNzKGVudHJ5KSB7XG4gICAgICAgICAgaWYgKGVudHJ5LmRvbmUpXG4gICAgICAgICAgICBkYXRhLmFwcGVuZChmb3JtRmllbGRQcmVmaXggKyBzdHJlYW1JZCwgXCJDXCIpLFxuICAgICAgICAgICAgICBwZW5kaW5nUGFydHMtLSxcbiAgICAgICAgICAgICAgMCA9PT0gcGVuZGluZ1BhcnRzICYmIHJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdmFyIHBhcnRKU09OID0gSlNPTi5zdHJpbmdpZnkoZW50cnkudmFsdWUsIHJlc29sdmVUb0pTT04pO1xuICAgICAgICAgICAgICBkYXRhLmFwcGVuZChmb3JtRmllbGRQcmVmaXggKyBzdHJlYW1JZCwgcGFydEpTT04pO1xuICAgICAgICAgICAgICByZWFkZXIucmVhZCgpLnRoZW4ocHJvZ3Jlc3MsIHJlamVjdCk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIHJlamVjdCh4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBudWxsID09PSBmb3JtRGF0YSAmJiAoZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKSk7XG4gICAgICAgIHZhciBkYXRhID0gZm9ybURhdGE7XG4gICAgICAgIHBlbmRpbmdQYXJ0cysrO1xuICAgICAgICB2YXIgc3RyZWFtSWQgPSBuZXh0UGFydElkKys7XG4gICAgICAgIHJlYWRlci5yZWFkKCkudGhlbihwcm9ncmVzcywgcmVqZWN0KTtcbiAgICAgICAgcmV0dXJuIFwiJFJcIiArIHN0cmVhbUlkLnRvU3RyaW5nKDE2KTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHNlcmlhbGl6ZVJlYWRhYmxlU3RyZWFtKHN0cmVhbSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBiaW5hcnlSZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKHsgbW9kZTogXCJieW9iXCIgfSk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICByZXR1cm4gc2VyaWFsaXplUmVhZGVyKHN0cmVhbS5nZXRSZWFkZXIoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZUJpbmFyeVJlYWRlcihiaW5hcnlSZWFkZXIpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gc2VyaWFsaXplQXN5bmNJdGVyYWJsZShpdGVyYWJsZSwgaXRlcmF0b3IpIHtcbiAgICAgICAgZnVuY3Rpb24gcHJvZ3Jlc3MoZW50cnkpIHtcbiAgICAgICAgICBpZiAoZW50cnkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0gZW50cnkudmFsdWUpXG4gICAgICAgICAgICAgIGRhdGEuYXBwZW5kKGZvcm1GaWVsZFByZWZpeCArIHN0cmVhbUlkLCBcIkNcIik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnRKU09OID0gSlNPTi5zdHJpbmdpZnkoZW50cnkudmFsdWUsIHJlc29sdmVUb0pTT04pO1xuICAgICAgICAgICAgICAgIGRhdGEuYXBwZW5kKGZvcm1GaWVsZFByZWZpeCArIHN0cmVhbUlkLCBcIkNcIiArIHBhcnRKU09OKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICAgIHJlamVjdCh4KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBlbmRpbmdQYXJ0cy0tO1xuICAgICAgICAgICAgMCA9PT0gcGVuZGluZ1BhcnRzICYmIHJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB2YXIgX3BhcnRKU09OID0gSlNPTi5zdHJpbmdpZnkoZW50cnkudmFsdWUsIHJlc29sdmVUb0pTT04pO1xuICAgICAgICAgICAgICBkYXRhLmFwcGVuZChmb3JtRmllbGRQcmVmaXggKyBzdHJlYW1JZCwgX3BhcnRKU09OKTtcbiAgICAgICAgICAgICAgaXRlcmF0b3IubmV4dCgpLnRoZW4ocHJvZ3Jlc3MsIHJlamVjdCk7XG4gICAgICAgICAgICB9IGNhdGNoICh4JDApIHtcbiAgICAgICAgICAgICAgcmVqZWN0KHgkMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbnVsbCA9PT0gZm9ybURhdGEgJiYgKGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCkpO1xuICAgICAgICB2YXIgZGF0YSA9IGZvcm1EYXRhO1xuICAgICAgICBwZW5kaW5nUGFydHMrKztcbiAgICAgICAgdmFyIHN0cmVhbUlkID0gbmV4dFBhcnRJZCsrO1xuICAgICAgICBpdGVyYWJsZSA9IGl0ZXJhYmxlID09PSBpdGVyYXRvcjtcbiAgICAgICAgaXRlcmF0b3IubmV4dCgpLnRoZW4ocHJvZ3Jlc3MsIHJlamVjdCk7XG4gICAgICAgIHJldHVybiBcIiRcIiArIChpdGVyYWJsZSA/IFwieFwiIDogXCJYXCIpICsgc3RyZWFtSWQudG9TdHJpbmcoMTYpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcmVzb2x2ZVRvSlNPTihrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciBvcmlnaW5hbFZhbHVlID0gdGhpc1trZXldO1xuICAgICAgICBcIm9iamVjdFwiICE9PSB0eXBlb2Ygb3JpZ2luYWxWYWx1ZSB8fFxuICAgICAgICAgIG9yaWdpbmFsVmFsdWUgPT09IHZhbHVlIHx8XG4gICAgICAgICAgb3JpZ2luYWxWYWx1ZSBpbnN0YW5jZW9mIERhdGUgfHxcbiAgICAgICAgICAoXCJPYmplY3RcIiAhPT0gb2JqZWN0TmFtZShvcmlnaW5hbFZhbHVlKVxuICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiT25seSBwbGFpbiBvYmplY3RzIGNhbiBiZSBwYXNzZWQgdG8gU2VydmVyIEZ1bmN0aW9ucyBmcm9tIHRoZSBDbGllbnQuICVzIG9iamVjdHMgYXJlIG5vdCBzdXBwb3J0ZWQuJXNcIixcbiAgICAgICAgICAgICAgICBvYmplY3ROYW1lKG9yaWdpbmFsVmFsdWUpLFxuICAgICAgICAgICAgICAgIGRlc2NyaWJlT2JqZWN0Rm9yRXJyb3JNZXNzYWdlKHRoaXMsIGtleSlcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgOiBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiT25seSBwbGFpbiBvYmplY3RzIGNhbiBiZSBwYXNzZWQgdG8gU2VydmVyIEZ1bmN0aW9ucyBmcm9tIHRoZSBDbGllbnQuIE9iamVjdHMgd2l0aCB0b0pTT04gbWV0aG9kcyBhcmUgbm90IHN1cHBvcnRlZC4gQ29udmVydCBpdCBtYW51YWxseSB0byBhIHNpbXBsZSB2YWx1ZSBiZWZvcmUgcGFzc2luZyBpdCB0byBwcm9wcy4lc1wiLFxuICAgICAgICAgICAgICAgIGRlc2NyaWJlT2JqZWN0Rm9yRXJyb3JNZXNzYWdlKHRoaXMsIGtleSlcbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgIGlmIChudWxsID09PSB2YWx1ZSkgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgICBzd2l0Y2ggKHZhbHVlLiQkdHlwZW9mKSB7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gdGVtcG9yYXJ5UmVmZXJlbmNlcyAmJiAtMSA9PT0ga2V5LmluZGV4T2YoXCI6XCIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudFJlZmVyZW5jZSA9IHdyaXR0ZW5PYmplY3RzLmdldCh0aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAodm9pZCAwICE9PSBwYXJlbnRSZWZlcmVuY2UpXG4gICAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICB0ZW1wb3JhcnlSZWZlcmVuY2VzLnNldChwYXJlbnRSZWZlcmVuY2UgKyBcIjpcIiArIGtleSwgdmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICBcIiRUXCJcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJSZWFjdCBFbGVtZW50IGNhbm5vdCBiZSBwYXNzZWQgdG8gU2VydmVyIEZ1bmN0aW9ucyBmcm9tIHRoZSBDbGllbnQgd2l0aG91dCBhIHRlbXBvcmFyeSByZWZlcmVuY2Ugc2V0LiBQYXNzIGEgVGVtcG9yYXJ5UmVmZXJlbmNlU2V0IHRvIHRoZSBvcHRpb25zLlwiICtcbiAgICAgICAgICAgICAgICAgIGRlc2NyaWJlT2JqZWN0Rm9yRXJyb3JNZXNzYWdlKHRoaXMsIGtleSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgICBvcmlnaW5hbFZhbHVlID0gdmFsdWUuX3BheWxvYWQ7XG4gICAgICAgICAgICAgIHZhciBpbml0ID0gdmFsdWUuX2luaXQ7XG4gICAgICAgICAgICAgIG51bGwgPT09IGZvcm1EYXRhICYmIChmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpKTtcbiAgICAgICAgICAgICAgcGVuZGluZ1BhcnRzKys7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGFyZW50UmVmZXJlbmNlID0gaW5pdChvcmlnaW5hbFZhbHVlKTtcbiAgICAgICAgICAgICAgICB2YXIgbGF6eUlkID0gbmV4dFBhcnRJZCsrLFxuICAgICAgICAgICAgICAgICAgcGFydEpTT04gPSBzZXJpYWxpemVNb2RlbChwYXJlbnRSZWZlcmVuY2UsIGxhenlJZCk7XG4gICAgICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKGZvcm1GaWVsZFByZWZpeCArIGxhenlJZCwgcGFydEpTT04pO1xuICAgICAgICAgICAgICAgIHJldHVybiBcIiRcIiArIGxhenlJZC50b1N0cmluZygxNik7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgeCAmJlxuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0geCAmJlxuICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgeC50aGVuXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICBwZW5kaW5nUGFydHMrKztcbiAgICAgICAgICAgICAgICAgIHZhciBfbGF6eUlkID0gbmV4dFBhcnRJZCsrO1xuICAgICAgICAgICAgICAgICAgcGFyZW50UmVmZXJlbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBfcGFydEpTT04yID0gc2VyaWFsaXplTW9kZWwodmFsdWUsIF9sYXp5SWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgX2RhdGEgPSBmb3JtRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICBfZGF0YS5hcHBlbmQoZm9ybUZpZWxkUHJlZml4ICsgX2xhenlJZCwgX3BhcnRKU09OMik7XG4gICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1BhcnRzLS07XG4gICAgICAgICAgICAgICAgICAgICAgMCA9PT0gcGVuZGluZ1BhcnRzICYmIHJlc29sdmUoX2RhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChyZWFzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICByZWplY3QocmVhc29uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIHgudGhlbihwYXJlbnRSZWZlcmVuY2UsIHBhcmVudFJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gXCIkXCIgKyBfbGF6eUlkLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVqZWN0KHgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHBlbmRpbmdQYXJ0cy0tO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB2YWx1ZS50aGVuKSB7XG4gICAgICAgICAgICBudWxsID09PSBmb3JtRGF0YSAmJiAoZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKSk7XG4gICAgICAgICAgICBwZW5kaW5nUGFydHMrKztcbiAgICAgICAgICAgIHZhciBwcm9taXNlSWQgPSBuZXh0UGFydElkKys7XG4gICAgICAgICAgICB2YWx1ZS50aGVuKGZ1bmN0aW9uIChwYXJ0VmFsdWUpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgX3BhcnRKU09OMyA9IHNlcmlhbGl6ZU1vZGVsKHBhcnRWYWx1ZSwgcHJvbWlzZUlkKTtcbiAgICAgICAgICAgICAgICBwYXJ0VmFsdWUgPSBmb3JtRGF0YTtcbiAgICAgICAgICAgICAgICBwYXJ0VmFsdWUuYXBwZW5kKGZvcm1GaWVsZFByZWZpeCArIHByb21pc2VJZCwgX3BhcnRKU09OMyk7XG4gICAgICAgICAgICAgICAgcGVuZGluZ1BhcnRzLS07XG4gICAgICAgICAgICAgICAgMCA9PT0gcGVuZGluZ1BhcnRzICYmIHJlc29sdmUocGFydFZhbHVlKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAocmVhc29uKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KHJlYXNvbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgICAgICByZXR1cm4gXCIkQFwiICsgcHJvbWlzZUlkLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFyZW50UmVmZXJlbmNlID0gd3JpdHRlbk9iamVjdHMuZ2V0KHZhbHVlKTtcbiAgICAgICAgICBpZiAodm9pZCAwICE9PSBwYXJlbnRSZWZlcmVuY2UpXG4gICAgICAgICAgICBpZiAobW9kZWxSb290ID09PSB2YWx1ZSkgbW9kZWxSb290ID0gbnVsbDtcbiAgICAgICAgICAgIGVsc2UgcmV0dXJuIHBhcmVudFJlZmVyZW5jZTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAtMSA9PT0ga2V5LmluZGV4T2YoXCI6XCIpICYmXG4gICAgICAgICAgICAgICgocGFyZW50UmVmZXJlbmNlID0gd3JpdHRlbk9iamVjdHMuZ2V0KHRoaXMpKSxcbiAgICAgICAgICAgICAgdm9pZCAwICE9PSBwYXJlbnRSZWZlcmVuY2UgJiZcbiAgICAgICAgICAgICAgICAoKHBhcmVudFJlZmVyZW5jZSA9IHBhcmVudFJlZmVyZW5jZSArIFwiOlwiICsga2V5KSxcbiAgICAgICAgICAgICAgICB3cml0dGVuT2JqZWN0cy5zZXQodmFsdWUsIHBhcmVudFJlZmVyZW5jZSksXG4gICAgICAgICAgICAgICAgdm9pZCAwICE9PSB0ZW1wb3JhcnlSZWZlcmVuY2VzICYmXG4gICAgICAgICAgICAgICAgICB0ZW1wb3JhcnlSZWZlcmVuY2VzLnNldChwYXJlbnRSZWZlcmVuY2UsIHZhbHVlKSkpO1xuICAgICAgICAgIGlmIChpc0FycmF5SW1wbCh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBGb3JtRGF0YSkge1xuICAgICAgICAgICAgbnVsbCA9PT0gZm9ybURhdGEgJiYgKGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCkpO1xuICAgICAgICAgICAgdmFyIF9kYXRhMyA9IGZvcm1EYXRhO1xuICAgICAgICAgICAga2V5ID0gbmV4dFBhcnRJZCsrO1xuICAgICAgICAgICAgdmFyIHByZWZpeCA9IGZvcm1GaWVsZFByZWZpeCArIGtleSArIFwiX1wiO1xuICAgICAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbiAob3JpZ2luYWxWYWx1ZSwgb3JpZ2luYWxLZXkpIHtcbiAgICAgICAgICAgICAgX2RhdGEzLmFwcGVuZChwcmVmaXggKyBvcmlnaW5hbEtleSwgb3JpZ2luYWxWYWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBcIiRLXCIgKyBrZXkudG9TdHJpbmcoMTYpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXApXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAoa2V5ID0gbmV4dFBhcnRJZCsrKSxcbiAgICAgICAgICAgICAgKHBhcmVudFJlZmVyZW5jZSA9IHNlcmlhbGl6ZU1vZGVsKEFycmF5LmZyb20odmFsdWUpLCBrZXkpKSxcbiAgICAgICAgICAgICAgbnVsbCA9PT0gZm9ybURhdGEgJiYgKGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCkpLFxuICAgICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoZm9ybUZpZWxkUHJlZml4ICsga2V5LCBwYXJlbnRSZWZlcmVuY2UpLFxuICAgICAgICAgICAgICBcIiRRXCIgKyBrZXkudG9TdHJpbmcoMTYpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFNldClcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChrZXkgPSBuZXh0UGFydElkKyspLFxuICAgICAgICAgICAgICAocGFyZW50UmVmZXJlbmNlID0gc2VyaWFsaXplTW9kZWwoQXJyYXkuZnJvbSh2YWx1ZSksIGtleSkpLFxuICAgICAgICAgICAgICBudWxsID09PSBmb3JtRGF0YSAmJiAoZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKSksXG4gICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChmb3JtRmllbGRQcmVmaXggKyBrZXksIHBhcmVudFJlZmVyZW5jZSksXG4gICAgICAgICAgICAgIFwiJFdcIiArIGtleS50b1N0cmluZygxNilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAoa2V5ID0gbmV3IEJsb2IoW3ZhbHVlXSkpLFxuICAgICAgICAgICAgICAocGFyZW50UmVmZXJlbmNlID0gbmV4dFBhcnRJZCsrKSxcbiAgICAgICAgICAgICAgbnVsbCA9PT0gZm9ybURhdGEgJiYgKGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCkpLFxuICAgICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoZm9ybUZpZWxkUHJlZml4ICsgcGFyZW50UmVmZXJlbmNlLCBrZXkpLFxuICAgICAgICAgICAgICBcIiRBXCIgKyBwYXJlbnRSZWZlcmVuY2UudG9TdHJpbmcoMTYpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEludDhBcnJheSlcbiAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVUeXBlZEFycmF5KFwiT1wiLCB2YWx1ZSk7XG4gICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSlcbiAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVUeXBlZEFycmF5KFwib1wiLCB2YWx1ZSk7XG4gICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkpXG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplVHlwZWRBcnJheShcIlVcIiwgdmFsdWUpO1xuICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEludDE2QXJyYXkpXG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplVHlwZWRBcnJheShcIlNcIiwgdmFsdWUpO1xuICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQxNkFycmF5KVxuICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZVR5cGVkQXJyYXkoXCJzXCIsIHZhbHVlKTtcbiAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBJbnQzMkFycmF5KVxuICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZVR5cGVkQXJyYXkoXCJMXCIsIHZhbHVlKTtcbiAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50MzJBcnJheSlcbiAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVUeXBlZEFycmF5KFwibFwiLCB2YWx1ZSk7XG4gICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KVxuICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZVR5cGVkQXJyYXkoXCJHXCIsIHZhbHVlKTtcbiAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkpXG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplVHlwZWRBcnJheShcImdcIiwgdmFsdWUpO1xuICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEJpZ0ludDY0QXJyYXkpXG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplVHlwZWRBcnJheShcIk1cIiwgdmFsdWUpO1xuICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEJpZ1VpbnQ2NEFycmF5KVxuICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZVR5cGVkQXJyYXkoXCJtXCIsIHZhbHVlKTtcbiAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRhVmlldykgcmV0dXJuIHNlcmlhbGl6ZVR5cGVkQXJyYXkoXCJWXCIsIHZhbHVlKTtcbiAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgQmxvYiAmJiB2YWx1ZSBpbnN0YW5jZW9mIEJsb2IpXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICBudWxsID09PSBmb3JtRGF0YSAmJiAoZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKSksXG4gICAgICAgICAgICAgIChrZXkgPSBuZXh0UGFydElkKyspLFxuICAgICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoZm9ybUZpZWxkUHJlZml4ICsga2V5LCB2YWx1ZSksXG4gICAgICAgICAgICAgIFwiJEJcIiArIGtleS50b1N0cmluZygxNilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKChwYXJlbnRSZWZlcmVuY2UgPSBnZXRJdGVyYXRvckZuKHZhbHVlKSkpXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAocGFyZW50UmVmZXJlbmNlID0gcGFyZW50UmVmZXJlbmNlLmNhbGwodmFsdWUpKSxcbiAgICAgICAgICAgICAgcGFyZW50UmVmZXJlbmNlID09PSB2YWx1ZVxuICAgICAgICAgICAgICAgID8gKChrZXkgPSBuZXh0UGFydElkKyspLFxuICAgICAgICAgICAgICAgICAgKHBhcmVudFJlZmVyZW5jZSA9IHNlcmlhbGl6ZU1vZGVsKFxuICAgICAgICAgICAgICAgICAgICBBcnJheS5mcm9tKHBhcmVudFJlZmVyZW5jZSksXG4gICAgICAgICAgICAgICAgICAgIGtleVxuICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgICBudWxsID09PSBmb3JtRGF0YSAmJiAoZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKSksXG4gICAgICAgICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoZm9ybUZpZWxkUHJlZml4ICsga2V5LCBwYXJlbnRSZWZlcmVuY2UpLFxuICAgICAgICAgICAgICAgICAgXCIkaVwiICsga2V5LnRvU3RyaW5nKDE2KSlcbiAgICAgICAgICAgICAgICA6IEFycmF5LmZyb20ocGFyZW50UmVmZXJlbmNlKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBSZWFkYWJsZVN0cmVhbSAmJlxuICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbVxuICAgICAgICAgIClcbiAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVSZWFkYWJsZVN0cmVhbSh2YWx1ZSk7XG4gICAgICAgICAgcGFyZW50UmVmZXJlbmNlID0gdmFsdWVbQVNZTkNfSVRFUkFUT1JdO1xuICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBwYXJlbnRSZWZlcmVuY2UpXG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplQXN5bmNJdGVyYWJsZSh2YWx1ZSwgcGFyZW50UmVmZXJlbmNlLmNhbGwodmFsdWUpKTtcbiAgICAgICAgICBwYXJlbnRSZWZlcmVuY2UgPSBnZXRQcm90b3R5cGVPZih2YWx1ZSk7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgcGFyZW50UmVmZXJlbmNlICE9PSBPYmplY3RQcm90b3R5cGUgJiZcbiAgICAgICAgICAgIChudWxsID09PSBwYXJlbnRSZWZlcmVuY2UgfHxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gZ2V0UHJvdG90eXBlT2YocGFyZW50UmVmZXJlbmNlKSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IHRlbXBvcmFyeVJlZmVyZW5jZXMpXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiT25seSBwbGFpbiBvYmplY3RzLCBhbmQgYSBmZXcgYnVpbHQtaW5zLCBjYW4gYmUgcGFzc2VkIHRvIFNlcnZlciBGdW5jdGlvbnMuIENsYXNzZXMgb3IgbnVsbCBwcm90b3R5cGVzIGFyZSBub3Qgc3VwcG9ydGVkLlwiICtcbiAgICAgICAgICAgICAgICAgIGRlc2NyaWJlT2JqZWN0Rm9yRXJyb3JNZXNzYWdlKHRoaXMsIGtleSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBcIiRUXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhbHVlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEVcbiAgICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIlJlYWN0IENvbnRleHQgUHJvdmlkZXJzIGNhbm5vdCBiZSBwYXNzZWQgdG8gU2VydmVyIEZ1bmN0aW9ucyBmcm9tIHRoZSBDbGllbnQuJXNcIixcbiAgICAgICAgICAgICAgICBkZXNjcmliZU9iamVjdEZvckVycm9yTWVzc2FnZSh0aGlzLCBrZXkpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIDogXCJPYmplY3RcIiAhPT0gb2JqZWN0TmFtZSh2YWx1ZSlcbiAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJPbmx5IHBsYWluIG9iamVjdHMgY2FuIGJlIHBhc3NlZCB0byBTZXJ2ZXIgRnVuY3Rpb25zIGZyb20gdGhlIENsaWVudC4gJXMgb2JqZWN0cyBhcmUgbm90IHN1cHBvcnRlZC4lc1wiLFxuICAgICAgICAgICAgICAgICAgb2JqZWN0TmFtZSh2YWx1ZSksXG4gICAgICAgICAgICAgICAgICBkZXNjcmliZU9iamVjdEZvckVycm9yTWVzc2FnZSh0aGlzLCBrZXkpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICA6IGlzU2ltcGxlT2JqZWN0KHZhbHVlKVxuICAgICAgICAgICAgICAgID8gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyAmJlxuICAgICAgICAgICAgICAgICAgKChwYXJlbnRSZWZlcmVuY2UgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHZhbHVlKSksXG4gICAgICAgICAgICAgICAgICAwIDwgcGFyZW50UmVmZXJlbmNlLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgIFwiT25seSBwbGFpbiBvYmplY3RzIGNhbiBiZSBwYXNzZWQgdG8gU2VydmVyIEZ1bmN0aW9ucyBmcm9tIHRoZSBDbGllbnQuIE9iamVjdHMgd2l0aCBzeW1ib2wgcHJvcGVydGllcyBsaWtlICVzIGFyZSBub3Qgc3VwcG9ydGVkLiVzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgcGFyZW50UmVmZXJlbmNlWzBdLmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaWJlT2JqZWN0Rm9yRXJyb3JNZXNzYWdlKHRoaXMsIGtleSlcbiAgICAgICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgICA6IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiT25seSBwbGFpbiBvYmplY3RzIGNhbiBiZSBwYXNzZWQgdG8gU2VydmVyIEZ1bmN0aW9ucyBmcm9tIHRoZSBDbGllbnQuIENsYXNzZXMgb3Igb3RoZXIgb2JqZWN0cyB3aXRoIG1ldGhvZHMgYXJlIG5vdCBzdXBwb3J0ZWQuJXNcIixcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpYmVPYmplY3RGb3JFcnJvck1lc3NhZ2UodGhpcywga2V5KVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICAgIGlmIChcIlpcIiA9PT0gdmFsdWVbdmFsdWUubGVuZ3RoIC0gMV0gJiYgdGhpc1trZXldIGluc3RhbmNlb2YgRGF0ZSlcbiAgICAgICAgICAgIHJldHVybiBcIiREXCIgKyB2YWx1ZTtcbiAgICAgICAgICBrZXkgPSBcIiRcIiA9PT0gdmFsdWVbMF0gPyBcIiRcIiArIHZhbHVlIDogdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJib29sZWFuXCIgPT09IHR5cGVvZiB2YWx1ZSkgcmV0dXJuIHZhbHVlO1xuICAgICAgICBpZiAoXCJudW1iZXJcIiA9PT0gdHlwZW9mIHZhbHVlKSByZXR1cm4gc2VyaWFsaXplTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgaWYgKFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiB2YWx1ZSkgcmV0dXJuIFwiJHVuZGVmaW5lZFwiO1xuICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgICBwYXJlbnRSZWZlcmVuY2UgPSBrbm93blNlcnZlclJlZmVyZW5jZXMuZ2V0KHZhbHVlKTtcbiAgICAgICAgICBpZiAodm9pZCAwICE9PSBwYXJlbnRSZWZlcmVuY2UpXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAoa2V5ID0gSlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgICAgeyBpZDogcGFyZW50UmVmZXJlbmNlLmlkLCBib3VuZDogcGFyZW50UmVmZXJlbmNlLmJvdW5kIH0sXG4gICAgICAgICAgICAgICAgcmVzb2x2ZVRvSlNPTlxuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgbnVsbCA9PT0gZm9ybURhdGEgJiYgKGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCkpLFxuICAgICAgICAgICAgICAocGFyZW50UmVmZXJlbmNlID0gbmV4dFBhcnRJZCsrKSxcbiAgICAgICAgICAgICAgZm9ybURhdGEuc2V0KGZvcm1GaWVsZFByZWZpeCArIHBhcmVudFJlZmVyZW5jZSwga2V5KSxcbiAgICAgICAgICAgICAgXCIkRlwiICsgcGFyZW50UmVmZXJlbmNlLnRvU3RyaW5nKDE2KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICB2b2lkIDAgIT09IHRlbXBvcmFyeVJlZmVyZW5jZXMgJiZcbiAgICAgICAgICAgIC0xID09PSBrZXkuaW5kZXhPZihcIjpcIikgJiZcbiAgICAgICAgICAgICgocGFyZW50UmVmZXJlbmNlID0gd3JpdHRlbk9iamVjdHMuZ2V0KHRoaXMpKSxcbiAgICAgICAgICAgIHZvaWQgMCAhPT0gcGFyZW50UmVmZXJlbmNlKVxuICAgICAgICAgIClcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIHRlbXBvcmFyeVJlZmVyZW5jZXMuc2V0KHBhcmVudFJlZmVyZW5jZSArIFwiOlwiICsga2V5LCB2YWx1ZSksIFwiJFRcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiQ2xpZW50IEZ1bmN0aW9ucyBjYW5ub3QgYmUgcGFzc2VkIGRpcmVjdGx5IHRvIFNlcnZlciBGdW5jdGlvbnMuIE9ubHkgRnVuY3Rpb25zIHBhc3NlZCBmcm9tIHRoZSBTZXJ2ZXIgY2FuIGJlIHBhc3NlZCBiYWNrIGFnYWluLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJzeW1ib2xcIiA9PT0gdHlwZW9mIHZhbHVlKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgdm9pZCAwICE9PSB0ZW1wb3JhcnlSZWZlcmVuY2VzICYmXG4gICAgICAgICAgICAtMSA9PT0ga2V5LmluZGV4T2YoXCI6XCIpICYmXG4gICAgICAgICAgICAoKHBhcmVudFJlZmVyZW5jZSA9IHdyaXR0ZW5PYmplY3RzLmdldCh0aGlzKSksXG4gICAgICAgICAgICB2b2lkIDAgIT09IHBhcmVudFJlZmVyZW5jZSlcbiAgICAgICAgICApXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICB0ZW1wb3JhcnlSZWZlcmVuY2VzLnNldChwYXJlbnRSZWZlcmVuY2UgKyBcIjpcIiArIGtleSwgdmFsdWUpLCBcIiRUXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIlN5bWJvbHMgY2Fubm90IGJlIHBhc3NlZCB0byBhIFNlcnZlciBGdW5jdGlvbiB3aXRob3V0IGEgdGVtcG9yYXJ5IHJlZmVyZW5jZSBzZXQuIFBhc3MgYSBUZW1wb3JhcnlSZWZlcmVuY2VTZXQgdG8gdGhlIG9wdGlvbnMuXCIgK1xuICAgICAgICAgICAgICBkZXNjcmliZU9iamVjdEZvckVycm9yTWVzc2FnZSh0aGlzLCBrZXkpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJiaWdpbnRcIiA9PT0gdHlwZW9mIHZhbHVlKSByZXR1cm4gXCIkblwiICsgdmFsdWUudG9TdHJpbmcoMTApO1xuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIlR5cGUgXCIgK1xuICAgICAgICAgICAgdHlwZW9mIHZhbHVlICtcbiAgICAgICAgICAgIFwiIGlzIG5vdCBzdXBwb3J0ZWQgYXMgYW4gYXJndW1lbnQgdG8gYSBTZXJ2ZXIgRnVuY3Rpb24uXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHNlcmlhbGl6ZU1vZGVsKG1vZGVsLCBpZCkge1xuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgbW9kZWwgJiZcbiAgICAgICAgICBudWxsICE9PSBtb2RlbCAmJlxuICAgICAgICAgICgoaWQgPSBcIiRcIiArIGlkLnRvU3RyaW5nKDE2KSksXG4gICAgICAgICAgd3JpdHRlbk9iamVjdHMuc2V0KG1vZGVsLCBpZCksXG4gICAgICAgICAgdm9pZCAwICE9PSB0ZW1wb3JhcnlSZWZlcmVuY2VzICYmIHRlbXBvcmFyeVJlZmVyZW5jZXMuc2V0KGlkLCBtb2RlbCkpO1xuICAgICAgICBtb2RlbFJvb3QgPSBtb2RlbDtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG1vZGVsLCByZXNvbHZlVG9KU09OKTtcbiAgICAgIH1cbiAgICAgIHZhciBuZXh0UGFydElkID0gMSxcbiAgICAgICAgcGVuZGluZ1BhcnRzID0gMCxcbiAgICAgICAgZm9ybURhdGEgPSBudWxsLFxuICAgICAgICB3cml0dGVuT2JqZWN0cyA9IG5ldyBXZWFrTWFwKCksXG4gICAgICAgIG1vZGVsUm9vdCA9IHJvb3QsXG4gICAgICAgIGpzb24gPSBzZXJpYWxpemVNb2RlbChyb290LCAwKTtcbiAgICAgIG51bGwgPT09IGZvcm1EYXRhXG4gICAgICAgID8gcmVzb2x2ZShqc29uKVxuICAgICAgICA6IChmb3JtRGF0YS5zZXQoZm9ybUZpZWxkUHJlZml4ICsgXCIwXCIsIGpzb24pLFxuICAgICAgICAgIDAgPT09IHBlbmRpbmdQYXJ0cyAmJiByZXNvbHZlKGZvcm1EYXRhKSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAwIDwgcGVuZGluZ1BhcnRzICYmXG4gICAgICAgICAgKChwZW5kaW5nUGFydHMgPSAwKSxcbiAgICAgICAgICBudWxsID09PSBmb3JtRGF0YSA/IHJlc29sdmUoanNvbikgOiByZXNvbHZlKGZvcm1EYXRhKSk7XG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVGYWtlU2VydmVyRnVuY3Rpb24oXG4gICAgICBuYW1lLFxuICAgICAgZmlsZW5hbWUsXG4gICAgICBzb3VyY2VNYXAsXG4gICAgICBsaW5lLFxuICAgICAgY29sLFxuICAgICAgZW52aXJvbm1lbnROYW1lLFxuICAgICAgaW5uZXJGdW5jdGlvblxuICAgICkge1xuICAgICAgbmFtZSB8fCAobmFtZSA9IFwiPGFub255bW91cz5cIik7XG4gICAgICB2YXIgZW5jb2RlZE5hbWUgPSBKU09OLnN0cmluZ2lmeShuYW1lKTtcbiAgICAgIDEgPj0gbGluZVxuICAgICAgICA/ICgobGluZSA9IGVuY29kZWROYW1lLmxlbmd0aCArIDcpLFxuICAgICAgICAgIChjb2wgPVxuICAgICAgICAgICAgXCJzPT4oe1wiICtcbiAgICAgICAgICAgIGVuY29kZWROYW1lICtcbiAgICAgICAgICAgIFwiIFwiLnJlcGVhdChjb2wgPCBsaW5lID8gMCA6IGNvbCAtIGxpbmUpICtcbiAgICAgICAgICAgIFwiOiguLi5hcmdzKSA9PiBzKC4uLmFyZ3MpfSlcXG4vKiBUaGlzIG1vZHVsZSBpcyBhIHByb3h5IHRvIGEgU2VydmVyIEFjdGlvbi4gVHVybiBvbiBTb3VyY2UgTWFwcyB0byBzZWUgdGhlIHNlcnZlciBzb3VyY2UuICovXCIpKVxuICAgICAgICA6IChjb2wgPVxuICAgICAgICAgICAgXCIvKiBUaGlzIG1vZHVsZSBpcyBhIHByb3h5IHRvIGEgU2VydmVyIEFjdGlvbi4gVHVybiBvbiBTb3VyY2UgTWFwcyB0byBzZWUgdGhlIHNlcnZlciBzb3VyY2UuICovXCIgK1xuICAgICAgICAgICAgXCJcXG5cIi5yZXBlYXQobGluZSAtIDIpICtcbiAgICAgICAgICAgIFwic2VydmVyPT4oe1wiICtcbiAgICAgICAgICAgIGVuY29kZWROYW1lICtcbiAgICAgICAgICAgIFwiOlxcblwiICtcbiAgICAgICAgICAgIFwiIFwiLnJlcGVhdCgxID4gY29sID8gMCA6IGNvbCAtIDEpICtcbiAgICAgICAgICAgIFwiKC4uLmFyZ3MpID0+IHNlcnZlciguLi5hcmdzKX0pXCIpO1xuICAgICAgZmlsZW5hbWUuc3RhcnRzV2l0aChcIi9cIikgJiYgKGZpbGVuYW1lID0gXCJmaWxlOi8vXCIgKyBmaWxlbmFtZSk7XG4gICAgICBzb3VyY2VNYXBcbiAgICAgICAgPyAoKGNvbCArPVxuICAgICAgICAgICAgXCJcXG4vLyMgc291cmNlVVJMPXJzYzovL1JlYWN0L1wiICtcbiAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChlbnZpcm9ubWVudE5hbWUpICtcbiAgICAgICAgICAgIFwiL1wiICtcbiAgICAgICAgICAgIGVuY29kZVVSSShmaWxlbmFtZSkgK1xuICAgICAgICAgICAgXCI/c1wiICtcbiAgICAgICAgICAgIGZha2VTZXJ2ZXJGdW5jdGlvbklkeCsrKSxcbiAgICAgICAgICAoY29sICs9IFwiXFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9XCIgKyBzb3VyY2VNYXApKVxuICAgICAgICA6IGZpbGVuYW1lICYmIChjb2wgKz0gXCJcXG4vLyMgc291cmNlVVJMPVwiICsgZmlsZW5hbWUpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuICgwLCBldmFsKShjb2wpKGlubmVyRnVuY3Rpb24pW25hbWVdO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICByZXR1cm4gaW5uZXJGdW5jdGlvbjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJCb3VuZFNlcnZlclJlZmVyZW5jZShyZWZlcmVuY2UsIGlkLCBib3VuZCkge1xuICAgICAga25vd25TZXJ2ZXJSZWZlcmVuY2VzLmhhcyhyZWZlcmVuY2UpIHx8XG4gICAgICAgIGtub3duU2VydmVyUmVmZXJlbmNlcy5zZXQocmVmZXJlbmNlLCB7XG4gICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgIG9yaWdpbmFsQmluZDogcmVmZXJlbmNlLmJpbmQsXG4gICAgICAgICAgYm91bmQ6IGJvdW5kXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVCb3VuZFNlcnZlclJlZmVyZW5jZShcbiAgICAgIG1ldGFEYXRhLFxuICAgICAgY2FsbFNlcnZlcixcbiAgICAgIGVuY29kZUZvcm1BY3Rpb24sXG4gICAgICBmaW5kU291cmNlTWFwVVJMXG4gICAgKSB7XG4gICAgICBmdW5jdGlvbiBhY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIGJvdW5kXG4gICAgICAgICAgPyBcImZ1bGZpbGxlZFwiID09PSBib3VuZC5zdGF0dXNcbiAgICAgICAgICAgID8gY2FsbFNlcnZlcihpZCwgYm91bmQudmFsdWUuY29uY2F0KGFyZ3MpKVxuICAgICAgICAgICAgOiBQcm9taXNlLnJlc29sdmUoYm91bmQpLnRoZW4oZnVuY3Rpb24gKGJvdW5kQXJncykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsU2VydmVyKGlkLCBib3VuZEFyZ3MuY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICA6IGNhbGxTZXJ2ZXIoaWQsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgdmFyIGlkID0gbWV0YURhdGEuaWQsXG4gICAgICAgIGJvdW5kID0gbWV0YURhdGEuYm91bmQsXG4gICAgICAgIGxvY2F0aW9uID0gbWV0YURhdGEubG9jYXRpb247XG4gICAgICBpZiAobG9jYXRpb24pIHtcbiAgICAgICAgZW5jb2RlRm9ybUFjdGlvbiA9IG1ldGFEYXRhLm5hbWUgfHwgXCJcIjtcbiAgICAgICAgdmFyIGZpbGVuYW1lID0gbG9jYXRpb25bMV0sXG4gICAgICAgICAgbGluZSA9IGxvY2F0aW9uWzJdO1xuICAgICAgICBsb2NhdGlvbiA9IGxvY2F0aW9uWzNdO1xuICAgICAgICBtZXRhRGF0YSA9IG1ldGFEYXRhLmVudiB8fCBcIlNlcnZlclwiO1xuICAgICAgICBmaW5kU291cmNlTWFwVVJMID1cbiAgICAgICAgICBudWxsID09IGZpbmRTb3VyY2VNYXBVUkxcbiAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgOiBmaW5kU291cmNlTWFwVVJMKGZpbGVuYW1lLCBtZXRhRGF0YSk7XG4gICAgICAgIGFjdGlvbiA9IGNyZWF0ZUZha2VTZXJ2ZXJGdW5jdGlvbihcbiAgICAgICAgICBlbmNvZGVGb3JtQWN0aW9uLFxuICAgICAgICAgIGZpbGVuYW1lLFxuICAgICAgICAgIGZpbmRTb3VyY2VNYXBVUkwsXG4gICAgICAgICAgbGluZSxcbiAgICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgICBtZXRhRGF0YSxcbiAgICAgICAgICBhY3Rpb25cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJlZ2lzdGVyQm91bmRTZXJ2ZXJSZWZlcmVuY2UoYWN0aW9uLCBpZCwgYm91bmQpO1xuICAgICAgcmV0dXJuIGFjdGlvbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VTdGFja0xvY2F0aW9uKGVycm9yKSB7XG4gICAgICBlcnJvciA9IGVycm9yLnN0YWNrO1xuICAgICAgZXJyb3Iuc3RhcnRzV2l0aChcIkVycm9yOiByZWFjdC1zdGFjay10b3AtZnJhbWVcXG5cIikgJiZcbiAgICAgICAgKGVycm9yID0gZXJyb3Iuc2xpY2UoMjkpKTtcbiAgICAgIHZhciBlbmRPZkZpcnN0ID0gZXJyb3IuaW5kZXhPZihcIlxcblwiKTtcbiAgICAgIGlmICgtMSAhPT0gZW5kT2ZGaXJzdCkge1xuICAgICAgICB2YXIgZW5kT2ZTZWNvbmQgPSBlcnJvci5pbmRleE9mKFwiXFxuXCIsIGVuZE9mRmlyc3QgKyAxKTtcbiAgICAgICAgZW5kT2ZGaXJzdCA9XG4gICAgICAgICAgLTEgPT09IGVuZE9mU2Vjb25kXG4gICAgICAgICAgICA/IGVycm9yLnNsaWNlKGVuZE9mRmlyc3QgKyAxKVxuICAgICAgICAgICAgOiBlcnJvci5zbGljZShlbmRPZkZpcnN0ICsgMSwgZW5kT2ZTZWNvbmQpO1xuICAgICAgfSBlbHNlIGVuZE9mRmlyc3QgPSBlcnJvcjtcbiAgICAgIGVycm9yID0gdjhGcmFtZVJlZ0V4cC5leGVjKGVuZE9mRmlyc3QpO1xuICAgICAgaWYgKFxuICAgICAgICAhZXJyb3IgJiZcbiAgICAgICAgKChlcnJvciA9IGpzY1NwaWRlck1vbmtleUZyYW1lUmVnRXhwLmV4ZWMoZW5kT2ZGaXJzdCkpLCAhZXJyb3IpXG4gICAgICApXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgZW5kT2ZGaXJzdCA9IGVycm9yWzFdIHx8IFwiXCI7XG4gICAgICBcIjxhbm9ueW1vdXM+XCIgPT09IGVuZE9mRmlyc3QgJiYgKGVuZE9mRmlyc3QgPSBcIlwiKTtcbiAgICAgIGVuZE9mU2Vjb25kID0gZXJyb3JbMl0gfHwgZXJyb3JbNV0gfHwgXCJcIjtcbiAgICAgIFwiPGFub255bW91cz5cIiA9PT0gZW5kT2ZTZWNvbmQgJiYgKGVuZE9mU2Vjb25kID0gXCJcIik7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBlbmRPZkZpcnN0LFxuICAgICAgICBlbmRPZlNlY29uZCxcbiAgICAgICAgKyhlcnJvclszXSB8fCBlcnJvcls2XSksXG4gICAgICAgICsoZXJyb3JbNF0gfHwgZXJyb3JbN10pXG4gICAgICBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkge1xuICAgICAgaWYgKG51bGwgPT0gdHlwZSkgcmV0dXJuIG51bGw7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgcmV0dXJuIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0VcbiAgICAgICAgICA/IG51bGxcbiAgICAgICAgICA6IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHR5cGUpIHJldHVybiB0eXBlO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJGcmFnbWVudFwiO1xuICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiUHJvZmlsZXJcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN0cmljdE1vZGVcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlTGlzdFwiO1xuICAgICAgICBjYXNlIFJFQUNUX0FDVElWSVRZX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiQWN0aXZpdHlcIjtcbiAgICAgIH1cbiAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgc3dpdGNoIChcbiAgICAgICAgICAoXCJudW1iZXJcIiA9PT0gdHlwZW9mIHR5cGUudGFnICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgdHlwZS4kJHR5cGVvZilcbiAgICAgICAgKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiBcIlBvcnRhbFwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgXCJDb250ZXh0XCI7XG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuICh0eXBlLl9jb250ZXh0LmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiKSArIFwiLkNvbnN1bWVyXCI7XG4gICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgdmFyIGlubmVyVHlwZSA9IHR5cGUucmVuZGVyO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuZGlzcGxheU5hbWU7XG4gICAgICAgICAgICB0eXBlIHx8XG4gICAgICAgICAgICAgICgodHlwZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCBcIlwiKSxcbiAgICAgICAgICAgICAgKHR5cGUgPSBcIlwiICE9PSB0eXBlID8gXCJGb3J3YXJkUmVmKFwiICsgdHlwZSArIFwiKVwiIDogXCJGb3J3YXJkUmVmXCIpKTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKGlubmVyVHlwZSA9IHR5cGUuZGlzcGxheU5hbWUgfHwgbnVsbCksXG4gICAgICAgICAgICAgIG51bGwgIT09IGlubmVyVHlwZVxuICAgICAgICAgICAgICAgID8gaW5uZXJUeXBlXG4gICAgICAgICAgICAgICAgOiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCBcIk1lbW9cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgIGlubmVyVHlwZSA9IHR5cGUuX3BheWxvYWQ7XG4gICAgICAgICAgICB0eXBlID0gdHlwZS5faW5pdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZShpbm5lclR5cGUpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFjdFByb21pc2Uoc3RhdHVzLCB2YWx1ZSwgcmVhc29uKSB7XG4gICAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIHRoaXMucmVhc29uID0gcmVhc29uO1xuICAgICAgdGhpcy5fZGVidWdJbmZvID0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdW53cmFwV2Vha1Jlc3BvbnNlKHdlYWtSZXNwb25zZSkge1xuICAgICAgd2Vha1Jlc3BvbnNlID0gd2Vha1Jlc3BvbnNlLndlYWsuZGVyZWYoKTtcbiAgICAgIGlmICh2b2lkIDAgPT09IHdlYWtSZXNwb25zZSlcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJXZSBkaWQgbm90IGV4cGVjdCB0byByZWNlaXZlIG5ldyBkYXRhIGFmdGVyIEdDOmluZyB0aGUgcmVzcG9uc2UuXCJcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiB3ZWFrUmVzcG9uc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsZWFudXBEZWJ1Z0NoYW5uZWwoZGVidWdDaGFubmVsKSB7XG4gICAgICBkZWJ1Z0NoYW5uZWwoXCJcIik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlYWRDaHVuayhjaHVuaykge1xuICAgICAgc3dpdGNoIChjaHVuay5zdGF0dXMpIHtcbiAgICAgICAgY2FzZSBcInJlc29sdmVkX21vZGVsXCI6XG4gICAgICAgICAgaW5pdGlhbGl6ZU1vZGVsQ2h1bmsoY2h1bmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicmVzb2x2ZWRfbW9kdWxlXCI6XG4gICAgICAgICAgaW5pdGlhbGl6ZU1vZHVsZUNodW5rKGNodW5rKTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoY2h1bmsuc3RhdHVzKSB7XG4gICAgICAgIGNhc2UgXCJmdWxmaWxsZWRcIjpcbiAgICAgICAgICByZXR1cm4gY2h1bmsudmFsdWU7XG4gICAgICAgIGNhc2UgXCJwZW5kaW5nXCI6XG4gICAgICAgIGNhc2UgXCJibG9ja2VkXCI6XG4gICAgICAgIGNhc2UgXCJoYWx0ZWRcIjpcbiAgICAgICAgICB0aHJvdyBjaHVuaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBjaHVuay5yZWFzb247XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFJvb3Qod2Vha1Jlc3BvbnNlKSB7XG4gICAgICB3ZWFrUmVzcG9uc2UgPSB1bndyYXBXZWFrUmVzcG9uc2Uod2Vha1Jlc3BvbnNlKTtcbiAgICAgIHJldHVybiBnZXRDaHVuayh3ZWFrUmVzcG9uc2UsIDApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVQZW5kaW5nQ2h1bmsocmVzcG9uc2UpIHtcbiAgICAgIDAgPT09IHJlc3BvbnNlLl9wZW5kaW5nQ2h1bmtzKysgJiZcbiAgICAgICAgKChyZXNwb25zZS5fd2Vha1Jlc3BvbnNlLnJlc3BvbnNlID0gcmVzcG9uc2UpLFxuICAgICAgICBudWxsICE9PSByZXNwb25zZS5fcGVuZGluZ0luaXRpYWxSZW5kZXIgJiZcbiAgICAgICAgICAoY2xlYXJUaW1lb3V0KHJlc3BvbnNlLl9wZW5kaW5nSW5pdGlhbFJlbmRlciksXG4gICAgICAgICAgKHJlc3BvbnNlLl9wZW5kaW5nSW5pdGlhbFJlbmRlciA9IG51bGwpKSk7XG4gICAgICByZXR1cm4gbmV3IFJlYWN0UHJvbWlzZShcInBlbmRpbmdcIiwgbnVsbCwgbnVsbCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbGVhc2VQZW5kaW5nQ2h1bmsocmVzcG9uc2UsIGNodW5rKSB7XG4gICAgICBcInBlbmRpbmdcIiA9PT0gY2h1bmsuc3RhdHVzICYmXG4gICAgICAgIDAgPT09IC0tcmVzcG9uc2UuX3BlbmRpbmdDaHVua3MgJiZcbiAgICAgICAgKChyZXNwb25zZS5fd2Vha1Jlc3BvbnNlLnJlc3BvbnNlID0gbnVsbCksXG4gICAgICAgIChyZXNwb25zZS5fcGVuZGluZ0luaXRpYWxSZW5kZXIgPSBzZXRUaW1lb3V0KFxuICAgICAgICAgIGZsdXNoSW5pdGlhbFJlbmRlclBlcmZvcm1hbmNlLmJpbmQobnVsbCwgcmVzcG9uc2UpLFxuICAgICAgICAgIDEwMFxuICAgICAgICApKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdha2VDaHVuayhsaXN0ZW5lcnMsIHZhbHVlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbaV07XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGxpc3RlbmVyXG4gICAgICAgICAgPyBsaXN0ZW5lcih2YWx1ZSlcbiAgICAgICAgICA6IGZ1bGZpbGxSZWZlcmVuY2UobGlzdGVuZXIsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVqZWN0Q2h1bmsobGlzdGVuZXJzLCBlcnJvcikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJzW2ldO1xuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBsaXN0ZW5lclxuICAgICAgICAgID8gbGlzdGVuZXIoZXJyb3IpXG4gICAgICAgICAgOiByZWplY3RSZWZlcmVuY2UobGlzdGVuZXIsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzb2x2ZUJsb2NrZWRDeWNsZShyZXNvbHZlZENodW5rLCByZWZlcmVuY2UpIHtcbiAgICAgIHZhciByZWZlcmVuY2VkQ2h1bmsgPSByZWZlcmVuY2UuaGFuZGxlci5jaHVuaztcbiAgICAgIGlmIChudWxsID09PSByZWZlcmVuY2VkQ2h1bmspIHJldHVybiBudWxsO1xuICAgICAgaWYgKHJlZmVyZW5jZWRDaHVuayA9PT0gcmVzb2x2ZWRDaHVuaykgcmV0dXJuIHJlZmVyZW5jZS5oYW5kbGVyO1xuICAgICAgcmVmZXJlbmNlID0gcmVmZXJlbmNlZENodW5rLnZhbHVlO1xuICAgICAgaWYgKG51bGwgIT09IHJlZmVyZW5jZSlcbiAgICAgICAgZm9yIChcbiAgICAgICAgICByZWZlcmVuY2VkQ2h1bmsgPSAwO1xuICAgICAgICAgIHJlZmVyZW5jZWRDaHVuayA8IHJlZmVyZW5jZS5sZW5ndGg7XG4gICAgICAgICAgcmVmZXJlbmNlZENodW5rKytcbiAgICAgICAgKSB7XG4gICAgICAgICAgdmFyIGxpc3RlbmVyID0gcmVmZXJlbmNlW3JlZmVyZW5jZWRDaHVua107XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgbGlzdGVuZXIgJiZcbiAgICAgICAgICAgICgobGlzdGVuZXIgPSByZXNvbHZlQmxvY2tlZEN5Y2xlKHJlc29sdmVkQ2h1bmssIGxpc3RlbmVyKSksXG4gICAgICAgICAgICBudWxsICE9PSBsaXN0ZW5lcilcbiAgICAgICAgICApXG4gICAgICAgICAgICByZXR1cm4gbGlzdGVuZXI7XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3YWtlQ2h1bmtJZkluaXRpYWxpemVkKGNodW5rLCByZXNvbHZlTGlzdGVuZXJzLCByZWplY3RMaXN0ZW5lcnMpIHtcbiAgICAgIHN3aXRjaCAoY2h1bmsuc3RhdHVzKSB7XG4gICAgICAgIGNhc2UgXCJmdWxmaWxsZWRcIjpcbiAgICAgICAgICB3YWtlQ2h1bmsocmVzb2x2ZUxpc3RlbmVycywgY2h1bmsudmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYmxvY2tlZFwiOlxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzb2x2ZUxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gcmVzb2x2ZUxpc3RlbmVyc1tpXTtcbiAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBsaXN0ZW5lcikge1xuICAgICAgICAgICAgICB2YXIgY3ljbGljSGFuZGxlciA9IHJlc29sdmVCbG9ja2VkQ3ljbGUoY2h1bmssIGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgbnVsbCAhPT0gY3ljbGljSGFuZGxlciAmJlxuICAgICAgICAgICAgICAgIChmdWxmaWxsUmVmZXJlbmNlKGxpc3RlbmVyLCBjeWNsaWNIYW5kbGVyLnZhbHVlKSxcbiAgICAgICAgICAgICAgICByZXNvbHZlTGlzdGVuZXJzLnNwbGljZShpLCAxKSxcbiAgICAgICAgICAgICAgICBpLS0sXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gcmVqZWN0TGlzdGVuZXJzICYmXG4gICAgICAgICAgICAgICAgICAoKGxpc3RlbmVyID0gcmVqZWN0TGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpKSxcbiAgICAgICAgICAgICAgICAgIC0xICE9PSBsaXN0ZW5lciAmJiByZWplY3RMaXN0ZW5lcnMuc3BsaWNlKGxpc3RlbmVyLCAxKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBcInBlbmRpbmdcIjpcbiAgICAgICAgICBpZiAoY2h1bmsudmFsdWUpXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcmVzb2x2ZUxpc3RlbmVycy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgY2h1bmsudmFsdWUucHVzaChyZXNvbHZlTGlzdGVuZXJzW2ldKTtcbiAgICAgICAgICBlbHNlIGNodW5rLnZhbHVlID0gcmVzb2x2ZUxpc3RlbmVycztcbiAgICAgICAgICBpZiAoY2h1bmsucmVhc29uKSB7XG4gICAgICAgICAgICBpZiAocmVqZWN0TGlzdGVuZXJzKVxuICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgIHJlc29sdmVMaXN0ZW5lcnMgPSAwO1xuICAgICAgICAgICAgICAgIHJlc29sdmVMaXN0ZW5lcnMgPCByZWplY3RMaXN0ZW5lcnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHJlc29sdmVMaXN0ZW5lcnMrK1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgY2h1bmsucmVhc29uLnB1c2gocmVqZWN0TGlzdGVuZXJzW3Jlc29sdmVMaXN0ZW5lcnNdKTtcbiAgICAgICAgICB9IGVsc2UgY2h1bmsucmVhc29uID0gcmVqZWN0TGlzdGVuZXJzO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicmVqZWN0ZWRcIjpcbiAgICAgICAgICByZWplY3RMaXN0ZW5lcnMgJiYgcmVqZWN0Q2h1bmsocmVqZWN0TGlzdGVuZXJzLCBjaHVuay5yZWFzb24pO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0cmlnZ2VyRXJyb3JPbkNodW5rKHJlc3BvbnNlLCBjaHVuaywgZXJyb3IpIHtcbiAgICAgIFwicGVuZGluZ1wiICE9PSBjaHVuay5zdGF0dXMgJiYgXCJibG9ja2VkXCIgIT09IGNodW5rLnN0YXR1c1xuICAgICAgICA/IGNodW5rLnJlYXNvbi5lcnJvcihlcnJvcilcbiAgICAgICAgOiAocmVsZWFzZVBlbmRpbmdDaHVuayhyZXNwb25zZSwgY2h1bmspLFxuICAgICAgICAgIChyZXNwb25zZSA9IGNodW5rLnJlYXNvbiksXG4gICAgICAgICAgKGNodW5rLnN0YXR1cyA9IFwicmVqZWN0ZWRcIiksXG4gICAgICAgICAgKGNodW5rLnJlYXNvbiA9IGVycm9yKSxcbiAgICAgICAgICBudWxsICE9PSByZXNwb25zZSAmJiByZWplY3RDaHVuayhyZXNwb25zZSwgZXJyb3IpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlUmVzb2x2ZWRJdGVyYXRvclJlc3VsdENodW5rKHJlc3BvbnNlLCB2YWx1ZSwgZG9uZSkge1xuICAgICAgcmV0dXJuIG5ldyBSZWFjdFByb21pc2UoXG4gICAgICAgIFwicmVzb2x2ZWRfbW9kZWxcIixcbiAgICAgICAgKGRvbmUgPyAne1wiZG9uZVwiOnRydWUsXCJ2YWx1ZVwiOicgOiAne1wiZG9uZVwiOmZhbHNlLFwidmFsdWVcIjonKSArXG4gICAgICAgICAgdmFsdWUgK1xuICAgICAgICAgIFwifVwiLFxuICAgICAgICByZXNwb25zZVxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzb2x2ZUl0ZXJhdG9yUmVzdWx0Q2h1bmsocmVzcG9uc2UsIGNodW5rLCB2YWx1ZSwgZG9uZSkge1xuICAgICAgcmVzb2x2ZU1vZGVsQ2h1bmsoXG4gICAgICAgIHJlc3BvbnNlLFxuICAgICAgICBjaHVuayxcbiAgICAgICAgKGRvbmUgPyAne1wiZG9uZVwiOnRydWUsXCJ2YWx1ZVwiOicgOiAne1wiZG9uZVwiOmZhbHNlLFwidmFsdWVcIjonKSArXG4gICAgICAgICAgdmFsdWUgK1xuICAgICAgICAgIFwifVwiXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNvbHZlTW9kZWxDaHVuayhyZXNwb25zZSwgY2h1bmssIHZhbHVlKSB7XG4gICAgICBpZiAoXCJwZW5kaW5nXCIgIT09IGNodW5rLnN0YXR1cykgY2h1bmsucmVhc29uLmVucXVldWVNb2RlbCh2YWx1ZSk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVsZWFzZVBlbmRpbmdDaHVuayhyZXNwb25zZSwgY2h1bmspO1xuICAgICAgICB2YXIgcmVzb2x2ZUxpc3RlbmVycyA9IGNodW5rLnZhbHVlLFxuICAgICAgICAgIHJlamVjdExpc3RlbmVycyA9IGNodW5rLnJlYXNvbjtcbiAgICAgICAgY2h1bmsuc3RhdHVzID0gXCJyZXNvbHZlZF9tb2RlbFwiO1xuICAgICAgICBjaHVuay52YWx1ZSA9IHZhbHVlO1xuICAgICAgICBjaHVuay5yZWFzb24gPSByZXNwb25zZTtcbiAgICAgICAgbnVsbCAhPT0gcmVzb2x2ZUxpc3RlbmVycyAmJlxuICAgICAgICAgIChpbml0aWFsaXplTW9kZWxDaHVuayhjaHVuayksXG4gICAgICAgICAgd2FrZUNodW5rSWZJbml0aWFsaXplZChjaHVuaywgcmVzb2x2ZUxpc3RlbmVycywgcmVqZWN0TGlzdGVuZXJzKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc29sdmVNb2R1bGVDaHVuayhyZXNwb25zZSwgY2h1bmssIHZhbHVlKSB7XG4gICAgICBpZiAoXCJwZW5kaW5nXCIgPT09IGNodW5rLnN0YXR1cyB8fCBcImJsb2NrZWRcIiA9PT0gY2h1bmsuc3RhdHVzKSB7XG4gICAgICAgIHJlbGVhc2VQZW5kaW5nQ2h1bmsocmVzcG9uc2UsIGNodW5rKTtcbiAgICAgICAgcmVzcG9uc2UgPSBjaHVuay52YWx1ZTtcbiAgICAgICAgdmFyIHJlamVjdExpc3RlbmVycyA9IGNodW5rLnJlYXNvbjtcbiAgICAgICAgY2h1bmsuc3RhdHVzID0gXCJyZXNvbHZlZF9tb2R1bGVcIjtcbiAgICAgICAgY2h1bmsudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgbnVsbCAhPT0gcmVzcG9uc2UgJiZcbiAgICAgICAgICAoaW5pdGlhbGl6ZU1vZHVsZUNodW5rKGNodW5rKSxcbiAgICAgICAgICB3YWtlQ2h1bmtJZkluaXRpYWxpemVkKGNodW5rLCByZXNwb25zZSwgcmVqZWN0TGlzdGVuZXJzKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGluaXRpYWxpemVNb2RlbENodW5rKGNodW5rKSB7XG4gICAgICB2YXIgcHJldkhhbmRsZXIgPSBpbml0aWFsaXppbmdIYW5kbGVyO1xuICAgICAgaW5pdGlhbGl6aW5nSGFuZGxlciA9IG51bGw7XG4gICAgICB2YXIgcmVzb2x2ZWRNb2RlbCA9IGNodW5rLnZhbHVlLFxuICAgICAgICByZXNwb25zZSA9IGNodW5rLnJlYXNvbjtcbiAgICAgIGNodW5rLnN0YXR1cyA9IFwiYmxvY2tlZFwiO1xuICAgICAgY2h1bmsudmFsdWUgPSBudWxsO1xuICAgICAgY2h1bmsucmVhc29uID0gbnVsbDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IEpTT04ucGFyc2UocmVzb2x2ZWRNb2RlbCwgcmVzcG9uc2UuX2Zyb21KU09OKSxcbiAgICAgICAgICByZXNvbHZlTGlzdGVuZXJzID0gY2h1bmsudmFsdWU7XG4gICAgICAgIG51bGwgIT09IHJlc29sdmVMaXN0ZW5lcnMgJiZcbiAgICAgICAgICAoKGNodW5rLnZhbHVlID0gbnVsbCksXG4gICAgICAgICAgKGNodW5rLnJlYXNvbiA9IG51bGwpLFxuICAgICAgICAgIHdha2VDaHVuayhyZXNvbHZlTGlzdGVuZXJzLCB2YWx1ZSkpO1xuICAgICAgICBpZiAobnVsbCAhPT0gaW5pdGlhbGl6aW5nSGFuZGxlcikge1xuICAgICAgICAgIGlmIChpbml0aWFsaXppbmdIYW5kbGVyLmVycm9yZWQpIHRocm93IGluaXRpYWxpemluZ0hhbmRsZXIudmFsdWU7XG4gICAgICAgICAgaWYgKDAgPCBpbml0aWFsaXppbmdIYW5kbGVyLmRlcHMpIHtcbiAgICAgICAgICAgIGluaXRpYWxpemluZ0hhbmRsZXIudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIGluaXRpYWxpemluZ0hhbmRsZXIuY2h1bmsgPSBjaHVuaztcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2h1bmsuc3RhdHVzID0gXCJmdWxmaWxsZWRcIjtcbiAgICAgICAgY2h1bmsudmFsdWUgPSB2YWx1ZTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIChjaHVuay5zdGF0dXMgPSBcInJlamVjdGVkXCIpLCAoY2h1bmsucmVhc29uID0gZXJyb3IpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaW5pdGlhbGl6aW5nSGFuZGxlciA9IHByZXZIYW5kbGVyO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBpbml0aWFsaXplTW9kdWxlQ2h1bmsoY2h1bmspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlcXVpcmVNb2R1bGUoY2h1bmsudmFsdWUpO1xuICAgICAgICBjaHVuay5zdGF0dXMgPSBcImZ1bGZpbGxlZFwiO1xuICAgICAgICBjaHVuay52YWx1ZSA9IHZhbHVlO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgKGNodW5rLnN0YXR1cyA9IFwicmVqZWN0ZWRcIiksIChjaHVuay5yZWFzb24gPSBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcG9ydEdsb2JhbEVycm9yKHdlYWtSZXNwb25zZSwgZXJyb3IpIHtcbiAgICAgIGlmICh2b2lkIDAgIT09IHdlYWtSZXNwb25zZS53ZWFrLmRlcmVmKCkpIHtcbiAgICAgICAgdmFyIHJlc3BvbnNlID0gdW53cmFwV2Vha1Jlc3BvbnNlKHdlYWtSZXNwb25zZSk7XG4gICAgICAgIHJlc3BvbnNlLl9jbG9zZWQgPSAhMDtcbiAgICAgICAgcmVzcG9uc2UuX2Nsb3NlZFJlYXNvbiA9IGVycm9yO1xuICAgICAgICByZXNwb25zZS5fY2h1bmtzLmZvckVhY2goZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgICAgXCJwZW5kaW5nXCIgPT09IGNodW5rLnN0YXR1cyAmJlxuICAgICAgICAgICAgdHJpZ2dlckVycm9yT25DaHVuayhyZXNwb25zZSwgY2h1bmssIGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHdlYWtSZXNwb25zZSA9IHJlc3BvbnNlLl9kZWJ1Z0NoYW5uZWw7XG4gICAgICAgIHZvaWQgMCAhPT0gd2Vha1Jlc3BvbnNlICYmXG4gICAgICAgICAgKHdlYWtSZXNwb25zZShcIlwiKSwgKHJlc3BvbnNlLl9kZWJ1Z0NoYW5uZWwgPSB2b2lkIDApKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbnVsbFJlZkdldHRlcigpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRUYXNrTmFtZSh0eXBlKSB7XG4gICAgICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkgcmV0dXJuIFwiPD5cIjtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlKSByZXR1cm4gJ1widXNlIGNsaWVudFwiJztcbiAgICAgIGlmIChcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUgJiZcbiAgICAgICAgbnVsbCAhPT0gdHlwZSAmJlxuICAgICAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEVcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIHR5cGUuX2luaXQgPT09IHJlYWRDaHVuayA/ICdcInVzZSBjbGllbnRcIicgOiBcIjwuLi4+XCI7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcbiAgICAgICAgcmV0dXJuIG5hbWUgPyBcIjxcIiArIG5hbWUgKyBcIj5cIiA6IFwiPC4uLj5cIjtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgcmV0dXJuIFwiPC4uLj5cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaW5pdGlhbGl6ZUVsZW1lbnQocmVzcG9uc2UsIGVsZW1lbnQpIHtcbiAgICAgIHZhciBzdGFjayA9IGVsZW1lbnQuX2RlYnVnU3RhY2ssXG4gICAgICAgIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICBudWxsID09PSBvd25lciAmJiAoZWxlbWVudC5fb3duZXIgPSByZXNwb25zZS5fZGVidWdSb290T3duZXIpO1xuICAgICAgdmFyIGVudiA9IHJlc3BvbnNlLl9yb290RW52aXJvbm1lbnROYW1lO1xuICAgICAgbnVsbCAhPT0gb3duZXIgJiYgbnVsbCAhPSBvd25lci5lbnYgJiYgKGVudiA9IG93bmVyLmVudik7XG4gICAgICB2YXIgbm9ybWFsaXplZFN0YWNrVHJhY2UgPSBudWxsO1xuICAgICAgbnVsbCA9PT0gb3duZXIgJiYgbnVsbCAhPSByZXNwb25zZS5fZGVidWdSb290U3RhY2tcbiAgICAgICAgPyAobm9ybWFsaXplZFN0YWNrVHJhY2UgPSByZXNwb25zZS5fZGVidWdSb290U3RhY2spXG4gICAgICAgIDogbnVsbCAhPT0gc3RhY2sgJiZcbiAgICAgICAgICAobm9ybWFsaXplZFN0YWNrVHJhY2UgPSBjcmVhdGVGYWtlSlNYQ2FsbFN0YWNrSW5ERVYoXG4gICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgIHN0YWNrLFxuICAgICAgICAgICAgZW52XG4gICAgICAgICAgKSk7XG4gICAgICBlbGVtZW50Ll9kZWJ1Z1N0YWNrID0gbm9ybWFsaXplZFN0YWNrVHJhY2U7XG4gICAgICBub3JtYWxpemVkU3RhY2tUcmFjZSA9IG51bGw7XG4gICAgICBzdXBwb3J0c0NyZWF0ZVRhc2sgJiZcbiAgICAgICAgbnVsbCAhPT0gc3RhY2sgJiZcbiAgICAgICAgKChub3JtYWxpemVkU3RhY2tUcmFjZSA9IGNvbnNvbGUuY3JlYXRlVGFzay5iaW5kKFxuICAgICAgICAgIGNvbnNvbGUsXG4gICAgICAgICAgZ2V0VGFza05hbWUoZWxlbWVudC50eXBlKVxuICAgICAgICApKSxcbiAgICAgICAgKHN0YWNrID0gYnVpbGRGYWtlQ2FsbFN0YWNrKFxuICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgIHN0YWNrLFxuICAgICAgICAgIGVudixcbiAgICAgICAgICAhMSxcbiAgICAgICAgICBub3JtYWxpemVkU3RhY2tUcmFjZVxuICAgICAgICApKSxcbiAgICAgICAgKGVudiA9IG51bGwgPT09IG93bmVyID8gbnVsbCA6IGluaXRpYWxpemVGYWtlVGFzayhyZXNwb25zZSwgb3duZXIpKSxcbiAgICAgICAgbnVsbCA9PT0gZW52XG4gICAgICAgICAgPyAoKGVudiA9IHJlc3BvbnNlLl9kZWJ1Z1Jvb3RUYXNrKSxcbiAgICAgICAgICAgIChub3JtYWxpemVkU3RhY2tUcmFjZSA9IG51bGwgIT0gZW52ID8gZW52LnJ1bihzdGFjaykgOiBzdGFjaygpKSlcbiAgICAgICAgICA6IChub3JtYWxpemVkU3RhY2tUcmFjZSA9IGVudi5ydW4oc3RhY2spKSk7XG4gICAgICBlbGVtZW50Ll9kZWJ1Z1Rhc2sgPSBub3JtYWxpemVkU3RhY2tUcmFjZTtcbiAgICAgIG51bGwgIT09IG93bmVyICYmIGluaXRpYWxpemVGYWtlU3RhY2socmVzcG9uc2UsIG93bmVyKTtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUxhenlDaHVua1dyYXBwZXIoY2h1bmspIHtcbiAgICAgIHZhciBsYXp5VHlwZSA9IHtcbiAgICAgICAgJCR0eXBlb2Y6IFJFQUNUX0xBWllfVFlQRSxcbiAgICAgICAgX3BheWxvYWQ6IGNodW5rLFxuICAgICAgICBfaW5pdDogcmVhZENodW5rXG4gICAgICB9O1xuICAgICAgY2h1bmsgPSBjaHVuay5fZGVidWdJbmZvIHx8IChjaHVuay5fZGVidWdJbmZvID0gW10pO1xuICAgICAgbGF6eVR5cGUuX2RlYnVnSW5mbyA9IGNodW5rO1xuICAgICAgcmV0dXJuIGxhenlUeXBlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRDaHVuayhyZXNwb25zZSwgaWQpIHtcbiAgICAgIHZhciBjaHVua3MgPSByZXNwb25zZS5fY2h1bmtzLFxuICAgICAgICBjaHVuayA9IGNodW5rcy5nZXQoaWQpO1xuICAgICAgY2h1bmsgfHxcbiAgICAgICAgKChjaHVuayA9IHJlc3BvbnNlLl9jbG9zZWRcbiAgICAgICAgICA/IG5ldyBSZWFjdFByb21pc2UoXCJyZWplY3RlZFwiLCBudWxsLCByZXNwb25zZS5fY2xvc2VkUmVhc29uKVxuICAgICAgICAgIDogY3JlYXRlUGVuZGluZ0NodW5rKHJlc3BvbnNlKSksXG4gICAgICAgIGNodW5rcy5zZXQoaWQsIGNodW5rKSk7XG4gICAgICByZXR1cm4gY2h1bms7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZ1bGZpbGxSZWZlcmVuY2UocmVmZXJlbmNlLCB2YWx1ZSkge1xuICAgICAgZm9yIChcbiAgICAgICAgdmFyIHJlc3BvbnNlID0gcmVmZXJlbmNlLnJlc3BvbnNlLFxuICAgICAgICAgIGhhbmRsZXIgPSByZWZlcmVuY2UuaGFuZGxlcixcbiAgICAgICAgICBwYXJlbnRPYmplY3QgPSByZWZlcmVuY2UucGFyZW50T2JqZWN0LFxuICAgICAgICAgIGtleSA9IHJlZmVyZW5jZS5rZXksXG4gICAgICAgICAgbWFwID0gcmVmZXJlbmNlLm1hcCxcbiAgICAgICAgICBwYXRoID0gcmVmZXJlbmNlLnBhdGgsXG4gICAgICAgICAgaSA9IDE7XG4gICAgICAgIGkgPCBwYXRoLmxlbmd0aDtcbiAgICAgICAgaSsrXG4gICAgICApIHtcbiAgICAgICAgZm9yICg7IHZhbHVlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEU7IClcbiAgICAgICAgICBpZiAoKCh2YWx1ZSA9IHZhbHVlLl9wYXlsb2FkKSwgdmFsdWUgPT09IGhhbmRsZXIuY2h1bmspKVxuICAgICAgICAgICAgdmFsdWUgPSBoYW5kbGVyLnZhbHVlO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3dpdGNoICh2YWx1ZS5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgY2FzZSBcInJlc29sdmVkX21vZGVsXCI6XG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6ZU1vZGVsQ2h1bmsodmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwicmVzb2x2ZWRfbW9kdWxlXCI6XG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6ZU1vZHVsZUNodW5rKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAodmFsdWUuc3RhdHVzKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJmdWxmaWxsZWRcIjpcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnZhbHVlO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICBjYXNlIFwiYmxvY2tlZFwiOlxuICAgICAgICAgICAgICAgIHZhciBjeWNsaWNIYW5kbGVyID0gcmVzb2x2ZUJsb2NrZWRDeWNsZSh2YWx1ZSwgcmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgICBpZiAobnVsbCAhPT0gY3ljbGljSGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjeWNsaWNIYW5kbGVyLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIFwicGVuZGluZ1wiOlxuICAgICAgICAgICAgICAgIHBhdGguc3BsaWNlKDAsIGkgLSAxKTtcbiAgICAgICAgICAgICAgICBudWxsID09PSB2YWx1ZS52YWx1ZVxuICAgICAgICAgICAgICAgICAgPyAodmFsdWUudmFsdWUgPSBbcmVmZXJlbmNlXSlcbiAgICAgICAgICAgICAgICAgIDogdmFsdWUudmFsdWUucHVzaChyZWZlcmVuY2UpO1xuICAgICAgICAgICAgICAgIG51bGwgPT09IHZhbHVlLnJlYXNvblxuICAgICAgICAgICAgICAgICAgPyAodmFsdWUucmVhc29uID0gW3JlZmVyZW5jZV0pXG4gICAgICAgICAgICAgICAgICA6IHZhbHVlLnJlYXNvbi5wdXNoKHJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICBjYXNlIFwiaGFsdGVkXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlamVjdFJlZmVyZW5jZShyZWZlcmVuY2UsIHZhbHVlLnJlYXNvbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgdmFsdWUgPSB2YWx1ZVtwYXRoW2ldXTtcbiAgICAgIH1cbiAgICAgIHJlZmVyZW5jZSA9IG1hcChyZXNwb25zZSwgdmFsdWUsIHBhcmVudE9iamVjdCwga2V5KTtcbiAgICAgIHBhcmVudE9iamVjdFtrZXldID0gcmVmZXJlbmNlO1xuICAgICAgXCJcIiA9PT0ga2V5ICYmIG51bGwgPT09IGhhbmRsZXIudmFsdWUgJiYgKGhhbmRsZXIudmFsdWUgPSByZWZlcmVuY2UpO1xuICAgICAgaWYgKFxuICAgICAgICBwYXJlbnRPYmplY3RbMF0gPT09IFJFQUNUX0VMRU1FTlRfVFlQRSAmJlxuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgaGFuZGxlci52YWx1ZSAmJlxuICAgICAgICBudWxsICE9PSBoYW5kbGVyLnZhbHVlICYmXG4gICAgICAgIGhhbmRsZXIudmFsdWUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRVxuICAgICAgKVxuICAgICAgICBzd2l0Y2ggKCgocGFyZW50T2JqZWN0ID0gaGFuZGxlci52YWx1ZSksIGtleSkpIHtcbiAgICAgICAgICBjYXNlIFwiM1wiOlxuICAgICAgICAgICAgcGFyZW50T2JqZWN0LnByb3BzID0gcmVmZXJlbmNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIjRcIjpcbiAgICAgICAgICAgIHBhcmVudE9iamVjdC5fb3duZXIgPSByZWZlcmVuY2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiNVwiOlxuICAgICAgICAgICAgcGFyZW50T2JqZWN0Ll9kZWJ1Z1N0YWNrID0gcmVmZXJlbmNlO1xuICAgICAgICB9XG4gICAgICBoYW5kbGVyLmRlcHMtLTtcbiAgICAgIDAgPT09IGhhbmRsZXIuZGVwcyAmJlxuICAgICAgICAoKGtleSA9IGhhbmRsZXIuY2h1bmspLFxuICAgICAgICBudWxsICE9PSBrZXkgJiZcbiAgICAgICAgICBcImJsb2NrZWRcIiA9PT0ga2V5LnN0YXR1cyAmJlxuICAgICAgICAgICgocGFyZW50T2JqZWN0ID0ga2V5LnZhbHVlKSxcbiAgICAgICAgICAoa2V5LnN0YXR1cyA9IFwiZnVsZmlsbGVkXCIpLFxuICAgICAgICAgIChrZXkudmFsdWUgPSBoYW5kbGVyLnZhbHVlKSxcbiAgICAgICAgICBudWxsICE9PSBwYXJlbnRPYmplY3QgJiYgd2FrZUNodW5rKHBhcmVudE9iamVjdCwgaGFuZGxlci52YWx1ZSkpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVqZWN0UmVmZXJlbmNlKHJlZmVyZW5jZSwgZXJyb3IpIHtcbiAgICAgIHZhciBoYW5kbGVyID0gcmVmZXJlbmNlLmhhbmRsZXI7XG4gICAgICByZWZlcmVuY2UgPSByZWZlcmVuY2UucmVzcG9uc2U7XG4gICAgICBpZiAoIWhhbmRsZXIuZXJyb3JlZCkge1xuICAgICAgICB2YXIgYmxvY2tlZFZhbHVlID0gaGFuZGxlci52YWx1ZTtcbiAgICAgICAgaGFuZGxlci5lcnJvcmVkID0gITA7XG4gICAgICAgIGhhbmRsZXIudmFsdWUgPSBlcnJvcjtcbiAgICAgICAgaGFuZGxlciA9IGhhbmRsZXIuY2h1bms7XG4gICAgICAgIGlmIChudWxsICE9PSBoYW5kbGVyICYmIFwiYmxvY2tlZFwiID09PSBoYW5kbGVyLnN0YXR1cykge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBibG9ja2VkVmFsdWUgJiZcbiAgICAgICAgICAgIG51bGwgIT09IGJsb2NrZWRWYWx1ZSAmJlxuICAgICAgICAgICAgYmxvY2tlZFZhbHVlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEVcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciBlcnJvcmVkQ29tcG9uZW50ID0ge1xuICAgICAgICAgICAgICBuYW1lOiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoYmxvY2tlZFZhbHVlLnR5cGUpIHx8IFwiXCIsXG4gICAgICAgICAgICAgIG93bmVyOiBibG9ja2VkVmFsdWUuX293bmVyXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXJyb3JlZENvbXBvbmVudC5kZWJ1Z1N0YWNrID0gYmxvY2tlZFZhbHVlLl9kZWJ1Z1N0YWNrO1xuICAgICAgICAgICAgc3VwcG9ydHNDcmVhdGVUYXNrICYmXG4gICAgICAgICAgICAgIChlcnJvcmVkQ29tcG9uZW50LmRlYnVnVGFzayA9IGJsb2NrZWRWYWx1ZS5fZGVidWdUYXNrKTtcbiAgICAgICAgICAgIChoYW5kbGVyLl9kZWJ1Z0luZm8gfHwgKGhhbmRsZXIuX2RlYnVnSW5mbyA9IFtdKSkucHVzaChcbiAgICAgICAgICAgICAgZXJyb3JlZENvbXBvbmVudFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJpZ2dlckVycm9yT25DaHVuayhyZWZlcmVuY2UsIGhhbmRsZXIsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB3YWl0Rm9yUmVmZXJlbmNlKFxuICAgICAgcmVmZXJlbmNlZENodW5rLFxuICAgICAgcGFyZW50T2JqZWN0LFxuICAgICAga2V5LFxuICAgICAgcmVzcG9uc2UsXG4gICAgICBtYXAsXG4gICAgICBwYXRoXG4gICAgKSB7XG4gICAgICBpZiAoaW5pdGlhbGl6aW5nSGFuZGxlcikge1xuICAgICAgICB2YXIgaGFuZGxlciA9IGluaXRpYWxpemluZ0hhbmRsZXI7XG4gICAgICAgIGhhbmRsZXIuZGVwcysrO1xuICAgICAgfSBlbHNlXG4gICAgICAgIGhhbmRsZXIgPSBpbml0aWFsaXppbmdIYW5kbGVyID0ge1xuICAgICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgICBjaHVuazogbnVsbCxcbiAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICBkZXBzOiAxLFxuICAgICAgICAgIGVycm9yZWQ6ICExXG4gICAgICAgIH07XG4gICAgICBwYXJlbnRPYmplY3QgPSB7XG4gICAgICAgIHJlc3BvbnNlOiByZXNwb25zZSxcbiAgICAgICAgaGFuZGxlcjogaGFuZGxlcixcbiAgICAgICAgcGFyZW50T2JqZWN0OiBwYXJlbnRPYmplY3QsXG4gICAgICAgIGtleToga2V5LFxuICAgICAgICBtYXA6IG1hcCxcbiAgICAgICAgcGF0aDogcGF0aFxuICAgICAgfTtcbiAgICAgIG51bGwgPT09IHJlZmVyZW5jZWRDaHVuay52YWx1ZVxuICAgICAgICA/IChyZWZlcmVuY2VkQ2h1bmsudmFsdWUgPSBbcGFyZW50T2JqZWN0XSlcbiAgICAgICAgOiByZWZlcmVuY2VkQ2h1bmsudmFsdWUucHVzaChwYXJlbnRPYmplY3QpO1xuICAgICAgbnVsbCA9PT0gcmVmZXJlbmNlZENodW5rLnJlYXNvblxuICAgICAgICA/IChyZWZlcmVuY2VkQ2h1bmsucmVhc29uID0gW3BhcmVudE9iamVjdF0pXG4gICAgICAgIDogcmVmZXJlbmNlZENodW5rLnJlYXNvbi5wdXNoKHBhcmVudE9iamVjdCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbG9hZFNlcnZlclJlZmVyZW5jZShyZXNwb25zZSwgbWV0YURhdGEsIHBhcmVudE9iamVjdCwga2V5KSB7XG4gICAgICBpZiAoIXJlc3BvbnNlLl9zZXJ2ZXJSZWZlcmVuY2VDb25maWcpXG4gICAgICAgIHJldHVybiBjcmVhdGVCb3VuZFNlcnZlclJlZmVyZW5jZShcbiAgICAgICAgICBtZXRhRGF0YSxcbiAgICAgICAgICByZXNwb25zZS5fY2FsbFNlcnZlcixcbiAgICAgICAgICByZXNwb25zZS5fZW5jb2RlRm9ybUFjdGlvbixcbiAgICAgICAgICByZXNwb25zZS5fZGVidWdGaW5kU291cmNlTWFwVVJMXG4gICAgICAgICk7XG4gICAgICB2YXIgc2VydmVyUmVmZXJlbmNlID0gcmVzb2x2ZVNlcnZlclJlZmVyZW5jZShcbiAgICAgICAgICByZXNwb25zZS5fc2VydmVyUmVmZXJlbmNlQ29uZmlnLFxuICAgICAgICAgIG1ldGFEYXRhLmlkXG4gICAgICAgICksXG4gICAgICAgIHByb21pc2UgPSBwcmVsb2FkTW9kdWxlKHNlcnZlclJlZmVyZW5jZSk7XG4gICAgICBpZiAocHJvbWlzZSlcbiAgICAgICAgbWV0YURhdGEuYm91bmQgJiYgKHByb21pc2UgPSBQcm9taXNlLmFsbChbcHJvbWlzZSwgbWV0YURhdGEuYm91bmRdKSk7XG4gICAgICBlbHNlIGlmIChtZXRhRGF0YS5ib3VuZCkgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShtZXRhRGF0YS5ib3VuZCk7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgKHByb21pc2UgPSByZXF1aXJlTW9kdWxlKHNlcnZlclJlZmVyZW5jZSkpLFxuICAgICAgICAgIHJlZ2lzdGVyQm91bmRTZXJ2ZXJSZWZlcmVuY2UocHJvbWlzZSwgbWV0YURhdGEuaWQsIG1ldGFEYXRhLmJvdW5kKSxcbiAgICAgICAgICBwcm9taXNlXG4gICAgICAgICk7XG4gICAgICBpZiAoaW5pdGlhbGl6aW5nSGFuZGxlcikge1xuICAgICAgICB2YXIgaGFuZGxlciA9IGluaXRpYWxpemluZ0hhbmRsZXI7XG4gICAgICAgIGhhbmRsZXIuZGVwcysrO1xuICAgICAgfSBlbHNlXG4gICAgICAgIGhhbmRsZXIgPSBpbml0aWFsaXppbmdIYW5kbGVyID0ge1xuICAgICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgICBjaHVuazogbnVsbCxcbiAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICBkZXBzOiAxLFxuICAgICAgICAgIGVycm9yZWQ6ICExXG4gICAgICAgIH07XG4gICAgICBwcm9taXNlLnRoZW4oXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgcmVzb2x2ZWRWYWx1ZSA9IHJlcXVpcmVNb2R1bGUoc2VydmVyUmVmZXJlbmNlKTtcbiAgICAgICAgICBpZiAobWV0YURhdGEuYm91bmQpIHtcbiAgICAgICAgICAgIHZhciBib3VuZEFyZ3MgPSBtZXRhRGF0YS5ib3VuZC52YWx1ZS5zbGljZSgwKTtcbiAgICAgICAgICAgIGJvdW5kQXJncy51bnNoaWZ0KG51bGwpO1xuICAgICAgICAgICAgcmVzb2x2ZWRWYWx1ZSA9IHJlc29sdmVkVmFsdWUuYmluZC5hcHBseShyZXNvbHZlZFZhbHVlLCBib3VuZEFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZWdpc3RlckJvdW5kU2VydmVyUmVmZXJlbmNlKFxuICAgICAgICAgICAgcmVzb2x2ZWRWYWx1ZSxcbiAgICAgICAgICAgIG1ldGFEYXRhLmlkLFxuICAgICAgICAgICAgbWV0YURhdGEuYm91bmRcbiAgICAgICAgICApO1xuICAgICAgICAgIHBhcmVudE9iamVjdFtrZXldID0gcmVzb2x2ZWRWYWx1ZTtcbiAgICAgICAgICBcIlwiID09PSBrZXkgJiZcbiAgICAgICAgICAgIG51bGwgPT09IGhhbmRsZXIudmFsdWUgJiZcbiAgICAgICAgICAgIChoYW5kbGVyLnZhbHVlID0gcmVzb2x2ZWRWYWx1ZSk7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgcGFyZW50T2JqZWN0WzBdID09PSBSRUFDVF9FTEVNRU5UX1RZUEUgJiZcbiAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBoYW5kbGVyLnZhbHVlICYmXG4gICAgICAgICAgICBudWxsICE9PSBoYW5kbGVyLnZhbHVlICYmXG4gICAgICAgICAgICBoYW5kbGVyLnZhbHVlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEVcbiAgICAgICAgICApXG4gICAgICAgICAgICBzd2l0Y2ggKCgoYm91bmRBcmdzID0gaGFuZGxlci52YWx1ZSksIGtleSkpIHtcbiAgICAgICAgICAgICAgY2FzZSBcIjNcIjpcbiAgICAgICAgICAgICAgICBib3VuZEFyZ3MucHJvcHMgPSByZXNvbHZlZFZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiNFwiOlxuICAgICAgICAgICAgICAgIGJvdW5kQXJncy5fb3duZXIgPSByZXNvbHZlZFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGhhbmRsZXIuZGVwcy0tO1xuICAgICAgICAgIDAgPT09IGhhbmRsZXIuZGVwcyAmJlxuICAgICAgICAgICAgKChyZXNvbHZlZFZhbHVlID0gaGFuZGxlci5jaHVuayksXG4gICAgICAgICAgICBudWxsICE9PSByZXNvbHZlZFZhbHVlICYmXG4gICAgICAgICAgICAgIFwiYmxvY2tlZFwiID09PSByZXNvbHZlZFZhbHVlLnN0YXR1cyAmJlxuICAgICAgICAgICAgICAoKGJvdW5kQXJncyA9IHJlc29sdmVkVmFsdWUudmFsdWUpLFxuICAgICAgICAgICAgICAocmVzb2x2ZWRWYWx1ZS5zdGF0dXMgPSBcImZ1bGZpbGxlZFwiKSxcbiAgICAgICAgICAgICAgKHJlc29sdmVkVmFsdWUudmFsdWUgPSBoYW5kbGVyLnZhbHVlKSxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gYm91bmRBcmdzICYmIHdha2VDaHVuayhib3VuZEFyZ3MsIGhhbmRsZXIudmFsdWUpKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgIGlmICghaGFuZGxlci5lcnJvcmVkKSB7XG4gICAgICAgICAgICB2YXIgYmxvY2tlZFZhbHVlID0gaGFuZGxlci52YWx1ZTtcbiAgICAgICAgICAgIGhhbmRsZXIuZXJyb3JlZCA9ICEwO1xuICAgICAgICAgICAgaGFuZGxlci52YWx1ZSA9IGVycm9yO1xuICAgICAgICAgICAgdmFyIGNodW5rID0gaGFuZGxlci5jaHVuaztcbiAgICAgICAgICAgIGlmIChudWxsICE9PSBjaHVuayAmJiBcImJsb2NrZWRcIiA9PT0gY2h1bmsuc3RhdHVzKSB7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgYmxvY2tlZFZhbHVlICYmXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gYmxvY2tlZFZhbHVlICYmXG4gICAgICAgICAgICAgICAgYmxvY2tlZFZhbHVlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEVcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yZWRDb21wb25lbnQgPSB7XG4gICAgICAgICAgICAgICAgICBuYW1lOiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoYmxvY2tlZFZhbHVlLnR5cGUpIHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgICBvd25lcjogYmxvY2tlZFZhbHVlLl9vd25lclxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZXJyb3JlZENvbXBvbmVudC5kZWJ1Z1N0YWNrID0gYmxvY2tlZFZhbHVlLl9kZWJ1Z1N0YWNrO1xuICAgICAgICAgICAgICAgIHN1cHBvcnRzQ3JlYXRlVGFzayAmJlxuICAgICAgICAgICAgICAgICAgKGVycm9yZWRDb21wb25lbnQuZGVidWdUYXNrID0gYmxvY2tlZFZhbHVlLl9kZWJ1Z1Rhc2spO1xuICAgICAgICAgICAgICAgIChjaHVuay5fZGVidWdJbmZvIHx8IChjaHVuay5fZGVidWdJbmZvID0gW10pKS5wdXNoKFxuICAgICAgICAgICAgICAgICAgZXJyb3JlZENvbXBvbmVudFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdHJpZ2dlckVycm9yT25DaHVuayhyZXNwb25zZSwgY2h1bmssIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0T3V0bGluZWRNb2RlbChyZXNwb25zZSwgcmVmZXJlbmNlLCBwYXJlbnRPYmplY3QsIGtleSwgbWFwKSB7XG4gICAgICByZWZlcmVuY2UgPSByZWZlcmVuY2Uuc3BsaXQoXCI6XCIpO1xuICAgICAgdmFyIGlkID0gcGFyc2VJbnQocmVmZXJlbmNlWzBdLCAxNik7XG4gICAgICBpZCA9IGdldENodW5rKHJlc3BvbnNlLCBpZCk7XG4gICAgICBzd2l0Y2ggKGlkLnN0YXR1cykge1xuICAgICAgICBjYXNlIFwicmVzb2x2ZWRfbW9kZWxcIjpcbiAgICAgICAgICBpbml0aWFsaXplTW9kZWxDaHVuayhpZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJyZXNvbHZlZF9tb2R1bGVcIjpcbiAgICAgICAgICBpbml0aWFsaXplTW9kdWxlQ2h1bmsoaWQpO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChpZC5zdGF0dXMpIHtcbiAgICAgICAgY2FzZSBcImZ1bGZpbGxlZFwiOlxuICAgICAgICAgIGZvciAodmFyIHZhbHVlID0gaWQudmFsdWUsIGkgPSAxOyBpIDwgcmVmZXJlbmNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKDsgdmFsdWUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRTsgKSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuX3BheWxvYWQ7XG4gICAgICAgICAgICAgIHN3aXRjaCAodmFsdWUuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInJlc29sdmVkX21vZGVsXCI6XG4gICAgICAgICAgICAgICAgICBpbml0aWFsaXplTW9kZWxDaHVuayh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwicmVzb2x2ZWRfbW9kdWxlXCI6XG4gICAgICAgICAgICAgICAgICBpbml0aWFsaXplTW9kdWxlQ2h1bmsodmFsdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN3aXRjaCAodmFsdWUuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImZ1bGZpbGxlZFwiOlxuICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJibG9ja2VkXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInBlbmRpbmdcIjpcbiAgICAgICAgICAgICAgICAgIHJldHVybiB3YWl0Rm9yUmVmZXJlbmNlKFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50T2JqZWN0LFxuICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICBtYXAsXG4gICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZS5zbGljZShpIC0gMSlcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgY2FzZSBcImhhbHRlZFwiOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbGl6aW5nSGFuZGxlclxuICAgICAgICAgICAgICAgICAgICAgID8gKChyZXNwb25zZSA9IGluaXRpYWxpemluZ0hhbmRsZXIpLCByZXNwb25zZS5kZXBzKyspXG4gICAgICAgICAgICAgICAgICAgICAgOiAoaW5pdGlhbGl6aW5nSGFuZGxlciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVuazogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRlcHM6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yZWQ6ICExXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbGl6aW5nSGFuZGxlclxuICAgICAgICAgICAgICAgICAgICAgID8gKChpbml0aWFsaXppbmdIYW5kbGVyLmVycm9yZWQgPSAhMCksXG4gICAgICAgICAgICAgICAgICAgICAgICAoaW5pdGlhbGl6aW5nSGFuZGxlci52YWx1ZSA9IHZhbHVlLnJlYXNvbikpXG4gICAgICAgICAgICAgICAgICAgICAgOiAoaW5pdGlhbGl6aW5nSGFuZGxlciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVuazogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLnJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGVwczogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JlZDogITBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlW3JlZmVyZW5jZVtpXV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3BvbnNlID0gbWFwKHJlc3BvbnNlLCB2YWx1ZSwgcGFyZW50T2JqZWN0LCBrZXkpO1xuICAgICAgICAgIGlkLl9kZWJ1Z0luZm8gJiZcbiAgICAgICAgICAgIChcIm9iamVjdFwiICE9PSB0eXBlb2YgcmVzcG9uc2UgfHxcbiAgICAgICAgICAgICAgbnVsbCA9PT0gcmVzcG9uc2UgfHxcbiAgICAgICAgICAgICAgKCFpc0FycmF5SW1wbChyZXNwb25zZSkgJiZcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiByZXNwb25zZVtBU1lOQ19JVEVSQVRPUl0gJiZcbiAgICAgICAgICAgICAgICByZXNwb25zZS4kJHR5cGVvZiAhPT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB8fFxuICAgICAgICAgICAgICByZXNwb25zZS5fZGVidWdJbmZvIHx8XG4gICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXNwb25zZSwgXCJfZGVidWdJbmZvXCIsIHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogaWQuX2RlYnVnSW5mb1xuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICBjYXNlIFwicGVuZGluZ1wiOlxuICAgICAgICBjYXNlIFwiYmxvY2tlZFwiOlxuICAgICAgICAgIHJldHVybiB3YWl0Rm9yUmVmZXJlbmNlKFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBwYXJlbnRPYmplY3QsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgIG1hcCxcbiAgICAgICAgICAgIHJlZmVyZW5jZVxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgXCJoYWx0ZWRcIjpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgaW5pdGlhbGl6aW5nSGFuZGxlclxuICAgICAgICAgICAgICA/ICgocmVzcG9uc2UgPSBpbml0aWFsaXppbmdIYW5kbGVyKSwgcmVzcG9uc2UuZGVwcysrKVxuICAgICAgICAgICAgICA6IChpbml0aWFsaXppbmdIYW5kbGVyID0ge1xuICAgICAgICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgICAgICAgY2h1bms6IG51bGwsXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgIGRlcHM6IDEsXG4gICAgICAgICAgICAgICAgICBlcnJvcmVkOiAhMVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGluaXRpYWxpemluZ0hhbmRsZXJcbiAgICAgICAgICAgICAgPyAoKGluaXRpYWxpemluZ0hhbmRsZXIuZXJyb3JlZCA9ICEwKSxcbiAgICAgICAgICAgICAgICAoaW5pdGlhbGl6aW5nSGFuZGxlci52YWx1ZSA9IGlkLnJlYXNvbikpXG4gICAgICAgICAgICAgIDogKGluaXRpYWxpemluZ0hhbmRsZXIgPSB7XG4gICAgICAgICAgICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICBjaHVuazogbnVsbCxcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBpZC5yZWFzb24sXG4gICAgICAgICAgICAgICAgICBkZXBzOiAwLFxuICAgICAgICAgICAgICAgICAgZXJyb3JlZDogITBcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVNYXAocmVzcG9uc2UsIG1vZGVsKSB7XG4gICAgICByZXR1cm4gbmV3IE1hcChtb2RlbCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVNldChyZXNwb25zZSwgbW9kZWwpIHtcbiAgICAgIHJldHVybiBuZXcgU2V0KG1vZGVsKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlQmxvYihyZXNwb25zZSwgbW9kZWwpIHtcbiAgICAgIHJldHVybiBuZXcgQmxvYihtb2RlbC5zbGljZSgxKSwgeyB0eXBlOiBtb2RlbFswXSB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlRm9ybURhdGEocmVzcG9uc2UsIG1vZGVsKSB7XG4gICAgICByZXNwb25zZSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtb2RlbC5sZW5ndGg7IGkrKylcbiAgICAgICAgcmVzcG9uc2UuYXBwZW5kKG1vZGVsW2ldWzBdLCBtb2RlbFtpXVsxXSk7XG4gICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFwcGx5Q29uc3RydWN0b3IocmVzcG9uc2UsIG1vZGVsLCBwYXJlbnRPYmplY3QpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihwYXJlbnRPYmplY3QsIG1vZGVsLnByb3RvdHlwZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmluZUxhenlHZXR0ZXIocmVzcG9uc2UsIGNodW5rLCBwYXJlbnRPYmplY3QsIGtleSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHBhcmVudE9iamVjdCwga2V5LCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIFwicmVzb2x2ZWRfbW9kZWxcIiA9PT0gY2h1bmsuc3RhdHVzICYmIGluaXRpYWxpemVNb2RlbENodW5rKGNodW5rKTtcbiAgICAgICAgICBzd2l0Y2ggKGNodW5rLnN0YXR1cykge1xuICAgICAgICAgICAgY2FzZSBcImZ1bGZpbGxlZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gY2h1bmsudmFsdWU7XG4gICAgICAgICAgICBjYXNlIFwicmVqZWN0ZWRcIjpcbiAgICAgICAgICAgICAgdGhyb3cgY2h1bmsucmVhc29uO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gXCJUaGlzIG9iamVjdCBoYXMgYmVlbiBvbWl0dGVkIGJ5IFJlYWN0IGluIHRoZSBjb25zb2xlIGxvZyB0byBhdm9pZCBzZW5kaW5nIHRvbyBtdWNoIGRhdGEgZnJvbSB0aGUgc2VydmVyLiBUcnkgbG9nZ2luZyBzbWFsbGVyIG9yIG1vcmUgc3BlY2lmaWMgb2JqZWN0cy5cIjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITFcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGV4dHJhY3RJdGVyYXRvcihyZXNwb25zZSwgbW9kZWwpIHtcbiAgICAgIHJldHVybiBtb2RlbFtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZU1vZGVsKHJlc3BvbnNlLCBtb2RlbCkge1xuICAgICAgcmV0dXJuIG1vZGVsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZU1vZGVsU3RyaW5nKHJlc3BvbnNlLCBwYXJlbnRPYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgICAgIGlmIChcIiRcIiA9PT0gdmFsdWVbMF0pIHtcbiAgICAgICAgaWYgKFwiJFwiID09PSB2YWx1ZSlcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgbnVsbCAhPT0gaW5pdGlhbGl6aW5nSGFuZGxlciAmJlxuICAgICAgICAgICAgICBcIjBcIiA9PT0ga2V5ICYmXG4gICAgICAgICAgICAgIChpbml0aWFsaXppbmdIYW5kbGVyID0ge1xuICAgICAgICAgICAgICAgIHBhcmVudDogaW5pdGlhbGl6aW5nSGFuZGxlcixcbiAgICAgICAgICAgICAgICBjaHVuazogbnVsbCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICBkZXBzOiAwLFxuICAgICAgICAgICAgICAgIGVycm9yZWQ6ICExXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgUkVBQ1RfRUxFTUVOVF9UWVBFXG4gICAgICAgICAgKTtcbiAgICAgICAgc3dpdGNoICh2YWx1ZVsxXSkge1xuICAgICAgICAgIGNhc2UgXCIkXCI6XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuc2xpY2UoMSk7XG4gICAgICAgICAgY2FzZSBcIkxcIjpcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChwYXJlbnRPYmplY3QgPSBwYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgMTYpKSxcbiAgICAgICAgICAgICAgKHJlc3BvbnNlID0gZ2V0Q2h1bmsocmVzcG9uc2UsIHBhcmVudE9iamVjdCkpLFxuICAgICAgICAgICAgICBjcmVhdGVMYXp5Q2h1bmtXcmFwcGVyKHJlc3BvbnNlKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBjYXNlIFwiQFwiOlxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKHBhcmVudE9iamVjdCA9IHBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCAxNikpLFxuICAgICAgICAgICAgICBnZXRDaHVuayhyZXNwb25zZSwgcGFyZW50T2JqZWN0KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBjYXNlIFwiU1wiOlxuICAgICAgICAgICAgcmV0dXJuIFN5bWJvbC5mb3IodmFsdWUuc2xpY2UoMikpO1xuICAgICAgICAgIGNhc2UgXCJGXCI6XG4gICAgICAgICAgICB2YXIgcmVmID0gdmFsdWUuc2xpY2UoMik7XG4gICAgICAgICAgICByZXR1cm4gZ2V0T3V0bGluZWRNb2RlbChcbiAgICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICAgIHJlZixcbiAgICAgICAgICAgICAgcGFyZW50T2JqZWN0LFxuICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgIGxvYWRTZXJ2ZXJSZWZlcmVuY2VcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSBcIlRcIjpcbiAgICAgICAgICAgIHBhcmVudE9iamVjdCA9IFwiJFwiICsgdmFsdWUuc2xpY2UoMik7XG4gICAgICAgICAgICByZXNwb25zZSA9IHJlc3BvbnNlLl90ZW1wUmVmcztcbiAgICAgICAgICAgIGlmIChudWxsID09IHJlc3BvbnNlKVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIk1pc3NpbmcgYSB0ZW1wb3JhcnkgcmVmZXJlbmNlIHNldCBidXQgdGhlIFJTQyByZXNwb25zZSByZXR1cm5lZCBhIHRlbXBvcmFyeSByZWZlcmVuY2UuIFBhc3MgYSB0ZW1wb3JhcnlSZWZlcmVuY2Ugb3B0aW9uIHdpdGggdGhlIHNldCB0aGF0IHdhcyB1c2VkIHdpdGggdGhlIHJlcGx5LlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuZ2V0KHBhcmVudE9iamVjdCk7XG4gICAgICAgICAgY2FzZSBcIlFcIjpcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChyZWYgPSB2YWx1ZS5zbGljZSgyKSksXG4gICAgICAgICAgICAgIGdldE91dGxpbmVkTW9kZWwocmVzcG9uc2UsIHJlZiwgcGFyZW50T2JqZWN0LCBrZXksIGNyZWF0ZU1hcClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSBcIldcIjpcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChyZWYgPSB2YWx1ZS5zbGljZSgyKSksXG4gICAgICAgICAgICAgIGdldE91dGxpbmVkTW9kZWwocmVzcG9uc2UsIHJlZiwgcGFyZW50T2JqZWN0LCBrZXksIGNyZWF0ZVNldClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSBcIkJcIjpcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChyZWYgPSB2YWx1ZS5zbGljZSgyKSksXG4gICAgICAgICAgICAgIGdldE91dGxpbmVkTW9kZWwocmVzcG9uc2UsIHJlZiwgcGFyZW50T2JqZWN0LCBrZXksIGNyZWF0ZUJsb2IpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNhc2UgXCJLXCI6XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAocmVmID0gdmFsdWUuc2xpY2UoMikpLFxuICAgICAgICAgICAgICBnZXRPdXRsaW5lZE1vZGVsKHJlc3BvbnNlLCByZWYsIHBhcmVudE9iamVjdCwga2V5LCBjcmVhdGVGb3JtRGF0YSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSBcIlpcIjpcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChyZWYgPSB2YWx1ZS5zbGljZSgyKSksXG4gICAgICAgICAgICAgIGdldE91dGxpbmVkTW9kZWwoXG4gICAgICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgcmVmLFxuICAgICAgICAgICAgICAgIHBhcmVudE9iamVjdCxcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgcmVzb2x2ZUVycm9yRGV2XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSBcImlcIjpcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChyZWYgPSB2YWx1ZS5zbGljZSgyKSksXG4gICAgICAgICAgICAgIGdldE91dGxpbmVkTW9kZWwoXG4gICAgICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgcmVmLFxuICAgICAgICAgICAgICAgIHBhcmVudE9iamVjdCxcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgZXh0cmFjdEl0ZXJhdG9yXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSBcIklcIjpcbiAgICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgICAgICBjYXNlIFwiLVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiJC0wXCIgPT09IHZhbHVlID8gLTAgOiAtSW5maW5pdHk7XG4gICAgICAgICAgY2FzZSBcIk5cIjpcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgICAgY2FzZSBcInVcIjpcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBjYXNlIFwiRFwiOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKERhdGUucGFyc2UodmFsdWUuc2xpY2UoMikpKTtcbiAgICAgICAgICBjYXNlIFwiblwiOlxuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCh2YWx1ZS5zbGljZSgyKSk7XG4gICAgICAgICAgY2FzZSBcIlBcIjpcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChyZWYgPSB2YWx1ZS5zbGljZSgyKSksXG4gICAgICAgICAgICAgIGdldE91dGxpbmVkTW9kZWwoXG4gICAgICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgcmVmLFxuICAgICAgICAgICAgICAgIHBhcmVudE9iamVjdCxcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgYXBwbHlDb25zdHJ1Y3RvclxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNhc2UgXCJFXCI6XG4gICAgICAgICAgICByZXNwb25zZSA9IHZhbHVlLnNsaWNlKDIpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuICgwLCBldmFsKShyZXNwb25zZSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGFydHNXaXRoKFwiKGFzeW5jIGZ1bmN0aW9uXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgKChwYXJlbnRPYmplY3QgPSByZXNwb25zZS5pbmRleE9mKFwiKFwiLCAxNSkpLFxuICAgICAgICAgICAgICAgICAgLTEgIT09IHBhcmVudE9iamVjdClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICAocmVzcG9uc2UgPSByZXNwb25zZS5zbGljZSgxNSwgcGFyZW50T2JqZWN0KS50cmltKCkpLFxuICAgICAgICAgICAgICAgICAgICAoMCwgZXZhbCkoXG4gICAgICAgICAgICAgICAgICAgICAgXCIoe1wiICsgSlNPTi5zdHJpbmdpZnkocmVzcG9uc2UpICsgXCI6YXN5bmMgZnVuY3Rpb24oKXt9fSlcIlxuICAgICAgICAgICAgICAgICAgICApW3Jlc3BvbnNlXVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGFydHNXaXRoKFwiKGZ1bmN0aW9uXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgKChwYXJlbnRPYmplY3QgPSByZXNwb25zZS5pbmRleE9mKFwiKFwiLCA5KSksXG4gICAgICAgICAgICAgICAgICAtMSAhPT0gcGFyZW50T2JqZWN0KVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgIChyZXNwb25zZSA9IHJlc3BvbnNlLnNsaWNlKDksIHBhcmVudE9iamVjdCkudHJpbSgpKSxcbiAgICAgICAgICAgICAgICAgICAgKDAsIGV2YWwpKFxuICAgICAgICAgICAgICAgICAgICAgIFwiKHtcIiArIEpTT04uc3RyaW5naWZ5KHJlc3BvbnNlKSArIFwiOmZ1bmN0aW9uKCl7fX0pXCJcbiAgICAgICAgICAgICAgICAgICAgKVtyZXNwb25zZV1cbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgcmVzcG9uc2Uuc3RhcnRzV2l0aChcIihjbGFzc1wiKSAmJlxuICAgICAgICAgICAgICAgICgocGFyZW50T2JqZWN0ID0gcmVzcG9uc2UuaW5kZXhPZihcIntcIiwgNikpLCAtMSAhPT0gcGFyZW50T2JqZWN0KVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgIChyZXNwb25zZSA9IHJlc3BvbnNlLnNsaWNlKDYsIHBhcmVudE9iamVjdCkudHJpbSgpKSxcbiAgICAgICAgICAgICAgICAgICgwLCBldmFsKShcIih7XCIgKyBKU09OLnN0cmluZ2lmeShyZXNwb25zZSkgKyBcIjpjbGFzc3t9fSlcIilbXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJZXCI6XG4gICAgICAgICAgICBpZiAoMiA8IHZhbHVlLmxlbmd0aCAmJiAocmVmID0gcmVzcG9uc2UuX2RlYnVnQ2hhbm5lbCkpIHtcbiAgICAgICAgICAgICAgaWYgKFwiQFwiID09PSB2YWx1ZVsyXSlcbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgKHBhcmVudE9iamVjdCA9IHZhbHVlLnNsaWNlKDMpKSxcbiAgICAgICAgICAgICAgICAgIChrZXkgPSBwYXJzZUludChwYXJlbnRPYmplY3QsIDE2KSksXG4gICAgICAgICAgICAgICAgICByZXNwb25zZS5fY2h1bmtzLmhhcyhrZXkpIHx8IHJlZihcIlA6XCIgKyBwYXJlbnRPYmplY3QpLFxuICAgICAgICAgICAgICAgICAgZ2V0Q2h1bmsocmVzcG9uc2UsIGtleSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDIpO1xuICAgICAgICAgICAgICB2YXIgX2lkMiA9IHBhcnNlSW50KHZhbHVlLCAxNik7XG4gICAgICAgICAgICAgIHJlc3BvbnNlLl9jaHVua3MuaGFzKF9pZDIpIHx8IHJlZihcIlE6XCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgIHJlZiA9IGdldENodW5rKHJlc3BvbnNlLCBfaWQyKTtcbiAgICAgICAgICAgICAgcmV0dXJuIFwiZnVsZmlsbGVkXCIgPT09IHJlZi5zdGF0dXNcbiAgICAgICAgICAgICAgICA/IHJlZi52YWx1ZVxuICAgICAgICAgICAgICAgIDogZGVmaW5lTGF6eUdldHRlcihyZXNwb25zZSwgcmVmLCBwYXJlbnRPYmplY3QsIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocGFyZW50T2JqZWN0LCBrZXksIHtcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiVGhpcyBvYmplY3QgaGFzIGJlZW4gb21pdHRlZCBieSBSZWFjdCBpbiB0aGUgY29uc29sZSBsb2cgdG8gYXZvaWQgc2VuZGluZyB0b28gbXVjaCBkYXRhIGZyb20gdGhlIHNlcnZlci4gVHJ5IGxvZ2dpbmcgc21hbGxlciBvciBtb3JlIHNwZWNpZmljIG9iamVjdHMuXCI7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICBjb25maWd1cmFibGU6ICExXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAocmVmID0gdmFsdWUuc2xpY2UoMSkpLFxuICAgICAgICAgICAgICBnZXRPdXRsaW5lZE1vZGVsKHJlc3BvbnNlLCByZWYsIHBhcmVudE9iamVjdCwga2V5LCBjcmVhdGVNb2RlbClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWlzc2luZ0NhbGwoKSB7XG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgJ1RyeWluZyB0byBjYWxsIGEgZnVuY3Rpb24gZnJvbSBcInVzZSBzZXJ2ZXJcIiBidXQgdGhlIGNhbGxTZXJ2ZXIgb3B0aW9uIHdhcyBub3QgaW1wbGVtZW50ZWQgaW4geW91ciByb3V0ZXIgcnVudGltZS4nXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZXNwb25zZUluc3RhbmNlKFxuICAgICAgYnVuZGxlckNvbmZpZyxcbiAgICAgIHNlcnZlclJlZmVyZW5jZUNvbmZpZyxcbiAgICAgIG1vZHVsZUxvYWRpbmcsXG4gICAgICBjYWxsU2VydmVyLFxuICAgICAgZW5jb2RlRm9ybUFjdGlvbixcbiAgICAgIG5vbmNlLFxuICAgICAgdGVtcG9yYXJ5UmVmZXJlbmNlcyxcbiAgICAgIGZpbmRTb3VyY2VNYXBVUkwsXG4gICAgICByZXBsYXlDb25zb2xlLFxuICAgICAgZW52aXJvbm1lbnROYW1lLFxuICAgICAgZGVidWdDaGFubmVsXG4gICAgKSB7XG4gICAgICB2YXIgY2h1bmtzID0gbmV3IE1hcCgpO1xuICAgICAgdGhpcy5fYnVuZGxlckNvbmZpZyA9IGJ1bmRsZXJDb25maWc7XG4gICAgICB0aGlzLl9zZXJ2ZXJSZWZlcmVuY2VDb25maWcgPSBzZXJ2ZXJSZWZlcmVuY2VDb25maWc7XG4gICAgICB0aGlzLl9tb2R1bGVMb2FkaW5nID0gbW9kdWxlTG9hZGluZztcbiAgICAgIHRoaXMuX2NhbGxTZXJ2ZXIgPSB2b2lkIDAgIT09IGNhbGxTZXJ2ZXIgPyBjYWxsU2VydmVyIDogbWlzc2luZ0NhbGw7XG4gICAgICB0aGlzLl9lbmNvZGVGb3JtQWN0aW9uID0gZW5jb2RlRm9ybUFjdGlvbjtcbiAgICAgIHRoaXMuX25vbmNlID0gbm9uY2U7XG4gICAgICB0aGlzLl9jaHVua3MgPSBjaHVua3M7XG4gICAgICB0aGlzLl9zdHJpbmdEZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gICAgICB0aGlzLl9mcm9tSlNPTiA9IG51bGw7XG4gICAgICB0aGlzLl9jbG9zZWQgPSAhMTtcbiAgICAgIHRoaXMuX2Nsb3NlZFJlYXNvbiA9IG51bGw7XG4gICAgICB0aGlzLl90ZW1wUmVmcyA9IHRlbXBvcmFyeVJlZmVyZW5jZXM7XG4gICAgICB0aGlzLl9wZW5kaW5nQ2h1bmtzID0gMDtcbiAgICAgIHRoaXMuX3dlYWtSZXNwb25zZSA9IHsgd2VhazogbmV3IFdlYWtSZWYodGhpcyksIHJlc3BvbnNlOiB0aGlzIH07XG4gICAgICB0aGlzLl9kZWJ1Z1Jvb3RPd25lciA9IGJ1bmRsZXJDb25maWcgPVxuICAgICAgICB2b2lkIDAgPT09IFJlYWN0U2hhcmVkSW50ZXJhbHNTZXJ2ZXIgfHxcbiAgICAgICAgbnVsbCA9PT0gUmVhY3RTaGFyZWRJbnRlcmFsc1NlcnZlci5BXG4gICAgICAgICAgPyBudWxsXG4gICAgICAgICAgOiBSZWFjdFNoYXJlZEludGVyYWxzU2VydmVyLkEuZ2V0T3duZXIoKTtcbiAgICAgIHRoaXMuX2RlYnVnUm9vdFN0YWNrID1cbiAgICAgICAgbnVsbCAhPT0gYnVuZGxlckNvbmZpZyA/IEVycm9yKFwicmVhY3Qtc3RhY2stdG9wLWZyYW1lXCIpIDogbnVsbDtcbiAgICAgIGVudmlyb25tZW50TmFtZSA9IHZvaWQgMCA9PT0gZW52aXJvbm1lbnROYW1lID8gXCJTZXJ2ZXJcIiA6IGVudmlyb25tZW50TmFtZTtcbiAgICAgIHN1cHBvcnRzQ3JlYXRlVGFzayAmJlxuICAgICAgICAodGhpcy5fZGVidWdSb290VGFzayA9IGNvbnNvbGUuY3JlYXRlVGFzayhcbiAgICAgICAgICAnXCJ1c2UgJyArIGVudmlyb25tZW50TmFtZS50b0xvd2VyQ2FzZSgpICsgJ1wiJ1xuICAgICAgICApKTtcbiAgICAgIHRoaXMuX2RlYnVnRmluZFNvdXJjZU1hcFVSTCA9IGZpbmRTb3VyY2VNYXBVUkw7XG4gICAgICB0aGlzLl9kZWJ1Z0NoYW5uZWwgPSBkZWJ1Z0NoYW5uZWw7XG4gICAgICB0aGlzLl9yZXBsYXlDb25zb2xlID0gcmVwbGF5Q29uc29sZTtcbiAgICAgIHRoaXMuX3Jvb3RFbnZpcm9ubWVudE5hbWUgPSBlbnZpcm9ubWVudE5hbWU7XG4gICAgICBkZWJ1Z0NoYW5uZWwgJiZcbiAgICAgICAgKG51bGwgPT09IGRlYnVnQ2hhbm5lbFJlZ2lzdHJ5XG4gICAgICAgICAgPyAoZGVidWdDaGFubmVsKFwiXCIpLCAodGhpcy5fZGVidWdDaGFubmVsID0gdm9pZCAwKSlcbiAgICAgICAgICA6IGRlYnVnQ2hhbm5lbFJlZ2lzdHJ5LnJlZ2lzdGVyKHRoaXMsIGRlYnVnQ2hhbm5lbCkpO1xuICAgICAgdGhpcy5fZnJvbUpTT04gPSBjcmVhdGVGcm9tSlNPTkNhbGxiYWNrKHRoaXMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVTdHJlYW1TdGF0ZSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIF9yb3dTdGF0ZTogMCxcbiAgICAgICAgX3Jvd0lEOiAwLFxuICAgICAgICBfcm93VGFnOiAwLFxuICAgICAgICBfcm93TGVuZ3RoOiAwLFxuICAgICAgICBfYnVmZmVyOiBbXVxuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzb2x2ZURlYnVnSGFsdChyZXNwb25zZSwgaWQpIHtcbiAgICAgIHZhciBjaHVua3MgPSByZXNwb25zZS5fY2h1bmtzLFxuICAgICAgICBjaHVuayA9IGNodW5rcy5nZXQoaWQpO1xuICAgICAgY2h1bmsgfHwgY2h1bmtzLnNldChpZCwgKGNodW5rID0gY3JlYXRlUGVuZGluZ0NodW5rKHJlc3BvbnNlKSkpO1xuICAgICAgaWYgKFwicGVuZGluZ1wiID09PSBjaHVuay5zdGF0dXMgfHwgXCJibG9ja2VkXCIgPT09IGNodW5rLnN0YXR1cylcbiAgICAgICAgcmVsZWFzZVBlbmRpbmdDaHVuayhyZXNwb25zZSwgY2h1bmspLFxuICAgICAgICAgIChyZXNwb25zZSA9IGNodW5rKSxcbiAgICAgICAgICAocmVzcG9uc2Uuc3RhdHVzID0gXCJoYWx0ZWRcIiksXG4gICAgICAgICAgKHJlc3BvbnNlLnZhbHVlID0gbnVsbCksXG4gICAgICAgICAgKHJlc3BvbnNlLnJlYXNvbiA9IG51bGwpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNvbHZlTW9kZWwocmVzcG9uc2UsIGlkLCBtb2RlbCkge1xuICAgICAgdmFyIGNodW5rcyA9IHJlc3BvbnNlLl9jaHVua3MsXG4gICAgICAgIGNodW5rID0gY2h1bmtzLmdldChpZCk7XG4gICAgICBjaHVua1xuICAgICAgICA/IHJlc29sdmVNb2RlbENodW5rKHJlc3BvbnNlLCBjaHVuaywgbW9kZWwpXG4gICAgICAgIDogY2h1bmtzLnNldChpZCwgbmV3IFJlYWN0UHJvbWlzZShcInJlc29sdmVkX21vZGVsXCIsIG1vZGVsLCByZXNwb25zZSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNvbHZlVGV4dChyZXNwb25zZSwgaWQsIHRleHQpIHtcbiAgICAgIHZhciBjaHVua3MgPSByZXNwb25zZS5fY2h1bmtzLFxuICAgICAgICBjaHVuayA9IGNodW5rcy5nZXQoaWQpO1xuICAgICAgY2h1bmsgJiYgXCJwZW5kaW5nXCIgIT09IGNodW5rLnN0YXR1c1xuICAgICAgICA/IGNodW5rLnJlYXNvbi5lbnF1ZXVlVmFsdWUodGV4dClcbiAgICAgICAgOiAoY2h1bmsgJiYgcmVsZWFzZVBlbmRpbmdDaHVuayhyZXNwb25zZSwgY2h1bmspLFxuICAgICAgICAgIGNodW5rcy5zZXQoaWQsIG5ldyBSZWFjdFByb21pc2UoXCJmdWxmaWxsZWRcIiwgdGV4dCwgbnVsbCkpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzb2x2ZUJ1ZmZlcihyZXNwb25zZSwgaWQsIGJ1ZmZlcikge1xuICAgICAgdmFyIGNodW5rcyA9IHJlc3BvbnNlLl9jaHVua3MsXG4gICAgICAgIGNodW5rID0gY2h1bmtzLmdldChpZCk7XG4gICAgICBjaHVuayAmJiBcInBlbmRpbmdcIiAhPT0gY2h1bmsuc3RhdHVzXG4gICAgICAgID8gY2h1bmsucmVhc29uLmVucXVldWVWYWx1ZShidWZmZXIpXG4gICAgICAgIDogKGNodW5rICYmIHJlbGVhc2VQZW5kaW5nQ2h1bmsocmVzcG9uc2UsIGNodW5rKSxcbiAgICAgICAgICBjaHVua3Muc2V0KGlkLCBuZXcgUmVhY3RQcm9taXNlKFwiZnVsZmlsbGVkXCIsIGJ1ZmZlciwgbnVsbCkpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzb2x2ZU1vZHVsZShyZXNwb25zZSwgaWQsIG1vZGVsKSB7XG4gICAgICB2YXIgY2h1bmtzID0gcmVzcG9uc2UuX2NodW5rcyxcbiAgICAgICAgY2h1bmsgPSBjaHVua3MuZ2V0KGlkKTtcbiAgICAgIG1vZGVsID0gSlNPTi5wYXJzZShtb2RlbCwgcmVzcG9uc2UuX2Zyb21KU09OKTtcbiAgICAgIHZhciBjbGllbnRSZWZlcmVuY2UgPSByZXNvbHZlQ2xpZW50UmVmZXJlbmNlKFxuICAgICAgICByZXNwb25zZS5fYnVuZGxlckNvbmZpZyxcbiAgICAgICAgbW9kZWxcbiAgICAgICk7XG4gICAgICBpZiAoKG1vZGVsID0gcHJlbG9hZE1vZHVsZShjbGllbnRSZWZlcmVuY2UpKSkge1xuICAgICAgICBpZiAoY2h1bmspIHtcbiAgICAgICAgICByZWxlYXNlUGVuZGluZ0NodW5rKHJlc3BvbnNlLCBjaHVuayk7XG4gICAgICAgICAgdmFyIGJsb2NrZWRDaHVuayA9IGNodW5rO1xuICAgICAgICAgIGJsb2NrZWRDaHVuay5zdGF0dXMgPSBcImJsb2NrZWRcIjtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgKGJsb2NrZWRDaHVuayA9IG5ldyBSZWFjdFByb21pc2UoXCJibG9ja2VkXCIsIG51bGwsIG51bGwpKSxcbiAgICAgICAgICAgIGNodW5rcy5zZXQoaWQsIGJsb2NrZWRDaHVuayk7XG4gICAgICAgIG1vZGVsLnRoZW4oXG4gICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVNb2R1bGVDaHVuayhyZXNwb25zZSwgYmxvY2tlZENodW5rLCBjbGllbnRSZWZlcmVuY2UpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJpZ2dlckVycm9yT25DaHVuayhyZXNwb25zZSwgYmxvY2tlZENodW5rLCBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfSBlbHNlXG4gICAgICAgIGNodW5rXG4gICAgICAgICAgPyByZXNvbHZlTW9kdWxlQ2h1bmsocmVzcG9uc2UsIGNodW5rLCBjbGllbnRSZWZlcmVuY2UpXG4gICAgICAgICAgOiBjaHVua3Muc2V0KFxuICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgbmV3IFJlYWN0UHJvbWlzZShcInJlc29sdmVkX21vZHVsZVwiLCBjbGllbnRSZWZlcmVuY2UsIG51bGwpXG4gICAgICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNvbHZlU3RyZWFtKHJlc3BvbnNlLCBpZCwgc3RyZWFtLCBjb250cm9sbGVyKSB7XG4gICAgICB2YXIgY2h1bmtzID0gcmVzcG9uc2UuX2NodW5rcyxcbiAgICAgICAgY2h1bmsgPSBjaHVua3MuZ2V0KGlkKTtcbiAgICAgIGNodW5rXG4gICAgICAgID8gXCJwZW5kaW5nXCIgPT09IGNodW5rLnN0YXR1cyAmJlxuICAgICAgICAgIChyZWxlYXNlUGVuZGluZ0NodW5rKHJlc3BvbnNlLCBjaHVuayksXG4gICAgICAgICAgKHJlc3BvbnNlID0gY2h1bmsudmFsdWUpLFxuICAgICAgICAgIChjaHVuay5zdGF0dXMgPSBcImZ1bGZpbGxlZFwiKSxcbiAgICAgICAgICAoY2h1bmsudmFsdWUgPSBzdHJlYW0pLFxuICAgICAgICAgIChjaHVuay5yZWFzb24gPSBjb250cm9sbGVyKSxcbiAgICAgICAgICBudWxsICE9PSByZXNwb25zZSAmJiB3YWtlQ2h1bmsocmVzcG9uc2UsIGNodW5rLnZhbHVlKSlcbiAgICAgICAgOiBjaHVua3Muc2V0KGlkLCBuZXcgUmVhY3RQcm9taXNlKFwiZnVsZmlsbGVkXCIsIHN0cmVhbSwgY29udHJvbGxlcikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdGFydFJlYWRhYmxlU3RyZWFtKHJlc3BvbnNlLCBpZCwgdHlwZSkge1xuICAgICAgdmFyIGNvbnRyb2xsZXIgPSBudWxsO1xuICAgICAgdHlwZSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIHN0YXJ0OiBmdW5jdGlvbiAoYykge1xuICAgICAgICAgIGNvbnRyb2xsZXIgPSBjO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHZhciBwcmV2aW91c0Jsb2NrZWRDaHVuayA9IG51bGw7XG4gICAgICByZXNvbHZlU3RyZWFtKHJlc3BvbnNlLCBpZCwgdHlwZSwge1xuICAgICAgICBlbnF1ZXVlVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIG51bGwgPT09IHByZXZpb3VzQmxvY2tlZENodW5rXG4gICAgICAgICAgICA/IGNvbnRyb2xsZXIuZW5xdWV1ZSh2YWx1ZSlcbiAgICAgICAgICAgIDogcHJldmlvdXNCbG9ja2VkQ2h1bmsudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHZhbHVlKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVucXVldWVNb2RlbDogZnVuY3Rpb24gKGpzb24pIHtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gcHJldmlvdXNCbG9ja2VkQ2h1bmspIHtcbiAgICAgICAgICAgIHZhciBjaHVuayA9IG5ldyBSZWFjdFByb21pc2UoXCJyZXNvbHZlZF9tb2RlbFwiLCBqc29uLCByZXNwb25zZSk7XG4gICAgICAgICAgICBpbml0aWFsaXplTW9kZWxDaHVuayhjaHVuayk7XG4gICAgICAgICAgICBcImZ1bGZpbGxlZFwiID09PSBjaHVuay5zdGF0dXNcbiAgICAgICAgICAgICAgPyBjb250cm9sbGVyLmVucXVldWUoY2h1bmsudmFsdWUpXG4gICAgICAgICAgICAgIDogKGNodW5rLnRoZW4oXG4gICAgICAgICAgICAgICAgICBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udHJvbGxlci5lbnF1ZXVlKHYpO1xuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250cm9sbGVyLmVycm9yKGUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgKHByZXZpb3VzQmxvY2tlZENodW5rID0gY2h1bmspKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2h1bmsgPSBwcmV2aW91c0Jsb2NrZWRDaHVuaztcbiAgICAgICAgICAgIHZhciBfY2h1bmszID0gY3JlYXRlUGVuZGluZ0NodW5rKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIF9jaHVuazMudGhlbihcbiAgICAgICAgICAgICAgZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udHJvbGxlci5lbnF1ZXVlKHYpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250cm9sbGVyLmVycm9yKGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcHJldmlvdXNCbG9ja2VkQ2h1bmsgPSBfY2h1bmszO1xuICAgICAgICAgICAgY2h1bmsudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHByZXZpb3VzQmxvY2tlZENodW5rID09PSBfY2h1bmszICYmIChwcmV2aW91c0Jsb2NrZWRDaHVuayA9IG51bGwpO1xuICAgICAgICAgICAgICByZXNvbHZlTW9kZWxDaHVuayhyZXNwb25zZSwgX2NodW5rMywganNvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKG51bGwgPT09IHByZXZpb3VzQmxvY2tlZENodW5rKSBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgYmxvY2tlZENodW5rID0gcHJldmlvdXNCbG9ja2VkQ2h1bms7XG4gICAgICAgICAgICBwcmV2aW91c0Jsb2NrZWRDaHVuayA9IG51bGw7XG4gICAgICAgICAgICBibG9ja2VkQ2h1bmsudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gcHJldmlvdXNCbG9ja2VkQ2h1bmspIGNvbnRyb2xsZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGJsb2NrZWRDaHVuayA9IHByZXZpb3VzQmxvY2tlZENodW5rO1xuICAgICAgICAgICAgcHJldmlvdXNCbG9ja2VkQ2h1bmsgPSBudWxsO1xuICAgICAgICAgICAgYmxvY2tlZENodW5rLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gY29udHJvbGxlci5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhc3luY0l0ZXJhdG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUl0ZXJhdG9yKG5leHQpIHtcbiAgICAgIG5leHQgPSB7IG5leHQ6IG5leHQgfTtcbiAgICAgIG5leHRbQVNZTkNfSVRFUkFUT1JdID0gYXN5bmNJdGVyYXRvcjtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdGFydEFzeW5jSXRlcmFibGUocmVzcG9uc2UsIGlkLCBpdGVyYXRvcikge1xuICAgICAgdmFyIGJ1ZmZlciA9IFtdLFxuICAgICAgICBjbG9zZWQgPSAhMSxcbiAgICAgICAgbmV4dFdyaXRlSW5kZXggPSAwLFxuICAgICAgICBpdGVyYWJsZSA9IHt9O1xuICAgICAgaXRlcmFibGVbQVNZTkNfSVRFUkFUT1JdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmV4dFJlYWRJbmRleCA9IDA7XG4gICAgICAgIHJldHVybiBjcmVhdGVJdGVyYXRvcihmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgaWYgKHZvaWQgMCAhPT0gYXJnKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgIFwiVmFsdWVzIGNhbm5vdCBiZSBwYXNzZWQgdG8gbmV4dCgpIG9mIEFzeW5jSXRlcmFibGVzIHBhc3NlZCB0byBDbGllbnQgQ29tcG9uZW50cy5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBpZiAobmV4dFJlYWRJbmRleCA9PT0gYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGNsb3NlZClcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWFjdFByb21pc2UoXG4gICAgICAgICAgICAgICAgXCJmdWxmaWxsZWRcIixcbiAgICAgICAgICAgICAgICB7IGRvbmU6ICEwLCB2YWx1ZTogdm9pZCAwIH0sXG4gICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgYnVmZmVyW25leHRSZWFkSW5kZXhdID0gY3JlYXRlUGVuZGluZ0NodW5rKHJlc3BvbnNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGJ1ZmZlcltuZXh0UmVhZEluZGV4KytdO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICByZXNvbHZlU3RyZWFtKFxuICAgICAgICByZXNwb25zZSxcbiAgICAgICAgaWQsXG4gICAgICAgIGl0ZXJhdG9yID8gaXRlcmFibGVbQVNZTkNfSVRFUkFUT1JdKCkgOiBpdGVyYWJsZSxcbiAgICAgICAge1xuICAgICAgICAgIGVucXVldWVWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAobmV4dFdyaXRlSW5kZXggPT09IGJ1ZmZlci5sZW5ndGgpXG4gICAgICAgICAgICAgIGJ1ZmZlcltuZXh0V3JpdGVJbmRleF0gPSBuZXcgUmVhY3RQcm9taXNlKFxuICAgICAgICAgICAgICAgIFwiZnVsZmlsbGVkXCIsXG4gICAgICAgICAgICAgICAgeyBkb25lOiAhMSwgdmFsdWU6IHZhbHVlIH0sXG4gICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBjaHVuayA9IGJ1ZmZlcltuZXh0V3JpdGVJbmRleF0sXG4gICAgICAgICAgICAgICAgcmVzb2x2ZUxpc3RlbmVycyA9IGNodW5rLnZhbHVlLFxuICAgICAgICAgICAgICAgIHJlamVjdExpc3RlbmVycyA9IGNodW5rLnJlYXNvbjtcbiAgICAgICAgICAgICAgY2h1bmsuc3RhdHVzID0gXCJmdWxmaWxsZWRcIjtcbiAgICAgICAgICAgICAgY2h1bmsudmFsdWUgPSB7IGRvbmU6ICExLCB2YWx1ZTogdmFsdWUgfTtcbiAgICAgICAgICAgICAgbnVsbCAhPT0gcmVzb2x2ZUxpc3RlbmVycyAmJlxuICAgICAgICAgICAgICAgIHdha2VDaHVua0lmSW5pdGlhbGl6ZWQoXG4gICAgICAgICAgICAgICAgICBjaHVuayxcbiAgICAgICAgICAgICAgICAgIHJlc29sdmVMaXN0ZW5lcnMsXG4gICAgICAgICAgICAgICAgICByZWplY3RMaXN0ZW5lcnNcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dFdyaXRlSW5kZXgrKztcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVucXVldWVNb2RlbDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBuZXh0V3JpdGVJbmRleCA9PT0gYnVmZmVyLmxlbmd0aFxuICAgICAgICAgICAgICA/IChidWZmZXJbbmV4dFdyaXRlSW5kZXhdID0gY3JlYXRlUmVzb2x2ZWRJdGVyYXRvclJlc3VsdENodW5rKFxuICAgICAgICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICExXG4gICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgOiByZXNvbHZlSXRlcmF0b3JSZXN1bHRDaHVuayhcbiAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgYnVmZmVyW25leHRXcml0ZUluZGV4XSxcbiAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgbmV4dFdyaXRlSW5kZXgrKztcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNsb3NlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGNsb3NlZCA9ICEwO1xuICAgICAgICAgICAgbmV4dFdyaXRlSW5kZXggPT09IGJ1ZmZlci5sZW5ndGhcbiAgICAgICAgICAgICAgPyAoYnVmZmVyW25leHRXcml0ZUluZGV4XSA9IGNyZWF0ZVJlc29sdmVkSXRlcmF0b3JSZXN1bHRDaHVuayhcbiAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAhMFxuICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICAgIDogcmVzb2x2ZUl0ZXJhdG9yUmVzdWx0Q2h1bmsoXG4gICAgICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgIGJ1ZmZlcltuZXh0V3JpdGVJbmRleF0sXG4gICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICEwXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGZvciAobmV4dFdyaXRlSW5kZXgrKzsgbmV4dFdyaXRlSW5kZXggPCBidWZmZXIubGVuZ3RoOyApXG4gICAgICAgICAgICAgIHJlc29sdmVJdGVyYXRvclJlc3VsdENodW5rKFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIGJ1ZmZlcltuZXh0V3JpdGVJbmRleCsrXSxcbiAgICAgICAgICAgICAgICAnXCIkdW5kZWZpbmVkXCInLFxuICAgICAgICAgICAgICAgICEwXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlcnJvcjogZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBjbG9zZWQgPSAhMDtcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIG5leHRXcml0ZUluZGV4ID09PSBidWZmZXIubGVuZ3RoICYmXG4gICAgICAgICAgICAgIChidWZmZXJbbmV4dFdyaXRlSW5kZXhdID0gY3JlYXRlUGVuZGluZ0NodW5rKHJlc3BvbnNlKSk7XG4gICAgICAgICAgICAgIG5leHRXcml0ZUluZGV4IDwgYnVmZmVyLmxlbmd0aDtcblxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB0cmlnZ2VyRXJyb3JPbkNodW5rKHJlc3BvbnNlLCBidWZmZXJbbmV4dFdyaXRlSW5kZXgrK10sIGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0b3BTdHJlYW0ocmVzcG9uc2UsIGlkLCByb3cpIHtcbiAgICAgIChyZXNwb25zZSA9IHJlc3BvbnNlLl9jaHVua3MuZ2V0KGlkKSkgJiZcbiAgICAgICAgXCJmdWxmaWxsZWRcIiA9PT0gcmVzcG9uc2Uuc3RhdHVzICYmXG4gICAgICAgIHJlc3BvbnNlLnJlYXNvbi5jbG9zZShcIlwiID09PSByb3cgPyAnXCIkdW5kZWZpbmVkXCInIDogcm93KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzb2x2ZUVycm9yRGV2KHJlc3BvbnNlLCBlcnJvckluZm8pIHtcbiAgICAgIHZhciBuYW1lID0gZXJyb3JJbmZvLm5hbWUsXG4gICAgICAgIGVudiA9IGVycm9ySW5mby5lbnY7XG4gICAgICBlcnJvckluZm8gPSBidWlsZEZha2VDYWxsU3RhY2soXG4gICAgICAgIHJlc3BvbnNlLFxuICAgICAgICBlcnJvckluZm8uc3RhY2ssXG4gICAgICAgIGVudixcbiAgICAgICAgITEsXG4gICAgICAgIEVycm9yLmJpbmQoXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBlcnJvckluZm8ubWVzc2FnZSB8fFxuICAgICAgICAgICAgXCJBbiBlcnJvciBvY2N1cnJlZCBpbiB0aGUgU2VydmVyIENvbXBvbmVudHMgcmVuZGVyIGJ1dCBubyBtZXNzYWdlIHdhcyBwcm92aWRlZFwiXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICByZXNwb25zZSA9IGdldFJvb3RUYXNrKHJlc3BvbnNlLCBlbnYpO1xuICAgICAgcmVzcG9uc2UgPSBudWxsICE9IHJlc3BvbnNlID8gcmVzcG9uc2UucnVuKGVycm9ySW5mbykgOiBlcnJvckluZm8oKTtcbiAgICAgIHJlc3BvbnNlLm5hbWUgPSBuYW1lO1xuICAgICAgcmVzcG9uc2UuZW52aXJvbm1lbnROYW1lID0gZW52O1xuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNvbHZlSGludChyZXNwb25zZSwgY29kZSwgbW9kZWwpIHtcbiAgICAgIHJlc3BvbnNlID0gSlNPTi5wYXJzZShtb2RlbCwgcmVzcG9uc2UuX2Zyb21KU09OKTtcbiAgICAgIG1vZGVsID0gUmVhY3RET01TaGFyZWRJbnRlcm5hbHMuZDtcbiAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICBjYXNlIFwiRFwiOlxuICAgICAgICAgIG1vZGVsLkQocmVzcG9uc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiQ1wiOlxuICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiByZXNwb25zZVxuICAgICAgICAgICAgPyBtb2RlbC5DKHJlc3BvbnNlKVxuICAgICAgICAgICAgOiBtb2RlbC5DKHJlc3BvbnNlWzBdLCByZXNwb25zZVsxXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJMXCI6XG4gICAgICAgICAgY29kZSA9IHJlc3BvbnNlWzBdO1xuICAgICAgICAgIHZhciBhcyA9IHJlc3BvbnNlWzFdO1xuICAgICAgICAgIDMgPT09IHJlc3BvbnNlLmxlbmd0aFxuICAgICAgICAgICAgPyBtb2RlbC5MKGNvZGUsIGFzLCByZXNwb25zZVsyXSlcbiAgICAgICAgICAgIDogbW9kZWwuTChjb2RlLCBhcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJtXCI6XG4gICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHJlc3BvbnNlXG4gICAgICAgICAgICA/IG1vZGVsLm0ocmVzcG9uc2UpXG4gICAgICAgICAgICA6IG1vZGVsLm0ocmVzcG9uc2VbMF0sIHJlc3BvbnNlWzFdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlhcIjpcbiAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgcmVzcG9uc2VcbiAgICAgICAgICAgID8gbW9kZWwuWChyZXNwb25zZSlcbiAgICAgICAgICAgIDogbW9kZWwuWChyZXNwb25zZVswXSwgcmVzcG9uc2VbMV0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiU1wiOlxuICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiByZXNwb25zZVxuICAgICAgICAgICAgPyBtb2RlbC5TKHJlc3BvbnNlKVxuICAgICAgICAgICAgOiBtb2RlbC5TKFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlWzBdLFxuICAgICAgICAgICAgICAgIDAgPT09IHJlc3BvbnNlWzFdID8gdm9pZCAwIDogcmVzcG9uc2VbMV0sXG4gICAgICAgICAgICAgICAgMyA9PT0gcmVzcG9uc2UubGVuZ3RoID8gcmVzcG9uc2VbMl0gOiB2b2lkIDBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIk1cIjpcbiAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgcmVzcG9uc2VcbiAgICAgICAgICAgID8gbW9kZWwuTShyZXNwb25zZSlcbiAgICAgICAgICAgIDogbW9kZWwuTShyZXNwb25zZVswXSwgcmVzcG9uc2VbMV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVGYWtlRnVuY3Rpb24oXG4gICAgICBuYW1lLFxuICAgICAgZmlsZW5hbWUsXG4gICAgICBzb3VyY2VNYXAsXG4gICAgICBsaW5lLFxuICAgICAgY29sLFxuICAgICAgZW5jbG9zaW5nTGluZSxcbiAgICAgIGVuY2xvc2luZ0NvbCxcbiAgICAgIGVudmlyb25tZW50TmFtZVxuICAgICkge1xuICAgICAgbmFtZSB8fCAobmFtZSA9IFwiPGFub255bW91cz5cIik7XG4gICAgICB2YXIgZW5jb2RlZE5hbWUgPSBKU09OLnN0cmluZ2lmeShuYW1lKTtcbiAgICAgIDEgPiBlbmNsb3NpbmdMaW5lID8gKGVuY2xvc2luZ0xpbmUgPSAwKSA6IGVuY2xvc2luZ0xpbmUtLTtcbiAgICAgIDEgPiBlbmNsb3NpbmdDb2wgPyAoZW5jbG9zaW5nQ29sID0gMCkgOiBlbmNsb3NpbmdDb2wtLTtcbiAgICAgIDEgPiBsaW5lID8gKGxpbmUgPSAwKSA6IGxpbmUtLTtcbiAgICAgIDEgPiBjb2wgPyAoY29sID0gMCkgOiBjb2wtLTtcbiAgICAgIGlmIChcbiAgICAgICAgbGluZSA8IGVuY2xvc2luZ0xpbmUgfHxcbiAgICAgICAgKGxpbmUgPT09IGVuY2xvc2luZ0xpbmUgJiYgY29sIDwgZW5jbG9zaW5nQ29sKVxuICAgICAgKVxuICAgICAgICBlbmNsb3NpbmdDb2wgPSBlbmNsb3NpbmdMaW5lID0gMDtcbiAgICAgIDEgPiBsaW5lXG4gICAgICAgID8gKChsaW5lID0gZW5jb2RlZE5hbWUubGVuZ3RoICsgMyksXG4gICAgICAgICAgKGVuY2xvc2luZ0NvbCAtPSBsaW5lKSxcbiAgICAgICAgICAwID4gZW5jbG9zaW5nQ29sICYmIChlbmNsb3NpbmdDb2wgPSAwKSxcbiAgICAgICAgICAoY29sID0gY29sIC0gZW5jbG9zaW5nQ29sIC0gbGluZSAtIDMpLFxuICAgICAgICAgIDAgPiBjb2wgJiYgKGNvbCA9IDApLFxuICAgICAgICAgIChlbmNvZGVkTmFtZSA9XG4gICAgICAgICAgICBcIih7XCIgK1xuICAgICAgICAgICAgZW5jb2RlZE5hbWUgK1xuICAgICAgICAgICAgXCI6XCIgK1xuICAgICAgICAgICAgXCIgXCIucmVwZWF0KGVuY2xvc2luZ0NvbCkgK1xuICAgICAgICAgICAgXCJfPT5cIiArXG4gICAgICAgICAgICBcIiBcIi5yZXBlYXQoY29sKSArXG4gICAgICAgICAgICBcIl8oKX0pXCIpKVxuICAgICAgICA6IDEgPiBlbmNsb3NpbmdMaW5lXG4gICAgICAgICAgPyAoKGVuY2xvc2luZ0NvbCAtPSBlbmNvZGVkTmFtZS5sZW5ndGggKyAzKSxcbiAgICAgICAgICAgIDAgPiBlbmNsb3NpbmdDb2wgJiYgKGVuY2xvc2luZ0NvbCA9IDApLFxuICAgICAgICAgICAgKGVuY29kZWROYW1lID1cbiAgICAgICAgICAgICAgXCIoe1wiICtcbiAgICAgICAgICAgICAgZW5jb2RlZE5hbWUgK1xuICAgICAgICAgICAgICBcIjpcIiArXG4gICAgICAgICAgICAgIFwiIFwiLnJlcGVhdChlbmNsb3NpbmdDb2wpICtcbiAgICAgICAgICAgICAgXCJfPT5cIiArXG4gICAgICAgICAgICAgIFwiXFxuXCIucmVwZWF0KGxpbmUgLSBlbmNsb3NpbmdMaW5lKSArXG4gICAgICAgICAgICAgIFwiIFwiLnJlcGVhdChjb2wpICtcbiAgICAgICAgICAgICAgXCJfKCl9KVwiKSlcbiAgICAgICAgICA6IGVuY2xvc2luZ0xpbmUgPT09IGxpbmVcbiAgICAgICAgICAgID8gKChjb2wgPSBjb2wgLSBlbmNsb3NpbmdDb2wgLSAzKSxcbiAgICAgICAgICAgICAgMCA+IGNvbCAmJiAoY29sID0gMCksXG4gICAgICAgICAgICAgIChlbmNvZGVkTmFtZSA9XG4gICAgICAgICAgICAgICAgXCJcXG5cIi5yZXBlYXQoZW5jbG9zaW5nTGluZSAtIDEpICtcbiAgICAgICAgICAgICAgICBcIih7XCIgK1xuICAgICAgICAgICAgICAgIGVuY29kZWROYW1lICtcbiAgICAgICAgICAgICAgICBcIjpcXG5cIiArXG4gICAgICAgICAgICAgICAgXCIgXCIucmVwZWF0KGVuY2xvc2luZ0NvbCkgK1xuICAgICAgICAgICAgICAgIFwiXz0+XCIgK1xuICAgICAgICAgICAgICAgIFwiIFwiLnJlcGVhdChjb2wpICtcbiAgICAgICAgICAgICAgICBcIl8oKX0pXCIpKVxuICAgICAgICAgICAgOiAoZW5jb2RlZE5hbWUgPVxuICAgICAgICAgICAgICAgIFwiXFxuXCIucmVwZWF0KGVuY2xvc2luZ0xpbmUgLSAxKSArXG4gICAgICAgICAgICAgICAgXCIoe1wiICtcbiAgICAgICAgICAgICAgICBlbmNvZGVkTmFtZSArXG4gICAgICAgICAgICAgICAgXCI6XFxuXCIgK1xuICAgICAgICAgICAgICAgIFwiIFwiLnJlcGVhdChlbmNsb3NpbmdDb2wpICtcbiAgICAgICAgICAgICAgICBcIl89PlwiICtcbiAgICAgICAgICAgICAgICBcIlxcblwiLnJlcGVhdChsaW5lIC0gZW5jbG9zaW5nTGluZSkgK1xuICAgICAgICAgICAgICAgIFwiIFwiLnJlcGVhdChjb2wpICtcbiAgICAgICAgICAgICAgICBcIl8oKX0pXCIpO1xuICAgICAgZW5jb2RlZE5hbWUgPVxuICAgICAgICAxID4gZW5jbG9zaW5nTGluZVxuICAgICAgICAgID8gZW5jb2RlZE5hbWUgK1xuICAgICAgICAgICAgXCJcXG4vKiBUaGlzIG1vZHVsZSB3YXMgcmVuZGVyZWQgYnkgYSBTZXJ2ZXIgQ29tcG9uZW50LiBUdXJuIG9uIFNvdXJjZSBNYXBzIHRvIHNlZSB0aGUgc2VydmVyIHNvdXJjZS4gKi9cIlxuICAgICAgICAgIDogXCIvKiBUaGlzIG1vZHVsZSB3YXMgcmVuZGVyZWQgYnkgYSBTZXJ2ZXIgQ29tcG9uZW50LiBUdXJuIG9uIFNvdXJjZSBNYXBzIHRvIHNlZSB0aGUgc2VydmVyIHNvdXJjZS4gKi9cIiArXG4gICAgICAgICAgICBlbmNvZGVkTmFtZTtcbiAgICAgIGZpbGVuYW1lLnN0YXJ0c1dpdGgoXCIvXCIpICYmIChmaWxlbmFtZSA9IFwiZmlsZTovL1wiICsgZmlsZW5hbWUpO1xuICAgICAgc291cmNlTWFwXG4gICAgICAgID8gKChlbmNvZGVkTmFtZSArPVxuICAgICAgICAgICAgXCJcXG4vLyMgc291cmNlVVJMPXJzYzovL1JlYWN0L1wiICtcbiAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChlbnZpcm9ubWVudE5hbWUpICtcbiAgICAgICAgICAgIFwiL1wiICtcbiAgICAgICAgICAgIGVuY29kZVVSSShmaWxlbmFtZSkgK1xuICAgICAgICAgICAgXCI/XCIgK1xuICAgICAgICAgICAgZmFrZUZ1bmN0aW9uSWR4KyspLFxuICAgICAgICAgIChlbmNvZGVkTmFtZSArPSBcIlxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVwiICsgc291cmNlTWFwKSlcbiAgICAgICAgOiAoZW5jb2RlZE5hbWUgPSBmaWxlbmFtZVxuICAgICAgICAgICAgPyBlbmNvZGVkTmFtZSArIChcIlxcbi8vIyBzb3VyY2VVUkw9XCIgKyBlbmNvZGVVUkkoZmlsZW5hbWUpKVxuICAgICAgICAgICAgOiBlbmNvZGVkTmFtZSArIFwiXFxuLy8jIHNvdXJjZVVSTD08YW5vbnltb3VzPlwiKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBmbiA9ICgwLCBldmFsKShlbmNvZGVkTmFtZSlbbmFtZV07XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIGZuID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICByZXR1cm4gXygpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBidWlsZEZha2VDYWxsU3RhY2soXG4gICAgICByZXNwb25zZSxcbiAgICAgIHN0YWNrLFxuICAgICAgZW52aXJvbm1lbnROYW1lLFxuICAgICAgdXNlRW5jbG9zaW5nTGluZSxcbiAgICAgIGlubmVyQ2FsbFxuICAgICkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZnJhbWUgPSBzdGFja1tpXSxcbiAgICAgICAgICBmcmFtZUtleSA9XG4gICAgICAgICAgICBmcmFtZS5qb2luKFwiLVwiKSArXG4gICAgICAgICAgICBcIi1cIiArXG4gICAgICAgICAgICBlbnZpcm9ubWVudE5hbWUgK1xuICAgICAgICAgICAgKHVzZUVuY2xvc2luZ0xpbmUgPyBcIi1lXCIgOiBcIi1uXCIpLFxuICAgICAgICAgIGZuID0gZmFrZUZ1bmN0aW9uQ2FjaGUuZ2V0KGZyYW1lS2V5KTtcbiAgICAgICAgaWYgKHZvaWQgMCA9PT0gZm4pIHtcbiAgICAgICAgICBmbiA9IGZyYW1lWzBdO1xuICAgICAgICAgIHZhciBmaWxlbmFtZSA9IGZyYW1lWzFdLFxuICAgICAgICAgICAgbGluZSA9IGZyYW1lWzJdLFxuICAgICAgICAgICAgY29sID0gZnJhbWVbM10sXG4gICAgICAgICAgICBlbmNsb3NpbmdMaW5lID0gZnJhbWVbNF07XG4gICAgICAgICAgZnJhbWUgPSBmcmFtZVs1XTtcbiAgICAgICAgICB2YXIgZmluZFNvdXJjZU1hcFVSTCA9IHJlc3BvbnNlLl9kZWJ1Z0ZpbmRTb3VyY2VNYXBVUkw7XG4gICAgICAgICAgZmluZFNvdXJjZU1hcFVSTCA9IGZpbmRTb3VyY2VNYXBVUkxcbiAgICAgICAgICAgID8gZmluZFNvdXJjZU1hcFVSTChmaWxlbmFtZSwgZW52aXJvbm1lbnROYW1lKVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgIGZuID0gY3JlYXRlRmFrZUZ1bmN0aW9uKFxuICAgICAgICAgICAgZm4sXG4gICAgICAgICAgICBmaWxlbmFtZSxcbiAgICAgICAgICAgIGZpbmRTb3VyY2VNYXBVUkwsXG4gICAgICAgICAgICBsaW5lLFxuICAgICAgICAgICAgY29sLFxuICAgICAgICAgICAgdXNlRW5jbG9zaW5nTGluZSA/IGxpbmUgOiBlbmNsb3NpbmdMaW5lLFxuICAgICAgICAgICAgdXNlRW5jbG9zaW5nTGluZSA/IGNvbCA6IGZyYW1lLFxuICAgICAgICAgICAgZW52aXJvbm1lbnROYW1lXG4gICAgICAgICAgKTtcbiAgICAgICAgICBmYWtlRnVuY3Rpb25DYWNoZS5zZXQoZnJhbWVLZXksIGZuKTtcbiAgICAgICAgfVxuICAgICAgICBpbm5lckNhbGwgPSBmbi5iaW5kKG51bGwsIGlubmVyQ2FsbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5uZXJDYWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRSb290VGFzayhyZXNwb25zZSwgY2hpbGRFbnZpcm9ubWVudE5hbWUpIHtcbiAgICAgIHZhciByb290VGFzayA9IHJlc3BvbnNlLl9kZWJ1Z1Jvb3RUYXNrO1xuICAgICAgcmV0dXJuIHJvb3RUYXNrXG4gICAgICAgID8gcmVzcG9uc2UuX3Jvb3RFbnZpcm9ubWVudE5hbWUgIT09IGNoaWxkRW52aXJvbm1lbnROYW1lXG4gICAgICAgICAgPyAoKHJlc3BvbnNlID0gY29uc29sZS5jcmVhdGVUYXNrLmJpbmQoXG4gICAgICAgICAgICAgIGNvbnNvbGUsXG4gICAgICAgICAgICAgICdcInVzZSAnICsgY2hpbGRFbnZpcm9ubWVudE5hbWUudG9Mb3dlckNhc2UoKSArICdcIidcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgcm9vdFRhc2sucnVuKHJlc3BvbnNlKSlcbiAgICAgICAgICA6IHJvb3RUYXNrXG4gICAgICAgIDogbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW5pdGlhbGl6ZUZha2VUYXNrKHJlc3BvbnNlLCBkZWJ1Z0luZm8pIHtcbiAgICAgIGlmICghc3VwcG9ydHNDcmVhdGVUYXNrIHx8IG51bGwgPT0gZGVidWdJbmZvLnN0YWNrKSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBjYWNoZWRFbnRyeSA9IGRlYnVnSW5mby5kZWJ1Z1Rhc2s7XG4gICAgICBpZiAodm9pZCAwICE9PSBjYWNoZWRFbnRyeSkgcmV0dXJuIGNhY2hlZEVudHJ5O1xuICAgICAgdmFyIHVzZUVuY2xvc2luZ0xpbmUgPSB2b2lkIDAgPT09IGRlYnVnSW5mby5rZXksXG4gICAgICAgIHN0YWNrID0gZGVidWdJbmZvLnN0YWNrLFxuICAgICAgICBlbnYgPVxuICAgICAgICAgIG51bGwgPT0gZGVidWdJbmZvLmVudiA/IHJlc3BvbnNlLl9yb290RW52aXJvbm1lbnROYW1lIDogZGVidWdJbmZvLmVudjtcbiAgICAgIGNhY2hlZEVudHJ5ID1cbiAgICAgICAgbnVsbCA9PSBkZWJ1Z0luZm8ub3duZXIgfHwgbnVsbCA9PSBkZWJ1Z0luZm8ub3duZXIuZW52XG4gICAgICAgICAgPyByZXNwb25zZS5fcm9vdEVudmlyb25tZW50TmFtZVxuICAgICAgICAgIDogZGVidWdJbmZvLm93bmVyLmVudjtcbiAgICAgIHZhciBvd25lclRhc2sgPVxuICAgICAgICBudWxsID09IGRlYnVnSW5mby5vd25lclxuICAgICAgICAgID8gbnVsbFxuICAgICAgICAgIDogaW5pdGlhbGl6ZUZha2VUYXNrKHJlc3BvbnNlLCBkZWJ1Z0luZm8ub3duZXIpO1xuICAgICAgZW52ID1cbiAgICAgICAgZW52ICE9PSBjYWNoZWRFbnRyeVxuICAgICAgICAgID8gJ1widXNlICcgKyBlbnYudG9Mb3dlckNhc2UoKSArICdcIidcbiAgICAgICAgICA6IHZvaWQgMCAhPT0gZGVidWdJbmZvLmtleVxuICAgICAgICAgICAgPyBcIjxcIiArIChkZWJ1Z0luZm8ubmFtZSB8fCBcIi4uLlwiKSArIFwiPlwiXG4gICAgICAgICAgICA6IHZvaWQgMCAhPT0gZGVidWdJbmZvLm5hbWVcbiAgICAgICAgICAgICAgPyBkZWJ1Z0luZm8ubmFtZSB8fCBcInVua25vd25cIlxuICAgICAgICAgICAgICA6IFwiYXdhaXQgXCIgKyAoZGVidWdJbmZvLmF3YWl0ZWQubmFtZSB8fCBcInVua25vd25cIik7XG4gICAgICBlbnYgPSBjb25zb2xlLmNyZWF0ZVRhc2suYmluZChjb25zb2xlLCBlbnYpO1xuICAgICAgdXNlRW5jbG9zaW5nTGluZSA9IGJ1aWxkRmFrZUNhbGxTdGFjayhcbiAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgIHN0YWNrLFxuICAgICAgICBjYWNoZWRFbnRyeSxcbiAgICAgICAgdXNlRW5jbG9zaW5nTGluZSxcbiAgICAgICAgZW52XG4gICAgICApO1xuICAgICAgbnVsbCA9PT0gb3duZXJUYXNrXG4gICAgICAgID8gKChyZXNwb25zZSA9IGdldFJvb3RUYXNrKHJlc3BvbnNlLCBjYWNoZWRFbnRyeSkpLFxuICAgICAgICAgIChyZXNwb25zZSA9XG4gICAgICAgICAgICBudWxsICE9IHJlc3BvbnNlXG4gICAgICAgICAgICAgID8gcmVzcG9uc2UucnVuKHVzZUVuY2xvc2luZ0xpbmUpXG4gICAgICAgICAgICAgIDogdXNlRW5jbG9zaW5nTGluZSgpKSlcbiAgICAgICAgOiAocmVzcG9uc2UgPSBvd25lclRhc2sucnVuKHVzZUVuY2xvc2luZ0xpbmUpKTtcbiAgICAgIHJldHVybiAoZGVidWdJbmZvLmRlYnVnVGFzayA9IHJlc3BvbnNlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmFrZUpTWENhbGxTaXRlKCkge1xuICAgICAgcmV0dXJuIEVycm9yKFwicmVhY3Qtc3RhY2stdG9wLWZyYW1lXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbml0aWFsaXplRmFrZVN0YWNrKHJlc3BvbnNlLCBkZWJ1Z0luZm8pIHtcbiAgICAgIGlmICh2b2lkIDAgPT09IGRlYnVnSW5mby5kZWJ1Z1N0YWNrKSB7XG4gICAgICAgIG51bGwgIT0gZGVidWdJbmZvLnN0YWNrICYmXG4gICAgICAgICAgKGRlYnVnSW5mby5kZWJ1Z1N0YWNrID0gY3JlYXRlRmFrZUpTWENhbGxTdGFja0luREVWKFxuICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICBkZWJ1Z0luZm8uc3RhY2ssXG4gICAgICAgICAgICBudWxsID09IGRlYnVnSW5mby5lbnYgPyBcIlwiIDogZGVidWdJbmZvLmVudlxuICAgICAgICAgICkpO1xuICAgICAgICB2YXIgb3duZXIgPSBkZWJ1Z0luZm8ub3duZXI7XG4gICAgICAgIG51bGwgIT0gb3duZXIgJiZcbiAgICAgICAgICAoaW5pdGlhbGl6ZUZha2VTdGFjayhyZXNwb25zZSwgb3duZXIpLFxuICAgICAgICAgIHZvaWQgMCA9PT0gb3duZXIuZGVidWdMb2NhdGlvbiAmJlxuICAgICAgICAgICAgbnVsbCAhPSBkZWJ1Z0luZm8uZGVidWdTdGFjayAmJlxuICAgICAgICAgICAgKG93bmVyLmRlYnVnTG9jYXRpb24gPSBkZWJ1Z0luZm8uZGVidWdTdGFjaykpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZXNvbHZlRGVidWdJbmZvKHJlc3BvbnNlLCBpZCwgZGVidWdJbmZvKSB7XG4gICAgICB2b2lkIDAgIT09IGRlYnVnSW5mby5zdGFjayAmJiBpbml0aWFsaXplRmFrZVRhc2socmVzcG9uc2UsIGRlYnVnSW5mbyk7XG4gICAgICBudWxsID09IGRlYnVnSW5mby5vd25lciAmJiBudWxsICE9IHJlc3BvbnNlLl9kZWJ1Z1Jvb3RPd25lclxuICAgICAgICA/ICgoZGVidWdJbmZvLm93bmVyID0gcmVzcG9uc2UuX2RlYnVnUm9vdE93bmVyKSxcbiAgICAgICAgICAoZGVidWdJbmZvLnN0YWNrID0gbnVsbCksXG4gICAgICAgICAgKGRlYnVnSW5mby5kZWJ1Z1N0YWNrID0gcmVzcG9uc2UuX2RlYnVnUm9vdFN0YWNrKSxcbiAgICAgICAgICAoZGVidWdJbmZvLmRlYnVnVGFzayA9IHJlc3BvbnNlLl9kZWJ1Z1Jvb3RUYXNrKSlcbiAgICAgICAgOiB2b2lkIDAgIT09IGRlYnVnSW5mby5zdGFjayAmJlxuICAgICAgICAgIGluaXRpYWxpemVGYWtlU3RhY2socmVzcG9uc2UsIGRlYnVnSW5mbyk7XG4gICAgICByZXNwb25zZSA9IGdldENodW5rKHJlc3BvbnNlLCBpZCk7XG4gICAgICAocmVzcG9uc2UuX2RlYnVnSW5mbyB8fCAocmVzcG9uc2UuX2RlYnVnSW5mbyA9IFtdKSkucHVzaChkZWJ1Z0luZm8pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRDdXJyZW50U3RhY2tJbkRFVigpIHtcbiAgICAgIHZhciBvd25lciA9IGN1cnJlbnRPd25lckluREVWO1xuICAgICAgaWYgKG51bGwgPT09IG93bmVyKSByZXR1cm4gXCJcIjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBpbmZvID0gXCJcIjtcbiAgICAgICAgaWYgKG93bmVyLm93bmVyIHx8IFwic3RyaW5nXCIgIT09IHR5cGVvZiBvd25lci5uYW1lKSB7XG4gICAgICAgICAgZm9yICg7IG93bmVyOyApIHtcbiAgICAgICAgICAgIHZhciBvd25lclN0YWNrID0gb3duZXIuZGVidWdTdGFjaztcbiAgICAgICAgICAgIGlmIChudWxsICE9IG93bmVyU3RhY2spIHtcbiAgICAgICAgICAgICAgaWYgKChvd25lciA9IG93bmVyLm93bmVyKSkge1xuICAgICAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX3RlbXBfY29uc3QgPSBpbmZvO1xuICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IG93bmVyU3RhY2ssXG4gICAgICAgICAgICAgICAgICBwcmV2UHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTtcbiAgICAgICAgICAgICAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB2YXIgc3RhY2sgPSBlcnJvci5zdGFjaztcbiAgICAgICAgICAgICAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXZQcmVwYXJlU3RhY2tUcmFjZTtcbiAgICAgICAgICAgICAgICBzdGFjay5zdGFydHNXaXRoKFwiRXJyb3I6IHJlYWN0LXN0YWNrLXRvcC1mcmFtZVxcblwiKSAmJlxuICAgICAgICAgICAgICAgICAgKHN0YWNrID0gc3RhY2suc2xpY2UoMjkpKTtcbiAgICAgICAgICAgICAgICB2YXIgaWR4ID0gc3RhY2suaW5kZXhPZihcIlxcblwiKTtcbiAgICAgICAgICAgICAgICAtMSAhPT0gaWR4ICYmIChzdGFjayA9IHN0YWNrLnNsaWNlKGlkeCArIDEpKTtcbiAgICAgICAgICAgICAgICBpZHggPSBzdGFjay5pbmRleE9mKFwicmVhY3Rfc3RhY2tfYm90dG9tX2ZyYW1lXCIpO1xuICAgICAgICAgICAgICAgIC0xICE9PSBpZHggJiYgKGlkeCA9IHN0YWNrLmxhc3RJbmRleE9mKFwiXFxuXCIsIGlkeCkpO1xuICAgICAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPVxuICAgICAgICAgICAgICAgICAgLTEgIT09IGlkeCA/IChzdGFjayA9IHN0YWNrLnNsaWNlKDAsIGlkeCkpIDogXCJcIjtcbiAgICAgICAgICAgICAgICBpbmZvID1cbiAgICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcF9jb25zdCArIChcIlxcblwiICsgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwID0gaW5mbztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBKU0NvbXBpbGVyX3RlbXBfY29uc3QgPSBvd25lci5uYW1lO1xuICAgICAgICAgIGlmICh2b2lkIDAgPT09IHByZWZpeClcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIChwcmVmaXggPVxuICAgICAgICAgICAgICAgICgoZXJyb3IgPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pKSAmJiBlcnJvclsxXSkgfHxcbiAgICAgICAgICAgICAgICBcIlwiKSxcbiAgICAgICAgICAgICAgICAoc3VmZml4ID1cbiAgICAgICAgICAgICAgICAgIC0xIDwgeC5zdGFjay5pbmRleE9mKFwiXFxuICAgIGF0XCIpXG4gICAgICAgICAgICAgICAgICAgID8gXCIgKDxhbm9ueW1vdXM+KVwiXG4gICAgICAgICAgICAgICAgICAgIDogLTEgPCB4LnN0YWNrLmluZGV4T2YoXCJAXCIpXG4gICAgICAgICAgICAgICAgICAgICAgPyBcIkB1bmtub3duOjA6MFwiXG4gICAgICAgICAgICAgICAgICAgICAgOiBcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDAgPVxuICAgICAgICAgICAgXCJcXG5cIiArIHByZWZpeCArIEpTQ29tcGlsZXJfdGVtcF9jb25zdCArIHN1ZmZpeDtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDAgPVxuICAgICAgICAgIFwiXFxuRXJyb3IgZ2VuZXJhdGluZyBzdGFjazogXCIgKyB4Lm1lc3NhZ2UgKyBcIlxcblwiICsgeC5zdGFjaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc29sdmVDb25zb2xlRW50cnkocmVzcG9uc2UsIHZhbHVlKSB7XG4gICAgICBpZiAocmVzcG9uc2UuX3JlcGxheUNvbnNvbGUpIHtcbiAgICAgICAgdmFyIHBheWxvYWQgPSBKU09OLnBhcnNlKHZhbHVlLCByZXNwb25zZS5fZnJvbUpTT04pO1xuICAgICAgICB2YWx1ZSA9IHBheWxvYWRbMF07XG4gICAgICAgIHZhciBzdGFja1RyYWNlID0gcGF5bG9hZFsxXSxcbiAgICAgICAgICBvd25lciA9IHBheWxvYWRbMl0sXG4gICAgICAgICAgZW52ID0gcGF5bG9hZFszXTtcbiAgICAgICAgcGF5bG9hZCA9IHBheWxvYWQuc2xpY2UoNCk7XG4gICAgICAgIHJlcGxheUNvbnNvbGVXaXRoQ2FsbFN0YWNrSW5ERVYoXG4gICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgc3RhY2tUcmFjZSxcbiAgICAgICAgICBvd25lcixcbiAgICAgICAgICBlbnYsXG4gICAgICAgICAgcGF5bG9hZFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBtZXJnZUJ1ZmZlcihidWZmZXIsIGxhc3RDaHVuaykge1xuICAgICAgZm9yIChcbiAgICAgICAgdmFyIGwgPSBidWZmZXIubGVuZ3RoLCBieXRlTGVuZ3RoID0gbGFzdENodW5rLmxlbmd0aCwgaSA9IDA7XG4gICAgICAgIGkgPCBsO1xuICAgICAgICBpKytcbiAgICAgIClcbiAgICAgICAgYnl0ZUxlbmd0aCArPSBidWZmZXJbaV0uYnl0ZUxlbmd0aDtcbiAgICAgIGJ5dGVMZW5ndGggPSBuZXcgVWludDhBcnJheShieXRlTGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIF9pMyA9IChpID0gMCk7IF9pMyA8IGw7IF9pMysrKSB7XG4gICAgICAgIHZhciBjaHVuayA9IGJ1ZmZlcltfaTNdO1xuICAgICAgICBieXRlTGVuZ3RoLnNldChjaHVuaywgaSk7XG4gICAgICAgIGkgKz0gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGJ5dGVMZW5ndGguc2V0KGxhc3RDaHVuaywgaSk7XG4gICAgICByZXR1cm4gYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzb2x2ZVR5cGVkQXJyYXkoXG4gICAgICByZXNwb25zZSxcbiAgICAgIGlkLFxuICAgICAgYnVmZmVyLFxuICAgICAgbGFzdENodW5rLFxuICAgICAgY29uc3RydWN0b3IsXG4gICAgICBieXRlc1BlckVsZW1lbnRcbiAgICApIHtcbiAgICAgIGJ1ZmZlciA9XG4gICAgICAgIDAgPT09IGJ1ZmZlci5sZW5ndGggJiYgMCA9PT0gbGFzdENodW5rLmJ5dGVPZmZzZXQgJSBieXRlc1BlckVsZW1lbnRcbiAgICAgICAgICA/IGxhc3RDaHVua1xuICAgICAgICAgIDogbWVyZ2VCdWZmZXIoYnVmZmVyLCBsYXN0Q2h1bmspO1xuICAgICAgY29uc3RydWN0b3IgPSBuZXcgY29uc3RydWN0b3IoXG4gICAgICAgIGJ1ZmZlci5idWZmZXIsXG4gICAgICAgIGJ1ZmZlci5ieXRlT2Zmc2V0LFxuICAgICAgICBidWZmZXIuYnl0ZUxlbmd0aCAvIGJ5dGVzUGVyRWxlbWVudFxuICAgICAgKTtcbiAgICAgIHJlc29sdmVCdWZmZXIocmVzcG9uc2UsIGlkLCBjb25zdHJ1Y3Rvcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsdXNoSW5pdGlhbFJlbmRlclBlcmZvcm1hbmNlKCkge31cbiAgICBmdW5jdGlvbiBwcm9jZXNzRnVsbEJpbmFyeVJvdyhyZXNwb25zZSwgaWQsIHRhZywgYnVmZmVyLCBjaHVuaykge1xuICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgY2FzZSA2NTpcbiAgICAgICAgICByZXNvbHZlQnVmZmVyKHJlc3BvbnNlLCBpZCwgbWVyZ2VCdWZmZXIoYnVmZmVyLCBjaHVuaykuYnVmZmVyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgNzk6XG4gICAgICAgICAgcmVzb2x2ZVR5cGVkQXJyYXkocmVzcG9uc2UsIGlkLCBidWZmZXIsIGNodW5rLCBJbnQ4QXJyYXksIDEpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSAxMTE6XG4gICAgICAgICAgcmVzb2x2ZUJ1ZmZlcihcbiAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAwID09PSBidWZmZXIubGVuZ3RoID8gY2h1bmsgOiBtZXJnZUJ1ZmZlcihidWZmZXIsIGNodW5rKVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlIDg1OlxuICAgICAgICAgIHJlc29sdmVUeXBlZEFycmF5KHJlc3BvbnNlLCBpZCwgYnVmZmVyLCBjaHVuaywgVWludDhDbGFtcGVkQXJyYXksIDEpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSA4MzpcbiAgICAgICAgICByZXNvbHZlVHlwZWRBcnJheShyZXNwb25zZSwgaWQsIGJ1ZmZlciwgY2h1bmssIEludDE2QXJyYXksIDIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSAxMTU6XG4gICAgICAgICAgcmVzb2x2ZVR5cGVkQXJyYXkocmVzcG9uc2UsIGlkLCBidWZmZXIsIGNodW5rLCBVaW50MTZBcnJheSwgMik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlIDc2OlxuICAgICAgICAgIHJlc29sdmVUeXBlZEFycmF5KHJlc3BvbnNlLCBpZCwgYnVmZmVyLCBjaHVuaywgSW50MzJBcnJheSwgNCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlIDEwODpcbiAgICAgICAgICByZXNvbHZlVHlwZWRBcnJheShyZXNwb25zZSwgaWQsIGJ1ZmZlciwgY2h1bmssIFVpbnQzMkFycmF5LCA0KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgNzE6XG4gICAgICAgICAgcmVzb2x2ZVR5cGVkQXJyYXkocmVzcG9uc2UsIGlkLCBidWZmZXIsIGNodW5rLCBGbG9hdDMyQXJyYXksIDQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSAxMDM6XG4gICAgICAgICAgcmVzb2x2ZVR5cGVkQXJyYXkocmVzcG9uc2UsIGlkLCBidWZmZXIsIGNodW5rLCBGbG9hdDY0QXJyYXksIDgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSA3NzpcbiAgICAgICAgICByZXNvbHZlVHlwZWRBcnJheShyZXNwb25zZSwgaWQsIGJ1ZmZlciwgY2h1bmssIEJpZ0ludDY0QXJyYXksIDgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSAxMDk6XG4gICAgICAgICAgcmVzb2x2ZVR5cGVkQXJyYXkocmVzcG9uc2UsIGlkLCBidWZmZXIsIGNodW5rLCBCaWdVaW50NjRBcnJheSwgOCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlIDg2OlxuICAgICAgICAgIHJlc29sdmVUeXBlZEFycmF5KHJlc3BvbnNlLCBpZCwgYnVmZmVyLCBjaHVuaywgRGF0YVZpZXcsIDEpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAoXG4gICAgICAgIHZhciBzdHJpbmdEZWNvZGVyID0gcmVzcG9uc2UuX3N0cmluZ0RlY29kZXIsIHJvdyA9IFwiXCIsIGkgPSAwO1xuICAgICAgICBpIDwgYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgaSsrXG4gICAgICApXG4gICAgICAgIHJvdyArPSBzdHJpbmdEZWNvZGVyLmRlY29kZShidWZmZXJbaV0sIGRlY29kZXJPcHRpb25zKTtcbiAgICAgIHJvdyArPSBzdHJpbmdEZWNvZGVyLmRlY29kZShjaHVuayk7XG4gICAgICBwcm9jZXNzRnVsbFN0cmluZ1JvdyhyZXNwb25zZSwgaWQsIHRhZywgcm93KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJvY2Vzc0Z1bGxTdHJpbmdSb3cocmVzcG9uc2UsIGlkLCB0YWcsIHJvdykge1xuICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgY2FzZSA3MzpcbiAgICAgICAgICByZXNvbHZlTW9kdWxlKHJlc3BvbnNlLCBpZCwgcm93KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA3MjpcbiAgICAgICAgICByZXNvbHZlSGludChyZXNwb25zZSwgcm93WzBdLCByb3cuc2xpY2UoMSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDY5OlxuICAgICAgICAgIHJvdyA9IEpTT04ucGFyc2Uocm93KTtcbiAgICAgICAgICB0YWcgPSByZXNvbHZlRXJyb3JEZXYocmVzcG9uc2UsIHJvdyk7XG4gICAgICAgICAgdGFnLmRpZ2VzdCA9IHJvdy5kaWdlc3Q7XG4gICAgICAgICAgcm93ID0gcmVzcG9uc2UuX2NodW5rcztcbiAgICAgICAgICB2YXIgY2h1bmsgPSByb3cuZ2V0KGlkKTtcbiAgICAgICAgICBjaHVua1xuICAgICAgICAgICAgPyB0cmlnZ2VyRXJyb3JPbkNodW5rKHJlc3BvbnNlLCBjaHVuaywgdGFnKVxuICAgICAgICAgICAgOiByb3cuc2V0KGlkLCBuZXcgUmVhY3RQcm9taXNlKFwicmVqZWN0ZWRcIiwgbnVsbCwgdGFnKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgODQ6XG4gICAgICAgICAgcmVzb2x2ZVRleHQocmVzcG9uc2UsIGlkLCByb3cpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDc4OlxuICAgICAgICBjYXNlIDY4OlxuICAgICAgICAgIHRhZyA9IG5ldyBSZWFjdFByb21pc2UoXCJyZXNvbHZlZF9tb2RlbFwiLCByb3csIHJlc3BvbnNlKTtcbiAgICAgICAgICBpbml0aWFsaXplTW9kZWxDaHVuayh0YWcpO1xuICAgICAgICAgIFwiZnVsZmlsbGVkXCIgPT09IHRhZy5zdGF0dXNcbiAgICAgICAgICAgID8gcmVzb2x2ZURlYnVnSW5mbyhyZXNwb25zZSwgaWQsIHRhZy52YWx1ZSlcbiAgICAgICAgICAgIDogdGFnLnRoZW4oXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlRGVidWdJbmZvKHJlc3BvbnNlLCBpZCwgdik7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7fVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDc0OlxuICAgICAgICBjYXNlIDg3OlxuICAgICAgICAgIHJlc29sdmVDb25zb2xlRW50cnkocmVzcG9uc2UsIHJvdyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgODI6XG4gICAgICAgICAgc3RhcnRSZWFkYWJsZVN0cmVhbShyZXNwb25zZSwgaWQsIHZvaWQgMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTE0OlxuICAgICAgICAgIHN0YXJ0UmVhZGFibGVTdHJlYW0ocmVzcG9uc2UsIGlkLCBcImJ5dGVzXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDg4OlxuICAgICAgICAgIHN0YXJ0QXN5bmNJdGVyYWJsZShyZXNwb25zZSwgaWQsICExKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMjA6XG4gICAgICAgICAgc3RhcnRBc3luY0l0ZXJhYmxlKHJlc3BvbnNlLCBpZCwgITApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDY3OlxuICAgICAgICAgIHN0b3BTdHJlYW0ocmVzcG9uc2UsIGlkLCByb3cpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIFwiXCIgPT09IHJvd1xuICAgICAgICAgICAgPyByZXNvbHZlRGVidWdIYWx0KHJlc3BvbnNlLCBpZClcbiAgICAgICAgICAgIDogcmVzb2x2ZU1vZGVsKHJlc3BvbnNlLCBpZCwgcm93KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcHJvY2Vzc0JpbmFyeUNodW5rKHdlYWtSZXNwb25zZSwgc3RyZWFtU3RhdGUsIGNodW5rKSB7XG4gICAgICBpZiAodm9pZCAwICE9PSB3ZWFrUmVzcG9uc2Uud2Vhay5kZXJlZigpKSB7XG4gICAgICAgIHZhciByZXNwb25zZSA9IHVud3JhcFdlYWtSZXNwb25zZSh3ZWFrUmVzcG9uc2UpLFxuICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgIHJvd1N0YXRlID0gc3RyZWFtU3RhdGUuX3Jvd1N0YXRlO1xuICAgICAgICB3ZWFrUmVzcG9uc2UgPSBzdHJlYW1TdGF0ZS5fcm93SUQ7XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgdmFyIHJvd1RhZyA9IHN0cmVhbVN0YXRlLl9yb3dUYWcsXG4gICAgICAgICAgICByb3dMZW5ndGggPSBzdHJlYW1TdGF0ZS5fcm93TGVuZ3RoLFxuICAgICAgICAgICAgYnVmZmVyID0gc3RyZWFtU3RhdGUuX2J1ZmZlcixcbiAgICAgICAgICAgIGNodW5rTGVuZ3RoID0gY2h1bmsubGVuZ3RoO1xuICAgICAgICAgIGkgPCBjaHVua0xlbmd0aDtcblxuICAgICAgICApIHtcbiAgICAgICAgICB2YXIgbGFzdElkeCA9IC0xO1xuICAgICAgICAgIHN3aXRjaCAocm93U3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgbGFzdElkeCA9IGNodW5rW2krK107XG4gICAgICAgICAgICAgIDU4ID09PSBsYXN0SWR4XG4gICAgICAgICAgICAgICAgPyAocm93U3RhdGUgPSAxKVxuICAgICAgICAgICAgICAgIDogKHdlYWtSZXNwb25zZSA9XG4gICAgICAgICAgICAgICAgICAgICh3ZWFrUmVzcG9uc2UgPDwgNCkgfFxuICAgICAgICAgICAgICAgICAgICAoOTYgPCBsYXN0SWR4ID8gbGFzdElkeCAtIDg3IDogbGFzdElkeCAtIDQ4KSk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICByb3dTdGF0ZSA9IGNodW5rW2ldO1xuICAgICAgICAgICAgICA4NCA9PT0gcm93U3RhdGUgfHxcbiAgICAgICAgICAgICAgNjUgPT09IHJvd1N0YXRlIHx8XG4gICAgICAgICAgICAgIDc5ID09PSByb3dTdGF0ZSB8fFxuICAgICAgICAgICAgICAxMTEgPT09IHJvd1N0YXRlIHx8XG4gICAgICAgICAgICAgIDg1ID09PSByb3dTdGF0ZSB8fFxuICAgICAgICAgICAgICA4MyA9PT0gcm93U3RhdGUgfHxcbiAgICAgICAgICAgICAgMTE1ID09PSByb3dTdGF0ZSB8fFxuICAgICAgICAgICAgICA3NiA9PT0gcm93U3RhdGUgfHxcbiAgICAgICAgICAgICAgMTA4ID09PSByb3dTdGF0ZSB8fFxuICAgICAgICAgICAgICA3MSA9PT0gcm93U3RhdGUgfHxcbiAgICAgICAgICAgICAgMTAzID09PSByb3dTdGF0ZSB8fFxuICAgICAgICAgICAgICA3NyA9PT0gcm93U3RhdGUgfHxcbiAgICAgICAgICAgICAgMTA5ID09PSByb3dTdGF0ZSB8fFxuICAgICAgICAgICAgICA4NiA9PT0gcm93U3RhdGVcbiAgICAgICAgICAgICAgICA/ICgocm93VGFnID0gcm93U3RhdGUpLCAocm93U3RhdGUgPSAyKSwgaSsrKVxuICAgICAgICAgICAgICAgIDogKDY0IDwgcm93U3RhdGUgJiYgOTEgPiByb3dTdGF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgMzUgPT09IHJvd1N0YXRlIHx8XG4gICAgICAgICAgICAgICAgICAgIDExNCA9PT0gcm93U3RhdGUgfHxcbiAgICAgICAgICAgICAgICAgICAgMTIwID09PSByb3dTdGF0ZVxuICAgICAgICAgICAgICAgICAgPyAoKHJvd1RhZyA9IHJvd1N0YXRlKSwgKHJvd1N0YXRlID0gMyksIGkrKylcbiAgICAgICAgICAgICAgICAgIDogKChyb3dUYWcgPSAwKSwgKHJvd1N0YXRlID0gMykpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgbGFzdElkeCA9IGNodW5rW2krK107XG4gICAgICAgICAgICAgIDQ0ID09PSBsYXN0SWR4XG4gICAgICAgICAgICAgICAgPyAocm93U3RhdGUgPSA0KVxuICAgICAgICAgICAgICAgIDogKHJvd0xlbmd0aCA9XG4gICAgICAgICAgICAgICAgICAgIChyb3dMZW5ndGggPDwgNCkgfFxuICAgICAgICAgICAgICAgICAgICAoOTYgPCBsYXN0SWR4ID8gbGFzdElkeCAtIDg3IDogbGFzdElkeCAtIDQ4KSk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBsYXN0SWR4ID0gY2h1bmsuaW5kZXhPZigxMCwgaSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAobGFzdElkeCA9IGkgKyByb3dMZW5ndGgpLFxuICAgICAgICAgICAgICAgIGxhc3RJZHggPiBjaHVuay5sZW5ndGggJiYgKGxhc3RJZHggPSAtMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBvZmZzZXQgPSBjaHVuay5ieXRlT2Zmc2V0ICsgaTtcbiAgICAgICAgICBpZiAoLTEgPCBsYXN0SWR4KVxuICAgICAgICAgICAgKHJvd0xlbmd0aCA9IG5ldyBVaW50OEFycmF5KGNodW5rLmJ1ZmZlciwgb2Zmc2V0LCBsYXN0SWR4IC0gaSkpLFxuICAgICAgICAgICAgICBwcm9jZXNzRnVsbEJpbmFyeVJvdyhcbiAgICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgICAgICB3ZWFrUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgcm93VGFnLFxuICAgICAgICAgICAgICAgIGJ1ZmZlcixcbiAgICAgICAgICAgICAgICByb3dMZW5ndGhcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgKGkgPSBsYXN0SWR4KSxcbiAgICAgICAgICAgICAgMyA9PT0gcm93U3RhdGUgJiYgaSsrLFxuICAgICAgICAgICAgICAocm93TGVuZ3RoID0gd2Vha1Jlc3BvbnNlID0gcm93VGFnID0gcm93U3RhdGUgPSAwKSxcbiAgICAgICAgICAgICAgKGJ1ZmZlci5sZW5ndGggPSAwKTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNodW5rID0gbmV3IFVpbnQ4QXJyYXkoY2h1bmsuYnVmZmVyLCBvZmZzZXQsIGNodW5rLmJ5dGVMZW5ndGggLSBpKTtcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgIHJvd0xlbmd0aCAtPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0cmVhbVN0YXRlLl9yb3dTdGF0ZSA9IHJvd1N0YXRlO1xuICAgICAgICBzdHJlYW1TdGF0ZS5fcm93SUQgPSB3ZWFrUmVzcG9uc2U7XG4gICAgICAgIHN0cmVhbVN0YXRlLl9yb3dUYWcgPSByb3dUYWc7XG4gICAgICAgIHN0cmVhbVN0YXRlLl9yb3dMZW5ndGggPSByb3dMZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZyb21KU09OQ2FsbGJhY2socmVzcG9uc2UpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHZhbHVlKVxuICAgICAgICAgIHJldHVybiBwYXJzZU1vZGVsU3RyaW5nKHJlc3BvbnNlLCB0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB2YWx1ZSAmJiBudWxsICE9PSB2YWx1ZSkge1xuICAgICAgICAgIGlmICh2YWx1ZVswXSA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKVxuICAgICAgICAgICAgYjoge1xuICAgICAgICAgICAgICB2YXIgb3duZXIgPSB2YWx1ZVs0XTtcbiAgICAgICAgICAgICAga2V5ID0gdmFsdWVbNV07XG4gICAgICAgICAgICAgIHZhciB2YWxpZGF0ZWQgPSB2YWx1ZVs2XTtcbiAgICAgICAgICAgICAgdmFsdWUgPSB7XG4gICAgICAgICAgICAgICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAgICAgICAgICAgICB0eXBlOiB2YWx1ZVsxXSxcbiAgICAgICAgICAgICAgICBrZXk6IHZhbHVlWzJdLFxuICAgICAgICAgICAgICAgIHByb3BzOiB2YWx1ZVszXSxcbiAgICAgICAgICAgICAgICBfb3duZXI6IHZvaWQgMCA9PT0gb3duZXIgPyBudWxsIDogb3duZXJcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbHVlLCBcInJlZlwiLCB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgICAgICAgICAgZ2V0OiBudWxsUmVmR2V0dGVyXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB2YWx1ZS5fc3RvcmUgPSB7fTtcbiAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbHVlLl9zdG9yZSwgXCJ2YWxpZGF0ZWRcIiwge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWxpZGF0ZWRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWx1ZSwgXCJfZGVidWdJbmZvXCIsIHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbHVlLCBcIl9kZWJ1Z1N0YWNrXCIsIHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdm9pZCAwID09PSBrZXkgPyBudWxsIDoga2V5XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsdWUsIFwiX2RlYnVnVGFza1wiLCB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmIChudWxsICE9PSBpbml0aWFsaXppbmdIYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGVkID0gaW5pdGlhbGl6aW5nSGFuZGxlcjtcbiAgICAgICAgICAgICAgICBpbml0aWFsaXppbmdIYW5kbGVyID0gdmFsaWRhdGVkLnBhcmVudDtcbiAgICAgICAgICAgICAgICBpZiAodmFsaWRhdGVkLmVycm9yZWQpIHtcbiAgICAgICAgICAgICAgICAgIGtleSA9IG5ldyBSZWFjdFByb21pc2UoXCJyZWplY3RlZFwiLCBudWxsLCB2YWxpZGF0ZWQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgaW5pdGlhbGl6ZUVsZW1lbnQocmVzcG9uc2UsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIHZhbGlkYXRlZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHZhbHVlLnR5cGUpIHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgIG93bmVyOiB2YWx1ZS5fb3duZXJcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICB2YWxpZGF0ZWQuZGVidWdTdGFjayA9IHZhbHVlLl9kZWJ1Z1N0YWNrO1xuICAgICAgICAgICAgICAgICAgc3VwcG9ydHNDcmVhdGVUYXNrICYmXG4gICAgICAgICAgICAgICAgICAgICh2YWxpZGF0ZWQuZGVidWdUYXNrID0gdmFsdWUuX2RlYnVnVGFzayk7XG4gICAgICAgICAgICAgICAgICBrZXkuX2RlYnVnSW5mbyA9IFt2YWxpZGF0ZWRdO1xuICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjcmVhdGVMYXp5Q2h1bmtXcmFwcGVyKGtleSk7XG4gICAgICAgICAgICAgICAgICBicmVhayBiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoMCA8IHZhbGlkYXRlZC5kZXBzKSB7XG4gICAgICAgICAgICAgICAgICBrZXkgPSBuZXcgUmVhY3RQcm9taXNlKFwiYmxvY2tlZFwiLCBudWxsLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgIHZhbGlkYXRlZC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgdmFsaWRhdGVkLmNodW5rID0ga2V5O1xuICAgICAgICAgICAgICAgICAgdmFsdWUgPSBpbml0aWFsaXplRWxlbWVudC5iaW5kKG51bGwsIHJlc3BvbnNlLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICBrZXkudGhlbih2YWx1ZSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjcmVhdGVMYXp5Q2h1bmtXcmFwcGVyKGtleSk7XG4gICAgICAgICAgICAgICAgICBicmVhayBiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpbml0aWFsaXplRWxlbWVudChyZXNwb25zZSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbG9zZSh3ZWFrUmVzcG9uc2UpIHtcbiAgICAgIHJlcG9ydEdsb2JhbEVycm9yKHdlYWtSZXNwb25zZSwgRXJyb3IoXCJDb25uZWN0aW9uIGNsb3NlZC5cIikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVEZWJ1Z0NhbGxiYWNrRnJvbVdyaXRhYmxlU3RyZWFtKGRlYnVnV3JpdGFibGUpIHtcbiAgICAgIHZhciB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpLFxuICAgICAgICB3cml0ZXIgPSBkZWJ1Z1dyaXRhYmxlLmdldFdyaXRlcigpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIFwiXCIgPT09IG1lc3NhZ2VcbiAgICAgICAgICA/IHdyaXRlci5jbG9zZSgpXG4gICAgICAgICAgOiB3cml0ZXJcbiAgICAgICAgICAgICAgLndyaXRlKHRleHRFbmNvZGVyLmVuY29kZShtZXNzYWdlICsgXCJcXG5cIikpXG4gICAgICAgICAgICAgIC5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlc3BvbnNlRnJvbU9wdGlvbnMob3B0aW9ucykge1xuICAgICAgdmFyIGRlYnVnQ2hhbm5lbCA9XG4gICAgICAgIG9wdGlvbnMgJiZcbiAgICAgICAgdm9pZCAwICE9PSBvcHRpb25zLmRlYnVnQ2hhbm5lbCAmJlxuICAgICAgICB2b2lkIDAgIT09IG9wdGlvbnMuZGVidWdDaGFubmVsLndyaXRhYmxlXG4gICAgICAgICAgPyBjcmVhdGVEZWJ1Z0NhbGxiYWNrRnJvbVdyaXRhYmxlU3RyZWFtKG9wdGlvbnMuZGVidWdDaGFubmVsLndyaXRhYmxlKVxuICAgICAgICAgIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZUluc3RhbmNlKFxuICAgICAgICBudWxsLFxuICAgICAgICBudWxsLFxuICAgICAgICBudWxsLFxuICAgICAgICBvcHRpb25zICYmIG9wdGlvbnMuY2FsbFNlcnZlciA/IG9wdGlvbnMuY2FsbFNlcnZlciA6IHZvaWQgMCxcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIG9wdGlvbnMgJiYgb3B0aW9ucy50ZW1wb3JhcnlSZWZlcmVuY2VzXG4gICAgICAgICAgPyBvcHRpb25zLnRlbXBvcmFyeVJlZmVyZW5jZXNcbiAgICAgICAgICA6IHZvaWQgMCxcbiAgICAgICAgb3B0aW9ucyAmJiBvcHRpb25zLmZpbmRTb3VyY2VNYXBVUkwgPyBvcHRpb25zLmZpbmRTb3VyY2VNYXBVUkwgOiB2b2lkIDAsXG4gICAgICAgIG9wdGlvbnMgPyAhMSAhPT0gb3B0aW9ucy5yZXBsYXlDb25zb2xlTG9ncyA6ICEwLFxuICAgICAgICBvcHRpb25zICYmIG9wdGlvbnMuZW52aXJvbm1lbnROYW1lID8gb3B0aW9ucy5lbnZpcm9ubWVudE5hbWUgOiB2b2lkIDAsXG4gICAgICAgIGRlYnVnQ2hhbm5lbFxuICAgICAgKS5fd2Vha1Jlc3BvbnNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdGFydFJlYWRpbmdGcm9tVW5pdmVyc2FsU3RyZWFtKHJlc3BvbnNlJGpzY29tcCQwLCBzdHJlYW0pIHtcbiAgICAgIGZ1bmN0aW9uIHByb2dyZXNzKF9yZWYpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gX3JlZi52YWx1ZTtcbiAgICAgICAgaWYgKF9yZWYuZG9uZSkgY2xvc2UocmVzcG9uc2UkanNjb21wJDApO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcilcbiAgICAgICAgICAgIHByb2Nlc3NCaW5hcnlDaHVuayhcbiAgICAgICAgICAgICAgcmVzcG9uc2UkanNjb21wJDAsXG4gICAgICAgICAgICAgIHN0cmVhbVN0YXRlLFxuICAgICAgICAgICAgICBuZXcgVWludDhBcnJheSh2YWx1ZSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgZWxzZSBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICgoX3JlZiA9IHN0cmVhbVN0YXRlKSwgdm9pZCAwICE9PSByZXNwb25zZSRqc2NvbXAkMC53ZWFrLmRlcmVmKCkpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2UgPSB1bndyYXBXZWFrUmVzcG9uc2UocmVzcG9uc2UkanNjb21wJDApLFxuICAgICAgICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICAgICAgICByb3dTdGF0ZSA9IF9yZWYuX3Jvd1N0YXRlLFxuICAgICAgICAgICAgICAgICAgcm93SUQgPSBfcmVmLl9yb3dJRCxcbiAgICAgICAgICAgICAgICAgIHJvd1RhZyA9IF9yZWYuX3Jvd1RhZyxcbiAgICAgICAgICAgICAgICAgIHJvd0xlbmd0aCA9IF9yZWYuX3Jvd0xlbmd0aCxcbiAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IF9yZWYuX2J1ZmZlcixcbiAgICAgICAgICAgICAgICAgIGNodW5rTGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGkgPCBjaHVua0xlbmd0aDtcblxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdElkeCA9IC0xO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAocm93U3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgbGFzdElkeCA9IHZhbHVlLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgICAgICAgICAgICAgICAgNTggPT09IGxhc3RJZHhcbiAgICAgICAgICAgICAgICAgICAgICA/IChyb3dTdGF0ZSA9IDEpXG4gICAgICAgICAgICAgICAgICAgICAgOiAocm93SUQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAocm93SUQgPDwgNCkgfFxuICAgICAgICAgICAgICAgICAgICAgICAgICAoOTYgPCBsYXN0SWR4ID8gbGFzdElkeCAtIDg3IDogbGFzdElkeCAtIDQ4KSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICByb3dTdGF0ZSA9IHZhbHVlLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICAgICAgICAgIDg0ID09PSByb3dTdGF0ZSB8fFxuICAgICAgICAgICAgICAgICAgICA2NSA9PT0gcm93U3RhdGUgfHxcbiAgICAgICAgICAgICAgICAgICAgNzkgPT09IHJvd1N0YXRlIHx8XG4gICAgICAgICAgICAgICAgICAgIDExMSA9PT0gcm93U3RhdGUgfHxcbiAgICAgICAgICAgICAgICAgICAgODUgPT09IHJvd1N0YXRlIHx8XG4gICAgICAgICAgICAgICAgICAgIDgzID09PSByb3dTdGF0ZSB8fFxuICAgICAgICAgICAgICAgICAgICAxMTUgPT09IHJvd1N0YXRlIHx8XG4gICAgICAgICAgICAgICAgICAgIDc2ID09PSByb3dTdGF0ZSB8fFxuICAgICAgICAgICAgICAgICAgICAxMDggPT09IHJvd1N0YXRlIHx8XG4gICAgICAgICAgICAgICAgICAgIDcxID09PSByb3dTdGF0ZSB8fFxuICAgICAgICAgICAgICAgICAgICAxMDMgPT09IHJvd1N0YXRlIHx8XG4gICAgICAgICAgICAgICAgICAgIDc3ID09PSByb3dTdGF0ZSB8fFxuICAgICAgICAgICAgICAgICAgICAxMDkgPT09IHJvd1N0YXRlIHx8XG4gICAgICAgICAgICAgICAgICAgIDg2ID09PSByb3dTdGF0ZVxuICAgICAgICAgICAgICAgICAgICAgID8gKChyb3dUYWcgPSByb3dTdGF0ZSksIChyb3dTdGF0ZSA9IDIpLCBpKyspXG4gICAgICAgICAgICAgICAgICAgICAgOiAoNjQgPCByb3dTdGF0ZSAmJiA5MSA+IHJvd1N0YXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAxMTQgPT09IHJvd1N0YXRlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIDEyMCA9PT0gcm93U3RhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gKChyb3dUYWcgPSByb3dTdGF0ZSksIChyb3dTdGF0ZSA9IDMpLCBpKyspXG4gICAgICAgICAgICAgICAgICAgICAgICA6ICgocm93VGFnID0gMCksIChyb3dTdGF0ZSA9IDMpKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGxhc3RJZHggPSB2YWx1ZS5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICAgICAgICAgICAgICAgIDQ0ID09PSBsYXN0SWR4XG4gICAgICAgICAgICAgICAgICAgICAgPyAocm93U3RhdGUgPSA0KVxuICAgICAgICAgICAgICAgICAgICAgIDogKHJvd0xlbmd0aCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIChyb3dMZW5ndGggPDwgNCkgfFxuICAgICAgICAgICAgICAgICAgICAgICAgICAoOTYgPCBsYXN0SWR4ID8gbGFzdElkeCAtIDg3IDogbGFzdElkeCAtIDQ4KSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBsYXN0SWR4ID0gdmFsdWUuaW5kZXhPZihcIlxcblwiLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICg4NCAhPT0gcm93VGFnKVxuICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJCaW5hcnkgUlNDIGNodW5rcyBjYW5ub3QgYmUgZW5jb2RlZCBhcyBzdHJpbmdzLiBUaGlzIGlzIGEgYnVnIGluIHRoZSB3aXJpbmcgb2YgdGhlIFJlYWN0IHN0cmVhbXMuXCJcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgcm93TGVuZ3RoIDwgdmFsdWUubGVuZ3RoIHx8XG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWUubGVuZ3RoID4gMyAqIHJvd0xlbmd0aFxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlN0cmluZyBjaHVua3MgbmVlZCB0byBiZSBwYXNzZWQgaW4gdGhlaXIgb3JpZ2luYWwgc2hhcGUuIE5vdCBzcGxpdCBpbnRvIHNtYWxsZXIgc3RyaW5nIGNodW5rcy4gVGhpcyBpcyBhIGJ1ZyBpbiB0aGUgd2lyaW5nIG9mIHRoZSBSZWFjdCBzdHJlYW1zLlwiXG4gICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgbGFzdElkeCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKC0xIDwgbGFzdElkeCkge1xuICAgICAgICAgICAgICAgICAgaWYgKDAgPCBidWZmZXIubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICBcIlN0cmluZyBjaHVua3MgbmVlZCB0byBiZSBwYXNzZWQgaW4gdGhlaXIgb3JpZ2luYWwgc2hhcGUuIE5vdCBzcGxpdCBpbnRvIHNtYWxsZXIgc3RyaW5nIGNodW5rcy4gVGhpcyBpcyBhIGJ1ZyBpbiB0aGUgd2lyaW5nIG9mIHRoZSBSZWFjdCBzdHJlYW1zLlwiXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBpID0gdmFsdWUuc2xpY2UoaSwgbGFzdElkeCk7XG4gICAgICAgICAgICAgICAgICBwcm9jZXNzRnVsbFN0cmluZ1JvdyhyZXNwb25zZSwgcm93SUQsIHJvd1RhZywgaSk7XG4gICAgICAgICAgICAgICAgICBpID0gbGFzdElkeDtcbiAgICAgICAgICAgICAgICAgIDMgPT09IHJvd1N0YXRlICYmIGkrKztcbiAgICAgICAgICAgICAgICAgIHJvd0xlbmd0aCA9IHJvd0lEID0gcm93VGFnID0gcm93U3RhdGUgPSAwO1xuICAgICAgICAgICAgICAgICAgYnVmZmVyLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZS5sZW5ndGggIT09IGkpXG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJTdHJpbmcgY2h1bmtzIG5lZWQgdG8gYmUgcGFzc2VkIGluIHRoZWlyIG9yaWdpbmFsIHNoYXBlLiBOb3Qgc3BsaXQgaW50byBzbWFsbGVyIHN0cmluZyBjaHVua3MuIFRoaXMgaXMgYSBidWcgaW4gdGhlIHdpcmluZyBvZiB0aGUgUmVhY3Qgc3RyZWFtcy5cIlxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBfcmVmLl9yb3dTdGF0ZSA9IHJvd1N0YXRlO1xuICAgICAgICAgICAgICBfcmVmLl9yb3dJRCA9IHJvd0lEO1xuICAgICAgICAgICAgICBfcmVmLl9yb3dUYWcgPSByb3dUYWc7XG4gICAgICAgICAgICAgIF9yZWYuX3Jvd0xlbmd0aCA9IHJvd0xlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgcHJvY2Vzc0JpbmFyeUNodW5rKHJlc3BvbnNlJGpzY29tcCQwLCBzdHJlYW1TdGF0ZSwgdmFsdWUpO1xuICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZCgpLnRoZW4ocHJvZ3Jlc3MpLmNhdGNoKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZXJyb3IoZSkge1xuICAgICAgICByZXBvcnRHbG9iYWxFcnJvcihyZXNwb25zZSRqc2NvbXAkMCwgZSk7XG4gICAgICB9XG4gICAgICB2YXIgc3RyZWFtU3RhdGUgPSBjcmVhdGVTdHJlYW1TdGF0ZSgpLFxuICAgICAgICByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgICByZWFkZXIucmVhZCgpLnRoZW4ocHJvZ3Jlc3MpLmNhdGNoKGVycm9yKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RhcnRSZWFkaW5nRnJvbVN0cmVhbShyZXNwb25zZSwgc3RyZWFtLCBpc1NlY29uZGFyeVN0cmVhbSkge1xuICAgICAgZnVuY3Rpb24gcHJvZ3Jlc3MoX3JlZjIpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gX3JlZjIudmFsdWU7XG4gICAgICAgIGlmIChfcmVmMi5kb25lKSBpc1NlY29uZGFyeVN0cmVhbSB8fCBjbG9zZShyZXNwb25zZSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgcHJvY2Vzc0JpbmFyeUNodW5rKHJlc3BvbnNlLCBzdHJlYW1TdGF0ZSwgdmFsdWUpLFxuICAgICAgICAgICAgcmVhZGVyLnJlYWQoKS50aGVuKHByb2dyZXNzKS5jYXRjaChlcnJvcilcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZXJyb3IoZSkge1xuICAgICAgICByZXBvcnRHbG9iYWxFcnJvcihyZXNwb25zZSwgZSk7XG4gICAgICB9XG4gICAgICB2YXIgc3RyZWFtU3RhdGUgPSBjcmVhdGVTdHJlYW1TdGF0ZSgpLFxuICAgICAgICByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgICByZWFkZXIucmVhZCgpLnRoZW4ocHJvZ3Jlc3MpLmNhdGNoKGVycm9yKTtcbiAgICB9XG4gICAgdmFyIFJlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpLFxuICAgICAgUmVhY3RET00gPSByZXF1aXJlKFwicmVhY3QtZG9tXCIpLFxuICAgICAgZGVjb2Rlck9wdGlvbnMgPSB7IHN0cmVhbTogITAgfSxcbiAgICAgIGJpbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCxcbiAgICAgIGNodW5rQ2FjaGUgPSBuZXcgTWFwKCksXG4gICAgICBSZWFjdERPTVNoYXJlZEludGVybmFscyA9XG4gICAgICAgIFJlYWN0RE9NLl9fRE9NX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERSxcbiAgICAgIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC50cmFuc2l0aW9uYWwuZWxlbWVudFwiKSxcbiAgICAgIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKSxcbiAgICAgIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIiksXG4gICAgICBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN0cmljdF9tb2RlXCIpLFxuICAgICAgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKSxcbiAgICAgIFJFQUNUX0NPTlNVTUVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29uc3VtZXJcIiksXG4gICAgICBSRUFDVF9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKSxcbiAgICAgIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIiksXG4gICAgICBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpLFxuICAgICAgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlX2xpc3RcIiksXG4gICAgICBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKSxcbiAgICAgIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5sYXp5XCIpLFxuICAgICAgUkVBQ1RfQUNUSVZJVFlfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5hY3Rpdml0eVwiKSxcbiAgICAgIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcixcbiAgICAgIEFTWU5DX0lURVJBVE9SID0gU3ltYm9sLmFzeW5jSXRlcmF0b3IsXG4gICAgICBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXksXG4gICAgICBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZixcbiAgICAgIGpzeFByb3BzUGFyZW50cyA9IG5ldyBXZWFrTWFwKCksXG4gICAgICBqc3hDaGlsZHJlblBhcmVudHMgPSBuZXcgV2Vha01hcCgpLFxuICAgICAgQ0xJRU5UX1JFRkVSRU5DRV9UQUcgPSBTeW1ib2wuZm9yKFwicmVhY3QuY2xpZW50LnJlZmVyZW5jZVwiKSxcbiAgICAgIE9iamVjdFByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGUsXG4gICAgICBrbm93blNlcnZlclJlZmVyZW5jZXMgPSBuZXcgV2Vha01hcCgpLFxuICAgICAgZmFrZVNlcnZlckZ1bmN0aW9uSWR4ID0gMCxcbiAgICAgIHY4RnJhbWVSZWdFeHAgPVxuICAgICAgICAvXiB7M30gYXQgKD86KC4rKSBcXCgoLispOihcXGQrKTooXFxkKylcXCl8KD86YXN5bmMgKT8oLispOihcXGQrKTooXFxkKykpJC8sXG4gICAgICBqc2NTcGlkZXJNb25rZXlGcmFtZVJlZ0V4cCA9IC8oPzooLiopQCk/KC4qKTooXFxkKyk6KFxcZCspLyxcbiAgICAgIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UgPSBTeW1ib2wuZm9yKFwicmVhY3QuY2xpZW50LnJlZmVyZW5jZVwiKSxcbiAgICAgIHByZWZpeCxcbiAgICAgIHN1ZmZpeDtcbiAgICBuZXcgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFdlYWtNYXAgPyBXZWFrTWFwIDogTWFwKSgpO1xuICAgIHZhciBSZWFjdFNoYXJlZEludGVyYWxzU2VydmVyID1cbiAgICAgICAgUmVhY3QuX19TRVJWRVJfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfV0FSTl9VU0VSU19USEVZX0NBTk5PVF9VUEdSQURFLFxuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPVxuICAgICAgICBSZWFjdC5fX0NMSUVOVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUgfHxcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcmFsc1NlcnZlcjtcbiAgICBSZWFjdFByb21pc2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShQcm9taXNlLnByb3RvdHlwZSk7XG4gICAgUmVhY3RQcm9taXNlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgc3dpdGNoICh0aGlzLnN0YXR1cykge1xuICAgICAgICBjYXNlIFwicmVzb2x2ZWRfbW9kZWxcIjpcbiAgICAgICAgICBpbml0aWFsaXplTW9kZWxDaHVuayh0aGlzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInJlc29sdmVkX21vZHVsZVwiOlxuICAgICAgICAgIGluaXRpYWxpemVNb2R1bGVDaHVuayh0aGlzKTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodGhpcy5zdGF0dXMpIHtcbiAgICAgICAgY2FzZSBcImZ1bGZpbGxlZFwiOlxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJlc29sdmUgJiYgcmVzb2x2ZSh0aGlzLnZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInBlbmRpbmdcIjpcbiAgICAgICAgY2FzZSBcImJsb2NrZWRcIjpcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZXNvbHZlICYmXG4gICAgICAgICAgICAobnVsbCA9PT0gdGhpcy52YWx1ZSAmJiAodGhpcy52YWx1ZSA9IFtdKSxcbiAgICAgICAgICAgIHRoaXMudmFsdWUucHVzaChyZXNvbHZlKSk7XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmVqZWN0ICYmXG4gICAgICAgICAgICAobnVsbCA9PT0gdGhpcy5yZWFzb24gJiYgKHRoaXMucmVhc29uID0gW10pLFxuICAgICAgICAgICAgdGhpcy5yZWFzb24ucHVzaChyZWplY3QpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImhhbHRlZFwiOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJlamVjdCAmJiByZWplY3QodGhpcy5yZWFzb24pO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIGRlYnVnQ2hhbm5lbFJlZ2lzdHJ5ID1cbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnlcbiAgICAgICAgICA/IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShjbGVhbnVwRGVidWdDaGFubmVsKVxuICAgICAgICAgIDogbnVsbCxcbiAgICAgIGluaXRpYWxpemluZ0hhbmRsZXIgPSBudWxsLFxuICAgICAgc3VwcG9ydHNDcmVhdGVUYXNrID0gISFjb25zb2xlLmNyZWF0ZVRhc2ssXG4gICAgICBmYWtlRnVuY3Rpb25DYWNoZSA9IG5ldyBNYXAoKSxcbiAgICAgIGZha2VGdW5jdGlvbklkeCA9IDAsXG4gICAgICBjcmVhdGVGYWtlSlNYQ2FsbFN0YWNrID0ge1xuICAgICAgICByZWFjdF9zdGFja19ib3R0b21fZnJhbWU6IGZ1bmN0aW9uIChyZXNwb25zZSwgc3RhY2ssIGVudmlyb25tZW50TmFtZSkge1xuICAgICAgICAgIHJldHVybiBidWlsZEZha2VDYWxsU3RhY2soXG4gICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgIHN0YWNrLFxuICAgICAgICAgICAgZW52aXJvbm1lbnROYW1lLFxuICAgICAgICAgICAgITEsXG4gICAgICAgICAgICBmYWtlSlNYQ2FsbFNpdGVcbiAgICAgICAgICApKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjcmVhdGVGYWtlSlNYQ2FsbFN0YWNrSW5ERVYgPVxuICAgICAgICBjcmVhdGVGYWtlSlNYQ2FsbFN0YWNrLnJlYWN0X3N0YWNrX2JvdHRvbV9mcmFtZS5iaW5kKFxuICAgICAgICAgIGNyZWF0ZUZha2VKU1hDYWxsU3RhY2tcbiAgICAgICAgKSxcbiAgICAgIGN1cnJlbnRPd25lckluREVWID0gbnVsbCxcbiAgICAgIHJlcGxheUNvbnNvbGVXaXRoQ2FsbFN0YWNrID0ge1xuICAgICAgICByZWFjdF9zdGFja19ib3R0b21fZnJhbWU6IGZ1bmN0aW9uIChcbiAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICBtZXRob2ROYW1lLFxuICAgICAgICAgIHN0YWNrVHJhY2UsXG4gICAgICAgICAgb3duZXIsXG4gICAgICAgICAgZW52LFxuICAgICAgICAgIGFyZ3NcbiAgICAgICAgKSB7XG4gICAgICAgICAgdmFyIHByZXZTdGFjayA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjaztcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2sgPSBnZXRDdXJyZW50U3RhY2tJbkRFVjtcbiAgICAgICAgICBjdXJyZW50T3duZXJJbkRFViA9IG51bGwgPT09IG93bmVyID8gcmVzcG9uc2UuX2RlYnVnUm9vdE93bmVyIDogb3duZXI7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgICAgICAgIHN3aXRjaCAobWV0aG9kTmFtZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJkaXJcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZGlyeG1sXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcImdyb3VwRW5kXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInRhYmxlXCI6XG4gICAgICAgICAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gYmluZC5hcHBseShcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZVttZXRob2ROYW1lXSxcbiAgICAgICAgICAgICAgICAgICAgW2NvbnNvbGVdLmNvbmNhdChhcmdzKVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgY2FzZSBcImFzc2VydFwiOlxuICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgbmV3QXJncyA9IGFyZ3Muc2xpY2UoMCk7XG4gICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBuZXdBcmdzW29mZnNldF1cbiAgICAgICAgICAgICAgICA/IG5ld0FyZ3Muc3BsaWNlKFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAgICAgICAgIFwiJWMlcyVjIFwiICsgbmV3QXJnc1tvZmZzZXRdLFxuICAgICAgICAgICAgICAgICAgICBcImJhY2tncm91bmQ6ICNlNmU2ZTY7YmFja2dyb3VuZDogbGlnaHQtZGFyayhyZ2JhKDAsMCwwLDAuMSksIHJnYmEoMjU1LDI1NSwyNTUsMC4yNSkpO2NvbG9yOiAjMDAwMDAwO2NvbG9yOiBsaWdodC1kYXJrKCMwMDAwMDAsICNmZmZmZmYpO2JvcmRlci1yYWRpdXM6IDJweFwiLFxuICAgICAgICAgICAgICAgICAgICBcIiBcIiArIGVudiArIFwiIFwiLFxuICAgICAgICAgICAgICAgICAgICBcIlwiXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgOiBuZXdBcmdzLnNwbGljZShcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICBcIiVjJXMlYyBcIixcbiAgICAgICAgICAgICAgICAgICAgXCJiYWNrZ3JvdW5kOiAjZTZlNmU2O2JhY2tncm91bmQ6IGxpZ2h0LWRhcmsocmdiYSgwLDAsMCwwLjEpLCByZ2JhKDI1NSwyNTUsMjU1LDAuMjUpKTtjb2xvcjogIzAwMDAwMDtjb2xvcjogbGlnaHQtZGFyaygjMDAwMDAwLCAjZmZmZmZmKTtib3JkZXItcmFkaXVzOiAycHhcIixcbiAgICAgICAgICAgICAgICAgICAgXCIgXCIgKyBlbnYgKyBcIiBcIixcbiAgICAgICAgICAgICAgICAgICAgXCJcIlxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgbmV3QXJncy51bnNoaWZ0KGNvbnNvbGUpO1xuICAgICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSBiaW5kLmFwcGx5KFxuICAgICAgICAgICAgICAgIGNvbnNvbGVbbWV0aG9kTmFtZV0sXG4gICAgICAgICAgICAgICAgbmV3QXJnc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNhbGxTdGFjayA9IGJ1aWxkRmFrZUNhbGxTdGFjayhcbiAgICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICAgIHN0YWNrVHJhY2UsXG4gICAgICAgICAgICAgIGVudixcbiAgICAgICAgICAgICAgITEsXG4gICAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChudWxsICE9IG93bmVyKSB7XG4gICAgICAgICAgICAgIHZhciB0YXNrID0gaW5pdGlhbGl6ZUZha2VUYXNrKHJlc3BvbnNlLCBvd25lcik7XG4gICAgICAgICAgICAgIGluaXRpYWxpemVGYWtlU3RhY2socmVzcG9uc2UsIG93bmVyKTtcbiAgICAgICAgICAgICAgaWYgKG51bGwgIT09IHRhc2spIHtcbiAgICAgICAgICAgICAgICB0YXNrLnJ1bihjYWxsU3RhY2spO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJvb3RUYXNrID0gZ2V0Um9vdFRhc2socmVzcG9uc2UsIGVudik7XG4gICAgICAgICAgICBudWxsICE9IHJvb3RUYXNrID8gcm9vdFRhc2sucnVuKGNhbGxTdGFjaykgOiBjYWxsU3RhY2soKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgKGN1cnJlbnRPd25lckluREVWID0gbnVsbCksXG4gICAgICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2sgPSBwcmV2U3RhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlcGxheUNvbnNvbGVXaXRoQ2FsbFN0YWNrSW5ERVYgPVxuICAgICAgICByZXBsYXlDb25zb2xlV2l0aENhbGxTdGFjay5yZWFjdF9zdGFja19ib3R0b21fZnJhbWUuYmluZChcbiAgICAgICAgICByZXBsYXlDb25zb2xlV2l0aENhbGxTdGFja1xuICAgICAgICApO1xuICAgIChmdW5jdGlvbiAoaW50ZXJuYWxzKSB7XG4gICAgICBpZiAoXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXykgcmV0dXJuICExO1xuICAgICAgdmFyIGhvb2sgPSBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG4gICAgICBpZiAoaG9vay5pc0Rpc2FibGVkIHx8ICFob29rLnN1cHBvcnRzRmxpZ2h0KSByZXR1cm4gITA7XG4gICAgICB0cnkge1xuICAgICAgICBob29rLmluamVjdChpbnRlcm5hbHMpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzLlwiLCBlcnIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhvb2suY2hlY2tEQ0UgPyAhMCA6ICExO1xuICAgIH0pKHtcbiAgICAgIGJ1bmRsZVR5cGU6IDEsXG4gICAgICB2ZXJzaW9uOiBcIjE5LjIuMC1jYW5hcnktOTdjZGQ1ZDMtMjAyNTA3MTBcIixcbiAgICAgIHJlbmRlcmVyUGFja2FnZU5hbWU6IFwicmVhY3Qtc2VydmVyLWRvbS10dXJib3BhY2tcIixcbiAgICAgIGN1cnJlbnREaXNwYXRjaGVyUmVmOiBSZWFjdFNoYXJlZEludGVybmFscyxcbiAgICAgIHJlY29uY2lsZXJWZXJzaW9uOiBcIjE5LjIuMC1jYW5hcnktOTdjZGQ1ZDMtMjAyNTA3MTBcIixcbiAgICAgIGdldEN1cnJlbnRDb21wb25lbnRJbmZvOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50T3duZXJJbkRFVjtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBleHBvcnRzLmNyZWF0ZUZyb21GZXRjaCA9IGZ1bmN0aW9uIChwcm9taXNlRm9yUmVzcG9uc2UsIG9wdGlvbnMpIHtcbiAgICAgIHZhciByZXNwb25zZSA9IGNyZWF0ZVJlc3BvbnNlRnJvbU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICBwcm9taXNlRm9yUmVzcG9uc2UudGhlbihcbiAgICAgICAgZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICBvcHRpb25zICYmIG9wdGlvbnMuZGVidWdDaGFubmVsICYmIG9wdGlvbnMuZGVidWdDaGFubmVsLnJlYWRhYmxlXG4gICAgICAgICAgICA/IChzdGFydFJlYWRpbmdGcm9tVW5pdmVyc2FsU3RyZWFtKFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMuZGVidWdDaGFubmVsLnJlYWRhYmxlXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIHN0YXJ0UmVhZGluZ0Zyb21TdHJlYW0ocmVzcG9uc2UsIHIuYm9keSwgITApKVxuICAgICAgICAgICAgOiBzdGFydFJlYWRpbmdGcm9tU3RyZWFtKHJlc3BvbnNlLCByLmJvZHksICExKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICByZXBvcnRHbG9iYWxFcnJvcihyZXNwb25zZSwgZSk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICByZXR1cm4gZ2V0Um9vdChyZXNwb25zZSk7XG4gICAgfTtcbiAgICBleHBvcnRzLmNyZWF0ZUZyb21SZWFkYWJsZVN0cmVhbSA9IGZ1bmN0aW9uIChzdHJlYW0sIG9wdGlvbnMpIHtcbiAgICAgIHZhciByZXNwb25zZSA9IGNyZWF0ZVJlc3BvbnNlRnJvbU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICBvcHRpb25zICYmIG9wdGlvbnMuZGVidWdDaGFubmVsICYmIG9wdGlvbnMuZGVidWdDaGFubmVsLnJlYWRhYmxlXG4gICAgICAgID8gKHN0YXJ0UmVhZGluZ0Zyb21Vbml2ZXJzYWxTdHJlYW0oXG4gICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgIG9wdGlvbnMuZGVidWdDaGFubmVsLnJlYWRhYmxlXG4gICAgICAgICAgKSxcbiAgICAgICAgICBzdGFydFJlYWRpbmdGcm9tU3RyZWFtKHJlc3BvbnNlLCBzdHJlYW0sICEwKSlcbiAgICAgICAgOiBzdGFydFJlYWRpbmdGcm9tU3RyZWFtKHJlc3BvbnNlLCBzdHJlYW0sICExKTtcbiAgICAgIHJldHVybiBnZXRSb290KHJlc3BvbnNlKTtcbiAgICB9O1xuICAgIGV4cG9ydHMuY3JlYXRlU2VydmVyUmVmZXJlbmNlID0gZnVuY3Rpb24gKFxuICAgICAgaWQsXG4gICAgICBjYWxsU2VydmVyLFxuICAgICAgZW5jb2RlRm9ybUFjdGlvbixcbiAgICAgIGZpbmRTb3VyY2VNYXBVUkwsXG4gICAgICBmdW5jdGlvbk5hbWVcbiAgICApIHtcbiAgICAgIGZ1bmN0aW9uIGFjdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gY2FsbFNlcnZlcihpZCwgYXJncyk7XG4gICAgICB9XG4gICAgICB2YXIgbG9jYXRpb24gPSBwYXJzZVN0YWNrTG9jYXRpb24oRXJyb3IoXCJyZWFjdC1zdGFjay10b3AtZnJhbWVcIikpO1xuICAgICAgaWYgKG51bGwgIT09IGxvY2F0aW9uKSB7XG4gICAgICAgIGVuY29kZUZvcm1BY3Rpb24gPSBsb2NhdGlvblsxXTtcbiAgICAgICAgdmFyIGxpbmUgPSBsb2NhdGlvblsyXTtcbiAgICAgICAgbG9jYXRpb24gPSBsb2NhdGlvblszXTtcbiAgICAgICAgZmluZFNvdXJjZU1hcFVSTCA9XG4gICAgICAgICAgbnVsbCA9PSBmaW5kU291cmNlTWFwVVJMXG4gICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgIDogZmluZFNvdXJjZU1hcFVSTChlbmNvZGVGb3JtQWN0aW9uLCBcIkNsaWVudFwiKTtcbiAgICAgICAgYWN0aW9uID0gY3JlYXRlRmFrZVNlcnZlckZ1bmN0aW9uKFxuICAgICAgICAgIGZ1bmN0aW9uTmFtZSB8fCBcIlwiLFxuICAgICAgICAgIGVuY29kZUZvcm1BY3Rpb24sXG4gICAgICAgICAgZmluZFNvdXJjZU1hcFVSTCxcbiAgICAgICAgICBsaW5lLFxuICAgICAgICAgIGxvY2F0aW9uLFxuICAgICAgICAgIFwiQ2xpZW50XCIsXG4gICAgICAgICAgYWN0aW9uXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZWdpc3RlckJvdW5kU2VydmVyUmVmZXJlbmNlKGFjdGlvbiwgaWQsIG51bGwpO1xuICAgICAgcmV0dXJuIGFjdGlvbjtcbiAgICB9O1xuICAgIGV4cG9ydHMuY3JlYXRlVGVtcG9yYXJ5UmVmZXJlbmNlU2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBNYXAoKTtcbiAgICB9O1xuICAgIGV4cG9ydHMuZW5jb2RlUmVwbHkgPSBmdW5jdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciBhYm9ydCA9IHByb2Nlc3NSZXBseShcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBcIlwiLFxuICAgICAgICAgIG9wdGlvbnMgJiYgb3B0aW9ucy50ZW1wb3JhcnlSZWZlcmVuY2VzXG4gICAgICAgICAgICA/IG9wdGlvbnMudGVtcG9yYXJ5UmVmZXJlbmNlc1xuICAgICAgICAgICAgOiB2b2lkIDAsXG4gICAgICAgICAgcmVzb2x2ZSxcbiAgICAgICAgICByZWplY3RcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5zaWduYWwpIHtcbiAgICAgICAgICB2YXIgc2lnbmFsID0gb3B0aW9ucy5zaWduYWw7XG4gICAgICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSBhYm9ydChzaWduYWwucmVhc29uKTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgYWJvcnQoc2lnbmFsLnJlYXNvbik7XG4gICAgICAgICAgICAgIHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgbGlzdGVuZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBleHBvcnRzLnJlZ2lzdGVyU2VydmVyUmVmZXJlbmNlID0gZnVuY3Rpb24gKHJlZmVyZW5jZSwgaWQpIHtcbiAgICAgIHJlZ2lzdGVyQm91bmRTZXJ2ZXJSZWZlcmVuY2UocmVmZXJlbmNlLCBpZCwgbnVsbCk7XG4gICAgICByZXR1cm4gcmVmZXJlbmNlO1xuICAgIH07XG4gIH0pKCk7XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0NBUUMsR0FHZ0I7QUFEakI7QUFDQSxvRUFDRSxBQUFDO0lBQ0MsU0FBUyx1QkFBdUIsYUFBYSxFQUFFLFFBQVE7UUFDckQsSUFBSSxlQUFlO1lBQ2pCLElBQUksZ0JBQWdCLGFBQWEsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDO1lBQzlDLElBQUssZ0JBQWdCLGlCQUFpQixhQUFhLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxFQUM5RCxnQkFBZ0IsY0FBYyxJQUFJO2lCQUMvQjtnQkFDSCxnQkFBZ0IsaUJBQWlCLGFBQWEsQ0FBQyxJQUFJO2dCQUNuRCxJQUFJLENBQUMsZUFDSCxNQUFNLE1BQ0osZ0NBQ0UsUUFBUSxDQUFDLEVBQUUsR0FDWDtnQkFFTixnQkFBZ0IsUUFBUSxDQUFDLEVBQUU7WUFDN0I7WUFDQSxPQUFPLE1BQU0sU0FBUyxNQUFNLEdBQ3hCO2dCQUFDLGNBQWMsRUFBRTtnQkFBRSxjQUFjLE1BQU07Z0JBQUU7Z0JBQWU7YUFBRSxHQUMxRDtnQkFBQyxjQUFjLEVBQUU7Z0JBQUUsY0FBYyxNQUFNO2dCQUFFO2FBQWM7UUFDN0Q7UUFDQSxPQUFPO0lBQ1Q7SUFDQSxTQUFTLHVCQUF1QixhQUFhLEVBQUUsRUFBRTtRQUMvQyxJQUFJLE9BQU8sSUFDVCxxQkFBcUIsYUFBYSxDQUFDLEdBQUc7UUFDeEMsSUFBSSxvQkFBb0IsT0FBTyxtQkFBbUIsSUFBSTthQUNqRDtZQUNILElBQUksTUFBTSxHQUFHLFdBQVcsQ0FBQztZQUN6QixDQUFDLE1BQU0sT0FDTCxDQUFDLEFBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQyxNQUFNLElBQ3ZCLHFCQUFxQixhQUFhLENBQUMsR0FBRyxLQUFLLENBQUMsR0FBRyxLQUFLLEFBQUM7WUFDeEQsSUFBSSxDQUFDLG9CQUNILE1BQU0sTUFDSixnQ0FDRSxLQUNBO1FBRVI7UUFDQSxPQUFPO1lBQUMsbUJBQW1CLEVBQUU7WUFBRSxtQkFBbUIsTUFBTTtZQUFFO1NBQUs7SUFDakU7SUFDQSxTQUFTLG1CQUFtQixFQUFFO1FBQzVCLElBQUksVUFBVSwwREFBc0I7UUFDcEMsSUFBSSxlQUFlLE9BQU8sUUFBUSxJQUFJLElBQUksZ0JBQWdCLFFBQVEsTUFBTSxFQUN0RSxPQUFPO1FBQ1QsUUFBUSxJQUFJLENBQ1YsU0FBVSxLQUFLO1lBQ2IsUUFBUSxNQUFNLEdBQUc7WUFDakIsUUFBUSxLQUFLLEdBQUc7UUFDbEIsR0FDQSxTQUFVLE1BQU07WUFDZCxRQUFRLE1BQU0sR0FBRztZQUNqQixRQUFRLE1BQU0sR0FBRztRQUNuQjtRQUVGLE9BQU87SUFDVDtJQUNBLFNBQVMsZ0JBQWdCO0lBQ3pCLFNBQVMsY0FBYyxRQUFRO1FBQzdCLElBQ0UsSUFBSSxTQUFTLFFBQVEsQ0FBQyxFQUFFLEVBQUUsV0FBVyxFQUFFLEVBQUUsSUFBSSxHQUM3QyxJQUFJLE9BQU8sTUFBTSxFQUNqQixJQUNBO1lBQ0EsSUFBSSxnQkFBZ0IsTUFBTSxDQUFDLEVBQUUsRUFDM0IsUUFBUSxXQUFXLEdBQUcsQ0FBQztZQUN6QixJQUFJLEtBQUssTUFBTSxPQUFPO2dCQUNwQixRQUFRLDBEQUEwQjtnQkFDbEMsU0FBUyxJQUFJLENBQUM7Z0JBQ2QsSUFBSSxVQUFVLFdBQVcsR0FBRyxDQUFDLElBQUksQ0FBQyxZQUFZLGVBQWU7Z0JBQzdELE1BQU0sSUFBSSxDQUFDLFNBQVM7Z0JBQ3BCLFdBQVcsR0FBRyxDQUFDLGVBQWU7WUFDaEMsT0FBTyxTQUFTLFNBQVMsU0FBUyxJQUFJLENBQUM7UUFDekM7UUFDQSxPQUFPLE1BQU0sU0FBUyxNQUFNLEdBQ3hCLE1BQU0sU0FBUyxNQUFNLEdBQ25CLG1CQUFtQixRQUFRLENBQUMsRUFBRSxJQUM5QixRQUFRLEdBQUcsQ0FBQyxVQUFVLElBQUksQ0FBQztZQUN6QixPQUFPLG1CQUFtQixRQUFRLENBQUMsRUFBRTtRQUN2QyxLQUNGLElBQUksU0FBUyxNQUFNLEdBQ2pCLFFBQVEsR0FBRyxDQUFDLFlBQ1o7SUFDUjtJQUNBLFNBQVMsY0FBYyxRQUFRO1FBQzdCLElBQUksZ0JBQWdCLDBEQUFzQixRQUFRLENBQUMsRUFBRTtRQUNyRCxJQUFJLE1BQU0sU0FBUyxNQUFNLElBQUksZUFBZSxPQUFPLGNBQWMsSUFBSSxFQUNuRSxJQUFJLGdCQUFnQixjQUFjLE1BQU0sRUFDdEMsZ0JBQWdCLGNBQWMsS0FBSzthQUNoQyxNQUFNLGNBQWMsTUFBTTtRQUNqQyxPQUFPLFFBQVEsUUFBUSxDQUFDLEVBQUUsR0FDdEIsZ0JBQ0EsT0FBTyxRQUFRLENBQUMsRUFBRSxHQUNoQixjQUFjLFVBQVUsR0FDdEIsY0FBYyxPQUFPLEdBQ3JCLGdCQUNGLGFBQWEsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDO0lBQ2xDO0lBQ0EsU0FBUyxjQUFjLGFBQWE7UUFDbEMsSUFBSSxTQUFTLGlCQUFpQixhQUFhLE9BQU8sZUFDaEQsT0FBTztRQUNULGdCQUNFLEFBQUMseUJBQXlCLGFBQWEsQ0FBQyxzQkFBc0IsSUFDOUQsYUFBYSxDQUFDLGFBQWE7UUFDN0IsT0FBTyxlQUFlLE9BQU8sZ0JBQWdCLGdCQUFnQjtJQUMvRDtJQUNBLFNBQVMsa0JBQWtCLE1BQU07UUFDL0IsSUFBSSxDQUFDLFFBQVEsT0FBTyxDQUFDO1FBQ3JCLElBQUksa0JBQWtCLE9BQU8sU0FBUztRQUN0QyxJQUFJLFdBQVcsaUJBQWlCLE9BQU8sQ0FBQztRQUN4QyxJQUFJLGVBQWUsU0FBUyxPQUFPLENBQUM7UUFDcEMsU0FBUyxPQUFPLG1CQUFtQixDQUFDO1FBQ3BDLElBQUssSUFBSSxJQUFJLEdBQUcsSUFBSSxPQUFPLE1BQU0sRUFBRSxJQUNqQyxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxJQUFJLGVBQWUsR0FBRyxPQUFPLENBQUM7UUFDL0MsT0FBTyxDQUFDO0lBQ1Y7SUFDQSxTQUFTLGVBQWUsTUFBTTtRQUM1QixJQUFJLENBQUMsa0JBQWtCLGVBQWUsVUFBVSxPQUFPLENBQUM7UUFDeEQsSUFDRSxJQUFJLFFBQVEsT0FBTyxtQkFBbUIsQ0FBQyxTQUFTLElBQUksR0FDcEQsSUFBSSxNQUFNLE1BQU0sRUFDaEIsSUFDQTtZQUNBLElBQUksYUFBYSxPQUFPLHdCQUF3QixDQUFDLFFBQVEsS0FBSyxDQUFDLEVBQUU7WUFDakUsSUFDRSxDQUFDLGNBQ0EsQ0FBQyxXQUFXLFVBQVUsSUFDckIsQ0FBQyxBQUFDLFVBQVUsS0FBSyxDQUFDLEVBQUUsSUFBSSxVQUFVLEtBQUssQ0FBQyxFQUFFLElBQ3hDLGVBQWUsT0FBTyxXQUFXLEdBQUcsR0FFeEMsT0FBTyxDQUFDO1FBQ1o7UUFDQSxPQUFPLENBQUM7SUFDVjtJQUNBLFNBQVMsV0FBVyxNQUFNO1FBQ3hCLFNBQVMsT0FBTyxTQUFTLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQztRQUN4QyxPQUFPLE9BQU8sS0FBSyxDQUFDLEdBQUcsT0FBTyxNQUFNLEdBQUc7SUFDekM7SUFDQSxTQUFTLDJCQUEyQixHQUFHO1FBQ3JDLElBQUksYUFBYSxLQUFLLFNBQVMsQ0FBQztRQUNoQyxPQUFPLE1BQU0sTUFBTSxRQUFRLGFBQWEsTUFBTTtJQUNoRDtJQUNBLFNBQVMsNkJBQTZCLEtBQUs7UUFDekMsT0FBUSxPQUFPO1lBQ2IsS0FBSztnQkFDSCxPQUFPLEtBQUssU0FBUyxDQUNuQixNQUFNLE1BQU0sTUFBTSxHQUFHLFFBQVEsTUFBTSxLQUFLLENBQUMsR0FBRyxNQUFNO1lBRXRELEtBQUs7Z0JBQ0gsSUFBSSxZQUFZLFFBQVEsT0FBTztnQkFDL0IsSUFBSSxTQUFTLFNBQVMsTUFBTSxRQUFRLEtBQUssc0JBQ3ZDLE9BQU87Z0JBQ1QsUUFBUSxXQUFXO2dCQUNuQixPQUFPLGFBQWEsUUFBUSxVQUFVO1lBQ3hDLEtBQUs7Z0JBQ0gsT0FBTyxNQUFNLFFBQVEsS0FBSyx1QkFDdEIsV0FDQSxDQUFDLFFBQVEsTUFBTSxXQUFXLElBQUksTUFBTSxJQUFJLElBQ3RDLGNBQWMsUUFDZDtZQUNSO2dCQUNFLE9BQU8sT0FBTztRQUNsQjtJQUNGO0lBQ0EsU0FBUyxvQkFBb0IsSUFBSTtRQUMvQixJQUFJLGFBQWEsT0FBTyxNQUFNLE9BQU87UUFDckMsT0FBUTtZQUNOLEtBQUs7Z0JBQ0gsT0FBTztZQUNULEtBQUs7Z0JBQ0gsT0FBTztRQUNYO1FBQ0EsSUFBSSxhQUFhLE9BQU8sTUFDdEIsT0FBUSxLQUFLLFFBQVE7WUFDbkIsS0FBSztnQkFDSCxPQUFPLG9CQUFvQixLQUFLLE1BQU07WUFDeEMsS0FBSztnQkFDSCxPQUFPLG9CQUFvQixLQUFLLElBQUk7WUFDdEMsS0FBSztnQkFDSCxJQUFJLFVBQVUsS0FBSyxRQUFRO2dCQUMzQixPQUFPLEtBQUssS0FBSztnQkFDakIsSUFBSTtvQkFDRixPQUFPLG9CQUFvQixLQUFLO2dCQUNsQyxFQUFFLE9BQU8sR0FBRyxDQUFDO1FBQ2pCO1FBQ0YsT0FBTztJQUNUO0lBQ0EsU0FBUyw4QkFBOEIsYUFBYSxFQUFFLFlBQVk7UUFDaEUsSUFBSSxVQUFVLFdBQVc7UUFDekIsSUFBSSxhQUFhLFdBQVcsWUFBWSxTQUFTLE9BQU87UUFDeEQsSUFBSSxRQUFRLENBQUMsR0FDWCxTQUFTO1FBQ1gsSUFBSSxZQUFZLGdCQUNkLElBQUksbUJBQW1CLEdBQUcsQ0FBQyxnQkFBZ0I7WUFDekMsSUFBSSxPQUFPLG1CQUFtQixHQUFHLENBQUM7WUFDbEMsVUFBVSxNQUFNLG9CQUFvQixRQUFRO1lBQzVDLElBQUssSUFBSSxJQUFJLEdBQUcsSUFBSSxjQUFjLE1BQU0sRUFBRSxJQUFLO2dCQUM3QyxJQUFJLFFBQVEsYUFBYSxDQUFDLEVBQUU7Z0JBQzVCLFFBQ0UsYUFBYSxPQUFPLFFBQ2hCLFFBQ0EsYUFBYSxPQUFPLFNBQVMsU0FBUyxRQUNwQyxNQUFNLDhCQUE4QixTQUFTLE1BQzdDLE1BQU0sNkJBQTZCLFNBQVM7Z0JBQ3BELEtBQUssTUFBTSxlQUNQLENBQUMsQUFBQyxRQUFRLFFBQVEsTUFBTSxFQUN2QixTQUFTLE1BQU0sTUFBTSxFQUNyQixXQUFXLEtBQU0sSUFDakIsVUFDQyxLQUFLLE1BQU0sTUFBTSxJQUFJLEtBQUssUUFBUSxNQUFNLEdBQUcsTUFBTSxNQUFNLEdBQ25ELFVBQVUsUUFDVixVQUFVO1lBQ3RCO1lBQ0EsV0FBVyxPQUFPLG9CQUFvQixRQUFRO1FBQ2hELE9BQU87WUFDTCxVQUFVO1lBQ1YsSUFBSyxPQUFPLEdBQUcsT0FBTyxjQUFjLE1BQU0sRUFBRSxPQUMxQyxJQUFJLFFBQVEsQ0FBQyxXQUFXLElBQUksR0FDekIsSUFBSSxhQUFhLENBQUMsS0FBSyxFQUN2QixJQUNDLGFBQWEsT0FBTyxLQUFLLFNBQVMsSUFDOUIsOEJBQThCLEtBQzlCLDZCQUE2QixJQUNuQyxLQUFLLFNBQVMsZUFDVixDQUFDLEFBQUMsUUFBUSxRQUFRLE1BQU0sRUFDdkIsU0FBUyxFQUFFLE1BQU0sRUFDakIsV0FBVyxDQUFFLElBQ2IsVUFDQyxLQUFLLEVBQUUsTUFBTSxJQUFJLEtBQUssUUFBUSxNQUFNLEdBQUcsRUFBRSxNQUFNLEdBQzNDLFVBQVUsSUFDVixVQUFVO1lBQ3hCLFdBQVc7UUFDYjthQUNHLElBQUksY0FBYyxRQUFRLEtBQUssb0JBQ2xDLFVBQVUsTUFBTSxvQkFBb0IsY0FBYyxJQUFJLElBQUk7YUFDdkQ7WUFDSCxJQUFJLGNBQWMsUUFBUSxLQUFLLHNCQUFzQixPQUFPO1lBQzVELElBQUksZ0JBQWdCLEdBQUcsQ0FBQyxnQkFBZ0I7Z0JBQ3RDLFVBQVUsZ0JBQWdCLEdBQUcsQ0FBQztnQkFDOUIsVUFBVSxNQUFNLENBQUMsb0JBQW9CLFlBQVksS0FBSztnQkFDdEQsT0FBTyxPQUFPLElBQUksQ0FBQztnQkFDbkIsSUFBSyxJQUFJLEdBQUcsSUFBSSxLQUFLLE1BQU0sRUFBRSxJQUFLO29CQUNoQyxXQUFXO29CQUNYLFFBQVEsSUFBSSxDQUFDLEVBQUU7b0JBQ2YsV0FBVywyQkFBMkIsU0FBUztvQkFDL0MsSUFBSSxVQUFVLGFBQWEsQ0FBQyxNQUFNO29CQUNsQyxJQUFJLFdBQ0YsVUFBVSxnQkFDVixhQUFhLE9BQU8sV0FDcEIsU0FBUyxVQUNMLDhCQUE4QixXQUM5Qiw2QkFBNkI7b0JBQ25DLGFBQWEsT0FBTyxXQUFXLENBQUMsV0FBVyxNQUFNLFdBQVcsR0FBRztvQkFDL0QsVUFBVSxlQUNOLENBQUMsQUFBQyxRQUFRLFFBQVEsTUFBTSxFQUN2QixTQUFTLFNBQVMsTUFBTSxFQUN4QixXQUFXLFFBQVMsSUFDcEIsVUFDQyxLQUFLLFNBQVMsTUFBTSxJQUFJLEtBQUssUUFBUSxNQUFNLEdBQUcsU0FBUyxNQUFNLEdBQ3pELFVBQVUsV0FDVixVQUFVO2dCQUN0QjtnQkFDQSxXQUFXO1lBQ2IsT0FBTztnQkFDTCxVQUFVO2dCQUNWLE9BQU8sT0FBTyxJQUFJLENBQUM7Z0JBQ25CLElBQUssSUFBSSxHQUFHLElBQUksS0FBSyxNQUFNLEVBQUUsSUFDM0IsSUFBSSxLQUFLLENBQUMsV0FBVyxJQUFJLEdBQ3RCLFFBQVEsSUFBSSxDQUFDLEVBQUUsRUFDZixXQUFXLDJCQUEyQixTQUFTLE1BQy9DLFVBQVUsYUFBYSxDQUFDLE1BQU0sRUFDOUIsVUFDQyxhQUFhLE9BQU8sV0FBVyxTQUFTLFVBQ3BDLDhCQUE4QixXQUM5Qiw2QkFBNkIsVUFDbkMsVUFBVSxlQUNOLENBQUMsQUFBQyxRQUFRLFFBQVEsTUFBTSxFQUN2QixTQUFTLFFBQVEsTUFBTSxFQUN2QixXQUFXLE9BQVEsSUFDbkIsVUFDQyxLQUFLLFFBQVEsTUFBTSxJQUFJLEtBQUssUUFBUSxNQUFNLEdBQUcsUUFBUSxNQUFNLEdBQ3ZELFVBQVUsVUFDVixVQUFVO2dCQUN4QixXQUFXO1lBQ2I7UUFDRjtRQUNBLE9BQU8sS0FBSyxNQUFNLGVBQ2QsVUFDQSxDQUFDLElBQUksU0FBUyxJQUFJLFNBQ2hCLENBQUMsQUFBQyxnQkFBZ0IsSUFBSSxNQUFNLENBQUMsU0FBUyxJQUFJLE1BQU0sQ0FBQyxTQUNqRCxTQUFTLFVBQVUsU0FBUyxhQUFhLElBQ3pDLFNBQVM7SUFDakI7SUFDQSxTQUFTLGdCQUFnQixNQUFNO1FBQzdCLE9BQU8sT0FBTyxRQUFRLENBQUMsVUFDbkIsTUFBTSxVQUFVLENBQUMsYUFBYSxJQUFJLFNBQ2hDLFFBQ0EsU0FDRixhQUFhLFNBQ1gsY0FDQSxDQUFDLGFBQWEsU0FDWixlQUNBO0lBQ1Y7SUFDQSxTQUFTLGFBQ1AsSUFBSSxFQUNKLGVBQWUsRUFDZixtQkFBbUIsRUFDbkIsT0FBTyxFQUNQLE1BQU07UUFFTixTQUFTLG9CQUFvQixHQUFHLEVBQUUsVUFBVTtZQUMxQyxhQUFhLElBQUksS0FBSztnQkFDcEIsSUFBSSxXQUNGLFdBQVcsTUFBTSxFQUNqQixXQUFXLFVBQVUsRUFDckIsV0FBVyxVQUFVO2FBRXhCO1lBQ0QsSUFBSSxTQUFTO1lBQ2IsU0FBUyxZQUFZLENBQUMsV0FBVyxJQUFJLFVBQVU7WUFDL0MsU0FBUyxNQUFNLENBQUMsa0JBQWtCLFFBQVE7WUFDMUMsT0FBTyxNQUFNLE1BQU0sT0FBTyxRQUFRLENBQUM7UUFDckM7UUFDQSxTQUFTLHNCQUFzQixNQUFNO1lBQ25DLFNBQVMsU0FBUyxLQUFLO2dCQUNyQixNQUFNLElBQUksR0FDTixDQUFDLEFBQUMsUUFBUSxjQUNWLEtBQUssTUFBTSxDQUFDLGtCQUFrQixPQUFPLElBQUksS0FBSyxVQUM5QyxLQUFLLE1BQU0sQ0FDVCxrQkFBa0IsVUFDbEIsUUFBUSxNQUFNLFFBQVEsQ0FBQyxNQUFNLE1BRS9CLEtBQUssTUFBTSxDQUFDLGtCQUFrQixVQUFVLE1BQ3hDLGdCQUNBLE1BQU0sZ0JBQWdCLFFBQVEsS0FBSyxJQUNuQyxDQUFDLE9BQU8sSUFBSSxDQUFDLE1BQU0sS0FBSyxHQUN4QixPQUFPLElBQUksQ0FBQyxJQUFJLFdBQVcsT0FBTyxJQUFJLENBQUMsVUFBVSxPQUFPO1lBQzlEO1lBQ0EsU0FBUyxZQUFZLENBQUMsV0FBVyxJQUFJLFVBQVU7WUFDL0MsSUFBSSxPQUFPO1lBQ1g7WUFDQSxJQUFJLFdBQVcsY0FDYixTQUFTLEVBQUU7WUFDYixPQUFPLElBQUksQ0FBQyxJQUFJLFdBQVcsT0FBTyxJQUFJLENBQUMsVUFBVTtZQUNqRCxPQUFPLE9BQU8sU0FBUyxRQUFRLENBQUM7UUFDbEM7UUFDQSxTQUFTLGdCQUFnQixNQUFNO1lBQzdCLFNBQVMsU0FBUyxLQUFLO2dCQUNyQixJQUFJLE1BQU0sSUFBSSxFQUNaLEtBQUssTUFBTSxDQUFDLGtCQUFrQixVQUFVLE1BQ3RDLGdCQUNBLE1BQU0sZ0JBQWdCLFFBQVE7cUJBRWhDLElBQUk7b0JBQ0YsSUFBSSxXQUFXLEtBQUssU0FBUyxDQUFDLE1BQU0sS0FBSyxFQUFFO29CQUMzQyxLQUFLLE1BQU0sQ0FBQyxrQkFBa0IsVUFBVTtvQkFDeEMsT0FBTyxJQUFJLEdBQUcsSUFBSSxDQUFDLFVBQVU7Z0JBQy9CLEVBQUUsT0FBTyxHQUFHO29CQUNWLE9BQU87Z0JBQ1Q7WUFDSjtZQUNBLFNBQVMsWUFBWSxDQUFDLFdBQVcsSUFBSSxVQUFVO1lBQy9DLElBQUksT0FBTztZQUNYO1lBQ0EsSUFBSSxXQUFXO1lBQ2YsT0FBTyxJQUFJLEdBQUcsSUFBSSxDQUFDLFVBQVU7WUFDN0IsT0FBTyxPQUFPLFNBQVMsUUFBUSxDQUFDO1FBQ2xDO1FBQ0EsU0FBUyx3QkFBd0IsTUFBTTtZQUNyQyxJQUFJO2dCQUNGLElBQUksZUFBZSxPQUFPLFNBQVMsQ0FBQztvQkFBRSxNQUFNO2dCQUFPO1lBQ3JELEVBQUUsT0FBTyxHQUFHO2dCQUNWLE9BQU8sZ0JBQWdCLE9BQU8sU0FBUztZQUN6QztZQUNBLE9BQU8sc0JBQXNCO1FBQy9CO1FBQ0EsU0FBUyx1QkFBdUIsUUFBUSxFQUFFLFFBQVE7WUFDaEQsU0FBUyxTQUFTLEtBQUs7Z0JBQ3JCLElBQUksTUFBTSxJQUFJLEVBQUU7b0JBQ2QsSUFBSSxLQUFLLE1BQU0sTUFBTSxLQUFLLEVBQ3hCLEtBQUssTUFBTSxDQUFDLGtCQUFrQixVQUFVO3lCQUV4QyxJQUFJO3dCQUNGLElBQUksV0FBVyxLQUFLLFNBQVMsQ0FBQyxNQUFNLEtBQUssRUFBRTt3QkFDM0MsS0FBSyxNQUFNLENBQUMsa0JBQWtCLFVBQVUsTUFBTTtvQkFDaEQsRUFBRSxPQUFPLEdBQUc7d0JBQ1YsT0FBTzt3QkFDUDtvQkFDRjtvQkFDRjtvQkFDQSxNQUFNLGdCQUFnQixRQUFRO2dCQUNoQyxPQUNFLElBQUk7b0JBQ0YsSUFBSSxZQUFZLEtBQUssU0FBUyxDQUFDLE1BQU0sS0FBSyxFQUFFO29CQUM1QyxLQUFLLE1BQU0sQ0FBQyxrQkFBa0IsVUFBVTtvQkFDeEMsU0FBUyxJQUFJLEdBQUcsSUFBSSxDQUFDLFVBQVU7Z0JBQ2pDLEVBQUUsT0FBTyxLQUFLO29CQUNaLE9BQU87Z0JBQ1Q7WUFDSjtZQUNBLFNBQVMsWUFBWSxDQUFDLFdBQVcsSUFBSSxVQUFVO1lBQy9DLElBQUksT0FBTztZQUNYO1lBQ0EsSUFBSSxXQUFXO1lBQ2YsV0FBVyxhQUFhO1lBQ3hCLFNBQVMsSUFBSSxHQUFHLElBQUksQ0FBQyxVQUFVO1lBQy9CLE9BQU8sTUFBTSxDQUFDLFdBQVcsTUFBTSxHQUFHLElBQUksU0FBUyxRQUFRLENBQUM7UUFDMUQ7UUFDQSxTQUFTLGNBQWMsR0FBRyxFQUFFLEtBQUs7WUFDL0IsSUFBSSxnQkFBZ0IsSUFBSSxDQUFDLElBQUk7WUFDN0IsYUFBYSxPQUFPLGlCQUNsQixrQkFBa0IsU0FDbEIseUJBQXlCLFFBQ3pCLENBQUMsYUFBYSxXQUFXLGlCQUNyQixRQUFRLEtBQUssQ0FDWCx5R0FDQSxXQUFXLGdCQUNYLDhCQUE4QixJQUFJLEVBQUUsUUFFdEMsUUFBUSxLQUFLLENBQ1gsNExBQ0EsOEJBQThCLElBQUksRUFBRSxLQUNyQztZQUNQLElBQUksU0FBUyxPQUFPLE9BQU87WUFDM0IsSUFBSSxhQUFhLE9BQU8sT0FBTztnQkFDN0IsT0FBUSxNQUFNLFFBQVE7b0JBQ3BCLEtBQUs7d0JBQ0gsSUFBSSxLQUFLLE1BQU0sdUJBQXVCLENBQUMsTUFBTSxJQUFJLE9BQU8sQ0FBQyxNQUFNOzRCQUM3RCxJQUFJLGtCQUFrQixlQUFlLEdBQUcsQ0FBQyxJQUFJOzRCQUM3QyxJQUFJLEtBQUssTUFBTSxpQkFDYixPQUNFLG9CQUFvQixHQUFHLENBQUMsa0JBQWtCLE1BQU0sS0FBSyxRQUNyRDt3QkFFTjt3QkFDQSxNQUFNLE1BQ0osdUpBQ0UsOEJBQThCLElBQUksRUFBRTtvQkFFMUMsS0FBSzt3QkFDSCxnQkFBZ0IsTUFBTSxRQUFRO3dCQUM5QixJQUFJLE9BQU8sTUFBTSxLQUFLO3dCQUN0QixTQUFTLFlBQVksQ0FBQyxXQUFXLElBQUksVUFBVTt3QkFDL0M7d0JBQ0EsSUFBSTs0QkFDRixrQkFBa0IsS0FBSzs0QkFDdkIsSUFBSSxTQUFTLGNBQ1gsV0FBVyxlQUFlLGlCQUFpQjs0QkFDN0MsU0FBUyxNQUFNLENBQUMsa0JBQWtCLFFBQVE7NEJBQzFDLE9BQU8sTUFBTSxPQUFPLFFBQVEsQ0FBQzt3QkFDL0IsRUFBRSxPQUFPLEdBQUc7NEJBQ1YsSUFDRSxhQUFhLE9BQU8sS0FDcEIsU0FBUyxLQUNULGVBQWUsT0FBTyxFQUFFLElBQUksRUFDNUI7Z0NBQ0E7Z0NBQ0EsSUFBSSxVQUFVO2dDQUNkLGtCQUFrQjtvQ0FDaEIsSUFBSTt3Q0FDRixJQUFJLGFBQWEsZUFBZSxPQUFPLFVBQ3JDLFFBQVE7d0NBQ1YsTUFBTSxNQUFNLENBQUMsa0JBQWtCLFNBQVM7d0NBQ3hDO3dDQUNBLE1BQU0sZ0JBQWdCLFFBQVE7b0NBQ2hDLEVBQUUsT0FBTyxRQUFRO3dDQUNmLE9BQU87b0NBQ1Q7Z0NBQ0Y7Z0NBQ0EsRUFBRSxJQUFJLENBQUMsaUJBQWlCO2dDQUN4QixPQUFPLE1BQU0sUUFBUSxRQUFRLENBQUM7NEJBQ2hDOzRCQUNBLE9BQU87NEJBQ1AsT0FBTzt3QkFDVCxTQUFVOzRCQUNSO3dCQUNGO2dCQUNKO2dCQUNBLElBQUksZUFBZSxPQUFPLE1BQU0sSUFBSSxFQUFFO29CQUNwQyxTQUFTLFlBQVksQ0FBQyxXQUFXLElBQUksVUFBVTtvQkFDL0M7b0JBQ0EsSUFBSSxZQUFZO29CQUNoQixNQUFNLElBQUksQ0FBQyxTQUFVLFNBQVM7d0JBQzVCLElBQUk7NEJBQ0YsSUFBSSxhQUFhLGVBQWUsV0FBVzs0QkFDM0MsWUFBWTs0QkFDWixVQUFVLE1BQU0sQ0FBQyxrQkFBa0IsV0FBVzs0QkFDOUM7NEJBQ0EsTUFBTSxnQkFBZ0IsUUFBUTt3QkFDaEMsRUFBRSxPQUFPLFFBQVE7NEJBQ2YsT0FBTzt3QkFDVDtvQkFDRixHQUFHO29CQUNILE9BQU8sT0FBTyxVQUFVLFFBQVEsQ0FBQztnQkFDbkM7Z0JBQ0Esa0JBQWtCLGVBQWUsR0FBRyxDQUFDO2dCQUNyQyxJQUFJLEtBQUssTUFBTSxpQkFDYixJQUFJLGNBQWMsT0FBTyxZQUFZO3FCQUNoQyxPQUFPO3FCQUVaLENBQUMsTUFBTSxJQUFJLE9BQU8sQ0FBQyxRQUNqQixDQUFDLEFBQUMsa0JBQWtCLGVBQWUsR0FBRyxDQUFDLElBQUksR0FDM0MsS0FBSyxNQUFNLG1CQUNULENBQUMsQUFBQyxrQkFBa0Isa0JBQWtCLE1BQU0sS0FDNUMsZUFBZSxHQUFHLENBQUMsT0FBTyxrQkFDMUIsS0FBSyxNQUFNLHVCQUNULG9CQUFvQixHQUFHLENBQUMsaUJBQWlCLE1BQU0sQ0FBQztnQkFDeEQsSUFBSSxZQUFZLFFBQVEsT0FBTztnQkFDL0IsSUFBSSxpQkFBaUIsVUFBVTtvQkFDN0IsU0FBUyxZQUFZLENBQUMsV0FBVyxJQUFJLFVBQVU7b0JBQy9DLElBQUksU0FBUztvQkFDYixNQUFNO29CQUNOLElBQUksU0FBUyxrQkFBa0IsTUFBTTtvQkFDckMsTUFBTSxPQUFPLENBQUMsU0FBVSxhQUFhLEVBQUUsV0FBVzt3QkFDaEQsT0FBTyxNQUFNLENBQUMsU0FBUyxhQUFhO29CQUN0QztvQkFDQSxPQUFPLE9BQU8sSUFBSSxRQUFRLENBQUM7Z0JBQzdCO2dCQUNBLElBQUksaUJBQWlCLEtBQ25CLE9BQ0UsQUFBQyxNQUFNLGNBQ04sa0JBQWtCLGVBQWUsTUFBTSxJQUFJLENBQUMsUUFBUSxNQUNyRCxTQUFTLFlBQVksQ0FBQyxXQUFXLElBQUksVUFBVSxHQUMvQyxTQUFTLE1BQU0sQ0FBQyxrQkFBa0IsS0FBSyxrQkFDdkMsT0FBTyxJQUFJLFFBQVEsQ0FBQztnQkFFeEIsSUFBSSxpQkFBaUIsS0FDbkIsT0FDRSxBQUFDLE1BQU0sY0FDTixrQkFBa0IsZUFBZSxNQUFNLElBQUksQ0FBQyxRQUFRLE1BQ3JELFNBQVMsWUFBWSxDQUFDLFdBQVcsSUFBSSxVQUFVLEdBQy9DLFNBQVMsTUFBTSxDQUFDLGtCQUFrQixLQUFLLGtCQUN2QyxPQUFPLElBQUksUUFBUSxDQUFDO2dCQUV4QixJQUFJLGlCQUFpQixhQUNuQixPQUNFLEFBQUMsTUFBTSxJQUFJLEtBQUs7b0JBQUM7aUJBQU0sR0FDdEIsa0JBQWtCLGNBQ25CLFNBQVMsWUFBWSxDQUFDLFdBQVcsSUFBSSxVQUFVLEdBQy9DLFNBQVMsTUFBTSxDQUFDLGtCQUFrQixpQkFBaUIsTUFDbkQsT0FBTyxnQkFBZ0IsUUFBUSxDQUFDO2dCQUVwQyxJQUFJLGlCQUFpQixXQUNuQixPQUFPLG9CQUFvQixLQUFLO2dCQUNsQyxJQUFJLGlCQUFpQixZQUNuQixPQUFPLG9CQUFvQixLQUFLO2dCQUNsQyxJQUFJLGlCQUFpQixtQkFDbkIsT0FBTyxvQkFBb0IsS0FBSztnQkFDbEMsSUFBSSxpQkFBaUIsWUFDbkIsT0FBTyxvQkFBb0IsS0FBSztnQkFDbEMsSUFBSSxpQkFBaUIsYUFDbkIsT0FBTyxvQkFBb0IsS0FBSztnQkFDbEMsSUFBSSxpQkFBaUIsWUFDbkIsT0FBTyxvQkFBb0IsS0FBSztnQkFDbEMsSUFBSSxpQkFBaUIsYUFDbkIsT0FBTyxvQkFBb0IsS0FBSztnQkFDbEMsSUFBSSxpQkFBaUIsY0FDbkIsT0FBTyxvQkFBb0IsS0FBSztnQkFDbEMsSUFBSSxpQkFBaUIsY0FDbkIsT0FBTyxvQkFBb0IsS0FBSztnQkFDbEMsSUFBSSxpQkFBaUIsZUFDbkIsT0FBTyxvQkFBb0IsS0FBSztnQkFDbEMsSUFBSSxpQkFBaUIsZ0JBQ25CLE9BQU8sb0JBQW9CLEtBQUs7Z0JBQ2xDLElBQUksaUJBQWlCLFVBQVUsT0FBTyxvQkFBb0IsS0FBSztnQkFDL0QsSUFBSSxlQUFlLE9BQU8sUUFBUSxpQkFBaUIsTUFDakQsT0FDRSxTQUFTLFlBQVksQ0FBQyxXQUFXLElBQUksVUFBVSxHQUM5QyxNQUFNLGNBQ1AsU0FBUyxNQUFNLENBQUMsa0JBQWtCLEtBQUssUUFDdkMsT0FBTyxJQUFJLFFBQVEsQ0FBQztnQkFFeEIsSUFBSyxrQkFBa0IsY0FBYyxRQUNuQyxPQUNFLEFBQUMsa0JBQWtCLGdCQUFnQixJQUFJLENBQUMsUUFDeEMsb0JBQW9CLFFBQ2hCLENBQUMsQUFBQyxNQUFNLGNBQ1Asa0JBQWtCLGVBQ2pCLE1BQU0sSUFBSSxDQUFDLGtCQUNYLE1BRUYsU0FBUyxZQUFZLENBQUMsV0FBVyxJQUFJLFVBQVUsR0FDL0MsU0FBUyxNQUFNLENBQUMsa0JBQWtCLEtBQUssa0JBQ3ZDLE9BQU8sSUFBSSxRQUFRLENBQUMsR0FBRyxJQUN2QixNQUFNLElBQUksQ0FBQztnQkFFbkIsSUFDRSxlQUFlLE9BQU8sa0JBQ3RCLGlCQUFpQixnQkFFakIsT0FBTyx3QkFBd0I7Z0JBQ2pDLGtCQUFrQixLQUFLLENBQUMsZUFBZTtnQkFDdkMsSUFBSSxlQUFlLE9BQU8saUJBQ3hCLE9BQU8sdUJBQXVCLE9BQU8sZ0JBQWdCLElBQUksQ0FBQztnQkFDNUQsa0JBQWtCLGVBQWU7Z0JBQ2pDLElBQ0Usb0JBQW9CLG1CQUNwQixDQUFDLFNBQVMsbUJBQ1IsU0FBUyxlQUFlLGdCQUFnQixHQUMxQztvQkFDQSxJQUFJLEtBQUssTUFBTSxxQkFDYixNQUFNLE1BQ0osOEhBQ0UsOEJBQThCLElBQUksRUFBRTtvQkFFMUMsT0FBTztnQkFDVDtnQkFDQSxNQUFNLFFBQVEsS0FBSyxxQkFDZixRQUFRLEtBQUssQ0FDWCxtRkFDQSw4QkFBOEIsSUFBSSxFQUFFLFFBRXRDLGFBQWEsV0FBVyxTQUN0QixRQUFRLEtBQUssQ0FDWCx5R0FDQSxXQUFXLFFBQ1gsOEJBQThCLElBQUksRUFBRSxRQUV0QyxlQUFlLFNBQ2IsT0FBTyxxQkFBcUIsSUFDNUIsQ0FBQyxBQUFDLGtCQUFrQixPQUFPLHFCQUFxQixDQUFDLFFBQ2pELElBQUksZ0JBQWdCLE1BQU0sSUFDeEIsUUFBUSxLQUFLLENBQ1gscUlBQ0EsZUFBZSxDQUFDLEVBQUUsQ0FBQyxXQUFXLEVBQzlCLDhCQUE4QixJQUFJLEVBQUUsS0FDckMsSUFDSCxRQUFRLEtBQUssQ0FDWCxvSUFDQSw4QkFBOEIsSUFBSSxFQUFFO2dCQUU5QyxPQUFPO1lBQ1Q7WUFDQSxJQUFJLGFBQWEsT0FBTyxPQUFPO2dCQUM3QixJQUFJLFFBQVEsS0FBSyxDQUFDLE1BQU0sTUFBTSxHQUFHLEVBQUUsSUFBSSxJQUFJLENBQUMsSUFBSSxZQUFZLE1BQzFELE9BQU8sT0FBTztnQkFDaEIsTUFBTSxRQUFRLEtBQUssQ0FBQyxFQUFFLEdBQUcsTUFBTSxRQUFRO2dCQUN2QyxPQUFPO1lBQ1Q7WUFDQSxJQUFJLGNBQWMsT0FBTyxPQUFPLE9BQU87WUFDdkMsSUFBSSxhQUFhLE9BQU8sT0FBTyxPQUFPLGdCQUFnQjtZQUN0RCxJQUFJLGdCQUFnQixPQUFPLE9BQU8sT0FBTztZQUN6QyxJQUFJLGVBQWUsT0FBTyxPQUFPO2dCQUMvQixrQkFBa0Isc0JBQXNCLEdBQUcsQ0FBQztnQkFDNUMsSUFBSSxLQUFLLE1BQU0saUJBQ2IsT0FDRSxBQUFDLE1BQU0sS0FBSyxTQUFTLENBQ25CO29CQUFFLElBQUksZ0JBQWdCLEVBQUU7b0JBQUUsT0FBTyxnQkFBZ0IsS0FBSztnQkFBQyxHQUN2RCxnQkFFRixTQUFTLFlBQVksQ0FBQyxXQUFXLElBQUksVUFBVSxHQUM5QyxrQkFBa0IsY0FDbkIsU0FBUyxHQUFHLENBQUMsa0JBQWtCLGlCQUFpQixNQUNoRCxPQUFPLGdCQUFnQixRQUFRLENBQUM7Z0JBRXBDLElBQ0UsS0FBSyxNQUFNLHVCQUNYLENBQUMsTUFBTSxJQUFJLE9BQU8sQ0FBQyxRQUNuQixDQUFDLEFBQUMsa0JBQWtCLGVBQWUsR0FBRyxDQUFDLElBQUksR0FDM0MsS0FBSyxNQUFNLGVBQWUsR0FFMUIsT0FDRSxvQkFBb0IsR0FBRyxDQUFDLGtCQUFrQixNQUFNLEtBQUssUUFBUTtnQkFFakUsTUFBTSxNQUNKO1lBRUo7WUFDQSxJQUFJLGFBQWEsT0FBTyxPQUFPO2dCQUM3QixJQUNFLEtBQUssTUFBTSx1QkFDWCxDQUFDLE1BQU0sSUFBSSxPQUFPLENBQUMsUUFDbkIsQ0FBQyxBQUFDLGtCQUFrQixlQUFlLEdBQUcsQ0FBQyxJQUFJLEdBQzNDLEtBQUssTUFBTSxlQUFlLEdBRTFCLE9BQ0Usb0JBQW9CLEdBQUcsQ0FBQyxrQkFBa0IsTUFBTSxLQUFLLFFBQVE7Z0JBRWpFLE1BQU0sTUFDSixrSUFDRSw4QkFBOEIsSUFBSSxFQUFFO1lBRTFDO1lBQ0EsSUFBSSxhQUFhLE9BQU8sT0FBTyxPQUFPLE9BQU8sTUFBTSxRQUFRLENBQUM7WUFDNUQsTUFBTSxNQUNKLFVBQ0UsT0FBTyxRQUNQO1FBRU47UUFDQSxTQUFTLGVBQWUsS0FBSyxFQUFFLEVBQUU7WUFDL0IsYUFBYSxPQUFPLFNBQ2xCLFNBQVMsU0FDVCxDQUFDLEFBQUMsS0FBSyxNQUFNLEdBQUcsUUFBUSxDQUFDLEtBQ3pCLGVBQWUsR0FBRyxDQUFDLE9BQU8sS0FDMUIsS0FBSyxNQUFNLHVCQUF1QixvQkFBb0IsR0FBRyxDQUFDLElBQUksTUFBTTtZQUN0RSxZQUFZO1lBQ1osT0FBTyxLQUFLLFNBQVMsQ0FBQyxPQUFPO1FBQy9CO1FBQ0EsSUFBSSxhQUFhLEdBQ2YsZUFBZSxHQUNmLFdBQVcsTUFDWCxpQkFBaUIsSUFBSSxXQUNyQixZQUFZLE1BQ1osT0FBTyxlQUFlLE1BQU07UUFDOUIsU0FBUyxXQUNMLFFBQVEsUUFDUixDQUFDLFNBQVMsR0FBRyxDQUFDLGtCQUFrQixLQUFLLE9BQ3JDLE1BQU0sZ0JBQWdCLFFBQVEsU0FBUztRQUMzQyxPQUFPO1lBQ0wsSUFBSSxnQkFDRixDQUFDLEFBQUMsZUFBZSxHQUNqQixTQUFTLFdBQVcsUUFBUSxRQUFRLFFBQVEsU0FBUztRQUN6RDtJQUNGO0lBQ0EsU0FBUyx5QkFDUCxJQUFJLEVBQ0osUUFBUSxFQUNSLFNBQVMsRUFDVCxJQUFJLEVBQ0osR0FBRyxFQUNILGVBQWUsRUFDZixhQUFhO1FBRWIsUUFBUSxDQUFDLE9BQU8sYUFBYTtRQUM3QixJQUFJLGNBQWMsS0FBSyxTQUFTLENBQUM7UUFDakMsS0FBSyxPQUNELENBQUMsQUFBQyxPQUFPLFlBQVksTUFBTSxHQUFHLEdBQzdCLE1BQ0MsVUFDQSxjQUNBLElBQUksTUFBTSxDQUFDLE1BQU0sT0FBTyxJQUFJLE1BQU0sUUFDbEMsNEhBQTZILElBQzlILE1BQ0MsbUdBQ0EsS0FBSyxNQUFNLENBQUMsT0FBTyxLQUNuQixlQUNBLGNBQ0EsUUFDQSxJQUFJLE1BQU0sQ0FBQyxJQUFJLE1BQU0sSUFBSSxNQUFNLEtBQy9CO1FBQ04sU0FBUyxVQUFVLENBQUMsUUFBUSxDQUFDLFdBQVcsWUFBWSxRQUFRO1FBQzVELFlBQ0ksQ0FBQyxBQUFDLE9BQ0EsaUNBQ0EsbUJBQW1CLG1CQUNuQixNQUNBLFVBQVUsWUFDVixPQUNBLHlCQUNELE9BQU8sNEJBQTRCLFNBQVUsSUFDOUMsWUFBWSxDQUFDLE9BQU8scUJBQXFCLFFBQVE7UUFDckQsSUFBSTtZQUNGLE9BQU8sQ0FBQyxHQUFHLElBQUksRUFBRSxLQUFLLGNBQWMsQ0FBQyxLQUFLO1FBQzVDLEVBQUUsT0FBTyxHQUFHO1lBQ1YsT0FBTztRQUNUO0lBQ0Y7SUFDQSxTQUFTLDZCQUE2QixTQUFTLEVBQUUsRUFBRSxFQUFFLEtBQUs7UUFDeEQsc0JBQXNCLEdBQUcsQ0FBQyxjQUN4QixzQkFBc0IsR0FBRyxDQUFDLFdBQVc7WUFDbkMsSUFBSTtZQUNKLGNBQWMsVUFBVSxJQUFJO1lBQzVCLE9BQU87UUFDVDtJQUNKO0lBQ0EsU0FBUywyQkFDUCxRQUFRLEVBQ1IsVUFBVSxFQUNWLGdCQUFnQixFQUNoQixnQkFBZ0I7UUFFaEIsU0FBUztZQUNQLElBQUksT0FBTyxNQUFNLFNBQVMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDO1lBQ3RDLE9BQU8sUUFDSCxnQkFBZ0IsTUFBTSxNQUFNLEdBQzFCLFdBQVcsSUFBSSxNQUFNLEtBQUssQ0FBQyxNQUFNLENBQUMsU0FDbEMsUUFBUSxPQUFPLENBQUMsT0FBTyxJQUFJLENBQUMsU0FBVSxTQUFTO2dCQUM3QyxPQUFPLFdBQVcsSUFBSSxVQUFVLE1BQU0sQ0FBQztZQUN6QyxLQUNGLFdBQVcsSUFBSTtRQUNyQjtRQUNBLElBQUksS0FBSyxTQUFTLEVBQUUsRUFDbEIsUUFBUSxTQUFTLEtBQUssRUFDdEIsV0FBVyxTQUFTLFFBQVE7UUFDOUIsSUFBSSxVQUFVO1lBQ1osbUJBQW1CLFNBQVMsSUFBSSxJQUFJO1lBQ3BDLElBQUksV0FBVyxRQUFRLENBQUMsRUFBRSxFQUN4QixPQUFPLFFBQVEsQ0FBQyxFQUFFO1lBQ3BCLFdBQVcsUUFBUSxDQUFDLEVBQUU7WUFDdEIsV0FBVyxTQUFTLEdBQUcsSUFBSTtZQUMzQixtQkFDRSxRQUFRLG1CQUNKLE9BQ0EsaUJBQWlCLFVBQVU7WUFDakMsU0FBUyx5QkFDUCxrQkFDQSxVQUNBLGtCQUNBLE1BQ0EsVUFDQSxVQUNBO1FBRUo7UUFDQSw2QkFBNkIsUUFBUSxJQUFJO1FBQ3pDLE9BQU87SUFDVDtJQUNBLFNBQVMsbUJBQW1CLEtBQUs7UUFDL0IsUUFBUSxNQUFNLEtBQUs7UUFDbkIsTUFBTSxVQUFVLENBQUMscUNBQ2YsQ0FBQyxRQUFRLE1BQU0sS0FBSyxDQUFDLEdBQUc7UUFDMUIsSUFBSSxhQUFhLE1BQU0sT0FBTyxDQUFDO1FBQy9CLElBQUksQ0FBQyxNQUFNLFlBQVk7WUFDckIsSUFBSSxjQUFjLE1BQU0sT0FBTyxDQUFDLE1BQU0sYUFBYTtZQUNuRCxhQUNFLENBQUMsTUFBTSxjQUNILE1BQU0sS0FBSyxDQUFDLGFBQWEsS0FDekIsTUFBTSxLQUFLLENBQUMsYUFBYSxHQUFHO1FBQ3BDLE9BQU8sYUFBYTtRQUNwQixRQUFRLGNBQWMsSUFBSSxDQUFDO1FBQzNCLElBQ0UsQ0FBQyxTQUNELENBQUMsQUFBQyxRQUFRLDJCQUEyQixJQUFJLENBQUMsYUFBYyxDQUFDLEtBQUssR0FFOUQsT0FBTztRQUNULGFBQWEsS0FBSyxDQUFDLEVBQUUsSUFBSTtRQUN6QixrQkFBa0IsY0FBYyxDQUFDLGFBQWEsRUFBRTtRQUNoRCxjQUFjLEtBQUssQ0FBQyxFQUFFLElBQUksS0FBSyxDQUFDLEVBQUUsSUFBSTtRQUN0QyxrQkFBa0IsZUFBZSxDQUFDLGNBQWMsRUFBRTtRQUNsRCxPQUFPO1lBQ0w7WUFDQTtZQUNBLENBQUMsQ0FBQyxLQUFLLENBQUMsRUFBRSxJQUFJLEtBQUssQ0FBQyxFQUFFO1lBQ3RCLENBQUMsQ0FBQyxLQUFLLENBQUMsRUFBRSxJQUFJLEtBQUssQ0FBQyxFQUFFO1NBQ3ZCO0lBQ0g7SUFDQSxTQUFTLHlCQUF5QixJQUFJO1FBQ3BDLElBQUksUUFBUSxNQUFNLE9BQU87UUFDekIsSUFBSSxlQUFlLE9BQU8sTUFDeEIsT0FBTyxLQUFLLFFBQVEsS0FBSyx5QkFDckIsT0FDQSxLQUFLLFdBQVcsSUFBSSxLQUFLLElBQUksSUFBSTtRQUN2QyxJQUFJLGFBQWEsT0FBTyxNQUFNLE9BQU87UUFDckMsT0FBUTtZQUNOLEtBQUs7Z0JBQ0gsT0FBTztZQUNULEtBQUs7Z0JBQ0gsT0FBTztZQUNULEtBQUs7Z0JBQ0gsT0FBTztZQUNULEtBQUs7Z0JBQ0gsT0FBTztZQUNULEtBQUs7Z0JBQ0gsT0FBTztZQUNULEtBQUs7Z0JBQ0gsT0FBTztRQUNYO1FBQ0EsSUFBSSxhQUFhLE9BQU8sTUFDdEIsT0FDRyxhQUFhLE9BQU8sS0FBSyxHQUFHLElBQzNCLFFBQVEsS0FBSyxDQUNYLHNIQUVKLEtBQUssUUFBUTtZQUViLEtBQUs7Z0JBQ0gsT0FBTztZQUNULEtBQUs7Z0JBQ0gsT0FBTyxLQUFLLFdBQVcsSUFBSTtZQUM3QixLQUFLO2dCQUNILE9BQU8sQ0FBQyxLQUFLLFFBQVEsQ0FBQyxXQUFXLElBQUksU0FBUyxJQUFJO1lBQ3BELEtBQUs7Z0JBQ0gsSUFBSSxZQUFZLEtBQUssTUFBTTtnQkFDM0IsT0FBTyxLQUFLLFdBQVc7Z0JBQ3ZCLFFBQ0UsQ0FBQyxBQUFDLE9BQU8sVUFBVSxXQUFXLElBQUksVUFBVSxJQUFJLElBQUksSUFDbkQsT0FBTyxPQUFPLE9BQU8sZ0JBQWdCLE9BQU8sTUFBTSxZQUFhO2dCQUNsRSxPQUFPO1lBQ1QsS0FBSztnQkFDSCxPQUNFLEFBQUMsWUFBWSxLQUFLLFdBQVcsSUFBSSxNQUNqQyxTQUFTLFlBQ0wsWUFDQSx5QkFBeUIsS0FBSyxJQUFJLEtBQUs7WUFFL0MsS0FBSztnQkFDSCxZQUFZLEtBQUssUUFBUTtnQkFDekIsT0FBTyxLQUFLLEtBQUs7Z0JBQ2pCLElBQUk7b0JBQ0YsT0FBTyx5QkFBeUIsS0FBSztnQkFDdkMsRUFBRSxPQUFPLEdBQUcsQ0FBQztRQUNqQjtRQUNGLE9BQU87SUFDVDtJQUNBLFNBQVMsYUFBYSxNQUFNLEVBQUUsS0FBSyxFQUFFLE1BQU07UUFDekMsSUFBSSxDQUFDLE1BQU0sR0FBRztRQUNkLElBQUksQ0FBQyxLQUFLLEdBQUc7UUFDYixJQUFJLENBQUMsTUFBTSxHQUFHO1FBQ2QsSUFBSSxDQUFDLFVBQVUsR0FBRztJQUNwQjtJQUNBLFNBQVMsbUJBQW1CLFlBQVk7UUFDdEMsZUFBZSxhQUFhLElBQUksQ0FBQyxLQUFLO1FBQ3RDLElBQUksS0FBSyxNQUFNLGNBQ2IsTUFBTSxNQUNKO1FBRUosT0FBTztJQUNUO0lBQ0EsU0FBUyxvQkFBb0IsWUFBWTtRQUN2QyxhQUFhO0lBQ2Y7SUFDQSxTQUFTLFVBQVUsS0FBSztRQUN0QixPQUFRLE1BQU0sTUFBTTtZQUNsQixLQUFLO2dCQUNILHFCQUFxQjtnQkFDckI7WUFDRixLQUFLO2dCQUNILHNCQUFzQjtRQUMxQjtRQUNBLE9BQVEsTUFBTSxNQUFNO1lBQ2xCLEtBQUs7Z0JBQ0gsT0FBTyxNQUFNLEtBQUs7WUFDcEIsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO2dCQUNILE1BQU07WUFDUjtnQkFDRSxNQUFNLE1BQU0sTUFBTTtRQUN0QjtJQUNGO0lBQ0EsU0FBUyxRQUFRLFlBQVk7UUFDM0IsZUFBZSxtQkFBbUI7UUFDbEMsT0FBTyxTQUFTLGNBQWM7SUFDaEM7SUFDQSxTQUFTLG1CQUFtQixRQUFRO1FBQ2xDLE1BQU0sU0FBUyxjQUFjLE1BQzNCLENBQUMsQUFBQyxTQUFTLGFBQWEsQ0FBQyxRQUFRLEdBQUcsVUFDcEMsU0FBUyxTQUFTLHFCQUFxQixJQUNyQyxDQUFDLGFBQWEsU0FBUyxxQkFBcUIsR0FDM0MsU0FBUyxxQkFBcUIsR0FBRyxJQUFLLENBQUM7UUFDNUMsT0FBTyxJQUFJLGFBQWEsV0FBVyxNQUFNO0lBQzNDO0lBQ0EsU0FBUyxvQkFBb0IsUUFBUSxFQUFFLEtBQUs7UUFDMUMsY0FBYyxNQUFNLE1BQU0sSUFDeEIsTUFBTSxFQUFFLFNBQVMsY0FBYyxJQUMvQixDQUFDLEFBQUMsU0FBUyxhQUFhLENBQUMsUUFBUSxHQUFHLE1BQ25DLFNBQVMscUJBQXFCLEdBQUcsV0FDaEMsOEJBQThCLElBQUksQ0FBQyxNQUFNLFdBQ3pDLElBQ0E7SUFDTjtJQUNBLFNBQVMsVUFBVSxTQUFTLEVBQUUsS0FBSztRQUNqQyxJQUFLLElBQUksSUFBSSxHQUFHLElBQUksVUFBVSxNQUFNLEVBQUUsSUFBSztZQUN6QyxJQUFJLFdBQVcsU0FBUyxDQUFDLEVBQUU7WUFDM0IsZUFBZSxPQUFPLFdBQ2xCLFNBQVMsU0FDVCxpQkFBaUIsVUFBVTtRQUNqQztJQUNGO0lBQ0EsU0FBUyxZQUFZLFNBQVMsRUFBRSxLQUFLO1FBQ25DLElBQUssSUFBSSxJQUFJLEdBQUcsSUFBSSxVQUFVLE1BQU0sRUFBRSxJQUFLO1lBQ3pDLElBQUksV0FBVyxTQUFTLENBQUMsRUFBRTtZQUMzQixlQUFlLE9BQU8sV0FDbEIsU0FBUyxTQUNULGdCQUFnQixVQUFVO1FBQ2hDO0lBQ0Y7SUFDQSxTQUFTLG9CQUFvQixhQUFhLEVBQUUsU0FBUztRQUNuRCxJQUFJLGtCQUFrQixVQUFVLE9BQU8sQ0FBQyxLQUFLO1FBQzdDLElBQUksU0FBUyxpQkFBaUIsT0FBTztRQUNyQyxJQUFJLG9CQUFvQixlQUFlLE9BQU8sVUFBVSxPQUFPO1FBQy9ELFlBQVksZ0JBQWdCLEtBQUs7UUFDakMsSUFBSSxTQUFTLFdBQ1gsSUFDRSxrQkFBa0IsR0FDbEIsa0JBQWtCLFVBQVUsTUFBTSxFQUNsQyxrQkFDQTtZQUNBLElBQUksV0FBVyxTQUFTLENBQUMsZ0JBQWdCO1lBQ3pDLElBQ0UsZUFBZSxPQUFPLFlBQ3RCLENBQUMsQUFBQyxXQUFXLG9CQUFvQixlQUFlLFdBQ2hELFNBQVMsUUFBUSxHQUVqQixPQUFPO1FBQ1g7UUFDRixPQUFPO0lBQ1Q7SUFDQSxTQUFTLHVCQUF1QixLQUFLLEVBQUUsZ0JBQWdCLEVBQUUsZUFBZTtRQUN0RSxPQUFRLE1BQU0sTUFBTTtZQUNsQixLQUFLO2dCQUNILFVBQVUsa0JBQWtCLE1BQU0sS0FBSztnQkFDdkM7WUFDRixLQUFLO2dCQUNILElBQUssSUFBSSxJQUFJLEdBQUcsSUFBSSxpQkFBaUIsTUFBTSxFQUFFLElBQUs7b0JBQ2hELElBQUksV0FBVyxnQkFBZ0IsQ0FBQyxFQUFFO29CQUNsQyxJQUFJLGVBQWUsT0FBTyxVQUFVO3dCQUNsQyxJQUFJLGdCQUFnQixvQkFBb0IsT0FBTzt3QkFDL0MsU0FBUyxpQkFDUCxDQUFDLGlCQUFpQixVQUFVLGNBQWMsS0FBSyxHQUMvQyxpQkFBaUIsTUFBTSxDQUFDLEdBQUcsSUFDM0IsS0FDQSxTQUFTLG1CQUNQLENBQUMsQUFBQyxXQUFXLGdCQUFnQixPQUFPLENBQUMsV0FDckMsQ0FBQyxNQUFNLFlBQVksZ0JBQWdCLE1BQU0sQ0FBQyxVQUFVLEVBQUUsQ0FBQztvQkFDN0Q7Z0JBQ0Y7WUFDRixLQUFLO2dCQUNILElBQUksTUFBTSxLQUFLLEVBQ2IsSUFBSyxJQUFJLEdBQUcsSUFBSSxpQkFBaUIsTUFBTSxFQUFFLElBQ3ZDLE1BQU0sS0FBSyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFO3FCQUNuQyxNQUFNLEtBQUssR0FBRztnQkFDbkIsSUFBSSxNQUFNLE1BQU0sRUFBRTtvQkFDaEIsSUFBSSxpQkFDRixJQUNFLG1CQUFtQixHQUNuQixtQkFBbUIsZ0JBQWdCLE1BQU0sRUFDekMsbUJBRUEsTUFBTSxNQUFNLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxpQkFBaUI7Z0JBQ3pELE9BQU8sTUFBTSxNQUFNLEdBQUc7Z0JBQ3RCO1lBQ0YsS0FBSztnQkFDSCxtQkFBbUIsWUFBWSxpQkFBaUIsTUFBTSxNQUFNO1FBQ2hFO0lBQ0Y7SUFDQSxTQUFTLG9CQUFvQixRQUFRLEVBQUUsS0FBSyxFQUFFLEtBQUs7UUFDakQsY0FBYyxNQUFNLE1BQU0sSUFBSSxjQUFjLE1BQU0sTUFBTSxHQUNwRCxNQUFNLE1BQU0sQ0FBQyxLQUFLLENBQUMsU0FDbkIsQ0FBQyxvQkFBb0IsVUFBVSxRQUM5QixXQUFXLE1BQU0sTUFBTSxFQUN2QixNQUFNLE1BQU0sR0FBRyxZQUNmLE1BQU0sTUFBTSxHQUFHLE9BQ2hCLFNBQVMsWUFBWSxZQUFZLFVBQVUsTUFBTTtJQUN2RDtJQUNBLFNBQVMsa0NBQWtDLFFBQVEsRUFBRSxLQUFLLEVBQUUsSUFBSTtRQUM5RCxPQUFPLElBQUksYUFDVCxrQkFDQSxDQUFDLE9BQU8sMEJBQTBCLHdCQUF3QixJQUN4RCxRQUNBLEtBQ0Y7SUFFSjtJQUNBLFNBQVMsMkJBQTJCLFFBQVEsRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLElBQUk7UUFDOUQsa0JBQ0UsVUFDQSxPQUNBLENBQUMsT0FBTywwQkFBMEIsd0JBQXdCLElBQ3hELFFBQ0E7SUFFTjtJQUNBLFNBQVMsa0JBQWtCLFFBQVEsRUFBRSxLQUFLLEVBQUUsS0FBSztRQUMvQyxJQUFJLGNBQWMsTUFBTSxNQUFNLEVBQUUsTUFBTSxNQUFNLENBQUMsWUFBWSxDQUFDO2FBQ3JEO1lBQ0gsb0JBQW9CLFVBQVU7WUFDOUIsSUFBSSxtQkFBbUIsTUFBTSxLQUFLLEVBQ2hDLGtCQUFrQixNQUFNLE1BQU07WUFDaEMsTUFBTSxNQUFNLEdBQUc7WUFDZixNQUFNLEtBQUssR0FBRztZQUNkLE1BQU0sTUFBTSxHQUFHO1lBQ2YsU0FBUyxvQkFDUCxDQUFDLHFCQUFxQixRQUN0Qix1QkFBdUIsT0FBTyxrQkFBa0IsZ0JBQWdCO1FBQ3BFO0lBQ0Y7SUFDQSxTQUFTLG1CQUFtQixRQUFRLEVBQUUsS0FBSyxFQUFFLEtBQUs7UUFDaEQsSUFBSSxjQUFjLE1BQU0sTUFBTSxJQUFJLGNBQWMsTUFBTSxNQUFNLEVBQUU7WUFDNUQsb0JBQW9CLFVBQVU7WUFDOUIsV0FBVyxNQUFNLEtBQUs7WUFDdEIsSUFBSSxrQkFBa0IsTUFBTSxNQUFNO1lBQ2xDLE1BQU0sTUFBTSxHQUFHO1lBQ2YsTUFBTSxLQUFLLEdBQUc7WUFDZCxTQUFTLFlBQ1AsQ0FBQyxzQkFBc0IsUUFDdkIsdUJBQXVCLE9BQU8sVUFBVSxnQkFBZ0I7UUFDNUQ7SUFDRjtJQUNBLFNBQVMscUJBQXFCLEtBQUs7UUFDakMsSUFBSSxjQUFjO1FBQ2xCLHNCQUFzQjtRQUN0QixJQUFJLGdCQUFnQixNQUFNLEtBQUssRUFDN0IsV0FBVyxNQUFNLE1BQU07UUFDekIsTUFBTSxNQUFNLEdBQUc7UUFDZixNQUFNLEtBQUssR0FBRztRQUNkLE1BQU0sTUFBTSxHQUFHO1FBQ2YsSUFBSTtZQUNGLElBQUksUUFBUSxLQUFLLEtBQUssQ0FBQyxlQUFlLFNBQVMsU0FBUyxHQUN0RCxtQkFBbUIsTUFBTSxLQUFLO1lBQ2hDLFNBQVMsb0JBQ1AsQ0FBQyxBQUFDLE1BQU0sS0FBSyxHQUFHLE1BQ2YsTUFBTSxNQUFNLEdBQUcsTUFDaEIsVUFBVSxrQkFBa0IsTUFBTTtZQUNwQyxJQUFJLFNBQVMscUJBQXFCO2dCQUNoQyxJQUFJLG9CQUFvQixPQUFPLEVBQUUsTUFBTSxvQkFBb0IsS0FBSztnQkFDaEUsSUFBSSxJQUFJLG9CQUFvQixJQUFJLEVBQUU7b0JBQ2hDLG9CQUFvQixLQUFLLEdBQUc7b0JBQzVCLG9CQUFvQixLQUFLLEdBQUc7b0JBQzVCO2dCQUNGO1lBQ0Y7WUFDQSxNQUFNLE1BQU0sR0FBRztZQUNmLE1BQU0sS0FBSyxHQUFHO1FBQ2hCLEVBQUUsT0FBTyxPQUFPO1lBQ2IsTUFBTSxNQUFNLEdBQUcsWUFBYyxNQUFNLE1BQU0sR0FBRztRQUMvQyxTQUFVO1lBQ1Isc0JBQXNCO1FBQ3hCO0lBQ0Y7SUFDQSxTQUFTLHNCQUFzQixLQUFLO1FBQ2xDLElBQUk7WUFDRixJQUFJLFFBQVEsY0FBYyxNQUFNLEtBQUs7WUFDckMsTUFBTSxNQUFNLEdBQUc7WUFDZixNQUFNLEtBQUssR0FBRztRQUNoQixFQUFFLE9BQU8sT0FBTztZQUNiLE1BQU0sTUFBTSxHQUFHLFlBQWMsTUFBTSxNQUFNLEdBQUc7UUFDL0M7SUFDRjtJQUNBLFNBQVMsa0JBQWtCLFlBQVksRUFBRSxLQUFLO1FBQzVDLElBQUksS0FBSyxNQUFNLGFBQWEsSUFBSSxDQUFDLEtBQUssSUFBSTtZQUN4QyxJQUFJLFdBQVcsbUJBQW1CO1lBQ2xDLFNBQVMsT0FBTyxHQUFHLENBQUM7WUFDcEIsU0FBUyxhQUFhLEdBQUc7WUFDekIsU0FBUyxPQUFPLENBQUMsT0FBTyxDQUFDLFNBQVUsS0FBSztnQkFDdEMsY0FBYyxNQUFNLE1BQU0sSUFDeEIsb0JBQW9CLFVBQVUsT0FBTztZQUN6QztZQUNBLGVBQWUsU0FBUyxhQUFhO1lBQ3JDLEtBQUssTUFBTSxnQkFDVCxDQUFDLGFBQWEsS0FBTSxTQUFTLGFBQWEsR0FBRyxLQUFLLENBQUU7UUFDeEQ7SUFDRjtJQUNBLFNBQVM7UUFDUCxPQUFPO0lBQ1Q7SUFDQSxTQUFTLFlBQVksSUFBSTtRQUN2QixJQUFJLFNBQVMscUJBQXFCLE9BQU87UUFDekMsSUFBSSxlQUFlLE9BQU8sTUFBTSxPQUFPO1FBQ3ZDLElBQ0UsYUFBYSxPQUFPLFFBQ3BCLFNBQVMsUUFDVCxLQUFLLFFBQVEsS0FBSyxpQkFFbEIsT0FBTyxLQUFLLEtBQUssS0FBSyxZQUFZLGlCQUFpQjtRQUNyRCxJQUFJO1lBQ0YsSUFBSSxPQUFPLHlCQUF5QjtZQUNwQyxPQUFPLE9BQU8sTUFBTSxPQUFPLE1BQU07UUFDbkMsRUFBRSxPQUFPLEdBQUc7WUFDVixPQUFPO1FBQ1Q7SUFDRjtJQUNBLFNBQVMsa0JBQWtCLFFBQVEsRUFBRSxPQUFPO1FBQzFDLElBQUksUUFBUSxRQUFRLFdBQVcsRUFDN0IsUUFBUSxRQUFRLE1BQU07UUFDeEIsU0FBUyxTQUFTLENBQUMsUUFBUSxNQUFNLEdBQUcsU0FBUyxlQUFlO1FBQzVELElBQUksTUFBTSxTQUFTLG9CQUFvQjtRQUN2QyxTQUFTLFNBQVMsUUFBUSxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sTUFBTSxHQUFHO1FBQ3ZELElBQUksdUJBQXVCO1FBQzNCLFNBQVMsU0FBUyxRQUFRLFNBQVMsZUFBZSxHQUM3Qyx1QkFBdUIsU0FBUyxlQUFlLEdBQ2hELFNBQVMsU0FDVCxDQUFDLHVCQUF1Qiw0QkFDdEIsVUFDQSxPQUNBLElBQ0Q7UUFDTCxRQUFRLFdBQVcsR0FBRztRQUN0Qix1QkFBdUI7UUFDdkIsc0JBQ0UsU0FBUyxTQUNULENBQUMsQUFBQyx1QkFBdUIsUUFBUSxVQUFVLENBQUMsSUFBSSxDQUM5QyxTQUNBLFlBQVksUUFBUSxJQUFJLElBRXpCLFFBQVEsbUJBQ1AsVUFDQSxPQUNBLEtBQ0EsQ0FBQyxHQUNELHVCQUVELE1BQU0sU0FBUyxRQUFRLE9BQU8sbUJBQW1CLFVBQVUsUUFDNUQsU0FBUyxNQUNMLENBQUMsQUFBQyxNQUFNLFNBQVMsY0FBYyxFQUM5Qix1QkFBdUIsUUFBUSxNQUFNLElBQUksR0FBRyxDQUFDLFNBQVMsT0FBUSxJQUM5RCx1QkFBdUIsSUFBSSxHQUFHLENBQUMsTUFBTztRQUM3QyxRQUFRLFVBQVUsR0FBRztRQUNyQixTQUFTLFNBQVMsb0JBQW9CLFVBQVU7UUFDaEQsT0FBTyxNQUFNLENBQUMsUUFBUSxLQUFLO0lBQzdCO0lBQ0EsU0FBUyx1QkFBdUIsS0FBSztRQUNuQyxJQUFJLFdBQVc7WUFDYixVQUFVO1lBQ1YsVUFBVTtZQUNWLE9BQU87UUFDVDtRQUNBLFFBQVEsTUFBTSxVQUFVLElBQUksQ0FBQyxNQUFNLFVBQVUsR0FBRyxFQUFFO1FBQ2xELFNBQVMsVUFBVSxHQUFHO1FBQ3RCLE9BQU87SUFDVDtJQUNBLFNBQVMsU0FBUyxRQUFRLEVBQUUsRUFBRTtRQUM1QixJQUFJLFNBQVMsU0FBUyxPQUFPLEVBQzNCLFFBQVEsT0FBTyxHQUFHLENBQUM7UUFDckIsU0FDRSxDQUFDLEFBQUMsUUFBUSxTQUFTLE9BQU8sR0FDdEIsSUFBSSxhQUFhLFlBQVksTUFBTSxTQUFTLGFBQWEsSUFDekQsbUJBQW1CLFdBQ3ZCLE9BQU8sR0FBRyxDQUFDLElBQUksTUFBTTtRQUN2QixPQUFPO0lBQ1Q7SUFDQSxTQUFTLGlCQUFpQixTQUFTLEVBQUUsS0FBSztRQUN4QyxJQUNFLElBQUksV0FBVyxVQUFVLFFBQVEsRUFDL0IsVUFBVSxVQUFVLE9BQU8sRUFDM0IsZUFBZSxVQUFVLFlBQVksRUFDckMsTUFBTSxVQUFVLEdBQUcsRUFDbkIsTUFBTSxVQUFVLEdBQUcsRUFDbkIsT0FBTyxVQUFVLElBQUksRUFDckIsSUFBSSxHQUNOLElBQUksS0FBSyxNQUFNLEVBQ2YsSUFDQTtZQUNBLE1BQU8sTUFBTSxRQUFRLEtBQUssaUJBQ3hCLElBQUssQUFBQyxRQUFRLE1BQU0sUUFBUSxFQUFHLFVBQVUsUUFBUSxLQUFLLEVBQ3BELFFBQVEsUUFBUSxLQUFLO2lCQUNsQjtnQkFDSCxPQUFRLE1BQU0sTUFBTTtvQkFDbEIsS0FBSzt3QkFDSCxxQkFBcUI7d0JBQ3JCO29CQUNGLEtBQUs7d0JBQ0gsc0JBQXNCO2dCQUMxQjtnQkFDQSxPQUFRLE1BQU0sTUFBTTtvQkFDbEIsS0FBSzt3QkFDSCxRQUFRLE1BQU0sS0FBSzt3QkFDbkI7b0JBQ0YsS0FBSzt3QkFDSCxJQUFJLGdCQUFnQixvQkFBb0IsT0FBTzt3QkFDL0MsSUFBSSxTQUFTLGVBQWU7NEJBQzFCLFFBQVEsY0FBYyxLQUFLOzRCQUMzQjt3QkFDRjtvQkFDRixLQUFLO3dCQUNILEtBQUssTUFBTSxDQUFDLEdBQUcsSUFBSTt3QkFDbkIsU0FBUyxNQUFNLEtBQUssR0FDZixNQUFNLEtBQUssR0FBRzs0QkFBQzt5QkFBVSxHQUMxQixNQUFNLEtBQUssQ0FBQyxJQUFJLENBQUM7d0JBQ3JCLFNBQVMsTUFBTSxNQUFNLEdBQ2hCLE1BQU0sTUFBTSxHQUFHOzRCQUFDO3lCQUFVLEdBQzNCLE1BQU0sTUFBTSxDQUFDLElBQUksQ0FBQzt3QkFDdEI7b0JBQ0YsS0FBSzt3QkFDSDtvQkFDRjt3QkFDRSxnQkFBZ0IsV0FBVyxNQUFNLE1BQU07d0JBQ3ZDO2dCQUNKO1lBQ0Y7WUFDRixRQUFRLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDO1FBQ3hCO1FBQ0EsWUFBWSxJQUFJLFVBQVUsT0FBTyxjQUFjO1FBQy9DLFlBQVksQ0FBQyxJQUFJLEdBQUc7UUFDcEIsT0FBTyxPQUFPLFNBQVMsUUFBUSxLQUFLLElBQUksQ0FBQyxRQUFRLEtBQUssR0FBRyxTQUFTO1FBQ2xFLElBQ0UsWUFBWSxDQUFDLEVBQUUsS0FBSyxzQkFDcEIsYUFBYSxPQUFPLFFBQVEsS0FBSyxJQUNqQyxTQUFTLFFBQVEsS0FBSyxJQUN0QixRQUFRLEtBQUssQ0FBQyxRQUFRLEtBQUssb0JBRTNCLE9BQVMsQUFBQyxlQUFlLFFBQVEsS0FBSyxFQUFHO1lBQ3ZDLEtBQUs7Z0JBQ0gsYUFBYSxLQUFLLEdBQUc7Z0JBQ3JCO1lBQ0YsS0FBSztnQkFDSCxhQUFhLE1BQU0sR0FBRztnQkFDdEI7WUFDRixLQUFLO2dCQUNILGFBQWEsV0FBVyxHQUFHO1FBQy9CO1FBQ0YsUUFBUSxJQUFJO1FBQ1osTUFBTSxRQUFRLElBQUksSUFDaEIsQ0FBQyxBQUFDLE1BQU0sUUFBUSxLQUFLLEVBQ3JCLFNBQVMsT0FDUCxjQUFjLElBQUksTUFBTSxJQUN4QixDQUFDLEFBQUMsZUFBZSxJQUFJLEtBQUssRUFDekIsSUFBSSxNQUFNLEdBQUcsYUFDYixJQUFJLEtBQUssR0FBRyxRQUFRLEtBQUssRUFDMUIsU0FBUyxnQkFBZ0IsVUFBVSxjQUFjLFFBQVEsS0FBSyxDQUFDLENBQUM7SUFDdEU7SUFDQSxTQUFTLGdCQUFnQixTQUFTLEVBQUUsS0FBSztRQUN2QyxJQUFJLFVBQVUsVUFBVSxPQUFPO1FBQy9CLFlBQVksVUFBVSxRQUFRO1FBQzlCLElBQUksQ0FBQyxRQUFRLE9BQU8sRUFBRTtZQUNwQixJQUFJLGVBQWUsUUFBUSxLQUFLO1lBQ2hDLFFBQVEsT0FBTyxHQUFHLENBQUM7WUFDbkIsUUFBUSxLQUFLLEdBQUc7WUFDaEIsVUFBVSxRQUFRLEtBQUs7WUFDdkIsSUFBSSxTQUFTLFdBQVcsY0FBYyxRQUFRLE1BQU0sRUFBRTtnQkFDcEQsSUFDRSxhQUFhLE9BQU8sZ0JBQ3BCLFNBQVMsZ0JBQ1QsYUFBYSxRQUFRLEtBQUssb0JBQzFCO29CQUNBLElBQUksbUJBQW1CO3dCQUNyQixNQUFNLHlCQUF5QixhQUFhLElBQUksS0FBSzt3QkFDckQsT0FBTyxhQUFhLE1BQU07b0JBQzVCO29CQUNBLGlCQUFpQixVQUFVLEdBQUcsYUFBYSxXQUFXO29CQUN0RCxzQkFDRSxDQUFDLGlCQUFpQixTQUFTLEdBQUcsYUFBYSxVQUFVO29CQUN2RCxDQUFDLFFBQVEsVUFBVSxJQUFJLENBQUMsUUFBUSxVQUFVLEdBQUcsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUNwRDtnQkFFSjtnQkFDQSxvQkFBb0IsV0FBVyxTQUFTO1lBQzFDO1FBQ0Y7SUFDRjtJQUNBLFNBQVMsaUJBQ1AsZUFBZSxFQUNmLFlBQVksRUFDWixHQUFHLEVBQ0gsUUFBUSxFQUNSLEdBQUcsRUFDSCxJQUFJO1FBRUosSUFBSSxxQkFBcUI7WUFDdkIsSUFBSSxVQUFVO1lBQ2QsUUFBUSxJQUFJO1FBQ2QsT0FDRSxVQUFVLHNCQUFzQjtZQUM5QixRQUFRO1lBQ1IsT0FBTztZQUNQLE9BQU87WUFDUCxNQUFNO1lBQ04sU0FBUyxDQUFDO1FBQ1o7UUFDRixlQUFlO1lBQ2IsVUFBVTtZQUNWLFNBQVM7WUFDVCxjQUFjO1lBQ2QsS0FBSztZQUNMLEtBQUs7WUFDTCxNQUFNO1FBQ1I7UUFDQSxTQUFTLGdCQUFnQixLQUFLLEdBQ3pCLGdCQUFnQixLQUFLLEdBQUc7WUFBQztTQUFhLEdBQ3ZDLGdCQUFnQixLQUFLLENBQUMsSUFBSSxDQUFDO1FBQy9CLFNBQVMsZ0JBQWdCLE1BQU0sR0FDMUIsZ0JBQWdCLE1BQU0sR0FBRztZQUFDO1NBQWEsR0FDeEMsZ0JBQWdCLE1BQU0sQ0FBQyxJQUFJLENBQUM7UUFDaEMsT0FBTztJQUNUO0lBQ0EsU0FBUyxvQkFBb0IsUUFBUSxFQUFFLFFBQVEsRUFBRSxZQUFZLEVBQUUsR0FBRztRQUNoRSxJQUFJLENBQUMsU0FBUyxzQkFBc0IsRUFDbEMsT0FBTywyQkFDTCxVQUNBLFNBQVMsV0FBVyxFQUNwQixTQUFTLGlCQUFpQixFQUMxQixTQUFTLHNCQUFzQjtRQUVuQyxJQUFJLGtCQUFrQix1QkFDbEIsU0FBUyxzQkFBc0IsRUFDL0IsU0FBUyxFQUFFLEdBRWIsVUFBVSxjQUFjO1FBQzFCLElBQUksU0FDRixTQUFTLEtBQUssSUFBSSxDQUFDLFVBQVUsUUFBUSxHQUFHLENBQUM7WUFBQztZQUFTLFNBQVMsS0FBSztTQUFDLENBQUM7YUFDaEUsSUFBSSxTQUFTLEtBQUssRUFBRSxVQUFVLFFBQVEsT0FBTyxDQUFDLFNBQVMsS0FBSzthQUUvRCxPQUNFLEFBQUMsVUFBVSxjQUFjLGtCQUN6Qiw2QkFBNkIsU0FBUyxTQUFTLEVBQUUsRUFBRSxTQUFTLEtBQUssR0FDakU7UUFFSixJQUFJLHFCQUFxQjtZQUN2QixJQUFJLFVBQVU7WUFDZCxRQUFRLElBQUk7UUFDZCxPQUNFLFVBQVUsc0JBQXNCO1lBQzlCLFFBQVE7WUFDUixPQUFPO1lBQ1AsT0FBTztZQUNQLE1BQU07WUFDTixTQUFTLENBQUM7UUFDWjtRQUNGLFFBQVEsSUFBSSxDQUNWO1lBQ0UsSUFBSSxnQkFBZ0IsY0FBYztZQUNsQyxJQUFJLFNBQVMsS0FBSyxFQUFFO2dCQUNsQixJQUFJLFlBQVksU0FBUyxLQUFLLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQztnQkFDM0MsVUFBVSxPQUFPLENBQUM7Z0JBQ2xCLGdCQUFnQixjQUFjLElBQUksQ0FBQyxLQUFLLENBQUMsZUFBZTtZQUMxRDtZQUNBLDZCQUNFLGVBQ0EsU0FBUyxFQUFFLEVBQ1gsU0FBUyxLQUFLO1lBRWhCLFlBQVksQ0FBQyxJQUFJLEdBQUc7WUFDcEIsT0FBTyxPQUNMLFNBQVMsUUFBUSxLQUFLLElBQ3RCLENBQUMsUUFBUSxLQUFLLEdBQUcsYUFBYTtZQUNoQyxJQUNFLFlBQVksQ0FBQyxFQUFFLEtBQUssc0JBQ3BCLGFBQWEsT0FBTyxRQUFRLEtBQUssSUFDakMsU0FBUyxRQUFRLEtBQUssSUFDdEIsUUFBUSxLQUFLLENBQUMsUUFBUSxLQUFLLG9CQUUzQixPQUFTLEFBQUMsWUFBWSxRQUFRLEtBQUssRUFBRztnQkFDcEMsS0FBSztvQkFDSCxVQUFVLEtBQUssR0FBRztvQkFDbEI7Z0JBQ0YsS0FBSztvQkFDSCxVQUFVLE1BQU0sR0FBRztZQUN2QjtZQUNGLFFBQVEsSUFBSTtZQUNaLE1BQU0sUUFBUSxJQUFJLElBQ2hCLENBQUMsQUFBQyxnQkFBZ0IsUUFBUSxLQUFLLEVBQy9CLFNBQVMsaUJBQ1AsY0FBYyxjQUFjLE1BQU0sSUFDbEMsQ0FBQyxBQUFDLFlBQVksY0FBYyxLQUFLLEVBQ2hDLGNBQWMsTUFBTSxHQUFHLGFBQ3ZCLGNBQWMsS0FBSyxHQUFHLFFBQVEsS0FBSyxFQUNwQyxTQUFTLGFBQWEsVUFBVSxXQUFXLFFBQVEsS0FBSyxDQUFDLENBQUM7UUFDaEUsR0FDQSxTQUFVLEtBQUs7WUFDYixJQUFJLENBQUMsUUFBUSxPQUFPLEVBQUU7Z0JBQ3BCLElBQUksZUFBZSxRQUFRLEtBQUs7Z0JBQ2hDLFFBQVEsT0FBTyxHQUFHLENBQUM7Z0JBQ25CLFFBQVEsS0FBSyxHQUFHO2dCQUNoQixJQUFJLFFBQVEsUUFBUSxLQUFLO2dCQUN6QixJQUFJLFNBQVMsU0FBUyxjQUFjLE1BQU0sTUFBTSxFQUFFO29CQUNoRCxJQUNFLGFBQWEsT0FBTyxnQkFDcEIsU0FBUyxnQkFDVCxhQUFhLFFBQVEsS0FBSyxvQkFDMUI7d0JBQ0EsSUFBSSxtQkFBbUI7NEJBQ3JCLE1BQU0seUJBQXlCLGFBQWEsSUFBSSxLQUFLOzRCQUNyRCxPQUFPLGFBQWEsTUFBTTt3QkFDNUI7d0JBQ0EsaUJBQWlCLFVBQVUsR0FBRyxhQUFhLFdBQVc7d0JBQ3RELHNCQUNFLENBQUMsaUJBQWlCLFNBQVMsR0FBRyxhQUFhLFVBQVU7d0JBQ3ZELENBQUMsTUFBTSxVQUFVLElBQUksQ0FBQyxNQUFNLFVBQVUsR0FBRyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQ2hEO29CQUVKO29CQUNBLG9CQUFvQixVQUFVLE9BQU87Z0JBQ3ZDO1lBQ0Y7UUFDRjtRQUVGLE9BQU87SUFDVDtJQUNBLFNBQVMsaUJBQWlCLFFBQVEsRUFBRSxTQUFTLEVBQUUsWUFBWSxFQUFFLEdBQUcsRUFBRSxHQUFHO1FBQ25FLFlBQVksVUFBVSxLQUFLLENBQUM7UUFDNUIsSUFBSSxLQUFLLFNBQVMsU0FBUyxDQUFDLEVBQUUsRUFBRTtRQUNoQyxLQUFLLFNBQVMsVUFBVTtRQUN4QixPQUFRLEdBQUcsTUFBTTtZQUNmLEtBQUs7Z0JBQ0gscUJBQXFCO2dCQUNyQjtZQUNGLEtBQUs7Z0JBQ0gsc0JBQXNCO1FBQzFCO1FBQ0EsT0FBUSxHQUFHLE1BQU07WUFDZixLQUFLO2dCQUNILElBQUssSUFBSSxRQUFRLEdBQUcsS0FBSyxFQUFFLElBQUksR0FBRyxJQUFJLFVBQVUsTUFBTSxFQUFFLElBQUs7b0JBQzNELE1BQU8sTUFBTSxRQUFRLEtBQUssaUJBQW1CO3dCQUMzQyxRQUFRLE1BQU0sUUFBUTt3QkFDdEIsT0FBUSxNQUFNLE1BQU07NEJBQ2xCLEtBQUs7Z0NBQ0gscUJBQXFCO2dDQUNyQjs0QkFDRixLQUFLO2dDQUNILHNCQUFzQjt3QkFDMUI7d0JBQ0EsT0FBUSxNQUFNLE1BQU07NEJBQ2xCLEtBQUs7Z0NBQ0gsUUFBUSxNQUFNLEtBQUs7Z0NBQ25COzRCQUNGLEtBQUs7NEJBQ0wsS0FBSztnQ0FDSCxPQUFPLGlCQUNMLE9BQ0EsY0FDQSxLQUNBLFVBQ0EsS0FDQSxVQUFVLEtBQUssQ0FBQyxJQUFJOzRCQUV4QixLQUFLO2dDQUNILE9BQ0Usc0JBQ0ksQ0FBQyxBQUFDLFdBQVcscUJBQXNCLFNBQVMsSUFBSSxFQUFFLElBQ2pELHNCQUFzQjtvQ0FDckIsUUFBUTtvQ0FDUixPQUFPO29DQUNQLE9BQU87b0NBQ1AsTUFBTTtvQ0FDTixTQUFTLENBQUM7Z0NBQ1osR0FDSjs0QkFFSjtnQ0FDRSxPQUNFLHNCQUNJLENBQUMsQUFBQyxvQkFBb0IsT0FBTyxHQUFHLENBQUMsR0FDaEMsb0JBQW9CLEtBQUssR0FBRyxNQUFNLE1BQU0sQUFBQyxJQUN6QyxzQkFBc0I7b0NBQ3JCLFFBQVE7b0NBQ1IsT0FBTztvQ0FDUCxPQUFPLE1BQU0sTUFBTTtvQ0FDbkIsTUFBTTtvQ0FDTixTQUFTLENBQUM7Z0NBQ1osR0FDSjt3QkFFTjtvQkFDRjtvQkFDQSxRQUFRLEtBQUssQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDO2dCQUM3QjtnQkFDQSxXQUFXLElBQUksVUFBVSxPQUFPLGNBQWM7Z0JBQzlDLEdBQUcsVUFBVSxJQUNYLENBQUMsYUFBYSxPQUFPLFlBQ25CLFNBQVMsWUFDUixDQUFDLFlBQVksYUFDWixlQUFlLE9BQU8sUUFBUSxDQUFDLGVBQWUsSUFDOUMsU0FBUyxRQUFRLEtBQUssc0JBQ3hCLFNBQVMsVUFBVSxJQUNuQixPQUFPLGNBQWMsQ0FBQyxVQUFVLGNBQWM7b0JBQzVDLGNBQWMsQ0FBQztvQkFDZixZQUFZLENBQUM7b0JBQ2IsVUFBVSxDQUFDO29CQUNYLE9BQU8sR0FBRyxVQUFVO2dCQUN0QixFQUFFO2dCQUNOLE9BQU87WUFDVCxLQUFLO1lBQ0wsS0FBSztnQkFDSCxPQUFPLGlCQUNMLElBQ0EsY0FDQSxLQUNBLFVBQ0EsS0FDQTtZQUVKLEtBQUs7Z0JBQ0gsT0FDRSxzQkFDSSxDQUFDLEFBQUMsV0FBVyxxQkFBc0IsU0FBUyxJQUFJLEVBQUUsSUFDakQsc0JBQXNCO29CQUNyQixRQUFRO29CQUNSLE9BQU87b0JBQ1AsT0FBTztvQkFDUCxNQUFNO29CQUNOLFNBQVMsQ0FBQztnQkFDWixHQUNKO1lBRUo7Z0JBQ0UsT0FDRSxzQkFDSSxDQUFDLEFBQUMsb0JBQW9CLE9BQU8sR0FBRyxDQUFDLEdBQ2hDLG9CQUFvQixLQUFLLEdBQUcsR0FBRyxNQUFNLEFBQUMsSUFDdEMsc0JBQXNCO29CQUNyQixRQUFRO29CQUNSLE9BQU87b0JBQ1AsT0FBTyxHQUFHLE1BQU07b0JBQ2hCLE1BQU07b0JBQ04sU0FBUyxDQUFDO2dCQUNaLEdBQ0o7UUFFTjtJQUNGO0lBQ0EsU0FBUyxVQUFVLFFBQVEsRUFBRSxLQUFLO1FBQ2hDLE9BQU8sSUFBSSxJQUFJO0lBQ2pCO0lBQ0EsU0FBUyxVQUFVLFFBQVEsRUFBRSxLQUFLO1FBQ2hDLE9BQU8sSUFBSSxJQUFJO0lBQ2pCO0lBQ0EsU0FBUyxXQUFXLFFBQVEsRUFBRSxLQUFLO1FBQ2pDLE9BQU8sSUFBSSxLQUFLLE1BQU0sS0FBSyxDQUFDLElBQUk7WUFBRSxNQUFNLEtBQUssQ0FBQyxFQUFFO1FBQUM7SUFDbkQ7SUFDQSxTQUFTLGVBQWUsUUFBUSxFQUFFLEtBQUs7UUFDckMsV0FBVyxJQUFJO1FBQ2YsSUFBSyxJQUFJLElBQUksR0FBRyxJQUFJLE1BQU0sTUFBTSxFQUFFLElBQ2hDLFNBQVMsTUFBTSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLEtBQUssQ0FBQyxFQUFFLENBQUMsRUFBRTtRQUMxQyxPQUFPO0lBQ1Q7SUFDQSxTQUFTLGlCQUFpQixRQUFRLEVBQUUsS0FBSyxFQUFFLFlBQVk7UUFDckQsT0FBTyxjQUFjLENBQUMsY0FBYyxNQUFNLFNBQVM7SUFDckQ7SUFDQSxTQUFTLGlCQUFpQixRQUFRLEVBQUUsS0FBSyxFQUFFLFlBQVksRUFBRSxHQUFHO1FBQzFELE9BQU8sY0FBYyxDQUFDLGNBQWMsS0FBSztZQUN2QyxLQUFLO2dCQUNILHFCQUFxQixNQUFNLE1BQU0sSUFBSSxxQkFBcUI7Z0JBQzFELE9BQVEsTUFBTSxNQUFNO29CQUNsQixLQUFLO3dCQUNILE9BQU8sTUFBTSxLQUFLO29CQUNwQixLQUFLO3dCQUNILE1BQU0sTUFBTSxNQUFNO2dCQUN0QjtnQkFDQSxPQUFPO1lBQ1Q7WUFDQSxZQUFZLENBQUM7WUFDYixjQUFjLENBQUM7UUFDakI7UUFDQSxPQUFPO0lBQ1Q7SUFDQSxTQUFTLGdCQUFnQixRQUFRLEVBQUUsS0FBSztRQUN0QyxPQUFPLEtBQUssQ0FBQyxPQUFPLFFBQVEsQ0FBQztJQUMvQjtJQUNBLFNBQVMsWUFBWSxRQUFRLEVBQUUsS0FBSztRQUNsQyxPQUFPO0lBQ1Q7SUFDQSxTQUFTLGlCQUFpQixRQUFRLEVBQUUsWUFBWSxFQUFFLEdBQUcsRUFBRSxLQUFLO1FBQzFELElBQUksUUFBUSxLQUFLLENBQUMsRUFBRSxFQUFFO1lBQ3BCLElBQUksUUFBUSxPQUNWLE9BQ0UsU0FBUyx1QkFDUCxRQUFRLE9BQ1IsQ0FBQyxzQkFBc0I7Z0JBQ3JCLFFBQVE7Z0JBQ1IsT0FBTztnQkFDUCxPQUFPO2dCQUNQLE1BQU07Z0JBQ04sU0FBUyxDQUFDO1lBQ1osQ0FBQyxHQUNIO1lBRUosT0FBUSxLQUFLLENBQUMsRUFBRTtnQkFDZCxLQUFLO29CQUNILE9BQU8sTUFBTSxLQUFLLENBQUM7Z0JBQ3JCLEtBQUs7b0JBQ0gsT0FDRSxBQUFDLGVBQWUsU0FBUyxNQUFNLEtBQUssQ0FBQyxJQUFJLEtBQ3hDLFdBQVcsU0FBUyxVQUFVLGVBQy9CLHVCQUF1QjtnQkFFM0IsS0FBSztvQkFDSCxPQUNFLEFBQUMsZUFBZSxTQUFTLE1BQU0sS0FBSyxDQUFDLElBQUksS0FDekMsU0FBUyxVQUFVO2dCQUV2QixLQUFLO29CQUNILE9BQU8sT0FBTyxHQUFHLENBQUMsTUFBTSxLQUFLLENBQUM7Z0JBQ2hDLEtBQUs7b0JBQ0gsSUFBSSxNQUFNLE1BQU0sS0FBSyxDQUFDO29CQUN0QixPQUFPLGlCQUNMLFVBQ0EsS0FDQSxjQUNBLEtBQ0E7Z0JBRUosS0FBSztvQkFDSCxlQUFlLE1BQU0sTUFBTSxLQUFLLENBQUM7b0JBQ2pDLFdBQVcsU0FBUyxTQUFTO29CQUM3QixJQUFJLFFBQVEsVUFDVixNQUFNLE1BQ0o7b0JBRUosT0FBTyxTQUFTLEdBQUcsQ0FBQztnQkFDdEIsS0FBSztvQkFDSCxPQUNFLEFBQUMsTUFBTSxNQUFNLEtBQUssQ0FBQyxJQUNuQixpQkFBaUIsVUFBVSxLQUFLLGNBQWMsS0FBSztnQkFFdkQsS0FBSztvQkFDSCxPQUNFLEFBQUMsTUFBTSxNQUFNLEtBQUssQ0FBQyxJQUNuQixpQkFBaUIsVUFBVSxLQUFLLGNBQWMsS0FBSztnQkFFdkQsS0FBSztvQkFDSCxPQUNFLEFBQUMsTUFBTSxNQUFNLEtBQUssQ0FBQyxJQUNuQixpQkFBaUIsVUFBVSxLQUFLLGNBQWMsS0FBSztnQkFFdkQsS0FBSztvQkFDSCxPQUNFLEFBQUMsTUFBTSxNQUFNLEtBQUssQ0FBQyxJQUNuQixpQkFBaUIsVUFBVSxLQUFLLGNBQWMsS0FBSztnQkFFdkQsS0FBSztvQkFDSCxPQUNFLEFBQUMsTUFBTSxNQUFNLEtBQUssQ0FBQyxJQUNuQixpQkFDRSxVQUNBLEtBQ0EsY0FDQSxLQUNBO2dCQUdOLEtBQUs7b0JBQ0gsT0FDRSxBQUFDLE1BQU0sTUFBTSxLQUFLLENBQUMsSUFDbkIsaUJBQ0UsVUFDQSxLQUNBLGNBQ0EsS0FDQTtnQkFHTixLQUFLO29CQUNILE9BQU87Z0JBQ1QsS0FBSztvQkFDSCxPQUFPLFVBQVUsUUFBUSxDQUFDLElBQUksQ0FBQztnQkFDakMsS0FBSztvQkFDSCxPQUFPO2dCQUNULEtBQUs7b0JBQ0g7Z0JBQ0YsS0FBSztvQkFDSCxPQUFPLElBQUksS0FBSyxLQUFLLEtBQUssQ0FBQyxNQUFNLEtBQUssQ0FBQztnQkFDekMsS0FBSztvQkFDSCxPQUFPLE9BQU8sTUFBTSxLQUFLLENBQUM7Z0JBQzVCLEtBQUs7b0JBQ0gsT0FDRSxBQUFDLE1BQU0sTUFBTSxLQUFLLENBQUMsSUFDbkIsaUJBQ0UsVUFDQSxLQUNBLGNBQ0EsS0FDQTtnQkFHTixLQUFLO29CQUNILFdBQVcsTUFBTSxLQUFLLENBQUM7b0JBQ3ZCLElBQUk7d0JBQ0YsT0FBTyxDQUFDLEdBQUcsSUFBSSxFQUFFO29CQUNuQixFQUFFLE9BQU8sR0FBRzt3QkFDVixJQUFJLFNBQVMsVUFBVSxDQUFDLG9CQUFvQjs0QkFDMUMsSUFDRyxBQUFDLGVBQWUsU0FBUyxPQUFPLENBQUMsS0FBSyxLQUN2QyxDQUFDLE1BQU0sY0FFUCxPQUNFLEFBQUMsV0FBVyxTQUFTLEtBQUssQ0FBQyxJQUFJLGNBQWMsSUFBSSxJQUNqRCxDQUFDLEdBQUcsSUFBSSxFQUNOLE9BQU8sS0FBSyxTQUFTLENBQUMsWUFBWSx3QkFDbkMsQ0FBQyxTQUFTO3dCQUVqQixPQUFPLElBQUksU0FBUyxVQUFVLENBQUMsY0FBYzs0QkFDM0MsSUFDRyxBQUFDLGVBQWUsU0FBUyxPQUFPLENBQUMsS0FBSyxJQUN2QyxDQUFDLE1BQU0sY0FFUCxPQUNFLEFBQUMsV0FBVyxTQUFTLEtBQUssQ0FBQyxHQUFHLGNBQWMsSUFBSSxJQUNoRCxDQUFDLEdBQUcsSUFBSSxFQUNOLE9BQU8sS0FBSyxTQUFTLENBQUMsWUFBWSxrQkFDbkMsQ0FBQyxTQUFTO3dCQUVqQixPQUFPLElBQ0wsU0FBUyxVQUFVLENBQUMsYUFDcEIsQ0FBQyxBQUFDLGVBQWUsU0FBUyxPQUFPLENBQUMsS0FBSyxJQUFLLENBQUMsTUFBTSxZQUFZLEdBRS9ELE9BQ0UsQUFBQyxXQUFXLFNBQVMsS0FBSyxDQUFDLEdBQUcsY0FBYyxJQUFJLElBQ2hELENBQUMsR0FBRyxJQUFJLEVBQUUsT0FBTyxLQUFLLFNBQVMsQ0FBQyxZQUFZLGFBQWEsQ0FDdkQsU0FDRDt3QkFFTCxPQUFPLFlBQWE7b0JBQ3RCO2dCQUNGLEtBQUs7b0JBQ0gsSUFBSSxJQUFJLE1BQU0sTUFBTSxJQUFJLENBQUMsTUFBTSxTQUFTLGFBQWEsR0FBRzt3QkFDdEQsSUFBSSxRQUFRLEtBQUssQ0FBQyxFQUFFLEVBQ2xCLE9BQ0UsQUFBQyxlQUFlLE1BQU0sS0FBSyxDQUFDLElBQzNCLE1BQU0sU0FBUyxjQUFjLEtBQzlCLFNBQVMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxRQUFRLElBQUksT0FBTyxlQUN4QyxTQUFTLFVBQVU7d0JBRXZCLFFBQVEsTUFBTSxLQUFLLENBQUM7d0JBQ3BCLElBQUksT0FBTyxTQUFTLE9BQU87d0JBQzNCLFNBQVMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxTQUFTLElBQUksT0FBTzt3QkFDekMsTUFBTSxTQUFTLFVBQVU7d0JBQ3pCLE9BQU8sZ0JBQWdCLElBQUksTUFBTSxHQUM3QixJQUFJLEtBQUssR0FDVCxpQkFBaUIsVUFBVSxLQUFLLGNBQWM7b0JBQ3BEO29CQUNBLE9BQU8sY0FBYyxDQUFDLGNBQWMsS0FBSzt3QkFDdkMsS0FBSzs0QkFDSCxPQUFPO3dCQUNUO3dCQUNBLFlBQVksQ0FBQzt3QkFDYixjQUFjLENBQUM7b0JBQ2pCO29CQUNBLE9BQU87Z0JBQ1Q7b0JBQ0UsT0FDRSxBQUFDLE1BQU0sTUFBTSxLQUFLLENBQUMsSUFDbkIsaUJBQWlCLFVBQVUsS0FBSyxjQUFjLEtBQUs7WUFFekQ7UUFDRjtRQUNBLE9BQU87SUFDVDtJQUNBLFNBQVM7UUFDUCxNQUFNLE1BQ0o7SUFFSjtJQUNBLFNBQVMsaUJBQ1AsYUFBYSxFQUNiLHFCQUFxQixFQUNyQixhQUFhLEVBQ2IsVUFBVSxFQUNWLGdCQUFnQixFQUNoQixLQUFLLEVBQ0wsbUJBQW1CLEVBQ25CLGdCQUFnQixFQUNoQixhQUFhLEVBQ2IsZUFBZSxFQUNmLFlBQVk7UUFFWixJQUFJLFNBQVMsSUFBSTtRQUNqQixJQUFJLENBQUMsY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQyxzQkFBc0IsR0FBRztRQUM5QixJQUFJLENBQUMsY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQyxXQUFXLEdBQUcsS0FBSyxNQUFNLGFBQWEsYUFBYTtRQUN4RCxJQUFJLENBQUMsaUJBQWlCLEdBQUc7UUFDekIsSUFBSSxDQUFDLE1BQU0sR0FBRztRQUNkLElBQUksQ0FBQyxPQUFPLEdBQUc7UUFDZixJQUFJLENBQUMsY0FBYyxHQUFHLElBQUk7UUFDMUIsSUFBSSxDQUFDLFNBQVMsR0FBRztRQUNqQixJQUFJLENBQUMsT0FBTyxHQUFHLENBQUM7UUFDaEIsSUFBSSxDQUFDLGFBQWEsR0FBRztRQUNyQixJQUFJLENBQUMsU0FBUyxHQUFHO1FBQ2pCLElBQUksQ0FBQyxjQUFjLEdBQUc7UUFDdEIsSUFBSSxDQUFDLGFBQWEsR0FBRztZQUFFLE1BQU0sSUFBSSxRQUFRLElBQUk7WUFBRyxVQUFVLElBQUk7UUFBQztRQUMvRCxJQUFJLENBQUMsZUFBZSxHQUFHLGdCQUNyQixLQUFLLE1BQU0sNkJBQ1gsU0FBUywwQkFBMEIsQ0FBQyxHQUNoQyxPQUNBLDBCQUEwQixDQUFDLENBQUMsUUFBUTtRQUMxQyxJQUFJLENBQUMsZUFBZSxHQUNsQixTQUFTLGdCQUFnQixNQUFNLDJCQUEyQjtRQUM1RCxrQkFBa0IsS0FBSyxNQUFNLGtCQUFrQixXQUFXO1FBQzFELHNCQUNFLENBQUMsSUFBSSxDQUFDLGNBQWMsR0FBRyxRQUFRLFVBQVUsQ0FDdkMsVUFBVSxnQkFBZ0IsV0FBVyxLQUFLLElBQzNDO1FBQ0gsSUFBSSxDQUFDLHNCQUFzQixHQUFHO1FBQzlCLElBQUksQ0FBQyxhQUFhLEdBQUc7UUFDckIsSUFBSSxDQUFDLGNBQWMsR0FBRztRQUN0QixJQUFJLENBQUMsb0JBQW9CLEdBQUc7UUFDNUIsZ0JBQ0UsQ0FBQyxTQUFTLHVCQUNOLENBQUMsYUFBYSxLQUFNLElBQUksQ0FBQyxhQUFhLEdBQUcsS0FBSyxDQUFFLElBQ2hELHFCQUFxQixRQUFRLENBQUMsSUFBSSxFQUFFLGFBQWE7UUFDdkQsSUFBSSxDQUFDLFNBQVMsR0FBRyx1QkFBdUIsSUFBSTtJQUM5QztJQUNBLFNBQVM7UUFDUCxPQUFPO1lBQ0wsV0FBVztZQUNYLFFBQVE7WUFDUixTQUFTO1lBQ1QsWUFBWTtZQUNaLFNBQVMsRUFBRTtRQUNiO0lBQ0Y7SUFDQSxTQUFTLGlCQUFpQixRQUFRLEVBQUUsRUFBRTtRQUNwQyxJQUFJLFNBQVMsU0FBUyxPQUFPLEVBQzNCLFFBQVEsT0FBTyxHQUFHLENBQUM7UUFDckIsU0FBUyxPQUFPLEdBQUcsQ0FBQyxJQUFLLFFBQVEsbUJBQW1CO1FBQ3BELElBQUksY0FBYyxNQUFNLE1BQU0sSUFBSSxjQUFjLE1BQU0sTUFBTSxFQUMxRCxvQkFBb0IsVUFBVSxRQUMzQixXQUFXLE9BQ1gsU0FBUyxNQUFNLEdBQUcsVUFDbEIsU0FBUyxLQUFLLEdBQUcsTUFDakIsU0FBUyxNQUFNLEdBQUc7SUFDekI7SUFDQSxTQUFTLGFBQWEsUUFBUSxFQUFFLEVBQUUsRUFBRSxLQUFLO1FBQ3ZDLElBQUksU0FBUyxTQUFTLE9BQU8sRUFDM0IsUUFBUSxPQUFPLEdBQUcsQ0FBQztRQUNyQixRQUNJLGtCQUFrQixVQUFVLE9BQU8sU0FDbkMsT0FBTyxHQUFHLENBQUMsSUFBSSxJQUFJLGFBQWEsa0JBQWtCLE9BQU87SUFDL0Q7SUFDQSxTQUFTLFlBQVksUUFBUSxFQUFFLEVBQUUsRUFBRSxJQUFJO1FBQ3JDLElBQUksU0FBUyxTQUFTLE9BQU8sRUFDM0IsUUFBUSxPQUFPLEdBQUcsQ0FBQztRQUNyQixTQUFTLGNBQWMsTUFBTSxNQUFNLEdBQy9CLE1BQU0sTUFBTSxDQUFDLFlBQVksQ0FBQyxRQUMxQixDQUFDLFNBQVMsb0JBQW9CLFVBQVUsUUFDeEMsT0FBTyxHQUFHLENBQUMsSUFBSSxJQUFJLGFBQWEsYUFBYSxNQUFNLE1BQU07SUFDL0Q7SUFDQSxTQUFTLGNBQWMsUUFBUSxFQUFFLEVBQUUsRUFBRSxNQUFNO1FBQ3pDLElBQUksU0FBUyxTQUFTLE9BQU8sRUFDM0IsUUFBUSxPQUFPLEdBQUcsQ0FBQztRQUNyQixTQUFTLGNBQWMsTUFBTSxNQUFNLEdBQy9CLE1BQU0sTUFBTSxDQUFDLFlBQVksQ0FBQyxVQUMxQixDQUFDLFNBQVMsb0JBQW9CLFVBQVUsUUFDeEMsT0FBTyxHQUFHLENBQUMsSUFBSSxJQUFJLGFBQWEsYUFBYSxRQUFRLE1BQU07SUFDakU7SUFDQSxTQUFTLGNBQWMsUUFBUSxFQUFFLEVBQUUsRUFBRSxLQUFLO1FBQ3hDLElBQUksU0FBUyxTQUFTLE9BQU8sRUFDM0IsUUFBUSxPQUFPLEdBQUcsQ0FBQztRQUNyQixRQUFRLEtBQUssS0FBSyxDQUFDLE9BQU8sU0FBUyxTQUFTO1FBQzVDLElBQUksa0JBQWtCLHVCQUNwQixTQUFTLGNBQWMsRUFDdkI7UUFFRixJQUFLLFFBQVEsY0FBYyxrQkFBbUI7WUFDNUMsSUFBSSxPQUFPO2dCQUNULG9CQUFvQixVQUFVO2dCQUM5QixJQUFJLGVBQWU7Z0JBQ25CLGFBQWEsTUFBTSxHQUFHO1lBQ3hCLE9BQ0UsQUFBQyxlQUFlLElBQUksYUFBYSxXQUFXLE1BQU0sT0FDaEQsT0FBTyxHQUFHLENBQUMsSUFBSTtZQUNuQixNQUFNLElBQUksQ0FDUjtnQkFDRSxPQUFPLG1CQUFtQixVQUFVLGNBQWM7WUFDcEQsR0FDQSxTQUFVLEtBQUs7Z0JBQ2IsT0FBTyxvQkFBb0IsVUFBVSxjQUFjO1lBQ3JEO1FBRUosT0FDRSxRQUNJLG1CQUFtQixVQUFVLE9BQU8sbUJBQ3BDLE9BQU8sR0FBRyxDQUNSLElBQ0EsSUFBSSxhQUFhLG1CQUFtQixpQkFBaUI7SUFFL0Q7SUFDQSxTQUFTLGNBQWMsUUFBUSxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsVUFBVTtRQUNyRCxJQUFJLFNBQVMsU0FBUyxPQUFPLEVBQzNCLFFBQVEsT0FBTyxHQUFHLENBQUM7UUFDckIsUUFDSSxjQUFjLE1BQU0sTUFBTSxJQUMxQixDQUFDLG9CQUFvQixVQUFVLFFBQzlCLFdBQVcsTUFBTSxLQUFLLEVBQ3RCLE1BQU0sTUFBTSxHQUFHLGFBQ2YsTUFBTSxLQUFLLEdBQUcsUUFDZCxNQUFNLE1BQU0sR0FBRyxZQUNoQixTQUFTLFlBQVksVUFBVSxVQUFVLE1BQU0sS0FBSyxDQUFDLElBQ3JELE9BQU8sR0FBRyxDQUFDLElBQUksSUFBSSxhQUFhLGFBQWEsUUFBUTtJQUMzRDtJQUNBLFNBQVMsb0JBQW9CLFFBQVEsRUFBRSxFQUFFLEVBQUUsSUFBSTtRQUM3QyxJQUFJLGFBQWE7UUFDakIsT0FBTyxJQUFJLGVBQWU7WUFDeEIsTUFBTTtZQUNOLE9BQU8sU0FBVSxDQUFDO2dCQUNoQixhQUFhO1lBQ2Y7UUFDRjtRQUNBLElBQUksdUJBQXVCO1FBQzNCLGNBQWMsVUFBVSxJQUFJLE1BQU07WUFDaEMsY0FBYyxTQUFVLEtBQUs7Z0JBQzNCLFNBQVMsdUJBQ0wsV0FBVyxPQUFPLENBQUMsU0FDbkIscUJBQXFCLElBQUksQ0FBQztvQkFDeEIsV0FBVyxPQUFPLENBQUM7Z0JBQ3JCO1lBQ047WUFDQSxjQUFjLFNBQVUsSUFBSTtnQkFDMUIsSUFBSSxTQUFTLHNCQUFzQjtvQkFDakMsSUFBSSxRQUFRLElBQUksYUFBYSxrQkFBa0IsTUFBTTtvQkFDckQscUJBQXFCO29CQUNyQixnQkFBZ0IsTUFBTSxNQUFNLEdBQ3hCLFdBQVcsT0FBTyxDQUFDLE1BQU0sS0FBSyxJQUM5QixDQUFDLE1BQU0sSUFBSSxDQUNULFNBQVUsQ0FBQzt3QkFDVCxPQUFPLFdBQVcsT0FBTyxDQUFDO29CQUM1QixHQUNBLFNBQVUsQ0FBQzt3QkFDVCxPQUFPLFdBQVcsS0FBSyxDQUFDO29CQUMxQixJQUVELHVCQUF1QixLQUFNO2dCQUNwQyxPQUFPO29CQUNMLFFBQVE7b0JBQ1IsSUFBSSxVQUFVLG1CQUFtQjtvQkFDakMsUUFBUSxJQUFJLENBQ1YsU0FBVSxDQUFDO3dCQUNULE9BQU8sV0FBVyxPQUFPLENBQUM7b0JBQzVCLEdBQ0EsU0FBVSxDQUFDO3dCQUNULE9BQU8sV0FBVyxLQUFLLENBQUM7b0JBQzFCO29CQUVGLHVCQUF1QjtvQkFDdkIsTUFBTSxJQUFJLENBQUM7d0JBQ1QseUJBQXlCLFdBQVcsQ0FBQyx1QkFBdUIsSUFBSTt3QkFDaEUsa0JBQWtCLFVBQVUsU0FBUztvQkFDdkM7Z0JBQ0Y7WUFDRjtZQUNBLE9BQU87Z0JBQ0wsSUFBSSxTQUFTLHNCQUFzQixXQUFXLEtBQUs7cUJBQzlDO29CQUNILElBQUksZUFBZTtvQkFDbkIsdUJBQXVCO29CQUN2QixhQUFhLElBQUksQ0FBQzt3QkFDaEIsT0FBTyxXQUFXLEtBQUs7b0JBQ3pCO2dCQUNGO1lBQ0Y7WUFDQSxPQUFPLFNBQVUsS0FBSztnQkFDcEIsSUFBSSxTQUFTLHNCQUFzQixXQUFXLEtBQUssQ0FBQztxQkFDL0M7b0JBQ0gsSUFBSSxlQUFlO29CQUNuQix1QkFBdUI7b0JBQ3ZCLGFBQWEsSUFBSSxDQUFDO3dCQUNoQixPQUFPLFdBQVcsS0FBSyxDQUFDO29CQUMxQjtnQkFDRjtZQUNGO1FBQ0Y7SUFDRjtJQUNBLFNBQVM7UUFDUCxPQUFPLElBQUk7SUFDYjtJQUNBLFNBQVMsZUFBZSxJQUFJO1FBQzFCLE9BQU87WUFBRSxNQUFNO1FBQUs7UUFDcEIsSUFBSSxDQUFDLGVBQWUsR0FBRztRQUN2QixPQUFPO0lBQ1Q7SUFDQSxTQUFTLG1CQUFtQixRQUFRLEVBQUUsRUFBRSxFQUFFLFFBQVE7UUFDaEQsSUFBSSxTQUFTLEVBQUUsRUFDYixTQUFTLENBQUMsR0FDVixpQkFBaUIsR0FDakIsV0FBVyxDQUFDO1FBQ2QsUUFBUSxDQUFDLGVBQWUsR0FBRztZQUN6QixJQUFJLGdCQUFnQjtZQUNwQixPQUFPLGVBQWUsU0FBVSxHQUFHO2dCQUNqQyxJQUFJLEtBQUssTUFBTSxLQUNiLE1BQU0sTUFDSjtnQkFFSixJQUFJLGtCQUFrQixPQUFPLE1BQU0sRUFBRTtvQkFDbkMsSUFBSSxRQUNGLE9BQU8sSUFBSSxhQUNULGFBQ0E7d0JBQUUsTUFBTSxDQUFDO3dCQUFHLE9BQU8sS0FBSztvQkFBRSxHQUMxQjtvQkFFSixNQUFNLENBQUMsY0FBYyxHQUFHLG1CQUFtQjtnQkFDN0M7Z0JBQ0EsT0FBTyxNQUFNLENBQUMsZ0JBQWdCO1lBQ2hDO1FBQ0Y7UUFDQSxjQUNFLFVBQ0EsSUFDQSxXQUFXLFFBQVEsQ0FBQyxlQUFlLEtBQUssVUFDeEM7WUFDRSxjQUFjLFNBQVUsS0FBSztnQkFDM0IsSUFBSSxtQkFBbUIsT0FBTyxNQUFNLEVBQ2xDLE1BQU0sQ0FBQyxlQUFlLEdBQUcsSUFBSSxhQUMzQixhQUNBO29CQUFFLE1BQU0sQ0FBQztvQkFBRyxPQUFPO2dCQUFNLEdBQ3pCO3FCQUVDO29CQUNILElBQUksUUFBUSxNQUFNLENBQUMsZUFBZSxFQUNoQyxtQkFBbUIsTUFBTSxLQUFLLEVBQzlCLGtCQUFrQixNQUFNLE1BQU07b0JBQ2hDLE1BQU0sTUFBTSxHQUFHO29CQUNmLE1BQU0sS0FBSyxHQUFHO3dCQUFFLE1BQU0sQ0FBQzt3QkFBRyxPQUFPO29CQUFNO29CQUN2QyxTQUFTLG9CQUNQLHVCQUNFLE9BQ0Esa0JBQ0E7Z0JBRU47Z0JBQ0E7WUFDRjtZQUNBLGNBQWMsU0FBVSxLQUFLO2dCQUMzQixtQkFBbUIsT0FBTyxNQUFNLEdBQzNCLE1BQU0sQ0FBQyxlQUFlLEdBQUcsa0NBQ3hCLFVBQ0EsT0FDQSxDQUFDLEtBRUgsMkJBQ0UsVUFDQSxNQUFNLENBQUMsZUFBZSxFQUN0QixPQUNBLENBQUM7Z0JBRVA7WUFDRjtZQUNBLE9BQU8sU0FBVSxLQUFLO2dCQUNwQixTQUFTLENBQUM7Z0JBQ1YsbUJBQW1CLE9BQU8sTUFBTSxHQUMzQixNQUFNLENBQUMsZUFBZSxHQUFHLGtDQUN4QixVQUNBLE9BQ0EsQ0FBQyxLQUVILDJCQUNFLFVBQ0EsTUFBTSxDQUFDLGVBQWUsRUFDdEIsT0FDQSxDQUFDO2dCQUVQLElBQUssa0JBQWtCLGlCQUFpQixPQUFPLE1BQU0sRUFDbkQsMkJBQ0UsVUFDQSxNQUFNLENBQUMsaUJBQWlCLEVBQ3hCLGdCQUNBLENBQUM7WUFFUDtZQUNBLE9BQU8sU0FBVSxLQUFLO2dCQUNwQixTQUFTLENBQUM7Z0JBQ1YsSUFDRSxtQkFBbUIsT0FBTyxNQUFNLElBQ2hDLENBQUMsTUFBTSxDQUFDLGVBQWUsR0FBRyxtQkFBbUIsU0FBUyxHQUN0RCxpQkFBaUIsT0FBTyxNQUFNLEVBRzlCLG9CQUFvQixVQUFVLE1BQU0sQ0FBQyxpQkFBaUIsRUFBRTtZQUM1RDtRQUNGO0lBRUo7SUFDQSxTQUFTLFdBQVcsUUFBUSxFQUFFLEVBQUUsRUFBRSxHQUFHO1FBQ25DLENBQUMsV0FBVyxTQUFTLE9BQU8sQ0FBQyxHQUFHLENBQUMsR0FBRyxLQUNsQyxnQkFBZ0IsU0FBUyxNQUFNLElBQy9CLFNBQVMsTUFBTSxDQUFDLEtBQUssQ0FBQyxPQUFPLE1BQU0saUJBQWlCO0lBQ3hEO0lBQ0EsU0FBUyxnQkFBZ0IsUUFBUSxFQUFFLFNBQVM7UUFDMUMsSUFBSSxPQUFPLFVBQVUsSUFBSSxFQUN2QixNQUFNLFVBQVUsR0FBRztRQUNyQixZQUFZLG1CQUNWLFVBQ0EsVUFBVSxLQUFLLEVBQ2YsS0FDQSxDQUFDLEdBQ0QsTUFBTSxJQUFJLENBQ1IsTUFDQSxVQUFVLE9BQU8sSUFDZjtRQUdOLFdBQVcsWUFBWSxVQUFVO1FBQ2pDLFdBQVcsUUFBUSxXQUFXLFNBQVMsR0FBRyxDQUFDLGFBQWE7UUFDeEQsU0FBUyxJQUFJLEdBQUc7UUFDaEIsU0FBUyxlQUFlLEdBQUc7UUFDM0IsT0FBTztJQUNUO0lBQ0EsU0FBUyxZQUFZLFFBQVEsRUFBRSxJQUFJLEVBQUUsS0FBSztRQUN4QyxXQUFXLEtBQUssS0FBSyxDQUFDLE9BQU8sU0FBUyxTQUFTO1FBQy9DLFFBQVEsd0JBQXdCLENBQUM7UUFDakMsT0FBUTtZQUNOLEtBQUs7Z0JBQ0gsTUFBTSxDQUFDLENBQUM7Z0JBQ1I7WUFDRixLQUFLO2dCQUNILGFBQWEsT0FBTyxXQUNoQixNQUFNLENBQUMsQ0FBQyxZQUNSLE1BQU0sQ0FBQyxDQUFDLFFBQVEsQ0FBQyxFQUFFLEVBQUUsUUFBUSxDQUFDLEVBQUU7Z0JBQ3BDO1lBQ0YsS0FBSztnQkFDSCxPQUFPLFFBQVEsQ0FBQyxFQUFFO2dCQUNsQixJQUFJLEtBQUssUUFBUSxDQUFDLEVBQUU7Z0JBQ3BCLE1BQU0sU0FBUyxNQUFNLEdBQ2pCLE1BQU0sQ0FBQyxDQUFDLE1BQU0sSUFBSSxRQUFRLENBQUMsRUFBRSxJQUM3QixNQUFNLENBQUMsQ0FBQyxNQUFNO2dCQUNsQjtZQUNGLEtBQUs7Z0JBQ0gsYUFBYSxPQUFPLFdBQ2hCLE1BQU0sQ0FBQyxDQUFDLFlBQ1IsTUFBTSxDQUFDLENBQUMsUUFBUSxDQUFDLEVBQUUsRUFBRSxRQUFRLENBQUMsRUFBRTtnQkFDcEM7WUFDRixLQUFLO2dCQUNILGFBQWEsT0FBTyxXQUNoQixNQUFNLENBQUMsQ0FBQyxZQUNSLE1BQU0sQ0FBQyxDQUFDLFFBQVEsQ0FBQyxFQUFFLEVBQUUsUUFBUSxDQUFDLEVBQUU7Z0JBQ3BDO1lBQ0YsS0FBSztnQkFDSCxhQUFhLE9BQU8sV0FDaEIsTUFBTSxDQUFDLENBQUMsWUFDUixNQUFNLENBQUMsQ0FDTCxRQUFRLENBQUMsRUFBRSxFQUNYLE1BQU0sUUFBUSxDQUFDLEVBQUUsR0FBRyxLQUFLLElBQUksUUFBUSxDQUFDLEVBQUUsRUFDeEMsTUFBTSxTQUFTLE1BQU0sR0FBRyxRQUFRLENBQUMsRUFBRSxHQUFHLEtBQUs7Z0JBRWpEO1lBQ0YsS0FBSztnQkFDSCxhQUFhLE9BQU8sV0FDaEIsTUFBTSxDQUFDLENBQUMsWUFDUixNQUFNLENBQUMsQ0FBQyxRQUFRLENBQUMsRUFBRSxFQUFFLFFBQVEsQ0FBQyxFQUFFO1FBQ3hDO0lBQ0Y7SUFDQSxTQUFTLG1CQUNQLElBQUksRUFDSixRQUFRLEVBQ1IsU0FBUyxFQUNULElBQUksRUFDSixHQUFHLEVBQ0gsYUFBYSxFQUNiLFlBQVksRUFDWixlQUFlO1FBRWYsUUFBUSxDQUFDLE9BQU8sYUFBYTtRQUM3QixJQUFJLGNBQWMsS0FBSyxTQUFTLENBQUM7UUFDakMsSUFBSSxnQkFBaUIsZ0JBQWdCLElBQUs7UUFDMUMsSUFBSSxlQUFnQixlQUFlLElBQUs7UUFDeEMsSUFBSSxPQUFRLE9BQU8sSUFBSztRQUN4QixJQUFJLE1BQU8sTUFBTSxJQUFLO1FBQ3RCLElBQ0UsT0FBTyxpQkFDTixTQUFTLGlCQUFpQixNQUFNLGNBRWpDLGVBQWUsZ0JBQWdCO1FBQ2pDLElBQUksT0FDQSxDQUFDLEFBQUMsT0FBTyxZQUFZLE1BQU0sR0FBRyxHQUM3QixnQkFBZ0IsTUFDakIsSUFBSSxnQkFBZ0IsQ0FBQyxlQUFlLENBQUMsR0FDcEMsTUFBTSxNQUFNLGVBQWUsT0FBTyxHQUNuQyxJQUFJLE9BQU8sQ0FBQyxNQUFNLENBQUMsR0FDbEIsY0FDQyxPQUNBLGNBQ0EsTUFDQSxJQUFJLE1BQU0sQ0FBQyxnQkFDWCxRQUNBLElBQUksTUFBTSxDQUFDLE9BQ1gsT0FBUSxJQUNWLElBQUksZ0JBQ0YsQ0FBQyxBQUFDLGdCQUFnQixZQUFZLE1BQU0sR0FBRyxHQUN2QyxJQUFJLGdCQUFnQixDQUFDLGVBQWUsQ0FBQyxHQUNwQyxjQUNDLE9BQ0EsY0FDQSxNQUNBLElBQUksTUFBTSxDQUFDLGdCQUNYLFFBQ0EsS0FBSyxNQUFNLENBQUMsT0FBTyxpQkFDbkIsSUFBSSxNQUFNLENBQUMsT0FDWCxPQUFRLElBQ1Ysa0JBQWtCLE9BQ2hCLENBQUMsQUFBQyxNQUFNLE1BQU0sZUFBZSxHQUM3QixJQUFJLE9BQU8sQ0FBQyxNQUFNLENBQUMsR0FDbEIsY0FDQyxLQUFLLE1BQU0sQ0FBQyxnQkFBZ0IsS0FDNUIsT0FDQSxjQUNBLFFBQ0EsSUFBSSxNQUFNLENBQUMsZ0JBQ1gsUUFDQSxJQUFJLE1BQU0sQ0FBQyxPQUNYLE9BQVEsSUFDVCxjQUNDLEtBQUssTUFBTSxDQUFDLGdCQUFnQixLQUM1QixPQUNBLGNBQ0EsUUFDQSxJQUFJLE1BQU0sQ0FBQyxnQkFDWCxRQUNBLEtBQUssTUFBTSxDQUFDLE9BQU8saUJBQ25CLElBQUksTUFBTSxDQUFDLE9BQ1g7UUFDVixjQUNFLElBQUksZ0JBQ0EsY0FDQSwwR0FDQSx3R0FDQTtRQUNOLFNBQVMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxXQUFXLFlBQVksUUFBUTtRQUM1RCxZQUNJLENBQUMsQUFBQyxlQUNBLGlDQUNBLG1CQUFtQixtQkFDbkIsTUFDQSxVQUFVLFlBQ1YsTUFDQSxtQkFDRCxlQUFlLDRCQUE0QixTQUFVLElBQ3JELGNBQWMsV0FDWCxjQUFjLENBQUMscUJBQXFCLFVBQVUsU0FBUyxJQUN2RCxjQUFjO1FBQ3RCLElBQUk7WUFDRixJQUFJLEtBQUssQ0FBQyxHQUFHLElBQUksRUFBRSxZQUFZLENBQUMsS0FBSztRQUN2QyxFQUFFLE9BQU8sR0FBRztZQUNWLEtBQUssU0FBVSxDQUFDO2dCQUNkLE9BQU87WUFDVDtRQUNGO1FBQ0EsT0FBTztJQUNUO0lBQ0EsU0FBUyxtQkFDUCxRQUFRLEVBQ1IsS0FBSyxFQUNMLGVBQWUsRUFDZixnQkFBZ0IsRUFDaEIsU0FBUztRQUVULElBQUssSUFBSSxJQUFJLEdBQUcsSUFBSSxNQUFNLE1BQU0sRUFBRSxJQUFLO1lBQ3JDLElBQUksUUFBUSxLQUFLLENBQUMsRUFBRSxFQUNsQixXQUNFLE1BQU0sSUFBSSxDQUFDLE9BQ1gsTUFDQSxrQkFDQSxDQUFDLG1CQUFtQixPQUFPLElBQUksR0FDakMsS0FBSyxrQkFBa0IsR0FBRyxDQUFDO1lBQzdCLElBQUksS0FBSyxNQUFNLElBQUk7Z0JBQ2pCLEtBQUssS0FBSyxDQUFDLEVBQUU7Z0JBQ2IsSUFBSSxXQUFXLEtBQUssQ0FBQyxFQUFFLEVBQ3JCLE9BQU8sS0FBSyxDQUFDLEVBQUUsRUFDZixNQUFNLEtBQUssQ0FBQyxFQUFFLEVBQ2QsZ0JBQWdCLEtBQUssQ0FBQyxFQUFFO2dCQUMxQixRQUFRLEtBQUssQ0FBQyxFQUFFO2dCQUNoQixJQUFJLG1CQUFtQixTQUFTLHNCQUFzQjtnQkFDdEQsbUJBQW1CLG1CQUNmLGlCQUFpQixVQUFVLG1CQUMzQjtnQkFDSixLQUFLLG1CQUNILElBQ0EsVUFDQSxrQkFDQSxNQUNBLEtBQ0EsbUJBQW1CLE9BQU8sZUFDMUIsbUJBQW1CLE1BQU0sT0FDekI7Z0JBRUYsa0JBQWtCLEdBQUcsQ0FBQyxVQUFVO1lBQ2xDO1lBQ0EsWUFBWSxHQUFHLElBQUksQ0FBQyxNQUFNO1FBQzVCO1FBQ0EsT0FBTztJQUNUO0lBQ0EsU0FBUyxZQUFZLFFBQVEsRUFBRSxvQkFBb0I7UUFDakQsSUFBSSxXQUFXLFNBQVMsY0FBYztRQUN0QyxPQUFPLFdBQ0gsU0FBUyxvQkFBb0IsS0FBSyx1QkFDaEMsQ0FBQyxBQUFDLFdBQVcsUUFBUSxVQUFVLENBQUMsSUFBSSxDQUNsQyxTQUNBLFVBQVUscUJBQXFCLFdBQVcsS0FBSyxNQUVqRCxTQUFTLEdBQUcsQ0FBQyxTQUFTLElBQ3RCLFdBQ0Y7SUFDTjtJQUNBLFNBQVMsbUJBQW1CLFFBQVEsRUFBRSxTQUFTO1FBQzdDLElBQUksQ0FBQyxzQkFBc0IsUUFBUSxVQUFVLEtBQUssRUFBRSxPQUFPO1FBQzNELElBQUksY0FBYyxVQUFVLFNBQVM7UUFDckMsSUFBSSxLQUFLLE1BQU0sYUFBYSxPQUFPO1FBQ25DLElBQUksbUJBQW1CLEtBQUssTUFBTSxVQUFVLEdBQUcsRUFDN0MsUUFBUSxVQUFVLEtBQUssRUFDdkIsTUFDRSxRQUFRLFVBQVUsR0FBRyxHQUFHLFNBQVMsb0JBQW9CLEdBQUcsVUFBVSxHQUFHO1FBQ3pFLGNBQ0UsUUFBUSxVQUFVLEtBQUssSUFBSSxRQUFRLFVBQVUsS0FBSyxDQUFDLEdBQUcsR0FDbEQsU0FBUyxvQkFBb0IsR0FDN0IsVUFBVSxLQUFLLENBQUMsR0FBRztRQUN6QixJQUFJLFlBQ0YsUUFBUSxVQUFVLEtBQUssR0FDbkIsT0FDQSxtQkFBbUIsVUFBVSxVQUFVLEtBQUs7UUFDbEQsTUFDRSxRQUFRLGNBQ0osVUFBVSxJQUFJLFdBQVcsS0FBSyxNQUM5QixLQUFLLE1BQU0sVUFBVSxHQUFHLEdBQ3RCLE1BQU0sQ0FBQyxVQUFVLElBQUksSUFBSSxLQUFLLElBQUksTUFDbEMsS0FBSyxNQUFNLFVBQVUsSUFBSSxHQUN2QixVQUFVLElBQUksSUFBSSxZQUNsQixXQUFXLENBQUMsVUFBVSxPQUFPLENBQUMsSUFBSSxJQUFJLFNBQVM7UUFDekQsTUFBTSxRQUFRLFVBQVUsQ0FBQyxJQUFJLENBQUMsU0FBUztRQUN2QyxtQkFBbUIsbUJBQ2pCLFVBQ0EsT0FDQSxhQUNBLGtCQUNBO1FBRUYsU0FBUyxZQUNMLENBQUMsQUFBQyxXQUFXLFlBQVksVUFBVSxjQUNsQyxXQUNDLFFBQVEsV0FDSixTQUFTLEdBQUcsQ0FBQyxvQkFDYixrQkFBbUIsSUFDeEIsV0FBVyxVQUFVLEdBQUcsQ0FBQztRQUM5QixPQUFRLFVBQVUsU0FBUyxHQUFHO0lBQ2hDO0lBQ0EsU0FBUztRQUNQLE9BQU8sTUFBTTtJQUNmO0lBQ0EsU0FBUyxvQkFBb0IsUUFBUSxFQUFFLFNBQVM7UUFDOUMsSUFBSSxLQUFLLE1BQU0sVUFBVSxVQUFVLEVBQUU7WUFDbkMsUUFBUSxVQUFVLEtBQUssSUFDckIsQ0FBQyxVQUFVLFVBQVUsR0FBRyw0QkFDdEIsVUFDQSxVQUFVLEtBQUssRUFDZixRQUFRLFVBQVUsR0FBRyxHQUFHLEtBQUssVUFBVSxHQUFHLENBQzNDO1lBQ0gsSUFBSSxRQUFRLFVBQVUsS0FBSztZQUMzQixRQUFRLFNBQ04sQ0FBQyxvQkFBb0IsVUFBVSxRQUMvQixLQUFLLE1BQU0sTUFBTSxhQUFhLElBQzVCLFFBQVEsVUFBVSxVQUFVLElBQzVCLENBQUMsTUFBTSxhQUFhLEdBQUcsVUFBVSxVQUFVLENBQUM7UUFDbEQ7SUFDRjtJQUNBLFNBQVMsaUJBQWlCLFFBQVEsRUFBRSxFQUFFLEVBQUUsU0FBUztRQUMvQyxLQUFLLE1BQU0sVUFBVSxLQUFLLElBQUksbUJBQW1CLFVBQVU7UUFDM0QsUUFBUSxVQUFVLEtBQUssSUFBSSxRQUFRLFNBQVMsZUFBZSxHQUN2RCxDQUFDLEFBQUMsVUFBVSxLQUFLLEdBQUcsU0FBUyxlQUFlLEVBQzNDLFVBQVUsS0FBSyxHQUFHLE1BQ2xCLFVBQVUsVUFBVSxHQUFHLFNBQVMsZUFBZSxFQUMvQyxVQUFVLFNBQVMsR0FBRyxTQUFTLGNBQWMsQUFBQyxJQUMvQyxLQUFLLE1BQU0sVUFBVSxLQUFLLElBQzFCLG9CQUFvQixVQUFVO1FBQ2xDLFdBQVcsU0FBUyxVQUFVO1FBQzlCLENBQUMsU0FBUyxVQUFVLElBQUksQ0FBQyxTQUFTLFVBQVUsR0FBRyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUM7SUFDM0Q7SUFDQSxTQUFTO1FBQ1AsSUFBSSxRQUFRO1FBQ1osSUFBSSxTQUFTLE9BQU8sT0FBTztRQUMzQixJQUFJO1lBQ0YsSUFBSSxPQUFPO1lBQ1gsSUFBSSxNQUFNLEtBQUssSUFBSSxhQUFhLE9BQU8sTUFBTSxJQUFJLEVBQUU7Z0JBQ2pELE1BQU8sT0FBUztvQkFDZCxJQUFJLGFBQWEsTUFBTSxVQUFVO29CQUNqQyxJQUFJLFFBQVEsWUFBWTt3QkFDdEIsSUFBSyxRQUFRLE1BQU0sS0FBSyxFQUFHOzRCQUN6QixJQUFJLHdCQUF3Qjs0QkFDNUIsSUFBSSxRQUFRLFlBQ1Ysd0JBQXdCLE1BQU0saUJBQWlCOzRCQUNqRCxNQUFNLGlCQUFpQixHQUFHLEtBQUs7NEJBQy9CLElBQUksUUFBUSxNQUFNLEtBQUs7NEJBQ3ZCLE1BQU0saUJBQWlCLEdBQUc7NEJBQzFCLE1BQU0sVUFBVSxDQUFDLHFDQUNmLENBQUMsUUFBUSxNQUFNLEtBQUssQ0FBQyxHQUFHOzRCQUMxQixJQUFJLE1BQU0sTUFBTSxPQUFPLENBQUM7NEJBQ3hCLENBQUMsTUFBTSxPQUFPLENBQUMsUUFBUSxNQUFNLEtBQUssQ0FBQyxNQUFNLEVBQUU7NEJBQzNDLE1BQU0sTUFBTSxPQUFPLENBQUM7NEJBQ3BCLENBQUMsTUFBTSxPQUFPLENBQUMsTUFBTSxNQUFNLFdBQVcsQ0FBQyxNQUFNLElBQUk7NEJBQ2pELElBQUksMkJBQ0YsQ0FBQyxNQUFNLE1BQU8sUUFBUSxNQUFNLEtBQUssQ0FBQyxHQUFHLE9BQVE7NEJBQy9DLE9BQ0Usd0JBQXdCLENBQUMsT0FBTyx3QkFBd0I7d0JBQzVEO29CQUNGLE9BQU87Z0JBQ1Q7Z0JBQ0EsSUFBSSxvQ0FBb0M7WUFDMUMsT0FBTztnQkFDTCx3QkFBd0IsTUFBTSxJQUFJO2dCQUNsQyxJQUFJLEtBQUssTUFBTSxRQUNiLElBQUk7b0JBQ0YsTUFBTTtnQkFDUixFQUFFLE9BQU8sR0FBRztvQkFDVCxTQUNDLEFBQUMsQ0FBQyxRQUFRLEVBQUUsS0FBSyxDQUFDLElBQUksR0FBRyxLQUFLLENBQUMsZUFBZSxLQUFLLEtBQUssQ0FBQyxFQUFFLElBQzNELElBQ0MsU0FDQyxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsT0FBTyxDQUFDLGNBQ2pCLG1CQUNBLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxPQUFPLENBQUMsT0FDbkIsaUJBQ0E7Z0JBQ1o7Z0JBQ0Ysb0NBQ0UsT0FBTyxTQUFTLHdCQUF3QjtZQUM1QztRQUNGLEVBQUUsT0FBTyxHQUFHO1lBQ1Ysb0NBQ0UsK0JBQStCLEVBQUUsT0FBTyxHQUFHLE9BQU8sRUFBRSxLQUFLO1FBQzdEO1FBQ0EsT0FBTztJQUNUO0lBQ0EsU0FBUyxvQkFBb0IsUUFBUSxFQUFFLEtBQUs7UUFDMUMsSUFBSSxTQUFTLGNBQWMsRUFBRTtZQUMzQixJQUFJLFVBQVUsS0FBSyxLQUFLLENBQUMsT0FBTyxTQUFTLFNBQVM7WUFDbEQsUUFBUSxPQUFPLENBQUMsRUFBRTtZQUNsQixJQUFJLGFBQWEsT0FBTyxDQUFDLEVBQUUsRUFDekIsUUFBUSxPQUFPLENBQUMsRUFBRSxFQUNsQixNQUFNLE9BQU8sQ0FBQyxFQUFFO1lBQ2xCLFVBQVUsUUFBUSxLQUFLLENBQUM7WUFDeEIsZ0NBQ0UsVUFDQSxPQUNBLFlBQ0EsT0FDQSxLQUNBO1FBRUo7SUFDRjtJQUNBLFNBQVMsWUFBWSxNQUFNLEVBQUUsU0FBUztRQUNwQyxJQUNFLElBQUksSUFBSSxPQUFPLE1BQU0sRUFBRSxhQUFhLFVBQVUsTUFBTSxFQUFFLElBQUksR0FDMUQsSUFBSSxHQUNKLElBRUEsY0FBYyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVU7UUFDcEMsYUFBYSxJQUFJLFdBQVc7UUFDNUIsSUFBSyxJQUFJLE1BQU8sSUFBSSxHQUFJLE1BQU0sR0FBRyxNQUFPO1lBQ3RDLElBQUksUUFBUSxNQUFNLENBQUMsSUFBSTtZQUN2QixXQUFXLEdBQUcsQ0FBQyxPQUFPO1lBQ3RCLEtBQUssTUFBTSxVQUFVO1FBQ3ZCO1FBQ0EsV0FBVyxHQUFHLENBQUMsV0FBVztRQUMxQixPQUFPO0lBQ1Q7SUFDQSxTQUFTLGtCQUNQLFFBQVEsRUFDUixFQUFFLEVBQ0YsTUFBTSxFQUNOLFNBQVMsRUFDVCxXQUFXLEVBQ1gsZUFBZTtRQUVmLFNBQ0UsTUFBTSxPQUFPLE1BQU0sSUFBSSxNQUFNLFVBQVUsVUFBVSxHQUFHLGtCQUNoRCxZQUNBLFlBQVksUUFBUTtRQUMxQixjQUFjLElBQUksWUFDaEIsT0FBTyxNQUFNLEVBQ2IsT0FBTyxVQUFVLEVBQ2pCLE9BQU8sVUFBVSxHQUFHO1FBRXRCLGNBQWMsVUFBVSxJQUFJO0lBQzlCO0lBQ0EsU0FBUyxpQ0FBaUM7SUFDMUMsU0FBUyxxQkFBcUIsUUFBUSxFQUFFLEVBQUUsRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLEtBQUs7UUFDNUQsT0FBUTtZQUNOLEtBQUs7Z0JBQ0gsY0FBYyxVQUFVLElBQUksWUFBWSxRQUFRLE9BQU8sTUFBTTtnQkFDN0Q7WUFDRixLQUFLO2dCQUNILGtCQUFrQixVQUFVLElBQUksUUFBUSxPQUFPLFdBQVc7Z0JBQzFEO1lBQ0YsS0FBSztnQkFDSCxjQUNFLFVBQ0EsSUFDQSxNQUFNLE9BQU8sTUFBTSxHQUFHLFFBQVEsWUFBWSxRQUFRO2dCQUVwRDtZQUNGLEtBQUs7Z0JBQ0gsa0JBQWtCLFVBQVUsSUFBSSxRQUFRLE9BQU8sbUJBQW1CO2dCQUNsRTtZQUNGLEtBQUs7Z0JBQ0gsa0JBQWtCLFVBQVUsSUFBSSxRQUFRLE9BQU8sWUFBWTtnQkFDM0Q7WUFDRixLQUFLO2dCQUNILGtCQUFrQixVQUFVLElBQUksUUFBUSxPQUFPLGFBQWE7Z0JBQzVEO1lBQ0YsS0FBSztnQkFDSCxrQkFBa0IsVUFBVSxJQUFJLFFBQVEsT0FBTyxZQUFZO2dCQUMzRDtZQUNGLEtBQUs7Z0JBQ0gsa0JBQWtCLFVBQVUsSUFBSSxRQUFRLE9BQU8sYUFBYTtnQkFDNUQ7WUFDRixLQUFLO2dCQUNILGtCQUFrQixVQUFVLElBQUksUUFBUSxPQUFPLGNBQWM7Z0JBQzdEO1lBQ0YsS0FBSztnQkFDSCxrQkFBa0IsVUFBVSxJQUFJLFFBQVEsT0FBTyxjQUFjO2dCQUM3RDtZQUNGLEtBQUs7Z0JBQ0gsa0JBQWtCLFVBQVUsSUFBSSxRQUFRLE9BQU8sZUFBZTtnQkFDOUQ7WUFDRixLQUFLO2dCQUNILGtCQUFrQixVQUFVLElBQUksUUFBUSxPQUFPLGdCQUFnQjtnQkFDL0Q7WUFDRixLQUFLO2dCQUNILGtCQUFrQixVQUFVLElBQUksUUFBUSxPQUFPLFVBQVU7Z0JBQ3pEO1FBQ0o7UUFDQSxJQUNFLElBQUksZ0JBQWdCLFNBQVMsY0FBYyxFQUFFLE1BQU0sSUFBSSxJQUFJLEdBQzNELElBQUksT0FBTyxNQUFNLEVBQ2pCLElBRUEsT0FBTyxjQUFjLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFO1FBQ3pDLE9BQU8sY0FBYyxNQUFNLENBQUM7UUFDNUIscUJBQXFCLFVBQVUsSUFBSSxLQUFLO0lBQzFDO0lBQ0EsU0FBUyxxQkFBcUIsUUFBUSxFQUFFLEVBQUUsRUFBRSxHQUFHLEVBQUUsR0FBRztRQUNsRCxPQUFRO1lBQ04sS0FBSztnQkFDSCxjQUFjLFVBQVUsSUFBSTtnQkFDNUI7WUFDRixLQUFLO2dCQUNILFlBQVksVUFBVSxHQUFHLENBQUMsRUFBRSxFQUFFLElBQUksS0FBSyxDQUFDO2dCQUN4QztZQUNGLEtBQUs7Z0JBQ0gsTUFBTSxLQUFLLEtBQUssQ0FBQztnQkFDakIsTUFBTSxnQkFBZ0IsVUFBVTtnQkFDaEMsSUFBSSxNQUFNLEdBQUcsSUFBSSxNQUFNO2dCQUN2QixNQUFNLFNBQVMsT0FBTztnQkFDdEIsSUFBSSxRQUFRLElBQUksR0FBRyxDQUFDO2dCQUNwQixRQUNJLG9CQUFvQixVQUFVLE9BQU8sT0FDckMsSUFBSSxHQUFHLENBQUMsSUFBSSxJQUFJLGFBQWEsWUFBWSxNQUFNO2dCQUNuRDtZQUNGLEtBQUs7Z0JBQ0gsWUFBWSxVQUFVLElBQUk7Z0JBQzFCO1lBQ0YsS0FBSztZQUNMLEtBQUs7Z0JBQ0gsTUFBTSxJQUFJLGFBQWEsa0JBQWtCLEtBQUs7Z0JBQzlDLHFCQUFxQjtnQkFDckIsZ0JBQWdCLElBQUksTUFBTSxHQUN0QixpQkFBaUIsVUFBVSxJQUFJLElBQUksS0FBSyxJQUN4QyxJQUFJLElBQUksQ0FDTixTQUFVLENBQUM7b0JBQ1QsT0FBTyxpQkFBaUIsVUFBVSxJQUFJO2dCQUN4QyxHQUNBLFlBQWE7Z0JBRW5CO1lBQ0YsS0FBSztZQUNMLEtBQUs7Z0JBQ0gsb0JBQW9CLFVBQVU7Z0JBQzlCO1lBQ0YsS0FBSztnQkFDSCxvQkFBb0IsVUFBVSxJQUFJLEtBQUs7Z0JBQ3ZDO1lBQ0YsS0FBSztnQkFDSCxvQkFBb0IsVUFBVSxJQUFJO2dCQUNsQztZQUNGLEtBQUs7Z0JBQ0gsbUJBQW1CLFVBQVUsSUFBSSxDQUFDO2dCQUNsQztZQUNGLEtBQUs7Z0JBQ0gsbUJBQW1CLFVBQVUsSUFBSSxDQUFDO2dCQUNsQztZQUNGLEtBQUs7Z0JBQ0gsV0FBVyxVQUFVLElBQUk7Z0JBQ3pCO1lBQ0Y7Z0JBQ0UsT0FBTyxNQUNILGlCQUFpQixVQUFVLE1BQzNCLGFBQWEsVUFBVSxJQUFJO1FBQ25DO0lBQ0Y7SUFDQSxTQUFTLG1CQUFtQixZQUFZLEVBQUUsV0FBVyxFQUFFLEtBQUs7UUFDMUQsSUFBSSxLQUFLLE1BQU0sYUFBYSxJQUFJLENBQUMsS0FBSyxJQUFJO1lBQ3hDLElBQUksV0FBVyxtQkFBbUIsZUFDaEMsSUFBSSxHQUNKLFdBQVcsWUFBWSxTQUFTO1lBQ2xDLGVBQWUsWUFBWSxNQUFNO1lBQ2pDLElBQ0UsSUFBSSxTQUFTLFlBQVksT0FBTyxFQUM5QixZQUFZLFlBQVksVUFBVSxFQUNsQyxTQUFTLFlBQVksT0FBTyxFQUM1QixjQUFjLE1BQU0sTUFBTSxFQUM1QixJQUFJLGFBRUo7Z0JBQ0EsSUFBSSxVQUFVLENBQUM7Z0JBQ2YsT0FBUTtvQkFDTixLQUFLO3dCQUNILFVBQVUsS0FBSyxDQUFDLElBQUk7d0JBQ3BCLE9BQU8sVUFDRixXQUFXLElBQ1gsZUFDQyxBQUFDLGdCQUFnQixJQUNqQixDQUFDLEtBQUssVUFBVSxVQUFVLEtBQUssVUFBVSxFQUFFO3dCQUNqRDtvQkFDRixLQUFLO3dCQUNILFdBQVcsS0FBSyxDQUFDLEVBQUU7d0JBQ25CLE9BQU8sWUFDUCxPQUFPLFlBQ1AsT0FBTyxZQUNQLFFBQVEsWUFDUixPQUFPLFlBQ1AsT0FBTyxZQUNQLFFBQVEsWUFDUixPQUFPLFlBQ1AsUUFBUSxZQUNSLE9BQU8sWUFDUCxRQUFRLFlBQ1IsT0FBTyxZQUNQLFFBQVEsWUFDUixPQUFPLFdBQ0gsQ0FBQyxBQUFDLFNBQVMsVUFBWSxXQUFXLEdBQUksR0FBRyxJQUN6QyxBQUFDLEtBQUssWUFBWSxLQUFLLFlBQ3JCLE9BQU8sWUFDUCxRQUFRLFlBQ1IsUUFBUSxXQUNSLENBQUMsQUFBQyxTQUFTLFVBQVksV0FBVyxHQUFJLEdBQUcsSUFDekMsQ0FBQyxBQUFDLFNBQVMsR0FBSyxXQUFXLENBQUU7d0JBQ25DO29CQUNGLEtBQUs7d0JBQ0gsVUFBVSxLQUFLLENBQUMsSUFBSTt3QkFDcEIsT0FBTyxVQUNGLFdBQVcsSUFDWCxZQUNDLEFBQUMsYUFBYSxJQUNkLENBQUMsS0FBSyxVQUFVLFVBQVUsS0FBSyxVQUFVLEVBQUU7d0JBQ2pEO29CQUNGLEtBQUs7d0JBQ0gsVUFBVSxNQUFNLE9BQU8sQ0FBQyxJQUFJO3dCQUM1QjtvQkFDRixLQUFLO3dCQUNGLFVBQVUsSUFBSSxXQUNiLFVBQVUsTUFBTSxNQUFNLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztnQkFDN0M7Z0JBQ0EsSUFBSSxTQUFTLE1BQU0sVUFBVSxHQUFHO2dCQUNoQyxJQUFJLENBQUMsSUFBSSxTQUNQLEFBQUMsWUFBWSxJQUFJLFdBQVcsTUFBTSxNQUFNLEVBQUUsUUFBUSxVQUFVLElBQzFELHFCQUNFLFVBQ0EsY0FDQSxRQUNBLFFBQ0EsWUFFRCxJQUFJLFNBQ0wsTUFBTSxZQUFZLEtBQ2pCLFlBQVksZUFBZSxTQUFTLFdBQVcsR0FDL0MsT0FBTyxNQUFNLEdBQUc7cUJBQ2hCO29CQUNILFFBQVEsSUFBSSxXQUFXLE1BQU0sTUFBTSxFQUFFLFFBQVEsTUFBTSxVQUFVLEdBQUc7b0JBQ2hFLE9BQU8sSUFBSSxDQUFDO29CQUNaLGFBQWEsTUFBTSxVQUFVO29CQUM3QjtnQkFDRjtZQUNGO1lBQ0EsWUFBWSxTQUFTLEdBQUc7WUFDeEIsWUFBWSxNQUFNLEdBQUc7WUFDckIsWUFBWSxPQUFPLEdBQUc7WUFDdEIsWUFBWSxVQUFVLEdBQUc7UUFDM0I7SUFDRjtJQUNBLFNBQVMsdUJBQXVCLFFBQVE7UUFDdEMsT0FBTyxTQUFVLEdBQUcsRUFBRSxLQUFLO1lBQ3pCLElBQUksYUFBYSxPQUFPLE9BQ3RCLE9BQU8saUJBQWlCLFVBQVUsSUFBSSxFQUFFLEtBQUs7WUFDL0MsSUFBSSxhQUFhLE9BQU8sU0FBUyxTQUFTLE9BQU87Z0JBQy9DLElBQUksS0FBSyxDQUFDLEVBQUUsS0FBSyxvQkFDZixHQUFHO29CQUNELElBQUksUUFBUSxLQUFLLENBQUMsRUFBRTtvQkFDcEIsTUFBTSxLQUFLLENBQUMsRUFBRTtvQkFDZCxJQUFJLFlBQVksS0FBSyxDQUFDLEVBQUU7b0JBQ3hCLFFBQVE7d0JBQ04sVUFBVTt3QkFDVixNQUFNLEtBQUssQ0FBQyxFQUFFO3dCQUNkLEtBQUssS0FBSyxDQUFDLEVBQUU7d0JBQ2IsT0FBTyxLQUFLLENBQUMsRUFBRTt3QkFDZixRQUFRLEtBQUssTUFBTSxRQUFRLE9BQU87b0JBQ3BDO29CQUNBLE9BQU8sY0FBYyxDQUFDLE9BQU8sT0FBTzt3QkFDbEMsWUFBWSxDQUFDO3dCQUNiLEtBQUs7b0JBQ1A7b0JBQ0EsTUFBTSxNQUFNLEdBQUcsQ0FBQztvQkFDaEIsT0FBTyxjQUFjLENBQUMsTUFBTSxNQUFNLEVBQUUsYUFBYTt3QkFDL0MsY0FBYyxDQUFDO3dCQUNmLFlBQVksQ0FBQzt3QkFDYixVQUFVLENBQUM7d0JBQ1gsT0FBTztvQkFDVDtvQkFDQSxPQUFPLGNBQWMsQ0FBQyxPQUFPLGNBQWM7d0JBQ3pDLGNBQWMsQ0FBQzt3QkFDZixZQUFZLENBQUM7d0JBQ2IsVUFBVSxDQUFDO3dCQUNYLE9BQU87b0JBQ1Q7b0JBQ0EsT0FBTyxjQUFjLENBQUMsT0FBTyxlQUFlO3dCQUMxQyxjQUFjLENBQUM7d0JBQ2YsWUFBWSxDQUFDO3dCQUNiLFVBQVUsQ0FBQzt3QkFDWCxPQUFPLEtBQUssTUFBTSxNQUFNLE9BQU87b0JBQ2pDO29CQUNBLE9BQU8sY0FBYyxDQUFDLE9BQU8sY0FBYzt3QkFDekMsY0FBYyxDQUFDO3dCQUNmLFlBQVksQ0FBQzt3QkFDYixVQUFVLENBQUM7d0JBQ1gsT0FBTztvQkFDVDtvQkFDQSxJQUFJLFNBQVMscUJBQXFCO3dCQUNoQyxZQUFZO3dCQUNaLHNCQUFzQixVQUFVLE1BQU07d0JBQ3RDLElBQUksVUFBVSxPQUFPLEVBQUU7NEJBQ3JCLE1BQU0sSUFBSSxhQUFhLFlBQVksTUFBTSxVQUFVLEtBQUs7NEJBQ3hELGtCQUFrQixVQUFVOzRCQUM1QixZQUFZO2dDQUNWLE1BQU0seUJBQXlCLE1BQU0sSUFBSSxLQUFLO2dDQUM5QyxPQUFPLE1BQU0sTUFBTTs0QkFDckI7NEJBQ0EsVUFBVSxVQUFVLEdBQUcsTUFBTSxXQUFXOzRCQUN4QyxzQkFDRSxDQUFDLFVBQVUsU0FBUyxHQUFHLE1BQU0sVUFBVTs0QkFDekMsSUFBSSxVQUFVLEdBQUc7Z0NBQUM7NkJBQVU7NEJBQzVCLFFBQVEsdUJBQXVCOzRCQUMvQixNQUFNO3dCQUNSO3dCQUNBLElBQUksSUFBSSxVQUFVLElBQUksRUFBRTs0QkFDdEIsTUFBTSxJQUFJLGFBQWEsV0FBVyxNQUFNOzRCQUN4QyxVQUFVLEtBQUssR0FBRzs0QkFDbEIsVUFBVSxLQUFLLEdBQUc7NEJBQ2xCLFFBQVEsa0JBQWtCLElBQUksQ0FBQyxNQUFNLFVBQVU7NEJBQy9DLElBQUksSUFBSSxDQUFDLE9BQU87NEJBQ2hCLFFBQVEsdUJBQXVCOzRCQUMvQixNQUFNO3dCQUNSO29CQUNGO29CQUNBLGtCQUFrQixVQUFVO2dCQUM5QjtnQkFDRixPQUFPO1lBQ1Q7WUFDQSxPQUFPO1FBQ1Q7SUFDRjtJQUNBLFNBQVMsTUFBTSxZQUFZO1FBQ3pCLGtCQUFrQixjQUFjLE1BQU07SUFDeEM7SUFDQSxTQUFTLHNDQUFzQyxhQUFhO1FBQzFELElBQUksY0FBYyxJQUFJLGVBQ3BCLFNBQVMsY0FBYyxTQUFTO1FBQ2xDLE9BQU8sU0FBVSxPQUFPO1lBQ3RCLE9BQU8sVUFDSCxPQUFPLEtBQUssS0FDWixPQUNHLEtBQUssQ0FBQyxZQUFZLE1BQU0sQ0FBQyxVQUFVLE9BQ25DLEtBQUssQ0FBQyxRQUFRLEtBQUs7UUFDNUI7SUFDRjtJQUNBLFNBQVMsMEJBQTBCLE9BQU87UUFDeEMsSUFBSSxlQUNGLFdBQ0EsS0FBSyxNQUFNLFFBQVEsWUFBWSxJQUMvQixLQUFLLE1BQU0sUUFBUSxZQUFZLENBQUMsUUFBUSxHQUNwQyxzQ0FBc0MsUUFBUSxZQUFZLENBQUMsUUFBUSxJQUNuRSxLQUFLO1FBQ1gsT0FBTyxJQUFJLGlCQUNULE1BQ0EsTUFDQSxNQUNBLFdBQVcsUUFBUSxVQUFVLEdBQUcsUUFBUSxVQUFVLEdBQUcsS0FBSyxHQUMxRCxLQUFLLEdBQ0wsS0FBSyxHQUNMLFdBQVcsUUFBUSxtQkFBbUIsR0FDbEMsUUFBUSxtQkFBbUIsR0FDM0IsS0FBSyxHQUNULFdBQVcsUUFBUSxnQkFBZ0IsR0FBRyxRQUFRLGdCQUFnQixHQUFHLEtBQUssR0FDdEUsVUFBVSxDQUFDLE1BQU0sUUFBUSxpQkFBaUIsR0FBRyxDQUFDLEdBQzlDLFdBQVcsUUFBUSxlQUFlLEdBQUcsUUFBUSxlQUFlLEdBQUcsS0FBSyxHQUNwRSxjQUNBLGFBQWE7SUFDakI7SUFDQSxTQUFTLGdDQUFnQyxpQkFBaUIsRUFBRSxNQUFNO1FBQ2hFLFNBQVMsU0FBUyxJQUFJO1lBQ3BCLElBQUksUUFBUSxLQUFLLEtBQUs7WUFDdEIsSUFBSSxLQUFLLElBQUksRUFBRSxNQUFNO2lCQUNoQjtnQkFDSCxJQUFJLGlCQUFpQixhQUNuQixtQkFDRSxtQkFDQSxhQUNBLElBQUksV0FBVztxQkFFZCxJQUFJLGFBQWEsT0FBTyxPQUFPO29CQUNsQyxJQUNHLEFBQUMsT0FBTyxhQUFjLEtBQUssTUFBTSxrQkFBa0IsSUFBSSxDQUFDLEtBQUssSUFDOUQ7d0JBQ0EsSUFDRSxJQUFJLFdBQVcsbUJBQW1CLG9CQUNoQyxJQUFJLEdBQ0osV0FBVyxLQUFLLFNBQVMsRUFDekIsUUFBUSxLQUFLLE1BQU0sRUFDbkIsU0FBUyxLQUFLLE9BQU8sRUFDckIsWUFBWSxLQUFLLFVBQVUsRUFDM0IsU0FBUyxLQUFLLE9BQU8sRUFDckIsY0FBYyxNQUFNLE1BQU0sRUFDNUIsSUFBSSxhQUVKOzRCQUNBLElBQUksVUFBVSxDQUFDOzRCQUNmLE9BQVE7Z0NBQ04sS0FBSztvQ0FDSCxVQUFVLE1BQU0sVUFBVSxDQUFDO29DQUMzQixPQUFPLFVBQ0YsV0FBVyxJQUNYLFFBQ0MsQUFBQyxTQUFTLElBQ1YsQ0FBQyxLQUFLLFVBQVUsVUFBVSxLQUFLLFVBQVUsRUFBRTtvQ0FDakQ7Z0NBQ0YsS0FBSztvQ0FDSCxXQUFXLE1BQU0sVUFBVSxDQUFDO29DQUM1QixPQUFPLFlBQ1AsT0FBTyxZQUNQLE9BQU8sWUFDUCxRQUFRLFlBQ1IsT0FBTyxZQUNQLE9BQU8sWUFDUCxRQUFRLFlBQ1IsT0FBTyxZQUNQLFFBQVEsWUFDUixPQUFPLFlBQ1AsUUFBUSxZQUNSLE9BQU8sWUFDUCxRQUFRLFlBQ1IsT0FBTyxXQUNILENBQUMsQUFBQyxTQUFTLFVBQVksV0FBVyxHQUFJLEdBQUcsSUFDekMsQUFBQyxLQUFLLFlBQVksS0FBSyxZQUNyQixRQUFRLFlBQ1IsUUFBUSxXQUNSLENBQUMsQUFBQyxTQUFTLFVBQVksV0FBVyxHQUFJLEdBQUcsSUFDekMsQ0FBQyxBQUFDLFNBQVMsR0FBSyxXQUFXLENBQUU7b0NBQ25DO2dDQUNGLEtBQUs7b0NBQ0gsVUFBVSxNQUFNLFVBQVUsQ0FBQztvQ0FDM0IsT0FBTyxVQUNGLFdBQVcsSUFDWCxZQUNDLEFBQUMsYUFBYSxJQUNkLENBQUMsS0FBSyxVQUFVLFVBQVUsS0FBSyxVQUFVLEVBQUU7b0NBQ2pEO2dDQUNGLEtBQUs7b0NBQ0gsVUFBVSxNQUFNLE9BQU8sQ0FBQyxNQUFNO29DQUM5QjtnQ0FDRixLQUFLO29DQUNILElBQUksT0FBTyxRQUNULE1BQU0sTUFDSjtvQ0FFSixJQUNFLFlBQVksTUFBTSxNQUFNLElBQ3hCLE1BQU0sTUFBTSxHQUFHLElBQUksV0FFbkIsTUFBTSxNQUNKO29DQUVKLFVBQVUsTUFBTSxNQUFNOzRCQUMxQjs0QkFDQSxJQUFJLENBQUMsSUFBSSxTQUFTO2dDQUNoQixJQUFJLElBQUksT0FBTyxNQUFNLEVBQ25CLE1BQU0sTUFDSjtnQ0FFSixJQUFJLE1BQU0sS0FBSyxDQUFDLEdBQUc7Z0NBQ25CLHFCQUFxQixVQUFVLE9BQU8sUUFBUTtnQ0FDOUMsSUFBSTtnQ0FDSixNQUFNLFlBQVk7Z0NBQ2xCLFlBQVksUUFBUSxTQUFTLFdBQVc7Z0NBQ3hDLE9BQU8sTUFBTSxHQUFHOzRCQUNsQixPQUFPLElBQUksTUFBTSxNQUFNLEtBQUssR0FDMUIsTUFBTSxNQUNKO3dCQUVOO3dCQUNBLEtBQUssU0FBUyxHQUFHO3dCQUNqQixLQUFLLE1BQU0sR0FBRzt3QkFDZCxLQUFLLE9BQU8sR0FBRzt3QkFDZixLQUFLLFVBQVUsR0FBRztvQkFDcEI7Z0JBQ0YsT0FBTyxtQkFBbUIsbUJBQW1CLGFBQWE7Z0JBQzFELE9BQU8sT0FBTyxJQUFJLEdBQUcsSUFBSSxDQUFDLFVBQVUsS0FBSyxDQUFDO1lBQzVDO1FBQ0Y7UUFDQSxTQUFTLE1BQU0sQ0FBQztZQUNkLGtCQUFrQixtQkFBbUI7UUFDdkM7UUFDQSxJQUFJLGNBQWMscUJBQ2hCLFNBQVMsT0FBTyxTQUFTO1FBQzNCLE9BQU8sSUFBSSxHQUFHLElBQUksQ0FBQyxVQUFVLEtBQUssQ0FBQztJQUNyQztJQUNBLFNBQVMsdUJBQXVCLFFBQVEsRUFBRSxNQUFNLEVBQUUsaUJBQWlCO1FBQ2pFLFNBQVMsU0FBUyxLQUFLO1lBQ3JCLElBQUksUUFBUSxNQUFNLEtBQUs7WUFDdkIsSUFBSSxNQUFNLElBQUksRUFBRSxxQkFBcUIsTUFBTTtpQkFFekMsT0FDRSxtQkFBbUIsVUFBVSxhQUFhLFFBQzFDLE9BQU8sSUFBSSxHQUFHLElBQUksQ0FBQyxVQUFVLEtBQUssQ0FBQztRQUV6QztRQUNBLFNBQVMsTUFBTSxDQUFDO1lBQ2Qsa0JBQWtCLFVBQVU7UUFDOUI7UUFDQSxJQUFJLGNBQWMscUJBQ2hCLFNBQVMsT0FBTyxTQUFTO1FBQzNCLE9BQU8sSUFBSSxHQUFHLElBQUksQ0FBQyxVQUFVLEtBQUssQ0FBQztJQUNyQztJQUNBLElBQUksdUhBQ0YsOEhBQ0EsaUJBQWlCO1FBQUUsUUFBUSxDQUFDO0lBQUUsR0FDOUIsT0FBTyxTQUFTLFNBQVMsQ0FBQyxJQUFJLEVBQzlCLGFBQWEsSUFBSSxPQUNqQiwwQkFDRSxTQUFTLDREQUE0RCxFQUN2RSxxQkFBcUIsT0FBTyxHQUFHLENBQUMsK0JBQ2hDLG9CQUFvQixPQUFPLEdBQUcsQ0FBQyxpQkFDL0Isc0JBQXNCLE9BQU8sR0FBRyxDQUFDLG1CQUNqQyx5QkFBeUIsT0FBTyxHQUFHLENBQUMsc0JBQ3BDLHNCQUFzQixPQUFPLEdBQUcsQ0FBQyxtQkFDakMsc0JBQXNCLE9BQU8sR0FBRyxDQUFDLG1CQUNqQyxxQkFBcUIsT0FBTyxHQUFHLENBQUMsa0JBQ2hDLHlCQUF5QixPQUFPLEdBQUcsQ0FBQyxzQkFDcEMsc0JBQXNCLE9BQU8sR0FBRyxDQUFDLG1CQUNqQywyQkFBMkIsT0FBTyxHQUFHLENBQUMsd0JBQ3RDLGtCQUFrQixPQUFPLEdBQUcsQ0FBQyxlQUM3QixrQkFBa0IsT0FBTyxHQUFHLENBQUMsZUFDN0Isc0JBQXNCLE9BQU8sR0FBRyxDQUFDLG1CQUNqQyx3QkFBd0IsT0FBTyxRQUFRLEVBQ3ZDLGlCQUFpQixPQUFPLGFBQWEsRUFDckMsY0FBYyxNQUFNLE9BQU8sRUFDM0IsaUJBQWlCLE9BQU8sY0FBYyxFQUN0QyxrQkFBa0IsSUFBSSxXQUN0QixxQkFBcUIsSUFBSSxXQUN6Qix1QkFBdUIsT0FBTyxHQUFHLENBQUMsMkJBQ2xDLGtCQUFrQixPQUFPLFNBQVMsRUFDbEMsd0JBQXdCLElBQUksV0FDNUIsd0JBQXdCLEdBQ3hCLGdCQUNFLHVFQUNGLDZCQUE2Qiw4QkFDN0IseUJBQXlCLE9BQU8sR0FBRyxDQUFDLDJCQUNwQyxRQUNBO0lBQ0YsSUFBSSxDQUFDLGVBQWUsT0FBTyxVQUFVLFVBQVUsR0FBRztJQUNsRCxJQUFJLDRCQUNBLE1BQU0sK0RBQStELEVBQ3ZFLHVCQUNFLE1BQU0sK0RBQStELElBQ3JFO0lBQ0osYUFBYSxTQUFTLEdBQUcsT0FBTyxNQUFNLENBQUMsUUFBUSxTQUFTO0lBQ3hELGFBQWEsU0FBUyxDQUFDLElBQUksR0FBRyxTQUFVLE9BQU8sRUFBRSxNQUFNO1FBQ3JELE9BQVEsSUFBSSxDQUFDLE1BQU07WUFDakIsS0FBSztnQkFDSCxxQkFBcUIsSUFBSTtnQkFDekI7WUFDRixLQUFLO2dCQUNILHNCQUFzQixJQUFJO1FBQzlCO1FBQ0EsT0FBUSxJQUFJLENBQUMsTUFBTTtZQUNqQixLQUFLO2dCQUNILGVBQWUsT0FBTyxXQUFXLFFBQVEsSUFBSSxDQUFDLEtBQUs7Z0JBQ25EO1lBQ0YsS0FBSztZQUNMLEtBQUs7Z0JBQ0gsZUFBZSxPQUFPLFdBQ3BCLENBQUMsU0FBUyxJQUFJLENBQUMsS0FBSyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssR0FBRyxFQUFFLEdBQ3hDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFFBQVE7Z0JBQzFCLGVBQWUsT0FBTyxVQUNwQixDQUFDLFNBQVMsSUFBSSxDQUFDLE1BQU0sSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLEdBQUcsRUFBRSxHQUMxQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPO2dCQUMxQjtZQUNGLEtBQUs7Z0JBQ0g7WUFDRjtnQkFDRSxlQUFlLE9BQU8sVUFBVSxPQUFPLElBQUksQ0FBQyxNQUFNO1FBQ3REO0lBQ0Y7SUFDQSxJQUFJLHVCQUNBLGVBQWUsT0FBTyx1QkFDbEIsSUFBSSxxQkFBcUIsdUJBQ3pCLE1BQ04sc0JBQXNCLE1BQ3RCLHFCQUFxQixDQUFDLENBQUMsUUFBUSxVQUFVLEVBQ3pDLG9CQUFvQixJQUFJLE9BQ3hCLGtCQUFrQixHQUNsQix5QkFBeUI7UUFDdkIsMEJBQTBCLFNBQVUsUUFBUSxFQUFFLEtBQUssRUFBRSxlQUFlO1lBQ2xFLE9BQU8sbUJBQ0wsVUFDQSxPQUNBLGlCQUNBLENBQUMsR0FDRDtRQUVKO0lBQ0YsR0FDQSw4QkFDRSx1QkFBdUIsd0JBQXdCLENBQUMsSUFBSSxDQUNsRCx5QkFFSixvQkFBb0IsTUFDcEIsNkJBQTZCO1FBQzNCLDBCQUEwQixTQUN4QixRQUFRLEVBQ1IsVUFBVSxFQUNWLFVBQVUsRUFDVixLQUFLLEVBQ0wsR0FBRyxFQUNILElBQUk7WUFFSixJQUFJLFlBQVkscUJBQXFCLGVBQWU7WUFDcEQscUJBQXFCLGVBQWUsR0FBRztZQUN2QyxvQkFBb0IsU0FBUyxRQUFRLFNBQVMsZUFBZSxHQUFHO1lBQ2hFLElBQUk7Z0JBQ0YsR0FBRztvQkFDRCxJQUFJLFNBQVM7b0JBQ2IsT0FBUTt3QkFDTixLQUFLO3dCQUNMLEtBQUs7d0JBQ0wsS0FBSzt3QkFDTCxLQUFLOzRCQUNILElBQUksMkJBQTJCLEtBQUssS0FBSyxDQUN2QyxPQUFPLENBQUMsV0FBVyxFQUNuQjtnQ0FBQzs2QkFBUSxDQUFDLE1BQU0sQ0FBQzs0QkFFbkIsTUFBTTt3QkFDUixLQUFLOzRCQUNILFNBQVM7b0JBQ2I7b0JBQ0EsSUFBSSxVQUFVLEtBQUssS0FBSyxDQUFDO29CQUN6QixhQUFhLE9BQU8sT0FBTyxDQUFDLE9BQU8sR0FDL0IsUUFBUSxNQUFNLENBQ1osUUFDQSxHQUNBLFlBQVksT0FBTyxDQUFDLE9BQU8sRUFDM0IsNkpBQ0EsTUFBTSxNQUFNLEtBQ1osTUFFRixRQUFRLE1BQU0sQ0FDWixRQUNBLEdBQ0EsV0FDQSw2SkFDQSxNQUFNLE1BQU0sS0FDWjtvQkFFTixRQUFRLE9BQU8sQ0FBQztvQkFDaEIsMkJBQTJCLEtBQUssS0FBSyxDQUNuQyxPQUFPLENBQUMsV0FBVyxFQUNuQjtnQkFFSjtnQkFDQSxJQUFJLFlBQVksbUJBQ2QsVUFDQSxZQUNBLEtBQ0EsQ0FBQyxHQUNEO2dCQUVGLElBQUksUUFBUSxPQUFPO29CQUNqQixJQUFJLE9BQU8sbUJBQW1CLFVBQVU7b0JBQ3hDLG9CQUFvQixVQUFVO29CQUM5QixJQUFJLFNBQVMsTUFBTTt3QkFDakIsS0FBSyxHQUFHLENBQUM7d0JBQ1Q7b0JBQ0Y7Z0JBQ0Y7Z0JBQ0EsSUFBSSxXQUFXLFlBQVksVUFBVTtnQkFDckMsUUFBUSxXQUFXLFNBQVMsR0FBRyxDQUFDLGFBQWE7WUFDL0MsU0FBVTtnQkFDUCxvQkFBb0IsTUFDbEIscUJBQXFCLGVBQWUsR0FBRztZQUM1QztRQUNGO0lBQ0YsR0FDQSxrQ0FDRSwyQkFBMkIsd0JBQXdCLENBQUMsSUFBSSxDQUN0RDtJQUVOLENBQUMsU0FBVSxTQUFTO1FBQ2xCLElBQUksZ0JBQWdCLE9BQU8sZ0NBQWdDLE9BQU8sQ0FBQztRQUNuRSxJQUFJLE9BQU87UUFDWCxJQUFJLEtBQUssVUFBVSxJQUFJLENBQUMsS0FBSyxjQUFjLEVBQUUsT0FBTyxDQUFDO1FBQ3JELElBQUk7WUFDRixLQUFLLE1BQU0sQ0FBQztRQUNkLEVBQUUsT0FBTyxLQUFLO1lBQ1osUUFBUSxLQUFLLENBQUMsbURBQW1EO1FBQ25FO1FBQ0EsT0FBTyxLQUFLLFFBQVEsR0FBRyxDQUFDLElBQUksQ0FBQztJQUMvQixDQUFDLEVBQUU7UUFDRCxZQUFZO1FBQ1osU0FBUztRQUNULHFCQUFxQjtRQUNyQixzQkFBc0I7UUFDdEIsbUJBQW1CO1FBQ25CLHlCQUF5QjtZQUN2QixPQUFPO1FBQ1Q7SUFDRjtJQUNBLFFBQVEsZUFBZSxHQUFHLFNBQVUsa0JBQWtCLEVBQUUsT0FBTztRQUM3RCxJQUFJLFdBQVcsMEJBQTBCO1FBQ3pDLG1CQUFtQixJQUFJLENBQ3JCLFNBQVUsQ0FBQztZQUNULFdBQVcsUUFBUSxZQUFZLElBQUksUUFBUSxZQUFZLENBQUMsUUFBUSxHQUM1RCxDQUFDLGdDQUNDLFVBQ0EsUUFBUSxZQUFZLENBQUMsUUFBUSxHQUUvQix1QkFBdUIsVUFBVSxFQUFFLElBQUksRUFBRSxDQUFDLEVBQUUsSUFDNUMsdUJBQXVCLFVBQVUsRUFBRSxJQUFJLEVBQUUsQ0FBQztRQUNoRCxHQUNBLFNBQVUsQ0FBQztZQUNULGtCQUFrQixVQUFVO1FBQzlCO1FBRUYsT0FBTyxRQUFRO0lBQ2pCO0lBQ0EsUUFBUSx3QkFBd0IsR0FBRyxTQUFVLE1BQU0sRUFBRSxPQUFPO1FBQzFELElBQUksV0FBVywwQkFBMEI7UUFDekMsV0FBVyxRQUFRLFlBQVksSUFBSSxRQUFRLFlBQVksQ0FBQyxRQUFRLEdBQzVELENBQUMsZ0NBQ0MsVUFDQSxRQUFRLFlBQVksQ0FBQyxRQUFRLEdBRS9CLHVCQUF1QixVQUFVLFFBQVEsQ0FBQyxFQUFFLElBQzVDLHVCQUF1QixVQUFVLFFBQVEsQ0FBQztRQUM5QyxPQUFPLFFBQVE7SUFDakI7SUFDQSxRQUFRLHFCQUFxQixHQUFHLFNBQzlCLEVBQUUsRUFDRixVQUFVLEVBQ1YsZ0JBQWdCLEVBQ2hCLGdCQUFnQixFQUNoQixZQUFZO1FBRVosU0FBUztZQUNQLElBQUksT0FBTyxNQUFNLFNBQVMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDO1lBQ3RDLE9BQU8sV0FBVyxJQUFJO1FBQ3hCO1FBQ0EsSUFBSSxXQUFXLG1CQUFtQixNQUFNO1FBQ3hDLElBQUksU0FBUyxVQUFVO1lBQ3JCLG1CQUFtQixRQUFRLENBQUMsRUFBRTtZQUM5QixJQUFJLE9BQU8sUUFBUSxDQUFDLEVBQUU7WUFDdEIsV0FBVyxRQUFRLENBQUMsRUFBRTtZQUN0QixtQkFDRSxRQUFRLG1CQUNKLE9BQ0EsaUJBQWlCLGtCQUFrQjtZQUN6QyxTQUFTLHlCQUNQLGdCQUFnQixJQUNoQixrQkFDQSxrQkFDQSxNQUNBLFVBQ0EsVUFDQTtRQUVKO1FBQ0EsNkJBQTZCLFFBQVEsSUFBSTtRQUN6QyxPQUFPO0lBQ1Q7SUFDQSxRQUFRLDJCQUEyQixHQUFHO1FBQ3BDLE9BQU8sSUFBSTtJQUNiO0lBQ0EsUUFBUSxXQUFXLEdBQUcsU0FBVSxLQUFLLEVBQUUsT0FBTztRQUM1QyxPQUFPLElBQUksUUFBUSxTQUFVLE9BQU8sRUFBRSxNQUFNO1lBQzFDLElBQUksUUFBUSxhQUNWLE9BQ0EsSUFDQSxXQUFXLFFBQVEsbUJBQW1CLEdBQ2xDLFFBQVEsbUJBQW1CLEdBQzNCLEtBQUssR0FDVCxTQUNBO1lBRUYsSUFBSSxXQUFXLFFBQVEsTUFBTSxFQUFFO2dCQUM3QixJQUFJLFNBQVMsUUFBUSxNQUFNO2dCQUMzQixJQUFJLE9BQU8sT0FBTyxFQUFFLE1BQU0sT0FBTyxNQUFNO3FCQUNsQztvQkFDSCxJQUFJLFdBQVc7d0JBQ2IsTUFBTSxPQUFPLE1BQU07d0JBQ25CLE9BQU8sbUJBQW1CLENBQUMsU0FBUztvQkFDdEM7b0JBQ0EsT0FBTyxnQkFBZ0IsQ0FBQyxTQUFTO2dCQUNuQztZQUNGO1FBQ0Y7SUFDRjtJQUNBLFFBQVEsdUJBQXVCLEdBQUcsU0FBVSxTQUFTLEVBQUUsRUFBRTtRQUN2RCw2QkFBNkIsV0FBVyxJQUFJO1FBQzVDLE9BQU87SUFDVDtBQUNGIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDQ3NDIsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LXNlcnZlci1kb20tdHVyYm9wYWNrL2NsaWVudC5icm93c2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1zZXJ2ZXItZG9tLXR1cmJvcGFjay1jbGllbnQuYnJvd3Nlci5wcm9kdWN0aW9uLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LXNlcnZlci1kb20tdHVyYm9wYWNrLWNsaWVudC5icm93c2VyLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBRUk7QUFGSjtBQUVBOztLQUVPO0lBQ0wsT0FBTyxPQUFPO0FBQ2hCIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDQ3NTUsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LXNlcnZlci1kb20tdHVyYm9wYWNrL2NsaWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jbGllbnQuYnJvd3NlcicpO1xuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUVBLE9BQU8sT0FBTyIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA0NzYxLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9zdHJpcC1hbnNpL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIigoKT0+e1widXNlIHN0cmljdFwiO3ZhciBlPXs1MTE6ZT0+e2UuZXhwb3J0cz0oe29ubHlGaXJzdDplPWZhbHNlfT17fSk9Pntjb25zdCByPVtcIltcXFxcdTAwMUJcXFxcdTAwOUJdW1tcXFxcXSgpIzs/XSooPzooPzooPzooPzo7Wy1hLXpBLVpcXFxcZFxcXFwvIyYuOj0/JUB+X10rKSp8W2EtekEtWlxcXFxkXSsoPzo7Wy1hLXpBLVpcXFxcZFxcXFwvIyYuOj0/JUB+X10qKSopP1xcXFx1MDAwNylcIixcIig/Oig/OlxcXFxkezEsNH0oPzo7XFxcXGR7MCw0fSkqKT9bXFxcXGRBLVBSLVRaY2YtbnRxcnk9Pjx+XSkpXCJdLmpvaW4oXCJ8XCIpO3JldHVybiBuZXcgUmVnRXhwKHIsZT91bmRlZmluZWQ6XCJnXCIpfX0sNTMyOihlLHIsXyk9Pntjb25zdCB0PV8oNTExKTtlLmV4cG9ydHM9ZT0+dHlwZW9mIGU9PT1cInN0cmluZ1wiP2UucmVwbGFjZSh0KCksXCJcIik6ZX19O3ZhciByPXt9O2Z1bmN0aW9uIF9fbmNjd3Bja19yZXF1aXJlX18oXyl7dmFyIHQ9cltfXTtpZih0IT09dW5kZWZpbmVkKXtyZXR1cm4gdC5leHBvcnRzfXZhciBhPXJbX109e2V4cG9ydHM6e319O3ZhciBuPXRydWU7dHJ5e2VbX10oYSxhLmV4cG9ydHMsX19uY2N3cGNrX3JlcXVpcmVfXyk7bj1mYWxzZX1maW5hbGx5e2lmKG4pZGVsZXRlIHJbX119cmV0dXJuIGEuZXhwb3J0c31pZih0eXBlb2YgX19uY2N3cGNrX3JlcXVpcmVfXyE9PVwidW5kZWZpbmVkXCIpX19uY2N3cGNrX3JlcXVpcmVfXy5hYj1fX2Rpcm5hbWUrXCIvXCI7dmFyIF89X19uY2N3cGNrX3JlcXVpcmVfXyg1MzIpO21vZHVsZS5leHBvcnRzPV99KSgpOyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxDQUFDO0lBQUs7SUFBYSxJQUFJLElBQUU7UUFBQyxLQUFJLENBQUE7WUFBSSxFQUFFLE9BQU8sR0FBQztvQkFBQyxFQUFDLFdBQVUsSUFBRSxLQUFLLEVBQUMsb0VBQUMsQ0FBQztnQkFBSyxNQUFNLElBQUU7b0JBQUM7b0JBQStIO2lCQUEyRCxDQUFDLElBQUksQ0FBQztnQkFBSyxPQUFPLElBQUksT0FBTyxHQUFFLElBQUUsWUFBVTtZQUFJO1FBQUM7UUFBRSxLQUFJLENBQUMsR0FBRSxHQUFFO1lBQUssTUFBTSxJQUFFLEVBQUU7WUFBSyxFQUFFLE9BQU8sR0FBQyxDQUFBLElBQUcsT0FBTyxNQUFJLFdBQVMsRUFBRSxPQUFPLENBQUMsS0FBSSxNQUFJO1FBQUM7SUFBQztJQUFFLElBQUksSUFBRSxDQUFDO0lBQUUsU0FBUyxvQkFBb0IsQ0FBQztRQUFFLElBQUksSUFBRSxDQUFDLENBQUMsRUFBRTtRQUFDLElBQUcsTUFBSSxXQUFVO1lBQUMsT0FBTyxFQUFFLE9BQU87UUFBQTtRQUFDLElBQUksSUFBRSxDQUFDLENBQUMsRUFBRSxHQUFDO1lBQUMsU0FBUSxDQUFDO1FBQUM7UUFBRSxJQUFJLElBQUU7UUFBSyxJQUFHO1lBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFFLEVBQUUsT0FBTyxFQUFDO1lBQXFCLElBQUU7UUFBSyxTQUFRO1lBQUMsSUFBRyxHQUFFLE9BQU8sQ0FBQyxDQUFDLEVBQUU7UUFBQTtRQUFDLE9BQU8sRUFBRSxPQUFPO0lBQUE7SUFBQyxJQUFHLE9BQU8sd0JBQXNCLGFBQVksb0JBQW9CLEVBQUUsR0FBQyx1RkFBVTtJQUFJLElBQUksSUFBRSxvQkFBb0I7SUFBSyxPQUFPLE9BQU8sR0FBQztBQUFDLENBQUMiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fV0KfQ==