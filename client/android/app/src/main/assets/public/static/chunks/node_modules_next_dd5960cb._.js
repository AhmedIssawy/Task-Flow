(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push([typeof document === "object" ? document.currentScript : undefined, {

"[project]/node_modules/next/dist/compiled/@edge-runtime/cookies/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
// src/index.ts
var src_exports = {};
__export(src_exports, {
    RequestCookies: ()=>RequestCookies,
    ResponseCookies: ()=>ResponseCookies,
    parseCookie: ()=>parseCookie,
    parseSetCookie: ()=>parseSetCookie,
    stringifyCookie: ()=>stringifyCookie
});
module.exports = __toCommonJS(src_exports);
// src/serialize.ts
function stringifyCookie(c) {
    var _a;
    const attrs = [
        "path" in c && c.path && "Path=".concat(c.path),
        "expires" in c && (c.expires || c.expires === 0) && "Expires=".concat((typeof c.expires === "number" ? new Date(c.expires) : c.expires).toUTCString()),
        "maxAge" in c && typeof c.maxAge === "number" && "Max-Age=".concat(c.maxAge),
        "domain" in c && c.domain && "Domain=".concat(c.domain),
        "secure" in c && c.secure && "Secure",
        "httpOnly" in c && c.httpOnly && "HttpOnly",
        "sameSite" in c && c.sameSite && "SameSite=".concat(c.sameSite),
        "partitioned" in c && c.partitioned && "Partitioned",
        "priority" in c && c.priority && "Priority=".concat(c.priority)
    ].filter(Boolean);
    const stringified = "".concat(c.name, "=").concat(encodeURIComponent((_a = c.value) != null ? _a : ""));
    return attrs.length === 0 ? stringified : "".concat(stringified, "; ").concat(attrs.join("; "));
}
function parseCookie(cookie) {
    const map = /* @__PURE__ */ new Map();
    for (const pair of cookie.split(/; */)){
        if (!pair) continue;
        const splitAt = pair.indexOf("=");
        if (splitAt === -1) {
            map.set(pair, "true");
            continue;
        }
        const [key, value] = [
            pair.slice(0, splitAt),
            pair.slice(splitAt + 1)
        ];
        try {
            map.set(key, decodeURIComponent(value != null ? value : "true"));
        } catch (e) {}
    }
    return map;
}
function parseSetCookie(setCookie) {
    if (!setCookie) {
        return void 0;
    }
    const [[name, value], ...attributes] = parseCookie(setCookie);
    const { domain, expires, httponly, maxage, path, samesite, secure, partitioned, priority } = Object.fromEntries(attributes.map((param)=>{
        let [key, value2] = param;
        return [
            key.toLowerCase().replace(/-/g, ""),
            value2
        ];
    }));
    const cookie = {
        name,
        value: decodeURIComponent(value),
        domain,
        ...expires && {
            expires: new Date(expires)
        },
        ...httponly && {
            httpOnly: true
        },
        ...typeof maxage === "string" && {
            maxAge: Number(maxage)
        },
        path,
        ...samesite && {
            sameSite: parseSameSite(samesite)
        },
        ...secure && {
            secure: true
        },
        ...priority && {
            priority: parsePriority(priority)
        },
        ...partitioned && {
            partitioned: true
        }
    };
    return compact(cookie);
}
function compact(t) {
    const newT = {};
    for(const key in t){
        if (t[key]) {
            newT[key] = t[key];
        }
    }
    return newT;
}
var SAME_SITE = [
    "strict",
    "lax",
    "none"
];
function parseSameSite(string) {
    string = string.toLowerCase();
    return SAME_SITE.includes(string) ? string : void 0;
}
var PRIORITY = [
    "low",
    "medium",
    "high"
];
function parsePriority(string) {
    string = string.toLowerCase();
    return PRIORITY.includes(string) ? string : void 0;
}
function splitCookiesString(cookiesString) {
    if (!cookiesString) return [];
    var cookiesStrings = [];
    var pos = 0;
    var start;
    var ch;
    var lastComma;
    var nextStart;
    var cookiesSeparatorFound;
    function skipWhitespace() {
        while(pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))){
            pos += 1;
        }
        return pos < cookiesString.length;
    }
    function notSpecialChar() {
        ch = cookiesString.charAt(pos);
        return ch !== "=" && ch !== ";" && ch !== ",";
    }
    while(pos < cookiesString.length){
        start = pos;
        cookiesSeparatorFound = false;
        while(skipWhitespace()){
            ch = cookiesString.charAt(pos);
            if (ch === ",") {
                lastComma = pos;
                pos += 1;
                skipWhitespace();
                nextStart = pos;
                while(pos < cookiesString.length && notSpecialChar()){
                    pos += 1;
                }
                if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
                    cookiesSeparatorFound = true;
                    pos = nextStart;
                    cookiesStrings.push(cookiesString.substring(start, lastComma));
                    start = pos;
                } else {
                    pos = lastComma + 1;
                }
            } else {
                pos += 1;
            }
        }
        if (!cookiesSeparatorFound || pos >= cookiesString.length) {
            cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
        }
    }
    return cookiesStrings;
}
// src/request-cookies.ts
var RequestCookies = class {
    [Symbol.iterator]() {
        return this._parsed[Symbol.iterator]();
    }
    /**
   * The amount of cookies received from the client
   */ get size() {
        return this._parsed.size;
    }
    get() {
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        const name = typeof args[0] === "string" ? args[0] : args[0].name;
        return this._parsed.get(name);
    }
    getAll() {
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        var _a;
        const all = Array.from(this._parsed);
        if (!args.length) {
            return all.map((param)=>{
                let [_, value] = param;
                return value;
            });
        }
        const name = typeof args[0] === "string" ? args[0] : (_a = args[0]) == null ? void 0 : _a.name;
        return all.filter((param)=>{
            let [n] = param;
            return n === name;
        }).map((param)=>{
            let [_, value] = param;
            return value;
        });
    }
    has(name) {
        return this._parsed.has(name);
    }
    set() {
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        const [name, value] = args.length === 1 ? [
            args[0].name,
            args[0].value
        ] : args;
        const map = this._parsed;
        map.set(name, {
            name,
            value
        });
        this._headers.set("cookie", Array.from(map).map((param)=>{
            let [_, value2] = param;
            return stringifyCookie(value2);
        }).join("; "));
        return this;
    }
    /**
   * Delete the cookies matching the passed name or names in the request.
   */ delete(names) {
        const map = this._parsed;
        const result = !Array.isArray(names) ? map.delete(names) : names.map((name)=>map.delete(name));
        this._headers.set("cookie", Array.from(map).map((param)=>{
            let [_, value] = param;
            return stringifyCookie(value);
        }).join("; "));
        return result;
    }
    /**
   * Delete all the cookies in the cookies in the request.
   */ clear() {
        this.delete(Array.from(this._parsed.keys()));
        return this;
    }
    /**
   * Format the cookies in the request as a string for logging
   */ [Symbol.for("edge-runtime.inspect.custom")]() {
        return "RequestCookies ".concat(JSON.stringify(Object.fromEntries(this._parsed)));
    }
    toString() {
        return [
            ...this._parsed.values()
        ].map((v)=>"".concat(v.name, "=").concat(encodeURIComponent(v.value))).join("; ");
    }
    constructor(requestHeaders){
        /** @internal */ this._parsed = /* @__PURE__ */ new Map();
        this._headers = requestHeaders;
        const header = requestHeaders.get("cookie");
        if (header) {
            const parsed = parseCookie(header);
            for (const [name, value] of parsed){
                this._parsed.set(name, {
                    name,
                    value
                });
            }
        }
    }
};
// src/response-cookies.ts
var ResponseCookies = class {
    /**
   * {@link https://wicg.github.io/cookie-store/#CookieStore-get CookieStore#get} without the Promise.
   */ get() {
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        const key = typeof args[0] === "string" ? args[0] : args[0].name;
        return this._parsed.get(key);
    }
    /**
   * {@link https://wicg.github.io/cookie-store/#CookieStore-getAll CookieStore#getAll} without the Promise.
   */ getAll() {
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        var _a;
        const all = Array.from(this._parsed.values());
        if (!args.length) {
            return all;
        }
        const key = typeof args[0] === "string" ? args[0] : (_a = args[0]) == null ? void 0 : _a.name;
        return all.filter((c)=>c.name === key);
    }
    has(name) {
        return this._parsed.has(name);
    }
    /**
   * {@link https://wicg.github.io/cookie-store/#CookieStore-set CookieStore#set} without the Promise.
   */ set() {
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        const [name, value, cookie] = args.length === 1 ? [
            args[0].name,
            args[0].value,
            args[0]
        ] : args;
        const map = this._parsed;
        map.set(name, normalizeCookie({
            name,
            value,
            ...cookie
        }));
        replace(map, this._headers);
        return this;
    }
    /**
   * {@link https://wicg.github.io/cookie-store/#CookieStore-delete CookieStore#delete} without the Promise.
   */ delete() {
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        const [name, options] = typeof args[0] === "string" ? [
            args[0]
        ] : [
            args[0].name,
            args[0]
        ];
        return this.set({
            ...options,
            name,
            value: "",
            expires: /* @__PURE__ */ new Date(0)
        });
    }
    [Symbol.for("edge-runtime.inspect.custom")]() {
        return "ResponseCookies ".concat(JSON.stringify(Object.fromEntries(this._parsed)));
    }
    toString() {
        return [
            ...this._parsed.values()
        ].map(stringifyCookie).join("; ");
    }
    constructor(responseHeaders){
        /** @internal */ this._parsed = /* @__PURE__ */ new Map();
        var _a, _b, _c;
        this._headers = responseHeaders;
        const setCookie = (_c = (_b = (_a = responseHeaders.getSetCookie) == null ? void 0 : _a.call(responseHeaders)) != null ? _b : responseHeaders.get("set-cookie")) != null ? _c : [];
        const cookieStrings = Array.isArray(setCookie) ? setCookie : splitCookiesString(setCookie);
        for (const cookieString of cookieStrings){
            const parsed = parseSetCookie(cookieString);
            if (parsed) this._parsed.set(parsed.name, parsed);
        }
    }
};
function replace(bag, headers) {
    headers.delete("set-cookie");
    for (const [, value] of bag){
        const serialized = stringifyCookie(value);
        headers.append("set-cookie", serialized);
    }
}
function normalizeCookie() {
    let cookie = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
        name: "",
        value: ""
    };
    if (typeof cookie.expires === "number") {
        cookie.expires = new Date(cookie.expires);
    }
    if (cookie.maxAge) {
        cookie.expires = new Date(Date.now() + cookie.maxAge * 1e3);
    }
    if (cookie.path === null || cookie.path === void 0) {
        cookie.path = "/";
    }
    return cookie;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    RequestCookies,
    ResponseCookies,
    parseCookie,
    parseSetCookie,
    stringifyCookie
});
}}),
"[project]/node_modules/next/dist/server/web/spec-extension/cookies.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    RequestCookies: null,
    ResponseCookies: null,
    stringifyCookie: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    RequestCookies: function() {
        return _cookies.RequestCookies;
    },
    ResponseCookies: function() {
        return _cookies.ResponseCookies;
    },
    stringifyCookie: function() {
        return _cookies.stringifyCookie;
    }
});
const _cookies = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/@edge-runtime/cookies/index.js [app-client] (ecmascript)"); //# sourceMappingURL=cookies.js.map
}}),
"[project]/node_modules/next/dist/server/web/spec-extension/adapters/request-cookies.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    MutableRequestCookiesAdapter: null,
    ReadonlyRequestCookiesError: null,
    RequestCookiesAdapter: null,
    appendMutableCookies: null,
    areCookiesMutableInCurrentPhase: null,
    getModifiedCookieValues: null,
    responseCookiesToRequestCookies: null,
    wrapWithMutableAccessCheck: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    MutableRequestCookiesAdapter: function() {
        return MutableRequestCookiesAdapter;
    },
    ReadonlyRequestCookiesError: function() {
        return ReadonlyRequestCookiesError;
    },
    RequestCookiesAdapter: function() {
        return RequestCookiesAdapter;
    },
    appendMutableCookies: function() {
        return appendMutableCookies;
    },
    areCookiesMutableInCurrentPhase: function() {
        return areCookiesMutableInCurrentPhase;
    },
    getModifiedCookieValues: function() {
        return getModifiedCookieValues;
    },
    responseCookiesToRequestCookies: function() {
        return responseCookiesToRequestCookies;
    },
    wrapWithMutableAccessCheck: function() {
        return wrapWithMutableAccessCheck;
    }
});
const _cookies = __turbopack_context__.r("[project]/node_modules/next/dist/server/web/spec-extension/cookies.js [app-client] (ecmascript)");
const _reflect = __turbopack_context__.r("[project]/node_modules/next/dist/server/web/spec-extension/adapters/reflect.js [app-client] (ecmascript)");
const _workasyncstorageexternal = __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/work-async-storage.external.js [app-client] (ecmascript)");
const _workunitasyncstorageexternal = __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/work-unit-async-storage.external.js [app-client] (ecmascript)");
class ReadonlyRequestCookiesError extends Error {
    static callable() {
        throw new ReadonlyRequestCookiesError();
    }
    constructor(){
        super('Cookies can only be modified in a Server Action or Route Handler. Read more: https://nextjs.org/docs/app/api-reference/functions/cookies#options');
    }
}
class RequestCookiesAdapter {
    static seal(cookies) {
        return new Proxy(cookies, {
            get (target, prop, receiver) {
                switch(prop){
                    case 'clear':
                    case 'delete':
                    case 'set':
                        return ReadonlyRequestCookiesError.callable;
                    default:
                        return _reflect.ReflectAdapter.get(target, prop, receiver);
                }
            }
        });
    }
}
const SYMBOL_MODIFY_COOKIE_VALUES = Symbol.for('next.mutated.cookies');
function getModifiedCookieValues(cookies) {
    const modified = cookies[SYMBOL_MODIFY_COOKIE_VALUES];
    if (!modified || !Array.isArray(modified) || modified.length === 0) {
        return [];
    }
    return modified;
}
function appendMutableCookies(headers, mutableCookies) {
    const modifiedCookieValues = getModifiedCookieValues(mutableCookies);
    if (modifiedCookieValues.length === 0) {
        return false;
    }
    // Return a new response that extends the response with
    // the modified cookies as fallbacks. `res` cookies
    // will still take precedence.
    const resCookies = new _cookies.ResponseCookies(headers);
    const returnedCookies = resCookies.getAll();
    // Set the modified cookies as fallbacks.
    for (const cookie of modifiedCookieValues){
        resCookies.set(cookie);
    }
    // Set the original cookies as the final values.
    for (const cookie of returnedCookies){
        resCookies.set(cookie);
    }
    return true;
}
class MutableRequestCookiesAdapter {
    static wrap(cookies, onUpdateCookies) {
        const responseCookies = new _cookies.ResponseCookies(new Headers());
        for (const cookie of cookies.getAll()){
            responseCookies.set(cookie);
        }
        let modifiedValues = [];
        const modifiedCookies = new Set();
        const updateResponseCookies = ()=>{
            // TODO-APP: change method of getting workStore
            const workStore = _workasyncstorageexternal.workAsyncStorage.getStore();
            if (workStore) {
                workStore.pathWasRevalidated = true;
            }
            const allCookies = responseCookies.getAll();
            modifiedValues = allCookies.filter((c)=>modifiedCookies.has(c.name));
            if (onUpdateCookies) {
                const serializedCookies = [];
                for (const cookie of modifiedValues){
                    const tempCookies = new _cookies.ResponseCookies(new Headers());
                    tempCookies.set(cookie);
                    serializedCookies.push(tempCookies.toString());
                }
                onUpdateCookies(serializedCookies);
            }
        };
        const wrappedCookies = new Proxy(responseCookies, {
            get (target, prop, receiver) {
                switch(prop){
                    // A special symbol to get the modified cookie values
                    case SYMBOL_MODIFY_COOKIE_VALUES:
                        return modifiedValues;
                    // TODO: Throw error if trying to set a cookie after the response
                    // headers have been set.
                    case 'delete':
                        return function() {
                            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                                args[_key] = arguments[_key];
                            }
                            modifiedCookies.add(typeof args[0] === 'string' ? args[0] : args[0].name);
                            try {
                                target.delete(...args);
                                return wrappedCookies;
                            } finally{
                                updateResponseCookies();
                            }
                        };
                    case 'set':
                        return function() {
                            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                                args[_key] = arguments[_key];
                            }
                            modifiedCookies.add(typeof args[0] === 'string' ? args[0] : args[0].name);
                            try {
                                target.set(...args);
                                return wrappedCookies;
                            } finally{
                                updateResponseCookies();
                            }
                        };
                    default:
                        return _reflect.ReflectAdapter.get(target, prop, receiver);
                }
            }
        });
        return wrappedCookies;
    }
}
function wrapWithMutableAccessCheck(responseCookies) {
    const wrappedCookies = new Proxy(responseCookies, {
        get (target, prop, receiver) {
            switch(prop){
                case 'delete':
                    return function() {
                        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                            args[_key] = arguments[_key];
                        }
                        ensureCookiesAreStillMutable('cookies().delete');
                        target.delete(...args);
                        return wrappedCookies;
                    };
                case 'set':
                    return function() {
                        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                            args[_key] = arguments[_key];
                        }
                        ensureCookiesAreStillMutable('cookies().set');
                        target.set(...args);
                        return wrappedCookies;
                    };
                default:
                    return _reflect.ReflectAdapter.get(target, prop, receiver);
            }
        }
    });
    return wrappedCookies;
}
function areCookiesMutableInCurrentPhase(requestStore) {
    return requestStore.phase === 'action';
}
/** Ensure that cookies() starts throwing on mutation
 * if we changed phases and can no longer mutate.
 *
 * This can happen when going:
 *   'render' -> 'after'
 *   'action' -> 'render'
 * */ function ensureCookiesAreStillMutable(callingExpression) {
    const requestStore = (0, _workunitasyncstorageexternal.getExpectedRequestStore)(callingExpression);
    if (!areCookiesMutableInCurrentPhase(requestStore)) {
        // TODO: maybe we can give a more precise error message based on callingExpression?
        throw new ReadonlyRequestCookiesError();
    }
}
function responseCookiesToRequestCookies(responseCookies) {
    const requestCookies = new _cookies.RequestCookies(new Headers());
    for (const cookie of responseCookies.getAll()){
        requestCookies.set(cookie);
    }
    return requestCookies;
} //# sourceMappingURL=request-cookies.js.map
}}),
"[project]/node_modules/next/dist/server/request/cookies.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "cookies", {
    enumerable: true,
    get: function() {
        return cookies;
    }
});
const _requestcookies = __turbopack_context__.r("[project]/node_modules/next/dist/server/web/spec-extension/adapters/request-cookies.js [app-client] (ecmascript)");
const _cookies = __turbopack_context__.r("[project]/node_modules/next/dist/server/web/spec-extension/cookies.js [app-client] (ecmascript)");
const _workasyncstorageexternal = __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/work-async-storage.external.js [app-client] (ecmascript)");
const _workunitasyncstorageexternal = __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/work-unit-async-storage.external.js [app-client] (ecmascript)");
const _dynamicrendering = __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/dynamic-rendering.js [app-client] (ecmascript)");
const _staticgenerationbailout = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/static-generation-bailout.js [app-client] (ecmascript)");
const _dynamicrenderingutils = __turbopack_context__.r("[project]/node_modules/next/dist/server/dynamic-rendering-utils.js [app-client] (ecmascript)");
const _creatededupedbycallsiteservererrorlogger = __turbopack_context__.r("[project]/node_modules/next/dist/server/create-deduped-by-callsite-server-error-logger.js [app-client] (ecmascript)");
const _scheduler = __turbopack_context__.r("[project]/node_modules/next/dist/lib/scheduler.js [app-client] (ecmascript)");
const _utils = __turbopack_context__.r("[project]/node_modules/next/dist/server/request/utils.js [app-client] (ecmascript)");
const _invarianterror = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/invariant-error.js [app-client] (ecmascript)");
const _reflect = __turbopack_context__.r("[project]/node_modules/next/dist/server/web/spec-extension/adapters/reflect.js [app-client] (ecmascript)");
function cookies() {
    const callingExpression = 'cookies';
    const workStore = _workasyncstorageexternal.workAsyncStorage.getStore();
    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
    if (workStore) {
        if (workUnitStore && workUnitStore.phase === 'after' && !(0, _utils.isRequestAPICallableInsideAfter)()) {
            throw Object.defineProperty(new Error("Route ".concat(workStore.route, ' used "cookies" inside "after(...)". This is not supported. If you need this data inside an "after" callback, use "cookies" outside of the callback. See more info here: https://nextjs.org/docs/canary/app/api-reference/functions/after')), "__NEXT_ERROR_CODE", {
                value: "E88",
                enumerable: false,
                configurable: true
            });
        }
        if (workStore.forceStatic) {
            // When using forceStatic we override all other logic and always just return an empty
            // cookies object without tracking
            const underlyingCookies = createEmptyCookies();
            return makeUntrackedExoticCookies(underlyingCookies);
        }
        if (workUnitStore) {
            if (workUnitStore.type === 'cache') {
                throw Object.defineProperty(new Error("Route ".concat(workStore.route, ' used "cookies" inside "use cache". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use "cookies" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache')), "__NEXT_ERROR_CODE", {
                    value: "E398",
                    enumerable: false,
                    configurable: true
                });
            } else if (workUnitStore.type === 'unstable-cache') {
                throw Object.defineProperty(new Error("Route ".concat(workStore.route, ' used "cookies" inside a function cached with "unstable_cache(...)". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use "cookies" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache')), "__NEXT_ERROR_CODE", {
                    value: "E157",
                    enumerable: false,
                    configurable: true
                });
            }
        }
        if (workStore.dynamicShouldError) {
            throw Object.defineProperty(new _staticgenerationbailout.StaticGenBailoutError("Route ".concat(workStore.route, ' with `dynamic = "error"` couldn\'t be rendered statically because it used `cookies`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering')), "__NEXT_ERROR_CODE", {
                value: "E549",
                enumerable: false,
                configurable: true
            });
        }
        if (workUnitStore) {
            switch(workUnitStore.type){
                case 'prerender':
                    return makeHangingCookies(workUnitStore);
                case 'prerender-client':
                    const exportName = '`cookies`';
                    throw Object.defineProperty(new _invarianterror.InvariantError("".concat(exportName, " must not be used within a client component. Next.js should be preventing ").concat(exportName, " from being included in client components statically, but did not in this case.")), "__NEXT_ERROR_CODE", {
                        value: "E693",
                        enumerable: false,
                        configurable: true
                    });
                case 'prerender-ppr':
                    // PPR Prerender (no dynamicIO)
                    // We are prerendering with PPR. We need track dynamic access here eagerly
                    // to keep continuity with how cookies has worked in PPR without dynamicIO.
                    (0, _dynamicrendering.postponeWithTracking)(workStore.route, callingExpression, workUnitStore.dynamicTracking);
                    break;
                case 'prerender-legacy':
                    // Legacy Prerender
                    // We track dynamic access here so we don't need to wrap the cookies in
                    // individual property access tracking.
                    (0, _dynamicrendering.throwToInterruptStaticGeneration)(callingExpression, workStore, workUnitStore);
                    break;
                default:
            }
        }
        // We fall through to the dynamic context below but we still track dynamic access
        // because in dev we can still error for things like using cookies inside a cache context
        (0, _dynamicrendering.trackDynamicDataInDynamicRender)(workStore, workUnitStore);
    }
    // cookies is being called in a dynamic context
    const requestStore = (0, _workunitasyncstorageexternal.getExpectedRequestStore)(callingExpression);
    let underlyingCookies;
    if ((0, _requestcookies.areCookiesMutableInCurrentPhase)(requestStore)) {
        // We can't conditionally return different types here based on the context.
        // To avoid confusion, we always return the readonly type here.
        underlyingCookies = requestStore.userspaceMutableCookies;
    } else {
        underlyingCookies = requestStore.cookies;
    }
    if (("TURBOPACK compile-time value", "development") === 'development' && !(workStore == null ? void 0 : workStore.isPrefetchRequest)) {
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        return makeUntrackedExoticCookiesWithDevWarnings(underlyingCookies, workStore == null ? void 0 : workStore.route);
    } else {
        return makeUntrackedExoticCookies(underlyingCookies);
    }
}
function createEmptyCookies() {
    return _requestcookies.RequestCookiesAdapter.seal(new _cookies.RequestCookies(new Headers({})));
}
const CachedCookies = new WeakMap();
function makeHangingCookies(prerenderStore) {
    const cachedPromise = CachedCookies.get(prerenderStore);
    if (cachedPromise) {
        return cachedPromise;
    }
    const promise = (0, _dynamicrenderingutils.makeHangingPromise)(prerenderStore.renderSignal, '`cookies()`');
    CachedCookies.set(prerenderStore, promise);
    return promise;
}
function makeUntrackedExoticCookies(underlyingCookies) {
    const cachedCookies = CachedCookies.get(underlyingCookies);
    if (cachedCookies) {
        return cachedCookies;
    }
    const promise = Promise.resolve(underlyingCookies);
    CachedCookies.set(underlyingCookies, promise);
    Object.defineProperties(promise, {
        [Symbol.iterator]: {
            value: underlyingCookies[Symbol.iterator] ? underlyingCookies[Symbol.iterator].bind(underlyingCookies) : // but that's already a hard thing to debug so we may as well implement it consistently. The biggest problem with
            // implementing this in this way is the underlying cookie type is a ResponseCookie and not a RequestCookie and so it
            // has extra properties not available on RequestCookie instances.
            polyfilledResponseCookiesIterator.bind(underlyingCookies)
        },
        size: {
            get () {
                return underlyingCookies.size;
            }
        },
        get: {
            value: underlyingCookies.get.bind(underlyingCookies)
        },
        getAll: {
            value: underlyingCookies.getAll.bind(underlyingCookies)
        },
        has: {
            value: underlyingCookies.has.bind(underlyingCookies)
        },
        set: {
            value: underlyingCookies.set.bind(underlyingCookies)
        },
        delete: {
            value: underlyingCookies.delete.bind(underlyingCookies)
        },
        clear: {
            value: typeof underlyingCookies.clear === 'function' ? underlyingCookies.clear.bind(underlyingCookies) : // but that's already a hard thing to debug so we may as well implement it consistently. The biggest problem with
            // implementing this in this way is the underlying cookie type is a ResponseCookie and not a RequestCookie and so it
            // has extra properties not available on RequestCookie instances.
            polyfilledResponseCookiesClear.bind(underlyingCookies, promise)
        },
        toString: {
            value: underlyingCookies.toString.bind(underlyingCookies)
        }
    });
    return promise;
}
function makeUntrackedExoticCookiesWithDevWarnings(underlyingCookies, route) {
    const cachedCookies = CachedCookies.get(underlyingCookies);
    if (cachedCookies) {
        return cachedCookies;
    }
    const promise = new Promise((resolve)=>(0, _scheduler.scheduleImmediate)(()=>resolve(underlyingCookies)));
    CachedCookies.set(underlyingCookies, promise);
    Object.defineProperties(promise, {
        [Symbol.iterator]: {
            value: function() {
                const expression = '`...cookies()` or similar iteration';
                syncIODev(route, expression);
                return underlyingCookies[Symbol.iterator] ? underlyingCookies[Symbol.iterator].apply(underlyingCookies, arguments) : // but that's already a hard thing to debug so we may as well implement it consistently. The biggest problem with
                // implementing this in this way is the underlying cookie type is a ResponseCookie and not a RequestCookie and so it
                // has extra properties not available on RequestCookie instances.
                polyfilledResponseCookiesIterator.call(underlyingCookies);
            },
            writable: false
        },
        size: {
            get () {
                const expression = '`cookies().size`';
                syncIODev(route, expression);
                return underlyingCookies.size;
            }
        },
        get: {
            value: function get() {
                let expression;
                if (arguments.length === 0) {
                    expression = '`cookies().get()`';
                } else {
                    expression = "`cookies().get(".concat(describeNameArg(arguments[0]), ")`");
                }
                syncIODev(route, expression);
                return underlyingCookies.get.apply(underlyingCookies, arguments);
            },
            writable: false
        },
        getAll: {
            value: function getAll() {
                let expression;
                if (arguments.length === 0) {
                    expression = '`cookies().getAll()`';
                } else {
                    expression = "`cookies().getAll(".concat(describeNameArg(arguments[0]), ")`");
                }
                syncIODev(route, expression);
                return underlyingCookies.getAll.apply(underlyingCookies, arguments);
            },
            writable: false
        },
        has: {
            value: function get() {
                let expression;
                if (arguments.length === 0) {
                    expression = '`cookies().has()`';
                } else {
                    expression = "`cookies().has(".concat(describeNameArg(arguments[0]), ")`");
                }
                syncIODev(route, expression);
                return underlyingCookies.has.apply(underlyingCookies, arguments);
            },
            writable: false
        },
        set: {
            value: function set() {
                let expression;
                if (arguments.length === 0) {
                    expression = '`cookies().set()`';
                } else {
                    const arg = arguments[0];
                    if (arg) {
                        expression = "`cookies().set(".concat(describeNameArg(arg), ", ...)`");
                    } else {
                        expression = '`cookies().set(...)`';
                    }
                }
                syncIODev(route, expression);
                return underlyingCookies.set.apply(underlyingCookies, arguments);
            },
            writable: false
        },
        delete: {
            value: function() {
                let expression;
                if (arguments.length === 0) {
                    expression = '`cookies().delete()`';
                } else if (arguments.length === 1) {
                    expression = "`cookies().delete(".concat(describeNameArg(arguments[0]), ")`");
                } else {
                    expression = "`cookies().delete(".concat(describeNameArg(arguments[0]), ", ...)`");
                }
                syncIODev(route, expression);
                return underlyingCookies.delete.apply(underlyingCookies, arguments);
            },
            writable: false
        },
        clear: {
            value: function clear() {
                const expression = '`cookies().clear()`';
                syncIODev(route, expression);
                // @ts-ignore clear is defined in RequestCookies implementation but not in the type
                return typeof underlyingCookies.clear === 'function' ? underlyingCookies.clear.apply(underlyingCookies, arguments) : // but that's already a hard thing to debug so we may as well implement it consistently. The biggest problem with
                // implementing this in this way is the underlying cookie type is a ResponseCookie and not a RequestCookie and so it
                // has extra properties not available on RequestCookie instances.
                polyfilledResponseCookiesClear.call(underlyingCookies, promise);
            },
            writable: false
        },
        toString: {
            value: function toString() {
                const expression = '`cookies().toString()` or implicit casting';
                syncIODev(route, expression);
                return underlyingCookies.toString.apply(underlyingCookies, arguments);
            },
            writable: false
        }
    });
    return promise;
}
// Similar to `makeUntrackedExoticCookiesWithDevWarnings`, but just logging the
// sync access without actually defining the cookies properties on the promise.
function makeUntrackedCookiesWithDevWarnings(underlyingCookies, route) {
    const cachedCookies = CachedCookies.get(underlyingCookies);
    if (cachedCookies) {
        return cachedCookies;
    }
    const promise = new Promise((resolve)=>(0, _scheduler.scheduleImmediate)(()=>resolve(underlyingCookies)));
    const proxiedPromise = new Proxy(promise, {
        get (target, prop, receiver) {
            switch(prop){
                case Symbol.iterator:
                    {
                        warnForSyncAccess(route, '`...cookies()` or similar iteration');
                        break;
                    }
                case 'size':
                case 'get':
                case 'getAll':
                case 'has':
                case 'set':
                case 'delete':
                case 'clear':
                case 'toString':
                    {
                        warnForSyncAccess(route, "`cookies().".concat(prop, "`"));
                        break;
                    }
                default:
                    {
                    // We only warn for well-defined properties of the cookies object.
                    }
            }
            return _reflect.ReflectAdapter.get(target, prop, receiver);
        }
    });
    CachedCookies.set(underlyingCookies, proxiedPromise);
    return proxiedPromise;
}
function describeNameArg(arg) {
    return typeof arg === 'object' && arg !== null && typeof arg.name === 'string' ? "'".concat(arg.name, "'") : typeof arg === 'string' ? "'".concat(arg, "'") : '...';
}
function syncIODev(route, expression) {
    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
    if (workUnitStore && workUnitStore.type === 'request' && workUnitStore.prerenderPhase === true) {
        // When we're rendering dynamically in dev we need to advance out of the
        // Prerender environment when we read Request data synchronously
        const requestStore = workUnitStore;
        (0, _dynamicrendering.trackSynchronousRequestDataAccessInDev)(requestStore);
    }
    // In all cases we warn normally
    warnForSyncAccess(route, expression);
}
const warnForSyncAccess = (0, _creatededupedbycallsiteservererrorlogger.createDedupedByCallsiteServerErrorLoggerDev)(createCookiesAccessError);
function createCookiesAccessError(route, expression) {
    const prefix = route ? 'Route "'.concat(route, '" ') : 'This route ';
    return Object.defineProperty(new Error("".concat(prefix, "used ").concat(expression, ". ") + "`cookies()` should be awaited before using its value. " + "Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis"), "__NEXT_ERROR_CODE", {
        value: "E223",
        enumerable: false,
        configurable: true
    });
}
function polyfilledResponseCookiesIterator() {
    return this.getAll().map((c)=>[
            c.name,
            c
        ]).values();
}
function polyfilledResponseCookiesClear(returnable) {
    for (const cookie of this.getAll()){
        this.delete(cookie.name);
    }
    return returnable;
} //# sourceMappingURL=cookies.js.map
}}),
"[project]/node_modules/next/dist/server/web/spec-extension/adapters/headers.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    HeadersAdapter: null,
    ReadonlyHeadersError: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    HeadersAdapter: function() {
        return HeadersAdapter;
    },
    ReadonlyHeadersError: function() {
        return ReadonlyHeadersError;
    }
});
const _reflect = __turbopack_context__.r("[project]/node_modules/next/dist/server/web/spec-extension/adapters/reflect.js [app-client] (ecmascript)");
class ReadonlyHeadersError extends Error {
    static callable() {
        throw new ReadonlyHeadersError();
    }
    constructor(){
        super('Headers cannot be modified. Read more: https://nextjs.org/docs/app/api-reference/functions/headers');
    }
}
class HeadersAdapter extends Headers {
    /**
   * Seals a Headers instance to prevent modification by throwing an error when
   * any mutating method is called.
   */ static seal(headers) {
        return new Proxy(headers, {
            get (target, prop, receiver) {
                switch(prop){
                    case 'append':
                    case 'delete':
                    case 'set':
                        return ReadonlyHeadersError.callable;
                    default:
                        return _reflect.ReflectAdapter.get(target, prop, receiver);
                }
            }
        });
    }
    /**
   * Merges a header value into a string. This stores multiple values as an
   * array, so we need to merge them into a string.
   *
   * @param value a header value
   * @returns a merged header value (a string)
   */ merge(value) {
        if (Array.isArray(value)) return value.join(', ');
        return value;
    }
    /**
   * Creates a Headers instance from a plain object or a Headers instance.
   *
   * @param headers a plain object or a Headers instance
   * @returns a headers instance
   */ static from(headers) {
        if (headers instanceof Headers) return headers;
        return new HeadersAdapter(headers);
    }
    append(name, value) {
        const existing = this.headers[name];
        if (typeof existing === 'string') {
            this.headers[name] = [
                existing,
                value
            ];
        } else if (Array.isArray(existing)) {
            existing.push(value);
        } else {
            this.headers[name] = value;
        }
    }
    delete(name) {
        delete this.headers[name];
    }
    get(name) {
        const value = this.headers[name];
        if (typeof value !== 'undefined') return this.merge(value);
        return null;
    }
    has(name) {
        return typeof this.headers[name] !== 'undefined';
    }
    set(name, value) {
        this.headers[name] = value;
    }
    forEach(callbackfn, thisArg) {
        for (const [name, value] of this.entries()){
            callbackfn.call(thisArg, value, name, this);
        }
    }
    *entries() {
        for (const key of Object.keys(this.headers)){
            const name = key.toLowerCase();
            // We assert here that this is a string because we got it from the
            // Object.keys() call above.
            const value = this.get(name);
            yield [
                name,
                value
            ];
        }
    }
    *keys() {
        for (const key of Object.keys(this.headers)){
            const name = key.toLowerCase();
            yield name;
        }
    }
    *values() {
        for (const key of Object.keys(this.headers)){
            // We assert here that this is a string because we got it from the
            // Object.keys() call above.
            const value = this.get(key);
            yield value;
        }
    }
    [Symbol.iterator]() {
        return this.entries();
    }
    constructor(headers){
        // We've already overridden the methods that would be called, so we're just
        // calling the super constructor to ensure that the instanceof check works.
        super();
        this.headers = new Proxy(headers, {
            get (target, prop, receiver) {
                // Because this is just an object, we expect that all "get" operations
                // are for properties. If it's a "get" for a symbol, we'll just return
                // the symbol.
                if (typeof prop === 'symbol') {
                    return _reflect.ReflectAdapter.get(target, prop, receiver);
                }
                const lowercased = prop.toLowerCase();
                // Let's find the original casing of the key. This assumes that there is
                // no mixed case keys (e.g. "Content-Type" and "content-type") in the
                // headers object.
                const original = Object.keys(headers).find((o)=>o.toLowerCase() === lowercased);
                // If the original casing doesn't exist, return undefined.
                if (typeof original === 'undefined') return;
                // If the original casing exists, return the value.
                return _reflect.ReflectAdapter.get(target, original, receiver);
            },
            set (target, prop, value, receiver) {
                if (typeof prop === 'symbol') {
                    return _reflect.ReflectAdapter.set(target, prop, value, receiver);
                }
                const lowercased = prop.toLowerCase();
                // Let's find the original casing of the key. This assumes that there is
                // no mixed case keys (e.g. "Content-Type" and "content-type") in the
                // headers object.
                const original = Object.keys(headers).find((o)=>o.toLowerCase() === lowercased);
                // If the original casing doesn't exist, use the prop as the key.
                return _reflect.ReflectAdapter.set(target, original !== null && original !== void 0 ? original : prop, value, receiver);
            },
            has (target, prop) {
                if (typeof prop === 'symbol') return _reflect.ReflectAdapter.has(target, prop);
                const lowercased = prop.toLowerCase();
                // Let's find the original casing of the key. This assumes that there is
                // no mixed case keys (e.g. "Content-Type" and "content-type") in the
                // headers object.
                const original = Object.keys(headers).find((o)=>o.toLowerCase() === lowercased);
                // If the original casing doesn't exist, return false.
                if (typeof original === 'undefined') return false;
                // If the original casing exists, return true.
                return _reflect.ReflectAdapter.has(target, original);
            },
            deleteProperty (target, prop) {
                if (typeof prop === 'symbol') return _reflect.ReflectAdapter.deleteProperty(target, prop);
                const lowercased = prop.toLowerCase();
                // Let's find the original casing of the key. This assumes that there is
                // no mixed case keys (e.g. "Content-Type" and "content-type") in the
                // headers object.
                const original = Object.keys(headers).find((o)=>o.toLowerCase() === lowercased);
                // If the original casing doesn't exist, return true.
                if (typeof original === 'undefined') return true;
                // If the original casing exists, delete the property.
                return _reflect.ReflectAdapter.deleteProperty(target, original);
            }
        });
    }
} //# sourceMappingURL=headers.js.map
}}),
"[project]/node_modules/next/dist/server/request/headers.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "headers", {
    enumerable: true,
    get: function() {
        return headers;
    }
});
const _headers = __turbopack_context__.r("[project]/node_modules/next/dist/server/web/spec-extension/adapters/headers.js [app-client] (ecmascript)");
const _workasyncstorageexternal = __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/work-async-storage.external.js [app-client] (ecmascript)");
const _workunitasyncstorageexternal = __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/work-unit-async-storage.external.js [app-client] (ecmascript)");
const _dynamicrendering = __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/dynamic-rendering.js [app-client] (ecmascript)");
const _staticgenerationbailout = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/static-generation-bailout.js [app-client] (ecmascript)");
const _dynamicrenderingutils = __turbopack_context__.r("[project]/node_modules/next/dist/server/dynamic-rendering-utils.js [app-client] (ecmascript)");
const _creatededupedbycallsiteservererrorlogger = __turbopack_context__.r("[project]/node_modules/next/dist/server/create-deduped-by-callsite-server-error-logger.js [app-client] (ecmascript)");
const _scheduler = __turbopack_context__.r("[project]/node_modules/next/dist/lib/scheduler.js [app-client] (ecmascript)");
const _utils = __turbopack_context__.r("[project]/node_modules/next/dist/server/request/utils.js [app-client] (ecmascript)");
const _invarianterror = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/invariant-error.js [app-client] (ecmascript)");
const _reflect = __turbopack_context__.r("[project]/node_modules/next/dist/server/web/spec-extension/adapters/reflect.js [app-client] (ecmascript)");
function headers() {
    const workStore = _workasyncstorageexternal.workAsyncStorage.getStore();
    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
    if (workStore) {
        if (workUnitStore && workUnitStore.phase === 'after' && !(0, _utils.isRequestAPICallableInsideAfter)()) {
            throw Object.defineProperty(new Error("Route ".concat(workStore.route, ' used "headers" inside "after(...)". This is not supported. If you need this data inside an "after" callback, use "headers" outside of the callback. See more info here: https://nextjs.org/docs/canary/app/api-reference/functions/after')), "__NEXT_ERROR_CODE", {
                value: "E367",
                enumerable: false,
                configurable: true
            });
        }
        if (workStore.forceStatic) {
            // When using forceStatic we override all other logic and always just return an empty
            // headers object without tracking
            const underlyingHeaders = _headers.HeadersAdapter.seal(new Headers({}));
            return makeUntrackedExoticHeaders(underlyingHeaders);
        }
        if (workUnitStore) {
            if (workUnitStore.type === 'cache') {
                throw Object.defineProperty(new Error("Route ".concat(workStore.route, ' used "headers" inside "use cache". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use "headers" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache')), "__NEXT_ERROR_CODE", {
                    value: "E304",
                    enumerable: false,
                    configurable: true
                });
            } else if (workUnitStore.type === 'unstable-cache') {
                throw Object.defineProperty(new Error("Route ".concat(workStore.route, ' used "headers" inside a function cached with "unstable_cache(...)". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use "headers" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache')), "__NEXT_ERROR_CODE", {
                    value: "E127",
                    enumerable: false,
                    configurable: true
                });
            }
        }
        if (workStore.dynamicShouldError) {
            throw Object.defineProperty(new _staticgenerationbailout.StaticGenBailoutError("Route ".concat(workStore.route, ' with `dynamic = "error"` couldn\'t be rendered statically because it used `headers`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering')), "__NEXT_ERROR_CODE", {
                value: "E525",
                enumerable: false,
                configurable: true
            });
        }
        if (workUnitStore) {
            switch(workUnitStore.type){
                case 'prerender':
                    return makeHangingHeaders(workUnitStore);
                case 'prerender-client':
                    const exportName = '`headers`';
                    throw Object.defineProperty(new _invarianterror.InvariantError("".concat(exportName, " must not be used within a client component. Next.js should be preventing ").concat(exportName, " from being included in client components statically, but did not in this case.")), "__NEXT_ERROR_CODE", {
                        value: "E693",
                        enumerable: false,
                        configurable: true
                    });
                case 'prerender-ppr':
                    // PPR Prerender (no dynamicIO)
                    // We are prerendering with PPR. We need track dynamic access here eagerly
                    // to keep continuity with how headers has worked in PPR without dynamicIO.
                    // TODO consider switching the semantic to throw on property access instead
                    (0, _dynamicrendering.postponeWithTracking)(workStore.route, 'headers', workUnitStore.dynamicTracking);
                    break;
                case 'prerender-legacy':
                    // Legacy Prerender
                    // We are in a legacy static generation mode while prerendering
                    // We track dynamic access here so we don't need to wrap the headers in
                    // individual property access tracking.
                    (0, _dynamicrendering.throwToInterruptStaticGeneration)('headers', workStore, workUnitStore);
                    break;
                default:
            }
        }
        // We fall through to the dynamic context below but we still track dynamic access
        // because in dev we can still error for things like using headers inside a cache context
        (0, _dynamicrendering.trackDynamicDataInDynamicRender)(workStore, workUnitStore);
    }
    const requestStore = (0, _workunitasyncstorageexternal.getExpectedRequestStore)('headers');
    if (("TURBOPACK compile-time value", "development") === 'development' && !(workStore == null ? void 0 : workStore.isPrefetchRequest)) {
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        return makeUntrackedExoticHeadersWithDevWarnings(requestStore.headers, workStore == null ? void 0 : workStore.route);
    } else {
        return makeUntrackedExoticHeaders(requestStore.headers);
    }
}
const CachedHeaders = new WeakMap();
function makeHangingHeaders(prerenderStore) {
    const cachedHeaders = CachedHeaders.get(prerenderStore);
    if (cachedHeaders) {
        return cachedHeaders;
    }
    const promise = (0, _dynamicrenderingutils.makeHangingPromise)(prerenderStore.renderSignal, '`headers()`');
    CachedHeaders.set(prerenderStore, promise);
    return promise;
}
function makeUntrackedExoticHeaders(underlyingHeaders) {
    const cachedHeaders = CachedHeaders.get(underlyingHeaders);
    if (cachedHeaders) {
        return cachedHeaders;
    }
    const promise = Promise.resolve(underlyingHeaders);
    CachedHeaders.set(underlyingHeaders, promise);
    Object.defineProperties(promise, {
        append: {
            value: underlyingHeaders.append.bind(underlyingHeaders)
        },
        delete: {
            value: underlyingHeaders.delete.bind(underlyingHeaders)
        },
        get: {
            value: underlyingHeaders.get.bind(underlyingHeaders)
        },
        has: {
            value: underlyingHeaders.has.bind(underlyingHeaders)
        },
        set: {
            value: underlyingHeaders.set.bind(underlyingHeaders)
        },
        getSetCookie: {
            value: underlyingHeaders.getSetCookie.bind(underlyingHeaders)
        },
        forEach: {
            value: underlyingHeaders.forEach.bind(underlyingHeaders)
        },
        keys: {
            value: underlyingHeaders.keys.bind(underlyingHeaders)
        },
        values: {
            value: underlyingHeaders.values.bind(underlyingHeaders)
        },
        entries: {
            value: underlyingHeaders.entries.bind(underlyingHeaders)
        },
        [Symbol.iterator]: {
            value: underlyingHeaders[Symbol.iterator].bind(underlyingHeaders)
        }
    });
    return promise;
}
function makeUntrackedExoticHeadersWithDevWarnings(underlyingHeaders, route) {
    const cachedHeaders = CachedHeaders.get(underlyingHeaders);
    if (cachedHeaders) {
        return cachedHeaders;
    }
    const promise = new Promise((resolve)=>(0, _scheduler.scheduleImmediate)(()=>resolve(underlyingHeaders)));
    CachedHeaders.set(underlyingHeaders, promise);
    Object.defineProperties(promise, {
        append: {
            value: function append() {
                const expression = "`headers().append(".concat(describeNameArg(arguments[0]), ", ...)`");
                syncIODev(route, expression);
                return underlyingHeaders.append.apply(underlyingHeaders, arguments);
            }
        },
        delete: {
            value: function _delete() {
                const expression = "`headers().delete(".concat(describeNameArg(arguments[0]), ")`");
                syncIODev(route, expression);
                return underlyingHeaders.delete.apply(underlyingHeaders, arguments);
            }
        },
        get: {
            value: function get() {
                const expression = "`headers().get(".concat(describeNameArg(arguments[0]), ")`");
                syncIODev(route, expression);
                return underlyingHeaders.get.apply(underlyingHeaders, arguments);
            }
        },
        has: {
            value: function has() {
                const expression = "`headers().has(".concat(describeNameArg(arguments[0]), ")`");
                syncIODev(route, expression);
                return underlyingHeaders.has.apply(underlyingHeaders, arguments);
            }
        },
        set: {
            value: function set() {
                const expression = "`headers().set(".concat(describeNameArg(arguments[0]), ", ...)`");
                syncIODev(route, expression);
                return underlyingHeaders.set.apply(underlyingHeaders, arguments);
            }
        },
        getSetCookie: {
            value: function getSetCookie() {
                const expression = '`headers().getSetCookie()`';
                syncIODev(route, expression);
                return underlyingHeaders.getSetCookie.apply(underlyingHeaders, arguments);
            }
        },
        forEach: {
            value: function forEach() {
                const expression = '`headers().forEach(...)`';
                syncIODev(route, expression);
                return underlyingHeaders.forEach.apply(underlyingHeaders, arguments);
            }
        },
        keys: {
            value: function keys() {
                const expression = '`headers().keys()`';
                syncIODev(route, expression);
                return underlyingHeaders.keys.apply(underlyingHeaders, arguments);
            }
        },
        values: {
            value: function values() {
                const expression = '`headers().values()`';
                syncIODev(route, expression);
                return underlyingHeaders.values.apply(underlyingHeaders, arguments);
            }
        },
        entries: {
            value: function entries() {
                const expression = '`headers().entries()`';
                syncIODev(route, expression);
                return underlyingHeaders.entries.apply(underlyingHeaders, arguments);
            }
        },
        [Symbol.iterator]: {
            value: function() {
                const expression = '`...headers()` or similar iteration';
                syncIODev(route, expression);
                return underlyingHeaders[Symbol.iterator].apply(underlyingHeaders, arguments);
            }
        }
    });
    return promise;
}
// Similar to `makeUntrackedExoticHeadersWithDevWarnings`, but just logging the
// sync access without actually defining the headers properties on the promise.
function makeUntrackedHeadersWithDevWarnings(underlyingHeaders, route) {
    const cachedHeaders = CachedHeaders.get(underlyingHeaders);
    if (cachedHeaders) {
        return cachedHeaders;
    }
    const promise = new Promise((resolve)=>(0, _scheduler.scheduleImmediate)(()=>resolve(underlyingHeaders)));
    const proxiedPromise = new Proxy(promise, {
        get (target, prop, receiver) {
            switch(prop){
                case Symbol.iterator:
                    {
                        warnForSyncAccess(route, '`...headers()` or similar iteration');
                        break;
                    }
                case 'append':
                case 'delete':
                case 'get':
                case 'has':
                case 'set':
                case 'getSetCookie':
                case 'forEach':
                case 'keys':
                case 'values':
                case 'entries':
                    {
                        warnForSyncAccess(route, "`headers().".concat(prop, "`"));
                        break;
                    }
                default:
                    {
                    // We only warn for well-defined properties of the headers object.
                    }
            }
            return _reflect.ReflectAdapter.get(target, prop, receiver);
        }
    });
    CachedHeaders.set(underlyingHeaders, proxiedPromise);
    return proxiedPromise;
}
function describeNameArg(arg) {
    return typeof arg === 'string' ? "'".concat(arg, "'") : '...';
}
function syncIODev(route, expression) {
    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
    if (workUnitStore && workUnitStore.type === 'request' && workUnitStore.prerenderPhase === true) {
        // When we're rendering dynamically in dev we need to advance out of the
        // Prerender environment when we read Request data synchronously
        const requestStore = workUnitStore;
        (0, _dynamicrendering.trackSynchronousRequestDataAccessInDev)(requestStore);
    }
    // In all cases we warn normally
    warnForSyncAccess(route, expression);
}
const warnForSyncAccess = (0, _creatededupedbycallsiteservererrorlogger.createDedupedByCallsiteServerErrorLoggerDev)(createHeadersAccessError);
function createHeadersAccessError(route, expression) {
    const prefix = route ? 'Route "'.concat(route, '" ') : 'This route ';
    return Object.defineProperty(new Error("".concat(prefix, "used ").concat(expression, ". ") + "`headers()` should be awaited before using its value. " + "Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis"), "__NEXT_ERROR_CODE", {
        value: "E277",
        enumerable: false,
        configurable: true
    });
} //# sourceMappingURL=headers.js.map
}}),
"[project]/node_modules/next/dist/server/request/draft-mode.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "draftMode", {
    enumerable: true,
    get: function() {
        return draftMode;
    }
});
const _workunitasyncstorageexternal = __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/work-unit-async-storage.external.js [app-client] (ecmascript)");
const _workasyncstorageexternal = __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/work-async-storage.external.js [app-client] (ecmascript)");
const _dynamicrendering = __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/dynamic-rendering.js [app-client] (ecmascript)");
const _creatededupedbycallsiteservererrorlogger = __turbopack_context__.r("[project]/node_modules/next/dist/server/create-deduped-by-callsite-server-error-logger.js [app-client] (ecmascript)");
const _staticgenerationbailout = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/static-generation-bailout.js [app-client] (ecmascript)");
const _hooksservercontext = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/hooks-server-context.js [app-client] (ecmascript)");
const _invarianterror = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/invariant-error.js [app-client] (ecmascript)");
const _reflect = __turbopack_context__.r("[project]/node_modules/next/dist/server/web/spec-extension/adapters/reflect.js [app-client] (ecmascript)");
function draftMode() {
    const callingExpression = 'draftMode';
    const workStore = _workasyncstorageexternal.workAsyncStorage.getStore();
    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
    if (!workStore || !workUnitStore) {
        (0, _workunitasyncstorageexternal.throwForMissingRequestStore)(callingExpression);
    }
    switch(workUnitStore.type){
        case 'request':
            return createOrGetCachedDraftMode(workUnitStore.draftMode, workStore);
        case 'cache':
        case 'unstable-cache':
            // Inside of `"use cache"` or `unstable_cache`, draft mode is available if
            // the outmost work unit store is a request store, and if draft mode is
            // enabled.
            const draftModeProvider = (0, _workunitasyncstorageexternal.getDraftModeProviderForCacheScope)(workStore, workUnitStore);
            if (draftModeProvider) {
                return createOrGetCachedDraftMode(draftModeProvider, workStore);
            }
        // Otherwise, we fall through to providing an empty draft mode.
        // eslint-disable-next-line no-fallthrough
        case 'prerender':
        case 'prerender-client':
        case 'prerender-ppr':
        case 'prerender-legacy':
            // Return empty draft mode
            return createOrGetCachedDraftMode(null, workStore);
        default:
            const _exhaustiveCheck = workUnitStore;
            return _exhaustiveCheck;
    }
}
function createOrGetCachedDraftMode(draftModeProvider, workStore) {
    const cacheKey = draftModeProvider !== null && draftModeProvider !== void 0 ? draftModeProvider : NullDraftMode;
    const cachedDraftMode = CachedDraftModes.get(cacheKey);
    if (cachedDraftMode) {
        return cachedDraftMode;
    }
    let promise;
    if (("TURBOPACK compile-time value", "development") === 'development' && !(workStore == null ? void 0 : workStore.isPrefetchRequest)) {
        const route = workStore == null ? void 0 : workStore.route;
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        promise = createExoticDraftModeWithDevWarnings(draftModeProvider, route);
    } else {
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        promise = createExoticDraftMode(draftModeProvider);
    }
    CachedDraftModes.set(cacheKey, promise);
    return promise;
}
const NullDraftMode = {};
const CachedDraftModes = new WeakMap();
function createExoticDraftMode(underlyingProvider) {
    const instance = new DraftMode(underlyingProvider);
    const promise = Promise.resolve(instance);
    Object.defineProperty(promise, 'isEnabled', {
        get () {
            return instance.isEnabled;
        },
        enumerable: true,
        configurable: true
    });
    promise.enable = instance.enable.bind(instance);
    promise.disable = instance.disable.bind(instance);
    return promise;
}
function createExoticDraftModeWithDevWarnings(underlyingProvider, route) {
    const instance = new DraftMode(underlyingProvider);
    const promise = Promise.resolve(instance);
    Object.defineProperty(promise, 'isEnabled', {
        get () {
            const expression = '`draftMode().isEnabled`';
            syncIODev(route, expression);
            return instance.isEnabled;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(promise, 'enable', {
        value: function get() {
            const expression = '`draftMode().enable()`';
            syncIODev(route, expression);
            return instance.enable.apply(instance, arguments);
        }
    });
    Object.defineProperty(promise, 'disable', {
        value: function get() {
            const expression = '`draftMode().disable()`';
            syncIODev(route, expression);
            return instance.disable.apply(instance, arguments);
        }
    });
    return promise;
}
// Similar to `createExoticDraftModeWithDevWarnings`, but just logging the sync
// access without actually defining the draftMode properties on the promise.
function createDraftModeWithDevWarnings(underlyingProvider, route) {
    const instance = new DraftMode(underlyingProvider);
    const promise = Promise.resolve(instance);
    const proxiedPromise = new Proxy(promise, {
        get (target, prop, receiver) {
            switch(prop){
                case 'isEnabled':
                    warnForSyncAccess(route, "`draftMode().".concat(prop, "`"));
                    break;
                case 'enable':
                case 'disable':
                    {
                        warnForSyncAccess(route, "`draftMode().".concat(prop, "()`"));
                        break;
                    }
                default:
                    {
                    // We only warn for well-defined properties of the draftMode object.
                    }
            }
            return _reflect.ReflectAdapter.get(target, prop, receiver);
        }
    });
    return proxiedPromise;
}
class DraftMode {
    get isEnabled() {
        if (this._provider !== null) {
            return this._provider.isEnabled;
        }
        return false;
    }
    enable() {
        // We have a store we want to track dynamic data access to ensure we
        // don't statically generate routes that manipulate draft mode.
        trackDynamicDraftMode('draftMode().enable()');
        if (this._provider !== null) {
            this._provider.enable();
        }
    }
    disable() {
        trackDynamicDraftMode('draftMode().disable()');
        if (this._provider !== null) {
            this._provider.disable();
        }
    }
    constructor(provider){
        this._provider = provider;
    }
}
function syncIODev(route, expression) {
    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
    if (workUnitStore && workUnitStore.type === 'request' && workUnitStore.prerenderPhase === true) {
        // When we're rendering dynamically in dev we need to advance out of the
        // Prerender environment when we read Request data synchronously
        const requestStore = workUnitStore;
        (0, _dynamicrendering.trackSynchronousRequestDataAccessInDev)(requestStore);
    }
    // In all cases we warn normally
    warnForSyncAccess(route, expression);
}
const warnForSyncAccess = (0, _creatededupedbycallsiteservererrorlogger.createDedupedByCallsiteServerErrorLoggerDev)(createDraftModeAccessError);
function createDraftModeAccessError(route, expression) {
    const prefix = route ? 'Route "'.concat(route, '" ') : 'This route ';
    return Object.defineProperty(new Error("".concat(prefix, "used ").concat(expression, ". ") + "`draftMode()` should be awaited before using its value. " + "Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis"), "__NEXT_ERROR_CODE", {
        value: "E377",
        enumerable: false,
        configurable: true
    });
}
function trackDynamicDraftMode(expression) {
    const store = _workasyncstorageexternal.workAsyncStorage.getStore();
    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
    if (store) {
        // We have a store we want to track dynamic data access to ensure we
        // don't statically generate routes that manipulate draft mode.
        if (workUnitStore) {
            if (workUnitStore.type === 'cache') {
                throw Object.defineProperty(new Error("Route ".concat(store.route, ' used "').concat(expression, '" inside "use cache". The enabled status of draftMode can be read in caches but you must not enable or disable draftMode inside a cache. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache')), "__NEXT_ERROR_CODE", {
                    value: "E246",
                    enumerable: false,
                    configurable: true
                });
            } else if (workUnitStore.type === 'unstable-cache') {
                throw Object.defineProperty(new Error("Route ".concat(store.route, ' used "').concat(expression, '" inside a function cached with "unstable_cache(...)". The enabled status of draftMode can be read in caches but you must not enable or disable draftMode inside a cache. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache')), "__NEXT_ERROR_CODE", {
                    value: "E259",
                    enumerable: false,
                    configurable: true
                });
            } else if (workUnitStore.phase === 'after') {
                throw Object.defineProperty(new Error("Route ".concat(store.route, ' used "').concat(expression, '" inside `after`. The enabled status of draftMode can be read inside `after` but you cannot enable or disable draftMode. See more info here: https://nextjs.org/docs/app/api-reference/functions/after')), "__NEXT_ERROR_CODE", {
                    value: "E348",
                    enumerable: false,
                    configurable: true
                });
            }
        }
        if (store.dynamicShouldError) {
            throw Object.defineProperty(new _staticgenerationbailout.StaticGenBailoutError("Route ".concat(store.route, ' with `dynamic = "error"` couldn\'t be rendered statically because it used `').concat(expression, "`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering")), "__NEXT_ERROR_CODE", {
                value: "E553",
                enumerable: false,
                configurable: true
            });
        }
        if (workUnitStore) {
            switch(workUnitStore.type){
                case 'prerender':
                    // dynamicIO Prerender
                    const error = Object.defineProperty(new Error("Route ".concat(store.route, " used ").concat(expression, " without first calling `await connection()`. See more info here: https://nextjs.org/docs/messages/next-prerender-sync-headers")), "__NEXT_ERROR_CODE", {
                        value: "E126",
                        enumerable: false,
                        configurable: true
                    });
                    (0, _dynamicrendering.abortAndThrowOnSynchronousRequestDataAccess)(store.route, expression, error, workUnitStore);
                    break;
                case 'prerender-client':
                    const exportName = '`draftMode`';
                    throw Object.defineProperty(new _invarianterror.InvariantError("".concat(exportName, " must not be used within a client component. Next.js should be preventing ").concat(exportName, " from being included in client components statically, but did not in this case.")), "__NEXT_ERROR_CODE", {
                        value: "E693",
                        enumerable: false,
                        configurable: true
                    });
                case 'prerender-ppr':
                    // PPR Prerender
                    (0, _dynamicrendering.postponeWithTracking)(store.route, expression, workUnitStore.dynamicTracking);
                    break;
                case 'prerender-legacy':
                    // legacy Prerender
                    workUnitStore.revalidate = 0;
                    const err = Object.defineProperty(new _hooksservercontext.DynamicServerError("Route ".concat(store.route, " couldn't be rendered statically because it used `").concat(expression, "`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error")), "__NEXT_ERROR_CODE", {
                        value: "E558",
                        enumerable: false,
                        configurable: true
                    });
                    store.dynamicUsageDescription = expression;
                    store.dynamicUsageStack = err.stack;
                    throw err;
                case 'request':
                    if ("TURBOPACK compile-time truthy", 1) {
                        workUnitStore.usedDynamic = true;
                    }
                    break;
                default:
            }
        }
    }
} //# sourceMappingURL=draft-mode.js.map
}}),
"[project]/node_modules/next/headers.js [app-client] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
module.exports.cookies = __turbopack_context__.r("[project]/node_modules/next/dist/server/request/cookies.js [app-client] (ecmascript)").cookies;
module.exports.headers = __turbopack_context__.r("[project]/node_modules/next/dist/server/request/headers.js [app-client] (ecmascript)").headers;
module.exports.draftMode = __turbopack_context__.r("[project]/node_modules/next/dist/server/request/draft-mode.js [app-client] (ecmascript)").draftMode;
}}),
}]);

//# sourceMappingURL=data:application/json;charset=utf-8;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFtdLAogICJzZWN0aW9ucyI6IFsKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNywgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvJTQwZWRnZS1ydW50aW1lL2Nvb2tpZXMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBzcmNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoc3JjX2V4cG9ydHMsIHtcbiAgUmVxdWVzdENvb2tpZXM6ICgpID0+IFJlcXVlc3RDb29raWVzLFxuICBSZXNwb25zZUNvb2tpZXM6ICgpID0+IFJlc3BvbnNlQ29va2llcyxcbiAgcGFyc2VDb29raWU6ICgpID0+IHBhcnNlQ29va2llLFxuICBwYXJzZVNldENvb2tpZTogKCkgPT4gcGFyc2VTZXRDb29raWUsXG4gIHN0cmluZ2lmeUNvb2tpZTogKCkgPT4gc3RyaW5naWZ5Q29va2llXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKHNyY19leHBvcnRzKTtcblxuLy8gc3JjL3NlcmlhbGl6ZS50c1xuZnVuY3Rpb24gc3RyaW5naWZ5Q29va2llKGMpIHtcbiAgdmFyIF9hO1xuICBjb25zdCBhdHRycyA9IFtcbiAgICBcInBhdGhcIiBpbiBjICYmIGMucGF0aCAmJiBgUGF0aD0ke2MucGF0aH1gLFxuICAgIFwiZXhwaXJlc1wiIGluIGMgJiYgKGMuZXhwaXJlcyB8fCBjLmV4cGlyZXMgPT09IDApICYmIGBFeHBpcmVzPSR7KHR5cGVvZiBjLmV4cGlyZXMgPT09IFwibnVtYmVyXCIgPyBuZXcgRGF0ZShjLmV4cGlyZXMpIDogYy5leHBpcmVzKS50b1VUQ1N0cmluZygpfWAsXG4gICAgXCJtYXhBZ2VcIiBpbiBjICYmIHR5cGVvZiBjLm1heEFnZSA9PT0gXCJudW1iZXJcIiAmJiBgTWF4LUFnZT0ke2MubWF4QWdlfWAsXG4gICAgXCJkb21haW5cIiBpbiBjICYmIGMuZG9tYWluICYmIGBEb21haW49JHtjLmRvbWFpbn1gLFxuICAgIFwic2VjdXJlXCIgaW4gYyAmJiBjLnNlY3VyZSAmJiBcIlNlY3VyZVwiLFxuICAgIFwiaHR0cE9ubHlcIiBpbiBjICYmIGMuaHR0cE9ubHkgJiYgXCJIdHRwT25seVwiLFxuICAgIFwic2FtZVNpdGVcIiBpbiBjICYmIGMuc2FtZVNpdGUgJiYgYFNhbWVTaXRlPSR7Yy5zYW1lU2l0ZX1gLFxuICAgIFwicGFydGl0aW9uZWRcIiBpbiBjICYmIGMucGFydGl0aW9uZWQgJiYgXCJQYXJ0aXRpb25lZFwiLFxuICAgIFwicHJpb3JpdHlcIiBpbiBjICYmIGMucHJpb3JpdHkgJiYgYFByaW9yaXR5PSR7Yy5wcmlvcml0eX1gXG4gIF0uZmlsdGVyKEJvb2xlYW4pO1xuICBjb25zdCBzdHJpbmdpZmllZCA9IGAke2MubmFtZX09JHtlbmNvZGVVUklDb21wb25lbnQoKF9hID0gYy52YWx1ZSkgIT0gbnVsbCA/IF9hIDogXCJcIil9YDtcbiAgcmV0dXJuIGF0dHJzLmxlbmd0aCA9PT0gMCA/IHN0cmluZ2lmaWVkIDogYCR7c3RyaW5naWZpZWR9OyAke2F0dHJzLmpvaW4oXCI7IFwiKX1gO1xufVxuZnVuY3Rpb24gcGFyc2VDb29raWUoY29va2llKSB7XG4gIGNvbnN0IG1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGZvciAoY29uc3QgcGFpciBvZiBjb29raWUuc3BsaXQoLzsgKi8pKSB7XG4gICAgaWYgKCFwYWlyKVxuICAgICAgY29udGludWU7XG4gICAgY29uc3Qgc3BsaXRBdCA9IHBhaXIuaW5kZXhPZihcIj1cIik7XG4gICAgaWYgKHNwbGl0QXQgPT09IC0xKSB7XG4gICAgICBtYXAuc2V0KHBhaXIsIFwidHJ1ZVwiKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSBbcGFpci5zbGljZSgwLCBzcGxpdEF0KSwgcGFpci5zbGljZShzcGxpdEF0ICsgMSldO1xuICAgIHRyeSB7XG4gICAgICBtYXAuc2V0KGtleSwgZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IFwidHJ1ZVwiKSk7XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICB9XG4gIHJldHVybiBtYXA7XG59XG5mdW5jdGlvbiBwYXJzZVNldENvb2tpZShzZXRDb29raWUpIHtcbiAgaWYgKCFzZXRDb29raWUpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGNvbnN0IFtbbmFtZSwgdmFsdWVdLCAuLi5hdHRyaWJ1dGVzXSA9IHBhcnNlQ29va2llKHNldENvb2tpZSk7XG4gIGNvbnN0IHtcbiAgICBkb21haW4sXG4gICAgZXhwaXJlcyxcbiAgICBodHRwb25seSxcbiAgICBtYXhhZ2UsXG4gICAgcGF0aCxcbiAgICBzYW1lc2l0ZSxcbiAgICBzZWN1cmUsXG4gICAgcGFydGl0aW9uZWQsXG4gICAgcHJpb3JpdHlcbiAgfSA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBhdHRyaWJ1dGVzLm1hcCgoW2tleSwgdmFsdWUyXSkgPT4gW1xuICAgICAga2V5LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvLS9nLCBcIlwiKSxcbiAgICAgIHZhbHVlMlxuICAgIF0pXG4gICk7XG4gIGNvbnN0IGNvb2tpZSA9IHtcbiAgICBuYW1lLFxuICAgIHZhbHVlOiBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpLFxuICAgIGRvbWFpbixcbiAgICAuLi5leHBpcmVzICYmIHsgZXhwaXJlczogbmV3IERhdGUoZXhwaXJlcykgfSxcbiAgICAuLi5odHRwb25seSAmJiB7IGh0dHBPbmx5OiB0cnVlIH0sXG4gICAgLi4udHlwZW9mIG1heGFnZSA9PT0gXCJzdHJpbmdcIiAmJiB7IG1heEFnZTogTnVtYmVyKG1heGFnZSkgfSxcbiAgICBwYXRoLFxuICAgIC4uLnNhbWVzaXRlICYmIHsgc2FtZVNpdGU6IHBhcnNlU2FtZVNpdGUoc2FtZXNpdGUpIH0sXG4gICAgLi4uc2VjdXJlICYmIHsgc2VjdXJlOiB0cnVlIH0sXG4gICAgLi4ucHJpb3JpdHkgJiYgeyBwcmlvcml0eTogcGFyc2VQcmlvcml0eShwcmlvcml0eSkgfSxcbiAgICAuLi5wYXJ0aXRpb25lZCAmJiB7IHBhcnRpdGlvbmVkOiB0cnVlIH1cbiAgfTtcbiAgcmV0dXJuIGNvbXBhY3QoY29va2llKTtcbn1cbmZ1bmN0aW9uIGNvbXBhY3QodCkge1xuICBjb25zdCBuZXdUID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIHQpIHtcbiAgICBpZiAodFtrZXldKSB7XG4gICAgICBuZXdUW2tleV0gPSB0W2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXdUO1xufVxudmFyIFNBTUVfU0lURSA9IFtcInN0cmljdFwiLCBcImxheFwiLCBcIm5vbmVcIl07XG5mdW5jdGlvbiBwYXJzZVNhbWVTaXRlKHN0cmluZykge1xuICBzdHJpbmcgPSBzdHJpbmcudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIFNBTUVfU0lURS5pbmNsdWRlcyhzdHJpbmcpID8gc3RyaW5nIDogdm9pZCAwO1xufVxudmFyIFBSSU9SSVRZID0gW1wibG93XCIsIFwibWVkaXVtXCIsIFwiaGlnaFwiXTtcbmZ1bmN0aW9uIHBhcnNlUHJpb3JpdHkoc3RyaW5nKSB7XG4gIHN0cmluZyA9IHN0cmluZy50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gUFJJT1JJVFkuaW5jbHVkZXMoc3RyaW5nKSA/IHN0cmluZyA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIHNwbGl0Q29va2llc1N0cmluZyhjb29raWVzU3RyaW5nKSB7XG4gIGlmICghY29va2llc1N0cmluZylcbiAgICByZXR1cm4gW107XG4gIHZhciBjb29raWVzU3RyaW5ncyA9IFtdO1xuICB2YXIgcG9zID0gMDtcbiAgdmFyIHN0YXJ0O1xuICB2YXIgY2g7XG4gIHZhciBsYXN0Q29tbWE7XG4gIHZhciBuZXh0U3RhcnQ7XG4gIHZhciBjb29raWVzU2VwYXJhdG9yRm91bmQ7XG4gIGZ1bmN0aW9uIHNraXBXaGl0ZXNwYWNlKCkge1xuICAgIHdoaWxlIChwb3MgPCBjb29raWVzU3RyaW5nLmxlbmd0aCAmJiAvXFxzLy50ZXN0KGNvb2tpZXNTdHJpbmcuY2hhckF0KHBvcykpKSB7XG4gICAgICBwb3MgKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHBvcyA8IGNvb2tpZXNTdHJpbmcubGVuZ3RoO1xuICB9XG4gIGZ1bmN0aW9uIG5vdFNwZWNpYWxDaGFyKCkge1xuICAgIGNoID0gY29va2llc1N0cmluZy5jaGFyQXQocG9zKTtcbiAgICByZXR1cm4gY2ggIT09IFwiPVwiICYmIGNoICE9PSBcIjtcIiAmJiBjaCAhPT0gXCIsXCI7XG4gIH1cbiAgd2hpbGUgKHBvcyA8IGNvb2tpZXNTdHJpbmcubGVuZ3RoKSB7XG4gICAgc3RhcnQgPSBwb3M7XG4gICAgY29va2llc1NlcGFyYXRvckZvdW5kID0gZmFsc2U7XG4gICAgd2hpbGUgKHNraXBXaGl0ZXNwYWNlKCkpIHtcbiAgICAgIGNoID0gY29va2llc1N0cmluZy5jaGFyQXQocG9zKTtcbiAgICAgIGlmIChjaCA9PT0gXCIsXCIpIHtcbiAgICAgICAgbGFzdENvbW1hID0gcG9zO1xuICAgICAgICBwb3MgKz0gMTtcbiAgICAgICAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgICAgICAgbmV4dFN0YXJ0ID0gcG9zO1xuICAgICAgICB3aGlsZSAocG9zIDwgY29va2llc1N0cmluZy5sZW5ndGggJiYgbm90U3BlY2lhbENoYXIoKSkge1xuICAgICAgICAgIHBvcyArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3MgPCBjb29raWVzU3RyaW5nLmxlbmd0aCAmJiBjb29raWVzU3RyaW5nLmNoYXJBdChwb3MpID09PSBcIj1cIikge1xuICAgICAgICAgIGNvb2tpZXNTZXBhcmF0b3JGb3VuZCA9IHRydWU7XG4gICAgICAgICAgcG9zID0gbmV4dFN0YXJ0O1xuICAgICAgICAgIGNvb2tpZXNTdHJpbmdzLnB1c2goY29va2llc1N0cmluZy5zdWJzdHJpbmcoc3RhcnQsIGxhc3RDb21tYSkpO1xuICAgICAgICAgIHN0YXJ0ID0gcG9zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBvcyA9IGxhc3RDb21tYSArIDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBvcyArPSAxO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWNvb2tpZXNTZXBhcmF0b3JGb3VuZCB8fCBwb3MgPj0gY29va2llc1N0cmluZy5sZW5ndGgpIHtcbiAgICAgIGNvb2tpZXNTdHJpbmdzLnB1c2goY29va2llc1N0cmluZy5zdWJzdHJpbmcoc3RhcnQsIGNvb2tpZXNTdHJpbmcubGVuZ3RoKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjb29raWVzU3RyaW5ncztcbn1cblxuLy8gc3JjL3JlcXVlc3QtY29va2llcy50c1xudmFyIFJlcXVlc3RDb29raWVzID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihyZXF1ZXN0SGVhZGVycykge1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9wYXJzZWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuX2hlYWRlcnMgPSByZXF1ZXN0SGVhZGVycztcbiAgICBjb25zdCBoZWFkZXIgPSByZXF1ZXN0SGVhZGVycy5nZXQoXCJjb29raWVcIik7XG4gICAgaWYgKGhlYWRlcikge1xuICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VDb29raWUoaGVhZGVyKTtcbiAgICAgIGZvciAoY29uc3QgW25hbWUsIHZhbHVlXSBvZiBwYXJzZWQpIHtcbiAgICAgICAgdGhpcy5fcGFyc2VkLnNldChuYW1lLCB7IG5hbWUsIHZhbHVlIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFyc2VkW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGFtb3VudCBvZiBjb29raWVzIHJlY2VpdmVkIGZyb20gdGhlIGNsaWVudFxuICAgKi9cbiAgZ2V0IHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcnNlZC5zaXplO1xuICB9XG4gIGdldCguLi5hcmdzKSB7XG4gICAgY29uc3QgbmFtZSA9IHR5cGVvZiBhcmdzWzBdID09PSBcInN0cmluZ1wiID8gYXJnc1swXSA6IGFyZ3NbMF0ubmFtZTtcbiAgICByZXR1cm4gdGhpcy5fcGFyc2VkLmdldChuYW1lKTtcbiAgfVxuICBnZXRBbGwoLi4uYXJncykge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBhbGwgPSBBcnJheS5mcm9tKHRoaXMuX3BhcnNlZCk7XG4gICAgaWYgKCFhcmdzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGFsbC5tYXAoKFtfLCB2YWx1ZV0pID0+IHZhbHVlKTtcbiAgICB9XG4gICAgY29uc3QgbmFtZSA9IHR5cGVvZiBhcmdzWzBdID09PSBcInN0cmluZ1wiID8gYXJnc1swXSA6IChfYSA9IGFyZ3NbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfYS5uYW1lO1xuICAgIHJldHVybiBhbGwuZmlsdGVyKChbbl0pID0+IG4gPT09IG5hbWUpLm1hcCgoW18sIHZhbHVlXSkgPT4gdmFsdWUpO1xuICB9XG4gIGhhcyhuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcnNlZC5oYXMobmFtZSk7XG4gIH1cbiAgc2V0KC4uLmFyZ3MpIHtcbiAgICBjb25zdCBbbmFtZSwgdmFsdWVdID0gYXJncy5sZW5ndGggPT09IDEgPyBbYXJnc1swXS5uYW1lLCBhcmdzWzBdLnZhbHVlXSA6IGFyZ3M7XG4gICAgY29uc3QgbWFwID0gdGhpcy5fcGFyc2VkO1xuICAgIG1hcC5zZXQobmFtZSwgeyBuYW1lLCB2YWx1ZSB9KTtcbiAgICB0aGlzLl9oZWFkZXJzLnNldChcbiAgICAgIFwiY29va2llXCIsXG4gICAgICBBcnJheS5mcm9tKG1hcCkubWFwKChbXywgdmFsdWUyXSkgPT4gc3RyaW5naWZ5Q29va2llKHZhbHVlMikpLmpvaW4oXCI7IFwiKVxuICAgICk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZSB0aGUgY29va2llcyBtYXRjaGluZyB0aGUgcGFzc2VkIG5hbWUgb3IgbmFtZXMgaW4gdGhlIHJlcXVlc3QuXG4gICAqL1xuICBkZWxldGUobmFtZXMpIHtcbiAgICBjb25zdCBtYXAgPSB0aGlzLl9wYXJzZWQ7XG4gICAgY29uc3QgcmVzdWx0ID0gIUFycmF5LmlzQXJyYXkobmFtZXMpID8gbWFwLmRlbGV0ZShuYW1lcykgOiBuYW1lcy5tYXAoKG5hbWUpID0+IG1hcC5kZWxldGUobmFtZSkpO1xuICAgIHRoaXMuX2hlYWRlcnMuc2V0KFxuICAgICAgXCJjb29raWVcIixcbiAgICAgIEFycmF5LmZyb20obWFwKS5tYXAoKFtfLCB2YWx1ZV0pID0+IHN0cmluZ2lmeUNvb2tpZSh2YWx1ZSkpLmpvaW4oXCI7IFwiKVxuICAgICk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlIGFsbCB0aGUgY29va2llcyBpbiB0aGUgY29va2llcyBpbiB0aGUgcmVxdWVzdC5cbiAgICovXG4gIGNsZWFyKCkge1xuICAgIHRoaXMuZGVsZXRlKEFycmF5LmZyb20odGhpcy5fcGFyc2VkLmtleXMoKSkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBGb3JtYXQgdGhlIGNvb2tpZXMgaW4gdGhlIHJlcXVlc3QgYXMgYSBzdHJpbmcgZm9yIGxvZ2dpbmdcbiAgICovXG4gIFtTeW1ib2wuZm9yKFwiZWRnZS1ydW50aW1lLmluc3BlY3QuY3VzdG9tXCIpXSgpIHtcbiAgICByZXR1cm4gYFJlcXVlc3RDb29raWVzICR7SlNPTi5zdHJpbmdpZnkoT2JqZWN0LmZyb21FbnRyaWVzKHRoaXMuX3BhcnNlZCkpfWA7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIFsuLi50aGlzLl9wYXJzZWQudmFsdWVzKCldLm1hcCgodikgPT4gYCR7di5uYW1lfT0ke2VuY29kZVVSSUNvbXBvbmVudCh2LnZhbHVlKX1gKS5qb2luKFwiOyBcIik7XG4gIH1cbn07XG5cbi8vIHNyYy9yZXNwb25zZS1jb29raWVzLnRzXG52YXIgUmVzcG9uc2VDb29raWVzID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihyZXNwb25zZUhlYWRlcnMpIHtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fcGFyc2VkID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICB0aGlzLl9oZWFkZXJzID0gcmVzcG9uc2VIZWFkZXJzO1xuICAgIGNvbnN0IHNldENvb2tpZSA9IChfYyA9IChfYiA9IChfYSA9IHJlc3BvbnNlSGVhZGVycy5nZXRTZXRDb29raWUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKHJlc3BvbnNlSGVhZGVycykpICE9IG51bGwgPyBfYiA6IHJlc3BvbnNlSGVhZGVycy5nZXQoXCJzZXQtY29va2llXCIpKSAhPSBudWxsID8gX2MgOiBbXTtcbiAgICBjb25zdCBjb29raWVTdHJpbmdzID0gQXJyYXkuaXNBcnJheShzZXRDb29raWUpID8gc2V0Q29va2llIDogc3BsaXRDb29raWVzU3RyaW5nKHNldENvb2tpZSk7XG4gICAgZm9yIChjb25zdCBjb29raWVTdHJpbmcgb2YgY29va2llU3RyaW5ncykge1xuICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VTZXRDb29raWUoY29va2llU3RyaW5nKTtcbiAgICAgIGlmIChwYXJzZWQpXG4gICAgICAgIHRoaXMuX3BhcnNlZC5zZXQocGFyc2VkLm5hbWUsIHBhcnNlZCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiB7QGxpbmsgaHR0cHM6Ly93aWNnLmdpdGh1Yi5pby9jb29raWUtc3RvcmUvI0Nvb2tpZVN0b3JlLWdldCBDb29raWVTdG9yZSNnZXR9IHdpdGhvdXQgdGhlIFByb21pc2UuXG4gICAqL1xuICBnZXQoLi4uYXJncykge1xuICAgIGNvbnN0IGtleSA9IHR5cGVvZiBhcmdzWzBdID09PSBcInN0cmluZ1wiID8gYXJnc1swXSA6IGFyZ3NbMF0ubmFtZTtcbiAgICByZXR1cm4gdGhpcy5fcGFyc2VkLmdldChrZXkpO1xuICB9XG4gIC8qKlxuICAgKiB7QGxpbmsgaHR0cHM6Ly93aWNnLmdpdGh1Yi5pby9jb29raWUtc3RvcmUvI0Nvb2tpZVN0b3JlLWdldEFsbCBDb29raWVTdG9yZSNnZXRBbGx9IHdpdGhvdXQgdGhlIFByb21pc2UuXG4gICAqL1xuICBnZXRBbGwoLi4uYXJncykge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBhbGwgPSBBcnJheS5mcm9tKHRoaXMuX3BhcnNlZC52YWx1ZXMoKSk7XG4gICAgaWYgKCFhcmdzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGFsbDtcbiAgICB9XG4gICAgY29uc3Qga2V5ID0gdHlwZW9mIGFyZ3NbMF0gPT09IFwic3RyaW5nXCIgPyBhcmdzWzBdIDogKF9hID0gYXJnc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLm5hbWU7XG4gICAgcmV0dXJuIGFsbC5maWx0ZXIoKGMpID0+IGMubmFtZSA9PT0ga2V5KTtcbiAgfVxuICBoYXMobmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9wYXJzZWQuaGFzKG5hbWUpO1xuICB9XG4gIC8qKlxuICAgKiB7QGxpbmsgaHR0cHM6Ly93aWNnLmdpdGh1Yi5pby9jb29raWUtc3RvcmUvI0Nvb2tpZVN0b3JlLXNldCBDb29raWVTdG9yZSNzZXR9IHdpdGhvdXQgdGhlIFByb21pc2UuXG4gICAqL1xuICBzZXQoLi4uYXJncykge1xuICAgIGNvbnN0IFtuYW1lLCB2YWx1ZSwgY29va2llXSA9IGFyZ3MubGVuZ3RoID09PSAxID8gW2FyZ3NbMF0ubmFtZSwgYXJnc1swXS52YWx1ZSwgYXJnc1swXV0gOiBhcmdzO1xuICAgIGNvbnN0IG1hcCA9IHRoaXMuX3BhcnNlZDtcbiAgICBtYXAuc2V0KG5hbWUsIG5vcm1hbGl6ZUNvb2tpZSh7IG5hbWUsIHZhbHVlLCAuLi5jb29raWUgfSkpO1xuICAgIHJlcGxhY2UobWFwLCB0aGlzLl9oZWFkZXJzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICoge0BsaW5rIGh0dHBzOi8vd2ljZy5naXRodWIuaW8vY29va2llLXN0b3JlLyNDb29raWVTdG9yZS1kZWxldGUgQ29va2llU3RvcmUjZGVsZXRlfSB3aXRob3V0IHRoZSBQcm9taXNlLlxuICAgKi9cbiAgZGVsZXRlKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBbbmFtZSwgb3B0aW9uc10gPSB0eXBlb2YgYXJnc1swXSA9PT0gXCJzdHJpbmdcIiA/IFthcmdzWzBdXSA6IFthcmdzWzBdLm5hbWUsIGFyZ3NbMF1dO1xuICAgIHJldHVybiB0aGlzLnNldCh7IC4uLm9wdGlvbnMsIG5hbWUsIHZhbHVlOiBcIlwiLCBleHBpcmVzOiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoMCkgfSk7XG4gIH1cbiAgW1N5bWJvbC5mb3IoXCJlZGdlLXJ1bnRpbWUuaW5zcGVjdC5jdXN0b21cIildKCkge1xuICAgIHJldHVybiBgUmVzcG9uc2VDb29raWVzICR7SlNPTi5zdHJpbmdpZnkoT2JqZWN0LmZyb21FbnRyaWVzKHRoaXMuX3BhcnNlZCkpfWA7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIFsuLi50aGlzLl9wYXJzZWQudmFsdWVzKCldLm1hcChzdHJpbmdpZnlDb29raWUpLmpvaW4oXCI7IFwiKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHJlcGxhY2UoYmFnLCBoZWFkZXJzKSB7XG4gIGhlYWRlcnMuZGVsZXRlKFwic2V0LWNvb2tpZVwiKTtcbiAgZm9yIChjb25zdCBbLCB2YWx1ZV0gb2YgYmFnKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IHN0cmluZ2lmeUNvb2tpZSh2YWx1ZSk7XG4gICAgaGVhZGVycy5hcHBlbmQoXCJzZXQtY29va2llXCIsIHNlcmlhbGl6ZWQpO1xuICB9XG59XG5mdW5jdGlvbiBub3JtYWxpemVDb29raWUoY29va2llID0geyBuYW1lOiBcIlwiLCB2YWx1ZTogXCJcIiB9KSB7XG4gIGlmICh0eXBlb2YgY29va2llLmV4cGlyZXMgPT09IFwibnVtYmVyXCIpIHtcbiAgICBjb29raWUuZXhwaXJlcyA9IG5ldyBEYXRlKGNvb2tpZS5leHBpcmVzKTtcbiAgfVxuICBpZiAoY29va2llLm1heEFnZSkge1xuICAgIGNvb2tpZS5leHBpcmVzID0gbmV3IERhdGUoRGF0ZS5ub3coKSArIGNvb2tpZS5tYXhBZ2UgKiAxZTMpO1xuICB9XG4gIGlmIChjb29raWUucGF0aCA9PT0gbnVsbCB8fCBjb29raWUucGF0aCA9PT0gdm9pZCAwKSB7XG4gICAgY29va2llLnBhdGggPSBcIi9cIjtcbiAgfVxuICByZXR1cm4gY29va2llO1xufVxuLy8gQW5ub3RhdGUgdGhlIENvbW1vbkpTIGV4cG9ydCBuYW1lcyBmb3IgRVNNIGltcG9ydCBpbiBub2RlOlxuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gIFJlcXVlc3RDb29raWVzLFxuICBSZXNwb25zZUNvb2tpZXMsXG4gIHBhcnNlQ29va2llLFxuICBwYXJzZVNldENvb2tpZSxcbiAgc3RyaW5naWZ5Q29va2llXG59KTtcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxJQUFJLFlBQVksT0FBTyxjQUFjO0FBQ3JDLElBQUksbUJBQW1CLE9BQU8sd0JBQXdCO0FBQ3RELElBQUksb0JBQW9CLE9BQU8sbUJBQW1CO0FBQ2xELElBQUksZUFBZSxPQUFPLFNBQVMsQ0FBQyxjQUFjO0FBQ2xELElBQUksV0FBVyxDQUFDLFFBQVE7SUFDdEIsSUFBSyxJQUFJLFFBQVEsSUFDZixVQUFVLFFBQVEsTUFBTTtRQUFFLEtBQUssR0FBRyxDQUFDLEtBQUs7UUFBRSxZQUFZO0lBQUs7QUFDL0Q7QUFDQSxJQUFJLGNBQWMsQ0FBQyxJQUFJLE1BQU0sUUFBUTtJQUNuQyxJQUFJLFFBQVEsT0FBTyxTQUFTLFlBQVksT0FBTyxTQUFTLFlBQVk7UUFDbEUsS0FBSyxJQUFJLE9BQU8sa0JBQWtCLE1BQ2hDLElBQUksQ0FBQyxhQUFhLElBQUksQ0FBQyxJQUFJLFFBQVEsUUFBUSxRQUN6QyxVQUFVLElBQUksS0FBSztZQUFFLEtBQUssSUFBTSxJQUFJLENBQUMsSUFB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SUFDRjtBQThDRjtBQUNBLFNBQVMsUUFBUSxHQUFHLEVBQUUsT0FBTztJQUMzQixRQUFRLE1BQU0sQ0FBQztJQUNmLEtBQUssTUFBTSxHQUFHLE1BQU0sSUFBSSxJQUFLO1FBQzNCLE1BQU0sYUFBYSxnQkFBZ0I7UUFDbkMsUUFBUSxNQUFNLENBQUMsY0FBYztJQUMvQjtBQUNGO0FBQ0EsU0FBUztRQUFnQixTQUFBLGlFQUFTO1FBQUUsTUFBTTtRQUFJLE9BQU87SUFBRztJQUN0RCxJQUFJLE9BQU8sT0FBTyxPQUFPLEtBQUssVUFBVTtRQUN0QyxPQUFPLE9BQU8sR0FBRyxJQUFJLEtBQUssT0FBTyxPQUFPO0lBQzFDO0lBQ0EsSUFBSSxPQUFPLE1BQU0sRUFBRTtRQUNqQixPQUFPLE9BQU8sR0FBRyxJQUFJLEtBQUssS0FBSyxHQUFHLEtBQUssT0FBTyxNQUFNLEdBQUc7SUFDekQ7SUFDQSxJQUFJLE9BQU8sSUFBSSxLQUFLLFFBQVEsT0FBTyxJQUFJLEtBQUssS0FBSyxHQUFHO1FBQ2xELE9BQU8sSUFBSSxHQUFHO0lBQ2hCO0lBQ0EsT0FBTztBQUNUO0FBQ0EsNkRBQTZEO0FBQzdELEtBQUssQ0FBQyxPQUFPLE9BQU8sR0FBRztJQUNyQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0FBQ0YsQ0FBQyIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA0MTksICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvc2VydmVyL3dlYi9zcGVjLWV4dGVuc2lvbi9jb29raWVzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7XG4gIFJlcXVlc3RDb29raWVzLFxuICBSZXNwb25zZUNvb2tpZXMsXG4gIHN0cmluZ2lmeUNvb2tpZSxcbn0gZnJvbSAnbmV4dC9kaXN0L2NvbXBpbGVkL0BlZGdlLXJ1bnRpbWUvY29va2llcydcbiJdLCJuYW1lcyI6WyJSZXF1ZXN0Q29va2llcyIsIlJlc3BvbnNlQ29va2llcyIsInN0cmluZ2lmeUNvb2tpZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0lBQ0VBLGNBQWMsRUFBQTtlQUFkQSxTQUFBQSxjQUFjOztJQUNkQyxlQUFlLEVBQUE7ZUFBZkEsU0FBQUEsZUFBZTs7SUFDZkMsZUFBZSxFQUFBO2VBQWZBLFNBQUFBLGVBQWU7Ozt5QkFDViIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA0NTEsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvc2VydmVyL3dlYi9zcGVjLWV4dGVuc2lvbi9hZGFwdGVycy9yZXF1ZXN0LWNvb2tpZXMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUmVxdWVzdENvb2tpZXMgfSBmcm9tICcuLi9jb29raWVzJ1xuXG5pbXBvcnQgeyBSZXNwb25zZUNvb2tpZXMgfSBmcm9tICcuLi9jb29raWVzJ1xuaW1wb3J0IHsgUmVmbGVjdEFkYXB0ZXIgfSBmcm9tICcuL3JlZmxlY3QnXG5pbXBvcnQgeyB3b3JrQXN5bmNTdG9yYWdlIH0gZnJvbSAnLi4vLi4vLi4vYXBwLXJlbmRlci93b3JrLWFzeW5jLXN0b3JhZ2UuZXh0ZXJuYWwnXG5pbXBvcnQge1xuICBnZXRFeHBlY3RlZFJlcXVlc3RTdG9yZSxcbiAgdHlwZSBSZXF1ZXN0U3RvcmUsXG59IGZyb20gJy4uLy4uLy4uL2FwcC1yZW5kZXIvd29yay11bml0LWFzeW5jLXN0b3JhZ2UuZXh0ZXJuYWwnXG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjbGFzcyBSZWFkb25seVJlcXVlc3RDb29raWVzRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFxuICAgICAgJ0Nvb2tpZXMgY2FuIG9ubHkgYmUgbW9kaWZpZWQgaW4gYSBTZXJ2ZXIgQWN0aW9uIG9yIFJvdXRlIEhhbmRsZXIuIFJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2FwaS1yZWZlcmVuY2UvZnVuY3Rpb25zL2Nvb2tpZXMjb3B0aW9ucydcbiAgICApXG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGNhbGxhYmxlKCkge1xuICAgIHRocm93IG5ldyBSZWFkb25seVJlcXVlc3RDb29raWVzRXJyb3IoKVxuICB9XG59XG5cbi8vIFdlIHVzZSB0aGlzIHRvIHR5cGUgc29tZSBBUElzIGJ1dCB3ZSBkb24ndCBjb25zdHJ1Y3QgaW5zdGFuY2VzIGRpcmVjdGx5XG5leHBvcnQgdHlwZSB7IFJlc3BvbnNlQ29va2llcyB9XG5cbi8vIFRoZSBgY29va2llcygpYCBBUEkgaXMgYSBtaXggb2YgcmVxdWVzdCBhbmQgcmVzcG9uc2UgY29va2llcy4gRm9yIGAuZ2V0KClgIG1ldGhvZHMsXG4vLyB3ZSB3YW50IHRvIHJldHVybiB0aGUgcmVxdWVzdCBjb29raWUgaWYgaXQgZXhpc3RzLiBGb3IgbXV0YXRpdmUgbWV0aG9kcyBsaWtlIGAuc2V0KClgLFxuLy8gd2Ugd2FudCB0byByZXR1cm4gdGhlIHJlc3BvbnNlIGNvb2tpZS5cbmV4cG9ydCB0eXBlIFJlYWRvbmx5UmVxdWVzdENvb2tpZXMgPSBPbWl0PFxuICBSZXF1ZXN0Q29va2llcyxcbiAgJ3NldCcgfCAnY2xlYXInIHwgJ2RlbGV0ZSdcbj4gJlxuICBQaWNrPFJlc3BvbnNlQ29va2llcywgJ3NldCcgfCAnZGVsZXRlJz5cblxuZXhwb3J0IGNsYXNzIFJlcXVlc3RDb29raWVzQWRhcHRlciB7XG4gIHB1YmxpYyBzdGF0aWMgc2VhbChjb29raWVzOiBSZXF1ZXN0Q29va2llcyk6IFJlYWRvbmx5UmVxdWVzdENvb2tpZXMge1xuICAgIHJldHVybiBuZXcgUHJveHkoY29va2llcyBhcyBhbnksIHtcbiAgICAgIGdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG4gICAgICAgIHN3aXRjaCAocHJvcCkge1xuICAgICAgICAgIGNhc2UgJ2NsZWFyJzpcbiAgICAgICAgICBjYXNlICdkZWxldGUnOlxuICAgICAgICAgIGNhc2UgJ3NldCc6XG4gICAgICAgICAgICByZXR1cm4gUmVhZG9ubHlSZXF1ZXN0Q29va2llc0Vycm9yLmNhbGxhYmxlXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0QWRhcHRlci5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcilcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9KVxuICB9XG59XG5cbmNvbnN0IFNZTUJPTF9NT0RJRllfQ09PS0lFX1ZBTFVFUyA9IFN5bWJvbC5mb3IoJ25leHQubXV0YXRlZC5jb29raWVzJylcblxuZXhwb3J0IGZ1bmN0aW9uIGdldE1vZGlmaWVkQ29va2llVmFsdWVzKFxuICBjb29raWVzOiBSZXNwb25zZUNvb2tpZXNcbik6IFJlc3BvbnNlQ29va2llW10ge1xuICBjb25zdCBtb2RpZmllZDogUmVzcG9uc2VDb29raWVbXSB8IHVuZGVmaW5lZCA9IChjb29raWVzIGFzIHVua25vd24gYXMgYW55KVtcbiAgICBTWU1CT0xfTU9ESUZZX0NPT0tJRV9WQUxVRVNcbiAgXVxuICBpZiAoIW1vZGlmaWVkIHx8ICFBcnJheS5pc0FycmF5KG1vZGlmaWVkKSB8fCBtb2RpZmllZC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW11cbiAgfVxuXG4gIHJldHVybiBtb2RpZmllZFxufVxuXG50eXBlIFNldENvb2tpZUFyZ3MgPVxuICB8IFtrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZywgY29va2llPzogUGFydGlhbDxSZXNwb25zZUNvb2tpZT5dXG4gIHwgW29wdGlvbnM6IFJlc3BvbnNlQ29va2llXVxuXG5leHBvcnQgZnVuY3Rpb24gYXBwZW5kTXV0YWJsZUNvb2tpZXMoXG4gIGhlYWRlcnM6IEhlYWRlcnMsXG4gIG11dGFibGVDb29raWVzOiBSZXNwb25zZUNvb2tpZXNcbik6IGJvb2xlYW4ge1xuICBjb25zdCBtb2RpZmllZENvb2tpZVZhbHVlcyA9IGdldE1vZGlmaWVkQ29va2llVmFsdWVzKG11dGFibGVDb29raWVzKVxuICBpZiAobW9kaWZpZWRDb29raWVWYWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBSZXR1cm4gYSBuZXcgcmVzcG9uc2UgdGhhdCBleHRlbmRzIHRoZSByZXNwb25zZSB3aXRoXG4gIC8vIHRoZSBtb2RpZmllZCBjb29raWVzIGFzIGZhbGxiYWNrcy4gYHJlc2AgY29va2llc1xuICAvLyB3aWxsIHN0aWxsIHRha2UgcHJlY2VkZW5jZS5cbiAgY29uc3QgcmVzQ29va2llcyA9IG5ldyBSZXNwb25zZUNvb2tpZXMoaGVhZGVycylcbiAgY29uc3QgcmV0dXJuZWRDb29raWVzID0gcmVzQ29va2llcy5nZXRBbGwoKVxuXG4gIC8vIFNldCB0aGUgbW9kaWZpZWQgY29va2llcyBhcyBmYWxsYmFja3MuXG4gIGZvciAoY29uc3QgY29va2llIG9mIG1vZGlmaWVkQ29va2llVmFsdWVzKSB7XG4gICAgcmVzQ29va2llcy5zZXQoY29va2llKVxuICB9XG5cbiAgLy8gU2V0IHRoZSBvcmlnaW5hbCBjb29raWVzIGFzIHRoZSBmaW5hbCB2YWx1ZXMuXG4gIGZvciAoY29uc3QgY29va2llIG9mIHJldHVybmVkQ29va2llcykge1xuICAgIHJlc0Nvb2tpZXMuc2V0KGNvb2tpZSlcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbnR5cGUgUmVzcG9uc2VDb29raWUgPSBOb25OdWxsYWJsZTxcbiAgUmV0dXJuVHlwZTxJbnN0YW5jZVR5cGU8dHlwZW9mIFJlc3BvbnNlQ29va2llcz5bJ2dldCddPlxuPlxuXG5leHBvcnQgY2xhc3MgTXV0YWJsZVJlcXVlc3RDb29raWVzQWRhcHRlciB7XG4gIHB1YmxpYyBzdGF0aWMgd3JhcChcbiAgICBjb29raWVzOiBSZXF1ZXN0Q29va2llcyxcbiAgICBvblVwZGF0ZUNvb2tpZXM/OiAoY29va2llczogc3RyaW5nW10pID0+IHZvaWRcbiAgKTogUmVzcG9uc2VDb29raWVzIHtcbiAgICBjb25zdCByZXNwb25zZUNvb2tpZXMgPSBuZXcgUmVzcG9uc2VDb29raWVzKG5ldyBIZWFkZXJzKCkpXG4gICAgZm9yIChjb25zdCBjb29raWUgb2YgY29va2llcy5nZXRBbGwoKSkge1xuICAgICAgcmVzcG9uc2VDb29raWVzLnNldChjb29raWUpXG4gICAgfVxuXG4gICAgbGV0IG1vZGlmaWVkVmFsdWVzOiBSZXNwb25zZUNvb2tpZVtdID0gW11cbiAgICBjb25zdCBtb2RpZmllZENvb2tpZXMgPSBuZXcgU2V0PHN0cmluZz4oKVxuICAgIGNvbnN0IHVwZGF0ZVJlc3BvbnNlQ29va2llcyA9ICgpID0+IHtcbiAgICAgIC8vIFRPRE8tQVBQOiBjaGFuZ2UgbWV0aG9kIG9mIGdldHRpbmcgd29ya1N0b3JlXG4gICAgICBjb25zdCB3b3JrU3RvcmUgPSB3b3JrQXN5bmNTdG9yYWdlLmdldFN0b3JlKClcbiAgICAgIGlmICh3b3JrU3RvcmUpIHtcbiAgICAgICAgd29ya1N0b3JlLnBhdGhXYXNSZXZhbGlkYXRlZCA9IHRydWVcbiAgICAgIH1cblxuICAgICAgY29uc3QgYWxsQ29va2llcyA9IHJlc3BvbnNlQ29va2llcy5nZXRBbGwoKVxuICAgICAgbW9kaWZpZWRWYWx1ZXMgPSBhbGxDb29raWVzLmZpbHRlcigoYykgPT4gbW9kaWZpZWRDb29raWVzLmhhcyhjLm5hbWUpKVxuICAgICAgaWYgKG9uVXBkYXRlQ29va2llcykge1xuICAgICAgICBjb25zdCBzZXJpYWxpemVkQ29va2llczogc3RyaW5nW10gPSBbXVxuICAgICAgICBmb3IgKGNvbnN0IGNvb2tpZSBvZiBtb2RpZmllZFZhbHVlcykge1xuICAgICAgICAgIGNvbnN0IHRlbXBDb29raWVzID0gbmV3IFJlc3BvbnNlQ29va2llcyhuZXcgSGVhZGVycygpKVxuICAgICAgICAgIHRlbXBDb29raWVzLnNldChjb29raWUpXG4gICAgICAgICAgc2VyaWFsaXplZENvb2tpZXMucHVzaCh0ZW1wQ29va2llcy50b1N0cmluZygpKVxuICAgICAgICB9XG5cbiAgICAgICAgb25VcGRhdGVDb29raWVzKHNlcmlhbGl6ZWRDb29raWVzKVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHdyYXBwZWRDb29raWVzID0gbmV3IFByb3h5KHJlc3BvbnNlQ29va2llcywge1xuICAgICAgZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICAgICAgc3dpdGNoIChwcm9wKSB7XG4gICAgICAgICAgLy8gQSBzcGVjaWFsIHN5bWJvbCB0byBnZXQgdGhlIG1vZGlmaWVkIGNvb2tpZSB2YWx1ZXNcbiAgICAgICAgICBjYXNlIFNZTUJPTF9NT0RJRllfQ09PS0lFX1ZBTFVFUzpcbiAgICAgICAgICAgIHJldHVybiBtb2RpZmllZFZhbHVlc1xuXG4gICAgICAgICAgLy8gVE9ETzogVGhyb3cgZXJyb3IgaWYgdHJ5aW5nIHRvIHNldCBhIGNvb2tpZSBhZnRlciB0aGUgcmVzcG9uc2VcbiAgICAgICAgICAvLyBoZWFkZXJzIGhhdmUgYmVlbiBzZXQuXG4gICAgICAgICAgY2FzZSAnZGVsZXRlJzpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJnczogW3N0cmluZ10gfCBbUmVzcG9uc2VDb29raWVdKSB7XG4gICAgICAgICAgICAgIG1vZGlmaWVkQ29va2llcy5hZGQoXG4gICAgICAgICAgICAgICAgdHlwZW9mIGFyZ3NbMF0gPT09ICdzdHJpbmcnID8gYXJnc1swXSA6IGFyZ3NbMF0ubmFtZVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LmRlbGV0ZSguLi5hcmdzKVxuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkQ29va2llc1xuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZVJlc3BvbnNlQ29va2llcygpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdzZXQnOlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzOiBTZXRDb29raWVBcmdzKSB7XG4gICAgICAgICAgICAgIG1vZGlmaWVkQ29va2llcy5hZGQoXG4gICAgICAgICAgICAgICAgdHlwZW9mIGFyZ3NbMF0gPT09ICdzdHJpbmcnID8gYXJnc1swXSA6IGFyZ3NbMF0ubmFtZVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnNldCguLi5hcmdzKVxuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkQ29va2llc1xuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZVJlc3BvbnNlQ29va2llcygpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdEFkYXB0ZXIuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfSlcblxuICAgIHJldHVybiB3cmFwcGVkQ29va2llc1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3cmFwV2l0aE11dGFibGVBY2Nlc3NDaGVjayhcbiAgcmVzcG9uc2VDb29raWVzOiBSZXNwb25zZUNvb2tpZXNcbik6IFJlc3BvbnNlQ29va2llcyB7XG4gIGNvbnN0IHdyYXBwZWRDb29raWVzID0gbmV3IFByb3h5KHJlc3BvbnNlQ29va2llcywge1xuICAgIGdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG4gICAgICBzd2l0Y2ggKHByb3ApIHtcbiAgICAgICAgY2FzZSAnZGVsZXRlJzpcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3M6IFtzdHJpbmddIHwgW1Jlc3BvbnNlQ29va2llXSkge1xuICAgICAgICAgICAgZW5zdXJlQ29va2llc0FyZVN0aWxsTXV0YWJsZSgnY29va2llcygpLmRlbGV0ZScpXG4gICAgICAgICAgICB0YXJnZXQuZGVsZXRlKC4uLmFyZ3MpXG4gICAgICAgICAgICByZXR1cm4gd3JhcHBlZENvb2tpZXNcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3NldCc6XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzOiBTZXRDb29raWVBcmdzKSB7XG4gICAgICAgICAgICBlbnN1cmVDb29raWVzQXJlU3RpbGxNdXRhYmxlKCdjb29raWVzKCkuc2V0JylcbiAgICAgICAgICAgIHRhcmdldC5zZXQoLi4uYXJncylcbiAgICAgICAgICAgIHJldHVybiB3cmFwcGVkQ29va2llc1xuICAgICAgICAgIH1cblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBSZWZsZWN0QWRhcHRlci5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcilcbiAgICAgIH1cbiAgICB9LFxuICB9KVxuICByZXR1cm4gd3JhcHBlZENvb2tpZXNcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFyZUNvb2tpZXNNdXRhYmxlSW5DdXJyZW50UGhhc2UocmVxdWVzdFN0b3JlOiBSZXF1ZXN0U3RvcmUpIHtcbiAgcmV0dXJuIHJlcXVlc3RTdG9yZS5waGFzZSA9PT0gJ2FjdGlvbidcbn1cblxuLyoqIEVuc3VyZSB0aGF0IGNvb2tpZXMoKSBzdGFydHMgdGhyb3dpbmcgb24gbXV0YXRpb25cbiAqIGlmIHdlIGNoYW5nZWQgcGhhc2VzIGFuZCBjYW4gbm8gbG9uZ2VyIG11dGF0ZS5cbiAqXG4gKiBUaGlzIGNhbiBoYXBwZW4gd2hlbiBnb2luZzpcbiAqICAgJ3JlbmRlcicgLT4gJ2FmdGVyJ1xuICogICAnYWN0aW9uJyAtPiAncmVuZGVyJ1xuICogKi9cbmZ1bmN0aW9uIGVuc3VyZUNvb2tpZXNBcmVTdGlsbE11dGFibGUoY2FsbGluZ0V4cHJlc3Npb246IHN0cmluZykge1xuICBjb25zdCByZXF1ZXN0U3RvcmUgPSBnZXRFeHBlY3RlZFJlcXVlc3RTdG9yZShjYWxsaW5nRXhwcmVzc2lvbilcbiAgaWYgKCFhcmVDb29raWVzTXV0YWJsZUluQ3VycmVudFBoYXNlKHJlcXVlc3RTdG9yZSkpIHtcbiAgICAvLyBUT0RPOiBtYXliZSB3ZSBjYW4gZ2l2ZSBhIG1vcmUgcHJlY2lzZSBlcnJvciBtZXNzYWdlIGJhc2VkIG9uIGNhbGxpbmdFeHByZXNzaW9uP1xuICAgIHRocm93IG5ldyBSZWFkb25seVJlcXVlc3RDb29raWVzRXJyb3IoKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNwb25zZUNvb2tpZXNUb1JlcXVlc3RDb29raWVzKFxuICByZXNwb25zZUNvb2tpZXM6IFJlc3BvbnNlQ29va2llc1xuKTogUmVxdWVzdENvb2tpZXMge1xuICBjb25zdCByZXF1ZXN0Q29va2llcyA9IG5ldyBSZXF1ZXN0Q29va2llcyhuZXcgSGVhZGVycygpKVxuICBmb3IgKGNvbnN0IGNvb2tpZSBvZiByZXNwb25zZUNvb2tpZXMuZ2V0QWxsKCkpIHtcbiAgICByZXF1ZXN0Q29va2llcy5zZXQoY29va2llKVxuICB9XG4gIHJldHVybiByZXF1ZXN0Q29va2llc1xufVxuIl0sIm5hbWVzIjpbIk11dGFibGVSZXF1ZXN0Q29va2llc0FkYXB0ZXIiLCJSZWFkb25seVJlcXVlc3RDb29raWVzRXJyb3IiLCJSZXF1ZXN0Q29va2llc0FkYXB0ZXIiLCJhcHBlbmRNdXRhYmxlQ29va2llcyIsImFyZUNvb2tpZXNNdXRhYmxlSW5DdXJyZW50UGhhc2UiLCJnZXRNb2RpZmllZENvb2tpZVZhbHVlcyIsInJlc3BvbnNlQ29va2llc1RvUmVxdWVzdENvb2tpZXMiLCJ3cmFwV2l0aE11dGFibGVBY2Nlc3NDaGVjayIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJjYWxsYWJsZSIsInNlYWwiLCJjb29raWVzIiwiUHJveHkiLCJnZXQiLCJ0YXJnZXQiLCJwcm9wIiwicmVjZWl2ZXIiLCJSZWZsZWN0QWRhcHRlciIsIlNZTUJPTF9NT0RJRllfQ09PS0lFX1ZBTFVFUyIsIlN5bWJvbCIsImZvciIsIm1vZGlmaWVkIiwiQXJyYXkiLCJpc0FycmF5IiwibGVuZ3RoIiwiaGVhZGVycyIsIm11dGFibGVDb29raWVzIiwibW9kaWZpZWRDb29raWVWYWx1ZXMiLCJyZXNDb29raWVzIiwiUmVzcG9uc2VDb29raWVzIiwicmV0dXJuZWRDb29raWVzIiwiZ2V0QWxsIiwiY29va2llIiwic2V0Iiwid3JhcCIsIm9uVXBkYXRlQ29va2llcyIsInJlc3BvbnNlQ29va2llcyIsIkhlYWRlcnMiLCJtb2RpZmllZFZhbHVlcyIsIm1vZGlmaWVkQ29va2llcyIsIlNldCIsInVwZGF0ZVJlc3BvbnNlQ29va2llcyIsIndvcmtTdG9yZSIsIndvcmtBc3luY1N0b3JhZ2UiLCJnZXRTdG9yZSIsInBhdGhXYXNSZXZhbGlkYXRlZCIsImFsbENvb2tpZXMiLCJmaWx0ZXIiLCJjIiwiaGFzIiwibmFtZSIsInNlcmlhbGl6ZWRDb29raWVzIiwidGVtcENvb2tpZXMiLCJwdXNoIiwidG9TdHJpbmciLCJ3cmFwcGVkQ29va2llcyIsImFyZ3MiLCJhZGQiLCJkZWxldGUiLCJlbnN1cmVDb29raWVzQXJlU3RpbGxNdXRhYmxlIiwicmVxdWVzdFN0b3JlIiwicGhhc2UiLCJjYWxsaW5nRXhwcmVzc2lvbiIsImdldEV4cGVjdGVkUmVxdWVzdFN0b3JlIiwicmVxdWVzdENvb2tpZXMiLCJSZXF1ZXN0Q29va2llcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUF5R2FBLDRCQUE0QixFQUFBO2VBQTVCQTs7SUE1RkFDLDJCQUEyQixFQUFBO2VBQTNCQTs7SUF3QkFDLHFCQUFxQixFQUFBO2VBQXJCQTs7SUFvQ0dDLG9CQUFvQixFQUFBO2VBQXBCQTs7SUF3SUFDLCtCQUErQixFQUFBO2VBQS9CQTs7SUF6SkFDLHVCQUF1QixFQUFBO2VBQXZCQTs7SUE0S0FDLCtCQUErQixFQUFBO2VB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N0I3QyxPQUFPbUIsR0FBRyxJQUFJdUI7d0JBQ2QsT0FBT0Q7b0JBQ1Q7Z0JBRUY7b0JBQ0UsT0FBT3RDLFNBQUFBLGNBQWMsQ0FBQ0osR0FBRyxDQUFDQyxRQUFRQyxNQUFNQztZQUM1QztRQUNGO0lBQ0Y7SUFDQSxPQUFPdUM7QUFDVDtBQUVPLFNBQVNwRCxnQ0FBZ0N5RCxZQUEwQjtJQUN4RSxPQUFPQSxhQUFhQyxLQUFLLEtBQUs7QUFDaEM7QUFFQTs7Ozs7O0dBTUcsR0FDSCxTQUFTRiw2QkFBNkJHLGlCQUF5QjtJQUM3RCxNQUFNRixlQUFlRyxDQUFBQSxHQUFBQSw4QkFBQUEsdUJBQXVCLEVBQUNEO0lBQzdDLElBQUksQ0FBQzNELGdDQUFnQ3lELGVBQWU7UUFDbEQsbUZBQW1GO1FBQ25GLE1BQU0sSUFBSTVEO0lBQ1o7QUFDRjtBQUVPLFNBQVNLLGdDQUNkK0IsZUFBZ0M7SUFFaEMsTUFBTTRCLGlCQUFpQixJQUFJQyxTQUFBQSxjQUFjLENBQUMsSUFBSTVCO0lBQzlDLEtBQUssTUFBTUwsVUFBVUksZ0JBQWdCTCxNQUFNLEdBQUk7UUFDN0NpQyxlQUFlL0IsR0FBRyxDQUFDRDtJQUNyQjtJQUNBLE9BQU9nQztBQUNUIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDY3OCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9zZXJ2ZXIvcmVxdWVzdC9jb29raWVzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIHR5cGUgUmVhZG9ubHlSZXF1ZXN0Q29va2llcyxcbiAgdHlwZSBSZXNwb25zZUNvb2tpZXMsXG4gIGFyZUNvb2tpZXNNdXRhYmxlSW5DdXJyZW50UGhhc2UsXG4gIFJlcXVlc3RDb29raWVzQWRhcHRlcixcbn0gZnJvbSAnLi4vd2ViL3NwZWMtZXh0ZW5zaW9uL2FkYXB0ZXJzL3JlcXVlc3QtY29va2llcydcbmltcG9ydCB7IFJlcXVlc3RDb29raWVzIH0gZnJvbSAnLi4vd2ViL3NwZWMtZXh0ZW5zaW9uL2Nvb2tpZXMnXG5pbXBvcnQgeyB3b3JrQXN5bmNTdG9yYWdlIH0gZnJvbSAnLi4vYXBwLXJlbmRlci93b3JrLWFzeW5jLXN0b3JhZ2UuZXh0ZXJuYWwnXG5pbXBvcnQge1xuICB3b3JrVW5pdEFzeW5jU3RvcmFnZSxcbiAgdHlwZSBQcmVyZW5kZXJTdG9yZU1vZGVybixcbn0gZnJvbSAnLi4vYXBwLXJlbmRlci93b3JrLXVuaXQtYXN5bmMtc3RvcmFnZS5leHRlcm5hbCdcbmltcG9ydCB7XG4gIHBvc3Rwb25lV2l0aFRyYWNraW5nLFxuICB0aHJvd1RvSW50ZXJydXB0U3RhdGljR2VuZXJhdGlvbixcbiAgdHJhY2tEeW5hbWljRGF0YUluRHluYW1pY1JlbmRlcixcbiAgdHJhY2tTeW5jaHJvbm91c1JlcXVlc3REYXRhQWNjZXNzSW5EZXYsXG59IGZyb20gJy4uL2FwcC1yZW5kZXIvZHluYW1pYy1yZW5kZXJpbmcnXG5pbXBvcnQgeyBnZXRFeHBlY3RlZFJlcXVlc3RTdG9yZSB9IGZyb20gJy4uL2FwcC1yZW5kZXIvd29yay11bml0LWFzeW5jLXN0b3JhZ2UuZXh0ZXJuYWwnXG5pbXBvcnQgeyBTdGF0aWNHZW5CYWlsb3V0RXJyb3IgfSBmcm9tICcuLi8uLi9jbGllbnQvY29tcG9uZW50cy9zdGF0aWMtZ2VuZXJhdGlvbi1iYWlsb3V0J1xuaW1wb3J0IHsgbWFrZUhhbmdpbmdQcm9taXNlIH0gZnJvbSAnLi4vZHluYW1pYy1yZW5kZXJpbmctdXRpbHMnXG5pbXBvcnQgeyBjcmVhdGVEZWR1cGVkQnlDYWxsc2l0ZVNlcnZlckVycm9yTG9nZ2VyRGV2IH0gZnJvbSAnLi4vY3JlYXRlLWRlZHVwZWQtYnktY2FsbHNpdGUtc2VydmVyLWVycm9yLWxvZ2dlcidcbmltcG9ydCB7IHNjaGVkdWxlSW1tZWRpYXRlIH0gZnJvbSAnLi4vLi4vbGliL3NjaGVkdWxlcidcbmltcG9ydCB7IGlzUmVxdWVzdEFQSUNhbGxhYmxlSW5zaWRlQWZ0ZXIgfSBmcm9tICcuL3V0aWxzJ1xuaW1wb3J0IHsgSW52YXJpYW50RXJyb3IgfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL2ludmFyaWFudC1lcnJvcidcbmltcG9ydCB7IFJlZmxlY3RBZGFwdGVyIH0gZnJvbSAnLi4vd2ViL3NwZWMtZXh0ZW5zaW9uL2FkYXB0ZXJzL3JlZmxlY3QnXG5cbi8qKlxuICogSW4gdGhpcyB2ZXJzaW9uIG9mIE5leHQuanMgYGNvb2tpZXMoKWAgcmV0dXJucyBhIFByb21pc2UgaG93ZXZlciB5b3UgY2FuIHN0aWxsIHJlZmVyZW5jZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgdW5kZXJseWluZyBjb29raWVzIG9iamVjdFxuICogc3luY2hyb25vdXNseSB0byBmYWNpbGl0YXRlIG1pZ3JhdGlvbi4gVGhlIGBVbnNhZmVVbndyYXBwZWRDb29raWVzYCB0eXBlIGlzIGFkZGVkIHRvIHlvdXIgY29kZSBieSBhIGNvZGVtb2QgdGhhdCBhdHRlbXB0cyB0byBhdXRvbWF0aWNhbGx5XG4gKiB1cGRhdGVzIGNhbGxzaXRlcyB0byByZWZsZWN0IHRoZSBuZXcgUHJvbWlzZSByZXR1cm4gdHlwZS4gVGhlcmUgYXJlIHNvbWUgY2FzZXMgd2hlcmUgYGNvb2tpZXMoKWAgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkLCBuYW1lbHlcbiAqIHdoZW4gaXQgaXMgdXNlZCBpbnNpZGUgYSBzeW5jaHJvbm91cyBmdW5jdGlvbiBhbmQgd2UgY2FuJ3QgYmUgc3VyZSB0aGUgZnVuY3Rpb24gY2FuIGJlIG1hZGUgYXN5bmMgYXV0b21hdGljYWxseS4gSW4gdGhlc2UgY2FzZXMgd2UgYWRkIGFuXG4gKiBleHBsaWNpdCB0eXBlIGNhc2UgdG8gYFVuc2FmZVVud3JhcHBlZENvb2tpZXNgIHRvIGVuYWJsZSB0eXBlc2NyaXB0IHRvIGFsbG93IGZvciB0aGUgc3luY2hyb25vdXMgdXNhZ2Ugb25seSB3aGVyZSBpdCBpcyBhY3R1YWxseSBuZWNlc3NhcnkuXG4gKlxuICogWW91IHNob3VsZCBzaG91bGQgdXBkYXRlIHRoZXNlIGNhbGxzaXRlcyB0byBlaXRoZXIgYmUgYXN5bmMgZnVuY3Rpb25zIHdoZXJlIHRoZSBgY29va2llcygpYCB2YWx1ZSBjYW4gYmUgYXdhaXRlZCBvciB5b3Ugc2hvdWxkIGNhbGwgYGNvb2tpZXMoKWBcbiAqIGZyb20gb3V0c2lkZSBhbmQgYXdhaXQgdGhlIHJldHVybiB2YWx1ZSBiZWZvcmUgcGFzc2luZyBpdCBpbnRvIHRoaXMgZnVuY3Rpb24uXG4gKlxuICogWW91IGNhbiBmaW5kIGluc3RhbmNlcyB0aGF0IHJlcXVpcmUgbWFudWFsIG1pZ3JhdGlvbiBieSBzZWFyY2hpbmcgZm9yIGBVbnNhZmVVbndyYXBwZWRDb29raWVzYCBpbiB5b3VyIGNvZGViYXNlIG9yIGJ5IHNlYXJjaCBmb3IgYSBjb21tZW50IHRoYXRcbiAqIHN0YXJ0cyB3aXRoIGBAbmV4dC1jb2RlbW9kLWVycm9yYC5cbiAqXG4gKiBJbiBhIGZ1dHVyZSB2ZXJzaW9uIG9mIE5leHQuanMgYGNvb2tpZXMoKWAgd2lsbCBvbmx5IHJldHVybiBhIFByb21pc2UgYW5kIHlvdSB3aWxsIG5vdCBiZSBhYmxlIHRvIGFjY2VzcyB0aGUgdW5kZXJseWluZyBjb29raWVzIG9iamVjdCBkaXJlY3RseVxuICogd2l0aG91dCBhd2FpdGluZyB0aGUgcmV0dXJuIHZhbHVlIGZpcnN0LiBXaGVuIHRoaXMgY2hhbmdlIGhhcHBlbnMgdGhlIHR5cGUgYFVuc2FmZVVud3JhcHBlZENvb2tpZXNgIHdpbGwgYmUgdXBkYXRlZCB0byByZWZsZWN0IHRoYXQgaXMgaXQgbm8gbG9uZ2VyXG4gKiB1c2FibGUuXG4gKlxuICogVGhpcyB0eXBlIGlzIG1hcmtlZCBkZXByZWNhdGVkIHRvIGhlbHAgaWRlbnRpZnkgaXQgYXMgdGFyZ2V0IGZvciByZWZhY3RvcmluZyBhd2F5LlxuICpcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmV4cG9ydCB0eXBlIFVuc2FmZVVud3JhcHBlZENvb2tpZXMgPSBSZWFkb25seVJlcXVlc3RDb29raWVzXG5cbmV4cG9ydCBmdW5jdGlvbiBjb29raWVzKCk6IFByb21pc2U8UmVhZG9ubHlSZXF1ZXN0Q29va2llcz4ge1xuICBjb25zdCBjYWxsaW5nRXhwcmVzc2lvbiA9ICdjb29raWVzJ1xuICBjb25zdCB3b3JrU3RvcmUgPSB3b3JrQXN5bmNTdG9yYWdlLmdldFN0b3JlKClcbiAgY29uc3Qgd29ya1VuaXRTdG9yZSA9IHdvcmtVbml0QXN5bmNTdG9yYWdlLmdldFN0b3JlKClcblxuICBpZiAod29ya1N0b3JlKSB7XG4gICAgaWYgKFxuICAgICAgd29ya1VuaXRTdG9yZSAmJlxuICAgICAgd29ya1VuaXRTdG9yZS5waGFzZSA9PT0gJ2FmdGVyJyAmJlxuICAgICAgIWlzUmVxdWVzdEFQSUNhbGxhYmxlSW5zaWRlQWZ0ZXIoKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAvLyBUT0RPKGFmdGVyKTogY2xhcmlmeSB0aGF0IHRoaXMgb25seSBhcHBsaWVzIHRvIHBhZ2VzP1xuICAgICAgICBgUm91dGUgJHt3b3JrU3RvcmUucm91dGV9IHVzZWQgXCJjb29raWVzXCIgaW5zaWRlIFwiYWZ0ZXIoLi4uKVwiLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQuIElmIHlvdSBuZWVkIHRoaXMgZGF0YSBpbnNpZGUgYW4gXCJhZnRlclwiIGNhbGxiYWNrLCB1c2UgXCJjb29raWVzXCIgb3V0c2lkZSBvZiB0aGUgY2FsbGJhY2suIFNlZSBtb3JlIGluZm8gaGVyZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvY2FuYXJ5L2FwcC9hcGktcmVmZXJlbmNlL2Z1bmN0aW9ucy9hZnRlcmBcbiAgICAgIClcbiAgICB9XG5cbiAgICBpZiAod29ya1N0b3JlLmZvcmNlU3RhdGljKSB7XG4gICAgICAvLyBXaGVuIHVzaW5nIGZvcmNlU3RhdGljIHdlIG92ZXJyaWRlIGFsbCBvdGhlciBsb2dpYyBhbmQgYWx3YXlzIGp1c3QgcmV0dXJuIGFuIGVtcHR5XG4gICAgICAvLyBjb29raWVzIG9iamVjdCB3aXRob3V0IHRyYWNraW5nXG4gICAgICBjb25zdCB1bmRlcmx5aW5nQ29va2llcyA9IGNyZWF0ZUVtcHR5Q29va2llcygpXG4gICAgICByZXR1cm4gbWFrZVVudHJhY2tlZEV4b3RpY0Nvb2tpZXModW5kZXJseWluZ0Nvb2tpZXMpXG4gICAgfVxuXG4gICAgaWYgKHdvcmtVbml0U3RvcmUpIHtcbiAgICAgIGlmICh3b3JrVW5pdFN0b3JlLnR5cGUgPT09ICdjYWNoZScpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBSb3V0ZSAke3dvcmtTdG9yZS5yb3V0ZX0gdXNlZCBcImNvb2tpZXNcIiBpbnNpZGUgXCJ1c2UgY2FjaGVcIi4gQWNjZXNzaW5nIER5bmFtaWMgZGF0YSBzb3VyY2VzIGluc2lkZSBhIGNhY2hlIHNjb3BlIGlzIG5vdCBzdXBwb3J0ZWQuIElmIHlvdSBuZWVkIHRoaXMgZGF0YSBpbnNpZGUgYSBjYWNoZWQgZnVuY3Rpb24gdXNlIFwiY29va2llc1wiIG91dHNpZGUgb2YgdGhlIGNhY2hlZCBmdW5jdGlvbiBhbmQgcGFzcyB0aGUgcmVxdWlyZWQgZHluYW1pYyBkYXRhIGluIGFzIGFuIGFyZ3VtZW50LiBTZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL25leHQtcmVxdWVzdC1pbi11c2UtY2FjaGVgXG4gICAgICAgIClcbiAgICAgIH0gZWxzZSBpZiAod29ya1VuaXRTdG9yZS50eXBlID09PSAndW5zdGFibGUtY2FjaGUnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgUm91dGUgJHt3b3JrU3RvcmUucm91dGV9IHVzZWQgXCJjb29raWVzXCIgaW5zaWRlIGEgZnVuY3Rpb24gY2FjaGVkIHdpdGggXCJ1bnN0YWJsZV9jYWNoZSguLi4pXCIuIEFjY2Vzc2luZyBEeW5hbWljIGRhdGEgc291cmNlcyBpbnNpZGUgYSBjYWNoZSBzY29wZSBpcyBub3Qgc3VwcG9ydGVkLiBJZiB5b3UgbmVlZCB0aGlzIGRhdGEgaW5zaWRlIGEgY2FjaGVkIGZ1bmN0aW9uIHVzZSBcImNvb2tpZXNcIiBvdXRzaWRlIG9mIHRoZSBjYWNoZWQgZnVuY3Rpb24gYW5kIHBhc3MgdGhlIHJlcXVpcmVkIGR5bmFtaWMgZGF0YSBpbiBhcyBhbiBhcmd1bWVudC4gU2VlIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYXBpLXJlZmVyZW5jZS9mdW5jdGlvbnMvdW5zdGFibGVfY2FjaGVgXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHdvcmtTdG9yZS5keW5hbWljU2hvdWxkRXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBTdGF0aWNHZW5CYWlsb3V0RXJyb3IoXG4gICAgICAgIGBSb3V0ZSAke3dvcmtTdG9yZS5yb3V0ZX0gd2l0aCBcXGBkeW5hbWljID0gXCJlcnJvclwiXFxgIGNvdWxkbid0IGJlIHJlbmRlcmVkIHN0YXRpY2FsbHkgYmVjYXVzZSBpdCB1c2VkIFxcYGNvb2tpZXNcXGAuIFNlZSBtb3JlIGluZm8gaGVyZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2J1aWxkaW5nLXlvdXItYXBwbGljYXRpb24vcmVuZGVyaW5nL3N0YXRpYy1hbmQtZHluYW1pYyNkeW5hbWljLXJlbmRlcmluZ2BcbiAgICAgIClcbiAgICB9XG5cbiAgICBpZiAod29ya1VuaXRTdG9yZSkge1xuICAgICAgc3dpdGNoICh3b3JrVW5pdFN0b3JlLnR5cGUpIHtcbiAgICAgICAgY2FzZSAncHJlcmVuZGVyJzpcbiAgICAgICAgICByZXR1cm4gbWFrZUhhbmdpbmdDb29raWVzKHdvcmtVbml0U3RvcmUpXG4gICAgICAgIGNhc2UgJ3ByZXJlbmRlci1jbGllbnQnOlxuICAgICAgICAgIGNvbnN0IGV4cG9ydE5hbWUgPSAnYGNvb2tpZXNgJ1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhcmlhbnRFcnJvcihcbiAgICAgICAgICAgIGAke2V4cG9ydE5hbWV9IG11c3Qgbm90IGJlIHVzZWQgd2l0aGluIGEgY2xpZW50IGNvbXBvbmVudC4gTmV4dC5qcyBzaG91bGQgYmUgcHJldmVudGluZyAke2V4cG9ydE5hbWV9IGZyb20gYmVpbmcgaW5jbHVkZWQgaW4gY2xpZW50IGNvbXBvbmVudHMgc3RhdGljYWxseSwgYnV0IGRpZCBub3QgaW4gdGhpcyBjYXNlLmBcbiAgICAgICAgICApXG4gICAgICAgIGNhc2UgJ3ByZXJlbmRlci1wcHInOlxuICAgICAgICAgIC8vIFBQUiBQcmVyZW5kZXIgKG5vIGR5bmFtaWNJTylcbiAgICAgICAgICAvLyBXZSBhcmUgcHJlcmVuZGVyaW5nIHdpdGggUFBSLiBXZSBuZWVkIHRyYWNrIGR5bmFtaWMgYWNjZXNzIGhlcmUgZWFnZXJseVxuICAgICAgICAgIC8vIHRvIGtlZXAgY29udGludWl0eSB3aXRoIGhvdyBjb29raWVzIGhhcyB3b3JrZWQgaW4gUFBSIHdpdGhvdXQgZHluYW1pY0lPLlxuICAgICAgICAgIHBvc3Rwb25lV2l0aFRyYWNraW5nKFxuICAgICAgICAgICAgd29ya1N0b3JlLnJvdXRlLFxuICAgICAgICAgICAgY2FsbGluZ0V4cHJlc3Npb24sXG4gICAgICAgICAgICB3b3JrVW5pdFN0b3JlLmR5bmFtaWNUcmFja2luZ1xuICAgICAgICAgIClcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdwcmVyZW5kZXItbGVnYWN5JzpcbiAgICAgICAgICAvLyBMZWdhY3kgUHJlcmVuZGVyXG4gICAgICAgICAgLy8gV2UgdHJhY2sgZHluYW1pYyBhY2Nlc3MgaGVyZSBzbyB3ZSBkb24ndCBuZWVkIHRvIHdyYXAgdGhlIGNvb2tpZXMgaW5cbiAgICAgICAgICAvLyBpbmRpdmlkdWFsIHByb3BlcnR5IGFjY2VzcyB0cmFja2luZy5cbiAgICAgICAgICB0aHJvd1RvSW50ZXJydXB0U3RhdGljR2VuZXJhdGlvbihcbiAgICAgICAgICAgIGNhbGxpbmdFeHByZXNzaW9uLFxuICAgICAgICAgICAgd29ya1N0b3JlLFxuICAgICAgICAgICAgd29ya1VuaXRTdG9yZVxuICAgICAgICAgIClcbiAgICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBmYWxsdGhyb3VnaFxuICAgICAgfVxuICAgIH1cbiAgICAvLyBXZSBmYWxsIHRocm91Z2ggdG8gdGhlIGR5bmFtaWMgY29udGV4dCBiZWxvdyBidXQgd2Ugc3RpbGwgdHJhY2sgZHluYW1pYyBhY2Nlc3NcbiAgICAvLyBiZWNhdXNlIGluIGRldiB3ZSBjYW4gc3RpbGwgZXJyb3IgZm9yIHRoaW5ncyBsaWtlIHVzaW5nIGNvb2tpZXMgaW5zaWRlIGEgY2FjaGUgY29udGV4dFxuICAgIHRyYWNrRHluYW1pY0RhdGFJbkR5bmFtaWNSZW5kZXIod29ya1N0b3JlLCB3b3JrVW5pdFN0b3JlKVxuICB9XG5cbiAgLy8gY29va2llcyBpcyBiZWluZyBjYWxsZWQgaW4gYSBkeW5hbWljIGNvbnRleHRcblxuICBjb25zdCByZXF1ZXN0U3RvcmUgPSBnZXRFeHBlY3RlZFJlcXVlc3RTdG9yZShjYWxsaW5nRXhwcmVzc2lvbilcblxuICBsZXQgdW5kZXJseWluZ0Nvb2tpZXM6IFJlYWRvbmx5UmVxdWVzdENvb2tpZXNcblxuICBpZiAoYXJlQ29va2llc011dGFibGVJbkN1cnJlbnRQaGFzZShyZXF1ZXN0U3RvcmUpKSB7XG4gICAgLy8gV2UgY2FuJ3QgY29uZGl0aW9uYWxseSByZXR1cm4gZGlmZmVyZW50IHR5cGVzIGhlcmUgYmFzZWQgb24gdGhlIGNvbnRleHQuXG4gICAgLy8gVG8gYXZvaWQgY29uZnVzaW9uLCB3ZSBhbHdheXMgcmV0dXJuIHRoZSByZWFkb25seSB0eXBlIGhlcmUuXG4gICAgdW5kZXJseWluZ0Nvb2tpZXMgPVxuICAgICAgcmVxdWVzdFN0b3JlLnVzZXJzcGFjZU11dGFibGVDb29raWVzIGFzIHVua25vd24gYXMgUmVhZG9ubHlSZXF1ZXN0Q29va2llc1xuICB9IGVsc2Uge1xuICAgIHVuZGVybHlpbmdDb29raWVzID0gcmVxdWVzdFN0b3JlLmNvb2tpZXNcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAhd29ya1N0b3JlPy5pc1ByZWZldGNoUmVxdWVzdCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfRFlOQU1JQ19JTykge1xuICAgICAgcmV0dXJuIG1ha2VVbnRyYWNrZWRDb29raWVzV2l0aERldldhcm5pbmdzKFxuICAgICAgICB1bmRlcmx5aW5nQ29va2llcyxcbiAgICAgICAgd29ya1N0b3JlPy5yb3V0ZVxuICAgICAgKVxuICAgIH1cblxuICAgIHJldHVybiBtYWtlVW50cmFja2VkRXhvdGljQ29va2llc1dpdGhEZXZXYXJuaW5ncyhcbiAgICAgIHVuZGVybHlpbmdDb29raWVzLFxuICAgICAgd29ya1N0b3JlPy5yb3V0ZVxuICAgIClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbWFrZVVudHJhY2tlZEV4b3RpY0Nvb2tpZXModW5kZXJseWluZ0Nvb2tpZXMpXG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRW1wdHlDb29raWVzKCk6IFJlYWRvbmx5UmVxdWVzdENvb2tpZXMge1xuICByZXR1cm4gUmVxdWVzdENvb2tpZXNBZGFwdGVyLnNlYWwobmV3IFJlcXVlc3RDb29raWVzKG5ldyBIZWFkZXJzKHt9KSkpXG59XG5cbmludGVyZmFjZSBDYWNoZUxpZmV0aW1lIHt9XG5jb25zdCBDYWNoZWRDb29raWVzID0gbmV3IFdlYWtNYXA8XG4gIENhY2hlTGlmZXRpbWUsXG4gIFByb21pc2U8UmVhZG9ubHlSZXF1ZXN0Q29va2llcz5cbj4oKVxuXG5mdW5jdGlvbiBtYWtlSGFuZ2luZ0Nvb2tpZXMoXG4gIHByZXJlbmRlclN0b3JlOiBQcmVyZW5kZXJTdG9yZU1vZGVyblxuKTogUHJvbWlzZTxSZWFkb25seVJlcXVlc3RDb29raWVzPiB7XG4gIGNvbnN0IGNhY2hlZFByb21pc2UgPSBDYWNoZWRDb29raWVzLmdldChwcmVyZW5kZXJTdG9yZSlcbiAgaWYgKGNhY2hlZFByb21pc2UpIHtcbiAgICByZXR1cm4gY2FjaGVkUHJvbWlzZVxuICB9XG5cbiAgY29uc3QgcHJvbWlzZSA9IG1ha2VIYW5naW5nUHJvbWlzZTxSZWFkb25seVJlcXVlc3RDb29raWVzPihcbiAgICBwcmVyZW5kZXJTdG9yZS5yZW5kZXJTaWduYWwsXG4gICAgJ2Bjb29raWVzKClgJ1xuICApXG4gIENhY2hlZENvb2tpZXMuc2V0KHByZXJlbmRlclN0b3JlLCBwcm9taXNlKVxuXG4gIHJldHVybiBwcm9taXNlXG59XG5cbmZ1bmN0aW9uIG1ha2VVbnRyYWNrZWRFeG90aWNDb29raWVzKFxuICB1bmRlcmx5aW5nQ29va2llczogUmVhZG9ubHlSZXF1ZXN0Q29va2llc1xuKTogUHJvbWlzZTxSZWFkb25seVJlcXVlc3RDb29raWVzPiB7XG4gIGNvbnN0IGNhY2hlZENvb2tpZXMgPSBDYWNoZWRDb29raWVzLmdldCh1bmRlcmx5aW5nQ29va2llcylcbiAgaWYgKGNhY2hlZENvb2tpZXMpIHtcbiAgICByZXR1cm4gY2FjaGVkQ29va2llc1xuICB9XG5cbiAgY29uc3QgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSh1bmRlcmx5aW5nQ29va2llcylcbiAgQ2FjaGVkQ29va2llcy5zZXQodW5kZXJseWluZ0Nvb2tpZXMsIHByb21pc2UpXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMocHJvbWlzZSwge1xuICAgIFtTeW1ib2wuaXRlcmF0b3JdOiB7XG4gICAgICB2YWx1ZTogdW5kZXJseWluZ0Nvb2tpZXNbU3ltYm9sLml0ZXJhdG9yXVxuICAgICAgICA/IHVuZGVybHlpbmdDb29raWVzW1N5bWJvbC5pdGVyYXRvcl0uYmluZCh1bmRlcmx5aW5nQ29va2llcylcbiAgICAgICAgOiAvLyBUT0RPIHRoaXMgaXMgYSBwb2x5ZmlsbCBmb3Igd2hlbiB0aGUgdW5kZXJseWluZyB0eXBlIGlzIFJlc3BvbnNlQ29va2llc1xuICAgICAgICAgIC8vIFdlIHNob3VsZCByZW1vdmUgdGhpcyBhbmQgdW5pZnkgb3VyIGNvb2tpZXMgdHlwZXMuIFdlIGNvdWxkIGp1c3QgbGV0IHRoaXMgY29udGludWUgdG8gdGhyb3cgbGF6aWx5XG4gICAgICAgICAgLy8gYnV0IHRoYXQncyBhbHJlYWR5IGEgaGFyZCB0aGluZyB0byBkZWJ1ZyBzbyB3ZSBtYXkgYXMgd2VsbCBpbXBsZW1lbnQgaXQgY29uc2lzdGVudGx5LiBUaGUgYmlnZ2VzdCBwcm9ibGVtIHdpdGhcbiAgICAgICAgICAvLyBpbXBsZW1lbnRpbmcgdGhpcyBpbiB0aGlzIHdheSBpcyB0aGUgdW5kZXJseWluZyBjb29raWUgdHlwZSBpcyBhIFJlc3BvbnNlQ29va2llIGFuZCBub3QgYSBSZXF1ZXN0Q29va2llIGFuZCBzbyBpdFxuICAgICAgICAgIC8vIGhhcyBleHRyYSBwcm9wZXJ0aWVzIG5vdCBhdmFpbGFibGUgb24gUmVxdWVzdENvb2tpZSBpbnN0YW5jZXMuXG4gICAgICAgICAgcG9seWZpbGxlZFJlc3BvbnNlQ29va2llc0l0ZXJhdG9yLmJpbmQodW5kZXJseWluZ0Nvb2tpZXMpLFxuICAgIH0sXG4gICAgc2l6ZToge1xuICAgICAgZ2V0KCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB1bmRlcmx5aW5nQ29va2llcy5zaXplXG4gICAgICB9LFxuICAgIH0sXG4gICAgZ2V0OiB7XG4gICAgICB2YWx1ZTogdW5kZXJseWluZ0Nvb2tpZXMuZ2V0LmJpbmQodW5kZXJseWluZ0Nvb2tpZXMpLFxuICAgIH0sXG4gICAgZ2V0QWxsOiB7XG4gICAgICB2YWx1ZTogdW5kZXJseWluZ0Nvb2tpZXMuZ2V0QWxsLmJpbmQodW5kZXJseWluZ0Nvb2tpZXMpLFxuICAgIH0sXG4gICAgaGFzOiB7XG4gICAgICB2YWx1ZTogdW5kZXJseWluZ0Nvb2tpZXMuaGFzLmJpbmQodW5kZXJseWluZ0Nvb2tpZXMpLFxuICAgIH0sXG4gICAgc2V0OiB7XG4gICAgICB2YWx1ZTogdW5kZXJseWluZ0Nvb2tpZXMuc2V0LmJpbmQodW5kZXJseWluZ0Nvb2tpZXMpLFxuICAgIH0sXG4gICAgZGVsZXRlOiB7XG4gICAgICB2YWx1ZTogdW5kZXJseWluZ0Nvb2tpZXMuZGVsZXRlLmJpbmQodW5kZXJseWluZ0Nvb2tpZXMpLFxuICAgIH0sXG4gICAgY2xlYXI6IHtcbiAgICAgIHZhbHVlOlxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGNsZWFyIGlzIGRlZmluZWQgaW4gUmVxdWVzdENvb2tpZXMgaW1wbGVtZW50YXRpb24gYnV0IG5vdCBpbiB0aGUgdHlwZVxuICAgICAgICB0eXBlb2YgdW5kZXJseWluZ0Nvb2tpZXMuY2xlYXIgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICA/IC8vIEB0cy1leHBlY3QtZXJyb3IgY2xlYXIgaXMgZGVmaW5lZCBpbiBSZXF1ZXN0Q29va2llcyBpbXBsZW1lbnRhdGlvbiBidXQgbm90IGluIHRoZSB0eXBlXG4gICAgICAgICAgICB1bmRlcmx5aW5nQ29va2llcy5jbGVhci5iaW5kKHVuZGVybHlpbmdDb29raWVzKVxuICAgICAgICAgIDogLy8gVE9ETyB0aGlzIGlzIGEgcG9seWZpbGwgZm9yIHdoZW4gdGhlIHVuZGVybHlpbmcgdHlwZSBpcyBSZXNwb25zZUNvb2tpZXNcbiAgICAgICAgICAgIC8vIFdlIHNob3VsZCByZW1vdmUgdGhpcyBhbmQgdW5pZnkgb3VyIGNvb2tpZXMgdHlwZXMuIFdlIGNvdWxkIGp1c3QgbGV0IHRoaXMgY29udGludWUgdG8gdGhyb3cgbGF6aWx5XG4gICAgICAgICAgICAvLyBidXQgdGhhdCdzIGFscmVhZHkgYSBoYXJkIHRoaW5nIHRvIGRlYnVnIHNvIHdlIG1heSBhcyB3ZWxsIGltcGxlbWVudCBpdCBjb25zaXN0ZW50bHkuIFRoZSBiaWdnZXN0IHByb2JsZW0gd2l0aFxuICAgICAgICAgICAgLy8gaW1wbGVtZW50aW5nIHRoaXMgaW4gdGhpcyB3YXkgaXMgdGhlIHVuZGVybHlpbmcgY29va2llIHR5cGUgaXMgYSBSZXNwb25zZUNvb2tpZSBhbmQgbm90IGEgUmVxdWVzdENvb2tpZSBhbmQgc28gaXRcbiAgICAgICAgICAgIC8vIGhhcyBleHRyYSBwcm9wZXJ0aWVzIG5vdCBhdmFpbGFibGUgb24gUmVxdWVzdENvb2tpZSBpbnN0YW5jZXMuXG4gICAgICAgICAgICBwb2x5ZmlsbGVkUmVzcG9uc2VDb29raWVzQ2xlYXIuYmluZCh1bmRlcmx5aW5nQ29va2llcywgcHJvbWlzZSksXG4gICAgfSxcbiAgICB0b1N0cmluZzoge1xuICAgICAgdmFsdWU6IHVuZGVybHlpbmdDb29raWVzLnRvU3RyaW5nLmJpbmQodW5kZXJseWluZ0Nvb2tpZXMpLFxuICAgIH0sXG4gIH0gc2F0aXNmaWVzIENvb2tpZUV4dGVuc2lvbnMpXG5cbiAgcmV0dXJuIHByb21pc2Vcbn1cblxuZnVuY3Rpb24gbWFrZVVudHJhY2tlZEV4b3RpY0Nvb2tpZXNXaXRoRGV2V2FybmluZ3MoXG4gIHVuZGVybHlpbmdDb29raWVzOiBSZWFkb25seVJlcXVlc3RDb29raWVzLFxuICByb3V0ZT86IHN0cmluZ1xuKTogUHJvbWlzZTxSZWFkb25seVJlcXVlc3RDb29raWVzPiB7XG4gIGNvbnN0IGNhY2hlZENvb2tpZXMgPSBDYWNoZWRDb29raWVzLmdldCh1bmRlcmx5aW5nQ29va2llcylcbiAgaWYgKGNhY2hlZENvb2tpZXMpIHtcbiAgICByZXR1cm4gY2FjaGVkQ29va2llc1xuICB9XG5cbiAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlPFJlYWRvbmx5UmVxdWVzdENvb2tpZXM+KChyZXNvbHZlKSA9PlxuICAgIHNjaGVkdWxlSW1tZWRpYXRlKCgpID0+IHJlc29sdmUodW5kZXJseWluZ0Nvb2tpZXMpKVxuICApXG4gIENhY2hlZENvb2tpZXMuc2V0KHVuZGVybHlpbmdDb29raWVzLCBwcm9taXNlKVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHByb21pc2UsIHtcbiAgICBbU3ltYm9sLml0ZXJhdG9yXToge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9ICdgLi4uY29va2llcygpYCBvciBzaW1pbGFyIGl0ZXJhdGlvbidcbiAgICAgICAgc3luY0lPRGV2KHJvdXRlLCBleHByZXNzaW9uKVxuICAgICAgICByZXR1cm4gdW5kZXJseWluZ0Nvb2tpZXNbU3ltYm9sLml0ZXJhdG9yXVxuICAgICAgICAgID8gdW5kZXJseWluZ0Nvb2tpZXNbU3ltYm9sLml0ZXJhdG9yXS5hcHBseShcbiAgICAgICAgICAgICAgdW5kZXJseWluZ0Nvb2tpZXMsXG4gICAgICAgICAgICAgIGFyZ3VtZW50cyBhcyBhbnlcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IC8vIFRPRE8gdGhpcyBpcyBhIHBvbHlmaWxsIGZvciB3aGVuIHRoZSB1bmRlcmx5aW5nIHR5cGUgaXMgUmVzcG9uc2VDb29raWVzXG4gICAgICAgICAgICAvLyBXZSBzaG91bGQgcmVtb3ZlIHRoaXMgYW5kIHVuaWZ5IG91ciBjb29raWVzIHR5cGVzLiBXZSBjb3VsZCBqdXN0IGxldCB0aGlzIGNvbnRpbnVlIHRvIHRocm93IGxhemlseVxuICAgICAgICAgICAgLy8gYnV0IHRoYXQncyBhbHJlYWR5IGEgaGFyZCB0aGluZyB0byBkZWJ1ZyBzbyB3ZSBtYXkgYXMgd2VsbCBpbXBsZW1lbnQgaXQgY29uc2lzdGVudGx5LiBUaGUgYmlnZ2VzdCBwcm9ibGVtIHdpdGhcbiAgICAgICAgICAgIC8vIGltcGxlbWVudGluZyB0aGlzIGluIHRoaXMgd2F5IGlzIHRoZSB1bmRlcmx5aW5nIGNvb2tpZSB0eXBlIGlzIGEgUmVzcG9uc2VDb29raWUgYW5kIG5vdCBhIFJlcXVlc3RDb29raWUgYW5kIHNvIGl0XG4gICAgICAgICAgICAvLyBoYXMgZXh0cmEgcHJvcGVydGllcyBub3QgYXZhaWxhYmxlIG9uIFJlcXVlc3RDb29raWUgaW5zdGFuY2VzLlxuICAgICAgICAgICAgcG9seWZpbGxlZFJlc3BvbnNlQ29va2llc0l0ZXJhdG9yLmNhbGwodW5kZXJseWluZ0Nvb2tpZXMpXG4gICAgICB9LFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgIH0sXG4gICAgc2l6ZToge1xuICAgICAgZ2V0KCk6IG51bWJlciB7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSAnYGNvb2tpZXMoKS5zaXplYCdcbiAgICAgICAgc3luY0lPRGV2KHJvdXRlLCBleHByZXNzaW9uKVxuICAgICAgICByZXR1cm4gdW5kZXJseWluZ0Nvb2tpZXMuc2l6ZVxuICAgICAgfSxcbiAgICB9LFxuICAgIGdldDoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgbGV0IGV4cHJlc3Npb246IHN0cmluZ1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGV4cHJlc3Npb24gPSAnYGNvb2tpZXMoKS5nZXQoKWAnXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXhwcmVzc2lvbiA9IGBcXGBjb29raWVzKCkuZ2V0KCR7ZGVzY3JpYmVOYW1lQXJnKGFyZ3VtZW50c1swXSl9KVxcYGBcbiAgICAgICAgfVxuICAgICAgICBzeW5jSU9EZXYocm91dGUsIGV4cHJlc3Npb24pXG4gICAgICAgIHJldHVybiB1bmRlcmx5aW5nQ29va2llcy5nZXQuYXBwbHkodW5kZXJseWluZ0Nvb2tpZXMsIGFyZ3VtZW50cyBhcyBhbnkpXG4gICAgICB9LFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgIH0sXG4gICAgZ2V0QWxsOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QWxsKCkge1xuICAgICAgICBsZXQgZXhwcmVzc2lvbjogc3RyaW5nXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgZXhwcmVzc2lvbiA9ICdgY29va2llcygpLmdldEFsbCgpYCdcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleHByZXNzaW9uID0gYFxcYGNvb2tpZXMoKS5nZXRBbGwoJHtkZXNjcmliZU5hbWVBcmcoYXJndW1lbnRzWzBdKX0pXFxgYFxuICAgICAgICB9XG4gICAgICAgIHN5bmNJT0Rldihyb3V0ZSwgZXhwcmVzc2lvbilcbiAgICAgICAgcmV0dXJuIHVuZGVybHlpbmdDb29raWVzLmdldEFsbC5hcHBseShcbiAgICAgICAgICB1bmRlcmx5aW5nQ29va2llcyxcbiAgICAgICAgICBhcmd1bWVudHMgYXMgYW55XG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgfSxcbiAgICBoYXM6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIGxldCBleHByZXNzaW9uOiBzdHJpbmdcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBleHByZXNzaW9uID0gJ2Bjb29raWVzKCkuaGFzKClgJ1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4cHJlc3Npb24gPSBgXFxgY29va2llcygpLmhhcygke2Rlc2NyaWJlTmFtZUFyZyhhcmd1bWVudHNbMF0pfSlcXGBgXG4gICAgICAgIH1cbiAgICAgICAgc3luY0lPRGV2KHJvdXRlLCBleHByZXNzaW9uKVxuICAgICAgICByZXR1cm4gdW5kZXJseWluZ0Nvb2tpZXMuaGFzLmFwcGx5KHVuZGVybHlpbmdDb29raWVzLCBhcmd1bWVudHMgYXMgYW55KVxuICAgICAgfSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICB9LFxuICAgIHNldDoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldCgpIHtcbiAgICAgICAgbGV0IGV4cHJlc3Npb246IHN0cmluZ1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGV4cHJlc3Npb24gPSAnYGNvb2tpZXMoKS5zZXQoKWAnXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgYXJnID0gYXJndW1lbnRzWzBdXG4gICAgICAgICAgaWYgKGFyZykge1xuICAgICAgICAgICAgZXhwcmVzc2lvbiA9IGBcXGBjb29raWVzKCkuc2V0KCR7ZGVzY3JpYmVOYW1lQXJnKGFyZyl9LCAuLi4pXFxgYFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBleHByZXNzaW9uID0gJ2Bjb29raWVzKCkuc2V0KC4uLilgJ1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzeW5jSU9EZXYocm91dGUsIGV4cHJlc3Npb24pXG4gICAgICAgIHJldHVybiB1bmRlcmx5aW5nQ29va2llcy5zZXQuYXBwbHkodW5kZXJseWluZ0Nvb2tpZXMsIGFyZ3VtZW50cyBhcyBhbnkpXG4gICAgICB9LFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgIH0sXG4gICAgZGVsZXRlOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBsZXQgZXhwcmVzc2lvbjogc3RyaW5nXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgZXhwcmVzc2lvbiA9ICdgY29va2llcygpLmRlbGV0ZSgpYCdcbiAgICAgICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgZXhwcmVzc2lvbiA9IGBcXGBjb29raWVzKCkuZGVsZXRlKCR7ZGVzY3JpYmVOYW1lQXJnKGFyZ3VtZW50c1swXSl9KVxcYGBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleHByZXNzaW9uID0gYFxcYGNvb2tpZXMoKS5kZWxldGUoJHtkZXNjcmliZU5hbWVBcmcoYXJndW1lbnRzWzBdKX0sIC4uLilcXGBgXG4gICAgICAgIH1cbiAgICAgICAgc3luY0lPRGV2KHJvdXRlLCBleHByZXNzaW9uKVxuICAgICAgICByZXR1cm4gdW5kZXJseWluZ0Nvb2tpZXMuZGVsZXRlLmFwcGx5KFxuICAgICAgICAgIHVuZGVybHlpbmdDb29raWVzLFxuICAgICAgICAgIGFyZ3VtZW50cyBhcyBhbnlcbiAgICAgICAgKVxuICAgICAgfSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICB9LFxuICAgIGNsZWFyOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSAnYGNvb2tpZXMoKS5jbGVhcigpYCdcbiAgICAgICAgc3luY0lPRGV2KHJvdXRlLCBleHByZXNzaW9uKVxuICAgICAgICAvLyBAdHMtaWdub3JlIGNsZWFyIGlzIGRlZmluZWQgaW4gUmVxdWVzdENvb2tpZXMgaW1wbGVtZW50YXRpb24gYnV0IG5vdCBpbiB0aGUgdHlwZVxuICAgICAgICByZXR1cm4gdHlwZW9mIHVuZGVybHlpbmdDb29raWVzLmNsZWFyID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgPyAvLyBAdHMtaWdub3JlIGNsZWFyIGlzIGRlZmluZWQgaW4gUmVxdWVzdENvb2tpZXMgaW1wbGVtZW50YXRpb24gYnV0IG5vdCBpbiB0aGUgdHlwZVxuICAgICAgICAgICAgdW5kZXJseWluZ0Nvb2tpZXMuY2xlYXIuYXBwbHkodW5kZXJseWluZ0Nvb2tpZXMsIGFyZ3VtZW50cylcbiAgICAgICAgICA6IC8vIFRPRE8gdGhpcyBpcyBhIHBvbHlmaWxsIGZvciB3aGVuIHRoZSB1bmRlcmx5aW5nIHR5cGUgaXMgUmVzcG9uc2VDb29raWVzXG4gICAgICAgICAgICAvLyBXZSBzaG91bGQgcmVtb3ZlIHRoaXMgYW5kIHVuaWZ5IG91ciBjb29raWVzIHR5cGVzLiBXZSBjb3VsZCBqdXN0IGxldCB0aGlzIGNvbnRpbnVlIHRvIHRocm93IGxhemlseVxuICAgICAgICAgICAgLy8gYnV0IHRoYXQncyBhbHJlYWR5IGEgaGFyZCB0aGluZyB0byBkZWJ1ZyBzbyB3ZSBtYXkgYXMgd2VsbCBpbXBsZW1lbnQgaXQgY29uc2lzdGVudGx5LiBUaGUgYmlnZ2VzdCBwcm9ibGVtIHdpdGhcbiAgICAgICAgICAgIC8vIGltcGxlbWVudGluZyB0aGlzIGluIHRoaXMgd2F5IGlzIHRoZSB1bmRlcmx5aW5nIGNvb2tpZSB0eXBlIGlzIGEgUmVzcG9uc2VDb29raWUgYW5kIG5vdCBhIFJlcXVlc3RDb29raWUgYW5kIHNvIGl0XG4gICAgICAgICAgICAvLyBoYXMgZXh0cmEgcHJvcGVydGllcyBub3QgYXZhaWxhYmxlIG9uIFJlcXVlc3RDb29raWUgaW5zdGFuY2VzLlxuICAgICAgICAgICAgcG9seWZpbGxlZFJlc3BvbnNlQ29va2llc0NsZWFyLmNhbGwodW5kZXJseWluZ0Nvb2tpZXMsIHByb21pc2UpXG4gICAgICB9LFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgIH0sXG4gICAgdG9TdHJpbmc6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9ICdgY29va2llcygpLnRvU3RyaW5nKClgIG9yIGltcGxpY2l0IGNhc3RpbmcnXG4gICAgICAgIHN5bmNJT0Rldihyb3V0ZSwgZXhwcmVzc2lvbilcbiAgICAgICAgcmV0dXJuIHVuZGVybHlpbmdDb29raWVzLnRvU3RyaW5nLmFwcGx5KFxuICAgICAgICAgIHVuZGVybHlpbmdDb29raWVzLFxuICAgICAgICAgIGFyZ3VtZW50cyBhcyBhbnlcbiAgICAgICAgKVxuICAgICAgfSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICB9LFxuICB9IHNhdGlzZmllcyBDb29raWVFeHRlbnNpb25zKVxuXG4gIHJldHVybiBwcm9taXNlXG59XG5cbi8vIFNpbWlsYXIgdG8gYG1ha2VVbnRyYWNrZWRFeG90aWNDb29raWVzV2l0aERldldhcm5pbmdzYCwgYnV0IGp1c3QgbG9nZ2luZyB0aGVcbi8vIHN5bmMgYWNjZXNzIHdpdGhvdXQgYWN0dWFsbHkgZGVmaW5pbmcgdGhlIGNvb2tpZXMgcHJvcGVydGllcyBvbiB0aGUgcHJvbWlzZS5cbmZ1bmN0aW9uIG1ha2VVbnRyYWNrZWRDb29raWVzV2l0aERldldhcm5pbmdzKFxuICB1bmRlcmx5aW5nQ29va2llczogUmVhZG9ubHlSZXF1ZXN0Q29va2llcyxcbiAgcm91dGU/OiBzdHJpbmdcbik6IFByb21pc2U8UmVhZG9ubHlSZXF1ZXN0Q29va2llcz4ge1xuICBjb25zdCBjYWNoZWRDb29raWVzID0gQ2FjaGVkQ29va2llcy5nZXQodW5kZXJseWluZ0Nvb2tpZXMpXG4gIGlmIChjYWNoZWRDb29raWVzKSB7XG4gICAgcmV0dXJuIGNhY2hlZENvb2tpZXNcbiAgfVxuXG4gIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZTxSZWFkb25seVJlcXVlc3RDb29raWVzPigocmVzb2x2ZSkgPT5cbiAgICBzY2hlZHVsZUltbWVkaWF0ZSgoKSA9PiByZXNvbHZlKHVuZGVybHlpbmdDb29raWVzKSlcbiAgKVxuXG4gIGNvbnN0IHByb3hpZWRQcm9taXNlID0gbmV3IFByb3h5KHByb21pc2UsIHtcbiAgICBnZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgc3dpdGNoIChwcm9wKSB7XG4gICAgICAgIGNhc2UgU3ltYm9sLml0ZXJhdG9yOiB7XG4gICAgICAgICAgd2FybkZvclN5bmNBY2Nlc3Mocm91dGUsICdgLi4uY29va2llcygpYCBvciBzaW1pbGFyIGl0ZXJhdGlvbicpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdzaXplJzpcbiAgICAgICAgY2FzZSAnZ2V0JzpcbiAgICAgICAgY2FzZSAnZ2V0QWxsJzpcbiAgICAgICAgY2FzZSAnaGFzJzpcbiAgICAgICAgY2FzZSAnc2V0JzpcbiAgICAgICAgY2FzZSAnZGVsZXRlJzpcbiAgICAgICAgY2FzZSAnY2xlYXInOlxuICAgICAgICBjYXNlICd0b1N0cmluZyc6IHtcbiAgICAgICAgICB3YXJuRm9yU3luY0FjY2Vzcyhyb3V0ZSwgYFxcYGNvb2tpZXMoKS4ke3Byb3B9XFxgYClcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAvLyBXZSBvbmx5IHdhcm4gZm9yIHdlbGwtZGVmaW5lZCBwcm9wZXJ0aWVzIG9mIHRoZSBjb29raWVzIG9iamVjdC5cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gUmVmbGVjdEFkYXB0ZXIuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpXG4gICAgfSxcbiAgfSlcblxuICBDYWNoZWRDb29raWVzLnNldCh1bmRlcmx5aW5nQ29va2llcywgcHJveGllZFByb21pc2UpXG5cbiAgcmV0dXJuIHByb3hpZWRQcm9taXNlXG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmFtZUFyZyhhcmc6IHVua25vd24pIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmXG4gICAgYXJnICE9PSBudWxsICYmXG4gICAgdHlwZW9mIChhcmcgYXMgYW55KS5uYW1lID09PSAnc3RyaW5nJ1xuICAgID8gYCckeyhhcmcgYXMgYW55KS5uYW1lfSdgXG4gICAgOiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJ1xuICAgICAgPyBgJyR7YXJnfSdgXG4gICAgICA6ICcuLi4nXG59XG5cbmZ1bmN0aW9uIHN5bmNJT0Rldihyb3V0ZTogc3RyaW5nIHwgdW5kZWZpbmVkLCBleHByZXNzaW9uOiBzdHJpbmcpIHtcbiAgY29uc3Qgd29ya1VuaXRTdG9yZSA9IHdvcmtVbml0QXN5bmNTdG9yYWdlLmdldFN0b3JlKClcbiAgaWYgKFxuICAgIHdvcmtVbml0U3RvcmUgJiZcbiAgICB3b3JrVW5pdFN0b3JlLnR5cGUgPT09ICdyZXF1ZXN0JyAmJlxuICAgIHdvcmtVbml0U3RvcmUucHJlcmVuZGVyUGhhc2UgPT09IHRydWVcbiAgKSB7XG4gICAgLy8gV2hlbiB3ZSdyZSByZW5kZXJpbmcgZHluYW1pY2FsbHkgaW4gZGV2IHdlIG5lZWQgdG8gYWR2YW5jZSBvdXQgb2YgdGhlXG4gICAgLy8gUHJlcmVuZGVyIGVudmlyb25tZW50IHdoZW4gd2UgcmVhZCBSZXF1ZXN0IGRhdGEgc3luY2hyb25vdXNseVxuICAgIGNvbnN0IHJlcXVlc3RTdG9yZSA9IHdvcmtVbml0U3RvcmVcbiAgICB0cmFja1N5bmNocm9ub3VzUmVxdWVzdERhdGFBY2Nlc3NJbkRldihyZXF1ZXN0U3RvcmUpXG4gIH1cbiAgLy8gSW4gYWxsIGNhc2VzIHdlIHdhcm4gbm9ybWFsbHlcbiAgd2FybkZvclN5bmNBY2Nlc3Mocm91dGUsIGV4cHJlc3Npb24pXG59XG5cbmNvbnN0IHdhcm5Gb3JTeW5jQWNjZXNzID0gY3JlYXRlRGVkdXBlZEJ5Q2FsbHNpdGVTZXJ2ZXJFcnJvckxvZ2dlckRldihcbiAgY3JlYXRlQ29va2llc0FjY2Vzc0Vycm9yXG4pXG5cbmZ1bmN0aW9uIGNyZWF0ZUNvb2tpZXNBY2Nlc3NFcnJvcihcbiAgcm91dGU6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgZXhwcmVzc2lvbjogc3RyaW5nXG4pIHtcbiAgY29uc3QgcHJlZml4ID0gcm91dGUgPyBgUm91dGUgXCIke3JvdXRlfVwiIGAgOiAnVGhpcyByb3V0ZSAnXG4gIHJldHVybiBuZXcgRXJyb3IoXG4gICAgYCR7cHJlZml4fXVzZWQgJHtleHByZXNzaW9ufS4gYCArXG4gICAgICBgXFxgY29va2llcygpXFxgIHNob3VsZCBiZSBhd2FpdGVkIGJlZm9yZSB1c2luZyBpdHMgdmFsdWUuIGAgK1xuICAgICAgYExlYXJuIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL3N5bmMtZHluYW1pYy1hcGlzYFxuICApXG59XG5cbmZ1bmN0aW9uIHBvbHlmaWxsZWRSZXNwb25zZUNvb2tpZXNJdGVyYXRvcihcbiAgdGhpczogUmVzcG9uc2VDb29raWVzXG4pOiBSZXR1cm5UeXBlPFJlYWRvbmx5UmVxdWVzdENvb2tpZXNbdHlwZW9mIFN5bWJvbC5pdGVyYXRvcl0+IHtcbiAgcmV0dXJuIHRoaXMuZ2V0QWxsKClcbiAgICAubWFwKChjKSA9PiBbYy5uYW1lLCBjXSBhcyBbc3RyaW5nLCBhbnldKVxuICAgIC52YWx1ZXMoKVxufVxuXG5mdW5jdGlvbiBwb2x5ZmlsbGVkUmVzcG9uc2VDb29raWVzQ2xlYXIoXG4gIHRoaXM6IFJlc3BvbnNlQ29va2llcyxcbiAgcmV0dXJuYWJsZTogUHJvbWlzZTxSZWFkb25seVJlcXVlc3RDb29raWVzPlxuKTogdHlwZW9mIHJldHVybmFibGUge1xuICBmb3IgKGNvbnN0IGNvb2tpZSBvZiB0aGlzLmdldEFsbCgpKSB7XG4gICAgdGhpcy5kZWxldGUoY29va2llLm5hbWUpXG4gIH1cbiAgcmV0dXJuIHJldHVybmFibGVcbn1cblxudHlwZSBDb29raWVFeHRlbnNpb25zID0ge1xuICBbSyBpbiBrZXlvZiBSZWFkb25seVJlcXVlc3RDb29raWVzIHwgJ2NsZWFyJ106IHVua25vd25cbn1cbiJdLCJuYW1lcyI6WyJjb29raWVzIiwiY2FsbGluZ0V4cHJlc3Npb24iLCJ3b3JrU3RvcmUiLCJ3b3JrQXN5bmNTdG9yYWdlIiwiZ2V0U3RvcmUiLCJ3b3JrVW5pdFN0b3JlIiwid29ya1VuaXRBc3luY1N0b3JhZ2UiLCJwaGFzZSIsImlzUmVxdWVzdEFQSUNhbGxhYmxlSW5zaWRlQWZ0ZXIiLCJFcnJvciIsInJvdXRlIiwiZm9yY2VTdGF0aWMiLCJ1bmRlcmx5aW5nQ29va2llcyIsImNyZWF0ZUVtcHR5Q29va2llcyIsIm1ha2VVbnRyYWNrZWRFeG90aWNDb29raWVzIiwidHlwZSIsImR5bmFtaWNTaG91bGRFcnJvciIsIlN0YXRpY0dlbkJhaWxvdXRFcnJvciIsIm1ha2VIYW5naW5nQ29va2llcyIsImV4cG9ydE5hbWUiLCJJbnZhcmlhbnRFcnJvciIsInBvc3Rwb25lV2l0aFRyYWNraW5nIiwiZHluYW1pY1RyYWNraW5nIiwidGhyb3dUb0ludGVycnVwdFN0YXRpY0dlbmVyYXRpb24iLCJ0cmFja0R5bmFtaWNEYXRhSW5EeW5hbWljUmVuZGVyIiwicmVxdWVzdFN0b3JlIiwiZ2V0RXhwZWN0ZWRSZXF1ZXN0U3RvcmUiLCJhcmVDb29raWVzTXV0YWJsZUluQ3VycmVudFBoYXNlIiwidXNlcnNwYWNlTXV0YWJsZUNvb2tpZXMiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJpc1ByZWZldGNoUmVxdWVzdCIsIl9fTkVYVF9EWU5BTUlDX0lPIiwibWFrZVVudHJhY2tlZENvb2tpZXNXaXRoRGV2V2FybmluZ3MiLCJtYWtlVW50cmFja2VkRXhvdGljQ29va2llc1dpdGhEZXZXYXJuaW5ncyIsIlJlcXVlc3RDb29raWVzQWRhcHRlciIsInNlYWwiLCJSZXF1ZXN0Q29va2llcyIsIkhlYWRlcnMiLCJDYWNoZWRDb29raWVzIiwiV2Vha01hcCIsInByZXJlbmRlclN0b3JlIiwiY2FjaGVkUHJvbWlzZSIsImdldCIsInByb21pc2UiLCJtYWtlSGFuZ2luZ1Byb21pc2UiLCJyZW5kZXJTaWduYWwiLCJzZXQiLCJjYWNoZWRDb29raWVzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJ2YWx1ZSIsImJpbmQiLCJwb2x5ZmlsbGVkUmVzcG9uc2VDb29raWVzSXRlcmF0b3IiLCJzaXplIiwiZ2V0QWxsIiwiaGFzIiwiZGVsZXRlIiwiY2xlYXIiLCJwb2x5ZmlsbGVkUmVzcG9uc2VDb29raWVzQ2xlYXIiLCJ0b1N0cmluZyIsInNjaGVkdWxlSW1tZWRpYXRlIiwiZXhwcmVzc2lvbiIsInN5bmNJT0RldiIsImFwcGx5IiwiYXJndW1lbnRzIiwiY2FsbCIsIndyaXRhYmxlIiwibGVuZ3RoIiwiZGVzY3JpYmVOYW1lQXJnIiwiYXJnIiwicHJveGllZFByb21pc2UiLCJQcm94eSIsInRhcmdldCIsInByb3AiLCJyZWNlaXZlciIsIndhcm5Gb3JTeW5jQWNjZXNzIiwiUmVmbGVjdEFkYXB0ZXIiLCJuYW1lIiwicHJlcmVuZGVyUGhhc2UiLCJ0cmFja1N5bmNocm9ub3VzUmVxdWVzdERhdGFBY2Nlc3NJbkRldiIsImNyZWF0ZURlZHVwZWRCeUNhbGxzaXRlU2VydmVyRXJyb3JMb2dnZXJEZXYiLCJjcmVhdGVDb29raWVzQWNjZXNzRXJyb3IiLCJwcmVmaXgiLCJtYXAiLCJjIiwidmFsdWVzIiwicmV0dXJuYWJsZSIsImNvb2tpZSJdLCJtYXBwaW5ncyI6IkFBZ0pNNkIsUUFBUUMsR0FBRyxDQUFDQyxRQUFROzs7OzsrQkE5RlYvQixXQUFBQTs7O2VBQUFBOzs7Z0NBN0NUO3lC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T3lEO0FBQzNCO0FBRUEsTUFBTWMsb0JBQW9CSyxDQUFBQSxHQUFBQSwwQ0FBQUEsMkNBQTJDLEVBQ25FQztBQUdGLFNBQVNBLHlCQUNQN0UsS0FBeUIsRUFDekJ5RCxVQUFrQjtJQUVsQixNQUFNcUIsU0FBUzlFLFFBQVMsQUFBRCxPQUFRLFVBQUVBLE9BQU0sRUFBRSxDQUFDLEtBQUc7SUFDN0MsT0FBTyxPQUFBLGNBSU4sQ0FKTSxJQUFJRCxNQUNULFVBQUcrRSxRQUFPLEtBQUssV0FBRXJCLFlBQVcsRUFBRSxDQUFDLEdBQzdCLEVBQUMsd0RBQXdELENBQUMsRUFDekQsQ0FBRCw2REFBK0QsQ0FBQyxJQUg3RCxxQkFBQTtlQUFBO29CQUFBO3NCQUFBO0lBSVA7QUFDRjtBQUVBLFNBQVNUO0lBR1AsT0FBTyxJQUFJLENBQUNFLE1BQU0sR0FDZjZCLEdBQUcsQ0FBQyxDQUFDQyxJQUFNO1lBQUNBLEVBQUVQLElBQUk7WUFBRU87U0FBRSxFQUN0QkMsTUFBTTtBQUNYO0FBRUEsU0FBUzNCLCtCQUVQNEIsVUFBMkM7SUFFM0MsS0FBSyxNQUFNQyxVQUFVLElBQUksQ0FBQ2pDLE1BQU0sR0FBSTtRQUNsQyxJQUFJLENBQUNFLE1BQU0sQ0FBQytCLE9BQU9WLElBQUk7SUFDekI7SUFDQSxPQUFPUztBQUNUIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDEwNDksICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvc2VydmVyL3dlYi9zcGVjLWV4dGVuc2lvbi9hZGFwdGVycy9oZWFkZXJzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgSW5jb21pbmdIdHRwSGVhZGVycyB9IGZyb20gJ2h0dHAnXG5cbmltcG9ydCB7IFJlZmxlY3RBZGFwdGVyIH0gZnJvbSAnLi9yZWZsZWN0J1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY2xhc3MgUmVhZG9ubHlIZWFkZXJzRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFxuICAgICAgJ0hlYWRlcnMgY2Fubm90IGJlIG1vZGlmaWVkLiBSZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9hcGktcmVmZXJlbmNlL2Z1bmN0aW9ucy9oZWFkZXJzJ1xuICAgIClcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgY2FsbGFibGUoKSB7XG4gICAgdGhyb3cgbmV3IFJlYWRvbmx5SGVhZGVyc0Vycm9yKClcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBSZWFkb25seUhlYWRlcnMgPSBIZWFkZXJzICYge1xuICAvKiogQGRlcHJlY2F0ZWQgTWV0aG9kIHVuYXZhaWxhYmxlIG9uIGBSZWFkb25seUhlYWRlcnNgLiBSZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9hcGktcmVmZXJlbmNlL2Z1bmN0aW9ucy9oZWFkZXJzICovXG4gIGFwcGVuZCguLi5hcmdzOiBhbnlbXSk6IHZvaWRcbiAgLyoqIEBkZXByZWNhdGVkIE1ldGhvZCB1bmF2YWlsYWJsZSBvbiBgUmVhZG9ubHlIZWFkZXJzYC4gUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYXBpLXJlZmVyZW5jZS9mdW5jdGlvbnMvaGVhZGVycyAqL1xuICBzZXQoLi4uYXJnczogYW55W10pOiB2b2lkXG4gIC8qKiBAZGVwcmVjYXRlZCBNZXRob2QgdW5hdmFpbGFibGUgb24gYFJlYWRvbmx5SGVhZGVyc2AuIFJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2FwaS1yZWZlcmVuY2UvZnVuY3Rpb25zL2hlYWRlcnMgKi9cbiAgZGVsZXRlKC4uLmFyZ3M6IGFueVtdKTogdm9pZFxufVxuZXhwb3J0IGNsYXNzIEhlYWRlcnNBZGFwdGVyIGV4dGVuZHMgSGVhZGVycyB7XG4gIHByaXZhdGUgcmVhZG9ubHkgaGVhZGVyczogSW5jb21pbmdIdHRwSGVhZGVyc1xuXG4gIGNvbnN0cnVjdG9yKGhlYWRlcnM6IEluY29taW5nSHR0cEhlYWRlcnMpIHtcbiAgICAvLyBXZSd2ZSBhbHJlYWR5IG92ZXJyaWRkZW4gdGhlIG1ldGhvZHMgdGhhdCB3b3VsZCBiZSBjYWxsZWQsIHNvIHdlJ3JlIGp1c3RcbiAgICAvLyBjYWxsaW5nIHRoZSBzdXBlciBjb25zdHJ1Y3RvciB0byBlbnN1cmUgdGhhdCB0aGUgaW5zdGFuY2VvZiBjaGVjayB3b3Jrcy5cbiAgICBzdXBlcigpXG5cbiAgICB0aGlzLmhlYWRlcnMgPSBuZXcgUHJveHkoaGVhZGVycywge1xuICAgICAgZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICAgICAgLy8gQmVjYXVzZSB0aGlzIGlzIGp1c3QgYW4gb2JqZWN0LCB3ZSBleHBlY3QgdGhhdCBhbGwgXCJnZXRcIiBvcGVyYXRpb25zXG4gICAgICAgIC8vIGFyZSBmb3IgcHJvcGVydGllcy4gSWYgaXQncyBhIFwiZ2V0XCIgZm9yIGEgc3ltYm9sLCB3ZSdsbCBqdXN0IHJldHVyblxuICAgICAgICAvLyB0aGUgc3ltYm9sLlxuICAgICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgcmV0dXJuIFJlZmxlY3RBZGFwdGVyLmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbG93ZXJjYXNlZCA9IHByb3AudG9Mb3dlckNhc2UoKVxuXG4gICAgICAgIC8vIExldCdzIGZpbmQgdGhlIG9yaWdpbmFsIGNhc2luZyBvZiB0aGUga2V5LiBUaGlzIGFzc3VtZXMgdGhhdCB0aGVyZSBpc1xuICAgICAgICAvLyBubyBtaXhlZCBjYXNlIGtleXMgKGUuZy4gXCJDb250ZW50LVR5cGVcIiBhbmQgXCJjb250ZW50LXR5cGVcIikgaW4gdGhlXG4gICAgICAgIC8vIGhlYWRlcnMgb2JqZWN0LlxuICAgICAgICBjb25zdCBvcmlnaW5hbCA9IE9iamVjdC5rZXlzKGhlYWRlcnMpLmZpbmQoXG4gICAgICAgICAgKG8pID0+IG8udG9Mb3dlckNhc2UoKSA9PT0gbG93ZXJjYXNlZFxuICAgICAgICApXG5cbiAgICAgICAgLy8gSWYgdGhlIG9yaWdpbmFsIGNhc2luZyBkb2Vzbid0IGV4aXN0LCByZXR1cm4gdW5kZWZpbmVkLlxuICAgICAgICBpZiAodHlwZW9mIG9yaWdpbmFsID09PSAndW5kZWZpbmVkJykgcmV0dXJuXG5cbiAgICAgICAgLy8gSWYgdGhlIG9yaWdpbmFsIGNhc2luZyBleGlzdHMsIHJldHVybiB0aGUgdmFsdWUuXG4gICAgICAgIHJldHVybiBSZWZsZWN0QWRhcHRlci5nZXQodGFyZ2V0LCBvcmlnaW5hbCwgcmVjZWl2ZXIpXG4gICAgICB9LFxuICAgICAgc2V0KHRhcmdldCwgcHJvcCwgdmFsdWUsIHJlY2VpdmVyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgICByZXR1cm4gUmVmbGVjdEFkYXB0ZXIuc2V0KHRhcmdldCwgcHJvcCwgdmFsdWUsIHJlY2VpdmVyKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbG93ZXJjYXNlZCA9IHByb3AudG9Mb3dlckNhc2UoKVxuXG4gICAgICAgIC8vIExldCdzIGZpbmQgdGhlIG9yaWdpbmFsIGNhc2luZyBvZiB0aGUga2V5LiBUaGlzIGFzc3VtZXMgdGhhdCB0aGVyZSBpc1xuICAgICAgICAvLyBubyBtaXhlZCBjYXNlIGtleXMgKGUuZy4gXCJDb250ZW50LVR5cGVcIiBhbmQgXCJjb250ZW50LXR5cGVcIikgaW4gdGhlXG4gICAgICAgIC8vIGhlYWRlcnMgb2JqZWN0LlxuICAgICAgICBjb25zdCBvcmlnaW5hbCA9IE9iamVjdC5rZXlzKGhlYWRlcnMpLmZpbmQoXG4gICAgICAgICAgKG8pID0+IG8udG9Mb3dlckNhc2UoKSA9PT0gbG93ZXJjYXNlZFxuICAgICAgICApXG5cbiAgICAgICAgLy8gSWYgdGhlIG9yaWdpbmFsIGNhc2luZyBkb2Vzbid0IGV4aXN0LCB1c2UgdGhlIHByb3AgYXMgdGhlIGtleS5cbiAgICAgICAgcmV0dXJuIFJlZmxlY3RBZGFwdGVyLnNldCh0YXJnZXQsIG9yaWdpbmFsID8/IHByb3AsIHZhbHVlLCByZWNlaXZlcilcbiAgICAgIH0sXG4gICAgICBoYXModGFyZ2V0LCBwcm9wKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N5bWJvbCcpIHJldHVybiBSZWZsZWN0QWRhcHRlci5oYXModGFyZ2V0LCBwcm9wKVxuXG4gICAgICAgIGNvbnN0IGxvd2VyY2FzZWQgPSBwcm9wLnRvTG93ZXJDYXNlKClcblxuICAgICAgICAvLyBMZXQncyBmaW5kIHRoZSBvcmlnaW5hbCBjYXNpbmcgb2YgdGhlIGtleS4gVGhpcyBhc3N1bWVzIHRoYXQgdGhlcmUgaXNcbiAgICAgICAgLy8gbm8gbWl4ZWQgY2FzZSBrZXlzIChlLmcuIFwiQ29udGVudC1UeXBlXCIgYW5kIFwiY29udGVudC10eXBlXCIpIGluIHRoZVxuICAgICAgICAvLyBoZWFkZXJzIG9iamVjdC5cbiAgICAgICAgY29uc3Qgb3JpZ2luYWwgPSBPYmplY3Qua2V5cyhoZWFkZXJzKS5maW5kKFxuICAgICAgICAgIChvKSA9PiBvLnRvTG93ZXJDYXNlKCkgPT09IGxvd2VyY2FzZWRcbiAgICAgICAgKVxuXG4gICAgICAgIC8vIElmIHRoZSBvcmlnaW5hbCBjYXNpbmcgZG9lc24ndCBleGlzdCwgcmV0dXJuIGZhbHNlLlxuICAgICAgICBpZiAodHlwZW9mIG9yaWdpbmFsID09PSAndW5kZWZpbmVkJykgcmV0dXJuIGZhbHNlXG5cbiAgICAgICAgLy8gSWYgdGhlIG9yaWdpbmFsIGNhc2luZyBleGlzdHMsIHJldHVybiB0cnVlLlxuICAgICAgICByZXR1cm4gUmVmbGVjdEFkYXB0ZXIuaGFzKHRhcmdldCwgb3JpZ2luYWwpXG4gICAgICB9LFxuICAgICAgZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N5bWJvbCcpXG4gICAgICAgICAgcmV0dXJuIFJlZmxlY3RBZGFwdGVyLmRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcClcblxuICAgICAgICBjb25zdCBsb3dlcmNhc2VkID0gcHJvcC50b0xvd2VyQ2FzZSgpXG5cbiAgICAgICAgLy8gTGV0J3MgZmluZCB0aGUgb3JpZ2luYWwgY2FzaW5nIG9mIHRoZSBrZXkuIFRoaXMgYXNzdW1lcyB0aGF0IHRoZXJlIGlzXG4gICAgICAgIC8vIG5vIG1peGVkIGNhc2Uga2V5cyAoZS5nLiBcIkNvbnRlbnQtVHlwZVwiIGFuZCBcImNvbnRlbnQtdHlwZVwiKSBpbiB0aGVcbiAgICAgICAgLy8gaGVhZGVycyBvYmplY3QuXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsID0gT2JqZWN0LmtleXMoaGVhZGVycykuZmluZChcbiAgICAgICAgICAobykgPT4gby50b0xvd2VyQ2FzZSgpID09PSBsb3dlcmNhc2VkXG4gICAgICAgIClcblxuICAgICAgICAvLyBJZiB0aGUgb3JpZ2luYWwgY2FzaW5nIGRvZXNuJ3QgZXhpc3QsIHJldHVybiB0cnVlLlxuICAgICAgICBpZiAodHlwZW9mIG9yaWdpbmFsID09PSAndW5kZWZpbmVkJykgcmV0dXJuIHRydWVcblxuICAgICAgICAvLyBJZiB0aGUgb3JpZ2luYWwgY2FzaW5nIGV4aXN0cywgZGVsZXRlIHRoZSBwcm9wZXJ0eS5cbiAgICAgICAgcmV0dXJuIFJlZmxlY3RBZGFwdGVyLmRlbGV0ZVByb3BlcnR5KHRhcmdldCwgb3JpZ2luYWwpXG4gICAgICB9LFxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogU2VhbHMgYSBIZWFkZXJzIGluc3RhbmNlIHRvIHByZXZlbnQgbW9kaWZpY2F0aW9uIGJ5IHRocm93aW5nIGFuIGVycm9yIHdoZW5cbiAgICogYW55IG11dGF0aW5nIG1ldGhvZCBpcyBjYWxsZWQuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHNlYWwoaGVhZGVyczogSGVhZGVycyk6IFJlYWRvbmx5SGVhZGVycyB7XG4gICAgcmV0dXJuIG5ldyBQcm94eTxSZWFkb25seUhlYWRlcnM+KGhlYWRlcnMsIHtcbiAgICAgIGdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG4gICAgICAgIHN3aXRjaCAocHJvcCkge1xuICAgICAgICAgIGNhc2UgJ2FwcGVuZCc6XG4gICAgICAgICAgY2FzZSAnZGVsZXRlJzpcbiAgICAgICAgICBjYXNlICdzZXQnOlxuICAgICAgICAgICAgcmV0dXJuIFJlYWRvbmx5SGVhZGVyc0Vycm9yLmNhbGxhYmxlXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0QWRhcHRlci5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcilcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIE1lcmdlcyBhIGhlYWRlciB2YWx1ZSBpbnRvIGEgc3RyaW5nLiBUaGlzIHN0b3JlcyBtdWx0aXBsZSB2YWx1ZXMgYXMgYW5cbiAgICogYXJyYXksIHNvIHdlIG5lZWQgdG8gbWVyZ2UgdGhlbSBpbnRvIGEgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0gdmFsdWUgYSBoZWFkZXIgdmFsdWVcbiAgICogQHJldHVybnMgYSBtZXJnZWQgaGVhZGVyIHZhbHVlIChhIHN0cmluZylcbiAgICovXG4gIHByaXZhdGUgbWVyZ2UodmFsdWU6IHN0cmluZyB8IHN0cmluZ1tdKTogc3RyaW5nIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHJldHVybiB2YWx1ZS5qb2luKCcsICcpXG5cbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgSGVhZGVycyBpbnN0YW5jZSBmcm9tIGEgcGxhaW4gb2JqZWN0IG9yIGEgSGVhZGVycyBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIGhlYWRlcnMgYSBwbGFpbiBvYmplY3Qgb3IgYSBIZWFkZXJzIGluc3RhbmNlXG4gICAqIEByZXR1cm5zIGEgaGVhZGVycyBpbnN0YW5jZVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBmcm9tKGhlYWRlcnM6IEluY29taW5nSHR0cEhlYWRlcnMgfCBIZWFkZXJzKTogSGVhZGVycyB7XG4gICAgaWYgKGhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzKSByZXR1cm4gaGVhZGVyc1xuXG4gICAgcmV0dXJuIG5ldyBIZWFkZXJzQWRhcHRlcihoZWFkZXJzKVxuICB9XG5cbiAgcHVibGljIGFwcGVuZChuYW1lOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBjb25zdCBleGlzdGluZyA9IHRoaXMuaGVhZGVyc1tuYW1lXVxuICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLmhlYWRlcnNbbmFtZV0gPSBbZXhpc3RpbmcsIHZhbHVlXVxuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShleGlzdGluZykpIHtcbiAgICAgIGV4aXN0aW5nLnB1c2godmFsdWUpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGVhZGVyc1tuYW1lXSA9IHZhbHVlXG4gICAgfVxuICB9XG5cbiAgcHVibGljIGRlbGV0ZShuYW1lOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBkZWxldGUgdGhpcy5oZWFkZXJzW25hbWVdXG4gIH1cblxuICBwdWJsaWMgZ2V0KG5hbWU6IHN0cmluZyk6IHN0cmluZyB8IG51bGwge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5oZWFkZXJzW25hbWVdXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHJldHVybiB0aGlzLm1lcmdlKHZhbHVlKVxuXG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIHB1YmxpYyBoYXMobmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGlzLmhlYWRlcnNbbmFtZV0gIT09ICd1bmRlZmluZWQnXG4gIH1cblxuICBwdWJsaWMgc2V0KG5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMuaGVhZGVyc1tuYW1lXSA9IHZhbHVlXG4gIH1cblxuICBwdWJsaWMgZm9yRWFjaChcbiAgICBjYWxsYmFja2ZuOiAodmFsdWU6IHN0cmluZywgbmFtZTogc3RyaW5nLCBwYXJlbnQ6IEhlYWRlcnMpID0+IHZvaWQsXG4gICAgdGhpc0FyZz86IGFueVxuICApOiB2b2lkIHtcbiAgICBmb3IgKGNvbnN0IFtuYW1lLCB2YWx1ZV0gb2YgdGhpcy5lbnRyaWVzKCkpIHtcbiAgICAgIGNhbGxiYWNrZm4uY2FsbCh0aGlzQXJnLCB2YWx1ZSwgbmFtZSwgdGhpcylcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgKmVudHJpZXMoKTogSGVhZGVyc0l0ZXJhdG9yPFtzdHJpbmcsIHN0cmluZ10+IHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh0aGlzLmhlYWRlcnMpKSB7XG4gICAgICBjb25zdCBuYW1lID0ga2V5LnRvTG93ZXJDYXNlKClcbiAgICAgIC8vIFdlIGFzc2VydCBoZXJlIHRoYXQgdGhpcyBpcyBhIHN0cmluZyBiZWNhdXNlIHdlIGdvdCBpdCBmcm9tIHRoZVxuICAgICAgLy8gT2JqZWN0LmtleXMoKSBjYWxsIGFib3ZlLlxuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmdldChuYW1lKSBhcyBzdHJpbmdcblxuICAgICAgeWllbGQgW25hbWUsIHZhbHVlXSBhcyBbc3RyaW5nLCBzdHJpbmddXG4gICAgfVxuICB9XG5cbiAgcHVibGljICprZXlzKCk6IEhlYWRlcnNJdGVyYXRvcjxzdHJpbmc+IHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh0aGlzLmhlYWRlcnMpKSB7XG4gICAgICBjb25zdCBuYW1lID0ga2V5LnRvTG93ZXJDYXNlKClcbiAgICAgIHlpZWxkIG5hbWVcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgKnZhbHVlcygpOiBIZWFkZXJzSXRlcmF0b3I8c3RyaW5nPiB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModGhpcy5oZWFkZXJzKSkge1xuICAgICAgLy8gV2UgYXNzZXJ0IGhlcmUgdGhhdCB0aGlzIGlzIGEgc3RyaW5nIGJlY2F1c2Ugd2UgZ290IGl0IGZyb20gdGhlXG4gICAgICAvLyBPYmplY3Qua2V5cygpIGNhbGwgYWJvdmUuXG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0KGtleSkgYXMgc3RyaW5nXG5cbiAgICAgIHlpZWxkIHZhbHVlXG4gICAgfVxuICB9XG5cbiAgcHVibGljIFtTeW1ib2wuaXRlcmF0b3JdKCk6IEhlYWRlcnNJdGVyYXRvcjxbc3RyaW5nLCBzdHJpbmddPiB7XG4gICAgcmV0dXJuIHRoaXMuZW50cmllcygpXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJIZWFkZXJzQWRhcHRlciIsIlJlYWRvbmx5SGVhZGVyc0Vycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsImNhbGxhYmxlIiwiSGVhZGVycyIsImhlYWRlcnMiLCJQcm94eSIsImdldCIsInRhcmdldCIsInByb3AiLCJyZWNlaXZlciIsIlJlZmxlY3RBZGFwdGVyIiwibG93ZXJjYXNlZCIsInRvTG93ZXJDYXNlIiwib3JpZ2luYWwiLCJPYmplY3QiLCJrZXlzIiwiZmluZCIsIm8iLCJzZXQiLCJ2YWx1ZSIsImhhcyIsImRlbGV0ZVByb3BlcnR5Iiwic2VhbCIsIm1lcmdlIiwiQXJyYXkiLCJpc0FycmF5Iiwiam9pbiIsImZyb20iLCJhcHBlbmQiLCJuYW1lIiwiZXhpc3RpbmciLCJwdXNoIiwiZGVsZXRlIiwiZm9yRWFjaCIsImNhbGxiYWNrZm4iLCJ0aGlzQXJnIiwiZW50cmllcyIsImNhbGwiLCJrZXkiLCJ2YWx1ZXMiLCJTeW1ib2wiLCJpdGVyYXRvciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7SUEyQmFBLGNBQWMsRUFBQTtlQUFkQTs7SUFwQkFDLG9CQUFvQixFQUFBO2VBQXBCQTs7O3lCQUxrQjtBQUt4QixNQUFNQSw2QkFBNkJDO0lBT3hDLE9BQWNF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QUMvQztRQUNGO0lBQ0Y7QUFvSEYiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTI0NCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9zZXJ2ZXIvcmVxdWVzdC9oZWFkZXJzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEhlYWRlcnNBZGFwdGVyLFxuICB0eXBlIFJlYWRvbmx5SGVhZGVycyxcbn0gZnJvbSAnLi4vd2ViL3NwZWMtZXh0ZW5zaW9uL2FkYXB0ZXJzL2hlYWRlcnMnXG5pbXBvcnQgeyB3b3JrQXN5bmNTdG9yYWdlIH0gZnJvbSAnLi4vYXBwLXJlbmRlci93b3JrLWFzeW5jLXN0b3JhZ2UuZXh0ZXJuYWwnXG5pbXBvcnQgeyBnZXRFeHBlY3RlZFJlcXVlc3RTdG9yZSB9IGZyb20gJy4uL2FwcC1yZW5kZXIvd29yay11bml0LWFzeW5jLXN0b3JhZ2UuZXh0ZXJuYWwnXG5pbXBvcnQge1xuICB3b3JrVW5pdEFzeW5jU3RvcmFnZSxcbiAgdHlwZSBQcmVyZW5kZXJTdG9yZU1vZGVybixcbn0gZnJvbSAnLi4vYXBwLXJlbmRlci93b3JrLXVuaXQtYXN5bmMtc3RvcmFnZS5leHRlcm5hbCdcbmltcG9ydCB7XG4gIHBvc3Rwb25lV2l0aFRyYWNraW5nLFxuICB0aHJvd1RvSW50ZXJydXB0U3RhdGljR2VuZXJhdGlvbixcbiAgdHJhY2tEeW5hbWljRGF0YUluRHluYW1pY1JlbmRlcixcbiAgdHJhY2tTeW5jaHJvbm91c1JlcXVlc3REYXRhQWNjZXNzSW5EZXYsXG59IGZyb20gJy4uL2FwcC1yZW5kZXIvZHluYW1pYy1yZW5kZXJpbmcnXG5pbXBvcnQgeyBTdGF0aWNHZW5CYWlsb3V0RXJyb3IgfSBmcm9tICcuLi8uLi9jbGllbnQvY29tcG9uZW50cy9zdGF0aWMtZ2VuZXJhdGlvbi1iYWlsb3V0J1xuaW1wb3J0IHsgbWFrZUhhbmdpbmdQcm9taXNlIH0gZnJvbSAnLi4vZHluYW1pYy1yZW5kZXJpbmctdXRpbHMnXG5pbXBvcnQgeyBjcmVhdGVEZWR1cGVkQnlDYWxsc2l0ZVNlcnZlckVycm9yTG9nZ2VyRGV2IH0gZnJvbSAnLi4vY3JlYXRlLWRlZHVwZWQtYnktY2FsbHNpdGUtc2VydmVyLWVycm9yLWxvZ2dlcidcbmltcG9ydCB7IHNjaGVkdWxlSW1tZWRpYXRlIH0gZnJvbSAnLi4vLi4vbGliL3NjaGVkdWxlcidcbmltcG9ydCB7IGlzUmVxdWVzdEFQSUNhbGxhYmxlSW5zaWRlQWZ0ZXIgfSBmcm9tICcuL3V0aWxzJ1xuaW1wb3J0IHsgSW52YXJpYW50RXJyb3IgfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL2ludmFyaWFudC1lcnJvcidcbmltcG9ydCB7IFJlZmxlY3RBZGFwdGVyIH0gZnJvbSAnLi4vd2ViL3NwZWMtZXh0ZW5zaW9uL2FkYXB0ZXJzL3JlZmxlY3QnXG5cbi8qKlxuICogSW4gdGhpcyB2ZXJzaW9uIG9mIE5leHQuanMgYGhlYWRlcnMoKWAgcmV0dXJucyBhIFByb21pc2UgaG93ZXZlciB5b3UgY2FuIHN0aWxsIHJlZmVyZW5jZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgdW5kZXJseWluZyBIZWFkZXJzIGluc3RhbmNlXG4gKiBzeW5jaHJvbm91c2x5IHRvIGZhY2lsaXRhdGUgbWlncmF0aW9uLiBUaGUgYFVuc2FmZVVud3JhcHBlZEhlYWRlcnNgIHR5cGUgaXMgYWRkZWQgdG8geW91ciBjb2RlIGJ5IGEgY29kZW1vZCB0aGF0IGF0dGVtcHRzIHRvIGF1dG9tYXRpY2FsbHlcbiAqIHVwZGF0ZXMgY2FsbHNpdGVzIHRvIHJlZmxlY3QgdGhlIG5ldyBQcm9taXNlIHJldHVybiB0eXBlLiBUaGVyZSBhcmUgc29tZSBjYXNlcyB3aGVyZSBgaGVhZGVycygpYCBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQsIG5hbWVseVxuICogd2hlbiBpdCBpcyB1c2VkIGluc2lkZSBhIHN5bmNocm9ub3VzIGZ1bmN0aW9uIGFuZCB3ZSBjYW4ndCBiZSBzdXJlIHRoZSBmdW5jdGlvbiBjYW4gYmUgbWFkZSBhc3luYyBhdXRvbWF0aWNhbGx5LiBJbiB0aGVzZSBjYXNlcyB3ZSBhZGQgYW5cbiAqIGV4cGxpY2l0IHR5cGUgY2FzZSB0byBgVW5zYWZlVW53cmFwcGVkSGVhZGVyc2AgdG8gZW5hYmxlIHR5cGVzY3JpcHQgdG8gYWxsb3cgZm9yIHRoZSBzeW5jaHJvbm91cyB1c2FnZSBvbmx5IHdoZXJlIGl0IGlzIGFjdHVhbGx5IG5lY2Vzc2FyeS5cbiAqXG4gKiBZb3Ugc2hvdWxkIHNob3VsZCB1cGRhdGUgdGhlc2UgY2FsbHNpdGVzIHRvIGVpdGhlciBiZSBhc3luYyBmdW5jdGlvbnMgd2hlcmUgdGhlIGBoZWFkZXJzKClgIHZhbHVlIGNhbiBiZSBhd2FpdGVkIG9yIHlvdSBzaG91bGQgY2FsbCBgaGVhZGVycygpYFxuICogZnJvbSBvdXRzaWRlIGFuZCBhd2FpdCB0aGUgcmV0dXJuIHZhbHVlIGJlZm9yZSBwYXNzaW5nIGl0IGludG8gdGhpcyBmdW5jdGlvbi5cbiAqXG4gKiBZb3UgY2FuIGZpbmQgaW5zdGFuY2VzIHRoYXQgcmVxdWlyZSBtYW51YWwgbWlncmF0aW9uIGJ5IHNlYXJjaGluZyBmb3IgYFVuc2FmZVVud3JhcHBlZEhlYWRlcnNgIGluIHlvdXIgY29kZWJhc2Ugb3IgYnkgc2VhcmNoIGZvciBhIGNvbW1lbnQgdGhhdFxuICogc3RhcnRzIHdpdGggYEBuZXh0LWNvZGVtb2QtZXJyb3JgLlxuICpcbiAqIEluIGEgZnV0dXJlIHZlcnNpb24gb2YgTmV4dC5qcyBgaGVhZGVycygpYCB3aWxsIG9ubHkgcmV0dXJuIGEgUHJvbWlzZSBhbmQgeW91IHdpbGwgbm90IGJlIGFibGUgdG8gYWNjZXNzIHRoZSB1bmRlcmx5aW5nIEhlYWRlcnMgaW5zdGFuY2VcbiAqIHdpdGhvdXQgYXdhaXRpbmcgdGhlIHJldHVybiB2YWx1ZSBmaXJzdC4gV2hlbiB0aGlzIGNoYW5nZSBoYXBwZW5zIHRoZSB0eXBlIGBVbnNhZmVVbndyYXBwZWRIZWFkZXJzYCB3aWxsIGJlIHVwZGF0ZWQgdG8gcmVmbGVjdCB0aGF0IGlzIGl0IG5vIGxvbmdlclxuICogdXNhYmxlLlxuICpcbiAqIFRoaXMgdHlwZSBpcyBtYXJrZWQgZGVwcmVjYXRlZCB0byBoZWxwIGlkZW50aWZ5IGl0IGFzIHRhcmdldCBmb3IgcmVmYWN0b3JpbmcgYXdheS5cbiAqXG4gKiBAZGVwcmVjYXRlZFxuICovXG5leHBvcnQgdHlwZSBVbnNhZmVVbndyYXBwZWRIZWFkZXJzID0gUmVhZG9ubHlIZWFkZXJzXG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBhbGxvd3MgeW91IHRvIHJlYWQgdGhlIEhUVFAgaW5jb21pbmcgcmVxdWVzdCBoZWFkZXJzIGluXG4gKiBbU2VydmVyIENvbXBvbmVudHNdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL3JlbmRlcmluZy9zZXJ2ZXItY29tcG9uZW50cyksXG4gKiBbU2VydmVyIEFjdGlvbnNdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL2RhdGEtZmV0Y2hpbmcvc2VydmVyLWFjdGlvbnMtYW5kLW11dGF0aW9ucyksXG4gKiBbUm91dGUgSGFuZGxlcnNdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL3JvdXRpbmcvcm91dGUtaGFuZGxlcnMpIGFuZFxuICogW01pZGRsZXdhcmVdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL3JvdXRpbmcvbWlkZGxld2FyZSkuXG4gKlxuICogUmVhZCBtb3JlOiBbTmV4dC5qcyBEb2NzOiBgaGVhZGVyc2BdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9hcGktcmVmZXJlbmNlL2Z1bmN0aW9ucy9oZWFkZXJzKVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGVhZGVycygpOiBQcm9taXNlPFJlYWRvbmx5SGVhZGVycz4ge1xuICBjb25zdCB3b3JrU3RvcmUgPSB3b3JrQXN5bmNTdG9yYWdlLmdldFN0b3JlKClcbiAgY29uc3Qgd29ya1VuaXRTdG9yZSA9IHdvcmtVbml0QXN5bmNTdG9yYWdlLmdldFN0b3JlKClcblxuICBpZiAod29ya1N0b3JlKSB7XG4gICAgaWYgKFxuICAgICAgd29ya1VuaXRTdG9yZSAmJlxuICAgICAgd29ya1VuaXRTdG9yZS5waGFzZSA9PT0gJ2FmdGVyJyAmJlxuICAgICAgIWlzUmVxdWVzdEFQSUNhbGxhYmxlSW5zaWRlQWZ0ZXIoKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgUm91dGUgJHt3b3JrU3RvcmUucm91dGV9IHVzZWQgXCJoZWFkZXJzXCIgaW5zaWRlIFwiYWZ0ZXIoLi4uKVwiLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQuIElmIHlvdSBuZWVkIHRoaXMgZGF0YSBpbnNpZGUgYW4gXCJhZnRlclwiIGNhbGxiYWNrLCB1c2UgXCJoZWFkZXJzXCIgb3V0c2lkZSBvZiB0aGUgY2FsbGJhY2suIFNlZSBtb3JlIGluZm8gaGVyZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvY2FuYXJ5L2FwcC9hcGktcmVmZXJlbmNlL2Z1bmN0aW9ucy9hZnRlcmBcbiAgICAgIClcbiAgICB9XG5cbiAgICBpZiAod29ya1N0b3JlLmZvcmNlU3RhdGljKSB7XG4gICAgICAvLyBXaGVuIHVzaW5nIGZvcmNlU3RhdGljIHdlIG92ZXJyaWRlIGFsbCBvdGhlciBsb2dpYyBhbmQgYWx3YXlzIGp1c3QgcmV0dXJuIGFuIGVtcHR5XG4gICAgICAvLyBoZWFkZXJzIG9iamVjdCB3aXRob3V0IHRyYWNraW5nXG4gICAgICBjb25zdCB1bmRlcmx5aW5nSGVhZGVycyA9IEhlYWRlcnNBZGFwdGVyLnNlYWwobmV3IEhlYWRlcnMoe30pKVxuICAgICAgcmV0dXJuIG1ha2VVbnRyYWNrZWRFeG90aWNIZWFkZXJzKHVuZGVybHlpbmdIZWFkZXJzKVxuICAgIH1cblxuICAgIGlmICh3b3JrVW5pdFN0b3JlKSB7XG4gICAgICBpZiAod29ya1VuaXRTdG9yZS50eXBlID09PSAnY2FjaGUnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgUm91dGUgJHt3b3JrU3RvcmUucm91dGV9IHVzZWQgXCJoZWFkZXJzXCIgaW5zaWRlIFwidXNlIGNhY2hlXCIuIEFjY2Vzc2luZyBEeW5hbWljIGRhdGEgc291cmNlcyBpbnNpZGUgYSBjYWNoZSBzY29wZSBpcyBub3Qgc3VwcG9ydGVkLiBJZiB5b3UgbmVlZCB0aGlzIGRhdGEgaW5zaWRlIGEgY2FjaGVkIGZ1bmN0aW9uIHVzZSBcImhlYWRlcnNcIiBvdXRzaWRlIG9mIHRoZSBjYWNoZWQgZnVuY3Rpb24gYW5kIHBhc3MgdGhlIHJlcXVpcmVkIGR5bmFtaWMgZGF0YSBpbiBhcyBhbiBhcmd1bWVudC4gU2VlIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LXJlcXVlc3QtaW4tdXNlLWNhY2hlYFxuICAgICAgICApXG4gICAgICB9IGVsc2UgaWYgKHdvcmtVbml0U3RvcmUudHlwZSA9PT0gJ3Vuc3RhYmxlLWNhY2hlJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFJvdXRlICR7d29ya1N0b3JlLnJvdXRlfSB1c2VkIFwiaGVhZGVyc1wiIGluc2lkZSBhIGZ1bmN0aW9uIGNhY2hlZCB3aXRoIFwidW5zdGFibGVfY2FjaGUoLi4uKVwiLiBBY2Nlc3NpbmcgRHluYW1pYyBkYXRhIHNvdXJjZXMgaW5zaWRlIGEgY2FjaGUgc2NvcGUgaXMgbm90IHN1cHBvcnRlZC4gSWYgeW91IG5lZWQgdGhpcyBkYXRhIGluc2lkZSBhIGNhY2hlZCBmdW5jdGlvbiB1c2UgXCJoZWFkZXJzXCIgb3V0c2lkZSBvZiB0aGUgY2FjaGVkIGZ1bmN0aW9uIGFuZCBwYXNzIHRoZSByZXF1aXJlZCBkeW5hbWljIGRhdGEgaW4gYXMgYW4gYXJndW1lbnQuIFNlZSBtb3JlIGluZm8gaGVyZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2FwaS1yZWZlcmVuY2UvZnVuY3Rpb25zL3Vuc3RhYmxlX2NhY2hlYFxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuICAgIGlmICh3b3JrU3RvcmUuZHluYW1pY1Nob3VsZEVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgU3RhdGljR2VuQmFpbG91dEVycm9yKFxuICAgICAgICBgUm91dGUgJHt3b3JrU3RvcmUucm91dGV9IHdpdGggXFxgZHluYW1pYyA9IFwiZXJyb3JcIlxcYCBjb3VsZG4ndCBiZSByZW5kZXJlZCBzdGF0aWNhbGx5IGJlY2F1c2UgaXQgdXNlZCBcXGBoZWFkZXJzXFxgLiBTZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL3JlbmRlcmluZy9zdGF0aWMtYW5kLWR5bmFtaWMjZHluYW1pYy1yZW5kZXJpbmdgXG4gICAgICApXG4gICAgfVxuXG4gICAgaWYgKHdvcmtVbml0U3RvcmUpIHtcbiAgICAgIHN3aXRjaCAod29ya1VuaXRTdG9yZS50eXBlKSB7XG4gICAgICAgIGNhc2UgJ3ByZXJlbmRlcic6XG4gICAgICAgICAgcmV0dXJuIG1ha2VIYW5naW5nSGVhZGVycyh3b3JrVW5pdFN0b3JlKVxuICAgICAgICBjYXNlICdwcmVyZW5kZXItY2xpZW50JzpcbiAgICAgICAgICBjb25zdCBleHBvcnROYW1lID0gJ2BoZWFkZXJzYCdcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YXJpYW50RXJyb3IoXG4gICAgICAgICAgICBgJHtleHBvcnROYW1lfSBtdXN0IG5vdCBiZSB1c2VkIHdpdGhpbiBhIGNsaWVudCBjb21wb25lbnQuIE5leHQuanMgc2hvdWxkIGJlIHByZXZlbnRpbmcgJHtleHBvcnROYW1lfSBmcm9tIGJlaW5nIGluY2x1ZGVkIGluIGNsaWVudCBjb21wb25lbnRzIHN0YXRpY2FsbHksIGJ1dCBkaWQgbm90IGluIHRoaXMgY2FzZS5gXG4gICAgICAgICAgKVxuICAgICAgICBjYXNlICdwcmVyZW5kZXItcHByJzpcbiAgICAgICAgICAvLyBQUFIgUHJlcmVuZGVyIChubyBkeW5hbWljSU8pXG4gICAgICAgICAgLy8gV2UgYXJlIHByZXJlbmRlcmluZyB3aXRoIFBQUi4gV2UgbmVlZCB0cmFjayBkeW5hbWljIGFjY2VzcyBoZXJlIGVhZ2VybHlcbiAgICAgICAgICAvLyB0byBrZWVwIGNvbnRpbnVpdHkgd2l0aCBob3cgaGVhZGVycyBoYXMgd29ya2VkIGluIFBQUiB3aXRob3V0IGR5bmFtaWNJTy5cbiAgICAgICAgICAvLyBUT0RPIGNvbnNpZGVyIHN3aXRjaGluZyB0aGUgc2VtYW50aWMgdG8gdGhyb3cgb24gcHJvcGVydHkgYWNjZXNzIGluc3RlYWRcbiAgICAgICAgICBwb3N0cG9uZVdpdGhUcmFja2luZyhcbiAgICAgICAgICAgIHdvcmtTdG9yZS5yb3V0ZSxcbiAgICAgICAgICAgICdoZWFkZXJzJyxcbiAgICAgICAgICAgIHdvcmtVbml0U3RvcmUuZHluYW1pY1RyYWNraW5nXG4gICAgICAgICAgKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ3ByZXJlbmRlci1sZWdhY3knOlxuICAgICAgICAgIC8vIExlZ2FjeSBQcmVyZW5kZXJcbiAgICAgICAgICAvLyBXZSBhcmUgaW4gYSBsZWdhY3kgc3RhdGljIGdlbmVyYXRpb24gbW9kZSB3aGlsZSBwcmVyZW5kZXJpbmdcbiAgICAgICAgICAvLyBXZSB0cmFjayBkeW5hbWljIGFjY2VzcyBoZXJlIHNvIHdlIGRvbid0IG5lZWQgdG8gd3JhcCB0aGUgaGVhZGVycyBpblxuICAgICAgICAgIC8vIGluZGl2aWR1YWwgcHJvcGVydHkgYWNjZXNzIHRyYWNraW5nLlxuICAgICAgICAgIHRocm93VG9JbnRlcnJ1cHRTdGF0aWNHZW5lcmF0aW9uKCdoZWFkZXJzJywgd29ya1N0b3JlLCB3b3JrVW5pdFN0b3JlKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIGZhbGx0aHJvdWdoXG4gICAgICB9XG4gICAgfVxuICAgIC8vIFdlIGZhbGwgdGhyb3VnaCB0byB0aGUgZHluYW1pYyBjb250ZXh0IGJlbG93IGJ1dCB3ZSBzdGlsbCB0cmFjayBkeW5hbWljIGFjY2Vzc1xuICAgIC8vIGJlY2F1c2UgaW4gZGV2IHdlIGNhbiBzdGlsbCBlcnJvciBmb3IgdGhpbmdzIGxpa2UgdXNpbmcgaGVhZGVycyBpbnNpZGUgYSBjYWNoZSBjb250ZXh0XG4gICAgdHJhY2tEeW5hbWljRGF0YUluRHluYW1pY1JlbmRlcih3b3JrU3RvcmUsIHdvcmtVbml0U3RvcmUpXG4gIH1cblxuICBjb25zdCByZXF1ZXN0U3RvcmUgPSBnZXRFeHBlY3RlZFJlcXVlc3RTdG9yZSgnaGVhZGVycycpXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAhd29ya1N0b3JlPy5pc1ByZWZldGNoUmVxdWVzdCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfRFlOQU1JQ19JTykge1xuICAgICAgcmV0dXJuIG1ha2VVbnRyYWNrZWRIZWFkZXJzV2l0aERldldhcm5pbmdzKFxuICAgICAgICByZXF1ZXN0U3RvcmUuaGVhZGVycyxcbiAgICAgICAgd29ya1N0b3JlPy5yb3V0ZVxuICAgICAgKVxuICAgIH1cblxuICAgIHJldHVybiBtYWtlVW50cmFja2VkRXhvdGljSGVhZGVyc1dpdGhEZXZXYXJuaW5ncyhcbiAgICAgIHJlcXVlc3RTdG9yZS5oZWFkZXJzLFxuICAgICAgd29ya1N0b3JlPy5yb3V0ZVxuICAgIClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbWFrZVVudHJhY2tlZEV4b3RpY0hlYWRlcnMocmVxdWVzdFN0b3JlLmhlYWRlcnMpXG4gIH1cbn1cblxuaW50ZXJmYWNlIENhY2hlTGlmZXRpbWUge31cbmNvbnN0IENhY2hlZEhlYWRlcnMgPSBuZXcgV2Vha01hcDxDYWNoZUxpZmV0aW1lLCBQcm9taXNlPFJlYWRvbmx5SGVhZGVycz4+KClcblxuZnVuY3Rpb24gbWFrZUhhbmdpbmdIZWFkZXJzKFxuICBwcmVyZW5kZXJTdG9yZTogUHJlcmVuZGVyU3RvcmVNb2Rlcm5cbik6IFByb21pc2U8UmVhZG9ubHlIZWFkZXJzPiB7XG4gIGNvbnN0IGNhY2hlZEhlYWRlcnMgPSBDYWNoZWRIZWFkZXJzLmdldChwcmVyZW5kZXJTdG9yZSlcbiAgaWYgKGNhY2hlZEhlYWRlcnMpIHtcbiAgICByZXR1cm4gY2FjaGVkSGVhZGVyc1xuICB9XG5cbiAgY29uc3QgcHJvbWlzZSA9IG1ha2VIYW5naW5nUHJvbWlzZTxSZWFkb25seUhlYWRlcnM+KFxuICAgIHByZXJlbmRlclN0b3JlLnJlbmRlclNpZ25hbCxcbiAgICAnYGhlYWRlcnMoKWAnXG4gIClcbiAgQ2FjaGVkSGVhZGVycy5zZXQocHJlcmVuZGVyU3RvcmUsIHByb21pc2UpXG5cbiAgcmV0dXJuIHByb21pc2Vcbn1cblxuZnVuY3Rpb24gbWFrZVVudHJhY2tlZEV4b3RpY0hlYWRlcnMoXG4gIHVuZGVybHlpbmdIZWFkZXJzOiBSZWFkb25seUhlYWRlcnNcbik6IFByb21pc2U8UmVhZG9ubHlIZWFkZXJzPiB7XG4gIGNvbnN0IGNhY2hlZEhlYWRlcnMgPSBDYWNoZWRIZWFkZXJzLmdldCh1bmRlcmx5aW5nSGVhZGVycylcbiAgaWYgKGNhY2hlZEhlYWRlcnMpIHtcbiAgICByZXR1cm4gY2FjaGVkSGVhZGVyc1xuICB9XG5cbiAgY29uc3QgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSh1bmRlcmx5aW5nSGVhZGVycylcbiAgQ2FjaGVkSGVhZGVycy5zZXQodW5kZXJseWluZ0hlYWRlcnMsIHByb21pc2UpXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMocHJvbWlzZSwge1xuICAgIGFwcGVuZDoge1xuICAgICAgdmFsdWU6IHVuZGVybHlpbmdIZWFkZXJzLmFwcGVuZC5iaW5kKHVuZGVybHlpbmdIZWFkZXJzKSxcbiAgICB9LFxuICAgIGRlbGV0ZToge1xuICAgICAgdmFsdWU6IHVuZGVybHlpbmdIZWFkZXJzLmRlbGV0ZS5iaW5kKHVuZGVybHlpbmdIZWFkZXJzKSxcbiAgICB9LFxuICAgIGdldDoge1xuICAgICAgdmFsdWU6IHVuZGVybHlpbmdIZWFkZXJzLmdldC5iaW5kKHVuZGVybHlpbmdIZWFkZXJzKSxcbiAgICB9LFxuICAgIGhhczoge1xuICAgICAgdmFsdWU6IHVuZGVybHlpbmdIZWFkZXJzLmhhcy5iaW5kKHVuZGVybHlpbmdIZWFkZXJzKSxcbiAgICB9LFxuICAgIHNldDoge1xuICAgICAgdmFsdWU6IHVuZGVybHlpbmdIZWFkZXJzLnNldC5iaW5kKHVuZGVybHlpbmdIZWFkZXJzKSxcbiAgICB9LFxuICAgIGdldFNldENvb2tpZToge1xuICAgICAgdmFsdWU6IHVuZGVybHlpbmdIZWFkZXJzLmdldFNldENvb2tpZS5iaW5kKHVuZGVybHlpbmdIZWFkZXJzKSxcbiAgICB9LFxuICAgIGZvckVhY2g6IHtcbiAgICAgIHZhbHVlOiB1bmRlcmx5aW5nSGVhZGVycy5mb3JFYWNoLmJpbmQodW5kZXJseWluZ0hlYWRlcnMpLFxuICAgIH0sXG4gICAga2V5czoge1xuICAgICAgdmFsdWU6IHVuZGVybHlpbmdIZWFkZXJzLmtleXMuYmluZCh1bmRlcmx5aW5nSGVhZGVycyksXG4gICAgfSxcbiAgICB2YWx1ZXM6IHtcbiAgICAgIHZhbHVlOiB1bmRlcmx5aW5nSGVhZGVycy52YWx1ZXMuYmluZCh1bmRlcmx5aW5nSGVhZGVycyksXG4gICAgfSxcbiAgICBlbnRyaWVzOiB7XG4gICAgICB2YWx1ZTogdW5kZXJseWluZ0hlYWRlcnMuZW50cmllcy5iaW5kKHVuZGVybHlpbmdIZWFkZXJzKSxcbiAgICB9LFxuICAgIFtTeW1ib2wuaXRlcmF0b3JdOiB7XG4gICAgICB2YWx1ZTogdW5kZXJseWluZ0hlYWRlcnNbU3ltYm9sLml0ZXJhdG9yXS5iaW5kKHVuZGVybHlpbmdIZWFkZXJzKSxcbiAgICB9LFxuICB9IHNhdGlzZmllcyBIZWFkZXJzRXh0ZW5zaW9ucylcblxuICByZXR1cm4gcHJvbWlzZVxufVxuXG5mdW5jdGlvbiBtYWtlVW50cmFja2VkRXhvdGljSGVhZGVyc1dpdGhEZXZXYXJuaW5ncyhcbiAgdW5kZXJseWluZ0hlYWRlcnM6IFJlYWRvbmx5SGVhZGVycyxcbiAgcm91dGU/OiBzdHJpbmdcbik6IFByb21pc2U8UmVhZG9ubHlIZWFkZXJzPiB7XG4gIGNvbnN0IGNhY2hlZEhlYWRlcnMgPSBDYWNoZWRIZWFkZXJzLmdldCh1bmRlcmx5aW5nSGVhZGVycylcbiAgaWYgKGNhY2hlZEhlYWRlcnMpIHtcbiAgICByZXR1cm4gY2FjaGVkSGVhZGVyc1xuICB9XG5cbiAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlPFJlYWRvbmx5SGVhZGVycz4oKHJlc29sdmUpID0+XG4gICAgc2NoZWR1bGVJbW1lZGlhdGUoKCkgPT4gcmVzb2x2ZSh1bmRlcmx5aW5nSGVhZGVycykpXG4gIClcblxuICBDYWNoZWRIZWFkZXJzLnNldCh1bmRlcmx5aW5nSGVhZGVycywgcHJvbWlzZSlcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhwcm9taXNlLCB7XG4gICAgYXBwZW5kOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYXBwZW5kKCkge1xuICAgICAgICBjb25zdCBleHByZXNzaW9uID0gYFxcYGhlYWRlcnMoKS5hcHBlbmQoJHtkZXNjcmliZU5hbWVBcmcoYXJndW1lbnRzWzBdKX0sIC4uLilcXGBgXG4gICAgICAgIHN5bmNJT0Rldihyb3V0ZSwgZXhwcmVzc2lvbilcbiAgICAgICAgcmV0dXJuIHVuZGVybHlpbmdIZWFkZXJzLmFwcGVuZC5hcHBseShcbiAgICAgICAgICB1bmRlcmx5aW5nSGVhZGVycyxcbiAgICAgICAgICBhcmd1bWVudHMgYXMgYW55XG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgfSxcbiAgICBkZWxldGU6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVsZXRlKCkge1xuICAgICAgICBjb25zdCBleHByZXNzaW9uID0gYFxcYGhlYWRlcnMoKS5kZWxldGUoJHtkZXNjcmliZU5hbWVBcmcoYXJndW1lbnRzWzBdKX0pXFxgYFxuICAgICAgICBzeW5jSU9EZXYocm91dGUsIGV4cHJlc3Npb24pXG4gICAgICAgIHJldHVybiB1bmRlcmx5aW5nSGVhZGVycy5kZWxldGUuYXBwbHkoXG4gICAgICAgICAgdW5kZXJseWluZ0hlYWRlcnMsXG4gICAgICAgICAgYXJndW1lbnRzIGFzIGFueVxuICAgICAgICApXG4gICAgICB9LFxuICAgIH0sXG4gICAgZ2V0OiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICBjb25zdCBleHByZXNzaW9uID0gYFxcYGhlYWRlcnMoKS5nZXQoJHtkZXNjcmliZU5hbWVBcmcoYXJndW1lbnRzWzBdKX0pXFxgYFxuICAgICAgICBzeW5jSU9EZXYocm91dGUsIGV4cHJlc3Npb24pXG4gICAgICAgIHJldHVybiB1bmRlcmx5aW5nSGVhZGVycy5nZXQuYXBwbHkodW5kZXJseWluZ0hlYWRlcnMsIGFyZ3VtZW50cyBhcyBhbnkpXG4gICAgICB9LFxuICAgIH0sXG4gICAgaGFzOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaGFzKCkge1xuICAgICAgICBjb25zdCBleHByZXNzaW9uID0gYFxcYGhlYWRlcnMoKS5oYXMoJHtkZXNjcmliZU5hbWVBcmcoYXJndW1lbnRzWzBdKX0pXFxgYFxuICAgICAgICBzeW5jSU9EZXYocm91dGUsIGV4cHJlc3Npb24pXG4gICAgICAgIHJldHVybiB1bmRlcmx5aW5nSGVhZGVycy5oYXMuYXBwbHkodW5kZXJseWluZ0hlYWRlcnMsIGFyZ3VtZW50cyBhcyBhbnkpXG4gICAgICB9LFxuICAgIH0sXG4gICAgc2V0OiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KCkge1xuICAgICAgICBjb25zdCBleHByZXNzaW9uID0gYFxcYGhlYWRlcnMoKS5zZXQoJHtkZXNjcmliZU5hbWVBcmcoYXJndW1lbnRzWzBdKX0sIC4uLilcXGBgXG4gICAgICAgIHN5bmNJT0Rldihyb3V0ZSwgZXhwcmVzc2lvbilcbiAgICAgICAgcmV0dXJuIHVuZGVybHlpbmdIZWFkZXJzLnNldC5hcHBseSh1bmRlcmx5aW5nSGVhZGVycywgYXJndW1lbnRzIGFzIGFueSlcbiAgICAgIH0sXG4gICAgfSxcbiAgICBnZXRTZXRDb29raWU6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTZXRDb29raWUoKSB7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSAnYGhlYWRlcnMoKS5nZXRTZXRDb29raWUoKWAnXG4gICAgICAgIHN5bmNJT0Rldihyb3V0ZSwgZXhwcmVzc2lvbilcbiAgICAgICAgcmV0dXJuIHVuZGVybHlpbmdIZWFkZXJzLmdldFNldENvb2tpZS5hcHBseShcbiAgICAgICAgICB1bmRlcmx5aW5nSGVhZGVycyxcbiAgICAgICAgICBhcmd1bWVudHMgYXMgYW55XG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgfSxcbiAgICBmb3JFYWNoOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZm9yRWFjaCgpIHtcbiAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9ICdgaGVhZGVycygpLmZvckVhY2goLi4uKWAnXG4gICAgICAgIHN5bmNJT0Rldihyb3V0ZSwgZXhwcmVzc2lvbilcbiAgICAgICAgcmV0dXJuIHVuZGVybHlpbmdIZWFkZXJzLmZvckVhY2guYXBwbHkoXG4gICAgICAgICAgdW5kZXJseWluZ0hlYWRlcnMsXG4gICAgICAgICAgYXJndW1lbnRzIGFzIGFueVxuICAgICAgICApXG4gICAgICB9LFxuICAgIH0sXG4gICAga2V5czoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGtleXMoKSB7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSAnYGhlYWRlcnMoKS5rZXlzKClgJ1xuICAgICAgICBzeW5jSU9EZXYocm91dGUsIGV4cHJlc3Npb24pXG4gICAgICAgIHJldHVybiB1bmRlcmx5aW5nSGVhZGVycy5rZXlzLmFwcGx5KHVuZGVybHlpbmdIZWFkZXJzLCBhcmd1bWVudHMgYXMgYW55KVxuICAgICAgfSxcbiAgICB9LFxuICAgIHZhbHVlczoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlcygpIHtcbiAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9ICdgaGVhZGVycygpLnZhbHVlcygpYCdcbiAgICAgICAgc3luY0lPRGV2KHJvdXRlLCBleHByZXNzaW9uKVxuICAgICAgICByZXR1cm4gdW5kZXJseWluZ0hlYWRlcnMudmFsdWVzLmFwcGx5KFxuICAgICAgICAgIHVuZGVybHlpbmdIZWFkZXJzLFxuICAgICAgICAgIGFyZ3VtZW50cyBhcyBhbnlcbiAgICAgICAgKVxuICAgICAgfSxcbiAgICB9LFxuICAgIGVudHJpZXM6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBlbnRyaWVzKCkge1xuICAgICAgICBjb25zdCBleHByZXNzaW9uID0gJ2BoZWFkZXJzKCkuZW50cmllcygpYCdcbiAgICAgICAgc3luY0lPRGV2KHJvdXRlLCBleHByZXNzaW9uKVxuICAgICAgICByZXR1cm4gdW5kZXJseWluZ0hlYWRlcnMuZW50cmllcy5hcHBseShcbiAgICAgICAgICB1bmRlcmx5aW5nSGVhZGVycyxcbiAgICAgICAgICBhcmd1bWVudHMgYXMgYW55XG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgfSxcbiAgICBbU3ltYm9sLml0ZXJhdG9yXToge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9ICdgLi4uaGVhZGVycygpYCBvciBzaW1pbGFyIGl0ZXJhdGlvbidcbiAgICAgICAgc3luY0lPRGV2KHJvdXRlLCBleHByZXNzaW9uKVxuICAgICAgICByZXR1cm4gdW5kZXJseWluZ0hlYWRlcnNbU3ltYm9sLml0ZXJhdG9yXS5hcHBseShcbiAgICAgICAgICB1bmRlcmx5aW5nSGVhZGVycyxcbiAgICAgICAgICBhcmd1bWVudHMgYXMgYW55XG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgfSxcbiAgfSBzYXRpc2ZpZXMgSGVhZGVyc0V4dGVuc2lvbnMpXG5cbiAgcmV0dXJuIHByb21pc2Vcbn1cblxuLy8gU2ltaWxhciB0byBgbWFrZVVudHJhY2tlZEV4b3RpY0hlYWRlcnNXaXRoRGV2V2FybmluZ3NgLCBidXQganVzdCBsb2dnaW5nIHRoZVxuLy8gc3luYyBhY2Nlc3Mgd2l0aG91dCBhY3R1YWxseSBkZWZpbmluZyB0aGUgaGVhZGVycyBwcm9wZXJ0aWVzIG9uIHRoZSBwcm9taXNlLlxuZnVuY3Rpb24gbWFrZVVudHJhY2tlZEhlYWRlcnNXaXRoRGV2V2FybmluZ3MoXG4gIHVuZGVybHlpbmdIZWFkZXJzOiBSZWFkb25seUhlYWRlcnMsXG4gIHJvdXRlPzogc3RyaW5nXG4pOiBQcm9taXNlPFJlYWRvbmx5SGVhZGVycz4ge1xuICBjb25zdCBjYWNoZWRIZWFkZXJzID0gQ2FjaGVkSGVhZGVycy5nZXQodW5kZXJseWluZ0hlYWRlcnMpXG4gIGlmIChjYWNoZWRIZWFkZXJzKSB7XG4gICAgcmV0dXJuIGNhY2hlZEhlYWRlcnNcbiAgfVxuXG4gIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZTxSZWFkb25seUhlYWRlcnM+KChyZXNvbHZlKSA9PlxuICAgIHNjaGVkdWxlSW1tZWRpYXRlKCgpID0+IHJlc29sdmUodW5kZXJseWluZ0hlYWRlcnMpKVxuICApXG5cbiAgY29uc3QgcHJveGllZFByb21pc2UgPSBuZXcgUHJveHkocHJvbWlzZSwge1xuICAgIGdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG4gICAgICBzd2l0Y2ggKHByb3ApIHtcbiAgICAgICAgY2FzZSBTeW1ib2wuaXRlcmF0b3I6IHtcbiAgICAgICAgICB3YXJuRm9yU3luY0FjY2Vzcyhyb3V0ZSwgJ2AuLi5oZWFkZXJzKClgIG9yIHNpbWlsYXIgaXRlcmF0aW9uJylcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2FwcGVuZCc6XG4gICAgICAgIGNhc2UgJ2RlbGV0ZSc6XG4gICAgICAgIGNhc2UgJ2dldCc6XG4gICAgICAgIGNhc2UgJ2hhcyc6XG4gICAgICAgIGNhc2UgJ3NldCc6XG4gICAgICAgIGNhc2UgJ2dldFNldENvb2tpZSc6XG4gICAgICAgIGNhc2UgJ2ZvckVhY2gnOlxuICAgICAgICBjYXNlICdrZXlzJzpcbiAgICAgICAgY2FzZSAndmFsdWVzJzpcbiAgICAgICAgY2FzZSAnZW50cmllcyc6IHtcbiAgICAgICAgICB3YXJuRm9yU3luY0FjY2Vzcyhyb3V0ZSwgYFxcYGhlYWRlcnMoKS4ke3Byb3B9XFxgYClcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAvLyBXZSBvbmx5IHdhcm4gZm9yIHdlbGwtZGVmaW5lZCBwcm9wZXJ0aWVzIG9mIHRoZSBoZWFkZXJzIG9iamVjdC5cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gUmVmbGVjdEFkYXB0ZXIuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpXG4gICAgfSxcbiAgfSlcblxuICBDYWNoZWRIZWFkZXJzLnNldCh1bmRlcmx5aW5nSGVhZGVycywgcHJveGllZFByb21pc2UpXG5cbiAgcmV0dXJuIHByb3hpZWRQcm9taXNlXG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmFtZUFyZyhhcmc6IHVua25vd24pIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnID8gYCcke2FyZ30nYCA6ICcuLi4nXG59XG5cbmZ1bmN0aW9uIHN5bmNJT0Rldihyb3V0ZTogc3RyaW5nIHwgdW5kZWZpbmVkLCBleHByZXNzaW9uOiBzdHJpbmcpIHtcbiAgY29uc3Qgd29ya1VuaXRTdG9yZSA9IHdvcmtVbml0QXN5bmNTdG9yYWdlLmdldFN0b3JlKClcbiAgaWYgKFxuICAgIHdvcmtVbml0U3RvcmUgJiZcbiAgICB3b3JrVW5pdFN0b3JlLnR5cGUgPT09ICdyZXF1ZXN0JyAmJlxuICAgIHdvcmtVbml0U3RvcmUucHJlcmVuZGVyUGhhc2UgPT09IHRydWVcbiAgKSB7XG4gICAgLy8gV2hlbiB3ZSdyZSByZW5kZXJpbmcgZHluYW1pY2FsbHkgaW4gZGV2IHdlIG5lZWQgdG8gYWR2YW5jZSBvdXQgb2YgdGhlXG4gICAgLy8gUHJlcmVuZGVyIGVudmlyb25tZW50IHdoZW4gd2UgcmVhZCBSZXF1ZXN0IGRhdGEgc3luY2hyb25vdXNseVxuICAgIGNvbnN0IHJlcXVlc3RTdG9yZSA9IHdvcmtVbml0U3RvcmVcbiAgICB0cmFja1N5bmNocm9ub3VzUmVxdWVzdERhdGFBY2Nlc3NJbkRldihyZXF1ZXN0U3RvcmUpXG4gIH1cbiAgLy8gSW4gYWxsIGNhc2VzIHdlIHdhcm4gbm9ybWFsbHlcbiAgd2FybkZvclN5bmNBY2Nlc3Mocm91dGUsIGV4cHJlc3Npb24pXG59XG5cbmNvbnN0IHdhcm5Gb3JTeW5jQWNjZXNzID0gY3JlYXRlRGVkdXBlZEJ5Q2FsbHNpdGVTZXJ2ZXJFcnJvckxvZ2dlckRldihcbiAgY3JlYXRlSGVhZGVyc0FjY2Vzc0Vycm9yXG4pXG5cbmZ1bmN0aW9uIGNyZWF0ZUhlYWRlcnNBY2Nlc3NFcnJvcihcbiAgcm91dGU6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgZXhwcmVzc2lvbjogc3RyaW5nXG4pIHtcbiAgY29uc3QgcHJlZml4ID0gcm91dGUgPyBgUm91dGUgXCIke3JvdXRlfVwiIGAgOiAnVGhpcyByb3V0ZSAnXG4gIHJldHVybiBuZXcgRXJyb3IoXG4gICAgYCR7cHJlZml4fXVzZWQgJHtleHByZXNzaW9ufS4gYCArXG4gICAgICBgXFxgaGVhZGVycygpXFxgIHNob3VsZCBiZSBhd2FpdGVkIGJlZm9yZSB1c2luZyBpdHMgdmFsdWUuIGAgK1xuICAgICAgYExlYXJuIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL3N5bmMtZHluYW1pYy1hcGlzYFxuICApXG59XG5cbnR5cGUgSGVhZGVyc0V4dGVuc2lvbnMgPSB7XG4gIFtLIGluIGtleW9mIFJlYWRvbmx5SGVhZGVyc106IHVua25vd25cbn1cbiJdLCJuYW1lcyI6WyJoZWFkZXJzIiwid29ya1N0b3JlIiwid29ya0FzeW5jU3RvcmFnZSIsImdldFN0b3JlIiwid29ya1VuaXRTdG9yZSIsIndvcmtVbml0QXN5bmNTdG9yYWdlIiwicGhhc2UiLCJpc1JlcXVlc3RBUElDYWxsYWJsZUluc2lkZUFmdGVyIiwiRXJyb3IiLCJyb3V0ZSIsImZvcmNlU3RhdGljIiwidW5kZXJseWluZ0hlYWRlcnMiLCJIZWFkZXJzQWRhcHRlciIsInNlYWwiLCJIZWFkZXJzIiwibWFrZVVudHJhY2tlZEV4b3RpY0hlYWRlcnMiLCJ0eXBlIiwiZHluYW1pY1Nob3VsZEVycm9yIiwiU3RhdGljR2VuQmFpbG91dEVycm9yIiwibWFrZUhhbmdpbmdIZWFkZXJzIiwiZXhwb3J0TmFtZSIsIkludmFyaWFudEVycm9yIiwicG9zdHBvbmVXaXRoVHJhY2tpbmciLCJkeW5hbWljVHJhY2tpbmciLCJ0aHJvd1RvSW50ZXJydXB0U3RhdGljR2VuZXJhdGlvbiIsInRyYWNrRHluYW1pY0RhdGFJbkR5bmFtaWNSZW5kZXIiLCJyZXF1ZXN0U3RvcmUiLCJnZXRFeHBlY3RlZFJlcXVlc3RTdG9yZSIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImlzUHJlZmV0Y2hSZXF1ZXN0IiwiX19ORVhUX0RZTkFNSUNfSU8iLCJtYWtlVW50cmFja2VkSGVhZGVyc1dpdGhEZXZXYXJuaW5ncyIsIm1ha2VVbnRyYWNrZWRFeG90aWNIZWFkZXJzV2l0aERldldhcm5pbmdzIiwiQ2FjaGVkSGVhZGVycyIsIldlYWtNYXAiLCJwcmVyZW5kZXJTdG9yZSIsImNhY2hlZEhlYWRlcnMiLCJnZXQiLCJwcm9taXNlIiwibWFrZUhhbmdpbmdQcm9taXNlIiwicmVuZGVyU2lnbmFsIiwic2V0IiwiUHJvbWlzZSIsInJlc29sdmUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiYXBwZW5kIiwidmFsdWUiLCJiaW5kIiwiZGVsZXRlIiwiaGFzIiwiZ2V0U2V0Q29va2llIiwiZm9yRWFjaCIsImtleXMiLCJ2YWx1ZXMiLCJlbnRyaWVzIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJzY2hlZHVsZUltbWVkaWF0ZSIsImV4cHJlc3Npb24iLCJkZXNjcmliZU5hbWVBcmciLCJhcmd1bWVudHMiLCJzeW5jSU9EZXYiLCJhcHBseSIsIl9kZWxldGUiLCJwcm94aWVkUHJvbWlzZSIsIlByb3h5IiwidGFyZ2V0IiwicHJvcCIsInJlY2VpdmVyIiwid2FybkZvclN5bmNBY2Nlc3MiLCJSZWZsZWN0QWRhcHRlciIsImFyZyIsInByZXJlbmRlclBoYXNlIiwidHJhY2tTeW5jaHJvbm91c1JlcXVlc3REYXRhQWNjZXNzSW5EZXYiLCJjcmVhdGVEZWR1cGVkQnlDYWxsc2l0ZVNlcnZlckVycm9yTG9nZ2VyRGV2IiwiY3JlYXRlSGVhZGVyc0FjY2Vzc0Vycm9yIiwicHJlZml4Il0sIm1hcHBpbmdzIjoiQUFvSU00QixRQUFRQyxHQUFHLENBQUNDLFFBQVE7Ozs7OytCQTVFVjlCLFdBQUFBOzs7ZUFBQUE7Ozt5QkFyRFQ7MENBQzBCOzhDQUNPO2tDQVVqQzt5Q0FDK0I7dUNBQ0g7MERBQ3lCOzJCQUMxQjt1QkFDYztnQ0FDakI7eUJBQ0E7QUFrQ3hCLFNBQVNBO0lBQ2QsTUFBTUMsWUFBWUMsMEJBQUFBLGdCQUFnQixDQUFDQyxRQUFRO0lBQzNDLE1BQU1DLGdCQUFnQkMsOEJBQUFBLG9CQUFvQixDQUFDRixRQUFRO0lBRW5ELElBQUlGLFdBQVc7UUFDYixJQUNFRyxpQkFDQUEsY0FBY0UsS0FBSyxLQUFLLFdBQ3hCLENBQUNDLENBQUFBLEdBQUFBLE9BQUFBLCtCQUErQixLQUNoQztZQUNBLE1BQU0sT0FBQSxjQUVMLENBRkssSUFBSUMsTUFDUixBQUFDLE1BQU0sR0FBa0IsT0FBaEJQLFVBQVVRLEtBQUssbU5BQTBPLENBQUMsNkJBRC9QLHFCQUFBO3VCQUFBOzRCQUFBOzhCQUFBO1lBRU47UUFDRjtRQUVBLElBQUlSLFVBQVVTLFdBQVcsRUFBRTtZQUN6QixxRkFBcUY7WUFDckYsa0NBQWtDO1lBQ2xDLE1BQU1DLG9CQUFvQkMsU0FBQUEs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RDtJQUVyQyxPQUFPQTtBQUNUO0FBRUEsU0FBU0wsZ0JBQWdCWSxHQUFZO0lBQ25DLE9BQU8sT0FBT0EsUUFBUSxXQUFXLEFBQUMsQ0FBQyxVQUFFQSxLQUFJLENBQUMsQ0FBQyxLQUFHO0FBQ2hEO0FBRUEsU0FBU1YsVUFBVXZELEtBQXlCLEVBQUVvRCxVQUFrQjtJQUM5RCxNQUFNekQsZ0JBQWdCQyw4QkFBQUEsb0JBQW9CLENBQUNGLFFBQVE7SUFDbkQsSUFDRUMsaUJBQ0FBLGNBQWNZLElBQUksS0FBSyxhQUN2QlosY0FBY3VFLGNBQWMsS0FBSyxNQUNqQztRQUNBLHdFQUF3RTtRQUN4RSxnRUFBZ0U7UUFDaEUsTUFBTWpELGVBQWV0QjtRQUNyQndFLENBQUFBLEdBQUFBLGtCQUFBQSxzQ0FBc0MsRUFBQ2xEO0lBQ3pDO0lBQ0EsZ0NBQWdDO0lBQ2hDOEMsa0JBQWtCL0QsT0FBT29EO0FBQzNCO0FBRUEsTUFBTVcsb0JBQW9CSyxDQUFBQSxHQUFBQSwwQ0FBQUEsMkNBQTJDLEVBQ25FQztBQUdGLFNBQVNBLHlCQUNQckUsS0FBeUIsRUFDekJvRCxVQUFrQjtJQUVsQixNQUFNa0IsU0FBU3RFLFFBQVEsQUFBQyxPQUFPLFVBQUVBLE9BQU0sRUFBRSxDQUFDLEtBQUc7SUFDN0MsT0FBTyxPQUFBLGNBSU4sQ0FKTSxJQUFJRCxNQUNULFVBQUd1RSxRQUFPLEtBQUssV0FBRWxCLFlBQVcsRUFBRSxDQUFDLEdBQzdCLEVBQUMsd0RBQXdELENBQUMsRUFDekQsQ0FBRCw2REFBK0QsQ0FBQyxJQUg3RCxxQkFBQTtlQUFBO29CQUFBO3NCQUFBO0lBSVA7QUFDRiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxNTU4LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL3NlcnZlci9yZXF1ZXN0L2RyYWZ0LW1vZGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgZ2V0RHJhZnRNb2RlUHJvdmlkZXJGb3JDYWNoZVNjb3BlLFxuICB0aHJvd0Zvck1pc3NpbmdSZXF1ZXN0U3RvcmUsXG59IGZyb20gJy4uL2FwcC1yZW5kZXIvd29yay11bml0LWFzeW5jLXN0b3JhZ2UuZXh0ZXJuYWwnXG5cbmltcG9ydCB0eXBlIHsgRHJhZnRNb2RlUHJvdmlkZXIgfSBmcm9tICcuLi9hc3luYy1zdG9yYWdlL2RyYWZ0LW1vZGUtcHJvdmlkZXInXG5cbmltcG9ydCB7XG4gIHdvcmtBc3luY1N0b3JhZ2UsXG4gIHR5cGUgV29ya1N0b3JlLFxufSBmcm9tICcuLi9hcHAtcmVuZGVyL3dvcmstYXN5bmMtc3RvcmFnZS5leHRlcm5hbCdcbmltcG9ydCB7IHdvcmtVbml0QXN5bmNTdG9yYWdlIH0gZnJvbSAnLi4vYXBwLXJlbmRlci93b3JrLXVuaXQtYXN5bmMtc3RvcmFnZS5leHRlcm5hbCdcbmltcG9ydCB7XG4gIGFib3J0QW5kVGhyb3dPblN5bmNocm9ub3VzUmVxdWVzdERhdGFBY2Nlc3MsXG4gIHBvc3Rwb25lV2l0aFRyYWNraW5nLFxuICB0cmFja1N5bmNocm9ub3VzUmVxdWVzdERhdGFBY2Nlc3NJbkRldixcbn0gZnJvbSAnLi4vYXBwLXJlbmRlci9keW5hbWljLXJlbmRlcmluZydcbmltcG9ydCB7IGNyZWF0ZURlZHVwZWRCeUNhbGxzaXRlU2VydmVyRXJyb3JMb2dnZXJEZXYgfSBmcm9tICcuLi9jcmVhdGUtZGVkdXBlZC1ieS1jYWxsc2l0ZS1zZXJ2ZXItZXJyb3ItbG9nZ2VyJ1xuaW1wb3J0IHsgU3RhdGljR2VuQmFpbG91dEVycm9yIH0gZnJvbSAnLi4vLi4vY2xpZW50L2NvbXBvbmVudHMvc3RhdGljLWdlbmVyYXRpb24tYmFpbG91dCdcbmltcG9ydCB7IER5bmFtaWNTZXJ2ZXJFcnJvciB9IGZyb20gJy4uLy4uL2NsaWVudC9jb21wb25lbnRzL2hvb2tzLXNlcnZlci1jb250ZXh0J1xuaW1wb3J0IHsgSW52YXJpYW50RXJyb3IgfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL2ludmFyaWFudC1lcnJvcidcbmltcG9ydCB7IFJlZmxlY3RBZGFwdGVyIH0gZnJvbSAnLi4vd2ViL3NwZWMtZXh0ZW5zaW9uL2FkYXB0ZXJzL3JlZmxlY3QnXG5cbi8qKlxuICogSW4gdGhpcyB2ZXJzaW9uIG9mIE5leHQuanMgYGRyYWZ0TW9kZSgpYCByZXR1cm5zIGEgUHJvbWlzZSBob3dldmVyIHlvdSBjYW4gc3RpbGwgcmVmZXJlbmNlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSB1bmRlcmx5aW5nIGRyYWZ0TW9kZSBvYmplY3RcbiAqIHN5bmNocm9ub3VzbHkgdG8gZmFjaWxpdGF0ZSBtaWdyYXRpb24uIFRoZSBgVW5zYWZlVW53cmFwcGVkRHJhZnRNb2RlYCB0eXBlIGlzIGFkZGVkIHRvIHlvdXIgY29kZSBieSBhIGNvZGVtb2QgdGhhdCBhdHRlbXB0cyB0byBhdXRvbWF0aWNhbGx5XG4gKiB1cGRhdGVzIGNhbGxzaXRlcyB0byByZWZsZWN0IHRoZSBuZXcgUHJvbWlzZSByZXR1cm4gdHlwZS4gVGhlcmUgYXJlIHNvbWUgY2FzZXMgd2hlcmUgYGRyYWZ0TW9kZSgpYCBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQsIG5hbWVseVxuICogd2hlbiBpdCBpcyB1c2VkIGluc2lkZSBhIHN5bmNocm9ub3VzIGZ1bmN0aW9uIGFuZCB3ZSBjYW4ndCBiZSBzdXJlIHRoZSBmdW5jdGlvbiBjYW4gYmUgbWFkZSBhc3luYyBhdXRvbWF0aWNhbGx5LiBJbiB0aGVzZSBjYXNlcyB3ZSBhZGQgYW5cbiAqIGV4cGxpY2l0IHR5cGUgY2FzZSB0byBgVW5zYWZlVW53cmFwcGVkRHJhZnRNb2RlYCB0byBlbmFibGUgdHlwZXNjcmlwdCB0byBhbGxvdyBmb3IgdGhlIHN5bmNocm9ub3VzIHVzYWdlIG9ubHkgd2hlcmUgaXQgaXMgYWN0dWFsbHkgbmVjZXNzYXJ5LlxuICpcbiAqIFlvdSBzaG91bGQgc2hvdWxkIHVwZGF0ZSB0aGVzZSBjYWxsc2l0ZXMgdG8gZWl0aGVyIGJlIGFzeW5jIGZ1bmN0aW9ucyB3aGVyZSB0aGUgYGRyYWZ0TW9kZSgpYCB2YWx1ZSBjYW4gYmUgYXdhaXRlZCBvciB5b3Ugc2hvdWxkIGNhbGwgYGRyYWZ0TW9kZSgpYFxuICogZnJvbSBvdXRzaWRlIGFuZCBhd2FpdCB0aGUgcmV0dXJuIHZhbHVlIGJlZm9yZSBwYXNzaW5nIGl0IGludG8gdGhpcyBmdW5jdGlvbi5cbiAqXG4gKiBZb3UgY2FuIGZpbmQgaW5zdGFuY2VzIHRoYXQgcmVxdWlyZSBtYW51YWwgbWlncmF0aW9uIGJ5IHNlYXJjaGluZyBmb3IgYFVuc2FmZVVud3JhcHBlZERyYWZ0TW9kZWAgaW4geW91ciBjb2RlYmFzZSBvciBieSBzZWFyY2ggZm9yIGEgY29tbWVudCB0aGF0XG4gKiBzdGFydHMgd2l0aCBgQG5leHQtY29kZW1vZC1lcnJvcmAuXG4gKlxuICogSW4gYSBmdXR1cmUgdmVyc2lvbiBvZiBOZXh0LmpzIGBkcmFmdE1vZGUoKWAgd2lsbCBvbmx5IHJldHVybiBhIFByb21pc2UgYW5kIHlvdSB3aWxsIG5vdCBiZSBhYmxlIHRvIGFjY2VzcyB0aGUgdW5kZXJseWluZyBkcmFmdE1vZGUgb2JqZWN0IGRpcmVjdGx5XG4gKiB3aXRob3V0IGF3YWl0aW5nIHRoZSByZXR1cm4gdmFsdWUgZmlyc3QuIFdoZW4gdGhpcyBjaGFuZ2UgaGFwcGVucyB0aGUgdHlwZSBgVW5zYWZlVW53cmFwcGVkRHJhZnRNb2RlYCB3aWxsIGJlIHVwZGF0ZWQgdG8gcmVmbGVjdCB0aGF0IGlzIGl0IG5vIGxvbmdlclxuICogdXNhYmxlLlxuICpcbiAqIFRoaXMgdHlwZSBpcyBtYXJrZWQgZGVwcmVjYXRlZCB0byBoZWxwIGlkZW50aWZ5IGl0IGFzIHRhcmdldCBmb3IgcmVmYWN0b3JpbmcgYXdheS5cbiAqXG4gKiBAZGVwcmVjYXRlZFxuICovXG5leHBvcnQgdHlwZSBVbnNhZmVVbndyYXBwZWREcmFmdE1vZGUgPSBEcmFmdE1vZGVcblxuZXhwb3J0IGZ1bmN0aW9uIGRyYWZ0TW9kZSgpOiBQcm9taXNlPERyYWZ0TW9kZT4ge1xuICBjb25zdCBjYWxsaW5nRXhwcmVzc2lvbiA9ICdkcmFmdE1vZGUnXG4gIGNvbnN0IHdvcmtTdG9yZSA9IHdvcmtBc3luY1N0b3JhZ2UuZ2V0U3RvcmUoKVxuICBjb25zdCB3b3JrVW5pdFN0b3JlID0gd29ya1VuaXRBc3luY1N0b3JhZ2UuZ2V0U3RvcmUoKVxuXG4gIGlmICghd29ya1N0b3JlIHx8ICF3b3JrVW5pdFN0b3JlKSB7XG4gICAgdGhyb3dGb3JNaXNzaW5nUmVxdWVzdFN0b3JlKGNhbGxpbmdFeHByZXNzaW9uKVxuICB9XG5cbiAgc3dpdGNoICh3b3JrVW5pdFN0b3JlLnR5cGUpIHtcbiAgICBjYXNlICdyZXF1ZXN0JzpcbiAgICAgIHJldHVybiBjcmVhdGVPckdldENhY2hlZERyYWZ0TW9kZSh3b3JrVW5pdFN0b3JlLmRyYWZ0TW9kZSwgd29ya1N0b3JlKVxuXG4gICAgY2FzZSAnY2FjaGUnOlxuICAgIGNhc2UgJ3Vuc3RhYmxlLWNhY2hlJzpcbiAgICAgIC8vIEluc2lkZSBvZiBgXCJ1c2UgY2FjaGVcImAgb3IgYHVuc3RhYmxlX2NhY2hlYCwgZHJhZnQgbW9kZSBpcyBhdmFpbGFibGUgaWZcbiAgICAgIC8vIHRoZSBvdXRtb3N0IHdvcmsgdW5pdCBzdG9yZSBpcyBhIHJlcXVlc3Qgc3RvcmUsIGFuZCBpZiBkcmFmdCBtb2RlIGlzXG4gICAgICAvLyBlbmFibGVkLlxuICAgICAgY29uc3QgZHJhZnRNb2RlUHJvdmlkZXIgPSBnZXREcmFmdE1vZGVQcm92aWRlckZvckNhY2hlU2NvcGUoXG4gICAgICAgIHdvcmtTdG9yZSxcbiAgICAgICAgd29ya1VuaXRTdG9yZVxuICAgICAgKVxuXG4gICAgICBpZiAoZHJhZnRNb2RlUHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZU9yR2V0Q2FjaGVkRHJhZnRNb2RlKGRyYWZ0TW9kZVByb3ZpZGVyLCB3b3JrU3RvcmUpXG4gICAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UsIHdlIGZhbGwgdGhyb3VnaCB0byBwcm92aWRpbmcgYW4gZW1wdHkgZHJhZnQgbW9kZS5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICBjYXNlICdwcmVyZW5kZXInOlxuICAgIGNhc2UgJ3ByZXJlbmRlci1jbGllbnQnOlxuICAgIGNhc2UgJ3ByZXJlbmRlci1wcHInOlxuICAgIGNhc2UgJ3ByZXJlbmRlci1sZWdhY3knOlxuICAgICAgLy8gUmV0dXJuIGVtcHR5IGRyYWZ0IG1vZGVcbiAgICAgIHJldHVybiBjcmVhdGVPckdldENhY2hlZERyYWZ0TW9kZShudWxsLCB3b3JrU3RvcmUpXG5cbiAgICBkZWZhdWx0OlxuICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjazogbmV2ZXIgPSB3b3JrVW5pdFN0b3JlXG4gICAgICByZXR1cm4gX2V4aGF1c3RpdmVDaGVja1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU9yR2V0Q2FjaGVkRHJhZnRNb2RlKFxuICBkcmFmdE1vZGVQcm92aWRlcjogRHJhZnRNb2RlUHJvdmlkZXIgfCBudWxsLFxuICB3b3JrU3RvcmU6IFdvcmtTdG9yZSB8IHVuZGVmaW5lZFxuKTogUHJvbWlzZTxEcmFmdE1vZGU+IHtcbiAgY29uc3QgY2FjaGVLZXkgPSBkcmFmdE1vZGVQcm92aWRlciA/PyBOdWxsRHJhZnRNb2RlXG4gIGNvbnN0IGNhY2hlZERyYWZ0TW9kZSA9IENhY2hlZERyYWZ0TW9kZXMuZ2V0KGNhY2hlS2V5KVxuXG4gIGlmIChjYWNoZWREcmFmdE1vZGUpIHtcbiAgICByZXR1cm4gY2FjaGVkRHJhZnRNb2RlXG4gIH1cblxuICBsZXQgcHJvbWlzZTogUHJvbWlzZTxEcmFmdE1vZGU+XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICF3b3JrU3RvcmU/LmlzUHJlZmV0Y2hSZXF1ZXN0KSB7XG4gICAgY29uc3Qgcm91dGUgPSB3b3JrU3RvcmU/LnJvdXRlXG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0RZTkFNSUNfSU8pIHtcbiAgICAgIHJldHVybiBjcmVhdGVEcmFmdE1vZGVXaXRoRGV2V2FybmluZ3MoZHJhZnRNb2RlUHJvdmlkZXIsIHJvdXRlKVxuICAgIH1cblxuICAgIHByb21pc2UgPSBjcmVhdGVFeG90aWNEcmFmdE1vZGVXaXRoRGV2V2FybmluZ3MoZHJhZnRNb2RlUHJvdmlkZXIsIHJvdXRlKVxuICB9IGVsc2Uge1xuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfRFlOQU1JQ19JTykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgRHJhZnRNb2RlKGRyYWZ0TW9kZVByb3ZpZGVyKSlcbiAgICB9XG5cbiAgICBwcm9taXNlID0gY3JlYXRlRXhvdGljRHJhZnRNb2RlKGRyYWZ0TW9kZVByb3ZpZGVyKVxuICB9XG5cbiAgQ2FjaGVkRHJhZnRNb2Rlcy5zZXQoY2FjaGVLZXksIHByb21pc2UpXG5cbiAgcmV0dXJuIHByb21pc2Vcbn1cblxuaW50ZXJmYWNlIENhY2hlTGlmZXRpbWUge31cbmNvbnN0IE51bGxEcmFmdE1vZGUgPSB7fVxuY29uc3QgQ2FjaGVkRHJhZnRNb2RlcyA9IG5ldyBXZWFrTWFwPENhY2hlTGlmZXRpbWUsIFByb21pc2U8RHJhZnRNb2RlPj4oKVxuXG5mdW5jdGlvbiBjcmVhdGVFeG90aWNEcmFmdE1vZGUoXG4gIHVuZGVybHlpbmdQcm92aWRlcjogbnVsbCB8IERyYWZ0TW9kZVByb3ZpZGVyXG4pOiBQcm9taXNlPERyYWZ0TW9kZT4ge1xuICBjb25zdCBpbnN0YW5jZSA9IG5ldyBEcmFmdE1vZGUodW5kZXJseWluZ1Byb3ZpZGVyKVxuICBjb25zdCBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGluc3RhbmNlKVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCAnaXNFbmFibGVkJywge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBpbnN0YW5jZS5pc0VuYWJsZWRcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICB9KVxuICA7KHByb21pc2UgYXMgYW55KS5lbmFibGUgPSBpbnN0YW5jZS5lbmFibGUuYmluZChpbnN0YW5jZSlcbiAgOyhwcm9taXNlIGFzIGFueSkuZGlzYWJsZSA9IGluc3RhbmNlLmRpc2FibGUuYmluZChpbnN0YW5jZSlcblxuICByZXR1cm4gcHJvbWlzZVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFeG90aWNEcmFmdE1vZGVXaXRoRGV2V2FybmluZ3MoXG4gIHVuZGVybHlpbmdQcm92aWRlcjogbnVsbCB8IERyYWZ0TW9kZVByb3ZpZGVyLFxuICByb3V0ZTogdW5kZWZpbmVkIHwgc3RyaW5nXG4pOiBQcm9taXNlPERyYWZ0TW9kZT4ge1xuICBjb25zdCBpbnN0YW5jZSA9IG5ldyBEcmFmdE1vZGUodW5kZXJseWluZ1Byb3ZpZGVyKVxuICBjb25zdCBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGluc3RhbmNlKVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCAnaXNFbmFibGVkJywge1xuICAgIGdldCgpIHtcbiAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSAnYGRyYWZ0TW9kZSgpLmlzRW5hYmxlZGAnXG4gICAgICBzeW5jSU9EZXYocm91dGUsIGV4cHJlc3Npb24pXG4gICAgICByZXR1cm4gaW5zdGFuY2UuaXNFbmFibGVkXG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgfSlcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgJ2VuYWJsZScsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgY29uc3QgZXhwcmVzc2lvbiA9ICdgZHJhZnRNb2RlKCkuZW5hYmxlKClgJ1xuICAgICAgc3luY0lPRGV2KHJvdXRlLCBleHByZXNzaW9uKVxuICAgICAgcmV0dXJuIGluc3RhbmNlLmVuYWJsZS5hcHBseShpbnN0YW5jZSwgYXJndW1lbnRzIGFzIGFueSlcbiAgICB9LFxuICB9KVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCAnZGlzYWJsZScsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgY29uc3QgZXhwcmVzc2lvbiA9ICdgZHJhZnRNb2RlKCkuZGlzYWJsZSgpYCdcbiAgICAgIHN5bmNJT0Rldihyb3V0ZSwgZXhwcmVzc2lvbilcbiAgICAgIHJldHVybiBpbnN0YW5jZS5kaXNhYmxlLmFwcGx5KGluc3RhbmNlLCBhcmd1bWVudHMgYXMgYW55KVxuICAgIH0sXG4gIH0pXG5cbiAgcmV0dXJuIHByb21pc2Vcbn1cblxuLy8gU2ltaWxhciB0byBgY3JlYXRlRXhvdGljRHJhZnRNb2RlV2l0aERldldhcm5pbmdzYCwgYnV0IGp1c3QgbG9nZ2luZyB0aGUgc3luY1xuLy8gYWNjZXNzIHdpdGhvdXQgYWN0dWFsbHkgZGVmaW5pbmcgdGhlIGRyYWZ0TW9kZSBwcm9wZXJ0aWVzIG9uIHRoZSBwcm9taXNlLlxuZnVuY3Rpb24gY3JlYXRlRHJhZnRNb2RlV2l0aERldldhcm5pbmdzKFxuICB1bmRlcmx5aW5nUHJvdmlkZXI6IG51bGwgfCBEcmFmdE1vZGVQcm92aWRlcixcbiAgcm91dGU6IHVuZGVmaW5lZCB8IHN0cmluZ1xuKTogUHJvbWlzZTxEcmFmdE1vZGU+IHtcbiAgY29uc3QgaW5zdGFuY2UgPSBuZXcgRHJhZnRNb2RlKHVuZGVybHlpbmdQcm92aWRlcilcbiAgY29uc3QgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShpbnN0YW5jZSlcblxuICBjb25zdCBwcm94aWVkUHJvbWlzZSA9IG5ldyBQcm94eShwcm9taXNlLCB7XG4gICAgZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICAgIHN3aXRjaCAocHJvcCkge1xuICAgICAgICBjYXNlICdpc0VuYWJsZWQnOlxuICAgICAgICAgIHdhcm5Gb3JTeW5jQWNjZXNzKHJvdXRlLCBgXFxgZHJhZnRNb2RlKCkuJHtwcm9wfVxcYGApXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnZW5hYmxlJzpcbiAgICAgICAgY2FzZSAnZGlzYWJsZSc6IHtcbiAgICAgICAgICB3YXJuRm9yU3luY0FjY2Vzcyhyb3V0ZSwgYFxcYGRyYWZ0TW9kZSgpLiR7cHJvcH0oKVxcYGApXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgLy8gV2Ugb25seSB3YXJuIGZvciB3ZWxsLWRlZmluZWQgcHJvcGVydGllcyBvZiB0aGUgZHJhZnRNb2RlIG9iamVjdC5cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gUmVmbGVjdEFkYXB0ZXIuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpXG4gICAgfSxcbiAgfSlcblxuICByZXR1cm4gcHJveGllZFByb21pc2Vcbn1cblxuY2xhc3MgRHJhZnRNb2RlIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbCAtIHRoaXMgZGVjbGFyYXRpb24gaXMgc3RyaXBwZWQgdmlhIGB0c2MgLS1zdHJpcEludGVybmFsYFxuICAgKi9cbiAgcHJpdmF0ZSByZWFkb25seSBfcHJvdmlkZXI6IG51bGwgfCBEcmFmdE1vZGVQcm92aWRlclxuXG4gIGNvbnN0cnVjdG9yKHByb3ZpZGVyOiBudWxsIHwgRHJhZnRNb2RlUHJvdmlkZXIpIHtcbiAgICB0aGlzLl9wcm92aWRlciA9IHByb3ZpZGVyXG4gIH1cbiAgZ2V0IGlzRW5hYmxlZCgpIHtcbiAgICBpZiAodGhpcy5fcHJvdmlkZXIgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcm92aWRlci5pc0VuYWJsZWRcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgcHVibGljIGVuYWJsZSgpIHtcbiAgICAvLyBXZSBoYXZlIGEgc3RvcmUgd2Ugd2FudCB0byB0cmFjayBkeW5hbWljIGRhdGEgYWNjZXNzIHRvIGVuc3VyZSB3ZVxuICAgIC8vIGRvbid0IHN0YXRpY2FsbHkgZ2VuZXJhdGUgcm91dGVzIHRoYXQgbWFuaXB1bGF0ZSBkcmFmdCBtb2RlLlxuICAgIHRyYWNrRHluYW1pY0RyYWZ0TW9kZSgnZHJhZnRNb2RlKCkuZW5hYmxlKCknKVxuICAgIGlmICh0aGlzLl9wcm92aWRlciAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5fcHJvdmlkZXIuZW5hYmxlKClcbiAgICB9XG4gIH1cbiAgcHVibGljIGRpc2FibGUoKSB7XG4gICAgdHJhY2tEeW5hbWljRHJhZnRNb2RlKCdkcmFmdE1vZGUoKS5kaXNhYmxlKCknKVxuICAgIGlmICh0aGlzLl9wcm92aWRlciAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5fcHJvdmlkZXIuZGlzYWJsZSgpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN5bmNJT0Rldihyb3V0ZTogc3RyaW5nIHwgdW5kZWZpbmVkLCBleHByZXNzaW9uOiBzdHJpbmcpIHtcbiAgY29uc3Qgd29ya1VuaXRTdG9yZSA9IHdvcmtVbml0QXN5bmNTdG9yYWdlLmdldFN0b3JlKClcbiAgaWYgKFxuICAgIHdvcmtVbml0U3RvcmUgJiZcbiAgICB3b3JrVW5pdFN0b3JlLnR5cGUgPT09ICdyZXF1ZXN0JyAmJlxuICAgIHdvcmtVbml0U3RvcmUucHJlcmVuZGVyUGhhc2UgPT09IHRydWVcbiAgKSB7XG4gICAgLy8gV2hlbiB3ZSdyZSByZW5kZXJpbmcgZHluYW1pY2FsbHkgaW4gZGV2IHdlIG5lZWQgdG8gYWR2YW5jZSBvdXQgb2YgdGhlXG4gICAgLy8gUHJlcmVuZGVyIGVudmlyb25tZW50IHdoZW4gd2UgcmVhZCBSZXF1ZXN0IGRhdGEgc3luY2hyb25vdXNseVxuICAgIGNvbnN0IHJlcXVlc3RTdG9yZSA9IHdvcmtVbml0U3RvcmVcbiAgICB0cmFja1N5bmNocm9ub3VzUmVxdWVzdERhdGFBY2Nlc3NJbkRldihyZXF1ZXN0U3RvcmUpXG4gIH1cbiAgLy8gSW4gYWxsIGNhc2VzIHdlIHdhcm4gbm9ybWFsbHlcbiAgd2FybkZvclN5bmNBY2Nlc3Mocm91dGUsIGV4cHJlc3Npb24pXG59XG5cbmNvbnN0IHdhcm5Gb3JTeW5jQWNjZXNzID0gY3JlYXRlRGVkdXBlZEJ5Q2FsbHNpdGVTZXJ2ZXJFcnJvckxvZ2dlckRldihcbiAgY3JlYXRlRHJhZnRNb2RlQWNjZXNzRXJyb3JcbilcblxuZnVuY3Rpb24gY3JlYXRlRHJhZnRNb2RlQWNjZXNzRXJyb3IoXG4gIHJvdXRlOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gIGV4cHJlc3Npb246IHN0cmluZ1xuKSB7XG4gIGNvbnN0IHByZWZpeCA9IHJvdXRlID8gYFJvdXRlIFwiJHtyb3V0ZX1cIiBgIDogJ1RoaXMgcm91dGUgJ1xuICByZXR1cm4gbmV3IEVycm9yKFxuICAgIGAke3ByZWZpeH11c2VkICR7ZXhwcmVzc2lvbn0uIGAgK1xuICAgICAgYFxcYGRyYWZ0TW9kZSgpXFxgIHNob3VsZCBiZSBhd2FpdGVkIGJlZm9yZSB1c2luZyBpdHMgdmFsdWUuIGAgK1xuICAgICAgYExlYXJuIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL3N5bmMtZHluYW1pYy1hcGlzYFxuICApXG59XG5cbmZ1bmN0aW9uIHRyYWNrRHluYW1pY0RyYWZ0TW9kZShleHByZXNzaW9uOiBzdHJpbmcpIHtcbiAgY29uc3Qgc3RvcmUgPSB3b3JrQXN5bmNTdG9yYWdlLmdldFN0b3JlKClcbiAgY29uc3Qgd29ya1VuaXRTdG9yZSA9IHdvcmtVbml0QXN5bmNTdG9yYWdlLmdldFN0b3JlKClcbiAgaWYgKHN0b3JlKSB7XG4gICAgLy8gV2UgaGF2ZSBhIHN0b3JlIHdlIHdhbnQgdG8gdHJhY2sgZHluYW1pYyBkYXRhIGFjY2VzcyB0byBlbnN1cmUgd2VcbiAgICAvLyBkb24ndCBzdGF0aWNhbGx5IGdlbmVyYXRlIHJvdXRlcyB0aGF0IG1hbmlwdWxhdGUgZHJhZnQgbW9kZS5cbiAgICBpZiAod29ya1VuaXRTdG9yZSkge1xuICAgICAgaWYgKHdvcmtVbml0U3RvcmUudHlwZSA9PT0gJ2NhY2hlJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFJvdXRlICR7c3RvcmUucm91dGV9IHVzZWQgXCIke2V4cHJlc3Npb259XCIgaW5zaWRlIFwidXNlIGNhY2hlXCIuIFRoZSBlbmFibGVkIHN0YXR1cyBvZiBkcmFmdE1vZGUgY2FuIGJlIHJlYWQgaW4gY2FjaGVzIGJ1dCB5b3UgbXVzdCBub3QgZW5hYmxlIG9yIGRpc2FibGUgZHJhZnRNb2RlIGluc2lkZSBhIGNhY2hlLiBTZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL25leHQtcmVxdWVzdC1pbi11c2UtY2FjaGVgXG4gICAgICAgIClcbiAgICAgIH0gZWxzZSBpZiAod29ya1VuaXRTdG9yZS50eXBlID09PSAndW5zdGFibGUtY2FjaGUnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgUm91dGUgJHtzdG9yZS5yb3V0ZX0gdXNlZCBcIiR7ZXhwcmVzc2lvbn1cIiBpbnNpZGUgYSBmdW5jdGlvbiBjYWNoZWQgd2l0aCBcInVuc3RhYmxlX2NhY2hlKC4uLilcIi4gVGhlIGVuYWJsZWQgc3RhdHVzIG9mIGRyYWZ0TW9kZSBjYW4gYmUgcmVhZCBpbiBjYWNoZXMgYnV0IHlvdSBtdXN0IG5vdCBlbmFibGUgb3IgZGlzYWJsZSBkcmFmdE1vZGUgaW5zaWRlIGEgY2FjaGUuIFNlZSBtb3JlIGluZm8gaGVyZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2FwaS1yZWZlcmVuY2UvZnVuY3Rpb25zL3Vuc3RhYmxlX2NhY2hlYFxuICAgICAgICApXG4gICAgICB9IGVsc2UgaWYgKHdvcmtVbml0U3RvcmUucGhhc2UgPT09ICdhZnRlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBSb3V0ZSAke3N0b3JlLnJvdXRlfSB1c2VkIFwiJHtleHByZXNzaW9ufVwiIGluc2lkZSBcXGBhZnRlclxcYC4gVGhlIGVuYWJsZWQgc3RhdHVzIG9mIGRyYWZ0TW9kZSBjYW4gYmUgcmVhZCBpbnNpZGUgXFxgYWZ0ZXJcXGAgYnV0IHlvdSBjYW5ub3QgZW5hYmxlIG9yIGRpc2FibGUgZHJhZnRNb2RlLiBTZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9hcGktcmVmZXJlbmNlL2Z1bmN0aW9ucy9hZnRlcmBcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdG9yZS5keW5hbWljU2hvdWxkRXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBTdGF0aWNHZW5CYWlsb3V0RXJyb3IoXG4gICAgICAgIGBSb3V0ZSAke3N0b3JlLnJvdXRlfSB3aXRoIFxcYGR5bmFtaWMgPSBcImVycm9yXCJcXGAgY291bGRuJ3QgYmUgcmVuZGVyZWQgc3RhdGljYWxseSBiZWNhdXNlIGl0IHVzZWQgXFxgJHtleHByZXNzaW9ufVxcYC4gU2VlIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYnVpbGRpbmcteW91ci1hcHBsaWNhdGlvbi9yZW5kZXJpbmcvc3RhdGljLWFuZC1keW5hbWljI2R5bmFtaWMtcmVuZGVyaW5nYFxuICAgICAgKVxuICAgIH1cblxuICAgIGlmICh3b3JrVW5pdFN0b3JlKSB7XG4gICAgICBzd2l0Y2ggKHdvcmtVbml0U3RvcmUudHlwZSkge1xuICAgICAgICBjYXNlICdwcmVyZW5kZXInOlxuICAgICAgICAgIC8vIGR5bmFtaWNJTyBQcmVyZW5kZXJcbiAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBSb3V0ZSAke3N0b3JlLnJvdXRlfSB1c2VkICR7ZXhwcmVzc2lvbn0gd2l0aG91dCBmaXJzdCBjYWxsaW5nIFxcYGF3YWl0IGNvbm5lY3Rpb24oKVxcYC4gU2VlIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LXByZXJlbmRlci1zeW5jLWhlYWRlcnNgXG4gICAgICAgICAgKVxuICAgICAgICAgIGFib3J0QW5kVGhyb3dPblN5bmNocm9ub3VzUmVxdWVzdERhdGFBY2Nlc3MoXG4gICAgICAgICAgICBzdG9yZS5yb3V0ZSxcbiAgICAgICAgICAgIGV4cHJlc3Npb24sXG4gICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgIHdvcmtVbml0U3RvcmVcbiAgICAgICAgICApXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAncHJlcmVuZGVyLWNsaWVudCc6XG4gICAgICAgICAgY29uc3QgZXhwb3J0TmFtZSA9ICdgZHJhZnRNb2RlYCdcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YXJpYW50RXJyb3IoXG4gICAgICAgICAgICBgJHtleHBvcnROYW1lfSBtdXN0IG5vdCBiZSB1c2VkIHdpdGhpbiBhIGNsaWVudCBjb21wb25lbnQuIE5leHQuanMgc2hvdWxkIGJlIHByZXZlbnRpbmcgJHtleHBvcnROYW1lfSBmcm9tIGJlaW5nIGluY2x1ZGVkIGluIGNsaWVudCBjb21wb25lbnRzIHN0YXRpY2FsbHksIGJ1dCBkaWQgbm90IGluIHRoaXMgY2FzZS5gXG4gICAgICAgICAgKVxuICAgICAgICBjYXNlICdwcmVyZW5kZXItcHByJzpcbiAgICAgICAgICAvLyBQUFIgUHJlcmVuZGVyXG4gICAgICAgICAgcG9zdHBvbmVXaXRoVHJhY2tpbmcoXG4gICAgICAgICAgICBzdG9yZS5yb3V0ZSxcbiAgICAgICAgICAgIGV4cHJlc3Npb24sXG4gICAgICAgICAgICB3b3JrVW5pdFN0b3JlLmR5bmFtaWNUcmFja2luZ1xuICAgICAgICAgIClcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdwcmVyZW5kZXItbGVnYWN5JzpcbiAgICAgICAgICAvLyBsZWdhY3kgUHJlcmVuZGVyXG4gICAgICAgICAgd29ya1VuaXRTdG9yZS5yZXZhbGlkYXRlID0gMFxuXG4gICAgICAgICAgY29uc3QgZXJyID0gbmV3IER5bmFtaWNTZXJ2ZXJFcnJvcihcbiAgICAgICAgICAgIGBSb3V0ZSAke3N0b3JlLnJvdXRlfSBjb3VsZG4ndCBiZSByZW5kZXJlZCBzdGF0aWNhbGx5IGJlY2F1c2UgaXQgdXNlZCBcXGAke2V4cHJlc3Npb259XFxgLiBTZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2R5bmFtaWMtc2VydmVyLWVycm9yYFxuICAgICAgICAgIClcbiAgICAgICAgICBzdG9yZS5keW5hbWljVXNhZ2VEZXNjcmlwdGlvbiA9IGV4cHJlc3Npb25cbiAgICAgICAgICBzdG9yZS5keW5hbWljVXNhZ2VTdGFjayA9IGVyci5zdGFja1xuXG4gICAgICAgICAgdGhyb3cgZXJyXG4gICAgICAgIGNhc2UgJ3JlcXVlc3QnOlxuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgd29ya1VuaXRTdG9yZS51c2VkRHluYW1pYyA9IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gZmFsbHRocm91Z2hcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJkcmFmdE1vZGUiLCJjYWxsaW5nRXhwcmVzc2lvbiIsIndvcmtTdG9yZSIsIndvcmtBc3luY1N0b3JhZ2UiLCJnZXRTdG9yZSIsIndvcmtVbml0U3RvcmUiLCJ3b3JrVW5pdEFzeW5jU3RvcmFnZSIsInRocm93Rm9yTWlzc2luZ1JlcXVlc3RTdG9yZSIsInR5cGUiLCJjcmVhdGVPckdldENhY2hlZERyYWZ0TW9kZSIsImRyYWZ0TW9kZVByb3ZpZGVyIiwiZ2V0RHJhZnRNb2RlUHJvdmlkZXJGb3JDYWNoZVNjb3BlIiwiX2V4aGF1c3RpdmVDaGVjayIsImNhY2hlS2V5IiwiTnVsbERyYWZ0TW9kZSIsImNhY2hlZERyYWZ0TW9kZSIsIkNhY2hlZERyYWZ0TW9kZXMiLCJnZXQiLCJwcm9taXNlIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiaXNQcmVmZXRjaFJlcXVlc3QiLCJyb3V0ZSIsIl9fTkVYVF9EWU5BTUlDX0lPIiwiY3JlYXRlRHJhZnRNb2RlV2l0aERldldhcm5pbmdzIiwiY3JlYXRlRXhvdGljRHJhZnRNb2RlV2l0aERldldhcm5pbmdzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJEcmFmdE1vZGUiLCJjcmVhdGVFeG90aWNEcmFmdE1vZGUiLCJzZXQiLCJXZWFrTWFwIiwidW5kZXJseWluZ1Byb3ZpZGVyIiwiaW5zdGFuY2UiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImlzRW5hYmxlZCIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJlbmFibGUiLCJiaW5kIiwiZGlzYWJsZSIsImV4cHJlc3Npb24iLCJzeW5jSU9EZXYiLCJ2YWx1ZSIsImFwcGx5IiwiYXJndW1lbnRzIiwicHJveGllZFByb21pc2UiLCJQcm94eSIsInRhcmdldCIsInByb3AiLCJyZWNlaXZlciIsIndhcm5Gb3JTeW5jQWNjZXNzIiwiUmVmbGVjdEFkYXB0ZXIiLCJjb25zdHJ1Y3RvciIsInByb3ZpZGVyIiwiX3Byb3ZpZGVyIiwidHJhY2tEeW5hbWljRHJhZnRNb2RlIiwicHJlcmVuZGVyUGhhc2UiLCJyZXF1ZXN0U3RvcmUiLCJ0cmFja1N5bmNocm9ub3VzUmVxdWVzdERhdGFBY2Nlc3NJbkRldiIsImNyZWF0ZURlZHVwZWRCeUNhbGxzaXRlU2VydmVyRXJyb3JMb2dnZXJEZXYiLCJjcmVhdGVEcmFmdE1vZGVBY2Nlc3NFcnJvciIsInByZWZpeCIsIkVycm9yIiwic3RvcmUiLCJwaGFzZSIsImR5bmFtaWNTaG91bGRFcnJvciIsIlN0YXRpY0dlbkJhaWxvdXRFcnJvciIsImVycm9yIiwiYWJvcnRBbmRUaHJvd09uU3luY2hyb25vdXNSZXF1ZXN0RGF0YUFjY2VzcyIsImV4cG9ydE5hbWUiLCJJbnZhcmlhbnRFcnJvciIsInBvc3Rwb25lV2l0aFRyYWNraW5nIiwiZHluYW1pY1RyYWNraW5nIiwicmV2YWxpZGF0ZSIsImVyciIsIkR5bmFtaWNTZXJ2ZXJFcnJvciIsImR5bmFtaWNVc2FnZURlc2NyaXB0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LEtBQUs7b0JBRW5DLE1BQU1KO2dCQUNSLEtBQUs7b0JBQ0gsSUFBSTFELFFBQVFDLEdBQUcsQ0FBQ0MsUUFBUSxLQUFLLFdBQWU7d0JBQzFDaEIsY0FBYzZFLFdBQVcsR0FBRztvQkFDOUI7b0JBQ0E7Z0JBQ0Y7WUFFRjtRQUNGO0lBQ0Y7QUFDRiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxODI3LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvaGVhZGVycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cy5jb29raWVzID0gcmVxdWlyZSgnLi9kaXN0L3NlcnZlci9yZXF1ZXN0L2Nvb2tpZXMnKS5jb29raWVzXG5tb2R1bGUuZXhwb3J0cy5oZWFkZXJzID0gcmVxdWlyZSgnLi9kaXN0L3NlcnZlci9yZXF1ZXN0L2hlYWRlcnMnKS5oZWFkZXJzXG5tb2R1bGUuZXhwb3J0cy5kcmFmdE1vZGUgPSByZXF1aXJlKCcuL2Rpc3Qvc2VydmVyL3JlcXVlc3QvZHJhZnQtbW9kZScpLmRyYWZ0TW9kZVxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sT0FBTyxDQUFDLE9BQU8sR0FBRyxnSEFBeUMsT0FBTztBQUN6RSxPQUFPLE9BQU8sQ0FBQyxPQUFPLEdBQUcsZ0hBQXlDLE9BQU87QUFDekUsT0FBTyxPQUFPLENBQUMsU0FBUyxHQUFHLG1IQUE0QyxTQUFTIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX1dCn0=